<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.jamesshore.com/v2/projects/nullables/testing-without-mocks">Original</a>
    <h1>Testing Without Mocks: A Pattern Language (2023)</h1>
    
    <div id="readability-page-1" class="page"><div><p>Automated tests are important. Without them, programmers waste a huge amount of time manually checking and fixing their code.</p>

<p>Unfortunately, many automated tests <em>also</em> waste a huge amount of time. The easy, obvious way to write tests is to make <a href="https://martinfowler.com/bliki/BroadStackTest.html">broad tests</a> that are automated versions of manual tests. But they’re flaky and slow.</p>

<p>Folks in the know use mocks and spies (I say “mocks” for short in this article) to write isolated <a href="http://blog.jayfields.com/2008/02/behavior-based-testing.html">interaction-based tests</a>. Their tests are reliable and fast, but they tend to “lock in” implementation, making refactoring difficult, and they have to be supplemented with broad tests. It’s also easy to make poor-quality tests that are hard to read, or end up only testing themselves.</p>

<p>Bad tests are a sign of bad design, so some people use techniques such as <a href="https://en.wikipedia.org/wiki/Hexagonal_architecture_(software)">Hexagonal Architecture</a> and <a href="https://www.destroyallsoftware.com/screencasts/catalog/functional-core-imperative-shell">functional core, imperative shell</a> to separate logic from infrastructure. (Infrastructure is code that involves external systems or state.) It fixes the problem... for logic. But infrastructure is often left untested, and it requires architectural changes that are out of reach for people with existing code.</p>

<p>This pattern language<sup>1</sup> describes a fourth option. It avoids all the above problems: it doesn’t use broad tests, doesn’t use mocks, doesn’t ignore infrastructure, and doesn’t require architectural changes. It has the speed, reliability, and maintainability of unit tests and the power of broad tests. But it’s not without <a href="#tradeoffs">tradeoffs</a> of its own.</p>



<p>The patterns combine <a href="#sociable-tests">sociable</a>, <a href="#state-based-tests">state-based</a> tests with a novel infrastructure technique called “<a href="#nullables">Nullables</a>.” At first glance, Nullables look like test doubles, but they&#39;re actually production code with an “off” switch. And that’s the tradeoff: do you want that in your production code? Your answer determines whether this pattern language is for you.</p>

<p>The rest of the article goes into detail. Don’t be intimidated by its size. It’s broken up into bite-sized pieces with lots of code examples.</p>


<blockquote>
	<h3>Additional resources</h3>

	<p>For more resources related to Nullables and the “Testing Without Mocks” patterns, including screencasts, self-guided training, and more, see the <a href="https://teonbrooks.com/v2/projects/nullables">Nullables Hub</a>.</p>
</blockquote>

<!--<blockquote class="site-notice">-->
<!--  <h3>“Testing Without Mocks” Training</h3>-->

<!--  <iframe class="framed youtube figure" width="560" height="315" src="https://www.youtube.com/embed/63GD6zSXZTc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>-->

<!--<!–  <div style="margin-top: var(--p-spacing)">–>-->
<!--<!–    <a href="/s/nullables-training?twm-article-head">–>-->
<!--<!–      <div style="font-size: 1em" class="calendar-page">–>-->
<!--<!–        <div class="calendar-page__month">Jun</div>–>-->
<!--<!–        <div class="calendar-page__day">6</div>–>-->
<!--<!–        <div class="calendar-page__year">2023</div>–>-->
<!--<!–      </div>–>-->
<!--<!–    </a>–>-->

<!--<!–    <p>I’m offering <a href="/s/nullables-training?twm-article-head">live online training</a> for this material in four 3-hour sessions from June 6th to 15th. <strong><a href="/s/nullables-training?twm-article-head">Register here.</a></strong></p>–>-->

<!--    <p>To be notified about future “Testing Without Mocks” training courses, <a href="https://groups.google.com/g/nullables-training/about">join the mailing list here</a> (requires Google login).</p>-->

<!--    <p>For private training, <a href="/v2/services/contact">contact me directly</a>.</p>-->
<!--  </div>-->
<!--</blockquote>-->


<h3 id="toc">Contents:</h3>

<ul>
  <li><a href="#examples">Examples</a></li>
  <li><a href="#goals">Goals</a></li>
  <li><a href="#tradeoffs">Tradeoffs</a></li>
  <li>
    <a href="#foundational-patterns">Foundational Patterns</a>
    <ul>
      <li><a href="#narrow-tests">Narrow Tests</a></li>
      <li><a href="#state-based-tests">State-Based Tests</a></li>
      <li><a href="#sociable-tests">Overlapping Sociable Tests</a></li>
      <li><a href="#smoke-tests">Smoke Tests</a></li>
      <li><a href="#zero-impact">Zero-Impact Instantiation</a></li>
      <li><a href="#instantiation">Parameterless Instantiation</a></li>
      <li><a href="#sig-shielding">Signature Shielding</a></li>
    </ul>
  </li>
  <li>
    <a href="#arch-patterns">Architectural Patterns</a>
    <ul>
      <li><a href="#a-frame-arch">A-Frame Architecture</a></li>
      <li><a href="#logic-sandwich">Logic Sandwich</a></li>
      <li><a href="#traffic-cop">Traffic Cop</a></li>
      <li><a href="#grow-seeds">Grow Evolutionary Seeds</a></li>
    </ul>
  </li>
  <li>
    <a href="#logic-patterns">Logic Patterns</a>
    <ul>
      <li><a href="#visible-behavior">Easily-Visible Behavior</a></li>
      <li><a href="#testable-libraries">Testable Libraries</a></li>
      <li><a href="#isolation">Collaborator-Based Isolation</a></li>
    </ul>
  </li>
  <li>
    <a href="#infrastructure-patterns">Infrastructure Patterns</a>
    <ul>
      <li><a href="#infrastructure-wrappers">Infrastructure Wrappers</a></li>
      <li><a href="#narrow-integration-tests">Narrow Integration Tests</a></li>
      <li><a href="#paranoic-telemetry">Paranoic Telemetry</a></li>
    </ul>
  </li>
  <li>
   <a href="#nullability-patterns">Nullability Patterns</a>
   <ul>
     <li><a href="#nullables">Nullables</a></li>
     <li><a href="#embedded-stub">Embedded Stub</a></li>
     <li><a href="#thin-wrapper">Thin Wrapper</a></li>
     <li><a href="#configurable-responses">Configurable Responses</a></li>
     <li><a href="#output-tracking">Output Tracking</a></li>
     <li><a href="#behavior-simulation">Behavior Simulation</a></li>
     <li><a href="#fake-it">Fake It Once You Make It</a></li>
   </ul>
 </li>
  <li>
    <a href="#legacy-patterns">Legacy Code Patterns</a>
    <ul>
      <li><a href="#descend-ladder">Descend the Ladder</a></li>
      <li><a href="#climb-ladder">Climb the Ladder</a></li>
      <li><a href="#replace-mocks-with-nullables">Replace Mocks with Nullables</a></li>
      <li><a href="#throwaway-stub">Throwaway Stub</a></li>
    </ul>
  </li>
  <li><a href="#conclusion">Conclusion</a></li>
</ul>


<h3 id="examples">Examples</h3>

<p>Here’s an example of testing a simple command line application. The application reads a string from the command line, encodes it using <a href="https://en.wikipedia.org/wiki/ROT13">ROT-13</a>, and outputs the result.</p>

<p>The production code uses the optional <a href="#a-frame-arch">A-Frame Architecture</a> pattern. <code>App</code> is the application entry point. It depends on <code>Rot13</code>, a <a href="#logic-patterns">Logic</a> class, and <code>CommandLine</code>, an <a href="#infrastructure-patterns">Infrastructure</a> class. Additional patterns are mentioned in the source code.</p>

<pre><code>// Example production code (JavaScript + Node.js)
import CommandLine from &#34;./infrastructure/command_line&#34;;  // <a href="#infrastructure-wrappers">Infrastructure Wrapper</a>
import * as rot13 from &#34;./logic/rot13&#34;;

export default class App {
  constructor(commandLine = CommandLine.create()) {   // <a href="#instantiation">Parameterless Instantiation</a>
    this._commandLine = commandLine;
  }

  run() {
    const args = this._commandLine.args();

    if (args.length === 0) {    <em>// Tested by Test #2</em>
      this._commandLine.writeOutput(&#34;Usage: run text_to_transform\n&#34;);
      return;
    }
    if (args.length !== 1) {    <em>// Tested by Test #3</em>
      this._commandLine.writeOutput(&#34;too many arguments\n&#34;);
      return;
    }

    <em>// Tested by Test #1</em>
    const input = args[0];                          // <a href="#logic-sandwich">Logic Sandwich</a>
    const output = rot13.transform(input);
    this._commandLine.writeOutput(output + &#34;\n&#34;);
  }
};
</code></pre>

<p>The tests of <code>App</code> look like end-to-end integration tests, but they’re actually <a href="https://www.artima.com/weblogs/viewpost.jsp?thread=126923">unit tests</a>. Technically, they’re <a href="#narrow-tests">Narrow</a>, <a href="#sociable-tests">Sociable</a> tests, which means they’re unit tests that execute code in dependencies.</p>

<p>As narrow tests, the tests only care about testing <code>App.run()</code>. Each of the dependencies is expected to have tests of their own, which they do.</p>

<p>The tests use a <a href="#nullables">Nullable</a> <code>CommandLine</code> to throw away <code>stdout</code> and <a href="#configurable-responses">Configurable Responses</a> to provide pre-configured command-line arguments. They also use <a href="#output-tracking">Output Tracking</a> to see what would have been written to <code>stdout</code>.</p>

<pre><code>// Example tests (JavaScript + Node.js)
import assert from &#34;assert&#34;;
import CommandLine from &#34;./infrastructure/command_line&#34;;
import App from &#34;./app&#34;;

describe(&#34;App&#34;, () =&gt; {
  <em>// Test #1</em>
  it(&#34;reads command-line argument, transform it with ROT-13, and writes result&#34;, () =&gt; {
    const { output } = run({ args: [ &#34;my input&#34; ] });     // <a href="#sig-shielding">Signature Shielding</a>, <a href="#configurable-responses">Configurable Responses</a>
    assert.deepEqual(output.data, [ &#34;zl vachg\n&#34; ];       // <a href="#output-tracking">Output Tracking</a>
  });

  <em>// Test #2</em>
  it(&#34;writes usage when no argument provided&#34;, () =&gt; {
    const { output } = run({ args: [] });                                 // <a href="#sig-shielding">Signature Shielding</a>, <a href="#configurable-responses">Configurable Responses</a>
    assert.deepEqual(output.data, [ &#34;Usage: run text_to_transform\n&#34; ]);  // <a href="#output-tracking">Output Tracking</a>
  });

  <em>// Test #3</em>
  it(&#34;complains when too many command-line arguments provided&#34;, () =&gt; {
    const { output } = run({ args: [ &#34;a&#34;, &#34;b&#34; ] });                       // <a href="#sig-shielding">Signature Shielding</a>, <a href="#configurable-responses">Configurable Responses</a>
    assert.deepEqual(output.data, [ &#34;too many arguments\n&#34; ]);            // <a href="#output-tracking">Output Tracking</a>
  });

  function run({ args = [] } = {}) {                      // <a href="#sig-shielding">Signature Shielding</a>
    const commandLine = CommandLine.createNull({ args }); // <a href="#nullables">Nullable</a>, <a href="#infrastructure-wrappers">Infrastructure Wrapper</a>, <a href="#configurable-responses">Configurable Responses</a>
    const output = commandLine.trackOutput();             // <a href="#output-tracking">Output Tracking</a>

    const app = new App(commandLine);
    app.run();

    return { output };                                    // <a href="#sig-shielding">Signature Shielding</a>
  }
});
</code></pre>

<p>If you’re familiar with mocks, you might assume <code>CommandLine</code> is a test double. But it’s actually production code with an “off” switch and the ability to monitor its output.</p>

<pre><code>// Example Nullable infrastructure wrapper (JavaScript + Node.js)
import EventEmitter from &#34;node:events&#34;;
import OutputTracker from &#34;output_tracker&#34;;

const OUTPUT_EVENT = &#34;output&#34;;

export default class CommandLine {
  static create() {
    return new CommandLine(process);                  // &#39;process&#39; is a Node.js global
  }

  static createNull({ args = [] } = {}) {             // <a href="#instantiation">Parameterless Instantiation</a>, <a href="#configurable-responses">Configurable Responses</a>
    return new CommandLine(new StubbedProcess(args)); // <a href="#embedded-stub">Embedded Stub</a>
  }

  constructor(proc) {
    this._process = proc;
    this._emitter = new EventEmitter();               // <a href="#output-tracking">Output Tracking</a>
  }

  args() {
    return this._process.argv.slice(2);
  }

  writeOutput(text) {
    this._process.stdout.write(text);
    this._emitter.emit(OUTPUT_EVENT, text);           // <a href="#output-tracking">Output Tracking</a>
  }

  trackOutput() {                                     // <a href="#output-tracking">Output Tracking</a>
    return OutputTracker.create(this._emitter, OUTPUT_EVENT);
  }
};

// <a href="#embedded-stub">Embedded Stub</a>
class StubbedProcess {
  constructor(args) {
    this._args = args;                                // <a href="#configurable-responses">Configurable Responses</a>
  }

  get argv() {
    return [ &#34;nulled_process_node&#34;, &#34;nulled_process_script.js&#34;, ...this._args ];
  }

  get stdout() {
    return {
      write() {}
    };
  }
}
</code></pre>

<p>The patterns shine in more complex code that has multiple layers of dependencies. Find more examples here:</p>

<ul>
	<li><p><strong><a href="https://github.com/jamesshore/testing-without-mocks-example">Simple example.</a></strong> The complete source code for the above example. (<a href="https://github.com/jamesshore/testing-without-mocks-example/tree/javascript">JavaScript</a> or
<a href="https://github.com/jamesshore/testing-without-mocks-example/tree/typescript">TypeScript</a> with Node.js)</p></li>

  <li><p><strong><a href="https://github.com/jamesshore/testing-without-mocks-complex">Complex example.</a></strong> The blinged-out version of the above example. A web application and microservice that performs ROT-13 encoding. Production-grade code with error handling, logging, timeouts, and request cancellation. (<a href="https://github.com/jamesshore/testing-without-mocks-complex/tree/javascript">JavaScript</a> or <a href="https://github.com/jamesshore/testing-without-mocks-complex/tree/typescript">TypeScript</a> with Node.js)</p></li>

  <li><p><strong><a href="https://teonbrooks.com/v2/projects/lunch-and-learn">TDD Lunch &amp; Learn Screencast.</a></strong> A series of one-hour webinars that demonstrate how to use the patterns. (JavaScript with Node.js)</p></li>

  <li><p><strong><a href="https://teonbrooks.com/v2/projects/nullables/jitterted-livestream">Nullables Livestream.</a></strong> A series of three-hour livestreams with James Shore and Ted M. Young. They pair on applying the patterns to an existing web application. (Java with Spring Boot)</p></li>
</ul>

<p><a href="#toc">Contents</a></p>


<h3 id="goals">Goals</h3>

<p>This pattern language was created to satisfy these goals:</p>

<ul>
  <li><p><em>No broad tests required.</em> The test suite consists entirely of “<a href="https://martinfowler.com/bliki/IntegrationTest.html">narrow</a>” tests that are focused on specific concepts. Although broad integration tests can be added as a safety net, their failure indicates a gap in the main test suite.</p></li>

  <li><p><em>Easy refactoring.</em> Object interactions are considered implementation to be encapsulated, not behavior to be tested. Although the consequences of object interactions are tested, the specific method calls aren’t. This allows structural refactorings to be made without breaking tests.</p></li>

  <li><p><em>Readable tests.</em> Tests follow a straightforward “arrange, act, assert” structure. They describe the externally-visible behavior of the unit under test, not its implementation. They can act as documentation for the unit under test.</p></li>

  <li><p><em>No magic.</em> Tools that automatically remove busywork, such as dependency-injection frameworks and auto-mocking frameworks, are not required.</p></li>

  <li><p><em>Fast and deterministic.</em> The test suite only executes “slow” code, such as network calls or file system requests, when that behavior is explicitly part of the unit under test. Such tests are organized so they produce the same results on every test run.</p></li>
</ul>

<p>Experience has revealed these additional benefits:</p>

<ul>
  <li><p><em>Faster than mocking frameworks.</em> In a head-to-head comparison, tests using these patterns were 2–3 orders of magnitude faster than tests using a mocking framework. (<a href="https://github.com/jamesshore/livestream/blob/rot13-cli/src/_comparisons_test.js">Comparison code here</a>.)</p></li>

  <li><p><em>Simple test setup.</em> Test setup is straightforward and easy to encapsulate in helper methods.</p></li>

  <li><p><em>High reusability.</em> The most complicated code needed for these patterns is also the most generic and reusable.</p>

  </li><li><p><em>In-memory infrastructure testing.</em> High-level infrastructure wrappers, such as a client for a specific web service, can be tested without network calls or complicated setup. (<a href="https://github.com/jamesshore/livestream/blob/2020-09-22-end/src/rot13-cli/infrastructure/_rot13_client_test.js#L22-L35">Example test</a>.)</p></li>

  <li><p><em>Edge case support.</em> It’s easy to test complex edge cases, such as error conditions and timeouts. (<a href="https://github.com/jamesshore/livestream/blob/2020-09-22-end/src/rot13-cli/_rot13_cli_test.js#L34-L67">Example tests</a>.)</p></li>

  <li><p><em>Legacy code compatibility.</em> The patterns are completely compatible with mocks and other test doubles, and can even be used together in the same test. Legacy code can be converted incrementally without impacting existing code.</p></li>
</ul>

<p><a href="#toc">Contents</a></p>


<h3 id="tradeoffs">Tradeoffs</h3>

<p>Nothing’s perfect. These are the downsides of using this pattern language:</p>

<ul>
  <li><p><em>Changes to production code.</em> The patterns require you to modify your production code, particularly for infrastructure classes. Although the modifications are usable in production, and have production use cases, many of the changes will only be used by tests.</p>

  </li><li><p><em>Hand-written stub code.</em> Some third-party infrastructure code has to be mimicked with hand-written stub code. It can’t be auto-generated and takes extra time to write. However, the results are highly reusable.</p></li>

  <li><p><em>Multiple test failures.</em> Although tests are written to focus on specific concepts, the units under test execute code in their dependencies. (Jay Fields coined the term “<a href="https://martinfowler.com/bliki/UnitTest.html">sociable tests</a>” for this behavior.) This can result in multiple tests failing when a bug is introduced.</p></li>
</ul>

<p><a href="#toc">Contents</a></p>


<h3 id="foundational-patterns">Foundational Patterns</h3>

<p>Start here. These patterns establish the ground rules.</p>

<ul>
  <li><a href="#narrow-tests">Narrow Tests</a></li>
  <li><a href="#state-based-tests">State-Based Tests</a></li>
  <li><a href="#sociable-tests">Overlapping Sociable Tests</a></li>
  <li><a href="#smoke-tests">Smoke Tests</a></li>
  <li><a href="#zero-impact">Zero-Impact Instantiation</a></li>
  <li><a href="#instantiation">Parameterless Instantiation</a></li>
  <li><a href="#sig-shielding">Signature Shielding</a></li>
</ul>


<h4 id="narrow-tests">Narrow Tests</h4>

<p>Broad tests, such as end-to-end tests, tend to be slow and brittle. They’re complicated to read and write, often fail randomly, and take a long time to run. <em>Therefore:</em></p>

<p>Instead of using broad tests, use narrow tests. Narrow tests check a specific function or behavior, not the system as a whole. Unit tests are a common type of narrow tests.</p>

<p>When testing infrastructure, use <a href="#narrow-integration-tests">Narrow Integration Tests</a>. When testing pure logic, use the <a href="#logic-patterns">Logic Patterns</a>. When testing code that has infrastructure dependencies, use <a href="#nullables">Nullables</a>.</p>

<p>To ensure your code works as a whole, use <a href="#state-based-tests">State-Based Tests</a> and <a href="#sociable-tests">Overlapping Sociable Tests</a>.</p>

<p><a href="#toc">Contents</a></p>


<h4 id="state-based-tests">State-Based Tests</h4>

<p>Mocks and spies result in “interaction-based” tests that check how the code under test uses its dependencies. However, they can be hard to read, and they tend to “lock in” your dependencies, which makes structural refactorings difficult. <em>Therefore:</em></p>

<p>Use state-based tests instead of interaction-based tests. A state-based test checks the output or state of the code under test, without any awareness of its implementation. For example, given the following production code:</p>

<pre><code>// Production code to describe phase of moon (JavaScript)
import * as moon from &#34;astronomy&#34;;
import { format } from &#34;date_formatter&#34;;

export function describeMoonPhase(date) {
  const visibility = moon.getPercentOccluded(date);
  const phase = moon.describePhase(visibility);
  const formattedDate = format(date);
  return `The moon is ${phase} on ${formattedDate}.`;
}
</code></pre>

<p>A state-based test would pass in a date and check the result, like this:</p>

<pre><code>// State-based test of describeMoonPhase() (JavaScript)
import { describeMoonPhase } from &#34;describe_phase&#34;;

it(&#34;describes phase of moon&#34;, () =&gt; {
  const dateOfFullMoon = new Date(&#34;8 Dec 2022&#34;);    // a date when the moon was actually full
  const description = describeMoonPhase(dateOfFullMoon);
  assert.equal(description, &#34;The moon is full on December 8th, 2022.&#34;;
});
</code></pre>

<p>In contrast, an interaction-based test would check how each dependency was used, like this:</p>

<pre><code>// Interaction-based test of describeMoonPhase() (JavaScript and fictional mocking framework)
const moon = mocker.mockImport(&#34;astronomy&#34;);
const { format } = mocker.mockImport(&#34;date_formatter&#34;);
const { describeMoonPhase } = mocker.importWithMocks(&#34;describe_phase&#34;);

it(&#34;describes phase of moon&#34;, () =&gt; {
  const date = new Date();    // specific date doesn&#39;t matter

  mocker.expect(moon.getPercentOccluded).toBeCalledWith(date).thenReturn(999);
  mocker.expect(moon.describePhase).toBeCalledWith(999).thenReturn(&#34;PHASE&#34;);
  mocker.expect(format).toBeCalledWith(date).thenReturn(&#34;DATE&#34;);

  const description = describeMoonPhase(date);
  mocker.verify();
  assert.equal(description, &#34;The moon is PHASE on DATE&#34;);
};
</code></pre>

<p>State-based tests naturally result in <a href="#sociable-tests">Overlapping Sociable Tests</a>. To use state-based tests on code with infrastructure dependencies, use the <a href="#nullability-patterns">Nullability Patterns</a>.</p>

<p><a href="#toc">Contents</a></p>


<h4 id="sociable-tests">Overlapping Sociable Tests</h4>

<p>Tests using mocks and other test doubles isolate the code under test by replacing its dependencies. This requires broad tests to confirm that the system works as a whole, but we don’t want to use broad tests. <em>Therefore:</em></p>

<p>When testing the interactions between an object and its dependencies, use the code under test’s real dependencies. Don’t test the dependencies’ behavior, but do test that the code under test uses its dependencies correctly. This happens naturally when using <a href="#state-based-tests">State-Based Tests</a>.</p>

<p>For example, the following test checks that <code>describeMoonPhase</code> uses its <code>Moon</code> and <code>format</code> dependencies correctly. If they don’t work the way <code>describeMoonPhase</code> thinks they do, the test will fail.</p>

<pre><code>// Example of sociable tests (JavaScript)

// Test code
it(&#34;describes phase of moon&#34;, () =&gt; {
  const dateOfFullMoon = new Date(&#34;8 Dec 2022&#34;);
  const description = describeMoonPhase(dateOfFullMoon);
  assert.equal(description, &#34;The moon is full on December 8th, 2022.&#34;;
};

// Production code
describeMoonPhase(date) {
  const visibility = moon.getPercentOccluded(date);
  const phase = moon.describePhase(visibility);
  const formattedDate = format(date);
  return `The moon is ${phase} on ${formattedDate}.`;
}
</code></pre>

<p>Write <a href="#narrow-tests">Narrow Tests</a> that are focused on the behavior of the code under test, not the behavior of its dependencies. Each dependency should have its own thorough set of Narrow Tests. For example, <em>don’t</em> test all phases of the moon in your <code>describeMoonPhase()</code> tests, but <em>do</em> test them in your <code>Moon</code> tests. Similarly, <em>don’t</em> check the intricacies of date formatting in your <code>describeMoonPhase</code> tests, but <em>do</em> test them in your <code>format(date)</code> tests.</p>

<p>In addition to checking how your code uses its dependencies, sociable tests also protect you against future breaking changes. Each test overlaps with dependencies’ tests and dependents’ tests, creating a strong linked chain of tests. This gives you the coverage of broad tests without their speed and reliability problems.</p>

<p>For example, imagine the dependency chain <code>LoginController</code> → <code>Auth0Client</code> → <code>HttpClient</code>:</p>

<ul>
  <li><p>The <code>LoginController</code> tests checks that <code>LoginController</code> is correct, including how it uses <code>Auth0Client</code>. (<code>Auth0Client</code> in turn runs <code>HttpClient</code>, but that isn’t explicitly checked by the <code>LoginController</code> tests.)</p></li>
  <li><p>The <code>Auth0Client</code> tests check that <code>Auth0Client</code> is correct, including how it uses <code>HttpClient</code>.</p></li>
  <li><p>The <code>HttpClient</code> tests check that <code>HttpClient</code> is correct, including using <a href="#narrow-integration-tests">Narrow Integration Tests</a> to check how it communicates with HTTP servers.</p></li>
  <li><p>Together, they ensure the whole chain is checked. Even if <code>HttpClient</code> and its tests are changed intentionally, if that change breaks <code>Auth0Client</code>, its tests would fail (and possibly the <code>LoginController</code> tests, too). Changing <code>Auth0Client</code>’s behavior would similarly break the <code>LoginController</code> tests.</p></li>
</ul>

<p>In contrast, if the <code>LoginController</code> tests stubbed or mocked out <code>Auth0Client</code>, the chain would be broken. Changing <code>Auth0Client</code>’s behavior would not break the <code>LoginController</code> tests, because nothing would check how <code>LoginController</code> used the real <code>Auth0Client</code>.

</p><p>To avoid manually constructing the entire dependency chain, use <a href="#instantiation">Parameterless Instantiation</a> with <a href="#zero-impact">Zero-Impact Instantiation</a>. To isolate tests from changes in dependencies’ behavior, use <a href="#isolation">Collaborator-Based Isolation</a>. To prevent your tests from interacting with external systems and state, use <a href="#nullables">Nullables</a>. To catch breaking changes in external systems, use <a href="#paranoic-telemetry">Paranoic Telemetry</a>. For a safety net, use <a href="#smoke-tests">Smoke Tests</a>.</p>

<p><a href="#toc">Contents</a></p>


<h4 id="smoke-tests">Smoke Tests</h4>

<p><a href="#sociable-tests">Overlapping Sociable Tests</a> are supposed to cover your entire system. But nobody’s perfect, and mistakes happen. <em>Therefore:</em>

</p><p>Write one or two end-to-end tests that make sure your code starts up and runs a common workflow. For example, if you’re coding a web site, check that you can get an important page.</p>

<p>Don’t rely on smoke tests to catch errors. Your real test suite should consist of <a href="#narrow-tests">Narrow</a>, <a href="#sociable-tests">Sociable</a> tests. If the smoke tests catch something the rest of your tests don’t, fill the gap with more narrow tests.</p>

<p><a href="#toc">Contents</a></p>


<h4 id="zero-impact">Zero-Impact Instantiation</h4>

<p><a href="#sociable-tests">Overlapping Sociable Tests</a> instantiate their dependencies, which in turn instantiate their dependencies, and so forth. If instantiating this web of dependencies takes too long or causes side effects, the tests could be slow, difficult to set up, or fail unpredictably. <em>Therefore:</em></p>

<p>Don’t do significant work in constructors. Don’t connect to external systems, start services, or perform long calculations. For code that needs to connect to an external system or start a service, provide a <code>connect()</code> or <code>start()</code> method. For code that needs to perform a long calculation, consider <a href="https://martinfowler.com/bliki/LazyInitialization.html">lazy initialization</a>. (But even complex calculations aren’t likely to be a problem, so profile before optimizing.)</p>

<p><a href="#toc">Contents</a></p>


<h4 id="instantiation">Parameterless Instantiation</h4>

<p><a href="#sociable-tests">Overlapping Sociable Tests</a> require your whole dependency tree to be instantiated, but multi-level dependency chains are difficult to set up in tests. Dependency injection (DI) frameworks work around the problem, but we don’t want to require such magic. <em>Therefore:</em></p>

<p>Ensure all classes have a constructor or factory that doesn’t take any parameters. This factory (or constructor) should have sensible defaults that set up everything the object needs, including instantiating its dependencies. You can make these defaults overridable if desired. (If your language doesn’t support overridable defaults, use method overloading or an Options object, as shown in the <a href="#sig-shielding">Signature Shielding</a> pattern.)</p>

<p>For some classes, particularly <a href="https://www.martinfowler.com/bliki/ValueObject.html">Value Objects</a>, a parameterless factory isn’t a good idea in production, because people could forget to provide a necessary value. For example, an immutable <code>Address</code> class should be constructed with its street, city, and so forth. Providing a default city could result in addresses that seemed to work, but actually had the wrong city.</p>

<p>In that case, provide a test-specific factory method with overridable defaults. Choose defaults that make the class work in as many situations as possible, and use a name such as <code>createTestInstance()</code> to indicate that it’s only for tests. In your tests,  pass in every parameter your test cares about, rather than relying on default values. That way, changes to the factory won’t break your tests.</p>

<pre><code>// Test-specific factory using named, optional parameters (JavaScript)
class Address {
  <em>// Production constructor</em>
  constructor(street, city, state, country, postalCode) {
    this._street = street;
    this._city = city;
    //...etc...
  }

  <em>// Test-specific factory</em>
  static createTestInstance({
    street = &#34;Address test street&#34;,
    city = &#34;Address test city&#34;,
    state = State.createTestInstance(),
    country = Country.createTestInstance(),
    postalCode = PostalCode.createTestInstance(),
  } = {}) {
    return new Address(street, city, state, country, postalCode);
  }
}
</code></pre>

<p>This test-specific factory method is easiest to maintain if it’s located in the production code next to the real constructors. However, if you don’t want test-specific code in production, or if the logic gets complicated, you can use the <a href="https://www.martinfowler.com/bliki/ObjectMother.html">Object Mother</a> pattern to put it in a test-only helper module instead.</p>

<p><a href="#toc">Contents</a></p>


<h4 id="sig-shielding">Signature Shielding</h4>

<p>As you refactor your application, method signatures will change. If your code is well-designed, this won’t be a problem for production code, because most methods will only be used in a few places. But tests can have many duplicated method and constructor calls. When you change those methods or constructors, you’ll have a lot of busywork to update the tests. <em>Therefore:</em></p>

<p>Provide helper functions to instantiate classes and call methods. Have these helper functions perform any setup your tests need rather than using your test framework’s <code>before()</code> or <code>setup()</code> functions.</p>

<p>Make the helper functions take optional parameters for customizing your setup and execution. If convenient in your programming language, return multiple optional values as well. This will allow you to expand your helper functions without breaking existing tests.</p>

<pre><code>// Optional parameters and multiple return values (JavaScript)

<em>// Example test</em>
it(&#34;uses hosted page for authentication&#34;, () =&gt; {
  const { url } = getLoginUrl({       <em>// Use the helper function</em>
    host: &#34;my.host&#34;,
    clientId: &#34;my_client_id&#34;,
    callbackUrl: &#34;my_callback_url&#34;
  });

  assert.equal(url, &#34;https://my.host/authorize?response_type=code&amp;client_id=my_client_id&amp;callback_url=my_callback_url&#34;);
});

<em>// Example helper function</em>
function getLoginUrl({
  host = &#34;irrelevant.host&#34;,           // Optional parameters
  clientId = &#34;irrelevant_client_id&#34;,
  clientSecret = &#34;irrelevant_secret&#34;,
  connection = &#34;irrelevant_connection&#34;
  username = &#34;irrelevant_username&#34;,
  callbackUrl = &#34;irrelevant_url&#34;,
} = {}) {
  const client = new LoginClient(host, clientId, clientSecret, connection);
  const url = client.getLoginUrl(username, callbackUrl);

  return { client, url };             // Multiple return values
}
</code></pre>

<p>If you’re using a language without support for optional parameters, use method overloading or an “Options” object. If you’re using a language without support for multiple return values, you can return a simple data structure.</p>

<pre><code>// Optional parameters and multiple return values <em>(Java)</em>

<em>// Example tests</em>
@Test
public void usesHostedPageForAuthentication() {
  GetLoginUrlResult actual = getLoginUrl(new GetLoginUrlOptions()   <em>// Use the helper function and Options object</em>
    .withHost(&#34;my.host&#34;)
    .withClientId(&#34;my_client_id&#34;)
    .withCallbackUrl(&#34;my_callback_url&#34;)
  );
  assert.equal(actual.url, &#34;https://my.host/authorize?response_type=code&amp;client_id=my_client_id&amp;callback_url=my_callback_url&#34;);
}

<em>// Helper function using Options object and return data structure</em>
private GetLoginUrlResult getLoginUrl(GetLoginUrlOptions options) {
  LoginClient client = new LoginClient(options.host, options.clientId, options.secret, options.connection);
  String url = client.getLoginUrl(options.username, options.callbackUrl);
  return new GetLoginUrlResult(client, url);
}

<em>// Options object</em>
private static final class GetLoginUrlOptions {
  public String host = &#34;irrelevant.host&#34;;
  public String clientId = &#34;irrelevant_client_id&#34;;
  public String clientSecret = &#34;irrelevant_secret&#34;;
  public String connection = &#34;irrelevant_connection&#34;;
  public String username = &#34;irrelevant_username&#34;;
  public String callbackUrl = &#34;irrelevant_url&#34;;

  GetLoginUrlOptions withHost(String host) {
    this.host = host;
    return this;
  }

  GetLoginUrlOptions withClientId(String clientId) {
    this.clientId = clientId;
    return this;
  }

  GetLoginUrlOptions withCallbackUrl(String url) {
    this.callbackUrl = url;
    return this;
  }
}

<em>// Return data structure</em>
private static final class GetLoginUrlResult {
  public LoginClient client;
  public String url;

  public GetLoginUrlResult(LoginClient client, String url) {
    this.client = client;
    this.url = url;
  }
}
</code></pre>

<p><a href="#toc">Contents</a></p>


<h3 id="arch-patterns">Architectural Patterns</h3>

<p>Testing works best when you pay careful attention to the dependencies in your codebase. These architectural patterns help you do so. They aren’t required, but they’re useful.</p>

<ul>
  <li><a href="#a-frame-arch">A-Frame Architecture</a></li>
  <li><a href="#logic-sandwich">Logic Sandwich</a></li>
  <li><a href="#traffic-cop">Traffic Cop</a></li>
  <li><a href="#grow-seeds">Grow Evolutionary Seeds</a></li>
</ul>


<h4 id="a-frame-arch">A-Frame Architecture</h4>

<p>Code without infrastructure dependencies is much easier to test than code that has infrastructure dependencies. However, a normal layered architecture puts infrastructure at the bottom of the dependency chain:</p>

<pre aria-description="ASCII art showing a vertical, three-layer architecture. &#39;Application/UI&#39; is on top, pointing to &#39;Logic&#39;, which is pointing to &#39;Infrastructure.">Application/UI
      |
      V
    Logic
      |
      V
Infrastructure
</pre>

<p><em>Therefore:</em></p>

<p>Structure your application so that infrastructure and logic are peers under the application layer, with no dependencies between Infrastructure and Logic. Coordinate between them at the Application layer with a <a href="#logic-sandwich">Logic Sandwich</a> or <a href="#traffic-cop">Traffic Cop</a>. Use <a href="https://www.martinfowler.com/bliki/ValueObject.html">Value Objects</a> to pass data between the Logic and Infrastructure layers.</p>

<pre aria-description="ASCII art showing a triangle-shaped architecture with four elements. &#39;Application/UI&#39; is on the top, pointing to &#39;Logic&#39; on the bottom left and &#39;Infrastructure&#39; on the bottom right. A fourth layer, &#39;Values&#39; is off to the side.">   Application/UI     Values
   /            \
  V              V
Logic   Infrastructure
</pre>

<p>Build the Logic and Values layers using <a href="#logic-patterns">Logic Patterns</a>. Build the Infrastructure layer using <a href="#infrastructure-patterns">Infrastructure Patterns</a>. Build the Application/UI layer with a <a href="#logic-sandwich">Logic Sandwich</a> or <a href="#traffic-cop">Traffic Cop</a>, and use <a href="#nullables">Nullables</a> to test it.</p>

<p>Although A-Frame Architecture is a nice way to simplify application dependencies, it’s entirely optional. This pattern language will work without it.</p>

<p>To build a new application using A-Frame Architecture, <a href="#grow-seeds">Grow Evolutionary Seeds</a>. To convert an existing codebase, <a href="#descend-ladder">Descend the Ladder</a>.</p>

<p><a href="#toc">Contents</a></p>


<h4 id="logic-sandwich">Logic Sandwich</h4>

<p>When using an <a href="#a-frame-arch">A-Frame Architecture</a>, the infrastructure and logic layers aren’t allowed to communicate with each other. But the logic layer needs to read and write data controlled by the infrastructure layer. <em>Therefore:</em></p>

<p>Implement the Application layer code as a “logic sandwich,” which reads data using the Infrastructure layer, processes it using the Logic layer, then writes it using the Infrastructure layer. Repeat as needed. Each layer can then be tested independently.</p>

<pre><code>// JavaScript
const input = infrastructure.readData();
const output = logic.processInput(input);
infrastructure.writeData(output);
</code></pre>

<p>This simple algorithm can handle sophisticated needs if put into a stateful loop. In some cases, your Application layer might need a bit of logic of its own, or you might need multiple sandwiches.</p>

<p>For applications that respond to events, use a <a href="#traffic-cop">Traffic Cop</a> instead.</p>

<p><a href="#toc">Contents</a></p>


<h4 id="traffic-cop">Traffic Cop</h4>

<p>The <a href="#logic-sandwich">Logic Sandwich</a> boils infrastructure down into simple <code>infrastructure.readData()</code> and <code>infrastructure.writeData()</code> abstractions. But some applications need to respond to changes instigated by the infrastructure and logic layers. <em>Therefore:</em></p>

<p>Program the application layer to use the <a href="https://en.wikipedia.org/wiki/Observer_pattern">Observer pattern</a> to listen for events from the infrastructure and logic layers. For each event, implement a <a href="#logic-sandwich">Logic Sandwich</a>.

</p><pre><code>// Traffic Cop example (JavaScript)

server.onPost(&#34;/login&#34;, (formData) =&gt; {               // event from infrastructure layer
  const loginData = processLoginForm(formData);           // application logic
  const userData = userService.logInUser(loginData);      // infrastructure layer
  this._user = new User(userData);                        // logic layer

  const userIsValid = this._user.isValid();               // logic layer
  if (userIsValid) {                                      // application logic
    const sessionData = user.sessionData;                 // logic layer
    sessionServer.createSession(sessionData);             // infrastructure layer
    return redirect(loginData.postLoginUrl);              // application logic
  }
  else {
    return redirect(LOGIN_FAILED_URL);                    // application logic
  }
});

this._user.onChange((userData) =&gt; {                   // event from logic layer
  userService.updateUser(userData);                       // infrastructure layer
});
</code></pre>

<p>Be careful not to let your Traffic Cop turn into a <a href="https://wiki.c2.com/?GodClass">God Class</a>. If it gets complicated, better infrastructure abstractions might help. Sometimes taking a less “pure” approach and moving some Logic code into the Infrastructure layer can simplify the overall design. In other cases, splitting the application layer into multiple classes or modules, each with its own <a href="#logic-sandwich">Logic Sandwich</a> or simple Traffic Cop, can help.</p>

<p><a href="#toc">Contents</a></p>


<h4 id="grow-seeds">Grow Evolutionary Seeds</h4>

<p>One popular design technique is <a href="https://www.amazon.com/gp/product/0321503627">outside-in design</a>, in which an application is programmed by starting with the externally-visible behavior of the application, then working your way in to the details.</p>

<p>This is typically done by writing a broad integration test to describe the externally-visible behavior, then using interaction tests to build higher-level functions before lower-level functions. But we want to use <a href="#narrow-tests">Narrow Tests</a>, not broad tests, and <a href="#state-based-tests">State-Based Tests</a>, not interaction tests. <em>Therefore:</em></p>

<p>Use <a href="https://teonbrooks.com/v2/books/aoad2/design">evolutionary design</a> to grow your application from a single file. Choose a simple end-to-end behavior as a starting point, then test-drive a single class to implement a trivial version of that behavior. Hardcode one value that would normally come from the Infrastructure layer, don’t implement any significant logic, and return the result to your tests rather than displaying it in a UI. This class forms the seed of your Application layer.</p>

<pre><code>// Simplest possible Application seed (JavaScript)

<em>// Test code</em>
it(&#34;renders user name&#34;, () =&gt; {
  const app = new MyApplication();
  assert.equal(&#34;Hello, Sarah&#34;, app.render());
});

<em>// Production code</em>
class MyApplication {
  render() {
    return &#34;Hello, Sarah&#34;;
  }
}
</code></pre>

<p>Next, implement a barebones <a href="#infrastructure-wrappers">Infrastructure Wrapper</a> for the one infrastructure value you hardcoded. Test-drive it with <a href="#narrow-integration-tests">Narrow Integration Tests</a> and code just enough to provide one real result that your Application class needs. Don’t worry about making it robust or reliable yet. This Infrastructure Wrapper class forms the seed of your Infrastructure layer.</p>

<p>Before integrating your new Infrastructure class into your Application class, use the <a href="#nullability-patterns">Nullability Patterns</a> to make the Infrastructure class testable from your application layer. Then modify your Application class to use the Infrastructure class, injecting the Nulled version in your tests.</p>

<pre><code>// Application + read from infrastructure (JavaScript)

<em>// Test code</em>
it(&#34;renders user name&#34;, async () =&gt; {
  const usernameService = UsernameService.createNull({ username: &#34;my_username&#34; });  // <a href="#nullables">Nullable</a> with <a href="#configurable-responses">Configurable Responses</a>
  const app = new MyApplication(usernameService);
  assert.equal(&#34;Hello, my_username&#34;, await app.renderAsync());
});

<em>// Production code</em>
class MyApplication {
  static create() {     // <a href="#instantiation">Parameterless Instantiation</a>
    return new MyApplication(UsernameService.create());
  }

  constructor(usernameService) {
    this._usernameService = usernameService;
  }

  async renderAsync() {
    const username = await this._usernameService.getUsernameAsync();
    return `Hello, ${username}`;
  }
}
</code></pre>

<p>Next, do the same for your UI. Choose one simple output mechanism that your application will use (such as rendering to the console, the DOM, or responding to a network request) and implement a barebones <a href="#infrastructure-wrappers">Infrastructure Wrapper</a> for it. Make it <a href="#nullability-patterns">Nullable</a> and modify your Application layer tests and code to use it.</p>

<pre><code>// Application + read/write to Infrastructure (JavaScript)

<em>// Test code</em>
it(&#34;renders user name&#34;, () =&gt; {
  const usernameService = UsernameService.createNull({ username: &#34;my_username&#34; });  // <a href="#nullables">Nullable</a> with <a href="#configurable-responses">Configurable Responses</a>
  const uiService = UiService.createNull();   // <a href="#nullables">Nullable</a>
  const uiOutput = uiService.trackOutput();   // <a href="#output-tracking">Output Tracking</a>

  const app = new MyApplication(usernameService, uiService);

  await app.renderAsync();
  assert.deepEqual(uiOutput.data, [ &#34;Hello, my_username&#34;]);
});

<em>// Production code</em>
class MyApplication {
  static create() {     // <a href="#instantiation">Parameterless Instantiation</a>
    return new MyApplication(UsernameService.create(), UiService.create());
  }

  constructor(usernameService, uiService = UiService.create()) {
    this._usernameService = usernameService;
    this._uiService = uiService;
  }

  async renderAsync() {
    const username = await this._usernameService.getUsernameAsync();
    await uiService.renderAsync(`Hello, ${username}`);
  }
}
</code></pre>

<p>Now your application tests serve the same purpose as broad end-to-end tests: they document and test the externally-visible behavior of the application. They’re <a href="#narrow-tests">Narrow Tests</a>, because they’re focused on the behavior of the Application class, and because they use <a href="#nullables">Nullable</a> dependencies, they don’t communicate with external systems. That makes them fast and reliable. But because they’re also <a href="#sociable-tests">Overlapping Sociable Tests</a>, they provide the same safety net that broad tests do.

</p><p>At this point, you have the beginnings of a <a href="https://wiki.c2.com/?WalkingSkeleton">walking skeleton</a>: an application that works end-to-end, but is far from complete. You can evolve that skeleton to support more features. Choose some aspect of your code that’s obviously incomplete and test-drive a slightly better solution. Repeat forever.</p>

<pre><code>// Application + read/write to Infrastructure + respond to UI events (JavaScript)

<em>// Test code</em>
it(&#34;renders user name&#34;, async () =&gt; {
  const usernameService = UsernameService.createNull({ username: &#34;my_username&#34; });  // <a href="#nullables">Nullable</a> with <a href="#configurable-responses">Configurable Responses</a>
  const uiService = UiService.createNull();   // <a href="#nullables">Nullable</a>
  const uiOutput = uiService.trackOutput();   // <a href="#output-tracking">Output Tracking</a>

  const app = new MyApplication(usernameService, uiService);
  await app.startAsync();

  uiService.simulateRequest(&#34;greeting&#34;);      // <a href="#behavior-simulation">Behavior Simulation</a>
  assert.deepEqual(uiOutput.data, [ &#34;Hello, my_username&#34; ]);
});

<em>// Production code</em>
class MyApplication {
  static create() {     // <a href="#instantiation">Parameterless Instantiation</a>
   return new MyApplication(UsernameService.create(), UiService.create());
 }

 constructor(usernameService, uiService = UiService.create()) {
   this._usernameService = usernameService;
   this._uiService = uiService;
 }

  async startAsync() {
    this._uiService.on(&#34;greeting&#34;, () =&gt; {
      const username = await this._usernameService.getUsernameAsync();
      await uiService.renderAsync(`Hello, ${username}`);
    });
  }
}
</code></pre>

<p>At some point, probably fairly early, your Application layer class will start feeling messy. When it does, look for a concept that can be factored into its own class. This forms the seed of your Logic layer. As your application continues to grow, continue refactoring so that class collaborations are easy to understand and responsibilities are clearly defined.</p>

<p>When working with existing code, use the <a href="#legacy-patterns">Legacy Code Patterns</a> instead.</p>

<p><a href="#toc">Contents</a></p>


<h3 id="logic-patterns">Logic Patterns</h3>

<p>Logic code is pure computation. To qualify, code can’t involve external systems or state. That means it can’t talk to a database, communicate across a network, touch the file system, read the date and time, look at environment variables, or use most random number generators. It can’t depend on any code that does these things, either.</p>

<p>Pure computation is easy to test. The following patterns make it even easier.</p>

<ul>
  <li><a href="#visible-behavior">Easily-Visible Behavior</a></li>
  <li><a href="#testable-libraries">Testable Libraries</a></li>
  <li><a href="#isolation">Collaborator-Based Isolation</a></li>
</ul>


<h4 id="visible-behavior">Easily-Visible Behavior</h4>

<p>Logic computation can only be tested by <a href="#state-based-tests">State-Based Tests</a> if the results of the computation are visible to tests. <em>Therefore:</em></p>

<p>Prefer pure functions where possible. Pure functions’ return values are determined only by their input parameters.</p>

<pre><code>// JavaScript
function add(a, b) {
  return a + b;
}
</code></pre>

<p>When working with objects, prefer immutable objects, which are the object-oriented equivalent of pure functions. The state of immutable objects is determined when the object is constructed, and never changes afterwards.</p>

<pre><code>// JavaScript
class Value {
  constructor(initialValue) {
    this._value = initialValue;
  }

  plus(addend) {
    return new Value(this._value + addend);
  }
}
</code></pre>

<p>For mutable objects, provide a way for changes in state to be observed, either with a getter method or an <a href="https://en.wikipedia.org/wiki/Observer_pattern">event</a>.</p>

<pre><code>// JavaScript
class RunningTotal {
  constructor(initialValue) {
    this._total = initialValue;
  }

  add(addend) {
    this._total += addend;
  }

  getTotal() {
    return this._total;
  }
}
</code></pre>

<p>In all cases, avoid writing code that explicitly depends on (or changes) the state of dependencies more than one level deep. That makes test setup difficult, and it’s a sign of poor design anyway. Instead, design dependencies so they completely encapsulate their next-level-down dependencies.</p>

<p><a href="#toc">Contents</a></p>


<h4 id="testable-libraries">Testable Libraries</h4>

<p>Third-party code doesn’t always have <a href="#visible-behavior">Easily-Visible Behavior</a>. It also tends to introduce breaking API changes with new releases, or simply stop being maintained. <em>Therefore:</em></p>

<p>Wrap third-party code in code you control. Ensure your application’s use of the third-party code is mediated through your wrapper. Write your wrapper’s API to match the needs of your application, not the third-party code, and add methods as needed to provide <a href="#visible-behavior">Easily-Visible Behavior</a>. (This will typically involve writing getter methods to expose deeply-buried state.) When the third-party code introduces a breaking change, or needs to be replaced, modify the wrapper so no other code is affected.</p>

<p>Frameworks and libraries with sprawling APIs are more difficult to wrap, so prefer libraries that have a narrowly-defined purpose and a simple API.</p>

<p>Some third-party code is pervasive and stable, such as core language frameworks. Other code, such as UI frameworks, can be very costly to wrap. You may be better off not creating a wrapper for these cases.</p>

<p>If the third-party code interfaces with an external system or state, use an <a href="#infrastructure-wrappers">Infrastructure Wrapper</a> instead.</p>

<p><a href="#toc">Contents</a></p>


<h4 id="isolation">Collaborator-Based Isolation</h4>

<p><a href="#sociable-tests">Overlapping Sociable Tests</a> ensure your tests will fail if your code’s behavior changes, no matter how far down the dependency chain those changes may be. On the one hand, this is nice, because you’ll learn when you accidentally break something. On the other hand, this could make feature changes terribly expensive. We don’t want a change in the formatting of addresses to break hundreds of unrelated reports’ tests. <em>Therefore:</em></p>

<p>When a dependency’s behavior isn’t relevant to the code under test, use the dependency to help define test expectations. For example, if you’re testing a report that includes an address in its header, don’t hardcode “123 Main St.” as your expectation. Instead, ask the address how it would render itself, and use that as part of your test expectation.</p>

<p>Be careful not to write tests that are a copy of the code under test. Collaborator-Based Isolation is for writing <a href="#narrow-tests">Narrow Tests</a> that ignore irrelevant details. For example, in the following code, the test is checking the special case of a report with a single address, not the behavior of address rendering. Address rendering is expected to have its own Narrow Tests.</p>

<pre><code>// JavaScript

<em>// Example test</em>
it(&#34;includes the address in the header when reporting on one address&#34;, () =&gt; {
  <em>// Instantiate the unit under test and its dependency</em>
  const address = Address.createTestInstance();                 // <a href="#instantiation">Parameterless Instantiation</a>
  const report = new InventoryReport(Inventory.create(), [ address ]);

  <em>// Define the expected result using the dependency</em>
  const expected = &#34;Inventory Report for &#34; + address.renderAsOneLine();

  <em>// Run the production code and make the assertion</em>
  assert.equal(report.renderHeader(), expected);
});

<em>// Example production code</em>
class InventoryReport {
  constructor(inventory, addresses) {
    this._inventory = inventory;
    this._addresses = addresses;
  }

  renderHeader() {
    let result = &#34;Inventory Report&#34;;
    if (this._addresses.length === 1) {
      result += &#34; for &#34; + this._address[0].renderAsOneLine();
    }
    return result;
  }
}
</code></pre>

<p>This provides the best of both worlds: <a href="#sociable-tests">Overlapping Sociable Tests</a> ensure that your application is wired together correctly and Collaborator-Based Isolation allows you to change behavior without breaking a lot of tests. However, it also ties the tests more tightly to the production code’s implementation, so it should be used sparingly.</p>

<p><a href="#toc">Contents</a></p>


<h3 id="infrastructure-patterns">Infrastructure Patterns</h3>

<p>Infrastructure code is for communicating with the outside world. Although it may contain some logic, that logic should be focused on making infrastructure easier to work with. Everything else belongs in Application or Logic code.</p>

<p>Infrastructure code is unreliable and difficult to test because of its dependencies on external systems and state. The following patterns work around those problems.</p>

<ul>
  <li><a href="#infrastructure-wrappers">Infrastructure Wrappers</a></li>
  <li><a href="#narrow-integration-tests">Narrow Integration Tests</a></li>
  <li><a href="#paranoic-telemetry">Paranoic Telemetry</a></li>
</ul>


<h4 id="infrastructure-wrappers">Infrastructure Wrappers</h4>

<p>Infrastructure code is complicated to write, hard to test, and often difficult to understand. <em>Therefore:</em></p>

<p>Isolate your Infrastructure code. For each external system—service, database, file system, or even environment variables—create one wrapper class that’s solely responsible for interfacing with that system. Design your wrappers to provide a crisp, clean view of the messy outside world, in whatever format is most useful to the rest of your code.</p>

<p>Avoid creating complex webs of dependencies. In some cases, high-level Infrastructure classes may depend on generic, low-level classes. For example, <code>LoginClient</code> might depend <code>HttpClient</code>. In other cases, high-level infrastructure classes might unify multiple low-level classes, such as a <code>DataStore</code> class that depends on a <code>RelationalDb</code> class and a <code>NoSqlDb</code> class. Other than these sorts of simple one-way dependency chains, design your Infrastructure classes to stand alone.</p>

<p>Test your Infrastructure Wrappers with <a href="#narrow-integration-tests">Narrow Integration Tests</a> and <a href="#paranoic-telemetry">Paranoic Telemetry</a>. Make them testable with the <a href="#nullability-patterns">Nullability Patterns</a>.</p>

<p>Infrastructure Wrappers are also called “<a href="https://martinfowler.com/articles/gateway-pattern.html">Gateways</a>” or “Adapters,” although those terms are technically a superset of infrastructure wrappers.

</p><p><a href="#toc">Contents</a></p>


<h4 id="narrow-integration-tests">Narrow Integration Tests</h4>

<p>Ultimately, Infrastructure code talks over a network, interacts with a file system, or involves some other communication with external systems or state. It’s easy to make a mistake. <em>Therefore:</em></p>

<p>Test your external communication for real. For file system code, read and write real files. For databases, access a real database. Make sure that your test systems use the same configuration as your production environment. Otherwise your code will fail in production when it encounters subtle incompatibilities.</p>

<p>Run your narrow integration tests against test systems that are reserved exclusively for one machine’s use. It’s best if they run locally on your development machine, and are started and stopped by your tests or build script. Otherwise, you could experience unpredictable test failures when multiple people run the tests at the same time.</p>

<p>If you have multiple external systems that use the same technology, such as multiple web services, create a generic, low-level infrastructure wrapper for the underlying technology. Then create higher-level infrastructure wrappers for each system. The high-level wrappers don’t need Narrow Integration Tests. Instead, you can <a href="#fake-it">Fake It Once You Make It</a> by delegating to the low-level wrapper.</p>

<p>For example, you could create a high-level <code>LoginClient</code> that depended on a low-level <code>HttpClient</code>. The <code>LoginClient</code> would <a href="#fake-it">Fake It Once You Make It</a> and the <code>HttpClient</code> would be tested with Narrow Integration Tests.</p>

<pre><code>// Example of narrow integration tests for HttpClient (JavaScript + Node.js)
import * as http from &#34;node:http&#34;;
import HttpClient from &#34;./http_client&#34;;

const HOST = &#34;localhost&#34;;
const PORT = 5001;

<em>// Tests</em>
describe(&#34;HTTP Client&#34;, () =&gt; {
  let server;

  before(async () =&gt; {
    server = new TestServer();
    await server.startAsync();
  });

  after(async () =&gt; {
    await server.stopAsync();
  });

  beforeEach(function() {
    server.reset();
  });

  it(&#34;performs request&#34;, async () =&gt; {
    await requestAsync({
      host: HOST,
      port: PORT,
      method: &#34;POST&#34;,
      path: &#34;/my/path&#34;,
      headers: { myRequestHeader: &#34;myRequestValue&#34; },
      body: &#34;my request body&#34;
    });

    assert.deepEqual(server.lastRequest, {
      method: &#34;POST&#34;,
      path: &#34;/my/path&#34;,
      headers: { myrequestheader: &#34;myRequestValue&#34; },
      body: &#34;my request body&#34;
    });
  });

  it(&#34;returns response&#34;, async () =&gt; {
    server.setResponse({
      status: 999,
      headers: { myResponseHeader: &#34;myResponseValue&#34; },
      body: &#34;my response&#34;,
    });

    const response = await requestAsync();
    assert.deepEqual(response, {
      status: 999,
      headers: { myresponseheader: &#34;myResponseValue&#34; },
      body: &#34;my response&#34;,
    });
  });

  async function requestAsync(options = {
    host: HOST,
    port: PORT,
    method: &#34;GET&#34;,
    path: &#34;/irrelevant/path&#34;,
  }) {
    const client = HttpClient.create();
    return client.requestAsync(options);
  }

});

<em>// Localhost HTTP server</em>
class TestServer {
  constructor() {
    this.reset();
  }

  reset() {
    this._lastRequest = null;
    this._nextResponse = {
      status: 500,
      headers: {},
      body: &#34;response not specified&#34;,
    };
  }

  startAsync() {
    return new Promise((resolve, reject) =&gt; {
      this._server = http.createServer();
      this._server.once(&#34;listening&#34;, resolve);
      this._server.once(&#34;error&#34;, reject);
      this._server.on(&#34;request&#34;, this.#handleRequest.bind(this));
      this._server.listen(PORT);
    });
  }

  stopAsync() {
    return new Promise((resolve, reject) =&gt; {
      this._server.once(&#34;close&#34;, resolve);
      this._server.close();
    });
  }

  setResponse(response) {
    this._nextResponse = response;
  }

  get lastRequest() {
    return this._lastRequest;
  }

  // In JavaScript, methods that start with &#34;#&#34; are private.
  #handleRequest(request, response) {
    let body = &#34;&#34;;
    request.on(&#34;data&#34;, (chunk) =&gt; {
      body += chunk;
    });
    request.on(&#34;end&#34;, () =&gt; {
      this.#storeRequest(request, body);
      this.#sendResponse(response);
    });
  }

  #storeRequest(request, body) {
    const headers = { ...request.headers };
    delete headers.connection;
    delete headers[&#34;content-length&#34;];
    delete headers.host;

    this._lastRequest = {
      method: request.method,
      path: request.url,
      headers,
      body,
    };
  }

  #sendResponse(response) {
    response.statusCode = this._nextResponse.status;
    Object.entries(this._nextResponse.headers).forEach(([key, value]) =&gt; {
      response.setHeader(key, value);
    });

    response.end(this._nextResponse.body);
  }
}
</code></pre>

<p>Ensure your code works in production with <a href="#paranoic-telemetry">Paranoic Telemetry</a>.


</p><p><a href="#toc">Contents</a></p>


<h4 id="paranoic-telemetry">Paranoic Telemetry</h4>

<p>External systems are unreliable. The only thing that’s certain is their eventual failure. File systems lose data and become unwritable. Services return error codes, suddenly change their specifications, and refuse to terminate connections. <em>Therefore:</em></p>

<p>Assume they really are out to get you, and instrument your code accordingly. Expect that everything will break eventually. Test that every failure case either logs an error and sends an alert, or throws an exception that ultimately logs an error and sends an alert. Remember to test your code’s ability to handle requests that hang, too.</p>

<p>All these failure cases are expensive to support and maintain. Whenever possible, use <a href="#testable-libraries">Testable Libraries</a> rather than external services.</p>

<p>Paranoic Telemetry may be supplemented with <a href="https://martinfowler.com/bliki/ContractTest.html">Contract Tests</a>. Contract Tests are most effective when run by the supplier (but provided by you), because they can’t catch changes that happen between test runs.</p>

<p><a href="#toc">Contents</a></p>


<h3 id="nullability-patterns">Nullability Patterns</h3>

<p><a href="#sociable-tests">Sociable Tests</a> run real code. That’s good for catching errors, but if the dependency chain includes infrastructure—external systems or state—they become hard to manage. The following patterns allow you to “turn off” external dependencies while retaining the benefits of sociable and state-based testing.</p>

<ul>
  <li><a href="#nullables">Nullables</a></li>
  <li><a href="#embedded-stub">Embedded Stub</a></li>
  <li><a href="#thin-wrapper">Thin Wrapper</a></li>
  <li><a href="#configurable-responses">Configurable Responses</a></li>
  <li><a href="#output-tracking">Output Tracking</a></li>
  <li><a href="#behavior-simulation">Behavior Simulation</a></li>
  <li><a href="#fake-it">Fake It Once You Make It</a></li>
</ul>


<h4 id="nullables">Nullables</h4>

<p><a href="#narrow-integration-tests">Narrow Integration Tests</a> are slow and difficult to set up. Although they’re useful for ensuring that low-level <a href="#infrastructure-wrappers">Infrastructure Wrappers</a> work in practice, they’re overkill for code that depends on those wrappers. <em>Therefore:</em></p>

<p>Program code that includes infrastructure in its dependency chain to have a <code>createNull()</code> factory method. The factory should create a “Nulled” instance that disables all external communication, but behaves normally in every other respect.<sup>2</sup> Make sure it supports <a href="#instantiation">Parameterless Instantiation</a>.

</p>

<p>For example, calling <code>LoginClient.createNull().getUserInfo(...)</code> should return a default response without actually talking to the third-party login service.</p>

<p>Nullables are production code and should be tested accordingly. Although Nulled instances are often used by tests, they’re also useful whenever you want the ability to “turn off” behavior in your application. For example, you could use Nullables implement a “dry run” option in a command-line application.</p>

<pre><code>// Example of using Nullables to implement &#34;dry run&#34; option (JavaScript + Node.js)
async initializeGitWriter(config) {
  if (config.dryRun) {
    return GitWriter.createNull();
  }
  else {
    return GitWriter.create();
  }
}
</code></pre>

<p>As another example, you can use Nullables in a web server to cache popular URLs when the server starts up:</p>

<pre><code>// Example of using Nullables to implement cache warming (JavaScript + Node.js)
async warmCacheAsync(popularUrls, log) {
  for await (const url of popularUrls) {
    await this.routeAsync(HttpRequest.createNull(url, log);
  }
}
</code></pre>

<p>Make low-level infrastructure wrappers Nullable with <a href="#embedded-stub">Embedded Stubs</a>. For all other code, <a href="#fake-it">Fake It Once You Make It</a>. To make existing code Nullable, see the <a href="#legacy-patterns">Legacy Code Patterns</a>.</p>

<p>If your Nullable reads data from external systems or state, or any of its dependencies do, implement <a href="#configurable-responses">Configurable Responses</a>. If it or its dependencies write data, implement <a href="#output-tracking">Output Tracking</a>. If they respond to events, implement <a href="#behavior-simulation">Behavior Simulation</a>.</p>

<p><a href="#toc">Contents</a></p>


<h4 id="embedded-stub">Embedded Stub</h4>

<p><a href="#nullables">Nullables</a> need to disable access to external systems and state while running everything else normally. The obvious approach is to surround any code that accesses the external system with an “if” statement, but that’s a recipe for spaghetti. <em>Therefore:</em></p>

<p>When making code <a href="#nullables">Nullable</a>, don’t change your code. Instead, stub out the third-party code that accesses external systems.</p>

<p>In your stub, implement the bare minimum needed to make your code run. Ensure you don’t overbuild the stub by test-driving it through your code’s public interface. Put the stub in the same file as the rest of your code so it’s easy to remember and update when your code changes.</p>

<p>Write a stub of the <em>third-party</em> code, not your code, so your <a href="#sociable-tests">Sociable Tests</a> test how your code will really work in production. Be careful to have your stub mimic the behavior of the third-party code exactly. To help you do so, write <a href="#narrow-integration-tests">Narrow Integration Tests</a> that document the behavior of the real code, paying particular attention to edge cases such as error handling and asynchronous code. Then write additional tests of the <a href="#nullables">Nulled</a> instance that will fail if your stub doesn’t have the same behavior.</p>

<p>Here’s a simple example of stubbing out JavaScript’s <code>Math</code> library:</p>

<pre><code>// An Infrastructure Wrapper for a random die roller. (JavaScript)

<em>// <a href="#infrastructure-wrappers">Infrastructure Wrapper</a></em>
export default class DieRoller {

  <em>// Normal factory</em>
  static create() {
    return new DieRoller(Math);    // &#34;Math&#34; is a built-in JavaScript global
  }

  <em>// Null factory</em>
  static createNull() {
    return new DieRoller(new StubbedMath());
  }

  <em>// Shared initialization code</em>
  constructor(math) {
    this._math = math;
  }

  <em>// Infrastructure wrapper implementation.</em>
  <em>// This is the same code you would write without a stub.</em>
  roll(amount) {
    const randomNumber = this._math.random();
    return Math.trunc((randomNumber * 6) + 1);    // There&#39;s no need to stub Math.trunc, so we use the real Math library here
  }
};

<em>// Embedded Stub. Note that we only stub the function we use.</em>
class StubbedMath {
  random() {
    return 0;
  }
}
</code></pre>

<p>Here’s a more complicated example. It stubs out Node.js’s <code>http</code> library:</p>

<pre><code>// An infrastructure wrapper for a generic HTTP client. (JavaScript + Node.js)
import * as http from &#34;node:http&#34;;
import { EventEmitter } from &#34;node:events&#34;;

export default class HttpClient {

  // Normal factory
  static create() {
    return new HttpClient(http);
  }

  // Null factory
  static createNull() {
    return new HttpClient(new StubbedHttp());
  }

  // Shared initialization code
  constructor(http) {
    this._http = http;
  }

  <em>// Infrastructure wrapper implementation.</em>
  <em>// This is the same code you would write without a stub.</em>
  async requestAsync({ host, port, method, path, headers = {}, body = &#34;&#34; }) {
    if (method === &#34;GET&#34; &amp;&amp; body !== &#34;&#34;) throw new Error(&#34;Don&#39;t include body with GET requests; Node won&#39;t send it&#34;);

    const httpOptions = { host, port, method, path, headers };
    const request = this.#sendRequest(httpOptions, body);

    await new Promise((resolve, reject) =&gt; {
      this.#handleResponse(request, resolve);
      this.#handleError(request, reject);
    });
  }

  // In JavaScript, methods that start with &#34;#&#34; are private.
  #sendRequest(httpOptions, body) {
    const request = this._http.request(httpOptions);
    request.end(body);
    return request;
  }

  #handleResponse(request, resolve) {
    request.once(&#34;response&#34;, (response) =&gt; {
      let body = &#34;&#34;;
      response.on(&#34;data&#34;, (chunk) =&gt; {
        body += chunk;
      });
      response.on(&#34;end&#34;, () =&gt; {
        resolve({
          status: response.statusCode,
          headers,
          body,
        });
      });
    });
  }

  #handleError(request, reject) {
    request.once(&#34;error&#34;, reject);
  }
};

<em>// Embedded Stub. Note that it’s built exactly for the needs of the infrastructure code, nothing more.</em>
class StubbedHttp {
  request() {
    return new StubbedRequest();
  }
}

class StubbedRequest extends EventEmitter {
  end() {
    <em>// setImmediate() is used to make the emit() call asynchronous, duplicating the behavior of real code</em>
    setImmediate(() =&gt; this.emit(&#34;response&#34;, new StubbedResponse()));
  }
}

class StubbedResponse extends EventEmitter {
  constructor() {
    super();
    setImmediate(() =&gt; {
      this.emit(&#34;data&#34;, &#34;Nulled HttpClient response&#34;);
      this.emit(&#34;end&#34;);
    });
  }
  get statusCode() {
    return 200;
  }
  get headers() {
    return {};
  }
}
</code></pre>

<p>Configure the embedded stub’s return values with <a href="#configurable-responses">Configurable Responses.</a> If your language requires it, as with Java or C#, create a <a href="#thin-wrapper">Thin Wrapper</a>.</p>

<p>Nullables are <em>production code</em>, and despite appearances, the Embedded Stub is too. It must be tested accordingly. If you don’t like the idea of having stubs in your production code, you can put the Embedded Stub in a separate test-only file instead. However, this will make dependency management more complicated, and it will prevent you from using Nulled instances in production, which can be useful.</p>

<p><a href="#toc">Contents</a></p>


<h4 id="thin-wrapper">Thin Wrapper</h4>

<p>Languages such as Java and C# will require your <a href="#embedded-stub">Embedded Stub</a> to share an interface with the real dependency. Often, there won’t be an interface you can use, or it will be bigger than you need. <em>Therefore:</em>

</p><p>Create a custom interface for your third-party dependency. Match the signature of the dependency exactly, but only include the methods your production code actually uses. Provide two implementations of the interface: a real version that only forwards calls to the third-party dependency, and an Embedded Stub.</p>

<pre><code>// A simple Infrastructure Wrapper for a random die roller. <em>(Java)</em>
// It has an embedded stub for Java&#39;s standard “Random” library.
// Based on an example created with Ted M. Young in his <a href="https://github.com/jitterted/yacht-tdd">Yacht codebase</a>.
public class DieRoller {
  private final RandomWrapper random;

  // Normal factory
  public static DieRoller create() {
    return new DieRoller(new RealRandom());
  }

  // Null factory
  public static DieRoller createNull() {
    return new DieRoller(new StubbedRandom());
  }

  // Private constructor with shared initialization code
  private DieRoller(RandomWrapper random) {
    this.random = random;
  }

  <em>// Infrastructure wrapper implementation.</em>
  <em>// This is the same code you would write without a stub.</em>
  public int roll() {
    return random.nextInt(6) + 1;
  }

  <em>// Interface for Thin Wrapper. Note that we match the real code&#39;s interface exactly,</em>
  <em>// and we only include the function we use.</em>
  private interface RandomWrapper {
    int nextInt(int bound);
  }

  <em>// Real implementation of Thin Wrapper</em>
  private static class RealRandom implements RandomWrapper {
    private final Random random = new Random();

    @Override
    public int nextInt(int bound) {
      return this.random.nextInt(bound);
    }
  }

  <em>// Embedded Stub implementation of Thin Wrapper</em>
  private static class StubbedRandom implements RandomWrapper {
    @Override
    public int nextInt(int bound) {
      return 0;
    }
  }
}
</code></pre>

<p>If the third-party code returns custom types, you’ll need to wrap those return types as well. Remember to match the third-party code’s signatures exactly.</p>

<pre><code>// Infrastructure Wrapper for an HTTP request. <em>(Java + Spring Boot&#39;s RestTemplate)</em>
// Based on an example created with Ted M. Young in his <a href="https://github.com/jitterted/yacht-tdd">Yacht codebase</a>.
public class AverageScoreFetcher {
  private static final String YACHT_AVERAGE_API_URI = &#34;http://localhost:8080/api/averages?scoreCategory={scoreCategory}&#34;;

  private final RestTemplateWrapper restTemplate;

  // Normal factory
  public static AverageScoreFetcher create() {
    return new AverageScoreFetcher(new RealRestTemplate());
  }

  // Null factory
  public static AverageScoreFetcher createNull() {
    return new AverageScoreFetcher(new StubbedRestTemplate());
  }

  // Private constructor with shared initialization code
  private AverageScoreFetcher(RestTemplateWrapper restTemplate) {
    this.restTemplate = restTemplate;
  }

  <em>// Infrastructure wrapper implementation</em>
  public double averageFor(ScoreCategory scoreCategory) {
    ResponseEntityWrapper&lt;CategoryAverage&gt; entity = restTemplate.getForEntity(
      YACHT_AVERAGE_API_URI,
      CategoryAverage.class,
      scoreCategory.toString()
    );
    return entity.getBody().getAverage();
  }

  <em>// Interfaces for Thin Wrapper. Note that we only include the functions we use.</em>
  interface RestTemplateWrapper {
    &lt;T&gt; ResponseEntityWrapper&lt;T&gt; getForEntity(String url, Class&lt;T&gt; responseType, Object... uriVariables);
  }

  interface ResponseEntityWrapper&lt;T&gt; {
    T getBody();
  }

  <em>// Real implementations of Thin Wrapper</em>
  private static class RealRestTemplate implements RestTemplateWrapper {
    private final RestTemplate restTemplate = new RestTemplate();

    public &lt;T&gt; ResponseEntityWrapper&lt;T&gt; getForEntity(String url, Class&lt;T&gt; responseType, Object... uriVariables) {
      return new RealResponseEntity&lt;T&gt;(restTemplate.getForEntity(url, responseType, uriVariables));
    }
  }

  private static class RealResponseEntity&lt;T&gt; implements ResponseEntityWrapper&lt;T&gt; {
    private ResponseEntity&lt;T&gt; entity;

    RealResponseEntity(ResponseEntity&lt;T&gt; entity) {
      this.entity = entity;
    }

    public T getBody() {
      return this.entity.getBody();
    }
  }

  <em>// Stubbed implementations of Thin Wrapper</em>
  private static class StubbedRestTemplate implements RestTemplateWrapper {
    @Override
    public &lt;T&gt; ResponseEntityWrapper&lt;T&gt; getForEntity(String url, Class&lt;T&gt; responseType, Object... uriVariables) {
      return new StubbedResponseEntity&lt;&gt;();
    }
  }

  private static class StubbedResponseEntity&lt;T&gt; implements ResponseEntityWrapper&lt;T&gt; {
    @Override
    public T getBody() {
      return (T) new CategoryAverage(&#34;Nulled AverageScoreFetcher category&#34;, 42.0);
    }
  }

}
</code></pre>

<p><a href="#toc">Contents</a></p>


<h4 id="configurable-responses">Configurable Responses</h4>

<p><a href="#state-based-tests">State-based tests</a> of code with infrastructure dependencies needs to set up the infrastructure’s state, but setting up external systems is complicated and slow. <em>Therefore:</em></p>

<p>Make the infrastructure dependencies <a href="#nullables">Nullable</a> and program the <code>createNull()</code> factory to take your desired response as an optional parameter. Define the responses from the perspective of the dependency’s externally-visible <em>behavior</em>, not its implementation.</p>

<p>If the Nullable dependency has multiple types of responses that can be configured, give each one its own configuration parameter. Use named and optional parameters so tests only need to configure the data they care about. If your language doesn’t support optional parameters, use an Options object, as shown in the <a href="#sig-shielding">Signature Shielding</a> pattern.</p>

<p>For example, the following test is for a <code>LoginController</code> that depends on a Nullable <code>LoginClient</code>. Although <code>LoginClient</code> is used to make HTTP requests, its Configurable Responses aren’t about HTTP. Instead, they’re about the logged-in user’s email address and verification status, which is the behavior <code>LoginController</code> and its tests care about.</p>

<pre><code>// Example of configuring multiple types of responses. (JavaScript)
it(&#34;logs successful login&#34;, async () =&gt; {
  <em>// Configure login client dependency</em>
  const loginClient = LoginClient.createNull(
    email: &#34;my_authenticated_email&#34;,  // configure email address
    emailVerified: true,              // configure whether email is verified
  );

  <em>// Run production code</em>
  const { logOutput } = await performLogin({ loginClient }));  // <a href="#sig-shielding">Signature Shielding</a>

  <em>// Check results</em>
  assert.deepEqual(logOutput.data, [ &#34;Login: my_authenticated_email (verified)&#34; ]);   // <a href="#output-tracking">Output Tracking</a>
});
</code></pre>

<p>If it makes sense for your class to respond differently each time it’s called, configure the responses with an array or list. It’s often helpful to support two data types: a list of values, that results in a different response each time, and causes an exception when it runs out; and a single value, that returns the same response every time, and never runs out.</p>

<p>For example, the following test configures a Nullable <code>DieRoller</code> with a set of expected die rolls:</p>

<pre><code>// Example of a single type of response with multiple return values. (JavaScript)
// Inspired by an example created with Ted M. Young in his <a href="https://github.com/jitterted/yacht-tdd">Yacht codebase</a>.
it(&#34;rolls a hand of dice&#34;, async () =&gt; {
  <em>// Configure die rolls</em>
  const dieRoller = DieRoller.createNull([ 1, 2, 3, 4, 5 ]);

  <em>// Run production code</em>
  const game = new Game(dieRoller);
  const hand = game.roll();

  <em>// Check results</em>
  assert.deepEqual(hand, HandOfDice.create(1, 2, 3, 4, 5));
});
</code></pre>

<p>If your Nullable uses an <a href="#embedded-stub">Embedded Stub</a>, implement the responses in the stub. Otherwise, <a href="#fake-it">Fake It Once You Make It</a>. Either way, decompose the responses down to the next level.</p>

<p>The following example uses an Embedded Stub to make a random die roller. It’s configured at the level its callers care about: dice roll results. In the Embedded Stub, those configured values are decomposed to the level DieRoller operates at: random floating point numbers from between zero and one. For example, a configured roll of <code>6</code> is turned into the floating point number <code>0.83333</code>.

</p><pre><code>// Example of implementing Configurable Responses in an Embedded Stub. (JavaScript)

<em>// <a href="#infrastructure-wrappers">Infrastructure Wrapper</a></em>
export default class DieRoller {

  static create() {
    return new DieRoller(Math);    // &#34;Math&#34; is a built-in JavaScript global
  }

  <em>// Null factory with Configurable Responses</em>
  // If a number is provided, it always returns that number.
  // If an array is provided, it returns exactly the numbers provided, then throws an error when it runs out.
  // If nothing is provided, it defaults to returning ones.
  static createNull(rolls = 1) {                    // set default to 1
    return new DieRoller(new StubbedMath(rolls));   // pass configuration to Embedded Stub
  }

  constructor(math) {
    this._math = math;
  }

  roll(amount) {
    const randomNumber = this._math.random();
    return Math.trunc((randomNumber * 6) + 1);      // There&#39;s no need to stub Math.trunc, so we use the real Math global
  }
};

<em>// Embedded Stub with Configurable Responses</em>
class StubbedMath {

  constructor(rolls) {
    <em>// Store configured responses</em>
    this._rolls = rolls;
  }

  random() {
    <em>// Use configured responses</em>
    const roll = this.#nextRoll();    // Get configuration to use
    return (roll - 1) / 6;            // Convert to float to match behavior of real Math.random()
  }

  <em>// Retrieve configured response</em>
  #nextRoll() {
    if (Array.isArray(this._rolls)) {
      <em>// Configuration is an array, so return the next roll in the array</em>
      const roll = this._rolls.shift();
      if (roll === undefined) throw new Error(&#34;No more rolls configured in nulled DieRoller&#34;);
      return roll;
    }
    else {
      <em>// Configuration is a number, so always return that number</em>
      return this._rolls;
    }
  }
}
</code></pre>

<p>The above code can be simplified by factoring <code>#nextRoll()</code> into a generic helper class. The result looks like this:</p>

<pre><code>// Example of implementing an embedded stub with a ConfigurableResponses helper class (JavaScript)
<em>class StubbedMath</em> {
  constructor(rolls) {
    this._rolls = <em>ConfigurableResponses.create(rolls)</em>;
  }

  random() {
    return (<em>this._rolls.next()</em> - 1) / 6;
  }
}
</code></pre>

<p>This is a JavaScript implementation of <code>ConfigurableResponses</code> you can use in your own code:</p>

<pre><code>// Copyright 2023 Titanium I.T. LLC. MIT License.
export default class ConfigurableResponses {

  // Create a list of responses (by providing an array),
  // or a single repeating response (by providing any other type).
  // &#39;Name&#39; is optional and used in error messages.
  static create(responses, name) {
    return new ConfigurableResponses(responses, name);
  }

  // Convert all properties in an object into ConfigurableResponse instances.
  // For example, { a: 1 } becomes { a: ConfigurableResponses.create(1) }.
  // &#39;Name&#39; is optional and used in error messages.
  static mapObject(responseObject, name) {
    const entries = Object.entries(responseObject);
    const translatedEntries = entries.map(([ key, value ]) =&gt; {
      const translatedName = name === undefined ? undefined : `${name}: ${key}`;
      return [ key, ConfigurableResponses.create(value, translatedName )];
    });
    return Object.fromEntries(translatedEntries);
  }

  constructor(responses, name) {
    this._description = name === undefined ? &#34;&#34; : ` in ${name}` ;
    this._responses = Array.isArray(responses)
      ? [ ...responses ]
      : responses;
  }

  // Get next configured response. Throws an error when configured with a list
  // of responses and no more responses remain.
  next() {
    const response = Array.isArray(this._responses)
      ? this._responses.shift()
      : this._responses;
    if (response === undefined) throw new Error(`No more responses configured${this._description}`);

    return response;
  }

};
</code></pre>


<p>To test code with dependencies that write to infrastructure, use <a href="#output-tracking">Output Tracking</a>. To test code with dependencies that respond to events, use <a href="#behavior-simulation">Behavior Simulation</a>.</p>

<p><a href="#toc">Contents</a></p>


<h4 id="output-tracking">Output Tracking</h4>

<p><a href="#state-based-tests">State-based tests</a> of code with dependencies that write to external systems need to check whether the writes were performed, but setting up external systems is complicated and slow. <em>Therefore:</em></p>

<p>Program each dependency with a tested, production-grade <code>trackXxx()</code> method that tracks the otherwise-invisible writes. Have it do so regardless of whether the object is <a href="#nullables">Nulled</a> or not.</p>

<p>Track the writes in terms of the <em>behavior</em> your callers care about, not the underlying <em>implementation</em> of your code. For example, a structured logger might write strings to <code>stdout</code>, but its callers care about the structured data that’s being written. Its Output Tracking would track the data, not the string.</p>

<p>One way to implement Output Tracking is to have <code>trackXxx()</code> return an <code>OutputTracker</code> that listens for events emitted by your production code. The following example shows how this works, including implementations of <code>OutputTracker</code> in JavaScript and Java that you can use in your own code. It starts with a test of <code>LoginPage</code>, which writes to a structured <code>Log</code> when the user logs in.</p>

<pre><code>// Example of using Output Tracking (JavaScript)

<em>// Application layer test</em>
it(&#34;writes to log when user logs in&#34;, async () =&gt; {
  <em>// Set up a log and track its output</em>
  const log = Log.createNull();
  const logOutput = log.trackOutput();

  // Instantiate the code under test
  const loginPage = new LoginPage(log);

  // Run the code
  const formData = // code to set up &#34;my_email&#34; login here
  await loginPage.postAsync(formData);

  <em>// Check the log output</em>
  assert.deepEqual(logOutput.data, [{
    alert: &#34;info&#34;,
    message: &#34;User login&#34;,
    email: &#34;my_email&#34;,
  }]);
});

<em>// Application layer code</em>
class LoginPage {
  constructor(log) {
    this._log = log;
  }

  async postAsync(formData) {
    const email = // code to parse formData and verify login goes here

    <em>// Code under test</em>
    this.log.info({
      message: &#34;User login&#34;,
      email,
    });
  }
}

<em>// High-level &#34;Log&#34; infrastructure wrapper used by the code under test </em>
import Clock from &#34;clock&#34;;                        // Low-level infrastructure wrapper
import Stdout from &#34;stdout&#34;;                      // Low-level infrastructure wrapper
import { EventEmitter } from &#34;node:events&#34;;       // Standard Node.js event library
import OutputTracker from &#34;output_tracker&#34;;       <em>// Output tracking library</em>

const OUTPUT_EVENT = &#34;output&#34;;                    <em>// Event to emit when output occurs</em>

class Log {
  static create() {
    return new Log(Clock.create(), Stdout.create());
  }

  static createNull({
    clock = Clock.createNull(),                   // <a href="#fake-it">Fake It Once You Make It</a>
    stdout = Stdout.createNull(),
  } = {}) {
    return new Log(clock, stdout);
  }

  constructor(clock, stdout) {
    this._clock = clock;
    this._stdout = stdout;

    this._emitter = new EventEmitter();           <em>// Event emitter used when output occurs</em>
  }

  <em>// Output tracker</em>
  trackOutput() {
    return OutputTracker.create(this._emitter, OUTPUT_EVENT);
  }

  <em>// The method called by the code under test</em>
  info(data) {
    data.alert = &#34;info&#34;;

    <em>// Write the log</em>
    const now = this._clock.formattedTimestamp();
    const dataJson = JSON.stringify(data);
    this._stdout.write(`${now} ${dataJson}`);

    <em>// Emit the event. This is received by the OutputTracker.</em>
    this._emitter.emit(OUTPUT_EVENT, data);
  }
}
</code></pre>

<p>At first glance, Output Tracking might look like the same thing as a spy (a type of test double), but there’s an important difference. Output Tracking records <em>behavior</em>, and spies record <em>function calls</em>. Output Trackers should write objects that represent the action that was performed, not just the function that was called to perform it. That way, when you refactor, you can change your functions without changing your Output Trackers or the tests that depend on them.</p>

<p>This is a JavaScript version of the <code>OutputTracker</code> class you can use in your own projects:</p>

<pre><code>// Copyright 2020-2022 Titanium I.T. LLC. <a href="https://mit-license.org/">MIT License.</a>
export default class OutputTracker {

  static create(emitter, event) {
    return new OutputTracker(emitter, event);
  }

  constructor(emitter, event) {
    this._emitter = emitter;
    this._event = event;
    this._data = [];

    this._trackerFn = (text) =&gt; this._data.push(text);
    this._emitter.on(this._event, this._trackerFn);
  }

  get data() {
    return this._data;
  }

  clear() {
    const result = [ ...this._data ];
    this._data.length = 0;
    return result;
  }

  stop() {
    this._emitter.off(this._event, this._trackerFn);
  }

}
</code></pre>

<p>Below, I’ve also included a Java version of the <code>OutputTracker</code> library that I created with Ted M. Young. Because Java doesn’t have a built-in event emitter, it’s used slightly differently. Here’s an example of using it in the <code>Log</code> infrastructure wrapper from the earlier example:</p>

<pre><code>// Example of Output Tracking in <em>Java</em>
public class Log {
  // Instantiate the event emitter
  <em>private final OutputListener&lt;LogData&gt; outputListener = new OutputListener&lt;&gt;();</em>

  public static Log create...
  public static Log createNull...
  private Log...

  // Create the output tracker
  public OutputTracker&lt;LogData&gt; trackOutput() {
    <em>return outputListener.createTracker();</em>
  }

  public void info(Map&lt;String, LogData&gt; data) {
    // ...

    // Emit the event
    <em>outputListener.track(data);</em>
  }
}
</code></pre>

<p>This is the Java version of <code>OutputTracker</code>. Split it into two files.</p>

<pre><code><em>---- OutputListener.java ----</em>
// Copyright 2022 Titanium I.T. LLC and Ted M. Young. <a href="https://mit-license.org/">MIT License.</a>
package com.jamesshore.output_tracker;

import java.util.ArrayList;
import java.util.List;

public class OutputListener&lt;T&gt; {
  private final List&lt;OutputTracker&lt;T&gt;&gt; listeners = new ArrayList&lt;&gt;();

  public void track(T data) {
    listeners.forEach(tracker -&gt; tracker.add(data));
  }

  public OutputTracker&lt;T&gt; createTracker() {
    OutputTracker&lt;T&gt; tracker = new OutputTracker&lt;&gt;(this);
    listeners.add(tracker);
    return tracker;
  }

  void remove(OutputTracker&lt;T&gt; outputTracker) {
    listeners.remove(outputTracker);
  }
}

<em>---- OutputTracker.java ----</em>
// Copyright 2022 Titanium I.T. LLC and Ted M. Young. <a href="https://mit-license.org/">MIT License.</a>
package com.jamesshore.output_tracker;

import java.util.ArrayList;
import java.util.List;

public class OutputTracker&lt;T&gt; {
  private final List&lt;T&gt; output = new ArrayList&lt;&gt;();
  private final OutputListener&lt;T&gt; outputListener;

  public OutputTracker(OutputListener&lt;T&gt; outputListener) {
    this.outputListener = outputListener;
  }

  void add(T data) {
    output.add(data);
  }

  public List&lt;T&gt; data() {
    return List.copyOf(output);
  }

  public List&lt;T&gt; clear() {
    List&lt;T&gt; data = this.data();
    output.clear();
    return data;
  }

  public void stop() {
    outputListener.remove(this);
  }
}
</code></pre>

<p>To test code with dependencies that read from infrastructure, use <a href="#configurable-responses">Configurable Responses</a>. To test code with dependencies that emit events, use <a href="#behavior-simulation">Behavior Simulation</a>.</p>

<p><a href="#toc">Contents</a></p>


<h4 id="behavior-simulation">Behavior Simulation</h4>

<p>Some external systems will push data to you rather than waiting for you to ask for it. Code that depends on those systems need a way to test what happens when their infrastructure dependencies generate those events, but setting up infrastructure to send events is complicated and slow. <em>Therefore:</em></p>

<p>Add methods to your dependencies that simulate receiving an event from an external system. Share as much code as possible with the code that handles real external events. Write it as tested, production-grade code.</p>

<p>The following example consists of an Application-layer <code>MessageServer</code> that performs real-time networking. <code>MessageServer</code> runs on a server and connects to web browsers using <code>WebSocketServer</code>, a low-level infrastructure wrapper for Socket.IO. When a connected browser sends a message to <code>MessageServer</code>, it relays the messages to all the other connected browsers.</p>

<p>The test uses Behavior Simulation to simulate web browsers connecting and sending messages, then validates <code>MessageServer</code>’s behavior by using <a href="#output-tracking">Output Tracking</a> to confirm that the correct messages were sent.</p>

<pre><code>// Example of using Behavior Simulation (JavaScript)

<em>// Application layer test</em>
it(&#34;broadcasts messages from one client to all others&#34;, async () =&gt; {
  // Set up test data
  const clientId = &#34;my_client_id&#34;;
  const message = new TestClientMessage(&#34;my_message&#34;);

  // Set up the infrastructure wrapper and the code under test
  const network = WebSocketServer.createNull();   // Create the infrastructure wrapper
  const sentMessages = network.trackMessages();   // Track messages sent by infrastructure wrapper (<a href="#output-tracking">Output Tracking</a>)
  const server = new MessageServer(network);      // Instantiate the application code under test
  await server.startAsync();                      // Start listening for messages (<a href="#zero-impact">Zero-Impact Instantiation</a>)

  <em>// Simulate a client connecting</em>
  network.simulateConnection(clientId);

  <em>// Simulate the client sending a message</em>
  network.simulateMessage(clientId, message);

  // Check that the message was broadcast (<a href="#output-tracking">Output Tracking</a>)
  assert.deepEqual(sentMessages.data(), [{
    type: &#34;broadcast&#34;,
    excludedClient: clientId,
    message
  }]);
});

<em>// Application layer code</em>
class MessageServer {
  constructor(webSocketServer) {
    this._webSocketServer = webSocketServer;
  }

  async startAsync() {
    <em>// Code under test</em>
    this._webSocketServer.onMessage((clientId, message) =&gt; {
      this._webSocketServer.broadcastToAllClientsExcept(clientId, message);
    });

    await this._webSocketServer.startAsync();
  }

  //...
}
</code></pre>

<p>The Behavior Simulation logic is implemented as production code in <code>WebSocketServer</code>, the low-level Socket.IO wrapper. Note how the real Socket.IO logic and the simulation methods share as much implementation as possible by delegating to <code>#handleXxx()</code> methods.</p>

<pre><code>// Example of implementing Behavior Simulation (JavaScript)
import { Server } from &#34;socket.io&#34;;               // Socket.IO
import { EventEmitter } from &#34;node:events&#34;;       // Standard Node.js event library
import OutputTracker from &#34;output_tracker&#34;;       // Output tracking library

const CLIENT_MESSAGE_EVENT = &#34;client_message&#34;;    // Event constants
const SERVER_MESSAGE_EVENT = &#34;server_message&#34;;

class WebSocketServer {
  static create(port) {
    return new WebSocketServer(io, port);
  }

  static createNull() {
    return new WebSocketServer(StubbedServer, 42);
  }

  constructor(server, port) {
    this._server = server;
    this._port = port;
    this._emitter = new EventEmitter();
    this._connectedSockets = {};
  }

  <em>// Real Socket.IO event handler</em>
  async startAsync() {
    this._io.on(&#34;connection&#34;, (socket) =&gt; {
      this.#handleConnection(socket);
      socket.onAny((event, ...args) =&gt; {
        const message = this.#deserializeMessage(event, args);
        this.#handleMessage(socket.id, message);
      });
      socket.on(&#34;disconnect&#34;, () =&gt; {
        this.#handleDisconnection(socket.id));
      });
    });
  }

  <em>// Behavior Simulation</em>
  simulateConnection(clientId) {
    this.#handleConnection(new StubbedSocket(clientId));
  }

  simulateMessage(clientId, message) {
    this.#handleMessage(clientId, message);
  }

  simulateDisconnection(clientId) {
    this.#handleDisconnection(clientId);
  }

  <em>// Shared by event handler and behavior simulation</em>
  #handleConnection(socket) {
    this._connectedSockets[socket.id] = socket;
  )

  #handleMessage(clientId, message) {
    this._emitter.emit(CLIENT_MESSAGE_EVENT, { clientId, message });
  }

  #handleDisconnection(clientId) {
    delete this._connectedSockets(clientId);
  }

  <em>// Methods called by the code under test</em>
  onMessage(fn) {
    this._emitter.on(CLIENT_MESSAGE_EVENT, ({ clientId, message }) =&gt; {
      fn(clientId, message));
    });
  }

  broadcastToAllClientsExcept(clientId, message) {
    const socket = this._connectedSockets[clientId];
    socket.broadcast.emit(message.name, message.payload);

    this._emitter.emit(SERVER_MESSAGE_EVENT, {    // <a href="#output-tracking">Output Tracking</a>
      type: &#34;broadcast&#34;,
      excludedClient: clientId,
      message,
    });
  });

  // <a href="#output-tracking">Output Tracking</a>
  trackMessages() {
    return OutputTracker.create(this._emitter, SERVER_MESSAGE_EVENT);
  }

  //...
}
</code></pre>

<p>To test code with dependencies that read from infrastructure, use <a href="#configurable-responses">Configurable Responses</a>. To test code with dependencies that write to infrastructure, use <a href="#output-tracking">Output Tracking</a>.</p>

<p><a href="#toc">Contents</a></p>


<h4 id="fake-it">Fake It Once You Make It</h4>

<p><a href="#narrow-integration-tests">Narrow Integration Tests</a> are slow and difficult to set up. Similarly, <a href="#embedded-stub">Embedded Stubs</a> can be difficult to create. Although they’re needed for low-level infrastructure wrappers, they’re overkill for code that doesn’t have direct dependencies on third-party infrastructure code. <em>Therefore:</em>

</p><p>In application-layer code and high-level infrastructure wrappers, delegate to <a href="#nullables">Nullable</a> dependencies rather than using Narrow Integration Tests and Embedded Stubs. In your tests, inject Nulled instances of the code under test’s dependencies. If your production code has a <code>createNull()</code> factory, implement it by creating Nulled dependencies and decomposing your <a href="#configurable-responses">Configurable Responses</a> into the format your dependencies expect.</p>

<p>For example, the following code tests <code>LoginClient</code>, which depends on a low-level <code>HttpClient</code>. The <code>LoginClient</code> tests Fake It Once You Make It by injecting a Nulled version of <code>HttpClient</code> into <code>LoginClient</code>.</p>

<pre><code>// Example of a using Fake It Once You Make It in a test (JavaScript)

it(&#34;performs network request&#34;, async () =&gt; {
  <em>// Set up the low-level HTTP client (<a href="#configurable-responses">Configurable Responses</a>)</em>
  const httpClient = HttpClient.createNull({
    &#34;/oauth/token&#34;: [{                        // The Auth0 endpoint our code will call.
      status: VALID_STATUS,                   // Status, headers, and body Auth0 could really return.
      headers: VALID_HEADERS,
      body: VALID_BODY,
    }],
  });

  <em>// Track requests made with the HTTP client (<a href="#output-tracking">Output Tracking</a>)</em>
  const httpRequests = httpClient.trackRequests();

  <em>// Instantiate the code under test, injecting the Nulled httpClient</em>
  const client = new LoginClient(httpClient, &#34;my_client_id&#34;, &#34;my_client_secret&#34;, &#34;my_management_api_token&#34;);

  <em>// Run the code under test</em>
  await client.validateLoginAsync(&#34;my_login_code&#34;, &#34;my_callback_url&#34;);

  <em>// Assert that the correct HTTP request was made (<a href="#output-tracking">Output Tracking</a>)</em>
  assert.deepEqual(httpRequests.data, [{
    host: HOST,
    port: PORT,
    method: &#34;post&#34;,
    path: &#34;/oauth/token&#34;,
    headers: {
      authorization: &#34;Bearer my_management_api_token&#34;,
      &#34;content-type&#34;: &#34;application/json; charset=utf-8&#34;,
    },
    body: JSON.stringify({
      client_id: &#34;my_client_id&#34;,
      client_secret: &#34;my_client_secret&#34;,
      code: &#34;my_login_code&#34;,
      redirect_uri: &#34;my_callback_url&#34;,
      grant_type: &#34;authorization_code&#34;
    }),
  }]);
});
</code></pre>

<p>The production <code>LoginClient</code> code is a wrapper for Auth0, an authentication service. <code>LoginClient.createNull()</code> has Configurable Responses related to authentication, such as configuring the login email address. They’re implemented by creating a Nulled <code>HttpClient</code> and decomposing <code>LoginClient</code>’s Configurable Responses into the actual HTTP responses Auth0 would return.</p>

<pre><code>// Example of a using Fake It Once You Make It to make a class Nullable (JavaScript)
class LoginClient {

  // Normal factory
  static create(host, clientId, clientSecret, managementApiToken) {
    const httpClient = HttpClient.create();
    return new LoginClient(httpClient, host, clientId, clientSecret, managementApiToken);
  }

  <em>// Null factory with <a href="#configurable-responses">Configurable Responses</a></em>
  static createNull({
    // Configurable Responses for user’s login
    email = &#34;null_login_email&#34;,   // The email address associated with the login
    emailVerified = true,         // True if the email address has been verified
    forbidden = undefined,        // Set to a string to simulate an Auth0 &#34;forbidden&#34; response

    // Other parameters unrelated to Configurable Responses
    host = &#34;null.host&#34;,
    clientId = &#34;null_client_id&#34;,
    clientSecret = &#34;null_client_secret&#34;,
    managementApiToken = &#34;null_management_api_token&#34;,
  } = {}) {
    <em>// Convert LoginClient&#39;s Configurable Response into the response Auth0 would actually return</em>
    const auth0Response = nullValidateLoginResponse({ email, emailVerified, forbidden });

    <em>// Create a Nulled HttpClient that&#39;s configured to return the Auth0 response</em>
    const httpClient = HttpClient.createNull({
      [VALIDATE_LOGIN_ENDPOINT]: auth0Response;
    });

    <em>// Instantiate the LoginClient using the Nulled HttpClient</em>
    return new LoginClient(httpClient, clientId, clientSecret, managementApiToken);
  }

  // Shared initialization
  constructor(httpClient, host, clientId, clientSecret, managementApiToken) {
    this._httpClient = httpClient;
    this._host = host;
    this._clientId = clientId;
    this._clientSecret = clientSecret;
    this._authHeaders = {
      authorization: `Bearer ${managementApiToken}`,
    };
  }

  // Shared production code
  async validateLoginAsync(code, callbackUrl) {
    const response = await this._httpClient.requestAsync(
      host: this._host,
      method: &#34;POST&#34;,
      path: VALIDATE_LOGIN_ENDPOINT,
      headers: this._authHeaders,
      body: {
        client_id: this._clientId,
        client_secret: this._clientSecret,
        code,
        redirect_uri: callbackUrl,
        grant_type: &#34;authorization_code&#34;
      },
    );

    const decodedToken = /* code to validate and decode response here */

    return {
      email: decodedToken.email,
      emailVerified: decodedToken.email_verified
    };
  }

  <em>// <a href="#configurable-responses">Configurable Responses</a> translation code</em>
  // This function decomposes the responses passed to LoginClient.createNull() down
  // into responses for HttpClient.createNull(). HttpClient.createNull() is configured
  // with a status, optional headers, and a body.
  function nullValidateLoginResponse({ email, emailVerified, forbidden }) {
    <em>// If the &#34;forbidden&#34; response is set, return a 403 (Forbidden) response.</em>
    if (forbidden) return { status: STATUS.FORBIDDEN_403, body: forbidden };

    <em>// Otherwise, create a JSON Web Token, because that&#39;s what Auth0 returns</em>
    const response = { email, email_verified: emailVerified };
    const id_token = jwt.sign(response, &#34;irrelevant_secret&#34;, { noTimestamp: true });

    <em>// Return the JWT in a 200 (OK) response</em>
    return {
      status: STATUS.OK_200,
      body: JSON.stringify({ id_token }),
    };
  }
}
</code></pre>

<p>Implement <a href="#output-tracking">Output Tracking</a> and <a href="#behavior-simulation">Behavior Simulation</a> normally, without regard to whether the dependencies are Nulled or not.</p>

<p>To make your dependencies <a href="#nullables">Nullable</a>, either <a href="#descend-ladder">Descend the Ladder</a> or <a href="#climb-ladder">Climb the Ladder</a>.</p>

<p><a href="#toc">Contents</a></p>


<h3 id="legacy-patterns">Legacy Code Patterns</h3>

<p>If you’d like to convert your existing code and tests to use <a href="#nullables">Nullables</a>, the patterns in this section will help you do so.</p>

<p>Work incrementally. You can mix Nullables with your current approach in the same codebase, and even in the same test, so there’s no need to convert everything at once. Similarly, focus your efforts on code where testing with Nullables will have noticeable benefit. Don’t waste time converting code that’s already easy to maintain, regardless of how it’s tested.</p>

<ul>
  <li><a href="#descend-ladder">Descend the Ladder</a></li>
  <li><a href="#climb-ladder">Climb the Ladder</a></li>
  <li><a href="#replace-mocks-with-nullables">Replace Mocks with Nullables</a></li>
  <li><a href="#throwaway-stub">Throwaway Stub</a></li>
</ul>


<h4 id="descend-ladder">Descend the Ladder</h4>

<p>Complex codebases have a lot of dependencies, and it isn’t feasible to improve all the tests at once. Instead, you’ll need to make progress incrementally. <em>Therefore:</em></p>

<p>When converting a module or class to use Nullables, convert the code and its direct dependencies, but nothing more. Work your way down through the rest of the dependency tree gradually, when time allows.</p>

<p>Each module or class you convert will fall into one of three categories:</p>

<h5>A. No Infrastructure Dependencies</h5>

<p>If the code doesn’t have infrastructure anywhere in its dependency tree, it doesn’t need to use Nullables. It can be tested with the <a href="#logic-patterns">Logic Patterns</a> instead.</p>


<h5>B. Infrastructure Wrapper with Third-Party Dependencies</h5>

<p>If the code is an <a href="#infrastructure-wrappers">Infrastructure Wrapper</a> with direct third-party infrastructure dependencies, test it with <a href="#narrow-integration-tests">Narrow Integration Tests</a>, then make it <a href="#nullables">Nullable</a> with an <a href="#embedded-stub">Embedded Stub</a>.</p>


<h5>C. Everything Else</h5>

<p>For everything else, you’ll make your code’s direct dependencies Nullable, then <a href="#fake-it">Fake It Once You Make It</a>. To make the dependencies Nullable, apply one of the following options to each one:</p>

<ul>
  <li><p>In most cases, the dependency will have a combination of logic and infrastructure in its dependency chain. Check the following bullet points. If none of them apply, make the dependency <a href="#nullables">Nullable</a> by introducing a <a href="#throwaway-stub">Throwaway Stub</a>.</p></li>

  <li><p>If the dependency is already <a href="#nullables">Nullable</a>, or if it doesn’t have any infrastructure dependencies, no changes are needed.</p></li>

  <li><p>If the dependency isn’t <a href="#nullables">Nullable</a>, but all of <em>its</em> dependencies are, make it Nullable by <a href="#fake-it">Faking It Once You Make It</a>.</p></li>

  <li><p>If the dependency is a low-level <a href="#infrastructure-wrappers">Infrastructure Wrapper</a> with third-party dependencies, make it Nullable by introducing an <a href="#embedded-stub">Embedded Stub</a>.</p></li>

  <li><p>If the dependency is third-party infrastructure code, extract it into an <a href="#infrastructure-wrappers">Infrastructure Wrapper</a>. Test the new Infrastructure Wrapper with <a href="#narrow-integration-tests">Narrow Integration Tests</a> and make it <a href="#nullables">Nullable</a> by introducing an <a href="#embedded-stub">Embedded Stub</a>.</p></li>
</ul>

<p>After you’ve updated the dependencies, <a href="#fake-it">Fake It Once You Make It</a>. (If your code has a <a href="#throwaway-stub">Throwaway Stub</a>, replace it.) <a href="#replace-mocks-with-nullables">Replace Mocks with Nullables</a> and add tests as needed.</p>

<p>When you’re done, the code you’re converting will be Nullable and tested. Its dependencies will be Nullable, but not tested. You can move on to other work. When you’re ready to convert another class or module, Descend the Ladder again. Over time, you’ll gradually convert the entire codebase.</p>


<h5>Example</h5>

<p>Imagine you have the dependency chain <code>Router</code> → <code>LoginController</code> → <code>Auth0Client</code> → <code>HttpClient</code>, where <code>HttpClient</code> is a low-level <a href="#infrastructure-wrappers">Infrastructure Wrapper</a>. To convert <code>Router</code>, you would follow these steps:</p>

<ol>
  <li><p><code>Router</code>’s direct dependency is
    <code>LoginController</code>, which has a mix of logic and infrastructure in its dependency chain. Make
    <code>LoginController</code> <a href="#nullables">Nullable</a> with a <a href="#throwaway-stub">Throwaway Stub</a>.</p></li>
  <li><p>Make <code>Router</code> Nullable with <a href="#fake-it">Fake It Once You Make It</a>.</p></li>
  <li><p>Convert <code>Router</code>’s tests with <a href="#replace-mocks-with-nullables">Replace Mocks with Nullables</a>.</p></li>
</ol>

<p>Later, if you wanted to convert <code>Auth0Client</code>, you would follow these steps:</p>

<ol>
  <li><p><code>Auth0Client</code>’s direct dependency is <code>HttpClient</code>, which is a low-level <a href="#infrastructure-wrappers">Infrastructure Wrapper</a>. Make
    <code>HttpClient</code> Nullable by introducing an <a href="#embedded-stub">Embedded Stub</a>.</p></li>
  <li><p>Make <code>Auth0Client</code> Nullable with <a href="#fake-it">Fake It Once You Make It</a>.</p></li>
  <li><p>Convert <code>Auth0Client</code>’s tests with <a href="#replace-mocks-with-nullables">Replace Mocks with Nullables</a>.</p></li>
</ol>

<p>When you wanted to convert <code>LoginController</code>, you would follow these steps:</p>

<ol>
  <li><p><code>LoginController</code>’s direct dependency is
    <code>Auth0Client</code>, which was previously converted, so it’s already Nullable.</p></li>
  <li><p><code>LoginController</code> has a <a href="#throwaway-stub">Throwaway Stub</a> from when
    <code>Router</code> was converted. Now that <code>Auth0Client</code> is Nullable, replace the stub with <a href="#fake-it">Fake It Once You Make It</a>.</p></li>
  <li><p>Convert <code>LoginController</code>’s tests with <a href="#replace-mocks-with-nullables">Replace Mocks with Nullables</a>.</p></li>
</ol>

<p>Finally, when you were ready to convert <code>HttpClient</code>, you would follow these steps:</p>

<ol>
  <li><p><code>HttpClient</code> is a low-level <a href="#infrastructure-wrappers">Infrastructure Wrapper</a>, and it was made Nullable when
    <code>Auth0Client</code> was converted, so it only needs to be tested.</p></li>
  <li><p>Test <code>HttpClient</code> with <a href="#narrow-integration-tests">Narrow Integration Tests</a>.</p></li>
</ol>

<p>Code that’s been converted can be refactored without breaking its tests. Once you’ve converted enough code, you can refactor it to use <a href="#a-frame-arch">A-Frame Architecture</a> or any other architecture you like.</p>

<p>Descend the Ladder is for code with large dependency trees. If the code you’re converting has a small dependency tree, <a href="#climb-ladder">Climb the Ladder</a> instead.</p>

<p><a href="#toc">Contents</a></p>


<h4 id="climb-ladder">Climb the Ladder</h4>

<p><a href="#descend-ladder">Descending the Ladder</a> is a careful, methodical approach to improving existing code. However, it involves creating <a href="#throwaway-stub">Throwaway Stubs</a>, which is wasteful, and it takes a long time. Simple dependency trees don’t need so much care. <em>Therefore:</em>

</p><p>When your dependency tree is simple, convert the entire tree at once. Start by graphing out a dependency tree for the code you want to convert, ignoring third-party dependencies. Then convert each node from the bottom of the tree up. (A post-order depth-first traversal). Apply one of the following options to each node:</p>

<ul>
  <li><p>If the node is pure logic, with no infrastructure dependencies, make sure it has <a href="#visible-behavior">Easily Visible Behavior</a>, then add tests as needed.</p></li>

  <li><p>If the node is already <a href="#nullables">Nullable</a>, convert its tests by <a href="#replace-mocks-with-nullables">Replacing Mocks with Nullables</a> and adding tests as needed.</p></li>

  <li><p>If the node is an <a href="#infrastructure-wrappers">Infrastructure Wrapper</a> <em>and</em> it uses third-party infrastructure code, make it <a href="#nullables">Nullable</a> by introducing an <a href="#embedded-stub">Embedded Stub</a>. Test it with <a href="#narrow-integration-tests">Narrow Integration Tests</a>.</p></li>

  <li><p>If the node <em>isn’t</em> an Infrastructure Wrapper, but it <em>does</em> use third-party infrastructure code, extract the third-party code into an <a href="#infrastructure-wrappers">Infrastructure Wrapper</a>. Apply the above option to the Infrastructure Wrapper, then apply the below option to the remaining code.</p></li>

  <li><p>If the node’s isn’t an Infrastructure Wrapper and doesn’t use third-party infrastructure code, <a href="#fake-it">Fake It Once You Make It</a>. Convert its tests by <a href="#replace-mocks-with-nullables">Replacing Mocks with Nullables</a> and adding tests as needed.</p></li>
</ul>

<p>When you’re done, the entire dependency tree will be tested and <a href="#nullables">Nullable</a>. You can then refactor it toward <a href="#a-frame-arch">A-Frame Architecture</a> or any other architecture you like.</p>

<p>For example, imagine you have the dependency chain <code>Router</code> → <code>LoginController</code> → <code>Auth0Client</code> → <code>HttpClient</code>, where <code>HttpClient</code> is a low-level <a href="#infrastructure-wrappers">Infrastructure Wrapper</a>. To convert <code>Router</code>, you would follow these steps:</p>

<ol>
  <li><code>HttpClient</code> is a low-level <a href="#infrastructure-wrappers">Infrastructure Wrapper</a>. Make it <a href="#nullables">Nullable</a> by introducing an <a href="#embedded-stub">Embedded Stub</a>.</li>
  <li>Test <code>HttpClient</code> with <a href="#narrow-integration-tests">Narrow Integration Tests</a>.</li>
  <li>Make <code>Auth0Client</code> <a href="#nullables">Nullable</a> with <a href="#fake-it">Fake It Once You Make It</a>.</li>
  <li>Convert <code>Auth0Client</code>’s tests with <a href="#replace-mocks-with-nullables">Replace Mocks with Nullables</a>.</li>
  <li>Make <code>LoginController</code> <a href="#nullables">Nullable</a> with <a href="#fake-it">Fake It Once You Make It</a>.</li>
  <li>Convert <code>LoginController</code>’s tests with <a href="#replace-mocks-with-nullables">Replace Mocks with Nullables</a>.</li>
  <li>Make <code>Router</code> <a href="#nullables">Nullable</a> with <a href="#fake-it">Fake It Once You Make It</a>.</li>
  <li>Convert <code>Router</code>’s tests with <a href="#replace-mocks-with-nullables">Replace Mocks with Nullables</a>.</li>
</ol>

<p>Climb the Ladder works best when you have a small dependency tree. If you have a large dependency tree, <a href="#climb-ladder">Descend the Ladder</a> instead.</p>

<p><a href="#toc">Contents</a></p>


<h4 id="replace-mocks-with-nullables">Replace Mocks with Nullables</h4>

<p>Existing code is often tested with mocks, spies, and other test doubles. Some of those tests will get in your way. They might be hard to understand and maintain, or they might make refactoring difficult. <em>Therefore:</em></p>

<p>When an existing test gets in your way, use <a href="#nullables">Nullables</a> in place of the existing test doubles. Depending on the quality of the existing tests, it might be easiest to inline any setup blocks or helper methods prior to starting. Then apply the following options to each mock, spy, or other test double in each test you want to convert:</p>

<ul>
  <li><p>Start by replacing the test double with a <a href="#nullables">Nulled</a> version of the real dependency.</p></li>

  <li><p>If the test double is configured to return specific values, replace the configuration with <a href="#configurable-responses">Configurable Responses</a>.</p></li>

  <li><p>If the test double is configured to emit events, replace the configuration with <a href="#behavior-simulation">Behavior Simulation</a>.</p></li>

  <li><p>If the test checks how a test double is called, replace its assertions with <a href="#output-tracking">Output Tracking</a>. Convert these test doubles last, after test doubles with only configuration have been replaced.</p>
</li></ul>

<p>For example, here’s a controller for a web page. When the user posts to the page, it uses the <code>rot13Client</code> infrastructure wrapper to call a web service, then renders the result.</p>

<pre><code>// Example web page controller (JavaScript + Node.js)

import * as homePageView from &#34;home_page_view&#34;;
import Rot13Client from &#34;rot13_client&#34;;
import HttpRequest from &#34;http_request&#34;;
import WwwConfig from &#34;www_config&#34;;

export default class HomePageController {
  constructor(rot13Client) {
    this._rot13Client = rot13Client;
  }

  // &#39;request&#39; is an HttpRequest instance
  // &#39;config&#39; is a WwwConfig instance
  async postAsync(request, config) {
    <em>// Parse the &#39;text&#39; field from the request&#39;s JSON body</em>
    const body = await request.readBodyAsync();
    const formData = new URLSearchParams(body); 
    const textFields = formData.getAll(&#34;text&#34;);
    const userInput = textFields[0];

    <em>// Call the web service</em>
    const output = await this._rot13Client.transformAsync(config.rot13ServiceHost, userInput);

    <em>// Render the page</em>
    return homePageView.homePage(output);
  }
};
</code></pre>

<p>The following test uses spies to check that the above code calls the web service. It’s an interaction-based test that checks whether the dependency’s methods are called correctly.</p>

<pre><code>// Example of spy-based test (JavaScript + testdouble.js)
  
it(&#34;POST asks ROT-13 service to transform text&#34;, async () =&gt; {
  <em>// Create spies</em>
  const rot13Client = td.instance(Rot13Client);
  const request = td.instance(HttpRequest);
  const config = td.instance(WwwConfig);

  <em>// Configure spies</em>
  config.rot13ServiceHost = &#34;my.rot13.host&#34;;   <em>// rot13ServiceHost is a getter, but testdouble.js can’t configure getters’ responses, so we just set the property directly</em>
  td.when(request.readBodyAsync()).thenResolve(&#34;text=hello%20world&#34;);

  <em>// Run the code under test</em>
  const controller = new HomePageController(rot13Client);
  await controller.postAsync(request, config);

  <em>// Check that the web service’s wrapper was called correctly</em>
  td.verify(rot13Client.transformAsync(&#34;my.rot13.host&#34;, &#34;hello world&#34;));
});
</code></pre>

<p>This test can be converted one spy at a time. First, we replace the <code>HttpRequest</code> spy with a <a href="#configurable-responses">Configurable Response</a>.</p>

<pre><code>// Replace HttpRequest spy (JavaScript + testdouble.js)

it(&#34;POST asks ROT-13 service to transform text&#34;, async () =&gt; {
  const rot13Client = td.instance(Rot13Client);

  <em>// Replace the HttpRequest spy with a real HttpRequest. (<a href="#nullables">Nullable</a> with <a href="#configurable-responses">Configurable Responses</a>)</em>
  <del>const request = td.instance(HttpRequest);</del>
  <em>const request = HttpRequest.createNull({ body: &#34;text=hello%20world&#34; });</em>

  const config = td.instance(WwwConfig);

  config.rot13ServiceHost = &#34;my.rot13.host&#34;;
  <del>td.when(request.readBodyAsync()).thenResolve(&#34;text=hello%20world&#34;);</del>    <em>// Old configuration no longer needed</em>

  const controller = new HomePageController(rot13Client);
  await controller.postAsync(request, config);

  td.verify(rot13Client.transformAsync(&#34;my.rot13.host&#34;, &#34;hello world&#34;));
});
</code></pre>

<p>Because <a href="#nullables">Nullables</a> can coexist with test doubles, the tests still pass after this change is made. Next, we replace the <code>WwwConfig</code> spy:</p>

<pre><code>// Replace WwwConfig spy (JavaScript + testdouble.js)

it(&#34;POST asks ROT-13 service to transform text&#34;, async () =&gt; {
  const rot13Client = td.instance(Rot13Client);
  const request = HttpRequest.createNull({ body: &#34;text=hello%20world&#34; });

  <em>// Replace the WwwConfig spy with a real WwwConfig. (<a href="#nullables">Nullable</a> with <a href="#configurable-responses">Configurable Responses</a>)</em>
  <del>const config = td.instance(WwwConfig);</del>
  <em>const config = WwwConfig.createNull({ rot13ServiceHost: &#34;my.rot13.host&#34; });</em>

  <del>config.rot13ServiceHost = &#34;my.rot13.host&#34;;</del>     <em>// Old configuration no longer needed (and real WwwConfig doesn&#39;t allow property to be set)</em>

  const controller = new HomePageController(rot13Client);
  await controller.postAsync(request, config);

  td.verify(rot13Client.transformAsync(&#34;my.rot13.host&#34;, &#34;hello world&#34;));
});
</code></pre>

<p>The tests continue to pass. Finally, we replace the <code>Rot13Client</code> spy:</p>

<pre><code>// Replace Rot13Client spy (JavaScript + testdouble.js)

it(&#34;POST asks ROT-13 service to transform text&#34;, async () =&gt; {
  <em>// Replace the Rot13Client spy with a real Rot13Client. (<a href="#nullables">Nullable</a>)</em>
  <del>const rot13Client = td.instance(Rot13Client);</del>
  <em>const rot13Client = Rot13Client.createNull();</em>

  <em>// Track the requests made by the Rot13Client. (<a href="#output-tracking">Output Tracking</a>)</em>
  <em>const rot13Requests = rot13Client.trackRequests();</em>

  const request = HttpRequest.createNull({ body: &#34;text=hello%20world&#34; });
  const config = WwwConfig.createNull({ rot13ServiceHost: &#34;my.rot13.host&#34; });

  const controller = new HomePageController(rot13Client);
  await controller.postAsync(request, config);

  <em>// Replace the method call check with a state-based output check. (<a href="#output-tracking">Output Tracking</a>)</em>
  <del>td.verify(rot13Client.transformAsync(&#34;my.rot13.host&#34;, &#34;hello world&#34;));</del>
  <em>assert.deepEqual(rot13Requests, [{</em>
  <em>  host: &#34;my.rot13.host&#34;,          </em>
  <em>  text: &#34;hello world&#34;,            </em>
  <em>});                               </em>
});
</code></pre>

<p>Here’s a side-by-side comparison of the two tests.</p>

<pre><code>// Side-by-side comparison of spy-based test and Nullables-based test (JavaScript + testdouble.js)

<em>// Interaction-based test using spies</em>
it(&#34;POST asks ROT-13 service to transform text&#34;, async () =&gt; {
  // Create dependencies
  const rot13Client = td.instance(Rot13Client);
  const request = td.instance(HttpRequest);
  const config = td.instance(WwwConfig);

  // Configure dependencies
  config.rot13ServiceHost = &#34;my.rot13.host&#34;;
  td.when(request.readBodyAsync()).thenResolve(&#34;text=hello%20world&#34;);

  // Run code under test
  const controller = new HomePageController(rot13Client);
  await controller.postAsync(request, config);

  // Check that rot13Client was called
  td.verify(rot13Client.transformAsync(&#34;my.rot13.host&#34;, &#34;hello world&#34;));
});

<em>// State-based test using <a href="#nullables">Nullables</a></em>
it(&#34;POST asks ROT-13 service to transform text&#34;, async () =&gt; {
  // Create and configure dependencies
  const rot13Client = Rot13Client.createNull();
  const rot13Requests = rot13Client.trackRequests();
  const request = HttpRequest.createNull({ body: &#34;text=hello%20world&#34; });
  const config = WwwConfig.createNull({ rot13ServiceHost: &#34;my.rot13.host&#34; });

  // Run code under test
  const controller = new HomePageController(rot13Client);
  await controller.postAsync(request, config);

  // Check that rot13Client made the correct request
  assert.deepEqual(rot13Requests, [{
    host: &#34;my.rot13.host&#34;,
    text: &#34;hello world&#34;,
  }]);
});
</code></pre>

<p>To make a dependency <a href="#nullables">Nullable</a>, either <a href="#descend-ladder">Descend the Ladder</a> or <a href="#climb-ladder">Climb the Ladder</a>.</p>

<p><a href="#toc">Contents</a></p>


<h4 id="throwaway-stub">Throwaway Stub</h4>

<p>Making a dependency <a href="#nullables">Nullable</a> requires making all of its infrastructure dependencies Nullable, too. Sometimes, that’s too much work to tackle all at once. <em>Therefore:</em>

</p><p>In the code you’re making Nullable, create <a href="#embedded-stub">Embedded Stubs</a> for any dependencies you don’t want to make Nullable. This will break the chain of <a href="#sociable-tests">Overlapping Sociable Tests</a>, leaving you vulnerable to behavioral changes in the dependencies, so throw away the stub and replace it with <a href="#fake-it">Fake It Once You Make It</a> as soon as the dependency is Nullable.</p>

<p>To avoid writing throwaway stubs, <a href="#climb-ladder">Climb the Ladder</a>.</p>

<p><a href="#toc">Contents</a></p>


<h3 id="conclusion">Conclusion</h3>

<p>These patterns are an effective way of writing code that is easy to test, easy to refactor, and doesn’t require broad tests.</p>

<p>For more resources related to these patterns, including screencasts, self-guided training, and more, see the <a href="https://teonbrooks.com/v2/projects/nullables">Nullables Hub</a>.</p>

<div>
	<p>This article was originally published in 2018. (<a href="https://teonbrooks.com/v2/projects/nullables/testing-without-mocks-2018">Read the original version here</a>.) It was completely overhauled in 2023 to add more detail, many more examples, improved structure, and patterns for dealing with legacy code.</p>

	<p>A big thank you to everyone who provided comments and feedback on the 2023 update of this article: Dave Foley, Aaron Jenson, Steven Harmon, Dirk Groot, Marcus Rådell, Seth McCarthy, Jay Bazuzi, Dave de Moel, Emily Bache, Steve Freeman, Martin Fowler, and many more. Thanks also to Matt Wynne and Ted M. Young for pairing with me to explore these ideas further.</p>
</div>
</div></div>
  </body>
</html>
