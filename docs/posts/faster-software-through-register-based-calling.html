<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://menno.io/posts/golang-register-calling/">Original</a>
    
    <div id="readability-page-1" class="page"><article>
  

  
    <p>Posted on <time datetime="2021-11-23T00:00:00+00:00">November 23, 2021</time></p>
  

  <p>The <a href="https://golang.org/doc/go1.17#compiler">release notes for Go 1.17</a> mention
an interesting change in the Go compiler:
<q>function arguments and return values will now be passed using registers
instead of the stack</q>.  The 
<a href="https://go.googlesource.com/proposal/+/refs/changes/78/248178/1/design/40724-register-calling.md">proposal document</a>
for the feature mentions an expected <q>5-10% throughput improvement across a
range of applications</q> which is significant, especially for no effort on the
developers part aside from recompiling with a newer version of the Go compiler.
I was curious to see what this actually looks like and decided to take a deeper
look. This will get more than a little nerdy so buckle up!</p>
<p>Note that although the catalyst for this blog article was a change in Go, much
of this article should be of interest generally even if you don&#39;t use Go.</p>
<h3 id="refresher-registers">Refresher: Registers</h3>
<p>At this point it&#39;s helpful to remind ourselves of what CPU registers are. In a
nutshell, they are small amounts of high speed temporary memory built into the
processor. Each register has a name and stores one
<a href="https://en.wikipedia.org/wiki/Word_(computer_architecture)">word</a> of data
each - this is 64 bits on almost all modern computers.</p>
<p>Some registers are general purpose while others have specific functions. In this
article you&#39;ll come across the AX, BX and CX general purpose registers, as well
as the SP (stack pointer) register which is special purpose.</p>
<h3 id="refresher-the-stack">Refresher: the Stack</h3>
<p>It&#39;s also useful to remind ourselves what the stack is in a computer program.
It&#39;s a chunk of memory that&#39;s placed at the top of a program&#39;s memory.
The stack is typically used store local variables, function arguments, function
return values and function return addresses. The stack grows downwards as items
are added to it.</p>
<p>Eli Bendersky has an <a href="https://eli.thegreenplace.net/2011/02/04/where-the-top-of-the-stack-is-on-x86">excellent article</a> about how stacks work which contains this helpful diagram:</p>
<img src="https://eli.thegreenplace.net/images/2011/02/stack1.png"/>
<p>When items are added to the stack we say that they are <em>pushed</em> onto the stack.
When items are removed from the stack we say that they are <em>popped</em> off the
stack. There are x86 CPU instructions for pushing and popping data onto and off
the stack.</p>
<p>The SP register mentioned earlier points to the item currently at the top of
the stack.</p>
<p>Note that I&#39;m taking some liberties here. The stack works like this on x86
computers (and many other CPU architectures) but not on all of them.</p>
<h3 id="calling-conventions">Calling Conventions</h3>
<p>In compiled software, when some code wants to call a function, the arguments
for that function need to somehow be passed to the function (and the return
values need to be passed back somehow when the function completes). There are
different agreed-upon ways to do this and each style of passing arguments and
return values around is a &#34;calling convention&#34;. </p>
<p>The part of the Go 1.17 release notes quoted above is really about a change in
Go&#39;s calling conventions.</p>
<p>This is all hidden from you unless you&#39;re programming in assembler or are
trying to make bits of code written in different programming languages work
together.  Even so, it&#39;s still interesting to see how the machinery works under
the hood. </p>
<h3 id="a-small-program">A Small Program</h3>
<p>In order to compare the code the Go compiler generates in 1.16 vs 1.17 we
need a simple test program. It doesn&#39;t have to do much, just call a function
that takes a couple of arguments which then returns a value. Here&#39;s the trivial
program I came up with:</p>
<pre data-lang="go"><code data-lang="go"><span>package </span><span>main
</span><span>
</span><span>import </span><span>&#34;</span><span>fmt</span><span>&#34;
</span><span>
</span><span>func </span><span>add</span><span>(</span><span>i</span><span>, </span><span>j </span><span>int</span><span>) </span><span>int </span><span>{
</span><span>    </span><span>return </span><span>i </span><span>+ </span><span>j
</span><span>}
</span><span>
</span><span>func </span><span>main</span><span>() {
</span><span>    </span><span>z </span><span>:= </span><span>add</span><span>(</span><span>22</span><span>, </span><span>33</span><span>)
</span><span>    </span><span>fmt</span><span>.</span><span>Println</span><span>(</span><span>z</span><span>)
</span><span>}
</span></code></pre>
<h3 id="disassembling">Disassembling</h3>
<p>In order to see the CPU instructions being generated by the Go compiler we need
a disassembler. One tool that can do this is venerable
<a href="https://linux.die.net/man/1/objdump">objdump</a> which comes with the GNU
binutils suite and may already be installed if you&#39;re running
Linux. I&#39;ll be using <code>objdump</code> in this article.</p>
<div><p>
    The Go build pipeline is a little unusual in that it generates
a kind of bespoke abstract assembly language before converting this to actual
machine specific instructions. This intermediate assembly language can be seen
using the <code>go tool objdump</code> command. </p>
<p>It&#39;s tempting to use this output for our exploration here but this intermediate
assembly language <a href="https://www.mit.edu/afs.new/sipb/project/golang/doc/asm.html">isn&#39;t necessarily a direct
representation</a>
of the machine code that will be generated for a given platform. For this reason I&#39;ve chosen
to stick with objdump.
</p></div>
<h3 id="go-1-16-s-output">Go 1.16&#39;s Output</h3>
<p>Let&#39;s take a look at the output from Go 1.16 which we expect to be using
stack based calling. First let&#39;s build the binary using Go 1.16 and make sure
it works:</p>
<pre data-lang="sh"><code data-lang="sh"><span>$</span><span> go1.16.10 build</span><span> -o</span><span> prog-116 ./main.go
</span><span>$</span><span> ./prog-116
</span><span>55
</span></code></pre>
<p>
    My Linux distro already had Go 1.17.3 installed and I used the approach described in the <a href="https://golang.org/doc/manage-install#installing-multiple">official docs</a> for installing Go 1.16.10.
</p>
<p>Great! Now lets disassemble it to see the generated instructions:</p>
<pre data-lang="sh"><code data-lang="sh"><span>$</span><span> objdump</span><span> -d</span><span> prog-116 &gt; prog-116.asm
</span></code></pre>
<p>The first thing I noticed is that there&#39;s quite of lot of code:</p>
<pre data-lang="sh"><code data-lang="sh"><span>$</span><span> wc</span><span> -l</span><span> prog-116.asm
</span><span>164670</span><span> prog-116.asm
</span></code></pre>
<p>That&#39;s a lot of instructions for such a small program but this is because every
Go program includes the Go runtime which is a non-trivial amount of software for
scheduling goroutines and providing all the conveniences we expect as Go developers.
Fortunately for us, the instructions directly relating to the code in our test
program are right at the bottom:</p>
<p>(I&#39;m omitting the offsets and raw bytes that objdump normally provides for
clarity; also some of Go&#39;s setup code)</p>
<pre><code><span>0000000000497640 &lt;main.main&gt;:
</span><span>  ...
</span><span>  movq   $0x37,(%rsp)
</span><span>  call   40a3e0 &lt;runtime.convT64&gt;
</span><span>  mov    0x8(%rsp),%rax
</span><span>  xorps  %xmm0,%xmm0
</span><span>  movups %xmm0,0x40(%rsp)
</span><span>  lea    0xaa7e(%rip),%rcx        # 4a2100 &lt;type.*+0xa100&gt;
</span><span>  mov    %rcx,0x40(%rsp)
</span><span>  mov    %rax,0x48(%rsp)
</span><span>  mov    0xb345d(%rip),%rax        # 54aaf0 &lt;os.Stdout&gt;
</span><span>  lea    0x4290e(%rip),%rcx        # 4d9fa8 &lt;go.itab.*os.File,io.Writer&gt;
</span><span>  mov    %rcx,(%rsp)
</span><span>  mov    %rax,0x8(%rsp)
</span><span>  lea    0x40(%rsp),%rax
</span><span>  mov    %rax,0x10(%rsp)
</span><span>  movq   $0x1,0x18(%rsp)
</span><span>
</span><span>  movq   $0x1,0x20(%rsp)
</span><span>
</span><span>  nop
</span><span>  call   491140 &lt;fmt.Fprintln&gt;
</span><span>  ...
</span></code></pre>
<p>Weird! This doesn&#39;t look like our code at all. Where&#39;s the call to our <code>add</code>
function? In fact, <code>movq   $0x37,(%rsp)</code> (move the value 0x37 to memory
location pointed to by the stack pointer register) looks super suspicious. 22 +
33 = 55 which is 0x37 in hex. It looks like the Go compiler has optimised the
code, working out the addition at compile time, eliminating most of our code in
the process!</p>
<p>In order to study this further we need to tell the Go compiler to not
<a href="https://dave.cheney.net/tag/inlining">inline</a> the add function which can be
done using a special comment to annotate the add function. <code>add</code> now looks like this:</p>
<pre data-lang="go"><code data-lang="go"><span>//go:noinline
</span><span>func </span><span>add</span><span>(</span><span>i</span><span>, </span><span>j </span><span>int</span><span>) </span><span>int </span><span>{
</span><span>    </span><span>return </span><span>i </span><span>+ </span><span>j
</span><span>}
</span></code></pre>
<p>Compiling the code and running <code>objdump</code> again, the disassembly looks more as
we might expect. Let&#39;s start with <code>main()</code> - I&#39;ve broken up the disassembly
into pieces and added commentary.</p>
<p>The main func begins with base pointer and stack pointer initialisation:</p>
<pre><code><span>0000000000497660 &lt;main.main&gt;:
</span><span>    mov    %fs:0xfffffffffffffff8,%rcx
</span><span>    
</span><span>    cmp    0x10(%rcx),%rsp
</span><span>    jbe    497705 &lt;main.main+0xa5&gt;
</span><span>    sub    $0x58,%rsp
</span><span>    mov    %rbp,0x50(%rsp)
</span><span>    lea    0x50(%rsp),%rbp
</span></code></pre>
<p>followed by,</p>
<pre><code><span>    movq   $0x16,(%rsp)
</span><span>    movq   $0x21,0x8(%rsp)
</span></code></pre>
<p>Here we see the arguments to <code>add</code> being pushed onto the stack in preparation
for the function call. 0x16 (22) is moved to where the stack pointer is
pointing. 0x21 (33) is copied to 8 bytes after where the stack pointer is
pointing (so earlier in the stack). The offset of 8 is important because we&#39;re
dealing with 64-bit (8 byte) integers. An 8 byte offset means the 33 is placed
on the stack directly after the 22. </p>
<pre><code><span>    call   4976e0 &lt;main.add&gt;
</span><span>    mov    0x10(%rsp),%rax
</span><span>    mov    %rax,0x30(%rsp)
</span></code></pre>
<p>Here&#39;s where the add function actually gets called. When the <code>call</code> instruction
is executed by the CPU, the current value of the instruction pointer is pushed
to the stack and execution jumps to the <code>add</code> function. Once <code>add</code> returns,
execution continues here where <code>z</code> (stack pointer + 0x30 as it turns out) is
assigned to the returned value (stack pointer + 0x10). The AX register is used
as temporary storage when moving the return value.</p>
<p>There&#39;s more code that follows in main to handle the call the fmt.Println but
that&#39;s outside the scope of this article.</p>
<p>One thing I found interesting looking at this code is that the classic <code>push</code>
instructions aren&#39;t being used to add values onto the stack. Values are placed
onto the stack using <code>mov</code>. It turns out that this is for performance reasons.
A <code>mov</code> <a href="https://agner.org/optimize/instruction_tables.pdf">generally requires fewer CPU cycles</a> than a <code>push</code>.</p>
<p>We should also have a look at <code>add</code>:</p>
<pre><code><span>0000000000497640 &lt;main.add&gt;:
</span><span>    mov    0x10(%rsp),%rax
</span><span>    mov    0x8(%rsp),%rcx
</span><span>    add    %rcx,%rax
</span><span>    mov    %rax,0x18(%rsp)
</span><span>    ret    
</span></code></pre>
<p>The second argument (at SP + 0x10) is copied to the AX register, and the first
argument (at SP + 0x08) is copied to the CX register. But hang on, weren&#39;t the
arguments at SP and SP+0x10? They were but when the <code>call</code> instruction was
executed, the instruction pointer was pushed to the stack which means the stack
pointer had to be decremented to make room for it - this means the offsets to
the arguments have to be adjusted to account for this.</p>
<p>The <code>add</code> instruction is easy enough to understand. Here CX and AX are added
(with the result left in AX). The result is then pushed to the return location
(SP + 0x18).</p>
<p>The <code>ret</code> (return) instruction grabs the return address off the stack and
starts execution just after the <code>call</code> in <code>main</code>.</p>
<p>Phew! That&#39;s a lot of code for a simple program. Although it&#39;s useful to
understand what&#39;s going on, be thankful that we don&#39;t have to write assembly
language very often these days!</p>
<h3 id="examining-go-1-17-s-output">Examining Go 1.17&#39;s Output</h3>
<p>Now let&#39;s take a look at the same program compiled with Go 1.17. The
compilation and disassembly steps are similar to Go 1.16:</p>
<pre><code><span>$ go build -o prog-117 ./main.go
</span><span>$ objdump -d prog-117 &gt; prog-117.asm
</span></code></pre>
<p>The main disassembly starts the same as under Go 1.16 but - as expected - 
differs in the call to <code>add</code>:</p>
<pre><code><span>    mov    $0x16,%eax
</span><span>    mov    $0x21,%ebx
</span><span>    xchg   %ax,%ax
</span><span>    call   47e260 &lt;main.add&gt;
</span></code></pre>
<p>Instead of copying the function arguments onto the stack, they&#39;re copied into
the AX and BX registers. This is the essence of register based calling. </p>
<p>The <code>xchg %ax,%ax</code> instruction is a bit more mysterious and I only have
theories regarding what it&#39;s for. Email me if you know and I&#39;ll add the detail
here.</p>
<p>As we&#39;ve already seen earlier, the <code>call</code> instruction moves execution to the
<code>add</code> function.</p>
<p>Now let&#39;s take a look at <code>add</code>:</p>
<pre><code><span>000000000047e260 &lt;main.add&gt;:
</span><span>    add    %rbx,%rax
</span><span>    ret    
</span></code></pre>
<p>Well that&#39;s simple! Unlike the Go 1.16 version, there&#39;s no need to move
arguments from the stack into registers in order to add them, and there&#39;s no
need to move the result back to the stack. The function arguments are expected to
be in the AX and BX registers, and the return value is expected to come back
via AX. The <code>ret</code> instruction moves execution back to where <code>call</code> was executed,
using the return address that <code>call</code> left on the stack.</p>
<p>With so much less work being done when handling function arguments and return
values, it&#39;s starting to become clearer why register based calling might be
faster.</p>
<h3 id="performance-comparison">Performance Comparison</h3>
<p>So how much faster is register based calling? I created a simple Go benchmark program to check:</p>
<pre data-lang="go"><code data-lang="go"><span>package </span><span>main
</span><span>
</span><span>import </span><span>&#34;</span><span>testing</span><span>&#34;
</span><span>
</span><span>//go:noinline
</span><span>func </span><span>add</span><span>(</span><span>i</span><span>, </span><span>j </span><span>int</span><span>) </span><span>int </span><span>{
</span><span>	</span><span>return </span><span>i </span><span>+ </span><span>j
</span><span>}
</span><span>
</span><span>var </span><span>result </span><span>int
</span><span>
</span><span>func </span><span>BenchmarkIt</span><span>(</span><span>b </span><span>*</span><span>testing</span><span>.</span><span>B</span><span>) {
</span><span>	</span><span>x </span><span>:= </span><span>22
</span><span>	</span><span>y </span><span>:= </span><span>33
</span><span>	</span><span>var </span><span>z </span><span>int
</span><span>	</span><span>for </span><span>i </span><span>:= </span><span>0</span><span>; </span><span>i </span><span>&lt; </span><span>b</span><span>.</span><span>N</span><span>; </span><span>i</span><span>++ {
</span><span>		</span><span>z </span><span>= </span><span>add</span><span>(</span><span>x</span><span>, </span><span>y</span><span>)
</span><span>	}
</span><span>	</span><span>result </span><span>= </span><span>z
</span><span>}
</span></code></pre>
<p>Note the use of a variable outside of the benchmark function to ensure that the
<a href="https://dave.cheney.net/2013/06/30/how-to-write-benchmarks-in-go">compiler won&#39;t optimise</a> 
the assignment to <code>z</code> away.</p>
<p>The benchmark can be run like this:</p>
<pre><code><span>go test bench_test.go -bench=.
</span></code></pre>
<p>On my somewhat long in the tooth laptop, the best result I could get under Go 1.16 was:</p>
<pre><code><span>BenchmarkIt-4   	512385438	         2.292 ns/op
</span></code></pre>
<p>With Go 1.17:</p>
<pre><code><span>BenchmarkIt-4   	613585278	         1.915 ns/op
</span></code></pre>
<p>That&#39;s a noticeable improvement - a 16% reduction in execution time for our
example. Not bad, especially as the improvement comes for free for all Go
programs just by using a newer version of the compiler.</p>
<h3 id="conclusion">Conclusion</h3>
<p>I hope you found it interesting to explore some lower level details of software
that we don&#39;t think about much these days and that you learned something along
the way. </p>
<p>Many thanks to <a href="https://benhoyt.com/writings/">Ben Hoyt</a> and <a href="https://hardbyte.nz/">Brian
Thorne</a> for their detailed reviews and input into this
article.</p>

</article></div>
  </body>
</html>
