<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://tkuriyama.github.io/accessibility/2025/02/23/say-scripting_with_llms.html">Original</a>
    <h1>Say Scripting with LLMs</h1>
    
    <div id="readability-page-1" class="page"><div aria-label="Content">
      <div>
        <article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    <p>How does one get the terminal to speak output?</p>

<p>There are various ways to achieve the goal with accessibility tools (e.g. screen readers like VoiceOver on macOS, or libraries like <a href="https://github.com/tvraman/emacspeak">emacspeak</a>). But suppose we want something simple…</p>

<h2 id="say">Say</h2>

<p>On macOS, the built-in text-to-speech (TTS) utility is <code>say</code>:</p>

<p><code>say hello</code></p>

<p>… says hello. There are a few simple flags to control the speech rate, voice, etc.</p>

<p>To print command results to the terminal while also calling <code>say</code>, we can use <code>tee</code> to duplicate the input:</p>

<p><code>date | tee /dev/tty | say</code></p>

<p>An alias like <code>alias dates=&#39;date | tee /dev/tty | say&#39;</code> can be convenient, but it doesn’t take additional arguments to the original command. Alternatively, we can define multiple aliases as functions (e.g. as a script to call from <code>~/.zshrc</code>).</p>

<div><div><pre><code><span>#!/bin/zsh</span>

<span>typeset </span><span>SPEECH_RATE</span><span>=</span>300
<span>typeset</span> <span>-A</span> saycommands
<span>saycommands</span><span>=(</span>
    lss <span>&#34;ls -1&#34;</span>
    pwds <span>&#34;pwd&#34;</span>
    dates <span>&#34;date&#34;</span>
<span>)</span>

<span>for </span>key <span>in</span> <span>${</span><span>(k)saycommands</span><span>}</span><span>;</span> <span>do
    </span><span>command</span><span>=</span><span>&#34;</span><span>${</span><span>saycommands</span><span>[</span><span>$key</span><span>]</span><span>}</span><span>&#34;</span>
    <span>eval</span> <span>&#34;
        function </span><span>${</span><span>key</span><span>}</span><span> {
            </span><span>${</span><span>command</span><span>}</span><span> </span><span>\&#34;\$</span><span>@</span><span>\&#34;</span><span> | tee /dev/tty | say -r </span><span>\$</span><span>{SPEECH_RATE}
        }
    &#34;</span>
<span>done

</span><span>echo</span> <span>&#34;Say-enabled commands: </span><span>${</span><span>(k)saycommands</span><span>}</span><span>&#34;</span>
</code></pre></div></div>

<h2 id="say-mode-asking-an-llm">Say Mode? Asking an LLM</h2>

<p>For a more general solution, maybe we want the terminal to always speak output. And for non-experts in zshell, maybe we want help from an LLM.</p>

<p>The LLMs tried are: (1) ChatGPT 4o in the macOS desktop app: (2) Mistral’s default model in the web UI. In both cases, the initial prompt is simple: “In MacOS ZSH, I want to intercept every shell output and also speak it aloud with <code>say -r 300</code>”.</p>

<p>Interestingly, ChatGPT didn’t generate working code even after a few iterations, while Mistral quickly got something working, albeit a bit buggy. This is Mistral’s initial working version, which speaks the output once but prints it three times: <a href="https://gist.github.com/tkuriyama/ef28d12e496b8670d5bee74f787f4f9a">link to gist</a>.</p>

<p>I didn’t spend too much time engineering the prompts, but toggling back and forth between ChatGPT and Mistral, I found that:</p>
<ul>
  <li>neither model could fully and independently resolve the triple-printing issue</li>
  <li>both models are better at debugging than generating code</li>
  <li>the differential diagnosis between models (i.e. comparing their outputs) is useful</li>
</ul>

<p>Overall, the results were roughly on par with expectations. For a modest task, the LLMs can do a good draft, allowing the human programmer to focus on refining the results. (Also, the time-savings were meaningful in this instance, since I know very little about shell/zshell scripting). And although by no means a rigorous comparison, I preferred the speed and quality of Mistral.</p>

<p>This is the final, working version, which allows say mode to be toggled in the terminal with <code>saymode on</code> and <code>saymode off</code> and includes a prompt indicator. It’s not particularly elegant and lacks some obvious usability features, but it works as a proof of concept.</p>

<div><div><pre><code><span>#!/bin/zsh</span>

<span>typeset</span> <span>-g</span> <span>SAYMODE_ENABLED</span><span>=</span><span>false
typeset</span> <span>-g</span> <span>LAST_COMMAND_OUTPUT</span><span>=</span><span>&#34;&#34;</span>
<span>typeset</span> <span>-g</span> <span>DEFAULT_PROMPT</span><span>=</span><span>&#34;</span><span>$PROMPT</span><span>&#34;</span>

<span>################################################################################</span>


<span>function </span>speak_last_output<span>()</span> <span>{</span>
    <span>if</span> <span>[[</span> <span>$SAYMODE_ENABLED</span> <span>==</span> <span>true</span> <span>&amp;&amp;</span> <span>-n</span> <span>&#34;</span><span>$LAST_COMMAND_OUTPUT</span><span>&#34;</span> <span>]]</span><span>;</span> <span>then
        </span><span>echo</span> <span>&#34;</span><span>$LAST_COMMAND_OUTPUT</span><span>    &#34;</span> | say <span>-r</span> 300
        <span>LAST_COMMAND_OUTPUT</span><span>=</span><span>&#34;&#34;</span>
    <span>fi</span>
<span>}</span>

<span>function </span>capture_output<span>()</span> <span>{</span>
    <span>LAST_COMMAND_OUTPUT</span><span>=</span><span>$(</span><span>eval</span> <span>&#34;</span><span>$1</span><span>&#34;</span> 2&gt;&amp;1<span>)</span>
    <span>return</span> <span>${</span><span>PIPESTATUS</span><span>[0]</span><span>}</span>
<span>}</span>

<span>################################################################################</span>

<span>function </span>preexec<span>()</span> <span>{</span>
    <span># Check if the command is not empty</span>
    <span>if</span> <span>[[</span> <span>-n</span> <span>&#34;</span><span>$1</span><span>&#34;</span> <span>&amp;&amp;</span> <span>$SAYMODE_ENABLED</span> <span>==</span> <span>true</span> <span>]]</span><span>;</span> <span>then
        </span>capture_output <span>&#34;</span><span>$1</span><span>&#34;</span>
        <span># Prevent the original command from being executed</span>
        <span>return </span>1
    <span>fi</span>
<span>}</span>

preexec_functions+<span>=(</span>preexec<span>)</span>
precmd_functions+<span>=(</span>speak_last_output<span>)</span>

<span>################################################################################</span>

<span>function </span>saymode_on<span>()</span> <span>{</span>
    <span>SAYMODE_ENABLED</span><span>=</span><span>true
    </span><span>PROMPT</span><span>=</span><span>&#34;%K{green}SAYMODE%k </span><span>$DEFAULT_PROMPT</span><span>&#34;</span>
    <span>echo</span> <span>&#34;Say mode enabled.&#34;</span>
<span>}</span>

<span># Define the vmode off command</span>
<span>function </span>saymode_off<span>()</span> <span>{</span>
    <span>PROMPT</span><span>=</span><span>&#34;</span><span>$DEFAULT_PROMPT</span><span>&#34;</span>
    <span>echo</span> <span>&#34;Say mode disabled.&#34;</span>
    <span>SAYMODE_ENABLED</span><span>=</span><span>false</span>
<span>}</span>

<span>function </span>saymode<span>()</span> <span>{</span>
    <span>if</span> <span>[[</span> <span>&#34;</span><span>$1</span><span>&#34;</span> <span>==</span> <span>&#34;on&#34;</span> <span>]]</span><span>;</span> <span>then
        </span>saymode_on
    <span>elif</span> <span>[[</span> <span>&#34;</span><span>$1</span><span>&#34;</span> <span>==</span> <span>&#34;off&#34;</span> <span>]]</span><span>;</span> <span>then
        </span>saymode_off
    <span>else
        </span><span>echo</span> <span>&#34;Usage: vmode {on|off}&#34;</span>
    <span>fi</span>
<span>}</span>
</code></pre></div></div>

<h2 id="can-you-do-better">Can You Do Better?</h2>

<p>Some usability improvements that come to mind:</p>

<ul>
  <li>output can be automatically Limited in length</li>
  <li>commands can be whitelisted or blacklisted, since e.g. “vi” or “men” that start a new program or terminal paging mode are not compatible</li>
</ul>

<p>What does a different model like Grok 3 think?</p>

<p><code>I want you to comment on this Zsh Voice mode program. What are some good usability or feature enhancements to consider?</code></p>

<p>Given a simple prompt like the above, Grok 3 yields an impressive answer.</p>

<ul>
  <li>It identifies and solves both the above points without any specific prompting</li>
  <li>It provides several more suggestions and implements them with lucid explanations</li>
  <li>It identifies several nuances and gotchas, providing clear explanations</li>
</ul>

<p>Overall, it generates a more complex and feature-rich program (<a href="https://gist.github.com/tkuriyama/bac9fb086bb5d56be7f736641af70a1d">copy-paste of the interactive session</a>). The revised script runs immediately without any modifications!</p>

<p>There are some oddities in the shell experience introduced by the more advanced functionality, which Grok 3 couldn’t fully debug. so in the end I reverted to the original, simpler script and asked it to implement only a subset of improvements.</p>

<p>Here is the revised, working script, verbatim from Grok 3 (except for the whitelist of commands).</p>

<div><div><pre><code><span># Global Variables</span>
<span>typeset</span> <span>-g</span> <span>SAYMODE_ENABLED</span><span>=</span><span>false</span>              <span># Tracks whether Say Mode is enabled</span>
<span>typeset</span> <span>-g</span> <span>LAST_COMMAND_OUTPUT</span><span>=</span><span>&#34;&#34;</span>             <span># Stores the last command&#39;s output</span>
<span>typeset</span> <span>-g</span> <span>DEFAULT_PROMPT</span><span>=</span><span>&#34;</span><span>$PROMPT</span><span>&#34;</span>           <span># Stores the default prompt for restoration</span>
<span>typeset</span> <span>-gi</span> <span>SAYMODE_OUTPUT_LIMIT</span><span>=</span><span>${</span><span>SAYMODE_OUTPUT_LIMIT</span><span>:-</span><span>500</span><span>}</span>  <span># Output limit in characters, default 100</span>
<span>typeset</span> <span>-g</span> <span>-A</span> <span>SAYMODE_COMMANDS</span><span>=(</span>
    <span>ls </span>1 <span>pwd </span>1 <span>echo </span>1 <span>date </span>1
    <span>whoami </span>1 <span>hostname </span>1 <span>uname </span>1 which 1 where 1
    <span>type </span>1 <span>env </span>1 <span>printenv </span>1 <span>alias </span>1
    <span>du </span>1 <span>df </span>1 ll 1 la 1 lh 1 
<span>)</span>  <span># Whitelist of safe commands</span>

<span># Function to speak the last command output</span>
<span>function </span>speak_last_output<span>()</span> <span>{</span>
    <span>if</span> <span>[[</span> <span>$SAYMODE_ENABLED</span> <span>==</span> <span>true</span> <span>&amp;&amp;</span> <span>-n</span> <span>&#34;</span><span>$LAST_COMMAND_OUTPUT</span><span>&#34;</span> <span>]]</span><span>;</span> <span>then
        </span><span>local </span>output_to_speak
        <span>if</span> <span>[[</span> <span>$SAYMODE_OUTPUT_LIMIT</span> <span>-gt</span> 0 <span>]]</span><span>;</span> <span>then
            </span><span>output_to_speak</span><span>=</span><span>&#34;</span><span>${</span><span>LAST_COMMAND_OUTPUT</span>:0:<span>$SAYMODE_OUTPUT_LIMIT</span><span>}</span><span>&#34;</span>
        <span>else
            </span><span>output_to_speak</span><span>=</span><span>&#34;</span><span>$LAST_COMMAND_OUTPUT</span><span>&#34;</span>
        <span>fi
        </span><span>echo</span> <span>&#34;</span><span>$output_to_speak</span><span>    &#34;</span> | say <span>-r</span> 300  <span># Preserve original rate of 300 wpm</span>
        <span>LAST_COMMAND_OUTPUT</span><span>=</span><span>&#34;&#34;</span>
    <span>fi</span>
<span>}</span>

<span># Function to capture command output</span>
<span>function </span>capture_output<span>()</span> <span>{</span>
    <span>LAST_COMMAND_OUTPUT</span><span>=</span><span>$(</span><span>eval</span> <span>&#34;</span><span>$1</span><span>&#34;</span> 2&gt;&amp;1<span>)</span>  <span># Capture stdout and stderr</span>
    <span>return</span> <span>${</span><span>PIPESTATUS</span><span>[0]</span><span>}</span>  <span># Return the exit status of the command</span>
<span>}</span>

<span># Pre-execution hook to process whitelisted commands</span>
<span>function </span>preexec<span>()</span> <span>{</span>
    <span>if</span> <span>[[</span> <span>$SAYMODE_ENABLED</span> <span>==</span> <span>true</span> <span>&amp;&amp;</span> <span>-n</span> <span>&#34;</span><span>$1</span><span>&#34;</span> <span>]]</span><span>;</span> <span>then
        </span><span>local </span><span>cmd_name</span><span>=</span><span>${</span><span>1</span><span>%%[[</span>:space:]]<span>*</span><span>}</span>  <span># Extract the first word of the command</span>
        <span>if</span> <span>[[</span> <span>-n</span> <span>&#34;</span><span>${</span><span>SAYMODE_COMMANDS</span><span>[</span><span>$cmd_name</span><span>]</span><span>}</span><span>&#34;</span> <span>]]</span><span>;</span> <span>then</span>  <span># Check if command is in whitelist</span>
            capture_output <span>&#34;</span><span>$1</span><span>&#34;</span>
            <span>return </span>1  <span># Prevent original command execution</span>
        <span>fi
    fi</span>
<span>}</span>

<span># Set up Zsh hooks</span>
preexec_functions+<span>=(</span>preexec<span>)</span>      <span># Run preexec before each command</span>
precmd_functions+<span>=(</span>speak_last_output<span>)</span>  <span># Run speak_last_output after each command</span>

<span># Function to enable Say Mode</span>
<span>function </span>saymode_on<span>()</span> <span>{</span>
    <span>SAYMODE_ENABLED</span><span>=</span><span>true
    </span><span>PROMPT</span><span>=</span><span>&#34;%K{green}SAYMODE%k </span><span>$DEFAULT_PROMPT</span><span>&#34;</span>  <span># Update prompt to indicate Say Mode</span>
    <span>echo</span> <span>&#34;Say mode enabled.&#34;</span>
<span>}</span>

<span># Function to disable Say Mode</span>
<span>function </span>saymode_off<span>()</span> <span>{</span>
    <span>PROMPT</span><span>=</span><span>&#34;</span><span>$DEFAULT_PROMPT</span><span>&#34;</span>  <span># Restore original prompt</span>
    <span>SAYMODE_ENABLED</span><span>=</span><span>false
    echo</span> <span>&#34;Say mode disabled.&#34;</span>
<span>}</span>

<span># Main Say Mode control function with toggle</span>
<span>function </span>saymode<span>()</span> <span>{</span>
    <span>if</span> <span>[[</span> <span>&#34;</span><span>$1</span><span>&#34;</span> <span>==</span> <span>&#34;on&#34;</span> <span>]]</span><span>;</span> <span>then
        </span>saymode_on
    <span>elif</span> <span>[[</span> <span>&#34;</span><span>$1</span><span>&#34;</span> <span>==</span> <span>&#34;off&#34;</span> <span>]]</span><span>;</span> <span>then
        </span>saymode_off
    <span>elif</span> <span>[[</span> <span>-z</span> <span>&#34;</span><span>$1</span><span>&#34;</span> <span>]]</span><span>;</span> <span>then</span>  <span># Toggle if no argument is provided</span>
        <span>if</span> <span>[[</span> <span>$SAYMODE_ENABLED</span> <span>==</span> <span>true</span> <span>]]</span><span>;</span> <span>then
            </span>saymode_off
        <span>else
            </span>saymode_on
        <span>fi
    else
        </span><span>echo</span> <span>&#34;Usage: saymode {on|off}&#34;</span>  <span># Updated usage message</span>
    <span>fi</span>
<span>}</span>


</code></pre></div></div>

  </div>
</article>

      </div>
    </div></div>
  </body>
</html>
