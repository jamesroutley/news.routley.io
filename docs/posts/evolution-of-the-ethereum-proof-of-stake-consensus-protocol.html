<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/ethereum/pos-evolution/blob/master/pos-evolution.md">Original</a>
    <h1>Evolution of the Ethereum proof-of-stake consensus protocol</h1>
    
    <div id="readability-page-1" class="page"><div>

    <div data-target="readme-toc.content">
      
  


        <div id="readme">
    <article itemprop="text">
<p dir="auto"><a href="https://twitter.com/luca_zanolini" rel="nofollow">Luca Zanolini</a></p>
<p dir="auto">In this document we present the evolution of the proof-of-stake consensus protocol of Ethereum, called <strong>Gasper</strong>, aiming at a self-contained reference for future study and research.</p>
<details><summary>Implementation</summary>
<div data-snippet-clipboard-copy-content="We include in boxes of this kind the (explained) implementation of the most relevant theoretical parts. Observe that the code showed for the implementation follows the [consensus pyspec](https://github.com/ethereum/consensus-specs), and is presented using Simple Serialize (SSZ), a serialization and merkleization standard created specifically for Ethereum consensus. This specification serves as a reference for consensus layer devs and is also used for creating the test case vectors for client teams. A tutorial on how to run the Ethereum consensus pyspec can be found [here](https://archive.devcon.org/archive/watch/6/how-to-use-executable-consensus-pyspec/?tab=YouTube), and an updated annotated specification can be found [here](https://eth2book.info/bellatrix/part3/)."><pre><code>We include in boxes of this kind the (explained) implementation of the most relevant theoretical parts. Observe that the code showed for the implementation follows the [consensus pyspec](https://github.com/ethereum/consensus-specs), and is presented using Simple Serialize (SSZ), a serialization and merkleization standard created specifically for Ethereum consensus. This specification serves as a reference for consensus layer devs and is also used for creating the test case vectors for client teams. A tutorial on how to run the Ethereum consensus pyspec can be found [here](https://archive.devcon.org/archive/watch/6/how-to-use-executable-consensus-pyspec/?tab=YouTube), and an updated annotated specification can be found [here](https://eth2book.info/bellatrix/part3/).
</code></pre></div>
   </details>
<h4 dir="auto"><a id="user-content-disclaimer" aria-hidden="true" href="#disclaimer"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Disclaimer</h4>
<p dir="auto">Since this document aims at grouping together all the most relevant resources concerning the proof-of-stake consensus protocol of Ethereum, some parts are just imported as they are in the original source. If this is the case, the text will be in <em>italic type</em> and the original reference is given.</p>
<h4 dir="auto"><a id="user-content-acknowledgments" aria-hidden="true" href="#acknowledgments"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Acknowledgments</h4>
<p dir="auto">Special thanks to Aditya Asgaonkar, Francesco D&#39;Amato, Tyler Holmes, and [...] for feedback and helpful discussions.</p>
<p dir="auto">The proof-of-stake consensus protocol of Ethereum, Gasper, evolved during the years. This is because attacks were found that undermined its properties and functioning. As a response to that, solutions were developed to cope with the problems.</p>
<p dir="auto">In order to better understand the current implemented protocol, we start by presenting the <a href="https://arxiv.org/pdf/2003.03052.pdf" rel="nofollow">original version of it</a>, by Buterin <em>et al.</em>, highlighting its underlying components and properties. Then, we present the most relevant attacks and/or problems that have been discovered so far, and discuss solutions to them.</p>
<p dir="auto">First, let us introduce the system model that will be used from now on.</p>
<h3 dir="auto"><a id="user-content-system-model" aria-hidden="true" href="#system-model"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>System Model</h3>
<h4 dir="auto"><a id="user-content-validators" aria-hidden="true" href="#validators"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Validators</h4>
<p dir="auto">We consider a system of <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$n$</math-renderer> <em>validators</em> <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$\mathcal{V} = {v_1, \dots, v_n}$</math-renderer> that communicate with each other through exchanging messages. Every validator is identified by a unique cryptographic identity and the public keys are common knowledge.</p>
<details><summary>Validator</summary>
<div data-snippet-clipboard-copy-content="class Validator(Container):
    pubkey: BLSPubkey
    withdrawal_credentials: Bytes32  # Commitment to pubkey for withdrawals
    effective_balance: Gwei  # Balance at stake
    slashed: boolean
    # Status epochs
    activation_eligibility_epoch: Epoch  # When criteria for activation were met
    activation_epoch: Epoch
    exit_epoch: Epoch
    withdrawable_epoch: Epoch  # When validator can withdraw funds"><pre lang="python"><code>class Validator(Container):
    pubkey: BLSPubkey
    withdrawal_credentials: Bytes32  # Commitment to pubkey for withdrawals
    effective_balance: Gwei  # Balance at stake
    slashed: boolean
    # Status epochs
    activation_eligibility_epoch: Epoch  # When criteria for activation were met
    activation_epoch: Epoch
    exit_epoch: Epoch
    withdrawable_epoch: Epoch  # When validator can withdraw funds
</code></pre></div>
<p dir="auto">This object contains all the information relating to a particular validator <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$v_i \in \mathcal{V}$</math-renderer>. In particular:</p>
<p dir="auto"><code>pubkey</code>: public key for signing;</p>
<p dir="auto"><code>withdrawal_credentials</code>: a hash of the pubkey that will be used to withdraw;</p>
<p dir="auto"><code>effective_balance</code>: the balance of the validator that is used for all calculations;</p>
<p dir="auto"><code>slashed</code>: it says if the validator has been <em>slashed</em> (this term will be introduced few sections below);</p>
<p dir="auto"><code>activation_eligibility_epoch</code>: when the validator became eligible for activation, i.e., when it became eligible to become an active validator;</p>
<p dir="auto"><code>activation_epoch</code>: when the validator was activated;</p>
<p dir="auto"><code>exit_epoch</code>: when the validator exited from <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$\mathcal{V}$</math-renderer>, voluntarily or not;</p>
<p dir="auto"><code>withdrawable_epoch</code>: when the validator became eligible to withdraw their balance;</p>
<p dir="auto">The precise epochs are kept around in order to calculate the current active validator set and the historical active validator set.</p>
<p dir="auto">Observe that validators have two private/public key pairs: <code>pubkey</code>, used for signing protocol messages, and a separate <em>withdrawal key</em>. <code>withdrawal_credentials</code> is  obtained from the validator&#39;s withdrawal key and it allows a validator to prove it owns the funds enabling it to withdraw them.</p>
   </details>
<p dir="auto">Validators are assigned a protocol to follow.
A protocol for <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$\mathcal{V}$</math-renderer> consists of a collection of programs with instructions for all validators.</p>
<p dir="auto">Each validator has a deposit; when a validator joins <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$\mathcal{V}$</math-renderer>, its deposit is the number of deposited coins, e.g., ETH. After joining, each validator’s balance rises and falls with rewards and penalties.</p>
<details><summary>Deposit</summary>
<div data-snippet-clipboard-copy-content="class DepositMessage(Container):
    pubkey: BLSPubkey
    withdrawal_credentials: Bytes32
    amount: Gwei"><pre lang="python"><code>class DepositMessage(Container):
    pubkey: BLSPubkey
    withdrawal_credentials: Bytes32
    amount: Gwei
</code></pre></div>
<div data-snippet-clipboard-copy-content="class DepositData(Container):
    pubkey: BLSPubkey
    withdrawal_credentials: Bytes32
    amount: Gwei
    signature: BLSSignature  # Signing over DepositMessage"><pre lang="python"><code>class DepositData(Container):
    pubkey: BLSPubkey
    withdrawal_credentials: Bytes32
    amount: Gwei
    signature: BLSSignature  # Signing over DepositMessage
</code></pre></div>
<p dir="auto">Observe that, as a rule, there can only be one validator <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$v_i$</math-renderer> for each <code>pubkey</code>; if <code>pubkey</code> is already present in the list of validators, then <code>amount</code> is added to <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$v_i$</math-renderer>&#39;s balance. Otherwise, a new entry <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$v_i$</math-renderer> is appended to the list and credited with amount.</p>
<p dir="auto">Requiring the <code>withdrawal_credentials</code> and the <code>amount</code> to be signed by the public key prevents some vectors of attack. This is why we have <code>DepositData(Container)</code>, i.e., a signed <code>DepositMessage(Container)</code>.</p>
<p dir="auto">A proof that a validator deposited is given by the following object.</p>
<div data-snippet-clipboard-copy-content="class Deposit(Container):
    proof: Vector[Bytes32, DEPOSIT_CONTRACT_TREE_DEPTH + 1]  # Merkle path to deposit root
    data: DepositData"><pre lang="python"><code>class Deposit(Container):
    proof: Vector[Bytes32, DEPOSIT_CONTRACT_TREE_DEPTH + 1]  # Merkle path to deposit root
    data: DepositData
</code></pre></div>
<p dir="auto">Every validator has an <code>effective_balance</code> (of at most 32 ETH), and its voting power is weighted by it. Any balance above this is ignored.</p>
<p dir="auto">However, validator balances are stored, for efficiency reasons, in <em>two</em> places: (i) in the <code>effective_balance</code> in the <code>Validator</code> record and (ii) in the (exact) <code>balances</code> in a separate record (in <code>BeaconState</code>, see few sections below).</p>
<p dir="auto"><em>The exact balances change every epoch (due to rewards and penalties), so we store them in a compact array that requires rehashing only &lt;32 MB to update, while the effective balances (which are used for all other computations that require validator balances) are updated using a hysteresis formula: if the effective balance is $n$ ETH, and if the exact balance goes below $n-0.25$ ETH, then the effective balance is set to $n-1$ ETH, and if the exact balance goes above $n+1.25$ ETH the effective balance is set to $n+1$ ETH.</em></p>
<p dir="auto"><em>Since the exact balance must change by at least a full $0.5$ ETH to trigger an effective balance update, this ensures an attacker can&#39;t make effective balances update every epoch -- and thus cause processing the chain to become very slow -- by repeatedly nudging the exact balances above, and then below, some threshold.</em> [<a href="https://github.com/ethereum/annotated-spec/blob/master/phase0/beacon-chain.md">https://github.com/ethereum/annotated-spec/blob/master/phase0/beacon-chain.md</a>]</p>
<p dir="auto">This effective balances are update according to the following function.</p>
<div data-snippet-clipboard-copy-content="def process_effective_balance_updates(state: BeaconState) -&gt; None:
    # Update effective balances with hysteresis
    for index, validator in enumerate(state.validators):
        balance = state.balances[index]
        HYSTERESIS_INCREMENT = uint64(EFFECTIVE_BALANCE_INCREMENT // HYSTERESIS_QUOTIENT)
        DOWNWARD_THRESHOLD = HYSTERESIS_INCREMENT * HYSTERESIS_DOWNWARD_MULTIPLIER
        UPWARD_THRESHOLD = HYSTERESIS_INCREMENT * HYSTERESIS_UPWARD_MULTIPLIER
        if (
            balance + DOWNWARD_THRESHOLD &lt; validator.effective_balance
            or validator.effective_balance + UPWARD_THRESHOLD &lt; balance
        ):
            validator.effective_balance = min(balance - balance % EFFECTIVE_BALANCE_INCREMENT, MAX_EFFECTIVE_BALANCE)"><pre lang="python"><code>def process_effective_balance_updates(state: BeaconState) -&gt; None:
    # Update effective balances with hysteresis
    for index, validator in enumerate(state.validators):
        balance = state.balances[index]
        HYSTERESIS_INCREMENT = uint64(EFFECTIVE_BALANCE_INCREMENT // HYSTERESIS_QUOTIENT)
        DOWNWARD_THRESHOLD = HYSTERESIS_INCREMENT * HYSTERESIS_DOWNWARD_MULTIPLIER
        UPWARD_THRESHOLD = HYSTERESIS_INCREMENT * HYSTERESIS_UPWARD_MULTIPLIER
        if (
            balance + DOWNWARD_THRESHOLD &lt; validator.effective_balance
            or validator.effective_balance + UPWARD_THRESHOLD &lt; balance
        ):
            validator.effective_balance = min(balance - balance % EFFECTIVE_BALANCE_INCREMENT, MAX_EFFECTIVE_BALANCE)
</code></pre></div>
<p dir="auto">Finally, deposits are processed through the following function.</p>
<div data-snippet-clipboard-copy-content="def process_deposit(state: BeaconState, deposit: Deposit) -&gt; None:
    # Verify the Merkle branch
    assert is_valid_merkle_branch(
        leaf=hash_tree_root(deposit.data),
        branch=deposit.proof,
        depth=DEPOSIT_CONTRACT_TREE_DEPTH + 1,  # Add 1 for the List length mix-in
        index=state.eth1_deposit_index,
        root=state.eth1_data.deposit_root,
    )

    # Deposits must be processed in order
    state.eth1_deposit_index += 1

    pubkey = deposit.data.pubkey
    amount = deposit.data.amount
    validator_pubkeys = [validator.pubkey for validator in state.validators]
    if pubkey not in validator_pubkeys:
        # Verify the deposit signature (proof of possession) which is not checked by the deposit contract
        deposit_message = DepositMessage(
            pubkey=deposit.data.pubkey,
            withdrawal_credentials=deposit.data.withdrawal_credentials,
            amount=deposit.data.amount,
        )
        domain = compute_domain(DOMAIN_DEPOSIT)  # Fork-agnostic domain since deposits are valid across forks
        signing_root = compute_signing_root(deposit_message, domain)
        # Initialize validator if the deposit signature is valid
        if bls.Verify(pubkey, signing_root, deposit.data.signature):
            state.validators.append(get_validator_from_deposit(state, deposit))
            state.balances.append(amount)
            state.previous_epoch_participation.append(ParticipationFlags(0b0000_0000))
            state.current_epoch_participation.append(ParticipationFlags(0b0000_0000))
            state.inactivity_scores.append(uint64(0))
    else:
        # Increase balance by deposit amount
        index = ValidatorIndex(validator_pubkeys.index(pubkey))
        increase_balance(state, index, amount)"><pre lang="python"><code>def process_deposit(state: BeaconState, deposit: Deposit) -&gt; None:
    # Verify the Merkle branch
    assert is_valid_merkle_branch(
        leaf=hash_tree_root(deposit.data),
        branch=deposit.proof,
        depth=DEPOSIT_CONTRACT_TREE_DEPTH + 1,  # Add 1 for the List length mix-in
        index=state.eth1_deposit_index,
        root=state.eth1_data.deposit_root,
    )

    # Deposits must be processed in order
    state.eth1_deposit_index += 1

    pubkey = deposit.data.pubkey
    amount = deposit.data.amount
    validator_pubkeys = [validator.pubkey for validator in state.validators]
    if pubkey not in validator_pubkeys:
        # Verify the deposit signature (proof of possession) which is not checked by the deposit contract
        deposit_message = DepositMessage(
            pubkey=deposit.data.pubkey,
            withdrawal_credentials=deposit.data.withdrawal_credentials,
            amount=deposit.data.amount,
        )
        domain = compute_domain(DOMAIN_DEPOSIT)  # Fork-agnostic domain since deposits are valid across forks
        signing_root = compute_signing_root(deposit_message, domain)
        # Initialize validator if the deposit signature is valid
        if bls.Verify(pubkey, signing_root, deposit.data.signature):
            state.validators.append(get_validator_from_deposit(state, deposit))
            state.balances.append(amount)
            state.previous_epoch_participation.append(ParticipationFlags(0b0000_0000))
            state.current_epoch_participation.append(ParticipationFlags(0b0000_0000))
            state.inactivity_scores.append(uint64(0))
    else:
        # Increase balance by deposit amount
        index = ValidatorIndex(validator_pubkeys.index(pubkey))
        increase_balance(state, index, amount)
</code></pre></div>
<p dir="auto"><code>BeaconState</code> will be preseted few sections below.</p>
</details>
<h4 dir="auto"><a id="user-content-failures" aria-hidden="true" href="#failures"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Failures</h4>
<p dir="auto">A validator that follows its protocol during an execution is called <em>honest</em>. On the other hand, a faulty validator may crash or even deviate arbitrarily from its specification, e.g., when corrupted by an adversary; such validators are also called <em>Byzantine</em>. In particular, Byzantine processes can <em>equivocate</em>, i.e., they can send conflicting messages. We consider only Byzantine faults here and assume the existence of a probabilistic poly-time adversary <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$\mathcal{A}$</math-renderer> that can choose up to <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$f$</math-renderer> validators to corrupt. The adversary <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$\mathcal{A}$</math-renderer> knows the internal state of corrupted validators. Finally, we assume that the majority of the validators is honest.</p>
<h4 dir="auto"><a id="user-content-links" aria-hidden="true" href="#links"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Links</h4>
<p dir="auto">We assume that a best-effort gossip primitive that will reach all validators is available. Moreover, we assume that messages from honest validator to honest validator are eventually received and cannot be forged. This includes messages sent by Byzantine validators, once they have been received by some honest validator <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$v_i$</math-renderer> and gossiped around by <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$v_i$</math-renderer>.</p>
<h4 dir="auto"><a id="user-content-time-and-sleepiness" aria-hidden="true" href="#time-and-sleepiness"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Time and sleepiness</h4>
<p dir="auto">Time is divided into discrete <em>slots</em> and a collection of <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$C$</math-renderer> slots forms an <em>epoch</em>. The genesis block <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$B_{\text{genesis}}$</math-renderer>, i.e., the first block in the blockchain, has slot number <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$0$</math-renderer> and is the first block of epoch <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$0$</math-renderer>. Generally, blocks belonging to epoch <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$j$</math-renderer> have slot numbers <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$jC + k$</math-renderer> as <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$k$</math-renderer> runs through <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">${0, 1, \ldots , C − 1}$</math-renderer>. The adversary <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$\mathcal{A}$</math-renderer> can decide for each slot which honest validator is <em>awake</em> or <em>asleep</em> at that slot. Asleep validators do not execute the protocol and messages for that slot are queued and delivered in the first slot in which the validator is awake again. [<a href="https://eprint.iacr.org/2016/918.pdf" rel="nofollow">https://eprint.iacr.org/2016/918.pdf</a>]
Communication is asynchronous until a global stabilization time (GST), after which communication becomes synchronous, i.e., message delays and processing times are bounded by <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$\Delta$</math-renderer> and validators have synchronized clocks. Moreover, honest nodes sleep and wake up until a global awake time (GAT), after which all nodes are awake. Adversary nodes are always awake. [<a href="https://arxiv.org/pdf/2009.04987.pdf" rel="nofollow">https://arxiv.org/pdf/2009.04987.pdf</a>]</p>
<h3 dir="auto"><a id="user-content-gasper" aria-hidden="true" href="#gasper"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Gasper</h3>
<p dir="auto"><strong>Gasper</strong> is a proof-of-stake consensus protocol obtained by the combination of two modules: <strong>FFG Casper</strong>, a finality gadget, and (a variation of) <strong>LMD-GHOST</strong>, a fork choice rule. The latter evolved during the years, due to some problems.</p>
<h4 dir="auto"><a id="user-content-friendly-finality-gadget-ffg-casper" aria-hidden="true" href="#friendly-finality-gadget-ffg-casper"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Friendly Finality Gadget (FFG) Casper</h4>
<p dir="auto"><strong>FFG Casper</strong> is a partial consensus protocol atop a proposal mechanism, i.e., a mechanism which proposes blocks, that aims at <em>finalizing</em> these blocks. Once a block is finalized it cannot be reverted, and a conflicting finalized block cannot be obtained. Casper introduces <em>accountability</em>, i.e., if a validators violates some rule, it is possible to detect the violation and know which validator violated the rule. Accountability allows the system to penalize (to <em>slash</em>) Byzantine validators, solving the <em>nothing at stake</em> problem.
Moreover, Casper introduces a way for the validator set to change over time, allowing new validators to join the validator set, and existing validators to leave.</p>
<p dir="auto"><a href="https://arxiv.org/pdf/1710.09437.pdf" rel="nofollow">Casper</a>, introduced by Buterin and Griffith, works following a two-phase traditional propose-and-vote-based Byzantine fault tolerant (BFT) mechanism, such as <a href="https://pmg.csail.mit.edu/papers/osdi99.pdf" rel="nofollow">PBFT</a> or <a href="https://arxiv.org/pdf/1803.05069.pdf" rel="nofollow">HotStuff</a>. Differently from PBFT or HotStuff, Casper is not a fully-specified protocol and is designed to be a <em>gadget</em> that works on top of a provided blockchain protocol. Again, differently from PBFT or HotStuff, in Casper there is no leader in charge of assembling proposals which are instead generated across honest nodes by an underlying proposal mechanism which produces child blocks of existing blocks, forming an ever-growing <em>block-tree</em>. The root of the three is the genesis block <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$B_{\text{genesis}}$</math-renderer>. Casper only considers a subtree of the blocks generated by the proposal mechanism, which we call a <em>checkpoint tree</em>. Blocks in the Casper checkpoint tree are called <em>checkpoints</em>.</p>
<details><summary>Checkpoint</summary>
<div dir="auto" data-snippet-clipboard-copy-content="class Checkpoint(Container):
    epoch: Epoch
    root: Root"><pre><span>class</span> <span>Checkpoint</span>(<span>Container</span>):
    <span>epoch</span>: <span>Epoch</span>
    <span>root</span>: <span>Root</span></pre></div>
</details>
<p dir="auto">The genesis block is <em>justified</em> and <em>finalized</em>, according to the following description.</p>
<p dir="auto">Casper proceeds as follows. Validators participate in the protocol by casting <em>votes</em> on blocks in the block-tree formed by the underlying proposal mechanism.</p>
<p dir="auto">A vote message consists of four fields: two blocks (called in the context of Casper, checkpoints) <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$s$</math-renderer> (source) and <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$t$</math-renderer> (target) together with their heights <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$h(s)$</math-renderer> and <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$h(t)$</math-renderer> (<em>The height $h(c)$ of a checkpoint $c$ is the number of elements in the checkpoint tree from $c$ (non-inclusive) to the root along the parent links.</em>). It is required to <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$s$</math-renderer> to be an ancestor of <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$t$</math-renderer> in the checkpoint tree, otherwise the vote is considered invalid. If <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$v_i$</math-renderer> is not in the validator set <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$\mathcal{V}$</math-renderer>, the vote is considered invalid. Together with the signature of the validator <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$v_i$</math-renderer>, a vote is expressed in the form <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$⟨v_i, s, t, h(s), h(t)⟩$</math-renderer>.</p>
<p dir="auto"><em>For the rest of this document, when we say “$\frac{2}{3}$ of validators”, we are referring to the deposit-weighted fraction; that is, a set of validators whose sum deposit size equals to $\frac{2}{3}$ of the total deposit size of the entire set of validators.</em></p>
<p dir="auto">Once a vote <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$⟨v_i, a, b, h(a), h(b)⟩$</math-renderer> has been cast by <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$\frac{2}{3}$</math-renderer> of validators and the checkpoint <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$a$</math-renderer> is justified (and the notion of <em>supermajority link</em> is defined as an ordered pair <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$(a,b),$</math-renderer> such that <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$\frac{2}{3}$</math-renderer> of validators have broadcast votes with source <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$a$</math-renderer> and target <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$b$</math-renderer>), the checkpoint <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$b$</math-renderer> becomes justified. Finally, the checkpoint <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$b$</math-renderer> is finalized if <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$b$</math-renderer> is justified and at least <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$\frac{2}{3}$</math-renderer> of validators broadcast a vote <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$⟨v_i, b, c, h(b), h(c)⟩$</math-renderer>, with <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$h(c)=h(b)+1.$</math-renderer> Observe that votes can skip checkpoints, i.e., given a vote <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$⟨v_i, a, b, h(a), h(b)⟩$</math-renderer>, it is permitted to have h(b) &gt; h(a) + 1.</p>
<p dir="auto">Let <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$⟨v_i, s_1, t_1, h(s_1), h(t_1)⟩$</math-renderer> and <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$⟨v, s_2, t_2, h(s_2), h(t_2)⟩$</math-renderer> be two voted cast by validator <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$v_i$</math-renderer>. Then, it must not be that either:</p>
<ul dir="auto">
<li>
<math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$h(t_1) = h(t_2)$</math-renderer>, i.e., a validator must not publish two distinct votes for the same target height; or</li>
<li>
<math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$h(s_1) &amp;lt; h(s_2) &amp;lt; h(t_2) &amp;lt; h(t_1)$</math-renderer>, i.e., a validator must not vote within the span of its other votes.</li>
</ul>
<p dir="auto">If a validator violates either condition, the evidence of the violation can be observed, at which point the validator’s entire deposit is taken away (it is slashed) with a reward given to the submitter of the evidence transaction.</p>
<p dir="auto">Casper satisfies the following two properties, and the proof can be found in the <a href="https://arxiv.org/pdf/1710.09437.pdf" rel="nofollow">full paper</a>.</p>
<ul dir="auto">
<li><strong>Accountable Safety</strong>: Two conflicting checkpoints cannot both be finalized.</li>
<li><strong>Plausible Liveness</strong>: It is always possible to produce new finalized checkpoints, provided there exist blocks extending the block-tree formed by the underlying proposal mechanism.</li>
</ul>
<p dir="auto">As mentioned above, the set of validators needs to be able to change. New validators must be able to join, and existing validators must be able to leave.</p>
<details><summary>Voluntary Exit</summary>
<div dir="auto" data-snippet-clipboard-copy-content="class VoluntaryExit(Container):
    epoch: Epoch  # Earliest epoch when voluntary exit can be processed
    validator_index: ValidatorIndex"><pre><span>class</span> <span>VoluntaryExit</span>(<span>Container</span>):
    <span>epoch</span>: <span>Epoch</span>  <span># Earliest epoch when voluntary exit can be processed</span>
    <span>validator_index</span>: <span>ValidatorIndex</span></pre></div>
<div dir="auto" data-snippet-clipboard-copy-content="class SignedVoluntaryExit(Container):
    message: VoluntaryExit
    signature: BLSSignature"><pre><span>class</span> <span>SignedVoluntaryExit</span>(<span>Container</span>):
    <span>message</span>: <span>VoluntaryExit</span>
    <span>signature</span>: <span>BLSSignature</span></pre></div>
<p dir="auto">When a validator wishes to exit from the validator list, it may create, sign, and broadcast a message of this type.</p>
</details>
<p dir="auto">To accomplish this, the notion of <em>dynasty of a block</em> is introduced. The dynasty of a block <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$b$</math-renderer> is the number of finalized checkpoints in the chain from root to the parent of block <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$b$</math-renderer>. When a would-be validator’s deposit message is included in a block with dynasty <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$d$</math-renderer>, then the validator <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$v_i$</math-renderer> will join the validator set at first block with dynasty <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$d + 2$</math-renderer>, which is called the validator’s <em>start dynasty</em>, <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$DS(v_i)$</math-renderer>.
To leave the validator set, a validator must send a withdraw message. If validator <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$v_i$</math-renderer>’s withdraw message is included in a block with dynasty <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$d$</math-renderer>, it similarly leaves the validator set at the first block with dynasty <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$d + 2$</math-renderer>, which is called the validator’s <em>end dynasty</em>, <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$DE(v_i)$</math-renderer>. If a withdraw message has not yet been included, then <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$DE(v_i) = ∞$</math-renderer>. Once validator <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$v_i$</math-renderer> leaves the validator set, the validator’s public key is forever forbidden from rejoining the validator set.</p>
<p dir="auto">To generate two subsets of validators for any given dynasty <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$d$</math-renderer>, the <em>forward validator set</em> and the <em>rear validator set</em> are introduced.</p>
<p dir="auto"><math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$$\mathcal{V}_f(d) ≡ {v_i : DS(v_i) \le d &lt; DE(v_i)}, $$</math-renderer></p>
<p dir="auto"><math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$$\mathcal{V}_r(d) ≡ {v_i : DS(v_i) &lt; d \le DE(v_i)}.$$</math-renderer></p>
<p dir="auto">This implies a new way to define the notion of justified and finalized checkpoints. In particular, an ordered pair of checkpoints <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$(s,t)$</math-renderer>, where <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$t$</math-renderer> is in dynasty <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$d$</math-renderer>, has a supermajority link if <em>both</em> at least <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$\frac{2}{3}$</math-renderer> of validators of the forward validator set of dynasty <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$d$</math-renderer> have broadcast votes <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$(s,t)$</math-renderer> <em>and</em> at least <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$\frac{2}{3}$</math-renderer> of validators of the rear validator set of dynasty <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$d$</math-renderer> have broadcast votes <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$(s,t)$</math-renderer>.
Previously, a checkpoint <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$c$</math-renderer> was called finalized if <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$c$</math-renderer> is justified and there is a supermajority link <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$(c,c&#39;)$</math-renderer> with <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$h(c&#39;)=h(c)+1$</math-renderer>. Now it is added the condition that <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$c$</math-renderer> is finalized if only if the votes for the supermajority link <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$(c,c&#39;)$</math-renderer>, as well as the supermajority link justifying <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$c$</math-renderer>, are included in <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$c′$</math-renderer>’s block-tree and before the child of <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$c′$</math-renderer>.</p>
<h4 dir="auto"><a id="user-content-lmd-ghost" aria-hidden="true" href="#lmd-ghost"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>LMD-GHOST</h4>
<p dir="auto">The Latest Message Driven Greediest Heaviest Observed SubTree Greediest Heaviest Observed SubTree rule (<strong>LMD-GHOST</strong>) is a fork choice rule (A fork choice rule is a function that takes as inputs the set of blocks and other messages that have been seen, and outputs what the <em>canonical chain</em> is. This is required because there may be multiple valid chains to choose from.) introduced by <a href="https://github.com/vladzamfir/research/blob/master/papers/CasperTFG/CasperTFG.pdf">Zamfir</a> while looking for a “correct-by-construction” consensus protocol. LMD-GHOST is an adaptation of the original GHOST protocol introduced by <a href="https://eprint.iacr.org/2013/881.pdf" rel="nofollow">Sompolinsky and Zohar</a>, a greedy algorithm that grows a blockchain on sub-branches with the “most activity”, and it guides the block production process.</p>
<p dir="auto">The idea behind LMD-GHOST is that at any fork, the protocol uses the weights of the subtrees created by the fork as a heuristic and assumes the subtree with the heaviest weight is the <em>right</em> one, as evident from the name of the algorithm. The weight of a subtree is determined by the sum of the stake of the validators that have cast a vote, at every slot, on each single block forming such subtree. Moreover, the protocol considers only each validator’s most recent vote (or <em>attestation</em>) (LMD).</p>
<details><summary>Latest Message</summary>
<div dir="auto" data-snippet-clipboard-copy-content="@dataclass(eq=True, frozen=True)
class LatestMessage(object):
    epoch: Epoch
    root: Root"><pre><span>@<span>dataclass</span>(<span>eq</span><span>=</span><span>True</span>, <span>frozen</span><span>=</span><span>True</span>)</span>
<span>class</span> <span>LatestMessage</span>(<span>object</span>):
    <span>epoch</span>: <span>Epoch</span>
    <span>root</span>: <span>Root</span></pre></div>
<p dir="auto">This struct represents the vote in the latest (meaning highest-epoch) valid attestation received from a validator.</p>
</details>
<p dir="auto">We first show informally how LMD-GHOST works through <a href="https://vitalik.ca/general/2018/12/05/cbc_casper.html" rel="nofollow">an example</a>, and then we present the algorithm that implements it.</p>
<p dir="auto">Let us consider a validator set <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$\mathcal{V} = {v_1, v_2, v_3, v_4, v_5}$</math-renderer> and let us assume that validator <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$v_1$</math-renderer> makes the blocks at slots 0 and 5, validator <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$v_2$</math-renderer> makes the blocks at slots 1 and 6, and so on. A client evaluating the LMD-GHOST fork choice rule cares only about the most recent (i.e., highest-slot) message (i.e., block) signed by each validator:</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/dca94ab416e48f5a489287a68a4bf29caab09192050e5b69724df59956cd4bcd/68747470733a2f2f73746f726167652e676f6f676c65617069732e636f6d2f657468657265756d2d6861636b6d642f75706c6f61645f38333964363536663961353839373863336466633863666635363265616539322e6a706567"><img src="https://camo.githubusercontent.com/dca94ab416e48f5a489287a68a4bf29caab09192050e5b69724df59956cd4bcd/68747470733a2f2f73746f726167652e676f6f676c65617069732e636f6d2f657468657265756d2d6861636b6d642f75706c6f61645f38333964363536663961353839373863336466633863666635363265616539322e6a706567" alt="" data-canonical-src="https://storage.googleapis.com/ethereum-hackmd/upload_839d656f9a58978c3dfc8cff562eae92.jpeg"/></a></p>
<p dir="auto">The protocol proceeds as it follows. Start from the genesis block, every time there is a fork, choose the side where more of the latest messages support that block&#39;s subtree, and keep doing this until a block with no descendants is reached.</p>
<p dir="auto">By computing for each block the subset of latest messages that support either the block or one of its descendants, we obtain the following.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/a07f9825e911d2ab52f22ed3ffd32ad2b5cb8324a3384aff5c809e698673c406/68747470733a2f2f73746f726167652e676f6f676c65617069732e636f6d2f657468657265756d2d6861636b6d642f75706c6f61645f33356436386161653963323739613064396461373235653633663434333531372e6a706567"><img src="https://camo.githubusercontent.com/a07f9825e911d2ab52f22ed3ffd32ad2b5cb8324a3384aff5c809e698673c406/68747470733a2f2f73746f726167652e676f6f676c65617069732e636f6d2f657468657265756d2d6861636b6d642f75706c6f61645f33356436386161653963323739613064396461373235653633663434333531372e6a706567" alt="" data-canonical-src="https://storage.googleapis.com/ethereum-hackmd/upload_35d68aae9c279a0d9da725e63f443517.jpeg"/></a></p>
<p dir="auto">To compute the head, start at the beginning, and then at each fork pick the higher number: first, pick the bottom chain as it has 4 latest messages supporting it versus 1 for the single-block top chain, then at the next fork support the middle chain.</p>
<p dir="auto">We now present the protocol in a more formal way. First  we introduce the notions of <em>views</em> and <em>weight</em>.</p>
<p dir="auto">Due to network delays and Byzantine validators, validators may have different set of received messages.
Each message may have one or more dependencies, where each dependency is another message. At any time, a validator <em>accepts a message</em> if and only if all of its dependencies are accepted, defined recursively.
A <em>view</em> of a validator <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$v_i \in \mathcal{V}$</math-renderer> at a given time <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$t$</math-renderer>, denoted as <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$\mathscr{view}(v_i, t)$</math-renderer>, is the set of all the accepted messages that <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$v_i$</math-renderer> has seen so far. A <em>God’s-eye-view</em> is the set of accepted messages for a hypothetical validator that has seen (with no latency) all messages any validator has broadcast at any time (this includes messages sent by a Byzantine validator to only a subset of the network).</p>
<p dir="auto">Finally, given a view <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$G$</math-renderer> (<em>Since usually one talks about a specific point in time, the time can be suppressed and a notation such as $\mathscr{view}(v_i)$ (or, to simplify the notation, $G$) can be used to talk about $\mathscr{view}(v_i,t)$.</em>), let <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$M$</math-renderer> be the set of latest attestations, one per validator. The weight <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$w(G,B,M)$</math-renderer> is defined to be the sum of the stake of the validators whose last attestation in <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$M$</math-renderer> is to <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$B$</math-renderer> or descendants of <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$B.$</math-renderer></p>
<p dir="auto">The following algorithm implements the LMD-GHOST fork choice rule.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/6b3e516dda81c18740f8b759e488204b999f4f964348ad6430d59e420f44923b/68747470733a2f2f73746f726167652e676f6f676c65617069732e636f6d2f657468657265756d2d6861636b6d642f75706c6f61645f33663339393665303563393461633536313633623039393461356331313834332e706e67"><img src="https://camo.githubusercontent.com/6b3e516dda81c18740f8b759e488204b999f4f964348ad6430d59e420f44923b/68747470733a2f2f73746f726167652e676f6f676c65617069732e636f6d2f657468657265756d2d6861636b6d642f75706c6f61645f33663339393665303563393461633536313633623039393461356331313834332e706e67" alt="" data-canonical-src="https://storage.googleapis.com/ethereum-hackmd/upload_3f3996e05c94ac56163b0994a5c11843.png"/></a></p>
<h4 dir="auto"><a id="user-content-ffg-casper--hlmd-ghost--gasper" aria-hidden="true" href="#ffg-casper--hlmd-ghost--gasper"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>FFG Casper + (H)LMD-GHOST = Gasper</h4>
<p dir="auto">As we already mentioned, <strong>Gasper</strong> is a proof-of-stake protocol obtained by combining the finality gadget Casper on top and (an FFG-aware variation of) the fork choice LMD-GHOST as a basis, called <em>Hybrid</em> LMD-GHOST (HLMD-GHOST).</p>
<details><summary>Beacon State</summary>
<div data-snippet-clipboard-copy-content="class BeaconState(Container):
    # Versioning
    genesis_time: uint64
    genesis_validators_root: Root
    slot: Slot
    fork: Fork
    # History
    latest_block_header: BeaconBlockHeader
    block_roots: Vector[Root, SLOTS_PER_HISTORICAL_ROOT]
    state_roots: Vector[Root, SLOTS_PER_HISTORICAL_ROOT]
    historical_roots: List[Root, HISTORICAL_ROOTS_LIMIT]
    # Eth1
    eth1_data: Eth1Data
    eth1_data_votes: List[Eth1Data, EPOCHS_PER_ETH1_VOTING_PERIOD * SLOTS_PER_EPOCH]
    eth1_deposit_index: uint64
    # Registry
    validators: List[Validator, VALIDATOR_REGISTRY_LIMIT]
    balances: List[Gwei, VALIDATOR_REGISTRY_LIMIT]
    # Randomness
    randao_mixes: Vector[Bytes32, EPOCHS_PER_HISTORICAL_VECTOR]
    # Slashings
    slashings: Vector[Gwei, EPOCHS_PER_SLASHINGS_VECTOR]  # Per-epoch sums of slashed effective balances
    # Participation
    previous_epoch_participation: List[ParticipationFlags, VALIDATOR_REGISTRY_LIMIT]
    current_epoch_participation: List[ParticipationFlags, VALIDATOR_REGISTRY_LIMIT]
    # Finality
    justification_bits: Bitvector[JUSTIFICATION_BITS_LENGTH]  # Bit set for every recent justified epoch
    previous_justified_checkpoint: Checkpoint
    current_justified_checkpoint: Checkpoint
    finalized_checkpoint: Checkpoint
    # Inactivity
    inactivity_scores: List[uint64, VALIDATOR_REGISTRY_LIMIT]
    # Sync
    current_sync_committee: SyncCommittee
    next_sync_committee: SyncCommittee
    # Execution
    latest_execution_payload_header: ExecutionPayloadHeader  # [New in Bellatrix]"><pre lang="python"><code>class BeaconState(Container):
    # Versioning
    genesis_time: uint64
    genesis_validators_root: Root
    slot: Slot
    fork: Fork
    # History
    latest_block_header: BeaconBlockHeader
    block_roots: Vector[Root, SLOTS_PER_HISTORICAL_ROOT]
    state_roots: Vector[Root, SLOTS_PER_HISTORICAL_ROOT]
    historical_roots: List[Root, HISTORICAL_ROOTS_LIMIT]
    # Eth1
    eth1_data: Eth1Data
    eth1_data_votes: List[Eth1Data, EPOCHS_PER_ETH1_VOTING_PERIOD * SLOTS_PER_EPOCH]
    eth1_deposit_index: uint64
    # Registry
    validators: List[Validator, VALIDATOR_REGISTRY_LIMIT]
    balances: List[Gwei, VALIDATOR_REGISTRY_LIMIT]
    # Randomness
    randao_mixes: Vector[Bytes32, EPOCHS_PER_HISTORICAL_VECTOR]
    # Slashings
    slashings: Vector[Gwei, EPOCHS_PER_SLASHINGS_VECTOR]  # Per-epoch sums of slashed effective balances
    # Participation
    previous_epoch_participation: List[ParticipationFlags, VALIDATOR_REGISTRY_LIMIT]
    current_epoch_participation: List[ParticipationFlags, VALIDATOR_REGISTRY_LIMIT]
    # Finality
    justification_bits: Bitvector[JUSTIFICATION_BITS_LENGTH]  # Bit set for every recent justified epoch
    previous_justified_checkpoint: Checkpoint
    current_justified_checkpoint: Checkpoint
    finalized_checkpoint: Checkpoint
    # Inactivity
    inactivity_scores: List[uint64, VALIDATOR_REGISTRY_LIMIT]
    # Sync
    current_sync_committee: SyncCommittee
    next_sync_committee: SyncCommittee
    # Execution
    latest_execution_payload_header: ExecutionPayloadHeader  # [New in Bellatrix]
</code></pre></div>
<p dir="auto">The <code>BeaconState</code> is what every validator must agree on, i.e., it is the state that every honest validator (should) reach through Gasper. It contains all the relevant information regarding the active validators, their (exact) balances, the history of the blockchain, the slashed validators, and also all the information related to justification and finalization. Everything is bundled into this single state object.</p>
<p dir="auto">We describe the most relevant (for this document) fields in the following.</p>
<p dir="auto"><code>genesis_time</code>: used by the fork choice rule to figure out what slot we&#39;re in, and to validate <code>execution_payloads</code>;</p>
<p dir="auto"><code>genesis_validators_root</code>: used to uniquely identify the chain that we are on;</p>
<p dir="auto"><code>latest_block_header</code>: used to process blocks that are descendents of the previous block;</p>
<p dir="auto"><code>block_roots</code> and <code>state_roots</code> are stored in lists until they are full. After that, the Merkle root is taken of both the lists together and appended to <code>historical_roots</code>;</p>
<p dir="auto"><code>eth1_data</code>: is the latest agreed upon state of the deposit contract;</p>
<p dir="auto"><code>eth1_data_votes</code>: votes on <code>Eth1Data</code>;</p>
<p dir="auto"><code>eth1_deposit_index</code>: total number of deposits that have been processed by the beacon chain;</p>
<p dir="auto"><code>validators</code> and <code>balances</code> contain the list of all the validators and their exact balances, respecively. Recall that every validator has two balances, an effective one (stored in the <code>Validator</code> object, and that is updated less frequently), and an exact one, that changes every epoch. Here the exact one is stored.</p>
<p dir="auto"><code>slashings</code>: used to store the total effective balance of all validators slashed in an epoch, for every epoch;</p>
<p dir="auto"><code>previous_epoch_participation</code>: used to record which validators participated in attesting during the previous epoch;</p>
<p dir="auto"><code>current_epoch_participation</code>: used to record which validators participated in attesting during the current epoch;</p>
<p dir="auto"><code>justification_bits</code>: used to keep track of the justification status of the last four epochs: <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$1$</math-renderer> if justified, <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$0$</math-renderer> if not;</p>
<p dir="auto"><code>previous_justified_checkpoint</code> and <code>current_justified_checkpoint</code> are the most recent justified <code>Checkpoint</code> as it was during the previous epoch and the most recent justified <code>Checkpoint</code> during the current epoch, respectively. They are used to filter attestations, i.e., blocks are considered valid if they include only attestations with a source checkpoint that matches the justified checkpoint the state. Moreover, they are used during the finalization process, following the rule of FFG Casper;</p>
<p dir="auto"><code>finalized_checkpoint</code>: used to keep track of the finalized checkpoint, as a result of FFG Casper. This guarantees that the state at or before the epoch with the finalized checkpoint will never be reverted, and the fork choice rule does not need to go back more that this checkpoint;</p>
<p dir="auto"><code>latest_execution_payload_header</code>: header of the most recent execution payload.</p>
<div data-snippet-clipboard-copy-content="def state_transition(state: BeaconState, signed_block: SignedBeaconBlock, validate_result: bool=True) -&gt; None:
    block = signed_block.message
    # Process slots (including those with no blocks) since block
    process_slots(state, block.slot)
    # Verify signature
    if validate_result:
        assert verify_block_signature(state, signed_block)
    # Process block
    process_block(state, block)
    # Verify state root
    if validate_result:
        assert block.state_root == hash_tree_root(state)"><pre lang="python"><code>def state_transition(state: BeaconState, signed_block: SignedBeaconBlock, validate_result: bool=True) -&gt; None:
    block = signed_block.message
    # Process slots (including those with no blocks) since block
    process_slots(state, block.slot)
    # Verify signature
    if validate_result:
        assert verify_block_signature(state, signed_block)
    # Process block
    process_block(state, block)
    # Verify state root
    if validate_result:
        assert block.state_root == hash_tree_root(state)
</code></pre></div>
<p dir="auto">The <code>state_transition</code> function is the function that is used to modify the <code>BeaconState</code>, processing slots (through <code>process_slots</code>), even in the case with no blocks, and blocks (through <code>process_block</code>).</p>
<p dir="auto">All the records/objects described in this box will be clearer after the next few sections.</p>
</details>
<p dir="auto">In this section we show how to define justification and finalization in Gasper, and we present the Hybrid LMD-GHOST that is used among validators to choose the head/tip of the chain at any slot.</p>
<p dir="auto">We start by presenting some preliminary notions.</p>
<p dir="auto">For a block <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$B$</math-renderer> and an epoch <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$j$</math-renderer>, define <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$EBB(B, j)$</math-renderer>, the <em>$j$-th epoch boundary block</em> of <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$B$</math-renderer>, to be the block with the highest slot less than or equal to <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$jC$</math-renderer> in <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$\mathscr{chain}(B)$</math-renderer>, the unique chain determined by <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$B$</math-renderer>. Let the <em>latest</em> such block be <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$LEBB(B)$</math-renderer>, or the last epoch boundary block (of <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$B$</math-renderer>). Then, for every block <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$B$</math-renderer>, <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$EBB(B, 0)$</math-renderer> is the genesis block. More generally, if <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$\mathscr{slot}(B) = jC$</math-renderer> for some epoch <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$j$</math-renderer>, <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$B$</math-renderer> will be an epoch boundary block in every chain that includes it.</p>
<p dir="auto">However, a block could be an epoch boundary block in some chains but not others. For this reason, <em>epoch boundary pairs</em> (or pairs for short) <em>(B, j)</em> are introduced, where <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$B$</math-renderer> is a block and <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$j$</math-renderer> is an epoch. These epoch boundary pairs are considered to play the role of Casper&#39;s checkpoints. A pair <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$P = (B, j)$</math-renderer> has <em>attestation epoch</em> <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$j$</math-renderer>, denoted as <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$\mathscr{aep}(P) = j$</math-renderer>. Observe that this is not necessarily the same as <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$\mathscr{ep}(B)$</math-renderer>, i.e., the epoch of <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$B$</math-renderer>. In fact, <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$\mathscr{ep}()$</math-renderer> is a local property that only depends on the block’s slot, while epoch boundary concepts like <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$\mathscr{aep}()$</math-renderer> depend on the context of the chain. Note that, without loss of generality, sometimes slot numbers are used as argument for <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$\mathscr{ep}$</math-renderer> and <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$\mathscr{aep}$</math-renderer> instead of blocks. It is clear that at any block <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$B$</math-renderer> corresponds a slot number. Moreover, <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$\mathscr{ep}(\alpha)$</math-renderer> is sometimes used as shorthand for <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$\mathscr{ep}(\mathscr{slot}(\alpha))$</math-renderer>.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/c5fb6060e3d81351de2fd285f31241ab2e1b05c64df3327bd504b2e4f9fa30f0/68747470733a2f2f73746f726167652e676f6f676c65617069732e636f6d2f657468657265756d2d6861636b6d642f75706c6f61645f62396437386663376333376439336462326331333964373332373961333365392e706e67"><img src="https://camo.githubusercontent.com/c5fb6060e3d81351de2fd285f31241ab2e1b05c64df3327bd504b2e4f9fa30f0/68747470733a2f2f73746f726167652e676f6f676c65617069732e636f6d2f657468657265756d2d6861636b6d642f75706c6f61645f62396437386663376333376439336462326331333964373332373961333365392e706e67" alt="" data-canonical-src="https://storage.googleapis.com/ethereum-hackmd/upload_b9d78fc7c37d93db2c139d73279a33e9.png"/></a></p>
<p dir="auto">In the image above, <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$\mathscr{aep}(63, 1)$</math-renderer> and <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$\mathscr{ep}(63) = 0$</math-renderer>.</p>
<p dir="auto">Finally, observe that, in Gasper, instead of justifying and finalizing checkpoint blocks as with Casper, epoch boundary pairs are justified and finalized.</p>
<p dir="auto">Given a block <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$B$</math-renderer>, we define <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$\mathscr{view}(B)$</math-renderer>, the view of <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$B$</math-renderer>, to be the view consisting of <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$B$</math-renderer> and all its ancestors. We define <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$\mathscr{ffgview}(B)$</math-renderer>, the FFG view of <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$B$</math-renderer>, to be <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$\mathscr{view}(LEBB(B))$</math-renderer>.
The definition of <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$\mathscr{view}(B)$</math-renderer> is <em>agnostic of the viewer</em>, in the sense that any view that accepted <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$B$</math-renderer> can compute an identical <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$\mathscr{view}(B)$</math-renderer>, so we do not need to supply a validator into the argument. Intuitively, <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$\mathscr{view}(B)$</math-renderer> <em>focuses</em> the view to the chain starting from the genesis block to <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$B$</math-renderer> and <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$\mathscr{ffgview}(B)$</math-renderer> looks at a <em>frozen</em> snapshot of <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$\mathscr{view}(B)$</math-renderer> at the last checkpoint. Casper FFG operates only on epoch boundary pairs, so the FFG view of a block <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$B$</math-renderer> extracts exactly the information in the chain starting from the genesis block to <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$B$</math-renderer> that is relevant to Casper FFG.</p>
<p dir="auto">In Gasper, validators are partitioned into <em>committees</em> in each epoch, with one committee per slot. In each slot, one validator from the designated committee proposes a block. Then, all the members of that committee will <em>attest</em> to what they see as the head of the chain with the fork choice rule HLMD-GHOST (a slight variation of LMD-GHOST that will be presented below).</p>
<p dir="auto">More in details, in each slot, the protocol requires validators to carry out two types of work. One validator in the committee, called <em>proposer</em>, needs to <em>propose</em> a new block (which is a message containing the slot number, a pointer to the parent block, a set of pointers to all the attestations that the validator has accepted, but have not been included in any other ancestor block, and some implementation-specific data).</p>
<details><summary>Beacon Block</summary>
<div dir="auto" data-snippet-clipboard-copy-content="class BeaconBlockBody(Container):
    randao_reveal: BLSSignature
    eth1_data: Eth1Data  # Eth1 data vote
    graffiti: Bytes32  # Arbitrary data
    # Operations
    proposer_slashings: List[ProposerSlashing, MAX_PROPOSER_SLASHINGS]
    attester_slashings: List[AttesterSlashing, MAX_ATTESTER_SLASHINGS]
    attestations: List[Attestation, MAX_ATTESTATIONS]
    deposits: List[Deposit, MAX_DEPOSITS]
    voluntary_exits: List[SignedVoluntaryExit, MAX_VOLUNTARY_EXITS]
    sync_aggregate: SyncAggregate
    # Execution
    execution_payload: ExecutionPayload  # [New in Bellatrix]"><pre><span>class</span> <span>BeaconBlockBody</span>(<span>Container</span>):
    <span>randao_reveal</span>: <span>BLSSignature</span>
    <span>eth1_data</span>: <span>Eth1Data</span>  <span># Eth1 data vote</span>
    <span>graffiti</span>: <span>Bytes32</span>  <span># Arbitrary data</span>
    <span># Operations</span>
    <span>proposer_slashings</span>: <span>List</span>[<span>ProposerSlashing</span>, <span>MAX_PROPOSER_SLASHINGS</span>]
    <span>attester_slashings</span>: <span>List</span>[<span>AttesterSlashing</span>, <span>MAX_ATTESTER_SLASHINGS</span>]
    <span>attestations</span>: <span>List</span>[<span>Attestation</span>, <span>MAX_ATTESTATIONS</span>]
    <span>deposits</span>: <span>List</span>[<span>Deposit</span>, <span>MAX_DEPOSITS</span>]
    <span>voluntary_exits</span>: <span>List</span>[<span>SignedVoluntaryExit</span>, <span>MAX_VOLUNTARY_EXITS</span>]
    <span>sync_aggregate</span>: <span>SyncAggregate</span>
    <span># Execution</span>
    <span>execution_payload</span>: <span>ExecutionPayload</span>  <span># [New in Bellatrix]</span></pre></div>
<p dir="auto">The <code>BeaconBlock</code> is the block that the proposer for a given slot creates and communicates to the network. This block, if correct, will update the <code>BeaconState</code> of every honest validator. Validators are randomly selected to propose <code>BeaconBlock</code>s, and there can be at most one <code>BeaconBlock</code> per slot.</p>
<p dir="auto"><code>randao_reveal</code>: record used for randomness purposes. The proposer generates it by signing the current epoch number with its private key;</p>
<p dir="auto"><code>eth1_data</code>: record used in a pre-merge version of Ethereum consensus protocol, and it is/was used for the deposits of validators;</p>
<p dir="auto"><code>graffiti</code>: record used by the proposer to insert whatever data it wishes. It has no protocol level significance;</p>
<p dir="auto"><code>proposer_slashings</code>: contains up to <code>MAX_PROPOSER_SLASHINGS</code> <code>ProposerSlashing</code> objects (see below);</p>
<p dir="auto"><code>attester_slashings</code>: contains up to <code>MAX_ATTESTER_SLASHINGS</code> <code>AttesterSlashing</code> objects (see below);</p>
<p dir="auto"><code>attestations</code>: contains up to <code>MAX_ATTESTATIONS</code> <code>Attestation objects</code> (see below). The proposer earns a reward for including well-packed aggregate attestations;</p>
<p dir="auto"><code>deposits</code>: if the block does not contain all the outstanding <code>Deposits</code>, it is considered invalid;</p>
<p dir="auto"><code>voluntary_exits</code>: contains up to <code>MAX_VOLUNTARY_EXITS</code> <code>SignedVoluntaryExit</code> objects;</p>
<p dir="auto"><code>sync_aggregate</code>: is a record voted from the current sync committee for the chain head in the previous slot;</p>
<p dir="auto"><code>execution_payload</code>: Ethereum transactions are included in this record.</p>
<div dir="auto" data-snippet-clipboard-copy-content="class BeaconBlock(Container):
    slot: Slot
    proposer_index: ValidatorIndex
    parent_root: Root
    state_root: Root
    body: BeaconBlockBody"><pre><span>class</span> <span>BeaconBlock</span>(<span>Container</span>):
    <span>slot</span>: <span>Slot</span>
    <span>proposer_index</span>: <span>ValidatorIndex</span>
    <span>parent_root</span>: <span>Root</span>
    <span>state_root</span>: <span>Root</span>
    <span>body</span>: <span>BeaconBlockBody</span></pre></div>
</details>
<p dir="auto">Moreover, everyone in the committee needs to attest to their head of the chain with an attestation <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$\alpha$</math-renderer> (which is a message containing the slot in which the validator is making the attestation, <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$\mathscr{slot}(\alpha)$</math-renderer>, the target block a validator is attesting to, <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$\mathscr{block}(\alpha)$</math-renderer>, and a checkpoint edge between two epoch boundary pairs, $LJ(\alpha) \rightarrow LE(\alpha)$). Both of them require to add a corresponding block and an attestation, respectively, to the validator&#39;s view, and then to broadcast it to the network. Observe that both proposing and attesting requires the committee member to run the same fork choice rule on the validator&#39;s own view.</p>
<p dir="auto">Note that, while attesting, a validator does two things at once: it is simultaneously casting a GHOST vote for its block and also a Casper FFG vote for the transition between the two epoch boundary pairs (akin to Casper’s checkpoint blocks).</p>
<details><summary>Attestation</summary>
<div data-snippet-clipboard-copy-content="class AttestationData(Container):
    slot: Slot
    index: CommitteeIndex
    # LMD GHOST vote
    beacon_block_root: Root
    # FFG vote
    source: Checkpoint
    target: Checkpoint"><pre lang="python"><code>class AttestationData(Container):
    slot: Slot
    index: CommitteeIndex
    # LMD GHOST vote
    beacon_block_root: Root
    # FFG vote
    source: Checkpoint
    target: Checkpoint
</code></pre></div>
<p dir="auto"><code>AttestationData</code> contains information about the attestation that a validator sent to the network in a given slot.</p>
<p dir="auto"><code>slot</code>: slot in which a validator is casting the attestation. It is recorded here for validation purposes;</p>
<p dir="auto"><code>index</code>: there can be several committees active in a single slot. This is the number of the committee that the validator belongs to in that slot;</p>
<p dir="auto"><code>beacon_block_root</code> is the validator&#39;s vote on the head block for that slot after locally running the LMD GHOST fork choice rule. If the validator believes that the current slot is empty, then this record might be the root of a block from a previous slot;</p>
<p dir="auto"><code>source</code>: the best currently justified checkpoint for the Casper FFG finalisation process, according to the validator;</p>
<p dir="auto"><code>target</code>: the block at the start of the current epoch (EBB), also for Casper FFG finalization, according to the validator;</p>
<p dir="auto"><code>AttestationData</code> is wrapped in the following.</p>
<div data-snippet-clipboard-copy-content="class Attestation(Container):
    aggregation_bits: Bitlist[MAX_VALIDATORS_PER_COMMITTEE]
    data: AttestationData
    signature: BLSSignature"><pre lang="python"><code>class Attestation(Container):
    aggregation_bits: Bitlist[MAX_VALIDATORS_PER_COMMITTEE]
    data: AttestationData
    signature: BLSSignature
</code></pre></div>
<div data-snippet-clipboard-copy-content="
def process_attestation(state: BeaconState, attestation: Attestation) -&gt; None:
    data = attestation.data
    assert data.target.epoch in (get_previous_epoch(state), get_current_epoch(state))
    assert data.target.epoch == compute_epoch_at_slot(data.slot)
    assert data.slot + MIN_ATTESTATION_INCLUSION_DELAY &lt;= state.slot &lt;= data.slot + SLOTS_PER_EPOCH
    assert data.index &lt; get_committee_count_per_slot(state, data.target.epoch)

    committee = get_beacon_committee(state, data.slot, data.index)
    assert len(attestation.aggregation_bits) == len(committee)

    # Participation flag indices
    participation_flag_indices = get_attestation_participation_flag_indices(state, data, state.slot - data.slot)

    # Verify signature
    assert is_valid_indexed_attestation(state, get_indexed_attestation(state, attestation))

    # Update epoch participation flags
    if data.target.epoch == get_current_epoch(state):
        epoch_participation = state.current_epoch_participation
    else:
        epoch_participation = state.previous_epoch_participation

    proposer_reward_numerator = 0
    for index in get_attesting_indices(state, data, attestation.aggregation_bits):
        for flag_index, weight in enumerate(PARTICIPATION_FLAG_WEIGHTS):
            if flag_index in participation_flag_indices and not has_flag(epoch_participation[index], flag_index):
                epoch_participation[index] = add_flag(epoch_participation[index], flag_index)
                proposer_reward_numerator += get_base_reward(state, index) * weight

    # Reward proposer
    proposer_reward_denominator = (WEIGHT_DENOMINATOR - PROPOSER_WEIGHT) * WEIGHT_DENOMINATOR // PROPOSER_WEIGHT
    proposer_reward = Gwei(proposer_reward_numerator // proposer_reward_denominator)
    increase_balance(state, get_beacon_proposer_index(state), proposer_reward)
"><pre lang="python"><code>
def process_attestation(state: BeaconState, attestation: Attestation) -&gt; None:
    data = attestation.data
    assert data.target.epoch in (get_previous_epoch(state), get_current_epoch(state))
    assert data.target.epoch == compute_epoch_at_slot(data.slot)
    assert data.slot + MIN_ATTESTATION_INCLUSION_DELAY &lt;= state.slot &lt;= data.slot + SLOTS_PER_EPOCH
    assert data.index &lt; get_committee_count_per_slot(state, data.target.epoch)

    committee = get_beacon_committee(state, data.slot, data.index)
    assert len(attestation.aggregation_bits) == len(committee)

    # Participation flag indices
    participation_flag_indices = get_attestation_participation_flag_indices(state, data, state.slot - data.slot)

    # Verify signature
    assert is_valid_indexed_attestation(state, get_indexed_attestation(state, attestation))

    # Update epoch participation flags
    if data.target.epoch == get_current_epoch(state):
        epoch_participation = state.current_epoch_participation
    else:
        epoch_participation = state.previous_epoch_participation

    proposer_reward_numerator = 0
    for index in get_attesting_indices(state, data, attestation.aggregation_bits):
        for flag_index, weight in enumerate(PARTICIPATION_FLAG_WEIGHTS):
            if flag_index in participation_flag_indices and not has_flag(epoch_participation[index], flag_index):
                epoch_participation[index] = add_flag(epoch_participation[index], flag_index)
                proposer_reward_numerator += get_base_reward(state, index) * weight

    # Reward proposer
    proposer_reward_denominator = (WEIGHT_DENOMINATOR - PROPOSER_WEIGHT) * WEIGHT_DENOMINATOR // PROPOSER_WEIGHT
    proposer_reward = Gwei(proposer_reward_numerator // proposer_reward_denominator)
    increase_balance(state, get_beacon_proposer_index(state), proposer_reward)

</code></pre></div>
<p dir="auto">This function processes attestations included in <code>BeaconBlockBody</code>. First it performs some validity checks such as, for example, that the target checkpoint and the attestation&#39;s slot must belong to the same epoch, or that the attestation must be no older than <code>SLOTS_PER_EPOCH</code> ($32$) slots. Then, once the attestation has passed all the validity checks, it is processed.</p>
</details>
<p dir="auto">In the previous section, the notion of justification and finalization were given in the context of FFG Casper. For Gasper, these are extended as it follows.</p>
<p dir="auto">Recall an attestation <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$\alpha$</math-renderer> for Gasper contains a checkpoint edge <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$LJ(\alpha) \rightarrow LE(\alpha)$</math-renderer> between epoch boundary pairs, acting as a FFG vote between two epoch boundary pairs. If at least <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$\frac{2}{3}$</math-renderer> of validators have broadcast votes with source <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$(A,j&#39;)$</math-renderer> and target <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$(B,j)$</math-renderer>, then there is a <em>supermajority link</em> from epoch boundary pairs <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$(A,j&#39;)$</math-renderer> and <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$(B,j),$</math-renderer> denoted with <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$(A,j&#39;) \xrightarrow[]{J} (B,j)$</math-renderer>.</p>
<p dir="auto">Given a view <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$G$</math-renderer>, the set <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$J(G)$</math-renderer> of <em>justified</em> pairs is such that <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$(B_{\text{genesis}}, 0) \in J(G)$</math-renderer> and if <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$(A,j&#39;) \in J(G)$</math-renderer> and <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$(A,j&#39;) \xrightarrow[]{J} (B,j)$</math-renderer> , then <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$(B,j) \in J(G)$</math-renderer>, i.e., <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$B$</math-renderer> is justified in <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$G$</math-renderer> during epoch <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$j.$</math-renderer></p>
<p dir="auto">With the notion of justification, it becomes clearer then what both <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$LJ(\alpha)$</math-renderer> and <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$LE(\alpha)$</math-renderer> mean: <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$LJ(\alpha)$</math-renderer> is the last justified pair of <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$\alpha$</math-renderer>, i.e., the last justified pair in <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$\mathscr{ffgview}(\mathscr{block}(\alpha))=\mathscr{view}(B)$</math-renderer>, while <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$LE(\alpha)$</math-renderer> is the last epoch boundary pair of <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$\alpha$</math-renderer>, i.e., <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$(B, \mathscr{ep}(\mathscr{slot}(\alpha)))$</math-renderer></p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/93d20927efbdcd5e9b47a026100dbd61d9a24ee4c8f2e6368accc3072108c6cf/68747470733a2f2f73746f726167652e676f6f676c65617069732e636f6d2f657468657265756d2d6861636b6d642f75706c6f61645f30666435313964306638376634303830663166653735623733653435383330622e706e67"><img src="https://camo.githubusercontent.com/93d20927efbdcd5e9b47a026100dbd61d9a24ee4c8f2e6368accc3072108c6cf/68747470733a2f2f73746f726167652e676f6f676c65617069732e636f6d2f657468657265756d2d6861636b6d642f75706c6f61645f30666435313964306638376634303830663166653735623733653435383330622e706e67" alt="" data-canonical-src="https://storage.googleapis.com/ethereum-hackmd/upload_0fd519d0f87f4080f1fe75b73e45830b.png"/></a></p>
<p dir="auto">A validator’s view <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$G$</math-renderer> as she writes an attestation in epoch <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$3$</math-renderer>. During epoch <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$1$</math-renderer>, latency issues make her not see any blocks, so block <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$64$</math-renderer> is both <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$EBB(193, 1)$</math-renderer> and <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$EBB(193, 2)$</math-renderer>. She ends up writing an attestation <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$\alpha$</math-renderer> with a GHOST vote for <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$\mathscr{block}(\alpha) = 193$</math-renderer> and a FFG vote checkpoint edge (single arc edge) <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$(64,2) \rightarrow (180,3)$</math-renderer> for <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$\alpha$</math-renderer>. Blocks in red are justified (in <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$G$</math-renderer>). Double edges corresponding to supermajority links. Then, <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$LE(\alpha) = (180, 3)$</math-renderer>, even though <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$\mathscr{ep}(180) = 2$</math-renderer>. In <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$\mathscr{ffgview}(193) = \mathscr{view}(180)$</math-renderer>, the last justified (by epoch number, not slot) pair is (64, 2), so <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$LJ(\alpha) = (64, 2)$</math-renderer>.</p>
<p dir="auto">Everything here is analogous to Casper FFG. Inside the chain of <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$\mathscr{block}(\alpha)$</math-renderer> is a sub-chain created by the epoch boundary blocks of that chain, starting from Bgenesis and ending at <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$B = LEBB(\alpha)$</math-renderer>.</p>
<p dir="auto">For a view <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$G$</math-renderer>, a pair <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$(B_0, j)$</math-renderer> is <em>finalized</em> (specifically, <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$k$</math-renderer>-finalized) in <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$G$</math-renderer> if <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$(B_0, j) = (B_{\text{genesis}},0)$</math-renderer> or if there is  an integer <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$k \ge 1$</math-renderer> and blocks <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$B_1,...,B_k \in G$</math-renderer> such that the following holds:</p>
<ul dir="auto">
<li>
<math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$(B_0,j),(B_1,j+1),...,(B_k,j+k)$</math-renderer> are adjacent epoch  boundary pairs in <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$\mathscr{chain}(B_k)$</math-renderer>;</li>
<li>
<math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$(B_0,j),(B_1,j+1),...,(B_{k−1},j+k−1)$</math-renderer> are all in <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$J(G)$</math-renderer>;</li>
<li>
<math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$(B_0,j) \xrightarrow[]{J} (B_k,j+k)$</math-renderer>.</li>
</ul>
<p dir="auto">The set <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$F(G)$</math-renderer> is the set of finalized pairs in the view <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$G$</math-renderer>; a block <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$B$</math-renderer> is finalized if <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$(B,j) \in F(G)$</math-renderer> for some epoch <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$j$</math-renderer>. For the vast majority of time, <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$1$</math-renderer>-finalized (or <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$2$</math-renderer>-finalized) blocks are expected.</p>
<details><summary>Justification and Finalization</summary>
<div data-snippet-clipboard-copy-content="def process_justification_and_finalization(state: BeaconState) -&gt; None:
    # Initial FFG checkpoint values have a `0x00` stub for `root`.
    # Skip FFG updates in the first two epochs to avoid corner cases that might result in modifying this stub.
    if get_current_epoch(state) &lt;= GENESIS_EPOCH + 1:
        return
    previous_indices = get_unslashed_participating_indices(state, TIMELY_TARGET_FLAG_INDEX, get_previous_epoch(state))
    current_indices = get_unslashed_participating_indices(state, TIMELY_TARGET_FLAG_INDEX, get_current_epoch(state))
    total_active_balance = get_total_active_balance(state)
    previous_target_balance = get_total_balance(state, previous_indices)
    current_target_balance = get_total_balance(state, current_indices)
    weigh_justification_and_finalization(state, total_active_balance, previous_target_balance, current_target_balance)"><pre lang="python"><code>def process_justification_and_finalization(state: BeaconState) -&gt; None:
    # Initial FFG checkpoint values have a `0x00` stub for `root`.
    # Skip FFG updates in the first two epochs to avoid corner cases that might result in modifying this stub.
    if get_current_epoch(state) &lt;= GENESIS_EPOCH + 1:
        return
    previous_indices = get_unslashed_participating_indices(state, TIMELY_TARGET_FLAG_INDEX, get_previous_epoch(state))
    current_indices = get_unslashed_participating_indices(state, TIMELY_TARGET_FLAG_INDEX, get_current_epoch(state))
    total_active_balance = get_total_active_balance(state)
    previous_target_balance = get_total_balance(state, previous_indices)
    current_target_balance = get_total_balance(state, current_indices)
    weigh_justification_and_finalization(state, total_active_balance, previous_target_balance, current_target_balance)
</code></pre></div>
<p dir="auto">FFG Casper happens in <code>process_justification_and_finalization</code>.</p>
<p dir="auto"><code>get_unslashed_participating_indices()</code>: returns the validators that made a timely attestation with the type <code>TIMELY_TARGET_FLAG_INDEX</code> during the epoch in question. It is used to calculate the proportion of stake that voted for the candidate checkpoint in the current and previous epochs. Observe that if a validator <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$v_i$</math-renderer> has the flag <code>TIMELY_TARGET_FLAG_INDEX</code> set, it means that a correct source and target have been used in the attestation broadcasted by <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$v_i$</math-renderer>. In other words, if validator <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$v_i$</math-renderer> broadcasts an attestation <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$\alpha$</math-renderer> with correct source <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$s$</math-renderer> and target <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$t$</math-renderer> in epoch <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$n$</math-renderer>, then for epoch <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$n$</math-renderer> validator <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$v_i$</math-renderer> has the flag <code>TIMELY_TARGET_FLAG_INDEX</code>. Moreover, if <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$v_i$</math-renderer> has not been slashed, then the index <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$i$</math-renderer> will be returned by <code>get_unslashed_participating_indices(state, TIMELY_TARGET_FLAG_INDEX, n)</code>;</p>
<p dir="auto"><code>get_total_active_balance(state: BeaconState)</code>: the sum of the <em>effective balances</em> of all active validators in the current epoch (slashed validators are not included);</p>
<p dir="auto"><code>get_total_balance(state: BeaconState, indices: Set[ValidatorIndex])</code>: returns the total balance of all validators in the list <code>indices</code> passed in.</p>
<p dir="auto">The function <code>process_justification_and_finalization</code> takes the lists of unslashed validators in the current and previous epochs, gets their respective total balances, and calculates the sum of the <em>effective balances</em> of all active validators in the current epoch. Then, these aggregate balances are passed to the following function for justification and finalization.</p>
<div data-snippet-clipboard-copy-content="def weigh_justification_and_finalization(state: BeaconState,
                                         total_active_balance: Gwei,
                                         previous_epoch_target_balance: Gwei,
                                         current_epoch_target_balance: Gwei) -&gt; None:
    previous_epoch = get_previous_epoch(state)
    current_epoch = get_current_epoch(state)
    old_previous_justified_checkpoint = state.previous_justified_checkpoint
    old_current_justified_checkpoint = state.current_justified_checkpoint

    # Process justifications
    state.previous_justified_checkpoint = state.current_justified_checkpoint
    state.justification_bits[1:] = state.justification_bits[:JUSTIFICATION_BITS_LENGTH - 1]
    state.justification_bits[0] = 0b0
    if previous_epoch_target_balance * 3 &gt;= total_active_balance * 2:
        state.current_justified_checkpoint = Checkpoint(epoch=previous_epoch,
                                                        root=get_block_root(state, previous_epoch))
        state.justification_bits[1] = 0b1
    if current_epoch_target_balance * 3 &gt;= total_active_balance * 2:
        state.current_justified_checkpoint = Checkpoint(epoch=current_epoch,
                                                        root=get_block_root(state, current_epoch))
        state.justification_bits[0] = 0b1

    # Process finalizations
    bits = state.justification_bits
    # The 2nd/3rd/4th most recent epochs are justified, the 2nd using the 4th as source
    if all(bits[1:4]) and old_previous_justified_checkpoint.epoch + 3 == current_epoch:
        state.finalized_checkpoint = old_previous_justified_checkpoint
    # The 2nd/3rd most recent epochs are justified, the 2nd using the 3rd as source
    if all(bits[1:3]) and old_previous_justified_checkpoint.epoch + 2 == current_epoch:
        state.finalized_checkpoint = old_previous_justified_checkpoint
    # The 1st/2nd/3rd most recent epochs are justified, the 1st using the 3rd as source
    if all(bits[0:3]) and old_current_justified_checkpoint.epoch + 2 == current_epoch:
        state.finalized_checkpoint = old_current_justified_checkpoint
    # The 1st/2nd most recent epochs are justified, the 1st using the 2nd as source
    if all(bits[0:2]) and old_current_justified_checkpoint.epoch + 1 == current_epoch:
        state.finalized_checkpoint = old_current_justified_checkpoint"><pre lang="python"><code>def weigh_justification_and_finalization(state: BeaconState,
                                         total_active_balance: Gwei,
                                         previous_epoch_target_balance: Gwei,
                                         current_epoch_target_balance: Gwei) -&gt; None:
    previous_epoch = get_previous_epoch(state)
    current_epoch = get_current_epoch(state)
    old_previous_justified_checkpoint = state.previous_justified_checkpoint
    old_current_justified_checkpoint = state.current_justified_checkpoint

    # Process justifications
    state.previous_justified_checkpoint = state.current_justified_checkpoint
    state.justification_bits[1:] = state.justification_bits[:JUSTIFICATION_BITS_LENGTH - 1]
    state.justification_bits[0] = 0b0
    if previous_epoch_target_balance * 3 &gt;= total_active_balance * 2:
        state.current_justified_checkpoint = Checkpoint(epoch=previous_epoch,
                                                        root=get_block_root(state, previous_epoch))
        state.justification_bits[1] = 0b1
    if current_epoch_target_balance * 3 &gt;= total_active_balance * 2:
        state.current_justified_checkpoint = Checkpoint(epoch=current_epoch,
                                                        root=get_block_root(state, current_epoch))
        state.justification_bits[0] = 0b1

    # Process finalizations
    bits = state.justification_bits
    # The 2nd/3rd/4th most recent epochs are justified, the 2nd using the 4th as source
    if all(bits[1:4]) and old_previous_justified_checkpoint.epoch + 3 == current_epoch:
        state.finalized_checkpoint = old_previous_justified_checkpoint
    # The 2nd/3rd most recent epochs are justified, the 2nd using the 3rd as source
    if all(bits[1:3]) and old_previous_justified_checkpoint.epoch + 2 == current_epoch:
        state.finalized_checkpoint = old_previous_justified_checkpoint
    # The 1st/2nd/3rd most recent epochs are justified, the 1st using the 3rd as source
    if all(bits[0:3]) and old_current_justified_checkpoint.epoch + 2 == current_epoch:
        state.finalized_checkpoint = old_current_justified_checkpoint
    # The 1st/2nd most recent epochs are justified, the 1st using the 2nd as source
    if all(bits[0:2]) and old_current_justified_checkpoint.epoch + 1 == current_epoch:
        state.finalized_checkpoint = old_current_justified_checkpoint
</code></pre></div>
<p dir="auto">Given a <code>BeaconState</code>, the function <code>weigh_justification_and_finalization</code> first handles the justification, and then the finalization.</p>
<p dir="auto">Recall that the <code>justification_bits</code> record contained in the <code>BeaconState</code> is used to keep track of the justification status of the last four epochs: <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$1$</math-renderer> if justified, <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$0$</math-renderer> if not. For example, if we are in epoch <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$7$</math-renderer>, then <code>state.justification_bits[0]</code> represents the justification state of epoch <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$7$</math-renderer> and <code>state.justification_bits[3]=1</code> means that epoch <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$4$</math-renderer> is justified, i.e., that at least <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$\frac{2}{3}$</math-renderer> of the validators cast a vote <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$⟨v_i, a, b, h(a), h(b)⟩$</math-renderer> with (a justified) checkpoint <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$a$</math-renderer> and an epoch boundary block <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$b$</math-renderer> for epoch <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$4$</math-renderer>.</p>
<p dir="auto">In particular, in the first part (# Process justifications), given the balances of the previous and the current epochs (i.e., the total amount of deposits of the active validators that cast a vote in the previous and current epochs), the two <code>if</code> statements try to justify the previous and the current epoch&#39;s checkpoints, respectively. If both the <code>if</code> statements return true, then before the finalization process starts we have <code>state.justification_bits[0]=state.justification_bits[1]=1</code>.</p>
<p dir="auto">For the second part, (# Process finalizations), observe that a <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$2$</math-renderer>-finalization rule is used. In particular, for a view <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$G$</math-renderer>, a pair <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$(B_0, j)$</math-renderer> is <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$2$</math-renderer>-finalized in <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$G$</math-renderer> if <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$(B_0, j) = (B_{\text{genesis}},0)$</math-renderer> or if there are two blocks <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$B_1, B_2 \in G$</math-renderer> such that the following holds:</p>
<ul dir="auto">
<li>
<math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$(B_0,j),(B_1,j+1),(B_2,j+2)$</math-renderer> are adjacent epoch boundary pairs in <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$\mathscr{chain}(B_2)$</math-renderer>;</li>
<li>
<math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$(B_0,j),(B_1,j+1)$</math-renderer> are all in <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$J(G)$</math-renderer>;</li>
<li>
<math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$(B_0,j) \xrightarrow[]{J} (B_2,j+2)$</math-renderer>.</li>
</ul>
<p dir="auto">In <code>weigh_justification_and_finalization</code>,</p>
<ul dir="auto">
<li>the first condition reflects on requiring that <code>old_previous_justified_checkpoint.epoch + 3 == current_epoch</code> and <code>old_previous_justified_checkpoint.epoch + 2 == current_epoch</code>;</li>
<li>the second condition reflects on requiring that <code>state.justification_bits[3]=state.justification_bits[2]=1</code>; and</li>
<li>the third condition reflects on requiring that <code>state.justification_bits[1]=1</code>. In particular, if <code>state.justification_bits[0]=state.justification_bits[1]=1</code> (from the justification process above) and if <code>state.justification_bits[3]=state.justification_bits[2]=1</code>, then the existence of supermajority links is implied.</li>
</ul>
</details>
<p dir="auto">We can now finally present HLMD-GHOST, a variation of LMD-GHOST. In this variation, the protocol freezes the state of the latest justified pair <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$(B_J , j)$</math-renderer> to the beginning of the epochs; formally, this means when defining <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$(B_J , j)$</math-renderer> the protocol considers the views of <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$\mathscr{ffgview}(B_l)$</math-renderer> over the leaf blocks <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$B_l$</math-renderer>. Then, it filters the branches so one does not go down branches with leaf nodes <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$B_l$</math-renderer> where <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$LJ(B_l)$</math-renderer> has not <em>caught up</em> to <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$(B_J,j)$</math-renderer>; formally, an auxiliary view <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$G&#39;$</math-renderer> from <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$G$</math-renderer> is created. This filtering prevents scenarios in which, when the algorithm forks, forked blocks have different last justified pairs. In fact, if this happened and no filtering was applied, if a validator <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$v_i$</math-renderer> that previously attested to a higher last justification epoch forks into a chain whose last justification epoch is older, then <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$v_i$</math-renderer> may end up slashing itself (see just below).</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/b421678c5d22cba6a5af5b290337d931f177354088a2d1643a863980f5e1e15b/68747470733a2f2f73746f726167652e676f6f676c65617069732e636f6d2f657468657265756d2d6861636b6d642f75706c6f61645f35376339373166366234653035353739373039313064633365656634383661372e706e67"><img src="https://camo.githubusercontent.com/b421678c5d22cba6a5af5b290337d931f177354088a2d1643a863980f5e1e15b/68747470733a2f2f73746f726167652e676f6f676c65617069732e636f6d2f657468657265756d2d6861636b6d642f75706c6f61645f35376339373166366234653035353739373039313064633365656634383661372e706e67" alt="" data-canonical-src="https://storage.googleapis.com/ethereum-hackmd/upload_57c971f6b4e0557970910dc3eef486a7.png"/></a></p>
<p dir="auto">One can think of each chain of a leaf block <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$B_l$</math-renderer> as storing the state of its own last justified pair. During an epoch, new attestations to blocks in the chain updates the GHOST-relevant list of latest attestations <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$M$</math-renderer> but not the FFG-relevant justification and finalization information of the chain until the next epoch boundary block. This way, the <em>FFG part</em> of the protocol always works with the <em>frozen until next epoch</em> information, while the <em>GHOST part</em> of the protocol is being updated continuously with the attestations.</p>
<details><summary>Fork Choice</summary>
<p dir="auto">The fork choice is implemented through a <code>store</code> object that contains received fork-choice-relevant information, and a function <code>get_head(store)</code>.</p>
<div data-snippet-clipboard-copy-content="@dataclass
class Store(object):
    time: uint64
    genesis_time: uint64
    justified_checkpoint: Checkpoint
    finalized_checkpoint: Checkpoint
    best_justified_checkpoint: Checkpoint
    proposer_boost_root: Root
    equivocating_indices: Set[ValidatorIndex]
    blocks: Dict[Root, BeaconBlock] = field(default_factory=dict)
    block_states: Dict[Root, BeaconState] = field(default_factory=dict)
    checkpoint_states: Dict[Checkpoint, BeaconState] = field(default_factory=dict)
    latest_messages: Dict[ValidatorIndex, LatestMessage] = field(default_factory=dict)"><pre lang="python"><code>@dataclass
class Store(object):
    time: uint64
    genesis_time: uint64
    justified_checkpoint: Checkpoint
    finalized_checkpoint: Checkpoint
    best_justified_checkpoint: Checkpoint
    proposer_boost_root: Root
    equivocating_indices: Set[ValidatorIndex]
    blocks: Dict[Root, BeaconBlock] = field(default_factory=dict)
    block_states: Dict[Root, BeaconState] = field(default_factory=dict)
    checkpoint_states: Dict[Checkpoint, BeaconState] = field(default_factory=dict)
    latest_messages: Dict[ValidatorIndex, LatestMessage] = field(default_factory=dict)
</code></pre></div>
<p dir="auto">The records here are as it follows.</p>
<p dir="auto"><code>time</code>: the current time;</p>
<p dir="auto"><code>genesis_time</code>: the time of the genesis block of the chain;</p>
<p dir="auto"><code>justified_checkpoint</code>: the FFG-Casper-justified checkpoint that is used as the root of the HLMD-GHOST fork choice;</p>
<p dir="auto"><code>finalized_checkpoint</code>: the last finalized checkpoint;</p>
<p dir="auto"><code>best_justified_checkpoint</code>: the justified checkpoint that we will switch to at the start of the next epoch;</p>
<p dir="auto"><code>proposer_boost_root</code>:  a special <code>LatestMessage</code> that stores the boost [<a data-error-text="Failed to load title" data-id="1058905734" data-permission-text="Title is private" data-url="https://github.com/ethereum/consensus-specs/issues/2730" data-hovercard-type="pull_request" data-hovercard-url="/ethereum/consensus-specs/pull/2730/hovercard" href="https://github.com/ethereum/consensus-specs/pull/2730">ethereum/consensus-specs#2730</a>] (see the section on <em>Proposer Weight Boosting</em>);</p>
<p dir="auto"><code>equivocating_indices</code>: list of validators that equivocated, i.e., cast contradictory votes [<a data-error-text="Failed to load title" data-id="1155756828" data-permission-text="Title is private" data-url="https://github.com/ethereum/consensus-specs/issues/2845" data-hovercard-type="pull_request" data-hovercard-url="/ethereum/consensus-specs/pull/2845/hovercard" href="https://github.com/ethereum/consensus-specs/pull/2845">ethereum/consensus-specs#2845</a>] (see the section on <em>Equivocation Discounting</em>);</p>
<p dir="auto"><code>blocks</code>: all blocks that we know about;</p>
<p dir="auto"><code>block_states</code>: the post-state of every block that we know about;</p>
<p dir="auto"><code>checkpoint_states</code>: the post-state of every checkpoint. This could be different from the post-state of the block referenced by the checkpoint in the case where there are skipped slots;</p>
<p dir="auto"><code>latest_messages</code>: the latest epoch and block voted for by each validator;</p>
<p dir="auto">At genesis, let <code>store = get_forkchoice_store(genesis_state)</code> and update store by running:</p>
<p dir="auto">(i)</p>
<div data-snippet-clipboard-copy-content="def on_tick(store: Store, time: uint64) -&gt; None:
    previous_slot = get_current_slot(store)

    # update store time
    store.time = time

    current_slot = get_current_slot(store)

    # Reset store.proposer_boost_root if this is a new slot
    if current_slot &gt; previous_slot:
        store.proposer_boost_root = Root()

    # Not a new epoch, return
    if not (current_slot &gt; previous_slot and compute_slots_since_epoch_start(current_slot) == 0):
        return

    # Update store.justified_checkpoint if a better checkpoint on the store.finalized_checkpoint chain
    if store.best_justified_checkpoint.epoch &gt; store.justified_checkpoint.epoch:
        finalized_slot = compute_start_slot_at_epoch(store.finalized_checkpoint.epoch)    
        ancestor_at_finalized_slot = get_ancestor(store, store.best_justified_checkpoint.root, finalized_slot)
        if ancestor_at_finalized_slot == store.finalized_checkpoint.root:
            store.justified_checkpoint = store.best_justified_checkpoint"><pre lang="python"><code>def on_tick(store: Store, time: uint64) -&gt; None:
    previous_slot = get_current_slot(store)

    # update store time
    store.time = time

    current_slot = get_current_slot(store)

    # Reset store.proposer_boost_root if this is a new slot
    if current_slot &gt; previous_slot:
        store.proposer_boost_root = Root()

    # Not a new epoch, return
    if not (current_slot &gt; previous_slot and compute_slots_since_epoch_start(current_slot) == 0):
        return

    # Update store.justified_checkpoint if a better checkpoint on the store.finalized_checkpoint chain
    if store.best_justified_checkpoint.epoch &gt; store.justified_checkpoint.epoch:
        finalized_slot = compute_start_slot_at_epoch(store.finalized_checkpoint.epoch)    
        ancestor_at_finalized_slot = get_ancestor(store, store.best_justified_checkpoint.root, finalized_slot)
        if ancestor_at_finalized_slot == store.finalized_checkpoint.root:
            store.justified_checkpoint = store.best_justified_checkpoint
</code></pre></div>
<p dir="auto">This function runs on each tick. At the end of each epoch, update the justified checkpoint used in the fork choice;</p>
<p dir="auto">(ii)</p>
<div data-snippet-clipboard-copy-content="def on_attestation(store: Store, attestation: Attestation) -&gt; None:
    &#34;&#34;&#34;
    Run ``on_attestation`` upon receiving a new ``attestation`` from either within a block or directly on the wire.

    An ``attestation`` that is asserted as invalid may be valid at a later time,
    consider scheduling it for later processing in such case.
    &#34;&#34;&#34;
    validate_on_attestation(store, attestation)
    store_target_checkpoint_state(store, attestation.data.target)

    # Get state at the `target` to fully validate attestation
    target_state = store.checkpoint_states[attestation.data.target]
    indexed_attestation = get_indexed_attestation(target_state, attestation)
    assert is_valid_indexed_attestation(target_state, indexed_attestation)

    # Update latest messages for attesting indices
    update_latest_messages(store, indexed_attestation.attesting_indices, attestation)"><pre lang="python"><code>def on_attestation(store: Store, attestation: Attestation) -&gt; None:
    &#34;&#34;&#34;
    Run ``on_attestation`` upon receiving a new ``attestation`` from either within a block or directly on the wire.

    An ``attestation`` that is asserted as invalid may be valid at a later time,
    consider scheduling it for later processing in such case.
    &#34;&#34;&#34;
    validate_on_attestation(store, attestation)
    store_target_checkpoint_state(store, attestation.data.target)

    # Get state at the `target` to fully validate attestation
    target_state = store.checkpoint_states[attestation.data.target]
    indexed_attestation = get_indexed_attestation(target_state, attestation)
    assert is_valid_indexed_attestation(target_state, indexed_attestation)

    # Update latest messages for attesting indices
    update_latest_messages(store, indexed_attestation.attesting_indices, attestation)
</code></pre></div>
<p dir="auto">This function runs whenever an attestation attestation is received; and</p>
<p dir="auto">(iii)</p>
<div data-snippet-clipboard-copy-content="def on_block(store: Store, signed_block: SignedBeaconBlock) -&gt; None:
    &#34;&#34;&#34;
    Run ``on_block`` upon receiving a new block.

    A block that is asserted as invalid due to unavailable PoW block may be valid at a later time,
    consider scheduling it for later processing in such case.
    &#34;&#34;&#34;
    block = signed_block.message
    # Parent block must be known
    assert block.parent_root in store.block_states
    # Make a copy of the state to avoid mutability issues
    pre_state = copy(store.block_states[block.parent_root])
    # Blocks cannot be in the future. If they are, their consideration must be delayed until they are in the past.
    assert get_current_slot(store) &gt;= block.slot

    # Check that block is later than the finalized epoch slot (optimization to reduce calls to get_ancestor)
    finalized_slot = compute_start_slot_at_epoch(store.finalized_checkpoint.epoch)
    assert block.slot &gt; finalized_slot
    # Check block is a descendant of the finalized block at the checkpoint finalized slot
    assert get_ancestor(store, block.parent_root, finalized_slot) == store.finalized_checkpoint.root

    # Check the block is valid and compute the post-state
    state = pre_state.copy()
    state_transition(state, signed_block, True)

    # [New in Bellatrix]
    if is_merge_transition_block(pre_state, block.body):
        validate_merge_block(block)

    # Add new block to the store
    store.blocks[hash_tree_root(block)] = block
    # Add new state for this block to the store
    store.block_states[hash_tree_root(block)] = state

    # Add proposer score boost if the block is timely
    time_into_slot = (store.time - store.genesis_time) % SECONDS_PER_SLOT
    is_before_attesting_interval = time_into_slot &lt; SECONDS_PER_SLOT // INTERVALS_PER_SLOT
    if get_current_slot(store) == block.slot and is_before_attesting_interval:
        store.proposer_boost_root = hash_tree_root(block)

    # Update justified checkpoint
    if state.current_justified_checkpoint.epoch &gt; store.justified_checkpoint.epoch:
        if state.current_justified_checkpoint.epoch &gt; store.best_justified_checkpoint.epoch:
            store.best_justified_checkpoint = state.current_justified_checkpoint
        if should_update_justified_checkpoint(store, state.current_justified_checkpoint):
            store.justified_checkpoint = state.current_justified_checkpoint

    # Update finalized checkpoint
    if state.finalized_checkpoint.epoch &gt; store.finalized_checkpoint.epoch:
        store.finalized_checkpoint = state.finalized_checkpoint
        store.justified_checkpoint = state.current_justified_checkpoint"><pre lang="python"><code>def on_block(store: Store, signed_block: SignedBeaconBlock) -&gt; None:
    &#34;&#34;&#34;
    Run ``on_block`` upon receiving a new block.

    A block that is asserted as invalid due to unavailable PoW block may be valid at a later time,
    consider scheduling it for later processing in such case.
    &#34;&#34;&#34;
    block = signed_block.message
    # Parent block must be known
    assert block.parent_root in store.block_states
    # Make a copy of the state to avoid mutability issues
    pre_state = copy(store.block_states[block.parent_root])
    # Blocks cannot be in the future. If they are, their consideration must be delayed until they are in the past.
    assert get_current_slot(store) &gt;= block.slot

    # Check that block is later than the finalized epoch slot (optimization to reduce calls to get_ancestor)
    finalized_slot = compute_start_slot_at_epoch(store.finalized_checkpoint.epoch)
    assert block.slot &gt; finalized_slot
    # Check block is a descendant of the finalized block at the checkpoint finalized slot
    assert get_ancestor(store, block.parent_root, finalized_slot) == store.finalized_checkpoint.root

    # Check the block is valid and compute the post-state
    state = pre_state.copy()
    state_transition(state, signed_block, True)

    # [New in Bellatrix]
    if is_merge_transition_block(pre_state, block.body):
        validate_merge_block(block)

    # Add new block to the store
    store.blocks[hash_tree_root(block)] = block
    # Add new state for this block to the store
    store.block_states[hash_tree_root(block)] = state

    # Add proposer score boost if the block is timely
    time_into_slot = (store.time - store.genesis_time) % SECONDS_PER_SLOT
    is_before_attesting_interval = time_into_slot &lt; SECONDS_PER_SLOT // INTERVALS_PER_SLOT
    if get_current_slot(store) == block.slot and is_before_attesting_interval:
        store.proposer_boost_root = hash_tree_root(block)

    # Update justified checkpoint
    if state.current_justified_checkpoint.epoch &gt; store.justified_checkpoint.epoch:
        if state.current_justified_checkpoint.epoch &gt; store.best_justified_checkpoint.epoch:
            store.best_justified_checkpoint = state.current_justified_checkpoint
        if should_update_justified_checkpoint(store, state.current_justified_checkpoint):
            store.justified_checkpoint = state.current_justified_checkpoint

    # Update finalized checkpoint
    if state.finalized_checkpoint.epoch &gt; store.finalized_checkpoint.epoch:
        store.finalized_checkpoint = state.finalized_checkpoint
        store.justified_checkpoint = state.current_justified_checkpoint
</code></pre></div>
<p dir="auto">This function runs whenever a <code>SignedBeaconBlock</code> is received.</p>
<p dir="auto">Any of the above handlers that trigger an unhandled exception are considered invalid. Invalid calls to handlers must not modify <code>store</code>.</p>
<p dir="auto">Observe that <code>best_justified_checkpoint</code> is stored to prevend an attack on FFG Casper [<a href="https://ethresear.ch/t/analysis-of-bouncing-attack-on-ffg/6113" rel="nofollow">https://ethresear.ch/t/analysis-of-bouncing-attack-on-ffg/6113</a>]. In particular, <code>on_block</code> uses the following function.</p>
<div data-snippet-clipboard-copy-content="def should_update_justified_checkpoint(store: Store, new_justified_checkpoint: Checkpoint) -&gt; bool:
    &#34;&#34;&#34;
    To address the bouncing attack, only update conflicting justified
    checkpoints in the fork choice if in the early slots of the epoch.
    Otherwise, delay incorporation of new justified checkpoint until next epoch boundary.

    See https://ethresear.ch/t/prevention-of-bouncing-attack-on-ffg/6114 for more detailed analysis and discussion.
    &#34;&#34;&#34;
    if compute_slots_since_epoch_start(get_current_slot(store)) &lt; SAFE_SLOTS_TO_UPDATE_JUSTIFIED:
        return True

    justified_slot = compute_start_slot_at_epoch(store.justified_checkpoint.epoch)
    if not get_ancestor(store, new_justified_checkpoint.root, justified_slot) == store.justified_checkpoint.root:
        return False

    return True
"><pre lang="python"><code>def should_update_justified_checkpoint(store: Store, new_justified_checkpoint: Checkpoint) -&gt; bool:
    &#34;&#34;&#34;
    To address the bouncing attack, only update conflicting justified
    checkpoints in the fork choice if in the early slots of the epoch.
    Otherwise, delay incorporation of new justified checkpoint until next epoch boundary.

    See https://ethresear.ch/t/prevention-of-bouncing-attack-on-ffg/6114 for more detailed analysis and discussion.
    &#34;&#34;&#34;
    if compute_slots_since_epoch_start(get_current_slot(store)) &lt; SAFE_SLOTS_TO_UPDATE_JUSTIFIED:
        return True

    justified_slot = compute_start_slot_at_epoch(store.justified_checkpoint.epoch)
    if not get_ancestor(store, new_justified_checkpoint.root, justified_slot) == store.justified_checkpoint.root:
        return False

    return True

</code></pre></div>
<p dir="auto"><em>The idea here is that we want to only change the last-justified-block within the first $\frac{1}{3}$ of an epoch. This prevents bouncing attacks of the following form.</em> Observe that the following blocks, i.e., <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$A,B,A&#39;,...$</math-renderer>, are EBB in Gasper.</p>
<ul dir="auto">
<li><em>Start from a scenario where in epoch $n$, $62%$ of validators support block $A$, and in epoch $n+1$, $62%$ of validators support a block $B$. Suppose that the attacker has $5%$ of the total stake. This scenario requires very exceptional networking conditions to get into; the point of the attack, however, is that if we get into such a scenario the attacker could perpetuate it, permanently preventing finality.</em></li>
<li><em>Due to LMD-GHOST, $B$ is favored, and so validators are continuing to vote for $B$. However, the attacker suddenly publishes attestations worth $5%$ of the total stake tagged with epoch $n$ for block $A$, causing $A$ to get justified.</em></li>
<li><em>In epoch $n+2$, $A$ is justified and so validators are attesting to $A&#39;$, a descendant of $A$. When $A&#39;$ gets to $62%$ support, the attacker publishes attestations worth $5%$ of total stake tagged with epoch $n+1$ for $B$. Now $B$ is justified and favored by the fork choice.</em></li>
<li><em>In epoch $n+3$, $B$ is justified, and so validators are attesting to $B&#39;$, a descendant of $B$. When $B&#39;$ gets to $62%$ support, the attacker publishes attestations worth $5%$ of total stake tagged with epoch $n+2$ for $A&#39;$, etc.</em></li>
</ul>
<p dir="auto"><em>This could continue forever, bouncing permanently between the two chains preventing any new block from being finalized. This attack can happen because the combined use of LMD-GHOST and FFG Casper creates a discontinuity, where a small shift in support for a block can outweigh a large amount of support for another block if that small shift pushes it past the $\frac{2}{3}$ threshold needed for justification. We block the attack by only allowing the latest justified block to change near the beginning of an epoch; this way, there is a full $\frac{2}{3}$ of an epoch during which honest validators agree on the head and have the opportunity to justify a block and thereby further cement it, at the same time causing the LMD-GHOST rule to strongly favor that head. This sets up that block to most likely be finalized in the next epoch.</em> [<a href="https://github.com/ethereum/annotated-spec/blob/master/phase0/fork-choice.md#should_update_justified_checkpoint">https://github.com/ethereum/annotated-spec/blob/master/phase0/fork-choice.md#should_update_justified_checkpoint</a>]</p>
<p dir="auto">The following function initializes the <code>store</code> given a particular block (the <code>anchor_block</code>) that the fork choice would start from. The provided <code>anchor-state</code> will be regarded as a trusted state.</p>
<div data-snippet-clipboard-copy-content="def get_forkchoice_store(anchor_state: BeaconState, anchor_block: BeaconBlock) -&gt; Store:
    assert anchor_block.state_root == hash_tree_root(anchor_state)
    anchor_root = hash_tree_root(anchor_block)
    anchor_epoch = get_current_epoch(anchor_state)
    justified_checkpoint = Checkpoint(epoch=anchor_epoch, root=anchor_root)
    finalized_checkpoint = Checkpoint(epoch=anchor_epoch, root=anchor_root)
    proposer_boost_root = Root()
    return Store(
        time=uint64(anchor_state.genesis_time + SECONDS_PER_SLOT * anchor_state.slot),
        genesis_time=anchor_state.genesis_time,
        justified_checkpoint=justified_checkpoint,
        finalized_checkpoint=finalized_checkpoint,
        best_justified_checkpoint=justified_checkpoint,
        proposer_boost_root=proposer_boost_root,
        equivocating_indices=set(),
        blocks={anchor_root: copy(anchor_block)},
        block_states={anchor_root: copy(anchor_state)},
        checkpoint_states={justified_checkpoint: copy(anchor_state)},
    )"><pre lang="python"><code>def get_forkchoice_store(anchor_state: BeaconState, anchor_block: BeaconBlock) -&gt; Store:
    assert anchor_block.state_root == hash_tree_root(anchor_state)
    anchor_root = hash_tree_root(anchor_block)
    anchor_epoch = get_current_epoch(anchor_state)
    justified_checkpoint = Checkpoint(epoch=anchor_epoch, root=anchor_root)
    finalized_checkpoint = Checkpoint(epoch=anchor_epoch, root=anchor_root)
    proposer_boost_root = Root()
    return Store(
        time=uint64(anchor_state.genesis_time + SECONDS_PER_SLOT * anchor_state.slot),
        genesis_time=anchor_state.genesis_time,
        justified_checkpoint=justified_checkpoint,
        finalized_checkpoint=finalized_checkpoint,
        best_justified_checkpoint=justified_checkpoint,
        proposer_boost_root=proposer_boost_root,
        equivocating_indices=set(),
        blocks={anchor_root: copy(anchor_block)},
        block_states={anchor_root: copy(anchor_state)},
        checkpoint_states={justified_checkpoint: copy(anchor_state)},
    )
</code></pre></div>
<p dir="auto">Finally, the main fork choice function is given by the following.</p>
<div data-snippet-clipboard-copy-content="def get_head(store: Store) -&gt; Root:
    # Get filtered block tree that only includes viable branches
    blocks = get_filtered_block_tree(store)
    # Execute the LMD-GHOST fork choice
    head = store.justified_checkpoint.root
    while True:
        children = [
            root for root in blocks.keys()
            if blocks[root].parent_root == head
        ]
        if len(children) == 0:
            return head
        # Sort by latest attesting balance with ties broken lexicographically
        # Ties broken by favoring block with lexicographically higher root
        head = max(children, key=lambda root: (get_latest_attesting_balance(store, root), root))"><pre lang="python"><code>def get_head(store: Store) -&gt; Root:
    # Get filtered block tree that only includes viable branches
    blocks = get_filtered_block_tree(store)
    # Execute the LMD-GHOST fork choice
    head = store.justified_checkpoint.root
    while True:
        children = [
            root for root in blocks.keys()
            if blocks[root].parent_root == head
        ]
        if len(children) == 0:
            return head
        # Sort by latest attesting balance with ties broken lexicographically
        # Ties broken by favoring block with lexicographically higher root
        head = max(children, key=lambda root: (get_latest_attesting_balance(store, root), root))
</code></pre></div>
<p dir="auto">The function <code>get_head</code> returns the head of the chain. <em>This follows the following procedure:</em></p>
<ul dir="auto">
<li>
<em>Get the latest justified block hash, call it $B$ (this is implicit in <code>get_filtered_block_tree</code>)</em>;</li>
<li>
<em>Get the subtree of blocks rooted in $B$ (done by <code>get_filtered_block_tree</code>)</em>;</li>
<li>
<em>Filter that for blocks whose slot exceeds the slot of $B$</em>;</li>
<li>
<em>Walk down the tree, at each step where a block has multiple children selecting the child with the strongest support i.e., higher <code>get_latest_attesting_balance</code></em> [<a href="https://github.com/ethereum/annotated-spec/blob/master/phase0/fork-choice.md#get_head">https://github.com/ethereum/annotated-spec/blob/master/phase0/fork-choice.md#get_head</a>]</li>
</ul>
</details>
<p dir="auto">Finally, as showed with FFG Casper, in Gasper validators must not make two distinct attestations <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$\alpha_1$</math-renderer> and <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$\alpha_2$</math-renderer> with <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$\mathscr{ep}(\mathscr{slot}(\alpha_1)))=\mathscr{ep}(\mathscr{slot}(\alpha_2)))$</math-renderer> and must not make two disting attestations <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$\alpha_1$</math-renderer> and <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$\alpha_2$</math-renderer> with <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$$\mathscr{aep}(LJ(\alpha_1)) &amp;lt; \mathscr{aep}(LJ(\alpha_2)) &amp;lt; \mathscr{aep}(LE(\alpha_2)) &amp;lt; \mathscr{aep}(LE(\alpha_1)).$$</math-renderer></p>
<details><summary>Slashing</summary>
<div dir="auto" data-snippet-clipboard-copy-content="def is_slashable_attestation_data(data_1: AttestationData, data_2: AttestationData) -&gt; bool:
    &#34;&#34;&#34;
    Check if ``data_1`` and ``data_2`` are slashable according to Casper FFG rules.
    &#34;&#34;&#34;
    return (
        # Double vote
        (data_1 != data_2 and data_1.target.epoch == data_2.target.epoch) or
        # Surround vote
        (data_1.source.epoch &lt; data_2.source.epoch and data_2.target.epoch &lt; data_1.target.epoch)
    )"><pre><span>def</span> <span>is_slashable_attestation_data</span>(<span>data_1</span>: <span>AttestationData</span>, <span>data_2</span>: <span>AttestationData</span>) <span>-&gt;</span> <span>bool</span>:
    <span>&#34;&#34;&#34;</span>
<span>    Check if ``data_1`` and ``data_2`` are slashable according to Casper FFG rules.</span>
<span>    &#34;&#34;&#34;</span>
    <span>return</span> (
        <span># Double vote</span>
        (<span>data_1</span> <span>!=</span> <span>data_2</span> <span>and</span> <span>data_1</span>.<span>target</span>.<span>epoch</span> <span>==</span> <span>data_2</span>.<span>target</span>.<span>epoch</span>) <span>or</span>
        <span># Surround vote</span>
        (<span>data_1</span>.<span>source</span>.<span>epoch</span> <span>&lt;</span> <span>data_2</span>.<span>source</span>.<span>epoch</span> <span>and</span> <span>data_2</span>.<span>target</span>.<span>epoch</span> <span>&lt;</span> <span>data_1</span>.<span>target</span>.<span>epoch</span>)
    )</pre></div>
</details>
<p dir="auto">If a validator violates either condition, the evidence of the violation can be observed, at which point the validator’s deposit is slashed with a reward given to the submitter of the evidence transaction.</p>
<details><summary>More on Slashing</summary>
<div dir="auto" data-snippet-clipboard-copy-content="class ProposerSlashing(Container):
    signed_header_1: SignedBeaconBlockHeader
    signed_header_2: SignedBeaconBlockHeader"><pre><span>class</span> <span>ProposerSlashing</span>(<span>Container</span>):
    <span>signed_header_1</span>: <span>SignedBeaconBlockHeader</span>
    <span>signed_header_2</span>: <span>SignedBeaconBlockHeader</span></pre></div>
<div dir="auto" data-snippet-clipboard-copy-content="class AttesterSlashing(Container):
    attestation_1: IndexedAttestation
    attestation_2: IndexedAttestation"><pre><span>class</span> <span>AttesterSlashing</span>(<span>Container</span>):
    <span>attestation_1</span>: <span>IndexedAttestation</span>
    <span>attestation_2</span>: <span>IndexedAttestation</span></pre></div>
</details>
<h3 dir="auto"><a id="user-content-properties-of-gasper" aria-hidden="true" href="#properties-of-gasper"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Properties of Gasper</h3>
<p dir="auto">In this section we present the properties that Gasper <em>should</em> satisfy as a consensus protocol, following the formalization introduced by <a href="https://arxiv.org/pdf/2009.04987.pdf" rel="nofollow">Neu <em>et al.</em></a></p>
<p dir="auto">However, due to some discovered attacks (that will be presented in the following sections), these properties are not guaranteed in the original version of Gasper, i.e., the version presented above.</p>
<p dir="auto">The goal of a consensus protocol is to allow all participants to reach a common decision despite the presence of faulty ones. In our context, this translates into allowing honest validators to grow a chain that is finalized and where all blocks consistute consistent state transitions with each other. Here we assume validators being Byzantine, being potentially offline, or suffering latency problems. In other terms, this translates to the following properties.</p>
<ul dir="auto">
<li>
<strong>Safety</strong>: If the set of finalized blocks <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$F(G)$</math-renderer> for any view <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$G$</math-renderer> can never contain two conflicting blocks.</li>
<li>
<strong>Liveness</strong>: If the set of finalized blocks can actually grow.</li>
</ul>
<h4 dir="auto"><a id="user-content-availability-finality-dilemma" aria-hidden="true" href="#availability-finality-dilemma"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Availability-Finality Dilemma</h4>
<p dir="auto">A novelty that blockchains have introduced is the notion of <em>dynamically available</em> protocols, i.e., consensus protocols that can support an unknown and variable number of participants.
One limitation of these protocols is that they are not tolerant to network partitions. In particular, when the network partitions, honest participants in a dynamically available protocol will think that many participants are asleep and keep confirming transactions, potentially leading to safety violations. A different approach is instead taken by standard permissioned BFT protocols such as PBFT or HotStuff. These are designed for partially synchronous networks, and a quorum of at least two-thirds of all the participants is required to finalize transactions, ensuring safety under network partition, but not liveness. Liveness is guaranteed only after GST. It is <em>impossible</em> for any consensus protocol to be both safe under network partition and live under dynamic participation.</p>
<p dir="auto">In other words, <em>the availability-finality dilemma says that there cannot be a consensus protocol for state-machine replication, one that outputs a single ledger, that provides both properties. The next best thing is then to ask for a protocol with two confirmation rules that outputs two ledgers, one that provides availability under dynamic participation, and one that provides finality even under network partitions, and in the long run they should agree on a common account of history.</em> [<a href="https://decentralizedthoughts.github.io/2020-11-01-ebb-and-flow-protocols-a-resolution-of-the-availability-finality-dilemma/" rel="nofollow">https://decentralizedthoughts.github.io/2020-11-01-ebb-and-flow-protocols-a-resolution-of-the-availability-finality-dilemma/</a>]</p>
<p dir="auto">Based on this observation, Neu <em>et al.</em> gave a formalization of the properties that Gasper, according to its design goals, should satisfy. In particular, given the time model described at the beginning of this document, they define the notion of <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$(\beta_1,\beta_2)$</math-renderer><em>-secure ebb-and-flow protocol</em> to be a protocol that outputs an available ledger <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$𝖫𝖮𝖦_{\text{da}}$</math-renderer> and a finalized ledger <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$𝖫𝖮𝖦_{\text{fin}}$</math-renderer> satisfying the following properties:</p>
<ul dir="auto">
<li>
<strong>Finality</strong>: The finalized ledger <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$𝖫𝖮𝖦_{\text{fin}}$</math-renderer> is guaranteed to be accountable safe (in the event of a safety violation, one can provably identify Byzantine validators that have violated the protocol) at all times, and live after <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$\max{𝖦𝖲𝖳,𝖦𝖠𝖳}$</math-renderer>, provided that fewer than <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$\beta_1$</math-renderer> proportion of all the nodes are adversarial.</li>
<li>
<strong>Dynamic Availability</strong>: If <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$𝖦𝖲𝖳=0$</math-renderer>, i.e., if the network is synchronous, the available ledger <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$𝖫𝖮𝖦_{\text{da}}$</math-renderer> is guaranteed to be safe and live at all times, provided that at all times fewer than <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$\beta_2$</math-renderer> proportion of the awake nodes are adversarial.</li>
<li>
<strong>Prefix</strong>: <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$𝖫𝖮𝖦_{\text{fin}}$</math-renderer> is a prefix of <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$𝖫𝖮𝖦_{\text{da}}$</math-renderer> at all times.</li>
</ul>
<p dir="auto">In the case of Gasper, we want <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$\beta_1 = 33 %$</math-renderer> and <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$\beta_2=50 %.$</math-renderer></p>
<p dir="auto">In other words, <em>together, Finality and Dynamic Availability say that the finalized ledger $𝖫𝖮𝖦_{\text{fin}}$ is safe under network partitions, i.e., before $\max{𝖦𝖲𝖳,𝖦𝖠𝖳}$, and can experience liveness violations before GST or GAT, and afterwards (after validators wake up and the network turns synchronous) catches up with the available ledger $𝖫𝖮𝖦_{\text{da}}$. The Prefix property ensures that eventually all clients, no matter what confirmation rule they follow, will still agree on a single account of history.</em> [<a href="https://decentralizedthoughts.github.io/2020-11-01-ebb-and-flow-protocols-a-resolution-of-the-availability-finality-dilemma/" rel="nofollow">https://decentralizedthoughts.github.io/2020-11-01-ebb-and-flow-protocols-a-resolution-of-the-availability-finality-dilemma/</a>]</p>
<h3 dir="auto"><a id="user-content-weak-subjectivity" aria-hidden="true" href="#weak-subjectivity"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Weak Subjectivity</h3>
<p dir="auto">One of the problems that proof-of-stake consensus protocols have is that they are subject to long-range attacks. In a long-range attack, an adversary corrupts past participants in the consensus protocol in order to re-write the history of the blockchain. The reason why this attack can be placed in a proof-of-stake-based system is because, in such system, the creation of a block is costless, contrary to proof-of-work-based systems where some external resource, e.g., computation, must be spent in order to create a new block.</p>
<p dir="auto">In practice, many proof-of-stake systems deal with long-range attacks by requiring key-evolving cryptography, using more refined chain selection rules, or other techniques. In the case of Ethereum, Gasper deals with long-range attacks through <em>weak subjectivity checkpoints</em>.</p>
<p dir="auto">To understand what a weak subjectivity checkpoint is, we first properly recall the notion of weak subjectivity, as introduced by Buterin in 2014.</p>
<p dir="auto">A consensus protocol can be categorized according to the following paradigms.</p>
<ul dir="auto">
<li><strong>Objective</strong>: <em>a new node coming onto the network with no knowledge except (i) the protocol definition and (ii) the set of all blocks and other important messages that have been published can independently come to the exact same conclusion as the rest of the network on the current state.</em> (This is the case of proof-of-work-based blockchains, such as Bitcoin)</li>
<li><strong>Subjective</strong>: <em>the system has stable states where different nodes come to different conclusions, and a large amount of social information  is required in order to participate.</em> (This is the case of social-network-based blockchains, such as Stellar)</li>
</ul>
<p dir="auto">For proof-of-stake, a third paradigm can be defined.</p>
<ul dir="auto">
<li>
<strong>Weakly subjective</strong>: <em>a new node coming onto the network with no knowledge except (i) the protocol definition, (ii) the set of all blocks and other important messages that have been published and (iii) a state from less than $N$ blocks ago that is known to be valid can independently come to the exact same conclusion as the rest of the network on the current state, unless there is an attacker that permanently has more than $X$ percent control over the consensus set.</em> [<a href="https://blog.ethereum.org/2014/11/25/proof-stake-learned-love-weak-subjectivity" rel="nofollow">https://blog.ethereum.org/2014/11/25/proof-stake-learned-love-weak-subjectivity</a>]</li>
</ul>
<p dir="auto">In other terms, through weak subjectivity it is possible to obtain checkpoints that acts as new genesis block, and we forbid participants from reverting more than <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$N$</math-renderer> blocks. Long-range attacks are then no longer a problem, because long-range forks are declared to be invalid as part of the protocol definition.
These checkpoints are called weak subjectivity checkpoints, and the history of the blockchain <em>before</em> them cannot be reverted, i.e., if a node receives a block conflicting with a weak subjectivity checkpoint, then it immediately rejects that block.</p>
<details><summary>Weak Subjectivity</summary>
<p dir="auto">Any <code>Checkpoint</code> object can be used as a weak subjectivity checkpoint. These are distributed by providers, downloaded by users and/or distributed as a part of clients, and used as input while syncing a client.</p>
<div dir="auto" data-snippet-clipboard-copy-content="
def get_latest_weak_subjectivity_checkpoint_epoch(state, safety_decay=0.1):
    # Returns the epoch of the latest weak subjectivity checkpoint for the given 
    # `state` and `safety_decay`. The default `safety_decay` used should be 10% (= 0.1)
    
    # The calculations in this document do not account for the withdrawability delay.
    # We should factor that in by adding MIN_VALIDATOR_WITHDRAWABILITY_DELAY to the
    # calculated subjectivity period.
    weak_subjectivity_mod = MIN_VALIDATOR_WITHDRAWABILITY_DELAY
    
    val_count = len(get_active_validator_indices(state, get_current_epoch(state)))
    if val_count &gt;= MIN_PER_EPOCH_CHURN_LIMIT * CHURN_LIMIT_QUOTIENT:
        weak_subjectivity_mod += 256 * ((safety_decay*CHURN_LIMIT_QUOTIENT/2) // 256)
    else:
        # This means val_count &lt; MIN_PER_EPOCH_CHURN_LIMIT * CHURN_LIMIT_QUOTIENT
        weak_subjectivity_mod += 256 * ((safety_decay*val_count/(2*MIN_PER_EPOCH_CHURN_LIMIT)) // 256)
    
    return state.finalized_checkpoint.epoch - (state.finalized_checkpoint.epoch % weak_subjectivity_mod)
"><pre><span>def</span> <span>get_latest_weak_subjectivity_checkpoint_epoch</span>(<span>state</span>, <span>safety_decay</span><span>=</span><span>0.1</span>):
    <span># Returns the epoch of the latest weak subjectivity checkpoint for the given </span>
    <span># `state` and `safety_decay`. The default `safety_decay` used should be 10% (= 0.1)</span>
    
    <span># The calculations in this document do not account for the withdrawability delay.</span>
    <span># We should factor that in by adding MIN_VALIDATOR_WITHDRAWABILITY_DELAY to the</span>
    <span># calculated subjectivity period.</span>
    <span>weak_subjectivity_mod</span> <span>=</span> <span>MIN_VALIDATOR_WITHDRAWABILITY_DELAY</span>
    
    <span>val_count</span> <span>=</span> <span>len</span>(<span>get_active_validator_indices</span>(<span>state</span>, <span>get_current_epoch</span>(<span>state</span>)))
    <span>if</span> <span>val_count</span> <span>&gt;=</span> <span>MIN_PER_EPOCH_CHURN_LIMIT</span> <span>*</span> <span>CHURN_LIMIT_QUOTIENT</span>:
        <span>weak_subjectivity_mod</span> <span>+=</span> <span>256</span> <span>*</span> ((<span>safety_decay</span><span>*</span><span>CHURN_LIMIT_QUOTIENT</span><span>/</span><span>2</span>) <span>//</span> <span>256</span>)
    <span>else</span>:
        <span># This means val_count &lt; MIN_PER_EPOCH_CHURN_LIMIT * CHURN_LIMIT_QUOTIENT</span>
        <span>weak_subjectivity_mod</span> <span>+=</span> <span>256</span> <span>*</span> ((<span>safety_decay</span><span>*</span><span>val_count</span><span>/</span>(<span>2</span><span>*</span><span>MIN_PER_EPOCH_CHURN_LIMIT</span>)) <span>//</span> <span>256</span>)
    
    <span>return</span> <span>state</span>.<span>finalized_checkpoint</span>.<span>epoch</span> <span>-</span> (<span>state</span>.<span>finalized_checkpoint</span>.<span>epoch</span> <span>%</span> <span>weak_subjectivity_mod</span>)</pre></div>
</details>
<p dir="auto">Two important notions in the context of weak subjectivity are the following.</p>
<ul dir="auto">
<li>
<strong>Weak subjectivity period</strong>: <em>the number of recent epochs within which there must be a weak subjectivity checkpoint to ensure that an attacker who takes control of the validator set at the beginning of the period is slashed at least a minimum threshold in the event that a conflicting checkpoint is finalized</em>; and</li>
<li>
<strong>Safety decay <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$D$</math-renderer></strong>: <em>the loss in the 1/3rd consensus safety margin of the FFG Casper mechanism because of the changing validator set. The new safety margin that the mechanism can tolerate becomes $\frac{1}{3} - D$.</em> [<a href="https://notes.ethereum.org/@adiasg/weak-subjectvity-eth2" rel="nofollow">https://notes.ethereum.org/@adiasg/weak-subjectvity-eth2</a>]</li>
</ul>
<details><summary>Weak Subjectivity Period</summary>
<div dir="auto" data-snippet-clipboard-copy-content="
def compute_weak_subjectivity_period(state: BeaconState) -&gt; uint64:
    &#34;&#34;&#34;
    Returns the weak subjectivity period for the current ``state``. 
    This computation takes into account the effect of:
        - validator set churn (bounded by ``get_validator_churn_limit()`` per epoch), and 
        - validator balance top-ups (bounded by ``MAX_DEPOSITS * SLOTS_PER_EPOCH`` per epoch).
    A detailed calculation can be found at:
    https://github.com/runtimeverification/beacon-chain-verification/blob/master/weak-subjectivity/weak-subjectivity-analysis.pdf
    &#34;&#34;&#34;
    ws_period = MIN_VALIDATOR_WITHDRAWABILITY_DELAY
    N = len(get_active_validator_indices(state, get_current_epoch(state)))
    t = get_total_active_balance(state) // N // ETH_TO_GWEI
    T = MAX_EFFECTIVE_BALANCE // ETH_TO_GWEI
    delta = get_validator_churn_limit(state)
    Delta = MAX_DEPOSITS * SLOTS_PER_EPOCH
    D = SAFETY_DECAY

    if T * (200 + 3 * D) &lt; t * (200 + 12 * D):
        epochs_for_validator_set_churn = (
            N * (t * (200 + 12 * D) - T * (200 + 3 * D)) // (600 * delta * (2 * t + T))
        )
        epochs_for_balance_top_ups = (
            N * (200 + 3 * D) // (600 * Delta)
        )
        ws_period += max(epochs_for_validator_set_churn, epochs_for_balance_top_ups)
    else:
        ws_period += (
            3 * N * D * t // (200 * Delta * (T - t))
        )
    
    return ws_period
"><pre><span>def</span> <span>compute_weak_subjectivity_period</span>(<span>state</span>: <span>BeaconState</span>) <span>-&gt;</span> <span>uint64</span>:
    <span>&#34;&#34;&#34;</span>
<span>    Returns the weak subjectivity period for the current ``state``. </span>
<span>    This computation takes into account the effect of:</span>
<span>        - validator set churn (bounded by ``get_validator_churn_limit()`` per epoch), and </span>
<span>        - validator balance top-ups (bounded by ``MAX_DEPOSITS * SLOTS_PER_EPOCH`` per epoch).</span>
<span>    A detailed calculation can be found at:</span>
<span>    https://github.com/runtimeverification/beacon-chain-verification/blob/master/weak-subjectivity/weak-subjectivity-analysis.pdf</span>
<span>    &#34;&#34;&#34;</span>
    <span>ws_period</span> <span>=</span> <span>MIN_VALIDATOR_WITHDRAWABILITY_DELAY</span>
    <span>N</span> <span>=</span> <span>len</span>(<span>get_active_validator_indices</span>(<span>state</span>, <span>get_current_epoch</span>(<span>state</span>)))
    <span>t</span> <span>=</span> <span>get_total_active_balance</span>(<span>state</span>) <span>//</span> <span>N</span> <span>//</span> <span>ETH_TO_GWEI</span>
    <span>T</span> <span>=</span> <span>MAX_EFFECTIVE_BALANCE</span> <span>//</span> <span>ETH_TO_GWEI</span>
    <span>delta</span> <span>=</span> <span>get_validator_churn_limit</span>(<span>state</span>)
    <span>Delta</span> <span>=</span> <span>MAX_DEPOSITS</span> <span>*</span> <span>SLOTS_PER_EPOCH</span>
    <span>D</span> <span>=</span> <span>SAFETY_DECAY</span>

    <span>if</span> <span>T</span> <span>*</span> (<span>200</span> <span>+</span> <span>3</span> <span>*</span> <span>D</span>) <span>&lt;</span> <span>t</span> <span>*</span> (<span>200</span> <span>+</span> <span>12</span> <span>*</span> <span>D</span>):
        <span>epochs_for_validator_set_churn</span> <span>=</span> (
            <span>N</span> <span>*</span> (<span>t</span> <span>*</span> (<span>200</span> <span>+</span> <span>12</span> <span>*</span> <span>D</span>) <span>-</span> <span>T</span> <span>*</span> (<span>200</span> <span>+</span> <span>3</span> <span>*</span> <span>D</span>)) <span>//</span> (<span>600</span> <span>*</span> <span>delta</span> <span>*</span> (<span>2</span> <span>*</span> <span>t</span> <span>+</span> <span>T</span>))
        )
        <span>epochs_for_balance_top_ups</span> <span>=</span> (
            <span>N</span> <span>*</span> (<span>200</span> <span>+</span> <span>3</span> <span>*</span> <span>D</span>) <span>//</span> (<span>600</span> <span>*</span> <span>Delta</span>)
        )
        <span>ws_period</span> <span>+=</span> <span>max</span>(<span>epochs_for_validator_set_churn</span>, <span>epochs_for_balance_top_ups</span>)
    <span>else</span>:
        <span>ws_period</span> <span>+=</span> (
            <span>3</span> <span>*</span> <span>N</span> <span>*</span> <span>D</span> <span>*</span> <span>t</span> <span>//</span> (<span>200</span> <span>*</span> <span>Delta</span> <span>*</span> (<span>T</span> <span>-</span> <span>t</span>))
        )
    
    <span>return</span> <span>ws_period</span></pre></div>
<div dir="auto" data-snippet-clipboard-copy-content="
def is_within_weak_subjectivity_period(store: Store, ws_state: BeaconState, ws_checkpoint: Checkpoint) -&gt; bool:
    # Clients may choose to validate the input state against the input Weak Subjectivity Checkpoint
    assert ws_state.latest_block_header.state_root == ws_checkpoint.root
    assert compute_epoch_at_slot(ws_state.slot) == ws_checkpoint.epoch

    ws_period = compute_weak_subjectivity_period(ws_state)
    ws_state_epoch = compute_epoch_at_slot(ws_state.slot)
    current_epoch = compute_epoch_at_slot(get_current_slot(store))
    return current_epoch &lt;= ws_state_epoch + ws_period
"><pre><span>def</span> <span>is_within_weak_subjectivity_period</span>(<span>store</span>: <span>Store</span>, <span>ws_state</span>: <span>BeaconState</span>, <span>ws_checkpoint</span>: <span>Checkpoint</span>) <span>-&gt;</span> <span>bool</span>:
    <span># Clients may choose to validate the input state against the input Weak Subjectivity Checkpoint</span>
    <span>assert</span> <span>ws_state</span>.<span>latest_block_header</span>.<span>state_root</span> <span>==</span> <span>ws_checkpoint</span>.<span>root</span>
    <span>assert</span> <span>compute_epoch_at_slot</span>(<span>ws_state</span>.<span>slot</span>) <span>==</span> <span>ws_checkpoint</span>.<span>epoch</span>

    <span>ws_period</span> <span>=</span> <span>compute_weak_subjectivity_period</span>(<span>ws_state</span>)
    <span>ws_state_epoch</span> <span>=</span> <span>compute_epoch_at_slot</span>(<span>ws_state</span>.<span>slot</span>)
    <span>current_epoch</span> <span>=</span> <span>compute_epoch_at_slot</span>(<span>get_current_slot</span>(<span>store</span>))
    <span>return</span> <span>current_epoch</span> <span>&lt;=</span> <span>ws_state_epoch</span> <span>+</span> <span>ws_period</span></pre></div>
</details>
<p dir="auto">Calculating the weak subjective period, as reported by <a href="https://notes.ethereum.org/@adiasg/weak-subjectvity-eth2" rel="nofollow">Aditya Asgaonkar</a>, results in the following table.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/f4fb18c3a197941b8b3317da0c84df434f3b77c454afb2d1fa0a60040ae98bb2/68747470733a2f2f73746f726167652e676f6f676c65617069732e636f6d2f657468657265756d2d6861636b6d642f75706c6f61645f66326432356331643366633035663836353364393063633865643566343561342e706e67"><img src="https://camo.githubusercontent.com/f4fb18c3a197941b8b3317da0c84df434f3b77c454afb2d1fa0a60040ae98bb2/68747470733a2f2f73746f726167652e676f6f676c65617069732e636f6d2f657468657265756d2d6861636b6d642f75706c6f61645f66326432356331643366633035663836353364393063633865643566343561342e706e67" alt="" data-canonical-src="https://storage.googleapis.com/ethereum-hackmd/upload_f2d25c1d3fc05f8653d90cc8ed5f45a4.png"/></a></p>
<p dir="auto">For example, assuming a validator set of at least <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$262144$</math-renderer> validators and a safety decay of <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$10%$</math-renderer>, the maximum safe weak subjectivity period is of <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$3277$</math-renderer> epoch, i.e., around two weeks. In other terms, within two weeks a weak subjectivity checkpoint must be defined.</p>
<p dir="auto"><em>So what would a world powered by weakly subjective consensus look like? First of all, nodes that are always online would be fine; in those cases weak subjectivity is by definition equivalent to objectivity. Nodes that pop online once in a while, or at least once every $N$ blocks, would also be fine, because they would be able to constantly get an updated state of the network. However, new nodes joining the network, and nodes that appear online after a very long time, would not have the consensus algorithm reliably protecting them. Fortunately, for them, the solution is simple: the first time they sign up, and every time they stay offline for a very very long time, they need only get a recent block hash from a friend, a blockchain explorer, or simply their software provider, and paste it into their blockchain client as a checkpoint. They will then be able to securely update their view of the current state from there.</em> [<a href="https://blog.ethereum.org/2014/11/25/proof-stake-learned-love-weak-subjectivity" rel="nofollow">https://blog.ethereum.org/2014/11/25/proof-stake-learned-love-weak-subjectivity</a>]</p>
<h3 dir="auto"><a id="user-content-problems-and-solutions" aria-hidden="true" href="#problems-and-solutions"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Problems and Solutions</h3>
<h4 dir="auto"><a id="user-content-problem-balancing-attack" aria-hidden="true" href="#problem-balancing-attack"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Problem: Balancing attack</h4>
<p dir="auto"><a href="https://arxiv.org/pdf/2009.04987.pdf" rel="nofollow">Neu <em>et al.</em></a> [<a href="https://ethresear.ch/t/a-balancing-attack-on-gasper-the-current-candidate-for-eth2s-beacon-chain/8079" rel="nofollow">https://ethresear.ch/t/a-balancing-attack-on-gasper-the-current-candidate-for-eth2s-beacon-chain/8079</a>] have shown how the original version of Gasper, i.e., the one presented in the <a href="https://riskmusings.substack.com/ethereum/pos-evolution/blob/master/GgixO3A1TrSBTfif1E8etw">first part</a>, suffers from a liveness issue that leads to loss of safety for the dynamically available ledger. They presented an attack against Gasper, called <em>balancing attack</em>, in the synchronous network model with adversarial network delay.</p>
<p dir="auto"><em>Recall that Gasper proceeds in epochs which are further subdivided into $C$ slots each. For simplicity, let $C$ divide $n$ so that every slot has a committee of size $\frac{n}{C}$. For each epoch, a random permutation of all $n$ validators assigns validators to slots’ committees and designates a proposer per slot. Per slot, the proposer produces a new block extending the tip determined by the fork choice rule $HLMD(G)$ executed in local view $G$. Then, each validator of the slot’s committee decides what block to vote for using $HLMD(G)$ in local view $G.$</em>
<em>For the Casper FFG layer, a block can only become finalized if two-thirds of validators vote for it. The attacker aims to keep honest validators split between two options (left and right chain) indefinitely, so that neither option ever gets two-thirds votes and thus no block ever gets finalized. Key technique to maintain this split is that some adversarial validators (‘swayers’) withhold their votes and release them only at specific times and to specific subsets of honest nodes in order to influence the fork choice of honest nodes and thus steer which honest nodes vote left/right.</em> [<a href="https://arxiv.org/pdf/2009.04987.pdf" rel="nofollow">https://arxiv.org/pdf/2009.04987.pdf</a>]</p>
<p dir="auto">The attacks requires an adversary to (i) know at what points in time honest validators execute HLMD-GHOST and (ii) be able to target a message for delivery to an honest validator just before a certain point in time. Moreover, it assumes that (iii) honest validators cannot <em>quickly</em> update each other about messages they have just received.</p>
<p dir="auto">The adversary waits until the the proposer in the first slot of an epoch is Byzantine and there are at least six Byzantine validators in every slot of the epoch. Let us assume that this is the case in epoch <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$0$</math-renderer>. The Byzantine proposer of slot <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$0$</math-renderer> <em>equivocates</em> and produces two conflicting blocks (left/blue and right/yellow) which it reveals to two suitably chosen equal-sized subsets of the committee. One subset votes left, the other subset votes ‘right’, obtaining a tie.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/0b3b983808e684956040cd2bd47655d29c3cab3ba256e83c6f6e585e35d7ac3a/68747470733a2f2f73746f726167652e676f6f676c65617069732e636f6d2f657468657265756d2d6861636b6d642f75706c6f61645f37666463363733626430633536616135356235633564343063396562626664352e706e67"><img src="https://camo.githubusercontent.com/0b3b983808e684956040cd2bd47655d29c3cab3ba256e83c6f6e585e35d7ac3a/68747470733a2f2f73746f726167652e676f6f676c65617069732e636f6d2f657468657265756d2d6861636b6d642f75706c6f61645f37666463363733626430633536616135356235633564343063396562626664352e706e67" alt="" data-canonical-src="https://storage.googleapis.com/ethereum-hackmd/upload_7fdc673bd0c56aa55b5c5d40c9ebbfd5.png"/></a></p>
<p dir="auto">Observe that if the number of honest validator is not even, then the adversary recruits a Byzantine validator ($d$) to behave like an honest one. Finally, all blocks are delivered to every validator before <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$\Delta$</math-renderer>. Note that the only Byzantine validators that cast a vote for slot <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$0$</math-renderer> are only <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$a$</math-renderer> and <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$d$</math-renderer>.</p>
<p dir="auto">At this point, the adversary selectively releases withheld votes (from Byzantine validators ($c$)) from slot <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$0$</math-renderer> to split validators of slot <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$1$</math-renderer> into two groups of equal size, one which sees left\blue as leading and votes for it, and one which sees right/yellow as leading and votes for it, reaching again a tie.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/83bacb7768b1a30994163d0bb93a8efda7ca83d2d4648641457c4d010023775e/68747470733a2f2f73746f726167652e676f6f676c65617069732e636f6d2f657468657265756d2d6861636b6d642f75706c6f61645f32653563353233363166363831343234356361633561633437333137353361632e706e67"><img src="https://camo.githubusercontent.com/83bacb7768b1a30994163d0bb93a8efda7ca83d2d4648641457c4d010023775e/68747470733a2f2f73746f726167652e676f6f676c65617069732e636f6d2f657468657265756d2d6861636b6d642f75706c6f61645f32653563353233363166363831343234356361633561633437333137353361632e706e67" alt="" data-canonical-src="https://storage.googleapis.com/ethereum-hackmd/upload_2e5c52361f6814245cac5ac4731753ac.png"/></a></p>
<p dir="auto">The adversary continues this strategy to maintain the tie throughout epoch <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$0$</math-renderer>.</p>
<p dir="auto">During epoch <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$1$</math-renderer>, the adversary selectively releases additional withheld votes from epoch <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$0$</math-renderer> ($b$) to keep splitting validators into two groups, one of which sees left/blue as leading, the other sees right/yellow as leading, voting left/blue and right/yellow, respectively.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/07b79dc6104f16d363c0e7e047f80aa234367bf776c0e5991b39b83223a18fa8/68747470733a2f2f73746f726167652e676f6f676c65617069732e636f6d2f657468657265756d2d6861636b6d642f75706c6f61645f35306632633139656131336561653266343431323966653762623933373165302e706e67"><img src="https://camo.githubusercontent.com/07b79dc6104f16d363c0e7e047f80aa234367bf776c0e5991b39b83223a18fa8/68747470733a2f2f73746f726167652e676f6f676c65617069732e636f6d2f657468657265756d2d6861636b6d642f75706c6f61645f35306632633139656131336561653266343431323966653762623933373165302e706e67" alt="" data-canonical-src="https://storage.googleapis.com/ethereum-hackmd/upload_50f2c19ea13eae2f44129fe7bb9371e0.png"/></a></p>
<p dir="auto">Finally, for epoch <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$2$</math-renderer> and beyond the adversary repeats its actions of epoch <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$1$</math-renderer>. This continues indefinitely preventing finalization. Hence, Gasper is not secure in the synchronous model.</p>
<h4 dir="auto"><a id="user-content-part-of-the-solution-proposer-weight-boosting" aria-hidden="true" href="#part-of-the-solution-proposer-weight-boosting"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>(Part Of The) Solution: Proposer Weight Boosting</h4>
<p dir="auto">The balancing attack just presented is based on the fact that an attacker, by manipulating the network, can create a disagreement at the end of each slot regarding which messages count for the fork choice, and therefore a disagreement on which chain is the winning chain.</p>
<p dir="auto"><a href="https://notes.ethereum.org/@vbuterin/lmd_ghost_mitigation" rel="nofollow">The proposed solution</a> to avoid the balancing attack is to increase the <em>attestation weight</em> of the proposer of a block in a given slot, if some conditions are met. In details, let us assume that all the attesters assigned to slot
<math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$i$</math-renderer>, i.e., validators in the committee that cast attestations in slot <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$i$</math-renderer>, have collective total weight <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$W$</math-renderer>. Then, the proposer in slot <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$i+1$</math-renderer> is expected to make a proposal immediately at the start of its slot. Its proposal implicitly chooses a particular chain. In this way, attesters of slot <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$i+1$</math-renderer>, if they see the proposal arriving before <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$\frac{1}{3}$</math-renderer> of the way into a slot, they treat that proposal as equivalent to an attestation with weight <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$\frac{W}{4}$</math-renderer>. Observe that this attestation weight for the proposer is valid only for slot <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$i+1$</math-renderer>; after that, this weight is reverted.</p>
<details><summary>Proposer Boosting</summary>
<p dir="auto">Proposer LMD Score Boosting: [<a data-error-text="Failed to load title" data-id="1058905734" data-permission-text="Title is private" data-url="https://github.com/ethereum/consensus-specs/issues/2730" data-hovercard-type="pull_request" data-hovercard-url="/ethereum/consensus-specs/pull/2730/hovercard" href="https://github.com/ethereum/consensus-specs/pull/2730">ethereum/consensus-specs#2730</a>]</p>
<div dir="auto" data-snippet-clipboard-copy-content="def on_block(store: Store, signed_block: SignedBeaconBlock) -&gt; None:

...
    
    # Add proposer score boost if the block is timely
    time_into_slot = (store.time - store.genesis_time) % SECONDS_PER_SLOT
    is_before_attesting_interval = time_into_slot &lt; SECONDS_PER_SLOT // INTERVALS_PER_SLOT
    if get_current_slot(store) == block.slot and is_before_attesting_interval:
        store.proposer_boost_root = hash_tree_root(block)

..."><pre><span>def</span> <span>on_block</span>(<span>store</span>: <span>Store</span>, <span>signed_block</span>: <span>SignedBeaconBlock</span>) <span>-&gt;</span> <span>None</span>:

...
    
    <span># Add proposer score boost if the block is timely</span>
    <span>time_into_slot</span> <span>=</span> (<span>store</span>.<span>time</span> <span>-</span> <span>store</span>.<span>genesis_time</span>) <span>%</span> <span>SECONDS_PER_SLOT</span>
    <span>is_before_attesting_interval</span> <span>=</span> <span>time_into_slot</span> <span>&lt;</span> <span>SECONDS_PER_SLOT</span> <span>//</span> <span>INTERVALS_PER_SLOT</span>
    <span>if</span> <span>get_current_slot</span>(<span>store</span>) <span>==</span> <span>block</span>.<span>slot</span> <span>and</span> <span>is_before_attesting_interval</span>:
        <span>store</span>.<span>proposer_boost_root</span> <span>=</span> <span>hash_tree_root</span>(<span>block</span>)

...</pre></div>
<p dir="auto">Recall that <code>on_block</code> runs whenever a <code>SignedBeaconBlock</code> is received, updating the <code>store</code> for the fork choice rule.</p>
</details>
<h4 dir="auto"><a id="user-content-problem-a-balancing-attack-despite-proposer-weight-boosting" aria-hidden="true" href="#problem-a-balancing-attack-despite-proposer-weight-boosting"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Problem: A Balancing Attack Despite Proposer Weight Boosting</h4>
<p dir="auto">Despite the proposer weight boosting solution presented above, <a href="https://arxiv.org/pdf/2203.01315.pdf" rel="nofollow">Neu <em>et al.</em></a> have shown that the LMD aspect of HLMD-GHOST still enables balancing attacks to Gasper.</p>
<p dir="auto">LMD is devised as it follows. Every validator has a local table of the latest message that it received from each other validator, and that can be updated if some conditions are met. In particular, when a validator <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$v_i \in \mathcal{V}$</math-renderer> receives a valid message (i.e., a vote) from another validator <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$v_j \in \mathcal{V}$</math-renderer>, then the latest message table entry for <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$v_j$</math-renderer> is updated if and only if new vote of <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$v_j$</math-renderer> is from a slot <em>strictly later</em> than the current latest message table entry. Thus, if <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$v_i$</math-renderer> observes two equivocating votes from <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$v_j$</math-renderer> for the same slot, validator <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$v_i$</math-renderer> considers the vote from <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$v_j$</math-renderer> received earlier in time. [<a href="https://ethresear.ch/t/balancing-attack-lmd-edition/11853" rel="nofollow">https://ethresear.ch/t/balancing-attack-lmd-edition/11853</a>]</p>
<p dir="auto">We present the example showing the attack presented by Neu <em>at al.</em> Let <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$W=100$</math-renderer> be the number of total validators per slot and let us assume that the proposal weight is <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$W_p = 0.7 W = 70$</math-renderer>. Moreover, let us assume a fraction of Byzantine validators of <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$20%$</math-renderer>, i.e., we assume <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$20$</math-renderer> Byzantine validators in each slot. Finally, the attack starts when there are five consecutive slots with Byzantine proposers.</p>
<p dir="auto">During the first four slots the Byzantine proposers create two parallel chains of <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$4$</math-renderer> blocks each. These chains are initially kept private from the honest validators. The <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$20$</math-renderer> Byzantine validators vote on each of the <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$4$</math-renderer> blocks in each slot, i.e., they equivocate.</p>
<p dir="auto">For the fifth slot, the adversary includes all equivocating votes for the left and the right chains into two distinct blocks and attaches these blocks on the left and right chains, respectively. Then, it releases the two equivocating blocks from the fifth slot in such a way that roughly half of the honest validators see the left block first (let us call <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$L$</math-renderer> that set of honest validators) and with it all the equivocating votes for the left chain; and half of the honest validators see the right block first (let us call <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$R$</math-renderer> that set of honest validators) and with it all the equivocating votes for the right chain.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/d00c08d311b88868fb8badf4ef17616d1667c0f7c488b8345420fa9ca42eb56d/68747470733a2f2f73746f726167652e676f6f676c65617069732e636f6d2f657468657265756d2d6861636b6d642f75706c6f61645f38353266666431633633386665306465343161333562633663353534386235342e706e67"><img src="https://camo.githubusercontent.com/d00c08d311b88868fb8badf4ef17616d1667c0f7c488b8345420fa9ca42eb56d/68747470733a2f2f73746f726167652e676f6f676c65617069732e636f6d2f657468657265756d2d6861636b6d642f75706c6f61645f38353266666431633633386665306465343161333562633663353534386235342e706e67" alt="" data-canonical-src="https://storage.googleapis.com/ethereum-hackmd/upload_852ffd1c638fe0de41a35bc6c5548b54.png"/></a></p>
<p dir="auto">Honest validators in <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$L$</math-renderer> and <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$R$</math-renderer> believe that their chain (left and right, respectively) has <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$80$</math-renderer> votes, while the other has <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$0$</math-renderer> (this because votes that arrive later are not considered, due to LMD).</p>
<p dir="auto">If now we assume that slot <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$6$</math-renderer> has an honest validator <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$v_i \in L$</math-renderer>, then <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$v_i$</math-renderer> proposes a block extending the left chain. The left chain gains a (temporary) proposal boost equivalent to <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$70$</math-renderer> votes (recall that we assumed <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$W_p = 0.7W$</math-renderer>). Thus, validators belonging to <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$L$</math-renderer> see the left chain as leading with
<math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$150$</math-renderer> votes and vote for it. Conversely, validators belonging to <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$R$</math-renderer> see the left chain with <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$70$</math-renderer> votes while the right chain with <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$80$</math-renderer> votes. Thus they vote for the right chain.</p>
<p dir="auto">At the end of slot <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$6$</math-renderer>, the proposer boost disappears. In the view of each honest validator, both chains gained roughly the same amount of votes, namely half of the honest validators’ votes. Assuming <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$|L|=|R|=40$</math-renderer>, the proportion of votes between the left chain and the right chain is <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$120:40$</math-renderer> from the view of validators in <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$L$</math-renderer>, and <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$40:120$</math-renderer> from the view of validators in <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$R$</math-renderer>.</p>
<p dir="auto">So, this repeats in subsequent slots, with the honest validators in <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$L$</math-renderer> and <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$R$</math-renderer> voting for the left and right chains, respectively.</p>
<p dir="auto">It is worth noting that, by assumption, if a message is received by an honest validator, then this message will be received also by every other honest validator. This implies that honest validators in <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$L$</math-renderer> will receive all the messages that honest validators in <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$R$</math-renderer> received, and vice-versa. So, Byzantine validators that equivocate will eventually be slashed. However, this does not prevent the attack to be placed.</p>
<h4 dir="auto"><a id="user-content-other-part-of-the-solution-equivocation-discounting" aria-hidden="true" href="#other-part-of-the-solution-equivocation-discounting"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>(Other Part Of The) Solution: Equivocation Discounting</h4>
<p dir="auto"><em>Equivocations are attributable faults, punishable by slashing a posteriori, but this does not prevent the attack vector a priori given that only one validator is required for it, and that there is no immediate recovery, because the same validator can continue producing equivocating attestations in subsequent slots as well.</em> [<a href="https://arxiv.org/pdf/2209.03255.pdf" rel="nofollow">https://arxiv.org/pdf/2209.03255.pdf</a>]</p>
<p dir="auto">We present the notion of <em>equivocation discounting</em>, a solution to the attack presented in the section right above. On a high level, with equivocation discounting, we rely on every validator eventually recognizing equivocations and discarding them by stopping to give them weight. Formally, we require:</p>
<ul dir="auto">
<li>
<strong>Fork choice discounting</strong>: When a validator <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$v_i$</math-renderer> runs HLMD-GHOST at slot <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$t$</math-renderer>, it only counts votes from eligible validators <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$v_j$s for which the view of $v_i$</math-renderer> contains at most a single vote for each slot $v_j$s voted for, i.e., which are not viewed to have equivocated at previous slots.</li>
</ul>
<p dir="auto">In other words, we discard equivocating attestations from the fork choice, and <em>discount</em>, i.e., do not consider the weight of, all future votes of equivocating validators for fork choice purposes. Together with the LMD rule, the protocol considers only each validator’s most recent vote (or <em>attestation</em>) and, among them, only the non-equivocating ones.</p>
<p dir="auto">Finally, observe that if a Byzantine validator <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$v_i$</math-renderer> equivocates, eventually every honest validator will have evidence that <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$v_i$</math-renderer> equivocated. This implies that, eventually, every equivocating validator <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$v_i$</math-renderer> will be <em>discovered</em> by every honest validator, and these equivocations will be used to slash <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$v_i$</math-renderer>.</p>
<details><summary>Equivocation Discounting</summary>
<p dir="auto">Remove equivocating validators from fork choice consideration: [<a data-error-text="Failed to load title" data-id="1155756828" data-permission-text="Title is private" data-url="https://github.com/ethereum/consensus-specs/issues/2845" data-hovercard-type="pull_request" data-hovercard-url="/ethereum/consensus-specs/pull/2845/hovercard" href="https://github.com/ethereum/consensus-specs/pull/2845">ethereum/consensus-specs#2845</a>]</p>
<div dir="auto" data-snippet-clipboard-copy-content="def on_attestation(store: Store, attestation: Attestation, is_from_block: bool=False) -&gt; None:

...

    # Update latest messages for attesting indices
    update_latest_messages(store, indexed_attestation.attesting_indices, attestation)"><pre><span>def</span> <span>on_attestation</span>(<span>store</span>: <span>Store</span>, <span>attestation</span>: <span>Attestation</span>, <span>is_from_block</span>: <span>bool</span><span>=</span><span>False</span>) <span>-&gt;</span> <span>None</span>:

...

    <span># Update latest messages for attesting indices</span>
    <span>update_latest_messages</span>(<span>store</span>, <span>indexed_attestation</span>.<span>attesting_indices</span>, <span>attestation</span>)</pre></div>
<p dir="auto">with <code>update_latest_message</code> defined as</p>
<div dir="auto" data-snippet-clipboard-copy-content="def update_latest_messages(store: Store, attesting_indices: Sequence[ValidatorIndex], attestation: Attestation) -&gt; None:
    target = attestation.data.target
    beacon_block_root = attestation.data.beacon_block_root
    non_equivocating_attesting_indices = [i for i in attesting_indices if i not in store.equivocating_indices]
    for i in non_equivocating_attesting_indices:
        if i not in store.latest_messages or target.epoch &gt; store.latest_messages[i].epoch:
            store.latest_messages[i] = LatestMessage(epoch=target.epoch, root=beacon_block_root)"><pre><span>def</span> <span>update_latest_messages</span>(<span>store</span>: <span>Store</span>, <span>attesting_indices</span>: <span>Sequence</span>[<span>ValidatorIndex</span>], <span>attestation</span>: <span>Attestation</span>) <span>-&gt;</span> <span>None</span>:
    <span>target</span> <span>=</span> <span>attestation</span>.<span>data</span>.<span>target</span>
    <span>beacon_block_root</span> <span>=</span> <span>attestation</span>.<span>data</span>.<span>beacon_block_root</span>
    <span>non_equivocating_attesting_indices</span> <span>=</span> [<span>i</span> <span>for</span> <span>i</span> <span>in</span> <span>attesting_indices</span> <span>if</span> <span>i</span> <span>not</span> <span>in</span> <span>store</span>.<span>equivocating_indices</span>]
    <span>for</span> <span>i</span> <span>in</span> <span>non_equivocating_attesting_indices</span>:
        <span>if</span> <span>i</span> <span>not</span> <span>in</span> <span>store</span>.<span>latest_messages</span> <span>or</span> <span>target</span>.<span>epoch</span> <span>&gt;</span> <span>store</span>.<span>latest_messages</span>[<span>i</span>].<span>epoch</span>:
            <span>store</span>.<span>latest_messages</span>[<span>i</span>] <span>=</span> <span>LatestMessage</span>(<span>epoch</span><span>=</span><span>target</span>.<span>epoch</span>, <span>root</span><span>=</span><span>beacon_block_root</span>)</pre></div>
<div dir="auto" data-snippet-clipboard-copy-content="
def on_attester_slashing(store: Store, attester_slashing: AttesterSlashing) -&gt; None:
    &#34;&#34;&#34;
    Run ``on_attester_slashing`` immediately upon receiving a new ``AttesterSlashing``
    from either within a block or directly on the wire.
    &#34;&#34;&#34;
    attestation_1 = attester_slashing.attestation_1
    attestation_2 = attester_slashing.attestation_2
    assert is_slashable_attestation_data(attestation_1.data, attestation_2.data)
    state = store.block_states[store.justified_checkpoint.root]
    assert is_valid_indexed_attestation(state, attestation_1)
    assert is_valid_indexed_attestation(state, attestation_2)

    indices = set(attestation_1.attesting_indices).intersection(attestation_2.attesting_indices)
    for index in indices:
        store.equivocating_indices.add(index)"><pre><span>def</span> <span>on_attester_slashing</span>(<span>store</span>: <span>Store</span>, <span>attester_slashing</span>: <span>AttesterSlashing</span>) <span>-&gt;</span> <span>None</span>:
    <span>&#34;&#34;&#34;</span>
<span>    Run ``on_attester_slashing`` immediately upon receiving a new ``AttesterSlashing``</span>
<span>    from either within a block or directly on the wire.</span>
<span>    &#34;&#34;&#34;</span>
    <span>attestation_1</span> <span>=</span> <span>attester_slashing</span>.<span>attestation_1</span>
    <span>attestation_2</span> <span>=</span> <span>attester_slashing</span>.<span>attestation_2</span>
    <span>assert</span> <span>is_slashable_attestation_data</span>(<span>attestation_1</span>.<span>data</span>, <span>attestation_2</span>.<span>data</span>)
    <span>state</span> <span>=</span> <span>store</span>.<span>block_states</span>[<span>store</span>.<span>justified_checkpoint</span>.<span>root</span>]
    <span>assert</span> <span>is_valid_indexed_attestation</span>(<span>state</span>, <span>attestation_1</span>)
    <span>assert</span> <span>is_valid_indexed_attestation</span>(<span>state</span>, <span>attestation_2</span>)

    <span>indices</span> <span>=</span> <span>set</span>(<span>attestation_1</span>.<span>attesting_indices</span>).<span>intersection</span>(<span>attestation_2</span>.<span>attesting_indices</span>)
    <span>for</span> <span>index</span> <span>in</span> <span>indices</span>:
        <span>store</span>.<span>equivocating_indices</span>.<span>add</span>(<span>index</span>)</pre></div>
<p dir="auto">This function updates <code>store.equivocating_indices</code> with the validators that cast equivocating votes.</p>
</details>
<h4 dir="auto"><a id="user-content-problem-avalanche-attack-solved-with-equivocation-discounting" aria-hidden="true" href="#problem-avalanche-attack-solved-with-equivocation-discounting"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Problem: Avalanche Attack (solved with equivocation discounting)</h4>
<p dir="auto">The <a href="https://arxiv.org/pdf/2203.01315.pdf" rel="nofollow">Avalanche Attack</a> is an attack at proof-of-stake GHOST that combines selfish mining with equivocations. Observe that this attack is possible because of the assumed underlying proof-of-stake mechanism. Proof-of-work does not have equivocations. The attack exploits the fact that the weight of a block in GHOST is given by the number of ancestors that such block has. This differs from the <em>vote-based</em> variant of GHOST as used in PoS Ethereum, <em>where block weight is determined by votes and potentially a proposal boost</em>. [<a href="https://arxiv.org/pdf/2203.01315.pdf" rel="nofollow">https://arxiv.org/pdf/2203.01315.pdf</a>] However, a similar attack exists also in the vote-based paradigm. Finally, note that <em>only</em> <a href="https://eprint.iacr.org/2013/881.pdf" rel="nofollow">GHOST</a> is considered, because its variant with LMD does not suffer from this attack.</p>
<p dir="auto"><em>The adversary uses withheld blocks to displace an honest chain once it catches up in subtree weight with the number of withheld adversarial blocks. The withheld blocks are released in a flat but wide subtree, exploiting the fact that under the GHOST rule such a subtree can displace a long chain. Only two withheld blocks enter the canonical chain permanently, while the other withheld blocks can subsequently be reused (through equivocations) to build further subtrees to displace even more honest blocks. The attack exploits a specific weakness of the GHOST rule in combination with equivocations from PoS, namely that an adversary can reuse ‘uncle blocks’ in GHOST, and thus such equivocations contribute to the weight of multiple ancestors. Formal security proof of PoS GHOST seems doomed.</em> <a href="https://ethresear.ch/t/avalanche-attack-on-proof-of-stake-ghost/11854" rel="nofollow">https://ethresear.ch/t/avalanche-attack-on-proof-of-stake-ghost/11854</a></p>
<p dir="auto">We present the example showing the attack presented by Neu <em>at al.</em> Let us assume that the adversary starts with <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$k=6$</math-renderer> withheld blocks and does not gain any new blocks during the attack, meaning that the attack eventually stops. Observe that the larger the number of blocks that are withheld, the longer will the attack last.</p>
<p dir="auto">First, the adversary withholds its subtree of <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$k=6$</math-renderer> withheld blocks, while honest nodes produce a chain. (In the figure below, red blocks are blocks from the adversary, while the green blocks constitute the honest chain.)</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/460bcac4ca62537c3caad5a3e5dd45a81b29c19c94be01da29e7585a82d71a9e/68747470733a2f2f73746f726167652e676f6f676c65617069732e636f6d2f657468657265756d2d6861636b6d642f75706c6f61645f39623866663066386337313835353932343263336664653866356461316266362e706e67"><img src="https://camo.githubusercontent.com/460bcac4ca62537c3caad5a3e5dd45a81b29c19c94be01da29e7585a82d71a9e/68747470733a2f2f73746f726167652e676f6f676c65617069732e636f6d2f657468657265756d2d6861636b6d642f75706c6f61645f39623866663066386337313835353932343263336664653866356461316266362e706e67" alt="" data-canonical-src="https://storage.googleapis.com/ethereum-hackmd/upload_9b8ff0f8c718559242c3fde8f5da1bf6.png"/></a></p>
<p dir="auto">Once honest nodes reach a chain of length <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$6$</math-renderer>, the adversary releases the withheld blocks. Observe that the main chain according to GHOST changes.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/3b8db37621a8e4030348d71b82c73656da84d6f6abf22a442e3631c022f3c654/68747470733a2f2f73746f726167652e676f6f676c65617069732e636f6d2f657468657265756d2d6861636b6d642f75706c6f61645f36623731373662373937653865613662653237343437643066313461356562352e706e67"><img src="https://camo.githubusercontent.com/3b8db37621a8e4030348d71b82c73656da84d6f6abf22a442e3631c022f3c654/68747470733a2f2f73746f726167652e676f6f676c65617069732e636f6d2f657468657265756d2d6861636b6d642f75706c6f61645f36623731373662373937653865613662653237343437643066313461356562352e706e67" alt="" data-canonical-src="https://storage.googleapis.com/ethereum-hackmd/upload_6b7176b797e8ea6be27447d0f14a5eb5.png"/></a></p>
<p dir="auto">Note that the adversary can reuse blocks <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$3,4,5$</math-renderer> and <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$6$</math-renderer>, in the form of equivocations, on top of the chain <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$B_{\text{genesis}} → 1 → 2$</math-renderer> formed by the first two withheld adversarial blocks, which is now the chain adopted by honest nodes. Again, once that new chain reaches length <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$4$</math-renderer>, the adversary releases another subtree and, according to GHOST, the main chain changes again.  Once the new chain reaches length <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$2$</math-renderer>, the adversary releases the last displacing subtree.</p>
<p dir="auto">Honest nodes now build on <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$6 \rightarrow 5 \rightarrow 4 \rightarrow 3 \rightarrow 2 \rightarrow 1 \rightarrow B_{\text{genesis}}$</math-renderer>. All honest nodes so far have been displaced.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/e98576d4253a5bbb6e8e4550cba122f63507e58cf3f1654e58a8544e0eab6ee4/68747470733a2f2f73746f726167652e676f6f676c65617069732e636f6d2f657468657265756d2d6861636b6d642f75706c6f61645f38343731613934653166663232306361373830646231663630626532363836622e706e67"><img src="https://camo.githubusercontent.com/e98576d4253a5bbb6e8e4550cba122f63507e58cf3f1654e58a8544e0eab6ee4/68747470733a2f2f73746f726167652e676f6f676c65617069732e636f6d2f657468657265756d2d6861636b6d642f75706c6f61645f38343731613934653166663232306361373830646231663630626532363836622e706e67" alt="" data-canonical-src="https://storage.googleapis.com/ethereum-hackmd/upload_8471a94e1ff220ca780db1f60be2686b.png"/></a></p>
<p dir="auto">Observe that, through equivocation discounting, this attack can no longer be placed. Equivocating blocks are not considered during the fork choice.</p>
<h4 dir="auto"><a id="user-content-problem-ex-ante-reorg" aria-hidden="true" href="#problem-ex-ante-reorg"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Problem: Ex-Ante Reorg</h4>
<p dir="auto">A reorg is an event where a block that was part of the canonical chain becomes no longer part of the canonical chain because a competing block beat it out. Reorgs can occur naturally due to network latency (also called <em>short reorgs</em>), or maliciously. In the first case, let us consider for example the proof-of-work. Here, if two miners create blocks <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$A$</math-renderer> and <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$A&#39;$</math-renderer> at nearly the same time, then the network partitions with some honest nodes mining on top of <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$A$</math-renderer> and some mining on top of <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$A&#39;$</math-renderer>. If a new block <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$B$</math-renderer> is mined as a child of <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$A$</math-renderer> before any blocks are mined as a child of <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$A&#39;$</math-renderer>, then the network will see <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$A$</math-renderer> as the tip of the chain, making <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$A&#39;$</math-renderer> <em>orphaned</em>. Every honest miner who saw <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$A&#39;$</math-renderer> as the tip of the chain, switches to <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$A$</math-renderer> and deletes block <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$A&#39;$</math-renderer> from the canonical chain.
The maliciously occurrency of reorgs are instead caused by an adversary who seeks to exploit reorgs for its own gain. This enables attacks like double-spending or front-running.</p>
<p dir="auto"><em>Finality is a situation where a fork choice rule so strongly favors a block that it is mathematically impossible, or economically infeasible for that block to get reorged. In some fork choice rules, reorgs cannot happen; the fork choice rule simply extends the existing chain by appending any blocks that have been finalized through consensus. In other fork choice rules, reorgs are very frequent.</em> [<a href="https://www.paradigm.xyz/2021/07/ethereum-reorgs-after-the-merge" rel="nofollow">https://www.paradigm.xyz/2021/07/ethereum-reorgs-after-the-merge</a>]</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/8387bfdc008ddf38f73cba48eec3f7b3bbe78d1f72c0a663b7d18e3d737c0f3b/68747470733a2f2f73746f726167652e676f6f676c65617069732e636f6d2f657468657265756d2d6861636b6d642f75706c6f61645f35613339633232376632333731333132316537653561386635396530346439352e706e67"><img src="https://camo.githubusercontent.com/8387bfdc008ddf38f73cba48eec3f7b3bbe78d1f72c0a663b7d18e3d737c0f3b/68747470733a2f2f73746f726167652e676f6f676c65617069732e636f6d2f657468657265756d2d6861636b6d642f75706c6f61645f35613339633232376632333731333132316537653561386635396530346439352e706e67" alt="" data-canonical-src="https://storage.googleapis.com/ethereum-hackmd/upload_5a39c227f23713121e7e5a8f59e04d95.png"/></a></p>
<p dir="auto">With Gasper, <em>long reorgs</em>, i.e., reorgs that aim to fork out several blocks, are not possible because all blocks that are deeper than <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$2$</math-renderer> epochs in the past are considered finalized (see FFG Casper and Gasper sections). Moreover, ex post reorgs become practically impossible because an adversary controlling only a few validators has no way to beat the honest majority of thousands of attesters (<a href="https://beaconcha.in/validators" rel="nofollow">https://beaconcha.in/validators</a>). In other terms, making a reorg directly requires the attacker to control close to <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$50%$</math-renderer> of all validators.</p>
<p dir="auto">We present a simple ex ante reorgs where an adversary, being the proposer for slot <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$n+1$</math-renderer>, can perform a reorg of one block. Observe that this attack is done on the available ledger <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$𝖫𝖮𝖦_{\text{da}}$</math-renderer> (see Properties of Gasper section), and assuming synchrony.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/cdeffe0ade1897389a1d3a8aacf0660803c392df3ba5e961d142cc28bf4cd412/68747470733a2f2f73746f726167652e676f6f676c65617069732e636f6d2f657468657265756d2d6861636b6d642f75706c6f61645f38376264393661653264313135303039383839396430323637336364633333612e706e67"><img src="https://camo.githubusercontent.com/cdeffe0ade1897389a1d3a8aacf0660803c392df3ba5e961d142cc28bf4cd412/68747470733a2f2f73746f726167652e676f6f676c65617069732e636f6d2f657468657265756d2d6861636b6d642f75706c6f61645f38376264393661653264313135303039383839396430323637336364633333612e706e67" alt="" data-canonical-src="https://storage.googleapis.com/ethereum-hackmd/upload_87bd96ae2d1150098899d02673cdc33a.png"/></a></p>
<p dir="auto"><em>In slot $n + 1$ the adversary privately creates block $n + 1$ on block $n$ and attests to it. Honest validators of slot $n+1$ do not see any block and thus attest to block $n$ as head of the chain. In the next slot, an honest proposer publishes block $n + 2$ building on block $n$, which is the current head in their view. Simultaneously, the adversary finally publishes block $n + 1$ and the attestation voting for block $n + 1$. All honest validators of slot $n + 2$ attest to block $n + 1$ as head of the chain, because it has more weight than block $n + 2$. In the next slot block $n + 3$ is proposed building on block $n + 1$. Block $n + 2$ is reorged out.</em> [<a href="https://eprint.iacr.org/2021/1413.pdf" rel="nofollow">https://eprint.iacr.org/2021/1413.pdf</a>]</p>
<p dir="auto"><em>Proposer boosting does not mitigate all ex ante reorgs</em> [<a href="https://ethresear.ch/t/change-fork-choice-rule-to-mitigate-balancing-and-reorging-attacks/11127" rel="nofollow">https://ethresear.ch/t/change-fork-choice-rule-to-mitigate-balancing-and-reorging-attacks/11127</a>]. Let <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$W=100$</math-renderer> be the number of total validators per slot and let us assume that the proposal weight is <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$W_p = 0.8 W = 80$</math-renderer>. Moreover, let us assume a fraction of Byzantine validators of <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$7%$</math-renderer>, i.e., we assume <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$7$</math-renderer> Byzantine validators in each slot.  The attack works as it follows. The adversary proposes a hidden block for the slot <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$n+1$</math-renderer> and votes for it with <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$7%$</math-renderer> of adversarial attestations from that slot. Thus, an honest proposer for slot <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$n+2$</math-renderer> builds its block on block <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$n$</math-renderer> (observe that block <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$n+2$</math-renderer> is now sibling of the hidden block <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$n+1$</math-renderer>). Due to proposer boosting, the <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$93$</math-renderer> honest validators for slot <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$n+2$</math-renderer> vote for block <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$n+2$</math-renderer>. However, the adversary again uses its <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$7%$</math-renderer> attestations from slot <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$n+2$</math-renderer> to vote for the hidden block <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$n+1$</math-renderer>.
Now, let us assume that block <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$n+3$</math-renderer> is also adversarial, and builds on <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$n+1$</math-renderer>. Now the chain of block <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$n+1$</math-renderer> has <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$7%$</math-renderer> attestations from slot <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$n+1$</math-renderer>, <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$7%$</math-renderer> attestations from slot <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$n+2$</math-renderer>, and <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$80%$</math-renderer> attestations from slot <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$n+3$</math-renderer> (due to the proposer boosting). This equals <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$94%$</math-renderer>, which is more than the <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$93%$</math-renderer> from the honest committee of slot <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$n+2$</math-renderer>. As a result, honest validators switch over and vote for block <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$n+3$</math-renderer>, and block <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$n+2$</math-renderer> is forked out.</p>
<h4 dir="auto"><a id="user-content-view-merge-as-a-replacement-for-proposer-weight-boosting" aria-hidden="true" href="#view-merge-as-a-replacement-for-proposer-weight-boosting"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>View-Merge As A Replacement For Proposer Weight Boosting</h4>
<p dir="auto">The notion of <em>view-merge</em>, initially introduced by the <a href="https://blog.casperlabs.io/the-casper-network-highway-consensus-protocol/" rel="nofollow">Highway protocol</a>, aims to solve some problems that arise with the proposer boosting technique. For example, proposer boosting can be weaponized by Byzantine proposers to conclude a reorg, lowering the amount of attestations needed for it by the weight of boost. [<a href="https://ethresear.ch/t/change-fork-choice-rule-to-mitigate-balancing-and-reorging-attacks/11127" rel="nofollow">https://ethresear.ch/t/change-fork-choice-rule-to-mitigate-balancing-and-reorging-attacks/11127</a>]</p>
<p dir="auto">The idea behind the view-merge is to join the view of the honest proposer with those of all the other honest validators before they cast a vote in their slot. The result is that <em>in slots with a honest proposer all honest validators vote in favor of the honest proposal.</em> [<a href="https://arxiv.org/pdf/2209.03255.pdf" rel="nofollow">https://arxiv.org/pdf/2209.03255.pdf</a>]</p>
<p dir="auto">The general concept of view-merge is the <a href="https://ethresear.ch/t/view-merge-as-a-replacement-for-proposer-boost/13739" rel="nofollow">following</a>:</p>
<ul dir="auto">
<li>Attesters freeze their view <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$\Delta$</math-renderer> seconds before the beginning of a new slot, caching new messages for later processing. (<em>Note that, currently, the duration of a slot in Gasper is $3\Delta$, with $\Delta$ be the message delay. In particular, the slot is divided into $3$ parts of $4$ seconds each: $4$ seconds to propose a block, $4$ seconds to attest, and $4$ seconds to aggregate the attestations.</em>)</li>
<li>The proposer, instead, does not freeze its view, and proposes, based on its view, on top of the head of the chain at the beginning of its slot. Moreover, the proposer references all attestations and blocks it used in its fork choice in some point-to-point message, which is propagated with the block.</li>
<li>Attesters include the referenced attestations in their view, and attest based on the <em>merged view</em>.</li>
</ul>
<p dir="auto">If the network delay is less that <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$\Delta$</math-renderer>, then every honest validator receives all the same messages. This implies that the view of the proposer is a superset of the frozen views of other validators. So, the final merged view is equal to the view of the proposer. Moreover, if the output of the fork choice is a function of a view, then every honest validator has the same fork choice output. As a consequence, honest validators attest to honest proposals.</p>
<h5 dir="auto"><a id="user-content-goldfish" aria-hidden="true" href="#goldfish"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Goldfish</h5>
<p dir="auto">In this section we present <a href="https://arxiv.org/pdf/2209.03255.pdf" rel="nofollow">Goldfish</a>, a simplified variant of LMD-GHOST, introduced by D&#39;Amato <em>et al.</em>, that implements the notions of view-merge and equivocation discounting. Goldfish can tolerate dynamic participation, it supports subsampling of validators (at each slot, the protocol can pseudo-randomly select a small group of validators to run the protocol on behalf of the total validator set), and it is provably secure and reorg resilient in synchronous networks with dynamic participation, assuming a majority of the validators follows the protocol honestly. Finally, Goldfish implements the notion of <em>vote expiry</em>, i.e., during each slot only votes from the immediately preceding slot influence the protocol’s behavior.</p>
<p dir="auto">Goldfish implements a variant of GHOST, for the fork choice rule, called <strong>GHOST-Eph</strong>. GHOST-Eph is a function that <em>takes a view $G$ and slot $t$ as input, and finds the canonical GHOST-Eph chain determined by the votes within $G$ that were cast for slot $t$. More specifically, starting at the genesis block, the function iterates over a sequence of blocks from $G$, selecting as the next block, the child of the current block with the maximum number of validators that have cast a slot $t$ vote for a block within its subtree. This continues until it reaches a leaf of the block-tree, and outputs a complete chain from leaf to root. The fork choice rule ignores votes from before slot $t$ in its decision (votes are ephemeral), lending GHOST-Eph its name.</em> [<a href="https://arxiv.org/pdf/2209.03255.pdf" rel="nofollow">https://arxiv.org/pdf/2209.03255.pdf</a>]</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/2a18327c8075ef448af34b074f5f58e2766f2356a38a98ff8be6bc2ad4ec140e/68747470733a2f2f73746f726167652e676f6f676c65617069732e636f6d2f657468657265756d2d6861636b6d642f75706c6f61645f64316663363131653166313462323936343461386232336133383238653039652e706e67"><img src="https://camo.githubusercontent.com/2a18327c8075ef448af34b074f5f58e2766f2356a38a98ff8be6bc2ad4ec140e/68747470733a2f2f73746f726167652e676f6f676c65617069732e636f6d2f657468657265756d2d6861636b6d642f75706c6f61645f64316663363131653166313462323936343461386232336133383238653039652e706e67" alt="" data-canonical-src="https://storage.googleapis.com/ethereum-hackmd/upload_d1fc611e1f14b29644a8b23a3828e09e.png"/></a></p>
<p dir="auto"><em>As in Gasper, slots in Goldfish have a duration of $3\Delta$. At the beginning of slot $t$, each awake honest validator $v_i$ checks if it is eligible to propose a block for slot $t$, i.e., if $v_i$ is a leader for slot $t$, by evaluating the verifiable random function (VRF) with secret key $\mathscr{vsk}$. If $v_i$ is the leader for slot $t$, then $v_i$ identifies the tip of its canonical GHOST-Eph chain using the slot $t-1$ votes in its view, and it broadcasts a proposal message containing (i) a new block extending the tip and (ii) the union of its view and buffer, $G \cup \mathcal{B}$.</em> (Observe that the buffer <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$\mathcal{B}$</math-renderer> is distinct from the validator’s view <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$G$</math-renderer>, the evergrowing set of messages used to make consensus decisions. Buffered messages are admitted to the view (merged) only at specific points in time.)* <em>At slot $3\Delta t + \Delta$, among the proposal messages received for slot $t$, each honest awake validator selects the one with the minimum VRF output, and accepts the block contained in the message as the proposal block for slot $t$. Moreover, validator $v_j$ merges its view with that of the proposal message. Then, with its VRF secret key $\mathscr{vsk}$, $v_j$ checks if it is eligible to vote for a block at slot $t$. If that is the case, $v_j$ identifies the new tip of its canonical GHOST-Eph chain using the slot $t − 1$ votes in its updated view, and broadcasts a slot $t$ vote for this tip.</em></p>
<p dir="auto"><em>At slot $3\Delta t + 2\Delta$, each honest awake validator $v_j$ merges its buffer $\mathcal{B}$ containing the votes received over the period $(3\Delta t + \Delta, 3\Delta t + 2\Delta]$ with its view $G$. Then, $v_j$ identifies the new tip of its canonical GHOST-Eph chain using the slot $t$ votes in its updated view, takes the prefix of this chain corresponding to blocks from slots $\le t-\kappa$, and outputs this confirmed prefix as the Goldfish ledger.</em></p>
<p dir="auto"><em>At the start of the next slot, i.e., at round $3\Delta t + 3\Delta$, the buffer of any honest validator contains all the votes received by honest validators in the period $(3\Delta t + \Delta, 3\Delta t + 2\Delta]$, i.e., all the votes which they have merged into their view at round $3\Delta t + 2\Delta$. In particular, the proposal message of an honest leader includes all such votes, ensuring that the view in an honest leader’s proposal message is a superset of any honest validator’s views at round $3\Delta(t+1)+\Delta$.</em> [<a href="https://arxiv.org/pdf/2209.03255.pdf" rel="nofollow">https://arxiv.org/pdf/2209.03255.pdf</a>]</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/38b492ec8d4b57828f5d0dc40d2801e1133089766feb434e76a45c2050d07652/68747470733a2f2f73746f726167652e676f6f676c65617069732e636f6d2f657468657265756d2d6861636b6d642f75706c6f61645f63363362383563366635353437313766323932323466656438663663666162382e706e67"><img src="https://camo.githubusercontent.com/38b492ec8d4b57828f5d0dc40d2801e1133089766feb434e76a45c2050d07652/68747470733a2f2f73746f726167652e676f6f676c65617069732e636f6d2f657468657265756d2d6861636b6d642f75706c6f61645f63363362383563366635353437313766323932323466656438663663666162382e706e67" alt="" data-canonical-src="https://storage.googleapis.com/ethereum-hackmd/upload_c63b85c6f554717f29224fed8f6cfab8.png"/></a></p>
<p dir="auto">A fast confirmation rule can also be added to Goldfish, allowing validators to confirm honest blocks proposed at the tip of their canonical GHOST-Eph chains within the same slot under optimistic conditions, i.e., under high participation and honest supermajority. This is done by adding <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$\Delta$</math-renderer> more rounds to slots, which are now divided into <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$4\Delta$</math-renderer> rounds.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/5760fc19dd7344657bb605fb955a5d74ac29368a32ad7daa0ed5a64e89d44d41/68747470733a2f2f73746f726167652e676f6f676c65617069732e636f6d2f657468657265756d2d6861636b6d642f75706c6f61645f30653431373533316231663637383930376638623634346330663436323635662e706e67"><img src="https://camo.githubusercontent.com/5760fc19dd7344657bb605fb955a5d74ac29368a32ad7daa0ed5a64e89d44d41/68747470733a2f2f73746f726167652e676f6f676c65617069732e636f6d2f657468657265756d2d6861636b6d642f75706c6f61645f30653431373533316231663637383930376638623634346330663436323635662e706e67" alt="" data-canonical-src="https://storage.googleapis.com/ethereum-hackmd/upload_0e417531b1f678907f8b644c0f46265f.png"/></a></p>
<p dir="auto"><em>At the start of each slot, the proposer merges buffered votes into their local view, determines their canonical chain, and proposes and broadcasts a block extending it, together with their local view. One-fourth into each slot, each voter merges the proposed view into their local view, determines their canonical chain, and casts a vote on the tip. Two-fourths into the slot, all awake validators merge their buffers into their local view and run the optimistic fast confirmation rule.
In particular, at round $4\Delta t + 2\Delta$, a validator merges its buffer and view, then marks a block $B$ proposed at the same slot $t$ as fast confirmed if $G$
contains a subset $G&#39;$ of slot $t$ votes by distinct validators for $B$ such that more than $\frac{3}{4}$ of the eligible voters of slot $t$ voted for $B$. In this case, $B$ and its prefix are output as the Goldfish ledger at round $4\Delta t + 3\Delta$. If no block is fast confirmed $2\Delta$ rounds into a slot in the view of a validator, the validator uses the $\kappa$-slots-deep confirmation rule, i.e., the slow confirmation rule, at round $4\Delta t + 3\Delta$ to output the Goldfish ledger. However, validators do not roll back their ledgers: if the validator has previously fast confirmed a block within the last $\kappa$ slots, it continues to output that block.
Finally, three-fourths into the slot, all awake validators again merge their buffers into their local view, and output a ledger according to GHOST-Eph.</em> [<a href="https://arxiv.org/pdf/2209.03255.pdf" rel="nofollow">https://arxiv.org/pdf/2209.03255.pdf</a>]</p>
<p dir="auto">Goldfish guarantees the following properties, and the proof can be found in the <a href="https://arxiv.org/pdf/2209.03255.pdf" rel="nofollow">full paper</a>.</p>
<ul dir="auto">
<li>
<strong>Reorg resilience</strong>: Suppose the validator that has the proposal with the minimum VRF output within a slot is an honest validator. Then, the block proposed by that validator enters and stays in the canonical GHOST-Eph chain adopted by any honest validator at all future slots.</li>
<li>
<strong>Security</strong>: Goldfish satisfies <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$T_{\text{conf}}$</math-renderer>-security for <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$T_{\text{conf}} = \kappa$</math-renderer> slots with overwhelming probability.</li>
</ul>
<p dir="auto">Observe that <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$T_{\text{conf}}$</math-renderer> is a polynomial function of a security parameter \kappa$. Moreover, a state machine replication protocol that outputs a ledger <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$\mathscr{ch}$</math-renderer> is <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$T_{\text{conf}}$</math-renderer>-secure after time <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$T$</math-renderer>, and has transaction confirmation time <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$T_{\text{conf}}$</math-renderer>, if <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$\mathscr{ch}$</math-renderer> satisfies <strong>Safety</strong> : For any two rounds <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$t, t′ \ge T$</math-renderer>, and any two honest validators <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$v_i$</math-renderer> and <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$v_j$</math-renderer> (possibly <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$i = j$</math-renderer>) awake at rounds <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$t$</math-renderer> and <math-renderer data-static-url="https://github.githubassets.com/static" data-run-id="7615c486d900ad8e42baece0cddcd601">$t′$</math-renderer> respectively, either ledger $\mathscr{ch}<em>i^t$ is the same as, or a prefix of $\mathscr{ch}<em>j^{t&#39;}$ or vice-versa; and <strong>Liveness</strong>: If a transaction is received by an awake honest validator at some round $t \ge T$, then for any round $t′ \ge t + T</em>{\text{conf}}$ and any honest validator $v_i$ awake at round $t&#39;$, the transaction will be included in $\mathscr{ch}</em>{t&#39;}^i$.</p>
<p dir="auto">Despite the security guarantees ensured by Goldfish, vote expiry as it is in this protocol leads to some problems. In particular, blocks in Goldfish do not accumulate safety against asynchrony as time goes on. This is because vote expiry after one slot means that <em>Goldfish cannot tolerate a single slot in which all honest validators are asleep or in which they cannot hear from the other honest validators due to adversarially induced network delay.</em> [<a href="https://arxiv.org/pdf/2209.03255.pdf" rel="nofollow">https://arxiv.org/pdf/2209.03255.pdf</a>]</p>
</article>
  </div>

    </div>

  </div></div>
  </body>
</html>
