<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://scattered-thoughts.net/writing/testing/">Original</a>
    
    <div id="readability-page-1" class="page"><article><p><em>This post is part of a series, starting at <a href="https://danluu.com/writing/reflections-on-a-decade-of-coding">Reflections on a decade of coding</a>.</em></p><p>This will be a short entry because I agree with almost everything written <a href="https://matklad.github.io/2021/05/31/how-to-test.html">here</a>. Read that first.</p><hr/><p>I think about tests in terms of <a href="https://buttondown.email/hillelwayne/archive/defense-in-depth-is-actually-a-good-thing/">defense in depth</a>, value-for-effort and debugging efficiency.</p><p>Debugging efficiency is not something I see discussed often and it&#39;s the only place where I disagree slightly with Aleksey&#39;s post above. The more that happens between the cause of a bug and the actual test failure, the longer it takes to track down the bug. So I tend to write unit tests for code which is:</p><ul><li>likely to be wrong</li><li>hard to debug from integration tests</li></ul><p>Eg in <a href="https://github.com/jamii/dida">dida</a> I wrote a lot of unit tests for things like frontier compaction and diff coalescing. These areas are also exercised by integration tests, but when an integration test fails it&#39;s a lot of work to track that failure back to some off-by-one bug in a merge sort deep inside the dataflow graph. So testing them directly saves me a lot of debugging time.</p><hr/><p>Aleksey&#39;s post also briefly mentions generating structured input from fuzzer-supplied bytes. For an in-depth explanation see <a href="https://hypothesis.works/articles/how-hypothesis-works/">How hypothesis works</a>. It&#39;s easy to implement from scratch in any language.</p><hr/><p>It&#39;s useful to be able to mark tests as known failures. They should be reported as such in the output, but not cause the test suite to fail.</p><p>When I find a bug that I&#39;m not going to fix immediately, I add it as a failing test with a link to the issue. If I later accidentally fix the bug, the test suite will fail and I&#39;ll know to mark the test as passing and close the issue. That prevents out-of-date issues hanging around.</p><hr/><p>It&#39;s really hard to test non-determistic code. I&#39;m willing to eat a lot of pain at design time to avoid doing so.</p><p>For code which generates random numbers, it often isn&#39;t sufficient to fix the seed. For example:</p><pre><code><span>fn foo() void {
</span><span>    const a = random_int();
</span><span>    const b = random_int();
</span><span>    do_stuff_with(a,b);
</span><span>}
</span></code></pre><p>If I change this to:</p><pre><code><span>fn foo() void {
</span><span>    const b = random_int();
</span><span>    const a = random_int();
</span><span>    do_stuff_with(a,b);
</span><span>}
</span></code></pre><p>A test with a fixed seed might now start failing, even though this change does not make the code more or less correct.</p><p>In this silly example it&#39;s easy to see what happened, but I&#39;ve run into similar problems in real code and it often takes me a long time to figure out that the failure wasn&#39;t really caused by my changes, but by some reordering of operations resulting in different random choices.</p><p>This can also come up with any multithreaded code, code that uses timeouts, any IO that exposes race conditions etc.</p><hr/><p>One way to get a lot more value from testing, especially fuzzing, is to write a lot of asserts over internal invariants.</p><p>These can be arbitrarily expensive and test complex global invariants. I like to write these as a function which takes some object and returns a list of errors. Then I insert calls like this:</p><pre><code><span>if (test_mode) assert_empty(self.validate())
</span></code></pre><p>Eg <a href="https://github.com/jamii/dida/blob/0f640092ac1506f71e6829778d8d5cc98373d0c9/lib/dida/debug.zig#L307-L467">here</a> is a function in dida that scans the entire state of the dataflow looking for accidentally aliased pointers. It returns errors that look like this:</p><pre><code><span>[
</span><span>    ValidationError{
</span><span>        .Aliasing = [
</span><span>            [
</span><span>                &#34;node_frontiers&#34;,
</span><span>                &#34;4&#34;,
</span><span>                &#34;frontier&#34;,
</span><span>            ],
</span><span>            [
</span><span>                &#34;node_states&#34;,
</span><span>                &#34;7&#34;,
</span><span>                &#34;Join&#34;,
</span><span>                &#34;index_input_frontiers&#34;,
</span><span>                &#34;0&#34;,
</span><span>            ],
</span><span>        ]
</span><span>    },
</span><span>]
</span><span>thread 9322 panic: Found invalid shard state. See errors above.
</span><span>/home/jamie/dida/lib/dida/util.zig:22:5: 0x38e831 in lib.dida.util.panic (build)
</span><span>    @panic(buf.toOwnedSlice());
</span><span>    ^
</span><span>/home/jamie/dida/lib/dida/debug.zig:313:16: 0x37654f in lib.dida.debug.validateOrPanic (build)
</span><span>        u.panic(&#34;Found invalid shard state. See errors above.&#34;, .{});
</span><span>               ^
</span><span>/home/jamie/dida/native-debugger/main.zig:219:31: 0x3404e0 in tryEmitDebugEvent (build)
</span><span>    dida.debug.validateOrPanic(global_allocator, shard);
</span><span>                              ^
</span><span>/home/jamie/dida/native-debugger/main.zig:208:22: 0x2e9258 in emitDebugEvent (build)
</span><span>    tryEmitDebugEvent(shard, debug_event) catch
</span><span>                     ^
</span></code></pre><p>This brings the test failure much closer to the cause of the bug, and is much easier to debug than eg a dataflow that produces subtly wrong output because it mutated a frontier that was used in two different places.</p><hr/><p>Aleksey&#39;s post also mentioned <a href="https://buttondown.email/hillelwayne/archive/cross-branch-testing/">rho problems</a> - code which is hard to test because we don&#39;t know how to specify the correct output.</p><p>Sometimes you can deal with this by finding two different ways to compute the output and testing that they always agree. You could write two completely different algorithms, or you can just find ways to tweak the existing one. Eg in a compiler, you can test that turning various optimizations on and off does not affect the output of random programs.</p><p>A neat example of this, which I can&#39;t remember the source of, is testing <a href="https://en.wikipedia.org/wiki/DWARF">DWARF</a> metadata. Compiler optimizations sometimes mess up their provenenance tracking and report the wrong location for variables. It&#39;s hard to test that the DWARF metadata is correct but what you can do is take a random program, insert a breakpoint, compile it in debug mode and release mode, run both in a debugger and check that at the breakpoint both versions show the same values for each variable in scope.</p><p>This is similar to <a href="https://www.hillelwayne.com/post/metamorphic-testing/">metamorphic testing</a>, but we&#39;re changing the code being tested rather than the input.</p><hr/><p>Infrastructure for fuzzing can be tricky. To discover as many bugs as possible it&#39;s worth running fuzzers continuously to explore random inputs. But you don&#39;t want to do this in CI because the failures will be non-deterministic.</p><p>So I like to have a separate server which continually fuzzes the latest master and reports any failures. Periodically I take the corpus from that server and check it in to the repo, so that in CI we can just run that fixed corpus and if it fails we know that it&#39;s a regression caused by the latest commit rather than an preexisting bug that has only just been discovered.</p><hr/><p>Perf tests are hard because performance usually isn&#39;t deterministic.</p><p>At minimum we want to run benchmarks automatically, either per commit in CI, or daily if the benchmarks take a long time. Record the results in a database somewhere, make a graph that shows results over time, and put it somewhere visible. That way we can see the trend over time and figure out where major regressions happened.</p><p>This doesn&#39;t prevent the &#39;death by a thousand cuts&#39; failure mode, where each commit makes perf very slightly worse but the individual effects are lost in the noise. I&#39;ve seen several projects tackle this by finding something other than time to measure (eg cpu instructions, cache misses) and then working hard to make those measurements deterministic (<a href="https://sqlite.org/cpu.html#performance_measurement">eg</a>, <a href="https://hackmd.io/sH315lO2RuicY-SEt7ynGA">eg</a>, <a href="https://buttondown.email/nelhage/archive/f6e8eddc-b96c-4e66-a648-006f9ebb6678">additional commentary</a>). I haven&#39;t done this yet but it seems worth learning how to do.</p></article></div>
  </body>
</html>
