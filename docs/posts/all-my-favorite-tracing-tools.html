<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://thume.ca/2023/12/02/tracing-methods/">Original</a>
    <h1>All my favorite tracing tools</h1>
    
    <div id="readability-page-1" class="page"><div>


<p>Ever wanted more different ways to understand what’s going on in a program? Here I catalogue a huge variety of tracing methods you can use for varying types of problems. Tracing has been such a long-standing interest (and job) of mine that some of these will novel and interesting to anyone who reads this. I’ll guarantee it by including 2 novel tracing tools I’ve made and haven’t shared before (look for this: <span><em>Tooling drop!</em></span>).</p>
<p>What I see as the key parts of tracing are collecting timestamped data on what happened in a system, and then ideally visualizing it in a timeline UI instead of just as a text log. First I’ll cover my favorite ways of really easily getting trace data into a nice timeline UI, because it’s a superpower that makes all the other tracing tools more interesting. Then I’ll go over ways to get that data, everything from instrumentation to binary patching to processor hardware features.</p>
<p>I’ll also give a real-life example of combining eBPF tracing with Perfetto visualization to diagnose tail latency issues in huge traces by using a number of neat tricks. Look for the “eBPF Example” section.</p>
<p><strong>Note:</strong> I’m hiring for my accelerator optimization team at Anthropic! See <a href="#conclusion-if-you-liked-this-you-may-like-my-team-at-anthropic">the bottom of the post</a> for more detail.</p>

<p>Getting event data onto a nice zoomable timeline UI is way easier than most people think. Here’s my favorite method I do all the time which can take you from logging your data to visualizing it in minutes:</p>
<div><div><pre><code><span># from:
</span><span>print</span><span>(</span><span>&#34;%d: %s %d&#34;</span> <span>%</span> <span>(</span><span>event_name</span><span>,</span> <span>timestamp</span><span>,</span> <span>duration</span><span>))</span>
<span># to:
</span><span>with</span> <span>open</span><span>(</span><span>&#39;trace.json&#39;</span><span>,</span><span>&#39;w&#39;</span><span>)</span> <span>as</span> <span>f</span><span>:</span>
  <span>f</span><span>.</span><span>print</span><span>(</span><span>&#34;[&#34;</span><span>)</span>
  <span>f</span><span>.</span><span>print</span><span>(</span><span>&#39;{&#34;name&#34;: &#34;%s&#34;, &#34;ts&#34;: %d, &#34;dur&#34;: %d, &#34;cat&#34;: &#34;hi&#34;, &#34;ph&#34;: &#34;X&#34;, &#34;pid&#34;: 1, &#34;tid&#34;: 1, &#34;args&#34;: {}}</span><span>\n</span><span>&#39;</span> <span>%</span>
    <span>(</span><span>event_name</span><span>,</span> <span>timestamp</span><span>,</span> <span>duration</span><span>))</span>
  <span>f</span><span>.</span><span>print</span><span>(</span><span>&#34;]&#34;</span><span>)</span> <span># this closing ] isn&#39;t actually required
</span></code></pre></div></div>
<p>This is the power of the <a href="https://docs.google.com/document/d/1CvAClvFfyA5R-PhYUmn5OOQtYMH4h6I0nSsKchNAySU/preview">Chromium Event JSON Format</a>. It’s a super simple JSON format that supports a bunch of different kinds of events, and is supported by a lot of different profile visualizer tools.</p>
<p>You can view the resulting tracing files in Google’s Perfetto trace viewer by going to <a href="https://ui.perfetto.dev/">https://ui.perfetto.dev/</a>, or in the older Catapult viewer (which is nicer for some traces) by going to <code>chrome://tracing</code> in Chrome. You can play around with the UI by <a href="https://ui.perfetto.dev/">going to Perfetto</a> and clicking “Open Chrome Example” in the sidebar. Here’s a screenshot showing an event annotated with arguments and flow event arrows:</p>
<p><a href="https://thume.ca/assets/postassets/tracing/perfetto.png"><img src="https://thume.ca/assets/postassets/tracing/perfetto.png" alt="Perfetto Screenshot"/></a></p>
<p>Me and my coworkers do this all the time at work, whip up trace visualizations for new data sources in under an hour and add them to our growing set of trace tools. We have a Python utility to turn a trace file into a clickable permanently-saved intranet link we can share with coworkers in Slack. This is easy to set up by building a copy of Perfetto and uploading to a file hosting server you control, and then putting trace files on that server and generating links using Perfetto’s <code>?url=</code> parameter. We also write custom trace analysis scripts by loading the simple JSON into a Pandas dataframe.</p>
<p>I like Perfetto as its use of WebAssembly lets it scale to about 10x more events than Catapult (although it gets laggy), and you have the escape hatch of the native backend for even bigger traces. Its <a href="https://perfetto.dev/docs/analysis/common-queries">SQL query feature</a> also lets you find events and annotate them in the UI using arbitrary predicates, including <a href="https://perfetto.dev/docs/analysis/stdlib-docs">special SQL functions</a> for dealing with trace stacks.</p>
<p><strong>UI protip</strong>: Press <code>?</code> in Perfetto to see the shortcuts. I use both <code>WASD</code> and <code>CTRL+scroll</code> to move around.</p>
<h3 id="advanced-format-fuchsia-trace-format">Advanced Format: Fuchsia Trace Format</h3>
<p>The Chromium JSON format can produce gigantic files and be very slow for large traces, because it repeats both the field names and string values for every event. Perfetto also supports the <a href="https://fuchsia.dev/fuchsia-src/reference/tracing/trace-format">Fuchsia Trace Format (FTF)</a> which is a simple compact binary format with an incredible spec doc that makes it easy to produce binary traces. It supports interning strings to avoid repeating event names, and is designed around 64 byte words and supports clock bases so that you can directly write timestamp counters and have the UI compute the true time.</p>
<p>When I worked at Jane Street I <a href="https://github.com/janestreet/tracing/blob/master/zero/writer.ml">used this to log instrumentation events to a buffer directly in FTF</a> as they occurred in &lt;10ns per span (it would have been closer to 4ns if it wasn’t for OCaml limitations).</p>
<h3 id="advanced-format-perfetto-protobuf">Advanced Format: Perfetto Protobuf</h3>
<p>Another format which is similarly compact, and also supports more features, is <a href="https://github.com/google/perfetto/blob/master/protos/perfetto/trace/perfetto_trace.proto">Perfetto’s native Protobuf trace format</a>. It’s documented only in comments in the proto files and is a bit trickier to figure out, but might be a bit easier to generate if you have access to a protobuf library. It enables access to advanced Perfetto features like including callstack samples in a trace, which aren’t available with other formats. It’s slower to write than FTF, although Perfetto has a <a href="https://perfetto.dev/docs/design-docs/protozero">ProtoZero</a> library to make it somewhat faster.</p>
<p>This can be really tricky to get right though and I had to reference the Perfetto source code to figure out error codes in the “info and stats” tab a lot. The biggest gotchas are you need to set <code>trusted_packet_sequence_id</code> on every packet, have a <code>TrackDescriptor</code> for every track, and set <code>sequence_flags=SEQ_INCREMENTAl_STATE_CLEARED</code> on the first packet.</p>
<h3 id="other-tools">Other tools</h3>
<p>Some other nice trace visualization tools are <a href="https://github.com/jlfwong/speedscope">Speedscope</a> which is better for a hybrid between profile and trace visualization, <a href="https://github.com/google/pprof">pprof</a> for pure profile call graph visualization, and <a href="https://www.rerun.io/">Rerun</a> for multimodal 3D visualization. Other profile viewers I like less but which have some nice parts include <a href="https://eclipse.dev/tracecompass/">Trace Compass</a> and the <a href="https://profiler.firefox.com/docs/#/">Firefox Profiler</a>.</p>

<p>Now lets go over all sorts of different neat tracing methods! I’ll start with some obscure and interesting low level ones but I promise I’ll get to some more broadly usable ones after.</p>
<h2 id="hardware-breakpoints">Hardware breakpoints</h2>
<p>For ages, processors have supported <strong>hardware breakpoint registers</strong> which let you put in a small number of memory addresses and have the processor interrupt itself when any of them are accessed or executed.</p>
<h3 id="perf-and-perftrace">perf and perftrace</h3>
<p>Linux exposes this functionality through <code>ptrace</code> but also through the <a href="https://man7.org/linux/man-pages/man2/perf_event_open.2.html"><code>perf_event_open</code> syscall</a> and the <a href="https://man7.org/linux/man-pages/man1/perf-record.1.html"><code>perf record</code> command</a>. You can record a process like <code>perf record -e \mem:0x1000/8:rwx my_command</code> and view the results with <code>perf script</code>. It costs about 3us of overhead every time a breakpoint is hit.</p>
<p><span><em>Tooling drop!</em></span> I wrote <a href="https://github.com/trishume/perftrace">a tiny Python library called perftrace</a> with a C stub which calls the <code>perf_event_open</code> syscall to record timestamps and register values when the breakpoints were hit.</p>
<p>It currently only supports execution breakpoints but you can also breakpoint on reads or writes of any memory and it would be <a href="https://github.com/trishume/perftrace/blob/d074e65bf71e8af10335164111969f96263d283a/perftrace.c#L61">easy to modify the code to do that</a>. Hardware breakpoints are basically the only way to watch for accessing a specific memory address at a fine granularity which doesn’t add overhead to code which doesn’t touch that memory.</p>
<h3 id="gdb-scripting">GDB scripting</h3>
<p>In addition to using it manually, you can automate the process of following the execution of a program using debugger breakpoints by using GDB’s Python scripting interface. This is slower than perf breakpoints but gives you the ability to inspect and modify memory when you hit breakpoints. <a href="https://github.com/hugsy/gef">GEF</a> is an extension to GDB that in addition to making it much nicer in general, also extends the Python API with a bunch of handy utilities.</p>
<p><span><em>Tooling drop!</em></span> <a href="https://gist.github.com/trishume/fe3b3b90a7e524c976ecb98053bb7f86">Here’s an example GDB script I wrote using GEF which gives examples of how to puppeteer, trace and inspect a program</a></p>
<h2 id="intel-processor-trace">Intel Processor Trace</h2>
<p><a href="https://easyperf.net/blog/2019/08/23/Intel-Processor-Trace">Intel Processor Trace</a> is a hardware technology on Intel chips since Skylake which allows recording a trace of <em>every instruction the processor executes</em> via recording enough info to reconstruct the control flow in a super-compact format, along with fine-grained timing info. It has extremely low overhead since it’s done by hardware and writes bypass the cache so the only overhead is reducing main memory bandwidth by about 1GB/s. I see no noticeable overhead at all on most program benchmarks I’ve tested.</p>
<p>You can access a dump of the assembly instructions executed in a recorded region using <a href="https://man7.org/linux/man-pages/man1/perf-intel-pt.1.html"><code>perf</code></a>, <a href="https://lldb.llvm.org/use/intel_pt.html"><code>lldb</code></a> and <a href="https://easyperf.net/blog/2019/08/30/Intel-PT-part2"><code>gdb</code></a>.</p>
<h3 id="magic-trace">magic-trace</h3>
<p>However assembly traces aren’t useful to most people, so when at Jane Street I created <a href="https://github.com/janestreet/magic-trace">magic-trace</a> along with my intern Chris Lambert, which generates a trace file (using FTF and Perfetto as described above) which visualizes <em>every function call</em> in a program execution. Jane Street generously open-sourced it so anyone can use it! Since then it’s been extended to support tracing into the kernel as well. I wrote <a href="https://blog.janestreet.com/magic-trace/">a blog post about how it works for the Jane Street tech blog</a>.</p>
<p><img src="https://github.com/janestreet/magic-trace/raw/master/docs/assets/stage-3.gif" alt="magic-trace demo"/></p>
<p>Processor Trace can record to a ring buffer, and <code>magic-trace</code> uses the hardware breakpoint feature described earlier to let you trigger capture of the last 10ms whenever some function that signals an event you want to look at happened, or when the program ends. This makes it great for a bunch of scenarios:</p>
<ul>
<li>Debugging rare tail latency events: Add a trigger function call after something takes unusually long, and then leave magic-trace attached in production. Because it captures everything you’ll never have not logged enough data to identify the slow part.</li>
<li>Everyday performance analysis: A full trace timeline can be easier to interpret than a sampling profiler visualization, especially because it displays the difference between a million fast calls to a function and one slow call.
<ul>
<li>It’s typical to find performance problems on systems that had only ever been analyzed with a sampling profiler by noticing the first time you magic-trace the program that many functions are being called more times than expected or in locations you didn’t expect.</li>
</ul>
</li>
<li>Debugging crashes: When a program crashes for reasons you don’t understand, you can just run it under magic-trace and see every function call leading up to the crash, which is often enough to figure out why the crash happened without adding extra logging or using a debugger!</li>
</ul>
<p>If you want to modify magic-trace to suit your needs, it’s open-source OCaml. And if you like Rust more than OCaml someone made a simple Rust port called <a href="https://github.com/michoecho/perf2perfetto">perf2perfetto</a>.</p>
<p>Unfortunately, Processor Trace isn’t supported on many virtual machines that use compatible Intel Hardware. Complain to your cloud provider to add support in their hypervisor or try bare-metal instances!</p>
<h2 id="instrumentation-based-tracing-profilers">Instrumentation-based tracing profilers</h2>
<p>What most people use to get similar benefits to magic-trace traces, especially in the gamedev industry, is low-overhead instrumentation-based profilers with custom UIs. One major advantage of instrumentation-based traces is they can contain extra information about data and not just control flow, putting arguments from your functions into the trace can be key for figuring out what’s going on. These tools often support including other data sources such as OS scheduling info, CPU samples and GPU trace data. Here’s my favorite tools like this and their pros/cons:</p>
<h3 id="tracy"><a href="https://github.com/wolfpld/tracy">Tracy</a></h3>
<p><a href="https://github.com/wolfpld/tracy"><img src="https://github.com/wolfpld/tracy/raw/master/doc/profiler.png" alt="Tracy screenshot"/></a></p>
<ul>
<li>Cross platform, including good Linux sampling and scheduling capture</li>
<li>Overhead of only 2ns/span, supports giant traces with hundreds of millions of events</li>
<li>Really nice and fast UI with tons of features (check out the <a href="https://www.youtube.com/watch?v=30wpRpHTTag">demo</a> <a href="https://www.youtube.com/watch?v=_hU7vw00MZ4">videos</a> in the readme)</li>
<li>Integrates CPU sampling with detailed source and assembly analysis</li>
<li>Popular so there are bindings in non-C++ languages like <a href="https://docs.rs/tracing-tracy/latest/tracing_tracy/">Rust</a> and <a href="https://github.com/nektro/zig-tracy">Zig</a>.</li>
<li>Con: Only supports a single string/number argument to events</li>
<li>Con: Timeline is overly aggressive in collapsing small events into squiggles (<a href="https://thume.ca/2021/03/14/iforests/">see my post on this</a>).</li>
</ul>
<h3 id="optick"><a href="https://github.com/bombomby/optick">Optick</a></h3>
<p><a href="https://www.youtube.com/watch?v=p57TV5342fo"><img src="https://github.com/bombomby/brofiler/raw/gh-pages/images/VideoThumbnail.jpg" alt="Optick screenshot"/></a></p>
<ul>
<li>Cross-platform, lots of features, very nice UI</li>
<li>Supports multiple named arguments per event</li>
<li>Con: Not as fleshed-out for non-game applications</li>
<li>Con: sampling integration only works on Windows</li>
</ul>
<h3 id="perfetto"><a href="https://perfetto.dev/docs/instrumentation/tracing-sdk">Perfetto</a></h3>
<ul>
<li>Perfetto UI is nice, events can include arguments and flow event arrows</li>
<li>Integrates with other Perfetto data sources like OS events and sampling</li>
<li>Con: Higher overhead of around 600ns/span when tracing enabled</li>
<li>Con: UI doesn’t scale to traces as large as the above two programs</li>
</ul>
<h3 id="other-programs">Other programs</h3>
<p>There’s a bunch more similar small programs that generally come with their own instrumentation library and their own WebGL profile viewer. These are generally more lightweight and can be easier to integrate. For example <a href="https://gravitymoth.com/spall/spall-web.html">Spall</a>, <a href="https://github.com/jonasmr/microprofile">microprofile</a>, <a href="https://github.com/Celtoys/Remotery">Remotery</a>, <a href="https://github.com/EmbarkStudios/puffin">Puffin (Rust-native)</a>, <a href="https://github.com/mikesart/gpuvis">gpuviz</a>. I must also mention the <a href="https://github.com/janestreet/tracing">OCaml tracing instrumentation library I wrote for Jane Street</a> which has overheads under 10ns/span via a compile-time macro like the C++ libraries.</p>
<h2 id="ebpf">eBPF</h2>
<p>If you want to trace things using the Linux kernel there’s a new game in town, and it’s awesome. The eBPF subsystem allows you to attach complex programs to all sorts of different things in the kernel and efficiently shuttle data back to userspace, basically subsuming all the legacy facilities like ftrace and kprobes such that I won’t talk about them.</p>
<p>Things you can trace include: syscalls, low overhead tracepoints throughout the kernel, hardware performance counters, any kernel function call and arbitrary breakpoints or function calls/returns in userspace code. Combined these basically let you see anything on the system in or out of userspace.</p>
<p>You normally write BPF programs in C but there are perhaps even nicer toolkits for using <a href="https://github.com/tw4452852/zbpf">Zig</a> and <a href="https://aya-rs.dev/">Rust</a>.</p>
<p>There’s <a href="https://ebpf.io/applications/">a whole bunch of ways to use eBPF</a> and I’ll talk about some of my favorites here. Some other favorites I won’t go into in detail are <a href="https://rubrikinc.github.io/wachy/">Wachy</a> and <a href="https://github.com/anakryiko/retsnoop">retsnoop</a>.</p>
<h3 id="bcc-easy-python-api-for-ebpf">BCC: Easy Python API for eBPF</h3>
<p>The <a href="https://github.com/iovisor/bcc">BPF Compiler Collection (BCC)</a> is a library with really nice Python bindings for compiling eBPF programs from C source code, injecting them, and getting the data back. It has a really nice feature where you can write a C struct to hold the event data you want to record, and then it will parse that and expose it so you can access the fields in Python. Check out <a href="https://github.com/iovisor/bcc/blob/master/examples/ringbuf/ringbuf_output.py">how simple this syscall tracing example is</a>.</p>
<p>I really like having the full power of Python to control my tracing scripts. BCC scripts often use Python string templating to do compile time metaprogramming of the C to compose the exact probe script you want, and then do data post-processing in Python to present things nicely.</p>
<h3 id="bpftrace-terse-dsl-for-ebpf-tracing">bpftrace: terse DSL for eBPF tracing</h3>
<p>If you want a terser way to compose tracing programs, in the style of dtrace, check out <a href="https://github.com/iovisor/bpftrace">bpftrace</a>. It lets you write one liners like these:</p>
<div><div><pre><code><span># Files opened by process</span>
bpftrace <span>-e</span> <span>&#39;tracepoint:syscalls:sys_enter_open { printf(&#34;%s %s\n&#34;, comm, str(args-&gt;filename)); }&#39;</span>

<span># Count LLC cache misses by process name and PID (uses PMCs):</span>
bpftrace <span>-e</span> <span>&#39;hardware:cache-misses:1000000 { @[comm, pid] = count(); }&#39;</span>
</code></pre></div></div>
<h3 id="ply-simpler-bpftrace">ply: simpler bpftrace</h3>
<p>If you want something like bpftrace but simpler and faster with no LLVM dependencies. Check out <a href="https://wkz.github.io/ply/">ply</a>.</p>
<div><div><pre><code><span># Which processes are receiving errors when reading from the VFS?</span>
ply <span>&#39;kretprobe:vfs_read if (retval &lt; 0) { @[pid, comm, retval] = count(); }&#39;</span>
</code></pre></div></div>
<h2 id="ebpf-example-anthropics-perfetto-based-packet-and-user-event-tracing">eBPF Example: Anthropic’s Perfetto-based packet and user event tracing</h2>
<p>For work at Anthropic I wanted to analyze tail latency of some networking code so I used BCC and hooked into low-overhead kernel probe points to trace info from every single packet into a ring buffer. I could even include fields pulled from the packet header and NIC queue information, all at 1 million packets per second with no noticeable overhead.</p>
<h3 id="trick-for-tracing-userspace-events-with-low-overhead-in-ebpf">Trick for tracing userspace events with low overhead in eBPF</h3>
<p>I wanted to correlate packets with userspace events from a Python program, so I used a fun trick: Find a syscall which has an early-exit error path and bindings in most languages, and then trace calls to that which have specific arguments which produce an error. I traced the <code>faccessat2</code> syscall such that in Python <code>os.access(event_name, -932, dir_fd=-event_type)</code> where <code>event_type</code> was an enum for start, stop and instant events would log spans to my Perfetto trace. This had an overhead of around 700ns/event, which is in a similar league to Perfetto’s full-userspace C++ instrumentation, and a lot of that is Python call overhead. The <code>os.access</code> function is especially good because when the syscall errors it doesn’t incur overhead by generating a Python exception like most other syscall wrappers do.</p>
<h3 id="how-to-process-events-more-quickly-using-a-c-helper-with-bcc">How to process events more quickly using a C helper with BCC</h3>
<p>With 1 million packets per second I had a problem that with rare tail latency events, my traces quickly got huge and lagged Perfetto. I wanted to only keep data from shortly before one of my userspace send events took too long. Normally you’d do this with a circular buffer that gets snapshotted, and it would be possible to implement that in eBPF. But I didn’t want to implement my own ringbuf and the included ones don’t support wraparound overwriting. So instead I used the internal <code>_open_ring_buffer</code> function to register a ctypes C function as a ringbuffer callback instead of a Python function, and wrote an efficient C callback to filter out packets near a tail latency event before passing those to Python.</p>
<h3 id="perks-of-perfetto-visualization">Perks of Perfetto visualization</h3>
<p>I used the Perfetto Protobuf format with interned strings in order to keep trace size down to a few bytes per packet.</p>
<p>I could use Perfetto’s SQL support in the resulting trace to query for send events above a certain time threshold after startup in a specific process. Here’s a screenshot showing a long send event coinciding with packets starting to be paced out with larger gaps on one of the queues, including the ability to have line graph tracks:</p>
<p><a href="https://thume.ca/assets/postassets/tracing/packettrace.png"><img src="https://thume.ca/assets/postassets/tracing/packettrace.png" alt="Perfetto Packet Trace"/></a></p>
<p>I think it’s kinda crazy that we have all these different mostly-text-based BPF tools rather than a framework that lets you put all sorts of different kinds of system events into a trace UI, including easily scripting your own new events. It’s so much easier to investigate this kind of thing with a timeline UI. I started building that framework at Anthropic, but only spent a week on it since I’ve had higher priority things to do since I did the packet latency investigation.</p>
<h2 id="binary-instrumentation">Binary Instrumentation</h2>
<p>When you’re instrumenting userspace programs in a way where the overhead of kernel breakpoints is too high, but you don’t have access to the source code, perhaps because you’re reverse-engineering something, then it may be time for binary instrumentation.</p>
<h3 id="bpftime-ebpf-based-binary-instrumentation">bpftime: eBPF-based binary instrumentation</h3>
<p>One easy way that’s a good segue is <a href="https://github.com/eunomia-bpf/bpftime">bpftime</a> which takes your existing eBPF programs with userspace probes, and runs them much faster by patching the instructions to run the BPF program inside the process rather than incurring 3us of kernel interrupt overhead every time.</p>
<h3 id="e9patch">E9Patch</h3>
<p>For more sophisticated binary patching on x86, look to <a href="https://github.com/GJDuck/e9patch">E9Patch</a>.</p>
<p>On some architectures, patching can be really easy since you just patch the instruction you want to trace with a jump to a piece of “trampoline” code which has your instrumentation, and then the original instruction and a jump back.</p>
<p>It’s much harder on x86 since instructions are variable length, so if you just patch a jump over a target instruction, occasionally that’ll cause problems since some other instruction jumps to an instruction your longer jump had to stomp over.</p>
<p>People have invented all kinds of clever tricks to get around these issues including “instruction punning” where you put your patch code at addresses which are also valid x86 nop or trap instructions. E9Patch implements very advanced versions of these tricks such that the patching should basically always work.</p>
<p>It comes with an API as well as a tool called <a href="https://github.com/GJDuck/e9patch/blob/master/doc/e9tool-user-guide.md">E9Tool</a> which lets you patch using a command line interface:</p>
<div><div><pre><code><span># print all jump instructions in the xterm binary</span>
<span>$ </span>e9tool <span>-M</span> jmp <span>-P</span> print xterm
jz 0x4064d5
jz 0x452c36
...
</code></pre></div></div>
<h3 id="frida">Frida</h3>
<p>The other way to get around the difficulty of static patching, when you have to be conservative around how jumps you don’t know about could be messed up by your patches, is dynamic binary instrumentation, where you basically puppeteer the execution of the program. This is the technique used by JIT VMs like Rosetta and QEMU to basically recompile your program as you run it.</p>
<p><a href="https://frida.re/">Frida</a> exposes this incredibly powerful technique in a general way you can script in Javascript using its “Stalker” interface. Allowing you to attach JS snippets to pieces of code or rewrite the assembly as it is run. It also lets you do more standard patching, although it doesn’t work as well on x86 as E9Patch.</p>
<h2 id="ld_preload">LD_PRELOAD</h2>
<p>If you just want to trace a function in a dynamic library like libc, you can use <code>LD_PRELOAD</code> to inject a library of your own to replace any functions you like. You can use <code>dlsym(RTLD_NEXT, &#34;fn_name&#34;)</code> to get the old implementation in order to wrap it. Check out <a href="https://axcheron.github.io/playing-with-ld_preload/">this tutorial post</a> for how.</p>
<h2 id="distributed-tracing">Distributed Tracing</h2>
<p>Distributed Tracing is where you can trace across different services via attaching special headers to requests and sending all the timing data back to a trace server. Some popular solutions are <a href="https://opentelemetry.io/">OpenTelemetry</a> (of which there are many implementations and UIs) and <a href="https://zipkin.io/">Zipkin</a>.</p>
<p>There’s some cool new solutions like <a href="https://odigos.io/">Odigos</a> that use eBPF to add distributed tracing support without any instrumentation.</p>
<h2 id="sampling-profilers">Sampling Profilers</h2>
<p>Sampling profilers take a sample of the full call stack of your program periodically. Typical profiler UIs don’t have the time axis I’d think of as part of “tracing”, but some UIs do. For example <a href="https://github.com/jlfwong/speedscope">Speedscope</a> accepts many profiler data formats and can visualize with a time axis, and <a href="https://github.com/mstange/samply">Samply</a> is an easy to use profiler which uses the Firefox Profiler UI, which also has a timeline view.</p>
<p>One neat sampling method used by <a href="https://github.com/benfred/py-spy">py-spy</a> and <a href="https://rbspy.github.io/">rbspy</a> is to use the <a href="https://man7.org/linux/man-pages/man2/process_vm_readv.2.html"><code>process_vm_readv</code> syscall</a> to read memory out of a process without interrupting it. If like an interpreter the process stores info about what it’s doing in memory, this can allow you to follow it with no overhead on the target process. You could even use this trick for low-overhead native program instrumentation: set up a little stack data structure where you push and pop pointers to span names or other context info, and then sample it from another program when needed using eBPF or <code>process_vm_readv</code>.</p>
<h2 id="qemu-instrumentation">QEMU Instrumentation</h2>
<p>When all other tracing tools fail, sometimes you have to fall back on the most powerful tool in the tracing toolbox: Full emulation and hooking into QEMU’s JIT compiler. This theoretically allows you to trace and patch both control flow <em>and</em> memory, in both userspace and the kernel, including snapshot and restore, across many architectures and operating systems.</p>
<p>However, actually doing this is not for the faint of heart and the tooling for it only barely exists.</p>
<h3 id="cannoli">Cannoli</h3>
<p><a href="https://github.com/MarginResearch/cannoli">Cannoli</a> is a tracing engine for qemu-user (so no kernel stuff) which patches QEMU to log execution and memory events to a high-performance ringbuffer read by a Rust extension you compile. This lets it trace with very low overhead by spreading the load of following the trace over many cores, at the cost of not being able to modify the execution.</p>
<p>It’s a bit tricky to use, you have to compile QEMU and Cannoli yourself at the moment, and it’s kind of a prototype so when I’ve used it in the past for CTFs I’ve often had to add new features to it.</p>
<h3 id="qemu-tcg-plugins">QEMU TCG Plugins</h3>
<p>QEMU has recently added <a href="https://www.qemu.org/docs/master/devel/tcg-plugins.html">plugin support for its TCG JIT</a>. Like Cannoli this is read-only for now, and its likely slower than Cannoli, but it works in qemu-system mode and exposes slightly different functionality.</p>
<h3 id="usercorn">usercorn</h3>
<p>My friend has an old project called <a href="https://github.com/lunixbochs/usercorn">usercorn</a> that is mostly bitrotted but has the ability to trace programs using QEMU and analyze them with Lua scripts and all sorts of fancy trace analysis. Someone (possibly him eventually) could theoretically revive it and rebase it on top of something like QEMU TCG plugins.</p>

<p>If you made it to the bottom and enjoyed all those different tracing strategies, you may also be interested in working on my team!</p>
<p>I lead the performance optimization team at <a href="https://www.anthropic.com/">Anthropic</a> (we build one of the world’s leading large language models, and have a heavy focus on figuring out how future more powerful models can go well for the world). We’ll be doing accelerator kernel optimization across GPUs, TPUs and Trainium. TPUs and Trainium are cool in that they’re simpler architectures where optimization is more like a cycle-counting puzzle, and they also have <a href="https://awsdocs-neuron.readthedocs-hosted.com/en/latest/tools/neuron-sys-tools/neuron-profile-user-guide.html">amazing tracing tools</a>. Almost nobody knows these new architectures, so we’re currently hiring high potential people with other kinds of low-level optimization experience who are willing to learn.</p>
<p>I plan for us to do a bunch of optimization work as compiler-style transformation passes over IRs, but simpler via being bespoke to the ML architecture we’re optimizing. These will parallelize architectures across machines, within a machine, and within a chip in similar ways. We also work closely with an amazing ML research team to do experiments together and come up with architectures that jointly optimize for ML and hardware performance.</p>
<p>Anthropic recently received ~$6B in funding commitments, and are investing it heavily in compute. We currently have ~5 performance specialists, with each one making an immense contribution in helping us have models that exhibit interesting capabilities for our alignment researcher and policy teams.</p>
<p>AI now is still missing a lot, but progress is incredibly fast. It’s hard for me to say the coming decade of progress won’t lead to AI as good as us at nearly all jobs, which would be the biggest event in history. Anthropic is unusually full of people who joined because they really care about ensuring this goes well. I think we have the world’s best alignment, interpretability research, and AI policy teams, and I personally work on performance optimization here because I think it’s the best way to leverage my comparative advantage to help the rest of our efforts succeed at steering towards AI going well for the world in the event it keeps up this pace.</p>
<p>If you too would like to do fun low-level optimization on what I think will be the most important technology of this decade and want to chat: Email me at <a href="https://thume.ca/cdn-cgi/l/email-protection" data-cfemail="86f2f4eff5f2e7e8c6e7e8f2eef4e9f6efe5a8e5e9eb">[email protected]</a> with a link or paragraph about the most impressive low-level or performance thing you’ve done. And feel free to check out some of
<a href="https://thume.ca/2023/01/02/one-machine-twitter/">my other</a> <a href="https://thume.ca/2021/03/14/iforests/">performance</a> <a href="https://thume.ca/2022/05/15/latency-testing-streaming/">writing</a>.</p>
</div></div>
  </body>
</html>
