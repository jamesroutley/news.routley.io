<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://tonsky.me/blog/humble-signals/">Original</a>
    <h1>Humble Chronicles: Managing State with Signals</h1>
    
    
        
        
        
        
        
        <p>After <a href="https://tonsky.me/blog/humble-state/">the previous post</a>, I figured that the best way to decide on the direction for Humble UI is to make an experiment.</p>

<p>And I did. I implemented a reactive/incremental computation engine (signals) and wrote a simple TodoMVC in it. Following are my thoughts on it.</p>

<h1 id="signals">Signals</h1>

<p>The idea behind signals is very simple: you declare some mutable (!) data sources:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(s/defsignal *width
  16)

(s/defsignal *height
  9)
</code></pre></div></div>

<p>And then create a derived (computed) state that depends on those:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(s/defsignal *area
  (println "Computing area of" @*width "x" @*height)
  (* @*width @*height))
</code></pre></div></div>

<p>Now, the first time you dereference <code class="language-plaintext highlighter-rouge">*area</code>, it is computed:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@*area =&gt; 144
;; Computing area of 16 x 9
</code></pre></div></div>

<p>After that, any subsequent read is cached (notice the lack of stdout):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@*area =&gt; 144
</code></pre></div></div>

<p>If any of the sources change, it is marked as dirty (but not immediately recomputed):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(s/reset! *width 20)
</code></pre></div></div>

<p>But if you try to read <code class="language-plaintext highlighter-rouge">*area</code> again, it will recompute and cache its value again:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@*area =&gt; 180
;; Computing area of 20 x 9

@*area =&gt; 180
;; (no println)
</code></pre></div></div>

<p>You can check out implementation <a href="https://github.com/HumbleUI/HumbleUI/blob/d111faa1fa27c5fa2d45264fdb718e6d1f980dd5/src/io/github/humbleui/signal.clj">here</a> and some usage examples <a href="https://github.com/HumbleUI/HumbleUI/blob/d111faa1fa27c5fa2d45264fdb718e6d1f980dd5/test/io/github/humbleui/signal_test.clj">here</a>. The implementation is a proof-of-concept, so maybe don’t use it in production.</p>

<h1 id="stable-object-references">Stable object references</h1>

<p>The appeal of signals is that, when data changes, only the necessary minimum of computations happens. This is, of course, cool, but not entirely free — it comes at a cost of some overhead for managing the dependencies.</p>

<p>I was particularly interested in using signals for Humble UI because they provide stable references. Let’s say you have a tabbed interface that has a checkbox that enables a text field:</p>

<figure><img src="https://tonsky.me/blog/humble-signals/ui.png" /></figure>

<p>Now, our state might look somewhat like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(s/defsignal *tab 
  :first)

(s/defsignal *checked?
  false)

(s/defsignal *text
  nil)

(s/defsignal *tab-content
  (column
    (ui/checkbox *checked?)
    (when @*checked?
      (ui/text-field *text))))

(s/defsignal *app
  (case @*tab
    :first  ...
    :second *tab-content
    :third  ...))
</code></pre></div></div>

<p>and the beauty of it is unless the user switches a tab or plays with a checkbox, <code class="language-plaintext highlighter-rouge">*tab-content</code> will be cached and NOT recomputed because its dependencies do not change!</p>

<p>And that means that no matter how many times we dereference <code class="language-plaintext highlighter-rouge">*tab-content</code> e.g. for rendering or layout, it will always return <em>exactly the same instance</em> of the checkbox and text field. As in, the same object. Same DOM node, if we were in the browser.</p>

<p>Cool? Cool! No diffing needed. No state tracking and positional memoization either. We can put all internal state into objects as fields and not invent any special “more persistent” storage solution at all!</p>

<p>This was my main motivation to look into incremental computations. I don’t really care about optimal performance, because—how much is there to compute in UI anyways?</p>

<p>And also—it’s not obvious to me that if you make every <code class="language-plaintext highlighter-rouge">+</code> and <code class="language-plaintext highlighter-rouge">concat</code> incremental it’ll be a net win because of overhead. But stable objects in a dynamic enough UI? Lack of diffing and VDOM? This is something I can use.</p>

<h1 id="props-drilling">Props drilling</h1>

<p>One of the examples where VDOM model doesn’t shine is props drilling. Imagine an app like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(ui/default-theme
  {:font-ui ...}
  (ui/column
    (ui/row
      (ui/tabs
        ...
        (ui/tab
          (ui/button
            (ui/label "Hello")))))))
</code></pre></div></div>

<p>The actual details don’t matter, but the point is: there’s a default theme at the very top of your app and a label somewhere deep down.</p>

<p>If you pass <code class="language-plaintext highlighter-rouge">font-ui</code> as an argument to every component, it will create a false dependency for every intermediate container that it passes through. When the time for the update comes, the whole UI will be re-created:</p>

<figure>
  <img src="https://tonsky.me/blog/humble-signals/drilling1.png" />
</figure>

<p>In a perfect world, though, <code class="language-plaintext highlighter-rouge">font-ui</code> change should only affect components that <em>actually use</em> that font. E.g. it shouldn’t affect paddings, backgrounds, or scrolls, but should affect labels and paragraphs.</p>

<p>Well, incremental computation solves this problem beautifully! If you make your default font a signal, then only components that <em>actually read it</em> will subscribe to its changes:</p>

<figure>
  <img src="https://tonsky.me/blog/humble-signals/drilling2.png" />
</figure>

<p>On the other hand, how often do you change fonts in the entire app? Should it really be optimized? The question of whether this use case is important remains open.</p>

<h1 id="reactive-vs-incremental">Reactive vs Incremental</h1>

<p>Now let’s dig into implementation details a little bit. What we have so far is, I believe, called reactive, but not incremental. To be called incremental we must somehow <em>reuse</em>, not just re-run, previous computations.</p>

<p>A simple example. Imagine we have a list of todos and a function to render them. Then we can define our UI like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(s/defsignal *todos
  ...)

(s/defsignal *column
  (ui/column
    (map render-todo @*todos)))
</code></pre></div></div>

<p>This would work fine the first time, but if we add a new to-do, the whole list will be re-rendered. <code class="language-plaintext highlighter-rouge">*todos</code> changes, <code class="language-plaintext highlighter-rouge">*column</code> body gets re-executed, <code class="language-plaintext highlighter-rouge">render-todo</code> is applied to <em>every</em> todo again by <code class="language-plaintext highlighter-rouge">map</code>.</p>

<p>To solve just this problem, we could introduce incremental <code class="language-plaintext highlighter-rouge">s/map</code> that only re-computes the mappings that were not computed before:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(def column
  (ui/column
    (s/map render-todo *todos)))
</code></pre></div></div>

<p>Under the hood, <code class="language-plaintext highlighter-rouge">s/map</code> caches previous computation and its result and, when re-evaluated, tries to reuse it as much as possible. Meaning, if it already saw the same todo before, it will return a cached version of <code class="language-plaintext highlighter-rouge">(render-todo todo)</code> instead of calculating it anew.</p>

<p>Two important things to note here. First, if we care about object identities, we <em>have</em> to use incremental map. Otherwise adding new todo to the end of the list will reset the internal component state of every other one. Not good!</p>

<p>Second, although “incremental map” sounds fancy and smart, under the hood it does the same thing that React does: diffing. It diffs new collection against previous collection and tries to find matches.</p>

<p>It is (probably) a perf win overall, but, more importantly, diff still does happen. That’s the reason why all incremental frameworks have their own versions of for/map:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{#each arr as el}
  &lt;li&gt;{el}&lt;/li&gt;
{/each}
</code></pre></div></div>

<p>I can imagine it could be better when a diff happens on the data layer instead of on the final UI layer because generated UI is usually much larger than the source data. Either way, at least you can choose where it happens.</p>

<p>The bad news is, you have to <em>think</em> about it, whereas in React model you usually don’t bother with such minute details at all.</p>

<p>One can imagine that we’ll need incremental versions of <code class="language-plaintext highlighter-rouge">filter</code>, <code class="language-plaintext highlighter-rouge">concat</code>, <code class="language-plaintext highlighter-rouge">reduce</code> etc, and our users will <em>have</em> to learn about them and use them if they want to keep stable identities. And we’ll have to provide enough incremental versions of base core functions to keep everyone happy, and potentially teach them to write their own. Sounds harsh.</p>

<h1 id="effects">Effects</h1>

<p>One important feature we’re missing in our incremental framework is effects.</p>

<p>We implement a mixed push/pull model: recalculating values is lazy (not done until explicitly requested), but marking as dirty is eager (immediate dependencies are marked as <code class="language-plaintext highlighter-rouge">:dirty</code> and their transitive deps are marked with <code class="language-plaintext highlighter-rouge">:check</code>, which means might or might not be dirty):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(s/defsignal *a
  1)

(s/defsignal *b
  (+ 10 @*a))

(s/defsignal *c
  (+ 100 @*b))

@*a ; =&gt; 1
@*b ; =&gt; 11
@*c ; =&gt; 111

(:state *b) ; =&gt; :clean
(:value *b) ; =&gt; 11

(s/reset! *a 2)

(:state *b) ; =&gt; :dirty
(:value *b) ; =&gt; 11
(:state *c) ; =&gt; :check
(:value *c) ; =&gt; 111

@*b ; =&gt; 12

(:state *c) ; =&gt; :dirty
(:value *c) ; =&gt; 111

@*c ; =&gt; 112
</code></pre></div></div>

<p>Or for us visual thinkers:</p>

<figure>
  <img src="https://tonsky.me/blog/humble-signals/lazyness.png" />
</figure>

<p>For details, see <a href="https://dev.to/modderme123/super-charging-fine-grained-reactive-performance-47ph#reactively">Reactively algorithm description</a>.</p>

<p>An effect is a signal that watches when it gets marked <code class="language-plaintext highlighter-rouge">:check</code> (something down the deps tree has changed) and forces its dependencies to see if any of them are actually <code class="language-plaintext highlighter-rouge">:dirty</code>. If any of them are, it evaluates its body:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(s/defsignal *a
  1)

(s/defsignal *b
  (mod @*a 3))

(s/effect [*b]
  (println @*a "mod 3 =" @*b))

(s/reset! *a 2) ; =&gt; "2 mod 3 = 2"
(s/reset! *a 3) ; =&gt; "3 mod 3 = 0"
(s/reset! *a 6) ; =&gt; (no stdout: *b didn’t change)
</code></pre></div></div>

<p>This is exactly what we need to schedule re-renders. We put an effect as a downstream dependency on every signal that was read during the last <code class="language-plaintext highlighter-rouge">draw</code>. That means we’ll create an explicit dependency for everything that affected the final picture one way or another.</p>

<figure>
  <img src="https://tonsky.me/blog/humble-signals/rendering1.png" />
</figure>

<p>Then, when any of the sources change <em>and</em> the redraw effect is actually a downstream dependency on it, we’ll trigger a new redraw.</p>

<h1 id="disposing-signals">Disposing signals</h1>

<p>What I did have problems with is resource management. First, let’s consider something like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(s/defsignal *object
  "world")

(def label
  (s/signal (str "Hello, " @*object "!")))
</code></pre></div></div>

<p>Now imagine we lose a reference to the label. Irresponsible, I know, but things happen, especially in end-user code. The simplest example: we’re in REPL and we re-evaluate <code class="language-plaintext highlighter-rouge">(def label ...)</code> again. What will happen?</p>

<p>Well, due to the nature of signals, they actually keep references to both upstream (for re-calculation) and downstream (for invalidation) dependencies. Meaning, the previous version of the signal will still be referenced from <code class="language-plaintext highlighter-rouge">*object</code> along with the new one:</p>

<figure>
  <img src="https://tonsky.me/blog/humble-signals/dangling_signal.png" />
</figure>

<p>We can introduce <code class="language-plaintext highlighter-rouge">dispose</code> method that could be called to unregister itself from upstream, but nobody can guarantee that users will call that in time. It’s so easy to accidentally lose a reference in a garbage-collected language!</p>

<p>And this is what I am struggling with. The signal network <em>has</em> to be dynamic. Meaning, new dependencies will come and go. But de-registering something doesn’t really feel natural in Clojure or even Java code, and there’s no way to enforce that every resource that is no longer needed will be properly disposed of.</p>

<p>A common solution is to make downstream references weak. That means, if we lost all references to the dependant signal (<code class="language-plaintext highlighter-rouge">label</code> on the picture below), it will eventually be garbage collected.</p>

<figure>
  <img src="https://tonsky.me/blog/humble-signals/weak_ref.png" />
</figure>

<p>What I don’t like about that solution (that we use anyways in the prototype) is that until GC is called, those unnecessary dependencies still hang around and take resources e.g. during downstream invalidation.</p>

<figure>
  <img src="https://tonsky.me/blog/humble-signals/weak_invalidation.png" />
</figure>

<p>One idea is to dispose of signals explicitly when their component unmounts. It works for some signals, but not in general. Consider this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(s/defsignal *text
  "Hello")

(ui/label *text)
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">*text</code> signal is created outside of the label and shouldn’t be disposed of by it. At the same time,</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(ui/label
  (s/signal (str @*text ", world!")))
</code></pre></div></div>

<p>In this case, the signal is created specifically for the label, thus should be disposed of at the same time as the label. But how to express that?</p>

<p>Keep in mind that we probably want both use cases at the same time:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(ui/column
  (ui/header *text)
  (ui/label
    (s/signal (str @*text ", world!")))
  (ui/label *text))
</code></pre></div></div>

<p>Eventually, unused signals will be cleaned up by GC, so we can rely on that. I’m just not sure what sorts of problems it might cause in practice.</p>

<h1 id="disposing-components">Disposing components</h1>

<p>Same problem I have with signals I also have with components. Because all components are values, nothing stops me from saving them in a var, using them multiple times, etc. Consider this UI:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(s/defsignal *cond
  true)

(def the-label
  (ui/label "Hello"))

(def *ui
  (s/signal
    (if @*cond
      the-label
      (ui/label "Not hello"))))
</code></pre></div></div>

<p>If we toggle <code class="language-plaintext highlighter-rouge">*cond</code> on and off, <code class="language-plaintext highlighter-rouge">the-label</code> will appear and disappear from our UI, calling <code class="language-plaintext highlighter-rouge">on-mount</code> and <code class="language-plaintext highlighter-rouge">on-unmount</code> multiple times. So if we do some resource cleanup in <code class="language-plaintext highlighter-rouge">on-unmount</code>, we should somehow restore it in <code class="language-plaintext highlighter-rouge">on-mount</code>? Feels strange, but why not?</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(core/deftype+ Label [*paint *text ^:mut *line]
  protocols/ILifecycle
  (-on-mount-impl [_]
    (set! *line
      (s/signal
        (.shapeLine
          core/shaper
          (str (s/maybe-read *text))
          @*font-ui
          ShapingOptions/DEFAULT))))
  
  (-on-unmount-impl [_]
    (s/dispose! *line)
    (set! *line nil)))
</code></pre></div></div>

<p>This way, if a component needs some heavy resources for rendering (textures, pre-rendered lines, or other native resources) it can clean it up and restore only when it’s actually on the screen. Or rely on GC once again (not recommended).</p>

<h1 id="mounting-components">Mounting components</h1>

<p>Another thing that I used to take for granted since the world switched to React: lifecycle callbacks. A lot of stuff comes down to these callbacks. Enabling/disabling signals. Freeing expensive resources held by components. Users’ use cases, like setting a timer or making a fetch request. It is so convenient to be able to tie some expensive resource’s lifetime to the lifetime of a component. We certainly want these!</p>

<p>How does React do it? Well, it takes mount/unmount API away from you and takes control over it, so it can guarantee to call you back at the right time.</p>

<p>The solution I came up with is very simple: the component is mounted if it was drawn during render, and not mounted otherwise. At the very top level, I’m keeping track of everything that was rendered last frame and what is rendered this frame. For new stuff, <code class="language-plaintext highlighter-rouge">-on-mount</code> is called, for stuff that’s no longer visible, <code class="language-plaintext highlighter-rouge">-on-unmount</code>. The gotcha here is, as I said above, that some components might “come back” after being unmounted. I guess it’s ok?</p>

<h1 id="gotchas">Gotchas</h1>

<p>Working with an incremental framework breaks both imperative and functional intuition. It’s a whole other thing. I made a lot of mistakes and had to think about stuff I usually don’t have to think about. Here are a few gotchas:</p>

<h2 id="dependency-too-wide">Dependency too wide</h2>

<p>Imagine we want to render a TODO from very simple EDN data:</p>

<figure>
  <img src="https://tonsky.me/blog/humble-signals/gotcha_1.png" style="max-width: 300px;" />
</figure>

<p>We might write something like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(defn render-todo [*todo]
  (let [*text (s/signal
                (str (:id @*todo)))]
    (ui/label *text)))
</code></pre></div></div>

<p>This render function returns a label object that has a signal as its text. So far so good.</p>

<p>The problem is, we over-depend here: we only use <code class="language-plaintext highlighter-rouge">:id</code> from <code class="language-plaintext highlighter-rouge">*todo</code> but we depend on the entire thing. A better solution would be:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(defn render-todo [*todo]
  (let [*id   (s/signal (:id @*todo))
        *text (s/signal (str *id))]
    (ui/label *text)))
</code></pre></div></div>

<p>which seems a bit too tedious to write. It probably doesn’t matter all that much in this particular case, but what if computations are more expensive?</p>

<p>My point is: it’s too easy to make this mistake.</p>

<p>Ambrose Bonnaire-Sergeant has pointed out that Reagent and CljFX solve this by providing an explicit API:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@(subscribe [:items])
</code></pre></div></div>

<h2 id="dependency-at-the-wrong-time">Dependency at the wrong time</h2>

<p>Imagine you have a UI like this:</p>

<figure>
  <img src="https://tonsky.me/blog/humble-signals/gotcha_2.png" style="max-width: 300px;" />
</figure>

<p>You have a signal that is hooked up to your text field and a button that converts it into a label:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(s/defsignal *text
  "Your name")

(s/defsignal *list
  [])

(def app
  (ui/column
    (s/mapv ui/label *list)

    (ui/text-field {:placeholder "Type here"}
      *text)

    (ui/button
      #(s/swap! *list conj *text)
      (ui/label "Add"))))
</code></pre></div></div>

<p>Do you see it? We actually store the original signal in <code class="language-plaintext highlighter-rouge">*list</code> instead of making a copy. This way, when we edit text, every element in our list will also be edited!</p>

<p>We might fix it like so:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#(s/swap! *list conj (s/signal @*text))
</code></pre></div></div>

<p>but it’s no good either.</p>

<p>Yes, we create a new signal, but it depends on the old one :) This is an API problem, and I think maybe I should have separate functions for source signals and derived signals. Right now the proper way to write it would be:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#(let [text @*text]
   (s/swap! *list conj (s/signal text)))
</code></pre></div></div>

<p>which is almost identical! but the result is very different.</p>

<p>It reminds me a lot about Clojure laziness puzzles, which is both ok (we all learned to deal with them) and not so much (the best way to deal with laziness is not to use it).</p>

<h2 id="recomputing-too-much">Recomputing too much</h2>

<p>There’s another gotcha in the previous example. <code class="language-plaintext highlighter-rouge">column</code> takes a collection or a signal that contains a collection, so we have to satisfy that:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(ui/column
  (s/signal
    (concat
      (mapv ui/label @*list)
      [(ui/text-field ...)
       (ui/button ...)]))))
</code></pre></div></div>

<p>But now our <code class="language-plaintext highlighter-rouge">s/signal</code> will re-create a text-field and a button each time <code class="language-plaintext highlighter-rouge">*list</code> changes. The solution might be:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(let [text-field (ui/text-field ...)
      button     (ui/button ...)]
  (ui/column
    (s/signal
      (concat
        (mapv ui/label @*list)
        [text-field
         button]))))
</code></pre></div></div>

<p>which, again, kind of breaks referential transparency. Depending on where we allocate our components, an app behaves differently. Doesn’t matter for the button, as it doesn’t have an internal state, but does matter for the text field.</p>

<p>Alternatively, we might introduce a version of concat that accepts both signals wrapping sequences as well as sequence values. Then argument evaluation will lock the <code class="language-plaintext highlighter-rouge">text-field</code> value for us:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(ui/column
  (s/signal
    (s/concat
      (s/mapv ui/label *list)
      [(ui/text-field ...)
       (ui/button ...)])))
</code></pre></div></div>

<h2 id="ambiguity">Ambiguity</h2>

<p>It was not always clear to me which parts of the state should be signals and which should be values. Right now, for example, a list of todos is signal containing signals that point to todos:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(defn random-todo []
  {:id       (rand-int 1000)
   :checked? (rand-nth [true false])})

(s/defsignal *todos
  [(s/signal (random-todo))
   (s/signal (random-todo))
   (s/signal (random-todo))
   ...])
</code></pre></div></div>

<p>This way list of todos could be decoupled from the todos themselves. When we add new todo, we need to change the list and generate a new component. But when an individual todo is e.g. toggled, it’s handled entirely inside and shouldn’t affect the list.</p>

<p>I guess this solution is okay, although double-nested mutable structures do give me pause.</p>

<p>Could the same be done “single atom”-style? Probably, with some sort of keyed map operator and lenses?</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(s/defsignal *todos
  [(random-todo)
   (random-todo)
   (random-todo)
   ...])

(def *todo-0
  (s/signal
    {:read  (nth @*todos 0)
     :write #(s/update *todos assoc 0 %)}))
</code></pre></div></div>

<p>The same ambiguity problem happens here:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(s/defsignal *text
  "Hello")
  
(ui/label *text)
</code></pre></div></div>

<p>or</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(s/signal
  (ui/label @*text))
</code></pre></div></div>

<p>Should I use a label that contains a signal or a signal that contains a label? Both are viable.</p>

<p>This is not necessarily a problem, just an observation. I guess I prefer Python’s “There should be one—and preferably only one—obvious way to do it” to Perl’s “There’s more than one way to do it”.</p>

<h2 id="repeating-computations">Repeating computations</h2>

<p>I have a few constants defined in my app, including <code class="language-plaintext highlighter-rouge">*scale</code> (UI scale, e.g. <code class="language-plaintext highlighter-rouge">2.0</code> on Retina) and <code class="language-plaintext highlighter-rouge">*padding</code> (in logical pixels, e.g. <code class="language-plaintext highlighter-rouge">10</code>).</p>

<p>But actual rendering requires screen pixels, not UI pixels. For that, I was using the derived signal calculated inside the <code class="language-plaintext highlighter-rouge">padding</code> constructor:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(defn padding [*amount]
  (map-&gt;Padding
    {:amount (s/signal (* @*scale @*amount))}))
</code></pre></div></div>

<p>The problem? I was using default <code class="language-plaintext highlighter-rouge">*padding</code> everywhere:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(padding *padding ...)
...
(padding *padding ...)
...
(padding *padding ...)
...
</code></pre></div></div>

<p>This way I ended up with dozens of equivalent signals (different identities, same value, dependencies, and function) that multiply the same numbers to get the same result.</p>

<p>Is it bad? In this case, probably not. It just doesn’t feel as clean, considering that the rest of the app uses the absolute required minimum of computations and the dependency graph is carefully constructed.</p>

<p>But I don’t see a way to merge identical signals together, either. I guess we’ll have to live with this imperfection.</p>

<h1 id="pre-compilation">Pre-compilation</h1>

<p>I started this experiment inspired by Svelte, Solid, and Electric Clojure. All of them have compilation steps that I wanted to avoid.</p>

<p>The most non-obvious result I get from this is that it looks like you <em>need</em> pre-compilation for better ergonomics and resource management. Both of these problems go away if we don’t let users interact with our incremental engine directly, but instead, do it for them.</p>

<p>We can replace calls to if/map/concat with their incremental versions transparently, track dependencies reliably, and add <code class="language-plaintext highlighter-rouge">dispose</code> calls where needed—basically, all these things you can’t trust humans to get right.</p>

<p>I am also getting reports that Reagent (that has a similar thing, <code class="language-plaintext highlighter-rouge">r/track</code>) is hard to use correctly at scale. Can anyone confirm?</p>

<p>Maybe it’s worth running another experiment to see if I can get pre-compilation working and how much it helps.</p>

<h1 id="results">Results</h1>

<p>Some preliminary results from the experiment:</p>

<h2 id="it-works">It works</h2>

<p>After some massaging, I was able to build incremental TodoMVC that keeps the state of its components that do not directly change.</p>

<p>Here’s a video:</p>

<figure>
  <video autoplay="" muted="" loop="" preload="auto" playsinline="" controls="">
    <source src="https://tonsky.me/blog/humble-signals/demo.mp4" type="video/mp4" />
  </video>
</figure>

<p>The magenta outline means that the component was just created and is rendered for the first time.</p>

<p>Notice how when I add new TODO only its row is highlighted. That’s because the rest reuses the same components that were created before.</p>

<p>When you switch between tabs, it causes some of the rows to be filtered out. When you go back to “All”, only the ones that were not visible are recreated.</p>

<p>Also, notice the same effect on tabs: when you switch e.g. from “All” to “Active”, “All” becomes a button but “Active” becomes just a label, so they both have to be recreated. But “Completed” stays a button, so it doesn’t get recreated.</p>

<p>And the last thing: when I toggle TODOs, nothing gets highlighted. This is because I made labels accept signals as text:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(s/defsignal *text
  "Hello")

(ui/label *text)
</code></pre></div></div>

<p>So the label could stay the same while the text it displays changes. Not necessary, but feels neat, actually. Another way to do it would’ve been:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(s/signal
  (ui/label @*text))
</code></pre></div></div>

<p>Then it would be highlighted on the toggle:</p>

<figure>
  <video autoplay="" muted="" loop="" preload="auto" playsinline="" controls="">
    <source src="https://tonsky.me/blog/humble-signals/demo2.mp4" type="video/mp4" />
  </video>
</figure>

<h2 id="it-feels-very-satisfying">It feels very satisfying</h2>

<p>…knowing no computation is wasted on diffs and only the necessary minimum of UI is recreated.</p>

<h2 id="props-drilling-works">Props drilling works</h2>

<p>I made UI scale, padding, and button fill color signals and when I change them necessary parts of UI are updated:</p>

<figure>
  <video autoplay="" muted="" loop="" preload="auto" playsinline="" controls="">
    <source src="https://tonsky.me/blog/humble-signals/demo3.mp4" type="video/mp4" />
  </video>
</figure>

<p>This feels very satisfying, too: knowing that you made the dependency very explicit and very precise, not the hacky “let’s just reset everything just in case” way. And it requires no special setup, it “just works”.</p>

<h2 id="no-vdom-needed">No VDOM needed</h2>

<p>I don’t have to implement VDOM and diffing! And I don’t need both heavy- and lightweight versions of each component. I don’t need to track the state separately from the components. That’s a huge burden off my shoulders.</p>

<h2 id="we-need-incremental-algorithms">We need incremental algorithms</h2>

<p>I do need to provide a set of incremental algorithms. Incremental <code class="language-plaintext highlighter-rouge">map</code>, incremental <code class="language-plaintext highlighter-rouge">filter</code>, <code class="language-plaintext highlighter-rouge">concat</code> etc. <code class="language-plaintext highlighter-rouge">for</code> macro, too.</p>

<p>Ideally, we want users to be able to write their own.</p>

<h2 id="it-breaks-intuition">It breaks intuition</h2>

<p>Working with incremental computations could be tricky. Making a mistake is easy, and double-checking yourself is hard, so it’s hard to know if you are doing the right thing.</p>

<p>But it seems that the stakes are not that high: the worst that could happen is you re-create too much and your performance suffers. I’d say it’s a ~similar deal you get with React.</p>

<h2 id="is-there-a-deeper-reason">Is there a deeper reason?</h2>

<p>There’s probably a good reason React won and FRP/incremental remain marginal technologies that have been tried dozens of times. I understand the appeal, but I also see how it’s not everybody’s cup of tea.</p>

<p>OTOH, Reagent seems to be doing fine in Clojure land, although many people prefer to pair it with re-frame.</p>

<h2 id="source-code">Source code</h2>

<p>If you are curious, the code is <a href="https://github.com/HumbleUI/HumbleUI/blob/main/dev/incremental.clj">on Github</a>. The run script is at <code class="language-plaintext highlighter-rouge">scripts/incremental.sh</code>.</p>

<p>Let me know what you think! And I’m going to try VDOM approach next. And then I guess I’ll have to make <a href="https://www.youtube.com/watch?v=c5QF2HjHLSE">a decision matrix</a>.</p>

        
      
  </body>
</html>
