<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://2ality.com/2022/01/pipe-operator.html">Original</a>
    <h1>A pipe operator for JavaScript: introduction and use cases</h1>
    
    <div id="readability-page-1" class="page"><div><p>The proposal <a href="https://github.com/tc39/proposal-pipeline-operator#tacit-unary-function-application-syntax">“Pipe operator (<code>|&gt;</code>) for JavaScript”</a> (by J. S. Choi, James DiGioia, Ron Buckton and Tab Atkins) introduces a new operator. This operator is an idea borrowed from functional programming that makes applying functions more convenient in many cases.</p>
<p>This blog post describes how the pipe operator works and what its use cases are (there are more than you might expect!).</p>
<!--more-->
<hr/>
<p><strong>Table of contents:</strong></p>
<nav><ul><li><a href="#the-two-competing-proposals">The two competing proposals  </a></li><li><a href="#the-hack-pipe-operator">The Hack pipe operator  </a><ul><li><a href="#a-first-use-case">A first use case  </a></li></ul></li><li><a href="#the-f%23-pipe-operator">The F# pipe operator  </a><ul><li><a href="#f%23-pipe-is-better-at-chaining-unary-(one-parameter)-functions">F# pipe is better at chaining unary (one-parameter) functions  </a></li><li><a href="#currying%3A-important-for-the-f%23-pipe-operator-but-not-a-good-fit-for-javascript">Currying: important for the F# pipe operator but not a good fit for JavaScript  </a><ul></ul></li><li><a href="#hack-pipe-is-better-at%3A-method-calls%2C-operators%2C-literals%2C-await%2C-yield">Hack pipe is better at: method calls, operators, literals, await, yield  </a></li><li><a href="#f%23-pipe-is-better-at-destructuring">F# pipe is better at destructuring  </a></li></ul></li><li><a href="#use-cases-for-the-pipe-operator">Use cases for the pipe operator  </a><ul><li><a href="#flat-syntax-for-nested-function-calls">Flat syntax for nested function calls  </a><ul></ul></li><li><a href="#post-processing-values">Post-processing values  </a><ul></ul></li><li><a href="#chaining-for-non-method-language-constructs">Chaining for non-method language constructs  </a><ul></ul></li></ul></li><li><a href="#summary%3A-hack-pipe-vs.-f%23-pipe">Summary: Hack pipe vs. F# pipe  </a><ul><li><a href="#how-likely-is-it-that-javascript-gets-a-pipe-operator%3F">How likely is it that JavaScript gets a pipe operator?  </a></li></ul></li><li><a href="#potential-improvements-for-hack-pipe-and-f%23-pipe">Potential improvements for Hack pipe and F# pipe  </a><ul><li><a href="#f%23-pipe%3A-better-support-for-functions-with-arities-greater-than-1">F# pipe: better support for functions with arities greater than 1  </a></li><li><a href="#smart-pipelines%3A-hack-pipes-with-optional-%25">Smart pipelines: Hack pipes with optional %  </a></li><li><a href="#an-extra-operator-for-unary-functions-that-complements-the-hack-pipe">An extra operator for unary functions that complements the Hack pipe  </a></li></ul></li><li><a href="#do-we-really-need-a-pipe-operator%3F-what-are-the-alternatives%3F">Do we really need a pipe operator? What are the alternatives?  </a><ul><li><a href="#function.pipe()">Function.pipe()  </a></li><li><a href="#using-intermediate-variables">Using intermediate variables  </a></li><li><a href="#reusing-a-variable-multiple-times">Reusing a variable multiple times  </a></li></ul></li><li><a href="#share-your-use-cases!">Share your use cases!  </a></li><li><a href="#further-reading">Further reading  </a></li></ul></nav><hr/>
<h2 id="the-two-competing-proposals">The two competing proposals  <a href="#the-two-competing-proposals" aria-hidden="true">#</a></h2>
<p>There originally were two competing proposals for a pipe operator, inspired by other programming languages:</p>
<ul>
<li>
<p><a href="https://en.wikipedia.org/wiki/F_Sharp_(programming_language)"><em>F#</em></a> by Microsoft is a functional programming language whose core is based on OCaml. This pipe operator works together well with <em>curried functions</em> (I’ll explain what that is soon).</p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Hack_(programming_language)"><em>Hack</em></a> by Facebook is – roughly – a statically typed version of PHP. This pipe operator focuses on language features other than curried functions. It includes syntactic support for partial application.</p>
</li>
</ul>
<p>The latter proposal won. However, if you prefer the F# pipe, there is good news: Its benefits may be added to the Hack pipe at a later time (details are explained later).</p>
<p>We’ll start by exploring the Hack pipe. Then we’ll move on to the F# pipe and compare its pros and cons with the pros and cons of the Hack pipe.</p>
<h2 id="the-hack-pipe-operator">The Hack pipe operator  <a href="#the-hack-pipe-operator" aria-hidden="true">#</a></h2>
<p>This is an example of using the Hack pipe operator <code>|&gt;</code>:</p>
<pre><code>assert.equal(
  <span>&#39;123.45&#39;</span> |&gt; <span>Number</span>(%), <span>123.45</span>
);
</code></pre>
<p>The left-hand side of the pipe operator <code>|&gt;</code> is an expression that is evaluated and becomes the value of the special variable <code>%</code>. We can use that variable on the right hand side. The returns the result of evaluating its right-hand side. In other words, the previous example is equivalent to:</p>
<pre><code>assert.equal(
  <span>Number</span>(<span>&#39;123.45&#39;</span>), <span>123.45</span>
);
</code></pre>
<p>The following examples demonstrate that <code>%</code> really works like any other variable:</p>
<pre><code>value |&gt; someFunction(<span>1</span>, %, <span>3</span>) 
value |&gt; %.someMethod() 
value |&gt; % + <span>1</span> 
value |&gt; [%, <span>&#39;b&#39;</span>, <span>&#39;c&#39;</span>] 
value |&gt; {<span>someProp</span>: %} 
value |&gt; <span>await</span> % 
value |&gt; (<span>yield</span> %) 
</code></pre>
<h3 id="a-first-use-case">A first use case  <a href="#a-first-use-case" aria-hidden="true">#</a></h3>
<p>We’ll see more use cases later, but let’s quickly look at a core use case now. Consider these nested function calls:</p>
<pre><code><span>const</span> y = h(g(f(x)));
</code></pre>
<p>This notation usually does not reflect how we think about the computational steps. Intuitively, we’d describe them as:</p>
<ul>
<li>Start with the value <code>x</code>.</li>
<li>Then apply <code>f()</code> to it.</li>
<li>Then apply <code>g()</code> to the result.</li>
<li>Then apply <code>h()</code> to the result.</li>
<li>Then assign the result to <code>y</code>.</li>
</ul>
<p>The Hack pipe operator lets us express this intuition better:</p>
<pre><code><span>const</span> y = x |&gt; f(%) |&gt; g(%) |&gt; h(%);
</code></pre>
<h2 id="the-f%23-pipe-operator">The F# pipe operator  <a href="#the-f%23-pipe-operator" aria-hidden="true">#</a></h2>
<p>The F# pipe operator is roughly similar to the Hack pipe operator. However, it doesn’t have the special variable <code>%</code>. Instead, expects a function at its right-hand side and applies that function to its left-hand side. Therefore, the following two expressions are equivalent:</p>
<pre><code><span>&#39;123.45&#39;</span> |&gt; <span>Number</span>
<span>Number</span>(<span>&#39;123.45&#39;</span>)
</code></pre>
<h3 id="f%23-pipe-is-better-at-chaining-unary-(one-parameter)-functions">F# pipe is better at chaining <em>unary</em> (one-parameter) functions  <a href="#f%23-pipe-is-better-at-chaining-unary-(one-parameter)-functions" aria-hidden="true">#</a></h3>
<p>The following three statements are equivalent:</p>
<pre><code><span>const</span> y = h(g(f(x))); 
<span>const</span> y = x |&gt; f(%) |&gt; g(%) |&gt; h(%); 
<span>const</span> y = x |&gt; f |&gt; g |&gt; h; 
</code></pre>
<p>We can see that Hack pipe is more verbose than F# pipe in this case.</p>
<h3 id="currying%3A-important-for-the-f%23-pipe-operator-but-not-a-good-fit-for-javascript">Currying: important for the F# pipe operator but not a good fit for JavaScript  <a href="#currying%3A-important-for-the-f%23-pipe-operator-but-not-a-good-fit-for-javascript" aria-hidden="true">#</a></h3>
<p>F# pipe works well in functional programming languages with built-in support for <em>currying</em>.</p>
<p>What is currying? Normal (uncurried) functions can have zero or more parameters – for example:</p>
<pre><code><span>const</span> add2 = <span>(<span>x, y</span>) =&gt;</span> x + y;
assert.equal(
  add2(<span>3</span>, <span>5</span>), <span>8</span>
);
</code></pre>
<p><em>Curried</em> functions have at most one parameter – they are <em>unary</em>. Functions with more parameters are emulated via unary functions that return functions:</p>
<pre><code><span>const</span> addCurry = <span><span>x</span> =&gt;</span> <span><span>y</span> =&gt;</span> x + y;
assert.equal(
  addCurry(<span>3</span>)(<span>7</span>), <span>10</span>
);
</code></pre>
<p>Currying makes it easy to create functions where the initial arguments are <em>partially applied</em> (filled in). For example, these are three ways of defining the same function:</p>
<pre><code><span>const</span> f1 = addCurry(<span>1</span>);
<span>const</span> f2 = add2.bind(<span>null</span>, <span>1</span>);
<span>const</span> f3 = <span><span>x</span> =&gt;</span> add2(<span>1</span>, x);
</code></pre>
<p>With currying, piping into a function with more than one parameter is concise:</p>
<pre><code>assert.equal(
  <span>5</span> |&gt; addCurry(<span>1</span>), <span>6</span>
);
</code></pre>
<p>Alas, currying is not a good choice for JavaScript:</p>
<ul>
<li>
<p>Currying can only fill in initial parameters. That works well in functional programming languages where the parameter with the data to operate on comes last (e.g. <code>append(elem, list)</code>). However, JavaScript’s functions are not structured that way and methods are often used, too.</p>
</li>
<li>
<p>I dislike using the same operator – function invocation – for both function calls and partial application.</p>
</li>
<li>
<p>Currying doesn’t work well with the named parameter pattern.</p>
</li>
<li>
<p>Currying doesn’t work well with parameter default values.</p>
</li>
</ul>
<p>For more information, see <a href="https://2ality.com/2017/11/currying-in-js.html">“Currying is not idiomatic in JavaScript”</a>.</p>
<h4 id="the-hack-pipe-%25-performs-partial-application">The Hack pipe <code>%</code> performs partial application  <a href="#the-hack-pipe-%25-performs-partial-application" aria-hidden="true">#</a></h4>
<p>The <code>%</code> in Hack pipe expressions could be considered an operator for partial application. For example, the following two expressions are equivalent:</p>
<pre><code><span>5</span> |&gt; add2(<span>1</span>, %) 
<span>5</span> |&gt; <span><span>$</span> =&gt;</span> add2(<span>1</span>, $) 
</code></pre>
<h3 id="hack-pipe-is-better-at%3A-method-calls%2C-operators%2C-literals%2C-await%2C-yield">Hack pipe is better at: method calls, operators, literals, <code>await</code>, <code>yield</code>  <a href="#hack-pipe-is-better-at%3A-method-calls%2C-operators%2C-literals%2C-await%2C-yield" aria-hidden="true">#</a></h3>
<p>To use the following constructs, we need arrow functions:</p>
<pre><code>value |&gt; <span><span>$</span> =&gt;</span> $.someMethod() 
value |&gt; <span><span>$</span> =&gt;</span> $ + <span>1</span> 
value |&gt; <span><span>$</span> =&gt;</span> [$, <span>&#39;b&#39;</span>, <span>&#39;c&#39;</span>] 
value |&gt; <span><span>$</span> =&gt;</span> {<span>someProp</span>: $} 
</code></pre>
<p>For <code>await</code> and <code>yield</code>, we’d need special syntax – e.g.:</p>
<pre><code>value |&gt; <span>await</span> 
value |&gt; <span>yield</span> 
</code></pre>
<h3 id="f%23-pipe-is-better-at-destructuring">F# pipe is better at destructuring  <a href="#f%23-pipe-is-better-at-destructuring" aria-hidden="true">#</a></h3>
<p>With the F# pipe, we can use a unary function to destructure an input value:</p>
<pre><code><span>const</span> str = obj |&gt; <span>(<span>{first,last}</span>) =&gt;</span> first + <span>&#39; &#39;</span> + last;
</code></pre>
<p>With the Hack pipe we have to either avoid destructuring:</p>
<pre><code><span>const</span> str = obj |&gt; %.first + <span>&#39; &#39;</span> + %.last;
</code></pre>
<p>Or we have to use an immediately-invoked arrow function:</p>
<pre><code><span>const</span> str = obj |&gt; <span>(<span>({first,last}</span>) =&gt;</span> first + <span>&#39; &#39;</span> + last)(%);
</code></pre>
<p>Should do-expressions ever be added to JavaScript, we could destructure via a variable declaration:</p>
<pre><code><span>const</span> str = obj |&gt; <span>do</span> { <span>const</span> {first,last} = %; first + <span>&#39; &#39;</span> + last };
</code></pre>
<h2 id="use-cases-for-the-pipe-operator">Use cases for the pipe operator  <a href="#use-cases-for-the-pipe-operator" aria-hidden="true">#</a></h2>
<p>There are three common kinds of use cases for the pipe operator:</p>
<ul>
<li>Flat syntax for nested function calls</li>
<li>Post-processing values: Given a value, we can apply a function by only adding code <em>after</em> it – where normal function calls require code before and after the value.</li>
<li>Chaining for non-method language constructs</li>
</ul>
<p>We’ll explore these use cases via Hack pipe, but they are also use cases for F# pipe.</p>
<h3 id="flat-syntax-for-nested-function-calls">Flat syntax for nested function calls  <a href="#flat-syntax-for-nested-function-calls" aria-hidden="true">#</a></h3>
<h4 id="retrieving-the-prototype-of-a-prototype-of-an-object">Retrieving the prototype of a prototype of an object  <a href="#retrieving-the-prototype-of-a-prototype-of-an-object" aria-hidden="true">#</a></h4>
<p>All iterators created by the JavaScript standard library have a common prototype. That prototype is not directly accessible, but we can retrieve it like this:</p>
<pre><code><span>const</span> IteratorPrototype =
  <span>Object</span>.getPrototypeOf(
    <span>Object</span>.getPrototypeOf(
      [][<span>Symbol</span>.iterator]()
    )
  )
;
</code></pre>
<p>With the pipe operator, the code becomes easier to understand:</p>
<pre><code><span>const</span> IteratorPrototype =
  [][<span>Symbol</span>.iterator]()
  |&gt; <span>Object</span>.getPrototypeOf(%)
  |&gt; <span>Object</span>.getPrototypeOf(%)
;
</code></pre>
<h4 id="mixin-classes">Mixin classes  <a href="#mixin-classes" aria-hidden="true">#</a></h4>
<p><a href="https://exploringjs.com/impatient-js/ch_classes.html#mixin-classes-advanced">Mixin classes</a> are a pattern where we use functions as factories for subclasses to emulate multiple inheritance. For example, these are two mixin classes:</p>
<pre><code><span>const</span> Parsable = <span>(<span>Sup</span>) =&gt;</span> <span><span>class</span> <span>extends</span> <span>Sup</span> </span>{
  
};
<span>const</span> Printable = <span>(<span>Sup</span>) =&gt;</span> <span><span>class</span> <span>extends</span> <span>Sup</span> </span>{
  
};
</code></pre>
<p>Both return a subclass of a given class <code>Sup</code>. Without the pipe operator, these mixins are used as follows:</p>
<pre><code><span><span>class</span> <span>Block</span> <span>extends</span> <span>Printable</span>(<span>Parsable</span>(<span>Object</span>)) </span>{
  
}
</code></pre>
<p>With the pipe operator, we get:</p>
<pre><code><span><span>class</span> <span>Block</span> <span>extends</span> <span>Object</span> |&gt; <span>Parsable</span>(%) |&gt; <span>Printable</span>(%) </span>{
  
}
</code></pre>
<h3 id="post-processing-values">Post-processing values  <a href="#post-processing-values" aria-hidden="true">#</a></h3>
<p>With the pipe operator, we can write functions such as <code>myProcessor</code> that post-process values in some manner:</p>
<pre><code><span>const</span> myPostProcessedValue = myValue |&gt; myProcessor(%);
</code></pre>
<p>We can see that the Hack pipe is more verbose here than the F# pipe would be. More on that later.</p>
<h4 id="easy-to-remove-logging-of-values">Easy-to-remove logging of values  <a href="#easy-to-remove-logging-of-values" aria-hidden="true">#</a></h4>
<p>Consider the following function:</p>
<pre><code><span><span>function</span> <span>myFunc</span>(<span></span>) </span>{
  
  <span>return</span> someObject.someMethod();
}
</code></pre>
<p>How would we change this code to log the result of <code>someObject.someMethod()</code> before it is returned?</p>
<p>Without the pipe operator, we’d have to introduce a temporary variable or wrap a function call around the operand of <code>return</code>.</p>
<p>With the pipe operator, we can do this:</p>
<pre><code><span><span>function</span> <span>myFunc</span>(<span></span>) </span>{
  
  <span>return</span> theResult |&gt; (<span>console</span>.log(%), %); 
}
</code></pre>
<p>In line A, we used <a href="https://exploringjs.com/impatient-js/ch_operators.html#comma-operator">the comma operator</a>. To evaluate the following expression:</p>
<pre><code>(expr1, expr2)
</code></pre>
<p>JavaScript first evaluates <code>expr1</code> and then <code>expr2</code> and then returns the latter result.</p>
<h4 id="post-processing-functions">Post-processing functions  <a href="#post-processing-functions" aria-hidden="true">#</a></h4>
<p>In the following code, the value that we post-process is a function – we add a property to it:</p>
<pre><code><span>const</span> testPlus = <span><span>()</span> =&gt;</span> {
  assert.equal(<span>3</span>+<span>4</span>, <span>7</span>);
} |&gt; <span>Object</span>.assign(%, {
  <span>name</span>: <span>&#39;Test the plus operator&#39;</span>,
});
</code></pre>
<p>The previous code is equivalent to:</p>
<pre><code><span>const</span> testPlus = <span><span>()</span> =&gt;</span> {
  assert.equal(<span>3</span>+<span>4</span>, <span>7</span>);
}
<span>Object</span>.assign(testPlus, {
  <span>name</span>: <span>&#39;Testing +&#39;</span>,
});
</code></pre>
<p>We could also have used the pipe operator like this:</p>
<pre><code><span>const</span> testPlus = <span><span>()</span> =&gt;</span> {
  assert.equal(<span>3</span>+<span>4</span>, <span>7</span>);
}
|&gt; (%.name = <span>&#39;Test the plus operator&#39;</span>, %)
;
</code></pre>
<h4 id="alternative-to-tagged-templates">Alternative to tagged templates  <a href="#alternative-to-tagged-templates" aria-hidden="true">#</a></h4>
<p><a href="https://exploringjs.com/impatient-js/ch_template-literals.html#tagged-templates">Tagged templates</a> are one way of post-processing template literals. The pipe operator can also do that:</p>
<pre><code><span>const</span> str = <span>String</span>.raw<span>`
  Text with
  <span>${<span>3</span>}</span> indented
  lines
`</span> |&gt; dedent(%) |&gt; prefixLines(%, <span>&#39;&gt; &#39;</span>);
</code></pre>
<p>Note that template literals have access to more data than functions we apply via pipe. They are therefore considerably more powerful – for example, <code>String.raw</code> can only be done via a template literal.</p>
<p>If a pipe-triggered function call is enough, we get the benefit of being able to apply multiple post-processing operations at the same time and can even combine those with a template literal (as is done in the example).</p>
<h3 id="chaining-for-non-method-language-constructs">Chaining for non-method language constructs  <a href="#chaining-for-non-method-language-constructs" aria-hidden="true">#</a></h3>
<h4 id="method-like-chaining">Method-like chaining  <a href="#method-like-chaining" aria-hidden="true">#</a></h4>
<p>Thanks to the pipe operator, we can chain operations similarly to how we can chain method invocations:</p>
<pre><code><span>const</span> regexOperators =
  [<span>&#39;*&#39;</span>, <span>&#39;+&#39;</span>, <span>&#39;[&#39;</span>, <span>&#39;]&#39;</span>]
  .map(<span><span>ch</span> =&gt;</span> escapeForRegExp(ch))
  .join(<span>&#39;&#39;</span>)
  |&gt; <span>&#39;[&#39;</span> + % + <span>&#39;]&#39;</span>
  |&gt; <span>new</span> <span>RegExp</span>(%)
;
</code></pre>
<p>This code is easy to read and less verbose than introducing intermediate variables.</p>
<h4 id="chaining-function-calls">Chaining function calls  <a href="#chaining-function-calls" aria-hidden="true">#</a></h4>
<p>We can chain methods such as the Array methods <code>.filter()</code> and <code>.map()</code>. However:</p>
<ul>
<li>They are a fixed set of operations that is built into a class. There is no way to add more Array methods via a library. (A library could create a subclass but that doesn’t help us if we get an Array from somewhere else.)</li>
<li>Tree-shaking (dead code elimination) is difficult if not impossible with methods.</li>
</ul>
<p>With the pipe operator, we can chain functions as if they were methods – without the two aforementioned downsides:</p>
<pre><code><span>import</span> {Iterable} <span>from</span> <span>&#39;@rauschma/iterable/sync&#39;</span>;
<span>const</span> {filter, map} = Iterable;

<span>const</span> resultSet = inputSet
  |&gt; filter(%, x =&gt; x &gt;= <span>0</span>)
  |&gt; map(%, x =&gt; x * <span>2</span>)
  |&gt; <span>new</span> <span>Set</span>(%)
;
</code></pre>
<h2 id="summary%3A-hack-pipe-vs.-f%23-pipe">Summary: Hack pipe vs. F# pipe  <a href="#summary%3A-hack-pipe-vs.-f%23-pipe" aria-hidden="true">#</a></h2>
<p>Strengths of F# pipe:</p>
<ul>
<li>Is better if we have code that uses currying.</li>
<li>Is less verbose when working with unary functions – e.g. when post-processing values.</li>
<li>Destructuring is slightly easier.</li>
</ul>
<p>Strengths of Hack pipe:</p>
<ul>
<li>Works better with typical (uncurried) JavaScript code and functions with an arity higher than 1.</li>
<li>Supports <code>await</code> and <code>yield</code> (without special syntax).</li>
</ul>
<p>TC39 is currently only persuing the Hack pipe. <a href="https://github.com/tc39/proposal-pipeline-operator#tc39-has-rejected-f-pipes-multiple-times">Concerns against F# pipe</a> include:</p>
<ul>
<li>Memory performance (due to the creation and invocation of functions)</li>
<li>Difficult to make <code>await</code> and <code>yield</code> work</li>
<li>Might encourage a split in the ecosystem between code that uses currying and code that doesn’t.</li>
</ul>
<h3 id="how-likely-is-it-that-javascript-gets-a-pipe-operator%3F">How likely is it that JavaScript gets a pipe operator?  <a href="#how-likely-is-it-that-javascript-gets-a-pipe-operator%3F" aria-hidden="true">#</a></h3>
<p>Progress is being made on the Hack pipe, but F# is not being persued anymore (for details, see <a href="https://github.com/tc39/proposal-pipeline-operator#tc39-has-rejected-f-pipes-multiple-times">the Hack operator proposal</a>).</p>
<h2 id="potential-improvements-for-hack-pipe-and-f%23-pipe">Potential improvements for Hack pipe and F# pipe  <a href="#potential-improvements-for-hack-pipe-and-f%23-pipe" aria-hidden="true">#</a></h2>
<p>In this section, we examine ways in which the two operators could be improved. However, it’s not always clear if the added complexity would be worth it.</p>
<h3 id="f%23-pipe%3A-better-support-for-functions-with-arities-greater-than-1">F# pipe: better support for functions with arities greater than 1  <a href="#f%23-pipe%3A-better-support-for-functions-with-arities-greater-than-1" aria-hidden="true">#</a></h3>
<p>If JavaScript had a partial application operator (<a href="https://github.com/tc39/proposal-partial-application">as proposed here</a>), then using F# pipes would look almost the same as using Hack pipes:</p>
<pre><code>
<span>const</span> resultArray = inputArray
  |&gt; filter(%, str =&gt; str.length &gt;= <span>0</span>)
  |&gt; map(%, str =&gt; <span>&#39;[&#39;</span>+str+<span>&#39;]&#39;</span>)
  |&gt; <span>console</span>.log(%)
;


<span>const</span> resultArray = inputArray
  |&gt; filter~(?, str =&gt; str.length &gt;= <span>0</span>)
  |&gt; map~(?, str =&gt; <span>&#39;[&#39;</span>+str+<span>&#39;]&#39;</span>)
  |&gt; <span>console</span>.log
;
</code></pre>
<p>A few downsides remain, though:</p>
<ul>
<li>Memory performance doesn’t improve (we still need function calls).</li>
<li>Doesn’t work with operators such as <code>+</code>.</li>
<li>Doesn’t work with <code>await</code> and <code>yield</code>.</li>
</ul>
<h3 id="smart-pipelines%3A-hack-pipes-with-optional-%25">Smart pipelines: Hack pipes with optional <code>%</code>  <a href="#smart-pipelines%3A-hack-pipes-with-optional-%25" aria-hidden="true">#</a></h3>
<p>We could make Hack pipe less verbose in the unary case:</p>
<ul>
<li>Is there a <code>%</code> in the right-hand side of the <code>|&gt;</code> operator?</li>
<li>If yes, then <code>|&gt;</code> works like the Hack pipe.</li>
<li>If not, then <code>|&gt;</code> works like the F# pipe.</li>
</ul>
<p>Example:</p>
<pre><code><span>const</span> resultArray = inputArray
  |&gt; filter(%, str =&gt; str.length &gt;= <span>0</span>)
  |&gt; map(%, str =&gt; <span>&#39;[&#39;</span>+str+<span>&#39;]&#39;</span>)
  |&gt; <span>console</span>.log 
;
</code></pre>
<p>Note that line A is different than the normal Hack pipe.</p>
<p><a href="https://github.com/tc39/proposal-smart-pipelines">A proposal for this approach</a> has been discarded, but it could in principle be revived as an add-on for Hack pipes.</p>

<p>We could complement the Hack pipe with a special operator <code>|&gt;&gt;</code> for unary functions that works like the F# pipe (line A):</p>
<pre><code><span>const</span> resultArray = inputArray
  |&gt; filter(%, str =&gt; str.length &gt;= <span>0</span>)
  |&gt; map(%, str =&gt; <span>&#39;[&#39;</span>+str+<span>&#39;]&#39;</span>)
  |&gt;&gt; <span>console</span>.log 
;
</code></pre>
<h2 id="do-we-really-need-a-pipe-operator%3F-what-are-the-alternatives%3F">Do we really need a pipe operator? What are the alternatives?  <a href="#do-we-really-need-a-pipe-operator%3F-what-are-the-alternatives%3F" aria-hidden="true">#</a></h2>
<p>In this section, we look at alternatives to the pipe operator. They are quite elegant but all have the following downsides:</p>
<ul>
<li>They are only good at chaining, not at post-processing.</li>
<li>Even if verbosity is only a little increased per processing step, it adds up and makes a built-in pipe operator more convenient.</li>
</ul>
<pre><code><span>import</span> {Iterable} <span>from</span> <span>&#39;@rauschma/iterable/sync&#39;</span>;
<span>const</span> {filter, map} = Iterable;

<span>const</span> resultSet = inputSet
  |&gt; filter(%, x =&gt; x &gt;= <span>0</span>)
  |&gt; map(%, x =&gt; x * <span>2</span>)
  |&gt; <span>new</span> <span>Set</span>(%)
;
</code></pre>
<h3 id="function.pipe()"><code>Function.pipe()</code>  <a href="#function.pipe()" aria-hidden="true">#</a></h3>
<p>One alternative to a pipe operator is to use a function – for example, the proposed <a href="https://github.com/js-choi/proposal-function-pipe-flow"><code>Function.pipe()</code></a>:</p>
<pre><code><span>const</span> resultSet = <span>Function</span>.pipe(
  inputSet,
  $ =&gt; filter($, x =&gt; x &gt;= <span>0</span>)
  $ =&gt; map($, x =&gt; x * <span>2</span>)
  $ =&gt; <span>new</span> <span>Set</span>($)
);
</code></pre>
<p>Thanks to arrow functions, this approach is less verbose than we might expect.</p>
<p>Its downsides are:</p>
<ul>
<li>We can’t use <code>await</code> and <code>yield</code>.</li>
<li>Functions are created and invoked.</li>
</ul>
<h3 id="using-intermediate-variables">Using intermediate variables  <a href="#using-intermediate-variables" aria-hidden="true">#</a></h3>
<p>We could use intermediate variables:</p>
<pre><code><span>const</span> filtered = filter(inputSet, x =&gt; x &gt;= <span>0</span>);
<span>const</span> mapped = map(filtered, x =&gt; x * <span>2</span>);
<span>const</span> resultSet = <span>new</span> <span>Set</span>(mapped);
</code></pre>
<p>On one hand, that’s more verbose than piping. On the other hand, the variable names describe what is going on – which can be useful if a step is complicated.</p>
<h3 id="reusing-a-variable-multiple-times">Reusing a variable multiple times  <a href="#reusing-a-variable-multiple-times" aria-hidden="true">#</a></h3>
<p>The following technique  is a variation of the previous technique – it reuses a short variable name such as <code>$</code>:</p>
<pre><code><span>let</span> $ = inputSet;
$ = filter($, x =&gt; x &gt;= <span>0</span>);
$ = map($, x =&gt; x * <span>2</span>);
<span>const</span> resultSet = <span>new</span> <span>Set</span>($);
</code></pre>
<p>(I’m not sure who deserves credit for this technique; I’ve first seen it used <a href="https://github.com/tc39/proposal-extensions/">here</a>.)</p>
<p>We save characters due to the shorter variable name and because we don’t need one variable declaration per step.</p>
<p>A downside of this technique is that it can’t be used multiple times within the same scope. And there is no simple way of wrapping a code block around such a code fragment, either.</p>
<p>However, we can fix that via an immediately-invoked Arrow function:</p>
<pre><code><span>const</span> resultSet = (
  <span>(<span>$ = inputSet</span>) =&gt;</span> {
    $ = filter($, x =&gt; x &gt;= <span>0</span>);
    $ = map($, x =&gt; x * <span>2</span>);
    $ = <span>new</span> <span>Set</span>($);
    <span>return</span> $;
  }
)();
</code></pre>
<p>Props to <a href="https://twitter.com/emnudge/status/1485741522477797379">@emnudge</a> for suggesting using a parameter default value.</p>

<p>Is there an interesting use case for the pipe operator that I missed? Let us know in the comments.</p>
<h2 id="further-reading">Further reading  <a href="#further-reading" aria-hidden="true">#</a></h2>
<ul>
<li>Blog post <a href="https://2ality.com/2011/09/currying-vs-part-eval.html">“Currying versus partial application (with JavaScript code)”</a></li>
<li>Blog post <a href="https://2ality.com/2017/11/currying-in-js.html">“Currying is not idiomatic in JavaScript”</a></li>
</ul>
</div></div>
  </body>
</html>
