<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.sethvargo.com/what-id-like-to-see-in-go-2/">Original</a>
    <h1>What I&#39;d like to see in Go 2.0</h1>
    
    <div id="readability-page-1" class="page"><section id="main"> <div> <section> <article> <header>  <span><a href="https://thewitchofendor.com/tag/go">Go</a>, <a href="https://thewitchofendor.com/tag/devex">DevEx</a></span> <img src="https://thewitchofendor.com/what-id-like-to-see-in-go-2/what-id-like-to-see-in-go-2.jpg" alt=""/> <span> Posted on <time datetime="2022-01-14">January 14, 2022</time> </span> </header> <section> <p>Go is one of my favorite programming languages, but it is still far from perfect. Over the past 10 years, I have used Go to both build small side projects and large scale applications. While the language has evolved significantly from its original release in 2009, this post highlights some of the areas where I think Go still has room for improvement.</p> <p>Before we get started, I want to be absolutely clear: I am NOT criticizing individual humans or their contributions. My only intent is to try and make Go the best programming language.</p> <h2 id="a-modern-templating-engine">A modern templating engine</h2> <p>The Go standard library has two templating packages: <a href="https://pkg.go.dev/text/template"><code>text/template</code></a> and <a href="https://pkg.go.dev/html/template"><code>html/template</code></a>. They use roughly the same syntax, but <code>html/template</code> handles entity escaping and a few other web-specific constructs. Unfortunately neither package is suitable or powerful enough for sufficiently advanced use cases without heavy developer investment.</p> <ul> <li><p><strong>Compile-time errors.</strong> Unlike Go itself, the Go templating packages will happily let you pass an integer as a string, only to render an error at runtime. This means developers need to rigorously test all possible inputs into their templates, instead of being able to rely on the type system. Go&#39;s templating packages should support compile time type checking.</p></li> <li><p><strong>A <code>range</code> clause that matches Go.</strong> After 10 years, I <em>still</em> mess up the order for the <code>range</code> clause in Go templating, because it is <em>sometimes</em> backwards from Go itself. With two arguments, the templating engine matches the standard library:</p> <div><pre><code>{{ range $a, $b := .Items }} // [$a = 0, $b = &#34;foo&#34;]
</code></pre></div><div><pre><code><span>for</span> <span>a</span><span>,</span> <span>b</span> <span>:=</span> <span>range</span> <span>items</span> <span>{</span> <span>// [a = 0, b = &#34;foo&#34;]</span>
</code></pre></div> <p>However, with only one argument, the template engine yields the value while Go renders yields the index:</p> <div><pre><code>{{ range $a := .Items }} // [$a = &#34;foo&#34;]
</code></pre></div><div><pre><code><span>for</span> <span>a</span> <span>:=</span> <span>range</span> <span>items</span> <span>{</span> <span>// [a = 0]</span>
</code></pre></div> <p>Go&#39;s template package should match how the standard library works.</p></li> <li><p><strong>Batteries included, reflection optional.</strong> As a general rule, I think most developers should never need to interact with reflection. However, if you want to do anything beyond basic addition and subtraction, Go&#39;s templating packages are going to force you into reflection. The built-in functions are incredibly minimal, and only satisfy a small subset of use cases.</p> <p>After I wrote <a href="https://github.com/hashicorp/consul-template">Consul Template</a>, it became pretty clear that the standard Go template functions were not sufficient to meet the needs of users. More than half of issues were about trying to use Go&#39;s templating language. Today, Consul Template has <a href="https://github.com/hashicorp/consul-template/blob/master/docs/templating-language.md">more than 50 &#34;helper&#34; functions</a>, the vast majority of which should really in the standard templating language.</p> <p>Consul Template isn&#39;t alone here. <a href="https://gohugo.io">Hugo</a> also has a <a href="https://gohugo.io/functions/">pretty expansive list of helper functions</a>, again, the vast majority of which should really be in the standard templating language. Even on my most recent project, <a href="https://g.co/ens">Exposure Notifications</a>, we <a href="https://github.com/google/exposure-notifications-verification-server/blob/0ec489ba95137d5be10e1617d1dcdc2d1ee6e5e9/pkg/render/renderer.go#L232-L280">could not escape the reflection</a>.</p> <p>Go&#39;s templating language really needs to have broader function surface area.</p></li> <li><p><strong>Short-circuit evaluation.</strong></p> <p><strong>EDIT:</strong> As many have pointed out, this feature is <a href="https://tip.golang.org/doc/go1.18#text/template">coming in Go 1.18</a>.</p> <p>Go&#39;s templating language always evaluates an entire conditional in a clause, which makes for some really fun bugs (that again will not manifest until runtime.) Consider the following, where <code>$foo</code> could be nil:</p> <div><pre><code>{{ if (and $foo $foo.Bar) }}
</code></pre></div> <p>It may <em>seem</em> like this is fine, but <strong>both</strong> of the <code>and</code> conditions will be evaluated - there is no short-circuit logic within an expression. That means this <em>will</em> throw a runtime exception if <code>$foo</code> is nil.</p> <p>To get around this, you have to separate the conditional clauses:</p> <div><pre><code>{{ if $foo }}
  {{ if $foo.Bar }}
{{ end }}
</code></pre></div> <p>Go&#39;s templating language should function like the standard library and stop executing a conditional on the first truthy value.</p></li> <li><p><strong>Investment in web-specific utilities.</strong> I was a Ruby on Rails developer for many years, and I really loved how <em>easy</em> it was to build beautiful web applications. With Go&#39;s templating language, even the simplest of tasks - like printing a list of items to a sentence - is unapproachable for beginners, especially when compared to Rails&#39; <code>Enumerable#to_sentence</code>.</p></li> </ul> <h2 id="improved-range-so-as-to-not-copy-values">Improved <code>range</code> so as to not copy values</h2> <p>While it is very well-documented, it is always unexpected that values in a range clause are copied. For example, consider the following code:</p> <div><pre><code><span>type</span> <span>Foo</span> <span>struct</span> <span>{</span>
  <span>bar</span> <span>string</span>
<span>}</span>

<span>func</span> <span>main</span><span>()</span> <span>{</span>
  <span>list</span> <span>:=</span> <span>[]</span><span>Foo</span><span>{{</span><span>&#34;A&#34;</span><span>},</span> <span>{</span><span>&#34;B&#34;</span><span>},</span> <span>{</span><span>&#34;C&#34;</span><span>}}</span>

  <span>cp</span> <span>:=</span> <span>make</span><span>([]</span><span>*</span><span>Foo</span><span>,</span> <span>len</span><span>(</span><span>list</span><span>))</span>
  <span>for</span> <span>i</span><span>,</span> <span>value</span> <span>:=</span> <span>range</span> <span>list</span> <span>{</span>
    <span>cp</span><span>[</span><span>i</span><span>]</span> <span>=</span> <span>&amp;</span><span>value</span>
  <span>}</span>

  <span>fmt</span><span>.</span><span>Printf</span><span>(</span><span>&#34;list: %q</span><span>\n</span><span>&#34;</span><span>,</span> <span>list</span><span>)</span>
  <span>fmt</span><span>.</span><span>Printf</span><span>(</span><span>&#34;cp: %q</span><span>\n</span><span>&#34;</span><span>,</span> <span>cp</span><span>)</span>
<span>}</span>
</code></pre></div> <p>What is the value of <code>cp</code>? If you said <code>[A B C]</code>, sadly you are incorrect. The value of <code>cp</code> is actually:</p>  <p>This is because Go uses a copy of the value instead of the value itself in the <code>range</code> clause. <strong>In Go 2.0, the <code>range</code> clause should pass values by reference.</strong> There are already a few proposals for Go 2.0 in this space, including <a href="https://github.com/golang/go/issues/24282">improve for-loop ergonomics</a> and <a href="https://github.com/golang/go/issues/20733">redefine range loop variables in each iteration</a>, so I am cautiously hopeful on this one.</p> <h2 id="deterministic-select">Deterministic <code>select</code></h2> <p>In cases where multiple conditions of a <code>select</code> statement are true, the <a href="https://golang.org/ref/spec#Select_statements">winning case is chosen via a uniform pseudo-random selection</a>. This is a very subtle source of errors, and it is exacerbated by the similar-looking <code>switch</code> statement which <em>does</em> evaluate in the order in which it is written.</p> <p>Consider the following code which we would like to behave as &#34;if the system is stopped, do nothing. Otherwise wait for new work for up to 5 seconds, then timeout&#34;:</p> <div><pre><code><span>for</span> <span>{</span>
  <span>select</span> <span>{</span>
  <span>case</span> <span>&lt;-</span><span>doneCh</span><span>:</span> <span>// or &lt;-ctx.Done():</span>
    <span>return</span>
  <span>case</span> <span>thing</span> <span>:=</span> <span>&lt;-</span><span>thingCh</span><span>:</span>
    <span>// ... long-running operation</span>
  <span>case</span> <span>&lt;-</span><span>time</span><span>.</span><span>After</span><span>(</span><span>5</span><span>*</span><span>time</span><span>.</span><span>Second</span><span>)</span><span>:</span>
    <span>return</span> <span>fmt</span><span>.</span><span>Errorf</span><span>(</span><span>&#34;timeout&#34;</span><span>)</span>
  <span>}</span>
<span>}</span>
</code></pre></div> <p>If multiple conditions are true when entering the <code>select</code> statement (e.g. <code>doneCh</code> is closed and more than 5 seconds have passed), it is undetermined behavior for which path will execute. This makes writing correct cancellation code annoyingly verbose:</p> <div><pre><code><span>for</span> <span>{</span>
  <span>// Check here in case we&#39;ve been CPU throttled for an extended time, we need to</span>
  <span>// check graceful stop or risk returning a timeout error.</span>
  <span>select</span> <span>{</span>
  <span>case</span> <span>&lt;-</span><span>doneCh</span><span>:</span>
    <span>return</span>
  <span>default</span><span>:</span>
  <span>}</span>

  <span>select</span> <span>{</span>
  <span>case</span> <span>&lt;-</span><span>doneCh</span><span>:</span>
    <span>return</span>
  <span>case</span> <span>thing</span> <span>:=</span> <span>&lt;-</span><span>thingCh</span><span>:</span>
    <span>// Even though this case won, we still might ALSO be stopped.</span>
    <span>select</span> <span>{</span>
    <span>case</span> <span>&lt;-</span><span>doneCh</span><span>:</span>
      <span>return</span>
    <span>default</span><span>:</span>
    <span>}</span>
    <span>// ...</span>
  <span>default</span> <span>&lt;-</span><span>time</span><span>.</span><span>After</span><span>(</span><span>5</span><span>*</span><span>time</span><span>.</span><span>Second</span><span>)</span><span>:</span>
    <span>// Even though this case won, we still might ALSO be stopped.</span>
    <span>select</span> <span>{</span>
    <span>case</span> <span>&lt;-</span><span>doneCh</span><span>:</span>
      <span>return</span>
    <span>default</span><span>:</span>
    <span>}</span>
    <span>return</span> <span>fmt</span><span>.</span><span>Errorf</span><span>(</span><span>&#34;timeout&#34;</span><span>)</span>
  <span>}</span>
<span>}</span>
</code></pre></div> <p>If <code>select</code> were updated to be deterministic, the original code (which is much simpler and easier to reach in my opinion) would work as intended. However, due to the non-deterministic nature of <code>select</code>, we have to continuously check the dominant condition.</p> <p>Tangentially related, I would love to see a shorthand syntax for &#34;read from this channel if it contains any messages, otherwise continue along&#34;. The current syntax is verbose:</p> <div><pre><code><span>select</span> <span>{</span>
<span>case</span> <span>&lt;-</span><span>doneCh</span><span>:</span>
  <span>return</span>
<span>default</span><span>:</span>
<span>}</span>
</code></pre></div> <p>I would love to see a more succinct version of this check, perhaps a syntax like:</p> <div><pre><code><span>select</span> <span>&lt;-</span><span>?</span><span>doneCh</span><span>:</span> <span>// not valid Go</span>
</code></pre></div> <h2 id="structured-logging-interfaces">Structured logging interfaces</h2> <p>Go&#39;s standard library includes the <a href="https://pkg.go.dev/log"><code>log</code></a> package, which is fine for basic use. However, most production systems want structured logging, and there is <a href="https://www.client9.com/logging-packages-in-golang/">no shortage</a> of structured logging libraries in Go:</p> <ul> <li> <a href="https://github.com/apex/log">apex/log</a></li> <li> <a href="https://github.com/go-kit/kit/tree/master/log">go-kit/log</a></li> <li> <a href="https://github.com/golang/glog">golang/glog</a></li> <li> <a href="https://github.com/hashicorp/go-hclog">hashicorp/go-hclog</a></li> <li> <a href="https://github.com/inconshreveable/log15">inconshreveable/log15</a></li> <li> <a href="https://github.com/rs/zerolog">rs/zerolog</a></li> <li> <a href="https://github.com/sirupsen/logrus">sirupsen/logrus</a></li> <li> <a href="https://github.com/uber-go/zap">uber/zap</a></li> </ul> <p>Go&#39;s lack of opinion in this space has led to the proliferation of these packages, most of which have incompatible functions and signatures. As a result, it is impossible for a library author to emit structured logs. For example, I would love to be able to emit structured logs in <a href="https://github.com/sethvargo/go-retry">go-retry</a>, <a href="https://github.com/sethvargo/go-envconfig">go-envconfig</a>, or <a href="https://github.com/sethvargo/go-githubactions">go-githubactions</a>, but doing so would require tightly coupling with one of these libraries. Ideally I want my library users to have choice over their structure logging solution, but the lack of a common interface for structure logging makes this extremely difficult.</p> <p><strong>The Go standard library needs to define a structured logging interface,</strong> and all these existing upstream packages can choose to implement that interface. Then, as a library author, I can choose to accept a <code>log.StructuredLogger</code> interface and implementers can make their own choices:</p> <div><pre><code><span>func</span> <span>WithLogger</span><span>(</span><span>l</span> <span>log</span><span>.</span><span>StructuredLogger</span><span>)</span> <span>Option</span> <span>{</span>
  <span>return</span> <span>func</span><span>(</span><span>f</span> <span>*</span><span>Foo</span><span>)</span> <span>*</span><span>Foo</span> <span>{</span>
    <span>f</span><span>.</span><span>logger</span> <span>=</span> <span>l</span>
    <span>return</span> <span>f</span>
  <span>}</span>
<span>}</span>
</code></pre></div> <p>I put together a quick sketch of what such an interface might look like:</p> <div><pre><code><span>// StructuredLogger is an interface for structured logging.</span>
<span>type</span> <span>StructuredLogger</span> <span>interface</span> <span>{</span>
  <span>// Log logs a message.</span>
  <span>Log</span><span>(</span><span>message</span> <span>string</span><span>,</span> <span>fields</span> <span>...</span><span>LogField</span><span>)</span>

  <span>// LogAt logs a message at the provided level. Perhaps we could also have</span>
  <span>// Debugf, Infof, etc, but I think that might be too limiting for the standard</span>
  <span>// library.</span>
  <span>LogAt</span><span>(</span><span>level</span> <span>LogLevel</span><span>,</span> <span>message</span> <span>string</span><span>,</span> <span>fields</span> <span>...</span><span>LogField</span><span>)</span>

  <span>// LogEntry logs a complete log entry. See LogEntry for the default values if</span>
  <span>// any fields are missing.</span>
  <span>LogEntry</span><span>(</span><span>entry</span> <span>*</span><span>LogEntry</span><span>)</span>
<span>}</span>

<span>// LogLevel is the underlying log level.</span>
<span>type</span> <span>LogLevel</span> <span>uint8</span>

<span>// LogEntry represents a single log entry.</span>
<span>type</span> <span>LogEntry</span> <span>struct</span> <span>{</span>
  <span>// Level is the log level. If no level is provided, the default level of</span>
  <span>// LevelError is used.</span>
  <span>Level</span> <span>LogLevel</span>

  <span>// Message is the actual log message.</span>
  <span>Message</span> <span>string</span>

  <span>// Fields is the list of structured logging fields. If two fields have the same</span>
  <span>// Name, the later one takes precedence.</span>
  <span>Fields</span> <span>[]</span><span>*</span><span>LogField</span>
<span>}</span>

<span>// LogField is a tuple of the named field (a string) and its underlying value.</span>
<span>type</span> <span>LogField</span> <span>struct</span> <span>{</span>
  <span>Name</span>  <span>string</span>
  <span>Value</span> <span>interface</span><span>{}</span>
<span>}</span>
</code></pre></div> <p>There is a lot of discussion to have around what the actual interface might look like, how to minimize allocations, and how to maximize compatibility, but the goal is to define an interface that other logging libraries could easily implement.</p> <p>Back in my Ruby days, there was a proliferation of Ruby version managers, each with their own dotfile name and syntax. Fletcher Nichol managed to convince all the maintainers of those Ruby version managers to standardize on <code>.ruby-version</code>, simply by <a href="https://gist.github.com/fnichol/1912050">writing a gist</a>. It is my hope that we can do something similar in the Go community with structured logging.</p> <h2 id="multi-error-handling">Multi-error handling</h2> <p>There are many cases, especially for background jobs or periodic tasks, where a system may process things in parallel or continue-on-error. In those cases, it&#39;s helpful to return a multi-error. There is no built-in support for handling collections of errors in the standard library.</p> <p>Having clear and concise standard library definitions around multi-error handling could unify the community and reduce risks for improper error handling, as we saw with error wrapping and unwrapping.</p> <h2 id="marshalling-for-json-error">Marshalling for JSON <code>error</code></h2> <p>Speaking of errors, did you know that embedding an <code>error</code> type into a struct field and then marshalling that struct as JSON will marshal the <code>&#34;error&#34;</code> field as <code>{}</code>?</p> <div><pre><code><span>// https://play.golang.org/p/gl7BPJOgmjr</span>
<span>package</span> <span>main</span>

<span>import</span> <span>(</span>
  <span>&#34;encoding/json&#34;</span>
  <span>&#34;fmt&#34;</span>
<span>)</span>

<span>type</span> <span>Response1</span> <span>struct</span> <span>{</span>
  <span>Err</span> <span>error</span> <span>`json:&#34;error&#34;`</span>
<span>}</span>

<span>func</span> <span>main</span><span>()</span> <span>{</span>
  <span>v1</span> <span>:=</span> <span>&amp;</span><span>Response1</span><span>{</span><span>Err</span><span>:</span> <span>fmt</span><span>.</span><span>Errorf</span><span>(</span><span>&#34;oops&#34;</span><span>)}</span>
  <span>b1</span><span>,</span> <span>err</span> <span>:=</span> <span>json</span><span>.</span><span>Marshal</span><span>(</span><span>v1</span><span>)</span>
  <span>if</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
    <span>panic</span><span>(</span><span>err</span><span>)</span>
  <span>}</span>

  <span>// got: {&#34;error&#34;:{}}</span>
  <span>// want: {&#34;error&#34;: &#34;oops&#34;}</span>
  <span>fmt</span><span>.</span><span>Println</span><span>(</span><span>string</span><span>(</span><span>b1</span><span>))</span>
<span>}</span>
</code></pre></div> <p>At least for the built-in <code>errorString</code> type, Go should marshal as the result of <code>.Error()</code>. Alternatively, for Go 2.0, JSON marshalling could return an error when trying to marshal an <code>error</code> type that does not implement custom marshalling logic.</p> <h2 id="no-more-public-variables-in-the-standard-library">No more public variables in the standard library</h2> <p>As just one example, both <code>http.DefaultClient</code> and <code>http.DefaultTransport</code> are global variables with shared state. <code>http.DefaultClient</code> has no configured timeout, which makes it <strong>trivial to DOS your own service</strong> and create bottlenecks. Many packages mutate <code>http.DefaultClient</code> and <code>http.DefaultTransport</code>, which can waste days of developer resources tracking down bugs.</p> <p>Go 2.0 should make these private and expose them via a function call that returns a unique allocation of the variable in question. Alternatively, Go 2.0 could implement &#34;frozen&#34; global variables, such that they cannot be mutated by other packages.</p> <p>I also worry about this class of issues from a software supply chain standpoint. If I can develop a useful package that secretly modifies the <code>http.DefaultTransport</code> to use a custom <code>RoundTripper</code> that funnels all your traffic through my servers, that would make for a very bad time.</p> <h2 id="native-support-for-buffered-renderers">Native support for buffered renderers</h2> <p>This is more of a &#34;thing that isn&#39;t well-known or documented&#34;. Most examples, including the examples in the Go documentation, encourage the following behavior for marshalling JSON or rendering HTML via a web request:</p> <div><pre><code><span>func</span> <span>toJSON</span><span>(</span><span>w</span> <span>http</span><span>.</span><span>ResponseWriter</span><span>,</span> <span>i</span> <span>interface</span><span>{})</span> <span>{</span>
  <span>if</span> <span>err</span> <span>:=</span> <span>json</span><span>.</span><span>NewEncoder</span><span>(</span><span>w</span><span>)</span><span>.</span><span>Encode</span><span>(</span><span>i</span><span>);</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
    <span>http</span><span>.</span><span>Error</span><span>(</span><span>w</span><span>,</span> <span>&#34;oops&#34;</span><span>,</span> <span>http</span><span>.</span><span>StatusInternalServerError</span><span>)</span>
  <span>}</span>
<span>}</span>

<span>func</span> <span>toHTML</span><span>(</span><span>w</span> <span>http</span><span>.</span><span>ResponseWriter</span><span>,</span> <span>tmpl</span> <span>string</span><span>,</span> <span>i</span> <span>interface</span><span>{})</span> <span>{</span>
  <span>if</span> <span>err</span> <span>:=</span> <span>templates</span><span>.</span><span>ExecuteTemplate</span><span>(</span><span>w</span><span>,</span> <span>tmpl</span><span>,</span> <span>i</span><span>);</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
    <span>http</span><span>.</span><span>Error</span><span>(</span><span>w</span><span>,</span> <span>&#34;oops&#34;</span><span>,</span> <span>http</span><span>.</span><span>StatusInternalServerError</span><span>)</span>
  <span>}</span>
<span>}</span>
</code></pre></div> <p>However, for both of these cases, if <code>i</code> is sufficiently large, it is possible that encoding/execution fails after the first bytes (and a 200 status code) have been sent. At this point, the request is irrecoverable, since you can&#39;t change the response code.</p> <p>The largely accepted solution to mitigate this is to render first, then copy to <code>w</code>. This still leaves a small room for error (where writing to <code>w</code> fails due to connection issues), but it ensures that encoding/execution is successful before sending the first byte. However, allocating a byte slice on each request can be expensive, so you typically <a href="https://github.com/google/exposure-notifications-verification-server/blob/08797939a56463fe85f0d1b7325374821ee31448/pkg/render/html.go#L65-L91">use a buffer pool</a>.</p> <p>This approach is really verbose and pushes a lot of unnecessary complexity onto the implementer. Instead, it would be great if Go handled this buffer pool management automatically, potentially with functions like <code>EncodePooled</code>.</p> <h2 id="wrapping-up">Wrapping up</h2> <p>Go continues to be one of my favorite programming languages, which is why I feel comfortable highlighting these criticisms. As with any programming language, Go is constantly evolving. Do you think these are good ideas? Or are they terrible suggestions? Let me know <a href="https://twitter.com/sethvargo">on Twitter</a>!</p> </section> <section> <h2>About Seth</h2> <p>Seth Vargo is an engineer at Google. Previously he worked at HashiCorp, Chef Software, CustomInk, and some Pittsburgh-based startups. He is the author of <a href="https://www.amazon.com/Learning-Chef-Configuration-Management-Automation/dp/1491944935">Learning Chef</a> and is passionate about reducing inequality in technology. When he is not writing, working on open source, teaching, or speaking at conferences, Seth advises non-profits.</p>  </section> </article> </section> </div> </section></div>
  </body>
</html>
