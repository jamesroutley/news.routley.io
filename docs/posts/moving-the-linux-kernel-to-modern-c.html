<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lwn.net/SubscriberLink/885941/01fdc39df2ecc25f/">Original</a>
    <h1>Moving the Linux Kernel to Modern C</h1>
    
    <div id="readability-page-1" class="page"><p>

<h2>[LWN subscriber-only content]</h2>
</p><div>
<!-- $Id: slink-trial,v 1.1 2005-11-04 21:27:01 corbet Exp $ -->
<center>
<table>
<tbody><tr><td>
<h3>Welcome to LWN.net</h3>
<p>
The following subscription-only content has been made available to you 
by an LWN subscriber.  Thousands of subscribers depend on LWN for the 
best news from the Linux and free software communities.  If you enjoy this 
article, please consider accepting the trial offer on the right.  Thank you
for visiting LWN.net!
</p></td><td>
<div>
<h3>Free trial subscription</h3>
           <p>
           Try LWN for free for 0 month: no payment
           or credit card required.  <a href="https://lwn.net/Promo/slink-trial2-3/claim">Activate
           your trial subscription now</a> and see why thousands of
           readers subscribe to LWN.net.
           
</p></div>
</td>
</tr>

</tbody></table>
</center>
<p>
Despite its generally fast-moving nature, the kernel project relies on a
number of old tools.  While critics like to focus on the community&#39;s
extensive use of email, a possibly more significant anachronism is the use
of the 1989 version of the C language standard for kernel code — a standard
that was codified before the kernel project even began over 30 years ago.
It is looking like that longstanding practice could be coming to an end as
soon as the 5.18 kernel, which can be expected in May of this year.
</p><h4>Linked-list concerns</h4>
<p>
The discussion started with <a href="https://lwn.net/ml/linux-kernel/20220217184829.1991035-1-jakobkoschel@gmail.com/">this
patch series</a> from Jakob Koschel, who is trying to prevent
speculative-execution vulnerabilities tied to the kernel&#39;s linked-list
primitives.  The kernel makes extensive use of doubly-linked lists defined
by <a href="https://elixir.bootlin.com/linux/v5.17-rc5/source/include/linux/types.h#L177"><tt>struct
list_head</tt></a>:
</p><pre>    struct list_head {
	struct list_head *next, *prev;
    };
</pre>
<p>
This structure is normally embedded into some other structure; in this way,
linked lists can be made with any structure type of interest.  Along with the
type, the kernel provides <a href="https://elixir.bootlin.com/linux/v5.17-rc5/source/include/linux/list.h">a
vast array of functions and macros</a> that can be used to traverse and
manipulate linked lists.  One of those is <a href="https://elixir.bootlin.com/linux/v5.17-rc5/source/scripts/kconfig/list.h#L43"><tt>list_for_each_entry()</tt></a>,
which is a macro masquerading as a sort of control structure.  To see how
this macro is used, imagine that the
kernel included a structure like this:
</p><pre>    struct foo {
    	int fooness;
	struct list_head list;
    };
</pre>
<p>
The <tt>list</tt> member can be used to create a doubly-linked list of
<tt>foo</tt> structures; a separate <tt>list_head</tt> structure is usually
declared as the beginning of such a list; assume we have one called
<tt>foo_list</tt>.  Traversing this list is possible with code like:
</p><pre>    struct foo *iterator;

    list_for_each_entry(iterator, &amp;foo_list, list) {
    	do_something_with(iterator);
    }
    /* Should not use iterator here */
</pre>
<p>

The
<tt>list</tt> parameter tells the macro what the name of the
<tt>list_head</tt> structure is within the <tt>foo</tt> structure.
This loop will be executed once for each element in the list, with
<tt>iterator</tt> pointing to that element.
</p><p>
Koschel included <a href="https://lwn.net/ml/linux-kernel/20220217184829.1991035-4-jakobkoschel@gmail.com/">a
patch</a> fixing a bug in the USB subsystem where the iterator passed to
this macro was used 
after the exit from the macro, which is a dangerous thing to do.  Depending
on what happens within the list, the contents of that iterator could be
something surprising, even in the absence of speculative execution.
Koschel fixed the problem by reworking the code in question to stop using
the iterator after the loop.
</p><h4>The plot twists</h4>
<p>
Linus Torvalds <a href="https://lwn.net/ml/linux-kernel/CAHk-=wg1RdFQ6OGb_H4ZJoUwEr-gk11QXeQx63n91m0tvVUdZw@mail.gmail.com/">didn&#39;t
much like the patch</a> and didn&#39;t see how it related to
speculative-execution vulnerabilities.  After Koschel <a href="https://lwn.net/ml/linux-kernel/86C4CE7D-6D93-456B-AA82-F8ADEACA40B7@gmail.com/">explained
the situation further</a>, though, Torvalds <a href="https://lwn.net/ml/linux-kernel/CAHk-=wiyCH7xeHcmiFJ-YgXUy2Jaj7pnkdKpcovt8fYbVFW3TA@mail.gmail.com/">agreed</a>
that &#34;<span>this is just a regular bug, plain and simple</span>&#34; and said
it should be fixed independently of the larger series.  But then he
wandered into the real source of the problem: that the iterator passed to
the list-traversal macros must be
declared in a scope outside of the loop itself:
</p><blockquote>
	The whole reason this kind of non-speculative bug can happen is
	that we historically didn&#39;t have C99-style &#34;declare variables in
	loops&#34;. So list_for_each_entry() - and all the other ones -
	fundamentally always leaks the last HEAD entry out of the loop,
	simply because we couldn&#39;t declare the iterator variable in the
	loop itself.
</blockquote>
<p>
If it were possible to write a list-traversal macro that could declare its
own iterator, then that iterator would not be visible outside of the loop
and this kind of problem would not arise.  But, since the kernel is stuck
on the C89 standard, declaring variables within the loop is not possible.
</p><p>
Torvalds said that perhaps the time had come to look to moving to the <a href="https://en.wikipedia.org/wiki/C99">C99 
standard</a> — it is still over 20 years old, but is at least recent
enough to allow block-level variable declarations.  As he noted, this move
hasn&#39;t been done in the past &#34;<span>because we had some odd problem with
some ancient gcc versions that broke documented initializers</span>&#34;.  But,
in the meantime,
the kernel has moved its minimum GCC requirement to version 5.1, so
perhaps those bugs are no longer relevant.
</p><p>
Arnd Bergmann, who tends to keep a close eye on cross-architecture
compiler issues, <a href="https://lwn.net/ml/linux-kernel/CAK8P3a0DOC3s7x380XR_kN8UYQvkRqvE5LkHQfK2-KzwhcYqQQ@mail.gmail.com/">agreed</a>
that it should be possible for the kernel to move forward.  Indeed, he
suggested that it would be possible to go as far as the <a href="https://en.wikipedia.org/wiki/C11_(C_standard_revision)">C11
standard</a> (from 2011) while the change was being made, though he wasn&#39;t
sure that 
C11 would bring anything new that would be useful to the kernel.  It might
even be possible to move to <a href="https://en.wikipedia.org/wiki/C17_(C_standard_revision)">C17</a> or
even the yet-unfinished <a href="https://en.wikipedia.org/wiki/C2x">C2x</a>
version of the language.  That, however, has a downside in that it
&#34;<span>would break gcc-5/6/7 support</span>&#34;, and the kernel still supports
those versions currently.  Raising the minimum GCC version to 8.x would
likely be more of a jump than the user community would be willing to accept
at this point.
</p><p>
Moving to C11 would not require changing the minimum GCC version, though,
and thus might be more readily doable.  Torvalds <a href="https://lwn.net/ml/linux-kernel/CAHk-=wicJ0VxEmnpb8=TJfkSDytFuf+dvQJj8kFWj0OF2FBZ9w@mail.gmail.com/">was
in favor</a> of that idea:
&#34;<span>I really would love to finally move forward on this, considering that
it&#39;s been brewing for many many years</span>&#34;.  After Bergmann <a href="https://lwn.net/ml/linux-kernel/CAK8P3a2b_RtXkhQ2pwqbZ1zz6QtjaWwD4em_MCF_wGXRwZirKA@mail.gmail.com/">confirmed</a>
that it should be possible to do so, Torvalds <a href="https://lwn.net/ml/linux-kernel/CAHk-=wh97QY9fEQUK6zMVQwaQ_JWDvR=R+TxQ_0OYrMHQ+egvQ@mail.gmail.com/">declared</a>:
&#34;<span>Ok, somebody please remind me, and let&#39;s just try this early in the
5.18 merge window</span>&#34;.
The 5.18 merge window is less than one month away, so this is a change that
could happen in the near future.
</p><p>
It is worth keeping in mind, though, that
a lot of things can happen between the merge window and the 5.18 release.
Moving to a new version of the language standard could reveal any number of
surprises in obscure places in the kernel; it would not take many of those
to cause the change to be reverted for now.  But, if all goes well, the
shift to C11 will happen in the next kernel release.  Converting all of the
users of <tt>list_for_each_entry()</tt> and variants (of which there are
well over 15,000 in the kernel) to a new version that doesn&#39;t expose the
internal iterator seems likely to take a little longer, though.</p>
               </div></div>
  </body>
</html>
