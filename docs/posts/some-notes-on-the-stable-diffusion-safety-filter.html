<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://vickiboykis.com/2022/11/18/some-notes-on-the-stable-diffusion-safety-filter/">Original</a>
    <h1>Some notes on the Stable Diffusion safety filter</h1>
    
    <div id="readability-page-1" class="page"><div><p>In time for <a href="https://nips.cc/">NeurIPS 2022</a>, there are a lot of interesting papers and preprints being published on ArXiv.</p><p>One I ran into recently was <a href="https://arxiv.org/abs/2210.04610v5">“Red-Teaming the Stable Diffusion Safety Filter.”</a></p><p>Having worked on content moderation before, the concept of how to moderate the content of a deep learning model was interesting to me and I thought it benefitted from a broader look.</p><p>Let’s dive in by starting with the paper title. The concept of “red-teaming” comes from cybersecurity. A red team is a group of people who have been authorized to act as an attacker in a given organization and probe for threats against a company’s security set-up. What they do can range from social engineering to penetration testing. The counter to this is the blue team, who defends against the red-team in this simulated scenario.</p><p>In this case, the researchers acting as the red team are trying to understand if they can bypass the safety filter that performs a high-level check on the output of a prompt generated by the Stable Diffusion model as hosted by HuggingFace in the <a href="https://github.com/huggingface/diffusers/">Diffusers Toolkit.</a></p><h2 id="quick-notes-on-diffusion-models-and-stable-diffusion">Quick notes on diffusion models and Stable Diffusion</h2><p><a href="https://github.com/CompVis/stable-diffusion">Stable Diffusion</a> is a text-to-image model released publicly in mid-2022 (seems like forever ago) that generates images based on text prompts that the user inputs. Other, earlier models <a href="https://lilianweng.github.io/posts/2021-07-11-diffusion-models/">in the diffusion family</a> include <a href="https://danielmiessler.com/blog/battle-of-the-ai-art-engines-midjourney-vs-dall-e/">DALL-E and Midjourney,</a> both of which were gated behind websites without a chance to inspect the code.</p><p>At an extremely high level, diffusion models work by learning to add statistically distributed noise to an image or a representation of an image and then, again, statistically removing noise until you get a picture that matches the properties of the input dataset but is, statistically, not the same image that was input.</p><figure><img src="https://raw.githubusercontent.com/veekaybee/veekaybee.github.io/master/static/images/gaussiannoise.png" width="600px"/></figure><a href="https://lilianweng.github.io/posts/2021-07-11-diffusion-models/">source</a><p>Stable Diffusion works by:</p><ol><li>Taking a large training set of real images (StableDiffusion itself was trained on 2.3 Billion images that are part of the <a href="https://simonwillison.net/2022/Sep/5/laion-aesthetics-weeknotes/">LAION dataset</a> and selected based on images that match a threshold for <a href="https://github.com/LAION-AI/laion-datasets/blob/main/laion-aesthetic.md">“aesthetic score”</a>.)</li><li>To make the pre-processing steps faster, the images are compressed into a smaller-dimension representation using a <a href="https://ermongroup.github.io/cs228-notes/extras/vae/">variational autoencoder</a> - the paper romantically calls this “departure to latent space.”</li><li>During the pre-processing used to generate the model’s input data, Gaussian noise is applied to the images’ latent representation.</li><li><a href="https://jalammar.github.io/illustrated-stable-diffusion/">Each time we add noise to a step</a>, we generatively build the part of the model called a “noise predictor”, which then allows us, for any given image, to probabilistically predict how much noise was added and how far it deviates from the original image. That prediction allows us to compare to the known noise from the original training data.</li><li>Once we train this noise predictor we can then run a decoder to denoise the data in small increments, which will remove that noise from a given image until we get a different image than the training set, but one that is semantically similar to the training set.</li></ol><p>Here’s the overall image-specific architecture:</p><figure><img src="https://raw.githubusercontent.com/veekaybee/veekaybee.github.io/master/static/images/diffusion.png" width="600px"/></figure><p>How do we now incorporate text? During inference, diffusion models work by adding guidance (otherwise, we’d just get random images without ability to steer from a text prompt):</p><ol><li>The model uses a Transformer language model, ClipText, to generate textual embeddings for the specific text prompt. Here’s a lot more information on <a href="https://openai.com/blog/clip/">how that model was trained</a>, but the general idea is that you have captioned images in which both the image and the caption, separately, are embedded into the same latent space using an encoder and compare the embeddings for the text and image using <a href="https://gist.github.com/veekaybee/32b121eceaa1dbfb6a268ea544893bd0">cosine similarity.</a></li><li>We pass these embeddings also into the UNet noising encoder that includes specific attention to the text, as well, and incorporate it in processing so that when we pass in a text prompt, we include that information in inference.</li></ol><h2 id="huggingface-diffusers">HuggingFace Diffusers</h2><p>As I mentioned, there are several ways to work with this model. If you are lucky enough to have at least 6GB of VRAM, you can download the model and <a href="https://github.com/CompVis/stable-diffusion">work with it locally.</a> Since there is no safety filter on that model, <a href="https://github.com/CompVis/stable-diffusion/blob/main/Stable_Diffusion_v1_Model_Card.md">in the model card</a>, there are a number of different caveats for misuse.</p><pre tabindex="0"><code>Misuse and Malicious Use

Using the model to generate content that is cruel to individuals is a misuse of this model. This includes, but is not limited to:

    + Generating demeaning, dehumanizing, or otherwise harmful representations of people or their environments, cultures, religions, etc.
    + Intentionally promoting or propagating discriminatory content or harmful stereotypes.
    + Impersonating individuals without their consent.
    + Sexual content without consent of the people who might see it.
    Mis- and disinformation
    Representations of egregious violence and gore
    + Sharing of copyrighted or licensed material in violation of its terms of use.
    Sharing content that is an alteration of copyrighted or licensed material in violation of its terms of use.
</code></pre><p>For everyone else, there’s HuggingFace via Google Colab. HuggingFace has a toolbox for diffusion models called <a href="https://huggingface.co/docs/diffusers/index">Diffusers</a> that also incorporate the ability to perform inference on Stable Diffusion using Pipelines, as well.</p><h2 id="digging-into-the-safety-filter">Digging into the Safety Filter</h2><p>Ok! Now that we have that out of the way, we can start to understand the safety filter</p><p>There are two versions of Stable Diffusion, one that you can clone and run on your own if you have enough hardware, and one that is hosted by HuggingFace using its <a href="https://huggingface.co/blog/stable_diffusion">Diffusers library</a> which you can run as a HuggingFace pipeline from either a local or Colab notebook. In order to perform inference against this version, you need to authenticate against HuggingFace’s API.</p><p>If you’ve played around with Stable Diffusion, you may have noticed that you get a black box for a given prompt. Here’s an example I was playing around with while trying to generate an image for another blog post I was working on around the topic of embeddings:</p><figure><img src="https://raw.githubusercontent.com/veekaybee/veekaybee.github.io/master/static/images/blackbox.png" width="600px"/></figure><p>The blog post notes,</p><blockquote><p>If at some point you get a black image, it may be because the content filter built inside the model might have detected an NSFW result. If you believe this shouldn’t be the case, try tweaking your prompt or using a different seed. In fact, the model predictions include information about whether NSFW was detected for a particular result. Let’s see what they look like:</p></blockquote><p>Why would dolphins be censored though? The way the safety filter works, as described by the paper is:</p><ol><li>The user inputs a text prompt for inference</li><li>An image is generated by Stable Diffusion for the user</li><li>Before being shown to the user, that image is projected into the CLIP embedding space, the same space used for the text training of Stable Diffusion</li><li>The image’s embedding is compared to one of 17 fixed embedding vectors in CLIP that are determined to be pre-sensitive concept filters, and if the cosine similarity is above some threshold, the image is filtered out and the user is shown the black box.</li><li>All of this happens at inference time, which is amazingly fast.</li></ol><p>As the paper points out, the code for the safety check <a href="https://github.com/huggingface/diffusers/blob/main/src/diffusers/pipelines/stable_diffusion/safety_checker.py">actually happens here:</a></p><p>There are a number of interesting parts here, but the takeaway is that, ultimately in the face of incredible deep learning technology, content safety still ends up being a very human-judgment driven task.</p><p>Check this out, <a href="https://github.com/huggingface/diffusers/blob/5dcef138bf9addd53a9abc80c5436ea948bb22d0/src/diffusers/pipelines/stable_diffusion/safety_checker.py#L66">for example</a>, the piece of code that is responsible for tuning the filter, right now very manual and based on a human-judgment threshold, as well as the 17 concepts (unclear what these are, only what their embedding representations are):</p><div><pre tabindex="0"><code data-lang="python"><span><span><span># increase this value to create a stronger `nfsw` filter</span>
</span></span><span><span><span># at the cost of increasing the possibility of filtering benign images</span>
</span></span><span><span>adjustment <span>=</span> <span>0.0</span>
</span></span><span><span>
</span></span><span><span><span>for</span> concept_idx <span>in</span> range(len(special_cos_dist[<span>0</span>])):
</span></span><span><span>    concept_cos <span>=</span> special_cos_dist[i][concept_idx]
</span></span><span><span>    concept_threshold <span>=</span> self<span>.</span>special_care_embeds_weights[concept_idx]<span>.</span>item()
</span></span><span><span>    result_img[<span>&#34;special_scores&#34;</span>][concept_idx] <span>=</span> round(concept_cos <span>-</span> concept_threshold <span>+</span> adjustment, <span>3</span>)
</span></span><span><span>    <span>if</span> result_img[<span>&#34;special_scores&#34;</span>][concept_idx] <span>&gt;</span> <span>0</span>:
</span></span><span><span>        result_img[<span>&#34;special_care&#34;</span>]<span>.</span>append({concept_idx, result_img[<span>&#34;special_scores&#34;</span>][concept_idx]})
</span></span><span><span>        adjustment <span>=</span> <span>0.01</span>
</span></span><span><span>
</span></span><span><span><span>for</span> concept_idx <span>in</span> range(len(cos_dist[<span>0</span>])):
</span></span><span><span>    concept_cos <span>=</span> cos_dist[i][concept_idx]
</span></span><span><span>    concept_threshold <span>=</span> self<span>.</span>concept_embeds_weights[concept_idx]<span>.</span>item()
</span></span><span><span>    result_img[<span>&#34;concept_scores&#34;</span>][concept_idx] <span>=</span> round(concept_cos <span>-</span> concept_threshold <span>+</span> adjustment, <span>3</span>)
</span></span><span><span>    <span>if</span> result_img[<span>&#34;concept_scores&#34;</span>][concept_idx] <span>&gt;</span> <span>0</span>:
</span></span><span><span>        result_img[<span>&#34;bad_concepts&#34;</span>]<span>.</span>append(concept_idx)
</span></span><span><span>
</span></span><span><span>result<span>.</span>append(result_img)
</span></span><span><span>
</span></span><span><span>has_nsfw_concepts <span>=</span> [len(res[<span>&#34;bad_concepts&#34;</span>]) <span>&gt;</span> <span>0</span> <span>for</span> res <span>in</span> result]
</span></span><span><span>
</span></span><span><span><span>for</span> idx, has_nsfw_concept <span>in</span> enumerate(has_nsfw_concepts):
</span></span><span><span><span>if</span> has_nsfw_concept:
</span></span><span><span>    images[idx] <span>=</span> np<span>.</span>zeros(images[idx]<span>.</span>shape)  <span># black image</span>
</span></span><span><span>
</span></span><span><span><span>if</span> any(has_nsfw_concepts):
</span></span><span><span>logger<span>.</span>warning(
</span></span><span><span>    <span>&#34;Potential NSFW content was detected in one or more images. A black image will be returned instead.&#34;</span>
</span></span><span><span>    <span>&#34; Try again with a different prompt and/or seed.&#34;</span>
</span></span><span><span>)
</span></span><span><span>
</span></span><span><span><span>return</span> images, has_nsfw_concepts
</span></span></code></pre></div><p>The researchers note the opaqueness of this classification (i.e. why did my dolphin image get flagged, what was it close to in the latent space?) and do a bunch of additional work in testing prompts to find out what bypasses the safety filter.</p><figure><img src="https://raw.githubusercontent.com/veekaybee/veekaybee.github.io/master/static/images/filterbypass.png" width="600px"/></figure><p>And, in an additional piece of really impressive work, reverse-engineering the CLIP embeddings to find out what the sensitive terms actually are (<a href="https://arxiv.org/pdf/2210.04610v5.pdf">last page of the linked paper here.</a>)</p><p>So what are the hypotheses for why my prompt could have been filtered? The simple answer is that the generated image’s embedding representation ended up being close to the embedding representation one of 17 sexually-oriented terms from the CLIP model space, as measured by some cosine similarity.</p><p>Probably easier to just put</p><pre tabindex="0"><code>&#34;Potential NSFW content was detected in one or more images. A black image will be returned instead.&#34;
</code></pre><p>instead.</p><h2 id="the-takeaway">The Takeaway</h2><p>There are a couple of very, very interesting parts of this paper for me.</p><ol><li>Even though machine learning models are, in theory, very, very good at detecting NSFW content (in fact it’s one of the key actually-useful use-cases for ML), this is an entirely new space we’re still learning how to navigate for these new deep-learning based approaches to computer vision. The policy has in no way caught up with the tech yet.</li><li>As such we are still relying on very manual human judgment lists to filter out bad content in deep learning, an area that’s just getting started with this. If you’ve ever worked in content safety, you know that these lists can be miles long. 17 is just the very start of what will eventually become a very long list :).</li><li>There is an ENORMOUS amount of context that you need to evaluate these models, and there is still much about them that is extremely opaque and resistant to evaluation. I am not a stable diffusion expert but I do know machine learning, and even still, I had to do a fair amount of reading to get caught up with the context of this particular paper.</li></ol><p>We need a lot more introspection, simplification, and education about these models, and this paper is a fantastic starting point.</p></div></div>
  </body>
</html>
