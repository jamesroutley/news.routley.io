<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://dougallj.wordpress.com/2020/01/13/bit-twiddling-addition-with-unknown-bits/">Original</a>
    <h1>Bit-twiddling abstract addition with unknown bits (2020)</h1>
    
    <div id="readability-page-1" class="page"><div>
		<p><em>(If you can’t read the code in this post on mobile, try this <a href="https://gist.github.com/dougallj/36359c3ee6c0272ad0c456926dbe5b61">wrapped version</a> instead, sorry)</em></p>
<p>Suppose you have two values. You know some bits are zero, some bits are one, other bits could be either. You can add together those two values to get another such partially-known value, determining as precisely as possible which bits can be known and which cannot. This operation is common in optimising compilers and program analysis, and it has some interesting properties that I’ll circle back to, but first here’s my implementation of the addition operation described above:</p>
<pre>  struct known_bits {
    unsigned ones;
    unsigned unknowns;
  };

  struct known_bits kb_add(struct known_bits a,
                           struct known_bits b) {
    struct known_bits result;
    unsigned x = a.ones + b.ones;
    result.unknowns = a.unknowns | b.unknowns |
                      (x ^ (x + a.unknowns + b.unknowns));
    result.ones = x &amp; ~result.unknowns;
    return result;
  }</pre>
<p>This function compiles to about 12 instructions, the assembly for which fits in a tweet. But let’s look at the theory behind it all.</p>
<h2>Representation</h2>
<p>A perhaps surprising amount of thought went into that simple-looking structure.</p>
<p>Each partially known value is a ternary number (with digits zero, one and unknown), so for a 32-bit number, there are 3<sup>32</sup> possible values. This requires more than one 32-bit value to represent, but can be comfortably represented with two or three 32-bit values. Initially, I stored “known ones” and “mask”, where the mask was set for all known bits. After figuring out most of my functions, I realised I could remove a significant number of bitwise nots by storing the unknown bits instead of known bits.</p>
<p>I could also store a third value, “known zeroes”, but this can be calculated if needed by the expression <strong>~(v.ones | v.unknowns)</strong>, and it seemed error prone to make the representation more redundant.</p>
<h2>Theory</h2>
<p>But that’s enough about code – let’s get back to some maths. Each value can be thought of as a lossy representation of a set of possible numbers. The size of this set is given by 2<sup>popcount(unknowns)</sup> (meaning if there are no unknown bits it represents a single value, or if there are two unknown bits it represents four possible values).</p>
<p>The representation is lossy. It would take 2<sup>32</sup> bits to represent an arbitrary subset of the 32-bit integers, and I’m only storing 64 bits. For example, consider the set <strong>{000, 011}</strong>. This is represented as <strong>0UU </strong>(maximising for precision), which represents the superset <strong>{000, 001, 010, 011}</strong>.</p>
<p>In some sense, the most fundamental operation is the “union” operation:</p>
<pre>   r.ones = a.ones &amp; b.ones;
   r.unknowns = a.unknowns | b.unknowns | (a.ones ^ b.ones);</pre>
<p>This combines two sets, such that only bits which are known to be the same are known in the result.</p>
<p>The other fundamental operation is iteration. This is done by iterating over values up to the set size (2<sup>popcount(unknowns)</sup>), and distributing those bits to the unknown bit locations. This can be written efficiently using a technique described in Fabian Giesen’s <em><a href="https://fgiesen.wordpress.com/2011/01/17/texture-tiling-and-swizzling/">Texture tiling and swizzling</a></em>.</p>
<p>Using these two operations, we can define an algorithm for computing the maximally precise known bits after any operation. As a pseudocode example:</p>
<pre>  r = known_value(op(a.ones, b.ones))
  for each possible a as A
    for each possible b as B
      r = union(r, known_value(op(A, B)))</pre>
<p>This has an exponential runtime, so it’s entirely impractical, but I quite like it as a mathematical definition of the best possible result, and it can be useful for quickly testing better algorithms.</p>
<h2>Some Bitwise Operations</h2>
<p>Bitwise operations have relatively simple definitions. A nice example is <strong>or</strong>:</p>
<pre>  r.ones = a.ones | b.ones;
  r.unknowns = (a.unknowns | b.unknowns) &amp; ~r.ones;</pre>
<p>Any known ones in either input will be known ones in the output, known zeroes in both inputs will give a known zero output, and anything else is unknown. For example: <strong>00011U | 0U1U1U = 0U111U</strong>.</p>
<p>Another example is <strong>xor</strong>.</p>
<pre>  r.unknowns = a.unknowns | b.unknowns;
  r.ones = (a.ones ^ b.ones) &amp; ~r.unknowns;</pre>
<p>Any unknowns in either input will be unknown, but any two known values are xored. For example: <strong>00011U ^ 0U1U1U = 0U1U0U</strong>.</p>
<p>It’s worth remembering that xor is basically addition without the carry.</p>
<h2>Addition Operation</h2>
<p>Coming back to addition, there are a few things worth noting. Firstly, our addition is not associative, for example:</p>
<pre>  (0001 + 0001) + 000U = 0010 + 000U = 001U
  0001 + (0001 + 000U) = 0001 + 00UU = 0UUU</pre>
<p>The addition algorithm shown above comes from a few logical ideas. Firstly, any unknown bit in either input will be unknown in the output (because it can change the result bit in the same location). Secondly, some carry bits may also become unknown, possibly a whole run of them. These unknown bits can be determined by finding difference between the maximum possible sum and the minimum possible sum.</p>
<p>The minimum value in a given set is <strong>a.ones</strong> and the maximum is <strong>a.ones | a.unknowns</strong>. So the initial algorithm was:</p>
<pre>  struct known_bits kb_add(struct known_bits a,
                           struct known_bits b) {
    struct known_bits result;
    result.unknowns = a.unknowns | b.unknowns |
                      ((a.ones + b.ones) ^ ((a.ones | a.unknowns) +
                                            (b.ones | b.unknowns));
    result.ones = (a.ones + b.ones) &amp; ~result.unknowns;
    return result;
  }</pre>
<p>Alternately, the maximum can be represented as <strong>(a.ones + a.unknowns)</strong> because no bits are set in both <strong>a.ones</strong> and <strong>a.unknowns</strong>, so the addition will never carry. This representation allows the following transformation to the function above:</p>
<pre>    (a.ones | a.unknowns) + (b.ones | b.unknowns)
  = (a.ones + a.unknowns) + (b.ones + b.unknowns)
  = (a.ones + b.ones) + a.unknowns + b.unknowns</pre>
<p>The <strong>(a.ones + b.ones)</strong> expression now appears in three places, so we calculate it ahead of time to simplify things, giving the function shown at the top.</p>
<h2>Questions</h2>
<p>Can you prove or disprove the addition function? I can’t find a counter-example when exhaustively searching 8-bit values, but that’s not really a proof.</p>
<p>Can you compute the known-bits for multiplication? It’s easy to start getting useful results, but I would love to see a maximally precise less-than-exponential-time algorithm. Can it be proven that that’s impossible?</p>
<p>Can it be simplified further? John Regehr has had <a href="https://twitter.com/johnregehr/status/1216458475783372800">interesting results in program synthesis along these lines</a> (which is what reminded me to post this – thanks!)</p>
<p><em>Update: </em>if you want to play with implementing different operations, I’ve put some test code <a href="https://gist.github.com/dougallj/9211fd24c3759f7f340dede28929c659">in a gist</a>, based on a gist by <a href="https://twitter.com/zwegner/status/1216548380576534536">@zwegner</a>. It includes an implementation of subtraction.</p>
			</div></div>
  </body>
</html>
