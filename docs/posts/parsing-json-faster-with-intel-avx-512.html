<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lemire.me/blog/2022/05/25/parsing-json-faster-with-intel-avx-512/">Original</a>
    <h1>Parsing JSON faster with Intel AVX-512</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>Many recent Intel processors benefit from a new family of instructions called AVX-512. These instructions operate over wide registers (up to 512 bits) and follow the <a href="https://en.wikipedia.org/wiki/Single_instruction,_multiple_data">Single instruction, multiple data (SIMD) paradigm</a>. These new AVX-512 instructions allow you to break some speed records, such as decoding <a href="https://en.wikipedia.org/wiki/Base64">base64</a> data at <a href="https://arxiv.org/abs/1910.05109">the speed of a memory copy</a>.</p>
<p>Most modern processors have SIMD instructions. The AVX-512 instructions are wider (more bits per register), but that is not necessarily their main appeal. If you merely take existing SIMD algorithms and apply them to AVX-512, you will probably not benefit as much as you would like. It is true that wider registers are beneficial, but in superscalar processors (processors that can issue several instructions per cycle), the number of instructions you can issue per cycle matters as much if not more. Typically, 512-bit AVX-512 instructions are more expensive and the processor can issue fewer of them per cycle. To fully benefit from AVX-512, you need to carefully design your code. It is made more challenging by the fact that Intel is releasing these instructions progressively: the recent processors have many new powerful AVX-512 instructions that were not initially available. Thus, AVX-512 is not “one thing” but rather a family of instruction sets.</p>
<p>Furthermore, early implementations of the AVX-512 instructions often lead to measurable downclocking: the processor would reduce its frequency for a time following the use of these instructions. Thankfully, the latest Intel processors to support AVX-512 (Rocket Lake and Ice Lake) <a href="https://travisdowns.github.io/blog/2020/08/19/icl-avx512-freq.html">have done away with this systematic frequency throttling</a>. Thankfully, it is easy to detect these recent processors at runtime.</p>
<p>Amazon’s powerful Intel servers are based on Ice Lake. Thus if you are deploying your software applications to the cloud on powerful servers, you probably have pretty good support for AVX-512 already !</p>
<p>A few years ago, we released a <a href="https://simdjson.org">really fast C++ JSON parser called simdjson</a>. It is somewhat unique as a parser in the fact that it relies critically on SIMD instructions. On several metrics, it was and still is the fastest JSON parser though other interesting competitors have emerged.</p>
<p>Initially, I had written a quick and dirty AVX-512 kernel for simdjson. We never merged it and after a time, I just deleted it. I then forgot about it.</p>
<p>Thanks to contributions from talented Intel engineers (Fangzheng Zhang and Weiqiang Wan) as well as indirect contributions from readers of this blog (Kim Walisch and Jatin Bhateja), we produced a new and shiny AVX-512 kernel. As always, keep in mind that the simdjson is the work of many people, a whole community of dozens of contributors. I must express my gratitude to Fangzheng Zhang who first wrote to me about an AVX-512 port.</p>
<p><a href="https://github.com/simdjson/simdjson/releases">We just released in the latest version of simdjson</a>. It breaks new speed records.</p>
<p>Let us consider an interesting test where you seek to scan a whole file (spanning kilobytes) to find a value corresponding to some identifier. In simdjson, the code is as follows:</p>
<pre>   <span>auto</span> doc <span>=</span> parser<span>.</span>iterate<span>(</span>json<span>)</span><span>;</span>    
   <span>for</span> <span>(</span><span>auto</span> tweet <span>:</span> doc<span>.</span>find_field<span>(</span><span>&#34;</span><span>statuses</span><span>&#34;</span><span>)</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span>uint64_t<span>(</span>tweet<span>.</span>find_field<span>(</span><span>&#34;</span><span>id</span><span>&#34;</span><span>)</span><span>)</span> <span>=</span><span>=</span> find_id<span>)</span> <span>{</span>
        result <span>=</span> tweet<span>.</span>find_field<span>(</span><span>&#34;</span><span>text</span><span>&#34;</span><span>)</span><span>;</span>
        <span>return</span> true<span>;</span>
      <span>}</span>
    <span>}</span>
    <span>return</span> false<span>;</span>
</pre>
<p>On a Tiger Lake processor, with GCC 11, I get a doubling of the processing speed, expressed by the number of input bytes processed per second.</p>
<table>
<tbody>
<tr>
<td>simdjson (512-bit SIMD): new</td>
<td>7.4 GB/s</td>
</tr>
<tr>
<td>simdjson (256-bit SIMD): old</td>
<td>4.6 GB/s</td>
</tr>
</tbody>
</table>
<p>The speed gain is so important because in this task we most just read the data, and we do relatively little secondary processing. We do not create a tree out of the JSON data, we do not create a data structure.</p>
<p>The simdjson library has a minify function which just strips unnecessary spaces from the input. Maybe surprisingly, we are more than twice as fast as the previous baseline:</p>
<table>
<tbody>
<tr>
<td>simdjson (512-bit SIMD): new</td>
<td>12 GB/s</td>
</tr>
<tr>
<td>simdjson (256-bit SIMD): old</td>
<td>4.3 GB/s</td>
</tr>
</tbody>
</table>
<p>Another reasonable benchmark is to fully parse the input into a DOM tree with full validation. Parsing a standard JSON file (<tt>twitter.json</tt>), I get nearly a 30% gain:</p>
<table>
<tbody>
<tr>
<td>simdjson (512-bit SIMD): new</td>
<td>3.6 GB/s</td>
</tr>
<tr>
<td>simdjson (256-bit SIMD): old</td>
<td>2.8 GB/s</td>
</tr>
</tbody>
</table>
<p>While 30% may sound unexciting, we are starting from a fast baseline.</p>
<p>Could we do better? Assuredly. There are many AVX-512 that we are not using yet. We do not use ternary Boolean operations (<tt>vpternlog</tt>). We are not using the new powerful shuffle functions (e.g., <tt>vpermt2b</tt>). We have an example of coevolution: better hardware requires new software which, in turn, makes the hardware shine.</p>
<p>Of course, to get these new benefits, you need recent Intel processors with adequate AVX-512 support and, evidently, you also need relatively recent C++ processors. Some of the recent laptop-class Intel processors do not support AVX-512 but you should be fine if you rely on AWS and have big Intel nodes.</p>
<p>You can grab our <a href="https://github.com/simdjson/simdjson/releases/tag/v2.0.0">release directly</a> or wait for it to reach one of the standard package managers (MSYS2, conan, vcpkg, brew, debian, FreeBSD, etc.).</p>
</div></div>
  </body>
</html>
