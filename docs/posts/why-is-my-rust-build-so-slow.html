<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://fasterthanli.me/articles/why-is-my-rust-build-so-slow">Original</a>
    <h1>Why is my Rust build so slow?</h1>
    
    <div id="readability-page-1" class="page"><div>
  

  <p>I&#39;ve recently come back to an older project of mine (that powers this website),
and as I did some maintenance work: upgrade to newer crates, upgrade to <a href="https://www.whatrustisit.com/">a newer
rustc</a>, I noticed that my build was taking too
damn long!</p>
<p>For me, this is a <em>big</em> issue. Because I juggle a lot of things at any given
time, and I have less and less time to just hyperfocus on an issue, I try to
make my setup as productive as possible.</p>
<p>This is why, for work, I bought a
<a href="https://www.amd.com/en/products/cpu/amd-ryzen-9-5950X">5950X</a>. It&#39;s no
ThreadRipper, but it gives me 32 logical cores to play with, and most of the
time, the computer is waiting on me, rather than the other way around.</p>

            <picture>
                <source type="image/avif" srcset="/content/articles/why-is-my-rust-build-so-slow/assets/ryzen-mobo.27b47b2041b821d8.avif"/>
                <source type="image/webp" srcset="/content/articles/why-is-my-rust-build-so-slow/assets/ryzen-mobo.7a28ffe1ad4c4a3d.webp"/>
                <img loading="lazy" src="https://scattered-thoughts.net/content/articles/why-is-my-rust-build-so-slow/assets/ryzen-mobo.a02da6ed6cb8910c.jpg"/>
            </picture>
            
<p>But despite having a beefy CPU, an excessive amount of RAM (128GB), and a very
fast SSD, my project took 2m09s for a &#34;cold&#34; release build, and 1m11s for a &#34;hot&#34;
release build (changing a single line in <code>main.rs</code> and recompiling).</p>
<pre><p>Shell session</p><p><code>$ time cargo build --release
      Finished release [optimized + debuginfo] target(s) in 2m 09s
cargo build --release  890.49s user 117.77s system 779% cpu 2:09.31 total
$ echo &#34;Editing some files...&#34;
$ time cargo build --release
    Finished release [optimized + debuginfo] target(s) in 1m 11s
cargo build --release  127.99s user 8.42s system 191% cpu 1:11.32 total
</code></p></pre>
<p>It would make sense for the initial build to be somewhat long, as I&#39;m pulling a
lot of crates here, 334 to be exact:</p>
<pre><p>Shell session</p><p><code>$ cat Cargo.lock | toml2json | jq &#39;.package | length&#39;
334
</code></p></pre><div>

<p><code>Cargo.lock</code> is a TOML file that contains <code>package</code> entries for all used crates
(even transitive dependencies).
<a href="https://github.com/woodruffw/toml2json">toml2json</a> is a Rust CLI utility that
does exactly what it sounds like, and <a href="https://stedolan.github.io/jq/">jq</a> lets
me count items in an array.</p>
</div>
<p>And it would make some sense for the &#34;hot&#34; release build to take some time, too
because there&#39;s quite a bit of code in that main crate: I really need to split
it up into several smaller crates to have clearer interfaces and make
compilation faster (because crates can be compiled in parallel).</p>
<pre><p>Shell session</p><p><code>$ tokei -t=Rust
===============================================================================
 Language            Files        Lines         Code     Comments       Blanks
===============================================================================
 Rust                   54         7334         6483           30          821
 |- Markdown             8           31            0           31            0
 (Total)                           7365         6483           61          821
===============================================================================
 Total                  54         7334         6483           30          821
===============================================================================
</code></p></pre><div>

<p><a href="https://lib.rs/crates/tokei">tokei</a> is a Rust CLI tool to count lines of code.</p>
<p>Counting lines of code is a silly measure that should almost never be used, but
let&#39;s keep it simple for now.</p>
</div>
<p>If you <em>haven&#39;t</em> been writing Rust for a long time, you&#39;ve probably heard &#34;Rust
compile times are long&#34; and so it might be hard for you to gauge whether &#34;over
one minute&#34; is excessive for a hot build, luckily I&#39;m here to tell you: <em>of
course it&#39;s excessive</em>.</p>
<p>Anything over &#34;a few seconds&#34; is excessive.</p>
<p>So, how do we find what&#39;s going on?</p>
<h2>What is cargo even doing</h2>
<p>In another language, say, C or C++, we might write a Makefile by hand.</p>
<div>

<p>What? No. Nobody does that anymore.</p>
</div>
<p>Okay, well, you might write a file, that eventually generates a Makefile, or a
set of instructions for ninja, or MSBuild, or xcodebuild, or whatever: the point
is, at some point you would have a file to look at, that would tell you what
steps are involved in building your thing.</p>
<p>And if you made a diagram out of it, it would look something like that:</p>
<p><img src="https://scattered-thoughts.net/content/articles/why-is-my-rust-build-so-slow/assets/c-build-pipeline.5ce1780d188652a1.svg" alt="" loading="lazy"/></p><p>And building Rust looks a lot like this!</p>
<p>It&#39;s just that, y&#39;know, <code>cargo</code> is driving the whole process, so most of the
time you don&#39;t really need to concern yourself with the details.</p>
<p>But if you <em>want</em> to concern yourself with the details, you can!</p>
<p>Say for example, we look inside the <code>target/</code> directory, we would find files
like these:</p>
<pre><p>Shell session</p><p><code>$ find target -name &#39;*.rlib&#39; | head -5
target/release/deps/libmatches-db00cdc86371b34a.rlib
target/release/deps/libcfg_if-038689491f275bed.rlib
target/release/deps/libpin_project_lite-06e0655a601f73df.rlib
target/release/deps/libfnv-663a3fe7793aefd3.rlib
target/release/deps/libtinyvec_macros-4b4139e126989f5f.rlib
</code></p></pre>
<p>And these are just &#34;ar archives&#34; (the ar stands for &#34;archive&#34; already, it&#39;s
a bit of an &#34;ATM machine&#34; situation), at least on Linux here:</p>
<pre><p>Shell session</p><p><code>$ file ./target/release/deps/libtree_sitter_highlight-dbbf005203d40df6.rlib 
./target/release/deps/libtree_sitter_highlight-dbbf005203d40df6.rlib: current ar archive
</code></p></pre>
<p>And an ar archive just contains a bunch of <code>.o</code>:</p>
<pre><p>Shell session</p><p><code>$ ar t ./target/release/deps/libtree_sitter_highlight-dbbf005203d40df6.rlib
tree_sitter_highlight-dbbf005203d40df6.tree_sitter_highlight.f125e660-cgu.0.rcgu.o
tree_sitter_highlight-dbbf005203d40df6.tree_sitter_highlight.f125e660-cgu.1.rcgu.o
tree_sitter_highlight-dbbf005203d40df6.tree_sitter_highlight.f125e660-cgu.10.rcgu.o
tree_sitter_highlight-dbbf005203d40df6.tree_sitter_highlight.f125e660-cgu.11.rcgu.o
tree_sitter_highlight-dbbf005203d40df6.tree_sitter_highlight.f125e660-cgu.12.rcgu.o
tree_sitter_highlight-dbbf005203d40df6.tree_sitter_highlight.f125e660-cgu.13.rcgu.o
tree_sitter_highlight-dbbf005203d40df6.tree_sitter_highlight.f125e660-cgu.14.rcgu.o
tree_sitter_highlight-dbbf005203d40df6.tree_sitter_highlight.f125e660-cgu.15.rcgu.o
tree_sitter_highlight-dbbf005203d40df6.tree_sitter_highlight.f125e660-cgu.2.rcgu.o
tree_sitter_highlight-dbbf005203d40df6.tree_sitter_highlight.f125e660-cgu.3.rcgu.o
tree_sitter_highlight-dbbf005203d40df6.tree_sitter_highlight.f125e660-cgu.4.rcgu.o
tree_sitter_highlight-dbbf005203d40df6.tree_sitter_highlight.f125e660-cgu.5.rcgu.o
tree_sitter_highlight-dbbf005203d40df6.tree_sitter_highlight.f125e660-cgu.6.rcgu.o
tree_sitter_highlight-dbbf005203d40df6.tree_sitter_highlight.f125e660-cgu.7.rcgu.o
tree_sitter_highlight-dbbf005203d40df6.tree_sitter_highlight.f125e660-cgu.8.rcgu.o
tree_sitter_highlight-dbbf005203d40df6.tree_sitter_highlight.f125e660-cgu.9.rcgu.o
lib.rmeta
</code></p></pre>
<p>And these, in turn, contain symbols: variables, functions, etc. and their
associated code, already compiled, and ready to be linked:</p>
<pre><p>Shell session</p><p><code>$ nm ./target/release/deps/libtree_sitter_highlight-dbbf005203d40df6.rlib | tail -8
nm: lib.rmeta: no symbols
0000000000000000 T _ZN4core3ptr68drop_in_place$LT$alloc..raw_vec..RawVec$LT$tree_sitter..Node$GT$$GT$17h79c5587a7f50bc54E.llvm.2637932016532741116
0000000000000000 t _ZN4core3ptr77drop_in_place$LT$alloc..vec..Vec$LT$tree_sitter_highlight..LocalScope$GT$$GT$17hb6e2dd6e6944713aE
                 U _ZN59_$LT$tree_sitter..Tree$u20$as$u20$core..ops..drop..Drop$GT$4drop17hee429551fa9c7144E
                 U _ZN66_$LT$tree_sitter..QueryCursor$u20$as$u20$core..ops..drop..Drop$GT$4drop17h94c27d3825e7214aE
0000000000000000 T _ZN86_$LT$alloc..vec..into_iter..IntoIter$LT$T$C$A$GT$$u20$as$u20$core..ops..drop..Drop$GT$4drop17h65a129b4029ecfd2E
0000000000000000 T _ZN86_$LT$alloc..vec..into_iter..IntoIter$LT$T$C$A$GT$$u20$as$u20$core..ops..drop..Drop$GT$4drop17he83a9f6dd95c6c07E

lib.rmeta:
</code></p></pre><div>

<p>Mhh that&#39;s not super readable.</p>
</div>
<p>True! We can pipe them into <a href="https://crates.io/crates/rustfilt">rustfilt</a> to <a href="https://en.wikipedia.org/wiki/Name_mangling">demangle</a> them.</p>
<pre><p>Shell session</p><p><code>$ nm ./target/release/deps/libtree_sitter_highlight-dbbf005203d40df6.rlib | tail -8 | rustfilt
nm: lib.rmeta: no symbols
0000000000000000 T core::ptr::drop_in_place&lt;alloc::raw_vec::RawVec&lt;tree_sitter::Node&gt;&gt;
0000000000000000 t core::ptr::drop_in_place&lt;alloc::vec::Vec&lt;tree_sitter_highlight::LocalScope&gt;&gt;
                 U &lt;tree_sitter::Tree as core::ops::drop::Drop&gt;::drop
                 U &lt;tree_sitter::QueryCursor as core::ops::drop::Drop&gt;::drop
0000000000000000 T &lt;alloc::vec::into_iter::IntoIter&lt;T,A&gt; as core::ops::drop::Drop&gt;::drop
0000000000000000 T &lt;alloc::vec::into_iter::IntoIter&lt;T,A&gt; as core::ops::drop::Drop&gt;::drop

lib.rmeta:
</code></p></pre>
<p>Or just use nm&#39;s <code>--demangle</code> option:</p>
<pre><p>Shell session</p><p><code>$ nm --demangle ./target/release/deps/libtree_sitter_highlight-dbbf005203d40df6.rlib | tail -8  
nm: lib.rmeta: no symbols
0000000000000000 T _ZN4core3ptr68drop_in_place$LT$alloc..raw_vec..RawVec$LT$tree_sitter..Node$GT$$GT$17h79c5587a7f50bc54E.llvm.2637932016532741116
0000000000000000 t core::ptr::drop_in_place&lt;alloc::vec::Vec&lt;tree_sitter_highlight::LocalScope&gt;&gt;
                 U &lt;tree_sitter::Tree as core::ops::drop::Drop&gt;::drop
                 U &lt;tree_sitter::QueryCursor as core::ops::drop::Drop&gt;::drop
0000000000000000 T &lt;alloc::vec::into_iter::IntoIter&lt;T,A&gt; as core::ops::drop::Drop&gt;::drop
0000000000000000 T &lt;alloc::vec::into_iter::IntoIter&lt;T,A&gt; as core::ops::drop::Drop&gt;::drop

lib.rmeta:
</code></p></pre>
<p>LLVM also provides an <code>llvm-nm</code> utility, which works well (although it lists symbols in a
different order, hence the <code>tail</code> =&gt; <code>head</code>):</p>
<pre><p>Shell session</p><p><code>$ llvm-nm --demangle ./target/release/deps/libtree_sitter_highlight-dbbf005203d40df6.rlib | head -8

tree_sitter_highlight-dbbf005203d40df6.tree_sitter_highlight.f125e660-cgu.0.rcgu.o:
0000000000000000 T core::ptr::drop_in_place$LT$core..alloc..layout..LayoutError$GT$::h01bcc4d6d4dc9891 (.llvm.1106350809534913491)
                 U core::panicking::panic::h0ba7146865b2f9d6
                 U alloc::alloc::handle_alloc_error::h6ad4108518320222
0000000000000000 T alloc::raw_vec::finish_grow::hca9a665eb9d6dbd6 (.llvm.1106350809534913491)
                 U alloc::raw_vec::capacity_overflow::h12238855ca9dc4ed
0000000000000000 T alloc::raw_vec::RawVec$LT$T$C$A$GT$::allocate_in::h19c1519794c5cb29
</code></p></pre>
<p>So we&#39;ve got every component of our graph, except it looks more like this:</p>
<p><img src="https://scattered-thoughts.net/content/articles/why-is-my-rust-build-so-slow/assets/rust-build-pipeline.9df86fe8c41f18cc.svg" alt="" loading="lazy"/></p><p>The notable differences here is that rustc is called once per <em>crate</em>. The
object files are not &#34;per source file&#34;, they&#39;re per &#34;rust codegen unit&#34;
(<a href="https://github.com/rust-lang/rust/blob/3d57c61a9e04dcd3df633f41142009d6dcad4399/compiler/rustc_session/src/config.rs#L657">RCGU</a>).</p>
<p>So:</p>
<ul>
<li><code>cargo</code> invokes <code>rustc</code> once per crate</li>
<li><code>rustc</code> decides how many &#34;codegen units&#34; to do in parallel,
writes them as <code>.o</code> files, then archives them in an <code>.rlib</code></li>
<li><code>cargo</code> does one final <code>rustc</code> invocation with all the required <code>.rlib</code>,
which ends up calling the linker to make a binary</li>
</ul>
<div>

<p>There&#39;s a bit of confusion around nomenclature here: something that has a
<code>Cargo.toml</code> is a <strong>package</strong>. Packages are published on a package registry,
like <a href="https://crates.io">https://crates.io</a>, and each package may have multiple crates: a build
script crate, a lib crate, one or more bin crates, etc.</p>
<p>Thanks to <a href="https://twitter.com/SimonSapin">@SimonSapin</a> for clearing that up!</p>
</div>
<p>If we use cargo&#39;s <code>--verbose</code> flag, we can see it making separate rustc
invocations: let&#39;s try it on a smaller crate so the output is a more manageable
size.</p>
<pre><p>Shell session</p><p><code>$ cargo build --verbose
    Blocking waiting for file lock on build directory
       Fresh unicode-xid v0.2.2
       Fresh cc v1.0.72
   Compiling regex-syntax v0.6.25
       Fresh proc-macro2 v1.0.35
       Fresh quote v1.0.10
   Compiling memchr v2.4.1
     Running `rustc --crate-name regex_syntax --edition=2018 /home/amos/.cargo/registry/src/github.com-1ecc6299db9ec823/regex-syntax-0.6.25/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debuginfo=2 --cfg &#39;feature=&#34;default&#34;&#39; --cfg &#39;feature=&#34;unicode&#34;&#39; --cfg &#39;feature=&#34;unicode-age&#34;&#39; --cfg &#39;feature=&#34;unicode-bool&#34;&#39; --cfg &#39;feature=&#34;unicode-case&#34;&#39; --cfg &#39;feature=&#34;unicode-gencat&#34;&#39; --cfg &#39;feature=&#34;unicode-perl&#34;&#39; --cfg &#39;feature=&#34;unicode-script&#34;&#39; --cfg &#39;feature=&#34;unicode-segment&#34;&#39; -C metadata=5f99d85e7aa20c3c -C extra-filename=-5f99d85e7aa20c3c --out-dir /home/amos/bearcove/tree-sitter-collection/target/debug/deps -L dependency=/home/amos/bearcove/tree-sitter-collection/target/debug/deps --cap-lints allow -C link-arg=-fuse-ld=lld`
       Fresh syn v1.0.84
       Fresh thiserror-impl v1.0.30
     Running `rustc --crate-name memchr --edition=2018 /home/amos/.cargo/registry/src/github.com-1ecc6299db9ec823/memchr-2.4.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debuginfo=2 --cfg &#39;feature=&#34;default&#34;&#39; --cfg &#39;feature=&#34;std&#34;&#39; -C metadata=6061dad8797913cc -C extra-filename=-6061dad8797913cc --out-dir /home/amos/bearcove/tree-sitter-collection/target/debug/deps -L dependency=/home/amos/bearcove/tree-sitter-collection/target/debug/deps --cap-lints allow -C link-arg=-fuse-ld=lld --cfg memchr_runtime_simd --cfg memchr_runtime_sse2 --cfg memchr_runtime_sse42 --cfg memchr_runtime_avx`
   Compiling thiserror v1.0.30
     Running `rustc --crate-name thiserror --edition=2018 /home/amos/.cargo/registry/src/github.com-1ecc6299db9ec823/thiserror-1.0.30/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debuginfo=2 -C metadata=e606936c310ae4d3 -C extra-filename=-e606936c310ae4d3 --out-dir /home/amos/bearcove/tree-sitter-collection/target/debug/deps -L dependency=/home/amos/bearcove/tree-sitter-collection/target/debug/deps --extern thiserror_impl=/home/amos/bearcove/tree-sitter-collection/target/debug/deps/libthiserror_impl-b40be9909dd03ab5.so --cap-lints allow -C link-arg=-fuse-ld=lld`
   Compiling aho-corasick v0.7.18
     Running `rustc --crate-name aho_corasick --edition=2018 /home/amos/.cargo/registry/src/github.com-1ecc6299db9ec823/aho-corasick-0.7.18/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debuginfo=2 --cfg &#39;feature=&#34;default&#34;&#39; --cfg &#39;feature=&#34;std&#34;&#39; -C metadata=d54b0d9e8dd84d99 -C extra-filename=-d54b0d9e8dd84d99 --out-dir /home/amos/bearcove/tree-sitter-collection/target/debug/deps -L dependency=/home/amos/bearcove/tree-sitter-collection/target/debug/deps --extern memchr=/home/amos/bearcove/tree-sitter-collection/target/debug/deps/libmemchr-6061dad8797913cc.rmeta --cap-lints allow -C link-arg=-fuse-ld=lld`
   Compiling regex v1.5.4
     Running `rustc --crate-name regex --edition=2018 /home/amos/.cargo/registry/src/github.com-1ecc6299db9ec823/regex-1.5.4/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debuginfo=2 --cfg &#39;feature=&#34;aho-corasick&#34;&#39; --cfg &#39;feature=&#34;default&#34;&#39; --cfg &#39;feature=&#34;memchr&#34;&#39; --cfg &#39;feature=&#34;perf&#34;&#39; --cfg &#39;feature=&#34;perf-cache&#34;&#39; --cfg &#39;feature=&#34;perf-dfa&#34;&#39; --cfg &#39;feature=&#34;perf-inline&#34;&#39; --cfg &#39;feature=&#34;perf-literal&#34;&#39; --cfg &#39;feature=&#34;std&#34;&#39; --cfg &#39;feature=&#34;unicode&#34;&#39; --cfg &#39;feature=&#34;unicode-age&#34;&#39; --cfg &#39;feature=&#34;unicode-bool&#34;&#39; --cfg &#39;feature=&#34;unicode-case&#34;&#39; --cfg &#39;feature=&#34;unicode-gencat&#34;&#39; --cfg &#39;feature=&#34;unicode-perl&#34;&#39; --cfg &#39;feature=&#34;unicode-script&#34;&#39; --cfg &#39;feature=&#34;unicode-segment&#34;&#39; -C metadata=84dc590185c6397b -C extra-filename=-84dc590185c6397b --out-dir /home/amos/bearcove/tree-sitter-collection/target/debug/deps -L dependency=/home/amos/bearcove/tree-sitter-collection/target/debug/deps --extern aho_corasick=/home/amos/bearcove/tree-sitter-collection/target/debug/deps/libaho_corasick-d54b0d9e8dd84d99.rmeta --extern memchr=/home/amos/bearcove/tree-sitter-collection/target/debug/deps/libmemchr-6061dad8797913cc.rmeta --extern regex_syntax=/home/amos/bearcove/tree-sitter-collection/target/debug/deps/libregex_syntax-5f99d85e7aa20c3c.rmeta --cap-lints allow -C link-arg=-fuse-ld=lld`
   Compiling tree-sitter v0.20.1
     Running `rustc --crate-name tree_sitter --edition=2018 /home/amos/.cargo/registry/src/github.com-1ecc6299db9ec823/tree-sitter-0.20.1/binding_rust/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debuginfo=2 -C metadata=434249d5421db9dc -C extra-filename=-434249d5421db9dc --out-dir /home/amos/bearcove/tree-sitter-collection/target/debug/deps -L dependency=/home/amos/bearcove/tree-sitter-collection/target/debug/deps --extern regex=/home/amos/bearcove/tree-sitter-collection/target/debug/deps/libregex-84dc590185c6397b.rmeta --cap-lints allow -C link-arg=-fuse-ld=lld -L native=/home/amos/bearcove/tree-sitter-collection/target/debug/build/tree-sitter-97060a66e399d154/out -l static=tree-sitter`
   Compiling tree-sitter-highlight v0.20.1
     Running `rustc --crate-name tree_sitter_highlight --edition=2018 /home/amos/.cargo/registry/src/github.com-1ecc6299db9ec823/tree-sitter-highlight-0.20.1/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi --crate-type lib --crate-type staticlib --emit=dep-info,link -C embed-bitcode=no -C debuginfo=2 -C metadata=f889da5f4ac6bce2 -C extra-filename=-f889da5f4ac6bce2 --out-dir /home/amos/bearcove/tree-sitter-collection/target/debug/deps -L dependency=/home/amos/bearcove/tree-sitter-collection/target/debug/deps --extern regex=/home/amos/bearcove/tree-sitter-collection/target/debug/deps/libregex-84dc590185c6397b.rlib --extern thiserror=/home/amos/bearcove/tree-sitter-collection/target/debug/deps/libthiserror-e606936c310ae4d3.rlib --extern tree_sitter=/home/amos/bearcove/tree-sitter-collection/target/debug/deps/libtree_sitter-434249d5421db9dc.rlib --cap-lints allow -C link-arg=-fuse-ld=lld -L native=/home/amos/bearcove/tree-sitter-collection/target/debug/build/tree-sitter-97060a66e399d154/out`
   Compiling tree-sitter-collection v0.26.0 (/home/amos/bearcove/tree-sitter-collection)
     Running `rustc --crate-name tree_sitter_collection --edition=2018 src/lib.rs --error-format=json --json=diagnostic-rendered-ansi --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debuginfo=2 -C metadata=a567e6662873a172 -C extra-filename=-a567e6662873a172 --out-dir /home/amos/bearcove/tree-sitter-collection/target/debug/deps -C incremental=/home/amos/bearcove/tree-sitter-collection/target/debug/incremental -L dependency=/home/amos/bearcove/tree-sitter-collection/target/debug/deps --extern tree_sitter=/home/amos/bearcove/tree-sitter-collection/target/debug/deps/libtree_sitter-434249d5421db9dc.rmeta --extern tree_sitter_highlight=/home/amos/bearcove/tree-sitter-collection/target/debug/deps/libtree_sitter_highlight-f889da5f4ac6bce2.rlib -C link-arg=-fuse-ld=lld -L native=/home/amos/bearcove/tree-sitter-collection/target/debug/build/tree-sitter-collection-c4ebc5be2f6a2943/out -L native=/home/amos/bearcove/tree-sitter-collection/target/debug/build/tree-sitter-collection-c4ebc5be2f6a2943/out -L native=/home/amos/bearcove/tree-sitter-collection/target/debug/build/tree-sitter-collection-c4ebc5be2f6a2943/out -L native=/home/amos/bearcove/tree-sitter-collection/target/debug/build/tree-sitter-collection-c4ebc5be2f6a2943/out -L native=/home/amos/bearcove/tree-sitter-collection/target/debug/build/tree-sitter-collection-c4ebc5be2f6a2943/out -L native=/home/amos/bearcove/tree-sitter-collection/target/debug/build/tree-sitter-collection-c4ebc5be2f6a2943/out -L native=/home/amos/bearcove/tree-sitter-collection/target/debug/build/tree-sitter-collection-c4ebc5be2f6a2943/out -L native=/home/amos/bearcove/tree-sitter-collection/target/debug/build/tree-sitter-collection-c4ebc5be2f6a2943/out -L native=/home/amos/bearcove/tree-sitter-collection/target/debug/build/tree-sitter-collection-c4ebc5be2f6a2943/out -L native=/home/amos/bearcove/tree-sitter-collection/target/debug/build/tree-sitter-collection-c4ebc5be2f6a2943/out -L native=/home/amos/bearcove/tree-sitter-collection/target/debug/build/tree-sitter-collection-c4ebc5be2f6a2943/out -L native=/home/amos/bearcove/tree-sitter-collection/target/debug/build/tree-sitter-collection-c4ebc5be2f6a2943/out -L native=/home/amos/bearcove/tree-sitter-collection/target/debug/build/tree-sitter-collection-c4ebc5be2f6a2943/out -L native=/home/amos/bearcove/tree-sitter-collection/target/debug/build/tree-sitter-collection-c4ebc5be2f6a2943/out -L native=/home/amos/bearcove/tree-sitter-collection/target/debug/build/tree-sitter-collection-c4ebc5be2f6a2943/out -L native=/home/amos/bearcove/tree-sitter-collection/target/debug/build/tree-sitter-collection-c4ebc5be2f6a2943/out -L native=/home/amos/bearcove/tree-sitter-collection/target/debug/build/tree-sitter-collection-c4ebc5be2f6a2943/out -L native=/home/amos/bearcove/tree-sitter-collection/target/debug/build/tree-sitter-collection-c4ebc5be2f6a2943/out -L native=/home/amos/bearcove/tree-sitter-collection/target/debug/build/tree-sitter-collection-c4ebc5be2f6a2943/out -l static=tree-sitter-go -l static=tree-sitter-c -l static=tree-sitter-rust -l static=tree-sitter-javascript -l static=tree-sitter-java -l static=tree-sitter-typescript -l static=tree-sitter-tsx -l static=tree-sitter-toml -l static=tree-sitter-bash-parser -l static=tree-sitter-bash-scanner -l stdc++ -l static=tree-sitter-html-parser -l static=tree-sitter-html-scanner -l stdc++ -l static=tree-sitter-python-parser -l static=tree-sitter-python-scanner -l stdc++ -l static=tree-sitter-ini-parser -l static=tree-sitter-meson-parser -l static=tree-sitter-yaml-parser -l static=tree-sitter-yaml-scanner -l stdc++ -l static=tree-sitter-dockerfile-parser -L native=/home/amos/bearcove/tree-sitter-collection/target/debug/build/tree-sitter-97060a66e399d154/out`
    Finished dev [unoptimized + debuginfo] target(s) in 9.95s
</code></p></pre>
<p>Yay!</p>
<p>And if we don&#39;t trust <code>cargo</code>, instead of asking nicely, we can also just
straight up spy on it, with <code>strace</code>.</p>
<p>Let&#39;s try it on an even smaller crate, because that one&#39;s pretty noisy:</p>
<div>

<p>In the invocation below, we trace system calls (<code>strace</code>), including children
processes (following forks, <code>-f</code>), for the execution of <code>cargo build --quiet</code>.
We then redirect standard error (<code>stderr</code>, file descriptor 2) to standard output
(<code>stdout</code>, file descriptor 1), and pipe into
<a href="https://en.wikipedia.org/wiki/Grep">grep</a> (from <code>g/re/p</code>: Globally search for a
Regular Expression and Print matching lines), using &#34;extended&#34; regular
expression syntax (<code>-E</code>), and we look for something that starts with <code>execve(</code>
and ends with <code>= 0</code> (which indicates success).</p>
</div>
<pre><p>Shell session</p><p><code>$ cargo clean &amp;&amp; strace -f -e execve -- cargo build --quiet 2&gt;&amp;1 | grep -E &#39;execve\(.*= 0&#39;
execve(&#34;/home/amos/.cargo/bin/cargo&#34;, [&#34;cargo&#34;, &#34;build&#34;, &#34;--quiet&#34;], 0x7fff74a9bec0 /* 51 vars */) = 0
execve(&#34;/home/amos/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/cargo&#34;, [&#34;/home/amos/.rustup/toolchains/st&#34;..., &#34;build&#34;, &#34;--quiet&#34;], 0x5628508c5b60 /* 56 vars */) = 0
[pid 702423] execve(&#34;/home/amos/.cargo/bin/rustc&#34;, [&#34;rustc&#34;, &#34;-vV&#34;], 0x5604183fdd60 /* 58 vars */) = 0
[pid 702423] execve(&#34;/home/amos/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc&#34;, [&#34;/home/amos/.rustup/toolchains/st&#34;..., &#34;-vV&#34;], 0x55d9605a1250 /* 58 vars */) = 0
[pid 702424] execve(&#34;/home/amos/.cargo/bin/rustc&#34;, [&#34;rustc&#34;, &#34;-&#34;, &#34;--crate-name&#34;, &#34;___&#34;, &#34;--print=file-names&#34;, &#34;--crate-type&#34;, &#34;bin&#34;, &#34;--crate-type&#34;, &#34;rlib&#34;, &#34;--crate-type&#34;, &#34;dylib&#34;, &#34;--crate-type&#34;, &#34;cdylib&#34;, &#34;--crate-type&#34;, &#34;staticlib&#34;, &#34;--crate-type&#34;, &#34;proc-macro&#34;, &#34;-Csplit-debuginfo=packed&#34;], 0x5604184cac20 /* 58 vars */) = 0
[pid 702424] execve(&#34;/home/amos/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc&#34;, [&#34;/home/amos/.rustup/toolchains/st&#34;..., &#34;-&#34;, &#34;--crate-name&#34;, &#34;___&#34;, &#34;--print=file-names&#34;, &#34;--crate-type&#34;, &#34;bin&#34;, &#34;--crate-type&#34;, &#34;rlib&#34;, &#34;--crate-type&#34;, &#34;dylib&#34;, &#34;--crate-type&#34;, &#34;cdylib&#34;, &#34;--crate-type&#34;, &#34;staticlib&#34;, &#34;--crate-type&#34;, &#34;proc-macro&#34;, &#34;-Csplit-debuginfo=packed&#34;], 0x55eaa32ffb50 /* 58 vars */) = 0
[pid 702425] execve(&#34;/home/amos/.cargo/bin/rustc&#34;, [&#34;rustc&#34;, &#34;-&#34;, &#34;--crate-name&#34;, &#34;___&#34;, &#34;--print=file-names&#34;, &#34;--crate-type&#34;, &#34;bin&#34;, &#34;--crate-type&#34;, &#34;rlib&#34;, &#34;--crate-type&#34;, &#34;dylib&#34;, &#34;--crate-type&#34;, &#34;cdylib&#34;, &#34;--crate-type&#34;, &#34;staticlib&#34;, &#34;--crate-type&#34;, &#34;proc-macro&#34;, &#34;--force-warn=rust-2021-compatibi&#34;...], 0x56041841ba80 /* 58 vars */) = 0
[pid 702425] execve(&#34;/home/amos/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc&#34;, [&#34;/home/amos/.rustup/toolchains/st&#34;..., &#34;-&#34;, &#34;--crate-name&#34;, &#34;___&#34;, &#34;--print=file-names&#34;, &#34;--crate-type&#34;, &#34;bin&#34;, &#34;--crate-type&#34;, &#34;rlib&#34;, &#34;--crate-type&#34;, &#34;dylib&#34;, &#34;--crate-type&#34;, &#34;cdylib&#34;, &#34;--crate-type&#34;, &#34;staticlib&#34;, &#34;--crate-type&#34;, &#34;proc-macro&#34;, &#34;--force-warn=rust-2021-compatibi&#34;...], 0x559d2d9dc7b0 /* 58 vars */) = 0
[pid 702427] execve(&#34;/home/amos/.cargo/bin/rustc&#34;, [&#34;rustc&#34;, &#34;-&#34;, &#34;--crate-name&#34;, &#34;___&#34;, &#34;--print=file-names&#34;, &#34;--crate-type&#34;, &#34;bin&#34;, &#34;--crate-type&#34;, &#34;rlib&#34;, &#34;--crate-type&#34;, &#34;dylib&#34;, &#34;--crate-type&#34;, &#34;cdylib&#34;, &#34;--crate-type&#34;, &#34;staticlib&#34;, &#34;--crate-type&#34;, &#34;proc-macro&#34;, &#34;--print=sysroot&#34;, &#34;--print=cfg&#34;], 0x5604184cac20 /* 58 vars */) = 0
[pid 702427] execve(&#34;/home/amos/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc&#34;, [&#34;/home/amos/.rustup/toolchains/st&#34;..., &#34;-&#34;, &#34;--crate-name&#34;, &#34;___&#34;, &#34;--print=file-names&#34;, &#34;--crate-type&#34;, &#34;bin&#34;, &#34;--crate-type&#34;, &#34;rlib&#34;, &#34;--crate-type&#34;, &#34;dylib&#34;, &#34;--crate-type&#34;, &#34;cdylib&#34;, &#34;--crate-type&#34;, &#34;staticlib&#34;, &#34;--crate-type&#34;, &#34;proc-macro&#34;, &#34;--print=sysroot&#34;, &#34;--print=cfg&#34;], 0x55e0804f1d00 /* 58 vars */) = 0
[pid 702429] execve(&#34;/home/amos/.cargo/bin/rustc&#34;, [&#34;rustc&#34;, &#34;-vV&#34;], 0x5604183fdd60 /* 58 vars */) = 0
[pid 702429] execve(&#34;/home/amos/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc&#34;, [&#34;/home/amos/.rustup/toolchains/st&#34;..., &#34;-vV&#34;], 0x55ffc26bb690 /* 58 vars */) = 0
[pid 702432] execve(&#34;/home/amos/.cargo/bin/rustc&#34;, [&#34;rustc&#34;, &#34;--crate-name&#34;, &#34;hello_world&#34;, &#34;--edition=2021&#34;, &#34;src/main.rs&#34;, &#34;--error-format=json&#34;, &#34;--json=diagnostic-rendered-ansi&#34;, &#34;--crate-type&#34;, &#34;bin&#34;, &#34;--emit=dep-info,link&#34;, &#34;-C&#34;, &#34;embed-bitcode=no&#34;, &#34;-C&#34;, &#34;debuginfo=2&#34;, &#34;-C&#34;, &#34;metadata=edf9f7e82579517e&#34;, &#34;-C&#34;, &#34;extra-filename=-edf9f7e82579517e&#34;, &#34;--out-dir&#34;, &#34;/home/amos/bearcove/hello-world/&#34;..., &#34;-C&#34;, &#34;incremental=/home/amos/bearcove/&#34;..., &#34;-L&#34;, &#34;dependency=/home/amos/bearcove/h&#34;...], 0x7f39d8004c30 /* 76 vars */) = 0
[pid 702432] execve(&#34;/home/amos/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc&#34;, [&#34;/home/amos/.rustup/toolchains/st&#34;..., &#34;--crate-name&#34;, &#34;hello_world&#34;, &#34;--edition=2021&#34;, &#34;src/main.rs&#34;, &#34;--error-format=json&#34;, &#34;--json=diagnostic-rendered-ansi&#34;, &#34;--crate-type&#34;, &#34;bin&#34;, &#34;--emit=dep-info,link&#34;, &#34;-C&#34;, &#34;embed-bitcode=no&#34;, &#34;-C&#34;, &#34;debuginfo=2&#34;, &#34;-C&#34;, &#34;metadata=edf9f7e82579517e&#34;, &#34;-C&#34;, &#34;extra-filename=-edf9f7e82579517e&#34;, &#34;--out-dir&#34;, &#34;/home/amos/bearcove/hello-world/&#34;..., &#34;-C&#34;, &#34;incremental=/home/amos/bearcove/&#34;..., &#34;-L&#34;, &#34;dependency=/home/amos/bearcove/h&#34;...], 0x5578142c7ba0 /* 76 vars */) = 0
[pid 702446] execve(&#34;/usr/bin/cc&#34;, [&#34;cc&#34;, &#34;-m64&#34;, &#34;/home/amos/bearcove/hello-world/&#34;..., &#34;/home/amos/bearcove/hello-world/&#34;..., &#34;/home/amos/bearcove/hello-world/&#34;..., &#34;/home/amos/bearcove/hello-world/&#34;..., &#34;/home/amos/bearcove/hello-world/&#34;..., &#34;/home/amos/bearcove/hello-world/&#34;..., &#34;/home/amos/bearcove/hello-world/&#34;..., &#34;/home/amos/bearcove/hello-world/&#34;..., &#34;/home/amos/bearcove/hello-world/&#34;..., &#34;-Wl,--as-needed&#34;, &#34;-L&#34;, &#34;/home/amos/bearcove/hello-world/&#34;..., &#34;-L&#34;, &#34;/home/amos/.rustup/toolchains/st&#34;..., &#34;-Wl,--start-group&#34;, &#34;-Wl,-Bstatic&#34;, &#34;/home/amos/.rustup/toolchains/st&#34;..., &#34;/home/amos/.rustup/toolchains/st&#34;..., &#34;/home/amos/.rustup/toolchains/st&#34;..., &#34;/home/amos/.rustup/toolchains/st&#34;..., &#34;/home/amos/.rustup/toolchains/st&#34;..., &#34;/home/amos/.rustup/toolchains/st&#34;..., &#34;/home/amos/.rustup/toolchains/st&#34;..., &#34;/home/amos/.rustup/toolchains/st&#34;..., &#34;/home/amos/.rustup/toolchains/st&#34;..., &#34;/home/amos/.rustup/toolchains/st&#34;..., &#34;/home/amos/.rustup/toolchains/st&#34;..., &#34;/home/amos/.rustup/toolchains/st&#34;..., &#34;/home/amos/.rustup/toolchains/st&#34;..., &#34;/home/amos/.rustup/toolchains/st&#34;..., ...], 0x7f712c3bcd00 /* 78 vars */) = 0
[pid 702447] execve(&#34;/usr/libexec/gcc/x86_64-redhat-linux/11/collect2&#34;, [&#34;/usr/libexec/gcc/x86_64-redhat-l&#34;..., &#34;-plugin&#34;, &#34;/usr/libexec/gcc/x86_64-redhat-l&#34;..., &#34;-plugin-opt=/usr/libexec/gcc/x86&#34;..., &#34;-plugin-opt=-fresolution=/tmp/cc&#34;..., &#34;--build-id&#34;, &#34;--no-add-needed&#34;, &#34;--eh-frame-hdr&#34;, &#34;--hash-style=gnu&#34;, &#34;-m&#34;, &#34;elf_x86_64&#34;, &#34;-dynamic-linker&#34;, &#34;/lib64/ld-linux-x86-64.so.2&#34;, &#34;-pie&#34;, &#34;-o&#34;, &#34;/home/amos/bearcove/hello-world/&#34;..., &#34;/usr/lib/gcc/x86_64-redhat-linux&#34;..., &#34;/usr/lib/gcc/x86_64-redhat-linux&#34;..., &#34;/usr/lib/gcc/x86_64-redhat-linux&#34;..., &#34;-L/home/amos/bearcove/hello-worl&#34;..., &#34;-L/home/amos/.rustup/toolchains/&#34;..., &#34;-L/home/amos/.rustup/toolchains/&#34;..., &#34;-L/usr/lib/gcc/x86_64-redhat-lin&#34;..., &#34;-L/usr/lib/gcc/x86_64-redhat-lin&#34;..., &#34;-L/lib/../lib64&#34;, &#34;-L/usr/lib/../lib64&#34;, &#34;-L/usr/lib/gcc/x86_64-redhat-lin&#34;..., &#34;/home/amos/bearcove/hello-world/&#34;..., &#34;/home/amos/bearcove/hello-world/&#34;..., &#34;/home/amos/bearcove/hello-world/&#34;..., &#34;/home/amos/bearcove/hello-world/&#34;..., &#34;/home/amos/bearcove/hello-world/&#34;..., ...], 0x1ece9c0 /* 85 vars */) = 0
[pid 702448] execve(&#34;/usr/bin/ld&#34;, [&#34;/usr/bin/ld&#34;, &#34;-plugin&#34;, &#34;/usr/libexec/gcc/x86_64-redhat-l&#34;..., &#34;-plugin-opt=/usr/libexec/gcc/x86&#34;..., &#34;-plugin-opt=-fresolution=/tmp/cc&#34;..., &#34;--build-id&#34;, &#34;--no-add-needed&#34;, &#34;--eh-frame-hdr&#34;, &#34;--hash-style=gnu&#34;, &#34;-m&#34;, &#34;elf_x86_64&#34;, &#34;-dynamic-linker&#34;, &#34;/lib64/ld-linux-x86-64.so.2&#34;, &#34;-pie&#34;, &#34;-o&#34;, &#34;/home/amos/bearcove/hello-world/&#34;..., &#34;/usr/lib/gcc/x86_64-redhat-linux&#34;..., &#34;/usr/lib/gcc/x86_64-redhat-linux&#34;..., &#34;/usr/lib/gcc/x86_64-redhat-linux&#34;..., &#34;-L/home/amos/bearcove/hello-worl&#34;..., &#34;-L/home/amos/.rustup/toolchains/&#34;..., &#34;-L/home/amos/.rustup/toolchains/&#34;..., &#34;-L/usr/lib/gcc/x86_64-redhat-lin&#34;..., &#34;-L/usr/lib/gcc/x86_64-redhat-lin&#34;..., &#34;-L/lib/../lib64&#34;, &#34;-L/usr/lib/../lib64&#34;, &#34;-L/usr/lib/gcc/x86_64-redhat-lin&#34;..., &#34;/home/amos/bearcove/hello-world/&#34;..., &#34;/home/amos/bearcove/hello-world/&#34;..., &#34;/home/amos/bearcove/hello-world/&#34;..., &#34;/home/amos/bearcove/hello-world/&#34;..., &#34;/home/amos/bearcove/hello-world/&#34;..., ...], 0x7ffc58148430 /* 85 vars */) = 0
</code></p></pre>
<p>Yay! We see <em>everything</em>. It does indeed calls <code>rustc</code> a bunch of times, and the
final invocation calls <code>cc</code>, which calls
<a href="https://gcc.gnu.org/onlinedocs/gccint/Collect2.html"><code>collect2</code></a> and eventually
<code>ld</code>.</p>
<p>And if we ask it to use <code>lld</code>, LLVM&#39;s linker, instead, it does that!</p>
<pre><p>Shell session</p><p><code>$ cargo clean &amp;&amp; RUSTFLAGS=&#34;-C link-args=-fuse-ld=lld&#34; strace -f -e execve -- cargo build --quiet 2&gt;&amp;1 | grep -E &#39;execve\(.*= 0&#39;
(cut)
[pid 705269] execve(&#34;/usr/libexec/gcc/x86_64-redhat-linux/11/collect2&#34;, [&#34;/usr/libexec/gcc/x86_64-redhat-l&#34;..., &#34;-plugin&#34;, &#34;/usr/libexec/gcc/x86_64-redhat-l&#34;..., &#34;-plugin-opt=/usr/libexec/gcc/x86&#34;..., &#34;-plugin-opt=-fresolution=/tmp/cc&#34;..., &#34;--build-id&#34;, &#34;--no-add-needed&#34;, &#34;--eh-frame-hdr&#34;, &#34;--hash-style=gnu&#34;, &#34;-m&#34;, &#34;elf_x86_64&#34;, &#34;-dynamic-linker&#34;, &#34;/lib64/ld-linux-x86-64.so.2&#34;, &#34;-pie&#34;, &#34;-fuse-ld=lld&#34;, &#34;-o&#34;, &#34;/home/amos/bearcove/hello-world/&#34;..., &#34;/usr/lib/gcc/x86_64-redhat-linux&#34;..., &#34;/usr/lib/gcc/x86_64-redhat-linux&#34;..., &#34;/usr/lib/gcc/x86_64-redhat-linux&#34;..., &#34;-L/home/amos/bearcove/hello-worl&#34;..., &#34;-L/home/amos/.rustup/toolchains/&#34;..., &#34;-L/home/amos/.rustup/toolchains/&#34;..., &#34;-L/usr/lib/gcc/x86_64-redhat-lin&#34;..., &#34;-L/usr/lib/gcc/x86_64-redhat-lin&#34;..., &#34;-L/lib/../lib64&#34;, &#34;-L/usr/lib/../lib64&#34;, &#34;-L/usr/lib/gcc/x86_64-redhat-lin&#34;..., &#34;/home/amos/bearcove/hello-world/&#34;..., &#34;/home/amos/bearcove/hello-world/&#34;..., &#34;/home/amos/bearcove/hello-world/&#34;..., &#34;/home/amos/bearcove/hello-world/&#34;..., ...], 0x6e2970 /* 86 vars */) = 0
                                👇
[pid 705270] execve(&#34;/usr/bin/ld.lld&#34;, [&#34;/usr/bin/ld.lld&#34;, &#34;-plugin&#34;, &#34;/usr/libexec/gcc/x86_64-redhat-l&#34;..., &#34;-plugin-opt=/usr/libexec/gcc/x86&#34;..., &#34;-plugin-opt=-fresolution=/tmp/cc&#34;..., &#34;--build-id&#34;, &#34;--no-add-needed&#34;, &#34;--eh-frame-hdr&#34;, &#34;--hash-style=gnu&#34;, &#34;-m&#34;, &#34;elf_x86_64&#34;, &#34;-dynamic-linker&#34;, &#34;/lib64/ld-linux-x86-64.so.2&#34;, &#34;-pie&#34;, &#34;-o&#34;, &#34;/home/amos/bearcove/hello-world/&#34;..., &#34;/usr/lib/gcc/x86_64-redhat-linux&#34;..., &#34;/usr/lib/gcc/x86_64-redhat-linux&#34;..., &#34;/usr/lib/gcc/x86_64-redhat-linux&#34;..., &#34;-L/home/amos/bearcove/hello-worl&#34;..., &#34;-L/home/amos/.rustup/toolchains/&#34;..., &#34;-L/home/amos/.rustup/toolchains/&#34;..., &#34;-L/usr/lib/gcc/x86_64-redhat-lin&#34;..., &#34;-L/usr/lib/gcc/x86_64-redhat-lin&#34;..., &#34;-L/lib/../lib64&#34;, &#34;-L/usr/lib/../lib64&#34;, &#34;-L/usr/lib/gcc/x86_64-redhat-lin&#34;..., &#34;/home/amos/bearcove/hello-world/&#34;..., &#34;/home/amos/bearcove/hello-world/&#34;..., &#34;/home/amos/bearcove/hello-world/&#34;..., &#34;/home/amos/bearcove/hello-world/&#34;..., &#34;/home/amos/bearcove/hello-world/&#34;..., ...], 0x7ffd9119d598 /* 86 vars */) = 0
</code></p></pre>
<h2>How much time are we spending on these steps?</h2>
<p>That&#39;s all really nice, but... it doesn&#39;t really explain why our build was slow.</p>
<p>For starters, unless we run the build with <code>--verbose</code> and watch the terminal
to monitor how long different parts are taking, we don&#39;t really know anything
about timings.</p>
<p>And that&#39;s why cargo has a <code>-Z timings</code> option!</p>
<p>It&#39;s nightly-only, so you really should <em>not</em> use the trick I&#39;m about to use and
just use nightly instead, but since I really want to use it in stable instead,
I&#39;m going to export <code>RUSTC_BOOTSTRAP=1</code> and have stable pretend it&#39;s a nightly
build.</p>
<div>

<p>This works because stable builds also have all the nightly code compiled in:
it&#39;s just feature-gated. No, not like <a href="https://www.youtube.com/watch?v=-4w52waLTx4">LaunchDarkly feature
flags</a>, just, it&#39;ll detect you&#39;re
trying to use a feature, parse it correctly and everything, and gently let you
know that feature isn&#39;t stable yet.</p>
<p>But rustc uses unstable features internally, so when bootstrapping, it needs to
be able to compile itself, unstable features and all. That&#39;s why the
<code>RUSTC_BOOTSTRAP</code> environment variable exists.</p>
<p>Of course here we&#39;re horribly misusing it, and it&#39;s going to make a bunch of
people sad, but I hope with time they can forgive us.</p>
</div>
<pre><p>Shell session</p><p><code>$ cargo clean &amp;&amp; RUSTC_BOOTSTRAP=1 cargo build --release --quiet -Z timings
</code></p></pre><div>

<p>Whoa, <code>--quiet</code> is really quiet.</p>
</div>

<p>That took forever, but now we have... a <code>cargo-timing.html</code> file!</p>
<p>It&#39;s interactive and stuff, so I can&#39;t really do it justice, but I still want to
show you what it looks like, so here goes, non-dark-mode and non-hidpi-friendly
screenshots and all.</p>
<p>First we have a nice summary:</p>

            <picture>
                <source type="image/avif" srcset="/content/articles/why-is-my-rust-build-so-slow/assets/cargo-timings-1.eeea748c9fe511f2.avif"/>
                <source type="image/webp" srcset="/content/articles/why-is-my-rust-build-so-slow/assets/cargo-timings-1.0d7e36633a106c0d.webp"/>
                <img loading="lazy" src="https://scattered-thoughts.net/content/articles/why-is-my-rust-build-so-slow/assets/cargo-timings-1.951af6955d6e2348.jpg"/>
            </picture>
            
<p>&#34;Fresh&#34; units would be those that we don&#39;t need to recompile, but this is a
&#34;cold&#34; build, since we ran <code>cargo clean</code> beforehand.</p>
<p>Then we have a timeline! That shows aaaaaall 420 compilation units:</p>

            <picture>
                <source type="image/avif" srcset="/content/articles/why-is-my-rust-build-so-slow/assets/cargo-timings-2.c1138d0cef24264c.avif"/>
                <source type="image/webp" srcset="/content/articles/why-is-my-rust-build-so-slow/assets/cargo-timings-2.db435d88d4536c09.webp"/>
                <img loading="lazy" src="https://scattered-thoughts.net/content/articles/why-is-my-rust-build-so-slow/assets/cargo-timings-2.0b47f061e70e5579.jpg"/>
            </picture>
            <div>

<p>Okay be real with me: did you add unnecessary dependencies just so the
total would be 420?</p>
</div>


<p>420 rows don&#39;t really fit on my screen, and if they did, they&#39;d be too small to
be readable, but luckily, we can crank up that &#34;Min unit time&#34; slider to hide the
really quick ones:</p>

            <picture>
                <source type="image/avif" srcset="/content/articles/why-is-my-rust-build-so-slow/assets/cargo-timings-3.1bde0f8a9e35be9d.avif"/>
                <source type="image/webp" srcset="/content/articles/why-is-my-rust-build-so-slow/assets/cargo-timings-3.11ffae48ef19b8c2.webp"/>
                <img loading="lazy" src="https://scattered-thoughts.net/content/articles/why-is-my-rust-build-so-slow/assets/cargo-timings-3.62ac3c9445ac249e.jpg"/>
            </picture>
            <div>

<p>What do the colors mean? I&#39;m so glad you asked!</p>
<p><strong>Orange</strong> means we&#39;re running a build script. Everything else has to deal with
pipelining: cargo always tries to build as many crates as possible in parallel,
but it can only start the &#34;next&#34; crate if there&#39;s enough metadata available
about all its dependencies.</p>
<p>So, the <strong>light blue</strong> parts are where we&#39;re still busy generating metadata, and
any dependents (crates that depend on us) are blocked. When transitioning to
<strong>lavender</strong>, dependents are unblocked and can start building immediately.</p>
<p>You can see this happening here: <code>regex-syntax</code> transitions from light blue to
lavender and <code>regex</code> (line 16) immediately starts building: the dotted line
shows the dependency:</p>

            <picture>
                <source type="image/avif" srcset="/content/articles/why-is-my-rust-build-so-slow/assets/pipelining.04038a30d3ed590a.avif"/>
                <source type="image/webp" srcset="/content/articles/why-is-my-rust-build-so-slow/assets/pipelining.99f3ff94b9b6e585.webp"/>
                <img loading="lazy" src="https://scattered-thoughts.net/content/articles/why-is-my-rust-build-so-slow/assets/pipelining.66e1f7444e54e069.jpg"/>
            </picture>
            
<p>You can read <a href="https://github.com/rust-lang/compiler-team/blob/master/content/working-groups/pipelining/NOTES.md">more about
pipelining</a>
on the Rust compiler team&#39;s repository.</p>
</div>
<p>And here we can see, at a glance, the most expensive crates:
<code>tree-sitter-collection</code>, one of my own crates, which compiles, like, 12
different tree-sitter parsers (as C code, with gcc), <code>libsqlite3-sys</code>, which
builds all of sqlite3 (so I don&#39;t have to have it installed on whichever
system I run this binary), <code>libquickjs-sys</code>, which is a whole-ass JavaScript
engine (which I use for <a href="https://en.wikipedia.org/wiki/KaTeX">KaTeX</a>).</p>
<p>And then the last hugeeeeeee light blue bar, that&#39;s just the binary crate we&#39;re
compiling. (And that is the crux of my issue).</p>
<p>For completeness, here&#39;s what else it shows us: a CPU usage and concurrency
graph:</p>

            <picture>
                <source type="image/avif" srcset="/content/articles/why-is-my-rust-build-so-slow/assets/cargo-timings-4.afde8ead505fcc4f.avif"/>
                <source type="image/webp" srcset="/content/articles/why-is-my-rust-build-so-slow/assets/cargo-timings-4.aeb4a710c6b0a0be.webp"/>
                <img loading="lazy" src="https://scattered-thoughts.net/content/articles/why-is-my-rust-build-so-slow/assets/cargo-timings-4.aca7759092c7d3a2.jpg"/>
            </picture>
            
<p>You can see that CPU usage is really high for the first third of the
compilation, and it spikes again at the end, but there&#39;s a big valley in
between, where it appeares to be doing very little.</p>
<p>&#34;Very little&#34; is misleading, of course, since there&#39;s 32 logical cores, we&#39;re
actually looking at one core being at full utilization. Still, the system as a
whole is &#34;mostly idle&#34;.</p>
<p>Finally, it gives us a table, sort of a hall of fame of slow-to-build crates:</p>

            <picture>
                <source type="image/avif" srcset="/content/articles/why-is-my-rust-build-so-slow/assets/cargo-timings-5.e6e963a1cd49bb80.avif"/>
                <source type="image/webp" srcset="/content/articles/why-is-my-rust-build-so-slow/assets/cargo-timings-5.52fe62d6f8c4c58d.webp"/>
                <img loading="lazy" src="https://scattered-thoughts.net/content/articles/why-is-my-rust-build-so-slow/assets/cargo-timings-5.317e241256bcc48e.jpg"/>
            </picture>
            
<p>Now for a hot build! If we change a single line in <code>main.rs</code> and rebuild,
we get:</p>

            <picture>
                <source type="image/avif" srcset="/content/articles/why-is-my-rust-build-so-slow/assets/cargo-timing-hot-build.19da9c8f9aa7b6aa.avif"/>
                <source type="image/webp" srcset="/content/articles/why-is-my-rust-build-so-slow/assets/cargo-timing-hot-build.48c717bf10c15a4d.webp"/>
                <img loading="lazy" src="https://scattered-thoughts.net/content/articles/why-is-my-rust-build-so-slow/assets/cargo-timing-hot-build.1f8d1b8dfcd56473.jpg"/>
            </picture>
            
<p>Which is almost completely devoid of insight.</p>
<p>Because it&#39;s a bin crate, <code>cargo -Z timings</code> doesn&#39;t report codegen time, and
(at least up until the time of this writing), it doesn&#39;t report link time
either, so... we have a big opaque block of 72 seconds, doing... <em>something</em>.</p>
<div>

<p>If you want to visualize &#34;how parallel&#34; your build is, or &#34;where cargo is
spending time&#34;, you can use <code>-Z timings</code>. It&#39;s a nightly-only option, but if
you&#39;re not afraid of code crime jail, you can (ab)use <code>RUSTC_BOOTSTRAP</code> to use
it on stable instead.</p>
<p>DO NOT USE RUSTC_BOOTSTRAP TO MAKE PRODUCTION BUILDS. Consider the output of any
<code>RUSTC_BOOTSTRAP=1</code> build radioactive. It&#39;s only really forgivable if 1) you&#39;re
bootstrapping the Rust compiler, or 2) you&#39;re just measuring something, like cargo
timings, or unused dependencies with <a href="https://lib.rs/crates/cargo-udeps">cargo-udeps</a>.</p>
</div>
<h2>Linker, is it you?</h2>
<p>For very large Rust projects, and for <em>hot builds</em>, it&#39;s not uncommon for
linking to make up <em>most</em> of the &#34;build time&#34;. And that&#39;s why people tend to
reach for <code>lld</code> (LLVM&#39;s linker), for example.</p>
<p>Thing is... we&#39;re already using <code>lld</code>.</p>
<p>Here&#39;s the graph with GNU ld instead (the default for this system):</p>

            <picture>
                <source type="image/avif" srcset="/content/articles/why-is-my-rust-build-so-slow/assets/cargo-timing-gnu-ld.1c4da6cb487f9acc.avif"/>
                <source type="image/webp" srcset="/content/articles/why-is-my-rust-build-so-slow/assets/cargo-timing-gnu-ld.99daa1f67d7ddeaf.webp"/>
                <img loading="lazy" src="https://scattered-thoughts.net/content/articles/why-is-my-rust-build-so-slow/assets/cargo-timing-gnu-ld.061cd08fc9788d2c.jpg"/>
            </picture>
            
<p><em>That</em> is the difference <code>lld</code> makes: it&#39;s nine seconds faster than GNU ld for
this build (out of some unknown duration — we could measure it, but I can&#39;t
be bothered right now).</p>
<blockquote>
<p>Note from the editor: It would appear the lld graph and the GNU ld graph don&#39;t
actually show a nine second difference. I swear the difference was there, and I
probably mixed up the graphs. I&#39;ll redo them when it&#39;s not past midnight.</p>
</blockquote>
<p>Using <code>mold</code> instead, we have this:</p>

            <picture>
                <source type="image/avif" srcset="/content/articles/why-is-my-rust-build-so-slow/assets/cargo-timing-mold.b1364aa2ea22896b.avif"/>
                <source type="image/webp" srcset="/content/articles/why-is-my-rust-build-so-slow/assets/cargo-timing-mold.a4eb657fdbba5d0f.webp"/>
                <img loading="lazy" src="https://scattered-thoughts.net/content/articles/why-is-my-rust-build-so-slow/assets/cargo-timing-mold.148372e50004775d.jpg"/>
            </picture>
            
<p>Barely faster than <code>lld</code>. So linking is not the bottleneck here.</p>
<div>

<p>When building larger applications, linking can become the slowest / most
expensive part of a rebuild. GNU ld hasn&#39;t been the best option for a while now.</p>
<p>Rui Ueyama changed the game, <em>twice</em>, by working on <code>lld</code>, LLVM&#39;s linker, and
then on <code>mold</code>, which will be <a href="https://twitter.com/rui314/status/1476168056766623745">recognized officially by
GCC</a> soon!</p>
</div>
<h2>Debug symbols, perhaps?</h2>
<p>By default, no debug symbols are included in &#34;release&#34; cargo builds.</p>
<p>Debug symbols allow mapping memory addresses to &#34;source locations&#34;, among other
things. Which in turns, unlocks comfortable ways of debugging our executable.</p>
<p>For example, with debug information, we can ask the debugger to stop execution
on a specific function by adding a breakpoint on a function name:</p>
<pre><p>Shell session</p><p><code>$ rust-gdb --quiet --args futile serve
Reading symbols from futile...
(gdb) set print thread-events off
(gdb) break futile::Config::read
Breakpoint 1 at 0x7d105a: file src/main.rs, line 69.
(gdb) r
Starting program: /home/amos/.cargo/bin/futile serve
[Thread debugging using libthread_db enabled]
Using host libthread_db library &#34;/lib64/libthread_db.so.1&#34;.

Thread 1 &#34;futile&#34; hit Breakpoint 1, futile::Config::read () at src/main.rs:69
69              let config_path = if config_path.is_dir() {
(gdb) 
</code></p></pre><div>

<p>Wait, couldn&#39;t we set a breakpoint even if we didn&#39;t have debug info?</p>
</div>
<p>Well, let&#39;s try it!</p>
<pre><p>Shell session</p><p><code>$ rust-gdb --quiet --args futile serve
Reading symbols from futile...
(No debugging symbols found in futile)
(gdb) set print thread-events off
(gdb) break futile::Config::read
Function &#34;futile::Config::read&#34; not defined.
Make breakpoint pending on future shared library load? (y or [n]) y
Breakpoint 1 (futile::Config::read) pending.
(gdb) r
Starting program: /home/amos/.cargo/bin/futile serve
[Thread debugging using libthread_db enabled]
Using host libthread_db library &#34;/lib64/libthread_db.so.1&#34;.
 INFO  futile &gt; Reading config from ./futile.toml
 INFO  futile &gt; No config file found, will use defaults
 INFO  futile &gt; Base dir is /home/amos/bearcove/fasterthanli.me
 WARN  futile &gt; sqlite: [283] recovered 2 frames from WAL file /home/amos/bearcove/fasterthanli.me/.futile/content.db-wal
(etc.)
</code></p></pre>
<p>No!</p>
<div>

<p>But I thought... don&#39;t ELF files (like executable and dynamic libraries, even
static libraries) have symbol tables, that are distinct from debug info?</p>
</div>
<p>They do! If we look at <code>libm.so</code> (lib math), it has a bunch of symbols.
Over a thousand, in fact:</p>
<pre><p>Shell session</p><p><code>$ nm --dynamic --defined-only /usr/lib64/libm.so.6 | head -10
00000000000119d0 W acos@@GLIBC_2.2.5
0000000000015370 W acosf@@GLIBC_2.2.5
0000000000064bc0 W acosf128@@GLIBC_2.26
0000000000046510 T __acosf128_finite@GLIBC_2.26
0000000000015370 W acosf32@@GLIBC_2.27
00000000000119d0 W acosf32x@@GLIBC_2.27
00000000000119d0 W acosf64@@GLIBC_2.27
0000000000010170 W acosf64x@@GLIBC_2.27
0000000000038310 T __acosf_finite@GLIBC_2.15
0000000000025630 i __acos_finite@GLIBC_2.15

$ nm --dynamic --defined-only /usr/lib64/libm.so.6 | wc -l
1102
</code></p></pre>
<p>Our executable however, doesn&#39;t define any symbols:</p>
<pre><p>Shell session</p><p><code>$ nm --dynamic --defined-only $(which futile)
</code></p></pre>
<p>It expects symbols to be defined by other dynamic libraries it depends on, though!</p>
<pre><p>Shell session</p><p><code>$ nm --dynamic --undefined-only $(which futile) | head
                 U abort@GLIBC_2.2.5
                 U accept4@GLIBC_2.10
                 U access@GLIBC_2.2.5
                 U acos@GLIBC_2.2.5
                 U acosh@GLIBC_2.2.5
                 U asin@GLIBC_2.2.5
                 U asinh@GLIBC_2.2.5
                 U __assert_fail@GLIBC_2.2.5
                 U atan@GLIBC_2.2.5
                 U atan2@GLIBC_2.2.5
</code></p></pre><div>

<p>Note the difference: we were using <code>--defined-only</code>, now we&#39;re using
<code>--undefined-only</code>, emphasis on the privative <code>un</code> prefix.</p>
</div>
<p>Look, math functions! I guess it links against <code>libm.so</code>...</p>
<pre><p>Shell session</p><p><code>$ objdump -p $(which futile) | grep &#39;NEEDED&#39;
  NEEDED               libstdc++.so.6
  NEEDED               libgcc_s.so.1
  NEEDED               libm.so.6
  NEEDED               libc.so.6
  NEEDED               ld-linux-x86-64.so.2
</code></p></pre>
<p>Yes it does.</p>
<p>So symbols are only exported if they <em>need</em> to be exported. In the case of a
library, we need to be able to call <code>acos</code> and <code>asin</code> from somewhere else, and
so they&#39;re in the table. But for an executable, all we need to know (sort of),
is where the code starts, and that&#39;s the &#34;start address&#34; here:</p>
<pre><p>Shell session</p><p><code>$ objdump -f $(which futile)

/home/amos/.cargo/bin/futile:     file format elf64-x86-64
architecture: i386:x86-64, flags 0x00000150:
HAS_SYMS, DYNAMIC, D_PAGED
start address 0x0000000000635ec0
</code></p></pre><div>

<p>Okay, so <code>futile::Config::read</code> doesn&#39;t need to be &#34;exported&#34;, because it&#39;s
only ever called &#34;internally&#34; from futile into futile, and... so how did GDB
ever successfully set a breakpoint there?</p>
</div>
<p>It looked at debug information instead!</p>
<p>Because debug information is so useful, and because I like to be able to look at
stack traces with &#34;source location&#34; (file name and line number) information, and
because I like to be able to step through code in a debugger, even on release
builds, I have this:</p>
<pre><p>TOML markup</p><p><code><i># in `futile/Cargo.toml`</i>

<i>[</i><i>profile</i><i>.</i><i>release</i><i>]</i>
<i>debug</i> <i>=</i> 1
</code></p></pre>
<p>And so my executable has a bunch of additional ELF sections:</p>
<pre><p>Shell session</p><p><code>$ objdump --wide --headers $(which futile) | grep -F &#39;.debug&#39;
 12 .debug_gdb_scripts    00000022  00000000004a8b99  00000000004a8b99  004a8b99  2**0  CONTENTS, ALLOC, LOAD, READONLY, DATA
 32 .debug_abbrev         0006a4d3  0000000000000000  0000000000000000  0164f4dc  2**0  CONTENTS, READONLY, DEBUGGING, OCTETS
 33 .debug_info           0195631c  0000000000000000  0000000000000000  016b99af  2**0  CONTENTS, READONLY, DEBUGGING, OCTETS
 34 .debug_aranges        00108190  0000000000000000  0000000000000000  0300fcd0  2**4  CONTENTS, READONLY, DEBUGGING, OCTETS
 35 .debug_ranges         00d770e0  0000000000000000  0000000000000000  03117e60  2**0  CONTENTS, READONLY, DEBUGGING, OCTETS
 36 .debug_str            016b3e43  0000000000000000  0000000000000000  03e8ef40  2**0  CONTENTS, READONLY, DEBUGGING, OCTETS
 37 .debug_pubnames       0154980f  0000000000000000  0000000000000000  05542d83  2**0  CONTENTS, READONLY, DEBUGGING, OCTETS
 38 .debug_pubtypes       0000690c  0000000000000000  0000000000000000  06a8c592  2**0  CONTENTS, READONLY, DEBUGGING, OCTETS
 39 .debug_line           00da927e  0000000000000000  0000000000000000  06a92e9e  2**0  CONTENTS, READONLY, DEBUGGING, OCTETS
 40 .debug_loclists       00453d2b  0000000000000000  0000000000000000  0783c11c  2**0  CONTENTS, READONLY, DEBUGGING, OCTETS
 41 .debug_rnglists       0009618f  0000000000000000  0000000000000000  07c8fe47  2**0  CONTENTS, READONLY, DEBUGGING, OCTETS
 42 .debug_line_str       000025c6  0000000000000000  0000000000000000  07d25fd6  2**0  CONTENTS, READONLY, DEBUGGING, OCTETS
 43 .debug_macro          00002a41  0000000000000000  0000000000000000  07d2859c  2**0  CONTENTS, READONLY, DEBUGGING, OCTETS
 44 .debug_frame          000001d0  0000000000000000  0000000000000000  07d2afe0  2**3  CONTENTS, READONLY, DEBUGGING, OCTETS
</code></p></pre>
<p>And, the format of those is quite complicated, but with a little help from our
friends we can trace back what GDB used to set a breakpoint on
<code>futile::Config::read</code>:</p>
<pre><p>Shell session</p><p><code>$ readelf --debug-dump=info $(which futile) | rustfilt | grep &#39;futile::Config::read&#39;
    &lt;2e68b4&gt;   DW_AT_linkage_name: (indirect string, offset: 0xb960a1): futile::Config::read
</code></p></pre><div>

<p>Note that <code>rustfilt</code> is necessary here, otherwise we have the mangled form
<code>_ZN6futile6Config4read17h2622e8ecc143c293E</code> instead.</p>
<p>Alternatively, we could&#39;ve piped into <code>grep -E &#39;futile.Config.read&#39;</code>, which
would have searched for the words <code>futile</code>, <code>Config</code>, and <code>read</code> separated by
any single character.</p>
</div>
<p>But here&#39;s the point I&#39;m getting at: generating that debug information is not
free. It takes time!</p>
<p>In fact, the
<a href="https://doc.rust-lang.org/cargo/reference/config.html#profilenamedebug"><code>profile.&lt;name&gt;.debug</code></a>
cargo configuration key is not a simple on/off switch: there&#39;s levels 0 (or
false), 1 and 2 (or true).</p>
<p>Most of the time, 2 really is overkill. Let&#39;s compare timings just so you can be
convinced that it really does make an impact on the build times of <code>futile</code>:</p>
<ul>
<li>With <code>debug = 0</code>, a cold build takes ~1m55s</li>
<li>With <code>debug = 1</code>, a cold build takes ~2m04s</li>
<li>With <code>debug = 2</code>, a cold build takes ~2m12s</li>
</ul>
<p>Now keep in mind we have a block of roughly ~72s where we&#39;re not sure what the
compiler is doing, and the rest is embarassingly parallel, so the difference
there is less impressive than it should be. We&#39;ll try again once we fix whatever
is taking so long.</p>
<div>

<p>Debug information is super duper useful, if only so when you get a crash, you
can easily map a stack trace (a bunch of memory addresses) to a bunch of source
locations (file name / line number, but also function name, etc).</p>
<p>In <code>Cargo.toml</code>, <code>debug = true</code> actually means <code>debug = 2</code>, and it&#39;s usually
overkill, unless you&#39;re doing the sort of debugging where you need to be able
to inspect the value of local variables for example. If all you&#39;re after is
a stack trace, <code>debug = 1</code> is good enough.</p>
<p>If you think debug information is too large, first off, you&#39;re correct, but
secondly, try reaching for <code>objcopy --compress-debug-sections</code> to compress it
instead of throwing it away with <code>strip</code>: you might find that you&#39;re happy with
that compromise.</p>
</div>
<h2>Incremental builds</h2>
<p>One thing I&#39;ve made sure to mention since the beginning of this article is that
I&#39;m talking about <em>release</em> builds, not <em>debug</em> builds. That&#39;s why all <code>cargo</code>
invocations have had the <code>--release</code> flag.</p>
<p>Is it as slow to make a debug build of <code>futile</code>?</p>
<ul>
<li>Cold debug build: 1m33s (vs 2m04s for release)</li>
<li>Hot debug build: 19s (vs 1m11s for release)</li>
</ul>

<p>Huh indeed! So again, we expect there to be a difference: in debug builds, we
do very few optimizations, whereas in release builds, we try to optimize as much
as possible.</p>
<p>And optimizing isn&#39;t free, so, it makes sense that a release build would take
longer. But that much longer?</p>
<p>There&#39;s another difference: by default, cargo&#39;s debug profile enables
<a href="https://doc.rust-lang.org/cargo/reference/profiles.html#incremental">incremental
builds</a>.
And cargo&#39;s release profile has incremental builds disabled.</p>
<p>What happens if we enable incremental builds for release?</p>
<pre><p>TOML markup</p><p><code><i># in `futile/Cargo.toml`</i>

<i>[</i><i>profile</i><i>.</i><i>release</i><i>]</i>
<i>debug</i> <i>=</i> 1
<i>incremental</i> <i>=</i> <i>true</i>
</code></p></pre>
<ul>
<li>Cold incremental build: 2m08s (vs 2m04s non-incremental)</li>
<li>Hot incremental build: 20s (vs 1m11s non-incremental)</li>
</ul>
<div>

<p>AhAH! That&#39;s better! Much better!</p>
</div>
<p>Yes it is! That&#39;s the whole trade-off of incremental builds: cold builds are a
little slower, but hot builds should be faster.</p>
<div>

<p>Mhh I&#39;m looking at the docs here and... it says something about &#34;codegen units&#34;
too, and it being different for incremental builds vs non-incremental builds?</p>
</div>
<p>Yes! The goal of &#34;incremental builds&#34; is to be able to recompile fast. It helps
if compiling is fast in general, and if we only have to recompile as little code
as possible.</p>
<p>So, with incremental builds, crates are split into more, smaller codegen units.
In 1.57.0 at least, non-incremental builds default to only 16 codegen units,
whereas incremental builds default to 256 codegen units.</p>
<div>

<p>Could it be what&#39;s making the difference? The number of codegen units, and not
incremental builds?</p>
</div>
<p>Let&#39;s try it!</p>
<pre><p>TOML markup</p><p><code><i># in `futile/Cargo.toml`</i>

<i>[</i><i>profile</i><i>.</i><i>release</i><i>]</i>
<i>debug</i> <i>=</i> 1
<i>incremental</i> <i>=</i> <i>false</i>
<i>codegen-units</i> <i>=</i> 256
</code></p></pre>
<ul>
<li>Cold 256-cgu build: 2m02s (vs 2m04s for 16-cgu)</li>
<li>Hot 256-cgu build: 1m11s (vs 1m11s for 16-cgu)</li>
</ul>
<p>Nope. No significant difference.</p>
<div>

<p>Incremental builds sound <em>great</em>. Why wouldn&#39;t we want to use them all the time?</p>
</div>
<p>Well, they&#39;re not well-supported by <a href="https://lib.rs/crates/sccache">sccache</a>,
which I use all the time in CI, so it&#39;s not really an option there.</p>
<p>I&#39;m not sure if there&#39;s any compelling reason not to use incremental builds all
the time <em>locally</em>: I used to think more codegen units meant less optimization
opportunities, but from what I read of the cargo docs, I&#39;m not sure that&#39;s true
anymore.</p>
<p>Generally I would advise setting <code>incremental = true</code> in <code>profile.release</code>, and
just disabling it in CI by setting the environment variable <code>CARGO_INCREMENTAL</code>
to <code>0</code>.</p>
<div>

<p>Incremental builds are super useful to iterate quickly on something. That&#39;s why
they&#39;re enabled by default for debug builds.</p>
<p>If you make a lot of release builds locally, you may want to enable incremental
builds for the release profile too.</p>
<p>If the reason you make release builds locally is because you depend on crates
that do gzip/bzip2/brotli/zstd decompression for example, and those are super
slow in debug, you may want to set up
<a href="https://doc.rust-lang.org/cargo/reference/profiles.html#overrides">overrides</a>
for those dependencies instead!</p>
</div>
<h2>Link-time optimization (LTO)</h2>
<p>Unless you explicitly set <code>lto = &#34;off&#34;</code> in your profile in <code>Cargo.toml</code>, cargo
performs &#34;thin local LTO&#34;, which means it&#39;ll try to inline calls across codegen
units within the same crate.</p>
<p>But if we want it to be able to inline calls <em>across crates</em>, we have to pick
other types of LTO. We can do &#34;fat&#34; LTO, the classical method, and that one
should be super expensive:</p>
<pre><p>TOML markup</p><p><code><i># in `futile/Cargo.toml`</i>

<i>[</i><i>profile</i><i>.</i><i>release</i><i>]</i>
<i>debug</i> <i>=</i> 1
<i>lto</i> <i>=</i> <i>&#34;fat&#34;</i>
</code></p></pre>
<ul>
<li>Cold &#34;fat&#34; LTO release build: 3m39s (vs 2m04s thin-local LTO)</li>
<li>Hot &#34;fat&#34; LTO release build: 2m50s (vs 1m11s thin-local LTO)</li>
</ul>
<p>As expected, it&#39;s doing a <em>lot</em> more work, and so it&#39;s slower. (But with the
promise of maybe generating faster code).</p>
<p>And we can do <a href="https://blog.llvm.org/2016/06/thinlto-scalable-and-incremental-lto.html">thin LTO</a>:</p>
<pre><p>TOML markup</p><p><code><i># in `futile/Cargo.toml`</i>

<i>[</i><i>profile</i><i>.</i><i>release</i><i>]</i>
<i>debug</i> <i>=</i> 1
<i>lto</i> <i>=</i> <i>&#34;thin&#34;</i>
</code></p></pre>
<ul>
<li>Cold thin LTO release build: 2m10s (vs 2m04s thin-local LTO)</li>
<li>Hot thin LTO release build: 1m20s (vs 1m11s thin-local LTO)</li>
</ul>
<p>And as promised, thin LTO is a lot faster than &#34;fat&#34; LTO.</p>
<div>

<p>But we still have a block of 72s where it&#39;s doing <em>something</em> that&#39;s not
linking,
right?</p>
</div>
<div>

<p>Right! We should probably do those measurements again once we&#39;ve solved that.</p>
</div>
<h2>Rustc self-profiling</h2>
<p>Since everything we&#39;ve tried (and that usually works) has failed, it&#39;s time to
go to the next level, which I didn&#39;t know existed until a couple days ago.</p>
<p>I said it was sorta easier to see what&#39;s going on when building, say, C/C++ code
using gcc, because the steps were obvious: in a Makefile or so. But that wasn&#39;t
entirely true.</p>
<p>Because what we have here, is the same as if we had a single <code>.c</code> source file
that took over a minute to build. We know exactly what&#39;s being run, but we don&#39;t
know where the compiler is spending time.</p>
<p>And I have no idea how easy it is to profile GCC, Clang, or MSVC, but I know
it&#39;s <em>really easy</em> to profile rustc, with <code>-Z self-profile</code></p>
<p>That&#39;s <em>also</em> a nightly-only option, so we&#39;ll use the same <code>RUSTC_BOOTSTRAP</code>
crime. It&#39;s also a rustc flag, not a cargo flag, so instead of using <code>cargo build</code> we&#39;ll need to use <code>cargo rustc</code>.</p>
<p>First, let&#39;s make a cold build, because what we really want to know is what
happens during a hot build:</p>
<pre><p>Shell session</p><p><code>$ cargo clean
$ RUSTC_BOOTSTRAP=1 cargo rustc --release
(cut)
    Finished release [optimized + debuginfo] target(s) in 2m 04s
</code></p></pre>
<p>And now let&#39;s change something in <code>main.rs</code> and rebuild, passing <code>-Z self-profile</code>. Because it&#39;s a rustc option, we need to pass it after <code>--</code>, which
separates cargo options from rustc options:</p>
<pre><p>Shell session</p><p><code>$ RUSTC_BOOTSTRAP=1 cargo rustc --release -- -Z self-profile
   Compiling futile v1.9.0 (/home/amos/bearcove/futile)
    Finished release [optimized + debuginfo] target(s) in 1m 14s
</code></p></pre>
<p>rustc wrote a profile to disk, because we asked nicely:</p>
<pre><p>Shell session</p><p><code>$ ls -lhA *profdata
-rw-r--r--. 1 amos amos 39M Dec 30 12:52 futile-1004573.mm_profdata
</code></p></pre>
<p>To visualize it, we have a couple options! So we&#39;ll install a couple tools:</p>
<pre><p>Shell session</p><p><code>$ cargo install --git https://github.com/rust-lang/measureme crox flamegraph summarize
(cut)
     Summary Successfully installed crox, flamegraph, summarize!
</code></p></pre>
<p>Let&#39;s try <code>summarize</code>, the simplest, first:</p>
<pre><p>Shell session</p><p><code>$ summarize summarize futile-1004573.mm_profdata | head -10
+------------------------------------------------+-----------+-----------------+----------+------------+
| Item                                           | Self time | % of total time | Time     | Item count |
+------------------------------------------------+-----------+-----------------+----------+------------+
| evaluate_obligation                            | 58.01s    | 36.678          | 58.17s   | 31347      |
+------------------------------------------------+-----------+-----------------+----------+------------+
| LLVM_module_optimize_module_passes             | 23.74s    | 15.008          | 23.74s   | 16         |
+------------------------------------------------+-----------+-----------------+----------+------------+
| LLVM_lto_optimize                              | 21.09s    | 13.334          | 21.09s   | 16         |
+------------------------------------------------+-----------+-----------------+----------+------------+
| LLVM_module_codegen_emit_obj                   | 16.17s    | 10.220          | 16.17s   | 17         |
(cut)
</code></p></pre><div>

<p>Yes, the <code>summarize</code> command-line tools accepts subcommands, and one of them is
<code>summarize</code>. The stutter is intentional.</p>
</div>
<p>Interesting! It&#39;s spending 58s in <code>evaluate_obligation</code>.</p>
<p>Let&#39;s try <code>flamegraph</code> next!</p>
<pre><p>Shell session</p><p><code>$ flamegraph futile-1004573.mm_profdata
</code></p></pre>
<p>Mhhh.. nothing?</p>
<pre><p>Shell session</p><p><code>$ ls -lhA *.svg
-rw-r--r--. 1 amos amos 28K Dec 30 12:58 rustc.svg
</code></p></pre>
<p>Ah!</p>
<p>It&#39;s interactive and stuff, like you&#39;d expect a flamegraph to be (you can hover
on items to see their full names, the number and % of samples, and you can zoom
around and filter stuff!), but again, all you get is a screenshot unless you
go and do it yourself:</p>

            <picture>
                <source type="image/avif" srcset="/content/articles/why-is-my-rust-build-so-slow/assets/flamegraph.356c093ae807b6e2.avif"/>
                <source type="image/webp" srcset="/content/articles/why-is-my-rust-build-so-slow/assets/flamegraph.1ce1e2a199eeb282.webp"/>
                <img loading="lazy" src="https://scattered-thoughts.net/content/articles/why-is-my-rust-build-so-slow/assets/flamegraph.678ceba37b409f84.jpg"/>
            </picture>
            
<p>I&#39;ve highlighted <code>evaluate_obligation</code>, since it was the most expensive bit
reported by <code>summary</code>.</p>
<p>There&#39;s a third way to visualize that information, which is the richest of them
all, and it&#39;s to use <code>crox</code> to convert it to a &#34;Chrome profile&#34;:</p>
<pre><p>Shell session</p><p><code>$ crox futile-1004573.mm_profdata
$ ls -lhA chrome_profiler.json 
-rw-r--r--. 1 amos amos 161M Dec 30 13:12 chrome_profiler.json
</code></p></pre>
<p>Now we have a <em>boatload</em> of JSON that we can load into <code>chrome://tracing</code> (only
works in Chromium-based browsers):</p>

            <picture>
                <source type="image/avif" srcset="/content/articles/why-is-my-rust-build-so-slow/assets/chrome-tracing.d1ca6b89ebb805bc.avif"/>
                <source type="image/webp" srcset="/content/articles/why-is-my-rust-build-so-slow/assets/chrome-tracing.833ba9fcf3678a3d.webp"/>
                <img loading="lazy" src="https://scattered-thoughts.net/content/articles/why-is-my-rust-build-so-slow/assets/chrome-tracing.bbfb99f47fa7908e.jpg"/>
            </picture>
            
<p>We see much of what we&#39;ve seen in the flamegraph, but with richer info! Also,
it&#39;s not the same graph at all: that one is a timeline, not a flame graph.</p>
<p>Flame graphs let us known about frequency, whereas timelines show what actually
happened in chronological order. Which is made obvious if we search for
<code>evaluate_obligation</code> to highlight it:</p>

            <picture>
                <source type="image/avif" srcset="/content/articles/why-is-my-rust-build-so-slow/assets/chrome-tracing-search.2eeb6cb03f106881.avif"/>
                <source type="image/webp" srcset="/content/articles/why-is-my-rust-build-so-slow/assets/chrome-tracing-search.97e42c236c352978.webp"/>
                <img loading="lazy" src="https://scattered-thoughts.net/content/articles/why-is-my-rust-build-so-slow/assets/chrome-tracing-search.ba3624286002ec65.jpg"/>
            </picture>
            
<p>We can see there&#39;s a <em>lot</em> of <code>evaluate_obligation</code> calls, there&#39;s just one
that&#39;s taking a lot longer. Which points to our issue: it&#39;s not that there&#39;s a
lot of obligations to evaluate, it&#39;s that one is taking <em>forever</em> (over 40
seconds).</p>
<p>If you look closer, you can see there&#39;s actually a <code>link</code> item in there, at
the top-right: it takes only 6.2 seconds. That&#39;s where the difference was made
between GNU ld, LLVM lld and mold.</p>
<div>

<p>Oh yeah, definitely worth measuring those again!</p>
</div>
<p>But... we still don&#39;t know what&#39;s happening. We know something&#39;s wrong, which is
great! Or rather, we now strongly suspect we&#39;re hitting a pathological case
somewhere.</p>
<p>What&#39;s a pathological case? It&#39;s when an algorithm is the slowest is can
possibly be, due to some input.</p>
<p>Take insertion sort, for example: if you go to this <a href="https://www.toptal.com/developers/sorting-algorithms">Sorting Algorithms
Animation page</a> and click
play on &#34;Selection&#34;, look at the &#34;Reversed&#34; input: see how long it takes? It has
to do the <em>maximum</em> amount of swaps, because it&#39;s being given the worst input
possible.  By comparison, &#34;Nearly sorted&#34; finishes very quickly.</p>
<p>So here, we probably have an algorithm in rustc that performs reasonably well
for most inputs, but our program somehow has a shape that makes that algorithm
perform <em>really poorly</em>. This can happen when an algorithm accidentally has
&#34;quadratic complexity&#34;.</p>
<p>Allow me, for a minute, to get all scientific with MS Paint drawings.</p>
<p>Logarithmic complexity is fine, as the time increases less and less as the input
size increases.</p>
<figure>
  
            <picture>
                <source type="image/avif" srcset="/content/articles/why-is-my-rust-build-so-slow/assets/o-log-n.b7b81a9eadcd6593.avif"/>
                <source type="image/webp" srcset="/content/articles/why-is-my-rust-build-so-slow/assets/o-log-n.536e8f8160398072.webp"/>
                <img loading="lazy" src="https://scattered-thoughts.net/content/articles/why-is-my-rust-build-so-slow/assets/o-log-n.77592545e5095977.jpg"/>
            </picture>
            
  <figcaption>
<h4><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log(n))</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>O</span><span>(</span><span>l</span><span>o</span><span>g</span><span>(</span><span>n</span><span>))</span></span></span></span> — logarithmic time complexity</h4>
</figcaption>
</figure>
<p>Linear complexity is fine too, as far as I&#39;m concerned: if you have twice as
much input, it takes twice as long:</p>
<figure>
  
            <picture>
                <source type="image/avif" srcset="/content/articles/why-is-my-rust-build-so-slow/assets/o-n.405f5ede9b3dae1e.avif"/>
                <source type="image/webp" srcset="/content/articles/why-is-my-rust-build-so-slow/assets/o-n.03a7b5c90794c8d2.webp"/>
                <img loading="lazy" src="https://scattered-thoughts.net/content/articles/why-is-my-rust-build-so-slow/assets/o-n.3ddaac7a906ea5f4.jpg"/>
            </picture>
            
  <figcaption>
<h4><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>O</span><span>(</span><span>n</span><span>)</span></span></span></span> — linear time complexity</h4>
</figcaption>
</figure>
<p>But quadratic complexity, is not fine at all. Well, it might be fine for small
values, but the time required shoots up <em>real quick</em>:</p>
<figure>
  
            <picture>
                <source type="image/avif" srcset="/content/articles/why-is-my-rust-build-so-slow/assets/o-n2.2a5b5042a2ec0314.avif"/>
                <source type="image/webp" srcset="/content/articles/why-is-my-rust-build-so-slow/assets/o-n2.e280a9bd1f351ff7.webp"/>
                <img loading="lazy" src="https://scattered-thoughts.net/content/articles/why-is-my-rust-build-so-slow/assets/o-n2.3c707c8e0d028730.jpg"/>
            </picture>
            
  <figcaption>
<h4><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>O</span><span>(</span><span><span>n</span><span><span><span><span><span><span></span><span><span>2</span></span></span></span></span></span></span></span><span>)</span></span></span></span> — quadratic time complexity</h4>
</figcaption>
</figure>
<p>Okay, back to our actual build. We suspect something like that is happening...
but where?</p>
<p>We&#39;ve already said it would be a good idea to break down our big binary crate
into smaller crates but... where to start? Plus, that&#39;s a lot of effort! I would
really like to know what&#39;s causing it.</p>
<p>Luckily, there&#39;s an additional rustc option we can use there to record the
arguments passed to its functions: so we&#39;ll known <em>which</em> obligation it&#39;s
evaluating.</p>
<p>Let&#39;s change something else in <code>main.rs</code> and measure again:</p>
<pre><p>Shell session</p><p><code>$ RUSTC_BOOTSTRAP=1 cargo rustc --release -- -Z self-profile -Z self-profile-events=default,args
</code></p></pre>
<p>This time we&#39;ll do two things differently: first off, when converting the
profile to the Chrome format, we&#39;ll ignore events below a certain duration:
that&#39;ll make for a smaller, easier to explore profile.</p>
<p>But before we do, let&#39;s use <em>another</em> subcommand of <code>summarize</code>: <code>diff</code>:</p>
<pre><p>Shell session</p><p><code>$ summarize diff futile-1004573.mm_profdata futile-1034530.mm_profdata | head -10
+-------------------------------------------------+---------------+------------------+---------------+-------------+------------+------------+--------------+-----------------------+--------------------------+
| Item                                            | Self Time     | Self Time Change | Time          | Time Change | Item count | Cache hits | Blocked time | Incremental load time | Incremental hashing time |
+-------------------------------------------------+---------------+------------------+---------------+-------------+------------+------------+--------------+-----------------------+--------------------------+
| self_profile_alloc_query_strings                | +6.609373529s | +55952.80%       | +6.631967425s | +56144.08%  | +0         | +0         | +0ns         | +0ns                  | +0ns                     |
+-------------------------------------------------+---------------+------------------+---------------+-------------+------------+------------+--------------+-----------------------+--------------------------+
| finish_ongoing_codegen                          | -5.700469852s | -100.00%         | -5.701132355s | -100.00%    | +0         | +0         | +0ns         | +0ns                  | +0ns                     |
+-------------------------------------------------+---------------+------------------+---------------+-------------+------------+------------+--------------+-----------------------+--------------------------+
| LLVM_module_codegen_emit_obj                    | +840.972695ms | +5.20%           | +840.972695ms | +5.20%      | +0         | +0         | +0ns         | +0ns                  | +0ns                     |
+-------------------------------------------------+---------------+------------------+---------------+-------------+------------+------------+--------------+-----------------------+--------------------------+
| LLVM_lto_optimize                               | +614.923743ms | +2.92%           | +614.923743ms | +2.92%      | +0         | +0         | +0ns         | +0ns                  | +0ns                     |
(cut)
</code></p></pre>
<p>Well, it&#39;s not really a fair comparison since we passed different parameters to
<code>self-profile</code>, and I guess that&#39;s what that result is showing us.</p>
<p>But it would be really useful if we had changed something meaningful about our
code instead!</p>
<p>So, let&#39;s convert to a chrome profile, ignoring anything that takes less than,
say... half a second.</p>
<pre><p>Shell session</p><p><code>$ crox --minimum-duration 500000 futile-1034530.mm_profdata
$ ls -lhA chrome_profiler.json 
-rw-r--r--. 1 amos amos 345K Dec 30 13:48 chrome_profiler.json
</code></p></pre>
<p>(Yes, <code>--minimum-duration</code> takes microseconds. Yes, I had to look it up. No, I
don&#39;t trust myself to make order-of-magnitude mistakes)</p>
<p>That&#39;s a much, <em>much</em> smaller profile! The second thing we&#39;re doing different
is, instead of using <code>chrome://tracing</code>, we&#39;re going to use another visualizer:
<a href="https://ui.perfetto.dev/">Perfetto</a>.</p>

            <picture>
                <source type="image/avif" srcset="/content/articles/why-is-my-rust-build-so-slow/assets/perfetto.ffadba1b1924d8ad.avif"/>
                <source type="image/webp" srcset="/content/articles/why-is-my-rust-build-so-slow/assets/perfetto.942aa5eff7f6a49d.webp"/>
                <img loading="lazy" src="https://scattered-thoughts.net/content/articles/why-is-my-rust-build-so-slow/assets/perfetto.d4b593b9934ec5f5.jpg"/>
            </picture>
            
<p><code>--minimum-duration</code> made the profile a lot easier to read, eliminating the
noise.  Loading it in Perfetto made it much nicer to look at. And adding <code>-Z self-profile-events=default,args</code> means we can see which obligation it&#39;s
evaluating, and it is:</p>
<pre><p><code>TraitPredicate(
  &lt;futures::future::Map&lt;warp::hyper::Server&lt;warp::hyper::server::conn::AddrIncoming, warp::hyper::service::make::MakeServiceFn&lt;[closure@warp::Server&lt;warp::log::internal::WithLog&lt;[closure@warp::log::{closure#0}], warp::filter::or::Or&lt;warp::filter::or::Or&lt;warp::filter::or::Or&lt;warp::filter::map::Map&lt;warp::filter::and::And&lt;warp::filter::and::And&lt;warp::filter::FilterFn&lt;[closure@warp::filters::method::method_is&lt;[closure@warp::get::{closure#0}]&gt;::{closure#0}]&gt;, warp::filter::and::And&lt;warp::filter::and::And&lt;warp::filter::and::And&lt;warp::filters::any::Any, warp::path::Exact&lt;warp::path::internal::Opaque&lt;serve::serve::{closure#0}::__StaticPath&gt;&gt;&gt;, warp::path::Exact&lt;warp::path::internal::Opaque&lt;serve::serve::{closure#0}::__StaticPath&gt;&gt;&gt;, warp::filter::FilterFn&lt;[closure@warp::path::end::{closure#0}]&gt;&gt;&gt;, warp::filter::map::Map&lt;warp::filter::and::And&lt;warp::filter::and::And&lt;warp::filter::and::And&lt;warp::filter::and::And&lt;warp::filter::map::Map&lt;warp::filters::any::Any, [closure@src/serve/mod.rs:158:38: 158:66]&gt;, warp::filter::FilterFn&lt;[closure@warp::path::full::{closure#0}]&gt;&gt;, warp::filter::unify::Unify&lt;warp::filter::recover::Recover&lt;warp::filter::FilterFn&lt;[closure@warp::filter::filter_fn_one&lt;[closure@warp::query::raw::{closure#0}], futures::future::Ready&lt;std::result::Result&lt;std::string::String, warp::Rejection&gt;&gt;&gt;::{closure#0}]&gt;, [closure@src/serve/mod.rs:165:26: 168:18]&gt;&gt;&gt;, warp::filter::FilterFn&lt;[closure@warp::filter::filter_fn_one&lt;[closure@warp::header::optional&lt;std::string::String&gt;::{closure#0}], futures::future::Ready&lt;std::result::Result&lt;std::option::Option&lt;std::string::String&gt;, warp::Rejection&gt;&gt;&gt;::{closure#0}]&gt;&gt;, warp::filter::unify::Unify&lt;warp::filter::recover::Recover&lt;warp::filter::and_then::AndThen&lt;warp::filter::FilterFn&lt;[closure@warp::filter::filter_fn_one&lt;[closure@warp::body::body::{closure#0}], futures::future::Ready&lt;std::result::Result&lt;warp::hyper::Body, warp::Rejection&gt;&gt;&gt;::{closure#0}]&gt;, [closure@warp::body::bytes::{closure#0}]&gt;, [closure@src/serve/mod.rs:174:26: 180:18]&gt;&gt;&gt;, [closure@src/serve/mod.rs:184:13: 207:14]&gt;&gt;, [closure@src/serve/mod.rs:231:14: 231:92]&gt;, warp::filter::and_then::AndThen&lt;warp::filter::and::And&lt;warp::filter::FilterFn&lt;[closure@warp::filters::method::method_is&lt;[closure@warp::get::{closure#0}]&gt;::{closure#0}]&gt;, warp::filter::map::Map&lt;warp::filter::and::And&lt;warp::filter::and::And&lt;warp::filter::and::And&lt;warp::filter::and::And&lt;warp::filter::map::Map&lt;warp::filters::any::Any, [closure@src/serve/mod.rs:158:38: 158:66]&gt;, warp::filter::FilterFn&lt;[closure@warp::path::full::{closure#0}]&gt;&gt;, warp::filter::unify::Unify&lt;warp::filter::recover::Recover&lt;warp::filter::FilterFn&lt;[closure@warp::filter::filter_fn_one&lt;[closure@warp::query::raw::{closure#0}], futures::future::Ready&lt;std::result::Result&lt;std::string::String, warp::Rejection&gt;&gt;&gt;::{closure#0}]&gt;, [closure@src/serve/mod.rs:165:26: 168:18]&gt;&gt;&gt;, warp::filter::FilterFn&lt;[closure@warp::filter::filter_fn_one&lt;[closure@warp::header::optional&lt;std::string::String&gt;::{closure#0}], futures::future::Ready&lt;std::result::Result&lt;std::option::Option&lt;std::string::String&gt;, warp::Rejection&gt;&gt;&gt;::{closure#0}]&gt;&gt;, warp::filter::unify::Unify&lt;warp::filter::recover::Recover&lt;warp::filter::and_then::AndThen&lt;warp::filter::FilterFn&lt;[closure@warp::filter::filter_fn_one&lt;[closure@warp::body::body::{closure#0}], futures::future::Ready&lt;std::result::Result&lt;warp::hyper::Body, warp::Rejection&gt;&gt;&gt;::{closure#0}]&gt;, [closure@warp::body::bytes::{closure#0}]&gt;, [closure@src/serve/mod.rs:174:26: 180:18]&gt;&gt;&gt;, [closure@src/serve/mod.rs:184:13: 207:14]&gt;&gt;, [closure@src/serve/mod.rs:235:19: 235:61]&gt;&gt;, warp::filter::and_then::AndThen&lt;warp::filter::and::And&lt;warp::filter::FilterFn&lt;[closure@warp::filters::method::method_is&lt;[closure@warp::head::{closure#0}]&gt;::{closure#0}]&gt;, warp::filter::map::Map&lt;warp::filter::and::And&lt;warp::filter::and::And&lt;warp::filter::and::And&lt;warp::filter::and::And&lt;warp::filter::map::Map&lt;warp::filters::any::Any, [closure@src/serve/mod.rs:158:38: 158:66]&gt;, warp::filter::FilterFn&lt;[closure@warp::path::full::{closure#0}]&gt;&gt;, warp::filter::unify::Unify&lt;warp::filter::recover::Recover&lt;warp::filter::FilterFn&lt;[closure@warp::filter::filter_fn_one&lt;[closure@warp::query::raw::{closure#0}], futures::future::Ready&lt;std::result::Result&lt;std::string::String, warp::Rejection&gt;&gt;&gt;::{closure#0}]&gt;, [closure@src/serve/mod.rs:165:26: 168:18]&gt;&gt;&gt;, warp::filter::FilterFn&lt;[closure@warp::filter::filter_fn_one&lt;[closure@warp::header::optional&lt;std::string::String&gt;::{closure#0}], futures::future::Ready&lt;std::result::Result&lt;std::option::Option&lt;std::string::String&gt;, warp::Rejection&gt;&gt;&gt;::{closure#0}]&gt;&gt;, warp::filter::unify::Unify&lt;warp::filter::recover::Recover&lt;warp::filter::and_then::AndThen&lt;warp::filter::FilterFn&lt;[closure@warp::filter::filter_fn_one&lt;[closure@warp::body::body::{closure#0}], futures::future::Ready&lt;std::result::Result&lt;warp::hyper::Body, warp::Rejection&gt;&gt;&gt;::{closure#0}]&gt;, [closure@warp::body::bytes::{closure#0}]&gt;, [closure@src/serve/mod.rs:174:26: 180:18]&gt;&gt;&gt;, [closure@src/serve/mod.rs:184:13: 207:14]&gt;&gt;, [closure@src/serve/mod.rs:239:19: 239:61]&gt;&gt;, warp::filter::and_then::AndThen&lt;warp::filter::and::And&lt;warp::filter::FilterFn&lt;[closure@warp::filters::method::method_is&lt;[closure@warp::post::{closure#0}]&gt;::{closure#0}]&gt;, warp::filter::map::Map&lt;warp::filter::and::And&lt;warp::filter::and::And&lt;warp::filter::and::And&lt;warp::filter::and::And&lt;warp::filter::map::Map&lt;warp::filters::any::Any, [closure@src/serve/mod.rs:158:38: 158:66]&gt;, warp::filter::FilterFn&lt;[closure@warp::path::full::{closure#0}]&gt;&gt;, warp::filter::unify::Unify&lt;warp::filter::recover::Recover&lt;warp::filter::FilterFn&lt;[closure@warp::filter::filter_fn_one&lt;[closure@warp::query::raw::{closure#0}], futures::future::Ready&lt;std::result::Result&lt;std::string::String, warp::Rejection&gt;&gt;&gt;::{closure#0}]&gt;, [closure@src/serve/mod.rs:165:26: 168:18]&gt;&gt;&gt;, warp::filter::FilterFn&lt;[closure@warp::filter::filter_fn_one&lt;[closure@warp::header::optional&lt;std::string::String&gt;::{closure#0}], futures::future::Ready&lt;std::result::Result&lt;std::option::Option&lt;std::string::String&gt;, warp::Rejection&gt;&gt;&gt;::{closure#0}]&gt;&gt;, warp::filter::unify::Unify&lt;warp::filter::recover::Recover&lt;warp::filter::and_then::AndThen&lt;warp::filter::FilterFn&lt;[closure@warp::filter::filter_fn_one&lt;[closure@warp::body::body::{closure#0}], futures::future::Ready&lt;std::result::Result&lt;warp::hyper::Body, warp::Rejection&gt;&gt;&gt;::{closure#0}]&gt;, [closure@warp::body::bytes::{closure#0}]&gt;, [closure@src/serve/mod.rs:174:26: 180:18]&gt;&gt;&gt;, [closure@src/serve/mod.rs:184:13: 207:14]&gt;&gt;, [closure@src/serve/mod.rs:243:19: 243:62]&gt;&gt;&gt;&gt;::bind_ephemeral&lt;std::net::SocketAddr&gt;::{closure#1}::{closure#0}]&gt;&gt;, [closure@warp::Server&lt;warp::log::internal::WithLog&lt;[closure@warp::log::{closure#0}], warp::filter::or::Or&lt;warp::filter::or::Or&lt;warp::filter::or::Or&lt;warp::filter::map::Map&lt;warp::filter::and::And&lt;warp::filter::and::And&lt;warp::filter::FilterFn&lt;[closure@warp::filters::method::method_is&lt;[closure@warp::get::{closure#0}]&gt;::{closure#0}]&gt;, warp::filter::and::And&lt;warp::filter::and::And&lt;warp::filter::and::And&lt;warp::filters::any::Any, warp::path::Exact&lt;warp::path::internal::Opaque&lt;serve::serve::{closure#0}::__StaticPath&gt;&gt;&gt;, warp::path::Exact&lt;warp::path::internal::Opaque&lt;serve::serve::{closure#0}::__StaticPath&gt;&gt;&gt;, warp::filter::FilterFn&lt;[closure@warp::path::end::{closure#0}]&gt;&gt;&gt;, warp::filter::map::Map&lt;warp::filter::and::And&lt;warp::filter::and::And&lt;warp::filter::and::And&lt;warp::filter::and::And&lt;warp::filter::map::Map&lt;warp::filters::any::Any, [closure@src/serve/mod.rs:158:38: 158:66]&gt;, warp::filter::FilterFn&lt;[closure@warp::path::full::{closure#0}]&gt;&gt;, warp::filter::unify::Unify&lt;warp::filter::recover::Recover&lt;warp::filter::FilterFn&lt;[closure@warp::filter::filter_fn_one&lt;[closure@warp::query::raw::{closure#0}], futures::future::Ready&lt;std::result::Result&lt;std::string::String, warp::Rejection&gt;&gt;&gt;::{closure#0}]&gt;, [closure@src/serve/mod.rs:165:26: 168:18]&gt;&gt;&gt;, warp::filter::FilterFn&lt;[closure@warp::filter::filter_fn_one&lt;[closure@warp::header::optional&lt;std::string::String&gt;::{closure#0}], futures::future::Ready&lt;std::result::Result&lt;std::option::Option&lt;std::string::String&gt;, warp::Rejection&gt;&gt;&gt;::{closure#0}]&gt;&gt;, warp::filter::unify::Unify&lt;warp::filter::recover::Recover&lt;warp::filter::and_then::AndThen&lt;warp::filter::FilterFn&lt;[closure@warp::filter::filter_fn_one&lt;[closure@warp::body::body::{closure#0}], futures::future::Ready&lt;std::result::Result&lt;warp::hyper::Body, warp::Rejection&gt;&gt;&gt;::{closure#0}]&gt;, [closure@warp::body::bytes::{closure#0}]&gt;, [closure@src/serve/mod.rs:174:26: 180:18]&gt;&gt;&gt;, [closure@src/serve/mod.rs:184:13: 207:14]&gt;&gt;, [closure@src/serve/mod.rs:231:14: 231:92]&gt;, warp::filter::and_then::AndThen&lt;warp::filter::and::And&lt;warp::filter::FilterFn&lt;[closure@warp::filters::method::method_is&lt;[closure@warp::get::{closure#0}]&gt;::{closure#0}]&gt;, warp::filter::map::Map&lt;warp::filter::and::And&lt;warp::filter::and::And&lt;warp::filter::and::And&lt;warp::filter::and::And&lt;warp::filter::map::Map&lt;warp::filters::any::Any, [closure@src/serve/mod.rs:158:38: 158:66]&gt;, warp::filter::FilterFn&lt;[closure@warp::path::full::{closure#0}]&gt;&gt;, warp::filter::unify::Unify&lt;warp::filter::recover::Recover&lt;warp::filter::FilterFn&lt;[closure@warp::filter::filter_fn_one&lt;[closure@warp::query::raw::{closure#0}], futures::future::Ready&lt;std::result::Result&lt;std::string::String, warp::Rejection&gt;&gt;&gt;::{closure#0}]&gt;, [closure@src/serve/mod.rs:165:26: 168:18]&gt;&gt;&gt;, warp::filter::FilterFn&lt;[closure@warp::filter::filter_fn_one&lt;[closure@warp::header::optional&lt;std::string::String&gt;::{closure#0}], futures::future::Ready&lt;std::result::Result&lt;std::option::Option&lt;std::string::String&gt;, warp::Rejection&gt;&gt;&gt;::{closure#0}]&gt;&gt;, warp::filter::unify::Unify&lt;warp::filter::recover::Recover&lt;warp::filter::and_then::AndThen&lt;warp::filter::FilterFn&lt;[closure@warp::filter::filter_fn_one&lt;[closure@warp::body::body::{closure#0}], futures::future::Ready&lt;std::result::Result&lt;warp::hyper::Body, warp::Rejection&gt;&gt;&gt;::{closure#0}]&gt;, [closure@warp::body::bytes::{closure#0}]&gt;, [closure@src/serve/mod.rs:174:26: 180:18]&gt;&gt;&gt;, [closure@src/serve/mod.rs:184:13: 207:14]&gt;&gt;, [closure@src/serve/mod.rs:235:19: 235:61]&gt;&gt;, warp::filter::and_then::AndThen&lt;warp::filter::and::And&lt;warp::filter::FilterFn&lt;[closure@warp::filters::method::method_is&lt;[closure@warp::head::{closure#0}]&gt;::{closure#0}]&gt;, warp::filter::map::Map&lt;warp::filter::and::And&lt;warp::filter::and::And&lt;warp::filter::and::And&lt;warp::filter::and::And&lt;warp::filter::map::Map&lt;warp::filters::any::Any, [closure@src/serve/mod.rs:158:38: 158:66]&gt;, warp::filter::FilterFn&lt;[closure@warp::path::full::{closure#0}]&gt;&gt;, warp::filter::unify::Unify&lt;warp::filter::recover::Recover&lt;warp::filter::FilterFn&lt;[closure@warp::filter::filter_fn_one&lt;[closure@warp::query::raw::{closure#0}], futures::future::Ready&lt;std::result::Result&lt;std::string::String, warp::Rejection&gt;&gt;&gt;::{closure#0}]&gt;, [closure@src/serve/mod.rs:165:26: 168:18]&gt;&gt;&gt;, warp::filter::FilterFn&lt;[closure@warp::filter::filter_fn_one&lt;[closure@warp::header::optional&lt;std::string::String&gt;::{closure#0}], futures::future::Ready&lt;std::result::Result&lt;std::option::Option&lt;std::string::String&gt;, warp::Rejection&gt;&gt;&gt;::{closure#0}]&gt;&gt;, warp::filter::unify::Unify&lt;warp::filter::recover::Recover&lt;warp::filter::and_then::AndThen&lt;warp::filter::FilterFn&lt;[closure@warp::filter::filter_fn_one&lt;[closure@warp::body::body::{closure#0}], futures::future::Ready&lt;std::result::Result&lt;warp::hyper::Body, warp::Rejection&gt;&gt;&gt;::{closure#0}]&gt;, [closure@warp::body::bytes::{closure#0}]&gt;, [closure@src/serve/mod.rs:174:26: 180:18]&gt;&gt;&gt;, [closure@src/serve/mod.rs:184:13: 207:14]&gt;&gt;, [closure@src/serve/mod.rs:239:19: 239:61]&gt;&gt;, warp::filter::and_then::AndThen&lt;warp::filter::and::And&lt;warp::filter::FilterFn&lt;[closure@warp::filters::method::method_is&lt;[closure@warp::post::{closure#0}]&gt;::{closure#0}]&gt;, warp::filter::map::Map&lt;warp::filter::and::And&lt;warp::filter::and::And&lt;warp::filter::and::And&lt;warp::filter::and::And&lt;warp::filter::map::Map&lt;warp::filters::any::Any, [closure@src/serve/mod.rs:158:38: 158:66]&gt;, warp::filter::FilterFn&lt;[closure@warp::path::full::{closure#0}]&gt;&gt;, warp::filter::unify::Unify&lt;warp::filter::recover::Recover&lt;warp::filter::FilterFn&lt;[closure@warp::filter::filter_fn_one&lt;[closure@warp::query::raw::{closure#0}], futures::future::Ready&lt;std::result::Result&lt;std::string::String, warp::Rejection&gt;&gt;&gt;::{closure#0}]&gt;, [closure@src/serve/mod.rs:165:26: 168:18]&gt;&gt;&gt;, warp::filter::FilterFn&lt;[closure@warp::filter::filter_fn_one&lt;[closure@warp::header::optional&lt;std::string::String&gt;::{closure#0}], futures::future::Ready&lt;std::result::Result&lt;std::option::Option&lt;std::string::String&gt;, warp::Rejection&gt;&gt;&gt;::{closure#0}]&gt;&gt;, warp::filter::unify::Unify&lt;warp::filter::recover::Recover&lt;warp::filter::and_then::AndThen&lt;warp::filter::FilterFn&lt;[closure@warp::filter::filter_fn_one&lt;[closure@warp::body::body::{closure#0}], futures::future::Ready&lt;std::result::Result&lt;warp::hyper::Body, warp::Rejection&gt;&gt;&gt;::{closure#0}]&gt;, [closure@warp::body::bytes::{closure#0}]&gt;, [closure@src/serve/mod.rs:174:26: 180:18]&gt;&gt;&gt;, [closure@src/serve/mod.rs:184:13: 207:14]&gt;&gt;, [closure@src/serve/mod.rs:243:19: 243:62]&gt;&gt;&gt;&gt;::bind_ephemeral&lt;std::net::SocketAddr&gt;::{closure#0}]&gt;
as
  warp::Future
&gt;)
</code></p></pre>
<p>That is... big.</p>
<p>And that&#39;s from <a href="https://lib.rs/crates/warp">warp</a>, the web server framework I&#39;m
using in futile.</p>
<div>

<p>rustc has a built-in profiler (<code>-Z self-profile</code>), and its output can be
visualized in a multitude of ways. The
<a href="https://github.com/rust-lang/measureme">measureme</a> repository contains
a <code>summary</code> tool, which shows a table in the CLI, a <code>flamegraph</code> tool which
generates a <a href="https://www.brendangregg.com/flamegraphs.html">flamegraph</a>,
and <code>crox</code>, which converts the profile to Chrome&#39;s tracing format.</p>
<p>Those can be viewed in <code>chrome://tracing</code> in a Chromium-based browser, on
<a href="https://ui.perfetto.dev/">Perfetto</a>, <a href="https://www.speedscope.app/">Speedscope</a>,
and more!</p>
</div>
<h2>Warp, I trusted you</h2>
<p>...I didn&#39;t actually trust <code>warp</code> that much. It&#39;s perfectly fine! It just.. has
a tendency to make for very very long types, like the one we see above. Just
like <a href="https://lib.rs/crates/tower">tower</a>.</p>
<p>But I hadn&#39;t noticed those long compile times before... did something change
recently?</p>
<p>Let&#39;s try Rust 1.54.0 just to check. Because <code>rustup</code> makes it unreasonably
easy!</p>
<pre><p>Shell session</p><p><code>$ rustup install 1.54.0
$ cargo clean
$ cargo +1.54.0 build --release
(cut)
</code></p></pre>
<p>(Note: I had to commit a few crimes to get 1.54.0 to build my project since I&#39;ve
already updated a couple crates to Rust edition 2021 - the <code>RUSTC_BOOTSTRAP</code> escape
hatch + manually adding <code>cargo-features = [&#34;edition2021&#34;]</code> did the trick).</p>
<p>Here are the timings:</p>
<ul>
<li>Cold 1.54.0 build: 1m12s (vs 2m04s for 1.57.0)</li>
<li>Hot 1.54.0 build: 18.07s (vs 1m11s for 1.57.0)</li>
</ul>

<p>Yeah. It&#39;s a pretty bad regression. And <a href="https://github.com/seanmonstar/warp/issues/507#issuecomment-992048404">it is
known</a>.</p>
<p>Apparently Rust 1.58 should improve the situation. Does that mean... nightly
should do better?</p>
<pre><p>Shell session</p><p><code>$ rustup install nightly
$ cargo clean
$ cargo +nightly build --release
(cut)
</code></p></pre>
<ul>
<li>Cold 2021-12-19 build: 1m05s (vs 2m04s for 1.57.0)</li>
<li>Hot 2021-12-19 build: 15.25s (vs 1m11s for 1.57.0)</li>
</ul>
<p>That is much, much better.</p>
<div>

<p>So what, we just switch to nightly?</p>
</div>
<p>Well, we could! It would be as simple as pinning that nightly version in our
<code>rust-toolchain.toml</code>, ie. changing:</p>
<pre><p>TOML markup</p><p><code><i>[</i><i>toolchain</i><i>]</i>
<i>channel</i> <i>=</i> <i>&#34;1.57.0&#34;</i>
<i>components</i> <i>=</i> <i>[</i> <i>&#34;rustfmt&#34;</i><i>,</i> <i>&#34;clippy&#34;</i> <i>]</i>
</code></p></pre>
<p>To:</p>
<pre><p>TOML markup</p><p><code><i>[</i><i>toolchain</i><i>]</i>
<i>channel</i> <i>=</i> <i>&#34;nightly-2021-12-19&#34;</i>
<i>components</i> <i>=</i> <i>[</i> <i>&#34;rustfmt&#34;</i><i>,</i> <i>&#34;clippy&#34;</i> <i>]</i>
</code></p></pre>
<p>But there&#39;s probably a workaround. Warp provides
<a href="https://docs.rs/warp/0.3.2/warp/trait.Filter.html#method.boxed">Filter::boxed</a>,
and boxing is a great way to hide actual types.</p>
<p>That will mean more heap allocations, but I think I can take the performance
hit, so, let&#39;s give it a try.</p>
<p>Right now, the code I&#39;m using to compose all routes looks like this:</p>
<pre><p>Rust code</p><p><code>    <i>let</i> livereload_route = method<i>::</i><i>get</i><i>(</i><i>)</i>
        <i>.</i><i>and</i><i>(</i>warp<i>::</i>path!<i>(</i><i>&#34;api&#34;</i> / <i>&#34;livereload&#34;</i><i>)</i><i>)</i>
        <i>.</i><i>and</i><i>(</i><i>with_cx</i><i>(</i><i>)</i><i>)</i>
        <i>.</i><i>map</i><i>(</i>|<i>cx</i>: <i>Context</i>| warp<i>::</i>sse<i>::</i><i>reply</i><i>(</i>warp<i>::</i>sse<i>::</i><i>keep_alive</i><i>(</i><i>)</i><i>.</i><i>stream</i><i>(</i><i>sse_events</i><i>(</i>cx<i>)</i><i>)</i><i>)</i><i>)</i><i>;</i>

    <i>let</i> catchall_get = method<i>::</i><i>get</i><i>(</i><i>)</i>
        <i>.</i><i>and</i><i>(</i><i>with_cx</i><i>(</i><i>)</i><i>)</i>
        <i>.</i><i>and_then</i><i>(</i>|<i>cx</i>: <i>Context</i>| cx<i>.</i><i>handle</i><i>(</i>routes<i>::</i>serve_get<i>)</i><i>)</i><i>;</i>

    <i>let</i> catchall_head = method<i>::</i><i>head</i><i>(</i><i>)</i>
        <i>.</i><i>and</i><i>(</i><i>with_cx</i><i>(</i><i>)</i><i>)</i>
        <i>.</i><i>and_then</i><i>(</i>|<i>cx</i>: <i>Context</i>| cx<i>.</i><i>handle</i><i>(</i>routes<i>::</i>serve_get<i>)</i><i>)</i><i>;</i>

    <i>let</i> catchall_post = method<i>::</i><i>post</i><i>(</i><i>)</i>
        <i>.</i><i>and</i><i>(</i><i>with_cx</i><i>(</i><i>)</i><i>)</i>
        <i>.</i><i>and_then</i><i>(</i>|<i>cx</i>: <i>Context</i>| cx<i>.</i><i>handle</i><i>(</i>routes<i>::</i>serve_post<i>)</i><i>)</i><i>;</i>

    <i>let</i> all_routes = livereload_route
        <i>.</i><i>or</i><i>(</i>catchall_get<i>)</i>
        <i>.</i><i>or</i><i>(</i>catchall_head<i>)</i>
        <i>.</i><i>or</i><i>(</i>catchall_post<i>)</i><i>;</i>
    <i>let</i> access_log = warp<i>::</i>filters<i>::</i>log<i>::</i><i>log</i><i>(</i><i>&#34;access&#34;</i><i>)</i><i>;</i>

    <i>let</i> addr: <i>SocketAddr</i> = config<i>.</i><i>address</i><i>.</i><i>parse</i><i>(</i><i>)</i>?<i>;</i>
    warp<i>::</i><i>serve</i><i>(</i>all_routes<i>.</i><i>with</i><i>(</i>access_log<i>)</i><i>)</i><i>.</i><i>run</i><i>(</i>addr<i>)</i><i>.</i>await<i>;</i>
</code></p></pre>
<p>It&#39;s not very warp-y, since I do some routing in the <code>catchall_{get,head,post}</code>
functions. You can see I&#39;ve <em>already</em> been trying to stay away from large types,
and kinda fighting off &#34;the warp way&#34;. Probably a good sign that the framework
just isn&#39;t for me - I&#39;m excited to try out <a href="https://lib.rs/crates/axum">axum</a>.</p>
<p>Note that there&#39;s a bunch of methods and closures not shown here: they deal with
<a href="https://en.wikipedia.org/wiki/Server-sent_events">server-sent events</a>, passing
around a <code>Context</code> struct (a reference-counted state of the server), dealing with
cookies, extracting the query string, etc.</p>
<p>Simply peppering a few <code>.boxed()</code>...</p>
<pre><p>Rust code</p><p><code>    <i>let</i> all_routes = livereload_route
        <i>.</i><i>boxed</i><i>(</i><i>)</i>
        <i>.</i><i>or</i><i>(</i>catchall_get<i>.</i><i>boxed</i><i>(</i><i>)</i><i>)</i>
        <i>.</i><i>or</i><i>(</i>catchall_head<i>.</i><i>boxed</i><i>(</i><i>)</i><i>)</i>
        <i>.</i><i>or</i><i>(</i>catchall_post<i>.</i><i>boxed</i><i>(</i><i>)</i><i>)</i><i>;</i>
</code></p></pre>
<p>...brought down the build times significantly.</p>
<ul>
<li>Cold boxed build: 1m06s (vs 2m04s non-boxed)</li>
<li>Hot boxed build: 14s (vs 1m11s non-boxed)</li>
</ul>
<h2>Revisiting all the other changes</h2>
<p>Now that we&#39;ve got a new standard for our build times, let&#39;s try our other
tricks again and see what change they make!</p>
<p>Because 14s is much <em>much</em> better than 1m11s, but it&#39;s already more than I&#39;m
comfortable with.</p>
<p>First, let&#39;s get a rough idea of where we&#39;re spending our time now.</p>
<pre><p>Shell session</p><p><code>$ RUSTC_BOOTSTRAP=1 cargo rustc --release -- -Z self-profile -Z self-profile-events=default,args
(cut)
$ crox --minimum-duration 500000 futile-1118608.mm_profdata
</code></p></pre>
            <picture>
                <source type="image/avif" srcset="/content/articles/why-is-my-rust-build-so-slow/assets/mostly-codegen.332c27191a584ed9.avif"/>
                <source type="image/webp" srcset="/content/articles/why-is-my-rust-build-so-slow/assets/mostly-codegen.5814b7b48f7165a7.webp"/>
                <img loading="lazy" src="https://scattered-thoughts.net/content/articles/why-is-my-rust-build-so-slow/assets/mostly-codegen.6c3b3df94c5aa62c.jpg"/>
            </picture>
            
<p>Okay! We&#39;re spending most of our time in codegen and LLVM: linking only accounts
for about two seconds, if we&#39;re to trust that <code>link</code> item (and even then, it&#39;s
spending time in <code>finish_ongoing_codegen</code>, which sounds like it&#39;s just waiting
for the other parts to be finished).</p>
<p>First, instead of doing a release build, let&#39;s try making a debug build instead:
this should, most significantly: 1) enable incremental builds, 2) bump codegen
units from 16 to 256 3) disable optimizations.</p>
<ul>
<li>Cold debug build: 36.44s (vs 1m06s release)</li>
<li>Hot debug build: 3.05s (vs 14s release)</li>
</ul>
<p>That&#39;s more like it!!! Three seconds is super acceptable honestly.</p>
<p>Let&#39;s look where it&#39;s spending time again:</p>

            <picture>
                <source type="image/avif" srcset="/content/articles/why-is-my-rust-build-so-slow/assets/debug-build-perfetto.64fc34f355adb98f.avif"/>
                <source type="image/webp" srcset="/content/articles/why-is-my-rust-build-so-slow/assets/debug-build-perfetto.adf8fb6790342e89.webp"/>
                <img loading="lazy" src="https://scattered-thoughts.net/content/articles/why-is-my-rust-build-so-slow/assets/debug-build-perfetto.17d19c6f6cd6b2b0.jpg"/>
            </picture>
            
<p>We&#39;ve now reached the point where profiling is interfering with the build
(making it more than 4x slower), and where a minimum duration of 500ms is hiding
a lot of important information.</p>
<p>Let&#39;s try again with a minimum duration of 200ms:</p>

            <picture>
                <source type="image/avif" srcset="/content/articles/why-is-my-rust-build-so-slow/assets/debug-build-perfetto2.f183ad440f9bbdf7.avif"/>
                <source type="image/webp" srcset="/content/articles/why-is-my-rust-build-so-slow/assets/debug-build-perfetto2.85ddeafd186b5321.webp"/>
                <img loading="lazy" src="https://scattered-thoughts.net/content/articles/why-is-my-rust-build-so-slow/assets/debug-build-perfetto2.9236f1f96e037ab2.jpg"/>
            </picture>
            
<p>Okay, so, still spending most of our time in codegen and LLVM.</p>
<p>The new iteration time to beat is still 3s.</p>
<p>The <code>dev</code> cargo profile defaults to <code>debug = true</code>, which is to say, <code>debug = 2</code>.
Can we do better if we set it to <code>1</code>?</p>
<ul>
<li>Cold <code>debug = 1</code> build: 33.86s (vs 36.44s <code>debug = 2</code>)</li>
<li>Hot <code>debug = 1</code> build: 3.03s (vs 3.05s <code>debug = 2</code>)</li>
</ul>
<p>Not a huge difference.</p>
<p>Okay well... is linking only taking ~961ms like it says it does?</p>
<p>Let&#39;s try GNU ld, which should be worse. (I just commented out the relevant
section of my <code>.cargo/config.toml</code>):</p>
<ul>
<li>Cold &#34;GNU ld&#34; build: 41.50s (vs 36.44s &#34;LLVM lld&#34;)</li>
<li>Hot &#34;GNU ld&#34; build: 7.77s (vs 3.05s &#34;LLVM lld&#34;)</li>
</ul>
<p>Okay, lld definitely doing a bunch of work for us here. How about <code>mold</code>?</p>
<pre><p>Shell session</p><p><code>$ cargo clean
$ mold -run cargo build
(cut)
</code></p></pre>
<ul>
<li>Cold &#34;mold&#34; build: 37.18s (vs 36.44s &#34;LLVM lld&#34;)</li>
<li>Hot &#34;mold&#34; build: 2.96s (vs 3.05s &#34;LLVM lld&#34;)</li>
</ul>
<p>No significant difference here, there probably would be a difference if the
linker was doing more work, but it seems lld is already doing great.</p>
<p>What if we disabled LTO entirely? Even thin-local LTO?</p>
<pre><p>TOML markup</p><p><code><i># in `futile/Cargo.toml`</i>

<i>[</i><i>profile</i><i>.</i><i>dev</i><i>]</i>
<i>lto</i> <i>=</i> <i>&#34;off&#34;</i>
</code></p></pre>
<ul>
<li>Cold &#34;lto = off&#34; build: 35.96s (vs 36.44s &#34;thin-local LTO&#34;)</li>
<li>Hot &#34;lto = off&#34; build: 3.16s (vs 3.05s &#34;thin-local LTO&#34;)</li>
</ul>
<p>No significant difference here.</p>
<p>What else can we do? We&#39;ve talked about splitting the bin crate into multiple
crates, and it being a lot of work... but here&#39;s a split that&#39;s easy to do:
we turn it into a <code>lib</code> crate and add a <code>bin</code> to it.</p>
<p>The <code>bin</code> part will simply be in charge of setting up error handling, tracing,
and parsing command-line arguments, and it&#39;ll rely on the <code>lib</code> part for any
actual work.</p>
<p>I won&#39;t go into too many details here, but the basic idea is to rename
<code>src/main.rs</code> to <code>src/lib.rs</code>, then create <code>src/bin/futile.rs</code>, and move some
code from the former to the latter.</p>
<p>Also, to add this to the <code>Cargo.toml</code> file:</p>
<pre><p>TOML markup</p><p><code><i>[[</i><i>bin</i><i>]]</i>
<i>name</i> <i>=</i> <i>&#34;futile&#34;</i>
<i>path</i> <i>=</i> <i>&#34;src/bin/futile.rs&#34;</i>
</code></p></pre>
<p>And now, well, it&#39;ll be hard to compare but let&#39;s try anyway:</p>
<ul>
<li>Cold build: 36.26s (vs Cold 36.44s &#34;just-bin&#34;)</li>
<li>Hot &#34;changed bin&#34; build: 2.47s (vs Hot 3.05s &#34;just-bin&#34;)</li>
<li>Hot &#34;changed lib&#34; build: 3.63s (vs Hot 3.05s &#34;just-bin&#34;)</li>
</ul>
<p>Mhh. When we change the lib, it&#39;s blocked on building the lib before
it can build the bin again, which I think explains the longer times.</p>
<p>But when we change the bin, the <em>whole lib</em> doesn&#39;t need to be touched
whatsoever, just linked, which explains the faster times.</p>
<p>And with <code>mold</code>?</p>
<ul>
<li>Cold build: 37.53s (vs 36.26s &#34;LLVM lld&#34;)</li>
<li>Hot &#34;changed bin&#34;: 2.29s (vs 2.47s &#34;LLVM lld&#34;)</li>
<li>Hot &#34;changed lib&#34;: 3.62s (vs 3.63s &#34;LLVM lld&#34;)</li>
</ul>
<p>Again, in this case, <code>mold</code> hardly makes a difference here: I think the linking
is really cobbling together two static libraries (one for the lib, one for the
bin), and a handful of dynamic libraries (libc, libm, etc.), so there&#39;s just not
a lot of work to do.</p>
<h2>Splitting into more crates!</h2>
<p>I gave it a couple hours, and now I have a lot of crates instead of just one!</p>
<pre><p>TOML markup</p><p><code><i># in the top-level `Cargo.toml`</i>

<i>[</i><i>workspace</i><i>]</i>
<i>members</i> <i>=</i> <i>[</i>
	<i>&#34;crates/futile&#34;</i><i>,</i>
	<i>&#34;crates/futile-db&#34;</i><i>,</i>
	<i>&#34;crates/futile-config&#34;</i><i>,</i>
	<i>&#34;crates/futile-templating&#34;</i><i>,</i>
	<i>&#34;crates/futile-backtrace-printer&#34;</i><i>,</i>
	<i>&#34;crates/futile-highlight&#34;</i><i>,</i>
	<i>&#34;crates/futile-content&#34;</i><i>,</i>
	<i>&#34;crates/futile-frontmatter&#34;</i><i>,</i>
	<i>&#34;crates/futile-extract-text&#34;</i><i>,</i>
	<i>&#34;crates/futile-reading-time&#34;</i><i>,</i>
	<i>&#34;crates/futile-parent-path&#34;</i><i>,</i>
	<i>&#34;crates/futile-asset-rewriter&#34;</i><i>,</i>
	<i>&#34;crates/futile-friendcodes&#34;</i><i>,</i>
	<i>&#34;crates/futile-reddit&#34;</i><i>,</i>
	<i>&#34;crates/futile-patreon&#34;</i><i>,</i>
<i>]</i>

<i>[</i><i>profile</i><i>.</i><i>release</i><i>]</i>
<i>debug</i> <i>=</i> 1
</code></p></pre>
<p>It&#39;s not perfect — <code>futile-templating</code> for example, is one of the largest bits:</p>
<pre><p>Shell session</p><p><code>$ for i in crates/*; do echo $i $(tokei $i -o json | jq .Rust.code); done
crates/futile 1472
crates/futile-asset-rewriter 433
crates/futile-backtrace-printer 12
crates/futile-config 158
crates/futile-content 769
crates/futile-db 818
crates/futile-extract-text 26
crates/futile-friendcodes 78
crates/futile-frontmatter 105
crates/futile-highlight 533
crates/futile-parent-path 10
crates/futile-patreon 522
crates/futile-query 14
crates/futile-reading-time 6
crates/futile-reddit 69
crates/futile-templating 1513
</code></p></pre>
<p>And I don&#39;t love how the dependency graph looks:</p>
<p><img src="https://scattered-thoughts.net/content/articles/why-is-my-rust-build-so-slow/assets/depgraph.f9bfac7ab1312653.svg" alt="" loading="lazy"/></p><p>But in my defense, there&#39;s <em>definitely</em> a way to lay that out that&#39;s less
confusing.</p>
<p>Let&#39;s look at build times!</p>
<ul>
<li>Cold build time: 35.28s (vs 37.53s bin+lib crate)</li>
<li>Hot build time (changed futile-extract-text): 4.22s</li>
<li>Hot build time (changed futile-content): 3.97s</li>
<li>Hot build time (changed futile-templating): 3.74s</li>
<li>Hot build time (changed bin): 2.70s</li>
</ul>
<p>Well. At least with incremental builds, this didn&#39;t change much.</p>
<p>Let&#39;s try release builds again maybe?</p>
<ul>
<li>Cold release build time: 1m03s (vs 1m06s)</li>
<li>Hot release build time (changed futile-extract-text): 12s (vs 14s)</li>
<li>Hot release build time (changed futile-content): 11.87s (vs 14s)</li>
<li>Hot release build time (changed futile-templating): 11.94s (vs 14s)</li>
<li>Hot release build time (changed bin): 8s (vs 14s)</li>
</ul>
<p>That&#39;s interesting! Does linking dominate those times? I wonder. Let&#39;s try
with <code>mold</code> again, since there&#39;s probably more linking work to be done there.</p>
<ul>
<li>Cold release mold: 1m04s (vs 1m06s)</li>
<li>Hot release mold (futile-extract-text): 12s (vs 14s)</li>
<li>Hot release mold (futile-content): 10.23s (vs 14s)</li>
<li>Hot release mold (futile-templating): 11.84s (vs 14s)</li>
<li>Hot release mold (bin): 8.10s (vs 14s)</li>
</ul>
<p>Not super different from <code>lld</code>: again, I guess we don&#39;t have a lot of linking to
do.</p>
<p>Let&#39;s look again at a rustc profile:</p>

            <picture>
                <source type="image/avif" srcset="/content/articles/why-is-my-rust-build-so-slow/assets/final-perfetto.37945ff69a87c908.avif"/>
                <source type="image/webp" srcset="/content/articles/why-is-my-rust-build-so-slow/assets/final-perfetto.58cff41262d936fd.webp"/>
                <img loading="lazy" src="https://scattered-thoughts.net/content/articles/why-is-my-rust-build-so-slow/assets/final-perfetto.a71e1eaf425d428c.jpg"/>
            </picture>
            
<p>Mh! It seems we&#39;re spending a bunch of time &#34;monomorphizing&#34;, which is when we
turn something like:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>add</i><i>&lt;</i><i>T</i><i>&gt;</i><i>(</i><i>a</i>: <i>T</i>, <i>b</i>: <i>T</i><i>)</i> -&gt; <i>T</i>
<i>where</i>
    <i>T</i>: <i>Add</i>,
{
    a + b
}
</code></p></pre>
<p>Into this:</p>
<pre><p>Rust code</p><p><code><i>fn</i> <i>add_usize</i><i>(</i><i>a</i>: <i>usize</i>, <i>b</i>: <i>usize</i><i>)</i> -&gt; <i>usize</i> {
    a + b
}
</code></p></pre>
<p>Except with much bigger types. And many of these.</p>
<p>I&#39;ll leave you with a last tip: another factor in build time is the sheer amount
of LLVM IR being generated, and you can easily look at that with
<a href="https://lib.rs/crates/cargo-llvm-lines">cargo-llvm-lines</a>.</p>
<p>For best results, we&#39;ll want to pass a couple other flags.
<code>-Zsymbol-mangling-version=v0</code> enables a <a href="https://rust-lang.github.io/rfcs/2603-rust-symbol-name-mangling-v0.html">new mangling
scheme</a>
which should be the default soon, and <code>-Z build-std</code> instructs cargo to build
libstd from source, instead of using the prebuilt version that comes with our
rust distribution.</p>
<p>Let&#39;s try it out!</p>
<pre><p>Shell session</p><p><code>$ cd crates/futile
$ RUSTFLAGS=-Zsymbol-mangling-version=v0 cargo -Z build-std llvm-lines --bin futile | head -20
   Compiling futile v1.9.0 (/home/amos/bearcove/futile/crates/futile)
warning: `futile` (bin &#34;futile&#34;) generated 2 warnings
    Finished dev [unoptimized + debuginfo] target(s) in 6.30s
  Lines          Copies       Function name
  -----          ------       -------------
  304016 (100%)  6746 (100%)  (TOTAL)
    2665 (0.9%)     1 (0.0%)  futile[507d45e82218702e]::serve::routes::revision_routes::serve_single::{closure#0}
    2462 (0.8%)     1 (0.0%)  &lt;futile[507d45e82218702e]::serve::Context&gt;::serve_template::{closure#0}
    2222 (0.7%)     1 (0.0%)  &lt;hyper[cbe7455c31603e19]::proto::h2::server::Serving&lt;hyper[cbe7455c31603e19]::common::io::rewind::Rewind&lt;hyper[cbe7455c31603e19]::server::tcp::addr_stream::AddrStream&gt;, hyper[cbe7455c31603e19]::body::body::Body&gt;&gt;::poll_server::&lt;hyper[cbe7455c31603e19]::service::util::ServiceFn&lt;&lt;warp[d2eac20ce511edd0]::server::Server&lt;warp[d2eac20ce511edd0]::filters::log::internal::WithLog&lt;warp[d2eac20ce511edd0]::filters::log::log::{closure#0}, warp[d2eac20ce511edd0]::filter::or::Or&lt;warp[d2eac20ce511edd0]::filter::or::Or&lt;warp[d2eac20ce511edd0]::filter::or::Or&lt;warp[d2eac20ce511edd0]::filter::boxed::BoxedFilter&lt;(warp[d2eac20ce511edd0]::filters::sse::SseReply&lt;warp[d2eac20ce511edd0]::filters::sse::SseKeepAlive&lt;futures_util[db872dedfe3ac01e]::stream::stream::chain::Chain&lt;futures_util[db872dedfe3ac01e]::stream::iter::Iter&lt;alloc[f5d0236c37905b20]::vec::into_iter::IntoIter&lt;core[49c27447ffaf9e48]::result::Result&lt;warp[d2eac20ce511edd0]::filters::sse::Event, core[49c27447ffaf9e48]::convert::Infallible&gt;&gt;&gt;, futures_util[db872dedfe3ac01e]::stream::stream::filter_map::FilterMap&lt;tokio_stream[b4aa1729856eb832]::wrappers::broadcast::BroadcastStream&lt;alloc[f5d0236c37905b20]::string::String&gt;, core[49c27447ffaf9e48]::future::from_generator::GenFuture&lt;futile[507d45e82218702e]::serve::serve::{closure#0}::sse_events::{closure#0}::{closure#0}&gt;, futile[507d45e82218702e]::serve::serve::{closure#0}::sse_events::{closure#0}&gt;&gt;&gt;&gt;,)&gt;, warp[d2eac20ce511edd0]::filter::boxed::BoxedFilter&lt;(alloc[f5d0236c37905b20]::boxed::Box&lt;dyn warp[d2eac20ce511edd0]::reply::Reply&gt;,)&gt;&gt;, warp[d2eac20ce511edd0]::filter::boxed::BoxedFilter&lt;(alloc[f5d0236c37905b20]::boxed::Box&lt;dyn warp[d2eac20ce511edd0]::reply::Reply&gt;,)&gt;&gt;, warp[d2eac20ce511edd0]::filter::boxed::BoxedFilter&lt;(alloc[f5d0236c37905b20]::boxed::Box&lt;dyn warp[d2eac20ce511edd0]::reply::Reply&gt;,)&gt;&gt;&gt;&gt;&gt;::bind_ephemeral&lt;std[5c4e0e91f40690d7]::net::addr::SocketAddr&gt;::{closure#1}::{closure#0}::{closure#0}, hyper[cbe7455c31603e19]::body::body::Body&gt;, hyper[cbe7455c31603e19]::common::exec::Exec&gt;
    2218 (0.7%)     1 (0.0%)  &lt;hyper[cbe7455c31603e19]::proto::h2::server::H2Stream&lt;warp[d2eac20ce511edd0]::filter::service::FilteredFuture&lt;warp[d2eac20ce511edd0]::filters::log::internal::WithLogFuture&lt;warp[d2eac20ce511edd0]::filters::log::log::{closure#0}, warp[d2eac20ce511edd0]::filter::or::EitherFuture&lt;warp[d2eac20ce511edd0]::filter::or::Or&lt;warp[d2eac20ce511edd0]::filter::or::Or&lt;warp[d2eac20ce511edd0]::filter::boxed::BoxedFilter&lt;(warp[d2eac20ce511edd0]::filters::sse::SseReply&lt;warp[d2eac20ce511edd0]::filters::sse::SseKeepAlive&lt;futures_util[db872dedfe3ac01e]::stream::stream::chain::Chain&lt;futures_util[db872dedfe3ac01e]::stream::iter::Iter&lt;alloc[f5d0236c37905b20]::vec::into_iter::IntoIter&lt;core[49c27447ffaf9e48]::result::Result&lt;warp[d2eac20ce511edd0]::filters::sse::Event, core[49c27447ffaf9e48]::convert::Infallible&gt;&gt;&gt;, futures_util[db872dedfe3ac01e]::stream::stream::filter_map::FilterMap&lt;tokio_stream[b4aa1729856eb832]::wrappers::broadcast::BroadcastStream&lt;alloc[f5d0236c37905b20]::string::String&gt;, core[49c27447ffaf9e48]::future::from_generator::GenFuture&lt;futile[507d45e82218702e]::serve::serve::{closure#0}::sse_events::{closure#0}::{closure#0}&gt;, futile[507d45e82218702e]::serve::serve::{closure#0}::sse_events::{closure#0}&gt;&gt;&gt;&gt;,)&gt;, warp[d2eac20ce511edd0]::filter::boxed::BoxedFilter&lt;(alloc[f5d0236c37905b20]::boxed::Box&lt;dyn warp[d2eac20ce511edd0]::reply::Reply&gt;,)&gt;&gt;, warp[d2eac20ce511edd0]::filter::boxed::BoxedFilter&lt;(alloc[f5d0236c37905b20]::boxed::Box&lt;dyn warp[d2eac20ce511edd0]::reply::Reply&gt;,)&gt;&gt;, warp[d2eac20ce511edd0]::filter::boxed::BoxedFilter&lt;(alloc[f5d0236c37905b20]::boxed::Box&lt;dyn warp[d2eac20ce511edd0]::reply::Reply&gt;,)&gt;&gt;&gt;&gt;, hyper[cbe7455c31603e19]::body::body::Body&gt;&gt;::poll2
    2191 (0.7%)     1 (0.0%)  futile[507d45e82218702e]::serve::serve::{closure#0}
    2080 (0.7%)     1 (0.0%)  &lt;futile_patreon[a3d798751567a674]::FutileCredentials&gt;::load_from_cookies::{closure#0}
    1871 (0.6%)     1 (0.0%)  &lt;futile_patreon[a3d798751567a674]::PatreonCredentials&gt;::to_futile_credentials_once::{closure#0}
    1579 (0.5%)     1 (0.0%)  futile[507d45e82218702e]::serve::routes::revision_routes::serve::{closure#0}
    1494 (0.5%)     1 (0.0%)  futile[507d45e82218702e]::serve::routes::login::serve_patreon_oauth::{closure#0}
    1438 (0.5%)     1 (0.0%)  &lt;hyper[cbe7455c31603e19]::proto::h2::PipeToSendStream&lt;hyper[cbe7455c31603e19]::body::body::Body&gt; as core[49c27447ffaf9e48]::future::future::Future&gt;::poll
    1387 (0.5%)    94 (1.4%)  warp::server::Server&lt;warp::filters::log::internal::WithLog&lt;[closure@warp::filters::log::log::{closure#0}], warp::filter::or::Or&lt;warp::filter::or::Or&lt;warp::filter::or::Or&lt;warp::filter::boxed::BoxedFilter&lt;
    1329 (0.4%)     1 (0.0%)  futile[507d45e82218702e]::serve::routes::serve_get::{closure#0}
    1311 (0.4%)     1 (0.0%)  &lt;hyper[cbe7455c31603e19]::proto::h1::dispatch::Dispatcher&lt;hyper[cbe7455c31603e19]::proto::h1::dispatch::Server&lt;hyper[cbe7455c31603e19]::service::util::ServiceFn&lt;&lt;warp[d2eac20ce511edd0]::server::Server&lt;warp[d2eac20ce511edd0]::filters::log::internal::WithLog&lt;warp[d2eac20ce511edd0]::filters::log::log::{closure#0}, warp[d2eac20ce511edd0]::filter::or::Or&lt;warp[d2eac20ce511edd0]::filter::or::Or&lt;warp[d2eac20ce511edd0]::filter::or::Or&lt;warp[d2eac20ce511edd0]::filter::boxed::BoxedFilter&lt;(warp[d2eac20ce511edd0]::filters::sse::SseReply&lt;warp[d2eac20ce511edd0]::filters::sse::SseKeepAlive&lt;futures_util[db872dedfe3ac01e]::stream::stream::chain::Chain&lt;futures_util[db872dedfe3ac01e]::stream::iter::Iter&lt;alloc[f5d0236c37905b20]::vec::into_iter::IntoIter&lt;core[49c27447ffaf9e48]::result::Result&lt;warp[d2eac20ce511edd0]::filters::sse::Event, core[49c27447ffaf9e48]::convert::Infallible&gt;&gt;&gt;, futures_util[db872dedfe3ac01e]::stream::stream::filter_map::FilterMap&lt;tokio_stream[b4aa1729856eb832]::wrappers::broadcast::BroadcastStream&lt;alloc[f5d0236c37905b20]::string::String&gt;, core[49c27447ffaf9e48]::future::from_generator::GenFuture&lt;futile[507d45e82218702e]::serve::serve::{closure#0}::sse_events::{closure#0}::{closure#0}&gt;, futile[507d45e82218702e]::serve::serve::{closure#0}::sse_events::{closure#0}&gt;&gt;&gt;&gt;,)&gt;, warp[d2eac20ce511edd0]::filter::boxed::BoxedFilter&lt;(alloc[f5d0236c37905b20]::boxed::Box&lt;dyn warp[d2eac20ce511edd0]::reply::Reply&gt;,)&gt;&gt;, warp[d2eac20ce511edd0]::filter::boxed::BoxedFilter&lt;(alloc[f5d0236c37905b20]::boxed::Box&lt;dyn warp[d2eac20ce511edd0]::reply::Reply&gt;,)&gt;&gt;, warp[d2eac20ce511edd0]::filter::boxed::BoxedFilter&lt;(alloc[f5d0236c37905b20]::boxed::Box&lt;dyn warp[d2eac20ce511edd0]::reply::Reply&gt;,)&gt;&gt;&gt;&gt;&gt;::bind_ephemeral&lt;std[5c4e0e91f40690d7]::net::addr::SocketAddr&gt;::{closure#1}::{closure#0}::{closure#0}, hyper[cbe7455c31603e19]::body::body::Body&gt;, hyper[cbe7455c31603e19]::body::body::Body&gt;, hyper[cbe7455c31603e19]::body::body::Body, hyper[cbe7455c31603e19]::server::tcp::addr_stream::AddrStream, hyper[cbe7455c31603e19]::proto::h1::role::Server&gt;&gt;::poll_write
    1252 (0.4%)    72 (1.1%)  warp::filters::log::log::{closure#0}], warp::filter::or::EitherFuture&lt;warp::filter::or::Or&lt;warp::filter::or::Or&lt;warp::filter::boxed::BoxedFilter&lt;
    1249 (0.4%)     1 (0.0%)  &lt;color_backtrace[f3bfce8006cb17f7]::Frame&gt;::print::&lt;futile[507d45e82218702e]::serve::html_color_output::HtmlColorOutput&gt;
    1249 (0.4%)     1 (0.0%)  &lt;color_backtrace[f3bfce8006cb17f7]::Frame&gt;::print::&lt;termcolor[ed53d2579171698e]::StandardStream&gt;
    1228 (0.4%)     1 (0.0%)  &lt;hyper[cbe7455c31603e19]::proto::h1::io::Buffered&lt;hyper[cbe7455c31603e19]::server::tcp::addr_stream::AddrStream, hyper[cbe7455c31603e19]::proto::h1::encode::EncodedBuf&lt;bytes[65b0fce232ff3b0d]::bytes::Bytes&gt;&gt;&gt;::parse::&lt;hyper[cbe7455c31603e19]::proto::h1::role::Server&gt;
</code></p></pre>
<p>What to do with those results? Well, nothing looks out of the ordinary here. If
a single symbol was responsible for say, &gt;10% of LLVM lines (left column), we&#39;d
definitely want to take a closer look at it. But from the looks of this, we&#39;re
fine.</p>
<h2>Conclusion</h2>
<p>I hope you had fun learning about all this, and that you can use it to make your
builds faster. If you didn&#39;t before, you should now have a lot of places to look
at when you want to make your builds faster. </p>
<p>You can go deeper than this still! I mentioned in <a href="https://www.youtube.com/watch?v=7_DExGdUw7w">How I learned to love build
systems</a> that some companies don&#39;t
even use <code>cargo</code> to build their Rust code, and I&#39;ve recently been experimenting
with that myself — and it&#39;s quite usable, even when you&#39;re not a megacorp.</p>
<p>Let me know if you&#39;d like to read more about this: I realized that I&#39;ve
accidentally acquired some expertise in release engineering, so now I&#39;m bound
to get more questions about this.</p>
<p>Until next time, take care!</p>

</div><div>
  
    
    
      <p>
    This article was made possible thanks to my patrons:
    Alexander Payne, Fredrik Østrem, David Barsky, Yufan Lou, Stephen Molyneaux,
Barret Rennie, Thomas Corbin, MW, Jacob Cheriathundam, Michael Watzko, Embark
Studios, Eugene Bulkin, Marcus Griep, Petar Radosevic, Tool Army, Tully,
Santiago Lema, Spencer Gilbert, Jörn Huxhorn, Garrett Ward, DEX, Christian
Oudard, Ronen Cohen, Thor Kamphefner, Kamran Khan, Cole Kurkowski, Arjen
Laarhoven, Vicente Bosch, Chirag Jain, Ville Mattila, Marie Janssen, Vladyslav
Batyrenko, Cameron Clausen, spike grobstein, Jon Gjengset, Paul Marques Mota,
Jakub Fijałkowski, Mitchell Hamilton, Brad Luyster, Max von Forell, Jake S,
Dimitri Merejkowsky, Chris Biscardi, René Ribaud, Alex Doroshenko, Vincent,
Steven McGuire, Chad Birch, Chris Emery, Bob Ippolito, John Van Enk, metabaron,
Isak Sunde Singh, Philipp Gniewosz, Mads Johansen, lukvol, Ives van Hoorne, Jan
De Landtsheer, Daniel Strittmatter, Evgeniy Dubovskoy, Alex Rudy, Shane Lillie,
Romet Tagobert, Douglas Creager, Corey Alexander, Molly Howell, knutwalker,
Zachary Dremann, Sebastian Ziebell, Julien Roncaglia, Amber Kowalski, T,
queenfartbutt, Paul Kline, Kristoffer Ström, Astrid Bek, Yoh Deadfall, Justin
Ossevoort, Tomáš Duda, Jeremy Banks, Rasmus Larsen, Torben Clasen, C J Silverio,
Walther, Pete Bevin, Shane Sveller, Clara Schultz, jer, Wonwoo Choi, Hawken
Rives, João Veiga, Richard Pringle, Adam Perry, Benjamin Röjder Delnavaz, Matt
Jadczak, Jonathan Knapp, Maximilian, Seth Stadick, brianloveswords, Sean Bryant,
Ember, Sebastian Zimmer, Makoto Nakashima, Geoff Cant, Geoffroy Couprie, Michael
Alyn Miller, o0Ignition0o, Zaki, Raphael Gaschignard, Romain Ruetschi, Ignacio
Vergara, Pascal, Jane Lusby, Nicolas Goy, Ted Mielczarek, Aurora.

</p>
    
  

  

  

  <div>
  
    <p>If you liked this article, please support my work on Patreon!</p>
    <p>
      <a href="https://www.patreon.com/bePatron?u=47556">
        <img src="https://scattered-thoughts.net/img/patreon/mark-white.png"/>
        <span>Become a Patron</span>
      </a>
    </p>
  
</div>


  

  
</div></div>
  </body>
</html>
