<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/c0stya/trre">Original</a>
    <h1>Show HN: Transductive regular expressions for text editing</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<div dir="auto"><h4 tabindex="-1" dir="auto">TLDR: It is an extension of the regular expressions for text editing and a <code>grep</code>-like command line tool.</h4><a id="user-content-tldr-it-is-an-extension-of-the-regular-expressions-for-text-editing-and-a-grep-like-command-line-tool" aria-label="Permalink: TLDR: It is an extension of the regular expressions for text editing and a grep-like command line tool." href="#tldr-it-is-an-extension-of-the-regular-expressions-for-text-editing-and-a-grep-like-command-line-tool"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div dir="auto"><h4 tabindex="-1" dir="auto">It is a PROTOTYPE. Do not use in production.</h4><a id="user-content-it-is-a-prototype-do-not-use-in-production" aria-label="Permalink: It is a PROTOTYPE. Do not use in production." href="#it-is-a-prototype-do-not-use-in-production"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>

<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/c0stya/trre/blob/main/docs/automata.png"><img src="https://github.com/c0stya/trre/raw/main/docs/automata.png" alt="automata"/></a></p>
<p dir="auto">Regular expressions is a great tool for searching patterns in text. But I always found it unnatural for text editing. The <em>group</em> logic works as a post-processor and can be complicated. Here I propose an extension to the regular expression language for pattern matching and text modification. I call it <strong>transductive regular expressions</strong> or simply <strong><code>trre</code></strong>.</p>
<p dir="auto">It  introduces the <code>:</code> symbol to define transformations. The simplest form is <code>a:b</code>, which replaces a with b. I call this a <code>transductive pair</code> or <code>transduction</code>.</p>
<p dir="auto">To demonstrate the concept, I have created a command line tool <strong><code>trre</code></strong>. It feels similar to the <code>grep -E</code> command.</p>


<p dir="auto">To change <code>cat</code> to <code>dog</code> we use the following expression:</p>
<div dir="auto" data-snippet-clipboard-copy-content="$ echo &#39;cat&#39; | trre &#39;c:da:ot:g&#39;

dog"><pre>$ <span>echo</span> <span><span>&#39;</span>cat<span>&#39;</span></span> <span>|</span> trre <span><span>&#39;</span>c:da:ot:g<span>&#39;</span></span>

dog</pre></div>
<p dir="auto">A more readable version:</p>
<div dir="auto" data-snippet-clipboard-copy-content="$ echo &#39;cat&#39; | trre &#39;(cat):(dog)&#39;

dog"><pre>$ <span>echo</span> <span><span>&#39;</span>cat<span>&#39;</span></span> <span>|</span> trre <span><span>&#39;</span>(cat):(dog)<span>&#39;</span></span>

dog</pre></div>
<p dir="auto">It can be used like <code>sed</code> to replace all matches in a string:</p>
<div dir="auto" data-snippet-clipboard-copy-content="$ echo &#39;Mary had a little lamb.&#39; | trre &#39;(lamb):(cat)&#39;

Mary had a little cat."><pre>$ <span>echo</span> <span><span>&#39;</span>Mary had a little lamb.<span>&#39;</span></span> <span>|</span> trre <span><span>&#39;</span>(lamb):(cat)<span>&#39;</span></span>

Mary had a little cat.</pre></div>
<p dir="auto"><strong>Deletion:</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="$ echo &#39;xor&#39; | trre &#39;(x:)or&#39;

or"><pre>$ <span>echo</span> <span><span>&#39;</span>xor<span>&#39;</span></span> <span>|</span> trre <span><span>&#39;</span>(x:)or<span>&#39;</span></span>

or</pre></div>
<p dir="auto">The expression <code>(x:)</code> could be interpreted as of translation of <code>x</code> to an empty string.</p>
<p dir="auto"><strong>Insertion:</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="$ echo &#39;or&#39; | trre &#39;(:x)or&#39;

xor"><pre>$ <span>echo</span> <span><span>&#39;</span>or<span>&#39;</span></span> <span>|</span> trre <span><span>&#39;</span>(:x)or<span>&#39;</span></span>

xor</pre></div>
<p dir="auto">We could think of the expression <code>(:x)</code> as of translation of an empty string into <code>x</code>.</p>

<p dir="auto">As for normal regular expression we could use <strong>alternations</strong> with <code>|</code> symbol:</p>
<div dir="auto" data-snippet-clipboard-copy-content="$ echo &#39;cat dog&#39; | trre &#39;c:bat|d:hog&#39;

bat hog"><pre>$ <span>echo</span> <span><span>&#39;</span>cat dog<span>&#39;</span></span> <span>|</span> trre <span><span>&#39;</span>c:bat|d:hog<span>&#39;</span></span>

bat hog</pre></div>
<p dir="auto">Or use the <strong>star</strong> over <code>trre</code> to repeat the transformation:</p>
<div dir="auto" data-snippet-clipboard-copy-content="$ echo &#39;catcatcat&#39; | trre &#39;((cat):(dog))*&#39;

dogdogdog"><pre>$ <span>echo</span> <span><span>&#39;</span>catcatcat<span>&#39;</span></span> <span>|</span> trre <span><span>&#39;</span>((cat):(dog))*<span>&#39;</span></span>

dogdogdog</pre></div>
<p dir="auto">In the default <code>scan</code> mode, <strong>star</strong> can be omitted:</p>
<div dir="auto" data-snippet-clipboard-copy-content="$ echo &#39;catcatcat&#39; | trre &#39;(cat):(dog)&#39;

dogdogdog"><pre>$ <span>echo</span> <span><span>&#39;</span>catcatcat<span>&#39;</span></span> <span>|</span> trre <span><span>&#39;</span>(cat):(dog)<span>&#39;</span></span>

dogdogdog</pre></div>
<p dir="auto">You can also use the star in the left part to &#34;consume&#34; a pattern infinitely:</p>
<div dir="auto" data-snippet-clipboard-copy-content="$ echo &#39;catcatcat&#39; | trre &#39;(cat)*:(dog)&#39;

dog"><pre>$ <span>echo</span> <span><span>&#39;</span>catcatcat<span>&#39;</span></span> <span>|</span> trre <span><span>&#39;</span>(cat)*:(dog)<span>&#39;</span></span>

dog</pre></div>

<p dir="auto">Avoid using <code>*</code> or <code>+</code> in the right part, as it can cause infinite loops:</p>
<div dir="auto" data-snippet-clipboard-copy-content="$ echo &#39;&#39; | trre &#39;:a*&#39;      # &lt;- do NOT do this

..."><pre>$ <span>echo</span> <span><span>&#39;</span><span>&#39;</span></span> <span>|</span> trre <span><span>&#39;</span>:a*<span>&#39;</span></span>      <span><span>#</span> &lt;- do NOT do this</span>

...</pre></div>
<p dir="auto">Instead, use finite iterations:</p>
<div dir="auto" data-snippet-clipboard-copy-content="$ echo &#39;&#39; | trre &#39;:(repeat-10-times){10}&#39;

repeat-10-timesrepeat-10-timesrepeat-10-timesrepeat-10-timesrepeat-10-timesrepeat-10-timesrepeat-10-timesrepeat-10-timesrepeat-10-timesrepeat-10-times"><pre>$ <span>echo</span> <span><span>&#39;</span><span>&#39;</span></span> <span>|</span> trre <span><span>&#39;</span>:(repeat-10-times){10}<span>&#39;</span></span>

repeat-10-timesrepeat-10-timesrepeat-10-timesrepeat-10-timesrepeat-10-timesrepeat-10-timesrepeat-10-timesrepeat-10-timesrepeat-10-timesrepeat-10-times</pre></div>

<p dir="auto">Transform ranges of characters:</p>
<div dir="auto" data-snippet-clipboard-copy-content="$ echo &#34;regular expressions&#34; | trre  &#34;[a:A-z:Z]&#34;

REGULAR EXPRESSIONS"><pre>$ <span>echo</span> <span><span>&#34;</span>regular expressions<span>&#34;</span></span> <span>|</span> trre  <span><span>&#34;</span>[a:A-z:Z]<span>&#34;</span></span>

REGULAR EXPRESSIONS</pre></div>
<p dir="auto">As more complex example, lets create a toy cipher. Below is the Caesar cipher(1) implementation:</p>
<div dir="auto" data-snippet-clipboard-copy-content="$ echo &#39;caesar cipher&#39; | trre &#39;[a:b-y:zz:a]&#39;

dbftbs djqifs"><pre>$ <span>echo</span> <span><span>&#39;</span>caesar cipher<span>&#39;</span></span> <span>|</span> trre <span><span>&#39;</span>[a:b-y:zz:a]<span>&#39;</span></span>

dbftbs djqifs</pre></div>
<p dir="auto">And decrypt it back:</p>
<div dir="auto" data-snippet-clipboard-copy-content="$ echo &#39;dbftbs djqifs&#39; | trre &#39;[a:zb:a-y:x]&#39;

caesar cipher"><pre>$ <span>echo</span> <span><span>&#39;</span>dbftbs djqifs<span>&#39;</span></span> <span>|</span> trre <span><span>&#39;</span>[a:zb:a-y:x]<span>&#39;</span></span>

caesar cipher</pre></div>

<p dir="auto"><strong><code>trre</code></strong> can generate multiple output strings for a single input. By default, it uses the first possible match. You can also generate all possible outputs.</p>
<p dir="auto"><strong>Binary sequences:</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="$ echo &#39;&#39; | trre -ma &#39;:(0|1){3}&#39;

000
001
010
011
100
101
110
111"><pre>$ <span>echo</span> <span><span>&#39;</span><span>&#39;</span></span> <span>|</span> trre -ma <span><span>&#39;</span>:(0|1){3}<span>&#39;</span></span>

000
001
010
011
100
101
110
111</pre></div>
<p dir="auto"><strong>Subsets:</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="$ echo &#39;&#39; | trre -ma &#39;:(0|1){,3}?&#39;


0
00
000
001
01
010
011
1
10
100
101
11
110
111"><pre>$ <span>echo</span> <span><span>&#39;</span><span>&#39;</span></span> <span>|</span> trre -ma <span><span>&#39;</span>:(0|1){,3}?<span>&#39;</span></span>


0
00
000
001
01
010
011
1
10
100
101
11
110
111</pre></div>

<p dir="auto">Informally, we define a <strong><code>trre</code></strong> as a pair <code>pattern-to-match</code>:<code>pattern-to-generate</code>. The <code>pattern-to-match</code> can be a string or regexp. The <code>pattern-to-generate</code> normally is a string. But it can be a <code>regex</code> as well. Moreover, we can do normal regular expression over these pairs.</p>
<p dir="auto">We can specify a smiplified grammar of <strong><code>trre</code></strong> as following:</p>
<div data-snippet-clipboard-copy-content="TRRE    &lt;- TRRE* TRRE|TRRE TRRE.TRRE
TRRE    &lt;- REGEX REGEX:REGEX"><pre><code>TRRE    &lt;- TRRE* TRRE|TRRE TRRE.TRRE
TRRE    &lt;- REGEX REGEX:REGEX
</code></pre></div>
<p dir="auto">Where <code>REGEX</code> is a usual regular expression, and <code>.</code> stands for concatenation.</p>
<p dir="auto">For now I consider the operator <code>:</code> as non-associative and the expression <code>TRRE:TRRE</code> as unsyntactical. There is a natural meaning for this expression as a composition of relations defined by **<code>trre</code>**s. But it can make things too complex. Maybe I change this later.</p>

<p dir="auto">Under the hood, <strong><code>trre</code></strong> constructs a special automaton called a <strong>Finite State Transducer (FST)</strong>, which is similar to a <strong>Finite State Automaton (FSA)</strong> used in normal regular expressions but handles input-output pairs instead of plain strings.</p>
<p dir="auto">Key differences:</p>
<ul dir="auto">
<li>
<p dir="auto"><strong><code>trre</code></strong> defines a binary relation between two regular languages.</p>
</li>
<li>
<p dir="auto">It uses <strong>FST</strong>s instead of <strong>FSA</strong>s for inference.</p>
</li>
<li>
<p dir="auto">It supports on-the-fly determinization for performance (experimental and under construction!).</p>
</li>
</ul>
<p dir="auto">To justify the laguage of trunsductive regular expression we need to prove the correspondence between <strong><code>trre</code></strong> expressions and the corresponding <strong>FST</strong>s. There is my sketch of a the proof: <a href="https://github.com/c0stya/trre/blob/main/doc/theory.pdf">theory.pdf</a>.</p>
<div dir="auto"><h2 tabindex="-1" dir="auto">Design choices and open questions</h2><a id="user-content-design-choices-and-open-questions" aria-label="Permalink: Design choices and open questions" href="#design-choices-and-open-questions"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">There are tons of decisions:</p>
<ul dir="auto">
<li>
<p dir="auto">Associativity of <code>:</code>. The <code>:</code> symbol is non-associative, meaning a:b:c is invalid in the current version. There is a natural meaning of transducer composition but it could make things too complicated. Alternative syntaxes (e.g., &gt; and &lt;) could be explored.</p>
</li>
<li>
<p dir="auto">Precedence of <code>:</code>. The priority of : in expressions needs clarification.</p>
</li>
<li>
<p dir="auto">Implicit Epsilon: should there be an explicit symbol?</p>
</li>
</ul>

<p dir="auto"><strong><code>trre</code></strong> supports two modes:</p>
<ul dir="auto">
<li>
<p dir="auto"><strong>Scan Mode (default)</strong>: Applies transformations sequentially.</p>
</li>
<li>
<p dir="auto"><strong>Match Mode</strong>: Checks the entire string against the expression (use <code>-m</code> flag).</p>
</li>
</ul>
<p dir="auto">Use <code>-a</code> to generate all possible outputs.</p>
<p dir="auto">The <code>?</code> modifier makes <code>*</code>, <code>+</code>, and <code>{,}</code> operators non-greedy:</p>
<div dir="auto" data-snippet-clipboard-copy-content="$ echo &#39;&lt;cat&gt;&lt;dog&gt;&#39; | trre &#39;&lt;(.:)*&gt;&#39;

&lt;&gt;

$ echo &#39;&lt;cat&gt;&lt;dog&gt;&#39; | trre &#39;&lt;(.:)*?&gt;&#39;

&lt;&gt;&lt;&gt;"><pre>$ <span>echo</span> <span><span>&#39;</span>&lt;cat&gt;&lt;dog&gt;<span>&#39;</span></span> <span>|</span> trre <span><span>&#39;</span>&lt;(.:)*&gt;<span>&#39;</span></span>

<span>&lt;&gt;</span>

$ <span>echo</span> <span><span>&#39;</span>&lt;cat&gt;&lt;dog&gt;<span>&#39;</span></span> <span>|</span> trre <span><span>&#39;</span>&lt;(.:)*?&gt;<span>&#39;</span></span>

&lt;&gt;&lt;&gt;</pre></div>

<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/c0stya/trre/blob/main/docs/determinization.png"><img src="https://github.com/c0stya/trre/raw/main/docs/determinization.png" width="80%"/></a></p>
<p dir="auto">The important part of the modern regex engines is determinization. This routine converts the non-deterministic automata to the deterministic one. Once converted it has linear time inference on the input string length. It is handy but the convertion is exponential in the worst case.</p>
<p dir="auto">For <strong><code>trre</code></strong> the similar approach is possible. The bad news is that not all the non-deterministic transducers (<strong>NFT</strong>) can be converted to a deterministic (<strong>DFT</strong>). In case of two &#34;bad&#34; cycles with same input labels the algorithm is trapped in the infinite loop of a state creation. There is a way to detect such loops but it is expensive (see more in <a href="https://cs.nyu.edu/~mohri/pub/twins.pdf" rel="nofollow">Allauzen, Mohri, Efficient Algorithms for testing the twins property</a>).</p>

<p dir="auto">The NFT (non-deterministic) version is a bit slower then <code>sed</code>:</p>
<div dir="auto" data-snippet-clipboard-copy-content="$ wget https://www.gutenberg.org/cache/epub/57333/pg57333.txt -O chekhov.txt

$ time cat chekhov.txt | trre &#39;(vodka):(VODKA)&#39; &gt; /dev/null

real	0m0.046s
user	0m0.043s
sys	0m0.007s

$ time cat chekhov.txt | sed  &#39;s/vodka/VODKA/&#39; &gt; /dev/null

real	0m0.024s
user	0m0.020s
sys	0m0.010s
"><pre>$ wget https://www.gutenberg.org/cache/epub/57333/pg57333.txt -O chekhov.txt

$ <span>time</span> cat chekhov.txt <span>|</span> trre <span><span>&#39;</span>(vodka):(VODKA)<span>&#39;</span></span> <span>&gt;</span> /dev/null

real	0m0.046s
user	0m0.043s
sys	0m0.007s

$ <span>time</span> cat chekhov.txt <span>|</span> sed  <span><span>&#39;</span>s/vodka/VODKA/<span>&#39;</span></span> <span>&gt;</span> /dev/null

real	0m0.024s
user	0m0.020s
sys	0m0.010s
</pre></div>
<p dir="auto">For complex tasks, <strong><code>trre_dft</code></strong> (deterministic version) can outperform sed:</p>
<div dir="auto" data-snippet-clipboard-copy-content="$ time cat chekhov.txt | sed -e &#39;s/\(.*\)/\U\1/&#39; &gt; /dev/null

real	0m0.508s
user	0m0.504s
sys	0m0.015s

$ time cat chekhov.txt | trre_dft &#39;[a:A-z:Z]&#39; &gt; /dev/null

real	0m0.131s
user	0m0.127s
sys	0m0.009s"><pre>$ <span>time</span> cat chekhov.txt <span>|</span> sed -e <span><span>&#39;</span>s/\(.*\)/\U\1/<span>&#39;</span></span> <span>&gt;</span> /dev/null

real	0m0.508s
user	0m0.504s
sys	0m0.015s

$ <span>time</span> cat chekhov.txt <span>|</span> trre_dft <span><span>&#39;</span>[a:A-z:Z]<span>&#39;</span></span> <span>&gt;</span> /dev/null

real	0m0.131s
user	0m0.127s
sys	0m0.009s</pre></div>

<p dir="auto">No pre-built binaries are available yet. Clone the repository and compile:</p>
<div dir="auto" data-snippet-clipboard-copy-content="git clone git@github.com:c0stya/trre.git trre
cd trre
make &amp;&amp; sh test.sh"><pre>git clone git@github.com:c0stya/trre.git trre
<span>cd</span> trre
make <span>&amp;&amp;</span> sh test.sh</pre></div>
<p dir="auto">Then move the binary to a directory in your <code>$PATH</code>.</p>

<ul dir="auto">
<li>Complete the ERE feature set:
<ul dir="auto">
<li>negation <code>^</code> within <code>[]</code></li>
<li>character classes</li>
<li>&#39;$^&#39; anchoring symbols</li>
</ul>
</li>
<li>Full unicode support</li>
<li>Efficient range processing</li>
<li>Stable DFT version</li>
</ul>

<ul dir="auto">
<li>The approach is strongly inspired by Russ Cox article: <a href="https://swtch.com/~rsc/regexp/regexp1.html" rel="nofollow">Regular Expression Matching Can Be Simple And Fast</a></li>
<li>The idea of transducer determinization comes from this paper: <a href="https://research.google/pubs/finitely-subsequential-transducers-2/" rel="nofollow">Cyril Allauzen, Mehryar Mohri, &#34;Finitely Subsequential Transducers&#34;</a></li>
<li>Parsing approach comes from <a href="https://github.com/erikeidt/erikeidt.github.io/blob/master/The-Double-E-Method.md">Double-E algorithm</a> by Erik Eidt which is close to the classical <a href="https://en.wikipedia.org/wiki/Shunting_yard_algorithm" rel="nofollow">Shunting Yard algorithm</a>.</li>
</ul>
</article></div></div>
  </body>
</html>
