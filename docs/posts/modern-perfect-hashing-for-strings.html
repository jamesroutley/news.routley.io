<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://0x80.pl/notesen/2023-04-30-lookup-in-strings.html">Original</a>
    <h1>Modern perfect hashing for strings</h1>
    
    <div id="readability-page-1" class="page"><p>While minimal hash functions are hard to find, perfect hash functions
are quite easy to compute. We will describe two methods:</p><div id="open-addressing">
<h2>Open addressing</h2>
<p>When we build a generic hash table implementation, collisions are unavoidable.
The most common solution to this problem is using some kind of container (a
linked list or balanced tree) to keep all objects sharing the same hash value.</p>
<p>A less common strategy is <strong>open addressing</strong>. We store values directly in
the table. If there is a collision — that is, the given index is already
allocated — we try another index. There are several approaches to pick
a new index; it simply may be the next index (called <em>linear probing</em>),
but there are of course more sophisticated procedures (quadratic probing,
double hashing, etc.).</p>
<p>In our case, where we have a static set of strings, we use the simplest
solution. Our goal is to find the minimum size of table (<strong>N</strong>) in which the
number of collisions (<strong>k</strong>) is also the least possible, preferably without
collisions.</p>
<p>Inputs parameters are: 1) a set of strings and 2) hash function; to avoid
calling the hash function over and over, we cache the hash value for each
string.</p>
<p>The main procedure is responsible for settings the maximum number of
collisions; it starts from 1 and increases it until we succeeded.  The
number of collisions depends on the quality of hash function, but often it
is just 2 or 3 collisions. The <a href="http://en.wikipedia.org/wiki/Go_(programming_language)">Go</a>
implementation of procedure is shown below.</p>
<p>Then, for some range of table sizes, we check the actual number of
collisions, and we report the minimum table size.</p>
<pre><span>func</span><span> </span><span>computerHashParameters</span><span>(</span><span>keywords</span><span> </span><span>[]</span><span>Keyword</span><span>,</span><span> </span><span>hash</span><span> </span><span>func</span><span>([]</span><span>byte</span><span>)</span><span> </span><span>uint64</span><span>)</span><span> </span><span>(</span><span>size</span><span> </span><span>int</span><span>,</span><span> </span><span>collisions</span><span> </span><span>int</span><span>)</span><span> </span><span>{</span><span>
    </span><span>hashes</span><span> </span><span>:=</span><span> </span><span>make</span><span>([]</span><span>uint64</span><span>,</span><span> </span><span>len</span><span>(</span><span>keywords</span><span>))</span><span>
    </span><span>for</span><span> </span><span>i</span><span> </span><span>:=</span><span> </span><span>range</span><span> </span><span>keywords</span><span> </span><span>{</span><span>
        </span><span>hashes</span><span>[</span><span>i</span><span>]</span><span> </span><span>=</span><span> </span><span>hash</span><span>(</span><span>keywords</span><span>[</span><span>i</span><span>].</span><span>word</span><span>)</span><span>
    </span><span>}</span><span>
    </span><span>collisions</span><span> </span><span>=</span><span> </span><span>1</span><span>
    </span><span>for</span><span> </span><span>{</span><span>
        </span><span>size</span><span> </span><span>=</span><span> </span><span>hashtableaux</span><span>(</span><span>hashes</span><span>,</span><span> </span><span>collisions</span><span>)</span><span>
        </span><span>if</span><span> </span><span>size</span><span> </span><span>&gt;</span><span> </span><span>0</span><span> </span><span>{</span><span>
            </span><span>fmt</span><span>.</span><span>Printf</span><span>(</span><span>&#34;size = %5d, maxcollisions = %d\n&#34;</span><span>,</span><span> </span><span>size</span><span>,</span><span> </span><span>collisions</span><span>)</span><span>
            </span><span>return</span><span>
        </span><span>}</span><span>
        </span><span>collisions</span><span> </span><span>+=</span><span> </span><span>1</span><span>
    </span><span>}</span><span>
</span><span>}</span>
</pre>
<p>Below is the implementation of a helper function. It checks table size
starting from the size of input set, up to its tenfold; multiply of 10
appeared to be a quite good upper bound.</p>
<pre><span>func</span><span> </span><span>hashtableaux</span><span>(</span><span>hashes</span><span> </span><span>[]</span><span>uint64</span><span>,</span><span> </span><span>maxcollisions</span><span> </span><span>int</span><span>)</span><span> </span><span>int</span><span> </span><span>{</span><span>
    </span><span>n</span><span> </span><span>:=</span><span> </span><span>len</span><span>(</span><span>hashes</span><span>)</span><span>
    </span><span>const</span><span> </span><span>sizeOverhead</span><span> </span><span>=</span><span> </span><span>10</span><span>

</span><span>outer</span><span>:</span><span>
    </span><span>for</span><span> </span><span>N</span><span> </span><span>:=</span><span> </span><span>n</span><span>;</span><span> </span><span>N</span><span> </span><span>&lt;</span><span> </span><span>sizeOverhead</span><span>*</span><span>n</span><span>;</span><span> </span><span>N</span><span>++</span><span> </span><span>{</span><span>
        </span><span>table</span><span> </span><span>:=</span><span> </span><span>make</span><span>(</span><span>map</span><span>[</span><span>uint64</span><span>]</span><span>int</span><span>)</span><span>
        </span><span>for</span><span> </span><span>_</span><span>,</span><span> </span><span>h</span><span> </span><span>:=</span><span> </span><span>range</span><span> </span><span>hashes</span><span> </span><span>{</span><span>
            </span><span>idx</span><span> </span><span>:=</span><span> </span><span>h</span><span> </span><span>%</span><span> </span><span>uint64</span><span>(</span><span>N</span><span>)</span><span>
            </span><span>table</span><span>[</span><span>idx</span><span>]</span><span> </span><span>+=</span><span> </span><span>1</span><span>
            </span><span>if</span><span> </span><span>table</span><span>[</span><span>idx</span><span>]</span><span> </span><span>&gt;</span><span> </span><span>maxcollisions</span><span> </span><span>{</span><span>
                </span><span>continue</span><span> </span><span>outer</span><span>
            </span><span>}</span><span>
        </span><span>}</span><span>
        </span><span>return</span><span> </span><span>N</span><span>
    </span><span>}</span><span>

    </span><span>return</span><span> </span><span>-</span><span>1</span><span>
</span><span>}</span>
</pre>
<p>Now, having the parameters <strong>N</strong> and <strong>k</strong>, we can finally write a procedure
for lookup.  The following C++ procedure lookups for one of Go keywords.</p>
<pre><span>int</span><span> </span><span>lookup_go_hash1</span><span>(</span><span>std</span><span>::</span><span>string_view</span><span> </span><span>s</span><span>)</span><span> </span><span>{</span><span>
    </span><span>const</span><span> </span><span>uint64_t</span><span> </span><span>idx</span><span> </span><span>=</span><span> </span><span>(</span><span>hash1</span><span>(</span><span>s</span><span>)</span><span> </span><span>%</span><span> </span><span>38</span><span>)</span><span> </span><span>*</span><span> </span><span>2</span><span>;</span><span>
    </span><span>static</span><span> </span><span>std</span><span>::</span><span>string_view</span><span> </span><span>lookup</span><span>[</span><span>76</span><span>]</span><span> </span><span>=</span><span> </span><span>{</span><span>
        </span><span>&#34;chan&#34;</span><span>,</span><span> </span><span>// 836 (0x344)
</span><span>        </span><span>&#34;&#34;</span><span>,</span><span> </span><span>&#34;&#34;</span><span>,</span><span> </span><span>&#34;&#34;</span><span>,</span><span>
        </span><span>&#34;case&#34;</span><span>,</span><span> </span><span>// 800 (0x320)
</span><span>        </span><span>&#34;for&#34;</span><span>,</span><span> </span><span>// 648 (0x288)
</span><span>        </span><span>&#34;&#34;</span><span>,</span><span> </span><span>&#34;&#34;</span><span>,</span><span>
        </span><span>&#34;continue&#34;</span><span>,</span><span> </span><span>// 1600 (0x640)
</span><span>        </span><span>&#34;&#34;</span><span>,</span><span> </span><span>&#34;&#34;</span><span>,</span><span> </span><span>&#34;&#34;</span><span>,</span><span>
        </span><span>&#34;defer&#34;</span><span>,</span><span> </span><span>// 1070 (0x42e)
</span><span>        </span><span>&#34;func&#34;</span><span>,</span><span> </span><span>// 804 (0x324)
</span><span>        </span><span>&#34;&#34;</span><span>,</span><span> </span><span>&#34;&#34;</span><span>,</span><span> </span><span>&#34;&#34;</span><span>,</span><span> </span><span>&#34;&#34;</span><span>,</span><span>
        </span><span>&#34;package&#34;</span><span>,</span><span> </span><span>// 1491 (0x5d3)
</span><span>        </span><span>&#34;&#34;</span><span>,</span><span>
        </span><span>&#34;else&#34;</span><span>,</span><span> </span><span>// 808 (0x328)
</span><span>        </span><span>&#34;go&#34;</span><span>,</span><span> </span><span>// 428 (0x1ac)
</span><span>        </span><span>&#34;const&#34;</span><span>,</span><span> </span><span>// 1075 (0x433)
</span><span>        </span><span>&#34;range&#34;</span><span>,</span><span> </span><span>// 1075 (0x433)
</span><span>        </span><span>&#34;var&#34;</span><span>,</span><span> </span><span>// 696 (0x2b8)
</span><span>        </span><span>&#34;&#34;</span><span>,</span><span> </span><span>&#34;&#34;</span><span>,</span><span> </span><span>&#34;&#34;</span><span>,</span><span>
        </span><span>&#34;return&#34;</span><span>,</span><span> </span><span>// 1344 (0x540)
</span><span>        </span><span>&#34;&#34;</span><span>,</span><span> </span><span>&#34;&#34;</span><span>,</span><span> </span><span>&#34;&#34;</span><span>,</span><span> </span><span>&#34;&#34;</span><span>,</span><span> </span><span>&#34;&#34;</span><span>,</span><span>
        </span><span>&#34;map&#34;</span><span>,</span><span> </span><span>// 663 (0x297)
</span><span>        </span><span>&#34;&#34;</span><span>,</span><span>
        </span><span>&#34;select&#34;</span><span>,</span><span> </span><span>// 1386 (0x56a)
</span><span>        </span><span>&#34;struct&#34;</span><span>,</span><span> </span><span>// 1386 (0x56a)
</span><span>        </span><span>&#34;&#34;</span><span>,</span><span> </span><span>&#34;&#34;</span><span>,</span><span>
        </span><span>&#34;goto&#34;</span><span>,</span><span> </span><span>// 856 (0x358)
</span><span>        </span><span>&#34;&#34;</span><span>,</span><span> </span><span>&#34;&#34;</span><span>,</span><span> </span><span>&#34;&#34;</span><span>,</span><span>
        </span><span>&#34;switch&#34;</span><span>,</span><span> </span><span>// 1314 (0x522)
</span><span>        </span><span>&#34;&#34;</span><span>,</span><span> </span><span>&#34;&#34;</span><span>,</span><span> </span><span>&#34;&#34;</span><span>,</span><span>
        </span><span>&#34;fallthrough&#34;</span><span>,</span><span> </span><span>// 2266 (0x8da)
</span><span>        </span><span>&#34;&#34;</span><span>,</span><span> </span><span>&#34;&#34;</span><span>,</span><span> </span><span>&#34;&#34;</span><span>,</span><span> </span><span>&#34;&#34;</span><span>,</span><span> </span><span>&#34;&#34;</span><span>,</span><span> </span><span>&#34;&#34;</span><span>,</span><span> </span><span>&#34;&#34;</span><span>,</span><span> </span><span>&#34;&#34;</span><span>,</span><span> </span><span>&#34;&#34;</span><span>,</span><span> </span><span>&#34;&#34;</span><span>,</span><span> </span><span>&#34;&#34;</span><span>,</span><span>
        </span><span>&#34;default&#34;</span><span>,</span><span> </span><span>// 1512 (0x5e8)
</span><span>        </span><span>&#34;interface&#34;</span><span>,</span><span> </span><span>// 1854 (0x73e)
</span><span>        </span><span>&#34;&#34;</span><span>,</span><span> </span><span>&#34;&#34;</span><span>,</span><span>
        </span><span>&#34;type&#34;</span><span>,</span><span> </span><span>// 868 (0x364)
</span><span>        </span><span>&#34;&#34;</span><span>,</span><span> </span><span>&#34;&#34;</span><span>,</span><span> </span><span>&#34;&#34;</span><span>,</span><span>
        </span><span>&#34;if&#34;</span><span>,</span><span> </span><span>// 414 (0x19e)
</span><span>        </span><span>&#34;import&#34;</span><span>,</span><span> </span><span>// 1326 (0x52e)
</span><span>        </span><span>&#34;&#34;</span><span>,</span><span> </span><span>&#34;&#34;</span><span>,</span><span> </span><span>&#34;&#34;</span><span>,</span><span> </span><span>&#34;&#34;</span><span>,</span><span>
        </span><span>&#34;break&#34;</span><span>,</span><span> </span><span>// 1025 (0x401)
</span><span>        </span><span>&#34;&#34;</span><span>,</span><span> </span><span>};</span><span>
    </span><span>static</span><span> </span><span>int</span><span> </span><span>values</span><span>[</span><span>76</span><span>]</span><span> </span><span>=</span><span> </span><span>{</span><span>
        </span><span>2</span><span>,</span><span> </span><span>// 836 (0x344)
</span><span>        </span><span>-1</span><span>,</span><span> </span><span>-1</span><span>,</span><span> </span><span>-1</span><span>,</span><span>
        </span><span>1</span><span>,</span><span> </span><span>// 800 (0x320)
</span><span>        </span><span>9</span><span>,</span><span> </span><span>// 648 (0x288)
</span><span>        </span><span>-1</span><span>,</span><span> </span><span>-1</span><span>,</span><span>
        </span><span>4</span><span>,</span><span> </span><span>// 1600 (0x640)
</span><span>        </span><span>-1</span><span>,</span><span> </span><span>-1</span><span>,</span><span> </span><span>-1</span><span>,</span><span>
        </span><span>6</span><span>,</span><span> </span><span>// 1070 (0x42e)
</span><span>        </span><span>10</span><span>,</span><span> </span><span>// 804 (0x324)
</span><span>        </span><span>-1</span><span>,</span><span> </span><span>-1</span><span>,</span><span> </span><span>-1</span><span>,</span><span> </span><span>-1</span><span>,</span><span>
        </span><span>17</span><span>,</span><span> </span><span>// 1491 (0x5d3)
</span><span>        </span><span>-1</span><span>,</span><span>
        </span><span>7</span><span>,</span><span> </span><span>// 808 (0x328)
</span><span>        </span><span>11</span><span>,</span><span> </span><span>// 428 (0x1ac)
</span><span>        </span><span>3</span><span>,</span><span> </span><span>// 1075 (0x433)
</span><span>        </span><span>18</span><span>,</span><span> </span><span>// 1075 (0x433)
</span><span>        </span><span>24</span><span>,</span><span> </span><span>// 696 (0x2b8)
</span><span>        </span><span>-1</span><span>,</span><span> </span><span>-1</span><span>,</span><span> </span><span>-1</span><span>,</span><span>
        </span><span>19</span><span>,</span><span> </span><span>// 1344 (0x540)
</span><span>        </span><span>-1</span><span>,</span><span> </span><span>-1</span><span>,</span><span> </span><span>-1</span><span>,</span><span> </span><span>-1</span><span>,</span><span> </span><span>-1</span><span>,</span><span>
        </span><span>16</span><span>,</span><span> </span><span>// 663 (0x297)
</span><span>        </span><span>-1</span><span>,</span><span>
        </span><span>20</span><span>,</span><span> </span><span>// 1386 (0x56a)
</span><span>        </span><span>21</span><span>,</span><span> </span><span>// 1386 (0x56a)
</span><span>        </span><span>-1</span><span>,</span><span> </span><span>-1</span><span>,</span><span>
        </span><span>12</span><span>,</span><span> </span><span>// 856 (0x358)
</span><span>        </span><span>-1</span><span>,</span><span> </span><span>-1</span><span>,</span><span> </span><span>-1</span><span>,</span><span>
        </span><span>22</span><span>,</span><span> </span><span>// 1314 (0x522)
</span><span>        </span><span>-1</span><span>,</span><span> </span><span>-1</span><span>,</span><span> </span><span>-1</span><span>,</span><span>
        </span><span>8</span><span>,</span><span> </span><span>// 2266 (0x8da)
</span><span>        </span><span>-1</span><span>,</span><span> </span><span>-1</span><span>,</span><span> </span><span>-1</span><span>,</span><span> </span><span>-1</span><span>,</span><span> </span><span>-1</span><span>,</span><span> </span><span>-1</span><span>,</span><span> </span><span>-1</span><span>,</span><span> </span><span>-1</span><span>,</span><span> </span><span>-1</span><span>,</span><span> </span><span>-1</span><span>,</span><span> </span><span>-1</span><span>,</span><span>
        </span><span>5</span><span>,</span><span> </span><span>// 1512 (0x5e8)
</span><span>        </span><span>15</span><span>,</span><span> </span><span>// 1854 (0x73e)
</span><span>        </span><span>-1</span><span>,</span><span> </span><span>-1</span><span>,</span><span>
        </span><span>23</span><span>,</span><span> </span><span>// 868 (0x364)
</span><span>        </span><span>-1</span><span>,</span><span> </span><span>-1</span><span>,</span><span> </span><span>-1</span><span>,</span><span>
        </span><span>13</span><span>,</span><span> </span><span>// 414 (0x19e)
</span><span>        </span><span>14</span><span>,</span><span> </span><span>// 1326 (0x52e)
</span><span>        </span><span>-1</span><span>,</span><span> </span><span>-1</span><span>,</span><span> </span><span>-1</span><span>,</span><span> </span><span>-1</span><span>,</span><span>
        </span><span>0</span><span>,</span><span> </span><span>// 1025 (0x401)
</span><span>        </span><span>-1</span><span>,</span><span>
    </span><span>};</span><span>
    </span><span>for</span><span> </span><span>(</span><span>int</span><span> </span><span>i</span><span>=</span><span>0</span><span>;</span><span> </span><span>i</span><span> </span><span>&lt;</span><span> </span><span>2</span><span>;</span><span> </span><span>i</span><span>++</span><span>)</span><span> </span><span>{</span><span>
        </span><span>if</span><span> </span><span>(</span><span>lookup</span><span>[</span><span>idx</span><span> </span><span>+</span><span> </span><span>i</span><span>]</span><span> </span><span>==</span><span> </span><span>s</span><span>)</span><span> </span><span>{</span><span>
            </span><span>return</span><span> </span><span>values</span><span>[</span><span>idx</span><span> </span><span>+</span><span> </span><span>i</span><span>];</span><span>
        </span><span>}</span><span>
    </span><span>}</span><span>
    </span><span>return</span><span> </span><span>-1</span><span>;</span><span>
</span><span>}</span>
</pre>
<p>First we have a call to <tt>hash1</tt> on the input string. Its result is
taken modulo 38 — that is the value <strong>N</strong> found by the above algorithm.
Likewise, the magic constant 2 is parameter <strong>k</strong>, and it is the number
of collisions we have to handle.</p>
<p>The lookup procedure contains two auxiliary tables of size <tt>N * k = 76</tt>: one
for strings and another for values; the not-found-value was set to -1. (Note that
we can have a single array of structures, however it&#39;s hard to tell what&#39;s
better for typically small arrays.) After getting index <tt>idx</tt> we just run
two times the following check:</p>
<pre><span>if</span><span> </span><span>(</span><span>lookup</span><span>[</span><span>idx</span><span> </span><span>+</span><span> </span><span>i</span><span>]</span><span> </span><span>==</span><span> </span><span>s</span><span>)</span><span> </span><span>{</span><span>
    </span><span>return</span><span> </span><span>values</span><span>[</span><span>idx</span><span> </span><span>+</span><span> </span><span>i</span><span>];</span><span>
</span><span>}</span>
</pre>
<p>Please note that all parameters for hash table are compile time, thus
a compiler can rid of division and apply additional optimizations.</p>
<p>Below is assembly code of the procedure, compiled for Skylake
architecture with GCC 12.2.0.</p>
<pre>&lt;lookup_go_hash1(std::basic_string_view&lt;char, std::char_traits&lt;char&gt; &gt;)&gt;:
    push   %r14
    push   %r13
    mov    %rsi,%r13
    push   %r12
    push   %rbp
    mov    %rdi,%rbp
    push   %rbx

    movsbq (%rsi),%rax                  // f := first char
    movsbq -0x1(%rdi,%rsi,1),%rcx       // l := last char
    add    %rax,%rcx                    // their sum
    imul   %rdi,%rcx                    // (f + l) * s.size()

    movabs $0xd79435e50d79435f,%rax     //
    mul    %rcx                         //
    shr    $0x5,%rdx                    //
    imul   $0x26,%rdx,%rax              //
    sub    %rax,%rcx                    //
    mov    %rcx,%rdx                    //
    lea    (%rcx,%rcx,1),%r12           //
    shl    $0x5,%rdx                    // rdx = ((f + l) * s.size()) % 38

    // The for loop. GCC split the loop -- it quickly compares lengths
    // of lookup[idx] + i with s.size (rbp) and only if they are equal
    // jumps to bytes comparison.
    lea    0x267b47(%rip),%rax          // rax = lookup address
    lea    (%rdx,%rax,1),%rbx           // rbx = size
    lea    0x2(%r12),%r14
    mov    0x8(%rbx),%rdi
    cmp    (%rbx),%rbp                  // jump to full compare only if lengths are equal
    je     &lt;lookup_go_hash1(std::basic_string_view&lt;char, std::char_traits&lt;char&gt; &gt;)+0x78&gt;
    inc    %r12
    add    $0x10,%rbx
    cmp    %r14,%r12
    jne    &lt;lookup_go_hash1(std::basic_string_view&lt;char, std::char_traits&lt;char&gt; &gt;)+0x52&gt;
    pop    %rbx
    pop    %rbp
    pop    %r12
    pop    %r13
    mov    $0xffffffff,%eax
    pop    %r14
    ret
    nopl   (%rax)

    // check if bytes are equal
    test   %rbp,%rbp
    je     &lt;lookup_go_hash1(std::basic_string_view&lt;char, std::char_traits&lt;char&gt; &gt;)+0x8c&gt;
    mov    %rbp,%rdx
    mov    %r13,%rsi
    call   &lt;memcmp@plt&gt;
    test   %eax,%eax
    jne    &lt;lookup_go_hash1(std::basic_string_view&lt;char, std::char_traits&lt;char&gt; &gt;)+0x5b&gt;
    pop    %rbx
    pop    %rbp
    lea    0x1f56bb(%rip),%rax        # &lt;lookup_go_hash1(std::basic_string_view&lt;char, std::char_traits&lt;char&gt; &gt;)::values&gt;
    mov    (%rax,%r12,4),%eax
    pop    %r12
    pop    %r13
    pop    %r14
    ret
</pre>
<div id="hash-functions">
<h3>Hash functions</h3>
<p>Following hash functions were tested:</p>
<ul>
<li><tt>hash1</tt> — sum of the first and last char multiplied by the string length;</li>
<li><tt>hash2</tt> — sum of the first and last char bit-xor&#39;ed with the string length;</li>
<li><tt>hash3</tt> — first, second and last characters combined with the string;
length: <tt>((f &lt;&lt; 8) | s) + l + (n * 0x111)</tt>;</li>
<li><tt>hash_sum0</tt> — sum of all bytes;</li>
<li><tt>hash_sumN</tt> — sum of all bytes plus the string length;</li>
<li><tt>hash_djb2</tt> — <a href="http://www.cse.yorku.ca/~oz/hash.html">Berenstein&#39;s hash</a>;</li>
<li><tt>hash_sdb</tt> — <a href="http://www.cse.yorku.ca/~oz/hash.html">sdbm hash</a>.</li>
</ul>
</div>
</div><div id="splitting-by-input-length">
<h2>Splitting by input length</h2>
<p>I observed that the string length is a decent discriminator:
<a href="http://0x80.pl/notesen/notesen/2010-04-03-stl-map-of-strings.html">STL: map with string as key — access speedup</a>.
In most cases we obtain the length of strings in constant time; for instance
this C++ function simplifies to a few CPU instructions.</p>
<pre><span>#include</span><span> </span><span>&lt;cstdint&gt;</span><span>
#include</span><span> </span><span>&lt;string_view&gt;</span><span>
</span><span>
</span><span>uint64_t</span><span> </span><span>len</span><span>(</span><span>std</span><span>::</span><span>string_view</span><span> </span><span>s</span><span>)</span><span> </span><span>{</span><span>
   </span><span>return</span><span> </span><span>s</span><span>.</span><span>size</span><span>();</span><span>
</span><span>}</span>
</pre>
<pre>$<span> </span>g++<span> </span>-O2<span> </span>-S<span> </span>test.cpp<span>
</span>$<span> </span>cat<span> </span>test.s<span>
    </span>...<span>
    </span>movq<span>    </span>%rdi,<span> </span>%rax<span>
    </span>ret<span>
    </span>...
</pre>
<p>Taking this into account, we first split the set of strings
into the subsets of strings having the same length. These
subsets are usually small. We can fine-tune looking up
in such substrings independently. One common optimization
that is present in sample code is using plain if-ladder
of compares when a subset is small (has two or three elements).</p>
<p>Additionally, working with same-length strings enables
more low-level optimizations:</p>
<ul>
<li>The length of string is usually known in the compile-time.</li>
<li>Thus, bound checks can be eliminated.</li>
<li>Equality of two strings from a subset is simple <tt>memcmp</tt>,
and this procedure may be further inlined and optimized by
a compiler.</li>
</ul>
</div><div id="using-the-minimum-number-of-bits">
<h2>Using the minimum number of bits</h2>
<blockquote>
<strong>Note</strong>: this method was inspired by the hashing procedure
found in <a href="https://www.gnu.org/software/gperf/">GNU gperf</a>.</blockquote>
<p>The presented method requires input string to have the same lengths.
We guaranteed that property by pre-classifying the input string by its
length, as described in the previous section.</p>
<p><tt>gperf</tt> uses the following observation: not all input characters
contribute to uniqueness of set. In most cases we may discard many
input characters and such modified set still holds unique items.</p>
<p>For instance, five-letter Go keywords are <tt>break</tt>, <tt>const</tt>, <tt>defer</tt>,
and <tt>range</tt>. The last character is sufficient to distinguish
them:</p>
<pre>break =&gt; ____k
const =&gt; ____t
defer =&gt; ____r
range =&gt; ____e
</pre>
<p>In the case of six-letter keywords, we need two characters, as shown
below. The letter &#39;t&#39; repeats at the last position, but the second
character makes this set unique.</p>
<pre>import =&gt; ___o_t
return =&gt; ___u_n
select =&gt; ___e_t
struct =&gt; ___u_t
switch =&gt; ___t_h
</pre>
<p>The major problem is that we need to combine somehow these unique characters
into an unique and <strong>relatively small</strong> value. <tt>gperf</tt> adds the characters
after passing them through an auxiliary lookup table. Like: <tt>lookup[s[0]] +
lookup[s[5]]</tt>.</p>
<p>Similarly to discarding individual bytes, we may discard individual <strong>bits</strong>,
ending up with a bitmask that can be used to extract <em>significant</em> bits. To do
this, we use a very fast instruction <tt>PEXT</tt>.</p>
<p>Before we dig into details, let us re-examine the examples. For five-letter
Go keywords we have:</p>
<pre>01100010.01110010.01100101.01100001.01101011 =&gt; ________.________.________.________.______11
01100011.01101111.01101110.01110011.01110100 =&gt; ________.________.________.________.______00
01100100.01100101.01100110.01100101.01110010 =&gt; ________.________.________.________.______10
01110010.01100001.01101110.01100111.01100101 =&gt; ________.________.________.________.______01
</pre>
<p>And for six-letter ones:</p>
<pre>01101001.01101101.01110000.01101111.01110010.01110100 =&gt; ________.________.________.___0____._______0._____1__
01110010.01100101.01110100.01110101.01110010.01101110 =&gt; ________.________.________.___1____._______0._____1__
01110011.01100101.01101100.01100101.01100011.01110100 =&gt; ________.________.________.___0____._______1._____1__
01110011.01110100.01110010.01110101.01100011.01110100 =&gt; ________.________.________.___1____._______1._____1__
01110011.01110111.01101001.01110100.01100011.01101000 =&gt; ________.________.________.___1____._______1._____0__
</pre>
<p>Thus, in the first case we need just 2 bits, and in the second bits
only 3 bits. The 2-bit subset contains all possible values (<tt>00</tt>, <tt>01</tt>,
<tt>11</tt>, <tt>10</tt>), while 3-bit subset is not full (<tt>001</tt>, <tt>101</tt>, <tt>011</tt>,
<tt>111</tt>, <tt>110</tt>).</p>
<p>A skeleton of C++ procedure that uses this approach is:</p>
<pre><span>...</span><span>
</span><span>/* 1 */</span><span> </span><span>const</span><span> </span><span>uint64_t</span><span> </span><span>word</span><span> </span><span>=</span><span> </span><span>load_bytes</span><span>(</span><span>s</span><span>);</span><span>
</span><span>/* 2 */</span><span> </span><span>const</span><span> </span><span>uint64_t</span><span> </span><span>idx</span><span>  </span><span>=</span><span> </span><span>_pext_u64</span><span>(</span><span>word</span><span>,</span><span> </span><span>mask</span><span>);</span><span>
</span><span>/* 3 */</span><span> </span><span>if</span><span> </span><span>(</span><span>memcmp</span><span>(</span><span>lookup</span><span>[</span><span>idx</span><span>],</span><span> </span><span>s</span><span>.</span><span>data</span><span>(),</span><span> </span><span>size</span><span>)</span><span> </span><span>==</span><span> </span><span>0</span><span>)</span><span> </span><span>{</span><span>
            </span><span>return</span><span> </span><span>value</span><span>[</span><span>idx</span><span>];</span><span>
        </span><span>}</span><span>
</span><span>...</span>
</pre>
<p>Once we know which bits are significant, we need to find which bytes
have to be loaded (1); a byte is the minimum amount of data we can
transfer. As we can see, for five-letter keywords it is sufficient to load
just one byte. But for six-letter keywords we need three bytes — in
practise it is still a single load, but done on an 32-bit entity.</p>
<p>Then, we extract the bits using the instruction <tt>PEXT</tt> (2) — these bits
form an <strong>n-bit index</strong>.</p>
<p>We need an auxiliary table(s) of size <span>2<sup><i>n</i></sup></span>, having exactly the same
meaning as in <a href="#hash">hashing</a>. We compare the input string with keyword (3)
and if they equal, we return the associated value.</p>
<p>This is a snippet from procedure for looking up the Go keywords:</p>
<pre><span>int</span><span> </span><span>lookup_go_pext</span><span>(</span><span>std</span><span>::</span><span>string_view</span><span> </span><span>s</span><span>)</span><span> </span><span>{</span><span>
    </span><span>switch</span><span> </span><span>(</span><span>s</span><span>.</span><span>size</span><span>())</span><span> </span><span>{</span><span>
        </span><span>// ...
</span><span>        </span><span>case</span><span> </span><span>5</span><span>:</span><span> </span><span>{</span><span>
            </span><span>static</span><span> </span><span>char</span><span> </span><span>lookup</span><span>[</span><span>4</span><span>][</span><span>5</span><span>]</span><span> </span><span>=</span><span> </span><span>{</span><span>
                </span><span>{</span><span>&#39;b&#39;</span><span>,</span><span> </span><span>&#39;r&#39;</span><span>,</span><span> </span><span>&#39;e&#39;</span><span>,</span><span> </span><span>&#39;a&#39;</span><span>,</span><span> </span><span>&#39;k&#39;</span><span>},</span><span>
                </span><span>{</span><span>&#39;r&#39;</span><span>,</span><span> </span><span>&#39;a&#39;</span><span>,</span><span> </span><span>&#39;n&#39;</span><span>,</span><span> </span><span>&#39;g&#39;</span><span>,</span><span> </span><span>&#39;e&#39;</span><span>},</span><span>
                </span><span>{</span><span>&#39;d&#39;</span><span>,</span><span> </span><span>&#39;e&#39;</span><span>,</span><span> </span><span>&#39;f&#39;</span><span>,</span><span> </span><span>&#39;e&#39;</span><span>,</span><span> </span><span>&#39;r&#39;</span><span>},</span><span>
                </span><span>{</span><span>&#39;c&#39;</span><span>,</span><span> </span><span>&#39;o&#39;</span><span>,</span><span> </span><span>&#39;n&#39;</span><span>,</span><span> </span><span>&#39;s&#39;</span><span>,</span><span> </span><span>&#39;t&#39;</span><span>},</span><span>
            </span><span>};</span><span>
            </span><span>static</span><span> </span><span>int</span><span> </span><span>value</span><span>[</span><span>4</span><span>]</span><span> </span><span>=</span><span> </span><span>{</span><span>
                </span><span>0</span><span>,</span><span>
                </span><span>18</span><span>,</span><span>
                </span><span>6</span><span>,</span><span>
                </span><span>3</span><span>,</span><span>
            </span><span>};</span><span>
            </span><span>const</span><span> </span><span>uint8_t</span><span> </span><span>w2</span><span> </span><span>=</span><span> </span><span>s</span><span>[</span><span>4</span><span>];</span><span>
            </span><span>const</span><span> </span><span>uint64_t</span><span> </span><span>idx</span><span> </span><span>=</span><span> </span><span>_pext_u64</span><span>(</span><span>w2</span><span>,</span><span> </span><span>0x14</span><span>);</span><span>
            </span><span>if</span><span> </span><span>(</span><span>memcmp</span><span>(</span><span>lookup</span><span>[</span><span>idx</span><span>],</span><span> </span><span>s</span><span>.</span><span>data</span><span>(),</span><span> </span><span>sizeof</span><span>(</span><span>lookup</span><span>[</span><span>0</span><span>]))</span><span> </span><span>==</span><span> </span><span>0</span><span>)</span><span> </span><span>{</span><span>
                </span><span>return</span><span> </span><span>value</span><span>[</span><span>idx</span><span>];</span><span>
            </span><span>}</span><span>
        </span><span>}</span><span>
        </span><span>break</span><span>;</span><span>
        </span><span>case</span><span> </span><span>6</span><span>:</span><span> </span><span>{</span><span>
            </span><span>static</span><span> </span><span>char</span><span> </span><span>lookup</span><span>[</span><span>8</span><span>][</span><span>6</span><span>]</span><span> </span><span>=</span><span> </span><span>{</span><span>
                </span><span>{},</span><span> </span><span>// no match
</span><span>                </span><span>{</span><span>&#39;s&#39;</span><span>,</span><span> </span><span>&#39;w&#39;</span><span>,</span><span> </span><span>&#39;i&#39;</span><span>,</span><span> </span><span>&#39;t&#39;</span><span>,</span><span> </span><span>&#39;c&#39;</span><span>,</span><span> </span><span>&#39;h&#39;</span><span>},</span><span>
                </span><span>{},</span><span> </span><span>// no match
</span><span>                </span><span>{</span><span>&#39;r&#39;</span><span>,</span><span> </span><span>&#39;e&#39;</span><span>,</span><span> </span><span>&#39;t&#39;</span><span>,</span><span> </span><span>&#39;u&#39;</span><span>,</span><span> </span><span>&#39;r&#39;</span><span>,</span><span> </span><span>&#39;n&#39;</span><span>},</span><span>
                </span><span>{</span><span>&#39;s&#39;</span><span>,</span><span> </span><span>&#39;e&#39;</span><span>,</span><span> </span><span>&#39;l&#39;</span><span>,</span><span> </span><span>&#39;e&#39;</span><span>,</span><span> </span><span>&#39;c&#39;</span><span>,</span><span> </span><span>&#39;t&#39;</span><span>},</span><span>
                </span><span>{</span><span>&#39;s&#39;</span><span>,</span><span> </span><span>&#39;t&#39;</span><span>,</span><span> </span><span>&#39;r&#39;</span><span>,</span><span> </span><span>&#39;u&#39;</span><span>,</span><span> </span><span>&#39;c&#39;</span><span>,</span><span> </span><span>&#39;t&#39;</span><span>},</span><span>
                </span><span>{</span><span>&#39;i&#39;</span><span>,</span><span> </span><span>&#39;m&#39;</span><span>,</span><span> </span><span>&#39;p&#39;</span><span>,</span><span> </span><span>&#39;o&#39;</span><span>,</span><span> </span><span>&#39;r&#39;</span><span>,</span><span> </span><span>&#39;t&#39;</span><span>},</span><span>
                </span><span>{},</span><span> </span><span>// no match
</span><span>            </span><span>};</span><span>
            </span><span>static</span><span> </span><span>int</span><span> </span><span>value</span><span>[</span><span>8</span><span>]</span><span> </span><span>=</span><span> </span><span>{</span><span>
                </span><span>-1</span><span>,</span><span>
                </span><span>22</span><span>,</span><span>
                </span><span>-1</span><span>,</span><span>
                </span><span>19</span><span>,</span><span>
                </span><span>20</span><span>,</span><span>
                </span><span>21</span><span>,</span><span>
                </span><span>14</span><span>,</span><span>
                </span><span>-1</span><span>,</span><span>
            </span><span>};</span><span>
            </span><span>uint32_t</span><span> </span><span>w3</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span><span>
            </span><span>memcpy</span><span>(</span><span>&amp;</span><span>w3</span><span>,</span><span> </span><span>&amp;</span><span>s</span><span>[</span><span>2</span><span>],</span><span> </span><span>4</span><span>);</span><span>
            </span><span>const</span><span> </span><span>uint64_t</span><span> </span><span>idx</span><span> </span><span>=</span><span> </span><span>_pext_u64</span><span>(</span><span>w3</span><span>,</span><span> </span><span>0x10101000</span><span>);</span><span>
            </span><span>if</span><span> </span><span>(</span><span>memcmp</span><span>(</span><span>lookup</span><span>[</span><span>idx</span><span>],</span><span> </span><span>s</span><span>.</span><span>data</span><span>(),</span><span> </span><span>sizeof</span><span>(</span><span>lookup</span><span>[</span><span>0</span><span>]))</span><span> </span><span>==</span><span> </span><span>0</span><span>)</span><span> </span><span>{</span><span>
                </span><span>return</span><span> </span><span>value</span><span>[</span><span>idx</span><span>];</span><span>
            </span><span>}</span><span>
        </span><span>}</span><span>
        </span><span>break</span><span>;</span><span>
        </span><span>// ...
</span><span>    </span><span>}</span><span>
    </span><span>return</span><span> </span><span>-1</span><span>;</span><span>
</span><span>}</span>
</pre>
<div id="variable-length-set-of-words">
<h3>Variable-length set of words</h3>
<p>Having strings of the same length is not a strict requirement.
We always can complete the past-end characters with some
easy-to-compute values. The following values were tested during
writing this text:</p>
<ul>
<li>zero (0x00),</li>
<li>the first character,</li>
<li>the last character,</li>
<li>the input length,</li>
<li>the first/last character combined with the input length.</li>
</ul>
<p>Depending on the chosen method and string set, the outcome differs.
Including length and one of chars <em>seems</em> to help. However, pre-classifying
inputs by their length appeared to be easier and faster, thus this topic is
not covered here.</p>
</div>
<div id="finding-mask">
<h3>Finding mask</h3>
<p>Finding the mask is surprisingly straightforward. We start with a full mask,
and iterate over all bits. For each bit we unset it, and then we check if the
set of masked bytes is still unique. If it&#39;s true, we keep that bit unset,
otherwise revert the change.</p>
<p>Below are shown two procedures that compute the mask.</p>
<pre><span>func</span><span> </span><span>computeMask</span><span>(</span><span>words</span><span> </span><span>[]</span><span>Keyword</span><span>)</span><span> </span><span>(</span><span>mask</span><span> </span><span>[]</span><span>byte</span><span>,</span><span> </span><span>err</span><span> </span><span>error</span><span>)</span><span> </span><span>{</span><span>
    </span><span>max</span><span> </span><span>:=</span><span> </span><span>0</span><span>
    </span><span>for</span><span> </span><span>_</span><span>,</span><span> </span><span>w</span><span> </span><span>:=</span><span> </span><span>range</span><span> </span><span>words</span><span> </span><span>{</span><span>
        </span><span>if</span><span> </span><span>n</span><span> </span><span>:=</span><span> </span><span>len</span><span>(</span><span>w</span><span>.</span><span>word</span><span>);</span><span> </span><span>n</span><span> </span><span>&gt;</span><span> </span><span>max</span><span> </span><span>{</span><span>
            </span><span>max</span><span> </span><span>=</span><span> </span><span>n</span><span>
        </span><span>}</span><span>
    </span><span>}</span><span>

    </span><span>mask</span><span> </span><span>=</span><span> </span><span>make</span><span>([]</span><span>byte</span><span>,</span><span> </span><span>max</span><span>)</span><span>
    </span><span>for</span><span> </span><span>i</span><span> </span><span>:=</span><span> </span><span>range</span><span> </span><span>mask</span><span> </span><span>{</span><span>
        </span><span>mask</span><span>[</span><span>i</span><span>]</span><span> </span><span>=</span><span> </span><span>0xff</span><span>
    </span><span>}</span><span>

    </span><span>ok</span><span> </span><span>:=</span><span> </span><span>checksamesize</span><span>(</span><span>words</span><span>,</span><span> </span><span>mask</span><span>)</span><span>
    </span><span>if</span><span> </span><span>!</span><span>ok</span><span> </span><span>{</span><span>
        </span><span>err</span><span> </span><span>=</span><span> </span><span>fmt</span><span>.</span><span>Errorf</span><span>(</span><span>&#34;set of words is not unique&#34;</span><span>)</span><span>
        </span><span>return</span><span>
    </span><span>}</span><span>

    </span><span>for</span><span> </span><span>byteIdx</span><span> </span><span>:=</span><span> </span><span>0</span><span>;</span><span> </span><span>byteIdx</span><span> </span><span>&lt;</span><span> </span><span>max</span><span>;</span><span> </span><span>byteIdx</span><span>++</span><span> </span><span>{</span><span>
        </span><span>for</span><span> </span><span>bitIdx</span><span> </span><span>:=</span><span> </span><span>0</span><span>;</span><span> </span><span>bitIdx</span><span> </span><span>&lt;</span><span> </span><span>8</span><span>;</span><span> </span><span>bitIdx</span><span>++</span><span> </span><span>{</span><span>
            </span><span>old</span><span> </span><span>:=</span><span> </span><span>mask</span><span>[</span><span>byteIdx</span><span>]</span><span>
            </span><span>mask</span><span>[</span><span>byteIdx</span><span>]</span><span> </span><span>&amp;=</span><span> </span><span>^(</span><span>1</span><span> </span><span>&lt;&lt;</span><span> </span><span>bitIdx</span><span>)</span><span>
            </span><span>if</span><span> </span><span>!</span><span>checksamesize</span><span>(</span><span>words</span><span>,</span><span> </span><span>mask</span><span>)</span><span> </span><span>{</span><span>
                </span><span>mask</span><span>[</span><span>byteIdx</span><span>]</span><span> </span><span>=</span><span> </span><span>old</span><span>
            </span><span>}</span><span>
        </span><span>}</span><span>
    </span><span>}</span><span>

    </span><span>return</span><span>
</span><span>}</span><span>

</span><span>func</span><span> </span><span>checksamesize</span><span>(</span><span>words</span><span> </span><span>[]</span><span>Keyword</span><span>,</span><span> </span><span>mask</span><span> </span><span>[]</span><span>byte</span><span>)</span><span> </span><span>bool</span><span> </span><span>{</span><span>
    </span><span>M</span><span> </span><span>:=</span><span> </span><span>make</span><span>(</span><span>map</span><span>[</span><span>string</span><span>]</span><span>struct</span><span>{})</span><span>
    </span><span>word</span><span> </span><span>:=</span><span> </span><span>make</span><span>([]</span><span>byte</span><span>,</span><span> </span><span>len</span><span>(</span><span>mask</span><span>))</span><span>
    </span><span>for</span><span> </span><span>i</span><span> </span><span>:=</span><span> </span><span>range</span><span> </span><span>words</span><span> </span><span>{</span><span>
        </span><span>for</span><span> </span><span>j</span><span> </span><span>:=</span><span> </span><span>range</span><span> </span><span>mask</span><span> </span><span>{</span><span>
            </span><span>word</span><span>[</span><span>j</span><span>]</span><span> </span><span>=</span><span> </span><span>words</span><span>[</span><span>i</span><span>].</span><span>word</span><span>[</span><span>j</span><span>]</span><span> </span><span>&amp;</span><span> </span><span>mask</span><span>[</span><span>j</span><span>]</span><span>
        </span><span>}</span><span>

        </span><span>s</span><span> </span><span>:=</span><span> </span><span>string</span><span>(</span><span>word</span><span>)</span><span>
        </span><span>_</span><span>,</span><span> </span><span>ok</span><span> </span><span>:=</span><span> </span><span>M</span><span>[</span><span>s</span><span>]</span><span>
        </span><span>if</span><span> </span><span>ok</span><span> </span><span>{</span><span>
            </span><span>return</span><span> </span><span>false</span><span>
        </span><span>}</span><span>
        </span><span>M</span><span>[</span><span>s</span><span>]</span><span> </span><span>=</span><span> </span><span>struct</span><span>{}{}</span><span>
    </span><span>}</span><span>

    </span><span>return</span><span> </span><span>true</span><span>
</span><span>}</span>
</pre>
</div>
<div id="loads">
<h3>Loads</h3>
<p>As it was shown in examples above, often a single load is sufficient, as the
significant bits fit in a 8-, 16-, 32-, or 64-bit word.</p>
<p>However, sometimes more loads are needed. In the generic case we concatenate
results of individual loads, forming a 32- or 64-bit word. Below is an example
of such code, where we combine 8-bit and 16-bit input words into a single 32-bit
word, which is the final argument to <tt>PEXT</tt>. Note that the we need only to
concatenate values in runtime, the mask for <tt>PEXT</tt> is know in the
compile-time.</p>
<pre><span>uint32_t</span><span> </span><span>w1</span><span>;</span><span>
</span><span>uint16_t</span><span> </span><span>w2</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span><span>
</span><span>memcpy</span><span>(</span><span>&amp;</span><span>w2</span><span>,</span><span> </span><span>&amp;</span><span>s</span><span>[</span><span>0</span><span>],</span><span> </span><span>2</span><span>);</span><span>
</span><span>w1</span><span> </span><span>=</span><span> </span><span>uint32_t</span><span>(</span><span>w2</span><span>);</span><span>
</span><span>const</span><span> </span><span>uint8_t</span><span> </span><span>w3</span><span> </span><span>=</span><span> </span><span>s</span><span>[</span><span>2</span><span>];</span><span>
</span><span>w1</span><span> </span><span>|=</span><span> </span><span>(</span><span>uint32_t</span><span>(</span><span>w3</span><span>)</span><span> </span><span>&lt;&lt;</span><span> </span><span>16</span><span>);</span><span>
</span><span>const</span><span> </span><span>uint64_t</span><span> </span><span>idx</span><span> </span><span>=</span><span> </span><span>_pext_u64</span><span>(</span><span>w1</span><span>,</span><span> </span><span>0x1e1104</span><span>);</span>
</pre>
<p>Another possibility is when we have exactly two loads and their masks do
not collide, their bit-and result is zero. Then we can merge these two
words; sample code for such case is shown below.</p>
<pre><span>uint16_t</span><span> </span><span>w7</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span><span>
</span><span>memcpy</span><span>(</span><span>&amp;</span><span>w7</span><span>,</span><span> </span><span>&amp;</span><span>s</span><span>[</span><span>10</span><span>],</span><span> </span><span>2</span><span>);</span><span>
</span><span>const</span><span> </span><span>uint8_t</span><span> </span><span>w8</span><span> </span><span>=</span><span> </span><span>s</span><span>[</span><span>2</span><span>];</span><span>
</span><span>const</span><span> </span><span>uint16_t</span><span> </span><span>w9</span><span> </span><span>=</span><span> </span><span>(</span><span>uint16_t</span><span>(</span><span>w7</span><span>)</span><span> </span><span>&amp;</span><span> </span><span>0x410</span><span>)</span><span> </span><span>|</span><span> </span><span>(</span><span>uint16_t</span><span>(</span><span>w8</span><span>)</span><span> </span><span>&amp;</span><span> </span><span>0x4</span><span>);</span><span>
</span><span>const</span><span> </span><span>uint64_t</span><span> </span><span>idx</span><span> </span><span>=</span><span> </span><span>_pext_u64</span><span>(</span><span>w9</span><span>,</span><span> </span><span>0x414</span><span>);</span>
</pre>
</div>
</div></div>
  </body>
</html>
