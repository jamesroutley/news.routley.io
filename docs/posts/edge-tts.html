<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/rany2/edge-tts">Original</a>
    <h1>Edge TTS</h1>
    
    <div id="readability-page-1" class="page"><article><p>This is one of the first problems I’ve seen that I have <em>not</em> liked the answer that Neetcode gave</p>
<blockquote>
<p>at least in his solution video - he does offer several approaches on his site.</p>
</blockquote>
<p>In his (youtube) answer, we essentially have to handle 6 different cases for every search iteration. It’s like this compound of logic, where we use comparisons of the left side of the window with the middle and the middle with the target to see which way we should “travel” with our next window/middle calculation depending on which side of the “pivot point” we determine we are.</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="js" data-theme="github-light github-dark"><code data-language="js" data-theme="github-light github-dark"><span data-line=""><span>class</span><span> Solution</span><span> {</span></span>
<span data-line=""><span>    /**</span></span>
<span data-line=""><span>     * </span><span>@param</span><span> {number[]}</span><span> nums</span></span>
<span data-line=""><span>     * </span><span>@param</span><span> {number}</span><span> target</span></span>
<span data-line=""><span>     * </span><span>@return</span><span> {number}</span></span>
<span data-line=""><span>     */</span></span>
<span data-line=""><span>    search</span><span>(</span><span>nums</span><span>, </span><span>target</span><span>) {</span></span>
<span data-line=""><span>        let</span><span> l </span><span>=</span><span> 0</span><span>, r </span><span>=</span><span> nums.</span><span>length</span><span> -</span><span> 1</span><span>;</span></span>
<span data-line=""> </span>
<span data-line=""><span>        while</span><span> (l </span><span>&lt;=</span><span> r) {</span></span>
<span data-line=""><span>            const</span><span> mid</span><span> =</span><span> Math.</span><span>floor</span><span>((l </span><span>+</span><span> r) </span><span>/</span><span> 2</span><span>);</span></span>
<span data-line=""><span>            if</span><span> (target </span><span>===</span><span> nums[mid]) {</span></span>
<span data-line=""><span>                return</span><span> mid;</span></span>
<span data-line=""><span>            }</span></span>
<span data-line=""> </span>
<span data-line=""><span>            if</span><span> (nums[l] </span><span>&lt;=</span><span> nums[mid]) {</span></span>
<span data-line=""><span>                if</span><span> (target </span><span>&gt;</span><span> nums[mid] </span><span>||</span><span> target </span><span>&lt;</span><span> nums[l]) {</span></span>
<span data-line=""><span>                    l </span><span>=</span><span> mid </span><span>+</span><span> 1</span><span>;</span></span>
<span data-line=""><span>                } </span><span>else</span><span> {</span></span>
<span data-line=""><span>                    r </span><span>=</span><span> mid </span><span>-</span><span> 1</span><span>;</span></span>
<span data-line=""><span>                }</span></span>
<span data-line=""><span>            } </span><span>else</span><span> {</span></span>
<span data-line=""><span>                if</span><span> (target </span><span>&lt;</span><span> nums[mid] </span><span>||</span><span> target </span><span>&gt;</span><span> nums[r]) {</span></span>
<span data-line=""><span>                    r </span><span>=</span><span> mid </span><span>-</span><span> 1</span><span>;</span></span>
<span data-line=""><span>                } </span><span>else</span><span> {</span></span>
<span data-line=""><span>                    l </span><span>=</span><span> mid </span><span>+</span><span> 1</span><span>;</span></span>
<span data-line=""><span>                }</span></span>
<span data-line=""><span>            }</span></span>
<span data-line=""><span>        }</span></span>
<span data-line=""><span>        return</span><span> -</span><span>1</span><span>;</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""><span>}</span></span></code></pre></figure>
<p>Watching Neetcode, I can see that it clearly makes sense to him, but to me it’s just so much index fiddling and abstract window logic that I know that it would take a me a really long time to be able to do this under pressure, and I probably would achieve that <em>mostly</em> through memorization. So hats off to him for really being able to grok it in the moment, while explaining it.</p>
<p>In the comments, a few people mentioned the strategy of breaking down the problem by first <em>finding</em> the pivot point, and immediately this felt like the more reasonable way to do this problem. It also is what I intuitively thought of first, but my brain has grown weary from leetcode and I reached out to see what others were doing before testing that potentially faulty hypothesis (I know - I might have taken my philosophy of “learn from others with more experience and conserve my own problem-solving energy” a little too far).</p>
<p>Although this problem chunking approach requires writing three separate functions, only one of those functions is challenging AND novel - <code>findPivot</code></p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>function</span><span> findPivot</span><span>(</span><span>nums</span><span>:</span><span> number</span><span>[])</span><span>:</span><span> number</span><span> {</span></span>
<span data-line=""><span>    let</span><span> left </span><span>=</span><span> 0</span><span>;</span></span>
<span data-line=""><span>    let</span><span> right </span><span>=</span><span> nums.</span><span>length</span><span> -</span><span> 1</span><span>;</span></span>
<span data-line=""> </span>
<span data-line=""><span>    if</span><span> (nums[left] </span><span>&lt;=</span><span> nums[right]) </span><span>return</span><span> 0</span><span>;</span></span>
<span data-line=""> </span>
<span data-line=""><span>    while</span><span> (left </span><span>&lt;=</span><span> right) {</span></span>
<span data-line=""> </span>
<span data-line=""><span>        const</span><span> mid</span><span> =</span><span> Math.</span><span>floor</span><span>((left </span><span>+</span><span> right) </span><span>/</span><span> 2</span><span>);</span></span>
<span data-line=""><span>        </span></span>
<span data-line=""><span>        if</span><span> (nums[mid] </span><span>&gt;</span><span> nums[mid </span><span>+</span><span> 1</span><span>]) </span><span>return</span><span> mid </span><span>+</span><span> 1</span><span>;</span></span>
<span data-line=""><span>        if</span><span> (nums[mid </span><span>-</span><span> 1</span><span>] </span><span>&gt;</span><span> nums[mid]) </span><span>return</span><span> mid;</span></span>
<span data-line=""> </span>
<span data-line=""><span>        if</span><span> (nums[left] </span><span>&lt;=</span><span> nums[mid]) {</span></span>
<span data-line=""><span>            left </span><span>=</span><span> mid </span><span>+</span><span> 1</span><span>;</span></span>
<span data-line=""><span>        } </span><span>else</span><span> {</span></span>
<span data-line=""><span>            right </span><span>=</span><span> mid </span><span>-</span><span> 1</span><span>;</span></span>
<span data-line=""><span>        }</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""> </span>
<span data-line=""><span>    return</span><span> 0</span><span>; </span><span>// Default case (shouldn&#39;t reach here)</span></span>
<span data-line=""><span>}</span></span>
<span data-line=""> </span>
<span data-line=""><span>// Standard binary search on a sorted array</span></span>
<span data-line=""><span>function</span><span> binarySearch</span><span>(</span><span>nums</span><span>:</span><span> number</span><span>[], </span><span>target</span><span>:</span><span> number</span><span>, </span><span>start</span><span>:</span><span> number</span><span>, </span><span>end</span><span>:</span><span> number</span><span>)</span><span>:</span><span> number</span><span> {</span></span>
<span data-line=""><span>    while</span><span> (start </span><span>&lt;=</span><span> end) {</span></span>
<span data-line=""><span>        const</span><span> mid</span><span> =</span><span> Math.</span><span>floor</span><span>((start </span><span>+</span><span> end) </span><span>/</span><span> 2</span><span>);</span></span>
<span data-line=""> </span>
<span data-line=""><span>        if</span><span> (nums[mid] </span><span>===</span><span> target) </span><span>return</span><span> mid;</span></span>
<span data-line=""><span>        </span></span>
<span data-line=""><span>        if</span><span> (nums[mid] </span><span>&lt;</span><span> target) {</span></span>
<span data-line=""><span>            start </span><span>=</span><span> mid </span><span>+</span><span> 1</span><span>;</span></span>
<span data-line=""><span>        } </span><span>else</span><span> {</span></span>
<span data-line=""><span>            end </span><span>=</span><span> mid </span><span>-</span><span> 1</span><span>;</span></span>
<span data-line=""><span>        }</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""> </span>
<span data-line=""><span>    return</span><span> -</span><span>1</span><span>;</span></span>
<span data-line=""><span>}</span></span>
<span data-line=""> </span>
<span data-line=""><span>// Main function to search in rotated array</span></span>
<span data-line=""><span>function</span><span> search</span><span>(</span><span>nums</span><span>:</span><span> number</span><span>[], </span><span>target</span><span>:</span><span> number</span><span>)</span><span>:</span><span> number</span><span> {</span></span>
<span data-line=""><span>    if</span><span> (nums.</span><span>length</span><span> ===</span><span> 0</span><span>) </span><span>return</span><span> -</span><span>1</span><span>;</span></span>
<span data-line=""><span>    </span></span>
<span data-line=""><span>    // Find the pivot point</span></span>
<span data-line=""><span>    const</span><span> pivot</span><span> =</span><span> findPivot</span><span>(nums);</span></span>
<span data-line=""><span>    if</span><span> (pivot </span><span>&gt;</span><span> 0</span><span> &amp;&amp;</span><span> target </span><span>&gt;=</span><span> nums[</span><span>0</span><span>]) </span><span>return</span><span> binarySearch</span><span>(nums, target, </span><span>0</span><span>, pivot </span><span>-</span><span> 1</span><span>);</span></span>
<span data-line=""><span>    return</span><span> binarySearch</span><span>(nums, target, pivot, nums.</span><span>length</span><span> -</span><span> 1</span><span>);</span></span>
<span data-line=""><span>}</span></span></code></pre></figure>
<p>At the very least, the <code>findPivot</code> function feels like a great encapsulation of navigating a rotated array.</p>
<p>Despite disagreeing with his recommended implementation within the context of coding interviews, I <em>still</em> am taking a page out of Neetcode’s book - I decided to record my exploration and understanding of this <code>findPivot</code> function and its edge cases so I could grok it a bit better. I found the process of explaining my code on paper really helpful:</p>
<video src="https://thornberry-obsidian-general.s3.us-east-2.amazonaws.com/attachments/b2970ad4465afd035a51fa1cc762dd5e.mov" controls=""></video></article></div>
  </body>
</html>
