<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://simonwillison.net/2022/May/23/bundling-binary-tools-in-python-wheels/">Original</a>
    <h1>Bundling binary tools in Python wheels</h1>
    
    <div id="readability-page-1" class="page"><div id="primary">

<div>




<p>I spotted a new (to me) pattern which I think is pretty interesting: projects are bundling compiled binary applications as part of their Python packaging wheels. I think it’s really neat.</p>
<h4>pip install ziglang</h4>
<p><a href="https://ziglang.org/">Zig</a> is a new programming language lead by Andrew Kelley that sits somewhere near Rust: Wikipedia <a href="https://en.wikipedia.org/wiki/Zig_(programming_language)">calls it</a> an “imperative, general-purpose, statically typed, compiled system programming language”.</p>
<p>One of its most notable features is that it bundles its own C/C++ compiler, as a “hermetic” compiler—it’s completely standalone, unaffected by the system that it is operating within. I learned about this usage of the word hermetic this morning from <a href="https://jakstys.lt/2022/how-uber-uses-zig/">How Uber Uses Zig</a> by Motiejus Jakštys.</p>
<p>The concept reminds me of Gregory Szorc’s <a href="https://github.com/indygreg/python-build-standalone">python-build-standalone</a>, which provides redistributable Python builds and was key to getting <a href="https://simonwillison.net/2021/Sep/8/datasette-desktop/">my Datasette Desktop Electron application</a> working with its own hermetic build of Python.</p>
<p>One of the options provided for installing Zig (and its bundled toolchain) is <a href="https://github.com/ziglang/zig-pypi/blob/main/README.pypi.md">to use pip</a>:</p>
<div><pre>% pip install ziglang
...
% python -m ziglang cc --help
OVERVIEW: clang LLVM compiler

USAGE: zig [options] file...

OPTIONS:
  -#<span><span>#</span>#                    Print (but do not run) the commands to run for this compilation</span>
  --amdgpu-arch-tool=<span>&lt;</span>value<span>&gt;</span>
                          Tool used <span>for</span> <span>detecting AMD GPU arch</span> <span>in</span> the system.
...</pre></div>
<p>This means you can now <code>pip install</code> a full C compiler for your current platform!</p>
<p>The way this works is really simple. The <code>ziglang</code> package that you install has two key files: A <code>zig</code> binary (155MB on my system) containing the full Zig compiled implementation, and a <code>__main__.py</code> module containing the following:</p>
<pre><span>import</span> <span>os</span>, <span>sys</span>, <span>subprocess</span>
<span>sys</span>.<span>exit</span>(<span>subprocess</span>.<span>call</span>([
    <span>os</span>.<span>path</span>.<span>join</span>(<span>os</span>.<span>path</span>.<span>dirname</span>(<span>__file__</span>), <span>&#34;zig&#34;</span>),
    <span>*</span><span>sys</span>.<span>argv</span>[<span>1</span>:]
]))</pre>
<p>The package also bundles <code>lib</code> and <code>doc</code> folders with supporting files used by Zig itself, unrelated to Python.</p>
<p>The Zig project then bundles and ships eight different Python wheels targetting different platforms. <a href="https://github.com/ziglang/zig-pypi/blob/de14cf728fa35c014821f62a4fa9abd9f4bb560e/make_wheels.py#L115-L124">Here’s their code</a> that does that, which lists the platforms that are supported:</p>
<pre><span>for</span> <span>zig_platform</span>, <span>python_platform</span> <span>in</span> {
    <span>&#39;windows-i386&#39;</span>:   <span>&#39;win32&#39;</span>,
    <span>&#39;windows-x86_64&#39;</span>: <span>&#39;win_amd64&#39;</span>,
    <span>&#39;macos-x86_64&#39;</span>:   <span>&#39;macosx_10_9_x86_64&#39;</span>,
    <span>&#39;macos-aarch64&#39;</span>:  <span>&#39;macosx_11_0_arm64&#39;</span>,
    <span>&#39;linux-i386&#39;</span>:     <span>&#39;manylinux_2_12_i686.manylinux2010_i686&#39;</span>,
    <span>&#39;linux-x86_64&#39;</span>:   <span>&#39;manylinux_2_12_x86_64.manylinux2010_x86_64&#39;</span>,
    <span>&#39;linux-armv7a&#39;</span>:   <span>&#39;manylinux_2_17_armv7l.manylinux2014_armv7l&#39;</span>,
    <span>&#39;linux-aarch64&#39;</span>:  <span>&#39;manylinux_2_17_aarch64.manylinux2014_aarch64&#39;</span>,
}.<span>items</span>():
    <span># Build the wheel here...</span></pre>
<p>They <a href="https://github.com/ziglang/zig-pypi/blob/main/README.pypi.md#usage">suggest</a> that if you want to run their tools from a Python program you do so like this, to ensure your script can find the installed binary:</p>
<pre><span>import</span> <span>sys</span>, <span>subprocess</span>

<span>subprocess</span>.<span>call</span>([<span>sys</span>.<span>executable</span>, <span>&#34;-m&#34;</span>, <span>&#34;ziglang&#34;</span>])</pre>
<p>I find this whole approach pretty fascinating. I really love the idea that I can add a full C/C++ compiler as a dependency to any of my Python projects, and thanks to Python wheels I’ll automatically get a binary excutable compiled for my current platform.</p>
<h4>Playwright Python</h4>
<p>I spotted another example of this pattern recently in <a href="https://playwright.dev/python/docs/intro">Playwright Python</a>. Playwright is Microsoft’s open source browser automation and testing framework—a kind of modern Selenium. I used it recently to build my <a href="https://shot-scraper.datasette.io/">shot-scraper</a> screenshot automation tool.</p>
<p>Playwright provides a full-featured API for controlling headless (and headful) browser instances, with implementations in Node.js, Python, Java and .NET.</p>
<p>I was intrigued as to how they had developed such a sophisticated API for four different platforms/languages at once, providing full equivalence for all of their features across all four.</p>
<p>So I dug around in their Python package (from <code>pip install playwright</code>) and found this:</p>
<p><code>77M ./venv/lib/python3.10/site-packages/playwright/driver/node</code></p>
<p>That’s a full copy of the Node.js binary!</p>
<pre><code>% ./venv/lib/python3.10/site-packages/playwright/driver/node --version
v16.13.0
</code></pre>
<p>Playwright Python works by providing a Python layer on top of the existing JavaScript API library. It runs a Node.js process which does the actual work, the Python library just communicates with the JavaScript for you.</p>
<p>As with Zig, the Playwright team offer <a href="https://pypi.org/project/playwright/#files">seven pre-compiled wheels</a> for different platforms. The list today is:</p>
<ul>
<li><code>playwright-1.22.0-py3-none-win_amd64.whl</code></li>
<li><code>playwright-1.22.0-py3-none-win32.whl</code></li>
<li><code>playwright-1.22.0-py3-none-manylinux_2_17_aarch64.manylinux2014_aarch64.whl</code></li>
<li><code>playwright-1.22.0-py3-none-manylinux1_x86_64.whl</code></li>
<li><code>playwright-1.22.0-py3-none-macosx_11_0_universal2.whl</code></li>
<li><code>playwright-1.22.0-py3-none-macosx_11_0_arm64.whl</code></li>
<li><code>playwright-1.22.0-py3-none-macosx_10_13_x86_64.whl</code></li>
</ul>
<p>I wish I could say &#34;you can now <code>pip install</code> a browser!&#34; but Playwright doesn’t actually bundle the browsers themselves—you need to run <code>python -m playwright install</code> to download those separately.</p>
<p>Pretty fascinating example of the same pattern though!</p>
<h4>pip install a SQLite database</h4>
<p>It’s not quite the same thing, since it’s not packaging an executable, but the one project I have that fits this mould if you squint a little is my <a href="https://datasette.io/plugins/datasette-basemap">datasette-basemap</a> plugin.</p>
<p>It’s a Datasette plugin which bundles a 23MB SQLite database file containing OpenStreetMap tiles for the first seven zoom levels of their world map—5,461 tile images total.</p>
<p>I built it so that people could use my <a href="https://datasette.io/plugins/datasette-cluster-map">datasette-cluster-map</a> and <a href="https://datasette.io/plugins/datasette-leaflet-geojson">datasette-leaflet-geojson</a> entirely standalone, without needing to load tiles from a central tile server.</p>
<p>You can <a href="https://datasette-tiles-demo.datasette.io/-/tiles/basemap">play with a demo here</a>. I wrote more about that project in <a href="https://simonwillison.net/2021/Feb/4/datasette-tiles/">Serving map tiles from SQLite with MBTiles and datasette-tiles</a>. It’s pretty fun to be able to run <code>pip install datasette-basemap</code> to install a full map of the world.</p>
<p>Seen any other interesting examples of <code>pip install</code> being (ab)used in this way? Ping them to me <a href="https://twitter.com/simonw/status/1528754782311047168">on Twitter</a>.</p>
<p><strong>Update:</strong>  Paul O’Leary McCann <a href="https://twitter.com/polm23/status/1528937321139122177">points out</a> that PyPI has a default 60MB size limit for packages, though it can be raised on a case-by-case basis. He wrote about this in <a href="https://www.dampfkraft.com/code/distributing-large-files-with-pypi.html">Distributing Large Files with PyPI Packages</a>.</p>




</div>

</div></div>
  </body>
</html>
