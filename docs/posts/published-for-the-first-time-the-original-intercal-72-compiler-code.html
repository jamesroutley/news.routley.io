<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://esoteric.codes/blog/published-for-the-first-time-the-original-intercal72-compiler-code">Original</a>
    <h1>Published for the first time: the original INTERCAL-72 compiler code</h1>
    
    <div id="readability-page-1" class="page"><p>, the first artist&#39;s monograph of esolangs. </p><p>.
            <a href="https://mitpress.mit.edu/9780262553087/forty-four-esolangs/"><img src="https://esoteric.codes/images/forty-four.png"/></a></p><div>
                <p><img src="https://esoteric.codes/uploads/c164fd0b-de22-4dd6-919e-881b023dbe6d/ical-header.png" alt="" width="" height=""/></p>
<p>It is with great excitement that we share the original INTERCAL-72 compiler source code, as both scans and transcriptions (see below). INTERCAL was created by Don Woods (<a href="https://esoteric.codes/blog/don-woods" target="_blank" rel="noopener">previously interviewed here</a>) and Jim Lyon as undergrads at Princeton during an infamous late-night session after freshman finals. Don recently rediscovered a print-out of the green-barred, continuous-feed pages of SPITBOL source code for ical.sbl, the original INTERCAL-72 compiler. This code had not been run (as far as we know) since his Princeton days. Sean Haas (of the <a href="https://adventofcomputing.com/" target="_blank" rel="noopener">Advent of Computing</a> podcast) and I transcribed the code from these fading pages, checking each others&#39; work as we went.</p>
<p>INTERCAL (&#34;Compiler Language with No Pronounceable Acronym&#34;) is the first language that can unequivocally be called an esolang. While previous languages had odd designs as pl research and experimentation, INTERCAL intentionally subverts the programmer&#39;s effort to write what Dijkstra called &#34;good code&#34;: that which &#34;shortens the conceptual gap between the static program and the dynamic process.&#34; In INTERCAL, code is circuitous, full of symbols used in bizarre ways and with unique designations (# is called the &#34;mesh&#34; sign). It is a challenge to read or to run in ones head, even for those deeply immersed in the language. Furthermore, it does this for parody and play, not with any practical aim in mind.</p>
<p>The length of INTERCAL&#39;s shadow cannot be overstated. It was twenty years after its creation that a series of minimalist languages (FALSE, Befunge, brainfuck) took the next steps toward what would become the esolang movement. INTERCAL-72 offered somewhat of a different path from these; it was less concerned with minimalism, and more explicitly dramatized the act of programming. Woods and his collaborator, Jim Lyons, described it as eschewing conventions of languages like ALGOL, SNOBOL, FOCAL, and AP/I, yet it also works as parody, embracing and exaggerating their worst eccentricities and inefficiencies, to create an intentionally alienating experience.</p>
<p>INTERCAL&#39;s most striking feature is its humanizing of the interpreter, a mercurial being who we literally plead with to get our programs to run, using the command PLEASE. Use PLEASE too little and the interpreter will be offended and ignore the whole program; use it too much and it writes you off as a suck-up and... also ignore the whole program. Its subjectivity, even in this basic form, feels particularly relevant in an age when AI systems are designed to deliberately confuse the human and algorithmic. The influence of just this one feature can be seen in early parody languages like Chicken and Ook! that undermine the seriousness of the interpreter, to <a href="https://esolangs.org/wiki/English" target="_blank" rel="noopener">English</a>, where the interpreter was once literally another person but is now downgraded to an AI prompt system, as well as the mostly-forgotten, jokey &#34;political&#34; esolangs where the interpreter takes on the irrational belief systems of Trump or Modi. More personally, INTERCAL&#39;s interpreter was directly referenced by my <a href="https://github.com/rottytooth/Olympus" target="_blank" rel="noopener">language Olympus</a>, where it takes on many, competing personalities in the form of the Greek gods, any of which might become offended and ignore the rest of the program, in INTERCAL style.</p>
<p>However, for such an influential esolang, it is one that we experience primarily in bastardized form. The most well-known INTERCAL keyword (apart from PLEASE) is not part of the INTERCAL-72 language at all. That would be the COME FROM statement, an inverse of GOTO, where one has to trace back jumps from destination to source, like cheating in a choose-your-own-adventure book. It was added in 1990 by Eric S Raymond (<a href="https://esoteric.codes/blog/interview-with-eric-s-raymond" target="_blank" rel="noopener">interviewed here</a>) for his adaptation C-INTERCAL. The original INTERCAL-72 compiler never left Princeton according to Woods; it is likely that ESR worked from the INTERCAL-72 manual without access to the reference compiler. Almost all who have used the language since then have actually used C-INTERCAL or one of its successors (CLC-INTERCAL etc). These later versions capture much of the spirit of the original but differ in significant ways in both style and content. Now, with access to the original, we can experience INTERCAL-72 first hand and make new discoveries.</p>
<p>Sean Haas describes the process of getting the ical.sbl (INTERCAL compiler) program running on a modern system, using SPITBOLx64. As he points out, ICAL is actually a transpiler; some of its infamous slowness is due to the overhead of generating a SPITBOL program and executing it. More surprisingly, it avoids SPITBOL&#39;s math functions, performing math through pure string manipulation. Sean discusses this in the latest episode of his podcast, <a href="https://adventofcomputing.com/" target="_blank" rel="noopener">Advent of Computing</a>, explaining the infamous thirty seconds needed to do a single division:</p>
<blockquote><span>The two operations you get, called MINGLE and SELECT, operate on binary data. Internally, ICAL will store numbers as a string of binary digits. A 4 becomes &#34;100&#34;, for instance. When you operate on that number it&#39;s done as a string operation. That is, again, inherently slower than a mathematical operation. The result is that any operation with numbers become this convoluted mess, both in INTERCAL and in the final output SPITBOL. Hence, 30 second divides.</span></blockquote>
<p>The full set of scans and transcribed code <a href="https://github.com/rottytooth/INTERCAL72" target="_blank" rel="noopener">can be found on GitHub</a>.</p>
<p><a href="https://github.com/rottytooth/INTERCAL72/tree/main" target="_blank" rel="noopener"><img src="https://github.com/rottytooth/INTERCAL72/blob/main/scans/ical-01.jpeg?raw=true" alt="" width="404" height="554"/></a> <a href="https://github.com/rottytooth/INTERCAL72" target="_blank" rel="noopener"><img src="https://github.com/rottytooth/INTERCAL72/blob/main/scans/ical-02.jpeg?raw=true" alt="" width="404" height="556"/></a></p>
<p><a href="https://github.com/rottytooth/INTERCAL72" target="_blank" rel="noopener"><strong>The full set of the scans and transcriptions can be found here...</strong></a></p>
            </div><p>, the first artist&#39;s monograph of esolangs. </p><p>.
            </p></div>
  </body>
</html>
