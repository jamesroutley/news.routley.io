<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.lbjgruppen.com/en/posts/flocking-quadtrees">Original</a>
    <h1>Functional Flocking Quadtree in ClojureScript</h1>
    
    <div id="readability-page-1" class="page"><div id="id4fe611ed-e871-8fb9-75be-07d4c8c7ded3"><div><div id="ida9193806-df2c-b277-db13-298f64fe45a9" name=""><p id="id64f6d349-6819-7098-7fce-4caee87eb2db">In a <a href="https://lbjgruppen.com/en/posts/functional-quadtree-clojure" target="_blank">recent blogpost</a> I demonstrated how to build purely functional quadtrees in submilliseconds and this week I&#39;ll take it up a notch and show how to add multiple focal points and add some boid flocking logic.</p><h2 id="idbee3e2fa-7f71-94fb-e1c0-d0dd826d3868">A demo</h2><p id="id2c389d9e-acec-5002-5354-9f0af44d9811">Below you should see 200 boids acting as individuals when apart and as flocks when closer together.</p><h2 id="id8dfc9dbe-af48-2dae-2202-6eff80c71909">How to flock</h2><p id="id2506ca31-82af-29d1-d61c-665cb8f549eb">To build this simulation, assuming you&#39;ve read how to build a functional quadtree, we need only 3 things</p><ul><li>A way to represent a Boid</li><li>Some fast way to get it&#39;s closest neighbors</li><li>Figure out how these neighbors interact</li></ul><p id="idabc82059-189c-e1b1-4853-f09bc2353aa2">So let&#39;s start with a generous representation of a Boid. I say generous because I&#39;m purposely including more data than needed. The cost is a bit more memory but it makes it easier to be purely functional down the road:</p><pre id="id09148a45-64b2-d015-ced5-a856fd9d2516" name=""><code id="id04d13ff4-5f6f-7e36-4a31-196df7de4dd3" name="">(def boid-defaults
  {:max-speed     2.0
   :max-force     0.4
   :perception   30})

(defn initialize-boids
  [ width height ]
  (-&gt;&gt; (for [idx (range num-boids)]
         (merge boid-defaults
                {:id idx
                 :position     [(rand-int width) (rand-int height)]
                 :max-w        width
                 :max-h        height
                 :velocity     [(- (u/rand-float 3) 1.5)
                                (- (u/rand-float 3) 1.5)]
                 :acceleration [0 0]}))
       (reset! boids)))</code></pre><p id="id331180c5-c2b5-07c8-94a7-5da25d9924c4">If you&#39;re new to clojure, be aware that &#39;for&#39; is a way of walking a list and returning a list. In this case we walk over (range num-boids), ie the number of 0..num-boids and for each of those we select a random starting point and a random velocity vector (direction) - And then we pipe that list into reset! which stores it in an atom.</p><p id="id9bfd0bf3-bd7e-d816-7113-5a23eab16a81">Now that we have our flock (list of boids) we simply need to walk the list, updating the position of each boid relative to its velocity vector - But before that, we need to make sure that the velocity vector is pointing in a direction which is similar to how a flock of birds would move.</p><p id="id9eb4caf6-acd3-f369-b64f-2daabc1eb8f8">The simplest way to model this, to my knowledge at least, is this:</p><ul><li>Find the boids that are close enough to affect the one you&#39;re updating</li><li id="id7aefb6bc-6177-96d7-8b45-d9dda309151c">Make a new acceleration vector, which <span id="id6f7efa81-f44f-0a87-4540-c8d4f73e9074">aligns</span> the current boid to the average direction of his friends</li><li id="id08abd6e4-b07b-a47e-8bf4-2cf938c0d621">Create some <span id="id6d0c05c1-ca67-8076-c387-ee7b509292be">cohesion</span> in the flock, by slightly pointing this vector towards the center of the group</li><li id="ida94ede08-b1b5-d96b-5f10-f9309a516345">Enable <span id="idec92e9dd-6d7a-5f9b-7df3-59e936c6d2c9">separation</span>, by adding a force away from the center, if the boids get too close (inversely proportional to distance)</li></ul><p id="id0b9fbba7-f403-5e08-61df-aadef11aaee4">Once you have computed this flock-acceleration vector, add it to the current velocity and off it goes. In Clojure it looks like so:</p><pre id="idc0961fd1-e532-8d58-333e-d08dbf718789" name=""><code id="idd5ad1663-7af0-1ad3-031c-bc23ae0d1868">(defn move-boid
  [ tree {:keys [id
                 position
                 velocity
                 perception
                 max-speed
                 max-force]
          :as boid} ]
  (let [friends        (-&gt;&gt; (qt/search tree perception position)
                            (filterv #(not= id (:id %))))
        acceleration   (-&gt;&gt; (v/add
                             (alignment boid friends)
                             (cohesion boid friends)
                             (seperation boid friends))
                            (v/limit-mag max-force))
        velocity       (-&gt;&gt; (v/add velocity acceleration)
                            (v/limit-mag max-speed))]
    (edge-wrap
     (assoc boid
            :position     (v/add position velocity)
            :velocity     velocity
            :acceleration [0 0]))))</code></pre><p id="id07a4053e-63af-1073-7836-636d64610b42">The math in each of these is actually fairly straightforward, so I&#39;ll just dive into one of them: Cohesion. Have a look at the code first and I&#39;ll pick it apart below:</p><pre id="id103fc42b-eac1-c58d-bc20-2d75b5d2c4bf" name=""><code id="idea2bc927-c811-660c-e118-cb2d8324828d">(defn cohesion
  &#34; Steer towards center of friends &#34;
  [ {:keys [position max-speed max-force velocity]} friends ]
  (if (seq friends)
    (-&gt;&gt; (map :position friends)
         (reduce #(v/add %1 %2) [0 0])
         (v/div (count friends))
         (v/sub position)
         (v/magnitude max-speed)
         (v/sub velocity)
         (v/limit-mag max-force))
    [0 0]))</code></pre><p id="id7136b1eb-6e1f-3995-93df-4a4d792e4899">As you saw in move-boid, all of these steering function receive a list of nearby-boids, ie friends. They are not really friends in the sense that they share private details and give each other advise on worldly matters, only in the sense that they are now so close that they are within each others radius of perception. </p><p id="ida8ad903d-cf62-d43b-5658-448acb306c1a">From these friends, I map :position, giving me a list of their positions. From an origin of 0, 0, I simply add all of these together and in the very next line divide by their number, effectively giving me an average of positions, ie. the center. </p><p id="id82ef81e0-f890-ab81-8cb4-90cc7c20cfec">I then subtract the center from my own position, giving me a vector pointing from me towards the center. Ideally, this is actually enough to create cohesion in a flock, but since I&#39;m computing a force which will act on my current velocity, I need to make sure that it never exceeds some acceptable threshold, ie. separation must not push the boid off the map completely. For this reason I set the magnitude to the maximum speed, then from subtract that sanitized vector from my current velocity (directional vector) and again make sure that the result does not exceed the maximum-force (clamping).</p><p id="id4b2ec4f7-06a7-3951-f356-d28487266eba">Alignment is nearly identically implemented, except that it looks at the friends velocity (I want to go the same way as you) and separation is like the opposite of cohesion, but with an extra push for small distances. Check them out <a href="https://github.com/LauJensen/practical-quadtree" target="_blank">on Github</a></p><p id="id2f92ff71-1194-1d5e-a41b-45804bf6fe10">So that only leaves one thing, finding the nearby-boids.</p><h2 id="idac933a9e-14be-3a25-cb77-2177f00c5bd3">Flocking Quadtrees</h2><p id="id7d0eceff-e7da-9a6c-e277-25b699a7493c">I assume that by now, you know everything there is to know about Quadtrees and how to build them functionally. But in case you want a bit more information on how to add multiple focal points and search through them quickly, I&#39;ll share a few insights.</p><p id="id75dbecd5-56a1-1e17-3d80-9205a2363d00">The only 2 changes in the tree itself, is a new variable called MINIMUM-LEAF-WIDTH which blocks infinite recursion while subdividing, and some method of moving all the objects in a cell, into it&#39;s new children: </p><pre id="idef6060c6-7daa-c7dd-e39f-31c6f1b61e08" name=""><code id="id7d26871d-6f8d-4eea-d6cc-398543da09f6" name="">(defn inside?
  [ bounds [x y] ]
  (when-let [[x1 y1 x2 y2] (seq bounds)]
    (and (&lt;= x1 x x2)
         (&lt;= y1 y y2))))

(defn subdivide
  &#34; Attaches 4 :children to the node &#34;
  [ {:keys [bounds objects] :as node} ]
  (let [[x1 y1 x2 y2] bounds
        top-left      [x1           y1           (half x2 x1) (half y2 y1)]
        top-right     [(half x2 x1) y1           x2           (half y2 y1)]
        bottom-left   [x1           (half y2 y1) (half x2 x1) y2]
        bottom-right  [(half x2 x1) (half y2 y1) x2           y2]]
    (-&gt;&gt; [top-left top-right bottom-left bottom-right]
         (mapv #(-&gt;&gt; (filterv (fn [p] (inside? % (:position p))) objects)
                     (assoc (qtree %) :objects)))
         (assoc node :objects [] :children))))</code></pre><p id="idd8795312-a689-8543-d3cf-0e8b74abcbcb">I think for these kinds of manipulations, Clojure really shines in it&#39;s simplicity. The only change in this version of the subdivide function, is the inner call to filterv, which quickly and easily filters the objects into the child-nodes. This can be made much, much faster of course, but it turns out that for a goal of 60 fps, this does just fine.</p><p id="id7b71e057-28a5-bda5-ce1f-d659bcd40807">For the search itself, we&#39;re getting a bit dirty:</p><pre id="id34ae14ff-96a0-3e8d-93da-33ff23e54ade" name=""><code id="id8020b798-45eb-6325-61aa-98cd7b294a6c">(defn search
  [node r center]
  (let [r2 (* r r)]
    (letfn [(drill [n acc]
              (if (not (circle-intersects-rect? center r (:bounds n)))
                acc
                (if-let [chs (:children n)]
                  (reduce (fn [a c] (drill c a)) acc chs)
                  (reduce (fn [a p]
                            (if (&lt;= (dist2 center (:position p)) r2)
                              (conj a p)
                              a))
                          acc
                          (:objects n)))))]
      (drill node []))))</code></pre><p id="idba740340-5257-b6f3-d9a2-2895dfe9cea2">Perhaps not the most beautiful code, but pretty fast. I recursively look for overlaps between the radius of my search-circle and the tree nodes. To shave off a few mikroseconds, I don&#39;t do any sqrt computations, but just compare the squared radius to the squad distance. I have a feeling this is old wisdom, but some habits die hard.</p><p id="id065eade1-2f81-e179-b01d-e4ebb902f8b4">The algorithm is, thanks to the structure of quadtrees, very simple. We look at a node and check if it overlaps with our search, if not we&#39;re done, return whatever we&#39;ve found. If so, repeat the step for each child, and you&#39;re done. This is very quick, but it&#39;s not actually the quickest. The reason I&#39;ve chosen it here, is 1) I was already blogging about Quadtress and 2) It&#39;s the most fun to visualize.</p><h2 id="id74570d29-b2b8-cfb1-0299-fb78ecb9d2d3">Conclusions</h2><p id="id470f6161-2540-ac90-267f-5956b92d3ece">As always, feel free to checkout the code, start a repl, experiments, it&#39;s on <a href="https://github.com/LauJensen/practical-quadtree" target="_blank">Github</a>.</p><p id="id83562283-59bf-08bf-d140-ac8994a99825">A comment on purity: I don&#39;t strive for 100% purity, but this is close. The exception being that the boids are in an atom which is updated each step. Since we&#39;re compiling to Javascript for your interactive reading-pleasure, we&#39;re single-threaded. If we compiled to Clojure, I could show you a neat trick where we use iterate to compute every single motion of every boid and simply show the nth step. Maybe I&#39;ll demonstrate this with webworkers in a future post. It&#39;s a fun exercise but not much is gained.</p><p id="id0873cd58-6bd8-f0fd-2a39-c2cd16ba243c">A comment on performance: I always start by making my code as functional, pure and concise as possible. In this case that means using prewalk as I did in the first post. I think it&#39;s a very elegant solution, but unfortunately it does visit every single element at least thrice, meaning it was a 200x speedup to write insert more manually. All in all, I was pleasantly surprised at how few compromises I had to make to get 60 fps.</p><p id="id2d10d4a2-0dc9-640c-5b90-1628a340f437">And finally I want to thank <a href="https://www.youtube.com/@pattvira" target="_blank">Patt Vira</a> for the inspiration for throwing Boids into the Quadmix. She demonstrates an interesting imperative approach in P5/JS <a href="https://www.youtube.com/watch?v=AMugNCfP1NA" target="_blank">in this video</a>.</p></div></div></div></div>
  </body>
</html>
