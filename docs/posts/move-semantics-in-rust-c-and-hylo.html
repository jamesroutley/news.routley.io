<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lukas-prokop.at/articles/2024-11-29-move-semantics-in-rust-cpp-and-hylo">Original</a>
    <h1>Move semantics in Rust, C&#43;&#43;, and Hylo</h1>
    
    <div id="readability-page-1" class="page"><p>
        ✍️ Written on 2024-11-29 in 2480 words. </p><article id="content">
         <div>
<h2 id="motivation">Motivation</h2>
<div>
<p>I just finished reading the paper <a href="https://2023.splashcon.org/details/iwaco-2023-papers/5/Borrow-checking-Hylo">Borrow checking Hylo</a>. It outlines the basic design of <a href="https://www.hylo-lang.org/">Hylo</a>. Hylo is an early-stage programming language, but unlike other contenders of C++, it provides memory safety like rust. Specifically it merges rust’s borrow checking ideas into the framework of moveable value semantics (MVS) and linear types (LT).</p>
<p>I wanted to illustrate differences of C++, rust, and Hylo with one specific example.</p>
</div>
</div>
<div>
<h2 id="example">Example</h2>
<div>
<p>We construct an example where we …</p>
<div>
<ol>
<li>
<p>define a record called <code>Person</code> with two attributes: name and age.</p>
</li>
<li>
<p>We create a person named Dave.</p>
</li>
<li>
<p>We pass the person to a function <code>show</code></p>
</li>
</ol>
</div>
<p>Then we ask us the following questions:</p>
<div>
<ol>
<li>
<p>When we passed Dave to <code>show</code>, did we create a copy?</p>
</li>
<li>
<p>If so, how do we avoid creating a copy?</p>
</li>
<li>
<p>May we use Dave after passing the unique Dave (i.e. not its copy) to <code>show</code>?</p>
</li>
</ol>
</div>
<p>I compiled the C++ examples with <a href="https://godbolt.org/">godbolt</a> with “x86-64 gcc (trunk)” and “-Wall -Wextra -Wno-pessimizing-move -Wno-redundant-move”. I compiled the rust examples on <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021">play.rust-lang.org</a> in edition 2021 in Debug mode. I compiled the Hylo examples on godbolt with “Hylo (trunk)”.</p>
</div>
</div>
<div>
<h2 id="c-example">C++ example</h2>
<div>
<div>
<div>
<pre><code data-lang="C++"><span></span>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstdint&gt;

using namespace std;

// (1)
struct Person {
    string name;
    uint8_t age;
};

void show(Person person) {
    cout &lt;&lt; person.name &lt;&lt; &#34; is &#34; &lt;&lt; unsigned(person.age)
         &lt;&lt; &#34; years old&#34; &lt;&lt; endl;
}

int main() {
    Person p{ &#34;Dave&#34;, 42 }; // (2)
    show(p); // (3)
    return 0;
}</code></pre>
</div>
</div>
<div>
<ol>
<li>
<p>Yes. You can insert <code>cout &lt;&lt; &#34;Person record is at address &#34; &lt;&lt; &amp;p &lt;&lt; endl;</code> before the call of <code>show</code> as well as the beginning of <code>show</code>. This reveals different memory addresses of the record.</p>
</li>
<li>
<p>Replace <code>void show(Person person)</code> with <code>void show(Person&amp; person)</code>. So only the function needs to change. The caller does not have to adapt to it.</p>
</li>
<li>
<p>Yes, you may insert <code>cout &lt;&lt; p.name &lt;&lt; &#34; is &#34; &lt;&lt; unsigned(p.age) &lt;&lt; &#34; years old&#34; &lt;&lt; endl;</code> after <code>show(p);</code>. This will compile and does not generate an error.</p>
</li>
</ol>
</div>
</div>
</div>
<div>
<h2 id="rust-example">rust example</h2>
<div>
<div>
<div>
<pre><code data-lang="rust"><span></span><span>// (1)</span>
<span>struct</span><span> </span><span>Person</span><span> </span>{
<span>    </span>name:<span> </span><span>String</span>,
<span>    </span>age:<span> </span><span>u8</span>,
}

<span>fn</span><span> </span><span>show</span>(person:<span> </span><span>Person</span>)<span> </span>{
<span>    </span><span>println!</span>(<span>&#34;{} is {} years old&#34;</span>,<span> </span>person.name,<span> </span>person.age);
}

<span>fn</span><span> </span><span>main</span>()<span> </span>{
<span>    </span><span>let</span><span> </span>p<span> </span><span>=</span><span> </span>Person<span> </span>{<span> </span>name:<span> </span><span>&#34;Dave&#34;</span>.to_string(),<span> </span>age:<span> </span><span>42</span><span> </span>};<span> </span><span>// (2)</span>
<span>    </span>show(p);<span> </span><span>// (3)</span>
}</code></pre>
</div>
</div>
<div>
<ol>
<li>
<p>No. <code>Person</code> does not implement the <a href="https://doc.rust-lang.org/std/marker/trait.Copy.html">Copy trait</a>.</p>
</li>
<li>
<p>(unnecessary)</p>
</li>
<li>
<p>No, inserting <code>println!(&#34;{} is {} years old&#34;, p.name, p.age);</code> after <code>show(p);</code> would generate the error <code>borrow of moved value: p</code>. Because we “moved” Dave into the scope of show, show will free the memory associated with Dave.</p>
</li>
</ol>
</div>
</div>
</div>
<div>
<h2 id="hylo-example">Hylo example</h2>
<div>
<div>
<div>
<pre><code data-lang="Hylo"><span></span>// (1)
type Person: Deinitializable {
    public var name: String
    public var age: UInt8
    public memberwise init
}

fun show(_ person: let Person) {
  print(person.name)
  print(&#34; is &#34;)
  print(person.name)
  print(&#34; years old&#34;)
}

public fun main() {
  let p = Person(name: &#34;Dave&#34;, age: 42) // (2)
  show(p) // (3)
}</code></pre>
</div>
</div>
<p>I would like to point out that string interpolation is broken in the trunk version and thus I resorted to multiple calls of <code>print</code>.</p>
<div>
<ol>
<li>
<p>No, all <a href="https://docs.hylo-lang.org/language-tour/bindings#lifetime">“copies are explicit by default”</a>. Thus one has to call <code>value.copy()</code> in Hylo explicitly to pass a value (similar to <code>value.clone()</code> in rust recognizing that rust distinguishes copy &amp; clone).</p>
</li>
<li>
<p>(unnecessary)</p>
</li>
<li>
<p>Yes, <code>let</code> in <code>(_ person: let Person)</code> provides immutable access to the value, but the lifetime of <code>p</code> (in main) is implicitly defined until the last use of <code>p</code> in <code>main</code>.</p>
</li>
</ol>
</div>
</div>
</div>
<div>
<h2 id="interlude">Interlude</h2>
<div>
<p>I think this example illustrates well that all three programming languages answer the provided questions differently. Specifically, I believe we had the following historic development:</p>
<div>
<ol>
<li>
<p>We had pass-by-value or pass-by-pointer in languages like C. So we can either provide a copy of Dave to a function or we can provide a memory address, where the function can find Dave.</p>
</li>
<li>
<p>We accept that large objects should not be copied (pass-by-pointer) and small objects may be copied (pass-by-value).</p>
</li>
<li>
<p>We learned that working on pointers directly often leads to memory bugs. So we introduced references. We pass by pointer, but using the pointer inside the function will directly operate on Dave. It was an ergonomic advancement. The awkward thing was that the caller loses control whether Dave is passed or a copy. For the caller, it looks the same (in C++).</p>
</li>
<li>
<p>These days we recognize that we have more dimensions to take care of. Besides copying, we want to convey whether Dave is [im]mutable, [un]initialized, and destroyed inside the function (and thus invalid after the call).</p>
</li>
</ol>
</div>
<p>As such we look for new designs. To distinguish these cases; we need to make them more explicit. Rust and Hylo contribute to this.
Now, we can take a look at additional features in each language.</p>
</div>
</div>
<div>
<h2 id="c-example-with-stdmove">C++ example with std::move</h2>
<div>
<p>People really <a href="https://stackoverflow.com/q/3413470">struggle understanding</a> the semantics, but <a href="https://en.cppreference.com/w/cpp/utility/move">std::move</a> is the only mentionable feature of C++ in this context. The technical explanation is that an lvalue is converted into an x-value, but most people in my programming circle using that language are not even familiar with it.</p>
<div>
<div>
<pre><code data-lang="C++"><span></span>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstdint&gt;

using namespace std;

// (1)
struct Person {
    string name;
    uint8_t age;
};

void show(Person person) {
    cout &lt;&lt; &#34;Person record is at address &#34; &lt;&lt; &amp;person &lt;&lt; endl;
    cout &lt;&lt; person.name &lt;&lt; &#34; is &#34; &lt;&lt; unsigned(person.age) &lt;&lt; &#34; years old&#34; &lt;&lt; endl;
}

int main() {
    Person p{ &#34;Dave&#34;, 42 }; // (2)
    cout &lt;&lt; &#34;Person record is at address &#34; &lt;&lt; &amp;p &lt;&lt; endl;
    show(move(p)); // (3)
    cout &lt;&lt; p.name &lt;&lt; &#34; is &#34; &lt;&lt; unsigned(p.age) &lt;&lt; &#34; years old&#34; &lt;&lt; endl;
    return 0;
}</code></pre>
</div>
</div>
<p>Its output is</p>
<div>
<div>
<pre>Person record is at address 0x7ffeb9074e30
Person record is at address 0x7ffeb9074e60
Dave is 42 years old
 is 42 years old</pre>
</div>
</div>
<p>So apparently, move does not prevent generation of a copy, but the empty string instead of expected text “Dave” is very interesting. Apparently, after termination of <code>show</code> after the move, the object is invalidated. This does not affect the <code>Person</code> object, but only the string object. Recognize that I speak about a factual behavior on the hardware. I think we have undefined behavior here. And no compilation error.</p>
<p>If we turn <code>Person person</code> (pass-by-value) into a <code>Person&amp; person</code> (pass-by-reference), we get an error. When I said “the caller loses control” in the interlude before, I was not completely right. With the introduction of <code>std::move</code>, we regain some control. If a function expects an object by reference, a moved value is not allowed. Because a moved value indicates that the programmer is not going to use the object after this call. So what is the purpose to modify an object (this is the intention of referencing) when it is thrown away (this is the intention of move) anyways? A compilation error is luckily provided in this case:</p>
<div>
<div>
<pre>error: cannot bind non-const lvalue reference of type &#39;Person&amp;&#39;
to an rvalue of type &#39;std::remove_reference&lt;Person&amp;&gt;::type&#39; {aka &#39;Person&#39;}</pre>
</div>
</div>
</div>
</div>
<div>
<h2 id="advanced-rust-example">Advanced rust example</h2>
<div>
<p>First, we can decide to copy (in rust, here it is a clone) the object:</p>
<div>
<div>
<pre><code data-lang="rust"><span></span><span>#[derive(Clone)]</span><span> </span><span>// recognize the Clone here</span>
<span>struct</span><span> </span><span>Person</span><span> </span>{
<span>    </span>name:<span> </span><span>String</span>,
<span>    </span>age:<span> </span><span>u8</span>,
}

<span>fn</span><span> </span><span>show</span>(person:<span> </span><span>Person</span>)<span> </span>{
<span>    </span><span>println!</span>(<span>&#34;{} is {} years old&#34;</span>,<span> </span>person.name,<span> </span>person.age);
}

<span>fn</span><span> </span><span>main</span>()<span> </span>{
<span>    </span><span>let</span><span> </span>p<span> </span><span>=</span><span> </span>Person<span> </span>{<span> </span>name:<span> </span><span>&#34;Dave&#34;</span>.to_string(),<span> </span>age:<span> </span><span>42</span><span> </span>};
<span>    </span>show(p.clone());<span> </span><span>// recognize the clone() here</span>
<span>    </span><span>println!</span>(<span>&#34;{} is {} years old&#34;</span>,<span> </span>p.name,<span> </span>p.age);
}</code></pre>
</div>
</div>
<div>
<div>
<pre>Dave is 42 years old
Dave is 42 years old</pre>
</div>
</div>
<p>Great. And what happens if I want to enable access to the object in the function, but still use it later on? I need to borrow it with <code>&amp;</code>:</p>
<div>
<div>
<pre><code data-lang="rust"><span></span><span>struct</span><span> </span><span>Person</span><span> </span>{
<span>    </span>name:<span> </span><span>String</span>,
<span>    </span>age:<span> </span><span>u8</span>,
}

<span>fn</span><span> </span><span>consume</span>(person:<span> </span><span>&amp;</span><span>Person</span>)<span> </span>{<span> </span><span>// recognize ‘&amp;’ here</span>
<span>    </span><span>println!</span>(<span>&#34;{} is {} years old&#34;</span>,<span> </span>person.name,<span> </span>person.age);
}

<span>fn</span><span> </span><span>main</span>()<span> </span>{
<span>    </span><span>let</span><span> </span>p<span> </span><span>=</span><span> </span>Person<span> </span>{<span> </span>name:<span> </span><span>&#34;Dave&#34;</span>.to_string(),<span> </span>age:<span> </span><span>42</span><span> </span>};
<span>    </span>consume(<span>&amp;</span>p);<span> </span><span>// recognize ‘&amp;’ here</span>
<span>    </span><span>println!</span>(<span>&#34;{} is {} years old&#34;</span>,<span> </span>p.name,<span> </span>p.age);
}</code></pre>
</div>
</div>
<p>This is what is called borrowing and a compilation unit called “borrow checker” needs to check that borrowing and the use of borrowed values (like <code>person</code>) does not violate memory safety.</p>
</div>
</div>
<div>
<h2 id="advanced-hylo-example">Advanced Hylo example</h2>
<div>
<div>
<div>
<pre><code data-lang="Hylo"><span></span>type Person: Deinitializable {
    public var name: String
    public var age: UInt8
    public memberwise init
}

fun show(_ person: sink Person) { // recognize “sink” here
  print(person.name)
  print(&#34; is &#34;)
  print(person.name)
  print(&#34; years old&#34;)
}

public fun main() {
  let p = Person(name: &#34;Dave&#34;, age: 42)
  show(p)
  print(p.name)
  print(&#34; is &#34;)
  print(p.name)
  print(&#34; years old&#34;)
}</code></pre>
</div>
</div>
<p>Changing the passing convention from <code>let</code> to <code>sink</code> tells the compiler the value is not going to be used after the call of <code>show(p)</code>. This is obviously not true, because we call <code>print(p.name)</code> after it. So we get an error:</p>
<div>
<div>
<pre>&lt;source&gt;:17.16: error: use of consumed object
  print(p.name)
               ^
&lt;source&gt;:19.16: error: use of consumed object
  print(p.name)
               ^</pre>
</div>
</div>
<p>Similar to rust, we can copy the object and the program is going to work fine with a <code>sink</code> property:</p>
<div>
<div>
<pre><code data-lang="Hylo"><span></span>type Person: Deinitializable, Copyable { // recognize “Copyable” here
    public var name: String
    public var age: UInt8
    public memberwise init
}

fun show(_ person: sink Person) {
  print(person.name)
  print(&#34; is &#34;)
  print(person.name)
  print(&#34; years old&#34;)
}

public fun main() {
  let p = Person(name: &#34;Dave&#34;, age: 42)
  show(p.copy()) // recognize copy() here
  print(p.name)
  print(&#34; is &#34;)
  print(p.name)
  print(&#34; years old&#34;)
}</code></pre>
</div>
</div>
</div>
</div>
<div>
<h2 id="conclusion">Conclusion</h2>
<div>
<p>I think before rust, language designers mixed up the various properties these values can have. As a result, many incomprehensible designs were the result. rust models the most important memory-related properties through its two call conventions (passing or borrowing). And Hylo moves even more properties into the call conventions. Namely, Hylo uses the keywords <code>let</code>, <code>set, </code>sink, and <code>inout</code>. This way Hylo additionally represents e.g. initialization (rust models this with <a href="https://doc.rust-lang.org/std/mem/union.MaybeUninit.html">a separate type</a>).</p>
<p>On an abstract level, a program has values which have capabilities (like copyable). In case of rust and Hylo, they are mostly represented by traits. And the programmer needs to write down what expectations a function has in terms of values it receives. And this design space of expectations gains new momentum now. What shall be distinguished and written down? What is just boilerplate and shall be ignored?</p>
<p>I think Hylo contributes nicely here and thus it was worth reading the paper. While writing this article, I learned that the <a href="https://docs.hylo-lang.org/language-tour/functions-and-methods">Hylo documentation</a> explicitly addresses differences with C++ and rust.</p>
<p>Finally, I want to mention that Hylo is currently in a very early development stage and it is going to take some years to get such concepts established.</p>
<p><strong>Bonus:</strong> Why is a call of <code>unsigned()</code> required in C++?.</p>
</div>
</div>

      </article></div>
  </body>
</html>
