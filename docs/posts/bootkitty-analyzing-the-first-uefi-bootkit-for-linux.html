<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.welivesecurity.com/en/eset-research/bootkitty-analyzing-first-uefi-bootkit-linux/">Original</a>
    <h1>Bootkitty: Analyzing the first UEFI bootkit for Linux</h1>
    
    <div id="readability-page-1" class="page"><div>
    <p>Over the past few years, the UEFI threat landscape, particularly that of UEFI bootkits, has evolved significantly. It all started with the first UEFI bootkit proof of concept (PoC) <a href="https://www.theregister.com/2012/09/19/win8_rootkit/" target="_blank" rel="noopener">described</a> by Andrea Allievi in 2012, which served as a demonstration of deploying bootkits on modern UEFI-based Windows systems, and was followed with many other PoCs (<a href="https://github.com/Mattiwatti/EfiGuard" target="_blank" rel="noopener">EfiGuard</a>, <a href="https://github.com/Cr4sh/s6_pcie_microblaze/tree/master/python/payloads/DmaBackdoorBoot" target="_blank" rel="noopener">Boot Backdoor</a>, <a href="https://github.com/ajkhoury/UEFI-Bootkit" target="_blank" rel="noopener">UEFI-bootkit</a>). It took several years until the first two real UEFI bootkits were discovered in the wild (<a href="https://www.welivesecurity.com/2021/10/05/uefi-threats-moving-esp-introducing-especter-bootkit/" target="_blank" rel="noopener">ESPecter</a>, 2021 ESET; <a href="https://securelist.com/finspy-unseen-findings/104322/" target="_blank" rel="noopener">FinSpy bootkit</a>, 2021 Kaspersky), and it took two more years until the infamous <a href="https://www.welivesecurity.com/2023/03/01/blacklotus-uefi-bootkit-myth-confirmed/" target="_blank" rel="noopener">BlackLotus</a> – the first UEFI bootkit capable of bypassing UEFI Secure Boot on up-to-date systems – appeared (2023, ESET).</p>
<p><span lang="EN-US">A common thread among these publicly known bootkits was their exclusive targeting of Windows systems. Today, we unveil our latest discovery: the first UEFI bootkit designed for Linux systems, named Bootkitty by its creators. We believe this bootkit is merely an initial proof of concept, and based on our telemetry, it has not been deployed in the wild. That said, its existence underscores an important message: UEFI bootkits are no longer confined to Windows systems alone.</span></p>
<p>The bootkit’s main goal is to disable the kernel’s signature verification feature and to preload two as yet unknown ELF binaries via the Linux <span>init</span> process (which is the first process executed by the Linux kernel during system startup). During our analysis, we discovered a possibly related unsigned kernel module – with signs suggesting that it could have been developed by the same author(s) as the bootkit – that deploys an ELF binary responsible for loading yet another kernel module unknown during our analysis.</p>
<blockquote>
<p><strong>Key points of this blogpost:</strong></p>
<ul>
<li>In November 2024, a previously unknown UEFI application, named <span>bootkit.efi</span>, was uploaded to <a href="https://www.virustotal.com/gui/file/f1f84819bdf395d42c36adb36ded0e7de338e2036e174716b5de71abc56f5d40" target="_blank" rel="noopener">VirusTotal</a>.</li>
<li>Our initial analysis confirmed it is a UEFI bootkit, named Bootkitty by its creators and surprisingly the first UEFI bootkit targeting Linux, specifically, a few Ubuntu versions.</li>
<li>Bootkitty is signed by a self-signed certificate, thus is not capable of running on systems with UEFI Secure Boot enabled unless the attackers certificates have been installed.</li>
<li>Bootkitty is designed to boot the Linux kernel seamlessly, whether UEFI Secure Boot is enabled or not, as it patches, in memory, the necessary functions responsible for integrity verification before GRUB is executed.</li>
<li><span>bootkit.efi</span> contains many artifacts suggesting this is more like a proof of concept than the work of an active threat actor.</li>
<li>We discovered a possibly related kernel module, which we named BCDropper, that deploys an ELF program responsible for loading another kernel module.</li>
</ul>
</blockquote>
<h2>Bootkitty overview</h2>
<p>As mentioned in the introduction, Bootkitty contains many artifacts suggesting that we might be dealing with a proof of concept instead of actively used malware. In this section, we look more closely at these artifacts, plus other basic information about the bootkit.</p>
<p>Bootkitty contains two unused functions, capable of printing special strings to the screen during its execution. The first function, whose output is depicted in Figure 1, can print ASCII art that we believe represents a possible name of the bootkit: Bootkitty.</p>
<figure><img title="Figure 1. ASCII art embedded in the bootkit" src="https://web-assets.esetstatic.com/wls/2024/11-2024/bootkitty/figure-1.png" alt="Figure 1. ASCII art embedded in the bootkit" width="" height=""/>
<figcaption><em>Figure 1. ASCII art embedded in the bootkit</em></figcaption>
</figure>
<p>The second function, can print text, shown in Figure 2, containing the list of possible bootkit authors and other persons that perhaps somehow participated in its development. One of the names mentioned in the image can be found on GitHub, but the profile does not have any public repository that would contain or mention a UEFI bootkit project; therefore, we can neither confirm nor deny authenticity of the names mentioned in the bootkit.</p>
<figure><img title="Figure 2. List of names embedded in the bootkit (redacted)" src="https://web-assets.esetstatic.com/wls/2024/11-2024/bootkitty/figure-2.png" alt="Figure 2. List of names embedded in the bootkit (redacted)" width="" height=""/>
<figcaption><em>Figure 2. List of names embedded in the bootkit (redacted)</em></figcaption>
</figure>
<p>During every boot, Bootkitty prints on screen the strings shown in Figure 3.</p>
<figure><img title="Figure 3. Bootkitty’s welcome message" src="https://web-assets.esetstatic.com/wls/2024/11-2024/bootkitty/figure-3.png" alt="Figure 3. Bootkitty’s welcome message" width="" height=""/>
<figcaption><em>Figure 3. Bootkitty’s welcome message</em></figcaption>
</figure>
<p>Note that the BlackCat name is referenced also in the loadable kernel module described later. Despite the name, we believe there is no connection to the ALPHV/BlackCat ransomware group. This is because BlackCat is a name used by researchers and Bootkitty was developed in C, while the group calls itself ALPHV and develops its malware exclusively in Rust.</p>
<p>As mentioned earlier, Bootkitty currently supports only a limited number of systems. The reason is that to find the functions it wants to modify in memory, it uses hardcoded byte patterns. While byte-pattern matching is a common technique when it comes to bootkits, the authors didn’t use the best patterns for covering multiple kernel or GRUB versions; therefore, the bootkit is fully functional only for a limited number of configurations. What limits the use of the bootkit even more is the way it patches the decompressed Linux kernel: as shown in Figure 4, once the kernel image is decompressed, Bootkitty simply copies the malicious patches to the hardcoded offsets within the kernel image.</p>
<figure><img title="Figure 4. Bootkitty’s code responsible for patching the decompressed kernel before it is executed" src="https://web-assets.esetstatic.com/wls/2024/11-2024/bootkitty/figure-4.png" alt="Figure 4. Bootkitty’s code responsible for patching the decompressed kernel before it is executed" width="" height=""/>
<figcaption><em>Figure 4. Bootkitty’s code responsible for patching the decompressed kernel before it is executed</em></figcaption>
</figure>
<p>We explain how the bootkit gets to the actual kernel patching later in the <a href="#Linux kernel image decompression hook"><em>Linux kernel image decompression hook</em></a> section; for now, just note that due to the lack of kernel-version checks in the function shown in Figure 4, Bootkitty can get to the point where it patches completely random code or data at these hardcoded offsets, thus crashing the system instead of compromising it. This is one of the facts that supports proof of concept. On the other hand, it might be an initial not-production-ready version of malware created by malicious threat actors.</p>
<p>Last but not least, the bootkit binary is signed by the self-signed certificate shown in Figure 5.</p>
<figure><img title="" src="https://web-assets.esetstatic.com/wls/2024/11-2024/bootkitty/figure-5.png" alt="Figure 5. Self-signed certificate used to sign the bootkit" width="" height=""/>
<figcaption><em>Figure 5. Self-signed certificate used to sign the bootkit</em></figcaption>
</figure>
<h2>Techical analysis</h2>
<p><span lang="EN-US">We start with an overview of Bootkitty’s execution, as depicted in </span><span lang="EN-US">Figure <span>6</span></span><span lang="EN-US">. First, we briefly describe the main functionality and then in subsequent sections we go into more details. </span></p>
<p>There are three main parts we focus on:</p>
<ul>
<li>Execution of the bootkit and patching of the legitimate GRUB bootloader (points 4 and 5 in Figure 6).</li>
<li>Patching of the Linux kernel’s EFI stub loader (points 6 and 7 in Figure 6).</li>
<li>Patching of the decompressed Linux kernel image (points 8 and 9 in Figure 6).</li>
</ul>
<figure><img title="Figure 6. Bootkitty execution overview" src="https://web-assets.esetstatic.com/wls/2024/11-2024/bootkitty/figure-6-1.png" alt="Figure 6. Bootkitty bootkit execution overview" width="" height=""/>
<figcaption><em>Figure 6. Bootkitty execution overview</em></figcaption>
</figure>
<h3>Initialization and GRUB hooking</h3>
<p>After Bootkitty is executed by the shim, it checks to see whether UEFI Secure Boot is enabled by examining the value of the <span>SecureBoot</span> UEFI variable, and proceeds to hook two functions from the UEFI authentication protocols if so (this process is shown in Figure 7):</p>
<ul>
<li><span>EFI_SECURITY2_ARCH_PROTOCOL.FileAuthentication</span>: <a href="https://uefi.org/specs/PI/1.8/V2_DXE_Architectural_Protocols.html#efi-security2-arch-protocol-fileauthentication" target="_blank" rel="noopener">this function</a> is used by the firmware to measure and verify the integrity of UEFI PE images. Bootkitty’s hook function modifies the output of this function so that it always returns <span>EFI_SUCCESS</span>, meaning that the verification succeeded.</li>
<li><span>EFI_SECURITY_ARCH_PROTOCOL.FileAuthenticationState</span>: <a href="https://uefi.org/specs/PI/1.8/V2_DXE_Architectural_Protocols.html#efi-security-arch-protocol-fileauthenticationstate" target="_blank" rel="noopener">this function</a> is used by the firmware to execute a platform-specific policy in response to different authentication status values. Again, the bootkit’s hook modifies it in a way that it always returns <span>EFI_SUCCESS</span>, meaning that the firmware can use the file regardless of its actual authentication status.</li>
</ul>
<figure><img title="Figure 7. Hooking of the UEFI security authentication protocols" src="https://web-assets.esetstatic.com/wls/2024/11-2024/bootkitty/figure-7.png" alt="Figure 7. Hooking of the UEFI security authentication protocols" width="" height=""/>
<figcaption><em>Figure 7. Hooking of the UEFI security authentication protocols</em></figcaption>
</figure>
<p>After checking the status of UEFI Secure Boot, Bootkitty proceeds to load the legitimate GRUB from the hardcoded path on the EFI system partition: <span>/EFI/ubuntu/grubx64-real.efi</span>. This file should be a backup, created by the attacker, of a legitimate GRUB. Once GRUB is loaded (not yet executed), the bootkit starts patching and hooking the following code in GRUB’s memory:</p>
<ul>
<li>The <span>start_image</span> function within the <span>peimage</span> GRUB module (a module embedded inside GRUB). This function is responsible for starting an already loaded PE image, and it’s invoked by GRUB to start the Linux kernel’s EFI stub binary (known in general as <span>vmlinuz.efi</span> or <span>vmlinuz</span>). The hook function takes advantage of the fact that at the moment the hook is executed, vmlinuz is already loaded into memory (but hasn’t been executed yet), and patches the function responsible for decompressing the actual Linux kernel image inside vmlinuz (note that in some cases, due to the way the Linux kernel is compiled, it can be quite challenging to find the exact name of the function being patched; however, we believe that this time it should be the <span>zstd_decompress_dctx</span> function). More details about the decompression hook are in the<em> </em><a href="#Linux kernel image decompression hook"><em>Linux kernel image decompression hook</em></a> section.</li>
<li>The <span>shim_lock_verifier_init</span> function, which is part of the <span>shim_lock</span> verifier mechanism inside GRUB – this should be activated automatically if UEFI Secure Boot is enabled. It is responsible for deciding whether the files provided (e.g., GRUB modules, Linux kernel, configurations…) should be verified or not during the boot. The installed hook, however, is somehow confusing and the author’s intentions are unclear because it modifies <span>shim_lock_verifier_init</span>’s output in a way that it sets the output flag to <span>GRUB_VERIFY_FLAGS_SINGLE_CHUNK</span> (value 2) for any file type provided, which should, according to the <a href="https://www.gnu.org/software/grub/manual/grub-dev/html_node/Verifiers-framework.html" target="_blank" rel="noopener">GRUB manual</a>, strengthen the security even more. Interestingly, due to the hook described in the next point, this shim_lock_verifier_init function is not even called during the boot, thus becoming irrelevant.</li>
<li>The <span>grub_verifiers_open</span> function. This function is invoked by GRUB anytime it opens a file, and is responsible for checking whether the installed GRUB file verifiers (this includes the <span>shim_lock</span> verifier described above) require integrity verification for the file being loaded. The function is hooked by the bootkit in a way that it returns immediately without proceeding to any signature checks (note that this means that it does not even execute the previously hooked <span>shim_lock_verifier_init</span> function).</li>
</ul>
<h3>Linux kernel image decompression hook<a id="Linux kernel image decompression hook"></a></h3>
<p>This hook is responsible for patching the decompressed Linux kernel image. The hook is called right before the kernel image is decompressed, so the hook restores the original decompression function’s bytes and executes the original function to decompress the kernel image before proceeding to the kernel patching.</p>
<p>Now, as the kernel is decompressed and lies in the memory untouched (still hasn’t been executed), the hook code patches it at hardcoded offsets (in memory only). Specifically, as shown in Figure 8, it:</p>
<ul>
<li>Rewrites the kernel version and <a href="https://github.com/torvalds/linux/blob/v6.8/init/version-timestamp.c#L28" target="_blank" rel="noopener">Linux banner</a> strings with the text <span>BoB13</span> (this has no significant impact on the system).</li>
<li>Hooks the <a href="https://github.com/torvalds/linux/blob/v6.8/kernel/module/signing.c#L70" target="_blank" rel="noopener"><span>module_sig_check</span></a> function.</li>
<li>Patches pointer/address to the first environment variable of the <span>init</span> process.</li>
</ul>
<figure><img title="Figure 8. Bootkitty’s kernel-decompression hook inside vmlinuz" src="https://web-assets.esetstatic.com/wls/2024/11-2024/bootkitty/figure-8.png" alt="Figure 8. Bootkitty’s kernel-decompression hook inside vmlinuz" width="" height=""/>
<figcaption><em>Figure 8. Bootkitty’s kernel-decompression hook inside vmlinuz</em></figcaption>
</figure>
<p>The function <span>module_sig_check</span> is patched to always return <span>0</span>. This function is responsible for checking whether the module is validly signed. By patching the function to return <span>0</span>, the kernel will load any module without verifying the signature. On Linux systems with UEFI Secure Boot enabled, kernel modules <em>need</em> to be signed if they are meant to be loaded. This is also the case when the kernel is built with <span>CONFIG_MODULE_SIG_FORCE</span> enabled or when <span>module.sig_enforce=1</span> is passed as a kernel command line argument, as described in the <a href="https://www.kernel.org/doc/html/v4.15/admin-guide/module-signing.html#non-valid-signatures-and-unsigned-modules" target="_blank" rel="noopener">Linux kernel documentation</a>. The likely scenario is that at least one malicious kernel module is loaded at a later phase, such as the dropper analyzed below.</p>
<p>The first process that the Linux kernel executes is init from the first hardcoded path that works (starting with <a href="https://github.com/torvalds/linux/blob/v6.8/init/main.c#L1467" target="_blank" rel="noopener"><span>/init</span> from initramfs</a>), along with command line arguments and environment variables. The hook code replaces the first environment variable with <span>LD_PRELOAD=/opt/injector.so /init</span>. <span><a href="https://man7.org/linux/man-pages/man8/ld.so.8.html" target="_blank" rel="noopener">LD_PRELOAD</a></span> is an environment variable that is used to load ELF shared objects before others and can be used to override functions. It is a common <a href="https://attack.mitre.org/techniques/T1574/006/" target="_blank" rel="noopener">technique</a> used by attackers to load malicious binaries. In this case, the <span>/opt/injector.so</span> and <span>/init</span> ELF shared objects are loaded when the init process starts. This is where the intention becomes less clear, mainly why the second string <span>/init</span> is part of <span>LD_PRELOAD</span>.</p>
<p>We have not discovered any of these possibly malicious ELF shared objects, although just as this blogpost was being finalized for publication, a write-up describing the missing components mentioned in our report has been <a href="https://humzak711.github.io/analyzing_IranuKit" target="_blank" rel="noopener">published</a>. Now it’s clear they are used just to load another stage.</p>
<h3>Impact and remediation</h3>
<p>Apart from loading unknown ELF shared objects, Bootkitty leaves footprints in the system. The first is the intended, albeit not necessary, modification of kernel version and Linux banner strings. The former can be seen by running <span>uname -v</span> (Figure 9) and the latter by running <span>dmesg</span> (Figure 10).</p>
<figure><img title="Figure 9. BoB13 string in uname output" src="https://web-assets.esetstatic.com/wls/2024/11-2024/bootkitty/figure-9.png" alt="Figure 9. BoB13 string in uname output" width="" height=""/>
<figcaption><em>Figure 9. </em><span>BoB13</span><em> string in uname output</em></figcaption>
</figure>
<figure><img title="Figure 10. BoB13 string in dmesg output" src="https://web-assets.esetstatic.com/wls/2024/11-2024/bootkitty/figure-10.png" alt="Figure 10. BoB13 string in dmesg output" width="" height=""/>
<figcaption><em>Figure 10. </em><span>BoB13</span><em> string in dmesg output</em></figcaption>
</figure>
<p>During our analysis, the output of the command <span>dmesg</span> also included details about how the init process was run. As depicted in Figure 11, the process was run with the <span>LD_PRELOAD</span> environment variable (it was originally <span>HOME=/</span> and was replaced with <span>LD_PRELOAD=/opt/injector.so /init</span> by the bootkit).</p>
<figure><img title="Figure 11. init process arguments and environment variables in dmesg output" src="https://web-assets.esetstatic.com/wls/2024/11-2024/bootkitty/figure-11.png" alt="Figure 11. init process arguments and environment variables in dmesg output" width="" height=""/>
<figcaption><em>Figure 11. </em><span>init</span><em> process arguments and environment variables in dmesg output</em></figcaption>
</figure>
<p>Note in Figure 11 that the word <span>/init</span> in the first line corresponds to the legitimate program in initramfs that eventually passes control to systemd on default Ubuntu installations. The presence of the <span>LD_PRELOAD</span> environment variable can also be verified by inspecting the file <span>/proc/1/environ</span>.</p>
<p>After booting up a system with Bootkitty in our testing environment, we noticed that the kernel was marked as <a href="https://docs.kernel.org/admin-guide/tainted-kernels.html" target="_blank" rel="noopener">tainted</a> (command from Figure 12 can be used to check the tainted value), which was not the case when the bootkit was absent. Another way to tell whether the bootkit is present on the system with UEFI Secure Boot enabled is by attempting to load an unsigned dummy kernel module during runtime. If it’s present, the module will be loaded; if not – the kernel refuses to load it.</p>
<figure><img title="Figure 12. Tainted state right after the system has started with Bootkitty" src="https://web-assets.esetstatic.com/wls/2024/11-2024/bootkitty/figure-12.png" alt="Figure 12. Tainted state right after the system has started with Bootkitty" width="" height=""/>
<figcaption><em>Figure 12. Tainted state right after the system has started with Bootkitty</em></figcaption>
</figure>
<p>A simple remedy tip to get rid of the bootkit is to move the legitimate <span>/EFI/ubuntu/grubx64-real.efi</span> file back to its original location, which is <span>/EFI/ubuntu/grubx64.efi</span>. This will make shim execute the legitimate GRUB and thus the system will boot up without the bootkit (note that this covers only the scenario when the bootkit is deployed as <span>/EFI/ubuntu/grubx64.efi</span>).</p>
<h3>BCDropper and BCObserver</h3>
<p>In addition to the bootkit, we discovered a possibly related unsigned kernel module we named BCDropper, uploaded to VirusTotal around the same time and by the same submitter’s ID as the bootkit, containing hints that it might have been developed by the same author as the bootkit, such as:</p>
<ul>
<li>a <span>BlackCat</span> string in the output of the <span>modinfo</span> command’s output, shown in Figure 13,</li>
<li>another presence of the <span>blackcat</span> string in the debug paths in the module’s binary, shown in Figure 14, and</li>
<li>it contains an unused file-hiding function that hides specific entries from directory listings. As shown in Figure 15, one of the hardcoded filename string prefixes used to filter-out these entries is <span>injector</span> (note that Bootkitty tries to preload a shared-library from the path <span>/opt/injector.so</span>)</li>
</ul>
<p>However, even with the evidence presented, we cannot say for sure whether or not the kernel module is related to Bootkitty (or was created by the same developer). Also, the kernel version mentioned in Figure 13 (<span>6.8.0-48-generic</span>) is not supported by the bootkit.</p>
<figure><img title="Figure 13. Dropper module information" src="https://web-assets.esetstatic.com/wls/2024/11-2024/bootkitty/figure-13.png" alt="Figure 13. Dropper module information" width="" height=""/>
<figcaption><em>Figure 13. Dropper module information</em></figcaption>
</figure>
<figure><img title="Figure 14. Dropper debug symbols referencing blackcat" src="https://web-assets.esetstatic.com/wls/2024/11-2024/bootkitty/figure-14.png" alt="Figure 14. Dropper debug symbols referencing blackcat" width="" height=""/>
<figcaption><em>Figure 14. Dropper debug symbols referencing </em><span>blackcat</span></figcaption>
</figure>
<figure><img title="Figure 15. List of files, in the dropper, to hide" src="https://web-assets.esetstatic.com/wls/2024/11-2024/bootkitty/figure-15.png" alt="Figure 15. List of files, in the dropper, to hide" width="" height=""/>
<figcaption><em>Figure 15. List of files, in the dropper, to hide</em></figcaption>
</figure>
<p>As its name suggests, the kernel module drops an embedded ELF file we named BCObserver, specifically to <span>/opt/observer</span>, and executes it via <span>/bin/bash</span> (Figure 17). On top of that, the module hides itself by <a href="https://xcellerator.github.io/posts/linux_rootkits_05/" target="_blank" rel="noopener">removing its entry from the module list</a>. The kernel module also implements other rootkit-related functionalities like hiding files (those in Figure 15), processes, and open ports, but they are not directly used by the dropper.</p>
<figure><img title="Figure 16. Hex-Rays decompiled dropper code" src="https://web-assets.esetstatic.com/wls/2024/11-2024/bootkitty/figure-16.png" alt="Figure 16. Hex-Rays decompiled dropper code" width="" height=""/>
<figcaption><em>Figure 16. Hex-Rays decompiled dropper code</em></figcaption>
</figure>
<p>BCObserver is a rather simple application that waits until the display manager <a href="https://manpages.ubuntu.com/manpages/lunar/man8/gdm3.8.html" target="_blank" rel="noopener">gdm3</a> is running, and then loads an unknown kernel module from <span>/opt/rootkit_loader.ko</span> via the <a href="https://man7.org/linux/man-pages/man2/init_module.2.html" target="_blank" rel="noopener"><span>finit_module</span></a> system call. By waiting for the display manager to start, the code ensures that the kernel module is loaded after the system is fully booted up.</p>
<figure><img title="Figure 17. Hex-Rays decompiled observer code" src="https://web-assets.esetstatic.com/wls/2024/11-2024/bootkitty/figure-17.png" alt="Figure 17. Hex-Rays decompiled observer code" width="" height=""/>
<figcaption><em>Figure 17. Hex-Rays decompiled observer code</em></figcaption>
</figure>
<p>While we cannot confirm whether the dropper is somehow related to the bootkit, and if so, how it is meant to be executed, we’re quite sure that the bootkit patches the <span>module_sig_check</span> function for a reason, and loading an unsigned kernel module (such as the dropper described here) would definitely make sense.</p>
<h2>Conclusion</h2>
<p>Whether a proof of concept or not, Bootkitty marks an interesting move forward in the UEFI threat landscape, breaking the belief about modern UEFI bootkits being Windows-exclusive threats. Even though the current version from VirusTotal does not, at the moment, represent a real threat to the majority of Linux systems, it emphasizes the necessity of being prepared for potential future threats.</p>
<p>To keep your Linux systems safe from such threats, make sure that UEFI Secure Boot is enabled, your system firmware and OS are up-to-date, and so is your UEFI revocations list.</p>
<blockquote>
<p><em>For any inquiries about our research published on WeLiveSecurity, please contact us at <a href="mailto:threatintel@eset.com?utm_source=welivesecurity.com&amp;utm_medium=referral&amp;utm_campaign=autotagging&amp;utm_content=eset-research&amp;utm_term=en">threatintel@eset.com</a>. </em></p>
<p><em>ESET Research offers private APT intelligence reports and data feeds. For any inquiries about this service, visit the <a href="https://www.eset.com/int/business/services/threat-intelligence/?utm_source=welivesecurity.com&amp;utm_medium=referral&amp;utm_campaign=wls-research&amp;utm_content=bootkitty-analyzing-first-uefi-bootkit-linux&amp;sfdccampaignid=7011n0000017htTAAQ" target="_blank" rel="noopener">ESET Threat Intelligence</a> page.</em></p>
</blockquote>
<h2>IoCs</h2>
<p>A comprehensive list of indicators of compromise (IoCs) and samples can be found in <a href="https://github.com/eset/malware-ioc/tree/master/bootkitty" target="_blank" rel="noopener">our GitHub repository</a>.</p>
<h3>Files</h3>
<table>
<thead>
<tr>
<td><strong><span lang="EN-US">SHA-1</span></strong></td>
<td><strong><span lang="EN-US">Filename</span></strong></td>
<td><strong><span lang="EN-US">Detection</span></strong></td>
<td><strong><span lang="EN-US">Description</span></strong></td>
</tr>
</thead>
<tbody>
<tr>
<td><span><span><span lang="EN-US">35ADF3AED60440DA7B80<wbr/>F3C452047079E54364C1</span></span></span></td>
<td><span><span><span lang="EN-US">bootkit.efi</span></span></span></td>
<td><span lang="EN-US">EFI/Agent.A</span></td>
<td><span lang="EN-US">Bootkitty UEFI bootkit.</span></td>
</tr>
<tr>
<td><span><span><span lang="EN-US">BDDF2A7B3152942D3A82<wbr/>9E63C03C7427F038B86D</span></span></span></td>
<td><span><span><span lang="EN-US">dropper.ko</span></span></span></td>
<td><span lang="EN-US">Linux/Rootkit.Agent.FM</span></td>
<td><span lang="EN-US">BCDropper.</span></td>
</tr>
<tr>
<td><span><span><span lang="EN-US">E8AF4ED17F293665136E<wbr/>17612D856FA62F96702D</span></span></span></td>
<td><span><span><span lang="EN-US">observer</span></span></span></td>
<td><span lang="EN-US">Linux/Rootkit.Agent.FM</span></td>
<td><span lang="EN-US">BCObserver.</span></td>
</tr>
</tbody>
</table>
<h2>MITRE ATT&amp;CK techniques</h2>
<p><em>This table was built using <a href="https://attack.mitre.org/resources/versions/">version 16</a> of the MITRE ATT&amp;CK framework<strong>.</strong></em></p>
<table>
<thead>
<tr>
<td><strong>Tactic</strong></td>
<td><strong>ID</strong></td>
<td><strong>Name</strong></td>
<td><strong>Description</strong></td>
</tr>
</thead>
<tbody>
<tr>
<td rowspan="2"><strong>Resource Development</strong></td>
<td><a href="https://attack.mitre.org/versions/v16/techniques/T1587/001">T1587.001</a></td>
<td>Develop Capabilities: Malware</td>
<td>Bootkitty is a brand-new UEFI bootkit developed by an unknown author.</td>
</tr>
<tr>
<td><a href="https://attack.mitre.org/versions/v16/techniques/T1587/002">T1587.002</a></td>
<td>Develop Capabilities: Code Signing Certificates</td>
<td>Bootkitty sample is signed with a self-signed certificate.</td>
</tr>
<tr>
<td rowspan="2"><strong>Execution</strong></td>
<td><a href="https://attack.mitre.org/versions/v16/techniques/T1106">T1106</a></td>
<td>Native API</td>
<td>BCObserver uses the <span>finit_module</span> system call to load a kernel module.</td>
</tr>
<tr>
<td><a href="https://attack.mitre.org/versions/v16/techniques/T1129">T1129</a></td>
<td>Shared Modules</td>
<td>Bootkitty uses <span>LD_PRELOAD</span> to preload shared modules from a hardcoded path into the <span>init</span> process during system start.</td>
</tr>
<tr>
<td rowspan="2"><strong>Persistence</strong></td>
<td><a href="https://attack.mitre.org/versions/v16/techniques/T1574/006">T1574.006</a></td>
<td>Hijack Execution Flow: Dynamic Linker Hijacking</td>
<td>Bootkitty patches <span>init</span>’s environment variable with <span>LD_PRELOAD</span> so it loads a next stage when executed.</td>
</tr>
<tr>
<td><a href="https://attack.mitre.org/versions/v16/techniques/T1542/003">T1542.003</a></td>
<td>Pre-OS Boot: Bootkit</td>
<td>Bootkitty is a UEFI bootkit meant to be deployed on the EFI System Partition.</td>
</tr>
<tr>
<td rowspan="3"><strong>Defense Evasion</strong></td>
<td><a href="https://attack.mitre.org/versions/v16/techniques/T1014">T1014</a></td>
<td>Rootkit</td>
<td>BCDropper serves as a rootkit implemented as a loadable kernel module for Linux systems.</td>
</tr>
<tr>
<td><a href="https://attack.mitre.org/versions/v16/techniques/T1562/">T1562</a></td>
<td>Impair Defenses</td>
<td>Bootkitty disables signature verification features in the GRUB bootloader and Linux kernel.</td>
</tr>
<tr>
<td><a href="https://attack.mitre.org/versions/v16/techniques/T1564">T1564</a></td>
<td>Hide Artifacts</td>
<td>BCDropper hides itself by removing its module’s entry from the kernel’s modules list.</td>
</tr>
</tbody>
</table>
<p><a href="https://www.eset.com/int/business/services/threat-intelligence/?utm_source=welivesecurity.com&amp;utm_medium=referral&amp;utm_campaign=wls-research&amp;utm_content=bootkitty-analyzing-first-uefi-bootkit-linux&amp;sfdccampaignid=7011n0000017htTAAQ" target="_blank" rel="noopener"><img src="https://web-assets.esetstatic.com/wls/2023/2023-12/welivesecurity-eset-threat-intelligence.jpeg" alt="" width="915" height="296"/></a></p>
</div></div>
  </body>
</html>
