<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.washi.dev/posts/tinysharp/">Original</a>
    <h1>How small is the smallest .NET Hello World binary?</h1>
    
    <div id="readability-page-1" class="page"><div>
  <p>Here is a dumb question that you probably never asked yourself: What is the minimal amount of bytes we need to store in a .NET executable to have the CLR print the string<code>&#34;Hello, World!&#34;</code> to the standard output?</p>

<p><a href="https://medium.com/assets/img/posts/tinysharp/thumbnail.png"><img data-src="/assets/img/posts/tinysharp/thumbnail.png" alt="" data-proofer-ignore=""/></a>
<em>How small can we get?</em></p>

<p>In this post, we will explore the limits of the .NET module file format, get it as small as possible, while still having it function like a normal executable on a typical Windows machine with the .NET Framework installed.</p>

<p>The final source code for this post can be found on my GitHub:</p>

<p><a href="https://gist.github.com/Washi1337/367eede6e00b31e29355626d5e2f3078" target="_blank">
<i aria-hidden="true"></i> Full Source Code
</a></p>

<h2 id="rules"><span>Rules</span><a href="#rules"><i></i></a></h2>

<p>Here are the arbitrary rules I set up for myself:</p>

<ul>
  <li>
    <p><strong>The application must run a managed entry point implemented in C# or CIL.</strong>
This entry point must be responsible for printing <code>&#34;Hello, World!&#34;</code> to the standard output. 
This means we cannot do any of the native entry point shenanigans like we did in a <a href="https://medium.com/entry-points">previous post</a>.
How it actually does the printing, however, is fully up to this method body.</p>
  </li>
  <li>
    <p><strong>The application runs on .NET Framework 4.x.x.</strong>
We do this to give ourselves a little bit more freedom, and it allows us to have a single executable only and leverage some of the features of the Windows PE loader. 
It is also nice to have an executable that we can just double click.</p>
  </li>
  <li>
    <p><strong>No third-party dependencies.</strong> 
We are only allowed to reference the BCL (i.e., mscorlib) and/or other libraries that are installed on a typical Windows machine. 
Otherwise, we could replace all code within our small application with a call to a custom-made dependency, which would be cheating!</p>
  </li>
  <li>
    <p><strong>Ignore zero bytes at the end of the file.</strong>
The PE file format, as well as the CLR itself, puts a hard limit on offset alignments for each section stored in the PE. 
Effectively it means that the theoretically smallest .NET PE that is able to run on Windows 10 or higher cannot be smaller than 1KB. 
As we will see this is rather easy to achieve.
To challenge ourselves a bit more, we strive to get to the “bare minimum description” of a .NET hello world PE file, where we consider all trailing zero bytes as non-existent.</p>
  </li>
</ul>

<p>Let’s get hacking!</p>

<h2 id="establishing-a-baseline"><span>Establishing a baseline</span><a href="#establishing-a-baseline"><i></i></a></h2>

<p>To establish a baseline that we want to beat, let’s first start by compiling the following Hello World application using the latest version of the C# compiler by the time of writing this post.</p>

<div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td><pre><span>using</span> <span>System</span><span>;</span>

<span>namespace</span> <span>ConsoleApp1</span><span>;</span>

<span>internal</span> <span>static</span> <span>class</span> <span>Program</span>
<span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>Main</span><span>(</span><span>string</span><span>[]</span> <span>args</span><span>)</span>
    <span>{</span>
        <span>Console</span><span>.</span><span>WriteLine</span><span>(</span><span>&#34;Hello, World!&#34;</span><span>);</span>
    <span>}</span>
<span>}</span>
</pre></td></tr></tbody></table></code></p></div>

<p>We accompany it with the following <code>.csproj</code> file:</p>

<div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td><pre><span>&lt;Project</span> <span>Sdk=</span><span>&#34;Microsoft.NET.Sdk&#34;</span><span>&gt;</span>

    <span>&lt;PropertyGroup&gt;</span>
        <span>&lt;OutputType&gt;</span>Exe<span>&lt;/OutputType&gt;</span>
        <span>&lt;TargetFramework&gt;</span>net472<span>&lt;/TargetFramework&gt;</span>
        <span>&lt;LangVersion&gt;</span>10<span>&lt;/LangVersion&gt;</span>
        <span>&lt;Nullable&gt;</span>enable<span>&lt;/Nullable&gt;</span>
    <span>&lt;/PropertyGroup&gt;</span>

<span>&lt;/Project&gt;</span>
</pre></td></tr></tbody></table></code></p></div>

<p>This gives us a binary of a whopping <code>4.6KB</code> file:</p>

<p><a href="https://medium.com/assets/img/posts/tinysharp/size01.png"><img data-src="/assets/img/posts/tinysharp/size01.png" alt="" data-proofer-ignore=""/></a>
<em>The size of a standard hello world application.</em></p>

<p>That seems excessive… Clearly we can do better than this.</p>

<h2 id="removing-nullable-reference-annotations"><span>Removing nullable reference annotations</span><a href="#removing-nullable-reference-annotations"><i></i></a></h2>

<p>Inspecting the application in a .NET decompiler gives us a bit more insight on what is going on.
Since C# 8.0 we have known the concept of <a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/nullable-reference-types">nullable reference types</a>.
These are special annotations that allows the C# compiler to reason about potentially unwanted null references to be passed on to functions, variables and parameters.
The downside is that these annotations are implemented in the form of custom attributes, which are linked into the executable statically and notoriously large:</p>

<p><a href="https://medium.com/assets/img/posts/tinysharp/dnSpy01.png"><img data-src="/assets/img/posts/tinysharp/dnSpy01.png" alt="" data-proofer-ignore=""/></a>
<em>Nullable Reference Types add many Custom Attributes to a .NET image</em></p>

<p>Let’s disable that with one option in our <code>.csproj</code> file:</p>

<div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td><pre><span>&lt;Project</span> <span>Sdk=</span><span>&#34;Microsoft.NET.Sdk&#34;</span><span>&gt;</span>

    <span>&lt;PropertyGroup&gt;</span>
        <span>&lt;OutputType&gt;</span>Exe<span>&lt;/OutputType&gt;</span>
        <span>&lt;TargetFramework&gt;</span>net472<span>&lt;/TargetFramework&gt;</span>
        <span>&lt;LangVersion&gt;</span>10<span>&lt;/LangVersion&gt;</span>
        
         <span>&lt;!-- Disable nullable reference type checks. --&gt;</span>
        <span>&lt;Nullable&gt;</span>disable<span>&lt;/Nullable&gt;</span>
    <span>&lt;/PropertyGroup&gt;</span>

<span>&lt;/Project&gt;</span>
</pre></td></tr></tbody></table></code></p></div>

<p>While this does get rid of all the attributes, we are unfortunately still left with a binary that is <code>4.6KB</code> in size, due to the PE file alignments.</p>

<h2 id="manually-crafting-a-net-module"><span>Manually crafting a .NET module</span><a href="#manually-crafting-a-net-module"><i></i></a></h2>

<p>Further inspecting the output in a decompiler shows that, even with nullable references disabled, the C# compiler still emits many type references to custom attributes in our application. 
In particular, they include many attributes assigned to the assembly itself, such as file version metadata and copyright information.
Additionally, besides our class <code>Program</code> we also have a hidden <code>&lt;Module&gt;</code> type that looks rather empty:</p>

<p><a href="https://medium.com/assets/img/posts/tinysharp/dnSpy02.png"><img data-src="/assets/img/posts/tinysharp/dnSpy02.png" alt="" data-proofer-ignore=""/></a>
<em>The C# compiler still emits a lot of unnecessary metadata</em></p>

<p>We could try and figure out how to instruct the compiler to disable generating all this metadata, but I figured, if we are going to the extreme, we may as well just build a .NET executable file from scratch by ourselves. 
This way we have more control over the final output, allowing us to just emit the bare minimum that is required to print <code>&#34;Hello World&#34;</code>, and not emit those unnecessary file metadata attributes.
Furthermore, we can just place our <code>main</code> function into the <code>&lt;Module&gt;</code> type and get rid of our <code>Program</code> class as well.
Below is an example implementation of building a small Hello World application using <a href="https://medium.com/@rey_soleil/github.com/washi1337/asmresolver">AsmResolver</a>:</p>

<div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre></td><td><pre><span>// Define new assembly and module.</span>
<span>var</span> <span>assembly</span> <span>=</span> <span>new</span> <span>AssemblyDefinition</span><span>(</span><span>&#34;assembly&#34;</span><span>,</span> <span>new</span> <span>Version</span><span>(</span><span>1</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>));</span>
<span>var</span> <span>module</span> <span>=</span> <span>new</span> <span>ModuleDefinition</span><span>(</span><span>&#34;module.exe&#34;</span><span>);</span>
<span>assembly</span><span>.</span><span>Modules</span><span>.</span><span>Add</span><span>(</span><span>module</span><span>);</span>

<span>// Obtain &lt;Module&gt; type.</span>
<span>var</span> <span>moduleType</span> <span>=</span> <span>module</span><span>.</span><span>GetOrCreateModuleType</span><span>();</span>

<span>// Craft a new Main method.</span>
<span>var</span> <span>factory</span> <span>=</span> <span>module</span><span>.</span><span>CorLibTypeFactory</span><span>;</span>
<span>var</span> <span>main</span> <span>=</span> <span>new</span> <span>MethodDefinition</span><span>(</span><span>&#34;main&#34;</span><span>,</span> <span>MethodAttributes</span><span>.</span><span>Static</span><span>,</span> <span>MethodSignature</span><span>.</span><span>CreateStatic</span><span>(</span><span>factory</span><span>.</span><span>Void</span><span>));</span>
<span>main</span><span>.</span><span>CilMethodBody</span> <span>=</span> <span>new</span> <span>CilMethodBody</span><span>(</span><span>main</span><span>)</span>
<span>{</span>
    <span>Instructions</span> <span>=</span>
    <span>{</span>
        <span>{</span><span>Ldstr</span><span>,</span> <span>&#34;Hello, World!&#34;</span><span>},</span>
        <span>{</span><span>Call</span><span>,</span> <span>factory</span><span>.</span><span>CorLibScope</span>
            <span>.</span><span>CreateTypeReference</span><span>(</span><span>&#34;System&#34;</span><span>,</span><span>&#34;Console&#34;</span><span>)</span>
            <span>.</span><span>CreateMemberReference</span><span>(</span><span>&#34;WriteLine&#34;</span><span>,</span> <span>MethodSignature</span><span>.</span><span>CreateStatic</span><span>(</span><span>factory</span><span>.</span><span>Void</span><span>,</span> <span>factory</span><span>.</span><span>String</span><span>))</span>
            <span>.</span><span>ImportWith</span><span>(</span><span>module</span><span>.</span><span>DefaultImporter</span><span>)</span>
        <span>},</span>
        <span>Ret</span>
    <span>}</span>
<span>};</span>

<span>// Add main to &lt;Module&gt;</span>
<span>moduleType</span><span>.</span><span>Methods</span><span>.</span><span>Add</span><span>(</span><span>main</span><span>);</span>

<span>// Register main as the entry point of the module:</span>
<span>module</span><span>.</span><span>ManagedEntryPointMethod</span> <span>=</span> <span>main</span><span>;</span>

<span>// Write to disk.</span>
<span>module</span><span>.</span><span>Write</span><span>(</span><span>&#34;output.exe&#34;</span><span>);</span>
</pre></td></tr></tbody></table></code></p></div>

<p>This did a great deal already, we cut our file size in half:</p>

<p><a href="https://medium.com/assets/img/posts/tinysharp/size02.png"><img data-src="/assets/img/posts/tinysharp/size02.png" alt="" data-proofer-ignore=""/></a>
<em>The size of a hello world application emitted by AsmResolver.</em></p>

<p>But we can do better…</p>

<h2 id="getting-rid-of-imports-and-base-relocations"><span>Getting rid of Imports and Base Relocations</span><a href="#getting-rid-of-imports-and-base-relocations"><i></i></a></h2>

<p>If we look into the resulting executable file using a tool like <a href="https://ntcore.com/?page_id=388">CFF Explorer</a>, we can see that the file contains two sections <code>.text</code> and <code>.reloc</code>.
Furthermore, it also contains two very large data directories called the Imports and Base Relocations directory respectively.</p>

<p><a href="https://medium.com/assets/img/posts/tinysharp/cff01.png"><img data-src="/assets/img/posts/tinysharp/cff01.png" alt="" data-proofer-ignore=""/></a>
<em>By default, 32-bit .NET images contain imports and base relocations that take a lot of space.</em></p>

<p>This is pretty typical for any AnyCPU or 32-bit .NET executable file.
The imports directory is required because 32-bit .NET executable files require an unmanaged entry point calling <code>mscoree!_CorExeMain</code>, as we have seen in a <a href="https://medium.com/entry-points">previous post</a>.
Furthermore, by default .NET executables are relocatable, that is, the Windows PE Loader is free to map the executable at any memory address it likes.
This means every 32-bit .NET executable also needs a base relocation for the call to this imported function to be registered in the relocation directory.
This is problematic, because it is by default put in a fully separate section.
As every section needs to be aligned to the smallest possible section alignment of <code>0x200</code> bytes (1KB), we inflate our file by at least that amount of bytes just because of that.</p>

<p>Fortunately for us, 64-bit .NET executables do not need such an unmanaged entry point anymore.
With just two extra lines added to our previous script, we can get rid of both directories, an entire PE section, and thus shave off an entire kilobyte worth of data from our binary file:</p>

<div><p><code><table><tbody><tr><td><pre>1
2
3
</pre></td><td><pre><span>// Output a 64-bit module.</span>
<span>module</span><span>.</span><span>PEKind</span> <span>=</span> <span>OptionalHeaderMagic</span><span>.</span><span>PE64</span><span>;</span>
<span>module</span><span>.</span><span>MachineType</span> <span>=</span> <span>MachineType</span><span>.</span><span>Amd64</span><span>;</span>
</pre></td></tr></tbody></table></code></p></div>

<p><a href="https://medium.com/assets/img/posts/tinysharp/cff02.png"><img data-src="/assets/img/posts/tinysharp/cff02.png" alt="" data-proofer-ignore=""/></a>
<em>64-bit .NET images do not need imports or base relocations.</em></p>

<p>And indeed, we get to the theoretically possible minimum size of 1KB of a valid .NET PE file:</p>

<p><a href="https://medium.com/assets/img/posts/tinysharp/size03.png"><img data-src="/assets/img/posts/tinysharp/size03.png" alt="" data-proofer-ignore=""/></a>
<em>The minimum size of a PE file is reached.</em></p>



<p>We could have called it quits here, but I decided to look a little bit deeper into what really we can strip out of a binary to get to the absolute bare minimum of a .NET hello world executable.
From now on, we won’t be looking at the file size as reported by Windows Explorer.
Instead, we will be looking at a hex editor and see where the last non-zero byte is stored and consider that to be our final file size.
If we do this for our current file, we can actually see we are already down to a size of 991 bytes (<code>0x3DF</code>):</p>

<p><a href="https://medium.com/assets/img/posts/tinysharp/size04.png"><img data-src="/assets/img/posts/tinysharp/size04.png" alt="" data-proofer-ignore=""/></a>
<em>The size we will be considering is the index of of the byte after the last non-zero byte in the file.</em></p>

<p>What is still contributing to this amount of bytes?
If we look again in a disassembler, we can see that the <code>#Strings</code> heap in a .NET binary is the second largest metadata stream stored in the file.
It contains all the names that the tables stream (<code>#~</code>) uses, which stores all the types and methods that our application defines and uses.
As it so turns out, many of these names are actually not really important to the runtime:</p>

<p><a href="https://medium.com/assets/img/posts/tinysharp/dnSpy03.png"><img data-src="/assets/img/posts/tinysharp/dnSpy03.png" alt="" data-proofer-ignore=""/></a>
<em>Names take up a lot of space.</em></p>

<p>Thus, setting these to <code>null</code> instead will give us an application that looks a bit like the following:</p>

<p><a href="https://medium.com/assets/img/posts/tinysharp/dnSpy04.png"><img data-src="/assets/img/posts/tinysharp/dnSpy04.png" alt="" data-proofer-ignore=""/></a>
<em>Truncating names.</em></p>

<p>Believe it or not, the application still runs fine and happily outputs “Hello World”, regardless of whether this looks fine or not.
Best of all, it shaved a whopping 32 bytes from our file:</p>

<p><a href="https://medium.com/assets/img/posts/tinysharp/size05.png"><img data-src="/assets/img/posts/tinysharp/size05.png" alt="" data-proofer-ignore=""/></a>
<em>The size of the file after stripping names.</em></p>



<p>What other unnecessary metadata is there that the CLR does not really care about?</p>

<p>Our next target is getting rid of the <code>#GUID</code> stream.
This stream is present in virtually any .NET executable, and contains, as its names implies, a list of GUIDs.
However, the only type of metadata that really references it, is the Module table.
This table has a column called <code>Mvid</code>, which is supposed to reference a GUID that makes the module uniquely identifiable across different versions of compiled binaries.</p>

<p><a href="https://medium.com/assets/img/posts/tinysharp/cff04.png"><img data-src="/assets/img/posts/tinysharp/cff04.png" alt="" data-proofer-ignore=""/></a>
<em>A module contains an optional MVID, which is a GUID of 16 bytes.</em></p>

<p>We do not care about versioning, we just want the smallest binary possible. 
We can just get rid of it and save 16 bytes that were originally making up the Mvid.
However, by doing so, the <code>#GUID</code> stream is now empty and thus is no longer needed. 
By removing the stream in its entirety, we save another 16 bytes that make up its header, making a total of 32 bytes that we save with this.</p>

<p>Additionally, the <code>Console::WriteLine</code> method that we call in our <code>Main</code> function is defined in <code>mscorlib</code>. 
Typically, references to BCL assemblies are annotated with a public key token of 8 bytes.</p>

<p><a href="https://medium.com/assets/img/posts/tinysharp/cff03.png"><img data-src="/assets/img/posts/tinysharp/cff03.png" alt="" data-proofer-ignore=""/></a>
<em>The reference to <code>mscorlib</code> contains a long public key token.</em></p>

<p>It so turns out that if there is no public key token present in this reference, the CLR then just does not verify this assembly token for authenticity.
Since we do not care about security anyways in our experiment, we can get rid of this too.</p>

<p>This brings us down to a file of 918 bytes in total:</p>

<p><a href="https://medium.com/assets/img/posts/tinysharp/size06.png"><img data-src="/assets/img/posts/tinysharp/size06.png" alt="" data-proofer-ignore=""/></a>
<em>The size after stripping GUIDs and public key tokens.</em></p>

<h2 id="getting-rid-of-consolewriteline"><span>Getting rid of Console.WriteLine</span><a href="#getting-rid-of-consolewriteline"><i></i></a></h2>

<p>If we look at other metadata streams defined in our assembly, we find that our <code>&#34;Hello, World!&#34;</code> string is actually stored in a rather inefficient manner.
In .NET, all user strings are put in the <code>#US</code> metadata stream as a length-prefixed array of 16-bit wide characters followed by an additional zero byte.
This is done to support a wide range of the UNICODE character set.
However, all the characters in the string that we want to print have a code-point value smaller than 255 (<code>0xFF</code>), the max value of a single byte.
Why should we then use 2 bytes per character?
Furthermore, this is the only user string that we need in our binary.
Having an entire 12-bytes stream header for just one string seems rather excessive:</p>

<p><a href="https://medium.com/assets/img/posts/tinysharp/cff05.png"><img data-src="/assets/img/posts/tinysharp/cff05.png" alt="" data-proofer-ignore=""/></a>
<em>User strings in .NET always use wide character encoding.</em></p>

<p>Unfortunately, there is no way turn this wide-character string in the <code>#US</code> stream to a single-byte ASCII string, and to tell the CLR to interpret it as such.</p>

<p>Time to get creative!</p>

<p>If we want to print an ASCII string as opposed to a wide-character string, we need a function that accepts those types of strings.
<code>Console::WriteLine</code> is not a function that fits this criterium, so we need to get rid of it.
However, the unmanaged function <code>ucrtbase!puts</code> does.
.NET allows for invoking unmanaged functions by using a feature called <a href="https://learn.microsoft.com/en-us/dotnet/standard/native-interop/pinvoke">Platform Invoke (P/Invoke)</a>.
We can define <code>puts</code> using P/Invoke in the following manner in C#:</p>

<div><p><code><table><tbody><tr><td><pre>1
2
</pre></td><td><pre><span>[</span><span>DllImport</span><span>(</span><span>&#34;ucrtbase&#34;</span><span>)]</span>
<span>static</span> <span>extern</span> <span>int</span> <span>puts</span><span>(</span><span>nint</span> <span>str</span><span>);</span>
</pre></td></tr></tbody></table></code></p></div>

<p>However, there is a problem.
The <code>puts</code> function accepts a pointer to a string. 
This pointer must be a valid <strong>runtime address</strong> that points to the start of the zero-terminated ASCII string that we want to print.
How do we know where our string is stored at compile-time so that we can push it in our <code>main</code> method?</p>

<p>It so turns out we can solve this by unchecking the <code>DynamicBase</code> flag in the <code>DllCharacteristics</code> field of the PE’s optional header.
This allows us to fix the base address the module will be mapped on at runtime.
We can then decide an arbitrary base address, put the ASCII string anywhere in our <code>.text</code> section, and calculate the runtime address by the formula <code>module_base_address + rva_ascii_string</code>.</p>

<div><p><code><table><tbody><tr><td><pre>1
2
3
4
</pre></td><td><pre><span>var</span> <span>image</span> <span>=</span> <span>module</span><span>.</span><span>ToPEImage</span><span>();</span>

<span>image</span><span>.</span><span>ImageBase</span> <span>=</span> <span>0x00000000004e0000</span><span>;</span>
<span>image</span><span>.</span><span>DllCharacteristics</span> <span>&amp;=</span> <span>~</span><span>DllCharacteristics</span><span>.</span><span>DynamicBase</span><span>;</span>
</pre></td></tr></tbody></table></code></p></div>

<p>In order to have the CLR actually respect this flag, we also need to unset the <code>ILOnly</code> flag in the .NET data directory:</p>

<div><p><code><table><tbody><tr><td><pre>1
</pre></td><td><pre><span>image</span><span>.</span><span>DotNetDirectory</span><span>!.</span><span>Flags</span> <span>&amp;=</span> <span>~</span><span>DotNetDirectoryFlags</span><span>.</span><span>ILOnly</span><span>;</span>
</pre></td></tr></tbody></table></code></p></div>

<p>We can then simply pass the calculated address directly in our <code>puts</code> function call as a normal integer:</p>

<p><a href="https://medium.com/assets/img/posts/tinysharp/dnSpy05.png"><img data-src="/assets/img/posts/tinysharp/dnSpy05.png" alt="" data-proofer-ignore=""/></a>
<em>Replace <code>Console::WriteLine</code> with <code>ucrtbase!puts</code>, allowing us to use an ASCII string instead.</em></p>

<p>And there we go, we not only got rid of our wide-character string, but also the entire <code>#US</code> stream, as well as the reference to <code>System.Console::WriteLine</code> which also contributes quite a few bytes to the size of our file.
In turn, we got a few bytes back due to the new required <code>puts</code> method definition and its associated P/Invoke metadata, but it is for sure a big shrink.</p>

<p>We are now down to 889 bytes (<code>0x379</code>):</p>

<p><a href="https://medium.com/assets/img/posts/tinysharp/size07.png"><img data-src="/assets/img/posts/tinysharp/size07.png" alt="" data-proofer-ignore=""/></a>
<em>The size of the file after removing <code>Console::WriteLine</code> and using ASCII strings.</em></p>

<h2 id="other-micro-optimizations"><span>Other micro optimizations</span><a href="#other-micro-optimizations"><i></i></a></h2>

<p>There are a few things we still can do.</p>

<p>Our <code>puts</code> definition follows the canonical definition as provided by the C runtime library. 
This means the function is defined to return an <code>int32</code> representing the number of characters that were written to the standard output.
However, we do not care about this value.
Indeed, in our main method, we pop this value right after the call to keep the CLR happy:</p>

<p><a href="https://medium.com/assets/img/posts/tinysharp/dnSpy06.png"><img data-src="/assets/img/posts/tinysharp/dnSpy06.png" alt="" data-proofer-ignore=""/></a>
<em>Returning an <code>int32</code> means the value needs to be popped from the evaluation stack again.</em></p>

<p>Since this is a 64-bit PE file anyways, the <code>puts</code> function will use the <a href="https://learn.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-170">x64 calling conventions</a> as described by Microsoft.
In simple terms, this means at runtime the return value is not really pushed on the stack as with normal .NET method calls, but rather put in the <code>RAX</code> register.
Since we do not use this value anyways, we can just turn the definition into <code>void</code>, effectively disregarding whatever is put into this register.
As the function is now no longer returning anything, nothing is also pushed onto the evaluation stack in our main method.
This allows us to get rid of the <code>pop</code> instruction in our main method:</p>

<p><a href="https://medium.com/assets/img/posts/tinysharp/dnSpy07.png"><img data-src="/assets/img/posts/tinysharp/dnSpy07.png" alt="" data-proofer-ignore=""/></a>
<em>Changing to a <code>void</code> means the <code>pop</code> instruction is no longer required.</em></p>

<p>We can also move the ASCII string that we pass on to the <code>puts</code> function to a slightly better place.
The PE file format contains a lot of segments that are aligned to a certain byte-boundary.
In particular, as was mentioned before, sections are aligned to the nearest multiple of <code>0x200</code> (1KB).
This also includes the first section.
However, since the PE file headers of our file take up less space than <code>0x200</code> bytes, we end up with a chunk of padding data between our headers and first section data:</p>

<p><a href="https://medium.com/assets/img/posts/tinysharp/hxd01.png"><img data-src="/assets/img/posts/tinysharp/hxd01.png" alt="" data-proofer-ignore=""/></a>
<em>PE images contain some padding between the headers and the first section.</em></p>

<p>It so turns out the Windows PE Loader always maps the PE headers as a chunk of readable memory. 
The good news is, it also includes this padding data.</p>

<p>Let’s move our string there!</p>

<p><a href="https://medium.com/assets/img/posts/tinysharp/hxd02.png"><img data-src="/assets/img/posts/tinysharp/hxd02.png" alt="" data-proofer-ignore=""/></a>
<em>Place the string to print into the unused padding segment.</em></p>

<p>By moving our string there, we effectively truncated our file by 13 bytes.</p>

<p>Since we also do not reference <code>Console::WriteLine</code> anymore, we also do not longer need the reference to <code>mscorlib</code> to be stored in our binary.
This also saves quite a bit of space, since it means one less table to store in the tables stream (<code>#~</code>), as well as the name <code>mscorlib</code> to be removed from the <code>#Strings</code> stream.</p>

<p><a href="https://medium.com/assets/img/posts/tinysharp/cff07.png"><img data-src="/assets/img/posts/tinysharp/cff07.png" alt="" data-proofer-ignore=""/></a>
<em>We no longer depend on <code>&#34;mscorlib&#34;</code>, thus we do no longer need a reference to it.</em></p>

<p>Finally, we can end with a bit of a weird one.
The .NET metadata directory contains a field called <code>VersionString</code>, containing the minimum required version of the .NET Framework that is required to run this .NET executable.
By default, for .NET 4.0+ binaries, this contains the string <code>&#34;v4.0.30319&#34;</code> padded with zero bytes to the nearest multiple of 4 (totaling 12 bytes).
However, we can truncate this string to just <code>v4.0.</code>, stripping a total of 4 bytes after padding, to trick .NET to still boot up the CLR version 4.0 and run the program successfully.</p>

<p><a href="https://medium.com/assets/img/posts/tinysharp/cff06.png"><img data-src="/assets/img/posts/tinysharp/cff06.png" alt="" data-proofer-ignore=""/></a>
<em>The .NET metadata directory contains a version string specifying the required runtime which can be truncated.</em></p>

<p>Note that, for some reason, the trailing <code>.</code> seems to be important. I have no idea why, but getting rid of anything more than this string will make the program not boot up correctly.</p>

<p>Our final size is 834 bytes (<code>0x342</code>):</p>

<p><a href="https://medium.com/assets/img/posts/tinysharp/size08.png"><img data-src="/assets/img/posts/tinysharp/size08.png" alt="" data-proofer-ignore=""/></a>
<em>The final size of our binary.</em></p>

<p>We can ZIP it to get it to a mere 476 bytes (compared to 582 bytes if we did not do any optimizations after reaching the 1KB limit).
This is where I decided to call it quits.</p>

<p>Finally, to prove the program still works fine, here is a screenshot:</p>

<p><a href="https://medium.com/assets/img/posts/tinysharp/final.png"><img data-src="/assets/img/posts/tinysharp/final.png" alt="" data-proofer-ignore=""/></a>
<em>It still works!</em></p>

<h2 id="final-words"><span>Final Words</span><a href="#final-words"><i></i></a></h2>

<p>This was a dumb way to spend my Saturday.</p>

<p>Even though this is probably quite a useless project, I still like diving into these dumb rabbit holes every now and then.
Exploring the limits of well-established systems is always fun, even if the end result is kind of pointless.</p>

<p>To summarize what we have done, we went from a Hello World file of <code>4.6 KB</code> compiled by the C# compiler to a handcrafted PE file of <code>834 B</code> excluding trailing zero bytes.
I don’t think we can get any smaller than this, but I am happy to be proven wrong!</p>

<p>As said before, the final source code to produce the binary can be found on my GitHub:</p>

<p><a href="https://gist.github.com/Washi1337/367eede6e00b31e29355626d5e2f3078" target="_blank">
<i aria-hidden="true"></i> Full Source Code
</a></p>

<p>Happy hacking!</p>


</div></div>
  </body>
</html>
