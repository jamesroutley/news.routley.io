<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://n0rdy.foo/posts/20250121/okta-bcrypt-lessons-for-better-apis/">Original</a>
    <h1>Okta Bcrypt incident lessons for designing better APIs</h1>
    
    <div id="readability-page-1" class="page"><div>
                <div>
  <div>
  

  <div>
    <p><time datetime=" 2025-01-22T18:00:00+0100">
        January 22, 2025
      </time>
      
      <span> - </span>
      <span>
        
          
        

        <span>16 mins read</span>
      </span>
    </p>

    
    
    
  </div>

  
  

  
</div>

  <p>Hello there! If you follow tech news, you might have heard about the <a href="https://trust.okta.com/security-advisories/okta-ad-ldap-delegated-authentication-username/" target="_blank">Okta security incident</a> that was reported on 1st of November. The TLDR of the incident was this:</p>
<blockquote>
<p>The Bcrypt algorithm was used to generate the cache key where we hash a  combined string of userId + username + password. Under a specific set of conditions, listed below, this could allow users to authenticate by  providing the username with the stored cache key of a previous  successful authentication.</p>
</blockquote>
<p>This means that if the user had a username above 52 chars, any password would suffice to log in. Also, if the username is, let’s say, 50 chars long, it means that the bad actor needs to guess only 3 first chars to get in, which is quite a trivial task for the computers these days. Too bad, isn’t it?</p>
<p>On the other hand, such long usernames are not very usual, which I agree with. However, some companies like using the entire name of the employee as the email address. So, let’s say, Albus Percival Wulfric Brian Dumbledore, a headmaster of Hogwarts, should be concerned, as <code><a href="https://n0rdy.foo/cdn-cgi/l/email-protection" data-cfemail="fe9f929c8b8dd08e9b8c9d97889f92d0898b92988c979dd09c8c979f90d09a8b939c929b9a918c9bbe969199899f8c8a8dd08d9d96919192">[email protected]</a></code> is 55 chars. Ooops!</p>
<p><img src="https://n0rdy.foo/images/drawings/20250122-0001.webp" alt="image"/></p>
<p>This was possible due to the nature of Bcrypt hashing algorithm that has a maximum supported input length of 72 characters (read more <a href="https://en.wikipedia.org/wiki/Bcrypt#Maximum_password_length" target="_blank">here</a>), so in Okta case the characters above the limit were ignored while computing the hash, and therefore, not used in the comparison operation. We can reverse engineer that:</p>
<ul>
<li><code>72 - 53 = 19</code> - user id with separators if any</li>
<li>this way, the password will be outside the 72 chars limit, and, therefore, ignored by the Bcrypt algorithm</li>
</ul>
<p>However, there was one thing that made me wonder: if there is a known limit of the algorithm, why is it not enforced by the crypto libraries as a form of input validation? A simple <code>if input length &gt; 72 -&gt; return error</code> will do the trick. I assumed that they might have used some custom library for Bcrypt implementation and simply forgotten about the input validation, which can happen. So, I decided to check how other programming languages behave.</p>
<h2 id="go-and-bcrypt">Go and Bcrypt</h2>
<p>Let’s start with Go, and implement the Okta incident-like case with the help of the official <code>golang.org/x/crypto/bcrypt</code> library:</p>
<div><pre tabindex="0"><code data-lang="go"><span><span><span>package</span> <span>main</span>
</span></span><span><span>
</span></span><span><span><span>import</span> (
</span></span><span><span>	<span>&#34;crypto/rand&#34;</span>
</span></span><span><span>	<span>&#34;encoding/base64&#34;</span>
</span></span><span><span>	<span>&#34;fmt&#34;</span>
</span></span><span><span>	<span>&#34;golang.org/x/crypto/bcrypt&#34;</span>
</span></span><span><span>)
</span></span><span><span>
</span></span><span><span><span>func</span> <span>main</span>() {
</span></span><span><span>	<span>// 18 + 55 + 1 = 74, so above 72 characters&#39; limit of BCrypt
</span></span></span><span><span><span></span>	<span>userId</span> <span>:=</span> <span>randomString</span>(<span>18</span>)
</span></span><span><span>	<span>username</span> <span>:=</span> <span>randomString</span>(<span>55</span>)
</span></span><span><span>	<span>password</span> <span>:=</span> <span>&#34;super-duper-secure-password&#34;</span>
</span></span><span><span>
</span></span><span><span>	<span>combinedString</span> <span>:=</span> <span>fmt</span>.<span>Sprintf</span>(<span>&#34;%s:%s:%s&#34;</span>, <span>userId</span>, <span>username</span>, <span>password</span>)
</span></span><span><span>
</span></span><span><span>	<span>combinedHash</span>, <span>err</span> <span>:=</span> <span>bcrypt</span>.<span>GenerateFromPassword</span>([]byte(<span>combinedString</span>), <span>bcrypt</span>.<span>DefaultCost</span>)
</span></span><span><span>	<span>if</span> <span>err</span> <span>!=</span> <span>nil</span> {
</span></span><span><span>		panic(<span>err</span>)
</span></span><span><span>	}
</span></span><span><span>
</span></span><span><span>	<span>// let&#39;s try to break it
</span></span></span><span><span><span></span>	<span>wrongPassword</span> <span>:=</span> <span>&#34;wrong-password&#34;</span>
</span></span><span><span>	<span>wrongCombinedString</span> <span>:=</span> <span>fmt</span>.<span>Sprintf</span>(<span>&#34;%s:%s:%s&#34;</span>, <span>userId</span>, <span>username</span>, <span>wrongPassword</span>)
</span></span><span><span>
</span></span><span><span>	<span>err</span> = <span>bcrypt</span>.<span>CompareHashAndPassword</span>(<span>combinedHash</span>, []byte(<span>wrongCombinedString</span>))
</span></span><span><span>	<span>if</span> <span>err</span> <span>!=</span> <span>nil</span> {
</span></span><span><span>		<span>fmt</span>.<span>Println</span>(<span>&#34;Password is incorrect&#34;</span>)
</span></span><span><span>	} <span>else</span> {
</span></span><span><span>		<span>fmt</span>.<span>Println</span>(<span>&#34;Password is correct&#34;</span>)
</span></span><span><span>	}
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>func</span> <span>randomString</span>(<span>length</span> <span>int</span>) <span>string</span> {
</span></span><span><span>	<span>bytes</span> <span>:=</span> make([]<span>byte</span>, <span>length</span>)
</span></span><span><span>	<span>_</span>, <span>err</span> <span>:=</span> <span>rand</span>.<span>Read</span>(<span>bytes</span>)
</span></span><span><span>	<span>if</span> <span>err</span> <span>!=</span> <span>nil</span> {
</span></span><span><span>		panic(<span>err</span>)
</span></span><span><span>	}
</span></span><span><span>	<span>return</span> <span>base64</span>.<span>URLEncoding</span>.<span>EncodeToString</span>(<span>bytes</span>)[:<span>length</span>]
</span></span><span><span>}
</span></span></code></pre></div><p>All the code samples can be found <a href="https://github.com/n0rdy/n0rdy-blog-code-samples/tree/main/20250122-bcrypt-api" target="_blank">here</a></p>
<p>What this code does is:</p>
<ul>
<li>generates 18-chars long userId</li>
<li>generates 55-chars long username</li>
<li>concatenates them with each other and a dummy password <code>super-duper-secure-password</code> with the use of <code>:</code> as a separator</li>
<li>computes Bcrypt hash from the concatenated string</li>
<li>then concatenates the same userId and username with a different password <code>wrong-password</code></li>
<li>uses bcrypt API to compare whether the 2nd concatenated string matches the hash of the 1st one</li>
</ul>
<p>Let’s run the code and see the result:</p>
<div><pre tabindex="0"><code data-lang="plain"><span><span>panic: bcrypt: password length exceeds 72 bytes
</span></span><span><span>
</span></span><span><span>goroutine 1 [running]:
</span></span><span><span>main.main()
</span></span><span><span>	/n0rdy-blog-code-samples/20250121-bcrypt-api/01-bcrypt-in-go/main.go:20 +0x2d1
</span></span></code></pre></div><p>Good job, Go! If we check the source code of the <code>bcrypt.GenerateFromPassword(...)</code> function, we’ll see this piece of code at the very beginning:</p>
<div><pre tabindex="0"><code data-lang="go"><span><span><span>if</span> len(<span>password</span>) &gt; <span>72</span> {
</span></span><span><span>	<span>return</span> <span>nil</span>, <span>ErrPasswordTooLong</span>
</span></span><span><span>}
</span></span></code></pre></div><p>Perfect! At this point, I became even more suspicious about the tool Okta used, as it seemed like the industry figured that out based on this example. Spoiler alert: it’s not that simple.</p>
<p>Let’s proceed with Java.</p>
<p><em>Btw, if you like my blog and don’t want to miss out on new posts, consider subscribing to my newsletter <a href="https://mail.n0rdy.foo/subscription/form" target="_blank">here</a>. You’ll receive an email once I publish a new post.</em></p>
<h2 id="java-and-bcrypt">Java and Bcrypt</h2>
<p>Java doesn’t support Bcrypt from its core API, but my simple Google search showed that Spring Security library has implemented it. For those who are not into Java ecosystem, Spring is the most used and battle-tested frameworks out there, that has libraries for almost anything: Web, DBs, Cloud, Security, AI, etc. Pretty powerful tool, that I’ve used a lot in the past, and still sometimes use for my side projects.</p>
<h3 id="spring-security">Spring Security</h3>
<p>So, I added the latest version of Spring Security to the project and reproduced the same scenario, as in Go example above:</p>
<div><pre tabindex="0"><code data-lang="java"><span><span><span>import</span> org.apache.commons.lang3.RandomStringUtils;
</span></span><span><span><span>import</span> org.springframework.security.crypto.bcrypt.BCrypt;
</span></span><span><span>
</span></span><span><span><span>public</span> <span>class</span> <span>BcriptSpringSecurity</span> {
</span></span><span><span>    <span>public</span> <span>static</span> <span>void</span> <span>main</span>(String<span>[]</span> args) {
</span></span><span><span>        <span>// 18 + 55 + 1 = 74, so above 72 characters&#39; limit of BCrypt</span>
</span></span><span><span>        <span>var</span> userId <span>=</span> RandomStringUtils.<span>randomAlphanumeric</span>(18);
</span></span><span><span>        <span>var</span> username <span>=</span> RandomStringUtils.<span>randomAlphanumeric</span>(55);
</span></span><span><span>        <span>var</span> password <span>=</span> <span>&#34;super-duper-secure-password&#34;</span>;
</span></span><span><span>
</span></span><span><span>        <span>var</span> combinedString <span>=</span> String.<span>format</span>(<span>&#34;%s:%s:%s&#34;</span>, userId, username, password);
</span></span><span><span>
</span></span><span><span>        <span>var</span> combinedHash <span>=</span> BCrypt.<span>hashpw</span>(combinedString, BCrypt.<span>gensalt</span>());
</span></span><span><span>
</span></span><span><span>        <span>// let&#39;s try to break it</span>
</span></span><span><span>        <span>var</span> wrongPassword <span>=</span> <span>&#34;wrong-password&#34;</span>;
</span></span><span><span>        <span>var</span> wrongCombinedString <span>=</span> String.<span>format</span>(<span>&#34;%s:%s:%s&#34;</span>, userId, username, wrongPassword);
</span></span><span><span>
</span></span><span><span>        <span>if</span> (BCrypt.<span>checkpw</span>(wrongCombinedString, combinedHash)) {
</span></span><span><span>            System.<span>out</span>.<span>println</span>(<span>&#34;Password is correct&#34;</span>);
</span></span><span><span>        } <span>else</span> {
</span></span><span><span>            System.<span>out</span>.<span>println</span>(<span>&#34;Password is incorrect&#34;</span>);
</span></span><span><span>        }
</span></span><span><span>    }
</span></span><span><span>}
</span></span></code></pre></div><p>I ran the code, and to my great surprise, saw this outcome:</p>
<p>I took a peak at the implementation code, and was disappointed: even though there are a bunch of checks on salt:</p>
<pre tabindex="0"><code>if (saltLength &lt; 28) {
	throw new IllegalArgumentException(&#34;Invalid salt&#34;);
}
...
if (salt.charAt(0) != &#39;$&#39; || salt.charAt(1) != &#39;2&#39;) {
	throw new IllegalArgumentException(&#34;Invalid salt version&#34;);
}
...
minor = salt.charAt(2);
if ((minor != &#39;a&#39; &amp;&amp; minor != &#39;x&#39; &amp;&amp; minor != &#39;y&#39; &amp;&amp; minor != &#39;b&#39;) || salt.charAt(3) != &#39;$&#39;) {
	throw new IllegalArgumentException(&#34;Invalid salt revision&#34;);
}
...
</code></pre><p>I didn’t see any validation of the input that will be hashed. Hm…</p>
<p>I decided to check other Google results, and the next Java library in the list was <code>bcrypt</code> from Patrick Favre (<a href="https://github.com/patrickfav/bcrypt" target="_blank">link to GitHub repo</a>) with 513 starts and the last release version 0.10.2 (so, not stable) from 12th of February 2023 (almost 2 years old). This suggested that I’d not use it in production, but why not to run our tests.</p>
<h3 id="bcrypt-from-patrick-favre">Bcrypt from Patrick Favre</h3>
<div><pre tabindex="0"><code data-lang="java"><span><span><span>import</span> at.favre.lib.crypto.bcrypt.BCrypt;
</span></span><span><span><span>import</span> org.apache.commons.lang3.RandomStringUtils;
</span></span><span><span>
</span></span><span><span><span>public</span> <span>class</span> <span>BcryptAtFavre</span> {
</span></span><span><span>
</span></span><span><span>    <span>public</span> <span>static</span> <span>void</span> <span>main</span>(String<span>[]</span> args) {
</span></span><span><span>        <span>// 18 + 1 + 55 = 74, so above 72 characters&#39; limit of BCrypt</span>
</span></span><span><span>        <span>var</span> userId <span>=</span> RandomStringUtils.<span>randomAlphanumeric</span>(18);
</span></span><span><span>        <span>var</span> username <span>=</span> RandomStringUtils.<span>randomAlphanumeric</span>(55);
</span></span><span><span>        <span>var</span> password <span>=</span> <span>&#34;super-duper-secure-password&#34;</span>;
</span></span><span><span>
</span></span><span><span>        <span>var</span> combinedString <span>=</span> String.<span>format</span>(<span>&#34;%s:%s:%s&#34;</span>, userId, username, password);
</span></span><span><span>
</span></span><span><span>        <span>var</span> combinedHash <span>=</span> BCrypt.<span>withDefaults</span>().<span>hashToString</span>(12, combinedString.<span>toCharArray</span>());
</span></span><span><span>
</span></span><span><span>        <span>// let&#39;s try to break it</span>
</span></span><span><span>        <span>var</span> wrongPassword <span>=</span> <span>&#34;wrong-password&#34;</span>;
</span></span><span><span>        <span>var</span> wrongCombinedString <span>=</span> String.<span>format</span>(<span>&#34;%s:%s:%s&#34;</span>, userId, username, wrongPassword);
</span></span><span><span>
</span></span><span><span>        <span>var</span> result <span>=</span> BCrypt.<span>verifyer</span>().<span>verify</span>(combinedHash.<span>toCharArray</span>(), wrongCombinedString);
</span></span><span><span>        <span>if</span> (result.<span>verified</span>) {
</span></span><span><span>            System.<span>out</span>.<span>println</span>(<span>&#34;Password is correct&#34;</span>);
</span></span><span><span>        } <span>else</span> {
</span></span><span><span>            System.<span>out</span>.<span>println</span>(<span>&#34;Password is incorrect&#34;</span>);
</span></span><span><span>        }
</span></span><span><span>    }
</span></span><span><span>}
</span></span></code></pre></div><p>Let’s run it:</p>
<div><pre tabindex="0"><code data-lang="plain"><span><span>Exception in thread &#34;main&#34; java.lang.IllegalArgumentException: password must not be longer than 72 bytes plus null terminator encoded in utf-8, was 102
</span></span><span><span>	at at.favre.lib.crypto.bcrypt.LongPasswordStrategy$StrictMaxPasswordLengthStrategy.innerDerive(LongPasswordStrategy.java:50)
</span></span><span><span>	at at.favre.lib.crypto.bcrypt.LongPasswordStrategy$BaseLongPasswordStrategy.derive(LongPasswordStrategy.java:34)
</span></span><span><span>	at at.favre.lib.crypto.bcrypt.BCrypt$Hasher.hashRaw(BCrypt.java:303)
</span></span><span><span>	at at.favre.lib.crypto.bcrypt.BCrypt$Hasher.hash(BCrypt.java:267)
</span></span><span><span>	at at.favre.lib.crypto.bcrypt.BCrypt$Hasher.hash(BCrypt.java:229)
</span></span><span><span>	at at.favre.lib.crypto.bcrypt.BCrypt$Hasher.hashToString(BCrypt.java:205)
</span></span><span><span>	at BcryptAtFavre.main(BcryptAtFavre.java:14)
</span></span></code></pre></div><p>Nice, good job, Patrick, you saved the day for Java!</p>
<p>After checking the source code, I found this piece:</p>
<div><pre tabindex="0"><code data-lang="java"><span><span><span>@Override</span>
</span></span><span><span><span>public</span> <span>byte</span><span>[]</span> <span>derive</span>(<span>byte</span><span>[]</span> rawPassword) {
</span></span><span><span>    <span>if</span> (rawPassword.<span>length</span> <span>&gt;=</span> maxLength) {
</span></span><span><span>        <span>return</span> innerDerive(rawPassword);
</span></span><span><span>    }
</span></span><span><span>    <span>return</span> rawPassword;
</span></span><span><span>}
</span></span></code></pre></div><p>and the strict strategy that threw the exception we’ve seen:</p>
<div><pre tabindex="0"><code data-lang="java"><span><span><span>final</span> <span>class</span> <span>StrictMaxPasswordLengthStrategy</span> <span>extends</span> BaseLongPasswordStrategy {
</span></span><span><span>    StrictMaxPasswordLengthStrategy(<span>int</span> maxLength) {
</span></span><span><span>        <span>super</span>(maxLength);
</span></span><span><span>    }
</span></span><span><span>
</span></span><span><span>    <span>@Override</span>
</span></span><span><span>    <span>public</span> <span>byte</span><span>[]</span> <span>innerDerive</span>(<span>byte</span><span>[]</span> rawPassword) {
</span></span><span><span>        <span>throw</span> <span>new</span> IllegalArgumentException(<span>&#34;password must not be longer than &#34;</span> <span>+</span> maxLength <span>+</span> <span>&#34; bytes plus null terminator encoded in utf-8, was &#34;</span> <span>+</span> rawPassword.<span>length</span>);
</span></span><span><span>    }
</span></span><span><span>}
</span></span></code></pre></div><p>We can see that this strict strategy is used as a part of the default configs:</p>
<div><pre tabindex="0"><code data-lang="java"><span><span><span>public</span> <span>static</span> Hasher <span>withDefaults</span>() {
</span></span><span><span>    <span>return</span> <span>new</span> Hasher(Version.<span>VERSION_2A</span>, <span>new</span> SecureRandom(), LongPasswordStrategies.<span>strict</span>(Version.<span>VERSION_2A</span>));
</span></span><span><span>}
</span></span></code></pre></div><p>Cool!</p>
<p>Let’s switch to JavaScript.</p>
<h2 id="javascript-and-bcrypt">JavaScript and Bcrypt</h2>
<p>Here I used the <a href="https://www.npmjs.com/package/bcryptjs" target="_blank">bcryptjs</a> which has over 2 million weekly downloads based on the NPM stats.</p>
<div><pre tabindex="0"><code data-lang="javascript"><span><span><span>const</span> <span>bcrypt</span> <span>=</span> <span>require</span>(<span>&#39;bcryptjs&#39;</span>)
</span></span><span><span>
</span></span><span><span><span>function</span> <span>randomString</span> (<span>length</span>) {
</span></span><span><span>  <span>const</span> <span>chars</span> <span>=</span> <span>&#39;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;</span>
</span></span><span><span>  <span>let</span> <span>result</span> <span>=</span> <span>&#39;&#39;</span>
</span></span><span><span>  <span>for</span> (<span>let</span> <span>i</span> <span>=</span> <span>length</span>; <span>i</span> <span>&gt;</span> <span>0</span>; <span>--</span><span>i</span>) {
</span></span><span><span>    <span>result</span> <span>+=</span> <span>chars</span>[Math.<span>floor</span>(Math.<span>random</span>() <span>*</span> <span>chars</span>.<span>length</span>)]
</span></span><span><span>  }
</span></span><span><span>  <span>return</span> <span>result</span>
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>function</span> <span>runTest</span> () {
</span></span><span><span>  <span>// 18 + 55 + 1 = 74, so above 72 characters&#39; limit of BCrypt
</span></span></span><span><span><span></span>  <span>const</span> <span>userId</span> <span>=</span> <span>randomString</span>(<span>18</span>)
</span></span><span><span>  <span>const</span> <span>username</span> <span>=</span> <span>randomString</span>(<span>55</span>)
</span></span><span><span>  <span>const</span> <span>password</span> <span>=</span> <span>&#39;super-duper-secure-password&#39;</span>
</span></span><span><span>
</span></span><span><span>  <span>const</span> <span>combinedString</span> <span>=</span> <span>`</span><span>${</span><span>userId</span><span>}</span><span>:</span><span>${</span><span>username</span><span>}</span><span>:</span><span>${</span><span>password</span><span>}</span><span>`</span>
</span></span><span><span>
</span></span><span><span>  <span>const</span> <span>combinedHash</span> <span>=</span> <span>bcrypt</span>.<span>hashSync</span>(<span>combinedString</span>)
</span></span><span><span>
</span></span><span><span>  <span>// let&#39;s try to break it
</span></span></span><span><span><span></span>  <span>const</span> <span>wrongPassword</span> <span>=</span> <span>&#39;wrong-password&#39;</span>
</span></span><span><span>  <span>const</span> <span>wrongCombinedString</span> <span>=</span> <span>`</span><span>${</span><span>userId</span><span>}</span><span>:</span><span>${</span><span>username</span><span>}</span><span>:</span><span>${</span><span>wrongPassword</span><span>}</span><span>`</span>
</span></span><span><span>
</span></span><span><span>  <span>if</span> (<span>bcrypt</span>.<span>compareSync</span>(<span>wrongCombinedString</span>, <span>combinedHash</span>)) {
</span></span><span><span>    <span>console</span>.<span>log</span>(<span>&#39;Password is correct&#39;</span>)
</span></span><span><span>  } <span>else</span> {
</span></span><span><span>    <span>console</span>.<span>log</span>(<span>&#39;Password is wrong&#39;</span>)
</span></span><span><span>  }
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>runTest</span>()
</span></span></code></pre></div><p>The output is:</p>
<p>Not great. The source code reveals that similar to Spring Security, the library validates the salt</p>
<div><pre tabindex="0"><code data-lang="javascript"><span><span><span>if</span> (<span>salt</span>.<span>charAt</span>(<span>0</span>) <span>!==</span> <span>&#39;$&#39;</span> <span>||</span> <span>salt</span>.<span>charAt</span>(<span>1</span>) <span>!==</span> <span>&#39;2&#39;</span>) {
</span></span><span><span>     <span>err</span> <span>=</span> Error(<span>&#34;Invalid salt version: &#34;</span><span>+</span><span>salt</span>.<span>substring</span>(<span>0</span>,<span>2</span>));
</span></span><span><span>     <span>if</span> (<span>callback</span>) {
</span></span><span><span>         <span>nextTick</span>(<span>callback</span>.<span>bind</span>(<span>this</span>, <span>err</span>));
</span></span><span><span>         <span>return</span>;
</span></span><span><span>     }
</span></span><span><span>     <span>else</span>
</span></span><span><span>         <span>throw</span> <span>err</span>;
</span></span><span><span>}
</span></span><span><span>...
</span></span></code></pre></div><p>but not the input length.</p>
<p>Let’s try if Python can do any better.</p>
<h2 id="python-and-bcrypt">Python and Bcrypt</h2>
<p>Using <a href="https://github.com/pyca/bcrypt" target="_blank">bcrypt</a> library with 1.3k starts and the latest release in November.</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>import</span> random
</span></span><span><span><span>import</span> string
</span></span><span><span>
</span></span><span><span><span>import</span> bcrypt
</span></span><span><span>
</span></span><span><span><span>def</span> <span>random_string</span>(length):
</span></span><span><span>    <span>return</span> <span>&#39;&#39;</span><span>.</span>join(random<span>.</span>choice(string<span>.</span>ascii_letters) <span>for</span> i <span>in</span> range(length))
</span></span><span><span>
</span></span><span><span><span>if</span> __name__ <span>==</span> <span>&#39;__main__&#39;</span>:
</span></span><span><span>    <span># 18 + 55 + 1 = 74, so above 72 characters&#39; limit of BCrypt</span>
</span></span><span><span>    user_id <span>=</span> random_string(<span>18</span>)
</span></span><span><span>    username <span>=</span> random_string(<span>55</span>)
</span></span><span><span>    password <span>=</span> <span>&#34;super-duper-secure-password&#34;</span>
</span></span><span><span>
</span></span><span><span>    combined_string <span>=</span> <span>&#34;</span><span>{0}</span><span>:</span><span>{1}</span><span>:</span><span>{2}</span><span>&#34;</span><span>.</span>format(user_id, username, password)
</span></span><span><span>
</span></span><span><span>    combined_hash <span>=</span> bcrypt<span>.</span>hashpw(combined_string<span>.</span>encode(<span>&#39;utf-8&#39;</span>), bcrypt<span>.</span>gensalt())
</span></span><span><span>
</span></span><span><span>    <span># let&#39;s try to break it</span>
</span></span><span><span>    wrong_password <span>=</span> <span>&#34;wrong-password&#34;</span>
</span></span><span><span>    wrong_combined_string <span>=</span> <span>&#34;</span><span>{0}</span><span>:</span><span>{1}</span><span>:</span><span>{2}</span><span>&#34;</span><span>.</span>format(user_id, username, wrong_password)
</span></span><span><span>
</span></span><span><span>    <span>if</span> bcrypt<span>.</span>checkpw(wrong_combined_string<span>.</span>encode(<span>&#39;utf-8&#39;</span>), combined_hash):
</span></span><span><span>        print(<span>&#34;Password is correct&#34;</span>)
</span></span><span><span>    <span>else</span>:
</span></span><span><span>        print(<span>&#34;Password is incorrect&#34;</span>)
</span></span></code></pre></div><p>The result is same as we observed for most of our test subjects:</p>
<p>All right, but what about some newer and more safety-oriented language - let’s try Rust.</p>
<h2 id="rust-and-bcrypt">Rust and Bcrypt</h2>
<p>Here I need to be honest: since I’m not a Rust expert at all, I used a help of a Claude AI to write this code. So, if you see any issues there, please, let me know in the comments section, so I can fix that.</p>
<p>As a library, I used <a href="https://github.com/Keats/rust-bcrypt" target="_blank">rust-bcrypt</a> based on my AI friend advice.</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>use</span> rand::RngCore;
</span></span><span><span><span>use</span> base64::{Engine <span>as</span> _, engine::general_purpose::<span>URL_SAFE</span>};
</span></span><span><span><span>use</span> std::error::Error;
</span></span><span><span>
</span></span><span><span><span>fn</span> <span>random_string</span>(length: <span>usize</span>) -&gt; String {
</span></span><span><span>    <span>let</span> <span>mut</span> bytes <span>=</span> vec![<span>0</span><span>u8</span>; length];
</span></span><span><span>    rand::thread_rng().fill_bytes(<span>&amp;</span><span>mut</span> bytes);
</span></span><span><span>    <span>URL_SAFE</span>.encode(<span>&amp;</span>bytes)[<span>..</span>length].to_string()
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>fn</span> <span>main</span>() -&gt; Result<span>&lt;</span>(), Box<span>&lt;</span><span>dyn</span> Error<span>&gt;&gt;</span> {
</span></span><span><span>    <span>// 18 + 55 + 1 = 74, so above 72 characters&#39; limit of BCrypt
</span></span></span><span><span><span></span>    <span>let</span> user_id <span>=</span> random_string(<span>18</span>);
</span></span><span><span>    <span>let</span> username <span>=</span> random_string(<span>55</span>);
</span></span><span><span>    <span>let</span> password <span>=</span> <span>&#34;super-duper-secure-password&#34;</span>;
</span></span><span><span>
</span></span><span><span>    <span>let</span> combined_string <span>=</span> format!(<span>&#34;</span><span>{}</span><span>:</span><span>{}</span><span>:</span><span>{}</span><span>&#34;</span>, user_id, username, password);
</span></span><span><span>    <span>let</span> combined_hash <span>=</span> bcrypt::hash(combined_string.as_bytes(), bcrypt::<span>DEFAULT_COST</span>)<span>?</span>;
</span></span><span><span>
</span></span><span><span>    <span>// let&#39;s try to break it
</span></span></span><span><span><span></span>    <span>let</span> wrong_password <span>=</span> <span>&#34;wrong-password&#34;</span>;
</span></span><span><span>    <span>let</span> wrong_combined_string <span>=</span> format!(<span>&#34;</span><span>{}</span><span>:</span><span>{}</span><span>:</span><span>{}</span><span>&#34;</span>, user_id, username, wrong_password);
</span></span><span><span>
</span></span><span><span>    <span>match</span> bcrypt::verify(wrong_combined_string.as_bytes(), <span>&amp;</span>combined_hash) {
</span></span><span><span>        Ok(<span>true</span>) <span>=&gt;</span> println!(<span>&#34;Password is correct&#34;</span>),
</span></span><span><span>        Ok(<span>false</span>) <span>=&gt;</span> println!(<span>&#34;Password is incorrect&#34;</span>),
</span></span><span><span>        Err(e) <span>=&gt;</span> println!(<span>&#34;</span><span>{}</span><span>&#34;</span>, e),
</span></span><span><span>    }
</span></span><span><span>
</span></span><span><span>    Ok(())
</span></span><span><span>}
</span></span></code></pre></div><p>The output is:</p>
<p>I can see the validation of the cost:</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>if</span> <span>!</span>(<span>MIN_COST</span><span>..=</span><span>MAX_COST</span>).contains(<span>&amp;</span>cost) {
</span></span><span><span>    <span>return</span> Err(BcryptError::CostNotAllowed(cost));
</span></span><span><span>}
</span></span></code></pre></div><p>but not of the input. And here is the place where the explicit truncation of 72 chars happens (the comment is from the library source code):</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>// We only consider the first 72 chars; truncate if necessary.
</span></span></span><span><span><span>// `bcrypt` below will panic if len &gt; 72
</span></span></span><span><span><span></span><span>let</span> truncated <span>=</span> <span>if</span> vec.len() <span>&gt;</span> <span>72</span> {
</span></span><span><span>    <span>if</span> err_on_truncation {
</span></span><span><span>        <span>return</span> Err(BcryptError::Truncation(vec.len()));
</span></span><span><span>    }
</span></span><span><span>    <span>&amp;</span>vec[<span>..</span><span>72</span>]
</span></span><span><span>} <span>else</span> {
</span></span><span><span>    <span>&amp;</span>vec
</span></span><span><span>};
</span></span><span><span>
</span></span><span><span><span>let</span> output <span>=</span> bcrypt::bcrypt(cost, salt, truncated);
</span></span></code></pre></div><h2 id="why">Why?</h2>
<p>That was my first question after seeing that the majority of the tools follow the pattern that leads to the vulnerability. <a href="https://en.wikipedia.org/wiki/Bcrypt" target="_blank">Wikipedia article about Bcrypt</a> gave a hint:</p>
<blockquote>
<p>Many implementations of bcrypt truncate the password to the first 72 bytes, following the OpenBSD implementation</p>
</blockquote>
<p>Interesting! Let’s check the OpenBSD implementation of this algorithm, and <a href="https://github.com/openbsd/src/blob/master/lib/libc/crypt/bcrypt.c" target="_blank">here is the link</a> to it. The first point of interest lies here:</p>
<div><pre tabindex="0"><code data-lang="c"><span><span><span>/* strlen() returns a size_t, but the function calls
</span></span></span><span><span><span> * below result in implicit casts to a narrower integer
</span></span></span><span><span><span> * type, so cap key_len at the actual maximum supported
</span></span></span><span><span><span> * length here to avoid integer wraparound */</span>
</span></span><span><span>key_len <span>=</span> <span>strlen</span>(key);
</span></span><span><span><span>if</span> (key_len <span>&gt;</span> <span>72</span>)
</span></span><span><span>	 key_len <span>=</span> <span>72</span>;
</span></span><span><span>key_len<span>++</span>;
</span></span></code></pre></div><p>And from that moment on, <code>key_len</code> is used as a limit to iterate over the input string within, for example:</p>
<div><pre tabindex="0"><code data-lang="c"><span><span><span>u_int32_t</span>
</span></span><span><span><span>Blowfish_stream2word</span>(<span>const</span> <span>u_int8_t</span> <span>*</span>data, <span>u_int16_t</span> databytes,
</span></span><span><span>    <span>u_int16_t</span> <span>*</span>current)
</span></span><span><span>{
</span></span><span><span>	<span>u_int8_t</span> i;
</span></span><span><span>	<span>u_int16_t</span> j;
</span></span><span><span>	<span>u_int32_t</span> temp;
</span></span><span><span>
</span></span><span><span>	temp <span>=</span> <span>0x00000000</span>;
</span></span><span><span>	j <span>=</span> <span>*</span>current;
</span></span><span><span>
</span></span><span><span>	<span>for</span> (i <span>=</span> <span>0</span>; i <span>&lt;</span> <span>4</span>; i<span>++</span>, j<span>++</span>) {
</span></span><span><span>		<span>if</span> (j <span>&gt;=</span> databytes)
</span></span><span><span>			j <span>=</span> <span>0</span>;
</span></span><span><span>		temp <span>=</span> (temp <span>&lt;&lt;</span> <span>8</span>) <span>|</span> data[j];
</span></span><span><span>	}
</span></span><span><span>
</span></span><span><span>	<span>*</span>current <span>=</span> j;
</span></span><span><span>	<span>return</span> temp;
</span></span><span><span>}
</span></span></code></pre></div><p>Where <code>key_length</code> is passed as a <code>databytes</code> parameter. So this piece of code:</p>
<div><pre tabindex="0"><code data-lang="c"><span><span><span>if</span> (j <span>&gt;=</span> databytes)
</span></span><span><span>	j <span>=</span> <span>0</span>;
</span></span></code></pre></div><p>will make sure that no chars over the limit (72) will end up being processed.</p>
<p>Git blame shows that the <code>if (key_len &gt; 72)</code> line is 11 years old</p>
<p><img src="https://n0rdy.foo/images/screenshots/20250122-0001.webp" alt="image"/></p>
<p>while the <code>if (j &gt;= databytes) j = 0;</code> is 28 years old (what were you busy with in 1997, ah?)</p>
<p><img src="https://n0rdy.foo/images/screenshots/20250122-0002.webp" alt="image"/></p>
<p>So, it’s been a while since the API has been reiterated.</p>
<h2 id="some-thoughts-on-that">Some thoughts on that</h2>
<h3 id="disclaimer">Disclaimer</h3>
<p>Let me start with a short disclaimer: I have a huge respect for people who spend their free time and mental capacity on maintaining open-source projects. That’s a large amount of work, that is not paid, and, unfortunately, quite often not appreciated by the users of the tools. That’s why they have all the legal and ethical rights to build the project the way they see them. My opinions below are not targeted towards anyone in particular.</p>
<p>My initial goal was to create issues for each of the mentioned library, but I noticed that this behavior has been already reported to each of them:</p>
<ul>
<li><a href="https://github.com/spring-projects/spring-security/issues/15725" target="_blank">https://github.com/spring-projects/spring-security/issues/15725</a></li>
<li><a href="https://github.com/dcodeIO/bcrypt.js/issues/102" target="_blank">https://github.com/dcodeIO/bcrypt.js/issues/102</a></li>
<li><a href="https://github.com/pyca/bcrypt/issues/691" target="_blank">https://github.com/pyca/bcrypt/issues/691</a></li>
<li><a href="https://github.com/Keats/rust-bcrypt/issues/87" target="_blank">https://github.com/Keats/rust-bcrypt/issues/87</a></li>
</ul>
<p>Check the discussions and their outcomes by following those links.</p>
<h3 id="thoughts-and-lessons">Thoughts and lessons</h3>
<p>As a guy who spent a few years of my career on building tools and solutions to be used by other software engineers, I understand the frustration: you invested your time and effort into writing a clear documentation and guides, but a certain number of your users don’t bother checking it at all, and just use the tool the way they think it should be used. However, that’s the reality that I had to accept and started thinking about how can I make my tools handle those use cases. Here are a few principles I came up with in that process.</p>
<h4 id="dont-let-the-people-use-your-api-incorrectly">Don’t let the people use your API incorrectly</h4>
<p>In my opinion, from the API perspective, the approach when the tool silently cuts the part of the input and processes the remaining one only, it is an extremely poor design choice. What makes things worse is the fact that Bcrypt is used in the domain of security and sensitive data, and, as we can see, most of the tools mentioned above, use <code>password</code> as the name of the input parameter of the hashing method. <strong>The good design should explicitly reject the invalid input</strong> with the error / exception / any other mechanism the platform uses. So, basically, exactly what Go and Patrick’s Java library did. This way, incidents like Okta one would be impossible by design (btw, I’m not shifting the blame away from Okta, considering the domain they operate in).</p>
<p>It is ok, though, to offer the non-default unsafe option, that will let the users pass longer input that will be truncated if the user explicitly asks for that. A prefix/suffix like <code>unsafe</code>, <code>truncated</code>, etc. can be a good addition to the names of the method that expose these options.</p>
<h4 id="be-predictable">Be predictable</h4>
<p>If we take a step back from the Bcrypt case, imagine other examples, if such a pattern becomes common in the industry:</p>
<ul>
<li>We created a new user account on HBO to watch a new season of Rick and Morty, and there is a warning that the max size of the password should not exceed 18 chars. However, the password generator of your password manager tool uses 25 chars as a default length of the produced password. So, the password manager inserts that password while creating an account, but the server cuts the last 7 chars, hashes the rest, and saves the hash to the DB. How easy would it be for us to be able to log in to HBO next time and watch a new episode?</li>
<li>The tech lead of the new project configured a linter tool, and set the max line length as 100 chars. While performing a check, linter removes the chars above the defined limit, and informs that the check has passed. How useful would it be?</li>
</ul>
<p>A good API design should remember that when it comes to tech, nobody likes surprises.</p>
<h4 id="no-ego">No ego</h4>
<p>While following a few online discussions about the Bcrypt Okta incident, I noticed something else: while the majority of comments agreed that we should design APIs like these better, there were a few folks that took a very defensive stance and exposed their ego: “Read a paper before using anything!”, “APIs are only correcting the input after the stupid users!”, etc. Based on my experience, ego is a big enemy of engineering. And I wouldn’t be surprised if you have a story or two in that regard as well. So, yeah, let’s not bring our egos to our APIs.</p>
<h4 id="be-helpful">Be helpful</h4>
<p>Don’t get me wrong, I do understand the gist that the users should have some basic knowledge before using any tool. But let’s get back to the reality: how many different tools, programming languages, databases, protocols, frameworks, libraries, algorithms, data structures, clouds, AI models, etc. does a software engineer use per week these days? I tried to count for my use case, but stopped after the number had reached 30. Is it possible to know all of them deep? To know all the edge cases and limits? For some of them and to some degree is a reasonable ask, as well as having an expertise in 1 or 2, but definitely not all. The hard truth is that on average, the industry today requires the wide spectrum of knowledge over the deep one (check any job opening to verify that claim). Therefore, while designing the tools, why not to help our fellow colleagues? For example, if our tool accepts only positive numbers, let’s add <code>if num &lt; 1 -&gt; return error</code>  to our solution, and make the life simpler for somebody out there.</p>
<p>Especially, if the tool might be used in the security-sensitive context, where humans are usually the weak point in the thread modelling. The good API can help there.</p>
<h4 id="be-brave">Be brave</h4>
<p>It’s not so often that the API we design is something completely new to the world. Most likely, there are other solutions like ours out there. And the chances are that they’ve been already doing certain things the particular way. However, that doesn’t mean that we need to follow the same path. Kudos to the Go team and Patrick’s Java library for being brave to do things the different way as the industry does in the Bcrypt example. Let’s learn from them.</p>
<h4 id="reiterate">Reiterate</h4>
<p>Regardless of the original design choices and intentions, it’s never too late to reiterate on some of them if we see a need or have discovered new information. That’s, actually, a place where a lot of us fail due to different reasons, with some of them listed above.</p>
<h2 id="instead-of-a-conclusion">Instead of a conclusion</h2>
<p>The Okta incident exposed large security issues out there. Our test showed, even 3 months after the incident, the industry is still vulnerable to the same outcome, so the chances are that more to come. However, we, as software engineers, can learn from that, and apply these lessons while designing APIs to make them predictable and easier to use.</p>
<p>I hope that was useful, and triggered some thoughts. Thanks a lot for reading my post, and see you in the following ones, there are plenty of topics to discuss. Have fun! =)</p>

  
    <hr/>

  
  <hr/>


  
    

  
</div>
            </div></div>
  </body>
</html>
