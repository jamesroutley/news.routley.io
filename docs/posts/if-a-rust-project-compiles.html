<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://samuelselleck.com/blog/if-rust-compiles-it-works/">Original</a>
    <h1>If a Rust Project Compiles</h1>
    
    <div id="readability-page-1" class="page"><div><p>Over the last week, I managed to finish Protohackers <a href="https://protohackers.com/problem/6">part 6</a> in Rust.</p><p>For almost the entire project timeline, I did what in all other low-level languages would be an incredibly bad idea. Instead of building a small MVP, getting it up and running and then continually adding features, I went all the way from an empty <code>main()</code> to a finished application that <strong>almost</strong> worked flawlessly on the first run.</p><p>It’s crazy to me that if your Rust project compiles, you are likely more than 90% done.</p><p>Below I will go over the few errors that did present themselves and my take on why these were not preventable by the language design itself, as well as my thoughts on why it worked out so well. For a TLDR, see <a href="https://samuelselleck.com/blog/if-rust-compiles-it-works/#conclusion">Conclusion</a>.</p><h2 id="specification-errors">Specification Errors</h2><p>The following are all errors I encountered that was because of me not following the specifications, I forgot to:</p><ul><li>Interpret a heartbeat-request interval of 0 as “I don’t want a heartbeat” (edge case).</li><li>Multiply speed by 100 in outgoing message (weird specification).</li><li>Round speed to nearest integer.</li><li>Let new dispatchers take over the job of a disconnected dispatcher (by far the largest miss).</li></ul><p>Rust can’t (so far) tell you when you’ve simply interpreted something differently or just missed a point on what is described in the specifications. However, Rusts strict rules at multiple times made me stop and think:</p><blockquote><p>oh yea, what to do in this case? I should probably check the specification.</p></blockquote><p>I think this reduced the number of specification errors considerably.</p><p>Besides that I found it an <strong>incredibly</strong> easy process to translate the specifications of the problem to actual rust code because of Rusts type system. Once the basic types are in place, all code that uses these types can be written in a way that makes the code impossible to compile without conforming to these specifications. These are all inbound and outbound messages from the server, neatly wrapped up in two enums:</p><pre data-lang="rust"><code data-lang="rust"><span>pub </span><span>enum </span><span>ClientMessage </span><span>{
</span><span>    PlateDetected </span><span>{
</span><span>        plate: Plate,
</span><span>        time: TimeStamp,
</span><span>    </span><span>}</span><span>,
</span><span>    HeartbeatRequest(Duration),
</span><span>    IAmCamera </span><span>{
</span><span>        road: RoadID,
</span><span>        position: Mile,
</span><span>        speed_limit: Speed,
</span><span>    </span><span>}</span><span>,
</span><span>    IAmDispatcher </span><span>{
</span><span>        roads: </span><span>Vec</span><span>&lt;RoadID&gt;,
</span><span>    </span><span>}</span><span>,
</span><span>}
</span><span>
</span><span>pub </span><span>enum </span><span>ServerMessage </span><span>{
</span><span>    Error(</span><span>String</span><span>),
</span><span>    Ticket </span><span>{
</span><span>        plate: Plate,
</span><span>        road: RoadID,
</span><span>        p1: (Mile, TimeStamp),
</span><span>        p2: (Mile, TimeStamp),
</span><span>        speed: Speed,
</span><span>    </span><span>}</span><span>,
</span><span>    HeartBeat,
</span><span>}
</span><span>
</span></code></pre><p>All match statements on these types need to be exhaustive, by default giving a very high degree of edge case coverage.</p><h2 id="runtime-errors">Runtime Errors</h2><p>I encountered <strong>one</strong> runtime error, in the part of the code base that was the most hacky (5 block indents are never a good idea). This error did clearly print out an error message in the console, but it was so flooded by others that I didn’t spot it for a while (in a async runtime all threads are not terminated if one panics).</p><p>If you <strong>have</strong> to see my crappy code for this part, here it is. Can you spot the bug?</p><pre data-lang="rust"><code data-lang="rust"><span>fn </span><span>should_be_ticketed</span><span>(
</span><span>        </span><span>entries</span><span>: </span><span>&amp;mut </span><span>Vec</span><span>&lt;(Mile, TimeStamp)&gt;,
</span><span>        </span><span>speed_limit</span><span>: Speed,
</span><span>        </span><span>ticket_days</span><span>: </span><span>&amp;mut </span><span>HashSet&lt;</span><span>u32</span><span>&gt;,
</span><span>    ) </span><span>-&gt; </span><span>Option</span><span>&lt;((Mile, TimeStamp), (Mile, TimeStamp), Speed)&gt; </span><span>{
</span><span>        </span><span>let</span><span> n </span><span>=</span><span> entries</span><span>.</span><span>len</span><span>();
</span><span>        </span><span>for</span><span> i </span><span>in </span><span>0</span><span>..</span><span>n </span><span>{
</span><span>            </span><span>let </span><span>(m1, t1) </span><span>=</span><span> entries[i];
</span><span>            </span><span>for</span><span> j </span><span>in </span><span>(i </span><span>+ </span><span>1</span><span>)</span><span>..</span><span>n </span><span>{
</span><span>                </span><span>let </span><span>(m2, t2) </span><span>=</span><span> entries[j];
</span><span>                </span><span>let</span><span> speed </span><span>= </span><span>3600.0 </span><span>* </span><span>((m1 </span><span>as </span><span>f64 </span><span>-</span><span> m2 </span><span>as </span><span>f64</span><span>) </span><span>/ </span><span>(t1 </span><span>as </span><span>f64 </span><span>-</span><span> t2 </span><span>as </span><span>f64</span><span>))</span><span>.</span><span>abs</span><span>();
</span><span>                </span><span>if</span><span> speed </span><span>&gt;</span><span> speed_limit </span><span>as </span><span>f64 </span><span>{
</span><span>                    entries</span><span>.</span><span>swap_remove</span><span>(j);
</span><span>                    entries</span><span>.</span><span>swap_remove</span><span>(i);
</span><span>                    </span><span>let</span><span> d1 </span><span>=</span><span> t1 </span><span>/ </span><span>86400</span><span>;
</span><span>                    </span><span>let</span><span> d2 </span><span>=</span><span> t2 </span><span>/ </span><span>86400</span><span>;
</span><span>                    </span><span>let</span><span> has_been_ticketed_for_day </span><span>=
</span><span>                        ticket_days</span><span>.</span><span>contains</span><span>(</span><span>&amp;</span><span>d1) </span><span>||</span><span> ticket_days</span><span>.</span><span>contains</span><span>(</span><span>&amp;</span><span>d2);
</span><span>                    </span><span>if !</span><span>has_been_ticketed_for_day </span><span>{
</span><span>                        ticket_days</span><span>.</span><span>insert</span><span>(d1);
</span><span>                        ticket_days</span><span>.</span><span>insert</span><span>(d2);
</span><span>                        </span><span>return </span><span>Some</span><span>(((m1, t1), (m2, t2), (</span><span>100.0 </span><span>*</span><span> speed)</span><span>.</span><span>round</span><span>() </span><span>as</span><span> Speed));
</span><span>                    </span><span>}
</span><span>                </span><span>}
</span><span>            </span><span>}
</span><span>        </span><span>}
</span><span>        </span><span>None
</span><span>    </span><span>}
</span></code></pre><p>I accidentally removed items from within the loops even in the case I didn’t return! That was it. no other runtime errors. None.</p><p>I would classify this as a <strong>logical</strong> error. The program did panic at runtime. But even if it wouldn’t have, I would have had to find why it was not behaving correctly and remedy it.</p><h2 id="honorable-mentions">Honorable Mentions</h2><p>Let’s look at one of the more error prone cases that actually didn’t go wrong, but felt like they could have: interpreting messages from the incoming TCP byte stream. One type of message that could be sent form the client was an <code>IAmCamera</code> message, telling the server that the newly connected client will be sending position/registration plate information about passing cars. Once all types of possible client messages are encoded as enum variants, decoding this variant from it’s binary representation looked like this:</p><pre data-lang="rust"><code data-lang="rust"><span>match &lt;</span><span>message identifier byte</span><span>&gt; </span><span>{
</span><span>    </span><span>...
</span><span>    </span><span>0x80 </span><span>=&gt; </span><span>{
</span><span>        </span><span>let</span><span> expected_len </span><span>= </span><span>1 
</span><span>         </span><span>+ </span><span>size_of</span><span>::</span><span>&lt;RoadID&gt;()
</span><span>         </span><span>+ </span><span>size_of</span><span>::</span><span>&lt;Mile&gt;()
</span><span>         </span><span>+ </span><span>size_of</span><span>::</span><span>&lt;Speed&gt;();
</span><span>
</span><span>        </span><span>if</span><span> src</span><span>.</span><span>len</span><span>() </span><span>&lt;</span><span> expected_len </span><span>{
</span><span>            src</span><span>.</span><span>reserve</span><span>(expected_len);
</span><span>            </span><span>return </span><span>Ok</span><span>(</span><span>None</span><span>)
</span><span>        </span><span>}</span><span>;
</span><span>        </span><span>//Everything is good, we can safely consume the message:
</span><span>        src</span><span>.</span><span>advance</span><span>(</span><span>1</span><span>);
</span><span>        </span><span>ClientMessage</span><span>::</span><span>IAmCamera </span><span>{
</span><span>            road: src</span><span>.</span><span>get_u16</span><span>(),
</span><span>            position: src</span><span>.</span><span>get_u16</span><span>(),
</span><span>            speed_limit: src</span><span>.</span><span>get_u16</span><span>(),
</span><span>        </span><span>}
</span><span>    </span><span>}</span><span>,
</span><span>    </span><span>...
</span><span>}
</span><span>
</span></code></pre><p>There are some possible pitfalls: Accidentally omitting <code>src.advance(1)</code> to skip the message identifier byte, forgetting to check message length or consuming parts of the message before we are sure we can consume it in its entirety. However one of the most important things is enforced: If the message specification enum ever is changed, this would not compile and yell at us. One thing i felt I was missing here is a way to check the length of an enum variant. (ie. would have been nice to be able to do: <code>size_of::&lt;ClientMessage::IAmCamera&gt;()</code> or similar). The general problem that made this harder to describe in a less error prone way was that some messages length depended on it’s contents. One possible way of doing better would be to implement a binary <code>serde</code> deserializer for the enum and contained length delimited strings, oh well another time!</p><h2 id="conclusion">Conclusion</h2><p>After compiling the program for the first time after over 3 days of working on the project, I had a handful of specification gaps and <strong>one</strong> runtime bug. The level of abstraction and robustness that Rust provides without compromising on low-level control is simply remarkable. If your asynchronous rust project compiles. You are with a high likelihood over 90% done. Even if you didn’t run it at any prior time.</p></div></div>
  </body>
</html>
