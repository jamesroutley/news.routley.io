<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://sanket.tech/posts/invert_binary_tree_assembly/">Original</a>
    <h1>Inverting a binary tree using x64 assembly</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
        <p>While browsing twitter, I came across this tweet:</p>
<figure><a href="https://twitter.com/smsunarto/status/1591566715011624961"><img src="https://sanket.tech/img/tweet_invert_merkle.jpg" alt="Tweet asking you to invert merkle tree"/><figcaption>
            <p>Challenge accepted</p>
        </figcaption>
</a></figure>
<h2 id="some-ground-rules">Some ground rules</h2>
<p>The task is to invert a binary tree. A binary tree node is defined as follows:</p>
<div><pre tabindex="0"><code data-lang="c"><span><span><span>struct</span> TreeNode{ 
</span></span><span><span>    <span>int</span> val;
</span></span><span><span>    <span>struct</span> TreeNode <span>*</span> left;
</span></span><span><span>    <span>struct</span> Treenode <span>*</span> right;
</span></span><span><span>};
</span></span></code></pre></div><p>This definition is from <a href="https://leetcode.com/problems/invert-binary-tree">Leetcode 226</a>. After we are done, we can submit our code there to see if it works.</p>
<p>I will be using x64 assembly with the AT&amp;T syntax as it is <em>objectively</em> superior than the Intel syntax.</p>
<p>Technically the tweet asks to invert a merkle tree, however you can easily extend the final code to recompute the hash at each node after its two subtrees are inverted.</p>
<h2 id="pseudocode">Pseudocode</h2>
<p>The function we need to implement is as follows:</p>
<div><pre tabindex="0"><code data-lang="c"><span><span><span>struct</span> TreeNode <span>*</span> <span>invertTree</span>(<span>struct</span> TreeNode <span>*</span> root);
</span></span></code></pre></div><p>We will begin by writing some pseudocode</p>
<div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span> 1
</span><span> 2
</span><span> 3
</span><span> 4
</span><span> 5
</span><span> 6
</span><span> 7
</span><span> 8
</span><span> 9
</span><span>10
</span><span>11
</span><span>12
</span><span>13
</span><span>14
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="javascript"><span><span><span>function</span> <span>invert</span>(<span>root</span>) {
</span></span><span><span>    <span>let</span> <span>local_root</span> <span>=</span> <span>root</span>;
</span></span><span><span>    <span>if</span> <span>local_root</span> <span>is</span> <span>null</span> {
</span></span><span><span>        <span>return</span> <span>null</span>
</span></span><span><span>    }
</span></span><span><span>
</span></span><span><span>    <span>let</span> <span>local_left</span> <span>=</span> <span>local_root</span>.<span>left</span>;
</span></span><span><span>    <span>let</span> <span>local_right</span> <span>=</span> <span>local_root</span>.<span>right</span>;
</span></span><span><span>
</span></span><span><span>    <span>root</span>.<span>right</span> <span>=</span> <span>invert</span>(<span>local_left</span>);
</span></span><span><span>    <span>root</span>.<span>left</span> <span>=</span> <span>invert</span>(<span>local_right</span>);
</span></span><span><span>
</span></span><span><span>    <span>return</span> <span>local_root</span>;
</span></span><span><span>}
</span></span></code></pre></td></tr></tbody></table>
</div>
</div><p>This pseudocode is intentionally verbose so we can easily track all local variables we have to create and store on the stack.
We will be translating this pseudocode as it is to assembly.</p>
<h2 id="basic-setup">Basic setup</h2>
<div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span>1
</span><span>2
</span><span>3
</span><span>4
</span><span>5
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="gas"><span><span><span>.globl</span> <span>invert_tree</span>
</span></span><span><span><span>.type</span> <span>invert_tree</span>, <span>@function</span>
</span></span><span><span><span>.section</span> <span>.text</span>
</span></span><span><span>invert_tree:
</span></span><span><span>    <span># Our function goes here
</span></span></span></code></pre></td></tr></tbody></table>
</div>
</div><p>Lines 1 and 2 tell the assembler that we are defining an <code>invert_tree</code> symbol of type function. The <code>globl</code>
modifier allows our function to be called from other source files.
The <code>.text</code> section is the <a href="https://www.wikiwand.com/en/Code_segment">Code segment</a> where we will be writing our function.</p>
<h3 id="function-prologue-and-epilogue">Function prologue and epilogue</h3>
<p>To define this function in assembly, we first need to understand the x86-64 calling convention.
This is documented in the System V ABI available <a href="https://gitlab.com/x86-psABIs/x86-64-ABI">here</a>.</p>
<div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span>1
</span><span>2
</span><span>3
</span><span>4
</span><span>5
</span><span>6
</span><span>7
</span><span>8
</span><span>9
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="gas"><span><span>invert_tree:
</span></span><span><span>    <span># Function prologue
</span></span></span><span><span><span></span>    <span>push</span> %rbp
</span></span><span><span>    <span>mov</span> %rsp, %rbp
</span></span><span><span>    <span>sub</span> <span>$32</span>, %rsp
</span></span><span><span>
</span></span><span><span>    <span># Function epilogue
</span></span></span><span><span><span></span>    <span>leave</span>
</span></span><span><span>    <span>ret</span>
</span></span></code></pre></td></tr></tbody></table>
</div>
</div><p>First, we push the current value of <code>%rbp</code> on the stack and copy <code>%rsp</code> to <code>%rbp</code>. We then subtract <code>32 bytes</code> from the stack pointer to make space to store our local variables.</p>
<p>Doing this sets up a stack frame for this function, with <code>%rbp</code> as the “base”. We can now use offsets from <code>%rbp</code> to access data on the stack.</p>
<p>There is an <code>enter</code> instruction which sets up the stack frame for us, but it is very slow. On modern processors <code>enter</code> decodes to some 10 to 20 µops, while the three instruction sequence is about 4 to 6, depending on the architecture. <a href="https://stackoverflow.com/questions/5959890/enter-vs-push-ebp-mov-ebp-esp-sub-esp-imm-and-leave-vs-mov-esp-ebp">Source</a></p>
<p>The <code>leave</code> instruction does exactly the opposite of lines <code>3</code> and <code>4</code>. It restores <code>%rsp</code> and pops the value from stack into <code>%rbp</code>.</p>
<h3 id="stack-alignment">Stack alignment</h3>
<p>In our pseudocode, there are 3 local variables <code>local_root</code>, <code>local_left</code> and <code>local_right</code>. Each of these is a pointer type, thus they require a total of 24 bytes to be stored on the stack (A pointer type has size 8 bytes in x64).</p>
<p>However, we instead make space for <code>32 bytes</code> to ensure our stack is “aligned” correctly. From the System V ABI document:</p>
<p><em>“The stack needs to be 16 byte aligned immediately before any call instruction is executed.”</em></p>
<h2 id="base-case">Base case</h2>
<p>The function accepts a single pointer as input, thus according to the calling convention, we will be receiving it as a 64 bit value in the register <code>%rdi</code>.</p>
<p>To return a pointer from our function, we have to store it in the register <code>%rax</code> before we <code>ret</code> from our function.</p>
<p>We check if the root is <code>NULL</code>, and if it is, we return <code>NULL</code>.</p>
<div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span> 1
</span><span> 2
</span><span> 3
</span><span> 4
</span><span> 5
</span><span> 6
</span><span> 7
</span><span> 8
</span><span> 9
</span><span>10
</span><span>11
</span><span>12
</span><span>13
</span><span>14
</span><span>15
</span><span>16
</span><span>17
</span><span>18
</span><span>19
</span><span>20
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="gas"><span><span>invert_tree:
</span></span><span><span>    <span># Function prologue
</span></span></span><span><span><span></span>    <span>push</span> %rbp
</span></span><span><span>    <span>mov</span> %rsp, %rbp
</span></span><span><span>    <span>sub</span> <span>$32</span>, %rsp
</span></span><span><span>
</span></span><span><span>    <span># --------- Base case ---------
</span></span></span><span><span><span></span>    <span># %rdi contains the input parameter (8 byte pointer to the root)
</span></span></span><span><span><span></span>    <span>cmp</span> <span>$0</span>, %rdi
</span></span><span><span>    <span># Root not NULL, continue with execution
</span></span></span><span><span><span></span>    <span>jne</span> <span>continue</span>
</span></span><span><span>    <span># Root is NULL, store NULL in %rax and return
</span></span></span><span><span><span></span>    <span>xor</span> %rax, %rax
</span></span><span><span>    <span>jmp</span> <span>done</span>
</span></span><span><span>continue:
</span></span><span><span>
</span></span><span><span>done:
</span></span><span><span>    <span># Function epilogue
</span></span></span><span><span><span></span>    <span>leave</span>
</span></span><span><span>    <span>ret</span>
</span></span></code></pre></td></tr></tbody></table>
</div>
</div><p>In x64, <code>NULL</code> is the value <code>0</code>. We compare <code>%rdi</code> with <code>0</code> and if it succeeds, we put <code>0</code> in <code>%rax</code> and return from our function.
To do this, using <code>xor</code> is faster than <code>mov</code> or <code>sub</code>.</p>
<h2 id="struct-alignment">Struct alignment</h2>
<p>On most ISA’s each data type in a struct has an alignment requirement. What this means is that the address of a type must start on an address which is a multiple of their size. (There are some exceptions, but this is the general rule)</p>
<p>So <code>int</code>’s must start on an address which is a multiple of 4, and pointers must start on an address which is a multiple of 8.</p>
<p>Given this, our original struct is laid out in memory something like so:</p>
<div><pre tabindex="0"><code data-lang="c"><span><span><span>struct</span> TreeNode{ 
</span></span><span><span>    <span>int</span> val;
</span></span><span><span>    <span>char</span> pad[<span>4</span>];  <span>// 4 extra bytes to align the next pointer
</span></span></span><span><span><span></span>    <span>struct</span> TreeNode <span>*</span> left;
</span></span><span><span>    <span>struct</span> Treenode <span>*</span> right;
</span></span><span><span>};
</span></span></code></pre></div><p>This wastes 4 bytes for every struct in memory. We can save this space by declaring the pointers first, however we will continue to use the original struct declaration as we want to submit this to Leetcode.</p>
<h3 id="storing-local-variables-on-the-stack">Storing local variables on the stack</h3>
<p>Once we know the address offsets in our struct, we can then store them on the stack. We will store local_root, left and right pointers on the stack. Each of them has a size of 8 bytes. We store them as follows</p>
<center>
<table>
<thead>
<tr>
<th>Variable</th>
<th>location start</th>
<th>location end</th>
</tr>
</thead>
<tbody>
<tr>
<td>local_root</td>
<td>%rbp - 8</td>
<td>%rbp</td>
</tr>
<tr>
<td>local_left</td>
<td>%rbp - 16</td>
<td>%rbp - 8</td>
</tr>
<tr>
<td>local_right</td>
<td>%rbp - 24</td>
<td>%rbp - 16</td>
</tr>
</tbody>
</table>
</center>
<p>Also, to make referring to them easier, we can define these offsets as constants using the <code>equ</code> assembler directive.</p>
<div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span>1
</span><span>2
</span><span>3
</span><span>4
</span><span>5
</span><span>6
</span><span>7
</span><span>8
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="gas"><span><span><span># ...
</span></span></span><span><span><span></span><span>.section</span> <span>.text</span>
</span></span><span><span><span>.equ</span> <span>local_root</span>, -<span>8</span>
</span></span><span><span><span>.equ</span> <span>local_left</span>, -<span>16</span>
</span></span><span><span><span>.equ</span> <span>local_right</span>, -<span>24</span>
</span></span><span><span>
</span></span><span><span>invert_tree:
</span></span><span><span><span># ... function here
</span></span></span></code></pre></td></tr></tbody></table>
</div>
</div><p>We can then use them in our code.</p>
<div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span> 1
</span><span> 2
</span><span> 3
</span><span> 4
</span><span> 5
</span><span> 6
</span><span> 7
</span><span> 8
</span><span> 9
</span><span>10
</span><span>11
</span><span>12
</span><span>13
</span><span>14
</span><span>15
</span><span>16
</span><span>17
</span><span>18
</span><span>19
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="gas"><span><span>invert_tree:
</span></span><span><span>    <span># ...
</span></span></span><span><span><span></span>continue:
</span></span><span><span>    <span># --------- Save local variables to stack ---------
</span></span></span><span><span><span></span>    <span># Save the root parameter as local_root on stack
</span></span></span><span><span><span></span>    <span>movq</span> %rdi, <span>local_root</span>(%rbp)
</span></span><span><span>
</span></span><span><span>    <span># Advance 8 bytes from root, to get left pointer in struct.
</span></span></span><span><span><span></span>    <span>movq</span> <span>8</span>(%rdi), %rdx
</span></span><span><span>    <span># Store this as local_left to stack
</span></span></span><span><span><span></span>    <span>movq</span> %rdx, <span>local_left</span>(%rbp)
</span></span><span><span>
</span></span><span><span>    <span># Advance 16 bytes from root, to get to right pointer in struct.
</span></span></span><span><span><span></span>    <span>movq</span> <span>16</span>(%rdi), %rdx
</span></span><span><span>    <span># Store this as local_right to stack
</span></span></span><span><span><span></span>    <span>movq</span> %rdx, <span>local_right</span>(%rbp)
</span></span><span><span>
</span></span><span><span>done:
</span></span><span><span>    <span># ...
</span></span></span></code></pre></td></tr></tbody></table>
</div>
</div><h2 id="do-the-recursive-calls">Do the recursive calls</h2>
<p>At this point, looking at the pseudocode, we simply need to perform 2 recursive calls.</p>
<p>To do this, we store the correct parameter to <code>%rdi</code> and use the <code>call</code> instruction.</p>
<div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span> 1
</span><span> 2
</span><span> 3
</span><span> 4
</span><span> 5
</span><span> 6
</span><span> 7
</span><span> 8
</span><span> 9
</span><span>10
</span><span>11
</span><span>12
</span><span>13
</span><span>14
</span><span>15
</span><span>16
</span><span>17
</span><span>18
</span><span>19
</span><span>20
</span><span>21
</span><span>22
</span><span>23
</span><span>24
</span><span>25
</span><span>26
</span><span>27
</span><span>28
</span><span>29
</span><span>30
</span><span>31
</span><span>32
</span><span>33
</span><span>34
</span><span>35
</span><span>36
</span><span>37
</span><span>38
</span><span>39
</span><span>40
</span><span>41
</span><span>42
</span><span>43
</span><span>44
</span><span>45
</span><span>46
</span><span>47
</span><span>48
</span><span>49
</span><span>50
</span><span>51
</span><span>52
</span><span>53
</span><span>54
</span><span>55
</span><span>56
</span><span>57
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="gas"><span><span>invert_tree:
</span></span><span><span>    <span># Function prologue
</span></span></span><span><span><span></span>    <span>push</span> %rbp
</span></span><span><span>    <span>mov</span> %rsp, %rbp
</span></span><span><span>    <span>sub</span> <span>$32</span>, %rsp
</span></span><span><span>
</span></span><span><span>    <span># --------- Base case ---------
</span></span></span><span><span><span></span>    <span># %rdi contains the input parameter (8 byte pointer to the root)
</span></span></span><span><span><span></span>    <span>cmp</span> <span>$0</span>, %rdi
</span></span><span><span>    <span># Root not NULL, continue with execution
</span></span></span><span><span><span></span>    <span>jne</span> <span>continue</span>
</span></span><span><span>    <span># Root is NULL, store NULL in %rax and return
</span></span></span><span><span><span></span>    <span>xor</span> %rax, %rax
</span></span><span><span>    <span>jmp</span> <span>done</span>
</span></span><span><span>continue:
</span></span><span><span>    <span># --------- Save local variables to stack ---------
</span></span></span><span><span><span></span>    <span># Save the root parameter as local_root on stack
</span></span></span><span><span><span></span>    <span>movq</span> %rdi, <span>local_root</span>(%rbp)
</span></span><span><span>
</span></span><span><span>    <span># Advance 8 bytes from root, to get left pointer in struct.
</span></span></span><span><span><span></span>    <span>movq</span> <span>8</span>(%rdi), %rdx
</span></span><span><span>    <span># Store this as local_left to stack
</span></span></span><span><span><span></span>    <span>movq</span> %rdx, <span>local_left</span>(%rbp)
</span></span><span><span>
</span></span><span><span>    <span># Advance 16 bytes from root, to get to right pointer in struct.
</span></span></span><span><span><span></span>    <span>movq</span> <span>16</span>(%rdi), %rdx
</span></span><span><span>    <span># Store this as local_right to stack
</span></span></span><span><span><span></span>    <span>movq</span> %rdx, <span>local_right</span>(%rbp)
</span></span><span><span>
</span></span><span><span>    <span># --------- Recursive calls ---------
</span></span></span><span><span><span></span>    <span># Recursively call invert_tree on local_right
</span></span></span><span><span><span></span>    <span>movq</span> <span>local_right</span>(%rbp), %rdi
</span></span><span><span>    <span>call</span> <span>invert_tree</span>
</span></span><span><span>
</span></span><span><span>    <span># Calculate address of root.left
</span></span></span><span><span><span></span>    <span>movq</span> <span>local_root</span>(%rbp), %rdx
</span></span><span><span>    <span>addq</span> <span>$8</span>, %rdx
</span></span><span><span>    <span># Assign root.left to value returned from recursive call
</span></span></span><span><span><span></span>    <span>movq</span> %rax, (%rdx)
</span></span><span><span>    
</span></span><span><span>    <span># Recursively call invert_tree on local_left
</span></span></span><span><span><span></span>    <span>movq</span> <span>local_left</span>(%rbp), %rdi
</span></span><span><span>    <span>call</span> <span>invert_tree</span>
</span></span><span><span>
</span></span><span><span>    <span># Calculate address of root.right
</span></span></span><span><span><span></span>    <span>movq</span> <span>local_root</span>(%rbp), %rdx
</span></span><span><span>    <span>addq</span> <span>$16</span>, %rdx
</span></span><span><span>    <span># Assign root.right to value returned from recursive call
</span></span></span><span><span><span></span>    <span>movq</span> %rax, (%rdx)
</span></span><span><span>
</span></span><span><span>    <span># Return root
</span></span></span><span><span><span></span>    <span>movq</span> <span>local_root</span>(%rbp), %rax
</span></span><span><span>
</span></span><span><span>done:
</span></span><span><span>    <span># Function epilogue
</span></span></span><span><span><span></span>    <span>leave</span>
</span></span><span><span>    <span>ret</span>
</span></span></code></pre></td></tr></tbody></table>
</div>
</div><p>To assign the results of the recursive calls, we use the <code>%rdx</code> register to compute the correct addresses of <code>root.left</code> and <code>root.right</code>.
Most of this is a straight translation of the pseudocode.</p>
<h2 id="submitting-to-leetcode">Submitting to leetcode</h2>
<p>We cannot submit assembly to Leetcode, so we will use C instead. Leetcode uses gcc to compile our code, so we can use the <code>__asm__</code> directive to add our assembly.</p>
<p>We need to also declare our function with <code>extern</code> before we can call it.</p>
<div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span> 1
</span><span> 2
</span><span> 3
</span><span> 4
</span><span> 5
</span><span> 6
</span><span> 7
</span><span> 8
</span><span> 9
</span><span>10
</span><span>11
</span><span>12
</span><span>13
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="c"><span><span><span>typedef</span> <span>struct</span> TreeNode TreeNode;
</span></span><span><span><span>extern</span> TreeNode<span>*</span> <span>invert_tree</span>(TreeNode<span>*</span>);
</span></span><span><span>
</span></span><span><span>__asm__(<span>&#34;.global invert_tree  </span><span>\n\t</span><span>&#34;</span>
</span></span><span><span><span>&#34;.type invert_tree, @function </span><span>\n\t</span><span>&#34;</span>
</span></span><span><span><span>&#34;.section .text               </span><span>\n\t</span><span>&#34;</span>
</span></span><span><span><span>// Rest of our code here...
</span></span></span><span><span><span></span>);
</span></span><span><span>
</span></span><span><span><span>// Leetcode func
</span></span></span><span><span><span></span>TreeNode<span>*</span> <span>invertTree</span>(TreeNode<span>*</span> root){
</span></span><span><span>    <span>return</span> invert_tree(root);
</span></span><span><span>}
</span></span></code></pre></td></tr></tbody></table>
</div>
</div><p>And we are done!
</p><figure><img src="https://sanket.tech/img/leetcode_ac.png"/>
</figure>

<p>The leetcode performance and memory numbers are very unreliable, so we don’t really know how much faster our program is compared to other submissions, but I suspect it is pretty fast.
</p><figure><img src="https://sanket.tech/img/leetcode_submission.png"/>
</figure>

<h2 id="conclusion">Conclusion</h2>
<p>This was a fun excursion to brush up on my assembly skills. It wasn’t difficult, but definitely was tedious (This is generally how I feel
about most leetcode style questions).</p>
<figure><img src="https://sanket.tech/img/goog_cant_invert_binary_tree.webp" alt="Max Howell rejected from Google" width="60%"/>
</figure>

<p>At least now I can relate to more memes on <a href="https://old.reddit.com/r/ProgrammerHumor">r/ProgrammerHumor</a></p>
<figure><img src="https://sanket.tech/img/they_dont_know_meme.png" alt="Max Howell rejected from Google" width="70%"/>
</figure>

<h2 id="hn-front-page-update">HN Front page update</h2>
<p>Since a lot of people from <a href="https://news.ycombinator.com/item?id=33732071">HN</a> and <a href="https://old.reddit.com/r/programming/comments/z3s9cp/inverting_a_binary_tree_using_x64_assembly/">reddit</a> are here, time for a shameless plug:</p>
<p>I am actively looking for a python/rust/quant job.
Here’s my <a href="https://github.com/TechieBoy">Github</a> and <a href="https://sanket.tech/cdn-cgi/l/email-protection#d5a1b0bebbb4a6f0e097b4a1f0e091b1a0b6bef0e097b1baa1f0e091b6bab8">Email</a></p>
<p>Thanks for reading. Happy Thanksgiving!</p>

      </div></div>
  </body>
</html>
