<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.youtube.com/watch?v=M6XIgdS1rzs">Original</a>
    <h1>Iron nitride permanent magnets made with DIY ball mill [video]</h1>
    
    <div id="readability-page-1" class="page"><div><p><i><a href="https://blog.jacobvosmaer.nl/">Jacob Vosmaer&#39;s blog</a></i></p>

<p>2025-06-14</p>

<p>I&#39;m slowly building out my own <a href="https://blog.jacobvosmaer.nl/tags/forth.html">Forth</a> implementation. In this post I will reflect on what I have been doing since my <a href="https://blog.jacobvosmaer.nl/0049-revisiting-forth/">last post</a>.</p>

<h2>Recap</h2>

<p><a href="https://en.wikipedia.org/wiki/Forth_(programming_language)">Forth</a> is a programming language that is simple enough for people to like writing their own version of it. Simple does not mean easy however. </p>

<p>My ideal is to write something like <a href="http://git.annexia.org/?p=jonesforth.git;a=tree">Jonesforth</a> but that is written in 386 assembler which is currently beyond my skills.  I got started writing <a href="https://github.com/jacobvosmaer/yaforth">my own Forth &#34;yaforth&#34;</a> in C instead, based on a nice <a href="https://news.ycombinator.com/item?id=13082825">Hacker News comment</a> by user &#34;tzs&#34;. I&#39;ll call that design &#34;tzs-forth&#34;.</p>

<p>My project is to add features to yaforth and transform its design from tzs-forth to something closer to Jonesforth.
If you want to read along with what changed then you can see my tzs-forth  <a href="https://github.com/jacobvosmaer/yaforth/tree/e3a2a81f6696f550b8ee866335359f9a0f8d4622">here</a>. The current more Jones-ish version is <a href="https://github.com/jacobvosmaer/yaforth/tree/b1c8ef47eadf4b5609ef79a495127c32c8d40c91">here</a>.</p>

<h2>Why I want to move from tzs-forth closer to Jonesforth</h2>

<p>One of the things I like about Jonesforth is how the code is structured. It has two &#34;halves&#34;. The first half (<a href="http://git.annexia.org/?p=jonesforth.git;a=blob;f=jonesforth.S;h=45e6e854a5d2a4c3f26af264dfce56379d401425;hb=HEAD">jonesforth.S</a>) is assembler, and the second half (<a href="http://git.annexia.org/?p=jonesforth.git;a=blob;f=jonesforth.f;h=5c1309574ae1165195a43250c19c822ab8681671;hb=HEAD">jonesforth.f</a>) is Forth. The assembler part compiles to an executable. The idea is you run the executable with jonesforth.f as a kind of startup file. Once the executable has processed the startup file it is ready for interactive use.</p>

<p>As a Forth learner, what I find so interesting here is how much of the system is defined in Forth itself. Even inside the assembler file jonesforth.S you find many functions (&#34;words&#34;) defined in Forth. They don&#39;t use Forth syntax because it&#39;s an assembler file but the author is nevertheless defining &#34;colon words&#34;, meaning words defined in Forth instead of native code.
For example, the word <code>:</code> <a href="http://git.annexia.org/?p=jonesforth.git;a=blob;f=jonesforth.S;h=45e6e854a5d2a4c3f26af264dfce56379d401425;hb=HEAD#l1869">is defined</a> as an arary of previously defined words, not as assembly.</p>

<p>I want yaforth to be like that too.</p>

<h2>Changing the memory layout</h2>

<p>The great thing about tzs-forth is that it uses &#34;natural&#34; or &#34;normal&#34; C concepts to help you get started building a Forth interpreter. This helps if you don&#39;t already understand Forth internals. But the downside of this approach, at least in my case, was that I ended up with data structures and a memory layout that make sense for a generic C program, but that are hard to read and write from Forth.</p>

<p>Forth expects to work with a single contiguous block of memory. My tzs-forth implementation used C malloc for strings and Forth colon word instruction arrays, meaning many scattered bits of memory.</p>

<p>The current version of yaforth uses one block of 32KB of memory called <code>mem</code> for all its allocations. Malloc is no longer used anywhere. We still have <a href="https://github.com/jacobvosmaer/yaforth/blob/b1c8ef47eadf4b5609ef79a495127c32c8d40c91/forth.c#L24">separate arrays</a> for the parameter and return stacks. I&#39;m not sure how much I would gain from moving those into <code>mem</code> main memory; I will find out.</p>

<p>Strings are stored in <code>mem</code> main memory with 32-bit length prefixes.</p>

<p>Dictionary entries are still C structs, which means that the C compiler is in charge of their memory layout. For the sake of maximizing code written in Forth it would be better to define their layout in Forth. I may do that later.</p>

<h2>Functions that modify interpreter state</h2>

<p>Another problem is that Jonesforth uses a pair of global instruction pointers. This allows it to intermingle code and data. For example, a relative jump in Jonesforth looks like a pointer to the code word <code>BRANCH</code> followed by the jump offset. That works because <code>BRANCH</code> can read the instruction pointer to find the jump offset, and then add that offset to the instruction pointer: that is what a jump is after all.</p>

<p>In my tzs-forth there was no global instruction pointer so I built support for local jumps into the function that runs colon words. This is the old code that performs a jump if the first value on the stack is zero. I have omitted the <a href="https://github.com/jacobvosmaer/yaforth/blob/e3a2a81f6696f550b8ee866335359f9a0f8d4622/forth.c#L222-L244">rest of the function</a>.</p>

<pre><code>  } else if (def[i] == DEFJUMPNZ) {
    int x;
    assert(++i &lt; deflen);
    if (stackpop(&amp;x) &amp;&amp; !x) {
      i += def[i];
      assert(i &gt;= 0 &amp;&amp; i &lt; deflen);
    }
  }
</code></pre>

<p>In the current code, the <a href="https://github.com/jacobvosmaer/yaforth/blob/b1c8ef47eadf4b5609ef79a495127c32c8d40c91/forth.c#L286-L290">function that runs code words</a> is oblivious about how jumps are implemented. Jumps are split into unconditional jump (<code>branch</code>) and jump-if-zero (<code>branch0</code>). The variable  <code>vm.next</code> is one of the (global) instruction pointers. </p>

<pre><code>void branch(void) {
  vm.next += *intaddr(vm.next);
  next();
}

void branch0(void) {
  int x;
  if (stackpop(&amp;x) &amp;&amp; !x) {
    branch();
  } else {
    intpp(&amp;vm.next); /* discard jump offset */
    next();
  }
}
</code></pre>

<h2>Writing part of the language in Forth itself</h2>

<p>In the old yaforth I could not wrap my head around how to start writing part of the language in Forth itself. In the current version I have solved this as follows.</p>

<p>There is a <a href="https://github.com/jacobvosmaer/yaforth/blob/b1c8ef47eadf4b5609ef79a495127c32c8d40c91/builtin.f">separate file <code>builtin.f</code></a> in the root of the repository. The Makefile <a href="https://github.com/jacobvosmaer/yaforth/blob/b1c8ef47eadf4b5609ef79a495127c32c8d40c91/Makefile#L4-L5">converts</a> this into an array of bytes in a header file using the ad-hoc file embedding utility <a href="https://github.com/jacobvosmaer/yaforth/blob/b1c8ef47eadf4b5609ef79a495127c32c8d40c91/builtin.c">builtin.c</a>. In forth.c, I have replaced all calls to <code>getchar()</code> with a wrapper function which first returns all bytes from the builtin &#34;input array&#34; before it starts calling <code>getchar()</code> to read from stdin.</p>

<pre><code>int Getchar(void) {
  return builtinp &lt; nelem(builtinforth) ? builtinforth[builtinp++] : getchar();
}
</code></pre>

<p>I don&#39;t know why I couldn&#39;t come up with that the first time. :)</p>

<p>I know this is inscrutable to the untrained eye, but it is satisfying to define <code>if</code>, <code>then</code> and <code>else</code> in the language rather than in the interpreter:</p>

<pre><code>
: if immediate &#39; branch0 , here @ 0 , ;
: else immediate &#39; branch , here @ 0 , swap dup here @ swap - swap ! ;
: then immediate dup here @ swap - swap ! ;
</code></pre>

<p>Understanding what this means is one of my main motivations for writing my own Forth.</p>

<h2>What&#39;s next</h2>

<p>I&#39;m going to keep nudging yaforth closer to Jonesforth. I can pick anything I like from the Jonesforth source code and see if I feel like implementing it. I&#39;m not trying to make a useful language per se, my main goal is to slowly get to understand Forth better.</p>

<p>Thank you for reading along!</p>
<p>Tags:  <a href="https://blog.jacobvosmaer.nl/tags/forth.html">forth</a></p>
<p><a href="https://blog.jacobvosmaer.nl/">Index</a> â€” <a href="mailto:contact@jacobvosmaer.nl">Contact</a></p></div></div>
  </body>
</html>
