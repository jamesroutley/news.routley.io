<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.julik.nl/2025/01/supercharge-sqlite-with-ruby-functions">Original</a>
    <h1>Supercharge SQLite with Ruby Functions</h1>
    
    <div id="readability-page-1" class="page"><div>

	<article>

    
		

<small>
  
    
   · <time datetime="2025-01-23T00:00:00+00:00">23 Jan 2025</time>
</small>

    <p>An interesting twist in my recent usage of SQLite was the fact that I noticed my research scripts and the database intertwine more. SQLite is unique in that it really lives in-process, unlike standalone database servers. There is a feature to that which does not get used very frequently, but can be indispensable in some situations.</p>

<p>By the way, the talk about the system that made me me to explore SQLite in anger can now be <a href="https://www.youtube.com/embed/q_EbeIaH0xw?list=PLZW-kXE0oRykbAG33qUp5izazF3wvHcft">seen here.</a></p>

<p>Normally it is your Ruby (or Python, or Go, or whatever) program which calls SQLite to make it “do stuff”. Most calls will be mapped to a native call like <code>sqlite3_exec()</code> which will do “SQLite things” and return you a result, converted into data structures accessible to your runtime. But there is another possible direction here - SQLite can actually call your code instead.</p>

<!--more-->

<p>There is no support for stored procedures in SQLite (which is imaginable, since the database already lives inside of a very large stored procedure - your program, basically). But: in addition to stored procedures, databases sometimes support something called <code>UDF</code>s, which stands for <em>User-Defined Functions.</em> Most SQL databases have some functions built in:</p>



<p>calls a built-in SQL function called <code>RANDOM</code>, which will accept no arguments and return you a random integer. A call like this:</p>



<p>calls a built-in SQL function called <code>LOWER</code>, which accepts one argument and returns that argument converted to lowercase. The beauty of it is, of course, that it does not have to be a literal - it can be a column resulting from a different part of the SQL statement:</p>

<div><div><pre><code><span>SELECT</span> <span>id</span><span>,</span> <span>UPPER</span><span>(</span><span>legal_name</span><span>)</span> <span>FROM</span> <span>users</span>
</code></pre></div></div>

<p>will select you the user names converted to uppercase. Important to note: these functions are what’s called <em>scalar</em> functions - they map a piece of data from a single result row to a piece of output. Another family of SQL functions are <em>aggregate</em> functions, which accept the entire result set and apply to all values in that dataset. These are your <code>MIN</code> and <code>MAX</code> functions:</p>

<div><div><pre><code><span>SELECT</span> <span>MAX</span><span>(</span><span>age</span><span>)</span> <span>FROM</span> <span>users</span>
</code></pre></div></div>

<p>They map values from multiple rows to one piece of output. Same for <code>SUM</code>.</p>

<p>The builtin functions in SQLite are pretty neat, but the menu is not that large, and sometimes exactly the function we need is not on that menu, sadly. In most DB systems you can define functions in the language the database supports - usually it will be some kind of superset of SQL the database supports, or one of the scripting languages the database embeds. With SQLite, however, something much nicer is possible: you can expose your own code from your “main” program and make it available to your SQL queries. And in some situations it can be very handy.</p>

<h3 id="creating-your-own-scalar-udf">Creating your own scalar UDF</h3>

<p>For instance: at Cheddar we use a small library called <a href="https://github.com/cheddar-me/tou">tou</a> - which is a flavour of time-ordered UUIDs. Let’s make it available to our database:</p>

<div><div><pre><code><span>CREATE</span> <span>TABLE</span> <span>users</span> <span>(</span>
  <span>uid</span> <span>VARCHAR</span> <span>NOT</span> <span>NULL</span> <span>PRIMARY</span> <span>KEY</span><span>,</span>
  <span>name</span> <span>VARCHAR</span> <span>NOT</span> <span>NULL</span>
<span>)</span>
</code></pre></div></div>

<p>Then, let’s create an enumerator which will issue us a deterministic sequence of Tou IDs, all sorted to the same timestamp:</p>

<div><div><pre><code><span>id_gen</span> <span>=</span> <span>Enumerator</span><span>.</span><span>new</span> <span>do</span> <span>|</span><span>yielder</span><span>|</span>
  <span>time</span> <span>=</span> <span>Time</span><span>.</span><span>at</span><span>(</span><span>1737665388.5792</span><span>)</span>
  <span>random</span> <span>=</span> <span>Random</span><span>.</span><span>new</span><span>(</span><span>42</span><span>)</span>
  <span>loop</span> <span>do</span>
    <span>yielder</span><span>.</span><span>yield</span><span>(</span><span>Tou</span><span>.</span><span>uuid</span><span>(</span><span>random</span><span>:,</span> <span>time</span><span>:))</span>
  <span>end</span>
<span>end</span>
</code></pre></div></div>

<p>The nice thing about this Enumerator is that we can now grab us a fresh Tou UUID by calling <code>next</code>:</p>

<div><div><pre><code><span>[</span><span>13</span><span>]</span> <span>pry</span><span>(</span><span>main</span><span>)</span><span>&gt;</span> <span>id_gen</span><span>.</span><span>next</span>
<span>=&gt;</span> <span>&#34;062c65c0-3989-4806-9ce1-5fb33deacb5c&#34;</span>
<span>[</span><span>14</span><span>]</span> <span>pry</span><span>(</span><span>main</span><span>)</span><span>&gt;</span> <span>id_gen</span><span>.</span><span>next</span>
<span>=&gt;</span> <span>&#34;062c65c0-3989-480e-95f5-2e6af463bb47&#34;</span>
</code></pre></div></div>

<p>We can insert users into our table with those IDs like so:</p>

<div><div><pre><code><span>db</span><span>.</span><span>query</span><span>(</span><span>&#34;INSERT INTO users (id, name) VALUES (?, ?)&#34;</span><span>,</span> <span>[</span><span>id_gen</span><span>.</span><span>next</span><span>,</span> <span>&#34;John&#34;</span><span>])</span>
</code></pre></div></div>

<p>and it will work, but sometimes we would want those values to be provided by SQLite itself. A good example is when doing a <code>UNION ALL</code> select to combine multiple datasets:</p>

<div><div><pre><code><span>SELECT</span> <span>&#39;Legal drinking age&#39;</span> <span>AS</span> <span>desc</span><span>,</span> <span>COUNT</span><span>(</span><span>1</span><span>)</span> <span>AS</span> <span>cnt</span> <span>FROM</span> <span>users</span> <span>WHERE</span> <span>age</span> <span>&gt;=</span> <span>21</span>
<span>UNION</span> <span>ALL</span> <span>SELECT</span> <span>&#39;Below legal drinking age&#39;</span> <span>AS</span> <span>desc</span><span>,</span> <span>COUNT</span><span>(</span><span>1</span><span>)</span> <span>AS</span> <span>cnt</span> <span>FROM</span> <span>users</span> <span>WHERE</span> <span>age</span> <span>&lt;</span> <span>21</span>
</code></pre></div></div>

<p>If this is for a report this is fine, but if we want to retain our result rows and address them, we may want to give them some kind of ID. We could inject those IDs into the query via the placeholders, but we can as well change our query to add IDs by itself:</p>

<div><div><pre><code><span>SELECT</span> <span>TOU</span><span>()</span> <span>AS</span> <span>id</span><span>,</span> <span>&#39;Legal drinking age&#39;</span> <span>AS</span> <span>desc</span><span>,</span> <span>COUNT</span><span>(</span><span>1</span><span>)</span> <span>AS</span> <span>cnt</span> <span>FROM</span> <span>users</span> <span>WHERE</span> <span>age</span> <span>&gt;=</span> <span>21</span>
<span>UNION</span> <span>ALL</span>
<span>SELECT</span> <span>TOU</span><span>()</span> <span>AS</span> <span>id</span><span>,</span> <span>&#39;Below legal drinking age&#39;</span> <span>AS</span> <span>desc</span><span>,</span> <span>COUNT</span><span>(</span><span>1</span><span>)</span> <span>AS</span> <span>cnt</span> <span>FROM</span> <span>users</span> <span>WHERE</span> <span>age</span> <span>&lt;</span> <span>21</span>
</code></pre></div></div>

<p>To be able to do that, we need to expose our little ID generator to SQLite. It is done like this:</p>

<div><div><pre><code><span>db</span><span>.</span><span>create_function</span><span>(</span> <span>&#34;TOU&#34;</span><span>,</span> <span>_arity</span> <span>=</span> <span>0</span><span>)</span> <span>do</span> <span>|</span><span>func</span><span>|</span>
  <span>func</span><span>.</span><span>result</span> <span>=</span> <span>id_gen</span><span>.</span><span>next</span>
<span>end</span>
</code></pre></div></div>

<p>We create a closure which addresses our ID generator and ratchets it to a new value. The value then gets assigned to the result of the function.</p>

<div><div><pre><code><span>[</span><span>22</span><span>]</span> <span>pry</span><span>(</span><span>main</span><span>)</span><span>&gt;</span> <span>db</span><span>.</span><span>get_first_value</span><span>(</span><span>&#34;SELECT TOU()&#34;</span><span>)</span>
<span>=&gt;</span> <span>&#34;062c65c0-3989-480c-ae41-99142ccb9866&#34;</span>
</code></pre></div></div>

<p>and now we can auto-ID our rows. This can be useful when doing, for example, a <code>CREATE TABLE some_report_results AS SELECT ...</code> and allows removing the annoying placeholders. There is another use for those scalar functions. Imagine we want to do some regex matching, but either SQLite does not have the regexp extension (is of an older version), or - which is something that actually happened to me - you want to test a Ruby regexp against all the items in your dataset. Regex engines are different in implementation and in their quirks. If you are designing regexes and you intend to run them in your Ruby runtime, it can be very useful to see whether they work or not. So, let’s design a function which will just tell us whether a regex matches a passed string, and will allow us branching:</p>

<div><div><pre><code><span>db</span><span>.</span><span>create_function</span><span>(</span> <span>&#34;TEXT_MATCHES_RE&#34;</span><span>,</span> <span>_arity</span> <span>=</span> <span>2</span><span>)</span> <span>do</span> <span>|</span><span>func</span><span>,</span> <span>text</span><span>,</span> <span>regexp_str</span><span>|</span>
  <span>re</span> <span>=</span> <span>Regexp</span><span>.</span><span>new</span><span>(</span><span>regexp_str</span><span>)</span>
  <span>func</span><span>.</span><span>result</span> <span>=</span> <span>text</span><span>&amp;</span><span>.</span><span>match?</span><span>(</span><span>re</span><span>)</span> <span>?</span> <span>1</span> <span>:</span> <span>0</span> <span># SQLite has no boolean type</span>
<span>end</span>
</code></pre></div></div>

<div><div><pre><code><span>[</span><span>30</span><span>]</span> <span>pry</span><span>(</span><span>main</span><span>)</span><span>&gt;</span> <span>db</span><span>.</span><span>get_first_value</span><span>(</span><span>&#34;SELECT TEXT_MATCHES_RE(&#39;john&#39;, &#39;[a-z]&#39;)&#34;</span><span>)</span>
<span>=&gt;</span> <span>1</span>
<span>[</span><span>31</span><span>]</span> <span>pry</span><span>(</span><span>main</span><span>)</span><span>&gt;</span> <span>db</span><span>.</span><span>get_first_value</span><span>(</span><span>&#34;SELECT TEXT_MATCHES_RE(&#39;123&#39;, &#39;[a-z]&#39;)&#34;</span><span>)</span>
<span>=&gt;</span> <span>0</span>
</code></pre></div></div>

<p>Since SQLite treats 1 and 0 as booleans we can use our new function in a <code>WHERE</code> clause (which is the main spot this kind of UDF will be useful):</p>

<div><div><pre><code><span>db</span><span>.</span><span>query</span><span>(</span><span>&#34;CREATE TABLE users (name TEXT NOT NULL)&#34;</span><span>);</span>
<span>db</span><span>.</span><span>query</span><span>(</span><span>&#34;INSERT INTO users (name) VALUES (?), (?), (?), (?)&#34;</span><span>,</span> <span>[</span><span>&#34;Jane&#34;</span><span>,</span> <span>&#34;Bobby&#34;</span><span>,</span> <span>&#34;Jake&#34;</span><span>,</span> <span>&#34;Peter&#34;</span><span>]);</span>
<span>db</span><span>.</span><span>query</span><span>(</span><span>&#34;SELECT * FROM users WHERE TEXT_MATCHES_RE(name, &#39;^Ja&#39;)&#34;</span><span>).</span><span>to_a</span> <span># =&gt; [[&#34;Jane&#34;], [&#34;Jake&#34;]]</span>
</code></pre></div></div>

<h3 id="rolling-it-up-with-aggregates">Rolling it up with aggregates</h3>

<p>When I was working on Sked - the scheduling simulator - one of the most useful things was rapidly doing statistical queries after the simulation ran. Doing things like computing the percentiles, the standard deviation and the like. While SQLite does have <code>MIN</code> and <code>MAX</code>, it does not have the more advanced functions that may be useful in those scenarios - like <a href="https://www.postgresql.org/docs/current/functions-aggregate.html">percentile_cont</a> - luckily, though, these can be implemented right inside the script used for experimenting.</p>

<p>An aggregate function in SQLite can be defined by supplying callbacks, but the Ruby SQLite library offers another option - defining your aggregate function as a class which gets instantiated. The instance holds the state that needs to be kept while the aggregate function gets called (the so-called “step”) for every value in the resultset.</p>

<div><div><pre><code><span>class</span> <span>StddevSampHandler</span>
  <span>def</span> <span>self</span><span>.</span><span>arity</span> <span>=</span> <span>1</span>
  <span>def</span> <span>self</span><span>.</span><span>name</span> <span>=</span> <span>&#34;stddev_samp&#34;</span>

  <span>def</span> <span>initialize</span>
    <span>@sample</span> <span>=</span> <span>[]</span>
  <span>end</span>

  <span>def</span> <span>step</span><span>(</span><span>ctx</span><span>,</span> <span>value</span><span>)</span>
    <span>@sample</span> <span>&lt;&lt;</span> <span>value</span><span>.</span><span>to_f</span> <span>if</span> <span>value</span>
  <span>end</span>

  <span>def</span> <span>finalize</span><span>(</span><span>ctx</span><span>)</span>
    <span>if</span> <span>@sample</span><span>.</span><span>length</span> <span>&gt;</span> <span>1</span>
      <span>mean</span> <span>=</span> <span>@sample</span><span>.</span><span>sum</span><span>.</span><span>to_f</span> <span>/</span> <span>@sample</span><span>.</span><span>length</span>
      <span>sd</span> <span>=</span> <span>@sample</span><span>.</span><span>map</span> <span>{</span> <span>|</span><span>v</span><span>|</span> <span>(</span><span>v</span> <span>-</span> <span>mean</span><span>)</span><span>**</span><span>2</span> <span>}.</span><span>sum</span>
      <span>ctx</span><span>.</span><span>result</span> <span>=</span> <span>Math</span><span>.</span><span>sqrt</span><span>(</span><span>sd</span> <span>/</span> <span>(</span><span>@sample</span><span>.</span><span>length</span> <span>-</span> <span>1</span><span>))</span>
    <span>else</span>
      <span>ctx</span><span>.</span><span>result</span> <span>=</span> <span>0</span>
    <span>end</span>
    <span>@sample</span><span>.</span><span>clear</span>
  <span>end</span>
<span>end</span>

<span>class</span> <span>PercentileHandler</span>
  <span>def</span> <span>self</span><span>.</span><span>arity</span> <span>=</span> <span>1</span>
  <span>def</span> <span>self</span><span>.</span><span>name</span> <span>=</span> <span>&#34;p90&#34;</span>

  <span>def</span> <span>initialize</span>
    <span>@sample</span> <span>=</span> <span>[]</span>
    <span>@fraction</span> <span>=</span> <span>0.9</span>
  <span>end</span>

  <span>def</span> <span>step</span><span>(</span><span>ctx</span><span>,</span> <span>value</span><span>)</span>
    <span>@sample</span> <span>&lt;&lt;</span> <span>value</span><span>.</span><span>to_f</span> <span>if</span> <span>value</span>
  <span>end</span>

  <span>def</span> <span>finalize</span><span>(</span><span>ctx</span><span>)</span>
    <span>if</span> <span>@sample</span><span>.</span><span>length</span> <span>&gt;</span> <span>1</span>
      <span>@sample</span><span>.</span><span>sort!</span>
      <span>k</span> <span>=</span> <span>(</span><span>@fraction</span> <span>*</span> <span>(</span><span>@sample</span><span>.</span><span>length</span> <span>-</span> <span>1</span><span>)</span> <span>+</span> <span>1</span><span>).</span><span>floor</span> <span>-</span> <span>1</span>
      <span>f</span> <span>=</span> <span>(</span><span>@fraction</span> <span>*</span> <span>(</span><span>@sample</span><span>.</span><span>length</span> <span>-</span> <span>1</span><span>)</span> <span>+</span> <span>1</span><span>).</span><span>modulo</span><span>(</span><span>1</span><span>)</span>
      <span>ctx</span><span>.</span><span>result</span> <span>=</span> <span>@sample</span><span>[</span><span>k</span><span>]</span> <span>+</span> <span>(</span><span>f</span> <span>*</span> <span>(</span><span>@sample</span><span>[</span><span>k</span> <span>+</span> <span>1</span><span>]</span> <span>-</span> <span>@sample</span><span>[</span><span>k</span><span>]))</span>
    <span>else</span>
      <span>ctx</span><span>.</span><span>result</span> <span>=</span> <span>0</span>
    <span>end</span>
    <span>@sample</span><span>.</span><span>clear</span>
  <span>end</span>
<span>end</span>

<span>db</span><span>.</span><span>create_aggregate_handler</span><span>(</span><span>StddevSampHandler</span><span>)</span>
<span>db</span><span>.</span><span>create_aggregate_handler</span><span>(</span><span>PercentileHandler</span><span>)</span>
</code></pre></div></div>

<p>Then we can create our table of samples:</p>

<div><div><pre><code><span>db</span><span>.</span><span>query</span><span>(</span><span>&#34;CREATE TABLE metric_samples (name VARCHAR NOT NULL, value FLOAT)&#34;</span><span>)</span>
<span>rng</span> <span>=</span> <span>Random</span><span>.</span><span>new</span><span>(</span><span>42</span><span>)</span>
<span>values</span> <span>=</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>4</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>,</span> <span>5</span><span>,</span> <span>6</span><span>,</span> <span>7</span><span>,</span> <span>7</span><span>,</span> <span>7</span><span>,</span> <span>8</span><span>,</span> <span>9</span><span>,</span> <span>9</span><span>,</span> <span>11</span><span>,</span> <span>12</span><span>,</span> <span>12</span><span>,</span> <span>25</span><span>]</span>
<span>metrics</span> <span>=</span> <span>%w( latency duration )</span>
<span>199</span><span>.</span><span>times</span> <span>do</span>
  <span>db</span><span>.</span><span>query</span><span>(</span><span>&#34;INSERT INTO metric_samples (name, value) VALUES (?, ?)&#34;</span><span>,</span> <span>[</span><span>metrics</span><span>.</span><span>sample</span><span>(</span><span>random: </span><span>rng</span><span>),</span> <span>values</span><span>.</span><span>sample</span><span>(</span><span>random: </span><span>rng</span><span>)])</span>
<span>end</span>
</code></pre></div></div>

<p>and query it:</p>

<div><div><pre><code><span>db</span><span>.</span><span>query</span><span>(</span><span>&lt;&lt;~</span><span>SQL</span><span>).</span><span>to_a</span><span>
SELECT
  COUNT(1) AS sample_size,
  name,
  printf(&#34;%.2f&#34;, MIN(value)) AS min,
  printf(&#34;%.2f&#34;, MAX(value)) AS max,
  printf(&#34;%.2f&#34;, AVG(value)) AS avg,
  printf(&#34;%.2f&#34;, stddev_samp(value)) AS stddev,
  printf(&#34;%.2f&#34;, p90(value)) AS p90
FROM metric_samples GROUP BY name
</span><span>SQL</span>
</code></pre></div></div>

<p>which gives:</p>

<div><div><pre><code>[
  [115, &#34;duration&#34;, &#34;1.00&#34;, &#34;25.00&#34;, &#34;6.10&#34;, &#34;4.21&#34;, &#34;12.00&#34;],
  [84, &#34;latency&#34;, &#34;1.00&#34;, &#34;25.00&#34;, &#34;7.65&#34;, &#34;5.78&#34;, &#34;12.00&#34;]
]
</code></pre></div></div>

<p>This turned out to be very useful when printing reports about the various simulations we ran for our queue workloads.</p>

<h3 id="a-stub-is-a-stub">A stub is a stub</h3>

<p>There is a caveat though. A SQL function can, normally, be used both in queries and in SQL statements run by the database itself. That may be triggers - which run on various changes to the tables, or the default values for columns. For example, nothing precludes us from creating a view with a <code>TOU()</code> value:</p>

<div><div><pre><code><span>CREATE</span> <span>VIEW</span> <span>single_tou</span> <span>AS</span> <span>SELECT</span> <span>TOU</span><span>()</span>
</code></pre></div></div>

<p>and in our process, this will work just fine. However, an unpleasant surprise will await you if you try to open the database “outside” of your process - and portability is one of the great qualities of SQLite databases. When you open a database in <code>sqlite</code> or using your favourite GUI editor (I use <a href="https://www.sqlitepro.com/">SQLPro</a>) you will be greeted with an error if you try to <code>SELECT</code> from that view or examine it. Unlike other RDBMSes, the function in SQLite is just a “callback” which delegates work to your host application, and cannot be stored with the database - or executed without your application having defined the function.</p>

<p>When defining a function, there is a flag you can supply - <a href="https://sqlite.org/c3ref/c_deterministic.html#sqliteinnocuous">as per SQLite documentation</a> - which is called <code>SQLITE_DIRECTONLY</code> - which hints SQLite that your function should not be used in “retained” SQL statements, and may only be used via a direct call. The way to set that is a bit obtuse, but it is available. There is an argument called <code>text_rep</code> that these flags may be OR-d with. The default value tells SQLite that it is getting text data in UTF-8. Let’s define a <code>TOU2()</code> which will be direct-only:</p>

<div><div><pre><code><span>SQLITE_DIRECTONLY</span> <span>=</span> <span>0x000080000</span>
<span>text_rep_and_flags</span> <span>=</span> <span>SQLite3</span><span>::</span><span>Constants</span><span>::</span><span>TextRep</span><span>::</span><span>UTF8</span> <span>|</span> <span>SQLITE_DIRECTONLY</span>
<span>db</span><span>.</span><span>create_function</span><span>(</span><span>&#34;TOU2&#34;</span><span>,</span> <span>_arity</span> <span>=</span> <span>0</span><span>,</span> <span>text_rep_and_flags</span><span>)</span> <span>do</span> <span>|</span><span>func</span><span>|</span>
  <span>func</span><span>.</span><span>result</span> <span>=</span> <span>id_gen</span><span>.</span><span>next</span>
<span>end</span>
<span>db</span><span>.</span><span>get_first_value</span><span>(</span><span>&#34;SELECT TOU2()&#34;</span><span>)</span> <span>#=&gt; &#34;062c65c0-3989-480a-91de-0eca55917557&#34;</span>
</code></pre></div></div>

<p>And we can create a view with that function, but if we try to <code>SELECT</code> from it, we will get an error:</p>

<div><div><pre><code><span>db</span><span>.</span><span>query</span><span>(</span><span>&#34;CREATE VIEW no_tou AS SELECT TOU2()&#34;</span><span>);</span>

<span>db</span><span>.</span><span>get_first_value</span><span>(</span><span>&#34;SELECT * FROM no_tou&#34;</span><span>)</span>
<span>&gt;</span> <span>SQLite3</span><span>::</span><span>SQLException</span><span>:</span> <span>unsafe</span> <span>use</span> <span>of</span> <span>TOU2</span><span>():</span>
<span>&gt;</span> <span>SELECT</span> <span>*</span> <span>FROM</span> <span>no_tou</span>
</code></pre></div></div>

<p>This is at least better than having this view hang around - but something to keep in mind. <code>SQLITE_DETERMINISTIC</code> also seems handy.</p>

<h3 id="to-sqlite-and-back-again">To SQLite and back again</h3>

<p>Wiring Ruby methods into SQLite can give you some very interesting capabilities (doing HTTP requests from your SQLite calls, parsing HTML with Nokogiri, tokenizing and matching data) and are a great tool when exploring datasets. If you use a Ruby program to generate a SQLite database for later inspection, like I do - just mark them as <code>SQLITE_DIRECTONLY</code> to not be unpleasantly surprised. It would, of course, be wonderful to be able to “talk” to the SQLite database with the custom UDFs attached using a familiar GUI – but since the functions live in Ruby-land, it will be impractical.</p>

<p>Now go and make your <code>SELECT</code>ions.</p>


  </article>

</div></div>
  </body>
</html>
