<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://yongjie.codes/reading-logs/effective-c/">Original</a>
    <h1>Reading Log for Effective C: An Introduction to Professional C Programming</h1>
    
    <div id="readability-page-1" class="page"><div>
        <p>
            <h3>Effective C: An Introduction to Professional C Programming</h3>
        </p>
        <h3><i>Book Details</i></h3>
        <ul>
            <li><p>Full Title: <i>Effective C: An Introduction to Professional C Programming</i></p></li>
            <li><p>Author: <i>Robert C. Seacord</i></p></li>
            <li><p>ISBN/URL: <i>978-1-71850-104-1</i></p></li>
            <li><p>Reading Period: <i>2020.12.13–2021.06</i></p></li>
            <li><p>Source: <i>Chanced upon the title when searching for other books</i></p></li>
        </ul>
        
<h2 id="headline-1">
General Review
</h2>
<ul>
<li>
<p>
An excellent book for the inquisitive: the books manages to confuse more so
than elucidate, and an inquisitive learner can look forward to hours of trying
(and failing miserably) to understand the prose contained within, only to
completely understand the topic (and more) after a brief Google search and a
visit to cppreference.com (and, God forbid, StackOverflow).
</p>
</li>
<li>
<p>
More seriously, this is generally an average-to-poor book.
</p>
<ul>
<li>
<p>
Tends to be mere listing of topics loosely grouped in various topics.
</p>
</li>
<li>
<p>
Explanation also isn&#39;t very clear, for example the definition of <em>sequence
point</em> is <code>the juncture at which side effects will have completed</code>; compared
this with the way it is explained on cppreference.com: =If a sequence point
is present between the subexpressions E1 and E2, then both value computation
and side effects of E1 are sequenced-before every value computation and side
effect of E2= (and a separate definition of sequenced-before is provided).
</p>
</li>
</ul>
</li>
</ul>
<h2 id="headline-2">
Specific Takeaways
</h2>
<h3 id="headline-3">
Introduction
</h3>
<ul>
<li>
<p>
One of the several tenets of C is to trust the programmer, allowing the
programmer to do what needs to be done.
</p>
</li>
<li>
<p>
Different implementations of C can have different behaviors. And because
certain behaviors in C are undefined, it is not possible to understand the C
language by just writing simple test programs to examine the behavior.
</p>
</li>
</ul>
<h3 id="headline-4">
Chapter 1 - Getting Started with C
</h3>
<ul>
<li>
<p>
C defines two possible execution environments: <em>freestanding</em> and <em>hosted</em>.
</p>
<ul>
<li>
<p>
A freestanding environment may not provide an operating system and is
typically used in embedded programming.
</p>
</li>
<li>
<p>
The name and type of the function called at program startup are
implementation defined. (E.g., <code>int main(void) {...}</code>)
</p>
</li>
</ul>
</li>
<li>
<p>
Five kinds of portability issues are enumerated in Annex J of the C Standard
documents:
</p>
<ol>
<li>
<p>
Implementation-defined behavior
</p>
<ul>
<li>
<p>
I.e., program behavior that is not specified by the C Standard and that
may offer different results among implementations, but has consistent,
documented behavior within an implementation.
</p>
</li>
<li>
<p>
E.g., number of bits in a byte.
</p>
</li>
<li>
<p>
Mostly harmless, but can cause defects when porting to different
implementations.
</p>
</li>
</ul>
</li>
<li>
<p>
Unspecified behavior
</p>
<ul>
<li>
<p>
I.e., program behavior for which the standard provides two or more
options.
</p>
</li>
<li>
<p>
E.g., function parameter storage layout, which can vary among function
invocations within the same program.
</p>
</li>
</ul>
</li>
<li>
<p>
Undefined behavior
</p>
<ul>
<li>
<p>
I.e., behavior that isn&#39;t defined by the C Standard; &#34;behavior, upon use
of a non-portable or erroneous program construct or of erroneous data, for
which the standard imposes no requirements&#34;
</p>
</li>
<li>
<p>
E.g., signed integer overflow and dereferencing an invalid pointer value.
</p>
</li>
</ul>
</li>
<li>
<p>
Locale-specific behavior
</p>
</li>
<li>
<p>
Common extensions
</p>
<ul>
<li>
<p>
I.e., extensions that are widely used in many systems but are not
portable to all implementations
</p>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="headline-5">
Chapter 2 - Objects, Functions, and Types
</h3>
<ul>
<li>
<p>
Every type in C is either an <em>object</em> type or a <em>function</em> type.
</p>
</li>
<li>
<p>
An <em>object</em> is storage in which you can represent values; &#34;region of data
storage in the execution environment, the contents of which can represent
values, … when referenced, an object can be interpreted as having a
particular type&#34;
</p>
</li>
<li>
<p>
<em>Functions</em> are not objects but do have types.
</p>
</li>
<li>
<p>
<em>Pointers</em> can be thought of as an <em>address</em> to a location in memory where an
object or function is stored.
</p>
<ul>
<li>
<p>
The object or function pointed to is called the <em>referenced type</em>.
</p>
<h4 id="headline-6">
Declaring Variables
</h4>
<h4 id="headline-7">
Scope
</h4>
</li>
</ul>
</li>
<li>
<p>
C has four types of scope: file, block, function prototype, and function.
</p>
<h4 id="headline-8">
Storage Duration
</h4>
</li>
<li>
<p>
Storage duration is the lifetime of objects. There are four storage durations
available: automatic, static, thread, and allocated.
</p>
<ol>
<li>
<p>
Automatic
</p>
<ul>
<li>
<p>
I.e., objects declared within a block or as a function parameter.
</p>
</li>
</ul>
</li>
<li>
<p>
Static
</p>
<ul>
<li>
<p>
Objects declared in the file scope have static storage duration. The
lifetime of these object is the entire execution of the program.
</p>
</li>
<li>
<p>
It is also possible to declare a variable within a block scope to have
static storage duration by using the storage-class specifier <code>static</code>.
</p>
<ul>
<li>
<p>
These objects persist after the function has exited.
</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>
Thread
</p>
<ul>
<li>
<p>
Not covered in this book.
</p>
</li>
</ul>
</li>
<li>
<p>
Allocated
</p>
<ul>
<li>
<p>
Deals with dynamically allocated memory (see chapter 6).
</p>
</li>
</ul>
</li>
</ol>
</li>
<li>
<p>
Note: <em>Scope</em> and <em>lifetime</em> are entirely different concepts. Scope applies to
identifiers, whereas lifetime applies to objects. The scope of an identifier
is the code region where the object denoted by the identifier can be accessed
by its name. The lifetime of an object is the time period for which the object
exists.
</p>
<h4 id="headline-9">
Alignment
</h4>
</li>
<li>
<p>
Object types have alignment requirements that place restrictions on the
addresses at which objects of that type may be allocated.
</p>
</li>
<li>
<p>
Generally, C programmers need not concern themselves with alignment
requirements, because the compiler chooses suitable alignments for its
various types.
</p>
</li>
<li>
<p>
Sometimes, programmers may need to override the compiler&#39;s default choices.
</p>
<ul>
<li>
<p>
This is traditionally done by using linker commands, by over-allocating
memory with <code>malloc</code> followed by rounding the user address upward, or
similar operations involving other nonstandard facilities.
</p>
</li>
<li>
<p>
C11 introduces a mechanism for specifying alignments using <code>_Alignas</code>.
</p>
<h4 id="headline-10">
Object Types
</h4>
<h5 id="headline-11">
Boolean Types
</h5>
<h5 id="headline-12">
Character Types
</h5>
</li>
</ul>
</li>
<li>
<p>
C defines three character types: <code>char</code>, <code>signed char</code>, and <code>unsigned char</code>.
</p>
</li>
<li>
<p>
Each compiler implementation will define <code>char</code> to have the same alignment,
size, range, representation, and behavior as either of the other two, but
<code>char</code> is nonetheless a separate type from the other two.
</p>
</li>
<li>
<p>
C also provides <code>wchar_t</code> type to represent a larger character sets required
for non-English characters.
</p>
<h5 id="headline-13">
Numerical Types
</h5>
<h6 id="headline-14">
Integer Types
</h6>
</li>
<li>
<p>
Signed integer types: <code>signed char</code>, <code>short int</code>, <code>int</code>, <code>long int</code>, <code>long
long int</code>.
</p>
<ul>
<li>
<p>
The word <code>int</code> may be omitted when using the above (i.e., <code>short myShort =
10;</code> instead of <code>short int myShort = 10;</code>)
</p>
</li>
</ul>
</li>
<li>
<p>
Unsigned integer types: <code>unsigned char</code>, <code>unsigned short int</code>, <code>unsigned int</code>,
<code>unsigned long int</code>, <code>unsigned long long int</code>.
</p>
</li>
<li>
<p>
A programmer can specify the actual width using definitions from <code>&lt;stdint.h&gt;</code>
or <code>&lt;inttypes.h&gt;</code>, like <code>uint32_t</code>.
</p>
<ul>
<li>
<p>
Other useful type definitions include <code>uintmax_t</code> and <code>intmax_t</code>.
</p>
<h6 id="headline-15">
Enums
</h6>
</li>
</ul>
</li>
<li>
<p>
E.g.,
</p>
<div>
<div><pre><code data-lang="c">  <span>enum</span> day { sun, mon, tue, wed, thu, fri, sat };
  <span>enum</span> cardinal_points { north <span>=</span> <span>0</span>, east <span>=</span> <span>90</span>, south <span>=</span> <span>180</span>, west <span>=</span> <span>270</span> };
  <span>enum</span> months { jan <span>=</span> <span>1</span>, feb, mar, apr, may, jun, jul, aug, sep, oct, nov, dec };</code></pre></div>
</div>
<h6 id="headline-16">
Floating-Point Types
</h6>
</li>
<li>
<p>
C supports three floating-point types: <code>float</code>, <code>double</code> and <code>long double</code>.
</p>
<h5 id="headline-17">
<code>void</code> Types
</h5>
</li>
<li>
<p>
When used in function parameter list, it indicates that the function takes no
arguments.
</p>
</li>
<li>
<p>
When used as function return type, it indicates that the function doesn&#39;t
return a value.
</p>
</li>
<li>
<p>
The derived type <code>void*</code> means that the pointer can reference any object.
</p>
<h4 id="headline-18">
Function Types
</h4>
</li>
<li>
<p>
E.g.,
</p>
<div>
<div><pre><code data-lang="c">  <span>int</span> <span>f</span>(<span>void</span>);
  <span>int</span> <span>*</span><span>fip</span>(); <span>// Bad (because can refer to any function returning int), but valid
</span><span></span>  <span>void</span> <span>g</span>(<span>int</span> i, <span>int</span> j);
  <span>void</span> <span>h</span>(<span>int</span>, <span>int</span>); <span>//</span> Bad (because no identifiers <span>for</span> parameters), but valid</code></pre></div>
</div>
<h4 id="headline-19">
Derived Types
</h4>
<h5 id="headline-20">
Pointers
</h5>
<h5 id="headline-21">
Arrays
</h5>
</li>
<li>
<p>
The subscript (<code>[]</code>) operator and addition (<code>+</code>) operator are defined so that
<code>str[i]</code> is identical to <code>*(str + i)</code>. Hence <code>str[i] = 10</code> becomes <code>*(str + i)
= 10</code>.
</p>
</li>
<li>
<p>
If the operand of the unary <code>&amp;</code> operator is the result of a <code>[]</code> operator, the
result is as if the <code>&amp;</code> operator were removed and the <code>[]</code> operator were
changed to a <code>+</code> operator. For example, <code>&amp;str[10]</code> is the same as <code>str + 10</code>.
</p>
<h5 id="headline-22">
Structures
</h5>
</li>
<li>
<p>
E.g.,
</p>
<div>
<div><pre><code data-lang="c">  <span>struct</span> sigrecord {
    <span>int</span> signum;
    <span>char</span> signame[<span>20</span>];
    <span>char</span> sigdesc[<span>100</span>];
  } sigline, <span>*</span>sigline_p;</code></pre></div>
</div>
<h5 id="headline-23">
Unions
</h5>
</li>
<li>
<p>
Union types are similar to structures, except that the memory used by the
member objects overlaps. Unions can contain an object of one type at one time,
and an object of a different type at a different time, but never both objects
at the same time, and are primarily used to save memory.
</p>
</li>
<li>
<p>
E.g.,
</p>
<div>
<div><pre><code data-lang="c">  <span>union</span> {
    <span>struct</span> {
      <span>int</span> type;
    } n;
    <span>struct</span> {
      <span>int</span> type;
      <span>int</span> intnode;
    } ni;
    <span>struct</span> {
      <span>int</span> type;
      <span>double</span> doublenode;
    } nf;
  } u;
  u.nf.type <span>=</span> <span>1</span>;
  u.nf.doublenode <span>=</span> <span>3.14</span>;</code></pre></div>
</div>
<h4 id="headline-24">
Tags
</h4>
</li>
<li>
<p>
Tags are a special naming mechanism for structs, unions and enumerations.
</p>
</li>
<li>
<p>
For example, the identifier <code>s</code> below is a tag:
</p>

</li>
<li>
<p>
A tag is not a type name and cannot be used to declare a variable. For
example, to use the <code>s</code> tag above to declare variables, one must do this:
</p>
<div>
<div><pre><code data-lang="c">  <span>struct</span> s v;   <span>// instance of struct s
</span><span></span>  <span>struct</span> s <span>*</span>p;  <span>//</span> pointer to <span>struct</span> s</code></pre></div>
</div>
<ul>
<li>
<p>
The names of unions and enumerations are also tags and not types. As such,
the names cannot be used to declare a variable alone:
</p>
<div>
<div><pre><code data-lang="c">  <span>enum</span> day { sun, mon, tue, wed, thu, fri, sat };
  day today; <span>// error
</span><span></span>  <span>enum</span> day tomorrow; <span>//</span> OK</code></pre></div>
</div>
</li>
</ul>
</li>
<li>
<p>
The tags of structures, unions and enumerations are defined in a separate
namespace from ordinary identifiers, and will not clash with each other.
</p>
<h4 id="headline-25">
Type Qualifiers
</h4>
</li>
<li>
<p>
I.e., <code>const</code>, <code>volatile</code> or <code>restrict</code>
</p>
</li>
<li>
<p>
<code>const</code>
</p>
<ul>
<li>
<p>
Objects declared with <code>const</code> qualifier are not modifiable: i.e., not
assignable, but can have constant initializers
</p>
</li>
<li>
<p>
It is possible to bypass a <code>const</code> qualifier using pointers:
</p>
<div>
<div><pre><code data-lang="c">  <span>const</span> <span>int</span> i <span>=</span> <span>1</span>; <span>// object of const-qualified type
</span><span></span>  <span>int</span> <span>*</span>ip <span>=</span> (<span>int</span> <span>*</span>)<span>&amp;</span>i;
  <span>*</span>ip <span>=</span> <span>2</span>; <span>//</span> undefined behavior</code></pre></div>
</div>
</li>
<li>
<p>
If the <code>const</code> pointer points to an object that is actually not defined
using <code>const</code>, then it is okay to cast away the <code>const</code> in the pointer
(second last line below):
</p>
<div>
<div><pre><code data-lang="c">  <span>int</span> i <span>=</span> <span>12</span>;
  <span>const</span> <span>int</span> j <span>=</span> <span>12</span>;
  <span>const</span> <span>int</span> <span>*</span>ip <span>=</span> <span>&amp;</span>i;
  <span>const</span> <span>int</span> <span>*</span>jp <span>=</span> <span>&amp;</span>j;
  <span>*</span>(<span>int</span> <span>*</span>)ip <span>=</span> <span>42</span>; <span>//ok
</span><span></span>  <span>*</span>(<span>int</span> <span>*</span>)jp <span>=</span> <span>42</span>; <span>//</span> undefined behavior</code></pre></div>
</div>
</li>
</ul>
</li>
<li>
<p>
<code>volatile</code>
</p>
<ul>
<li>
<p>
Static <code>volatile</code>-qualified objects are used to model memory-mapped
input/output ports.
</p>
</li>
<li>
<p>
Static constant <code>volatile</code>-qualified objects model memory-mapped input ports
such as real-time clock.
</p>
</li>
<li>
<p>
Values in the objects listed above may change without the knowledge of the
compiler; e.g., the value of the real-time clock will change even without
interaction from the C program.
</p>
<ul>
<li>
<p>
<code>volatile</code> ensures that the value will actually be read each time it is
supposed to be read in the program (otherwise the compiler might optimize
away certain reads)
</p>
<ul>
<li>
<p>
E.g., the following code ensures that value of <code>port</code> is read and
assigned back to <code>port</code> (instead of it being a no-op since it&#39;s an
assignment to self):
</p>
<div>
<div><pre><code data-lang="c">  <span>volatile</span> <span>int</span> port;
  port <span>=</span> port;</code></pre></div>
</div>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>
<code>volatile</code>-qualified types are also used for signal handlers with <code>setjmp</code> /
<code>longjmp</code>
</p>
</li>
<li>
<p>
Unlike in Java, <code>volatile</code>-qualified types in C should not be used for
synchronization between threads.
</p>
</li>
</ul>
</li>
<li>
<p>
<code>restrict</code>
</p>
<ul>
<li>
<p>
The compiler will assume objects accessed through pointer with
<code>restrict</code>-qualified pointers are not accessed by another other pointers,
allowing more optimizations. For example:
</p>
<div>
<div><pre><code data-lang="c">  <span>void</span> <span>f</span>(<span>unsigned</span> <span>int</span> n, <span>int</span> <span>*</span> <span>restrict</span> p, <span>int</span> <span>*</span> <span>restrict</span> q) {
    <span>while</span> (n<span>--</span> <span>&gt;</span> <span>0</span>) {
      <span>*</span>p<span>++</span> <span>=</span> <span>*</span>q<span>++</span>;
    }
  }</code></pre></div>
</div>
</li>
</ul>
</li>
</ul>
<h3 id="headline-26">
Chapter 3 - Arithmetic Type
</h3>
<h4 id="headline-27">
Integers
</h4>
<ul>
<li>
<p>
Integer types are unsigned by default, except for <code>char</code>.
</p>
</li>
<li>
<p>
When declaring integer types, unless <code>int</code> is the only keyword, it can be
removed. For instance, <code>long long int</code> is the same as <code>long long</code>.
</p>
</li>
<li>
<p>
When using unsigned integer types, remember to avoid wraparound (if necessary)
using the <code>&lt;limits.h&gt;</code> library.
</p>
<ul>
<li>
<p>
Some common mistakes are as follows:
</p>
<ul>
<li>
<p>
Never-ending loop:
</p>
<div>
<div><pre><code data-lang="c">     <span>for</span> (<span>unsigned</span> <span>int</span> i <span>=</span> n; i <span>&gt;=</span> <span>0</span>; <span>--</span>i)</code></pre></div>
</div>
</li>
<li>
<p>
Value of expression never greater than <code>UINT_MAX</code>:
</p>
<div>
<div><pre><code data-lang="c">  <span>extern</span> <span>unsigned</span> <span>int</span> ui, sum;
  <span>if</span> (ui <span>+</span> sum <span>&gt;</span> UINT_MAX)
    too_big();
  <span>else</span>
    sum <span>=</span> sum <span>+</span> ui;

  <span>// One correct way might be as follows
</span><span></span>  <span>extern</span> <span>unsigned</span> <span>int</span> ui, sum;
  <span>if</span> (ui <span>&gt;</span> UINT_MAX <span>-</span> sum)
    too_big();
  <span>else</span>
    sum <span>=</span> sum <span>+</span> ui</code></pre></div>
</div>
</li>
<li>
<p>
Value of expression never negative:
</p>
<div>
<div><pre><code data-lang="c">  <span>extern</span> <span>unsigned</span> <span>int</span> i, j;
  <span>if</span> (i <span>-</span> j <span>&lt;</span> <span>0</span>)
    negative();
  <span>else</span>
    i <span>=</span> i <span>-</span> j;

  <span>// One correct way migh be as follows:
</span><span></span>  <span>extern</span> <span>unsigned</span> <span>int</span> i, j;
  <span>if</span> (j <span>&lt;</span> i)
    negative();
  <span>else</span>
    i <span>=</span> i <span>-</span> j;</code></pre></div>
</div>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>
<strong>Signed Integers</strong>
</p>
<ul>
<li>
<p>
Historically C support three different representations of signed integers:
</p>
<ol>
<li>
<p>
Sign and magnitude - High order bit represents sign, the remaining
represents magnitude
</p>
</li>
<li>
<p>
One&#39;s complement - The sign bit is given the weight -(2^(N-1) - 1)
</p>
</li>
<li>
<p>
Two&#39;s complement - The sign bit is given the weight -(2^(N-1))
</p>
</li>
</ol>
</li>
<li>
<p>
Using the two&#39;s complement system, we can represent one additional negative
value compared to positive value. For instance, a 8-bit signed integer can
represent values in the range [-128, 127]. This results is an interesting
edge case where abs(-128) is not representation in the same bit-width.
</p>
</li>
</ul>
</li>
</ul>
<h4 id="headline-28">
Floating-Point
</h4>
<ul>
<li>
<p>
Floating-points are generally represented using (a) the sign bit, (b) the
exponent, and (c) the significand (also referred to as the mantissa).
</p>
<ul>
<li>
<p>
To avoid the need for separately encoding negative values in the exponent,
an offset is applied. For example, to encode the zero value for an 8-bit
exponent, we might store the value 127.
</p>
</li>
<li>
<p>
Exponents of -127 (where every bit is zero) and +128 (where every bit is
one) are reserved for special numbers.
</p>
</li>
<li>
<p>
The significand is adjusted so that the first digit is always one, and this
is implied in the encoding scheme.
</p>
<ul>
<li>
<p>
As such a <code>float</code> which uses 1 bit for the sign bit, 8 bits for the
exponent, and 23 bits for the significand can actually represent 24 bits
of precision.
</p>
</li>
<li>
<p>
A <code>double</code> which uses 1 bit for the sign bit, 11 bits for the exponent,
and 52 bits for the significand can represent 53 bits of precision.
</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>
<strong>Subnormal Floating-Point Number</strong>
</p>
<ul>
<li>
<p>
A non-zero floating-point number that is so small such that even the
smallest value for the exponent is insufficient to represent, is called a
subnormal (also known as denormal) floating-point number.
</p>
</li>
<li>
<p>
In such a situation, all the bits of the exponent is zero, and the implied
leading one for the significand is now implied to be a zero.
</p>
<ul>
<li>
<p>
As a result, such subnormal floating-point numbers have lower precision.
</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>
Floating-point types can also represent (a) positive infinity, (b) negative
infinity, (c) not-a-number (NaN).
</p>
<ul>
<li>
<p>
Having infinities allow operations to continue past overflows without
requiring special treatment, and are well-defined behaviors.
</p>
</li>
<li>
<p>
NaN can be quiet or signalling. A quiet NaN has to be checked manually,
whereas a signalling NaN raises floating-point exception when in occurs.
</p>
</li>
</ul>
</li>
</ul>
<h4 id="headline-29">
Arithmetic Conversion
</h4>
<ul>
<li>
<p>
There are two types of conversion: implicit (also known as coercion) and
explicit (via casting)
</p>
</li>
<li>
<p>
<strong>Integer Conversion Rank</strong>
</p>
<ul>
<li>
<p>
Every integer has a <em>integer conversion rank</em>, where generally:
</p>
<ul>
<li>
<p>
integer types of higher precision has higher rank than types with lower
rank
</p>
</li>
<li>
<p>
unsigned and signed integer of the same type has the same rank (e.g.,
<code>char</code>, <code>signed char</code> and <code>unsigned char</code> has the same rank)
</p>
</li>
<li>
<p>
no two signed integer types has the same rank, even if they have the same
representation
</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>
<strong>Integer Promotion</strong>
</p>
<ul>
<li>
<p>
<em>Integer promotion</em> is the process of converting <em>small type</em> to an <code>int</code> or
<code>unsigned int</code> (?automatically). A small type is one that has lower integer
conversion rank than <code>int</code> and <code>signed int</code>.
</p>
</li>
<li>
<p>
Integer promotion will preserve the value of the original small type. That
is, the small type will be converted to <code>int</code> if the all values of the
original type can be represented as <code>int</code>, otherwise, the small type will be
converted to <code>unsigned int</code>.
</p>
</li>
<li>
<p>
Integer promotion serves two primary purposes:
</p>
<ol>
<li>
<p>
Encourage operations in the natural size for the architecture (<code>int</code>)
</p>
</li>
<li>
<p>
Avoid overflows from intermediate values. For example, without integer
promotion, the <code>c1 * c2</code> below would have overflowed:
</p>
<div>
<div><pre><code data-lang="c">  <span>signed</span> <span>char</span> c1, c2, c3, cresult;
  c1 <span>=</span> <span>3</span>; c2 <span>=</span> <span>100</span>; c3 <span>=</span> <span>4</span>;
  cresult <span>=</span> c1 <span>*</span> c2 <span>/</span> c3;</code></pre></div>
</div>
</li>
</ol>
</li>
</ul>
</li>
<li>
<p>
<strong>Usual Arithmetic Conversion</strong>
</p>
<ul>
<li>
<p>
<em>Balancing conversions</em> converts one or both operands to a binary operator
(i.e., an operator that takes two operand, as opposed to an unary operator)
to a common type.
</p>
</li>
<li>
<p>
The conversion rules are as follows:
</p>
<ul>
<li>
<p>
If any of the operand is <code>long double</code>, the other operand is converted to
<code>long double</code>. Otherwise, check for if any of the operand is <code>double</code>, and
if not, <code>float</code>.
</p>
</li>
<li>
<p>
Failing the above, integer promotions are applied on both operands:
</p>
<ol>
<li>
<p>
Stop if both sides have the same type
</p>
</li>
<li>
<p>
If the type on both sides are signed (or unsigned), the type with lower
integer conversion rank is converted to the other.
</p>
</li>
<li>
<p>
If the unsigned type has greater rank than the signed type, then the
signed type is converted to the unsigned type.
</p>
</li>
<li>
<p>
If the signed type can represent all values of the unsigned type, then
the unsigned type is converted to the signed type.
</p>
</li>
<li>
<p>
Otherwise, both operands are converted to the unsigned integer type
corresponding to the type of the signed operand.
</p>
</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>
<strong>Safe Conversions</strong>
</p>
<ul>
<li>
<p>
While conversion of a type to a large type of the same signedness is always
safe, this may not be the same for other conversions.
</p>
</li>
<li>
<p>
One way to ensure safe integer conversion is as follows:
</p>
<div>
<div><pre><code data-lang="c">  <span>#include</span> <span>&lt;errno.h&gt;</span><span>
</span><span></span>  <span>#include</span> <span>&lt;limits.h&gt;</span><span>
</span><span></span>
  errno_t <span>do_stuff</span>(<span>signed</span> <span>long</span> value) {
    <span>if</span> ((value <span>&lt;</span> SCHAR_MIN) <span>||</span> (value <span>&gt;</span> SCHAR_MAX)) {
      <span>return</span> ERANGE;
    }
    <span>signed</span> <span>char</span> sc <span>=</span> (<span>signed</span> <span>char</span>)value;
    <span>// do something with sc
</span><span></span>  }</code></pre></div>
</div>
</li>
<li>
<p>
Integer to floating-point conversion:
</p>
<ul>
<li>
<p>
When an integer type is converted to a floating-pointing type, its value
is unchanged (if representable in the floating-point type) or rounded to
the representable value.
</p>
</li>
<li>
<p>
if the value of the integer type is outside the range representable by the
floating-point type, then the behavior is undefined.
</p>
</li>
</ul>
</li>
<li>
<p>
Floating-point to integer conversion:
</p>
<ul>
<li>
<p>
When a floating-point type with finite value is converted to an integer
type, the fractional part is discarded.
</p>
</li>
<li>
<p>
If the integral part cannot be represented by the integer type, then the
behavior is undefined.
</p>
</li>
</ul>
</li>
<li>
<p>
Floating-point to floating-point conversions:
</p>
<ul>
<li>
<p>
Conversion of a floating-point type to a larger one is always safe.
</p>
</li>
<li>
<p>
Conversion of a larger floating-point type to a smaller one behaves
similarly to conversion of a floating-point type to an integer type.
</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="headline-30">
Chapter 4 - Expressions and Operators
</h3>
<h4 id="headline-31">
Simple Assignment
</h4>
<ul>
<li>
<p>
A statement like <code>int myInt = 123;</code> is a declaration with an initializer. It
is not an assignment. An assignment is something like <code>myInt = 456;</code> occurring
after a declaration.
</p>
</li>
<li>
<p>
The left operand of the assignment operation (<code>=</code>) is also called the <em>lvalue</em>
(we can also think of it as the <em>locator</em> value). An lvalue can be an
expression like <code>*(p+4)</code>.
</p>
</li>
<li>
<p>
The right operand is also called the <em>rvalue</em>, is also an expression, and
additionally can simply be a value (i.e., doesn&#39;t need to identify an object).
</p>
</li>
</ul>
<h4 id="headline-32">
Evaluations
</h4>
<ul>
<li>
<p>
Evaluations mostly mean simplifying an expression down to a single
value. Sometimes evaluations will result in side effects.
</p>
</li>
</ul>
<h4 id="headline-33">
Operator Precedence and Associativity
</h4>
<ul>
<li>
<p>
Associativity affects how operators of the same precedence are grouped. For
example, the addition operator (<code>+</code>) is left-associative, so an expression
like <code>a + b + c</code> will be grouped as <code>((a + b) + c</code>). An example of a
right-associative operand would be the assignment operator.
</p>
</li>
<li>
<p>
Some weird implications of operator precedence and associativity:
</p>
<ul>
<li>
<p>
<code>*p++</code> is evaluated as <code>*(p++)</code>, <code>++*p</code> is evaluated as <code>++(*p)</code>
</p>
</li>
</ul>
</li>
</ul>
<h4 id="headline-34">
Order of Evaluation
</h4>
<ul>
<li>
<p>
Order of evaluation in C is generally unspecified, and the compiler may choose
to evaluate them in different order in different circumstances. For example,
in an expression like <code>funcA(funcB(), funcC())</code>, there is no guarantee whether
<code>funcB()</code> or <code>funcC()</code> will be evaluated first.
</p>
</li>
<li>
<p>
Evaluations can be classified as <em>unsequenced</em> and <em>indeterminately sequenced</em>.
</p>
<ul>
<li>
<p>
Execution of <em>unsequenced</em> evaluations can interleave, provided that
execution is <em>sequentially consistent</em> (i.e., that the reads and writes
happen in the order specificity by the program (YJ: lexical order?))
</p>
</li>
<li>
<p>
<em>Indeterminately sequenced</em> evaluations cannot be interleaved, but can still
be executed in any order.
</p>
<ul>
<li>
<p>
See <a href="https://en.cppreference.com/w/c/language/eval_order,">https://en.cppreference.com/w/c/language/eval_order,</a>
<a href="https://web.archive.org/web/20210411111816/https://en.cppreference.com/w/c/language/eval_order">https://web.archive.org/web/20210411111816/https://en.cppreference.com/w/c/language/eval_order</a>
</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>
If a side effect is unsequenced relative to another side effect on the same
scalar or a value computation that relies on the value of the scalar, the
result is undefined behavior. For example, this expression is undefined:
<code>i++ * i++</code>.
</p>
</li>
</ul>
<h4 id="headline-35">
Some other operators to be aware of
</h4>
<ul>
<li>
<p>
<code>sizeof()</code>, <code>_Alignof()</code>, <code>,</code> (i.e., the comma)
</p>
</li>
</ul>
<h3 id="headline-36">
Chapter 5 - Control Flow
</h3>
<ul>
<li>
<p>
<em>Compound statements</em> are lists of zero or more statements surrounded by curly
braces.
</p>
</li>
<li>
<p>
The <code>if</code> statement actually only executes the next statement after the
condition (or the <code>else</code> clause), as in:
</p>
<div>
<div><pre><code data-lang="c">  <span>if</span> (myWonderfulCondition)
    myOneStatement();
  <span>else</span>
    <span>myOtherOneStatement</span>();</code></pre></div>
</div>
<p>
However, because compound statement is treated as a statement too, we can use
a compound statement in place of each of <code>myOneStatement()</code> and/or
<code>myOtherOneStatement()</code> above, giving us the if-else block with the curly
braces that we are all so familiar.
</p>
</li>
<li>
<p>
When using <code>switch</code> cases with enumerations, consider having a <code>default</code> case
with the <code>abort()</code> (from the <code>&lt;stdlib.h&gt;</code> header) to catch situations where
the enumeration is updated but not the switch case.
</p>
</li>
<li>
<p>
One situation where <code>goto</code> statements might be useful is when dealing with
multiple error handling and clean-ups.
</p>
<ul>
<li>
<p>
For example, if we have three operations in sequential–operations A, B and
C–each of which will acquire resources that will need to be cleaned up, but
may also fail.
</p>
</li>
<li>
<p>
So if A succeeds and B fails, we will need to perform clean-up for A; if A
and B succeeds and C fails, then we need to perform clean-up for A and B.
</p>
</li>
<li>
<p>
Using <code>if-else</code> to handle this will require nesting, and can lead to
complexity.
</p>
</li>
<li>
<p>
A solution using <code>goto</code> statement may be as follows:
</p>
<div>
<div><pre><code data-lang="c">  <span>int</span> <span>doSomething</span>(<span>void</span>) {
    FILE <span>*</span>file1, <span>*</span>file2;
    object_t <span>*</span>obj;
    <span>int</span> ret_val <span>=</span> <span>0</span>;

    file1 <span>=</span> open(<span>&#34;file_1&#34;</span>, <span>&#34;w&#34;</span>);
    <span>if</span> (file1 <span>==</span> NULL) {
      ret_val <span>=</span> <span>-</span><span>1</span>;
      <span>goto</span> FAIL_FILE1;
    }

    file2 <span>=</span> open(<span>&#34;file_2&#34;</span>, <span>&#34;w&#34;</span>);
    <span>if</span> (file2 <span>==</span> NULL) {
      ret_val <span>=</span> <span>-</span><span>1</span>;
      <span>goto</span> FAIL_FILE2;
    }

    obj <span>=</span> malloc(size_of(object_t));
    <span>if</span> (obj <span>==</span> NULL) {
      ret_val <span>=</span> <span>-</span><span>1</span>;
      <span>goto</span> FAIL_OBJ;
    }

    <span>// perform actual operations
</span><span></span>
    <span>// clean up
</span><span></span>    free(obj);
   FAIL_OBJ:
    fclose(file2);
   FAIL_FILE2:
    fclose(file1);
   FAIL_FILE1:
    <span>return</span> ret_val;
  }</code></pre></div>
</div>
</li>
</ul>
</li>
</ul>
<h3 id="headline-37">
Chapter 6 - Dynamically Allocated Memory
</h3>
<h4 id="headline-38">
Basics
</h4>
<ul>
<li>
<p>
Objects declared within a block has <em>automatic</em> storage, and their lifetimes
begins and ends with the block.
</p>
</li>
<li>
<p>
Objects declared in the file scope has static storage, and last for the entire
duration of the program. Their values are initialized prior to program
start-up.
</p>
<ul>
<li>
<p>
Objects in block scope can be declared to have static storage using the
<code>static</code> keyword.
</p>
</li>
</ul>
</li>
<li>
<p>
Dynamically allocated memory has <em>allocated storage duration</em>, and extends from
allocation until deallocation.
</p>
</li>
</ul>
<h4 id="headline-39">
Memory Management Functions
</h4>
<ul>
<li>
<p>
<code>malloc</code>
</p>
<ul>
<li>
<p>
Accepts as argument representing the number of bytes to allocate. Typically
used with <code>sizeof</code> operator for convenience and portability.
</p>
</li>
<li>
<p>
Returns null pointer to indicate error.
</p>
</li>
<li>
<p>
Because objects of any type can be stored in allocated memory, we can assign
the pointers return by all memory allocation functions to point to any type
of object.
</p>
</li>
<li>
<p>
It appears to be a point of contention whether it is good practice to
immediately cast the return value of <code>malloc</code>, like:
</p>
<div>
<div><pre><code data-lang="c">  widget <span>*</span>w <span>=</span> (widget <span>*</span>)malloc(<span>sizeof</span>(widget));</code></pre></div>
</div>
<p>
The return type would otherwise be <code>void *</code>, and can be implicitly convert to
a pointer to any type for which the resulting pointer is correctly aligned.
</p>
</li>
</ul>
</li>
<li>
<p>
<code>aligned_alloc</code>
</p>
<ul>
<li>
<p>
Has the following signature:
</p>
<div>
<div><pre><code data-lang="c">  <span>void</span> <span>*</span> <span>aligned_alloc</span>(size_t alignment, size_t size);</code></pre></div>
</div>
</li>
<li>
<p>
Typically used to request for memory with stricter-than-usual requirements
for memory alignment (i.e., larger power of 2 required than default).
</p>
</li>
</ul>
</li>
<li>
<p>
<code>calloc</code>
</p>
<ul>
<li>
<p>
Has the following signature:
</p>
<div>
<div><pre><code data-lang="c">  <span>void</span> <span>*</span><span>calloc</span>(size_t nmemb, size_t size);</code></pre></div>
</div>
</li>
<li>
<p>
Allocates <code>nmemb</code> objects, each with <code>size</code> bytes.
</p>
</li>
<li>
<p>
Initializes the memory to the zero-value for bytes; but note that this may
not correspond to the zero values expected of floating-point zero, null
pointer, etc.
</p>
</li>
</ul>
</li>
<li>
<p>
<code>realloc</code>
</p>
<ul>
<li>
<p>
Has the following signature:
</p>
<div>
<div><pre><code data-lang="c">  <span>void</span> <span>*</span><span>realloc</span>(<span>void</span> <span>*</span>ptr, size_t size);</code></pre></div>
</div>
</li>
<li>
<p>
Increases or decreases size of previously allocated memory.
</p>
</li>
<li>
<p>
If a call to <code>realloc</code> fails (i.e., a null pointer is returned), the memory
pointed to by <code>ptr</code> is not deallocated, and must be freed manually.
</p>
</li>
<li>
<p>
If a call to <code>realloc</code> succeeds, the pointer <code>ptr</code> should no longer be used.
</p>
</li>
<li>
<p>
Passing in 0 for <code>size</code> is undefined behavior.
</p>
</li>
</ul>
</li>
<li>
<p>
<code>reallocarray</code>
</p>
<ul>
<li>
<p>
Available in OpenBSD, is adopted in GNU libc.
</p>
</li>
<li>
<p>
Has the following signature:
</p>
<div>
<div><pre><code data-lang="c">  <span>void</span> <span>*</span><span>reallocarray</span>(<span>void</span> <span>*</span>ptr, size_t nmemb, size_t size);</code></pre></div>
</div>
</li>
<li>
<p>
Reallocates storage for an array, but also provides overflow checking on
array size calculations.
</p>
<ul>
<li>
<p>
In particular, checks for the overflow that might occur when obtaining
memory size from <code>nmemb * size</code>.
</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>
<code>free</code>
</p>
<ul>
<li>
<p>
Has the following signature:
</p>

</li>
<li>
<p>
Calling <code>free</code> on the same pointer twice is undefined behavior, and is a
security vulnerability.
</p>
</li>
<li>
<p>
It is good practice to set a pointer to <code>NULL</code> after calling <code>free</code> on it.
</p>
</li>
</ul>
</li>
</ul>
<h4 id="headline-40">
Flexible Array Members
</h4>
<ul>
<li>
<p>
A struct that defines at least one named member can additionally as its last
member an incomplete array type (i.e., an array type without the size filled
in).
</p>
<ul>
<li>
<p>
When the incomplete array is accessed, the struct behaves as if the array
member had the longest size that fits in the memory allocated for this object.
</p>
</li>
<li>
<p>
This incomplete array will generally have to be manually managed and will be
ignored by various operations (e.g., the <code>sizeof</code> operator does not include
the size of the incomplete array). For more details:
<a href="https://en.cppreference.com/w/c/language/struct">https://en.cppreference.com/w/c/language/struct</a>
</p>
</li>
</ul>
</li>
</ul>
<h4 id="headline-41">
Other Dynamically Allocated Storage
</h4>
<ul>
<li>
<p>
<code>alloca</code>
</p>
<ul>
<li>
<p>
Allows dynamic allocation on the stack; memory is automatically released when
the function that calls <code>alloca</code> returns.
</p>
</li>
<li>
<p>
Use of <code>alloca</code> is generally discouraged because of various reasons. For
example, the return value of <code>alloca</code> does not need to be freed (i.e.,
inconsistent with other memory allocation functions), and the compiler tends
to not inline functions with <code>alloca</code> calls.
</p>
</li>
</ul>
</li>
<li>
<p>
Variable-Length Arrays
</p>
<ul>
<li>
<p>
Can only be declared in block scope or function prototype scope.
</p>
<div>
<div><pre><code data-lang="c">  <span>void</span> <span>myFunc</span>(size_t s) {
    <span>char</span> myArr[s];
    <span>// do something with myArr
</span><span></span>  }</code></pre></div>
</div>
</li>
<li>
<p>
Such arrays are allocated in the stack frame, and released when the function
returns.
</p>
</li>
<li>
<p>
One use of variable-length array in function prototype scope is as follows:
</p>
<div>
<div><pre><code data-lang="c">  <span>int</span> <span>myMatrixFunc</span>(size_t rows, size_t cols, <span>int</span> matrix[rows][cols]) {
    <span>// manually allocate memory for matrix if required.
</span><span></span>
    <span>for</span> (<span>int</span> r <span>=</span> <span>0</span>; r <span>&lt;</span> rows; r<span>++</span>) {
      <span>for</span> (<span>int</span> c <span>=</span> <span>0</span>; c <span>&lt;</span> cols; c<span>++</span>) {
        <span>// Perform operations on each element of the matrix
</span><span></span>      }
    }
  }</code></pre></div>
</div>
</li>
</ul>
</li>
</ul>
<h4 id="headline-42">
Debugging Allocated Memory Problems
</h4>
<ul>
<li>
<p>
Dmalloc: <a href="https://dmalloc.com/">https://dmalloc.com/</a>
</p>
</li>
</ul>
<h3 id="headline-43">
Chapter 7 - Characters and Strings
</h3>
<h4 id="headline-44">
Basics
</h4>
<ul>
<li>
<p>
ASCII is 7-bits (i.e., 128 characters)
</p>
</li>
<li>
<p>
For Unicode, the characters represented by codepoints from U+0000 to U+007F are
identical to ASCII, and character represented by codepoints from U+0000 to
U+00FF are identical to ISO-8859-1 (Latin-1).
</p>
</li>
</ul>
<h4 id="headline-45">
Source and Execution Character Sets
</h4>
<ul>
<li>
<p>
Each implementation of C defines the <em>source character set</em> (used in source
files) and <em>execution character set</em> (used for character and string literals at
compile time).
</p>
</li>
</ul>
<h4 id="headline-46">
Data Types
</h4>
<ul>
<li>
<p>
<code>char</code> can safely represent any 7-bit character encoding (e.g.,
ASCII). However, when used to represent 8-bit encodings, problems might arise
if <code>char</code> is defined by the implementation to be a signed type (e.g., when the
character represented by 0xFF is sign-extended, it might become 0xFFFF FFFF
instead of 0x0000 00FF, the former is the representation used for EOF).
</p>
</li>
<li>
<p>
<code>int</code> should be used when representing EOF, or character data interpreted as
<code>unsigned char</code> then converted to <code>int</code>.
</p>
</li>
<li>
<p>
<code>wchar_t</code>
</p>
<ul>
<li>
<p>
Can be signed or unsigned, depending on implementation.
</p>
</li>
<li>
<p>
Writing portable code with <code>wchar_t</code> can be difficult because of the range of
implementation-defined behaviors.
</p>
</li>
</ul>
</li>
<li>
<p>
<code>char16_t</code> and <code>char32_t</code>
</p>
</li>
</ul>
<h4 id="headline-47">
String
</h4>
<ul>
<li>
<p>
C11 introduced (in Annex K) bounds-checking interface for string-handling, that
tend to be safer than the traditional functions in <code>&lt;string.h&gt;</code> and <code>&lt;wchar.h&gt;</code>.
</p>
<ul>
<li>
<p>
Some of the Annex K functions are: <code>strcpy_s</code>, <code>strcat_s</code>, <code>strncpy_s</code> and
<code>strncat_s</code>.
</p>
</li>
</ul>
</li>
</ul>
<h3 id="headline-48">
Chapter 8 - Input/Output
</h3>
<h3 id="headline-49">
Chapter 9 - Preprocessor
</h3>
<ul>
<li>
<p>
Command for generating translation units (i.e., after the preprocessing step)
using the common compilers:
</p>
<ul>
<li>
<p>
<code>clang [other-options] -E -o output_file.i source.c</code>
</p>
</li>
<li>
<p>
<code>gcc [other-options] -E -o output_file.i source.c</code>
</p>
</li>
<li>
<p>
Visual C++: <code>cl [other-options] /P /Fioutput_file.i source.c</code>
</p>
</li>
</ul>
</li>
<li>
<p>
Files included using angle brackets are searched on the <em>system include path</em>,
whereas files included using quotes are searched on the <em>quoted include path</em>.
</p>
</li>
<li>
<p>
When using conditional directives (i.e., <code>#if</code>, <code>elif</code>, etc.), it is possible
to throw error using the <code>#error</code> directive. This would be useful if for
example there are no implementation of a particular functionality on the target
architecture being built.
</p>
</li>
<li>
<p>
Run <code>clang/gcc -E -dM &lt;source-files&gt;</code> to get a list of compiler predefined macros.
</p>
</li>
</ul>
<h3 id="headline-50">
Chapter 10 - Program Structure
</h3>
<h4 id="headline-51">
Opaque Types
</h4>
<ul>
<li>
<p>
In C, <em>opaque</em> (or <em>private</em>) data types are expressed using an <em>incomplete
type</em>, such as a forward-declared structure type.
</p>
<ul>
<li>
<p>
An <em>incomplete type</em> describes the identifier, but does not provide enough
information to determine the size of the object and the layout. As such, all
functions in the public interface must accept a pointer to the type (instead
of the type directly).
</p>
</li>
</ul>
</li>
</ul>
<h4 id="headline-52">
Linkage
</h4>
<ul>
<li>
<p>
C programs can have 3 kinds of linkages: external, internal, and none.
</p>
</li>
<li>
<p>
When a declaration has <em>external</em> linkage, identifiers referring to that
declaration all refer to the same entity (e.g., function or object).
</p>
</li>
<li>
<p>
When a declaration has <em>internal</em> linkage, identifiers referring to that
declaration refer to the same entity only within the same translation unit
containing the declaration.
</p>
</li>
<li>
<p>
If a declaration has no linkage, it is a unique entity in each translation
unit.
</p>
</li>
<li>
<p>
The above might have been explained better by a StackOverflow response:
</p>
<blockquote>
<p>
in addition to type, variables have three other characteristics: linkage, scope
and lifetime. All four attributes are sort of orthogonal, but linked in the way
they are expressed in the language, and do interact in some ways.
</p>
<p>
With regards to linkage: linkage really affects the symbol which is being
declared, and not the object itself. If there is no linkage, all declarations
of the symbol bind to different objects, e.g.:
…
</p>
<p>
Generally speaking, local variables… and function arguments have no linkage,
regardless of type and lifetime.
…
</p>
<p>
Internal and external linkage are similar, in that repeated declarations of the
symbol bind to the same entity: internal linkage binds only within the
translation unit, external across the entire program. So given:
</p>
</blockquote>
<p>
<a href="https://stackoverflow.com/a/24866015/5821101">https://stackoverflow.com/a/24866015/5821101</a>
</p>
</li>
<li>
<p>
Examples of linkages:
</p>
<div>
<div><pre><code data-lang="c">  <span>// foo.c
</span><span></span>
  <span>void</span> <span>func</span>(<span>int</span> i) { <span>// Implicit external linkage
</span><span></span>    <span>// i has no linkage
</span><span></span>  }
  <span>static</span> <span>void</span> <span>bar</span>(<span>void</span>); <span>// Internal linkage, different bar the one in bar.c
</span><span></span>  <span>extern</span> <span>void</span> <span>bar</span>(<span>void</span>) {
    <span>// bar still has internal linkage because the initial declaration was declared
</span><span></span>    <span>// as static; the extern specifier has no effect in this case.
</span><span></span>  }

  <span>// bar.c
</span><span></span>
  <span>extern</span> <span>void</span> <span>func</span>(<span>int</span> i); <span>// Explicit external linkage
</span><span></span>
  <span>static</span> <span>void</span> <span>bar</span>(<span>void</span>) { <span>// Internal linkage; different bar from the one in foo.c
</span><span></span>    func(<span>12</span>); <span>// Calls func from foo.c
</span><span></span>  }
  <span>int</span> i; <span>// External linkage; does not conflict with i from foo.c or bar.c
</span><span></span>  <span>void</span> <span>baz</span>(<span>int</span> k) { <span>// Implicit external linkage
</span><span></span>    bar(); <span>// Calls bar from bar.c, not foo.c
</span><span></span>  }</code></pre></div>
</div>
</li>
<li>
<p>
Given the above, file scope entities that doesn&#39;t need to be visible from
outside the file should be declared <code>static</code> to avoid polluting the global
namespace.
</p>
</li>
</ul>
<h3 id="headline-53">
Chapter 11 - Debugging, Testing, and Analysis
</h3>
<h4 id="headline-54">
Assertions
</h4>
<h5 id="headline-55">
Static Assertions
</h5>
<ul>
<li>
<p>
C supports <code>static_assert</code> macro for assertion evaluated during compile time:
</p>
<div>
<div><pre><code data-lang="c">  static_assert(integer<span>-</span>constant<span>-</span>expression, error<span>-</span>message<span>-</span>string<span>-</span>literal);</code></pre></div>
</div>
</li>
<li>
<p>
Three examples of using static asserts:
</p>
<ol>
<li>
<p>
Verify the lack of padding bytes:
</p>
<div>
<div><pre><code data-lang="c">  <span>#include</span> <span>&lt;assert.h&gt;</span><span>
</span><span></span>
  <span>struct</span> packed {
    <span>unsigned</span> <span>int</span> i;
    <span>char</span> <span>*</span>p;
  };

  static_assert(
    <span>sizeof</span>(<span>struct</span> packed) <span>==</span> <span>sizeof</span>(<span>unsigned</span> <span>int</span>) <span>+</span> <span>sizeof</span>(<span>char</span> <span>*</span>),
    <span>&#34;struct packed must not have any padding&#34;</span>
  );</code></pre></div>
</div>
</li>
<li>
<p>
Verify that <code>unsigned char</code> and <code>int</code> has different range (although allowed
by C standard), so that there will not be false positives when checking for
EOF while reading input:
</p>
<div>
<div><pre><code data-lang="c">  <span>#include</span> <span>&lt;assert.h&gt;</span><span>
</span><span></span>  <span>#include</span> <span>&lt;stdio.h&gt;</span><span>
</span><span></span>  <span>#include</span> <span>&lt;limit.h&gt;</span><span>
</span><span></span>
  <span>void</span> <span>clear_stdin</span>() {
    <span>int</span> c;

    <span>do</span> {
      c <span>=</span> getchar();
      static_assert(UCHAR_MAX <span>&lt;</span> UINT_MAX, <span>&#34;FIO34-C Violation&#34;</span>);
    } <span>while</span> (c <span>!=</span> EOF);
  }</code></pre></div>
</div>
</li>
<li>
<p>
Compile-time bounds-checking:
</p>
<div>
<div><pre><code data-lang="c">  <span>static</span> <span>const</span> <span>char</span> prefix[] <span>=</span> <span>&#34;Error No: &#34;</span>;
  <span>#define arraysize 14
</span><span></span>  <span>char</span> str[arraysize];

  <span>// Ensure that str has sufficient space to store at least one additional
</span><span></span>  <span>// character for error code
</span><span></span>  static_assert(<span>sizeof</span>(str) <span>&gt;</span> <span>sizeof</span>(prefix),
                <span>&#34;str must be larger than prefix&#34;</span>);
  strcpy(str, prefix);</code></pre></div>
</div>
</li>
</ol>
</li>
</ul>
<h5 id="headline-56">
Runtime Assertions
</h5>
<ul>
<li>
<p>
C supports <code>assert</code> macro for assertion evaluated during runtime time:
</p>
<div>
<div><pre><code data-lang="c">  <span>#define assert(scalar-expression) </span><span>/* implementation-defined */</span></code></pre></div>
</div>
</li>
<li>
<p>
Runtime assertions are typically used only during development and test phases,
and are disabled for production builds. As such, avoid using it to check for
conditions that may fail during normal operations, like:
</p>
<ul>
<li>
<p>
Invalid input
</p>
</li>
<li>
<p>
Error opening, reading, or writing streams
</p>
</li>
<li>
<p>
Out-of-memory conditions from dynamic allocation functions
</p>
</li>
<li>
<p>
System call errors
</p>
</li>
<li>
<p>
Invalid permissions
</p>
</li>
</ul>
</li>
</ul>
<h4 id="headline-57">
Compiler Settings and Flags
</h4>
<ul>
<li>
<p>
Distinct phases of software development calls for different sets of build flags:
</p>
<ul>
<li>
<p>
<strong>Analysis</strong> - Generally enable maximum diagnostics to catch bugs before the
later phases.
</p>
</li>
<li>
<p>
<strong>Debugging</strong> - Generally enable debugging information.
</p>
</li>
<li>
<p>
<strong>Testing</strong> - Disable the most verbose debugging information, keeping only
symbol names for cleaner stack traces. Also start testing optimized builds.
</p>
</li>
<li>
<p>
<strong>Acceptance Testing / Deployment</strong>
</p>
</li>
</ul>
</li>
</ul>
<h2 id="headline-58">
To Internalize <em>Now</em>
</h2>
<ul>
<li>
<p>
N.A.
</p>
</li>
</ul>
<h2 id="headline-59">
To Learn/Do Soon
</h2>
<ul>
<li>
<p>
N.A.
</p>
</li>
</ul>
<h2 id="headline-60">
To Revisit When Necessary
</h2>
<h3 id="headline-61">
Chapter 7 - Characters and Strings
</h3>
<ul>
<li>
<p>
See the <strong>Windows</strong> section for some elaboration on how character encodings are
converted at various points when executing a program (e.g., conversion of
command-line arguments to appropriate encoding for the main function,
conversion prior to sending output for display on console, etc.)
</p>
</li>
<li>
<p>
See the <strong>Character Conversion</strong> section for some elaboration and C standard
library functions for converting between narrow and wide character types.
</p>
</li>
<li>
<p>
See the <strong>String</strong> section for some elaboration on the string-handling libraries
available.
</p>
</li>
</ul>
<h3 id="headline-62">
Chapter 8 - Input/Output
</h3>
<ul>
<li>
<p>
Refer to this section (or not) for various I/O-related functions, including:
</p>
<ul>
<li>
<p>
Opening and Creating Files
</p>
</li>
<li>
<p>
Closing Files
</p>
</li>
<li>
<p>
Reading and Writing Characters and Lines
</p>
</li>
<li>
<p>
Stream Flushing
</p>
</li>
<li>
<p>
Setting the Position in a File
</p>
</li>
<li>
<p>
Removing and Renaming File
</p>
</li>
<li>
<p>
Using Temporary Files
</p>
</li>
<li>
<p>
Reading Formatted Text Streams
</p>
</li>
<li>
<p>
Reading from and Writing to Binary Streams
</p>
</li>
</ul>
</li>
</ul>
<h3 id="headline-63">
Chapter 9 - Preprocessor
</h3>
<ul>
<li>
<p>
Refer to the section on <strong>Type-Generic Macros</strong> for an example of how C might
implement simple function overloading like in C++ and Java using generic
selection expression macro.
</p>
</li>
</ul>
<h3 id="headline-64">
Chapter 10 - Program Structure
</h3>
<ul>
<li>
<p>
Refer to the section on <strong>Structuring a Simple Program</strong> for an example of a
simple program that is more than just a hello world, and involves:
</p>
<ul>
<li>
<p>
Handling command-line arguments (including allocating memory)
</p>
</li>
<li>
<p>
Converting command-line arguments from string to integer type (including
error handling)
</p>
</li>
<li>
<p>
Implementing the Miller-Rabin test for prime numbers
</p>
</li>
<li>
<p>
Splitting code into source files into &#34;library&#34; and &#34;driver&#34; code
</p>
</li>
<li>
<p>
Using the <code>ar</code> command to generate static library (AKA archive) file
</p>
<ul>
<li>
<p>
Note: by convention, static libraries on Linux have the prefix <code>lib</code> and
the extension <code>.a</code>, but when passing them as argument to the linker, the
prefix and extension can be excluded, which is why we link to the <code>libm</code>
library using <code>-lm</code> argument to the compiler/linker.
</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="headline-65">
Chapter 11 - Debugging, Testing, and Analysis
</h3>
<ul>
<li>
<p>
Refer to this chapter for some common compiler settings and flags that are
useful during different stages of development.
</p>
</li>
</ul>
<h2 id="headline-66">
Other Resources Referred To
</h2>
<ul>
<li>
<p>
CERT C Coding Standard: 98 Rules for Developing Safe, Reliable, and Secure
Systems
</p>
<ul>
<li>
<p>
Contains examples of common C programming mistakes and how to correct them.
</p>
</li>
</ul>
</li>
<li>
<p>
<a href="https://www.nccgroup.trust/us/our-services/cyber-security/security-training/secure-coding/">Training classes offered through NCC Group</a> 
</p>
</li>
</ul>

    </div></div>
  </body>
</html>
