<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://nickb.website/blog/virtualizing-ios-on-apple-silicon">Original</a>
    <h1>Virtualizing iOS on Apple Silicon</h1>
    
    <div id="readability-page-1" class="page"><div aria-label="Content"><div><article itemscope="" itemtype="http://schema.org/BlogPosting"><div itemprop="articleBody"><p>In this blog post, I explore how I achieved virtualizing iOS on Apple silicon Macs, exploring many internals along the way.</p><picture><source srcset="/assets/img/vma2-ios.avif" type="image/avif"/><source srcset="/assets/img/vma2-ios.webp" type="image/webp"/><img src="https://nickb.website/assets/img/vma2-ios.png"/></picture><h2 id="part-0-uncharted-waters">Part 0: Uncharted Waters?</h2><p>One large project I‚Äôve spent large amounts of time working on was <a href="https://nickb.website/projects/vma2pwn">vma2pwn</a>, a project that can create a fully modifiable vma2 macOS boot-chain for macOS guest virtual machines. This was actually a preliminary project to this one‚Äîin other words, figuring out how to walk before learning how to run. With recent developments such as the Mac transition to Apple silicon and Mac Catalyst, the iOS and macOS operating systems were brought much closer together than they ever have been before; with the introduction of macOS virtualization on Apple silicon Macs, this begged the question: <strong>could iOS (and the macOS boot-chain) be modified in such a way to virtualize it as well?</strong></p><p>iOS on macOS? These are rather uncharted waters. vma2ios exists, but has not been (intentionally) publicized. Additionally, the macOS version of XNU and iBoot differs enough to require difficult modifications that result in only a partially-working solution.</p><h3 id="relevant-prior-research">Relevant Prior Research</h3><p>I am not the first to embark on the topic on iOS virtualization/emulation. Here are some notable projects and companies that have approached this subject already that you may be interested in reading up on:</p><ul><li>Corellium and their virtual iPhone cloud product (only publicly-available ‚Äúcomplete‚Äù solution)</li><li>qemu-t8030<ul><li>Helpful tools, code, and applicable modifications to iOS which proved insightful</li></ul></li><li>Other QEMU</li><li><a href="https://worthdoingbadly.com/macappsios/">Zhuowei Zhang‚Äôs blog</a><ul><li>Outside of their previous blog posts on emulating iOS on QEMU, this article also proved briefly helpful when I learned about the relationship between macOS‚Äôs <code>IOSurfaceRoot</code> and iOS‚Äôs <code>IOCoreSurfaceRoot</code> when exploring necessary kernel patches. Zhuowei concluded that (GUI) macOS applications cannot run on iOS‚Äîbut (graphical) iOS apps can run on macOS. Mac Catalyst seems to work, expectedly, only one way. Luckily, this holds true not just for iOS apps, but the majority of iOS‚Äôs graphical systems.</li></ul></li><li>Others</li></ul><h2 id="part-i-getting-started--a-new-discovery">Part I: Getting Started + a New Discovery</h2><p>As I was drafting this (overdue) article, I discovered a useful-yet-infuriating feature in Apple‚Äôs Virtualization stack‚Äîthe ability to sign arbitrary data for the virtual machine. As mentioned, I created the vma2pwn project for the purpose of patching the vma2 stack to allow for a chain of modified firmware; however, this proved to be largely pointless.</p><p>Apple‚Äôs Virtualization.framework has an undocumented private function: <code>_setProductionModeEnabled(false)</code>. This useful call (and it‚Äôs VM configuration equivalent) demotes the VM to a Chip Fuse Mode (CPFM) of <code>01</code>, which configures the virtual device as ‚Äúsecure‚Äù and ‚Äúnon-production.‚Äù With physical hardware devices, Apple‚Äôs Tatsu Signing Server (TSS), reponsible for providing SHSH blobs required for firmware installation, refuses to sign firmware for any non-production/non-secure device (CPFM of <code>00</code> or <code>01</code>). However, TSS <em>does</em> sign firmware for the public vma2 device‚Äî<strong>any</strong> firmware provided, in fact! Now I don‚Äôt have to feel bad about only supporting 12.0.1 in vma2pwn‚Ä¶</p><p>Now, to get started, a strategy for approaching the daunting task of running iOS on vma2 is needed. I found the most success with reusing a fully macOS 12.0.1 bootchain and simply replacing the system (OS) image, along with its associated <code>mtree</code>, <code>root_hash</code>, and <code>trustcache</code> files, with that of the iOS 15.0.2‚Äôs (iPhone XR build). This would largely bypass the need for (almost) any modifications before iOS initializes, such as to the bootchain and ramdisk (restore process). The XR build was chosen for its arm64e capability and lower-resolution (if that mattered). You should see success with other arm64e device configurations, but do note that the vma2 kernel is hardcoded to return <code>&#34;iPad8,6&#34;</code> for some sysctl key. arm64 versions experienced additional issues and binary incompatibilities, so there is no point in trying these builds.</p><p>I used my own fork of tart (a third-party application for managing Apple silicon virtual machines), <a href="https://github.com/nick-botticelli/super-tart">super-tart</a> for running the iOS VM, which allows for using the required undocumented features provided by Virtualization.framework. I have not yet pushed all of my changes, such as for setting <code>_setProductionModeEnabled(false)</code>. Do note that such Virtualization.framework tools that use private APIs require SIP to be turned off, and maybe AMFI as well. I also use <a href="https://github.com/nick-botticelli/idevicerestore">my own fork of idevicerestore</a>.</p><h2 id="part-ii-patch-purgatory">Part II: Patch Purgatory</h2><p>Welcome to Patch Purgatory, where you pay with time and leave with regret. This section attempts to review the patches I made to get to the point of booting iOS <em>enough</em>, as shown in the demo at the end. These are not necessarily in chronological order.</p><h3 id="kernel-patches">Kernel Patches</h3><p>The first patches one needs are potentially the ones I did for vma2pwn, but I am not sure if any are necessarily needed if using the CPFM 01 trick detailed above. These include patches to <code>_apfs_extract_root_hash_arm</code>, <code>_authenticate_root_hash</code>, <code>__img4_firmware_property_callback</code>, <code>_is_root_hash_authentication_required</code>, and <code>_img4_firmware_evaluate</code> to return 0 in the vma2 kernel. Additionally, <code>lookup_in_static_trust_cache</code> needs to be patched to return 1. These are your run-of-the-mill signature patches and won‚Äôt be further detailed.</p><p>So, with our sigcheck-patched kernel, we try to boot iOS from a fresh restore and run into an expected problem: our executables are terminated with <code>EXEC, [0xe] Binary with wrong platform</code>, since these are not simulator platform binaries! This is an easy fix, <a href="https://github.com/apple-oss-distributions/xnu/blob/xnu-10063.101.15/bsd/kern/kern_exec.c#L7660">patching this line in XNU</a> to skip the <code>PLATFORM_IOS</code> check. This can be done in the vma2 kernel by patching the <code>B.NE</code> to <code>B</code> as shown here:</p><picture><source srcset="/assets/img/vma2-ios-platform-patch.avif" type="image/avif"/><source srcset="/assets/img/vma2-ios-platform-patch.webp" type="image/webp"/><img src="https://nickb.website/assets/img/vma2-ios-platform-patch.png" loading="lazy"/></picture><p>Now our modded kernel will launch iOS binaries without issue.</p><p>An issue one might encounter is related to the system keybag, of which there are incompatibilities down the rabbit hole‚Äîthis is Patch Purgatory, after all. This is what causes PreBoard.app to ask the user to ‚ÄúSwipe up to upgrade.‚Äù instead of showing Setup.app (normal setup); the iOS system and macOS kernel just aren‚Äôt very compatible in regards to keybags, unfortunately. I have yet to overcome this limitation, other than making two patches to <code>ipc_make_system_keybag</code> to force the function to <em>not</em> return an error, which at least gets us to PreBoard.app.</p><p>Another kernel issue I encountered is the size mismatch between the IOMFB struct passed between iOS system frameworks and the macOS kernel. This causes a kernel panic with the string <code>CLCDTransaction size mismatch. Returning error 0x%X.</code>. I thought this was going to be a dead-end, but to my surprise, patching out the size check in <code>IOMobileFramebufferUserClient::swap_submit</code> stopped it from panicking! This concludes the kernel patches.</p><h3 id="system-patches-preface">System Patches Preface</h3><p>In the following section, I detail the patches needed for non-kernel components in the restore ramdisk (a ramdisk sent by the host to the virtual device that is essentially a stripped-down iOS that is used to carry out the restore process), as well as iOS system files. These files are signed, and will be killed if ran if patching them without re-signing. In our modified environment, I suggest using Procursus‚Äôs <code>ldid</code> (<code>brew install ldid-procursus</code>) and re-signing with <code>ldid_macosx_arm64 -S -M &lt;binary&gt;</code>; the <code>-S</code> parameter pseudo-signs the binary, and the <code>-M</code> parameter preserves the existing entitlements in this context. Note that many binaries have an identity that is checked and will need to be renamed before being re-signed, then renamed back. For example, to re-sign <code>keybagd</code>, one needs to find the proper Identity with <code>codesign -d -v keybagd</code>, which tells us <code>Identifier=com.apple.keybagd</code>, and rename it to this identity (<code>mv keybagd com.apple.keybagd</code>), then re-signing with ldid (<code>ldid_macosx_arm64 -S -M com.apple.keybagd</code>), and finally renaming it back (<code>mv com.apple.keybagd keybagd</code>).</p><p>Additionally, to find the named functions to patch if they are not symbolicated automatically, search for the string XRef using your disassembler of choice and trace the caller function via the logging call reference.</p><p>You may also want to port over Bash and add a LaunchDaemon in order to get an interactable shell through the serial terminal. This can be done by simply copying the relevant files from a version-compatible iOS jailbreak payload such as with Procursus.</p><h3 id="system-patches">System Patches</h3><p>In order to patch the system (or the restore ramdisk), one needs to directly modify the DMG volume. This can be done first by converting the iOS System volume (included in the desired version‚Äôs IPSW) to a read-and-writable version with, for iOS 15.0.2, for example, <code>hdiutil convert -format UDRW -o 018-66258-074-rw.dmg 018-66258-074.dmg</code> (if I remember correctly). Now, once it is first initially mounted (e.g., by double-clicking on it), mount it as properly writable again with, for example, <code>sudo mount -uw /Volumes/Sky19A404.N104N841OS</code>. Now, while using sudo through the Terminal, update the files as desired (like the ones modified as follows). Once finished, this R/W DMG can be converted back to a usable version for your restore tool by first running <code>hdiutil convert -format ULFO -o 018-66258-074.dmg 018-66258-074-rw.dmg</code>, and then running <code>asr imagescan --source 018-66258-074.dmg</code>. You may want to keep the R/W version around for quick-turnaround modification.</p><p>Before iOS boots, the restore ramdisk needs a little fixing up‚Äîspecifically, <code>/usr/local/bin/restored_external</code>. This is due to the fact that the iOS version of <code>restored_external</code> attempts to create the system keybag with <code>MKBKeyBagCreateSystem</code>, but this is not compatible with our macOS kernel, so the error check can easily be patched out. Another patch needed is to skip root hash authentication, by patching the conditional that calls the <code>ramrod_set_NVRAM_variable</code> function to set <code>allow-root-hash-mismatch</code> to true (<code>1</code>).</p><p>Another ramdisk modification needed is to <code>/usr/sbin/asr</code>. One should be able to easily patch this with <a href="https://github.com/iSuns9/asr64_patcher">iSuns9‚Äôs version of <code>asr64_patcher</code></a>. Specifically, one needs to find the function that prints the string <code>&#34;Image failed signature verification.&#34;</code>, then find the function which references this function, then patch the <code>BL</code> ARMv8-A call there with a <code>B</code> jump down to where the string <code>&#34;Image passed signature verification&#34;</code> is referenced (placed in <code>X0</code> before calling <code>_warnx</code>). In the <code>asr</code> binary from 15.0.2, this would be patched with <code>b #0x7c</code> at file offset 0x27A18.</p><p>Now, the iOS system itself needs fixing up to become compatible with the macOS kernel. The main change is to move most files stored on the system volume that will be installed in the root of the filesystem into <code>/System/Library/Templates/Data</code>. These will be present in <code>/</code> once the system boots. Do note that empty folders in the normal root in the system volume may still need to exist, even though empty (e.g., <code>/Applications</code>), though I have not done enough testing surrounding this.</p><p>Very early in the iOS boot process, <code>/sbin/launchd</code> runs to initialize early boot processes. Patches are needed to allow it to run without failing. The first patches are to the embedded configuration plist, which can be found in the binary by searching for the string <code>&lt;key&gt;SIGTERMTimeout&lt;/key&gt;</code> and looking back about 172 bytes. The first of these patches which may be required is adding <code>&lt;key&gt;PerformAfterUserspaceReboot&lt;/key&gt;&lt;true/&gt;</code> to the embedded configuration plist sections <code>mount-phase-2</code>, <code>fips</code>, <code>tzinit</code>, <code>finish-demo-restore</code>, <code>fud</code>, <code>xpcroleaccountd</code>, <code>prng_seedctl</code>, and <code>MSUEarlyBootTask</code> in order to get closer to the macOS version of <code>launchd</code> functionality. Additionally, in the <code>data-protection</code> section, <code>RequireSuccess</code> can be changed to <code>&lt;false/&gt;</code>. This is needed due to the iOS version of <code>/usr/libexec/init_data_protection</code> (symlinked to <code>/usr/libexec/seputil</code>) failing due to running in a virtual machine. These modifications to the embedded configuration plist will likely not fit under the existing size of the string; luckily, one can easily work around this by using an XML minimizer and pasting this minimized XML over the old one, then overwriting the rest of the string with some XML-friendly whitespace (e.g., hex <code>0x20</code> for space characters).</p><h4 id="a-keybagd-aside">A keybagd Aside</h4><p>Another responsibility of <code>launchd</code> is to initialize <code>/usr/libexec/keybagd</code>; this binary will fail due to the aforementioned kernel differences. This problem can be hacked around in various ways; one way is by compiling a simple executable to simply exit with a return code of 0 to replace <code>keybagd</code> with. I explored the possibility of resolving these system keybag differences; the <a href="https://github.com/NyanSatan/fixkeybag">fixkeybag project</a> by NyanSatan was a point of interest for this. However, the code to generate a system keybag in this application designed for enabling iOS dual-boots simply calls <code>MKBKeyBagCreateSystem</code>, just like the failing code in the restore ramdisk binary <code>restored_external</code>. This would still fail in the booted iOS state, as well.</p><p>One additional patch to <code>launchd</code> is needed; a <code>NOP</code> patch to the conditional branch (<code>TBZ</code>) that results in the error <code>Userspace reboot changed system version: previous %s != current %s</code> being printed as a panic string.</p><p>After launchd, we quickly run into an expected issue, related to the disk volumes. Because we are using a macOS bootchain, including a macOS ramdisk for the restore process, the <code>/sbin/mount</code> binary on iOS has no idea how to manage the APFS volumes created. Fortunately, this is once again an easy fix: simply replace the binary with the one from the macOS system volume after modifying its Mach-O metadata to run on iOS. I did this manually, but you can use <code>vtool</code> which is included in macOS, as well.</p><p>Now, a difficult modification is needed‚Äîa patch to the DYLD shared cache. Like the previously mentioned, <code>IOSurfaceRoot</code> in macOS and <code>IOCoreSurfaceRoot</code> on iOS are basically the same driver, but are incompatible with their different names. Luckily, because the DYLD shared cache (DSC) for iOS uses the longer of the two strings, it is trivial to patch it to match the macOS‚Äôs vma2 kernel driver name from <code>&#34;IOCoreSurfaceRoot&#34;</code> to <code>&#34;IOSurfaceRoot&#34;</code>, filling in the rest of the remnants of the old string with zeroes (0x00). In order to do this, I suggest installing the <a href="https://github.com/blacktop/ipsw"><code>ipsw</code> tool created by blacktop</a>. Using this, one can extract the embedded dylibs for easy modification (good luck analyzing a full DSC in IDA!) with <code>ipsw dyld split &lt;dsc file&gt;</code>. Then, you can find the <code>/System/Library/Frameworks/IOSurface.framework/IOSurface</code> binary that requires these modifications (without telling you, you should find an error pointing here anyway). The virtual addresses should be preserved if you use a decent DSC extractor and disassembler combo; then, it is trivial to find the reference to the string <code>&#34;IOCoreSurfaceRoot&#34;</code>, in the <code>__iosConnectInitalize</code> function. If you are curious, you can see that it calls an unknown function at the address 0x1A38D5F58; some functions of <code>ipsw</code> error out in my experience, but <code>ipsw dyld dump</code> always works. Using this command, one can see it pointing to some data in <code>/System/Library/PrivateFrameworks/ktrace.framework/ktrace</code>. When disassembling this binary at the same address, one can see that it is, unsurprisingly, the function <code>IOServiceNameMatching</code>; this isn‚Äôt actually important, however. Moving on, you can use the <code>ipsw dyld a2o</code> command to convert the original virtual address (of the modified string <code>&#34;IOSurfaceRoot&#34;</code>) into the file offset to patch the DYLD shared cache file itself (in this case, 0x28fde373 in <code>dyld_shared_cache_arm64e</code>). After this modification, there is some cdhash thing in another part of the DSC that will no longer be valid, which will produce an exception when you restore this modified system. I don‚Äôt understand it much, but I found that one way to get through this issue is to set a breakpoint in the kernel (can be done through the GDB stub provided by a Virtualization.framework frontend like super-tart) in the <code>cs_validate_hash</code> function, specifically at the end of the function that contains the string <code>&#34;CODE SIGNING: cs_validate_page: mobj %p off 0x%llx size 0x%lx: actual [0x%x 0x%x 0x%x 0x%x 0x%x] != expected [0x%x 0x%x 0x%x 0x%x 0x%x]\n&#34;</code>. Unfortunately, despite the proper boot-args, this <code>printf</code> call only prints <em>a truncated version</em> (also with flipped endianness) of the new and old cdhashes, so this breakpoint is needed to find the complete cdhashes. You can then look at the entire old cdhash and search for it using a hex editor in the DSC. In this case, for 15.0.2, it can be found at the file offset 0x5a9cffc0, and the bytes <code>16D6BA49 065E212B ECC422B4 C0965F3B 2D8B70CA 48E0EE18 11E50A10 807D1BD5</code> should be patched to the new cdhash (depending on the exact patch you made), which should be <code>A44E9EEA 2A6185E0 E3E5FB90 5F51055A FBF55912 2081A217 039AF2DB D09FC715</code> if you followed my patch instructions exactly. Now, iOS should have no problems with our modified DSC.</p><p>One harmless crash we come across is <code>watchdogd</code>; this crashes because it lacks the code path that exists in the macOS version that checks if it is running in a VM, then gracefully exits. This just means that <code>watchdogd</code> will crash-loop. Disregard.</p><p>In <code>backboardd</code>, I experimented with patching calls that may trigger <code>PreBoard.app</code>, such as data migration. I didn‚Äôt realize any difference with this other than getting stuck on the Apple logo.</p><p>In <code>lockdownd</code>, specifically in the <code>get_device_type_internal_block_invoke</code> function (can be found by the log string xref), the <code>getMGInt</code> call (ditto) for <code>&#34;ShouldHactivate&#34;</code> should be patched with <code>mov x0, #1</code> to force <code>lockdownd</code> to ‚Äúhactivate‚Äù (bypass normal iOS activation restrictions in development environments).</p><p>Like previously, <code>mobileactivationd</code> can be patched to allow for hactivation, as well. The <code>shouldHactivate</code> function should be patched with the ARMv8-A instructions <code>mov x0, #0</code> and then <code>ret</code>.</p><p>Any additional modifications that may be needed to the vma2 device tree is left as an exercise to the reader. üôÇ</p><p>This sums up most, but probably not all of the specific modifications needed to get a similar setup up and running. You may need to do weird things like <code>chmod -R 777 /</code> to try and get some things working.</p><h2 id="part-iii-the-future">Part III: The Future</h2><p>Getting past the system keybag issues requires many more patches and an understanding of the system as it exists in the iOS system and kernel that I currently lack. This project has already taken at least a few hundred hours of exploration, and I‚Äôd be curious to see if anyone can take it further than just booting to <code>PreBoard.app</code>.</p><p>I have also not yet discovered if touch functionality is functional through the public vma2 Mac kernel and firmware. However, in the case that it does, <code>Virtualization.framework</code> provides undocumented API functions for this, such as the <code>_VZAppleTouchScreenConfiguration</code> and <code>_VZUSBTouchScreenConfiguration</code> devices. These can then be used with the <code>_VZTouch</code> and <code>_VZMultiTouchEvent</code> objects to sned touches. I have not fully figured out the exact parameter usage, but some example code that should be fairly close to the correct implementation can be found below. Note the <code>TouchPhase</code> enum which is just a simple enum that implements the same named values as <code>NSTouch.Phase</code>. This may sometimes generate an exception, and I have no idea if the coordinate values are mapped correctly to what the VM expects, if it can even handle it. See the example implementation below.</p><picture><source srcset="/assets/img/vma2-vztouch-code.avif" type="image/avif"/><img src="https://nickb.website/assets/img/vma2-vztouch-code.jpg" loading="lazy"/></picture><p>If anyone would like further guidance or access to the numerous files involved with this project (my setup is a bit unsightly), please do not hesitate to contact me!</p><h2 id="demo">Demo</h2><p>For the final conclusion of this blog post, enjoy this video demo (with a half-minute waiting period clipped out) showing off the boot sequence.</p><p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="" frameborder="0" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube-nocookie.com/embed/hS-h1gRd3hc" title="YouTube video player"></iframe></p><p>* By playing the video, you are agreeing to YouTube‚Äôs Terms of Service.</p></div></article></div></div></div>
  </body>
</html>
