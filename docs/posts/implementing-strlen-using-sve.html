<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lemire.me/blog/2022/12/19/implementing-strlen-using-sve/">Original</a>
    <h1>Implementing ‘strlen’ using SVE</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>In C, the length of a string in marked by a 0 byte at the end of the string. Thus to determine the length of the string, one must scan it, looking for the 0 byte. Recent ARM processors have a powerful instruction set (SVE) that is well suited for such problems. It allows you to load large registers at once and to do wide comparisons (comparing many bytes at once).</p>
<p>Yet we do not want to read too much data. If you read beyond the string, you could hit another memory page and trigger a segmentation fault. This could crash your program.</p>
<p>Thankfully, SVE comes with a load instruction that would only fault on the ‘first active element’: as long as the first element you are loading is valid, then there is no fault.</p>
<p>With this in mind, a simple algorithm to compute the length of a C string is as follows:</p>
<ol>
<li>Load a register.</li>
<li>Compare each byte in it to 0.</li>
<li>If any comparison matches, then locate the match and return the corresponding length.</li>
<li>If not, increment by the register size (given by svcntb()), and repeat.</li>
</ol>
<p>Using intrinsics, the code looks as follows…</p>
<pre>size_t sve_strlen<span>(</span><span>const</span> <span>char</span> <span>*</span>s<span>)</span> <span>{</span>
  size_t len <span>=</span> <span>0</span><span>;</span>
  <span>while</span> <span>(</span><span>true</span><span>)</span> <span>{</span>
    svuint8_t input <span>=</span> svldff1_u8<span>(</span>svptrue_b8<span>(</span><span>)</span><span>,</span> <span>(</span><span>const</span> uint8_t <span>*</span><span>)</span>s <span>+</span> len<span>)</span><span>;</span>
    svbool_t matches <span>=</span> svcmpeq_n_u8<span>(</span>svptrue_b8<span>(</span><span>)</span><span>,</span> input<span>,</span> <span>0</span><span>)</span><span>;</span>
    <span>if</span> <span>(</span>svptest_any<span>(</span>svptrue_b8<span>(</span><span>)</span><span>,</span> matches<span>)</span><span>)</span> <span>{</span>
      <span>return</span> len <span>+</span> svlastb_u8<span>(</span>svbrka_z<span>(</span>matches<span>,</span> matches<span>)</span><span>,</span> svindex_u8<span>(</span><span>0</span><span>,</span> <span>1</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
    len <span>+</span><span>=</span> svcntb<span>(</span><span>)</span><span>;</span>
  <span>}</span>
<span>}</span>
</pre>
<p>In assembly, the code looks as follows…</p>
<pre>mainloop<span>:</span>
        ldff1b  <span>{</span> z0<span>.</span>b <span>}</span><span>,</span> p0<span>/</span>z<span>,</span> <span>[</span>x10<span>,</span> x8<span>]</span>
        add     x8<span>,</span> x8<span>,</span> x9
        cmpeq   p1<span>.</span>b<span>,</span> p0<span>/</span>z<span>,</span> z0<span>.</span>b<span>,</span> #<span>0</span>
        b<span>.</span>eq    <span>.</span>mainloop
</pre>
<p>I do not discuss the details of my function, but it assumes implicitly that the underlying register size is no larger than 256. I would recommend adding a check that svcntb() is no larger than 256 before using this function in a real system.</p>
<p>Benchmarking against your system’s strlen function is difficult methodologically. Nevertheless, we can measure the number of instructions retired for sizeable strings as an indication of the relative speed. Using GCC 11 on a graviton 3 system (Amazon), I get the following metrics:</p>
<table>
<tbody>
<tr>
<td>system’s strlen</td>
<td>0.23 instructions per byte</td>
</tr>
<tr>
<td>SVE</td>
<td>0.15 instructions per byte</td>
</tr>
</tbody>
</table>
<p>Though I do not advocate adopting SVE as a replacement for strlen at this time, the potential is interesting, considering that I threw together my implementation in minutes.</p>
<p><a href="https://github.com/lemire/Code-used-on-Daniel-Lemire-s-blog/tree/master/2022/12/19">My source code is available</a>.</p>
<p><strong>Credit</strong>: Thanks to Denis Yaroshevskiy for inviting me to look at non-faulting loads.</p>
<p><strong>Update</strong>: It turns out that strlen was one of the examples that ARM used in its slides presenting SVE. At a glance, <a href="https://www.stonybrook.edu/commcms/ookami/support/_docs/5%20-%20Advanced%20SVE.pdf">their implementation looks like mine</a> but with more sophistication.</p>
</div></div>
  </body>
</html>
