<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://guix.gnu.org/en/blog/2024/identifying-software/">Original</a>
    <h1>Identifying Software</h1>
    
    <div id="readability-page-1" class="page"><div><article class="page" lang="en"><h2>Identifying software</h2><p lang="en">Ludovic Courtès, Maxim Cournoyer, Jan Nieuwenhuizen, Simon Tournier — March  4, 2024</p><p>What does it take to “identify software”?  How can we tell what software
is running on a machine to determine, for example, what security
vulnerabilities might affect it?</p><p>In October 2023, the US Cybersecurity and Infrastructure Security Agency
(CISA) published a white paper entitled <a href="https://www.cisa.gov/resources-tools/resources/software-identification-ecosystem-option-analysis"><em>Software Identification
Ecosystem Option
Analysis</em></a>
that looks at existing options to address these questions.  The
publication was followed by a <a href="https://www.regulations.gov/document/CISA-2023-0026-0001">request for
comments</a>; our
<a href="https://git.savannah.gnu.org/cgit/guix/maintenance.git/plain/doc/cisa-2023-0026-0001/cisa-2023-0026-0001.pdf">comment</a>
as Guix developers didn’t make it on time to be published, but we’d like
to share it here.</p><p>Software identification for cybersecurity purposes is a crucial topic,
as the white paper explains in its introduction:</p><blockquote><p>Effective vulnerability management requires software to be trackable
in a way that allows correlation with other information such as known
vulnerabilities […]. This correlation is only possible when different
cybersecurity professionals know they are talking about the same
software.</p></blockquote><p>The <a href="https://en.wikipedia.org/wiki/Common_Platform_Enumeration">Common Platform Enumeration
(CPE)</a>
standard has been designed to fill that role; it is used to identify
software as part of the well-known <a href="https://en.wikipedia.org/wiki/Common_Vulnerabilities_and_Exposures">Common Vulnerabilities and Exposures
(CVE)</a>
process.  But CPE is showing its limits as an <em>extrinsic identification
mechanism</em>: the human-readable identifiers chosen by CPE fail to capture
the complexity of what “software” is.</p><p>We think functional software deployment as implemented by Nix and Guix,
coupled with the source code identification work carried out by Software
Heritage, provides a unique perspective on these matters.</p><p>The <em>Software Identification Ecosystem Option Analysis</em> white paper
released by CISA in October 2023 studies options towards the definition
of <em>a software identification ecosystem that can be used across the
complete, global software space for all key cybersecurity use cases</em>.</p><p>Our experience lies in the design and development of
<a href="https://guix.gnu.org">GNU Guix</a>, a package manager, software deployment
tool, and GNU/Linux distribution, which emphasizes three key elements:
<strong>reproducibility, provenance tracking, and auditability</strong>. We explain
in the following sections our approach and how it relates to the goal
stated in the aforementioned white paper.</p><p>Guix produces binary artifacts of varying complexity from source code:
package binaries, application bundles (container images to be consumed
by Docker and related tools), system installations, system bundles
(container and virtual machine images).</p><p>All these artifacts qualify as “software” and so does source code. Some
of this “software” comes from well-identified upstream packages,
sometimes with modifications added downstream by packagers (patches);
binary artifacts themselves are the byproduct of a build process where
the package manager uses <em>other</em> binary artifacts it previously built
(compilers, libraries, etc.) along with more source code (the package
definition) to build them. How can one identify “software” in that
sense?</p><p>Software is dual: it exists in <em>source</em> form and in <em>binary</em>,
machine-executable form. The latter is the outcome of a complex
computational process taking source code and intermediary binaries as
input.</p><p>Our thesis can be summarized as follows:</p><blockquote><p><strong>We consider that the requirements for source code identifiers differ
from the requirements to identify binary artifacts.</strong></p><p>Our view, embodied in GNU Guix, is that:</p><ol><li><p><strong>Source code</strong> can be identified in an unambiguous and
distributed fashion through <em>inherent identifiers</em> such as
cryptographic hashes.</p></li><li><p><strong>Binary artifacts</strong>, instead, need to be the byproduct of a
<em>comprehensive and verifiable build process itself available as
source code</em>.</p></li></ol></blockquote><p>In the next sections, to clarify the context of this statement, we show
how Guix identifies source code, how it defines the <em>source-to-binary</em>
path and ensures its verifiability, and how it provides provenance
tracking.</p><p>Guix includes <a href="https://guix.gnu.org/manual/en/html_node/Defining-Packages.html">package
definitions</a>
for almost 30,000 packages. Each package definition identifies its
<a href="https://guix.gnu.org/manual/en/html_node/origin-Reference.html">origin</a>—its
“main” source code as well as patches. The origin is
<strong>content-addressed</strong>: it includes a SHA256 cryptographic hash of the
code (an <em>inherent identifier</em>), along with a primary URL to download
it.</p><p>Since source is content-addressed, the URL can be thought of as a hint.
Indeed, <strong>we connected Guix to the <a href="https://www.softwareheritage.org">Software
Heritage</a> source code archive</strong>: when
source code vanishes from its original URL, Guix falls back to
downloading it from the archive. This is made possible thanks to the use
of inherent (or intrinsic) identifiers both by Guix and Software
Heritage.</p><p>More information can be found in this <a href="https://guix.gnu.org/en/blog/2019/connecting-reproducible-deployment-to-a-long-term-source-code-archive/">2019 blog
post</a>
and in the documents of the <a href="https://www.swhid.org/">Software Hash Identifiers
(SWHID)</a> working group.</p><p>Guix provides a <strong>verifiable path from source code to binaries</strong> by
ensuring <a href="https://reproducible-builds.org">reproducible builds</a>. To
achieve that, Guix builds upon the pioneering research work of Eelco
Dolstra that led to the design of the <a href="https://nixos.org">Nix package
manager</a>, with which it shares the same conceptual
foundation.</p><p>Namely, Guix relies on <em>hermetic builds</em>: builds are performed in
isolated environments that contain nothing but explicitly-declared
dependencies—where a “dependency” can be the output of another build
process or source code, including build scripts and patches.</p><p>An implication is that <strong>builds can be verified independently</strong>. For
instance, for a given version of Guix, <code>guix build gcc</code>
should produce the exact same binary, bit-for-bit. To facilitate
independent verification, <code>guix challenge gcc</code> compares the
binary artifacts of the GNU Compiler Collection (GCC) as built and
published by different parties. Users can also compare to a local build
with <code>guix build gcc --check</code>.</p><p>As with Nix, build processes are identified by <em>derivations</em>, which are
low-level, content-addressed build instructions; derivations may refer
to other derivations and to source code. For instance,
<code>/gnu/store/c9fqrmabz5nrm2arqqg4ha8jzmv0kc2f-gcc-11.3.0.drv</code>
uniquely identifies the derivation to build a specific variant of
version 11.3.0 of the GNU Compiler Collection (GCC). Changing the
package definition—patches being applied, build flags, set of
dependencies—, or similarly changing one of the packages it depends
on, leads to a different derivation (more information can be found in
<a href="https://edolstra.github.io/pubs/phd-thesis.pdf">Eelco Dolstra&#39;s PhD
thesis</a>).</p><p>Derivations form a graph that <strong>captures the entirety of the build
processes leading to a binary artifact</strong>. In contrast, mere package
name/version pairs such as <code>gcc 11.3.0</code> fail to capture the
breadth and depth elements that lead to a binary artifact. This is a
shortcoming of systems such as the <strong>Common Platform Enumeration</strong> (CPE)
standard: it fails to express whether a vulnerability that applies to
<code>gcc 11.3.0</code> applies to it regardless of how it was built,
patched, and configured, or whether certain conditions are required.</p><p>Reproducible builds alone cannot ensure the source-to-binary
correspondence: the compiler could contain a backdoor, as demonstrated
by Ken Thompson in <em>Reflections on Trusting Trust</em>. To address that,
Guix goes further by implementing so-called <strong>full-source bootstrap</strong>:
for the first time, literally every package in the distribution is built
from source code, <a href="https://guix.gnu.org/en/blog/2023/the-full-source-bootstrap-building-from-source-all-the-way-down/">starting from a very small binary
seed</a>.
This gives an unprecedented level of transparency, allowing code to be
audited at all levels, and improving robustness against the
“trusting-trust attack” described by Ken Thompson.</p><p>The European Union recognized the importance of this work through an
<a href="https://nlnet.nl/project/GNUMes-fullsource/">NLnet Privacy &amp; Trust Enhancing Technologies (NGI0 PET)
grant</a> allocated in
2021 to Jan Nieuwenhuizen to further work on full-source bootstrap in
GNU Guix, GNU Mes, and related projects, followed by <a href="https://nlnet.nl/project/GNUMes-ARM_RISC-V/">another
grant</a> in 2022 to expand
support to the Arm and RISC-V CPU architectures.</p><p>We define provenance tracking as the ability <strong>to map a binary artifact
back to its complete corresponding source</strong>. Provenance tracking is
necessary to allow the recipient of a binary artifact to access the
corresponding source code and to verify the source/binary correspondence
if they wish to do so.</p><p>The
<a href="https://guix.gnu.org/manual/en/html_node/Invoking-guix-pack.html"><code>guix pack</code></a>
command can be used to build, for instance, containers images. Running
<code>guix pack -f docker python --save-provenance</code> produces a
<em>self-describing Docker image</em> containing the binaries of Python and its
run-time dependencies. The image is self-describing because
<code>--save-provenance</code> flag leads to the inclusion of a
<em>manifest</em> that describes which revision of Guix was used to produce
this binary. A third party can retrieve this revision of Guix and from
there view the entire build dependency graph of Python, view its source
code and any patches that were applied, and recursively for its
dependencies.</p><p>To summarize, capturing the revision of Guix that was used is all it
takes to <em>reproduce</em> a specific binary artifact. This is illustrated by
<a href="https://guix.gnu.org/manual/en/html_node/Invoking-guix-time_002dmachine.html">the <code>time-machine</code>
command</a>.
The example below deploys, <em>at any time on any machine</em>, the specific
build artifact of the <code>python</code> package as it was defined in this Guix
commit:</p><pre><code>guix time-machine -q --commit=d3c3922a8f5d50855165941e19a204d32469006f \
  -- install python</code></pre><p>In other words, because Guix itself defines how artifacts are built,
<strong>the revision of the Guix source coupled with the package name
unambiguously identify the package’s binary artifact</strong>. As
scientists, we build on this property to achieve reproducible research
workflows, as explained in this <a href="https://doi.org/10.1038/s41597-022-01720-9">2022 article in <em>Nature Scientific
Data</em></a>; as engineers, we
value this property to analyze the systems we are running and determine
which known vulnerabilities and bugs apply.</p><p>Again, a software bill of materials (SBOM) written as a mere list of
package name/version pairs would fail to capture as much information.
The <strong>Artifact Dependency Graph (ADG) of
<a href="https://omnibor.io/">OmniBOR</a></strong>, while less ambiguous, falls short in
two ways: it is too fine-grained for typical cybersecurity applications
(at the level of individual source files), and it only captures the
alleged source/binary correspondence of individual files but not the
process to go from source to binary.</p><p>Inherent identifiers lend themselves well to unambiguous source code
identification, as demonstrated by Software Heritage, Guix, and Nix.</p><p>However, we believe binary artifacts should instead be treated as the
result of a computational process; it is that process that needs to be
fully captured to support <strong>independent verification of the
source/binary correspondence</strong>. For cybersecurity purposes, recipients
of a binary artifact must be able to be map it back to its source code
(<em>provenance tracking</em>), with the additional guarantee that they must be
able to reproduce the entire build process to verify the source/binary
correspondence (<em>reproducible builds and full-source bootstrap</em>). As
long as binary artifacts result from a reproducible build process,
itself described as source code, <strong>identifying binary artifacts boils
down to identifying the source code of their build process</strong>.</p><p>These ideas are developed in the 2022 scientific paper <a href="https://doi.org/10.22152/programming-journal.org/2023/7/1"><em>Building a
Secure Software Supply Chain with
GNU Guix</em></a></p><p>Unless otherwise stated, blog posts on this site are
copyrighted by their respective authors and published under the terms of
the <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC-BY-SA 4.0</a> license and those of the <a href="https://www.gnu.org/licenses/fdl-1.3.html">GNU Free Documentation License</a> (version 1.3 or later, with no Invariant Sections, no
Front-Cover Texts, and no Back-Cover Texts).</p></article></div></div>
  </body>
</html>
