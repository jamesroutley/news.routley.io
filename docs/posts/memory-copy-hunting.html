<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://tigerbeetle.com/blog/2023-07-26-copy-hunting/">Original</a>
    <h1>Memory Copy Hunting</h1>
    
    <div id="readability-page-1" class="page"><div>
            <p>
              I have a super power. I want to share it in this blog post so that
              you, my dear reader, also have it!
            </p>
            <p>
              This is the super power: I know that LLVM IR is text. Let me
              explain.
            </p>
            <p>
              When we hack on something, <em>usually</em> it is enough to study
              the source code. Whether we are implementing a new feature,
              hunting down a bug, or optimizing performance, usually the mapping
              between the source code and the resulting machine code is
              transparent enough that we can work on the level of our language,
              like Rust or Zig.
            </p>
            <p>
              Sometimes though, you need to look deeper. For example, if you are
              optimizing binary size, the relation between the amount of source
              code and the length of the resulting ELF file is much less clear.
              The natural first answer when looking into these sorts of problems
              is to study the resulting binary. Tools like <code>nm</code>,
              <code>objdump</code> or even
              <a href="https://godbolt.org/">compiler explorer</a> come to mind.
              But in practice, working with raw disassembly is not efficient—it
              is too remote from the original source code, too target specific,
              too AT&amp;T syntax by default.
            </p>
            <p>
              What if… the next time you think to yourself “oh
              dear, I have to look at the assembly to solve this problem”,
              you think “wow, I can look at the LLVM IR to tackle
              this!”?
            </p>
            <p>
              LLVM IR is pretty low-level, so there’s a rather direct
              correspondence between IR instructions and generated assembly
              instructions. At the same time, LLVM IR is actually also
              high-level! It is somewhat target independent, it has better
              connection with the source code, and it is more human
              oriented—instruction names are usually obvious words, rather than
              cryptic mnemonics, variables are symbolic, rather than mapped to a
              finite number of registers, etc. And, the killer feature, LLVM IR
              has a standard, good, readable textual representation. You can
              read LLVM IR <em>without</em> studying the spec, and you can grep
              it. Recently, we’ve used a “grep llvm-ir” trick
              to make a dent in two different problems at TigerBeetle.
            </p>
            <h2 id="needless-memcpy">Needless memcpy</h2>
            <p>
              One performance bug that we have hit a few times in TigerBeetle is
              the problem of implicit memcopies. This is a problem that Rust and
              Zig both share—naive compilation of idiomatic code can introduce a
              bunch of local variable copies. Removing these copies requires
              some compiler smartness, and the work is underway in both
              <a href="https://github.com/ziglang/zig/issues/2765">Zig</a> and
              <a href="https://arewestackefficientyet.com">Rust</a> to implement
              relevant optimizations. While the smartness isn’t fully
              there yet, it’s on the programmer to write the code so that
              the compiled result is optimal with respect to copies.
            </p>
            <p>
              How do we use our new super power to solve the problem? Solving
              real problems is hard, so let’s invent a fake, simple
              problem first. Once we’ve solved that, we can move onto the
              real thing.
            </p>
            <p>
              One particular issue we fixed a couple of times in TigerBeetle is
              replacing by-value with by-pointer loops:
            </p>
            <div>
              <pre tabindex="0"><code data-lang="zig"><span><span><span>for</span> (<span>items</span>) <span>|</span><span>item</span><span>|</span> {
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>// -&gt; //
</span></span></span><span><span><span></span>
</span></span><span><span><span>for</span> (<span>items</span>) <span>|*</span><span>item</span><span>|</span> {
</span></span><span><span>}
</span></span></code></pre>
            </div>
            <p>
              When compiling with optimizations, even older Zig versions such as
              0.9.1 often can eliminate the copy here, but this doesn’t
              always happen. We want to find cases where it doesn’t.
            </p>
            <p>
              Let’s try to weaponize this example. To do that, we need to
              create a surrounding context for the <code>for</code> loop which
              is as small as possible, but still shows the problem (ideally, in
              an obvious form).
            </p>
            <p>
              So let’s start with defining a gigantic struct with a small
              field:
            </p>
            <div>
              <pre tabindex="0"><code data-lang="zig"><span><span><span>const</span> <span>Big</span> <span>=</span> <span>struct</span> {
</span></span><span><span>    <span>ballast</span><span>:</span> [<span>4096</span>]<span>u8</span>,
</span></span><span><span>    <span>small</span><span>:</span> <span>Small</span>,
</span></span><span><span>};
</span></span><span><span>
</span></span><span><span><span>const</span> <span>Small</span> <span>=</span> <span>struct</span> {
</span></span><span><span>    <span>value</span><span>:</span> <span>u32</span>,
</span></span><span><span>};
</span></span></code></pre>
            </div>
            <p>
              We can now plug it into a <code>for</code> loop, which only uses a
              small part of the struct:
            </p>
            <div>
              <pre tabindex="0"><code data-lang="zig"><span><span><span>const</span> <span>xs</span><span>:</span> []<span>Big</span> <span>=</span> <span>todo</span>;
</span></span><span><span><span>for</span> (<span>xs</span>) <span>|</span><span>x</span><span>|</span> {
</span></span><span><span>    <span>use_small</span>(<span>&amp;</span><span>x</span>.<span>small</span>);
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>fn</span> <span>use_small</span>(<span>small</span><span>:</span> <span>*</span><span>const</span> <span>Small</span>) <span>void</span> {
</span></span><span><span>    <span>_</span> <span>=</span> <span>small</span>;
</span></span><span><span>}
</span></span></code></pre>
            </div>
            <p>
              Note how I abstract a detail, the body of the
              <code>for</code> loop, into a function. To complete our example,
              we need to get the <code>xs</code> slice. We
              <em>could</em> manually initialize an array of some
              <code>Big</code> structs, but that’s cumbersome. When
              crafting minimal examples, we can use a standard trick to conjure
              anything out of thin air by defining a function that gets whatever
              is needed through parameters:
            </p>
            <div>
              <pre tabindex="0"><code data-lang="zig"><span><span><span>const</span> <span>Big</span> <span>=</span> <span>struct</span> {
</span></span><span><span>    <span>ballast</span><span>:</span> [<span>4096</span>]<span>u8</span>,
</span></span><span><span>    <span>small</span><span>:</span> <span>Small</span>,
</span></span><span><span>};
</span></span><span><span>
</span></span><span><span><span>const</span> <span>Small</span> <span>=</span> <span>struct</span> {
</span></span><span><span>    <span>value</span><span>:</span> <span>u32</span>,
</span></span><span><span>};
</span></span><span><span>
</span></span><span><span><span>fn</span> <span>use_big</span>(<span>xs</span><span>:</span> []<span>Big</span>) <span>void</span> {
</span></span><span><span>    <span>for</span> (<span>xs</span>) <span>|</span><span>x</span><span>|</span> {
</span></span><span><span>        <span>use_small</span>(<span>&amp;</span><span>x</span>.<span>small</span>);
</span></span><span><span>    }
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>fn</span> <span>use_small</span>(<span>small</span><span>:</span> <span>*</span><span>const</span> <span>Small</span>) <span>void</span> {
</span></span><span><span>    <span>_</span> <span>=</span> <span>small</span>;
</span></span><span><span>}
</span></span></code></pre>
            </div>
            <p>
              We are getting somewhere! Now we need to compile this to an actual
              artifact to get our LLVM IR. Because we are only interested in our
              <code>use_big</code> function, we better compile a
              <em>library</em>. But to also force Zig to compile anything, we
              need to mark our function as part of the library API, which means
              it must also follow the C ABI. So the complete minimal example can
              look like this:
            </p>
            <div>
              <pre tabindex="0"><code data-lang="zig"><span><span><span>const</span> <span>Big</span> <span>=</span> <span>struct</span> {
</span></span><span><span>    <span>ballast</span><span>:</span> [<span>4096</span>]<span>u8</span>,
</span></span><span><span>    <span>small</span><span>:</span> <span>Small</span>,
</span></span><span><span>};
</span></span><span><span>
</span></span><span><span><span>const</span> <span>Small</span> <span>=</span> <span>struct</span> {
</span></span><span><span>    <span>value</span><span>:</span> <span>u32</span>,
</span></span><span><span>};
</span></span><span><span>
</span></span><span><span><span>export</span> <span>fn</span> <span>use_big</span>(<span>xs_ptr</span><span>:</span> [<span>*</span>]<span>Big</span>, <span>xs_len</span><span>:</span> <span>usize</span>) <span>callconv</span>(.<span>C</span>) <span>void</span> {
</span></span><span><span>    <span>const</span> <span>xs</span><span>:</span> []<span>Big</span> <span>=</span> <span>xs_ptr</span>[<span>0</span>..<span>xs_len</span>];
</span></span><span><span>    <span>for</span> (<span>xs</span>) <span>|</span><span>x</span><span>|</span> {
</span></span><span><span>        <span>use_small</span>(<span>&amp;</span><span>x</span>.<span>small</span>);
</span></span><span><span>    }
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>fn</span> <span>use_small</span>(<span>small</span><span>:</span> <span>*</span><span>const</span> <span>Small</span>) <span>void</span> {
</span></span><span><span>    <span>_</span> <span>=</span> <span>small</span>;
</span></span><span><span>}
</span></span></code></pre>
            </div>
            <p>How do we compile that to LLVM IR?</p>
            <div>
              <pre tabindex="0"><code data-lang="shell"><span><span>$ zig build-lib -h | rg llvm
</span></span><span><span>  -femit-llvm-ir<span>[=</span>path<span>]</span>     Produce a .ll file with LLVM IR <span>(</span>requires LLVM extensions<span>)</span>
</span></span><span><span>  -fno-emit-llvm-ir         <span>(</span>default<span>)</span> Do not produce a .ll file with LLVM IR
</span></span><span><span>  -femit-llvm-bc<span>[=</span>path<span>]</span>     Produce a LLVM module as a .bc file <span>(</span>requires LLVM extensions<span>)</span>
</span></span><span><span>  -fno-emit-llvm-bc         <span>(</span>default<span>)</span> Do not produce a LLVM module as a .bc file
</span></span><span><span>  --verbose-llvm-ir            Enable compiler debug output <span>for</span> LLVM IR
</span></span><span><span>  --verbose-llvm-cpu-features  Enable compiler debug output <span>for</span> LLVM CPU features
</span></span></code></pre>
            </div>
            <p>
              Ok, got it, it’s <code>--femit-llvm-ir</code>, let’s
              do it!
            </p>
            <div>
              <pre tabindex="0"><code data-lang="shell"><span><span>$ zig build-lib -femit-llvm-ir example.zig
</span></span><span><span>
</span></span><span><span>$ ls
</span></span><span><span>example.ll
</span></span><span><span>example.zig
</span></span><span><span>libexample.a
</span></span></code></pre>
            </div>
            <p>Perfect! Let’s look at what is inside that .ll file!</p>
            <div>
              <pre tabindex="0"><code data-lang="llvm"><span><span><span>; ModuleID = &#39;example&#39;
</span></span></span><span><span><span></span><span>source_filename</span> = <span>&#34;example&#34;</span>
</span></span><span><span><span>target</span> <span>datalayout</span> = <span>&#34;e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128&#34;</span>
</span></span><span><span><span>target</span> <span>triple</span> = <span>&#34;x86_64-unknown-linux-gnu&#34;</span>
</span></span><span><span>
</span></span><span><span><span>%&#34;[]u8&#34;</span> = <span>type</span> { <span>i8</span>*, <span>i64</span> }
</span></span><span><span><span>%std.builtin.StackTrace</span> = <span>type</span> { <span>i64</span>, <span>%&#34;[]usize&#34;</span> }
</span></span><span><span><span>%&#34;[]usize&#34;</span> = <span>type</span> { <span>i64</span>*, <span>i64</span> }
</span></span><span><span><span>%std.target.LinuxVersionRange</span> = <span>type</span> { <span>%std.builtin.Range</span>, <span>%std.builtin.Version</span> }
</span></span><span><span><span>%std.builtin.Range</span> = <span>type</span> { <span>%std.builtin.Version</span>, <span>%std.builtin.Version</span> }
</span></span><span><span><span>%std.builtin.Version</span> = <span>type</span> { <span>i32</span>, <span>i32</span>, <span>i32</span> }
</span></span></code></pre>
            </div>
            <p>
              Some gibberish! Let’s try to search for our
              <code>use_big</code> function:
            </p>
            <div>
              <pre tabindex="0"><code data-lang="llvm"><span><span><span>; Function Attrs: nobuiltin nounwind
</span></span></span><span><span><span></span><span>define</span> <span>void</span> <span>@use_big</span>(<span>%Big</span>* <span>nonnull</span> <span>%0</span>, <span>i64</span> <span>%1</span>) <span>#1</span> <span>!dbg</span> <span>!2400</span> {
</span></span><span><span><span>Entry:</span>
</span></span><span><span>  <span>%xs</span> = <span>alloca</span> <span>%&#34;[]Big&#34;</span>, <span>align</span> <span>8</span>
</span></span><span><span>  <span>%i</span> = <span>alloca</span> <span>i64</span>, <span>align</span> <span>8</span>
</span></span><span><span>  <span>%x</span> = <span>alloca</span> <span>%Big</span>, <span>align</span> <span>4</span>
</span></span><span><span>  <span>%xs_ptr</span> = <span>alloca</span> <span>%Big</span>*, <span>align</span> <span>8</span>
</span></span><span><span>  <span>%xs_len</span> = <span>alloca</span> <span>i64</span>, <span>align</span> <span>8</span>
</span></span><span><span>  <span>store</span> <span>%Big</span>* <span>%0</span>, <span>%Big</span>** <span>%xs_ptr</span>, <span>align</span> <span>8</span>
</span></span><span><span>  <span>call</span> <span>void</span> <span>@llvm.dbg.declare</span>(<span>metadata</span> <span>%Big</span>** <span>%xs_ptr</span>, <span>metadata</span> <span>!2416</span>, <span>metadata</span> <span>!DIExpression</span>()), <span>!dbg</span> <span>!2426</span>
</span></span><span><span>  <span>store</span> <span>i64</span> <span>%1</span>, <span>i64</span>* <span>%xs_len</span>, <span>align</span> <span>8</span>
</span></span><span><span>  <span>call</span> <span>void</span> <span>@llvm.dbg.declare</span>(<span>metadata</span> <span>i64</span>* <span>%xs_len</span>, <span>metadata</span> <span>!2417</span>, <span>metadata</span> <span>!DIExpression</span>()), <span>!dbg</span> <span>!2427</span>
</span></span><span><span>  <span>%2</span> = <span>load</span> <span>i64</span>, <span>i64</span>* <span>%xs_len</span>, <span>align</span> <span>8</span>, <span>!dbg</span> <span>!2428</span>
</span></span><span><span>  <span>%3</span> = <span>load</span> <span>%Big</span>*, <span>%Big</span>** <span>%xs_ptr</span>, <span>align</span> <span>8</span>, <span>!dbg</span> <span>!2429</span>
</span></span><span><span>  <span>%4</span> = <span>icmp</span> <span>ule</span> <span>i64</span> <span>0</span>, <span>%2</span>, <span>!dbg</span> <span>!2429</span>
</span></span><span><span>  <span>br</span> <span>i1</span> <span>%4</span>, <span>label</span> <span>%BoundsCheckOk</span>, <span>label</span> <span>%BoundsCheckFail</span>, <span>!dbg</span> <span>!2429</span>
</span></span><span><span><span>ForCond:</span>
</span></span><span><span>  <span>%5</span> = <span>load</span> <span>i64</span>, <span>i64</span>* <span>%i</span>, <span>align</span> <span>8</span>, <span>!dbg</span> <span>!2430</span>
</span></span><span><span>  <span>%6</span> = <span>icmp</span> <span>ult</span> <span>i64</span> <span>%5</span>, <span>%19</span>, <span>!dbg</span> <span>!2430</span>
</span></span><span><span>  <span>br</span> <span>i1</span> <span>%6</span>, <span>label</span> <span>%ForBody</span>, <span>label</span> <span>%ForEnd</span>, <span>!dbg</span> <span>!2430</span>
</span></span><span><span><span>ForBody:</span>
</span></span><span><span>  <span>%7</span> = <span>getelementptr</span> <span>inbounds</span> <span>%&#34;[]Big&#34;</span>, <span>%&#34;[]Big&#34;</span>* <span>%xs</span>, <span>i32</span> <span>0</span>, <span>i32</span> <span>0</span>, <span>!dbg</span> <span>!2430</span>
</span></span><span><span>  <span>%8</span> = <span>load</span> <span>%Big</span>*, <span>%Big</span>** <span>%7</span>, <span>align</span> <span>8</span>, <span>!dbg</span> <span>!2430</span>
</span></span><span><span>  <span>%9</span> = <span>getelementptr</span> <span>inbounds</span> <span>%Big</span>, <span>%Big</span>* <span>%8</span>, <span>i64</span> <span>%5</span>, <span>!dbg</span> <span>!2430</span>
</span></span><span><span>  <span>%10</span> = <span>bitcast</span> <span>%Big</span>* <span>%9</span> <span>to</span> <span>i8</span>*, <span>!dbg</span> <span>!2431</span>
</span></span><span><span>  <span>%11</span> = <span>bitcast</span> <span>%Big</span>* <span>%x</span> <span>to</span> <span>i8</span>*, <span>!dbg</span> <span>!2431</span>
</span></span><span><span>
</span></span><span><span>  <span>call</span> <span>void</span> <span>@llvm.memcpy.p0i8.p0i8.i64</span>(<span>i8</span>* <span>align</span> <span>4</span> <span>%11</span>, <span>i8</span>* <span>align</span> <span>4</span> <span>%10</span>, <span>i64</span> <span>4100</span>, <span>i1</span> <span>false</span>), <span>!dbg</span> <span>!2431</span>
</span></span><span><span><span>; Found you!      ☝️
</span></span></span><span><span><span></span>
</span></span><span><span>  <span>call</span> <span>void</span> <span>@llvm.dbg.declare</span>(<span>metadata</span> <span>%Big</span>* <span>%x</span>, <span>metadata</span> <span>!2425</span>, <span>metadata</span> <span>!DIExpression</span>()), <span>!dbg</span> <span>!2431</span>
</span></span><span><span>  <span>%12</span> = <span>getelementptr</span> <span>inbounds</span> <span>%Big</span>, <span>%Big</span>* <span>%x</span>, <span>i32</span> <span>0</span>, <span>i32</span> <span>1</span>, <span>!dbg</span> <span>!2432</span>
</span></span><span><span>  <span>call</span> <span>fastcc</span> <span>void</span> <span>@use_small</span>(<span>%Small</span>* <span>%12</span>), <span>!dbg</span> <span>!2434</span>
</span></span><span><span>  <span>%13</span> = <span>add</span> <span>nuw</span> <span>i64</span> <span>%5</span>, <span>1</span>, <span>!dbg</span> <span>!2430</span>
</span></span><span><span>  <span>store</span> <span>i64</span> <span>%13</span>, <span>i64</span>* <span>%i</span>, <span>align</span> <span>8</span>, <span>!dbg</span> <span>!2430</span>
</span></span><span><span>  <span>br</span> <span>label</span> <span>%ForCond</span>, <span>!dbg</span> <span>!2430</span>
</span></span></code></pre>
            </div>
            <p>
              Hey, it’s still gibberish, but we were able to find our
              <code>use_big</code> function. And we even see
              <code>memcpy</code>! And that’s the thing I like about LLVM
              IR—I know very little about the x86_64 instruction set, and even
              less about LLVM IR, but I am able to muddle through
              <code>.ll</code> just because it is text.
            </p>
            <p>
              Looking at the
              <a href="https://llvm.org/docs/LangRef.html#llvm-memcpy-intrinsic">docs</a>
              for this LLVM intrinsic, we see that the third argument is the
              length. And, indeed, <code>i64 4100</code> looks like a big
              number, corresponding to <code>@sizeOf(Big)</code>.
            </p>
            <p>
              So here’s the plan for our copy-finding tool—read the
              <code>.ll</code> file line-by-line, notice the current
              <code>define</code>, look for lines with <code>memcpy</code>, do
              some comma counting to find the third argument, and check it
              against a threshold.
            </p>
            <p>
              At this point you might be wondering—why parse
              <code>.ll</code> line-by-line? Can we just, like, take an ll-file
              parser, parse that into a data structure, build a call-graph, and
              otherwise act like grown-up compiler engineers? I also wondered
              about it! I tried one <code>.ll</code> parsing library, but it
              required linking against LLVM and crashed on my
              <code>.ll</code> file, so I figured some text processing would be
              more robust for my purpose here.
            </p>
            <p>
              Anyway, the relatively self-contained tool can be found here:
              <a href="https://github.com/tigerbeetle/tigerbeetle/blob/ae3ed332815c95cde149fd0559976f16facdd8cc/src/copyhound.zig">copyhound.zig</a>. Feel free to use it yourself, like
              <a href="https://github.com/pkmn/engine/blob/389843619449bfdd23510a77a4545371c8d0a51b/src/tools/copies.zig">scheibo is already doing</a>!
            </p>
            <h2 id="copies-found">Copies found</h2>
            <p>
              So, was this useful? A bit! We haven’t fully productionized
              and put this into our CI, but some ad-hoc investigations uncovered
              a couple of curiosities. For example, a bunch of copies were
              traced back to the <code>std.meta.eql</code> function. This is an
              extremely cute Zig version of Rust’s
              <code>PartialEq</code> which compares two types by comparing every
              field, roughly like this:
            </p>
            <div>
              <pre tabindex="0"><code data-lang="zig"><span><span><span>pub</span> <span>fn</span> <span>eql</span>(<span>a</span><span>:</span> <span>anytype</span>, <span>b</span><span>:</span> <span>@TypeOf</span>(<span>a</span>)) <span>bool</span> {
</span></span><span><span>    <span>const</span> <span>T</span> <span>=</span> <span>@TypeOf</span>(<span>a</span>);
</span></span><span><span>    <span>inline</span> <span>for</span> (<span>info</span>.<span>fields</span>) <span>|</span><span>field_info</span><span>|</span> {
</span></span><span><span>        <span>if</span> (<span>!</span><span>eql</span>(<span>@field</span>(<span>a</span>, <span>field_info</span>.<span>name</span>), <span>@field</span>(<span>b</span>, <span>field_info</span>.<span>name</span>))) <span>return</span> <span>false</span>;
</span></span><span><span>    }
</span></span><span><span>    <span>return</span> <span>true</span>;
</span></span><span><span>}
</span></span></code></pre>
            </div>
            <p>
              This is great for comparing “objects” with complex
              structure. But in TigerBeetle, very few things are such objects.
              <em>Most</em> of the things we work with are cache-line aligned
              bags-of-bytes without pointers or padding. And when we compare
              things, very often it is for assertions where we expect things to
              be equal most of the time.
            </p>
            <p>
              Thinking about this use-case suggests a more elegant comparison
              algorithm—just compare the underlying bytes directly.
              Additionally, given that we carefully align all our data, the
              comparison routine can take advantage of that, and compare chunks
              of memory at the same time. And Zig is just <em>perfect</em> for
              implementing this kind of optimized comparison routine, because we
              can use comptime capabilities to <em>directly</em> express this
              optimally:
            </p>
            <div>
              <pre tabindex="0"><code data-lang="zig"><span><span><span>/// Compare two values by directly comparing the underlying memory.
</span></span></span><span><span><span>///
</span></span></span><span><span><span>/// Assert at compile time that this is a reasonable thing to do for a given `T`. That is, check
</span></span></span><span><span><span>/// that:
</span></span></span><span><span><span>///   - `T` doesn&#39;t have any non-deterministic padding,
</span></span></span><span><span><span>///   - `T` doesn&#39;t embed any pointers.
</span></span></span><span><span><span></span><span>pub</span> <span>fn</span> <span>equal_bytes</span>(<span>comptime</span> <span>T</span><span>:</span> <span>type</span>, <span>a</span><span>:</span> <span>*</span><span>const</span> <span>T</span>, <span>b</span><span>:</span> <span>*</span><span>const</span> <span>T</span>) <span>bool</span> {
</span></span><span><span>    <span>comptime</span> <span>assert</span>(<span>std</span>.<span>meta</span>.<span>trait</span>.<span>hasUniqueRepresentation</span>(<span>T</span>));
</span></span><span><span>    <span>comptime</span> <span>assert</span>(<span>!</span><span>has_pointers</span>(<span>T</span>));
</span></span><span><span>    <span>comptime</span> <span>assert</span>(<span>@sizeOf</span>(<span>T</span>) <span>*</span> <span>8</span> <span>==</span> <span>@bitSizeOf</span>(<span>T</span>));
</span></span><span><span>
</span></span><span><span>    <span>// Pick the biggest &#34;word&#34; for word-wise comparison, and don&#39;t try to early-return on the first
</span></span></span><span><span><span></span>    <span>// mismatch, so that a compiler can vectorize the loop.
</span></span></span><span><span><span></span>
</span></span><span><span>    <span>const</span> <span>Word</span> <span>=</span> <span>inline</span> <span>for</span> (.{ <span>u64</span>, <span>u32</span>, <span>u16</span>, <span>u8</span> }) <span>|</span><span>Word</span><span>|</span> {
</span></span><span><span>        <span>if</span> (<span>@alignOf</span>(<span>T</span>) <span>&gt;=</span> <span>@alignOf</span>(<span>Word</span>) <span>and</span> <span>@sizeOf</span>(<span>T</span>) <span>%</span> <span>@sizeOf</span>(<span>Word</span>) <span>==</span> <span>0</span>) <span>break</span> <span>Word</span>;
</span></span><span><span>    } <span>else</span> <span>unreachable</span>;
</span></span><span><span>
</span></span><span><span>    <span>const</span> <span>a_words</span> <span>=</span> <span>std</span>.<span>mem</span>.<span>bytesAsSlice</span>(<span>Word</span>, <span>std</span>.<span>mem</span>.<span>asBytes</span>(<span>a</span>));
</span></span><span><span>    <span>const</span> <span>b_words</span> <span>=</span> <span>std</span>.<span>mem</span>.<span>bytesAsSlice</span>(<span>Word</span>, <span>std</span>.<span>mem</span>.<span>asBytes</span>(<span>b</span>));
</span></span><span><span>    <span>assert</span>(<span>a_words</span>.<span>len</span> <span>==</span> <span>b_words</span>.<span>len</span>);
</span></span><span><span>
</span></span><span><span>    <span>var</span> <span>total</span><span>:</span> <span>Word</span> <span>=</span> <span>0</span>;
</span></span><span><span>    <span>for</span> (<span>a_words</span>) <span>|</span><span>a_word</span>, <span>i</span><span>|</span> {
</span></span><span><span>        <span>const</span> <span>b_word</span> <span>=</span> <span>b_words</span>[<span>i</span>];
</span></span><span><span>        <span>total</span> <span>|=</span> <span>a_word</span> <span>^</span> <span>b_word</span>;
</span></span><span><span>    }
</span></span><span><span>
</span></span><span><span>    <span>return</span> <span>total</span> <span>==</span> <span>0</span>;
</span></span><span><span>}
</span></span></code></pre>
            </div>
            <p>
              For fun, I also tried running copyhound on the Zig compiler
              itself, and it found
              <a href="https://github.com/ziglang/zig/pull/16438">a curious issue</a>!
            </p>
            <p>
              <code>AstGen.numberLiteral</code>, a function which parses numeric
              tokens into numeric values (that is,
              <code>&#34;92&#34;</code> to <code>92</code>) uses ten kilobytes
              of stack.
            </p>
            <p>
              The root cause was a slow path for parsing floating point numbers.
              Parsing floats is a surprisingly gnarly problem, because they are
              specified as base-10 in the source code, but the actual IEEE-754
              float value is base-2. So, while most simple values can be dealt
              with efficiently, sometimes a slow path is needed which in Zig
              requires a lot of stack space. And LLVM was happily inlining this
              slow path! Although the <em>code</em> for slow path was rarely
              executed, the function’s frame size would have to account
              for memory there every time. The fix was to mark the function in
              question as
              <a href="https://ziglang.org/documentation/master/#setCold"><code>@setCold(true)</code></a>.
            </p>
            <h2 id="tracking-binary-size">Tracking Binary Size</h2>
            <p>
              After writing <code>copyhound</code>, I realized that it solves
              one other kind of copy problem as well!
            </p>
            <p>
              At TigerBeetle, we also care about binary size. Well, we are not
              <em>actively</em> trying to shrink the binary just yet, but we are
              keeping an eye on size. And Zig, like Rust and C++, has a
              potential gotcha here — it’s very easy to write source
              code that, while small in size on its own, uses comptime
              parameters that cause combinatorial explosion of the binary size,
              when the same function gets repeatedly monomorphized with
              different compile time parameters. A function like:
            </p>
            <div>
              <pre tabindex="0"><code data-lang="zig"><span><span><span>fn</span> <span>f</span>(<span>comptime</span> <span>T</span><span>:</span> <span>type</span>, <span>value</span><span>:</span> <span>T</span>) <span>void</span>
</span></span></code></pre>
            </div>
            <p>
              is duplicated in the machine code for every value of
              <code>T</code> it is actually used with.
            </p>
            <p>For the following example:</p>
            <div>
              <pre tabindex="0"><code data-lang="zig"><span><span><span>fn</span> <span>f</span>(<span>comptime</span> <span>T</span><span>:</span> <span>type</span>, <span>value</span><span>:</span> <span>T</span>) <span>void</span> {
</span></span><span><span><span>_</span> <span>=</span> <span>value</span>;
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span>
</span></span><span><span><span>export</span> <span>fn</span> <span>g</span>() <span>callconv</span>(.<span>C</span>) <span>void</span> {
</span></span><span><span><span>f</span>(<span>i32</span>, <span>92</span>);
</span></span><span><span><span>f</span>(<span>f32</span>, <span>9.2</span>);
</span></span><span><span>}
</span></span></code></pre>
            </div>
            <p>We get the following IR:</p>
            <div>
              <pre tabindex="0"><code data-lang="llvm"><span><span><span>; Function Attrs: nobuiltin nounwind
</span></span></span><span><span><span></span><span>define</span> <span>internal</span> <span>fastcc</span> <span>void</span> <span>@f</span>(<span>i32</span> <span>%0</span>) <span>unnamed_addr</span> <span>#1</span> <span>!dbg</span> <span>!2406</span> {
</span></span><span><span><span>…</span>
</span></span><span><span>
</span></span><span><span><span>; Function Attrs: nobuiltin nounwind
</span></span></span><span><span><span></span><span>define</span> <span>internal</span> <span>fastcc</span> <span>void</span> <span>@f.23</span>(<span>float</span> <span>%0</span>) <span>unnamed_addr</span> <span>#1</span> <span>!dbg</span> <span>!2414</span> {
</span></span><span><span><span>…</span>
</span></span><span><span>
</span></span><span><span><span>; Function Attrs: nobuiltin nounwind
</span></span></span><span><span><span></span><span>define</span> <span>void</span> <span>@g</span>() <span>#1</span> <span>!dbg</span> <span>!2400</span> {
</span></span><span><span><span>…</span>
</span></span></code></pre>
            </div>
            <p>
              As you can see, the <code>f</code> is repeated twice. But because
              the repetition already exists at the LLVM IR level, we can look at
              this IR to find functions which contribute most to combinatorial
              explosion. To do this, we need to adjust our line-by-line
              processing of <code>.ll</code> files as follows:
            </p>
            <ul>
              <li>
                When we parse the <code>define</code> line, extract the
                polymorphic name of a function. This mostly amounts to removing
                generic arguments between <code>()</code> from the function
                name.
              </li>
              <li>
                Instead of looking for memcpy calls, just count the total number
                of lines comprising the body of each function.
              </li>
              <li>Group by extracted name, summing up the total size.</li>
            </ul>
            <p>
              This is the same idea that
              <a href="https://github.com/dtolnay/cargo-llvm-lines">cargo-llvm-lines</a>
              uses for Rust. That’s a theme—any trick you do with LLVM IR
              would work for any LLVM-based language.
            </p>
            <p>
              Did this find any curiosities? You bet! Turns out, one of the most
              bloated functions in TigerBeetle was the code responsible for:
            </p>
            <div>
              <pre tabindex="0"><code data-lang="shell"><span><span>$ tigerbeetle version --verbose
</span></span></code></pre>
            </div>
            <p>
              In verbose mode, this outputs compile-time configuration for
              TigerBeetle, using the following function:
            </p>
            <div>
              <pre tabindex="0"><code data-lang="zig"><span><span><span>fn</span> <span>print_value</span>(
</span></span><span><span>    <span>writer</span><span>:</span> <span>anytype</span>,
</span></span><span><span>    <span>comptime</span> <span>field</span><span>:</span> []<span>const</span> <span>u8</span>,
</span></span><span><span>    <span>comptime</span> <span>value</span><span>:</span> <span>anytype</span>,
</span></span><span><span>) <span>!</span><span>void</span> {
</span></span></code></pre>
            </div>
            <p>
              As you see, it is monomorphized for each field name and value. But
              there’s no need for that! The following works and shaves off
              300 bytes from the release binary:
            </p>
            <div>
              <pre tabindex="0"><code data-lang="zig"><span><span><span>fn</span> <span>print_value</span>(
</span></span><span><span>    <span>writer</span><span>:</span> <span>anytype</span>,
</span></span><span><span>    <span>field</span><span>:</span> []<span>const</span> <span>u8</span>,
</span></span><span><span>    <span>value</span><span>:</span> <span>anytype</span>,
</span></span><span><span>) <span>!</span><span>void</span> {
</span></span></code></pre>
            </div>
            <p>Let’s recap the tricks from the post:</p>
            <ul>
              <li>
                LLVM IR in many cases can be a convenient substitute for
                assembly.
              </li>
              <li>
                When debugging something related to compilers, it’s
                important to first come up with a minimal program to experiment
                with.
              </li>
              <li>
                You don’t need to write a whole program with
                <code>main</code>, you can write a single function which accepts
                everything needed as an argument.
              </li>
              <li>
                To compile just a single function, you can compile a library
                (but don’t forget to make the function public).
              </li>
              <li>
                Any compiler which uses LLVM should have a way to produce a
                textual file with LLVM IR; look for a
                <code>--emit-llvm</code> argument.
              </li>
              <li>
                You can open the resulting <code>.ll</code> file in a text
                editor and <code>Ctrl+F</code> functions names you are
                interested in.
              </li>
              <li>
                You can also do UNIX-style ad-hoc text processing of the result,
                which might show interesting properties of your code.
              </li>
            </ul>
          </div></div>
  </body>
</html>
