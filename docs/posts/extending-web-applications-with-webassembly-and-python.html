<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://wasmlabs.dev/articles/wasm-host-to-python/">Original</a>
    <h1>Extending web applications with WebAssembly and Python</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>This article shows how you can run a Python program within another application that uses a Wasm runtime (host) and have the Python program talk to the host and vice versa.</p>
<p>A couple of months ago we <a href="https://wasmlabs.dev/articles/python-wasm32-wasi/">added Python to the WebAssembly Language Runtimes</a>. We published a pre-built <code>python.wasm</code> binary, which can be used to run Python scripts with WebAssembly to get better security and portability.</p>
<p>After that release we received a lot of feedback on how to make it even more useful for developers. One of the recurring topics was around the need for bi-directional communication between the Wasm host and the Python code that runs on <code>python.wasm</code>.</p>
<p>We worked on this together with the <a href="https://suborbital.dev/">Suborbital</a> team and implemented an application that showcases bi-directional communication by implementing the SE2 Plugin ABI. This work was later incorporated in Suborbital&#39;s SE2 <a href="https://blog.suborbital.dev/bringing-python-to-se2-with-webassembly">Python offering</a>.</p>
<p>The sample application can be found at <a href="https://github.com/vmware-labs/webassembly-language-runtimes/tree/c6cf6e11ffaef1624108dfc9581911ed11f3f42d/python/examples/bindings/se2-bindings">WLR/python/examples/bindings/se2-bindings</a>. It is easy to run and can guide you on how to embed Python in a Wasm application and implement bindings for bi-directional communication.</p>

<p>WebAssembly is a great technology for extending applications. On the one hand, it provides a sandboxed environment, where extensions can run securely within the same process as the main application. On the other hand, it allows people to write extensions in any language that can be built into a Wasm module, or can be interpreted by one, like <code>python.wasm</code>.</p>
<p>There is an emerging trend for web applications and platforms to offer extensibility on top of WebAssembly. It is used by serverless platforms such as <a href="https://wasmcloud.com/">Cosmonic&#39;s wasmCloud</a>, <a href="https://workers.cloudflare.com/">CloudFlare&#39;s Workers</a>, <a href="https://www.fastly.com/products/edge-compute">Fastly&#39;s Compute</a>, <a href="https://www.fermyon.com/cloud">Fermyon&#39;s Cloud</a>, our own <a href="https://wasmlabs.dev/projects/wasm-workers-server/">Wasm Workers Server</a>, and also by solutions for extending existing applications such as <a href="https://extism.org/">Dylibso&#39;s Extism</a>, <a href="https://scale.sh/">LoopholeLabs&#39;s Scale</a> and <a href="https://suborbital.dev/">Suborbital&#39;s Extension Engine</a>.</p>
<h2 id="extending-applications" tabindex="-1">Extending applications</h2>
<p>The ability to extend applications with external code provides great flexibility to the software development processes. One can have a community of developers writing extensions for the same application, or a platform may offer great basic functionality that developers can reuse by building extensions on top.</p>
<p>Traditionally, this is done via so-called plugins, which get loaded into the main application and implement custom functionality. However, this usually limits plugin implementers to using a specific programming language (or set of languages) and also brings in risks to the stability and security of the main application.</p>
<p>With web applications developers have the option to use WebHooks, which allows several web apps to work as one and each can be implemented in a different language. However, this approach implies slower communication between the different web apps and a more complex deployment setup.</p>
<h2 id="extending-with-webassembly" tabindex="-1">Extending with WebAssembly</h2>
<p>To extend an application with WebAssembly you need to embed a Wasm runtime in it, so it can execute code from a Wasm module. We call such an application a Wasm host. Communication between the Wasm host and the Wasm module is well-defined by the exported and imported functions as declared by the Wasm module. Exported functions are implemented by the module and can be invoked by the host, while imported functions (also called <em>host functions</em>) are implemented by the host and can be invoked by the module.</p>
<p>However, when a Wasm module embeds the Python runtime in order to run a Python script we don&#39;t have a well defined way for the Wasm host to call a function from the Python script or the other way around. To facilitate that we need to add some code in the Wasm module that would expose host functions to the Python script and Python functions to the host. We refer to that code with the term <em>bindings</em> as it translates a Wasm module API to Python.</p>
<p>When we were doing our initial experiments at creating such bindings we had a discussion with Suborbital, who were just starting to work on adding Python support to their SE2 engine. We decided to collaborate. After experimenting with <code>libpython</code> and the Python C API we came to the working solution explained in this article.</p>
<p>The Suborbital team picked this up and pretty quickly rolled <a href="https://blog.suborbital.dev/bringing-python-to-se2-with-webassembly">SE2 support for Python plugins</a>.</p>
<h2 id="why-work-on-this" tabindex="-1">Why work on this</h2>
<p>The main drive to make WasmHost-to-Python communication easier is reusability. There is a lot of existing Python developers and code out there. Even though you can run Python scripts on <code>python.wasm</code>, you still don&#39;t have a paved way to communicate with the Wasm host. When necessary, developers will need to find their way through trial and error.</p>
<p>Accelerating WebAssembly adoption is one of our core goals at Wasm Labs, so we decided that working on a showcase of how to do this bi-directional communication can help developers bridge the gap between Wasm and their existing Python apps and knowledge.</p>
<p>We decided to partner up with Suborbital, who had a need for this functionality as part of their platform.</p>
<h2 id="previous-work" tabindex="-1">Previous work</h2>
<p>This is all based on the <code>python.wasm</code> work done by the CPython team. They already provide a <code>wasm32-wasi</code> build target, which we previously used to publish reusable Python binaries. We only needed to add <code>libpython</code> (which they also build) to the released assets.</p>
<p>The Suborbital team already has a well-defined ABI for the communication between a Wasm host and plugins defined in JavaScript that gets interpreted by a Wasm module. We could easily build on top of something that works and just implement it for another language.</p>

<p>Our app consists of three separate components:</p>
<ul>
<li><code>se2-mock-runtime</code>: a WebAssembly host.</li>
<li><code>py-plugin</code>: a Python app.</li>
<li><code>wasm-wrapper-c</code>: a Wasm app that provides the bindings for communication between the other two.</li>
</ul>
<p>The diagram below shows the app&#39;s flow:</p>
<ul>
<li><em>se2-mock-runtime</em> calls <code>run_e</code> defined in the <code>plugin.py</code> module.</li>
<li><code>plugin.py</code> calls <code>return_result</code> defined in <em>se2-mock-runtime</em></li>
</ul>
<picture>
<source type="image/avif" srcset="/static/images/opt/7RvrP_djfK-757.avif, /static/images/opt/7RvrP_djfK-1514.avif 2x"/>
<source type="image/jpeg" srcset="/static/images/opt/7RvrP_djfK-757.jpeg, /static/images/opt/7RvrP_djfK-1514.jpeg 2x"/>
<source type="image/webp" srcset="/static/images/opt/7RvrP_djfK-757.webp, /static/images/opt/7RvrP_djfK-1514.webp 2x"/>
<img src="https://wasmlabs.dev/static/images/opt/7RvrP_djfK-757.webp" width="1514" height="621" alt="se2-bindings showcase overview" loading="lazy" decoding="async"/>
</picture>
<h2 id="running-it" tabindex="-1">Running it</h2>
<p>You only need to have Docker. Then running this example boils down to</p>
<pre><code><span>export TMP_WORKDIR=$(mktemp -d)</span></code></pre>
<p>and you will get an output with extensive logging that looks like this:</p>
<picture>
<source type="image/avif" srcset="/static/images/opt/0oU9HU509X-757.avif, /static/images/opt/0oU9HU509X-1514.avif 2x"/>
<source type="image/jpeg" srcset="/static/images/opt/0oU9HU509X-757.jpeg, /static/images/opt/0oU9HU509X-1514.jpeg 2x"/>
<source type="image/webp" srcset="/static/images/opt/0oU9HU509X-757.webp, /static/images/opt/0oU9HU509X-1514.webp 2x"/>
<img src="https://wasmlabs.dev/static/images/opt/0oU9HU509X-757.webp" width="1514" height="576" alt="run_me.sh console output" loading="lazy" decoding="async"/>
</picture>
<p>You will notice a few extra logs around methods used for explicit memory management. They are explained in the <a href="https://github.com/vmware-labs/webassembly-language-runtimes/tree/c6cf6e11ffaef1624108dfc9581911ed11f3f42d/python/examples/bindings/se2-bindings#readme">README.md</a> companion to the example, and we will not discuss them here for simplicity.</p>
<p>For easier reading the logs are organized like this:</p>
<ul>
<li><code>se2-mock-runtime</code> logs start at the beginning of the line and the filename is dark orange</li>
<li><code>wasm-wrapper-c</code> logs are indented by one tab and the filename is green</li>
<li><code>plugin.py</code> logs are indented by two tabs and the filename is violet</li>
</ul>

<p>To get a better feel at the code and the whole showcase application, take a look at it <a href="https://github.com/vmware-labs/webassembly-language-runtimes/tree/c6cf6e11ffaef1624108dfc9581911ed11f3f42d/python/examples/bindings/se2-bindings">on GitHub</a>. There, you will find instructions on how to run it as well as more detailed explanation of its components.</p>
<h2 id="overview" tabindex="-1">Overview</h2>
<p>Let&#39;s take a closer look at each of the components</p>
<ul>
<li>
<p><em>se2-mock-runtime</em> - a Node JS app that mimics Suborbital&#39;s SE2 runtime</p>
<ul>
<li>loads a Wasm module (equivalent to an SE2 plugin)</li>
<li>calls its <code>run_e</code> method to execute the plugin logic with a sample script</li>
<li>provides <code>return_result</code> and <code>return_error</code>, which are used by the plugin to return execution result</li>
</ul>
</li>
<li>
<p><em>wasm-wrapper-c</em> - a Wasm module (written in C), which</p>
<ul>
<li>mimics an SE2 plugin by exporting the <code>run_e</code> method and using imported <code>return_result</code> or <code>return_error</code></li>
<li>uses <em>libpython</em> to embed the Python interpreter and thus forward the implementation of <code>run_e</code> to a Python script.</li>
</ul>
</li>
<li>
<p><em>py-plugin</em> - a Python app</p>
<ul>
<li>executed by the <em>wasm-wrapper-c</em> app</li>
<li>provides the actual implementation of <code>run_e</code> in pure Python - &#34;string reversal for words that contain only characters (without <code>&#39;</code>, <code>.</code>, etc.)&#34;</li>
</ul>
</li>
</ul>
<h2 id="using-libpython.a-and-the-python-c-api" tabindex="-1">Using libpython.a and the Python C API</h2>
<p>Embedding the Python interpreter is pretty straightforward. The <a href="https://docs.python.org/3/c-api/index.html">Python C API</a> is well documented and one can find multiple examples in Open Source software.</p>
<p>The challenge with WASI comes from the lack of support for dynamic libraries. Because of this we have to use <em>libpython</em> as a static library and link it into out Wasm module. For convenience, we added a <a href="https://github.com/vmware-labs/webassembly-language-runtimes/releases/download/python%2F3.11.3%2B20230428-7d1b259/libpython-3.11.3-wasi-sdk-19.0.tar.gz">libpython tarball</a> to our Python release. It contains all the necessary headers, and the <code>libpython.a</code> file is a fat library that has all other dependencies (like <code>zlib</code>, <code>libuuid</code>, <code>sqlite3</code>, etc.) incorporated.</p>
<p>Additionally, complex Python applications are likely to require a bigger stack size. To make sure we have enough and it&#39;s configured correctly, we added linker options to the configuration file in the above in the above tarball.</p>
<pre><code>// Linker configuration in lib/wasm32-wasi/pkg-config/libpython3.11.pc.</code></pre>
<p>This ensures a big enough stack of half a MB. Additionally, it places the stack before the global data thus ensuring that any stack overflow will lead to immediate Wasm trap, instead of silent global data corruptions (in some cases).</p>
<p>For more details on how to link a C app with <em>libpython</em> from WebAssembly Language Runtimes you can check out the <code>build-wasm.sh</code> and <code>CMakeLists.tst</code> files in <a href="https://github.com/vmware-labs/webassembly-language-runtimes/tree/c6cf6e11ffaef1624108dfc9581911ed11f3f42d/python/examples/bindings/se2-bindings/wasm-wrapper-c">WLR/python/examples/bindings/se2-bindings/wasm-wrapper-c/</a></p>
<h2 id="calling-a-python-function-from-the-host" tabindex="-1">Calling a Python function from the host</h2>
<p>Let&#39;s say we have this function in <code>plugin.py</code>. So how do we call it from the Wasm host?</p>
<pre><code><span>def</span> <span>run_e</span><span>(</span>payload<span>,</span> <span>id</span><span>)</span><span>:</span></code></pre>
<p>To get to call anything from the Wasm host we need to export it first from the Wasm module, which embeds the Python interpreter. As we better use simple types we represent the string as a pointer and length.</p>
<pre><code><span>__attribute__</span><span>(</span><span>(</span><span>export_name</span><span>(</span><span>&#34;run_e&#34;</span><span>)</span><span>)</span><span>)</span> <span>void</span> <span>run_e</span><span>(</span>u8 <span>*</span>ptr<span>,</span> i32 len<span>,</span> i32 id<span>)</span><span>;</span></code></pre>
<p>Then, translating this method to the Python one is straightforward with the Python C API. <strong>Skipping the error and memory handling</strong> it boils down to something like this:</p>
<pre><code><span>void</span> <span>run_e</span><span>(</span>u8 <span>*</span>ptr<span>,</span> i32 len<span>,</span> i32 id<span>)</span> <span>{</span></code></pre>
<p>The major method to examine here is <code>Py_BuildValue</code> and the Python docs about <a href="https://docs.python.org/3/c-api/arg.html#building-values">Building values</a>.</p>
<h2 id="calling-a-host-function-from-python-code" tabindex="-1">Calling a host function from Python code</h2>
<p>Let&#39;s say we have this host function.</p>
<pre><code></code></pre>
<p>To allow the Python code in <code>plugin.py</code> to access it we will need to create a Python module in C, which will translate from something like <code>def return_result(result, id)</code> to the function above.</p>
<p>A sample implementation (skipping error handling) of an SDK module with such function would look like:</p>
<pre><code><span>static</span> PyObject <span>*</span><span>sdk_return_result</span><span>(</span>PyObject <span>*</span>self<span>,</span> PyObject <span>*</span>args<span>)</span> <span>{</span></code></pre>
<p>Again, the core of this is in <code>PyArg_ParseTuple</code>, which is well documented in the Python docs about <a href="https://docs.python.org/3/c-api/arg.html#parsing-arguments">Parsing arguments</a>.</p>
<p>Finally, before we initialize the Python interpreter we just need to add the &#39;sdk&#39; module to the list of built-in modules. This will make it available via <code>import sdk</code> in the interpreted Python modules.</p>
<pre><code><span>PyImport_AppendInittab</span><span>(</span><span>&#34;sdk&#34;</span><span>,</span> <span>&amp;</span>PyInit_SdkModule<span>)</span><span>;</span></code></pre>
<h2 id="putting-it-all-together" tabindex="-1">Putting it all together</h2>
<p>You can see how this all fits together with our showcase application on the picture below.</p>
<ol>
<li>
<p>When the WasmHost calls <code>_start</code> on the Wasm module, it will call <code>_initialize</code> internally to</p>
<ul>
<li>add the <code>sdk</code> plugin as a built-in Python module</li>
<li>initialize the Python interpreter</li>
<li>load the <code>plugin</code> module (which will import the built-in <code>sdk</code> module)</li>
</ul>
</li>
<li>
<p>When the WasmHost calls <code>run_e</code> on the Wasm module, it will</p>
<ul>
<li>lookup the <code>run_e</code> function from the <code>plugin</code> module</li>
<li>translate the arguments via <code>Py_BuildValue</code></li>
<li>call the python function with those arguments</li>
</ul>
</li>
<li>
<p>When <code>run_e</code> in <code>plugin.py</code> calls <code>sdk.return_result</code>, the implementation in <code>sdk_module</code> will</p>
<ul>
<li>translate the argument via <code>Py_ParseTuple</code></li>
<li>call the imported <code>env:return_result</code> function with these translated arguments</li>
</ul>
</li>
</ol>
<picture>
<source type="image/avif" srcset="/static/images/opt/3GvKsKS3pu-757.avif, /static/images/opt/3GvKsKS3pu-1514.avif 2x"/>
<source type="image/jpeg" srcset="/static/images/opt/3GvKsKS3pu-757.jpeg, /static/images/opt/3GvKsKS3pu-1514.jpeg 2x"/>
<source type="image/webp" srcset="/static/images/opt/3GvKsKS3pu-757.webp, /static/images/opt/3GvKsKS3pu-1514.webp 2x"/>
<img src="https://wasmlabs.dev/static/images/opt/3GvKsKS3pu-757.webp" width="1514" height="625" alt="se2-bindings recap" loading="lazy" decoding="async"/>
</picture>

<p>Our showcase application includes a lot of manual work. In an ideal scenario, you will provide a <code>.wit</code> file declaring an API and can have the bindings code generated automatically.</p>
<p>There is already developers from multiple companies working on a more generic approach for using Python interchangeably with server-side Wasm. You can track the progress in the <a href="https://bytecodealliance.zulipchat.com/#narrow/stream/223391-wasm/topic/Python.20guest.20runtime.20and.20bindings">Python guest runtime and bindings</a> stream on the ByteCodeAlliance&#39;s Zulip space.</p>

<p>Give this showcase app a try <a href="https://github.com/vmware-labs/webassembly-language-runtimes/tree/c6cf6e11ffaef1624108dfc9581911ed11f3f42d/python/examples/bindings/se2-bindings">here</a>.</p>
<p>If you want to build something from scratch, you can find a pre-built <em>libpython</em> as part of our <a href="https://github.com/vmware-labs/webassembly-language-runtimes/releases/tag/python%2F3.11.3%2B20230428-7d1b259">recent Python release</a>. Don&#39;t forget <a href="#using-libpython.a-and-the-python-c-api">the linker options mentioned earlier on</a>.</p>
<p>Let us know what you think! If you find our work meaningful <a href="https://github.com/vmware-labs/webassembly-language-runtimes">give us a star in GitHub</a> and <a href="https://twitter.com/vmwwasm">follow us on Twitter</a>.</p>
</div></div>
  </body>
</html>
