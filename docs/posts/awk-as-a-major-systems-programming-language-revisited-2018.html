<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://www.skeeve.com/awk-sys-prog.html">Original</a>
    <h1>Awk as a major systems programming language, revisited (2018)</h1>
    
    <div id="readability-page-1" class="page">















<a name="Preface"></a>
<h2>Preface</h2>

<p>I started this paper in 2013, and in 2015 sent it out for review to the people
listed later on.  After incorporating comments, I sent it to Rik Farrow, the
editor of the USENIX magazine <cite>;login:</cite> to see if he would publish it.
He declined to do so, for reasonably good reasons.
</p>
<p>The paper languished, forgotten, until early 2018 when I came across it and
decided to polish it off, put it up on GitHub, and make it available from
my home page in HTML.
</p>
<p>If you are interested in language design and evolution in general, and in Awk
in particular, I hope you will enjoy reading this paper.  If not, then why
are you bothering looking at it now?
</p>
<p>Arnold Robbins </p>
<a name="Introduction"></a>
<h2>1 Introduction</h2>

<p>At the March 1991 USENIX conference, Henry Spencer presented a paper
entitled <cite>AWK As A Major Systems Programming Language</cite>.  In it,
he described his experiences using the original version of <code>awk</code>
to write two significant “systems” programs—a clone for a reasonable
subset of the <code>nroff</code> formatter<a name="DOCF1" href="#FOOT1"><sup>1</sup></a>,
and a simple parser generator.
</p>
<p>He described what <code>awk</code> did well, as well as what it didn’t, and
presented a list of things that <code>awk</code> would need to acquire
in order to take the position of a reasonable alternative to C for
systems programming tasks on Unix systems.
</p>
<p>In particular, <code>awk</code> lies about in the middle of the spectrum
between C, which is “close to the metal,” and the shell, which is
quite high-level.  A language at this level that is useful for
doing systems programming is very desirable.
</p>
<p>This paper reviews Henry’s wish list, and describes some of the events that
have occurred in the Unix/Linux world since 1991.
It presents a case that <code>gawk</code>—GNU Awk—fills most of the
major needs Henry listed way back in 1991, and then describes the
author’s opinion as to why other languages have successfully filled the
systems programming role which <code>awk</code> did not.  It discusses
how the current version of <code>gawk</code> may
finally be able to join the ranks of other popular, powerful, scripting
languages in common use today, and ends off with some counter-arguments
and the author’s responses to them.
</p>
<a name="Acknowledgements"></a>
<h4>Acknowledgements</h4>

<p>Thanks to Andrew Schorr, Henry Spencer, Nelson H.F. Beebe, and Brian Kernighan
for reviewing an earlier draft of this paper.
</p>
<a name="That-Was-Then-_2026"></a>
<h2>2 That Was Then …</h2>

<p>In this section we review the state of the Unix world in
1991, as well as the state of <code>awk</code>, and then list what Henry Spencer
saw as missing for <code>awk</code>.
</p>
<a name="The-Unix-World-in-1991"></a>
<h3>2.1 The Unix World in 1991</h3>

<p>Undoubtedly, many readers of this paper were not using
computers in 1991, so this section provides the context
in which Henry’s paper was written.  In March of 1991:
</p>
<ul>
<li> Commercial Unix systems were the norm, with offerings from
AT&amp;T,
Digital Equipment Corporation,
Hewlett Packard,
IBM,
Sun Microsystems,
and many others,
all vying for market share.  Microsoft Windows existed, but was
primarily a layer on top of MS-DOS and was not taken seriously.

</li><li> Very few sites still ran the original Bell Labs or direct-from-UCB
variants of Unix; those did not keep up with the available hardware
and AT&amp;T was itself trying to succeed in the Unix hardware market.

</li><li> GNU/Linux did not exist!  Some unencumbered BSD variants were available,
but they were still under the cloud of the AT&amp;T/UCB law suit.<a name="DOCF2" href="#FOOT2"><sup>2</sup></a>

</li><li> So-called “new” <code>awk</code> was about 2.5 years old.
The book by Aho, Weinberger and Kernighan was published in
October of 1987, so most people knew about new <code>awk</code>, but they
just couldn’t get it.

<p>Who could? New <code>awk</code> was available to educational institutions
from the Bell Labs research group, and to those who had Unix source
licenses for System V Releases 3.1, 3.2, and 4.  By this time, source
licensees were an extremely rare breed, since the cost for commercial
licenses had skyrocketed, and even for educational licensees it had
increased greatly.<a name="DOCF3" href="#FOOT3"><sup>3</sup></a> If I recall correctly,
an educational license cost around US $1,000, considerably more than
the earlier Unix licenses.
</p>
</li><li> PERL<a name="DOCF4" href="#FOOT4"><sup>4</sup></a> existed and was starting to gain in popularity. In 1991,
“PERL” most likely meant PERL 3 or a very early version of PERL 4.
The World Wide Web, which was one of the major reasons for PERL’s growth
in popularity, had not yet really taken off.

</li><li> Other implementations of new <code>awk</code> were available:

<ul>
<li>+ MKS Awk for PC systems (MS-DOS).

</li><li>+ GNU Awk was available and relatively stable, but could not be
called “solid.”
</li></ul>

<p>The problem with the first of these is that source code was not
available. And the latter came with (to quote Henry) “troublesome
licenses.”  (Actually, Henry no longer remembers whether his statement
about “troublesome licenses” referred to the GPL, or to the Bell Labs
source licenses.)
</p>
</li><li> Michael Brennan’s <code>mawk</code> (also GPL’ed) was <em>not</em> yet available.
Version 1.0 was accepted for posting in <code>comp.sources.reviewed</code>
on September 30, 1991, half a year after Henry’s paper was published.
</li></ul>

<a name="What-Awk-Lacked-In-1991"></a>
<h3>2.2 What Awk Lacked In 1991</h3>

<p>Here is a summary of what was wrong with the <code>awk</code> picture
in 1991.  These are in the same order as presented Henry’s paper.
We qualify each issue in order to later discuss how it has been addressed
over time.
</p>
<ol>
<li> New <code>awk</code> was not widely available. Most Unix vendors
still shipped only old <code>awk</code>.  (Here is where he mentions that
“the independently-available implementations either cost substantial
amounts of money or come with troublesome [sic] licenses.”) His point then
was that for portability, <code>awk</code> programs had to be restricted
to old <code>awk</code>.

<p>This could be considered a quality of implementation issue, although
it’s really a “lack of available implementation” issue.
</p>
</li><li> There is no way to tell <code>awk</code> to start matching all its
patterns over again against the existing <code>$0</code>.
This is a language design issue.

</li><li> There is no array assignment.
(Language design issue.)

</li><li> Getting an error message out to standard error is difficult.
(Implementation issue.)

</li><li> There is no precise language specification for <code>awk</code>.
This leads to gratuitous portability problems.
This too is thus a quality of implementation issue, in that without
a specification, it’s difficult to produce uniform, high quality
implementations.

</li><li> The existing widely available implementation is slow; a much
faster implementation is needed and the best thing of all would be
an optimizing compiler.
(Implementation issue.)

</li><li> There is no <code>awk</code>-level debugger.
(Support tool or quality of implementation issue.)

</li><li> There is no <code>awk</code>-level profiler.
(Support tool or quality of implementation issue.)
</li></ol>

<p>In private email, Henry added the following items, saying
“there are a couple more things I’d add now, in hindsight.”
These are direct quotes:
</p>
<ol start="9">
<li> [I can’t believe I didn’t discuss this in the paper, because I was
certainly aware of it then!]  Lack of any convenient mechanism for adding
libraries.  When <code>awk</code> is being invoked from a shell file, the
shell file can do substitutions or use multiple <samp>-f</samp> options, but
those are mechanisms outside the language, and not very convenient ones.
What’s really wanted is something like you get in Python etc., where one
little statement up near the top says “arrange for this program to have
the xyz library available when it runs.”

</li><li> I think it was Rob Pike who later said (roughly):  “It says something
bad about Awk that in a language with integrated regular expressions,
you end up using <code>substr()</code> so often.”  My paper did allude
to the difficulty of finding out <em>where</em> something matched in
old-<code>awk</code> programs, but even in new <code>awk</code>, what you get
is a number that you then have to feed to <code>substr()</code>.  The language
could really use some more convenient way of dissecting a string using
regexp matching.  [Caveat:  I have not looked lately at Gawk to see if
it has one.]
</li></ol>

<p>The first of these is somewhere between a language design and a
language implementation issue. The latter is a language design issue.
</p>
<a name="g_t_2026-And-This-Is-Now"></a>
<h2>3 … And This Is Now</h2>

<p>Fast forward to 2018.  Where do things stand?
</p>
<a name="What-Awk-Has-Today"></a>
<h3>3.1 What Awk Has Today</h3>

<p>The state of the <code>awk</code> world is much better now.
In the same order:
</p>
<ol>
<li> New <code>awk</code> is the standard version of <code>awk</code>
today on GNU/Linux, BSD, and commercial Unix systems.
The one notable exception is Solaris, where <samp>/usr/bin/awk</samp>
is still the old one; on all other systems, plain <code>awk</code>
is some version of new <code>awk</code>.

</li><li> There remains no way to tell <code>awk</code> to start matching all its
patterns over again against the existing <code>$0</code>.  Furthermore,
this is a feature that has not been called for by the <code>awk</code>
community, except in Henry’s paper.  (We do acknowledge that this might
be a useful feature.)

</li><li> There continues to be no array assignment.
However, this function in <code>gawk</code>, which has arrays of arrays, can do
the trick nicely. It is also efficient, since <code>gawk</code> uses
reference counted strings internally:

<div>
<pre>function copy_array(dest, source,   i, count)
{
    delete dest

    for (i in source) {
        if (typeof(source[i]) == &#34;array&#34;)
            count += copy_array(dest[i], source[i])
        else {
            dest[i] = source[i]
            count++
        }
    }

    return count
}
</pre></div>

</li><li> Getting error messages out is easier. All modern systems have
a <samp>/dev/stderr</samp> special file to which error messages
may be sent directly.

</li><li> Perhaps most important of all, with the
<a href="http://pubs.opengroup.org/onlinepubs/9699919799/utilities/awk.html">POSIX standard</a>,
there is a formal standard specification
for <code>awk</code>. As with all formal standards, it isn’t
perfect. But it provides an excellent starting point, as well
as chapter and verse to cite when explaining the behavior
of a standards-compliant version of <code>awk</code>.

</li><li> There are a number of freely available implementations, with
different licenses, such that everyone ought to be able to find
a suitable one:

<ul>
<li> Brian Kernighan’s <code>awk</code> is the direct lineal
descendant of Unix <code>awk</code>. He calls it the “One
True Awk” (sic). It is available from
<a href="http://www.cs.princeton.edu/~bwk">his home page</a>,
in several archive formats:

<dl compact="compact">
<dt>Shell archive:</dt>
<dd><p><a href="http://www.cs.princeton.edu/~bwk/btl.mirror/awk.shar">http://www.cs.princeton.edu/~bwk/btl.mirror/awk.shar</a>
</p>
</dd>
<dt>Compressed <code>tar</code> file:</dt>
<dd><p><a href="http://www.cs.princeton.edu/~bwk/btl.mirror/awk.tar.gz">http://www.cs.princeton.edu/~bwk/btl.mirror/awk.tar.gz</a>
</p>
</dd>
<dt>Zip file:</dt>
<dd><p><a href="http://www.cs.princeton.edu/~bwk/btl.mirror/awk.zip">http://www.cs.princeton.edu/~bwk/btl.mirror/awk.zip</a>
</p>
</dd>
<dt>Git Hub:</dt>
<dd><p><code>git clone git://github.com/onetrueawk/awk bwkawk</code>
</p></dd>
</dl>

</li><li> GNU Awk, <code>gawk</code>, is available from the Free Software Foundation.
You may use either <code>ftp</code> or an HTTP downloader:
<a href="http://ftp.gnu.org/gnu/gawk/gawk-4.2.1.tar.gz">http://ftp.gnu.org/gnu/gawk/gawk-4.2.1.tar.gz</a> is the current
version. There may be a newer one.

</li><li> Michael Brennan’s <code>awk</code>, known as <code>mawk</code>.
In 2009, Thomas Dickey took on <code>mawk</code> maintenance.
Basic information is available on
<a href="http://www.invisible-island.net/mawk">the project’s web page</a>.
The download URL is
<a href="http://invisible-island.net/datafiles/release/mawk.tar.gz">http://invisible-island.net/datafiles/release/mawk.tar.gz</a>.

<p>In 2017 Michael published a beta of <code>mawk</code> 2.0. It’s available from
the project’s <a href="https://github.com/mikebrennan000/mawk-2">GitHub page</a>.
</p>
</li><li> MKS Awk was used for Solaris’s <samp>/usr/xpg4/bin/awk</samp>, which is
their standards-compliant version of new <code>awk</code>. For a while it was
available as part of Open Solaris, but is no longer so.
Some years ago, we were able to make this version compile and run on
GNU/Linux after just a few hours work.

<p>Although Open Solaris is now history, the
<a href="http://wiki.illumos.org/display/illumos/illumos+Home">Illumos project</a>
does make the MKS Awk available.  You can view the files one at a time from
<a href="https://github.com/joyent/illumos-joyent/blob/master/usr/src/cmd/awk_xpg4">https://github.com/joyent/illumos-joyent/blob/master/usr/src/cmd/awk_xpg4</a>.
</p>
</li><li> Other, more esoteric versions as well. See the
<a href="http://en.wikipedia.org/wiki/Awk_language#Versions_and_implementations">Wikipedia article</a>, and also the
<a href="http://www.gnu.org/software/gawk/manual/html_node/Other-Versions.html#Other-Versions"><code>gawk</code> documentation</a>.
</li></ul>

</li></ol>

<a name="And-What-GNU-Awk-Has-Today"></a>
<h3>3.2 And What GNU Awk Has Today</h3>

<p>The more difficult of the quality of implementation issues are addressed
by <code>gawk</code>.  In particular:
</p>
<ol start="7">
<li> Beginning with version 4.0 in 2011, <code>gawk</code> provides an
<code>awk</code>-level debugger: <code>dgawk</code>, which is
modeled after GDB.
This is a full debugger, with breakpoints, watchpoints, single statement
stepping and expression evaluation capabilities.

</li><li> <code>gawk</code> has provided an <code>awk</code>-level statement profiler for
many years (<code>pgawk</code>).
Although there is no direct correlation with CPU time used, the
statement level profiler remains a powerful tool for understanding
program behavior.

</li><li> Since version 4.0, <code>gawk</code> has had an ‘<samp>@include</samp>’ facility
whereby <code>gawk</code> goes and finds the named <code>awk</code> source
progrm.  For much longer it has searched for files specified with
<samp>-f</samp> along the path named by the <code>AWKPATH</code> environment variable.
The ‘<samp>@include</samp>’ mechanism also uses <code>AWKPATH</code>.

</li><li> In terms of getting at the pieces of text matched by a regular expression,
<code>gawk</code> provides an optional third argument to the <code>match()</code>
function. This argument is an array which <code>gawk</code> fills in with both
the matched text for the full regexp and subexpressions, and index and length
information for use with <code>substr()</code>.  <code>gawk</code> also provides the
<code>gensub()</code> general substitution function, an enhanced version of the
<code>split()</code> function, and the <code>patsplit()</code> function for specifying
contents instead of separators using a regexp.
</li></ol>

<p>With the 4.1 release, all three versions (<code>gawk</code>,
<code>pgawk</code>, and <code>dgawk</code>) are merged into a single
executable, considerably reducing the required installation “footprint.”
</p>
<p>While <code>gawk</code> has almost always been faster than Brian
Kernighan’s <code>awk</code>, recent performance improvements bring
it closer to <code>mawk</code>’s performance level (a byte-code based
execution engine and internal improvements in array indexing).
</p>
<p>And <code>gawk</code> clearly has the most features of any version,
many of which considerably increase the power of the language.
</p>
<a name="So-Where-Does-Awk-Stand_003f"></a>
<h3>3.3 So Where Does Awk Stand?</h3>

<p>Despite all of the above, <code>gawk</code> is not as popular as other
scripting languages. Since 1991, we can point to four major scripting
languages which have enjoyed, or currently enjoy, differing levels of
popularity: PERL, tcl/tk, Python, and Ruby.  We think it is fair to say
that Python and Ruby are the most popular scripting languages in the
second decade of the 21st century.
</p>
<p>Is <code>awk</code>, as we’ve described it up to this point, now ready to
compete with the other languages?  Not quite yet.
</p>
<a name="Key-Reasons-Why-Other-Languages-Have-Gained-Popularity"></a>
<h2>4 Key Reasons Why Other Languages Have Gained Popularity</h2>

<p>In retrospect, it seems clear (at least to us!) that there are two
major reasons that all of the previously mentioned languages have enjoyed
significant popularity. The first is their <em>extensibility</em>.
The second is <em>namespace management</em>.
</p>
<p>One certainly cannot attribute their popularity to improved syntax.
In the opinion of many, PERL and Ruby both suffer from terrible syntax.
Tcl’s syntax is readable but nothing special. Python’s syntax is elegant,
although slightly unusual.  The point here is that they all differ greatly
in syntax, and none really offers the clean pattern–action paradigm
that is <code>awk</code>’s trademark, yet they are all popular languages.
</p>
<p>If not syntax, then what?  We believe that their popularity stems from
the fact that all of these languages are easily <em>extensible</em>. This is true
with both “modules” in the scripting language, and more importantly,
with access to C level facilities via dynamic library loading.
</p>
<p>Furthermore, these languages allow you to group related functions and 
variables into packages or modules: they let you manage the namespace.
</p>
<p><code>awk</code>, on the other hand, has always been closed. An <code>awk</code>
program cannot even change its working directory, much less open
a connection to an SQL database or a socket to a server on the
Internet somewhere (although <code>gawk</code> can do the latter).
</p>
<p>If one examines the number of extensions available for PERL on CPAN,
or for Python such as PyQt or the Python tk bindings, it becomes
clear that extensibility is the real key to power (and from there
to popularity).
</p>
<p>Furthermore, in <code>awk</code>, all global variables and functions
share a single namespace. This prevents many good software development
practices based on the principle of information hiding.
</p>
<p>To summarize: A reasonable language definition, efficient implementations,
debuggers and profilers are necessary but not sufficient for true power.
The final ingredients are <em>extensibility</em> and <em>namespaces</em>.
</p>
<a name="Filling-The-Extensibility-Gap"></a>
<h2>5 Filling The Extensibility Gap</h2>

<p>With version 4.1, <code>gawk</code> (finally) provides a defined C API
for extending the core language.
</p>
<a name="API-Overview"></a>
<h3>5.1 API Overview</h3>

<p>The API makes it possible to write functions in C or C++ that are
callable from an <code>awk</code> program as if the function were
written in <code>awk</code>.  The most straightforward way to think
of these functions is as user-defined functions that happen to be
implemented in a different language.
</p>
<p>The API provides the following facilities:
</p>
<ul>
<li> Structures that map <code>awk</code> string, numeric, and undefined values
into C types that can be worked with.

</li><li> Management of function parameters, including the ability to convert
a parameter whose original type is undefined, into an array. That is,
there is full call-by-reference for arrays.  Scalars are passed by
value, of course.

</li><li> Access to the symbol table. Extension functions can read all <code>awk</code>
variables, and create and update new variables. As an initial, relatively
arbitrary design decision, extensions cannot update special variables such as
<code>NR</code> or <code>NF</code>, with the single exception of <code>PROCINFO</code>.

</li><li> Full array management, including the ability to create arrays, and arrays
of arrays, and the ability to add and delete elements from an array. It
is also possible to “flatten” an array into a data structure that
makes it simple for C code to loop over all the elements of an array.

</li><li> The ability to run a procedure when <code>gawk</code> exits. This is conceptually
the same as the C <code>atexit()</code> function.

</li><li> Hooks into the built-in I/O redirection mechanisms in <code>gawk</code>.
In particular, there are separate facilities for input redirections
with <code>getline</code> and ‘<samp>&lt;</samp>’, output redirections with
<code>print</code> or <code>printf</code> and ‘<samp>&gt;</samp>’ or ‘<samp>&gt;&gt;</samp>’, and two-way
pipelines with <code>gawk</code>’s ‘<samp>|&amp;</samp>’ operator.

</li></ul>

<a name="Discussion"></a>
<h3>5.2 Discussion</h3>

<p>Considerable thought went into the design of the API.
The <code>gawk</code> documentation provides a
<a href="http://www.gnu.org/software/gawk/manual/html_node/Dynamic-Extensions.html#Dynamic-Extensions">full description of the API itself</a>,
with examples (over 50 pages worth!), as well as
<a href="http://www.gnu.org/software/gawk/manual/html_node/Extension-Design.html#Extension-Design">some discussion of the goals and design decisions</a>
behind the API (in an appendix).
The development was done over the course of
about a year and a half, together with the developers of <code>xgawk</code>,
a fork of <code>gawk</code> that added features that made using extensions
easier, and included an extension for processing XML files in a way that
fit naturally with the pattern–action paradigm.  While it may not be
perfect, the <code>gawk</code> developers feel that it is a good start.
</p>
<p><strong>FIXME</strong>: Henry Spencer suggests adding more info on the API and
on the design decisions.
I think this paper is long enough, and the full doc is quite big.
It’d be hard to pull API doc into this paper in a reasonable fashion,
although it would be possible to review some of the design decisions.
Comments?
</p>
<p>The major <code>xgawk</code> additions to the C code base have been merged
into <code>gawk</code>, and the extensions from that project have been
rewritten to use the new API.  As a result, the <code>xgawk</code> project
developers renamed their project <code>gawkextlib</code>, and the project now
provides only extensions.<a name="DOCF5" href="#FOOT5"><sup>5</sup></a>
</p>
<p>It is notable that functions written in <code>awk</code> can do a number
of things that extension functions cannot, such as modify any
variables, do I/O, call <code>awk</code> built-in functions,
and call other user-defined functions.
</p>
<p>While it would certainly be possible to provide APIs for all of these
features for extension functions, this seemed to be overkill.  Instead,
the <code>gawk</code> developers took the view that extension functions
should provide access to external facilities, and provide communication
to the <code>awk</code> level via function parameters and/or global variables,
including associative arrays, which are the only real data structure.
</p>
<p>Consider a simple example.  The standard <code>du</code> program
can recursively walk one or more arbitrary file hierarchies, call
<code>stat()</code> to retrieve file information, and then sum up the blocks
used.  In the process, <code>du</code> must track hard links, so that no
file is accounted for or reported more than once.
</p>
<p>The ‘<samp>filefuncs</samp>’ extension shipped with <code>gawk</code> provides a
<code>stat()</code> function that takes a pathname and fills in an associative
array with the information retrieved from <code>stat()</code>.  The array
elements have names like <code>&#34;size&#34;</code>, <code>&#34;mtime&#34;</code> and so on, with
corresponding appropriate values.  (Compare this to PERL’s <code>stat()</code>
function that returns a linearly-indexed array!)
</p>
<p>The <code>fts()</code> function in the ‘<samp>filefuncs</samp>’ extension builds on
<code>stat()</code> to create a multidimensional array of arrays that describes
the requested file hierarchies, with each element being an array filled
in by <code>stat()</code>. Directories are arrays containing elements for each
directory entry, with an element named <code>&#34;.&#34;</code> for the array itself.
</p>
<p>Given that <code>fts()</code> does the heavy lifting, <code>du</code> can be
written quite nicely, and quite portably<a name="DOCF6" href="#FOOT6"><sup>6</sup></a>, in <code>awk</code>.  See <a href="#du-in-awk">du in awk</a>, for the
code, which weighs in at under 250 lines.  Much of this is comments and
argument parsing.
</p>
<a name="Future-Work"></a>
<h3>5.3 Future Work</h3>

<p>The extension facility is relatively new, and undoubtedly has introduced new
“dark corners” into <code>gawk</code>.  These remain to be uncovered
and any new bugs need to be shaken out and removed.
</p>
<p>Some issues are known and may not be resolvable. For example, 64-bit
integer values such as the timestamps in <code>stat()</code> data on modern
systems don’t fit into <code>awk</code>’s 64-bit double-precision
numbers which only have 53 bits of significand. This is also a
problem for the bit-manipulation functions.
</p>
<p>With respect to namespaces, in 2017 I (finally) figured out how
namespaces in <code>awk</code> ought to work to provide the needed
functionality while retaining backwards compatibility.
The code is currently in the <code>feature/namespaces</code> branch
of <code>gawk</code>’s Git repository. It will eventually be merged
into the <code>master</code> branch for release as part of <code>gawk</code> 5.0.
</p>
<p><strong>FIXME</strong>: More info needed here.
</p>
<a name="Counterpoints"></a>
<h2>6 Counterpoints</h2>

<p>Brian Kernighan raised several counterpoints in response to
an earlier draft of the paper. They are worth addressing (or
at least trying to):
</p>
<blockquote>
<p>I’m not 100% convinced by your basic premise, that the lack of an
extension mechanism is the main / a big reason why Awk isn’t used for
the kinds of system programming tasks that Perl, Python, etc., are.
It’s absolutely a factor—without such a mechanism, there’s just no
way to do a lot of important computations.  But how does that trade off
against just having built-in mechanisms for the core system programming
facilities (as Perl does) or a handful of core libraries like <code>sys</code>,
<code>os</code>, <code>regex</code>, etc., for Python?
</p></blockquote>

<p>I think that Perl’s original inclusion of most of the Unix system calls
was, <em>from a language design standpoint</em>, ultimately a mistake. At
the time it was first done, there was no other choice: dynamic loading
of libraries didn’t exist on Unix systems in the early and mid-1980s
(nor did shared libraries, for that matter).  But having all those
built-in functions bloats the language, making it harder to learn,
document, and maintain, and I definitely did not wish to go down that
path for <code>gawk</code>.
</p>
<p>With respect to Python, the question is: how are those libraries
implemented? Are they built-in to the interpreter and separated from the
“core” language simply by the language design? Or are they dynamically
loaded modules?
</p>
<p>If the latter, that sounds like an argument <em>for</em> the case of having
extensions, not against it.  And indeed, this merely emphasizes the
point made at the end of the previous section, which is that to make an
extension facility really scalable, you also need some sort of namespace /
module capability.
</p>
<p>Thus, Brian is correct: an extension facility is needed, but the
last part of the puzzle would be a module facility in the language.
I think that I have solved this, and invite the curious reader to
checkout the branch named earlier and provide feedback.
</p>
<blockquote>
<p>I’m also not convinced that Awk is the right language for writing
things that need extensions.  It was originally designed for 1-liners,
and a lot of its constructs don’t scale up to bigger programs.  The
notation for function locals is appalling (all my fault too, which makes
it worse).  There’s little chance to recover from random spelling
mistakes and typos; the use of mere adjacency for concatenation looks
ever more like a bad idea.
</p></blockquote>

<p>This is hard to argue with.  Nonetheless, <code>gawk</code>’s <samp>--lint</samp>
option may be of help here, as well as the <samp>--dump-variables</samp>
option which produces a list of all variables used in the program.
</p>
<blockquote>
<p>Awk is fine for its original purpose, but I find myself writing Python
for anything that’s going to be bigger than say 10-20 lines unless the
lines are basically just longer pattern-action sequences.  (That
notation is a win, of course, which you point out.)
</p></blockquote>

<p>Since my Python experience is minimal, I have little to say here;
it might be that if I were more familiar with Python, I would start
using it for small scripts instead of <code>awk</code>.
</p>
<p>On the other hand, with discipline, it’s possible to write fairly
good-sized, understandable and maintainable <code>awk</code> programs;
in my experience <code>awk</code> does scale up well beyond the one-liner
range.
</p>
<p>Not to mention that Brian published a whole book of <code>awk</code>
programs larger than one line. <code>:-)</code> (See the Resources section.)
</p>
<p>Some of my own, good-sized <code>awk</code> programs are available
from GitHub:
</p>
<dl compact="compact">
<dt>The TexiWeb Jr. literate programming system</dt>
<dd><p>See <a href="https://github.com/arnoldrobbins/texiwebjr">https://github.com/arnoldrobbins/texiwebjr</a>.
The suite has two programs that total over 1,300 lines
of <code>awk</code>. (They share some code.)
</p>
</dd>
<dt>Prepinfo</dt>
<dd><p>See <a href="https://github.com/arnoldrobbins/prepinfo">https://github.com/arnoldrobbins/prepinfo</a>.
This script processes Texinfo files, updating menus
as needed. This version is rewritten in TexiWeb Jr.; it’s
about 350 lines of <code>awk</code>.
</p>
</dd>
<dt>Sortmail</dt>
<dd><p>See <a href="https://github.com/arnoldrobbins/sortmail">https://github.com/arnoldrobbins/sortmail</a>.
This script sorts a Unix mbox format mailbox by thread.
I use it daily.  It’s also written in TexiWeb Jr. and
is about 330 lines of <code>awk</code>.
</p>
</dd>
</dl>

<p>Brian continues:
</p>
<blockquote>
<p>The <code>du</code> example is awfully big, though it does show off some of the
language features.  Could you get the same mileage with something
quite a bit shorter?
</p></blockquote>

<p>My definition of “small” and “big” has changed over time. 250 lines
may be big for a script, but the <code>du.awk</code> program is much smaller
than a full implementation in C:  GNU <code>du</code> is over 1,100 lines
of C, plus all the libraries it relies upon in the GNU Coreutils.
</p>
<p>With respect to shorter examples, nothing springs to mind immediately.
However, <code>gawk</code> comes with several useful extensions that
are worth exploring, much more than we’ve covered here.
</p>
<p>For example, the <code>readdir</code> extension in the <code>gawk</code>
distribution causes <code>gawk</code> to read directories and return one
record per directory entry in an easy-to-parse format:
</p>
<div>
<pre>$ <kbd>gawk -lreaddir &#39;{ print }&#39; .</kbd>
-| 2109292/mail.mbx/f
-| 2109295/awk-sys-prog.texi/f
-| 2100007/./d
-| 2100056/texinfo.tex/f
-| 2100055/cleanit/f
-| 2109282/awk-sys-prog.pdf/f
-| 2100009/du.awk/f
-| 2100010/.git/d
-| 2098025/../d
-| 2109294/ChangeLog/f
</pre></div>

<p>How cool is that?!? <code>:-)</code>
</p>
<p>Also, the <code>gawkextlib</code> project provides some very interesting
extensions.  Of particular interest are the XML and JSON extensions,
but there are a number of others, and it’s worth checking out.
</p>
<p>In short, it’s too early to really tell. This is the beginning of
an experiment. I hope it will be a fun journey for me, the other
<code>gawk</code> maintainers, and the larger community of <code>awk</code>
users.
</p>
<a name="Conclusion"></a>
<h2>7 Conclusion</h2>

<p>It has taken much longer than any <code>awk</code> fan would like, but finally,
GNU Awk fills in almost all the gaps listed by Henry Spencer for
<code>awk</code> to be really useful as a systems programming language.
</p>
<p>In addition, experience from other popular languages has shown that
extensibility and namespaces are the keys to true power,
usability, and popularity.
</p>
<p>With the release of <code>gawk</code> 4.1, we feel that <code>gawk</code>
(and thus the Awk language) are now almost on par with the basic capabilities
of other popular languages. With <code>gawk</code> 5.0, we hope to truly
reach par.
</p>
<p>Is it too late in the game?
If enough people start to write extensions for <code>gawk</code>,
then perhaps <code>awk</code> will return to the scripting language limelight.
If not, then the <code>gawk</code> developers will have wasted a
lot of time and effort. (We hope not!) Time will tell.
</p>
<p>For now though, we hope that this paper will have piqued <em>your</em>
curiosity, and that you will take the time to give <code>gawk</code>
a fresh look.
</p>
<a name="Resources"></a>
<h2>Appendix A Resources</h2>

<ol>
<li> <cite>The AWK Programming Language Paperback</cite>,
Alfred V. Aho, Brian W. Kernighan, and Peter J. Weinberger.
Addison-Wesley, 1988.
ISBN-13: 978-0201079814, ISBN-10: 020107981X.

</li><li> <cite>Effective awk Programming</cite>, fourth edition.
Arnold Robbins.
O’Reilly Media, 2015.
ISBN-13: 978-1491904619, ISBN-10: 1491904615.

</li><li> Online version of the <code>gawk</code> documentation:
<a href="http://www.gnu.org/software/gawk/manual/">http://www.gnu.org/software/gawk/manual/</a>.

</li><li> The <code>gawkextlib</code> project:
<a href="http://sourceforge.net/projects/gawkextlib/">http://sourceforge.net/projects/gawkextlib/</a>.
</li></ol>

<a name="du-in-awk"></a>
<a name="Awk-Code-For-du"></a>
<h2>Appendix B Awk Code For <code>du</code></h2>

<p>Here is the <code>du</code> program, written in Awk.
Besides demonstrating the power of the <code>stat()</code> and <code>fts()</code>
extensions and <code>gawk</code>’s multidimensional arrays,
it also shows the <code>switch</code> statement and the built-in
bit manipulation functions <code>and()</code>, <code>or()</code>, and <code>compl()</code>.
</p>
<p>The output is not identical to GNU <code>du</code>’s, since filenames are
not sorted.  However, <code>gawk</code>’s built-in sorting facilities
should make sorting the output straightforward; we leave that as the
traditional “exercise for the reader.”
</p>
<div>
<pre>#! /usr/local/bin/gawk -f

# du.awk --- write POSIX du utility in awk.
# See http://pubs.opengroup.org/onlinepubs/9699919799/utilities/du.html
#
# Most of the heavy lifting is done by the fts() function in the &#34;filefuncs&#34;
# extension.
#
# We think this conforms to POSIX, except for the default block size, which
# is set to 1024. Following GNU standards, set POSIXLY_CORRECT in the
# environment to force 512-byte blocks.
#
# Arnold Robbins
# arnold@skeeve.com

@include &#34;getopt&#34;
@load &#34;filefuncs&#34;

BEGIN {
    FALSE = 0
    TRUE = 1

    BLOCK_SIZE = 1024   # Sane default for the past 30 years
    if (&#34;POSIXLY_CORRECT&#34; in ENVIRON)
        BLOCK_SIZE = 512        # POSIX default

    compute_scale()

    fts_flags = FTS_PHYSICAL
    sum_only = FALSE
    all_files = FALSE

    while ((c = getopt(ARGC, ARGV, &#34;aHkLsx&#34;)) != -1) {
        switch (c) {
        case &#34;a&#34;:
            # report size of all files
            all_files = TRUE;
            break
        case &#34;H&#34;:
            # follow symbolic links named on the command line
            fts_flags = or(fts_flags, FTS_COMFOLLOW)
            break
        case &#34;k&#34;:
            BLOCK_SIZE = 1024       # 1K block size
            break
        case &#34;L&#34;:
            # follow all symbolic links

            # fts_flags &amp;= ~FTS_PHYSICAL
            fts_flags = and(fts_flags, compl(FTS_PHYSICAL))

            # fts_flags |= FTS_LOGICAL
            fts_flags = or(fts_flags, FTS_LOGICAL)
            break
        case &#34;s&#34;:
            # do sums only
            sum_only = TRUE
            break
        case &#34;x&#34;:
            # don&#39;t cross filesystems
            fts_flags = or(fts_flags, FTS_XDEV)
            break
        case &#34;?&#34;:
        default:
            usage()
            break
        }
    }

    # if both -a and -s
    if (all_files &amp;&amp; sum_only)
        usage()

    for (i = 0; i &lt; Optind; i++)
        delete ARGV[i]

    if (Optind &gt;= ARGC) {
        delete ARGV     # clear all, just to be safe
        ARGV[1] = &#34;.&#34;   # default to current directory
    }

    fts(ARGV, fts_flags, filedata)  # all the magic happens here

    # now walk the trees
    if (sum_only)
        sum_walk(filedata)
    else if (all_files)
        all_walk(filedata)
    else
        top_walk(filedata)
}

# usage --- print a message and die

function usage()
{
    print &#34;usage: du [-a|-s] [-kx] [-H|-L] [file] ...&#34; &gt; &#34;/dev/stderr&#34;
    exit 1
}

# compute_scale --- compute the scale factor for block size calculations

function compute_scale(     stat_info, blocksize)
{
    stat(&#34;.&#34;, stat_info)

    if (! (&#34;devbsize&#34; in stat_info)) {
        printf(&#34;du.awk: you must be using filefuncs extension from gawk 4.1.1 or later\n&#34;) &gt; &#34;/dev/stderr&#34;
        exit 1
    }

    # Use &#34;devbsize&#34;, which is the units for the count of blocks
    # in &#34;blocks&#34;.
    blocksize = stat_info[&#34;devbsize&#34;]
    if (blocksize &gt; BLOCK_SIZE)
        SCALE = blocksize / BLOCK_SIZE
    else    # I can&#39;t really imagine this would be true
        SCALE = BLOCK_SIZE / blocksize
}

# islinked --- return true if a file has been seen already

function islinked(stat_info,        device, inode, ret)
{
    device = stat_info[&#34;dev&#34;]
    inode = stat_info[&#34;ino&#34;]

    ret = ((device, inode) in Files_seen)

    return ret
}

# file_blocks --- return number of blocks if a file has not been seen yet

function file_blocks(stat_info,     device, inode)
{
    if (islinked(stat_info))
        return 0

    device = stat_info[&#34;dev&#34;]
    inode = stat_info[&#34;ino&#34;]

    Files_seen[device, inode]++

    return block_count(stat_info)   # delegate actual counting
}

# block_count --- return number of blocks from a stat() result array

function block_count(stat_info,     result)
{
    if (&#34;blocks&#34; in stat_info)
        result = int(stat_info[&#34;blocks&#34;] / SCALE)
    else
        # otherwise round up from size
        result = int((stat_info[&#34;size&#34;] + (BLOCK_SIZE - 1)) / BLOCK_SIZE)

    return result
}

# sum_dir --- data on a single directory

function sum_dir(directory, do_print,   i, sum, count)
{
    for (i in directory) {
        if (&#34;.&#34; in directory[i]) {  # directory
            count = sum_dir(directory[i], do_print)
            count += file_blocks(directory[i][&#34;.&#34;])
            if (do_print)
                printf(&#34;%d\t%s\n&#34;, count, directory[i][&#34;.&#34;][&#34;path&#34;])
        } else {            # regular file
            count = file_blocks(directory[i][&#34;stat&#34;])
        }
        sum += count
    }

    return sum
}

# simple_walk --- summarize directories --- print info per parameter

function simple_walk(filedata, do_print,    i, sum, path)
{
    for (i in filedata) {
        if (&#34;.&#34; in filedata[i]) {   # directory
            sum = sum_dir(filedata[i], do_print)
            path = filedata[i][&#34;.&#34;][&#34;path&#34;]
        } else {            # regular file
            sum = file_blocks(filedata[i][&#34;stat&#34;])
            path = filedata[i][&#34;path&#34;]
        }
        printf(&#34;%d\t%s\n&#34;, sum, path)
    }
}

# sum_walk --- summarize directories --- print info only for the top set of directories

function sum_walk(filedata)
{
    simple_walk(filedata, FALSE)
}

# top_walk --- data on the main arguments only

function top_walk(filedata)
{
    simple_walk(filedata, TRUE)
}

# all_walk --- data on every file

function all_walk(filedata, i, sum, count)
{
    for (i in filedata) {
        if (&#34;.&#34; in filedata[i]) {   # directory
            count = all_walk(filedata[i])
            sum += count
            printf(&#34;%s\t%s\n&#34;, count, filedata[i][&#34;.&#34;][&#34;path&#34;])
        } else {            # regular file
            if (! islinked(filedata[i][&#34;stat&#34;])) {
                count = file_blocks(filedata[i][&#34;stat&#34;])
                sum += count
                if (i != &#34;.&#34;)
                    printf(&#34;%d\t%s\n&#34;, count, filedata[i][&#34;path&#34;])
            }
        }
    }
    return sum
}
</pre></div>


<hr/>





</div>
  </body>
</html>
