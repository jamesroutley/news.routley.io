<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://benghancock.github.io/blog/2022/tao-of-acme.html">Original</a>
    <h1>The Tao of Acme</h1>
    
    <div id="readability-page-1" class="page">
<nav><a href="https://benghancock.github.io/blog">~/Blog</a></nav>

<h2 id="abstract">Abstract</h2>
<p>Acme is a text editor originally developed for the Plan 9 operating
system in the 1990s by well-known software engineer Rob Pike, and has
since been ported to other Unix-like systems and platforms. It was
created to be a “<a href="http://acme.cat-v.org/">user interface for
programmers</a>,” and although it arguably belongs to a family of
“classic” text editors dating from an even earlier era — Emacs and vi —
it is distinguished by fundamentally different design decisions, user
experience, and overall look and feel.</p>
<p>I started using acme in the middle of 2021, and as I did so, found
myself curious about the thinking that influenced those decisions, as
well as the factors that drove other committed programmers to choose
acme for their work. This led me to subscribe to the <a href="http://9p.io/wiki/plan9/mailing_lists/">9fans mailing list</a> and
begin digging through the archives, which I found to be a trove of
interesting insights, tips, and perspectives — including from Pike
himself, who also kindly responded to a question of my own about code
navigation in acme.</p>
<p>In this post, my goal is to distill this information into some key
points that I think will help any programmer newly approaching acme
understand the thinking behind “the acme way” of doing things, and why
the editor might be an effective tool for their purposes — even when
many other newer, feature-rich editors are available. If that’s too
lofty a goal, I hope to at least convey why I enjoy using acme when I
write code.</p>
<h2 id="on-emptiness">On Emptiness</h2>
<h3 id="less-is-more">Less is More</h3>
<p>When one talks about software, it’s common to start by listing out a
program’s features. When it comes to acme, however, it’s perhaps more
appropriate to start by talking about what features it <em>does not</em>
include. It is not for nothing that acme is sometimes described as a <a href="https://github.com/evbogdanov/acme">“Zen-style” text editor</a>.
As another programmer <a href="http://jlouisramblings.blogspot.com/2013/04/acme-as-editor_20.html">aptly
wrote</a>: “With acme, you sacrifice almost everything.”</p>
<p>This emptiness is considered to be one of the editor’s positive
attributes, with the idea being that most everything that is missing
from acme itself belongs to one of the following categories:</p>
<ul>
<li>It can be supplied by an external program specifically designed for
the task, following the Unix philosophy</li>
<li>It actually <em>can</em> be achieved, probably with the use of
structural regular expressions and the command language of acme
predecessor <code>sam(1)</code></li>
<li>It’s just a distraction that you really don’t need</li>
</ul>
<p>The final category is significant. In a mailing list thread from
2008, Russ Cox, the person behind the <a href="https://9fans.github.io/plan9port/">plan9port project</a>, <a href="https://marc.info/?l=9fans&amp;m=121916884525962&amp;w=2">responds
to a post</a> asking for acme’s way of achieving 19 common editor
features — such as substituting spaces for tabs, syntax highlighting,
and code folding — with a simple refrain: <em>“Just say no.”</em></p>
<p>Cox’s first response in the message underscores acme’s “keep it
simple, stupid” ethos:</p>
<blockquote>
<p><em>&gt; what is the acme way of approaching it?</em></p>
<p><em>&gt; 01. Toggle on/off line wrapping</em></p>
<p><em>&gt; 02. Toggle on/off EOL character display</em></p>
<p><strong>Write shorter lines.</strong></p>
</blockquote>
<p>This is not to say that acme is not powerful. In fact, Cox, in a <a href="https://research.swtch.com/acme">video posted in 2012</a>, nicely
demonstrates how much acme <em>can</em> do — especially by leveraging
the <code>plumber</code> and Plan 9 virtual file system, topics that I
won’t attempt to do justice to in this post. He sums up by describing
acme as an “integrat<em>ing</em> development environment,” distinct
because it allows the programmer to more effectively use the tools
available on their system rather than trying to reimplement them out of
whole cloth.</p>
<p>Still, simplicity is acme’s hallmark. It’s <a href="http://acme.cat-v.org/readme">README</a> is mercifully short (two
pages, printed) and ends by saying: “This is mostly what you need to get
started with acme.”</p>
<h3 id="bare-text">Bare Text</h3>
<p>Eschewing syntax highlighting probably invites guffaws, utter dismay,
or bemusement for many programmers. But I think others have made a
convincing case for ditching the colors. Håkon Robbestad Gylterud —
another acme user — in his article <a href="https://hakon.gylterud.net/opinion/syntax-highlighting.html">“How
I program without syntax highlighting”</a> notes how syntax highlighting
can often hide ugly code, whereas leaving the text bare allows neatly
organized code to really shine. I certainly am guilty of futzing about
too much with different editor color schemes, and if nothing else,
taking it away removes at least <em>that</em> bit of distraction.</p>
<p>In the same 2008 thread mentioned above, <a href="https://marc.info/?l=9fans&amp;m=121916365714790&amp;w=2">another
poster writes</a> that acme’s approach to presenting code helps
highlight flaws or messy code more plainly:</p>
<blockquote>
<p>For me, that’s a crucial thing. Keeps my code in check purely through
the text of it.</p>
</blockquote>
<p>This philosophy is actually what initially attracted me to acme. It
was at a time when life in general was feeling hectic and overwhelming.
I was listening to the audiobook of <a href="http://www.worldcat.org/oclc/985356418">Greg McKeown’s
<em>Essentialism</em></a>, and was working on a software project that I
felt had become needlessly complex. It seemed that hiding this
complexity was <em>too easy</em> in other tools, and that working in
acme pushed me to make things simple where doing so actually made more
sense.</p>
<p>Acme’s lack of support for substituting tabs for spaces means that
for those who write a lot of Python (like myself) adhering to the PEP8
convention of using four spaces to indent means you will probably end up
counting how many times you hit the space bar at one point or another.
This irked me at first, though it’s more trivial when starting acme with
the <code>-a</code> flag, which performs a simplistic auto-indent. But
what I found interesting was that before using acme, I had never really
questioned the convention — even though the tabs vs. spaces debate is by
now as old as time. (I then felt genuinely befuddled: If I’m really just
trying to visually indent my code, and hitting <kbd>Tab</kbd> to do so,
why <em>not</em> use an actual tab character?)</p>
<p>On that point, I found a <a href="https://marc.info/?l=9fans&amp;m=111558697816669&amp;w=2">1995
message by Rob Pike</a> (albeit on a different subject) to be
illuminating.</p>
<blockquote>
<p>Seriously, if you need more than indentation with tabs to lay out
your program, you’re probably worrying about the wrong things in your
source code.</p>
</blockquote>
<h2 id="on-fonts">On Fonts</h2>
<p>In <a href="https://marc.info/?t=111558706700043&amp;r=1&amp;w=2">that
thread</a> , Pike was actually responding to a message about fonts in
acme — and in particular, its choice of using a proportional (or
variable-pitch) font as the default. By now, we’re seeming really
oddball, aren’t we? First, no syntax highlighting; now, ditching
<em>monospace fonts</em>!?</p>
<p>Here too, there is reasoning behind this choice, and it boils down to
two things: screen real estate, and readability. I’ll quote liberally
from Howard Trickey (another Bell Labs alum who, like Pike, now works at
Google) on that same 1995 thread:</p>
<blockquote>
<p>[G]ive the proportional font a chance. You can always flip a given
window between proportional and non-proportional (execute Font with
button 2) if it is critical to see how things line up.</p>
<p>I’ve been using acme exclusively for years now — I was the first
non-rob person to do so. At first, the problems with programming seem to
loom large, but there are two solutions:</p>
<p>() if you are working a program for yourself only: make it look good
with the proportional font, and the hell with how it looks in fixed
pitch!</p>
<p>() if you have to collaborate with others, or produce programs that
look good when printed on paper, develop a programming style that needs
very few uses of “Font” to see how things line up. […]</p>
<p>The additional real-estate advantages of the proportional font are
too great to give up without a fight.</p>
</blockquote>
<p>In subsequent messages, Pike goes on to dismiss arguments about
monospace fonts being useful because you can do things like create ASCII
diagrams in comments (see his remark above), and describes monospace
fonts as “old fashioned” and on their way out.</p>
<blockquote>
<p>Fixed-pitch will soon follow in the footsteps of CAPITAL LETTERS AND
PUNCHED CARDS.</p>
</blockquote>
<p>I’d be interested to know how Pike feels about that prediction now,
given that fixed-pitch fonts are still the default in most editors and
IDEs. Maybe we’re still too early on the timeline. But either way, I can
say that after embracing Trickey’s advice to give proportional fonts a
chance, I’ve found I really enjoy them. And apparently I’m <a href="https://news.ycombinator.com/item?id=1056908">not totally
alone</a>. (My font of choice is DejaVu Serif; it’s widely available and
leaves a small amount of space between braces, parentheses, quote marks,
etc., which makes working with code easier).</p>
<h2 id="on-using-the-mouse">On Using the Mouse</h2>
<p>Another one of acme’s hallmarks is that many operations are achieved
using the mouse, and <em>only</em> the mouse. It has a total of five key
bindings, six if you count using <kbd>Esc</kbd> to select the most
recently typed text (which you will then probably click in some
fashion), and a few more if you use the plan9port version on a Mac. But
in general, <em>a lot</em> in acme gets done with the mouse. If you are
coming from an editor like Vim or Emacs — I was a strong adherent to the
latter for years — this may seem like utter heresy, a productivity drag
at best and a recipe for <a href="https://en.wikipedia.org/wiki/Repetitive_strain_injury">RSI</a> at
worst.</p>
<p>There are a couple things I’ve learned from giving it a try anyway:
First, using the mouse, and especially with acme’s unique mouse
“chords,” can actually be pretty fast. But more importantly, I’ve come
to feel that obsessing over the speed of issuing editor commands is
misguided. To be sure, appearing fast and fluid while programming is
something that programmers take seriously. I once attended an Emacs
meetup (Yes, you read that right) where a developer who spent a lot of
time writing C++ expressed consternation about sometimes not appearing
as quick on the draw as his colleagues who used an IDE. “The one thing
you don’t want to look is <em>slow</em>,” he said.</p>
<p>I get this. But I also know that there have been too many times when
I’ve started hacking away at something without really understanding what
I was trying to achieve. With acme (as well as with its predecessor <a href="http://sam.cat-v.org/">sam</a>) I find that I am more deliberate,
more clear-headed. This experience appears to be shared by at least some
others. <a href="https://marc.info/?l=9fans&amp;m=124653651608298&amp;w=2">One user
wrote</a> on a 2009 thread to the list:</p>
<blockquote>
<p>I spend relatively little of my time actually typing or moving the
cursor, etc. The majority of my time is spent thinking, so I’m much more
interested in what distracts me less and what causes the least
irritation. And I do find moving my hand back and forth between the
keyboard and mouse to be a bit irritating. I will say, however, that I
find acme to be the least irritating of the pointer-based applications
I’ve used.</p>
</blockquote>
<p>In a <a href="https://mostlymaths.net/2013/03/extensibility-programming-acme-text-editor.html">blog
post from 2013</a> about acme, mathemetician and data engineer Ruben
Berenguel also writes about this idea.</p>
<blockquote>
<p>[T]he point is not […] speed. What are you changing this string for?
Did you wait to think about it or you just changed it, compiled it,
checked it and went back to square one?</p>
</blockquote>
<h2 id="on-navigating-code">On Navigating Code</h2>
<p>Programmers spend a lot of time reading code, and often code that
they did not write. This means that finding one’s way around a code
base, identifying what different pieces do and understanding the logical
flow, is an important part of the craft. Jumping to a function or
symbol’s definition is a standard IDE feature, and is something that
editors like Emacs and Vim accomplish natively (i.e. without external
packages) by parsing so-called “tags” files, which are files generated
with a special tool that analyzes source code.</p>
<p>Acme offers an easy way to jump around to matching strings
<em>within</em> a file: simply right-click a bit of text and you will
jump to the next match. But this only gets you so far, and as I began
using the editor more, I scratched my head at how to accomplish this
essential task of navigating complex source code in acme. So I <a href="https://marc.info/?t=162923195200001&amp;r=1&amp;w=2">sent a
message</a> to the mailing list asking for some guidance.</p>
<p>At this point I should say some kind words about the acme and Plan 9
community, because I received a lot of friendly and helpful feedback
(and fast!). The responses ranged from philosophical (<em>Don’t let your
code get so complex that it’s hard to navigate</em>) to more pragmatic.
One of the people who replied was Rob Pike himself, who <a href="https://marc.info/?l=9fans&amp;m=162927881111507&amp;w=2">shared a
sampling</a> of one-line scripts he calls from acme to find definitions.
Some of them were tools that I hadn’t heard of, like Ross Cox’s <a href="https://github.com/google/codesearch">codesearch</a>, but most of
them pointed toward a dead-simple answer: use <code>grep</code>.</p>
<p>Here’s an example of Pike’s <code>f</code> script.</p>
<pre><code>#!/bin/sh

9 grep -i -n &#39;^func (\([^)]+\) )?&#39;$1&#39;\(&#39; *.go /dev/null</code></pre>
<p>It may look cryptic, but this just looks for a function definition in
any <code>go</code> source file with the name given as the argument.</p>
<p>Acme makes calling a program like this pretty slick: if I’m looking
for a function called <code>foo()</code>, I can double-click
<code>foo</code> to highlight it, type my program name — here, just
<code>f</code>— in the top blue portion of my window (called the “tag”
in acme, not to be confused with the types of tags files described
above), and then click <code>f</code> with a mouse chord: middle button
followed by left-click. This executes <code>f</code> with
<code>foo</code> as the argument, and the output pops up in a new
window, with the filename and line number where <code>foo()</code> is
defined. Right-click that, and then acme takes you there.</p>
<p>I realize as I write this that it may sound like a lot of steps, or
that it’s clunky, but it really becomes quite fluid. Part of the
paradigm of using acme, too, is that you keep useful text around. So you
might keep <code>f</code> in your window tag for your whole session,
along with commands to invoke other external programs, like
<code>|fmt</code> or <code>|tr A-Z a-z</code>.</p>
<p>Being able to leverage a simple script like this to navigate code is
especially useful if you do any work in an uncommon language. For
example: I write and need to navigate a fair amount of code written in
XQuery, a functional language used by some XML databases. It also has an
uncommon syntax for definining functions that is quite verbose and in
which functions are generally prefixed by namespaces
(e.g. <code>declare function foo:barThisFoo($x as xs:string) { ... }</code>).
But acme allows me to use a one-liner to traverse definitions across
XQuery modules easily.</p>
<p>Is this on par with automatic code-completion, or
“Intellisense”-style in-line documentation of functions? Probably not
(though there is <a href="https://github.com/fhs/acme-lsp"><code>acme-lsp</code></a>). But
it is simple, and makes clear that there’s not much magic about finding
your way around code.</p>
<h2 id="but-still-why">But Still, Why?</h2>
<p>If you’ve made it to the end of this post (thank you!), then you may
still be wondering: Why? In an era when there are so many editors and
IDEs, why choose to do things in this quirky, acme way?</p>
<p>To be honest, after reading <a href="https://echosa.net/blog/2014/10/06/lets-try-acme-episode-9-the-end/">Brian
Zwahr’s blog series</a> about using acme, at the end of which he —
spoiler alert! — returns to using Emacs, I fully expected that I would
end up doing the same thing. After several months, there were days when
I would go back to Emacs and get a sense that things were so much easier
and more fluid. The buffer juggling. The keyboard bindings. The
packages. The colors!</p>
<p>I usually did this when I hit some roadblock in my programming,
thinking that it was the editor standing in the way. But invariably,
this was not the case: the mental block was a realization that there was
a problem in my code, a flaw in the design. Acme, I found, helped to me
to focus on that.</p>
<p>And so I’ve come back to acme, day after day; I’ve worked on projects
large and small with it, used it to take notes, and — hey — even written
blog posts. Do I still use Emacs? Sure, sometimes. I also sometimes use
Vim, mg, sam, or even VS Code. I subscribe to the philosophy that <a href="https://utcc.utoronto.ca/~cks/space/blog/tech/EditorDifferences">different
editors have different strengths</a>. But for a lot of what I do, acme
is a fantastic tool.</p>
<h2 id="conclusion">Conclusion</h2>
<p>I’ve barely scratched the surface of what it’s like using acme, but
hopefully this has helped the curious programmer get acquainted with
some of the thinking behind the editor’s most obvious design
differences. I hope in the future to share more notes and tips about how
I use it for day-to-day work, but in the meantime, give it a try!</p>
<hr/>
<p>Copyright (c) Ben Hancock. Read the <a href="https://benghancock.github.io/license.html">license</a>.</p>


</div>
  </body>
</html>
