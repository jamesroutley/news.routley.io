<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://yosefk.com/blog/its-done-in-hardware-so-its-cheap.html">Original</a>
    <h1>It&#39;s done in hardware so it&#39;s cheap (2012)</h1>
    
    <div id="readability-page-1" class="page"><div>
				<p>It isn&#39;t.</p>
<p>This is one of these things that look very obvious to me, to the point where it seems not worth discussing. However, I&#39;ve heard the idea that &#34;hardware magically makes things cheap&#34; from several PhDs over the years. So apparently, if you aren&#39;t into hardware, it&#39;s not obvious at all.</p>
<p>So why doesn&#39;t &#34;hardware support&#34; automatically translate to &#34;low cost&#34;/&#34;efficiency&#34;? The short answer is, hardware is an electric circuit and you can&#39;t do magic with that, there are rules. So what are the rules? We know that hardware support does help at times. When does it, and when doesn&#39;t it?</p>
<p>To see the limitations of hardware support, let&#39;s first look at what hardware <em>can </em>do to speed things up. Roughly, you can really only do two things:</p>
<ol>
<li><strong>Specialization </strong>- save dispatching costs in speed and energy.</li>
<li><strong>Parallelization </strong>- save time, but not energy, by throwing more hardware at the job.</li>
</ol>
<p>Let&#39;s briefly look at examples of these two speed-up methods – and then some examples where hardware support does nothing for you, because none of the two methods helps. We&#39;ll only consider run time and energy per operation, ignoring silicon area (considering a third variable just makes it too hairy).</p>
<p>I&#39;ll also discuss the difference between <em>real costs</em> of operations and <em>the price you pay</em> for these operations, and argue that in the long run, costs are more stable and more important than prices.</p>
<p><strong>Specialization: cheaper dispatching</strong></p>
<p>If you want to extract bits 3 to 7 of a 32-bit word and then multiply them by 13 – let&#39;s say an encryption algorithm requires this – you can have an instruction doing just that. That will be faster and use less energy than, say, using bitwise AND, shift &amp; multiplication instructions.</p>
<p>Why – what costs were cut out? The costs of dispatching individual operations – circuitry controlling which operation is executed, where the inputs come from and where the outputs go.</p>
<p>Specialization can be taken to an extreme. For instance, if you want a piece of hardware doing nothing but JPEG decoding, you can bring dispatching costs close to zero by having a single &#34;instruction&#34; – &#34;decode a JPEG image&#34;. Then you have no flexibility – and none of the &#34;overhead&#34; circuitry found in more flexible machines (memory for storing instructions, logic for decoding these instructions, multiplexers choosing the registers that inputs come from based on these instructions, etc.)</p>
<p>Before moving on, let&#39;s look a little closer at why we won here:</p>
<ul>
<li>We got a speed-up because <strong>the operations were fast to begin with</strong> – so dispatching costs dominated. With specialization, we need 4 wires connected directly to bits 3 to 7 that have tiny physical delay – just the time it takes the signal to travel to a nearby multiplier-by-13. Without specialization, we&#39;d use a shifter shifting by a configurable amount of bits – 3 in our case but not always – which is a bunch of gates introducing a much larger delay. On top of that, since we&#39;d be using several such circuits communicating through registers (let&#39;s say we&#39;re on a RISC CPU), we&#39;d have delays due to reading and writing registers, delays due to selecting registers from a large register file, etc. With all this taken out by having a specialized instruction, no wonder we&#39;re seeing a big speed-up.</li>
<li>Likewise, we&#39;ll see lower energy consumption because the operations didn&#39;t require a lot of energy to begin with. Roughly, most of the energy is consumed when a signal value changes from 1 to 0 or back. When we use general-purpose instructions, most of the gate inputs &amp; outputs and most flip-flops changing their values are those implementing the dispatching. When we use a specialized instruction, most of the switching is gone.</li>
</ul>
<p>This means that, unsurprisingly, there&#39;s a limit to efficiency – the fundamental cost of the operations we need to do, which can&#39;t be cut.</p>
<p>When the operations themselves are costly enough – for instance, memory access or floating point operations – then their cost dominates the cost of dispatching. So specialized instructions that cut dispatching costs will give us little or nothing.</p>
<p><strong>Parallelization: throwing more hardware at the job</strong></p>
<p>What to do when specialization doesn&#39;t help? We can simply have N processors instead of one. For the parts that can be parallelized, we&#39;ll cut the run time by N – but spend the same amount of energy. So things got faster but not necessarily cheaper. A fixed power budget limits parallelization – as does a fixed budget of, well, money (the price of a 1000-CPU rack is still not trivial today).</p>
<p>[Why have multicore chips if it saves no energy? Because a multicore chip is cheaper than many single core ones, and because, above a certain frequency, many low-frequency cores use less energy than few high-frequency ones.]</p>
<p>We can combine parallelization with specialization – in fact it&#39;s done very frequently. Actually a JPEG decoder mentioned above would do that – a lot of its specialized circuits would execute in parallel.</p>
<p>Another example is how SIMD or <a href="http://www.yosefk.com/blog/simd-simt-smt-parallelism-in-nvidia-gpus.html">SIMT</a> processors broadcast a single instruction to multiple execution units. This way, we get only a speed-up, but no energy savings at the execution unit level: instead of one floating point ALU, we now have 4, or 32, etc. We do, however, get energy savings at the dispatching level – we save on program memory and decoding logic. As always with specialization, we pay in flexibility – we can&#39;t have our ALUs do different things at the same time, as some programs might want to.</p>
<p>Why do we see more single-precision floating point SIMD than double-precision SIMD? Because the higher the raw cost of operations, the less we save by specialization, and SIMD is a sort of specialization. If we have to pay for double-precision ALUs, why not put each in a full-blown CPU core? That way, at least we get the most flexibility, which means more opportunities to actually use the hardware rather than keeping it idle.</p>
<p>(It&#39;s really more complicated than that because SIMD can actually be a more useful programming model than multiple threads or processes in some cases, but we won&#39;t dwell on that.)</p>
<p><strong>What can&#39;t be done</strong></p>
<p>Now that we know what can be done – and there really isn&#39;t anything else – we basically already also know what can&#39;t be done. Let&#39;s look at some examples.</p>
<p><strong><em>Precision costs are forever</em></strong></p>
<p>8-bit integers are fundamentally more efficient than 32-bit floating point, and no hardware support for any sort of floating point operations can change this.</p>
<p>For one thing, multiplier circuit size (and energy consumption) is roughly quadratic in the size of inputs. IEEE 32b floating point numbers have 23b mantissas, so multiplying them means a ~9x larger circuit than an 8×8-bit multiplier with the same throughput. Another cost, linear in size, is that you need more memory, flip-flops and wires to store and transfer a float than an int8.</p>
<p>(People are more often aware of this one because SIMD instruction sets usually have fixed-sized registers which can be used to keep, say, 4 floats or 16 uint8s. However, this makes people underestimate the overhead of floating point as 4x – when it&#39;s more like 9x if you look at multiplying mantissas, not to mention handling exponents. Even int16 is 4x more costly to multiply than int8, not 2x as the storage space difference makes one guess.)</p>
<p>We design our own chips, and occasionally people say that it&#39;d be nice to have a chip with, say, 256 floating point ALUs. This sounds economically nonsensical – sure it&#39;s nice and it&#39;s also quite obvious, so if nobody makes such chips at a budget similar to ours, it must be impossible, so why ask?</p>
<p>But actually it&#39;s a rather sensible suggestion, in that you <em>can</em> make a chip with 256 ALUs that is more efficient than anything on the market for what you do, but not flexible enough to be marketed as a general-purpose computer. That&#39;s precisely what specialization does.</p>
<p>However, specialization only helps with operations which are cheap enough to begin with compared to the cost of dispatching. So this can work with low-precision ALUs, but not with high-precision ALUs. With high-precision ALUs, the raw cost of operations would exceed our power budget, even if dispatching costs were zero.</p>
<p><strong><em>Memory indirection costs are forever</em></strong></p>
<p>I mentioned this in my old needlessly combative write-up about &#34;<a href="http://www.yosefk.com/blog/the-high-level-cpu-challenge.html">high-level CPUs</a>&#34;. There&#39;s this idea that we can have a machine that makes &#34;high-level languages&#34; run fast, and that they&#39;re really only slow because we&#39;re running on &#34;C machines&#34; as opposed to Lisp machines/Ruby machines/etc.</p>
<p>Leaving aside the question of what &#34;high-level language&#34; means (I really don&#39;t find it obvious at all, but never mind), object-orientation and dynamic typing frequently result in indirection: pointers instead of values and pointers to pointers instead of pointers. Sometimes it&#39;s done for no apparent reason – for instance, Erlang strings that are kept as linked lists of ints. (Why do people even like linked lists as &#34;the&#34; data structure and head/tail recursion as &#34;the&#34; control structure? But I digress.)</p>
<p>This kind of thing can never be sped up by specialization, because memory access fundamentally takes quite a lot of time and energy, and when you do p-&gt;a, you need one such access, and when you do p-&gt;q-&gt;a, you need two, hence you&#39;ll spend twice the time. Having a single &#34;LOAD_LOAD&#34; instruction instead of two – LOAD followed by a LOAD – does nothing for you.</p>
<p>All you can do is parallelization - throw more hardware at the problem, N processors instead of one. You can, alternatively, combine parallelization with specialization, similarly to N-way floating point SIMD that&#39;s somewhat cheaper than having N full-blown processors. For example, you could have several load-store units and several cache banks and a multiple-issue processor. Than if you had to run p1-&gt;q1-&gt;a and somewhere near that, p2-&gt;q2-&gt;b, and the pointers point into different banks, some of the 4 LOADs would end up running in parallel, without having several processors.</p>
<p>But, similarly to low-precision math being cheaper whatever the merits of floating point SIMD, one memory access is always twice cheaper than two despite the merits of cache banking and multiple issue. Specifically, doubling the memory access throughput roughly doubles the energy cost. This can sometimes be better than simply using two processors, but it&#39;s a non-trivial cost and will always be.</p>
<p><strong>A note about latency</strong></p>
<p>We could discuss other examples but these two are among the most popular – floating point support is a favorite among math geeks, and memory indirection support is a favorite among language geeks. So we&#39;ll move on to a general conclusion – but first, we should mention the difference between latency costs and throughput costs.</p>
<p>In our two examples, we only discussed throughput costs. A floating point ALU with a given throughout uses more energy than an int8 ALU. Two memory banks with a given throughput use about twice the energy of a single memory bank with half the throughput. This, together with the relatively high costs of these operations compared to the costs of dispatching them, made us conclude that we have nothing to do.</p>
<p>In reality, the high latency of such heavyweight operations can be the bigger problem than our inability to increase their throughput without paying a high price in energy. For example, consider the instruction sequence:</p>
<pre>c = FIRST(a,b)
e = SECOND(c,d)</pre>
<p>If FIRST has a low latency, then we&#39;ll quickly proceed to SECOND. If FIRST has a high latency, then SECOND will have to wait for that amount of time, even if FIRST has excellent throughput. Say, if FIRST is a LOAD, being able to issue a LOAD every cycle doesn&#39;t help if SECOND depends on the result of that LOAD and the LOAD latency is 5 cycles.</p>
<p>A large part of computer architecture is various methods for dealing with these latencies – <a href="http://www.yosefk.com/blog/humans-and-compilers-need-each-other-the-vliw-simd-case.html">VLIW</a>, out-of-order, <a href="http://en.wikipedia.org/wiki/Barrel_processor">barrel processors</a>/SIMT, etc. These are all forms of parallelization – finding something to do in parallel with the high-latency instruction. A barrel processor helps when you have many threads. An out-of-order processor helps when you have nearby independent instructions in the same thread. And so on.</p>
<p>Just like having N processors, all these parallelization methods don&#39;t lower dispatching costs - in fact, they <em>raise </em>them (more registers, higher issue bandwidth, tricky dispatching logic, etc.) The processor doesn&#39;t become more energy efficient - you get more done per unit of time but not per unit of energy. A simple processor would be stuck at the FIRST instruction, while a more clever one would find something to do – and spend the energy to do it.</p>
<p>So latency is a very important problem with fundamentally heavyweight operations, and machinery for hiding this latency is extremely consequential for execution speed. But fighting latency using any of the available methods is just a special case of parallelization, and in this sense not fundamentally different from simply having many cores in terms of energy consumed.</p>
<p>The upshot is that parallelization, whether it&#39;s having many cores or having single-core latency-hiding circuitry, can help you with execution speed – throughput per cycle – but not with energy efficiency – throughput per watt.</p>
<p>The latency of heavyweight stuff is important and not hopeless; its throughput is important and hopeless.</p>
<p><strong>Cost vs price</strong></p>
<p>&#34;But on my GPU, floating point operations are actually as fast as int8 operations! How about that?&#34;</p>
<p>Well, a bus ticket can be cheaper than the price of getting to the same place in a taxi. The bus ticket will be cheaper even if you&#39;re the only passenger, in which case the real cost of getting from A to B in a bus is surely higher than the cost of getting from A to B in a taxi. Moreover, a bus might take you there more quickly if there are lanes reserved for buses that taxis are not allowed to use.</p>
<p>It&#39;s basically a cost vs price thing – math and physics vs economics and marketing. The fundamentals only say that a hardware vendor always <em>can</em> make int8 cheaper than float – but they can have good reasons not to. It&#39;s not that they made floats as cheap as int8 – actually, they made int8 as expensive as floats in terms of real costs.</p>
<p>Just like you going alone in a bus designed to carry dozens of people is an inefficient use of a bus, using float ALUs to process what could be int8 numbers is an inefficient use of float ALUs. Similarly, just like transport regulations can make lanes available for buses but not cars, an instruction set can make fetching a float easy but make fetching a single byte hard (no load byte/load byte with sign extension instructions). But cars <em>could </em>use those lanes – and loading bytes <em>could </em>be made easy.</p>
<p>As a passenger, of course you will use the bus and not the taxi, because economics and/or marketing and/or regulations made it the cheaper option in terms of price. Perhaps it&#39;s so because the bus is cheaper overall, with all the passengers it carries during rush hours. Perhaps it&#39;s so because the bus is a part of the contract with your employer – it&#39;s a bus carrying employees towards a nearby something. And perhaps it&#39;s so because the bus is subsidized by the government. Whatever the reason, you go ahead and use the cheaper bus.</p>
<p>Likewise, as a programmer, if you&#39;re handed a platform where floating point is not more expensive or even cheaper than int8, it is perhaps wise to use floating point everywhere. The only things to note are, the vendor <em>could </em>have given you better int8 performance; and, at some point, a platform might emerge that you want to target and where int8 is much more efficient than float.</p>
<p>The upshot is that it&#39;s possible to lower the <em>price </em>of floating point relative to int8, but not the <em>cost</em>.</p>
<p><em><strong>What&#39;s more &#34;important&#34; – prices or costs?</strong></em></p>
<p>Prices have many nice properties that real costs don&#39;t have. For instance, all prices can be compared – just convert them all to your currency of choice. Real costs are hard to compare without prices: is 2x less time for 3x more energy better or worse?</p>
<p>In any discussion about &#34;fundamental real costs&#34;, there tend to be hidden assumptions about prices. For example, I chose to ignore area in this discussion under the assumption that area is usually less important than power. What makes this assumption true – or false – is the prices fabs charge for silicon production, the sort of cooling solutions that are marketable today (a desktop fan could be used to cool a cell phone but you couldn&#39;t sell that phone), etc. It&#39;s really hard to separate costs from prices.</p>
<p><a href="http://www.futurechips.org/thoughts-for-researchers/dollar-the-only-first-order-metric-in-computer-engineering.html">Here&#39;s</a> a computer architect&#39;s argument to the effect of &#34;look at prices, not costs&#34;:</p>
<blockquote><p>While technical metrics like performance, power, and programmer effort  make up for nice fuzzy debates, it is pivotal for every computer guy to  understand that “Dollar” is the one metric that rules them all. The  other metrics are just sub-metrics derived from the dollar: Performance  matters because that’s what customers pay for; power matters because it  allows OEMs to put cheaper, smaller batteries and reduce people’s  electricity bills; and programmer effort matters because it reduces the  cost of making software.</p></blockquote>
<p>I have two objections: that prices are the effect, not the cause, and that prices are too volatile to commit to memory as a &#34;fundamental&#34;.</p>
<p>Prices are the effect in the sense that, customers pay for performance because it matters, not &#34;performance matters because customers pay for it&#34;. Or, more precisely – customers pay for performance because it matters <em>to them</em>. As a result – because customers pay for it – performance matters <em>to vendors</em>. Ultimately, the first cause is that performance matters, not that it sells.</p>
<p>The other thing about prices is that they&#39;re rather jittery. Even a price index designed for stability such as <a href="http://www.google.com/finance?client=ob&amp;q=INDEXSP:.INX">S&amp;P 500</a> is jumping up and down like crazy. In a changing world, knowledge about costs has a longer shelf life than knowledge about prices.</p>
<p>For instance, power is considered cheap for desktops but expensive for servers and really expensive for mobile devices. In reality, desktops likely consume more power than servers, there being more desktops than servers. So the real costs are not like the prices – and prices change; the rise of mobile computing means rising prices for power-hungry architectures.</p>
<p>It seems to me that, taking the long view, the following makes sense:</p>
<ul>
<li>It&#39;s best to reason in costs and project them to the relevant prices – not forget the underlying costs and &#34;think in prices&#34;, so as to not get into habits that will become outdated when prices change.</li>
<li>If you see a high real cost &#34;hidden&#34; by contemporary prices, it&#39;s a good bet to assume that at some point in the future, prices will shift so that the real cost will rear its ugly head.</li>
</ul>
<p>For example, any RISC architecture – ARM, MIPS, PowerPC, etc. – is fundamentally cheaper than, specifically, x86, in at least two ways: hardware costs – area &amp; power – and the costs of developing said hardware. [At least so I believe; let&#39;s say that it&#39;s not as significant in my view than my other more basic examples, and I might be wrong and I&#39;m only using this as an illustration.]</p>
<p>In the long run, this spells doom for the x86, whatever momentum it otherwise has at any point in time – software compatibility costs, Intel&#39;s manufacturing capabilities vs competitors capabilities, etc. Mathematically or physically fundamental costs will, in the long run, trump everything else.</p>
<p>In the long run, there is no x86, no ARM, no Windows, no iPhone, etc. There are just ideas. We remember ideas originating in ancient Greece and Rome, but no products. Every product is eventually outsold by another product. Old software is forgotten and old fabs rot. But fundamentals are forever. An idea that is sufficiently more costly fundamentally than a competing idea can not survive.</p>
<p>This is why I disagree with the following quote by Bob Colwell – the chief architect of the Pentium Pro (BTW, I love <a href="http://newsletter.sigmicro.org/sigmicro-oral-history-transcripts/Bob-Colwell-Transcript.pdf">the interview</a> and intend to publish a summary of the entire 160-something page document):</p>
<blockquote><p>…you might say that CISC only stayed viable because Intel was able to throw a lot of money and people at it, and die size, bigger chips and so on.</p>
<p>In that sense, RISC still was better, which is what was claimed all along. And I said you know, there&#39;s point to be made there. I agree with you that Intel had more to do to stay competitive. They were starting a race from far behind the start line. But if you can throw money at a problem then, it&#39;s not really so fundamental technologically, is it? We look for more deep things than that, so if all the RISC/CISC thing amounted to was, you had a slight advantage economically, well, that&#39;s not as profound as it seemed back in the 80s was it?</p></blockquote>
<p>Well, here&#39;s my counter-argument and it&#39;s not technical. The technical argument would be, CISC is worse, to the point where Intel&#39;s 32nm Medfield performs about as well as ARM-based 40nm chips in a space where power matters. Which can be countered with an economical argument – so what, Intel does have a better manufacturing ability so who cares, they still compete.</p>
<p>But my non-technical argument is, sure, you can be extremely savvy business-wise, and perhaps, if Intel realized early on how big mobile is going to be, they&#39;d make a good enough x86-based offering back then and then everyone would have been locked out due to software compatibility issues and they&#39;d reign like they reign in the desktop market.</p>
<p>But you can&#39;t do that forever. Every company is going to lose to some company at some point or other because you only need one big mistake and you&#39;ll make it, you&#39;ll ignore a single emerging market and that will be the end. Or, someone will outperform you technically – build a better fab, etc. If an idea is only (&#34;only&#34;?) being dragged into the future kicking and screaming by a very business-savvy and technically excellent company, then the idea has no chance.</p>
<p>The idea that will win is <em>the idea that every new product will use</em>. New products always beat old products – always have.</p>
<p>And nobody, nobody at all has made a new CISC architecture in ages. Intel will lose to a company or companies making RISC CPUs because nobody makes anything else – and it has to lose to <em>someone</em>. Right now it seems like it&#39;s ARM but it doesn&#39;t matter how it comes out in this round. It will happen at some point or other.</p>
<p>And if ARM beats x86, it won&#39;t be, straightforwardly, &#34;because RISC is better&#34; – x86 will have lost <em>for business reasons</em>, and it could have gone the other way <em>for business reasons</em>. But the fact that it will have lost <em>to a RISC</em> – that will be because RISC is<em> technically better</em>. That&#39;s why there&#39;s no CISC competitor to lose to.</p>
<p>Or, if you dismiss this with the sensible &#34;in the long run, we&#39;re all dead&#34; – then, well, if you&#39;re alive right now and you&#39;re designing hardware, <em>you </em>are not making a CISC processor, are you? QED, not?</p>
<p>Getting back to our subject – based on the assumption that real costs matter, I believe that ugly, specialized hardware is forever. It doesn&#39;t matter how much money is poured into general-purpose computing, by whom and why. You will always have sufficiently important tasks that can be accomplished 10x or 100x more cheaply by using fundamentally cheap operations, and it will pay off for someone to make the ugly hardware and write the ugly, low-level code doing low-precision arithmetic to make it work.</p>
<p>And, on the other hand, the market for general-purpose hardware is always going to be huge, in particular, because there are so many things that must be done where specialization fundamentally doesn&#39;t help at all.</p>
<p><strong>Conclusion</strong></p>
<p>Hardware can only deliver &#34;efficiency miracles&#34; for operations that are fundamentally cheap to begin with. This is done by lowering dispatching costs and so increasing throughput per unit of energy. The price paid is reduced flexibility.</p>
<p>Some operations, such as high-precision arithmetic and memory access, are fundamentally expensive in terms of energy consumed to reach a given throughput. With these, hardware can still give you more speed through parallelization, but at an energy cost that may be prohibitive.</p>
							</div></div>
  </body>
</html>
