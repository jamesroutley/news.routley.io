<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://developer.apple.com/library/archive/documentation/Performance/Conceptual/power_efficiency_guidelines_osx/PrioritizeWorkAtTheTaskLevel.html">Original</a>
    <h1>Prioritize Work at the Task Level</h1>
    
    <div id="readability-page-1" class="page"><article>
  <a name="//apple_ref/doc/uid/TP40013929-CH35"></a><a name="//apple_ref/doc/uid/TP40013929-CH35-SW1"></a>

  <h2>Prioritize Work at the Task Level</h2>


  
  	<section>
  		
<p>
  Apps and processes compete to use finite resources—CPU, memory, network interfaces, and so on. In order to remain responsive and efficient, the system needs to prioritize tasks and make intelligent decisions about when to execute them.
</p>
<p>
  Work that directly impacts the user, such as UI updates in the active app, is extremely important and takes precedence over other work that may be occurring in the background. This higher priority work often uses more energy, as it may require substantial and immediate access to system resources.
</p>
<p>
  As a developer, you can help the system prioritize work more effectively by categorizing your app’s work, based on importance. Even if you’ve implemented other efficiency measures, such as deferring work until an optimal time, the system still needs to perform some level of prioritization. Therefore, it is still important to categorize the work your app performs.
</p>

		</section> 


  <section>
  <a name="//apple_ref/doc/uid/TP40013929-CH35-SW3"></a>
  <h3 tabindex="0">About Quality of Service Classes</h3>
  <p>
  OS X implements a variety of resource management attributes, which can be adjusted in order to improve the responsiveness and efficiency of the system. For example, you can adjust the CPU scheduler and I/O priorities for a task, provide a threshold for timer coalescing, and denote whether the CPU should operate in a throughput- or efficiency-oriented mode. These attributes, however, can be difficult to access and configure. A much simpler solution is to utilize quality of service (QoS) levels—known as classes—in your app.
</p><p>
  A <em>quality of service (QoS) class</em> allows you to categorize work to be performed by <code>NSOperation</code>, <code>NSOperationQueue</code>, <code>NSTask</code>, <code>NSThread</code>, dispatch queues, and pthreads (POSIX threads). By assigning a QoS to work, you indicate its importance, and the system prioritizes it and schedules it accordingly. For example, the system performs work initiated by a user sooner than background work that can be deferred until a more optimal time. In some cases, system resources may be reallocated away from the lower priority work and given to the higher priority work.
</p><p>
  Because higher priority work is performed more quickly and with more resources than lower priority work, it typically requires more energy than lower priority work. Accurately specifying appropriate QoS classes for the work your app performs ensures that your app is responsive as well as energy efficient.
</p>
  
</section>
<section>
  <a name="//apple_ref/doc/uid/TP40013929-CH35-SW5"></a>
  <h3 tabindex="0">Choosing a Quality of Service Class</h3>
  <p>
  The system uses QoS information to adjust priorities such as scheduling, CPU and I/O throughput, and timer latency. As a result, the work performed maintains a balance between performance and energy efficiency.
</p><p>
  When you assign a QoS to a task, consider how it affects the user and how it affects other work. As shown in <span>Table 10-1</span>, there are four primary QoS classes, each corresponding to a level of work importance.
</p><div>
  <table>
    <caption><strong>Table 10-1</strong>Primary QoS classes (shown in order of priority)</caption>
    <thead>
        <tr>
            <th scope="col"><p>
  QoS Class
</p></th>
            <th scope="col"><p>
  Type of work and focus of QoS
</p></th>
            <th scope="col"><p>
  Duration of work to be performed
</p></th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td scope="row"><p>
  User-interactive
</p></td>
            <td><p>
  Work that is interacting with the user, such as operating on the main thread, refreshing the user interface, or performing animations. If the work doesn’t happen quickly, the user interface may appear frozen. Focuses on responsiveness and performance.
</p></td>
            <td><p>
  Work is virtually instantaneous.
</p></td>
        </tr>
        <tr>
            <td scope="row"><p>
  User-initiated
</p></td>
            <td><p>
  Work that the user has initiated and requires immediate results, such as opening a saved document or performing an action when the user clicks something in the user interface. The work is required in order to continue user interaction. Focuses on responsiveness and performance.
</p></td>
            <td><p>
  Work is nearly instantaneous, such as a few seconds or less.
</p></td>
        </tr>
        <tr>
            <td scope="row"><p>
  Utility
</p></td>
            <td><p>
  Work that may take some time to complete and doesn’t require an immediate result, such as downloading a PDF or importing data. Utility tasks typically have a progress bar that is visible to the user. Focuses on providing a balance between responsiveness, performance, and energy efficiency.
</p></td>
            <td><p>
  Work takes a few seconds to a few minutes.
</p></td>
        </tr>
        <tr>
            <td scope="row"><p>
  Background
</p></td>
            <td><p>
  Work that operates in the background and isn’t visible to the user, such as indexing, synchronizing, and backups. Focuses on energy efficiency.
</p></td>
            <td><p>
  Work takes significant time, such as minutes or hours.
</p></td>
        </tr>
    </tbody>
  </table>
</div>
  
</section>
<section>
  <a name="//apple_ref/doc/uid/TP40013929-CH35-SW33"></a>
  <h3 tabindex="0">Special Quality of Service Classes</h3>
  <p>
  In addition to the primary QoS classes, there are two special types of QoS (described in <span>Table 10-2</span>). In most cases, you won’t be exposed to these classes, but there is still value in knowing they exist.
</p><div>
  <table>
    <caption><strong>Table 10-2</strong>Special QoS classes</caption>
    <thead>
        <tr>
            <th scope="col"><p>
  QoS Class
</p></th>
            <th scope="col"><p>
  Description
</p></th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td scope="row"><p>
  Default
</p></td>
            <td><p>
  The priority level of this QoS falls between user-initiated and utility. Work that has no QoS information assigned is treated as default. The GCD global queue runs at this level. This QoS is not intended to be used to classify work.
</p></td>
        </tr>
        <tr>
            <td scope="row"><p>
  Unspecified
</p></td>
            <td><p>
  This represents the absence of QoS information and cues the system that an environmental QoS should be inferred. Threads can have an unspecified QoS if they use legacy APIs that may opt the thread out of QoS.
</p></td>
        </tr>
    </tbody>
  </table>
</div>
  
</section>
<section>
  <a name="//apple_ref/doc/uid/TP40013929-CH35-SW35"></a>
  <h3 tabindex="0">Specify a QoS for Operations and Queues</h3>
  <p>
  If your app uses operations and queues to perform work, you can specify a QoS for that work. The <code><a href="https://developer.apple.com/documentation/foundation/nsoperation">NSOperation</a></code> and <code><a href="https://developer.apple.com/documentation/foundation/operationqueue">NSOperationQueue</a></code> classes both possess a <code>qualityOfService</code> property, of type <code>NSQualityOfService</code>, which can be set to one of the following values:
</p><ul>
  <li><p>
  <code>NSQualityOfServiceUserInteractive</code>
</p>
</li><li><p>
  <code>NSQualityOfServiceUserInitiated</code>
</p>
</li><li><p>
  <code>NSQualityOfServiceUtility</code>
</p>
</li><li><p>
  <code>NSQualityOfServiceBackground</code>
</p>
</li>
</ul><p>
  <span>Listing 10-1</span> shows how to set the QoS for an operation.
</p><section>
  <a name="//apple_ref/doc/uid/TP40013929-CH35-SW13"></a>
    <span><strong>Listing 10-1</strong>Setting the quality of service of an operation </span>
  <div>
      <div>
          <p>Objective-C</p>
        <ol>
            <li><code><span>NSOperation</span> <span>*</span><span>myOperation</span> <span>=</span> <span>[[</span><span>NSOperation</span> <span>alloc</span><span>]</span> <span>init</span><span>];</span>
</code></li>
            <li><code><span>myOperation</span><span>.</span><span>qualityOfService</span> <span>=</span> <span>NSQualityOfServiceUtility</span><span>;</span>
</code></li>
        </ol>
      </div>
      <div>
          <p>Swift</p>
        <ol>
            <li><code><span>let</span> <span>myOperation</span>: <span><!-- a href="" -->NSOperation<!-- /a --></span> = <span>MyOperation</span>()</code></li>
            <li><code><span>myOperation</span>.<span>qualityOfService</span> = .<span>Utility</span></code></li>
        </ol>
      </div>
  </div>
</section>
  <section>
  <a name="//apple_ref/doc/uid/TP40013929-CH35-SW36"></a>
  <h3 tabindex="0">Quality of Service Inference and Promotion</h3>
  <p>
  Note that QoS is not a static setting for operations and queues, and could fluctuate over time depending on a variety of criteria. For example, situations may occur where the QoS of an operation and the QoS of a queue don’t match, an operation and a dependent operation don’t match, or an operation has no QoS assigned. In these scenarios, a QoS may be inferred.
</p><p>
  Numerous rules govern how QoS inference and promotion occurs with regard to queues (see <span>Table 10-3</span>) and operations (see <span>Table 10-4</span>).
</p><div>
  <table>
    <caption><strong>Table 10-3</strong><code>NSOperationQueue</code> QoS inference and promotion rules</caption>
    <thead>
        <tr>
            <th scope="col"><p>
  Situation
</p></th>
            <th scope="col"><p>
  Result
</p></th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td scope="row"><p>
  A queue has no QoS assigned and an operation with a QoS is added to the queue.
</p></td>
            <td><p>
  The queue and its other operations, if any, remain unaffected.
</p></td>
        </tr>
        <tr>
            <td scope="row"><p>
  A queue has a QoS assigned, and an operation with a QoS is added to the queue.
</p></td>
            <td><p>
  The QoS of the queue is promoted if the QoS of the new operation is higher.
</p><p>
  Any of the queue’s operations with a lower QoS are also promoted.
</p><p>
  Any operations with a lower QoS that are added to the queue in the future will infer the higher QoS.
</p></td>
        </tr>
        <tr>
            <td scope="row"><p>
  The QoS of a queue is raised by changing the value of the queue’s <code>qualityOfService</code> property.
</p></td>
            <td><p>
  Any of the queue’s operations with a lower QoS are promoted to the higher QoS.
</p><p>
  Any operations with a lower QoS that are added to the queue in the future will infer the higher QoS.
</p></td>
        </tr>
        <tr>
            <td scope="row"><p>
  The QoS of a queue is lowered by changing the value of the queue’s <code>qualityOfService</code> property.
</p></td>
            <td><p>
  Any of the queue’s operations remain unaffected.
</p><p>
  Any operations that are added to the queue in the future will infer the lower QoS, unless they have a higher QoS assigned, in which case they will retain their assigned QoS level.
</p></td>
        </tr>
    </tbody>
  </table>
</div><div>
  <table>
    <caption><strong>Table 10-4</strong><code>NSOperation</code> inference and promotion rules</caption>
    <thead>
        <tr>
            <th scope="col"><p>
  Situation
</p></th>
            <th scope="col"><p>
  Result
</p></th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td scope="row"><p>
  An operation has no QoS assigned.
</p></td>
            <td><p>
  The operation infers the QoS of the parent operation, queue, <code>[NSProcessInfo performActivityWithOptions:reason:usingBlock:]</code> block, or thread, if any.
</p><p>
  In a situation where an operation is created on the main thread, a QoS of <code>NSQualityOfServiceUserInitiated</code> is inferred.
</p></td>
        </tr>
        <tr>
            <td scope="row"><p>
  An operation with a QoS is added to a queue with a higher QoS.
</p></td>
            <td><p>
  The QoS of the operation is promoted to match the QoS of the queue.
</p></td>
        </tr>
        <tr>
            <td scope="row"><p>
  The QoS of a queue containing an operation is promoted.
</p></td>
            <td><p>
  The operation infers the new QoS of the queue if it is higher than the current QoS of the operation.
</p></td>
        </tr>
        <tr>
            <td scope="row"><p>
  Another operation becomes dependent (child) on the operation (parent).
</p></td>
            <td><p>
  The parent operation infers the QoS of the child operation if that QoS is higher.
</p></td>
        </tr>
        <tr>
            <td scope="row"><p>
  The QoS of the operation is raised by changing the operation’s <code>qualityOfService</code> property.
</p></td>
            <td><p>
  The operation infers the new QoS.
</p><p>
  Any child operations are promoted to the new QoS if it is higher.
</p><p>
  Other operations in the operation’s queue that are in front of the operation are promoted to the new QoS if it is higher.
</p></td>
        </tr>
        <tr>
            <td scope="row"><p>
  The QoS of the operation is lowered by changing the operation’s <code>qualityOfService</code> property.
</p></td>
            <td><p>
  The operation infers the new QoS.
</p><p>
  Any child operations remain unaffected.
</p><p>
  The queue of the operation remains unaffected.
</p></td>
        </tr>
    </tbody>
  </table>
</div>
  
</section>
<section>
  <a name="//apple_ref/doc/uid/TP40013929-CH35-SW37"></a>
  <h3 tabindex="0">Adjust the QoS of a Running Operation</h3>
  <p>
  Once an operation is running, you can change its QoS in one of the following ways:
</p><ul>
  <li><p>
  Change the <code><a href="https://developer.apple.com/documentation/foundation/operation/1413553-qualityofservice">qualityOfService</a></code> property of the operation. Note that doing this also changes the QoS of the thread that’s running the operation.
</p>
</li><li><p>
  Add a new operation with a higher QoS to the running operation’s queue. This will promote the QoS of the running operation to match the QoS of the operation.
</p>
</li><li><p>
  Use <code><a href="https://developer.apple.com/documentation/foundation/nsoperation/1412859-adddependency">addDependency:</a></code> to add an operation with a higher QoS to the running operation as a dependent.
</p>
</li><li><p>
  Use <code><a href="https://developer.apple.com/documentation/foundation/nsoperation/1409256-waituntilfinished">waitUntilFinished</a></code> or <code><a href="https://developer.apple.com/documentation/foundation/nsoperationqueue/1407971-waituntilalloperationsarefinishe">waitUntilAllOperationsAreFinished</a></code>. This will promote the QoS of the running operation to match the QoS of the caller.
</p>
</li>
</ul>
  
</section>

</section>
<section>
  <a name="//apple_ref/doc/uid/TP40013929-CH35-SW39"></a>
  <h3 tabindex="0">Specify a QoS for Dispatch Queues and Blocks</h3>
  <p>
  If your app uses GCD, QoS classes can be applied to dispatch queues and blocks.
</p>
  <section>
  <a name="//apple_ref/doc/uid/TP40013929-CH35-SW40"></a>
  <h3 tabindex="0">Dispatch Queues</h3>
  <p>
  For dispatch queues, you can specify a QoS by calling <code><a href="https://developer.apple.com/documentation/dispatch/1453028-dispatch_queue_attr_make_with_qo">dispatch_queue_attr_make_with_qos_class</a></code> when creating the queue. First, create a dispatch queue attribute for the QoS, and then provide that attribute when you create the queue, as shown in <span>Listing 10-2</span>.
</p><section>
  <a name="//apple_ref/doc/uid/TP40013929-CH35-SW20"></a>
    <span><strong>Listing 10-2</strong>Assigning a QoS to a GCD dispatch queue</span>
  <div>
      <div>
          <p>Objective-C</p>
        <ol>
            <li><code><span>dispatch_queue_attr_t</span> <span>qosAttribute</span> <span>=</span> <span>dispatch_queue_attr_make_with_qos_class</span><span>(</span><span>DISPATCH_QUEUE_CONCURRENT</span><span>,</span> <span>QOS_CLASS_UTILITY</span><span>,</span> <span>0</span><span>);</span>
</code></li>
            <li><code><span>dispatch_queue_t</span> <span>myQueue</span> <span>=</span> <span>dispatch_queue_create</span><span>(</span><span>&#34;com.YourApp.YourQueue&#34;</span><span>,</span> <span>qosAttribute</span><span>);</span>
</code></li>
        </ol>
      </div>
      <div>
          <p>Swift</p>
        <ol>
            <li><code><span>let</span> <span>qosAttribute</span> = <span>dispatch_queue_attr_make_with_qos_class</span>(<span>DISPATCH_QUEUE_CONCURRENT</span>, <span>QOS_CLASS_UTILITY</span>, <span>0</span>)</code></li>
            <li><code><span>let</span> <span>myQueue</span> = <span>dispatch_queue_create</span>(<span>&#34;com.YourApp.YourQueue&#34;</span>, <span>qosAttribute</span>)</code></li>
        </ol>
      </div>
  </div>
</section><p>
  <span>Table 10-5</span> shows how GCD QoS classes map to Foundation QoS equivalents.
</p><div>
  <table>
    <caption><strong>Table 10-5</strong>GCD to Foundation QoS mappings</caption>
    <thead>
        <tr>
            <th scope="col"><p>
  GCD QoS classes (defined in sys/qos.h)
</p></th>
            <th scope="col"><p>
  Corresponding Foundation QoS classes
</p></th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td scope="row"><p>
  <code>QOS_CLASS_USER_INTERACTIVE</code>
</p></td>
            <td><p>
  <code>NSQualityOfServiceUserInteractive</code>
</p></td>
        </tr>
        <tr>
            <td scope="row"><p>
  <code>QOS_CLASS_USER_INITIATED</code>
</p></td>
            <td><p>
  <code>NSQualityOfServiceUserInitiated</code>
</p></td>
        </tr>
        <tr>
            <td scope="row"><p>
  <code>QOS_CLASS_UTILITY</code>
</p></td>
            <td><p>
  <code>NSQualityOfServiceUtility</code>
</p></td>
        </tr>
        <tr>
            <td scope="row"><p>
  <code>QOS_CLASS_BACKGROUND</code>
</p></td>
            <td><p>
  <code>NSQualityOfServiceBackground</code>
</p></td>
        </tr>
    </tbody>
  </table>
</div><p>
  QoS is an immutable attribute of a dispatch queue, and can’t be changed once the queue has been created. To retrieve the QoS that’s assigned to a dispatch queue, call <code>dispatch_queue_get_qos_class</code>.
</p><section>
  <a name="//apple_ref/doc/uid/TP40013929-CH35-SW41"></a>
    <span><strong>Listing 10-3</strong>Retrieving the QoS of a GCD dispatch queue</span>
  <div>
      <div>
          <p>Objective-C</p>
        <ol>
            <li><code><span>qosClass</span> <span>=</span> <span>dispatch_queue_get_qos_class</span><span>(</span><span>myQueue</span><span>,</span> <span>&amp;</span><span>relative</span><span>);</span>
</code></li>
        </ol>
      </div>
      <div>
          <p>Swift</p>
        <ol>
            <li><code><span>let</span> <span>qosClass</span> = <span>dispatch_queue_get_qos_class</span>(<span>myQueue</span>, &amp;<span>relative</span>)</code></li>
        </ol>
      </div>
  </div>
</section>
  
</section>
<section>
  <a name="//apple_ref/doc/uid/TP40013929-CH35-SW42"></a>
  <h3 tabindex="0">Global Concurrent Queues</h3>
  <p>
  In the past, GCD has provided high, default, low, and background global concurrent queues for prioritizing work. Corresponding QoS classes should be used in place of these queues. <span>Table 10-6</span> describes the mappings between these queues and QoS classes.
</p><div>
  <table>
    <caption><strong>Table 10-6</strong>GCD global concurrent queue to QoS mappings</caption>
    <thead>
        <tr>
            <th scope="col"><p>
  Global queue
</p></th>
            <th scope="col"><p>
  Corresponding QoS class
</p></th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td scope="row"><p>
  Main thread
</p></td>
            <td><p>
  User-interactive
</p></td>
        </tr>
        <tr>
            <td scope="row"><p>
  DISPATCH_QUEUE_PRIORITY_HIGH
</p></td>
            <td><p>
  User-initiated
</p></td>
        </tr>
        <tr>
            <td scope="row"><p>
  DISPATCH_QUEUE_PRIORITY_DEFAULT
</p></td>
            <td><p>
  Default
</p></td>
        </tr>
        <tr>
            <td scope="row"><p>
  DISPATCH_QUEUE_PRIORITY_LOW
</p></td>
            <td><p>
  Utility
</p></td>
        </tr>
        <tr>
            <td scope="row"><p>
  DISPATCH_QUEUE_PRIORITY_BACKGROUND
</p></td>
            <td><p>
  Background
</p></td>
        </tr>
    </tbody>
  </table>
</div><p>
  A global concurrent queue exists for each QoS class. To retrieve the global concurrent queue corresponding to a given QoS, call <code><a href="https://developer.apple.com/documentation/dispatch/1452927-dispatch_get_global_queue">dispatch_get_global_queue</a></code> and pass it the desired QoS class. <span>Listing 10-4</span>, for example, retrieves the global concurrent queue for the utility QoS class.
</p><section>
  <a name="//apple_ref/doc/uid/TP40013929-CH35-SW21"></a>
    <span><strong>Listing 10-4</strong>Getting the global concurrent queue for a QoS</span>
  <div>
      <div>
          <p>Objective-C</p>
        <ol>
            <li><code><span>utilityGlobalQueue</span> <span>=</span> <span>dispatch_get_global_queue</span><span>(</span><span>QOS_CLASS_UTILITY</span><span>,</span> <span>0</span><span>);</span>
</code></li>
        </ol>
      </div>
      <div>
          <p>Swift</p>
        <ol>
            <li><code><span>utilityGlobalQueue</span> = <span>dispatch_get_global_queue</span>(<span>QOS_CLASS_UTILITY</span>, <span>0</span>)</code></li>
        </ol>
      </div>
  </div>
</section><p>
  Queues that don’t have a QoS assigned and don’t target a global concurrent queue infer a QoS class of unspecified.
</p>
  
</section>
<section>
  <a name="//apple_ref/doc/uid/TP40013929-CH35-SW43"></a>
  <h3 tabindex="0">Dispatch Blocks</h3>
  <p>
  The GCD block API allows QoS classes to be applied at the block level, such as when calling <code><a href="https://developer.apple.com/documentation/dispatch/1453057-dispatch_async">dispatch_async</a></code>, <code><a href="https://developer.apple.com/documentation/dispatch/1452870-dispatch_sync">dispatch_sync</a></code>, <code><a href="https://developer.apple.com/documentation/dispatch/1452876-dispatch_after">dispatch_after</a></code>, <code><a href="https://developer.apple.com/documentation/dispatch/1453050-dispatch_apply">dispatch_apply</a></code>, or <code><a href="https://developer.apple.com/documentation/dispatch/1447169-dispatch_once">dispatch_once</a></code>. You do this when you create the block, as shown in <span>Listing 10-5</span>.
</p><section>
  <a name="//apple_ref/doc/uid/TP40013929-CH35-SW24"></a>
    <span><strong>Listing 10-5</strong>Assigning a QoS when creating a dispatch block</span>
  <div>
      <div>
          <p>Objective-C</p>
        <ol>
            <li><code><span>dispatch_block_t</span> <span>myBlock</span><span>;</span>
</code></li>
            <li><code><span>myBlock</span> <span>=</span> <span>dispatch_block_create_with_qos_class</span><span>)(</span>
</code></li>
            <li><code>     <span>0</span><span>,</span> <span>QOS_CLASS_UTILITY</span><span>,</span> <span>-</span><span>8</span><span>,</span> <span>^</span><span>{</span><span>…</span><span>});</span>
</code></li>
            <li><code><span>dispatch_async</span><span>(</span><span>myQueue</span><span>,</span> <span>myBlock</span><span>);</span>
</code></li>
        </ol>
      </div>
      <div>
          <p>Swift</p>
        <ol>
            <li><code><span>let</span> <span>myBlock</span> = <span>dispatch_block_create_with_qos_class</span>(<span>0</span>, <span>QOS_CLASS_UTILITY</span>) {</code></li>
            <li><code>    ...</code></li>
            <li><code>}</code></li>
            <li><code><span>dispatch_async</span>(<span>myQueue</span>, <span>myBlock</span>)</code></li>
        </ol>
      </div>
  </div>
</section>
  
</section>
<section>
  <a name="//apple_ref/doc/uid/TP40013929-CH35-SW44"></a>
  <h3 tabindex="0">Priority Inversions</h3>
  <p>
  When high-priority work becomes dependent on lower priority work, or it becomes the result of lower priority work, a <em>priority inversion</em> occurs. As a result, blocking, spinning, and polling may occur.
</p><p>
  In the case of synchronous work, the system will try to resolve the priority inversion automatically by raising the QoS of the lower priority work for the duration of the inversion. This will occur in the following situations:
</p><ul>
  <li><p>
  When <code>dispatch_sync()</code> and <code>dispatch_wait()</code> are called for a block on a serial queue.
</p>
</li><li><p>
  When <code>pthread_mutex_lock()</code> is called while the mutex is held by a thread with lower QoS. In this situation, the thread holding the lock is raised to the QoS of the caller. However, this QoS promotion does not occur across multiple locks.
</p>
</li>
</ul><p>
  In the case of asynchronous work, the system will attempt to resolve the priority inversions occurring on a serial queue.
</p>
  
</section>

</section>
<section>
  <a name="//apple_ref/doc/uid/TP40013929-CH35-SW38"></a>
  <h3 tabindex="0">Specify a QoS for Tasks and Threads</h3>
  <p>
  Tasks and threads also support QoS.
</p>
  <section>
  <a name="//apple_ref/doc/uid/TP40013929-CH35-SW2"></a>
  <h3 tabindex="0">NSTask and NSThread</h3>
  <p>
  Both <code><a href="https://developer.apple.com/library/archive/documentation/LegacyTechnologies/WebObjects/WebObjects_3.5/Reference/Frameworks/ObjC/Foundation/Classes/NSTask/Description.html#//apple_ref/occ/cl/NSTask" data-renderer-version="1">NSTask</a></code> and <code><a href="https://developer.apple.com/library/archive/documentation/LegacyTechnologies/WebObjects/WebObjects_3.5/Reference/Frameworks/ObjC/Foundation/Classes/NSThread/Description.html#//apple_ref/occ/cl/NSThread" data-renderer-version="1">NSThread</a></code> possesses a <code>qualityOfService</code> property, of type <code>NSQualityOfService</code>. These classes will not infer a QoS based on the context of their execution, so the value of this property may only be changed before the task or thread has started. Reading the <code>qualityOfService</code> of a task or thread at any time will provide its current value.
</p>
  
</section>
<section>
  <a name="//apple_ref/doc/uid/TP40013929-CH35-SW45"></a>
  <h3 tabindex="0">The Main Thread and the Current Thread</h3>
  <p>
  The main thread is automatically assigned a QoS based on its environment. In an app, the main thread runs at a QoS level of user-interactive. In an XPC service, the main thread runs at a QoS of default. To retrieve the QoS of the main thread, call the <code>qos_class_main</code> function, as shown in <span>Listing 10-6</span>.
</p><section>
  <a name="//apple_ref/doc/uid/TP40013929-CH35-SW22"></a>
    <span><strong>Listing 10-6</strong>Retrieving the QoS of the main thread</span>
  <div>
      <div>
          <p>Objective-C</p>
        <ol>
            <li><code><span>qosClass</span> <span>=</span> <span>qos_class_main</span><span>();</span>
</code></li>
        </ol>
      </div>
      <div>
          <p>Swift</p>
        <ol>
            <li><code><span>let</span> <span>qosClass</span> = <span>qos_class_main</span>()</code></li>
        </ol>
      </div>
  </div>
</section><p>
  To retrieve the QoS of the currently running thread, call the <code>qos_class_self</code> function, as shown in <span>Listing 10-7</span>.
</p><section>
  <a name="//apple_ref/doc/uid/TP40013929-CH35-SW23"></a>
    <span><strong>Listing 10-7</strong>Retrieving the QoS of the current thread</span>
  <div>
      <div>
          <p>Objective-C</p>
        <ol>
            <li><code><span>qosClass</span> <span>=</span> <span>qos_class_self</span><span>();</span>
</code></li>
        </ol>
      </div>
      <div>
          <p>Swift</p>
        <ol>
            <li><code><span>let</span> <span>qosClass</span> = <span>qos_class_self</span>()</code></li>
        </ol>
      </div>
  </div>
</section>
  
</section>
<section>
  <a name="//apple_ref/doc/uid/TP40013929-CH35-SW46"></a>
  <h3 tabindex="0">pthreads</h3>
  <p>
  You can assign a QoS class when creating a pthread by using an attribute, as shown in <span>Listing 10-8</span>, which creates a utility pthread.
</p><section>
  <a name="//apple_ref/doc/uid/TP40013929-CH35-SW25"></a>
    <span><strong>Listing 10-8</strong>Creating a pthread with a QoS</span>
  <div>
      <div>
          <p>Objective-C</p>
        <ol>
            <li><code><span>pthread_attr_t</span> <span>qosAttribute</span><span>;</span>
</code></li>
            <li><code><span>pthread_attr_init</span><span>(</span><span>&amp;</span><span>qosAttribute</span><span>);</span>
</code></li>
            <li><code><span>pthread_attr_set_qos_class_np</span><span>(</span><span>&amp;</span><span>qosAttribute</span><span>,</span> <span>QOS_CLASS_UTILITY</span><span>,</span> <span>0</span><span>);</span>
</code></li>
            <li><code><span>pthread_create</span><span>(</span><span>&amp;</span><span>thread</span><span>,</span> <span>&amp;</span><span>qosAttribute</span><span>,</span> <span>f</span><span>,</span> <span>NULL</span><span>);</span>
</code></li>
        </ol>
      </div>
      <div>
          <p>Swift</p>
        <ol>
            <li><code><span>var</span> <span>thread</span> = <span>pthread_t</span>()</code></li>
            <li><code><span>var</span> <span>qosAttribute</span> = <span>pthread_attr_t</span>()</code></li>
            <li><code><span>pthread_attr_init</span>(&amp;<span>qosAttribute</span>)</code></li>
            <li><code><span>pthread_attr_set_qos_class_np</span>(&amp;<span>qosAttribute</span>, <span>QOS_CLASS_UTILITY</span>, <span>0</span>)</code></li>
            <li><code><span>pthread_create</span>(&amp;<span>thread</span>, &amp;<span>qosAttribute</span>, <span>f</span>, <span>nil</span>)</code></li>
        </ol>
      </div>
  </div>
</section><p>
  To change the QoS of a pthread, call pthread_set_qos_class_self_np and pass it the new QoS to apply, as shown in <span>Listing 10-9</span>.
</p><section>
  <a name="//apple_ref/doc/uid/TP40013929-CH35-SW26"></a>
    <span><strong>Listing 10-9</strong>Changing the QoS of a pthread</span>
  <div>
      <div>
          <p>Objective-C</p>
        <ol>
            <li><code><span>pthread_set_qos_class_self_np</span><span>(</span><span>QOS_CLASS_BACKGROUND</span><span>,</span><span>0</span><span>);</span>
</code></li>
        </ol>
      </div>
      <div>
          <p>Swift</p>
        <ol>
            <li><code><span>pthread_set_qos_class_self_np</span>(<span>QOS_CLASS_BACKGROUND</span>, <span>0</span>)</code></li>
        </ol>
      </div>
  </div>
</section>
  
</section>

</section>
<section>
  <a name="//apple_ref/doc/uid/TP40013929-CH35-DontLinkElementID_1"></a>
  <h3 tabindex="0">About CloudKit and Quality of Service</h3>
  <p>
  If your app uses the CloudKit framework, it’s worth noting that certain CloudKit classes implement custom QoS behavior by default.
</p><ul>
  <li><p>
  <code><a href="https://developer.apple.com/documentation/cloudkit/ckoperation">CKOperation</a></code> is a subclass of the <code><a href="https://developer.apple.com/documentation/foundation/nsoperation">NSOperation</a></code> class. Although the <code>NSOperation</code> class has a default QoS level of <code>NSQualityOfServiceBackground</code>, <code>CKOperation</code> objects have a default QoS level of <code>NSQualityOfServiceUtility</code>. At this level, network requests are treated as discretionary when your app isn’t in use. 
</p>
</li><li><p>
  <code><a href="https://developer.apple.com/documentation/cloudkit/ckcontainer">CKContainer</a></code> is a subclass of the <code><a href="https://developer.apple.com/library/archive/documentation/LegacyTechnologies/WebObjects/WebObjects_3.5/Reference/Frameworks/ObjC/Foundation/Classes/NSObject/Description.html#//apple_ref/occ/cl/NSObject" data-renderer-version="1">NSObject</a></code> class. Interactions with <code>CKContainer</code> objects occur at a QoS level of <code>NSQualityOfServiceUserInitiated</code> by default.
</p>
</li><li><p>
  <code><a href="https://developer.apple.com/documentation/cloudkit/ckdatabase">CKDatabase</a></code> is a subclass of the <code>NSObject</code> class. Interactions with <code>CKContainer</code> objects occur at a QoS level of <code>NSQualityOfServiceUserInitiated</code> by default.
</p>
</li>
</ul><p>
  For information about CloudKit classes, see <em><a href="https://developer.apple.com/documentation/cloudkit" target="_self">CloudKit Framework Reference</a></em>.
</p>
  
</section>
<section>
  <a name="//apple_ref/doc/uid/TP40013929-CH35-SW9"></a>
  <h3 tabindex="0">Debugging Quality of Service Classes</h3>
  <p>
  There are several ways you can evaluate your code in order to determine whether a particular QoS has been applied.
</p>
  <section>
  <a name="//apple_ref/doc/uid/TP40013929-CH35-SW47"></a>
  <h3 tabindex="0">Xcode</h3>
  <p>
  By setting breakpoints in Xcode or pausing your app while testing, you can inspect your app with the CPU usage gauge in the debug navigator in order to confirm that requested QoS classes are being applied. See <span>Figure 10-1</span>.
</p><figure>
  <a name="//apple_ref/doc/uid/TP40013929-CH35-SW27"></a>
  <span><strong>Figure 10-1</strong>QoS classes in the Xcode CPU gauge</span>
  <img src="https://developer.apple.com/library/archive/documentation/Performance/Conceptual/power_efficiency_guidelines_osx/Art/xcode_cpu_gauge_qos_2x.png" alt="image: ../Art/xcode_cpu_gauge_qos_2x.png" width="607" height="321"/>
</figure>
  
</section>
<section>
  <a name="//apple_ref/doc/uid/TP40013929-CH35-SW10"></a>
  <h3 tabindex="0">powermetrics</h3>
  <p>
  Use the powermetrics tool to analyze your app and determine how much time is being allocated to different QoS classes.
</p><p>
  In <span>Listing 10-10</span>, metrics are retrieved for the running tasks on a device. The results show that an app is running primarily at a QoS level of user-interactive (<code>19.96</code>), with much less user-initiated (<code>0.62</code>), utility (<code>0.0</code>), and background (<code>0.0</code>) work occurring. As a result, the app is using more energy than if it were running more work at the lower QoS classes. If the breakdown provided for your app is not what you expect, then you should investigate further. Consider running <span><a href="#//apple_ref/doc/uid/TP40013929-CH35-SW30" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40013929-CH35-SW30">spindump</a></span> to analyze your code.
</p><section>
  <a name="//apple_ref/doc/uid/TP40013929-CH35-SW29"></a>
    <span><strong>Listing 10-10</strong>Example of QoS inspection via the powermetrics tool</span>
  <div>
      <div>
        <ol>
            <li><code>$ sudo powermetrics --show-process-qos --samplers tasks</code></li>
            <li><code>*** Sampled system activity (Fri Feb 20 11:55:48 2015 -0800) (5004.56ms elapsed) ***</code></li>
            <li><code> </code></li>
            <li><code>*** Running tasks ***</code></li>
            <li><code> </code></li>
            <li><code>Name   ID   CPU ms/s   User%   Deadlines   (&lt;2 ms, 2-5 ms)   Wakeups (Intr, Pkg idle)   QOS (ms/s)   Default   Maint   BG   Util   Lgcy   U-Init   U-Intr</code></li>
            <li><code>ListerOSX   8083   21.05   79.16   0.00   0.00   10.19   4.60   0.00   0.00   0.00   0.00   0.43   0.62   19.96</code></li>
        </ol>
      </div>
  </div>
</section><p>
  See <!-- a href="" target="_self" -->powermetrics(1) Mac OS X Manual Page<!-- /a --> for information on using this tool.
</p>
  
</section>
<section>
  <a name="//apple_ref/doc/uid/TP40013929-CH35-SW30"></a>
  <h3 tabindex="0">spindump</h3>
  <p>
  Use the spindump tool with the <code>-timeline</code> option to sample and profile your app in order to determine which QoS class applies as a specific portion of code executes at a given time. <span>Listing 10-11</span> shows that a thread is running at a QoS level of user-initiated.
</p><section>
  <a name="//apple_ref/doc/uid/TP40013929-CH35-SW31"></a>
    <span><strong>Listing 10-11</strong>Example of QoS inspection via the spindump tool</span>
  <div>
      <div>
        <ol>
            <li><code>$ sudo spindump -timeline ListerOSX</code></li>
            <li><code> </code></li>
            <li><code>Thread 0x48e64c     1000 samples (1-1000) priority 37</code></li>
            <li><code>&lt;thread QoS user initiated, IO policy standard&gt;</code></li>
            <li><code>1000  thread_start + 13 (libsystem_pthread.dylib + 5149) [0x7fff8c3aa41d] 1-1000</code></li>
            <li><code>  1000  _pthread_start + 176 (libsystem_pthread.dylib + 12773) [0x7fff8c3ac1e5] 1-1000</code></li>
            <li><code>    1000  _pthread_body + 131 (libsystem_pthread.dylib + 12904) [0x7fff8c3ac268] 1-1000</code></li>
        </ol>
      </div>
  </div>
</section><p>
  See <!-- a href="" target="_self" -->spindump(8) Mac OS X Manual Page<!-- /a --> for information on using this tool.
</p>
  
</section>

</section>

  	
 	<section id="next_previous">
    		<p><a href="https://developer.apple.com/library/archive/documentation/Performance/Conceptual/power_efficiency_guidelines_osx/PrioritizeWorkAtTheAppLevel.html#//apple_ref/doc/uid/TP40013929-CH36-SW1" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40013929-CH36-SW1">Prioritize Work at the App Level</a></p>
  			<p><a href="https://developer.apple.com/library/archive/documentation/Performance/Conceptual/power_efficiency_guidelines_osx/DiscretionaryTasks.html#//apple_ref/doc/uid/TP40013929-CH34-SW1" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40013929-CH34-SW1">Manage Tasks with CTS and GCD</a></p>

    <p>Copyright © 2018 Apple Inc. All rights reserved. 
  <a href="http://www.apple.com/legal/terms/site.html" target="_blank" rel="external">Terms of Use</a> | 
  <a href="http://www.apple.com/privacy/" target="_blank" rel="external">Privacy Policy</a> | 
  <a href="https://developer.apple.com/library/archive/documentation/Performance/Conceptual/power_efficiency_guidelines_osx/RevisionHistory.html#//apple_ref/doc/uid/TP40013929-CH99-SW1" data-renderer-version="2" data-id="//apple_ref/doc/uid/TP40013929-CH99-SW1">Updated: 2016-09-13</a>
</p>
  </section>
</article></div>
  </body>
</html>
