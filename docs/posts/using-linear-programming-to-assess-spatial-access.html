<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://andrewpwheeler.com/2022/07/01/using-linear-programming-to-assess-spatial-access/">Original</a>
    <h1>Using linear programming to assess spatial access</h1>
    
    <div id="readability-page-1" class="page"><div>

		<p>So one of the problems I have been thinking about at work is assessing spatial access to providers. Some common metrics are ‘distance to nearest’, or combining distance as well as total provider capacity into one metric, the <a href="https://en.wikipedia.org/wiki/Two-step_floating_catchment_area_method">two-step floating catchment method</a> (2SFCA).</p>
<p>So imagine we are trying to evaluate the coverage of opioid treatment facilities relative to the spatial distribution of people abusing opioids. Say for example we have two areas, A and B. Area A has a facility that can treat 50 people, but has a total of 100 people who need service. Now Area B has no treatment provider, but only has 10 people that need service.</p>
<p>If you looked at distance to nearest provider, location B would look worse than A. So you may think to yourself – we should open up a facility in Area B. But if you look at the total number of people, as well as the capacity of the treatment provider in Area A, it would probably be a better investment to expand the capacity of treatment center A. It has more potential demand.</p>
<p>The 2SFCA partially captures this, but I am going to show a linear programming approach that can decompose the added benefit of adding capacity to a particular provider, or adding in potential new providers. I have the posted <a href="https://github.com/apwheele/Blog_Code/tree/master/Python/assignlp">these functions on github</a>, but can walk through the linear programming model, and how to assess potential policy interventions in that framework.</p>
<p>So first lets make just a simple set of data, we have 10 people with XY coordinates, and 2 service providers. The two service providers have capacity 3 and 5, so we cannot cover 2 of the people.</p>
<pre><code># Python example code
import numpy as np
import pandas as pd
import pulp

# locations of people
id = range(10)
px = [1,1,3,3,4,5,6,6,9,9]
py = [2,8,1,8,4,6,1,2,5,8]
peop = pd.DataFrame(zip(id,px,py),columns=[&#39;id&#39;,&#39;px&#39;,&#39;py&#39;])

# locations of 2 providers &amp; capacity 3/5
hid = [1,2]
hx = [1,8]
hy = [1,8]
hc = [3,5] # so cant cover 2 people
prov = pd.DataFrame(zip(hid,hx,hy,hc),columns=[&#39;hid&#39;,&#39;hx&#39;,&#39;hy&#39;,&#39;hc&#39;])</code></pre>
<p>Now for the subsequent model I show, it is going to assign the people to the nearest possible provider, given the distance constraints. To make the model feasible, we need to add in a slack provider that can soak up the remaining people not covered. We set this location to somewhere very far away, so the model will only assign people to this slack provider in the case no other options are available.</p>
<pre><code># add in a slack location to the providers
# very out of the way and large capacity
prov_slack = prov.iloc[[0],:].copy()
prov_slack[&#39;hid&#39;] = 999
prov_slack[&#39;hx&#39;] = 999
prov_slack[&#39;hy&#39;] = 999
prov_slack[&#39;hc&#39;] = peop.shape[0]
prov_add = pd.concat([prov,prov_slack],axis=0)</code></pre>
<p>Now the decision model looks at all pairwise combinations between people and providers (potentially eliminating combinations that are too far away to be reasonable). So I do the cross join between the people/providers, and then calculate the Euclidean distance between them. I set the distance for the slack provider to a very high value (here 9999).</p>
<pre><code># distance between people/providers
peop[&#39;const&#39;] = 1
prov_add[&#39;const&#39;] = 1
cross = pd.merge(peop,prov_add,on=&#39;const&#39;)
cross[&#39;dist&#39;] = np.sqrt( (cross[&#39;px&#39;]-cross[&#39;hx&#39;])**2 + 
                         (cross[&#39;py&#39;]-cross[&#39;hy&#39;])**2 )
cross.set_index([&#39;id&#39;,&#39;hid&#39;],inplace=True)
# setting max distance for outside provider to 9999
cross.loc[cross.xs(999,level=&#34;hid&#34;,drop_level=False).index,&#34;dist&#34;] = 9999</code></pre>
<p>Now we are ready to fit our linear programming model. First our objective is to minimize distances. (If all inputs are integers, you can use continuous decision variables and it will still return integer solutions.)</p>
<pre><code># now setting up linear program
# each person assigned to a location
# locations have capacity
# minimize distance traveled

# Minimize distances
P = pulp.LpProblem(&#34;MinDist&#34;,pulp.LpMinimize)

# each pair gets a decision variable
D = pulp.LpVariable.dicts(&#34;DA&#34;,cross.index.tolist(),
                          lowBound=0, upBound=1, cat=pulp.LpContinuous)

# Objective function based on distance
P += pulp.lpSum(D[i]*cross.loc[i,&#39;dist&#39;] for i in cross.index)</code></pre>
<p>And we have two types of constraints, one is that each person is assigned a single provider in the end:</p>
<pre><code># Each person assigned to a single provider
for p in peop[&#39;id&#39;]:
    provl = cross.xs(p,0,drop_level=False).index
    P += pulp.lpSum(D[i] for i in provl) == 1, f&#34;pers_{p}&#34;</code></pre>
<p>As a note later on, I will expand this model to include multiple people from a single source (e.g. count of people in a zipcode). For that expanded model, this constraint turns into <code>pulp.lpSum(...) == tot</code> where <code>tot</code> is the total people in a single area.</p>
<p>The second constraint is that providers have a capacity limit.</p>
<pre><code># Each provider capacity constraint
for h in prov_add[&#39;hid&#39;]:
    peopl = cross.xs(h,level=1,drop_level=False)
    pid = peopl.index
    cap = peopl[&#39;hc&#39;].iloc[0] # should be a constant
    P += pulp.lpSum(D[i] for i in pid) &lt;= cap, f&#34;prov_{h}&#34;</code></pre>
<p>Now we can solve the model, and look at who was assigned to where:</p>
<pre><code># Solve the model
P.solve(pulp.PULP_CBC_CMD()) 
# CPLEX or CBC only ones I know of that return shadow
pulp.value(P.objective) #print objective 20024.33502494309


# Get the person distances
res_pick = []
for ph in cross.index:
    res_pick.append(D[ph].varValue)

cross[&#39;picked&#39;] = res_pick
cross[cross[&#39;picked&#39;] &gt; 0.99]</code></pre>
<p><img src="https://lh3.googleusercontent.com/pw/AM-JKLVtwms53SPC6PQcfLIWLAxvAyNuAWeb8b1nQyx9ZAwipMadrM1tfZ1AXTLQmjKwVk-10vGn_FpAtXIeZPLNSjnG70bePUlBKv-D2cINElBkMln5h-0n0zjo6919C0kppigeB-DYYqcVJnxFzD-qQoSM=w706-h330-no?authuser=0"/></p>
<p>So we can see two people were assigned the slack provider <code>999</code>. Note that some people are not even assigned the closest – person 7 <code>(6,2)</code> is assigned to provider <code>2</code> at a distance of <code>6.3</code>, it is only a distance of <code>5.1</code> away from provider 1. Because provider 1 has limited capacity though, they are assigned to provider 2 in the end.</p>
<p>In this framework, we can get the <a href="https://math.stackexchange.com/q/91504/16839"><em>shadow price</em></a> for the constraints, which says if we relax the constraint, how much it will improve our objective value.So if we add 1 capacity to provider 1, we will improve our objective by <code>-9994</code>.</p>
<pre><code># Get the shadow constraints per provider
o = [{&#39;name&#39;:name, &#39;shadow price&#39;:c.pi, &#39;slack&#39;: c.slack} 
     for name, c in P.constraints.items()]
sc = pd.DataFrame(o)
print(sc)</code></pre>
<p><img src="https://lh3.googleusercontent.com/pw/AM-JKLU4anN5v9TAM20psZjQdMReFJxoYgq4sSBuhoW9eaE4Z4htaooPODBF6_dz7LFiDX24IbmYFHK_vCc9Y8Q_oxmWSsh1K1K9kom65fYhQdDY7Dl9EJv7qoo4IRWgJDJz8ODCdOgO1cHa8JUGxxLSosus=w423-h381-no?authuser=0"/></p>
<p>I have helper functions at the <a href="https://github.com/apwheele/Blog_Code/tree/master/Python/assignlp">github link above</a>, so I don’t need to go through all of these motions again. You input your people matrix and the field names for the <code>id, x, y, totn</code> values.</p>
<p>And then you input your provider matrix with the field names for the <code>providerid, x, y, prov_capacity</code> (note this is not the matrix with the additional slack provider, my code adds that in automatically). The final two arguments limit the potential locations (e.g. here saying can’t assign a person to a provider over 12 distance away). And the last argument sets the super high distance penalty to people are not assigned.</p>
<pre><code># load in model functions
from assign_funcs import ProvAssign

# Const=1 is the total people per area
m1 = ProvAssign(peop,
                [&#39;id&#39;,&#39;px&#39;,&#39;py&#39;,&#39;const&#39;],
                prov,
                [&#39;hid&#39;,&#39;hx&#39;,&#39;hy&#39;,&#39;hc&#39;],
                12,
                9999)

m1.solve(pulp.PULP_CBC_CMD())
# see the same objective as before</code></pre>
<p>Now we can go ahead and up our capacity at provider 1 by 1, and see how the objective is reduced by -9994:</p>
<pre><code># if we up the provider capacity for
# prov by 1, the model objective goes 
# down by -9994
prov[&#39;hc&#39;] = [4,5]

m2 = ProvAssign(peop,
                [&#39;id&#39;,&#39;px&#39;,&#39;py&#39;,&#39;const&#39;],
                prov,
                [&#39;hid&#39;,&#39;hx&#39;,&#39;hy&#39;,&#39;hc&#39;],
                12,
                9999)
m2.solve(pulp.PULP_CBC_CMD())
m1.obj - m2.obj # 9994!</code></pre>
<p>Like I said, I extended this to the scenario that you don’t have individual people, but have multiple counts of people in a spatial area. What can happen in this scenario is one source location can send people to multiple providers. Here you can see that source location 4 (total of 12 people), 5 were sent to provider 1, and 7 were sent to provider 2.</p>
<pre><code># Can make these multiple people, 100 total
peop[&#39;tot&#39;] = [10,15,5,10,12,11,20,6,9,2]
prov[&#39;cap&#39;] = [40,50] # should assign 10 people to slack

m3 = ProvAssign(peop,
                [&#39;id&#39;,&#39;px&#39;,&#39;py&#39;,&#39;tot&#39;],
                prov,
                [&#39;hid&#39;,&#39;hx&#39;,&#39;hy&#39;,&#39;cap&#39;],
                12,
                9999)
m3.solve(pulp.PULP_CBC_CMD())
# Can see the assignments from one
# source can spill over into multiple
# provider locations
m3.assign</code></pre>
<p><img src="https://lh3.googleusercontent.com/pw/AM-JKLXyTueI-jwkUd1w_tsRW3YO8yBYvOMB2FCHKy0zo9PXGR3gXID3gTSAFwmEcqMQM3p-SfnMXk4YpIUj1G0x5llM3t_hHlgbwyUnfgabTs56PZLO5DEUPvnRAOmQz3MS2sIVYiPhuWoyhUKmSQposqrY=w537-h484-no?authuser=0"/></p>
<p>So one of the things I like about this approach I already showed, we can do hypothetical scenarios ‘add capacity’ and see how it improves overall travel. Another potential intervention is to just place dummy 0 capacity providers over the study area, then look at the shadow constraints to see the best locations to open new facilities. Here I add in a potential provider at location <code>(5,5)</code>.</p>
<pre><code># Can add in hypothetical providers with
# no capacity (make new providers)
# and check out the shadow
p2 = prov_slack.copy()
p2[&#39;hid&#39;] = 10
p2[&#39;hx&#39;] = 5
p2[&#39;hy&#39;] = 5
p2[&#39;hc&#39;] = 0
p2[&#39;cap&#39;] = 0
prov_add = pd.concat([prov,p2],axis=0)


m4 = ProvAssign(peop,
                [&#39;id&#39;,&#39;px&#39;,&#39;py&#39;,&#39;tot&#39;],
                prov_add,
                [&#39;hid&#39;,&#39;hx&#39;,&#39;hy&#39;,&#39;cap&#39;],
                10,
                9999)

# we now don&#39;t have source9 and prov1
m4.cross</code></pre>
<p>Here in the code, I also have a function to limit potential assignments. Here if I set that limit to 10, it only just prevents id 9 <code>(9,8)</code> from being assigned to provider 1 <code>(1,1)</code>, which is a distance of 10.6 away. This is useful with larger datasets, in which you may not be able to fit <em>all</em> of the pairwise distances into memory and model. (Although this model is pretty simple, you may be able to look at +1 million pairwise combos and solve in a reasonable time with open source solvers.)</p>
<p><img src="https://lh3.googleusercontent.com/pw/AM-JKLXye4RItG78HmqswrUuDHwBSItIQ_WhN-Olpl928F5eTUBIELYWys1Zf3fiRb5HhtmP3SGZLaw4jb7tjljKdzkS8AqLtU5fNvW7ni9DK4ZIqn9qup6hbSLtUAlMXek9SsL9_nwQ7f5uX2rrM_srvsV1=w529-h871-no?authuser=0"/></p>
<p>Now we can go ahead and solve this model. I have a bunch of helper functions as well, so after solving we can check out the shadow price matrix:</p>
<pre><code># Solve m4 model
m4.solve(pulp.PULP_CBC_CMD())

# can see the new provider 10
# if we added capacity would
# decrease distance travelled by -9996.2426
m4.shadow</code></pre>
<p><img src="https://lh3.googleusercontent.com/pw/AM-JKLXBc8cPvijJbXQMpzLbpIv3-j04gnfwJrjghfxTChMaiab7yIt85eiApUw4dDuDld1BVKlEHcodJsk0l8lqMCTiGgs3QtExWMXzORSjDkyHiAlbbrCS9kzsbTfLbUnpkkANz6y9sESiG7GYrIPsqNPx=w718-h418-no?authuser=0"/></p>
<p>And based on this, it does look like we will have the best improvement by adding capacity at our hypothetical new provider 10, as oppossed to adding capacity at provider 1 or 2. Lets see what happens if you add 10 capacity to our hypothetical provider:</p>
<pre><code># Now lets add capacity for new provider
# by 10, should the objective go down
# by 10*-9996.2426 ?
prov_add[&#39;cap&#39;] = [40,50,10]

m5 = ProvAssign(peop,
                [&#39;id&#39;,&#39;px&#39;,&#39;py&#39;,&#39;tot&#39;],
                prov_add,
                [&#39;hid&#39;,&#39;hx&#39;,&#39;hy&#39;,&#39;cap&#39;],
                12,
                9999)
m5.solve(pulp.PULP_CBC_CMD())

# Not quite -9996.2 but close!
(m5.obj - m4.obj)/10</code></pre>
<p>We can see that the objective was not quite reduced by the expected, but is close. If it is not feasible to add a totally new provider, but simpler to give resources to expand current ones, we can see what will happen if we expand provider 1 by 10.</p>
<pre><code># we could add capacity
# to provider 1 by 10
# as well
prov_add[&#39;cap&#39;] = [50,50,0]

m6 = ProvAssign(peop,
                [&#39;id&#39;,&#39;px&#39;,&#39;py&#39;,&#39;tot&#39;],
                prov_add,
                [&#39;hid&#39;,&#39;hx&#39;,&#39;hy&#39;,&#39;cap&#39;],
                10,
                9999)
m6.solve(pulp.PULP_CBC_CMD())

# Not quite -9993.4 but close!
(m6.obj - m4.obj)/10</code></pre>
<p>In addition to doing different policy interventions in this approach, I provide different metrics to assess distance traveled and coverage. So going back to model 4, we can look at which areas have limited coverage. It only ends up that source area 1 has 10/15 people not covered. The rest of the areas are covered.</p>
<pre><code># Can look at sources and see stats
# for distance travelled as well
# as potential non-coverage
m4.source_stats</code></pre>
<p><img src="https://lh3.googleusercontent.com/LCoylNbAr49vzYntojMwPUJ6z4YtWNZHcG5W731lny0aE3UGdRdW9Z6SD3BUfot9Z18tpR4OnWdEizEUx2D_-yHvJT5blMDmKLJfojDVxlf7rkQrygaZiI8p6wXH-T1XfeexacCwVjrDjiFbpl3-1LOTpYAYh5garFoe_4FowlTWUwoHwTaO5nOxmgvgB5wnfIedpK2y-NXyw_Cgt3UzOlKHLamNbrtyEjbkH_Mnqfl5VexKT06vwVpBrLHLEnwnyBzTYlGKDZYqy0RZ1zW7DlviD35mkhzePC2sSDxHEByyN0Rf8eUcufEZZxsve5qB21XbpRu7AliNbRGeRu6CsWXULmmW2VtMSV5IBlVQ8Nv9Q9qsVZaVHDv9gfl3fsYWMHnIhX720e-gskOSdJUgxTpQEWM6QaLUjNpiM8ZccY59lLnclXLBDgSlXlVhuSu_qVSZWke-9UX99q4hcy6b0yT1sVz0YutiqKVsc0W5Hm_lMZhiEEOjBuql0riEgg2t1miUDt2FqbO5Ao6yOQg4Y_AUGVnMX-DSBM5Ox57BorUO7cZk0lCfI4o8trhkn7Ncqvqw984qujl6YPkoH3-pvX3nJJFoM1l9mf3FenEsfPye8LBSN9MkqfdqnN4z9PQx2RoFOCw1aHbkYKdLM1bSDcrcGaNjkcOfbETzhaJ5a-V2N4sihm2sa54X7g_DwFi4-GblXh8xvoOTHpFakA_8e8CXH2WbQfoHXjalae6muqWy9JrCzY1k32Q67p8=w471-h305-no?authuser=0"/></p>
<p>The fields are <code>Trav</code> is the average distance travelled for people who are covered (so could have high coverage but those people have to go a ways). <code>Tot</code> is the total number of people within that particular source area, and picked/not-covered are those assigned a provider/not assigned a provider (so go to the slack) respectively.</p>
<p>I additionally I have stats available rolled up to providers, mostly based on the not covered nearby. One way that the shadow doesn’t work, if you only have 10 people nearby, it doesn’t make sense to expand capacity to any more than 10 people. Here you can see the shadow price, as well as those not covered that are nearby to that provider.</p>
<pre><code># Can look at providers
# and see which ones would result in
# most reduced travel given increased coverage
# Want high NotCover and low shadow price
m4.prov_stats</code></pre>
<p><img src="https://lh3.googleusercontent.com/_Apfsa1EmaOQbOfQs6eNIPjVcd6Bft9JWb-lASgqum5TKkFtoh-_Dc6UYzv-rjmoPJH4ks1EESpa_94yYrR05uAZV9XMuoeygU0JNMQcmycKdnrDYoaEAayvmPf92gRG_DgRPNQ_q21zGURsQR68UracapiSZBKvtgBmRz4VDi7uxaeJbdh9xK61ez7zEqoE2-OcC1WBCe-bfg6ZcTD_EzACFZSbldjOYRXWMQYToOfQF4-Y9MOqjhsAyHbM_7bLc7xJHzzhBBjfukWVdPVHJbtU2XGK5yP9PC16lmGwvFwuzR_KhiHdYsAFdvsLokrkWn9tyCZpYRi3jrl0717W3iGZdZHxezjSuVuuvjQSnci_3UCHEEsgi63aRFEfJr_6MPO2BrcQddP8lMVd0G-TeYlz_3tbMqcGCaMSFr3tzjksECMkXwrtK5r5UtI5RWcEylWAiS2l29zkw3b75FQJRL_7Nh6r0GSzwylgI1_m8VYWBvUb17ZM5SGQzObpds9j3WRmm9VpB4omgACsAVH3xu7YSCn2eGavjLFe4H6JA-35NlMXPyZ1bRHQYh6d_d0I3gwdmEBiyN6wNU6auXsScZbvxrJdEW58hscv8PmwNXmlRHLo50mvdtOWySnSFHgNQZb208ZPtWGgW1dUwxRc8UuVmJMJFgN8J6PIscia6YGzLkXDDvoZTNGrwSHETwHAkWDuSceZqXi3CvnflXUfNBxaiAiqrzHDtEuKvL6unpXQXm33Q1j4rMMwvBU"/></p>
<p>The other fields, <code>hc</code> is the listed capacity. <code>Trav</code> is the total travel for those not covered. The last field <code>bisqw</code>, is a way to only partially count not covered based on distance. It uses the bi-square kernel weight, based on the max distance field you provided in the model object. So if many people are nearby it will get a higher weight.</p>
<p>Here good add capacity locations are those with low shadow prices, and high notcovered/bisqw fields.</p>
<p>Note these won’t per se give the best potential places to add capacity. It may be the best new solution is to spread out new capacity – so here instead of adding 10 to a single provider, add a few to different providers.</p>
<p>You could technically figure that out by slicing out those leftover people in the <code>m4.source_stats</code> that have some not covered, adding in extra capacity to each provider, and then rerunning the algorithm and seeing where they end up.</p>
<p>Again I like this approach as it lets you articulate different policy proposals and see how that changes the coverage/distance travelled. Although no doubt there are other ways to formulate the problem that may make sense, such as maximizing coverage or making a coverage/distance bi-objective function.</p>
		</div></div>
  </body>
</html>
