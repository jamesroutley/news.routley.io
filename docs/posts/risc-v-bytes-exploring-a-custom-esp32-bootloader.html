<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://danielmangum.com/posts/risc-v-bytes-exploring-custom-esp32-bootloader/">Original</a>
    <h1>RISC-V Bytes: Exploring a Custom ESP32 Bootloader</h1>
    
    <div id="readability-page-1" class="page"><div>
        
        <p>I recently acquired an
<a href="https://docs.espressif.com/projects/esp-idf/en/latest/esp32c3/hw-reference/esp32c3/user-guide-devkitc-02.html">ESP32-C3-DevKitC-02</a>
module, and, as I tend to do, jumped right into reading about how the system
boots and how the (pretty good!) tooling <a href="https://www.espressif.com">Espressif</a>
offers works. We have typically used <a href="https://www.qemu.org/">QEMU</a> in the
<a href="https://danielmangum.com/categories/risc-v-bytes/">RISC-V Bytes</a> series, but
getting our hands on physical hardware starts to make things feel a bit more
real. In this first post on the ESP32, we’ll do some basic setup and look at a
simple custom bootloader.</p>
<p><img src="https://danielmangum.com/static/risc_v_esp32_boot_header.png" alt="risc-v-esp32-boot-header"/></p>
<h2 id="sections">
  Sections
  <a href="#sections">
    <i aria-hidden="true" title="Link to heading"></i>
    <span>Link to heading</span>
  </a>
</h2>
<ul>
<li><a href="#booting-up">Booting Up</a></li>
<li><a href="#installing-tools">Installing Tools</a></li>
<li><a href="#the-boot-process">The Boot Process</a></li>
<li><a href="#the-serial-protocol">The Serial Protocol</a></li>
<li><a href="#overriding-the-second-stage-bootloader">Overriding the Second Stage
Bootloader</a></li>
<li><a href="#looking-behind-the-scenes">Looking Behind the Scenes</a></li>
<li><a href="#concluding-thoughts">Concluding Thoughts</a></li>
</ul>
<h2 id="booting-up">
  Booting Up
  <a href="#booting-up">
    <i aria-hidden="true" title="Link to heading"></i>
    <span>Link to heading</span>
  </a>
</h2>
<p>The system boots when power is supplied. Because of this, to monitor the logs,
you’ll likely need to issue a reset after opening the serial port with a tool
such as <code>minicom</code>. With the device connected to your machine, you should be able
to find the serial port under <code>/dev/ttyUSB*</code>. On my machine it was
<code>/dev/ttyUSB0</code>. The baud rate is <code>115200</code>, which is the default for <code>minicom</code>.</p>
<div><pre tabindex="0"><code data-lang="fallback"><span><span>$ minicom -D /dev/ttyUSB0
</span></span></code></pre></div><p>If we then press the <code>RST</code> button, we should see output. Before overwriting, a
<a href="https://docs.espressif.com/projects/esp-rainmaker/en/latest/index.html">Rainmaker</a>
demo was pre-programmed on my module, and it printed some ASCII art over the
serial port.</p>

<p>Espressif provides tooling that makes building projects for any ESP32 module
much simpler. Though certainly not strictly required, Espressif highly
recommends the use of the <a href="https://github.com/espressif/esp-idf"><code>esp-idf</code> (ESP IOT Development
Framework)</a>. In the root of the
repository, you’ll find instructions to get started with one of the install
scripts. As usual, I am on a Linux machine, so I used the <a href="https://github.com/espressif/esp-idf/blob/master/install.sh"><code>install.sh</code>
script</a>.</p>
<div><pre tabindex="0"><code data-lang="fallback"><span><span>$ ./install.sh
</span></span><span><span>Detecting the Python interpreter
</span></span><span><span>Checking &#34;python3&#34; ...
</span></span><span><span>Python 3.8.10
</span></span><span><span>&#34;python3&#34; has been detected
</span></span><span><span>Checking Python compatibility
</span></span><span><span>Installing ESP-IDF tools
</span></span><span><span>Current system platform: linux-amd64
</span></span><span><span>Selected targets are: esp32c2, esp32c6, esp32s2, esp32c3, esp32, esp32s3, esp32h4, esp32h2
</span></span><span><span>Installing tools: xtensa-esp-elf-gdb, riscv32-esp-elf-gdb, xtensa-esp32-elf, xtensa-esp32s2-elf, xtensa-esp32s3-elf, riscv32-esp-elf, esp32ulp-elf, openocd-esp32, esp-rom-elfs
</span></span><span><span>Skipping xtensa-esp-elf-gdb@12.1_20221002 (already installed)
</span></span><span><span>Skipping riscv32-esp-elf-gdb@12.1_20221002 (already installed)
</span></span><span><span>Skipping xtensa-esp32-elf@esp-12.2.0_20230208 (already installed)
</span></span><span><span>Skipping xtensa-esp32s2-elf@esp-12.2.0_20230208 (already installed)
</span></span><span><span>Skipping xtensa-esp32s3-elf@esp-12.2.0_20230208 (already installed)
</span></span><span><span>Skipping riscv32-esp-elf@esp-12.2.0_20230208 (already installed)
</span></span><span><span>Skipping esp32ulp-elf@2.35_20220830 (already installed)
</span></span><span><span>Skipping openocd-esp32@v0.11.0-esp32-20221026 (already installed)
</span></span><span><span>Skipping esp-rom-elfs@20230113 (already installed)
</span></span><span><span>Installing Python environment and packages
</span></span><span><span>...
</span></span><span><span>Installing collected packages: esp-idf-monitor
</span></span><span><span>  Attempting uninstall: esp-idf-monitor
</span></span><span><span>    Found existing installation: esp-idf-monitor 1.0.1
</span></span><span><span>    Uninstalling esp-idf-monitor-1.0.1:
</span></span><span><span>      Successfully uninstalled esp-idf-monitor-1.0.1
</span></span><span><span>Successfully installed esp-idf-monitor-1.0.0
</span></span><span><span>All done! You can now run:
</span></span><span><span>
</span></span><span><span>  . ./export.sh
</span></span></code></pre></div><p>By default, this will install the toolchains for all targets (or skip if they
are already present as shown above). It will also install supporting tools, such
as <code>idf.py</code> and <code>esptool</code>. You can take a look at everything installed in
<code>~/.espressif</code>.</p>
<div><pre tabindex="0"><code data-lang="fallback"><span><span>$ ls ~/.espressif/tools/
</span></span><span><span>esp32ulp-elf/        esp-rom-elfs/        openocd-esp32/       riscv32-esp-elf/     riscv32-esp-elf-gdb/ xtensa-esp32-elf/    xtensa-esp32s2-elf/  xtensa-esp32s3-elf/  xtensa-esp-elf-gdb/
</span></span><span><span>
</span></span><span><span>$ ls ~/.espressif/python_env/idf5.1_py3.8_env/bin/
</span></span><span><span>activate               allmodconfig           doesitcache            esptool.py             menuconfig             pip                    pyserial-miniterm      savedefconfig
</span></span><span><span>activate.csh           allnoconfig            esp-coredump           futurize               normalizer             pip3                   pyserial-ports         setconfig
</span></span><span><span>activate.fish          allyesconfig           espefuse.py            genconfig              oldconfig              pip3.8                 python                 tqdm
</span></span><span><span>Activate.ps1           compote                esp_rfc2217_server.py  guiconfig              olddefconfig           __pycache__/           python3                west
</span></span><span><span>alldefconfig           defconfig              espsecure.py           listnewconfig          pasteurize             pykwalify              readelf.py    
</span></span></code></pre></div><p>To add the necessary tools to your <code>$PATH</code>, the corresponding export script can
be sourced.</p>
<div><pre tabindex="0"><code data-lang="fallback"><span><span>$ . ./export.sh 
</span></span><span><span>Detecting the Python interpreter
</span></span><span><span>Checking &#34;python3&#34; ...
</span></span><span><span>Python 3.8.10
</span></span><span><span>&#34;python3&#34; has been detected
</span></span><span><span>Checking Python compatibility
</span></span><span><span>Checking other ESP-IDF version.
</span></span><span><span>Using a supported version of tool cmake found in PATH: 3.16.3.
</span></span><span><span>However the recommended version is 3.24.0.
</span></span><span><span>Adding ESP-IDF tools to PATH...
</span></span><span><span>Using a supported version of tool cmake found in PATH: 3.16.3.
</span></span><span><span>However the recommended version is 3.24.0.
</span></span><span><span>Checking if Python packages are up to date...
</span></span><span><span>Constraint file: /home/dan/.espressif/espidf.constraints.v5.1.txt
</span></span><span><span>Requirement files:
</span></span><span><span> - /home/dan/code/github.com/espressif/esp-idf/tools/requirements/requirements.core.txt
</span></span><span><span>Python being checked: /home/dan/.espressif/python_env/idf5.1_py3.8_env/bin/python
</span></span><span><span>Python requirements are satisfied.
</span></span><span><span>Added the following directories to PATH:
</span></span><span><span>  /home/dan/code/github.com/espressif/esp-idf/components/esptool_py/esptool
</span></span><span><span>  /home/dan/code/github.com/espressif/esp-idf/components/espcoredump
</span></span><span><span>  /home/dan/code/github.com/espressif/esp-idf/components/partition_table
</span></span><span><span>  /home/dan/code/github.com/espressif/esp-idf/components/app_update
</span></span><span><span>Done! You can now compile ESP-IDF projects.
</span></span><span><span>Go to the project directory and run:
</span></span><span><span>
</span></span><span><span>  idf.py build
</span></span></code></pre></div><p>As indicated in the output, we are now ready to start building!</p>
<h2 id="the-boot-process">
  The Boot Process
  <a href="#the-boot-process">
    <i aria-hidden="true" title="Link to heading"></i>
    <span>Link to heading</span>
  </a>
</h2>
<p>The boot process is described in detail in the <a href="https://docs.espressif.com/projects/esp-idf/en/latest/esp32c3/api-guides/startup.html">ESP32-C3 API
Guide</a>.
The main takeaway is that booting is a two stage process, where the first stage
bootloader, which is stored in ROM and cannot be modified, loads the second
stage one. The second stage bootloader lives in flash memory at offset <code>0x0</code>,
but is loaded into RAM by the first stage bootloader.</p>
<p><img src="https://danielmangum.com/static/risc_v_esp32_boot_0.png" alt="risc-v-esp32-boot-0"/></p>
<p>Before diving deeper, it is useful to understand the various components of the
ESP32-C3-DevKitC-02. The ESP32-C3 is the system-on-chip (SoC), but lives inside
of the ESP32­-C3-­WROOM-­02 module. The module surrounds the SoC with
peripherals, such as SPI flash and a PCB Antenna, enabling the combined unit to
utilize WiFi, Bluetooth LE, and more. The module itself is surrounded by other
peripherals on the development kit PCB, such as the micro-USB port and
USB-to-UART bridge, making it much easier to interact with from our host
machine.</p>
<p><img src="https://danielmangum.com/static/risc_v_esp32_boot_1.png" alt="risc-v-esp32-boot-1"/></p>
<p>In order to overwrite the second stage bootloader in flash, we’ll need to
communicate with the ESP32-C3, which will then talk over the SPI bus to the
flash that lives beside it in the WROOM module.</p>
<h2 id="the-serial-protocol">
  The Serial Protocol
  <a href="#the-serial-protocol">
    <i aria-hidden="true" title="Link to heading"></i>
    <span>Link to heading</span>
  </a>
</h2>
<p>One of the tools installed during setup was <code>esptool.py</code>. Though most of the
documentation uses <code>idf.py</code>, many of the commands it offers are just wrapping
<code>esptool.py</code> and passing necessary flags. The ESP32-C3 can be configured <a href="https://docs.espressif.com/projects/esptool/en/latest/esp32c3/advanced-topics/boot-mode-selection.html">to
boot in “serial
mode”</a>,
which implements a <a href="https://docs.espressif.com/projects/esptool/en/latest/esp32c3/advanced-topics/serial-protocol.html">serial
protocol</a>
with support for a variety of commands that allow for operations such as reading
and writing to flash. Interestingly, by default <code>esptool.py</code> will load a <a href="https://docs.espressif.com/projects/esptool/en/latest/esp32c3/esptool/flasher-stub.html">stub
bootloader</a>
that implements the same protocol, but has some optimizations and additional
features. You can choose to skip loading the stub bootloader by passing the
<code>--no-stub</code> argument to any command.</p>
<p>The serial protocol is based on the <a href="https://en.wikipedia.org/wiki/Serial_Line_Internet_Protocol">Serial Line Internet
Protocol</a>. The
<a href="https://docs.espressif.com/projects/esptool/en/latest/esp32c3/advanced-topics/serial-protocol.html">documentation</a>
provides the full specification for packet format, but the general structure for
commands and responses are reproduced below.</p>
<p><strong>Command Packets</strong></p>
<table>
<thead>
<tr>
<th>Byte</th>
<th>Name</th>
<th>Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>Direction</td>
<td>Always 0x00 for requests</td>
</tr>
<tr>
<td>1</td>
<td>Command</td>
<td>Command identifier (see Commands).</td>
</tr>
<tr>
<td>2-3</td>
<td>Size</td>
<td>Length of Data field, in bytes.</td>
</tr>
<tr>
<td>4-7</td>
<td>Checksum</td>
<td>Simple checksum of part of the data field (only used for some commands, see Checksum).</td>
</tr>
<tr>
<td>8..n</td>
<td>Data</td>
<td>Variable length data payload (0-65535 bytes, as indicated by Size parameter). Usage depends on specific command.</td>
</tr>
</tbody>
</table>
<p><strong>Response Packets</strong></p>
<table>
<thead>
<tr>
<th>Byte</th>
<th>Name</th>
<th>Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>Direction</td>
<td>Always 0x01 for responses</td>
</tr>
<tr>
<td>1</td>
<td>Command</td>
<td>Same value as Command identifier in the request packet that triggered the response</td>
</tr>
<tr>
<td>2-3</td>
<td>Size</td>
<td>Size of data field. At least the length of the Status Bytes (2 or 4 bytes, see below).</td>
</tr>
<tr>
<td>4-7</td>
<td>Value</td>
<td>Response value used by READ_REG command (see below). Zero otherwise.</td>
</tr>
<tr>
<td>8..n</td>
<td>Data</td>
<td>Variable length data payload. Length indicated by “Size” field.</td>
</tr>
</tbody>
</table>
<p>Command sequences used for <a href="https://docs.espressif.com/projects/esptool/en/latest/esp32c3/advanced-topics/serial-protocol.html#writing-data">writing
data</a>
follow a similar pattern of a single <em>begin</em> command, followed by some number of
<em>data</em> commands, then a single <em>end</em> command. This pattern is used to both load
the stub bootloader and, subsequently, load the second stage bootloader. The
former is written to RAM, while the latter is written to flash. The commands for
writing to RAM are:</p>
<ul>
<li><code>MEM_BEGIN</code> (<code>0x05</code>)</li>
<li><code>MEM_DATA</code> (<code>0x07</code>)</li>
<li><code>MEM_END</code> (<code>0x06</code>)</li>
</ul>
<p>The <code>MEM_END</code> command supports supplying an execute flag and an address in RAM
(each 32-bit words) that the chip will begin executing instructions at if
execute flag is set. The commands for writing to flash are:</p>
<ul>
<li><code>FLASH_BEGIN</code> (<code>0x02</code>)</li>
<li><code>FLASH_DATA</code> (<code>0x03</code>)</li>
<li><code>FLASH_END</code> (<code>0x04</code>)</li>
</ul>
<p>The <code>FLASH_END</code> command can supply a single 32-bit word and if the value is <code>0</code>
the chip will reboot.</p>
<h2 id="overriding-the-second-stage-bootloader">
  Overriding the Second Stage Bootloader
  <a href="#overriding-the-second-stage-bootloader">
    <i aria-hidden="true" title="Link to heading"></i>
    <span>Link to heading</span>
  </a>
</h2>
<p>Fortunately, the <code>esp-idf</code> repo has an
<a href="https://github.com/espressif/esp-idf/tree/master/examples/custom_bootloader/bootloader_override">example</a>
of how the second stage bootloader can be overridden. It is quite similar to the
<a href="https://github.com/espressif/esp-idf/tree/master/components/bootloader">default second stage
bootloader</a>,
but it <a href="https://github.com/espressif/esp-idf/blob/master/examples/custom_bootloader/bootloader_override/bootloader_components/main/Kconfig">allows for
customizing</a>
an additional message that is printed on startup.</p>
<p>Prior to running the commands in the <code>README.md</code>, we need to specify which ESP32
SoC we are targeting.</p>
<div><pre tabindex="0"><code data-lang="fallback"><span><span>$ idf.py set-target esp32c3
</span></span><span><span>Adding &#34;set-target&#34;&#39;s dependency &#34;fullclean&#34; to list of commands with default set of options.
</span></span><span><span>Executing action: fullclean
</span></span><span><span>Executing action: set-target
</span></span><span><span>Set Target to: esp32c3, new sdkconfig will be created.
</span></span><span><span>...
</span></span><span><span>-- Configuring done
</span></span><span><span>-- Generating done
</span></span><span><span>-- Build files have been written to: /home/dan/code/github.com/espressif/esp-idf/examples/custom_bootloader/bootloader_override/build
</span></span></code></pre></div><p>This will ensure that we have the necessary toolchain components and setup the
proper configuration (<code>sdkconfig</code>). It will also setup the <code>build</code> directory
machinery, which we can then exercise.</p>
<div><pre tabindex="0"><code data-lang="fallback"><span><span>$ idf.py build
</span></span><span><span>Executing action: all (aliases: build)
</span></span><span><span>Running cmake in directory /home/dan/code/github.com/espressif/esp-idf/examples/custom_bootloader/bootloader_override/build
</span></span><span><span>Executing &#34;cmake -G Ninja -DPYTHON_DEPS_CHECKED=1 -DPYTHON=/home/dan/.espressif/python_env/idf5.1_py3.8_env/bin/python -DESP_PLATFORM=1 -DCCACHE_ENABLE=0 /home/dan/code/github.com/espressif/esp-idf/examples/custom_bootloader/bootloader_override&#34;...
</span></span><span><span>-- IDF_TARGET is not set, guessed &#39;esp32c3&#39; from sdkconfig &#39;/home/dan/code/github.com/espressif/esp-idf/examples/custom_bootloader/bootloader_override/sdkconfig&#39;
</span></span><span><span>...
</span></span><span><span>[848/849] Generating binary image from built executable
</span></span><span><span>esptool.py v4.5.1
</span></span><span><span>Creating esp32c3 image...
</span></span><span><span>Merged 1 ELF section
</span></span><span><span>Successfully created esp32c3 image.
</span></span><span><span>Generated /home/dan/code/github.com/espressif/esp-idf/examples/custom_bootloader/bootloader_override/build/main.bin
</span></span><span><span>[849/849] cd /home/dan/code/github.com/espressif/esp-idf/examples/custom_bootloader/bootloader_override/build/esp-idf/esptool_py &amp;&amp; /home/dan/.espressif/python_env/idf5.1_py3.8_env/bin/python /home/dan/code/github.com/espressif/esp-idf/components/partition_table/check_sizes.py --offset 0x8000 partition --type app /home/dan/code/github.com/espressif/esp-idf/examples/custom_bootloader/bootloader_override/build/partition_table/partition-table.bin /home/dan/code/github.com/espressif/esp-idf/examples/custom_bootloader/bootloader_override/build/main.bin
</span></span><span><span>main.bin binary size 0x28e00 bytes. Smallest app partition is 0x100000 bytes. 0xd7200 bytes (84%) free.
</span></span><span><span>
</span></span><span><span>Project build complete. To flash, run this command:
</span></span><span><span>/home/dan/.espressif/python_env/idf5.1_py3.8_env/bin/python ../../../components/esptool_py/esptool/esptool.py -p (PORT) -b 460800 --before default_reset --after hard_reset --chip esp32c3  write_flash --flash_mode dio --flash_size 2MB --flash_freq 80m 0x0 build/bootloader/bootloader.bin 0x8000 build/partition_table/partition-table.bin 0x10000 build/main.bin
</span></span><span><span>or run &#39;idf.py -p (PORT) flash&#39;
</span></span></code></pre></div><p>We can see that it automatically defaulted to the <code>esp32c3</code> target, built
artifacts, and provided the command to be used to flash the device. The two
command options demonstrate how <code>idf.py</code> wraps <code>esptool</code>, which will write three
different binaries to various locations in flash with the <code>write_flash</code> command.</p>
<ul>
<li><code>build/bootloader/bootloader.bin</code> will be written to <code>0x0</code></li>
<li><code>build/partition_table/partition-table.bin</code> will be written to <code>0x8000</code></li>
<li><code>build/main.bin</code> will be written to <code>0x10000</code></li>
</ul>
<p>We’ll dig a little deeper into what the binaries are, as well as why they are
being written to those offsets in flash in the next section, but first let’s see
it in action!</p>
<blockquote>
<p>NOTE: we can leave off <code>-p /dev/ttyUSB0</code> as it is the default.</p>
</blockquote>
<div><pre tabindex="0"><code data-lang="fallback"><span><span>$ idf.py flash
</span></span><span><span>Executing action: flash
</span></span><span><span>Serial port /dev/ttyUSB0
</span></span><span><span>Connecting....
</span></span><span><span>Detecting chip type... ESP32-C3
</span></span><span><span>Running ninja in directory /home/dan/code/github.com/espressif/esp-idf/examples/custom_bootloader/bootloader_override/build
</span></span><span><span>Executing &#34;ninja flash&#34;...
</span></span><span><span>[1/5] cd /home/dan/code/github.com/espressif/esp-idf/examples/custom_bootloader/bootloader_override/build/esp-idf/esptool_py &amp;&amp; /home/dan/.espressif/python_env/idf5.1_py3.8_env/bin/python /home/dan/code/github.com/espressif/esp-idf/components/partition_table/check_sizes.py --offset 0x8000 partition --type app /home/dan/code/github.com/espressif/esp-idf/examples/custom_bootloader/bootloader_override/build/partition_table/partition-table.bin /home/dan/code/github.com/espressif/esp-idf/examples/custom_bootloader/bootloader_override/build/main.bin
</span></span><span><span>main.bin binary size 0x28e00 bytes. Smallest app partition is 0x100000 bytes. 0xd7200 bytes (84%) free.
</span></span><span><span>[2/5] Performing build step for &#39;bootloader&#39;
</span></span><span><span>[1/1] cd /home/dan/code/github.com/espressif/esp-idf/examples/custom_bootloader/bootloader_override/build/bootloader/esp-idf/esptool_py &amp;&amp; /home/dan/.espressif/python_env/idf5.1_py3.8_env/bin/python /home/dan/code/github.com/espressif/esp-idf/components/partition_table/check_sizes.py --offset 0x8000 bootloader 0x0 /home/dan/code/github.com/espressif/esp-idf/examples/custom_bootloader/bootloader_override/build/bootloader/bootloader.bin
</span></span><span><span>Bootloader binary size 0x5080 bytes. 0x2f80 bytes (37%) free.
</span></span><span><span>[2/3] cd /home/dan/code/github.com/espressif/esp-idf/components/esptool_py &amp;&amp; /usr/bin/cmake -D IDF_PATH=/home/dan/code/github.com/espressif/esp-idf -D &#34;SERIAL_TOOL=/home/dan/.espressif/python_env/idf5.1_py3.8_env/bin/python;;/home/dan/code/github.com/espressif/esp-idf/components/esptool_py/esptool/esptool.py;--chip;esp32c3&#34; -D &#34;SERIAL_TOOL_ARGS=--before=default_reset;--after=hard_reset;write_flash;@flash_args&#34; -D WORKING_DIRECTORY=/home/dan/code/github.com/espressif/esp-idf/examples/custom_bootloader/bootloader_override/build -P /home/dan/code/github.com/espressif/esp-idf/components/esptool_py/run_serial_tool.cmake
</span></span><span><span>esptool esp32c3 -p /dev/ttyUSB0 -b 460800 --before=default_reset --after=hard_reset write_flash --flash_mode dio --flash_freq 80m --flash_size 2MB 0x0 bootloader/bootloader.bin 0x10000 main.bin 0x8000 partition_table/partition-table.bin
</span></span><span><span>esptool.py v4.5.1
</span></span><span><span>Serial port /dev/ttyUSB0
</span></span><span><span>Connecting....
</span></span><span><span>Chip is ESP32-C3 (revision v0.3)
</span></span><span><span>Features: WiFi, BLE
</span></span><span><span>Crystal is 40MHz
</span></span><span><span>MAC: 58:cf:79:16:7d:a0
</span></span><span><span>Uploading stub...
</span></span><span><span>Running stub...
</span></span><span><span>Stub running...
</span></span><span><span>Changing baud rate to 460800
</span></span><span><span>Changed.
</span></span><span><span>Configuring flash size...
</span></span><span><span>Flash will be erased from 0x00000000 to 0x00005fff...
</span></span><span><span>Flash will be erased from 0x00010000 to 0x00038fff...
</span></span><span><span>Flash will be erased from 0x00008000 to 0x00008fff...
</span></span><span><span>Compressed 20608 bytes to 12655...
</span></span><span><span>Writing at 0x00000000... (100 %)
</span></span><span><span>Wrote 20608 bytes (12655 compressed) at 0x00000000 in 0.7 seconds (effective 244.4 kbit/s)...
</span></span><span><span>Hash of data verified.
</span></span><span><span>Compressed 167424 bytes to 88511...
</span></span><span><span>Writing at 0x00010000... (16 %)
</span></span><span><span>Writing at 0x0001a51f... (33 %)
</span></span><span><span>Writing at 0x0002104c... (50 %)
</span></span><span><span>Writing at 0x00028442... (66 %)
</span></span><span><span>Writing at 0x0002ec04... (83 %)
</span></span><span><span>Writing at 0x00035e5c... (100 %)
</span></span><span><span>Wrote 167424 bytes (88511 compressed) at 0x00010000 in 2.8 seconds (effective 477.3 kbit/s)...
</span></span><span><span>Hash of data verified.
</span></span><span><span>Compressed 3072 bytes to 103...
</span></span><span><span>Writing at 0x00008000... (100 %)
</span></span><span><span>Wrote 3072 bytes (103 compressed) at 0x00008000 in 0.1 seconds (effective 295.2 kbit/s)...
</span></span><span><span>Hash of data verified.
</span></span><span><span>
</span></span><span><span>Leaving...
</span></span><span><span>Hard resetting via RTS pin...
</span></span><span><span>Done
</span></span></code></pre></div><p>Much of the logic in this step can be found in the
<a href="https://github.com/espressif/esptool/blob/53ae5eba4f968cfb49aefe8667e7d03a085ca1fa/esptool/cmds.py#L321">source</a>
for the <code>write_flash</code> command, but at a high level the steps are as follows:</p>
<ol>
<li>Load stub bootloader.</li>
</ol>
<div><pre tabindex="0"><code data-lang="fallback"><span><span>...
</span></span><span><span>Uploading stub...
</span></span><span><span>Running stub...
</span></span><span><span>Stub running...
</span></span><span><span>...
</span></span></code></pre></div><ol start="2">
<li>Erase flash sections.</li>
</ol>
<div><pre tabindex="0"><code data-lang="fallback"><span><span>...
</span></span><span><span>Configuring flash size...
</span></span><span><span>Flash will be erased from 0x00000000 to 0x00005fff...
</span></span><span><span>Flash will be erased from 0x00010000 to 0x00038fff...
</span></span><span><span>Flash will be erased from 0x00008000 to 0x00008fff...
</span></span><span><span>...
</span></span></code></pre></div><ol start="3">
<li>Write second stage bootloader to flash.</li>
</ol>
<div><pre tabindex="0"><code data-lang="fallback"><span><span>...
</span></span><span><span>Compressed 20608 bytes to 12655...
</span></span><span><span>Writing at 0x00000000... (100 %)
</span></span><span><span>Wrote 20608 bytes (12655 compressed) at 0x00000000 in 0.7 seconds (effective 244.4 kbit/s)...
</span></span><span><span>Hash of data verified.
</span></span><span><span>...
</span></span></code></pre></div><ol start="4">
<li>Write application to flash.</li>
</ol>
<div><pre tabindex="0"><code data-lang="fallback"><span><span>...
</span></span><span><span>Compressed 167424 bytes to 88511...
</span></span><span><span>Writing at 0x00010000... (16 %)
</span></span><span><span>Writing at 0x0001a51f... (33 %)
</span></span><span><span>Writing at 0x0002104c... (50 %)
</span></span><span><span>Writing at 0x00028442... (66 %)
</span></span><span><span>Writing at 0x0002ec04... (83 %)
</span></span><span><span>Writing at 0x00035e5c... (100 %)
</span></span><span><span>Wrote 167424 bytes (88511 compressed) at 0x00010000 in 2.8 seconds (effective 477.3 kbit/s)...
</span></span><span><span>Hash of data verified.
</span></span><span><span>...
</span></span></code></pre></div><ol start="5">
<li>Write partition table to flash.</li>
</ol>
<div><pre tabindex="0"><code data-lang="fallback"><span><span>...
</span></span><span><span>Compressed 3072 bytes to 103...
</span></span><span><span>Writing at 0x00008000... (100 %)
</span></span><span><span>Wrote 3072 bytes (103 compressed) at 0x00008000 in 0.1 seconds (effective 295.2 kbit/s)...
</span></span><span><span>Hash of data verified.
</span></span><span><span>...
</span></span></code></pre></div><ol start="6">
<li>Reset chip.</li>
</ol>
<div><pre tabindex="0"><code data-lang="fallback"><span><span>...
</span></span><span><span>Leaving...
</span></span><span><span>Hard resetting via RTS pin...
</span></span><span><span>Done
</span></span></code></pre></div><p>In order to see what happens on boot now, we can once again connect via
<code>minicom</code> and press the <code>RST</code> button.</p>
<div><pre tabindex="0"><code data-lang="fallback"><span><span>$ minicom -D /dev/ttyUSB0
</span></span><span><span>
</span></span><span><span>ESP-ROM:esp32c3-api1-20210207
</span></span><span><span>Build:Feb  7 2021
</span></span><span><span>rst:0x1 (POWERON),boot:0xc (SPI_FAST_FLASH_BOOT)
</span></span><span><span>SPIWP:0xee
</span></span><span><span>mode:DIO, clock div:1
</span></span><span><span>load:0x3fcd5820,len:0x1754
</span></span><span><span>load:0x403cc710,len:0x970
</span></span><span><span>load:0x403ce710,len:0x2f68
</span></span><span><span>entry 0x403cc710
</span></span><span><span>I (30) boot: ESP-IDF 4f0769d2ed 2nd stage bootloader
</span></span><span><span>I (30) boot: compile time Apr  8 2023 18:51:23
</span></span><span><span>I (30) boot: chip revision: v0.3
</span></span><span><span>I (34) boot.esp32c3: SPI Speed      : 80MHz
</span></span><span><span>I (38) boot.esp32c3: SPI Mode       : DIO
</span></span><span><span>I (43) boot.esp32c3: SPI Flash Size : 2MB
</span></span><span><span>I (48) boot: Enabling RNG early entropy source...
</span></span><span><span>I (53) boot: Partition Table:
</span></span><span><span>I (57) boot: ## Label            Usage          Type ST Offset   Length
</span></span><span><span>I (64) boot:  0 nvs              WiFi data        01 02 00009000 00006000
</span></span><span><span>I (71) boot:  1 phy_init         RF data          01 01 0000f000 00001000
</span></span><span><span>I (79) boot:  2 factory          factory app      00 00 00010000 00100000
</span></span><span><span>I (86) boot: End of partition table
</span></span><span><span>[boot] Custom bootloader message defined in the KConfig file.
</span></span><span><span>I (96) esp_image: segment 0: paddr=00010020 vaddr=3c020020 size=08480h ( 33920) map
</span></span><span><span>I (110) esp_image: segment 1: paddr=000184a8 vaddr=3fc8aa00 size=01110h (  4368) load
</span></span><span><span>I (114) esp_image: segment 2: paddr=000195c0 vaddr=40380000 size=06a58h ( 27224) load
</span></span><span><span>I (126) esp_image: segment 3: paddr=00020020 vaddr=42000020 size=15018h ( 86040) map
</span></span><span><span>I (143) esp_image: segment 4: paddr=00035040 vaddr=40386a58 size=03d9ch ( 15772) load
</span></span><span><span>I (149) boot: Loaded app from partition at offset 0x10000
</span></span><span><span>I (149) boot: Disabling RNG early entropy source...
</span></span><span><span>I (163) cpu_start: Pro cpu up.
</span></span><span><span>I (172) cpu_start: Pro cpu start user code
</span></span><span><span>I (172) cpu_start: cpu freq: 160000000 Hz
</span></span><span><span>I (172) cpu_start: Application information:
</span></span><span><span>I (175) cpu_start: Project name:     main
</span></span><span><span>I (180) cpu_start: App version:      4f0769d2ed
</span></span><span><span>I (185) cpu_start: Compile time:     Apr  8 2023 18:51:16
</span></span><span><span>I (191) cpu_start: ELF file SHA256:  3916cd87115c6efe...
</span></span><span><span>I (197) cpu_start: ESP-IDF:          4f0769d2ed
</span></span><span><span>I (203) cpu_start: Min chip rev:     v0.3
</span></span><span><span>I (207) cpu_start: Max chip rev:     v0.99 
</span></span><span><span>I (212) cpu_start: Chip rev:         v0.3
</span></span><span><span>I (217) heap_init: Initializing. RAM available for dynamic allocation:
</span></span><span><span>I (224) heap_init: At 3FC8C940 len 0004FDD0 (319 KiB): DRAM
</span></span><span><span>I (230) heap_init: At 3FCDC710 len 00002950 (10 KiB): STACK/DRAM
</span></span><span><span>I (237) heap_init: At 50000020 len 00001FE0 (7 KiB): RTCRAM
</span></span><span><span>I (244) spi_flash: detected chip: generic
</span></span><span><span>I (248) spi_flash: flash io: dio
</span></span><span><span>W (252) spi_flash: Detected size(4096k) larger than the size in the binary image header(2048k). Using the size in the binary image header.
</span></span><span><span>I (265) sleep: Configure to isolate all GPIO pins in sleep state
</span></span><span><span>I (272) sleep: Enable automatic switching of GPIO sleep configuration
</span></span><span><span>I (279) app_start: Starting scheduler on CPU0
</span></span><span><span>I (284) main_task: Started on CPU0
</span></span><span><span>I (284) main_task: Calling app_main()
</span></span><span><span>Application started!
</span></span><span><span>I (294) main_task: Returned from app_main()
</span></span></code></pre></div><p>The second stage bootloader is loaded and executed successfully, as evidenced by
the custom message.</p>
<div><pre tabindex="0"><code data-lang="fallback"><span><span>[boot] Custom bootloader message defined in the KConfig file.
</span></span></code></pre></div><p>We can also see the message from the simple application that the bootloader
jumps to.</p>
<h2 id="looking-behind-the-scenes">
  Looking Behind the Scenes
  <a href="#looking-behind-the-scenes">
    <i aria-hidden="true" title="Link to heading"></i>
    <span>Link to heading</span>
  </a>
</h2>
<p>Now that we’ve run the example custom bootloader, let’s explore the binary to
get a sense of what is happening behind the scenes. The entrypoint to the second
stage bootloader is
<a href="https://github.com/espressif/esp-idf/blob/42261df71f12b0b995774d103ce68e40e8fba529/examples/custom_bootloader/bootloader_override/bootloader_components/main/bootloader_start.c#L22"><code>call_start_cpu0(void)</code></a>.</p>
<p><code>examples/custom_bootloader/bootloader_override/bootloader_components/main/bootloader_start.c</code></p>
<div><pre tabindex="0"><code data-lang="c"><span><span><span>/*
</span></span></span><span><span><span> * We arrive here after the ROM bootloader finished loading this second stage bootloader from flash.
</span></span></span><span><span><span> * The hardware is mostly uninitialized, flash cache is down and the app CPU is in reset.
</span></span></span><span><span><span> * We do have a stack, so we can do the initialization in C.
</span></span></span><span><span><span> */</span>
</span></span><span><span><span>void</span> __attribute__((noreturn)) call_start_cpu0(<span>void</span>)
</span></span><span><span>{
</span></span><span><span>    <span>// 1. Hardware initialization
</span></span></span><span><span><span></span>    <span>if</span> (bootloader_init() != ESP_OK) {
</span></span><span><span>        bootloader_reset();
</span></span><span><span>    }
</span></span><span><span>
</span></span><span><span><span>#ifdef CONFIG_BOOTLOADER_SKIP_VALIDATE_IN_DEEP_SLEEP
</span></span></span><span><span><span></span>    <span>// If this boot is a wake up from the deep sleep then go to the short way,
</span></span></span><span><span><span></span>    <span>// try to load the application which worked before deep sleep.
</span></span></span><span><span><span></span>    <span>// It skips a lot of checks due to it was done before (while first boot).
</span></span></span><span><span><span></span>    bootloader_utility_load_boot_image_from_deep_sleep();
</span></span><span><span>    <span>// If it is not successful try to load an application as usual.
</span></span></span><span><span><span></span><span>#endif
</span></span></span><span><span><span></span>
</span></span><span><span>    <span>// 2. Select the number of boot partition
</span></span></span><span><span><span></span>    <span>bootloader_state_t</span> bs = {<span>0</span>};
</span></span><span><span>    <span>int</span> boot_index = select_partition_number(&amp;bs);
</span></span><span><span>    <span>if</span> (boot_index == INVALID_INDEX) {
</span></span><span><span>        bootloader_reset();
</span></span><span><span>    }
</span></span><span><span>
</span></span><span><span>    <span>// 2.1 Print a custom message!
</span></span></span><span><span><span></span>    esp_rom_printf(<span>&#34;[%s] %s</span><span>\n</span><span>&#34;</span>, TAG, CONFIG_EXAMPLE_BOOTLOADER_WELCOME_MESSAGE);
</span></span><span><span>
</span></span><span><span>    <span>// 3. Load the app image for booting
</span></span></span><span><span><span></span>    bootloader_utility_load_boot_image(&amp;bs, boot_index);
</span></span><span><span>}
</span></span></code></pre></div><p>The provided comments are helpful to understand what is happening, and we’ll
explore them in a moment, but how does the first stage bootloader know to jump
here? Our custom bootloader is reusing the <a href="https://github.com/espressif/esp-idf/blob/master/components/bootloader/subproject/main/ld/esp32c3/bootloader.ld">same linker
script</a>
as the default second stage bootloader, which defines the entrypoint at the
location of the <code>call_start_cpu0</code> function.</p>
<p><code>components/bootloader/subproject/main/ld/esp32c3/bootloader.ld</code></p>
<div><pre tabindex="0"><code data-lang="fallback"><span><span>/* Default entry point: */
</span></span><span><span>ENTRY(call_start_cpu0);
</span></span></code></pre></div><p>It also defines a <a href="https://github.com/espressif/esp-idf/blob/42261df71f12b0b995774d103ce68e40e8fba529/components/bootloader/subproject/main/ld/esp32c3/bootloader.ld#L38">few memory
regions</a>
for instruction memory (<code>IRAM</code>) and data memory (<code>DRAM</code>).</p>
<p><code>components/bootloader/subproject/main/ld/esp32c3/bootloader.ld</code></p>
<div><pre tabindex="0"><code data-lang="fallback"><span><span>MEMORY
</span></span><span><span>{
</span></span><span><span>  iram_seg (RWX) :                  org = bootloader_iram_seg_start, len = bootloader_iram_seg_len
</span></span><span><span>  iram_loader_seg (RWX) :           org = bootloader_iram_loader_seg_start, len = bootloader_iram_loader_seg_len
</span></span><span><span>  dram_seg (RW) :                   org = bootloader_dram_seg_start, len = bootloader_dram_seg_len
</span></span><span><span>}
</span></span></code></pre></div><p>The entrypoint is loaded at the beginning of th <code>IRAM</code> segment.</p>
<p><code>components/bootloader/subproject/main/ld/esp32c3/bootloader.ld</code></p>
<div><pre tabindex="0"><code data-lang="fallback"><span><span>  .iram.text :
</span></span><span><span>  {
</span></span><span><span>    . = ALIGN (16);
</span></span><span><span>    *(.entry.text)
</span></span><span><span>    *(.init.literal)
</span></span><span><span>    *(.init)
</span></span><span><span>  } &gt; iram_seg
</span></span></code></pre></div><p>We can see this layout in effect by examining the
<a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">ELF</a> file we
built for the bootloader image. If you successfully added all installed tools to
your path, you should be able to use <code>riscv32-esp-elf-objdump</code>.</p>
<div><pre tabindex="0"><code data-lang="fallback"><span><span>$ riscv32-esp-elf-objdump -h build/bootloader/bootloader.elf 
</span></span><span><span>
</span></span><span><span>build/bootloader/bootloader.elf:     file format elf32-littleriscv
</span></span><span><span>
</span></span><span><span>Sections:
</span></span><span><span>Idx Name          Size      VMA       LMA       File off  Algn
</span></span><span><span>  0 .iram_loader.text 00002f66  403ce710  403ce710  00003710  2**1
</span></span><span><span>                  CONTENTS, ALLOC, LOAD, READONLY, CODE
</span></span><span><span>  1 .iram.text    00000000  403cc710  403cc710  00006676  2**0
</span></span><span><span>                  CONTENTS
</span></span><span><span>  2 .dram0.bss    00000110  3fcd5710  3fcd5710  00000710  2**2
</span></span><span><span>                  ALLOC
</span></span><span><span>  3 .dram0.data   00000004  3fcd5820  3fcd5820  00000820  2**2
</span></span><span><span>                  CONTENTS, ALLOC, LOAD, DATA
</span></span><span><span>  4 .dram0.rodata 00001750  3fcd5824  3fcd5824  00000824  2**2
</span></span><span><span>                  CONTENTS, ALLOC, LOAD, READONLY, DATA
</span></span><span><span>  5 .iram.text    0000096e  403cc710  403cc710  00002710  2**1
</span></span><span><span>                  CONTENTS, ALLOC, LOAD, READONLY, CODE
</span></span><span><span>  6 .debug_info   000229fa  00000000  00000000  00006676  2**0
</span></span><span><span>                  CONTENTS, READONLY, DEBUGGING, OCTETS
</span></span><span><span>  7 .debug_abbrev 000048b6  00000000  00000000  00029070  2**0
</span></span><span><span>                  CONTENTS, READONLY, DEBUGGING, OCTETS
</span></span><span><span>  8 .debug_loc    000075d6  00000000  00000000  0002d926  2**0
</span></span><span><span>                  CONTENTS, READONLY, DEBUGGING, OCTETS
</span></span><span><span>  9 .debug_aranges 00000808  00000000  00000000  00034efc  2**0
</span></span><span><span>                  CONTENTS, READONLY, DEBUGGING, OCTETS
</span></span><span><span> 10 .debug_ranges 000015b8  00000000  00000000  00035704  2**0
</span></span><span><span>                  CONTENTS, READONLY, DEBUGGING, OCTETS
</span></span><span><span> 11 .debug_line   00010e82  00000000  00000000  00036cbc  2**0
</span></span><span><span>                  CONTENTS, READONLY, DEBUGGING, OCTETS
</span></span><span><span> 12 .debug_str    0000a1e0  00000000  00000000  00047b3e  2**0
</span></span><span><span>                  CONTENTS, READONLY, DEBUGGING, OCTETS
</span></span><span><span> 13 .comment      0000002f  00000000  00000000  00051d1e  2**0
</span></span><span><span>                  CONTENTS, READONLY
</span></span><span><span> 14 .riscv.attributes 0000003f  00000000  00000000  00051d4d  2**0
</span></span><span><span>                  CONTENTS, READONLY
</span></span><span><span> 15 .debug_frame  000014bc  00000000  00000000  00051d8c  2**2
</span></span><span><span>                  CONTENTS, READONLY, DEBUGGING, OCTETS
</span></span></code></pre></div><blockquote>
<p>NOTE: the <code>-h</code> flag indicates that we want just the section headers.</p>
</blockquote>
<p>We see two <code>.iram.text</code> sections, which look identical except for the <code>Size</code> and
<code>Algn</code> (alignment). Because all of the <code>.iram.text</code> symbols are 16-bit aligned
(<code>ALIGN (16)</code>), the 1-byte aligned section (<code>2**0</code> or <code>2^0 = 1</code>) is empty, and
all of the data is in the 2-byte aligned (<code>2**0</code> or <code>2^1 = 2</code>) section. Both
sections have the same virtual memory address (<code>VMA</code>), which makes sense given
that the size of the first section is <code>0</code>. We can jump to the <code>.iram.text</code>
section to see if our <code>call_start_cpu0</code> function is indeed present.</p>
<div><pre tabindex="0"><code data-lang="fallback"><span><span>$ riscv32-esp-elf-objdump -D -j .iram.text build/bootloader/bootloader.elf | head -46
</span></span><span><span>
</span></span><span><span>build/bootloader/bootloader.elf:     file format elf32-littleriscv
</span></span><span><span>
</span></span><span><span>
</span></span><span><span>Disassembly of section .iram.text:
</span></span><span><span>
</span></span><span><span>403cc710 &lt;call_start_cpu0&gt;:
</span></span><span><span>403cc710:	7171                	addi	sp,sp,-176
</span></span><span><span>403cc712:	d706                	sw	ra,172(sp)
</span></span><span><span>403cc714:	d522                	sw	s0,168(sp)
</span></span><span><span>403cc716:	d326                	sw	s1,164(sp)
</span></span><span><span>403cc718:	2895                	jal	403cc78c &lt;bootloader_init&gt;
</span></span><span><span>403cc71a:	c119                	beqz	a0,403cc720 &lt;call_start_cpu0+0x10&gt;
</span></span><span><span>403cc71c:	55a030ef          	jal	ra,403cfc76 &lt;bootloader_reset&gt;
</span></span><span><span>403cc720:	0a000613          	li	a2,160
</span></span><span><span>403cc724:	4581                	li	a1,0
</span></span><span><span>403cc726:	850a                	mv	a0,sp
</span></span><span><span>403cc728:	ffc34097          	auipc	ra,0xffc34
</span></span><span><span>403cc72c:	c2c080e7          	jalr	-980(ra) # 40000354 &lt;memset&gt;
</span></span><span><span>403cc730:	850a                	mv	a0,sp
</span></span><span><span>403cc732:	19a030ef          	jal	ra,403cf8cc &lt;bootloader_utility_load_partition_table&gt;
</span></span><span><span>403cc736:	3fcd64b7          	lui	s1,0x3fcd6
</span></span><span><span>403cc73a:	ed19                	bnez	a0,403cc758 &lt;call_start_cpu0+0x48&gt;
</span></span><span><span>403cc73c:	688020ef          	jal	ra,403cedc4 &lt;esp_log_early_timestamp&gt;
</span></span><span><span>403cc740:	85aa                	mv	a1,a0
</span></span><span><span>403cc742:	3fcd6537          	lui	a0,0x3fcd6
</span></span><span><span>403cc746:	86c48613          	addi	a2,s1,-1940 # 3fcd586c &lt;_data_end+0x48&gt;
</span></span><span><span>403cc74a:	87450513          	addi	a0,a0,-1932 # 3fcd5874 &lt;_data_end+0x50&gt;
</span></span><span><span>403cc74e:	ffc34097          	auipc	ra,0xffc34
</span></span><span><span>403cc752:	8f2080e7          	jalr	-1806(ra) # 40000040 &lt;esp_rom_printf&gt;
</span></span><span><span>403cc756:	b7d9                	j	403cc71c &lt;call_start_cpu0+0xc&gt;
</span></span><span><span>403cc758:	850a                	mv	a0,sp
</span></span><span><span>403cc75a:	3a0030ef          	jal	ra,403cfafa &lt;bootloader_utility_get_selected_boot_partition&gt;
</span></span><span><span>403cc75e:	f9d00793          	li	a5,-99
</span></span><span><span>403cc762:	842a                	mv	s0,a0
</span></span><span><span>403cc764:	faf50ce3          	beq	a0,a5,403cc71c &lt;call_start_cpu0+0xc&gt;
</span></span><span><span>403cc768:	3fcd6637          	lui	a2,0x3fcd6
</span></span><span><span>403cc76c:	3fcd6537          	lui	a0,0x3fcd6
</span></span><span><span>403cc770:	86c48593          	addi	a1,s1,-1940
</span></span><span><span>403cc774:	8a860613          	addi	a2,a2,-1880 # 3fcd58a8 &lt;_data_end+0x84&gt;
</span></span><span><span>403cc778:	8e050513          	addi	a0,a0,-1824 # 3fcd58e0 &lt;_data_end+0xbc&gt;
</span></span><span><span>403cc77c:	ffc34097          	auipc	ra,0xffc34
</span></span><span><span>403cc780:	8c4080e7          	jalr	-1852(ra) # 40000040 &lt;esp_rom_printf&gt;
</span></span><span><span>403cc784:	85a2                	mv	a1,s0
</span></span><span><span>403cc786:	850a                	mv	a0,sp
</span></span><span><span>403cc788:	50a030ef          	jal	ra,403cfc92 &lt;bootloader_utility_load_boot_image&gt;
</span></span></code></pre></div><blockquote>
<p>NOTE: the <code>-D</code> flag indicates that we want to disassemble all section
contents. The <code>-j .iram.text</code> indicates that we only want the contents of the
<code>.iram.text</code> section.</p>
</blockquote>
<p>Here we see the familiar function prologue of growing our stack (<code>addi sp,sp,-176</code>) and storing our <a href="https://danielmangum.com/posts/risc-v-bytes-caller-callee-registers/">callee-saved
registers</a>
(<code>s0</code>, <code>s1</code>) on it, before progressing through the various calls to bootloader
utility functions. The <code>bootloader_init()</code> implementation varies per SoC, but
the high-level steps are fairly similar. The <code>esp32c3</code>
<a href="https://github.com/espressif/esp-idf/blob/42261df71f12b0b995774d103ce68e40e8fba529/components/bootloader_support/src/esp32c3/bootloader_esp32c3.c#L128">implementation</a>
is shown below.</p>
<p><code>components/bootloader_support/src/esp32c3/bootloader_esp32c3.c</code></p>
<div><pre tabindex="0"><code data-lang="c"><span><span><span>esp_err_t</span> bootloader_init(<span>void</span>)
</span></span><span><span>{
</span></span><span><span>    <span>esp_err_t</span> ret = ESP_OK;
</span></span><span><span>
</span></span><span><span>    bootloader_hardware_init();
</span></span><span><span>    bootloader_ana_reset_config();
</span></span><span><span>    bootloader_super_wdt_auto_feed();
</span></span><span><span>
</span></span><span><span><span>// In RAM_APP, memory will be initialized in `call_start_cpu0`
</span></span></span><span><span><span></span><span>#if !CONFIG_APP_BUILD_TYPE_RAM
</span></span></span><span><span><span></span>    <span>// protect memory region
</span></span></span><span><span><span></span>    bootloader_init_mem();
</span></span><span><span>    <span>/* check that static RAM is after the stack */</span>
</span></span><span><span>    assert(&amp;_bss_start &lt;= &amp;_bss_end);
</span></span><span><span>    assert(&amp;_data_start &lt;= &amp;_data_end);
</span></span><span><span>    <span>// clear bss section
</span></span></span><span><span><span></span>    bootloader_clear_bss_section();
</span></span><span><span><span>#endif </span><span>// !CONFIG_APP_BUILD_TYPE_RAM
</span></span></span><span><span><span></span>
</span></span><span><span>    <span>// init eFuse virtual mode (read eFuses to RAM)
</span></span></span><span><span><span></span><span>#ifdef CONFIG_EFUSE_VIRTUAL
</span></span></span><span><span><span></span>    ESP_LOGW(TAG, <span>&#34;eFuse virtual mode is enabled. If Secure boot or Flash encryption is enabled then it does not provide any security. FOR TESTING ONLY!&#34;</span>);
</span></span><span><span><span>#ifndef CONFIG_EFUSE_VIRTUAL_KEEP_IN_FLASH
</span></span></span><span><span><span></span>    esp_efuse_init_virtual_mode_in_ram();
</span></span><span><span><span>#endif
</span></span></span><span><span><span>#endif
</span></span></span><span><span><span></span>    <span>// config clock
</span></span></span><span><span><span></span>    bootloader_clock_configure();
</span></span><span><span>    <span>// initialize console, from now on, we can use esp_log
</span></span></span><span><span><span></span>    bootloader_console_init();
</span></span><span><span>    <span>/* print 2nd bootloader banner */</span>
</span></span><span><span>    bootloader_print_banner();
</span></span><span><span>
</span></span><span><span><span>#if !CONFIG_APP_BUILD_TYPE_PURE_RAM_APP
</span></span></span><span><span><span></span>    <span>//init cache hal
</span></span></span><span><span><span></span>    cache_hal_init();
</span></span><span><span>    <span>//init mmu
</span></span></span><span><span><span></span>    mmu_hal_init();
</span></span><span><span>    <span>// update flash ID
</span></span></span><span><span><span></span>    bootloader_flash_update_id();
</span></span><span><span>    <span>// Check and run XMC startup flow
</span></span></span><span><span><span></span>    <span>if</span> ((ret = bootloader_flash_xmc_startup()) != ESP_OK) {
</span></span><span><span>        ESP_LOGE(TAG, <span>&#34;failed when running XMC startup flow, reboot!&#34;</span>);
</span></span><span><span>        <span>return</span> ret;
</span></span><span><span>    }
</span></span><span><span><span>#if !CONFIG_APP_BUILD_TYPE_RAM
</span></span></span><span><span><span></span>    <span>// read bootloader header
</span></span></span><span><span><span></span>    <span>if</span> ((ret = bootloader_read_bootloader_header()) != ESP_OK) {
</span></span><span><span>        <span>return</span> ret;
</span></span><span><span>    }
</span></span><span><span>    <span>// read chip revision and check if it&#39;s compatible to bootloader
</span></span></span><span><span><span></span>    <span>if</span> ((ret = bootloader_check_bootloader_validity()) != ESP_OK) {
</span></span><span><span>        <span>return</span> ret;
</span></span><span><span>    }
</span></span><span><span><span>#endif  </span><span>//#if !CONFIG_APP_BUILD_TYPE_RAM
</span></span></span><span><span><span></span>    <span>// initialize spi flash
</span></span></span><span><span><span></span>    <span>if</span> ((ret = bootloader_init_spi_flash()) != ESP_OK) {
</span></span><span><span>        <span>return</span> ret;
</span></span><span><span>    }
</span></span><span><span><span>#endif </span><span>// !CONFIG_APP_BUILD_TYPE_PURE_RAM_APP
</span></span></span><span><span><span></span>
</span></span><span><span>    <span>// check whether a WDT reset happend
</span></span></span><span><span><span></span>    bootloader_check_wdt_reset();
</span></span><span><span>    <span>// config WDT
</span></span></span><span><span><span></span>    bootloader_config_wdt();
</span></span><span><span>    <span>// enable RNG early entropy source
</span></span></span><span><span><span></span>    bootloader_enable_random();
</span></span><span><span>
</span></span><span><span>    <span>return</span> ret;
</span></span><span><span>}
</span></span></code></pre></div><p>If all initialization is successful (i.e. <code>bootloader_init()</code> returns <code>0</code>), we
jump over the call to <code>bootloader_reset()</code> with <code>beqz</code> and continue to loading
the application.</p>
<div><pre tabindex="0"><code data-lang="fallback"><span><span>403cc71a:	c119                	beqz	a0,403cc720 &lt;call_start_cpu0+0x10&gt;
</span></span><span><span>403cc71c:	55a030ef          	jal	ra,403cfc76 &lt;bootloader_reset&gt;
</span></span><span><span>403cc720:	0a000613          	li	a2,160
</span></span></code></pre></div><p>In addition to the bootloader and application binaries, we also saw that a
<a href="https://docs.espressif.com/projects/esp-idf/en/latest/esp32c3/api-guides/partition-tables.html">partition
table</a>
was constructed and loaded into flash (it was the last item and had size of only
<code>3072</code> bytes). The partition table informs the bootloader where various data is
located in flash. We saw a visual representation of its contents in the
bootloader logs when we reset the CPU.</p>
<div><pre tabindex="0"><code data-lang="fallback"><span><span>I (53) boot: Partition Table:
</span></span><span><span>I (57) boot: ## Label            Usage          Type ST Offset   Length
</span></span><span><span>I (64) boot:  0 nvs              WiFi data        01 02 00009000 00006000
</span></span><span><span>I (71) boot:  1 phy_init         RF data          01 01 0000f000 00001000
</span></span><span><span>I (79) boot:  2 factory          factory app      00 00 00010000 00100000
</span></span><span><span>I (86) boot: End of partition table
</span></span></code></pre></div><p>In this case, we are loading the <code>factory</code> partition, which is where our
application was written to flash (<code>0x00010000</code>). There are a number of steps in
this process, but the sequence maps to the following function calls.</p>
<ol>
<li><a href="https://github.com/espressif/esp-idf/blob/42261df71f12b0b995774d103ce68e40e8fba529/components/bootloader_support/src/bootloader_utility.c#L521"><code>void bootloader_utility_load_boot_image(const bootloader_state_t *bs, int start_index)</code></a>:
determines where the desired image exists and, if it cannot be found, goes
through a series of fallback options.</li>
<li><a href="https://github.com/espressif/esp-idf/blob/42261df71f12b0b995774d103ce68e40e8fba529/components/bootloader_support/src/bootloader_utility.c#L575"><code>static void load_image(const esp_image_metadata_t *image_data)</code></a>:
copies loaded segments to RAM and sets up caches for mapped segments.</li>
<li><a href="https://github.com/espressif/esp-idf/blob/42261df71f12b0b995774d103ce68e40e8fba529/components/bootloader_support/src/bootloader_utility.c#L788"><code>static void unpack_load_app(const esp_image_metadata_t *data)</code></a>:
configures mappings for MMU.</li>
</ol>
<p>The final step is to actually start the application, which is accomplished by
defining an <code>entry</code> symbol at the <code>entry_addr</code>, then calling it.</p>
<p><code>components/bootloader_support/src/bootloader_utility.c</code></p>
<div><pre tabindex="0"><code data-lang="c"><span><span><span>static</span> <span>void</span> set_cache_and_start_app(
</span></span><span><span>    <span>uint32_t</span> drom_addr,
</span></span><span><span>    <span>uint32_t</span> drom_load_addr,
</span></span><span><span>    <span>uint32_t</span> drom_size,
</span></span><span><span>    <span>uint32_t</span> irom_addr,
</span></span><span><span>    <span>uint32_t</span> irom_load_addr,
</span></span><span><span>    <span>uint32_t</span> irom_size,
</span></span><span><span>    <span>uint32_t</span> entry_addr)
</span></span><span><span>{
</span></span><span><span>    ...
</span></span><span><span>    ESP_LOGD(TAG, <span>&#34;start: 0x%08&#34;</span>PRIx32, entry_addr);
</span></span><span><span>    bootloader_atexit();
</span></span><span><span>    <span>typedef</span> <span>void</span> (*<span>entry_t</span>)(<span>void</span>) __attribute__((noreturn));
</span></span><span><span>    <span>entry_t</span> entry = ((<span>entry_t</span>) entry_addr);
</span></span><span><span>
</span></span><span><span>    <span>// TODO: we have used quite a bit of stack at this point.
</span></span></span><span><span><span></span>    <span>// use &#34;movsp&#34; instruction to reset stack back to where ROM stack starts.
</span></span></span><span><span><span></span>    (*entry)();
</span></span><span><span>}
</span></span></code></pre></div><h2 id="concluding-thoughts">
  Concluding Thoughts
  <a href="#concluding-thoughts">
    <i aria-hidden="true" title="Link to heading"></i>
    <span>Link to heading</span>
  </a>
</h2>
<p>Bootloaders are a great place to look when you want to understand how software
and hardware communicate. While you may never need to modify the bootloader
yourself, knowledge of how it works is useful for conceptualizing how changes
made at higher levels utlimately translate to the machine.</p>
<p>As always, these posts are meant to serve as a useful resource for folks who are
interested in learning more about RISC-V and low-level software in general. If I
can do a better job of reaching that goal, or you have any questions or
comments, please feel free to send me a message
<a href="https://twitter.com/hasheddan">@hasheddan</a> on Twitter or
<a href="https://types.pl/web/@hasheddan">@hasheddan@types.pl</a> on Mastodon!</p>

      </div></div>
  </body>
</html>
