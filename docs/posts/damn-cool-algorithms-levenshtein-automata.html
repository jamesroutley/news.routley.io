<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://blog.notdot.net/2010/07/Damn-Cool-Algorithms-Levenshtein-Automata">Original</a>
    <h1>Damn Cool Algorithms: Levenshtein Automata</h1>
    
    <div id="readability-page-1" class="page"><div id="main">
      
  
    <p>
      Posted by Nick Johnson
      
        | Filed under
        
          <a href="http://blog.notdot.net/tag/python">python</a>,
        
          <a href="http://blog.notdot.net/tag/tech">tech</a>,
        
          <a href="http://blog.notdot.net/tag/coding">coding</a>,
        
          <a href="http://blog.notdot.net/tag/damn-cool-algorithms">damn-cool-algorithms</a>
        
      
    </p>
  <p>In a <a href="http://blog.notdot.net/2007/4/Damn-Cool-Algorithms-Part-1-BK-Trees">previous</a> Damn Cool Algorithms post, I talked about BK-trees, a clever indexing structure that makes it possible to search for fuzzy matches on a text string based on <a href="http://en.wikipedia.org/wiki/Levenshtein_distance">Levenshtein distance</a> - or any other metric that obeys the <a href="http://en.wikipedia.org/wiki/Triangle_inequality">triangle inequality</a>. Today, I&#39;m going to describe an alternative approach, which makes it possible to do fuzzy text search in a regular index: <a href="http://en.wikipedia.org/wiki/Levenshtein_automata">Levenshtein automata</a>.</p>

<h3>Introduction</h3>

<p>The basic insight behind Levenshtein automata is that it&#39;s possible to construct a <a href="http://en.wikipedia.org/wiki/Finite_state_machine">Finite state automaton</a> that recognizes exactly the set of strings within a given Levenshtein distance of a target word. We can then feed in any word, and the automaton will accept or reject it based on whether the Levenshtein distance to the target word is at most the distance specified when we constructed the automaton. Further, due to the nature of FSAs, it will do so in O(n) time with the length of the string being tested. Compare this to the standard Dynamic Programming Levenshtein algorithm, which takes O(mn) time, where m and n are the lengths of the two input words! It&#39;s thus immediately apparrent that Levenshtein automaton provide, at a minimum, a faster way for us to check many words against a single target word and maximum distance - not a bad improvement to start with!</p>

<p>Of course, if that were the only benefit of Levenshtein automata, this would be a short article. There&#39;s much more to come, but first let&#39;s see what a Levenshtein automaton looks like, and how we can build one.</p>

<h3>Construction and evaluation</h3>

<p><img src="http://lh4.ggpht.com/_23zDbjk-dKI/TFAMHm_FQUI/AAAAAAAABrI/jpf9QkVoZUk/levenstein-nfa-food.png"/></p><p>The diagram on the right shows the NFA for a Levenshtein automaton for the word &#39;food&#39;, with maximum edit distance 2. As you can see, it&#39;s very regular, and the construction is fairly straightforward. The start state is in the lower left. States are named using a n<sup>e</sup> style notation, where n is the number of characters consumed so far, and e is the number of errors. Horizontal transitions represent unmodified characters, vertical transitions represent insertions, and the two types of diagonal transitions represent substitutions (the ones marked with a *) and deletions, respectively.</p>

<p>Let&#39;s see how we can construct an NFA such as this given an input word and a maximum edit distance. I won&#39;t include the source for the NFA class here, since it&#39;s fairly standard; for gory details, see <a href="http://gist.github.com/491973">the Gist</a>. Here&#39;s the relevant function in Python:</p>

<pre>def levenshtein_automata(term, k):
  nfa = NFA((0, 0))
  for i, c in enumerate(term):
    for e in range(k + 1):
      # Correct character
      nfa.add_transition((i, e), c, (i + 1, e))
      if e &lt; k:
        # Deletion
        nfa.add_transition((i, e), NFA.ANY, (i, e + 1))
        # Insertion
        nfa.add_transition((i, e), NFA.EPSILON, (i + 1, e + 1))
        # Substitution
        nfa.add_transition((i, e), NFA.ANY, (i + 1, e + 1))
  for e in range(k + 1):
    if e &lt; k:
      nfa.add_transition((len(term), e), NFA.ANY, (len(term), e + 1))
    nfa.add_final_state((len(term), e))
  return nfa</pre>

<p>This should be easy to follow; we&#39;re basically constructing the transitions you see in the diagram in the most straightforward manner possible, as well as denoting the correct set of final states. State labels are tuples, rather than strings, with the tuples using the same notation we described above.</p>

<p>Because this is an NFA, there can be multiple active states. Between them, these represent the possible interpretations of the string processed so far. For example, consider the active states after consuming the characters &#39;f&#39; and &#39;x&#39;:</p>

<p><img src="http://lh4.ggpht.com/_23zDbjk-dKI/TFAPqKljIYI/AAAAAAAABrc/93sblJ_ZVyQ/levenstein-nfa-food-fx.png"/></p><p>This indicates there are several possible variations that are consistent with the first two characters &#39;f&#39; and &#39;x&#39;: A single substitution, as in &#39;fxod&#39;, a single insertion, as in &#39;fxood&#39;, two insertions, as in &#39;fxfood&#39;, or a substitution and a deletion, as in &#39;fxd&#39;. Also included are several redundant hypotheses, such as a deletion and an insertion, also resulting in &#39;fxod&#39;. As more characters are processed, some of these possibilities will be eliminated, while other new ones will be introduced. If, after consuming all the characters in the word, an accepting (bolded) state is in the set of current states, there&#39;s a way to convert the input word into the target word with two or fewer changes, and we know we can accept the word as valid.</p>

<p>Actually evaluating an NFA directly tends to be fairly computationally expensive, due to the presence of multiple active states, and epsilon transitions (that is, transitions that require no input symbol), so the standard practice is to first convert the NFA to a DFA using <a href="http://en.wikipedia.org/wiki/Powerset_construction">powerset construction</a>. Using this algorithm, a DFA is constructed in which each state corresponds to a set of active states in the original NFA. We won&#39;t go into detail about powerset construction here, since it&#39;s tangential to the main topic. Here&#39;s an example of a DFA corresponding to the NFA for the input word &#39;food&#39; with one allowable error:</p>

<p><img src="http://lh6.ggpht.com/_23zDbjk-dKI/TFAMHtbPPAI/AAAAAAAABrE/cF_WDpCVCCg/levenstein-dfa-food.png"/></p><p>Note that we depicted a DFA for one error, as the DFA corresponding to our NFA above is a bit too complex to fit comfortably in a blog post! The DFA above will accept exactly the words that have an edit distance to the word &#39;food&#39; of 1 or less. Try it out: pick any word, and trace its path through the DFA. If you end up in a bolded state, the word is valid.</p>

<p>I won&#39;t include the source for powerset construction here; it&#39;s also <a href="http://gist.github.com/491973">in the gist</a> for those who care.</p>

<p>Briefly returning to the issue of runtime efficiency, you may be wondering how efficient Levenshtein DFA construction is. We can construct the NFA in O(kn) time, where k is the edit distance and n is the length of the target word. Conversion to a DFA has a worst case of O(2<sup>n</sup>) time - which leads to a pretty extreme worst-case of O(2<sup>kn</sup>) runtime! Not all is doom and gloom, though, for two reasons: First of all, Levenshtein automata won&#39;t come anywhere near the 2<sup>n</sup> worst-case for DFA construction<sup><a href="#footnote1">*</a></sup>. Second, some very clever computer scientists have come up with algorithms to construct the DFA directly in O(n) time, [<a href="#schulz2002fast">SCHULZ2002FAST</a>] and even a method to skip the DFA construction entirely and use a table-based evaluation method!</p>

<h3>Indexing</h3>

<p>Now that we&#39;ve established that it&#39;s possible to construct Levenshtein automata, and demonstrated how they work, let&#39;s take a look at how we can use them to search an index for fuzzy matches efficiently. The first insight, and the approach many papers [<a href="#schulz2002fast">SCHULZ2002FAST</a>] [<a href="#mihov2004fast">MIHOV2004FAST</a>] take is to observe that a dictionary - that is, the set of records you want to search - can itself be represented as a DFA. In fact, they&#39;re frequently stored as a <a href="http://en.wikipedia.org/wiki/Trie">Trie</a> or a <a href="http://en.wikipedia.org/wiki/Directed_acyclic_word_graph">DAWG</a>, both of which can be viewed as special cases of DFAs. Given that both the dictionary and the criteria (the Levenshtein automata) are represented as DFAs, it&#39;s then possible to efficiently intersect the two DFAs to find exactly the words in the dictionary that match our criteria, using a very simple procedure that looks something like this:</p>

<pre>def intersect(dfa1, dfa2):
  stack = [(&#34;&#34;, dfa1.start_state, dfa2.start_state)]
  while stack:
    s, state1, state2 = stack.pop()
    for edge in set(dfa1.edges(state1)).intersect(dfa2.edges(state2)):
      state1 = dfa1.next(state1, edge)
      state2 = dfa2.next(state2, edge)
      if state1 and state2:
        s = s + edge
        stack.append((s, state1, state2))
        if dfa1.is_final(state1) and dfa2.is_final(state2):
          yield s</pre>

<p>That is, we traverse both DFAs in lockstep, only following edges that both DFAs have in common, and keeping track of the path we&#39;ve followed so far. Any time both DFAs are in a final state, that word is in the output set, so we output it.</p>

<p>This is all very well if your index is stored as a DFA (or a trie or DAWG), but many indexes aren&#39;t: if they&#39;re in-memory, they&#39;re probably in a sorted list, and if they&#39;re on disk, they&#39;re probably in a <a href="http://en.wikipedia.org/wiki/Btree">BTree</a> or similar structure. Is there a way we can modify this scheme to work with these sort of indexes, and still provide a speedup on brute-force approaches? It turns out that there is.</p>

<p>The critical insight here is that with our criteria expressed as a DFA, we can, given an input string that <b>doesn&#39;t</b> match, find the next string (lexicographically speaking) that <b>does</b>. Intuitively, this is fairly easy to do: we evaluate the input string against the DFA until we cannot proceed further - for example, because there&#39;s no valid transition for the next character. Then, we repeatedly follow the edge that has the lexicographically smallest label until we reach a final state. Two special cases apply here: First, on the first transition, we need to follow the lexicographically smallest label greater than character that had no valid transition in the preliminary step. Second, if we reach a state with no valid outwards edge, we should backtrack to the previous state, and try again. This is pretty much the &#39;wall following&#39; maze solving algorithm, as applied to a DFA.</p>

<p>For an example of this, take a look at the DFA for food(1), above, and consider the input word &#39;foogle&#39;. We consume the first four characters fine, leaving us in state 3<sup>1</sup>4<sup>1</sup>. The only out edge from here is &#39;d&#39;, while the next character is &#39;l&#39;, so we backtrack one step to the previous state, 2<sup>1</sup>3<sup>0</sup>3<sup>1</sup>4<sup>1</sup>. From here, our next character is &#39;g&#39;, and there&#39;s an out-edge for &#39;f&#39;, so we take that edge, leaving us in an accepting state (the same state as previously, in fact, but with a different path to it) with the output string &#39;fooh&#39; - the lexicographically next string in the DFA after &#39;foogle&#39;.</p>

<p>Here&#39;s the Python code for it, as a method on the DFA class. As previously, I haven&#39;t included boilerplate for the DFA, which is all <a href="">here</a>.</p>

<pre>  def next_valid_string(self, input):
    state = self.start_state
    stack = []
    
    # Evaluate the DFA as far as possible
    for i, x in enumerate(input):
      stack.append((input[:i], state, x))
      state = self.next_state(state, x)
      if not state: break
    else:
      stack.append((input[:i+1], state, None))

    if self.is_final(state):
      # Input word is already valid
      return input
    
    # Perform a &#39;wall following&#39; search for the lexicographically smallest
    # accepting state.
    while stack:
      path, state, x = stack.pop()
      x = self.find_next_edge(state, x)
      if x:
        path += x
        state = self.next_state(state, x)
        if self.is_final(state):
          return path
        stack.append((path, state, None))
    return None</pre>

<p>In the first part of the function, we evaluate the DFA in the normal fashion, keeping a stack of visited states, along with the path so far and the edge we intend to attempt to follow out of them. Then, assuming we didn&#39;t find an exact match, we perform the backtracking search we described above, attempting to find the smallest set of transitions we can follow to come to an accepting state. For some caveats about the generality of this function, read on...</p>

<p>Also needed is the utility function find_next_edge, which finds the lexicographically smallest outwards edge from a state that&#39;s greater than some given input:</p>

<pre>  def find_next_edge(self, s, x):
    if x is None:
      x = u&#39;\0&#39;
    else:
      x = unichr(ord(x) + 1)
    state_transitions = self.transitions.get(s, {})
    if x in state_transitions or s in self.defaults:
      return x
    labels = sorted(state_transitions.keys())
    pos = bisect.bisect_left(labels, x)
    if pos &lt; len(labels):
      return labels[pos]
    return None</pre>

<p>With some preprocessing, this could be made substantially more efficient - for example, by pregenerating a mapping from each character to the first outgoing edge greater than it, rather than using binary search to find it in many cases. I once again leave such optimizations as an exercise for the reader.</p>

<p>Now that we have this procedure, we can finally describe how to search the index with it. The algorithm is surprisingly simple:</p>

<ol>
  <li>Obtain the first element from your index - or alternately, a string you know to be less than any valid string in your index - and call it the &#39;current&#39; string.</li>
  <li>Feed the current string into the &#39;DFA successor&#39; algorithm we outlined above, obtaining the &#39;next&#39; string.</li>
  <li>If the next string is equal to the current string, you have found a match - output it, fetch the next element from the index as the current string, and repeat from step 2.</li>
  <li>If the next string is not equal to the current string, search your index for the first string greater than or equal to the next string. Make this the new current string, and repeat from step 2.</li>
</ol>

<p>And once again, here&#39;s the implementation of this procedure in Python:</p>

<pre>def find_all_matches(word, k, lookup_func):
  &#34;&#34;&#34;Uses lookup_func to find all words within levenshtein distance k of word.
  
  Args:
    word: The word to look up
    k: Maximum edit distance
    lookup_func: A single argument function that returns the first word in the
      database that is greater than or equal to the input argument.
  Yields:
    Every matching word within levenshtein distance k from the database.
  &#34;&#34;&#34;
  lev = levenshtein_automata(word, k).to_dfa()
  match = lev.next_valid_string(u&#39;\0&#39;)
  while match:
    next = lookup_func(match)
    if not next:
      return
    if match == next:
      yield match
      next = next + u&#39;\0&#39;
    match = lev.next_valid_string(next)</pre>

<p>One way of looking at this algorithm is to think of both the Levenshtein DFA and the index as sorted lists, and the procedure above to be similar to App Engine&#39;s &#34;zigzag merge join&#34; strategy. We repeatedly look up a string on one side, and use that to jump to the appropriate place on the other side. If there&#39;s no matching entry, we use the result of the lookup to jump ahead on the first side, and so forth. The result is that we skip over large numbers of non-matching index entries, as well as large numbers of non-matching Levenshtein strings, saving us the effort of exhaustively enumerating either of them. Hopefully it&#39;s apparrent from the description that this procedure has the potential to avoid the need to evaluate either all of the index entries, or all of the candidate Levenshtein strings.</p>

<p>As a side note, it&#39;s not true that for all DFAs it&#39;s possible to find a lexicographically minimal successor to any string. For example, consider the successor to the string &#39;a&#39; in the DFA that recognizes the pattern &#39;a+b&#39;. The answer is that there isn&#39;t one: it would have to consist of an infinite number of &#39;a&#39; characters followed by a single &#39;b&#39; character! It&#39;s possible to make a fairly simple modification to the procedure outlined above such that it returns a string that&#39;s guaranteed to be a <b>prefix</b> of the next string recognized by the DFA, which is sufficient for our purposes. Since Levenshtein DFAs are always finite, though, and thus always have a finite length successor (except for the last string, naturally), we leave such an extension as an exercise for the reader. There are potentially interesting applications one could put this approach to, such as indexed regular expression search, which would require this modification.</p>

<h3>Testing</h3>

<p>First, let&#39;s see this in action. We&#39;ll define a simple Matcher class, which provides an implementation of the lookup_func required by our find_all_matches function:</p>

<pre>class Matcher(object):
  def __init__(self, l):
    self.l = l
    self.probes = 0

  def __call__(self, w):
    self.probes += 1
    pos = bisect.bisect_left(self.l, w)
    if pos &lt; len(self.l):
      return self.l[pos]
    else:
      return None</pre>

<p>Note that the only reason we implemented a callable class here is because we want to extract some metrics - specifically, the number of probes made - from the procedure; normally a regular or nested function would be perfectly sufficient. Now, we need a sample dataset. Let&#39;s load the web2 dictionary for that:</p>

<pre>&gt;&gt;&gt; words = [x.strip().lower().decode(&#39;utf-8&#39;) for x in open(&#39;/usr/share/dict/web2&#39;)]
&gt;&gt;&gt; words.sort()
&gt;&gt;&gt; len(words)
234936</pre>

<p>We could also use a couple of subsets for testing how things change with scale:</p>

<pre>&gt;&gt;&gt; words10 = [x for x in words if random.random() &lt;= 0.1]
&gt;&gt;&gt; words100 = [x for x in words if random.random() &lt;= 0.01]</pre>

<p>And here it is in action:</p>

<pre>&gt;&gt;&gt; m = Matcher(words)
&gt;&gt;&gt; list(automata.find_all_matches(&#39;nice&#39;, 1, m))
[u&#39;anice&#39;, u&#39;bice&#39;, u&#39;dice&#39;, u&#39;fice&#39;, u&#39;ice&#39;, u&#39;mice&#39;, u&#39;nace&#39;, u&#39;nice&#39;, u&#39;niche&#39;, u&#39;nick&#39;, u&#39;nide&#39;, u&#39;niece&#39;, u&#39;nife&#39;, u&#39;nile&#39;, u&#39;nine&#39;, u&#39;niue&#39;, u&#39;pice&#39;, u&#39;rice&#39;, u&#39;sice&#39;, u&#39;tice&#39;, u&#39;unice&#39;, u&#39;vice&#39;, u&#39;wice&#39;]
&gt;&gt;&gt; len(_)
23
&gt;&gt;&gt; m.probes
142
</pre>

<p>Working perfectly! Finding the 23 fuzzy matches for &#39;nice&#39; in the dictionary of nearly 235,000 words required 142 probes. Note that if we assume an alphabet of 26 characters, there are 4+26*4+26*5=238 strings within levenshtein distance 1 of &#39;nice&#39;, so we&#39;ve made a reasonable saving over exhaustively testing all of them. With larger alphabets, longer strings, or larger edit distances, this saving should be more pronounced. It may be instructive to see how the number of probes varies as a function of word length and dictionary size, by testing it with a variety of inputs:</p>

<table>
  <thead>
    <tr><th>String length</th><th>Max strings</th><th>Small dict</th><th>Med dict</th><th>Full dict</th></tr>
  </thead>
  <tbody><tr><th>1</th><td>79</td><td>47 (59%)</td><td>54 (68%)</td><td>81 (100%)</td></tr>
  <tr><th>2</th><td>132</td><td>81 (61%)</td><td>103 (78%)</td><td>129 (97%)</td></tr>
  <tr><th>3</th><td>185</td><td>94 (50%)</td><td>120 (64%)</td><td>147 (79%)</td></tr>
  <tr><th>4</th><td>238</td><td>94 (39%)</td><td>123 (51%)</td><td>155 (65%)</td></tr>
  <tr><th>5</th><td>291</td><td>94 (32%)</td><td>124 (43%)</td><td>161 (55%)</td></tr>
</tbody></table>

<p>In this table, &#39;max strings&#39; is the total number of strings within edit distance one of the input string, and the values for small, med, and full dict represent the number of probes required to search the three dictionaries (consisting of 1%, 10% and 100% of the web2 dictionary). All the following rows, at least until 10 characters, required a similar number of probes as row 5. The sample input string used consisted of prefixes of the word &#39;abracadabra&#39;.</p>

<p>Several observations are immediately apparrent:</p>

<ol>
  <li>For very short strings and large dictionaries, the number of probes is not much lower - if at all - than the maximum number of valid strings, so there&#39;s little saving.</li>
  <li>As the string gets longer, the number of probes required increases significantly slower than the number of potential results, so that at 10 characters, we need only probe 161 of 821 (about 20%) possible results. At commonly encountered word lengths (97% of words in the web2 dictionary are at least 5 characters long), the savings over naively checking every string variation are already significant.</li>
  <li>Although the size of the sample dictionaries differs by an order of magnitude, the number of probes required increases only a little each time. This provides encouraging evidence that this will scale well for very large indexes.</li>
</ol>

<p>It&#39;s also instructive to see how this varies for different edit distance thresholds. Here&#39;s the same table, for a max edit distance of 2:</p>

<table>
  <thead>
    <tr><th>String length</th><th>Max strings</th><th>Small dict</th><th>Med dict</th><th>Full dict</th></tr>
  </thead>
  <tbody><tr><th>1</th><td>2054</td><td>413 (20%)</td><td>843 (41%)</td><td>1531 (75%)</td></tr>
  <tr><th>2</th><td>10428</td><td>486 (5%)</td><td>1226 (12%)</td><td>2600 (25%)</td></tr>
  <tr><th>3</th><td>24420</td><td>644 (3%)</td><td>1643 (7%)</td><td>3229 (13%)</td></tr>
  <tr><th>4</th><td>44030</td><td>646 (1.5%)</td><td>1676 (4%)</td><td>3366 (8%)</td></tr>
  <tr><th>5</th><td>69258</td><td>648 (0.9%)</td><td>1676 (2%)</td><td>3377 (5%)</td></tr>
</tbody></table>

<p>This is also promising: with an edit distance of 2, although we&#39;re having to do a lot more probes, it&#39;s a much smaller percentage of the number of candidate strings. With a word length of 5 and an edit distance of 2, having to do 3377 probes is definitely far preferable to doing 69,258 (one for every matching string) or 234,936 (one for every word in the dictionary)!</p>

<p>As a quick comparison, a straightforward BK-tree implementation with the same dictionary requires examining 5858 nodes for a string length of 5 and an edit distance of 1 (with the same sample string used above), while the same query with an edit distance of 2 required 58,928 nodes to be examined! Admittedly, many of these nodes are likely to be on the same disk page, if structured properly, but there&#39;s still a startling difference in the number of lookups.</p>

<p>One final note: The second paper we referenced in this article, [<a href="#mihov2004fast">MIHOV2004FAST</a>] describes a very nifty construction: a universal Levenshtein automata. This is a DFA that determines, in linear time, if any pair of words are within a given fixed Levenshtein distance of each other. Adapting the above scheme to this system is, also, left as an exercise for the reader.</p>

<p>The complete source code for this article can be found <a href="http://gist.github.com/491973">here</a>.</p>

<p><a name="footnote1">*</a> Robust proofs of this hypothesis are welcome.</p>

<p>[<a name="schulz2002fast">SCHULZ2002FAST</a>] <a href="http://scholar.google.com/scholar?cluster=14641878050783977181&amp;hl=en&amp;as_sdt=2000">Fast string correction with Levenshtein automata</a></p>

<p>[<a name="mihov2004fast">MIHOV2004FAST</a>] <a href="http://scholar.google.com/scholar?cluster=11598378791316911178&amp;hl=en&amp;as_sdt=2005&amp;sciodt=2000">Fast approximate search in large dictionaries</a></p>


  <p>
    <span>28 July, 2010</span>
  </p>
  
    <p><a id="prev" href="http://blog.notdot.net/2010/07/Getting-unicode-right-in-Python">Previous Post</a>
  
  
    <a id="next" href="http://blog.notdot.net/2010/08/Using-BlobReader-wildcard-subdomains-and-webapp2">Next Post</a></p>
    
    
    
    
    <p><a href="http://disqus.com">blog comments powered by </a>
  

  



		</p></div></div>
  </body>
</html>
