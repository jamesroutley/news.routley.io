<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.saaspegasus.com/about/how-pegasus-works/">Original</a>
    <h1>A Codebase That Makes Codebases</h1>
    
    <div id="readability-page-1" class="page"><div id="content-body">
            
  <section>
    
    <p>
      A Codebase That Makes Codebases
    </p>
    
      <p>
        How SaaS Pegasus—a codebase creator for Django projects—works under the hood.
      </p>
    
    <div id="main-content">
      <p><img alt="Drawing Hands" src="https://www.saaspegasus.com/static/images/web/how-pegasus-is-made/drawing-hands.ac987fed5ad7.webp"/></p>
<figcaption><a href="https://en.wikipedia.org/wiki/Drawing_Hands">Drawing Hands</a> by M. C. Escher.</figcaption>

<p><small><em>May 10, 2023</em></small></p>
<p>I&#39;ve spent the last four years building and maintaining a project called <a href="https://www.saaspegasus.com/">SaaS Pegasus</a>.
Pegasus is a <a href="https://www.saaspegasus.com/guides/saas-boilerplates-and-starter-kits/"><em>SaaS boilerplate</em> or <em>SaaS starter kit</em></a>.
It provides a starting codebase for new SaaS projects with a bunch of features like user accounts,
teams, and billing already included.</p>
<p>Most boilerplates are regular codebases.
You clone a repository from Github, follow the getting started instructions, and you&#39;re up and running.
What makes Pegasus different is that every project&#39;s codebase is unique.
You enter information about your project and the tech stack you want to use, and Pegasus makes a codebase just for you.
In other words, Pegasus is <em>a codebase that makes other codebases</em>.</p>
<p>Making—and more importantly, maintaining—a codebase-making codebase has posed some unique challenges,
and I&#39;ve had to get pretty creative to solve them.
In this post I&#39;ll outline how Pegasus is built, the problems I&#39;ve run into, and the tooling that holds it all together.</p>
<p>But first, I need to address the obvious question.</p>
<h2 id="why-generate-codebases-at-all">Why generate codebases at all?</h2>
<p>I mentioned that most boilerplates just provide starting code and don&#39;t bother with any code-generation business.
You may be thinking...wouldn&#39;t that be <em>much</em> easier? Why take on all this extra complexity?</p>
<p>The problem is my inner perfectionist.</p>
<p>When I started working on Pegasus, I had two important design goals:</p>
<p><strong>The first was that it should be flexible</strong>.
I knew every project would be different and wanted to make Pegasus flexible enough to handle a lot of different use cases.</p>
<p><strong>The second was that I wanted developers to love it</strong>.
Pegasus is a product geared towards developers—notoriously an opinionated and finicky bunch of people.
For Pegasus to be successful, I needed it to create codebases that developers would be happy to use.
For this constraint, I used myself as a litmus test.
Anything that I personally wouldn&#39;t use was an instant no-go.</p>
<p>Anyway—let&#39;s first focus on flexibility.
In order for a boilerplate to be flexible it has to be <em>configurable</em>.</p>
<p>As an example, many SaaS projects want to collect monthly payments from their users.
But many others—internal tools or hobby projects—won&#39;t.
To facilitate both of these use cases you need to have some piece of configuration that tells the app
whether billing is enabled or not, and then have everything behave accordingly.</p>
<p>If the boilerplate is &#34;just a codebase&#34;, this configuration has to be a <em>runtime</em> setting.
You&#39;d set <code>USE_BILLING = True</code> in your settings file, and that would dynamically enable the billing module, UI, and so on.
This is typically how configurable open-source libraries work, and it works reasonably well.</p>
<pre><code>if settings.USE_BILLING:
    show_billing_module()
</code></pre>
<figcaption>Example code that enables a billing module based on a runtime setting.</figcaption>

<p>Unfortunately, from a developer experience perspective—<em>this sucks</em>.</p>
<p>In this world, all generated codebases include the billing code (and all its dependencies)—<em>even the codebases that never use it</em>.
It also means lots of &#34;<code>if USE_BILLING</code>&#34; statements sprinkled throughout the codebase that—for
any individual project—only add unnecessary complexity.
It would be hard for developers working on the code to know what could safely be deleted, what libraries were never used, and so on.
This might be acceptable for libraries—since they are largely treated as a black boxes—but
for the starting code for a new app it felt...<em>sloppy</em>.</p>
<p>So I decided runtime configuration was out. The purist in me wouldn&#39;t allow it.</p>
<p>What quickly became clear was that if Pegasus was going to generate code that satisfied developers like me,
the generated codebase <em>itself</em> needed to be configurable.
Then, by the time a developer got their hands on the code, all the extra cruft and branching logic would be gone
and they could start with exactly what they needed.</p>
<p>So that&#39;s what I did.</p>
<p>Here&#39;s a little snippet from the <a href="https://www.saaspegasus.com/projects/">Pegasus codebase creator</a>:</p>
<p><img alt="Project Editor" src="https://www.saaspegasus.com/static/images/web/how-pegasus-is-made/project-editor.39fc2c60851c.png"/></p>
<figcaption>A snippet from Pegasus&#39;s codebase creator. Yes, the UI isn&#39;t that great—not the point!</figcaption>

<p>I know it looks simple, but each of these checkboxes controls a huge amount of logic—from
the UI that is created all the way down to the data models and required packages.
Some of these even have interdependencies.<sup id="fnref:1"><a href="#fn:1">1</a></sup>
And Pegasus—the codebase creator—takes on all this complexity so that the developers using Pegasus are shielded from it.</p>
<p>Maintenance of this project has been… <em>interesting</em>. But over time I&#39;ve managed to come up with solutions for most of the big problems I&#39;ve run into.</p>
<p>With that out of the way, let&#39;s peek under the hood.</p>
<h2 id="the-secret-to-dynamic-code-generation-cookiecutter">The secret to dynamic code generation: cookiecutter</h2>
<p>At its core, SaaS Pegasus is a cookiecutter project.
<a href="https://github.com/cookiecutter/cookiecutter">Cookiecutter</a> is an awesome little utility that lets you create projects from templates.
In my case, Pegasus is the template, and the codebases it produces are the projects.</p>
<p>Cookiecutter has two main components: </p>
<ol>
<li>A set of configuration variables. These are the equivalent of <code>USE_BILLING = True</code> in the example above.</li>
<li>A logic/templating engine that sits on top of those variables (written in <a href="https://palletsprojects.com/p/jinja/">Jinja2</a>).
   This is the equivalent of all the <code>if USE_BILLING</code> logic, above.</li>
</ol>
<p>The examples from the project editing UI above produce a cookiecutter configuration dictionary that looks like this:</p>
<pre><code>cookiecutter = {
    &#34;use_teams&#34;: &#34;y&#34;,
    &#34;use_teams_example&#34;: &#34;n&#34;,
    &#34;use_translations&#34;: &#34;y&#34;,
    &#34;use_wagtail&#34;: &#34;n&#34;,
    &#34;use_openai&#34;: &#34;y&#34;,
}
</code></pre>
<p>Then, you can add Jinja2 markup to any file in your project to write logic that depends on these variables.</p>
<p>For example, in Pegasus, I want to include or exclude certain URL paths depending on whether a feature is turned on:</p>
<pre><code>urlpatterns = [
    # some urls are always included
    path(&#39;admin/&#39;, admin.site.urls),
    # but many are turned on/off depending on your configuration
{% if cookiecutter.use_translations == &#39;y&#39; %}
    path(&#39;i18n/&#39;, include(&#39;django.conf.urls.i18n&#39;)),
{% endif %}
{% if cookiecutter.use_teams == &#39;y&#39; %}
    path(&#39;teams/&#39;, include(&#39;apps.teams.urls&#39;)),
{% endif %}
{% if cookiecutter.use_openai == &#39;y&#39; %}
    path(&#39;openai/&#39;, include(&#39;apps.openai_example.urls&#39;)),
{% endif %}
    # and so on...
]
</code></pre>
<figcaption>Including or excluding certain URLs based on user&#39;s project configuration.</figcaption>

<p>Each of these <code>{% if cookiecutter.use_thing == &#39;y&#39; %}</code> statements runs against the generated cookiecutter dictionary
and either keeps or leaves out that content from the project.</p>
<p>Now, each generated project will have the right set of URLs based on the chosen configuration.
The same trick can be applied to data models, business logic, the UI, dependencies, and so on—and
no extra logic or code will be included in the final output!</p>
<h3 id="handling-larger-changes-with-cookiecutter-hooks">Handling larger changes with cookiecutter hooks</h3>
<p>The syntax above works great for changes <em>within</em> a file, but sometimes you need to do larger operations,
e.g. include or exclude entire files or directories.
For these bigger pieces, cookiecutter provides hooks that run before/after project creation.
<a href="https://cookiecutter.readthedocs.io/en/1.7.2/advanced/hooks.html">Cookiecutter&#39;s hooks</a> are Python scripts that have access to the generated project directory.
So, for example, if you want to delete entire files or directories based on a variable you can do that like this:</p>
<pre><code>using_translations = &#39;{{ cookiecutter.use_translations }}&#39; == &#39;y&#39;
if not using_translations:
    # remove locale files and middleware if we aren&#39;t using translations
    remove(os.path.join(project_dir, &#39;locale&#39;))
    remove(os.path.join(&#39;apps&#39;, &#39;web&#39;, &#39;locale_middleware.py&#39;))
</code></pre>
<figcaption>Using a cookiecutter hook to remove entire files/directories from a project. <a href="https://github.com/cookiecutter/cookiecutter/issues/723" target="_blank">More info here</a>.</figcaption>

<p>Jinja templating and hooks can get you quite far—almost everything I&#39;ve had to configure in Pegasus can be done with one of these two patterns.</p>
<h3 id="how-do-you-template-a-template">How do you template a template?</h3>
<p>SaaS Pegasus generates Django projects—which include HTML templates with their own template language that looks very similar to Jinja2:</p>
<pre><code>&lt;nav&gt;
{% if user.is_authenticated %}
  &lt;a class=&#34;navbar-item&#34; href=&#34;{% url &#39;pegasus_examples:examples_home&#39; %}&#34;&gt;
    Examples Gallery
  &lt;/a&gt;
{% endif %}
&lt;/nav&gt;
</code></pre>
<figcaption>An example snippet using the Django template language, which is very similar to cookiecutter&#39;s Jinja2.</figcaption>

<p>This template snippet adds a navigation link to the example gallery only if the user is authenticated.
But what if we need to layer on some cookiecutter logic?
What if we only want to include this code in the template if the project was built with examples enabled?</p>
<p>A first attempt might look something like this:</p>
<pre><code>&lt;nav&gt;
{% if cookiecutter.use_examples == &#39;y&#39; %} &lt;!-- cookiecutter check --&gt;
{% if user.is_authenticated %}            &lt;!-- Django template check --&gt;
  &lt;a class=&#34;navbar-item&#34; href=&#34;{% url &#39;pegasus_examples:examples_home&#39; %}&#34;&gt;
    Examples Gallery
  &lt;/a&gt;
{% endif %}                               &lt;!-- end Django template check --&gt;
{% endif %}                               &lt;!-- end cookiecutter check --&gt;
&lt;/nav&gt;
</code></pre>
<p>But there&#39;s a problem.
When cookiecutter is building this project, Jinja2 can&#39;t tell the difference between the cookiecutter
options (<code>{% if cookiecutter.use_examples == &#39;y&#39; %}</code>) and the Django ones (<code>{% if user.is_authenticated %}</code>).
It tries to evaluate the whole file, but chokes as soon as it runs into something it doesn&#39;t understand
(in this case, the reference to <code>user.is_authenticated</code>).</p>
<p>In order to make it work we have to tell cookiecutter&#39;s Jinja syntax to ignore the similar-looking Django template syntax.
We can do this with the <a href="https://jinja.palletsprojects.com/en/3.0.x/templates/#escaping">{% raw %} tag</a>—which stops evaluation on everything inside it.
Here&#39;s the updated example:</p>
<pre><code>&lt;nav&gt;
{% if cookiecutter.use_examples == &#39;y&#39; %} &lt;!-- cookiecutter check --&gt;
{% raw %}                                 &lt;!-- pause cookiecutter parsing --&gt;
{% if user.is_authenticated %}            &lt;!-- Django template check --&gt;
  &lt;a class=&#34;navbar-item&#34; href=&#34;{% url &#39;pegasus_examples:examples_home&#39; %}&#34;&gt;
    Examples Gallery
  &lt;/a&gt;
{% endif %}                               &lt;!-- end Django template check --&gt;
{% endraw %}                              &lt;!-- unpause cookiecutter parsing --&gt;
{% endif %}                               &lt;!-- end cookiecutter check --&gt;
</code></pre>
<p>Now cookiecutter will ignore the troublesome <code>{% if user.is_authenticated %}</code> statement, and everything works correctly.</p>
<p>These templates can get quite unwieldy when there&#39;s a lot of intermingled cookiecutter and Django template logic!
For kicks, try to make sense of the example below, taken straight from Pegasus&#39;s source code.</p>
<pre><code>&lt;body{% endraw %}{% if use_multiple %}{% raw %}{% if pg_is_material_bootstrap %} class=&#34;g-sidenav-show  bg-gray-200&#34;{% endif %}{% endraw %}{% endif %}{% if use_material %} class=&#34;g-sidenav-show  bg-gray-200&#34;{% endif %}{% if using_htmx %}{% raw %} hx-headers=&#39;{&#34;X-CSRFToken&#34;: &#34;{{ csrf_token }}&#34;}&#39;{% endraw %}{% endif %}{% raw %}&gt;
</code></pre>
<figcaption>The opening &lt;body&gt; tag declaration in Pegasus&#39;s base template.</figcaption>
<p>It ain&#39;t pretty but it works...</p>
<h2 id="testing-code-that-makes-code">Testing code that makes code</h2>
<p>Testing a cookiecutter project presents its own challenges. The first one being, simply: <em>how do you test it?</em></p>
<p>Importantly, <em>cookiecutter projects themselves are not valid code</em>. Remember our <code>urls.py</code> file?</p>
<pre><code>urlpatterns = [
    # some urls are always included
    path(&#39;admin/&#39;, admin.site.urls),
    # but many are turned on/off depending on your configuration
{% if cookiecutter.use_translations == &#39;y&#39; %}
    path(&#39;i18n/&#39;, include(&#39;django.conf.urls.i18n&#39;)),
{% endif %}
    # and so on...
]
</code></pre>
<p>This file will crash a Python interpreter the moment a <code>{% %}</code> tag is reached.
Yes, once you <em>run</em> cookiecutter you should (hopefully!) get valid code, but the cookiecutter project—Pegasus itself—is incomprehensible nonsense.</p>
<p>So I can&#39;t run a test suite on the project itself.
Instead I have to run the test suite on a <em>generated project</em>.
And tests become a two-stage test process:</p>
<ol>
<li>Generate a project codebase from the Pegasus template.</li>
<li>Run the tests on the generated project.</li>
</ol>
<p>This is straightforward enough to script, but raises a new question: <em>What project(s) should be tested?</em></p>
<h3 id="attempting-to-get-decent-test-coverage">Attempting to get decent test coverage</h3>
<p>There are currently 25 configurable variables you can use in Pegasus.
This means there are about 2<sup>25</sup>—or ~33 million—different ways to configure a Pegasus project. That&#39;s a lot of combinations!<sup id="fnref:2"><a href="#fn:2">2</a></sup></p>
<p><img alt="Branching Tree" src="https://www.saaspegasus.com/static/images/web/how-pegasus-is-made/branching-tree.f2f24c97913e.jpeg"/></p>
<figcaption>Each dot on the end of this tree represents a different Pegasus config I need to test. Image by Midjourney.</figcaption>

<p>Most of the bug reports I get for Pegasus inevitably end up being tied to some unique combination of variables—e.g.
&#34;building without teams or subscriptions, but with API keys enabled causes profile picture uploads to fail&#34;.
It&#39;s a lot to manage.</p>
<p>In the early days, I&#39;d fix the bug, then add an item to my release checklist to make sure this particular combination
of variables still worked the next time around.
The release checklist started getting quite long!</p>
<p>Eventually, as the number of options (and users) grew, so did the number of combinations I had to test.
And soon I found myself spending entire days just banging on different combinations of variables looking for bugs.
I needed something more sustainable.</p>
<p>Enter: <em>automation</em>. With the help of a friend, I turned to <a href="https://github.com/features/actions">Github Actions</a>,
and we managed to set up a series of jobs that:</p>
<ol>
<li>Generate a list of configurations to test.</li>
<li>Generate new projects based on each configuration.</li>
<li>Install and run the test suite (and anything else) on each generated project.</li>
</ol>
<p>Now every change to Pegasus gets run through ~25 hand-picked build configurations, each of which ensures that a particular combination
of features still works properly.</p>
<p><img alt="Pegasus Github Actions" src="https://www.saaspegasus.com/static/images/web/how-pegasus-is-made/pegasus-github-actions.b5d6f04ce62a.png"/></p>
<figcaption>A glorious, green Pegasus build. On the left you can see all the different combinations that have been tested.</figcaption>

<p>And now whenever I find a new bug involving a particular combination of flags—I add a line to the config file to test that particular combination,
and I can rest assured it won&#39;t happen again!</p>
<p>Under the hood this works via <a href="https://docs.github.com/en/actions/using-jobs/using-a-matrix-for-your-jobs">Github&#39;s matrix support</a>.
The first job of the workflow creates the matrix of configurations as a JSON output, and the next job uses it to setup the project and run CI on each one.<sup id="fnref:3"><a href="#fn:3">3</a></sup></p>
<p>Testing coverage problem (mostly) solved!</p>
<h2 id="automating-away-complexity-with-post-processing">Automating away complexity with post-processing</h2>
<p>So that&#39;s the underlying code and testing infrastructure. But, there are still things that are hard to do in cookiecutter.</p>
<p>Code formatting, for one, is a nightmare.
All the cookiecutter Jinja syntax makes it very difficult to control whitespace in the generated output.</p>
<p>Also compiled files are a mess.
If a cookiecutter variable impacts JavaScript code, managing how that ends up in a compiled JavaScript bundle is impossible to do by hand.
Similarly, managing a compiled <code>requirements.txt</code> file based off a cookiecuttered 
<a href="https://github.com/jazzband/pip-tools#requirements-from-requirementsin"><code>requirements.in</code> file</a> is a huge hassle.</p>
<p><img alt="Requirements" src="https://www.saaspegasus.com/static/images/web/how-pegasus-is-made/requirements.3e3b33541914.png"/></p>
<figcaption>A snippet from the cookiecutter requirements.txt file in Pegasus before I added post-processing. Maintaining this was a disaster.</figcaption>

<p>To solve these issues, I&#39;ve introduced a custom post-processing step to the pipeline.
After cookiecutter generates the project, but <em>before</em> the developer downloads it,
I run a number of things server-side to put the finishing touches on the project.
Formatting the code with <code>black</code>, running <code>isort</code>, building the final <code>requirements.txt</code> file, compiling and bundling the front end, and so on.</p>
<p>Doing it this way helps avoid having to manage crazy, complex cookiecutter logic on anything that can be automated.</p>
<h2 id="wrapping-up-complexity-all-the-way-down">Wrapping up: complexity all the way down</h2>
<p>At the end of the day, building Pegasus is—like most software projects—an exercise in managing  complexity.</p>
<p>My starting goal was to remove as much complexity as possible from the end-product of Pegasus: <em>the generated codebases</em>.
The simpler the generated codebases are, the better Pegasus the product will be.</p>
<p>But—the more complexity I shield from the end-user, the more I take on myself, and the harder the project is to maintain.
This eventually slows me down and hurts the product too—if in a less direct way.</p>
<p>So I also have to remove complexity for myself—as I&#39;ve done with cookiecutter, automated testing, post-processing and so on.</p>
<p>You could call what I&#39;m doing <em>complexity-driven development</em> (CDD) or <em>complexity juggling</em>.
As some area of Pegasus gets too complex, I prioritize coming up with a way to make it easier—either for my end-users or for myself.
Once things are streamlined, I move onto something else.</p>
<p><img alt="Complexity Juggler" src="https://www.saaspegasus.com/static/images/web/how-pegasus-is-made/complexity-juggler.edecc712068d.jpeg"/></p>
<figcaption>&#34;A juggler of complexity.&#34; Not me. Image by Midjourney.</figcaption>

<p>Pegasus still isn&#39;t perfect, but the rate of complexity growth has stabilized.
There are still a lot of balls in the air, but so far I&#39;m managing to keep them afloat.</p>
<hr/>

<p><em>Thanks to <a href="https://mtlynch.io/">Michael Lynch</a> and Rowena Luk for providing feedback on a draft of this.</em></p>
<p><em>If you want to find out when I publish new content you can subscribe below, or follow me <a href="https://twitter.com/czue">on Twitter</a>.</em></p>
<p><em>And if you want to take a massive shortcut to launch your next project, I hope you&#39;ll consider <a href="https://www.saaspegasus.com/">SaaS Pegasus</a>.
Hopefully this post has at least convinced you that it&#39;s something I work quite hard on.</em></p>
<p><strong>Notes</strong></p>

    </div>
  </section>
  <section>
    <div>
  <div>
    
    <h2>
      Sign up to get notified when I publish new articles about building
      SaaS applications with Django.
    </h2>
    <p>I don&#39;t spam and you can unsubscribe anytime.</p>
  </div>
  
</div>


  </section>


        </div></div>
  </body>
</html>
