<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://harper.blog/2024/04/12/i-accidentally-built-a-meme-search-engine/">Original</a>
    <h1>I accidentally built a meme search engine</h1>
    
    <div id="readability-page-1" class="page"><div><div><article><div><h2 id="or-how-to-learn-about-clipsiglip-and-vector-encoding-images">Or: how to learn about clip/siglip and vector encoding images</h2><p><em>tl;dr</em>: I built a meme search engine using siglip/CLIP and vector encoding images. It was fun and I learned a lot.</p><p>I have been building a lot of applied AI tools for a while. One of the components that always seemed the most magical has always been vector embeddings. <a href="https://en.wikipedia.org/wiki/Word2vec" target="_blank">Word2Vec</a> and the like have straight blown my mind. It is like magic.</p><p>I saw a <a href="https://news.ycombinator.com/item?id=39392582" target="_blank">simple app on hacker news</a> that was <a href="https://mood-amber.vercel.app/" target="_blank">super impressive</a>. Someone crawled a bunch of Tumblr images and used <a href="https://arxiv.org/abs/2303.15343" target="_blank">siglip</a> to get the embeddings and then made a simple “click the image and see similar images” app. It was like magic. I had no idea how to achieve this, but it seemed accessible.</p><p>I decided to use my sudden motivation as an opportunity to learn how “all this works.”</p><h2 id="wut">wut</h2><p>If you have never ran into vector embeddings, clip/siglip, vector databases, and the like - never fear.</p><p>Before I saw the hack on hn I really didn’t think much about vector embeddings, multi modal embeddings or vector datastores. I had used faiss (facebooks simple vector store), and Pinecone ($$) for some hacks, but didn’t really dig in. Just got it to work and then was like “yep. Tests pass.”</p><p>I still barely know what vectors are. Lol. Before I dug in and built this, I really didn’t understand how I would use it outside of RAG or another LLM process.</p><p>I learn by building. It helps if the results are really intriguing, and in this case kind of magical.</p><h3 id="wtf-terms">WTF terms</h3><p>I had a few friends read this over before publishing and a couple were like “wtf is X?” Here is a short list of terms that were largely new to me:</p><ul><li><strong>Vector Embeddings</strong> - Vector embeddings convert your text of images into numerical representations, allowing you to find similar pics and search your library effectively.</li><li><strong>Vector Database</strong> - A vector database is a way to store and search through encoded items, enabling you to find similar items.</li><li><strong>Word2Vec</strong> - Word2Vec is a groundbreaking technique that converts words into numerical vectors, enabling you to perform tasks like finding similar words and exploring relationships between them.</li><li><strong>CLIP</strong> - CLIP is OpenAI’s model that encodes images and text into numerical vectors.</li><li><strong>OpenCLIP</strong> - OpenCLIP is an open-source implementation of OpenAI’s CLIP model, allowing anyone to use and build upon this powerful image and text encoding technology without the need for special access or permissions.</li><li><strong>FAISS</strong> - FAISS is an efficient library for managing and searching through large collections of image vectors, making it fast and easy to find the images you’re looking for.</li><li><strong>ChromaDB</strong> - ChromaDB is a database that stores and retrieves your image and text vectors, quickly returning similar results for your searches.</li></ul><h2 id="keep-it-simple-harper">Keep it simple, harper.</h2><p>This is a pretty straight forward hack. I am just fucking around so I wasn’t super interested in making it scalable. I did have an interest in making it replicable. I wanted to make something that <strong>you</strong> could run without a lot of work.</p><p>One of my goals was to make sure everything runs locally to my laptop. We have these fancy Mac GPUs - let’s heat them up.</p><p>The first step was building out a simple crawler that would crawl a directory of images. I use Apple Photos, so I didn’t have a directory full of my photos laying around. I did, however, have a giant bucket of memes from my precious and very secret meme chat group (don’t tell anyone). I exported the chat, moved the images to a directory and BAM - I had my test image set.</p><h3 id="the-crawler">The Crawler</h3><p>I created the world’s worst crawler. Well. I should be honest: Claude created the world’s worst crawler with my instructions.</p><p>It is a bit complicated but here are the steps:</p><ol><li>It gets the file list of the target directory</li><li>It stores the list in a msgpack file</li><li>I reference the msgpack file and then iterate through every image and store it in a sqlite db. Grabing some metadata about the file<ul><li>hash</li><li>filesize</li><li>location</li></ul></li><li>I iterate through that sqlite db and then use CLIP to get the vector encoding of every image.</li><li>Then I store those vectors back in the sqlite db</li><li>Then I iterate through the sqlite db and insert the vectors and image path into chroma vector db</li><li>Then we are done</li></ol><p>This is a lot of wasted work. You could iterate through the images, grab the embeddings and slam it into chroma (I chose chroma cuz it is easy, free, and no infra).</p><p>I have built it this way because:</p><ul><li>After the memes, I crawled 140k images and wanted it to be resilient to crashing.</li><li>I needed it to be able to resume building out the databases in case it crashed, power went out, etc</li><li>I really like loops</li></ul><p>Regardless of the extra complexity, it worked flawlessly. I have crawled over 200k images without a blip.</p><h3 id="an-embedding-system">An embedding system</h3><p>Encoding the images was fun.</p><p>I started with siglip and created a <a href="https://github.com/harperreed/imbedding" target="_blank">simple web service</a> where we could upload the image and get the vectors back. This ran on one of our GPU boxes at the studio and worked well. It wasn’t fast, but it was way faster than running <a href="https://github.com/mlfoundations/open_clip" target="_blank">open clip</a> locally.</p><p>I still wanted to run it locally. I remembered that the <a href="https://github.com/ml-explore/" target="_blank">ml-explore</a> repo from apple had some neat examples that could help. And BAM they had a <a href="https://github.com/ml-explore/mlx-examples/tree/main/clip" target="_blank">clip implementation</a> that was fast af. Even using the larger model, it was faster than the 4090. Wildstyle.</p><p>I just needed to make it easy to use in my script.</p><h3 id="mlx_clip">MLX_CLIP</h3><p>Claude and I were able to coerce the example script from apple into a fun lil python class that you can use locally on any of your machines. It will download the models if they don’t exist, convert them, and then use them in flight with your script.</p><p>You can check it out here: <a href="https://github.com/harperreed/mlx_clip" target="_blank">https://github.com/harperreed/mlx_clip</a></p><p>I am pretty chuffed with how well it turned out. I know most people know this, but the apple silicon is fast af.</p><p>It turned out to be rather simple to use:</p><div><pre tabindex="0"><code data-lang="python"><span><span><span>import</span> mlx_clip
</span></span><span><span>
</span></span><span><span><span># Initialize the mlx_clip model with the given model name.</span>
</span></span><span><span>clip <span>=</span> mlx_clip<span>.</span>mlx_clip(<span>&#34;openai/clip-vit-base-patch32&#34;</span>)
</span></span><span><span>
</span></span><span><span><span># Encode the image from the specified file path and obtain the image embeddings.</span>
</span></span><span><span>image_embeddings <span>=</span> clip<span>.</span>image_encoder(<span>&#34;assets/cat.jpeg&#34;</span>)
</span></span><span><span><span># Print the image embeddings to the console.</span>
</span></span><span><span>print(image_embeddings)
</span></span><span><span>
</span></span><span><span><span># Encode the text description and obtain the text embeddings.</span>
</span></span><span><span>text_embeddings <span>=</span> clip<span>.</span>text_encoder(<span>&#34;a photo of a cat&#34;</span>)
</span></span><span><span><span># Print the text embeddings to the console.</span>
</span></span><span><span>print(text_embeddings)
</span></span></code></pre></div><p>I would love to get this to work with siglip, as I prefer that model (it is way better than CLIP). However, this is a POC more than a product I want to maintain. If anyone has any hints on how to get it working with siglip - <a href="https://harper.blog/cdn-cgi/l/email-protection#eb838a999b8e99ab86848f8e989fc5888486">hmu</a>. I don’t want to reinvent open clip - which should theoretically run well on apple silicon, and is very good.</p><h3 id="now-what">Now what</h3><p>Now that we had all the image vectors slammed into the vector datastore we could get started with the interface. I used the built in query functionality of chromadb to show similar images.</p><p>Grab the vectors of the image you are starting with. Query those vectors with chromadb. Chromed returns a list of image ids that are similar in declining similarity.</p><p>I then wrapped it all up in a tailwind/flask app.
This was incredible.</p><p>I can’t imagine the amount of work we would have done in 2015 to build this. I spent maybe 10 hours total on this and it was trivial.</p><p>The results are akin to magic.</p><h3 id="memes-concept-search">Memes concept search</h3><p>Now remember, I used memes as my initial set of images. I had 12000 memes to search through.</p><p>Start with this:</p><figure role="group" aria-describedby="caption-So true"><img title="" loading="lazy" decoding="async" src="https://harper.blog/images/posts/vector-memes-bowie.png" alt="" width="" height=""/><figcaption id="caption-So true">So true</figcaption></figure><p>Encode it, pass it to chroma to return similar results.</p><p>And then similar images that return are like this:
<img title="" loading="lazy" decoding="async" src="https://harper.blog/images/posts/vector-memes-bowie-results.png" alt="" width="" height=""/></p><p>Another example:
<img title="" loading="lazy" decoding="async" src="https://harper.blog/images/posts/vector-memes-star-trek.png" alt="" width="" height=""/></p><p>Gives you results like:
<img title="" loading="lazy" decoding="async" src="https://harper.blog/images/posts/vector-memes-star-trek-results.png" alt="" width="" height=""/></p><p>It is really fun to click around.</p><h3 id="namespaces">Namespaces?</h3><p>The magic isn’t clicking on an image and getting a similar image. That is cool, but wasn’t “holy shit” for me.</p><p>What blew my mind was using the same model to encode the search text into vectors and finding images similar to the text.</p><p>For whatever reason, this screws up my brain. It is one thing to have a neat semantic like search for images based on another images. Being able to have a nice multi modal interface really made it like a magic trick.</p><p>Here are some examples:</p><p>Searching for <strong>money</strong>. I grab the encoding for money and pass the vectors to chroma. The results for <strong>money</strong> are:
<img title="" loading="lazy" decoding="async" src="https://harper.blog/images/posts/vector-memes-money.png" alt="" width="" height=""/></p><p>Searching for <strong>AI</strong>
<img title="" loading="lazy" decoding="async" src="https://harper.blog/images/posts/vector-memes-ai.png" alt="" width="" height=""/></p><p>Searching for <strong>red</strong> (a dozy! Is it a color? Is a lifestyle? Is it Russia?)
<img title="" loading="lazy" decoding="async" src="https://harper.blog/images/posts/vector-memes-red.png" alt="" width="" height=""/></p><p>So on and so forth. Forever. It is magical. You can find all sorts of gems you forgot about. Oh shit I need a meme about writing a blog post:
<img title="" loading="lazy" decoding="async" src="https://harper.blog/images/posts/vector-memes-writing-meme.jpg" alt="" width="" height=""/></p><p>(I am self aware, I just don’t care - lol)</p><h3 id="how-does-it-work-with-a-photo-library">How does it work with a photo library?</h3><p>It works super well.</p><p>I highly recommend running this against your photo library. To get started, I downloaded my google photos takeout archive. Extracted it onto an external disk. I had to run a few scripts against it to make it usable (Whoever designed the google photos takeout is very excited about duplicate data). I then pointed the script at that directory instead of my memes folder and let ’er rip.</p><p>I had about 140k photos and it took about 6 hours to run through. Not so bad. The results are incredible.</p><h4 id="here-are-some-fun-examples">Here are some fun examples:</h4><p>Obviously these are similar (I also have a dupe problem in google photos)
<img title="" loading="lazy" decoding="async" src="https://harper.blog/images/posts/vector-memes-harper.png" alt="" width="" height=""/></p><p>We have had a lot of poodles. Here are some
<img title="" loading="lazy" decoding="async" src="https://harper.blog/images/posts/vector-memes-poodles.png" alt="" width="" height=""/></p><p>You can search for landmarks. I had no idea I had taken a photo of fuji-san from a plane!
<img title="" loading="lazy" decoding="async" src="https://harper.blog/images/posts/vector-memes-fuji-results.png" alt="" width="" height=""/></p><p>And then find similar images of Mt Fuji.
<img title="" loading="lazy" decoding="async" src="https://harper.blog/images/posts/vector-memes-fuji-similar.png" alt="" width="" height=""/></p><p>It is pretty easy to search for places.
<img title="" loading="lazy" decoding="async" src="https://harper.blog/images/posts/vector-memes-chicago.png" alt="" width="" height=""/></p><p>Or emotions. I am apparently surprising so I have a lot of surprised photos.
<img title="" loading="lazy" decoding="async" src="https://harper.blog/images/posts/vector-memes-surprised.png" alt="" width="" height=""/></p><p>Also niche things like low riders. (These are from Shibuya!)
<img title="" loading="lazy" decoding="async" src="https://harper.blog/images/posts/vector-memes-low-riders.png" alt="" width="" height=""/></p><p>And you can use it to find things that are not easy to find or search for. Like bokeh.
<img title="" loading="lazy" decoding="async" src="https://harper.blog/images/posts/vector-memes-bokeh.png" alt="" width="" height=""/></p><p>It’s wonderful, because I can click through and find great images I had forgotten about. Like this great photo of Baratunde that I took in 2017:</p><p><img title="" loading="lazy" decoding="async" src="https://harper.blog/images/posts/vector-memes-baratunde.png" alt="" width="" height=""/></p><h3 id="this-will-be-everywhere">This will be everywhere</h3><p>I imagine that we will see this tech rolled into all the various photo apps shortly. Google Photos probably already does this, but they have googled it so much that nobody notices.</p><p>This is too good to not roll into whatever photo app you use. If I had any large scale product that used photos or images, I would immediately set up a pipeline to start encoding the images to see what kind of weird features this unlocks.</p><h2 id="you-can-use-this-for-the-low-price-of-free">YOU CAN USE THIS FOR THE LOW PRICE OF FREE</h2><p>I put the source here: <a href="https://github.com/harperreed/photo-similarity-search" target="_blank">harperreed/photo-similarity-search</a>.</p><p>Please check it out.</p><p>It is pretty straight forward to get going. It is a bit hacky. lol.</p><p>I would use conda or something similar to keep things clean. The interface is simple tailwind. The web is flask. The code is python. I am your host, harper reed.</p><h2 id="my-challenge-for-you">My challenge for you!</h2><p>Please build an app that I can use to catalog my photo library in a nice way. I don’t want to upload to another destination. I want to have a simple Mac app that I can point to my photo library and say “crawl this.” I imagine a lot of neat stuff could be added:</p><ul><li>Llava/Moondream auto captioning</li><li>Keywords / Tags</li><li>Vector similarity</li><li>etc</li></ul><p>It should run locally. Be a native app. Be simple, and effective. Maybe plug into Lightroom, capture one, or apple photos.</p><p>I want this. Build it. Let’s discover all the amazing photos we have taken through the magic of AI.</p><p>My hacking buddy Ivan was around while I was building this. He immediately saw the magic of what a person could discover by using this on their photo library. He wanted to use it immediately.</p><p>His photo catalog is on an external hard drive - but he had his Lightroom preview file locally. He wrote a quick script to extract the thumbnails and metadata from the preview file and save it to an external disk.</p><p>We then ran the image vector crawler and BAM - he could see similar images and what not. Worked perfectly.</p><h4 id="recover-your-lightroom-photos-or-at-least-the-thumbnails">Recover your Lightroom photos. Or at least the thumbnails.</h4><p>Ivan’s simple script to extract the images from the preview file is really awesome. If you have ever lost your real photo library (corrupt harddrive, or whatever) and you still have the lrpreview file - this script can help you extract at least the lower res version.</p><p>A super handy script to keep around.</p><p>You can check it out here: <a href="https://github.com/ibips/lrprev-extract" target="_blank">LR Preview JPEG Extractor</a>.</p><h2 id="thanks-for-reading">Thanks for reading.</h2><p>As always, <a href="https://harper.blog/cdn-cgi/l/email-protection#99f1f8ebe9fcebd9f4f6fdfceaedb7faf6f4">hmu</a> and let’s hang out. I am thinking a lot about AI, Ecommerce, photos, hifi, hacking and other shit.</p><p>If you are in Chicago come hang out.</p></div></article></div></div></div>
  </body>
</html>
