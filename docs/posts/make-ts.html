<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://matklad.github.io/2026/01/27/make-ts.html">Original</a>
    <h1>Make.ts</h1>
    
    <div id="readability-page-1" class="page"><div>
      <article>
        <header>
          
          <time datetime="2026-01-27">Jan 27, 2026</time>
        </header>
        <p>
          <kbd><kbd>Up Enter</kbd></kbd> <kbd><kbd>Up Up Enter</kbd></kbd> <kbd><kbd>Up Up Up Enter</kbd></kbd>
        </p>
        <p>
          Sounds familiar? This is how I historically have been running
          benchmarks and other experiments requiring a repeated sequence of
          commands — type them manually once, then rely on shell history (and
          maybe some terminal splits) for reproduction. These past few years
          I’ve arrived at a much better workflow pattern — <code>make.ts</code>.
          I was forced to adapt it once I started working with multiprocess
          applications, where manually entering commands is borderline
          infeasible. In retrospect, I should have adapted the workflow years
          earlier.
        </p>
        <section id="The-Pattern">
          <h2><a href="#The-Pattern">The Pattern</a></h2>
          <p>
            Use a (gitignored) file for interactive scripting. Instead of
            entering a command directly into the terminal, write it to a file
            first, and then run the file. For me, I type stuff into <code>make.ts</code> and then run <code>./make.ts</code> in my terminal
            (Ok, I need <em>one</em> <kbd><kbd>Up Enter</kbd></kbd> for that).
          </p>
          <p>
            I want to be clear here, I am not advocating writing “proper”
            scripts, just capturing your interactive, ad-hoc command to a
            persistent file. Of course any command that you want to execute
            <em>repeatedly</em> belongs to the build system. The surprising
            thing is that even more complex one-off commands benefit from
            running through file, because it will take you several tries to get
            them right!
          </p>
          <p>
            There are many benefits relative to <kbd><kbd>Up Up Up</kbd></kbd>
            workflow:
          </p>
          <ul>
            <li>
              Real commands tend to get large, and it is so much nicer to use a
              real 2D text editor rather than shell’s line editor.
            </li>
            <li>
              If you need more than one command, you can write several commands,
              and still run them all with a single key (before <code>make.ts</code>, I was prone to constructing rather horrific
              &amp;&amp; conjuncts for this reason).
            </li>
            <li>
              With a sequence of command outlined, you nudge yourself towards
              incrementally improving them, making them idempotent, and
              otherwise investing into your own workflow for the next few
              minutes, without falling into the YAGNI pit from the outset.
            </li>
            <li>
              At some point you might realize after, say, running a series of
              ad-hoc benchmarks interactively, that you’d rather write a proper
              script which executes a collection of benchmarks with varying
              parameters. With the file approach, you already have the meat of
              the script implemented, and you only need to wrap in a couple of
              fors and ifs.
            </li>
            <li>
              Finally, if you happen to work with multi-process projects, you’ll
              find it easier to manage concurrency declaratively, spawning a
              tree of processes from a single script, rather than switching
              between terminal splits.
            </li>
          </ul>
        </section>
        <section id="Details">
          <h2><a href="#Details">Details</a></h2>
          <p>
            Use a consistent filename for the script. I use <code>make.ts</code>, and so there’s a <code>make.ts</code> in the root
            of most projects I work on. Correspondingly, I have <code>make.ts</code> line in project’s <code>.git/info/exclude</code>
            — the <code>.gitignore</code> file which is not shared. The fixed
            name reduces fixed costs — whenever I need complex interactivity I
            don’t need to come up with a name for a new file, I open my
            pre-existing <code>make.ts</code>, wipe whatever was there and start
            hacking. Similarly, I have <code>./make.ts</code> in my shell
            history, so
            <a href="https://fishshell.com/docs/current/interactive.html#autosuggestions">fish autosuggestions</a>
            work for me. At one point, I had a VS Code task to run <code>make.ts</code>, though I now use
            <a href="https://matklad.github.io/2025/08/31/vibe-coding-terminal-editor.html">terminal editor</a>.
          </p>
          <p>
            Start the script with hash bang,
            <span><code>#!/usr/bin/env -S deno run
                --allow-all</code></span>
            in my case, and
            <span><code>chmod a+x make.ts</code></span>
            the file, to make it easy to run.
          </p>
          <p>Write the script in a language that:</p>
          <ul>
            <li>
              you are comfortable with,
            </li>
            <li>
              doesn’t require huge setup,
            </li>
            <li>
              makes it easy to spawn subprocesses,
            </li>
            <li>
              has good support for concurrency.
            </li>
          </ul>
          <p>
            For me, that is TypeScript. Modern JavaScript is sufficiently
            ergonomic, and structural, gradual typing is a sweet spot that gives
            you reasonable code completion, but still allows brute-forcing any
            problem by throwing enough stringly dicts at it.
          </p>
          <p>
            JavaScript’s tagged template syntax is brilliant for scripting
            use-cases:
          </p>

          <figure>
            <pre><code><span><span>function</span> <span>$</span>(<span>literal, ...interpolated</span>) {</span>
<span>  <span>console</span>.<span>log</span>({ literal, interpolated });</span>
<span>}</span>
<span></span>
<span><span>const</span> dir = <span>&#34;hello, world&#34;</span>;</span>
<span>$<span>`ls <span>${dir}</span>`</span>;</span></code></pre>
          </figure>
          <p>prints</p>

          <figure>
            <pre><code><span><span>{</span></span>
<span>    literal<span>:</span> <span>[</span> <span>&#34;ls &#34;</span><span>,</span> <span>&#34;&#34;</span> <span>]</span><span>,</span></span>
<span>    interpolated<span>:</span> <span>[</span> <span>&#34;hello, world&#34;</span> <span>]</span></span>
<span><span>}</span></span></code></pre>
          </figure>
          <p>
            What happens here is that <code>$</code> gets a list of literal
            string fragments inside the backticks, and then, separately, a list
            of values to be interpolated in-between. It <em>could</em>
            concatenate everything to just a single string, but it doesn’t have
            to. This is precisely what is required for process spawning, where
            you want to pass an array of strings to the <code>exec</code>
            syscall.
          </p>
          <p>
            Specifically, I use <a href="https://github.com/dsherret/dax">dax</a> library with Deno, which is excellent as a single-binary
            batteries-included scripting environment (see <a href="https://matklad.github.io/2023/02/12/a-love-letter-to-deno.html">&lt;3 Deno</a>). Bun has a dax-like library in the box and is a
            good alternative (though I personally stick with Deno because of
            <code>deno fmt</code> and <code>deno lsp</code>). You could also use
            famous zx, though be mindful that it
            <a href="https://google.github.io/zx/configuration#shell">uses your shell as a middleman</a>, something I consider to be
            sloppy (<a href="https://julialang.org/blog/2012/03/shelling-out-sucks/">explanation</a>).
          </p>
          <p>
            While <code>dax</code> makes it convenient to spawn a single
            program, <code>async/await</code> is excellent for herding a slither
            of processes:
          </p>

          <figure>
            <pre><code><span><span>await</span> <span>Promise</span>.<span>all</span>([</span>
<span>    $<span>`sleep 5`</span>,</span>
<span>    $<span>`sleep 10`</span>,</span>
<span>]);</span></code></pre>
          </figure>
        </section>
        <section id="Concrete-Example">
          <h2><a href="#Concrete-Example">Concrete Example</a></h2>
          <p>
            Here’s how I applied this pattern earlier today. I wanted to measure
            how TigerBeetle cluster recovers from the crash of the primary. The
            manual way to do that would be to create a bunch of ssh sessions for
            several cloud machines, format datafiles, start replicas, and then
            create some load. I
            <em>almost</em> started to split my terminal up, but then figured
            out I can do it the smart way.
          </p>
          <p>
            The first step was cross-compiling the binary, uploading it to the
            cloud machines, and running the cluster (using my <a href="https://matklad.github.io/2026/01/20/vibecoding-2.html">box</a> from the other week):
          </p>

          <figure>
            <pre><code><span><span>#!/usr/bin/env -S deno run --allow-all</span></span>
<span><span>import</span> $ <span>from</span> <span>&#34;jsr:@david/dax@0.44.2&#34;</span>;</span>
<span></span>
<span><span>await</span> $<span>`./zig/zig build -Drelease -Dtarget=x86_64-linux`</span>;</span>
<span><span>await</span> $<span>`box sync 0-5 ./tigerbeetle`</span>;</span>
<span><span>await</span> $<span>`box run 0-5</span></span>
<span><span>    ./tigerbeetle format --cluster=0 --replica-count=6 --replica=?? 0_??.tigerbeetle`</span>;</span>
<span><span>await</span> $<span>`box run 0-5</span></span>
<span><span>    ./tigerbeetle start --addresses=?0-5? 0_??.tigerbeetle`</span>;</span></code></pre>
          </figure>
          <p>
            Running the above the second time, I realized that I need to kill
            the old cluster first, so two new commands are “interactively”
            inserted:
          </p>

          <figure>
            <pre><code><span><span>await</span> $<span>`./zig/zig build -Drelease -Dtarget=x86_64-linux`</span>;</span>
<span><span>await</span> $<span>`box sync 0-5 ./tigerbeetle`</span>;</span>
<span></span>
<span><span>await</span> $<span>`box run 0-5 rm 0_??.tigerbeetle`</span>.<span>noThrow</span>();</span>
<span><span>await</span> $<span>`box run 0-5 pkill tigerbeetle`</span>.<span>noThrow</span>();</span>
<span></span>
<span><span>await</span> $<span>`box run 0-5</span></span>
<span><span>    ./tigerbeetle format --cluster=0 --replica-count=6 --replica=?? 0_??.tigerbeetle`</span>;</span>
<span><span>await</span> $<span>`box run 0-5</span></span>
<span><span>    ./tigerbeetle start --addresses=?0-5? 0_??.tigerbeetle`</span>;</span></code></pre>
          </figure>
          <p>
            At this point, my investment in writing this file and not just
            entering the commands one-by-one already paid off!
          </p>
          <p>
            The next step is to run the benchmark load in parallel with the
            cluster:
          </p>

          <figure>
            <pre><code><span><span>await</span> <span>Promise</span>.<span>all</span>([</span>
<span>    $<span>`box run 0-5 ./tigerbeetle start     --addresses=?0-5? 0_??.tigerbeetle`</span>,</span>
<span>    $<span>`box run 6   ./tigerbeetle benchmark --addresses=?0-5?`</span>,</span>
<span>])</span></code></pre>
          </figure>
          <p>
            I don’t need two terminals for two processes, and I get to
            copy-paste-edit the mostly same command.
          </p>
          <p>
            For the next step, I actually want to kill one of the replicas, and
            I also want to capture live logs, to see in real-time how the
            cluster reacts. This is where <code>0-5</code> multiplexing syntax
            of box falls short, but, given that this is JavaScript, I can just
            write a for loop:
          </p>

          <figure>
            <pre><code><span><span>const</span> replicas = <span>range</span>(<span>6</span>).<span>map</span>(<span>(<span>it</span>) =&gt;</span></span>
<span>    $<span>`box run <span>${it}</span></span></span>
<span><span>        ./tigerbeetle start --addresses=?0-5? 0_??.tigerbeetle</span></span>
<span><span>        &amp;&gt; logs/<span>${it}</span>.log`</span></span>
<span>        .<span>noThrow</span>()</span>
<span>        .<span>spawn</span>()</span>
<span>);</span>
<span></span>
<span><span>await</span> <span>Promise</span>.<span>all</span>([</span>
<span>    $<span>`box run 6 ./tigerbeetle benchmark --addresses=?0-5?`</span>,</span>
<span>    (<span>async</span> () =&gt; {</span>
<span>        <span>await</span> $.<span>sleep</span>(<span>&#34;20s&#34;</span>);</span>
<span>        <span>console</span>.<span>log</span>(<span>&#34;REDRUM&#34;</span>);</span>
<span>        <span>await</span> $<span>`box run 1 pkill tigerbeetle`</span>;</span>
<span>    })(),</span>
<span>]);</span>
<span></span>
<span>replicas.<span>forEach</span>(<span>(<span>it</span>) =&gt;</span> it.<span>kill</span>());</span>
<span><span>await</span> <span>Promise</span>.<span>all</span>(replicas);</span></code></pre>
          </figure>
          <p>
            At this point, I do need two terminals. One runs <code>./make.ts</code> and shows the log from the benchmark itself, the
            other runs <code>tail -f logs/2.log</code> to watch the next replica
            to become primary.
          </p>
          <p>
            I have definitelly crossed the line where writing a script makes
            sense, but the neat thing is that the gradual evolution up to this
            point. There isn’t a discontinuity where I need to spend 15 minutes
            trying to shape various ad-hoc commands from five terminals into a
            single coherent script, it was in the file to begin with.
          </p>
          <p>
            And then the script is easy to evolve. Once you realize that it’s a
            good idea to also run the same benchmark against a different,
            baseline version TigerBeetle, you replace <code>./tigerbeetle</code>
            with
            <code>./${tigerbeetle}</code> and wrap everything into
          </p>

          <figure>
            <pre><code><span><span>async</span> <span>function</span> <span>benchmark</span>(<span>tigerbeetle: <span>string</span></span>) {</span>
<span>    </span>
<span>}</span>
<span></span>
<span><span>const</span> tigerbeetle = <span>Deno</span>.<span>args</span>[<span>0</span>]</span>
<span><span>await</span> <span>benchmark</span>(tigerbeetle);</span></code></pre>
          </figure>

          <figure>
            <pre><code><span><span>$</span> ./make.ts tigerbeetle-baseline</span>
<span><span>$</span> ./make.ts tigerbeetle</span></code></pre>
          </figure>
          <p>
            A bit more hacking, and you end up with a repeatable benchmark
            schedule for a matrix of parameters:
          </p>

          <figure>
            <pre><code><span><span>for</span> (<span>const</span> attempt <span>of</span> [<span>0</span>, <span>1</span>])</span>
<span><span>for</span> (<span>const</span> tigerbeetle <span>of</span> [<span>&#34;baseline&#34;</span>, <span>&#34;tigerbeetle&#34;</span>])</span>
<span><span>for</span> (<span>const</span> mode <span>of</span> [<span>&#34;normal&#34;</span>, <span>&#34;viewchange&#34;</span>]) {</span>
<span>    <span>const</span> results = $.<span>path</span>(</span>
<span>        <span>`./results/<span>${tigerbeetle}</span>-<span>${mode}</span>-<span>${attempt}</span>`</span>,</span>
<span>    );</span>
<span>    <span>await</span> <span>benchmark</span>(tigerbeetle, mode, results);</span>
<span>}</span></code></pre>
          </figure>
          <p>
            That’s the gist of it. Don’t let the shell history be your source,
            capture it into the file first!
          </p>
        </section>
      </article>
    </div></div>
  </body>
</html>
