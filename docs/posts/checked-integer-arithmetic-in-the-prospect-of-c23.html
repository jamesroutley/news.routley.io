<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://gustedt.wordpress.com/2022/12/18/checked-integer-arithmetic-in-the-prospect-of-c23/">Original</a>
    <h1>Checked integer arithmetic in the prospect of C23</h1>
    
    <div id="readability-page-1" class="page"><article id="post-3855">
	<!-- .entry-header -->

	
	
	<div>
		
<p>As you might have noticed, C23 is scheduled to come out in November 2023 and will have a lot of improvements and new features, in particular for integers. One of the most controversial properties of integer arithmetic in C is the overflow behavior. C23 will have a new header <code>&lt;stdckdint.h&gt;</code> for “checked integer operations”, that helps to deal with overflow and puts the responsibility in your hands, the programmer. In addition to the result of an arithmetic operation, the interfaces provide an extra <code>bool</code> value that tells if the operation has been erroneous or not.</p>



<p>The addition that has been integrated into C23 is the <a href="https://open-std.org/JTC1/SC22/WG14/www/docs/n2683.pdf">core proposal</a> and</p>



<p>Anyhow, for many of you it is even possible to use these features in a C23 compatible way just now, because they are closely modeled after similar gcc and clang features. Since overflow still is an important source of bugs and security issues, you should just</p>



<p><b>start using checked integer operations, now!</b></p>



<p>There are three new type-generic interfaces for addition, subtraction and multiplication:</p>


<div><pre title="">#include &lt;stdckdint.h&gt;
bool ckd_add(type1 *result, type2 a, type3 b);
bool ckd_sub(type1 *result, type2 a, type3 b);
bool ckd_mul(type1 *result, type2 a, type3 b);
</pre></div>


<p>Their working is quite simple: the arithmetic is as if performed in the set of mathematical integers and then the value is written to <code>*result</code>. If it fits, the return value is <code>false</code>. If it doesn’t fit, the return value is <code>true</code>, and the stored result are the lower bits of the mathematical value, just as much bits as as do fit into the target type. For unsigned types that is exactly the same value as would have given an operation with that target type; the additional <code>bool</code> value just tells you if there has been a wrap around. For signed types, this corresponds to the bit pattern of the corresponding unsigned value, and is exactly the value that you’d expect, knowing that now two’s complement is the only sign representation that remains valid for C.</p>



<p>Now how can we use this already with gcc and similar compilers, if we don’t even yet have C23 compilers?  To see that let’s look an example code:</p>


<div><pre title="">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;stdatomic.h&gt;

/* This is in the public domain, so you can copy this around freely.
But I would be nice if you could just link to this blog post at 
https://gustedt.wordpress.com/ such that users see an explanation. */

/* C23 has three new tg interfaces in the new &lt;stdkdint.h&gt; header.
They are modeled after similar gcc features. They are meant to do
arithmetic with overflow check by using everything the compiler can
get from instruction flags that already exist on most CPU.

If we don&#39;t have the header, yet, we may easily emulate it if we are
on a compiler claiming compatibility with gcc. */

#if __has_include(&lt;stdckdint.h&gt;)
# include &lt;stdckdint.h&gt;
#else
# ifdef __GNUC__
#  define ckd_add(R, A, B) __builtin_add_overflow ((A), (B), (R))
#  define ckd_sub(R, A, B) __builtin_sub_overflow ((A), (B), (R))
#  define ckd_mul(R, A, B) __builtin_mul_overflow ((A), (B), (R))
# else
#  error &#34;we need a compiler extension for this&#34;
# endif
#endif

#if __STC_VERSION__ &lt; 202300L
# define nullptr ((void*)0)
#endif

#ifndef TYPE
# define TYPE unsigned long long
#endif

typedef unsigned long long ullong;

// Use a fence such that the assembler is not reordered too wildly
#define fence atomic_signal_fence(memory_order_seq_cst)

int main(int argc, char* argv[argc + 1]) {
  if (argc != 2) {
    fprintf(stderr, &#34;we need exactly 1 arguments, found %d\n&#34;, argc-1);
  } else {
    TYPE a = strtoull(argv[1], nullptr, 0);
    TYPE result_add;
    TYPE result_sub;
    TYPE result_mul;

    for (TYPE b = 1; b &lt; 4; ++b) {
      bool add_invalid = ckd_add(&amp;result_add, a, b);
      fence;
      bool sub_invalid = ckd_sub(&amp;result_sub, a, b);
      fence;
      bool mul_invalid = ckd_mul(&amp;result_mul, a, b);
      fence;

      printf(&#34;operation add for %#llX and %#llX is %s, result is %#llX\n&#34;,
             (ullong)a, (ullong)b, (add_invalid ? &#34;invalid&#34; : &#34;valid&#34;), (ullong)result_add);
      printf(&#34;operation sub for %#llX and %#llX is %s, result is %#llX\n&#34;,
             (ullong)a, (ullong)b, (sub_invalid ? &#34;invalid&#34; : &#34;valid&#34;), (ullong)result_sub);
      printf(&#34;operation mul for %#llX and %#llX is %s, result is %#llX\n&#34;,
             (ullong)a, (ullong)b, (mul_invalid ? &#34;invalid&#34; : &#34;valid&#34;), (ullong)result_mul);
    }
  }
}
</pre></div>


<p>Here in line <code>18</code> we use a new feature <code>__has_include</code> that also comes with C23 and which gcc and clang implement since a long time. So if the header exists we will be using it, if not we define three fallback macros that do the job.</p>



<p>If you successfully compile this into an executable, you may test the feature with some big number as the first and only command-line argument. On my machine this gives for example the following:</p>


<div><pre title="">&lt;517&gt;$ ./test-ckd 0xFFFFFFFFFFFFFFFD
operation add for 0XFFFFFFFFFFFFFFFD and 0X1 is valid, result is 0XFFFFFFFFFFFFFFFE
operation sub for 0XFFFFFFFFFFFFFFFD and 0X1 is valid, result is 0XFFFFFFFFFFFFFFFC
operation mul for 0XFFFFFFFFFFFFFFFD and 0X1 is valid, result is 0XFFFFFFFFFFFFFFFD
operation add for 0XFFFFFFFFFFFFFFFD and 0X2 is valid, result is 0XFFFFFFFFFFFFFFFF
operation sub for 0XFFFFFFFFFFFFFFFD and 0X2 is valid, result is 0XFFFFFFFFFFFFFFFB
operation mul for 0XFFFFFFFFFFFFFFFD and 0X2 is invalid, result is 0XFFFFFFFFFFFFFFFA
operation add for 0XFFFFFFFFFFFFFFFD and 0X3 is invalid, result is 0
operation sub for 0XFFFFFFFFFFFFFFFD and 0X3 is valid, result is 0XFFFFFFFFFFFFFFFA
operation mul for 0XFFFFFFFFFFFFFFFD and 0X3 is invalid, result is 0XFFFFFFFFFFFFFFF7

</pre></div>


<p>Here you see that for the input value multiplication overflowed for values <code>0x2</code> and <code>0x3</code>, whereas for addition that happens only for value <code>0x3</code>. The object code that the compiler produces for this should be close to optimal: it should use processor flags to track the validity of the operation and optimize out stores to <code>*result</code> if only the value (and not the pointer) is used later on.</p>



<p>One valid use of these functions is to use them with signed integer types and to just ignore the <code>bool</code> return. This then leads to the value as it wraps around, but the behavior is always well-defined, if that is want you want or need.</p>



<p>As you can see, there are no interfaces for division or modulo. This is so, because these are quite different from the other arithmetic. For unsigned types there is exactly one input value that is invalid, namely <code>0</code> as the divisor. When we have that, there is no clear value or bit-pattern that would be reasonable to return as <code>*result</code>. Division by zero is a logical error that indeed should never occur, and if it does, where a real error handling path is in order.</p>



<p>For all other value we are fine; valid division and modulo operations always have results that are smaller than the input. (There could be a problem if we choose a result type that is too narrow, though.)</p>



<p>For signed values there is an additional difficulty. There is exactly one value for which negation leads to an error, namely the most negative values of the type. So for example</p>





<p>has the mathematical value <code>INT_MAX + 1</code> which obviously does not fit into an <code>int</code>.</p>
			
			
				</div><!-- .entry-content -->

	<!-- .entry-footer -->
</article></div>
  </body>
</html>
