<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://kuzudb.com/blog/what-every-gdbms-should-do-and-vision.html">Original</a>
    <h1>What Every Competent Graph DBMS Should Do</h1>
    
    <div id="readability-page-1" class="page"><div id="main-content" role="main"> <p>by Semih Salihoƒülu, Jan 12th, 2023</p>  <p>As a co-implementor of the K√πzu GDBMS and a professor at University of Waterloo, I have been thinking of GDBMSs day in and day out for many years now. After years of understanding and publishing on the architectural principles of graph data management (<a href="http://www.vldb.org/pvldb/vol12/p1692-mhedhbi.pdf">1</a>, <a href="https://www.vldb.org/pvldb/vol14/p2491-gupta.pdf">2</a>, <a href="https://www.vldb.org/pvldb/vol15/p1011-jin.pdf">3</a>, <a href="https://www.vldb.org/pvldb/vol15/p1533-chen.pdf">4</a>), we decided to develop <a href="https://github.com/kuzudb/kuzu">K√πzu</a> as a state-of-the-art modern embeddable GDBMS. This post covers my broad opinions on GDBMSs, and the feature set they should optimize for and why. In doing so, it also gives an overall vision of K√πzu!</p> <blockquote> <p><strong>Tldr: The key takeaways are:</strong></p> <ul> <li><strong>Overview of GDBMSs</strong>: GDBMSs are relational in their cores but offer an elegant graph model to model application data and SQL-like query languages with elegant graph-specific syntax. Many applications, e.g., in <a href="https://tinyurl.com/3x89ceum">fraud detection</a>, <a href="https://www.tigergraph.com/solutions/recommendation-engine/">recommendations</a>, <a href="https://tinyurl.com/3z9bckmm">personalization</a>, etc. benefit from such modeling and query language features.</li> <li><strong>Key Feature Set of GDBMSs</strong>: Despite being relational, GDBMS optimize (or at least they should!) for a distinct set of features/use cases that RDBMSs do not traditionally optimize for: (i) pre-defined/pointer-based joins; (ii) growing many-to-many joins; (iii) recursive joins; (iv) schema querying; (v) efficient storage of semi-structured data and URIs. GDBMSs that want to be competitive in terms of performance need to perfect this feature set and that‚Äôs exactly what K√πzu aims to do!</li> <li><strong>K√πzu as the GDBMS for Graph Data Science</strong>: One example application domain the K√πzu team is exited about is to be a usable, efficient, and scalable GDBMS of graph data science in the Python graph analytics ecosystem. Here we are looking at how DuckDB revolutionized tabular data science and want to repeat it in graph data science!</li> </ul> </blockquote> <p>This week, I presented K√πzu to the database community at the <a href="https://www.cidrdb.org/cidr2023/papers/p48-jin.pdf">CIDR 2023</a> conference in Amsterdam. For those who are not familiar with academic database conferences, CIDR brings together work from academia and industry to discuss recent research on systems aspects of database technology. Our paper was about K√πzu‚Äôs goals and vision and its core query processor design for evaluating complex growing joins. We intentionally targeted CIDR for our paper because of its systems focus and we thought many system gurus would be there: the attendees included creators of <a href="https://www.monetdb.org/">MonetDB</a>, <a href="https://en.wikipedia.org/wiki/Vectorwise">Vectorwise</a>, <a href="https://duckdb.org/">DuckDB</a>, <a href="https://www.snowflake.com/en/">Snowflake</a>, <a href="https://www.databricks.com/">Databricks</a>, amongst others. It also meant a lot to share our ambitious goal of developing a usable GDBMS from an academic setting in this CIDR because it was organized locally by CWI. The late <a href="https://en.wikipedia.org/wiki/Martin_L._Kersten">Martin Kersten</a> founded the CWI database group and was a pioneer of this style of research projects and his successors are continuing this tradition very successfully today. CWI has created many successful DBMSs, including MonetDB (Martin‚Äôs legacy), Vectorwise, and most recently DuckDB. People paid their respects to Martin during an emotional memorial on the first night of the conference. As a surprise, <a href="https://memgraph.com/">MemGraph</a> co-founder and CTO <a href="https://www.linkedin.com/in/markobudiselic/">Marko Budiseliƒá</a> was also there (it was his first CIDR)! Marko is an extremely friendly and humble person you should meet and it great to share our insights about where GDBMSs make a difference in enterprise applications.</p> <p>I want to start a 3-part blog post to cover the contents of our CIDR paper in a less academic language:</p> <ul> <li>Post 1: K√πzu‚Äôs goals and vision as a system</li> <li>Post 2: Factorization technique for compression</li> <li>Post 3: Worst-case optimal join algorithms</li> </ul> <p>In this Post 1, I discuss the following: (i) <a href="#overview-of-gdbms-and-a-bit-of-history">an overview of GDBMSs</a>. (ii) <a href="#features-every-competent-gdbms-should-optimize-for-">the features GDBMSs should optimize for and why;</a> and (iii) <a href="#k√πzu-as-a-gdbms-for-graph-data-science-pipelines">an example application domain (graph data science!) we are immediately targeting with K√πzu. </a> (ii) and (iii) should give you a good idea about the current goals and vision of K√πzu. If you know GDBMSs well, you should skip over (i).</p> <h2 id="overview-of-gdbmss-and-a-bit-of-history"> <a href="#overview-of-gdbmss-and-a-bit-of-history" aria-labelledby="overview-of-gdbmss-and-a-bit-of-history"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Overview of GDBMSs and a Bit of History </h2> <p>In one sentence, GDBMSs are read-optimized analytical DBMSs for modeling and querying application data as a graph. As a consequence they are optimized for fast querying of node and relationship records. Modern GDBMSs, such as Neo4j, Tigergraph, MemGraph, or K√πzu, adopt the <a href="https://neo4j.com/developer/graph-database/#property-graph">property graph data model</a> (or its variants), where you can model your records as a set of labeled nodes and edges/relationships, and key-value properties on these relationships. When I say GDBMSs in this post, I specifically refer to the systems that adopt this model but I will also discuss <a href="https://en.wikipedia.org/wiki/Triplestore">RDF systems</a> (aka triplestores) here and there, which are also DBMSs that adopt a graph-based model.</p> <p>Here‚Äôs a side comment that I have to make because I‚Äôm a professor and professors are always ready to profess. DBMSs based on graph models are anything but new. They have existed even before the relational model: DBMS die-hards love remembering that the <a href="https://en.wikipedia.org/wiki/Integrated_Data_Store">IDS system</a> from 1960s was based on the ‚Äúnetwork model‚Äù, which is is just another term for graph. IDS was lead by the amazing Charlie Bachmann <img src="https://kuzudb.com/img/bachmann.png"/> (<a href="https://amturing.acm.org/award_winners/bachman_9385610.cfm">1</a>, <a href="https://youtu.be/iDVsNqFEkB0">2</a>, <a href="https://youtu.be/jByIpJNrm50">3</a>), whose photo is shown on the left and who is credited for inventing DBMSs<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" rel="footnote">1</a></sup>. If you click on <a href="http://wp.sigmod.org/wp-content/uploads/2012/12/image4.jpg">this 1962 ad of the IDS system</a>, you will see a graph of node and edge records. Note 1960s are pre-relational times. Ever since, every decade has seen a surge of DBMSs that adopted a graph-based model with mixed levels of adoption success: hierarchical model, XML, and RDF are examples. In my view, current property GDBMSs is the most generic and suitable to model a very broad range of application data out of these. So they probably established themselves most successfully out of these. There is a very fundamental reason why graph-based DBMSs have always existed and will always exist: graphs and tables are the two most natural and generic abstract data structures to model application data. It‚Äôs no surprise they were the first two proposed data models when the field of DBMSs were born and both have existed ever since and will continue to exist.</p> <p>Back to property GDBMSs. How about their query languages? They support SQL-like high-level query languages with several graph-specific syntax. I call them ‚Äúgraph-specific‚Äù SQL. Let‚Äôs look at a query snippet. Assume this is on a database that models a set of financial ‚Äúaccounts‚Äù and money ‚Äútransfers‚Äù between accounts:</p> <div><div><pre><code>MATCH (a:Account)-[e:Transfer]-&gt;(b:Account)
WHERE a.name = &#39;Alice&#39;
RETURN b.ID
</code></pre></div></div> <p>This is a query expressed in Cypher. Instead of a SELECT/FROM/WHERE, you are looking at MATCH/WHERE/RETURN. If intelligent Martians saw Cypher and SQL, their immediate reaction would not be to notice the minor syntactic differences but instead the fundamental similarities: their clauses describe joins, filters, projections, group by and aggregates, and other relational operations that process sets of tuples. There is of course syntactic differences that are important. Query languages of GDBMSs adopt graph-specific syntax that are often very elegant to express several computations. For example, the arrow syntax ((a)-[e]-&gt;(b)) in Cypher describes joins between node records. This is much more elegant than listing names of tables that model node records in a FROM clause, with a complex WHERE clause. Much more importantly, they adopt a very elegant and direct syntax, such as the Kleene star ‚Äú*‚Äù, to express recursive queries. Expressing recursive computations with vanilla SQL is objectively harder. I‚Äôll come to recursive queries later.</p> <p>Now get ready for a blasphemous observation: <em>GDBMSs are relational at their cores!</em><sup id="fnref:2" role="doc-noteref"><a href="#fn:2" rel="footnote">2</a></sup>. Well, OK anyone who has studied the principles of DBMSs knows there is nothing blasphemous here because GDBMSs actually have to be relational because of this simple fact: <em>the only known practical way to implement declarative high-level query languages is to compile them to relational operators that take in and output sets of tuples</em>. Type ‚ÄúExplain‚Äù to any of your queries in your favorite GDBMs (or RDF system) and look at their query plans and you will see joins, scans, filters, projections, group bys, unions, intersections, etc. You might see some graph-specific operators but they will also be processing sets of tuples. That was the primary observation of <a href="https://en.wikipedia.org/wiki/Edgar_F._Codd">Ted Codd</a> when he proposed that data management should be done by systems implementing relational operators that process sets of tuples.</p> <p>But don‚Äôt worry, I do love GDBMSs and you should too! The fact that at their cores GDBMSs are relational doesn‚Äôt mean they don‚Äôt offer value beyond RDBMSs. DBMSs are very complex software systems and they make a ton of design tradeoffs in terms of what they optimize for. There is a very distinctive set of technical features that GDBMSs should optimize for and excel in, where RDBMSs and SQL traditionally don‚Äôt. This feature set is exactly what K√πzu aims to perfect over time, which is what I hope to articulate in this post. In short: GDBMSs do offer a ton of value if they are architected correctly and every software engineer should know about GDBMSs<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" rel="footnote">3</a></sup>.</p> <h2 id="features-every-competent-gdbms-should-optimize-for-"> <a href="#features-every-competent-gdbms-should-optimize-for-" aria-labelledby="features-every-competent-gdbms-should-optimize-for-"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Features Every Competent GDBMS Should Optimize For <sup id="fnref:4" role="doc-noteref"><a href="#fn:4" rel="footnote">4</a></sup> </h2> <p>Here is a list of features that differentiate GDBMSs from RDBMSs and GDBMS should highly optimize for and support.</p> <h3 id="feature-1-pre-definedpointer-based-joins"> <a href="#feature-1-pre-definedpointer-based-joins" aria-labelledby="feature-1-pre-definedpointer-based-joins"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Feature 1: Pre-defined/pointer-based Joins </h3> <p>This is perhaps the most ubiquitously adopted technique in GDBMSs that is ubiquitously missing in RDBMSs. Although GDBMSs can join arbitrary node records with each other, most common user queries in GDBMSs join node records with their ‚Äúneighbors‚Äù. A GDBMS knows about these neighbor node records because they are predefined to the system as relationships. So GDBMSs universally exploit this and optimize for these types of joins. For example, almost universally they all create a <strong>join index</strong> (aka an adjacency list index)<sup id="fnref:5" role="doc-noteref"><a href="#fn:5" rel="footnote">5</a></sup>. Here‚Äôs a demonstrative example showing a ‚Äúforward‚Äù, i.e., from src to dst, join index:</p> <p> <img src="https://kuzudb.com/img/ex-fwd-join-index.png" width="800"/> </p> <p>Note that the join index does not store the actual data values, which are strings (e.g., ‚ÄúAli‚Äù, ‚ÄúNoura‚Äù, etc.) in the example. Instead, it stores dense system level node record IDs. As a result, GDBMSs to be fast on these joins because they can use: (1) the join index; and (2) dense integer IDs to joins (instead of, say running string equality conditions).</p> <h3 id="feature-2-many-to-many-growing-joins"> <a href="#feature-2-many-to-many-growing-joins" aria-labelledby="feature-2-many-to-many-growing-joins"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Feature 2: Many-to-many Growing Joins </h3> <p>In many application data stored on GDBMSs, node records have many-to-many relationships with each other. Think of any data as a graph, say a network of financial transactions or who bought which items or who is friends with whom. In many of these datasets, an entity/node connects with many other nodes. In addition, many of the killer apps of GDBMSs search for complex patterns on these relationships. A classic example we like using is a Twitter friend recommendation engine that is looking for diamond patterns to implement the following rule: If a user A follows two users B and C, who both follow D, recommend D to A. This is the pattern:</p> <p> <img src="https://kuzudb.com/img/diamond-pattern.png" width="200"/> </p> <p>The whitepapers of existing GDBMSs are full of these patterns, e.g., branching trees, money laundering circles, cliques of customers who buy similar items, etc. These correspond to complex many-to-many joins, which by their nature are growing. If on average each of your nodes connect with k other nodes and you have t many relationships in the pattern you are searching, you are asking a system to search through k^t many possible combinations and guess what: exponential functions are scary. We have been advocating the integration of 2 specific techniques into the query processors of GDBMSs for several years now: (i) factorization; and (ii) worst-case optimal joins. Both of these techniques are specifically designed for many-to-many growing joins and we have integrated them in K√πzu. Stay tuned for for my next two posts on this.</p> <h3 id="feature-3-recursive-join-queries"> <a href="#feature-3-recursive-join-queries" aria-labelledby="feature-3-recursive-join-queries"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Feature 3: Recursive Join Queries </h3> <p>This is probably the most obvious feature where GDBMSs should excel in. First, objectively the query languages of GDBMSs have much better support for recursive join queries than SQL. Consider this query on our previous financial transaction network example: ‚ÄúGive me all direct or indirect money flows into Alice‚Äôs account from Canada.‚Äù Now look at this elegant way to ask this in Cypher using the Kleene star ‚Äò*‚Äô:</p> <div><div><pre><code>MATCH (a:Account)-[:Transfer*]-&gt;(b:Account)
WHERE a.country = &#39;Canada&#39; and b.name = &#39;Alice&#39;
RETURN a.ID
</code></pre></div></div> <p>Similar to regexes, ‚Äò*‚Äô represents possible 1 or more repetitions of the Transfer edge in the join. So the join could be a direct join between (a) and (b) or a 2-hop one, or a 3-hop one etc. You can do this with SQL of course, but it‚Äôs objectively harder. Recursion has been an afterthought when standardizing SQL. It came 20 years after SQL standardization started and is really a hack. In contrast, recursion has been first-class citizen feature in every graph-based DBMS‚Äôs query language. This distinction is even much more visible if you want to do other graph-specific recursive computation, such as finding shortest paths. In K√πzu, we are starting to work on implementing and optimizing recursive query support and we hope to have first a basic version and then optimized versions that hopefully works very well and contributes to the principles of how these queries should be evaluated.</p> <h3 id="feature-4-schema-querying"> <a href="#feature-4-schema-querying" aria-labelledby="feature-4-schema-querying"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Feature 4: Schema Querying </h3> <p>Another important feature of GDBMSs that cannot be done in RDBMSs is that the query languages allow querying the schema of a database in addition to the data in the database. Suppose in a modified financial transaction network, there are three relationship types: Wire, Deposit, and ETransfer and you you wanted to search for a path where the first edge and the second edge types are different. Note that the predicate is <em>on the schema</em>, specifically on the type of the nodes/relations. You can write the following query:</p> <div><div><pre><code>MATCH (a:Account)-[e1]-&gt;(b:Account)-[e2]-&gt;(c:Account)
WHERE type(e1) != type(e2)
RETURN *
</code></pre></div></div> <p>Something akin to this cannot directly be done in SQL. One would have to write a query that unions many sub-queries: one that joins node records over Wire and then Deposit, another on Wire and ETransfer, another on Deposit and then Wire etc. This will be messy. The ability to <em>not</em> specify a label on relationships, specifically on e1 and e2, is an elegant way to effectively express such unions of join queries. It says: ‚Äújoin a and b nodes over every possible relationship‚Äù. The <code>type()</code> function on these variables allows doing querying over the schema.</p> <h3 id="feature-5-semi-structured-data-and-uri-heavy-datasets-eg-knowledge-graphs"> <a href="#feature-5-semi-structured-data-and-uri-heavy-datasets-eg-knowledge-graphs" aria-labelledby="feature-5-semi-structured-data-and-uri-heavy-datasets-eg-knowledge-graphs"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Feature 5: Semi-structured Data and URI-heavy Datasets (e.g., ‚ÄúKnowledge Graphs‚Äù) </h3> <p>An important application domain of GDBMSs is ‚Äúknowledge graphs‚Äù. This term means different things in different contexts and I‚Äôll take it to refer to highly heterogenous datasets that are often naturally modeled as RDF triples. Again, I don‚Äôt want to go into the details of this model but I assume many readers will already be familiar with RDF. RDF is a simple data model where data is represented as (subject, predicate, object) triples that represent facts about a domain. A great application is when modeling and querying encyclopedic facts, such as those extracted from Wikipedia data. For example, the following triple stores the fact that Justin Trudeau is married to Sophie Trudeau: (http://dbpedia.org/resource/Justin_Trudeau, http://dbpedia.org/ontology/spouse, http://dbpedia.org/resource/Sophie_Gr√©goire_Trudeau). There are 2 immediate challenges for a DBMS to manage such data:</p> <ol> <li> <p>Structuring such datasets is very difficult. Structuring here refers to designing a relational schema for the data. Entities can have many types, e.g., Justin Trudeau is both a ‚Äúrdf:type‚Äù http://dbpedia.org/ontology/Person as well as http://dbpedia.org/ontology/Politician. Further, within a single type, entities can have many different and distinct properties, so good luck coming up with and maintaining a relational schema for all that. This is a direct result of the overly ambitious domain the dataset is modeling: all encyclopedic human knowledge! You need a data model that allows flexibility in what can be associated with entities and their types<sup id="fnref:6" role="doc-noteref"><a href="#fn:6" rel="footnote">6</a></sup>.</p> </li> <li> <p>Those long strings used to identify entities, e.g., Justin Trudea, are called URIs (for universal resource identifiers), and queries will frequently access and specify them. So systems should be competent in handling those.</p> </li> </ol> <p>GDBMSs tend to support semi-structured schemas and certainly RDF systems have good techniques to handle URIs. These applications are directly in the realm of graph-based DBMSs. Currently, they are directly targeted by RDF systems but I‚Äôm convinced GDBMSs should also implement techniques to efficiently support them<sup id="fnref:7" role="doc-noteref"><a href="#fn:7" rel="footnote">7</a></sup>.</p> <p><strong>Final note on the above feature set:</strong> I referred to several classic applications but many other applications require and benefit from the above feature set. One can think of the dataset and workloads of these applications as the ‚Äúbeyond relational/SQL‚Äù datasets/workloads, which often require modeling and querying in a graph-based DBMS, and we want K√πzu to excel in and represent the state-of-art in this feature set!</p> <h2 id="k√πzu-as-a-gdbms-for-graph-data-science-pipelines"> <a href="#k√πzu-as-a-gdbms-for-graph-data-science-pipelines" aria-labelledby="k√πzu-as-a-gdbms-for-graph-data-science-pipelines"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> K√πzu as a GDBMS for Graph Data Science Pipelines </h2> <p>Finally, let me tell you a little bit about a particular application domain we are currently excited about and we want to see K√πzu used in: graph data science in the python ecosystem! This figure from my CIDR slides describes this vision pictorially:</p> <p> <img src="https://kuzudb.com/img/kuzu-as-gdbms-of-gds.png" width="600"/> </p> <p>Suppose you are building a graph analytics, machine learning, or visualization pipeline from raw record files on disk. You will want to model your raw records as nodes and edges, clean them, extract features, query them, transform them, and then you will extract data to an upstream python library, such as Pytorch Geometric, DGL, NetworkX or a graph visualization library. You might even want a pipeline that extracts regular tables from your graphs to a tabular data science library, such as NumPy, since the outputs of queries in Cypher are tables of records. We want people to use K√πzu as an embeddable library in their Python scripts, to do their modeling, querying, feature extraction, cleaning, and other transformations, all by benefiting from a high-level query language and state-of-art graph data management techniques that we are implementing. This is exactly what DuckDB did for tabular data science/analytics. We are looking at DuckDB here and want to fill the same gap for graph data science/analytics! We are currently understanding the ecosystem better and appreciate feedback and suggestions for features we should implement to enable your workloads.</p> <p>OK, this is it for now. In the next two blog posts, I will discuss factorization and worst-case optimal join algorithms and describe some of the principles that we adopted in K√πzu‚Äôs query processor. Until then, happy new years from the cold but cozy winter of üá®üá¶ and <a href="https://github.com/kuzudb/kuzu">pip install kuzu</a>!</p>  </div></div>
  </body>
</html>
