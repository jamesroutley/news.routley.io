<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://cloud.google.com/blog/products/containers-kubernetes/how-we-built-a-130000-node-gke-cluster/">Original</a>
    <h1>Building the largest known Kubernetes cluster</h1>
    
    <div id="readability-page-1" class="page"><div jsname="tx2NYc"><section><div jsaction="rcuQ6b:npT2md" jscontroller="M0Q3Qb" data-is-cws-richtext="true"><p><span>At Google Cloud, we’re constantly pushing the scalability of </span><strong>Google Kubernetes Engine (GKE)</strong><span> so that it can keep up with increasingly demanding workloads — especially AI. GKE already </span><a href="https://cloud.google.com/blog/products/containers-kubernetes/gke-65k-nodes-and-counting"><span>supports massive </span><strong>65,000-node clusters</strong></a><span>, and at KubeCon, we shared that we successfully ran a </span><strong>130,000-node cluster in experimental mode</strong><span> — twice the number of nodes compared to the officially supported and tested limit. </span></p>
<p><span>This kind of scaling isn&#39;t just about increasing the sheer number of nodes; it also requires scaling other critical dimensions, such as </span><strong>Pod creation </strong><span>and</span><strong> scheduling throughput</strong><span>. For instance, during this test, we sustained Pod throughput of </span><strong>1,000 Pods per second</strong><span>, as well as storing over </span><strong>1 million objects</strong><span> in our optimized distributed storage. In this blog, we take a look at the trends driving demand for these kinds of mega-clusters, and do a deep dive on the architectural innovations we implemented to make this extreme scalability a reality. </span></p>
<h3><span>The rise of the mega cluster</span></h3>
<p><span>Our largest customers are actively pushing the boundaries of GKE’s scalability and performance with their AI workloads. In fact, we already have numerous customers operating clusters in the 20-65K node range, and we anticipate the demand for large clusters to stabilize around the 100K node mark. </span></p>
<p><span>This sets up an interesting dynamic. In short, we are transitioning from a world constrained by chip supply to a world constrained by electrical power. Consider the fact that a single NVIDIA GB200 GPU needs 2700W of power. With tens of thousands, or even more, of these chips, a single cluster&#39;s power footprint could easily scale to hundreds of megawatts — ideally distributed across multiple data centers. Thus, for AI platforms exceeding 100K nodes, we’ll need robust multi-cluster solutions that can orchestrate distributed training or reinforcement learning across clusters and data centers. This is a significant challenge, and we’re actively investing in tools like</span><a href="https://kueue.sigs.k8s.io/docs/concepts/multikueue/" rel="noopener" target="_blank"><span> </span><span>MultiKueue</span></a><span> to address it, with further innovations on the horizon. We are also advancing high-performance RDMA networking with the recently announced </span><a href="https://cloud.google.com/blog/products/networking/introducing-managed-dranet-in-google-kubernetes-engine"><span>managed DRANET</span></a><span>, improving topology awareness to maximize performance for massive AI workloads. Stay tuned.</span></p>
<p><span>At the same time, these investments also benefit users who operate at more modest scales — the vast majority of GKE customers. By hardening GKE&#39;s core systems for extreme usage, we create substantial headroom for average clusters, making them more resilient to errors, increasing tolerance for user misuse of the Kubernetes API, and generally optimizing all controllers for faster performance. And of course, all GKE customers, large and small, benefit from investments in an intuitive, self-service experience.</span></p>
<h2><strong>Key architectural innovations</strong></h2>
<p><span>With that said, achieving this level of scale requires significant innovations throughout the Kubernetes ecosystem, including control plane, custom scheduling and storage. Let’s take a look at a few key areas that were critical to this project.</span></p>
<h3><strong>Optimized read scalability</strong></h3>
<p><span>When operating at scale, there’s a need for a strongly consistent and snapshottable API server watch cache. At 130,000 nodes, the sheer volume of read requests to the API server can overwhelm the central object datastore. To solve this, Kubernetes includes several complementary features to offload these read requests from the central object datastore.</span></p>
<p><span>First, the Consistent Reads from Cache feature (KEP-2340), detailed in </span><a href="https://kubernetes.io/blog/2024/08/15/consistent-read-from-cache-beta/" rel="noopener" target="_blank"><span>here</span></a><span>, enables the API server to serve strongly consistent data directly from its in-memory cache. This drastically reduces the load on the object storage database for common read patterns such as filtered list requests (e.g., &#34;all Pods on a specific node&#34;), by ensuring the cache&#39;s data is verifiably up-to-date before it serves the request.</span></p>
<p><span>Building on this foundation, the Snapshottable API Server Cache feature (KEP-4988) further enhances performance by allowing the API server to serve LIST requests for previous states (via pagination or by specifying </span><code>resourceVersion</code><span>) directly from that same consistent watch cache. By generating a B-tree &#34;snapshot&#34; of the cache at a specific resource version, the API server can efficiently handle subsequent LIST requests without repeatedly querying the datastore.</span></p>
<p><span>Together, these two enhancements address the problem of read amplification, ensuring the API server remains fast and responsive by serving both strongly consistent filtered reads and list requests of previous states directly from memory. This is essential for maintaining cluster-wide component health at extreme scale.</span></p>
<h3><strong>An optimized distributed storage backend</strong></h3>
<p><span>To support the cluster’s massive scale, we relied on a proprietary key-value store based on Google’s Spanner distributed database. At 130K nodes, we required 13,000 QPS to update lease objects, ensuring that critical cluster operations such as node health checks didn’t become a bottleneck, and providing the stability needed for the entire system to operate reliably. We didn’t witness any bottlenecks with respect to the new storage system and it showed no signs of it not being able to support higher scales.</span></p>
<h3><strong>Kueue for advanced job queueing</strong></h3>
<p><span>The default Kubernetes scheduler is designed to schedule individual Pods, but complex AI/ML environments require more sophisticated, job-level management. </span><a href="https://kueue.sigs.k8s.io/" rel="noopener" target="_blank"><span>Kueue</span></a><span> is a job queueing controller that brings batch system capabilities to Kubernetes. It decides *when* a job should be admitted based on fair-sharing policies, priorities, and resource quotas, and enables &#34;all-or-nothing&#34; scheduling for entire jobs. Built on top of the default scheduler, Kueue provided the orchestration necessary to manage the complex mix of competing training, batch, and inference workloads in our benchmark.</span></p>
<h3><strong>Future of scheduling: Enhanced workload awareness</strong></h3>
<p><span>Beyond Kueue&#39;s job-level queueing, the Kubernetes ecosystem is evolving towards workload-aware scheduling in its core. The goal is to move from a Pod-centric to a workload-centric approach to scheduling. This means the scheduler will make placement decisions considering the entire workload&#39;s needs as a single unit, encompassing both available and potential capacity. This holistic view is crucial for optimizing price-performance, especially for the new wave of AI/ML training and inference workloads.</span></p>
<p><span>A key aspect of the emerging kubernetes scheduler is the native implementation of gang scheduling semantics within Kubernetes, a feature currently provided by add-ons like Kueue. The community is actively working on this through </span><a href="https://github.com/kubernetes/enhancements/tree/master/keps/sig-scheduling/4671-gang-scheduling" rel="noopener" target="_blank"><span>KEP-4671: Gang Scheduling</span></a><span>.</span></p>
<p><span>In time, support for workload-aware scheduling in core Kubernetes will simplify orchestrating large-scale, tightly coupled applications on GKE, making the platform even more powerful for demanding AI/ML and HPC use cases. We’re also working on integrating Kueue as a second-level scheduler within GKE.</span></p>
<h3><strong>GCS FUSE for data access</strong></h3>
<p><span>AI workloads need to be able to access data efficiently. Together, </span><a href="https://cloud.google.com/kubernetes-engine/docs/how-to/persistent-volumes/cloud-storage-fuse-csi-driver"><span>Cloud Storage FUSE</span></a><span> with parallel downloads and </span><a href="https://cloud.google.com/kubernetes-engine/docs/how-to/cloud-storage-fuse-csi-driver-perf#enable-and-use-file-caching"><span>caching</span></a><span> enabled and paired with the zonal </span><a href="https://cloud.google.com/storage/docs/anywhere-cache"><span>Anywhere Cache</span></a><span>, allowing access to model data in Cloud Storage buckets as if it were a local file system, reducing latency up to 70%. This provides a scalable, high-throughput mechanism for feeding data to distributed jobs or scale-out inference workflows. Alternatively, there’s </span><a href="https://cloud.google.com/managed-lustre/docs/overview"><span>Google Cloud Managed Lustre</span></a><span>, a fully managed persistent zonal storage solution that supports workloads that need multi-petabyte capacity, TB/s throughput, and sub-millisecond latency. You can learn more about your storage options for AI/ML workloads </span><a href="https://cloud.google.com/architecture/ai-ml/storage-for-ai-ml"><span>here</span></a><span>.</span></p>
<h2><span>Benchmarking GKE for large-scale, dynamic AI workloads</span></h2>
<p><span>To validate GKE&#39;s performance with large-scale AI/ML workloads, we designed a four-phase benchmark simulating a dynamic environment with complex resource management, prioritization, and scheduling challenges. This builds on the benchmark used in </span><a href="https://cloud.google.com/blog/products/containers-kubernetes/benchmarking-a-65000-node-gke-cluster-with-ai-workloads"><span>the previous 65K node scale test</span></a><span>.</span></p>
<p><span>We upgraded the benchmark to represent a typical AI platform that hosts mixed workloads, using workloads with distinct priority classes:</span></p>
<ul>
<li>
<p><strong>Low Priority:</strong><span> Preemptible batch processing, such as data preparation jobs.</span></p>
</li>
<li>
<p><strong>Medium Priority:</strong><span> Core model training jobs that are important but can tolerate some queuing.</span></p>
</li>
<li>
<p><strong>High Priority:</strong><span> Latency-sensitive, user-facing inference services that must have resources guaranteed.</span></p>
</li>
</ul>
<p><span>We orchestrated the process using Kueue to manage quotas and resource sharing, and JobSet to manage training jobs.</span></p>
<h4><strong>Phase 1: Establishing a performance baseline with a large training job</strong></h4>
<p><span>To begin, we measure the cluster&#39;s foundational performance by scheduling a single, large-scale training workload. We deploy one </span><code>JobSet</code><span> configured to run </span><strong>130,000 medium-priority Pods</strong><span> simultaneously. This initial test allows us to establish a baseline for key metrics like Pod startup latency and overall scheduling throughput, revealing the overhead of launching a substantial workload on a clean cluster. This set the stage for evaluating GKE&#39;s performance under more complex conditions. After execution, we removed this JobSet from the cluster, leaving an empty cluster for Phase 2.</span></p></div></section><section><div><section><figure><section jscontroller="SCGBie" jsaction="rcuQ6b:npT2md"><img src="https://storage.googleapis.com/gweb-cloudblog-publish/images/1_Phase_1__Establishing_a_performance_base.max-1300x1300.png" alt="https://storage.googleapis.com/gweb-cloudblog-publish/images/1_Phase_1__Establishing_a_performance_base.max-1300x1300.png" jsname="P3Vluc" jsaction="click:HTIlC" loading="lazy"/><section role="dialog" aria-modal="true"><img src="https://storage.googleapis.com/gweb-cloudblog-publish/images/1_Phase_1__Establishing_a_performance_base.max-1300x1300.png" alt="https://storage.googleapis.com/gweb-cloudblog-publish/images/1_Phase_1__Establishing_a_performance_base.max-1300x1300.png" jsname="P3Vluc" jsaction="click:HTIlC" loading="lazy"/></section></section></figure><div><p>Figure 1: Phase 1: Establishing a performance baseline by deploying a massive pre-training workload of 130,000 Pods on a clean cluster.</p></div></section></div></section><section><div jsaction="rcuQ6b:npT2md" jscontroller="M0Q3Qb" data-is-cws-richtext="true"><h4><strong>Phase 2: Simulating a realistic mixed-workload environment</strong></h4>
<p><span>Next, we introduced resource contention to simulate a typical MLOps environment. At first, we deployed </span><strong>650 low-priority batch </strong><strong>Jobs</strong><span> (totaling 65,000 Pods), filling up half of the capacity of the cluster’s 130K nodes.</span></p></div></section><section><div><section><figure><section jscontroller="SCGBie" jsaction="rcuQ6b:npT2md"><img src="https://storage.googleapis.com/gweb-cloudblog-publish/images/2_Phase_2__Simulating_a_realistic_MLOps_en.max-1300x1300.png" alt="https://storage.googleapis.com/gweb-cloudblog-publish/images/2_Phase_2__Simulating_a_realistic_MLOps_en.max-1300x1300.png" jsname="P3Vluc" jsaction="click:HTIlC" loading="lazy"/><section role="dialog" aria-modal="true"><img src="https://storage.googleapis.com/gweb-cloudblog-publish/images/2_Phase_2__Simulating_a_realistic_MLOps_en.max-1300x1300.png" alt="https://storage.googleapis.com/gweb-cloudblog-publish/images/2_Phase_2__Simulating_a_realistic_MLOps_en.max-1300x1300.png" jsname="P3Vluc" jsaction="click:HTIlC" loading="lazy"/></section></section></figure><div><p>Figure 2: Phase 2: Simulating a realistic MLOps environment by introducing 65,000 low-priority batch job Pods to fill 50% of cluster capacity.</p></div></section></div></section><section><p><span>Then we introduced </span><strong>8 large, medium-priority fine-tuning </strong><strong>Jobs</strong><span> (totaling 104,000 Pods), taking 80% of the cluster capacity, and preempting 60% of the batch workloads (which represents 30% of total cluster capacity). This phase tested GKE’s ability to manage mixed workloads, as well preemption within a mixed workloads environment. In this scenario, we observed Kueue in action, preempting existing workload and gang-scheduling a large number of batch jobs all at once to allow for fine-tuning jobs to be scheduled. This highlighted Kueue&#39;s advantage over kube-scheduler: preemption happens much faster, and switching between workloads is almost instantaneous.</span></p></section><section><div><section><figure><section jscontroller="SCGBie" jsaction="rcuQ6b:npT2md"><img src="https://storage.googleapis.com/gweb-cloudblog-publish/images/3_Kueue_in_Action__Preempting_low-priority.max-1300x1300.png" alt="https://storage.googleapis.com/gweb-cloudblog-publish/images/3_Kueue_in_Action__Preempting_low-priority.max-1300x1300.png" jsname="P3Vluc" jsaction="click:HTIlC" loading="lazy"/><section role="dialog" aria-modal="true"><img src="https://storage.googleapis.com/gweb-cloudblog-publish/images/3_Kueue_in_Action__Preempting_low-priority.max-1300x1300.png" alt="https://storage.googleapis.com/gweb-cloudblog-publish/images/3_Kueue_in_Action__Preempting_low-priority.max-1300x1300.png" jsname="P3Vluc" jsaction="click:HTIlC" loading="lazy"/></section></section></figure><div><p>Figure 3: Kueue in action: Preempting low-priority batch workloads to accommodate 104,000 Pods for higher-priority fine-tuning jobs.</p></div></section></div></section><section><div jsaction="rcuQ6b:npT2md" jscontroller="M0Q3Qb" data-is-cws-richtext="true"><p><strong>Phase 3: Prioritizing and scaling a latency-sensitive inference service</strong></p>
<p><span>In this phase, we simulated the arrival of a critical inference service by deploying a high-priority </span><code>Job</code><span>, totalling 26K Pods, or 20% of the capacity. To accommodate it, Kueue </span><strong>preempted the remaining low-priority batch jobs</strong><span>.</span></p></div></section><section><div><section><figure><section jscontroller="SCGBie" jsaction="rcuQ6b:npT2md"><img src="https://storage.googleapis.com/gweb-cloudblog-publish/images/4_Phase_3__Prioritizing_a_critical_latency.max-1200x1200.png" alt="https://storage.googleapis.com/gweb-cloudblog-publish/images/4_Phase_3__Prioritizing_a_critical_latency.max-1200x1200.png" jsname="P3Vluc" jsaction="click:HTIlC" loading="lazy"/><section role="dialog" aria-modal="true"><img src="https://storage.googleapis.com/gweb-cloudblog-publish/images/4_Phase_3__Prioritizing_a_critical_latency.max-1200x1200.png" alt="https://storage.googleapis.com/gweb-cloudblog-publish/images/4_Phase_3__Prioritizing_a_critical_latency.max-1200x1200.png" jsname="P3Vluc" jsaction="click:HTIlC" loading="lazy"/></section></section></figure><div><p>Figure 4: Phase 3: Prioritizing a critical, latency-sensitive inference service (26,000 Pods) by preempting the remaining of lower-priority batch jobs.</p></div></section></div></section><section><p><span>We then scaled the inference workload to simulate a spike in traffic, first, preempting part of the medium-priority fine-tuning jobs. The inference workload scaled up to a total of </span><strong>52,000 Pods,</strong><span> representing 40% of the capacity. Once fully scaled, we ran a 10-minute traffic simulation to measure performance under load.</span></p></section><section><div><section><figure><section jscontroller="SCGBie" jsaction="rcuQ6b:npT2md"><img src="https://storage.googleapis.com/gweb-cloudblog-publish/images/5_Simulating_a_traffic_spike__Scaling_the_.max-1200x1200.png" alt="https://storage.googleapis.com/gweb-cloudblog-publish/images/5_Simulating_a_traffic_spike__Scaling_the_.max-1200x1200.png" jsname="P3Vluc" jsaction="click:HTIlC" loading="lazy"/><section role="dialog" aria-modal="true"><img src="https://storage.googleapis.com/gweb-cloudblog-publish/images/5_Simulating_a_traffic_spike__Scaling_the_.max-1200x1200.png" alt="https://storage.googleapis.com/gweb-cloudblog-publish/images/5_Simulating_a_traffic_spike__Scaling_the_.max-1200x1200.png" jsname="P3Vluc" jsaction="click:HTIlC" loading="lazy"/></section></section></figure><div><p>Figure 5: Simulating a traffic spike. Scaling the inference workload to 52,000 Pods (40% capacity) triggers partial preemption of fine-tuning jobs.</p></div></section></div></section><section><div jsaction="rcuQ6b:npT2md" jscontroller="M0Q3Qb" data-is-cws-richtext="true"><h4><strong>Phase 4: Validating cluster elasticity and resource recovery</strong></h4>
<p><span>Finally, we evaluated the cluster&#39;s ability to efficiently recover and reallocate resources once peak demand was over. We </span><strong>scaled down the high-priority inference workload by 50%</strong><span>, returning to its original initial phase. This demonstrated GKE’s elasticity, ensuring that valuable compute resources were not left idle as workload demands change, thereby maximizing utilization and cost-efficiency. Again, Kueue took care of admitting back the preempted fine-tuning workloads that were waiting in the cluster queue.</span></p></div></section><section><div><section><figure><section jscontroller="SCGBie" jsaction="rcuQ6b:npT2md"><img src="https://storage.googleapis.com/gweb-cloudblog-publish/images/6_Phase_4__Demonstrating_cluster_elasticit.max-1200x1200.png" alt="https://storage.googleapis.com/gweb-cloudblog-publish/images/6_Phase_4__Demonstrating_cluster_elasticit.max-1200x1200.png" jsname="P3Vluc" jsaction="click:HTIlC" loading="lazy"/><section role="dialog" aria-modal="true"><img src="https://storage.googleapis.com/gweb-cloudblog-publish/images/6_Phase_4__Demonstrating_cluster_elasticit.max-1200x1200.png" alt="https://storage.googleapis.com/gweb-cloudblog-publish/images/6_Phase_4__Demonstrating_cluster_elasticit.max-1200x1200.png" jsname="P3Vluc" jsaction="click:HTIlC" loading="lazy"/></section></section></figure><div><p>Figure 6: Phase 4: Demonstrating cluster elasticity by scaling down the inference workload and automatically recovering resources for pending fine-tuning jobs.</p></div></section></div></section><section><div jsaction="rcuQ6b:npT2md" jscontroller="M0Q3Qb" data-is-cws-richtext="true"><p><span>With the benchmark concluded, the resulting data paints a clear picture of how GKE handles extreme-scale pressure. </span></p>
<h3><span>Demonstrating GKE’s scalability across dimensions</span></h3>
<p><span>The four benchmark phases tested multiple performance dimensions. In Phase 1, the cluster scaled to 130,000 Pods in 3 minutes and 40 seconds. In Phase 2, the low-priority batch workloads were created in 81 seconds, an average throughput of around 750 Pods/second. </span></p>
<p><span>Below is a diagram showing the execution timeline of the workload, highlighting the various phases of the benchmark. </span></p></div></section><section><div><section><figure><section jscontroller="SCGBie" jsaction="rcuQ6b:npT2md"><img src="https://storage.googleapis.com/gweb-cloudblog-publish/images/7_Execution_timeline_highlighting_the_four_d.max-800x800.png" alt="https://storage.googleapis.com/gweb-cloudblog-publish/images/7_Execution_timeline_highlighting_the_four_d.max-800x800.png" jsname="P3Vluc" jsaction="click:HTIlC" loading="lazy"/><section role="dialog" aria-modal="true"><img src="https://storage.googleapis.com/gweb-cloudblog-publish/images/7_Execution_timeline_highlighting_the_four_d.max-800x800.png" alt="https://storage.googleapis.com/gweb-cloudblog-publish/images/7_Execution_timeline_highlighting_the_four_d.max-800x800.png" jsname="P3Vluc" jsaction="click:HTIlC" loading="lazy"/></section></section></figure><div><p>Figure 7: Execution timeline highlighting the four distinct phases of the large-scale AI workload benchmark.</p></div></section></div></section><section><p><span>Overall, the benchmark demonstrated GKE&#39;s ability to manage fluctuating demands by preempting lower-priority jobs to make room for critical training and inference services, showcasing the cluster&#39;s elasticity and resource reallocation capabilities.</span></p></section><section><div><section><figure><section jscontroller="SCGBie" jsaction="rcuQ6b:npT2md"><img src="https://storage.googleapis.com/gweb-cloudblog-publish/images/8_Total_number_of_running_workload_pods_ov.max-1600x1600.png" alt="https://storage.googleapis.com/gweb-cloudblog-publish/images/8_Total_number_of_running_workload_pods_ov.max-1600x1600.png" jsname="P3Vluc" jsaction="click:HTIlC" loading="lazy"/><section role="dialog" aria-modal="true"><img src="https://storage.googleapis.com/gweb-cloudblog-publish/images/8_Total_number_of_running_workload_pods_ov.max-1600x1600.png" alt="https://storage.googleapis.com/gweb-cloudblog-publish/images/8_Total_number_of_running_workload_pods_ov.max-1600x1600.png" jsname="P3Vluc" jsaction="click:HTIlC" loading="lazy"/></section></section></figure><div><p>Figure 8: Total number of running workload Pods over time, demonstrating GKE&#39;s ability to maintain high utilization through dynamic preemption and resource reallocation.</p></div></section></div></section><section><div jsaction="rcuQ6b:npT2md" jscontroller="M0Q3Qb" data-is-cws-richtext="true"><h3><span>Intelligent workload management with Kueue</span></h3>
<p><span>For this benchmark, Kueue was a critical component for enabling workload prioritization. In Phase 2, Kueue preempted 60% of the batch workloads (30% of the cluster capacity) to make room for medium-priority jobs, with the remainder preempted in Phase 3 for the high-priority inference workload. This simulation of urgent tasks taking precedence is a common operational scenario, and this large-scale preemption highlights how the combination of GKE and Kueue can dynamically allocate resources to the most critical jobs. At its peak in Phase 2, 39,000 Pods were preempted in 93 seconds. The Pod churn during the preemption of batch workloads and admission and creation of fine-tuning workloads reached a median of 990 and an average of 745 Pods/s, as seen below.</span></p></div></section><section><div><section><figure><section jscontroller="SCGBie" jsaction="rcuQ6b:npT2md"><img src="https://storage.googleapis.com/gweb-cloudblog-publish/images/9_API_request_throughput_during_preemption.max-1500x1500.png" alt="https://storage.googleapis.com/gweb-cloudblog-publish/images/9_API_request_throughput_during_preemption.max-1500x1500.png" jsname="P3Vluc" jsaction="click:HTIlC" loading="lazy"/><section role="dialog" aria-modal="true"><img src="https://storage.googleapis.com/gweb-cloudblog-publish/images/9_API_request_throughput_during_preemption.max-1500x1500.png" alt="https://storage.googleapis.com/gweb-cloudblog-publish/images/9_API_request_throughput_during_preemption.max-1500x1500.png" jsname="P3Vluc" jsaction="click:HTIlC" loading="lazy"/></section></section></figure><div><p>Figure 9: API request throughput during preemption events, showing a mix of POST and DELETE requests averaging Pod churn of 745 Pods per second.</p></div></section></div></section><section><p><span>Checking the status of the admitted vs. evicted workloads from Kueue shows that many batch workloads were initially admitted, only to be preempted later by fine-tuning and later inference workloads.</span></p></section><section><div><section><figure><section jscontroller="SCGBie" jsaction="rcuQ6b:npT2md"><img src="https://storage.googleapis.com/gweb-cloudblog-publish/images/10_Workload_status_over_time_visualizing_t.max-1400x1400.png" alt="https://storage.googleapis.com/gweb-cloudblog-publish/images/10_Workload_status_over_time_visualizing_t.max-1400x1400.png" jsname="P3Vluc" jsaction="click:HTIlC" loading="lazy"/><section role="dialog" aria-modal="true"><img src="https://storage.googleapis.com/gweb-cloudblog-publish/images/10_Workload_status_over_time_visualizing_t.max-1400x1400.png" alt="https://storage.googleapis.com/gweb-cloudblog-publish/images/10_Workload_status_over_time_visualizing_t.max-1400x1400.png" jsname="P3Vluc" jsaction="click:HTIlC" loading="lazy"/></section></section></figure><div><p>Figure 10: Workload status over time, visualizing the volume of jobs admitted versus those preempted (evicted) by Kueue as priorities shifted.</p></div></section></div></section><section><div jsaction="rcuQ6b:npT2md" jscontroller="M0Q3Qb" data-is-cws-richtext="true"><h3><span>Blazing-fast scheduling at 1,000 pods/second</span></h3>
<p><span>The key measure of Kubernetes’ control-plane performance is its ability to create and schedule Pods quickly. Throughout the benchmark, especially during the most intense phases, GKE consistently achieved and sustained a throughput of up to 1,000 operations per second for both Pod creation and Pod binding (the act of scheduling a Pod to a node).</span></p></div></section><section><div><section><figure><section jscontroller="SCGBie" jsaction="rcuQ6b:npT2md"><img src="https://storage.googleapis.com/gweb-cloudblog-publish/images/11_Control_plane_throughput__Sustaining_up.max-1600x1600.png" alt="https://storage.googleapis.com/gweb-cloudblog-publish/images/11_Control_plane_throughput__Sustaining_up.max-1600x1600.png" jsname="P3Vluc" jsaction="click:HTIlC" loading="lazy"/><section role="dialog" aria-modal="true"><img src="https://storage.googleapis.com/gweb-cloudblog-publish/images/11_Control_plane_throughput__Sustaining_up.max-1600x1600.png" alt="https://storage.googleapis.com/gweb-cloudblog-publish/images/11_Control_plane_throughput__Sustaining_up.max-1600x1600.png" jsname="P3Vluc" jsaction="click:HTIlC" loading="lazy"/></section></section></figure><div><p>Figure 11: Control plane throughput: Sustaining up to 1,000 operations per second for both Pod creation and Pod binding during intense scheduling phases.</p></div></section></div></section><section><div><section><figure><section jscontroller="SCGBie" jsaction="rcuQ6b:npT2md"><img src="https://storage.googleapis.com/gweb-cloudblog-publish/images/12_Detailed_Pod_creation_throughput_statis.max-1500x1500.png" alt="https://storage.googleapis.com/gweb-cloudblog-publish/images/12_Detailed_Pod_creation_throughput_statis.max-1500x1500.png" jsname="P3Vluc" jsaction="click:HTIlC" loading="lazy"/><section role="dialog" aria-modal="true"><img src="https://storage.googleapis.com/gweb-cloudblog-publish/images/12_Detailed_Pod_creation_throughput_statis.max-1500x1500.png" alt="https://storage.googleapis.com/gweb-cloudblog-publish/images/12_Detailed_Pod_creation_throughput_statis.max-1500x1500.png" jsname="P3Vluc" jsaction="click:HTIlC" loading="lazy"/></section></section></figure><div><p>Figure 12: Detailed pod-creation throughput statistics (Average, Max, P50, P90, P99) across large pre-training, batch, and fine-tuning workloads.</p></div></section></div></section><section><div jsaction="rcuQ6b:npT2md" jscontroller="M0Q3Qb" data-is-cws-richtext="true"><h3><span>Low pod startup latency</span></h3>
<p><span>At the same time, pod-creation throughput was matched by low Pod-startup latencies across all workload types. For latency-sensitive inference workloads, the 99th percentile (P99) startup time was approximately 10 seconds, ensuring services could scale quickly to meet demand.</span></p></div></section><section><div><section><figure><section jscontroller="SCGBie" jsaction="rcuQ6b:npT2md"><img src="https://storage.googleapis.com/gweb-cloudblog-publish/images/13_Pod_startup_latency_across_workload_typ.max-1300x1300.png" alt="https://storage.googleapis.com/gweb-cloudblog-publish/images/13_Pod_startup_latency_across_workload_typ.max-1300x1300.png" jsname="P3Vluc" jsaction="click:HTIlC" loading="lazy"/><section role="dialog" aria-modal="true"><img src="https://storage.googleapis.com/gweb-cloudblog-publish/images/13_Pod_startup_latency_across_workload_typ.max-1300x1300.png" alt="https://storage.googleapis.com/gweb-cloudblog-publish/images/13_Pod_startup_latency_across_workload_typ.max-1300x1300.png" jsname="P3Vluc" jsaction="click:HTIlC" loading="lazy"/></section></section></figure><div><p>Figure 13: Pod startup latency across workload types.</p></div></section></div></section><section><div jsaction="rcuQ6b:npT2md" jscontroller="M0Q3Qb" data-is-cws-richtext="true"><h3><span>Control plane stability under extreme load</span></h3>
<p><span>GKE’s cluster control plane remained stable throughout the test. The total number of objects in a </span><strong>single database replica</strong><span> exceeded </span><strong>1 million</strong><span> at its peak, while API server latencies for critical operations remained well below their defined thresholds. This confirms that the cluster can remain responsive and manageable even at this scale.</span></p></div></section><section><div><section><figure><section jscontroller="SCGBie" jsaction="rcuQ6b:npT2md"><img src="https://storage.googleapis.com/gweb-cloudblog-publish/images/14_API_Server_latency_for_GET_and_LIST_ope.max-1600x1600.png" alt="https://storage.googleapis.com/gweb-cloudblog-publish/images/14_API_Server_latency_for_GET_and_LIST_ope.max-1600x1600.png" jsname="P3Vluc" jsaction="click:HTIlC" loading="lazy"/><section role="dialog" aria-modal="true"><img src="https://storage.googleapis.com/gweb-cloudblog-publish/images/14_API_Server_latency_for_GET_and_LIST_ope.max-1600x1600.png" alt="https://storage.googleapis.com/gweb-cloudblog-publish/images/14_API_Server_latency_for_GET_and_LIST_ope.max-1600x1600.png" jsname="P3Vluc" jsaction="click:HTIlC" loading="lazy"/></section></section></figure><div><p>Figure 14: API Server latency for GET and LIST operations, remaining stable and well below defined thresholds, and despite the cluster’s massive scale.</p></div></section></div></section><section><div><section><figure><section jscontroller="SCGBie" jsaction="rcuQ6b:npT2md"><img src="https://storage.googleapis.com/gweb-cloudblog-publish/images/15_API_request_duration_broken_down_by_ver.max-1400x1400.png" alt="https://storage.googleapis.com/gweb-cloudblog-publish/images/15_API_request_duration_broken_down_by_ver.max-1400x1400.png" jsname="P3Vluc" jsaction="click:HTIlC" loading="lazy"/><section role="dialog" aria-modal="true"><img src="https://storage.googleapis.com/gweb-cloudblog-publish/images/15_API_request_duration_broken_down_by_ver.max-1400x1400.png" alt="https://storage.googleapis.com/gweb-cloudblog-publish/images/15_API_request_duration_broken_down_by_ver.max-1400x1400.png" jsname="P3Vluc" jsaction="click:HTIlC" loading="lazy"/></section></section></figure><div><p>Figure 15: API request duration broken down by verb (GET, POST, PUT, PATCH, DELETE), confirming consistent response times under load.</p></div></section></div></section><section><div><section><figure><section jscontroller="SCGBie" jsaction="rcuQ6b:npT2md"><img src="https://storage.googleapis.com/gweb-cloudblog-publish/images/16_Duration_for_LIST_operations_specifical.max-1400x1400.png" alt="https://storage.googleapis.com/gweb-cloudblog-publish/images/16_Duration_for_LIST_operations_specifical.max-1400x1400.png" jsname="P3Vluc" jsaction="click:HTIlC" loading="lazy"/><section role="dialog" aria-modal="true"><img src="https://storage.googleapis.com/gweb-cloudblog-publish/images/16_Duration_for_LIST_operations_specifical.max-1400x1400.png" alt="https://storage.googleapis.com/gweb-cloudblog-publish/images/16_Duration_for_LIST_operations_specifical.max-1400x1400.png" jsname="P3Vluc" jsaction="click:HTIlC" loading="lazy"/></section></section></figure><div><p>Figure 16: Duration for LIST operations specifically, remaining stable throughout the benchmark phases.</p></div></section></div></section><section><div><section><figure><section jscontroller="SCGBie" jsaction="rcuQ6b:npT2md"><img src="https://storage.googleapis.com/gweb-cloudblog-publish/images/17_Total_count_of_Kubernetes_objects_inclu.max-1600x1600.png" alt="https://storage.googleapis.com/gweb-cloudblog-publish/images/17_Total_count_of_Kubernetes_objects_inclu.max-1600x1600.png" jsname="P3Vluc" jsaction="click:HTIlC" loading="lazy"/><section role="dialog" aria-modal="true"><img src="https://storage.googleapis.com/gweb-cloudblog-publish/images/17_Total_count_of_Kubernetes_objects_inclu.max-1600x1600.png" alt="https://storage.googleapis.com/gweb-cloudblog-publish/images/17_Total_count_of_Kubernetes_objects_inclu.max-1600x1600.png" jsname="P3Vluc" jsaction="click:HTIlC" loading="lazy"/></section></section></figure><div><p>Figure 17: Total count of Kubernetes objects (including Pods, Leases, and Nodes) in the database, exceeding 1 million objects.</p></div></section></div></section><section><div jsaction="rcuQ6b:npT2md" jscontroller="M0Q3Qb" data-is-cws-richtext="true"><h2><span>Destination: Massive scale</span></h2>
<p><span>All told, this experiment demonstrated that GKE can support AI and ML workloads at a scale well beyond current public limits. Further, the insights we gained from operating at this scale are helping us plan the GKE’s future development.While we don’t yet officially support 130K nodes, we&#39;re very encouraged by these findings. If your workloads require this level of scale, reach out to us to discuss your specific needs! You can also enjoy </span><a href="https://www.thecube.net/events/linux-foundation/kubecon-cloudnativecon-na-2025" rel="noopener" target="_blank"><span>these</span></a><span> wonderful conversations on scale and other topics from KubeCon at Atlanta with Google experts and analysts. </span></p></div></section><section><section><span>Posted in</span><ul><li><a href="https://cloud.google.com/blog/products/containers-kubernetes" track-metadata-position="body" track-metadata-eventdetail="cloud.google.com/blog/products/containers-kubernetes" track-metadata-module="tag list" track-metadata-module_headline="posted in">Containers &amp; Kubernetes</a></li><li><a href="https://cloud.google.com/blog/products/kubernetes-engine" track-metadata-position="body" track-metadata-eventdetail="cloud.google.com/blog/products/kubernetes-engine" track-metadata-module="tag list" track-metadata-module_headline="posted in">GKE</a></li></ul></section></section></div></div>
  </body>
</html>
