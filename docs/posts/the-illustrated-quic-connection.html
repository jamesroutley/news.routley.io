<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://quic.ulfheim.net/">Original</a>
    <h1>The Illustrated QUIC Connection</h1>
    
    <div id="readability-page-1" class="page"><div><p>
    The server now has the information needed to calculate the
    keys used to encrypt Handshake packets.  It uses the following
    information in this calculation:
    </p><ul>
    <li><a href="https://nedbatchelder.com/blog/202102/files/client-ephemeral-public.key">client public key</a> (from Client Hello)
    </li><li><a href="https://nedbatchelder.com/blog/202102/files/server-ephemeral-private.key">server private key</a> (from Server Key Exchange Generation)
    </li><li>SHA256 hash of ClientHello and ServerHello</li>
    </ul><p>
    First, the server finds the shared secret, which is the
    result of the key exchange that allows the client and server
    to agree on a number.  The server multiplies the client&#39;s
    public key by the server&#39;s private key using the curve25519()
    algorithm.  The 32-byte result is found to be:
    </p><pre><tt>df4a291baa1eb7cfa6934b29b474baad2697e29f1f920dcc77c8a0a088447624</tt></pre><p>

    I&#39;ve provided <a href="https://nedbatchelder.com/blog/202102/files/curve25519-mult.c" download="curve25519-mult.c">a tool</a>
    to perform this calculation:
    </p><codesample>
<pre><code>$ cc -o curve25519-mult curve25519-mult.c
$ ./curve25519-mult server-ephemeral-private.key \
                    client-ephemeral-public.key | hexdump

0000000 df 4a 29 1b aa 1e b7 cf a6 93 4b 29 b4 74 ba ad
0000010 26 97 e2 9f 1f 92 0d cc 77 c8 a0 a0 88 44 76 24
</code></pre>
    </codesample><p>

    It then calculates the SHA256 hash of all handshake messages
    to this point (ClientHello and ServerHello).  The hash does
    not include the 6-byte CRYPTO frame headers.  This &#34;hello_hash&#34;
    is </p><tt>ff788f9ed09e60d8142ac10a8931cdb6a3726278d3acdba54d9d9ffc7326611b</tt><p>:
    </p><codesample>
<pre><code>$ cat crypto_clienthello crypto_serverhello | openssl sha256
ff788f9ed09e60d8142ac10a8931cdb6a3726278d3acdba54d9d9ffc7326611b
</code></pre>
    </codesample><p>

    We then feed the hash and the shared secret into a set of
    key derivation operations, designed to protect against known and
    possible attacks:

    </p><processblock>
<pre>early_secret = HKDF-Extract(salt=00, key=00...)
empty_hash = SHA256(&#34;&#34;)
derived_secret = HKDF-Expand-Label(key: early_secret, label: &#34;derived&#34;, ctx: empty_hash, len: 32)
handshake_secret = HKDF-Extract(salt: derived_secret, key: shared_secret)
client_secret = HKDF-Expand-Label(key: handshake_secret, label: &#34;c hs traffic&#34;, ctx: hello_hash, len: 32)
server_secret = HKDF-Expand-Label(key: handshake_secret, label: &#34;s hs traffic&#34;, ctx: hello_hash, len: 32)
client_key = HKDF-Expand-Label(key: client_secret, label: &#34;quic key&#34;, ctx: &#34;&#34;, len: 16)
server_key = HKDF-Expand-Label(key: server_secret, label: &#34;quic key&#34;, ctx: &#34;&#34;, len: 16)
client_iv = HKDF-Expand-Label(key: client_secret, label: &#34;quic iv&#34;, ctx: &#34;&#34;, len: 12)
server_iv = HKDF-Expand-Label(key: server_secret, label: &#34;quic iv&#34;, ctx: &#34;&#34;, len: 12)
</pre>
    </processblock><p>

    I&#39;ve created <a href="https://nedbatchelder.com/blog/202102/files/hkdf.sh" download="hkdf">an HKDF tool</a>
    to perform these operations on the command line.
    The key derivation process is reproduced below:
    </p><codesample>
<pre><code>$ hello_hash=ff788f9ed09e60d8142ac10a8931cdb6a3726278d3acdba54d9d9ffc7326611b
$ shared_secret=df4a291baa1eb7cfa6934b29b474baad2697e29f1f920dcc77c8a0a088447624
$ zero_key=0000000000000000000000000000000000000000000000000000000000000000
$ early_secret=$(./hkdf extract 00 $zero_key)
$ empty_hash=$(openssl sha256 &lt; /dev/null | sed -e &#39;s/.* //&#39;)
$ derived_secret=$(./hkdf expandlabel $early_secret &#34;derived&#34; $empty_hash 32)
$ handshake_secret=$(./hkdf extract $derived_secret $shared_secret)
$ csecret=$(./hkdf expandlabel $handshake_secret &#34;c hs traffic&#34; $hello_hash 32)
$ ssecret=$(./hkdf expandlabel $handshake_secret &#34;s hs traffic&#34; $hello_hash 32)
$ client_handshake_key=$(./hkdf expandlabel $csecret &#34;quic key&#34; &#34;&#34; 16)
$ server_handshake_key=$(./hkdf expandlabel $ssecret &#34;quic key&#34; &#34;&#34; 16)
$ client_handshake_iv=$(./hkdf expandlabel $csecret &#34;quic iv&#34; &#34;&#34; 12)
$ server_handshake_iv=$(./hkdf expandlabel $ssecret &#34;quic iv&#34; &#34;&#34; 12)
$ client_handshake_hp=$(./hkdf expandlabel $csecret &#34;quic hp&#34; &#34;&#34; 16)
$ server_handshake_hp=$(./hkdf expandlabel $ssecret &#34;quic hp&#34; &#34;&#34; 16)
$ echo ckey: $client_handshake_key
$ echo civ: $client_handshake_iv
$ echo chp: $client_handshake_hp
$ echo skey: $server_handshake_key
$ echo siv: $server_handshake_iv
$ echo shp: $server_handshake_hp

ckey: 30a7e816f6a1e1b3434cf39cf4b415e7
civ: 11e70a5d1361795d2bb04465
chp: 84b3c21cacaf9f54c885e9a506459079
skey: 17abbf0a788f96c6986964660414e7ec
siv: 09597a2ea3b04c00487e71f3
shp: 2a18061c396c2828582b41b0910ed536
</code></pre>
    </codesample><p>

    From this we get the following encryption keys and IVs:
    </p><ul>
    <li>client handshake key: <tt>30a7e816f6a1e1b3434cf39cf4b415e7</tt>
    </li><li>client handshake IV: <tt>11e70a5d1361795d2bb04465</tt>
    </li><li>client handshake header protection key: <tt>84b3c21cacaf9f54c885e9a506459079</tt>
    </li><li>server handshake key: <tt>17abbf0a788f96c6986964660414e7ec</tt>
    </li><li>server handshake IV: <tt>09597a2ea3b04c00487e71f3</tt>
    </li><li>server handshake header protection key: <tt>2a18061c396c2828582b41b0910ed536</tt>
    </li></ul>
</div></div>
  </body>
</html>
