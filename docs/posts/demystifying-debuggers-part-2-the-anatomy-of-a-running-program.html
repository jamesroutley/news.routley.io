<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.rfleury.com/p/demystifying-debuggers-part-2-the">Original</a>
    <h1>Demystifying Debuggers, Part 2: The Anatomy of a Running Program</h1>
    
    <div id="readability-page-1" class="page"><div><div dir="auto"><p>From day one using a modern home computer, users are exposed to the concept of a program. Support for separate programs is, after all, the main value-add of multitasking operating systems. But—if we take a peek under the hood—a program is a high-level term which refers to many lower level mechanisms and concepts, and it isn’t obvious from the outset how they’re all arranged.</p><p>To unpack debuggers—programs which analyze the execution of other programs—it’s important that we first unpack the concept of a program, so that we’re familiar with the details of programs that a debugger must contend with.</p><p>Programs are the virtualized equivalent of cartridges for an old video game console, like the Nintendo Entertainment System. The NES didn’t have a multitasking operating system, and it only executed a single program while it was turned on—whatever one was stored on the cartridge that the player installed.</p><p>In this context, the program executing on the system had full availability to all of the system’s resources. There was no code running of which the program couldn’t be aware.</p><p><span>Programs, in the context of a multitasking operating system, are a bundle of mechanisms used to approximately provide the same thing </span><em>virtually</em><span> as the NES provided to the program stored on the cartridge </span><em>physically</em><span>. Of course, multitasking operating systems also provide ways for these programs to communicate and interact (that is indeed the point), but at some level they must still exist independently, as different physical cartridges do.</span></p><p><span>Because programs, unlike cartridges, can be executing on the same chip </span><em>at the same time</em><span>, and thus contend for the same resources, there are many additional </span><em>software</em><span> concepts that operating systems use to virtualize independent program execution:</span></p><ul><li><p><span>A </span><em><strong>virtual address space</strong></em><span> — A range of </span><em>virtual addresses</em><span>, for which the platform provides a mapping to </span><em>physical addresses</em><span>. Programs are built to interact with </span><em>virtual addresses, </em><span>which are entirely independent from addresses in other virtual address spaces. Virtual address spaces can be much </span><em>larger</em><span> than, for example, physical RAM limitations.</span></p></li><li><p><span>A </span><em><strong>thread of execution</strong></em><span> — A bundle of state which is used to initialize the CPU to coherently execute a sequence of instructions. Threads of execution are </span><em>scheduled</em><span> by the platform, such that many threads can execute on a small, fixed number of </span><em>cores</em><span>.</span></p></li><li><p><span>An </span><em><strong>executable image</strong></em><span> — A sequence of bytes encoding data in a platform-defined format, to encode executable machine instructions, as well as relevant headers and metadata. An independent code package’s </span><em>non-live</em><span> representation—a blueprint for execution.</span></p></li><li><p><span>A </span><em><strong>loader</strong></em><span> — The part of an operating system responsible for parsing </span><em>executable images</em><span>—blueprints for execution—and instantiating them, so that the code encoded in the images may be actually executed.</span></p></li><li><p><span>A </span><em><strong>module</strong></em><span> — The loaded equivalent of an </span><em>executable image</em><span>. One </span><em>process</em><span> can load several </span><em>modules</em><span>, although a process is always initialized by the loading of </span><em>one specific module</em><span> (the initial executable image). Modules can be both dynamically </span><em>loaded</em><span> and </span><em>unloaded</em><span>.</span></p></li><li><p><span>A </span><em><strong>process</strong></em><span> — An instance of a live, running program. Instantiated by the platform’s </span><em>loader</em><span> using the initial </span><em>executable image</em><span> to determine how it’s initialized, and what code is initially loaded. The granularity at which operating systems assign </span><em>virtual address spaces</em><span>. The container of several </span><em>modules</em><span>, and </span><em>threads of execution</em><span>.</span></p></li></ul><p>Let’s unpack all of this.</p><h3>Virtual Address Spaces</h3><blockquote><p><em>A range of virtual addresses, for which the platform provides a mapping to physical addresses. Programs are built to interact with virtual addresses, which are entirely independent from addresses in other virtual address spaces. Virtual address spaces can be much larger than, for example, physical RAM limitations.</em></p></blockquote><p><span>Whether it’s through the easy or hard way, all programmers learn about pointers. When I first learned about pointers, I understood them as being used to encode integers, with the integers being addresses, which address bytes within memory, in linear order. Address </span><code>0</code><span> comes before </span><code>1</code><span>, which comes before </span><code>2</code><span>, and so on.</span></p><p>In other words, I was under the impression that physical memory, and its relationship to addresses, was structured like this:</p><div><figure><a target="_blank" href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fbf0d7080-b386-4391-95f7-4b7f3a98aa46_1398x1137.png" data-component-name="Image2ToDOM" rel=""><div><picture><source type="image/webp" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fbf0d7080-b386-4391-95f7-4b7f3a98aa46_1398x1137.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fbf0d7080-b386-4391-95f7-4b7f3a98aa46_1398x1137.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fbf0d7080-b386-4391-95f7-4b7f3a98aa46_1398x1137.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fbf0d7080-b386-4391-95f7-4b7f3a98aa46_1398x1137.png 1456w" sizes="100vw"/><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fbf0d7080-b386-4391-95f7-4b7f3a98aa46_1398x1137.png" width="568" height="461.9570815450644" data-attrs="{&#34;src&#34;:&#34;https://substack-post-media.s3.amazonaws.com/public/images/bf0d7080-b386-4391-95f7-4b7f3a98aa46_1398x1137.png&#34;,&#34;srcNoWatermark&#34;:null,&#34;fullscreen&#34;:null,&#34;imageSize&#34;:null,&#34;height&#34;:1137,&#34;width&#34;:1398,&#34;resizeWidth&#34;:568,&#34;bytes&#34;:302713,&#34;alt&#34;:null,&#34;title&#34;:null,&#34;type&#34;:&#34;image/png&#34;,&#34;href&#34;:null,&#34;belowTheFold&#34;:true,&#34;topImage&#34;:false,&#34;internalRedirect&#34;:null,&#34;isProcessing&#34;:false}" alt="" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fbf0d7080-b386-4391-95f7-4b7f3a98aa46_1398x1137.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fbf0d7080-b386-4391-95f7-4b7f3a98aa46_1398x1137.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fbf0d7080-b386-4391-95f7-4b7f3a98aa46_1398x1137.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fbf0d7080-b386-4391-95f7-4b7f3a98aa46_1398x1137.png 1456w" sizes="100vw" loading="lazy"/></picture><div><div></div></div></div></a></figure></div><p>This is a fine mental model to begin with. But it isn’t accurate.</p><p><span>When many independent programs execute on a single machine, it isn’t difficult to imagine one of them getting an address wrong. In fact, sometimes, it feels like “getting addresses wrong” is the only thing anybody talks about these days. If all of these programs shared a single memory space, this could easily lead to one program stomping over data that another program is using. It could also lead to, for example, a </span><em>malicious program</em><span>—let’s call it </span><code>ryans_game.exe</code><span>—reading information from </span><code>chrome.exe</code><span>, browsing a page from </span><code>chase.com</code><span> with all of your sensitive information on it. This is purely hypothetical!</span></p><p><em>Virtual address spaces</em><span> are used to mediate between different programs accessing the same resource—physical memory. Addresses </span><em>can</em><span> be understood as integers, and as such, they </span><em>are</em><span> linearly ordered, and they </span><em>do</em><span> each refer to sequential bytes—but these bytes are sequential in </span><em>virtual address space</em><span>, not in </span><em>physical memory</em><span>.</span></p><p><span>Virtual address spaces are implemented with a mapping data structure known as a </span><em>page table</em><span>. Page tables can be used to translate a virtual address to a physical address. They can then be used directly by the CPU in order to do address translation. For instance, if a CPU core were to execute a </span><code>mov</code><span> (move) instruction, to load 8 bytes from address </span><code>0x1000</code><span> into a register, then before issuing a read from physical memory, the CPU would first treat </span><code>0x1000</code><span> as a </span><em>virtual address</em><span>, and translate it into a </span><em>physical address, </em><span>which might be completely different—like </span><code>0x111000</code><span>.</span></p><p><span>“Page tables” are called as such, because they map from virtual to physical addresses at </span><em>page-size granularity</em><span>. A system’s page-size varies—on an x64 Windows PC, it’ll be 4 kilobytes. On an iPhone, it’ll be 16 kilobytes. Operating systems also expose larger page sizes under some circumstances.</span></p><p><span>This means the relationship between physical memory and an address—as used by a program, as a </span><em>virtual address</em><span>—looks more like this:</span></p><div><figure><a target="_blank" href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F2ee85c0c-2624-4ffb-9810-633b75e933b6_1533x1377.png" data-component-name="Image2ToDOM" rel=""><div><picture><source type="image/webp" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F2ee85c0c-2624-4ffb-9810-633b75e933b6_1533x1377.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F2ee85c0c-2624-4ffb-9810-633b75e933b6_1533x1377.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F2ee85c0c-2624-4ffb-9810-633b75e933b6_1533x1377.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F2ee85c0c-2624-4ffb-9810-633b75e933b6_1533x1377.png 1456w" sizes="100vw"/><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F2ee85c0c-2624-4ffb-9810-633b75e933b6_1533x1377.png" width="602" height="540.8076923076923" data-attrs="{&#34;src&#34;:&#34;https://substack-post-media.s3.amazonaws.com/public/images/2ee85c0c-2624-4ffb-9810-633b75e933b6_1533x1377.png&#34;,&#34;srcNoWatermark&#34;:null,&#34;fullscreen&#34;:null,&#34;imageSize&#34;:null,&#34;height&#34;:1308,&#34;width&#34;:1456,&#34;resizeWidth&#34;:602,&#34;bytes&#34;:509363,&#34;alt&#34;:null,&#34;title&#34;:null,&#34;type&#34;:&#34;image/png&#34;,&#34;href&#34;:null,&#34;belowTheFold&#34;:true,&#34;topImage&#34;:false,&#34;internalRedirect&#34;:null,&#34;isProcessing&#34;:false}" alt="" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F2ee85c0c-2624-4ffb-9810-633b75e933b6_1533x1377.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F2ee85c0c-2624-4ffb-9810-633b75e933b6_1533x1377.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F2ee85c0c-2624-4ffb-9810-633b75e933b6_1533x1377.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F2ee85c0c-2624-4ffb-9810-633b75e933b6_1533x1377.png 1456w" sizes="100vw" loading="lazy"/></picture><div><div></div></div></div></a></figure></div><p><span>If a virtual address </span><em>cannot be mapped</em><span> to a physical address, then a “page fault” exception is issued by the CPU, and execution is interrupted. If this is done by a program’s code, then execution will be transferred to the operating system’s code, which can take measures to address the cause of the exception and resume, or do whatever else it deems appropriate.</span></p><p>This provides a great deal of flexibility to operating systems. An operating system can move memory allocated by one program to disk—what’s known as “paging out”, or “swapping out”—if it expects that memory to not be accessed in the near future. It can then use that physical memory for more frequently accessed addresses, in any of the active virtual address spaces. If a page fault occurs when code attempts to access memory which has been paged out, then the operating system can simply page that memory back in, and resume execution. Thus, even though hundreds—if not thousands—of programs can be executing at once, the operating system can make much more efficient use of physical memory, given its analysis of which addresses in which spaces are needed, and when. This is critical in building operating systems which can support the execution of many programs, where all programs are contending for the same physical hardware.</p><p><span>It also provides a great deal of flexibility to programs, as it can be used to implement virtual address spaces which are </span><em>much larger</em><span> than physical memory. Nowadays, nearly every consumer CPU—from phones, to game consoles, to PCs, to laptops—is a 64-bit processor. For PCs and laptops running on 64-bit CPUs, the CPU and operating system normally provide a 48-bit address space. On some server systems, it is larger, and on some mobile and console platforms, it is smaller.</span></p><p><span>Taking a 48-bit address space as an example—48 bits allow the representation of 2</span><sup>48</sup><span> different values (each bit multiplies the number of possible values by 2). Since each value refers to a different potential byte, that is enough address space to refer to 256 terabytes.</span></p><p>To understand this further, let’s dissect the “page table” data structure a bit more.</p><p><span>First, let’s assume a 48-bit address space, and a 4 kilobyte page size (the usual configuration on x64 Windows systems). As I said, page tables map from virtual to physical addresses at </span><em>page-size granularity</em><span>. Because of our 4 kilobyte page size, we can infer that the bottom 12 bits of any address are </span><em>identical</em><span> for both a virtual address and a physical address (2</span><sup>12</sup><span> = 4096 = 4 kilobytes).</span></p><div><figure><a target="_blank" href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F18d8c36d-3abc-4faf-9d4a-f525f7a8dc9d_1572x633.png" data-component-name="Image2ToDOM" rel=""><div><picture><source type="image/webp" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F18d8c36d-3abc-4faf-9d4a-f525f7a8dc9d_1572x633.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F18d8c36d-3abc-4faf-9d4a-f525f7a8dc9d_1572x633.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F18d8c36d-3abc-4faf-9d4a-f525f7a8dc9d_1572x633.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F18d8c36d-3abc-4faf-9d4a-f525f7a8dc9d_1572x633.png 1456w" sizes="100vw"/><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F18d8c36d-3abc-4faf-9d4a-f525f7a8dc9d_1572x633.png" width="1456" height="586" data-attrs="{&#34;src&#34;:&#34;https://substack-post-media.s3.amazonaws.com/public/images/18d8c36d-3abc-4faf-9d4a-f525f7a8dc9d_1572x633.png&#34;,&#34;srcNoWatermark&#34;:null,&#34;fullscreen&#34;:null,&#34;imageSize&#34;:null,&#34;height&#34;:586,&#34;width&#34;:1456,&#34;resizeWidth&#34;:null,&#34;bytes&#34;:293389,&#34;alt&#34;:null,&#34;title&#34;:null,&#34;type&#34;:&#34;image/png&#34;,&#34;href&#34;:null,&#34;belowTheFold&#34;:true,&#34;topImage&#34;:false,&#34;internalRedirect&#34;:null,&#34;isProcessing&#34;:false}" alt="" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F18d8c36d-3abc-4faf-9d4a-f525f7a8dc9d_1572x633.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F18d8c36d-3abc-4faf-9d4a-f525f7a8dc9d_1572x633.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F18d8c36d-3abc-4faf-9d4a-f525f7a8dc9d_1572x633.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F18d8c36d-3abc-4faf-9d4a-f525f7a8dc9d_1572x633.png 1456w" sizes="100vw" loading="lazy"/></picture><div><div></div></div></div></a></figure></div><p><span>This leaves 36 remaining bits, of each address, to map from virtual to physical addresses. These bits are used to index into several hierarchical levels, within the page table—it is actually a hierarchical data structure, despite its name, which sounds like it implies a flat table. To understand why, imagine, first, a naïve page table implementation, which simply stores a 64-bit physical address, for each value in this 36-bit space. This, unsurprisingly, would require an unrealistically large amount of storage. Instead, we can notice that the page table need only map virtual addresses </span><em>which have actually been allocated</em><span>. At the outset, </span><em>none</em><span> are allocated. When a virtual address space allocation is made, a hierarchical data structure allows the page table implementation to </span><em>only</em><span> allocate nodes in the hierarchy which are actually touched, by that one allocation.</span></p><p>Each node in the hierarchy can simply be a table of 64-bit addresses which point to children nodes (or, at the final level, it can store each page’s physical address). If each node is a 512-element table, and each element is a 64-bit address (8 bytes), then each node requires 4096 bytes, which is our page-size!</p><p><span>Because 2</span><sup>9</sup><span> = 512, we can slice our 36-bits into </span><em>4</em><span> table indices—each 9 bits—and use that to traverse the page table. The first 9 bits indexes into the first level, the next into the second, the next into the third, the next into the fourth—the fourth provides the base address of the containing page of our address, and then the bottom 12 bits can be used as an offset from that base.</span></p><div><figure><a target="_blank" href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F6f29652e-7a7a-4a0c-a6f3-8c90134f7976_2048x2048.png" data-component-name="Image2ToDOM" rel=""><div><picture><source type="image/webp" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F6f29652e-7a7a-4a0c-a6f3-8c90134f7976_2048x2048.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F6f29652e-7a7a-4a0c-a6f3-8c90134f7976_2048x2048.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F6f29652e-7a7a-4a0c-a6f3-8c90134f7976_2048x2048.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F6f29652e-7a7a-4a0c-a6f3-8c90134f7976_2048x2048.png 1456w" sizes="100vw"/><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F6f29652e-7a7a-4a0c-a6f3-8c90134f7976_2048x2048.png" width="1456" height="1456" data-attrs="{&#34;src&#34;:&#34;https://substack-post-media.s3.amazonaws.com/public/images/6f29652e-7a7a-4a0c-a6f3-8c90134f7976_2048x2048.png&#34;,&#34;srcNoWatermark&#34;:null,&#34;fullscreen&#34;:null,&#34;imageSize&#34;:null,&#34;height&#34;:1456,&#34;width&#34;:1456,&#34;resizeWidth&#34;:null,&#34;bytes&#34;:1042833,&#34;alt&#34;:null,&#34;title&#34;:null,&#34;type&#34;:&#34;image/png&#34;,&#34;href&#34;:null,&#34;belowTheFold&#34;:true,&#34;topImage&#34;:false,&#34;internalRedirect&#34;:null,&#34;isProcessing&#34;:false}" alt="" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F6f29652e-7a7a-4a0c-a6f3-8c90134f7976_2048x2048.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F6f29652e-7a7a-4a0c-a6f3-8c90134f7976_2048x2048.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F6f29652e-7a7a-4a0c-a6f3-8c90134f7976_2048x2048.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F6f29652e-7a7a-4a0c-a6f3-8c90134f7976_2048x2048.png 1456w" sizes="100vw" loading="lazy"/></picture><div><div></div></div></div></a></figure></div><p><span>For each virtual address space, the operating system manages this page table structure. Before the operating system prepares the CPU to execute code for one program, it can supply this table, such that the CPU can appropriately issue memory reads and writes to </span><em>physical </em><span>addresses for the appropriate virtual address space. The end result is that each program can, in effect, live in its own universe of virtual addresses, as if it had access to the entire system’s memory space, and if that memory space far exceeded the limitations of a system’s random access memory (RAM) capacity.</span></p><h3>Threads Of Execution</h3><blockquote><p><em>A bundle of state which is used to initialize the CPU to cohesively execute a sequence of instructions. Threads of execution are scheduled by the platform, such that many threads can execute on a small, fixed number of cores.</em></p></blockquote><p><span>Beyond a page table, a CPU core requires other information to coherently execute code. For instance, it requires the “instruction pointer” (or “program counter”)—this is a register, which stores the virtual address of the next instruction which should execute, in a given instruction stream. After each instruction is executed, the value in this register is updated to reflect the base address of the next subsequent instruction. On x64, this is known as the </span><code>rip</code><span> register.</span></p><p>When using a debugger, you’ll often see golden arrows, pointing to lines of source code or disassembly. This directly visualizes the location of the instruction pointer.</p><div><figure><a target="_blank" href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fe21e4ab3-7d54-4384-9722-9b4552b406da_1419x248.png" data-component-name="Image2ToDOM" rel=""><div><picture><source type="image/webp" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fe21e4ab3-7d54-4384-9722-9b4552b406da_1419x248.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fe21e4ab3-7d54-4384-9722-9b4552b406da_1419x248.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fe21e4ab3-7d54-4384-9722-9b4552b406da_1419x248.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fe21e4ab3-7d54-4384-9722-9b4552b406da_1419x248.png 1456w" sizes="100vw"/><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fe21e4ab3-7d54-4384-9722-9b4552b406da_1419x248.png" width="1419" height="248" data-attrs="{&#34;src&#34;:&#34;https://substack-post-media.s3.amazonaws.com/public/images/e21e4ab3-7d54-4384-9722-9b4552b406da_1419x248.png&#34;,&#34;srcNoWatermark&#34;:null,&#34;fullscreen&#34;:null,&#34;imageSize&#34;:null,&#34;height&#34;:248,&#34;width&#34;:1419,&#34;resizeWidth&#34;:null,&#34;bytes&#34;:42198,&#34;alt&#34;:null,&#34;title&#34;:null,&#34;type&#34;:&#34;image/png&#34;,&#34;href&#34;:null,&#34;belowTheFold&#34;:true,&#34;topImage&#34;:false,&#34;internalRedirect&#34;:null,&#34;isProcessing&#34;:false}" alt="" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fe21e4ab3-7d54-4384-9722-9b4552b406da_1419x248.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fe21e4ab3-7d54-4384-9722-9b4552b406da_1419x248.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fe21e4ab3-7d54-4384-9722-9b4552b406da_1419x248.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fe21e4ab3-7d54-4384-9722-9b4552b406da_1419x248.png 1456w" sizes="100vw" loading="lazy"/></picture></div></a></figure></div><p><span>There are several other registers, used for a variety of purposes, including general purpose slots for computations. The state of </span><em>all</em><span> such registers is called a “register state”, or “register file”. One register state is paired exclusively with one instruction stream, from one program—a register state should only change if a single instruction stream performs work which causes it.</span></p><p><span>But a CPU has only a fixed number of cores, be it 1, 2, 4, 8, 12, 16, 32, and so on—yet operating systems support a much larger number of programs executing simultaneously. Or, at least, it </span><em>seems</em><span> like they execute simultaneously.</span></p><p><span>The operating system implements this illusion—of hundreds if not thousands (if not more—unfortunately…) programs running simultaneously on a small, fixed number of cores—by </span><em>scheduling</em><span> </span><em>work</em><span> from these programs. One CPU core will perform work for one program, for some period of time—it will be interrupted, and the operating system can make the decision to schedule work from another program, for example.</span></p><p><span>A </span><em>thread of execution</em><span> is the name given to the execution state for one instruction stream. Each contains one register state, which includes the instruction pointer, and thus a stream of instructions—among whatever other state each operating system deems appropriate.</span></p><p><span>In other words, operating systems do not just schedule </span><em>programs</em><span>—they schedule </span><em>threads</em><span>. When an operating system </span><em>schedules a thread</em><span>, it incurs a “context switch”—this is the process of storing the CPU core state for whatever thread </span><em>was executing </em><span>to memory, and initializing that core to execute work for the thread which </span><em>will execute</em><span>.</span></p><h3>Executable Images</h3><blockquote><p><em>A sequence of bytes encoding data in a platform-defined format, to encode executable machine instructions, as well as relevant headers and metadata. An independent code package’s non-live representation—a blueprint for execution.</em></p></blockquote><p><span>On Windows, you’ll find executable images stored on the filesystem with a </span><code>.exe</code><span>, or a </span><code>.dll</code><span> extension. These files are stored in the </span><a href="https://learn.microsoft.com/en-us/windows/win32/debug/pe-format" rel="">Portable Executable (PE) format</a><span>. The difference between </span><code>.exe</code><span> and </span><code>.dll</code><span> is that the former is used to signify that an executable image is a viable </span><em>initial module</em><span> for a process, whereas the latter is used to signify that an executable image is only to be loaded dynamically as an </span><em>additional module</em><span> for a process.</span></p><p><span>On Linux systems, there is a similar structure—executable images are stored on the filesystem (the extension convention varies—sometimes there is no extension for the equivalent of Windows’ </span><code>.exe</code><span>, sometimes there is a </span><code>.elf</code><span> extension, and for the equivalent of Windows’ </span><code>.dll</code><span>, the extension is generally </span><code>.so</code><span>). These files are stored in the </span><a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format" rel="">Executable and Linkable Format (ELF)</a><span>.</span></p><p><span>When I say “these files are stored in” a particular format, what I mean is that the associated operating system’s </span><em>loader</em><span> expects files in that format. In order to produce code which can be loaded on a platform out-of-the-box, one must package that code in the format which is expected by that platform.</span></p><p>It’s not in this series’ scope to comprehensively dissect either the PE or the ELF formats. But to justify the definition and concepts I’ve provided, let’s investigate the PE format using a simple example.</p><p>First, consider the following code:</p><pre><code>// sample.c

void WinMainCRTStartup(void)
{
  int x = 0;
}</code></pre><p>This can be built with the following command, using the Visual Studio Build Tools:</p><pre><code>cl /nologo /Zi sample.c /link /NODEFAULTLIB /INCREMENTAL:NO /SUBSYSTEM:WINDOWS</code></pre><p>This command will produce an executable image, containing machine code. This machine code could be disassembled (for instance, using a debugger)—that would show something like this:</p><pre><code>sub rsp, 0x18              ; - push 24 bytes onto the stack, for locals
mov dword ptr [rsp], 0x00  ; - set the 4 bytes we are using of the stack
                           ;     for `x` to 0
add rsp, 0x18              ; - pop the 24 bytes we pushed off the stack
ret                        ; - return to the caller of our main function</code></pre><p><span>Even if we know nothing else about the PE format, we </span><em>do know</em><span> that these instructions need to be encoded </span><em>somewhere</em><span> in the file. We can identify how these are encoded using a disassembler tool as well, which should have an ability to visualize the machine code bytes which were parsed to form each instruction:</span></p><div><figure><a target="_blank" href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fa185fe0b-85c6-4e6a-a279-abf50f96727d_849x512.png" data-component-name="Image2ToDOM" rel=""><div><picture><source type="image/webp" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fa185fe0b-85c6-4e6a-a279-abf50f96727d_849x512.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fa185fe0b-85c6-4e6a-a279-abf50f96727d_849x512.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fa185fe0b-85c6-4e6a-a279-abf50f96727d_849x512.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fa185fe0b-85c6-4e6a-a279-abf50f96727d_849x512.png 1456w" sizes="100vw"/><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fa185fe0b-85c6-4e6a-a279-abf50f96727d_849x512.png" width="849" height="512" data-attrs="{&#34;src&#34;:&#34;https://substack-post-media.s3.amazonaws.com/public/images/a185fe0b-85c6-4e6a-a279-abf50f96727d_849x512.png&#34;,&#34;srcNoWatermark&#34;:null,&#34;fullscreen&#34;:null,&#34;imageSize&#34;:null,&#34;height&#34;:512,&#34;width&#34;:849,&#34;resizeWidth&#34;:null,&#34;bytes&#34;:48721,&#34;alt&#34;:null,&#34;title&#34;:null,&#34;type&#34;:&#34;image/png&#34;,&#34;href&#34;:null,&#34;belowTheFold&#34;:true,&#34;topImage&#34;:false,&#34;internalRedirect&#34;:null,&#34;isProcessing&#34;:false}" alt="" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fa185fe0b-85c6-4e6a-a279-abf50f96727d_849x512.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fa185fe0b-85c6-4e6a-a279-abf50f96727d_849x512.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fa185fe0b-85c6-4e6a-a279-abf50f96727d_849x512.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fa185fe0b-85c6-4e6a-a279-abf50f96727d_849x512.png 1456w" sizes="100vw" loading="lazy"/></picture><div><div></div></div></div></a></figure></div><p><span>The above image shows the disassembled instructions in the RAD Debugger, as well as the bytes from which they were parsed. If you took a look at the disassembly yourself, and were confused by the </span><code>add [rax], al</code><span> instruction everywhere surrounding the actual code, the code bytes also clear that mystery up—that is simply the instruction one obtains when parsing two sequential zero bytes.</span></p><p>Given the above, we know that the generated machine code is encoded with 16 bytes. Each byte can be represented with two hexadecimal digits:</p><pre><code>48 83 ec 18 c7 04 24 00 00 00 00 48 83 c4 18 c3</code></pre><p>If we look at the generated EXE with a memory viewer, we can, indeed, find this sequence of bytes.</p><div><figure><a target="_blank" href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ffa4cda8a-786d-494b-9b6d-bcb6ccc5d0bf_870x610.png" data-component-name="Image2ToDOM" rel=""><div><picture><source type="image/webp" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ffa4cda8a-786d-494b-9b6d-bcb6ccc5d0bf_870x610.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ffa4cda8a-786d-494b-9b6d-bcb6ccc5d0bf_870x610.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ffa4cda8a-786d-494b-9b6d-bcb6ccc5d0bf_870x610.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ffa4cda8a-786d-494b-9b6d-bcb6ccc5d0bf_870x610.png 1456w" sizes="100vw"/><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ffa4cda8a-786d-494b-9b6d-bcb6ccc5d0bf_870x610.png" width="870" height="610" data-attrs="{&#34;src&#34;:&#34;https://substack-post-media.s3.amazonaws.com/public/images/fa4cda8a-786d-494b-9b6d-bcb6ccc5d0bf_870x610.png&#34;,&#34;srcNoWatermark&#34;:null,&#34;fullscreen&#34;:null,&#34;imageSize&#34;:null,&#34;height&#34;:610,&#34;width&#34;:870,&#34;resizeWidth&#34;:null,&#34;bytes&#34;:37748,&#34;alt&#34;:null,&#34;title&#34;:null,&#34;type&#34;:&#34;image/png&#34;,&#34;href&#34;:null,&#34;belowTheFold&#34;:true,&#34;topImage&#34;:false,&#34;internalRedirect&#34;:null,&#34;isProcessing&#34;:false}" alt="" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ffa4cda8a-786d-494b-9b6d-bcb6ccc5d0bf_870x610.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ffa4cda8a-786d-494b-9b6d-bcb6ccc5d0bf_870x610.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ffa4cda8a-786d-494b-9b6d-bcb6ccc5d0bf_870x610.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ffa4cda8a-786d-494b-9b6d-bcb6ccc5d0bf_870x610.png 1456w" sizes="100vw" loading="lazy"/></picture><div><div></div></div></div></a></figure></div><p>We know that this sequence of bytes is the primary “payload”—the actual program code. Everything else in the file is used to either instruct the loader how to correctly prepare a process for this code to execute, or to associate various metadata with the code.</p><p>For example, if you scan around the file, you’ll find the full path to the debug information file (PDB) for the executable image.</p><div><figure><a target="_blank" href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F86b44674-2b9d-44ad-9945-36916129bf95_869x568.png" data-component-name="Image2ToDOM" rel=""><div><picture><source type="image/webp" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F86b44674-2b9d-44ad-9945-36916129bf95_869x568.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F86b44674-2b9d-44ad-9945-36916129bf95_869x568.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F86b44674-2b9d-44ad-9945-36916129bf95_869x568.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F86b44674-2b9d-44ad-9945-36916129bf95_869x568.png 1456w" sizes="100vw"/><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F86b44674-2b9d-44ad-9945-36916129bf95_869x568.png" width="869" height="568" data-attrs="{&#34;src&#34;:&#34;https://substack-post-media.s3.amazonaws.com/public/images/86b44674-2b9d-44ad-9945-36916129bf95_869x568.png&#34;,&#34;srcNoWatermark&#34;:null,&#34;fullscreen&#34;:null,&#34;imageSize&#34;:null,&#34;height&#34;:568,&#34;width&#34;:869,&#34;resizeWidth&#34;:null,&#34;bytes&#34;:69255,&#34;alt&#34;:null,&#34;title&#34;:null,&#34;type&#34;:&#34;image/png&#34;,&#34;href&#34;:null,&#34;belowTheFold&#34;:true,&#34;topImage&#34;:false,&#34;internalRedirect&#34;:null,&#34;isProcessing&#34;:false}" alt="" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F86b44674-2b9d-44ad-9945-36916129bf95_869x568.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F86b44674-2b9d-44ad-9945-36916129bf95_869x568.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F86b44674-2b9d-44ad-9945-36916129bf95_869x568.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F86b44674-2b9d-44ad-9945-36916129bf95_869x568.png 1456w" sizes="100vw" loading="lazy"/></picture><div><div></div></div></div></a></figure></div><p>The executable image also must store data to which code refers. We can see this by inserting a recognizable pattern into a global variable:</p><pre><code>// sample.c

static char important_data[] = {0x12, 0x34, 0x56, 0x78, 0x90};

void WinMainCRTStartup(void)
{
  int x = important_data[0];
}</code></pre><p>We can also easily find the corresponding data in the PE file:</p><div><figure><a target="_blank" href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fc3f5a56f-c105-4e90-a39b-16f5fad3fddd_896x310.png" data-component-name="Image2ToDOM" rel=""><div><picture><source type="image/webp" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fc3f5a56f-c105-4e90-a39b-16f5fad3fddd_896x310.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fc3f5a56f-c105-4e90-a39b-16f5fad3fddd_896x310.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fc3f5a56f-c105-4e90-a39b-16f5fad3fddd_896x310.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fc3f5a56f-c105-4e90-a39b-16f5fad3fddd_896x310.png 1456w" sizes="100vw"/><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fc3f5a56f-c105-4e90-a39b-16f5fad3fddd_896x310.png" width="896" height="310" data-attrs="{&#34;src&#34;:&#34;https://substack-post-media.s3.amazonaws.com/public/images/c3f5a56f-c105-4e90-a39b-16f5fad3fddd_896x310.png&#34;,&#34;srcNoWatermark&#34;:null,&#34;fullscreen&#34;:null,&#34;imageSize&#34;:null,&#34;height&#34;:310,&#34;width&#34;:896,&#34;resizeWidth&#34;:null,&#34;bytes&#34;:17650,&#34;alt&#34;:null,&#34;title&#34;:null,&#34;type&#34;:&#34;image/png&#34;,&#34;href&#34;:null,&#34;belowTheFold&#34;:true,&#34;topImage&#34;:false,&#34;internalRedirect&#34;:null,&#34;isProcessing&#34;:false}" alt="" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fc3f5a56f-c105-4e90-a39b-16f5fad3fddd_896x310.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fc3f5a56f-c105-4e90-a39b-16f5fad3fddd_896x310.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fc3f5a56f-c105-4e90-a39b-16f5fad3fddd_896x310.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fc3f5a56f-c105-4e90-a39b-16f5fad3fddd_896x310.png 1456w" sizes="100vw" loading="lazy"/></picture><div><div></div></div></div></a></figure></div><p><span>If you investigate formats like PE or ELF more closely, what you’ll find is that various categories of data—code, initialized global variables—are separated into </span><em>sections</em><span>. Each section has a name, which is also encoded in the file.</span></p><p><span>In PE, </span><code>.text</code><span>, for example, encodes all of the machine code (rather than, well, text…). </span><code>.data</code><span> stores data for initialized global variables. </span><code>.rdata</code><span> stores the same, but is separated to be allocated in read-only pages, such that code cannot modify that data.</span></p><p><code>.pdata</code><span> and </span><code>.xdata</code><span> encode information about how, given a procedure, one may </span><em>unwind</em><span> a thread, to—for example—produce a call stack, which is simply recreating the information of which functions called which other functions in order to get a thread of execution to its current point in a procedure. But we’ll dig into that topic in a later post.</span></p><p><code>.edata</code><span> and </span><code>.idata</code><span> encode information about </span><em>exports</em><span> and </span><em>imports</em><span>, respectively, which associate strings (“symbol names”) with locations in the file. An export is used by DLLs, for example, to export functions which can be dynamically loaded by name, by code in an executable or other DLL, and called. An import is used by either executables or DLLs to specify functions from other modules with which it must dynamically “link”.</span></p><p>When implementing a debugger, the precise details of formats like PE and ELF become relevant—but this should be a sufficient introduction for those unfamiliar with the basics.</p><h3>Loaders &amp; Modules</h3><blockquote><p><em><span>A </span><strong>loader</strong><span> — The part of an operating system responsible for parsing executable images—blueprints for execution—and instantiating them, so that the code encoded in the images may be actually executed.</span></em></p><p><span>A </span><em><strong>module</strong></em><span> — The loaded equivalent of an </span><em>executable image</em><span>. One </span><em>process</em><span> can load several </span><em>modules</em><span>, although a process is always initialized by the loading of </span><em>one specific module</em><span> (the initial executable image). Modules can be both dynamically </span><em>loaded</em><span> and </span><em>unloaded</em><span>.</span></p></blockquote><p><span>More than a debugger, a </span><em>loader</em><span> must be highly aware of executable image format details, because it has the task of </span><em>parsing</em><span> those images and making preparations,</span><em> </em><span>such that the code contained in the executable image can be executed.</span></p><p><span>A loader executes when a program is initially launched, or when actively-executing code requests to dynamically load another image—for instance, via </span><code>LoadLibrary</code><span> (Windows) or </span><code>dlopen</code><span> (Linux).</span></p><p><span>To understand this, let’s build a toy executable image format, and write our own loader, which parses </span><em>our </em><span>format, rather than PE or ELF.</span></p><p>Consider the following code, from earlier:</p><pre><code>// sample.c

void WinMainCRTStartup(void)
{
  int x = 0;
}</code></pre><p>And its disassembly:</p><pre><code>&gt; c:/devel/sample/sample.c
&gt; {
{48 83 ec 18}              sub rsp, 0x18
&gt; int x = 0;
{c7 04 24 00 00 00 00}     mov dword ptr [rsp], 0x00
&gt; }
{48 83 c4 18}              add rsp, 0x18
{c3}                       ret</code></pre><p>Our toy format can have a simple header, at the beginning of the image, containing the following values, in order:</p><ul><li><p><span>An 8-byte signature, denoting that the file is in our format—must always be </span><code>54 4f 59 45 58 45 00 00</code><span>—encoding the ASCII text </span><code>TOYEXE</code><span>, followed by two zero bytes.</span></p></li><li><p>An 8-byte offset into the file, encoding where in the file all readable-and-writable global data is stored—the “data section”</p></li><li><p>An 8-byte offset into the file, encoding where in the file all read-only global data is stored—the “read-only data section”</p></li><li><p>An 8-byte offset into the file, encoding where in the file all executable data is stored— the “code section”</p></li></ul><p>Each section size is determined by taking the next subsequent section offset (or the file size, in the case of the final section), and subtracting from it the section offset. If sections contain no data in any case, they will simply have the same offset as the next section.</p><p>Given this simple format, our full executable file for the simple example program can be encoded with the following bytes:</p><pre><code>{54 4f 59 45 58 45 00 00} (magic)
{20 00 00 00 00 00 00 00} (read/write data offset)
{20 00 00 00 00 00 00 00} (read-only data offset)
{20 00 00 00 00 00 00 00} (executable data offset)
{48 83 ec 18 c7 04 24 00 00 00 00 48 83 c4 18 c3} (executable data)</code></pre><p><span>In this case, our data sections are completely empty, because no global data is used by the code. Every section offset begins at offset </span><code>0x20</code><span> (or 32 bytes) into the file—or, directly after the header. The executable data section, being the final section, occupies the remainder of the file.</span></p><p>Our “loader” can define the format’s header with the following structure:</p><pre><code>typedef struct ToyExe_Header ToyExe_Header;
struct ToyExe_Header
{
  U64 magic;       // must be {54 4f 59 45 58 45 00 00}
  U64 rw_data_off; // read/write
  U64 r_data_off;  // read
  U64 x_data_off;  // executable
};</code></pre><p>It can begin by reading the file, and extracting the header:</p><pre><code>// open file, map it into the process address space
HANDLE file = CreateFileA(arguments, GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
U64 file_size = 0;
if(file != INVALID_HANDLE_VALUE)
{
  DWORD file_size_hi = 0;
  DWORD file_size_lo = GetFileSize(file, &amp;file_size_hi);
  file_size = (((U64)file_size_hi) &lt;&lt; 32) | (U64)file_size_lo;
}
HANDLE file_map = CreateFileMappingA(file, 0, PAGE_EXECUTE_READ, 0, 0, 0);
void *file_base = MapViewOfFile(file_map, FILE_MAP_ALL_ACCESS, 0, 0, 0);

// extract the header
ToyExe_Header header_stub = {0};
ToyExe_Header *header = &amp;header_stub;
if(file_base &amp;&amp; file_size &gt;= sizeof(*header))
{
  header = (ToyExe_Header *)file_base;
}  </code></pre><p>It can then allocate memory, big enough for the image’s data, and copy the file’s contents into that address range.</p><pre><code><code>// allocate memory for all executable data - ensure it is all
// writeable, executable, and readable
void *exe_data = VirtualAlloc(0, file_size, MEM_RESERVE|MEM_COMMIT, 
                              PAGE_EXECUTE_READWRITE);

// copy file&#39;s data into memory
CopyMemory(exe_data, file_base, file_size);</code></code></pre><p>Given the header’s information encoding where in the executable data the code is stored, we can now call into that code directly:</p><pre><code>// call the code
void *x_data = (U8 *)exe_data + header-&gt;x_data_off;
((void (*)())x_data)();</code></pre><div><figure><a target="_blank" href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ff13a85b2-3f22-4989-942b-521f5cb892dd_1350x726.png" data-component-name="Image2ToDOM" rel=""><div><picture><source type="image/webp" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ff13a85b2-3f22-4989-942b-521f5cb892dd_1350x726.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ff13a85b2-3f22-4989-942b-521f5cb892dd_1350x726.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ff13a85b2-3f22-4989-942b-521f5cb892dd_1350x726.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ff13a85b2-3f22-4989-942b-521f5cb892dd_1350x726.png 1456w" sizes="100vw"/><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ff13a85b2-3f22-4989-942b-521f5cb892dd_1350x726.png" width="1350" height="726" data-attrs="{&#34;src&#34;:&#34;https://substack-post-media.s3.amazonaws.com/public/images/f13a85b2-3f22-4989-942b-521f5cb892dd_1350x726.png&#34;,&#34;srcNoWatermark&#34;:null,&#34;fullscreen&#34;:null,&#34;imageSize&#34;:null,&#34;height&#34;:726,&#34;width&#34;:1350,&#34;resizeWidth&#34;:null,&#34;bytes&#34;:95139,&#34;alt&#34;:null,&#34;title&#34;:null,&#34;type&#34;:&#34;image/png&#34;,&#34;href&#34;:null,&#34;belowTheFold&#34;:true,&#34;topImage&#34;:false,&#34;internalRedirect&#34;:null,&#34;isProcessing&#34;:false}" alt="" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ff13a85b2-3f22-4989-942b-521f5cb892dd_1350x726.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ff13a85b2-3f22-4989-942b-521f5cb892dd_1350x726.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ff13a85b2-3f22-4989-942b-521f5cb892dd_1350x726.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ff13a85b2-3f22-4989-942b-521f5cb892dd_1350x726.png 1456w" sizes="100vw" loading="lazy"/></picture><div><div></div></div></div></a></figure></div><p>And it actually works! But there is, as you might expect, more minutiae to this in practice.</p><h4>Per-Section Memory Protections</h4><p><span>In this example, I’ve allocated all of the executable’s data with identical </span><em>memory protections</em><span>—all bytes in the executable’s data are legal to read, write, </span><em>and</em><span> execute. The point of having different sections at all is to organize data by how it will be accessed and used, so that—for instance—our “read-only data section” can actually be read-only (such that, if any code were to attempt writing to it, it would fail).</span></p><p><span>Because memory protections are assigned at </span><em>page granularity</em><span>, each individual section, after it’s loaded by our toy loader, must be </span><em>at least</em><span> one page size (so that we can assign appropriate protections to each section), and it must be aligned to page boundaries. But, were we actually designing a format, to require all sections be at least one page size (which is normally 4 kilobytes, if not larger), at least </span><em>in the executable image itself </em><span>(as it’s stored in the filesystem), can be fairly wasteful for smaller executables.</span></p><p>Instead of our loaded image being a flat copy from the image file:</p><div><figure><a target="_blank" href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fb1a1b1e4-4a94-4d55-9775-ce0fc7c84407_1278x1446.png" data-component-name="Image2ToDOM" rel=""><div><picture><source type="image/webp" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fb1a1b1e4-4a94-4d55-9775-ce0fc7c84407_1278x1446.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fb1a1b1e4-4a94-4d55-9775-ce0fc7c84407_1278x1446.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fb1a1b1e4-4a94-4d55-9775-ce0fc7c84407_1278x1446.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fb1a1b1e4-4a94-4d55-9775-ce0fc7c84407_1278x1446.png 1456w" sizes="100vw"/><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fb1a1b1e4-4a94-4d55-9775-ce0fc7c84407_1278x1446.png" width="364" height="411.84976525821594" data-attrs="{&#34;src&#34;:&#34;https://substack-post-media.s3.amazonaws.com/public/images/b1a1b1e4-4a94-4d55-9775-ce0fc7c84407_1278x1446.png&#34;,&#34;srcNoWatermark&#34;:null,&#34;fullscreen&#34;:null,&#34;imageSize&#34;:null,&#34;height&#34;:1446,&#34;width&#34;:1278,&#34;resizeWidth&#34;:364,&#34;bytes&#34;:812416,&#34;alt&#34;:null,&#34;title&#34;:null,&#34;type&#34;:&#34;image/png&#34;,&#34;href&#34;:null,&#34;belowTheFold&#34;:true,&#34;topImage&#34;:false,&#34;internalRedirect&#34;:null,&#34;isProcessing&#34;:false}" alt="" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fb1a1b1e4-4a94-4d55-9775-ce0fc7c84407_1278x1446.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fb1a1b1e4-4a94-4d55-9775-ce0fc7c84407_1278x1446.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fb1a1b1e4-4a94-4d55-9775-ce0fc7c84407_1278x1446.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fb1a1b1e4-4a94-4d55-9775-ce0fc7c84407_1278x1446.png 1456w" sizes="100vw" loading="lazy"/></picture><div><div></div></div></div></a></figure></div><p><span>We can adjust it to being an </span><em>expansion</em><span> for each section</span><em> </em><span>to page granularity, and a copy:</span></p><div><figure><a target="_blank" href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F13ac2a39-66e1-4568-a052-b70d2ff91dc5_2048x2048.png" data-component-name="Image2ToDOM" rel=""><div><picture><source type="image/webp" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F13ac2a39-66e1-4568-a052-b70d2ff91dc5_2048x2048.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F13ac2a39-66e1-4568-a052-b70d2ff91dc5_2048x2048.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F13ac2a39-66e1-4568-a052-b70d2ff91dc5_2048x2048.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F13ac2a39-66e1-4568-a052-b70d2ff91dc5_2048x2048.png 1456w" sizes="100vw"/><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F13ac2a39-66e1-4568-a052-b70d2ff91dc5_2048x2048.png" width="518" height="518" data-attrs="{&#34;src&#34;:&#34;https://substack-post-media.s3.amazonaws.com/public/images/13ac2a39-66e1-4568-a052-b70d2ff91dc5_2048x2048.png&#34;,&#34;srcNoWatermark&#34;:null,&#34;fullscreen&#34;:null,&#34;imageSize&#34;:null,&#34;height&#34;:1456,&#34;width&#34;:1456,&#34;resizeWidth&#34;:518,&#34;bytes&#34;:1320933,&#34;alt&#34;:null,&#34;title&#34;:null,&#34;type&#34;:&#34;image/png&#34;,&#34;href&#34;:null,&#34;belowTheFold&#34;:true,&#34;topImage&#34;:false,&#34;internalRedirect&#34;:null,&#34;isProcessing&#34;:false}" alt="" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F13ac2a39-66e1-4568-a052-b70d2ff91dc5_2048x2048.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F13ac2a39-66e1-4568-a052-b70d2ff91dc5_2048x2048.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F13ac2a39-66e1-4568-a052-b70d2ff91dc5_2048x2048.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F13ac2a39-66e1-4568-a052-b70d2ff91dc5_2048x2048.png 1456w" sizes="100vw" loading="lazy"/></picture><div><div></div></div></div></a></figure></div><p><span>To do this, we can introduce a distinction between </span><em>unloaded</em><span> sections (that which stored in an executable image), and </span><em>loaded </em><span>sections (that which are loaded in memory, when a process executes). So far, our toy format has one notion of “offset”. We can break that down into two notions of offset, into two separate spaces—”unloaded space” and “loaded space”. These are generally called “file space” and “virtual space” (where “virtual” refers to a process’ “virtual address space”). Thus, instead of one type of offset, we can have </span><em>file offsets</em><span>, or </span><em>virtual offsets</em><span>. In code, instead of using </span><code>off</code><span> as our naming convention, we can explicitly encode which space we’re working within, by prefixing a name with either </span><code>f</code><span> or </span><code>v</code><span>. For example, “offsets” can now be referred to as either </span><code>foff</code><span> for file offsets, or </span><code>voff</code><span> for virtual offsets.</span></p><p><span>This distinction of </span><em>unloaded</em><span> and </span><em>loaded</em><span> images is the reason for the separation between the terms </span><em>image</em><span> and </span><em>module</em><span>. We call the </span><em>image</em><span> the “cold” equivalent of the data, and we call the </span><em>module</em><span> the “hot”—the loaded—equivalent of the data.</span></p><p><span>We can rewrite our header structure as follows, to encode both the locations of section data within the image, </span><em>and</em><span> to encode where the section data should be arranged </span><em>within memory</em><span> before execution:</span></p><pre><code><code>typedef struct ToyExe_Header ToyExe_Header;
struct ToyExe_Header
{
  U64 magic;   // must be {54 4f 59 45 58 45 00 00}
  U64 padding; // (round up to 64 bytes)
  U64 rw_foff; // read/write (file)
  U64 r_foff;  // read (file)
  U64 x_foff;  // executable (file)
  U64 rw_voff; // read/write (virtual)
  U64 r_voff;  // read (virtual)
  U64 x_voff;  // executable (virtual)
};</code></code></pre><p>Our test program can then be adjusted to the following bytes, assuming 4 kilobyte pages:</p><pre><code><code>{54 4f 59 45 58 45 00 00} (magic)
{00 00 00 00 00 00 00 00} (padding)
{20 00 00 00 00 00 00 00} (read/write data file offset)
{20 00 00 00 00 00 00 00} (read-only data file offset)
{20 00 00 00 00 00 00 00} (executable data file offset)
{00 10 00 00 00 00 00 00} (read/write data virtual offset)
{00 10 00 00 00 00 00 00} (read-only data virtual offset)
{00 10 00 00 00 00 00 00} (executable data virtual offset)
{48 83 ec 18 c7 04 24 00 00 00 00 48 83 c4 18 c3} (executable data)</code></code></pre><p>And our loader can be adjusted to perform the “expansionary copy”:</p><pre><code><code>// unpack f/v dimensions of each section (and header)
U64 fdata_hdr_size = sizeof(*header);
U64 fdata_rw_size  = header-&gt;r_foff - header-&gt;rw_foff;
U64 fdata_r_size   = header-&gt;x_foff - header-&gt;r_foff;
U64 fdata_x_size   = file_size - header-&gt;x_foff;
U64 vdata_hdr_size = fdata_hdr_size;
U64 vdata_rw_size  = header-&gt;r_voff - header-&gt;rw_voff;
U64 vdata_r_size   = header-&gt;x_voff - header-&gt;r_voff;
U64 vdata_x_size   = fdata_x_size;

// round up virtual sizes to 4K boundaries
vdata_hdr_size+= 4095;
vdata_rw_size += 4095;
vdata_r_size  += 4095;
vdata_x_size  += 4095;
vdata_hdr_size-= vdata_hdr_size%4096;
vdata_rw_size -= vdata_rw_size%4096;
vdata_r_size  -= vdata_r_size%4096;
vdata_x_size  -= vdata_x_size%4096;

// calculate total needed virtual size, allocate
U64 vdata_size = (vdata_hdr_size + vdata_rw_size + vdata_r_size + vdata_x_size);
U8 *vdata = (U8 *)VirtualAlloc(0, vdata_size, MEM_RESERVE|MEM_COMMIT, 
                               PAGE_READWRITE);

// unpack parts of virtual data
U8 *vdata_hdr     = vdata + 0;
U8 *vdata_rw      = vdata + header-&gt;rw_voff;
U8 *vdata_r       = vdata + header-&gt;r_voff;
U8 *vdata_x       = vdata + header-&gt;x_voff;

// unpack parts of file data
U8 *fdata         = (U8 *)file_base;
U8 *fdata_hdr     = fdata + 0;
U8 *fdata_rw      = fdata + header-&gt;rw_foff;
U8 *fdata_r       = fdata + header-&gt;r_foff;
U8 *fdata_x       = fdata + header-&gt;x_foff;

// copy &amp; protect
CopyMemory(vdata_hdr, fdata_hdr, fdata_hdr_size);
CopyMemory(vdata_rw, fdata_rw, fdata_rw_size);
CopyMemory(vdata_r, fdata_r, fdata_r_size);
CopyMemory(vdata_x, fdata_x, fdata_x_size);
DWORD old_protect = 0;
VirtualProtect(vdata_hdr, vdata_hdr_size, PAGE_READONLY, &amp;old_protect);
VirtualProtect(vdata_rw, vdata_rw_size, PAGE_READWRITE, &amp;old_protect);
VirtualProtect(vdata_r, vdata_r_size, PAGE_READONLY, &amp;old_protect);
VirtualProtect(vdata_x, vdata_x_size, PAGE_EXECUTE, &amp;old_protect);</code></code></pre><p>And—since it’s easy to notice that this is getting rather repetitive for each section—we can table-drive this “expansionary copy”. Doing so will eliminate most of the per-section duplication:</p><pre><code><code>// gather all information for all boundaries between all sections (&amp; header)
struct
{
  U64 foff;
  U64 voff;
  DWORD protect_flags;
}
boundaries[] =
{
  {0,               0,               PAGE_READONLY},
  {header-&gt;rw_foff, header-&gt;rw_voff, PAGE_READWRITE},
  {header-&gt;r_foff,  header-&gt;r_voff,  PAGE_READONLY},
  {header-&gt;x_foff,  header-&gt;x_voff,  PAGE_EXECUTE},
  {file_size,       0,               PAGE_READONLY},
};
U64 region_count = (sizeof(boundaries)/sizeof(boundaries[0]) - 1);

// calculate vsize for all regions
U64 vdata_size = 0;
for(U64 idx = 0; idx &lt; region_count; idx += 1)
{
  U64 vsize = (boundaries[idx+1].foff - boundaries[idx].foff);
  vsize += 4095;
  vsize -= vsize%4096;
  vdata_size += vsize;
}
boundaries[region_count].voff = vdata_size;

// allocate; iterate regions, do copy &amp; protect
U8 *vdata = (U8 *)VirtualAlloc(0, vdata_size, MEM_RESERVE|MEM_COMMIT, 
                               PAGE_READWRITE);
U8 *fdata = (U8 *)file_data;
DWORD old_protect = 0;
for(U64 idx = 0; idx &lt; region_count; idx += 1)
{
  CopyMemory(vdata + boundaries[idx].voff,
             fdata + boundaries[idx].foff,
             (boundaries[idx+1].foff - boundaries[idx].foff));
  VirtualProtect(vdata + boundaries[idx].voff,
                 (boundaries[idx+1].voff - boundaries[idx].voff),
                 boundaries[idx].protect_flags, &amp;old_protect);
}</code></code></pre><p>It’s not much shorter, but all work for all expanded and copied sections has been deduplicated. In order to adjust this for a larger number of different sections, only the boundary table must change.</p><h4>Imports &amp; Exports</h4><p><span>Now that we have a basic structure for loading our image format, let’s consider how a loader is used. As I’ve stated, an executable image is loaded whenever a program is </span><em>launched</em><span>, or when an executing program requests to dynamically load another image (for instance, through </span><code>LoadLibrary</code><span> or </span><code>dlopen</code><span>).</span></p><p>We’ve already explored the first case—program launching—as that will consist of simply beginning execution of the program. With our toy loader, we can just immediately execute the code after we’ve loaded it:</p><pre><code><code>// call the code
void *vdata_x = (U8 *)vdata + header-&gt;x_voff;
((void (*)())vdata_x)();</code></code></pre><p><span>This makes the assumption that the first instruction stored is our entry point. If we ever wanted that to </span><em>not be the case</em><span>—as “real” executable image formats do—then we can simply store a virtual offset for the desired entry point within the image’s header.</span></p><p><span>But in the case of </span><em>dynamic loading</em><span>, our loader’s job is not to merely begin executing at a single point in some code. Our load instead must load the image, and prepare for dynamic lookups of potentially many named entry points. On Windows, the usage code for this looks something like:</span></p><pre><code>HMODULE foo_library = LoadLibraryA(&#34;foo.dll&#34;);
void (*foo_function)(void) = GetProcAddress(foo_library, &#34;foo_function&#34;);
foo_function();</code></pre><p><span>To facilitate this path, our executable image format must associate a number of names—like </span><code>foo_function</code><span>—with specific virtual offsets in the executable data section. This concept is known as an executable image’s </span><em>exports</em><span>, and it can be straightforwardly encoded as a set of pairs of names and virtual offsets.</span></p><p><span>There’s a symmetric concept known as </span><em>imports</em><span>, which function as a fast path for the manual lookup of functions from a loaded executable image like the above code. On Windows, the usage code for </span><em>that</em><span> looks something like:</span></p><pre><code>__declspec(dllimport) void foo_function(void);
#pragma comment(lib, &#34;foo.lib&#34;)
foo_function();</code></pre><p><span>Both </span><em>explicitly</em><span> loaded (via </span><code>GetProcAddress</code><span> on Windows, or </span><code>dlsym</code><span> on Linux), and </span><em>implicitly</em><span> loaded (via </span><code>__declspec(dllimport)</code><span> on Windows, which is more automatic on Linux toolchains) functions are called through a double indirection. To perform an actual function call, first the CPU must follow the address of the pointer in which the loaded address is stored, </span><em>then</em><span> it can use whatever the value of that pointer as the address of the function to call.</span></p><p><span>In the above example with </span><em>explicit</em><span> loading, the address of the loaded function is stored in the explicit </span><code>foo_function</code><span> function pointer variable. In the above example with </span><em>implicit</em><span> loading, the address of the loaded function is implicitly stored in hidden state, as an implementation detail.</span></p><p><span>When an executable image has imports, in order for the loading of that image to succeed, the associated imports must be dynamically linked. This will be done automatically, as opposed to the program code manually calling—for instance—</span><code>LoadLibrary</code><span> or </span><code>GetProcAddress</code><span>.</span></p><h4>Address Stability &amp; Relocations</h4><p><span>Machine code contained in an executable image can be hardcoded to refer to specific addresses. But as you’ll notice, in our toy loader, we don’t control which address at which our </span><em>module</em><span> for an image is placed in memory. We call </span><code>VirtualAlloc</code><span> to allocate memory for our module data, and whatever address it returns, we use that. Of course, we can </span><em>request</em><span> that </span><code>VirtualAlloc</code><span> place our allocation at a specific address, but that is not necessarily guaranteed to succeed.</span></p><p>This means that if we, for instance, had an image with instructions which referred to a global variable’s absolute address, they would only be valid given that the image is loaded at a particular address. </p><p><span>In principle, a loader could guarantee a fixed virtual address </span><em>for a program’s initially loaded executable image. </em><a href="https://en.wikipedia.org/wiki/Address_space_layout_randomization" rel="">They don’t</a><span>. But in any case, that cannot generally be true, because images can be loaded or unloaded dynamically, and they are not built to be aware of which other images are loaded simultaneously. Thus, they must be dynamically arranged—each image’s code should be able to operate correctly, irrespective of where its loaded module equivalent is placed in memory.</span></p><p><span>In many cases, especially nowadays, addresses are encoded as </span><em>relative to some offset into code</em><span>, in which case they’re always valid, irrespective of which runtime address at which the module is loaded. But, nevertheless, there still exist mechanisms for code to be hardwired to refer to specific addresses. In such cases, an executable image also contains </span><em>relocations</em><span>, which encode locations within the executable image which must be </span><em>reencoded</em><span> after the base address of the loaded image is determined at runtime.</span></p><p>It is the loader’s job to iterate these relocations, and patch in the appropriate addresses given the only-then-available knowledge of where the image’s loaded data is actually stored.</p><div><figure><a target="_blank" href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fc9e7b8be-92da-4f66-9800-cb0686184931_2048x2048.png" data-component-name="Image2ToDOM" rel=""><div><picture><source type="image/webp" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fc9e7b8be-92da-4f66-9800-cb0686184931_2048x2048.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fc9e7b8be-92da-4f66-9800-cb0686184931_2048x2048.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fc9e7b8be-92da-4f66-9800-cb0686184931_2048x2048.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fc9e7b8be-92da-4f66-9800-cb0686184931_2048x2048.png 1456w" sizes="100vw"/><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fc9e7b8be-92da-4f66-9800-cb0686184931_2048x2048.png" width="496" height="496" data-attrs="{&#34;src&#34;:&#34;https://substack-post-media.s3.amazonaws.com/public/images/c9e7b8be-92da-4f66-9800-cb0686184931_2048x2048.png&#34;,&#34;srcNoWatermark&#34;:null,&#34;fullscreen&#34;:null,&#34;imageSize&#34;:null,&#34;height&#34;:1456,&#34;width&#34;:1456,&#34;resizeWidth&#34;:496,&#34;bytes&#34;:689644,&#34;alt&#34;:null,&#34;title&#34;:null,&#34;type&#34;:&#34;image/png&#34;,&#34;href&#34;:null,&#34;belowTheFold&#34;:true,&#34;topImage&#34;:false,&#34;internalRedirect&#34;:null,&#34;isProcessing&#34;:false}" alt="" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fc9e7b8be-92da-4f66-9800-cb0686184931_2048x2048.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fc9e7b8be-92da-4f66-9800-cb0686184931_2048x2048.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fc9e7b8be-92da-4f66-9800-cb0686184931_2048x2048.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fc9e7b8be-92da-4f66-9800-cb0686184931_2048x2048.png 1456w" sizes="100vw" loading="lazy"/></picture><div><div></div></div></div></a></figure></div><h3>And Finally, A Process</h3><blockquote><p><em>An instance of a live, running program. Instantiated by the platform’s loader using the initial executable image to determine how it’s initialized, and what code is initially loaded. The granularity at which operating systems assign virtual address spaces. The container of several modules, and threads of execution.</em></p></blockquote><p><span>We’ve covered everything we need to sketch out a definition of a </span><em>process</em><span>—a running program.</span></p><p><span>Each </span><em>process</em><span> is the owner of some number of </span><em>threads</em><span>, and some number of </span><em>modules</em><span>. It is the owner of a single </span><em>virtual address space</em><span>.</span></p><p><span>Threads and virtual address spaces are, in a sense, </span><em>orthogonal concepts</em><span>—threads are used to virtualize CPU cores, virtual address spaces are used to virtualize physical storage—the </span><em>process</em><span> is the concept which binds them together.</span></p><div><figure><a target="_blank" href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F65f796a4-42e3-48da-9d54-f9757e8017af_2048x2048.png" data-component-name="Image2ToDOM" rel=""><div><picture><source type="image/webp" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F65f796a4-42e3-48da-9d54-f9757e8017af_2048x2048.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F65f796a4-42e3-48da-9d54-f9757e8017af_2048x2048.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F65f796a4-42e3-48da-9d54-f9757e8017af_2048x2048.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F65f796a4-42e3-48da-9d54-f9757e8017af_2048x2048.png 1456w" sizes="100vw"/><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F65f796a4-42e3-48da-9d54-f9757e8017af_2048x2048.png" width="474" height="474" data-attrs="{&#34;src&#34;:&#34;https://substack-post-media.s3.amazonaws.com/public/images/65f796a4-42e3-48da-9d54-f9757e8017af_2048x2048.png&#34;,&#34;srcNoWatermark&#34;:null,&#34;fullscreen&#34;:null,&#34;imageSize&#34;:null,&#34;height&#34;:1456,&#34;width&#34;:1456,&#34;resizeWidth&#34;:474,&#34;bytes&#34;:928209,&#34;alt&#34;:null,&#34;title&#34;:null,&#34;type&#34;:&#34;image/png&#34;,&#34;href&#34;:null,&#34;belowTheFold&#34;:true,&#34;topImage&#34;:false,&#34;internalRedirect&#34;:null,&#34;isProcessing&#34;:false}" alt="" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F65f796a4-42e3-48da-9d54-f9757e8017af_2048x2048.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F65f796a4-42e3-48da-9d54-f9757e8017af_2048x2048.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F65f796a4-42e3-48da-9d54-f9757e8017af_2048x2048.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F65f796a4-42e3-48da-9d54-f9757e8017af_2048x2048.png 1456w" sizes="100vw" loading="lazy"/></picture><div><div></div></div></div></a></figure></div><p>When a program is launched, a process is created, an executable image is loaded to produce an initial module, and an initial thread is spawned.</p><p>An operating system’s scheduler then considers that process’ main thread as a viable candidate for scheduling. When it’s scheduled, the program executes.</p><p><span>When a debugger is used to analyze another program, it does so at process granularity. It is registered by the operating system as being </span><em>attached to a process</em><span>. When a debugger is attached to a process, the operating system enables additional codepaths, which report information about that process’ execution to the debugger’s process. If that information includes addresses, they’re reported as </span><em>virtual addresses</em><span>, within the address space of the process to which the debugger is attached.</span></p><p>But that’s enough for now! We’ll dig into exactly what kind of information an operating system reports to a debugger process, how it can do so, and how the debugger can interact with the debugged process, next time.</p><p>If you enjoyed this post, please consider subscribing. Thanks for reading.</p><p>-Ryan</p></div></div></div>
  </body>
</html>
