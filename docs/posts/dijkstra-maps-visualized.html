<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://www.roguebasin.com/index.php/Dijkstra_Maps_Visualized">Original</a>
    <h1>Dijkstra Maps Visualized</h1>
    
    <div id="readability-page-1" class="page"><div id="mw-content-text" lang="en" dir="ltr"><div>


<p>Dijkstra maps are awesome. They can teach your AI some clever new tricks - and cheaply, too, because the same map can be used for any number of actors. And AI is just the beginning: Dijkstra maps can facilitate automatic exploration, pathfind-to-cursor, and dungeon generation, too.
</p><p>So, what is a Dijkstra map? Take a look:
</p><p><a href="http://www.roguebasin.com/index.php/File:Dijk_basic.png"><img alt="Dijk basic.png" src="http://www.roguebasin.com/images/7/7c/Dijk_basic.png" decoding="async" width="144" height="140"/></a>
</p><p>At its most basic, it indicates distances. In the above image, the map shows how far from the player (&#39;@&#39;) each cell is. (The colors here are just for demonstrative purposes. The numbers are the important part.) Some notes on the implementation can be found <a rel="nofollow" href="http://www.redblobgames.com/pathfinding/tower-defense/">here</a>.
</p><p>Now, I&#39;d like to encourage you to read <a href="http://www.roguebasin.com/index.php/The_Incredible_Power_of_Dijkstra_Maps" title="The Incredible Power of Dijkstra Maps">this fantastic article by Pender(Brian Walker), the creator of Brogue</a>. This article is based heavily on the ideas presented there, and I&#39;ll go into more detail on how they can be achieved.
</p><p>Finished reading that one? Sounds amazing, right? Let&#39;s see if we can get those examples working.
</p>
<h2><span id="--_The_basics_--">-- The basics --</span></h2>
<p>One of the simplest applications of Dijkstra maps is making enemies beeline for the player, taking the shortest path at all times. The image above is all you need. These goblins - 
</p><p><a href="http://www.roguebasin.com/index.php/File:Dijk_goblin.png"><img alt="Dijk goblin.png" src="http://www.roguebasin.com/images/6/6a/Dijk_goblin.png" decoding="async" width="144" height="140"/></a>
</p><p>- can, each turn, simply check each cell adjacent to them, and step to any that has the lowest value.
</p><p><a href="http://www.roguebasin.com/index.php/File:Dijk_goblin2.png"><img alt="Dijk goblin2.png" src="http://www.roguebasin.com/images/f/ff/Dijk_goblin2.png" decoding="async" width="144" height="140"/></a>  <a href="http://www.roguebasin.com/index.php/File:Dijk_goblin3.png"><img alt="Dijk goblin3.png" src="http://www.roguebasin.com/images/4/44/Dijk_goblin3.png" decoding="async" width="144" height="140"/></a>
</p><p>This map only needs to be updated when the player moves, like this:
</p><p><a href="http://www.roguebasin.com/index.php/File:Dijk_goblin4.png"><img alt="Dijk goblin4.png" src="http://www.roguebasin.com/images/5/53/Dijk_goblin4.png" decoding="async" width="144" height="140"/></a>
</p>
<h2><span id="--_Multiple_sources_--">-- Multiple sources --</span></h2>
<p>They work great! If you have multiple sources, the resulting map will lead toward whichever is closest. In this example, we add gold. Goblins now want to attack the player AND collect gold:
</p><p><a href="http://www.roguebasin.com/index.php/File:Dijk_gold.png"><img alt="Dijk gold.png" src="http://www.roguebasin.com/images/f/f7/Dijk_gold.png" decoding="async" width="408" height="248"/></a>
</p><p>(The map will be updated whenever the player moves or gold is collected, so the goblins don&#39;t aim for a target that&#39;s no longer there.)
</p>
<h2><span id="--_Variable_strengths,_and_what_distance_really_means_--"></span><span id="--_Variable_strengths.2C_and_what_distance_really_means_--">-- Variable strengths, and what distance really means --</span></h2>
<p>So, in the previous example, our goblins were happy to collect gold or attack the player, whichever was closest, just by seeking lower values on the map. But what if we want our goblins to be exceptionally greedy, willing to walk farther to reach gold even if the player is actually closer? Here&#39;s how.
</p><p>Instead of starting all of our sources at a value of 0, give the more desirable ones a lower value - let&#39;s use -4 for the gold while keeping the player at 0. Like this:
</p><p><a href="http://www.roguebasin.com/index.php/File:Dijk_gold2.png"><img alt="Dijk gold2.png" src="http://www.roguebasin.com/images/7/70/Dijk_gold2.png" decoding="async" width="408" height="248"/></a>
(Those gray numbers are negatives, so a goblin seeking lower values would move from a 0 to a -1 and so forth.)
</p><p>Why does this work? By starting the gold at a value of -4, we&#39;re treating it as though it were closer than it really is. If a goblin is 7 cells away from gold, and 3 cells away from the player, the -4 modifier means that the goblin will see them as equidistant, and be equally likely to approach either one.
</p>
<h2><span id="--_Fleeing_AI_--">-- Fleeing AI --</span></h2>
<p>Now that we know how to make enemies approach, let&#39;s look at making them flee. What happens if we take the approach map and have them move toward higher numbers? (i.e., darker colors?)
</p><p><a href="http://www.roguebasin.com/index.php/File:Dijk_flee.png"><img alt="Dijk flee.png" src="http://www.roguebasin.com/images/9/9f/Dijk_flee.png" decoding="async" width="328" height="272"/></a>
</p><p>They just end up in the corners, and can&#39;t escape even when the player is right next to them. Here&#39;s how to fix that:
</p><p>First, take the existing approach map and multiply each value by a number close to -1.2. This effectively flips the map so that moving toward the lower numbers (lighter colors) takes you away from the source(s) instead of toward the source(s).
</p><p><a href="http://www.roguebasin.com/index.php/File:Dijk_flee2.png"><img alt="Dijk flee2.png" src="http://www.roguebasin.com/images/d/d7/Dijk_flee2.png" decoding="async" width="328" height="272"/></a>
</p><p>Then, we rescan that map. It&#39;s the same as the basic scan, but we use whatever values happen to be in the map already. After that, we end up with this:
</p><p><a href="http://www.roguebasin.com/index.php/File:Dijk_flee3.png"><img alt="Dijk flee3.png" src="http://www.roguebasin.com/images/d/d6/Dijk_flee3.png" decoding="async" width="328" height="272"/></a>
</p><p>Observe what happened to the spaces around corners and doorways.
</p><p>Note also that what we&#39;ve effectively done is to create a new map using the farthest tiles as the sources, and giving them a bonus for being farther away - the bonus is the 0.2 part of the -1.2 multiplication.
</p><p>Changing that coefficient from -1.2 to a stronger number can have a big effect on the result: The bigger the coefficient, the &#34;closer&#34; a distant cell will be, and the more it&#39;ll &#34;pull&#34; fleeing monsters toward it. Here&#39;s what a coefficient of -1.6 looks like:
</p><p><a href="http://www.roguebasin.com/index.php/File:Dijk_flee4.png"><img alt="Dijk flee4.png" src="http://www.roguebasin.com/images/2/21/Dijk_flee4.png" decoding="async" width="328" height="272"/></a>
</p><p>If the coefficient is too high, the most distant cells will dominate the whole map - a fleeing monster will ONLY want to move to the FARTHEST cell if this happens. If the coefficient is too low, the map won&#39;t change very much from the &#34;bump into corners&#34; version. Experiment with different values to see which you like!
</p>
<h2><span id="--_Automatic_exploration_--">-- Automatic exploration --</span></h2>
<p>Autoexplore is really easy! Just use every unseen cell as a source, and you get this:
</p><p><a href="http://www.roguebasin.com/index.php/File:Dijk_explore.png"><img alt="Dijk explore.png" src="http://www.roguebasin.com/images/4/4e/Dijk_explore.png" decoding="async" width="264" height="152"/></a>
</p><p>The player can now move toward lower values and automatically uncover new territory. Keep doing this each turn until a key is pressed or until something happens (an enemy comes into view; a message is generated; the player takes damage).
</p><p>(Note that this even accounts for the extra turn required to open a door (&#39;+&#39;) before you move through it, by assigning it a cost of 2 instead of 1.)
</p>
<h2><span id="--_Cheap_mouse_pathing_--">-- Cheap mouse pathing --</span></h2>
<p>Let&#39;s say you want to show a visible path onscreen as the player moves the mouse (or other) cursor across the map. Dijkstra maps can provide an optimization so you don&#39;t need to run a normal pathfinder (like A* or regular Dijkstra pathfinding) every time the cursor moves to a new cell.
</p><p><a href="http://www.roguebasin.com/index.php/File:Dijk_cursor.png"><img alt="Dijk cursor.png" src="http://www.roguebasin.com/images/c/c7/Dijk_cursor.png" decoding="async" width="264" height="152"/></a>
</p><p>By calculating a single Dijkstra map when the cursor moves onto the map (for the first time on each turn), you can simply roll from the cursor to the player to find a path (then, of course, reverse that path so it leads from the player to the cursor).
</p><p>(I recommend having a way to ensure that the path you see is the path you take - I prefer a deterministic pathfinding routine for the player, and a randomized one for enemies.)
</p><p>Like autoexplore, this one treats unexplored cells like they&#39;re regular floors, so it&#39;s possible to choose an impossible path. That&#39;s fine - you&#39;ll just need to stop the player once it&#39;s clear that the chosen path leads into a wall.
</p><p><a href="http://www.roguebasin.com/index.php/File:Dijk_cursor2.png"><img alt="Dijk cursor2.png" src="http://www.roguebasin.com/images/f/f1/Dijk_cursor2.png" decoding="async" width="264" height="152"/></a>
</p>
<h2><span id="--_Moving_into_optimal_range_--">-- Moving into optimal range --</span></h2>
<p>Want your ranged enemies to stay at a certain range? Start with a Dijkstra map from the player, and then create another one - the source cells will be the cells on the first map with the desired range:
</p><p><a href="http://www.roguebasin.com/index.php/File:Dijk_range.png"><img alt="Dijk range.png" src="http://www.roguebasin.com/images/8/8c/Dijk_range.png" decoding="async" width="264" height="152"/></a>
</p><p>But, you probably want to go one step further, and say that the source cells will be the cells on the first map with the desired range...to which the player has line of sight:
</p><p><a href="http://www.roguebasin.com/index.php/File:Dijk_range2.png"><img alt="Dijk range2.png" src="http://www.roguebasin.com/images/e/eb/Dijk_range2.png" decoding="async" width="264" height="152"/></a>
</p>
<h2><span id="--_Hazard_avoidance_--">-- Hazard avoidance --</span></h2>
<p><a href="http://www.roguebasin.com/index.php/File:Dijk_water.png"><img alt="Dijk water.png" src="http://www.roguebasin.com/images/1/11/Dijk_water.png" decoding="async" width="576" height="380"/></a>
</p><p>If the player can swim, but only for a few turns, you can use a map like this one, calculated just once when the map is created. Track the remaining swimming turns, and if the player tries to move to a cell with a value greater than the remaining turns, you can prevent that move and give a warning.
</p><p>I hope these examples help to illustrate just how useful Dijkstra maps can be. Good luck!
</p>
<!-- 
NewPP limit report
Cached time: 20230117175155
Cache expiry: 86400
Dynamic content: false
Complications: []
CPU time usage: 0.082 seconds
Real time usage: 4.257 seconds
Preprocessor visited node count: 43/1000000
Post‐expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 2/40
Expensive parser function count: 0/100
Unstrip recursion depth: 0/20
Unstrip post‐expand size: 0/5000000 bytes
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%    0.000      1 -total
-->

<!-- Saved in parser cache with key 133099?hbasin:pcache:idhash:7906-0!canonical and timestamp 20230117175151 and revision id 45312. Serialized with JSON.
 -->
</div>
</div></div>
  </body>
</html>
