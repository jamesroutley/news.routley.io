<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://seirdy.one/posts/2022/06/10/cli-best-practices/">Original</a>
    <h1>Best Practices for Inclusive CLIs</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
				<meta itemprop="author" content="Rohan Kumar"/>
				
				<p>This began as a reply to another article by Lucas F. Costa; it lists practices to improve user-experience (<abbr title="User Experience">UX</abbr>) of command-line interfaces (<abbr title="Command-Line Interface">CLIs</abbr>). It comes from a good place, and has some good advice: I particularly like its advice on input-validation and understandable errors. Unfortunately, a number of its suggestions are problematic, particularly from an accessibility perspective.</p>
				<p role="doc-tip">Note: this article specifically concerns CLIs, not full-blown textual user interfaces (<abbr title="Textual User Interfaces">TUIs</abbr>). It also focuses on utilities for UNIX-like shells; other command-line environments may have different conventions.</p>
				<h2 id="problematic-patterns" tabindex="-1">Problematic patterns</h2>
				<p><a id="problematic-patterns-anchor" href="#problematic-patterns" aria-labelledby="problematic-patterns-prefix problematic-patterns">
					<span id="problematic-patterns-prefix">Permalink to section</span>
				</a></p><p>The “Getting Started Experience” section of Lucas’ article has a GIF video of a CLI utility printing <code>--help</code> output, featuring a decorative border.</p>
				<figure aria-labelledby="code-1" itemprop="hasPart" itemscope="" itemtype="https://schema.org/SoftwareSourceCode">
					<figcaption id="code-1-caption"><span id="code-1" tabindex="-1"><strong itemprop="name"><span itemprop="codeSampleType">Code snippet</span> 1</strong> (<span itemprop="programmingLanguage">console</span>)</span>:
Lucas’ article leads with an example <samp>--help</samp> output that’s surrounded by a decorative textual border. This is a transcription of the output, wrapped to a narrower width.
</figcaption>
					<pre tabindex="0"><samp translate="no" itemprop="text">$ tool --help

╔ Getting started ════════════════════════════════════════╗
║                                                         ║
║  To scaffold a new project, run:                        ║
║                                                         ║
║    $ mytool init &lt;directory&gt;                            ║
║                                                         ║
║  If you already have a project set up and would like to ║
║  add, remove, or update its structure, run:             ║
║                                                         ║
║    $ mytool manage                                      ║
║                                                         ║
╚═════════════════════════════════════════════════════════╝

Usage: tool &lt;command&gt; [options] 
Commands:
  tool init [directory]	creates a new project
  tool manage	allows you to manage an existing project 

Options:
  --help	Show help	[boolean]
  --version	Show version number	[boolean] </samp></pre>
				</figure>
				<ol>
					<li>
						<p>Borders in TUIs should always be drawn with characters specifically intended for textual interfaces (e.g., boxdraw characters). While I do think the GIF followed this advice, I think it’s worth explicitly saying it. Accessible terminal emulators can figure out what these mean and factor them into what they report through an accessibility API. But breaking these borders up with descriptive text makes detection of readable text error-prone.</p>
					</li>
					<li>
						<p>Borders should be used sparingly, as they end up causing issues when the window is re-sized.<sup><a href="#fn:1" id="fnref:1" role="doc-noteref">note 1</a></sup> Re-sizing terminal windows is quite common: think about the combined user-base of tiling window managers, tiling terminal session managers (Tmux, Screen, etc.), multiplexing terminal emulators, and plain old split-windows.</p>
					</li>
					<li>
						<p>Decorative content in CLI output should be limited, since the output of CLI utilities can be piped through other programs. At the very least, these tools should be able to detect whether their standard output is being re-directed or piped and sanitize output accordingly.</p>
					</li>
				</ol>
				<p>The “Colours, Emojis, and Layouting” (sic) section has similar issues:</p>
				<ol>
					<li>
						<p>Nearly all animated spinners are extremely problematic for screenreaders. A simple progress meter and/or numeric percentage combined with flags to enable/disable them is preferable.</p>
					</li>
					<li>
						<p>Excessive animation and color can be harmful to users with attention and/or vestibular disorders, and some on the autism spectrum. Many tools offer a <code>--color[=WHEN]</code> flag where <code>WHEN</code> is <code>always</code>, <code>never</code>, or <code>auto</code>. Expecting users to learn all the color configurations for all their tools is unrealistic; tools should <a href="https://no-color.org/">respect the <code>NO_COLOR</code> environment variable.</a></p>
					</li>
				</ol>
				<h2 id="recommendations" tabindex="-1">Recommen­dations</h2>
				<p><a id="recommendations-anchor" href="#recommendations" aria-labelledby="recommendations-prefix recommendations">
					<span id="recommendations-prefix">Permalink to section</span>
				</a></p><p>This is a non-exhaustive list of simple, baseline recommendations for designing CLI utilities.</p>
				<ol>
					<li>
						<p>Send your tool’s output through a program like <code>espeak-ng</code> and listen to it. Can you make sense of the output?</p>
					</li>
					<li>
						<p>How “unique” is your tool’s output? Output should look as similar to other common utilities as possible, to reduce the learning curve. Keep it boring.</p>
					</li>
					<li>
						<p>Refer to the latest <abbr title="Web Content Accessibility Guidelines">WCAG</abbr> publication (currently WCAG 2.2) and take a look at the applicable criteria. Many have <a href="https://w3c.github.io/wcag/techniques/#text">accompanying techniques for plain-text interfaces.</a>. Avoiding reliance on color and using whitespace and/or indentation for pseudo-headings are two sample recommendations from the WCAG.</p>
					</li>
					<li>
						<p>Write man pages! Man pages have a standardized,<sup><a href="#fn:2" id="fnref:2" role="doc-noteref">note 2</a></sup> predictable, searchable format. Many screen-reader users actually have special scripts to make it easy to read man pages. A man page is also trivial to convert to HTML for people who prefer web-based documentation.<sup><a href="#fn:3" id="fnref:3" role="doc-noteref">note 3</a></sup> If your utility has a config file with special syntax or vocabulary, write a dedicated man page for it in section 5 and mention it in a “SEE ALSO” section.<sup><a href="#fn:4" id="fnref:4" role="doc-noteref">note 4</a></sup></p>
					</li>
					<li>
						<p>Try adding shell completions for your program, so users can tab-complete options. This is particularly helpful in shells like Zsh that support help-text in tab completions, especially when combined with plugins like <a href="https://github.com/Aloxaf/fzf-tab">fzf-tab</a> that enable fuzzy-searching help-text (see <a href="#code-2">code snippet 2</a>).</p>
					</li>
					<li>
						<p>Related to no. 5: use a well-understood format for <code>-h</code> and <code>--help</code> output. This makes auto-generating shell completions much easier. Alternatively, delegate the generation of both to a library that follows this advice.</p>
					</li>
					<li>
						<p>Follow convention: use POSIX-like options. Consider supplementing them with GNU-style long options if your tool has a significant number of them.<sup><a href="#fn:5" id="fnref:5" role="doc-noteref">note 5</a></sup></p>
					</li>
					<li>
						<p>Either delegate output wrapping to the terminal, or detect the number of columns and format output to fit. Prefer the former when given a choice, especially when the output is not a TTY.</p>
					</li>
					<li>
						<p>Make sure your web-based documentation and forge frontends are accessible, or are mirrored somewhere with good accessibility. I love what the Gitea folks are doing, but sadly their web frontend has a number of critical issues.<sup><a href="#fn:6" id="fnref:6" role="doc-noteref">note 6</a></sup> For now, if your forge has accessibility issues, mirroring to GitHub and/or Sourcehut seems like a good option.</p>
					</li>
					<li>
						<p>Avoid breaking changes to you program’s CLI. Remember that its argument parsing is an API, unless documentation explicitly states otherwise.<sup><a href="#fn:7" id="fnref:7" role="doc-noteref">note 7</a></sup> Semantic versioning is your friend.</p>
					</li>
					<li>
						<p>Be predictable. Users expect <code>git log</code> to print a commit log. Users do not expect <code>git log</code> to make network connections, write something to their filesystem, etc. Try to only perform the minimum functionality suggested by the command. Naturally, this disqualifies opt-out telemetry.</p>
					</li>
				</ol>
				<figure aria-labelledby="code-2" itemprop="hasPart" itemscope="" itemtype="https://schema.org/SoftwareSourceCode">
					<figcaption id="code-2-caption"><span id="code-2" tabindex="-1"><strong itemprop="name"><span itemprop="codeSampleType">Code snippet</span> 2</strong> (<span itemprop="programmingLanguage">console</span>)</span>:
This is what tab-completion for <a href="https://sr.ht/~seirdy/moac">MOAC</a> looks like with fzf-tab.
</figcaption>
					<pre tabindex="0"><samp translate="no" itemprop="text">$ moac -
&gt; -p
  9/11 (0)
  -P  -- power available to the computer (W)
&gt; -p  -- password to analyze
  -s  -- password entropy
  -h  -- display this help message
  -r  -- interactively enter a password in the terminal; overrides -p
  -T  -- temperature of the system (K)
  -m  -- mass at attacker&#39;s disposal (kg)
  -q  -- account for quantum computers using Grover&#39;s algorithm</samp></pre>
				</figure>
				<h3 id="more-opinionated-considerations" tabindex="-1">More opinionated considerations</h3>
				<p>These considerations are far more subjective, debatable, and deserving of skepticism than the previous recommendations. There’s a reason I call this section “considerations”, not “recommendations”. Exceptions abound; I’m not here to think on your behalf.</p>
				<ol>
					<li>
						<p>Remember that users aren’t always at their best when they read <code>--help</code> output; they could be trying to solve a frustrating problem, feeling a great deal of anxiety. Keep the output clean, predictable, boring, and <em>fast.</em> A 2-second delay and spinning fans will probably be extremely unpleasant for already-stressed users, especially if they need to use it often.<sup><a href="#fn:8" id="fnref:8" role="doc-noteref">note 8</a></sup></p>
					</li>
					<li>
						<p>Include example usage in your man pages and accompanying documentation. Consider submitting the example usage to the <a href="https://tldr.sh/">tldr pages</a> project if your tool gets popular.</p>
					</li>
					<li>
						<p>Include an extended list of example command invocations and expected output. Make that document double as a test suite. My <a href="https://git.sr.ht/~seirdy/moac/tree/master/item/cmd/moac/testdata/scripts"><code>moac</code> testdata</a> and <a href="https://git.sr.ht/~seirdy/moac/tree/master/item/cmd/moac-pwgen/testdata/scripts"><code>moac-pwgen</code> testdata</a> scripts are good examples. This can serve as a check for API stability, and even as a source of documentation.</p>
					</li>
					<li>
						<p>Make your man pages as similar to other man pages on the target OS as possible. Many programs parse man pages, and expect them to follow a predictable structure. Try testing your man pages in multiple programs, just as people test Web pages in multiple browser engines. <a href="https://manpages.debian.org/unstable/w3m/w3mman.1.en.html"><code>w3mman</code></a> (included in <a href="https://github.com/tats/w3m">w3m</a>) is a good example to make sure auto-hyperlinking works. <a href="https://pandoc.org/">Pandoc</a> is another tool worth trying.</p>
					</li>
					<li>
						<p>Conform to tools that share a similar niche. If you’re using Rust to make a fast alternative to popular coreutils: model its behavior, help-text, and man pages after <code>ripgrep</code> and <code>fd</code>. If you’re making a linter for Go: copy <code>go vet</code>.</p>
					</li>
					<li>
						<p>If you want to keep your tool simple, make the output readable to both humans and machines; it should work well when streamed to another program’s standard input and when parsed by a person. This is especially useful when people redirect output streams to log files.</p>
					</li>
					<li>
						<p>Consider splitting related functionality between many executables (the UNIX way) and/or sub-commands (like Git). I split <a href="https://sr.ht/~seirdy/moac">MOAC’s</a> functionality across both <code>moac</code> and <code>moac-pwgen</code>, and gave <code>moac</code> three subcommands. The <a href="https://lucasfcosta.com/2022/06/01/ux-patterns-cli-tools.html#consistent-commands-trees">“Consistent commands trees”</a> section of Lucas’ article has good advice.</p>
					</li>
					<li>
						<p>Don’t conflate CLIs and TUIs. A CLI should be non-interactive; a TUI should be interactive. Exceptions exist for really simple interfaces (e.g. Magic-Wormhole and others like it) that accept user input; however, as the interface grows more complex, consider splitting the program into two sibling programs, one of which can have a “pure” non-interactive CLI.</p>
					</li>
					<li>
						<p>Go above and beyond by writing separate integrations for environments like <a href="http://emacspeak.sourceforge.net/">Emacspeak</a>.<sup><a href="#fn:9" id="fnref:9" role="doc-noteref">note 9</a></sup></p>
					</li>
				</ol>
				<h2 id="name-conflicts" tabindex="-1">Name conflicts</h2>
				<p><a id="name-conflicts-anchor" href="#name-conflicts" aria-labelledby="name-conflicts-prefix name-conflicts">
					<span id="name-conflicts-prefix">Permalink to section</span>
				</a></p><p>This section might be the most important part of this post. If a CLI executable has a binary name conflict, packagers may have to re-name it. Otherwise, users will have to juggle <code>$PATH</code> overrides.<sup><a href="#fn:10" id="fnref:10" role="doc-noteref">note 10</a></sup></p>
				<p>Before publishing your software, test for binary name conflicts. Many package managers have built-in functionality to search for package files. I recommend doing so with large repositories to test for conflicts.</p>
				<figure aria-labelledby="code-3" itemprop="hasPart" itemscope="" itemtype="https://schema.org/SoftwareSourceCode">
					<figcaption id="code-3-caption"><span id="code-3" tabindex="-1"><strong itemprop="name"><span itemprop="codeSampleType">Code snippet</span> 3</strong> (<span itemprop="programmingLanguage">console</span>)</span>:
On Fedora and derivatives, use DNF to query package contents. You can also check <samp>cht.sh</samp> for other common commands.
</figcaption>
					<pre tabindex="0"><samp translate="no" itemprop="text">$ dnf provides /usr/bin/p
Last metadata expiration check: 0:48:19 ago [...]
perl-App-p-0.0400-19.fc36.noarch : Steroids for your perl one-liners
Repo        : fedora
Matched from:
Filename    : /usr/bin/p

$ curl https://cht.sh/fly
# fly
# Command-line tool for concourse-ci.
# More information: &lt;https://concourse-ci.org/fly.html&gt;.
[...]</samp></pre>
				</figure>
				<p>Thanks to Emily for <a href="https://sparkly.uni.horse/@emily/108451871152495325">reminding me of name conflicts.</a></p>
				<section role="doc-bibliography">
					<h2 id="references-and-further-reading" tabindex="-1">References and further reading</h2>
					<a id="references-and-further-reading-anchor" href="#references-and-further-reading" aria-labelledby="references-and-further-reading-prefix references-and-further-reading">
						<span id="references-and-further-reading-prefix">Permalink to section</span>
					</a>
					<ol>
						<li>
							<p itemprop="citation" role="doc-credit" itemscope="" itemtype="https://schema.org/ScholarlyArticle">Harini Sampath, Alice Merrick, and Andrew Macvean. 2021. <em><cite itemprop="name headline"><a itemprop="url" href="https://dl.acm.org/doi/fullHtml/10.1145/3411764.3445544">Accessibility of Command Line Interfaces</a></cite>. In CHI Conference on Human Factors in Computing Systems (CHI ‘21), May 8–13, 2021, Yokohama, Japan.</em> ACM, New York, NY, USA 10 Pages. <a href="https://doi.org/10.1145/3411764.3445544">DOI 10.1145/3411764.3445544</a></p>
						</li>
						<li>
							<p itemprop="citation" role="doc-credit" itemscope="" itemtype="https://schema.org/TechArticle"><cite itemprop="name headline"><a itemprop="url" href="https://www.w3.org/WAI/WCAG22/Techniques/#text">Techniques for WCAG 2.2</a></cite>. Alastair Campbell, Michael Cooper, Andrew Kirkpatrick. W3C. <time datetime="2022-05-30">2022-05-30</time>.</p>
						</li>
						<li>
							<p itemprop="citation" role="doc-credit" itemscope="" itemtype="https://schema.org/Book"><cite itemprop="name"><a itemprop="url" href="https://clig.dev/">Command Line Interface Guidelines</a></cite>. Aanand Prasad, Ben Firshman, Carl Tashian, Eva Parish. Commit <code>89d755c</code>, <time datetime="2022-04-19">2022-04-19</time>.</p>
						</li>
					</ol>
				</section>
				<hr/>
				<section role="doc-endnotes" aria-labelledby="note-hd">
					<h2 id="note-hd">Footnotes</h2>
					<ol>
						<li id="fn:1" tabindex="-1">
							<p>Yes, it’s possible to support re-sizing by using a TUI library like ncurses. Unfortunately, TUIs are out of scope for this article; I’m focusing mainly on CLIs. <a href="#fnref:1" aria-labelledby="bl-1" role="doc-backlink">↩︎ </a></p>
						</li>
						<li id="fn:2" tabindex="-1">
							<p>Well, they’re <em>somewhat</em> standardized compared to plain stdout. <a href="#fnref:2" aria-labelledby="bl-2" role="doc-backlink">↩︎ </a></p>
						</li>
						<li id="fn:3" tabindex="-1">
							<p><a href="https://seirdy.one/posts/2020/11/23/website-best-practices/">My other article on accessible textual websites</a> is probably relevant when it comes to Web-based documentation <a href="#fnref:3" aria-labelledby="bl-3" role="doc-backlink">↩︎ </a></p>
						</li>
						<li id="fn:4" tabindex="-1">
							<p>For more on man page sections, see the <a href="https://man.openbsd.org/man"><code>man(1)</code></a> man page. <a href="#fnref:4" aria-labelledby="bl-4" role="doc-backlink">↩︎ </a></p>
						</li>
						<li id="fn:5" tabindex="-1">
							<p>I need to take my own advice for programs like <a href="https://sr.ht/~seirdy/moac">moac</a>. Ugh. <a href="#fnref:5" aria-labelledby="bl-5" role="doc-backlink">↩︎ </a></p>
						</li>
						<li id="fn:6" tabindex="-1">
							<p>See <a href="https://mastodon.technology/@codeberg/108403449317373462">this Fediverse thread</a> about forge accessibility. <a href="#fnref:6" aria-labelledby="bl-6" role="doc-backlink">↩︎ </a></p>
						</li>
						<li id="fn:7" tabindex="-1">
							<p>For a good example, see Git’s distinction between regular output and porcelain-friendly output. The instability of the former and stability of the latter are explicitly documented in the Git man pages and in the official Git book. <a href="#fnref:7" aria-labelledby="bl-7" role="doc-backlink">↩︎ </a></p>
						</li>
						<li id="fn:8" tabindex="-1">
							<p>The slow responses to basic flags like <code>--help</code> is one of many reasons I dislike Java command-line utilities (signal-cli, Nu HTML Checker). I believe I’m not alone when I say this. <a href="#fnref:8" aria-labelledby="bl-8" role="doc-backlink">↩︎ </a></p>
						</li>
						<li id="fn:9" tabindex="-1">
							<p>I used to not-very-seriously claim that Neovim, my preferred <code>$EDITOR</code>, is better than Emacs. Then I tried Emacspeak. I still make the same claim, but more softly and with an exception for Emacspeak. <a href="#fnref:9" aria-labelledby="bl-9" role="doc-backlink">↩︎ </a></p>
						</li>
						<li id="fn:10" tabindex="-1">
							<p>A notable exception is executables that are supposed to conflict with others. Distributions like Fedora, Debian, and derivatives have an “alternatives” system to manage these overrides using symlinks. Examples include toolchains (<code>cc</code> and <code>ld</code> could point to their GCC or Clang implementations) and mail transfer agents (<code>sendmail</code> and <code>mta</code> have been re-implemented many times over). <a href="#fnref:10" aria-labelledby="bl-10" role="doc-backlink">↩︎ </a></p>
						</li>
					</ol>
				</section>
			</div></div>
  </body>
</html>
