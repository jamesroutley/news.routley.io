<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.redhat.com/sysadmin/podman-inside-container">Original</a>
    <h1>How to use Podman inside of a container (2021)</h1>
    
    <div id="readability-page-1" class="page"><div>

  
    

      
            <div property="schema:text"><p>One of the most asked about topics to folks working on upstream container technologies is running <a href="https://podman.io/" target="_blank">Podman</a> within a container. Most of this has historically been related to Docker in Docker (DIND), but now, people also want to run Podman in Podman (PINP) or Podman in Docker (PIND).</p>


<p>But Podman can be run in multiple ways, rootful and rootless. We end up with people wanting to run various combinations of rootful and rootless Podman:</p>

<ul><li>Rootful Podman in rootful Podman</li>
	<li>Rootless Podman in rootful Podman</li>
	<li>Rootful Podman in rootless Podman</li>
	<li>Rootless Podman in rootless Podman</li>
</ul><p>You get the picture.</p>

<p>This blog will attempt to cover each combination, starting with a discussion of privileges. We&#39;ll start with the PINP scenario here in part one. In part two of the series, we&#39;ll cover similar ground but do so within the <a href="https://reserialised.routley.io/sysadmin/podman-inside-kubernetes">context of Kubernetes</a>. Be sure to read both articles for a complete picture.</p>

<h2>Container engines require privileges</h2>

<p>In order to run a container engine like Podman within a container, the first thing you need to understand is that you need a fair amount of privilege.</p>

<ul><li>Containers require multiple UIDs. Most container images need more than one UID to work. For example, you might have an image with most of the files owned by root, but some owned by the apache user (UID=60).</li>
	<li>Container engines mount file systems and use the system call clone to create user namespaces.</li>
</ul><p>Note: You might need a newer version of Podman.  Examples in this blog were run with Podman 3.2.</p>

<h3>Our test image</h3>

<p>For the examples in this blog, we&#39;ll use the <code>quay.io/podman/stable</code> image, which was built with the idea of finding the best way to run Podman within a container. You can examine how we build this image from the Dockerfile and <code>containers.conf</code> image in the <a href="https://github.com/containers/podman/tree/master/contrib/podmanimage/stable" target="_blank">github.com repo</a>.</p>

<pre><code># stable/Dockerfile
#
# Build a Podman container image from the latest
# stable version of Podman on the Fedoras Updates System.
# https://bodhi.fedoraproject.org/updates/?search=podman
# This image can be used to create a secured container
# that runs safely with privileges within the container.
#
FROM registry.fedoraproject.org/fedora:latest

# Don&#39;t include container-selinux and remove
# directories used by yum that are just taking
# up space.
RUN dnf -y update; yum -y reinstall shadow-utils; \
yum -y install podman fuse-overlayfs --exclude container-selinux; \
rm -rf /var/cache /var/log/dnf* /var/log/yum.*

RUN useradd podman; \
echo podman:10000:5000 &gt; /etc/subuid; \
echo podman:10000:5000 &gt; /etc/subgid;

VOLUME /var/lib/containers
VOLUME /home/podman/.local/share/containers

ADD https://raw.githubusercontent.com/containers/libpod/master/contrib/podmanimage/stable/containers.conf /etc/containers/containers.conf
ADD https://raw.githubusercontent.com/containers/libpod/master/contrib/podmanimage/stable/podman-containers.conf /home/podman/.config/containers/containers.conf

RUN chown podman:podman -R /home/podman

# chmod containers.conf and adjust storage.conf to enable Fuse storage.
RUN chmod 644 /etc/containers/containers.conf; sed -i -e &#39;s|^#mount_program|mount_program|g&#39; -e &#39;/additionalimage.*/a &#34;/var/lib/shared&#34;,&#39; -e &#39;s|^mountopt[[:space:]]*=.*$|mountopt = &#34;nodev,fsync=0&#34;|g&#39; /etc/containers/storage.conf
RUN mkdir -p /var/lib/shared/overlay-images /var/lib/shared/overlay-layers /var/lib/shared/vfs-images /var/lib/shared/vfs-layers; touch /var/lib/shared/overlay-images/images.lock; touch /var/lib/shared/overlay-layers/layers.lock; touch /var/lib/shared/vfs-images/images.lock; touch /var/lib/shared/vfs-layers/layers.lock

ENV _CONTAINERS_USERNS_CONFIGURED=&#34;&#34;
</code></pre>

<p>Let’s examine the Dockerfile.</p>

<pre><code>FROM registry.fedoraproject.org/fedora:latest

# Don&#39;t include container-selinux and remove
# directories used by yum that are just taking
# up space.
RUN dnf -y update; yum -y reinstall shadow-utils; \
yum -y install podman fuse-overlayfs --exclude container-selinux; \
rm -rf /var/cache /var/log/dnf* /var/log/yum.*
</code></pre>

<p>First pull fedora latest, and then update to the latest packages.  Note it reinstalls <code>shadow-utils</code>, since there is a known issue in the <code>shadow-utils</code> install on the Fedora image where the <code>filecaps</code> on <code>newsubuid</code> and <code>newsubgid</code> are not set.  Reinstalling <code>shadow-utils</code> fixes the problem.  Next, install Podman as well as the <code>fuse-overlayfs</code>.  We don’t install <code>container-selinux</code> because it is not needed within the container.</p>

<pre><code>RUN useradd podman; \
echo podman:10000:5000 &gt; /etc/subuid; \
echo podman:10000:5000 &gt; /etc/subgid;
</code></pre>

<p>Next I create a user <code>podman</code> and set up the <code>/etc/subuid</code> and <code>/etc/subgid</code> files to use 5000 UIDs.  This is used to set up User Namespace within the container.  5000 is an arbitrary number and potentially too small.  We picked this number because it is smaller than the 65k allocated to rootless users.  If you were only running the container as root, 65k would have been a better number.</p>

<pre><code>VOLUME /var/lib/containers
VOLUME /home/podman/.local/share/containers
</code></pre>

<p>Since we can run rootfull and rootless containers with this image we create two volumes.  Rootfull Podman uses <code>/var/lib/containers</code>  for it’s container storage and rootless uses <code>/home/podman/.local/share/containers</code>.  Overlay over overlay is often denied by the kernel, so this creates non overlay volumes to be used within the container.</p>

<pre><code>ADD https://raw.githubusercontent.com/containers/libpod/master/contrib/podmanimage/stable/containers.conf /etc/containers/containers.conf
ADD https://raw.githubusercontent.com/containers/libpod/master/contrib/podmanimage/stable/podman-containers.conf /home/podman/.config/containers/containers.conf
</code></pre>

<p>I have pre-configured two <code>containers.conf</code> files to make sure containers run easier in each mode.</p>

<p>The image is set up to run with fuse-overlayfs by default. In certain cases, you could run the kernel&#39;s overlay file system for rootful mode, and you&#39;ll soon be able to do this in rootless mode. However, for now, we use fuse-overlayfs as our container storage within the container. Other people have used VFS storage driver, but this is not that efficient.</p>

<h3>The --privileged flag</h3>

<p>The easiest way to run Podman inside of a container is to use the <code>--privileged</code> flag.</p>

<h4>Rootful Podman in rootful Podman with --privileged</h4>

<pre><code># podman run --privileged quay.io/podman/stable podman run ubi8 echo hello
Resolved &#34;ubi8-minimal&#34; as an alias (/etc/containers/registries.conf.d/shortnames.conf)
Trying to pull registry.access.redhat.com/ubi8:latest...
Getting image source signatures
Copying blob sha256:a591faa84ab05242a17131e396a336da172b0e1ec66d921c9f130b7c4c24586d
Copying blob sha256:76b9354adec626b01ffb0faae4a217cebd616661fd90c4b54ba4415f53392fb8
Copying config sha256:dc080723f596f2407300cca2c19a17accad89edcf39f7b8b33e6472dd41e30f1
Writing manifest to image destination
Storing signatures
hello</code></pre>

<p>To save time, since I will be doing a lot of experiments, I created a directory on my host <code>./mycontainers</code>, which I will volume mount into the container to be used and not have to pull the image each time.</p>

<pre><code># podman run --privileged -v ./mycontainers:/var/lib/containers quay.io/podman/stable podman run ubi8 echo hello
hello</code></pre>

<h4>Rootless Podman in rootful Podman with --privileged</h4>

<p>The <code>quay.io/podman/stable</code> image is set up with a <strong>podman</strong> user that you can use to run rootless containers.</p>

<pre><code># podman run --user podman --privileged quay.io/podman/stable podman run ubi8 echo hello
Resolved &#34;ubi8&#34; as an alias (/etc/containers/registries.conf.d/shortnames.conf)
...
hello</code></pre>

<p>Note in this case, the Podman running inside the container is running as the user <strong>podman</strong>. This is because the containerized Podman uses the user namespace to create a confined container within the privileged container.</p>

<h4>Running rootless Podman in Docker with --privileged</h4>

<p>Similar to rootful Podman, you can also run rootless Podman within Docker with the <code>--privileged</code> option.</p>

<pre><code># docker run --privileged quay.io/podman/stable podman run ubi8 echo hello</code></pre>

<p>Rootless Podman with Docker</p>

<pre><code># docker run --user podman --privileged quay.io/podman/stable podman run ubi8 echo hello
Resolved &#34;ubi8&#34; as an alias (/etc/containers/registries.conf.d/shortnames.conf)
...
hello</code></pre>

<h2>Can we do this more securely?</h2>


<p>Notice that even though we ran the outer containers <code>--privileged</code> above, the inner containers are running in locked-down mode. The rootless Podman running within the container is really locked down and would have a very difficult time escaping. Given that, I am not a fan of using the <code>--privileged</code> flag. I believe we can do better from a security perspective.</p>

<h3>Running without the --privileged flag</h3>

<p>Let&#39;s look at how we can remove the <code>--privileged</code> flag for better security.</p>

<h4>Rootful Podman in rootful Podman without --privileged</h4>

<pre><code># podman run --cap-add=sys_admin,mknod --device=/dev/fuse --security-opt label=disable quay.io/podman/stable podman run ubi8-minimal echo hello
hello</code></pre>

<p>We can eliminate the <code>--privileged</code> flag from rootful Podman but still have to disable some security features to make rootful Podman within the container work.</p>

<ol><li>Capabilities: <code>--cap-add=sys_admin,mknod</code> We need to add two Linux capabilities.

	<ol type="a"><li><strong>CAP_SYS_ADMIN</strong> is required for the Podman running as root inside of the container to mount the required file systems.</li>
		<li><strong>CAP_MKNOD</strong> is required for Podman running as root inside of the container to create the devices in <code>/dev</code>. (Note that Docker allows this by default).</li>
	</ol></li>
	<li>Devices: The <code>--device /dev/fuse</code> flag must use fuse-overlayfs inside the container. This option tells Podman on the host to add <code>/dev/fuse</code> to the container so that containerized Podman can use it.</li>
	<li>Disable SELinux: The <code>--security-opt label=disable</code> option tells the host&#39;s Podman to disable SElinux separation for the container. SELinux does not allow containerized processes to mount all of the file systems required to run inside a container.</li>
</ol><h4>Rootful Podman in Docker without --privileged</h4>

<pre><code># docker run --cap-add=sys_admin --cap-add mknod --device=/dev/fuse --security-opt seccomp=unconfined --security-opt label=disable quay.io/podman/stable podman run ubi8-minimal echo hello
hello</code></pre>

<ol><li>Note Docker does not support the comma separate <code>--cap-add</code> command, so I had to add <strong>sys_admin</strong> and <strong>mknod</strong> separately</li>
	<li>Still needed <code>--device /dev/fuse</code>, since container defaults to <code>/dev/fuse</code></li>
	<li>Docker always creates builtin volumes as owned by root:root, so we need to create a volume to mount for Podman in the container to be able to use for storage.</li>
	<li>As always, I need to disable SELinux separation</li>
	<li>Also need to disable <code>seccomp</code>, since Docker has a slightly stricter <code>seccomp</code> policy than Podman. You could just use a Podman security policy by using<code>--seccomp=/usr/share/containers/seccomp.json</code></li>
</ol><pre><code># docker run --cap-add=sys_admin --cap-add mknod --device=/dev/fuse --security-opt seccomp=/usr/share/containers/seccomp.json --security-opt label=disable quay.io/podman/stable podman run ubi8-minimal echo hello
hello</code></pre>

<h4>Rootless Podman in rootful Podman without --privileged</h4>

<p>Run <em>non</em>-privileged container with Podman inside using a non-root user using the user namespace.</p>

<pre><code># podman run --user podman --security-opt label=disable --security-opt unmask=ALL --device /dev/fuse -ti quay.io/podman/stable podman run -ti docker.io/busybox echo hello
hello</code></pre>

<ol><li>Note that unlike the rooful within rootful case before, we don&#39;t have to add the dangerous security capabilities <strong>sys_admin</strong> and <strong>mknod</strong></li>
	<li>In this case, I am running with <code>--user podman</code>, which automatically causes the Podman within the container to run within the user namespace</li>
	<li>Still disabling SELinux since it blocks the mounting</li>
	<li>Still need <code>--device /dev/fuse</code> to use fuse-overlayfs within the container</li>
</ol><h4>Podman-remote in rootful Podman with a leaked Podman socket from the host</h4>

<pre><code># podman run -v /run:/run --security-opt label=disable quay.io/podman/stable podman --remote run busybox echo hi
hi</code></pre>

<p>In this case, we are leaking the <code>/run</code> directory from the host into the container. This allows <code>podman --remote</code> to communicate with the Podman socket on the host and start the container on the host OS. This is often how people execute Docker In Docker, especially Docker builds. You could also execute Podman builds this way and take advantage of images previously pulled to the system.</p>

<p>Note, however, this is extremely insecure. The processes within the container can totally take over the host machine.</p>

<ol><li>You still need to disable SELinux separation because SELinux would block the container processes from using sockets leaked in <code>/run</code>.</li>
	<li>The <code>podman --remote</code> flag is added to tell Podman to work in remote mode. Note you could also just install the <code>podman-remote</code> executable into a container and use this.</li>
</ol><p><em><strong>[ Getting started with containers? Check out this free course. <a href="https://www.redhat.com/en/services/training/do080-deploying-containerized-applications-technical-overview?intcmp=701f20000012ngPAAQ" target="_blank">Deploying containerized applications: A technical overview.</a> ]</strong></em></p>

<h4>Podman-remote in Docker with a leaked Podman socket from the host</h4>

<pre><code># docker run -v /run:/run --security-opt label=disable quay.io/podman/stable podman --remote run busybox echo hi
hi</code></pre>

<p>The same example works for a Docker container.</p>

<p>This example shows a fully locked down container—other than SELinux being disabled—with the Podman socket leaked into the container. SELinux would block this access, as it should.</p>

<pre><code># /bin/podman run --security-opt=label=disable -v /run/podman:/run/podman quay.io/podman/stable podman --remote run alpine echo hi
hi</code></pre>

<h4>Rootless Podman with containerized rootful Podman</h4>

<pre><code>$ podman run --privileged quay.io/podman/stable podman run ubi8 echo hello
Resolved &#34;ubi8&#34; as an alias (/etc/containers/registries.conf.d/shortnames.conf)
..
hello</code></pre>

<h4>Rootless Podman running rootless Podman</h4>

<pre><code>$ podman run --security-opt label=disable --user podman --device /dev/fuse quay.io/podman/stable podman run alpine echo hello</code></pre>

<h2>Final thoughts</h2>

<p>Now you have some context for Podman in Podman options, using both rootful and rootless modes. in various combinations. You also have a better sense of the necessary privileges and the considerations surrounding the <code>--privileged</code> flag.</p>

<p>Part two in this series looks at the use of <a href="https://reserialised.routley.io/sysadmin/podman-inside-kubernetes">Podman and Kubernetes</a>. The article covers similar territory but within the context of Kubernetes.</p>

<p><em><strong>[ Want to test your sysadmin skills? <a href="https://www.redhat.com/rhtapps/assessment/?intcmp=701f20000012ngPAAQ" target="_blank">Take a skills assessment today</a>. ]</strong></em></p>
</div>
      
  
  </div></div>
  </body>
</html>
