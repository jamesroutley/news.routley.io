<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://kevinlynagh.com/calipertron/">Original</a>
    <h1>Making Electronic Calipers</h1>
    
    <div id="readability-page-1" class="page"><div><p><a href="https://elijer.github.io/">← Back to Kevin&#39;s homepage</a><span>Published: 2024 November 2</span></p><p>Have you ever wished for a 500 Hz, millimeter-precise linear position sensing system?
Well you’re in luck — all you need is some circuit board, a basic microcontroller, and a wee bit of maths!</p>

<video src="2024_11_02_caliper_demo.mp4" controls="true" loop="true" autoplay="true"></video>

<p>See also the <a href="https://github.com/lynaghk/calipertron/">full source code and my research log</a> for this project.</p>

<h2 id="why-make-calipers">Why make calipers?</h2>

<p>Electronic calipers are awesome.
<a href="https://amzn.to/3BVZhvB">This \$30 pair</a> has served me well for years, reading far more precision than my skills justify:</p>

<p><img src="https://elijer.github.io/garden/devnotes/LeetCode-Journal/calipers.png" alt="calipers"/></p>

<p>Such calipers work via capacitive coupling between a PCB on the powered slidey display and a passive PCB “scale” in the stationary spine.</p>

<p>Back in March, I idly wondered if the same working principle could be used for a cheap and cheerful “maker-friendly” positioning system.
E.g., slide some passive PCB scales into an aluminum extrusion rail, add a capacitive pickup to the bottom of whatever carriage you’ve got riding along, and <em>tada</em> — you’ve got sub-mm closed-loop positioning.
All for the cost of some PCB, a few GPIO pins, and some firmware (so free, basically).</p>

<p>I figured someone else must’ve done this before, but I wasn’t able to find any “open source caliper” projects.
The closest was <a href="https://hackaday.io/project/194778-diy-digital-caliper-calipatron/log/227428-research">this hackaday.io project page</a>, started literally a month before.</p>

<p>I reached out to the author, Mitko, and offered to implement the firmware if they sent me a PCB.
My main motivation was to learn some digital signal processing, as I’d never studied it beyond a passing undergrad mention of the Fourier transform.</p>

<p>If you just want some off-the-shelf precision measurements and don’t want to go on <em>An Adventure</em>, you may want to consider instead:</p>

<ul>
<li>reading measurement data directly out of cheap calipers via their <a href="https://hackaday.com/2016/05/17/improved-digital-caliper-interfacing-including-3d-printed-connector/">secret data interface</a></li>
<li>searching for “digital read out” (DRO) kits, which is the generic term for all sorts of capacitive, optical, and magnetic precision linear and angular measurement schemes (typically for retrofitting manual machine equipment with a digital readout, so <em>you</em> can be the “<a href="https://en.wikipedia.org/wiki/Numerical_control">NC</a>” of “CNC”). E.g., this  <a href="https://www.sra-measurement.com/digital-readout-systems/magnetic-linear-encoder-reading-head-1-micron-resolution">\$200 magnetic encoder</a> with some <a href="https://www.sra-measurement.com/high-accuracy-magnetic-linear-tape">\$1/cm linear tape</a>.)</li>
</ul>

<h2 id="caliper-theory">Caliper theory</h2>

<p>Here’s a photo of calipers disassembled by my collaborator Mitko (annotations mine):</p>

<p><img src="https://elijer.github.io/garden/devnotes/LeetCode-Journal/book_calipers.jpg" alt=""/></p>

<p>The left half is the caliper’s stationary metal spine, which contains a passive PCB with a pattern of “reflectors” (which look sorta like the capital letter “T” rotated 90 degrees clockwise).</p>

<p>The right half is the powered display part of the calipers, which slides up and down along the metal stem; this PCB has a long receiver pad and a bunch of emitter pads that look like the keys of a piano.</p>

<p>When assembled (folded together like a book), the reflector “T” stems are over top the signal-emitting piano keys and the reflector “T” crossbars are over the receiver pad.</p>

<p>(Pedant note: There’s not actually any “reflection” going on, the plates are capacitively coupled. I just find the term “reflector” conveys the right vibe.)</p>

<p>Here’s a close up, taken from Big Clive’s excellent caliper <a href="https://youtu.be/fKSSY1gzCEs?t=588">teardown video</a> (annotations mine):</p>

<p><img src="https://elijer.github.io/garden/devnotes/LeetCode-Journal/diagram.jpg" alt=""/></p>

<p>The top half is the stationary part and the bottom half is slidey part.</p>

<p>Note the following details of the geometry:</p>

<ul>
<li>The slidey part emits 8 signals through the little piano keys (labeled), which repeat along the entire length.</li>
<li>The reflector plate stems are exactly 4 keys wide.</li>
</ul>

<p>In essence, the reflector plate “adds up” the signals of the piano keys underneath it (in this photo, signals 0, 1, 2, and 3).</p>

<p>Imagine sliding the caliper display 0.5 keys to the right.
Then the reflectors would be above <em>half</em> of signal 0, all of signals 1, 2, 3, and half of signal 4.
Sliding another 0.5 keys to the right, the reflectors would then be on top of signals 1, 2, 3, and 4.</p>

<p>The reflectors are just passive pieces of metal; all they can do is sum together the signals coupled to them.
This summed signal is then reflected back to the slidey part’s single receiver pad.</p>

<p>So what are the 8 signals you should emit?</p>

<p>If you use sine waves at the same frequency but different phases, then their reflected sum will always be a sine wave of the original frequency, with some combined phase and amplitude (<a href="https://www.johndcook.com/blog/2020/08/17/adding-phase-shifted-sine-waves/">proof</a>).</p>

<p>That is: <strong>as you move the slidey part, the phase offset of the reflected signal changes</strong>.</p>

<p>Since we have 8 signals, if we evenly divide the unit circle so that the nth signal is:</p>

<p>$$\sin\left( 2\pi f + 2\pi\frac{n}{8} \right)$$</p>

<p>then we can track the cumulative phase offset of the received signal (relative to some initial position) and know that every $2\pi$ moved in phase space corresponds to a linear movement 8 emitter keys wide.</p>

<h2 id="microcontroller-implementation">Microcontroller implementation</h2>

<p>Mitko mailed me version 1.1 of his PCB (<a href="https://github.com/MitkoDyakov/Calipatron/blob/444c72c3e81eab0a2e7ee198f5574062dc1fc510/Hardware/V1.1/Schematics%20V1.1.pdf">schematic</a>), which is built around an stm32f103 microcontroller.</p>

<p>I wrote the firmware using the <a href="https://github.com/embassy-rs/embassy">Embassy Rust framework</a>, which worked reasonably well.
(“Well” as far as embedded goes — there was a side quest tracking down an intermittent freeze that locked out the debugger, which seems to be a genuine hardware bug triggered only on <a href="https://github.com/lynaghk/repro-stm32f103-rust-embassy-freeze/">older ARM core silicon revisions</a>.)</p>

<p>The firmware needs to:</p>

<ul>
<li>emit 8 sinusoidal waves</li>
<li>measure the reflected sum calculate the phase offset</li>
</ul>

<p>Let’s take these in turn.</p>

<h2 id="emitting-sinusoidal-waves">Emitting sinusoidal waves</h2>

<p>The stm32f103 doesn’t have a digital to analog converter, but we can emit a sinusoidal wave using “pulse density modulation” (PDM).
The technique is similar to PWM (“pulse width modulation”) in that an analog signal level is approximated by having a digital signal stay “on” for the appropriate fraction of time.
But while PWM has its “on” fraction all at once, the PDM signal spaces it out across the sample window.</p>

<p>For example, to represent an analog level of 50% using 8 pulses:</p>
<div><pre><span></span>PWM: X X X X . . . .
PDM: X . X . X . X .
</pre></div>
<p>the PWM signal stays high (<code>x</code>) for the first half of the period, whereas the PDM signal alternates.
This is preferable for our use case, since it means the switching noise is at a higher frequency, further away from our lower frequency sinusoidal wave.</p>

<p>We need all of the waves to move in lockstep with each other, so rather than updating the pins one-by-one, we update all of them with a single 32-bit write to the GPIO’s “bit set reset register” (BSRR).</p>

<p>Furthermore, since we know how many PDM samples we want in advance, we can take pity on our lil’ stm32f103 (which doesn’t even have a hardware floating point unit) and calculate all of the BSRR values at compile-time.
Rust’s formal compile-time machinery <a href="https://users.rust-lang.org/t/constant-trigonometry/58565">doesn’t support trigonometry</a>, so we use a <code>build.rs</code> script to generate a string of code at compile-time:</p>
<div><pre><span></span><span>fn</span> <span>generate_pdm_bsrr</span><span>(</span><span>n_samples</span>: <span>usize</span><span>)</span><span> </span>-&gt; <span>String</span> <span>{</span><span></span>
<span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>output</span><span> </span><span>=</span><span> </span><span>String</span>::<span>new</span><span>();</span><span></span>
<span>    </span><span>output</span><span>.</span><span>push_str</span><span>(</span><span>&#34;pub const PDM_SIGNAL: [u32; &#34;</span><span>);</span><span></span>
<span>    </span><span>output</span><span>.</span><span>push_str</span><span>(</span><span>&amp;</span><span>n_samples</span><span>.</span><span>to_string</span><span>());</span><span></span>
<span>    </span><span>output</span><span>.</span><span>push_str</span><span>(</span><span>&#34;] = [</span><span>\n</span><span>&#34;</span><span>);</span><span></span>

<span>    </span><span>let</span><span> </span><span>n_waves</span><span> </span><span>=</span><span> </span><span>8</span><span>;</span><span></span>

<span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>errors</span><span> </span><span>=</span><span> </span><span>vec!</span><span>[</span><span>0.0</span><span>;</span><span> </span><span>n_waves</span><span>];</span><span></span>
<span>    </span><span>for</span><span> </span><span>sample</span><span> </span><span>in</span><span> </span><span>0</span><span>..</span><span>n_samples</span><span> </span><span>{</span><span></span>
<span>        </span><span>let</span><span> </span><span>mut</span><span> </span><span>bsrr</span><span> </span><span>=</span><span> </span><span>0</span><span>u32</span><span>;</span><span></span>
<span>        </span><span>for</span><span> </span><span>wave</span><span> </span><span>in</span><span> </span><span>0</span><span>..</span><span>n_waves</span><span> </span><span>{</span><span></span>
<span>            </span><span>let</span><span> </span><span>phase_offset</span><span> </span><span>=</span><span> </span><span>2.0</span><span> </span><span>*</span><span> </span><span>PI</span><span> </span><span>*</span><span> </span><span>(</span><span>wave</span><span> </span><span>as</span><span> </span><span>f64</span><span>)</span><span> </span><span>/</span><span> </span><span>(</span><span>n_waves</span><span> </span><span>as</span><span> </span><span>f64</span><span>);</span><span></span>
<span>            </span><span>let</span><span> </span><span>angle</span><span> </span><span>=</span><span> </span><span>2.0</span><span> </span><span>*</span><span> </span><span>PI</span><span> </span><span>*</span><span> </span><span>(</span><span>sample</span><span> </span><span>as</span><span> </span><span>f64</span><span> </span><span>/</span><span> </span><span>n_samples</span><span> </span><span>as</span><span> </span><span>f64</span><span>)</span><span> </span><span>+</span><span> </span><span>phase_offset</span><span>;</span><span></span>
<span>            </span><span>let</span><span> </span><span>cosine</span><span> </span><span>=</span><span> </span><span>angle</span><span>.</span><span>cos</span><span>()</span><span> </span><span>as</span><span> </span><span>f32</span><span>;</span><span></span>
<span>            </span><span>let</span><span> </span><span>normalized_signal</span><span> </span><span>=</span><span> </span><span>(</span><span>cosine</span><span> </span><span>+</span><span> </span><span>1.0</span><span>)</span><span> </span><span>/</span><span> </span><span>2.0</span><span>;</span><span></span>

<span>            </span><span>if</span><span> </span><span>normalized_signal</span><span> </span><span>&gt;</span><span> </span><span>errors</span><span>[</span><span>wave</span><span>]</span><span> </span><span>{</span><span></span>
<span>                </span><span>bsrr</span><span> </span><span>|=</span><span> </span><span>1</span><span> </span><span>&lt;&lt;</span><span> </span><span>wave</span><span>;</span><span> </span><span>// set bit</span>
<span>                </span><span>errors</span><span>[</span><span>wave</span><span>]</span><span> </span><span>+=</span><span> </span><span>1.0</span><span> </span><span>-</span><span> </span><span>normalized_signal</span><span>;</span><span></span>
<span>            </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span><span></span>
<span>                </span><span>bsrr</span><span> </span><span>|=</span><span> </span><span>1</span><span> </span><span>&lt;&lt;</span><span> </span><span>(</span><span>wave</span><span> </span><span>+</span><span> </span><span>16</span><span>);</span><span> </span><span>// reset bit</span>
<span>                </span><span>errors</span><span>[</span><span>wave</span><span>]</span><span> </span><span>-=</span><span> </span><span>normalized_signal</span><span>;</span><span></span>
<span>            </span><span>}</span><span></span>
<span>        </span><span>}</span><span></span>
<span>        </span><span>output</span><span>.</span><span>push_str</span><span>(</span><span>&amp;</span><span>format!</span><span>(</span><span>&#34;    {:#034b},</span><span>\n</span><span>&#34;</span><span>,</span><span> </span><span>bsrr</span><span>));</span><span></span>
<span>    </span><span>}</span><span></span>

<span>    </span><span>output</span><span>.</span><span>push_str</span><span>(</span><span>&#34;];</span><span>\n</span><span>&#34;</span><span>);</span><span></span>
<span>    </span><span>output</span><span></span>
<span>}</span><span></span>
</pre></div>
<p>This emitted string is then written to a file, which we <code>import</code> as usual from our main code namespace.
The <code>PDM_SIGNAL</code> const slice is then baked into the firmware, and at runtime a hardware timer and a DMA task is used copy each value directly to BSRR at a fixed rate.
This prevents any jitter in the emitted signal, as after starting the transmission the CPU is no longer involved.</p>

<h2 id="measuring-phase-offset">Measuring phase offset</h2>

<p>The reflected composite wave is measured by the stm32f103’s ADC.
A DMA task is triggered at the same time as the emitted PDM signals, and it reads a fixed number of samples into a buffer.</p>

<p>So how do we get the phase offset?</p>

<p>If you’re like me, the first thing you need to do is read some textbooks to figure out what’s what.
I recommend <a href="https://amzn.to/3MDLdZN">Understanding Digital Signal Processing</a> by Richard Lyons, as the book has a casual friendly style and is clearly written by an experienced engineer — the final chapter is simply 150 pages of “Digital Signal Processing Tricks”!</p>

<p>Anyway, we know from earlier that our reflected signal $s(t)$ is the sum of the sinusoidal signals that we emitted, so it must also be a sinusoid with some phase offset; let’s call it $A \cos( \omega t + \phi)$ (with $A$ some constant representing a change in amplitude due to our capacitive coupling, amplification, etc. compared to our original emitted signal).</p>

<p>Then as I’m sure you recall from <a href="https://mathworld.wolfram.com/TrigonometricAdditionFormulas.html">trigonometric addition formula</a> from grade school, we can rewrite this as:</p>

<p>$$
\begin{align}
s(t) &amp;= A \cos( \omega t + \phi)\newline
     &amp;= A \left[ \cos( \omega t)\cos(\phi) - \sin( \omega t)\sin(\phi) \right]
\end{align}
$$</p>

<p>If we correlate our signal with $\cos(\omega t)$ then we’re left with $A \cos(\phi)$, and similarly for sin.
Thus:</p>

<p>$$
\begin{align}
\frac{\mathrm{Corr}\left(s(t), \sin(\omega t)\right)}{\mathrm{Corr}\left(s(t), \cos(\omega t)\right)} &amp;= \frac{A \sin(\phi)} {A \cos(\phi)} \newline
\arctan\left(\frac{\mathrm{Corr}\left(s(t), \sin(\omega t)\right)}{\mathrm{Corr}\left(s(t), \cos(\omega t)\right)}\right) &amp;= \phi
\end{align}
$$</p>

<p>The correlation operator itself is simple: it’s the sum of the product of the two signals at matching points in time.</p>

<p>All we need to do is figure out the exact times of our $s(t)$ samples, which can be derived by the sampling rate of the ADC.</p>

<p>All of the terms besides our measured signal samples $s(t)$ are knowable at compile-time, so we can again generate a lookup table for our microcontroller to use:</p>
<div><pre><span></span><span>fn</span> <span>generate_sine_cosine_table</span><span>(</span><span></span>
<span>    </span><span>signal_frequency</span>: <span>f64</span><span>,</span><span></span>
<span>    </span><span>sampling_frequency</span>: <span>f64</span><span>,</span><span></span>
<span>    </span><span>num_samples</span>: <span>usize</span><span>,</span><span></span>
<span>)</span><span> </span>-&gt; <span>String</span> <span>{</span><span></span>
<span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>output</span><span> </span><span>=</span><span> </span><span>String</span>::<span>new</span><span>();</span><span></span>
<span>    </span><span>output</span><span>.</span><span>push_str</span><span>(</span><span>&#34;pub const SINE_COSINE_TABLE: [(f32, f32); &#34;</span><span>);</span><span></span>
<span>    </span><span>output</span><span>.</span><span>push_str</span><span>(</span><span>&amp;</span><span>num_samples</span><span>.</span><span>to_string</span><span>());</span><span></span>
<span>    </span><span>output</span><span>.</span><span>push_str</span><span>(</span><span>&#34;] = [</span><span>\n</span><span>&#34;</span><span>);</span><span></span>

<span>    </span><span>for</span><span> </span><span>i</span><span> </span><span>in</span><span> </span><span>0</span><span>..</span><span>num_samples</span><span> </span><span>{</span><span></span>
<span>        </span><span>let</span><span> </span><span>angle</span><span> </span><span>=</span><span> </span><span>2.0</span><span> </span><span>*</span><span> </span><span>PI</span><span> </span><span>*</span><span> </span><span>signal_frequency</span><span> </span><span>*</span><span> </span><span>(</span><span>i</span><span> </span><span>as</span><span> </span><span>f64</span><span> </span><span>*</span><span> </span><span>(</span><span>1.0</span><span> </span><span>/</span><span> </span><span>sampling_frequency</span><span>));</span><span></span>
<span>        </span><span>let</span><span> </span><span>sine</span><span> </span><span>=</span><span> </span><span>angle</span><span>.</span><span>sin</span><span>()</span><span> </span><span>as</span><span> </span><span>f32</span><span>;</span><span></span>
<span>        </span><span>let</span><span> </span><span>cosine</span><span> </span><span>=</span><span> </span><span>angle</span><span>.</span><span>cos</span><span>()</span><span> </span><span>as</span><span> </span><span>f32</span><span>;</span><span></span>
<span>        </span><span>output</span><span>.</span><span>push_str</span><span>(</span><span>&amp;</span><span>format!</span><span>(</span><span>&#34;    ({:?}, {:?}),</span><span>\n</span><span>&#34;</span><span>,</span><span> </span><span>sine</span><span>,</span><span> </span><span>cosine</span><span>));</span><span></span>
<span>    </span><span>}</span><span></span>

<span>    </span><span>output</span><span>.</span><span>push_str</span><span>(</span><span>&#34;];</span><span>\n</span><span>&#34;</span><span>);</span><span></span>
<span>    </span><span>output</span><span></span>
<span>}</span><span></span>
</pre></div>
<p>The build.rs script is then:</p>
<div><pre><span></span><span>fn</span> <span>main</span><span>()</span><span> </span><span>{</span><span></span>

<span>    </span><span>// lol, compile-time-programming by literally writing code to a file that we import</span>
<span>    </span><span>let</span><span> </span><span>out_dir</span><span> </span><span>=</span><span> </span><span>std</span>::<span>env</span>::<span>var</span><span>(</span><span>&#34;OUT_DIR&#34;</span><span>).</span><span>unwrap</span><span>();</span><span></span>
<span>    </span><span>let</span><span> </span><span>dest_path</span><span> </span><span>=</span><span> </span><span>std</span>::<span>path</span>::<span>Path</span>::<span>new</span><span>(</span><span>&amp;</span><span>out_dir</span><span>).</span><span>join</span><span>(</span><span>&#34;constants.rs&#34;</span><span>);</span><span></span>
<span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>f</span><span> </span><span>=</span><span> </span><span>File</span>::<span>create</span><span>(</span><span>&amp;</span><span>dest_path</span><span>).</span><span>unwrap</span><span>();</span><span></span>

<span>    </span><span>let</span><span> </span><span>pdm_frequency</span>: <span>u32</span> <span>=</span><span> </span><span>100_000</span><span>;</span><span> </span><span>// 100 kHz</span>
<span>    </span><span>f</span><span>.</span><span>write_all</span><span>(</span><span>format!</span><span>(</span><span>&#34;pub const PDM_FREQUENCY: u32 = {:?};</span><span>\n</span><span>&#34;</span><span>,</span><span> </span><span>pdm_frequency</span><span>).</span><span>as_bytes</span><span>())</span><span></span>
<span>        </span><span>.</span><span>unwrap</span><span>();</span><span></span>

<span>    </span><span>let</span><span> </span><span>pdm_length</span><span> </span><span>=</span><span> </span><span>128</span><span>;</span><span></span>

<span>    </span><span>let</span><span> </span><span>num_samples</span><span> </span><span>=</span><span> </span><span>512</span><span>;</span><span></span>
<span>    </span><span>let</span><span> </span><span>signal_frequency</span><span> </span><span>=</span><span> </span><span>pdm_frequency</span><span> </span><span>as</span><span> </span><span>f64</span><span> </span><span>/</span><span> </span><span>pdm_length</span><span> </span><span>as</span><span> </span><span>f64</span><span>;</span><span></span>
<span>    </span><span>let</span><span> </span><span>adc_frequency</span><span> </span><span>=</span><span> </span><span>12_000_000.</span><span>;</span><span></span>
<span>    </span><span>let</span><span> </span><span>adc_sample_cycles</span><span> </span><span>=</span><span> </span><span>71.5</span><span>;</span><span></span>
<span>    </span><span>let</span><span> </span><span>adc_sample_overhead_cycles</span><span> </span><span>=</span><span> </span><span>12.5</span><span>;</span><span> </span><span>// see reference manual section 11.6</span>
<span>    </span><span>let</span><span> </span><span>sampling_frequency</span><span> </span><span>=</span><span> </span><span>adc_frequency</span><span> </span><span>/</span><span> </span><span>(</span><span>adc_sample_cycles</span><span> </span><span>+</span><span> </span><span>adc_sample_overhead_cycles</span><span>);</span><span></span>

<span>    </span><span>f</span><span>.</span><span>write_all</span><span>(</span><span></span>
<span>        </span><span>generate_sine_cosine_table</span><span>(</span><span>signal_frequency</span><span>,</span><span> </span><span>sampling_frequency</span><span>,</span><span> </span><span>num_samples</span><span>).</span><span>as_bytes</span><span>(),</span><span></span>
<span>    </span><span>)</span><span></span>
<span>    </span><span>.</span><span>unwrap</span><span>();</span><span></span>

<span>    </span><span>f</span><span>.</span><span>write_all</span><span>(</span><span>generate_pdm_bsrr</span><span>(</span><span>pdm_length</span><span>).</span><span>as_bytes</span><span>())</span><span></span>
<span>        </span><span>.</span><span>unwrap</span><span>();</span><span></span>

<span>    </span><span>/// ...</span>
<span>}</span><span></span>
</pre></div>
<p>Finally, at runtime we’re left with this loop:</p>
<div><pre><span></span><span>loop</span><span> </span><span>{</span><span></span>

<span>  </span><span>// start PDM emission via DMA</span>
<span>  </span><span>// start ADC via DMA</span>
<span>  </span><span>// wait for ADC to read NUM_SAMPLES</span>
<span>  </span><span>// then...</span>

<span>  </span><span>let</span><span> </span><span>mut</span><span> </span><span>sum_sine</span>: <span>f32</span> <span>=</span><span> </span><span>0.0</span><span>;</span><span></span>
<span>  </span><span>let</span><span> </span><span>mut</span><span> </span><span>sum_cosine</span>: <span>f32</span> <span>=</span><span> </span><span>0.0</span><span>;</span><span></span>

<span>  </span><span>let</span><span> </span><span>adc_buf</span><span> </span><span>=</span><span> </span><span>unsafe</span><span> </span><span>{</span><span> </span><span>&amp;</span><span>ADC_BUF</span><span>[</span><span>..</span><span>]</span><span> </span><span>};</span><span></span>

<span>  </span><span>for</span><span> </span><span>i</span><span> </span><span>in</span><span> </span><span>0</span><span>..</span><span>NUM_SAMPLES</span><span> </span><span>{</span><span></span>
<span>      </span><span>let</span><span> </span><span>(</span><span>sine</span><span>,</span><span> </span><span>cosine</span><span>)</span><span> </span><span>=</span><span> </span><span>SINE_COSINE_TABLE</span><span>[</span><span>i</span><span>];</span><span></span>
<span>      </span><span>sum_sine</span><span> </span><span>+=</span><span> </span><span>adc_buf</span><span>[</span><span>i</span><span>]</span><span> </span><span>as</span><span> </span><span>f32</span><span> </span><span>*</span><span> </span><span>sine</span><span>;</span><span></span>
<span>      </span><span>sum_cosine</span><span> </span><span>+=</span><span> </span><span>adc_buf</span><span>[</span><span>i</span><span>]</span><span> </span><span>as</span><span> </span><span>f32</span><span> </span><span>*</span><span> </span><span>cosine</span><span>;</span><span></span>
<span>  </span><span>}</span><span></span>
<span>  </span><span>let</span><span> </span><span>phase</span><span> </span><span>=</span><span> </span><span>sum_sine</span><span>.</span><span>atan2</span><span>(</span><span>sum_cosine</span><span>);</span><span></span>

<span>  </span><span>// add latest phase reading to position estimation.</span>
<span>  </span><span>// this object also handles wraparound and hysteresis.</span>
<span>  </span><span>position_estimator</span><span>.</span><span>update</span><span>(</span><span>phase</span><span>);</span><span></span>
<span>  </span><span>info</span><span>!</span><span>(</span><span>&#34;Phase: {} Position: {}&#34;</span><span>,</span><span> </span><span>phase</span><span>,</span><span> </span><span>position_estimator</span><span>.</span><span>position</span><span>);</span><span></span>

<span>  </span><span>if</span><span> </span><span>user_button</span><span>.</span><span>is_low</span><span>()</span><span> </span><span>{</span><span></span>
<span>      </span><span>info</span><span>!</span><span>(</span><span>&#34;Button pressed, zeroing&#34;</span><span>);</span><span></span>
<span>      </span><span>position_estimator</span><span>.</span><span>position</span><span> </span><span>=</span><span> </span><span>0.</span><span>;</span><span></span>
<span>  </span><span>}</span><span></span>
<span>}</span><span></span>
</pre></div>
<h2 id="precision">Precision</h2>

<p>There are several parameters we need to select in the firmware to implement the measurement:</p>

<ul>
<li>The frequency at which we emit the PDM pulses</li>
<li>The number of PDM pulses across which we divide a single sinusoid period</li>
<li>The ADC sampling time</li>
<li>The number of ADC samples we take for each phase calculation</li>
</ul>

<p>Rather than try to calculate the ideal parameters from first principles (which would probably depend on all sorts of specifics like the PCB soldermask thickness and trace resistances), let’s just try them all and see what works best.
More specifically: for each parameter configuration, which has the lowest standard deviation for multiple measurements taken from the same physical slide position?</p>

<p>Instead of reflashing the firmware for each set of parameters, we can write a special <a href="https://github.com/lynaghk/calipertron/blob/2ceedc0e477498601dcbd6a6f257012657070bf9/firmware/src/bin/recorder.rs">recorder firmware</a> that can be controlled by a laptop to try different parameters configurations.
Then we can stream  the raw ADC readings back to the laptop, which lets us try a much wider variety parameters.</p>

<p>You can look at the <a href="https://github.com/lynaghk/calipertron/blob/2ceedc0e477498601dcbd6a6f257012657070bf9/analysis/parameter_sweep.ipynb">parameter sweep notebook</a> for the gory details, but here’s the summary in a plot:</p>

<p><img src="https://elijer.github.io/garden/devnotes/LeetCode-Journal/parameter_sweep.jpg" alt=""/></p>

<p>There’s a lot going on here, let’s break it down.
Schematically:</p>

<ul>
<li>The Y-axis corresponds to the standard deviation of recorded phases (lower is better — after all, the slide is never moving, so ideally all measurements would return the same value)</li>
<li>The X-axis corresponds to the frequency for which we’re sending out the PDM pulses of the emitted sinusoidal signal. All data here are for 128 PDM segments and an X-axis spacing of 2 kHz.</li>
<li>Each sub-plot corresponds to a different “window size” — i.e., how many ADC samples we correlate to derive a single phase measurement.</li>
<li>Each colored line is a different ADC sampling frequency (the stm32f103’s ADC can sample over 8 different periods, and we’re trying all of them)</li>
</ul>

<p>What stands out to me in the data itself:</p>

<ul>
<li>The higher the ADC frequency, the higher the PDM frequency needs to be before we start to pick up the signal (i.e., for the standard deviation to drop).
This makes sense to me, as if the ADC frequency is much higher than the signal’s, our window of samples won’t see the signal change much at all, so it’s going to be dominated by noise and we’ll have no idea what the phase is.</li>
<li>Increasing the window size tends to improve precision — makes sense, as it means we’re looking at more samples and (presumably) reducing the effect of noise.</li>
<li>The lowest ADC sampling frequency (i.e., the longest ADC sampling period) tends to have the best performance.</li>
<li>There’s a strange cat at 250 kHz; this is probably the point at which our ADC sampling rate isn’t fast enough to keep up with the signal itself. With 250 kHz / 128 PDM segments implies our emitted sinusoid is at about 1950 Hz</li>
</ul>

<p>While in this static test increasing the window size and ADC sampling period looks best, that does mean it’ll reduce the rate at which we can actually calculate the phase, which limits how fast the slider can move before it loses track of its absolute position.</p>

<p>So, based on this survey I decided to set the parameters for the local, in-firmware calculation (as seen in the demo video) to be the point indicated by the red arrow:</p>

<ul>
<li>window size = 128</li>
<li>PDM frequency = 222 kHz</li>
<li>ADC sampling frequency = 222.2 kHz</li>
</ul>

<p>It actually makes sense that the phase deviation is a minimum here: At this ADC sampling frequency and a window size of 128, we’re pretty much matching a full period of the emitted 128-segment PDM signal.</p>

<p>The timestamps in the demo video show about 1.5 ms between readings (0.6 kHz), which is about three times the ideal limit (222.2 kHz / 128 samples =&gt; 1.7 kHz), probably due to the time it takes to do correlation math, print to the host computer, and cycle through the Embassy async machinery.
I’m sure a more optimized implementation could hit the limit by, e.g., calculating the correlations while the samples are being collected rather than afterwards.</p>

<p>As for the precision, taking 200ms worth of phase measurements from the printed logs (n = 124) while the slide isn’t moving, the standard deviation of the phase is 0.039 radians, which (for my PCB with 8 emitter keys = 9.4 mm) is a position error of about $ 0.039 * 9.4\,\mathrm{mm} / 2\pi = 0.6\,\mathrm{mm}$.</p>

<p>Honestly, this is way better than I expected — especially since the stm32f103 came out in 2007, the drive signal is created by just banging on GPIO, and only conditioning for the received signal is a fixed-gain amplifier (we’re not even filtering out the 50 Hz line noise).</p>

<h2 id="misc-tips-lessons-learned">Misc. tips / lessons learned</h2>

<ul>
<li>I’m very happy with the workflow of streaming raw data to my computer over USB and then doing analysis in Python notebooks. This was also helpful for letting continue work on the project while I was traveling and away from the working hardware.</li>
<li>I’m not super-well versed in the Python ecosystem, and it was spectacular asking LLMs like Claude stuff like, “Can you please plot an FFT of these data samples”, “Run these bad boys through a low pass filter at with cutoff at 1000 Hz”, “Can you please write an a phase accumulator that handles wraparound correctly”, etc. Being able to use <a href="https://elijer.github.io/newsletter/2024_10_transcription_app_art_wall/">my lightweight dictation app</a> to just ramble out thoughts/ideas at an LLM was particularly satisfying.</li>
<li>Even with LLM-assistance, plotting was more difficult than I expected:

<ul>
<li>The JS-based interactive plots (Plotly, etc.) blew up when I tried to visualize raw data with just ~100k samples.</li>
<li>The matplotlib-based static plotting libraries didn’t make it easy to read exact coordinates from a point on the plot interactively.</li>
<li>Doing data aggregation with <a href="https://pola.rs/">Polars</a> was pretty good, but it wasn’t obvious to me how to aggregate + plot, e.g., both underlying data and their standard deviation across dimensions.</li>
<li>Likely I just need to pick a Python plotting library and spend 20 hours getting fluent.</li>
</ul></li>
<li>The proliferation of complex type signatures in the Rust Embedded ecosystem still fails to spark joy — I’m stuck in the local optima of “literally just write everything in <code>fn main()</code> with a loop at the bottom” so I never have to write out the type signatures.</li>
</ul>

<h2 id="future-improvements">Future improvements</h2>

<p>I probably won’t go further on this until I have some sort of robotics context-of-use.
But for anyone who’s in the market for a project, here are a few ideas:</p>

<ul>
<li>Figure out how to make a parametric caliper emitter/reflector designs in PCB tools like <a href="https://atopile.io/">atopile</a> or some kind of KiCAD footprint generation script.</li>
<li>Design something specifically to work with aluminum extrusion motion systems and see how cheap/accurate you can make it.</li>
<li>Compare to more “off the shelf” positioning systems like magnetic tape or <a href="https://blog.adafruit.com/2024/02/29/eye-on-npi-triad-semiconductor-ts4631-light-to-digital-converter-eyeonnpi-adafruit-digikey-digikey-triadsemi-adafruit/">SteamVR trackers</a>.</li>
<li>Actually make this into a functional caliper by designing more suitable housing (as you can see from the video, my 3d printed base is just clamped to my desk).</li>
</ul>

<h2 id="thanks">Thanks</h2>

<ul>
<li>Mitko for designing the PCB hardware. See the details on the <a href="https://hackaday.io/project/194778-diy-digital-caliper-calipatron">hackday.io project page</a>.</li>
<li><a href="https://blog.npry.dev/">Nathan Perry</a> and <a href="https://jeffmcbride.net/">Jeff McBride</a> for helping me track down the <a href="https://github.com/lynaghk/repro-stm32f103-rust-embassy-freeze/">intermittent stm32f103 freeze up</a> to a bug in the CPU silicon. (Let’s all do our best to never run into that again!)</li>
</ul>
</div></div>
  </body>
</html>
