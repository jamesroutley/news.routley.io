<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/fairyglade/ly">Original</a>
    <h1>Ly: Display Manager with Console UI</h1>
    
    <div id="readability-page-1" class="page"><div>
  <p>I was pairing with a colleague on some asynchronous streaming abstractions implemented in Python.
I realized that there are some pretty significant footguns with predictable cleanup in async generators.</p>
<p>In fact, the same footguns are present in <em>normal</em> generators, but don&#39;t cause quite as many issues as in async generators. Crucially, we can observe unexpected cleanup behavior when we don&#39;t fully consume a generator.</p>
<p>Let&#39;s take a look!</p>
<pre data-lang="python"><code data-lang="python"><span>from </span><span>__future__ </span><span>import </span><span>annotations
</span><span>
</span><span>import </span><span>itertools
</span><span>import </span><span>time
</span><span>from </span><span>collections.abc </span><span>import </span><span>Generator
</span><span>
</span><span>
</span><span>def </span><span>gen</span><span>() -&gt; Generator[</span><span>int</span><span>]:
</span><span>    </span><span># Contrived example wrapping an infinite iterator in some cleanup code.
</span><span>    </span><span>try</span><span>:
</span><span>        </span><span>yield from </span><span>itertools.count(</span><span>0</span><span>)
</span><span>    </span><span>finally</span><span>:
</span><span>        </span><span>print</span><span>(</span><span>&#34;cleaned up&#34;</span><span>)
</span><span>
</span><span>
</span><span>def </span><span>main</span><span>() -&gt; </span><span>None</span><span>:
</span><span>    generator </span><span>= </span><span>gen()
</span><span>    </span><span># We break out of this loop early, meaning we have not fully consumed `generator`.
</span><span>    </span><span>for </span><span>elem </span><span>in </span><span>generator:
</span><span>        </span><span>print</span><span>(elem)
</span><span>        </span><span>if </span><span>elem </span><span>&gt; </span><span>3</span><span>:
</span><span>            </span><span>break
</span><span>    </span><span>print</span><span>(</span><span>&#34;finished iterating&#34;</span><span>)
</span><span>    </span><span># Perform some expensive operation.
</span><span>    </span><span>time.sleep(</span><span>2</span><span>)
</span><span>
</span><span>
</span><span>if </span><span>__name__ </span><span>== </span><span>&#34;__main__&#34;</span><span>:
</span><span>    </span><span>main()
</span></code></pre>
<p><a href="https://samgeo.codes/python-generator-cleanup/0.html">Run with PyScript</a></p>
<p>When running this, the output looks something like this:</p>
<pre><code><span>0
</span><span>1
</span><span>2
</span><span>3
</span><span>4
</span><span>finished iterating
</span><span>cleaned up
</span></code></pre>
<p>The order of these print statements suggests that the cleanup code only gets executed at the exit of the function (e.g. when the reference count of the generator object is decremented to <code>0</code>).</p>
<p>We can do a <em>little</em> bit better by inlining the call to <code>gen</code> <em>or</em> explicitly using the <code>del</code> statement to ensure that the generator is cleaned up <em>before</em> we start some expensive operation. In this contrived example, it doesn&#39;t seem like that big of a deal, but it can often be desirable to relinquish resources (such as open file descriptors or database connections) as soon as we&#39;re finished with them.</p>
<pre data-lang="python"><code data-lang="python"><span>from </span><span>__future__ </span><span>import </span><span>annotations
</span><span>
</span><span>import </span><span>itertools
</span><span>import </span><span>time
</span><span>from </span><span>collections.abc </span><span>import </span><span>Generator
</span><span>
</span><span>
</span><span>def </span><span>gen</span><span>() -&gt; Generator[</span><span>int</span><span>]:
</span><span>    </span><span>try</span><span>:
</span><span>        </span><span>yield from </span><span>itertools.count(</span><span>0</span><span>)
</span><span>    </span><span>finally</span><span>:
</span><span>        </span><span>print</span><span>(</span><span>&#34;cleaned up&#34;</span><span>)
</span><span>
</span><span>
</span><span>def </span><span>main</span><span>() -&gt; </span><span>None</span><span>:
</span><span>    </span><span>for </span><span>elem </span><span>in </span><span>gen()</span><span>:
</span><span>        </span><span>print</span><span>(elem)
</span><span>        </span><span>if </span><span>elem </span><span>&gt; </span><span>3</span><span>:
</span><span>            </span><span>break
</span><span>    </span><span>print</span><span>(</span><span>&#34;finished iterating&#34;</span><span>)
</span><span>    </span><span># Perform some expensive operation.
</span><span>    </span><span>time.sleep(</span><span>2</span><span>)
</span><span>
</span><span>
</span><span>if </span><span>__name__ </span><span>== </span><span>&#34;__main__&#34;</span><span>:
</span><span>    </span><span>main()
</span></code></pre>
<p><a href="https://samgeo.codes/python-generator-cleanup/1.html">Run with PyScript</a></p>
<p>The output this time:</p>
<pre><code><span>0
</span><span>1
</span><span>2
</span><span>3
</span><span>4
</span><span>cleaned up
</span><span>finished iterating
</span></code></pre>
<p>So we clean up first! However, this relies pretty heavily on some implementation details of CPython. In fact, when I run this same code with <code>pypy</code>, the cleanup never gets run! So what options do we have?</p>
<p>Let&#39;s take a look at some of the code in the standard library; specifically, let&#39;s look at <a href="https://github.com/python/cpython/blob/3.12/Lib/_collections_abc.py"><code>Lib/_collections_abc.py</code></a> to get a better sense of what operations may be available on generators.</p>
<p>This snippet seems promising:</p>
<pre data-lang="python"><code data-lang="python"><span>class </span><span>Generator</span><span>(</span><span>Iterator</span><span>):
</span><span>
</span><span>    </span><span>__slots__ </span><span>= </span><span>()
</span><span>
</span><span>    </span><span>def </span><span>__next__</span><span>(</span><span>self</span><span>):
</span><span>        </span><span>&#34;&#34;&#34;Return the next item from the generator.
</span><span>        When exhausted, raise StopIteration.
</span><span>        &#34;&#34;&#34;
</span><span>        </span><span>return </span><span>self.send(</span><span>None</span><span>)
</span><span>
</span><span>    @</span><span>abstractmethod
</span><span>    </span><span>def </span><span>send</span><span>(</span><span>self</span><span>, </span><span>value</span><span>):
</span><span>        </span><span>&#34;&#34;&#34;Send a value into the generator.
</span><span>        Return next yielded value or raise StopIteration.
</span><span>        &#34;&#34;&#34;
</span><span>        </span><span>raise </span><span>StopIteration
</span><span>
</span><span>    @</span><span>abstractmethod
</span><span>    </span><span>def </span><span>throw</span><span>(</span><span>self</span><span>, </span><span>typ</span><span>, </span><span>val</span><span>=</span><span>None</span><span>, </span><span>tb</span><span>=</span><span>None</span><span>):
</span><span>        </span><span>&#34;&#34;&#34;Raise an exception in the generator.
</span><span>        Return next yielded value or raise StopIteration.
</span><span>        &#34;&#34;&#34;
</span><span>        </span><span>if </span><span>val </span><span>is </span><span>None</span><span>:
</span><span>            </span><span>if </span><span>tb </span><span>is </span><span>None</span><span>:
</span><span>                </span><span>raise </span><span>typ
</span><span>            val </span><span>= </span><span>typ()
</span><span>        </span><span>if </span><span>tb </span><span>is not </span><span>None</span><span>:
</span><span>            val </span><span>= </span><span>val.with_traceback(tb)
</span><span>        </span><span>raise </span><span>val
</span><span>
</span><span>    </span><span>def </span><span>close</span><span>(</span><span>self</span><span>):
</span><span>        </span><span>&#34;&#34;&#34;Raise GeneratorExit inside generator.
</span><span>        &#34;&#34;&#34;
</span><span>        </span><span>try</span><span>:
</span><span>            </span><span>self.throw(</span><span>GeneratorExit</span><span>)
</span><span>        </span><span>except </span><span>(</span><span>GeneratorExit</span><span>, </span><span>StopIteration</span><span>):
</span><span>            </span><span>pass
</span><span>        </span><span>else</span><span>:
</span><span>            </span><span>raise </span><span>RuntimeError</span><span>(</span><span>&#34;generator ignored GeneratorExit&#34;</span><span>)
</span><span>
</span><span>    @</span><span>classmethod
</span><span>    </span><span>def </span><span>__subclasshook__</span><span>(</span><span>cls</span><span>, </span><span>C</span><span>):
</span><span>        </span><span>if </span><span>cls </span><span>is </span><span>Generator:
</span><span>            </span><span>return </span><span>_check_methods(C, </span><span>&#39;__iter__&#39;</span><span>, </span><span>&#39;__next__&#39;</span><span>,
</span><span>                                  </span><span>&#39;send&#39;</span><span>, </span><span>&#39;throw&#39;</span><span>, </span><span>&#39;close&#39;</span><span>)
</span><span>        </span><span>return </span><span>NotImplemented
</span></code></pre>
<p>In particular, this suggests that generators have a <code>close</code> method!</p>
<p>So what happens if we explicitly invoke <code>close</code> on our generator after we&#39;ve finished iteration?</p>
<pre data-lang="python"><code data-lang="python"><span>from </span><span>__future__ </span><span>import </span><span>annotations
</span><span>
</span><span>import </span><span>itertools
</span><span>import </span><span>time
</span><span>from </span><span>collections.abc </span><span>import </span><span>Generator
</span><span>
</span><span>
</span><span>def </span><span>gen</span><span>() -&gt; Generator[</span><span>int</span><span>]:
</span><span>    </span><span>try</span><span>:
</span><span>        </span><span>yield from </span><span>itertools.count(</span><span>0</span><span>)
</span><span>    </span><span>finally</span><span>:
</span><span>        </span><span>print</span><span>(</span><span>&#34;cleaned up&#34;</span><span>)
</span><span>
</span><span>
</span><span>def </span><span>main</span><span>() -&gt; </span><span>None</span><span>:
</span><span>    generator </span><span>= </span><span>gen()
</span><span>    </span><span>for </span><span>elem </span><span>in </span><span>generator:
</span><span>        </span><span>print</span><span>(elem)
</span><span>        </span><span>if </span><span>elem </span><span>&gt; </span><span>3</span><span>:
</span><span>            </span><span>break
</span><span>    </span><span>generator.close()
</span><span>    </span><span>print</span><span>(</span><span>&#34;finished iterating&#34;</span><span>)
</span><span>    </span><span># Perform some expensive operation.
</span><span>    </span><span>time.sleep(</span><span>2</span><span>)
</span><span>
</span><span>
</span><span>if </span><span>__name__ </span><span>== </span><span>&#34;__main__&#34;</span><span>:
</span><span>    </span><span>main()
</span></code></pre>
<p><a href="https://samgeo.codes/python-generator-cleanup/2.html">Run with PyScript</a></p>
<p>Running with both CPython and <code>pypy</code> seems to work as desired! But we can even do a little bit better using the <a href="https://docs.python.org/3/library/contextlib.html#contextlib.closing"><code>closing</code></a> context manager from <code>contextlib</code>:</p>
<pre data-lang="python"><code data-lang="python"><span>from </span><span>__future__ </span><span>import </span><span>annotations
</span><span>
</span><span>import </span><span>itertools
</span><span>import </span><span>time
</span><span>from </span><span>collections.abc </span><span>import </span><span>Generator
</span><span>from </span><span>contextlib </span><span>import </span><span>closing
</span><span>
</span><span>
</span><span>def </span><span>gen</span><span>() -&gt; Generator[</span><span>int</span><span>]:
</span><span>    </span><span>try</span><span>:
</span><span>        </span><span>yield from </span><span>itertools.count(</span><span>0</span><span>)
</span><span>    </span><span>finally</span><span>:
</span><span>        </span><span>print</span><span>(</span><span>&#34;cleaned up&#34;</span><span>)
</span><span>
</span><span>
</span><span>def </span><span>main</span><span>() -&gt; </span><span>None</span><span>:
</span><span>    </span><span>with </span><span>closing(gen()) </span><span>as </span><span>generator:
</span><span>        </span><span>for </span><span>elem </span><span>in </span><span>generator:
</span><span>            </span><span>print</span><span>(elem)
</span><span>            </span><span>if </span><span>elem </span><span>&gt; </span><span>3</span><span>:
</span><span>                </span><span>break
</span><span>    </span><span>print</span><span>(</span><span>&#34;finished iterating&#34;</span><span>)
</span><span>    </span><span># Perform some expensive operation.
</span><span>    </span><span>time.sleep(</span><span>2</span><span>)
</span><span>
</span><span>
</span><span>if </span><span>__name__ </span><span>== </span><span>&#34;__main__&#34;</span><span>:
</span><span>    </span><span>main()
</span></code></pre>
<p><a href="https://samgeo.codes/python-generator-cleanup/3.html">Run with PyScript</a></p>
<p>Even when an exception is raised out of the body of the <code>for</code> loop, we&#39;ll still invoke the generator cleanup.</p>
<p>Cool, so we have finally arrived at a sensible idiom for ensuring that we invoke cleanup code with reasonable confidence (as much confidence as the chosen Python runtime can provide, at least).</p>
<p>In practice, very few people write code like this; CPython cleanup behavior is fairly predictable. But what happens when we venture into &#34;asyncland&#34;? Here&#39;s a similar example:</p>
<pre data-lang="python"><code data-lang="python"><span>from </span><span>__future__ </span><span>import </span><span>annotations
</span><span>
</span><span>import </span><span>asyncio
</span><span>import </span><span>itertools
</span><span>from </span><span>collections.abc </span><span>import </span><span>AsyncGenerator
</span><span>
</span><span>
</span><span>async def </span><span>gen</span><span>() -&gt; AsyncGenerator[</span><span>int</span><span>]:
</span><span>    </span><span>try</span><span>:
</span><span>        </span><span># `yield from` is not supported in async generators
</span><span>        </span><span>for </span><span>x </span><span>in </span><span>itertools.count(</span><span>0</span><span>)</span><span>:
</span><span>            </span><span>yield </span><span>x
</span><span>    </span><span>finally</span><span>:
</span><span>        </span><span># Required to enable &#34;cancellation&#34;
</span><span>        </span><span>await </span><span>asyncio.sleep(</span><span>0</span><span>)
</span><span>        </span><span>print</span><span>(</span><span>&#34;Clean up&#34;</span><span>)
</span><span>
</span><span>
</span><span>async def </span><span>main</span><span>() -&gt; </span><span>None</span><span>:
</span><span>    generator </span><span>= </span><span>gen()
</span><span>    </span><span>async for </span><span>elem </span><span>in </span><span>generator:
</span><span>        </span><span>print</span><span>(elem)
</span><span>        </span><span>if </span><span>elem </span><span>&gt; </span><span>3</span><span>:
</span><span>            </span><span>break
</span><span>    </span><span>print</span><span>(</span><span>&#34;finished iterating&#34;</span><span>)
</span><span>    </span><span># Perform some expensive operation.
</span><span>    </span><span>await </span><span>asyncio.sleep(</span><span>1</span><span>)
</span><span>
</span><span>
</span><span>if </span><span>__name__ </span><span>== </span><span>&#34;__main__&#34;</span><span>:
</span><span>    </span><span>asyncio.run(main())
</span></code></pre>
<p><a href="https://samgeo.codes/python-generator-cleanup/4.html">Run with PyScript</a></p>
<p>Running this with CPython demonstrates an issue very similar to what we observed when running the normal generator examples with <code>pypy</code>: the cleanup code is simply never run! But wait, when we run this using <code>pypy</code>, the cleanup code gets run?!</p>
<p>This is related to how async generator cleanup is managed: the event loop is required to register async generator hooks so that the language runtime can communicate with the event loop when an async generator object gets &#34;finalized&#34; (the work associated with cleaning up an unused object during garbage collection).</p>
<p>If you&#39;re curious why the <code>await asyncio.sleep(0)</code> is there: <code>asyncio.run</code> will invoke <code>cancel</code> on outstanding tasks once the provided coroutine has finished execution. The async generator cleanup task is one such task. When omitting the <code>asyncio.sleep(0)</code>, the print statement is executed.</p>
<p>Let&#39;s make the similar adjustment of inlining the <code>gen</code> call into the <code>async for</code> loop and see what happens:</p>
<pre data-lang="python"><code data-lang="python"><span>from </span><span>__future__ </span><span>import </span><span>annotations
</span><span>
</span><span>import </span><span>asyncio
</span><span>import </span><span>itertools
</span><span>from </span><span>collections.abc </span><span>import </span><span>AsyncGenerator
</span><span>
</span><span>
</span><span>async def </span><span>gen</span><span>() -&gt; AsyncGenerator[</span><span>int</span><span>]:
</span><span>    </span><span>try</span><span>:
</span><span>        </span><span>for </span><span>x </span><span>in </span><span>itertools.count(</span><span>0</span><span>)</span><span>:
</span><span>            </span><span>yield </span><span>x
</span><span>    </span><span>finally</span><span>:
</span><span>        </span><span># Required for &#34;reasons&#34;
</span><span>        </span><span>await </span><span>asyncio.sleep(</span><span>0</span><span>)
</span><span>        </span><span>print</span><span>(</span><span>&#34;Clean up&#34;</span><span>)
</span><span>
</span><span>
</span><span>async def </span><span>main</span><span>() -&gt; </span><span>None</span><span>:
</span><span>    </span><span>async for </span><span>elem </span><span>in </span><span>gen()</span><span>:
</span><span>        </span><span>print</span><span>(elem)
</span><span>        </span><span>if </span><span>elem </span><span>&gt; </span><span>3</span><span>:
</span><span>            </span><span>break
</span><span>    </span><span>print</span><span>(</span><span>&#34;finished iterating&#34;</span><span>)
</span><span>    </span><span># Perform some expensive operation.
</span><span>    </span><span>await </span><span>asyncio.sleep(</span><span>1</span><span>)
</span><span>
</span><span>
</span><span>if </span><span>__name__ </span><span>== </span><span>&#34;__main__&#34;</span><span>:
</span><span>    </span><span>asyncio.run(main())
</span></code></pre>
<p><a href="https://samgeo.codes/python-generator-cleanup/5.html">Run with PyScript</a></p>
<p>With CPython, the cleanup is now executed. This is because the generator is finalized as we exit the <code>async for</code> loop, so the cleanup task is scheduled <em>before</em> the <code>await syncio.sleep(1)</code> which allows the event loop to &#34;work on&#34; the cleanup task prior to the completion of the coroutine. With <code>pypy</code>, the cleanup is still executed, but due to the differences in garbage collection behavior, only after the <code>await asyncio.sleep(1)</code> completes.</p>
<p>Finally, let&#39;s take a look at using a similar explicit cleanup idiom with async code. The <code>contextlib</code> library provides an asynchronous variant of the <code>closing</code> context manager called <code>aclosing</code>:</p>
<pre data-lang="python"><code data-lang="python"><span>from </span><span>__future__ </span><span>import </span><span>annotations
</span><span>
</span><span>import </span><span>asyncio
</span><span>import </span><span>itertools
</span><span>from </span><span>collections.abc </span><span>import </span><span>AsyncGenerator
</span><span>from </span><span>contextlib </span><span>import </span><span>aclosing
</span><span>
</span><span>
</span><span>async def </span><span>gen</span><span>() -&gt; AsyncGenerator[</span><span>int</span><span>]:
</span><span>    </span><span>try</span><span>:
</span><span>        </span><span>for </span><span>x </span><span>in </span><span>itertools.count(</span><span>0</span><span>)</span><span>:
</span><span>            </span><span>yield </span><span>x
</span><span>    </span><span>finally</span><span>:
</span><span>        </span><span># Required for &#34;reasons&#34;
</span><span>        </span><span>await </span><span>asyncio.sleep(</span><span>0</span><span>)
</span><span>        </span><span>print</span><span>(</span><span>&#34;Clean up&#34;</span><span>)
</span><span>
</span><span>
</span><span>async def </span><span>main</span><span>() -&gt; </span><span>None</span><span>:
</span><span>    </span><span>async with </span><span>aclosing(gen()) </span><span>as </span><span>generator:
</span><span>        </span><span>async for </span><span>elem </span><span>in </span><span>generator:
</span><span>            </span><span>print</span><span>(elem)
</span><span>            </span><span>if </span><span>elem </span><span>&gt; </span><span>3</span><span>:
</span><span>                </span><span>break
</span><span>    </span><span>print</span><span>(</span><span>&#34;finished iterating&#34;</span><span>)
</span><span>    </span><span># Perform some expensive operation.
</span><span>    </span><span>await </span><span>asyncio.sleep(</span><span>1</span><span>)
</span><span>
</span><span>
</span><span>if </span><span>__name__ </span><span>== </span><span>&#34;__main__&#34;</span><span>:
</span><span>    </span><span>asyncio.run(main())
</span></code></pre>
<p><a href="https://samgeo.codes/python-generator-cleanup/6.html">Run with PyScript</a></p>
<p>This code has consistent, reliable behavior across both CPython and <code>pypy</code>.</p>
<p>There are some extra reasons why explicit cleanup code is <em>especially</em> important in async code:</p>
<ul>
<li>different event loop implementations may implement async generator hooks differently; so there is more surface area for weird behavior (see some of the linked PyScript examples which use Pyodide&#39;s <a href="https://pyodide.org/en/stable/usage/api/python-api/webloop.html">webloop</a>)</li>
<li>cleanup code that uses runtime context (e.g. inspects the currently running async task) will observe the runtime context of the tasks started by the event loop&#39;s async generator hooks</li>
</ul>
<h2 id="conclusion">Conclusion</h2>
<p>It&#39;s probably a reasonably good practice to follow predictable cleanup idioms when using generators (async or not). Practically, it seems unlikely that most folks will use these idioms with normal generators, but you should really consider applying these idioms when interacting with async generators.</p>
<p>I learned a <em>ton</em> while researching this post. Async generators are an interesting example of a language feature that requires the language runtime to work in tandem with an async event loop. Async generator cleanup used to be magic but now I think I have a reasonable mental model of what is going on and have a better sense of the idioms that might help to ensure predictable behavior.</p>
<h2 id="additional-reading">Additional reading</h2>
<ul>
<li><a href="https://peps.python.org/pep-0525/">PEP 525</a>: The PEP that describes async generators and their implementation. Includes details about async generator hooks.</li>
<li><a href="https://peps.python.org/pep-0533/">PEP 533</a>: A &#34;deferred&#34; PEP that proposes extensions to synchronous and asynchronous iterator protocols to support deterministic cleanup in for loops.</li>
<li><a href="https://docs.python.org/3/library/contextlib.html#contextlib.aclosing">contextlib documentation</a>: The first place that I noticed the <code>async with aclosing(gen()) as generator:</code> idiom.</li>
</ul>



</div></div>
  </body>
</html>
