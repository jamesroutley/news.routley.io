<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.rerun.io/blog/why-rust">Original</a>
    <h1>Why Rust?</h1>
    
    <div id="readability-page-1" class="page"><div id="__next"><div><div><div><p>I&#39;ve been a programmer for 20+ years, and few things excite me as much as Rust. My background is mostly in C++, though I have also worked in Python and Lua, and dabbled in many more languages. I started writing Rust around 2014, and since 2018 I&#39;ve been writing Rust full time. In my spare time I&#39;ve developed a popular Rust GUI crate, <a href="https://www.egui.rs/"><code>egui</code></a>.</p>
<p>When I co-founded <a href="https://www.rerun.io/">Rerun</a> earlier this year, the choice of language was obvious.</p>
<p>At Rerun we build visualization tools for computer vision and robotics. For that, we need a language that is fast and easy to parallelize. When running on desktop we want native speed, but we also want to be able to show our visualization on the web, or inline in a Jupyter Notebook or IDE.</p>
<p>By picking Rust, we get speed that rivals C and C++, and we can easily compile to Wasm. By using Rust for both our frontend and backend, we have a unified stack of <em>Rust everywhere</em>, simplifying our hiring.</p>
<p>Speaking of hiring, we hoped that by picking Rust, we would attract more high quality developers. This bet on hiring turned out even better than we had hoped.</p>
<h3>Sure, but why, <em>really</em>?</h3>
<p>Ok you got me! Those are only a part of the reasons we chose Rust. If I&#39;m honest, the main reason is because <em>I love Rust</em>.</p>
<p>I believe Rust is the most important development in system programming languages since C. What is novel is not any individual feature (<a href="https://doc.rust-lang.org/reference/influences.html">&#34;Rust is not a particularly original language&#34;</a>), but the fact that so many amazing features have come together in one mainstream language.</p>
<p>Rust is not a perfect language (scroll down for my complaints!), but it&#39;s so much nicer than anything else I&#39;ve used.</p>
<p>I&#39;m not alone in loving Rust - Rust has been the most loved language in the Stack Overflow Developer Survey <a href="https://survey.stackoverflow.co/2022/"><em>for seven years straight</em></a>. So what are the features that make me love Rust so much?</p>
<h3>Safety and speed</h3>
<p>&#34;Wait, that&#39;s two features!&#34; - well yes, but what is novel is that I get <em>both</em>.</p>
<p>To be clear: what I&#39;m talking about here is <em>memory safety</em>, which mean handling array bounds checks, data races, use-after free, segfaults, uninitialized memory, etc.</p>
<p>We&#39;ve had fast languages like C and C++, and then we&#39;ve had safe languages like Lisp, Java, and Python. The safe languages were all slower. Common wisdom said that a programming language could either be fast or safe, but not both. Rust has thoroughly disproved this, with speeds rivaling C even when writing safe Rust.</p>
<p>What&#39;s even more impressive is that Rust achieves safety and speed without using a garbage collector. Garbage collectors can be very useful, but they also tend to waste a lot of memory and/or create CPU spikes during GC collection. But more importantly, GC languages are difficult to <em>embed</em> in other environments (e.g. compile to Wasm - more on that later).</p>
<p>The big innovation leading to this &#34;fast safety&#34; is the borrow checker.</p>
<h3>The borrow checker</h3>
<p>The Rust Borrow Checker has it&#39;s roots in the <a href="https://www.cs.umd.edu/projects/cyclone/papers/cyclone-regions.pdf">Cyclone research language</a>, and is arguably the most important innovation in system program languages since C.</p>
<p>The gist of it is: each piece of data has exactly one owner. You can either share the data or <em>mutate</em> it, but never both at the same time. That is, you can either have one single mutating reference to it, OR many non-mutating references to the data.</p>
<p>This is a great way to structure your program, as it prevents many common bugs (not just memory safety ones). The magic thing is that Rust enforces this <em>at compile-time</em>.</p>
<p>A lot of people who are new to Rust struggle with the borrow checker, as it forbids you from doing things you are used to doing in other languages. The seasoned Rustacean knows to cut along the grain, to not fight the borrow checker, but to listen to its wisdom. When you structure your code so that each piece of data has one clear owner, and mutation is always exclusive, your program will become more clear and easy to reason about, and you will discover you have fewer bugs. It also makes it a lot easier to multi-thread your program.</p>
<h3>Enums</h3>
<p>Rust&#39;s <code>enum</code>s and exhaustive <code>match</code> statement are just amazing, and now that I&#39;m using them daily I can barely imagine how I could live without them for so long.</p>
<p>Consider you are writing a simple GUI that needs to handle events. An event is either a keyboard press, some pasted text, or a mouse button press:</p>
<pre><code><span>enum</span> <span>Event</span> <span>{</span>
    <span>KeyPress</span><span>(</span><span>char</span><span>)</span><span>,</span>
    <span>Pasted</span><span>(</span><span>String</span><span>)</span><span>,</span>
    <span>MouseButtonPress</span> <span>{</span>
        pos<span>:</span> <span>Pos2</span><span>,</span>
        button<span>:</span> <span>MouseButton</span><span>,</span>
    <span>}</span>
<span>}</span>

<span>fn</span> <span>handle_event</span><span>(</span>event<span>:</span> <span>Event</span><span>)</span> <span>{</span>
    <span>match</span> event <span>{</span>
        <span>Event</span><span>::</span><span>KeyPress</span><span>(</span>c<span>)</span> <span>=&gt;</span> <span>{</span>
            …
        <span>}</span>
        <span>Event</span><span>::</span><span>Pasted</span><span>(</span>text<span>)</span> <span>=&gt;</span> <span>{</span>
            …
        <span>}</span>
        <span>Event</span><span>::</span><span>MouseButtonPress</span><span>{</span> pos<span>,</span> button <span>}</span> <span>=&gt;</span> <span>{</span>
            …
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<p>If you add another alternative to <code>enum Event</code>, then <code>handle_event</code> will fail to compile until you add a handler for that new alternative.</p>
<p>Implementing the above in C or C++ would be very difficult and error prone (and the very existence of <a href="https://en.cppreference.com/w/cpp/utility/variant"><code>std::variant</code></a> makes me weep in dispair).</p>
<h3>Error handling</h3>
<p>Error handling is an extremely important aspect of the job of an engineer, and failure to report errors can lead to very serious bugs.</p>
<p>In C and Go you have to manually check and propagate errors:</p>
<pre><code>obj<span>,</span> err <span>:</span><span>=</span> <span>foo</span><span>(</span><span>)</span>
<span>if</span> err <span>!=</span> nil <span>{</span>
   <span>return</span> <span>0</span><span>,</span> err
<span>}</span>
result<span>,</span> err <span>:</span><span>=</span> obj<span>.</span><span>bar</span><span>(</span><span>)</span>
<span>if</span> err <span>!=</span> nil <span>{</span>
   <span>return</span> <span>0</span><span>,</span> err
<span>}</span>
</code></pre>
<p>This is extremely verbose and it is easy to forget an error.</p>
<p>In languages with exceptions, like C++, Java, and Python, you instead have the problem of invisible errors:</p>
<pre><code>auto result <span>=</span> <span>foo</span><span>(</span><span>)</span><span>.</span><span>bar</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<p>As a reader, I can&#39;t see where potential errors can occur. Even if I look at the function declaration for <code>foo</code> and <code>bar</code> I won&#39;t know whether or not they can throw exceptions, so I don&#39;t know whether or not I need a <code>try/catch</code> block around some piece of code.</p>
<p>In Rust, errors are propagated with the <code>?</code> operator:</p>
<pre><code><span>let</span> result <span>=</span> <span>foo</span><span>(</span><span>)</span><span>?</span><span>.</span><span>bar</span><span>(</span><span>)</span><span>?</span><span>;</span>
</code></pre>
<p>The <code>?</code> operator means: if the previous expression resulted in an error, return that error. Failure to add a <code>?</code> results in a compilation error, so you must propagate (or handle) all errors. This is explicit, yet terse, and I love it.</p>
<p>Not everything is perfect though - how error types are declared and combined is something the ecosystem is still trying to figure out, but for all its flaws I find the Rust approach to error handling to be the best I&#39;ve ever used.</p>
<h3>Scoped resource management</h3>
<p>Rust will automatically free memory and close resources when the resource falls out of scope. For instance:</p>
<pre><code><span>{</span>
    <span>let</span> <span>mut</span> file <span>=</span> <span>std<span>::</span>fs<span>::</span></span><span>File</span><span>::</span><span>open</span><span>(</span><span>&amp;</span>path<span>)</span><span>?</span><span>;</span>

    <span>let</span> <span>mut</span> contents <span>=</span> <span>Vec</span><span>::</span><span>new</span><span>(</span><span>)</span><span>;</span>
    file<span>.</span><span>read_to_end</span><span>(</span><span>&amp;</span><span>mut</span> contents<span>)</span><span>?</span><span>;</span>

    …

    
    
    
<span>}</span>
</code></pre>
<p>If you&#39;re used to C++ this is nothing new, and it is indeed one of the things I like the most about C++. But Rust improves this by having better move semantics and lifetime tracking.</p>
<p>This feature has been likened to a compile-time garbage collector. This is in contrast with a more common runtime garbage collected language, where memory is freed <em>eventually</em> (at some future GC pass). Such languages tend to use a lot more memory, but worse: if you forget to explicitly close a file or a socket in such a language, it will remain open for far too long which can lead to very subtle bugs.</p>
<h3>Wasm</h3>
<p>I find WebAssembly (or Wasm for short) a very exciting technology, and it probably deserves a blog post on its own. In short, I am excited because with Wasm:</p>
<ul>
<li>I can write web apps in another language than JavaScript</li>
<li>I can write web apps that are fast</li>
<li>I can safely and efficiently sandbox other peoples&#39; code</li>
</ul>
<p>So what does Wasm have to do with Rust? Well, it is dead easy to compile Rust to Wasm - just pass <code>--target wasm32-unknown-unknown</code> to <code>cargo</code>, and you are done!</p>
<p>And then there is <a href="https://github.com/bytecodealliance/wasmtime"><code>wasmtime</code></a>, a high performance runtime for Wasm, written in Rust. This means we can have fast plugins, written in Rust, compiled to Wasm, running in our tool. <em>Rust everywhere!</em></p>
<h3>Traits</h3>
<p>The Rust <code>trait</code> is really nifty as it is the interface for both run-time polymorphism and compile-time polymorphism. For instance:</p>
<pre><code><span>trait</span> <span>Foo</span> <span>{</span>
    <span>fn</span> <span>do_stuff</span><span>(</span><span>&amp;</span><span>self</span><span>)</span><span>;</span>
<span>}</span>



<span>fn</span> <span>runtime</span><span>(</span>obj<span>:</span> <span>&amp;</span><span>dyn</span> <span>Foo</span><span>)</span> <span>{</span>
    obj<span>.</span><span>do_stuff</span><span>(</span><span>)</span><span>;</span>
<span>}</span>




<span>fn</span> <span>compile_time</span><span>&lt;</span><span>T</span><span>:</span> <span>Foo</span><span>&gt;</span><span>(</span>obj<span>:</span> <span>&amp;</span><span>T</span><span>)</span> <span>{</span>
    obj<span>.</span><span>do_stuff</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<h3>Tooling</h3>
<p>Rust has amazing tooling, which makes learning and using Rust a much more pleasant experience compared to most other languages.</p>
<p>First of all: the error messages from the compiler are superb. They point out what your mistake was, why it was a mistake, and then often point you in the right direction. The Rust compiler errors are perhaps the best error messages of any software anywhere (which is fortunate, since learning Rust can be difficult).</p>
<p>Then there is <em>Cargo</em>, the Rust package manager and build system. Having a package manager and a build system for a language may seem like a low bar, but when you come from C++, it is amazing. You can build almost any Rust library with a simple <code>cargo build</code>, and test it with <code>cargo test</code>.</p>
<p>Rust libraries are known as <em>crates</em> (and can be browsed at <a href="https://crates.io/">crates.io</a>). Though the ecosystem is nascent, there is already a plethora of high quality crates, and trying out a crate is as easy as <code>cargo add</code>. There is of course some legitimate worry that the Rust crate ecosystem could devolve into the crazy left-pad world of <code>npm</code>, and it is something to be wary about, but so far the Rust crates keep an overall high quality.</p>
<p>And then there is the wonderful <a href="https://rust-analyzer.github.io/">rust analyzer</a> which provides completion, go-to-definition, and refactoring to my editor.</p>
<p>Rust documentation is also really good, partially because of the effort of its writers, partially because of the amazing tooling. <code>cargo doc</code> is a godsend, as are <em>doc-tests</em>:</p>
<pre><code>






<span>fn</span> <span>add</span><span>(</span>a<span>:</span> <span>i32</span><span>,</span> b<span>:</span> <span>i32</span><span>)</span> <span>-&gt;</span> <span>i32</span> <span>{</span>
    a <span>+</span> b
<span>}</span>
</code></pre>
<p>The compiler will actually run the example code to check that it is correct! <em>Amazeballs!</em></p>
<h3>The bad</h3>
<p>It&#39;s not all unicorns and lollipops. Rust has some pretty rough edges, and may not be for everyone.</p>
<h4>It&#39;s not a simple language</h4>
<p>Rust is difficult, and it takes a while to learn. Even if you know C and some functional programming, you still need to learn about the borrow checker and lifetime annotations. Still, I would put Rust as both simpler and easier than C++.</p>
<h4>Compile times</h4>
<p>This is unfortunately something Rust has inherited from C++. Things are bad, and are only slowly getting better, and I doubt it will ever be fast as e.g. Go.</p>
<h4>Noisy syntax</h4>
<p>You will see a lot of <code>&lt;&#39;_&gt;</code> and <code>::&lt;T&gt;</code> in Rust, and it ain&#39;t always pretty (but you get used to it).</p>
<h4>Floating point behavior</h4>
<p><code>f32</code> and <code>f64</code> does not implement <a href="https://doc.rust-lang.org/stable/std/cmp/trait.Ord.html"><code>Ord</code></a>. This means you cannot sort on a float without jumping through a lot of hoops, and this is very annoying. I wish the float would just use <a href="https://en.wikipedia.org/wiki/IEEE_754#Total-ordering_predicate">total ordering</a> and take the performance hit.</p>
<p>Same with <a href="https://doc.rust-lang.org/stable/std/hash/trait.Hash.html"><code>Hash</code></a>, which <code>f32</code> and <code>f64</code> also doesn&#39;t implement.</p>
<p>Thankfully there is the <a href="https://docs.rs/ordered-float"><code>ordered-float</code></a> crate, but the ergonomics of using a wrapped type isn&#39;t great.</p>
<h4>Still lacking a lot of libraries</h4>
<p>The Rust crate ecosystem is good, but C and C++ has a huge head start and it will take a long time for Rust to catch up. For us at Rerun, that pain is most urgently felt in the lack of libraries for scientific computing and computer vision, as well as the lack of mature GUI libraries.</p>
<h4>Flawed, but improving</h4>
<p>Five years ago my gripes with Rust were much longer. Rust is steadily improving, with a new release every six weeks. This is an impressive pace, especially since there are no breaking changes.</p>
<h3>Conclusion</h3>
<p>At the end of the day, a programming language is a tool like any other, and you need to pick the right tool for the job. But sometimes, the right tool for the job is actually the tool you love the most. Perhaps that is exactly <em>why</em> you love it so much?</p>
<p>In many ways, using C++ for the engine, Go for the backend, and JS for the frontend would have been the &#34;safe&#34; choice. We could have made use of the many great C++ libraries for linear algebra and computer vision, and we could have used one of the many popular and excellent frontend libraries for JS. In the short term that might have been the right choice, but it would have severely limited what we could accomplish going forward. It would have been a bet on the past. At Rerun, we are building the tools of the future, and for that we need to be using the language of the future.</p>
<p><em>If you&#39;re interested in what we&#39;re building at Rerun, then <a href="https://5li7zhj98k8.typeform.com/to/IeCL0ERA?utm_source=website&amp;utm_content=blog">join our waitlist</a> or <a href="https://twitter.com/ernerfeldt">follow me on Twitter</a>.</em></p></div></div></div></div></div>
  </body>
</html>
