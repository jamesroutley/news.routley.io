<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jeremykun.com/2023/02/13/googles-fully-homomorphic-encryption-compiler-a-primer/">Original</a>
    <h1>Google’s fully homomorphic encryption compiler – a primer</h1>
    
    <div id="readability-page-1" class="page"><div>
		
<p>Back in May of 2022 I transferred teams at Google to work on Fully Homomorphic Encryption (<a href="https://buttondown.email/j2kun/archive/career-update-homomorphic-encryption/">newsletter announcement</a>). Since then I’ve been working on a variety of projects in the space, including being the primary maintainer on <a href="http://github.com/google/fully-homomorphic-encryption">github.com/google/fully-homomorphic-encryption</a>, which is an open source FHE compiler for C++. This article will be an introduction to how to use it to compile programs to FHE, as well as a quick overview of its internals.</p>



<p>If you’d like to contribute to this project, please reach out to me at <a href="mailto:mathintersectprogramming@gmail.com">mathintersectprogramming@gmail.com</a> or at <a href="https://mathstodon.xyz/@j2kun">j2kun@mathstodon.xyz</a>. I have a few procedural hurdles to overcome before I can accept external contributions (with appropriate git commit credit), but if there’s enough interest I will make time for it sooner as opposed to later.</p>



<h2>Overview</h2>



<p>The core idea of fully homomorphic encryption (henceforth FHE) is that you can encrypt data and then run programs on it without ever decrypting it. In the extreme, even if someone had physical access to the machine and could inspect the values of individual memory cells or registers while the program was running, they would not see any of the bits of the underlying data being operated on (without cracking the cryptosystem).</p>



<p>Our FHE compiler converts C++ programs that operate on plaintext to programs that operate on the corresponding FHE ciphertexts (since it emits high-level code that then needs to be further compiled, it could be described as a <em>transpiler</em>). More specifically, it converts a specific <em>subset</em> of valid C++ programs—more on what defines that subset later—to programs that run the same program on encrypted data via one of the supported FHE cryptosystem implementations. In this sense it’s close to a traditional compiler: parse the input, run a variety of optimization passes, and generate some output. However, as we’ll see in this article, the unique properties of FHE make the compiler more like hardware circuit toolchains.</p>



<p>The variety of FHE supported by the compiler today is called “gate bootstrapping.” I won’t have time to go into intense detail about the math behind it, but suffice it to say that this technique gives away performance in exchange for a simpler job of optimizing and producing a working program. What I will say is that this blend of FHE encrypts <em>each bit</em> of its input into a separate ciphertext, and then represents the program as a boolean (combinational) circuit—composed of gates like AND, OR, XNOR, etc. Part of the benefit of the compiler is that it manages a mapping of higher order types like integers, arrays, and structs, to lists of encrypted booleans and back again.</p>



<p>A few limitations result from this circuit-based approach, which will be woven throughout the rest of this tutorial. First is that all loops must be fully unrolled and have statically-known bounds. Second, constructs like pointers, and dynamic memory allocation are not supported. Third, all control flow is multiplexed, meaning that all branches of all if statements are evaluated, and only then is one chosen. Finally, there are important practical considerations related to the bit-width of the types used and the expansion of cleartexts into ciphertexts that impact the performance of the resulting program.</p>



<p>On the other hand, combinational circuit optimization is a well-studied problem with off-the-shelf products that can be integrated (narrator: they did integrate some) into the FHE compiler to make the programs run faster. </p>



<h2>Dependencies</h2>



<p><em>tl;dr:</em> check out <a href="https://github.com/google/fully-homomorphic-encryption/tree/main/docker">the dockerfiles</a>.</p>



<p>Google’s internal build system is called <code>blaze</code>, and it’s open source counterpart (equivalent in all except name) is called <code>bazel</code>. One of the first curious things you’ll notice about the compiler is that bazel is used both to build the project and to <em>use</em> the project (the latter I’d like to change). So you’ll need to install bazel, and an easy way to do that is to <a href="https://bazel.build/install/bazelisk">install <code>bazelisk</code></a>, which is the analogue of <code>nvm</code> for Node or <code>pyenv</code> for Python. You won’t need multiple versions of bazel, but this is just the easiest way to install the latest version. I’ll be using Bazel 4.0.0, but there are newer versions that should work just fine as well.</p>



<p>You’ll need a C compiler (I use gcc12) because most of the project’s dependencies are built from source (see next paragraph), and a small number of external libraries and programs to support some of the circuit optimizer plugins. For debian-based systems, this is the full list</p>


<div><pre title="">apt-get update &amp;&amp; apt-get install -y \
  gcc \
  git \
  libtinfo5 \
  python \
  python3 \
  python3-pip \
  autoconf \
  libreadline-dev \
  flex \
  bison \
  wget
</pre></div>


<p>As mentioned above, all the other dependencies are built <em>from source</em>, and this will take a while the first time you build the project. So you might as well clone and get that build started while you read. The command below will build the project and all the example binaries, and then cache the intermediate build artifacts for future builds, only recompiling what has changed in the mean time. See the Bazel/Starlark section for more details on what this command is doing. <strong>Note: </strong>the one weird case is LLVM. If you use an exotic operating system (or a docker container, don’t get me started on why this is an issue) then bazel may choose to build LLVM from scratch, which will take an hour or two for the first build. It may also fail due to a missing dependency of your system, which will be extremely frustrating (this is the #1 complaint in our GitHub issues). But, if you’re on a standard OS/architecture combination (<a href="https://github.com/grailbio/bazel-toolchain/blob/08d1aa8cee67a7a9c51c09225cead1dad42dadc3/toolchain/internal/common.bzl">as enumerated here</a>), it will just fetch the right LLVM dependency and install it on your system.</p>


<div><pre title="">git clone https://github.com/google/fully-homomorphic-encryption.git
cd fully-homomorphic-encryption
bazel build ...:all
</pre></div>


<p>A clean build on my home machine takes about 16 minutes.</p>



<h2>Two end-to-end examples: add and string_cap</h2>



<p>In this section I’ll show two end-to-end examples of using the compiler as an end user. The first will be for a dirt-simple program that adds two 32-bit integers. The second will be for a program that capitalizes the first character of each word in an ASCII string. The examples are already in the repository under <a href="https://github.com/google/fully-homomorphic-encryption/tree/main/transpiler/examples">transpiler/examples</a> by the names <code>simple_sum</code> and <code>string_cap</code>.</p>



<p>Both of these programs will have the form of compiling a single function that is the entry point for the FHE part of the program, and providing a library and API to integrate it with a larger program. </p>



<p>First <code>simple_sum</code>. Add a header and source file like you would any standard C++ program, but with one extra line to tell the compiler which function is the function that should be compiled (along with any functions called within it).</p>


<div><pre title="">// add.h
int add(int a, int b);

// add.cc
#include &#34;add.h&#34;

#pragma hls_top
int add(int a, int b) {
  return a + b;
}
</pre></div>


<p>The line <code>#pragma hls_top</code> tells the compiler which function is the entry point. Incidentally, <code>hls</code> stands for “<a href="https://en.wikipedia.org/wiki/High-level_synthesis">high level synthesis</a>,” and the pragma itself comes from the <a href="https://github.com/google/xls">XLS</a> project, which we use as our parser and initial circuit builder. Here ‘top’ just means top level function.</p>



<p>Then, inside a file in the same directory called <code>BUILD</code> (see the Bazel/Starlark section next for an overview of the build system), create a build target that invokes the FHE compiler. In our case we’ll use the <a href="https://github.com/openfheorg/openfhe-development">OpenFHE backend</a>.</p>


<div><pre title=""># BUILD
# loads the FHE compiler as an extension to Bazel.
load(&#34;//transpiler:fhe.bzl&#34;, &#34;fhe_cc_library&#34;)

fhe_cc_library(
  name = &#34;add_fhe_lib&#34;,
  src = &#34;add.cc&#34;,
  hdrs = [&#34;add.h&#34;],
  encryption = &#34;openfhe&#34;,  # backend cryptosystem library
  interpreter = True,      # use dynamic thread scheduling
  optimizer = &#34;yosys&#34;,     # boolean circuit optimizer
)
</pre></div>


<p>The full options for this build rule (i.e., the documentation of the compiler’s main entry point) can be found in the <a href="https://github.com/google/fully-homomorphic-encryption/blob/f6b6fe3894e134827010524914d8993aa994ab08/transpiler/fhe.bzl#L585">docstring of the bazel macro</a>. I picked the parameters that have what I think of as the best tradeoff between stability and performance.</p>



<p>If you run <code>bazel build add_fhe_lib</code>, then you will see it build but nothing else (see the “intermediate files” section for more on what’s happening behind the scenes). But if you typed something wrong in the build file it would err at this point. It generates a header and <code>cc</code> file that contains the same API as <code>add</code>, but with different types for the arguments and extra arguments needed by the FHE library backend.</p>



<p>Next we need a main routine that uses the library. Since we’re using OpenFHE as our backend, it requires some configuration and the initial encryption of its inputs. The <a href="https://github.com/google/fully-homomorphic-encryption/tree/main/transpiler/codelab/add">full code</a>, with some slight changes for the blog, looks like this</p>


<div><pre title="">#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;ostream&gt;

#include &#34;absl/strings/numbers.h&#34;
#include &#34;transpiler/codelab/add/add_fhe_lib.h&#34;
#include &#34;transpiler/data/openfhe_data.h&#34;

constexpr auto kSecurityLevel = lbcrypto::MEDIUM;

int main(int argc, char** argv) {
  if (argc &lt; 3) {
    fprintf(stderr, &#34;Usage: add_main [int] [int]\n\n&#34;);
    return 1;
  }

  int x, y;
  if(!absl::SimpleAtoi(argv[1], &amp;x)) {
    std::cout &lt;&lt; &#34;Bad int &#34; &lt;&lt; argv[1] &lt;&lt; std::endl;
    return 1;
  }
  if(!absl::SimpleAtoi(argv[2], &amp;y)) {
    std::cout &lt;&lt; &#34;Bad int &#34; &lt;&lt; argv[2] &lt;&lt; std::endl;
    return 1;
  }
  std::cout &lt;&lt; &#34;Computing &#34; &lt;&lt; x &lt;&lt; &#34; + &#34; &lt;&lt; y &lt;&lt; std::endl;

  // Set up backend context and encryption keys.
  auto context = lbcrypto::BinFHEContext();
  context.GenerateBinFHEContext(kSecurityLevel);
  auto sk = context.KeyGen();
  context.BTKeyGen(sk);

  OpenFhe&lt;int&gt; ciphertext_x = OpenFhe&lt;int&gt;::Encrypt(x, context, sk);
  OpenFhe&lt;int&gt; ciphertext_y = OpenFhe&lt;int&gt;::Encrypt(y, context, sk);
  OpenFhe&lt;int&gt; result(context);
  auto status = add(result, ciphertext_x, ciphertext_y, context);
  if(!status.ok()) {
    std::cout &lt;&lt; &#34;FHE computation failed: &#34; &lt;&lt; status &lt;&lt; std::endl;
    return 1;
  }

  std::cout &lt;&lt; &#34;Result: &#34; &lt;&lt; result.Decrypt(sk) &lt;&lt; &#34;\n&#34;;
  return 0;
}
</pre></div>


<p>The parts that are not obvious boilerplate include:</p>



<p>Configuring the security level of the OpenFHE library (which is called BinFHE to signal it’s doing binary circuit FHE).</p>


<div><pre title="">constexpr auto kSecurityLevel = lbcrypto::MEDIUM;
</pre></div>


<p>Setting up the initial OpenFHE secret key</p>


<div><pre title=""> auto context = lbcrypto::BinFHEContext();
 context.GenerateBinFHEContext(kSecurityLevel);
 auto sk = context.KeyGen();
 context.BTKeyGen(sk);
</pre></div>


<p>Encrypting the inputs. This uses an API provided by the compiler (though because the project was a research prototype, I think the original authors never got around to unifying the “set up the secret key” part behind an API) and included in this from <code>include &#34;transpiler/data/openfhe_data.h&#34;</code></p>


<div><pre title=""> OpenFhe&lt;int&gt; ciphertext_x = OpenFhe&lt;int&gt;::Encrypt(x, context, sk);
 OpenFhe&lt;int&gt; ciphertext_y = OpenFhe&lt;int&gt;::Encrypt(y, context, sk);
</pre></div>


<p>Then calling the FHE-enabled <code>add</code> function, and decrypting the results.</p>



<p>Then create another <code>BUILD </code>rule for the binary:</p>


<div><pre title="">cc_binary(
    name = &#34;add_openfhe_fhe_demo&#34;,
    srcs = [
        &#34;add_openfhe_fhe_demo.cc&#34;,
    ],
    deps = [
        &#34;:add_fhe_lib&#34;,
        &#34;//transpiler/data:openfhe_data&#34;,
        &#34;@com_google_absl//absl/strings&#34;,
        &#34;@openfhe//:binfhe&#34;,
    ],
)
</pre></div>


<p>Running it with bazel:</p>


<div><pre title="">$ bazel run add_openfhe_fhe_demo -- 5 7
Computing 5 + 7
Result: 12
</pre></div>


<p>Timing this on my system, it takes a little less than 7 seconds.</p>



<p>On to a more complicated example: <code>string_cap</code>, which will showcase loops and arrays. This was slightly simplified from the <a href="https://github.com/google/fully-homomorphic-encryption/tree/main/transpiler/examples/string_cap">GitHub example</a>. First the header and source files:</p>


<div><pre title="">// string_cap.h
#define MAX_LENGTH 32
void CapitalizeString(char my_string[MAX_LENGTH]);

// string_cap.cc
#include &#34;string_cap.h&#34;

#pragma hls_top
void CapitalizeString(char my_string[MAX_LENGTH]) {
  bool last_was_space = true;
#pragma hls_unroll yes
  for (int i = 0; i &lt; MAX_LENGTH; i++) {
    char c = my_string[i];
    if (last_was_space &amp;&amp; c &gt;= &#39;a&#39; &amp;&amp; c &lt;= &#39;z&#39;) {
      my_string[i] = c - (&#39;a&#39; - &#39;A&#39;);
    }
    last_was_space = (c == &#39; &#39;);
  }
}
</pre></div>


<p>Now there’s a bit to discuss. First, the string has a static length known at compile time. This is required because the FHE program is a boolean circuit. It defines wires for each of the inputs, and it must know how many wires to define. In this case it will be a circuit with <code>32 * 8</code> wires, one for each bit of each character in the array.</p>



<p>The second new thing is the <code>#pragma hsl_unroll yes</code>, which, like <code>hls_top</code>, tells the XLS compiler to fully unroll that loop. Because the FHE program is a static circuit, it cannot have any loops. XLS unrolls our loops for us, and incidentally, I learned recently that it uses the Z3 solver to first <em>prove</em> the loops can be unrolled (which can lead to some slow compile times for complex programs). I’m not aware of other compilers that do this proving part. It looks like <a href="https://llvm.org/doxygen/LoopUnroll_8cpp_source.html#l00269">LLVM’s loop unroller</a> just slingshots its CPU cycles into the sun if it’s asked to fully unroll an infinite loop.</p>



<p>The main routine is similar as before:</p>


<div><pre title="">#include &lt;array&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

#include &#34;openfhe/binfhe/binfhecontext.h&#34;
#include &#34;transpiler/data/openfhe_data.h&#34;
#include &#34;transpiler/examples/string_cap/string_cap.h&#34;
#include &#34;transpiler/examples/string_cap/string_cap_openfhe_yosys_interpreted.h&#34;

int main(int argc, char** argv) {
  if (argc &lt; 2) {
    fprintf(stderr, &#34;Usage: string_cap_openfhe_testbench string_input\n\n&#34;);
    return 1;
  }

  std::string input = argv[1];
  input.resize(MAX_LENGTH, &#39;\0&#39;);
  std::string plaintext(input);

  auto cc = lbcrypto::BinFHEContext();
  cc.GenerateBinFHEContext(lbcrypto::MEDIUM);
  auto sk = cc.KeyGen();
  cc.BTKeyGen(sk);

  auto ciphertext = OpenFheArray&lt;char&gt;::Encrypt(plaintext, cc, sk);
  auto status = CapitalizeString(ciphertext, cc);
  if (!status.ok()) {
    std::cout &lt;&lt; &#34;FHE computation failed &#34; &lt;&lt; status &lt;&lt; std::endl;
    return 1;
  };
  std::cout &lt;&lt; &#34;Decrypted result: &#34; &lt;&lt; ciphertext.Decrypt(sk) &lt;&lt; std::endl;
}
</pre></div>


<p>The key differences are:</p>



<ul>
<li>We resize the input to be exactly <code>MAX_LENGTH</code>, padding with null bytes.</li>



<li>We use <code>OpenFheArray</code> instead of <code>OpenFhe</code> to encode an array of characters.</li>
</ul>



<p>And now omitting the binary’s <a href="https://github.com/google/fully-homomorphic-encryption/blob/main/transpiler/examples/string_cap/BUILD#L35">build rule</a> and running it, we get</p>


<div><pre title="">$ bazel run string_cap_openfhe_yosys_interpreted_testbench -- &#39;hello there&#39;
Decrypted result: Hello There
</pre></div>


<p>Interestingly, this also takes about 6 seconds to run on my machine (same as the “add 32-bit integers” program). It would be the same runtime for a longer string, up to 32 characters, since, of course, the program processes all <code>MAX_LENGTH</code> characters without knowing if they are null bytes.</p>



<h2>An overview of Bazel and Starlark</h2>



<p>The FHE compiler originated within Google in a curious way. It was created by dozens of volunteer contributors (<a href="https://en.wikipedia.org/wiki/Side_project_time#Google_implementation">20%-ers</a>, as they say), many of whom worked on the <a href="https://github.com/google/xls">XLS hardware synthesis toolchain</a>, which is a core component of the compiler. Because of these constraints, and also because it was happening entirely in Google, there wasn’t much bandwidth available to make the compiler independent of Google’s internal build tooling.</p>



<p>This brings us to Bazel and Starlark, which is the user-facing façade of the compiler today. <a href="https://bazel.build/">Bazel</a> is the open source analogue of Google’s internal build system (“Blaze” is the internal tool), and <a href="https://bazel.build/rules/language">Starlark</a> is its Python-inspired scripting language. There are <a href="https://medium.com/windmill-engineering/bazel-is-the-worst-build-system-except-for-all-the-others-b369396a9e26">lots of opinions</a> about Bazel that I won’t repeat here. Instead I will give a minimal overview of how it works with regards to the FHE compiler.</p>



<p>First some terminology. To work with Bazel you do the following.</p>



<ul>
<li>Define a <a href="https://github.com/google/fully-homomorphic-encryption/blob/main/WORKSPACE"><code>WORKSPACE</code> file</a> which defines all your project’s external dependencies, how to fetch their source code, and what bazel commands should be used to build them. This can be thought of as a top-level CMakeLists, except that it doesn’t contain any instructions for building the project beyond declaring the root of the project’s directory tree and the project’s name.</li>



<li>Define a set of <code>BUILD</code> files in each subdirectory, declaring the <em>build targets</em> that can be built from the source files in that directory (but not its subdirectories). This is analogous to CMakeLists files in subdirectories. Each build target can declare dependence on other build targets, and <code>bazel build</code> ensures the dependencies are built first, and caches the build results across a session. Many projects have a <code>BUILD</code> file in the project root to expose the project’s public libraries and APIs.</li>



<li>Use the built-in bazel <em>rules</em> like <code>cc_library</code> and <code>cc_binary</code> and <code>cc_test</code> to group files into libraries that can be built with <code>bazel build</code>, executable binaries that can also be run with <code>bazel run</code>, and tests that can also be run with <code>bazel test</code>. Most bazel rules boil down to calling some executable program like <code>gcc</code> or <code>javac</code> with specific arguments, while also keeping track of the accumulated dependency set of build artifacts in a “hermetic” location on the filesystem.</li>



<li>Write any additional bazel <em>macros</em> that chain together built-in bazel commands, e.g., for defining logical groupings of build commands that need to happen in a particular sequence. Macros look like Python functions that call individual bazel rules and possibly pass data between them. They’re written in <code>.bzl</code> files which are interpreted directly by <code>bazel</code>.</li>
</ul>



<p>Generally, <code>bazel</code> builds targets in two phases. First—the analysis phase—it loads all the <code>BUILD</code> files and imported <code>.bzl</code> files, and scans for all the rules that were called. In particular, it <em>runs</em> the macros, because it needs to know what rules are called by the macros (and rules can be guarded by control flow, or their arguments can be generated dynamically, etc.). But it doesn’t <em>run</em> the build rules themselves. In doing this, it can build a complete graph of dependencies, and report errors about typos, missing dependencies, cycles, etc. Once the analysis phase is complete, it runs the underlying rules in dependency order, and caches the results. Bazel will only run a rule again if something changes with the files it depends on or its underlying dependencies.</p>



<p>The FHE compiler is written in Starlark, in the sense that the main entrypoint for the compiler is the Bazel macro <code>fhe_cc_library</code>. This macro chains together a bunch of rules that call the parser, circuit optimizer, and codegen steps, each one being its own Bazel rule. Each of these rules in turn declare/write files that we can inspect—see the next section.</p>



<p>Here’s what <code>fhe_cc_library</code> looks like (a subset of the control flow for brevity)</p>


<div><pre title="">def fhe_cc_library(name, src, hdrs, copts = [], num_opt_passes = 1,
        encryption = &#34;openfhe&#34;, optimizer = &#34;xls&#34;, interpreter = False, library_name = None,
        **kwargs):
    &#34;&#34;&#34;A rule for building FHE-based cc_libraries. [docstring ommitted]&#34;&#34;&#34;
    transpiled_xlscc_files = &#34;{}.cc_to_xls_ir&#34;.format(name)
    library_name = library_name or name
    cc_to_xls_ir(
        name = transpiled_xlscc_files,
        library_name = library_name,
        src = src,
        hdrs = hdrs,
        defines = kwargs.get(&#34;defines&#34;, None),
    )

    # below, adding a leading colon to the `src` argument points the source files attribute
    # to the files generated by a previously generated rule, with the name being the unique
    # identifier.
    transpiled_structs_headers = &#34;{}.xls_cc_transpiled_structs&#34;.format(name)
    xls_cc_transpiled_structs(
        name = transpiled_structs_headers,
        src = &#34;:&#34; + transpiled_xlscc_files,
        encryption = encryption,
    )

    if optimizer == &#34;yosys&#34;:  # other branch omitted for brevity
        verilog = &#34;{}.verilog&#34;.format(name)
        xls_ir_to_verilog(name = verilog, src = &#34;:&#34; + transpiled_xlscc_files)
        netlist = &#34;{}.netlist&#34;.format(name)
        verilog_to_netlist(name = netlist, src = &#34;:&#34; + verilog, encryption = encryption)
        cc_fhe_netlist_library(
            name = name,
            src = &#34;:&#34; + netlist,
            encryption = encryption,
            interpreter = interpreter,
            transpiled_structs = &#34;:&#34; + transpiled_structs_headers,
            copts = copts,
            **kwargs
        )
</pre></div>


<p>The rules invoked by the macro include:</p>



<ul>
<li><code>cc_to_xls_ir</code>, which calls the parser <code>xlscc</code> and outputs an intermediate representation of the program as a high-level circuit. This step does the loop unrolling and other smarts related to converting C++ to a circuit.</li>



<li><code>xlscc_transpiled_structs</code>, which calls a binary that handles structs (this part is complicated and will not be covered in this article).</li>



<li><code>xls_ir_to_verilog</code>, which converts the XLS IR to verilog so that it can be optimized using Yosys/ABC, a popular circuit design and optimization program.</li>



<li><code>verilog_to_netlist</code>, which invokes Yosys to both optimize the circuit and convert it to the lowest-level IR, which is called a <a href="https://en.wikipedia.org/wiki/Netlist">netlist</a>.</li>



<li><code>cc_fhe_netlist_library</code>, which calls the codegen step to generate C++ code from the netlist in the previous step.</li>
</ul>



<p>All of this results in a C++ library (generated by the last step) that can be linked against an existing program and whose generated source we can inspect. Now let’s see what each generated file looks like.</p>



<h2>The intermediate files generated by the compiler</h2>



<p>Earlier I mentioned that bazel puts the intermediate files generated by each build rule into a “hermetic” location on the filesystem. That location is sym-linked from the workspace root by a link called <code>bazel-bin</code>.</p>


<div><pre title="">$ ls -al . | grep bazel-bin
/home/j2kun/.cache/bazel/_bazel_j2kun/42987a3d4769c6105b2fa57d2291edc3/execroot/com_google_fully_homomorphic_encryption/bazel-out/k8-opt/bin
</pre></div>


<p>Within <code>bazel-bin</code> there’s a mirror of the project’s source tree, and in the directory for a build rule you can find all the generated files. For our 32-bit adder here’s what it looks like:</p>


<div><pre title="">$ ls
_objs                                   add_test
add_fhe_lib.cc                          add_test-2.params
add_fhe_lib.entry                       add_test.runfiles
add_fhe_lib.generic.types.h             add_test.runfiles_manifest
add_fhe_lib.h                           libadd.a
add_fhe_lib.ir                          libadd.a-2.params
add_fhe_lib.netlist.v                   libadd.pic.a
add_fhe_lib.netlist.v.dot               libadd.pic.a-2.params
add_fhe_lib.opt.ir                      libadd.so
add_fhe_lib.types.h                     libadd.so-2.params
add_fhe_lib.v                           libadd_fhe_lib.a
add_fhe_lib.ys                          libadd_fhe_lib.a-2.params
add_fhe_lib_meta.proto                  libadd_fhe_lib.pic.a
add_openfhe_fhe_demo                    libadd_fhe_lib.pic.a-2.params
add_openfhe_fhe_demo-2.params           libadd_fhe_lib.so
add_openfhe_fhe_demo.runfiles           libadd_fhe_lib.so-2.params
add_openfhe_fhe_demo.runfiles_manifest
</pre></div>


<p>You can see the output <code>.h</code> and <code>.cc</code> files and their compiled <code>.so</code> files (the output build artifacts), but more importantly for us are the internal generated files. This is where we get to actually see the circuits generated.</p>



<p>The first one worth inspecting is <code>add_fhe_lib.opt.ir</code>, which is the output of the <code>xlscc</code> compiler plus an XLS-internal optimization step. This is the main part of how the compiler uses the XLS project: to convert an input program into a circuit. The file looks like:</p>


<div><pre title="">package my_package

file_number 1 &#34;./transpiler/codelab/add/add.cc&#34;

top fn add(x: bits[32], y: bits[32]) -&gt; bits[32] {
  ret add.3: bits[32] = add(x, y, id=3, pos=[(1,18,25)])
}
</pre></div>


<p>As you can see, it’s an XLS-defined internal representation (IR) of the main routine with some extra source code metadata. Because XLS-IR natively supports additions, the result is trivial. One interesting thing to note is that numbers are represented as bit arrays. In short, XLS-IR’s <a href="https://google.github.io/xls/ir_semantics/">value type system</a> supports only bits, arrays, and tuples, which tuples being the mechanism for supporting structures.</p>



<p>Next, the XLS-IR is converted to Verilog in <code>add_fhe_lib.v</code>, resulting in the (similarly trivial)</p>


<div><pre title="">module add(
  input wire [31:0] x,
  input wire [31:0] y,
  output wire [31:0] out
);
  wire [31:0] add_6;
  assign add_6 = x + y;
  assign out = add_6;
endmodule
</pre></div>


<p>The next step is to run this verilog through <a href="https://github.com/YosysHQ/yosys">Yosys</a>, which is a mature circuit synthesis suite, and for our purposes is encapsulates the two tasks:</p>



<ul>
<li>Convert higher-level operations to a specified set of boolean gates (that operate on individual bits)</li>



<li>Optimize the resulting circuit to be as small as possible</li>
</ul>



<p>XLS can also do this, and if you want to see that you can change the build rule <code>optimizer</code> attribute from <code>yosys</code> to <code>xls</code>. But we’ve found that Yosys routinely produces 2-3x smaller circuits. The script that we give to yosys can be found in <code>fhe_yosys.bzl</code>, which encapsulates the bazel macros and rules related to invoking Yosys. The output for our adder program is:</p>


<div><pre title="">module add(x, y, out);
  wire _000_;
  wire _001_;
  wire _002_;
  [...]
  wire _131_;
  wire _132_;
  output [31:0] out;
  wire [31:0] out;
  input [31:0] x;
  wire [31:0] x;
  input [31:0] y;
  wire [31:0] y;
  nand2 _133_ (.A(x[12]), .B(y[12]), .Y(_130_));
  xor2 _134_ ( .A(x[12]), .B(y[12]), .Y(_131_));
  nand2 _135_ ( .A(x[11]), .B(y[11]), .Y(_132_));
  or2 _136_ ( .A(x[11]), .B(y[11]), .Y(_000_));
  nand2 _137_ ( .A(x[10]), .B(y[10]), .Y(_001_));
  xor2 _138_ ( .A(x[10]), .B(y[10]), .Y(_002_));
  nand2 _139_ ( .A(x[9]), .B(y[9]), .Y(_003_));
  or2 _140_ ( .A(x[9]), .B(y[9]), .Y(_004_));
  nand2 _141_ ( .A(x[8]), .B(y[8]), .Y(_005_));
  xor2 _142_ ( .A(x[8]), .B(y[8]), .Y(_006_));
  nand2 _143_ ( .A(x[7]), .B(y[7]), .Y(_007_));
  or2 _144_ ( .A(x[7]), .B(y[7]), .Y(_008_));
  [...]
  xor2 _291_ ( .A(_006_), .B(_035_), .Y(out[8]));
  xnor2 _292_ ( .A(x[9]), .B(y[9]), .Y(_128_));
  xnor2 _293_ ( .A(_037_), .B(_128_), .Y(out[9]));
  xor2 _294_ ( .A(_002_), .B(_039_), .Y(out[10]));
  xnor2 _295_ ( .A(x[11]), .B(y[11]), .Y(_129_));
  xnor2 _296_ ( .A(_041_), .B(_129_), .Y(out[11]));
  xor2 _297_ ( .A(_131_), .B(_043_), .Y(out[12]));
endmodule
</pre></div>


<p>This produces a circuit with a total of 165 gates.</p>



<p>The codegen step then produces a <code>add_fhe_lib.cc</code> file which loads this circuit into an interpreter which knows to map the operation <code>and2</code> to the chosen backend cryptosystem library call (see the <a href="https://github.com/google/fully-homomorphic-encryption/blob/main/transpiler/yosys_openfhe_runner.cc">source for the OpenFHE backend</a>), and uses thread-pool scheduling on CPU to speed up the evaluation of the circuit.</p>



<p>For the string_cap circuit, the <code><a href="https://pastebin.com/raw/1friPEPh">opt.ir</a></code> shows off a bit more of XLS’s IR, including operations for sign extension, array indexing &amp; slicing, and multiplexing (<code>sel</code>) branches. The resulting netlist after optimization is a <a href="https://pastebin.com/raw/DMhP941T">684-gate circuit</a> (though many of those are “inverter” or “buffer” gates, which are effectively free for FHE).</p>



<p>The compiler also outputs a <code>.dot</code> file which can be rendered <a href="https://github.com/j2kun/j2kun.github.io/blob/main/svg/string_cap_openfhe_yosys_interpreted.netlist.v.dot.svg">to an SVG</a> (warning, the SVG is ~2.3 MiB). If you browse this circuit, you’ll see it is rather shallow and wide, and this allows the thread-pool scheduler to take advantage of the parallelism in the circuit to make it run fast. Meanwhile, the 32-bit adder, though it has roughly 25% the total number of gates, is a much deeper circuit and hence has less parallelism.</p>



<h2>Supported C++ input programs and encryption overhead</h2>



<p>This has so far been a tour of the compiler, but if you want to get started using the compiler to write programs, you’ll need to keep a few things in mind.</p>



<p>First, the subset of C++ supported by the compiler is rather small. As mentioned earlier, all data needs to have static sizes. This means, e.g., you can’t write a program that processes arbitrary images. Instead, you have to pick an upper bound on the image size, zero-pad the image appropriately before encrypting it, and then write the program to operate on that image size. In the same vein, the integer types you choose have nontrivial implications on performance. To see this, replace the <code>int</code> type in the 32-bit adder with a <code>char</code> and inspect the resulting circuit.</p>



<p>Similarly, loops need static bounds on their iteration count. Or, more precisely, <code>xlscc</code> needs to be able to fully unwrap every loop—which permits some forms of while loops and recursion that provably terminate. This can cause some problem if the input code has loops with complex exit criteria (i.e., <code>break</code>‘s guarded by if/else). It also requires you to think hard about how you write your loops, though future work will hopefully let the compiler do that thinking for you.</p>



<p>Finally, encrypting each bit of a plaintext message comes with major tax on space usage. Each encryption of a single bit corresponds to a list of roughly 700 32-bit integers. If you want to encrypt a 100×100 pixel greyscale image, each pixel of which is an 8-bit integer (0-255), it will cost you <strong>218 MiB</strong> to store all the pixels in memory. It’s roughly a 20,000x overhead. For comparison, the music video for Rick Astley’s “Never Gonna Give You Up” at 360p is about 9 MiB (pretty small for a 3 minute video!), but encrypted in FHE would be <strong>188 GiB</strong>, which (generously) corresponds to 20 feature-length films at 1080p. Some other FHE schemes have smaller ciphertext sizes, but at the cost of even larger in-memory requirements to run the computations. So if you want to run programs to operate on video—you can do it, but you will need to distribute the work appropriately, and find useful ways to reduce the data size as much as possible before encrypting it (such as working in lower resolution, greyscale, and a lower frame rate), which will also result in overall faster programs.</p>



<p>Until next time!</p>



<p>[Personal note]: Now that I’m more or less ramped up on the FHE domain, I’m curious to know what aspects of FHE my readers are interested in. Mathematical foundations? More practical demonstrations? Library tutorials? Circuit optimization? Please comment and tell me about what you’re interested in.</p>

			</div></div>
  </body>
</html>
