<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://huggingface.co/nanonets/Nanonets-OCR-s">Original</a>
    <h1>Nanonets-OCR-s ‚Äì OCR model that transforms documents into structured markdown</h1>
    
    <div id="readability-page-1" class="page"><div>
	<!-- HTML_TAG_START --><p>Nanonets-OCR-s is a powerful, state-of-the-art image-to-markdown OCR model that goes far beyond traditional text extraction. It transforms documents into structured markdown with intelligent content recognition and semantic tagging, making it ideal for downstream processing by Large Language Models (LLMs).</p>
<p>Nanonets-OCR-s is packed with features designed to handle complex documents with ease:</p>
<ul>
<li><strong>LaTeX Equation Recognition:</strong> Automatically converts mathematical equations and formulas into properly formatted LaTeX syntax. It distinguishes between inline (<code>$...$</code>) and display (<code>$$...$$</code>) equations.</li>
<li><strong>Intelligent Image Description:</strong> Describes images within documents using structured <code>&lt;img&gt;</code> tags, making them digestible for LLM processing. It can describe various image types, including logos, charts, graphs and so on, detailing their content, style, and context.</li>
<li><strong>Signature Detection &amp; Isolation:</strong> Identifies and isolates signatures from other text, outputting them within a <code>&lt;signature&gt;</code> tag. This is crucial for processing legal and business documents.</li>
<li><strong>Watermark Extraction:</strong> Detects and extracts watermark text from documents, placing it within a <code>&lt;watermark&gt;</code> tag.</li>
<li><strong>Smart Checkbox Handling:</strong> Converts form checkboxes and radio buttons into standardized Unicode symbols (<code>‚òê</code>, <code>‚òë</code>, <code>‚òí</code>) for consistent and reliable processing.</li>
<li><strong>Complex Table Extraction:</strong> Accurately extracts complex tables from documents and converts them into both markdown and HTML table formats.</li>
</ul>
<p>üì¢ <a rel="nofollow" href="https://nanonets.com/research/nanonets-ocr-s">Read the full announcement</a> | ü§ó <a rel="nofollow" href="https://huggingface.co/spaces/Souvik3333/Nanonets-ocr-s">Hugging Face Space Demo</a></p>
<h2>
	<a rel="nofollow" href="#usage" id="usage">
		
	</a>
	<span>
		Usage
	</span>
</h2>
<h3>
	<a rel="nofollow" href="#using-transformers" id="using-transformers">
		
	</a>
	<span>
		Using transformers
	</span>
</h3>
<pre><code><span>from</span> PIL <span>import</span> Image
<span>from</span> transformers <span>import</span> AutoTokenizer, AutoProcessor, AutoModelForImageTextToText

model_path = <span>&#34;nanonets/Nanonets-OCR-s&#34;</span>

model = AutoModelForImageTextToText.from_pretrained(
    model_path, 
    torch_dtype=<span>&#34;auto&#34;</span>, 
    device_map=<span>&#34;auto&#34;</span>, 
    attn_implementation=<span>&#34;flash_attention_2&#34;</span>
)
model.<span>eval</span>()

tokenizer = AutoTokenizer.from_pretrained(model_path)
processor = AutoProcessor.from_pretrained(model_path)


<span>def</span> <span>ocr_page_with_nanonets_s</span>(<span>image_path, model, processor, max_new_tokens=<span>4096</span></span>):
    prompt = <span>&#34;&#34;&#34;Extract the text from the above document as if you were reading it naturally. Return the tables in html format. Return the equations in LaTeX representation. If there is an image in the document and image caption is not present, add a small description of the image inside the &lt;img&gt;&lt;/img&gt; tag; otherwise, add the image caption inside &lt;img&gt;&lt;/img&gt;. Watermarks should be wrapped in brackets. Ex: &lt;watermark&gt;OFFICIAL COPY&lt;/watermark&gt;. Page numbers should be wrapped in brackets. Ex: &lt;page_number&gt;14&lt;/page_number&gt; or &lt;page_number&gt;9/22&lt;/page_number&gt;. Prefer using ‚òê and ‚òë for check boxes.&#34;&#34;&#34;</span>
    image = Image.<span>open</span>(image_path)
    messages = [
        {<span>&#34;role&#34;</span>: <span>&#34;system&#34;</span>, <span>&#34;content&#34;</span>: <span>&#34;You are a helpful assistant.&#34;</span>},
        {<span>&#34;role&#34;</span>: <span>&#34;user&#34;</span>, <span>&#34;content&#34;</span>: [
            {<span>&#34;type&#34;</span>: <span>&#34;image&#34;</span>, <span>&#34;image&#34;</span>: <span>f&#34;file://<span>{image_path}</span>&#34;</span>},
            {<span>&#34;type&#34;</span>: <span>&#34;text&#34;</span>, <span>&#34;text&#34;</span>: prompt},
        ]},
    ]
    text = processor.apply_chat_template(messages, tokenize=<span>False</span>, add_generation_prompt=<span>True</span>)
    inputs = processor(text=[text], images=[image], padding=<span>True</span>, return_tensors=<span>&#34;pt&#34;</span>)
    inputs = inputs.to(model.device)
    
    output_ids = model.generate(**inputs, max_new_tokens=max_new_tokens, do_sample=<span>False</span>)
    generated_ids = [output_ids[<span>len</span>(input_ids):] <span>for</span> input_ids, output_ids <span>in</span> <span>zip</span>(inputs.input_ids, output_ids)]
    
    output_text = processor.batch_decode(generated_ids, skip_special_tokens=<span>True</span>, clean_up_tokenization_spaces=<span>True</span>)
    <span>return</span> output_text[<span>0</span>]

image_path = <span>&#34;/path/to/your/document.jpg&#34;</span>
result = ocr_page_with_nanonets_s(image_path, model, processor, max_new_tokens=<span>15000</span>)
<span>print</span>(result)
</code></pre>
<h3>
	<a rel="nofollow" href="#using-vllm" id="using-vllm">
		
	</a>
	<span>
		Using vLLM
	</span>
</h3>
<ol>
<li>Start the vLLM server.</li>
</ol>
<pre><code>vllm serve nanonets/Nanonets-OCR-s
</code></pre>
<ol start="2">
<li>Predict with the model</li>
</ol>
<pre><code><span>from</span> openai <span>import</span> OpenAI
<span>import</span> base64

client = OpenAI(api_key=<span>&#34;123&#34;</span>, base_url=<span>&#34;http://localhost:8000/v1&#34;</span>)

model = <span>&#34;nanonets/Nanonets-OCR-s&#34;</span>

<span>def</span> <span>encode_image</span>(<span>image_path</span>):
    <span>with</span> <span>open</span>(image_path, <span>&#34;rb&#34;</span>) <span>as</span> image_file:
        <span>return</span> base64.b64encode(image_file.read()).decode(<span>&#34;utf-8&#34;</span>)

<span>def</span> <span>ocr_page_with_nanonets_s</span>(<span>img_base64</span>):
    response = client.chat.completions.create(
        model=model,
        messages=[
            {
                <span>&#34;role&#34;</span>: <span>&#34;user&#34;</span>,
                <span>&#34;content&#34;</span>: [
                    {
                        <span>&#34;type&#34;</span>: <span>&#34;image_url&#34;</span>,
                        <span>&#34;image_url&#34;</span>: {<span>&#34;url&#34;</span>: <span>f&#34;data:image/png;base64,<span>{img_base64}</span>&#34;</span>},
                    },
                    {
                        <span>&#34;type&#34;</span>: <span>&#34;text&#34;</span>,
                        <span>&#34;text&#34;</span>: <span>&#34;Extract the text from the above document as if you were reading it naturally. Return the tables in html format. Return the equations in LaTeX representation. If there is an image in the document and image caption is not present, add a small description of the image inside the &lt;img&gt;&lt;/img&gt; tag; otherwise, add the image caption inside &lt;img&gt;&lt;/img&gt;. Watermarks should be wrapped in brackets. Ex: &lt;watermark&gt;OFFICIAL COPY&lt;/watermark&gt;. Page numbers should be wrapped in brackets. Ex: &lt;page_number&gt;14&lt;/page_number&gt; or &lt;page_number&gt;9/22&lt;/page_number&gt;. Prefer using ‚òê and ‚òë for check boxes.&#34;</span>,
                    },
                ],
            }
        ],
        temperature=<span>0.0</span>,
        max_tokens=<span>15000</span>
    )
    <span>return</span> response.choices[<span>0</span>].message.content

test_img_path = <span>&#34;/path/to/your/document.jpg&#34;</span>
img_base64 = encode_image(test_img_path)
<span>print</span>(ocr_page_with_nanonets_s(img_base64))
</code></pre>
<h3>
	<a rel="nofollow" href="#using-docext" id="using-docext">
		
	</a>
	<span>
		Using docext
	</span>
</h3>
<pre><code>pip install docext
python -m docext.app.app --model_name hosted_vllm/nanonets/Nanonets-OCR-s
</code></pre>
<p>Checkout <a rel="nofollow" href="https://github.com/NanoNets/docext/tree/dev/markdown">GitHub</a> for more details.</p>
<h2>
	<a rel="nofollow" href="#bibtex" id="bibtex">
		
	</a>
	<span>
		BibTex
	</span>
</h2>
<pre><code>@misc{Nanonets-OCR-S,
  title={Nanonets-OCR-S: A model for transforming documents into structured markdown with intelligent content recognition and semantic tagging},
  author={Souvik Mandal and Ashish Talewar and Paras Ahuja and Prathamesh Juvatkar},
  year={2025},
}
</code></pre>
<!-- HTML_TAG_END --></div></div>
  </body>
</html>
