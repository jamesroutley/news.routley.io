<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://fathy.fr/carbonyl">Original</a>
    <h1>Forking Chrome to render in a terminal</h1>
    
    <div id="readability-page-1" class="page"><div>
            <p>Alright, day 2.</p>
<h2 id="problem-statement">Problem statement</h2>
<p>Rock Paper Scissors!</p>
<p>We are given a &#34;strategy guide&#34; that looks like:</p>
<pre><code><span>A Y
</span><span>B X
</span><span>C Z
</span></code></pre>
<p>and we need to follow the provided scheme.</p>
<p>We save the example as <code>input/02/example.txt</code> and our input as <code>input/02/input.txt</code>.</p>
<h2 id="python-time">Python time!</h2>
<p>We create our solution in <code>2022/py/day02/sol.py</code> and add a blank <code>2022/py/day02/__init__.py</code>.</p>
<p>Software engineering best practices be damned, let&#39;s hard code everything!
Since we know the score associated with each combination of moves, we can
create a dictionary that maps each combination to the final score:</p>
<pre data-lang="python"><code data-lang="python"><span># 2022/py/day02/sol.py
</span><span>
</span><span>from </span><span>py.read_input </span><span>import </span><span>read_input
</span><span>
</span><span>
</span><span>def </span><span>main</span><span>() -&gt; int:
</span><span>    </span><span>input </span><span>= </span><span>read_input</span><span>(</span><span>2</span><span>)
</span><span>    scores = {
</span><span>        &#34;</span><span>A X</span><span>&#34;: </span><span>4</span><span>,  </span><span># 3 + 1
</span><span>        &#34;</span><span>A Y</span><span>&#34;: </span><span>8</span><span>,  </span><span># 6 + 2
</span><span>        &#34;</span><span>A Z</span><span>&#34;: </span><span>3</span><span>,  </span><span># 0 + 3
</span><span>        &#34;</span><span>B X</span><span>&#34;: </span><span>1</span><span>,  </span><span># 0 + 1
</span><span>        &#34;</span><span>B Y</span><span>&#34;: </span><span>5</span><span>,  </span><span># 3 + 2
</span><span>        &#34;</span><span>B Z</span><span>&#34;: </span><span>9</span><span>,  </span><span># 6 + 3
</span><span>        &#34;</span><span>C X</span><span>&#34;: </span><span>7</span><span>,  </span><span># 6 + 1
</span><span>        &#34;</span><span>C Y</span><span>&#34;: </span><span>2</span><span>,  </span><span># 0 + 2
</span><span>        &#34;</span><span>C Z</span><span>&#34;: </span><span>6</span><span>,  </span><span># 3 + 3
</span><span>    }
</span><span>    result = </span><span>sum</span><span>(scores[line.</span><span>strip</span><span>()] </span><span>for </span><span>line </span><span>in </span><span>input</span><span>.</span><span>splitlines</span><span>())
</span><span>    </span><span>print</span><span>(</span><span>f</span><span>&#34;</span><span>Part one: </span><span>{result}&#34;)
</span><span>    </span><span>return </span><span>0
</span><span>
</span><span>
</span><span>if </span><span>__name__ == &#34;</span><span>__main__</span><span>&#34;:
</span><span>    </span><span>raise </span><span>SystemExit</span><span>(</span><span>main</span><span>())
</span></code></pre>
<p>Part two involves a different scoring scheme, so we can take the same approach
but with a different <code>scores</code> table:</p>
<pre data-lang="python"><code data-lang="python"><span># 2022/py/day02/sol.py
</span><span>
</span><span>from </span><span>typing </span><span>import </span><span>Final, Iterable, Mapping
</span><span>
</span><span>from </span><span>py.read_input </span><span>import </span><span>read_input
</span><span>
</span><span>
</span><span>P1_SCORES</span><span>: Final[dict[str, int]] = {
</span><span>    &#34;</span><span>A X</span><span>&#34;: </span><span>4</span><span>,  </span><span># 3 + 1
</span><span>    &#34;</span><span>A Y</span><span>&#34;: </span><span>8</span><span>,  </span><span># 6 + 2
</span><span>    &#34;</span><span>A Z</span><span>&#34;: </span><span>3</span><span>,  </span><span># 0 + 3
</span><span>    &#34;</span><span>B X</span><span>&#34;: </span><span>1</span><span>,  </span><span># 0 + 1
</span><span>    &#34;</span><span>B Y</span><span>&#34;: </span><span>5</span><span>,  </span><span># 3 + 2
</span><span>    &#34;</span><span>B Z</span><span>&#34;: </span><span>9</span><span>,  </span><span># 6 + 3
</span><span>    &#34;</span><span>C X</span><span>&#34;: </span><span>7</span><span>,  </span><span># 6 + 1
</span><span>    &#34;</span><span>C Y</span><span>&#34;: </span><span>2</span><span>,  </span><span># 0 + 2
</span><span>    &#34;</span><span>C Z</span><span>&#34;: </span><span>6</span><span>,  </span><span># 3 + 3
</span><span>}
</span><span>
</span><span>P2_SCORES</span><span>: Final[dict[str, int]] = {
</span><span>    &#34;</span><span>A X</span><span>&#34;: </span><span>3</span><span>,  </span><span># 3 + 0
</span><span>    &#34;</span><span>A Y</span><span>&#34;: </span><span>4</span><span>,  </span><span># 1 + 3
</span><span>    &#34;</span><span>A Z</span><span>&#34;: </span><span>8</span><span>,  </span><span># 2 + 6
</span><span>    &#34;</span><span>B X</span><span>&#34;: </span><span>1</span><span>,  </span><span># 1 + 0
</span><span>    &#34;</span><span>B Y</span><span>&#34;: </span><span>5</span><span>,  </span><span># 2 + 3
</span><span>    &#34;</span><span>B Z</span><span>&#34;: </span><span>9</span><span>,  </span><span># 3 + 6
</span><span>    &#34;</span><span>C X</span><span>&#34;: </span><span>2</span><span>,  </span><span># 2 + 0
</span><span>    &#34;</span><span>C Y</span><span>&#34;: </span><span>6</span><span>,  </span><span># 3 + 3
</span><span>    &#34;</span><span>C Z</span><span>&#34;: </span><span>7</span><span>,  </span><span># 1 + 6
</span><span>}
</span><span>
</span><span>
</span><span>def </span><span>score</span><span>(</span><span>games</span><span>: Iterable[str], </span><span>table</span><span>: Mapping[str, int]) -&gt; int:
</span><span>    </span><span>return </span><span>sum</span><span>(table[game] </span><span>for </span><span>game </span><span>in </span><span>games)
</span><span>
</span><span>
</span><span>def </span><span>main</span><span>() -&gt; int:
</span><span>    </span><span>input </span><span>= </span><span>read_input</span><span>(</span><span>2</span><span>)
</span><span>    games = [line.</span><span>strip</span><span>() </span><span>for </span><span>line </span><span>in </span><span>input</span><span>.</span><span>splitlines</span><span>()]
</span><span>    </span><span>print</span><span>(</span><span>f</span><span>&#34;</span><span>Part one: </span><span>{</span><span>score</span><span>(games, </span><span>P1_SCORES</span><span>)}&#34;)
</span><span>    </span><span>print</span><span>(</span><span>f</span><span>&#34;</span><span>Part two: </span><span>{</span><span>score</span><span>(games, </span><span>P2_SCORES</span><span>)}&#34;)
</span><span>    </span><span>return </span><span>0
</span><span>
</span><span>
</span><span>if </span><span>__name__ == &#34;</span><span>__main__</span><span>&#34;:
</span><span>    </span><span>raise </span><span>SystemExit</span><span>(</span><span>main</span><span>())
</span></code></pre>
<p>I guess one interesting note is the use of the <code>Iterable</code> type instead of
<code>list[str]</code> for the <code>games</code> argument and the <code>Mapping</code> type instead of
<code>dict[str, int]</code> for the <code>table</code> argument. In general when using type
hints, it can be nice to get in the habit of accepting more general abstract types.
It&#39;s not likely for this program, but you could imagine that someone might
swap to using a <code>set</code> or <code>frozenset</code> to represent some collection. By using
argument types like <code>Iterable</code>, you can enable users of functions to pass in a
larger variety of inputs without additional copies or allocations. Additionally,
immutable container types are covariant on their value types. Using immutable
container argument types often makes your interfaces much more flexible.</p>
<h3 id="efficiency">Efficiency</h3>
<p>This solution is optimal in terms of asymptotic complexity (it runs in linear time
over the length of the input). But one idea we could try would be to use a
<code>match</code> statement instead of a lookup table. It&#39;s unlikely that this will yield
performance benefits since dictionary lookups are well optimized in Python. I&#39;m
more curious to see how these approaches fare in Rust, but let&#39;s try it in Python,
just to see!</p>
<pre data-lang="python"><code data-lang="python"><span># 2022/py/day02/sol.py
</span><span>
</span><span>from </span><span>time </span><span>import </span><span>perf_counter
</span><span>from </span><span>typing </span><span>import </span><span>Callable, Final, Iterable, Mapping, Sequence
</span><span>
</span><span>from </span><span>py.read_input </span><span>import </span><span>read_input
</span><span>
</span><span>
</span><span>P1_SCORES</span><span>: Final[dict[str, int]] = {
</span><span>    &#34;</span><span>A X</span><span>&#34;: </span><span>4</span><span>,  </span><span># 3 + 1
</span><span>    &#34;</span><span>A Y</span><span>&#34;: </span><span>8</span><span>,  </span><span># 6 + 2
</span><span>    &#34;</span><span>A Z</span><span>&#34;: </span><span>3</span><span>,  </span><span># 0 + 3
</span><span>    &#34;</span><span>B X</span><span>&#34;: </span><span>1</span><span>,  </span><span># 0 + 1
</span><span>    &#34;</span><span>B Y</span><span>&#34;: </span><span>5</span><span>,  </span><span># 3 + 2
</span><span>    &#34;</span><span>B Z</span><span>&#34;: </span><span>9</span><span>,  </span><span># 6 + 3
</span><span>    &#34;</span><span>C X</span><span>&#34;: </span><span>7</span><span>,  </span><span># 6 + 1
</span><span>    &#34;</span><span>C Y</span><span>&#34;: </span><span>2</span><span>,  </span><span># 0 + 2
</span><span>    &#34;</span><span>C Z</span><span>&#34;: </span><span>6</span><span>,  </span><span># 3 + 3
</span><span>}
</span><span>
</span><span>P2_SCORES</span><span>: Final[dict[str, int]] = {
</span><span>    &#34;</span><span>A X</span><span>&#34;: </span><span>3</span><span>,  </span><span># 3 + 0
</span><span>    &#34;</span><span>A Y</span><span>&#34;: </span><span>4</span><span>,  </span><span># 1 + 3
</span><span>    &#34;</span><span>A Z</span><span>&#34;: </span><span>8</span><span>,  </span><span># 2 + 6
</span><span>    &#34;</span><span>B X</span><span>&#34;: </span><span>1</span><span>,  </span><span># 1 + 0
</span><span>    &#34;</span><span>B Y</span><span>&#34;: </span><span>5</span><span>,  </span><span># 2 + 3
</span><span>    &#34;</span><span>B Z</span><span>&#34;: </span><span>9</span><span>,  </span><span># 3 + 6
</span><span>    &#34;</span><span>C X</span><span>&#34;: </span><span>2</span><span>,  </span><span># 2 + 0
</span><span>    &#34;</span><span>C Y</span><span>&#34;: </span><span>6</span><span>,  </span><span># 3 + 3
</span><span>    &#34;</span><span>C Z</span><span>&#34;: </span><span>7</span><span>,  </span><span># 1 + 6
</span><span>}
</span><span>
</span><span>
</span><span>def </span><span>table_score</span><span>(</span><span>games</span><span>: Iterable[str], </span><span>table</span><span>: Mapping[str, int]) -&gt; int:
</span><span>    </span><span>return </span><span>sum</span><span>(table[game] </span><span>for </span><span>game </span><span>in </span><span>games)
</span><span>
</span><span>
</span><span>def </span><span>table_sol</span><span>(</span><span>games</span><span>: Sequence[str]) -&gt; tuple[int, int]:
</span><span>    </span><span>return </span><span>table_score</span><span>(games, </span><span>P1_SCORES</span><span>), </span><span>table_score</span><span>(games, </span><span>P2_SCORES</span><span>)
</span><span>
</span><span>
</span><span>def </span><span>score_fn_p1</span><span>(</span><span>game</span><span>: str) -&gt; int:
</span><span>    match game:
</span><span>        case &#34;</span><span>A X</span><span>&#34;:
</span><span>            </span><span>return </span><span>4
</span><span>        case &#34;</span><span>A Y</span><span>&#34;:
</span><span>            </span><span>return </span><span>8
</span><span>        case &#34;</span><span>A Z</span><span>&#34;:
</span><span>            </span><span>return </span><span>3
</span><span>        case &#34;</span><span>B X</span><span>&#34;:
</span><span>            </span><span>return </span><span>1
</span><span>        case &#34;</span><span>B Y</span><span>&#34;:
</span><span>            </span><span>return </span><span>5
</span><span>        case &#34;</span><span>B Z</span><span>&#34;:
</span><span>            </span><span>return </span><span>9
</span><span>        case &#34;</span><span>C X</span><span>&#34;:
</span><span>            </span><span>return </span><span>7
</span><span>        case &#34;</span><span>C Y</span><span>&#34;:
</span><span>            </span><span>return </span><span>2
</span><span>        case &#34;</span><span>C Z</span><span>&#34;:
</span><span>            </span><span>return </span><span>6
</span><span>        case </span><span>_</span><span>:
</span><span>            </span><span>raise </span><span>ValueError</span><span>(</span><span>f</span><span>&#34;</span><span>Invalid game: </span><span>{game}&#34;)
</span><span>
</span><span>
</span><span>def </span><span>score_fn_p2</span><span>(</span><span>game</span><span>: str) -&gt; int:
</span><span>    match game:
</span><span>        case &#34;</span><span>A X</span><span>&#34;:
</span><span>            </span><span>return </span><span>3
</span><span>        case &#34;</span><span>A Y</span><span>&#34;:
</span><span>            </span><span>return </span><span>4
</span><span>        case &#34;</span><span>A Z</span><span>&#34;:
</span><span>            </span><span>return </span><span>8
</span><span>        case &#34;</span><span>B X</span><span>&#34;:
</span><span>            </span><span>return </span><span>1
</span><span>        case &#34;</span><span>B Y</span><span>&#34;:
</span><span>            </span><span>return </span><span>5
</span><span>        case &#34;</span><span>B Z</span><span>&#34;:
</span><span>            </span><span>return </span><span>9
</span><span>        case &#34;</span><span>C X</span><span>&#34;:
</span><span>            </span><span>return </span><span>2
</span><span>        case &#34;</span><span>C Y</span><span>&#34;:
</span><span>            </span><span>return </span><span>6
</span><span>        case &#34;</span><span>C Z</span><span>&#34;:
</span><span>            </span><span>return </span><span>7
</span><span>        case </span><span>_</span><span>:
</span><span>            </span><span>raise </span><span>ValueError</span><span>(</span><span>f</span><span>&#34;</span><span>Invalid game: </span><span>{game}&#34;)
</span><span>
</span><span>
</span><span>def </span><span>match_score</span><span>(</span><span>games</span><span>: Iterable[str], </span><span>score_fn</span><span>: Callable[[str], int]) -&gt; int:
</span><span>    </span><span>return </span><span>sum</span><span>(</span><span>score_fn</span><span>(game) </span><span>for </span><span>game </span><span>in </span><span>games)
</span><span>
</span><span>
</span><span>def </span><span>match_sol</span><span>(</span><span>games</span><span>: Sequence[str]) -&gt; tuple[int, int]:
</span><span>    </span><span>return </span><span>match_score</span><span>(games, score_fn_p1), </span><span>match_score</span><span>(games, score_fn_p2)
</span><span>
</span><span>
</span><span>def </span><span>main</span><span>() -&gt; int:
</span><span>    </span><span>input </span><span>= </span><span>read_input</span><span>(</span><span>2</span><span>)
</span><span>    games = [line.</span><span>strip</span><span>() </span><span>for </span><span>line </span><span>in </span><span>input</span><span>.</span><span>splitlines</span><span>()]
</span><span>    expected_output = </span><span>table_sol</span><span>(games)
</span><span>    </span><span>print</span><span>(</span><span>f</span><span>&#34;</span><span>Part one: </span><span>{expected_output[</span><span>0</span><span>]}&#34;)
</span><span>    </span><span>print</span><span>(</span><span>f</span><span>&#34;</span><span>Part two: </span><span>{expected_output[</span><span>1</span><span>]}&#34;)
</span><span>
</span><span>    </span><span>def </span><span>benchmark</span><span>(</span><span>solution</span><span>: Callable[[Sequence[str]], tuple[int, int]]) -&gt; float:
</span><span>        start = </span><span>perf_counter</span><span>()
</span><span>        </span><span>for </span><span>_ </span><span>in </span><span>range</span><span>(</span><span>1000</span><span>):
</span><span>            </span><span>assert </span><span>solution</span><span>(games) == expected_output
</span><span>        end = </span><span>perf_counter</span><span>()
</span><span>        </span><span>return </span><span>end - start
</span><span>
</span><span>    </span><span>print</span><span>(</span><span>f</span><span>&#34;</span><span>Table solution takes </span><span>{</span><span>benchmark</span><span>(table_sol)}</span><span>s</span><span>&#34;)
</span><span>    </span><span>print</span><span>(</span><span>f</span><span>&#34;</span><span>Match solution takes </span><span>{</span><span>benchmark</span><span>(match_sol)}</span><span>s</span><span>&#34;)
</span><span>
</span><span>    </span><span>return </span><span>0
</span><span>
</span><span>
</span><span>if </span><span>__name__ == &#34;</span><span>__main__</span><span>&#34;:
</span><span>    </span><span>raise </span><span>SystemExit</span><span>(</span><span>main</span><span>())
</span></code></pre>
<p>Running this on my machine yields this result:</p>
<pre><code><span>$ python -m py.day02.sol
</span><span>Part one: 11906
</span><span>Part two: 11186
</span><span>Table solution takes 0.1719587080006022s
</span><span>Match solution takes 0.38245958300103666s
</span></code></pre>
<p>So the <code>match</code>-based solution takes more than twice as long as the lookup table
approach. I&#39;m glad that Python now has some form of structural pattern matching, but
a little bit sad about the performance gap to lookup tables, especially when compared
with compiled languages like Rust or Standard ML.</p>
<p>So for Python, we&#39;ll stick with our original lookup table approach.</p>
<h2 id="rust">Rust!</h2>
<p>Let&#39;s try the same exercise in Rust.</p>
<p>You know most of the boilerplate from day 1, so I&#39;ll gloss over most of those details.</p>
<p>We&#39;ll use the <a href="https://crates.io/crates/phf"><code>phf</code></a> crate to build our lookup table.</p>
<pre><code><span>$ cargo add phf phf_macros
</span></code></pre>
<pre data-lang="rust"><code data-lang="rust"><span>use </span><span>phf_macros::phf_map;
</span><span>
</span><span>fn </span><span>parse_games</span><span>(</span><span>input</span><span>: &amp;</span><span>str</span><span>) -&gt; Vec&lt;&amp;</span><span>str</span><span>&gt; {
</span><span>    input.</span><span>lines</span><span>().</span><span>map</span><span>(</span><span>str</span><span>::trim).collect::&lt;Vec&lt;_&gt;&gt;()
</span><span>}
</span><span>
</span><span>static </span><span>P1_SCORES</span><span>: phf::Map&lt;&amp;</span><span>&#39;static str</span><span>, </span><span>i32</span><span>&gt; = phf_map! {
</span><span>    &#34;</span><span>A X</span><span>&#34; =&gt; </span><span>3 </span><span>+ </span><span>1</span><span>,
</span><span>    &#34;</span><span>A Y</span><span>&#34; =&gt; </span><span>6 </span><span>+ </span><span>2</span><span>,
</span><span>    &#34;</span><span>A Z</span><span>&#34; =&gt; </span><span>0 </span><span>+ </span><span>3</span><span>,
</span><span>    &#34;</span><span>B X</span><span>&#34; =&gt; </span><span>0 </span><span>+ </span><span>1</span><span>,
</span><span>    &#34;</span><span>B Y</span><span>&#34; =&gt; </span><span>3 </span><span>+ </span><span>2</span><span>,
</span><span>    &#34;</span><span>B Z</span><span>&#34; =&gt; </span><span>6 </span><span>+ </span><span>3</span><span>,
</span><span>    &#34;</span><span>C X</span><span>&#34; =&gt; </span><span>6 </span><span>+ </span><span>1</span><span>,
</span><span>    &#34;</span><span>C Y</span><span>&#34; =&gt; </span><span>0 </span><span>+ </span><span>2</span><span>,
</span><span>    &#34;</span><span>C Z</span><span>&#34; =&gt; </span><span>3 </span><span>+ </span><span>3</span><span>,
</span><span>};
</span><span>
</span><span>static </span><span>P2_SCORES</span><span>: phf::Map&lt;&amp;</span><span>&#39;static str</span><span>, </span><span>i32</span><span>&gt; = phf_map! {
</span><span>    &#34;</span><span>A X</span><span>&#34; =&gt; </span><span>3 </span><span>+ </span><span>0</span><span>,
</span><span>    &#34;</span><span>A Y</span><span>&#34; =&gt; </span><span>1 </span><span>+ </span><span>3</span><span>,
</span><span>    &#34;</span><span>A Z</span><span>&#34; =&gt; </span><span>2 </span><span>+ </span><span>6</span><span>,
</span><span>    &#34;</span><span>B X</span><span>&#34; =&gt; </span><span>1 </span><span>+ </span><span>0</span><span>,
</span><span>    &#34;</span><span>B Y</span><span>&#34; =&gt; </span><span>2 </span><span>+ </span><span>3</span><span>,
</span><span>    &#34;</span><span>B Z</span><span>&#34; =&gt; </span><span>3 </span><span>+ </span><span>6</span><span>,
</span><span>    &#34;</span><span>C X</span><span>&#34; =&gt; </span><span>2 </span><span>+ </span><span>0</span><span>,
</span><span>    &#34;</span><span>C Y</span><span>&#34; =&gt; </span><span>3 </span><span>+ </span><span>3</span><span>,
</span><span>    &#34;</span><span>C Z</span><span>&#34; =&gt; </span><span>1 </span><span>+ </span><span>6</span><span>,
</span><span>};
</span><span>
</span><span>fn </span><span>table_score</span><span>(</span><span>games</span><span>: &amp;[&amp;</span><span>str</span><span>], </span><span>table</span><span>: &amp;phf::Map&lt;&amp;</span><span>&#39;static str</span><span>, </span><span>i32</span><span>&gt;) -&gt; </span><span>i32 </span><span>{
</span><span>    games
</span><span>        .</span><span>iter</span><span>()
</span><span>        .</span><span>map</span><span>(|</span><span>game</span><span>| table.</span><span>get</span><span>(game).</span><span>expect</span><span>(&#34;</span><span>invalid game</span><span>&#34;))
</span><span>        .</span><span>sum</span><span>()
</span><span>}
</span><span>
</span><span>pub fn </span><span>table_sol</span><span>(</span><span>input</span><span>: &amp;</span><span>str</span><span>) -&gt; (</span><span>i32</span><span>, </span><span>i32</span><span>) {
</span><span>    </span><span>let</span><span> games = </span><span>parse_games</span><span>(input);
</span><span>    (
</span><span>        </span><span>table_score</span><span>(&amp;games, &amp;</span><span>P1_SCORES</span><span>),
</span><span>        </span><span>table_score</span><span>(&amp;games, &amp;</span><span>P2_SCORES</span><span>),
</span><span>    )
</span><span>}
</span><span>
</span><span>fn </span><span>score_fn_p1</span><span>(</span><span>game</span><span>: &amp;</span><span>str</span><span>) -&gt; </span><span>i32 </span><span>{
</span><span>    </span><span>match</span><span> game {
</span><span>        &#34;</span><span>A X</span><span>&#34; =&gt; </span><span>3 </span><span>+ </span><span>1</span><span>,
</span><span>        &#34;</span><span>A Y</span><span>&#34; =&gt; </span><span>6 </span><span>+ </span><span>2</span><span>,
</span><span>        &#34;</span><span>A Z</span><span>&#34; =&gt; </span><span>0 </span><span>+ </span><span>3</span><span>,
</span><span>        &#34;</span><span>B X</span><span>&#34; =&gt; </span><span>0 </span><span>+ </span><span>1</span><span>,
</span><span>        &#34;</span><span>B Y</span><span>&#34; =&gt; </span><span>3 </span><span>+ </span><span>2</span><span>,
</span><span>        &#34;</span><span>B Z</span><span>&#34; =&gt; </span><span>6 </span><span>+ </span><span>3</span><span>,
</span><span>        &#34;</span><span>C X</span><span>&#34; =&gt; </span><span>6 </span><span>+ </span><span>1</span><span>,
</span><span>        &#34;</span><span>C Y</span><span>&#34; =&gt; </span><span>0 </span><span>+ </span><span>2</span><span>,
</span><span>        &#34;</span><span>C Z</span><span>&#34; =&gt; </span><span>3 </span><span>+ </span><span>3</span><span>,
</span><span>        _ =&gt; panic!(&#34;</span><span>invalid game: {game}</span><span>&#34;),
</span><span>    }
</span><span>}
</span><span>
</span><span>fn </span><span>score_fn_p2</span><span>(</span><span>game</span><span>: &amp;</span><span>str</span><span>) -&gt; </span><span>i32 </span><span>{
</span><span>    </span><span>match</span><span> game {
</span><span>        &#34;</span><span>A X</span><span>&#34; =&gt; </span><span>3 </span><span>+ </span><span>0</span><span>,
</span><span>        &#34;</span><span>A Y</span><span>&#34; =&gt; </span><span>1 </span><span>+ </span><span>3</span><span>,
</span><span>        &#34;</span><span>A Z</span><span>&#34; =&gt; </span><span>2 </span><span>+ </span><span>6</span><span>,
</span><span>        &#34;</span><span>B X</span><span>&#34; =&gt; </span><span>1 </span><span>+ </span><span>0</span><span>,
</span><span>        &#34;</span><span>B Y</span><span>&#34; =&gt; </span><span>2 </span><span>+ </span><span>3</span><span>,
</span><span>        &#34;</span><span>B Z</span><span>&#34; =&gt; </span><span>3 </span><span>+ </span><span>6</span><span>,
</span><span>        &#34;</span><span>C X</span><span>&#34; =&gt; </span><span>2 </span><span>+ </span><span>0</span><span>,
</span><span>        &#34;</span><span>C Y</span><span>&#34; =&gt; </span><span>3 </span><span>+ </span><span>3</span><span>,
</span><span>        &#34;</span><span>C Z</span><span>&#34; =&gt; </span><span>1 </span><span>+ </span><span>6</span><span>,
</span><span>        _ =&gt; panic!(&#34;</span><span>invalid game: {game}</span><span>&#34;),
</span><span>    }
</span><span>}
</span><span>
</span><span>fn </span><span>match_score</span><span>(</span><span>games</span><span>: &amp;[&amp;</span><span>str</span><span>], </span><span>score_fn</span><span>: impl Fn(&amp;</span><span>str</span><span>) -&gt; </span><span>i32</span><span>) -&gt; </span><span>i32 </span><span>{
</span><span>    games.</span><span>iter</span><span>().</span><span>cloned</span><span>().</span><span>map</span><span>(score_fn).</span><span>sum</span><span>()
</span><span>}
</span><span>
</span><span>pub fn </span><span>match_sol</span><span>(</span><span>input</span><span>: &amp;</span><span>str</span><span>) -&gt; (</span><span>i32</span><span>, </span><span>i32</span><span>) {
</span><span>    </span><span>let</span><span> games = </span><span>parse_games</span><span>(input);
</span><span>    (
</span><span>        </span><span>match_score</span><span>(&amp;games, score_fn_p1),
</span><span>        </span><span>match_score</span><span>(&amp;games, score_fn_p2),
</span><span>    )
</span><span>}
</span><span>
</span><span>#[</span><span>cfg</span><span>(test)]
</span><span>mod </span><span>tests {
</span><span>    </span><span>use super</span><span>::*;
</span><span>
</span><span>    </span><span>const </span><span>EXAMPLE</span><span>: &amp;</span><span>str </span><span>= </span><span>r</span><span>#&#34;</span><span>A Y
</span><span>B X
</span><span>C Z</span><span>&#34;#;
</span><span>
</span><span>    #[</span><span>test</span><span>]
</span><span>    </span><span>fn </span><span>test_table_sol</span><span>() {
</span><span>        assert_eq!(</span><span>table_sol</span><span>(</span><span>EXAMPLE</span><span>), (</span><span>15</span><span>, </span><span>12</span><span>));
</span><span>    }
</span><span>
</span><span>    #[</span><span>test</span><span>]
</span><span>    </span><span>fn </span><span>test_match_sol</span><span>() {
</span><span>        assert_eq!(</span><span>match_sol</span><span>(</span><span>EXAMPLE</span><span>), (</span><span>15</span><span>, </span><span>12</span><span>));
</span><span>    }
</span><span>}
</span></code></pre>
<p>Let&#39;s hook it all up in our <code>main</code> function:</p>
<pre data-lang="rust"><code data-lang="rust"><span>use </span><span>std::error::Error;
</span><span>
</span><span>use </span><span>day02::{match_sol, table_sol};
</span><span>
</span><span>fn </span><span>main</span><span>() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span>    </span><span>let</span><span> input = include_str!(&#34;</span><span>../../../../input/02/input.txt</span><span>&#34;);
</span><span>    </span><span>let </span><span>(tp1, tp2) = </span><span>table_sol</span><span>(input);
</span><span>    println!(&#34;</span><span>Table sol p1: </span><span>{tp1}</span><span>, p2: </span><span>{tp2}</span><span>&#34;);
</span><span>    </span><span>let </span><span>(mp1, mp2) = </span><span>match_sol</span><span>(input);
</span><span>    println!(&#34;</span><span>Match sol p1: </span><span>{mp1}</span><span>, p2: </span><span>{mp2}</span><span>&#34;);
</span><span>    Ok(())
</span><span>}
</span></code></pre>
<p>We can run it and get our expected results:</p>
<pre><code><span>$ cargo run
</span><span>    Finished dev [unoptimized + debuginfo] target(s) in 0.02s
</span><span>     Running `/Users/sgeisenh/projects/aoc/2022/rust/day02/target/debug/main`
</span><span>Table sol p1: 11906, p2: 11186
</span><span>Match sol p1: 11906, p2: 11186
</span></code></pre>
<p>Similarly, we add a benchmark file for <code>criterion</code> to use:</p>
<pre data-lang="rust"><code data-lang="rust"><span>use </span><span>std::hint::black_box;
</span><span>
</span><span>use </span><span>criterion::{criterion_group, criterion_main, Criterion};
</span><span>
</span><span>static </span><span>INPUT</span><span>: &amp;</span><span>str </span><span>= include_str!(&#34;</span><span>../../../input/02/input.txt</span><span>&#34;);
</span><span>
</span><span>pub fn </span><span>criterion_benchmark</span><span>(</span><span>c</span><span>: &amp;</span><span>mut</span><span> Criterion) {
</span><span>    c.</span><span>bench_function</span><span>(&#34;</span><span>table_sol</span><span>&#34;, |</span><span>b</span><span>| {
</span><span>        b.</span><span>iter</span><span>(|| day02::table_sol(</span><span>black_box</span><span>(</span><span>INPUT</span><span>)))
</span><span>    });
</span><span>    c.</span><span>bench_function</span><span>(&#34;</span><span>match_sol</span><span>&#34;, |</span><span>b</span><span>| {
</span><span>        b.</span><span>iter</span><span>(|| day02::match_sol(</span><span>black_box</span><span>(</span><span>INPUT</span><span>)))
</span><span>    });
</span><span>}
</span><span>
</span><span>criterion_group!(benches, criterion_benchmark);
</span><span>criterion_main!(benches);
</span></code></pre>
<p>And finally, we run our benchmarks:</p>
<pre><code><span>$ cargo bench
</span><span>    Finished bench [optimized] target(s) in 0.03s
</span><span>     Running unittests src/lib.rs (/Users/sgeisenh/projects/aoc/2022/rust/day02/target/release/deps/day02-14b54ca39dda7916)
</span><span>
</span><span>running 2 tests
</span><span>test tests::test_match_sol ... ignored
</span><span>test tests::test_table_sol ... ignored
</span><span>
</span><span>test result: ok. 0 passed; 0 failed; 2 ignored; 0 measured; 0 filtered out; finished in 0.00s
</span><span>
</span><span>     Running unittests src/bin/main.rs (/Users/sgeisenh/projects/aoc/2022/rust/day02/target/release/deps/main-ea2d4c751f6a8144)
</span><span>
</span><span>running 0 tests
</span><span>
</span><span>test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</span><span>
</span><span>     Running benches/my_benchmark.rs (/Users/sgeisenh/projects/aoc/2022/rust/day02/target/release/deps/my_benchmark-24b0eacb110149e1)
</span><span>Gnuplot not found, using plotters backend
</span><span>table_sol               time:   [105.59 µs 105.63 µs 105.69 µs]
</span><span>                        change: [-0.1857% -0.0658% +0.0629%] (p = 0.31 &gt; 0.05)
</span><span>                        No change in performance detected.
</span><span>Found 4 outliers among 100 measurements (4.00%)
</span><span>  1 (1.00%) high mild
</span><span>  3 (3.00%) high severe
</span><span>
</span><span>match_sol               time:   [47.056 µs 47.131 µs 47.222 µs]
</span><span>                        change: [-6.3413% -5.8155% -5.1458%] (p = 0.00 &lt; 0.05)
</span><span>                        Performance has improved.
</span><span>Found 5 outliers among 100 measurements (5.00%)
</span><span>  1 (1.00%) high mild
</span><span>  4 (4.00%) high severe
</span></code></pre>
<p>As expected, the <code>match</code>-based solution is significantly faster than the table
lookup solution in Rust.</p>
<h2 id="that-s-it">That&#39;s it!</h2>
<p>I&#39;m a little bit sad that day 1 had some more interesting algorithmic ideas to
explore than day 2. Oh well. I&#39;ll probably jump to something like day 20 for my
next post so we can get into some juicy ideas.</p>

        </div></div>
  </body>
</html>
