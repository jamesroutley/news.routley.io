<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://elijer.github.io/garden/devnotes/LeetCode-Journal/11%29-Climbing-Stairs">Original</a>
    <h1>11) Climbing Stairs</h1>
    
    <div id="readability-page-1" class="page"><article><p>I paired with Russell again and A wild <a href="https://www.thecoder.cafe/devnotes/LeetCode-Journal/A)-Dynamically-Programming-Fibonnacci" data-slug="devnotes/LeetCode-Journal/A)-Dynamically-Programming-Fibonnacci">Fibonnacci sequence appeared!</a> The leetcode exercise we paired on was called <a href="https://leetcode.com/problems/climbing-stairs/">climbing stairs<svg aria-hidden="true" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a>, and it was one of the more unreasonably tricky (not specifically difficult; more like duplicitous) ones.</p>
<p>The idea is that you have a staircase with <code>n</code> stairs, and you can take them one or two at a time. I picked this exercise for the sole reason that Russell is a competitive stair climber. I’m serious. Before talking to him, I hadn’t known it was a sport.</p>
<p>The exercise wants us to return the number of valid, unique sequences of one or two step sequences that will get us exactly to the final stair.</p>
<p>Here is the pseudocode I worked through prior to coding:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="js" data-theme="github-light github-dark"><code data-language="js" data-theme="github-light github-dark"><span data-line=""><span>    // dynamically find what the output for n would be for every additional step in n, evaluate recursively some function</span></span>
<span data-line=""><span>    // climb stairs, continue until we reach</span></span>
<span data-line=""><span>    // assumption n=3</span></span>
<span data-line=""><span>    // 1, 1, 1</span></span>
<span data-line=""><span>    // 2, 1</span></span>
<span data-line=""><span>    // 1, 2</span></span>
<span data-line=""><span>    // n = 4</span></span>
<span data-line=""><span>    // 2, 2</span></span>
<span data-line=""><span>    // 1, 1, 1, 1</span></span>
<span data-line=""><span>    // 1, 1, 2</span></span>
<span data-line=""><span>    // 2, 1, 1</span></span>
<span data-line=""><span>    // 1, 2, 1</span></span>
<span data-line=""><span>    // should return 5</span></span>
<span data-line=""> </span>
<span data-line=""><span>    // n = 1</span></span>
<span data-line=""><span>    // 1</span></span>
<span data-line=""><span>    // return 1</span></span>
<span data-line=""> </span>
<span data-line=""><span>    // even odd</span></span>
<span data-line=""><span>    // % </span></span>
<span data-line=""> </span>
<span data-line=""><span>    // 1 -&gt; 1</span></span>
<span data-line=""><span>    // 2, 2</span></span>
<span data-line=""><span>    // 3 -&gt; 3</span></span>
<span data-line=""><span>    // 4 -&gt; 5</span></span>
<span data-line=""><span>    // 5 -&gt; 8</span></span>
<span data-line=""> </span>
<span data-line=""><span>    // n=5</span></span>
<span data-line=""><span>    // 1, 1, 1, 1, 1</span></span>
<span data-line=""><span>    // 1, 1, 1, 2</span></span>
<span data-line=""><span>    // 1, 1, 2, 1</span></span>
<span data-line=""><span>    // 1, 2, 1, 1</span></span>
<span data-line=""><span>    // 2, 1, 1, 1</span></span>
<span data-line=""><span>    // 1, 2, 2</span></span>
<span data-line=""><span>    // 2, 1, 2</span></span>
<span data-line=""><span>    // 2, 2, 1</span></span>
<span data-line=""> </span>
<span data-line=""><span>    // assumption the only way to get where you are is from an existing pathway that we&#39;ve added to our sum in one of the past 2n&#39;s</span></span>
<span data-line=""> </span>
<span data-line=""><span>    // If there are no previous values, create an object - &gt; {1: 1, 2: 2} default value</span></span>
<span data-line=""><span>    // if the current value has no previous value, I want to use the past 2 values to generate and save it to the object</span></span>
<span data-line=""><span>    // if there aren&#39;t 2 previous past values &lt;- this won&#39;t happen because of default value passed into extra argument</span></span>
<span data-line=""><span>    // if know what the original opassed in value is that&#39;s separate from this interative progress through all the values UP to that point,</span></span>
<span data-line=""><span>    // if the iterative value is the same as the passed in value, then I will return things the same way</span></span>
<span data-line=""><span>    // base case vs. enter another recursive case</span></span></code></pre></figure>
<p>I had a sort of horrifying (despite it being a mock interview) moment where my brain felt like a completely empty space. Russell suggested that I work through each possible input to see if I could find a pattern. This ended up being a big hint, as the outputs were the fibonacci sequence. I didn’t totally believe it, so I tried to reason as to why this might be. Maybe it’s intuitive to someone else, but to me this seemed strange.</p>
<p>The explanation is that for each <code>n</code> value, there are only two ways to get there with the current configuration of stair-movements - you can get there from <code>n-1</code> or from <code>n-2</code>.</p>
<blockquote data-callout="why" data-callout-fold="" data-callout-metadata="?">

</blockquote>
<p>…Okay actually, I’m really not sure why this is the case still. I had to figure it out here if you’re curious or confused </p>
<p>This is what I arrived at after 40 minutes with some major hints from Russell. I also had practiced <a href="https://www.thecoder.cafe/devnotes/LeetCode-Journal/A)-Dynamically-Programming-Fibonnacci" data-slug="devnotes/LeetCode-Journal/A)-Dynamically-Programming-Fibonnacci">A) Dynamically Programming Fibonnacci</a> before as an introduction to Dynamic programming. I hadn’t really gotten it down pat, but I think that not being completely fresh to the idea really helped.</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="javascript" data-theme="github-light github-dark"><code data-language="javascript" data-theme="github-light github-dark"><span data-line=""><span>var</span><span> climbStairs</span><span> =</span><span> function</span><span>(</span><span>n</span><span>) {</span></span>
<span data-line=""> </span>
<span data-line=""><span>    let</span><span> initial </span><span>=</span><span> new</span><span> Map</span><span>()</span></span>
<span data-line=""><span>    initial.</span><span>set</span><span>(</span><span>1</span><span>, </span><span>1</span><span>)</span></span>
<span data-line=""><span>    initial.</span><span>set</span><span>(</span><span>2</span><span>, </span><span>2</span><span>)</span></span>
<span data-line=""><span>    //</span></span>
<span data-line=""> </span>
<span data-line=""><span>    // recursive case</span></span>
<span data-line=""><span>    // setting new values</span></span>
<span data-line=""> </span>
<span data-line=""><span>    let</span><span> climbStairsRecursively</span><span> =</span><span> function</span><span>(</span><span>n</span><span>){</span></span>
<span data-line=""> </span>
<span data-line=""><span>        // I would start where n = 3</span></span>
<span data-line=""><span>        // what I&#39;m doing is starting with the final value</span></span>
<span data-line=""> </span>
<span data-line=""><span>        if</span><span> (initial.</span><span>has</span><span>(n)){</span></span>
<span data-line=""><span>            return</span><span> initial.</span><span>get</span><span>(n)</span></span>
<span data-line=""><span>        }</span></span>
<span data-line=""> </span>
<span data-line=""><span>        if</span><span> (initial.</span><span>has</span><span>(n</span><span>-</span><span>1</span><span>)){</span></span>
<span data-line=""><span>            return</span><span> initial.</span><span>get</span><span>(n</span><span>-</span><span>1</span><span>) </span><span>+</span><span> initial.</span><span>get</span><span>(n</span><span>-</span><span>2</span><span>)</span></span>
<span data-line=""><span>        } </span><span>else</span><span> {</span></span>
<span data-line=""><span>            initial.</span><span>set</span><span>(n</span><span>-</span><span>1</span><span>, </span><span>climbStairsRecursively</span><span>(n</span><span>-</span><span>1</span><span>))</span></span>
<span data-line=""><span>            return</span><span> initial.</span><span>get</span><span>(n</span><span>-</span><span>1</span><span>) </span><span>+</span><span> initial.</span><span>get</span><span>(n</span><span>-</span><span>2</span><span>)</span></span>
<span data-line=""><span>        }</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""> </span>
<span data-line=""><span>    return</span><span> climbStairsRecursively</span><span>(n)</span></span></code></pre></figure>
<p>Russell pointed out that by reversing the conditional and checking for what we DON’T have, we can simplify things, but that we could simplify even farther by just calculating n</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="javascript" data-theme="github-light github-dark"><code data-language="javascript" data-theme="github-light github-dark"><span data-line=""> </span>
<span data-line=""><span>var</span><span> climbStairs</span><span> =</span><span> function</span><span>(</span><span>n</span><span>) {</span></span>
<span data-line=""> </span>
<span data-line=""><span>    let</span><span> initial </span><span>=</span><span> new</span><span> Map</span><span>()</span></span>
<span data-line=""><span>    initial.</span><span>set</span><span>(</span><span>1</span><span>, </span><span>1</span><span>)</span></span>
<span data-line=""><span>    initial.</span><span>set</span><span>(</span><span>2</span><span>, </span><span>2</span><span>)</span></span>
<span data-line=""> </span>
<span data-line=""><span>    let</span><span> climbStairsRecursively</span><span> =</span><span> function</span><span>(</span><span>n</span><span>){</span></span>
<span data-line=""><span>        if</span><span> (initial.</span><span>has</span><span>(n)) </span><span>return</span><span> initial.</span><span>get</span><span>(n)</span></span>
<span data-line=""> </span>
<span data-line=""><span>        initial.</span><span>set</span><span>(n, </span><span>climbStairsRecursively</span><span>(n</span><span>-</span><span>1</span><span>) </span><span>+</span><span> climbStairsRecursively</span><span>(n</span><span>-</span><span>2</span><span>))</span></span>
<span data-line=""> </span>
<span data-line=""><span>        return</span><span> initial.</span><span>get</span><span>(n)</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""> </span>
<span data-line=""><span>    return</span><span> climbStairsRecursively</span><span>(n)</span></span>
<span data-line=""><span>};</span></span>
<span data-line=""> </span></code></pre></figure>

<ul>
<li>typos are a real - I misspelled <code>initial</code> a few times, which was an unhelpful var name anyway</li>
<li>avoid picking difficult to type variable names like <code>initial</code></li>
<li>working through example cases is a great thing to do if little else occurs to me. A lot of inspiration struck at this moment. More on that:</li>
</ul>

<p>This might point towards the most difficult part about encountering novel, strange coding puzzles. Somewhere, somehow - I don’t know who put it there - there’s this expectation that you have a stroke of inspiration about how to solve a puzzle. Sometimes I do! Sometimes I have a hunch about what to do. But sometimes there is very little. Or the hunches lead me in the wrong direction.</p>
<p>This sort of approach of “what’s a clever way to do this”, well, it can work sometimes I think. But, it can’t really be relied on.</p>
<p>You know what can be relied on? Doing it manually. I think it’s easy to forget that programming replaces manual operations. Well, it can be hard to replace manual operations if you’re not familiar with them. Eloquence, brevity and abstraction are difficult to arrive at unless there is some ugly, long-winded phrase of axioms to improve upon. In other words, the act of improving <em>nothing</em> is infinitely harder than improving <em>something.</em></p>
<p>So writing out the expected outcome for a single case seemed like a great exercise. I got to see what my brain did, and abstract. I also got to observe (even if Russell sort of handed them to me) patterns, like the Fibonacci sequence.</p></article></div>
  </body>
</html>
