<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.regehr.org/archives/1393">Original</a>
    <h1>Teaching C (2016)</h1>
    
    <div id="readability-page-1" class="page"><div><p>The other day <a href="https://www.mpi-sws.org/~neelk/">Neel Krishnaswami</a> mentioned that he’s going to be teaching the C class at Cambridge in the fall, and asked if I had any advice about that topic. Of course I do! In fact the response got so long that it ended up being a blog post.</p>
<p>My main idea is that we need to teach C in a way that helps students understand why a very large fraction of critical software infrastructure, including almost all operating systems and embedded systems, is written in C, while also acknowledging the disastrously central role that it has played in our ongoing computer security nightmare.</p>
<p>There’s a lot of reading material out there. For the basics, I still recommend that students purchase <a href="http://www.amazon.com/Programming-Language-Brian-W-Kernighan/dp/0131103628/">K&amp;R</a>. People say good things about <a href="http://knking.com/books/c2/">C Programming: A Modern Approach</a>; I’ve only skimmed it. For advanced C I’ve not read a better book than <a href="http://www.amazon.com/Expert-Programming-Peter-van-Linden/dp/0131774298/">Expert C Programming</a>, though like K&amp;R it is fairly old. <a href="http://www.amazon.com/Practice-Programming-Brian-W-Kernighan/dp/020161586X">The Practice of Programming</a> is a really great book though it’s not completely specific to C. I haven’t read all of it but from what I’ve seen <a href="http://icube-icps.unistra.fr/img_auth.php/d/db/ModernC.pdf">Modern C</a> is a very good resource, with AFAIK the best treatment of undefined behavior of any C book. The <a href="http://c-faq.com/">C FAQ</a> contains lots of good material.</p>
<p>For supplemental reading, of course the students need to look at all three parts of <a href="http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html">Chris Lattner’s writeup</a> about undefined behavior, and <a href="https://blog.regehr.org/archives/213">mine as well</a>.</p>
<p>What version of C should we teach? Probably a common subset of C99 and C11. In a first C class there’s no need to go into advanced C11 features such as the concurrent memory model.</p>
<p>We’d like students to be able to answer the question: <strong>Is C an appropriate choice for solving this problem?</strong> We’ll want some lecture material about C’s place in the modern world and we also need to spend time reading some high-quality C code, perhaps starting with <a href="http://redis.io/">Redis</a>, <a href="https://www.musl-libc.org/">Musl</a>, or <a href="https://pdos.csail.mit.edu/6.828/2014/xv6.html">Xv6</a>. Musl, in particular, is a good match for teaching since it contains lots of <a href="https://git.musl-libc.org/cgit/musl/tree/src/string/memchr.c">cute little functions</a> that can be understood in isolation. From any such function we can launch a discussion about tradeoffs between portability, efficiency, maintainability, testability, etc. If Rich Felker (the Musl author) did something a certain way, there’s probably a good reason for it and we should be able to puzzle it out. We can also use Matt Godbolt’s super awesome compiler explorer to <a href="https://godbolt.org/g/EuyYxa">look at the code generated</a> by various compilers. C’s lightweight-to-nonexistent runtime support is one of its key advantages for real-world system building, and it also means that generated code can be understood without thinking about something like a garbage collector.</p>
<p>We probably also need to spend a bit of time looking at bad old C, the kind that makes the world work even though we’re not proud of it. We can find files in OpenSSL and in the PHP interpreter that would singe your brain despite getting run billions of times a day, or we can always pick on an old standby like <a href="https://sourceware.org/git/?p=glibc.git;a=blob;f=intl/dcigettext.c;h=3d38de99e7c79df28a68c115db99aa772b55ddb5;hb=HEAD">glibc</a> — worth looking at just for the preprocessor abuse. But perhaps I am being uncharitable: Pascal Cuoq (reading a draft of this piece) correctly points out that “even what seems like plain stupidity often stems from engineering trade-offs. Does the project try to remain compilable under MS-DOS with DJGPP, with C90 compilers, under VMS, or all three at the same time?” And it is true that we would do well to help students understand that real-world engineering constraints do not often resemble the circumstances that we lead them to expect in school.</p>
<p>The second big thing each student should learn is: <strong>How can I avoid being burned by C’s numerous and severe shortcomings?</strong> This is a development environment where only the paranoid can survive; we want to emphasize a modern C programming style and heavy reliance on the (thankfully excellent) collection of tools that is available for helping us develop good C.</p>
<p>Static analysis is the first line of defense; the students need to use a good selection of -W flags and then get used to making things compile without warnings. A stronger tool such as the <a href="http://clang-analyzer.llvm.org/">Clang static analyzer</a> should also be used. On the dynamic side, all code handed in by students must be clean as far as <a href="http://clang.llvm.org/docs/AddressSanitizer.html">ASan</a>, <a href="http://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html">UBSan</a>, and <a href="http://clang.llvm.org/docs/MemorySanitizer.html">MSan</a> are concerned. <a href="http://trust-in-soft.com/tis-interpreter/">tis-interpreter</a> holds code to an even higher standard; I haven’t had students use this tool yet but I think it’s a great thing to try. Since dynamic testing is limited by the quality of the test cases, the students need to get used to using the output of a code coverage tool to find gaps in test coverage. Lots of coverage tools for C are available but I usually just use <a href="https://gcc.gnu.org/onlinedocs/gcc/Gcov.html">gcov</a> since it is ubiquitous and hassle-free.</p>
<p>Teaching undefined behavior using sanitizers is a piece of cake: the tool gives students exactly the feedback that they need. The other way of teaching undefined behavior, by looking at <a href="https://blog.regehr.org/archives/767">its consequences</a>, is something that we should spend a bit of time on, but it requires a different kind of thinking and we probably won’t expect the majority of students to pick up on all the subtleties — even seasoned professional C programmers are often unaware of these.</p>
<p>Detecting errors and doing something about them is a really important part of programming that we typically don’t teach much about in school. Since C is designed to avoid sweeping these problems under the rug, a C class is a great place to get students started on the right track. They should have to implement a <a href="https://blog.regehr.org/archives/894">goto chain</a>.</p>
<p>Something I’m leaving out of this post is the content of the assignments that we give the students — this mostly depends on the specific goals of the course and how it fits into the broader curriculum (In what year are students expected to take the class? What kind of background do they have in math and science? What languages do they already know?). I’ve always taught C as a side effect of teaching operating systems, embedded systems, or something along those lines. In a course where the primary goal is C we have more freedom, and could look at more domains. Image processing and cryptographic algorithms would be really fun, for example, and even the old standby, <a href="https://blog.regehr.org/archives/896">data structures</a>, can be used to good effect in class.</p>
<p>I’m also leaving out build systems and version control. They should use these.</p>
<p>In some courses I will give students access to the test infrastructure that will be used to grade their code. This makes assignments a lot more fun, and makes students a lot more happy. Other times I will give them a few test cases and keep the good tests (and the fuzzers) for myself. The idea is to make the assignment not only about implementation but also about testing. This stresses students out but it’s far more realistic.</p>
<p>Pascal remarks that “C is mostly taught very badly, and a student who aims at becoming good at maintaining C code will need to unlearn much that they have (typically) been told in class.” This is regrettably true — a lot of instructors learned C in previous decades and then they teach an outdated language, for example failing to discourage preprocessor abuse. The most serious common failing is to leave students unaware of their side of the bargain when the deal with a C compiler. I am talking of course about undefined behavior (and, to a lesser extent, unspecified and implementation-defined behavior). As a concrete example, I have taught numerous classes based on <a href="http://csapp.cs.cmu.edu/">Computer Systems: A Programmer’s Perspective</a>. In most respects this is an excellent book, but (even in the 3rd edition) it not only ignores undefined behavior but, worse, explicitly teaches students that signed integers in C have two’s complement behavior on overflow:</p>
<p>One might argue that we shouldn’t be teaching C any longer, and I would certainly agree that C is probably a poor first or second language. On the other hand, even if we were in a position where no new projects should be written in C (that day is coming, but slowly — probably at least a decade off), we’re still going to be stuck maintaining C for many decades. A random CS graduate has pretty good odds of running into C during her career. But beyond that, even after we replace C, the systems programming niche will remain. A lot of what we learn when we think we’re learning C is low-level programming and that stuff is important.</p>
<p>Thanks to Pascal Cuoq and Robby Findler for commenting on drafts of this piece.</p>
</div></div>
  </body>
</html>
