<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/ChartGPU/ChartGPU">Original</a>
    <h1>Show HN: ChartGPU ‚Äì WebGPU-powered charting library (1M points at 60fps)</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text"><p dir="auto">
  <a target="_blank" rel="noopener noreferrer" href="https://blog.veitheller.de/ChartGPU/ChartGPU/blob/main/docs/assets/chart-gpu.jpg"><img src="https://blog.veitheller.de/ChartGPU/ChartGPU/raw/main/docs/assets/chart-gpu.jpg" alt="ChartGPU" width="400"/></a>
</p>
<p dir="auto">
  High-performance charts powered by WebGPU
</p>
<p dir="auto">
  <a href="https://github.com/hunterg325/ChartGPU/blob/main/docs/GETTING_STARTED.md">Documentation</a> |
  <a href="https://chartgpu.github.io/ChartGPU/" rel="nofollow">Live Demo</a> |
  <a href="https://github.com/hunterg325/ChartGPU/tree/main/examples">Examples</a>
</p>
<p dir="auto">
  <a href="https://www.npmjs.com/package/chartgpu" rel="nofollow">
    <img src="https://camo.githubusercontent.com/5dade81d029498527fff2eb2af0c92345f06a96e4ba74b183a331bf5470ef274/68747470733a2f2f696d672e736869656c64732e696f2f6e706d2f762f6368617274677075" alt="npm" data-canonical-src="https://img.shields.io/npm/v/chartgpu"/>
  </a>
  <a href="https://github.com/hunterg325/ChartGPU/blob/main/LICENSE">
    <img src="https://camo.githubusercontent.com/52a7df47768c92b4adda60e321b1caf269118a447289d12733d196d4a712d763/68747470733a2f2f696d672e736869656c64732e696f2f6e706d2f6c2f6368617274677075" alt="license" data-canonical-src="https://img.shields.io/npm/l/chartgpu"/>
  </a>
  <a href="https://chartgpu.github.io/ChartGPU/" rel="nofollow">
    <img src="https://camo.githubusercontent.com/5274b4e2c45a4fe1b80fbce179f9d2a9c6f930ffd1abd2fa823b9530b42194fd/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f64656d6f2d6c6976652d627269676874677265656e" alt="Live Demo" data-canonical-src="https://img.shields.io/badge/demo-live-brightgreen"/>
  </a>
</p>
<p dir="auto">ChartGPU is a TypeScript charting library built on WebGPU for smooth, interactive rendering‚Äîespecially when you have lots of data.</p>

<ul dir="auto">
<li>üöÄ WebGPU-accelerated rendering for high FPS with large datasets</li>
<li>üìà Multiple series types: line, area, bar, scatter, pie, candlestick</li>
<li>üß≠ Built-in interaction: hover highlight, tooltip, crosshair</li>
<li>üîÅ Streaming updates via <code>appendData(...)</code> (cartesian series)</li>
<li>üîç X-axis zoom (inside gestures + optional slider UI)</li>
<li>üéõÔ∏è Theme presets (<code>&#39;dark&#39; | &#39;light&#39;</code>) and custom theme support</li>
</ul>

<p dir="auto">At a high level, <code>ChartGPU.create(...)</code> owns the canvas + WebGPU lifecycle, and delegates render orchestration (layout/scales/data upload/render passes + internal overlays) to the render coordinator. For deeper internal notes, see <a href="https://github.com/hunterg325/ChartGPU/blob/main/docs/API.md"><code>docs/API.md</code></a> (especially ‚ÄúRender coordinator‚Äù).</p>
<section data-identity="baa048b5-b9a7-41ee-96ce-3eb6ad350098" data-host="https://viewscreen.githubusercontent.com" data-src="https://viewscreen.githubusercontent.com/markdown/mermaid?docs_host=https%3A%2F%2Fdocs.github.com" data-type="mermaid" aria-label="mermaid rendered output container">
  <div data-json="{&#34;data&#34;:&#34;flowchart TB\n  UserApp[\&#34;Consumer app\&#34;] --&amp;gt; PublicAPI[\&#34;src/index.ts (Public API exports)\&#34;]\n\n  PublicAPI --&amp;gt; ChartCreate[\&#34;ChartGPU.create(container, options)\&#34;]\n  PublicAPI --&amp;gt; SyncAPI[\&#34;connectCharts(charts)\&#34;]\n\n  subgraph ChartInstance[\&#34;Chart instance (src/ChartGPU.ts)\&#34;]\n    ChartCreate --&amp;gt; SupportCheck[\&#34;checkWebGPUSupport()\&#34;]\n    ChartCreate --&amp;gt; Canvas[\&#34;Create canvas + mount into container\&#34;]\n    ChartCreate --&amp;gt; Options[\&#34;resolveOptions(options)\&#34;]\n    ChartCreate --&amp;gt; GPUInit[\&#34;GPUContext.create(canvas)\&#34;]\n    ChartCreate --&amp;gt; Coordinator[\&#34;createRenderCoordinator(gpuContext, resolvedOptions)\&#34;]\n\n    ChartCreate --&amp;gt; InstanceAPI[\&#34;ChartGPUInstance APIs\&#34;]\n    InstanceAPI --&amp;gt; RequestRender[\&#34;requestAnimationFrame (coalesced)\&#34;]\n    RequestRender --&amp;gt; Coordinator\n\n    InstanceAPI --&amp;gt; SetOption[\&#34;setOption(...)\&#34;]\n    InstanceAPI --&amp;gt; AppendData[\&#34;appendData(...)\&#34;]\n    InstanceAPI --&amp;gt; Resize[\&#34;resize()\&#34;]\n\n    subgraph PublicEvents[\&#34;Public events + hit-testing (ChartGPU.ts)\&#34;]\n      Canvas --&amp;gt; PointerHandlers[\&#34;Pointer listeners\&#34;]\n      PointerHandlers --&amp;gt; PublicHitTest[\&#34;findNearestPoint() / findPieSlice()\&#34;]\n      PointerHandlers --&amp;gt; EmitEvents[\&#34;emit(&#39;click&#39;/&#39;mouseover&#39;/&#39;mouseout&#39;)\&#34;]\n    end\n\n    DataZoomSlider[\&#34;dataZoom slider UI (DOM)\&#34;] --&amp;gt; Coordinator\n  end\n\n  subgraph WebGPUCore[\&#34;WebGPU core (src/core/GPUContext.ts)\&#34;]\n    GPUInit --&amp;gt; AdapterDevice[\&#34;navigator.gpu.requestAdapter/device\&#34;]\n    GPUInit --&amp;gt; CanvasConfig[\&#34;canvasContext.configure(format)\&#34;]\n  end\n\n  subgraph RenderCoordinatorLayer[\&#34;Render coordinator (src/core/createRenderCoordinator.ts)\&#34;]\n    Coordinator --&amp;gt; Layout[\&#34;GridArea layout\&#34;]\n    Coordinator --&amp;gt; Scales[\&#34;xScale/yScale (clip space for render)\&#34;]\n    Coordinator --&amp;gt; DataUpload[\&#34;createDataStore(device) (GPU buffer upload/caching)\&#34;]\n    Coordinator --&amp;gt; RenderPass[\&#34;Encode + submit render pass\&#34;]\n\n    subgraph InternalOverlays[\&#34;Internal interaction overlays (coordinator)\&#34;]\n      Coordinator --&amp;gt; Events[\&#34;createEventManager(canvas, gridArea)\&#34;]\n      Events --&amp;gt; OverlayHitTest[\&#34;hover/tooltip hit-testing\&#34;]\n      Events --&amp;gt; InteractionX[\&#34;interaction-x state (crosshair)\&#34;]\n      Coordinator --&amp;gt; OverlaysDOM[\&#34;DOM overlays: legend / tooltip / text labels\&#34;]\n    end\n  end\n\n  subgraph Renderers[\&#34;GPU renderers (src/renderers/*)\&#34;]\n    RenderPass --&amp;gt; GridR[\&#34;Grid\&#34;]\n    RenderPass --&amp;gt; AreaR[\&#34;Area\&#34;]\n    RenderPass --&amp;gt; BarR[\&#34;Bar\&#34;]\n    RenderPass --&amp;gt; ScatterR[\&#34;Scatter\&#34;]\n    RenderPass --&amp;gt; LineR[\&#34;Line\&#34;]\n    RenderPass --&amp;gt; PieR[\&#34;Pie\&#34;]\n    RenderPass --&amp;gt; CandlestickR[\&#34;Candlestick\&#34;]\n    RenderPass --&amp;gt; CrosshairR[\&#34;Crosshair overlay\&#34;]\n    RenderPass --&amp;gt; HighlightR[\&#34;Hover highlight overlay\&#34;]\n    RenderPass --&amp;gt; AxisR[\&#34;Axes/ticks\&#34;]\n  end\n\n  subgraph Shaders[\&#34;WGSL shaders (src/shaders/*)\&#34;]\n    GridR --&amp;gt; gridWGSL[\&#34;grid.wgsl\&#34;]\n    AreaR --&amp;gt; areaWGSL[\&#34;area.wgsl\&#34;]\n    BarR --&amp;gt; barWGSL[\&#34;bar.wgsl\&#34;]\n    ScatterR --&amp;gt; scatterWGSL[\&#34;scatter.wgsl\&#34;]\n    LineR --&amp;gt; lineWGSL[\&#34;line.wgsl\&#34;]\n    PieR --&amp;gt; pieWGSL[\&#34;pie.wgsl\&#34;]\n    CandlestickR --&amp;gt; candlestickWGSL[\&#34;candlestick.wgsl\&#34;]\n    CrosshairR --&amp;gt; crosshairWGSL[\&#34;crosshair.wgsl\&#34;]\n    HighlightR --&amp;gt; highlightWGSL[\&#34;highlight.wgsl\&#34;]\n  end\n\n  subgraph ChartSync[\&#34;Chart sync (src/interaction/createChartSync.ts)\&#34;]\n    SyncAPI --&amp;gt; ListenX[\&#34;listen: &#39;crosshairMove&#39;\&#34;]\n    SyncAPI --&amp;gt; DriveX[\&#34;setCrosshairX(...) on peers\&#34;]\n  end\n\n  InteractionX --&amp;gt; ListenX\n  DriveX --&amp;gt; InstanceAPI\n&#34;}" data-plain="flowchart TB
  UserApp[&#34;Consumer app&#34;] --&gt; PublicAPI[&#34;src/index.ts (Public API exports)&#34;]

  PublicAPI --&gt; ChartCreate[&#34;ChartGPU.create(container, options)&#34;]
  PublicAPI --&gt; SyncAPI[&#34;connectCharts(charts)&#34;]

  subgraph ChartInstance[&#34;Chart instance (src/ChartGPU.ts)&#34;]
    ChartCreate --&gt; SupportCheck[&#34;checkWebGPUSupport()&#34;]
    ChartCreate --&gt; Canvas[&#34;Create canvas + mount into container&#34;]
    ChartCreate --&gt; Options[&#34;resolveOptions(options)&#34;]
    ChartCreate --&gt; GPUInit[&#34;GPUContext.create(canvas)&#34;]
    ChartCreate --&gt; Coordinator[&#34;createRenderCoordinator(gpuContext, resolvedOptions)&#34;]

    ChartCreate --&gt; InstanceAPI[&#34;ChartGPUInstance APIs&#34;]
    InstanceAPI --&gt; RequestRender[&#34;requestAnimationFrame (coalesced)&#34;]
    RequestRender --&gt; Coordinator

    InstanceAPI --&gt; SetOption[&#34;setOption(...)&#34;]
    InstanceAPI --&gt; AppendData[&#34;appendData(...)&#34;]
    InstanceAPI --&gt; Resize[&#34;resize()&#34;]

    subgraph PublicEvents[&#34;Public events + hit-testing (ChartGPU.ts)&#34;]
      Canvas --&gt; PointerHandlers[&#34;Pointer listeners&#34;]
      PointerHandlers --&gt; PublicHitTest[&#34;findNearestPoint() / findPieSlice()&#34;]
      PointerHandlers --&gt; EmitEvents[&#34;emit(&#39;click&#39;/&#39;mouseover&#39;/&#39;mouseout&#39;)&#34;]
    end

    DataZoomSlider[&#34;dataZoom slider UI (DOM)&#34;] --&gt; Coordinator
  end

  subgraph WebGPUCore[&#34;WebGPU core (src/core/GPUContext.ts)&#34;]
    GPUInit --&gt; AdapterDevice[&#34;navigator.gpu.requestAdapter/device&#34;]
    GPUInit --&gt; CanvasConfig[&#34;canvasContext.configure(format)&#34;]
  end

  subgraph RenderCoordinatorLayer[&#34;Render coordinator (src/core/createRenderCoordinator.ts)&#34;]
    Coordinator --&gt; Layout[&#34;GridArea layout&#34;]
    Coordinator --&gt; Scales[&#34;xScale/yScale (clip space for render)&#34;]
    Coordinator --&gt; DataUpload[&#34;createDataStore(device) (GPU buffer upload/caching)&#34;]
    Coordinator --&gt; RenderPass[&#34;Encode + submit render pass&#34;]

    subgraph InternalOverlays[&#34;Internal interaction overlays (coordinator)&#34;]
      Coordinator --&gt; Events[&#34;createEventManager(canvas, gridArea)&#34;]
      Events --&gt; OverlayHitTest[&#34;hover/tooltip hit-testing&#34;]
      Events --&gt; InteractionX[&#34;interaction-x state (crosshair)&#34;]
      Coordinator --&gt; OverlaysDOM[&#34;DOM overlays: legend / tooltip / text labels&#34;]
    end
  end

  subgraph Renderers[&#34;GPU renderers (src/renderers/*)&#34;]
    RenderPass --&gt; GridR[&#34;Grid&#34;]
    RenderPass --&gt; AreaR[&#34;Area&#34;]
    RenderPass --&gt; BarR[&#34;Bar&#34;]
    RenderPass --&gt; ScatterR[&#34;Scatter&#34;]
    RenderPass --&gt; LineR[&#34;Line&#34;]
    RenderPass --&gt; PieR[&#34;Pie&#34;]
    RenderPass --&gt; CandlestickR[&#34;Candlestick&#34;]
    RenderPass --&gt; CrosshairR[&#34;Crosshair overlay&#34;]
    RenderPass --&gt; HighlightR[&#34;Hover highlight overlay&#34;]
    RenderPass --&gt; AxisR[&#34;Axes/ticks&#34;]
  end

  subgraph Shaders[&#34;WGSL shaders (src/shaders/*)&#34;]
    GridR --&gt; gridWGSL[&#34;grid.wgsl&#34;]
    AreaR --&gt; areaWGSL[&#34;area.wgsl&#34;]
    BarR --&gt; barWGSL[&#34;bar.wgsl&#34;]
    ScatterR --&gt; scatterWGSL[&#34;scatter.wgsl&#34;]
    LineR --&gt; lineWGSL[&#34;line.wgsl&#34;]
    PieR --&gt; pieWGSL[&#34;pie.wgsl&#34;]
    CandlestickR --&gt; candlestickWGSL[&#34;candlestick.wgsl&#34;]
    CrosshairR --&gt; crosshairWGSL[&#34;crosshair.wgsl&#34;]
    HighlightR --&gt; highlightWGSL[&#34;highlight.wgsl&#34;]
  end

  subgraph ChartSync[&#34;Chart sync (src/interaction/createChartSync.ts)&#34;]
    SyncAPI --&gt; ListenX[&#34;listen: &#39;crosshairMove&#39;&#34;]
    SyncAPI --&gt; DriveX[&#34;setCrosshairX(...) on peers&#34;]
  end

  InteractionX --&gt; ListenX
  DriveX --&gt; InstanceAPI
" dir="auto">
    <div dir="auto">
      <pre lang="mermaid" aria-label="Raw mermaid code">flowchart TB
  UserApp[&#34;Consumer app&#34;] --&gt; PublicAPI[&#34;src/index.ts (Public API exports)&#34;]

  PublicAPI --&gt; ChartCreate[&#34;ChartGPU.create(container, options)&#34;]
  PublicAPI --&gt; SyncAPI[&#34;connectCharts(charts)&#34;]

  subgraph ChartInstance[&#34;Chart instance (src/ChartGPU.ts)&#34;]
    ChartCreate --&gt; SupportCheck[&#34;checkWebGPUSupport()&#34;]
    ChartCreate --&gt; Canvas[&#34;Create canvas + mount into container&#34;]
    ChartCreate --&gt; Options[&#34;resolveOptions(options)&#34;]
    ChartCreate --&gt; GPUInit[&#34;GPUContext.create(canvas)&#34;]
    ChartCreate --&gt; Coordinator[&#34;createRenderCoordinator(gpuContext, resolvedOptions)&#34;]

    ChartCreate --&gt; InstanceAPI[&#34;ChartGPUInstance APIs&#34;]
    InstanceAPI --&gt; RequestRender[&#34;requestAnimationFrame (coalesced)&#34;]
    RequestRender --&gt; Coordinator

    InstanceAPI --&gt; SetOption[&#34;setOption(...)&#34;]
    InstanceAPI --&gt; AppendData[&#34;appendData(...)&#34;]
    InstanceAPI --&gt; Resize[&#34;resize()&#34;]

    subgraph PublicEvents[&#34;Public events + hit-testing (ChartGPU.ts)&#34;]
      Canvas --&gt; PointerHandlers[&#34;Pointer listeners&#34;]
      PointerHandlers --&gt; PublicHitTest[&#34;findNearestPoint() / findPieSlice()&#34;]
      PointerHandlers --&gt; EmitEvents[&#34;emit(&#39;click&#39;/&#39;mouseover&#39;/&#39;mouseout&#39;)&#34;]
    end

    DataZoomSlider[&#34;dataZoom slider UI (DOM)&#34;] --&gt; Coordinator
  end

  subgraph WebGPUCore[&#34;WebGPU core (src/core/GPUContext.ts)&#34;]
    GPUInit --&gt; AdapterDevice[&#34;navigator.gpu.requestAdapter/device&#34;]
    GPUInit --&gt; CanvasConfig[&#34;canvasContext.configure(format)&#34;]
  end

  subgraph RenderCoordinatorLayer[&#34;Render coordinator (src/core/createRenderCoordinator.ts)&#34;]
    Coordinator --&gt; Layout[&#34;GridArea layout&#34;]
    Coordinator --&gt; Scales[&#34;xScale/yScale (clip space for render)&#34;]
    Coordinator --&gt; DataUpload[&#34;createDataStore(device) (GPU buffer upload/caching)&#34;]
    Coordinator --&gt; RenderPass[&#34;Encode + submit render pass&#34;]

    subgraph InternalOverlays[&#34;Internal interaction overlays (coordinator)&#34;]
      Coordinator --&gt; Events[&#34;createEventManager(canvas, gridArea)&#34;]
      Events --&gt; OverlayHitTest[&#34;hover/tooltip hit-testing&#34;]
      Events --&gt; InteractionX[&#34;interaction-x state (crosshair)&#34;]
      Coordinator --&gt; OverlaysDOM[&#34;DOM overlays: legend / tooltip / text labels&#34;]
    end
  end

  subgraph Renderers[&#34;GPU renderers (src/renderers/*)&#34;]
    RenderPass --&gt; GridR[&#34;Grid&#34;]
    RenderPass --&gt; AreaR[&#34;Area&#34;]
    RenderPass --&gt; BarR[&#34;Bar&#34;]
    RenderPass --&gt; ScatterR[&#34;Scatter&#34;]
    RenderPass --&gt; LineR[&#34;Line&#34;]
    RenderPass --&gt; PieR[&#34;Pie&#34;]
    RenderPass --&gt; CandlestickR[&#34;Candlestick&#34;]
    RenderPass --&gt; CrosshairR[&#34;Crosshair overlay&#34;]
    RenderPass --&gt; HighlightR[&#34;Hover highlight overlay&#34;]
    RenderPass --&gt; AxisR[&#34;Axes/ticks&#34;]
  end

  subgraph Shaders[&#34;WGSL shaders (src/shaders/*)&#34;]
    GridR --&gt; gridWGSL[&#34;grid.wgsl&#34;]
    AreaR --&gt; areaWGSL[&#34;area.wgsl&#34;]
    BarR --&gt; barWGSL[&#34;bar.wgsl&#34;]
    ScatterR --&gt; scatterWGSL[&#34;scatter.wgsl&#34;]
    LineR --&gt; lineWGSL[&#34;line.wgsl&#34;]
    PieR --&gt; pieWGSL[&#34;pie.wgsl&#34;]
    CandlestickR --&gt; candlestickWGSL[&#34;candlestick.wgsl&#34;]
    CrosshairR --&gt; crosshairWGSL[&#34;crosshair.wgsl&#34;]
    HighlightR --&gt; highlightWGSL[&#34;highlight.wgsl&#34;]
  end

  subgraph ChartSync[&#34;Chart sync (src/interaction/createChartSync.ts)&#34;]
    SyncAPI --&gt; ListenX[&#34;listen: &#39;crosshairMove&#39;&#34;]
    SyncAPI --&gt; DriveX[&#34;setCrosshairX(...) on peers&#34;]
  end

  InteractionX --&gt; ListenX
  DriveX --&gt; InstanceAPI
</pre>
    </div>
  </div>
  <span role="presentation">
    <span data-view-component="true">
  <svg style="box-sizing: content-box; color: var(--color-icon-primary);" width="16" height="16" viewBox="0 0 16 16" fill="none" aria-hidden="true" data-view-component="true">
    <circle cx="8" cy="8" r="7" stroke="currentColor" stroke-opacity="0.25" stroke-width="2" vector-effect="non-scaling-stroke" fill="none"></circle>
    <path d="M15 8a7.002 7.002 0 00-7-7" stroke="currentColor" stroke-width="2" stroke-linecap="round" vector-effect="non-scaling-stroke"></path>
</svg>    <span>Loading</span>
</span>
  </span>
</section>


<p dir="auto"><a target="_blank" rel="noopener noreferrer nofollow" href="https://raw.githubusercontent.com/hunterg325/ChartGPU/main/docs/assets/chart-gpu-demo.gif"><img src="https://raw.githubusercontent.com/hunterg325/ChartGPU/main/docs/assets/chart-gpu-demo.gif" alt="ChartGPU demo" data-animated-image=""/></a></p>

<p dir="auto">Financial OHLC (open-high-low-close) candlestick rendering with classic/hollow style toggle and color customization.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://blog.veitheller.de/ChartGPU/ChartGPU/blob/main/docs/assets/candle-stick-example.png"><img src="https://blog.veitheller.de/ChartGPU/ChartGPU/raw/main/docs/assets/candle-stick-example.png" alt="Candlestick chart example"/></a></p>

<div dir="auto" data-snippet-clipboard-copy-content="import { ChartGPU } from &#39;chartgpu&#39;;
const container = document.getElementById(&#39;chart&#39;)!;
await ChartGPU.create(container, {
  series: [{ type: &#39;line&#39;, data: [[0, 1], [1, 3], [2, 2]] }],
});"><pre><span>import</span> <span>{</span> <span>ChartGPU</span> <span>}</span> <span>from</span> <span>&#39;chartgpu&#39;</span><span>;</span>
<span>const</span> <span>container</span> <span>=</span> <span>document</span><span>.</span><span>getElementById</span><span>(</span><span>&#39;chart&#39;</span><span>)</span><span>!</span><span>;</span>
<span>await</span> <span>ChartGPU</span><span>.</span><span>create</span><span>(</span><span>container</span><span>,</span> <span>{</span>
  <span>series</span>: <span>[</span><span>{</span> <span>type</span>: <span>&#39;line&#39;</span><span>,</span> <span>data</span>: <span>[</span><span>[</span><span>0</span><span>,</span> <span>1</span><span>]</span><span>,</span> <span>[</span><span>1</span><span>,</span> <span>3</span><span>]</span><span>,</span> <span>[</span><span>2</span><span>,</span> <span>2</span><span>]</span><span>]</span> <span>}</span><span>]</span><span>,</span>
<span>}</span><span>)</span><span>;</span></pre></div>

<p dir="auto"><code>npm install chartgpu</code></p>

<p dir="auto">React bindings are available via <a href="https://github.com/ChartGPU/chartgpu-react"><code>chartgpu-react</code></a>:</p>
<div dir="auto" data-snippet-clipboard-copy-content="npm install chartgpu-react"><pre>npm install chartgpu-react</pre></div>
<div dir="auto" data-snippet-clipboard-copy-content="import { ChartGPUChart } from &#39;chartgpu-react&#39;;

function MyChart() {
  return (
    &lt;ChartGPUChart
      options={{
        series: [{ type: &#39;line&#39;, data: [[0, 1], [1, 3], [2, 2]] }],
      }}
    /&gt;
  );
}"><pre><span>import</span> <span>{</span> <span>ChartGPUChart</span> <span>}</span> <span>from</span> <span>&#39;chartgpu-react&#39;</span><span>;</span>

<span>function</span> <span>MyChart</span><span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>(</span>
    <span>&lt;</span><span>ChartGPUChart</span>
      <span>options</span><span>=</span><span>{</span><span>{</span>
        <span>series</span>: <span>[</span><span>{</span> <span>type</span>: <span>&#39;line&#39;</span><span>,</span> <span>data</span>: <span>[</span><span>[</span><span>0</span><span>,</span> <span>1</span><span>]</span><span>,</span> <span>[</span><span>1</span><span>,</span> <span>3</span><span>]</span><span>,</span> <span>[</span><span>2</span><span>,</span> <span>2</span><span>]</span><span>]</span> <span>}</span><span>]</span><span>,</span>
      <span>}</span><span>}</span>
    <span>/&gt;</span>
  <span>)</span><span>;</span>
<span>}</span></pre></div>
<p dir="auto">See the <a href="https://github.com/ChartGPU/chartgpu-react">chartgpu-react repository</a> for full documentation and examples.</p>
<div dir="auto"><h2 tabindex="-1" dir="auto">Browser support (WebGPU required)</h2><a id="user-content-browser-support-webgpu-required" aria-label="Permalink: Browser support (WebGPU required)" href="#browser-support-webgpu-required"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<ul dir="auto">
<li>Chrome 113+ or Edge 113+ (WebGPU enabled by default)</li>
<li>Safari 18+ (WebGPU enabled by default)</li>
<li>Firefox: not supported (WebGPU support in development)</li>
</ul>

<ul dir="auto">
<li>Full documentation: <a href="https://github.com/hunterg325/ChartGPU/blob/main/docs/GETTING_STARTED.md">Getting Started</a></li>
<li>API reference: <a href="https://github.com/hunterg325/ChartGPU/blob/main/docs/API.md"><code>docs/API.md</code></a></li>
</ul>

<ul dir="auto">
<li>Browse examples: <a href="https://github.com/hunterg325/ChartGPU/tree/main/examples"><code>examples/</code></a></li>
<li>Run locally:
<ul dir="auto">
<li><code>npm install</code></li>
<li><code>npm run dev</code> (opens <code>http://localhost:5176/examples/</code>)</li>
</ul>
</li>
</ul>

<p dir="auto">See <a href="https://github.com/hunterg325/ChartGPU/blob/main/CONTRIBUTING.md"><code>CONTRIBUTING.md</code></a>.</p>

<p dir="auto">MIT ‚Äî see <a href="https://github.com/hunterg325/ChartGPU/blob/main/LICENSE"><code>LICENSE</code></a>.</p>
</article></div></div>
  </body>
</html>
