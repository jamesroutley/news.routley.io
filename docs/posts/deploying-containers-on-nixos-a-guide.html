<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://bkiran.com/blog/deploying-containers-nixos">Original</a>
    <h1>Deploying Containers on NixOS: A Guide</h1>
    
    <div id="readability-page-1" class="page"><div>
        <p>Managing infrastructure on your own machine can be cumbersome and scary. Much of the rhetoric out there would have you believe that it’s not possible or very dangerous to run and manage your own server. There have been some great advances with tools like containers(Docker and Podman) and NixOS that makes this easier than ever.</p>

<h2 id="why-bother-with-nixos">Why Bother with NixOS?</h2>

<p>Most of my background is in DevOps and infrastructure. I set out to find the easiest way to manage multiple websites and applications on my own servers. Installing and managing Kubernetes seemed like a nightmare, and deploying with Docker Compose felt neither elegant nor easy enough to justify using it.</p>

<p>Then I came across NixOS. I found a way to adapt it to meet my needs for managing different application containers on a single machine—or even across a fleet. NixOS is a Linux distribution that offers a unique approach: immutable and declarative builds. This allows you to define the state of a machine in a single configuration file, which, as an infrastructure professional, is something I really like.</p>

<p>This approach fits me because of how I think about software. I love being able to see everything running on a machine in one place, defined declaratively. It enables you to create a configuration for your machine and seamlessly apply it to the host.</p>

<h2 id="containers-containers">Containers, Containers</h2>

<p>I have considerable experience running containers in production environments, usually on Kubernetes. Becuase of this, I prefer to package my software as a container. Many of my  workflows are built around the useage of containers.</p>

<p>For me, containers are simply a means to get things up and running in production quickly. While I can easily get a Docker image of my software packaged, how can I get it running on NixOS?</p>

<h4 id="1-setting-up-virtualization-and-podman">1. Setting up Virtualization and Podman</h4>

<p>There is an option in NixOS called vitualization. This allows for all different types of virtualization but we want to virtualize at the OS level(how Docker and Podman works). So here we’re going to pick one to use and and enable it. I’m using Podman but you can choose Docker if you like.</p>

<pre><code>  virtualisation = {
    podman = {
      enable = true;
    };
  };
</code></pre>

<h4 id="2-adding-our-container">2. Adding Our Container</h4>

<p>Okay so now that our virtualization is turned on, we want to start a container. We do that by defining a option in <code>virtualisation</code> called <code>oci-containers.containers</code>. For each container we want to run, we create and entry here. There are a few options that I always use:</p>

<ul>
<li><strong>image</strong>: Defines the container image we want to run.</li>
<li><strong>environment</strong>: Define environment variables that you want to be exposed within the container.</li>
<li><strong>entrypoint</strong>: Define a command to run on container startup(if needed).</li>
</ul>

<pre><code>  virtualisation = {
      podman = {
        enable = true;
      };
      oci-containers.containers = {
        my-appication = {
          image = &#34;myregistry.com/myApplication:latest&#34;;
          entrypoint = &#34;/root/main&#34;;
          environment = {
              DEV_MODE = &#34;false&#34;;
          };
        };
      };
  };
</code></pre>

<h4 id="3-private-registry-no-problem">3. Private Registry, No Problem</h4>

<p>Your container may not actually work at the previous step because it’s behind a private registry. It’s good practice to put your containers behind one and if you do, you need a way to authenticate. This is done using the <code>login</code> configuration.</p>

<pre><code>  virtualisation = {
      podman = {
        enable = true;
      };
      oci-containers.containers = {
        my-appication = {
          login = {
              registry = &#34;https://myregistry.com&#34;;
              username = &#34;myRegistryUsername&#34;;
              passwordFile = &#34;/root/registry-password.txt&#34;;
          };
          image = &#34;myregistry.com/myApplication:latest&#34;;
          entrypoint = &#34;/root/main&#34;;
          environment = {
              DEV_MODE = &#34;false&#34;;
          };
        };
      };
  };
</code></pre>

<h4 id="4-opening-it-up-to-the-outside">4. Opening it Up to the Outside</h4>

<p>For things like web servers, we need a way to expose our container to the outside world. This is achieved using ports on both the host and the container. First, we add the <code>ports</code> configuration to our container setup. At this point, our container is accessible to the machine itself. To make it accessible from outside the machine, we specify the following configuration: <code>networking.firewall.interfaces.ens4.allowedTCPPorts</code>. The complete configuration will look like this:</p>

<pre><code>  networking.firewall.interfaces.ens4.allowedTCPPorts = [
    8090
  ];

  virtualisation = {
      podman = {
        enable = true;
      };
      oci-containers.containers = {
        my-appication = {
          login = {
              registry = &#34;https://myregistry.com&#34;;
              username = &#34;myRegistryUsername&#34;;
              passwordFile = &#34;/root/registry-password.txt&#34;;
          };
          image = &#34;myregistry.com/myApplication:latest&#34;;
          ports = [&#34;8090:8000&#34;];
          entrypoint = &#34;/root/main&#34;;
          environment = {
              DEV_MODE = &#34;false&#34;;
          };
        };
      };
  };
</code></pre>

<h2 id="interacting-with-your-running-container">Interacting With Your Running Container</h2>

<p>Containers are started as systemd processes. You can use systemd commands interact and debug each running container. Also since our virutaulization is enabled, we can use our Podman and Docker commands.</p>

<p>Here are my favorite tools for debugging my running services. Systemd processes are named <code>podmain-{container-name}.service</code> so in our example it would be <code>podman-my-appication.service</code></p>

<h3 id="starting-stoping-and-statuses">Starting, Stoping and Statuses</h3>

<p>To get the current status of the application and last lines of logs we want to use the <code>status</code> command. This is useful for doing a quick check on if anything failed or just getting the last lines of logs.</p>

<pre><code>systemctl status {service}
</code></pre>

<p>Let’s say you want to start and stop a process. We can use the respective <code>start</code> and <code>stop</code> commands.</p>

<pre><code>systemctl start {service}
systemctl stop {service}
</code></pre>

<h3 id="the-process-journal">The Process Journal</h3>

<p><code>systemctl</code> is a useful command but it does not show us all the logs. To be able to view all the logs of a systemd serice, we need to use the <code>journalctl</code>.</p>

<pre><code>journalctl -u {service} -b
</code></pre>

<h3 id="container-commands">Container Commands</h3>

<p>To get a list of all the running podman services. Often times I use this command to get the container ID.</p>

<pre><code>podman ps
</code></pre>

<p>We can get more granular and specify the service name to get the ID of the container</p>

<pre><code>podman ps -aqf &#34;name={service}&#34;
</code></pre>

<p>Often times, I’ll jump into the contain to run some one off command or dig through internals to find an issue that I could not find on the logs exposed to the systemd service. We’ll do that with the <code>exec</code> command and use a shell that’s avaliable in your container(in this example im using <code>sh</code>).</p>

<pre><code>podman exec -it {container-id} /bin/sh
</code></pre>

<h2 id="what-are-you-waiting-for">What are You Waiting For?</h2>

<p>NixOS has some great attributes, especially if you’re willing to invest the time to learn and understand its configuration language. It’s the easiest Linux distribution I’ve used that allows me to go from configuration to working container orchestration seamlessly while not loosing sight that we’re running on Linux infrastructure. This also makes continuous deployment much simpler—we’ll explore that in future posts.</p>

    </div></div>
  </body>
</html>
