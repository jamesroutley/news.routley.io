<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://acko.net/blog/use-gpu-goes-trad/">Original</a>
    <h1>Use.GPU Goes Trad</h1>
    
    <div id="readability-page-1" class="page"><article>

  
    <img src="https://acko.net/files/use-gpu-goes-trad/cover.jpg" alt="Use.GPU Goes Trad"/>
  

  
  
    



<img src="https://acko.net/files/use-gpu-goes-trad/cover.jpg" alt="Cover Image - Traditional 3D Scene"/>

<div><div>

<p>I&#39;ve released a new version of <a href="https://usegpu.live">Use.GPU</a>, my <b>experimental reactive/declarative WebGPU framework</b>, now at version 0.8.</p>

<p>My goal is to make GPU rendering easier and more sane. I do this by applying the lessons and patterns learned from the React world, and basically turning them all up to 11, sometimes 12. This is done via my own <a href="https://usegpu.live/docs/guides-live-vs-react" target="_blank">Live run-time,</a> which is like a martian React on steroids.</p>

<p>The previous 0.7 release was themed around <i>compute</i>, where I applied my shader linker to a few challenging use cases. It hopefully made it clear that Use.GPU is very good at things that traditional engines are kinda bad at.</p>

<p>In comparison, 0.8 will seem banal, because the theme was to fill the gaps and bring some traditional conveniences, like:</p>

<ul>
  <li>Scenes and nodes with matrices</li>
  <li>Meshes with instancing</li>
  <li>Shadow maps for lighting</li>
  <li>Visibility culling for geometry</li>
</ul>

</div></div>

<div><p><img src="https://acko.net/files/use-gpu-goes-trad/scene.jpg" alt="Traditional 3D scene"/>

</p></div>

<div><div>

<p>These were absent mostly because I didn&#39;t really need them, and they didn&#39;t seem like they&#39;d push the architecture in novel directions. That&#39;s changed however, because there&#39;s one major refactor underpinning it all: the previously standard <i>forward</i> renderer is now entirely swappable. There is a shiny <i>deferred</i>-style renderer to showcase this ability, where lights are rendered separately, using a g-buffer with stenciling.</p>

<p>This new rendering pipeline is entirely component-driven, and fully dogfooded. There is no core renderer per-se: the way draws are realized depends purely on the components being used. It effectively realizes that most elusive of graphics grails, which established engines have had difficulty delivering on: a data-driven, scriptable render pipeline, that mortals can hopefully use.</p>

</div></div>




<div><div>
  <p><img src="https://acko.net/files/use-gpu-goes-trad/tree-app.png" alt="Root of app tree"/></p><p><i>Root of the App</i></p>
</div></div>

<div><div>
  <p><img src="https://acko.net/files/use-gpu-goes-trad/tree-pass.png" alt="Deep inside app tree"/></p><p><i>Deep inside the tree</i></p>
</div></div>

<div><div>

<p>I&#39;ve spent countless words on Use.GPU&#39;s effect-based architecture in prior posts, which I won&#39;t recap. Rather, I&#39;ll just summarize the one big trick: it&#39;s structured entirely as if it needs to produce only 1 frame. Then in order to be interactive, and animate, it selectively rewinds parts of the program, and reactively re-runs them. If it sounds crazy, that&#39;s because it is. And yet it works.</p>

<p>So the key point isn&#39;t the feature list above, but rather, how it does so. It continues to prove that this way of coding can pay off big. It has all the benefits of immediate-mode UI, with none of the downsides, and tons of extensibility. And there are some surprises along the way.</p>

<h2>Real Reactivity</h2>

<p>You might think: isn&#39;t this a solved problem? There are plenty of JS 3D engines. Hasn&#39;t React-Three-Fiber (R3F) shown how to make that declarative? And aren&#39;t these just web versions of what native engines like Unreal and Unity already do well, and better?</p>

<p>My answer is no, but it might not be clear why. Let me give an example from my current job.</p>

</div></div>

<div><p>
<img src="https://acko.net/files/use-gpu-goes-trad/editing-app.jpg" alt="a 3D editing app"/>
</p></div>

<div><div>

<p>My client needs a specialized 3D editing tool. In gaming terms you might think of it as a level design tool, except the levels are real buildings. The details don&#39;t really matter, only that they need a custom 3D editing UI. I&#39;ve been using Three.js and R3F for it, because that&#39;s what works today and what other people know.</p>

<p>Three.js might seem like a great choice for the job: it has a 3D scene, editing controls and so on. But, my scene is not the source of truth, it&#39;s the output of a process. The actual source of truth being live-edited is another tree that sits before it. So I need to solve a two-way synchronization problem between both. This requires careful reasoning about state changes.</p>

</div></div>



<div><div>
  <p><img src="https://acko.net/files/use-gpu-goes-trad/onchange.png" alt="onchange in three.js"/></p>
  <p><img src="https://acko.net/files/use-gpu-goes-trad/onchange2.png" alt="onchange in react three fiber"/></p>
  <p><i>Change handlers in Three.js and R3F</i></p>
</div></div>

<div><div>

<p>Sadly, the way Three.js responds to changes is ill-defined. As is common, its objects have &#34;dirty&#34; flags. They are resolved and cleared when the scene is re-rendered. But this is not an iron rule: many methods do trigger a local refresh on the spot. Worse, certain properties have an invisible setter, which immediately triggers a &#34;change&#34; event when you assign a new value to it. This also causes derived state to update and cascade, and will be broadcast to any code that might be listening.</p>

<p>The coding principle applied here is &#34;better safe than sorry&#34;. Each of these triggers was only added to fix a particular stale data bug, so their effects are incomplete, creating two big problems. Problem 1 is a mix of old and new state... but problem 2 is you can only make it worse, by adding <i>even more</i> pre-emptive partial updates, sprinkled around everywhere.</p>

<p>These &#34;change&#34; events are oblivious to the reason for the change, and this is actually key: if a change was caused by a user interaction, the rest of the app needs to respond to it. But if the change was <i>computed</i> from something else, then you explicitly don&#39;t want anything earlier to respond to it, because it would just create an endless cycle, which you need to detect and halt.</p>

</div></div>

<div><div>

<p>R3F introduces a declarative model on top, but can&#39;t fundamentally fix this. In fact it adds a few new problems of it own in trying to bridge the two worlds. The details are boring and too specific to dig into, but let&#39;s just say it took me a while to realize why my objects were moving around whenever I did a hot-reload, because the second render is not at all the same as the first.</p>

<p>Yet this is exactly what one-way data flow in reactive frameworks is meant to address. It creates a fundamental distinction between the two directions: cascading down (derived state) vs cascading up (user interactions). Instead of routing both through the same mutable objects, it creates a one-way reverse-path too, triggered only in specific circumstances, so that cause and effect are always unambigious, and cycles are impossible.</p>

<p>Three.js is good for classic 3D. But if you&#39;re trying to build applications with R3F it feels fragile, like there&#39;s something fundamentally wrong with it, that they&#39;ll never be able to fix. The big lesson is this: for code to be truly declarative, changes must not be allowed to travel backwards. They must also be resolved consistently, in one big pass. Otherwise it leads to endless bug whack-a-mole.</p>

<p>What reactivity really does is take cache invalidation, said to be the hardest problem, and turn the problem itself into the solution. You never invalidate a cache without immediately refreshing it, and you make that the sole way to cause anything to happen at all. Crazy, and yet it works.</p>

<p>When I tell people this, they often say <i>&#34;well, it might work well for your domain, but it couldn&#39;t possibly work for mine.&#34;</i> And then I show them how to do it.</p>

<p>
<img src="https://acko.net/files/use-gpu-goes-trad/axes.png" alt="a cubemap with 3 axes"/>
</p><p><i>Figuring out which way your cube map points:</i></p>


<h2>And... Scene</h2>

<p>One of the cool consequences of this architecture is that even the most traditional of constructs can suddenly bring neat, Lispy surprises.</p>

<p>The new scene system is a great example. Contrary to most other engines, it&#39;s actually entirely optional. But that&#39;s not the surprising part.</p>

<p>Normally you just have a tree where nodes contain other nodes, which eventually contain meshes, like this:</p>

<pre><code>&lt;Scene&gt;
  &lt;Node matrix={...}&gt;
    &lt;Mesh&gt;
    &lt;Mesh&gt;
  &lt;Node matrix={...}&gt;
    &lt;Mesh&gt;
    &lt;Node matrix={...}&gt;
      &lt;Mesh&gt;
      &lt;Mesh&gt;
</code></pre>


<p>It&#39;s a way to compose matrices: they cascade and combine from parent to child. The 3D engine is then built to efficiently traverse and render this structure.</p>

<p>But what it ultimately does is define a transform for every mesh: a function <code>vec3 =&gt; vec3</code> that maps one vertex position to another. So if you squint, <code>&lt;Mesh&gt;</code> is really just a marker for a place where you <i>stop</i> composing matrices and pass a composed matrix transform <i>to</i> something else.</p>

<p>Hence Use.GPU&#39;s equivalent, <code>&lt;Primitive&gt;</code>, could actually be called <code>&lt;Unscene&gt;</code>. What it does is <i>escape</i> from the scene model, mirroring the Lisp pattern of quote-unquote. A chain of <code>&lt;Node&gt;</code> parents is just a domain-specific-language (DSL) to produce a <code>TransformContext</code> with a shader function, one that applies a single combined matrix transform.</p>

<p>In turn, <code>&lt;Mesh&gt;</code> just becomes a combination of <code>&lt;Primitive&gt;</code> and a <code>&lt;FaceLayer&gt;</code>, i.e. triangle geometry that uses the transform. It all composes cleanly.</p>

<p>So if you just put meshes inside the scene tree, it works exactly like a traditional 3D engine. But if you put, say, a polar coordinate plot in there from the <a href="https://usegpu.live/docs/reference-live-@use-gpu-plot" target="_blank">plot</a> package, which is not a matrix transform, inside a primitive, then it will still compose cleanly. It will combine the transforms into a new shader function, and apply it to whatever&#39;s inside. You can unscene and scene repeatedly, because it&#39;s just exiting and re-entering a DSL.</p>

<p>In 3D this is complicated by the fact that tangents and normals transform differently from vertices. But, this was already addressed in 0.7 by pairing each transform with a differential function, and using shader fu to compose it. So this all just keeps working.</p>

<p>Another neat thing is how this works with instancing. There is now an <code>&lt;Instances&gt;</code> component, which is exactly like <code>&lt;Mesh&gt;</code>, except that it gives you a dynamic <code>&lt;Instance&gt;</code> to copy/paste via a render prop:</p>

<pre><code>&lt;Instances
   mesh={mesh}
   render={(Instance) =&gt; (&lt;&gt;
     &lt;Instance position={[1, 2, 3]} /&gt;
     &lt;Instance position={[3, 4, 5]} /&gt;
   &lt;/&gt;)
 /&gt;
</code></pre>


<p>As you might expect, it will gather the transforms of all instances, stuff all of them into a single buffer, and then render them all with a single draw call. The neat part is this: you can still wrap individual <code>&lt;Instance&gt;</code> components in as many <code>&lt;Node&gt;</code> levels as you like. Because all <code>&lt;Instance&gt;</code> does is pass its matrix transform back up the tree to the parent it belongs to.</p>

</div></div>

<div><p><img src="https://acko.net/files/use-gpu-goes-trad/instance-capture.png" alt="instance capture"/>
</p></div>

<div><p>This is done using Live captures, which are React context providers in reverse. It doesn&#39;t violate one-way data flow, because captures will only run after all the children have finished running. Captures already worked previously, the semantics were just extended and formalized in 0.8 to allow this to compose with other reduction mechanisms.</p></div>

<div><p>But there&#39;s more. Not only can you wrap <code>&lt;Instance&gt;</code> in <code>&lt;Node&gt;</code>, you can also wrap either of them in <code>&lt;Animate&gt;</code>, which is Use.GPU&#39;s keyframe animator, entirely unchanged since 0.7:</p></div>



<div><div>
  <p>
  <iframe src="https://www.youtube.com/embed/Qt0na-lTt-0" frameborder="0" allowfullscreen="allowfullscreen"></iframe>
  </p>
</div></div>



<div><div>

<pre><code>&lt;Instances
  mesh={mesh}
  render={(Instance) =&gt; (

    &lt;Animate
      prop=&#34;rotation&#34;
      keyframes={ROTATION_KEYFRAMES}
      loop
      ease=&#34;cosine&#34;
    &gt;
      &lt;Node&gt;
        {seq(20).map(i =&gt; (
          &lt;Animate
            prop=&#34;position&#34;
            keyframes={POSITION_KEYFRAMES}
            loop
            delay={-i * 2}
            ease=&#34;linear&#34;
          &gt;
            &lt;Instance
              rotation={[
                Math.random()*360,
                Math.random()*360,
                Math.random()*360,
              ]}
              scale={[0.2, 0.2, 0.2]}
            /&gt;
          &lt;/Animate&gt;
        ))}
      &lt;/Node&gt;
    &lt;/Animate&gt;

  )}
/&gt;
</code></pre>


<p>The scene DSL and the instancing DSL and the animation DSL all compose directly, with nothing up my sleeve. Each of these <code>&lt;Components&gt;</code> are still just ordinary functions. On the inside they look like constructors with all the other code missing. There is zero special casing going on here, and none of them are explicitly walking the tree to reach each other. The only one doing that is the reactive run-time... and all it does is enforce one-way data flow by calling functions, gathering results and busting caches in tree order. Because a capture is a long-distance yeet.</p>

<p>Personally I find this pretty magical. It&#39;s not as efficient as a hand-rolled scene graph with instancing and built-in animation, but in terms of coding lift it&#39;s literally <code>O(0)</code> instead of OO. I needed to add <i>zero</i> lines of code to any of the 3 sub-systems, in order to combine them into one spinning whole.</p>

<p>The entire <a href="https://usegpu.live/docs/reference-live-@use-gpu-scene" target="_blank">scene + instancing</a> package clocks in at about 300 lines and that&#39;s including empties and generous formatting. I don&#39;t need to architect the rest of the framework around a base <code>Object3D</code> class that everything has to inherit from either, which is a-ok in my book.</p>

<p>This architecture will never reach Unreal or Unity levels of hundreds of thousands of draw calls, but then, it&#39;s not meant to do that. It embraces the idea of a unique shader for every draw call, and then walks that back if and when it&#39;s useful. The prototype <a href="https://usegpu.live/docs/reference-live-@use-gpu-map" target="_blank">map</a> package for example does this, and can draw a whole 3D vector globe in 2 draw calls: fill and stroke. Adding labels would make it 3. And it&#39;s not static: it&#39;s doing the usual quad-tree of LOD&#39;d mercator map tiles.</p>

</div></div>





<div><div>
  <p>
  <iframe src="https://www.youtube.com/embed/bTiOoB2S7U4" frameborder="0" allowfullscreen="allowfullscreen"></iframe>
  </p>
</div></div>



<div><div>
  
<h2>Multi-Pass</h2>

<p>Next up, the modular renderer passes. Architecturally and reactively-speaking, there isn&#39;t much here. This was mainly an exercise in slicing apart the existing glue.</p>

<p>The key thing to grok is that in Use.GPU, the <code>&lt;Pass&gt;</code> component does not correspond to a literal GPU render pass. Rather, it&#39;s a virtual, logical render pass. It represents all the work needed to draw some geometry to a screen or off-screen buffer, in its fully shaded form. This seems like a useful abstraction, because it cleanly separates the nitty gritty rendering from later compositing (e.g. overlays).</p>

<p>For the forward renderer, this means first rendering a few shadow maps, and possibly rendering a picking buffer for interaction. For the deferred renderer, this involves rendering the g-buffer, stencils, lights, and so on.</p>

<p>My goal was for the toggle between the two to be as simple as replacing a <code>&lt;ForwardRenderer&gt;</code> with a <code>&lt;DeferredRenderer&gt;</code>... but also to have both of those be flexible enough that you could potentially add on, say, SSAO, or bloom, or a Space Engine-style black hole, as an afterthought. And each <code>&lt;Pass&gt;</code> can have its own renderer, rather than shoehorning everything into one big engine.</p>

<p>Neatly, that&#39;s mostly what it is now. The basic principle rests on three pillars.</p>

</div></div>

<div><div>
  <p><img src="https://acko.net/files/use-gpu-goes-trad/tree-deferred.png" alt="deferred renderer"/></p><p><i>Deferred rendering</i></p>
</div></div>

<div><div>

<p>First, there are a few different rendering modes, by default <code>solid</code> vs <code>shaded</code> vs <code>ui</code>. These define what kind of information is needed at every pixel, i.e. the classic <i>varying</i> attributes. But they have no opinion on where the data comes from or what it&#39;s used for: that&#39;s defined by the geometry layer being rendered. It renders a <code>&lt;Virtual&gt;</code> draw call, which it gives e.g. a <code>getVertex</code> and <code>getFragment</code> shader function with a particular signature for that mode. These functions are not complete shaders, just the core functions, which are linked into a stub. There are a few standard &#39;tropes&#39; used here, not just these two.</p>

<p>Second, there are a few different rendering buckets, like <code>opaque</code>, <code>transparent</code>, <code>shadow</code>, <code>picking</code> and <code>debug</code>. These are used to group draws into. Different GPU render passes then pick and choose from that. <code>opaque</code> and <code>transparent</code> are drawn to the screen, while <code>shadow</code> is drawn repeatedly into all the shadow maps. This includes sorting front-to-back and back-to-front, as well as culling.</p>

<p>Finally, there&#39;s the renderer itself (<code>forward</code> vs <code>deferred</code>), and its associated pass components (e.g. <code>&lt;ColorPass&gt;</code>, <code>&lt;ShadowPass&gt;</code>, <code>&lt;PickingPass&gt;</code>, and so on). The renderer decides how to translate a particular &#34;mode + bucket&#34; combination into a concrete draw call, by lowering it into render components (e.g. <code>&lt;ShadedRender&gt;</code>). The pass components decide which buffer to actually render stuff to, and how. So the renderer itself doesn&#39;t actually render, it merely spawns and delegates to other components that do.</p>

</div></div>

<div><div>

<p>The forward path works mostly the same as before, only the culling and shadow maps are new... but it&#39;s now split up into all its logical parts. And I verified this design by adding the deferred renderer, which is a lot more convoluted, but still needs to do some forward rendering.</p>

<p>It works like a treat, and they use all the same lighting shaders. You can extend any of the 3 pillars just by replacing or injecting a new component. And you don&#39;t need to fork either renderer to do so: you can just pick and choose à la carte by selectively overriding or extending its &#34;mode + bucket&#34; mapping table, or injecting a new actual render pass.</p>

</div></div>





<div><div>
  <p>
  <iframe src="https://www.youtube.com/embed/hIBIlf28dxE" frameborder="0" allowfullscreen="allowfullscreen"></iframe>
  </p>
</div></div>



<div><div>

<p>To really put a bow on top, I upgraded the Use.GPU inspector so that you can directly view any render target in a RenderDoc-like way. This will auto-apply useful colorization shaders, e.g. to visualize depth. This is itself implemented as a Use.GPU Live canvas, sitting inside the HTML-based inspector, sitting on top of Live, which makes this a Live-in-React-in-Live scenario.</p>

<p>For shits and giggles, you can also inspect the inspector&#39;s canvas, recursively, ad infinitum. Useful for debugging the debugger:</p>

</div></div>

<div><p>
<img src="https://acko.net/files/use-gpu-goes-trad/inspect-inspect.png" alt="inspecting the inspector"/>
</p></div>

<div><div>

<p>There are still of course some limitations. If, for example, you wanted to add a new light type, or add support for volumetric lights, you&#39;d have to reach in more deeply to make that happen: the resulting code needs to be tightly optimized, because it runs per pixel and per light. But if you do, you&#39;re still going to be able to reuse 90% of the existing components as-is.</p>

<p>I do want a more comprehensive set of light types (e.g. line and area), I just didn&#39;t get around to it. Same goes for motion vectors and TXAA. However, with WebGPU finally nearing public release, maybe people will actually help out. Hint hint.</p>

</div></div>





<div><div>
  <p>
  <iframe src="https://www.youtube.com/embed/LQIZaMeQSqY" frameborder="0" allowfullscreen="allowfullscreen"></iframe>
  </p>
  
  <p><i>Port of a Reaction Diffusion system by <a href="http://twitter.com/flexi23" target="_blank">Felix Woitzel</a>.</i></p>
</div></div>



<div><div>

<h2>A Clusterfuck of Textures</h2>

<p>A final thing to talk about is 2D image effects and how they work. Or rather, the way they don&#39;t work. It seems simple, but in practice it&#39;s kind of ludicrous.</p>

<p>If you&#39;d asked me a year ago, I&#39;d have thought a very clean, composable post-effects pipeline was entirely within reach, with a unified API that mostly papered over the difference between compute and render. Given that I can link together all sorts of crazy shaders, this ought to be doable.</p>

<p>Well, I did upgrade the built-in fullscreen conveniences a bit, so that it&#39;s now easier to make e.g. a reaction diffusion sim like this (<a href="https://gitlab.com/unconed/use.gpu/-/blob/master/packages/app/src/pages/rtt/multiscale.tsx" target="_blank">full code</a>):</p>

<p>
<img src="https://acko.net/files/use-gpu-goes-trad/rtt.png" alt="multiple render-to-texture pipelines"/>
</p>

<p>The devil here is in the details. If you want to process 2D images on a GPU, you basically have several choices:</p>

<ul>
<li>Use a compute shader or render shader?</li>
<li>Which pixel format do you use?</li>
<li>Are you sampling one flat image or a MIP pyramid of pre-scaled copies?</li>
<li>Are you sampling color images, or depth/stencil images?</li>
<li>Use hardware filtering or emulate filtering in software?</li>
</ul>

<p>The big problem is that there is no single approach that can handle all cases. Each has its own quirks. To give you a concrete example: if you wrote a float16 reaction-diffusion sim, and then decided you actually needed float32, you&#39;d probably have to rewrite all your shaders, because float16 is always renderable and hardware filterable, but float32 is not.</p>

<p>Use.GPU has a pretty nice set of Compute/Stage/Kernel components, which are elegant on the outside; but they require you to write <a href="https://gitlab.com/unconed/use.gpu/-/blob/master/packages/app/src/pages/rtt/cfd-compute/mccormack.wgsl#L34" target="_blank">pretty gnarly shader code</a> to actually use them. On the other side are the RenderToTexture/Pass/FullScreen components which conceptually do the same thing, and have much nicer shader code, but which don&#39;t work for a lot of scenarios. All of them can be broken by doing something seemingly obvious, that just isn&#39;t natively supported and difficult to check ahead of time.</p>

<p>Even just producing universal code to <i>display</i> any possible texture type on screen becomes a careful exercise in code-generation. If you&#39;re familiar with the history of these features, it&#39;s understandable how it got to this point, but nevertheless, the resulting API is abysmal to use, and is a never-ending show of surprise pitfalls.</p>

<p>Here&#39;s a non-exhaustive list of quirks:</p>

<ul>
<li>Render shaders are the simplest, but can only be used to write those pixel formats that are &#34;renderable&#34;.</li>
<li>Compute shaders must be dispatched in groups of N, even if the image size is not a multiple of N. You have to manually trim off the excess threads.</li>
<li>Hardware filtering only works on some formats, and some filtering functions only work in render shaders.</li>
<li>Hardware filtering (fast) uses [0..1] UV float coordinates, software emulation in a shader (slow) uses [0..N] XY uint coordinates.</li>
<li>Reading and writing from/to the same render texture is not allowed, you have to bounce between a read and write buffer.</li>
<li>Depth+stencil images have their own types and have an additional notion of &#34;aspect&#34; to select one or both.</li>
<li>Certain texture functions cannot be called conditionally, i.e. inside an <code>if</code>.</li>
<li>Copying from one texture to another doesn&#39;t work between certain formats and aspects.</li>
</ul>

<p>My strategy so far has been to try and stick to native WGSL semantics as much as possible, meaning the shader code you do write gets inserted pretty much verbatim. But if you wanted to paper over all these differences, you&#39;d have to invent a whole new shader dialect. This is a huge effort which I have not bothered with. As a result, compute vs render pretty much have to remain separate universes, even when they&#39;re doing 95% the same thing. There is also no easy way to explain to users which one they ought to use.</p>

<p>While it&#39;s unrealistic to expect GPU makers to support every possible format and feature on a fast path, there is little reason why they can&#39;t just pretend a little bit more. If a texture format isn&#39;t hardware filterable, somebody will have to emulate that in a shader, so it may as well be done once, properly, instead of in hundreds of other hand-rolled implementations.</p>

<p>If there is one overarching theme in this space, it&#39;s that limitations and quirks continue to be offloaded directly onto application developers, often with barely a shrug. To make matters worse, the &#34;next gen&#34; APIs like Metal and Vulkan, which WebGPU inherits from, do not improve this. They want you to become an expert at their own kind of busywork, instead of getting on with your own.</p>

<p>I can understand if the WebGPU designers have looked at the resulting venn-diagram of poorly supported features, and have had to pick their battles. But there&#39;s a few absurdities hidden in the API, and many non-obvious limitations, where the API spec suggests you can do a lot more than you actually can. It&#39;s a very mixed bag all things considered, and in certain parts, plain retarded. Ask me about <i>minimum binding size</i>. No wait, don&#39;t.</p>

<p>* * *</p>

<p>Most promising is that as Use.GPU grows to do more, I&#39;m not touching extremely large parts of it. This to me is the sign of good architecture. I also continue to focus on specific use cases to validate it all, because that&#39;s the only way I know how to do it well.</p>

<p>There are some very interesting goodies lurking inside too. To give you an example... that R3F client app I mentioned at the start. It leverages Use.GPU&#39;s <a href="https://usegpu.live/docs/reference-live-@use-gpu-state" target="_blank">state</a> package to implement a universal undo/redo system in 130 lines. A JS patcher is very handy to wrangle the WebGPU API&#39;s deep argument style, but it can do a lot more.</p>

<p>One more thing. As a side project to get away from the core architecting, I made a viewer for levels for Dark Engine games, i.e. Thief 1 (1998), System Shock 2 (1999) and Thief 2 (2000). I want to answer a question I&#39;ve had for ages: how would those light-driven games have looked, if we&#39;d had better lighting tech back then? So it actually relights the levels. It&#39;s still a work in progress, and so far I&#39;ve only done slow-ass offline CPU bakes with it, using a BSP-tree based raytracer. But it works like a treat.</p>

</div></div>



<div><div>
  <p>
  <iframe src="https://www.youtube.com/embed/wYAlkjNbEjk" frameborder="0" allowfullscreen="allowfullscreen"></iframe>
  </p>
</div></div>



<div><div>

<p>I basically don&#39;t have to do any heavy lifting if I want to draw something, be it normal geometry, in-place data/debug viz, or zoomable overlays. Integrating old-school lightmaps takes about 10 lines of shader code and 10 lines of JS, and the rest is off-the-shelf Use.GPU. I can spend my cycles working on the problem I actually want to be working on. That to me is the real value proposition here.</p>

<p>I&#39;ve noticed that when you present people with refined code that is extremely simple, they often just do not believe you, or even themselves. They assume that the only way you&#39;re able to juggle many different concerns is through galaxy brain integration gymnastics. It&#39;s really quite funny. They go looking for the complexity, and they can&#39;t find it, so they assume they&#39;re missing something really vital. The realization that it&#39;s simply not there can take a very long time to sink in.</p>

<p><i>Visit <a href="https://usegpu.live" target="_blank">usegpu.live</a> for more and to <a href="https://usegpu.live/demo/index.html">view demos</a> in a WebGPU capable browser</i>.</p>

</div></div>


  

  
</article></div>
  </body>
</html>
