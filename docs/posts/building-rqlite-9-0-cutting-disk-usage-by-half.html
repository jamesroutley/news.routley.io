<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.philipotoole.com/building-rqlite-9-0-cutting-disk-usage-by-half/">Original</a>
    <h1>Building rqlite 9.0: Cutting disk usage by half</h1>
    
    <div id="readability-page-1" class="page"><div>
		<p><a href="https://rqlite.io" target="_blank" rel="noopener noreferrer"><img src="https://www.philipotoole.com/wp-content/uploads/2016/04/j.png" alt="" width="131" height="126"/></a><a href="https://www.rqlite.io" target="_blank" rel="noopener noreferrer">rqlite</a> is a lightweight, <a href="https://github.com/rqlite/rqlite" target="_blank" rel="noopener noreferrer">open-source</a>, distributed relational database written in <a href="https://golang.org" target="_blank" rel="noopener noreferrer">Go</a>,  built on <a href="https://raft.github.io/" target="_blank" rel="noopener noreferrer">Raft consensus protocol</a>, and uses <a href="http://sqlite.com" target="_blank" rel="noopener noreferrer">SQLite</a> as its storage engine.</p>
<p><a href="https://github.com/rqlite/rqlite/tree/referential-snapshot" target="_blank" rel="noopener noreferrer">Development of 9.0 has started</a>, with the main goal of reducing disk usage by approximately 50%. This goal will be achieved through a high-level design overhaul targeting the primary causes of disk consumption in rqlite.</p>

<h2>What drives current disk usage?</h2>
<p>Today, rqlite’s disk space usage is driven by three main factors:</p>
<ol>
<li><strong>Raft Log:</strong> The log of changes made to the system. This log is at the core of the Raft.</li>
<li><strong>Working SQLite Database:</strong> The live database that rqlite uses to serve reads and writes. Once a SQLite statement is <a href="https://thesecretlivesofdata.com/raft/" target="_blank" rel="noopener noreferrer">successfully committed to the Raft log</a>, that statement is applied to the working SQLite database.</li>
<li><strong>A snapshot of the working SQLite Database:</strong> To prevent the Raft log growing without bound, the Raft subsystem within rqlite periodically <a href="https://youtu.be/8XbxQ1Epi5w?t=449" target="_blank" rel="noopener noreferrer">generates</a> and stores a point-in-time copy of the working SQLite database – this copy is known as a <em>snapshot</em>. Once the snapshot is taken rqlite can then <em>truncate the Raft log</em>. This <em>snapshotted</em> copy can then be used by rqlite to restore a node when it restarts, or when a another node needs to “catch up” with the state of an existing rqlite cluster. Snapshotting and Log Truncation are core concepts in Raft based systems.</li>
</ol>
<h2>High-Level Design for rqlite 9.0</h2>
<p>The key strategy for reducing disk usage involves removing the need to store the <em>snapshotted</em> copy of the working SQLite database in the Raft system. While the Raft log is periodically truncated and stops growing after a certain point due to snapshotting, the working SQLite database continues to grow as more data is written to it. And since the snapshot copy of the SQLite database is roughly the same size as the working SQLite database it too grows in size. So if we could eliminate the Snapshot copy, rqlite would use 50% less disk.</p>
<p><img src="https://www.philipotoole.com/wp-content/uploads/2024/08/rqlite-snapshot.png" alt="" width="150" height="140" srcset="https://www.philipotoole.com/wp-content/uploads/2024/08/rqlite-snapshot.png 360w, https://www.philipotoole.com/wp-content/uploads/2024/08/rqlite-snapshot-300x281.png 300w" sizes="(max-width: 150px) 100vw, 150px"/></p>
<p>However, an rqlite node  needs a snapshotted copy at certain points — this cannot be avoided. So how do we avoid the copy, but still meet the needs of <em>Snapshot and Restore</em>? The key thing to understand in this new approach is that the working SQLite database file — <strong>ignoring its associated WAL file — </strong>and the snapshotted copy in the Raft system are logically the same thing. So can we use this fact to avoid storing a snapshotted copy in the first place?<strong><br/>
</strong></p>
<h3>Step-by-step</h3>
<p>Let’s look at how snapshotting will work in 9.0, and see if we can understand why the working SQLite file can also serve as the copy needed by the Raft Snapshot store.</p>
<ol>
<li><strong>Snapshot and WAL Checkpointing:</strong> At snapshot time, rqlite will checkpoint the <a href="https://www.sqlite.org/wal.html" target="_blank" rel="noopener noreferrer">Write-Ahead Log (WAL)</a> of the working SQLite database. All subsequent writes will then be directed to a <strong>newly-created</strong> WAL file (thanks to the way WAL-mode SQLite operates) — this leaves the main SQLite file unchanged from the point at which the Snapshot was generated . Therefore  — until the next Snapshot takes place — the main SQLite file <strong>is</strong> the point-in-time state that the Raft Snapshot store requires. <strong>It is this insight</strong> that allows us to use the combined SQLite file <strong>and</strong> WAL file to serve reads and writes as usual, but use just the SQLite file to serve as the data the Raft Snapshot store needs. No more need for an extra copy!</li>
<li><strong>Write a <em>Reference</em> to Snapshot Store:</strong> Instead of copying the entire SQLite file, rqlite will write a <em>Reference</em>, such as a checksum, to the Snapshot store. This <em>Reference</em> can be used to validate that the main SQLite file matches what the Snapshot store references, whenever snapshot data is needed. (This check protects against bugs, operational mistakes, or disk corruption but isn’t strictly needed.)</li>
<li><strong>Restoration from Snapshot:</strong> As explained above, because all writes after the snapshot process are written to the WAL file, the main SQLite file remains ready for reading by the <em>Restore-from-Snapshot</em> process if needed (e.g., during a node restart or when transferring the snapshot to another node). In other words the main SQLite file (again, ignoring its associated WAL file) remains logically the same as what would have been written to the Raft snapshot store, if rqlite actually wrote that copy.</li>
</ol>
<p>I call this new design <em>Referential Snapshotting</em>.</p>
<h3>Bonus Enhancements</h3>
<p><em>Referential Snapshotting</em> will actually result in a couple of other high-impact improvements.</p>
<ul>
<li><strong>Faster Snapshotting:</strong> By writing minimal data to the Raft Snapshot store, the snapshotting process will be much faster. It should consist of the SQLite WAL checkpointing time (which is usually very short) and the checksum computation time.  There will be no need to copy large amounts of SQLite data to the Snapshot store on every snapshot. When one realises that writes to rqlite are blocked during the Snapshot process, the advantages of faster snapshotting are clear.</li>
<li><strong>Improved Node Restart Times:</strong> Nodes, <a href="https://github.com/rqlite/rqlite/issues/1798" target="_blank" rel="noopener noreferrer">even those with multiple gigabytes of SQLite data</a>, will restart much, much faster. Currently, at restart, rqlite has to restore the working SQLite database file from the copy in Raft Snapshot Store. But with this new design, the working SQLite database file will already be in the correct place at start-up. At most, rqlite will only need to compare the checksum in the Snapshot store to the checksum of the working SQLite database. Multi-GB systems should restart within a few seconds.</li>
</ul>
<h3>Next Steps</h3>
<p>The move to rqlite 9.0 should make a significant step forward in optimizing the efficiency of rqlite. By implementing <em>Referential Snapshotting</em>, I expect to achieve significant reductions in disk usage, faster snapshotting, and improved node restart times.</p>
<p>There are many details to get right, including SQLite WAL management, seamless upgrades from earlier releases, and checksum choice. So stay tuned for further updates as we progress towards this major release.</p>
<p><em>If you’re interested in learning more about Raft and how it can be used to build distributed systems such as rqlite, <a href="https://www.youtube.com/watch?v=8XbxQ1Epi5w" target="_blank" rel="noopener noreferrer">check out my recent talk at GopherCon</a>.<br/>
</em></p>
	</div></div>
  </body>
</html>
