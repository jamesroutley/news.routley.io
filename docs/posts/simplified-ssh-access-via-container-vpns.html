<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://rgoswami.me/posts/remote-access-cvpn/">Original</a>
    <h1>Simplified SSH access via container VPNs</h1>
    
    <div id="readability-page-1" class="page"><div><div><p>This post is part of the <a href="https://rgoswami.me/series/remote-usage/">Remote Usage</a> series.</p></div><blockquote><p>Leveraging containers for streamlined remote interactive and mounted file access to intranet machines</p></blockquote><h2 id="background">Background</h2><p>Most academic or corporate networks gate access to internal resources (like
clusters or services) via their local intranet, requiring a VPN connection
(e.g., using Cisco AnyConnect, FortiGate). Connecting to such a VPN on a
personal machine typically routes all your internet traffic through that VPN.
This is useful for certain tasks like accessing paywalled journal articles via
university subscriptions, but it becomes problematic when:</p><ul><li>You only want some of your traffic to go through the VPN.</li><li>You need to connect to multiple distinct services, each behind its own
separate VPN. Managing these simultaneously or switching between them on a
host system is often cumbersome or impossible.</li></ul><p>These considerations not only affect interactive SSH sessions but also
complicates using tools for remote file management or other services that need
to operate through these VPNs.</p><h3 id="tools">Tools</h3><p>We’ll be using <a href="https://podman.io/">Podman</a> with <a href="https://www.infradead.org/openconnect/">OpenConnect</a> and <a href="https://www.openssh.com/">OpenSSH</a> to build a VPN jumphost for
simplified <code>ProxyJump</code> configurations and <a href="https://rclone.org/">rclone</a> for SFTP mounting.</p><h2 id="normal-usage">Normal usage</h2><p>To recap, the standard workflow, for say, an <code>anyconnect</code> VPN is as follows:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>1</span><span>sudo openconnect <span>$VPN</span> -u <span>$VUSER</span> --useragent AnyConnect
</span></span><span><span>2</span><span><span># Another terminal</span>
</span></span><span><span>3</span><span>ssh <span>$LMACHINE</span>
</span></span></code></pre></div><p>Where <code>LMACHINE</code> is normally only accessible from the intranet, access to which
is provided by <code>VPN</code> authenticated for <code>VUSER</code>. <code>sudo</code> is there since the
networking of the current machine, say <code>CMACHINE</code> is affected. This works, but
as noted has the side effect of routing the entire machine’s traffic
through the VPN. Trying to manage multiple such VPNs is difficult.</p><h3 id="caveats">Caveats</h3><dl><dt>Full Network Routing</dt><dd>Your entire machine’s internet usage goes through the VPN.</dd><dt>Multiple VPNs</dt><dd>Switching between VPNs is slow, and running multiple
simultaneously is generally not feasible.</dd><dt>Streamlining Access</dt><dd>Even with one VPN, accessing many internal machines via
direct SSH can be made more convenient with a jumphost and SSH’s ProxyJump
feature.</dd></dl><h2 id="container-setup">Container setup</h2><p>Containerization offers a powerful solution by isolating the VPN connection
within a dedicated environment, leaving your host system’s networking untouched.
This container can then act as a secure SSH jumphost.</p><p>A basic container using an Alpine base with a non-root user for this is
basically:</p><div><pre tabindex="0"><code data-lang="cfg"><span><span> 1</span><span><span>FROM alpine:latest</span>
</span></span><span><span> 2</span><span>
</span></span><span><span> 3</span><span><span>LABEL maintainer</span><span>=</span><span>&#34;rgoswami[at]ieee[dot]org&#34;</span>
</span></span><span><span> 4</span><span><span>LABEL description</span><span>=</span><span>&#34;Alpine jumphost: OpenConnect (interactive) as main process, OpenSSH server for ProxyJump.&#34;</span>
</span></span><span><span> 5</span><span>
</span></span><span><span> 6</span><span><span>ARG SSH_USER_NAME</span><span>=</span><span>jumphostuser</span>
</span></span><span><span> 7</span><span><span># It&#39;s safer to pass the public key content at build time than to have a default here that might be forgotten.</span>
</span></span><span><span> 8</span><span><span>ARG USER_PUBLIC_KEY</span>
</span></span><span><span> 9</span><span><span>ARG PASS</span><span>=</span><span>nothing</span>
</span></span><span><span>10</span><span>
</span></span><span><span>11</span><span><span># Install necessary packages</span>
</span></span><span><span>12</span><span><span>RUN apk add --no-cache \</span>
</span></span><span><span>13</span><span>    <span>tini \</span>
</span></span><span><span>14</span><span>    <span>openconnect \</span>
</span></span><span><span>15</span><span>    <span>openssh \</span>
</span></span><span><span>16</span><span>    <span>openssh-server \</span>
</span></span><span><span>17</span><span>    <span>bash \</span>
</span></span><span><span>18</span><span>    <span>ca-certificates</span>
</span></span><span><span>19</span><span>
</span></span><span><span>20</span><span><span># Create a non-root user for SSH connections INTO the container</span>
</span></span><span><span>21</span><span><span># The password isn&#39;t really ever required, but causes an error without it</span>
</span></span><span><span>22</span><span><span>RUN adduser -g &#34;${SSH_USER_NAME}&#34; -D -s /bin/bash &#34;${SSH_USER_NAME}&#34; &amp;&amp; \</span>
</span></span><span><span>23</span><span>    <span>echo &#34;${SSH_USER_NAME}:$(openssl passwd -1 $PASS)&#34; | chpasswd</span>
</span></span><span><span>24</span><span>
</span></span><span><span>25</span><span><span># Setup SSH for this user using the public key provided at build time</span>
</span></span><span><span>26</span><span><span>RUN mkdir -p &#34;/home/${SSH_USER_NAME}/.ssh&#34; &amp;&amp; \</span>
</span></span><span><span>27</span><span>    <span>chmod 700 &#34;/home/${SSH_USER_NAME}/.ssh&#34; &amp;&amp; \</span>
</span></span><span><span>28</span><span>    <span>echo &#34;${USER_PUBLIC_KEY}&#34; &gt; &#34;/home/${SSH_USER_NAME}/.ssh/authorized_keys&#34; &amp;&amp; \</span>
</span></span><span><span>29</span><span>    <span>chmod 600 &#34;/home/${SSH_USER_NAME}/.ssh/authorized_keys&#34; &amp;&amp; \</span>
</span></span><span><span>30</span><span>    <span>chown -R &#34;${SSH_USER_NAME}:${SSH_USER_NAME}&#34; &#34;/home/${SSH_USER_NAME}/.ssh&#34;</span>
</span></span><span><span>31</span><span>
</span></span><span><span>32</span><span><span># Configure SSHD for security and ProxyJump functionality</span>
</span></span><span><span>33</span><span><span>RUN sed -i &#39;s/^#?PermitRootLogin.*/PermitRootLogin no/&#39; /etc/ssh/sshd_config &amp;&amp; \</span>
</span></span><span><span>34</span><span>    <span>sed -i &#39;s/^#?PasswordAuthentication.*/PasswordAuthentication yes/&#39; /etc/ssh/sshd_config &amp;&amp; \</span>
</span></span><span><span>35</span><span>    <span>sed -i &#39;s/^#?PubkeyAuthentication.*/PubkeyAuthentication yes/&#39; /etc/ssh/sshd_config &amp;&amp; \</span>
</span></span><span><span>36</span><span>    <span>\</span>
</span></span><span><span>37</span><span>    <span># Robustly set AllowTcpForwarding to yes</span>
</span></span><span><span>38</span><span>    <span>sed -i &#39;/^#\?AllowTcpForwarding.*/d&#39; /etc/ssh/sshd_config &amp;&amp; \</span>
</span></span><span><span>39</span><span>    <span>echo &#34;AllowTcpForwarding yes&#34; &gt;&gt; /etc/ssh/sshd_config &amp;&amp; \</span>
</span></span><span><span>40</span><span>    <span>\</span>
</span></span><span><span>41</span><span>    <span>sed -i &#39;/^#\?AllowAgentForwarding.*/d&#39; /etc/ssh/sshd_config &amp;&amp; \</span>
</span></span><span><span>42</span><span>    <span>echo &#34;AllowAgentForwarding yes&#34; &gt;&gt; /etc/ssh/sshd_config &amp;&amp; \</span>
</span></span><span><span>43</span><span>    <span>\</span>
</span></span><span><span>44</span><span>    <span>sed -i &#39;/^#\?GatewayPorts.*/d&#39; /etc/ssh/sshd_config &amp;&amp; \</span>
</span></span><span><span>45</span><span>    <span>echo &#34;GatewayPorts no&#34; &gt;&gt; /etc/ssh/sshd_config &amp;&amp; \</span>
</span></span><span><span>46</span><span>    <span>\</span>
</span></span><span><span>47</span><span>    <span>sed -i &#39;/^#\?UsePAM.*/d&#39; /etc/ssh/sshd_config &amp;&amp; \</span>
</span></span><span><span>48</span><span>    <span>echo &#34;UsePAM no&#34; &gt;&gt; /etc/ssh/sshd_config &amp;&amp; \</span>
</span></span><span><span>49</span><span>    <span>echo &#34;ChallengeResponseAuthentication no&#34; &gt;&gt; /etc/ssh/sshd_config &amp;&amp; \</span>
</span></span><span><span>50</span><span>    <span>\</span>
</span></span><span><span>51</span><span>    <span>echo &#34;ClientAliveInterval 60&#34; &gt;&gt; /etc/ssh/sshd_config &amp;&amp; \</span>
</span></span><span><span>52</span><span>    <span>echo &#34;ClientAliveCountMax 3&#34; &gt;&gt; /etc/ssh/sshd_config &amp;&amp; \</span>
</span></span><span><span>53</span><span>    <span>echo &#34;LogLevel DEBUG3&#34; &gt;&gt; /etc/ssh/sshd_config</span>
</span></span><span><span>54</span><span>
</span></span><span><span>55</span><span><span># Generate SSH host keys if they don&#39;t exist</span>
</span></span><span><span>56</span><span><span>RUN ssh-keygen -A</span>
</span></span><span><span>57</span><span>
</span></span><span><span>58</span><span><span># Expose the SSH port</span>
</span></span><span><span>59</span><span><span>EXPOSE 22</span>
</span></span><span><span>60</span><span>
</span></span><span><span>61</span><span><span># Copy the entrypoint script into the image</span>
</span></span><span><span>62</span><span><span>COPY entrypoint.sh /usr/local/bin/entrypoint.sh</span>
</span></span><span><span>63</span><span><span>RUN chmod +x /usr/local/bin/entrypoint.sh</span>
</span></span><span><span>64</span><span>
</span></span><span><span>65</span><span><span># Use tini to manage the entrypoint script. The script itself runs as root.</span>
</span></span><span><span>66</span><span><span>ENTRYPOINT [&#34;/sbin/tini&#34;, &#34;--&#34;]</span>
</span></span><span><span>67</span><span><span>CMD [&#34;/usr/local/bin/entrypoint.sh&#34;]</span>
</span></span></code></pre></div><p>Normally, I’m a fan of using <code>tinyssh</code> <a href="https://theconversation.com/posts/tinyssh-dockerdev-env/">for basic containers</a> but since this is
meant to be a jump server, we need <code>AllowTcpForwarding</code> and so <code>openssh</code> is
simpler. Combined with this <code>entrypoint.sh</code>:</p><div><pre tabindex="0"><code data-lang="bash"><span><span> 1</span><span><span>#!/usr/bin/env sh
</span></span></span><span><span> 2</span><span><span></span>
</span></span><span><span> 3</span><span><span># Exit immediately if a command exits with a non-zero status</span>
</span></span><span><span> 4</span><span><span>set</span> -e
</span></span><span><span> 5</span><span>
</span></span><span><span> 6</span><span><span>echo</span> <span>&#34;Starting SSH daemon...&#34;</span>
</span></span><span><span> 7</span><span>/usr/sbin/sshd -e
</span></span><span><span> 8</span><span>
</span></span><span><span> 9</span><span><span>echo</span> <span>&#34;SSH daemon active. Starting OpenConnect interactively...&#34;</span>
</span></span><span><span>10</span><span><span>echo</span> <span>&#34;You will be prompted for your VPN password.&#34;</span>
</span></span><span><span>11</span><span>
</span></span><span><span>12</span><span><span># Now, execute OpenConnect in the foreground.</span>
</span></span><span><span>13</span><span><span># This script runs as root by default in Docker, which OpenConnect needs</span>
</span></span><span><span>14</span><span><span># to modify network routes and create the tun interface.</span>
</span></span><span><span>15</span><span><span># The --script flag is vital for DNS/routing updates.</span>
</span></span><span><span>16</span><span><span>exec</span> openconnect sample.vpnhost <span>\
</span></span></span><span><span>17</span><span><span></span>    -u me@sample.vpnhost <span>\
</span></span></span><span><span>18</span><span><span></span>    --useragent<span>=</span><span>&#39;AnyConnect&#39;</span> <span>\
</span></span></span><span><span>19</span><span><span></span>    --script<span>=</span>/etc/vpnc/vpnc-script
</span></span></code></pre></div><p>Here the command is hardcoded, but it can be adapted or parameterized via an
environment variable if required.</p><p>Built with:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>1</span><span><span># Remember to modify this for your key</span>
</span></span><span><span>2</span><span><span>export</span> <span>PUB_KEY_CONTENT</span><span>=</span><span>$(</span>cat ~/.ssh/cstuff.pub<span>)</span>
</span></span><span><span>3</span><span><span># Build the container called vpn-smart-jumphost</span>
</span></span><span><span>4</span><span>docker build <span>\
</span></span></span><span><span>5</span><span><span></span>  --build-arg <span>USER_PUBLIC_KEY</span><span>=</span><span>&#34;</span><span>$PUB_KEY_CONTENT</span><span>&#34;</span> <span>\
</span></span></span><span><span>6</span><span><span></span>  --build-arg <span>SSH_USER_NAME</span><span>=</span>jumphostuser <span>\
</span></span></span><span><span>7</span><span><span></span>  --pull <span>\
</span></span></span><span><span>8</span><span><span></span>  -t vpn-smart-jumphost:latest .
</span></span></code></pre></div><p>Which is subsequently run via:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>1</span><span>docker run --rm -it <span>\
</span></span></span><span><span>2</span><span><span></span>  --name vpn-smart-jump-container <span>\
</span></span></span><span><span>3</span><span><span></span>  --cap-add<span>=</span>NET_ADMIN <span>\
</span></span></span><span><span>4</span><span><span></span>  --device<span>=</span>/dev/net/tun:/dev/net/tun <span>\
</span></span></span><span><span>5</span><span><span></span>  -p 127.0.0.1:2200:22 <span>\
</span></span></span><span><span>6</span><span><span></span>  vpn-smart-jumphost:latest
</span></span></code></pre></div><p>This will prompt in the terminal for the VPN credentials, including an MFA if
necessary. The network within the container is now correctly connected through
to the VPN. Remember to keep this open as it maintains the VPN session (perhaps
using <code>tmux</code>).</p><h3 id="proxyjump-settings"><code>ProxyJump</code> settings</h3><p>For the SSH configuration now,</p><div><pre tabindex="0"><code data-lang="cfg"><span><span> 1</span><span><span>Host vpn-docker-jump</span>
</span></span><span><span> 2</span><span>    <span>HostName 127.0.0.1</span>
</span></span><span><span> 3</span><span>    <span>Port 2200</span>
</span></span><span><span> 4</span><span>    <span>User jumphostuser</span>
</span></span><span><span> 5</span><span>    <span>IdentitiesOnly yes</span>
</span></span><span><span> 6</span><span>    <span>IdentityFile ~/.ssh/cstuff</span>
</span></span><span><span> 7</span><span>
</span></span><span><span> 8</span><span><span>Host *.vpnhost !vpnhost</span>
</span></span><span><span> 9</span><span>    <span>User rgoswami</span>
</span></span><span><span>10</span><span>    <span>ProxyJump vpn-docker-jump</span>
</span></span><span><span>11</span><span>
</span></span><span><span>12</span><span><span>Host someone.cstuff</span>
</span></span><span><span>13</span><span>  <span>Hostname something.vpnhost</span>
</span></span><span><span>14</span><span>  <span>User rgoswami</span>
</span></span><span><span>15</span><span>  <span>ProxyJump vpn-docker-jump</span>
</span></span></code></pre></div><p>Replace <code>~/.ssh/cstuff</code> with the path to the private key that corresponds to the
public key you used during the build. Replace <code>rgoswami</code> with your username on
the target systems if it’s different.</p><h3 id="usage">Usage</h3><p>Once the container is running, the VPN is connected within it, and your
<code>~/.ssh/config</code> is set up, you can SSH to your remote machines from a new
terminal window on your host:</p><p>Or indeed, anything which matches <code>*.vpnhost</code>:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>1</span><span>ssh some-other-server.vpnhost
</span></span></code></pre></div><p>The first time you connect via the jumphost, you may be asked to verify and
accept the SSH host key of the container.</p><h2 id="mounting-sftp-remotes">Mounting SFTP Remotes</h2><p>The <code>ProxyJump</code> setup in <code>~/.ssh/config</code> is excellent for interactive SSH
sessions, <code>scp</code>, and direct <code>sftp</code> commands. However, for <code>rclone</code> (<a href="https://rclone.org/">homepage</a>),
which can mount a remote SFTP share, some more work is necessary for the VPN
jumphost.</p><p><code>rclone</code> can leverage SSH’s capabilities, but it does not parse directives from
the global SSH config directly.</p><p>We can achieve this by constructing an appropriate ProxyCommand and passing it
to rclone via its SFTP backend options.</p><div><pre tabindex="0"><code data-lang="bash"><span><span>1</span><span>ssh -o <span>&#34;ProxyCommand ssh jumphostuser@127.0.0.1 -p 2200 -i ~/.ssh/cosmolab -o IdentitiesOnly=yes -W %h:%p&#34;</span> <span>$USER</span>@<span>$VPN_HOSTNAME</span>
</span></span></code></pre></div><p>The ProxyCommand effectively tells SSH how to connect to the intermediate
jumphost first, and then tunnel the connection to the final SFTP server.</p><p>Essentially we have <code>rclone config edit</code> (followed by <code>n</code> and then <code>SFTP</code>) to
end up with:</p><dl><dt><strong>type</strong></dt><dd><code>sftp</code></dd><dt><strong>host</strong></dt><dd><code>$RCLONE_REMOTE</code></dd><dt><strong>user</strong></dt><dd><code>$USER</code></dd><dt><strong>pubkey_file</strong></dt><dd><code>$SSH_KEY</code></dd><dt><strong>key_use_agent</strong></dt><dd><code>true</code></dd><dt><strong>ssh</strong></dt><dd><code>ssh -o &#34;ProxyCommand ssh jumphostuser@127.0.0.1 -p 2200 -i ~/.ssh/cosmolab -o IdentitiesOnly=yes -W %h:%p&#34; $USER@$VPN_HOSTNAME</code></dd></dl><p>Final usage proceeds in the usual fashion:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>1</span><span>rclone mount <span>&#34;</span><span>$RCLONE_REMOTE</span><span>:/home/</span><span>$USER</span><span>&#34;</span> ~/mnt/somevpn --vfs-cache-mode full
</span></span></code></pre></div><p>Where <code>--vfs-cache-mode full</code> improves performance by caching files.</p><h2 id="conclusions">Conclusions</h2><p>This containerized approach provides an isolated VPN connection and a convenient
ProxyJump setup, allowing for more streamlined and targeted access to remote
networks without impacting your entire host’s networking. Remote file access via
<code>rclone</code> also works well. The principles can be adapted for other
OpenConnect-compatible VPNs by modifying the <code>openconnect</code> command in the
<code>entrypoint.sh</code> script (potentially using environment variables for server
addresses and usernames).</p><p>A more robust variant of the container images and workflow developed into the
<a href="https://github.com/HaoZeke/vpn-proxyjump">vpn-proxyjump</a> project.</p><hr/><div><h2>Series info</h2><h3>Remote Usage series</h3><ol><li><b>Simplified SSH access via container VPNs</b> &lt;-- You are here!</li></ol></div></div></div>
  </body>
</html>
