<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.beatworm.co.uk/blog/computers/perls-decline-was-cultural-not-technical">Original</a>
    <h1>Perl&#39;s decline was cultural</h1>
    
    <div id="readability-page-1" class="page"><div id="content">
			    <h3>According to the Discourse, somebody killed perl</h3><p>There&#39;s been a flurry of discussion <a href="https://news.ycombinator.com/item?id=45977900">on Hacker News</a> and <a href="https://lobste.rs/s/0m6yln/what_killed_perl">other tech forums</a> about what killed Perl. I wrote a lot of Perl in the mid 90s and subsequently worked on some of the most trafficked sites on the web in mod_perl in the early 2000s, so I have some thoughts. My take: it was mostly baked into the culture. Perl grew amongst a reactionary community with conservative values, which prevented it from evolving into a mature general purpose language ecosystem. Everything else filled the gap. </p><h3>I remember Perl</h3><p>Something to keep in mind, is that although this is my personal take, and therefore entirely an opinion piece, I <em>was</em> there at the time. I stopped doing Perl properly when I left Amazon, I think this would have been around 2005. It&#39;s based on the first hand impressions of somebody who was very deeply involved in Perl in its heyday, and moved on. I have a lot of experience, from both inside and outside the tent. </p><h3>Perl&#39;s roots are sysadmin</h3><p>What culture? Perl always had a significant amount of what you might call &#34;BOFH&#34; culture, which came from its old UNIX sysadmin roots. All of those passive aggressive idioms and in jokes like <em>&#34;RTFM&#34;</em>, <em>&#34;lusers&#34;</em>, <em>&#34;wizards&#34;</em>, <em>&#34;asking for help the wrong way&#34;</em> etc.  None of this is literally serious, but it does encode and inform social norms that are essentially tribal and introverted. There implicitly is a privileged population, with a cost of entry to join. Dues must be paid. Cultural conservatism as a first principle. </p><p>This stems from the old locked-down data centre command culture. When computer resource was expensive, centralised, fragile, and manually operated, it was rigidly maintained by gatekeepers, defending against inappropriate use. I started my career as an apprentice programmer at the very end of this era, (late 80s) pre-web, and before microcomputers had made much inroads, and this really was the prevailing view from inside the fort. (This is a drawback about fort-building. Once you live in a fort, it&#39;s slightly too easy to develop a siege mentality). Computers are special, users are inconvenient, disruption is the main enemy. </p><p>An unfortunate feedback loop in this kind of &#34;perilous&#34; environment is that it easily turns prideful. It&#39;s difficult to thrive here, if you survive and do well you are skilled; you&#39;ve performed feats; you <em>should</em> mark your rites of passage. This can become a dangerous culture trap. If you&#39;re not careful about it, you may start to think of the hazards and difficulties, the &#34;foot guns&#34;, as <em>necessary</em> features - they teach you those essential survival skills that mark you out. More unkindly, they keep the stupid folk out, and help preserve the high status of those who survived long enough to be assimilated. Uh-oh, now you&#39;ve invented class politics. </p><p>The problem with this thinking is that it&#39;s self-reinforcing. Working hard to master system complexities was genuinely rewarding - you really were doing difficult things and doing them well. This is actually the same mechanism behind what eventually became known as &#39;meritocracy&#39;<sup id="ref1"><a href="#fn1">1</a></sup>, but the core point is simpler - if difficulty itself becomes a badge of honour, you&#39;ve created a trap: anything that makes the system more approachable starts to feel like it&#39;s cheapening what you achieved. You become invested in preserving the barriers you overcame. </p><p>(This is the same mentality that built leetcode interview pipelines BTW, but let&#39;s leave that sidebar alone for now) </p><p>So the UNIX operator culture tended to operate as a tribal meritocracy (as opposed to the UNIX <em>implementer</em> culture, which fell out of a different set of cultural norms, quite an interesting side bar itself<sup id="ref2"><a href="#fn2">2</a></sup>), a cultural priesthood, somewhat self-regarding, rewarding of cleverness and knowledge hoarding, prone to feats of bravado, full of lore, with a defensive mentality of keeping the flame aloft, keeping the plebs happy and fed, and warding off the barbarians. As we entered the 90s it was already gently in decline, because centralised computing was giving way to the rise of the microcomputer, but the sudden explosive growth of the WWW pulled internet / Unix culture suddenly back into the mainstream with an enormous and public opportunity vacuum. Everyone suddenly has an urgent need to write programs that push text off UNIX file-systems (and databases) and into web pages, and Perl is uniquely positioned to have a strong first-mover advantage in this suddenly vital, novel ecosystem. But it&#39;s culture and values are very much pulled across from this previous era. </p><p>(Springing out of this, Perl had an, at best grudging, tolerance for &#39;difficult genius&#39; types, alongside this baseline culture. Unfortunately, this kind of toxic personality tends to thrive in the type of culture I&#39;ve described, and they do set to help the tone. I&#39;m not here to call out people specifically, because I&#39;m trying to make a point rather than feed a culture war, or dig up gossip, but there were several significant examples, you can probably find lore if you like. I think the kindest way I can describe the compounding effect of this is that there was a strong cultural norm along the lines of &#34;It&#39;s OK to be rude, as long as it&#39;s for a good cause&#34;.) </p><h3>A fort within a fort</h3><p>I remember this tension as always being tangibly there. Perl IRC and mailing lists were quite cliquey and full of venerated experts and in-jokes, rough on naivety, keen on robust, verbose debate, and a little suspicious of newcomers. And very cult-like. The &#34;<a href="https://perl.fandom.com/wiki/TIMTOWTDI">TIMTOWTDI</a>&#34; rule, although ostensibly liberal, literally means &#39;there is more than one way to do it <em>in Perl</em>&#39; - and you can perhaps infer from that that there&#39;s little to no reason to do it using anything else. Elevating extreme flexibility like this is paradoxically also an engine of conservatism. If Perl can already do anything, flexibly, in multiple ways, then the language itself doesn&#39;t need to change - &#39;we already have one of those here, we don&#39;t need new things&#39;. This attitude determined how Perl intended to handle evolution: the core language would remain stable (a fort inside a fort, only accessible to high level wizards), while innovation was pushed outward to CPAN. You could add features outside of core by writing and consuming third party libraries, you could bend language behaviour with pragmas without modifying Perl itself. The very best CPAN modules could theoretically be promoted into core, allowing the language to evolve conservatively from proven, widely-used features. </p><p>On paper, this sounds reasonable. In practice, I think it encoded a fundamental conflict of interest into the community early on, and set the stage for many of the later growth problems.  I&#39;m not going to pretend that Perl <em>invented</em> dependency hell, but I think it turned out to be another one of those profound misfeatures that their cultural philosophy lead them to mistake for virtue, and embrace. </p><p>An interesting thing I think has been missed discussing the context of the original blog piece, about whether Perl 6 significantly impacted Perl growth, is the fact that Perl 6 itself manifested out of ongoing arguments. Perl 6 is a schism. Here&#39;s a oft-cited note from Larry Wall himself about the incident that sparked Perl 6, at <strike> YAPC</strike>  <a href="https://whitecamel.org/p/jon_orwant.html">OSCON 2000</a> </p><blockquote><p>We spent the first hour gabbing about all sorts of political and organizational issues of a fairly boring and mundane nature. Partway through, Jon Orwant comes in, and stands there for a few minutes listening, and then he very calmly walks over to the coffee service table in the corner, and there were about 20 of us in the room, and he picks up a coffee mug and throws it against the other wall and he keeps throwing coffee mugs against the other wall, and he says &#34;we are f-ed unless we can come up with something that will excite the community, because everyone&#39;s getting bored and going off and doing other things&#34;. </p></blockquote><p>(Pause a second and ask yourself about the sort of social culture that both allows this kind of behaviour at public events, and then chooses to embrace it as a key piece of cultural lore) </p><h3>The impact of Perl 6</h3><p>Perl 6 was really a <em>schism</em>. Perl was already under a great amount of strain trying to accommodate the modernising influx of post dot-com mainstream web application building, alongside the entrenched conservatism of the core maintainers, and the maintenance burden of a few years exponential growth of third-party libraries, starting to build a fractal mess of slightly differentiating, incompatible approaches of those multiple ways to do things that were effectively now table-stakes language features, as the deployment landscape started to tiptoe towards a more modern, ubiquitous WWW<sup id="ref3"><a href="#fn3">3</a></sup>. </p><p>So, while I agree that it&#39;s wrong to generalise that &#39;Perl 6 killed Perl&#39;, I would say that Perl 6 was a symptom of the irreconcilable internal forces that killed Perl. Although, I also intend to go on to point out that Perl isn&#39;t dead, nothing has actually <em>killed</em> Perl. Killed Perl is a very stupid way to frame the discussion, but here we are. </p><p>So... Perl 6 is created as a valve to offset that pressure, and it kind of works. Up to a point. Unfortunately I think the side effect really is that the two branches of the culture, in the process of forking, double down on their encoded norms. Perl 5.x beds down as the practical, already solved way to do all the same things, with little need to change. Any requirements for more <em>modern</em> application patterns that are emerging in the broader web development environment, like idk, Unicode, REST clients, strict data structures, asynchronous I/O, whatever? That can <em>either</em> wait for Perl6 or you can pull things together using the CPAN if you want to move right now. Perl 6 leans the other way - they don&#39;t need to ship immediately, we have Perl 5 already here for doing things, Perl 6 is going to innovate on <em>everything</em>, and spend it&#39;s time getting there, designing up-front.<sup id="ref4"><a href="#fn4">4</a></sup> They spend at least two years writing high level requirement specs. They even spin out a side-project trying to build a universal virtual machine to run all dynamic programming languages that never delivers<sup id="ref5"><a href="#fn5">5</a></sup> </p><p>This is the landscape where Perl&#39;s central dominance of &#39;back end&#39; web programming continues to slip. Unfortunately, alongside the now principled bias toward cultural conservatism, Perl 5 has an explicit excuse for it. The future is over there, and exciting, and meanwhile we&#39;re working usefully, and getting paid, and getting stuff done. Kind of OK from inside the fort. Some day we&#39;ll move to the newer fort, but right now <em>this is fine</em>. Not very attractive to newcomers though, really. And this is also sort of OK, because Perl doesn&#39;t really want those sort of newcomers, does it? The kind that turns up on IRC or forums and asks basic questions about Perl 6 and sadly often gets treated with open contempt. </p><h3>Meanwhile, over there</h3><p>Ruby has sprouted &#34;Ruby on Rails&#34;, and it&#39;s taken the dynamic web building world by storm. Rails is a second generation web framework, that&#39;s proudly an &#39;opinionated web framework&#39;. Given that the web application architecture is starting to stabilise into a kind of three-tier system , with a client as a web browser, a middle tier as a monolithic application server, and a persistence layer as a relational database , and a split server architecture serving static and dynamic content from different routes, here is just one way to do that, with hugely developer friendly tooling turning this into a cookie-cutter solution for the 80% core, and a plugin and client-side decoration approach that allows for the necessary per-site customisation. </p><p>Ruby is interesting as well. Ruby is kind of a Perl6 really. More accurately it&#39;s <a href="https://ruby-doc.org/docs/ruby-doc-bundle/FAQ/FAQ.html">a parallel universe Perl5</a> Ruby comes from Japan, and has developed as an attempt to build something similar to Perl, but it&#39;s developed much later, by programming language enthusiasts, and for the first ten years or so, it&#39;s mostly only used in Japan. To my line of thinking this is probably important. Ruby does not spring from decades of sysadmin or sysop culture. Ruby is a language for programmers, and is at this point an sensible candidate for building something like Rails with - a relatively blank canvas for dynamic programming, with many of the same qualities as Perl, with less legacy cruft, and more modern niceties, like an integrated object system, exceptions, straightforward data structures. Ruby also has adopted &#39;friendliness&#39; as a core value, and the culture over there adopts a principled approach to aggressively welcoming newcomers, promoting easiness, and programmer happiness and convenience as strong first class principles. </p><p>Rails is a <em>huge</em> hit. At this point, which is around about the time I stopped significantly using Perl (2004-2005) (because I quit my job, not out of any core animosity toward it, in fact, in my day, I was really quite a Perl <em>fan</em>), Rails is the most appealing place to start as a new web programmer. Adoption rate is high, community is great, velocity of development is well-paced, and there&#39;s a lovely , well-lit, onboarding pipeline for how to start. You don&#39;t even really need to know ruby. It has a one-shot install tool, and generates working websites from templates, almost out of the box. It&#39;s an obvious starting point. </p><p>Perl being Perl, develops several analogue frameworks to Rails, all of them interdependently compatible and incompatible with each other and each other&#39;s dependencies, all of them designed to be as customisable and as user configurable as they possibly can be<sup id="ref6"><a href="#fn6">6</a></sup> </p><h3>PHP</h3><p>There are also the other obvious contenders. PHP has been there all along, and it&#39;s almost coming up from entirely the opposite cultural background of Perl. PHP is <em>a users language</em>. It&#39;s built to be deployed by copying script files to your home directory, with minimal server side impact or privileges. It&#39;s barely designed at all, but it encounters explosive growth all the way through the first (and through into the second) web era, almost entirely because it makes the barrier to onboarding so low as to be non-existent. PHP gets a couple of extra free shots in the arm </p><ol><li>Because it&#39;s architecture is so amenable to shared-server hosting, it is adopted as the primary implementation language of the blogging boom. An entire generation of web developers is born of installing and customising WordPress and text-pattern et. al by installing it directly into your home directory on a rented CPanel host account. It&#39;s the go-to answer for &#39;I&#39;m not a programmer really but how do I get a personal web site&#39;<sup id="ref7"><a href="#fn7">7</a></sup> This zero gate-keeping approach keeps the PHP stack firmly on the table of &#39;basic&#39; web programmers all through the history of the web up to the current day. </li><li>Because of these initially lightweight deployment targets, PHP scales like little else, mostly because it&#39;s execution model leans strongly towards idempotent execution, with each web request tearing up and tearing down the whole environment. In a sense, this is slower than keeping hot state around, but it does lend itself extremely well to shared-nothing horizontal scaling, which as the web user base increases gigantically throughout the 2000s era, is the simplest route to scaling out. Facebook famously, is built in PHP at this point in time. </li></ol><h3>Python</h3><p>There is of course one other big horse in the race in this era, and it&#39;s a particularly interesting one in many ways, certainly when contrasted with Perl. This is of course, Python. Python is a close contemporary of Perl&#39;s but once again, it&#39;s roots are somewhere very different. Python doesn&#39;t come from UNIX culture either. Python comes from academia, and programming language culture. It&#39;s kind of a forgotten footnote, but Python was originally built for the <a href="https://en.wikipedia.org/wiki/Amoeba_(operating_system">Amoeba operating system</a>, and it&#39;s intention was to be a straightforward programming language for scripting this<sup id="ref8"><a href="#fn8">8</a></sup>. The idea was to build a language that could be the &#39;second programming language&#39; for programmers. Given that this is the 1980s, early 1990s, the programmers would be expected to be mostly using C / C++ ,perhaps Pascal. Python was intended to allow faster development for lighter weight programs or scripting tasks. I suppose the idea was to take something that you might want to build in a shell script, but provide enough high level structured support that you could cleanly build the kind of things that quickly become a problem in shell scripts. So, it emphasises data structures, and scoped variables, and modules, and prioritises making it possible to extend the language with modules. Typical things that experienced programmers would want to use. The language was also designed to be portable between the different platforms programmers would use, running on the desktops of the day, but also on the server. As a consequence, it had a broad standard library of common <em>portable</em> abstractions around standard system features - file-systems, concurrency, time, FFI. For quite a long time, one of python&#39;s standard mottoes was &#39;batteries included&#39;. </p><p>Python never set the world on fire at any particular moment, but it remained committed to a clear evolutionary incremental development, and clean engineering principles. Again, I think the key element here is cultural tone. Python is kind of boring, not trying to be anyone&#39;s best language, or even a universal language. Python was always a little fussy, maybe snobby, slightly abstracted away from the real world. It&#39;s almost as old as Perl and it just kept incrementally evolving, picking up users, picking up features, slowly broadening the standard library. The first time I saw Python pick up an undeniable mainstream advantage would also have been around the early 2000s, when Google publicly adopted it as one of their house standard languages. Never radical, just calmly evolving in it&#39;s environs. </p><h3>Nature abhors a vacuum</h3><p>When I sketch out this landscape, I remain firmly convinced that most of Perl&#39;s impedance to continued growth were cultural. Perl&#39;s huge moment of relevance in the 90s was because it cross-pollinated two diverging user cultures. Traditional UNIX / database / data-centre maintenance and admin users, and enthusiastic early web builders and scalers. It had a cultural shock phase from extremely rapid growth, the centre couldn&#39;t hold, and things slowly fell apart. </p><p>Circling back though, it&#39;s time to address the real elephant in the room. Perl manifestly did not die. It&#39;s here right now. It&#39;s installed I think by default, on almost every single computer I own and operate, without me doing a single thing to make that happen. It&#39;s still used every day by millions of people on millions of systems (even if that isn&#39;t deliberate). It&#39;s still used by many people <em>entirely deliberately</em> for building software, whether that&#39;s because they know it and like it and it works, or because they&#39;re interfacing with or working on legacy Perl systems (of which there are still many), or maybe they&#39;re using it still in it&#39;s original intentional role - A capable POSIX-native scripting language, with much better performance and a broader feature-set than any shell or awk. I still occasionally break it out myself, for small scripts I would like to use more than once, or as parts of CLI pipelines. </p><p>What I don&#39;t do any more is reach for Perl <em>first</em> to make anything new. In my case, it&#39;s just because I typically am spoilt for options that are a better fit for most tasks, depending on whatever it is I&#39;m trying to achieve. By the time I came to Perl, (1998-ish), I was already on my third career phase, I had a strong UNIX background, and had already built real things in lisp, java, pascal, visual basic and C++. My attitude to languages was already informed by picking a tool to fit the task at hand. Boy did I love Perl for a few years. The product/market-fit for those early web days was just beautiful. The culture did have too much of the negative tropes I&#39;ve been pointing at, but that wasn&#39;t really a problem personally for me, I&#39;d grown up amongst the BOFHs inside the data centres already, it wasn&#39;t too hard for me to assimilate, nor pick up the core principles. I did occasionally bounce off a couple of abrasive characters in the community, but mostly this just kept me loosely coupled, I enjoyed how the language solved the problems I needed solving quickly, I enjoyed the flexibility, and I also enjoyed the way that it made me feel smart, and en-route to my wizard&#39;s robes and hat, when i used it to solve harder problems in creative ways, or designed ways around bugs and gremlins. For a good 3-4 years I would have immediately picked it as my favourite language. </p><p>So as I say, I didn&#39;t fall out of it with any sense of pique, I just naturally moved to different domains, and picked up tools that best fit. After Amazon, I spent t a lot of time concentrating on OS X and audio programming, and that involved a lot of objective C, C++. The scripting tools in that domain were often in ruby, sometimes python. For personal hacking, I picked up lisp again<sup id="ref9"><a href="#fn9">9</a></sup> (which I&#39;d always enjoyed in school). I dipped in and out of Perl here and there for occasional contract work, but I tended to gravitate more towards larger database stuff, where I typically found C, java and python. The next time I was building web things, it was all Rails and ruby, and then moving towards the web services / REST / cloud era, the natural fits were go, and of course node and JavaScript or Typescript. I&#39;ve always been a polyglot, and I&#39;ve always been pretty comfortable moving between programming languages. The truth of the matter is, that the majority of programming work is broadly similar, and the specific implementation details of the language you use don&#39;t matter all that much, if it&#39;s a good fit for the circumstances. </p><p>I can&#39;t imagine Perl disappearing entirely in my lifetime. I can remember entire programming environments and languages that are much, much deader than I can ever see Perl becoming. </p><ul><li>Pascal used to be <em>huge</em> for teaching and also for desktop development in the 8/16 bit era</li><li>Objective C - only really useful inside the Apple ecosystem, and they&#39;re hell bent on phasing it out.</li><li>Before I got into the Internet, I used to build application software for 16 bit Windows (3.11) which was a vast market, in a mixture of database 4GLs (like PowerBuilder, Gupta/Centura SQLWindows) and Win16 C APIs. This entire universe basically no longer exists, and is fully obsolete. There must be many similar cases.</li><li>I mean who the hell realistically uses common lisp any more outside of legacy or enthusiast markets? Less people than Perl I&#39;m sure.</li></ul><p>Perl also got to be if not first, then certainly early to dominate a new market paradigm. Plenty of things never manage that. It&#39;s hard to see Perl as anything other than an enormous success on these terms. Perl innovated and influenced languages that came after in some truly significant ways. </p><ul><li>Tightly embedding regular expressions and extending regular expressions (the most commonly used regular expression dialect in other tools is Perl)</li><li>CPAN, for package/library distribution via the internet, with dependency resolution - and including important concepts like supply chain verification with strong package signatures</li><li>A huge emphasis on testing, automated test harnesses, and CI. Perl test format (TAP) is also widely found in other CI/harness systems</li><li>Blending the gap between shell / scripting / and system programming in a single tool. I suppose this is debatable, but the way Perl basically integrated all the fundamental POSIX/libc as native built-ins with broadly the same semantics, but with managed memory and shell conventions was really revolutionary. Before this, most languages I had ever seen broadly tended to sit in one box, afterwards, most languages tended to span across several.</li><li>Amazing integrated documentation, online, in-tool and also man pages. POD is maybe the most successful ever implementation of literate programming ideas (although most of the real docs don&#39;t intertwingle the documentation very much iirc)</li></ul><p>Just these points, and I&#39;m sure there are many others that could be made, are enough of a legacy to be proud of. </p><p>Counterfactuals are stupid (but also fun). If I squint, I can imagine that a Perl with a less reactionary culture, and a healthier acceptance of other ideas and environmental change might have been able to evolve alongside the other tools in the web paradigm shift, and still occupy a more central position in today&#39;s development landscape. That&#39;s not the Perl we have though, and that didn&#39;t happen. And I&#39;m very confident that without the Perl we did have, the whole of modern software practice would be differently shaped. I do think Perl now lives in a legacy role, with a declining influence, but that&#39;s really nothing to feel shame or regret for. Nobody is going to forcibly take Perl away as long as POSIX exists, and so far as I can see, that means forever. In 2025 too, I can see the invisible hand creeping up on some of these other systems I&#39;ve mentioned. Rust is slowly absorbing C and C++. Ruby (and of course Rails) is clearly in decline, in a way that probably consigns it to become a similar legacy state. From a certain angle, it looks a lot like Typescript is slowly supplanting Python. I won&#39;t be entirely surprised if that happens, although at my age I kind of doubt I&#39;ll live to see the day. </p><h3>Footnotes</h3><p><a id="fn1" href="#ref1">1</a> : Meritocracy is a fun word. It was originally coined as a pejorative term to describe a dystopian mechanism by which modern i.e. Western / British society entrenches and justifies an unfair and unequal distribution of privilege </p><p><a id="fn2" href="#ref2">2</a> : The UNIX <em>implementer</em> culture, is scientific/academic and fell out of Bell Labs. I guess you could extend this school of thought as a cultural sweep towards building abstracted cloud operations, toward plan 9/ Inferno / go </p><p><a id="fn3" href="#ref3">3</a> : Web 2.0 was first <a href="https://www.webdesignmuseum.org/web-design-history/web-2-0-1999">defined in 1999</a> by <a href="http://darcyd.com/fragmented_future.pdf">Darcy DiNucci in a print article</a> , the term didn&#39;t become mainstream until it was picked up and promoted by Tim O&#39;Reilly (then owner/operator of perl.com, trivia fans), an astute inside observer of the forces driving web development </p><p><a id="fn4" href="#ref4">4</a>: Another unfortunate bit of luck here. Right at the point of time that <em>&#39;agile&#39;</em> starts getting some traction as a more natural way to embrace software development - i.e. iterating in small increments against a changing environment and requirements, Perl 6 decides to do perhaps the most waterfall open source development process ever attempted. . It is fifteen years before Perl 6 ships something resembling a usable programming language.<br/>
</p><p><a id="fn5" href="#ref5">5</a> : <a href="http://www.parrot.org/">The Parrot VM</a>, a lovely quixotic idea, which sadly fizzled out, after even Perl 6 stopped trying to target it. Interestingly enough, both python and ruby both made relatively high profile ports to the JVM that were useful enough to be used for production deploys in certain niches. </p><p><a id="fn6" href="#ref6">6</a> : A side effect of this degree of abstraction, is that as well as being very hard to get started, it&#39;s easy to fall foul of performance overhead. </p><p><a id="fn7" href="#ref7">7</a> : This ubituitious ecosystem of small footprint wordpress custom installs gives birth to the web agency model of commercial website building / small ecommerce sites, which thrives and is suprisingly healthy today. Recent, and slighly optimistic surveys have pitched WordPress as powering over 40% of all websites today. Now this is certainly inflated, but even if the realistic number is half of that, that&#39;s still pretty damn healthy. </p><p><a id="fn8" href="#ref8">8</a> : It&#39;s often repeated that Python was designed as a teaching language, but as far as I know, that&#39;s not actually the case. The designer of Python, Guido Van Rossum <a href="https://www.artima.com/articles/the-making-of-python">was previously working on a project</a> that <em>was</em> a intended as training language, called ABC, and many of ABC&#39;s syntax and structural features influenced or made their way into Python. </p><p><a id="fn9" href="#ref9">9</a> : Common lisp is a better answer to an infinitely flexible &#39;everything&#39; chainsaw language than perl, IMHO </p>
			    <section>
			      <span>posted by <a rel="me" href="https://blog.veitheller.de/">cms</a></span><span> on <time datetime="2025-11-20">2025-11-20</time></span>
			    </section>
			  <p>tagged as</p>
		      </div></div>
  </body>
</html>
