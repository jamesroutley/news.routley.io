<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.gilesthomas.com/2025/05/llm-from-scratch-13-taking-stock-part-1-attention-heads-are-dumb">Original</a>
    <h1>Writing an LLM from scratch, part 13 – attention heads are dumb</h1>
    
    <div id="readability-page-1" class="page"><div>
            

            <div data-current-dropdown="" hx-on="click:
                    if (event.target.closest(&#39;.dropdown&#39;)) {
                        let targetId = event.target.closest(&#39;.dropdown&#39;).dataset.target;
                        this.dataset.currentDropdown = (this.dataset.currentDropdown === targetId) ? &#39;&#39; : targetId;
                        event.stopPropagation();
                    }">

                

                <div>
                    
                        <p>
                            Archives <span></span>
                        </p>
                    
                    
                        <p>
                            Categories <span></span>
                        </p>
                    
                    <p>
                        Blogroll <span></span>
                    </p>
                </div>

                
                
                
            </div>

            

    

    

    <p>Now that I&#39;ve finished chapter 3 of
<a href="https://sebastianraschka.com/">Sebastian Raschka</a>&#39;s book
&#34;<a href="https://www.manning.com/books/build-a-large-language-model-from-scratch">Build a Large Language Model (from Scratch)</a>&#34; --
having worked my way through <a href="https://www.gilesthomas.com/2025/04/llm-from-scratch-12-multi-head-attention">multi-head attention</a> in the last post --
I thought it would be worth pausing to take stock before moving on to Chapter 4.</p>

<p>There are two things I want to cover, the &#34;why&#34; of self-attention, and some thoughts
on context lengths.  This post is on the &#34;why&#34; -- that is, why do the particular
set of matrix multiplications described in the book do what we want them to do?</p>

<p>As always, this is something I&#39;m doing
primarily to get things clear in my own head -- with the possible extra benefit of it
being of use to other people out there.  I will, of course, run it past multiple
LLMs to make sure I&#39;m not posting total nonsense, but caveat lector!</p>

<p>Let&#39;s get into it.  As I wrote in
<a href="https://www.gilesthomas.com/2025/03/llm-from-scratch-8-trainable-self-attention">part 8 of this series</a>:</p>

<blockquote>
  <p>I think it&#39;s also worth noting that [what&#39;s in the book is] very much a &#34;mechanistic&#34; explanation -- it says how we do these calculations
  without saying why. I think that the &#34;why&#34; is actually out of scope for this book, but it&#39;s something that fascinates
  me, and I&#39;ll blog about it soon.</p>
</blockquote>

<p>That &#34;soon&#34; is now :-)</p>


    
        <h3 id="attention-heads-are-dumb">Attention heads are dumb</h3>

<p>I think that my core problem with getting my head around why these equations
work was that I was overestimating
what a single attention head could do.  In
<a href="https://www.gilesthomas.com/2025/01/llm-from-scratch-6-coding-self-attention-part-1">part 6</a>, I wrote, of
the phrase &#34;the fat cat sat on the mat&#34;:</p>

<blockquote>
  <p>So while the input embedding for &#34;cat&#34; just means &#34;cat in position 3&#34;, the context vector
  for &#34;cat&#34; in this sentence also has some kind of overtones about it being a cat
  that is sitting, perhaps less strongly that it&#39;s a specific cat (&#34;the&#34; rather than &#34;a&#34;),
  and hints of it being sitting on a mat.</p>
</blockquote>

<p>The thing that I hadn&#39;t understood was that this is true in as far as it goes, but
only for the output of the attention mechanism as a whole -- <em>not</em> for a single
attention head.</p>

<p>Each individual attention head is really dumb, and what it&#39;s doing is much
simpler than that!</p>

<p>The two things that combine to make the mechanism as a whole smart are multi-head
attention and layering.  The book has gone over multi-head attention in detail, so
let&#39;s drill down on that second part.</p>

<h3 id="layers">Layers</h3>

<p>Right at the start, in <a href="https://www.gilesthomas.com/2024/12/llm-from-scratch-1">part 1</a>, I wrote:</p>

<blockquote>
  <p>One other thing that Raschka mentions that confuses me a little is that
  apparently the original transformer architecture had six encoder and six decoder
  blocks, and GPT-3 has 96 transformer layers. That doesn&#39;t fit very comfortably
  with my model of how this all works. Both encoders and decoders seem like
  stand-alone things that accept inputs (tokens/embeddings) and produce outputs
  (embeddings/tokens). What would you do with multiple layers of them?</p>
</blockquote>

<p>Now that we&#39;ve covered how attention works, that&#39;s become a bit clearer.
A multi-head attention block gets a set of input embeddings, one per token in
the input sequence, and produces a set of the same number of context vectors.
There&#39;s nothing stopping us from treating those context vectors as the input embeddings
for another attention block and doing the same thing again.</p>

<p>(That also explains why Raschka mentions that the number of dimensions in the
context vectors often matches the number in the input embeddings; it makes it easier
to use the same &#34;shape&#34; of multi-head attention calculations for each layer.)</p>

<p>In my mind, this is similar to the way an image-processing network -- say, a CNN --
works.  In those, the first layer
might detect edges, the second might detect lines at certain orientations, the
next particular shapes, and then somewhere later on, the <em>n</em>th might recognise
dogs&#39; faces.</p>

<p>So the representation of the token &#34;cat&#34; that I described above would not be part of
the output of one attention head, and perhaps even the first layer of the attention
mechanism might not have anything that rich.  But it might be in the output of
the third layer of multi-head attention, or the fourth, or something like that.</p>

<p>By the 96th of those layers in GPT-3, what&#39;s represented in the context vectors
is going to be super-enriched, and have lots of information spread across the different
tokens.  And realising this was a bit of an epiphany for me as well.</p>

<h3 id="no-more-fixed-length-bottleneck">No more fixed-length bottleneck</h3>

<p>If you cast your
mind back to <a href="https://www.gilesthomas.com/2025/01/llm-from-scratch-5-self-attention">part 5</a>, a big problem
with encoder/decoder RNNs that did not have attention mechanisms was
the fixed-length bottleneck.  You would run your input sequence into an encoder
RNN, which would try to represent its meaning in its hidden state -- a vector of
a particular fixed length -- ready to pass it
on to the decoder.  Easy with a short input, but increasingly hard and eventually
impossible as it gets longer, because you&#39;d be trying to pack more and more information
into the same &#34;space&#34;.</p>

<p>But with attention, this super-enriched and combined representation of the input
sequence that comes out of the last attention layer is proportional in length to the
number of tokens in the input!  You&#39;re still limited by available memory, of course
(and other things -- see the next post), but the more tokens you have, the larger
this &#34;hidden state&#34; of the context vectors.</p>

<p>That&#39;s pretty cool.</p>

<p>So, using multi-head attention plus layers allows us to build up complex representations
even when each individual attention head is dumb.  But, going back to the core of
this post, <em>why</em> do these dumb attention heads use the specific calculations that they
do?</p>

<h3 id="why-dumb-attention-heads-work">Why dumb attention heads work</h3>

<p>Let&#39;s use an example.</p>

<p>A heads-up/warning first: the attention heads are learning their own representations and patterns
to match on as part of a deep learning gradient descent -- so whatever they learn will
probably be weird and alien and not relate in any way to grammar as we understand
it.  But for this example, let&#39;s pretend that isn&#39;t the case, and that we&#39;ve got an attention head
that has learned how to match articles (like &#34;a&#34;, &#34;an&#34;, and &#34;the&#34;) up with their
associated nouns.</p>

<p>How would that work?  Let&#39;s take &#34;the fat cat sat on the mat&#34;, and ignore everything
apart from the two &#34;the&#34;s, and the nouns &#34;cat&#34; and &#34;mat&#34;.  We&#39;ll say that our attention head
wants to produce a context vector for &#34;cat&#34; that combines it with the first &#34;the&#34;
(meaning that it will contain the concept that we&#39;re talking about a specific cat
rather than just &#34;a&#34; cat), and similarly it wants to blend the second &#34;the&#34; into
&#34;mat&#34;.</p>

<p>Now, remember that our input sequence is a series of input embeddings, which are combinations of the token
embeddings (which are vectors in a space that point to some abstract &#34;meaning&#34; of
the tokens) and position embeddings (which represent their position in the
sequence).</p>

<p>Taking &#34;mat&#34; as our example, we project its input embedding, which means &#34;the token &#39;mat&#39;
at position 7&#34; into <em>query space</em>.  The breakthrough to
me was that query space is another embedding space, just like the original
one for the input embeddings, but with different representations for the values.</p>

<p>Let&#39;s say that in this new embedding space, representations are much simpler -- they don&#39;t have
as much detail as the original one.  It just represents &#34;this is an article&#34; or
&#34;this is not an article&#34;, and some information about positioning --
that is, the embedding for an article at position 1 is close to the embedding at
position 2, but is not very close to the one for an article at position 69,536.
And other things that are not articles would be somewhere even further away.</p>

<p>In this example, perhaps the projection that our attention head has
learned will map &#34;&#39;mat&#39; at position 7&#34; to an embedding pointing in the direction of
&#34;some article -- the or a -- at position 6 or lower, probably quite close&#34;.
In other words, the projection into query space turns an input embedding for a token into the kind of thing
this attention head is looking for when it&#39;s handling that token.  Likewise &#34;&#39;cat&#39; at position 2&#34;
would be projected into an embedding vector meaning &#34;some article at position 1 or
lower, probably quite close&#34;.</p>

<p>Now, as well as projecting the input embeddings into the query space, we&#39;re also projecting them into the key space.  In that case, our imaginary
article-matching head would create a projection that would turn the first &#34;the&#34; into
something meaning &#34;an article at position 1&#34;, and the second into one meaning
&#34;an article at position 6&#34;.</p>

<p>So, the query weights have projected our input embeddings into this &#34;low-resolution&#34; embedding space
to point in a direction meaning &#34;this is what I&#39;m interested in&#34;, and the key weights
have projected the input embeddings into the same embedding space in a direction meaning &#34;this is what I am&#34;.</p>

<p>That means that when we do our dot product, the query vector for the &#34;mat&#34; will point in a
very similar direction to the key vector for the second &#34;the&#34;, and so the dot
product will be high -- remember, so long as vectors are roughly the same length,
the dot product is an indication of how similar they are.</p>

<p>What&#39;s important about this is that the shared embedding space that the query and
key vectors use can actually be pretty impoverished compared to the rich space
that the input embeddings used.  In our case, all the head cares about are whether
tokens are nouns or articles or something else, and their position.</p>

<p>Let&#39;s take an example.  Here&#39;s the imaginary set of attention scores that
I imagined that the attention mechanism might come up with back in part 6 (modified to
be causal so that tokens don&#39;t pay any attention to tokens in their &#34;future&#34;):</p>

<table>
<thead>
<tr>
  <th>Token</th>
  <th>ω(&#34;The&#34;)</th>
  <th>ω(&#34;fat&#34;)</th>
  <th>ω(&#34;cat&#34;)</th>
  <th>ω(&#34;sat&#34;)</th>
  <th>ω(&#34;on&#34;)</th>
  <th>ω(&#34;the&#34;)</th>
  <th>ω(&#34;mat&#34;)</th>
</tr>
</thead>
<tbody>
<tr>
  <td>The</td>
  <td>1</td>
  <td>0</td>
  <td>0</td>
  <td>0</td>
  <td>0</td>
  <td>0</td>
  <td>0</td>
</tr>
<tr>
  <td>fat</td>
  <td>0.2</td>
  <td>1</td>
  <td>0</td>
  <td>0</td>
  <td>0</td>
  <td>0</td>
  <td>0</td>
</tr>
<tr>
  <td>cat</td>
  <td>0.6</td>
  <td>0.8</td>
  <td>1</td>
  <td>0</td>
  <td>0</td>
  <td>0</td>
  <td>0</td>
</tr>
<tr>
  <td>sat</td>
  <td>0.1</td>
  <td>0</td>
  <td>0.85</td>
  <td>1</td>
  <td>0</td>
  <td>0</td>
  <td>0</td>
</tr>
<tr>
  <td>on</td>
  <td>0</td>
  <td>0.1</td>
  <td>0.4</td>
  <td>0.6</td>
  <td>1</td>
  <td>0</td>
  <td>0</td>
</tr>
<tr>
  <td>the</td>
  <td>0</td>
  <td>0</td>
  <td>0</td>
  <td>0</td>
  <td>0.1</td>
  <td>1</td>
  <td>0</td>
</tr>
<tr>
  <td>mat</td>
  <td>0</td>
  <td>0</td>
  <td>0.2</td>
  <td>0.8</td>
  <td>0.7</td>
  <td>0.6</td>
  <td>1</td>
</tr>
</tbody>
</table>

<p>Each row is, for the token in the first column, the attention scores for all of the
other words.  It&#39;s based on my own intuition about the importance of words, and it&#39;s
the kind of thing you might imagine a clever attention head might come up with.
(Remember that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi>ω</mi></mrow></math> is the variable we use to represent attention scores.)</p>

<p>But our closer-to-real-world example of an article-noun matching head is really dumb,
so it might come up with something more like this:</p>

<table>
<thead>
<tr>
  <th>Token</th>
  <th>ω(&#34;The&#34;)</th>
  <th>ω(&#34;fat&#34;)</th>
  <th>ω(&#34;cat&#34;)</th>
  <th>ω(&#34;sat&#34;)</th>
  <th>ω(&#34;on&#34;)</th>
  <th>ω(&#34;the&#34;)</th>
  <th>ω(&#34;mat&#34;)</th>
</tr>
</thead>
<tbody>
<tr>
  <td>The</td>
  <td>0</td>
  <td>0</td>
  <td>0</td>
  <td>0</td>
  <td>0</td>
  <td>0</td>
  <td>0</td>
</tr>
<tr>
  <td>fat</td>
  <td>0</td>
  <td>0</td>
  <td>0</td>
  <td>0</td>
  <td>0</td>
  <td>0</td>
  <td>0</td>
</tr>
<tr>
  <td>cat</td>
  <td>0.8</td>
  <td>0</td>
  <td>1</td>
  <td>0</td>
  <td>0</td>
  <td>0</td>
  <td>0</td>
</tr>
<tr>
  <td>sat</td>
  <td>0</td>
  <td>0</td>
  <td>0</td>
  <td>0</td>
  <td>0</td>
  <td>0</td>
  <td>0</td>
</tr>
<tr>
  <td>on</td>
  <td>0</td>
  <td>0</td>
  <td>0</td>
  <td>0</td>
  <td>0</td>
  <td>0</td>
  <td>0</td>
</tr>
<tr>
  <td>the</td>
  <td>0</td>
  <td>0</td>
  <td>0</td>
  <td>0</td>
  <td>0</td>
  <td>0</td>
  <td>0</td>
</tr>
<tr>
  <td>mat</td>
  <td>0.1</td>
  <td>0</td>
  <td>0</td>
  <td>0</td>
  <td>0</td>
  <td>0.8</td>
  <td>1</td>
</tr>
</tbody>
</table>

<p>All it has done is
decided to pay attention to the &#34;the&#34;s when considering the nouns -- and it&#39;s
even paying a bit of attention to the first &#34;the&#34; when considering &#34;mat&#34;, because
it doesn&#39;t know that it has to be the closest &#34;the&#34; that it matches with.  </p>

<p>Now, as I said earlier, the real attention heads, having been trained by gradient
descent over billions of tokens, will probably have learned something weird and
abstract and not related to the way we think of language, grammar and the parts
of speech.</p>

<p>But taken individually, they will be really dumb, because the equation is doing something really simple:
when considering a particular kind of thing, look for this other kind of thing.
Each token is projected into a shared embedding space by the query weights
(&#34;what I&#39;m looking for&#34; ) and into the same space by the key weights
(&#34;what I am&#34;), and the dot product does the comparison to find
matches.</p>

<p>Of course, that doesn&#39;t mean we lose any information.  This impoverished embedding space is only used
to do the matching to work out our attention scores.  When we work out the context
vectors we use projection into value space, which can be as rich as we like.</p>

<blockquote>
  <p>It&#39;s worth noting that although the example Raschka is using in the book has the
  same dimensionality for the shared space for query and key vectors, and the space
  for value vectors, there&#39;s actually no need for that.  I&#39;ve seen specs for LLMs
  where the QK space has fewer dimensions -- which makes sense, at least for this
  trivial example.</p>
</blockquote>

<p>It&#39;s also worth noting that this key/query space is impoverished in this example,
but in a real &#34;alien&#34; learned example, it could actually be quite complex and
rich -- but much harder to understand than this example.  Ultimately, the
nature of that embedding space will be learned in the same way as everything else,
and will match whatever thing the head in question has learned to do.</p>

<h3 id="the-elegance-of-dumb-attention">The elegance of dumb attention</h3>

<p>So, that is (right now) my understanding of how scaled dot product attention works.
We&#39;re just doing simple pattern matching, where each token&#39;s input embedding is
projected by the query weights into a (learned) embedding space that is able to represent what it is
&#34;looking for&#34; in some sense.  It&#39;s also projected by the key weights into the same
space, but this time in a way that makes it point to what it &#34;is&#34; in the same sense.
Then the dot product matches those up so that we can associate input embeddings with
each other to work out our attention scores.</p>

<p>That all makes sense in my head, and I hope it does in at least a few other people&#39;s :-)</p>

<p>I&#39;ll wrap this one up here; next time I&#39;ll be posting on what I understand right
now about what we&#39;ve been through in the book so far means for context lengths.  We&#39;ve seen
the upside of that hidden state that grows as the input sequence does -- what are
the downsides?</p>



    

    
        
    

    



            
        </div></div>
  </body>
</html>
