<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://docs.timetime.in/blog/js-dates-finally-fixed">Original</a>
    <h1>JavaScript dates are about to be fixed</h1>
    
    <div id="readability-page-1" class="page"><div id="__blog-post-container">
<p>Of all the recent changes coming to ECMAScript, my favorite by far is the <a href="https://github.com/tc39/proposal-temporal" target="_blank" rel="noopener noreferrer">Temporal proposal</a>. This proposal is very advanced, and we can already use this API through the <a href="https://github.com/fullcalendar/temporal-polyfill" target="_blank" rel="noopener noreferrer">polyfill provided by the FullCalendar team</a>.</p>
<p>This API is so incredible that I will likely dedicate several blog posts to highlighting its key features. However, in this first post, I will focus on explaining one of its main advantages: <strong>we finally have a native object to represent a &#34;Zoned Date Time&#34;</strong>.</p>
<p>But... What is a &#34;Zoned Date Time&#34;?</p>

<p>Well, when we talk about <em>human dates</em>, we usually say something like, &#34;I have a doctor&#39;s appointment on August 4th, 2024, at 10:30 AM,&#34; but we omit the time zone. This omission makes sense because, generally, our interlocutor knows us and understands that when I talk about dates, I usually do so in the context of my time zone, Europe/Madrid.</p>
<p>Unfortunately, with computers, this is not the case. When we work with &#34;Date&#34; objects in JavaScript we are dealing with plain numbers.</p>
<p>If we read the <a href="https://tc39.es/ecma262/multipage/numbers-and-dates.html#sec-time-values-and-time-range" target="_blank" rel="noopener noreferrer">official specification</a>, it states:</p>
<blockquote>
<p><em>&#34;An ECMAScript time value is a Number, either a finite integral Number representing an instant in time to millisecond precision or NaN representing no specific instant&#34;</em></p>
</blockquote>
<p>Aside from the VERY IMPORTANT fact that dates in JavaScript are not UTC but POSIX, where leap seconds are completely ignored, the problem with having only numbers is that the original semantics of the date are lost. This is becaus given an human date we can get the equivalent js date but not the other way arround.</p>
<p>Let&#39;s consider an example: suppose I want to record the moment I make a payment with my card. Many people might be tempted to do something like this:</p>
<div><div><pre tabindex="0"><code><span><span>const</span><span> paymentDate </span><span>=</span><span> </span><span>new</span><span> </span><span>Date</span><span>(</span><span>&#39;2024-07-20T10:30:00&#39;</span><span>)</span><span>;</span><br/></span></code></pre></div></div>
<p>Since my browser is on an <code>CET</code> timezone, when I write this the browser just <em>&#34;computes the number of milliseconds since the EPOX given this CET instant&#34;</em></p>
<p>This is what we actually store in a date:</p>

<p>This means that depending on how you read this information you will get a different &#34;human date&#34;:</p>
<p>If we read this from the CET perspective I get 10:30:</p>

<p>and if we read this from the ISO perspective we get 8:30:</p>

<p>Many people think that by working with UTC or communicating dates in ISO format, they are safe; however, <strong>this is not correct, as information is still lost.</strong></p>

<p>Even when working with dates on an ISO format, including the offset, the next time we want to display that date, we only know the number of milliseconds that have passed since the UNIX epoch and the offset. But this is still not enough to know the human moment and time zone in which the payment was made.</p>
<p>Strictly speaking, given a timestamp <code>t0</code>, we can obtain <code>n</code> human-readable dates that represent it...</p>
<!-- -->
<p>In other words, the function responsible for transforming a timestamp into a human-readable date is not <a href="https://en.wikipedia.org/wiki/Injective_function" target="_blank" rel="noopener noreferrer">injective</a>, as each element of the set of timestamps corresponds to more than one element of the &#34;human dates&#34; set.</p>
<!-- -->
<p>This happens in exactly the same way when storing ISO dates, as timestamps and ISO are two representations of the same instant:</p>
<!-- -->
<p>And this <strong>also happens if you work with offsets</strong> because different timezones might have the same offset.</p>
<!-- -->
<p>If you still don&#39;t see the problem clearly, let me illustrate it with an example. Imagine you live in Madrid and take a trip to Sydney.</p>
<p>A few weeks later, you return to Madrid and see a charge on your transaction statement that you don&#39;t recognize... a charge of 3.50 at 2 AM on the 16th? What was I doing? That night I went to bed early!... I don&#39;t understand.</p>
<p>After a while of being worried, you realize that the charge corresponds to the coffee you had the following morning since, as you&#39;ve read this article, you&#39;ve deduced that your bank stores all transactions in UTC, and the application translates them to the phone&#39;s time zone.</p>
<p>This may end up as an anecdote, but what if your bank applies a promotion of one free cash withdrawal per day? When does that day start and end? UTC? Australia?... Things get complicated, believe me...</p>
<p>At this point, I hope you&#39;re convinced that working with only timestamps is a problem that, fortunately, now has a solution.</p>

<p>In addition to many other things, the new Temporal API introduces a <a href="https://tc39.es/proposal-temporal/docs/zoneddatetime.html" target="_blank" rel="noopener noreferrer">Temporal.ZonedDateTime</a> object specifically designed to represent dates and times with their corresponding time zone. They have also proposed an <a href="https://datatracker.ietf.org/doc/rfc9557/" target="_blank" rel="noopener noreferrer">extension to RFC 3339</a> to standardize the serialization and deserialization of strings representing dates:</p>
<p><img src="https://tc39.es/proposal-temporal/docs/persistence-model.svg" alt="" title="String spec"/></p><p>As an example:</p>
<div><div><pre tabindex="0"><code><span><span>   1996-12-19T16:39:57-08:00[America/Los_Angeles]</span><br/></span></code></pre></div></div>
<p>This string represents 39 minutes and 57 seconds after the 16th hour of December 19, 1996, with an offset of -08:00 from UTC, and additionally specifies the human time zone associated with it (&#34;Pacific Time&#34;) for time-zone-aware applications to take into account.</p>
<p>Additionally, this API allows working with different calendars such as:</p>
<ul>
<li>buddhist</li>
<li>chinese</li>
<li>coptic</li>
<li>dangi</li>
<li>ethioaa</li>
<li>ethiopic</li>
<li>gregory</li>
<li>hebrew</li>
<li>indian</li>
<li>islamic</li>
<li>islamic-umalqura</li>
<li>islamic-tbla</li>
<li>islamic-civil</li>
<li>islamic-rgsa</li>
<li>japanese</li>
<li>persian</li>
<li>roc</li>
</ul>
<p>Among all these, the most common will be <code>iso8601</code> (the standard adaptation of the Gregorian calendar) with which you will work most frequently.</p>
<h3 id="basic-operations">Basic operations<a href="#basic-operations" aria-label="Direct link to Basic operations" title="Direct link to Basic operations">​</a></h3>
<h4 id="creating-dates">Creating Dates<a href="#creating-dates" aria-label="Direct link to Creating Dates" title="Direct link to Creating Dates">​</a></h4>
<p>The Temporal API offers a significant advantage when creating dates, particularly with its Temporal.ZonedDateTime object. One of the standout features is its ability to effortlessly handle time zones, including those tricky situations involving Daylight Saving Time (DST). For example, when you create a Temporal.ZonedDateTime object like this:</p>
<div><div><pre tabindex="0"><code><span><span>const</span><span> zonedDateTime </span><span>=</span><span> Temporal</span><span>.</span><span>ZonedDateTime</span><span>.</span><span>from</span><span>(</span><span>{</span><span></span><br/></span><span><span>  year</span><span>:</span><span> </span><span>2024</span><span>,</span><span></span><br/></span><span><span>  month</span><span>:</span><span> </span><span>8</span><span>,</span><span></span><br/></span><span><span>  day</span><span>:</span><span> </span><span>16</span><span>,</span><span></span><br/></span><span><span>  hour</span><span>:</span><span> </span><span>12</span><span>,</span><span></span><br/></span><span><span>  minute</span><span>:</span><span> </span><span>30</span><span>,</span><span></span><br/></span><span><span>  second</span><span>:</span><span> </span><span>0</span><span>,</span><span></span><br/></span><span><span>  timeZone</span><span>:</span><span> </span><span>&#39;Europe/Madrid&#39;</span><span></span><br/></span><span><span></span><span>}</span><span>)</span><span>;</span><br/></span></code></pre></div></div>
<p>You’re not just setting a date and time; you&#39;re ensuring that this date is accurately represented within the specified time zone. This precision means that regardless of DST changes or any other local time adjustments, your date will always reflect the correct moment in time.</p>
<p>This feature is especially powerful when scheduling events or logging actions that need to be consistent across different regions. By incorporating the time zone directly into the date creation process, Temporal eliminates the common pitfalls of working with traditional Date objects, such as unexpected shifts in time due to DST or time zone differences. This makes Temporal not just a convenience but a necessity for modern web development where global time consistency is crucial.</p>
<p>If you are curious about why this API is great read <a href="https://tc39.es/proposal-temporal/docs/ambiguity.html#ambiguity-caused-by-permanent-changes-to-a-time-zone-definition" target="_blank" rel="noopener noreferrer">this article explaining how to deal with changes on Time Zone definitions</a>.</p>
<h4 id="comparing-dates">Comparing dates<a href="#comparing-dates" aria-label="Direct link to Comparing dates" title="Direct link to Comparing dates">​</a></h4>
<p>ZonedDateTime offers an static method named <code>compare</code> which given 2 ZonedDateTimes one and two will return:</p>
<ul>
<li><code>−1</code> if one is less than two</li>
<li><code>0</code> if the two instances describe the same exact instant, ignoring the time zone and calendar</li>
<li><code>1</code> if one is greater than two.</li>
</ul>
<p>You can easily compare dates on unusual cases like the repeated clock hour after DST ends, values that are later in the real world can be earlier in clock time, or vice versa:</p>
<div><div><pre tabindex="0"><code><span><span>const</span><span> one </span><span>=</span><span> Temporal</span><span>.</span><span>ZonedDateTime</span><span>.</span><span>from</span><span>(</span><span>&#39;2020-11-01T01:45-07:00[America/Los_Angeles]&#39;</span><span>)</span><span>;</span><span></span><br/></span><span><span></span><span>const</span><span> two </span><span>=</span><span> Temporal</span><span>.</span><span>ZonedDateTime</span><span>.</span><span>from</span><span>(</span><span>&#39;2020-11-01T01:15-08:00[America/Los_Angeles]&#39;</span><span>)</span><span>;</span><span></span><br/></span><span><span></span><br/></span><span><span>Temporal</span><span>.</span><span>ZonedDateTime</span><span>.</span><span>compare</span><span>(</span><span>one</span><span>,</span><span> two</span><span>)</span><span>;</span><span></span><br/></span><span><span>  </span><span></span><br/></span><span><span>  </span><br/></span></code></pre></div></div>
<h4 id="cool-built-ins">Cool built-ins<a href="#cool-built-ins" aria-label="Direct link to Cool built-ins" title="Direct link to Cool built-ins">​</a></h4>
<p>A ZonedDateTime has some precomputed attributes that will make your life easier, for example:</p>
<p><strong><code>hoursInDay</code></strong></p>
<p>The hoursInDay read-only property returns the number of real-world hours between the start of the current day (usually midnight) in zonedDateTime.timeZone to the start of the next calendar day in the same time zone.</p>
<div><div><pre tabindex="0"><code><span><span>Temporal</span><span>.</span><span>ZonedDateTime</span><span>.</span><span>from</span><span>(</span><span>&#39;2020-01-01T12:00-08:00[America/Los_Angeles]&#39;</span><span>)</span><span>.</span><span>hoursInDay</span><span>;</span><span></span><br/></span><span><span>  </span><span></span><br/></span><span><span>  </span><span></span><br/></span><span><span>Temporal</span><span>.</span><span>ZonedDateTime</span><span>.</span><span>from</span><span>(</span><span>&#39;2020-03-08T12:00-07:00[America/Los_Angeles]&#39;</span><span>)</span><span>.</span><span>hoursInDay</span><span>;</span><span></span><br/></span><span><span>  </span><span></span><br/></span><span><span>  </span><span></span><br/></span><span><span>Temporal</span><span>.</span><span>ZonedDateTime</span><span>.</span><span>from</span><span>(</span><span>&#39;2020-11-01T12:00-08:00[America/Los_Angeles]&#39;</span><span>)</span><span>.</span><span>hoursInDay</span><span>;</span><span></span><br/></span><span><span>  </span><span></span><br/></span><span><span>  </span><br/></span></code></pre></div></div>
<p>Another cool attributes are <a href="https://tc39.es/proposal-temporal/docs/zoneddatetime.html#daysInYear" target="_blank" rel="noopener noreferrer">daysInYear</a>, <a href="https://tc39.es/proposal-temporal/docs/zoneddatetime.html#inLeapYear" target="_blank" rel="noopener noreferrer">inLeapYear</a></p>
<h4 id="transforming-timezones">Transforming timezones<a href="#transforming-timezones" aria-label="Direct link to Transforming timezones" title="Direct link to Transforming timezones">​</a></h4>
<p>ZonedDateTimes offer a <code>.withTimeZone</code> method which allows to change a ZonedDateTime as we desire:</p>
<div><div><pre tabindex="0"><code><span><span>zdt </span><span>=</span><span> Temporal</span><span>.</span><span>ZonedDateTime</span><span>.</span><span>from</span><span>(</span><span>&#39;1995-12-07T03:24:30+09:00[Asia/Tokyo]&#39;</span><span>)</span><span>;</span><span></span><br/></span><span><span>zdt</span><span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span><span> </span><span></span><br/></span><span><span>zdt</span><span>.</span><span>withTimeZone</span><span>(</span><span>&#39;Africa/Accra&#39;</span><span>)</span><span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span><span> </span><br/></span></code></pre></div></div>
<h4 id="basic-arithmetics">Basic arithmetics<a href="#basic-arithmetics" aria-label="Direct link to Basic arithmetics" title="Direct link to Basic arithmetics">​</a></h4>
<p>We can use the <code>.add</code> method to add the date portion of a duration using calendar arithmetics. The result will automatically adjust for Daylight Saving Time using the rules of this instance&#39;s timeZone field.</p>
<p>The <strong>GREAT PART</strong> of this is that it supports playing with calendar arithmetics or plain durations.</p>
<ul>
<li>Adding or subtracting days should keep clock time consistent across DST transitions. For example, if you have an appointment on Saturday at 1:00PM and you ask to reschedule it 1 day later, you would expect the reschedule appointment to still be at 1:00PM, even if there was a DST transition overnight.</li>
<li>Adding or subtracting the time portion of a duration should ignore DST transitions. For example, a friend you&#39;ve asked to meet in in 2 hours will be annoyed if you show up 1 hour or 3 hours later.</li>
<li>There should be a consistent and relatively-unsurprising order of operations. If results are at or near a DST transition, ambiguities should be handled automatically (no crashing) and deterministically.</li>
</ul>
<div><div><pre tabindex="0"><code><span><span>zdt </span><span>=</span><span> Temporal</span><span>.</span><span>ZonedDateTime</span><span>.</span><span>from</span><span>(</span><span>&#39;2020-03-08T00:00-08:00[America/Los_Angeles]&#39;</span><span>)</span><span>;</span><span></span><br/></span><span><span></span><span></span><br/></span><span><span>laterDay </span><span>=</span><span> zdt</span><span>.</span><span>add</span><span>(</span><span>{</span><span> days</span><span>:</span><span> </span><span>1</span><span> </span><span>}</span><span>)</span><span>;</span><span></span><br/></span><span><span>  </span><span></span><br/></span><span><span>  </span><span></span><br/></span><span><span>laterDay</span><span>.</span><span>since</span><span>(</span><span>zdt</span><span>,</span><span> </span><span>{</span><span> largestUnit</span><span>:</span><span> </span><span>&#39;hour&#39;</span><span> </span><span>}</span><span>)</span><span>.</span><span>hours</span><span>;</span><span></span><br/></span><span><span>  </span><span></span><br/></span><span><span>  </span><span></span><br/></span><span><span></span><br/></span><span><span>laterHours </span><span>=</span><span> zdt</span><span>.</span><span>add</span><span>(</span><span>{</span><span> hours</span><span>:</span><span> </span><span>24</span><span> </span><span>}</span><span>)</span><span>;</span><span></span><br/></span><span><span>  </span><span></span><br/></span><span><span>  </span><span></span><br/></span><span><span>  </span><span></span><br/></span><span><span>laterHours</span><span>.</span><span>since</span><span>(</span><span>zdt</span><span>,</span><span> </span><span>{</span><span> largestUnit</span><span>:</span><span> </span><span>&#39;hour&#39;</span><span> </span><span>}</span><span>)</span><span>.</span><span>hours</span><span>;</span><span> </span><br/></span></code></pre></div></div>
<h4 id="computing-differences-between-dates">Computing differences between dates.<a href="#computing-differences-between-dates" aria-label="Direct link to Computing differences between dates." title="Direct link to Computing differences between dates.">​</a></h4>
<p>Temporal offers a method named <code>.until</code> which computes the difference between the two times represented by zonedDateTime and other, optionally rounds it, and returns it as a Temporal.Duration object. If other is earlier than zonedDateTime then the resulting duration will be negative. If using the default options, adding the returned Temporal.Duration to zonedDateTime will yield other.</p>
<p>This might look like an obvious operation but I encourage you to <a href="https://tc39.es/proposal-temporal/docs/zoneddatetime.html#until" target="_blank" rel="noopener noreferrer">read the full spec</a> to understand the nuances of it.</p>

<p>The Temporal API represents a revolutionary shift in how time is handled in JavaScript, making it one of the few languages that address this issue comprehensively. In this article, we&#39;ve only scratched the surface by discussing the difference between human-readable dates (or wall clock time) and UTC dates, and how the Temporal.ZonedDateTime object can be used to accurately represent the former.</p>
<p>In future articles, we&#39;ll explore other fascinating objects such as Instant, PlainDate, and Duration.</p>
<p>I hope you enjoyed this introduction.</p>
<p>Happy coding! :)</p></div></div>
  </body>
</html>
