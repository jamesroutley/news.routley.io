<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://positive.security/blog/ms-officecmd-rce">Original</a>
    <h1>Windows 10 RCE: The exploit is in the link</h1>
    
    <div id="readability-page-1" class="page"><div><p>-- MARKDOWN --</p><p># TL;DR</p><p>- We discovered a drive-by code execution vulnerability on Windows 10 via IE11/Edge Legacy and MS Teams, triggered by an argument injection in the Windows 10/11 default handler for `ms-officecmd:` URIs</p><p>---</p><p># Exploitation/Demo</p><p>Code execution is triggered by a malicious website which performs a Javascript redirect to a crafted `ms-officecmd:` URI (a scheme used by the Microsoft Office UWP app to launch other Office desktop applications). We exploit an argument injection vulnerability in the URI handler and bypass a security measure in Electron to inject an arbitrary OS command via the `--gpu-launcher` parameter of the Microsoft Teams Electron app.</p><p><figure>
<video preload="none" poster="https://uploads-ssl.webflow.com/5f6498c074436c50c016e745/61a62a90d327716ff1b3cf15_1_RCE_driveby-poster-00001.jpg" controls="" data-wf-ignore="true" data-object-fit="cover">
<source src="https://uploads-ssl.webflow.com/5f6498c074436c50c016e745/61a62a90d327716ff1b3cf15_1_RCE_driveby-transcode.mp4" data-wf-ignore="true"/>
<source src="https://uploads-ssl.webflow.com/5f6498c074436c50c016e745/61a62a90d327716ff1b3cf15_1_RCE_driveby-transcode.webm" data-wf-ignore="true"/></video>
<figcaption>Drive-by RCE on Windows 10 via MS Edge</figcaption>
</figure></p><p>This is the crafted `ms-officecmd:` URI used in the video above (JSON indented for readability):</p><p>```jsx</p><p>Browsers other than Internet Explorer and Microsoft Edge Legacy show a rather inconspicuous confirmation dialog before opening the malicious URI:</p><figure><a href="https://positive.security/#zoom" target="_blank"><p><img src="https://uploads-ssl.webflow.com/5f6498c074436c349716e747/61477de31e40b0491aface87_Edge_Chrome_FF_comparison.png" loading="lazy" alt=""/></p></a><figcaption>Different browsers displaying a confirmation dialog which is missing in IE and Edge Legacy</figcaption></figure><p>As an alternative to exploitation through malicious websites, crafted `ms-officecmd:` URIs could also be delivered via [desktop applications performing unsafe URL handling](https://positive.security/blog/url-open-rce).</p><p>Precondition for this particular exploit is to have Microsoft Teams installed but not running. In the following sections we will also show how the scheme and argument injection could be abused in other ways, with and without the help of MS Teams.</p><p>Note: While Windows 11 was not yet released at the time of this research, it&#39;s also (still) affected by the same argument injection vulnerability in the `ms-officecmd:` URI handler.</p><p>In case you&#39;re interested in all technical details, but short on time, you can also skip directly to the [vulnerability report we submitted to Microsoft](#original-msrc-report).</p><p>---</p><p># ToC / Research journey</p><p>## Motivation: Improving the malicious URI attack scenario</p><p>In January of 2021 we spent some time analyzing how popular desktop applications handle user supplied URIs, and found code execution vulnerabilities in most of them. A detailed write-up of our findings can be found in [our post from April 2021](https://positive.security/blog/url-open-rce).</p><p>To showcase exploitation of our findings on Windows, we mostly utilized file related schemes (`nfs`, `dav`, `file`, ...) coupled with executables/jar files hosted on internet accessible fileshares. One caveat of those payloads is that they either require Java to be installed or a dialog to run the executable to be confirmed.</p><p>Along the way, we also discovered a [code execution vulnerability in WinSCP&#39;s URI handling](https://positive.security/blog/url-open-rce#bonus-vulnerability-winscp). WinSCP is the de facto standard for handling various URI schemes on Windows, but it does not come pre-installed with the operating system.</p><p>Vulnerabilities in 3rd-party URI handlers are not a novelty, prior examples include:</p><p>- [Code execution in the `steam:` URI handler (2012)](https://revuln.com/files/ReVuln_Steam_Browser_Protocol_Insecurity.pdf)</p><p>We wanted to further improve on the attack scenario based on malicious URIs by finding a code execution vulnerability in a URI handler that comes pre-installed with Windows.</p><p>## Enumerating URI handlers in Windows 10</p><p>Windows 10 comes with an abundance of custom URI handlers relating to different OS features or other Microsoft software.</p><p>For our purposes, a sufficiently convenient way of finding registered URI handlers was to repeatedly search for &#39;URL Protocol&#39; in the registry:</p><figure><a href="https://positive.security/#zoom" target="_blank"><p><img src="https://uploads-ssl.webflow.com/5f6498c074436c349716e747/61477fcaf2b22753a8d46ee6_URL_protocol_registry.png" loading="lazy" alt=""/></p></a><figcaption>Finding URI handlers in the Windows registry</figcaption></figure><p>Any hit in `Computer\HKEY_CLASSES_ROOT\*` means that the name of the containing folder corresponds to the scheme for a registered URI handler. The registry also contains more information on each of these, like the shell command used to invoke the corresponding handler. A very simple and more hands-on approach to help find out what the scheme is related to is to type it into the browser address bar, followed by a `:`, and hit enter: </p><p><figure>
<video preload="none" poster="https://uploads-ssl.webflow.com/5f6498c074436c50c016e745/61477b9d0b4f4927aadf0973_calculator_edge-poster-00001.jpg" controls="" data-wf-ignore="true" data-object-fit="cover">
<source src="https://uploads-ssl.webflow.com/5f6498c074436c50c016e745/61477b9d0b4f4927aadf0973_calculator_edge-transcode.mp4" data-wf-ignore="true"/>
<source src="https://uploads-ssl.webflow.com/5f6498c074436c50c016e745/61477b9d0b4f4927aadf0973_calculator_edge-transcode.webm" data-wf-ignore="true"/></video>
<figcaption>Opening calc.exe via the `calculator:` scheme from Edge</figcaption>
</figure></p><p>## ms-officecmd: Interesting due to its apparent complexity</p><p>The `ms-officecmd:` scheme immediately grabbed our attention due to its promising name: MS Office is a very complex suite of applications with many legacy features and a long history of exploitability. On top of that, the scheme ends in the abbreviation for &#39;command&#39;, which suggests even more complexity and potential for injection.</p><p>When we started playing around with it, we noticed an executable called `LocalBridge.exe` which would briefly run, but to no apparent external effect. To gain more insight on what happened, we checked the Windows Event Log, which contained some very useful information:</p><figure><a href="https://positive.security/#zoom" target="_blank"><p><img src="https://uploads-ssl.webflow.com/5f6498c074436c349716e747/61478065bf08d42425b6477e_event_log_ms-officecmd.png" loading="lazy" alt=""/></p></a><figcaption>.NET JsonReaderException triggered by opening the URI `ms-officecmd:invalid`</figcaption></figure><p>The same exception did not occur when opening a URI consisting of the empty, valid JSON payload `ms-officecmd:{}`, giving us the first hint for what the structure of a valid URI looks like.</p><p>Observing JSON parsing in the URI handler ultimately confirmed that `ms-officecmd:` URIs have potential to do very complex things. We were determined to find out exactly what they can do.</p><p>## Reversing LocalBridge.exe and AppBridge.dll</p><p>To find out more, we decided to start with decompiling `LocalBridge.exe`:</p><figure><a href="https://positive.security/#zoom" target="_blank"><p><img src="https://uploads-ssl.webflow.com/5f6498c074436c349716e747/614780860f2a9dec3f2a394b_LocalBridge_dotpeek.png" loading="lazy" alt=""/></p></a><figcaption>Decompiled source of `LocalBridge.exe`: URI validation and `LaunchOfficeAppValidated` call (dotPeek)</figcaption></figure><p>The C# code held more information on the structure of a valid JSON payload. With its help we started experimenting again:</p><p>```jsx</p><p>Unfortunately, this did not provoke any observable behavior from `LocalBridge.exe`. Going deeper meant analyzing `AppBridge.dll` next, since it contained the `LaunchOfficeAppValidated` method which the JSON payload is ultimately passed to:</p><figure><a href="https://positive.security/#zoom" target="_blank"><p><img src="https://uploads-ssl.webflow.com/5f6498c074436c349716e747/614780b26b5ac50da3df267a_LocalBridge_dotPeek_2.png" loading="lazy" alt=""/></p></a><figcaption>Decompiled source of `LocalBridge.exe`: `LaunchOfficeAppValidated` imported from `AppBridge.dll` (dotPeek)</figcaption></figure><p>We extracted some more potential JSON attribute names by disassembling the native `AppBridge.dll` library, but it was not immediately obvious how to use them.</p><figure><a href="https://positive.security/#zoom" target="_blank"><p><img src="https://uploads-ssl.webflow.com/5f6498c074436c349716e747/614780e45eacc32e9affa4bf_AppBridge_Ghidra.png" loading="lazy" alt=""/></p></a><figcaption>`AppBridge.dll`: Relevant unicode strings (from Ghidra)</figcaption></figure><p>## Debugging the Office UWP app (Electron PWA)</p><p>When the analysis of `LocalBridge.exe`/`AppBridge.dll` did not yield the desired results quickly, we picked up a different approach in parallel: Rather than dissecting the application that handles `ms-officecmd:` URIs, we could try to inspect an application which generates such URIs.</p><p>While we did not know for certain which applications do so, we had previously stumbled across the Office UWP app, which presented itself as a likely candidate due to the following reasons:</p><p>- The app can be opened via the custom scheme `ms-officeapp:`, which looks awfully similar to the subject of our research, `ms-officecmd:`</p><figure><a href="https://positive.security/#zoom" target="_blank"><p><img src="https://uploads-ssl.webflow.com/5f6498c074436c349716e747/614780fc608f85273c932c67_ms-officeapp.png" loading="lazy" alt=""/></p></a><figcaption>The Office UWP app comes pre-installed on Windows 10</figcaption></figure><p>Intuition suggested that the `ms-officecmd:` scheme was used internally whenever the Office UWP app triggered an Office desktop application to be opened. That suspicion was confirmed later.</p><p>Using Microsoft&#39;s own &#39;Edge DevTools Preview&#39; app, we were able to hook into the process and debug the Office UWP app. </p><figure><a href="https://positive.security/#zoom" target="_blank"><p><img src="https://uploads-ssl.webflow.com/5f6498c074436c349716e747/61478112b7f7db077403aac9_Edge_DevTools_start_screen.png" loading="lazy" alt=""/></p></a><figcaption>Microsoft Edge DevTools Preview (right) offering the Office UWP app (left) as a debug target</figcaption></figure><p>Getting the information we wanted was quick and easy:</p><p>1. Perform a global source code search (`ctrl` + `shift` + `f`) to find occurrences of our scheme keyword &#39;ms-officecmd&#39;: The only occurrence found was the definition of the `launchProtocol` constant </p><figure><a href="https://positive.security/#zoom" target="_blank"><p><img src="https://uploads-ssl.webflow.com/5f6498c074436c349716e747/6147812e818c75757112868b_Edge_DevTools_search.png" loading="lazy" alt=""/></p></a><figcaption>Office UWP app: `launchProtocol` constant definition (Edge DevTools Preview)</figcaption></figure><figure><p><img src="https://uploads-ssl.webflow.com/5f6498c074436c349716e747/61478144f483042b7d1a1722_Edge_DevTools_debug.png" loading="lazy" alt=""/></p><figcaption>Office UWP app: `ms-officecmd:` JSON payload extracted from local variable `n` (Edge DevTools Preview)</figcaption></figure><p>An even faster alternative to recover the JSON payload is to use the [Microsoft Sysinternals Process Monitor tool](https://docs.microsoft.com/en-us/sysinternals/downloads/procmon) to record `Process Create` events associated with `LocalBridge.exe`:</p><figure><a href="https://positive.security/#zoom" target="_blank"><p><img src="https://uploads-ssl.webflow.com/5f6498c074436c349716e747/614781688259c2430c763009_ProcMon_ms-officecmd.png" loading="lazy" alt=""/></p></a><figcaption>`ms-officecmd:` JSON payload revealed by Process Monitor</figcaption></figure><p>## ms-officecmd: Basic JSON payload structure</p><p>With the extracted JSON payload we were finally able to open Office desktop applications via `ms-officecmd:` URIs. Specifically, the payload extracted from the Office UWP app could be used to open Outlook:</p><p>```jsx</p><p>In subsequent tests it became clear that two properties properties could be manipulated to an immediately observable effect:</p><p>- `appId`: Office desktop application to be opened</p><p>The `name` and `command` properties were validated and treated with lower priority, while the `id` property seemed to only be used for telemetry.</p><p>On a machine with a basic Office installation, we enumerated the following `appId` mappings:</p><p>- `1`: Access</p><p>## Outlook phishing issue</p><p>The first noteworthy finding was that when an `http(s)` URL was provided in the `filename` property, Outlook would render the respective webpage in an IE11 powered embedded webview. No indication of the webpage&#39;s origin or even the fact that the displayed content stemmed from an external webpage was given. This behavior could be abused to mount very believable phishing attacks, especially since `mailto:` links are, depending on local configuration, expected to open the user&#39;s email program:</p><p><figure>
<video preload="none" poster="https://uploads-ssl.webflow.com/5f6498c074436c50c016e745/61477c10818c75024c127499_Outlook_phishing-poster-00001.jpg" controls="" data-wf-ignore="true" data-object-fit="cover">
<source src="https://uploads-ssl.webflow.com/5f6498c074436c50c016e745/61477c10818c75024c127499_Outlook_phishing-transcode.mp4" data-wf-ignore="true"/>
<source src="https://uploads-ssl.webflow.com/5f6498c074436c50c016e745/61477c10818c75024c127499_Outlook_phishing-transcode.webm" data-wf-ignore="true"/></video>
<figcaption>Phishing attack using `ms-officecmd:` and Outlook: The login form displayed inside of the Outlook window is an attacker controlled webpage</figcaption>
</figure></p><p>## Outlook code execution issue</p><p>Outlook&#39;s unexpected opening behavior could also be abused to achieve code execution with some more user interaction. While Outlook does not allow `file://` URLs, the `C://`  &#34;url scheme&#34; is allowed and later treated as the drive letter to a local path. Furthermore, we add a trailing `/` which bypasses a file extension check in `AppBridge.dll`, but is later ignored when the executable is opened.</p><p>This PoC requires the user to confirm an additional warning dialog, but we believe that the context is misleading enough to even trick some more advanced users into accepting:</p><p><figure>
<video preload="none" poster="https://uploads-ssl.webflow.com/5f6498c074436c50c016e745/61477c1fdb7104efc54cb2ff_Outlook_RCE-poster-00001.jpg" controls="" data-wf-ignore="true" data-object-fit="cover">
<source src="https://uploads-ssl.webflow.com/5f6498c074436c50c016e745/61477c1fdb7104efc54cb2ff_Outlook_RCE-transcode.mp4" data-wf-ignore="true"/>
<source src="https://uploads-ssl.webflow.com/5f6498c074436c50c016e745/61477c1fdb7104efc54cb2ff_Outlook_RCE-transcode.webm" data-wf-ignore="true"/></video>
<figcaption>RCE attack with user interaction from Chrome using `ms-officecmd:` and Outlook </figcaption>
</figure></p><p>Here is what happens when the link on the malicious webpage is clicked:</p><p>1. A malicious executable named `outlook.exe` is saved to the victim&#39;s download folder by dynamically adding an iframe that points to the exe (in our demo, this is a renamed &#39;PuTTY&#39; executable)</p><p>## `filename` property argument injection</p><p>The issues shown above abused the `filename` property by providing values that were unexpected and mishandled only in the context of the Outlook application, but could be totally valid and expected in the more abstract context of the `ms-officecmd:` URI handler: In addition to local file paths with a multitude of different file extensions, most Office applications allow directly opening documents hosted on the web via `http(s)` URLs, as is the case with files that live in Microsoft SharePoint/OneDrive.</p><p>Our next discovery pushes the abuse potential much further by attacking the way in which the `filename` property is processed by the URI handler itself. Even without a fully detailed understanding of the inner workings of `AppBridge.dll`, it is relatively safe to assume that in order to open the specified Office application with the specified parameters, the URI handler would ultimately either generate and execute a shell command, or run its executable directly. In any case, the attacker-controlled `filename` property would need to be passed either as part of the shell command or an argument. When we experimented with common command and argument injection techniques, we found that it was possible to break out of the filename specification with a simple `&#34;  `  (double quote + space) sequence.</p><p>This argument injection represents the most significant issue at the core of the discoveries that are outlined here. Before we get into actual exploitation, here&#39;s a video demonstrating the argument injection at its most basic level:</p><p><figure>
<video preload="none" poster="https://uploads-ssl.webflow.com/5f6498c074436c50c016e745/61477c466b5ac58522df1280_Word_argument_injection_splash_screen-poster-00001.jpg" controls="" data-wf-ignore="true" data-object-fit="cover">
<source src="https://uploads-ssl.webflow.com/5f6498c074436c50c016e745/61477c466b5ac58522df1280_Word_argument_injection_splash_screen-transcode.mp4" data-wf-ignore="true"/>
<source src="https://uploads-ssl.webflow.com/5f6498c074436c50c016e745/61477c466b5ac58522df1280_Word_argument_injection_splash_screen-transcode.webm" data-wf-ignore="true"/></video>
<figcaption>Using the `filename` argument injection to inject a `/q` switch: Note the absence of the blue splash (loading) screen when the second URI is opened</figcaption>
</figure></p><p>This is the URI used in the video (the quote needs to be escaped to not break the JSON):</p><p>```jsx</p><p>## Loading malicious Word/Excel add-ins</p><p>After discovering the possibility to inject arguments into the launch commands for Office applications, our next step naturally was to check which kind of arguments were available to us. Out of the [documented command line switches for Microsoft Office products](https://support.microsoft.com/en-us/office/command-line-switches-for-microsoft-office-products-079164cd-4ef5-4178-b235-441737deb3a6), the ones pertaining to the loading of add-ins on startup seemed most promising.</p><p>We experimented with the following add-in types:</p><p>- plain `.dll` and `.wll` files</p><p>Unfortunately we were not able to make the application properly load any of our crafted add-ins on startup.</p><figure><a href="https://positive.security/#zoom" target="_blank"><p><img src="https://uploads-ssl.webflow.com/5f6498c074436c349716e747/61478279608f851ad3933be7_Word_AddIn.png" loading="lazy" alt=""/></p></a><figcaption>Attempting to use the `-l` switch to load a Word add-in fails as the application seemingly interprets it as a document file to open</figcaption></figure><p>## Teams MITM, authentication leak using `--host-rules`</p><p>While our argument injection experiments with the document-focused Office applications did not produce any more findings that would be of much interest for real world attackers, there was another group of applications which showed a lot of promise: Microsoft Teams and Skype are based on the Electron framework, and therefore equipped with a wide range of useful [Electron command line arguments](https://www.electronjs.org/docs/api/command-line-switches) and [Node.js command line arguments](https://nodejs.org/api/cli.html).</p><p>The first of these arguments whose abuse potential we were able to confirm is `--host-rules`. This argument can be used to remap IP addresses and host names, causing all relevant network traffic of the application to be directed to the chosen target. When using a new domain as the map destination, there are no TLS errors as long as TLS is correctly set up for the new domain. By adding the `--ignore-certificate-errors` switch, not even this is needed. With the help of a reverse proxy, or even just a listening web server, an attacker could extract all sensitive information sent to Microsoft Teams&#39; back-end services, including authentication tokens and messages. A reverse proxy could also be leveraged to modify API responses and impersonate any MS Teams user towards the victim.</p><p>When we tried to craft a valid payload in order to inject those arguments we had to overcome two more hurdles:</p><p>1. As a [fix for the critical CVE-2018-1000006](https://www.electronjs.org/blog/protocol-handler-fix), Electron changed their command line parsing logic to drop additional arguments after a URI. Checking the source code, we identified an [exception for 1-letter URI schemes](https://github.com/electron/electron/blob/4b70ccde26c057a3376c52eb563431943ebc3be6/shell/app/command_line_args.cc#L18-L20) to skip this filtering for Windows file paths that include drive letters (i.e. `C:/`). This allowed us to inject Electron arguments after a bogus `filename` prefix like `a:/b/`, which is accepted by both Electron and `AppBridge.dll`</p><p><figure>
<video preload="none" poster="https://uploads-ssl.webflow.com/5f6498c074436c50c016e745/61477c3aa5926303bb6bb8b3_Teams_host-rules_MITM-poster-00001.jpg" controls="" data-wf-ignore="true" data-object-fit="cover">
<source src="https://uploads-ssl.webflow.com/5f6498c074436c50c016e745/61477c3aa5926303bb6bb8b3_Teams_host-rules_MITM-transcode.mp4" data-wf-ignore="true"/>
<source src="https://uploads-ssl.webflow.com/5f6498c074436c50c016e745/61477c3aa5926303bb6bb8b3_Teams_host-rules_MITM-transcode.webm" data-wf-ignore="true"/></video>
<figcaption>Redirecting MS Teams https traffic to our own server using injected `--host-rules` and `--ignore-certificate-errors` arguments</figcaption>
</figure></p><p>Please note that in this demo video the requests are not forwarded to Team&#39;s real backend, resulting in the connection error. </p><p>This is the URI used in the video:</p><p>```jsx</p><p>## Teams/Skype code execution from local network via  `--inspect` debugger</p><p>Another promising argument was the Node.js `--inspect` parameter, which can be used to debug the Node.js Javascript environment. The parameter specifies the network interface and port number which can be used to connect a debugger. For security reasons, debugging is only made available through the local interface `127.0.0.1` by default. In the video below we override that setting via the `--inspect=&#34;0.0.0.0:28966&#34;` switch, so that debugger connections are accepted on port 28966 for any network interface. Once the debugger is connected, we utilize a standard Node.js library to execute our command: `require(&#34;child_process&#34;).exec(&#34;&lt;command&gt;&#34;)`</p><p>Crafting a valid payload again required a bit of trickery:</p><p>1. Due to the way that the `filename` parameter is processed when Skype is opened this way, an additional `&#34;` character is required after the fake file name before other parameters can be injected</p><p><figure>
<video preload="none" poster="https://uploads-ssl.webflow.com/5f6498c074436c50c016e745/61477c2ddb710414944cb307_Skype_inspect_exec_local_network-poster-00001.jpg" controls="" data-wf-ignore="true" data-object-fit="cover">
<source src="https://uploads-ssl.webflow.com/5f6498c074436c50c016e745/61477c2ddb710414944cb307_Skype_inspect_exec_local_network-transcode.mp4" data-wf-ignore="true"/>
<source src="https://uploads-ssl.webflow.com/5f6498c074436c50c016e745/61477c2ddb710414944cb307_Skype_inspect_exec_local_network-transcode.webm" data-wf-ignore="true"/></video>
<figcaption>‍Local network exploit showcased by clicking a malicious link inside of a VM and connecting a debugger to the Skype process from the host system</figcaption>
</figure></p><p>This is the URI used in the video:</p><p>```jsx</p><p>Note that for susceptible setups, this attack could also be combined with, for example, [DNS rebinding](https://en.wikipedia.org/wiki/DNS_rebinding), or (the recently improved) [NAT Slipstreaming](https://github.com/samyk/slipstream) techniques to achieve RCE through the browser without the need for local network access.</p><p>## Teams code execution via `--inspect` debugger and MITM with SOP bypass</p><p>We have not actually confirmed this potential exploit to work, but wanted to share the idea for it regardless, because we found its setup to be kind of fun. Ultimately we never attempted to exploit it, because we achieved full RCE using the method described in the next section before we were ready to resort to a setup as complex as what would be required here.</p><p>The idea is to combine the `--host-rules` and `--inspect` switches from the sections above with the `--disable-web-security` Chromium switch, which should allow us to utilize our control of the Chromium Javascript context to connect to the Node.js debugger and execute arbitrary commands:</p><p>1. MS Teams is launched via a malicious website, with the following parameters injected:</p><p>## Teams code execution via `--gpu-launcher` command injection</p><p>With the last discovery we made before starting to write up our report to Microsoft, we finally arrived at arbitrary code execution via a malicious `ms-officecmd:` URI. Precondition for this PoC is to have MS Teams installed but not running.</p><p>Our malicious payload is based on [the exploit for CVE-2018-1000006](https://www.exploit-db.com/exploits/44357), which makes use of the `--gpu-launcher` argument to inject an arbitrary command that is executed when the Electron application launches. To make the exploit work with our argument injection and MS Teams, we need to:</p><p>1. Start the `filename` parameter with a 1-character URI scheme to pass the `AppBridge.dll` validation, but also not run into the Electron-fix for CVE-2018-1000006 (Electron still allows additional arguments after Windows filenames such as &#34;C:&#34;)</p><p><figure>
<video preload="none" poster="https://uploads-ssl.webflow.com/5f6498c074436c50c016e745/61477bcdbefe979d0872fbc7_Edge_Teams_RCE-poster-00001.jpg" controls="" data-wf-ignore="true" data-object-fit="cover">
<source src="https://uploads-ssl.webflow.com/5f6498c074436c50c016e745/61477bcdbefe979d0872fbc7_Edge_Teams_RCE-transcode.mp4" data-wf-ignore="true"/>
<source src="https://uploads-ssl.webflow.com/5f6498c074436c50c016e745/61477bcdbefe979d0872fbc7_Edge_Teams_RCE-transcode.webm" data-wf-ignore="true"/></video>
<figcaption>‍‍Arbitrary code execution with user interaction via MS Edge and Teams</figcaption>
</figure></p><p>A valid payload may look like this:</p><p>```jsx</p><p>Skype comes pre-installed on Windows 10, and multiple instances of Skype can be started in parallel by adding the `--secondary` argument to its launch command. Therefore, if a valid payload was found to exploit this issue via the Skype app, it should work on a default Windows 10 install without any precondition. We attempted to find a valid payload for Skype but were not successful. It seems possible that extra security measures were implemented for Skype when it was [found to be vulnerable to CVE-2018-1000006](https://www.securityfocus.com/bid/102796).</p><p>## Teams drive-by exploit for IE11/Edge Legacy via `--gpu-launcher` command injection</p><p>At this point we were quite satisfied with our findings and started to work on the bug report for Microsoft. Right when we were about to submit the report, we noticed that the MSRC report flow includes a mandatory dropdown selection to specify whether the reported vulnerability can be reproduced on the latest Windows version of the &#39;Windows Insider Dev Channel&#39;. Since Microsoft advertises a quite sizeable bounty of $50k for issues like this, and we assumed that performing due diligence on a mandatory form field would improve the quality rating of our report, we were happy to install the latest version of Windows 10 from that release channel and verify that our exploit works there too.</p><figure><a href="https://positive.security/#zoom" target="_blank"><p><img src="https://uploads-ssl.webflow.com/5f6498c074436c349716e747/614783a2939d3cc30e3f5c15_MSRC_report_flow.png" loading="lazy" alt=""/></p></a><figcaption>MSRC report flow asking &#39;Does this repro on Windows Insider Dev Channel?&#39;</figcaption></figure><p>Much to our surprise the exploit did not only work, but by simply adding some JavaScript which clicks the malicious link, the pre-installed Internet Explorer 11 and (now obsolete) &#39;Legacy&#39; version of MS Edge could be abused to trigger the code execution without any user interaction beyond browsing a malicious website. Since our initial motivation was to improve on our previous attack scenario involving desktop applications which open arbitrary URIs, we had not thought about browser exploitation too much, and just assumed that all modern browsers have somewhat sensible security defaults when dealing with obscure schemes like `ms-officecmd`. That assumption proved to be wrong, as demonstrated here by MS Edge Legacy:</p><p><figure>
<video preload="none" poster="https://uploads-ssl.webflow.com/5f6498c074436c50c016e745/61a62a90d327716ff1b3cf15_1_RCE_driveby-poster-00001.jpg" controls="" data-wf-ignore="true" data-object-fit="cover">
<source src="https://uploads-ssl.webflow.com/5f6498c074436c50c016e745/61a62a90d327716ff1b3cf15_1_RCE_driveby-transcode.mp4" data-wf-ignore="true"/>
<source src="https://uploads-ssl.webflow.com/5f6498c074436c50c016e745/61a62a90d327716ff1b3cf15_1_RCE_driveby-transcode.webm" data-wf-ignore="true"/></video>
<figcaption>Drive-by RCE on Windows 10 via MS Edge</figcaption>
</figure></p><p>This is the payload used in the video above:</p><p>```html</p><p>Armed with this piece of video evidence we submitted our report.</p><p>---</p><p># MSRC response</p><p>## Lack of technical understanding during triage</p><p>Our initial report was erroneously closed as not applicable one day after its submission.</p><p>&gt; [...] Unfortunately your report appears to rely on social engineering to accomplish, which would not meet the definition of a security vulnerability. [...]</p><p>Only after our appeal was the issue reopened and classified as &#34;Critical, RCE&#34;.</p><p>## Reluctant, slow communication</p><p>Our first email was answered after one week. Any communication attempt after that was typically met with several weeks of silence and required us to follow-up (see [timeline](#timeline) below).</p><p>## Insufficient remediation</p><p>The argument injection vulnerability described in this post is still present on fully patched Windows 10 and 11 systems. The patch that was issued after 5 months seems to only affect Teams and Skype in particular. While it does prevent exploitation of the RCE PoCs described here, we believe that there are likely other ways of exploiting the argument injection to achieve code execution.</p><p>After we brought this to Microsoft&#39;s attention, they said they have prepared another patch addressing the argument injection, and gave us the go-ahead to post this write-up independently of its rollout. At the time of publishing this blog post, we could still inject arbitrary arguments and perform e.g. the Outlook phishing attack on fully patched Windows 10/11 systems.</p><p>## No communication to public</p><p>No CVE has been assigned or advisory published to inform the public about the risk, which Microsoft explained as follows:</p><p>&gt; Unfortunately in this case there was no CVE or advisory tied to the report. Most of our CVEs are created to explain to users why certain patches are sent through Windows Update and why they should be installed. Changes to websites, downloads through Defender, or through the Store normally do not get a CVE attached in the same way.  In this case the fix did not go out through Windows Update.</p><p>## Misleading bounty advertisement</p><p>While they paid out $5000 for this report, MS advertises special *[Attack Scenario Awards](https://www.microsoft.com/en-us/msrc/bounty-windows-insider-preview)* for their bug bounty program based on certain criteria. We believe that our report should qualify for the second described scenario of &#39;Demonstrated unauthenticated and unauthorized access to private user data with little or no user interaction&#39;, with a maximum award of $50,000.</p><p>Someone at MS must agree with us, because the report earned us 180 *[Researcher Recognition Program](https://www.microsoft.com/en-us/msrc/researcher-recognition-program)* points, a number which we could only explain as 60 base points with the 3X bonus multiplier for &#39;eligible attack scenarios&#39; applied.</p><p>When we inquired about the bounty amount, we were prompted to provide a PoC which does not require the victim to confirm the additional &#34;This site is trying to open LocalBridge.&#34; dialog:</p><p>&gt; As for the second attack scenario (remote (assumes no prior execution), demonstrated unauthenticated and unauthorized access to private user data with little or no user interaction), this scenario requires no prior execution, and the information leak demonstrated in your case requires interaction to get to code execution.</p><p>We complied and responded with demo videos showing drive-by exploitation on IE 11, even though:</p><p>- We do not believe the &#34;This site is trying to open LocalBridge.&#34; dialog should disqualify the issue from the second attack scenario which explicitly allows for little user interaction</p><p>MS finally rejected a potential adjustment of the bounty amount:</p><p>&gt; [...] the case will remain in scope for the general award. Vulnerabilities that are only reachable by Internet Explorer are not in scope for our bounty program today [...]</p><p>We find this statement to be surprising given that [IE is still &#34;supported&#34; until 2022-06-15](https://blogs.windows.com/windowsexperience/2021/05/19/the-future-of-internet-explorer-on-windows-10-is-in-microsoft-edge/).</p><p>## Timeline</p><p>`2021-03-10` Initial disclosure via [https://msrc.microsoft.com/](https://msrc.microsoft.com/)</p><p>---</p><p>## Windows 10 remote code execution via insecure `ms-officecmd:` default URI handler</p><p># Summary</p><p>When a Windows 10 user either visits a malicious website with Edge, or clicks on a malicious &#34;ms-officecmd:&#34;-link in any application, arbitrary commands can be executed on the victim&#39;s computer. A malicious link can look like this:</p><p>```jsx</p><p>A demo video showcasing drive-by exploitation on the latest Windows Insider Dev Channel via Edge is attached (1_RCE_driveby.mp4; PoC: 1_RCE_driveby.html).</p><p>Payload Summary:</p><p>- The overall JSON structure conforms to what LocalBridge.exe/AppBridge.dll expects and instructs this URI handler to call the Microsoft Teams executable (via `appId: 5`) with `filename` as argument</p><p>Besides the direct RCE via `--gpu-launcher`, several other attack scenarios are possible:</p><p>- injecting a `--host-rules` parameter for a full Electron MitM (e.g. to retrieve Teams messages and Auth tokens)</p><p>Even without argument injection, we found the following two attacks to be possible:</p><p>- Starting Outlook with a web URL as parameter opens this web page inside Outlook, allowing for very believable phishing attacks</p><p>The vulnerability is in a default URI handler of Windows 10 and can be exploited from various applications. As an example, the attached 3_Thunderbird_RCE.mp4 showcases exploitation by opening a link in Thunderbird.</p><p># Additional Details</p><p>In a default Windows 10 installation, LocalBridge.exe is associated as the (only) handler for the &#34;ms-officecmd:&#34; URI scheme. The scheme is used internally by the Office PWA application to launch other Microsoft applications, but such links can be opened by any application, e.g. a web browser, email client or instant messanger. LocalBridge.exe (C#) parses the JSON, performs light validation, and when it encounters a &#34;LocalProviders.LaunchOfficeAppForResult&#34; key, calls the &#34;LaunchOfficeAppValidated&#34; function implemented in the native AppBridge.dll.</p><p>We investigated the potential impact of being able to launch those Microsoft apps with a user-chosen URI argument and found two attack vectors using Outlook:</p><p>1. Advanced Phishing: When launching Outlook with a https URL, the website is loaded inside the Outlook UI (without address bar). Showing a cloned Office login page makes for a very believable phishing attack, especially if the user clicked on an email address before and expected Outlook to open. A demo video is attached (4_Outlook_Phishing.mp4).</p><p>Furthermore, it&#39;s possible to inject additional arguments via quote-escaping and URI encoding. We then focused on exploiting launch-able Electron Apps (esp. Teams) due to their complexity and to check whether Electron/Chromium/Node.js parameters can be injected in addition to application-specific command line parameters.</p><p>1. `--gpu-launcher`: Similar to an RCE exploit for CVE-2018-1000006. In this case, the `--disable-gpu-sandbox` flag also needs to be set for successful exploitation. Otherwise, the external process is created, but exits again immediately.</p><p>Another interesting attack vector, that we haven&#39;t fully explored, are application-specific command-line arguments, e.g. the ones listed in [1]. For Office Add-Ins (e.g. `/l` flag in Word), we verified that UNC path locations can be specified, but did not further investigate its impact.</p><p>To achieve interactionless exploitation, we abused an insecure setting in Microsoft Edge, that allows navigation via JavaScript to any URL (with any URI scheme) without any additional user confirmation. As can be seen in the attached 2_Browser_1click_RCE.mp4, other browsers usually ask the user for confirmation before opening external URI handlers.</p><p># Mitigation</p><p>As shown, several smaller issues are responsible for parts of the overall impact. Also, solely fixing the argument injection is not sufficient.</p><p>- As source, it accepts, parses and validates JSON with lots of information (and this JSON can be differently encoded depending on the application the link was opened from)</p><p>Overall, this introduces a high attack surface and probability for inconsistencies. Therefore, we&#39;d recommend, if possible, the removal of this URI handler and a migration to the application-specific URI handlers (e.g. &#34;teams:&#34; and &#34;ms-word:&#34;) to open the applications. Making the URI handler only available to the Office PWA app would also greatly reduce the risk, if somehow possible.</p><p>In addition, we recommend the following actions:</p><p>- Strengthen filename validation in AppBridge.dll:</p><p>Please let us know if we can provide you with any additional information.</p><p>Disclosure Contacts:</p><p>- Fabian Bräunlein, fabian@positive.security</p><p>[1] [https://support.microsoft.com/en-us/office/command-line-switches-for-microsoft-office-products-079164cd-4ef5-4178-b235-441737deb3a6](https://support.microsoft.com/en-us/office/command-line-switches-for-microsoft-office-products-079164cd-4ef5-4178-b235-441737deb3a6)</p><p>[2] [https://www.electronjs.org/blog/protocol-handler-fix](https://www.electronjs.org/blog/protocol-handler-fix)</p><p>[3] [https://github.com/electron/electron/blob/ master/shell/app/command_line_args.cc#L18-L20](https://github.com/electron/electron/blob/master/shell/app/command_line_args.cc#L18-L20)</p><p>[4] List of launchable applications: Access, Delve, Skype, Teams, Excel, SkypeForBusiness, OfficeLens, OneNote, Outlook, Powerpoint, Project, Publisher, Sway, Visio, Word, Office, Office Hub</p></div></div>
  </body>
</html>
