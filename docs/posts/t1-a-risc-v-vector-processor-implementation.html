<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/chipsalliance/t1">Original</a>
    <h1>T1: A RISC-V Vector processor implementation</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto">T1(Torrent-1) is a RISC-V Vector implementation inspired by the Cray X1 vector machine, which is named after <a href="https://www2.eecs.berkeley.edu/Pubs/TechRpts/1997/5411.html" rel="nofollow">T0</a>.</p>
<p dir="auto">T1 aims to implement the RISC-V Vector in lane-based micro-architectures, with intensive chaining support and SRAM-based VRFs.</p>
<p dir="auto">T1 supports standard <code>Zve32f</code> and <code>Zve32x</code>, and <code>VLEN</code>/<code>DLEN</code> can be increased up to <code>64K</code>, hitting the RISC-V Vector architecture bottleneck.</p>
<p dir="auto">T1 ships important vector machine features, e.g., lanes, chaining, and large LSU outstanding by default, but it can also be a general platform for MMIO DSA(Domain-Specific-Accelerators).</p>
<p dir="auto">T1 is designed with <a href="https://github.com/chipsalliance/chisel">Chisel</a> and releasing <code>T1Emulator</code> to users.</p>
<p dir="auto">T1 uses a forked version of the Rocket Core as the scalar part of T1. But we don&#39;t officially support it for now; it can be replaced by any other RISC-V Scalar CPU.</p>
<p dir="auto">T1 only supports bare-metal program loading and execution; test examples can be found in the <code>tests/</code> folder.</p>

<p dir="auto">The generated T1 vector processors can integrate with any RISC-V scalar core.</p>

<ul dir="auto">
<li>Default support for multiple lanes(32-bits per-lane).</li>
<li>Load to Multiple-Exec to Store to Load chaining-ability.</li>
<li>RAM-based configurable banked SRAM with DualPort, TwoPort, and SinglePort supports.</li>
<li>Pipelined/Asynchronous Vector Function Unit (VFU) with comprehensive chaining support. Allocating 4 VFU slots per lane, multiple and different VFU can be attached to the corresponding lane.</li>
<li>T1 lane execution can skip masked elements for the mask instructions that are all masked to accommodate the sparsity of the mask.</li>
<li>We use a direct-connected lane interconnection for <code>widen</code> and <code>narrow</code> instructions.</li>
</ul>
<div dir="auto"><h3 tabindex="-1" dir="auto">Load Store Unit (LSU) Profiles:</h3><a id="user-content-load-store-unit-lsu-profiles" aria-label="Permalink: Load Store Unit (LSU) Profiles:" href="#load-store-unit-lsu-profiles"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<ul dir="auto">
<li>Configurable banked memory port.</li>
<li>Instruction-level Out-of-Order (OoO) load/store, leveraging the high memory bandwidth of the vector cache.</li>
<li>Configurable outstanding size to mitigate memory latency.</li>
<li>Fully chained to the Vector Function Unit (VFU).</li>
</ul>
<div dir="auto"><h2 tabindex="-1" dir="auto">Design Space Exploration (DSE) Principles and Methodology:</h2><a id="user-content-design-space-exploration-dse-principles-and-methodology" aria-label="Permalink: Design Space Exploration (DSE) Principles and Methodology:" href="#design-space-exploration-dse-principles-and-methodology"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Compared to some commercial Out-of-Order core designs with advanced speculation schemes, the architecture of the vector machine is relatively straightforward. Instead of dedicating the area to a Branch Prediction Unit (BPU), Rename and Reorder Buffer(ROB) or prefetching. Vector instructions provide enough metadata to allow T1 to run for thousands of elements without requiring a speculation scheme.</p>
<p dir="auto">T1 is designed to balance the throughput, area, and frequency among the VRF, VFU, and LSU. With the T1 generator, it can be easily configured to achieve either high efficiency or high performance, depending on the desired trade-offs, even adding function units or purging out FPU, which supports <code>Zve32f</code> and remains <code>Zve32x</code> only.</p>
<p dir="auto">The methodology for the micro-architecture tuning is based on this trade-off idea:</p>
<p dir="auto"><strong>The overall vector core frequency should be limited by the VRF memory</strong>. Based on this principle, we could retime the VFU pipeline to multiple stages to meet the frequency target. For a small, highly efficient core, designers should choose high-density memory (which usually doesn’t offer high frequency) and reduce the VFU pipeline stages. For a high-performance core, they should increase the pipeline stages and use the fastest possible SRAM for the VRFs.</p>
<p dir="auto"><strong>The bandwidth bottleneck is limited by VRF SRAM</strong>. For each VFU, if it is operating, it might encounter hazards due to the limited VRF memory ports. Users can increase the banking size of VRFs. The banked VRF is forcing an all-to-all crossbar between the VFU and VRF banks, which has a heavy impact on the physical design. Users should trade off the Exec and VRF bandwidth by limiting the connection between Execution and VRFs.</p>
<p dir="auto"><strong>The bandwidth of the LSU is limited by the memory ports</strong>: The LSU is also configurable to provide an insane memory bandwidth with a small overhead. It contains these limitations to bus:</p>
<ul dir="auto">
<li>Requiring FIFO (first-in-first-out) ordering in bus. If FIFO is not implemented in the bus IP, a large reorder unit will be implemented due to extremely large outstanding <code>sourceId</code> in TileLink, like <code>AWID</code>, <code>ARID</code>, <code>WID</code>, <code>RID</code>, <code>BID</code> in AXI protocol.</li>
<li>Requiring no-MMU for high-bandwidth-ports, since we may query <code>DLEN/32</code> elements from TLB for each cycle in an indexed load store mode, while there might be an unreasonable page fault outstandings. For now, these features are not supported in the current Rocket Core.</li>
<li>No Coherence support: any high-performance cache cannot bear T1’s <code>DLEN/32</code> queries.</li>
</ul>
<p dir="auto">The key point of T1 LSU is that it is designed to support multiple memory banks. Each memory bank has 3 MSHRs for outstanding memory instructions, while every instruction can record thousands of transaction states in the FIFO order. T1 also supports instruction-level interleaved vector load/store to maximize the use of memory ports for high memory bandwidth.</p>
<p dir="auto">For tuning the ideal vector machines, follow these performance-tuning methodologies:</p>
<ul dir="auto">
<li>Determine DLEN for your parallelism requirement, AKA the required bandwidth for the Vector unit.</li>
<li>Matching bandwidth for VRF, VFU, and LSU.</li>
<li>Based on your workload, determine the required VLEN as it dictates the VRF memory area.</li>
<li>Choose the memory type for the VRF, which will determine the chip frequency.</li>
<li>Run the T1Emulator and PnR for your workloads to tune micro-architecture.</li>
</ul>

<p dir="auto">We have a IP emulator under the directory <code>./t1emu</code>. <a href="https://github.com/riscv/riscv-isa-sim">Spike</a> is used as the reference scalar core, integrated with the verilated vector IP. Under the online differential-test strategy, the emulator compares the load/store and VRF writes between Spike and T1 to verify T1’s correctness.</p>

<div dir="auto" data-snippet-clipboard-copy-content="docker pull ghcr.io/chipsalliance/t1-$config:latest
# For example, config with dlen 256 vlen 512 support
docker pull ghcr.io/chipsalliance/t1-blastoise:latest"><pre>docker pull ghcr.io/chipsalliance/t1-<span>$config</span>:latest
<span><span>#</span> For example, config with dlen 256 vlen 512 support</span>
docker pull ghcr.io/chipsalliance/t1-blastoise:latest</pre></div>
<p dir="auto">Or build the image using nix and load it into docker</p>
<div dir="auto" data-snippet-clipboard-copy-content="nix build -L &#34;.#t1.$config.release.docker-image&#34; --out-link docker-image.tar.gz
docker load -i ./docker-image.tar.gz"><pre>nix build -L <span><span>&#34;</span>.#t1.<span>$config</span>.release.docker-image<span>&#34;</span></span> --out-link docker-image.tar.gz
docker load -i ./docker-image.tar.gz</pre></div>
<blockquote>
<p dir="auto">Using nix to build docker-image required KVM feature, so this derivation might not be available
for some platform that has no QEMU/KVM support.</p>
</blockquote>

<p dir="auto">We use Nix Flake as our primary build system. If you have not installed nix, install it following the <a href="https://nixos.org/manual/nix/stable/installation/installing-binary.html" rel="nofollow">guide</a>, and enable flake following the <a href="https://nixos.wiki/wiki/Flakes#Enable_flakes" rel="nofollow">wiki</a>. Or you can try the <a href="https://github.com/DeterminateSystems/nix-installer">installer</a> provided by Determinate Systems, which enables flake by default.</p>

<p dir="auto">T1 includes a hardware design written in Chisel and an emulator powered by a verilator. The elaborator and emulator can be run with various configurations. Configurations can be represented by your favorite Pokemon! The only limitation is that T1 uses <a href="https://pokemon.fandom.com/wiki/Types" rel="nofollow">Pokemon type</a> to determine <code>DLEN</code>, aka lane size, based on the corresponding map:</p>
<markdown-accessiblity-table><table>
<thead>
<tr>
<th>Type</th>
<th>DLEN</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://bulbapedia.bulbagarden.net/wiki/Grass_(type)" rel="nofollow">Grass</a></td>
<td>32</td>
</tr>
<tr>
<td><a href="https://bulbapedia.bulbagarden.net/wiki/Fire_(type)" rel="nofollow">Fire</a></td>
<td>64</td>
</tr>
<tr>
<td><a href="https://bulbapedia.bulbagarden.net/wiki/Flying_(type)" rel="nofollow">Flying</a></td>
<td>128</td>
</tr>
<tr>
<td><a href="https://bulbapedia.bulbagarden.net/wiki/Water_(type)" rel="nofollow">Water</a></td>
<td>256</td>
</tr>
<tr>
<td><a href="https://bulbapedia.bulbagarden.net/wiki/Fighting_(type)" rel="nofollow">Fighting</a></td>
<td>512</td>
</tr>
<tr>
<td><a href="https://bulbapedia.bulbagarden.net/wiki/Electric_(type)" rel="nofollow">Electric</a></td>
<td>1K</td>
</tr>
<tr>
<td><a href="https://bulbapedia.bulbagarden.net/wiki/Ground_(type)" rel="nofollow">Ground</a></td>
<td>1K</td>
</tr>
<tr>
<td><a href="https://bulbapedia.bulbagarden.net/wiki/Psychic_(type)" rel="nofollow">Psychic</a></td>
<td>2K</td>
</tr>
<tr>
<td><a href="https://bulbapedia.bulbagarden.net/wiki/Rock_(type)" rel="nofollow">Dark</a></td>
<td>4K</td>
</tr>
<tr>
<td><a href="https://bulbapedia.bulbagarden.net/wiki/Ice_(type)" rel="nofollow">Ice</a></td>
<td>8K</td>
</tr>
<tr>
<td><a href="https://bulbapedia.bulbagarden.net/wiki/Fairy_(type)" rel="nofollow">Fairy</a></td>
<td>16K</td>
</tr>
<tr>
<td><a href="https://bulbapedia.bulbagarden.net/wiki/Ghost_(type)" rel="nofollow">Ghost</a></td>
<td>32K</td>
</tr>
<tr>
<td><a href="https://bulbapedia.bulbagarden.net/wiki/Dragon_(type)" rel="nofollow">Dragon</a></td>
<td>64K</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<div dir="auto"><p dir="auto"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p><p dir="auto">The <code>Bug</code> type is reserved to submit bug report by users.</p>
</div>
<p dir="auto">Users can add their own pokemon to <code>configgen/src/Main.scala</code> to add configurations with different variations.</p>
<p dir="auto">You can build its components with the following commands:</p>
<div dir="auto" data-snippet-clipboard-copy-content="$ nix build .#t1.elaborator  # the wrapped jar file of the Chisel elaborator

# Build T1
$ nix build .#t1.&lt;config-name&gt;.t1.rtl  # the elaborated IP core .sv files

# Build T1 Emu
$ nix build .#t1.&lt;config-name&gt;.t1emu.rtl                    # the elaborated IP core .sv files
$ nix build .#t1.&lt;config-name&gt;.t1emu.verilator-emu          # build the IP core emulator using verilator
$ nix build .#t1.&lt;config-name&gt;.t1emu.vcs-emu --impure       # build the IP core emulator using VCS w/ VCS environment locally
$ nix build .#t1.&lt;config-name&gt;.t1emu.vcs-emu-trace --impure # build the IP core emulator using VCS w/ trace support

# Build T1 Rocket emulator
$ nix build .#t1.&lt;config-name&gt;.t1rocketemu.rtl            # the elaborated T1 with Rocket core .sv files
$ nix build .#t1.&lt;config-name&gt;.t1rocketemu.verilator-emu  # build the t1rocket emulator using verilator
$ nix build .#t1.&lt;config-name&gt;.t1rocketemu.vcs-emu        # build the t1rocket emulator using VCS
$ nix build .#t1.&lt;config-name&gt;.t1rocketemu.vcs-emu-trace  # build the t1rocket emulator using VCS with trace support"><pre>$ nix build .<span><span>#</span>t1.elaborator  # the wrapped jar file of the Chisel elaborator</span>

<span><span>#</span> Build T1</span>
$ nix build .<span><span>#</span>t1.&lt;config-name&gt;.t1.rtl  # the elaborated IP core .sv files</span>

<span><span>#</span> Build T1 Emu</span>
$ nix build .<span><span>#</span>t1.&lt;config-name&gt;.t1emu.rtl                    # the elaborated IP core .sv files</span>
$ nix build .<span><span>#</span>t1.&lt;config-name&gt;.t1emu.verilator-emu          # build the IP core emulator using verilator</span>
$ nix build .<span><span>#</span>t1.&lt;config-name&gt;.t1emu.vcs-emu --impure       # build the IP core emulator using VCS w/ VCS environment locally</span>
$ nix build .<span><span>#</span>t1.&lt;config-name&gt;.t1emu.vcs-emu-trace --impure # build the IP core emulator using VCS w/ trace support</span>

<span><span>#</span> Build T1 Rocket emulator</span>
$ nix build .<span><span>#</span>t1.&lt;config-name&gt;.t1rocketemu.rtl            # the elaborated T1 with Rocket core .sv files</span>
$ nix build .<span><span>#</span>t1.&lt;config-name&gt;.t1rocketemu.verilator-emu  # build the t1rocket emulator using verilator</span>
$ nix build .<span><span>#</span>t1.&lt;config-name&gt;.t1rocketemu.vcs-emu        # build the t1rocket emulator using VCS</span>
$ nix build .<span><span>#</span>t1.&lt;config-name&gt;.t1rocketemu.vcs-emu-trace  # build the t1rocket emulator using VCS with trace support</span></pre></div>
<p dir="auto">where <code>&lt;config-name&gt;</code> should be replaced with a configuration name, e.g. <code>blastoise</code>. The build output will be put in <code>./result</code> directory by default.</p>
<p dir="auto">Currently under tested configs:</p>
<markdown-accessiblity-table><table>
<thead>
<tr>
<th>Config name</th>
<th>Short summary</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Blastoise</strong></td>
<td><code>DLEN256 VLEN512;   FP; VRF p0rw,p1rw bank1; LSU bank8  beatbyte 8</code></td>
</tr>
<tr>
<td><strong>Machamp</strong></td>
<td><code>DLEN512 VLEN1K ; NOFP; VRF p0r,p1w   bank2; LSU bank8  beatbyte 16</code></td>
</tr>
<tr>
<td><strong>Sandslash</strong></td>
<td><code>DLEN1K  VLEN4K ; NOFP; VRF p0rw      bank4; LSU bank16 beatbyte 16</code></td>
</tr>
<tr>
<td><strong>Alakazam</strong></td>
<td><code>DLEN2K  VLEN16K; NOFP; VRF p0rw      bank8; LSU bank8  beatbyte 64</code></td>
</tr>
<tr>
<td><strong>t1rocket</strong></td>
<td><code>Configs that specific to t1rocket</code></td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<p dir="auto">The <code>&lt;config-name&gt;</code> could also be <code>t1rocket</code>,
this is special configuration name that enable rocket-chip support for scalar instruction.</p>
<p dir="auto">To see all possible combination of <code>&lt;config-name&gt;</code> and <code>&lt;top-name&gt;</code>, use:</p>


<p dir="auto">To run testcase on IP emulator, use the following script:</p>
<div dir="auto" data-snippet-clipboard-copy-content="$ nix develop -c t1-helper run -i &lt;top-name&gt; -c &lt;config-name&gt; -e &lt;emulator-type&gt; &lt;case-name&gt;"><pre>$ nix develop -c t1-helper run -i <span>&lt;</span>top-name<span>&gt;</span> -c <span>&lt;</span>config-name<span>&gt;</span> -e <span>&lt;</span>emulator-type<span>&gt;</span> <span>&lt;</span>case-name<span>&gt;</span></pre></div>
<p dir="auto">wheres</p>
<ul dir="auto">
<li><code>&lt;config-name&gt;</code> is the configuration name</li>
<li><code>&lt;top-name&gt;</code> is one of the <code>t1emu</code>, <code>t1rocketemu</code></li>
<li><code>&lt;emulator-type&gt;</code> is one of the <code>verilator-emu</code>, <code>verilator-emu-trace</code>, <code>vcs-emu</code>, <code>vcs-emu-trace</code>, <code>vcs-emu-cover</code></li>
<li><code>&lt;case-name&gt;</code> is the name of a testcase, you can resolve runnable test cases by command: <code>t1-helper listCases -c &lt;config-name&gt; &lt;regexp&gt;</code></li>
</ul>
<p dir="auto">For example:</p>
<div dir="auto" data-snippet-clipboard-copy-content="$ nix develop -c t1-helper run -i t1emu -c blastoise -e vcs-emu intrinsic.linear_normalization"><pre>$ nix develop -c t1-helper run -i t1emu -c blastoise -e vcs-emu intrinsic.linear_normalization</pre></div>
<p dir="auto">To get waveform, use the trace emulator</p>
<div dir="auto" data-snippet-clipboard-copy-content="$ nix develop -c t1-helper run -i t1emu -c blastoise -e vcs-emu-trace intrinsic.linear_normalization"><pre>$ <span>nix develop -c t1-helper run -i t1emu -c blastoise -e vcs-emu-trace intrinsic.linear_normalization</span></pre></div>
<p dir="auto">The <code>&lt;config-name&gt;</code>, <code>&lt;top-name&gt;</code> and <code>&lt;emulator-type&gt;</code> option will be cached under <code>$XDG_CONFIG_HOME</code>,
so if you want to test multiple test case with the same emulator,
you don&#39;t need to add <code>-c</code>, <code>-i</code> and <code>-e</code> option every time.</p>
<p dir="auto">For example:</p>
<div dir="auto" data-snippet-clipboard-copy-content="$ nix develop -c t1-helper run -i t1emu -c blastoise -e vcs-emu-trace intrinsic.linear_normalization
$ nix develop -c t1-helper run pytorch.llama"><pre>$ <span>nix develop -c t1-helper run -i t1emu -c blastoise -e vcs-emu-trace intrinsic.linear_normalization</span>
$ <span>nix develop -c t1-helper run pytorch.llama</span></pre></div>
<p dir="auto">To get verbose logging, add the <code>-v</code> option</p>
<div dir="auto" data-snippet-clipboard-copy-content="$ nix develop -c t1-helper run -v pytorch.lenet"><pre>$ <span>nix develop -c t1-helper run -v pytorch.lenet</span></pre></div>
<p dir="auto">The <code>t1-helper run</code> subcommand only run the driver without validating internal status.
To run design verification, use the <code>t1-helper check</code> subcommand:</p>
<div dir="auto" data-snippet-clipboard-copy-content="$ nix develop -c t1-helper run -i t1emu -c blastoise -e vcs-emu mlir.hello
$ nix develop -c t1-helper check"><pre>$ <span>nix develop -c t1-helper run -i t1emu -c blastoise -e vcs-emu mlir.hello</span>
$ <span>nix develop -c t1-helper check</span></pre></div>
<p dir="auto">The <code>t1-helper check</code> subcommand will read RTL event produced in <code>run</code> stage,
so make sure you <code>run</code> a test before <code>check</code>.</p>
<p dir="auto">To get the coverage report, use the <code>vcs-emu-cover</code> emulator type:</p>
<div dir="auto" data-snippet-clipboard-copy-content="$ nix develop -c t1-helper run -i t1emu -c blastoise -e vcs-emu-cover mlir.hello"><pre>$ <span>nix develop -c t1-helper run -i t1emu -c blastoise -e vcs-emu-cover mlir.hello</span></pre></div>

<div dir="auto" data-snippet-clipboard-copy-content="$ nix run .#t1.&lt;config-name&gt;.&lt;top-name&gt;.omreader &lt;key&gt; # export the contents of the specified key
$ nix run .#t1.&lt;config-name&gt;.&lt;top-name&gt;.emu-omreader &lt;key&gt; # export the contents of the specified key with emulation support"><pre>$ nix run .<span><span>#</span>t1.&lt;config-name&gt;.&lt;top-name&gt;.omreader &lt;key&gt; # export the contents of the specified key</span>
$ nix run .<span><span>#</span>t1.&lt;config-name&gt;.&lt;top-name&gt;.emu-omreader &lt;key&gt; # export the contents of the specified key with emulation support</span></pre></div>
<p dir="auto">To dump all available keys and preview their contents:</p>
<div dir="auto" data-snippet-clipboard-copy-content="$ nix run .#t1.&lt;config-name&gt;.&lt;top-name&gt;.omreader -- run --dump-methods
$ nix run .#t1.&lt;config-name&gt;.&lt;top-name&gt;.emu-omreader -- run --dump-methods"><pre>$ nix run .<span><span>#</span>t1.&lt;config-name&gt;.&lt;top-name&gt;.omreader -- run --dump-methods</span>
$ nix run .<span><span>#</span>t1.&lt;config-name&gt;.&lt;top-name&gt;.emu-omreader -- run --dump-methods</span></pre></div>
<details>
  <summary>Schema</summary>



<markdown-accessiblity-table><table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>[*]</code></td>
<td>string</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>

<div dir="auto"><h5 tabindex="-1" dir="auto"><code>decoderInstructionsJson</code> | <code>decoderInstructionsJsonPretty</code> : Json</h5><a id="user-content-decoderinstructionsjson--decoderinstructionsjsonpretty--json" aria-label="Permalink: decoderInstructionsJson | decoderInstructionsJsonPretty : Json" href="#decoderinstructionsjson--decoderinstructionsjsonpretty--json"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<markdown-accessiblity-table><table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>[*]</code></td>
<td>array</td>
</tr>
<tr>
<td><code>[*].attributes</code></td>
<td>object</td>
</tr>
<tr>
<td><code>[*].attributes[*]</code></td>
<td>array</td>
</tr>
<tr>
<td><code>[*].attributes[*].description</code></td>
<td>string</td>
</tr>
<tr>
<td><code>[*].attributes[*].identifier</code></td>
<td>string</td>
</tr>
<tr>
<td><code>[*].attributes[*].value</code></td>
<td>string</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
</details>

<div dir="auto"><h4 tabindex="-1" dir="auto">Developing Elaborator (Chisel-only)</h4><a id="user-content-developing-elaborator-chisel-only" aria-label="Permalink: Developing Elaborator (Chisel-only)" href="#developing-elaborator-chisel-only"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div dir="auto" data-snippet-clipboard-copy-content="$ nix develop .#t1.elaborator  # bring up scala environment, circt tools, and create submodules

$ nix develop .#t1.elaborator.editable  # or if you want submodules editable

$ mill -i elaborator  # build and run elaborator"><pre>$ nix develop .<span><span>#</span>t1.elaborator  # bring up scala environment, circt tools, and create submodules</span>

$ nix develop .<span><span>#</span>t1.elaborator.editable  # or if you want submodules editable</span>

$ mill -i elaborator  <span><span>#</span> build and run elaborator</span></pre></div>

<div dir="auto" data-snippet-clipboard-copy-content="$ nix develop .#t1.&lt;config-name&gt;.&lt;top-name&gt;.vcs-dpi-lib  # replace &lt;config-name&gt; with your configuration name
$ cd difftest
$ cargo build --feature vcs"><pre>$ nix develop .<span><span>#</span>t1.&lt;config-name&gt;.&lt;top-name&gt;.vcs-dpi-lib  # replace &lt;config-name&gt; with your configuration name</span>
$ <span>cd</span> difftest
$ cargo build --feature vcs</pre></div>

<p dir="auto">The <code>tests/</code> directory contains all the testcases.</p>
<ul dir="auto">
<li>asm</li>
<li>codegen</li>
<li>intrinsic</li>
<li>mlir</li>
<li>perf</li>
<li>pytorch</li>
<li>rvv_bench</li>
</ul>
<p dir="auto">To view what is available to run, use the <code>t1-helper listCases</code> sub command:</p>
<div dir="auto" data-snippet-clipboard-copy-content="$ nix develop -c t1-helper listCases -c &lt;config-name&gt; -i &lt;top-name&gt; &lt;regexp&gt;"><pre>$ <span>nix develop -c t1-helper listCases -c <span>&lt;</span>config-name<span>&gt;</span> -i <span>&lt;</span>top-name<span>&gt;</span> <span>&lt;</span>regexp<span>&gt;</span></span></pre></div>
<p dir="auto">For example,</p>
<div dir="auto" data-snippet-clipboard-copy-content="$ t1-helper listCases -c blastoise -i t1emu mlir
[INFO] Fetching current test cases

* mlir.axpy_masked
* mlir.conv
* mlir.hello
* mlir.matmul
* mlir.maxvl_tail_setvl_front
* mlir.rvv_vp_intrinsic_add
* mlir.rvv_vp_intrinsic_add_scalable
* mlir.stripmining
* mlir.vectoradd

$ t1-helper listCases -c blastoise -i t1emu &#39;.*vslid.*&#39;
[INFO] Fetching current test cases

* codegen.vslide1down_vx
* codegen.vslide1up_vx
* codegen.vslidedown_vi
* codegen.vslidedown_vx
* codegen.vslideup_vi
* codegen.vslideup_vx"><pre>$ <span>t1-helper listCases -c blastoise -i t1emu mlir</span>
<span>[INFO] Fetching current test cases</span>

<span>* mlir.axpy_masked</span>
<span>* mlir.conv</span>
<span>* mlir.hello</span>
<span>* mlir.matmul</span>
<span>* mlir.maxvl_tail_setvl_front</span>
<span>* mlir.rvv_vp_intrinsic_add</span>
<span>* mlir.rvv_vp_intrinsic_add_scalable</span>
<span>* mlir.stripmining</span>
<span>* mlir.vectoradd</span>

$ <span>t1-helper listCases -c blastoise -i t1emu <span><span>&#39;</span>.*vslid.*<span>&#39;</span></span></span>
<span>[INFO] Fetching current test cases</span>

<span>* codegen.vslide1down_vx</span>
<span>* codegen.vslide1up_vx</span>
<span>* codegen.vslidedown_vi</span>
<span>* codegen.vslidedown_vx</span>
<span>* codegen.vslideup_vi</span>
<span>* codegen.vslideup_vx</span></pre></div>
<p dir="auto">To develop a specific testcases, enter the development shell:</p>
<div dir="auto" data-snippet-clipboard-copy-content="# nix develop .#t1.&lt;config-name&gt;.&lt;top-name&gt;.cases.&lt;type&gt;.&lt;name&gt;
#
# For example:

$ nix develop .#t1.blastoise.t1emu.cases.pytorch.llama"><pre><span><span>#</span> nix develop .#t1.&lt;config-name&gt;.&lt;top-name&gt;.cases.&lt;type&gt;.&lt;name&gt;</span>
<span><span>#</span></span>
<span><span>#</span> For example:</span>

$ nix develop .<span><span>#</span>t1.blastoise.t1emu.cases.pytorch.llama</span></pre></div>
<p dir="auto">Build tests:</p>
<div dir="auto" data-snippet-clipboard-copy-content="# build a single test
$ nix build .#t1.&lt;config-name&gt;.&lt;top-name&gt;.cases.intrinsic.matmul -L
$ ls -al ./result"><pre><span><span>#</span> build a single test</span>
$ nix build .<span><span>#</span>t1.&lt;config-name&gt;.&lt;top-name&gt;.cases.intrinsic.matmul -L</span>
$ ls -al ./result</pre></div>

<p dir="auto">To develop coverage, use the following steps:</p>
<ol dir="auto">
<li>Write the coverpoint description file at the same level as the test case source code.</li>
<li>Update the <code>default.nix</code> file to parse the coverpoint description file.</li>
</ol>
<p dir="auto">For example, to develop coverage for the <code>mlir.hello</code> test case:</p>
<p dir="auto">tests/mlir/hello/hello.json:</p>
<div dir="auto" data-snippet-clipboard-copy-content="{
  &#34;assert&#34;: [
    {
      &#34;name&#34;: &#34;vmv_v_i&#34;,
      &#34;description&#34;: &#34;single instruction vmv.v.i&#34;
    }
  ],
  &#34;tree&#34;: [],
  &#34;module&#34;: []
}"><pre>{
  <span>&#34;assert&#34;</span>: [
    {
      <span>&#34;name&#34;</span>: <span><span>&#34;</span>vmv_v_i<span>&#34;</span></span>,
      <span>&#34;description&#34;</span>: <span><span>&#34;</span>single instruction vmv.v.i<span>&#34;</span></span>
    }
  ],
  <span>&#34;tree&#34;</span>: [],
  <span>&#34;module&#34;</span>: []
}</pre></div>
<p dir="auto">tests/mlir/default.nix:</p>
<div dir="auto" data-snippet-clipboard-copy-content="if [ -f ${caseName}.json ]; then
  ${jq}/bin/jq -r &#39;[.assert[] | &#34;+assert &#34; + .name] + [.tree[] | &#34;+tree &#34; + .name] + [.module[] | &#34;+module &#34; + .name] | .[]&#39; \
      ${caseName}.json &gt; $pname.cover
else 
  echo &#34;-assert *&#34; &gt; $pname.cover
fi"><pre><span>if</span> [ <span>-f</span> <span>${caseName}</span>.json ]<span>;</span> <span>then</span>
  <span>${jq}</span>/bin/jq -r <span><span>&#39;</span>[.assert[] | &#34;+assert &#34; + .name] + [.tree[] | &#34;+tree &#34; + .name] + [.module[] | &#34;+module &#34; + .name] | .[]<span>&#39;</span></span> \
      <span>${caseName}</span>.json <span>&gt;</span> <span>$pname</span>.cover
<span>else</span> 
  <span>echo</span> <span><span>&#34;</span>-assert *<span>&#34;</span></span> <span>&gt;</span> <span>$pname</span>.cover
<span>fi</span></pre></div>
<p dir="auto">Then, you can run the test building script to check if the coverage is generated correctly:</p>
<div dir="auto" data-snippet-clipboard-copy-content="nix build .#t1.blastoise.t1emu.cases.mlir.hello -L"><pre>nix build .<span><span>#</span>t1.blastoise.t1emu.cases.mlir.hello -L</span></pre></div>
<p dir="auto">Use the <code>vcs-emu-cover</code> emulator type to run the test case and generate the coverage report:</p>
<div dir="auto" data-snippet-clipboard-copy-content="nix develop -c t1-helper run -i t1emu -c blastoise -e vcs-emu-cover mlir.hello"><pre>nix develop -c t1-helper run -i t1emu -c blastoise -e vcs-emu-cover mlir.hello</pre></div>

<p dir="auto">Bump nixpkgs:</p>

<p dir="auto">Bump chisel submodule versions:</p>
<div dir="auto" data-snippet-clipboard-copy-content="$ cd nix/t1/dependencies
$ nix run &#39;.#nvfetcher&#39;"><pre>$ <span>cd</span> nix/t1/dependencies
$ nix run <span><span>&#39;</span>.#nvfetcher<span>&#39;</span></span></pre></div>

<p dir="auto">Copyright © 2022-2023, Jiuyang Liu. Released under the Apache-2.0 License.</p>
</article></div></div>
  </body>
</html>
