<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://martypc.blogspot.com/2023/10/bus-sniffing-ibm-5150.html">Original</a>
    <h1>Bus Sniffing the IBM 5150</h1>
    
    <div id="readability-page-1" class="page"><div id="post-body-731216099375746177"><p>
Writing a cycle-accurate emulator for a computer system is more than just understanding all the CPU instruction timings. A computer is a complete system with peripherals, interrupts, IO bus signals, and DMA. All this comes with an array of different timings and quirks.</p><p>When software like Area 5150 is written that requires perfect cycle timing, it can be a challenge to provide the level of accuracy needed for the software to function. Area 5150 in particular requires precise coordination with the CGA&#39;s CRTC chip and timer interrupts to begin the end credits demo effect at precisely the right time. Getting this right is crucial to whether the demo effect produces this:</p><table><tbody><tr><td><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhmC7ezDm3UwvdM7sAH285PwS9xPvh198O2ojXdvYquHxMELzETSa46bKFv6jg7EyxWyXCuO6dru6TUI2xfmlEXMsUXMkznvcnyE8qYm1iniFXPOlwnW64GoYQYur2cH0nJf0--MpRYqnsQp3Ghi756tgbcPq5Sa5fzSep0uaERLPmIgFMT_zxH2-7HBLKy/s768/area_good.png"><img data-original-height="472" data-original-width="768" height="394" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhmC7ezDm3UwvdM7sAH285PwS9xPvh198O2ojXdvYquHxMELzETSa46bKFv6jg7EyxWyXCuO6dru6TUI2xfmlEXMsUXMkznvcnyE8qYm1iniFXPOlwnW64GoYQYur2cH0nJf0--MpRYqnsQp3Ghi756tgbcPq5Sa5fzSep0uaERLPmIgFMT_zxH2-7HBLKy/w640-h394/area_good.png" width="640"/></a></td></tr><tr><td>Artwork by VileR</td></tr></tbody></table><p>Or this:</p><table><tbody><tr><td><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgc-Pl--abkZBsieYF_U2lgIjAPvQFLDpGtCxzwsRyAGilNvkYjH4TuQb6A6R6FeJvFxctUNQ_ccMKdl5c41sSMYCe5VYywmotRRDmqw3xx6n6gqXziXJKOoXFFDfy6XdJnAeJ5kQc7LSUPw--kh0O6p8W_-4bbY-lPp0L_SkPN1W9SMIGT5_o_YjMQo6hW/s768/area_bad.png"><img data-original-height="472" data-original-width="768" height="394" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgc-Pl--abkZBsieYF_U2lgIjAPvQFLDpGtCxzwsRyAGilNvkYjH4TuQb6A6R6FeJvFxctUNQ_ccMKdl5c41sSMYCe5VYywmotRRDmqw3xx6n6gqXziXJKOoXFFDfy6XdJnAeJ5kQc7LSUPw--kh0O6p8W_-4bbY-lPp0L_SkPN1W9SMIGT5_o_YjMQo6hW/w640-h394/area_bad.png" width="640"/></a></td></tr><tr><td><br/></td></tr></tbody></table><p>It would be very handy then if we could somehow peek into the operation of the system while it was running and understand how all these parts interact.  As it turns out, we can! This process is typically referred to as &#39;bus sniffing&#39;, and there&#39;s a lot of a technical information out there on the topic in general. Sniffing can be done on everything from <a href="https://www.wireshark.org/download.html" target="_blank">ethernet networks</a> to <a href="https://hackaday.com/2014/04/18/sniffing-vending-machine-buses/" target="_blank">vending machines</a>, and you can even <a href="https://tbruno25.medium.com/car-hacking-the-can-bus-tutorial-i-wish-i-had-783d7e0a2046" target="_blank">bus sniff your car</a>. This article will specifically discuss sniffing the IBM PC 5150.</p><p>Sniffing the IBM PC is something that has been done before - I am making no claims to any great breakthroughs here. Notably, it has been done by reenigne, who designed a custom ISA card with an onboard microcontroller to capture sniffing traces. You can read about it here: <a href="https://www.reenigne.org/blog/isa-bus-sniffer-update/">https://www.reenigne.org/blog/isa-bus-sniffer-update/</a></p><p>Not only did he make such a neat device, he&#39;s <a href="http://reenigne.mooo.com:8088/" target="_blank">hosted it online</a>, so that the general public can use it. That&#39;s right - an internet connected bus sniffer, that takes your code, runs it, and responds with the cycle traces.  Ingenious!</p><p>I used reenigne&#39;s bus sniffer to produce CPU cycle traces of the CPU test from 8088MPH and <a href="https://martypc.blogspot.com/2023/08/the-8088mph-cpu-test.html" target="_blank">wrote about that here</a>.  </p><p>As cool as his bus sniffer is, it does have some limitations. Primarily, the tiny amount of memory the microcontroller has available limits it to 2048 samples. To even get the 8088MPH CPU test traces, I had to split the test up into 4 parts, changing the sample start offset each time, then reassembling the trace.  Investigating something much longer - like an entire frame of a demo effect, rapidly becomes impractical. Consider that one CGA frame of 238,944 clock ticks represents 79,648 CPU cycles. That would require 39 separate sessions to accomplish, for 16.6 milliseconds of data!</p><p>I originally purchased a <a href="https://siglentna.com/product/sds1104x-e-100-mhz/" target="_blank">Siglent SDS-1104X-E</a> 4-channel oscilloscope to investigate the composite output of the CGA card, but I have found a number of uses for it including <a href="https://martypc.blogspot.com/2023/05/exploring-dma-on-ibm-pc.html" target="_blank">investigating DMA timings</a>, <a href="https://martypc.blogspot.com/2023/05/exploring-cga-wait-states.html" target="_blank">CGA wait states</a>, monitoring interrupt and IO activity, among other things. </p><p>There were several times where I really wished I had more than 4 probes, and the thought naturally lead to pondering a design for my own bus sniffer. One of the main problems immediately encountered is that modern microcontrollers all run their GPIO pins at 3v, and can be damaged by the 5v signals used by the 5150. </p><p>The Arduino I used for the Arduino8088 project operates at 5V, but its slow clock rate (16MHz) and delay in switching GPIO pin directions made it unsuitable for the task of sniffing a system in realtime.</p><p>Newer microcontrollers like the Pi Pico, Teensy and Arduino GIGA are much faster - but operate at 3V, and will be damaged by 5V signals. There&#39;s some indication that the Raspberry Pi 2040 can tolerate 5v acceptably well, but no guarantees. Level shifters can be used to translate the old 5V TTL logic signals from the 5150 down to 3V for a modern microcontroller, but we would need a lot of them. They might have at most 8 lines, and we have at least 26 signals off the CPU alone. They range from either oldschool DIP packages to incredibly small surface-mount components I would barely be able to hand-solder. There are confusing warnings associated with each about speed, bidirectionality, and rumors of hard to troubleshoot glitches. I was quickly going down a rabbit hole.</p><p>Turns out I was overthinking things a bit, as long as I was willing to throw some money at the problem. There&#39;s a whole class of device designed to do exactly what I was wanting to do, without needing to build custom hardware to accomplish it.</p><p>They&#39;re called <a href="https://en.wikipedia.org/wiki/Logic_analyzer">Digital Logic Analyzers</a>. Unlike an oscilloscope, they&#39;re primarily interested in examining digital signals - and unlike a microcontroller&#39;s GPIO pins, they are tolerant of a wide range of voltage levels.</p><p>I can even add a digital logic analyzer to my Siglent scope - it&#39;s a bit of a pricey addition, $300 for the hardware and $100 for the requisite software license that unlocks the feature.  In the world of digital logic analyzers, that&#39;s not too crazy, though - the top of the line Saleae Logic Pro 16 retails for a <a href="https://usd.saleae.com/products/saleae-logic-pro-16" target="_blank">whopping $1500</a>. </p><p>How many channels do I need, exactly?  I could probably squeak by with 16, but ideally, I&#39;d have more. Consider there are 20 address pins on the 8088 alone.  Between the address/data bus, clock line, S0-S2 status lines, and QS0-QS1 status lines and other helpful signals like READY, INTR and DREQ, we&#39;re up to 28 channels already.</p><p>After some shopping around, I settled on the <a href="https://www.dreamsourcelab.com/product/dslogic-series/" target="_blank">DSLogic U3Pro32</a>.  It offers 32 channels at 50Mhz sampling rate, USB 3.0 connectivity and decent software (based on the open source <a href="https://sigrok.org/" target="_blank">Sigrok Pulseview</a> project).  </p><p>I wasn&#39;t sure what to expect buying a &#34;cheaper&#34; device, but the unit that arrived seems well built (if surprisingly small) and came with a nice case for its leads.</p><table><tbody><tr><td><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhED31oRFZXyuOdgJW6NebrCSqv71TRRrDnHiwcFrrwA38UHVlEBN-qDeC9PdWTp8xRgbqRWZAGOCRnZAfxLhVqKa8sOoItH2lJnhMLDRhWmWU0dHvQmy-qicYlOjq0pER7_ShYANcq52kI1wyhGXG6SyDWuT7qSipqEyiDV_p1FWLIhzBE9SjUK1eytG35/s1601/analyzer_hardware01.JPG"><img data-original-height="857" data-original-width="1601" height="342" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhED31oRFZXyuOdgJW6NebrCSqv71TRRrDnHiwcFrrwA38UHVlEBN-qDeC9PdWTp8xRgbqRWZAGOCRnZAfxLhVqKa8sOoItH2lJnhMLDRhWmWU0dHvQmy-qicYlOjq0pER7_ShYANcq52kI1wyhGXG6SyDWuT7qSipqEyiDV_p1FWLIhzBE9SjUK1eytG35/w640-h342/analyzer_hardware01.JPG" width="640"/></a></td></tr><tr><td>The DSLogic U3Pro32<br/></td></tr></tbody></table><!--HTML generated using hilite.me-->




<!--HTML generated using hilite.me-->




<!--HTML generated using hilite.me-->







<!--HTML generated using hilite.me-->





</div></div>
  </body>
</html>
