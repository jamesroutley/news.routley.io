<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lichess.org/@/thibault/blog/lichess--scala-3/y1sbYzJX">Original</a>
    <h1>Lichess gets a big upgrade. It doesn&#39;t go as planned</h1>
    
    <div id="readability-page-1" class="page"><p><strong>Lichess gets a big upgrade. It doesn&#39;t go as planned.</strong></p><div><p>Lichess is a <a href="https://lichess.org/source">100% open-source/free-software</a> chess website, used by millions of players to play <a href="https://database.lichess.org/">billions of games</a>.</p>
<p>I made the choice to write it using <a href="https://www.scala-lang.org/">the scala language</a> many years ago, and never looked back. It has the features that matter to me:</p>
<ul>
<li>Type safety: the compiler as a copilot</li>
<li>Functional programming: functions as building blocks</li>
<li>Performance and ecosystem: the JVM as a strong foundation</li>
</ul>
<h2>Enters Scala 3</h2>
<p>Lichess being built on Scala 2, when Scala 3 was released last year, I was very excited to upgrade.</p>
<p>Last month I decided the wait was over, and that it was time for Lichess to get a massive upgrade. Could I have waited for longer? Sure, but I didn&#39;t see a reason why, and let&#39;s be honest I was craving for the latest features.</p>
<h2>Scala 3 new features</h2>
<p>It&#39;s not so much an evolution of the language, but rather a complete overhaul, as the compiler was <strong>rewritten from scratch</strong>. Yet compatibility was preserved wherever possible, easing the migration.</p>
<p>Here are some of my favourite <a href="https://docs.scala-lang.org/scala3/new-in-scala3.html">Scala 3 features</a>:</p>
<h3><a href="https://docs.scala-lang.org/scala3/book/types-opaque-types.html">Opaque types</a></h3>
<p>Stronger typing with zero runtime cost, what&#39;s not to love? Strings (like user IDs) and other primitives can be replaced with proper types that the compiler understands.</p>
<pre><code>opaque type UserId = String

def find(id: UserId) // this function doesn&#39;t accept any String, just UserId values
</code></pre>
<p>I actually found and fixed some old obscure bugs that were due to using Strings, while changing them to <code>opaque</code> types.</p>
<h3>Cleaner syntax</h3>
<p>Significant indentation and optional braces make our code look like python, which is cute. Fortunately the comparison stops here ;)</p>
<pre><code>object Chess:
  def turnColor(ply: Int) =
    if ply % 2 == 1 then White else Black
</code></pre>
<h3>Improved <a href="https://docs.scala-lang.org/scala3/book/types-inferred.html">type inference</a></h3>
<p>We want types, not boilerplate. Sometimes it&#39;s best to let the compiler figure out what things are by itself. I&#39;ve been able to remove a lot of type annotations during the Scala 3 migration, and it pleased my code-golf inclinations.</p>
<h3>Better <a href="https://docs.scala-lang.org/scala3/book/ca-contextual-abstractions-intro.html">contextual abstractions</a></h3>
<p><code>implicit</code> has been replaced with specialized keywords <code>using</code>, <code>given</code>, and <code>extension</code>.</p>
<h3>Enumerations that look good</h3>
<p>More of a code sugar thing, but I always love concision and expressiveness:</p>
<pre><code>enum DrawReason:
  case MutualAgreement, FiftyMoves, ThreefoldRepetition, InsufficientMaterial
</code></pre>
<p>It doesn&#39;t look like much, but it comes with <a href="https://docs.scala-lang.org/scala3/reference/enums/enums.html">batteries included</a>.</p>
<h3>New <code>export</code> keyword</h3>
<p>It works like <code>import</code>, but to expose functions and values. It makes composition more concise.</p>
<pre><code>// before:
def rating = glicko.rating
def deviation = glicko.deviation

// after:
export glicko.{ rating, deviation }
</code></pre>
<p>If better composition means less inheritance, then count me in.</p>
<h3>New <a href="https://docs.scala-lang.org/scala3/guides/macros/inline.html"><code>inline</code> keyword</a></h3>
<p>While the former <a href="https://lichess.org/@/inline">@inline</a> annotation was a best-effort thing, the new <code>inline</code> keyword <strong>guarantees inlining during compilation</strong>.</p>
<h3>And many more features</h3>
<p>The list could go on and on; there is <a href="https://docs.scala-lang.org/scala3/new-in-scala3.html#whats-new-in-scala-3">so much more to Scala 3</a>! This post is already getting too long, so I&#39;ll cut down on the fanboism.</p>
<h2>The migration</h2>
<p><a href="https://github.com/lichess-org/lila">Lila</a> is a big program, serving 2000 HTTP requests per second, playing 5000 chess moves per second, while doing <a href="https://lichess.org/features">A LOT</a> of <a href="https://github.com/lichess-org/lila/tree/master/modules">OTHER THINGS</a> that I better not start enumerating here.</p>
<p>So yeah, migrating it was scary, and I fully expected a disaster of some sort. Let&#39;s see how it went.</p>
<h3>Tooling</h3>
<p>Fortunately <a href="https://scalameta.org/metals/">metals</a> and <a href="https://scalacenter.github.io/bloop/">bloop</a> are handling Scala 3 very well, which gave my <a href="https://neovim.io/">code editor</a> full language support. It was a very comfortable experience.</p>
<p>All we need now is for some brave soul to <a href="https://github.com/tree-sitter/tree-sitter-scala/issues/43">improve Scala 3 support for treesitter</a>, so that we can all enjoy proper code coloring for the new language syntax.</p>
<h3>Updating my code</h3>
<p>That was the easy and fun part, especially since <a href="https://docs.scala-lang.org/scala3/guides/migration/tooling-migration-mode.html">the compiler did most of the work</a> for me. I actually rewrote more code than I had too, because I couldn&#39;t resist converting some <code>implicits</code> to <code>given</code> here and there, and using <code>opaque</code> types.</p>
<p>At some point I had to rewrite the Glicko2 rating system <a href="https://github.com/lichess-org/lila/commits/master/modules/rating/src/main/glicko2">from Java to Scala 3</a>, as the compiler was complaining about having Java in my project. No-one noticed broken ratings, so I suppose it worked.</p>
<h3>Third-party libraries</h3>
<p>That&#39;s where things got a bit hairy. Lila is built on <a href="https://www.playframework.com/">Play Framework</a> which is not yet ported to Scala 3.</p>
<p>So I <a href="https://github.com/lichess-org/playframework-lila">forked it and butchered it</a> to remove everything we don&#39;t need - which is actually most of the framework.</p>
<p>Once Play was reduced to a handful of small libraries (HTTP/netty server, routing, and forms), it became very easy to migrate to Scala 3.</p>
<p>Most <a href="https://github.com/lichess-org/lila/blob/b9e650a636df75198eefe89bd3951e7fefb87b79/project/Dependencies.scala#L1">other dependencies</a>, such as the <a href="https://github.com/ReactiveMongo/ReactiveMongo">MongoDB driver</a>, the <a href="https://github.com/com-lihaoyi/scalatags">template engine</a> or the <a href="https://github.com/typelevel/cats">cute functional cats</a>, were already upgraded to Scala 3. As for the libraries coming from the Java ecosystem, like our <a href="https://github.com/lettuce-io/lettuce-core">redis driver</a>, well, they just work as usual.</p>
<h3>Going to production</h3>
<p>When everything compiled, <strong>I shipped it</strong>. And to everyone&#39;s surprise, apart from a few bugs I had created while rewriting thousands of lines of code... it worked. It just did. No explosions, no obscure bugs, no memory leak, no performance degradation. That was rather unexpected.</p>
<p>With Scala 3 working in production, I was free to rewrite the code even deeper, to incrementally make use of Scala 3 features.</p>
<h3>JVM tuning</h3>
<p>Until one morning, instead of deploying the changes from the day before, I let it run an extra 24h. Then we saw the JVM CPU usage rise to alarming heights, with unusual patterns. And no obvious culprit in the thread dumps...</p>
<p>I couldn&#39;t make sense of it, and eventually called for help - read all about it in <a href="https://lichess.org/@/thibault/blog/lichess-on-scala3-help-needed/2bpotLb0">my previous blog post</a>.</p>
<p>The avengers assembled and saved Lichess: it was just the JVM that needed some tuning. The HotSpot compiler was running out of code cache, and once we gave it some more, things suddenly went a lot better.</p>
<h3>Ludicrous speed</h3>
<p>As a result, Lichess is now faster than it ever was. The previous version running Scala 2 was also throttled by the lack of JVM tuning. The effects were not as spectacular, but still: we were basically running Lichess with the parking brake on.</p>
<p>Lichess is now running with Scala 3 and without the parking brake, and it&#39;s a lot faster. To be able to tell if Scala 3 itself is faster, we would have to rollback to Scala 2 and try it with the proper JVM tuning. I&#39;m not willing to do that, sorry! Once you&#39;ve tried Scala 3, there&#39;s no going back.</p>
<h2>Last words</h2>
<p>I&#39;ve been both scared and excited about this migration, ever since Scala 3 was announced. Given the size of our codebase, I was expecting a disaster, but instead all we got was a few bumps on the road. And we&#39;re now smooth sailing, all modern and future proof, which feels kinda great.</p>
<p>It only took a month to fully migrate Lichess, from the first code change to being certain that it runs in production perfectly (current uptime: 7 days).</p>
<p>As with every refactoring or migration, the success and speed are largely due to static typing and compiler quality.</p>
<h2>Verdict</h2>
<p>10/10 would migrate again</p>
<h2>Thanks</h2>
<p>Massive thanks go to the Scala 3 team, who did an incredible job at this new version of the language. Changes are <a href="https://docs.scala-lang.org/scala3/reference/index.html">pretty darn well documented</a> too.</p>
<p>I&#39;m also forever grateful to everyone who works on Scala tooling, and to the fantastic <a href="https://discord.com/invite/scala">community of developers</a> who helped me, guided me, and sometimes outright wrote the <a href="https://github.com/lichess-org/lila/blob/b9e650a636df75198eefe89bd3951e7fefb87b79/modules/common/src/main/AutoConfig.scala#L1">complicated</a> <a href="https://github.com/ornicar/scalalib/blob/master/src/main/scala/newtypes.scala">code</a> for me when I needed it.</p>
<p>Thank you to all Lichess players, and to everyone who <a href="https://lichess.org/patron">supports this beautiful project with a donation</a>!</p>
</div></div>
  </body>
</html>
