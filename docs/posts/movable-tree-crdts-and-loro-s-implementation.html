<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://loro.dev/blog/movable-tree">Original</a>
    <h1>Movable tree CRDTs and Loro&#39;s implementation</h1>
    
    <div id="readability-page-1" class="page"><article><main><div><svg fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path></svg><p>Movable tree CRDTs and Loro&#39;s implementation</p></div>
<!-- -->

<p><img loading="lazy" width="1792" height="1024" decoding="async" data-nimg="1" srcset="/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fmovable-tree-cover.f2c64ff7.png&amp;w=1920&amp;q=75 1x, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fmovable-tree-cover.f2c64ff7.png&amp;w=3840&amp;q=75 2x" src="https://olu.online/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fmovable-tree-cover.f2c64ff7.png&amp;w=3840&amp;q=75"/></p>
<p>This article introduces the implementation difficulties and challenges of Movable Tree CRDTs when collaboration, and how Loro implements it and sorts child nodes. The algorithm has high performance and can be used in production.</p>
<h2>Background<a href="#background" id="background" aria-label="Permalink for this section"></a></h2>
<p>In distributed systems and collaborative software, managing hierarchical relationships is difficult and complex. Challenges arise in resolving conflicts and meeting user expectations when working with the data structure that models movement by combining deletion and insertion. For instance, if a node is concurrently moved to different parents in replicas, it may lead to the unintended creation of duplicate nodes with the same content. Because the node is deleted twice and created under two parents.</p>
<p>Currently, many software solutions offer different levels of support and functionality for managing hierarchical data structures in distributed environments. The key variation among these solutions lies in their approaches to handling potential conflicts.</p>
<h3>Conflicts in Movable Trees<a href="#conflicts-in-movable-trees" id="conflicts-in-movable-trees" aria-label="Permalink for this section"></a></h3>
<p>A movable tree has 3 primary operations: creation, deletion, and movement. Consider a scenario where two peers independently execute various operations on their respective replicas of the same movable tree. Synchronizing these operations can lead to potential conflicts, such as:</p>
<ul>
<li>The same node was deleted and moved</li>
<li>The same node was moved under different nodes</li>
<li>Different nodes were moved, resulting in a cycle</li>
<li>The ancestor node is deleted while the descendant node is moved</li>
</ul>
<h4>Deletion and Movement of the Same Node<a href="#deletion-and-movement-of-the-same-node" id="deletion-and-movement-of-the-same-node" aria-label="Permalink for this section"></a></h4>
<p><img alt="Deletion and Movement of the Same Node" loading="lazy" width="3054" height="1394" decoding="async" data-nimg="1" srcset="/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fmove-delete-dark.17378273.png&amp;w=3840&amp;q=75 1x" src="https://olu.online/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fmove-delete-dark.17378273.png&amp;w=3840&amp;q=75"/></p>
<p>This situation is relatively easy to resolve. It can be addressed by applying one of the operations while ignoring the other based on the timestamp in the distributed system or the application&#39;s specific requirements. Either approach yields an acceptable outcome.</p>
<h4>Moving the Same Node Under Different Parents<a href="#moving-the-same-node-under-different-parents" id="moving-the-same-node-under-different-parents" aria-label="Permalink for this section"></a></h4>
<p><img alt="Moving the Same Node Under Different Parents" loading="lazy" width="3070" height="1398" decoding="async" data-nimg="1" srcset="/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fmove-same-node-dark.fc82da02.png&amp;w=3840&amp;q=75 1x" src="https://olu.online/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fmove-same-node-dark.fc82da02.png&amp;w=3840&amp;q=75"/></p>
<p>Merging concurrent movement operations of the same node is slightly more complex. Different approaches can be adopted depending on the application:</p>
<ul>
<li>Delete the node and create copies of nodes under different parent nodes. Subsequent operations then treat these nodes independently. This approach is acceptable when node uniqueness is not critical.</li>
<li>Allow the node have two edges pointing to different parents. However, this approach breaks the fundamental tree structure and is generally not considered acceptable.</li>
<li>Sort all operations, then apply them one by one. The order can be determined by timestamps in a distributed system. Providing the system maintains a consistent operation sequence, it ensures uniform results across all peers.</li>
</ul>
<h4>Movement of Different Nodes Resulting in a Cycle<a href="#movement-of-different-nodes-resulting-in-a-cycle" id="movement-of-different-nodes-resulting-in-a-cycle" aria-label="Permalink for this section"></a></h4>
<p><img alt="cycle" loading="lazy" width="3024" height="1442" decoding="async" data-nimg="1" srcset="/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fcycle-dark.267300d7.png&amp;w=3840&amp;q=75 1x" src="https://olu.online/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fcycle-dark.267300d7.png&amp;w=3840&amp;q=75"/></p>
<p>Concurrent movement operations that cause cycles make the conflict resolution of movable trees complex. Matthew Weidner listed several solutions to resolve cycles in his <a href="https://mattweidner.com/2023/09/26/crdt-survey-2.html#forests-and-trees" target="_blank" rel="noreferrer">blog<span> (opens in a new tab)</span></a>.</p>
<blockquote>
<ol>
<li>Error. Some desktop file sync apps do this in practice (<a href="https://doi.org/10.1109/TPDS.2021.3118603" target="_blank" rel="noreferrer">Martin Kleppmann et al. (2022)<span> (opens in a new tab)</span></a> give an example).</li>
<li>Render the cycle nodes (and their descendants) in a special “time-out” zone. They will stay there until some user manually fixes the cycle.</li>
<li>Use a server to process move ops. When the server receives an op, if it would create a cycle in the server’s own state, the server rejects it and tells users to do likewise. This is <a href="https://www.figma.com/blog/how-figmas-multiplayer-technology-works/#syncing-trees-of-objects" target="_blank" rel="noreferrer">what Figma does<span> (opens in a new tab)</span></a>. Users can still process move ops optimistically, but they are tentative until confirmed by the server. (Optimistic updates can cause temporary cycles for users; in that case, Figma uses strategy (2): it hides the cycle nodes.)</li>
<li>Similar, but use a <a href="https://mattweidner.com/2023/09/26/crdt-survey-2.html#topological-sort" target="_blank" rel="noreferrer">topological sort<span> (opens in a new tab)</span></a> (below) instead of a server’s receipt order. When processing ops in the sort order, if an op would create a cycle, skip it <a href="https://doi.org/10.1109/TPDS.2021.3118603" target="_blank" rel="noreferrer">(Martin Kleppmann et al. 2022)<span> (opens in a new tab)</span></a>.</li>
<li>For forests: Within each cycle, let <code dir="ltr">B.parent = A</code> be the edge whose <code dir="ltr">set</code> operation has the largest LWW timestamp. At render time, “hide” that edge, instead rendering <code dir="ltr">B.parent = &#34;none&#34;</code>, but don’t change the actual CRDT state. This hides one of the concurrent edges that created the cycle.
• To prevent future surprises, users’ apps should follow the rule: before performing any operation that would create or destroy a cycle involving a hidden edge, first “affirm” that hidden edge, by performing an op that sets <code dir="ltr">B.parent = &#34;none&#34;</code>.</li>
<li>For trees: Similar, except instead of rendering <code dir="ltr">B.parent = &#34;none&#34;</code>, render the previous parent for <code dir="ltr">B</code> - as if the bad operation never happened. More generally, you might have to backtrack several operations. Both <a href="http://dx.doi.org/10.1145/3209280.3229110" target="_blank" rel="noreferrer">Hall et al. (2018)<span> (opens in a new tab)</span></a> and <a href="https://arxiv.org/abs/2103.04828" target="_blank" rel="noreferrer">Nair et al. (2022)<span> (opens in a new tab)</span></a> describe strategies along these lines.</li>
</ol>
</blockquote>
<h4>Ancestor Node Deletion and Descendant Node Movement<a href="#ancestor-node-deletion-and-descendant-node-movement" id="ancestor-node-deletion-and-descendant-node-movement" aria-label="Permalink for this section"></a></h4>
<p><img alt="Ancestor Node Deletion and Descendant Node Movement" loading="lazy" width="2064" height="1136" decoding="async" data-nimg="1" srcset="/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fmove_chlid_delete_parent_dark.4422d913.png&amp;w=3840&amp;q=75 1x" src="https://olu.online/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fmove_chlid_delete_parent_dark.4422d913.png&amp;w=3840&amp;q=75"/></p>
<p>The most easily overlooked scenario is moving descendant nodes when deleting an ancestor node. If all descendant nodes of the ancestor are deleted directly, users may easily misunderstand that their data has been lost.</p>
<h3>How Popular Applications Handle Conflicts<a href="#how-popular-applications-handle-conflicts" id="how-popular-applications-handle-conflicts" aria-label="Permalink for this section"></a></h3>
<p>Dropbox is a file data synchronization software. Initially, Dropbox treated file movement as a two-step process: deletion from the original location followed by creation at a new location. However, this method risked data loss, especially if a power outage or system crash occurred between the delete and create operations.</p>
<p>Today, when multiple people move the same file concurrently and attempt to save their changes, Dropbox detects a conflict. In this scenario, it typically saves one version of the original file and creates a new <a href="https://help.dropbox.com/organize/conflicted-copy" target="_blank" rel="noreferrer">&#34;conflicted copy&#34;<span> (opens in a new tab)</span></a> for the changes made by one of the users.</p>
<p><img alt="Solution for conflicts when moving files with Dropbox" loading="lazy" width="852" height="311" decoding="async" data-nimg="1" srcset="/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fdropbox_move.467b7931.gif&amp;w=1080&amp;q=75 1x, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fdropbox_move.467b7931.gif&amp;w=1920&amp;q=75 2x" src="https://olu.online/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fdropbox_move.467b7931.gif&amp;w=1920&amp;q=75"/></p>
<p>The image shows the conflict that occurs when A is moved to the B folder and B
is moved to the A folder concurrently.</p>
<p>Figma is a real-time collaborative prototyping tool. They consider tree structures as the most complex part of the collaborative system, as detailed in their <a href="https://www.figma.com/blog/how-figmas-multiplayer-technology-works/#syncing-trees-of-objects" target="_blank" rel="noreferrer">blog post about multiplayer technology<span> (opens in a new tab)</span></a>. To maintain consistency, each element in Figma has a &#34;parent&#34; attribute. The centralized server plays a crucial role in ensuring the integrity of these structures. It monitors updates from various users and checks if any operation would result in a cycle. If a potential cycle is detected, the server rejects the operation.</p>
<p>However, due to network delays and similar issues, there can be instances where updates from users temporarily create a cycle before the server has the chance to reject them. Figma acknowledges that this situation is uncommon. Their <a href="https://www.figma.com/blog/how-figmas-multiplayer-technology-works/#syncing-trees-of-objects" target="_blank" rel="noreferrer">solution<span> (opens in a new tab)</span></a> is straightforward yet effective: they temporarily preserve this state and hide the elements involved in the cycle. This approach lasts until the server formally rejects the operation, ensuring both the stability of the system and a seamless user experience.</p>
<p><img alt="An animation that demonstrates how Figma resolves conflicts." loading="lazy" width="1248" height="824" decoding="async" data-nimg="1" srcset="/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Ffigma-tree.8521d43a.gif&amp;w=1920&amp;q=75 1x, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Ffigma-tree.8521d43a.gif&amp;w=3840&amp;q=75 2x" src="https://olu.online/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Ffigma-tree.8521d43a.gif&amp;w=3840&amp;q=75"/></p>
<div><p>An animation that demonstrates how
<a href="https://www.figma.com/blog/how-figmas-multiplayer-technology-works/#syncing-trees-of-objects" target="_blank" rel="noreferrer">Figma<span> (opens in a new tab)</span></a>
resolves conflicts.</p></div>
<h2>Movable Tree CRDTs<a href="#movable-tree-crdts" id="movable-tree-crdts" aria-label="Permalink for this section"></a></h2>
<p>The applications mentioned above use movable trees and resolve conflicts based on centralized solutions. Another alternative approach to collaborative tree structures is using Conflict-free Replicated Data Types (CRDTs). While initial CRDT-based algorithms were challenging to implement and incurred significant storage overhead as noted in prior research, such as <a href="https://arxiv.org/pdf/1201.1784.pdf" target="_blank" rel="noreferrer">Abstract unordered and
ordered trees CRDT<span> (opens in a new tab)</span></a> or <a href="https://arxiv.org/pdf/1207.5990.pdf" target="_blank" rel="noreferrer">File system on CRDT<span> (opens in a new tab)</span></a>, but continual optimization and improvement have made several CRDT-based tree synchronization algorithms suitable for certain production environments. This article highlights two innovative CRDT-based approaches for movable trees. The first is presented by Martin Kleppmann et al. in their work <strong><em><a href="https://martin.kleppmann.com/2021/10/07/crdt-tree-move-operation.html" target="_blank" rel="noreferrer">A highly-available move operation for replicated trees<span> (opens in a new tab)</span></a></em></strong> and the second by Evan Wallace in his <strong><em><a href="https://madebyevan.com/algos/crdt-mutable-tree-hierarchy/" target="_blank" rel="noreferrer">CRDT: Mutable Tree Hierarchy<span> (opens in a new tab)</span></a></em></strong>.</p>
<h3>A highly-available move operation for replicated trees<a href="#a-highly-available-move-operation-for-replicated-trees" id="a-highly-available-move-operation-for-replicated-trees" aria-label="Permalink for this section"></a></h3>
<p>This paper unifies the three operations used in trees (creating, deleting, and moving nodes) into a move operation. The move operation is defined as a four-tuple <code dir="ltr">Move t p m c</code>, where <code dir="ltr">t</code> is the operation&#39;s unique and ordered timestamp such as <a href="https://en.wikipedia.org/wiki/Lamport_timestamp" target="_blank" rel="noreferrer"><code dir="ltr">Lamport timestamp</code><span> (opens in a new tab)</span></a>, <code dir="ltr">p</code> is the parent node ID, <code dir="ltr">m</code> is the metadata associated with the node, and <code dir="ltr">c</code> is the child node ID.</p>
<p>If all nodes of the tree do not contain <code dir="ltr">c</code>, this is a <strong>creation</strong> operation that creates a child node <code dir="ltr">c</code> under parent node <code dir="ltr">p</code>. Otherwise, it is a <strong>move</strong> operation that moves <code dir="ltr">c</code> from its original parent to the new parent <code dir="ltr">p</code>. Additionally, node deletion is elegantly handled by introducing a designated <code dir="ltr">TRASH</code> node; moving a node to <code dir="ltr">TRASH</code> implies its deletion, with all descendants of <code dir="ltr">TRASH</code> considered deleted. But they remain in memory to prevent concurrent editing from moving them to other nodes. In order to handle the previously mentioned situation of deleting ancestor nodes and moving descendant nodes concurrently.</p>
<p>In the three potential conflicts mentioned earlier, since deletion is also defined as a move operation, <strong>deleting and moving the same node</strong> is transformed into two move operations, leaving only two remaining problems:</p>
<ul>
<li><strong>Moving the same node under different parents</strong></li>
<li><strong>Moving different nodes, creating a cycle</strong></li>
</ul>
<p>Logical timestamps are added so that all operations can be linearly ordered, thus the first conflict can be avoided as they can be expressed as two operations in sequence rather than concurrently for the same node. Therefore, in modeling a Tree using only move operations, the only exceptional case in concurrent editing would be creating a cycle, and operations causing a cycle are termed <strong>unsafe operations</strong>.</p>
<p>This algorithm sorts all move operations according to their timestamps. It can then sequentially apply each operation. Before applying, the algorithm detects cycles to determine whether an operation is safe. If the operation creates a cycle, we ignore the unsafe operation to ensure the correct structure of the tree.</p>
<p>Based on the above approach, the consistency problem of movable trees becomes the following two questions:</p>
<ol>
<li>How to introduce global order to operations</li>
<li>How to apply a remote operation that should be inserted in the middle of an existing sorted sequence of operations</li>
</ol>
<h4>Globally Ordered Logical Timestamps<a href="#globally-ordered-logical-timestamps" id="globally-ordered-logical-timestamps" aria-label="Permalink for this section"></a></h4>
<p><a href="https://en.wikipedia.org/wiki/Lamport_timestamp" target="_blank" rel="noreferrer">Lamport Timestamp<span> (opens in a new tab)</span></a> can determine the causal order of events in a distributed system. Here&#39;s how they work: each peer starts with a counter initialized to <code dir="ltr">0</code>. When a local event occurs, the counter is increased by <code dir="ltr">1</code>, and this value becomes the event&#39;s Lamport Timestamp. When peer <code dir="ltr">A</code> sends a message to peer <code dir="ltr">B</code>, <code dir="ltr">A</code> attaches its Lamport Timestamp to the message. Upon receiving the message, peer <code dir="ltr">B</code> compares its current logical clock value with the timestamp in the message and updates its logical clock to the larger value.</p>
<p>To globally sort events, we first look at the Lamport Timestamps: smaller numbers mean earlier events. If two events have the same timestamp, we use the unique ID of the peer serves as a tiebreaker.</p>
<h4>Apply a Remote Operation<a href="#apply-a-remote-operation" id="apply-a-remote-operation" aria-label="Permalink for this section"></a></h4>
<p>An op&#39;s safety depends on the tree&#39;s state when applied, avoiding cycles. Insertion requires evaluating the state formed by all preceding ops. For remote updates, we may need to:</p>
<ol>
<li>Undo recent ops</li>
<li>Insert the new op</li>
<li>Reapply undone ops</li>
</ol>
<p>This ensures proper integration of new ops into the existing sequence.</p>
<h5>Undo Recent Ops<a href="#undo-recent-ops" id="undo-recent-ops" aria-label="Permalink for this section"></a></h5>
<p>Since we&#39;ve modeled all operations on the tree as move operations, undoing a move operation involves either moving the node back to its old parent or undoing the operation that created this node. To enable quick undoing, we cache and record the <strong>old parent</strong> of the node before applying each move operation.</p>
<h5>Apply the Remote Op<a href="#apply-the-remote-op" id="apply-the-remote-op" aria-label="Permalink for this section"></a></h5>
<p>Upon encountering an unsafe operation, disregarding its effects prevents the creation of a cycle. Nevertheless, it&#39;s essential to record the operation, as the safety of an operation is determined <strong>dynamically</strong>. For instance, if we receive and sort an update that deletes another node causing the cycle prior to this operation, the operation that was initially unsafe becomes safe. Additionally, we need to mark this unsafe operation as ineffective, since during undo operations, it&#39;s necessary to query the <strong>old parent</strong> node, which is the target parent of the last effective operation in the sequence targeting this node.</p>
<h5>Reapply Undone Ops<a href="#reapply-undone-ops" id="reapply-undone-ops" aria-label="Permalink for this section"></a></h5>
<p>Cycles only occur when receiving updates from other peers, so the undo-do-redo process is also needed at this time. When receiving a new op:</p>
<div><pre data-language="jsx" data-theme="default"><code dir="ltr" data-language="jsx" data-theme="default"><span><span>function</span><span> </span><span>apply</span><span>(newOp)</span></span>
<span><span>      </span><span>// Compare the ID of the new operation with existing operations</span></span>
<span><span>      </span><span>if</span><span> </span><span>largerThanExistingOpId</span><span>(</span><span>newOp</span><span>.id</span><span>,</span><span> oplog)</span></span>
<span><span>          </span><span>// If the new operation&#39;s ID is greater, apply it directly</span></span>
<span><span>          </span><span>oplog</span><span>.applyOp</span><span>(newOp)</span></span>
<span><span>      </span><span>else</span></span>
<span><span>          </span><span>// If the new operation&#39;s ID is not the greatest, undo operations until it can be applied</span></span>
<span><span>          undoneOps </span><span>=</span><span> </span><span>oplog</span><span>.undoUtilCanBeApplied</span><span>(newOp)</span></span>
<span><span>          </span><span>oplog</span><span>.applyOp</span><span>(newOp)</span></span>
<span><span>          </span><span>// After applying the new operation, redo the undone operations to maintain sequence order</span></span>
<span><span>          </span><span>oplog</span><span>.redoOps</span><span>(undoneOps)</span></span></code></pre></div>
<ul>
<li>If the new operation depends on an op that has not been encountered locally, indicating that some inter-version updates are still missing, it is necessary to temporarily cache the new op and wait to apply it until the missing updates are received.</li>
<li>Compare the new operation with all existing operations. If the <code dir="ltr">opId</code> of the new operation is greater than that of all existing operations, it can be directly applied. If the new operation is safe, record the parent node of the target node as the old parent node, then apply the move operation to change the current state. If it is not safe, mark this operation as ineffective and ignore the operation&#39;s impact.</li>
<li>If the new opId is sorted in the middle of the existing sequence, it is necessary to pop the operations that are sorted later from the sequence one by one, and undo the impact of this operation, which means moving back to the child of the old parent node, until the new operation can be applied. After applying the new operation, reapply the undone nodes in sequence order, ensuring that all operations are applied in order.</li>
</ul>
<p>The following animated GIF demonstrates the process executed by <code dir="ltr">Peer1</code>:</p>
<ol>
<li>Received <code dir="ltr">Peer0</code> creating node <code dir="ltr">A</code> with the <code dir="ltr">root</code> node as its parent.</li>
<li>Received <code dir="ltr">Peer0</code> creating node <code dir="ltr">B</code> with <code dir="ltr">A</code> as its parent.</li>
<li>Created node <code dir="ltr">C</code> with <code dir="ltr">A</code> as its parent and synchronized it with <code dir="ltr">Peer0</code>.</li>
<li>Moved <code dir="ltr">C</code> to have <code dir="ltr">B</code> as its parent.</li>
<li>Received <code dir="ltr">Peer0</code>&#39;s moving <code dir="ltr">B</code> to have <code dir="ltr">C</code> as its parent.</li>
</ol>
<p><img loading="lazy" width="1440" height="810" decoding="async" data-nimg="1" srcset="/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fundo-do-redo.213bb232.gif&amp;w=1920&amp;q=75 1x, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fundo-do-redo.213bb232.gif&amp;w=3840&amp;q=75 2x" src="https://olu.online/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fundo-do-redo.213bb232.gif&amp;w=3840&amp;q=75"/></p>
<p>The queue at the top right of the animation represents the order of local operations and newly received updates. The interpretation of each element in each <code dir="ltr">Block</code> is as follows:</p>
<p><img loading="lazy" width="891" height="465" decoding="async" data-nimg="1" srcset="/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fexplain.ba7477d6.png&amp;w=1080&amp;q=75 1x, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fexplain.ba7477d6.png&amp;w=1920&amp;q=75 2x" src="https://olu.online/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fexplain.ba7477d6.png&amp;w=1920&amp;q=75"/></p>
<p>A particular part of this process to note is the two operations with <code dir="ltr">lamport timestamps</code> of <code dir="ltr">0:3</code> and <code dir="ltr">1:3</code>. Initially, the <code dir="ltr">1:3</code> operation moving <code dir="ltr">C</code> to <code dir="ltr">B</code> was created and applied locally, followed by receiving <code dir="ltr">Peer0</code>&#39;s <code dir="ltr">0:3</code> operation moving <code dir="ltr">B</code> to <code dir="ltr">C</code>. In <code dir="ltr">lamport timestamp</code> order, <code dir="ltr">0:3</code> is less than <code dir="ltr">1:3</code> but greater than <code dir="ltr">1:2</code> (with peer as the tiebreaker when counters are equal). To apply the new op, the <code dir="ltr">1:3</code> operation is undone first, moving <code dir="ltr">C</code> back to its old parent <code dir="ltr">A</code>, then <code dir="ltr">0:3</code> moving <code dir="ltr">B</code> to <code dir="ltr">C</code> is applied. After that, <code dir="ltr">1:3</code> is redone, attempting to move <code dir="ltr">C</code> to <code dir="ltr">B</code> again (the old parent remains <code dir="ltr">A</code>, omitted in the animation). However, a cycle is detected during this attempt, preventing the operation from taking effect, and the state of the tree remains unchanged. This completes an <code dir="ltr">undo-do-redo</code> process.</p>
<h3>CRDT: Mutable Tree Hierarchy<a href="#crdt-mutable-tree-hierarchy" id="crdt-mutable-tree-hierarchy" aria-label="Permalink for this section"></a></h3>
<p>Evan Wallace has developed an innovative algorithm that enables each node to track all its historical parent nodes, attaching a counter to each recorded parent. The count value of a new parent node is 1 higher than that of all the node&#39;s historical parents, indicating the update sequence of the node&#39;s parents. The parent with the highest count is considered the current parent node.</p>
<p>During synchronization, this parent node information is also synced. If a cycle occurs, a heuristic algorithm reattaches the nodes causing the cycle back to the nearest historical parent node that won&#39;t cause a cycle and is connected to the root node, thus updating the parent node record. This process is repeated until all nodes causing cycles are reattached to the tree, achieving all replica synchronization of the tree structure. The demo in <a href="https://madebyevan.com/algos/crdt-mutable-tree-hierarchy/" target="_blank" rel="noreferrer">Evan&#39;s blog<span> (opens in a new tab)</span></a> clearly illustrates this process.</p>
<p>As Evan summarized at the end of the article, this algorithm does not require the expensive <code dir="ltr">undo-do-redo</code> process. However, each time a remote move is received, the algorithm needs to determine if all nodes are connected to the root node and reattach the nodes causing cycles back to the tree, which can perform poorly when there are too many nodes.</p>
<p>I established a <a href="https://github.com/Leeeon233/movable-tree-crdt" target="_blank" rel="noreferrer">benchmark<span> (opens in a new tab)</span></a> to compare the performance of the movable tree algorithms.</p>
<h2>Movable Tree CRDTs implementation in Loro<a href="#movable-tree-crdts-implementation-in-loro" id="movable-tree-crdts-implementation-in-loro" aria-label="Permalink for this section"></a></h2>
<p>Loro implements the algorithm proposed by Martin Kleppmann et al., <strong><em><a href="https://martin.kleppmann.com/2021/10/07/crdt-tree-move-operation.html" target="_blank" rel="noreferrer">A highly-available move operation for replicated trees<span> (opens in a new tab)</span></a></em></strong>. On one hand, this algorithm has high performance in most real world scenarios. On the other hand, the core <code dir="ltr">undo-do-redo</code> process of the algorithm is highly similar to how REG (Replayable Event Graph) applies remote updates in Loro. Introduction about <strong>REG</strong> can be found in our previous <a href="https://www.loro.dev/blog/loro-richtext#brief-introduction-to-replayable-event-graph" target="_blank" rel="noreferrer">blog<span> (opens in a new tab)</span></a>.</p>
<p>Movable tree has been introduced in detail, but there is still another problem of tree structure that has not been solved. For movable tree, in some real use cases, we still need the capability to sort child nodes. This is necessary for outline notes or layer management in graphic design softwares. Users need to adjust node order and sync it to other collaborators or devices.</p>
<p>We integrated the <code dir="ltr">Fractional Index</code> algorithm into Loro and combined it with the movable tree, making the child nodes of the movable tree sortable.</p>
<p>There are many introductions to <code dir="ltr">Fractional Index</code> on the web, You can read more about <code dir="ltr">Fractional Index</code> in the <a href="https://www.figma.com/blog/realtime-editing-of-ordered-sequences" target="_blank" rel="noreferrer">Figma blog<span> (opens in a new tab)</span></a> or <a href="https://madebyevan.com/algos/crdt-fractional-indexing/" target="_blank" rel="noreferrer">Evan blog<span> (opens in a new tab)</span></a>. In simple terms, <code dir="ltr">Fractional Index</code> assigns a sortable value to each object, and if a new insertion occurs between two objects, the <code dir="ltr">Fractional Index</code> of the new object will be between the left and right values. What we want to speak about more here is how to deal with potential conflicts brought by <code dir="ltr">Fractional Index</code> in CRDTs systems.</p>
<h3>Potential Conflicts in Child Node Sorting<a href="#potential-conflicts-in-child-node-sorting" id="potential-conflicts-in-child-node-sorting" aria-label="Permalink for this section"></a></h3>
<p>As our applications are in a distributive condition, when multiple peers insert new nodes in the same position, the same <code dir="ltr">Fractional Index</code> would be assigned to these differing content but same position nodes. When updates from the remote are applied to local, conflicts arise as the same <code dir="ltr">Fractional Index</code> is encountered.</p>
<p>In Loro, we retain these identical <code dir="ltr">Fractional Index</code> and use <code dir="ltr">PeerID</code> (unique ID of every Peer) as the tie-breaker for the relative order judgment of the same <code dir="ltr">Fractional Index</code>.</p>
<p><img loading="lazy" width="1096" height="465" decoding="async" data-nimg="1" srcset="/_next/image?url=%2F_next%2Fstatic%2Fmedia%2FFI-and-PeerID-dark.82febfcc.png&amp;w=1200&amp;q=75 1x, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2FFI-and-PeerID-dark.82febfcc.png&amp;w=3840&amp;q=75 2x" src="https://olu.online/_next/image?url=%2F_next%2Fstatic%2Fmedia%2FFI-and-PeerID-dark.82febfcc.png&amp;w=3840&amp;q=75"/></p>
<p>Although this solved the sorting problem among the same <code dir="ltr">Fractional Index</code> nodes from different peers, it impacted the generation of new <code dir="ltr">Fractional Index</code> as we cannot generate a new <code dir="ltr">Fractional Index</code> between two same ones. We use two methods to solve this problem:</p>
<ol>
<li>The first method, as stated in Evan&#39;s blog, we could add a certain amount of jitter to each generated <code dir="ltr">Fractional Index</code>, (for the ease of explanation, all examples below take decimal fraction as the <code dir="ltr">Fractional Index</code>) for example, when generating a new <code dir="ltr">Fractional Index</code> between 0 and 1, it should have been 0.5, but through random jitters, it could be <code dir="ltr">0.52712</code>, <code dir="ltr">0.58312</code>, <code dir="ltr">0.52834</code>, etc., thus significantly reducing the chance of same <code dir="ltr">Fractional Index</code> appearing.</li>
<li>If the situation arises where the same <code dir="ltr">Fractional Index</code> is present on both sides, we can handle this problem by resetting these <code dir="ltr">Fractional Index</code>. For example, if we need to insert a new node between <code dir="ltr">0.7@A</code> and <code dir="ltr">0.7@B</code> (which indicates <code dir="ltr">Fractional Index</code> @ <code dir="ltr">PeerID</code>), instead of generating a new <code dir="ltr">Fractional Index</code> between 0.7 and 0.7, we could assign two new <code dir="ltr">Fractional Index</code> respectively for the new node and the <code dir="ltr">0.7@B</code> node between 0.7 and 1, which could be understood as an extra move operations.</li>
</ol>
<p><img loading="lazy" width="2592" height="1354" decoding="async" data-nimg="1" srcset="/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fsame-FI-dark.79d4bd5a.png&amp;w=3840&amp;q=75 1x" src="https://olu.online/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fsame-FI-dark.79d4bd5a.png&amp;w=3840&amp;q=75"/></p>
<h3>Implementation and Encoding Size<a href="#implementation-and-encoding-size" id="implementation-and-encoding-size" aria-label="Permalink for this section"></a></h3>
<p>Introducing <code dir="ltr">Fractional Index</code> brings the advantage of node sequence. What about encoding size?</p>
<p>Loro uses <a href="https://github.com/drifting-in-space/fractional_index" target="_blank" rel="noreferrer">drifting-in-space<span> (opens in a new tab)</span></a> <code dir="ltr">Fractional Index</code> implementation based on <code dir="ltr">Vec&lt;u8&gt;</code>, which is base 256. In other words, you need to continuously insert 128 values forward or backward from the default value to increase the byte size of the <code dir="ltr">Fractional Index</code> by 1. The worst storage overhead case, such as inserting new values alternately each time. For example, the initial sequence is <code dir="ltr">ab</code>, insert <code dir="ltr">c</code> between <code dir="ltr">a</code> and <code dir="ltr">b</code>, then insert <code dir="ltr">d</code> between <code dir="ltr">c</code> and <code dir="ltr">b</code>, then <code dir="ltr">e</code> between <code dir="ltr">c</code> and <code dir="ltr">d</code>, like:</p>
<div><pre data-language="js" data-theme="default"><code dir="ltr" data-language="js" data-theme="default"><span><span>ab    </span><span>// [128] [129, 128]</span></span>
<span><span>acb   </span><span>// [128] [129, 127, 128] [129, 128]</span></span>
<span><span>acdb  </span><span>// [128] [129, 127, 128] [129, 127, 129, 128] [129, 128]</span></span>
<span><span>acedb </span><span>// [128] [129, 127, 128] [129, 127, 129, 127, 128] [129, 127, 129, 128] [129, 128]</span></span></code></pre></div>
<p>a new operation would cause an additional byte to be needed. But such a situation is very rare.</p>
<p>Considering that potential conflicts wouldn&#39;t appear frequently in most applications, Loro simply extended the implementation, the original implementation produced new <code dir="ltr">Fractional Index</code> in <code dir="ltr">Vec&lt;u8&gt;</code> by only increasing or decreasing 1 in certain index to achieve relative sorting. The simple jitter solution was added, by appending random bytes in length of jitter value to <code dir="ltr">Fractional Index</code>. To enable jitter in js, you can use <code dir="ltr">doc.setFractionalIndexJitter(number)</code> with a positive value. But this will increase the encoding size slightly, but each <code dir="ltr">Fractional Index</code> only adds <code dir="ltr">jitter</code> bytes. If you want to generate <code dir="ltr">Fractional Index</code> at the same position with 99% probability without conflict, the relationship between <code dir="ltr">jitter</code> settings and the maximum number of concurrent edits <code dir="ltr">n</code> will be:</p>
<table><thead><tr><th><p>jitter</p></th><th><p>max num of concurrent edits</p></th></tr></thead><tbody><tr><td><p>1</p></td><td><p>3</p></td></tr><tr><td><p>2</p></td><td><p>37</p></td></tr><tr><td><p>3</p></td><td><p>582</p></td></tr></tbody></table>
<p>When there are numerous <code dir="ltr">Fractional Indexes</code>, there will be many common prefixes after being sorted, when Loro encodes these <code dir="ltr">Fractional Indexes</code>, prefix optimization would be implemented. Each <code dir="ltr">Fractional Index</code> only saves the amount of same prefix bits and remaining bytes with the previous one, which further downsizes the overall encoding size.</p>
<h3>Related work<a href="#related-work" id="related-work" aria-label="Permalink for this section"></a></h3>
<p>Other than using Fractional Index, there are other movable list CRDT that can make sibling nodes of the tree in order. One of these algorithms is Martin Kleppmann&#39;s <a href="https://martin.kleppmann.com/2020/04/27/papoc-list-move.html" target="_blank" rel="noreferrer">Moving Elements in List CRDTs<span> (opens in a new tab)</span></a>, which has been used in Loro&#39;s <a href="https://www.loro.dev/docs/tutorial/list" target="_blank" rel="noreferrer">Movable List<span> (opens in a new tab)</span></a>.</p>
<p>In comparison, the implementation of <code dir="ltr">Fractional Index</code> solution is simpler, and no stable position representation is provided for child nodes when modeling nodes in a tree, otherwise, the overall tree structure would be too complex. However, the <code dir="ltr">Fractional Index</code> has the problem of <a href="https://vlcn.io/blog/fractional-indexing#interleaving" target="_blank" rel="noreferrer">interleaving<span> (opens in a new tab)</span></a>, but this is acceptable when some only need relative order and do not require strict sequential semantics, such as figma layer items, multi-level bookmarks, etc.</p>
<h2>Benchmark<a href="#benchmark" id="benchmark" aria-label="Permalink for this section"></a></h2>
<p>We conducted performance benchmarks on the Movable Tree implementation by Loro, including scenarios of random node movement, switching to historical versions, and performance under extreme conditions with significantly deep tree structures. The results indicate that it is capable of supporting real-time collaboration and enabling seamless historical version checkouts.</p>
<table><thead><tr><th>Task</th><th>Time</th><th>Setup</th></tr></thead><tbody><tr><td>Move 10000 times randomly</td><td>28 ms</td><td>Create 1000 nodes first</td></tr><tr><td>Switch to different versions 1000 times</td><td>153 ms</td><td>Create 1000 nodes and move 1000 times first</td></tr><tr><td>Switch to different versions 1000 times in a tree with depth of 300</td><td>701 ms</td><td>The new node is a child node of the previous node</td></tr></tbody></table>
<div><p>Test environment: M2 Max CPU, you can find the bench code
<a href="https://github.com/loro-dev/loro/blob/main/crates/loro-internal/benches/tree.rs" target="_blank" rel="noreferrer">here<span> (opens in a new tab)</span></a>.</p></div>
<h2>Usage<a href="#usage" id="usage" aria-label="Permalink for this section"></a></h2>
<div><pre data-language="tsx" data-theme="default"><code dir="ltr" data-language="tsx" data-theme="default"><span><span>import</span><span> { Loro</span><span>,</span><span> LoroTree</span><span>,</span><span> LoroTreeNode</span><span>,</span><span> LoroMap } </span><span>from</span><span> </span><span>&#34;loro-crdt&#34;</span><span>;</span></span>
<span> </span>
<span><span>let</span><span> doc </span><span>=</span><span> </span><span>new</span><span> </span><span>Loro</span><span>();</span></span>
<span><span>let</span><span> tree</span><span>:</span><span> </span><span>LoroTree</span><span> </span><span>=</span><span> </span><span>doc</span><span>.getTree</span><span>(</span><span>&#34;tree&#34;</span><span>);</span></span>
<span><span>let</span><span> root</span><span>:</span><span> </span><span>LoroTreeNode</span><span> </span><span>=</span><span> </span><span>tree</span><span>.createNode</span><span>();</span></span>
<span><span>// By default, append to the end of the parent node&#39;s children list</span></span>
<span><span>let</span><span> node </span><span>=</span><span> </span><span>root</span><span>.createNode</span><span>();</span></span>
<span><span>// Specify the child&#39;s position</span></span>
<span><span>let</span><span> node2 </span><span>=</span><span> </span><span>root</span><span>.createNode</span><span>(</span><span>0</span><span>);</span></span>
<span><span>// Move `node2` to be the last child of `node`</span></span>
<span><span>node2</span><span>.move</span><span>(node);</span></span>
<span><span>// Move `node` to be the first child of `node2`</span></span>
<span><span>node</span><span>.move</span><span>(node2</span><span>,</span><span> </span><span>0</span><span>);</span></span>
<span><span>// Move the node to become the root node</span></span>
<span><span>node</span><span>.move</span><span>();</span></span>
<span><span>// Move the node to be positioned after another node</span></span>
<span><span>node</span><span>.moveAfter</span><span>(node2);</span></span>
<span><span>// Move the node to be positioned before another node</span></span>
<span><span>node</span><span>.moveBefore</span><span>(node2);</span></span>
<span><span>// Retrieve the index of the node within its parent&#39;s children</span></span>
<span><span>let</span><span> index </span><span>=</span><span> </span><span>node</span><span>.index</span><span>();</span></span>
<span><span>// Get the `Fractional Index` of the node</span></span>
<span><span>let</span><span> fractionalIndex </span><span>=</span><span> </span><span>node</span><span>.fractionalIndex</span><span>();</span></span>
<span><span>// Access the associated data map container</span></span>
<span><span>let</span><span> nodeData</span><span>:</span><span> </span><span>LoroMap</span><span> </span><span>=</span><span> </span><span>node</span><span>.data;</span></span></code></pre></div>
<h3>Demo<a href="#demo" id="demo" aria-label="Permalink for this section"></a></h3>
<p>We developed a simulated Todo app with data synchronization among multiple peers using Loro, including the use of <code dir="ltr">Movable Tree</code> to represent subtask relationships, <code dir="ltr">Map</code> to represent various attributes of tasks, and <code dir="ltr">Text</code> to represent task titles, etc. In addition to basic creation, moving, modification, and deletion, we also implemented version switching based on Loro. You can drag the scrollbar to switch between all the historical versions that have been operated on.</p>

<h2>Summary<a href="#summary" id="summary" aria-label="Permalink for this section"></a></h2>
<p>This article discusses why implementing Movable Tree CRDTs is difficult, and presents two innovative algorithms for movable trees.</p>
<p>For implementation, Loro has integrated <strong><em><a href="https://martin.kleppmann.com/2021/10/07/crdt-tree-move-operation.html" target="_blank" rel="noreferrer">A highly-available move operation for replicated trees<span> (opens in a new tab)</span></a></em></strong> to implement the hierarchical movement of the Tree, and integrated the <code dir="ltr">Fractional Index</code> implementation by <a href="https://github.com/drifting-in-space/fractional_index" target="_blank" rel="noreferrer">drifting-in-space<span> (opens in a new tab)</span></a> to achieve the movement between child nodes. This can meet the needs of various application scenarios.</p>
<p>If you are developing collaborative applications or are interested in CRDT algorithms, you are welcome to join <a href="https://discord.gg/tUsBSVfqzf" target="_blank" rel="noreferrer">our community<span> (opens in a new tab)</span></a>.</p></main></article></div>
  </body>
</html>
