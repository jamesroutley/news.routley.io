<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.hillelwayne.com/post/always-more-history/">Original</a>
    <h1>There&#39;s always more history (2020)</h1>
    
    <div id="readability-page-1" class="page"><article lang="en">
    

    
    

    <div>
  

<p>Last month I researched two historical questions. I originally posted summaries on Twitter and am reproducing both here.</p>

<h3 id="why-vim-uses-hjkl">Why Vim Uses hjkl</h3>

<p><strong>Question:</strong> Why does Vim use hjkl and not the arrow keys for navigation?</p>

<p><strong>Common Explanation:</strong> It keeps your fingers on the home row.</p>

<p><strong>Historical Explanation:</strong> Bill Joy developed vi on the ADM-3A, which didn’t have dedicated arrow keys. If you look at the ADM keyboard, it put the arrow keys on the hjkl keys. So Joy used that same logic for vi, which led to Vim.</p>

<center>
<figure>
<img src="https://www.hillelwayne.com/post/always-more-history/adm-keyboard.png" alt="picture of ADM keyboard"/>
<figcaption>The ADM keyboard. <a href="https://catonmat.net/why-vim-uses-hjkl-as-arrow-keys">(source)</a></figcaption>
</figure>
</center>

<p><strong>Deeper History</strong>: It’s odd, though, that the ADM used hjkl for arrow keys. Why <em>those</em> letters?</p>

<p>There’s a very good reason for this. Here’s the 1967 version of the ASCII table:</p>

<figure>
<img src="https://www.hillelwayne.com/post/always-more-history/ascii-table.png" alt="1967 ASCII table"/>
<figcaption><a href="https://sltls.org/ASCII">(source)</a></figcaption>
</figure>

<p>Each character has 7 bits. The first 32 characters are “control characters”, which were important for communication but weren’t actual characters. Computer keyboards, patterned off of QWERTY typewriters, needed a way to input these characters while keeping the same layout. They solved this with an extra “control” key to change inputs from physical characters to control characters. Holding down the control key would zero the 6th and 7th highest bits of the pressed key. If you wanted to send a backspace control character, you’d hold down ctrl+H (or ^H). That would convert <code>100 1000</code> to <code>000 1000</code>. Similarly, for a line separator, you’d press ^J.</p>

<p>If we flip through <a href="http://www.bitsavers.org/pdf/learSiegler/ADM_3/DP2880486F_ADM3A_UM_Apr86.pdf">the ADM manual</a>, we see that the ADM used “backspace” to mean “move the cursor left” without deleting the current character. With ^H and ^J already being used as left and down, it made sense to turn ^K and ^L into up and right. This means that ADM users were already navigating with hjkl and Bill Joy just followed the precedent for vi.</p>

<h3 id="why-javascript-months-start-from-0">Why JavaScript months start from 0</h3>

<p><strong>Question:</strong> In the JavaScript date API, months go 0-11, not 1-12. Why?</p>

<p><strong>Common Explanation:</strong> It makes array indexing easier. You want to show the name of the month, not the number. You’d have an array with all the month names and use <code>date.getMonth()</code> to index it.</p>

<p><strong>Historical Explanation:</strong> It’s this way to be compatible with Java, which was that way to be compatible with C.</p>

<p><strong>Deeper History:</strong> Then why did C do it? And why is every calendar time field in C 0-indexed <em>except</em> the day of the month?</p>

<p>The ANSI C89 standard first officially established the fields of the <code>tm_date</code> structure, which remained almost entirely unchanged to the present day. The standard came out 17 years after C did and formalized a lot of what was already standard for various Unixes. If we then look back in <a href="https://minnie.tuhs.org/cgi-bin/utree.pl">Unix history</a>, we find that the <a href="https://www.tuhs.org/cgi-bin/utree.pl?file=V5/usr/source/s3/ctime.c">earliest C example</a> of <code>&lt;ctime.c&gt;</code> didn’t use a struct, but instead stored the time data in an array.</p>
<div><pre><code data-lang="c"><span></span><span>#define SEC   0</span>
<span>#define MIN   1</span>
<span>#define HOUR  2</span>
<span>#define MDAY  3</span>
<span>#define MON   4</span>
<span>#define YEAR  5</span>
<span>#define WDAY  6</span>
<span>#define YDAY  7</span>
<span>#define ISDAY 8</span>
</code></pre></div>

<p><code>ctime</code> stores the time of day as second-minute-hour (SMH), while it’s displayed as HMS. This peculiarity makes sense when we look at how the code is actually used. Unix 5 only used this data for showing users the time:</p>
<div><pre><code data-lang="c"><span></span><span>asctime(t)</span>
<span>int</span><span> </span><span>*</span><span>t;</span>
<span>{</span>
<span>    </span><span>register</span><span> </span><span>char</span><span> </span><span>*</span><span>cp, </span><span>*</span><span>ncp;</span>
<span>    </span><span>register</span><span> </span><span>int</span><span> </span><span>*</span><span>tp;</span>

<span>    cp </span><span>=</span><span> cbuf;</span>
<span>    </span><span>for</span><span> (ncp </span><span>=</span><span> </span><span>&#34;Day Mon 00 00:00:00 1900</span><span>\n</span><span>&#34;</span><span>; </span><span>*</span><span>cp</span><span>++</span><span> </span><span>=</span><span> </span><span>*</span><span>ncp</span><span>++</span><span>;);</span>
<span>    ncp </span><span>=</span><span> </span><span>&amp;</span><span>&#34;SunMonTueWedThuFriSat&#34;</span><span>[</span><span>3</span><span>*</span><span>t[</span><span>6</span><span>]];</span>
<span>    cp </span><span>=</span><span> cbuf;</span>
<span>    </span><span>*</span><span>cp</span><span>++</span><span> </span><span>=</span><span> </span><span>*</span><span>ncp</span><span>++</span><span>;</span>
<span>    </span><span>*</span><span>cp</span><span>++</span><span> </span><span>=</span><span> </span><span>*</span><span>ncp</span><span>++</span><span>;</span>
<span>    </span><span>*</span><span>cp</span><span>++</span><span> </span><span>=</span><span> </span><span>*</span><span>ncp</span><span>++</span><span>;</span>
<span>    cp</span><span>++</span><span>;</span>
<span>    tp </span><span>=</span><span> </span><span>&amp;</span><span>t[</span><span>4</span><span>];</span>
<span>    ncp </span><span>=</span><span> </span><span>&amp;</span><span>&#34;JanFebMarAprMayJunJulAugSepOctNovDec&#34;</span><span>[(</span><span>*</span><span>tp)</span><span>*</span><span>3</span><span>]; </span><span>// (a)</span>
<span>    </span><span>*</span><span>cp</span><span>++</span><span> </span><span>=</span><span> </span><span>*</span><span>ncp</span><span>++</span><span>;</span>
<span>    </span><span>*</span><span>cp</span><span>++</span><span> </span><span>=</span><span> </span><span>*</span><span>ncp</span><span>++</span><span>;</span>
<span>    </span><span>*</span><span>cp</span><span>++</span><span> </span><span>=</span><span> </span><span>*</span><span>ncp</span><span>++</span><span>;</span>
<span>    cp </span><span>=</span><span> numb(cp, </span><span>*--</span><span>tp); </span><span>// (b)</span>
<span>    cp </span><span>=</span><span> numb(cp, </span><span>*--</span><span>tp</span><span>+</span><span>100</span><span>); </span><span>// (c)</span>
<span>    cp </span><span>=</span><span> numb(cp, </span><span>*--</span><span>tp</span><span>+</span><span>100</span><span>);</span>
<span>    cp </span><span>=</span><span> numb(cp, </span><span>*--</span><span>tp</span><span>+</span><span>100</span><span>);</span>
<span>    cp </span><span>=+</span><span> </span><span>2</span><span>;</span>
<span>    cp </span><span>=</span><span> numb(cp, t[YEAR]);</span>
<span>    </span><span>return</span><span>(cbuf);</span>
<span>}</span>
</code></pre></div>

<p>I’ve annotated some interesting lines. We first used the stored month at (a). Instead of storing all of the months names in an array, the developers stored the three-character abbreviations of each month in a single string and then used the month number as part of the pointer arithmetic to get the exact three bytes they needed. They then get the day (b) and then the HMS (c) by decrementing the pointer address three times. So storing it as SMH saves them an extra explicit jump (since they iterate through it backwards). They took advantage of the fact that, because the fields are stored as elements of an array, they are right next to each other <em>in memory</em>.</p>

<p>This all tells us that they were optimizing <em>everything</em>. This makes sense, as the first versions of Unix were developed on the PDP-7. A decent computer in the 1970s might have a few kilobytes of memory. If you tried to store all of the month names in memory, that could be almost 10% of your <em>total</em> RAM!</p>

<p>So the developers needed to use as little memory and CPU as possible, and they did pointer arithmetic to save both, and the arithmetic is easier with 0-indexed months than with 1-indexed. On the other hand, they never used day of month for anything except user display (b), so that was stored directly in the representable form.</p>

<p>This explanation also explains a small inconsistency in the structure: <code>MDAY</code> (day of month) starts from 1, while <code>YDAY</code> (day of <em>year</em>) starts from 0. This is consistent in the “computation vs display” dichotomy, as the day of year is never shown to the user. It’s only used to calculate when daylight savings starts (in <code>sunday</code> and <code>localtime</code>).</p>

<hr/>

<p>Both of those explanations are incomplete. We can go deeper than “just” two layers of history. For the hjkl question, we can ask why the <a href="https://textfiles.meulie.net/bitsaved/Books/Mackenzie_CodedCharSets.pdf">ASCII table is laid out that way</a>. For the <code>tm_date</code> question, we can hunt down earlier versions of Unix, see what they did in assembly, or talk to the developers directly. And even that’s not the only layer. We can always look further, peeling back more and more layers of the history.</p>

<p>But two layers is enough for this essay. With two layers, we can see a common pattern in studying history, the difference between answers and explanation. When asked why something is the way it is, most people will give a post-hoc rationalization. They’ll see the present and come up with reasons why it’s “better” for things to be that way. If you look a little into the past, you often see that “things are this way because they were this way”. And if you look deeper, you see the forces that lead to things <em>becoming</em> that way.</p>

<p>That difference between the first and second layers of history leads to an unfortunate trap. People see the first layer and assume that’s all there is. This makes history seem irrelevant. Even if you realize there’s more to the story, excavating each layer takes considerably more work than the layer before. You can learn that Bill Joy used an ADM-3A with a quick web search. Finding the reasons beyond that took me two hours.</p>

<p>Some other examples of layers of history: Why do modern languages use <code>=</code> for assignment? The first layer is “blame C”, the second layer involved <a href="https://www.hillelwayne.com/post/equals-as-assignment/">tracing the chain of languages from ALGOL to C</a>. Why do so many interviewers ask linked list questions? The first layer is <em>Cracking the Coding Interview</em>, the second layer involved <a href="https://www.hillelwayne.com/talks/software-history/">reading hundreds of old Usenet posts and interviewing retired programmers</a>.</p>

<p>But it’s all worth the effort. Digging into the second layer teaches us much more about the context and reasons for why things are the way they are. And I can’t deny the puzzle aspect of it all, the joy in solving a mystery. Lost knowledge found again.</p>

<p><em>Thanks to Lito Nicolai and <a href="http://alexkoppel.com/">Alex Koppel</a> for feedback. I shared the first draft of this essay on my <a href="https://buttondown.email/hillelwayne/">newsletter</a>. If you like my writing, why not subscribe?</em></p>


</div>

    



  </article></div>
  </body>
</html>
