<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://macwright.com/2023/10/29/tidbyt-rs.html">Original</a>
    <h1>Rendering Tidbyt graphics in Rust</h1>
    
    <div id="readability-page-1" class="page"><div><p>One of my other long-term projects has been building new graphics for my <a href="https://macwright.com/2022/03/11/tidbyt-review">Tidbyt</a> in Rust. It has been a slow, silly process in which I celebrate when a single pixel lights up on the device. I’m not even writing firmware or code that runs “on the device” - that’s a stretch goal for someday. I’m just writing a Rust program that renders some WebP graphics and pushes them to <a href="https://tidbyt.com/">Tidbyt</a>’s API.</p><p><img alt="The new display" src="https://www.wildlondon.org.uk/images/2023-10-29-tidbyt-rs-the-new-display.jpeg"/></p><p>I’ve had a lot of type 2 fun. I’ve also learned a lot more about Rust.</p><p>It’s probably not useful for many people, but the <a href="https://github.com/tmcw/tidbyt-rs">repository is now open source</a>. There’s a little implementation of checking a Fastmail email account to get a count of unread emails and Strava for new runs.</p><p>Plus, there’s an implementation of checking weather with <a href="https://www.weather.gov/">weather.gov</a>, UV exposure from an <a href="https://www.epa.gov/">EPA</a> API, and AQI from <a href="https://www.airnow.gov/">AirNow</a>. Isn’t it nice to feel the benefits of paying taxes by using these free APIs from government services?</p><p>There have been lots of high points to the project so far. The Rust compiler can be really fast when it’s recompiling projects. The error messages it emits can be really helpful. And the quality of the average Rust project seems really high: even a niche crate that I used for this project - <a href="https://github.com/meh/rust-bdf">bdf</a> was really solid and worked right off the bat.</p><p>This is markedly better than my experience with the JavaScript ecosystem and NPM modules: I read through every new module that I add as a dependency and have to sort through the old or overcomplicated duds. A lot of the times, the popular <a href="https://www.npmjs.com/package/marked">module</a> in the JavaScript ecosystem is kind of not-very-good and has much better <a href="https://www.npmjs.com/package/micromark">alternatives</a> that people should be using instead.</p><h3 id="i-love-anyhow">I love anyhow</h3><p>Why isn’t the <a href="https://docs.rs/anyhow/latest/anyhow/index.html">anyhow crate</a> part of Rust core? Every time I’ve needed to return <code>Result</code> types from functions, or unwrap <code>Option</code> values within functions that return a <code>Result</code>, I get stuck in some vague <code>dyn</code> gotcha with the borrow-checker, and then I just sprinkle anyhow on it, and it works.</p><p>I barely understand how anyhow does its magic, but so far I haven’t needed to: I just use it for everything and it makes Rust much less painful. When I recently removed all of the lazy use of <code>.unwrap()</code> in this project - a method that gets the “successful” values out of <code>Result</code> and <code>Option</code> objects or throws if the Result is an error or the Option is nothing, I was stuck until I realized that I could use the anyhow <a href="https://docs.rs/anyhow/latest/anyhow/trait.Context.html">Context</a> trait which gives <code>Option</code>s a <code>.context</code> method that lets you unwrap them in methods that return <code>Result</code>.</p><h3 id="rendering-pixel-art-in-rust">Rendering pixel art in Rust</h3><p>This project is all to run a Tidbyt display. This is what it looked like <a href="https://macwright.com/2022/03/11/tidbyt-review">last time I wrote about it</a>:</p><p><picture><source srcset="/images/2022-03-11-tidbyt-review-tidbyt-on-a-shelf.webp" type="image/webp"/><img alt="Tidbyt on a shelf" src="https://www.wildlondon.org.uk/images/2022-03-11-tidbyt-review-tidbyt-on-a-shelf.jpg"/></picture></p><p>The images I’m generating are 64x32 pixels, and the pixels are huge, so aesthetically I want everything to be crisp and non-antialiased. Which is a fun challenge for this project, because a lot of graphics technologies are built for floating-point pixels and anti-aliasing by default.</p><p>My first inclination was to use <a href="https://bevyengine.org/">Bevy</a> the game engine for Rust. It’s super cool, but seemed like kind of overkill for this project - if I ever want to run this on the Tidbyt hardware directly, my guess is that Bevy will be too heavyweight.</p><p>Bevy seemed to heavyweight, and <a href="https://docs.rs/embedded-graphics/latest/embedded_graphics/">embedded_graphics</a> seemed too low-level. <a href="https://github.com/jrmuizel/raqote">Raqote</a> is just right. And Raqote being adopted by the huge <a href="https://github.com/servo/servo">Servo browser project</a> was a point of trustworthiness. It’s been pretty reliable.</p><p>The code to make all of this work together has been kind of hilariously low-level. For example, here’s a snippet of how I’m rendering letters:</p><div><div><pre><code><span>for</span> <span>px</span> <span>in</span> <span>glyph</span><span>.pixels</span><span>()</span> <span>{</span>
  <span>let</span> <span>x</span> <span>=</span> <span>px</span><span>.0</span> <span>.0</span><span>;</span>
  <span>let</span> <span>y</span> <span>=</span> <span>px</span><span>.0</span> <span>.1</span><span>;</span>
  <span>let</span> <span>white</span> <span>=</span> <span>px</span><span>.1</span><span>;</span>
  <span>if</span> <span>white</span> <span>{</span>
    <span>dt</span><span>.fill_rect</span><span>(</span>
      <span>start</span><span>.x</span> <span>+</span> <span>x</span> <span>as</span> <span>f32</span> <span>+</span> <span>x_offset</span> <span>as</span> <span>f32</span><span>,</span>
      <span>start</span><span>.y</span> <span>+</span> <span>y</span> <span>as</span> <span>f32</span> <span>+</span> <span>y_offset</span> <span>as</span> <span>f32</span><span>,</span>
      <span>1.</span><span>,</span> <span>1.</span><span>,</span> <span>color</span><span>,</span> <span>&amp;</span><span>DrawOptions</span><span>::</span><span>new</span><span>(),</span>
    <span>)</span>
  <span>}</span>
<span>}</span>
</code></pre></div></div><p>That’s right, I use the bdf crate to read <a href="https://en.wikipedia.org/wiki/Glyph_Bitmap_Distribution_Format">bitmap fonts</a> into a map of pixels to on &amp; off values, and render those fonts pixel-by-pixel. I use the font’s glyph advance information to manually move forward to draw the next character. The same kind of process goes for rendering the pixels to a WebP image: <a href="https://github.com/tmcw/tidbyt-rs/blob/c4e01a30610f63d1494f5e2fc8beef50db294cde/src/draw_buffer.rs">pixel by pixel</a>. Like I said, type 2 fun.</p><h3 id="on-chatgpt">On ChatGPT</h3><p>So, I’ll admit, I use ChatGPT to write bash scripts sometimes. I don’t know bash very well and have no interest in learning it. I don’t use it for harder problems because, brace yourself, I think that cognitive load is good. I know that cars and bicycles exist, but I still go on runs because it’s not just about getting to the destination.</p><p>But, at many points in this project I’ve reached for ChatGPT (4.0) in moments of weakness, and it is not very good. It hallucinates methods that don’t exist. It can’t solve borrow checker problems. Four or five broken solutions deep, I just start regretting the CO<sub>2</sub> that this conversation has burned and promising myself that I’ll just read more documentation.</p><h3 id="the-borrow-checker">The borrow checker</h3><p>Complaining about the borrow checker in Rust is like writing about NaN in JavaScript or the GIL in Python, but in reality, how bad is it?</p><p>In this project, it’s been an intermittent annoyance. I’ll have an hour of coding with everything going according to plan, and then spend an hour trying to refactoring three lines of code into a function. And that is a consistent theme: the more I try to refactor this program into something that’d make sense in Ruby, with small focused functions, the worse the borrow-checking becomes.</p><p>To give an example, here’s the start of my <code>render()</code> method:</p><div><div><pre><code><span>async</span> <span>fn</span> <span>render</span><span>(</span><span>args</span><span>:</span> <span>&amp;</span><span>Args</span><span>)</span> <span>-&gt;</span> <span>Result</span><span>&lt;</span><span>()</span><span>&gt;</span> <span>{</span>
    <span>let</span> <span>local</span><span>:</span> <span>DateTime</span><span>&lt;</span><span>Local</span><span>&gt;</span> <span>=</span> <span>Local</span><span>::</span><span>now</span><span>();</span>
    <span>let</span> <span>width</span> <span>=</span> <span>64i32</span><span>;</span>
    <span>let</span> <span>height</span> <span>=</span> <span>32i32</span><span>;</span>
    <span>let</span> <span>mut</span> <span>config</span> <span>=</span> <span>WebPConfig</span><span>::</span><span>new</span><span>()</span><span>.map_err</span><span>(|</span><span>_s</span><span>|</span> <span>anyhow!</span><span>(</span><span>&#34;WebPConfig failed&#34;</span><span>))</span><span>?</span><span>;</span>
    <span>config</span><span>.lossless</span> <span>=</span> <span>1</span><span>;</span>
    <span>let</span> <span>mut</span> <span>encoder</span> <span>=</span> <span>AnimEncoder</span><span>::</span><span>new</span><span>(</span><span>width</span> <span>as</span> <span>u32</span><span>,</span> <span>height</span> <span>as</span> <span>u32</span><span>,</span> <span>&amp;</span><span>config</span><span>);</span>
    <span>// ...</span>
</code></pre></div></div><p>I think that maybe I want to get a similar encoder somewhere else in my application, so it’d be nice to have a <code>get_encoder()</code> method that encapsulates those first few lines. So, I refactor those few lines into something like</p><div><div><pre><code><span>fn</span> <span>get_encoder</span><span>()</span> <span>-&gt;</span> <span>Result</span><span>&lt;</span><span>AnimEncoder</span><span>&lt;</span><span>&#39;static</span><span>&gt;&gt;</span> <span>{</span>
    <span>let</span> <span>width</span> <span>=</span> <span>64i32</span><span>;</span>
    <span>let</span> <span>height</span> <span>=</span> <span>32i32</span><span>;</span>
    <span>let</span> <span>mut</span> <span>config</span> <span>=</span> <span>WebPConfig</span><span>::</span><span>new</span><span>()</span><span>.map_err</span><span>(|</span><span>_s</span><span>|</span> <span>anyhow!</span><span>(</span><span>&#34;WebPConfig failed&#34;</span><span>))</span><span>?</span><span>;</span>
    <span>config</span><span>.lossless</span> <span>=</span> <span>1</span><span>;</span>
    <span>let</span> <span>mut</span> <span>encoder</span> <span>=</span> <span>AnimEncoder</span><span>::</span><span>new</span><span>(</span><span>width</span> <span>as</span> <span>u32</span><span>,</span> <span>height</span> <span>as</span> <span>u32</span><span>,</span> <span>&amp;</span><span>config</span><span>);</span>
    <span>encoder</span>
<span>}</span>
</code></pre></div></div><p>And the borrow checker is summoned from the dark place in the woods where it lives:</p><div><div><pre><code>error[E0515]: cannot return value referencing local variable `config`
   --&gt; src/main.rs:369:5
    |
368 |     let mut encoder = AnimEncoder::new(width as u32, height as u32, &amp;confi...
    |                                                                     ------- `config` is borrowed here
369 |     Ok(encoder)
    |     ^^^^^^^^^^^ returns a value referencing
                      data owned by the current function
</code></pre></div></div><p>This happened for two major cases:</p><ul><li>The webp crate’s <a href="https://docs.rs/webp/latest/webp/struct.AnimEncoder.html">AnimEncoder</a> takes a reference to a <a href="https://docs.rs/webp/latest/webp/struct.WebPConfig.html">WebPConfig</a>.</li><li>The raqote crate’s <a href="https://docs.rs/raqote/latest/raqote/struct.Image.html">Image struct</a> takes a reference to a slice of pixel data.</li></ul><p>Now, brief intermission from this to thank two people. I complained about these issues as I was hitting them, and <a href="https://daveceddia.com/">Dave Ceddia</a> was <a href="https://twitter.com/dceddia/status/1694121383901495633">extremely helpful</a> on one and <a href="https://theomn.com/">Owen Nelson</a> took time out of his Sunday to <a href="https://mastodon.social/@tmcw/111240591367039356">help me on another</a>. Visit their websites! Appreciate the value of people just being helpful and nice to each other!</p><p>Maybe for reasons of performance, the crates that I’ve been using don’t “take ownership” of some of the arguments of <code>AnimEncoder::new</code> or <code>Image::new</code> - maybe you already have the bytes lying around, and you want to create an Image that refers to those bytes without creating a copy of them. This makes sense, but makes it a lot harder to write a method that configures &amp; returns an <code>AnimEncoder</code> struct or reads an image into bytes and returns an <code>Image</code> struct - the bytes have to belong to something.</p><p>The solution seems to be creating a struct that owns <em>both</em> the Image and the data it refers to, and <em>both</em> the AnimEncoder and its configuration. This worked well for raqote’s <code>Image</code> type, but still.</p><p>I think this is the biggest part of the learning curve of Rust for me. In most other languages, you can pull a few lines of an existing function into a new function and it behaves mostly the same. In Rust, the context really matters – especially for the borrow-checker, but also for <a href="https://doc.rust-lang.org/beta/reference/expressions/operator-expr.html#the-question-mark-operator">the question mark operator</a>, which you can only use in methods that return <code>Result</code> or <code>Option</code> values, and <code>.await</code>, which you can only use in asynchronous functions. JavaScript has the same restriction with its <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await"><code>await</code></a> keyword, but you can still use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then">.then</a> to use Promise values in “synchronous” functions.</p><p>I think the next thing for me to learn is how to use the <a href="https://doc.rust-lang.org/book/ch15-01-box.html">Box</a> and <a href="https://doc.rust-lang.org/book/ch15-04-rc.html">Rc</a> types so I can trade be more free and wild with passing around memory.</p><h3 id="async">Async</h3><p>The borrow checker is still my enemy, but this time around, asynchronous Rust has been pretty painless. I’m using <a href="https://github.com/tokio-rs/tokio">tokio</a> and thankfully haven’t needed to bridge it to any other async runtime.</p><p>I think the coolest moment of all these crates working together was using the <a href="https://docs.rs/cached/latest/cached/">cached</a> macro to cache the requests to different APIs so that I don’t hammer Fastmail’s servers.</p><div><div><pre><code><span>/// Get the number of unread threads in my inbox</span>
<span>#[cached(time</span> <span>=</span> <span>120</span><span>,</span> <span>result</span> <span>=</span> <span>true</span><span>)]</span>
<span>pub</span> <span>async</span> <span>fn</span> <span>get_email_count</span><span>()</span> <span>-&gt;</span> <span>Result</span><span>&lt;</span><span>(</span><span>u64</span><span>,</span> <span>Vec</span><span>&lt;</span><span>u64</span><span>&gt;</span><span>)</span><span>&gt;</span> <span>{</span>
</code></pre></div></div><p>It just worked: one line of code and it worked with an async method that returns a Result. A lot of these crates, the work that the Rust community has been producing, are rock-solid.</p><h3 id="running-on-the-device">Running on the device</h3><p>This whole contraption still generates a Base64-encoded WebP image and sends it to Tidbyt’s web service. It’d be super cool to run on the Tidbyt itself, and they <a href="https://github.com/tidbyt/hdk">released a development kit</a> that lets you re-flash firmware. A baby step in the direction of self-hosting would be to flash firmware with a local URL to pull the image from - I think I could assign a static IP to a home server. It’d be even cooler to use <a href="https://github.com/tailscale/tailscale">Tailscale</a> to handle the networking, but I don’t think that they scale down to the tiny chip on this device: judging by the hardware development kit, it’s some kind of <a href="https://en.wikipedia.org/wiki/ESP32">ESP32</a> chip.</p><p>Rust <em>does</em> have some <a href="https://esp-rs.github.io/book/overview/using-the-standard-library.html">support for the ESP32</a> library, but getting all of that working with the display driver is too big a side project for me, for now.</p><h3 id="the-actual-program">The actual program</h3><p>I’ve mostly written about all the joys of implementing the thing, not much about the thing itself.</p><p>Tidbyt provides a library called <a href="https://github.com/tidbyt/pixlet">pixlet</a> for developing graphics and applications for the display. For 99% of people, you should use that: it solves all the problems I’ve solved and more.</p><p>I wanted to branch out from pixlet, though, first because it’s very locked down: you write pixlet applications in <a href="https://github.com/google/starlark-go/">Starlark</a>, which is a Python-like language. You can’t access the filesystem, and there aren’t many Starlark libraries, though the ones maintained by the folks at Google &amp; Tidbyt are high-quality. Plus, learning Rust is a long-term goal for me and this is a fun justification.</p><p>The display currently features:</p><ul><li>The outdoor temperature</li><li>A warning about UV radiation or AQI if either is high today</li><li>A count of my unread emails</li><li>How many miles I’ve run in the last 7 days</li><li>The time</li></ul><p>Mainly development has been focused on making it more reliable, so that even if Fastmail or NOAA is offline, the display still works, and making it more customizable. It now has a tiny little layout system and a tiny widget system:</p><div><div><pre><code><span>trait</span> <span>Widget</span><span>:</span> <span>Send</span> <span>{</span>
    <span>// Gets the width of the given widget</span>
    <span>fn</span> <span>measure</span><span>(</span><span>&amp;</span><span>self</span><span>)</span> <span>-&gt;</span> <span>Point</span><span>;</span>
    <span>fn</span> <span>frame_count</span><span>(</span><span>&amp;</span><span>self</span><span>)</span> <span>-&gt;</span> <span>u32</span><span>;</span>
    <span>fn</span> <span>render</span><span>(</span><span>&amp;</span><span>self</span><span>,</span>
      <span>dt</span><span>:</span> <span>&amp;</span><span>mut</span> <span>DrawTarget</span><span>,</span>
      <span>point</span><span>:</span> <span>Point</span><span>,</span>
      <span>frame</span><span>:</span> <span>u32</span><span>)</span> <span>-&gt;</span> <span>Result</span><span>&lt;</span><span>(),</span> <span>Error</span><span>&gt;</span><span>;</span>
<span>}</span>
</code></pre></div></div><p>Widgets can measure themselves to be laid out, and then render onto a shared canvas. I want to add animation, but that’s still a work-in-progress. This might’ve been the first time I implemented a <a href="https://doc.rust-lang.org/rust-by-example/trait.html">trait</a> with methods! That part of Rust clicked immediately: it seems like such an elegant way to define shared behavior.</p><p>The widgets are combined in stacks:</p><div><div><pre><code><span>let</span> <span>layout</span> <span>=</span> <span>vstack!</span><span>[</span>
  <span>hstack!</span><span>[</span>
    <span>get_weather</span><span>()</span><span>.await</span><span>,</span>
    <span>TextWidget</span><span>::</span><span>new</span><span>(</span>
      <span>format!</span><span>(</span><span>&#34;{}&#34;</span><span>,</span> <span>local</span><span>.format</span><span>(</span><span>&#34;%l:%M&#34;</span><span>)</span><span>.to_string</span><span>()),</span>
      <span>String</span><span>::</span><span>from</span><span>(</span><span>&#34;#fff&#34;</span><span>),</span>
    <span>)</span>
  <span>],</span>
  <span>hstack!</span><span>[</span>
    <span>TextWidget</span><span>::</span><span>new</span><span>(</span><span>format!</span><span>(</span><span>&#34;{} MAIL&#34;</span><span>,</span> <span>count</span><span>),</span> <span>String</span><span>::</span><span>from</span><span>(</span><span>&#34;#fff&#34;</span><span>)),</span>
    <span>ChartWidget</span><span>::</span><span>new</span><span>(</span><span>&amp;</span><span>rec_chart</span><span>)</span>
  <span>],</span>
  <span>hstack!</span><span>[</span>
    <span>TextWidget</span><span>::</span><span>new</span><span>(</span><span>format!</span><span>(</span><span>&#34;{:.0} RUN&#34;</span><span>,</span> <span>week_miles</span><span>),</span> <span>String</span><span>::</span><span>from</span><span>(</span><span>&#34;#fff&#34;</span><span>)),</span>
    <span>ChartWidget</span><span>::</span><span>new</span><span>(</span><span>&amp;</span><span>miles_chart</span><span>)</span>
  <span>],</span>
  <span>hstack!</span><span>[</span><span>get_aqi</span><span>()</span><span>.await</span><span>,</span> <span>get_uv</span><span>()</span><span>.await</span><span>]</span>
<span>]</span>
<span>.map</span><span>(|</span><span>s</span><span>|</span> <span>s</span><span>.set_gap</span><span>(</span><span>3.0</span><span>));</span>
</code></pre></div></div><p>And this was my first time implementing a macro, for <code>vstack!</code> and <code>hstack!</code>. That part felt much hackier: I used macros because managing the ownership of the items was tricky. The horizontal stacks have a little layout algorithm which is kind of amusing because of the nature of the problem: unlike a standard flexbox implementation, I really want to make sure that the pixel boundaries are right. Having an uneven number of pixels might shift the date to the right. The math for this was pretty fun.</p><hr/><p>This project has been a lot of fun. I feel like I’ve been working at the edge of my abilities the whole time. I’m pathetically proud of rendering some pixels to the screen. The absurdity of gesturing toward this glorified clock that I’ve spent hours coding.</p><p>In a way it’s a perfect antidote to the behaviors that the internet and social media have been brainwashing us all into. It’s optimized for nothing but my own personal enjoyment. Not even the open source code is really worth reusing yet. One of my favorite things about the Tidbyt – something that they’ve <a href="https://gen2.tidbyt.com/">‘fixed’ in their second-generation devices</a> - is how amazing the display looks in real life and how terrible it looks in photos. The display is made for eyes, not CMOS sensors. This project was about doing it, not about finishing it.</p></div></div>
  </body>
</html>
