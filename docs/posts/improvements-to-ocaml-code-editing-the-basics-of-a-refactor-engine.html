<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://tarides.com/blog/2025-08-20-internship-report-refactoring-tools-coming-to-merlin/">Original</a>
    <h1>Improvements to OCaml code editing: the basics of a refactor engine</h1>
    
    <div id="readability-page-1" class="page"><div><p>Refactoring features have contributed to the popularity of editors like <a href="https://www.jetbrains.com/idea/">IntelliJ</a>, as well as certain programming languages whose editor support offers interactive mechanisms to manage code — <a href="https://gleam.run/language-server/">Gleam</a> being an excellent example. Even though OCaml has some features related to refactoring (such as <a href="https://discuss.ocaml.org/t/ann-merlin-and-ocaml-lsp-support-experimental-project-wide-renaming/16008">renaming occurrences</a>, <a href="https://ocaml.github.io/merlin/editor/emacs/#expression-construction">substituting typed holes</a> with expressions, and <a href="https://tarides.com/blog/2024-05-29-effective-ml-through-merlin-s-destruct-command/">case analysis</a> for pattern matching), the goal of my internship was to kickstart work on a robust set of features to enable the smooth integration of multiple complementary refactoring support commands.</p>
<p>As part of my Tarides internship (on the editor side), I specified several useful commands, inspired by competitors and materialised in the form of RFCs, subject to discussion. There were multiple candidates, but we found that <em>expression extraction to toplevel</em> was the most suitable for a first experiment. Since it touched on several parts of the protocol and required tools that could be reused for other features, it was important to design the system with extensibility and modularity in mind.</p>
<p>In this article, I will present the results of this experiment, including the new command and some interesting use cases.</p>
<h2>Examples</h2>
<p><em>Expression extraction to toplevel</em> will select the most inclusive expression that fits in your selection and propose to extract it. In this case, <code>extract</code> means that the selected expression will be moved into its own freshly generated let binding top level.</p>
<h3>Extracting Constants</h3>
<p>Here is a first example: Let&#39;s try to extract a constant. Let’s assume
that the float 3.14159 is selected in the following code snippet:</p>
<pre><code><span>let</span><span> </span><span>circle_area</span><span> </span><span>radius</span><span> </span><span>=</span><span> </span><span>3.14159</span><span> </span><span>*.</span><span> </span><span>(</span><span>radius</span><span> </span><span>**</span><span> </span><span>2.</span><span>)</span><span>
</span><span>                      </span><span>
</span></code></pre>
<p>The <code>extract</code> action code will then be proposed, and if you apply it, the code will look like this:</p>
<pre><code><span>let</span><span> </span><span>const_name1</span><span> </span><span>=</span><span> </span><span>3.14159</span><span>
</span><span>let</span><span> </span><span>circle_area</span><span> </span><span>radius</span><span> </span><span>=</span><span> </span><span>const_name1</span><span> </span><span>*.</span><span> </span><span>(</span><span>radius</span><span> </span><span>**</span><span> </span><span>2.</span><span>)</span><span>
</span></code></pre>
<p>Here is an illustrated example (based on an experimental branch of <a href="https://github.com/tarides/ocaml-eglot">ocaml-eglot</a>):</p>
<p>
<img src="https://tarides.com/blog/images/merlin-extract-1~RDOf-0dhfHB2JyJ0n1d4hw.gif" alt="Extract constant"/>
</p>
<p>We can see that the expression has been effectively extracted and replaced by a reference to the fresh let binding. We can also observe that in the absence of a specified name, the generated binding will be named with a generic name that is not taken in the destination scope. You also have the ability to supply the name you want for extraction.</p>
<p>For example, here is the same example where the user can enter a name:</p>
<p>
<img src="https://tarides.com/blog/images/merlin-extract-2~ZfD3Cjk4AeK3amEbq66vuQ.gif" alt="Extract constant with a given name"/>
</p>
<p>But the refactoring capabilities go much further than constant extraction!</p>
<h3>Extracting an Expression</h3>
<p>In our previous example, we could speculate about the purity of the expression, since we were only extracting a literal value. However, OCaml is an impure language, so extracting an expression into a constant can lead to unintended behavior. For example, let&#39;s imagine the following snippet:</p>
<pre><code><span>let</span><span> </span><span>()</span><span> </span><span>=</span><span> 
</span><span>  </span><span>let</span><span> </span><span>()</span><span> </span><span>=</span><span> 
</span><span>    </span><span>print_endline</span><span> </span><span>&#34;</span><span>Hello World!</span><span>&#34;</span><span>;</span><span>
</span><span>    </span><span>print_endline</span><span> </span><span>&#34;</span><span>Done</span><span>&#34;</span><span>
</span><span>  </span><span>in</span><span> </span><span>()</span><span>
</span></code></pre>
<p>In this example, extracting into a <em>constant</em> would cause problems! Indeed, we would be changing the semantics of our program by executing both print statements beforehand. Fortunately, the command analyses the expression as not being a constant and delays its execution using a thunk — a function of <code>type unit -&gt; ...</code>.</p>
<p>
<img src="https://tarides.com/blog/images/merlin-extract-3~2oFjCOtDbixwhiiQOMoMyg.gif" alt="Extract expression"/>
</p>
<p>As we can see, our goal was to maximise the production of valid code, as much as possible, by carefully analysing how to perform the extraction. This is all the more challenging in OCaml, which allows for arbitrary (and potentially infinite) nesting of expressions.</p>
<h3>Extracting an Expression That Uses Variables</h3>
<p>The final point we’ll briefly cover is the most fun. Indeed, it’s possible that the expression we want to extract depends on values defined in the current scope. For example:</p>
<pre><code><span>let</span><span> </span><span>z</span><span> </span><span>=</span><span> </span><span>45</span><span>
</span><span>
</span><span>let</span><span> </span><span>a_complicated_function</span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>=</span><span> 
</span><span>  </span><span>let</span><span> </span><span>a</span><span> </span><span>=</span><span> </span><span>10</span><span> </span><span>in</span><span> 
</span><span>  </span><span>let</span><span> </span><span>b</span><span> </span><span>=</span><span> </span><span>11</span><span> </span><span>in</span><span> 
</span><span>  </span><span>let</span><span> </span><span>c</span><span> </span><span>=</span><span> </span><span>12</span><span> </span><span>in</span><span> 
</span><span>  </span><span>a</span><span> </span><span>+</span><span> </span><span>b</span><span> </span><span>+</span><span> </span><span>c</span><span> </span><span>+</span><span> </span><span>(</span><span>c</span><span> </span><span>*</span><span> </span><span>x</span><span> </span><span>*</span><span> </span><span>y</span><span>)</span><span> </span><span>+</span><span> </span><span>z</span><span>
</span></code></pre>
<p>In this example, the extraction of the expression <code>a + b + c (c * x * y) + z</code> will be placed between <code>z</code> and <code>a_complicated_function</code>. As a result, <code>z</code> will still be accessible; however, <code>x</code>, <code>y</code>, <code>a</code>, <code>b</code>, and <code>c</code> will be <a href="https://en.wikipedia.org/wiki/Free_variables_and_bound_variables">free variables</a> in the extracted expression. Therefore, we generate a function that takes these free variables as arguments:</p>
<p>
<img src="https://tarides.com/blog/images/merlin-extract-4~THNQL-EZb5Gx7m80iaOg8A.gif" alt="Extract expression with free variables"/>
</p>
<p>Identifying free variables was one of the motivations for starting with this command. We are fairly certain that this is a function that we will need to reuse in many contexts!  Note that the command behaves correctly in the presence of objects and modules.</p>
<h2>A Real World Example</h2>
<p>Let’s try to extract something a little more complicated now. Let’s assume we have the following code and we want to refactor it, for example, by extracting the <code>markup</code> type pretty print logic outside our <code>pp</code> function.</p>
<pre><code><span>type</span><span> </span><span>t</span><span> </span><span>=</span><span> </span><span>markup</span><span> </span><span>list</span><span>
</span><span>and</span><span> </span><span>markup</span><span> </span><span>=</span><span> </span><span>Text</span><span> </span><span>of</span><span> </span><span>string</span><span> </span><span>|</span><span> </span><span>Bold</span><span> </span><span>of</span><span> </span><span>string</span><span>
</span><span>
</span><span>let</span><span> </span><span>show</span><span> </span><span>doc</span><span> </span><span>=</span><span>
</span><span>  </span><span>let</span><span> </span><span>buf</span><span> </span><span>=</span><span> </span><span>Buffer</span><span>.</span><span>create</span><span> </span><span>101</span><span> </span><span>in</span><span>
</span><span>  </span><span>let</span><span> </span><span>bold_tag</span><span> </span><span>=</span><span> </span><span>&#34;</span><span>**</span><span>&#34;</span><span> </span><span>in</span><span>
</span><span>  </span><span>List</span><span>.</span><span>iter</span><span>
</span><span>    </span><span>(</span><span>fun</span><span> </span><span>markup</span><span> </span><span>-&gt;</span><span>
</span><span>      </span><span>Buffer</span><span>.</span><span>add_string</span><span> </span><span>buf</span><span>
</span><span>      </span><span>@@</span><span>
</span><span>      </span><span>match</span><span> </span><span>markup</span><span> </span><span>with</span><span>
</span><span>      </span><span>|</span><span> </span><span>Text</span><span> </span><span>txt</span><span> </span><span>-&gt;</span><span> </span><span>txt</span><span>
</span><span>      </span><span>|</span><span> </span><span>Bold</span><span> </span><span>txt</span><span> </span><span>-&gt;</span><span> </span><span>bold_tag</span><span> </span><span>^</span><span> </span><span>txt</span><span> </span><span>^</span><span> </span><span>bold_tag</span><span>)</span><span>
</span><span>    </span><span>doc</span><span>;</span><span>
</span><span>  </span><span>Buffer</span><span>.</span><span>contents</span><span> </span><span>buf</span><span>
</span></code></pre>
<p>We can observe that bounded variables in the extracted region are now passed as arguments, and the extracted function is properly replaced by a call to the new show_markup generated function.</p>
<pre><code><span>let</span><span> </span><span>show_markup</span><span> </span><span>buf</span><span> </span><span>bold_tag</span><span> </span><span>=</span><span>
</span><span> </span><span>fun</span><span> </span><span>markup</span><span> </span><span>-&gt;</span><span>
</span><span>  </span><span>(</span><span>Buffer</span><span>.</span><span>add_string</span><span> </span><span>buf</span><span>)</span><span>
</span><span>    </span><span>(</span><span>match</span><span> </span><span>markup</span><span> </span><span>with</span><span>
</span><span>    </span><span>|</span><span> </span><span>Text</span><span> </span><span>txt</span><span> </span><span>-&gt;</span><span> </span><span>txt</span><span>
</span><span>    </span><span>|</span><span> </span><span>Bold</span><span> </span><span>txt</span><span> </span><span>-&gt;</span><span> </span><span>bold_tag</span><span> </span><span>^</span><span> </span><span>txt</span><span> </span><span>^</span><span> </span><span>bold_tag</span><span>)</span><span>
</span><span>let</span><span> </span><span>show</span><span> </span><span>doc</span><span> </span><span>=</span><span>
</span><span>  </span><span>let</span><span> </span><span>buf</span><span> </span><span>=</span><span> </span><span>Buffer</span><span>.</span><span>create</span><span> </span><span>101</span><span> </span><span>in</span><span>
</span><span>  </span><span>let</span><span> </span><span>bold_tag</span><span> </span><span>=</span><span> </span><span>&#34;</span><span>**</span><span>&#34;</span><span> </span><span>in</span><span>
</span><span>  </span><span>List</span><span>.</span><span>iter</span><span> </span><span>(</span><span>show_markup</span><span> </span><span>buf</span><span> </span><span>bold_tag</span><span>)</span><span> </span><span>doc</span><span>;</span><span>
</span><span>  </span><span>Buffer</span><span>.</span><span>contents</span><span> </span><span>buf</span><span>
</span></code></pre>
<p>Here is an example of how it is used. <em>Impressive, isn&#39;t it</em>?</p>
<p>
<img src="https://tarides.com/blog/images/merlin-extract-5~eKmd53L9w5fkYgE7KoBFDA.gif" alt="Extract show_markup"/>
</p>
<h2>Editor Support</h2>
<p>To understand how this new Merlin command can be properly used in your favourite editor, we have to take a closer look at the functioning of the Language Server Protocol. The LSP supports two mechanisms to extend the existing protocol with new features. First, there is <code>code action</code>, which allows us to perform multiple LSP commands  sequentially. This kind of request has the merit of working out of the box without requiring any plugin or specific command support on the editor side (which oils the wheels for maintenance). Secondly, there are <code>custom requests</code>, which are more powerful than code actions and enable custom interactivity. So, if you want to prompt the user, a custom request is the way to go. The price you have to pay for this power is to have client-side support implemented for each custom request in every editor plugin.</p>
<p>The current editor team approach is as follows: For each of Merlin&#39;s commands that don&#39;t map directly to a standard LSP request, we provide a code action associated with the Merlin command and potentially a dedicated custom request if the feature requires custom interactivity. Regarding the ‘extract’ feature, the associated code action does not allow us to choose the name of the generated let binding, but the custom request does.</p>
<h2>What’s Next?</h2>
<p>I hope this new command helps you get even more productive in OCaml! Don’t hesitate to experiment with it and report any bugs you encounter.</p>
<p>The development of Merlin’s refactoring tools was part of a broader vision to improve OCaml editor support and perhaps claim an editor experience similar to JetBrains IDE in the future!</p>
<p>The work done on the <code>extract</code> command gives us the opportunity to identify various problems pertaining to refactoring (<em>substitution</em>, <em>code generation</em>) and potentially to make the connection to refactoring commands that already exist in Merlin (like <code>open</code> refactoring and project-wide renaming). The next step is to add a small toolbox library in Merlin dedicated to refactoring in order to develop even more refactor actions. I hope this is just the first refactoring feature of a long series.</p>
<p>If you&#39;re curious and want to take a look at the feature, it&#39;s split into several PRs:</p>
<ul>
<li><a href="https://github.com/ocaml/merlin/pull/1948">ocaml/merlin#1948</a> which implements the extraction logic on the Merlin side and exposes it in the protocol,</li>
<li><a href="https://github.com/ocaml/ocaml-lsp/pull/1545">ocaml/ocaml-lsp#1545</a> which exposes the Custom Request enabling the use of the LSP-side functionality,</li>
<li><a href="https://github.com/ocaml/ocaml-lsp/pull/1546">ocaml/ocaml-lsp#1546</a> which exposes an Action Code that allows the functionality to be invoked without additional formalities on the Editor side,</li>
<li><a href="https://github.com/tarides/ocaml-eglot/pull/65">tarides/ocaml-eglot#65</a> which implements extraction behaviour in OCaml-Eglot, invocable either from a type enclosing or directly as a classic Emacs command.</li>
</ul>
<p>All of these PRs are currently under review, and should be merged soon!</p>
<p>A big thanks to <a href="https://tarides.com/blog/author/xavier-van-de-woestyne/">Xavier</a>, <a href="https://tarides.com/blog/author/ulysse-gerard/">Ulysse</a>, and all the people that helped me during this internship. It was pretty interesting!</p>
</div></div>
  </body>
</html>
