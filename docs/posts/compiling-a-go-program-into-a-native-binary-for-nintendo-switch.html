<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ebiten.org/blog/native_compiling_for_nintendo_switch.html">Original</a>
    <h1>Compiling a Go program into a native binary for Nintendo Switch</h1>
    
    <div id="readability-page-1" class="page"><article>
        <div>
  
  <p>Hajime Hoshi</p>
  <p>This is an English translation of <a href="https://zenn.dev/hajimehoshi/articles/72f027db464280">my article in Japanese</a>.</p>
  <h2>tl;dr</h2>
  <p>Previously, we compiled a Go program into a WebAssembly and then converted it into C++ files to make it run on Nintendo Switch. Now, I have succeeded in compiling a Go program into a native binary for Nintendo Switch, and also running a game there. I replaced system calls with C function calls using the <code>-overlay</code> option. Also, I have developed a new package <a href="https://github.com/hajimehoshi/hitsumabushi">Hitsumabushi</a> to generate JSON content for this.</p>
  <h2>Caution</h2>
  <p>This article and the open-source projects in this article are based only on publicly available information. Hajime is responsible for this article&#39;s content. Please do not ask Nintendo about this article.</p>
  <h2>Background</h2>
  <p>I have been developing a 2D game engine called Ebiten in my spare time. I have succeeded in porting this to Nintendo Switch and <a href="https://odencat.com/bearsrestaurant/switch/en.html">the Nintendo Switch version of &#34;Bear&#39;s Restaurant&#34;</a> was released in 2021.</p>
  <figure>
    <p><a href="https://odencat.com/bearsrestaurant/switch/"><img src="https://ebiten.org/images/blog/nintendo_switch/bearsrestaurant_en.jpg" width="360" alt="Bear&#39;s Restaurant"/></a></p>
    <figcaption>Copyright 2021 Odencat Inc.</figcaption>
  </figure>
  <p>The method was to compile a Go program into a WebAssembly (Wasm) binary and then convert it to C++ files. See <a href="https://docs.google.com/presentation/d/e/2PACX-1vTMRSmuWjhpOx3DIgetfi72jcOGvlqPU5z0Nps24YN6dxaBbu4dWm0FXS2f--D4G2b1aAvTmfqNA2IG/pub?start=false&amp;loop=false&amp;delayms=3000">the presentation slides from GoConference 2021 Autumn</a> for more details. The advantages were low uncertainty, low maintenance cost, and high portability. Once I developed the tool, its maintenance cost was pretty small as Wasm&#39;s specification is stable. On the other hand, the disadvantages were bad performance and long compiling time. Not only that performance was worse than native, but GC also suspended the game due to a single thread.</p>
  <p>Compiling a Go program into a native binary for Nintendo Switch without using Wasm was quite uncertain and a rocky road. Of course, Go doesn&#39;t support Nintendo Switch officially. And naturally, Nintendo Switch&#39;s source code and binary formats are not open. Even if I hit an issue, it&#39;d be possible that there would not be any clues to help me solve it. However, if I knew that I were to succeed, performance would be better than ever, and compiling speed would be as fast as Go. So I thought it was worth a shot and have been doing some experiments intermittently for one year.</p>
  <h2>Strategy</h2>
  <p>The strategy is basically to replace system calls with C function calls in the runtime and the standard library. The system calls part is OS-dependent, and if I replace it with something portable, Go should work everywhere in theory. It seems pretty easy, doesn&#39;t it? Well, it was a lot more challenging than I expected...</p>
  <p>The graphic below describes what I had to do. The left side is a structure of a structural overview of standard Go compiling. System calls work on specific systems and of course, this doesn&#39;t work on Nintendo Switch. So I had to replace them with standard C function calls like the right side.</p>
  <figure>
    <p><img src="https://ebiten.org/images/blog/native_compiling_for_nintendo_switch/strategy.png" alt="Replacing system calls with C function calls"/></p>
    <figcaption>Replacing system calls with C function calls</figcaption>
  </figure>
  <p>And, there is another action item to adjust the binary format that the Go compiler generates to fit with Nintendo Switch. So in summary, the action items were as follows:</p>
  <ol>
    <li>Replacing system calls with standard C function and/or pthread function calls</li>
    <li>Adjust the ELF format that the Go compiler generates</li>
  </ol>
  <p>For replacing system calls, of course, system calls do not correspond one-to-one with C functions. And, there are too many system calls to implement. So, I replaced system calls one by one by finding which ones refused to work on an actual Nintendo Switch device.</p>
  <p>The Go compiler can generate only formats that the Go compiler officially supports. For example, when a target is Linux, the format is ELF. Can Nintendo Switch support ELF? To make a long story short, yes, I managed it. I won&#39;t describe the details about 2. here<a href="#footnote_1">*1</a>.</p>
  <p>What I have to do is create a <code>.a</code> file via the Go compiler with <code>GOOS=linux GOARCH=arm64</code> and <code>-buildmode=c-archive</code>, and then link it with other object files and libraries via Nintendo Switch compiler. The reason why I don&#39;t use <code>-buildmode=default</code> is that there are some items I have to do around an entry point. IMO, in general, it is more portable to depend on the platform for an entry point.</p>
  <p>System calls are defined basically in the standard library, especially <code>runtime</code> and <code>syscall</code> packages. So, how did I rewrite them? In this project, I adopted the <code>-overlay</code> option.</p>
  <h2>Hitsumabushi - rewriting the runtime with the <code>-overlay</code> option</h2>
  <p><code>go build</code>&#39;s <code>-overlay</code> is an option that overwrites Go files to be compiled. I overwrote Go files in the runtime with this option. This is <a href="https://pkg.go.dev/cmd/go">the official document&#39;s explanation</a>:</p>
  <pre><code>-overlay file
    read a JSON config file that provides an overlay for build operations.
    The file is a JSON struct with a single field, named &#39;Replace&#39;, that
    maps each disk file path (a string) to its backing file path, so that
    a build will run as if the disk file path exists with the contents
    given by the backing file paths, or as if the disk file path does not
    exist if its backing file path is empty. Support for the -overlay flag
    has some limitations: importantly, cgo files included from outside the
    include path must be in the same directory as the Go package they are
    included from, and overlays will not appear when binaries and tests are
    run through go run and go test respectively.</code></pre>
  <p>This is the format to give <code>-overlay</code>:</p>
  <pre><code>{
  &#34;Replace&#34;: {
    &#34;/usr/local/go/src/runtime/os_linux.go&#34;: &#34;/home/hajimehoshi/my_os_linux.go&#34;
  }
}</code></pre>
  <p>If you build a Go program with this, <code>os_linux.go</code>&#39;s content in <code>runtime</code> is replaced with <code>my_os_linux.go</code>&#39;s. Pretty handy, isn’t it?</p>
  <p>Managing this JSON file as it is is not portable. A location where Go is installed depends on environments, and then the target files&#39; locations vary. Plus, you very rarely have to replace the full contents of a file, and in most cases, it is enough to replace some functions. As such, it is troublesome to update source files to match each Go version update.</p>
  <p>So, I developed a new package to generate a JSON for this project. This is <a href="https://github.com/hajimehoshi/hitsumabushi">Hitsumabushi (ひつまぶし)</a><a href="#footnote_2">*2</a>. I adopted this name because I wanted a name ending with &#39;bushi&#39; as a play on libc (ree-boo-shee (りぶしー) in Japanese pronunciation), because this is one of the primary things that Hitsumabushi deals with. There was another candidate I was considering, Katsuobushi (かつおぶし)<a href="#footnote_3">*3</a>, but I won’t get into that...</p>
  <p>Hitsumabushi is a very simple package defining an API like this:</p>
  <pre><code>// GenOverlayJSON generates JSON content that can be passed
// to -overlay based on the given options, or returns an error
// when an error occurs.
//
// There are some options like specifying command arguments
// and specifying the number of CPU.
func GenOverlayJSON(options ...Option) ([]byte, error)</code></pre>
  <h2>Implementation of Hitsumabushi</h2>
  <p>I have created an original patch format for Hitsumabushi that looks like this:</p>
  <pre><code>//--from
func getRandomData(r []byte) {
    if startupRandomData != nil {
        n := copy(r, startupRandomData)
        extendRandom(r, n)
        return
    }
    fd := open(&amp;urandom_dev[0], 0 /* O_RDONLY */, 0)
    n := read(fd, unsafe.Pointer(&amp;r[0]), int32(len(r)))
    closefd(fd)
    extendRandom(r, int(n))
}
//--to
// Use getRandomData in os_plan9.go.

//go:nosplit
func getRandomData(r []byte) {
    // inspired by wyrand see hash32.go for detail
    t := nanotime()
    v := getg().m.procid ^ uint64(t)

    for len(r) &gt; 0 {
        v ^= 0xa0761d6478bd642f
        v *= 0xe7037ed1a0b428db
        size := 8
        if len(r) &lt; 8 {
            size = len(r)
        }
        for i := 0; i &lt; size; i++ {
            r[i] = byte(v &gt;&gt; (8 * i))
        }
        r = r[size:]
        v = v&gt;&gt;32 | v&lt;&lt;32
    }
}</code></pre>
  <p>The part after <code>//--from</code> and the part after <code>//--to</code> represent a replacing source and a target respectively. The reason why I invented my simple format is that the existing patch formats don&#39;t assume to be modified by a human being. In the above example, Linux&#39;s <code>getRandomData</code> implementation is replaced with Plan 9&#39;s. Linux&#39;s <code>getRandomData</code> uses <code>/dev/urandom</code> and this is not potable<a href="#footnote_4">*4</a>. This patch format saves some amount of work to manage the differences I want to replace. Of course, the cost to keep up with the Go version updates doesn&#39;t become zero even with this, but it should help a lot.</p>
  <p>Hitsumabushi creates modified files with this format and puts them in a temporary directory. It uses the files as the content of JSON (the replacing source file names).</p>
  <p>Note that Hitsumabushi rewrites the standard library and the runtime, and the Go compiler is not the target to rewrite. In other words, the regular Go compiler is used as is.</p>
  <p>The replacements by Hitsumabushi are only the standard C function calls and pthread function calls. It never deals with platform-specific APIs<a href="#footnote_5">*5</a>. So, ideally, <strong>Hitsumabushi should enable a Go program to run on any platform, regardless of whether or not the Go compiler originally supports it</strong>.</p>
  <h2>Replacements</h2>
  <h3>Calling C functions from <code>runtime</code></h3>
  <p>It is not an easy task to call a C function from <code>runtime</code>. In a usual Go program, you can call a C function easily with Cgo. However, <code>runtime</code> cannot use Cgo. Using Cgo means to depend on <code>runtime/cgo</code>, and <code>runtime/cgo</code> depends on <code>runtime</code>, so this would be a circular dependency.</p>
  <p>To get straight to the point, <code>libcCall</code> makes it possible to call a C function from <code>runtime</code>. Some environments like <code>GOOS=darwin</code> already do this.</p>
  <p>In addition, <a href="https://pkg.go.dev/cmd/compile#hdr-Compiler_Directives">various compiler directives</a> are required.</p>
  <ul>
    <li><code>//go:nosplit</code>: Skips an overflow in the stack.</li>
    <li><code>//go:cgo_unsafe_args</code>: Treats Go arguments as C arguments.</li>
    <li><code>//go:linkname</code>: Treats something defined in another package as if it was defined in this package. Or, it treats something defined in this package as if it was defined in another package. It ignores whether the symbol is exported or not. Very useful!</li>
    <li><code>//go:cgo_import_static</code>: Static-links a C function and makes it possible to treat the symbol value in Go.</li>
  </ul>
  <p>Let&#39;s see an actual example. To call the <code>write</code> system call from <code>runtime</code>, a function called <code>write1</code> is defined on the Go side.</p>
  <pre><code>// An excerpt from runtime/stubs2.go in Go 1.17.5

//go:noescape
func write1(fd uintptr, p unsafe.Pointer, n int32) int32</code></pre>
  <pre><code>// An excerpt from runtime/sys_linux_arm64.s in Go 1.17.5

TEXT runtime·write1(SB),NOSPLIT|NOFRAME,$0-28
    MOVD    fd+0(FP), R0
    MOVD    p+8(FP), R1
    MOVW    n+16(FP), R2
    MOVD    $SYS_write, R8
    SVC
    MOVW    R0, ret+24(FP)
    RET</code></pre>
  <p>In the case of 64bit ARM, <code>SVC</code> is used to invoke a system call.</p>
  <p>Let&#39;s replace this with a C function call by <code>libcCall</code> and compiler directives.</p>
  <pre><code>// An excerpt from runtime/stubs2.go after Hitsumabushi&#39;s replacement

//go:nosplit
//go:cgo_unsafe_args
func write1(fd uintptr, p unsafe.Pointer, n int32) int32 {
    return libcCall(unsafe.Pointer(abi.FuncPCABI0(write1_trampoline)), unsafe.Pointer(&amp;fd))
}
func write1_trampoline(fd uintptr, p unsafe.Pointer, n int32) int32</code></pre>
  <pre><code>// An excerpt from runtime/os_linux.go after Hitsumabushi&#39;s replacement

//go:linkname c_write1 c_write1
//go:cgo_import_static c_write1
var c_write1 byte</code></pre>
  <pre><code>// An excerpt from runtime/sys_linux_arm64.s after Hitsumabushi&#39;s replacement

TEXT runtime·write1_trampoline(SB),NOSPLIT,$0-28
    MOVD    8(R0), R1   // p
    MOVW    16(R0), R2  // n
    MOVD    0(R0), R0   // fd
    BL  c_write1(SB)
    RET</code></pre>
  <pre><code>// An excerpt from runtime/cgo/gcc_linux_arm64.c after Hitsumabushi&#39;s replacement

int32_t c_write1(uintptr_t fd, void *p, int32_t n) {
  static pthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER;
  int32_t ret = 0;
  pthread_mutex_lock(&amp;m);
  switch (fd) {
  case 1:
    ret = fwrite(p, 1, n, stdout);
    fflush(stdout);
    break;
  case 2:
    ret = fwrite(p, 1, n, stderr);
    fflush(stderr);
    break;
  default:
    fprintf(stderr, &#34;syscall write(%lu, %p, %d) is not implemented\n&#34;, fd, p, n);
    break;
  }
  pthread_mutex_unlock(&amp;m);
  return ret;
}</code></pre>
  <p>By the way, <code>libcCall</code> is not defined on <code>GOOS=linux</code>. I had to rewrite <code>//go:build</code> in <code>runtime/sys_libc.go</code> properly.</p>
  <p>If you forcibly call a C function using assembly without <code>libcCall</code>, a C stack will be on the current Goroutine&#39;s stack. Then, you might find very mysterious errors. I don&#39;t recommend invoking a C function without <code>libcCall</code>.</p>
  <h3>Ignoring signals</h3>
  <p>Hitsumabushi ignores all signals. For example, <a href="https://github.com/hajimehoshi/hitsumabushi/blob/033f91b0b848e44349a91ccd28d6436bc22d0c44/1.17/runtime/os_linux.go.patch#L165-L180"><code>sigaltstack</code> and <code>sigprocmask</code> in <code>runtime</code> are empty</a>. There are standard C functions that deal with signals, but they are not implemented in some environments.</p>
  <p>As a side effect, accessing a nil pointer caused SEGV, and <code>recover</code>-ing it became impossible. A program dies without panic messages, even. This is inconvenient to some extent, but we have to put in the effort to avoid this issue in production environments.</p>
  <h3>Implementing a pseudo file system</h3>
  <p>Even when a Go program does nothing, the runtime might access the file system. On Linux, apparently these files are read from the runtime:</p>
  <ul>
    <li><code>/proc/self/auxv</code> (Information about e.g. a page size)</li>
    <li><code>/sys/kernel/mm/transparent_hugepage/hpage_pmd_size</code> (Huge Page Size)</li>
  </ul>
  <p>I hand-crafted some content for both. For example, I used 0 for Huge Page Size since it worked. For the implementation, see <a href="https://github.com/hajimehoshi/hitsumabushi/blob/033f91b0b848e44349a91ccd28d6436bc22d0c44/1.17/runtime/cgo/gcc_linux_arm64.c.patch#L437-L454">Hitsumabushi&#39;s <code>c_open</code></a>.</p>
  <p>For writing files, I implemented only a standard output and a standard error. Both just use <code>fprintf</code>. Without them, even <code>println</code> doesn&#39;t work. I decided not to implement reading and writing other files for now. For the implementation, see <a href="https://github.com/hajimehoshi/hitsumabushi/blob/033f91b0b848e44349a91ccd28d6436bc22d0c44/1.17/runtime/cgo/gcc_linux_arm64.c.patch#L480-L499">Hitsumabushi&#39;s <code>c_write1</code></a>.</p>
  <h3>Implementing a pseudo memory system</h3>
  <p>In Go&#39;s heap memory management, <a href="https://man7.org/linux/man-pages/man2/mmap.2.html"><code>mmap</code></a> system call is the bottom layer on Linux. Go manages virtual memory allocated there. <code>munmap</code> is called for unused regions.</p>
  <p>There are <a href="https://cs.opensource.google/go/go/+/refs/tags/go1.17.5:src/runtime/malloc.go;l=349-360">4 states</a> of a heap memory region and these states transition as in the diagram below. When the state is &#39;Ready&#39;, the region is available.</p>
  <figure>
    <p><img src="https://ebiten.org/images/blog/native_compiling_for_nintendo_switch/memory.png" width="360" alt="The state transition diagram of Go&#39;s memory"/></p>
    <figcaption>The state transition diagram of Go&#39;s memory</figcaption>
  </figure>
  <p>Go specifies an address in virtual memory and uses an allocated memory region with the address. However, there is no standard C function to allocate memory with a specific address. That&#39;s unfortunate.</p>
  <p>There are some platforms where it is impossible to allocate memory with a specific address: Plan 9 and Wasm. Hitsumabushi referred to them and implemented a &#39;corner-cutting&#39; memory system. It referred to <a href="https://cs.opensource.google/go/go/+/refs/tags/go1.17.5:src/runtime/mem_js.go">the Wasm version</a> in particular, which is the simplest implementation. I won&#39;t describe the details here, but basically, the implementation is as shown in the following list. For an actual source, see <a href="https://github.com/hajimehoshi/hitsumabushi/blob/033f91b0b848e44349a91ccd28d6436bc22d0c44/1.17/runtime/mem_linux.go">Hitsumabushi&#39;s <code>mem_linux.go</code></a>.</p>
  <ul>
    <li><code>sysAlloc</code>: Calls <code>sysReserve</code> and <code>sysMap</code>.</li>
    <li><code>sysMap</code>: Increments the total size record of heap memory.</li>
    <li><code>sysFree</code>: Decrements the total size record of heap memory.</li>
    <li><code>sysReserve</code>: Calls <code>calloc</code>.</li>
    <li>The other functions do nothing.</li>
  </ul>
  <p>As you can see, there is a call of <code>calloc</code> but no call of <code>free</code>. It is impossible to <code>free</code> a part of a region allocated by <code>calloc</code>. This means that memory usage is monotonically increased. Originally, the method to make an Ebiten application work on Nintendo Switch was to convert Go to C++ via Wasm, and memory usage was also monotonically increased there<a href="#footnote_6">*6</a>. It didn’t end up making things worse, at the very least, so I’ve compromised with this solution so far, but I would like to fix this in the future...</p>
  <h3>Implementing pseudo <code>futex</code></h3>
  <p><a href="https://man7.org/linux/man-pages/man2/futex.2.html"><code>futex</code></a> is the bottom layer of the part that handles sleeping and waking up threads. Of course, the standard C functions and pthread functions cannot invoke <code>futex</code> directly. So, I had to mimic the behavior of <code>futex</code> with pthread. Originally, pthread itself is implemented with <code>futex</code>, so I had to do the opposite thing.</p>
  <p>There are <a href="https://cs.opensource.google/go/go/+/refs/tags/go1.17.5:src/runtime/os_linux.go;l=17-24">two ways</a> to use <code>futex</code> via Go.</p>
  <ul>
    <li><code>futexsleep(uint32 *addr, uint32 val)</code>: Makes the thread sleep when <code>addr</code> is <code>val</code>.</li>
    <li><code>futexwake(uint32 *addr)</code>: Wakes up the thread which sleeps with <code>addr</code>.</li>
  </ul>
  <p>In Hitsumabushi, I added a simple implementation like this. For an actual source, see <a href="https://github.com/hajimehoshi/hitsumabushi/blob/033f91b0b848e44349a91ccd28d6436bc22d0c44/1.17/runtime/cgo/gcc_linux_arm64.c.patch#L321-L385">Hitsumabushi&#39;s <code>pseudo_futex</code></a>.</p>
  <pre><code>// A pseudo code
pseudo_futex(void* uaddr, int32_t val) {
  static pthread_cond_t cond; // A condition variable

  switch (mode) {
  case sleep:
    if (*uaddr == val) {
      cond_wait(&amp;cond); // Sleep
    }
    break;
  case wake:
    cond_broadcast(&amp;cond); // Wake up all the threads sleeping with cond.
    break;
  }
}</code></pre>
  <p>When <code>wake</code> is called, it will wake up not only the necessary threads, but all the threads. If you want to wake up only necessary threads, you would need to manage multiple condition variables for each <code>uaddr</code>, which would be cumbersome. Such unnecessary waking up is called <a href="https://en.wikipedia.org/wiki/Spurious_wakeup">spurious wakeup</a>. <a href="https://cs.opensource.google/go/go/+/refs/tags/go1.17.5:src/runtime/os_linux.go;l=41-42">This is explicitly expected in Go source code</a>, so this is not problematic. However, performance might be degraded.</p>
  <h3>Adjusting the number of CPU cores</h3>
  <p>The number of CPU cores is determined by the result of the <a href="https://man7.org/linux/man-pages/man2/sched_setaffinity.2.html"><code>sched_getaffinity</code></a> system call. There is no corresponding standard C function, so I gave Hitsumabushi an option to specify the number of cores to <code>GenOverlayJSON</code>. For the actual source, see <a href="https://github.com/hajimehoshi/hitsumabushi/blob/033f91b0b848e44349a91ccd28d6436bc22d0c44/overlay.go#L177-L208">Hitsumabushi&#39;s <code>c_sched_getaffinity</code></a>.</p>
  <p>There were some environments where an application froze with 2 or more CPU cores specified. It&#39;s because a thread could use only one core by default. Thus, I had to call <a href="https://man7.org/linux/man-pages/man3/pthread_setaffinity_np.3.html"><code>pthread_setaffinity_np</code></a> explicitly. In Hitsumabushi, I added a hack to call <code>pthread_setaffinity_np</code> just after <a href="https://man7.org/linux/man-pages/man3/pthread_create.3.html"><code>pthread_create</code></a>. For the actual source, see <a href="https://github.com/hajimehoshi/hitsumabushi/blob/033f91b0b848e44349a91ccd28d6436bc22d0c44/overlay.go#L217-L247">Hitsumabushi&#39;s <code>overlay.go</code></a>. As an aside, it was quite hard to find this solution. I can’t tell you how happy I was to finally solve this conundrum.</p>
  <h3>Entry point</h3>
  <p>Hitsumabushi is assumed to be used with <code>-buildmode=c-archive</code>. The generated file is a C library, and even <code>main</code> is not called. If you want to call <code>main</code>, you have to define a C function and call <code>main</code> explicitly inside. Calling <code>main</code> explicitly does not make sense usually, but I think it is practical for <code>c-archive</code>.</p>
  <pre><code>package main

import &#34;C&#34;

//export GoMain
func GoMain() {
    main()
}</code></pre>
  <pre><code>// Call the entry point in Go in the entry point in C.
int main() {
  GoMain();
  return 0;
}</code></pre>
  <h2>Results</h2>
  <ul>
    <li><strong>I managed to get a game called &#34;<a href="https://github.com/hajimehoshi/go-inovation">Innovation 2007</a>&#34; working on an actual Nintendo Switch device</strong>. Controller support, touch inputting, and audio all work perfectly. Innovation 2007 uses most of Ebiten&#39;s features, so I&#39;m sure other games would work as well.</li>
    <li>Compiling speed became much faster. Before this solution, it took 5 to 10 minutes to full-build a C++ project, but now it only takes less than 10 seconds. This is awesome!</li>
    <li>Suspensions by GC seem to have disappeared.</li>
    <li>I now have to update whenever a new version of Go is released. This is an acceptable compromise to me. From my past experiments, I don’t expect any major changes anyway.</li>
  </ul>
  <h2>Remarks</h2>
  <p>This is a side note, but the implementation of Go&#39;s runtime has ample accumulation of knowledge about modern OSes and is very insightful. I think it can teach you a significant amount about computer science. That said, it can be quite daunting to read it without a purpose, so I recommend doing so with some sort of modification project in mind.</p>
  <p>Thanks to the near-success of this project, the method I presented in the Go Conference is now becoming outdated. This was inevitable, obviously, but it still makes me feel a little sad to see that hard work go obsolete.</p>
  <h2>Future works</h2>
  <p>I&#39;ll continue polishing this so that a proper game can be released for Nintendo Switch. As I described first, there is a high level of uncertainty in this project. Until a game is released, I cannot anticipate what kind of issues will occur, and I always have to be on high alert. Even in the worst case scenario, however, I know we can continue to release the game with the help of <a href="https://github.com/hajimehoshi/go2cpp">go2cpp</a>, which is reassuring. Still, with all the hard work I’ve put into this already, I really want to release a game with Hitsumabushi and see it achieve some actual results.</p>
  <h2>Acknowledgments</h2>
  <p>Thanks to the kind folks over in the PySpa community for all their technical advice. I’d also like to express my gratitude to Daigo, <a href="https://odencat.com/">President of Odencat Inc.</a>, who kindly uses Ebiten for Nintendo Switch. Thank you very much.</p>
  <p>Happy new year!</p>
  <ul>
    <li> It&#39;s due to complicated business reasons.</li>
    <li> Hitsumabushi is <a href="https://en.wikipedia.org/wiki/Unadon#Variations">Japanese food</a>.</li>
    <li> Katsuobushi is <a href="https://en.wikipedia.org/wiki/Katsuobushi">yet another Japanese food</a>.</li>
    <li> There is another solution, making a pseudo <code>/dev/urandom</code> file, but I didn&#39;t adopt this. There is no other good way than using a platform-specific API.</li>
    <li> The main reason is portability, but there is also another compelling reason: I wouldn&#39;t be able to make it open-source if it used a platform-specific API.</li>
    <li> To be exact, about 2G of memory was allocated first and was used without additional allocations.</li>
  </ul>
</div>

      </article></div>
  </body>
</html>
