<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.janetacarr.com/mindset-shifts-for-functional-programming-with-clojure/">Original</a>
    <h1>Mindset shifts for functional programming (with Clojure)</h1>
    
    <div id="readability-page-1" class="page"><section>
    <p>For more experienced functional programmers, most of this post will seem introductory, but I introduce some more advanced stuff near the end.</p><h3 id="functional-programming-over-canadian-programming">Functional Programming over Canadian Programming</h3><p>Lately, I&#39;ve been thinking about this Functional Programming journey I&#39;ve been on. I thought it started when I was twenty, but It may have started when I was twelve. See, I used to watch a lot of <a href="https://en.wikipedia.org/wiki/G4_(Canadian_TV_channel)?ref=blog.janetacarr.com">G4TechTV</a> here in Canada. I still remember Amber Macarthur introducing a cool new website called Remember the Milk. </p><p>Remember the Milk was, to my knowledge, one of the first ToDo list Software-as-a-Service apps, circa 2005. All that tech consumer television certainly inspired me to, not only become a computer nerd, but it inspired me to take up programming at thirteen years old because I believed computing was the future.</p><p>I didn&#39;t learn <em>functional</em> programming at thirteen years old though. Like most, I started with an imperative programming language. I learned to program with the easiest programming language around: The C programming language. Okay, it wasn&#39;t that easy, but I still learned. Making introduction to computer programming in University a breeze. </p><p>All throughout University I was still a Remember the Milk user. One day their website spawned a careers page. Much to my curiousity, I decided to checkout the Software Engineer position as I usually did on those kinds of job postings back then. Remember the Milk&#39;s job description was different though. There was talk about <a href="https://www.amazon.ca/Scalable-Internet-Architectures-Theo-Schlossnagle/dp/067232699X/ref=sr_1_1?crid=2BB8B48XVHL22&amp;keywords=scalable+internet+architectures&amp;qid=1680538484&amp;sprefix=scalable+internet+architectures%2Caps%2C90&amp;sr=8-1&amp;ref=blog.janetacarr.com">Scalable Internet Architectures</a>, and this obscure programming language called Scala.</p><p>Soon after, I became enamoured with Scala. I thought &#34;this was what Java should have been&#34;, but I hit a wall soon after reading <a href="https://www.amazon.ca/Scala-Impatient-Cay-S-Horstmann/dp/0321774094/ref=sr_1_3?keywords=scala+for+the+impatient&amp;qid=1680538563&amp;sprefix=Scala+for+the+Imp%2Caps%2C110&amp;sr=8-3&amp;ref=blog.janetacarr.com">Scala for the Impatient</a>. And, I was <em>impatient</em>. I didn&#39;t really understand the funcitonal programming features of Scala. Most of my Scala code looked similar to the Java code I was writing in my programming classes. What the hell were closures, reducers, special-access methods, actors, and pattern matching? No fucking clue. Of course my internet research lead me to another functional programming language, a pure functional programming language, Haskell.</p><p>Haskell suffered from none of the deficiencies of Java Virtual Machine (JVM) functional programming languages at the time. It had it&#39;s own complier that produced binaries as well as having it&#39;s own read-eval-print-loop (REPL), and importantly, because I was a broke student, there was a great book online for free to learn Haskell. Finally, I had unlocked functional programming. I went back to Scala, only using the functional programming features for years. </p><p>Solving problems with Scala and functional programming eventually qualified me for a full-time Clojure position when I finally dropped out of University.</p><h3 id="transformations-over-instructions">Transformations over Instructions</h3><p>The first mindset shift when learning Haskell was to think of a program as a <a href="http://learnyouahaskell.com/introduction?ref=blog.janetacarr.com">series of transformations</a> on data rather than a series of instructions. A philosophy I would carry into other programming languages throughout my career, like when I was Golang developer. Pure functions and reducers like <code>map</code> and <code>filter</code> made for simplicity and easy testing. Transformations on data are so important, Clojure provides <a href="https://blog.janetacarr.com/clojure-transducers-your-composable-big-data-pipelines/">transducers</a> to decouple those transformations from their contexts. Of course, most of us know what a simple series of transformations look like in Clojure:</p><pre><code>(-&gt;&gt; (range)
     (filter even?)
     (map inc)
     (take 10))

(-&gt;&gt; (range)
     (filter even?)
     (map inc)
     (take 10)
     (reduce +))</code></pre><p>Thinking of programs as a series of transformations was necessary because functional programming languages defaulted to immutable or persistent data structures. Meaning, if you want to change the data in the structure, you didn&#39;t mutate the data structure, rather you got a whole new data structure in memory at the end of the transformation, preserving the old data structure.</p><p>At a high level, an operation like <code>map</code> produces a collection the same length as it&#39;s input collection, applying an input function to each value in the input collection as the output collection. Simple on the surface. But, how do you do that without state and, therefore, looping? </p><h3 id="recursion-over-looping">Recursion over Looping</h3><p>Pure functional programming languages like Haskell do not contain a looping construct like <code>for</code> <code>while</code> or <code>do...while</code>. Loops by they&#39;re nature often facilitate side-effects and mutate a variable to track whether or not to continue iteration. </p><p>Inspired by mathematics (a <em>recurring</em> theme in functional programming), functional programming languages often facilitate iteration through <a href="https://en.wikipedia.org/wiki/Recursion?ref=blog.janetacarr.com">recursion</a>. The mindset shift being, how do we construct a recursive function to emulate a loop? </p><p>We can emulate an iteration in a functional programming language by taking advantage of the lexical scope each recursive call has. </p><pre><code>(defn recursive-map
  &#34;Recursively applies `f` to each element in `coll`,
  returning the new collection.&#34;
  [f coll]
  (let [[head &amp; tail] coll]
    (if (empty? coll)
      nil
      (cons (f head) (recursive-map f tail)))))
      
user&gt; (recursive-map identity (range 10))
(0 1 2 3 4 5 6 7 8 9)
user&gt; (recursive-map inc (range 10))
(1 2 3 4 5 6 7 8 9 10)</code></pre><p>Typically, code like this is an anti-pattern in Clojure as it would consume too much stack space for large input. We would have passed our output through each call, building it through the recursive calls like using Clojure&#39;s <code>loop</code> and <code>recur</code>. Unfortunately, Clojure does not have tail-call optimization. To get around this, it has a special form <code>recur</code> to signal to the compiler not to consume stack space, but it has to be in the end position unlike our <code>recursive-map</code> call.</p><p>I chose the example above because it shows a common functional programming technique: Destructuring our input collection into a <code>head</code> and <code>tail</code>. Head being the first element in our collection, and tail being a collection with all except the head of the collection. Rather than looping over an array and applying our function, each recursive call applies a 1-arity function <code>f</code> to each element before getting <code>cons</code>&#39;d into the list.</p><h3 id="functions-over-objects">Functions over Objects</h3><p>Our <code>recursive-map</code> above example uses another mindset shift: higher-order functions. Higher-order functions form the basis for everything else in functional programming. In functional programming languages, functions are first class, meaning we can treat them like any other piece of data. We can pass them to other functions as arguments, return functions from functions, and even having lists of functions. Higher-order functions let us decouple a function from it&#39;s usage, provided the function signatures align. </p><figure><pre><code>user&gt; (take 1 (map println [1 2 3 4 5]))
;; 1
;; 2
;; 3
;; 4
;; 5
;; (nil)
user&gt; (take 1 (map println &#39;(1 2 3 4 5)))
;; 1
;; (nil)</code></pre><figcaption>Clojure side-effects <a href="https://blog.janetacarr.com/how-clojure-works-for-you/#chunked-sequences">gotcha</a></figcaption></figure><p>Functional Programming emphasizes pure functions. That is, functions free from side-effects. Side-effects are behaviours functions perform during their execution aside from computing the output. For example, IO operations, network transmission, and writing to a database are all side-effects. Side-effects cause numerous bugs in software development, so by (nearly) eliminating side-effects, functional programming (nearly) elminates this whole class of bugs. </p><h3 id="design-over-spaghetti">Design over Spaghetti</h3><p>I like to think of transformations, recursion, and functions as the fundamentals of functional programming. With them we can design and emulate a finite state machine (FSM) without any actual state by using the recurring lexical scope to bind our current FSM state. Whenever the state &#34;transitions&#34;, we&#39;ll return a function to replace our <code>game-state</code> in <code>game-loop</code> with a new state for our fake game engine below. Even though I wrote this example in Clojure, there&#39;s nothing stopping someone from replicating it in Haskell:</p><figure><pre><code>(defn pause-menu
  [game]
  (let [{:keys [menu player]} game]
    (do
      (draw-game game)
      (if (= :affirm (:action player))
        (when-let [menu-item (collision player)]
          (cond
            (= menu-item :resume-game) play-game
            (= menu-item :options) (partial options-menu pause-menu)
            (= menu-item :quit-game) quit-game
            :else pause-menu))
        pause-menu))))

(defn options-menu
  [previous game]
  (let [{:keys [menu player]} game]
    (do
      (draw-game game)
      (if (= :affirm (:action player))
        (when-let [menu-item (collision player)]
          (cond
            (= menu-item :controls) controls-menu
            (= menu-item :accessibility) accessibility-menu
            (= menu-item :exit-options) previous
            :else options-menu))
        options-menu))))

(defn play-game
  [game]
  (let [{:keys [components player]} game]
    (do
      (doseq [component components]
        (update! component))
      (draw-game game)
      (if (= :paused (:action player))
        pause-menu
        play-game))))

(defn start-menu
  [game]
  (let [{:keys [menu player]} game]
    (do
      (draw-game game)
      (if (= :affirm (:action player))
        (when-let [menu-item (collision player)]
          (cond ;; our state transition
            (= menu-item :start-game) play-game
            (= menu-item :options) (partial options-menu start-menu)
            (= menu-item :quit-game) quit-game
            :else start-menu))
        start-menu))))

;; Our initial state
(defn start-game
  [game]
  (start-menu game))

(defn game-loop
  [game-state game-engine]
  (when-not (:quit game-engine)
    (recur (game-state game-engine) (game-engine))))

(defn -main
  []
  (game-loop (start-game game-engine) (game-engine)))</code></pre><figcaption>A stateless <a href="https://blog.janetacarr.com/software-design-patterns-in-clojure/#state">state machine</a></figcaption></figure><p>Regular readers will recognize this FSM as my &#34;stateless&#34; state pattern from my design patterns series, but I want to emphasis something else: how we can use the fundamentals of Functional Programming to design solutions without making our lives miserable. At least until AI puts us out of work.</p><h3 id="closure-over-conclusion">Closure over Conclusion</h3><p>Functional Programming is awesome. When I started learning Haskell, it felt like learning to code all over again. After the initial hurdle, Functional Programming gave me a cognitive model for programming that leads to more simplicity and less bugs by emphasizing transformations, recursion, and functions.</p><div><p><em>Thanks for reading. Subscribe for the next one or follow me on twitter </em><a href="https://twitter.com/janetacarr?ref=blog.janetacarr.com"><em>@janetacarr</em></a><em> , or don&#39;t </em>¯\_(ツ)_/¯ <em>. I got a little more personal than usual in this post, so I hope it doesn&#39;t detract from the content. Let me know if it did. You can also join the discussion about this post on twitter, hackernews, or reddit if you think I&#39;m wrong.</em></p></div>
</section></div>
  </body>
</html>
