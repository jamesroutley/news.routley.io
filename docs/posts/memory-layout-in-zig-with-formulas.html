<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://raymondtana.github.io/math/programming/2026/01/23/zig-alignment-and-sizing.html">Original</a>
    <h1>Memory layout in Zig with formulas</h1>
    
    <div id="readability-page-1" class="page"><div>
      
        <header>
          
          

  <p>
    
      
      <span>
        <i aria-hidden="true"></i>
        
        <time datetime="2026-01-23T00:00:00+00:00">January 23, 2026</time>
      </span>
    

    <span></span>

    
      
      

      <span>
        <i aria-hidden="true"></i>
        
          15 minute read
        
      </span>
    
  </p>


        </header>
      

      <section itemprop="text">
        
        <p>I was recently encouraged to watch <a href="https://www.youtube.com/watch?v=IroPQ150F6c">A Practical Guide to Applying Data Oriented Design (DoD)</a> by Andrew Kelley, the creator of <a href="https://ziglang.org/">Zig</a><sup id="fnref:1" role="doc-noteref"><a href="#fn:1" rel="footnote">1</a></sup>. Just 10 minutes into the talk, I was confronted with a skill I had never formally learned… the arithmetic behind <em>memory layout</em> of types.</p>

<p>Throughout the talk, Andrew tested the audience’s ability to compute the alignment and sizes of various types, starting with primitives like <code>u32</code> and <code>bool</code>, and ending with some more complex structures involving enums, unions, and more. As far as I can tell, the exact rules for computing the alignment and size of a type in Zig are not made explicit in any documentation, but are understood by those <em>in-the-know</em>.</p>

<p>As a late-comer to low-level programming myself, I thought I’d collect here some formulas &amp; explanations I landed on while wrestling with alignment and sizing in Zig.</p>

<h2 id="memory-layout-principles">Memory Layout Principles</h2>

<p>For any piece of data stored in memory on a computer, the data must have some natural alignment and size dimensions according to its type. Intuitively, its <em>size</em> captures how many bytes it would take to specify the information that should be contained in any instance of that type. Whereas, its <em>alignment</em> captures the spacing the compiler must obey when choosing valid addresses at which to place data of this type.</p>

<p>I imagine just about any computer science major would have learned the rules of memory layout according to some kind of C-like compiler. I guess the motivation would go something like: “CPUs fetch data from memory in fixed-size blocks of so-many bytes, and performance degrades when data is misaligned. So, compilers automatically pad and align data types.”</p>

<p>In particular, types that don’t “fill up” all of the space in memory allocated to them will be padded with extra bits/bytes to make up for the difference.</p>

<p>Andrew’s whole message in his DoD talk centered on designing your data types to take up as little space in memory as possible, which includes reducing the size, alignment, and padding required to represent the same information.</p>

<p>Probably, the formulas I propose below apply to similar languages beyond Zig and my machine’s (Apple) ABI, but I make no claims.</p>

<p>The Zig language exposes two builtin functions relevant to our discussion:</p>
<ul>
  <li><strong><a href="https://ziglang.org/documentation/master/#alignOf">@alignOf</a>(comptime T: type)</strong>: #bytes required for aligning this type in memory (valid addresses for this type will be multiples of this value);</li>
  <li><strong><a href="https://ziglang.org/documentation/master/#sizeOf">@sizeOf</a>(comptime T: type)</strong>: #bytes for storing the type in memory (including padding).</li>
</ul>

<p>I’ll use the following function <code>memory_printout</code> to report these values for any type:</p>
<div><div><pre><code><span>const</span> <span>std</span> <span>=</span> <span>@import</span><span>(</span><span>&#34;std&#34;</span><span>);</span>

<span>fn</span> <span>memory_printout</span><span>(</span><span>T</span><span>:</span> <span>type</span><span>)</span> <span>void</span> <span>{</span>
    <span>std</span><span>.</span><span>debug</span><span>.</span><span>print</span><span>(</span><span>&#34;@alignOf( {s} ): {d}</span><span>\t</span><span>&#34;</span><span>,</span> <span>.</span><span>{</span> <span>@typeName</span><span>(</span><span>T</span><span>),</span> <span>@alignOf</span><span>(</span><span>T</span><span>)</span> <span>});</span>
    <span>std</span><span>.</span><span>debug</span><span>.</span><span>print</span><span>(</span><span>&#34;@sizeOf( {s} ): {d}</span><span>\n</span><span>&#34;</span><span>,</span> <span>.</span><span>{</span> <span>@typeName</span><span>(</span><span>T</span><span>),</span> <span>@sizeOf</span><span>(</span><span>T</span><span>)</span> <span>});</span>
<span>}</span>
</code></pre></div></div>

<h2 id="memory-layout-formulas">Memory Layout Formulas</h2>

<p>To start, one helpful invariant is offered in Zig’s documentation. For any type <code>T</code>:</p>

\[\texttt{@sizeOf(T)} \geq \texttt{@alignOf(T)}.\]

<h3 id="primitives">Primitives</h3>

<p>Already, the primitive data types will teach us a good bit about memory layout. Try guessing the results of the following Zig code before looking at the answer:</p>
<div><div><pre><code><span>pub</span> <span>fn</span> <span>main</span><span>()</span> <span>void</span> <span>{</span>
    <span>const</span> <span>types</span> <span>=</span> <span>[</span><span>_</span><span>]</span><span>type</span><span>{</span> <span>bool</span><span>,</span> <span>c_char</span><span>,</span> <span>u8</span><span>,</span> <span>*</span><span>u8</span><span>,</span> <span>u16</span><span>,</span> <span>u17</span><span>,</span> <span>i32</span><span>,</span> <span>f64</span><span>,</span> <span>usize</span> <span>};</span>
    <span>inline</span> <span>for</span> <span>(</span><span>types</span><span>)</span> <span>|</span><span>T</span><span>|</span> <span>memory_printout</span><span>(</span><span>T</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<details>
  <summary>The Output:</summary>
  <div><div><pre><code><span>@alignOf</span><span>(</span> <span>bool</span> <span>):</span> <span>1</span>       <span>@sizeOf</span><span>(</span> <span>bool</span> <span>):</span> <span>1</span>
<span>@alignOf</span><span>(</span> <span>c_char</span> <span>):</span> <span>1</span>     <span>@sizeOf</span><span>(</span> <span>c_char</span> <span>):</span> <span>1</span>
<span>@alignOf</span><span>(</span> <span>u8</span> <span>):</span> <span>1</span>         <span>@sizeOf</span><span>(</span> <span>u8</span> <span>):</span> <span>1</span>
<span>@alignOf</span><span>(</span> <span>*</span><span>u8</span> <span>):</span> <span>8</span>        <span>@sizeOf</span><span>(</span> <span>*</span><span>u8</span> <span>):</span> <span>8</span>
<span>@alignOf</span><span>(</span> <span>u16</span> <span>):</span> <span>2</span>        <span>@sizeOf</span><span>(</span> <span>u16</span> <span>):</span> <span>2</span>
<span>@alignOf</span><span>(</span> <span>u17</span> <span>):</span> <span>4</span>        <span>@sizeOf</span><span>(</span> <span>u17</span> <span>):</span> <span>4</span>
<span>@alignOf</span><span>(</span> <span>i32</span> <span>):</span> <span>4</span>        <span>@sizeOf</span><span>(</span> <span>i32</span> <span>):</span> <span>4</span>
<span>@alignOf</span><span>(</span> <span>f64</span> <span>):</span> <span>8</span>        <span>@sizeOf</span><span>(</span> <span>f64</span> <span>):</span> <span>8</span>
<span>@alignOf</span><span>(</span> <span>usize</span> <span>):</span> <span>8</span>      <span>@sizeOf</span><span>(</span> <span>usize</span> <span>):</span> <span>8</span>
</code></pre></div>  </div>
</details>

<p>This suggests the following formula for primitive data types:</p>

\[\texttt{@sizeOf(primitive)} = \texttt{@alignOf(primitive)}.\]

<p>Most of these make sense. A <code>c_char</code> truly requires 8 bits, or 1 byte to specify.</p>

<p>Whereas, a <code>bool</code> comprises a single bit (information-theoretically). But, alignment and size are measured in <em>whole bytes</em>, so we should round up to the nearest byte (and pad with 7 bits to fill up that byte).</p>

<p>Similarly, any unsigned integer <code>u{b}</code>, signed integer <code>i{b}</code>, or floating-point number <code>f{b}</code> contains $b$ bits of information. So, counting in bytes, we will have to round $b / 8$ up, somehow. But, look at <code>u17</code>: despite $2 &lt; 17 / 8 \leq 3$, the size of <code>u17</code> is not 3 bytes. Instead, it’s 4 bytes. In general, alignment and size must be <em>powers-of-2</em> bytes. This is another desirable property half-dictated by architecture and half-related to the convenience of powers of two. So, we actually always <em>round up to the nearest power-of-2 bytes</em> when converting from bits.</p>

<p>Let’s formalize this conversion from bits to bytes for good:</p>

\[\begin{aligned}
  \texttt{bytes}(\texttt{bits}) &amp;:= \max\left\{1, 2^{\left\lceil\log_2(\frac{\texttt{bits}}{8}) \right\rceil}\right\}.
\end{aligned}\]

<p>Another consequence of alignment and size being powers of two is the following, stronger invariant. For any type <code>T</code>:</p>

\[\texttt{@alignOf(T)} \mid \texttt{@sizeOf(T)}.\]

<p>That is, the size of the type is always a multiple of its alignment.</p>

<p>Next up, depending on your architecture, <code>usize</code> will either match <code>u32</code> or <code>u64</code>. I’m working on a 64-bit machine, so that’s why we see its size and alignment as 8 bytes. Moreover, any pointer (such as <code>*u8</code>) represents an address, which is guaranteed by Zig to match <code>usize</code>.</p>

<p>For primitive data types, remember: <strong>their size and align values agree and equal the smallest power-of-2 many bytes required to represent that type in memory</strong>.</p>

<h3 id="structs">Structs</h3>

<p>In Zig, a <code>struct</code> combines many fields into a single data type. How does memory layout work when many fields are combined together?</p>

<blockquote>
  <p><strong>Note</strong>: Zig automatically minimizes the memory footprint of a struct by possibly shuffling around its fields. To force the Zig compiler to respect the order of the fields as we’ve defined them, we may use the <code>extern</code> keyword as shown below. Really, this forces the compiler to obey C ABI compatibility.</p>
</blockquote>

<p>First, rest assured that structs add no overhead. That is, if <code>T</code> is a type, and we define:</p>
<div><div><pre><code><span>const</span> <span>struct_T</span> <span>=</span> <span>struct</span> <span>{</span>
  <span>field</span><span>:</span> <span>T</span><span>,</span>
<span>};</span>
</code></pre></div></div>
<p>then <code>@alignOf(struct_T) == @alignOf(T)</code> and <code>@sizeOf(struct_T) == @sizeOf(T)</code>.</p>

<p>Now, when a struct envelops two fields, such as</p>
<div><div><pre><code><span>const</span> <span>pair</span> <span>=</span> <span>extern</span> <span>struct</span> <span>{</span>
  <span>a</span><span>:</span> <span>u8</span><span>,</span>
  <span>b</span><span>:</span> <span>u32</span><span>,</span>
<span>};</span>
</code></pre></div></div>
<p>we should consider the meanings of align and size again:</p>
<ul>
  <li>The alignment of the struct <code>pair</code> should be such that any offset by this alignment value does not break the alignment of its constituent fields <code>a</code> and <code>b</code>.
    <ul>
      <li>Here, field <code>b</code> has a stricter alignment of 4 bytes, whereas <code>a</code> permits offsets of 1 byte. So, <code>pair</code> better also only permit alignments of 4 bytes.</li>
    </ul>
  </li>
  <li>The size of the struct <code>pair</code> is dictated by its alignment. Its memory will necessarily take up a number of bytes which is a multiple of its alignment. To figure out exactly how many, we iterate through the fields in order, trying our best to greedily pack those fields while still respecting their own alignments.
    <ul>
      <li>Here, the size of <code>a</code> is just one byte, so it fits into a single memory chunk of size 4 bytes (the alignment of <code>pair</code> is 4 bytes), with three bytes to spare. Now, we consider the next field: <code>b</code>. As its alignment is 4 bytes, we can only write <code>b</code> at an address which is a multiple of its own alignment. The soonest we can accomplish this is by padding three bytes after <code>a</code> and writing <code>b</code> at the fourth byte. This already places <code>b</code> into another 4-byte memory chunk, in which it fits entirely as its size is 4 bytes. So, the total size of <code>pair</code> is 8 bytes.</li>
    </ul>
  </li>
</ul>

<p>Now, what do you expect the output of the following Zig code to be?</p>
<div><div><pre><code><span>pub</span> <span>fn</span> <span>main</span><span>()</span> <span>void</span> <span>{</span>
    <span>memory_printout</span><span>(</span><span>ABAB</span><span>);</span>
    <span>memory_printout</span><span>(</span><span>ABBA</span><span>);</span>
<span>}</span>

<span>const</span> <span>ABAB</span> <span>=</span> <span>extern</span> <span>struct</span> <span>{</span>
    <span>a1</span><span>:</span> <span>u8</span><span>,</span>
    <span>b1</span><span>:</span> <span>u16</span><span>,</span>
    <span>a2</span><span>:</span> <span>u8</span><span>,</span>
    <span>b2</span><span>:</span> <span>u16</span><span>,</span>
<span>};</span>

<span>const</span> <span>ABBA</span> <span>=</span> <span>extern</span> <span>struct</span> <span>{</span>
    <span>a1</span><span>:</span> <span>u8</span><span>,</span>
    <span>a2</span><span>:</span> <span>u8</span><span>,</span>
    <span>b1</span><span>:</span> <span>u16</span><span>,</span>
    <span>b2</span><span>:</span> <span>u16</span><span>,</span>
<span>};</span>
</code></pre></div></div>

<details>
  <summary>The Answer:</summary>
  <div><div><pre><code><span>@alignOf</span><span>(</span> <span>ABAB</span> <span>):</span> <span>2</span>      <span>@sizeOf</span><span>(</span> <span>ABAB</span> <span>):</span> <span>8</span>
<span>@alignOf</span><span>(</span> <span>ABBA</span> <span>):</span> <span>2</span>      <span>@sizeOf</span><span>(</span> <span>ABBA</span> <span>):</span> <span>6</span>
</code></pre></div>  </div>
</details>

<p>In general, deciding the placement of a struct field follows this rule:</p>
<blockquote>
  <p><strong>Rule</strong>: Each field is placed after the previous field at the next smallest multiple of its own alignment.</p>
</blockquote>

<p>In general, the formula for rounding a number $N$ up to the nearest multiple of some other number $m$ looks like:</p>

\[\texttt{next_mult}(N, m) := \left\lceil \frac{N}{m} \right\rceil \cdot m.\\\]

<p>Given this, try to follow the next example. We make use of another Zig builtin <code>@offsetOf(&lt;type&gt;, &lt;field_name&gt;)</code> to display exactly where each field is placed in memory relative to the beginning address of <code>S</code>.</p>
<div><div><pre><code><span>fn</span> <span>printOffset</span><span>(</span><span>T</span><span>:</span> <span>type</span><span>,</span> <span>comptime</span> <span>f</span><span>:</span> <span>[:</span><span>0</span><span>]</span><span>const</span> <span>u8</span><span>)</span> <span>void</span> <span>{</span>
    <span>std</span><span>.</span><span>debug</span><span>.</span><span>print</span><span>(</span><span>&#34;@offsetOf( {s} ) = {d}</span><span>\n</span><span>&#34;</span><span>,</span> <span>.</span><span>{</span> <span>f</span><span>,</span> <span>@offsetOf</span><span>(</span><span>T</span><span>,</span> <span>f</span><span>)</span> <span>});</span>
<span>}</span>

<span>pub</span> <span>fn</span> <span>main</span><span>()</span> <span>void</span> <span>{</span>
  <span>memory_printout</span><span>(</span><span>S</span><span>);</span>
  <span>printOffset</span><span>(</span><span>S</span><span>,</span> <span>&#34;a&#34;</span><span>);</span>
  <span>printOffset</span><span>(</span><span>S</span><span>,</span> <span>&#34;b&#34;</span><span>);</span>
  <span>printOffset</span><span>(</span><span>S</span><span>,</span> <span>&#34;c&#34;</span><span>);</span>
<span>}</span>

<span>const</span> <span>S</span> <span>=</span> <span>extern</span> <span>struct</span> <span>{</span>
    <span>// align = size = 2</span>
    <span>a</span><span>:</span> <span>u16</span><span>,</span>
    <span>// align = 2, size = 6</span>
    <span>b</span><span>:</span> <span>extern</span> <span>struct</span> <span>{</span> <span>b1</span><span>:</span> <span>u16</span><span>,</span> <span>b2</span><span>:</span> <span>u16</span><span>,</span> <span>b3</span><span>:</span> <span>u16</span> <span>},</span>
    <span>// align = size = 4</span>
    <span>c</span><span>:</span> <span>u32</span><span>,</span>
<span>};</span>
</code></pre></div></div>
<details>
  <summary>Output:</summary>
  <div><div><pre><code><span>@alignOf</span><span>(</span> <span>S</span> <span>):</span> <span>4</span>        <span>@sizeOf</span><span>(</span> <span>S</span> <span>):</span> <span>12</span>
<span>@offsetOf</span><span>(</span> <span>a</span> <span>)</span> <span>=</span> <span>0</span>
<span>@offsetOf</span><span>(</span> <span>b</span> <span>)</span> <span>=</span> <span>2</span>
<span>@offsetOf</span><span>(</span> <span>c</span> <span>)</span> <span>=</span> <span>8</span>
</code></pre></div>  </div>
</details>

<p>In general, alignment for structs is quite simple to formulate:</p>

\[\texttt{@alignOf(struct)} := \max_{\texttt{fields}} \texttt{@alignOf(field)}.\]

<p>In contrast, the size of the (externed) struct is more complicated: $\texttt{@sizeOf(struct)}$ is the smallest multiple of $\texttt{@alignOf(struct)}$ many bytes required to fit the fields of a struct (in order) such that:</p>

<ol>
  <li>No two fields overlap in memory, and</li>
  <li>Each field lies at an address which is a multiple of its own alignment: $\texttt{@alignOf(field)}$.</li>
</ol>

<p>Without the <code>extern</code> keyword, Zig minimizes the size of the struct under all permutations of its fields. Zig also offers <code>packed struct</code>, which eliminates padding entirely and lays out fields in strict bit-order. While this can reduce memory usage further, it comes with performance trade-offs and restrictions on field access.</p>

<blockquote>
  <p><strong>Bonus question</strong>: Try to explain why the choice to make alignments and sizes be powers of two is vital for these rules to be well-defined for assessing the alignment and size of structs.</p>
</blockquote>

<h3 id="enums">Enums</h3>

<p>Under the hood, an enum works on indices, not labels. So, the alignment and size of an enum will equal the minimal number of bytes to express the type of its indices. Suppose <code>T = enum (u{b}) { ... }</code> is an arbitrary enum indexed by unsigned integers of type <code>u{b}</code>, where <code>b</code> is measured in bits.</p>

<blockquote>
  <p><strong>Note</strong>: we may use the Zig standard library to access the number of options in the enum as follows: <code>std.meta.fields(T).len</code>. I’ll call this $\texttt{T.len}$, below.</p>
</blockquote>

<blockquote>
  <p><strong>Note</strong>: By default, Zig’s compiler assigns indices starting at zero and counting up by one. So, by default, Zig sets <code>b</code> to $\lceil \log_2 (\texttt{T.len}) \rceil$.</p>
</blockquote>

<p>Then,</p>

\[\begin{aligned}
\texttt{@alignOf(enum(u{b}))} &amp;= \texttt{@alignOf(u{b})} = \texttt{bytes}(\texttt{b}),\\
\texttt{@sizeOf(enum(u{b}))} &amp;=  \texttt{@sizeOf(u{b})} = \texttt{bytes}(\texttt{b}).
\end{aligned}\]

<p>We’ve made use of the $\texttt{bytes}$ function, again<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" rel="footnote">2</a></sup>.</p>

<p>Example:</p>
<div><div><pre><code><span>const</span> <span>T_default</span> <span>=</span> <span>enum</span> <span>{</span> <span>a</span><span>,</span> <span>b</span><span>,</span> <span>c</span><span>,</span> <span>d</span><span>,</span> <span>e</span> <span>};</span>
<span>const</span> <span>T_long</span> <span>=</span> <span>enum</span><span>(</span><span>u64</span><span>)</span> <span>{</span> <span>a</span><span>,</span> <span>b</span><span>,</span> <span>c</span><span>,</span> <span>d</span><span>,</span> <span>e</span> <span>};</span>

<span>memory_printout</span><span>(</span><span>T_default</span><span>);</span>
<span>memory_printout</span><span>(</span><span>T_long</span><span>);</span>
</code></pre></div></div>
<details>
  <summary>Output:</summary>
  <div><div><pre><code><span>@alignOf</span><span>(</span> <span>T_default</span> <span>):</span> <span>1</span>    <span>@sizeOf</span><span>(</span> <span>T_default</span> <span>):</span> <span>1</span>
<span>@alignOf</span><span>(</span> <span>T_long</span> <span>):</span> <span>8</span>       <span>@sizeOf</span><span>(</span> <span>T_long</span> <span>):</span> <span>8</span>
</code></pre></div>  </div>
</details>

<h3 id="arrays-and-slices">Arrays and Slices</h3>

<p>For an array in Zig, its alignment inherits from that of its elements, and its size is just length$\times$size of the type:</p>

\[\begin{aligned}
  \texttt{@alignOf([N]T)} &amp;= \texttt{@alignOf(T)},\\
  \texttt{@sizeOf([N]T)} &amp;= \texttt{N} \cdot \texttt{@sizeOf(T)}.
\end{aligned}\]

<p>In contrast, a slice in Zig is just a special case of a struct which contains one pointer (<code>usize</code>) and a length (<code>usize</code>). So,</p>

\[\begin{aligned}
  \texttt{@alignOf(slice)} &amp;= \texttt{@alignOf(usize)} = 8 \text{ bytes (on 64-bit)},\\
  \texttt{@sizeOf(slice)} &amp;= 2 \cdot \texttt{@sizeOf(usize)} = 16 \text{ bytes (on 64-bit)}.
\end{aligned}\]

<p>Example (using another builtin <code>@TypeOf</code>):</p>
<div><div><pre><code><span>pub</span> <span>fn</span> <span>main</span><span>()</span> <span>void</span> <span>{</span>
    <span>memory_printout</span><span>(</span><span>@TypeOf</span><span>(</span><span>digits_array</span><span>));</span>
    <span>memory_printout</span><span>(</span><span>@TypeOf</span><span>(</span><span>digits_slice</span><span>));</span>
<span>}</span>

<span>const</span> <span>digits_array</span> <span>=</span> <span>[</span><span>10</span><span>]</span><span>u8</span><span>{</span> <span>0</span><span>,</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>,</span> <span>6</span><span>,</span> <span>7</span><span>,</span> <span>8</span><span>,</span> <span>9</span> <span>};</span>
<span>const</span> <span>digits_slice</span><span>:</span> <span>[]</span><span>const</span> <span>u8</span> <span>=</span> <span>digits_array</span><span>[</span><span>0</span><span>..</span><span>];</span> 
</code></pre></div></div>
<details>
  <summary>Output:</summary>
  <div><div><pre><code><span>@alignOf</span><span>(</span> <span>[</span><span>10</span><span>]</span><span>u8</span> <span>):</span> <span>1</span>         <span>@sizeOf</span><span>(</span> <span>[</span><span>10</span><span>]</span><span>u8</span> <span>):</span> <span>10</span>
<span>@alignOf</span><span>(</span> <span>[]</span><span>const</span> <span>u8</span> <span>):</span> <span>8</span>     <span>@sizeOf</span><span>(</span> <span>[]</span><span>const</span> <span>u8</span> <span>):</span> <span>16</span>
</code></pre></div>  </div>
</details>

<h3 id="untagged-unions">(Untagged) Unions</h3>

<p>An untagged, bare union in Zig (accomplished with the <code>extern</code> keyword) essentially acts as a switch statement over a number of mutually-exclusive options of various types without the ability to report which option is active. To express a bare union type in memory, we just need enough memory to store the largest option(s).</p>

\[\begin{aligned}
  \texttt{@alignOf(bare_union)} &amp;= \max_{\texttt{fields}} \{\texttt{@alignOf(field)}\},\\
  \texttt{@sizeOf(bare_union)} &amp;= \texttt{next_mult} \left(\max_{\texttt{fields}} \{\texttt{@sizeOf(field)} \}, \texttt{@alignOf(bare_union)} \right).
\end{aligned}\]

<p>However, untagged unions in Zig without the <code>extern</code> keyword seem to require extra memory, essentially one more alignment’s worth. So, untagged unions should satisfy:</p>

\[\begin{aligned}
  \texttt{@alignOf(union)} &amp;= \max_{\texttt{fields}} \{\texttt{@alignOf(field)}\},\\
  \texttt{@sizeOf(union)} &amp;= \texttt{next_mult} \left(\max_{\texttt{fields}} \{\texttt{@sizeOf(field)} \}, \texttt{@alignOf(union)} \right) + \texttt{@alignOf(union)}.
\end{aligned}\]

<p>Example:</p>
<div><div><pre><code><span>pub</span> <span>fn</span> <span>main</span><span>()</span> <span>void</span> <span>{</span>
    <span>memory_printout</span><span>(</span><span>U_bare</span><span>);</span>
    <span>memory_printout</span><span>(</span><span>U</span><span>);</span>
<span>}</span>

<span>const</span> <span>U_bare</span> <span>=</span> <span>extern</span> <span>union</span> <span>{</span>
    <span>a</span><span>:</span> <span>i64</span><span>,</span>
    <span>b</span><span>:</span> <span>extern</span> <span>struct</span> <span>{</span> <span>c</span><span>:</span> <span>i64</span><span>,</span> <span>d</span><span>:</span> <span>i64</span><span>,</span> <span>e</span><span>:</span> <span>i64</span> <span>},</span>
<span>};</span>

<span>const</span> <span>U</span> <span>=</span> <span>union</span> <span>{</span>
    <span>a</span><span>:</span> <span>i64</span><span>,</span>
    <span>b</span><span>:</span> <span>struct</span> <span>{</span> <span>c</span><span>:</span> <span>i64</span><span>,</span> <span>d</span><span>:</span> <span>i64</span><span>,</span> <span>e</span><span>:</span> <span>i64</span> <span>},</span>
<span>};</span>
</code></pre></div></div>

<details>
  <summary>Output:</summary>
  <div><div><pre><code><span>@alignOf</span><span>(</span> <span>U_bare</span> <span>):</span> <span>8</span>   <span>@sizeOf</span><span>(</span> <span>U_bare</span> <span>):</span> <span>24</span>
<span>@alignOf</span><span>(</span> <span>U</span> <span>):</span> <span>8</span>        <span>@sizeOf</span><span>(</span> <span>U</span> <span>):</span> <span>32</span>
</code></pre></div>  </div>
</details>

<h3 id="tagged-unions">Tagged Unions</h3>

<p>Tagged unions are unions which use an additional enum to detect which field is active in the union. Alignment for a tagged union must additionally consider the alignment of the tag too, while the size must treat the tag and fields together.</p>

<blockquote>
  <p><strong>Note</strong>: there are no “bare” tagged unions. So, the <code>extern</code> keyword doesn’t work on tagged unions.</p>
</blockquote>

<p>Suppose <code>U(E)</code> is of type <code>union(enum)</code>. Then, we can compute the alignment and size of this type depending on those of its union and enum components:</p>

\[\begin{aligned}
  \texttt{@alignOf(U(E))} &amp;= \max\{\texttt{@alignOf(U)}, \texttt{@alignOf(E)}\},\\
  \texttt{@sizeOf(U(E))} &amp;= \texttt{next_mult} \left(\max_{\texttt{fields}} \{\texttt{@sizeOf(field)} \} + \texttt{@sizeOf(E)}, \texttt{@alignOf(U(E))} \right).
\end{aligned}\]

<p>Example:</p>

<div><div><pre><code><span>pub</span> <span>fn</span> <span>main</span><span>()</span> <span>void</span> <span>{</span>
    <span>memory_printout</span><span>(</span><span>UE</span><span>);</span>
    <span>memory_printout</span><span>(</span><span>UF</span><span>);</span>
    <span>memory_printout</span><span>(</span><span>UG</span><span>);</span>
<span>}</span>

<span>const</span> <span>E</span> <span>=</span> <span>enum</span> <span>{</span> <span>a</span><span>,</span> <span>b</span> <span>};</span>
<span>const</span> <span>F</span> <span>=</span> <span>enum</span><span>(</span><span>u64</span><span>)</span> <span>{</span> <span>a</span><span>,</span> <span>b</span> <span>};</span>
<span>const</span> <span>G</span> <span>=</span> <span>enum</span><span>(</span><span>u128</span><span>)</span> <span>{</span> <span>a</span><span>,</span> <span>b</span> <span>};</span>

<span>const</span> <span>UE</span> <span>=</span> <span>union</span><span>(</span><span>E</span><span>)</span> <span>{</span>
    <span>a</span><span>:</span> <span>i64</span><span>,</span> <span>b</span><span>:</span> <span>struct</span> <span>{</span> <span>c</span><span>:</span> <span>i64</span><span>,</span> <span>d</span><span>:</span> <span>i64</span> <span>}</span>
<span>};</span>
<span>const</span> <span>UF</span> <span>=</span> <span>union</span><span>(</span><span>F</span><span>)</span> <span>{</span>
    <span>a</span><span>:</span> <span>i64</span><span>,</span> <span>b</span><span>:</span> <span>struct</span> <span>{</span> <span>c</span><span>:</span> <span>i64</span><span>,</span> <span>d</span><span>:</span> <span>i64</span> <span>}</span>
<span>};</span>
<span>const</span> <span>UG</span> <span>=</span> <span>union</span><span>(</span><span>G</span><span>)</span> <span>{</span>
    <span>a</span><span>:</span> <span>i64</span><span>,</span> <span>b</span><span>:</span> <span>struct</span> <span>{</span> <span>c</span><span>:</span> <span>i64</span><span>,</span> <span>d</span><span>:</span> <span>i64</span> <span>}</span>
<span>};</span>
</code></pre></div></div>

<details>
  <summary>Output:</summary>
  <div><div><pre><code><span>@alignOf</span><span>(</span> <span>UE</span> <span>):</span> <span>8</span>       <span>@sizeOf</span><span>(</span> <span>UE</span> <span>):</span> <span>24</span>
<span>@alignOf</span><span>(</span> <span>UF</span> <span>):</span> <span>8</span>       <span>@sizeOf</span><span>(</span> <span>UF</span> <span>):</span> <span>24</span>
<span>@alignOf</span><span>(</span> <span>UG</span> <span>):</span> <span>16</span>      <span>@sizeOf</span><span>(</span> <span>UG</span> <span>):</span> <span>32</span>
</code></pre></div>  </div>
</details>

<h3 id="arraylists-and-multiarraylists">ArrayLists and MultiArrayLists</h3>

<p>An <code>ArrayList(T)</code> in Zig is the standard library’s dynamic array implementation. This is comparable to the notions of a “vector” in C++ or a “list” in Python, otherwise understood as the <em>Array of Structs</em> (AoS) memory layout. Elements of type <code>T</code> are stored contiguously in memory each with their full size and padding.</p>

<p>The <code>ArrayList(T)</code> type itself is a struct containing:</p>
<ul>
  <li><code>items</code>: a slice <code>[]T</code>, and</li>
  <li><code>capacity</code>: a <code>usize</code>.</li>
</ul>

<p>So, the <code>ArrayList(T)</code> type has a fixed memory footprint:</p>

\[\begin{aligned}
  \texttt{@alignOf(ArrayList(T))} &amp;= \texttt{@alignOf(usize)} = 8 \text{ bytes (on 64-bit)},\\
  \texttt{@sizeOf(ArrayList(T))} &amp;= 3 \cdot \texttt{@sizeOf(usize)} = \text{24 bytes (on 64-bit)}.
\end{aligned}\]

<p>However, the <em>data</em> that the ArrayList manages lives on the heap. When iterating over an ArrayList, you traverse memory in strides of $\texttt{@sizeOf(T)}$ bytes. The memory consumed by the backing buffer is simply:</p>

\[\begin{aligned}
  \texttt{buffer_alignment} &amp;= \texttt{@alignOf(T)},\\
  \texttt{buffer_size} &amp;= \texttt{buffer.capacity} \cdot \texttt{@sizeOf(T)}.
\end{aligned}\]

<p>In contrast, a <code>MultiArrayList(T)</code> in Zig follows the <em>Struct of Arrays</em> (SoA) memory layout. Instead of storing complete <code>T</code> instances contiguously, it stores each field of <code>T</code> in its own separate, tightly-packed array.</p>

<p>The <code>MultiArrayList(T)</code> type itself is a struct containing:</p>
<ul>
  <li><code>ptr</code>: a single pointer to the backing buffer,</li>
  <li><code>len</code>: a <code>usize</code>,</li>
  <li><code>capacity</code>: a <code>usize</code>.</li>
</ul>

<p>So:</p>

\[\begin{aligned}
  \texttt{@alignOf(MultiArrayList(T))} &amp;= \texttt{@alignOf(usize)} = 8 \text{ bytes (on 64-bit)},\\
  \texttt{@sizeOf(MultiArrayList(T))} &amp;= 3 \cdot \texttt{@sizeOf(usize)} = 24 \text{ bytes (on 64-bit)}.
\end{aligned}\]

<p>The backing buffer stores all field arrays contiguously. Padding between fields is not needed; instead, each field array is packed according to the field’s alignment. Summing over the fields of $T$, the total buffer size would thus be:</p>

\[\texttt{buffer_size} = \texttt{buffer.capacity} \cdot \sum_{\texttt{fields}} \texttt{@sizeOf}(\texttt{field}).\]

<p>Example:</p>
<div><div><pre><code><span>const</span> <span>std</span> <span>=</span> <span>@import</span><span>(</span><span>&#34;std&#34;</span><span>);</span>
<span>const</span> <span>ArrayList</span> <span>=</span> <span>std</span><span>.</span><span>ArrayList</span><span>;</span>
<span>const</span> <span>MultiArrayList</span> <span>=</span> <span>std</span><span>.</span><span>MultiArrayList</span><span>;</span>

<span>pub</span> <span>fn</span> <span>main</span><span>()</span> <span>!</span><span>void</span> <span>{</span>
    <span>var</span> <span>gpa</span> <span>=</span> <span>std</span><span>.</span><span>heap</span><span>.</span><span>GeneralPurposeAllocator</span><span>(</span><span>.</span><span>{}){};</span>
    <span>const</span> <span>allocator</span> <span>=</span> <span>gpa</span><span>.</span><span>allocator</span><span>();</span>

    <span>const</span> <span>T</span> <span>=</span> <span>struct</span> <span>{</span> <span>a</span><span>:</span> <span>u8</span><span>,</span> <span>b</span><span>:</span> <span>u16</span> <span>};</span>

    <span>var</span> <span>list</span><span>:</span> <span>ArrayList</span><span>(</span><span>T</span><span>)</span> <span>=</span> <span>.</span><span>{};</span>
    <span>defer</span> <span>list</span><span>.</span><span>deinit</span><span>(</span><span>allocator</span><span>);</span>

    <span>var</span> <span>multiList</span><span>:</span> <span>MultiArrayList</span><span>(</span><span>T</span><span>)</span> <span>=</span> <span>.</span><span>{};</span>
    <span>defer</span> <span>multiList</span><span>.</span><span>deinit</span><span>(</span><span>allocator</span><span>);</span>

    <span>for</span> <span>(</span><span>0</span><span>..</span><span>10_000</span><span>)</span> <span>|</span><span>_</span><span>|</span> <span>{</span>
        <span>try</span> <span>list</span><span>.</span><span>append</span><span>(</span><span>allocator</span><span>,</span> <span>.</span><span>{</span> <span>.</span><span>a</span> <span>=</span> <span>0</span><span>,</span> <span>.</span><span>b</span> <span>=</span> <span>1</span> <span>});</span>
        <span>try</span> <span>multiList</span><span>.</span><span>append</span><span>(</span><span>allocator</span><span>,</span> <span>.</span><span>{</span> <span>.</span><span>a</span> <span>=</span> <span>0</span><span>,</span> <span>.</span><span>b</span> <span>=</span> <span>1</span> <span>});</span>
    <span>}</span>

    <span>memory_printout</span><span>(</span><span>T</span><span>);</span>
    <span>memory_printout</span><span>(</span><span>ArrayList</span><span>(</span><span>T</span><span>));</span>
    <span>memory_printout</span><span>(</span><span>MultiArrayList</span><span>(</span><span>T</span><span>));</span>
    <span>std</span><span>.</span><span>debug</span><span>.</span><span>print</span><span>(</span><span>&#34;list capacity: {d}</span><span>\n</span><span>&#34;</span><span>,</span> <span>.</span><span>{</span><span>list</span><span>.</span><span>capacity</span><span>});</span>
    <span>std</span><span>.</span><span>debug</span><span>.</span><span>print</span><span>(</span><span>&#34;list buffer size: {d}</span><span>\n</span><span>&#34;</span><span>,</span> <span>.</span><span>{</span><span>list</span><span>.</span><span>capacity</span> <span>*</span> <span>@sizeOf</span><span>(</span><span>T</span><span>)});</span>
    <span>std</span><span>.</span><span>debug</span><span>.</span><span>print</span><span>(</span><span>&#34;multiList capacity: {d}</span><span>\n</span><span>&#34;</span><span>,</span> <span>.</span><span>{</span><span>multiList</span><span>.</span><span>capacity</span><span>});</span>
    <span>std</span><span>.</span><span>debug</span><span>.</span><span>print</span><span>(</span><span>&#34;multiList buffer size: {d}</span><span>\n</span><span>&#34;</span><span>,</span> <span>.</span><span>{</span><span>multiList</span><span>.</span><span>capacity</span> <span>*</span> <span>(</span><span>@sizeOf</span><span>(</span><span>@FieldType</span><span>(</span><span>T</span><span>,</span> <span>&#34;a&#34;</span><span>))</span> <span>+</span> <span>@sizeOf</span><span>(</span><span>@FieldType</span><span>(</span><span>T</span><span>,</span> <span>&#34;b&#34;</span><span>)))});</span>
<span>}</span>
</code></pre></div></div>

<details>
  <summary>Output:</summary>
  <div><div><pre><code><span>@alignOf</span><span>(</span> <span>T</span> <span>):</span> <span>2</span>                  <span>@sizeOf</span><span>(</span> <span>T</span> <span>):</span> <span>4</span>
<span>@alignOf</span><span>(</span> <span>ArrayList</span><span>(</span><span>T</span><span>)</span> <span>):</span> <span>8</span>       <span>@sizeOf</span><span>(</span> <span>ArrayList</span><span>(</span><span>T</span><span>)</span> <span>):</span> <span>24</span>
<span>@alignOf</span><span>(</span> <span>MultiArrayList</span><span>(</span><span>T</span><span>)</span> <span>):</span> <span>8</span>  <span>@sizeOf</span><span>(</span> <span>MultiArrayList</span><span>(</span><span>T</span><span>)</span> <span>):</span> <span>24</span>
<span>list</span> <span>capacity</span><span>:</span> <span>12854</span>
<span>list</span> <span>buffer</span> <span>size</span><span>:</span> <span>51416</span>
<span>multiList</span> <span>capacity</span><span>:</span> <span>11150</span>
<span>multiList</span> <span>buffer</span> <span>size</span><span>:</span> <span>33450</span>
</code></pre></div>  </div>
</details>

<h2 id="battle-testing">Battle Testing</h2>

<p>Let’s test our formulas against the video that inspired this post: Andrew Kelley’s talk on <a href="https://www.youtube.com/watch?v=IroPQ150F6c">DoD</a>.</p>

<blockquote>
  <p><strong>Note</strong>: In order to get these examples to actually compile and execute in Zig (0.16.0), I had to throw in some allocators and extra helper methods.</p>
</blockquote>

<h3 id="arraylist-of-monsters-1905">ArrayList of Monsters (<a href="https://www.youtube.com/watch?v=IroPQ150F6c">19:05</a>)</h3>

<div><div><pre><code><span>const</span> <span>Monster</span> <span>=</span> <span>struct</span> <span>{</span>
  <span>anim</span><span>:</span> <span>*</span><span>Animation</span><span>,</span> 
  <span>kind</span><span>:</span> <span>Kind</span><span>,</span>

  <span>const</span> <span>Kind</span> <span>=</span> <span>enum</span> <span>{</span> <span>snake</span><span>,</span> <span>bat</span><span>,</span> <span>wolf</span><span>,</span> <span>dingo</span><span>,</span> <span>human</span> <span>};</span>
<span>};</span>

<span>var</span> <span>monsters</span><span>:</span> <span>ArrayList</span><span>(</span><span>Monster</span><span>)</span> <span>=</span> <span>.</span><span>{};</span>
<span>var</span> <span>i</span><span>:</span> <span>usize</span> <span>=</span> <span>0</span><span>;</span>
<span>while</span> <span>(</span><span>i</span> <span>&lt;</span> <span>10_000</span><span>)</span> <span>:</span> <span>(</span><span>i</span> <span>+=</span> <span>1</span><span>)</span> <span>{</span>
  <span>try</span> <span>monsters</span><span>.</span><span>append</span><span>(</span><span>.</span><span>{</span>
    <span>.</span><span>anim</span> <span>=</span> <span>getAnimation</span><span>(),</span>
    <span>.</span><span>kind</span> <span>=</span> <span>rng</span><span>.</span><span>enumValue</span><span>(</span><span>Monster</span><span>.</span><span>Kind</span><span>),</span>
  <span>});</span>
<span>}</span>
</code></pre></div></div>

<details>
  <summary>Actual Memory Use:</summary>
  <div><div><pre><code><span>Monster</span> <span>size</span><span>:</span> <span>16</span> <span>bytes</span> 
<span>ArrayList</span><span>(</span><span>Monster</span><span>)</span> <span>size</span><span>:</span> <span>24</span> <span>bytes</span>
<span>monsters</span> <span>size</span><span>:</span> <span>160_000</span> <span>bytes</span>        <span>// Total memory size of 10_000 monsters</span>
</code></pre></div>  </div>
</details>

<p>Do our formulas agree?</p>
<ol>
  <li><strong><code>Monster</code> Struct</strong>:
    <ul>
      <li>The fields of <code>Monster</code> satisfy $\texttt{@alignOf(anim)} = 8$ and $\texttt{@alignOf(kind)} = 1$. So, we expect the alignment of the struct to be $\texttt{@alignOf(Monster)} = 8$.</li>
      <li>No matter the ordering, it takes two memory chunks of size 8 bytes to fit these fields (since $\texttt{@sizeOf(anim)} = 8$ and $\texttt{@sizeOf(kind)} = 1$). So, we expect $\texttt{@sizeOf(Monster)} = 16$, exactly as we observed.</li>
    </ul>
  </li>
  <li><strong>ArrayList(Monster) Type</strong>: as a type, it takes a bit of overhead to specify <code>ArrayList(Monster)</code>, since an ArrayList is really a slice <code>[]Monster</code> plus a capacity (<code>usize</code>). On my 64-bit machine, that adds up to 24 bytes of memory.</li>
  <li><strong><code>monsters</code> ArrayList</strong>: remember, ArrayLists act like “arrays of structs”.
    <ul>
      <li>The natural size and alignment of the <code>Monster</code> struct dictate the layout of the <code>monsters</code> ArrayList.</li>
      <li>The size of an ArrayList in memory should equal its length times the size of each <code>Monster</code> element type. So, we expect <code>monsters</code> to take up $10,000 \times \texttt{@sizeOf(Monster)} = 160,000$ bytes, as observed.</li>
    </ul>
  </li>
</ol>

<hr/>
<p><strong>Footnotes</strong></p>



        
      </section>

      

      


      
  


    </div></div>
  </body>
</html>
