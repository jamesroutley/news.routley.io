<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://aschmelyun.com/blog/i-built-a-receipt-printer-for-github-issues/">Original</a>
    <h1>I built a receipt printer for GitHub issues</h1>
    
    <div id="readability-page-1" class="page"><div><p>I have a lot of <a href="https://github.com/aschmelyun?tab=repositories">side projects</a> on GitHub. Some of them are kind of popular, and I tend to get issues posted from time to time. The problem though is that usually they kind of get lost in the mix of my emails, or I forget to go through my repos and add new items to my todo list.</p>
<p>I&#39;ve been occasionally writing new issues down on sticky notes whenever I see a notification for an issue, but I always wanted an excuse to streamline the process a bit more. After seeing a receipt printer spitting out orders while grabbing some take-out the other day, I wondered if I could use one to print out a ticket each time an issue was added to one of my repos.</p>
<p>Spoiler alert, it worked!</p>
<blockquote><p lang="en" dir="ltr">So here&#39;s why I bought a receipt printer:</p>â€” Andrew Schmelyun (@aschmelyun) <a href="https://twitter.com/aschmelyun/status/1506960015063625733?ref_src=twsrc%5Etfw">March 24, 2022</a></blockquote>
<p>So let&#39;s dive in and I&#39;ll show you exactly what I used, and how I set it up!</p>
<h2>Hardware list</h2>
<p>In order to get started, I&#39;ll need a thermal receipt printer and some way to get data into it. I ended up using:</p>
<ul>
<li>Epson TM-T88IV</li>
<li>Raspberry Pi Zero W</li>
<li>Micro USB to USB adapter</li>
<li>USB Type-B cable</li>
</ul>
<p>The reason that I went with an Epson thermal printer is that they use the ESC/POS command set, for which there&#39;s <a href="https://github.com/search?q=esc%2Fpos">established libraries</a> in a variety of programming languages. Plus they&#39;re pretty ubiquitous in the second-hand market, and I was able to pick one up on Ebay along with some receipt paper for a pretty fair price.</p>
<p>The other piece I need is some kind of hardware to connect from the internet to the printer, and facilitate the actual data sending. I could just hook it up to my PC, but I want this to be a fully-contained unit that could just be constantly on idle sitting in a corner. I have an old <a href="https://www.raspberrypi.com/products/raspberry-pi-zero-w/">Raspberry Pi Zero W</a> laying around that I&#39;m not using, so I&#39;ll choose that. </p>
<p>Because the RPi Zero has just a single micro USB port, I&#39;ll use an adapter as well as a USB Type-B cable to connect it to the receipt printer.</p>
<h2>Sending data to the printer</h2>
<p>Alright, so we have the printer hooked up, the Raspberry Pi good to go, but now I need a way to send data <em>to</em> the printer <em>from</em> the Raspberry Pi. This could easily be accomplished with Node or Python, but since I&#39;m a PHP developer and I enjoy stretching the limitations of the language, I&#39;ll reach for that. Luckily for me, there&#39;s a <a href="https://github.com/mike42/escpos-php">pretty solid library</a> for working with ESC/POS commands available in PHP.</p>
<p>Before I write any code though, I have to make sure the printer is available to the program I create. Since I&#39;m using Ubuntu on the Raspberry Pi, I should be able to access it via <code>/dev/usb/lp0</code> (or another lp#). But it might require a little bit of prep work first.</p>
<p>First, I&#39;ll open up a terminal in the device that my printer is connected to (for me, that&#39;s the Raspberry Pi). I&#39;ll run the command <code>lsusb</code> to get the <em>Product ID</em> and <em>Vendor ID</em> from the connection to your printer. It returns something like this:</p>
<pre><code>Bus 002 Device 001: ID 04b2:0202 Epson TM-T888IV Device Details</code></pre>
<p>Next, I create a udev rule to let users belonging to the <strong>dialout</strong> group use the printer. I create the file <code>/etc/udev/rules.d/99-escpos.rules</code> and add the following to it:</p>
<pre><code>SUBSYSTEM==&#34;usb&#34;, ATTRS{idVendor}==&#34;04b2&#34;, ATTRS{idProduct}==&#34;0202&#34;, MODE=&#34;0664&#34;, GROUP=&#34;dialout&#34;</code></pre>
<p>Being sure to replace the hex values for the vendor and product ID&#39;s with what I got returned back from <code>lsusb</code>.</p>
<p>If my user(s) aren&#39;t part of the <em>dialout</em> group, I try to add them to it now:</p>
<pre><code>sudo usermod -a -G dialout pi &amp;&amp; sudo usermod -a -G dialout root</code></pre>
<p>And then finally, I have to restart udev:</p>
<pre><code>sudo service udev restart</code></pre>
<p>Now that I have the connection ready, I can start writing some code to test this out. First, I&#39;ll require that library from earlier with Composer:</p>
<pre><code>composer require mike42/escpos-php</code></pre>
<p>After that&#39;s installed, I need to write some code to send data to the printer. I&#39;ll create a file called <code>index.php</code>, and add the following:</p>
<pre><code>&lt;?php

require __DIR__ . &#39;/vendor/autoload.php&#39;;

use Mike42\Escpos\PrintConnectors\FilePrintConnector;
use Mike42\Escpos\Printer;

$connector = new FilePrintConnector(&#39;/dev/usb/lp0&#39;);
$printer = new Printer($connector);

$printer-&gt;text(&#39;Hello, world!&#39;);
$printer-&gt;feed(2);
$printer-&gt;cut();</code></pre>
<p>So now to run this, all I have to do is execute the script with PHP and root permissions:</p>
<pre><code>sudo php index.php</code></pre>
<p>If everything worked out fine, <strong>Hello, world!</strong> will have printed on a receipt, with two lines skipped, and then the receipt will have cut. How that all works is pretty straightforward.</p>
<p>A print connector is created to the &#39;file&#39; <code>/dev/usb/lp0</code>, which is the usb adapter that the printer is connected to. The printer commands that are subsequently used (<code>text()</code>, <code>feed()</code>, <code>cut()</code>), stream the raw commands associated with those actions to the printer through that connection.</p>
<blockquote>
<p><strong>Note</strong>: If you get an error about permissions when sending to <code>/dev/usb/lp0</code> or something similiar to that, try running <code>sudo chmod +777 /dev/usb/lp0</code> and seeing if that fixes it.</p>
</blockquote>
<p>Using these methods, I can move on to connecting this with GitHub and populating the receipts with some actual data.</p>
<h2>Connecting to GitHub</h2>
<p>GitHub makes it easy to listen to events on repos with <a href="https://docs.github.com/en/developers/webhooks-and-events/webhooks/about-webhooks">webhooks</a>. By going to one of my repo&#39;s settings page and navigating to the webhooks section, I can create a hook that will POST to a specific URL on a given action. For my case, I want to print out a ticket when a new issue is created, so I choose just the &#39;Issues&#39; section. I also set the data type as JSON, since that&#39;s what I enjoy working with.</p>
<p>But before I continue, I need to have a URL that GitHub could <em>send that POST request to</em>. First, I ssh back into the Raspberry Pi and start up the local PHP server by using the -S flag in my project&#39;s directory:</p>
<pre><code>sudo php -S 127.0.0.1:8000</code></pre>
<p>Now that it&#39;s running, I need a way to access that port on my Raspberry Pi, while it&#39;s on my local network. I don&#39;t really want to expose my home&#39;s IP address or worry about creating a pass through my router. So, I just ended up using <a href="https://ngrok.com/">ngrok</a> to tunnel through to the exposed port.</p>
<pre><code>ngrok http 8000</code></pre>
<p>After that loads up, I copy the provided https url, and paste it in the GitHub webhook url field. Everything looks good, and I save the webhook. As soon as I save, there should be a test request that&#39;s sent out, ngrok accepts the request, tunnels it to the local PHP server, and another <strong>Hello, world!</strong> will print out.</p>
<p>Now I&#39;m ready to actually use the incoming request from GitHub to build out a ticket.</p>
<h2>The final code</h2>
<p>Now I&#39;ll make some modifications to my code from earlier. First, I should discard anything that&#39;s not a POST request. So before initializing the FilePrintConnection, I add these lines:</p>
<pre><code>if ($_SERVER[&#39;REQUEST_METHOD&#39;] !== &#39;POST&#39;) {
    return &#39;Error: Expecting POST request&#39;;
}</code></pre>
<p>And after the FilePrintConnection and Printer initialization, I&#39;ll decode the entire JSON request from GitHub as an associative array:</p>
<pre><code>$data = json_decode(file_get_contents(&#39;php://input&#39;), true);</code></pre>
<p>Now, I can use the printer methods from before and the data array from GitHub to build up the receipt I want! Using the Escpos library, formatting text requires a <strong>lot</strong> of repetitive code. For a small example, here&#39;s what a bold and underlined title of the issue, along with the plain text body, looks like:</p>
<pre><code>$printer-&gt;setUnderline(true); // start underlined text
$printer-&gt;setEmphasis(true); // start bolded text
$printer-&gt;text($data[&#39;issue&#39;][&#39;title&#39;]);
$printer-&gt;setEmphasis(false); // stop bolded text
$printer-&gt;setUnderline(false); // stop underlined text

$printer-&gt;text($data[&#39;issue&#39;][&#39;body&#39;]);</code></pre>
<blockquote>
<p>If you&#39;d like to see the entire code that I used to format my ticket in the tweet above, you can check it out on the <a href="https://github.com/aschmelyun/github-receipts">GitHub repo</a>.</p>
</blockquote>
<p>Now to test it out, all I have to do is go to the repository where I set up my webhook, create a new issue, and wait for the printer to deliver a ticket :magic:.</p>
<h2>Wrapping up and next steps</h2>
<p>Alright, so where to go from here? This is definitely a simple proof of concept, but we can <strong>expand on it</strong> a few different ways.</p>
<p>For the tickets themselves, a QR code could be added to link directly to the issue on GitHub. You could also add in more details from the issue itself like tags and severity.</p>
<p>You could also use this concept to handle basically any data coming from a webhook or through an API request. Like printing tickets from apps like Jira or Bugsnag, exceptions thrown from production applications, or even daily todo items and grocery lists!</p>
<p>So, what do you think? If you have any ideas for how you&#39;d improve on this setup, or just have a question or comment, please let me know in the discussion below or on my <a href="https://twitter.com/aschmelyun">Twitter</a>!</p>
</div></div>
  </body>
</html>
