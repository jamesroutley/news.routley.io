<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://chadaustin.me/2024/01/truecolor-terminal-emacs/">Original</a>
    <h1>I just wanted Emacs to look nice – Using 24-bit color in terminals</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
    <p>Thanks to some coworkers and David Wilson’s <a href="https://www.youtube.com/watch?v=74zOY-vgkyw&amp;list=PLEoMzSkcN8oPH1au7H6B7bBJ4ZO7BXjSZ">Emacs from Scratch
playlist</a>,
I’ve been getting back into Emacs. The community is more vibrant than
the last time I looked, and
<a href="https://microsoft.github.io/language-server-protocol/">LSP</a> brings
modern completion and inline type checking.</p>

<p>David’s Emacs looks so fancy — I want nice colors and fonts
too, especially my preferred themes like
<a href="https://ethanschoonover.com/solarized/">Solarized</a>.</p>

<p>From desktop environments, Emacs automatically supports 24-bit color.</p>

<figure>
<a href="https://chadaustin.me/images/truecolor-terminal-emacs/emacs-window.png"><img src="https://chadaustin.me/images/truecolor-terminal-emacs/emacs-window.png" alt="Graphical Emacs: Fonts and Colors"/></a>
<figcaption>Graphical Emacs: Fonts and Colors</figcaption>
</figure>

<p>But, since I work on infrastructure, I’ve lived primarily in terminals
for years. And my Emacs looks like:</p>

<figure>
<a href="https://chadaustin.me/images/truecolor-terminal-emacs/emacs-terminal.png"><img src="https://chadaustin.me/images/truecolor-terminal-emacs/emacs-terminal.png" alt="Terminal Emacs: Not Fancy"/></a>
<figcaption>Terminal Emacs: Not Fancy</figcaption>
</figure>

<p>It turns out, for <em>years</em>, <a href="https://github.com/termstandard/colors#truecolor-support-in-output-devices">popular terminals have supported 24-bit
color</a>.
And yet they’re rarely used.</p>

<p>Like everything else, it boil down to legacy and politics. Control
codes are a protocol, and changes to that protocol take time to
propagate, especially with missteps along the way.</p>

<p>This post is two things:</p>
<ol>
  <li>how to enable true-color support in the terminal environments I
use, and</li>
  <li>how my desire for nice colors in Emacs led to poring over technical
standards from the 70s, 80s, and 90s, wondering how we got to this
point.</li>
</ol>

<blockquote>
  <p><strong><em>NOTE:</em></strong> I did my best, but please forgive any terminology
slip-ups or false histories. I grew up on VGA text mode UIs, but
never used a hardware terminal and wasn’t introduced to unix until
much later.</p>
</blockquote>

<h2 id="ansi-escape-codes">ANSI Escape Codes</h2>

<p>Early hardware terminals offered their own, incompatible, control code
schemes. That made writing portable software hard, so ANSI
standardized the protocol, while reserving room for expansion and
vendor-specific capabilities.</p>

<figure>
<a href="https://chadaustin.me/images/truecolor-terminal-emacs/dec-vt100.webp"><img src="https://chadaustin.me/images/truecolor-terminal-emacs/dec-vt100.webp" alt="DEC
VT100 (1978)"/></a>
<figcaption>DEC
VT100 (1978)</figcaption>
</figure>

<p><a href="https://en.wikipedia.org/wiki/ANSI_escape_code">ANSI escape codes</a>
date back to the 70s. They cover a huge range of functionality, but
since this post is focused on colors, I’m mostly interested in SGR
(Select Graphics Rendition), which allows configuring a variety of
character display attributes:</p>

<ul>
  <li>bold or intensity</li>
  <li>italics (not frequently supported)</li>
  <li>blink</li>
  <li>foreground and background colors</li>
  <li>and a bunch of other stuff. You can look at Wikipedia.</li>
</ul>

<h2 id="3--4--and-8-bit-color">3-, 4-, and 8-bit Color</h2>

<p>When color was introduced, there were eight. Black, white, the
additive primaries, and the subtractive primaries. The eight corners
of an RGB color cube.</p>

<p>Later, a bright (or bold) bit added eight more; “bright black” being
dark gray.</p>

<figure>
<a href="https://chadaustin.me/images/truecolor-terminal-emacs/microsoft-vga.png"><img src="https://chadaustin.me/images/truecolor-terminal-emacs/microsoft-vga.png" alt="4-Bit VGA Text Mode Palette"/></a>
<figcaption>4-Bit VGA Text Mode Palette</figcaption>
</figure>

<p>In 1999, <a href="https://invisible-island.net/xterm/xterm.log.html#xterm_111">Todd Larason patched xterm to add support for 256
colors</a>.
He chose a palette that filled out the RGB color cube with a 6x6x6
interior sampling and added a 24-entry finer-precision grayscale ramp.</p>

<figure>
<a href="https://chadaustin.me/images/truecolor-terminal-emacs/xterm-256color.png"><img src="https://chadaustin.me/images/truecolor-terminal-emacs/xterm-256color.png" alt="Output From colortest-256"/></a>
<figcaption>Output From colortest-256</figcaption>
</figure>

<blockquote>
  <p><strong><em>NOTE:</em></strong> There’s a rare, but still-supported, 88-color variant
with a 4x4x4 color cube and 8-entry grayscale ramp, primarily to
reduce the use of historically-limited X11 color objects.</p>
</blockquote>

<blockquote>
  <p><strong><em>NOTE:</em></strong> We’ll debug this later, but Todd’s patch to add
256-color support to xterm used semicolons as the separator between
the ANSI SGR command 48 and the color index, which set off a chain
reaction of ambiguity we’re still dealing with today.</p>
</blockquote>

<h2 id="where-did-24-bit-color-support-come-from">Where Did 24-Bit Color Support Come From?</h2>

<p>It’s well-documented how to send 8-bit and 24-bit colors to compatible
terminals. Per
<a href="https://en.wikipedia.org/wiki/ANSI_escape_code#8-bit">Wikipedia</a>:</p>

<p><code>ESC[38;5;&lt;n&gt;m</code> sets foreground color <code>n</code> per the palettes above.</p>

<p><code>ESC[38;2;&lt;r&gt;;&lt;g&gt;;&lt;b&gt;m</code> sets foreground color (<code>r</code>, <code>g</code>, <code>b</code>).</p>

<p>(Again, that confusion about <a href="https://wezfurlong.org/wezterm/escape-sequences.html#graphic-rendition-sgr">semicolons vs.
colons</a>,
and an unused colorspace ID if colons are used. We’ll get to the
bottom of that soon.)</p>

<p>But why 5? Why 2? How did any of this come about? I’d struggled enough
with unexpected output that it was time to discover the ground truth.</p>

<p>Finding and reading original sources led me to construct the following
narrative:</p>

<ul>
  <li>In the 70s, ANSI standardized terminal escape sequences, resulting
in <a href="https://nvlpubs.nist.gov/nistpubs/Legacy/FIPS/fipspub86.pdf">ANSI
X3.64</a>
and the better-known
<a href="https://www.ecma-international.org/wp-content/uploads/ECMA-48_5th_edition_june_1991.pdf">ECMA-48</a>.</li>
  <li>The first edition of ECMA-48 is lost to time, but it probably looks
much like ANSI X3.64.</li>
  <li>The <a href="https://ecma-international.org/wp-content/uploads/ECMA-48_2nd_edition_august_1979.pdf">2nd
edition</a>
of ECMA-48 (1979) allocated SGR parameters 30-37 and 40-47 for setting
3-bit foreground and background colors, respectively.
    <ul>
      <li>By the way, these standards use the word “parameter” to mean
command, and “subparameter” to mean argument, if applicable.</li>
    </ul>
  </li>
  <li>The <a href="https://ecma-international.org/wp-content/uploads/ECMA-48_3rd_edition_march_1984.pdf">3rd
edition</a>
(1984) introduced the concept of an implementation-defined default
color for both foreground and background, and allocated parameters
39 and 49, respectively.</li>
  <li>Somewhere in this timeline, vendors did ship hardware terminals with
richer color support. The <a href="https://terminals-wiki.org/wiki/index.php/Wyse_WY-370">Wyse
WY-370</a>
introduced new color modes, including a direct-indexed 64-color
palette. (See Page 86 of its <a href="http://bitsavers.org/pdf/wyse/WY-370/881133-02A_WY-370_Programmers_Guide_Jun90.pdf">Programmer’s
Guide</a>.)</li>
  <li>38 and 48 are the most important parameters for selecting colors
today, but they weren’t allocated by either the
<a href="https://ecma-international.org/wp-content/uploads/ECMA-48_4th_edition_december_1986.pdf">4th</a>
(1986) or
<a href="https://www.ecma-international.org/wp-content/uploads/ECMA-48_5th_edition_june_1991.pdf">5th</a>
(1991) editions. So where did they come from? The 5th edition gives
a clue:
    <blockquote>
      <p>reserved for future standardization; intended for setting
character foreground colour as specified in ISO 8613-6 [CCITT
Recommendation T.416]</p>
    </blockquote>
  </li>
  <li>
    <p>ISO 8613 was a boondoggle of a project intended to <a href="https://en.wikipedia.org/wiki/Open_Document_Architecture">standardize and
replace all proprietary document file
formats</a>.
You’ve never heard of it, so it obviously failed. But its legacy
lives on – ISO 8613-6 (ITU T.416) (1993) built on ECMA-48’s codes
and defined parameters 38 and 48 as extended foreground and
background color modes, respectively.</p>

    <blockquote>
      <p>The first parameter element indicates a choice between:</p>
      <ul>
        <li>0 implementation defined (only applicable for the character foreground colour)</li>
        <li>1 transparent;</li>
        <li>2 direct colour in RGB space;</li>
        <li>3 direct colour in CMY space;</li>
        <li>4 direct colour in CMYK space;</li>
        <li>5 indexed colour.</li>
      </ul>
    </blockquote>
  </li>
</ul>

<p>There we go! <em>That</em> is why 5 is used for 256-color mode and 2 is
24-bit RGB.</p>

<p>Careful reading also gives a clue as to the semicolon vs. colon syntax
screw-up. Note the subtle use of the term “parameter element” vs.
“parameter”.</p>

<p>If you read ISO 8613-6 (ITU T.416) and ECMA-48 closely, it’s not
explicitly stated, but they seem to indicate that unknown parameters
for commands like “select graphics rendition” should be ignored. And
parameters are separated with semicolons.</p>

<p>That implies <code>ESC[38;5;3m</code> should be interpreted, in terminals that
don’t support SGR 38, as “unknown, ignored (38)”, “blinking (5)”, and
“italicized (3)”. The syntax should use colons to separate
sub-parameter components, but something got lost along the way.</p>

<p>(Now, in practice, programs are told how to communicate with their
terminals via the TERM variable and the terminfo database, so I
don’t know how much pain occurs in reality.)</p>

<p>Thomas Dickey has done a great job documenting the history of
<a href="https://invisible-island.net/ncurses/">ncurses</a> and
<a href="https://invisible-island.net/xterm/xterm.log.html">xterm</a>, and, lo
and behold, explains exactly the <a href="https://invisible-island.net/xterm/xterm.faq.html#semicolon_vs_colon">origin of the ambiguous
syntax</a>:</p>

<blockquote>
  <p>We used semicolon (like other SGR parameters) for separating the
R/G/B values in the escape sequence, since a copy of ITU T.416
(ISO-8613-6) which presumably clarified the use of colon for this
feature was costly.</p>

  <p>Using semicolon was incorrect because some applications could expect
their parameters to be order-independent. As used for the R/G/B
values, that was order-dependent. The relevant information, by the
way, is part of ECMA-48 (not ITU T.416, as mentioned in Why only 16
(or 256) colors?). Quoting from section 5.4.2 of ECMA-48, page 12,
and adding emphasis (not in the standard):</p>

  <blockquote>
    <p>Each parameter sub-string consists of one or more bit combinations
from 03/00 to 03/10; the bit combinations from 03/00 to 03/09
represent the digits ZERO to NINE; bit combination 03/10 may be
used as a separator in a parameter sub-string, for example, to
separate the fractional part of a decimal number from the integer
part of that number.</p>
  </blockquote>

  <p>and later on page 78, in 8.3.117 SGR – SELECT GRAPHIC RENDITION, the
description of SGR 38:</p>

  <blockquote>
    <p>(reserved for future standardization; intended for setting
character foreground colour as specified in ISO 8613-6 [CCITT
Recommendation T.416])</p>
  </blockquote>

  <p>Of course you will immediately recognize that 03/10 is ASCII colon,
and that ISO 8613-6 necessarily refers to the encoding in a
parameter sub-string. Or perhaps you will not.</p>
</blockquote>

<p>So it’s all because the ANSI and ISO standards are ridiculously
expensive (to this day, these crappy PDF scans from the 90s and
earlier are $200 USD!) and because they use a baroque syntax to denote
ASCII characters. While writing this post, I had to keep <code>man ascii</code>
open to match, for example, <code>03/10</code> to colon and <code>03/11</code> to semicolon.
I guess it’s how standards were written back then. A Hacker News
thread in the context of WezTerm <a href="https://news.ycombinator.com/item?id=35138390">gives more
detail</a>.</p>

<p>So, to recap in the timeline:</p>

<ul>
  <li>1999: <a href="https://invisible-island.net/xterm/xterm.log.html#xterm_111">Thomas Dickey merged Todd Larason’s 256-color
patches</a>
with ambiguous semicolon syntax.</li>
  <li>2006: Konsole added support for 256-color and 24-bit truecolor using
the same ambiguous syntax as xterm, with a <a href="https://bugs.kde.org/show_bug.cgi?id=107487">follow-on
discussion</a> about
colons vs. semicolons. The issue was noticed, but semicolon syntax
was adopted anyway.</li>
  <li>2012: Thomas Dickey <a href="https://invisible-island.net/xterm/xterm.log.html#xterm_282">fixed xterm to accept the standards-compliant
syntax</a>.</li>
  <li>2016: Windows 10’s built-in console gained <a href="https://devblogs.microsoft.com/commandline/24-bit-color-in-the-windows-console/">ANSI escape code
support, including 24-bit
colors</a>.
Unfortunately with the ambiguous semicolon syntax.</li>
  <li>2019: Windows Terminal is released, with ANSI escape code support,
but also using ambiguous semicolon syntax.</li>
  <li>2022: Microsoft announced <a href="https://learn.microsoft.com/en-us/windows/console/ecosystem-roadmap">ecosystem-wide
migration</a>
from the legacy framebuffer-based VGA-style console subsystem to
ANSI terminal emulation, specifically using xterm as a guide.</li>
  <li>2022: Konsole <a href="https://github.com/KDE/konsole/commit/316a386d92a083e235624e9f81df3b6dbbe08bff">gains support for standards-compliant
syntax</a>.</li>
</ul>

<p>Okay, here’s what we’ve established:</p>

<ul>
  <li>ANSI codes are widely supported, even on Windows.</li>
  <li>Truecolor support is either widely supported or (for example, on the
Linux text mode terminal) at least recognized and mapped to a more
limited palette.</li>
  <li>Semicolon syntax is the most compatible, though the unambiguous
colon syntax is slowly spreading.</li>
</ul>

<p>I wrote a <a href="https://gist.github.com/chadaustin/2d2c2cb4b71fd1d4163aa8115077624a">small colortest.rs program to test color support and attributes like
reverse and
italics</a>
to confirm the above in every terminal I use.</p>

<h2 id="terminfo">Terminfo</h2>

<p>Now that we’ve established terminal capabilities and how to use them,
the next trick is to convince software of varying lineages to detect
and use the best color support available.</p>

<p>Typically, this is done with the old
<a href="https://en.wikipedia.org/wiki/Terminfo">terminfo</a> library (or the
even older <a href="https://en.wikipedia.org/wiki/Termcap">termcap</a>).</p>

<p>Terminfo provides a database of terminal capabilities and the ability
to generate appropriate escape sequences. The TERM environment
variable tells programs which terminfo record to use. Its value is
automatically forwarded over <code>ssh</code> connections.</p>

<p>Terminfo uses ridiculous command names: <code>infocmp</code>, <code>tic</code>, <code>toe</code>. (Not
to be confused with the unrelated <code>tac</code>.)</p>

<p>To see the list of terminfo records installed on your host, run <code>toe
-a</code>. (Do we /really/ need to install support for every legacy hardware
terminal on modern machines? Good luck even finding a hardware
terminal these days. They’re collector’s items.)</p>

<p><code>infocmp</code> is how you inspect the capabilities of a specific terminfo
record.</p>

<div><div><pre><code>$ infocmp xterm-256color
#       Reconstructed via infocmp from file: /lib/terminfo/x/xterm-256color
xterm-256color|xterm with 256 colors,
        am, bce, ccc, km, mc5i, mir, msgr, npc, xenl,
        colors#0x100, cols#80, it#8, lines#24, pairs#0x10000,
        acsc=``aaffggiijjkkllmmnnooppqqrrssttuuvvwwxxyyzz{{||}}~~,
        bel=^G, blink=\E[5m, bold=\E[1m, cbt=\E[Z, civis=\E[?25l,
        clear=\E[H\E[2J, cnorm=\E[?12l\E[?25h, cr=\r,
        csr=\E[%i%p1%d;%p2%dr, cub=\E[%p1%dD, cub1=^H,
        cud=\E[%p1%dB, cud1=\n, cuf=\E[%p1%dC, cuf1=\E[C,
        cup=\E[%i%p1%d;%p2%dH, cuu=\E[%p1%dA, cuu1=\E[A,
        cvvis=\E[?12;25h, dch=\E[%p1%dP, dch1=\E[P, dim=\E[2m,
        dl=\E[%p1%dM, dl1=\E[M, ech=\E[%p1%dX, ed=\E[J, el=\E[K,
        el1=\E[1K, flash=\E[?5h$&lt;100/&gt;\E[?5l, home=\E[H,
        hpa=\E[%i%p1%dG, ht=^I, hts=\EH, ich=\E[%p1%d@,
        il=\E[%p1%dL, il1=\E[L, ind=\n, indn=\E[%p1%dS,
        initc=\E]4;%p1%d;rgb:%p2%{255}%*%{1000}%/%2.2X/%p3%{255}%*%{1000}%/%2.2X/%p4%{255}%*%{1000}%/%2.2X\E\\,
        invis=\E[8m, is2=\E[!p\E[?3;4l\E[4l\E&gt;, kDC=\E[3;2~,
        kEND=\E[1;2F, kHOM=\E[1;2H, kIC=\E[2;2~, kLFT=\E[1;2D,
        kNXT=\E[6;2~, kPRV=\E[5;2~, kRIT=\E[1;2C, ka1=\EOw,
        ka3=\EOy, kb2=\EOu, kbeg=\EOE, kbs=^?, kc1=\EOq, kc3=\EOs,
        kcbt=\E[Z, kcub1=\EOD, kcud1=\EOB, kcuf1=\EOC, kcuu1=\EOA,
        kdch1=\E[3~, kend=\EOF, kent=\EOM, kf1=\EOP, kf10=\E[21~,
        kf11=\E[23~, kf12=\E[24~, kf13=\E[1;2P, kf14=\E[1;2Q,
        kf15=\E[1;2R, kf16=\E[1;2S, kf17=\E[15;2~, kf18=\E[17;2~,
        kf19=\E[18;2~, kf2=\EOQ, kf20=\E[19;2~, kf21=\E[20;2~,
        kf22=\E[21;2~, kf23=\E[23;2~, kf24=\E[24;2~,
        kf25=\E[1;5P, kf26=\E[1;5Q, kf27=\E[1;5R, kf28=\E[1;5S,
        kf29=\E[15;5~, kf3=\EOR, kf30=\E[17;5~, kf31=\E[18;5~,
        kf32=\E[19;5~, kf33=\E[20;5~, kf34=\E[21;5~,
        kf35=\E[23;5~, kf36=\E[24;5~, kf37=\E[1;6P, kf38=\E[1;6Q,
        kf39=\E[1;6R, kf4=\EOS, kf40=\E[1;6S, kf41=\E[15;6~,
        kf42=\E[17;6~, kf43=\E[18;6~, kf44=\E[19;6~,
        kf45=\E[20;6~, kf46=\E[21;6~, kf47=\E[23;6~,
        kf48=\E[24;6~, kf49=\E[1;3P, kf5=\E[15~, kf50=\E[1;3Q,
        kf51=\E[1;3R, kf52=\E[1;3S, kf53=\E[15;3~, kf54=\E[17;3~,
        kf55=\E[18;3~, kf56=\E[19;3~, kf57=\E[20;3~,
        kf58=\E[21;3~, kf59=\E[23;3~, kf6=\E[17~, kf60=\E[24;3~,
        kf61=\E[1;4P, kf62=\E[1;4Q, kf63=\E[1;4R, kf7=\E[18~,
        kf8=\E[19~, kf9=\E[20~, khome=\EOH, kich1=\E[2~,
        kind=\E[1;2B, kmous=\E[&lt;, knp=\E[6~, kpp=\E[5~,
        kri=\E[1;2A, mc0=\E[i, mc4=\E[4i, mc5=\E[5i, meml=\El,
        memu=\Em, mgc=\E[?69l, nel=\EE, oc=\E]104\007,
        op=\E[39;49m, rc=\E8, rep=%p1%c\E[%p2%{1}%-%db,
        rev=\E[7m, ri=\EM, rin=\E[%p1%dT, ritm=\E[23m, rmacs=\E(B,
        rmam=\E[?7l, rmcup=\E[?1049l\E[23;0;0t, rmir=\E[4l,
        rmkx=\E[?1l\E&gt;, rmm=\E[?1034l, rmso=\E[27m, rmul=\E[24m,
        rs1=\Ec\E]104\007, rs2=\E[!p\E[?3;4l\E[4l\E&gt;, sc=\E7,
        setab=\E[%?%p1%{8}%&lt;%t4%p1%d%e%p1%{16}%&lt;%t10%p1%{8}%-%d%e48;5;%p1%d%;m,
        setaf=\E[%?%p1%{8}%&lt;%t3%p1%d%e%p1%{16}%&lt;%t9%p1%{8}%-%d%e38;5;%p1%d%;m,
        sgr=%?%p9%t\E(0%e\E(B%;\E[0%?%p6%t;1%;%?%p5%t;2%;%?%p2%t;4%;%?%p1%p3%|%t;7%;%?%p4%t;5%;%?%p7%t;8%;m,
        sgr0=\E(B\E[m, sitm=\E[3m, smacs=\E(0, smam=\E[?7h,
        smcup=\E[?1049h\E[22;0;0t, smglp=\E[?69h\E[%i%p1%ds,
        smglr=\E[?69h\E[%i%p1%d;%p2%ds,
        smgrp=\E[?69h\E[%i;%p1%ds, smir=\E[4h, smkx=\E[?1h\E=,
        smm=\E[?1034h, smso=\E[7m, smul=\E[4m, tbc=\E[3g,
        u6=\E[%i%d;%dR, u7=\E[6n, u8=\E[?%[;0123456789]c,
        u9=\E[c, vpa=\E[%i%p1%dd,
</code></pre></div></div>

<p>There’s so much junk in there. I wonder how much only applies to
non-ANSI hardware terminals, and therefore is irrelevant these days.</p>

<p>For now, we’re only interested in three of these capabilities:</p>
<ul>
  <li><code>colors</code> is how many colors this terminal supports. The standard
values are 0, 8, 16, 256, and 0x1000000 (24-bit), though other
values exist.</li>
  <li><code>setaf</code> and <code>setab</code> set foreground and background colors,
respectively. I believe they stand for “Set ANSI Foreground” and
“Set ANSI Background”. Each takes a single argument, the color
number.</li>
</ul>

<p>Those percent signs are a parameter arithmetic and substitution
language. Let’s decode <code>setaf</code> in particular:</p>

<div><div><pre><code>setaf=\E[%?%p1%{8}%&lt;%t3%p1%d%e%p1%{16}%&lt;%t9%p1%{8}%-%d%e38;5;%p1%d%;m
</code></pre></div></div>

<div><div><pre><code>print &#34;\E[&#34;
if p1 &lt; 8 {
  print &#34;3&#34; p1
} else if p1 &lt; 16 {
  print &#34;9&#34; (p1 - 8)
} else {
  print &#34;38;5;&#34; p1
}
print &#34;m&#34;
</code></pre></div></div>

<p>This is the <code>xterm-256color</code> terminfo description. It only knows how
to output the ANSI 30-37 SGR parameters, the non-standard 90-97
brights (from IBM AIX), or otherwise the 256-entry palette, using
ambiguous semicolon-delimited syntax.</p>

<p>Let’s compare with <code>xterm-direct</code>, the terminfo entry that supports
RGB.</p>

<div><div><pre><code>$ infocmp xterm-256color xterm-direct
comparing xterm-256color to xterm-direct.
    comparing booleans.
        ccc: T:F.
    comparing numbers.
        colors: 256, 16777216.
    comparing strings.
        initc: &#39;\E]4;%p1%d;rgb:%p2%{255}%*%{1000}%/%2.2X/%p3%{255}%*%{1000}%/%2.2X/%p4%{255}%*%{1000}%/%2.2X\E\\&#39;, NULL.
        oc: &#39;\E]104\007&#39;, NULL.
        rs1: &#39;\Ec\E]104\007&#39;, &#39;\Ec&#39;.
        setab: &#39;\E[%?%p1%{8}%&lt;%t4%p1%d%e%p1%{16}%&lt;%t10%p1%{8}%-%d%e48;5;%p1%d%;m&#39;, &#39;\E[%?%p1%{8}%&lt;%t4%p1%d%e48:2::%p1%{65536}%/%d:%p1%{256}%/%{255}%&amp;%d:%p1%{255}%&amp;%d%;m&#39;.
        setaf: &#39;\E[%?%p1%{8}%&lt;%t3%p1%d%e%p1%{16}%&lt;%t9%p1%{8}%-%d%e38;5;%p1%d%;m&#39;, &#39;\E[%?%p1%{8}%&lt;%t3%p1%d%e38:2::%p1%{65536}%/%d:%p1%{256}%/%{255}%&amp;%d:%p1%{255}%&amp;%d%;m&#39;.
</code></pre></div></div>

<p>A few things are notable:</p>

<ul>
  <li><code>xterm-direct</code> advertises 16.7 million colors, as expected.</li>
  <li><code>xterm-direct</code> unsets the <code>ccc</code> boolean, which indicates color
indices cannot have new RGB values assigned.</li>
  <li>Correspondingly, xterm-direct unsets <code>initc</code>, <code>oc</code>, and <code>rs1</code>, also
related to changing color values at runtime.</li>
  <li>And of course <code>setaf</code> and <code>setab</code> change. We’ll decode that next.</li>
</ul>

<p>Here’s where Terminfo’s limitations cause us trouble. Terminfo and
ncurses are tied at the hip. Their programming model is that there are
N palette entries, each of which has a default RGB value, and
terminals may support overriding any palette entry’s RGB value.</p>

<p>The <code>-direct</code> terminals, however, are different. They represent 24-bit
colors by pretending there are 16.7 million palette entries, each of
which maps to the 8:8:8 RGB cube, but whose values cannot be changed.</p>

<p>Now let’s look at the new <code>setaf</code>:</p>

<div><div><pre><code>print &#34;\E[&#34;
if p1 &lt; 8 {
  print &#34;3&#34; p1
} else {
  print &#34;38:2::&#34; (p1 / 65536) &#34;:&#34; ((p1 / 256) &amp; 255) &#34;:&#34; (p1 &amp; 255)
}
print &#34;m&#34;
</code></pre></div></div>

<p>It’s not <em>quite</em> as simple as direct RGB. For compatibility with
programs that assume the meaning of <code>setaf</code>, this scheme steals the
darkest 7 blues, not including black, and uses them for compatibility
with the basic ANSI 8 colors. Otherwise, there’s a risk of legacy
programs outputting barely-visible dark blues instead of the ANSI
colors they expect.</p>

<p>One consequence is that the <code>-direct</code> schemes are incompatible with
the <code>-256color</code> schemes, so programs must be aware that 256 colors
means indexed and 16.7 million means direct, except that the darkest 7
blues are to be avoided.</p>

<p>Fundamentally, terminfo has no notion of color space. So a program
that was written before terminfo even supported more colors than 256
might (validly!) assume the values of the first 8, 16, or even 256
palette entries.</p>

<p>This explains an issue with the Rust crate
<a href="https://docs.rs/termwiz/latest/termwiz/">termwiz</a> that I <a href="https://github.com/wez/wezterm/issues/4528">recently
ran into</a> at work. A
<a href="https://sapling-scm.com/">program</a> expected to output colors in the
xterm-256color palette, but was actually generating various
illegibly-dark shades of blue. (Note: Despite the fact that the issue
is open as of this writing, @quark-zju landed a fix, so current
termwiz behaves reasonably.)</p>

<p>This is a terminfo restriction, not a terminal restriction. As far as
I know, every terminal that supports 24-bit color also supports the
xterm 256-color palette and even dynamically changing their RGB
values. (You can even <a href="https://gist.github.com/chadaustin/7046bff2261b0f669d223a88ecad8282">animate the
palette</a>
like <a href="https://www.youtube.com/watch?v=aMcJ1Jvtef0">The Secret of Monkey Island
did</a>!) While I appreciate
Thomas Dickey’s dedication to accurately documenting history and
preserving compatibility, terminfo simply isn’t great at accurate and
timely descriptions of today’s vibrant ecosystem of terminal
emulators.</p>

<p>Kovid Goyal, author of <a href="https://sw.kovidgoyal.net/kitty/">kitty</a>,
<a href="https://github.com/kovidgoyal/kitty/issues/4172#issuecomment-955190343">expresses his
frustration</a>:</p>

<blockquote>
  <p>To summarize, one cannot have both 256 and direct color support in
one terminfo file.</p>

  <p>Frustrated users of the ncurses library have only themselves to
blame, for choosing to use such a bad library.</p>
</blockquote>

<p>A deeper, more accurate discussion of the challenges are documented in
<a href="https://github.com/kovidgoyal/kitty/issues/879">kitty issue #879</a>.</p>

<p>In an ideal world, terminfo would have introduced a brand new
capability for 24-bit RGB, leaving the adjustable 256-color palette in
place.</p>

<p>Modern programs should probably disregard most of terminfo and assume
that 16.7 million colors implies support for the rest of the color
capabilities. And maybe generate their own ANSI-compatible escape
sequences… except for the next wrinkle.</p>

<h2 id="setting-term-semicolons-again">Setting TERM: Semicolons Again!</h2>

<p>Gripes about terminfo aside, everyone uses it, so we do need to ensure
TERM is set correctly.</p>

<p>While I’d like to standardize on the colon-based SGR syntax, several
terminals I use only support semicolons:</p>

<ul>
  <li><a href="https://learn.microsoft.com/en-us/windows/console/definitions#console-host">Conhost</a>,
Windows’s built-in console.</li>
  <li><a href="https://github.com/mintty/mintty/wiki/Changelog#370-14-november-2023">Mintty</a>
<a href="https://github.com/mintty/mintty/wiki/Changelog#370-14-november-2023">claims to
work</a>
(and <a href="https://github.com/mintty/wsltty">wsltty</a> does), but for some
reason running <a href="https://gist.github.com/chadaustin/2d2c2cb4b71fd1d4163aa8115077624a">my colortest.rs
program</a>
from Cygwin only works with semicolon syntax, unless I pipe the
output through <code>cat</code> or a file. There must be some kind of magic
translation happening under the hood. I haven’t debugged.</li>
  <li><a href="https://mosh.org/">Mosh</a> is aware, but hasn’t <a href="https://github.com/mobile-shell/mosh/issues/951">added
support</a>.</li>
  <li><a href="https://www.chiark.greenend.org.uk/~sgtatham/putty/">PuTTY</a>.</li>
  <li>Ubuntu 22.04 LTS ships a version of Konsole that only supports
semicolons.</li>
</ul>

<p>Terminfo entries are built from “building blocks”, marked with a plus.
<a href="https://invisible-island.net/ncurses/terminfo.src.html#tic-xterm_direct"><code>xterm+direct</code></a>
is the building block for the standard colon-delimited syntax.
<a href="https://invisible-island.net/ncurses/terminfo.src.html#tic-xterm_indirect"><code>xterm+indirect</code></a>
is the building block for legacy terminals that only support semicolon
syntax.</p>

<p>Searching for <code>xterm+indirect</code> shows which terminfo entries might work
for me. <code>vscode-direct</code> looks the most accurate. I assume that, since
it targets a Microsoft terminal, it’s probably close enough in
functionality to Windows Terminal and Windows Console. I have not
audited all capabilities, but it seems to work.</p>

<p>The next issue was that none of my servers had the <code>-direct</code> terminfo
entries installed! On most systems, the terminfo database comes from
the
<a href="https://packages.ubuntu.com/jammy/all/ncurses-base/filelist"><code>ncurses-base</code></a>
package, but you need
<a href="https://packages.ubuntu.com/jammy/all/ncurses-term/filelist"><code>ncurses-term</code></a>
for the extended set of terminals.</p>

<p>At work, we can configure a default set of installed packages for your
hosts, but I have to install them manually on my unmanaged personal
home machines. Also, I was still running Ubuntu 18, so I had to
upgrade to a version that contained the <code>-direct</code> terminfo entries.
(Of course, two of my headless machines failed to boot after
upgrading, but that’s a different story.)</p>

<p><del>Unfortunately, there is no terminfo entry for the Windows console.</del>
Since I started writing this post, ncurses introduced a
<a href="https://invisible-island.net/ncurses/NEWS.html#index-t20231230">winconsole</a>
terminfo entry, but it neither supports 24-bit color nor is released
in any ncurses version.</p>

<h2 id="configuring-emacs">Configuring Emacs</h2>

<p>Emacs documents <a href="https://www.gnu.org/software/emacs/manual/html_node/efaq/Colors-on-a-TTY.html">how it detects truecolor
support</a>.</p>

<p>I find it helpful to <code>M-x eval-expression</code> <code>(display-color-cells)</code> to
confirm whether Emacs sees 16.7 million colors.</p>

<p>Emacs also documents the <code>-direct</code> mode terminfo limitation described
above:</p>

<blockquote>
  <p>Terminals with ‘RGB’ capability treat pixels #000001 - #000007 as
indexed colors to maintain backward compatibility with applications
that are unaware of direct color mode. Therefore the seven darkest
blue shades may not be available. If this is a problem, you can
always use custom terminal definition with ‘setb24’ and ‘setf24’.</p>
</blockquote>

<p>It’s worth noting that <code>RGB</code> is Emacs’s fallback capability. Emacs
looks for the <code>setf24</code> and <code>setb24</code> strings first, but no terminfo
entries on my machine contain those capabilities:</p>

<div><div><pre><code>$ for t in $(toe -a | cut -f1); do
    if (infocmp &#34;$t&#34; | grep &#39;setf24&#39;) &gt; /dev/null; then
      echo &#34;$t&#34;;
    fi;
done
$
</code></pre></div></div>

<h2 id="nesting-terminals">Nesting Terminals</h2>

<div><div><pre><code>conhost.exe (WSL1)
+-------------------------+
| mosh                    |
| +---------------------+ |
| | tmux                | |
| | +-----------------+ | |
| | | emacs terminal  | | |
| | | +-------------+ | | |
| | | | $ ls        | | | |
| | | | foo bar baz | | | |
| | | +-------------+ | | |
| | +-----------------+ | |
| +---------------------+ |
+-------------------------+
</code></pre></div></div>

<p>I’d never consciously considered this, but my typical workflow nests
multiple terminals.</p>
<ul>
  <li>I open a graphical terminal emulator on my local desktop, Windows,
Mac, or Linux.</li>
  <li>I mosh to a remote machine or VM.</li>
  <li>I start tmux.</li>
  <li>I might then use a terminal within Emacs or
<a href="https://asciinema.org/">Asciinema</a> or <a href="https://www.gnu.org/software/screen/">GNU
Screen</a>.
    <ul>
      <li>Yes, there are situations where it’s useful to have some screen
sessions running inside or outside of tmux.</li>
    </ul>
  </li>
</ul>

<p>Each of those layers is its own implementation of the ANSI escape
sequence state machine. For 24-bit color to work, every single layer
has to understand and accurately translate the escape sequences from
the inner TERM value’s terminfo to the outer terminfo.</p>

<p>Therefore, you need recent-enough versions of all of this software.
Current LTS Ubuntus only ship with mosh 1.3, so I had to enable the
<a href="https://launchpad.net/~keithw/+archive/ubuntu/mosh-dev">mosh-dev
PPA</a>.</p>

<p>TERM must be set correctly within each terminal: <code>tmux-direct</code> within
tmux, for example. There is no standard terminfo for <code>mosh</code>, so you
have to pick something close enough.</p>

<h3 id="graphical-terminal-emulators">Graphical Terminal Emulators</h3>

<p>Most terminals either set TERM to a reasonable default or
allow you to override TERM.</p>

<p>I use Konsole, but I think you could find a similar option in
whichever you use.</p>

<figure>
<a href="https://chadaustin.me/images/truecolor-terminal-emacs/konsole.png"><img src="https://chadaustin.me/images/truecolor-terminal-emacs/konsole.png" alt="Konsole&#39;s TERM value selection"/></a>
<figcaption>Konsole&#39;s TERM value selection</figcaption>
</figure>

<h3 id="ssh">ssh</h3>

<p>Often, the first thing I do when opening a terminal is to <code>ssh</code>
somewhere else. Fortunately, this is easy, as long as the remote host
has the same terminfo record. <code>ssh</code> carries your TERM value into the
new shell.</p>

<h3 id="tmux">tmux</h3>

<p>But then you load <code>tmux</code> and TERM is set to <code>screen</code>! To fix this,
override <code>default-terminal</code> in your <code>~/.tmux.conf</code>:</p>

<div><div><pre><code>set -g default-terminal &#34;tmux-direct&#34;
</code></pre></div></div>

<p>For extra credit, consider setting <code>tmux-direct</code> conditionally with
<code>%if</code> when the outer TERM supports 24-bit color, otherwise leaving the
default of <code>screen</code> or <code>tmux-256color</code>. And then let me know how you
did it. :P</p>

<h3 id="mosh">mosh</h3>

<p>While recent mosh does support 24-bit color, it <a href="https://github.com/mobile-shell/mosh/blob/1105d481bb9143dad43adf768f58da7b029fd39c/src/frontend/mosh-server.cc#L571">only advertises 8 or
256
colors</a>.
Thus, it’s up to you to set TERM appropriately.</p>

<p>Mosh aims for xterm compatibility, but unfortunately only supports
semicolon syntax for SGR 38 and 48, so <code>TERM=xterm-direct</code> does not
work. So far, I’ve found that <code>vscode-direct</code> is the closest to
<code>xterm-direct</code>.</p>

<p>There is no convenient “I’m running in mosh” variable, so I wrote a
<a href="https://gist.github.com/chadaustin/ee1a20e0522c10b65cb4006496d1fb7c"><code>detect-mosh.rs</code></a>
Rust script and called it from <code>.bashrc</code>:</p>

<div><div><pre><code>unamer=$(uname -r)
unameo=$(uname -o)
if [[ ! &#34;$TMUX&#34; ]]; then
    if [[ &#34;$unamer&#34; == *Microsoft ]]; then
        # WSL 1
        export TERM=vscode-direct
    elif [[ &#34;$unameo&#34; == Cygwin ]]; then
        # Eh, could just configure mintty to set mintty-direct.
        export TERM=vscode-direct
    elif detect-mosh 2&gt;/dev/null; then
        # This should be xterm-direct, but mosh does not understand SGR
        # colon syntax.
        export TERM=vscode-direct
    fi
fi
</code></pre></div></div>

<p>It works by checking whether the shell process is a child of
<code>mosh-server</code>.</p>

<p>The jury’s still out on whether it’s a good idea to compile Rust in
the critical path of login, especially into an underpowered host like
my Intel Atom NAS or a Raspberry Pi.</p>

<h2 id="it-works">It Works!</h2>

<p>Beautiful Emacs themes everywhere!</p>

<figure>
<a href="https://chadaustin.me/images/truecolor-terminal-emacs/finally.png"><img src="https://chadaustin.me/images/truecolor-terminal-emacs/finally.png" alt="Emacs within tmux within mosh"/></a>
<figcaption>Emacs within tmux within mosh</figcaption>
</figure>

<p>This was a ton of work, but I learned a lot, and, perhaps most
importantly, I now feel confident I could debug any kind of wonky
terminal behavior in the future.</p>

<p>To recap:</p>
<ul>
  <li>Terminals don’t agree on syntax and capabilities.</li>
  <li>Terminfo is how those capabilities are queried.</li>
  <li>Terminfo is often limited, sometimes inaccurate, and new terminfo
versions are released infrequently.</li>
</ul>

<h2 id="whats-next">What’s Next?</h2>

<p>If you were serious about writing software to take full advantage of
modern terminal capabilities, it would be time to break from terminfo.</p>

<p>I imagine such a project would look like this:</p>
<ul>
  <li>Continue to use the TERM variable because it’s well-supported.</li>
  <li>Give programs knowledge of terminals independent of the age of the
operating system or distribution they’re running on:
    <ul>
      <li>Programs would link with a frequently-updated (Rust?) library.</li>
      <li>Said library would contain a (modern!) terminfo database
representing, say, the last 10 years of terminal emulators, keyed
on (name, version). Notably, the library would not pretend to
support any hardware terminals, because they no longer exist. We
can safely forget about
<a href="https://www.gnu.org/software/termutils/manual/termcap-1.3/html_mono/termcap.html#SEC7">padding</a>,
for example.</li>
    </ul>
  </li>
  <li>Continue to support the terminfo file format and OS-provided
terminfo files on disk, with some protocol for determining which
information is most-up-to-date.</li>
  <li>Allow an opt-in TERMVERSION to differentiate between the
capabilities of, for example, 2022’s Konsole and 2023’s Konsole.</li>
  <li>Allow describing modern terminal capabilities (like 24-bit color,
256-color palette animation, <a href="https://github.com/Alhadis/OSC8-Adoption/">URL
links</a>, <a href="https://sw.kovidgoyal.net/kitty/graphics-protocol/">Kitty’s graphics
protocol</a>) in an
accurate, unambiguous format, independent of the timeline of new
ncurses releases.</li>
  <li>Backport modern terminal descriptions to legacy programs by
providing a program to be run by <code>.bashrc</code> that:
    <ul>
      <li>Uses TERM and TERMVERSION to generate a binary terminfo file in
<code>$HOME/.terminfo/</code>, which ncurses knows how to discover.</li>
      <li>Generates unambiguous 24-bit color capabilities like <code>RGB</code>,
<code>setf24</code>, and <code>setb24</code>, despite the fact that getting them added
to terminfo has been politically untenable.</li>
      <li>Otherwise, assumes RGB-unaware programs will assume the 256-color
palette, and leaves <code>colors#0x100</code>, <code>initc</code>, <code>oc</code> in place.
Palette animation is a useful, widely-supported feature.</li>
    </ul>
  </li>
</ul>

<p>Let me know if you’re interested in such a project!</p>

  </div></div>
  </body>
</html>
