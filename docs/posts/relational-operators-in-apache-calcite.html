<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.querifylabs.com/blog/relational-operators-in-apache-calcite">Original</a>
    <h1>Relational Operators in Apache Calcite</h1>
    
    <div id="readability-page-1" class="page"><div><div><div><p>When a user submits a query to a database, the optimizer translates the query string to an intermediate representation (IR) and applies various transformations to find the optimal execution plan.</p><p>Apache Calcite uses relational operators as the intermediate representation. In this blog post, we discuss the design of common relational operators in Apache Calcite.</p><h2>Syntax Tree</h2><p>Query optimization starts with parsing when a query string is translated into a syntax tree, which defines the syntactic structure of the query.</p><p>Since every database has a parser, the syntax tree might look like a good candidate for the intermediate representation because it is readily available to the database.</p><p>There are two significant problems with syntax tree as query&#39;s IR:</p><ol role="list"><li>AST has a highly complicated structure, thanks to the involved ANSI SQL syntax. For example, a `SELECT` node may have dedicated child nodes for `FROM`, `WHERE`, `ORDER BY`, `GROUP BY`, etc.</li><li>AST models the syntactic structure but not relational semantics. It could be problematic to map some valid relational transformations to the syntax tree. For example, a semi-join cannot be expressed easily with ANSI SQL syntax.</li></ol><p>Combined, this makes query optimization over syntax trees challenging and not flexible.</p><h2>Relational Tree</h2><p>An alternative IR is a relational operator tree. We may define common relational operators, such as `Project`, `Filter`, `Join`, `Aggregate`. The query represented in such a way is much simpler to optimize because relational operators have a well-defined scope and usually have only one input (except for joins and set operators). This dramatically simplifies common relational optimizations, such as operator transposition. Also, it gives implementors flexibility to model operators independently of the database syntax rules.</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://uploads-ssl.webflow.com/5fe5c475cb3c75040200bfe6/60b3612efc0661ba1956b79b_ast-vs-rel.png" loading="lazy" alt=""/></p></figure><p>The main disadvantage is the need to translate the syntax tree into a relational tree, which is often non-trivial, especially with complex syntax constructs like subqueries or common table expressions. However, the simplicity and flexibility of relational operators usually outweigh by a high margin the additional efforts on translation.</p><p>Apache Calcite parses the query into a syntax tree. Then it performs the semantic validation of the syntax tree using the <a href="https://github.com/apache/calcite/blob/calcite-1.26.0/core/src/main/java/org/apache/calcite/sql/validate/SqlValidatorImpl.java" target="_blank">SqlValidatorImpl</a> class, resolving involved data types along the way. Finally, the validated syntax tree is converted into a tree or relational operators using the <a href="https://github.com/apache/calcite/blob/calcite-1.26.0/core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java" target="_blank">SqlToRelConverter</a> class. The subsequent optimizations are performed on the relational tree.</p><p>In this section, we discuss the design of Apache Calcite relational operators.</p><h2>Terminology</h2><p>We start with several simplified definitions, which are not precise but sufficient for this blog post. </p><p>An <strong>attribute</strong> is a pair of a name and a data type. An <strong>attribute value</strong> is defined by an attribute name and value from the attribute type domain. A <strong>tuple</strong> is an unordered set of attribute values. No two attribute values in the tuple may have the same attribute name. A <strong>relation</strong> is a set of tuples. Every tuple within the relation has the same set of attributes. <strong>Relational operators</strong> take zero, one, or more input relations and produce an output relation.</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://uploads-ssl.webflow.com/5fe5c475cb3c75040200bfe6/60b374a4be8579b98cbce816_blog08-definitions.png" loading="lazy" alt=""/></p></figure><h2>Operators</h2><p>To construct a tree of relational operators, we need the ability to define operator inputs. Many operators need access to attributes of the input relations. Therefore we also need the ability to reference input attributes. These are two key requirements for the relational operator interface.</p><p>In Apache Calcite, the relational operator is represented by the <a href="https://github.com/apache/calcite/blob/calcite-1.26.0/core/src/main/java/org/apache/calcite/rel/RelNode.java" target="_blank">RelNode</a> interface. The operator may have zero, one, or more input operators. For example, `TableScan` is an 0-ary operator, `Filter` is a unary operator, and `Union` is an N-ary operator. Every operator exposes the `RelDataType`, which is an ordered list of operator attributes. This is sufficient to construct arbitrarily complex relational trees.</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://uploads-ssl.webflow.com/5fe5c475cb3c75040200bfe6/60b48ffda5f126e051e3a082_blog08-row-type.png" loading="lazy" alt=""/></p></figure><h2>Row Expressions</h2><p>Operators describe various transformations to tuples. A <a href="https://github.com/apache/calcite/blob/calcite-1.26.0/core/src/main/java/org/apache/calcite/rex/RexNode.java" target="_blank">RexNode</a> interface defines an operation that applies to some attribute values of a tuple and produces another value. Common `RexNode` types:</p><ol start="1" role="list"><li>`RexLiteral` - a constant.</li><li>`RexInputRef` - a reference to operator&#39;s input attribute.</li><li>`RexCall` - a function call.</li></ol><p>For example, the expression `name = &#34;John&#34;` would be represented as follows.</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://uploads-ssl.webflow.com/5fe5c475cb3c75040200bfe6/60b7829f70d3200769e64e01_blog08-rex.png" loading="lazy" alt=""/></p></figure><p>Notice that `RexInputRef` references the input&#39;s attribute by index, which means that attribute order is important in Apache Calcite. On the bright side, it simplifies the design, as you do not need to care about attribute names and potential naming conflicts (think of a join of two tables, which have an attribute with the same name). On the other hand, it has a detrimental effect on join order planning, as we shall see below.</p><p>Now, as we understand the basics, let&#39;s discuss the most common Apache Calcite operators: `TableScan`, `Project`, `Filter`, `Calc`, `Aggregate`, and `Join`.</p><p>Other important operators are `Window` and `Union`. We omit them in this blog post because they follow the same design principles as the previously mentioned operators.</p><h2>TableScan</h2><p>`TableScan` is a leaf 0-ary operator that defines a scan of some data source.</p><p>The operator contains the `org.apache.calcite.schema.Table` instance, which describes a data source that produces tuples. It could represent a relational table, an index, a view, a CSV file, a network connection, or anything else. As an implementor, you provide the schema of your database that contains some `Table` instances. Apache Calcite will create a `TableScan` operator with the referenced `Table` inside when you refer to that table in the query. The `Table` must expose the row type so that the parent operators know which attributes are available from the `TableScan`.</p><h2>Project</h2><p>The `Project` operator defines row expressions that should be applied to input tuples to produce new tuples. The operator produces one output tuple for every input tuple. Expressions are organized in a list.</p><p>Because Apache Calcite uses local indexes to reference input attributes, the `Project` operator is also injected whenever we need to change the attribute&#39;s order. For example, if there is a table with attributes `[a, b]` in that order and we execute `SELECT b, a FROM t`, the `Project` operator will be added on top of the `TableScan` to reorder attributes as required by the query. This complicates query planning because the optimizer spends time applying transformation rules to otherwise useless operators that do a trivial reorder.</p><p>Physical implementations of the `Project` operator must adjust the input <a href="https://www.querifylabs.com/blog/custom-traits-in-apache-calcite">traits</a>. E.g., if the `TableScan` produces tuples ordered by `[b]` but the `Project` operator doesn&#39;t project that column, the order will be lost.</p><p>The relational tree of the query `SELECT a, a+b FROM t`  might look like this:</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://uploads-ssl.webflow.com/5fe5c475cb3c75040200bfe6/60b78e86342fb8c97b6540f5_blog08-project.png" loading="lazy" alt=""/></p></figure><h2>Filter</h2><p>The `Filter` operator returns tuples that satisfy a predicate. A predicate is a row expression. The `Filter` output row type is similar to the input&#39;s row type. Physical implementations of the `Filter` operator usually don&#39;t change input traits. </p><p>The query `SELECT a, a+b FROM t WHERE a+b&gt;5` could be represented as:</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://uploads-ssl.webflow.com/5fe5c475cb3c75040200bfe6/60b78be9128f38006b87f543_blog08-filter.png" loading="lazy" alt=""/></p></figure><h2>Calc</h2><p>The `Calc` is a special operator that combines the functionality of `Project` and `Filter` operators and performs the common sub-expression elimination. Internally, it splits all composite row expressions into primitive expressions. Expressions are organized in a list. The special `RexLocalRef` node is used to link siblings. `Project` becomes a list of expression indexes that should be exposed from the operator. `Filter` becomes an optional expression index that filters input tuples.</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://uploads-ssl.webflow.com/5fe5c475cb3c75040200bfe6/60b78c01fcaf5405442e5ede_blog08-calc.png" loading="lazy" alt=""/></p></figure><p>Apache Calcite provides a lot of optimization rules for `Project` and `Filter` operators. These same optimizations are generally not implemented for the `Calc` operator because it would essentially require duplication of rules logic. Instead, you may do the cost-based optimization with `Project` and `Filter` operations only and then convert `Project` and `Filter` operators into `Calc` in a separate heuristic phase. Apache Calcite provides <a href="https://github.com/apache/calcite/blob/calcite-1.26.0/core/src/main/java/org/apache/calcite/plan/RelOptRules.java#L55-L66" target="_blank">dedicated rules</a> for that. We touched on the multi-phase optimization in our previous <a href="https://www.querifylabs.com/blog/what-is-cost-based-optimization">blog post</a>.</p><h2>Aggregate</h2><p>The `Aggregate` operator models the application of aggregate functions to the input. The operator consists of two parts - the group keys and aggregate functions. </p><p>The group keys define which input attributes to use to construct the groups. The statement `GROUP BY a, b` yields the grouping key `[0, 1]` if `a` and `b` are located on input positions 0 and 1, respectively. If there is no `GROUP BY` clause, the group key would be empty. </p><p>There will be several group keys if there is a `ROLLUP` or `CUBE` clause. For example, `GROUP BY ROLLUP a, b` would yield the grouping keys `[0,1], [0], []`, which means that we would like to output groups for `[a, b]`, groups for `[a]`, and global aggregates without any grouping. </p><p>If there is an expression in the `GROUP BY` statement, it would be moved to a separate `Project` operator below `Aggregate`. This is why it is sufficient to define input attribute indexes for the group keys instead of defining row expressions. Separation of projections and aggregations is essential to keep the complexity of optimization rules under control. Otherwise, we would have to repeat logic from the `Project` optimization rules in the `Aggregate` optimization rules.</p><p>The aggregate functions are the list of aggregates that should be computed for the groups. The aggregate functions do not use the `RexNode` interface because they operate on multiple tuples as opposed to row expressions that are applied to a single tuple. Similar to group keys, aggregate functions refer to input columns by indexes. For example, the function `SUM(a)` is converted to `SUM(0)` if the input attribute `a` is located at position 0. Likewise, complex expressions are moved to a `Project` operator below the `Aggregate`. Aggregate functions may also have advanced properties, such as the `DISTINCT` flag or an optional filter. We will discuss these features in detail in future blog posts.</p><p>The `Aggregate` operator outputs group keys followed by aggregate functions. For the query `SELECT SUM(a), b GROUP BY b`, the relevant `Aggregate` operator would output `[0:b, 1:SUM(a)]`.</p><p>Consider the plan for the query `SELECT SUM(a+b), c FROM t GROUP BY c` below. Notice two `Project` operators: one to calculate `a+b` and another to output `SUM` before the attribute `c`.</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://uploads-ssl.webflow.com/5fe5c475cb3c75040200bfe6/60b78c1759f1405dda985451_blog08-agg.png" loading="lazy" alt=""/></p></figure><h2>Join</h2><p>The `Join` operator joins two inputs. The operator defines the join type (inner, left/right/full outer, semi, etc.) and the optional predicate. </p><p>The `Join` operator outputs all columns from the left input followed by all columns from the right input. There is the convention: given the left input with `L` attributes and the right input with `R` attributes: </p><ul role="list"><li>If the referenced column index `I` is between zero and `L` exclusive, we should use the left input&#39;s attribute at position `I`.</li><li>Otherwise, we should use the right input&#39;s attribute at position `I - L`. </li></ul><p>In our previous <a href="https://www.querifylabs.com/blog/memoization-in-cost-based-optimizers">blog post</a>, we discussed that cost-based optimizers rely on the equivalence property of operators to encode alternative plans efficiently in the MEMO data structure. In Apache Calcite, `Join(AxB)` and `Join(BxA)` are not semantically equivalent because Apache Calcite relies on attribute indexes in the `RexInputRef` class. Parent operators of `Join(AxB)` and `Join(BxA)` will have to use different indexes when referring to the same join attribute. Internal join predicates will also reference attributes at different indexes.</p><p>Consider the `JoinCommute` rule that changes the order of inputs. To apply this rule, we need to (a) rewrite the internal predicate and (b) add the `Project` on top of the new `Join` to restore the original order of attributes.</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://uploads-ssl.webflow.com/5fe5c475cb3c75040200bfe6/60b78c222b319033945b0cf1_blog08-join-1.png" loading="lazy" alt=""/></p></figure><p>This additional `Project` prevents the execution of other rules. For example, the `JoinAssociate` rule tries to reorder `(A join B) join C` to `A join (B join C)`. The rule looks for a pattern &#34;Join on top of the Join&#34;. But with the additional `Project`, we have only &#34;Join on top of the Project&#34;. To mitigate this, we may use the `JoinProjectTransposeRule` that transposes `Join` and `Project`, but this dramatically decreases planner&#39;s performance to the extent that Apache Calcite cannot do the exhaustive cost-based join planning on more than 5-6 tables in a reasonable time. </p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://uploads-ssl.webflow.com/5fe5c475cb3c75040200bfe6/60b4cbfba395d8e030cc1dbb_blog08-join-2.png" loading="lazy" alt=""/></p></figure><p>The alternative solution would be to operate on unique column names rather than indexes. Spark Catalyst and CockroachDB follow this approach. But this would require introducing some unique identifier to every equivalence group, which is also a challenge on its own.</p><p>Apache Calcite parses the query string into a syntax tree. The syntax tree is then translated into a tree of relational operators, which have a simpler internal structure and are more suitable for the subsequent optimizations.</p><p>We discussed several common relational operators in Apache Calcite. `Project` transforms every tuple from the input into another tuple. `Filter` operator returns input tuples that pass the predicate. `Calc` combines `Project` and `Filter` functionality and eliminates the common sub-expressions. `Aggregate` operator performs the grouping and applies aggregate functions. `Join` operator combines tuples two inputs and applies the predicate. </p><p>Designing relational operators is challenging. Every decision may open opportunities for new optimizations but block others. The index-based input attribute references in Apache Calcite are a good example of such a trade-off when a simplification useful for many optimization rules leads to severe problems with one of the most critical optimizer tasks - join order planning.</p><p>In future blog posts, we will dive into concrete optimizations that Apache Calcite applies to individual operators. Stay tuned!</p><p>We are always ready to help you with your query optimizer design. Just <a href="https://www.querifylabs.com/contact" target="_blank">let us know</a>.</p></div></div></div></div>
  </body>
</html>
