<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://mcejp.github.io/2024/10/16/gba-raycasting.html">Original</a>
    <h1>How I failed to make a game: Raycasting on the GBA</h1>
    
    <div id="readability-page-1" class="page"><div aria-label="Content">
      <div>
        





<article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    <p>Today I am releasing my raycasting tech demo for the GameBoy Advance. Although it falls short of the goals I set out in the beginning – which included releasing a playable game –, I think there are some lessons worth sharing with the world.</p>

<p>This project started essentially as a challenge: inspired by the impressive work of <a href="https://www.youtube.com/@3DSage/videos">3DSage</a>, I wanted to see if I could build a raycasting “2.5D” engine that ran well enough to play a game.</p>

<p>
<iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/5rjSpQ_rC7I?si=1zJRQxStlLgq8e_1" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe>
</p>

<p>I explained in <a href="https://mcejp.github.io/2023/10/30/gba-benchmarking.html">a previous post</a> why I find the GBA a really nice platform to develop for. I have always enjoyed game programming, but pretty much from the beginning of my C++ journey I have been stuck in the <a href="https://geometrian.com/programming/tutorials/write-games-not-engines/index.php">Game Engine Trap</a>. Due to that realization, and based on experience from my other gamedev projects, it was really important to avoid getting carried away by tasks that are fun, but ultimately non-important. To that end I established some firm rules:</p>

<ul>
  <li>Build a <em>game</em>, not a <em>game engine</em></li>
  <li>Don’t get stuck on assets. Make a quick placeholder when necessary</li>
  <li>Don’t get distracted by languages. Use straightforward C++ and, if necessary, Python to generate code. Want fancy LISP-compiled-to-bytecode AI scripting? Put it in another project.</li>
  <li>Stick to one design direction. Don’t start branching out in the middle of development.</li>
</ul>

<p>And <em>it worked</em> – until I realized that tech development is the really interesting part for me, and while it is fun to think about the final result, with all the captivating environments and assets and mechanics, actually getting there eventually turns into a chore. Therefore, after not touching the project in several months, I declare time for a post-mortem!</p>

<h3 id="what-worked-out-well">What worked out well</h3>

<p>My tech stack was fixed more-or-less from the start. The main language for run-time code was C++, technically <strong>C++20</strong>, but I use barely any new language features. I was determined to use <strong>CMake</strong>, partly because it is the native project format of my favorite C++ IDE (CLion), partly because <a href="https://ascii.mcejp.com/posts/CMake-tips-&amp;-tricks.html">I just like it</a>. As toolchain, I used devkitARM at first, but moved to the official <strong>ARM GNU Toolchain</strong> with <a href="https://www.coranac.com/man/tonclib/"><strong>Tonclib</strong></a> to access the GBA hardware. Tonclib is really great. I don’t think it gets enough praise, and I think that more libraries should follow the same kind of spartan philosophy.</p>

<p>For really hot code paths, namely sprite scaling code, I also generate what are basically unrolled loops. They’re still compiled as C++, GCC does a good job of optimizing it. I didn’t want to write any assembly code except as a last resort at the end of the project, since it would be time-consuming to maintain.</p>

<p>Most games cannot exist without a considerable amount of <strong>assets</strong>. Having previously built somewhat sophisticated asset pipelines, this time I wanted something dead simple, knowing my game <a href="https://github.com/mcejp/GBA-raycaster/blob/master/doc/content-guidelines.rst#content-system-assumptions">would be very small</a>. I had recently finally grasped how input/output dependencies work for custom steps in CMake projects, so it seemed kind of obvious to use these for asset compilation, including the management of any dependencies between assets (such as between sprites and palettes). On GBA, the entirety of the cartridge ROM shows up as addressable memory, so instead of embedding custom binary formats and filesystem images, I just decided to <strong>generate a C++ header with the compiled data</strong> for each asset. Here’s an example snippet from the animation data for a spider enemy:</p>

<div><div><pre><code>    <span>...</span>
    <span>// col 30</span>
    <span>{</span><span>25</span><span>,</span> <span>7</span><span>,</span> <span>ani_spider_dead_1_data_30</span><span>},</span>
    <span>// col 31</span>
    <span>{</span><span>25</span><span>,</span> <span>6</span><span>,</span> <span>ani_spider_dead_1_data_31</span><span>},</span>
<span>}</span><span>;</span>

<span>static</span> <span>const</span> <span>AnimFrame</span> <span>ani_spider_dead_frames</span><span>[]</span> <span>=</span> <span>{</span>
    <span>{</span> <span>.</span><span>spans</span> <span>=</span> <span>ani_spider_dead_0_spans</span> <span>},</span>
    <span>{</span> <span>.</span><span>spans</span> <span>=</span> <span>ani_spider_dead_1_spans</span> <span>},</span>
<span>};</span>

<span>static</span> <span>const</span> <span>AnimImage</span> <span>ani_spider_anims</span><span>[]</span> <span>=</span> <span>{</span>
    <span>{</span> <span>.</span><span>frames</span> <span>=</span> <span>ani_spider_idle_frames</span><span>,</span> <span>.</span><span>num_frames</span> <span>=</span> <span>2</span> <span>},</span>
    <span>{</span> <span>.</span><span>frames</span> <span>=</span> <span>ani_spider_walk_frames</span><span>,</span> <span>.</span><span>num_frames</span> <span>=</span> <span>2</span> <span>},</span>
    <span>{</span> <span>.</span><span>frames</span> <span>=</span> <span>ani_spider_attk_frames</span><span>,</span> <span>.</span><span>num_frames</span> <span>=</span> <span>2</span> <span>},</span>
    <span>{</span> <span>.</span><span>frames</span> <span>=</span> <span>ani_spider_dead_frames</span><span>,</span> <span>.</span><span>num_frames</span> <span>=</span> <span>2</span> <span>},</span>
<span>};</span>

<span>static</span> <span>const</span> <span>SpriteImage</span> <span>ani_spider</span> <span>=</span> <span>{</span> <span>.</span><span>anims</span> <span>=</span> <span>ani_spider_anims</span><span>,</span> <span>};</span>
</code></pre></div></div>

<p>I cannot overstate how satisfied I am with this solution. Again, this might only work for games up to a certain size. Rumor has it, though, that there is leaked Pokémon R/S/E code out there which does the exact same thing.</p>

<p>The custom asset compilers are all written in Python with only the most essential external dependencies (Numpy and <a href="https://pillow.readthedocs.io/">Pillow</a>). Python dependency management in this context is still an unsolved problem for me; in principle, the CMake script could set up a <em>venv</em> and install arbitrary dependencies at configuration time, but such a setup sounds rather fragile. So I just require those two packages to be already installed in whatever interpreter is used to configure the project.</p>

<p>To create and edit maps I opted for the venerable <a href="https://www.mapeditor.org/">Tiled</a> editor and it didn’t disappoint. About the only point of friction was due to difference in the coordinate system between the editor and the game, so the conversion script has to include some transformation math which took a few iterations to get right:</p>

<div><div><pre><code><span># correct for rotation
# Tiled anchors sprites in bottom left of the cell, but in-game sprite origin
# (incl. for rotation) is at the center
# therefore un-rotate the vector from corner to center
</span><span>xxx</span> <span>=</span> <span>obj</span><span>[</span><span>&#34;width&#34;</span><span>]</span> <span>/</span> <span>2</span>
<span>yyy</span> <span>=</span> <span>obj</span><span>[</span><span>&#34;height&#34;</span><span>]</span> <span>/</span> <span>2</span>
<span>aaa</span> <span>=</span> <span>-</span><span>obj</span><span>[</span><span>&#34;rotation&#34;</span><span>]</span> <span>*</span> <span>2</span> <span>*</span> <span>math</span><span>.</span><span>pi</span> <span>/</span> <span>360</span>
<span>xxxx</span> <span>=</span> <span>xxx</span> <span>*</span> <span>math</span><span>.</span><span>cos</span><span>(</span><span>aaa</span><span>)</span> <span>-</span> <span>yyy</span> <span>*</span> <span>math</span><span>.</span><span>sin</span><span>(</span><span>aaa</span><span>)</span>
<span>yyyy</span> <span>=</span> <span>xxx</span> <span>*</span> <span>math</span><span>.</span><span>sin</span><span>(</span><span>aaa</span><span>)</span> <span>+</span> <span>yyy</span> <span>*</span> <span>math</span><span>.</span><span>cos</span><span>(</span><span>aaa</span><span>)</span>
<span>obj_x</span> <span>=</span> <span>obj</span><span>[</span><span>&#34;x&#34;</span><span>]</span> <span>+</span> <span>xxxx</span>
<span>obj_y</span> <span>=</span> <span>obj</span><span>[</span><span>&#34;y&#34;</span><span>]</span> <span>-</span> <span>yyyy</span>

<span>x</span><span>,</span> <span>y</span> <span>=</span> <span>tiled_to_world_coords</span><span>(</span><span>obj_x</span><span>,</span> <span>obj_y</span><span>)</span>
</code></pre></div></div>

<p>Benchmarking was an important part of the development process. I wrote about it at length in <a href="https://mcejp.github.io/2023/10/30/gba-benchmarking.html">a previous article</a>. Unless you are willing to spend a lot of time experimenting and guessing, I would now say that having strong benchmarking capability built-in is <strong>essential</strong> in such a project sensitive to “detail optimization” (I don’t know if there is an established term for this – what I mean is that changing e.g. the alignment of some function or structure can make a 1% performance difference, which quckly adds up. A related idea is <a href="https://youtu.be/Ca1hHC2EctY">“performance lottery”</a>, which should really be called <em>performance chaos theory</em>, whereby a minor change to the codebase can have performance impacts elsewhere by changing the layout of the compiled code).</p>

<figure>
<p><img src="https://mcejp.github.io/images/2024/gba-raycasting/benchmarks.png" alt="Benchmarking results are processed by CI and rendered to a webpage"/></p>
</figure>

<h3 id="what-didnt-work">What didn’t work</h3>

<p>Content. Brace for an obvious statement: it is one thing to imagine a grand, Daggerfall-scale game in your head, and a completely different thing to actually start building the pieces that make it up. I am not a graphic artist and I get quickly frustrated playing one. (If you haven’t figured by now, I am writing this article as a reminder/deterrent to future me.) I could commission the graphics and sounds, but that gets expensive for a game with no prospect of commercialization. Making maps was more interesting, but I often felt like I was missing the right textures for the environments I wanted to build.</p>

<p>Controls were an issue from the beginning. I should have done more research into how other FPS games solved this. What I settled on was “tank controls” on the D-pad, A/B to strafe and R to shoot.</p>

<p>The screen on the GBA is notoriously bad. I don’t know how we managed to stare at it for hours as kids. The gamma curve is crazy, the colors are kinda washed out, and the contrast is a joke. The right answer here is probably to simply use a GBA SP, but I don’t have any emotional connection to it.</p>

<p>In any case, it always feels great to see your code run on real hardware, but after already being somewhat burned out with assets, it really drove home the latter two points above, providing a final straw to kill the project.</p>

<h3 id="just-show-me-the-code">Just show me the code</h3>

<p>The release is as complete as was possible; unfortunately, I do not have redistribution rights for the third-party assets. I have blackened them out in the published files, hopefully keeping just the silhouettes can be considered fair use.</p>

<p>And here it is: <a href="https://github.com/mcejp/GBA-raycaster">mcejp/GBA-raycaster</a></p>

  </div>
  
  
</article>

      </div>
    </div></div>
  </body>
</html>
