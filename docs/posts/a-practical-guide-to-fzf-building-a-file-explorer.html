<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://thevaluable.dev/practical-guide-fzf-example/">Original</a>
    <h1>A Practical Guide to fzf: Building a File Explorer</h1>
    
    <div id="readability-page-1" class="page"><div role="main"><article><section><picture><source srcset="https://thevaluable.dev/images/2023/fzf-guide/gandalf-fuzzy-search-ring.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2023/fzf-guide/gandalf-fuzzy-search-ring.jpg" alt="Gandalf trying to fuzzy search the ring of power"/></picture><p>It’s again a sunny day! Desperate, you’re looking through the windows. You’re locked up in the offices of MegaCorpMoneyMaker, the company you’re working for.</p><p>While Davina, your colleague developer, explains quietly to one of her colleague the power of the <a href="https://thevaluable.dev/guide-terminal-shell-console/">terminal</a>, Dave, another colleague developer, suddenly stands up and interjects:</p><p>“What you’re saying is not true! The terminal is an old, clunky tool. It’s difficult to manage files and directories only using a terminal, for example. Using GUIs (<span>G</span>raphical <span>U</span>ser <span>I</span>nterfaces) is often the best idea!”</p><p>Davina acknowledges that GUIs might seem more powerful and easier to use than a terminal. But graphical interfaces don’t often have the power to be customized for the specific needs of a developer.</p><p>“For example, she continues, the CLI (<span>C</span>ommand <span>L</span>ine <span>I</span>nterface) fzf is powerful enough to create ourselves simple but useful TUIs (<span>T</span>erminal <span>U</span>ser <span>I</span>nterface). When you have a specific workflow, CLIs can be combined to support this workflow. Personally, the shell is the keystone of my own <a href="https://thevaluable.dev/mouseless-development-environment/">development environment</a>.”</p><p>She pauses a moment, thinking. Then, she continues:</p><p>“I have an idea: let’s try to create a simple file explorer using fzf!”</p><p>Many, including you, join the group, decided to help them in this endeavor. Quickly, you decide that the file explorer should have two modes:</p><ol><li>A “file” mode: for searching, previewing, and opening files.</li><li>A “directory” mode: for searching, previewing, and opening directories.</li></ol><p>This article is the result of the Dave’s and Davina’s journey at MegaCorpMoneyMaker. You’ll find some small exercises throughout, to build this file explorer step by step. I recommend you to try to solve them; it doesn’t matter if you succeed. You’ll <a href="https://thevaluable.dev/learning-developer-efficiently-effectively/">remember more easily</a> if you only try.</p><p>In the same spirit, I encourage you to try out the different shell commands described in this article. To follow along, you can download the <a href="https://github.com/Phantas0s/the_valuable_dev_companion/tree/main/guide-fzf" target="_blank" rel="noopener">companion project</a> and run the different commands from there.</p><p>We’ll see, in this article:</p><ul><li>The basics of fzf.</li><li>How to enable multi-selection to select more than one entry.</li><li>The special metacharacters we can use for our queries.</li><li>How to limit the fuzzy search to some specific fields for each entry.</li><li>How to customize fzf’s TUI.</li><li>How to preview the different entries.</li><li>How to bind keystrokes or event to some actions.</li><li>How to build our complete file explorer.</li><li>How to fix potential performance issues.</li></ul><p>This article also exists <a href="https://www.youtube.com/watch?v=FvNFxx3Z9qI" target="_blank" rel="noopener">as a video you can find on my YouTube channel</a>.</p><p>In this article, we’ll only look at fzf as an independent CLI. We won’t discuss the different fzf integrations (with the shell or with Vim, for example). If you want me to write about that, don’t hesitate to contact me by answering <a href="https://thevaluable.dev/page/newsletter/" target="_blank" rel="noopener">one of my newsletter</a>, or by writing a comment down below.</p><p>Many examples from this article are inspired from fzf’s manual (<code>man fzf</code>). It’s where you’ll find the most complete guide you’ll ever need; I definitely recommend you to look at it if you need something specific.</p><p>Enough rambling! Let’s now dive deep in the labyrinth of fuzzy searching with the fantastic fzf.</p><h2 id="the-basics-of-fzf">The Basics of fzf</h2><h3 id="a-fuzzy-finder">A Fuzzy Finder</h3><p>The CLI fzf is a <span>f</span>u<span>z</span>zy <span>f</span>inder, an interactive filter which can be used to easily match plain text entries separated with newlines.</p><p>To fuzzy find, you can type a query directly in fzf’s TUI. This query is not a regex pattern, but only plain text trying to match fzf’s input, using an approximate string matching algorithm (also called fuzzy search).</p><p>For example, you can try to run the following in your shell:</p><div><pre tabindex="0"><code data-lang="bash"><span><span><span>echo</span> <span>&#34;hello\nbonjour\nbonsoir&#34;</span> <span>|</span> fzf
</span></span></code></pre></div><p>We give here a string to fzf’s input, creating three entries all separated with a newline <code>\n</code>: <code>hello</code>, <code>bonjour</code>, and <code>bonsoir</code>. The TUI of fzf will then be displayed, allowing us to type our query to fuzzy search the entry we want.</p><p>For example, the query “bon” will only match “bonjour” and “bonsoir”; everything else will disappear. You can then select the entry you want with one of the following keystrokes:</p><table><tbody><tr><th>Keystroke</th><th>Description</th></tr><tr><td><code>UP</code>, <code>CTRL-P</code>, or <code>CTRL-K</code></td><td>Select the previous entry.</td></tr><tr><td><code>DOWN</code>, <code>CTRL-N</code>, or <code>CTRL-J</code></td><td>Select the next entry.</td></tr></tbody></table><p>If you press the <code>ENTER</code> key after making your choice, the selection is simply spit back using the <span>st</span>an<span>d</span>ard <span>out</span>put (STDOUT).</p><p>It wouldn’t be super useful if we weren’t in the shell; but since we are, we can redirect STDOUT to anything we want. A file, another pipe (to pass the selection as input to another command), a command substitution… you name it.</p><h3 id="default-behavior">Default Behavior</h3><p>If you run fzf without giving it any input, it will run a default command (with the <a href="https://themouseless.dev/posts/find-guide-example-mouseless/" target="_blank" rel="noopener">CLI find</a>) to get all the files and subdirectories of the working directory by default. All hidden files will be skipped.</p><h4 id="the-default-command">The Default Command</h4><p>You can overwrite the default command fzf uses under the hood with the environment variable <code>FZF_DEFAULT_COMMAND</code>. For example:</p><div><pre tabindex="0"><code data-lang="bash"><span><span><span># Use the CLI find to get all files, excluding any filepath</span>
</span></span><span><span><span># containing the string &#34;git&#34;.</span>
</span></span><span><span><span>export</span> <span>FZF_DEFAULT_COMMAND</span><span>=</span><span>&#39;find . -type f ! -path &#34;*git*&#34;&#39;</span>
</span></span><span><span>
</span></span><span><span><span># Use the CLI fd to respect ignore files (like &#39;.gitignore&#39;),</span>
</span></span><span><span><span># display hidden files, and exclude the &#39;.git&#39; directory.</span>
</span></span><span><span><span>export</span> <span>FZF_DEFAULT_COMMAND</span><span>=</span><span>&#39;fd . --hidden --exclude &#34;.git&#34;&#39;</span>
</span></span><span><span>
</span></span><span><span><span># Use the CLI ripgrep to respect ignore files (like &#39;.gitignore&#39;),</span>
</span></span><span><span><span># display hidden files, and exclude the &#39;.git&#39; directory.</span>
</span></span><span><span><span>export</span> <span>FZF_DEFAULT_COMMAND</span><span>=</span><span>&#39;rg --files --hidden --glob &#34;!.git&#34;&#39;</span>
</span></span></code></pre></div><p>For the two last examples to work, you need respectively <a href="https://github.com/sharkdp/fd" target="_blank" rel="noopener">fd</a> and <a href="https://github.com/BurntSushi/ripgrep" target="_blank" rel="noopener">ripgrep</a> installed on your system.</p><p>Remember: fzf will use this default command if and only if you don’t give any input.</p><h4 id="the-default-options">The Default Options</h4><p>Like many other CLIs, the behavior of fzf can be significantly altered thanks to its option. If you want to always use the same options without specifying them each time, you can set fzf’s default options with the environment variable <code>FZF_DEFAULT_OPTS</code>. For example:</p><div><pre tabindex="0"><code data-lang="bash"><span><span><span>export</span> <span>FZF_DEFAULT_OPTS</span><span>=</span><span>&#39;-i --height=50%&#39;</span>
</span></span></code></pre></div><p>We’ll describe the most interesting options below in the article.</p><p>With the proper defaults in place, you can use a command substitution (for example) to edit any file from your filesystem. For instance, to fuzzy search a file (or a directory) and edit it in Vim, you can do:</p><p>When I run this command in our <a href="https://github.com/Phantas0s/the_valuable_dev_companion/tree/main/guide-fzf" target="_blank" rel="noopener">companion project</a>, here’s what I get:</p><picture><source srcset="https://thevaluable.dev/images/2023/fzf-guide/fzf-without-input-vim.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2023/fzf-guide/fzf-without-input-vim.jpg" alt="using fzf to select a file and edit it in Vim"/></picture><p>You can of course combine command substitutions and pipes if you want to:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>vim <span>$(</span>find . -type f <span>|</span> fzf<span>)</span>
</span></span></code></pre></div><p>Since we feed fzf’s input, <code>FZF_DEFAULT_COMMAND</code> is not used, but <code>FZF_DEFAULT_OPTS</code> is. I’d recommend not to add too many options for specific entries in there (like options which can only work when the entries are filepath, for example). The aim of fzf is to be as general as possible, to fuzzy find <em>any</em> kind of plain text.</p><h3 id="default-query">Default Query</h3><p>By default, fzf will start without any query; everything will be matched. You can change that by using the <code>--query</code> option. For example:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>vim <span>$(</span>find . -type f <span>|</span> fzf --query <span>&#34;mouseless&#34;</span><span>)</span>
</span></span></code></pre></div><p>Here’s the result if I run the above in the <a href="https://github.com/Phantas0s/the_valuable_dev_companion/tree/main/guide-fzf" target="_blank" rel="noopener">companion project</a>:</p><picture><source srcset="https://thevaluable.dev/images/2023/fzf-guide/fzf-default-query.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2023/fzf-guide/fzf-default-query.jpg" alt="Launching fzf with a default query"/></picture><h3 id="creating-a-list-of-directory">Creating a List of Directory</h3><p>Let’s begin to create our file explorer. As we said above, it will have two modes: one only displaying files, the other one only displaying directories.</p><p>Let’s look at this second mode. We want to create here the list of subdirectories for the working directory, and feed that to fzf’s <span>st</span>an<span>d</span>ard <span>in</span>put (STDIN).</p><p>We want then to give the selection we make (fzf’s STDOUT) to the command “cd” (as argument), to move to the directory selected.</p><div id="toggle-1"><p><label for="toggle-input-1">Click to see the solution</label>
</p><div><div><pre tabindex="0"><code data-lang="bash"><span><span><span>cd</span> <span>$(</span>find . -type d <span>|</span> fzf<span>)</span>
</span></span></code></pre></div><p>We use the expression <code>-type</code> with the value <code>d</code> to only display directories. As you might have guessed, if we wanted to only display files, we would have given the value “f”.</p><p>We then use a command substitution to give the output of our command to “cd” as argument.</p></div></div><h2 id="selecting-more-entries-with-multi-selection">Selecting More Entries with Multi-Selection</h2><p>By default, we can only select one entry in fzf’s TUI. To select multiple of them, we can run fzf with the following option:</p><table><tbody><tr><th>Option</th><th>Description</th></tr><tr><td><code>--multi</code> or <code>-m</code></td><td>Allow multi-selection.</td></tr></tbody></table><p>We can then use these keystrokes in fzf’s TUI:</p><table><tbody><tr><th>Keystroke</th><th>Description</th></tr><tr><td><code>TAB</code></td><td>Toggle the selection of the current entry and move the pointer up.</td></tr><tr><td><code>SHIFT+TAB</code></td><td>Toggle the selection of the current entry and move the pointer down.</td></tr></tbody></table><p>Here’s what it looks like with multiple entries selected:</p><picture><source srcset="https://thevaluable.dev/images/2023/fzf-guide/fzf-multiple-entries.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2023/fzf-guide/fzf-multiple-entries.jpg" alt="Selecting multiple entries in fzf"/></picture><p>When we then hit <code>ENTER</code>, all selected entries will be spit back to STDOUT, separated with newlines.</p><p>Here’s a little exercise: in our <a href="https://github.com/Phantas0s/the_valuable_dev_companion/tree/main/guide-fzf" target="_blank" rel="noopener">companion project</a>, how would you edit all the files in the “headers” directory using Vim?</p><div id="toggle-2"><p><label for="toggle-input-2">Click to see the solution</label>
</p><div><p>You need first to launch Vim with the selection you’re making using fzf:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>vim <span>$(</span>find -type f <span>|</span> fzf -m<span>)</span>
</span></span></code></pre></div><p>You can then use the query “headers” to match all the files in the “headers” directory. To select them all, hit <code>SHIFT-TAB</code> to move your pointer up to the top of the list.</p><p>Finally, hit the <code>ENTER</code> key to edit all these files in Vim.</p></div></div><p>There is no keystroke to select all entries (or unselect them) by default. We’ll see how we can configure that in another section below.</p><h2 id="search-syntax">Search Syntax</h2><p>We saw earlier that we can type a query in fzf to reduce the matches and select more easily what we want. I also wrote that these queries are not <a href="https://thevaluable.dev/regular-expression-basics-vim-grep/" target="_blank" rel="noopener">regex patterns</a>, only plain text queries used in a fuzzy search algorithm.</p><p>Yet, fzf’s query system allows us to use a couple of metacharacters similar to most common regex engines, thanks to fzf’s extended search mode. It’s enabled by default; if you don’t want to use it, you can disable it with the option <code>--no-extended</code> (or the equivalent <code>+x</code>).</p><p>We’ll try to edit different files from <a href="https://github.com/Phantas0s/the_valuable_dev_companion/tree/main/guide-fzf" target="_blank" rel="noopener">our companion project</a> in this section, always using the following command:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>vim <span>$(</span>find . -type f <span>|</span> fzf<span>)</span>
</span></span></code></pre></div><p>Let’s focus now on these queries.</p><h3 id="beginning-and-end-of-line">Beginning and End of Line</h3><p>Let’s say that we only want to match and edit one of our LaTeX file with the extension “.tex”. To do so, after running our command above, we can use this query:</p><p>The dollar <code>$</code> is a metacharacter in that case; it doesn’t match the dollar character, but it has a meaning. For fzf, it means “end of line”, like most regex engines out there.</p><p>With our query, we basically want to match filepaths finishing with <code>.tex</code>. Here’s the result:</p><picture><source srcset="https://thevaluable.dev/images/2023/fzf-guide/fzf-end-of-line-metacharacter.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2023/fzf-guide/fzf-end-of-line-metacharacter.jpg" alt="Using fzf metacharacter end-of-line"/></picture><p>We can also match the beginning of line with a caret <code>^</code>. For example, if we want to match filepaths beginning with “./explorer”, we can write the following query:</p><h3 id="the-or-operator">The OR operator</h3><p>If we want to match at least one query among many, we can use a bar <code>|</code> between them. For example, if we want to match files with the extensions “.yml”, “.xml”, and “.tex”, we can use the following query:</p><p>Here’s the result:</p><picture><source srcset="https://thevaluable.dev/images/2023/fzf-guide/fzf-or-metacharacter.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2023/fzf-guide/fzf-or-metacharacter.jpg" alt="Using fzf metacharacter end-of-line"/></picture><p>Remember that these bars have nothing to do with shell pipes.</p><h3 id="the-and-operator">The AND operator</h3><p>We can also try to match multiple queries at once: we just have to separate our queries with a space.</p><p>For example, if we want to match all the files with extension “.tex”, and also the filepaths containing “/headers/”, we can write the following query:</p><p>The result:</p><picture><source srcset="https://thevaluable.dev/images/2023/fzf-guide/fzf-and-query.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2023/fzf-guide/fzf-and-query.jpg" alt="Using fzf metacharacter end-of-line"/></picture><h3 id="the-not-operator">The NOT operator</h3><p>What about using a query to exclude some entries? To do so, we can use the bang <code>!</code> as prefix.</p><p>Let’s say that we want to match the files with extensions “.yml”, “.xml”, or “.tex”, but not the files in the “headers” directory. We can write this query:</p><div><pre tabindex="0"><code data-lang="text"><span><span>.yml$ | .xml$ | .tex$ !/headers/
</span></span></code></pre></div><p>We could translate the above by: “I want to match YAML, XML, or LaTeX files, and not the ones in the ‘headers’ directory”.</p><p>The result:</p><picture><source srcset="https://thevaluable.dev/images/2023/fzf-guide/fzf-not-metacharacter.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2023/fzf-guide/fzf-not-metacharacter.jpg" alt="Using fzf metacharacter end-of-line"/></picture><h3 id="exact-match">Exact Match</h3><p>There is a last metacharacter we can use as a prefix to our queries: the single quote <code>&#39;</code>, to get an exact match.</p><p>For example, if you type the query <code>ti</code> in fzf, you’ll match any entry including the letter ’t’ and ‘i’, even if they are not following one another. If you add a single quote to the query as prefix (<code>&#39;ti</code>), it will only exactly match a ’t’ followed with an ‘i’.</p><p>You can also use the option <code>-e</code> when running fzf to <span>e</span>xactly match all your queries, without the need to use the single quote <code>&#39;</code> for each of them.</p><h3 id="case-sensitive-search">Case Sensitive Search</h3><p>By default, fzf’s search algorithm use “smart-case”: the match will only be case-sensitive if we use one or more uppercase in the query. Otherwise, it will be case-insensitive.</p><p>To change this, we can use one of the following options:</p><table><tbody><tr><th>Option</th><th>Description</th></tr><tr><td><code>-i</code></td><td>All queries are case-insensitive.</td></tr><tr><td><code>+i</code></td><td>All queries are case-sensitive.</td></tr></tbody></table><h2 id="limiting-the-search">Limiting the Search</h2><p>Until now, our queries try to match every single character of each entry. What if we only want to match a part of each of these entries?</p><p>We can use these options to limit the search scope by entry:</p><table><tbody><tr><th>Option</th><th>Description</th></tr><tr><td><code>--nth</code></td><td>Limit the scope to the nth field of the entry.</td></tr><tr><td><code>--delimiter</code></td><td>Regex to change the field delimiter (space by default).</td></tr></tbody></table><p>Let’s say that we want to display a number before each entry. To accomplish this miracle, we could use the CLI <code>nl</code>, for <span>n</span>umber of <span>l</span>ines). But we don’t want our queries to match these numbers. Here’s how to do that:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>vim <span>$(</span>find . -type f <span>|</span> nl <span>|</span> fzf --nth<span>=</span>2<span>)</span>
</span></span></code></pre></div><p>The result:</p><picture><source srcset="https://thevaluable.dev/images/2023/fzf-guide/fzf-multiple-fields.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2023/fzf-guide/fzf-multiple-fields.jpg" alt="Limiting the match using fields"/></picture><p>As you can see, there are two fields separated with a space in each entry:</p><ol><li>The number (created by <code>nl</code>).</li><li>The filepath.</li></ol><p>We only want to match the filepath with our query, so we give “2” to the option <code>--nth</code>. As a result, if you type the query “2” for example, nothing will be matched.</p><p>What if we want to use another delimiter? A comma <code>,</code>, for example? To do so, we can use the <code>--delimiter</code> option to specify this new separator. For example:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>vim <span>$(</span>find . -type f <span>|</span> nl -s <span>&#39;,&#39;</span> <span>|</span> fzf --nth<span>=</span><span>2</span> --delimiter<span>=</span><span>&#39;,&#39;</span><span>)</span>
</span></span></code></pre></div><p>Here’s the result:</p><picture><source srcset="https://thevaluable.dev/images/2023/fzf-guide/fzf-comma-separator.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2023/fzf-guide/fzf-comma-separator.jpg" alt="Limiting the match using fields and comma separator"/></picture><p>Again, querying for “2” (for example) won’t match anything.</p><p>Here are some examples of the possible values we can give to the <code>--nth</code> option:</p><table><tbody><tr><th>Example of value</th><th>Description</th></tr><tr><td><code>2</code></td><td>Only match the 2nd field.</td></tr><tr><td><code>-1</code></td><td>Only match the last field.</td></tr><tr><td><code>-2</code></td><td>Only match the 2nd to last field.</td></tr><tr><td><code>3..5</code></td><td>Only match from the 3rd to the 5th field.</td></tr><tr><td><code>2..</code></td><td>Only match from the 2nd to the last field.</td></tr><tr><td><code>..-3</code></td><td>Only match from the 1st to the 3rd to last field.</td></tr><tr><td><code>..</code></td><td>Match all the fields.</td></tr></tbody></table><p>In the fzf manual (<code>man fzf</code>), this is called the <code>FIELD INDEX EXPRESSION</code> ways of selecting fields. These values can also be used for the placeholder in fzf’s preview; we’ll see that in another section of this article.</p><h2 id="customizing-fzf-display">Customizing fzf Display</h2><p>Now that we have a good grasp of fzf’s basics, let’s see how we can customize its display. We can do a lot in that regard; for example, here are a couple of options we can use, to give you an overview:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>fzf --multi <span>\
</span></span></span><span><span><span></span>--height<span>=</span>50% <span>\
</span></span></span><span><span><span></span>--margin<span>=</span>5%,2%,2%,5% <span>\
</span></span></span><span><span><span></span>--layout<span>=</span>reverse-list <span>\
</span></span></span><span><span><span></span>--border<span>=</span>double <span>\
</span></span></span><span><span><span></span>--info<span>=</span>inline <span>\
</span></span></span><span><span><span></span>--prompt<span>=</span><span>&#39;$&gt;&#39;</span> <span>\
</span></span></span><span><span><span></span>--pointer<span>=</span><span>&#39;→&#39;</span> <span>\
</span></span></span><span><span><span></span>--marker<span>=</span><span>&#39;♡&#39;</span> <span>\
</span></span></span><span><span><span></span>--header<span>=</span><span>&#39;CTRL-c or ESC to quit&#39;</span> <span>\
</span></span></span><span><span><span></span>--color<span>=</span><span>&#39;dark,fg:magenta&#39;</span>
</span></span></code></pre></div><p>Here’s the resulting masterpiece of colors and forms:</p><picture><source srcset="https://thevaluable.dev/images/2023/fzf-guide/fzf-custom-display.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2023/fzf-guide/fzf-custom-display.jpg" alt="fzf with custom display"/></picture><p>Let’s look now at each of these options. If you’re not interested to customize fzf’s TUI, you can pass the whole section. You’re the reader, you decide.</p><h3 id="height">Height</h3><p>You don’t want fzf to take all the height of your terminal? Here are the options you can use to accommodate your sophisticated tastes:</p><table><tbody><tr><th>Option</th><th>Description</th><th>Default</th></tr><tr><td><code>--height</code></td><td>Height of fzf (rows or percentage). Can be prefixed by <code>~</code> to adapt the height depending on the number of entries.</td><td><code>100%</code></td></tr><tr><td><code>--min-height</code></td><td>Minimum height when <code>--height</code> is used with percentage.</td><td><code>10</code></td></tr></tbody></table><p>Here’s how you can use these options:</p><div><pre tabindex="0"><code data-lang="bash"><span><span><span># Height of 10 rows</span>
</span></span><span><span>fzf --height<span>=</span><span>10</span>
</span></span><span><span>
</span></span><span><span><span># Height of 10%</span>
</span></span><span><span>fzf --height<span>=</span>10%
</span></span><span><span>
</span></span><span><span><span># Height around 10%, depending on the number of entries</span>
</span></span><span><span>fzf --height<span>=</span>~10%
</span></span><span><span>
</span></span><span><span><span># Height of 30%, minimum height of 8 rows</span>
</span></span><span><span>fzf --height<span>=</span>30% --min-height<span>=</span><span>8</span>
</span></span></code></pre></div><h3 id="margins-and-padding">Margins and Padding</h3><p>We can also add margin and padding to fzf’s TUI:</p><table><tbody><tr><th>Option</th><th>Description</th><th>Default</th></tr><tr><td><code>--margin</code></td><td>Comma separated margin (similar to CSS) in absolute number or percentage.</td><td><code>0</code></td></tr><tr><td><code>--padding</code></td><td>Comma separated padding (similar to CSS) in absolute number or percentage.</td><td><code>0</code></td></tr></tbody></table><p>Here are some examples for adding a margin:</p><div><pre tabindex="0"><code data-lang="bash"><span><span><span># Margin of 10</span>
</span></span><span><span>fzf --margin<span>=</span><span>10</span>
</span></span><span><span>
</span></span><span><span><span># Margin of 10%</span>
</span></span><span><span>fzf --margin<span>=</span>10%
</span></span><span><span>
</span></span><span><span><span># Margin of 10% on top and bottom, 5% on left and right</span>
</span></span><span><span>fzf --margin<span>=</span>10%,5%
</span></span><span><span>
</span></span><span><span><span># Margin of 10% on top, 5% on left and right, 8% on bottom</span>
</span></span><span><span>fzf --margin<span>=</span>10%,5%,8%
</span></span><span><span>
</span></span><span><span><span># Margin of 10% on top, 3% on right, 8% on bottom, 5% on left</span>
</span></span><span><span>fzf --margin<span>=</span>10%,3%,8%,5%
</span></span></code></pre></div><p>The padding works similarly. Keep in mind that if you don’t have any border, there won’t be any visual difference between adding a margin and adding a padding.</p><h3 id="layout">Layout</h3><p>We can change the general layout with the option <code>--layout</code> (how surprising!). Here are the possible values:</p><table><tbody><tr><th>Value</th><th>Prompt’s position</th><th>List</th></tr><tr><td><code>default</code></td><td>Bottom</td><td>From bottom to top.</td></tr><tr><td><code>reverse</code></td><td>Top</td><td>From top to bottom.</td></tr><tr><td><code>reverse-list</code></td><td>Bottom</td><td>From top to bottom.</td></tr></tbody></table><p>You can also use the option <code>--reverse</code> instead of <code>--layout=reverse</code>. Both are equivalent.</p><h3 id="borders">Borders</h3><p>We can also display borders around fzf’s TUI, thanks to these magical options:</p><table><tbody><tr><th>Option</th><th>Description</th><th>Default</th></tr><tr><td><code>--border</code></td><td>Display a border.</td><td><code>none</code></td></tr><tr><td><code>--border-label</code></td><td>Label to display on the horizontal line of the border. Only some types of borders can have a label.</td><td>None</td></tr><tr><td><code>--border-label-position</code></td><td>Position of the border label. Positive numbers mean number of columns from the left (left-align), negative ones for number of columns from the right (right-align). Can add <code>:bottom</code> to put the label on the bottom line of the border.</td><td><code>0</code> (center)</td></tr></tbody></table><p>Here are the value we can use for the option <code>--border</code>:</p><table><tbody><tr><th>Border</th><th>Description</th></tr><tr><td><code>rounded</code></td><td>Rounded corners.</td></tr><tr><td><code>sharp</code></td><td>Sharp corners.</td></tr><tr><td><code>bold</code></td><td>Bold lines.</td></tr><tr><td><code>double</code></td><td>Double lines.</td></tr><tr><td><code>horizontal</code></td><td>Horizontal lines above and below.</td></tr><tr><td><code>vertical</code></td><td>Vertical lines on the left and right.</td></tr><tr><td><code>top</code></td><td>Only one border at the top.</td></tr><tr><td><code>bottom</code></td><td>Only one border at the bottom.</td></tr><tr><td><code>left</code></td><td>Only one border on the left.</td></tr><tr><td><code>right</code></td><td>Only one border on the right.</td></tr><tr><td><code>none</code></td><td>No border.</td></tr></tbody></table><p>As always, here are a couple of examples:</p><div><pre tabindex="0"><code data-lang="bash"><span><span><span># Top border and centered label</span>
</span></span><span><span>fzf --border<span>=</span>top --border-label<span>=</span><span>&#34;| My Cool Label |&#34;</span>
</span></span><span><span>
</span></span><span><span><span># Bold border and label 5 columns from the left</span>
</span></span><span><span>fzf --border<span>=</span>bold --border-label<span>=</span><span>&#34;| My Cool Label |&#34;</span> <span>\
</span></span></span><span><span><span></span>--border-label-pos<span>=</span><span>5</span>
</span></span><span><span>
</span></span><span><span><span># Horizontal border and label 5 columns from the right</span>
</span></span><span><span>fzf --border<span>=</span>horizontal --border-label<span>=</span><span>&#34;| My Cool Label |&#34;</span> <span>\
</span></span></span><span><span><span></span>--border-label-pos<span>=</span>-5
</span></span></code></pre></div><h3 id="the-info-line">The Info Line</h3><p>If you open fzf, you’ll notice that there is an info line just between the matched entries and the prompt. By default, it displays the number of matched entries and the total number of entries. If you allowed multi-selection like a boss, the count of selected entries will also be displayed in parentheses.</p><p>We can display this info line in three different ways, thanks to the value of the option <code>--info</code>. Here are the possible ones:</p><table><tbody><tr><th>Value</th><th>Description</th></tr><tr><td><code>default</code></td><td>The info line is just above the prompt (or below if the layout is reversed).</td></tr><tr><td><code>inline</code></td><td>The info line is at the same level as the prompt.</td></tr><tr><td><code>hidden</code></td><td>The info line doesn’t appear at all.</td></tr></tbody></table><p>Do you want some examples?</p><div><pre tabindex="0"><code data-lang="bash"><span><span><span># Inline the info line with the prompt</span>
</span></span><span><span>fzf --info<span>=</span>inline
</span></span><span><span>
</span></span><span><span><span># Hide the info line</span>
</span></span><span><span>fzf --info<span>=</span>hidden
</span></span></code></pre></div><h3 id="prompt-pointer-and-multi-marker">Prompt, Pointer, and Multi-Marker</h3><p>By now I’m sure you’re realizing how much we can customize fzf’s display, to make the most beautiful fuzzy finder in the galaxy. The prompt, pointer (the pointer pointing to the current entry), and multi-markers (the characters marking the selections, if multi-selection is enabled) are no exceptions: we can change them following our craziest artistic inspirations.</p><p>Here are the options allowing us to do exactly what I just wrote:</p><table><tbody><tr><th>Option</th><th>Description</th><th>Default</th><th>Character limit</th></tr><tr><td><code>--prompt</code></td><td>Change the prompt’s character.</td><td><code>&gt;</code></td><td>None</td></tr><tr><td><code>--pointer</code></td><td>Change the pointer’s character.</td><td><code>&gt;</code></td><td>2</td></tr><tr><td><code>--marker</code></td><td>Change the multi-markers’ character.</td><td><code>&gt;</code></td><td>2</td></tr></tbody></table><p>Here’s an example:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>fzf -m --prompt<span>=</span><span>&#39;▶&#39;</span> --pointer<span>=</span><span>&#39;→&#39;</span> --marker<span>=</span><span>&#39;♡&#39;</span>
</span></span></code></pre></div><p>How lovely!</p><p>What about adding a header to our TUI? This can be useful to give some information to the user, especially when we’ll begin to create keystrokes for fzf; again, we’ll see that later in this article.</p><p>The header will appear near the prompt, above or below, depending on the layout. Here are the options you can use to craft the header of your dreams:</p><table><tbody><tr><th>Option</th><th>Description</th></tr><tr><td><code>--header</code></td><td>The header’s content.</td></tr><tr><td><code>--header-lines</code></td><td>When given a positive number N, the first N lines of input are used as header.</td></tr><tr><td><code>--header-first</code></td><td>Display the header before the prompt.</td></tr></tbody></table><p>Some inspiration:</p><div><pre tabindex="0"><code data-lang="bash"><span><span><span># The header is above the prompt</span>
</span></span><span><span>fzf --header<span>=</span><span>&#34;Use CTRL-C to cancel&#34;</span> --header-first --reverse
</span></span><span><span>
</span></span><span><span><span># Display the first line of output from the command &#34;lsblk&#34; as header.</span>
</span></span><span><span><span># It won&#39;t be possible to fuzzy search for this line anymore.</span>
</span></span><span><span>lsblk <span>|</span> fzf --header-lines<span>=</span><span>1</span>
</span></span></code></pre></div><h3 id="colors">Colors</h3><p>We have now a good understanding on how to configure fzf’s display. Let’s finish this section beautifully, by looking at the colors we can give to our favorite fuzzy finder.</p><h4 id="colorful-options">Colorful Options</h4><p>Here are the options available to manipulate fzf’s color scheme:</p><table><tbody><tr><th>Option</th><th>Description</th></tr><tr><td><code>--ansi</code></td><td>Allow the processing of <a href="https://en.wikipedia.org/wiki/ANSI_escape_code#Colors" target="_blank" rel="noopener">ANSI color code</a>.</td></tr><tr><td><code>--color</code></td><td>Change colors for the different elements of the TUI.</td></tr><tr><td><code>--no-color</code></td><td>Don’t use any color (black &amp; white).</td></tr></tbody></table><p>Here’s the general pattern to change the color of specific elements:</p><div><pre tabindex="0"><code data-lang="text"><span><span>--color=[BASE_SCHEME][,COLOR_NAME[:ANSI_COLOR][:ANSI_ATTRIBUTES]]...
</span></span></code></pre></div><p>Keep in mind that the notation you can use for your colors depends on your terminal; more specifically, if it can display 16, 256 colors, or 24-bit colors.</p><p>Here are the usual examples:</p><div><pre tabindex="0"><code data-lang="bash"><span><span><span># Use ANSI color code (bright red)</span>
</span></span><span><span><span># The first &#39;^[&#39; is an ESC character - you can spit it with &#39;CTRL-v ESC&#39;</span>
</span></span><span><span><span>echo</span> <span>&#34;^[[1;31mHello&#34;</span> <span>|</span> fzf --ansi
</span></span><span><span>
</span></span><span><span><span># The text of the current entry is red on a &#34;dark&#34; base scheme (ANSI 256 colors).</span>
</span></span><span><span>fzf --color<span>=</span><span>&#39;dark,fg+:red&#39;</span>
</span></span><span><span>
</span></span><span><span><span># The text of the current entry is red, and the other entries are blue (ANSI 256 colors).</span>
</span></span><span><span>fzf --color<span>=</span><span>&#39;fg+:red,fg:117&#39;</span>
</span></span><span><span>
</span></span><span><span><span># The text of the current line is red, and the other entries are blue (24 bits colors).</span>
</span></span><span><span>fzf --color<span>=</span><span>&#39;fg+:#ff0000,fg:#0000ff&#39;</span>
</span></span></code></pre></div><p>You can also use the ANSI color <code>-1</code> to use the background color of your terminal.</p><p>Note that the base scheme is not specified for the two last examples; in that case, it will fallback to the default one. But, you might wonder: what’s this base scheme? I’m happy you ask the question.</p><h4 id="base-scheme">Base Scheme</h4><p>The base scheme gives you some default colors you can then overwrite as you see fit. Here are the ones you can use:</p><table><tbody><tr><th>Scheme</th><th>Description</th></tr><tr><td><code>dark</code></td><td>Dark color scheme for 256-color terminals (default for any 256 color terminal).</td></tr><tr><td><code>light</code></td><td>Light color scheme for light 256-color terminal.</td></tr><tr><td><code>16</code></td><td>Color scheme for 16-color terminal.</td></tr><tr><td><code>bw</code></td><td>Black and white (equivalent to <code>--no-color</code>).</td></tr></tbody></table><p>For example, if you want to use the light base scheme, you can run:</p><h4 id="colors-but-for-what">Colors… But for What?</h4><p>All of that is great, but on what elements can we apply these new colors? Here’s the complete list:</p><table><tbody><tr><th>Element</th><th>Description</th></tr><tr><td><code>fg</code></td><td>Text of the entries (except the current line).</td></tr><tr><td><code>fg+</code></td><td>Text of the current line.</td></tr><tr><td><code>bg</code></td><td>General background (except the current line).</td></tr><tr><td><code>bg+</code></td><td>Current’s line background.</td></tr><tr><td><code>preview-fg</code></td><td>Preview window’s text.</td></tr><tr><td><code>preview-bg</code></td><td>Preview window’s background.</td></tr><tr><td><code>hl</code></td><td>Highlighted substrings.</td></tr><tr><td><code>hl+</code></td><td>Highlighted substrings for the current line.</td></tr><tr><td><code>gutter</code></td><td>Gutter on the left (get the value of <code>bg+</code> if not specified).</td></tr><tr><td><code>query</code></td><td>Query string.</td></tr><tr><td><code>disabled</code></td><td>Query string when search is disabled.</td></tr><tr><td><code>info</code></td><td>Info line.</td></tr><tr><td><code>separator</code></td><td>Horizontal separator of the info line.</td></tr><tr><td><code>border</code></td><td>Border around the window (used by <code>--border</code> and <code>--preview</code>).</td></tr><tr><td><code>label</code></td><td>Border’s label (used by <code>--border-label</code> and <code>--preview-label</code>)</td></tr><tr><td><code>prompt</code></td><td>Prompt.</td></tr><tr><td><code>pointer</code></td><td>Pointer.</td></tr><tr><td><code>marker</code></td><td>Multi-select markers.</td></tr><tr><td><code>spinner</code></td><td>Loading input indicator.</td></tr><tr><td><code>header</code></td><td>Header.</td></tr></tbody></table><p>For example, here are the colors I’m using:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>fzf --color<span>=</span><span>&#34;bg+:-1,\
</span></span></span><span><span><span>fg:gray,\
</span></span></span><span><span><span>fg+:white,\
</span></span></span><span><span><span>border:black,\
</span></span></span><span><span><span>spinner:0,\
</span></span></span><span><span><span>hl:yellow,\
</span></span></span><span><span><span>header:blue,\
</span></span></span><span><span><span>info:green,\
</span></span></span><span><span><span>pointer:red,\
</span></span></span><span><span><span>marker:blue,\
</span></span></span><span><span><span>prompt:gray,\
</span></span></span><span><span><span>hl+:red&#34;</span>
</span></span></code></pre></div><p>As you can see, some elements are related to some preview. What’s that?</p><h2 id="preview-in-fzf">Preview in fzf</h2><p>We can preview the current entry in fzf using a command of our choice. Let’s see how.</p><h3 id="displaying-a-preview">Displaying a Preview</h3><p>Here are all the different options we can use to display a preview in fzf:</p><table><tbody><tr><th>Option</th><th>Description</th></tr><tr><td><code>--preview</code></td><td>Execute the given command for the current line, and display the result in the preview window. The placeholder <code>{}</code> is replaced in the command by the current entry (single-quoted).</td></tr><tr><td><code>--preview-window</code></td><td>General display of the preview window, including position, border…</td></tr><tr><td><code>--preview-label</code></td><td>Label to display on the horizontal line of the preview window. Can only be used when a border is present (using the <code>--preview-window</code> option).</td></tr><tr><td><code>--preview-label-pos</code></td><td>Position of the border’s label on the preview window. Positive numbers represent the number of columns on the left (left-align), negative numbers the number of columns on the right (right-align). <code>0</code> (the default) for center. Can add <code>:bottom</code> to put the label on the bottom line of the border.</td></tr></tbody></table><p>These options are not very intuitive; let’s try some examples:</p><div><pre tabindex="0"><code data-lang="bash"><span><span><span># Display the stats of each directory using the CLI &#34;stat&#34;</span>
</span></span><span><span><span># For example, if the current entry is &#34;./home&#34;, the preview command will be &#34;stat &#39;./home&#39;&#34;</span>
</span></span><span><span>find . -type d <span>|</span> fzf --preview<span>=</span><span>&#39;stat {}&#39;</span>
</span></span><span><span>
</span></span><span><span><span># Display the preview window with a label centered on top.</span>
</span></span><span><span>find . -type d <span>|</span> fzf --preview<span>=</span><span>&#39;stat {}&#39;</span> <span>\
</span></span></span><span><span><span></span>--preview-label<span>=</span><span>&#39;[ Directory stats ]&#39;</span>
</span></span><span><span>
</span></span><span><span><span># Display the preview window with a label at the bottom, 3 rows from the left.</span>
</span></span><span><span>find . -type d <span>|</span> fzf --preview<span>=</span><span>&#39;stat {}&#39;</span> <span>\
</span></span></span><span><span><span></span>--preview-label<span>=</span><span>&#39;[ Directory stats ]&#39;</span> <span>\
</span></span></span><span><span><span></span>--preview-label-pos<span>=</span><span>&#39;3:bottom&#39;</span>
</span></span></code></pre></div><p>Using our <a href="https://github.com/Phantas0s/the_valuable_dev_companion/tree/main/guide-fzf" target="_blank" rel="noopener">companion project</a>, here’s the result for the last example:</p><picture><source srcset="https://thevaluable.dev/images/2023/fzf-guide/fzf-preview.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2023/fzf-guide/fzf-preview.jpg" alt="Adding a preview to fzf&#39;s TUI"/></picture><p>If the preview window is too small to display everything, you can still scroll through thanks to these default keystrokes:</p><table><tbody><tr><th>Keystroke</th><th>Description</th></tr><tr><td><code>SHIFT-UP</code></td><td>Scroll the preview one line up.</td></tr><tr><td><code>SHIFT-DOWN</code></td><td>Scroll the preview one line down.</td></tr></tbody></table><h3 id="previews-placeholder">Preview’s Placeholder</h3><p>If the placeholder <code>{}</code> as an integer N between the curly bracket, it will be replaced by the Nth field of the preview’s command output. By default, the field delimiter is space (AWK style).</p><p>For example, let’s say that you want to add a number on each line to select them more easily (by just querying the number you want, instead of the directory itself). We already saw how to do that above, using the CLI “nl”:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>find . -type d <span>|</span> nl <span>|</span> fzf --preview<span>=</span><span>&#39;stat {}&#39;</span> <span>\
</span></span></span><span><span><span></span>--preview-label<span>=</span><span>&#39;[ Directory stats ]&#39;</span>
</span></span></code></pre></div><p>If you run the above, you’ll notice that… it doesn’t work! The placeholder will be replaced by the whole entry line, including the prefixed number. If you want to replace the placeholder with only the second field of your entry, you can do:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>find . -type d <span>|</span> nl <span>|</span> fzf --preview<span>=</span><span>&#39;stat {2}&#39;</span> <span>\
</span></span></span><span><span><span></span>--preview-label<span>=</span><span>&#39;[ Directory stats ]&#39;</span>
</span></span></code></pre></div><p>This is similar to the option <code>--nth</code> (see the above section Limiting the Search). You can also use the option <code>--delimiter</code> to use a different delimiter instead of space. For example, if we have a comma <code>,</code> as delimiter:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>find . -type d <span>|</span> nl -s <span>&#39;,&#39;</span> <span>|</span> fzf --delimiter<span>=</span><span>&#39;,&#39;</span> --preview<span>=</span><span>&#39;stat {2}&#39;</span> <span>\
</span></span></span><span><span><span></span>--preview-label<span>=</span><span>&#39;[ Directory stats ]&#39;</span>
</span></span></code></pre></div><p>We can also put some flags between the curly brackets <code>{}</code> of the placeholder for different effects:</p><table><tbody><tr><th>Placeholder</th><th>Description</th></tr><tr><td><code>{+}</code></td><td>Display the preview for all entries selected if you can select more than one (multi-selection enabled).</td></tr><tr><td><code>{s}</code></td><td>Keep leading and trailing whitespace if you use a specific field instead of the whole entry.</td></tr><tr><td><code>{q}</code></td><td>Replace the placeholder with the query string.</td></tr><tr><td><code>{n}</code></td><td>Replace the placeholder by the line number (zero-based).</td></tr></tbody></table><p>You can combine integers (to select different fields) and flags. For example, <code>{+1}</code> or <code>{+n}</code></p><div><pre tabindex="0"><code data-lang="bash"><span><span>find . -type d <span>|</span> fzf <span>\
</span></span></span><span><span><span></span>--preview<span>=</span><span>&#39;echo &#34;File(s) with index(es) {+n} and query {q} \n&#34; &amp;&amp; ls -l {-1}&#39;</span> <span>\
</span></span></span><span><span><span></span>--preview-label<span>=</span><span>&#39;[ Directory stats ]&#39;</span>
</span></span></code></pre></div><p>The result:</p><picture><source srcset="https://thevaluable.dev/images/2023/fzf-guide/fzf-preview-placeholder.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2023/fzf-guide/fzf-preview-placeholder.jpg" alt="Using different preview placehoders with fzf with different flags"/></picture><p>Here’s a question which will help us build our file explorer: how to display all directories and the first 50 lines of their file trees in the preview? You can use the CLI “tree” and “head” to do so. It should give you something like this:</p><picture><source srcset="https://thevaluable.dev/images/2023/fzf-guide/fzf-preview-tree.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2023/fzf-guide/fzf-preview-tree.jpg" alt="Using fzf and a preview generated with the CLI tree"/></picture><div id="toggle-3"><p><label for="toggle-input-3">Click to see the solution</label>
</p><div><div><pre tabindex="0"><code data-lang="bash"><span><span>find . -type d <span>|</span> fzf --preview<span>=</span><span>&#39;tree -C {} | head -n 50&#39;</span>
</span></span></code></pre></div><p>The CLI <code>tree</code> normally displays files and directories of the directory given as argument. With the option <code>-C</code>, it only displays directories.</p></div></div><p>What about modifying the display of the preview window thanks to the <code>--preview-window</code> option?</p><h3 id="layout-of-the-preview-window">Layout of the Preview Window</h3><p>Here’s the general pattern you can use with the option <code>--preview-window</code> to modify its display:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>--preview-window<span>=[</span>POSITION<span>][</span>,SIZE<span>[</span>%<span>]][</span>,border-BORDER_OPT<span>][</span>,<span>[</span>no<span>]</span>wrap<span>][</span>,<span>[</span>no<span>]</span>follow<span>][</span>,<span>[</span>no<span>]</span>cycle<span>][</span>,<span>[</span>no<span>]</span>hidden<span>][</span>,+SCROLL<span>[</span>OFFSETS<span>][</span>/DENOM<span>]][</span>,~HEADER_LINES<span>][</span>,default<span>]</span><span>`</span>
</span></span></code></pre></div><p>That’s a lot of different values in there! Let’s look at each of them:</p><table><tbody><tr><th>Value</th><th>Description</th><th>Default</th></tr><tr><td><code>POSITION</code></td><td>Position of the window; <code>left</code>, <code>right</code>, <code>top</code>, or <code>bottom</code>.</td><td><code>right</code></td></tr><tr><td><code>SIZE</code></td><td>Height of the window, in rows or percentage.</td><td><code>50%</code></td></tr><tr><td><code>border-BORDER_OPT</code></td><td>Add a border. The placeholder <code>BORDER_OPT</code> can be replaced with one of the borders seen above.</td><td><code>border-rounded</code></td></tr><tr><td><code>wrap</code> or <code>nowrap</code></td><td>Wrap the line</td><td><code>nowrap</code></td></tr><tr><td><code>follow</code> or <code>nofollow</code></td><td>Automatically scroll to the bottom of the preview window.</td><td><code>nofollow</code></td></tr><tr><td><code>cycle</code> or <code>nocycle</code></td><td>Enable cyclic scroll (come back to the beginning when the end is reached).</td><td><code>nocycle</code></td></tr><tr><td><code>hidden</code> or <code>nohidden</code></td><td>Hide the preview window. Can only be shown when keybinding the <code>toggle-preview</code> action (see <a href="">below</a>).</td><td><code>nohidden</code></td></tr><tr><td><code>+SCROLL[OFFSETS][/DENOM]</code></td><td>Set an offset for the preview’s window scroll. See the man page for more details.</td><td><ul><li></li></ul></td></tr><tr><td><code>~HEADER_LINES</code></td><td>Always keep the N lines of the preview on top of the preview window.</td><td><ul><li></li></ul></td></tr><tr><td><code>default</code></td><td>Reset any option set before to the default.</td><td><ul><li></li></ul></td></tr></tbody></table><p>You can use these values in any order. For example:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>find . -type d <span>|</span> fzf <span>\
</span></span></span><span><span><span></span>--preview<span>=</span><span>&#39;tree -C {} | head -n 50&#39;</span> <span>\
</span></span></span><span><span><span></span>--preview-window<span>=</span>70%,border-double,top
</span></span></code></pre></div><p>The result you’ve been waiting for all your life:</p><picture><source srcset="https://thevaluable.dev/images/2023/fzf-guide/fzf-preview-custom-display.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2023/fzf-guide/fzf-preview-custom-display.jpg" alt="Using fzf and a preview generated with the CLI tree and a custom display"/></picture><h2 id="binding-keystrokes-or-events-to-actions">Binding Keystrokes or Events to Actions</h2><p>We can now create a custom file explorer, even with a preview window if we want to. But we’re missing an important feature: being able to bind keystrokes to different commands. It would be nice, for example, to be able to refresh the list of files or directories, in case some were created after opening the file explorer itself.</p><h3 id="the-bind-option">The Bind Option</h3><p>Here’s the option we’ll use a lot below:</p><table><tbody><tr><th>Option</th><th>Description</th></tr><tr><td><code>--bind</code></td><td>Comma-separated list of pairs of keybindings (or events) and actions.</td></tr></tbody></table><p>For example, to reload a directory list:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>find . -type d <span>|</span> fzf <span>\
</span></span></span><span><span><span></span>--bind<span>=</span><span>&#39;ctrl-r:reload(find -type d)&#39;</span> <span>\
</span></span></span><span><span><span></span>--header<span>=</span><span>&#39;CTRL-r to refresh the list&#39;</span>
</span></span></code></pre></div><p>To test if it works as expected, you can try to:</p><ol><li>Run the command above.</li><li>Create another directory in another shell.</li><li>Refresh fzf’s entry list with `CTRL-r.</li><li>The directory you’ve created should appear programagically.</li></ol><p>As you can see, the pair of keybinding (<code>ctrl-r</code>) and action (<code>reload(find -type d)</code>) is separated by a colon <code>:</code>. We can add more of these pairs; for example, if we want to delete the current directory (with a prompt asking if we really want to to that), we can do the following:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>find . -type d <span>|</span> fzf  <span>\
</span></span></span><span><span><span></span>--bind <span>&#39;ctrl-r:reload(find -type d),del:execute(rm -ri {})&#39;</span> <span>\
</span></span></span><span><span><span></span>--header<span>=</span><span>&#39;CTRL-R to refresh the list | CTRL-P to toggle the preview | DEL to delete the current directory&#39;</span>
</span></span></code></pre></div><p>The action <code>execute</code> is very useful: it can execute any arbitrary command <em>in a subshell</em>; the placeholder <code>{}</code> is replaced with the value of the current entry. This placeholder works exactly like the preview’s placeholder we’ve discussed above.</p><p>It would also be nice to automatically reload the list after deleting a directory, for it not to appear as an entry in fzf. To chain different actions to the same keystroke, we can use the <code>+</code> separator, as follows:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>find . -type d <span>|</span> fzf <span>\
</span></span></span><span><span><span></span>--bind<span>=</span><span>&#39;ctrl-r:reload(find -type d)&#39;</span> <span>\
</span></span></span><span><span><span></span>--bind<span>=</span><span>&#39;del:execute(rm -ri {})&#39;</span> <span>\
</span></span></span><span><span><span></span>--bind<span>=</span><span>&#39;del:+reload(find -type d)&#39;</span> <span>\
</span></span></span><span><span><span></span>--header<span>=</span><span>&#39;CTRL-R to refresh the list | CTRL-P to toggle the preview | DEL to delete the current directory&#39;</span>
</span></span></code></pre></div><p>As you can see, our command to create fzf’s entries (<code>find . -type d</code>) begins to be repeated all over the place. We can create a variable for that and use it everywhere:</p><div><pre tabindex="0"><code data-lang="bash"><span><span><span>FZF_EXPLORER_CMD</span><span>=</span><span>&#34;find . -type d&#34;</span> <span>&amp;&amp;</span> <span>\
</span></span></span><span><span><span></span><span>eval</span> <span>$FZF_EXPLORER_CMD</span> <span>|</span> fzf
</span></span><span><span>--bind <span>&#34;ctrl-r:reload(</span><span>$FZF_EXPLORER_CMD</span><span>)&#34;</span> <span>\
</span></span></span><span><span><span></span>--bind <span>&#39;del:execute(rm -ri {})&#39;</span> <span>\
</span></span></span><span><span><span></span>--bind <span>&#34;del:+reload(</span><span>$FZF_EXPLORER_CMD</span><span>)&#34;</span> <span>\
</span></span></span><span><span><span></span>--header<span>=</span><span>&#39;CTRL-R to refresh the list | CTRL-P to toggle the preview | DEL to delete the current directory&#39;</span>
</span></span></code></pre></div><p>Remember <code>FZF_DEFAULT_COMMAND</code>? It’s the default command used by fzf under the hood when we don’t give any input. If you don’t mind overwriting this environment variable the time of a command, you can do the following:</p><div><pre tabindex="0"><code data-lang="bash"><span><span><span>FZF_DEFAULT_COMMAND</span><span>=</span><span>&#34;find . -type d&#34;</span> <span>\
</span></span></span><span><span><span></span>fzf --preview<span>=</span><span>&#39;tree -C {}&#39;</span> <span>\
</span></span></span><span><span><span></span>--bind<span>=</span><span>&#39;ctrl-r:reload(eval $FZF_DEFAULT_COMMAND)&#39;</span> <span>\
</span></span></span><span><span><span></span>--bind<span>=</span><span>&#39;del:execute(rm -ri {})&#39;</span> <span>\
</span></span></span><span><span><span></span>--bind<span>=</span><span>&#39;del:+reload(eval $FZF_DEFAULT_COMMAND)&#39;</span> <span>\
</span></span></span><span><span><span></span>--header<span>=</span><span>&#39;CTRL-R to refresh the list | CTRL-P to toggle the preview | DEL to delete the current directory&#39;</span>
</span></span></code></pre></div><h3 id="using-events-and-actions">Using Events and Actions</h3><p>We’ve bound keystrokes and actions until now, but there are also a couple of events we can use instead of these keystrokes. Here’s the complete list:</p><table><tbody><tr><th>Event</th><th>Description</th></tr><tr><td><code>start</code></td><td>Triggered when fzf starts.</td></tr><tr><td><code>change</code></td><td>Triggered when the query is changed.</td></tr><tr><td><code>backward-eof</code></td><td>Triggered when the query is empty but the user still tries to delete characters backward.</td></tr></tbody></table><p>Taking back our example above, we could refresh the list of directory each time we change our query:</p><div><pre tabindex="0"><code data-lang="bash"><span><span><span>FZF_DEFAULT_COMMAND</span><span>=</span><span>&#34;find . -type d&#34;</span> fzf <span>\
</span></span></span><span><span><span></span>--bind<span>=</span><span>&#39;change:reload(eval $FZF_DEFAULT_COMMAND)&#39;</span> <span>\
</span></span></span><span><span><span></span>--bind<span>=</span><span>&#39;del:execute(rm -ri {})&#39;</span> <span>\
</span></span></span><span><span><span></span>--bind<span>=</span><span>&#39;del:+reload(eval $FZF_DEFAULT_COMMAND)&#39;</span> <span>\
</span></span></span><span><span><span></span>--header<span>=</span><span>&#39;CTRL-R to refresh the list | CTRL-P to toggle the preview | DEL to delete the current directory&#39;</span>
</span></span></code></pre></div><p>Be careful if you use the <code>start</code> event: fzf creates the list of entries asynchronously, which means that you might not have all entries when the event is triggered. In that case, use the fzf option <code>--sync</code> to build the list synchronously, only displaying the TUI (and triggering the <code>start</code> event) after all entries have been generated. The downside: it might feel slower, because you won’t see the TUI until the list is fully built.</p><h3 id="useful-actions">Useful Actions</h3><p>I won’t list all the possible actions we can bind in this article. You can have the complete list by looking at the fzf’s manual page (<code>man fzf</code>, search for <code>AVAILABLE ACTIONS</code>).</p><p>Some actions take arguments, some don’t. Actions with arguments are suffixed below with <code>(...)</code>, exactly like in fzf’s manual page:</p><table><tbody><tr><th>Action</th><th>Description</th></tr><tr><td><code>execute(...)</code></td><td>Switch to the alternate screen and execute a command in a <code>sh</code> subshell. Return to fzf when it’s done. Similarly to the <code>--preview</code> option, you can use a placeholder <code>{}</code> for the current entry.</td></tr><tr><td><code>execute-silent(...)</code></td><td>Execute a command in a <code>sh</code> subshell, in the current screen, without leaving fzf (but block fzf the time the command run). Similarly to <code>--preview</code>, you can use the placeholder <code>{}</code> for the current entry.</td></tr><tr><td><code>preview(...)</code></td><td>Specify one more preview command, additionally to the one given to the <code>--preview</code> option.</td></tr><tr><td><code>change-preview(...)</code></td><td>Change the <code>--preview</code> option.</td></tr><tr><td><code>refresh-preview</code></td><td>Refresh the preview.</td></tr><tr><td><code>change-preview-window(...)</code></td><td>Change the value of <code>--preview-window</code>. Use the delimiter <code>|</code> to create (and cycle through) different groups of options.</td></tr><tr><td><code>change-prompt(...)</code></td><td>Change the prompt to the given characters.</td></tr><tr><td><code>reload(...)</code></td><td>Reload the list of entries with the given command.</td></tr><tr><td><code>select-all</code></td><td>Select all matches.</td></tr><tr><td><code>deselect-all</code></td><td>Clear the selection.</td></tr><tr><td><code>toggle-all</code></td><td>Toggle all matches.</td></tr><tr><td><code>toggle-sort</code></td><td>Toggle the sorting.</td></tr><tr><td><code>replace-query</code></td><td>Replace the query with the current selection.</td></tr><tr><td><code>clear-query</code></td><td>Delete the query.</td></tr><tr><td><code>unbind(...)</code></td><td>Unbind a binding keystroke.</td></tr><tr><td><code>rebind(...)</code></td><td>Rebind a keystroke after unbinding it.</td></tr><tr><td><code>abort</code></td><td>Close fzf.</td></tr></tbody></table><p>You know what’s next: yep, some examples.</p><div><pre tabindex="0"><code data-lang="bash"><span><span><span># Close fzf with CTRL-D</span>
</span></span><span><span>fzf --bind<span>=</span><span>&#39;ctrl-d:abort&#39;</span>
</span></span><span><span>
</span></span><span><span><span># Display the preview with CTRL-P</span>
</span></span><span><span>fzf --preview-window<span>=</span>hidden --bind<span>=</span><span>&#39;ctrl-p:preview(stat {})&#39;</span>
</span></span><span><span>
</span></span><span><span><span># Change the preview with CTRL-P</span>
</span></span><span><span>fzf --preview<span>=</span><span>&#39;file {}&#39;</span> <span>\
</span></span></span><span><span><span></span>--bind<span>=</span><span>&#39;ctrl-p:change-preview(stat {})&#39;</span>
</span></span><span><span>
</span></span><span><span><span># Change the position and size of the preview window with CTRL-P</span>
</span></span><span><span>fzf --preview<span>=</span><span>&#39;file {}&#39;</span> <span>\
</span></span></span><span><span><span></span>--bind<span>=</span><span>&#39;ctrl-p:change-preview-window(20%,top|50%,right)&#39;</span>
</span></span><span><span>
</span></span><span><span><span># Change the prompt with CTRL-P</span>
</span></span><span><span>fzf --preview<span>=</span><span>&#39;file {}&#39;</span> <span>\
</span></span></span><span><span><span></span>--bind<span>=</span><span>&#39;ctrl-p:change-prompt(→ )&#39;</span>
</span></span><span><span>
</span></span><span><span><span># Delete the file or directory with DEL</span>
</span></span><span><span>fzf --preview<span>=</span><span>&#39;file {}&#39;</span> <span>\
</span></span></span><span><span><span></span>--bind<span>=</span><span>&#39;del:execute(rm -ri {})&#39;</span>
</span></span><span><span>
</span></span><span><span><span># Reload the list of files</span>
</span></span><span><span>find . -type f <span>|</span> fzf <span>\
</span></span></span><span><span><span></span>--bind<span>=</span><span>&#39;ctrl-r:reload(find . -type f)&#39;</span>
</span></span><span><span>
</span></span><span><span><span># Bind CTRL-A to select all entries</span>
</span></span><span><span><span># Unbind CTRL-A and rebind it with, respectively, CTRL-U and CTRL-R</span>
</span></span><span><span>find . -type f <span>|</span> fzf --multi <span>\
</span></span></span><span><span><span></span>--bind<span>=</span><span>&#39;ctrl-a:select-all&#39;</span> <span>\
</span></span></span><span><span><span></span>--bind<span>=</span><span>&#39;ctrl-u:unbind(ctrl-a)&#39;</span> <span>\
</span></span></span><span><span><span></span>--bind<span>=</span><span>&#39;ctrl-r:rebind(ctrl-a)&#39;</span>
</span></span></code></pre></div><h2 id="putting-it-together-a-file-explorer-with-fzf">Putting it Together: a File Explorer with fzf</h2><p>It’s time! We looked at fzf enough to be able to create our file explorer. Here are the requirements:</p><ul><li>It should display files by hitting <code>CTRL-f</code>, or directories by hitting <code>CTRL-d</code>.</li><li>It should display directories by default.</li><li>The user should know what keystrokes she can use.</li><li>The user should be able to select one or multiple files or directories.</li><li>Switching to files or directories should refresh fzf’s list as well as the preview.</li><li>Both files and directories should be open using the default text editor when hitting <code>ENTER</code>.</li><li>Everything can be selected with <code>CTRL-a</code>.</li><li>Everything can be de-selected with <code>CTRL-x</code>.</li><li>The preview window can be hidden with <code>CTRL-p</code></li><li>The user can delete selected files or directories with <code>DEL</code>. There should be a prompt to confirm the choice.</li></ul><p>Concerning the TUI:</p><ul><li>The height should be 90%.</li><li>The preview window should be 45% wide, on the right.</li><li>The border should be sharp.</li><li>The border of the preview window should be sharp.</li></ul><p>If files are displayed:</p><ul><li>The prompt should be <code>Files &gt; </code>.</li><li>The preview should be the content of the current file.</li></ul><p>If directories are displayed:</p><ul><li>The prompt should be <code>Dirs &gt; </code>.</li><li>The preview should be the tree of the current directory.</li></ul><p>So, how would you build that? Don’t worry if you don’t succeed: the most important is to try. It will help you remember the solution.</p><p>Here’s the result:</p><a href="https://thevaluable.dev/images/2023/fzf-guide/fzf-file-explorer-org.png"><figure><picture><source srcset="https://thevaluable.dev/images/2023/fzf-guide/fzf-file-explorer.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2023/fzf-guide/fzf-file-explorer.jpg" alt="Using fzf as a file explorer (or a directory explorer)"/></picture><figcaption>Click to enlarge</figcaption></figure></a><div id="toggle-4"><p><label for="toggle-input-4">Click to see the solution</label>
</p><div><p>Here’s my solution:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>find -type d <span>|</span> fzf --multi --height<span>=</span>80% --border<span>=</span>sharp <span>\
</span></span></span><span><span><span></span>--preview<span>=</span><span>&#39;tree -C {}&#39;</span> --preview-window<span>=</span><span>&#39;45%,border-sharp&#39;</span> <span>\
</span></span></span><span><span><span></span>--prompt<span>=</span><span>&#39;Dirs &gt; &#39;</span> <span>\
</span></span></span><span><span><span></span>--bind<span>=</span><span>&#39;enter:execute($EDITOR {+})&#39;</span> <span>\
</span></span></span><span><span><span></span>--bind<span>=</span><span>&#39;del:execute(rm -ri {+})&#39;</span> <span>\
</span></span></span><span><span><span></span>--bind<span>=</span><span>&#39;ctrl-p:toggle-preview&#39;</span> <span>\
</span></span></span><span><span><span></span>--bind<span>=</span><span>&#39;ctrl-d:change-prompt(Dirs &gt; )&#39;</span> <span>\
</span></span></span><span><span><span></span>--bind<span>=</span><span>&#39;ctrl-d:+reload(find -type d)&#39;</span> <span>\
</span></span></span><span><span><span></span>--bind<span>=</span><span>&#39;ctrl-d:+change-preview(tree -C {})&#39;</span> <span>\
</span></span></span><span><span><span></span>--bind<span>=</span><span>&#39;ctrl-d:+refresh-preview&#39;</span> <span>\
</span></span></span><span><span><span></span>--bind<span>=</span><span>&#39;ctrl-f:change-prompt(Files &gt; )&#39;</span> <span>\
</span></span></span><span><span><span></span>--bind<span>=</span><span>&#39;ctrl-f:+reload(find -type f)&#39;</span> <span>\
</span></span></span><span><span><span></span>--bind<span>=</span><span>&#39;ctrl-f:+change-preview(cat {})&#39;</span> <span>\
</span></span></span><span><span><span></span>--bind<span>=</span><span>&#39;ctrl-f:+refresh-preview&#39;</span> <span>\
</span></span></span><span><span><span></span>--bind<span>=</span><span>&#39;ctrl-a:select-all&#39;</span> <span>\
</span></span></span><span><span><span></span>--bind<span>=</span><span>&#39;ctrl-x:deselect-all&#39;</span> <span>\
</span></span></span><span><span><span></span>--header <span>&#39;
</span></span></span><span><span><span>CTRL-D to display directories | CTRL-F to display files
</span></span></span><span><span><span>CTRL-A to select all | CTRL-x to deselect all
</span></span></span><span><span><span>ENTER to edit | DEL to delete
</span></span></span><span><span><span>CTRL-P to toggle preview
</span></span></span><span><span><span>&#39;</span>
</span></span></code></pre></div></div></div><p>Now, can we improve this explorer by editing the files using the current editor when we display the files only, but moving to the good directory when we display the directories only?</p><div id="toggle-5"><p><label for="toggle-input-5"><i></i>Click to see the solution</label>
</p><div><p>First, we need to know if the current entry is a file or directory, to either change the working directory or edit the file with <code>$EDITOR</code>. Let’s try to add a conditional as argument to “execute”:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>--bind<span>=</span><span>&#39;enter:execute(if [ -d {} ]; then cd {}; else $EDITOR {+}; fi)+abort&#39;</span>
</span></span></code></pre></div><p>But this won’t work. The action <code>execute</code> will run <code>cd</code> in a subshell (doing <code>sh -c</code> under the hood), which won’t change the directory of the current shell.</p><p>No choice here: we need to create a bash script to solve our problem.</p><div><pre tabindex="0"><code data-lang="bash"><span><span><span>#!/usr/bin/env bash
</span></span></span><span><span><span></span>
</span></span><span><span><span># Store the STDOUT of fzf in a variable</span>
</span></span><span><span><span>selection</span><span>=</span><span>$(</span>find -type d <span>|</span> fzf --multi --height<span>=</span>80% --border<span>=</span>sharp <span>\
</span></span></span><span><span><span></span>--preview<span>=</span><span>&#39;tree -C {}&#39;</span> --preview-window<span>=</span><span>&#39;45%,border-sharp&#39;</span> <span>\
</span></span></span><span><span><span></span>--prompt<span>=</span><span>&#39;Dirs &gt; &#39;</span> <span>\
</span></span></span><span><span><span></span>--bind<span>=</span><span>&#39;del:execute(rm -ri {+})&#39;</span> <span>\
</span></span></span><span><span><span></span>--bind<span>=</span><span>&#39;ctrl-p:toggle-preview&#39;</span> <span>\
</span></span></span><span><span><span></span>--bind<span>=</span><span>&#39;ctrl-d:change-prompt(Dirs &gt; )&#39;</span> <span>\
</span></span></span><span><span><span></span>--bind<span>=</span><span>&#39;ctrl-d:+reload(find -type d)&#39;</span> <span>\
</span></span></span><span><span><span></span>--bind<span>=</span><span>&#39;ctrl-d:+change-preview(tree -C {})&#39;</span> <span>\
</span></span></span><span><span><span></span>--bind<span>=</span><span>&#39;ctrl-d:+refresh-preview&#39;</span> <span>\
</span></span></span><span><span><span></span>--bind<span>=</span><span>&#39;ctrl-f:change-prompt(Files &gt; )&#39;</span> <span>\
</span></span></span><span><span><span></span>--bind<span>=</span><span>&#39;ctrl-f:+reload(find -type f)&#39;</span> <span>\
</span></span></span><span><span><span></span>--bind<span>=</span><span>&#39;ctrl-f:+change-preview(cat {})&#39;</span> <span>\
</span></span></span><span><span><span></span>--bind<span>=</span><span>&#39;ctrl-f:+refresh-preview&#39;</span> <span>\
</span></span></span><span><span><span></span>--bind<span>=</span><span>&#39;ctrl-a:select-all&#39;</span> <span>\
</span></span></span><span><span><span></span>--bind<span>=</span><span>&#39;ctrl-x:deselect-all&#39;</span> <span>\
</span></span></span><span><span><span></span>--header <span>&#39;
</span></span></span><span><span><span>CTRL-D to display directories | CTRL-F to display files
</span></span></span><span><span><span>CTRL-A to select all | CTRL-x to deselect all
</span></span></span><span><span><span>ENTER to edit | DEL to delete
</span></span></span><span><span><span>CTRL-P to toggle preview
</span></span></span><span><span><span>&#39;</span>
</span></span><span><span><span>)</span>
</span></span><span><span>
</span></span><span><span><span># Determine what to do depending on the selection</span>
</span></span><span><span><span>if</span> <span>[</span> -d <span>&#34;</span><span>$selection</span><span>&#34;</span> <span>]</span><span>;</span> <span>then</span>
</span></span><span><span>    <span>cd</span> <span>&#34;</span><span>$selection</span><span>&#34;</span> <span>||</span> <span>exit</span>
</span></span><span><span><span>else</span>
</span></span><span><span>    <span>eval</span> <span>&#34;</span><span>$EDITOR</span><span> </span><span>$selection</span><span>&#34;</span>
</span></span><span><span><span>fi</span>
</span></span></code></pre></div><p>Then, we need to call it in the current shell. For example:</p></div></div><h2 id="fixing-performance-issues">Fixing Performance Issues</h2><p>In general, fuzzy search with fzf is blazlingly fast. That said, you might run into performance issues if you have too many entries for example. Here are some options you shouldn’t use if you want to improve the performances:</p><table><tbody><tr><th>Option</th><th>Description</th></tr><tr><td><code>--ansi</code></td><td>Parse ANSI color codes from the input and makes the initial scanning slower.</td></tr><tr><td><code>--nth</code></td><td>Limit search scope, but tokenize each entry and make fzf slower.</td></tr><tr><td><code>--with-nth</code></td><td>Transform the presentation of each line, but make fzf slower.</td></tr></tbody></table><p>If you’re not using any of the above and you still have performance issues, you can also try to change fzf’s search engine. By default, it uses “v2”, but you can switch to “v1” as follows:</p><h2 id="fuzzy-find-forever">Fuzzy Find Forever</h2><p>The file explorer we’ve created might not be of the taste of everybody, but that’s the real power of CLIs: you can often customize them for your own needs and preferences.</p><p>What did we see in this article?</p><ul><li>fzf is a fuzzy finder, allowing us to match a plain text query against line-separated inputs.</li><li>We can overwrite fzf’s default command and options with environment variables.</li><li>fzf allows <span>m</span>ulti-selection with the option <code>-m</code> (or <code>--multi</code>).</li><li>Some metacharacters (similar to regex patterns) can be used for queries: <code>^</code>,<code>$</code>, or <code>|</code> for example.</li><li>To limit the search scope, we can specify what part of the entry we want to be searchable, thanks to <code>--nth</code> and <code>--delimiter</code>.</li><li>fzf provides many different options to customize its TUI.</li><li>Creating a preview (the output of a command) is quite easy with the <code>--preview</code> option.</li><li>We can bound many actions to different keystrokes or events, to create a trully unique experience.</li><li>Some options take more resources than other; better disabling them if you’re runnning into performance issues.</li></ul><p>As you can see, fzf is general enough to fit many use cases. It’s simple yet powerful, to help us customize our workflow as much as we can. The links belows have many more examples; you’re now able to understand them, and customize them as you see fit!</p></section></article></div></div>
  </body>
</html>
