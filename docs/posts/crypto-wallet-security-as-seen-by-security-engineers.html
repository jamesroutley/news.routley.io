<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.cossacklabs.com/blog/crypto-wallets-security/">Original</a>
    <h1>Crypto wallet security as seen by security engineers</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>What can go wrong when you develop a “secure” crypto wallet? How to eliminate typical security mistakes and build a secure app with multilayered data protection against mnemonics leakage and transaction forgery?</p>
<p>Cossack Labs security engineers were involved in improving the security of several large public <a href="https://www.cossacklabs.com/solutions/solutions-for-blockchain/">blockchain ecosystems</a> and their hot non-custodial crypto wallets.</p>
<p><strong>Here we present some of our observations to help developers build safer and more secure crypto wallets.</strong></p>
<figure><img src="https://www.cossacklabs.com/blog/crypto-wallets-security/crypto-wallets-security-title.png" alt="auditing crypto wallets security"/>
</figure>
<p>First, let’s talk about the risks and threats of crypto wallets, then move to design concerns and implementation issues. In terms of financial risks, crypto wallets’ security baseline is <em>“an old good banking app&#34;</em>, meaning OWASP <a href="https://github.com/OWASP/ASVS/">ASVS L3</a>, <a href="https://github.com/OWASP/owasp-masvs">MASVS L2</a>, and <a href="https://ec.europa.eu/info/law/payment-services-psd-2-directive-eu-2015-2366_en">PSD2</a> are good starting points.</p>
<hr/>
<ol>
<li><a href="#hot-vs-cold-wallets">Hot vs cold crypto wallets</a></li>
<li><a href="#security-risks-of-all-crypto-wallets">Security risks and threats typical to all crypto wallets</a>
<ul>
<li><a href="#deanonymization">Deanonymization</a></li>
<li><a href="#dos">Denial-of-service</a></li>
</ul>
</li>
<li><a href="#application-security-flaws-of-crypto-wallets">Application security flaws of crypto wallets</a>
<ul>
<li><a href="#user-authentication">User authentication</a></li>
<li><a href="#local-data-storage">Local data storage</a></li>
</ul>
</li>
<li><a href="#platform-trust-issues-of-mobile-crypto-wallets">Platform trust issues of mobile crypto wallets</a></li>
<li><a href="#platform-trust-issues-of-web-crypto-wallets">Platform trust issues of web crypto wallets</a></li>
<li><a href="#cryptography-flaws-of-crypto-wallets">Cryptographic flaws of crypto wallets</a>
<ul>
<li><a href="#combination-of-bad-crypto-choices">A combination of bad cryptographic choices leads to a disaster</a></li>
</ul>
</li>
<li><a href="#security-issues-in-communication-with-dapps">Communication with decentralised apps</a></li>
<li><a href="#user-is-a-single-point-of-failure">User is a single point of failure</a></li>
<li><a href="#crypto-wallets-supply-chain-risks">Supply chain risks</a>
<ul>
<li><a href="#dependency-issues-with-crypto-wallets">Nine circles of dependency hell</a></li>
</ul>
</li>
<li><a href="#practical-security-for-crypto-wallets">Practicalities</a></li>
<li><a href="#security-thoughts-about-crypto-wallets">Final thoughts</a></li>
</ol>
<hr/>
<h2 id="hot-vs-cold-wallets">1. Hot vs cold crypto wallets</h2>
<p>The difference between custodial and non-custodial blockchain wallets is pretty straightforward, security-wise. <strong>Custodial crypto wallets</strong> rely on third parties (backends) to store users&#39; private keys, requiring the users to trust them more. <strong>Non-custodial crypto</strong> wallets are fully controlled by the user, making the user responsible for the tokens’ safety. Often non-custodial crypto wallets are open sourced, as a demonstration of trust and security for the users.</p>
<p><strong>Being open-source is a two-sided sword – attackers could also read details of implementation and find flaws easily.</strong></p>
<p>Crypto wallets of public blockchains (Tezos, XRPL, Cardano, Bitcoin, Ethereum, etc.) don’t “store” any user data except for account keys in non-custodial wallets — all transactions are public and can be found in public ledgers.</p>
<p><strong>Cold crypto wallets</strong> (offline, hardware, paper wallets) is one of the safest methods for holding crypto currency, as they are not connected to the Internet. But for convenience people prefer <strong>hot (online) wallets</strong> — mobile apps or web extensions.</p>
<p>Securing hot crypto wallets is a typical exercise in balancing trade offs — security vs usability.</p>
<hr/>
<h2 id="security-risks-of-all-crypto-wallets">2. Security risks and threats typical to all crypto wallets</h2>
<p>Think about crypto wallets as “gates” to the blockchain ledgers.</p>
<p>The attack surface is broad: it combines security issues unique for the exact ledger, with risks and threats typical for any finance application. Additionally, crypto wallets&#39; security heavily depends on their implementation – the selected platform (web, mobile) and developers&#39; coding choices.</p>
<p>Understanding <a href="https://www.cossacklabs.com/solutions/security-engineering-architecture/">risks &amp; threats</a> on every level helps to find security mistakes on an overlap of cryptography, platform trust, ledgers&#39; specifics and wallet’s exact implementation. This overlap hides the most interesting issues.</p>
<h3 id="deanonymization">Deanonymization</h3>
<p>In public blockchains, all crypto transactions are public. Thus, a linkability between a user’s identity and public address (deanonymization) can lead to disclosing the user’s personality or IP addresses. See <a href="https://arxiv.org/pdf/1405.7418.pdf">Deanonymization of clients in Bitcoin P2P network</a>.</p>
<p>Even privacy-oriented systems like Zcash or Monero are affected by existing deanonymization techniques (see details in <a href="https://arxiv.org/pdf/1805.03180.pdf">An empirical analysis of anonymity in ZCash</a>, <a href="https://core.ac.uk/download/pdf/225543439.pdf">Privacy and linkability of mining in ZCash</a> and <a href="https://eprint.iacr.org/2017/338.pdf">A traceability analysis of Monero’s blockchain</a>) though to a lesser degree. Public blockchains suffer from user deanonymization based on transactions graph analysis and IP-address deanonymization based on observing nodes&#39; connections.</p>
<p>User deanonymization is typically outlooked by crypto wallets developers. That’s why we recommend educating users about <a href="https://en.wikipedia.org/wiki/Shoulder_surfing_(computer_security)">over-the-shoulder attacks</a> (minimize time secrets appearing on a screen) and the risks of adding friends&#39; accounts to the address book.</p>
<h3 id="dos">Denial-of-service (DoS)</h3>
<p>Non-custodial wallets can become a component of DoS attacks on individual nodes or even the whole blockchains in some rare cases. It happens when cryptocurrency solution lacks the middleware entity (e.g. crypto wallet backend server) that can validate and filter transactions. In this case, malformed transactions go directly to the blockchain, waste nodes’ resources, and prevent valid transactions from processing.</p>
<hr/>
<div>
<p>Cryptocurrencies require combining novel cryptography with traditional data, application and product security expertise.</p>

</div>
<hr/>
<h2 id="application-security-flaws-of-crypto-wallets">3. Application security flaws of crypto wallets</h2>
<p>From the appsec perspective, crypto wallets are just applications.</p>
<p>They have similar threat vectors as any other applications: user phishing, injections, MitM, brute-forcing users’ passwords, replay attacks, reverse engineering, malicious 3rd party libraries – all the things to steal wallets’ secrets or fake transactions.</p>
<p>The primary purpose of all non-custodial crypto wallets is to store wallets’ secrets and sign transactions. Thus, user authentication and secure data storage are the most important security controls presented in every wallet.</p>
<h3 id="user-authentication">User authentication</h3>
<p>Local authentication is much more than just setting a password for the wallet app.</p>
<p>Crypto wallets often miss crucial controls around password and authentication flow: password policy, rotation, defences against password brute-force, additional authentication step before doing sensitive actions, biometrics verification, tying biometric authN to Keychain/Keystore, etc. Lack of these controls leads to lowering the bar for the attackers and sometimes opening opportunities for mnemonics and credentials leakage.</p>
<p>See <a href="https://github.com/OWASP/ASVS/blob/master/4.0/en/0x11-V2-Authentication.md">OWASP ASVS V2: Authentication</a> and <a href="https://github.com/OWASP/owasp-masvs/blob/master/Document/0x09-V4-Authentication_and_Session_Management_Requirements.md">OWASP MASVS V4: Authentication and Session Management Requirements</a>.</p>
<h3 id="local-data-storage">Local data storage</h3>
<p>As a non-custodial wallet needs to store the mnemonics, seed and private keys locally, it is crucial to understand how the local storage works and what are the common attacks against it.</p>
<p>Before storing the data, developers should get the platform-specific answers to the following questions:</p>
<ul>
<li>What kind of storage should be used to deliver the best security guarantees? Think about browser local storage vs session storage, Keychain/Keystore vs storing in plist/preferences.</li>
<li>Is the storage accessible as a file? Is it accessible by other apps?</li>
<li>Can you validate the authenticity of such storage? Is it possible to “steal” the storage from one wallet and put it in another one without problems?</li>
<li>Are there any integrity checks? Or anyone can change stored data and the crypto wallet won’t notice anything.</li>
<li>Does the storage provide encryption (even hardware-backed encryption), or the data is stored in clear text?</li>
<li>Should application-level encryption be used to encrypt data before putting it to the storage? If so, where the encryption key will be stored and how to derive it?</li>
</ul>
<figure><img src="https://www.cossacklabs.com/blog/crypto-wallets-security/crypto-wallet-security-local-storage-file.png" alt="crypto wallets security: local storage is just a file"/>
</figure>
<p><em><a href="https://stackoverflow.com/a/30766416">Despite its name,</a> 000003.log is not a log file, but a local storage of web extensions – it can be copy-pasted and put into another web extension. Most of them won’t even notice.</em></p>
<hr/>
<h2 id="platform-trust-issues-of-mobile-crypto-wallets">4. Platform trust issues of mobile crypto wallets</h2>
<p>The crypto wallet security largely depends on the security of its platform – web, mobile, desktop – and tight integration of security controls between app and platform. The more platforms the crypto wallet supports, the more related security issues might appear. Keeping the threat model in mind at all times, let’s look into various aspects of <a href="https://www.cossacklabs.com/solutions/mobile-apps-security/">mobile platform security</a>.</p>
<p>For example, crypto wallet mobile applications often do not check <strong>if the device is trusted</strong>: if it is rooted or jailbroken, if it has potentially harmful app or reverse engineering tools installed, etc. Existing mobile malware can be used to steal users&#39; credentials, mnemonics or private keys from apps’ memory (see <a href="https://en.wikipedia.org/wiki/Pegasus_(spyware)">Pegasus, remote iOS and Android spyware</a>).</p>
<p><a href="https://github.com/OWASP/owasp-masvs/blob/master/Document/0x03-Using_the_MASVS.md#masvs-r-resiliency-against-reverse-engineering-and-tampering">OWASP MASVS L2</a> recommends implementing reverse engineering and tampering protection for financial, payments, and other apps operating highly sensitive data. It also recommends notifying the users that the device is not trusted because they may be not aware of it.</p>
<p>Mobile platforms (iOS, Android) do offer device-level security controls. Requiring users to set device-level passcode is a simple feature that creates a significant obstacle for an attacker. If the passcode is not installed, anyone can unlock the phone and steal the wallet data or even access the Keychain/Keystore. Crypto wallets should require using the device-level passcode, or at least notify the users that it should be set up.</p>
<p>Another good example of not-trusting the platform is encrypting wallet’s data before putting it to Keychain/Keystore – thus, even if the phone is under attack and attackers have access to the Keychain/Keystore – the data is encrypted there (see <a href="https://www.infoq.com/articles/ale-software-architects/">Application level encryption</a>).</p>
<figure><img src="https://www.cossacklabs.com/blog/crypto-wallets-security/crypto-wallets-security-keychain.png" alt="crypto wallets security: keychain is accessible when device is unlocked"/>
</figure>
<p><em>It takes one command of the <a href="https://github.com/sensepost/objection">objection</a> tool to see Keychain content when the iOS device is unlocked, even with no jailbreak.</em></p>
<p>While mobile devices’ and OS’ exploits are out-of-scope for developers, they can implement <a href="https://www.cossacklabs.com/solutions/mobile-apps-security/">security protections to “raise the bar”</a> for attackers. For example, limiting app’s functionality on jailbroken/rooted devices, not supporting old devices, using native secure storage, limiting the lifecycle of sensitive data, thus decreasing the risks of successful attacks and data leakage.</p>
<p>OWASP (<a href="https://github.com/OWASP/owasp-masvs">MASVS</a>, <a href="https://github.com/OWASP/owasp-mstg">MSTG</a>) and NIST (<a href="https://csrc.nist.gov/publications/detail/sp/800-57-part-1/rev-5/final">SP 800-57</a>, <a href="https://pages.nist.gov/800-63-3/sp800-63-3.html">SP 800-63</a>, <a href="https://csrc.nist.gov/publications/detail/sp/800-218/draft">SSDF</a>, etc.) describe proven industry guidelines and best practices. Apart from them developers should always look for platform specific recommendations (see our article on <a href="https://www.cossacklabs.com/blog/react-native-app-security/">React Native application security</a>).</p>
<hr/>
<h2 id="platform-trust-issues-of-web-crypto-wallets">5. Platform trust issues of web crypto wallets</h2>
<p>We’ve audited crypto wallets done as web extensions that rely entirely on browser security.</p>
<p>Web crypto wallets’ security operates under certain assumptions that stored data is safe and doesn’t leak. But the web extensions (as well as the users) have no notion of runtime code integrity, so whatever is running on the user machine can be modified at all times.</p>
<p><strong>Web malware’s possibilities are unlimited:</strong> phishing users by displaying a malicious version of an “import account” or “send transaction” screen or replacing the content of the clipboard to take advantage of the copy-paste actions when the users try to send tokens to their friends.</p>
<p>Thanks to a browser extension sandbox, other extensions, web sites and out-of-browser processes <em>typically</em> can’t access wallet process memory and read sensitive data. See <a href="https://intoli.com/blog/sandbox-breakout/">Breaking out of the Chrome WebExtension sandbox</a>.</p>
<p>However, browsers are a <a href="https://github.com/Escapingbug/awesome-browser-exploit">target for exploits and 0days</a> that give memory access to attackers.</p>
<p>According to <a href="https://security.googleblog.com/2021/09/an-update-on-memory-safety-in-chrome.html">Google Security blog</a>, ~70% of security bugs that affect browsers are memory issues. <a href="https://googleprojectzero.blogspot.com/2018/01/reading-privileged-memory-with-side.html">Specter and Meltdown attacks</a> were published in 2018 by Google Project Zero; they allow reading privileged memory by side-channel attacks. Although there are no 100% protection measures against 0days and yet-unknown exploits, there are security guidelines that help developers to decrease chances of successful exploitation of known bugs.</p>
<p>Chrome team <a href="https://developers.google.com/web/updates/2018/02/meltdown-spectre">recommends</a> developers to enable site isolation, use no-sniff content-type headers, and prevent cookies from entering renders’ process memory. OWASP <a href="https://github.com/OWASP/ASVS">ASVS</a>, <a href="https://github.com/OWASP/WSTG">WSTG</a>, and <a href="https://cheatsheetseries.owasp.org/">Cheat Sheets</a> are also good sources of inspiration for industry best practices.</p>
<hr/>
<h2 id="cryptography-flaws-of-crypto-wallets">6. Cryptographic flaws of crypto wallets</h2>
<p>Non-custodial wallets perform many cryptographic operations: encrypt stored wallet’s secrets, sign transactions, and communicate with decentralised apps using secure protocols. Some cryptographic choices are dictated by the community (thus, <a href="https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki">BIP39</a> is often used to generate mnemonics, XRPL uses <a href="https://github.com/XRPLF/XRPL-Standards/tree/master/XLS-12">XLS-12</a>), but the crypto wallet developers still have plenty of room to fail.</p>
<p><strong>When people hear about cryptocurrency wallets, they assume that developers are experts in “crypto”, which they see as a synonym to “cryptography”.</strong></p>
<p>But typically, crypto wallet developers are not the same people who are working on the blockchain’s cryptographic core.</p>
<p>Usually, they are regular web, mobile, desktop devs who understand cryptocurrency concepts, but they are not experts in modern applied cryptography. Thus, their cryptographic code suffers from the common design flaws and implementation mistakes. Using correct crypto primitives for a particular use case is a separate skill that requires <a href="https://www.cossacklabs.com/solutions/applied-crypto-engineering/">additional knowledge and experience</a>.</p>
<p><strong>The most common cryptographic issues we’ve seen are:</strong></p>
<ul>
<li>
<p>Deriving cryptographic keys from the low entropy secrets without any KDF or choosing poor KDF parameters (think using PBKDF2 with 500 rounds to generate encryption key from the user password, instead of <a href="https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html">argon2, scrypt or PBKDF2 with 310000 rounds</a>).</p>
</li>
<li>
<p>Improper handling of errors and exceptions leading to salt, nonce or IV misuse or leakage.</p>
</li>
<li>
<p>Using unsuitable crypto-primitives for a desired purpose (MD5 instead of Argon2DI, AES-OFB instead of AES-GCM, SHA-256 instead of HMAC-SHA256);</p>
</li>
<li>
<p>Using the <a href="https://soatok.blog/2020/07/12/comparison-of-symmetric-encryption-methods/">unsuitable block cipher modes</a> for data encryption (AES-CBC doesn’t provide integrity checks, prefer using AES-GCM instead).</p>
</li>
<li>
<p>Making typical cryptographic mistakes: AES-CBC with zero IV, home-brewing own crypto protocols, using math.random instead of crypto.random, using base64 as “encryption” and so on.</p>
</li>
<li>
<p>Poor key management (storing encryption keys in plaintext together with data; lack of key rotation, revocation, expiration; using cryptographic keys for several different purposes).</p>
</li>
<li>
<p>Poor memory management of secrets (having sensitive data “everywhere” in the application code, not limiting its lifecycle in memory, in storage and on screen).</p>
</li>
<li>
<p>Storing wallet’s sensitive data in plaintext (well…).</p>
</li>
</ul>
<figure><img src="https://www.cossacklabs.com/blog/crypto-wallets-security/crypto-wallets-security-iv-nil-for-aes-cbc.png" alt="crypto wallets security: don&#39;t forget to handle nil IV for AES CBC"/>
</figure>
<p><em>When using the <code>randomKey()</code> from <a href="https://github.com/tectiv3/react-native-aes">react-native-aes-crypto</a> to generate IV, don’t forget to handle the <code>IV == nil</code> case.</em></p>
<p>For every crypto wallet we’ve audited, we typically found 8-10 issues related purely to the cryptography – high and medium, mostly. As many non-custodial crypto wallets are open-source, cryptographic issues become much easier to identify and exploit for a prying eye.</p>
<p>As we do believe that software developers shouldn’t struggle with tradeoffs of writing cryptographic themselves, we strongly recommend using community-proven crypto-libraries that are designed for developers and work across many platforms, like <a href="https://github.com/cossacklabs/themis/">Themis</a> and <a href="https://libsodium.gitbook.io/doc/">libsodium</a>.</p>
<hr/>
<div>
<p>Themis is a high-level cryptographic library that fits perfectly for multi-platform apps. Themis is easy-to-use and hard-to-misuse.</p>

</div>
<hr/>
<h3 id="combination-of-bad-crypto-choices">A combination of bad cryptographic choices leads to a disaster</h3>
<h4 id="weakness-1-weak-storage-scheme-for-wallets-data">Weakness 1. Weak storage scheme for wallets data</h4>
<p>The most interesting cryptographic issues we’ve seen were a combination of design &amp; implementation mistakes or bad choices. Let’s see how several small issues combined together could simplify uncovering wallet’s mnemonics – the core secret of all non-custodial crypto wallets.</p>
<p>One crypto wallet stored sensitive data in a file, encrypted but in a very human-friendly format. Each stored field had an understandable name.</p>
<p>The file itself was stored on a user’s machine in a folder, accessible for curious eyes and any other applications in the system.</p>
<pre><code>wallet_mnemonics:
encrypted_data: &#34;4198fbf....aaca6d&#34;
iv: &#34;e84c2e2bb7c...904f6a16bbad9&#34;
salt: &#34;da2111aeab1182...0c30614931&#34;

password_check:
encrypted_data: &#34;12e1a2ba2c...8492e9&#34;
iv: &#34;521a231a21a...a1bb123c86&#34;
salt: &#34;73aac01746d4d...928da60adb4&#34;
</code></pre><p><em>The crypto wallet stores the data in a file, encrypted per field.</em></p>
<p>The encryption scheme was the following:</p>
<figure><img src="https://www.cossacklabs.com/blog/crypto-wallets-security/crypto-wallets-security-too-obvious-encryption-scheme.png" alt="crypto wallets security: encryption scheme is too obvious"/>
</figure>
<p>It means that every data field was encrypted using AES-256-GCM and a unique-per-field derived encryption key. All encryption keys were derived from the same user password using different salts.</p>
<p>The devil is in the details. If the attacker had access to this file, they only needed to decrypt one field – <code>wallet_mnemonics</code>. The attacker knows the salt and IV of the encrypted data, making brute-force very straightforward. Human-friendly names really help attackers to quickly locate required fields.</p>
<h4 id="weakness-2-encrypting-multiple-fields-with-the-same-password">Weakness 2. Encrypting multiple fields with the same password</h4>
<p>Brute-forcing becomes even faster with the <code>password_check</code> field. It is a special utility field, which the crypto wallet uses to determine if the user has entered the correct password. If decryption of this field is successful – the user password is correct.</p>
<p>The original (plaintext) value of the <code>password_check</code> field was “null”. So developers were actually encrypting “null” with the user’s password, storing it encrypted, then decrypting and comparing <code>if decrypted == null</code>.</p>
<p>As all fields are encrypted by keys derived from the same password, the attacker can optimize brute-force by first decrypting the <code>password_check</code> value. The attacker knows salt, IV <em>and</em> value of plaintext null. Brute-forcing <code>password_check</code> will be faster than brute-forcing <code>wallet_mnemonics</code> due to known and short plaintext.</p>
<p>Successful brute force will result in a user password, which the attacker will use to decrypt the <code>wallet_mnemonics</code> field (already knowing its salt and IV).</p>
<h4 id="weakness-3-poor-kdf-choice-and-weak-parameters">Weakness 3. Poor KDF choice and weak parameters</h4>
<p>Usually, a strong password-based KDF should protect against brute-forcing, making it very long, as KDFs are designed to be slow. However, this particular crypto wallet used a PBKDF2-HMAC-SHA256 with only <strong>1000</strong> iterations (instead of currently recommended by NIST and OWASP <a href="https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html#pbkdf2">310000 iterations</a>).</p>
<p>PBKDF2 is well-known to <a href="https://eprint.iacr.org/2016/273.pdf">have weaknesses, CPU and GPU optimizations</a> for faster brute force. Tools like <a href="https://github.com/openwall/john">John-the-Ripper</a> already provide GPU support for cracking PBKDF2-HMAC-SHA256.</p>
<p>Using so few rounds with an “old-school” PBKDF2 is a bad choice that makes brute-forcing even easier. <a href="https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html">Which KDF to use?</a></p>
<h4 id="weakness-4-allowing-low-entropy-user-passwords">Weakness 4. Allowing low-entropy user passwords</h4>
<p>The next line of defence is the user password. Low-entropy passwords, like “Password1” or “Qwerty123” are quite common. This crypto wallet used the following password rules: 8 chars length, 1 number, 1 capital and 1 lowercase letter, which seems fine.</p>
<p>However, it hasn’t checked if the password was a low-entropy string (like “Aa11111”), or a dictionary word (“Matrix12”), or was <a href="https://haveibeenpwned.com/">previously leaked</a>. See <a href="https://pages.nist.gov/800-63-3/sp800-63b.html#memsecretver">NIST SP 800-63b</a>.</p>
<p>As a result, it takes less time to brute-force a more straightforward password.</p>
<h4 id="a-combination-of-weaknesses">A combination of weaknesses</h4>
<p>In this example, a combination of bad choices could lead – under unfortunate circumstances – to stealing and reversing crypto wallet’s mnemonics. Location of a file, its human-friendly format, IV and salt placed together with the encrypted data, using “null” field for a check, using encryption keys derived from the same password for every field, selecting PBKDF2 and using too few iterations for it, allowing weak passwords, and, finally, being an open-source wallet.</p>
<p>We provided multiple recommendations for every aspect of this scheme.</p>
<hr/>
<h2 id="security-issues-in-communication-with-dapps">7. Communication with decentralised apps</h2>
<p>The more features crypto wallets have, the more extensive is their attack surface and the more sophisticated is the threat model.</p>
<p>One of such typical wallet features is interaction with third-party <a href="https://en.wikipedia.org/wiki/Decentralized_application">decentralized applications</a> (depending on a blockchain, they are called dApps or xApps). Some crypto wallets allow quickly interacting with a predefined list of dApps and others embed dApps as WebViews.</p>
<p><strong>This communication introduces the following threat vectors:</strong></p>
<ul>
<li>
<p>Communication between the wallet and the dApp. Without proper authentication, data-in-transit encryption and authorization of transaction data, the attacker may intercept and modify requests – like changing transaction’s amount or recipient’s address.</p>
</li>
<li>
<p>Malicious dApps. Most blockchains have dozens of dApps created by the community – some of them suddenly gain popularity, others become neglected. Even if the dApp is coming from a trusted source, it doesn’t mean that it has no vulnerabilities. Also, nothing prevents attacking users via the dApp that has been modified and becomes malicious afterwards (<a href="https://medium.com/technicity/most-of-the-dapps-exhibit-this-vulnerability-21abdbb8168">refer to typical vulnerabilities caused by DApps</a>).</p>
</li>
<li>
<p>The way dApps are integrated into the wallet. For example, if the crypto wallet is a mobile app, dApps may be opened in a WebView as regular web pages. As a result, they bring all web-related risks: injection, hijacking, and leaks.</p>
</li>
</ul>
<p>To mitigate these threat vectors, we recommend using a strong transport encryption between crypto wallets and dApps (TLS 1.3 or specific protocols, like <a href="https://tezos.b9lab.com/beacon">Beacon for Tezos ecosystem</a>), doing a proper session management and mutual authentication, and watching the integration point.</p>
<p>Most blockchains we’ve audited don’t have anti-spam and anti-abuse measures other software marketplaces have – think AppStore, Google play market, AWS marketplace, etc. It makes inexperienced users vulnerable to malicious dApps. We suggest having a “complaint” button, doing periodical inspections of dApps and having a dedicated support channel for users related to dApps’ behaviour.</p>
<hr/>
<h2 id="user-is-a-single-point-of-failure">8. User is a single point of failure</h2>
<p>Non-custodial crypto wallets are secure as long as the user keeps it secure. So, along with in-app security efforts, educating users about their responsibility is a mission of every crypto wallet dev team.</p>
<p>It doesn’t matter how strict apps’ security controls are, if the users are easily tricked by phishing attacks or simply lose their wallet’s secrets. Developers should include quick security tips and hints in the app, especially when users interact with critical features (like transferring their tokens to a new address) .</p>
<figure><img src="https://www.cossacklabs.com/blog/crypto-wallets-security/crypto-wallets-security-educate-users.jpg" alt="crypto wallets security: educate users"/>
</figure>
<p><em>Popular wallets like Coinbase and Bitcoin wallet have variety of approaches for users education.</em></p>
<p>Educate the users because often the attackers do not need any technical skills to obtain someone’s sensitive information through “shoulder surfing”, i. e. observing their computer or mobile device screen and keyboard.</p>
<p>Users may know what blockchain is, what is the current currency exchange rate, how to send transactions, but they may not know how it works or what account mnemonics and private keys are and why they need it. Users may not know that they should treat mnemonics as credit card CVV. We suggest treating mnemonics similarly to a “memorized secret” according to <a href="https://pages.nist.gov/800-63-3/sp800-63b.html#memsecret">NIST SP 800-63</a>, and follow it.</p>
<p>When building new features in the crypto wallet, always consider how the users might misuse and abuse the app. Educate the users wherever it is possible as overwise they can be the weakest link in the wallet’s security mechanism.</p>
<hr/>
<p>We help companies to build secure systems and protect their innovations. Read how we secured notes in Bear iOS and macOS apps using Themis:</p>

<hr/>
<h2 id="crypto-wallets-supply-chain-risks">9. Supply chain risks</h2>
<p>Supply chain attacks pose a significant risk to crypto wallets. Supply chain risks are growing together with a growing amount of external dependencies used in the app.</p>
<p>Crypto wallets may have numerous dependencies that have access to the wallet sensitive data, like cryptographic libraries (think ECC), official libraries for particular protocols or standards used in the blockchain (think BIP39 or BIP32), and handy utility libraries for every possible purpose (think all npm).</p>
<p>We’ve seen crypto wallets with 110 external dependencies. As every dependency has its dependencies, the total amount of dependencies was 1838 (estimated by yarn audit).</p>
<p>If some dependencies are close sourced, the <a href="https://medium.com/@alex.birsan/dependency-confusion-4a5d60fec610">Dependency confusion attacks</a> might be relevant.</p>
<figure><img src="https://www.cossacklabs.com/blog/crypto-wallets-security/crypto-wallets-security-supply-chain1.jpg" alt="crypto wallets security: supply chain"/>
</figure>
<p><em>3rd party libraries inside a typical crypto wallet React Native application</em></p>
<p>A vulnerability in any of these libraries – is a potential vulnerability of the whole wallet.</p>
<p>While adding another dependency may seem to save developers’ time, it may not be the best option for security-related features (see <a href="https://csrc.nist.gov/publications/detail/white-paper/2020/04/23/mitigating-risk-of-software-vulnerabilities-with-ssdf/final">NIST SSDF PW.7</a>). Some dependencies have open issues and PRs that might affect their security. For example, <a href="https://github.com/indutny/elliptic">@elliptic</a> has opened unmerged PR to <a href="https://github.com/indutny/elliptic/pull/253/files">fix EC point decoding</a>, and <a href="https://github.com/bitwiseshiftleft/sjcl/issues">Stanford JavaScript crypto library</a> has 98 open issues, some marinating there since 2010.</p>
<p>Another example is that the dependency may not have required security functionality. For example, <a href="https://www.npmjs.com/package/react-native-fingerprint-scanner">react-native-fingerprint-scanner</a> doesn’t handle a fallback action on a biometry change and <a href="https://www.npmjs.com/package/react-native-webview">react-native-webview</a> doesn’t clear WebView cache properly.</p>
<p>We recommend carefully nurturing external dependencies, patches and forks, updating them regularly, and using automation tools to support the process (<a href="https://csrc.nist.gov/publications/detail/white-paper/2020/04/23/mitigating-risk-of-software-vulnerabilities-with-ssdf/final">NIST SSDF PW.1, PO.3</a>).</p>
<h3 id="dependency-issues-with-crypto-wallets">Nine circles of dependency hell</h3>
<p>Researching dependencies sometimes opens an unexpected hole to hell.</p>
<p>Let’s take a look on React Native crypto wallet that works on iOS and Android. It generates random values used for encryption and private keys generation:</p>
<div><pre tabindex="0"><code data-lang="javascript"><span>const</span> <span>random</span> <span>=</span> <span>generateRandomValues</span>();
</code></pre></div><p>This method calls <a href="https://github.com/mvayngrib/react-native-crypto/">mvayngrib/react-native-crypto</a> (which, by the way, is now deprecated and renamed to <a href="https://github.com/tradle/react-native-crypto">tradle/react-native-crypto</a>). mvayngrib/react-native-crypto has a peerDependency <a href="https://github.com/mvayngrib/react-native-randombytes">react-native-randombytes</a>. react-native-randombytes, in its turn, depends on a quite outdated <a href="https://github.com/bitwiseshiftleft/sjcl">Stanford Javascript Crypto Library</a> (SJCL).</p>
<p>According to the <a href="https://github.com/mvayngrib/react-native-randombytes">react-native-randombytes documentation</a>, it supports two ways of generating pseudo random bytes: synchronous and asynchronous calls.</p>
<p>For <em>async generation</em>, the library uses native CPRNGs – SecRandomCopyBytes on iOS and SecureRandom API on Android. For <em>sync generation</em>, the library uses CPRNG from the SJCL library.</p>
<p>People had questioned this choice before. For example, in <a href="https://github.com/tradle/react-native-crypto/issues/57#issuecomment-641991857">this issue</a>, one of the react-native-crypto maintainers, confirmed the sync generation is less secure than the async one. But they plan to update using a more secure sync way of generating random values (this update hasn’t happened yet).</p>
<p><a href="https://github.com/bitwiseshiftleft/sjcl">SJCL</a> is one of the oldest javascript libraries, initially created in May 2010. SJCL doesn’t have dependencies, that’s a pure implementation of crypto-primitives in javascript. SJCL was initially designed for web browsers before the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues">WebAPI crypto.getRandomValues</a> became available.</p>
<p>Right now, SJCL has many open issues, it wasn’t updated for several years and is surrounded by discussions about the security of its random function: <a href="https://github.com/bitwiseshiftleft/sjcl/issues/77">bitwiseshiftleft/sjcl#77</a>, <a href="https://github.com/bitwiseshiftleft/sjcl/issues/178">bitwiseshiftleft/sjcl#178</a>, <a href="https://stackoverflow.com/questions/4083204/secure-random-numbers-in-javascript">stackoverflow</a>.</p>
<p>SJCL uses <a href="https://github.com/bitwiseshiftleft/sjcl/blob/master/core/random.js">random.js</a> to collect entropy from entropy pools, relying on things like “mouse movements” and “keyboard listener”. Of course, mobile devices don’t have a mouse and keyboard in a way as desktop devices do.</p>
<p>All of the above leads us to think that SJCL is an unsuitable choice for CPRNG for mobile applications. It was not designed to get entropy from mobile devices, doesn’t have secure default settings, and wasn’t updated for a while.</p>
<p>We strongly recommend keeping an eye on sources of cryptographically pseudorandom values, as low entropy values lead to deriving weak and predictable cryptographic material, making attackers’ job easier.</p>
<figure><img src="https://www.cossacklabs.com/blog/crypto-wallets-security/crypto-wallets-security-supply-chain2.jpg" alt="crypto wallets security: supply chain"/>
</figure>
<p><em>Bringing “react-native-crypto” library brings its dozen dependencies.</em></p>
<hr/>
<h2 id="practical-security-for-crypto-wallets">10. Practicalities</h2>
<p>The users are trusting a decent amount of their tokens (~ money) to crypto wallets. They expect the same level of security as they get from other financial applications, banking apps or better.</p>
<p>Some teams, having built a widely popular wallets, lack security and cryptography expertise to understand that their implementation exposes users to problems. Some of the bike-shed security controls are amazing examples of <a href="https://www.schneier.com/blog/archives/2011/04/schneiers_law.html">Schneier’s law</a>. It’s not their fault, as their business is different.</p>
<p>Responsible developers should understand when responsibility becomes hard. Perhaps, when wallet adoption reaches some point, choosing to review and improve security should become a priority.</p>
<p>Here are some practical tips for improving security of crypto wallets:</p>
<ul>
<li>Start with understanding risks and threats: crypto wallets’ risk landscape is a combination of blockchain-related and platform-related risks, cryptography, and application security flaws.</li>
<li>Educate the user. For a non-custodial crypto wallet, the user is the weakest link of the system. Do your best to prevent phishing attacks: add hints, mask fields, show warnings, ask for user password before critical actions.</li>
<li>Follow the best practices in cryptography: don’t implement your own ciphers and protocols, use strong encryption, and be careful with key management.</li>
<li>Do not hesitate to use out-of-the-box platform security controls: they allow “raising the bar” for attackers with minimum developers’ cost.</li>
<li>Use automated static code analysis tools (SAST) in your CI pipeline.</li>
<li>Continuously audit all dependencies that you are using and implement the proper fixes before the next release goes public. Use automated dependency management tools in your CI pipeline.</li>
<li>Focus on massive exploits. While you can cover single cases, massive exploits may destroy the reputation of the crypto wallet and even the cryptocurrency. Cryptocurrency reputation equals its cost.</li>
<li>Follow the secure coding best practices (e.g. <a href="https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/migrated_content">OWASP Secure Coding Practices</a>): data minimization, input validation and sanitization, principle of least privilege, etc.</li>
</ul>
<hr/>
<h2 id="security-thoughts-about-crypto-wallets">11. Final thoughts</h2>
<p>Crypto wallet security is a tricky beast. All cool vulnerabilities and potential issues we’ve found <em>lie at the intersection of multiple flaws:</em> cryptography, access to the local storage, lack of authentication, lack of input validation. Each is relatively small, but they open the unexpected attack vectors when combined.</p>
<p>From the defender’s point of view, the crypto wallet’s attack surface is enormous. But from the attacker’s point of view, it’s not so difficult to combine 3-4 flaws, especially if the crypto wallet’s code is open-sourced.</p>
<p>Therefore, it makes sense to look not only at specific flaws but at their synergies. Preventing security bugs not only with secure coding and suitable crypto primitives but with the right security design, using proven building blocks and correctly integrating them. Pushing security early and following the secure software development cycle (SSDLC) saves time and budget spent on security and keeps a clean reputation.</p>
<p>Crypto wallets&#39; application security failures allow stealing money faster than from vulnerable mobile banking apps. Unlike banks, public blockchains don’t have a massive anti-fraud system or customer support able to revert transactions. Act accordingly.</p>
</div></div>
  </body>
</html>
