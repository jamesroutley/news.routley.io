<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://eieio.games/nonsense/game-14-one-million-checkboxes/">Original</a>
    <h1>One Million Checkboxes</h1>
    
    <div id="readability-page-1" class="page"><div>
    <h3>
        <a href="http://eieio.games/nonsense/game-14-one-million-checkboxes/">One Million Checkboxes</a>
    </h3>
    <div><p><span>One million checkboxes that anyone can check</span></p></div>
</div><div itemprop="articleBody">
        <p>I made a website. It’s called <a href="https://onemillioncheckboxes.com">One Million Checkboxes</a>. It has one million checkboxes on it. Checking a box checks that box for everyone (and makes some numbers go up).</p>

<p>You can find it at <a href="https://onemillioncheckboxes.com">onemillioncheckboxes.com</a>.</p>




<p>I don’t really know. The idea came up in a conversation last Friday and I felt compelled to make it.</p>

<!-- excerpt-end -->


<p>There are a few fun tricks I used here.</p>

<ul>
  <li>To efficiently store state I use a bit array. Checking box 0 just flips the first bit in that array.</li>
  <li>I store my state in redis since redis can easily flip individual bits of a value.</li>
  <li>I broadcast individual “toggle” updates via websockets and push out a full state snapshot every 30 seconds or so to make sure clients stay synched.</li>
  <li>I use <a href="https://www.npmjs.com/package/react-window">react-window</a> to avoid rendering checkboxes that aren’t in view.</li>
</ul>


<p>Not much! This one was fun and fast. I did run into one bug that was <em>baffling</em> - I’ll tell you about it really quick.</p>

<h4 id="endianness">Endianness</h4>
<p>When we toggle a checkbox, the server does something like this:</p>

<div><div><pre><code><span>def</span> <span>set_bit</span><span>(</span><span>index</span><span>,</span> <span>value</span><span>):</span>
    <span>state</span><span>[</span><span>&#39;bitset&#39;</span><span>][</span><span>index</span><span>]</span> <span>=</span> <span>value</span>
</code></pre></div></div>

<p>Pretty simple! We convert that state to a big array of bytes and ship it to the client<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" rel="footnote">1</a></sup>. The client looks at the state to figure out which toggles are set. My original implementation looked like this:</p>

<div><div><pre><code><span>class</span> <span>BitSet</span> <span>{</span>
    <span>constructor</span><span>(</span><span>size</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span><span>size</span> <span>=</span> <span>size</span><span>;</span>
        <span>this</span><span>.</span><span>bits</span> <span>=</span> <span>new</span> <span>Uint32Array</span><span>(</span><span>Math</span><span>.</span><span>ceil</span><span>(</span><span>size</span> <span>/</span> <span>32</span><span>));</span>
    <span>}</span>

    <span>get</span><span>(</span><span>index</span><span>)</span> <span>{</span>
        <span>const</span> <span>arrayIndex</span> <span>=</span> <span>Math</span><span>.</span><span>floor</span><span>(</span><span>index</span> <span>/</span> <span>32</span><span>);</span>
        <span>const</span> <span>bitIndex</span> <span>=</span> <span>index</span> <span>%</span> <span>32</span><span>;</span>
        <span>return</span> <span>(</span><span>this</span><span>.</span><span>bits</span><span>[</span><span>arrayIndex</span><span>]</span> <span>&amp;</span> <span>(</span><span>1</span> <span>&lt;&lt;</span> <span>bitIndex</span><span>))</span> <span>!==</span> <span>0</span><span>;</span>
    <span>}</span>

    <span>set</span><span>(</span><span>index</span><span>)</span> <span>{</span>
        <span>const</span> <span>arrayIndex</span> <span>=</span> <span>Math</span><span>.</span><span>floor</span><span>(</span><span>index</span> <span>/</span> <span>32</span><span>);</span>
        <span>const</span> <span>bitIndex</span> <span>=</span> <span>index</span> <span>%</span> <span>32</span><span>;</span>
        <span>const</span> <span>mask</span> <span>=</span> <span>1</span> <span>&lt;&lt;</span> <span>bitIndex</span><span>;</span>
        <span>this</span><span>.</span><span>bits</span><span>[</span><span>arrayIndex</span><span>]</span> <span>|=</span> <span>mask</span><span>;</span>
  <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>Does this work?</p>

<p>No! Look at what we get from each of these implementations when we set the first bit:</p>

<div><div><pre><code><span>def</span> <span>set_bit</span><span>(</span><span>index</span><span>,</span> <span>value</span><span>):</span>
    <span>state</span><span>[</span><span>&#39;bitset&#39;</span><span>][</span><span>index</span><span>]</span> <span>=</span> <span>value</span>
<span>state</span> <span>=</span> <span>{</span> <span>&#34;bitset&#34;</span><span>:</span> <span>[</span><span>0</span> <span>for</span> <span>_</span> <span>in</span> <span>range</span><span>(</span><span>32</span><span>)]</span> <span>}</span>
<span>set_bit</span><span>(</span><span>0</span><span>,</span> <span>1</span><span>)</span>
<span>print</span><span>(</span><span>&#34;&#34;</span><span>.</span><span>join</span><span>(</span><span>str</span><span>(</span><span>x</span><span>)</span> <span>for</span> <span>x</span> <span>in</span> <span>state</span><span>[</span><span>&#34;bitset&#34;</span><span>]))</span>
<span># &#39;10000000000000000000000000000000&#39;
</span><span>int</span><span>(</span><span>&#34;&#34;</span><span>.</span><span>join</span><span>(</span><span>str</span><span>(</span><span>x</span><span>)</span> <span>for</span> <span>x</span> <span>in</span> <span>state</span><span>[</span><span>&#34;bitset&#34;</span><span>]),</span> <span>2</span><span>)</span>
<span># 2147483648
</span></code></pre></div></div>

<div><div><pre><code><span>&gt;</span> <span>bitset</span> <span>=</span> <span>new</span> <span>BitSet</span><span>(</span><span>32</span><span>)</span>
<span>&gt;</span> <span>bitset</span><span>.</span><span>set</span><span>(</span><span>0</span><span>)</span>
<span>&gt;</span> <span>bitset</span>
<span>BitSet</span> <span>{</span> <span>size</span><span>:</span> <span>32</span><span>,</span> <span>bits</span><span>:</span> <span>Uint32Array</span><span>(</span><span>1</span><span>)</span> <span>[</span> <span>1</span> <span>]</span> <span>}</span>
</code></pre></div></div>

<p>Our python implementation treats bit 0 as the leftmost bit of the leftmost byte. In javascript we’re grabbing the <em>rightmost</em> bit of the leftmost byte!</p>

<p>This isn’t <em>quite</em> an endianness problem - really we’re reversing the order of bits in a byte, instead of reversing the order of bytes in a word. But it certainly <em>feels</em> like an endianness bug.</p>

<p>Fixing this meant deciding whether I wanted to model my data as “one million bits” or “125,000 bytes” - and of course realizing that those were two different things. The bug appeared mid-refactor - my original update code hid the error in my data model until you refreshed the page - and so it took me ages to suspect the bit twiddling. In retrospect this was a mistake. Always suspect the bit twiddling.</p>


<p>This site was fun to make. It got me thinking about a new space of collaborative experiences that I want to explore.</p>

<p>It was also really nice to make and ship something in two days! I’ve got a few ongoing projects that I’ve been working on for too long and this was a welcome break (maybe I should just ship those projects too).</p>

<p>Anyway. I hope you enjoy the site, and I’ll be back soon with some larger webcam-based projects :)</p>



    </div></div>
  </body>
</html>
