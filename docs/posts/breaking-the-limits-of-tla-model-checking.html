<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.hillelwayne.com/post/graphing-tla/">Original</a>
    <h1>Breaking the limits of TLA&#43; model checking</h1>
    
    <div id="readability-page-1" class="page"><article lang="en">
    

    
    

    <div>
  

<p>I haven’t written much about TLA+ on the blog since the new <a href="https://learntla.com/">learntla</a> went up. Any examples or special topics I think of go there instead. But I recently thought of a cool demo that doesn’t quite fit the theme of that book: there are some things you can’t easily check with the model checker but <em>can</em> check if you work with the state space as a directed graph.</p>

<p>Take for example <dfn>observational determinism</dfn>
 (OD): does an algorithm always converge on the <em>same</em> answer? Let’s use the example of four threads, each nonatomically incrementing a counter once. To show that the final value of <code>x</code> isn’t always 4, you just have find one trace where it’s not 4. But to show that the final value is <em>inconsistent</em>, you have to find <em>two</em> traces that get different answers! The TLA+ model checker (TLC) can do the first but not the second.</p>

<details>

  <summary>
    Show spec
  </summary>
  <div><pre><code data-lang="tla"><span></span><span>------------------------------</span> <span>MODULE</span> <span>threads</span> <span>------------------------------</span>

<span>EXTENDS</span> <span>Integers</span>
<span>Threads</span> <span>==</span> <span>1</span><span>..</span><span>4</span> <span>\* four threads!</span>
<span>(* --algorithm threads</span>

<span>variables</span> 
  <span>x</span> <span>=</span> <span>0</span><span>;</span>

<span>process</span> <span>thread</span> <span>\in</span> <span>Threads</span>
<span>variables</span> <span>tmp</span> <span>=</span> <span>0</span><span>;</span>
<span>begin</span>
<span>  Get:</span>
    <span>tmp</span> <span>:=</span> <span>x;</span>

<span>  Inc:</span>
    <span>x</span> <span>:=</span> <span>tmp</span> <span>+</span> <span>1</span><span>;</span>
<span>end process</span><span>;</span>

<span>end algorithm; *)</span>
<span>====</span>
</code></pre></div>

</details>




<p>If you wanted to test for observational determinism, you’d normally have to <a href="https://www.hillelwayne.com/post/software-mimicry/">mimic</a> it with some hairy “hypermodeling” tricks I <a href="https://www.hillelwayne.com/post/hyperproperties/">wrote about here</a>. Not only is this difficult and fragile, it’s also really inefficient. The regular model has only 755 distinct states, while the hypermodel has over 100,000! It’d be much easier if we could “step outside” the model checker and just examine the state space directly.</p>

<p>So I started looking for a way. And I got a lot further than I expected, well past checking OD and all the way into finding probabilities! If you want to poke around with any of the components, you can download the whole project <a href="https://github.com/hwayne/tla-graphing-demo">here</a>.</p>



<h2 id="1-get-the-state-space-dump">1. Get the state space dump</h2>

<p>This is easy, just model check with <code>-dump dot,actionlabels file</code>. TLC will output a <a href="https://graphviz.org/">graphviz</a> file.</p>
<div><pre><code data-lang="graphviz"><span></span><span>strict</span><span> </span><span>digraph</span><span> </span><span>DiskGraph</span><span> {</span>
<span>nodesep</span><span>=</span><span>0.35</span><span>;</span>
<span>subgraph</span><span> </span><span>cluster_graph</span><span> {</span>
<span>color</span><span>=</span><span>&#34;white&#34;</span><span>;</span>
<span>2665600213816166005</span><span> [</span><span>label</span><span>=</span><span>&#34;/\\ x = 0\n/\\ pc = &lt;&lt;\&#34;Get\&#34;, \&#34;Get\&#34;, \&#34;Get\&#34;, \&#34;Get\&#34;&gt;&gt;\n/\\ tmp = &lt;&lt;0, 0, 0, 0&gt;&gt;&#34;</span><span>,</span><span>style</span><span> = </span><span>filled</span><span>]</span>
<span>2665600213816166005</span><span> </span><span>-&gt;</span><span> </span><span>-1245546546836852765</span><span> [</span><span>label</span><span>=</span><span>&#34;Get&#34;</span><span>,</span><span>color</span><span>=</span><span>&#34;black&#34;</span><span>,</span><span>fontcolor</span><span>=</span><span>&#34;black&#34;</span><span>];</span>
<span>// 2000 more lines</span>
</code></pre></div>

<p>That’s…   going to be hard to work with.</p>

<h2 id="2-clean-up-the-file">2. Clean up the file</h2>

<p>Let’s replace the node ids with something a little more readable. I wrote a script to replace each node id with a short string. The first node in the file is renamed to “a”, the second to “b”, the twenty-seventh to “ab”, and the 5796th to “aaa”. I took this as an opportunity to learn some Rust.</p>

<details>

  <summary>
    Show code
  </summary>
  <div><pre><code data-lang="rust"><span></span><span>//use std::io;</span>
<span>#![allow(unused_imports)]</span>
<span>#![allow(dead_code)]</span>
<span>#![allow(unused_variables)]</span>

<span>use</span><span> std</span>::<span>fmt;</span>
<span>use</span><span> std</span>::<span>fs;</span>
<span>use</span><span> std</span>::<span>path</span>::<span>Path;</span>
<span>use</span><span> std</span>::<span>env;</span>
<span>use</span><span> regex</span>::<span>Regex; </span><span>// 1.7.1</span>
<span>use</span><span> std</span>::<span>collections</span>::<span>HashMap;</span>

<span>fn</span> <span>num_to_id_str</span><span>(id</span>: <span>u32</span><span>) </span>-&gt; <span>String</span> <span>{</span>
<span>    </span><span>let</span><span> </span><span>mut</span><span> out</span>: <span>String</span> <span>=</span><span> String</span>::<span>with_capacity(</span><span>5</span><span>);</span>

<span>    </span><span>let</span><span> </span><span>mut</span><span> id</span>: <span>u32</span> <span>=</span><span> id;</span>

<span>    </span><span>while</span><span> id </span><span>!=</span><span> </span><span>0</span><span> {</span>
<span>        id </span><span>=</span><span> id </span><span>-</span><span> </span><span>1</span><span>;</span>
<span>        out.push(((id </span><span>%</span><span> </span><span>26</span><span>) </span><span>+</span><span> </span><span>97</span><span>) </span><span>as</span><span> </span><span>u8</span><span> </span><span>as</span><span> </span><span>char</span><span>);</span>
<span>        id </span><span>=</span><span> id </span><span>/</span><span> </span><span>26</span><span>;</span>
<span>    };</span>
<span>    out.chars().rev().collect</span>::<span>&lt;</span><span>String</span><span>&gt;</span><span>()</span>
<span>}</span>

<span>fn</span> <span>next_id_str</span><span>(id</span>: <span>&amp;</span><span>mut</span><span> </span><span>u32</span><span>) </span>-&gt; <span>String</span> <span>{</span>
<span>    </span><span>*</span><span>id </span><span>=</span><span> </span><span>*</span><span>id </span><span>+</span><span> </span><span>1</span><span>;</span>
<span>    num_to_id_str(</span><span>*</span><span>id)</span>
<span>}</span>


<span>fn</span> <span>main</span><span>() {</span>
<span>    </span><span>let</span><span> </span><span>mut</span><span> id</span>: <span>u32</span> <span>=</span><span> </span><span>0</span><span>;</span>
<span>    </span><span>let</span><span> </span><span>mut</span><span> replacement_table</span>: <span>HashMap</span><span>&lt;&amp;</span><span>str</span><span>, String</span><span>&gt;</span><span> </span><span>=</span><span> HashMap</span>::<span>new();</span>

<span>    </span><span>let</span><span> args</span>: <span>Vec</span><span>&lt;</span><span>String</span><span>&gt;</span><span> </span><span>=</span><span> env</span>::<span>args().collect();</span>
<span>    </span><span>let</span><span> file_path</span>: <span>&amp;str</span> <span>=</span><span> </span><span>&amp;</span><span>args[</span><span>1</span><span>];</span>
<span>    </span><span>let</span><span> out_path</span>: <span>&amp;str</span> <span>=</span><span> </span><span>&amp;</span><span>args[</span><span>2</span><span>];</span>
<span>    </span><span>let</span><span> graph </span><span>=</span><span> fs</span>::<span>read_to_string(file_path)</span>
<span>        .expect(</span><span>&#34;Should have been able to read the file&#34;</span><span>);</span>
<span>    </span><span>let</span><span> </span><span>mut</span><span> out </span><span>=</span><span> String</span>::<span>with_capacity((</span><span>&amp;</span><span>graph).len());</span>
<span>    </span>
<span>    </span><span>let</span><span> re </span><span>=</span><span> Regex</span>::<span>new(</span><span>r&#34;-?[[:digit:]]{10,}&#34;</span><span>).unwrap();</span>
<span>    </span><span>let</span><span> unchanged_chunks </span><span>=</span><span> re.split(</span><span>&amp;</span><span>graph);</span>
<span>    </span><span>let</span><span> </span><span>mut</span><span> text_words </span><span>=</span><span> re.find_iter(</span><span>&amp;</span><span>graph); </span><span>//needs to be mut for iteration</span>

<span>    </span><span>for</span><span> chunk </span><span>in</span><span> unchanged_chunks {</span>
<span>        out.push_str(chunk);</span>
<span>        </span><span>match</span><span> text_words.next() {</span>
<span>            Some(mat) </span><span>=&gt;</span><span> {</span>
<span>                </span><span>let</span><span> key </span><span>=</span><span> mat.as_str();</span>
<span>                </span><span>if</span><span> </span><span>!</span><span>replacement_table.contains_key(key) {</span>
<span>                    replacement_table.insert(key, next_id_str(</span><span>&amp;</span><span>mut</span><span> id));</span>
<span>                }</span>
<span>                out.push_str(replacement_table.get(</span><span>&amp;</span><span>key).unwrap());</span>
<span>            }</span>
<span>            None </span><span>=&gt;</span><span> </span><span>continue</span>
<span>        };</span>
<span>    }</span>
<span>    fs</span>::<span>write(out_path, out).expect(</span><span>&#34;Unable to write file&#34;</span><span>);</span>
<span>}</span>


<span>#[cfg(test)]</span>
<span>mod</span> <span>tests {</span>
<span>    </span><span>use</span><span> </span><span>super</span>::<span>*</span><span>;</span>
<span>    </span><span>#[test]</span>
<span>    </span><span>fn</span> <span>it_increments</span><span>() {</span>
<span>        </span><span>let</span><span> </span><span>mut</span><span> id</span>: <span>u32</span> <span>=</span><span> </span><span>0</span><span>;</span>
<span>        next_id_str(</span><span>&amp;</span><span>mut</span><span> id);</span>
<span>        next_id_str(</span><span>&amp;</span><span>mut</span><span> id);</span>
<span>        </span><span>assert_eq!</span><span>(id, </span><span>2</span><span>); </span>
<span>    }</span>

<span>    </span><span>#[test]</span>
<span>    </span><span>fn</span> <span>str_generator</span><span>() {</span>
<span>        </span><span>let</span><span> results</span>: <span>Vec</span><span>&lt;</span><span>String</span><span>&gt;</span><span> </span><span>=</span><span> </span><span>vec!</span><span>[</span><span>1</span><span>, </span><span>2</span><span>, </span><span>25</span><span>, </span><span>26</span><span>, </span><span>27</span><span>, </span><span>28</span><span>, </span><span>52</span><span>, </span><span>53</span><span>].iter().map(</span><span>|&amp;</span><span>x</span><span>|</span><span> num_to_id_str(x)).collect();</span>
<span>        </span><span>assert_eq!</span><span>(results, </span><span>vec!</span><span>[</span><span>&#34;a&#34;</span><span>, </span><span>&#34;b&#34;</span><span>, </span><span>&#34;y&#34;</span><span>, </span><span>&#34;z&#34;</span><span>, </span><span>&#34;aa&#34;</span><span>, </span><span>&#34;ab&#34;</span><span>, </span><span>&#34;az&#34;</span><span>, </span><span>&#34;ba&#34;</span><span>]);</span>
<span>    }</span>

<span>    </span><span>#[test]</span>
<span>    </span><span>fn</span> <span>incrementor_and_generator</span><span>() {</span>
<span>        </span><span>let</span><span> </span><span>mut</span><span> id</span>: <span>u32</span> <span>=</span><span> </span><span>0</span><span>;</span>
<span>        next_id_str(</span><span>&amp;</span><span>mut</span><span> id);</span>
<span>        </span><span>assert_eq!</span><span>(next_id_str(</span><span>&amp;</span><span>mut</span><span> id), </span><span>&#34;b&#34;</span><span>);</span>

<span>    }</span>
<span>}</span>
</code></pre></div>

</details>




<h2 id="3-try-gephi">3. Try Gephi</h2>

<p><a href="https://gephi.org/">Gephi</a> is a graph analysis tool. I used it because it was the first tool I found. There’s probably better ones out there.</p>

<p><a href="https://www.hillelwayne.com/post/graphing-tla/img/graph1.png"><img src="https://www.hillelwayne.com/post/graphing-tla/img/graph1.png" alt="The Gephi IDE, randomly shoving all the nodes in a square"/></a></p>

<p>Uhhhhhh that’s a mess. Let’s run a layout algorithm to make it at least tractable.</p>

<p><a href="https://www.hillelwayne.com/post/graphing-tla/img/forcegraph.png"><img src="https://www.hillelwayne.com/post/graphing-tla/img/forcegraph.png" alt="The graph laid out slightly better"/></a></p>

<p>That’s a little better. Those little dots on the bottom of the graph are graphviz options that got accidentally turned into nodes. I went through the data table and manually deleted them.</p>

<h2 id="4-discover-that-gephi-is-terrible">4. Discover that Gephi is terrible</h2>

<p>Gephi can make nice looking graphs and not much else. After fighting through the terrible documentation and UX I managed to filter for initial and terminal states. You can see the queries on the right-hand side of the window. Once I got the filters working I added a “Type” data column and labelled the corresponding states. That way I could assign special colors to root and terminal nodes.</p>

<p><a href="https://www.hillelwayne.com/post/graphing-tla/img/graph-colored.png"><img src="https://www.hillelwayne.com/post/graphing-tla/img/graph-colored.png" alt="Same layout, but now the nodes have colors"/></a></p>

<p>After that, I could manually look through the terminal nodes and see that they have different values of <code>x</code>.</p>

<p><a href="https://www.hillelwayne.com/post/graphing-tla/img/graph-terminal.png"><img src="https://www.hillelwayne.com/post/graphing-tla/img/graph-terminal.png" alt="Looking at the labels of the terminal states"/></a></p>

<p>Okay, so OD is refuted. I’m interested in checking more than just observational determinism, though, and I wanted to see what else Gephi could do. To start with, I wanted to extract the <code>x</code> value from the label and put it in its own column. After that, I’d see which values are most common in terminal states.</p>

<p>This is where I learned that Gephi hates me.</p>

<p>The <em>only</em> way to extract <code>x</code> is to duplicate the column and do a regex find/replace on the whole string. Gephi defaults to running the find/replace on every single column and resets that default every time you reopen the find/replace modal. If you forget to re-enable it just once then it’s time to reload the graph and start over, because <strong>there’s no way to undo changes</strong>.</p>

<p>In fact nothing in Gephi is undoable, and nothing is well documented, which together make the system inscrutable. You can’t learn what buttons do and you can’t safely try them out, especially when some buttons do things like “wipe all your layout and customizations and go back to grey blobs.”</p>

<p>…In retrospect, I should’ve guessed Gephi was a dead end. I don’t want to repeat painstaking manual labor every time I change the spec. What I really want is a software library.</p>

<p>(Unrelated, it’s interesting that most languages don’t have a <code>graph</code> type in their standard library. I’m guessing it’s because graphs have lots of different representations, which also have very different performance and API considerations.)</p>

<h2 id="5-start-over-with-networkx">5. Start over with NetworkX</h2>

<p><a href="https://networkx.org/">NetworkX</a> is a graph analysis library. I used it because I already know Python. There’s probably better ones out there.</p>

<p>NetworkX represents graphs as a dict of dicts of dicts. As far as I could figure out, you have to implement graph operations imperatively. For example, to extract <code>x</code> from the label, I had to iterate through every node and add <code>x</code> as an attribute.</p>
<div><pre><code data-lang="py"><span></span><span>for</span> <span>node</span> <span>in</span> <span>G:</span>
    <span>label</span> <span>=</span> <span>G</span><span>.</span><span>nodes[node][</span><span>&#34;label&#34;</span><span>]</span>
    <span>x</span> <span>=</span> <span>re</span><span>.</span><span>search(</span><span>r&#39;x\s*=\s*(\d+)&#39;</span><span>,</span> <span>label)</span><span>.</span><span>group(</span><span>1</span><span>)</span>
    <span>G</span><span>.</span><span>nodes[node][</span><span>&#34;x&#34;</span><span>]</span> <span>=</span> <span>int(x)</span>
</code></pre></div>

<p>To find the terminal states, I first removed all the self-loops, and then filtered for all the nodes with zero outbound degree (no outbound edges).</p>
<div><pre><code data-lang="py"><span></span><span>G</span><span>.</span><span>remove_edges_from(nx</span><span>.</span><span>selfloop_edges(G))</span>
<span>terminals</span> <span>=</span> <span>[n</span> <span>for</span> <span>n,</span> <span>deg</span> <span>in</span> <span>G</span><span>.</span><span>out_degree()</span> <span>if</span> <span>deg</span> <span>==</span> <span>0</span><span>]</span>
</code></pre></div>

<p>After that, I can pull all their <code>x</code> attributes to see the spread.</p>
<div><pre><code data-lang="py"><span></span><span>from</span> <span>collections</span> <span>import</span> <span>Counter</span>
<span>Counter([G</span><span>.</span><span>nodes[t][</span><span>&#34;x&#34;</span><span>]</span> <span>for</span> <span>t</span> <span>in</span> <span>terminals])</span>

<span># output</span>
<span>Counter({</span><span>4</span><span>:</span> <span>24</span><span>,</span> <span>3</span><span>:</span> <span>36</span><span>,</span> <span>2</span><span>:</span> <span>26</span><span>,</span> <span>1</span><span>:</span> <span>23</span><span>})</span>
</code></pre></div>

<p>So there are some end states where <code>x=4</code> and some where <code>x=3</code>, proving that our system is <em>not</em> observationally deterministic.</p>

<h2 id="6-go-mad-with-power-and-probability">6. Go mad with power (and probability)</h2>

<p>Something I wasn’t expecting: <code>x != 4</code> in three quarters of the end states. That seems really high for a race condition! I implemented the spec in C++ and it only had the race condition 0.1% of the time.</p>

<details>

  <summary>
    Show C++ code
  </summary>
  <div><pre><code data-lang="cpp"><span></span><span>#include</span><span> </span><span>&lt;iostream&gt;</span>
<span>#include</span><span> </span><span>&lt;thread&gt;</span>
<span>#include</span><span> </span><span>&lt;vector&gt;</span>

<span>const</span><span> </span><span>int</span><span> NUMRUNS </span><span>=</span><span> </span><span>30000</span><span>;</span>
<span>const</span><span> </span><span>int</span><span> NUMTHREADS </span><span>=</span><span> </span><span>4</span><span>;</span>
<span>int</span><span> x </span><span>=</span><span> </span><span>0</span><span>;</span>
<span>bool</span><span> wait </span><span>=</span><span> true;</span>

<span>void</span><span> </span><span>*</span><span>increment_x</span><span>()</span>
<span>{</span>
<span>    </span><span>while</span><span> (wait) {;}</span>
<span>    </span><span>int</span><span> tmp </span><span>=</span><span> x;</span>
<span>    tmp </span><span>=</span><span> tmp </span><span>+</span><span> </span><span>1</span><span>;</span>
<span>    x </span><span>=</span><span> tmp;</span>
<span>    </span><span>return</span><span> NULL;</span>
<span>}</span>

<span>int</span><span> </span><span>main</span><span>()</span>
<span>{</span>
<span>    </span><span>int</span><span> results[NUMTHREADS] {</span><span>0</span><span>};</span>
<span>    std</span><span>::</span><span>vector</span><span>&lt;</span><span>std</span><span>::</span><span>thread</span><span>&gt;</span><span> threads(NUMTHREADS);</span>

<span>    </span><span>for</span><span>(</span><span>int</span><span> i </span><span>=</span><span> </span><span>0</span><span>; i </span><span>&lt;</span><span> NUMRUNS; i</span><span>++</span><span>) {</span>
<span>      x </span><span>=</span><span> </span><span>0</span><span>;</span>
<span>      wait </span><span>=</span><span> true;</span>

<span>      </span><span>for</span><span>(</span><span>int</span><span> j</span><span>=</span><span>0</span><span>; j </span><span>&lt;</span><span> NUMTHREADS; j</span><span>++</span><span>) threads[j] </span><span>=</span><span> std</span><span>::</span><span>thread</span><span>(increment_x);</span>
<span>      </span>
<span>      wait </span><span>=</span><span> false;</span>
<span>      </span><span>for</span><span> (</span><span>auto</span><span>&amp;</span><span> th </span><span>:</span><span> threads) th.join();</span>
<span>      results[x</span><span>-1</span><span>] </span><span>+=</span><span> </span><span>1</span><span>; </span>
<span>    }</span>
<span>    </span><span>for</span><span>(</span><span>int</span><span> i </span><span>=</span><span> </span><span>0</span><span>; i </span><span>&lt;</span><span> NUMTHREADS; i</span><span>++</span><span>) std</span><span>::</span><span>cout </span><span>&lt;&lt;</span><span>  results[i] </span><span>&lt;&lt;</span><span> </span><span>&#34; &#34;</span><span>;</span>
<span>}</span>
</code></pre></div>

</details>




<p>There are two reasons why “count the end states” misestimates the likelihood. First, it assumes there’s only one path per end state. To see why this is a problem, here’s the state space for two threads:</p>

<p><a href="https://www.hillelwayne.com/post/graphing-tla/img/2threads.png"><img src="https://www.hillelwayne.com/post/graphing-tla/img/2threads.png" alt="The state space for 2 threads with a race condition"/></a></p>

<p>The space has three end states, and <code>x = 2</code> in two of those. But there are four <em>paths</em> to those three end states; two of them end in <code>x = 1</code>. That means it’s twice as likely to happen as either of the other states, <em>assuming</em> all transitions are equally likely.</p>

<p>And that’s the second issue: all transitions are <em>not</em> equally likely. In the spec, a Get followed by a second Get represents one thread interrupting another. Threads (on Windows) get 20ms slices at a time, and both assignment and increment operations both happen on the nanosecond scale. Each thread will more often complete both operations than complete one and then get interrupted. So two consecutive Gets should happen pretty rarely</p>

<p>“Pretty rarely” isn’t a concept in TLA+: either a state is possible or it isn’t. Figuring out the state’s <em>likelihood</em> is out of scope for the language. But with graph analysis, we’ve expanded the scope, and maybe that’ll be enough to get something interesting. I feel really out of my depth here and am learning this all as I go, but let’s give it a shot anyway.</p>

<p>So let’s say that if a thread takes an action, like Get, it’s more likely that thread will Inc than that the other thread will interrupt it and Get. As a <strong><em>very</em></strong> rough substitute, we’ll say that Inc transitions have more “weight” than Get transitions do.</p>

<figure> 
  <img src="https://www.hillelwayne.com/post/graphing-tla/img/transitions.png" title="Three examples of a root with two edges: get/get, inc/inc, get/inc"/> 
  <figcaption><a href="https://www.hillelwayne.com/post/graphing-tla/code/transitions.tex">(TikZ source)</a></figcaption>
</figure>

<p>In the first two images, we have only Gets and only Incs, so each transition is equally likely to happen. In the final image, we have one of each. If I weight each Inc as 3 times heavier than a Get, then it’ll happen 75% of the time. If we instead had 2 Incs and a Get, each Inc would happen 3/7ths the time and the Get would happen 1/7th.</p>

<p>That gives us the probability, given a state, of which edge we take. Now what’s the likelihood of <em>reaching</em> a given state? Let’s walk through an example state space:</p>

<figure> 
  <img src="https://www.hillelwayne.com/post/graphing-tla/img/likelihoods.png" title="Root transitions to two states, A B transition to three states (they share one), all edges have different weights"/> 
  <figcaption><a href="https://www.hillelwayne.com/post/graphing-tla/code/likelihoods.tex">(TikZ source)</a></figcaption>
</figure>

<p>I marked the weight of each edge. Now let’s walk through the likelihoods of each node:</p>

<ul>
<li><strong>R</strong> is the single root node, so it has likelihood <code>1</code>.</li>
<li>R is equally likely of going to <strong>A</strong> or <strong>B</strong>, so they each have likelihood <code>0.5</code>.</li>
<li>A goes to <strong>C</strong> 50% of the time. But we have to get to A to get to C, and that only happens 50% of the time! So the likelihood of C is <code>0.5*0.5 = 0.25</code>.</li>
<li>Similar logic shows that the likelihood of <strong>E</strong> is <code>0.5*0.75 = 0.375</code>.</li>
<li>The most interesting case is <strong>D</strong>. We can reach it from <em>either</em> A or B. So its likelihood is the sum of the two paths, or <code>0.375</code>.</li>
</ul>

<p>(This only works because there are no cycles in the state space. IIRC the technique broadly works with cycles, but you have to keep doing iterations over the graph until the likelihoods converge. This is basically the idea behind representing probabilistic systems as a <a href="https://en.wikipedia.org/wiki/Stochastic_matrix">stochastic matrix</a>.)</p>

<p>Now we have our algorithm for calculating each state likelihood. Then if we take all the terminal states with <code>x={k}</code> and sum their likelihoods, we’ll have the proper probability that we end with <code>x={k}</code>. Repeat for every <code>{k}</code> and we have the distribution of end values!</p>

<p>I implemented this algorithm, but explaining the code took 1,000 words and this essay is already long enough as it is. So I hosted the code elsewhere.</p>



<p><a href="https://github.com/hwayne/tla-graphing-demo">Link here</a>. It contains all of the work I put into this experiment:</p>

<ol>
<li>A copy of the <a href="https://github.com/hwayne/tla-graphing-demo/blob/master/threads.tla">TLA+ spec</a>, which you can use to generate new state space graphs</li>
<li>Five premade state space graphs, so you don’t have to learn how to use TLA+</li>
<li>A (python) script to make the graph nodes a little more readable</li>
<li>A python script that calculates the probabilistic property, along with <a href="https://github.com/hwayne/tla-graphing-demo/blob/master/notes.md">notes and commentary</a> on the code</li>
<li>A <a href="https://github.com/hwayne/tla-graphing-demo/tree/master/gephi">Gephi workspace</a> with all the hard cleanup work already done for you</li>
<li>A <a href="https://github.com/hwayne/tla-graphing-demo/tree/master/PRISM">PRISM probabilistic model</a> of the same problem, just because.</li>
</ol>

<p>I wrote it to be easy to study, so you can experiment with it too. I hope you find it useful!</p>

<p>To close out the experiment, let’s find some likelihoods:</p>
<div><pre><code data-lang="bash"><span></span>python<span> </span>likelihoods.py<span> </span>graphs/2_threads.dot<span> </span>--weight<span> </span><span>1</span>
Counter<span>({</span><span>2</span>:<span> </span><span>0</span>.5,<span> </span><span>1</span>:<span> </span><span>0</span>.5<span>})</span>

python<span> </span>likelihoods.py<span> </span>graphs/2_threads.dot<span> </span>--weight<span> </span><span>10</span>
Counter<span>({</span><span>2</span>:<span> </span><span>0</span>.91,<span> </span><span>1</span>:<span> </span><span>0</span>.09<span>})</span>

python<span> </span>likelihoods.py<span> </span>graphs/2_threads.dot<span> </span>--weight<span> </span><span>100</span>
Counter<span>({</span><span>2</span>:<span> </span><span>0</span>.9901,<span> </span><span>1</span>:<span> </span><span>0</span>.0099<span>})</span>
</code></pre></div>



<p>I’m excited about what this opens up! I’m hopeful the approach scales up to larger state spaces, too; it seems the majority of the script runtime is spent on importing the graphviz into NetworkX, the actual graph computations finish much faster. Even if it NetworkX doesn’t scale, maybe a more ergonomic graph analysis library would.</p>

<p>And man it’s feels good doing a blog post on advanced TLA+ use again. It’s been <a href="https://www.hillelwayne.com/post/tla-adt/">over a year</a> since the last time. I enjoy writing <a href="https://www.learntla.com">material for beginners</a> but it doesn’t scratch the same itch.</p>

<p>Anyway if you enjoyed this, I’m running a <a href="https://www.eventbrite.com/e/software-modeling-with-tla-workshop-tickets-520030754987?aff=website">1 day TLA+ workshop</a> in May and have a <a href="https://buttondown.email/hillelwayne/">newsletter</a> I update weekly.</p>

<p><em>Thanks to <a href="https://twitter.com/parlar">Jay Parlar</a>, <a href="http://lorinhochstein.org/">Lorin Hochstein</a>, and <a href="https://ahelwer.ca/">Andrew Helwer</a> for feedback.</em></p>


</div>

    



  </article></div>
  </body>
</html>
