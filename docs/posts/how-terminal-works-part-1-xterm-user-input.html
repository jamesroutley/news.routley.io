<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://kevroletin.github.io/terminal/2021/12/11/how-terminal-works-in.html">Original</a>
    <h1>How terminal works. Part 1: Xterm, user input</h1>
    
    <div id="readability-page-1" class="page"><div aria-label="Content">
      <div>
        <article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    <p><img src="https://kevroletin.github.io/assets/how-terminal-works/img/terminal_and_shell.jpg" alt=""/></p>

<ul id="markdown-toc">
  <li><a href="#motivation" id="markdown-toc-motivation">Motivation</a></li>
  <li><a href="#introduction" id="markdown-toc-introduction">Introduction</a></li>
  <li><a href="#user-input" id="markdown-toc-user-input">User input</a>    <ul>
      <li><a href="#strace" id="markdown-toc-strace">strace</a></li>
      <li><a href="#printing-non-printable" id="markdown-toc-printing-non-printable">Printing non-printable</a></li>
      <li><a href="#stty-raw--echo--isig" id="markdown-toc-stty-raw--echo--isig">stty raw -echo -isig</a></li>
      <li><a href="#utf-8" id="markdown-toc-utf-8">UTF-8</a></li>
    </ul>
  </li>
  <li><a href="#conclusion" id="markdown-toc-conclusion">Conclusion</a></li>
</ul>

<h2 id="motivation">Motivation</h2>

<p>This blog series explains how modern terminals and command-line tools work. The
primary goal here is to learn by <strong>experimenting</strong>. I’ll provide Linux tools to
debug every component mentioned in the discussion. Our focus is to discover
<strong>how</strong> things work. For the explanation of <strong>why</strong> things work in a certain
way, I encourage the reader to read excellent articles:</p>

<ul>
  <li><a href="https://www.linusakesson.net/programming/tty/">The TTY demystified</a></li>
  <li><a href="https://blog.nelhage.com/2009/12/a-brief-introduction-to-termios/">A Brief Introduction to termios</a></li>
</ul>

<p>and to visit a computer history museum:</p>

<ul>
  <li><a href="https://www.youtube.com/watch?v=S81GyMKH7zw">Teletype ASR 33 Part 10: ASR 33 demo</a></li>
  <li><a href="https://www.youtube.com/watch?v=uFQ3sajIdaM">The IBM 1401 compiles and runs FORTRAN II</a>.</li>
</ul>

<p>Please note that I talk solely about Linux (because that is what I use), but
many discussed concepts should apply to other Unix-like systems.</p>

<p>I’ve chosen the “learn by experimenting” approach because that’s how I’ve
learned about command-line tools. In my case, there was no single “click” moment
after which I’ve understood all the things. Instead, I’ve learned through a
never-ending process of building mental models, proving them to be wrong, and
then adjusting those models to reflect new knowledge.</p>

<p>Target audience are people who want to start working on command-line tools.</p>

<p>The series consists of 4 parts. The first two parts discuss how xterm work.
Parts 3 and 4 talk about different features of tty:</p>

<ul>
  <li>Part 1: Xterm, user input;</li>
  <li>Part 2: Xterm, CLI tool output;</li>
  <li>Part 3: pty, stty;</li>
  <li>Part 4: pty, sessions.</li>
</ul>

<h2 id="introduction">Introduction</h2>

<p>Let’s start the discussion with an <strong>inaccurate</strong> diagram that shows a general
use case for working with a command-line shell:</p>

<div><div><pre><code>           (1)   (2)   (3)
user &lt;---&gt; xterm &lt;---&gt; bash 

</code></pre></div></div>

<p>The user interacts with bash using a terminal emulator xterm. xterm is a GUI app
that receives “key pressed” events and writes corresponding characters into a
bidirectional filehandle (2). Bash reads those characters from (2) does
something and sends the output back to xterm, using the same filehandle (2).
Xterm reads, bash outputs from (2) and renders them on the screen. (2) is “just
a file” and this communication scheme looks pretty simple.</p>

<p>If the user asks bash to execute a command, let’s say <code>cat log.txt</code> then bash
spawns <code>cat</code> which uses the same filehandle to send its output to xterm:</p>

<div><div><pre><code>                       bash
           (1)   (2)     (4)
user &lt;---&gt; xterm &lt;---&gt;   cat

</code></pre></div></div>

<p>Again, pretty simple. In this unrealistic model (2) is “just a file” xterm and
cat exchange plain text.</p>

<p>In reality, things are slightly more complicated. Evolution extended the simple
scheme of “using a bidirectional filehandle to exchange plain text” to implement
additional features:</p>

<ol>
  <li>TUI interfaces. The terminal can draw characters at an arbitrary part of the
screen; command-line tools can ask capabilities of the terminal and can
handle window resize;</li>
  <li>job control. Shell organizes processes into logical groups which can be
paused/resumed or stopped altogether;</li>
  <li>access control for the filehandle (2). Bash has a feature to spawn background
processes. This might lead to a situation when two processes are writing
their output into the same filehandle (2) at the same time; there should be
some access control mechanism;</li>
  <li>“fixing” stupid tools which believe that the terminal is just a file with
plain text; so that those tools look and feel better.</li>
</ol>

<h2 id="user-input">User input</h2>

<p>Requirement above and 50 years of history led us to this scheme:</p>

<div><div><pre><code>           (1)         (2)       (3)
user &lt;---&gt; xterm &lt;---&gt; tty &lt;---&gt; bash

</code></pre></div></div>

<p>The first thing to notice is a “middle man” <strong>tty</strong> between xterm and bash. We
will discuss tty in parts 3 and 4. For now, we will just say that:</p>
<ul>
  <li>tty sits between xterm and bash and passes data from one to the other in both
directions;</li>
  <li>depending on its configuration, tty changes data it receives from one side
before passing to the other;</li>
  <li>there is command <code>stty raw -echo -isig</code> which configures tty to pass data “as
is without modification”.</li>
</ul>

<p>Using <code>stty raw -echo -isig</code> to disable most effects of tty is our primary
strategy to explore how xterm works. Until the part 3, we will ignore the
existence of tty and will concentrate on exploring xterm’s behavior.</p>

<p>Let’s start by discussing a bi-directional link between a user and xterm.
Converting scancodes that come from a keyboard into GUI events happens in two
steps. First, Linux handles hardware events and turns them into keycodes that
can be read by userland (using device descriptors like
<code>/dev/input/by-id/usb-2.4G_2.4G_Wireless_Device-event-kbd</code>). Second, Windows
system (X or Wayland) reads Linux keycodes and converts them into its own
keycodes, and also assigns a keysym (i.e. a Unicode character). To check how it
works, one can use:</p>

<ul>
  <li><code>sudo showkey</code> to explore Linux keycodes <em>(visit <a href="https://tldp.org/HOWTO/Keyboard-and-Console-HOWTO-14.html">this page</a> for more info)</em>;</li>
  <li><code>xev</code> (or <a href="https://git.sr.ht/~sircmpwn/wev"><code>wev</code></a> for Wayland users) to explore GUI events.</li>
</ul>

<p>For example, when I press the <code>q</code> button on my keyboard, depending on my keyboard layout I see:</p>
<ul>
  <li>showkey: keycode 16</li>
  <li>xev: keycode 24 (keysym 0x71, q)</li>
  <li>xev: keycode 24 (keysym 0x6ca, Cyrillic_shorti)</li>
</ul>

<p>xterm receives keypress events and writes data into tty(2):</p>
<ul>
  <li>it encodes printable characters using configured encoding (most probably UTF-8);</li>
  <li>on receiving some key combinations, it executes actions such as copy-paste from clipboard;</li>
  <li>it encodes other key combinations and non-printable characters (such as arrow
keys) using ANSI escape sequences (see post #2 for more details about ANSI
sequences).</li>
</ul>

<p>So converting key presses into data written into tty(2) happens in 3 steps, two
involving kernel and one in xterm. Now let’s figure out what xterm sends into
tty after all those 3 steps. There are two strategies we can use to accomplish
this task:</p>

<ul>
  <li><code>strace</code>: trace system calls <em>(we will trace <code>write</code> and <code>read</code> calls, but be aware that there are also
<a href="https://man7.org/linux/man-pages/man7/aio.7.html">aio</a> API)</em>;</li>
  <li>run a command-line tool that will
    <ul>
      <li>disable tty’s input/output processing using <code>stty raw -echo -isig</code></li>
      <li>log its inputs.</li>
    </ul>
  </li>
</ul>

<h3 id="strace">strace</h3>

<p>Let’s start with <code>strace</code> because it’s quite a practical approach. In your daily
life, if you’ll get stuck with misbehaving command-line tools, you can attach to
a running process and observe what your terminal is writing into filehandles and
what your shell reads. You don’t need to restart running programs to figure out
what is going on.</p>

<p>First, here is a little helper to find out PID of a terminal by clicking it with a computer mouse (for users of XWindows system):</p>

<div><div><pre><code>xprop | grep &#39;_NET_WM_PID(CARDINAL)&#39; | awk &#39;{print $3}&#39;
</code></pre></div></div>

<p>Then let’s observe what xterm writes and reads into/from filehandles (please
replace <code>-p 22853</code> with an appropriate PID):</p>

<div><div><pre><code>sudo strace -f -e &#39;trace=write,read&#39; -e write=all -e read=all -p 22853 2&gt;&amp;1 | grep -v EAGAIN
</code></pre></div></div>

<p>For testing, I’ve entered <code>qwe</code> sequence and strace gave me:</p>

<div><div><pre><code>write(4, &#34;q&#34;, 1)                        = 1
 | 00000  71                                                q                |
read(4, &#34;q&#34;, 4096)                      = 1
 | 00000  71                                                q                |
write(4, &#34;w&#34;, 1)                        = 1
 | 00000  77                                                w                |
read(4, &#34;w&#34;, 4096)                      = 1
 | 00000  77                                                w                |
write(4, &#34;e&#34;, 1)                        = 1
 | 00000  65                                                e                |
read(4, &#34;e&#34;, 4096)                      = 1
 | 00000  65
</code></pre></div></div>

<p>That makes sense. xterm sends (writes) <code>q</code>. tty+bash echoes back <code>q</code> to display
it so that the user can see what he/she entered. Then a sequence <code>we</code> follows
the same pattern. Now, I’ll try arrow keys: the left arrow and then the right
arrow:</p>

<div><div><pre><code>write(4, &#34;\33[D&#34;, 3)                    = 3
 | 00000  1b 5b 44                                          .[D              |
read(4, &#34;\10&#34;, 4096)                    = 1
 | 00000  08                                                .                |
write(4, &#34;\33[C&#34;, 3)                    = 3
 | 00000  1b 5b 43                                          .[C              |
read(4, &#34;\33[C&#34;, 4096)                  = 3
 | 00000  1b 5b 43                                          .[C              |
</code></pre></div></div>

<p>For left arrow key, xterm sends <code>\33[D</code> and receives back <code>\10</code>. <code>man ascii</code>
tells us that <code>33</code> Oct is the same <code>1b</code> Hex and it’s a <code>\ESC</code> (escape) ASCII
control character. <code>10</code> Oct is <code>08</code> Hex and its <code>BS</code> backspace control character
(commonly abbreviated as <code>\b</code> thanks to C programming language). We will discuss
ANSI escape sequences and ASCII control characters soon, for now, we can confirm
that using strace helps to observe what xterm is actually doing: it sends
<code>qwe\ESC[D\ESC[C</code> and receives <code>qwe\b\ESC[C</code>.</p>

<p>Let’s use strace to observe what bash is doing.</p>



<p>Entering the sequence <code>qwe&lt;left&gt;&lt;right&gt;</code> gives me symmetrical result from the
bash side: It receives <code>qwe\ESC[D\ESC[C</code> and sends <code>qwe\b\ESC[C</code> back.</p>

<div><div><pre><code>read(0, &#34;\33&#34;, 1)                       = 1
 | 00000  1b                                                .                |
read(0, &#34;[&#34;, 1)                         = 1
 | 00000  5b                                                [                |
read(0, &#34;D&#34;, 1)                         = 1
 | 00000  44                                                D                |
write(2, &#34;\10&#34;, 1)                      = 1
 | 00000  08
</code></pre></div></div>

<p>I’ve promised to ignore tty for a while, but just to show why it might be useful
to strace both a terminal and bash, let’s experiment. Let’s execute <code>cat -</code>
command and observe in real-time what xterm is sending to tty and what <code>cat</code>
receives.</p>

<p>First, let’s get the PID of a shell and then execute <code>cat</code></p>

<div><div><pre><code>echo $$

10519
sh-4.4$ cat -
</code></pre></div></div>

<p>Then in the other terminal window, let’s find out the PID of <code>cat</code> using “parent
PID” option of ps:</p>

<div><div><pre><code>ps --ppid 10519

  PID TTY          TIME CMD
10560 pts/5    00:00:00 cat
</code></pre></div></div>

<p>In my system, experiment shows that xterm writes characters one by one
immediately after I’ve pressed a keyboard button. Yet <code>cat</code> receives the entire
line only after I’ve pressed Enter. I can use the Backspace key to erase
previously entered characters, which is relatively complicated logic. This logic
is part of what tty is capable of.</p>

<div><div><pre><code>read(0, &#34;qwe\33[D\33[C\n&#34;, 131072)      = 10
 | 00000  71 77 65 1b 5b 44 1b 5b  43 0a                    qwe.[D.[C.       |
</code></pre></div></div>

<p>We will discuss tty in the 2nd part. For now, let’s just enjoy the success of
our debugging approach: we’ve just observed what <em>exactly</em> xterm and bash send
to each other and how tty (which sits in the middle) can alter data before
sending it to a consumer. The big limitation of such an approach is that reading
sequences like <code>\33[D\33[C\n</code> require a certain patience and might be quite hard
if applications output a lot of data ¯_(ツ)_/¯.</p>

<h3 id="printing-non-printable">Printing non-printable</h3>

<p>While playing with strace we’ve encountered sequences like this <code>\33[D\33[C</code>
which I’ve later written like this: <code>\ESC[D\ESC[C</code>. In my daily life, I
sometimes encounter different notations, for example <code>\u001b[D\u001b[C</code>,
<code>\x1b[D\x1b[C</code>, or something else. Different software uses different conventions
for visualizing non-printable characters. Also, many programming languages have
a way to embed non-printable characters into string literals using a sequence of
printable characters. But again, conventions for representing non-printable
characters using printable ones differ between programming languages.</p>

<p>Let’s discover how different software visualizes the ESC (escape) ASCII character:</p>



<ul>
  <li>vi, emacs: <code>^[</code></li>
  <li>less: <code>ESC</code></li>
  <li>code, gedit : on my systems render some nonsense</li>
  <li>hexdump: <code>1b</code> (hexdump supports many output formats)</li>
  <li>od -a : <code>esc</code> (od supports many output formats)</li>
  <li>strace: <code>\33</code> and <code>1b</code></li>
  <li>python: <code>\x1b</code>
    <div><div><pre><code>open(&#34;/tmp/data.txt&#34;, &#34;r&#34;).read()
</code></pre></div>    </div>
  </li>
  <li>Haskell: <code>\ESC</code>
    <div><div><pre><code>import qualified Data.ByteString as BS
BS.readFile &#34;/tmp/data.txt&#34; &gt;&gt;= print
</code></pre></div>    </div>
  </li>
  <li>nodejs: <code>\u001b</code>
    <div><div><pre><code>const fs = require(&#39;fs&#39;)
console.dir( fs.readFileSync(&#39;/tmp/data.txt&#39;, &#39;utf8&#39;) )
</code></pre></div>    </div>
  </li>
</ul>

<p>To make things more confusing, some popular programming languages support syntax
for embedding non-printable characters into string literals, but don’t provide
easily accessible function to convert a string into the same notation. For
example, using the C programming language, I can easily make a string containing
ESC character:</p>



<p>But the easiest way I know to visualize it using printable characters is to write code like this:</p>

<div><div><pre><code>#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;

int main() {
    FILE* f = fopen(&#34;/tmp/data.txt&#34;, &#34;r&#34;);
    int c = fgetc(f);
    while (!feof(f)) {
        if (isprint(c))
            printf(&#34;%c&#34;, c);
        else
            printf(&#34;\\x%x&#34;, c);
        c = fgetc(f);
    }
    return 0;
}
</code></pre></div></div>

<p>The moral here is that different tools visualize non-printable characters
differently. To make things less confusing it’s helpful to train your eye to
recognize magic strings <code>^[</code>, <code>\ESC</code>, <code>ESC</code>, <code>esc</code>, <code>1b</code>, <code>\x1b</code>, <code>0x1b</code>,
<code>\u001b</code>, <code>33</code>, <code>27</code>. Also, it’s helpful to choose tools you can understand even
under stress.</p>

<h3 id="stty-raw--echo--isig">stty raw -echo -isig</h3>

<p>We’ve traced xterm using <code>strace</code> to check what it sends to bash. We can
accomplish a similar task without using a tracing tool. The most fool-proof way
to do so is to disable the effects of tty and to dump binary data which comes
from tty into a file. Then we can explore the content of a file using our
favorite tool of choice:</p>

<div><div><pre><code>stty raw -echo -isig; dd bs=1 of=/tmp/data.txt
</code></pre></div></div>

<p>I prefer to use vi or od:</p>

<div><div><pre><code>vi /tmp/data.txt
od -ac /tmp/data.txt
</code></pre></div></div>

<p>It might be cool to visualize the same data in real-time. One can use this bash
one-liner:</p>

<div><div><pre><code>stty sane -isig -echo -icanon; while true; do od -N 1 -ax -; done
</code></pre></div></div>

<p>Or convert <code>man ascii</code> into a <a href="https://kevroletin.github.io/assets/how-terminal-works/display_ascii.c">small c
program</a>. It executes <code>stty raw
-echo</code> on startup, so that tty doesn’t change terminal output and hence the tool
shows what terminal sends into tty.</p>

<p>Pressing a sequence of <code>a</code>, <code>1</code>, <code>Ctrl+d</code>, <code>Ctrl+l</code> gives:</p>

<div><div><pre><code>a
1
EOT (end of transmission)
FF  &#39;\f&#39; (form feed)
</code></pre></div></div>

<p><code>Alt+d</code> gives 2 characters:</p>



<p><code>Ctrl+Alt+Shift+d</code> gives:</p>

<div><div><pre><code>ESC (escape)
EOT (end of transmission)
</code></pre></div></div>

<p>which is the same as <code>Ctrl+Alt+d</code>, Shift is just ignored.</p>

<p>That behavior of xterm is <strong>not</strong> set in stone and it is configurable in a
terminal-dependent way. Depending on its configuration, xterm might send
different things in response to <code>Ctrl+Alt+Shift</code> combination. Here is the
discussion about xterm <a href="https://invisible-island.net/xterm/modified-keys.html">modified
keys</a>.</p>

<h3 id="utf-8">UTF-8</h3>

<p>Utf8 has a few nice features which I didn’t appreciate enough until recently:</p>

<ol>
  <li>Utf8 is a self-synchronizing code. If you take any Utf8-encoded string and
randomly chop off the beginning so that you end up in the middle of
multi-byte character, then:
    <ul>
      <li>you’ll be able to detect an error: an attempt to decode an invalid character;</li>
      <li>you’ll be able to recover from the error by discarding bytes of a broken
character and figure out the beginning of the next valid character.</li>
    </ul>
  </li>
  <li>ASCII characters (including control character) are valid one-byte Utf8 encoded characters.</li>
</ol>

<p>Combined (1) and (2) give us a nice property that control characters will never
appear as part of multi-byte characters. I.e. python code below is correct for
any string comprising multi-byte Utf8 characters:</p>

<div><div><pre><code>&#34;编程很有趣&#34;.find(&#34;\n&#34;) == -1
</code></pre></div></div>

<p>Let’s understand why this is the case. <code>编程很有趣</code> is encoded using 15 bytes;
below I’ve represented bytes using decimal numbers:</p>

<div><div><pre><code>编            程             很            有            趣
231 188 150 | 231 168 139 | 229 190 136 | 230 156 137 | 232 182 163
</code></pre></div></div>

<p>All these numbers are greater than 127 Dec. But all ASCII characters (including
control characters) are lesser or equal to 127 Dec. So it’s safe to search for
single-byte ASCII characters in Utf8 strings without decoding them because all
bytes of every valid multi-byte character is guaranteed to be greater than 127
Dec.</p>

<p>Error recovery is possible, and it works surprisingly simple. In binary
notation, all ASCII characters start with leading <code>0</code>, all bytes of multi-byte
characters start with <code>1</code>. In addition, for multi-byte characters:</p>
<ul>
  <li>only the first byte of a character can start with <code>11</code>;</li>
  <li>all continuation bytes (bytes 2, 3, 4) start with <code>10</code>.</li>
</ul>

<p>You can easily observe these properties in action:</p>

<div><div><pre><code>编
11100111
10111100
10010110
程
11100111
10101000
10001011
很
11100101
10111110
10001000
有
11100110
10011100
10001001
趣
11101000
10110110
10100011
</code></pre></div></div>

<p>Each byte starts with <code>1</code> indicating that it’s a part of a multi-byte character.
Also, each byte contains an indication if it’s the first byte or a continuation
byte.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Using strace and by disabling tty features, we’ve explored how keyboard input
from users reaches command-line tools. We also saw that xterm might send
non-printable characters and different tools visualize non-printable characters
differently. Also, we’ve improved our mental resilience by getting accustomed to
different notations and by trying different tools for visualizing control
characters. Finally, we said a few words about Utf8 encoding, which is the most
widely used Unicode encoding nowadays.</p>

<p>In this blog, post we’ve discussed how xterm handles user input. Next post will
discuss how xterm visualizes the output of CLI tools.</p>

<p>Stay tuned :)</p>

  </div>
</article>

      </div>
    </div></div>
  </body>
</html>
