<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://iscinumpy.dev/post/packaging-faster/">Original</a>
    <h1>How we made Python&#39;s packaging library 3x faster</h1>
    
    <div id="readability-page-1" class="page"><div role="main">
  <div>
    <div>
      <article role="main">
        <p>Along with a <a href="https://github.com/pypa/pip">pip</a> (and now <a href="https://github.com/pypa/packaging">packaging</a>) maintainer, Damian Shaw, I have
been working on making <a href="https://github.com/pypa/packaging">packaging</a>, the library behind almost all packaging
related tools, faster at reading versions and specifiers, something tools like
pip have to do thousands of times during resolution. Using Python 3.15’s new
statistical profiler and metadata from every package ever uploaded to PyPI, I
measured and improved core Packaging constructs while keeping the code readable
and simple. Reading in <code>Version</code>s can be up to 2x faster and <code>SpecifierSet</code>s can
be up to 3x faster in <a href="https://github.com/pypa/packaging/releases/tag/26.0rc1">packaging <code>26.0rc1</code></a>, now released! Other
operations have been optimized, as well, up to 5x in some cases. See the
<a href="https://discuss.python.org/t/announcement-packaging-26-0rc1-released/105631">announcement</a> and <a href="https://github.com/pypa/packaging/releases/tag/26.0rc1">release notes</a> too; this post will focus on the
performance work only.</p>
<h2 id="introduction">Introduction</h2>
<p><code>packaging</code> is the core library used by most tools for Python to deal with many
of the standardized packaging constructs, like versions, specifiers, markers,
and the like. It is the 11th most downloaded library, but if you also take into
account that it is vendored into pip, meaning you get a (hidden) copy with every
pip install, it’s actually the 2nd most downloaded library. Given that pip is
vendored into Python, everyone who has Python has <code>packaging</code>, unless their
distro strips it out into a separate package; so it is possible it is the most
common third party Python library in the world.</p>
<p>In packaging, a <code>Version</code> is something that follows <a href="https://peps.python.org/pep-0440">PEP 440</a>’s version
standard. And a <code>SpecifierSet</code> is conditions on that version; think <code>&gt;=2,&lt;3</code> or
<code>~=1.0</code>, those are <code>SpecifierSet</code>s. They are used on dependencies, on
<code>requires-python</code>, etc. They are also part of <code>Marker</code>s, that is, something like
<code>tomli; python_version &lt; &#39;3.11&#39;</code> (a <code>Requirement</code>) contains a <code>Marker</code>.</p>
<p>I’d like to start by showing you the progress we’ve made as a series of plots;
if you’d like to see how we made some of these, I’ll follow with in-depth
examples.</p>
<h2 id="performance-plots-with-asv">Performance plots with asv</h2>
<p>After most of the performance PRs were made, I finally invested a little time
into making a proper set of micro-benchmarks with <a href="https://asv.readthedocs.io">asv</a>; I’ll be showing plots
from that. Code for this is currently in <a href="https://github.com/henryiii/packaging/tree/henryiii/chore/bench">a branch</a> in my fork; it
might eventually be either contributed or moved to a separate repo. The
benchmarks are an optimized (trimmed down) version of the original code.</p>
<p>Plots were made using code in the <code>source</code> directory of my blog repository;
values are scaled by the 25.0 performance numbers, with a green line showing the
current performance after the changes we’ve been working on. I ran them with
Python 3.14 from <code>uv</code> (which is a bit faster than the one from homebrew) on an
entry-level M1 Mac Mini. The plot xscale is expanded after 25.0 to show the
current work.</p>
<hr/>
<p><img src="https://iscinumpy.dev/post/packaging-faster/version.TimeVersionSuite.time_constructor.svg" alt="Version constructor"/></p>
<p>This is the <code>Version</code> constructor. You can see the series of PRs described below
lowering the time to 0.5. Now, one of those steps was making the comparison
tuple generated on first usage, instead of in the constructor, so the sorting
benchmark has taken on that cost:</p>
<hr/>
<p><img src="https://iscinumpy.dev/post/packaging-faster/version.TimeVersionSuite.time_sort.svg" alt="Version sort"/></p>
<p>Sorting isn’t slower than before, we’ve just moved some of the construction time
over to the first time you compare a version; inside pip, only around 30% of the
versions constructed actually get compared, so this is a savings.</p>
<p>I did play around with the idea of computing <code>__lt__</code> and friends directly,
instead of making a tuple, caching it, then comparing that. But it seems Python
optimizes tuple comparison, and these get compared a lot when sorting, so even
though the custom method could exit early and save a little calculation, it
still was something like 5x slower.</p>
<hr/>
<p><img src="https://iscinumpy.dev/post/packaging-faster/version.TimeVersionSuite.time_str.svg" alt="Version str"/></p>
<p>Here you can see optimizations for <code>__str__</code>; we’ve mostly avoided calling the
<code>Version -&gt; str -&gt; Version</code> like we used to, but this still helps third party
packages that do this.</p>
<hr/>
<p><img src="https://iscinumpy.dev/post/packaging-faster/specifiers.TimeSpecSuite.time_constructor.svg" alt="SpecifierSet construction"/></p>
<p>Here we can see <code>SpecifierSet</code>’s construction time. In the past, there were two
major regressions; The first bump around 2020 was a bugfix; the added logic is
needed for correctness. The second was the introduction of the nested
<code>NamedTuple</code> and some other slowdowns we have now fixed.</p>
<hr/>
<p><img src="https://iscinumpy.dev/post/packaging-faster/specifiers.TimeSpecSuite.time_contains.svg" alt="SpecifierSet contains"/></p>
<p>One of the most important operations on <code>SpecifierSet</code> is asking if a version is
contained in it. Here you can see that we’ve managed to get this over 2x faster.</p>
<hr/>
<p><img src="https://iscinumpy.dev/post/packaging-faster/specifiers.TimeSpecSuite.time_filter.svg" alt="SpecifierSet filter"/></p>
<p>Another core operation is <code>.filter</code>, which we’ve made about 5x faster. Most of
this was from caching the <code>Version</code>, avoiding repeated Version constructors.</p>
<hr/>
<p><img src="https://iscinumpy.dev/post/packaging-faster/markers.TimeMarkerSuite.time_constructor.svg" alt="Marker constructor"/></p>
<p>Another constructor is <code>Marker</code>. The big jump in version 22 was moving to a
handwritten parser instead of pyparsing (which also isolated us from breakages
due to pyparsing changing their API, and removed our only dependency, too!), but
we’ve further improved this since 25.0 by dropping the regular expression
construction inside the constructor.</p>
<hr/>
<p><img src="https://iscinumpy.dev/post/packaging-faster/markers.TimeMarkerSuite.time_evaluate.svg" alt="Marker evaluate"/></p>
<p>Evaluating <code>Marker</code>s (to see if the <code>Requirement</code> passes a particular
environment) has also gotten faster. Most of that final drop is from avoiding
trying to parse everything as a <code>Version</code>, and instead just apply <code>Version</code> to
things that might be versions.</p>
<hr/>
<p><img src="https://iscinumpy.dev/post/packaging-faster/requirement.TimeRequirementSuite.time_constructor.svg" alt="Requirement constructor"/></p>
<p>For reconstructing <code>Requirement</code>, this is similar to <code>Marker</code> (since it contains
them).</p>
<hr/>
<p><img src="https://iscinumpy.dev/post/packaging-faster/utils.TimeUtils.time_canonicalize_name.svg" alt="Utilities: canonicalize_name"/></p>
<p>Here’s a microbenchmark of the <code>canonicalize_name</code> function, which we made 2x
faster by removing a regular expression substitution, using <code>str.translate</code>
instead.</p>
<hr/>
<p><img src="https://iscinumpy.dev/post/packaging-faster/resolver.TimeResolverSuite.time_resolver_loop.svg" alt="Resolver loop"/></p>
<p>For our final benchmark, this is a quick attempt at making a toy resolver. The
one bump up is from a fix for proper PEP 440 handling of prereleases.</p>
<h2 id="how-it-started">How it started</h2>
<p>Now that you’ve seen what we’ve done, let’s look at how we got there.</p>
<p>This optimization work started when Damian Shaw <a href="https://github.com/pypa/packaging/pull/985">made a PR</a> to reduce
the number of Versions being created during specifier comparison operations,
with a note about how pip needed to create thousands of these. That got me
interested; I was looking into why <code>Version</code>’s were slow to create in the first
place. During the work, Kevin Turcios also got involved, looking for potential
slow operations using an AI tool he works on. Also huge thanks to Brett Cannon
for reviewing many of these PRs.</p>
<h3 id="measuring-version-and-atomicpossessive-regex-3115-only">Measuring Version and atomic/possessive regex (3.11.5+ only)</h3>
<p>The core of the <code>Version</code> object is a regular expression; the rules specified in
PEP 440 can be expressed as a regular expression. While most versions look like
<code>1.2.3</code>, there are a lot of optional parts; <code>2!1.2.3.dev1.post1+extra</code> is also a
valid version (don’t try to upload it to PyPI, but it is valid as a <code>Version</code>!).
A regular expression is a natural way to express something like that, and
probably will be faster than lots of string manipulations; but regular
expressions are known to be slow. Since I teach students in my <a href="https://se-for-sci.github.io/content/intro.html">APC 524
class</a> at Princeton to always profile before they start to optimize,
<del>I started by profiling, of course</del>. Okay… I first worked on the regex,
because I <em>knew</em> it had to be slow. I used Python 3.11’s new atomic grouping and
possessive qualifiers to reduce backtracking; once you’ve matched a part you
don’t need to go back and try other matches on the same part of the version.
This did make it faster - by something like 5%.</p>
<p>To measure this, I started by just asking ChatGPT for some versions valid in
Python, it gave me 10 or so, then I multiplied that by a large number and that
gave me something I could run. A little later, I <a href="https://py-code.org">downloaded the
metadata</a> for PyPI (about 10GB sqlite file), and read in every
version published, filtering out invalid versions (PyPI used to not validate
versions; it predates <a href="https://peps.python.org/pep-0440">PEP 440</a> anyway!), and started using that (final
benchmarking code is at the end). This also gave me a way to ensure that the
same versions were being read; if the number of versions changed, then the regex
was doing something differently.</p>
<p>Here’s the quick script:</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>import</span> <span>timeit</span>
</span></span><span><span><span>from</span> <span>packaging.version</span> <span>import</span> <span>Version</span>
</span></span><span><span>
</span></span><span><span><span>TEST_VERSIONS</span> <span>=</span> <span>[</span>
</span></span><span><span>    <span>&#34;1.0.0&#34;</span><span>,</span>
</span></span><span><span>    <span>&#34;2.7&#34;</span><span>,</span>
</span></span><span><span>    <span>&#34;1.2.3rc1&#34;</span><span>,</span>
</span></span><span><span>    <span>&#34;0.9.0.dev4&#34;</span><span>,</span>
</span></span><span><span>    <span>&#34;10.5.1.post2&#34;</span><span>,</span>
</span></span><span><span>    <span>&#34;1!2.3.4&#34;</span><span>,</span>
</span></span><span><span>    <span>&#34;1.0+abc.1&#34;</span><span>,</span>
</span></span><span><span>    <span>&#34;2025.11.24&#34;</span><span>,</span>
</span></span><span><span>    <span>&#34;3.4.5-preview.8&#34;</span><span>,</span>
</span></span><span><span>    <span>&#34;v1.0.0&#34;</span><span>,</span>
</span></span><span><span><span>]</span> <span>*</span> <span>10_000</span>
</span></span><span><span>
</span></span><span><span>
</span></span><span><span><span>def</span> <span>bench</span><span>():</span>
</span></span><span><span>    <span>for</span> <span>v</span> <span>in</span> <span>TEST_VERSIONS</span><span>:</span>
</span></span><span><span>        <span>Version</span><span>(</span><span>v</span><span>)</span>
</span></span><span><span>
</span></span><span><span>
</span></span><span><span><span>if</span> <span>__name__</span> <span>==</span> <span>&#34;__main__&#34;</span><span>:</span>
</span></span><span><span>    <span>t</span> <span>=</span> <span>timeit</span><span>.</span><span>timeit</span><span>(</span><span>&#34;bench()&#34;</span><span>,</span> <span>globals</span><span>=</span><span>globals</span><span>(),</span> <span>number</span><span>=</span><span>5</span><span>)</span>
</span></span><span><span>    <span>print</span><span>(</span><span>f</span><span>&#34;Time: </span><span>{</span><span>t</span><span>:</span><span>.4f</span><span>}</span><span> seconds&#34;</span><span>)</span>
</span></span></code></pre></div><h3 id="profiling-version">Profiling Version</h3>
<p>This result didn’t make sense; the regex was faster, so it should have had a
bigger impact on <code>Version</code>s as a whole. I decided to do what I should have done
first: profile. This was a perfect opportunity to try CPython 3.15.0’s new
statistical profiler that I’d been hearing about on the <a href="https://open.spotify.com/show/1PGRfdrLEwgXjQbPBNk1pW">Core.Py podcast</a>.
Since <code>uv python install</code> can install the 3.15 alpha’s, it was easy to get it, I
didn’t even have to build anything. Since <code>packaging</code> doesn’t have any compiled
dependencies, everything worked smoothly with the alpha version.</p>
<p>To use it, something like this works on macOS:</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span>sudo -E uv run --python 3.15 python -m profiling.sampling tasks/benchmark_version.py
</span></span></code></pre></div><p>It might trigger an install with <code>sudo</code> active, which means you’ll have to clear
<a href="https://github.com/astral-sh/uv">uv</a>’s cache and python installs also with <code>sudo</code>, but it got me going.</p>
<p>The textual output was nice, and the html output was great; for a zero-setup
profile (well, once Python 3.15 is out), this is fantastic.</p>
<p>Here’s what it looked like:</p>
<p><img src="https://iscinumpy.dev/post/packaging-faster/first-version.svg" alt="First flamegraph of Version"/></p>
<details><summary>Textual output (click to expand)</summary>
<div><pre tabindex="0"><code data-lang="console"><span><span><span>$</span> sudo -E uv run --python 3.15 python -m profiling.sampling tasks/benchmark_version.py
</span></span><span><span><span>Time: 1.3528 seconds
</span></span></span><span><span><span>Per version: 2.705616084 µs
</span></span></span><span><span><span>Captured 13646 samples in 1.36 seconds
</span></span></span><span><span><span>Sample rate: 10000.01 samples/sec
</span></span></span><span><span><span>Error rate: 20.57%
</span></span></span><span><span><span>Profile Stats:
</span></span></span><span><span><span>       nsamples   sample%  tottime (ms)    cumul%   cumtime (s)  filename:lineno(function)
</span></span></span><span><span><span>        1/10703       0.0         0.100      99.4         1.070  _sync_coordinator.py:193(_execute_script)
</span></span></span><span><span><span>        0/10703       0.0         0.000      99.4         1.070  _sync_coordinator.py:234(main)
</span></span></span><span><span><span>        0/10703       0.0         0.000      99.4         1.070  _sync_coordinator.py:251(&lt;module&gt;)
</span></span></span><span><span><span>        0/10703       0.0         0.000      99.4         1.070  &lt;frozen runpy&gt;:88(_run_code)
</span></span></span><span><span><span>        0/10703       0.0         0.000      99.4         1.070  &lt;frozen runpy&gt;:198(_run_module_as_main)
</span></span></span><span><span><span>        0/10661       0.0         0.000      99.0         1.066  &lt;timeit-src&gt;:6(inner)
</span></span></span><span><span><span>        0/10661       0.0         0.000      99.0         1.066  timeit.py:183(Timer.timeit)
</span></span></span><span><span><span>        0/10661       0.0         0.000      99.0         1.066  timeit.py:240(timeit)
</span></span></span><span><span><span>        0/10661       0.0         0.000      99.0         1.066  benchmark_version.py:25(&lt;module&gt;)
</span></span></span><span><span><span>      670/10660       6.2        67.000      99.0         1.066  benchmark_version.py:21(bench)
</span></span></span><span><span><span>        82/9990       0.8         8.200      92.7         0.999  __init__:0(__init__)
</span></span></span><span><span><span>      2613/2623      24.3       261.300      24.4         0.262  version.py:201(Version.__init__)
</span></span></span><span><span><span>       951/2106       8.8        95.100      19.6         0.211  version.py:218(Version.__init__)
</span></span></span><span><span><span>      1660/1813      15.4       166.000      16.8         0.181  version.py:208(Version.__init__)
</span></span></span><span><span><span>      1068/1151       9.9       106.800      10.7         0.115  version.py:206(Version.__init__)
</span></span></span><span><span><span></span><span>
</span></span></span><span><span><span></span><span>Legend:
</span></span></span><span><span><span>  nsamples: Direct/Cumulative samples (direct executing / on call stack)
</span></span></span><span><span><span>  sample%: Percentage of total samples this function was directly executing
</span></span></span><span><span><span>  tottime: Estimated total time spent directly in this function
</span></span></span><span><span><span>  cumul%: Percentage of total samples when this function was on the call stack
</span></span></span><span><span><span>  cumtime: Estimated cumulative time (including time in called functions)
</span></span></span><span><span><span>  filename:lineno(function): Function location and name
</span></span></span><span><span><span></span><span>
</span></span></span><span><span><span></span><span>Summary of Interesting Functions:
</span></span></span><span><span><span></span><span>
</span></span></span><span><span><span></span><span>Functions with Highest Direct/Cumulative Ratio (Hot Spots):
</span></span></span><span><span><span>  0.818 direct/cumulative ratio, 58.4% direct samples: version.py:(Version.__init__)
</span></span></span><span><span><span>  0.063 direct/cumulative ratio, 6.2% direct samples: benchmark_version.py:(bench)
</span></span></span><span><span><span>  0.008 direct/cumulative ratio, 0.8% direct samples: __init__:(__init__)
</span></span></span><span><span><span></span><span>
</span></span></span><span><span><span></span><span>Functions with Highest Call Frequency (Indirect Calls):
</span></span></span><span><span><span>  10703 indirect calls, 99.4% total stack presence: _sync_coordinator.py:(main)
</span></span></span><span><span><span>  10703 indirect calls, 99.4% total stack presence: _sync_coordinator.py:(&lt;module&gt;)
</span></span></span><span><span><span>  10703 indirect calls, 99.4% total stack presence: &lt;frozen runpy&gt;:(_run_code)
</span></span></span><span><span><span></span><span>
</span></span></span><span><span><span></span><span>Functions with Highest Call Magnification (Cumulative/Direct):
</span></span></span><span><span><span>  10703.0x call magnification, 10702 indirect calls from 1 direct: _sync_coordinator.py:(_execute_script)
</span></span></span><span><span><span>  121.8x call magnification, 9908 indirect calls from 82 direct: __init__:(__init__)
</span></span></span><span><span><span>  15.9x call magnification, 9990 indirect calls from 670 direct: benchmark_version.py:(bench)
</span></span></span></code></pre></div>

</details>

<p>(The HTML version has line numbers and more info.) That’s not what I expected at
all. While you can see the regex (first blue section on the left), it’s not
dominating; there’s a bunch of other stuff nearly as large as the regex.</p>
<h2 id="speedups">Speedups</h2>
<h3 id="stripping-0s-10-speedup">Stripping 0’s: 10% speedup</h3>
<p>The first speedup I saw was this line:</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>_release</span> <span>=</span> <span>tuple</span><span>(</span>
</span></span><span><span>    <span>reversed</span><span>(</span><span>list</span><span>(</span><span>itertools</span><span>.</span><span>dropwhile</span><span>(</span><span>lambda</span> <span>x</span><span>:</span> <span>x</span> <span>==</span> <span>0</span><span>,</span> <span>reversed</span><span>(</span><span>release</span><span>))))</span>
</span></span><span><span><span>)</span>
</span></span></code></pre></div><p>That’s terrible, it’s generating tons of small lists and dropping them. I
started with a version that is very fast, making this line 20x faster and
dropping it off the profile. This was my first version:</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>def</span> <span>_strip_trailing_zeros</span><span>(</span><span>release</span><span>:</span> <span>tuple</span><span>[</span><span>int</span><span>,</span> <span>...</span><span>])</span> <span>-&gt;</span> <span>tuple</span><span>[</span><span>int</span><span>,</span> <span>...</span><span>]:</span>
</span></span><span><span>    <span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>len</span><span>(</span><span>release</span><span>)</span> <span>-</span> <span>1</span><span>,</span> <span>-</span><span>1</span><span>,</span> <span>-</span><span>1</span><span>):</span>
</span></span><span><span>        <span>if</span> <span>release</span><span>[</span><span>i</span><span>]</span> <span>!=</span> <span>0</span><span>:</span>
</span></span><span><span>            <span>return</span> <span>release</span><span>[:</span> <span>i</span> <span>+</span> <span>1</span><span>]</span>
</span></span><span><span>    <span>return</span> <span>()</span>
</span></span></code></pre></div><p><a href="https://github.com/pypa/packaging/pull/987">This</a> sped reading versions up by about 10% in my benchmark, and by
about 40% in pip’s resolver.</p>
<p>There’s overhead to the call, though, so later I got another 10% or so by
starting from a suggestion from ℤahlman on the PyPA Discord:</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>while</span> <span>release</span> <span>and</span> <span>release</span><span>[</span><span>-</span><span>1</span><span>]</span> <span>==</span> <span>0</span><span>:</span>
</span></span><span><span>    <span>release</span> <span>=</span> <span>release</span><span>[:</span><span>-</span><span>1</span><span>]</span>
</span></span></code></pre></div><p>And coming up with an in-between version with good performance by being inline:</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>len_release</span> <span>=</span> <span>len</span><span>(</span><span>release</span><span>)</span>
</span></span><span><span><span>i</span> <span>=</span> <span>len_release</span>
</span></span><span><span><span>while</span> <span>i</span> <span>and</span> <span>release</span><span>[</span><span>i</span> <span>-</span> <span>1</span><span>]</span> <span>==</span> <span>0</span><span>:</span>
</span></span><span><span>    <span>i</span> <span>-=</span> <span>1</span>
</span></span><span><span><span>_release</span> <span>=</span> <span>release</span> <span>if</span> <span>i</span> <span>==</span> <span>len_release</span> <span>else</span> <span>release</span><span>[:</span><span>i</span><span>]</span>
</span></span></code></pre></div><p>This avoids creating multiple tuples; it even avoids a slice in the common case
of no stripped zeros.</p>
<h3 id="faster-regex-10-17-faster-3115-only">Faster Regex (10-17% faster, 3.11.5+ only)</h3>
<p>I did go ahead and make the <a href="https://github.com/pypa/packaging/pull/988">regex PR</a>. I dropped atomic groups; just
using possessive qualifiers got the speed up I wanted and it was easier to strip
them out to support older versions of Python with the same single regex string.
The 10-17% speedup might not seem like a lot, but I still planned to remove a
lot of the other things that were keeping the regex from dominating.</p>
<p>To do this, <code>*</code> becomes <code>*+</code>, and <code>?</code> becomes <code>?+</code>. You just need to be careful
to only apply it where backtracking is not needed, like between each group.
Inside a group, there are cases where you might need to backtrack. To support
older Python versions, <code>PATTERN.replace(&#34;*+&#34;, &#34;*&#34;).replace(&#34;?+&#34;, &#34;?&#34;)</code> can be
used to strip this back out (atomic groups are harder to strip out). Note that
possessive qualifiers were broken on CPython 3.11.0-3.11.4, so the same
stripping needs to be done there.</p>
<p>I also cleaned up the regex code a bit, using <code>fullmatch</code> instead of <code>search</code>
with anchors, which also seemed a little (1%) faster, could be within
measurement uncertainty though.</p>
<p>Note that if you are trying to speed anything up except <code>packaging</code> itself, you
can add the <a href="https://pypi.org/project/regex">regex PyPI library</a> and that supports these features on
older Python versions too. The <code>packaging</code> library can’t have dependencies,
especially compiled ones.</p>
<h3 id="specifierset-removing-singledispatch-7-faster">SpecifierSet: Removing singledispatch (7% faster)</h3>
<p>I noticed another slow part in the flamegraph was <code>canonicalize_version</code>, which
used a <code>functools.singledispatch</code> instead of an if statement; while I love
<code>singledispatch</code> for a very specific style of programming, this isn’t a good use
of it, and it’s slow. The function is now simpler, and faster.</p>
<p>This is basically what it was doing:</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span># Bad pattern</span>
</span></span><span><span><span>@functools.singledispatch</span>
</span></span><span><span><span>def</span> <span>f</span><span>(</span><span>x</span><span>:</span> <span>Version</span> <span>|</span> <span>str</span><span>)</span> <span>-&gt;</span> <span>str</span><span>:</span>
</span></span><span><span>    <span>str</span><span>(</span><span>_TrimmedRelease</span><span>(</span><span>str</span><span>(</span><span>...</span><span>)))</span>
</span></span><span><span>
</span></span><span><span>
</span></span><span><span><span>@f.register</span>
</span></span><span><span><span>def</span> <span>f</span><span>(</span><span>x</span><span>:</span> <span>str</span><span>)</span> <span>-&gt;</span> <span>object</span><span>:</span>
</span></span><span><span>    <span>return</span> <span>f</span><span>(</span><span>Version</span><span>(</span><span>x</span><span>))</span>
</span></span></code></pre></div><p>Notice how the dispatched functions call the generic function, and the types
overlap. Those are signs that this shouldn’t even be used. <a href="https://github.com/pypa/packaging/pull/993">A better
version</a> would be:</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>def</span> <span>f</span><span>(</span><span>x</span><span>:</span> <span>Version</span> <span>|</span> <span>str</span><span>)</span> <span>-&gt;</span> <span>str</span><span>:</span>
</span></span><span><span>    <span>if</span> <span>isinstance</span><span>(</span><span>x</span><span>,</span> <span>str</span><span>):</span>
</span></span><span><span>        <span>version</span> <span>=</span> <span>Version</span><span>(</span><span>x</span><span>)</span>
</span></span><span><span>    <span>return</span> <span>str</span><span>(</span><span>_TrimmedRelease</span><span>(</span><span>str</span><span>(</span><span>x</span><span>)))</span>
</span></span></code></pre></div><p>I don’t want to give <code>singledispatch</code> a bad reputation; see <code>uproot-browser</code> for
a good use, where I use it to register different data types that have a known
plotting mechanism. It’s just the wrong tool here, and also not great when
performance is critical.</p>
<p>However, that wasn’t the only problem with this function; it was running the
<code>Version</code> creation (also inside <code>_TrimmedRelease</code>, too!) too many (more than
one) times. Remember making <code>Version</code>s runs a regex!</p>
<h3 id="specifierset-remove-duplicate-version-creation-37-faster">SpecifierSet: remove duplicate Version creation (37% faster)</h3>
<p>Inside <code>canonicalize_version</code>, there was another issue; the same version was
created twice, once with a subclass (<code>_TrimmedRelease</code>) that had a different
behavior when it turned into a string (removing zeros). I <a href="https://github.com/pypa/packaging/pull/994">instead
reworked</a> the classes so you could create the subclass directly, without
going through a string. <code>_TrimmedRelease(version)</code> now avoids the string
intermediate if <code>version</code> is a <code>Version</code>.</p>
<p>Now the function looks something like this:</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>def</span> <span>f</span><span>(</span><span>x</span><span>:</span> <span>Version</span> <span>|</span> <span>str</span><span>)</span> <span>-&gt;</span> <span>str</span><span>:</span>
</span></span><span><span>    <span>if</span> <span>isinstance</span><span>(</span><span>x</span><span>,</span> <span>str</span><span>):</span>
</span></span><span><span>        <span>version</span> <span>=</span> <span>Version</span><span>(</span><span>x</span><span>)</span>
</span></span><span><span>    <span>return</span> <span>str</span><span>(</span><span>_TrimmedRelease</span><span>(</span><span>x</span><span>))</span>
</span></span></code></pre></div><h3 id="removing-namedtuple-20-faster">Removing NamedTuple (20% faster)</h3>
<p><code>Version</code> had an interesting design; it contained a <code>_Version</code> <code>NamedTuple</code> with
all of its fields. Now that we added caching, the outer <code>Version</code> had one more
field, but otherwise, it was redundant. Creating and using <code>NamedTuple</code> is
expensive, accessing via the names has a cost. This might have been done to
ensure the object was not writeable, but that can be done without the
<code>NamedTuple</code> access using properties. <a href="https://github.com/pypa/packaging/pull/995">Removing this</a> gave a (20%)
speedup, as well as accessing values and even turning the version into a string
also gets faster.</p>
<p>I was not able to find anyone using the hidden <code>._version</code> attribute using
GitHub’s code search; if that does break someone, we can always generate the
<code>NamedTuple</code> on demand, but we’ll only do that if we have to. Edit: Turns out
<a href="https://github.com/pypa/hatch">Hatch</a> uses this. We’ve added the on-demand version with a
<code>DeprecationWarning</code>, to be a <code>FutureWarning</code> in a later release.</p>
<h3 id="map-instead-of-generator-8-faster">Map instead of generator (8% faster)</h3>
<p>Another slow line are the ones that look like this:</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>release</span> <span>=</span> <span>tuple</span><span>(</span><span>int</span><span>(</span><span>i</span><span>)</span> <span>for</span> <span>i</span> <span>in</span> <span>match</span><span>.</span><span>group</span><span>(</span><span>&#34;release&#34;</span><span>)</span><span>.</span><span>split</span><span>(</span><span>&#34;.&#34;</span><span>))</span>
</span></span></code></pre></div><p>That generator is rather expensive. You can save a little time by using a list
comprehension instead (<code>tuple([...])</code> instead of <code>tuple(...)</code>) for small tuples,
but <a href="https://github.com/pypa/packaging/pull/996">I found</a> that this:</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span>release</span> <span>=</span> <span>map</span><span>(</span><span>int</span><span>,</span> <span>match</span><span>.</span><span>group</span><span>(</span><span>&#34;release&#34;</span><span>)</span><span>.</span><span>split</span><span>(</span><span>&#34;.&#34;</span><span>))</span>
</span></span></code></pre></div><p>was similar to the list comprehension in speed, and it’s both nicer than adding
the extra brackets, and was used elsewhere in the code, so moving to using them
saved about 8%. Note that <code>tuple([ ... for ... in ... ])</code> is likely only faster
when the thing you are iterating over is small.</p>
<h3 id="using-replacement-to-get-new-versions">Using replacement to get new versions</h3>
<p>A couple PRs Damian started and we both worked on was <a href="https://github.com/pypa/packaging/pull/1003">adding <code>__replace__</code>
support</a>, then <a href="https://github.com/pypa/packaging/pull/999">using it</a> to to replace some
<code>Version -&gt; str -&gt; Version</code> sequences inside <code>SpecifierSet</code>. It would have been
nice if the API of <code>Version</code> returned <code>Version</code> instead of <code>str</code> for some
methods like <code>.public</code>, but that’s a breaking change. If you are using something
like <code>Version(version.public)</code> in a performance critical path, you can use
<code>__replace__</code> (<code>copy.replace</code> on Python 3.14) instead, which will be much faster
than reparsing the <code>Version</code>. This mostly speeds up comparison, which I’m not
usually benchmarking, but is critical for users like pip.</p>
<h3 id="using-slots-2-faster">Using slots (2% faster)</h3>
<p>This isn’t much of an improvement for <a href="https://github.com/pypa/packaging/pull/1001"><code>Version</code></a> or
<a href="https://github.com/pypa/packaging/pull/1002"><code>SpecifierSet</code></a> (maybe more on older Python versions), but using
<code>__slots__</code> is a good idea, can reduce memory, and makes the class stricter as
well, since it disallows setting a unknown property. Key sharing dictionaries in
newer versions reduce the savings, but it’s still nicer.</p>
<h3 id="speedups-inspired-by-codeflash">Speedups inspired by Codeflash</h3>
<p>Kevin Turcios used his tool, codeflash.ai, to look for possible speedups. I
reviewed the ones it found, and implemented a version of three of them: I moved
<a href="https://github.com/pypa/packaging/pull/1012">set construction out of a function</a>, <a href="https://github.com/pypa/packaging/pull/1013">I used <code>.partition</code></a>
instead of split (probably not faster, but nicer), and <a href="https://github.com/pypa/packaging/pull/1014">I used a dict</a>
to handle alternate spellings instead of a series of if’s. The tool reported the
speedup in the test function, but that’s representative of real work; check the
PRs if you’d like to see the values. I came up with different solutions, so the
values are relevant enough to show here.</p>
<p>Here’s an example:</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span># Before</span>
</span></span><span><span><span>parts</span> <span>=</span> <span>[</span><span>p</span><span>.</span><span>strip</span><span>()</span> <span>for</span> <span>p</span> <span>in</span> <span>pair</span><span>.</span><span>split</span><span>(</span><span>&#34;,&#34;</span><span>,</span> <span>1</span><span>)]</span>
</span></span><span><span><span>parts</span><span>.</span><span>extend</span><span>([</span><span>&#34;&#34;</span><span>]</span> <span>*</span> <span>(</span><span>max</span><span>(</span><span>0</span><span>,</span> <span>2</span> <span>-</span> <span>len</span><span>(</span><span>parts</span><span>))))</span>  <span># Ensure 2 items</span>
</span></span><span><span><span>label</span><span>,</span> <span>url</span> <span>=</span> <span>parts</span>
</span></span><span><span>
</span></span><span><span><span># After</span>
</span></span><span><span><span>label</span><span>,</span> <span>_</span><span>,</span> <span>url</span> <span>=</span> <span>(</span><span>s</span><span>.</span><span>strip</span><span>()</span> <span>for</span> <span>s</span> <span>in</span> <span>pair</span><span>.</span><span>partition</span><span>(</span><span>&#34;,&#34;</span><span>))</span>
</span></span></code></pre></div><p>Another one pulled set construction outside a function (making a set is
expensive unless you use it inline; if it’s static, just make it once).</p>
<h3 id="other-speedups">Other speedups</h3>
<p>Damian also implemented a series of speedups related to reducing unnecessary
object creation, such as <a href="https://github.com/pypa/packaging/pull/989">making some computation lazy</a>, <a href="https://github.com/pypa/packaging/pull/985">caching
related versions</a>, <a href="https://github.com/pypa/packaging/pull/986">avoiding redundant Version creation</a>, and
using the <a href="https://github.com/pypa/packaging/pull/1005">cache in more places</a>. These aren’t less important than
mine, it’s just that I’m writing the blog post and I have more to say about
mine. :) Also, since his work focused on making pip’s resolver faster, some of
the speedups are related to comparisons and containment checks, which won’t show
up on my simple profiling.</p>
<p>For his resolver benchmark, pip was originally creating <code>Version</code>s over 4.8
million times, and combined with changes he is also making to pip, it’s now
under 400 thousand.</p>
 
	
	
	    
	
	
        
	

 
	
	
	
        
	

 

<ul role="tablist">
  
  <li role="presentation">
    <a href="#before_after-pip-on-packaging-250" role="tab" data-toggle="tab" aria-controls="before_after-pip-on-packaging-250">pip on packaging 25.0</a>
  </li>
  
  <li role="presentation">
    <a href="#before_after-pip-on-packaging-main" role="tab" data-toggle="tab" aria-controls="before_after-pip-on-packaging-main">pip on packaging main</a>
  </li>
  
</ul>

<div>
  
    <p><img src="https://iscinumpy.dev/post/packaging-faster/pip-main-version-only.png" alt="CProfile on 25.0"/></p>
  
    <p><img src="https://iscinumpy.dev/post/packaging-faster/pip-main-packaging-main-version-only.png" alt="CProfile on main"/></p>
  
</div>

<p>There also was <a href="https://github.com/pypa/packaging/pull/1019">a speedup found</a> by Shantanu Jain, which speeds up
<code>Requirement</code> parsing by 3x by moving regex construction out of the constructor.</p>
<p>After implementing the asv based benchmarks, I also worked on speedups for
<code>Marker</code> and <code>Requirement</code>. I inlined the <code>__str__</code> code for <code>Version</code>, using
f-strings instead of joining lists, which gave a 10% speedup.</p>
<p>One of the more <a href="https://github.com/pypa/packaging/pull/1030">impactful changes</a> was replacing the regular
expression substitution for a string translate, doubling the performance of
<code>canonicalize_name</code>:</p>
<pre tabindex="0"><code>_canonicalize_table = str.maketrans(
    &#34;ABCDEFGHIJKLMNOPQRSTUVWXYZ_.&#34;,
    &#34;abcdefghijklmnopqrstuvwxyz--&#34;,
)
...
value = name.translate(_canonicalize_table)
while &#34;--&#34; in value:
    value = value.replace(&#34;--&#34;, &#34;-&#34;)
</code></pre><p>This works because package names are required to be ASCII; using this just for
the two replacements than calling <code>.lower()</code> is only about 5% slower if you have
unicode, but we don’t. Condensing repeated separators is also quite rare.
(Credit to Hugo van Kemenade for the clean version above, mine was a bit
uglier).</p>
<p><img src="https://iscinumpy.dev/post/packaging-faster/final-version.svg" alt="Final flamegraph of Version"/></p>
<p>The flamegraph now looks <em>much</em> better; the regex (in blue above) dominates, and
parts like splitting strings into <code>.</code> separated integers probably can’t get
faster outside of compilation. There might be a bit more to gain, but we’ve done
pretty well.</p>
<h2 id="final-performance-numbers">Final performance numbers</h2>
<p>Comparing packaging 25.0 and the main branch on Python 3.14, reading every
version on PyPI went from 19.6 seconds to 9.9 seconds, a nearly 2x speedup.
Reading every <code>requires-python</code> and checking if the current version of Python
passes went from 105 seconds to 33.9 seconds, a 3x speedup. I actually do this
all the time when I’m running analysis on build backends to monitor adoption;
those run about two times faster on packaging <code>main</code>.</p>
<p>We have made an RC release, and hope to make a full release in about a week;
some other work on improving our handling of standards around markers could
cause a delay, but it should happen soon. A lot of other things are in the
release as well: support for pattern matching, support for <code>pylock</code> files,
support for import name metadata, support for writing metadata to a file, and
lots of expanded linting and type verification in our codebase.</p>
<p>The last change required a small fix to the standard; packaging has never
followed the marker specification correctly, but the standard was a bit broken,
requiring <em>every</em> value to attempt conversion to a <code>Version</code>, even things that
were not version-like at all. This change gave us a speed up that <a href="https://github.com/astral-sh/uv">uv</a> is
already doing. Waiting on that to get approval is all that’s left for a final
release of the new packaging (as well as waiting a bit for any bugs in the RC to
be reported by you)! Please test the RC and make sure it works for you.</p>
<p>I don’t know about you, but I’m very excited for the fastest release of
packaging yet! Please try <a href="https://github.com/pypa/packaging/releases/tag/26.0rc1"><code>26.0rc3</code></a> and tell us if there are any
regressions!</p>
<p>Edit: after this post, people have been applying some of these speedups to
<a href="https://github.com/pypa/distlib/pull/254">other libraries</a> as well, including <a href="https://github.com/python/cpython/pull/143660">CPython itself</a>!</p>
<hr/>
<p>Thanks to Kevin Turcios, Brett Cannon, and Damian Shaw for reviewing this post
before publication. Thanks to Mike Fielder for suggesting proper benchmarking
with asv, which added work but the result is much cooler and I even found new
speedups. Thanks to ChatGPT for catching some initial typos before publication.
And thanks to Brett Cannon (again), Thanos (from the PyPA discord server), James
Gilbert, and Giordon Stark for catching typos in the published article. I found
I am really bad at writing example code that doesn’t run or get linted! (If you
helped and I missed your name above, please let me know!)</p>
<details><summary>Benchmark scripts (click to expand)</summary>
<div><pre tabindex="0"><code data-lang="python"><span><span><span># benchmark_versions.py</span>
</span></span><span><span><span>import</span> <span>sqlite3</span>
</span></span><span><span><span>import</span> <span>timeit</span>
</span></span><span><span><span>from</span> <span>packaging.version</span> <span>import</span> <span>Version</span><span>,</span> <span>InvalidVersion</span>
</span></span><span><span>
</span></span><span><span><span># Get data with:</span>
</span></span><span><span><span># curl -L https://github.com/pypi-data/pypi-json-data/releases/download/latest/pypi-data.sqlite.gz | gzip -d &gt; pypi-data.sqlite</span>
</span></span><span><span>
</span></span><span><span>
</span></span><span><span><span>def</span> <span>valid_version</span><span>(</span><span>v</span><span>:</span> <span>str</span><span>)</span> <span>-&gt;</span> <span>bool</span><span>:</span>
</span></span><span><span>    <span>try</span><span>:</span>
</span></span><span><span>        <span>Version</span><span>(</span><span>v</span><span>)</span>
</span></span><span><span>    <span>except</span> <span>InvalidVersion</span><span>:</span>
</span></span><span><span>        <span>return</span> <span>False</span>
</span></span><span><span>    <span>return</span> <span>True</span>
</span></span><span><span>
</span></span><span><span>
</span></span><span><span><span>with</span> <span>sqlite3</span><span>.</span><span>connect</span><span>(</span><span>&#34;pypi-data.sqlite&#34;</span><span>)</span> <span>as</span> <span>conn</span><span>:</span>
</span></span><span><span>    <span>TEST_ALL_VERSIONS</span> <span>=</span> <span>[</span>
</span></span><span><span>        <span>row</span><span>[</span><span>0</span><span>]</span>
</span></span><span><span>        <span>for</span> <span>row</span> <span>in</span> <span>conn</span><span>.</span><span>execute</span><span>(</span><span>&#34;SELECT version FROM projects&#34;</span><span>)</span>
</span></span><span><span>        <span>if</span> <span>valid_version</span><span>(</span><span>row</span><span>[</span><span>0</span><span>])</span>
</span></span><span><span>    <span>]</span>
</span></span><span><span>
</span></span><span><span>
</span></span><span><span><span>def</span> <span>bench</span><span>():</span>
</span></span><span><span>    <span>for</span> <span>v</span> <span>in</span> <span>TEST_ALL_VERSIONS</span><span>:</span>
</span></span><span><span>        <span>Version</span><span>(</span><span>v</span><span>)</span>
</span></span><span><span>
</span></span><span><span>
</span></span><span><span><span>if</span> <span>__name__</span> <span>==</span> <span>&#34;__main__&#34;</span><span>:</span>
</span></span><span><span>    <span>print</span><span>(</span><span>f</span><span>&#34;Loaded </span><span>{</span><span>len</span><span>(</span><span>TEST_ALL_VERSIONS</span><span>)</span><span>:</span><span>,</span><span>}</span><span> versions&#34;</span><span>)</span>
</span></span><span><span>    <span>t</span> <span>=</span> <span>timeit</span><span>.</span><span>timeit</span><span>(</span><span>&#34;bench()&#34;</span><span>,</span> <span>globals</span><span>=</span><span>globals</span><span>(),</span> <span>number</span><span>=</span><span>1</span><span>)</span>
</span></span><span><span>    <span>print</span><span>(</span><span>f</span><span>&#34;Time: </span><span>{</span><span>t</span><span>:</span><span>.4f</span><span>}</span><span> seconds&#34;</span><span>)</span>
</span></span></code></pre></div><div><pre tabindex="0"><code data-lang="python"><span><span><span># benchmark_specifiers.py</span>
</span></span><span><span><span>import</span> <span>sqlite3</span>
</span></span><span><span><span>import</span> <span>timeit</span>
</span></span><span><span><span>from</span> <span>packaging.specifiers</span> <span>import</span> <span>SpecifierSet</span><span>,</span> <span>InvalidSpecifier</span>
</span></span><span><span><span>from</span> <span>packaging.version</span> <span>import</span> <span>Version</span>
</span></span><span><span>
</span></span><span><span><span># Get data with:</span>
</span></span><span><span><span># curl -L https://github.com/pypi-data/pypi-json-data/releases/download/latest/pypi-data.sqlite.gz | gzip -d &gt; pypi-data.sqlite</span>
</span></span><span><span>
</span></span><span><span>
</span></span><span><span><span>def</span> <span>valid_spec</span><span>(</span><span>v</span><span>:</span> <span>str</span><span>)</span> <span>-&gt;</span> <span>bool</span><span>:</span>
</span></span><span><span>    <span>try</span><span>:</span>
</span></span><span><span>        <span>SpecifierSet</span><span>(</span><span>v</span><span>)</span>
</span></span><span><span>    <span>except</span> <span>InvalidSpecifier</span><span>:</span>
</span></span><span><span>        <span>return</span> <span>False</span>
</span></span><span><span>    <span>return</span> <span>True</span>
</span></span><span><span>
</span></span><span><span>
</span></span><span><span><span>with</span> <span>sqlite3</span><span>.</span><span>connect</span><span>(</span><span>&#34;pypi-data.sqlite&#34;</span><span>)</span> <span>as</span> <span>conn</span><span>:</span>
</span></span><span><span>    <span>TEST_ALL_SPECS</span> <span>=</span> <span>[</span>
</span></span><span><span>        <span>row</span><span>[</span><span>0</span><span>]</span>
</span></span><span><span>        <span>for</span> <span>row</span> <span>in</span> <span>conn</span><span>.</span><span>execute</span><span>(</span><span>&#34;SELECT requires_python FROM projects&#34;</span><span>)</span>
</span></span><span><span>        <span>if</span> <span>row</span><span>[</span><span>0</span><span>]</span> <span>and</span> <span>valid_spec</span><span>(</span><span>row</span><span>[</span><span>0</span><span>])</span>
</span></span><span><span>    <span>]</span>
</span></span><span><span>
</span></span><span><span>
</span></span><span><span><span>def</span> <span>bench</span><span>():</span>
</span></span><span><span>    <span>ver</span> <span>=</span> <span>Version</span><span>(</span><span>&#34;3.14.2&#34;</span><span>)</span>
</span></span><span><span>    <span>for</span> <span>v</span> <span>in</span> <span>TEST_ALL_SPECS</span><span>:</span>
</span></span><span><span>        <span>SpecifierSet</span><span>(</span><span>v</span><span>)</span><span>.</span><span>contains</span><span>(</span><span>ver</span><span>)</span>
</span></span><span><span>
</span></span><span><span>
</span></span><span><span><span>if</span> <span>__name__</span> <span>==</span> <span>&#34;__main__&#34;</span><span>:</span>
</span></span><span><span>    <span>print</span><span>(</span><span>f</span><span>&#34;Loaded </span><span>{</span><span>len</span><span>(</span><span>TEST_ALL_SPECS</span><span>)</span><span>:</span><span>,</span><span>}</span><span> specs&#34;</span><span>)</span>
</span></span><span><span>    <span>t</span> <span>=</span> <span>timeit</span><span>.</span><span>timeit</span><span>(</span><span>&#34;bench()&#34;</span><span>,</span> <span>globals</span><span>=</span><span>globals</span><span>(),</span> <span>number</span><span>=</span><span>1</span><span>)</span>
</span></span><span><span>    <span>print</span><span>(</span><span>f</span><span>&#34;Time: </span><span>{</span><span>t</span><span>:</span><span>.4f</span><span>}</span><span> seconds&#34;</span><span>)</span>
</span></span></code></pre></div>

</details>

        
          
        

        

        
      </article>

      
        
      


      
      
      
      
      
        
      

    </div>
  </div>
</div></div>
  </body>
</html>
