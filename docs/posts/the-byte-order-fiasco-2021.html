<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://justine.lol/endian.html">Original</a>
    <h1>The Byte Order Fiasco (2021)</h1>
    
    <div id="readability-page-1" class="page"><p>
01 may 2021 @ <a href="https://justine.lol/index.html"> justine&#39;s web page</a>

</p>

<p>
One of the most challenging topics in the C / C++ programming language
is how to handle endianness properly. There&#39;s a surprising amount of
depth here. I&#39;ve been programming in C for a while and I feel like I
keep learning about this subject, even when I thought I&#39;d seen it all.

</p><p>
Let&#39;s say we want to deserialize a 32-bit integer off the wire, using
code that&#39;ll work on machines like IBM&#39;s s390x mainframes (one of the
few big endian chips still in play). Here&#39;s the naive approach:



</p><pre><span>#include</span> <span>&lt;stdio.h&gt;</span>
<span>#include</span> <span>&lt;stdint.h&gt;</span>
<span>#include</span> <span>&lt;byteswap.h&gt;</span>
<span>#if</span> (defined(__BYTE_ORDER__) &amp;&amp; __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__) || \
    defined(__s390x__) || defined(__ppc__) || defined(__PPC__) ||          \
    defined(__powerpc__) || defined(__POWERPC__) ||                        \
    defined(__BIG_ENDIAN__) || defined(__ARMEB__) ||                       \
    defined(__THUMBEB__) || defined(__AARCH64EB__) ||                      \
    defined(_MIPSEB) || defined(__MIPSEB) || defined(__MIPSEB__)
<span>#define</span> READ32BE(p) (*(<span>uint32_t</span> *)(p))
<span>#else</span>
<span>#define</span> READ32BE(p) bswap_32(*(<span>uint32_t</span> *)(p))
<span>#endif</span>
<span>char</span> b[4] = {0x80,0x02,0x03,0x04};
<span>int</span> main(<span>int</span> argc, <span>char</span> *argv[]) { printf(<span>&#34;%08x\n&#34;</span>, READ32BE(b)); }
</pre>

<p>
Aside from being ugly, the code above is wrong. Modern compiler policies
don&#39;t even permit code that looks like like that anymore. Your compiler
might see that and emit assembly
that <a href="https://twitter.com/m13253/status/1371615680068526081">formats
your hard drive with btrfs</a>. That&#39;s the thing about behaviors which
are undefined according to the C standard.

<!-- <p style="text-align:center"> -->
<!-- <img src="undefined.png" width="85%"> -->

</p><p>
The compiler benchmark wars have been very competitive ever since the GNU
vs. Apple/Google schism these past ten years. Clang and GCC are reaching
for any optimization they can get. Undefined Behavior may be hostile and
dangerous, but it&#39;s legal. So don&#39;t let your code become a casualty. In
fact, compilers won&#39;t even warn you if they rewrite your program in
unexpected ways because you&#39;re not conforming to the C standard. Someone
will probably build an X-Ray one of these days and there&#39;ll be
a <a href="https://youtu.be/IJNR2EpS0jw">Dumb Ways to Die</a> video that
causes things to change. But until that day, we have an excellent tool
for avoiding these problems and it&#39;s called UBSAN.

</p><pre>$ cc -g -Os -Wall \
     -fsanitize=undefined \
     -pedantic -fstrict-aliasing -Wstrict-aliasing=3 \
     -o /tmp/o endian.c
$ /tmp/o
endian.c:30:3: runtime error: load of misaligned address 0x5575a79fc05f for type &#39;uint32_t&#39;,
               which requires 4 byte alignment
0x5575a79fc05f: note: pointer points here
 5f 74 27 00 80  02 03 04 00
             ^
80020304
</pre>

<p>
So how do we deserialize an int properly? Rob Pike has a
good <a href="https://commandcenter.blogspot.com/2012/04/byte-order-fallacy.html">blog
post</a> talking about how easy it is. The solution he recommends is as
follows:

</p><pre><span>char</span> b[4] = {0x80,0x02,0x03,0x04};
<span>#define</span> READ32BE(p) p[3] | p[2]&lt;&lt;8 | p[1]&lt;&lt;16 | p[0]&lt;&lt;24
<span>int</span> main(<span>int</span> argc, <span>char</span> *argv[]) { printf(<span>&#34;%08x\n&#34;</span>, READ32BE(b)); }
</pre>

<p>
Huge improvement! It still has undefined behaviors.
Assuming <code>-fsigned-char</code> is the default behavior, we get:

</p><pre>$ cc -fsanitize=undefined -g -Os -o /tmp/o endian.c &amp;&amp; /tmp/o
endian.c:19:53: runtime error: left shift of negative value -128
80020304
</pre>

<p>
Let&#39;s assume we change the data so the undefined behavior goes
away. <code>0x80</code> is the same in this context as <code>-128</code>
a.k.a. <code>CHAR_MIN</code>.

</p><pre><span>char</span> b[4] = {0x02,0x03,0x04,0x80};
<span>#define</span> READ32BE(p) p[3] | p[2]&lt;&lt;8 | p[1]&lt;&lt;16 | p[0]&lt;&lt;24
<span>int</span> main(<span>int</span> argc, <span>char</span> *argv[]) { printf(<span>&#34;%08x\n&#34;</span>, READ32BE(b)); }
</pre>

<p>
If we do this then something even worse happens. Rather than crashing or
a runtime warning we get an incorrect result, because of sign extension.

</p><pre>$ cc -fsanitize=undefined -g -Os -o /tmp/o endian.c &amp;&amp; /tmp/o
ffffff80
</pre>

<p>
So the solution is simple right? Let&#39;s just use <code>unsigned
char</code> instead. Sadly no. Because <code>unsigned char</code> in C
expressions gets type promoted to the signed type <code>int</code>. So
if we say <code>0x80&lt;&lt;24</code> it overwrites the sign bit, which is an
undefined behavior according to the C standard.

</p><pre>$ cc -fsanitize=undefined -g -Os -o /tmp/o endian.c &amp;&amp; /tmp/o
endian.c:19:53: runtime error: left shift of 128 by 24 places cannot be represented in type &#39;int&#39;
80020304
</pre>

<p>
That part of the C standard is the legacy of companies like UNIVAC, who
didn&#39;t agree with John von Neumman&#39;s design doc from the second world war
for EDVAC, which very clearly laid out that the plan was to have 32-bit
little endian two&#39;s complement integers. Imagine that. Even Seymour Cray
himself admitted that when he chose ones&#39; complement it was because he
hadn&#39;t yet understood the full meaning of John von Neumman&#39;s design at
the time.

</p><p>
So here&#39;s the secret to writing good generic C code:



</p><p><em>
  Mask, and then shift.</em>

</p><p>
Repeat it like a mantra. You mask first, to define away potential
concerns about signedness. Then you cast if needed. And finally, you can
shift. Now we can create the fool-proof version for machines with at
least 32-bit ints:

</p><pre><span>#define</span> READ32BE(p) \
  (<span>uint32_t</span>)(255 &amp; p[0]) &lt;&lt; 24 | (255 &amp; p[1]) &lt;&lt; 16 | (255 &amp; p[2]) &lt;&lt; 8 | (255 &amp; p[3])
</pre>

<p>
Another cool trick is we can make the code look more elegant using octal
notation:

</p><pre><span>#define</span> READ16LE(S) ((255 &amp; (S)[1]) &lt;&lt; 8 | (255 &amp; (S)[0]))
<span>#define</span> READ16BE(S) ((255 &amp; (S)[0]) &lt;&lt; 8 | (255 &amp; (S)[1]))
<span>#define</span> READ32LE(S)                                                    \
  ((<span>uint32_t</span>)(255 &amp; (S)[3]) &lt;&lt; 030 | (<span>uint32_t</span>)(255 &amp; (S)[2]) &lt;&lt; 020 | \
   (<span>uint32_t</span>)(255 &amp; (S)[1]) &lt;&lt; 010 | (<span>uint32_t</span>)(255 &amp; (S)[0]) &lt;&lt; 000)
<span>#define</span> READ32BE(S)                                                    \
  ((<span>uint32_t</span>)(255 &amp; (S)[0]) &lt;&lt; 030 | (<span>uint32_t</span>)(255 &amp; (S)[1]) &lt;&lt; 020 | \
   (<span>uint32_t</span>)(255 &amp; (S)[2]) &lt;&lt; 010 | (<span>uint32_t</span>)(255 &amp; (S)[3]) &lt;&lt; 000)
<span>#define</span> READ64LE(S)                                                    \
  ((<span>uint64_t</span>)(255 &amp; (S)[7]) &lt;&lt; 070 | (<span>uint64_t</span>)(255 &amp; (S)[6]) &lt;&lt; 060 | \
   (<span>uint64_t</span>)(255 &amp; (S)[5]) &lt;&lt; 050 | (<span>uint64_t</span>)(255 &amp; (S)[4]) &lt;&lt; 040 | \
   (<span>uint64_t</span>)(255 &amp; (S)[3]) &lt;&lt; 030 | (<span>uint64_t</span>)(255 &amp; (S)[2]) &lt;&lt; 020 | \
   (<span>uint64_t</span>)(255 &amp; (S)[1]) &lt;&lt; 010 | (<span>uint64_t</span>)(255 &amp; (S)[0]) &lt;&lt; 000)
<span>#define</span> READ64BE(S)                                                    \
  ((<span>uint64_t</span>)(255 &amp; (S)[0]) &lt;&lt; 070 | (<span>uint64_t</span>)(255 &amp; (S)[1]) &lt;&lt; 060 | \
   (<span>uint64_t</span>)(255 &amp; (S)[2]) &lt;&lt; 050 | (<span>uint64_t</span>)(255 &amp; (S)[3]) &lt;&lt; 040 | \
   (<span>uint64_t</span>)(255 &amp; (S)[4]) &lt;&lt; 030 | (<span>uint64_t</span>)(255 &amp; (S)[5]) &lt;&lt; 020 | \
   (<span>uint64_t</span>)(255 &amp; (S)[6]) &lt;&lt; 010 | (<span>uint64_t</span>)(255 &amp; (S)[7]) &lt;&lt; 000)
</pre>

<p>
Now you might be looking at the code above and be thinking, surely
that&#39;s the slowest thing imaginable. Here&#39;s a jewel from the TensorFlow
codebase expressing that sentiment:

</p><pre><span>// Fall back on a non-optimized implementation on other big-endian targets.</span>
<span>// This code swaps one byte at a time and is probably an order of magnitude</span>
<span>// slower.</span>
<span>#define</span> BYTE_SWAP_64(x)                                                      \
  ((((x)&amp;0x00000000000000ffUL) &lt;&lt; 56) | (((x)&amp;0x000000000000ff00UL) &lt;&lt; 40) | \
   (((x)&amp;0x0000000000ff0000UL) &lt;&lt; 24) | (((x)&amp;0x00000000ff000000UL) &lt;&lt;  8) | \
   (((x)&amp;0x000000ff00000000UL) &gt;&gt;  8) | (((x)&amp;0x0000ff0000000000UL) &gt;&gt; 24) | \
   (((x)&amp;0x00ff000000000000UL) &gt;&gt; 40) | (((x)&amp;0xff00000000000000UL) &gt;&gt; 56))
</pre>

<p>
That might have been true with old compilers, but it&#39;s not true today.
The more verbosely well-defined your code is, then with a good modern
compiler, the smaller the generated code will be. Here&#39;s what we get if
we run it through
<a href="https://clang.godbolt.org">clang.godbolt.org</a>:

</p><pre><span>read32le(char*)</span>:
	<span>mov</span>	(<span>%rdi</span>),<span>%eax</span>
	<span>ret</span>
<span>byte_swap_64(unsigned long)</span>:
	<span>mov</span>	<span>%rdi</span>,<span>%rax</span>
	<span>bswap</span>	<span>%rax</span>
	<span>ret</span>
<span>read32be(char*)</span>:
	<span>mov</span>	(<span>%rdi</span>),<span>%eax</span>
	<span>bswap</span>	<span>%eax</span>
	<span>ret</span>
</pre>

<p>
So we can finally delete the ifdef soup, and I&#39;d call that progress.

</p><p>
What if we want to serialize integers to the wire? Using our new
knowledge, that becomes easy too. Here&#39;s how it can be done with a
mempcpy-style API:

</p><pre><span>#define</span> WRITE16LE(P, V)                        \
  ((P)[0] = (0x00000000000000FF &amp; (V)) &gt;&gt; 000, \
   (P)[1] = (0x000000000000FF00 &amp; (V)) &gt;&gt; 010, (P) + 2)
<span>#define</span> WRITE16BE(P, V)                        \
  ((P)[0] = (0x000000000000FF00 &amp; (V)) &gt;&gt; 010, \
   (P)[1] = (0x00000000000000FF &amp; (V)) &gt;&gt; 000, (P) + 2)
<span>#define</span> WRITE32LE(P, V)                        \
  ((P)[0] = (0x00000000000000FF &amp; (V)) &gt;&gt; 000, \
   (P)[1] = (0x000000000000FF00 &amp; (V)) &gt;&gt; 010, \
   (P)[2] = (0x0000000000FF0000 &amp; (V)) &gt;&gt; 020, \
   (P)[3] = (0x00000000FF000000 &amp; (V)) &gt;&gt; 030, (P) + 4)
<span>#define</span> WRITE32BE(P, V)                        \
  ((P)[0] = (0x00000000FF000000 &amp; (V)) &gt;&gt; 030, \
   (P)[1] = (0x0000000000FF0000 &amp; (V)) &gt;&gt; 020, \
   (P)[2] = (0x000000000000FF00 &amp; (V)) &gt;&gt; 010, \
   (P)[3] = (0x00000000000000FF &amp; (V)) &gt;&gt; 000, (P) + 4)
<span>#define</span> WRITE64LE(P, V)                        \
  ((P)[0] = (0x00000000000000FF &amp; (V)) &gt;&gt; 000, \
   (P)[1] = (0x000000000000FF00 &amp; (V)) &gt;&gt; 010, \
   (P)[2] = (0x0000000000FF0000 &amp; (V)) &gt;&gt; 020, \
   (P)[3] = (0x00000000FF000000 &amp; (V)) &gt;&gt; 030, \
   (P)[4] = (0x000000FF00000000 &amp; (V)) &gt;&gt; 040, \
   (P)[5] = (0x0000FF0000000000 &amp; (V)) &gt;&gt; 050, \
   (P)[6] = (0x00FF000000000000 &amp; (V)) &gt;&gt; 060, \
   (P)[7] = (0xFF00000000000000 &amp; (V)) &gt;&gt; 070, (P) + 8)
<span>#define</span> WRITE64BE(P, V)                        \
  ((P)[0] = (0xFF00000000000000 &amp; (V)) &gt;&gt; 070, \
   (P)[1] = (0x00FF000000000000 &amp; (V)) &gt;&gt; 060, \
   (P)[2] = (0x0000FF0000000000 &amp; (V)) &gt;&gt; 050, \
   (P)[3] = (0x000000FF00000000 &amp; (V)) &gt;&gt; 040, \
   (P)[4] = (0x00000000FF000000 &amp; (V)) &gt;&gt; 030, \
   (P)[5] = (0x0000000000FF0000 &amp; (V)) &gt;&gt; 020, \
   (P)[6] = (0x000000000000FF00 &amp; (V)) &gt;&gt; 010, \
   (P)[7] = (0x00000000000000FF &amp; (V)) &gt;&gt; 000, (P) + 8)
</pre>

<p>
If you program in C long enough, stuff like this becomes second nature,
and it starts to almost feel inappropriate to even have macros like the
above, since it might be more appropriately inlined into the specific
code. Since there have simply been too many APIs introduced over the
years for solving this problem. To name a few for 32-bit byte swapping
alone: bswap_32, htobe32, htole32, be32toh, le32toh, ntohl, and htonl
which all have pretty much the same meaning.

</p><p>
Now you don&#39;t need to use those APIs because you know the secret. This
blog post covers most of the dark corners of C so if you&#39;ve understood
what you&#39;ve read so far, you&#39;re already practically a master at the
language, which is otherwise remarkably simple and beautiful.

</p><p>
  <strong>see also</strong><br/>

</p><p>
  <a href="https://commandcenter.blogspot.com/2012/04/byte-order-fallacy.html">The byte order fallacy</a>

</p>
<img src="https://ipv4.games/claim?name=jart"/>
</div>
  </body>
</html>
