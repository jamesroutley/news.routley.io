<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://x.st/turing-machine-halting-in-lean/">Original</a>
    <h1>Turing Machine Halting in Lean</h1>
    
    <div id="readability-page-1" class="page"><div>
<article>

<time datetime="2022-01-31T11:12:12-05:00">31 Jan 2022</time>
<p>I recently fooled around with the theorem-proving language <a href="https://leanprover-community.github.io/">Lean</a>, and proved whether some very simple Turing machines halt or not. These are my notes on how I did that.</p>
<p>The code is also <a href="https://github.com/hrldcpr/lean-halting">on github</a> and can be run in the <a href="https://leanprover-community.github.io/lean-web-editor/#url=https%3A%2F%2Fraw.githubusercontent.com%2Fhrldcpr%2Flean-halting%2Fmain%2Fsrc%2Fhalting.lean">web-based Lean editor</a>.</p>
<h2 id="basic-definitions">Basic definitions</h2>
<p>There’s some existing Turing machinery in the Lean community’s amazing library mathlib, so first we import that:</p>
<div><div><pre><code><span>import</span> <span>computability</span><span>.</span><span>turing_machine</span>
</code></pre></div></div>
<p>Then we define our set of machine states Λ and set of tape symbols Γ<sup id="fnref:symbols"><a href="#fn:symbols">1</a></sup> and mark both types as <code>inhabited</code> by specifying their default elements, because the imported code uses such types:</p>
<div><div><pre><code><span>inductive</span> <span>Λ</span><span> -- states</span>
<span>|</span> <span>A</span>
<span>|</span> <span>B</span>
<span>|</span> <span>C</span>

<span>inductive</span> <span>Γ</span><span> -- symbols</span>
<span>|</span> <span>zero</span>
<span>|</span> <span>one</span>

<span>instance</span> <span>Λ</span><span>.</span><span>inhabited</span> : <span>inhabited</span> <span>Λ</span> := <span>⟨</span><span>Λ</span><span>.</span><span>A</span><span>⟩</span>
<span>instance</span> <span>Γ</span><span>.</span><span>inhabited</span> : <span>inhabited</span> <span>Γ</span> := <span>⟨</span><span>Γ</span><span>.</span><span>zero</span><span>⟩</span>
</code></pre></div></div>
<p>And for convenience we define an initial machine configuration, of the initial state (A) and an empty tape:</p>
<div><div><pre><code><span>def</span> <span>cfg</span><span>₀</span> : <span>turing</span><span>.</span><span>TM0</span><span>.</span><span>cfg</span> <span>Γ</span> <span>Λ</span> := <span>turing</span><span>.</span><span>TM0</span><span>.</span><span>init</span> []
</code></pre></div></div>
<p>We want to be able to repeatedly run a Turing machine one step at a time, but the existing <code>turing.TM0.step</code> function is inconvenient for this, because it takes a configuration <code>turing.TM0.cfg Γ Λ</code> as input but outputs a different type <code>option (turing.TM0.cfg Γ Λ)</code>. So we use <code>option.bind</code> to define a more convenient function whose input and output are the same type:</p>
<div><div><pre><code><span>def</span> <span>step</span><span>&#39;</span>
  (<span>M</span> : <span>turing</span><span>.</span><span>TM0</span><span>.</span><span>machine</span> <span>Γ</span> <span>Λ</span>)
  (<span>x</span> : <span>option</span> (<span>turing</span><span>.</span><span>TM0</span><span>.</span><span>cfg</span> <span>Γ</span> <span>Λ</span>)) :
  <span>option</span> (<span>turing</span><span>.</span><span>TM0</span><span>.</span><span>cfg</span> <span>Γ</span> <span>Λ</span>) :=
<span>x</span><span>.</span><span>bind</span> (<span>turing</span><span>.</span><span>TM0</span><span>.</span><span>step</span> <span>M</span>)
</code></pre></div></div>
<p>Now we can easily use Lean’s <code>f^[n]</code> iteration shorthand to define a function which steps a given number of times:</p>
<div><div><pre><code><span>def</span> <span>multistep</span>
  (<span>M</span> : <span>turing</span><span>.</span><span>TM0</span><span>.</span><span>machine</span> <span>Γ</span> <span>Λ</span>)
  (<span>n</span> : <span>ℕ</span>)
  (<span>cfg</span> : <span>turing</span><span>.</span><span>TM0</span><span>.</span><span>cfg</span> <span>Γ</span> <span>Λ</span>) :
  <span>option</span> (<span>turing</span><span>.</span><span>TM0</span><span>.</span><span>cfg</span> <span>Γ</span> <span>Λ</span>) :=
<span>step</span><span>&#39;</span> <span>M</span><span>^</span>[<span>n</span>] (<span>some</span> <span>cfg</span>)
</code></pre></div></div>
<h2 id="some-little-proofs">Some little proofs</h2>
<p>Now for fun we can prove some theorems about <code>multistep</code>.</p>
<p>If <code>multistep M n cfg = none</code> then <code>multistep M (n + m) cfg = none</code> for any m, i.e. once the machine has halted it stays halted. We prove this by induction on m:</p>
<div><div><pre><code><span>theorem</span> <span>multistep_none_add</span>
  <span>{</span><span>cfg</span> <span>M</span> <span>n</span> <span>m</span><span>}</span>
  (<span>hn</span> : <span>multistep</span> <span>M</span> <span>n</span> <span>cfg</span> <span>=</span> <span>none</span>) :
  <span>multistep</span> <span>M</span> (<span>n</span> <span>+</span> <span>m</span>) <span>cfg</span> <span>=</span> <span>none</span> :=
<span>begin</span>
  <span>induction</span> <span>m</span> <span>with</span> <span>m</span> <span>hm</span>,
  <span>{</span> <span>exact</span> <span>hn</span>, <span>}</span>,
  <span>{</span> <span>rw</span> [<span>multistep</span>, <span>nat</span><span>.</span><span>add_succ</span>, <span>function</span><span>.</span><span>iterate_succ_apply</span><span>&#39;</span>,
        <span>←</span> <span>multistep</span>, <span>hm</span>],
    <span>refl</span>, <span>}</span>,
<span>end</span>
</code></pre></div></div>
<p>And we can prove the same thing but for m≥n instead of m+n:</p>
<div><div><pre><code><span>theorem</span> <span>multistep_none_ge</span>
  <span>{</span><span>cfg</span> <span>M</span> <span>n</span><span>}</span>
  <span>{</span><span>m</span> <span>≥</span> <span>n</span><span>}</span>
  (<span>hn</span> : <span>multistep</span> <span>M</span> <span>n</span> <span>cfg</span> <span>=</span> <span>none</span>) :
  <span>multistep</span> <span>M</span> <span>m</span> <span>cfg</span> <span>=</span> <span>none</span> :=
<span>begin</span>
  <span>rw</span> <span>←</span> <span>nat</span><span>.</span><span>add_sub_of_le</span> <span>H</span>,
  <span>exact</span> <span>multistep_none_add</span> <span>hn</span>,
<span>end</span>
</code></pre></div></div>
<p><small><em>(Reading these proofs non-interactively isn’t very illuminating—you can try clicking through them <a href="https://leanprover-community.github.io/lean-web-editor/#url=https%3A%2F%2Fraw.githubusercontent.com%2Fhrldcpr%2Flean-halting%2Fmain%2Fsrc%2Fhalting.lean">in the Lean web editor</a>, though it might not make much sense if you haven’t used a proof assistant before.)</em></small></p>
<h2 id="defining-halting">Defining halting</h2>
<p>With <code>multistep</code> defined, we can easily define halting. A machine M halts if there is some n such that it halts after n steps:</p>
<div><div><pre><code><span>def</span> <span>halts</span> (<span>M</span> : <span>turing</span><span>.</span><span>TM0</span><span>.</span><span>machine</span> <span>Γ</span> <span>Λ</span>) : <span>Prop</span> :=
<span>∃</span> <span>n</span>, <span>multistep</span> <span>M</span> <span>n</span> <span>cfg</span><span>₀</span> <span>=</span> <span>none</span>
</code></pre></div></div>
<p>Now we can try using this definition of halting, for a few specific simple Turing machines.</p>

<p>First we’ll define the simplest possible machine, which just halts (i.e. returns <code>none</code>) no matter what its current state and tape symbol are:</p>
<div><div><pre><code><span>def</span> <span>M</span><span>₁</span> : <span>turing</span><span>.</span><span>TM0</span><span>.</span><span>machine</span> <span>Γ</span> <span>Λ</span>
<span>|</span> <span>_</span> <span>_</span> := <span>none</span>
</code></pre></div></div>
<p>To prove this halts, we basically just run it for one step and see that it has halted.</p>
<p>Specifically, we use Lean’s ⟨⟩ implicit constructor syntax to construct a proof of <code>∃ n, multistep M₁ n cfg₀ = none</code> (aka <code>halts M₁</code>), by specifying n=1 and using <code>rfl</code> to prove the trivial <code>multistep M₁ 1 cfg₀ = none</code>:</p>
<div><div><pre><code><span>theorem</span> <span>M</span><span>₁</span><span>_halts</span> : <span>halts</span> <span>M</span><span>₁</span> :=
<span>⟨</span><span>1</span>, <span>rfl</span><span>⟩</span>
</code></pre></div></div>
<h2 id="a-machine-that-goes-a--b--halt">A machine that goes A → B → halt</h2>
<p>In state A, this machine goes to state B, and writes the current symbol back to the tape (i.e. basically ignores the tape). And for any other state (including B) it halts:</p>
<div><div><pre><code><span>def</span> <span>M</span><span>₂</span> : <span>turing</span><span>.</span><span>TM0</span><span>.</span><span>machine</span> <span>Γ</span> <span>Λ</span>
<span>|</span> <span>Λ</span><span>.</span><span>A</span> <span>symbol</span> := <span>some</span> <span>⟨</span><span>Λ</span><span>.</span><span>B</span>, <span>turing</span><span>.</span><span>TM0</span><span>.</span><span>stmt</span><span>.</span><span>write</span> <span>symbol</span><span>⟩</span>
<span>|</span> <span>_</span> <span>_</span> := <span>none</span>
</code></pre></div></div>
<p>So again we can easily prove that it halts, by simply running it for two steps:</p>
<div><div><pre><code><span>theorem</span> <span>M</span><span>₂</span><span>_halts</span> : <span>halts</span> <span>M</span><span>₂</span> :=
<span>⟨</span><span>2</span>, <span>rfl</span><span>⟩</span>
</code></pre></div></div>
<h2 id="a-machine-that-loops-a--b--a--b--">A machine that loops A → B → A → B → ⋯</h2>
<p>Proving that a machine halts isn’t very interesting since you just run it until it halts. Proving that a machine <em>doesn’t</em> halt is trickier and potentially more useful (e.g. for helping to determine the values of the <a href="https://en.wikipedia.org/wiki/Busy_beaver">Busy Beaver function</a>).</p>
<p>This machine loops forever between A and B, while leaving the tape unchanged:</p>
<div><div><pre><code><span>def</span> <span>M</span><span>₃</span> : <span>turing</span><span>.</span><span>TM0</span><span>.</span><span>machine</span> <span>Γ</span> <span>Λ</span>
<span>|</span> <span>Λ</span><span>.</span><span>A</span> <span>symbol</span> := <span>some</span> <span>⟨</span><span>Λ</span><span>.</span><span>B</span>, <span>turing</span><span>.</span><span>TM0</span><span>.</span><span>stmt</span><span>.</span><span>write</span> <span>symbol</span><span>⟩</span>
<span>|</span> <span>Λ</span><span>.</span><span>B</span> <span>symbol</span> := <span>some</span> <span>⟨</span><span>Λ</span><span>.</span><span>A</span>, <span>turing</span><span>.</span><span>TM0</span><span>.</span><span>stmt</span><span>.</span><span>write</span> <span>symbol</span><span>⟩</span>
<span>|</span> <span>_</span> <span>_</span> := <span>none</span>
</code></pre></div></div>
<p><small><em>(We have to specify the final <code>_ _ := none</code> because Λ.C is a possible state as far as the type system is concerned.)</em></small></p>
<p>Proving that this machine doesn’t halt is more work than the previous trivial halting proofs. First we prove that for any number of steps, the machine always ends up in either state A or state B:</p>
<div><div><pre><code><span>lemma</span> <span>M</span><span>₃</span><span>_AB_only</span> <span>{</span><span>n</span><span>}</span> : <span>∃</span> <span>tape</span>,
  <span>multistep</span> <span>M</span><span>₃</span> <span>n</span> <span>cfg</span><span>₀</span> <span>=</span> <span>some</span> <span>⟨</span><span>Λ</span><span>.</span><span>A</span>, <span>tape</span><span>⟩</span>
  <span>∨</span> <span>multistep</span> <span>M</span><span>₃</span> <span>n</span> <span>cfg</span><span>₀</span> <span>=</span> <span>some</span> <span>⟨</span><span>Λ</span><span>.</span><span>B</span>, <span>tape</span><span>⟩</span> :=
<span>begin</span>
  <span>induction</span> <span>n</span> <span>with</span> <span>n</span> <span>hn</span>,
  <span>{</span> <span>existsi</span> <span>_</span>,
    <span>left</span>,
    <span>refl</span>, <span>}</span>,
  <span>{</span> <span>cases</span> <span>hn</span> <span>with</span> <span>tape_n</span> <span>hn</span>,
    <span>cases</span> <span>hn</span><span>;</span> <span>existsi</span> <span>_</span>,
    <span>{</span>
      <span>right</span>,
      <span>rw</span> [<span>multistep</span>, <span>function</span><span>.</span><span>iterate_succ_apply</span><span>&#39;</span>, <span>←</span> <span>multistep</span>,
          <span>hn</span>, <span>step</span><span>&#39;</span>, <span>option</span><span>.</span><span>bind</span>, <span>turing</span><span>.</span><span>TM0</span><span>.</span><span>step</span>],
      <span>simp</span>,
      <span>existsi</span> <span>_</span>,
      <span>existsi</span> <span>_</span>,
      <span>split</span><span>;</span> <span>refl</span>, <span>}</span>,
    <span>{</span>
      <span>left</span>,
      <span>rw</span> [<span>multistep</span>, <span>function</span><span>.</span><span>iterate_succ_apply</span><span>&#39;</span>, <span>←</span> <span>multistep</span>,
          <span>hn</span>, <span>step</span><span>&#39;</span>, <span>option</span><span>.</span><span>bind</span>, <span>turing</span><span>.</span><span>TM0</span><span>.</span><span>step</span>],
      <span>simp</span>,
      <span>existsi</span> <span>_</span>,
      <span>existsi</span> <span>_</span>,
      <span>split</span><span>;</span> <span>refl</span>, <span>}</span>,
  <span>}</span>,
<span>end</span>
</code></pre></div></div>
<p><small><em>(Again, reading these proofs non-interactively is probably pointless, try <a href="https://leanprover-community.github.io/lean-web-editor/#url=https%3A%2F%2Fraw.githubusercontent.com%2Fhrldcpr%2Flean-halting%2Fmain%2Fsrc%2Fhalting.lean">the Lean web editor</a>.)</em></small></p>
<p>Now that we know that the machine is always in state A or state B, it’s easy to prove that it doesn’t halt, by showing that <code>some A</code> and <code>some B</code> aren’t <code>none</code> (which comes from a theorem called <code>option.no_confusion</code>):</p>
<div><div><pre><code><span>theorem</span> <span>M</span><span>₃</span><span>_not_halts</span> : <span>¬</span> <span>halts</span> <span>M</span><span>₃</span> :=
<span>begin</span>
  <span>intro</span> <span>h</span>,
  <span>cases</span> <span>h</span> <span>with</span> <span>n</span> <span>hn</span>,
  <span>cases</span> <span>M</span><span>₃</span><span>_AB_only</span> <span>with</span> <span>tape</span> <span>h_tape</span>,
  <span>cases</span> <span>h_tape</span><span>;</span> <span>{</span>
    <span>rw</span> <span>h_tape</span> <span>at</span> <span>hn</span>,
    <span>exact</span> <span>option</span><span>.</span><span>no_confusion</span> <span>hn</span>,
  <span>}</span>,
<span>end</span>
</code></pre></div></div>
<p>So there we have it, a Turing machine which clearly loops forever …doesn’t halt!</p>
<p>This is pretty obvious, but maybe someday proofs like these could be automatically derived for more complicated machines. But mostly it was a fun way for me to try Lean!</p>

</article>
</div></div>
  </body>
</html>
