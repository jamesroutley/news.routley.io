<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.evanjones.ca/jvm-mmap-pause.html">Original</a>
    <h1>JVM statistics cause garbage collection pauses (2015)</h1>
    
    <div id="readability-page-1" class="page"><div>

<h3>[ 2015-March-24 16:56 ]</h3>
<p><strong>TL;DR:</strong> The JVM by default exports statistics by <code>mmap</code>-ing a file in <code>/tmp</code> (hsperfdata). On Linux, modifying a memory mapped file can block until disk I/O completes, which can be hundreds of milliseconds. Since the JVM modifies these statistics during garbage collection and safepoints, this causes pauses that are hundreds of milliseconds long. To reduce worst-case pause latencies, add the <code>-XX:+PerfDisableSharedMem</code> JVM flag to disable this feature. This will break tools that read this file, like <code>jstat</code>. <strong>Update</strong>: <a href="https://www.evanjones.ca/jvm-mmap-pause-finding.html">how I found this problem</a></p>

<p><strong>Long version:</strong> There are few things I find more satisfying that solving a challenging bug, and this is the hardest bug I can remember. I&#39;ve spent <em>four months</em> figuring this one out. The root cause is that on rare occasions, writing to memory that is a memory mapped file on Linux will block, waiting for disk writes to complete. This is surprising, since in the code it doesn&#39;t look like modifying some variable is related to disk I/O. I wrote a <a href="https://github.com/evanj/mmap-pause/blob/master/mmapwritepause.c">test program</a> to demonstrate this behaviour, and I was able to cause pauses on multiple file systems: ext2, ext3, ext4, btrfs (extremely common), and xfs (less common). The pauses occur even if the I/O is to a separate disk, or if you call <code>mlock</code>. The only workaround I&#39;ve found is to place the mmap-ed file in tmpfs (a RAM disk), or disable it completely.</p>

<p>I don&#39;t know exactly why the Linux kernel does this, but the pauses do not seem to occur for reads, so the Linux kernel is marking these pages read-only. A friend suggested this is the kernel&#39;s way of reducing the write I/O rate under overloaded conditions. If you know exactly why the kernel is doing this, I would love to hear it.</p>

<p>Since I&#39;ve discovered this, a number of services at Twitter are experimenting with adding the <code>-XX:+PerfDisableSharedMem</code> JVM flag and seeing a significant reduction in worst-case JVM pause latency. I highly recommend testing this out if you run a latency sensitive service.</p>

<h2>Symptoms</h2>

<p>I first noticed some JVM garbage collection pauses that were taking more real time than user plus system time. Here is an example garbage collection log entry:</p>

<pre>2014-12-10T12:38:44.419+0000: 58758.830: [GC (Allocation Failure)[ParNew: 11868438K-&gt;103534K(13212096K), 0.7651580 secs]
  12506389K-&gt;741669K(17406400K), 0.7652510 secs] [Times: user=0.36 sys=0.01, real=0.77 secs]
</pre>

<p>The last section of this line shows that this garbage collection took 770 milliseconds of real time (<code>real=0.77</code>). However, the garbage collection threads only consumed 370 milliseconds of CPU time (<code>user=0.36 sys=0.01</code>). The JVM uses multiple threads for GC, so normally the user plus system time is multiple times higher than the real time. This suggests the kernel has blocked the GC threads for some reason.</p>

<p>The cause is that the JVM creates an &#34;hsperfdata&#34; file in /tmp, with the name hsperfdata_(username), which is a memory mapped file that records statistics about safepoints and garbage collections. When the JVM threads are reaching a safepoint, they increment some counters in this memory. Occasionally the Linux kernel blocks those threads until it finishes some amount of disk I/O.</p>


<h2>Reproducing the pauses</h2>

<p>You just need to cause a lot of writes to a single disk while measuring the time to write to an mmaped file:</p>

<ol>
<li>Start a machine with at least 4 CPUs to make sure there is plenty of CPU time available (I tested this on AWS and Google Cloud VMs with at least 8 CPUs and 7 GB of RAM). Use the latest Linux kernel and distribution you want. I used Ubuntu 14.10 with kernel 3.16.0-31-generic.</li>
<li>Copy the files from <a href="https://github.com/evanj/mmap-pause">my reproduction Github repository</a>; See the README there for additional instructions.</li>
<li>Compile and run <a href="https://github.com/evanj/mmap-pause/blob/master/mmapwritepause.c">mmapwritepause</a> or MakeGarbage (with verbose safepoint times).</li>
<li>While running, cause a lot of writes with <a href="https://github.com/evanj/mmap-pause/blob/master/diskload.sh">diskload.sh</a>.</li>
</ol>


<h2>Related Issues</h2>

<ul>
<li><a href="http://yoshinorimatsunobu.blogspot.com/2014/03/why-buffered-writes-are-sometimes.html">Buffered writes can stall</a></li>
<li><a href="http://events.linuxfoundation.org/sites/events/files/lcjp13_moriya.pdf">Causes of random access memory pauses</a></li>
<li><a href="http://www.slideshare.net/cuonghuutran/gc-andpagescanattacksbylinux">Garbage collection page scan attacks</a></li>
<li><a href="http://engineering.linkedin.com/performance/optimizing-linux-memory-management-low-latency-high-throughput-databases">Optimizing Linux Memory Management (zone reclaim)</a></li>
</ul>

</div></div>
  </body>
</html>
