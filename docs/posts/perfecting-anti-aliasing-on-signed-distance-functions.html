<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.pkh.me/p/44-perfecting-anti-aliasing-on-signed-distance-functions.html">Original</a>
    <h1>Perfecting anti-aliasing on signed distance functions</h1>
    
    <div id="readability-page-1" class="page"><article><p>Doing anti-aliasing on <a href="https://en.wikipedia.org/wiki/Signed_distance_function">SDF</a> is not as straightforward as it seems. Most of the
time, we see people use a <code>smoothstep</code> with hardcoded constants, sometimes with
screen space information, sometimes cryptic or convoluted formulas. Even if SDFs
have the perfect mathematical properties needed for a clean anti-aliasing, the
whole issue has a scope larger than it appears at first glance. And even when
trivial solutions exist, it&#39;s not always clear why they are a good fit. Let&#39;s
study that together.</p>
<h2>SDF</h2>
<p>The article assumes that you are at least a bit familiar with what an SDF is,
but if I had to provide a quick and informal definition, I would say something
like:</p>
<blockquote>
<p>&#34;It&#39;s a function (or lookup-table of said function, usually stored in a
texture) which returns the signed distance from the specified coordinates to
a given shape, where the sign indicates whether you&#39;re inside or outside the
shape.&#34;</p>
</blockquote>
<p>A common visualization of it looks like this:</p>
<figure>
  <canvas width="480" height="320" data-fragment="/frag/anti-aliasing/sdf-debug.frag"></canvas>
  <figcaption>SDF of a moving pie/pacman, using Inigo Quilez formula and colorscheme for visualization</figcaption>
</figure>
<p>The distance is fancily colored here for illustrative purpose, and the shape is
animated to see how it affects the field.</p>
<p>Another way of seeing it is to switch to a 3D view:</p>
<figure>
  <canvas width="480" height="480" data-fragment="/frag/anti-aliasing/sdf-3d.frag"></canvas>
  <figcaption>SDF of a moving pie/pacman, as seen in 3D</figcaption>
</figure>
<p>For the sign interpretation, here we&#39;re using the convention <strong>positive
inside and negative outside</strong>, <a href="https://en.wikipedia.org/wiki/Signed_distance_function#/media/File:Signed_distance1.png">as seen for example on the Wikipedia
illustration</a>. But this is not always the case, for example, Inigo
prefers the opposite: <strong>negative inside and positive outside</strong>. I personally
find the Wikipedia convention to be more intuitive and easy to work with, but
that&#39;s a matter of preferences so we&#39;ll figure out the formulas for both models.
Switching from one to the other is just a sign swap, but it&#39;s important to know
what we are working with.</p>
<h2>Linear ramp</h2>
<p>A properly crafted SDF has a gradient of length 1, meaning the slope is either
going up or down, but always at the same constant rate of 1:</p>
<figure>
  <img src="https://blog.pkh.me/img/anti-aliasing/sdf-grad1.png" alt=""/>
  <figcaption>1D side cut of an SDF depicting the gradient/slope</figcaption>
</figure>
<p>This is an important property since anti-aliasing is all about transitioning
smoothly toward (or away from) the shape. For our first attempt at anti-aliasing
we will simply follow that ramp and make a straight transition.</p>
<p>Once again, we are going to rely on <code>linear</code>, one of <a href="https://blog.pkh.me/p/29-the-most-useful-math-formulas.html">the most useful math
formulas</a>:</p>
<pre><code>float linear(float a, float b, float x) { return (x-a)/(b-a); }
</code></pre>
<p>And more specifically we will need its saturated version <code>linearstep</code>:</p>
<pre><code>float linearstep(float a, float b, float x) { return clamp(linear(a,b,x), 0.0, 1.0); }
</code></pre>
<p>This is the same as the well-known <code>smoothstep</code>, except it&#39;s a straight line
when transitioning from <code>a</code> to <code>b</code>.</p>
<figure>
  <img src="https://blog.pkh.me/img/anti-aliasing/linearstep.png" alt=""/>
  <figcaption>linearstep function</figcaption>
</figure>
<p>The length of our ramp (the transition zone between <code>a</code> and <code>b</code>) is going to be
arbitrary at first, we will call it <code>w</code> (for &#34;width&#34;). It&#39;s our diffuse, or blur
parameter if you prefer. The height <code>h</code> we are looking for corresponds to the
opacity of our shape.</p>
<p>Given a positive inside and negative outside SDF, we will start with the
transition centered around the boundary between the shape and its outside.</p>
<p>You might be confused about the relationship between the distance and the
transition zone (diffuse width <code>w</code>). The following diagram may help clarifying
why:</p>
<figure>
  <img src="https://blog.pkh.me/img/anti-aliasing/w-vs-d.png" alt=""/>
  <figcaption>The relationship between the diffuse width (w) and the signed distance (d)</figcaption>
</figure>
<p>Remember, the gradient of an SDF is supposed to have a length of 1. This means
there is a direct match between the height of the signed distance (y-axis on the
figure), and the spacial distance traveled (x-axis on the figure).</p>
<div>
<p>Note</p>
<p>This is why Inigo and other folks spend a lot of energy into looking for
the perfect formula for <a href="https://iquilezles.org/articles/ellipsedist/">the distance to an ellipse</a>. We cannot
just stretch a circle as it would distort the SDF, and thus break this
important property. A broken AA would be one of the consequences.</p>
</div>
<p>The previous figure shows that for a centered transition, when the distance
<code>d</code> is within <code>[-w/2,w/2]</code>, it represents a transition width of size <code>w</code> around
the edge, so we want it to be mapped to an opacity within <code>[0,1]</code>. This can be
expressed with:</p>
<pre><code>float h = linearstep(-w/2.0, w/2.0, d);
</code></pre>
<p>Which can be unrolled and simplified into the following tiny form:</p>
<pre><code>float h = clamp(0.5 + d/w, 0.0, 1.0);
</code></pre>
<p>We can also decide to make the transition on the outside or the inside boundary
of the shape:</p>
<pre><code>float h_in  = linearstep(0.0, w, d);  // or simply clamp(    d/w, 0.0, 1.0);
float h_out = linearstep(-w, 0.0, d); // or simply clamp(1.0+d/w, 0.0, 1.0);
</code></pre>
<p>And we can be creative and have a cursor indicating where we are on the border.
If we give <code>k=0</code> for inside, <code>k=0.5</code> for centered and <code>k=1</code> for outside:</p>
<pre><code>float h = clamp(k + d/w, 0.0, 1.0);
</code></pre>
<p>For the negative inside and positive outside SDF, we simply swap the sign:</p>
<pre><code>float h = clamp(k - d/w, 0.0, 1.0);
</code></pre>
<p>Any of these one-liners is all we need to have AA for our shape, but the
question of what value to use for the ramp width <code>w</code> arises.</p>
<figure>
  <canvas width="480" height="320" data-fragment="/frag/anti-aliasing/sdf-blurry.frag"></canvas>
  <figcaption>&#34;anti-aliasing&#34; with a width w oscillating within [0.1,0.3]</figcaption>
</figure>
<h2>Pixel size</h2>
<p>The difference between a blur and anti-aliasing is simply the width value. With
AA, it&#39;s the size of a &#34;pixel&#34;, and with a blur it&#39;s typically a user input or
an arbitrarily large value.</p>
<p>If we are in 2D and have access to the pixel resolution, we can use it to get
the pixel size. Note that this is closely tied to the coordinate space we use to
calculate the SDF.</p>
<p>For example, let&#39;s say we have a canvas for which we don&#39;t know the aspect ratio,
we can calculate the screen coordinates like this:</p>
<pre><code>vec2 p = (2.0*gl_FragCoord.xy - resolution) / min(resolution.x, resolution.y);
</code></pre>
<p>This will give us a <code>p</code> value within <code>[-1,1]</code> on the shortest axis (the y-axis
in landscape mode) and preserve a squared aspect ratio. That means the shortest
axis will have an amplitude of <code>2</code>, which means the number of pixel on that axis
correspond to 2 units. As a result, the unit-width that will be used for the
signed distance can be obtained with:</p>
<pre><code>float w = 2.0 / min(resolution.x, resolution.y);
</code></pre>
<p>Remember that this is true <em>only</em> if the position <code>p</code> we use for the SDF is
in that range. Basically, we have to adjust this formula to the coordinate space
we are using.</p>
<figure>
  <canvas width="480" height="320" data-fragment="/frag/anti-aliasing/sdf-exact.frag"></canvas>
  <figcaption>anti-aliasing with a width w of 1 pixel</figcaption>
</figure>
<p>The same with a x10 resolution to better see the AA:</p>
<figure>
  <canvas width="48" height="32" data-fragment="/frag/anti-aliasing/sdf-exact.frag"></canvas>
  <figcaption>anti-aliasing with a width w of 1 pixel (resolution x10)</figcaption>
</figure>
<h2>3D and numerical derivatives</h2>
<p>But sometimes we might not have access to the resolution, or we may want to map
that 2D SDF onto a plane in 3D or some other transformation. For example, a
decal or a text on the wall in a video game. In that later case, if we were to
use the screen resolution, it would lead to inconsistent anti-aliasing:</p>
<figure>
  <canvas width="120" height="80" data-fragment="/frag/anti-aliasing/sdf-decal.frag"></canvas>
  <figcaption>An SDF shape viewed from above and in perspective, resolution x4</figcaption>
</figure>
<p>We can see that, when put in perspective, the edge in the back gets way too
sharp while the edge in the front becomes a bit too blurry. Fortunately, there
is a magic trick we can use, the numerical derivatives:</p>
<pre><code>float w = fwidth(d);
</code></pre>
<figure>
  <canvas width="120" height="80" data-fragment="/frag/anti-aliasing/sdf-decal-fwidth.frag"></canvas>
  <figcaption>An SDF shape viewed from above and in perspective, using w=fwidth(d), resolution x4</figcaption>
</figure>
<p>Now we magically have a smooth pixel-wise anti-aliasing, no matter the
perspective. What is this sorcery? 🧙</p>
<p><code>fwidth</code> calculate the rate of change of a given variable using fragment-based
numerical derivatives. Mathematically this is a L1-norm (also known as Taxicab
or Manhattan norm) defined as: <code>abs(dFdx(x)) + abs(dFdy(x))</code>.</p>
<p>But how the hell is this providing a good pixel width estimate?</p>
<p>Let&#39;s see the simple case where we want observe the rate of change of one
variable across one axis. For example, <code>dFdx(px)</code> where <code>px</code> is the pixel
coordinate: <code>int px = gl_FragCoord.x</code>. We will have <code>dFdx(px)=1</code>. Why? Because
<code>x</code> changes at a constant rate of 1 (exactly like our SDF) from one pixel to
another. If we remap <code>px</code> to a value between <code>[-1,1]</code> using <code>p=px/W*2.0-1.0</code>
(where <code>W</code> is the number of pixels on the x axis), we can follow derivation
rules and end up with: <code>dFdx(p)=2.0/W</code>. This matches with our initial pixel size
computation <code>w</code> in our previous section.</p>
<p>Now when 3D and perspective distortions are involved, this still holds and you
may be wondering why. The intuitive answer is that <code>fwidth(d)</code> is the rate of
change of the signed distance <strong>as seen from the flat pixel screen
perspective</strong>. In 3D view, in the back of the shape, the distance <code>d</code> changes
sharply from one pixel to another (meaning <code>fwidth(d)</code> will be high), while in
the front it&#39;s way smoother (meaning <code>fwidth(d)</code> will be low). So this numerical
derivative is used to scale the distance back to a transition that works
smoothly from the 2D pixel point of view.</p>
<h3>Numerical derivatives refinement</h3>
<p>Instead of <code>fwidth</code>, we could also use the L2-norm (also known as euclidean
distance):</p>
<pre><code>float w = length(vec2(dFdx(d), dFdy(d)));
</code></pre>
<p>This is more expensive than <code>fwidth</code>, but it can be considered as an
alternative. The AA will be slightly different but it&#39;s hard to say which one
really is better than the other:</p>
<figure>
  <canvas width="80" height="40" data-fragment="/frag/anti-aliasing/norm1-vs-norm2.frag"></canvas>
  <figcaption>L1-norm (left) vs L2-norm (right) for pixel estimate, resolution x8</figcaption>
</figure>
<h2>Straight vs smooth(er) ramp</h2>
<p>Instead of a <code>linearstep()</code> some people like to use <code>smoothstep()</code>. The main
reason is probably because <code>smoothstep()</code> is available in builtin while
<code>linearstep()</code> isn&#39;t. But is it a better choice?</p>
<p>Intuitively, to me at least, it makes perfect sense for the alpha value to
follow a linear ramp. A few weeks ago I would have adamantly argued that it&#39;s
actually a faster and more logical choice than its curved version <code>smoothstep</code>.</p>
<p>Well... I did some tests. With a large diffuse, here is what it looks like with
a linear ramp:</p>
<figure>
  <canvas width="640" height="320" data-fragment="/frag/anti-aliasing/sdf-linear.frag"></canvas>
  <figcaption>A blurry shape using a linearstep transition with w=0.3</figcaption>
</figure>
<p>It looks like there is a brighter highlight around the border (before the
fall-off), doesn&#39;t it? Well, it&#39;s an illusion, it&#39;s just our brain noticing the
discontinuity and telling us about it.</p>
<p>With a <code>smoothstep</code> things get better:</p>
<figure>
  <canvas width="640" height="320" data-fragment="/frag/anti-aliasing/sdf-smooth.frag"></canvas>
  <figcaption>A blurry shape using a smoothstep transition with w=0.3</figcaption>
</figure>
<p>I wasn&#39;t expecting that, so I stand corrected: <code>smoothstep</code> is actually a better
choice. It&#39;s also builtin, so we won&#39;t need to define our own function.</p>
<p>Of course, one may prefer an even smoother curve, for example <code>smootherstep()</code>
using the quintic curve instead of the hermite:</p>
<pre><code>float smootherstep(float a, float b, float x) {
    float t = linearstep(a, b, x);
    return ((6.0*t-15.0)*t+10.0)*t*t*t; // quintic
}
</code></pre>
<figure>
  <canvas width="640" height="320" data-fragment="/frag/anti-aliasing/sdf-smoother.frag"></canvas>
  <figcaption>A blurry shape using a smootherstep transition</figcaption>
</figure>
<div>
<p>Note</p>
<p>For pixel-wise anti-aliasing, the discontinuity won&#39;t be noticed so using a
linear interpolation still is a perfectly valid choice.</p>
</div>
<h2>Color space</h2>
<p>When we have our anti-aliasing value, it&#39;s pretty much done. But we still have
the question on how to use it. My previous examples were in black and white, but
in many cases we need blending between colors. The question of how to blend is
probably the most tricky of all, and <a href="https://blog.pkh.me/p/43-the-current-technology-is-not-ready-for-proper-blending.html">my previous article was entirely dedicated
to this particular issue</a>.</p>
<p>In all the examples from this page, I&#39;ve been using the OkLab blending because
&#34;it&#39;s perfect&#34;. But the reality is likely to force you to use a simple linear
blending. For anti-aliasing, it&#39;s honestly just fine, the illusion still works
out, but if you&#39;re trying to blur I would advise you against it and switch to a
better colorspace like OkLab whenever possible.</p>
<p>See here how, because of how the human perception works, the linear blending
does feel &#34;bobby&#34; and too large compared to OkLab:</p>
<figure>
  <canvas width="640" height="320" data-fragment="/frag/anti-aliasing/sdf-linear-vs-oklab.frag"></canvas>
  <figcaption>A blurry shape blend using linear (left) or OkLab (right) blending</figcaption>
</figure>
<h2>Summary</h2>
<p>Given all these tools we can combine them according to our needs and
preferences. As closing words, let me propose a few reference examples:</p>
<h3>A &#34;good enough&#34; centered linear ramp working in 2D or 3D</h3>
<pre><code>vec2 p = (2.0*gl_FragCoord.xy - resolution) / min(resolution.x, resolution.y);
float d = sdWP(p, ...); // signed distance, positive inside, negative outside SDF (Wikipedia style)
float h = clamp(0.5 + d/fwidth(d), 0.0, 1.0);
vec3 c = mix(c0, c1, h); // this assumes c0 and c1 colors are in linear space
</code></pre>
<h3>A smooth user blur working in 2D only</h3>
<pre><code>float r = min(resolution.x, resolution.y);
vec2 p = (2.0*gl_FragCoord.xy - resolution) / r;
float w = max(u_blur, 2.0/r); // blur should not be smaller than unit size
float d = sdIQ(p, ...); // signed distance, negative inside, positive outside SDF (iQuilez style)
float h = smoothstep(-w/2.0, w/2.0, -d); // smooth centered blur
vec3 c = mix(c0, c1, h); // this assumes c0 and c1 colors are in linear space
</code></pre>
<h3>An outer anti-aliasing with a more refined unit width estimation</h3>
<pre><code>vec2 p = (2.0*gl_FragCoord.xy - resolution) / min(resolution.x, resolution.y);
float d = sdWP(p, ...); // signed distance, positive inside, negative outside SDF (Wikipedia style)
float w = length(vec2(dFdx(d),dFdy(d))); // L2-norm width estimation
float h = smoothstep(-w, 0.0, d); // smooth outer AA
vec3 c = mix(c0, c1, h); // this assumes c0 and c1 colors are in linear space
</code></pre>
<p>Anti-aliasing SDFs can be beautifully simple, and now we also understand better
the magic behind. ✨</p>
</article><p>For updates and more frequent content you can follow me on
<a href="https://fosstodon.org/@bug">Mastodon</a>. Feel also free to subscribe to the
<a href="https://blog.pkh.me/rss.xml">RSS</a> in order to be notified of new write-ups. It is also usually
possible to reach me through other means (check the footer below). Finally,
discussions on some of the articles can sometimes be found on HackerNews,
Lobste.rs and Reddit.</p></div>
  </body>
</html>
