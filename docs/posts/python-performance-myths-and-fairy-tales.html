<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lwn.net/SubscriberLink/1031707/73cb0cf917307a93/">Original</a>
    <h1>Python performance myths and fairy tales</h1>
    
    <div id="readability-page-1" class="page"><div>
<center>
<table>
<tbody><tr><td>
<h3>Welcome to LWN.net</h3>
<p>
The following subscription-only content has been made available to you 
by an LWN subscriber.  Thousands of subscribers depend on LWN for the 
best news from the Linux and free software communities.  If you enjoy this 
article, please consider accepting the discount offer on the right.  Thank you
for visiting LWN.net!
</p></td><td>
<div>
<h3>Special discount offer</h3>
           <p>
           <a href="https://lwn.net/Promo/sl-discount-3/claim">Subscribe to LWN now</a> at the
           &#34;professional hacker&#34; level for at least six months,
           and you will
           receive a special discount of 25%.
           
</p></div>
</td>
</tr>

</tbody></table>
</center>

<p>
Antonio Cuni, who
is a longtime Python performance engineer and <a href="https://pypy.org/">PyPy</a> developer, gave a presentation at <a href="https://ep2025.europython.eu/">EuroPython
2025</a> about &#34;Myths and fairy tales around Python performance&#34; on
the first day of the conference in Prague.  As might be guessed from the
title, he thinks that much of the conventional wisdom about Python
performance is misleading at best.  With lots of examples, he showed where
the real problems that he sees lie.  He has come to the conclusion that memory
management will ultimately limit what can be done about Python performance,
but he has an
early-stage project called <a href="https://github.com/spylang/spy?tab=readme-ov-file#spy">SPy</a> that
might be a way toward a super-fast Python.
</p>

<p>
He started by asking the audience to raise their hands if they thought
&#34;<q>Python is slow or not fast enough</q>&#34;; lots of hands went up, which
was rather different than when he gave the presentation at PyCon Italy,
where almost no one raised their hand. &#34;<q>Very different audience</q>&#34;, he
said with a smile.  He has been working on Python performance for many
years, has talked with many Python developers, and heard some persistent
myths, which he would like to try to dispel.
</p>

<h4>Myths</h4>

<p>
The first is that &#34;<q>Python is not slow</q>&#34;; based on the raised hands,
though, he thought that most attendees already knew that was a myth.  These
days, he hears developers say that Python speed doesn&#39;t really matter,
because it is a glue language; &#34;<q>nowadays only the GPU matters</q>&#34;, so
Python is fast enough.  Python <i>is</i> fast enough for some tasks, he
said, which is why there are so many people using it and attending
conferences like EuroPython.
</p>

<p>
There is a set of programs where Python is fast enough, but that set does
not hold all of the Python programs in use—it is only a subset.  The
programs that need more Python performance are what is driving all of the
different efforts to optimize the interpreter, but are also causing
developers to constantly work to improve the performance of their programs, often by using <a href="https://cython.org/">Cython</a>, <a href="https://numba.pydata.org/">Numba</a>, and the like.
</p>

<p><a href="https://lwn.net/Articles/1032100/">
<img src="https://static.lwn.net/images/2025/europy-cuni-sm.png" alt="[Antonio Cuni]" title="Antonio Cuni" width="220" height="280"/>
</a></p><p>
In his <a href="https://antocuni.eu/talk/2025/07/europython-myths-and-fairy-tales/">slides</a>,
he represented the two sets as circles, with &#34;programs where Python is fast
enough&#34; fully inside &#34;Python programs&#34;; he then added the set of &#34;all
possible programs&#34; fully encompassing the other two.  In his ideal world,
all possible programs would be able to be written with Python; currently,
programs that need all of the performance of the processor cannot use
Python.  He would like to see the inner circles grow so that Python can
be used in more programs.
</p>

<p>
The corollary of the &#34;it&#39;s just a glue language&#34; statement is that you
&#34;just need to rewrite the hot parts in <span>C/C++</span>&#34;, though that is a little out
of date; &#34;<q>nowadays they say that we should rewrite it in Rust</q>&#34;.
That is &#34;<q>not completely false</q>&#34;, it is a good technique to speed up
your code, but soon enough it will &#34;<q>hit a wall</q>&#34;.  The <a href="https://en.wikipedia.org/wiki/Pareto_principle">Pareto
principle</a>—described with a slide created by ChatGPT for unclear
reasons—says that 80% of the time will be spent in 20% of the code.  So
optimizing that 20% will help.
</p>

<p>
But the program will then run into <a href="https://en.wikipedia.org/wiki/Amdahl%27s_law">Amdahl&#39;s law</a>, which
says that the improvement for optimizing one part of the code is limited by
the time spent in the now-optimized code;
&#34;<q>what was the hot part now is very very fast and then you need to
optimize everything else</q>&#34;.  He showed a diagram where some
<tt>inner()</tt> function was taking 80% of the time; if that gets reduced
to, say, 10% of what it was, the rest of the program now dominates the run
time. 
</p>

<p>
Another &#34;myth&#34; is that Python is slow because it is interpreted; again,
there is some truth to that, but interpretation is only a small part of
what makes Python slow.  He gave the example of a simple Python
expression:
</p><pre>    p.x * 2
</pre><p>
A compiler for C/C++/Rust could turn that kind of expression into three
operations: load the value of </p><tt>x</tt><p>, multiply it by two, and then
store the result.  In Python, however, there is a long list of operations
that have to be performed, starting with finding the type of </p><tt>p</tt><p>,
calling its </p><tt>__getattribute__()</tt><p> method, through <a href="https://en.wikipedia.org/wiki/Boxing_(computer_programming)">unboxing</a></p><tt>p.x</tt><p> and </p><tt>2</tt><p>, to finally boxing the result, which requires
memory allocation.  None of that is dependent on whether Python is
interpreted or not, those steps are required based on the language
semantics.
</p>

<h4>Static types</h4>

<p>
Now people are using static types in Python, so he hears people say that
compilers for the language can now skip past all of those steps and
simply do the operation directly.  He put up an example:
</p><pre>    def add(x: int, y: int) -&gt; int:
        return x + y

    print(add(2, 3))
</pre><p>
But static typing is not enforced at run time, so there are various ways to
call </p><tt>add()</tt><p> with non-integers, for example:
</p><pre>    print(add(&#39;hello &#39;, &#39;world&#39;)) # type: ignore
</pre><p>
That is perfectly valid code and the type-checker is happy because of the
comment, but string addition is not the same as for integers.  The
static types &#34;<q>are completely useless from the point of view of
optimization and performance</q>&#34;.  Beyond that, the following is legal
Python too:
</p><pre>    class MyClass:
        def __add__(self, other):
            ...

    def foo(x: MyClass, y: MyClass) -&gt; MyClass:
        return x + y

    del MyClass.__add__
</pre><p>
&#34;<q>Static compilation of Python is problematic because everything can
change</q>&#34;, he said.
</p>

<p>
So, maybe, &#34;<q>a JIT compiler can solve all of your problems</q>&#34;; they can
go a long way toward making Python, or any dynamic language, faster, Cuni
said.  But that leads to &#34;<q>a more subtle problem</q>&#34;.  He put up a slide
with a <a href="https://en.wikipedia.org/wiki/Trilemma">trilemma</a>
triangle: a dynamic language, speed, or a simple implementation.
You can have two of those, but not all three.
</p>

<p>
Python has historically favored a dynamic, simply implemented language, but
it is moving toward a dynamic, fast language with projects like the <a href="https://lwn.net/Articles/1029307/">CPython JIT compiler</a>.  That loses the simple
implementation, but he does not have to care &#34;<q>because there are people
in the front row doing it for me</q>&#34;, he said with a grin.
</p>

<p>
In practice, though, it becomes hard to predict performance with a JIT.
Based on his experience with PyPy, and as a consultant improving Python
performance for customers, it is necessary to think about what the JIT will
do in order to get the best performance.  That is a complex and error-prone
process; he found situations where he was &#34;<q>unable to trigger
optimizations in PyPy&#39;s compiler because the code was too complicated</q>&#34;.
</p>

<p>
All of this leads to what he calls &#34;<q>optimization chasing</q>&#34;.  It
starts with a slow program that gets its fast path optimized, which results
in a faster program and everyone is happy.  Then they start to rely on that
extra speed, which can suddenly disappear with a seemingly unrelated change
somewhere in the program.  His favorite example is a program that was
running on PyPy (using Python 2) and suddenly got 10x slower; it turned out
that a Unicode key was being used in a dictionary of strings
that led the JIT to de-optimize the code so that everything got much
slower.
</p>

<h4>Dynamic</h4>

<p>
He put up some code that did not really do anything exciting or useful, he
said, but did demonstrate some of the problems that Python compilers
encounter: 
</p><pre>    import numpy as np

    N = 10

    def calc(v: np.ndarray[float], k: float) -&gt; float:
        return (v * k).sum() + N
</pre><p>
The compiler really can assume nothing from that code.  Seemingly, it
imports <a href="https://numpy.org/">NumPy</a> in the usual way, the
</p><tt>calc()</tt><p> function multiplies each element of the </p><tt>v</tt><p> array by
</p><tt>k</tt><p>, adds them all up with </p><tt>sum()</tt><p> and then adds the constant
</p><tt>N</tt><p> to that.  First off, the </p><tt>import</tt><p> may not bring in NumPy
at all; there could be some import hook somewhere that does something
completely unexpected.  </p><tt>N</tt><p> cannot be assumed to be ten, because
that could be changed elsewhere in the code; as with the earlier
</p><tt>add()</tt><p> function, the type declarations on </p><tt>calc()</tt><p> are not
ironclad either.
</p>

<p>
But, in almost all cases, that code would do exactly what it looks like it
does.  Developers rarely do these kinds of things that the language would
allow, but the
gap between the way programmers normally write Python and the definition of
the language is what &#34;<q>makes life complicated for the interpreter</q>&#34;.
In practice, a lot of what Python allows does not actually happen.
</p>

<p>
It is the extremely dynamic nature of the language that makes it slow,
&#34;<q>but at the same time it&#39;s what makes Python very nice</q>&#34;.  The
dynamic features are not needed 99% of the time, Cuni said, but &#34;<q>in that
1% are what you need to make Python awesome</q>&#34;.  Libraries often use
patterns that rely on the dynamic nature of the language in order to make
APIs &#34;<q>that end users can use nicely</q>&#34; so those features cannot simply
be removed.
</p>

<h4>Game</h4>

<p>
The &#34;compiler game&#34; was up next; he progressively showed some code snippets
to point out how little a compiler can actually &#34;know&#34; about the code.
This code might seem like it should give an error of some sort:
</p><pre>    class Point:
        def __init__(self, x, y):
            self.x = x
            self.y = y

    def foo(p: Point):
        assert isinstance(p, Point)
        print(p.name) # ???
</pre><p>
Inside </p><tt>foo()</tt><p>, the compiler knows that </p><tt>p</tt><p> is a
</p><tt>Point</tt><p>, which has no </p><tt>name</tt><p> attribute.  But, of course,
Python is a dynamic language:
</p><pre>    def bar():
        p = Point(1, 2)
        p.name = &#39;P0&#39;
        foo(p)
</pre><p>
Meanwhile, here is an example where the compiler cannot even assume that
the method exists:
</p><pre>    import random

    class Evil:
        if random.random() &gt; 0.5:
            def hello(self):
                print(&#39;hello world&#39;)

    Evil().hello() # 🤷🏻‍♂️
</pre><p>
Legal Python, but &#34;<q>this is not something to define in production, I
hope</q>&#34;, he said with a laugh.  &#34;<q>Half of the time it still works, half
of the time
it raises an exception. Good luck compiling it.</q>&#34;
</p>

<p>
In another example, he showed a function:
</p><pre>    def foo():
        p = Person(&#39;Alice&#39;, 16)
        print(p.name, p.age)
        assert isinstance(p, Person) # &lt;&lt;&lt;
</pre><p>
The </p><tt>Person</tt><p> class was not shown (yet), but there was an empty class
(just &#34;</p><tt>pass</tt><p>&#34;) called </p><tt>Student</tt><p>.  In this case, the
</p><tt>assert</tt><p> will fail, because of the definition of </p><tt>Person</tt><p>:
</p><pre>    class Person:
        def __new__(cls, name, age):
            if age &lt; 18:
                p = object.__new__(Student)
            else:
                p = object.__new__(Person)
            p.name = name
            p.age = age
            return p
</pre><p>
&#34;<q>You can have a class with a dunder-new [i.e. <tt>__new__()</tt>], which
returns something which is unrelated and is not an instance of the class.
Good luck optimizing that.</q>&#34;
</p>

<p>
The final entrant in the game was the following:
</p><pre>    N = 10

    @magic
    def foo():
       return N
</pre><p>
He &#34;de-sugared&#34; the </p><tt>@magic</tt><p> decorator and added some assertions:
</p><pre>    def foo():
       return N

    bar = magic(foo)

    assert foo.__code__ == bar.__code__
    assert bar.__module__ == &#39;__main__&#39;
    assert bar.__closure__ is None

    assert foo() == 10
    assert bar() == 20 # 🤯😱
</pre><p>
The code object for </p><tt>foo()</tt><p> and </p><tt>bar()</tt><p> are the same, but
they give different results.  As might be guessed, the value of </p><tt>N</tt><p>
has been changed by </p><tt>magic()</tt><p>; the code is as follows:
</p><pre>    def rebind_globals(func, newglobals):
        newfunc = types.FunctionType(
            func.__code__,
            newglobals,
            func.__name__,
            func.__defaults__,
            func.__closure__)
        newfunc.__module__ = func.__module__
        return newfunc

    def magic(fn):
        return rebind_globals(fn, {&#39;N&#39;: 20})
</pre><p>
That returns a version of the function (</p><tt>foo()</tt><p> was passed) that has
a different view of the values of the global variables.  That may seem like
a far-fetched example, but he wrote <a href="https://github.com/pdbpp/pdbpp/blob/master/src/pdbpp.py#L114-L134">code
much like that</a> for the <a href="https://github.com/pdbpp/pdbpp/tree/master?tab=readme-ov-file#pdb-a-drop-in-replacement-for-pdb">pdb++
Python debugger</a> many years ago. &#34;<q>I claim I had good reason to do
that</q>&#34;, he said with a chuckle.
</p>

<h4>Abstraction</h4>

<p>
So there are parts of the language that need to be accounted for, as he
showed in the game, but there is a more fundamental problem: &#34;<q>in Python,
abstractions are not free</q>&#34;.  When code is written, developers want
performance, but they also want the code to be understandable and
maintainable. That comes at a cost.  He started with a simple function:
</p><pre>    def algo(points: list[tuple[float, float]]):
        res = 0
        for x, y in points:
            res += x**2 * y + 10
        return
</pre><p>
It takes a list of points, each represented as a tuple of floating-point
numbers, and performs a calculation using them.
Then he factored out the calculation into its own function:
</p><pre>    def fn(x, y):
        return x**2 * y + 10
</pre><p>
That is already slower than the original, because there 
is overhead for calling a function: the function has to be looked up, a
frame object has to be created, and so on.  A JIT compiler can help, but it
will still have more overhead.  He took things one step further by
switching to a </p><tt>Point</tt><p> data class:
</p><pre>    @dataclass
    class Point:
        x: float
        y: float

    def fn(p):
        return p.x**2 * p.y + 10

    def algo(items: list[Point]):
        res = 0
        for p in items:
            res += fn(p)
        return
</pre><p>
That, of course, slows it down even further.  This is a contrived example,
Cuni said, but the idea is that every abstraction has a cost, &#34;<q>and then
you end up with a program that is very slow</q>&#34;.  It was an example of
what he calls &#34;Python to Python&#34; abstraction, where the code is being
refactored strictly within the language.
</p>

<p>
A &#34;Python to C&#34; abstraction, where the hot parts of the code are factored
out into C or some other compiled language, also suffers from added costs.
One could imagine that Python implementations get more and more
optimizations such that the list of <tt>Point</tt> objects is represented
in a simple linear array of floating-point numbers, without boxing, but if
<tt>fn()</tt> is written for Python&#39;s C API, those numbers will need to be
boxed and unboxed (in both directions), which is completely wasted work.
It is &#34;<q>unavoidable with the current C API</q>&#34;.  One of the ways to
speed up programs that were running under PyPy was to remove the C code and
perform the calculations directly in Python, which PyPy could optimize
well.
</p>

<h4>An elephant</h4>

<p>
There is an elephant in the room, however, with regard to Python
performance, though it is one he rarely hears about: memory management.  In
today&#39;s hardware, &#34;<q>computation is very cheap</q>&#34;, but memory is the
bottleneck.   If the data is in a cache at any level, accessing it is
inexpensive, but RAM accesses are quite slow.  &#34;<q>Generally speaking, if
you want to have very very good performance, we should avoid cache misses
as much as possible.</q>&#34;
</p>

<p>
But Python is prone to having a memory layout that is cache-unfriendly.  He
showed a simple example:
</p><pre>    class Person:
        def __init__(self, name, age):
            self.name = name
            self.age = age

    p = [Person(&#39;Alice&#39;, 16), Person(&#39;Bob&#39;, 21)]
</pre><p>
Each </p><tt>Person</tt><p> has two fields, which ideally would be placed together
in memory, and the two objects in the list would also be placed together,
for a cache-friendly layout.  In practice, though, those objects are all
scattered throughout memory; he showed a <a href="https://pythontutor.com/render.html#code=class%20Person%3A%0A%20%20%20%20def%20__init__%28self,%20name,%20age%29%3A%0A%20%20%20%20%20%20%20%20self.name%20%3D%20name%0A%20%20%20%20%20%20%20%20self.age%20%3D%20age%0A%20%20%20%20%0Ap%20%3D%20%5BPerson%28&#39;Alice&#39;,%2016%29,%20Person%28&#39;Bob&#39;,%2021%29%5D%0Adel%20Person&amp;cumulative=false&amp;curInstr=11&amp;heapPrimitives=true&amp;mode=display&amp;origin=opt-frontend.js&amp;py=3&amp;rawInputLstJSON=%5B%5D&amp;textReferences=false">visualization from
Python Tutor</a>.  Each arrow represented a pointer that needed to be
followed, thus a potential cache miss; there were nearly a dozen arrows for
this simple data structure.
</p>

<p>
&#34;<q>This is something you cannot just solve with a JIT compiler; it&#39;s
impossible to solve it without changing semantics.</q>&#34; Python is
inherently cache-unfriendly, he said, &#34;<q>and I honestly don&#39;t know how to
solve this problem</q>&#34;.  His &#34;sad truth&#34; conclusion is that &#34;<q>Python
cannot be super-fast</q>&#34; without breaking compatibility.  Some of the
dynamic features (&#34;<q>let&#39;s call it
craziness</q>&#34;)  he had described in the talk will eventually hamper performance improvements. &#34;<q>If we
want to keep this craziness, well, we have to leave some performance on the
table.</q>&#34;
</p>

<p>
His next slide was &#34;The end&#34;, complete with emojis of sadness (&#34;😢💔🥹&#34;),
which is where he ended the talk when he gave it at PyCon Italy a year
earlier.  This time, though, he wanted to &#34;<q>give a little hope</q>&#34; so he
added a question mark, then reiterated that without breaking
compatibility Python could not get super-fast.
</p>

<p>
He has a proposal for the community if it decides that Python should try to
reach top-level performance, which he hopes the community does, but
&#34;<q>it&#39;s fine to say &#39;no&#39;</q>&#34;.  He suggests tweaking the language
semantics by keeping the dynamic features where they are actually useful,
perhaps by limiting the kinds of dynamic changes that can be made to
specific points in time, so that compilers can depend on certain behavior
and structure.  &#34;<q>Not to allow the world to change at any point in
time as it is now.</q>&#34;
</p>

<p>
Meanwhile, the type system should be revamped with an eye on performance.
Currently, the types are optional and not enforced, so they cannot be
used for optimizations.  The intent would be that performance-oriented code
could be written in Python, not in some other language called from Python.
But, for cases where calling another language is still desirable, the
extra cost (e.g. boxing) of doing so should be removed. &#34;<q>Most
importantly, we want something which stays Pythonic, because we like this
language or we wouldn&#39;t be here.</q>&#34;
</p>

<p>
Cuni said that he has a potential solution, &#34;<q>which is not to make Python
faster</q>&#34;, because he claims that is not possible. SPy, which stands for
&#34;Static Python&#34;, is a project he started a few years ago to address the
performance problems.  All of the standard disclaimers apply to SPy, it is
&#34;<q>a work in progress, research and development, [and] we don&#39;t know where it
will go</q>&#34;.  The best information can be found on the GitHub page linked
above or in his <a href="https://antocuni.eu/2025/05/31/spy--pycon-it-2025/">talk on SPy at PyCon
Italy</a> in late May.
</p>

<p>
He showed a quick <a href="https://antocuni.pyscriptapps.com/sobel/latest/">demo</a> of doing
realtime edge detection from a camera; it ran in the browser using <a href="https://pyscript.net/">PyScript</a>.  The demo shows the raw camera
feed on the left
and, at first, edge detection being run in NumPy on the right; NumPy
achieves fewer than two frames per second (fps).  Switching to a SPy-based
edge-detection algorithm makes the right-hand image keep up with the
camera, running at around 60fps.  The <a href="https://github.com/spylang/demos/tree/main/sobel">code for the
demo</a> is available on GitHub as well.
</p>

<p>
He recommended the SPy repository and its issue tracker in particular for
interested attendees; some issues have been tagged as &#34;good first issue&#34;
and &#34;help wanted&#34;.  There is also a <a href="https://discord.com/invite/wRb29FGZpP">Discord server</a> for
chatting about the project. Before too long, a video of the talk should
appear on the <a href="https://www.youtube.com/@EuroPythonConference">EuroPython YouTube channel</a>.
</p>

<p>
[I would like to thank the Linux Foundation, LWN&#39;s travel sponsor, for
travel assistance to Prague for EuroPython.]
</p></div></div>
  </body>
</html>
