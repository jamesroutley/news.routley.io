<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.haskellforall.com/2024/08/firewall-rules-not-as-secure-as-you.html">Original</a>
    <h1>Firewall rules: not as secure as you think</h1>
    
    <div id="readability-page-1" class="page"><div id="post-body-6277361455932329681" itemprop="description articleBody">
<!--DOCTYPE html-->


  <meta charset="utf-8"/>
  <meta name="generator" content="pandoc"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes"/>
  <meta name="twitter:card" content="summary"/>
  <meta name="twitter:creator" content="@GabriellaG439"/>
  <meta name="twitter:title" content="Firewall rules: not as secure as you think"/>
  <meta name="twitter:description" content="A post outlining tricks for firewall privilege escalation"/>
  <title>Firewall rules: not as secure as you think</title>
  


<p>This post introduces some tricks for jailbreaking hosts behind
“secure” enterprise firewalls in order to enable arbitrary inbound and
outbound requests over any protocol. You’ll probably find the tricks
outlined in the post useful if you need to deploy software in a hostile
networking environment.</p>
<p>The motivation for these tricks is that you might be a vendor that
sells software that runs in a customer’s datacenter (a.k.a. <a href="https://en.wikipedia.org/wiki/On-premises_software">on-premises
software</a>), so your software has to run inside of a restricted
network environment. You (the vendor) can ask the customer to open their
firewall for your software to communicate with the outside world
(e.g. your own datacenter or third party services), but customers will
usually be reluctant to open their firewall more than necessary.</p>
<p>For example, you might want to <code>ssh</code> into your host so
that you can service, maintain, or upgrade the host, but if you ask the
customer to open their firewall to let you <code>ssh</code> in they’ll
usually push back on or outright reject the request. Moreover, this
isn’t one of those situations where you can just ask for forgiveness
instead of permission because you can’t begin to do anything without
explicitly requesting <em>some</em> sort of firewall change on their
part.</p>
<p>So I’m about to teach you a bunch of tricks for efficiently tunneling
whatever you want over seemingly innocuous openings in a customer’s
firewall. These tricks will culminate with the most cursed trick of all,
which is tunneling <strong>inbound SSH</strong> connections inside of
<strong>outbound HTTPS</strong> requests. This will grant you full
command-line access to your on-premises hosts using the most benign
firewall permission that a customer can grant. Moreover, this post is
accompanied by a <a href="https://github.com/Gabriella439/holepunch">repository named
<code>holepunch</code> containing NixOS modules automating this ultimate
trick</a> which you can either use directly or consult as a working
proof-of-concept for how the trick works.</p>
<h4 id="overview">Overview</h4>
<p>Most of the tricks outlined in this post assume that you control the
hosts on both ends of the network request. In other words, we’re going
to assume that there is some external host in your datacenter and some
internal host in the customer’s datacenter and you control the software
running on both hosts.</p>
<p>There are four tricks in our arsenal that we’re going to use to
jailbreak internal hosts behind a restrictive customer firewall:</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Proxy_server">forward
proxies</a> (e.g. <code>squid</code>)</li>
<li><a href="https://en.wikipedia.org/wiki/TLS_termination_proxy">TLS-terminating
reverse proxies</a> (e.g. <code>nginx</code> or
<code>stunnel</code>)</li>
<li><a href="https://en.wikipedia.org/wiki/Reverse_connection">reverse
tunnels</a> (e.g. <code>ssh -R</code>)</li>
<li><a href="https://github.com/bryanpkc/corkscrew"><code>corkscrew</code></a></li>
</ul>
<p>Once you master these four tools you will typically be able to do
basically anything you want using the slimmest of firewall
permissions.</p>
<p>You might also want to read another post of mine: <a href="https://www.haskellforall.com/2021/09/forward-and-reverse-proxies-explained.html">Forward
and reverse proxies explained</a>. It’s not required reading for this
post, but you might find it helpful or interesting if you like this
post.</p>
<h4 id="proxies">Proxies</h4>
<p>We’re going to start with proxies since that’s the easiest thing to
explain which requires no other conceptual dependencies.</p>
<p>A <strong>proxy</strong> is a host that can connect to other hosts on
a client’s behalf (instead of the client making a direct connection to
those other hosts). We will call these other hosts “upstream hosts”.</p>
<p>One of the most common tricks when jailbreaking an internal host (in
the customer’s datacenter) is to create an external host (in your
datacenter) that is a <strong>proxy</strong>. This is really effective
because <em>the customer has no control over traffic between the proxy
and upstream hosts</em>. The customer’s firewall can only see, manage,
and intercept traffic between the internal host and the proxy, but
everything else is invisible to them.</p>
<p>There are two types of proxies, though: forward proxies and reverse
proxies. Both types of proxies are going to come in handy for
jailbreaking our internal host.</p>
<h4 id="forward-proxy">Forward proxy</h4>
<p>A <strong>forward proxy</strong> is a proxy that lets the client
decide which upstream host to connect to. In our case, the “client” is
the internal host that resides in the customer datacenter that is trying
to bypass the firewall.</p>
<p>Forward proxies come in handy when the customer restricts which hosts
that you’re allowed to connect to. For example, suppose that your
external host’s address is <code>external.example.com</code> and your
internal hosts’s address is <code>internal.example.com</code>. Your
customer might have a firewall rule that prevents
<code>internal.example.com</code> from connecting to any host other than
<code>external.example.com</code>. The intention here is to prevent your
machine from connecting to other (potentially malicious) machines.
However, this firewall rule is quite easy for a vendor to subvert.</p>
<p>All you have to do is host a forward proxy at
<code>external.example.com</code> and then any time
<code>internal.example.com</code> wants to connect to any other domain
(e.g. <code>google.com</code>) it can just route the request through the
forward proxy hosted at <code>external.example.com</code>. For example,
<code>squid</code> is one example of a forward proxy that you can use
for this purpose, and you could configure it like this:</p>
<pre><code>acl internal src ${SUBNET OF YOUR INTERNAL SERVER(S)}

http_access allow internal
http_access deny all</code></pre>
<p>… and then <code>squid</code> will let any program on
<code>internal.example.com</code> connect to any host reachable from
<code>external.example.com</code> so long as the program configured
<code>http://external.example.com:3128</code> as the forward proxy. For
example, you’d be able to run this command on
<code>internal.example.com</code>:</p>
<div id="cb2"><pre><code><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span>$</span> curl <span>--proxy</span> http://external.example.com:3128 https://google.com</span></code></pre></div>
<p>… and the request would succeed despite the firewall because from the
customer’s point of view they can’t tell that you’re using a forward
proxy. Or can they?</p>
<h4 id="reverse-proxy">Reverse proxy</h4>
<p>Well, actually the customer <em>can</em> tell that you’re doing
something suspicious. The connection to <code>squid</code> isn’t
encrypted (note that the scheme for our forward proxy URI is
<code>http</code> and not <code>https</code>), and most modern firewalls
will be smart enough to monitor unencrypted traffic and notice that
you’re trying to evade the firewall by using a forward proxy (and they
will typically block your connection if you try this). Oops!</p>
<p>Fortunately, there’s a very easy way to evade this: encrypt the
traffic to the proxy! There are quite a few ways to do this, but the
most common approach is to put a “TLS-terminating reverse proxy” in
front of any service that needs to be encrypted.</p>
<p>So what’s a “reverse proxy”? A <strong>reverse proxy</strong> is a
proxy where the proxy decides which upstream host to connect to (instead
of the client deciding). A <strong>TLS-terminating</strong> reverse
proxy is one whose sole purpose is to provide an encrypted endpoint that
clients can connect to and then it forwards unencrypted traffic to some
(fixed) upstream endpoint (e.g. <code>squid</code> running on
<code>external.example.com:3128</code> in this example).</p>
<p>There are quite a few services created for doing this sort of thing,
but the three I’ve personally used the most throughout my career
are:</p>
<ul>
<li><code>nginx</code></li>
<li><code>haproxy</code></li>
<li><code>stunnel</code></li>
</ul>
<p>For this particular case, I actually will be using
<code>stunnel</code> to keep things as simple as possible
(<code>nginx</code> and <code>haproxy</code> require a bit more
configuration to get working for this).</p>
<p>You would run <code>stunnel</code> on
<code>external.example.com</code> with a configuration that would look
something like this:</p>
<div id="cb3"><pre><code><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span>[default]</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span>accept</span> <span>=</span> <span>443</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span>connect</span> <span>=</span> <span>localhost</span><span>:</span><span>3128</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span>cert</span> <span>=</span> <span>/</span><span>path</span><span>/</span><span>to</span><span>/</span><span>your-certificate.pem</span></span></code></pre></div>
<p>… and now connections to <code>https://external.example.com</code>
are encrypted and handled by <code>stunnel</code>, which will decrypt
the traffic and route those requests to <code>squid</code> running on
port <code>3128</code> of the same machine.</p>
<p>In order for this to work you’re going to need a valid certificate
for <code>external.example.com</code>, which you can obtain for free
using <a href="https://letsencrypt.org/">Let’s Encrypt</a>. Then you
staple the certificate public key and private key to generate the final
PEM file that you reference in the above <code>stunnel</code>
configuration.</p>
<p>So if you’ve gotten this far your server can now access any publicly
reachable address despite the customer’s firewall restriction. Moreover,
the customer can no longer detect that anything is amiss because all of
your connections to the outside world will appear to the customer’s
firewall as encrypted HTTPS connections to
<code>external.example.com:443</code>, which is an extremely innocuous
type of of connection.</p>
<h4 id="reverse-tunnel">Reverse tunnel</h4>
<p>We’re only getting started, though! By this point we can make
whatever outbound connections we want, but <em>WHAT ABOUT INBOUND
CONNECTIONS</em>?</p>
<p>As it turns out, there is a trick known as a <strong>reverse
tunnel</strong> which lets you tunnel inbound connections over outbound
connections. Most reverse tunnels exploit two properties of TCP
connections:</p>
<ul>
<li>TCP connections may be long-lived (sometimes very long-lived)</li>
<li>TCP connections must necessarily support network traffic in both
directions</li>
</ul>
<p>Now, in the common case a lot of TCP connections are short-lived. For
example, when you open https://google.com in your browser that is an
HTTPS request which is layered on top of a TCP connection. The HTTP
request message is data sent in one direction over the TCP connection
and the HTTP response message is data sent in the other direction over
the TCP connection and then the TCP connection is closed.</p>
<p>But TCP is much more powerful than that and reverse tunnels exploit
that latent protocol power. To illustrate how that works I’ll use the
most widely known type of reverse tunnel: the SSH reverse tunnel.</p>
<p>You typically create an SSH reverse tunnel by running a command like
this from the internal machine
(e.g. <code>internal.example.com</code>):</p>
<div id="cb4"><pre><code><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span>$</span> ssh <span>-R</span> <span>&#34;</span><span>${EXTERNAL_PORT}</span><span>:localhost:</span><span>${INTERNAL_PORT}</span><span>&#34;</span> <span>-N</span> external.example.com</span></code></pre></div>
<p>In an SSH reverse tunnel, the internal machine
(e.g. <code>internal.example.com</code>) initiates an outbound TCP
request to the SSH daemon (<code>sshd</code>) listening on the external
machine (e.g. <code>external.example.com</code>). When <code>sshd</code>
receives this TCP request it <em>keeps the TCP connection alive</em> and
then listens for inbound requests on <code>EXTERNAL_PORT</code> of the
external machine. <code>sshd</code> forward all requests received on
that port through the still-alive TCP connection back to the
<code>INTERNAL_PORT</code> on the internal machine. This works fine
because TCP connections permit arbitrary data flow both ways and the
protocol does not care if the usual request/response flow is suddenly
reversed.</p>
<blockquote>
<p>In fact, an SSH reverse tunnel doesn’t just let you make inbound
connections to the internal machine; it lets you make inbound
connections to <strong>any machine reachable from the internal
machine</strong> (e.g. other machines inside the customer’s datacenter).
However, those kinds of connections to other internal hosts can be
noticed and blocked by the customer’s firewall.</p>
</blockquote>
<p>From the point of view of the customer’s firewall, our internal
machine has just made a single long-lived <strong>outbound</strong>
connection to <code>external.example.com</code> and they cannot easily
tell that the <em>real</em> requests are coming in the other direction
(<strong>inbound</strong>) because those requests are being tunneled
inside of the outbound request.</p>
<p>However, this is not foolproof, for two reasons:</p>
<ul>
<li><p>A customer’s firewall can notice (and ban) a long-lived
connection</p>
<p>I believe it is possible to disguise a long-lived connection as a
series of shorter-lived connections, but I’ve never personally done that
before so I’m not equipped to explain how to do that.</p></li>
<li><p>A customer’s firewall <em>will</em> notice that you’re making an
SSH connection of some sort</p>
<p>Even when the SSH connection is encrypted it is still possible for a
firewall to detect that the SSH protocol is being used. A lot of
firewalls will be configured to ban SSH traffic by default unless
explicitly approved.</p></li>
</ul>
<p>However, there is a great solution to that latter problem, which is
…</p>
<h4 id="corkscrew"><code>corkscrew</code></h4>
<p><code>corkscrew</code> is an extremely simple tool that wraps an SSH
connection in an HTTP connection. This lets us disguise SSH traffic as
HTTP traffic (which we can then further disguise as HTTPS traffic by
encrypting the connection using <code>stunnel</code>).</p>
<p>Normally, the only thing we’d need to do is to extend our
<code>ssh -R</code> command to add this option:</p>
<div id="cb5"><pre><code><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span>ssh</span> <span>-R</span> <span>-o</span> <span>&#39;ProxyCommand /path/to/corkscrew external.example.com 443 %h %p` …</span></span></code></pre></div>
<p>… but this doesn’t work because <code>corkscrew</code> doesn’t
support HTTPS connections (it’s an extremely simple program written in
just a couple hundred lines of C code). So in order to work around that
we’re going to use <code>stunnel</code> again, but this time we’re going
to run <code>stunnel</code> in “client mode” on
<code>internal.example.com</code> so that it can handle the HTTPS logic
on behalf of <code>corkscrew</code>.</p>
<div id="cb6"><pre><code><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span>[default]</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span>client</span> <span>=</span> <span>yes</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span>accept</span> <span>=</span> <span>3128</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span>connect</span> <span>=</span> <span>external.example.com</span><span>:</span><span>443</span></span></code></pre></div>
<p>… and then the correct <code>ssh</code> command is:</p>
<div id="cb7"><pre><code><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span>$</span> ssh <span>-R</span> <span>-o</span> <span>&#39;ProxyCommand /path/to/corkscrew localhost 3128 %h %p` …</span></span></code></pre></div>
<p>… and now you are able to disguise an outbound SSH request as an
outbound HTTPS request.</p>
<p><strong>MOREOVER,</strong> you can use that disguised outbound SSH
request to create an SSH reverse tunnel which you can use to forward
inbound traffic from <code>external.example.com</code> to any
<code>INTERNAL_PORT</code> on <code>internal.example.com</code>. Can you
guess what <code>INTERNAL_PORT</code> we’re going to pick?</p>
<p>That’s right, we’re going to forward inbound traffic to port 22:
<code>sshd</code>. Also, we’re going to arbitrarily set
<code>EXTERNAL_PORT</code> to 17705:</p>
<div id="cb8"><pre><code><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span>$</span> ssh <span>-R</span> 17705:localhost:22 <span>-N</span> external.example.com</span></code></pre></div>
<p>Now, (separately from the above command) we can <code>ssh</code> into
our internal server via our external server like this:</p>
<div id="cb9"><pre><code><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span>$</span> ssh <span>-p</span> 17705 external.example.com</span></code></pre></div>
<p>… and we have complete command-line access to our internal server and
the customer is none the wiser.</p>
<p>From the customer’s perspective, we just ask them for an
innocent-seeming firewall rule permitting outbound HTTPS traffic from
<code>internal.example.com</code> to <code>external.example.com</code>.
That is the most innocuous firewall change we can possibly request
(short of not opening the firewall at all).</p>
<h4 id="conclusion">Conclusion</h4>
<p>I don’t think all firewall rules are ineffective or bad, but if the
same person or organization controls both ends of a connection then
typically anything short of completely disabling internet access can be
jailbroken in some way with off-the-shelf open source tools. It does
require some work, but as you can see with the <a href="https://github.com/Gabriella439/holepunch">associated
<code>holepunch</code> repository</a> even moderately sophisticated
firewall escape hatches can be neatly packaged for others to reuse.</p>



</div></div>
  </body>
</html>
