<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://jackkelly.name/blog/archives/2024/10/12/a_dictionary_of_single-letter_variable_names/">Original</a>
    <h1>A dictionary of single-letter variable names</h1>
    
    <div id="readability-page-1" class="page"><div>
  
  <div><p>
  Posted on October 12, 2024
  
    by Jack Kelly
  

  
    </p>
  
</div>

  <p>Haskell’s expressive type system means that type signatures can carry
a lot of information. Haskell’s polymorphism means that you sometime
write a function that works across an enormous range of types, and are
often left wondering “what do I actually call my variables?”. It is
often the case that there’s nothing to say beyond “this variable is a <a href="https://hackage.haskell.org/package/base-4.20.0.1/docs/Data-Functor.html#t:Functor"><code>Functor</code></a>”,
or “this variable is a monadic action”, and so a single-letter variable
name is appropriate. An unofficial and largely undocumented convention
has emerged around these variable names, and so I wanted to write them
all down in one place.</p>
<p>It should go without saying that single-letter variable names are not
always the answer. Like point-free style, it sometimes obscures more
than it helps and people get carried away with it. But when you have a
highly polymorphic function and no good words to use, choosing the right
letter can convey a surprising amount of meaning.</p>
<p>This dictionary is not and cannot be exhaustive. Variable naming
often relies on context to convey information, and shorter variable
names should only be used when they make sense in context. That context
could be:</p>
<ul>
<li>The function’s <code>(...) =&gt;</code> context to reference
“nearby” concepts, as in <code>Monoid</code> and
<code>Monad</code>;</li>
<li>Some nearby variable context, like when using <code>(k, v)</code> to
reference the key and value of a <code>Map</code> entry; or</li>
<li>Domain context.
<code>position a u t = u * t + (a * t * t) / 2</code> is reasonable if
the reader knows you’re talking classical mechanics.</li>
</ul>
<p>With the warnings out of the way, the dictionary is after the jump.
The bulk of the dictionary documents type variables, where overly long
variable names can blow out complicated type signatures. Important
value-level variable names are also documented, and are explicitly
labelled as such.</p>
<!--more-->
<h2 id="the-dictionary">The Dictionary</h2>
<h3 id="a"><code>a</code></h3>
<ol type="1">
<li>(Rare) the type of an <a href="https://hackage.haskell.org/package/base-4.20.0.1/docs/Control-Arrow.html#t:Arrow"><code>Arrow</code></a>,
but because of the common usage of <code>a</code> as “arbitrary ground
type (type of kind <code>Type</code>)”, this is often confusing. I
recommend <code>arr</code> or infix <code>k</code> instead.</li>
</ol>
<h3 id="a-b-c-d"><code>a</code>, <code>b</code>, <code>c</code>,
<code>d</code></h3>
<ol type="1">
<li>Arbitrary (almost always ground) types, like the <code>a</code> in a
<code>Foldable t =&gt; t a</code>. Almost never used for higher-kinded
types, unless they’re kind-polymorphic (like
<code>data Proxy (a :: k) =    Proxy</code>).</li>
</ol>
<h3 id="b"><code>b</code></h3>
<ol type="1">
<li>(As value) An arbitrary <code>ByteString</code>. I personally am not
a fan of using <code>b</code> or <code>bs</code> for this: there is
often a short contextual word that describes what it actually is, and if
it truly is an arbitrary collection of bytes, then <code>bytes</code> is
only five characters.</li>
</ol>
<h3 id="c"><code>c</code></h3>
<ol type="1">
<li><p>A constraint (type variable of kind <a href="https://hackage.haskell.org/package/base-4.20.0.1/docs/Data-Kind.html#t:Constraint"><code>Constraint</code></a>).</p></li>
<li><p>(Sometimes) type variable of class <a href="https://hackage.haskell.org/package/base-4.20.0.1/docs/Control-Category.html#t:Category"><code>Category</code></a>,
but that clashes with <code>c</code> if you’re writing out a composition
operator. Consider <code>cat</code> or infix <code>k</code> as
alternatives.</p>
<div id="cb1"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span>-- From package `constraints`. Given evidence `e`,</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span>-- produce a dictionary for constraint `c`:</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span>class</span> <span>HasDict</span> c e <span>|</span> e <span>-&gt;</span> c</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span>  evidence ::</span> e <span>-&gt;</span> <span>Dict</span> c</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span>-- From package `constraints-extras`:</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span>class</span> <span>Has</span> c f <span>where</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span>  has ::</span> <span>forall</span> a r<span>.</span> f a <span>-&gt;</span> (c a <span>=&gt;</span> r) <span>-&gt;</span> r</span></code></pre></div></li>
</ol>
<h3 id="e"><code>e</code></h3>
<ol type="1">
<li><p>(As type or value) An “error” or exception type, though I
personally prefer <code>ex</code> for true exceptions. Using
<code>e</code> in a type like <code>Either e a</code> indicates that
<code>Either</code> is being used for its <code>Monad</code> instance,
where <code>Left</code> is considered an exceptional/early/error return,
and not as an unbiased choice between two types.</p>
<div id="cb2"><pre><code><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span>-- From packages `mtl`, `generic-lens`:</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span>trySomething ::</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  (<span>MonadError</span> e m, <span>AsType</span> <span>SomeSpecificError</span> e) <span>=&gt;</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  <span>SomeArgument</span> <span>-&gt;</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  m <span>SomeResponse</span></span></code></pre></div></li>
</ol>
<h3 id="f-g-h"><code>f</code>, <code>g</code>, <code>h</code></h3>
<ol type="1">
<li><p>A <code>Functor</code> or “<code>Functor</code>-like” type,
including <a href="https://hackage.haskell.org/package/base-4.20.0.1/docs/Control-Applicative.html#t:Applicative"><code>Applicative</code></a>,
<a href="https://hackage.haskell.org/package/base-4.20.0.1/docs/Control-Applicative.html#t:Alternative"><code>Alternative</code></a>,
and their contravariant versions <a href="https://hackage.haskell.org/package/base-4.20.0.1/docs/Data-Functor-Contravariant.html#t:Contravariant"><code>Contravariant</code></a>,
<a href="https://hackage.haskell.org/package/contravariant-1.5.5/docs/Data-Functor-Contravariant-Divisible.html#t:Divisible"><code>Divisible</code></a>,
and <a href="https://hackage.haskell.org/package/contravariant-1.5.5/docs/Data-Functor-Contravariant-Divisible.html#t:Decidable"><code>Decidable</code></a>.</p></li>
<li><p>(As value) An arbitrary function.</p></li>
</ol>
<h3 id="h"><code>h</code></h3>
<ol type="1">
<li>(As value, rare) The <code>h</code>ead of a sequence, but the
<code>x:xs</code> notation is more common.</li>
</ol>
<h3 id="i-j"><code>i</code>, <code>j</code></h3>
<ol type="1">
<li><p>An index: a type that identifies an element in a structure (a key
in a key-value map; an <code>Int</code> for a list, vector, or sequence;
etc).</p>
<div id="cb3"><pre><code><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span>-- From package `indexed-traversable`:</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span>class</span> <span>Functor</span> f <span>=&gt;</span> <span>FunctorWithIndex</span> i f <span>|</span> f <span>-&gt;</span> i <span>where</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span>  imap ::</span> (i <span>-&gt;</span> a <span>-&gt;</span> b) <span>-&gt;</span> f a <span>-&gt;</span> f b</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span>instance</span> <span>FunctorWithIndex</span> <span>Int</span> <span>List</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span>instance</span> <span>FunctorWithIndex</span> k (<span>Map</span> k)</span></code></pre></div></li>
<li><p>(As value) An integral value.</p></li>
<li><p>(As value, uncommon) An index into a data structure.
<code>idx</code> is more common.</p></li>
</ol>
<h3 id="k"><code>k</code></h3>
<ol type="1">
<li><p>(As type or value) <code>k</code>ey type of a key-value map, or
the <code>key</code> of a K-V entry within such a map.</p>
<div id="cb4"><pre><code><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span>-- From package `containers`:</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span>mapWithKey ::</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  (k <span>-&gt;</span> a <span>-&gt;</span> b) <span>-&gt;</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  <span>Map</span> k a <span>-&gt;</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  <span>Map</span> k b</span></code></pre></div></li>
<li><p>(Sometimes) the arrows of a category, often written infix.</p>
<div id="cb5"><pre><code><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span>-- From package `categories`:</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span>class</span> <span>Category</span> k <span>=&gt;</span> <span>HasTerminalObject</span> k <span>where</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  <span>type</span> <span>Terminal</span><span> k ::</span> <span>Type</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span>  terminate ::</span> a <span>`k`</span> <span>Terminal</span> k</span></code></pre></div></li>
<li><p>(As value) A continuation parameter. (Mnemonic:
<code>k</code>ontinuation)</p>
<div id="cb6"><pre><code><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span>-- From package `transformers`:</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span>runCont ::</span> <span>Cont</span> r a <span>-&gt;</span> (a <span>-&gt;</span> r) <span>-&gt;</span> r</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>runCont m k <span>=</span> runIdentity (runContT m (<span>Identity</span> <span>.</span> k))</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span>--        ^-- The continuation parameter.</span></span></code></pre></div></li>
<li><p>The “<code>k</code>ind variable” for a type variables of
polymorphic kind.</p>
<div id="cb7"><pre><code><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span>data</span> <span>Proxy</span> (<span>a ::</span> k) <span>=</span> <span>Proxy</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span>--               ^-- The variable `a` has polymorphic kind.</span></span></code></pre></div></li>
</ol>
<h3 id="m"><code>m</code></h3>
<h4 id="as-type">As Type</h4>
<ol type="1">
<li><p>A <a href="https://hackage.haskell.org/package/base-4.20.0.1/docs/Data-Monoid.html#t:Monoid"><code>Monoid</code></a>,
subclass of <code>Monoid</code>, or a monoidal value.</p>
<div id="cb8"><pre><code><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span>foldMap</span><span> ::</span> (<span>Foldable</span> t, <span>Monoid</span> m) <span>=&gt;</span> (a <span>-&gt;</span> m) <span>-&gt;</span> t a <span>-&gt;</span> m</span></code></pre></div></li>
<li><p>A <a href="https://hackage.haskell.org/package/base-4.20.0.1/docs/Control-Monad.html#t:Monad"><code>Monad</code></a>,
subclass of <code>Monoid</code>, or (as value) a monadic action.</p>
<div id="cb9"><pre><code><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span>(&gt;&gt;=) ::</span> <span>Monad</span> m <span>=&gt;</span> m a <span>-&gt;</span> (a <span>-&gt;</span> m b) <span>-&gt;</span> m b</span></code></pre></div></li>
<li><p>(As value) a map (such as a <code>Data.Map.Map k v</code>), but
with no contextual meaning.</p></li>
</ol>
<p>For <code>Monad</code>s and <code>Monoid</code>s, <code>n</code> is
sometimes also used when a second variable is needed, but is hard to
visually distinguish from <code>m</code>. Consider <code>m&#39;</code>,
<code>m1</code> and <code>m2</code>, or (if using <code>Monad</code> as
<code>Functors</code>) <code>f</code> and <code>g</code> instead.</p>
<h3 id="n"><code>n</code></h3>
<ol type="1">
<li><p>A type-level natural number.</p></li>
<li><p>(As value) A numeric (often <a href="https://hackage.haskell.org/package/base-4.20.0.1/docs/Numeric-Natural.html#t:Natural"><code>Natural</code></a>
or at least <a href="https://hackage.haskell.org/package/base-4.20.0.1/docs/Prelude.html#t:Integral">Integral</a>)
quantity. Often used for the (single) numeic induction variable in a
recursive function.</p></li>
</ol>
<h3 id="p"><code>p</code></h3>
<ol type="1">
<li><p>(As value) A <code>p</code>roposition — a <code>Bool</code> with
no contextual meaning that we can see. All we care about is whether it
is <code>True</code> or <code>False</code>.</p>
<div id="cb10"><pre><code><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span>when ::</span> <span>Applicative</span> f <span>=&gt;</span> <span>Bool</span> <span>-&gt;</span> f () <span>-&gt;</span> f ()</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>when p s <span>=</span> <span>if</span> p <span>then</span> s <span>else</span> <span>pure</span> ()</span></code></pre></div></li>
<li><p>(As value, rare) A “<a href="https://en.wikipedia.org/wiki/Predicate_(mathematical_logic)">predicate</a>”.
A predicate is almost always represented by a function
<code>a -&gt; Bool</code> and often named <code>pred_</code>
(<code>pred</code> without the underscore clashes with a method from
class <code>Enum</code>), or with the standard variable name
<code>f</code>.</p></li>
</ol>
<h3 id="p-q"><code>p</code>, <code>q</code></h3>
<ol type="1">
<li><p>Mnemonically, a <a href="https://hackage.haskell.org/package/profunctors-5.6.2/docs/Data-Profunctor.html#t:Profunctor"><code>Profunctor</code></a>,
or a profunctor value.</p>
<div id="cb11"><pre><code><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span>-- From package `profunctors`:</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span>class</span> <span>Profunctor</span> p <span>where</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span>  dimap ::</span> (a <span>-&gt;</span> b) <span>-&gt;</span> (c <span>-&gt;</span> d) <span>-&gt;</span> p b c <span>-&gt;</span> p a d</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span>  lmap ::</span> (a <span>-&gt;</span> b) <span>-&gt;</span> p b c <span>-&gt;</span> p a c</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span>  rmap ::</span> (b <span>-&gt;</span> c) <span>-&gt;</span> p a b <span>-&gt;</span> p a c</span></code></pre></div></li>
<li><p>A <a href="https://hackage.haskell.org/package/base-4.20.0.1/docs/Data-Bifunctor.html#t:Bifunctor"><code>Bifunctor</code></a>,
or a bifunctor value. (The obvious first choice — <code>b</code> — would
clash with the use of
<code>a</code>/<code>b</code>/<code>c</code>/<code>d</code> for
arbitrary types.)</p>
<div id="cb12"><pre><code><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span>class</span> (<span>forall</span> a<span>.</span> <span>Functor</span> (p a)) <span>=&gt;</span> <span>Bifunctor</span> p <span>where</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span>  bimap ::</span> (a <span>-&gt;</span> b) <span>-&gt;</span> (c <span>-&gt;</span> d) <span>-&gt;</span> p a c <span>-&gt;</span> p b d</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span>  first ::</span> (a <span>-&gt;</span> b) <span>-&gt;</span> p a c <span>-&gt;</span> p b c</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span>  second ::</span> (b <span>-&gt;</span> c) <span>-&gt;</span> p a b <span>-&gt;</span> p a c</span></code></pre></div></li>
</ol>
<h3 id="r"><code>r</code></h3>
<ol type="1">
<li><p>A “reader” or “environment” type, like the kind carried around in
a <code>ReaderT</code>.</p>
<div id="cb13"><pre><code><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span>-- Constraints from packages &#39;mtl&#39; and &#39;generic-lens&#39;:</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span>doSomething ::</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>  (<span>MonadReader</span> r m, <span>HasField&#39;</span> <span>&#34;apiKey&#34;</span> r <span>ApiKey</span>) <span>=&gt;</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>  <span>AnArg</span> <span>-&gt;</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>  m <span>AResult</span></span></code></pre></div></li>
<li><p>A “return” or “result” type. Often used as the result type for
streams and the like, as well as in type signatures for functions
written in <a href="https://en.wikibooks.org/wiki/Haskell/Continuation_passing_style">continuation-passing
style</a>:</p>
<div id="cb14"><pre><code><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span>-- From package `streaming`:</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span>data</span> <span>Stream</span> f m r</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span>--              ^-- Result type of the stream.</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span>-- From package `constraints-extras`:</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a><span>class</span> <span>Has</span> c f <span>where</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a><span>  has ::</span> <span>forall</span> a r<span>.</span> f a <span>-&gt;</span> (c a <span>=&gt;</span> r) <span>-&gt;</span> r</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>  <span>--                                ^     ^</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>  <span>-- Continuation-passing style: the return type</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>  <span>-- of the function argument is the return type</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>  <span>-- of the whole function.</span></span></code></pre></div></li>
<li><p>(As value) A result of some sort. (I personally prefer
<code>res</code>.)</p></li>
</ol>
<h3 id="s"><code>s</code></h3>
<ol type="1">
<li><p>A “state type”, like the ones plumbed around by <a href="https://hackage.haskell.org/package/transformers-0.6.1.2/docs/Control-Monad-Trans-State-Lazy.html#t:StateT"><code>StateT</code></a>.</p>
<div id="cb15"><pre><code><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span>-- From package `mtl`.</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span>modify ::</span> <span>MonadState</span> s m <span>=&gt;</span> (s <span>-&gt;</span> s) <span>-&gt;</span> m ()</span></code></pre></div></li>
<li><p>(As value, sometimes) An arbitrary <code>String</code> or
<code>Text</code>. <code>str</code> is usually more common, or
<code>c:cs</code> or <code>ch:chs</code> if recursing over individual
<code>Char</code>s (the <code>s</code> suffix denotes plural “chars”;
this is also discussed in the section on <code>x</code>, <code>y</code>,
<code>z</code>).</p></li>
</ol>
<h3 id="s-t-a-b"><code>s</code>, <code>t</code>, <code>a</code>,
<code>b</code></h3>
<ol type="1">
<li><p>These four type variables often appear together in lenses or
other optics. The simplest complete example is a
<code>Lens s t a b</code>: it can extract an <code>a</code> from an
<code>s</code> and overwrite it with a <code>b</code>. Doing so would
produce a value of type <code>t</code>.</p>
<div id="cb16"><pre><code><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span>-- A lens into the second part of a 2-tuple.</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span>-- Inspired by package `lens`, but less polymorphic to make the point clear.</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span>_2 ::</span> <span>Lens</span> (x, c) (x, d) c d</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span>--           ^      ^    ^ ^-- `b`: Type of the new value to put back in.</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a><span>--           |      |    &#39;---- `a`: Type of the value extracted from the tuple.</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a><span>--           |      &#39;--------- `t`: Type of the tuple with a new value written back.</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a><span>--           &#39;---------------- `s`: Type of the initial tuple that is focused upon.</span></span></code></pre></div></li>
</ol>
<h3 id="t"><code>t</code></h3>
<ol type="1">
<li><p>A <a href="https://hackage.haskell.org/package/base-4.20.0.1/docs/Data-Traversable.html#t:Traversable"><code>Traversable</code></a>
or <a href="https://hackage.haskell.org/package/base-4.20.0.1/docs/Data-Foldable.html#t:Foldable"><code>Foldable</code></a>
structure. The mnemonic for <code>Traversable</code> is obvious, but
<code>Foldable</code> is a superclass of <code>Traversable</code> and so
is often called <code>t</code> as well:</p>
<div id="cb17"><pre><code><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span>class</span> <span>Foldable</span> t <span>where</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span>  foldMap ::</span> <span>Monoid</span> m <span>=&gt;</span> (a <span>-&gt;</span> m) <span>-&gt;</span> t a <span>-&gt;</span> m</span></code></pre></div></li>
<li><p>(As value) An arbitrary <code>Text</code> value.</p></li>
<li><p>(As value, sometimes) A time value. I personally avoid using
<code>t</code> for times, as times often have some contextual meaning
and can be given better names like <code>now</code> or
<code>createdAt</code>.</p></li>
<li><p>(As value, rare) The <code>t</code>ail of a sequence, but the
<code>x:xs</code> notation is more common.</p></li>
</ol>
<h3 id="v"><code>v</code></h3>
<ol type="1">
<li>(As type or value) <code>v</code>alue type of a key-value map, or
the value of a K-V entry within such a map.</li>
</ol>
<h3 id="w"><code>w</code></h3>
<ol type="1">
<li>A <a href="https://hackage.haskell.org/package/comonad-5.0.8/docs/Control-Comonad.html#t:Comonad"><code>Comonad</code></a>.
(Mnemonic: a comonad is dual to a monad, and <code>w</code> is an
upside-down <code>m</code>.)</li>
</ol>
<h3 id="x"><code>x</code></h3>
<ol type="1">
<li><p>A type that is ignored, irrelevant, or inaccessible.</p>
<div id="cb18"><pre><code><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span>-- From package `streaming`:</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span>maps ::</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>  (<span>Monad</span> m, <span>Functor</span> f) <span>=&gt;</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>  (<span>forall</span> x<span>.</span> f x <span>-&gt;</span> g x) <span>-&gt;</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>  <span>--      ^-- The function passed in here cannot know anything</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>  <span>--          interesting about `x`, so it is &#34;inaccessible&#34;.</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>  <span>Stream</span> f m r <span>-&gt;</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>  <span>Stream</span> g m r</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a><span>-- From package `streaming`:</span></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a><span>for ::</span></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>  (<span>Monad</span> m, <span>Functor</span> f) <span>=&gt;</span></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>  <span>Stream</span> (<span>Of</span> a) m r <span>-&gt;</span></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>  (a <span>-&gt;</span> <span>Stream</span> f m x) <span>-&gt;</span></span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>  <span>--               ^-- This x is not referenced elsewhere; `for`</span></span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>  <span>--                   discards the result of the substreams.</span></span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a>  <span>Stream</span> f m r</span></code></pre></div></li>
</ol>
<h3 id="x-y-z"><code>x</code>, <code>y</code>, <code>z</code></h3>
<ol type="1">
<li><p>(As values) Arbitrary values about which nothing is known. Often
seen with a suffix <code>s</code> to pluralise the variable and denote a
collection of arbitrary values. Read <code>xs</code>, <code>ys</code>,
<code>zs</code> as “eckses”, “wyes”, and “zeds” (though American readers
may disagree on the final one).</p>
<div id="cb19"><pre><code><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span>map</span><span> ::</span> (a <span>-&gt;</span> b) <span>-&gt;</span> [a] <span>-&gt;</span> [b]</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span>map</span> f list <span>=</span> <span>case</span> list <span>of</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>  [] <span>-&gt;</span> []</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>  <span>-- `x` binds one value from the list head;</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>  <span>-- `xs` binds many values from the list tail.</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>  x<span>:</span>xs <span>-&gt;</span> f x <span>:</span> <span>map</span> f xs</span></code></pre></div></li>
</ol>
<h3 id="underscore"><code>_</code> (Underscore)</h3>
<ol type="1">
<li>(As value) A blank pattern. A pattern that matches anything but
binds no variable to the matched data.</li>
</ol>
<h2 id="thanks">Thanks</h2>
<ul>
<li><p>Thanks to Fraser Tweedale for suggesting that I include type
variables {<code>s</code>, <code>t</code>, <code>a</code>,
<code>b</code>}; type variable <code>k</code> as a polymorphic kind
variable; term variables <code>h</code> and <code>t</code> for head and
tail; term variables <code>k</code> and <code>v</code> for key-value
entries; and <code>_</code> as blank pattern.</p></li>
<li><p>Thanks to <code>/u/gasche</code> on Reddit for reminding me that
<code>p</code> is often used for <code>p</code>redicates and
<code>p</code>ropositions.</p></li>
<li><p>Thanks to <code>/u/maxigit</code> on <a href="https://discourse.haskell.org">discourse.haskell.org</a> for
suggesting <code>e</code>rror, <code>n</code>atural number,
<code>s</code>tate, and <code>t</code>ime.</p></li>
<li><p>Thanks to <code>/u/enobayram</code> on Reddit for also suggesting
<code>n</code>.</p></li>
<li><p>Thanks to <code>/u/rhendric</code> on <a href="https://discourse.haskell.org">discourse.haskell.org</a> for
suggesing <code>w</code> as the type variable for <code>Comonad</code>s,
and that <code>c</code> is used for categories.</p></li>
<li><p>Thanks to <code>/u/danidiaz</code> for reminding me that
<code>c</code> is used for constraint variables.</p></li>
<li><p>Thanks to <code>/u/taejo</code> on Reddit for suggesting an
example from classical mechanics that brings in its own single-character
variables.</p></li>
<li><p>Thanks to Tikhon Jelvis, who suggested expanding some important
context.</p></li>
<li><p>Thanks to <code>jonathrg</code> on HN, who reminded me about
<code>r</code> as <code>r</code>eader.</p></li>
</ul>
</div></div>
  </body>
</html>
