<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.sqlite.org/lang_with.html#outlandish_recursive_query_examples">Original</a>
    <h1>SQLite: Outlandish Recursive Query Examples</h1>
    
    <div id="readability-page-1" class="page"><div>
<div>
<p>
The WITH Clause
</p>
<details>
<summary>Table Of Contents</summary>

</details>
</div>





<p><b><a href="https://elijer.github.io/garden/Creative-Writing/Nano24/syntax/with-clause.html">with-clause:</a></b>
</p>
 


<p>Common Table Expressions or CTEs act like temporary <a href="https://elijer.github.io/garden/Creative-Writing/Nano24/lang_createview.html">views</a> that exist
only for the duration of a single SQL statement.  There are two kinds of
common table expressions: &#34;ordinary&#34; and &#34;recursive&#34;. Ordinary 
common table expressions are helpful for making
queries easier to understand by factoring
subqueries out of the main SQL statement.
Recursive common table expressions
provide the ability to do hierarchical or
recursive queries of trees and graphs, a capability
that is not otherwise available in the SQL language.

</p><p>All common table expressions (ordinary and recursive) are 
created by prepending a WITH clause in front of a <a href="https://elijer.github.io/garden/Creative-Writing/Nano24/lang_select.html">SELECT</a>, <a href="https://elijer.github.io/garden/Creative-Writing/Nano24/lang_insert.html">INSERT</a>, <a href="https://elijer.github.io/garden/Creative-Writing/Nano24/lang_delete.html">DELETE</a>,
or <a href="https://elijer.github.io/garden/Creative-Writing/Nano24/lang_update.html">UPDATE</a> statement.  A single WITH clause can specify one or more
common table expressions, some of which are ordinary and some of which
are recursive.

<a name="ordinarycte"></a>

</p>

<p>An ordinary common table expression works as if it were a <a href="https://elijer.github.io/garden/Creative-Writing/Nano24/lang_createview.html">view</a> that
exists for the duration of a single statement.  Ordinary common table
expressions are useful for factoring out subqueries and making the overall
SQL statement easier to read and understand.

</p><p>A WITH clause can contain ordinary common table expressions even if
it includes the RECURSIVE keyword.  The use of RECURSIVE does not force
common table expressions to be recursive.

<a name="recursivecte"></a>

</p>

<p>A recursive common table expression can be used to write a query that
walks a tree or graph.  A recursive common table expression has the same
basic syntax as an ordinary common table expression, but with the following
additional attributes:

</p><ol>
<li> The &#34;<a href="https://elijer.github.io/garden/Creative-Writing/Nano24/syntax/select-stmt.html">select-stmt</a>&#34; must be a <a href="https://elijer.github.io/garden/Creative-Writing/Nano24/lang_select.html#compound">compound select</a>.  That is to say,
     the CTE body must be two or more individual SELECT statements
     separated by compound operators like UNION, UNION ALL, INTERSECT,
     or EXCEPT.
</li><li> One or more of the individual SELECT statements that make up
     the compound must be
     &#34;recursive&#34;.  A SELECT statement is recursive if
     its FROM clause contains exactly one reference to
     the CTE table (the table named on the left-hand side of the
     AS clause).
</li><li> One or more of the SELECT statements in the compound must be
     non-recursive.
</li><li> All non-recursive SELECT statements must occur before any
     recursive SELECT statements.
</li><li> The recursive SELECT statements must be separated from the
     non-recursive SELECT statements
     and from each other by the UNION or UNION ALL operators.
     If there are two or more recursive SELECT statements, they all must
     be separated from each other using the same operator that separates
     the first recursive SELECT from the last non-recursive SELECT statement.
</li><li> Recursive SELECT statements may not use
     <a href="https://elijer.github.io/garden/Creative-Writing/Nano24/lang_aggfunc.html">aggregate functions</a> or <a href="https://elijer.github.io/garden/Creative-Writing/Nano24/windowfunctions.html">window functions</a>.     
</li></ol>

<p>To put it another way, a recursive common table expression must
look something like the following:

</p><p><b><a href="https://elijer.github.io/garden/Creative-Writing/Nano24/syntax/recursive-cte.html">recursive-cte:</a></b>
</p>
 <div id="x91789db1">
 <p><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 874.291 72.36">
<circle cx="5" cy="17" r="3.6" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></circle>
<polygon points="32,17 20,21 20,12" style="fill:rgb(0,0,0)"></polygon>
<path d="M9,17L26,17" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<path d="M32,32L169,32L169,2L32,2Z" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<text x="100" y="17" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">cte-table-name</text>
<polygon points="192,17 180,21 180,12" style="fill:rgb(0,0,0)"></polygon>
<path d="M169,17L186,17" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<path d="M207,32L211,32A15 15 0 0 0 226 17A15 15 0 0 0 211 2L207,2A15 15 0 0 0 192 17A15 15 0 0 0 207 32Z" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<text x="209" y="17" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">AS</text>
<polygon points="249,17 237,21 237,12" style="fill:rgb(0,0,0)"></polygon>
<path d="M226,17L243,17" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<path d="M264,32A15 15 0 0 0 279 17A15 15 0 0 0 264 2A15 15 0 0 0 249 17A15 15 0 0 0 264 32Z" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<text x="264" y="17" text-anchor="middle" font-weight="bold" fill="rgb(0,0,0)" dominant-baseline="central">(</text>
<polygon points="302,17 291,21 291,12" style="fill:rgb(0,0,0)"></polygon>
<path d="M279,17L296,17" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<path d="M317,32L403,32A15 15 0 0 0 418 17A15 15 0 0 0 403 2L317,2A15 15 0 0 0 302 17A15 15 0 0 0 317 32Z" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<text x="360" y="17" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">initial-select</text>
<polygon points="459,55 448,59 448,50" style="fill:rgb(0,0,0)"></polygon>
<path d="M418,17 L 425,17 Q 433,17 433,32 L 433,40 Q 433,55 443,55 L 454,55" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<path d="M474,70L518,70A15 15 0 0 0 533 55L533,55A15 15 0 0 0 518 39L474,39A15 15 0 0 0 459 55L459,55A15 15 0 0 0 474 70Z" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<text x="496" y="55" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">UNION</text>
<polygon points="556,55 545,59 545,50" style="fill:rgb(0,0,0)"></polygon>
<path d="M533,55L550,55" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<path d="M571,70L586,70A15 15 0 0 0 601 55L601,55A15 15 0 0 0 586 39L571,39A15 15 0 0 0 556 55L556,55A15 15 0 0 0 571 70Z" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<text x="579" y="55" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">ALL</text>
<polygon points="643,17 631,21 631,12" style="fill:rgb(0,0,0)"></polygon>
<path d="M601,55 L 609,55 Q 616,55 616,40 L 616,32 Q 616,17 627,17 L 637,17" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<path d="M658,32L773,32A15 15 0 0 0 788 17A15 15 0 0 0 773 2L658,2A15 15 0 0 0 643 17A15 15 0 0 0 658 32Z" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<text x="715" y="17" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">recursive-select</text>
<polygon points="811,17 800,21 800,12" style="fill:rgb(0,0,0)"></polygon>
<path d="M788,17L805,17" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<path d="M826,32A15 15 0 0 0 841 17A15 15 0 0 0 826 2A15 15 0 0 0 811 17A15 15 0 0 0 826 32Z" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<text x="826" y="17" text-anchor="middle" font-weight="bold" fill="rgb(0,0,0)" dominant-baseline="central">)</text>
<polygon points="864,17 853,21 853,12" style="fill:rgb(0,0,0)"></polygon>
<path d="M841,17L859,17" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<circle cx="868" cy="17" r="3.6" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></circle>
<polygon points="459,17 448,21 448,12" style="fill:rgb(0,0,0)"></polygon>
<path d="M418,17L454,17" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<path d="M474,32L518,32A15 15 0 0 0 533 17A15 15 0 0 0 518 2L474,2A15 15 0 0 0 459 17A15 15 0 0 0 474 32Z" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<text x="496" y="17" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central">UNION</text>
<path d="M533,17L631,17" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
</svg>
</p>
<p><b><a href="https://elijer.github.io/garden/Creative-Writing/Nano24/syntax/cte-table-name.html">cte-table-name:</a></b>
</p>
 
</div>


<p>In the diagram above, <span>initial-select</span> means one or more
non-recursive SELECT statements and <span>recursive-select</span> means
one or more recursive SELECT statements.  The most common case is for there
to be exactly one <span>initial-select</span> and exactly one
<span>recursive-select</span> but more than one of each is allowed.</p>

<p>Call the table named by the <a href="https://elijer.github.io/garden/Creative-Writing/Nano24/syntax/cte-table-name.html">cte-table-name</a> in a recursive
common table expression the &#34;recursive table&#34;.
In the <a href="https://elijer.github.io/garden/Creative-Writing/Nano24/syntax/recursive-cte.html">recursive-cte</a> bubble diagram above, the recursive
table must appear exactly once in the FROM clause of each
top-level SELECT statement in the <span>recursive-select</span>
and must not appear anywhere else in either the
<span>initial-select</span> or the
<span>recursive-select</span>, including subqueries.
The <span>initial-select</span> may be
a <a href="https://elijer.github.io/garden/Creative-Writing/Nano24/lang_select.html#compound">compound select</a>, but it may not include an ORDER BY, LIMIT, or OFFSET.
The <span>recursive-select</span> may also be a <a href="https://elijer.github.io/garden/Creative-Writing/Nano24/lang_select.html#compound">compound select</a> with
the restriction that all elements of that compound must be separated by
the same UNION or UNION ALL operator that separates
<span>initial-select</span> from <span>recursive-select</span>.
The <span>recursive-select</span> is allowed to include an
ORDER BY, LIMIT, and/or OFFSET but may not use
<a href="https://elijer.github.io/garden/Creative-Writing/Nano24/lang_aggfunc.html">aggregate functions</a> or <a href="https://elijer.github.io/garden/Creative-Writing/Nano24/windowfunctions.html">window functions</a>.

</p><p>The ability for the <span>recursive-select</span> to be a compound
was added in <a href="https://elijer.github.io/garden/Creative-Writing/Nano24/releaselog/3_34_0.html">version 3.34.0</a> (2020-12-01).  In earlier versions of
SQLite, the <span>recursive-select</span> could only be a single
simple SELECT statement.</p>

<p>The basic algorithm for computing the content of the recursive table
is as follows:

</p><ol>
<li> Run the <span>initial-select</span> and add the results to a queue.
</li><li> While the queue is not empty:
<ol type="a">
<li> Extract a single row from the queue.
</li><li> Insert that single row into the recursive table
</li><li> Pretend that the single row just extracted is the only
     row in the recursive table and run the recursive-select,
     adding all results to the queue.
</li></ol>
</li></ol>

<p>The basic procedure above may modified by the following additional rules:

</p><ul>
<li><p>
  If a UNION operator connects the <span>initial-select</span> with the
  <span>recursive-select</span>, then only add rows to the queue if 
  no identical row has
  been previously added to the queue.  Repeated rows are discarded before being
  added to the queue even if the repeated rows have already been extracted
  from the queue by the recursion step.  If the operator is UNION ALL,
  then all rows generated by both the <span>initial-select</span> and the
  <span>recursive-select</span> are always added to the queue even if
  they are repeats.
  When determining if a row is repeated, NULL values compare
  equal to one another and not equal to any other value.
</p></li><li><p>
  The LIMIT clause, if present, determines the maximum number of rows that
  will ever be added to the recursive table in step 2b.
  Once the limit is reached, the recursion stops.
  A limit of zero means that no rows are ever added to the
  recursive table, and a negative limit means an unlimited number of rows
  may be added to the recursive table.
</p></li><li><p>
  The OFFSET clause, if it is present and has a positive value N, prevents the
  first N rows from being added to the recursive table.
  The first N rows are still processed
  by the <span>recursive-select</span> — they
  just are not added to the recursive table.  Rows are not counted toward
  fulfilling the LIMIT until all OFFSET rows have been skipped.
</p></li><li><p>
  If an ORDER BY clause is present, it determines the order in which rows
  are extracted from the queue in step 2a.  If there is no ORDER BY clause,
  then the order in which rows are extracted is undefined.  (In the current
  implementation, the queue becomes a FIFO if the ORDER BY clause is omitted,
  but applications should not depend on that fact since it might change.)
</p></li></ul>

<h2 id="recursive_query_examples"><span>3.1. </span>Recursive Query Examples</h2>

<p>The following query returns all integers between 1 and 1000000:

</p><blockquote><pre>WITH RECURSIVE
  cnt(x) AS (VALUES(1) UNION ALL SELECT x+1 FROM cnt WHERE x&lt;1000000)
SELECT x FROM cnt;
</pre></blockquote>

<p>Consider how this query works.  The initial-select
runs first and returns a single row
with a single column &#34;1&#34;.  This one row is added to the queue.  In
step 2a, that one row is extracted from the queue and added to &#34;cnt&#34;.
Then the recursive-select is run in accordance with step 2c generating
a single new row with value &#34;2&#34; to add to the queue.  The queue still
has one row, so step 2 repeats.  The &#34;2&#34; row is extracted and added to the
recursive table by steps 2a and 2b.  Then the row containing 2 is used 
as if it were the complete content of the recursive table and the 
recursive-select is run again, resulting in a row with value &#34;3&#34; being added
to the queue.  This repeats 999999 times until finally at step 2a the
only value on the queue is a row containing 1000000.  That row is
extracted and added to the recursive table.  But this time, the
WHERE clause causes the recursive-select to return no rows, so the
queue remains empty and the recursion stops.

</p><p><b>Optimization note:</b>
In the discussion above, statements like &#34;insert the row into
the recursive table&#34; should be understood conceptually, not literally.
It sounds as if SQLite is accumulating a huge table
containing one million rows, then going back and scanning that table
from top to bottom to generate the result.  What really happens
is that the query optimizer sees that values in the
&#34;cnt&#34; recursive table are only used once.  So as each row is added to
the recursive table, that row is immediately returned as a result of the main
SELECT statement and then discarded.  SQLite does <em>not</em> accumulate
a temporary table containing a million rows.  Very little memory is
needed to run the above example.  However, if the example had used
UNION instead of UNION ALL, then SQLite would have had to keep around
all previously generated content in order to check for duplicates.
For this reason, programmers should strive to use UNION ALL instead
of UNION when feasible.

</p><p>Here is a variation on the previous example:

</p><blockquote><pre>WITH RECURSIVE
  cnt(x) AS (
     SELECT 1
     UNION ALL
     SELECT x+1 FROM cnt
      LIMIT 1000000
  )
SELECT x FROM cnt;
</pre></blockquote>

<p>There are two differences in this variation.  The initial-select is
&#34;SELECT 1&#34; instead of &#34;VALUES(1)&#34;.  But those are just different
syntaxes for saying exactly the same thing.  The other change is that the
recursion is stopped by a LIMIT rather than a WHERE clause.  The use of
LIMIT means that when the one-millionth row is added to the &#34;cnt&#34; table
(and returned by the main SELECT, thanks to the query optimizer)
then the recursion stops immediately regardless of how many rows might be
left in the queue.  On more complex queries, it can sometimes be
difficult to ensure that the WHERE clause will eventually cause the
queue to drain and the recursion to terminate.  But the LIMIT clause will
always stop the recursion.  So it is good practice to always include a
LIMIT clause as a safety if an upper bound on the size of the recursion 
is known.

<a name="rcex2"></a>

</p><h2 id="hierarchical_query_examples"><span>3.2. </span>Hierarchical Query Examples</h2>

<p>Consider a table that describes the members of an organization as
well as the chain-of-command within that organization:

</p><blockquote><pre>CREATE TABLE org(
  name TEXT PRIMARY KEY,
  boss TEXT REFERENCES org,
  height INT,
  -- other content omitted
);
</pre></blockquote>

<p>Every member in the organization has a name, and most members have
a single boss.  (The head of the whole organization has a NULL
&#34;boss&#34; field.) The rows of the &#34;org&#34; table form a tree.

</p><p>Here is a query that computes the average height over everyone
in Alice&#39;s organization, including Alice:

</p><blockquote><pre>WITH RECURSIVE
  works_for_alice(n) AS (
    VALUES(&#39;Alice&#39;)
    UNION
    SELECT name FROM org, works_for_alice
     WHERE org.boss=works_for_alice.n
  )
SELECT avg(height) FROM org
 WHERE org.name IN works_for_alice;
</pre></blockquote>

<p>The next example uses two 
common table expressions in a single WITH clause.  
The following table records a family tree:

</p><blockquote><pre>CREATE TABLE family(
  name TEXT PRIMARY KEY,
  mom TEXT REFERENCES family,
  dad TEXT REFERENCES family,
  born DATETIME,
  died DATETIME -- NULL if still alive
  -- other content
);
</pre></blockquote>

<p>The &#34;family&#34; table is similar to the earlier &#34;org&#34; table except that 
now there are two parents to each member.
We want to know all living ancestors of Alice, from oldest to youngest.
An ordinary common table expression, &#34;parent_of&#34;, is defined first.  That
ordinary CTE is a view that can be used to find all parents of any
individual.  That ordinary CTE is then used in the &#34;ancestor_of_alice&#34;
recursive CTE.  The recursive CTE is then used in the final query:

</p><blockquote><pre>WITH RECURSIVE
  parent_of(name, parent) AS
    (SELECT name, mom FROM family UNION SELECT name, dad FROM family),
  ancestor_of_alice(name) AS
    (SELECT parent FROM parent_of WHERE name=&#39;Alice&#39;
     UNION ALL
     SELECT parent FROM parent_of JOIN ancestor_of_alice USING(name))
SELECT family.name FROM ancestor_of_alice, family
 WHERE ancestor_of_alice.name=family.name
   AND died IS NULL
 ORDER BY born;
</pre></blockquote>

<h2 id="queries_against_a_graph"><span>3.3. </span>Queries Against A Graph</h2>

<p>Suppose you have an undirected graph where each node is
identified by an integer and edges are defined by a table like
this:

</p><blockquote><pre>CREATE TABLE edge(aa INT, bb INT);
CREATE INDEX edge_aa ON edge(aa);
CREATE INDEX edge_bb ON edge(bb);
</pre></blockquote>

<p>The indexes are not required, but they do help performance
for large graphs.
To find all nodes of the graph that are connected to
node 59, use a query similar to the following:

</p><blockquote><pre>WITH RECURSIVE nodes(x) AS (
   SELECT 59
   UNION
   SELECT aa FROM edge JOIN nodes ON bb=x
   UNION
   SELECT bb FROM edge JOIN nodes ON aa=x
)
SELECT x FROM nodes;
</pre></blockquote>

<p>
The <span>initial-select</span> in this case is the simple query
&#34;SELECT 59&#34;.  This establishes the base case.  The
<span>recursive-select</span> consists of the other two
SELECT statements.  The first recursive SELECT follows edges
in the bb-to-aa direction and the second recursive SELECT follows
edges in the aa-to-bb direction.  UNION is used instead of
UNION ALL to prevent the recursion from entering an infinite
loop if the graph contains cycles.
</p>

<p>Here is a real-world example of using a graph query against a
directed graph:
A version control system (VCS) will typically store the evolving
versions of a project as a directed acyclic graph (DAG).  Call each
version of the project a &#34;checkin&#34;.  A single
checkin can have zero or more parents.  Most checkins (except the
first) have a single parent, but in the case of a merge, a checkin
might have two or three or more parents.  A schema to keep track of
checkins and the order in which they occur might look something like
this:

</p><blockquote><pre>CREATE TABLE checkin(
  id INTEGER PRIMARY KEY,
  mtime INTEGER -- timestamp when this checkin occurred
);
CREATE TABLE derivedfrom(
  xfrom INTEGER NOT NULL REFERENCES checkin, -- parent checkin
  xto INTEGER NOT NULL REFERENCES checkin,   -- derived checkin
  PRIMARY KEY(xfrom,xto)
);
CREATE INDEX derivedfrom_back ON derivedfrom(xto,xfrom);
</pre></blockquote>

<p>This graph is acyclic.  And we assume that the mtime of every
child checkin is no less than the mtime of all its parents.  But
unlike the earlier examples, this graph might have multiple paths of
differing lengths between any two checkins.

</p><p>We want to know the twenty most recent ancestors in time (out of
the thousands and thousands of ancestors in the whole DAG) for
checkin &#34;@BASELINE&#34;.  (A query similar to this is used
by the <a href="http://www.fossil-scm.org/">Fossil</a> VCS to
show the N most recent ancestors of a checkin.  For example:
<a href="https://www.sqlite.org/src/timeline?p=trunk&amp;n=30">https://www.sqlite.org/src/timeline?p=trunk&amp;n=30</a>.)

</p><blockquote><pre>WITH RECURSIVE
  ancestor(id,mtime) AS (
    SELECT id, mtime FROM checkin WHERE id=@BASELINE
    UNION
    SELECT derivedfrom.xfrom, checkin.mtime
      FROM ancestor, derivedfrom, checkin
     WHERE ancestor.id=derivedfrom.xto
       AND checkin.id=derivedfrom.xfrom
     ORDER BY checkin.mtime DESC
     LIMIT 20
  )
SELECT * FROM checkin JOIN ancestor USING(id);
</pre></blockquote>

<p>
The &#34;ORDER BY checkin.mtime DESC&#34; term in the recursive-select makes
the query run much faster by preventing it from following
branches that merge checkins
from long ago.  The ORDER BY forces the recursive-select to focus
on the most recent checkins, the ones we want.  Without the ORDER BY
on the recursive-select, one would be forced to compute the complete set of
thousands of ancestors, sort them all by mtime, then take the top twenty.
The ORDER BY essentially sets up a priority queue that
forces the recursive query to look at the most recent ancestors first,
allowing the use of a LIMIT clause to restrict the scope of the
query to just the checkins of interest.

<a name="withorderby"></a>

</p><h2 id="controlling_depth_first_versus_breadth_first_search_of_a_tree_using_order_by"><span>3.4. </span>Controlling Depth-First Versus Breadth-First Search Of a Tree
Using ORDER BY</h2>

<p>An ORDER BY clause on the recursive-select can be used to control
whether the search of a tree is depth-first or breadth-first.  To
illustrate, we will use a variation on the &#34;org&#34; table from an example
above, without the &#34;height&#34; column, and with some real data inserted:

</p><blockquote><pre>CREATE TABLE org(
  name TEXT PRIMARY KEY,
  boss TEXT REFERENCES org
) WITHOUT ROWID;
INSERT INTO org VALUES(&#39;Alice&#39;,NULL);
INSERT INTO org VALUES(&#39;Bob&#39;,&#39;Alice&#39;);
INSERT INTO org VALUES(&#39;Cindy&#39;,&#39;Alice&#39;);
INSERT INTO org VALUES(&#39;Dave&#39;,&#39;Bob&#39;);
INSERT INTO org VALUES(&#39;Emma&#39;,&#39;Bob&#39;);
INSERT INTO org VALUES(&#39;Fred&#39;,&#39;Cindy&#39;);
INSERT INTO org VALUES(&#39;Gail&#39;,&#39;Cindy&#39;);
</pre></blockquote>

<p>Here is a query to show the tree structure in a breadth-first pattern:

</p><blockquote><pre>WITH RECURSIVE
  under_alice(name,level) AS (
    VALUES(&#39;Alice&#39;,0)
    UNION ALL
    SELECT org.name, under_alice.level+1
      FROM org JOIN under_alice ON org.boss=under_alice.name
     ORDER BY 2
  )
SELECT substr(&#39;..........&#39;,1,level*3) || name FROM under_alice;
</pre></blockquote>

<p>The &#34;ORDER BY 2&#34; (which means the same as &#34;ORDER BY under_alice.level+1&#34;)
causes higher levels in the organization chart (with smaller &#34;level&#34; values)
to be processed first, resulting in a breadth-first search.  The output is:

</p><blockquote><pre>Alice
...Bob
...Cindy
......Dave
......Emma
......Fred
......Gail
</pre></blockquote>

<p>But if we change the ORDER BY clause to add the &#34;DESC&#34; modifier, that will
cause lower levels in the organization (with larger &#34;level&#34; values) to be
processed first by the recursive-select, resulting in a depth-first search:

</p><blockquote><pre>WITH RECURSIVE
  under_alice(name,level) AS (
    VALUES(&#39;Alice&#39;,0)
    UNION ALL
    SELECT org.name, under_alice.level+1
      FROM org JOIN under_alice ON org.boss=under_alice.name
     ORDER BY 2 <b>DESC</b>
  )
SELECT substr(&#39;..........&#39;,1,level*3) || name FROM under_alice;
</pre></blockquote>

<p>The output of this revised query is:

</p><blockquote><pre>Alice
...Bob
......Dave
......Emma
...Cindy
......Fred
......Gail
</pre></blockquote>

<p>When the ORDER BY clause is omitted from the recursive-select, the
queue behaves as a FIFO, which results in a breadth-first search.


<a name="mandelbrot"></a>

</p><h2 id="outlandish_recursive_query_examples"><span>3.5. </span>Outlandish Recursive Query Examples</h2>

<p>The following query computes an approximation of the Mandelbrot Set
and outputs the result as ASCII-art:

</p><blockquote><pre>WITH RECURSIVE
  xaxis(x) AS (VALUES(-2.0) UNION ALL SELECT x+0.05 FROM xaxis WHERE x&lt;1.2),
  yaxis(y) AS (VALUES(-1.0) UNION ALL SELECT y+0.1 FROM yaxis WHERE y&lt;1.0),
  m(iter, cx, cy, x, y) AS (
    SELECT 0, x, y, 0.0, 0.0 FROM xaxis, yaxis
    UNION ALL
    SELECT iter+1, cx, cy, x*x-y*y + cx, 2.0*x*y + cy FROM m 
     WHERE (x*x + y*y) &lt; 4.0 AND iter&lt;28
  ),
  m2(iter, cx, cy) AS (
    SELECT max(iter), cx, cy FROM m GROUP BY cx, cy
  ),
  a(t) AS (
    SELECT group_concat( substr(&#39; .+*#&#39;, 1+min(iter/7,4), 1), &#39;&#39;) 
    FROM m2 GROUP BY cy
  )
SELECT group_concat(rtrim(t),x&#39;0a&#39;) FROM a;
</pre></blockquote>

<p>In this query, the &#34;xaxis&#34; and &#34;yaxis&#34; CTEs define the grid of points for
which the Mandelbrot Set will be approximated.  Each row in the
&#34;m(iter,cx,cy,x,y)&#34; CTE means that after &#34;iter&#34; iterations, the Mandelbrot
iteration starting at cx,cy has reached point x,y.  The number of iterations
in this example is limited to 28 (which severely limits the resolution of
the computation, but is sufficient for low-resolution ASCII-art output).
The &#34;m2(iter,cx,cy)&#34; CTE holds the maximum number of iterations reached when
starting at point cx,cy.
Finally, each row in the &#34;a(t)&#34; CTE holds a string 
which is a single line of the output ASCII-art.
The SELECT statement at the end just queries the &#34;a&#34; CTE to
retrieve all lines of ASCII-art, one by one.

</p><p>Running the query above in an SQLite <a href="https://elijer.github.io/garden/Creative-Writing/Nano24/cli.html">command-line shell</a> results
in the following output:

</p><blockquote><pre>                                    ....#
                                   ..#*..
                                 ..+####+.
                            .......+####....   +
                           ..##+*##########+.++++
                          .+.##################+.
              .............+###################+.+
              ..++..#.....*#####################+.
             ...+#######++#######################.
          ....+*################################.
 #############################################...
          ....+*################################.
             ...+#######++#######################.
              ..++..#.....*#####################+.
              .............+###################+.+
                          .+.##################+.
                           ..##+*##########+.++++
                            .......+####....   +
                                 ..+####+.
                                   ..#*..
                                    ....#
                                    +.
</pre></blockquote>

<p>This next query solves a Sudoku puzzle.  The state of the puzzle is
defined by an 81-character string formed by reading entries from the
puzzle box row by row from left to right and then from top to bottom.
Blank squares in the puzzle are denoted by a &#34;.&#34; character.  
Thus the input string:

</p><blockquote>
53..7....6..195....98....6.8...6...34..8.3..17...2...6.6....28....419..5....8..79
</blockquote>

<p>Corresponds to a puzzle like this:

</p><blockquote>
<table>
<tbody><tr><td>5</td><td>3</td><td> </td><td> </td><td>7</td><td> </td><td> </td><td> </td><td>
</td></tr><tr><td>6</td><td> </td><td> </td><td>1</td><td>9</td><td>5</td><td> </td><td> </td><td>
</td></tr><tr><td> </td><td>9</td><td>8</td><td> </td><td> </td><td> </td><td> </td><td>6</td><td>
</td></tr><tr><td>8</td><td> </td><td> </td><td> </td><td>6</td><td> </td><td> </td><td> </td><td>3
</td></tr><tr><td>4</td><td> </td><td> </td><td>8</td><td> </td><td>3</td><td> </td><td> </td><td>1
</td></tr><tr><td>7</td><td> </td><td> </td><td> </td><td>2</td><td> </td><td> </td><td> </td><td>6
</td></tr><tr><td> </td><td>6</td><td> </td><td> </td><td> </td><td> </td><td>2</td><td>8</td><td>
</td></tr><tr><td> </td><td> </td><td> </td><td>4</td><td>1</td><td>9</td><td> </td><td> </td><td>5
</td></tr><tr><td> </td><td> </td><td> </td><td> </td><td>8</td><td> </td><td> </td><td>7</td><td>9
</td></tr></tbody></table>
</blockquote>

<p>This is the query that solves the puzzle:

</p><blockquote><pre>WITH RECURSIVE
  input(sud) AS (
    VALUES(&#39;53..7....6..195....98....6.8...6...34..8.3..17...2...6.6....28....419..5....8..79&#39;)
  ),
  digits(z, lp) AS (
    VALUES(&#39;1&#39;, 1)
    UNION ALL SELECT
    CAST(lp+1 AS TEXT), lp+1 FROM digits WHERE lp&lt;9
  ),
  x(s, ind) AS (
    SELECT sud, instr(sud, &#39;.&#39;) FROM input
    UNION ALL
    SELECT
      substr(s, 1, ind-1) || z || substr(s, ind+1),
      instr( substr(s, 1, ind-1) || z || substr(s, ind+1), &#39;.&#39; )
     FROM x, digits AS z
    WHERE ind&gt;0
      AND NOT EXISTS (
            SELECT 1
              FROM digits AS lp
             WHERE z.z = substr(s, ((ind-1)/9)*9 + lp, 1)
                OR z.z = substr(s, ((ind-1)%9) + (lp-1)*9 + 1, 1)
                OR z.z = substr(s, (((ind-1)/3) % 3) * 3
                        + ((ind-1)/27) * 27 + lp
                        + ((lp-1) / 3) * 6, 1)
         )
  )
SELECT s FROM x WHERE ind=0;
</pre></blockquote>

<p>The &#34;input&#34; CTE defines the input puzzle.
The &#34;digits&#34; CTE defines a table that holds all digits between 1 and 9.
The work of solving the puzzle is undertaken by the &#34;x&#34; CTE.
An entry in x(s,ind) means that the 81-character string &#34;s&#34; is a valid
sudoku puzzle (it has no conflicts) and that the first unknown character
is at position &#34;ind&#34;, or ind==0 if all character positions are filled in.
The goal, then, is to compute entries for &#34;x&#34; with an &#34;ind&#34; of 0.

</p><p>The solver works by adding new entries to the &#34;x&#34; recursive table.
Given prior entries, the recursive-select tries to fill in a single new
position with all values between 1 and 9 that actually work in that
position.  The complicated &#34;NOT EXISTS&#34; subquery is the magic that
figures out whether or not each candidate &#34;s&#34; string is a valid
sudoku puzzle or not.

</p><p>The final answer is found by looking for a string with ind==0.
If the original sudoku problem did not have a unique solution, then
the query will return all possible solutions.  If the original problem
was unsolvable, then no rows will be returned.  In this case, the unique
answer is:

</p><blockquote>
534678912672195348198342567859761423426853791713924856961537284287419635345286179
</blockquote>

<p>The solution was computed in less than 300 milliseconds on a modern
workstation.

<a name="mathint"></a>

</p>

<p>
The &#34;AS MATERIALIZED&#34; and &#34;AS NOT MATERIALIZED&#34; forms of a common table expression
are non-standard SQL syntax copied from PostgreSQL.  Using MATERIALIZED or
NOT MATERIALIZED after the AS keyword provides non-binding hints to the query
planner about how the CTE should be implemented.

</p><p>
If the MATERIALIZED phrase is used, then <span>select-stmt</span> will
be materialized into an ephemeral table that is held in memory or in a
temporary disk file.  That ephemeral table will then be used in place of the
CTE table name whenever the CTE table name appears in the subsequent SQL.
Because the <span>select-stmt</span> is evaluated immediately,
the opportunity to apply optimizations such as
<a href="https://elijer.github.io/garden/Creative-Writing/Nano24/optoverview.html#flattening">query flattening</a> or the <a href="https://elijer.github.io/garden/Creative-Writing/Nano24/optoverview.html#pushdown">push-down optimization</a>, is lost.
This loss of optimization is a feature, not a bug.  Developers are able
to use the MATERIALIZED keyword as an &#34;optimization fence&#34; to more tightly
control the behavior of the SQLite query planner.  SQLite copied the idea of
using MATERIALIZED as an optimization fence from PostgreSQL.

</p><p>
If the NOT MATERIALIZED phrase is used, then <span>select-stmt</span>
is substituted as a subquery in place of every occurrence of the CTE
table name.  Optimizations such as <a href="https://elijer.github.io/garden/Creative-Writing/Nano24/optoverview.html#flattening">flattening</a> and
<a href="https://elijer.github.io/garden/Creative-Writing/Nano24/optoverview.html#pushdown">push-down</a> are then applied to the subquery as if
the subquery had by used in directly.  In spite of its name, the NOT MATERIALIZED
phrase does not prohibit the use of materialization.  The query planner
is still free to implement the subquery using materialization if
it feels that is the best solution.  The true meaning of NOT MATERIALIZED
is closer to &#34;TREAT LIKE ANY ORDINARY VIEW OR SUBQUERY&#34;.  

</p><p>
If neither hint is present, then SQLite is free to choose whatever
implementation strategy it thinks will work best.  This is the recommended
approach.  <i>Do not use the MATERIALIZED or NOT MATERIALIZED keywords on
a common table expression unless you have a compelling reason to do so.</i>

</p><p>
The MATERIALIZED and NOT MATERIALIZED hints are only available in
SQLite version 3.35.0 (2021-03-12) and later.

</p>

<ul>
<li><p>
The WITH clause cannot be used within a <a href="https://elijer.github.io/garden/Creative-Writing/Nano24/lang_createtrigger.html">CREATE TRIGGER</a>.
</p></li><li><p>
The WITH clause must appear at the beginning of a top-level <a href="https://elijer.github.io/garden/Creative-Writing/Nano24/lang_select.html">SELECT</a> statement
or at the beginning of a subquery.  The WITH clause cannot be prepended to
the second or subsequent SELECT statement of a <a href="https://elijer.github.io/garden/Creative-Writing/Nano24/lang_select.html#compound">compound select</a>.
</p></li><li><p>
The SQL:1999 spec requires that the RECURSIVE keyword follow WITH in any
WITH clause that includes a recursive common table expression.  However, for
compatibility with SqlServer and Oracle, SQLite does not enforce this rule.
</p></li></ul>
<p><small><i>This page last modified on  <a href="https://sqlite.org/docsrc/honeypot" id="mtimelink" data-href="https://sqlite.org/docsrc/finfo/pages/lang_with.in?m=5365d4ff94">2024-01-29 11:00:27</a> UTC </i></small></p>

</div></div>
  </body>
</html>
