<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://utcc.utoronto.ca/~cks/space/blog/unix/SignalHandlingOverTime">Original</a>
    <h1>The evolving Unix attitudes on handling signals in your code</h1>
    
    <div id="readability-page-1" class="page"><div><h2>The evolving Unix attitudes on handling signals in your code</h2>

	<p><small>July  2, 2023</small></p>
</div><div><p>Once upon a time, back in <a href="https://utcc.utoronto.ca/~cks/space/blog/unix/RemarkableV7">V7 Unix</a> or so, Unix
signal handling in programs was nominally very simple. You&#39;d set a
signal handler with <a href="https://www.tuhs.org/cgi-bin/utree.pl?file=V7/usr/man/man2/signal.2"><code>signal(2)</code></a>, and
then when it was invoked it would do things, possibly including
using <a href="https://www.tuhs.org/cgi-bin/utree.pl?file=V7/usr/man/man3/setjmp.3"><code>longjmp(3)</code></a> to
pop back to the top level of your programs. Among other examples,
the Bourne shell famously <a href="https://utcc.utoronto.ca/~cks/space/blog/programming/BourneGol">used SIGSEGV as a memory allocation
method</a>. Even today, a lot of programs
behave as if this is the signal handling model in effect; you can
interrupt your shell, or your pager, or various other things with
a Ctrl-C and they&#39;ll act like this, popping back to a top level or
cleanly stopping their current action while still operating in
general (instead of just exiting the way simpler programs do).</p>

<p>In actual reality, even in V7 signal handling could be potentially
chancy. The problem with handling signals in the V7 way is that
they&#39;re interrupts, which means that they can happen at arbitrary
points in program execution. If a signal arrives at the wrong point,
it will interrupt program execution half-way through doing something
that wasn&#39;t designed to be interrupted, for example half way through
doing a <code>malloc()</code> or <code>free()</code>, and then various havoc can ensue.
In V7 I think there weren&#39;t all that many critical points like this
(in the C library or in programs), and in general the possibility
was mostly ignored outside of a few programs that took care to block
signals around their critical operations. If something went wrong,
the person using the program would deal with it.</p>

<p>(This was in general the V7 way; it was a simple operating system
so it had simple implementations that often punted on harder
problems.)</p>

<p>To simplify the story, as Unix grew both programs and the C library
became more complex, with more complex internal operations going
on, and people became less tolerant of flaky programs than they
might have been in a simple research operating system. Eventually
people began to think about threads, and also about standardizing
what signal handlers could legally do as part of <a href="https://en.wikipedia.org/wiki/POSIX">POSIX</a>. This resulted in the current
situation where <a href="https://pubs.opengroup.org/onlinepubs/9699919799/functions/V2_chap02.html#tag_15_04_03">POSIX signal handlers are very constrained in
what they can legally do</a>,
especially in threaded programs. To simplify things, you can call
some C library functions (primarily to interact with the operating
system), or set a flag, and that&#39;s about it. A particular Unix may
go beyond the POSIX requirements to make other things safe in signal
handlers, and programs may break these requirements and still get
away with it most of the time, but today there isn&#39;t much you can
safely do in a signal handler within the C API.</p>

<p>(A non-C language on Unix may or may not have to restrict itself
to the C API behavior in its signal handling, depending on how much
it relies on the C library.)</p>

<p>With effort it&#39;s still possible to write reliable Unix programs
that handle signals and behave as people expect them to. But it&#39;s
not trivial, and in particular it&#39;s not trivial to present an API
to programs so that they can handle signals as if they were on V7,
with their &#39;signal handlers&#39; free to do pretty much anything and
make broad transfers of control without restriction. For a start,
if you offer this API to programs, their signal handlers can&#39;t be
real signal handlers and by extension you need a runtime to catch
the actual signals, set status flags, and then invoke the &#39;signal
handlers&#39; outside of the actual Unix signal delivery.</p>

<p>(This is <a href="https://utcc.utoronto.ca/~cks/space/blog/python/CPythonSignals">how (C)Python handles signals</a>,
for example. I believe that Go on Linux handles signals outside of
the C API, and as part of that manages handling locking and
coordination on its own.)</p>

<p>PS: The POSIX signal handler requirements are also only a promise
about C (POSIX) API functions, not about what functions in your own
program may or may not be safe to call from your signal handlers.
If you manipulate data structures or have internal locking in your
program, or in libraries that you call, interacting with things
safely from within a signal handler is your own responsibility.
POSIX makes no promises.</p>

<p>PPS: I&#39;m not sure if restrictions on what signal handlers should
do were ever written down before POSIX. The 4.3 BSD <a href="https://www.tuhs.org/cgi-bin/utree.pl?file=4.3BSD/usr/man/man2/sigvec.2"><code>sigvec(2)</code></a>
and <a href="https://www.tuhs.org/cgi-bin/utree.pl?file=4.3BSD/usr/man/man3/signal.3c"><code>signal(3)</code></a>
manual pages don&#39;t contain any cautions, for example.</p>

<h3>Sidebar: threads and signals</h3>

<p>Once you introduce threads, many operations in the C library may start
requiring locks. Once you have operations taking locks, it becomes quite
dangerous to call back in to anything related to those locks in a signal
handler. If you get a signal at the wrong time, some thread will attempt
to recursively obtain a lock and then probably deadlock. Introducing
threads to your C library model forces you to think about locks,
deadlocks, and preventing them, and now you can&#39;t hand-wave signal
safety any more.</p>

<p>(Not that you ever could, but threads make it basically impossible
to think you can get away with it, because the failure modes are
so obvious.)</p>

<p>PS: I don&#39;t know how this interacts with POSIX <a href="https://pubs.opengroup.org/onlinepubs/9699919799/functions/sigsetjmp.html"><code>sigsetjmp()</code></a>
and <a href="https://pubs.opengroup.org/onlinepubs/9699919799/functions/siglongjmp.html"><code>siglongjmp()</code></a>,
since <code>siglongjmp()</code> is listed as one of the POSIX functions that&#39;s
safe to call in a signal handler.</p>
</div></div>
  </body>
</html>
