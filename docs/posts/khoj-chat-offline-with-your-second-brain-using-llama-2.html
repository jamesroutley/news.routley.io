<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/khoj-ai/khoj">Original</a>
    <h1>Show HN: Khoj – Chat Offline with Your Second Brain Using Llama 2</h1>
    
    <div id="readability-page-1" class="page"><div><p>I find great joy in using programming languages <em>idiomatically</em>. Following the
conventions and thoroughly using the features of a language helps write
shorter and simpler programs. Compared to using a library, readers of the
program will be more likely to be familiar with the abstractions, and even if
unfamiliar it will be easier to learn about them and more useful due to them
being more applicable.</p>
<p><a href="https://docs.racket-lang.org/guide/for.html">Racket’s iterations and comprehensions</a>
are an excellent example of very powerful abstractions built right into the
language. The <code>for/*</code> forms capture many iteration patterns in a generic and
systematic way. Different <code>for/*</code> forms differ in what they do with the results
of the iteration, but they all take the same options and give them meanings that
make sense for each pattern.</p>
<p>I want to show you an example of using the <code>for/fold</code> form to write a very brief
and readable program. Let’s consider the following problem posed by
<a href="https://cassidoo.co/newsletter/">@cassidoo</a> in her newsletter:</p>
<blockquote>
<p>Given an array where each element is the price of a given stock on that
index’s day, choose a single day to buy a stock and a different day (in the
future/later in the array) to sell the stock to maximize your profit. Return
the maximum profit that you can get from a given input. If you can’t profit,
return 0.</p>
</blockquote>
<p>For example, <code>maximumProfit([7, 1, 5, 3, 6, 4])</code> would return <code>5</code>, because it’s
best to buy on day 2, and sell on day 5, for a profit of 6 - 1 = 5.</p>
<p>Rather than checking every possibility we can use dynamic programming to go over
the array once, keeping track of the best solution so far an seeing if we can
improve it. Something like this:</p>
<pre><code><span>#!/usr/bin/Python</span>

<span>def</span> <span>maximum_profit</span><span>(</span>days<span>)</span><span>:</span>
    <span># By definition, the worst profit is 0</span>
    best_profit <span>=</span> <span>0</span>
    <span># Initially the cheapest you can buy is the day one&#39;s price</span>
    best_price <span>=</span> days<span>[</span><span>0</span><span>]</span>

    <span># For each day</span>
    <span>for</span> price <span>in</span> days<span>:</span>
        <span># You could sell, maybe beating the best profit</span>
        best_profit <span>=</span> <span>max</span><span>(</span>best_profit<span>,</span> price <span>-</span> min_price<span>)</span>
        <span># Or you could buy, if the price is the best so far</span>
        min_price <span>=</span> <span>min</span><span>(</span>best_price<span>,</span> price<span>)</span>

    <span>return</span> best_profit

<span>assert</span> maximum_profit<span>(</span><span>[</span><span>7</span><span>,</span> <span>1</span><span>,</span> <span>5</span><span>,</span> <span>3</span><span>,</span> <span>6</span><span>,</span> <span>4</span><span>]</span><span>)</span> <span>==</span> <span>5</span>
<span>assert</span> maximum_profit<span>(</span><span>[</span><span>2</span><span>,</span> <span>10</span><span>,</span> <span>1</span><span>,</span> <span>8</span><span>]</span><span>)</span> <span>==</span> <span>8</span>
<span>assert</span> maximum_profit<span>(</span><span>[</span><span>1</span><span>]</span><span>)</span> <span>==</span> <span>0</span>
</code></pre>
<p>This Python version relies on an imperative iteration with two side effects
(updating <code>best_profit</code> and updating <code>best_price</code>). Racket is a functional
language so on principle we avoid mutation and iterate by doing recursion.
Here’s a possible version:</p>
<pre><code><span>#lang racket</span>

<span>(</span><span>define</span> <span>(</span><span>max-profit-helper</span> days best-price best-profit<span>)</span>
  <span>(</span><span>cond</span>
    <span>[</span><span>(</span><span>empty?</span> days<span>)</span> best-profit<span>]</span>
    <span>[</span><span>else</span>
     <span>(</span><span>let</span> <span>(</span><span>[</span><span>price</span> <span>(</span><span>first</span> days<span>)</span><span>]</span><span>)</span>
       <span>(</span><span>max-profit-helper</span> <span>(</span><span>rest</span> days<span>)</span>
                          <span>(</span><span>min</span> best-price price<span>)</span>
                          <span>(</span><span>max</span> best-profit <span>(</span><span>-</span> price best-price<span>)</span><span>)</span><span>)</span><span>)</span><span>]</span><span>)</span><span>)</span>

<span>(</span><span>define</span> <span>(</span><span>max-profit%</span> days<span>)</span>
  <span>(</span><span>max-profit-helper</span> days <span>(</span><span>first</span> days<span>)</span> <span>0</span><span>)</span><span>)</span>

<span>(</span><span>println</span> <span>(</span><span>max-profit%</span> <span>&#39;</span><span>(</span><span>7</span> <span>1</span> <span>5</span> <span>3</span> <span>6</span> <span>4</span><span>)</span><span>)</span><span>)</span> <span>; 5</span>
<span>(</span><span>println</span> <span>(</span><span>max-profit%</span> <span>&#39;</span><span>(</span><span>2</span> <span>10</span> <span>1</span> <span>8</span><span>)</span><span>)</span><span>)</span> <span>; 8</span>
<span>(</span><span>println</span> <span>(</span><span>max-profit%</span> <span>&#39;</span><span>(</span><span>1</span><span>)</span><span>)</span><span>)</span> <span>; 0</span>
</code></pre>
<p>It’s a little cumbersome. Compared to the Python version we have to inspect the
recursive function to understand we are iterating over days. And because we
need to keep track of two pieces of state, we need to split the function into a
recursion helper and the function proper.</p>
<p>Recursion is a very general mechanism, but <code>for/*</code> and friends capture more
specific patterns of iteration through a sequence. In our case, the idea of
going through a sequence element by element, accumulating some sort of state,
is the concept of
<a href="https://en.wikipedia.org/wiki/Fold_(higher-order_function)">folding</a>,
and the corresponding Racket iteration is called
<a href="https://docs.racket-lang.org/reference/for.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._for%2Ffold%29%29"><code>for/fold</code></a>.</p>
<p>Rewriting our solution using <code>for/fold</code> looks like:</p>
<pre><code><span>#lang racket</span>

<span>(</span><span>define</span> <span>(</span><span>max-profit</span> days<span>)</span>
  <span>(</span><span>for/fold</span> <span>(</span><span>[</span><span>best-price</span> <span>(</span><span>car</span> days<span>)</span><span>]</span>
             <span>[</span><span>best-profit</span> <span>0</span><span>]</span>
             #:result best-profit<span>)</span>
            <span>(</span><span>[</span><span>price</span> days<span>]</span><span>)</span>
    <span>(</span><span>values</span> <span>(</span><span>min</span> best-price price<span>)</span>
            <span>(</span><span>max</span> best-profit <span>(</span><span>-</span> price best-price<span>)</span><span>)</span><span>)</span><span>)</span><span>)</span>

<span>(</span><span>println</span> <span>(</span><span>max-profit</span> <span>&#39;</span><span>(</span><span>7</span> <span>1</span> <span>5</span> <span>3</span> <span>6</span> <span>4</span><span>)</span><span>)</span><span>)</span> <span>; 5</span>
<span>(</span><span>println</span> <span>(</span><span>max-profit</span> <span>&#39;</span><span>(</span><span>2</span> <span>10</span> <span>1</span> <span>8</span><span>)</span><span>)</span><span>)</span> <span>; 8</span>
<span>(</span><span>println</span> <span>(</span><span>max-profit</span> <span>&#39;</span><span>(</span><span>1</span><span>)</span><span>)</span><span>)</span> <span>; 0</span>
</code></pre>
<p>Which I think is even better than the Python version:</p>
<ol>
<li>The specific iteration pattern is explicitly named (fold).</li>
<li>We can accumulate two values independently (the best price and the best
profit), but only use one as the final result via <code>#:result</code>.</li>
<li>The body of the <code>for/fold</code> is a pure function that performs a single complete
iteration step. Nothing gets updated until the function is complete, so
computing <code>best-price</code> before <code>best-profit</code> does not cause a bug like it
would in the Python version.</li>
</ol>
<p>I encourage you to take a look at the <a href="https://docs.racket-lang.org/guide/for.html">Racket guide on iterations and
comprehensions</a> and to take a look
there first whenever you are considering any sort of iterative or even recursive
process.</p></div></div>
  </body>
</html>
