<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.openmymind.net/Im-Too-Dumb-For-Zigs-New-IO-Interface/">Original</a>
    <h1>I&#39;m too dumb for Zig&#39;s new IO interface</h1>
    
    <div id="readability-page-1" class="page"><article>
  
  
  
<p>You might have heard that Zig 0.15 introduces a new IO interface, with the focus for this release being the new std.Io.Reader and std.Io.Writer types. The old &#34;interfaces&#34; had problems. Like <a href="https://github.com/ziglang/zig/issues/17985">this performance issue</a> that I opened. And it relied on a <a href="https://www.openmymind.net/In-Zig-Whats-a-Writer/">mix of types</a>, which always confused me, and a lot of <code>anytype</code> - which is generally great, but a poor foundation to build an interface on.</p>

<p>I&#39;ve been slowly upgrading my libraries, and I ran into changes to the <code>tls.Client</code> client used by my smtp library. For the life of me, I just don&#39;t understand how it works.</p>

<p>Zig has never been known for its documentation, but if we look at the documentation for <code>tls.Client.init</code>, we&#39;ll find:</p>

<pre><code><span>pub</span> <span>fn</span> <span>init</span><span>(</span>input<span>:</span> <span><span>*</span>std<span>.</span>Io<span>.</span>Reader</span><span>,</span> output<span>:</span> <span><span>*</span>std<span>.</span>Io<span>.</span>Writer</span><span>,</span> options<span>:</span> <span>Options</span><span>)</span> InitError<span>!</span>Client
Initiates a TLS handshake <span>and</span> establishes a TLSv1<span>.</span><span>2</span> <span>or</span> TLSv1<span>.</span><span>3</span> session<span>.</span></code></pre>

<p>So it takes one of these new Readers and a new Writer, along with some options (sneak peak, which aren&#39;t all optional). It doesn&#39;t look like you can just give it a <code>net.Stream</code>, but <code>net.Stream</code> does expose a <code>reader()</code> and <code>writer()</code> method, so that&#39;s probably a good place to start:</p>

<pre><code><span>const</span> stream <span>=</span> <span>try</span> std<span>.</span>net<span>.</span><span>tcpConnectToHost</span><span>(</span>allocator<span>,</span> <span>&#34;www.openmymind.net&#34;</span><span>,</span> <span>443</span><span>)</span><span>;</span>
<span>defer</span> stream<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>

<span>var</span> writer <span>=</span> stream<span>.</span><span>writer</span><span>(</span><span>&amp;</span><span>.</span><span>{</span><span>}</span><span>)</span><span>;</span>
<span>var</span> reader <span>=</span> stream<span>.</span><span>reader</span><span>(</span><span>&amp;</span><span>.</span><span>{</span><span>}</span><span>)</span><span>;</span>

<span>var</span> tls_client <span>=</span> <span>try</span> std<span>.</span>crypto<span>.</span>tls<span>.</span>Client<span>.</span><span>init</span><span>(</span>
  reader<span>.</span><span>interface</span><span>(</span><span>)</span><span>,</span>
  <span>&amp;</span>writer<span>.</span>interface<span>,</span>
  <span>.</span><span>{</span><span>}</span><span>,</span> 
<span>)</span><span>;</span></code></pre>

<p>Note that <code>stream.writer()</code> returns a <code>Stream.Writer</code> and <code>stream.reader()</code> returns a <code>Stream.Reader</code> - those aren&#39;t the types our <code>tls.Client</code> expects. To convert the <code>Stream.Reader</code> to an <code>*std.Io.Reader</code>, we need to call its <code>interface()</code> method. To get a <code>*std.io.Writer</code> from an <code>Stream.Writer</code>, we need the address of its <code>&amp;interface</code> field. This doesn&#39;t seem particularly consistent. Don&#39;t forget that the <code>writer</code> and <code>reader</code> need a stable address. Because I&#39;m trying to get the simplest example working, this isn&#39;t an issue - everything will live on the stack of <code>main</code>. In a real word example, I think it means that I&#39;ll always have to wrap the <code>tls.Client</code> into my own heap-allocated type; giving the writer and reader have a cozy stable home.</p>

<p>Speaking of allocations, you might have noticed that <code>stream.writer</code> and <code>stream.reader</code> take a parameter. It&#39;s the buffer they should use. Buffering is a first class citizen of the new Io interface - who needs composition? The documentation <strong>does</strong> tell me these need to be at least <code>std.crypto.tls.max_ciphertext_record_len</code> large, so we need to fix things a bit:</p>

<pre><code><span>var</span> write_buf<span>:</span> <span><span>[</span>std<span>.</span>crypto<span>.</span>tls<span>.</span>max_ciphertext_record_len<span>]</span><span>u8</span></span> <span>=</span> <span>undefined</span><span>;</span>
<span>var</span> writer <span>=</span> stream<span>.</span><span>writer</span><span>(</span><span>&amp;</span>write_buf<span>)</span><span>;</span>

<span>var</span> read_buf<span>:</span> <span><span>[</span>std<span>.</span>crypto<span>.</span>tls<span>.</span>max_ciphertext_record_len<span>]</span><span>u8</span></span> <span>=</span> <span>undefined</span><span>;</span>
<span>var</span> reader <span>=</span> stream<span>.</span><span>reader</span><span>(</span><span>&amp;</span>read_buf<span>)</span><span>;</span></code></pre>

<p>Here&#39;s where the code stands: </p>

<pre><code><span>const</span> std <span>=</span> <span>@import</span><span>(</span><span>&#34;std&#34;</span><span>)</span><span>;</span>

<span>pub</span> <span>fn</span> <span>main</span><span>(</span><span>)</span> <span><span>!</span><span>void</span></span> <span>{</span>
  <span>var</span> gpa<span>:</span> std<span>.</span>heap<span>.</span><span>DebugAllocator</span><span>(</span><span>.</span><span>{</span><span>}</span><span>)</span> <span>=</span> <span>.</span>init<span>;</span>
  <span>const</span> allocator <span>=</span> gpa<span>.</span><span>allocator</span><span>(</span><span>)</span><span>;</span>

  <span>const</span> stream <span>=</span> <span>try</span> std<span>.</span>net<span>.</span><span>tcpConnectToHost</span><span>(</span>allocator<span>,</span> <span>&#34;www.openmymind.net&#34;</span><span>,</span> <span>443</span><span>)</span><span>;</span>
  <span>defer</span> stream<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>

  <span>var</span> write_buf<span>:</span> <span><span>[</span>std<span>.</span>crypto<span>.</span>tls<span>.</span>max_ciphertext_record_len<span>]</span><span>u8</span></span> <span>=</span> <span>undefined</span><span>;</span>
  <span>var</span> writer <span>=</span> stream<span>.</span><span>writer</span><span>(</span><span>&amp;</span>write_buf<span>)</span><span>;</span>

  <span>var</span> read_buf<span>:</span> <span><span>[</span>std<span>.</span>crypto<span>.</span>tls<span>.</span>max_ciphertext_record_len<span>]</span><span>u8</span></span> <span>=</span> <span>undefined</span><span>;</span>
  <span>var</span> reader <span>=</span> stream<span>.</span><span>reader</span><span>(</span><span>&amp;</span>read_buf<span>)</span><span>;</span>

  <span>var</span> tls_client <span>=</span> <span>try</span> std<span>.</span>crypto<span>.</span>tls<span>.</span>Client<span>.</span><span>init</span><span>(</span>
      reader<span>.</span><span>interface</span><span>(</span><span>)</span><span>,</span>
      <span>&amp;</span>writer<span>.</span>interface<span>,</span>
      <span>.</span><span>{</span>
      <span>}</span><span>,</span>
  <span>)</span><span>;</span>
  <span>defer</span> tls_client<span>.</span><span>end</span><span>(</span><span>)</span> <span>catch</span> <span>{</span><span>}</span><span>;</span>
<span>}</span></code></pre>

<p>But if you try to run it, you&#39;ll get a compilation error. Turns out we have to provide 4 options: the ca_bundle, a host, a <code>write_buffer</code> and a <code>read_buffer</code>. Normally I&#39;d expect the options parameter to be for optional parameters, I don&#39;t understand why some parameters (input and output) are passed one way while <code>writer_buffer</code> and <code>read_buffer</code> are passed another.</p>

<p>Let&#39;s give it what it wants AND send some data:</p>

<pre><code>

<span>var</span> bundle <span>=</span> <span>std<span>.</span>crypto<span>.</span>Certificate<span>.</span>Bundle</span><span>{</span><span>}</span><span>;</span>
<span>try</span> bundle<span>.</span><span>rescan</span><span>(</span>allocator<span>)</span><span>;</span>
<span>defer</span> bundle<span>.</span><span>deinit</span><span>(</span>allocator<span>)</span><span>;</span>

<span>var</span> tls_client <span>=</span> <span>try</span> std<span>.</span>crypto<span>.</span>tls<span>.</span>Client<span>.</span><span>init</span><span>(</span>
  reader<span>.</span><span>interface</span><span>(</span><span>)</span><span>,</span>
  <span>&amp;</span>writer<span>.</span>interface<span>,</span>
  <span>.</span><span>{</span>
    <span>.</span>ca <span>=</span> <span>.</span><span>{</span><span>.</span>bundle <span>=</span> bundle<span>}</span><span>,</span>
    <span>.</span>host <span>=</span> <span>.</span><span>{</span> <span>.</span>explicit <span>=</span> <span>&#34;www.openmymind.net&#34;</span> <span>}</span> <span>,</span>
    <span>.</span>read_buffer <span>=</span> <span>&amp;</span><span>.</span><span>{</span><span>}</span><span>,</span>
    <span>.</span>write_buffer <span>=</span> <span>&amp;</span><span>.</span><span>{</span><span>}</span><span>,</span>
  <span>}</span><span>,</span>
<span>)</span><span>;</span>
<span>defer</span> tls_client<span>.</span><span>end</span><span>(</span><span>)</span> <span>catch</span> <span>{</span><span>}</span><span>;</span>

<span>try</span> tls_client<span>.</span>writer<span>.</span><span>writeAll</span><span>(</span><span>&#34;GET / HTTP/1.1\r\n\r\n&#34;</span><span>)</span><span>;</span></code></pre>

<p>Now, if I try to run it, the program just hangs. I don&#39;t know what <code>write_buffer</code> is, but I know Zig now loves buffers, so let&#39;s try to give it something:</p>

<pre><code>


<span>var</span> write_buf2<span>:</span> <span><span>[</span>std<span>.</span>crypto<span>.</span>tls<span>.</span>max_ciphertext_record_len<span>]</span><span>u8</span></span> <span>=</span> <span>undefined</span><span>;</span>

<span>var</span> tls_client <span>=</span> <span>try</span> std<span>.</span>crypto<span>.</span>tls<span>.</span>Client<span>.</span><span>init</span><span>(</span>
  reader<span>.</span><span>interface</span><span>(</span><span>)</span><span>,</span>
  <span>&amp;</span>writer<span>.</span>interface<span>,</span>
  <span>.</span><span>{</span>
    <span>.</span>ca <span>=</span> <span>.</span><span>{</span><span>.</span>bundle <span>=</span> bundle<span>}</span><span>,</span>
    <span>.</span>host <span>=</span> <span>.</span><span>{</span> <span>.</span>explicit <span>=</span> <span>&#34;www.openmymind.net&#34;</span> <span>}</span> <span>,</span>
    <span>.</span>read_buffer <span>=</span> <span>&amp;</span><span>.</span><span>{</span><span>}</span><span>,</span>
    <span>.</span>write_buffer <span>=</span> <span>&amp;</span>write_buf2<span>,</span>
  <span>}</span><span>,</span>
<span>)</span><span>;</span>
<span>defer</span> tls_client<span>.</span><span>end</span><span>(</span><span>)</span> <span>catch</span> <span>{</span><span>}</span><span>;</span>

<span>try</span> tls_client<span>.</span>writer<span>.</span><span>writeAll</span><span>(</span><span>&#34;GET / HTTP/1.1\r\n\r\n&#34;</span><span>)</span><span>;</span></code></pre>


<p>Great, now the code doesn&#39;t hang, all we need to do is read the response. <code>tls.Client</code> exposes a <code>reader: *std.Io.Reader</code> field which is &#34;Decrypted stream from the server to the client.&#34; That sounds like what we want, but believe it or not <code>std.Io.Reader</code> doesn&#39;t have a <code>read</code> method. It has a <code>peak</code> a <code>takeByteSigned</code>, a <code>readSliceShort</code> (which seems close, but it blocks until the provided buffer is full), a <code>peekArray</code> and a lot more, but nothing like the <code>read</code> I&#39;d expect. The closest I can find, which I think does what I want, is to stream it to a writer:</p>

<pre><code><span>var</span> buf<span>:</span> <span><span>[</span><span>1024</span><span>]</span><span>u8</span></span> <span>=</span> <span>undefined</span><span>;</span>
<span>var</span> w<span>:</span> <span>std<span>.</span>Io<span>.</span>Writer</span> <span>=</span> <span>.</span><span>fixed</span><span>(</span><span>&amp;</span>buf<span>)</span><span>;</span>
<span>const</span> n <span>=</span> <span>try</span> tls_client<span>.</span>reader<span>.</span><span>stream</span><span>(</span><span>&amp;</span>w<span>,</span> <span>.</span><span>limited</span><span>(</span>buf<span>.</span>len<span>)</span><span>)</span><span>;</span>
std<span>.</span>debug<span>.</span><span>print</span><span>(</span><span>&#34;read: {d} - {s}\n&#34;</span><span>,</span> <span>.</span><span>{</span>n<span>,</span> buf<span>[</span><span>0</span><span>..</span>n<span>]</span><span>}</span><span>)</span><span>;</span></code></pre>

<p>If we try to run the code now, it crashes. We&#39;ve apparently failed an assertion regarding the length of a buffer. So it seems like we also <em>have</em> to provide a <code>read_buffer</code>.</p>

<p>Here&#39;s my current version (it doesn&#39;t work, but it doesn&#39;t crash!):</p>

<pre><code><span>const</span> std <span>=</span> <span>@import</span><span>(</span><span>&#34;std&#34;</span><span>)</span><span>;</span>

<span>pub</span> <span>fn</span> <span>main</span><span>(</span><span>)</span> <span><span>!</span><span>void</span></span> <span>{</span>
  <span>var</span> gpa<span>:</span> std<span>.</span>heap<span>.</span><span>DebugAllocator</span><span>(</span><span>.</span><span>{</span><span>}</span><span>)</span> <span>=</span> <span>.</span>init<span>;</span>
  <span>const</span> allocator <span>=</span> gpa<span>.</span><span>allocator</span><span>(</span><span>)</span><span>;</span>

  <span>const</span> stream <span>=</span> <span>try</span> std<span>.</span>net<span>.</span><span>tcpConnectToHost</span><span>(</span>allocator<span>,</span> <span>&#34;www.openmymind.net&#34;</span><span>,</span> <span>443</span><span>)</span><span>;</span>
  <span>defer</span> stream<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>

  <span>var</span> write_buf<span>:</span> <span><span>[</span>std<span>.</span>crypto<span>.</span>tls<span>.</span>max_ciphertext_record_len<span>]</span><span>u8</span></span> <span>=</span> <span>undefined</span><span>;</span>
  <span>var</span> writer <span>=</span> stream<span>.</span><span>writer</span><span>(</span><span>&amp;</span>write_buf<span>)</span><span>;</span>

  <span>var</span> read_buf<span>:</span> <span><span>[</span>std<span>.</span>crypto<span>.</span>tls<span>.</span>max_ciphertext_record_len<span>]</span><span>u8</span></span> <span>=</span> <span>undefined</span><span>;</span>
  <span>var</span> reader <span>=</span> stream<span>.</span><span>reader</span><span>(</span><span>&amp;</span>read_buf<span>)</span><span>;</span>

  <span>var</span> bundle <span>=</span> <span>std<span>.</span>crypto<span>.</span>Certificate<span>.</span>Bundle</span><span>{</span><span>}</span><span>;</span>
  <span>try</span> bundle<span>.</span><span>rescan</span><span>(</span>allocator<span>)</span><span>;</span>
  <span>defer</span> bundle<span>.</span><span>deinit</span><span>(</span>allocator<span>)</span><span>;</span>

  <span>var</span> write_buf2<span>:</span> <span><span>[</span>std<span>.</span>crypto<span>.</span>tls<span>.</span>max_ciphertext_record_len<span>]</span><span>u8</span></span> <span>=</span> <span>undefined</span><span>;</span>
  <span>var</span> read_buf2<span>:</span> <span><span>[</span>std<span>.</span>crypto<span>.</span>tls<span>.</span>max_ciphertext_record_len<span>]</span><span>u8</span></span> <span>=</span> <span>undefined</span><span>;</span>

  <span>var</span> tls_client <span>=</span> <span>try</span> std<span>.</span>crypto<span>.</span>tls<span>.</span>Client<span>.</span><span>init</span><span>(</span>
      reader<span>.</span><span>interface</span><span>(</span><span>)</span><span>,</span>
      <span>&amp;</span>writer<span>.</span>interface<span>,</span>
      <span>.</span><span>{</span>
        <span>.</span>ca <span>=</span> <span>.</span><span>{</span><span>.</span>bundle <span>=</span> bundle<span>}</span><span>,</span>
        <span>.</span>host <span>=</span> <span>.</span><span>{</span> <span>.</span>explicit <span>=</span> <span>&#34;www.openmymind.net&#34;</span> <span>}</span> <span>,</span>
        <span>.</span>read_buffer <span>=</span> <span>&amp;</span>read_buf2<span>,</span>
        <span>.</span>write_buffer <span>=</span> <span>&amp;</span>write_buf2<span>,</span>
      <span>}</span><span>,</span>
  <span>)</span><span>;</span>
  <span>defer</span> tls_client<span>.</span><span>end</span><span>(</span><span>)</span> <span>catch</span> <span>{</span><span>}</span><span>;</span>

  <span>try</span> tls_client<span>.</span>writer<span>.</span><span>writeAll</span><span>(</span><span>&#34;GET / HTTP/1.1\r\n\r\n&#34;</span><span>)</span><span>;</span>

  <span>var</span> buf<span>:</span> <span><span>[</span>std<span>.</span>crypto<span>.</span>tls<span>.</span>max_ciphertext_record_len<span>]</span><span>u8</span></span> <span>=</span> <span>undefined</span><span>;</span>
  <span>var</span> w<span>:</span> <span>std<span>.</span>Io<span>.</span>Writer</span> <span>=</span> <span>.</span><span>fixed</span><span>(</span><span>&amp;</span>buf<span>)</span><span>;</span>
  <span>const</span> n <span>=</span> <span>try</span> tls_client<span>.</span>reader<span>.</span><span>stream</span><span>(</span><span>&amp;</span>w<span>,</span> <span>.</span><span>limited</span><span>(</span>buf<span>.</span>len<span>)</span><span>)</span><span>;</span>
  std<span>.</span>debug<span>.</span><span>print</span><span>(</span><span>&#34;read: {d} - {s}\n&#34;</span><span>,</span> <span>.</span><span>{</span>n<span>,</span> buf<span>[</span><span>0</span><span>..</span>n<span>]</span><span>}</span><span>)</span><span>;</span>
<span>}</span></code></pre>

<p>When I looked through Zig&#39;s source code, there&#39;s <a href="https://github.com/ziglang/zig/blob/306176046e6ae5e30bc58e5f3bcf786159e367f2/lib/std/http/Client.zig#L329">only one place</a> using <code>tls.Client</code>. It helped to get me where where I am. I couldn&#39;t find any tests.</p>

<p>I&#39;ll admit that during this migration, I&#39;ve missed some basic things. For example, someone had to help me find <code>std.fmt.printInt</code> - the renamed version of <code>std.fmt.formatIntBuf</code>. Maybe there&#39;s a helper like: <code>tls.Client.init(allocator, stream)</code> somewhere. And maybe it makes sense that we do <code>reader.interface()</code> but <code>&amp;writer.interface</code> - I&#39;m reminded of Go&#39;s <code>*http.Request</code> and <code>http.ResponseWrite</code>. And maybe Zig has some consistent rule for what parameters belong in options. And I know nothing about TLS, so maybe it makes complete sense to need 4 buffers. I feel a bit more confident about the weirdness of not having a <code>read(buf: []u8) !usize</code> function on <code>Reader</code>, but at this point I wouldn&#39;t bet on me.</p>

</article></div>
  </body>
</html>
