<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://discourse.llvm.org/t/rfc-hardening-mode-for-the-compiler/87660">Original</a>
    <h1>Hardening mode for the compiler</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="text">
              <p>This is a joint proposal from: <a href="https://discourse.llvm.org/u/aaronballman">@AaronBallman</a>, <a href="https://discourse.llvm.org/u/shafik">@shafik</a>, <a href="https://discourse.llvm.org/u/endill">@Endill</a>, and <a href="https://discourse.llvm.org/u/cor3ntin">@cor3ntin</a> (with helpful input from others!)</p>
<p>Safety and security of C and C++ programs has been an important issue in the ecosystem for a while. Both WG21 and WG14 are making plans on how to improve these aspects of the language from their end, but the standard is constrained by what it can talk about and the speed at which it can move. Implementations need to be the driving force behind improving this situation; we’re ultimately responsible for the quality of what we provide our users. To that end, we should seriously consider what the Clang approach to hardening will be.</p>
<p>Thankfully, our implementation already provides a ton of mechanisms to help users improve the safety and security of their code. Unfortunately, those mechanisms are scattered throughout the implementation (some are feature flags, some are machine flags, some are macros, some are warnings, etc), poorly documented or not documented at all, and are not always easy to use. There are <a href="https://best.openssf.org/Compiler-Hardening-Guides/Compiler-Options-Hardening-Guide-for-C-and-C++.html">guides online</a> to help users, but this requires more proactive consideration from users than we think is reasonable.</p>
<p>We’re proposing a path forward to unify a lot of our existing mechanisms in an easy-to-use way for users.</p>
<h2><a name="p-349605-setting-user-expectations-1" href="#p-349605-setting-user-expectations-1"></a>Setting User Expectations</h2>
<p>One difficult decision we frequently face is “will this change break existing code?”. To date, user expectations have been set that we will work hard to avoid breaking their existing, working, correct code. For example, when deciding whether to emit a diagnostic or not, if we cannot prove something is wrong, we will frequently suppress the diagnostic (reduce false positives). However, this is in direct conflict with the needs for safety and security. In that scenario, if we cannot prove something is right, we should generally diagnose the construct (increase false positives). So this mode needs to set user expectations appropriately: your code breaking between compiler releases is a feature, not a bug. Obviously, we still want to strive for a low false positive rate in hardened code; it’s just that we should feel comfortable with rejecting correct, but suspicious, code. This includes a need for potentially ABI breaking changes; when the next spectre vulnerability hits, we want users to get the mitigation automatically rather than having to learn that they need the mitigation at all.</p>
<h2><a name="p-349605-prior-art-in-gcc-2" href="#p-349605-prior-art-in-gcc-2"></a>Prior Art in GCC</h2>
<p>GCC has added a <code>-fhardened</code> mode (<a href="https://gcc.gnu.org/onlinedocs/gcc-15.1.0/gcc/Instrumentation-Options.html#index-fhardened">Instrumentation Options (Using the GNU Compiler Collection (GCC))</a>). This mode enables several feature flags (<code>-ftrivial-auto-var-init</code>, <code>-fstack-protector-strong</code>, etc) and predefines some macros (<code>_FORTIFY_SOURCE=3</code>, <code>_GLIBCXX_ASSERTIONS</code>). It does not currently modify any diagnostic behavior or set any machine flags.</p>
<p>We could follow GCC’s lead and do exactly as they do and add <code>-fhardened</code> which aims for compatibility with GCC. However, we do not recommend aiming for an identical implementation between Clang and GCC. Differences in behavior between the two compilers already makes matching features difficult. When it comes to omnibus options, it becomes even harder. So we will likely never behave the same as GCC anyway – better to set user expectations up front that Clang and GCC hardening aim to solve the same problem, but may do so in different ways sometimes.</p>
<h2><a name="p-349605-goals-3" href="#p-349605-goals-3"></a>Goals</h2>
<p>We want to enable various <code>-f</code>, <code>-m</code>, <code>-D</code>, and <code>-W</code> flags in this hardened mode, but we do not want users to have to manually figure out the set to enable. So we’re looking to add some one-shot way for the user to enable various flags, for example:</p>
<ul>
<li>It can enable various <code>-f</code> flags by default: <code>-ftrivial-auto-var-init</code>, <code>-fPIE</code>, <code>-fcf-protection</code>, etc.</li>
<li>It can enable various <code>-m</code> flags by default: <code>-mspeculative-load-hardening</code>, <code>-mlvi-hardening</code>, etc.</li>
<li>It can enable various <code>-W</code> flags by default: <code>-Wall</code>, <code>-Wextra</code>, <code>-Werror=return-type</code>, etc.</li>
<li>It can enable any hardening modes available for the standard library</li>
<li>It can predefine various macros: <code>_FORTIFY_SOURCE</code>, <code>_GLIBCXX_ASSERTIONS</code>, etc.</li>
<li>It can require the user to specify an explicit language standard mode</li>
<li>It can refuse to compile code against older language standards we feel are inherently unsafe, like C89 or C++98</li>
<li>It can pass along linker flags like enabling ASLR</li>
</ul>
<p>The exact flags and behaviors can be determined as we go and can be extended as we introduce new functionality or diagnostics into the compiler.</p>
<h2><a name="p-349605-proposal-4" href="#p-349605-proposal-4"></a>Proposal</h2>
<p>There are multiple ways we could surface this functionality. We’re presenting options to see what direction the community thinks will best meet the goals outlined. Other alternatives may also exist which are worth considering.</p>
<h4><a name="p-349605-config-file-5" href="#p-349605-config-file-5"></a>Config File</h4>
<p>A configuration file could be shipped alongside Clang. Users would set the hardened mode by passing <code>--config=hardened</code> (or some other single flag that effectively translates into <code>–config</code> under the hood). A benefit of this approach is that maintenance of hardened mode is very easy and downstreams can modify the behavior easily to meet their own needs.</p>
<h4><a name="p-349605-driver-6" href="#p-349605-driver-6"></a>Driver</h4>
<p>By using a new driver mode, we reset user expectations about how compiler upgrades will go. They’re no longer running <code>clang</code>, it’s now a “different” compiler. The significant downside to a new driver is that it can be a challenge to integrate it into existing build systems like CMake. However, <code>clang --driver-mode=</code> can still be used as a stopgap solution until build systems catch up.</p>
<h4><a name="p-349605-orthogonal-flags-7" href="#p-349605-orthogonal-flags-7"></a>Orthogonal Flags</h4>
<p>We could have orthogonal <code>-fhardened</code>, <code>-mhardened</code>, and <code>-Whardened</code> options to specify language dialect flags and macros, machine flags, and diagnostic flags respectively. It’s not a single flag for a user to pass to get all the hardening, but it does let the user have an a la carte approach to opting into hardening.</p>
<h4><a name="p-349605-single-flag-8" href="#p-349605-single-flag-8"></a>Single Flag</h4>
<p>We could have a single flag such as <code>-fhardened</code> which enables all the macros, language dialect, machine, and diagnostic options so that we have a single flag for users to opt into everything. However, it would be a novel direction; we don’t have any other flags with such wide-reaching impacts across <code>-f</code>, <code>-m</code>, <code>-W</code>, etc behaviors. Also, if we name the flag <code>-fhardened</code>, there will be pressure to be compatible across GCC and Clang, which is a burden on both communities, so if we go with a single flag, we should pick a unique name for it.</p>
<h2><a name="p-349605-what-are-we-deciding-right-now-9" href="#p-349605-what-are-we-deciding-right-now-9"></a>What Are We Deciding Right Now?</h2>
<p>We are looking for high-level direction from the community on how to proceed. Once we know that the community supports the notion of a hardened mode, and we know the general shape of how the community wants that mode surfaced, we intend to come back with a separate proposal for that particular path forward as well as the initial set of functionality enabled by that mode.</p>
            </div></div>
  </body>
</html>
