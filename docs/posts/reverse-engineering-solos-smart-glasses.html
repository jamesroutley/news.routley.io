<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jfloren.net/b/2025/8/28/0">Original</a>
    <h1>Reverse engineering Solos smart glasses</h1>
    
    <div id="readability-page-1" class="page"><div>


<p>First and foremost: If you’ve got any documentation on this hardware, please contact me! I would love to read the actual specs for this protocol.</p>

<h2>Background</h2>

<p>Before the audio-only AI-based smart glasses of today, we’d periodically see companies announcing smart glasses with <em>displays</em>, usually to small fanfare and little success. The Solos Smart Glasses are just another example. Released in 2018, they targeted <a href="https://www.menshealth.com/technology-gear/a20212746/solos-smart-glasses-review/">cyclists and runners</a>. The company itself was spun out of Kopin, which has been making micro-displays for electronic viewfinder and military/industrial HUDs for decades. They cost $500 at time of release and weren’t much of a success, as far as I can tell.</p>

<p>Because they weren’t a big hit, I was able to get a new-in-box pair for <a href="https://www.ebay.com/itm/286568369068">$30 shipped on ebay</a>. Now, Solos is still making smart glasses, although they’ve pivoted to audio-only AI glasses like everyone else in the world. I emailed support asking for documentation, but they played all cagey (wouldn’t want to tell somebody how to use a product you dropped 7 years ago) and wouldn’t do more than give me the APK for the companion app.</p>

<p><img src="https://jfloren.net/content/solos/glass1.jpeg" alt=""/></p>

<p>I played with the app on a bike ride. As you see in the review I linked above, the glasses cycle through several screens of information as you ride, in a way which I found pretty usable. It also does navigation, but bitrot appears to have set in… it was constantly convinced I had left the route and needed a new route calculated, then when I reached the destination it said “you have arrived” over and over until I shut it down.</p>

<p>Yes, you can remove the slightly goofy yellow plastic lenses:</p>

<p><img src="https://jfloren.net/content/solos/glass2.jpeg" alt=""/></p>

<p>Anyway, I don’t really need a wearable bike computer, so I started trying to figure out how I could hack these. Why am I interested? Because I’m interested in displays for wearable computing, and these are both cheap and <em>wireless</em>.</p>

<h2>Bluetooth capture</h2>

<p>I guessed that the glasses probably didn’t run a lot of software on-board but instead received bitmaps or vector graphics from the smartphone app via Bluetooth. Luckily, you can <a href="https://source.android.com/docs/core/connect/bluetooth/verifying_debugging">capture Bluetooth traffic in Android</a>:</p>

<ol>
<li>Enable developer options on the phone.</li>
<li>In the developer options menu, turn on “Enable Bluetooth HCI snoop log”</li>
<li>Restart Bluetooth, connect the device, do some stuff.</li>
<li>Turn off Bluetooth, turn offf the snoop log option.</li>
<li>Plug in to your computer via USB, enable USB debugging on the phone, run <code>adb bugreport android_bugreport</code></li>
<li>Unzip resulting <code>android_bugreport.zip</code> and look at <code>android_bugreport/data/misc/bluetooth/logs</code>; there should be a file you can open in Wireshark.</li>
</ol>

<h2>Analysis</h2>

<p>After a little poking around, I spotted a likely-looking pattern. The phone would send a big packet beginning with 1d60, then several more packets, then a small pause, then another sequence beginning with 1d60:</p>

<p><img src="https://jfloren.net/content/solos/wireshark.png" alt=""/></p>

<p>I found that if I saved these payloads to a text file, I could actually use a little Python script to replay them over Bluetooth and the glasses would indeed re-display what I’d seen before! Ok, clearly there’s image data in there somewhere.</p>

<p>I isolated the first hundred-ish bytes of one of these sequences and started to look closely:</p>

<pre><code>1d60050000001c4c000002000000010000000000ac01f000ff0000ad0000ff0000ad0000ff0000ad0000ff0000ad0000ff00
</code></pre>

<p>The first thing that stands out is the repeated sequence in the latter half, <code>ff0000ad0000</code>. The pattern actually repeated quite a few times more, then started to change. The output I had seen was a black screen with colored text &amp; simple diagrams on it, so I made the assumption that <code>0000</code> represented the color black. I created a new packet with the same header but repeated <code>ff5555adcccc</code> instead, and saw teal on the left side of the screen and orange on the right. With a little more examination, it became clear that <code>ff0000</code> means “255 pixels of 0x0000 (black)” and <code>ad0000</code> means “173 pixels of 0x0000”. It’s Run-Length Encoding that specifies how many pixels and then an RGB 5:6:5 (little-endian) color.</p>

<p>Examining the header, I believe it breaks down like this:</p>

<ul>
<li><code>1d60</code>: magic number indicating the beginning of a command.</li>
<li><code>05000000</code>: unclear, probably selects a drawing mode. I also saw <code>0a00</code>, <code>0240</code>, and <code>0310</code> but those didn’t have the same sort of pixel data following.</li>
<li>`<code>1c4c0000</code>: a little-endian representation of the number of bytes of RLE-encoded image data which will follow this header. The weird thing is this only works properly if I divide the actual length by two…</li>
<li><code>02000000010</code>: unclear, but this was the same on all packets with RLE data had the same value here.</li>
<li><code>00000000</code>: I believe this is an x,y offset to indicate where to start drawing. All zeroes means start at the top-left, but it seems that the app likes to draw a status bar w/ time and battery level at the top, then refresh a smaller box lower down to show the gauges. I saw values like <code>45001200</code> in other packets, which would be an offset of 69,18.</li>
<li><code>ac01f000</code>: The x,y dimensions of the RLE data to follow, in this case 0x01ac (428) by 0x00f0 (240) which is the resolution of the display.</li>
</ul>

<p>The one thing I’m left scratching my head over is the length field. If I have 0x20 bytes of image data to send over, I actually need to put 0x10 into that field. What I saw in the packet capture was that they would send e.g. 0x20, then re-transmit the exact same sequence of packets twice. I don’t know exactly why.</p>

<h2>Driving the display</h2>

<p>After some experimentation, I came up with the following Python script, which will read any number of 428x240 image files (specified as command line arguments), RLE-encode them, and ship to the device with a 2 second pause between each:</p>

<pre><code>import bluetooth
import binascii
import time
from PIL import Image
import sys

def get_rle(inputfile):
    img = Image.open(inputfile).convert(mode=&#34;RGB&#34;,dither=Image.Dither.NONE)

    count = 0
    last = &#34;&#34;
    s = &#34;&#34;
    for y in range(240):
        for x in range(428):
            red, green, blue = img.getpixel((x, y))
            red = red &gt;&gt; 3
            green = green &gt;&gt; 2
            blue = blue &gt;&gt; 3
            rgb16 = ((red &lt;&lt; 11) | (green &lt;&lt; 5) | blue)
            color = (0xffff &amp; rgb16).to_bytes(2, &#39;little&#39;).hex()
            if last == &#34;&#34;:
                last = color
            if (last != color) or count == 0xff:
                v = f&#39;{count:02x}{last}&#39;
                s = s + v
                count = 0
            last = color
            count = count + 1
    return s

bd_addr=&#34;cc:78:ab:59:6a:2b&#34;
port = 1
sock=bluetooth.BluetoothSocket(bluetooth.RFCOMM)
sock.connect((bd_addr, port))

for arg in sys.argv[1:]:
    # get the image string
    img = get_rle(arg)
    # break it up into chunks for shipping over bluetooth
    chunk_size=900
    imgchunks = [ img[i:i+chunk_size] for i in range(0, len(img), chunk_size) ]
    for index, chunk in enumerate(imgchunks):
        if index == 0:
            length=(len(img)//2).to_bytes(4, &#39;little&#39;).hex()
            print(length)
            chunk = f&#39;1d6005000000{length}02000000010000000000ac01f000&#39; + chunk
        sock.send(binascii.unhexlify(chunk))
    time.sleep(2)
</code></pre>

<p>(I do not claim to be a great Python programmer)</p>

<p>I shipped over a simple image showing the current conditions at home:</p>

<p><img src="https://jfloren.net/content/solos/display1.png" alt=""/></p>

<p>Then I tried loading up an actual photo. It takes a bit to send this much data over, but it looks surprisingly good:</p>

<p><img src="https://jfloren.net/content/solos/display2.png" alt=""/></p>

<p>If you wanted to do something useful, you could just run <code>while true; python client.py /tmp/hud/*.png; sleep 1; done</code> and have cron scripts generating images that get dropped into <code>/tmp/hud</code>.</p>

<h2>Conclusion and next steps</h2>

<p>I’ve got the device displaying arbitrary images. This alone is enough to show useful information: subject lines of emails, weather forecast, up/down status of services on my home network, etc. I just have to get pipelines set up to generate images displaying those things and push them over in some sensible order. The simple bash loop I showed above would actually be a great start to this!</p>

<p>The best part is, it’s all nondestructive: as soon as I pair the glasses to my phone again, I can open up the app and use it on a bike ride or a run.</p>

<p>The device also includes a microphone and speakers, which could be a useful addition to a wearable system (although I’m quite happy with wearing a single Bluetooth earbud for microphone/speakers right now). When I paired the glasses to my laptop, audio devices didn’t show up, but they act like regular headphones on my Android device, meaning there’s probably a command I need to send to turn them on.</p>

</div></div>
  </body>
</html>
