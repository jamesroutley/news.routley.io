<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://nickdrozd.github.io/2021/11/17/binary-relations-in-idris.html">Original</a>
    <h1>Binary Relations in Idris</h1>
    
    <div id="readability-page-1" class="page"><div aria-label="Content">
      <div>
        <article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    <p>Every <strong>natural number</strong> is either zero or the successor of some number. In <strong>Idris</strong> this is expressed as a <strong>type</strong>:</p>

<figure><pre><code data-lang="haskell"><span>data</span> <span>Nat</span> <span>=</span> <span>Z</span> <span>|</span> <span>S</span> <span>Nat</span></code></pre></figure>

<p>Given two numbers <em>m</em> and <em>n</em>, <strong><em>m ≤ n</em></strong> (that is, <em>m</em> is less than or equal to <em>n</em>) either when <em>m</em> is zero or when <em>m</em> is the successor of <em>j</em> and <em>n</em> is the successor of <em>k</em> and <em>j ≤ k</em>. This is again expressed in Idris as a type:</p>

<figure><pre><code data-lang="haskell"><span>data</span> <span>LTE</span>  <span>:</span> <span>(</span><span>m</span><span>,</span> <span>n</span> <span>:</span> <span>Nat</span><span>)</span> <span>-&gt;</span> <span>Type</span> <span>where</span>
  <span>LTEZero</span> <span>:</span> <span>LTE</span> <span>Z</span> <span>n</span>
  <span>LTESucc</span> <span>:</span> <span>LTE</span> <span>j</span> <span>k</span> <span>-&gt;</span> <span>LTE</span> <span>(</span><span>S</span> <span>j</span><span>)</span> <span>(</span><span>S</span> <span>k</span><span>)</span></code></pre></figure>

<p>≤ is the classic example of a <strong>binary relation</strong>. In type theory a binary relation is a function of type <code>ty -&gt; ty -&gt; Type</code>. This is not to be confused with <strong>binary operation</strong>, which is a function of type <code>ty -&gt; ty -&gt; ty</code>. Binary operations produce instances of some type, but binary relations produce things that are themselves types. In spirit a binary relation is similar to a function of type <code>ty -&gt; ty -&gt; Bool</code>; it is a <strong>proposition</strong> that “says” something that may or may not be true.</p>

<p>Certain common properties are used to classify binary relations and describe their behavior. For example, ≤ is <strong>reflexive</strong>: <em>x ≤ x</em> for all <em>x</em>. It is also <strong>transitive</strong> and <strong>antisymmetric</strong>: if <em>x ≤ y</em> and <em>y ≤ z</em> then <em>x ≤ z</em>; and <em>x ≤ y</em> and <em>y ≤ x</em> only when <em>x = y</em>.</p>

<p>In idris these properties are expressed with <strong>interfaces</strong>:</p>

<figure><pre><code data-lang="haskell"><span>interface</span> <span>Reflexive</span> <span>ty</span> <span>rel</span> <span>where</span>
  <span>reflexive</span> <span>:</span> <span>{</span><span>x</span> <span>:</span> <span>ty</span><span>}</span> <span>-&gt;</span> <span>rel</span> <span>x</span> <span>x</span>

<span>interface</span> <span>Transitive</span> <span>ty</span> <span>rel</span> <span>where</span>
  <span>transitive</span> <span>:</span> <span>{</span><span>x</span><span>,</span> <span>y</span><span>,</span> <span>z</span> <span>:</span> <span>ty</span><span>}</span> <span>-&gt;</span> <span>rel</span> <span>x</span> <span>y</span> <span>-&gt;</span> <span>rel</span> <span>y</span> <span>z</span> <span>-&gt;</span> <span>rel</span> <span>x</span> <span>z</span>

<span>interface</span> <span>Antisymmetric</span> <span>ty</span> <span>rel</span> <span>where</span>
  <span>antisymmetric</span> <span>:</span> <span>{</span><span>x</span><span>,</span> <span>y</span> <span>:</span> <span>ty</span><span>}</span> <span>-&gt;</span> <span>rel</span> <span>x</span> <span>y</span> <span>-&gt;</span> <span>rel</span> <span>y</span> <span>x</span> <span>-&gt;</span> <span>x</span> <span>=</span> <span>y</span></code></pre></figure>

<p>Implementing these interfaces for a relation over some type <strong>verifies</strong> that the relation bears those properties. Sometimes this is difficult, and sometimes it’s easy:</p>

<figure><pre><code data-lang="haskell"><span>Reflexive</span> <span>Nat</span> <span>LTE</span> <span>where</span>
  <span>reflexive</span> <span>{</span><span>x</span> <span>=</span> <span>Z</span><span>}</span> <span>=</span> <span>LTEZero</span>
  <span>reflexive</span> <span>{</span><span>x</span> <span>=</span> <span>S</span> <span>k</span><span>}</span> <span>=</span> <span>LTESucc</span> <span>$</span> <span>reflexive</span> <span>{</span><span>x</span> <span>=</span> <span>k</span><span>}</span>

<span>Transitive</span> <span>Nat</span> <span>LTE</span> <span>where</span>
  <span>transitive</span> <span>LTEZero</span> <span>_</span> <span>=</span> <span>LTEZero</span>
  <span>transitive</span> <span>(</span><span>LTESucc</span> <span>xy</span><span>)</span> <span>(</span><span>LTESucc</span> <span>yz</span><span>)</span> <span>=</span>
    <span>LTESucc</span> <span>$</span> <span>transitive</span> <span>{</span><span>rel</span> <span>=</span> <span>LTE</span><span>}</span> <span>xy</span> <span>yz</span>

<span>Antisymmetric</span> <span>Nat</span> <span>LTE</span> <span>where</span>
  <span>antisymmetric</span> <span>LTEZero</span> <span>LTEZero</span> <span>=</span> <span>Refl</span>
  <span>antisymmetric</span> <span>(</span><span>LTESucc</span> <span>xy</span><span>)</span> <span>(</span><span>LTESucc</span> <span>yx</span><span>)</span> <span>=</span>
    <span>cong</span> <span>S</span> <span>$</span> <span>antisymmetric</span> <span>xy</span> <span>yx</span></code></pre></figure>

<p>A <strong>preorder</strong> is a relation that is both reflexive and transitive, and a <strong>partial order</strong> is a preorder that is antisymmetric:</p>

<figure><pre><code data-lang="haskell"><span>interface</span> <span>(</span><span>Reflexive</span> <span>ty</span> <span>rel</span><span>,</span> <span>Transitive</span> <span>ty</span> <span>rel</span><span>)</span> <span>=&gt;</span> <span>Preorder</span> <span>ty</span> <span>rel</span> <span>where</span>

<span>interface</span> <span>(</span><span>Preorder</span> <span>ty</span> <span>rel</span><span>,</span> <span>Antisymmetric</span> <span>ty</span> <span>rel</span><span>)</span> <span>=&gt;</span> <span>PartialOrder</span> <span>ty</span> <span>rel</span> <span>where</span></code></pre></figure>

<p>These order properties are <strong>empty</strong> – just definitions that <strong>bundle together other properties</strong>. Consequently they are easy to implement:</p>

<figure><pre><code data-lang="haskell"><span>Preorder</span> <span>Nat</span> <span>LTE</span> <span>where</span>

<span>PartialOrder</span> <span>Nat</span> <span>LTE</span> <span>where</span></code></pre></figure>

<p>A slightly more complicated property is <em>connexity</em>. A relation is <strong>connex</strong> over a type if any two distinct instances of the type are related one way or another, and a <strong>linear order</strong> is a connex partial order:</p>

<figure><pre><code data-lang="haskell"><span>interface</span> <span>Connex</span> <span>ty</span> <span>rel</span> <span>where</span>
  <span>connex</span> <span>:</span> <span>{</span><span>x</span><span>,</span> <span>y</span> <span>:</span> <span>ty</span><span>}</span> <span>-&gt;</span> <span>Not</span> <span>(</span><span>x</span> <span>=</span> <span>y</span><span>)</span> <span>-&gt;</span> <span>Either</span> <span>(</span><span>rel</span> <span>x</span> <span>y</span><span>)</span> <span>(</span><span>rel</span> <span>y</span> <span>x</span><span>)</span>

<span>interface</span> <span>(</span><span>PartialOrder</span> <span>ty</span> <span>rel</span><span>,</span> <span>Connex</span> <span>ty</span> <span>rel</span><span>)</span> <span>=&gt;</span> <span>LinearOrder</span> <span>ty</span> <span>rel</span> <span>where</span></code></pre></figure>

<p>≤ is connex over the naturals, but this is <strong>trickier to prove</strong> than the other properties:</p>

<figure><pre><code data-lang="haskell"><span>Connex</span> <span>Nat</span> <span>LTE</span> <span>where</span>
  <span>connex</span> <span>{</span><span>x</span> <span>=</span> <span>Z</span><span>}</span> <span>_</span> <span>=</span> <span>Left</span> <span>LTEZero</span>
  <span>connex</span> <span>{</span><span>y</span> <span>=</span> <span>Z</span><span>}</span> <span>_</span> <span>=</span> <span>Right</span> <span>LTEZero</span>
  <span>connex</span> <span>{</span><span>x</span> <span>=</span> <span>S</span> <span>_</span><span>}</span> <span>{</span><span>y</span> <span>=</span> <span>S</span> <span>_</span><span>}</span> <span>prf</span> <span>=</span>
    <span>case</span> <span>connex</span> <span>{</span><span>rel</span> <span>=</span> <span>LTE</span><span>}</span> <span>$</span> <span>prf</span> <span>.</span> <span>(</span><span>cong</span> <span>S</span><span>)</span> <span>of</span>
      <span>Left</span> <span>jk</span> <span>=&gt;</span> <span>Left</span> <span>$</span> <span>LTESucc</span> <span>jk</span>
      <span>Right</span> <span>kj</span> <span>=&gt;</span> <span>Right</span> <span>$</span> <span>LTESucc</span> <span>kj</span>

<span>LinearOrder</span> <span>Nat</span> <span>LTE</span> <span>where</span></code></pre></figure>

<p>≤ is antisymmetric: <em>x ≤ y</em> implies <em>y ≤ x</em> only when <em>y = x</em>. A relation is <strong>symmetric</strong> when it goes both ways unconditionally:</p>

<figure><pre><code data-lang="haskell"><span>interface</span> <span>Symmetric</span> <span>ty</span> <span>rel</span> <span>where</span>
  <span>symmetric</span> <span>:</span> <span>{</span><span>x</span><span>,</span> <span>y</span> <span>:</span> <span>ty</span><span>}</span> <span>-&gt;</span> <span>rel</span> <span>x</span> <span>y</span> <span>-&gt;</span> <span>rel</span> <span>y</span> <span>x</span></code></pre></figure>

<p>A simple example of a symmetric relation is the relation of <strong>being-within-one-of</strong>:</p>

<figure><pre><code data-lang="haskell"><span>WithinOneOf</span> <span>:</span> <span>(</span><span>a</span><span>,</span> <span>b</span> <span>:</span> <span>Nat</span><span>)</span> <span>-&gt;</span> <span>Type</span>
<span>WithinOneOf</span> <span>a</span> <span>b</span> <span>=</span> <span>Either</span> <span>(</span><span>a</span> <span>=</span> <span>b</span><span>)</span> <span>$</span> <span>Either</span> <span>(</span><span>a</span> <span>=</span> <span>S</span> <span>b</span><span>)</span> <span>(</span><span>b</span> <span>=</span> <span>S</span> <span>a</span><span>)</span></code></pre></figure>

<p>If <em>x</em> is within one of <em>y</em>, then <em>y</em> is within one of <em>x</em>. Further, <em>x</em> is within one of <em>x</em> for all <em>x</em>:</p>

<figure><pre><code data-lang="haskell"><span>Reflexive</span> <span>Nat</span> <span>WithinOneOf</span> <span>where</span>
  <span>reflexive</span> <span>=</span> <span>Left</span> <span>Refl</span>

<span>Symmetric</span> <span>Nat</span> <span>WithinOneOf</span> <span>where</span>
  <span>symmetric</span> <span>(</span><span>Left</span> <span>x_eq_y</span><span>)</span> <span>=</span> <span>Left</span> <span>$</span> <span>sym</span> <span>x_eq_y</span>
  <span>symmetric</span> <span>(</span><span>Right</span> <span>$</span>  <span>Left</span> <span>prf</span><span>)</span> <span>=</span> <span>Right</span> <span>$</span> <span>Right</span> <span>prf</span>
  <span>symmetric</span> <span>(</span><span>Right</span> <span>$</span> <span>Right</span> <span>prf</span><span>)</span> <span>=</span> <span>Right</span> <span>$</span>  <span>Left</span> <span>prf</span></code></pre></figure>

<p>A relation that is both reflexive and symmetric is a <strong>tolerance relation</strong>:</p>

<figure><pre><code data-lang="haskell"><span>interface</span> <span>(</span><span>Reflexive</span> <span>ty</span> <span>rel</span><span>,</span> <span>Symmetric</span> <span>ty</span> <span>rel</span><span>)</span> <span>=&gt;</span> <span>Tolerance</span> <span>ty</span> <span>rel</span> <span>where</span>

<span>Tolerance</span> <span>Nat</span> <span>WithinOneOf</span> <span>where</span></code></pre></figure>

<p>The within-one-of relation is not transitive. 2 is within one of 3 and 4 is within one of 3, but 2 is not within one of 4. A tolerance relation that is transitive is an <strong>equivalence relation</strong>. This could also be defined as a symmetric preorder. Or even better, forget about the <strong>hierarchy</strong> altogether and define an equivalence relation directly as a bundle of reflexive, transitive, and symmetric:</p>

<figure><pre><code data-lang="haskell"><span>interface</span> <span>(</span><span>Reflexive</span> <span>ty</span> <span>rel</span><span>,</span> <span>Transitive</span> <span>ty</span> <span>rel</span><span>,</span> <span>Symmetric</span> <span>ty</span> <span>rel</span><span>)</span> <span>=&gt;</span> <span>Equivalence</span> <span>ty</span> <span>rel</span> <span>where</span>

<span>Equivalence</span> <span>ty</span> <span>rel</span> <span>=&gt;</span> <span>Preorder</span> <span>ty</span> <span>rel</span> <span>where</span>

<span>Equivalence</span> <span>ty</span> <span>rel</span> <span>=&gt;</span> <span>Tolerance</span> <span>ty</span> <span>rel</span> <span>where</span></code></pre></figure>

<p>Let <em>p</em> be a <strong>factor</strong> of <em>q</em> and let <em>q</em> be factor of <em>r</em>. Is <em>p</em> a factor of <em>r</em>? Yes, and therefore the is-a-factor-of relation is transitive. It’s also reflexive and antisymmetric, and so the relation is another example of a partial order. All of these claims can be proved in Idris, although it <strong>takes some work</strong>:</p>

<figure><pre><code data-lang="haskell"><span>data</span> <span>Factor</span> <span>:</span> <span>Nat</span> <span>-&gt;</span> <span>Nat</span> <span>-&gt;</span> <span>Type</span> <span>where</span>
    <span>CofactorExists</span> <span>:</span> <span>{</span><span>p</span><span>,</span> <span>n</span> <span>:</span> <span>Nat</span><span>}</span> <span>-&gt;</span> <span>(</span><span>q</span> <span>:</span> <span>Nat</span><span>)</span> <span>-&gt;</span> <span>n</span> <span>=</span> <span>p</span> <span>*</span> <span>q</span> <span>-&gt;</span> <span>Factor</span> <span>p</span> <span>n</span>

<span>Reflexive</span> <span>Nat</span> <span>Factor</span> <span>where</span>
  <span>reflexive</span> <span>=</span> <span>CofactorExists</span> <span>1</span> <span>$</span> <span>rewrite</span> <span>multOneRightNeutral</span> <span>x</span> <span>in</span> <span>Refl</span>

<span>Transitive</span> <span>Nat</span> <span>Factor</span> <span>where</span>
  <span>transitive</span> <span>(</span><span>CofactorExists</span> <span>qb</span> <span>prfAB</span><span>)</span> <span>(</span><span>CofactorExists</span> <span>qc</span> <span>prfBC</span><span>)</span> <span>=</span>
    <span>CofactorExists</span> <span>(</span><span>qb</span> <span>*</span> <span>qc</span><span>)</span> <span>$</span>
        <span>rewrite</span> <span>prfBC</span> <span>in</span>
        <span>rewrite</span> <span>prfAB</span> <span>in</span>
        <span>rewrite</span> <span>multAssociative</span> <span>x</span> <span>qb</span> <span>qc</span> <span>in</span>
        <span>Refl</span>

<span>Preorder</span> <span>Nat</span> <span>Factor</span> <span>where</span>

<span>-- Proofs elided because they are boring and complicated...</span>
<span>multOneSoleNeutral</span> <span>:</span> <span>(</span><span>a</span><span>,</span> <span>b</span> <span>:</span> <span>Nat</span><span>)</span> <span>-&gt;</span> <span>S</span> <span>a</span> <span>=</span> <span>S</span> <span>a</span> <span>*</span> <span>b</span> <span>-&gt;</span> <span>b</span> <span>=</span> <span>1</span>
<span>oneSoleFactorOfOne</span> <span>:</span> <span>(</span><span>a</span> <span>:</span> <span>Nat</span><span>)</span> <span>-&gt;</span> <span>Factor</span> <span>a</span> <span>1</span> <span>-&gt;</span> <span>a</span> <span>=</span> <span>1</span>

<span>Antisymmetric</span> <span>Nat</span> <span>Factor</span> <span>where</span>
  <span>antisymmetric</span> <span>{</span><span>x</span> <span>=</span> <span>Z</span><span>}</span> <span>(</span><span>CofactorExists</span> <span>_</span> <span>prfAB</span><span>)</span> <span>_</span> <span>=</span> <span>sym</span> <span>prfAB</span>
  <span>antisymmetric</span> <span>{</span><span>y</span> <span>=</span> <span>Z</span><span>}</span> <span>_</span> <span>(</span><span>CofactorExists</span> <span>_</span> <span>prfBA</span><span>)</span> <span>=</span> <span>prfBA</span>
  <span>antisymmetric</span> <span>{</span><span>x</span> <span>=</span> <span>S</span> <span>a</span><span>}</span> <span>{</span><span>y</span> <span>=</span> <span>S</span> <span>_</span><span>}</span> <span>(</span><span>CofactorExists</span> <span>qa</span> <span>prfAB</span><span>)</span> <span>(</span><span>CofactorExists</span> <span>qb</span> <span>prfBA</span><span>)</span> <span>=</span>
      <span>let</span> <span>qIs1</span> <span>=</span> <span>multOneSoleNeutral</span> <span>a</span> <span>(</span><span>qa</span> <span>*</span> <span>qb</span><span>)</span> <span>$</span>
              <span>rewrite</span> <span>multAssociative</span> <span>(</span><span>S</span> <span>a</span><span>)</span> <span>qa</span> <span>qb</span> <span>in</span>
              <span>rewrite</span> <span>sym</span> <span>prfAB</span> <span>in</span>
              <span>prfBA</span>
      <span>in</span>
      <span>rewrite</span> <span>prfAB</span> <span>in</span>
      <span>rewrite</span> <span>oneSoleFactorOfOne</span> <span>qa</span> <span>.</span> <span>CofactorExists</span> <span>qb</span> <span>$</span> <span>sym</span> <span>qIs1</span> <span>in</span>
      <span>rewrite</span> <span>multOneRightNeutral</span> <span>a</span> <span>in</span>
      <span>Refl</span>

<span>PartialOrder</span> <span>Nat</span> <span>Factor</span> <span>where</span></code></pre></figure>

<p>Reflexivity, transitivity, and symmetry are the most prominent properties of binary relations. A lesser-known property is <em>density</em>: a relation is <strong>dense</strong> if between any two related elements there is a third related element:</p>

<figure><pre><code data-lang="haskell"><span>interface</span> <span>Dense</span> <span>ty</span> <span>rel</span> <span>where</span>
  <span>dense</span> <span>:</span> <span>{</span><span>x</span><span>,</span> <span>y</span> <span>:</span> <span>ty</span><span>}</span> <span>-&gt;</span> <span>rel</span> <span>x</span> <span>y</span> <span>-&gt;</span> <span>(</span><span>z</span> <span>:</span> <span>ty</span> <span>**</span> <span>(</span><span>rel</span> <span>x</span> <span>z</span><span>,</span> <span>rel</span> <span>z</span> <span>y</span><span>))</span></code></pre></figure>

<p><strong>Every reflexive relation is dense</strong>: if <em>x</em> is related to <em>y</em>, then by reflexivity <em>x</em> is related to <em>x</em>, and so <em>x</em> itself serves as the intercalated element:</p>

<figure><pre><code data-lang="haskell"><span>Reflexive</span> <span>ty</span> <span>rel</span> <span>=&gt;</span> <span>Dense</span> <span>ty</span> <span>rel</span> <span>where</span>
  <span>dense</span> <span>{</span><span>x</span><span>}</span> <span>xy</span> <span>=</span> <span>(</span><span>x</span> <span>**</span> <span>(</span><span>reflexive</span> <span>{</span><span>x</span><span>},</span> <span>xy</span><span>))</span></code></pre></figure>

<p>So ≤ is technically dense, but that doesn’t mean much. The strictly-less-than relation <strong>&lt;</strong> is not dense over the natural numbers: <em>3 &lt; 4</em>, but there is no <em>x</em> such that <em>3 &lt; x</em> and <em>x &lt; 4</em>. But it is dense over the <strong>rational numbers</strong>: if <em>a/b &lt; c/d</em>, then <em>a+c/b+d</em> comes between them.</p>

<p>A relation such that <em>x</em> being related to <em>y</em> and also to <em>z</em> implies that <em>y</em> is related to <em>z</em> is called <strong>Euclidean</strong>:</p>

<figure><pre><code data-lang="haskell"><span>interface</span> <span>Euclidean</span> <span>ty</span> <span>rel</span> <span>where</span>
  <span>euclidean</span> <span>:</span> <span>{</span><span>x</span><span>,</span> <span>y</span><span>,</span> <span>z</span> <span>:</span> <span>ty</span><span>}</span> <span>-&gt;</span> <span>rel</span> <span>x</span> <span>y</span> <span>-&gt;</span> <span>rel</span> <span>x</span> <span>z</span> <span>-&gt;</span> <span>rel</span> <span>y</span> <span>z</span></code></pre></figure>

<p>Euclideanness is commonly listed as a property of relations, but <strong>examples are hard to come by</strong>. The <a href="https://en.wikipedia.org/wiki/Euclidean_relation">Wikipedia page for Euclidean relations</a> doesn’t list any! Still, a few general properties can be proved. If a Euclidean relation is reflexive, it is also symmetric; and if it is reflexive, it is also transitive. Finally, a relation that is both transitive and symmetric is Euclidean:</p>

<figure><pre><code data-lang="haskell"><span>[</span><span>RES</span><span>]</span> <span>(</span><span>Reflexive</span> <span>ty</span> <span>rel</span><span>,</span> <span>Euclidean</span> <span>ty</span> <span>rel</span><span>)</span> <span>=&gt;</span> <span>Symmetric</span> <span>ty</span> <span>rel</span> <span>where</span>
  <span>symmetric</span> <span>{</span><span>x</span><span>}</span> <span>xy</span> <span>=</span>
    <span>euclidean</span> <span>{</span><span>x</span><span>}</span> <span>xy</span> <span>$</span> <span>reflexive</span> <span>{</span><span>x</span><span>}</span>

<span>[</span><span>RET</span><span>]</span> <span>(</span><span>Reflexive</span> <span>ty</span> <span>rel</span><span>,</span> <span>Euclidean</span> <span>ty</span> <span>rel</span><span>)</span> <span>=&gt;</span>
      <span>Transitive</span> <span>ty</span> <span>rel</span> <span>using</span> <span>RES</span> <span>where</span>
  <span>transitive</span> <span>{</span><span>rel</span><span>}</span> <span>xy</span> <span>yz</span> <span>=</span>
    <span>symmetric</span> <span>{</span><span>rel</span><span>}</span> <span>$</span> <span>euclidean</span> <span>{</span><span>rel</span><span>}</span> <span>yz</span> <span>$</span> <span>symmetric</span> <span>{</span><span>rel</span><span>}</span> <span>xy</span>

<span>[</span><span>TSE</span><span>]</span> <span>(</span><span>Transitive</span> <span>ty</span> <span>rel</span><span>,</span> <span>Symmetric</span> <span>ty</span> <span>rel</span><span>)</span> <span>=&gt;</span> <span>Euclidean</span> <span>ty</span> <span>rel</span> <span>where</span>
  <span>euclidean</span> <span>{</span><span>rel</span><span>}</span> <span>xy</span> <span>xz</span> <span>=</span>
    <span>transitive</span> <span>{</span><span>rel</span><span>}</span> <span>(</span><span>symmetric</span> <span>{</span><span>rel</span><span>}</span> <span>xy</span><span>)</span> <span>xz</span></code></pre></figure>

<p>As of <strong>v0.5</strong>, all of these relations and more are included in the <strong><a href="https://github.com/idris-lang/Idris2/blob/main/libs/base/Control/Relation.idr">Idris 2 standard library</a></strong>. I authored the current design. Earlier version of Idris used a different relation module with fewer relations and an inflexible hierarchy of order relations.</p>

  </div>
</article>

      </div>
    </div></div>
  </body>
</html>
