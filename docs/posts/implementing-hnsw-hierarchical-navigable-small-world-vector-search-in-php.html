<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://centamori.com/index.php?slug=hierarchical-navigable-small-world-hnsw-php&amp;lang=en">Original</a>
    <h1>Implementing HNSW (Hierarchical Navigable Small World) Vector Search in PHP</h1>
    
    <div id="readability-page-1" class="page"><article>
    
<p><strong>Or: How to find a needle in a haystack without checking all the hay</strong></p>
<p>In the <a href="https://centamori.com/index.php?slug=dungeons-dragons-vector-search">previous article</a> we saw how <strong>vectors</strong> can help find the right information simply by describing the concept we want to find.</p>
<p>We used <strong>Cosine Similarity</strong> to compare our request with <em>all</em> available documents, scanning them one by one until we found those with the highest similarity. Does this approach work? <em>Yes.</em> Is it fast? <em>Sort of....</em></p>
<p>Imagine if a librarian, to find your book, had to read the titles of <strong>all 10 million volumes</strong> in a National Library. Even if they spent one millisecond per book, it would take hours. This is the problem of linear search ($O(N)$).</p>
<p>To solve this problem, we introduce a concept that will transform that search from hours to milliseconds: <strong>HNSW</strong> (Hierarchical Navigable Small World).</p>
<h2 id="small-worlds-and-highways">Small worlds and highways</h2>
<p>Let&#39;s use an analogy to better understand the solution HNSW proposes: <strong>How do we find a specific point in a huge city if we come from very far away and don&#39;t know the direction?</strong></p>
<p>Simple: in real life, we use a hierarchy of roads. That is, we start from a &#34;broad&#34; view of the map and subsequently &#34;zoom in&#34; towards the point of interest. Expressing this with an algorithm, we would:</p>
<ol>
<li>Take the <strong>highway</strong> to get close to the region.</li>
<li>Exit onto the <strong>state road</strong> to reach the city.</li>
<li>Take the <strong>main streets</strong> for the neighborhood.</li>
<li>Finally, use the <strong>side streets</strong> to find the house number.</li>
</ol>
<p>HNSW does exactly this with data. It builds a layered structure (Layers) where the higher levels are like highways (few points, long connections) and the lower levels are neighborhood streets (all points, short connections).</p>
<p><img src="https://centamori.com/content/images/hnsw-display-1.png" alt=""/></p>
<h2 id="the-code">The Code</h2>
<p>Let&#39;s analyze how to implement this logic in PHP. The code we will examine comes from the open source project <a href="https://github.com/centamiv/vektor" target="_blank" rel="nofollow noopener noreferrer">Vektor</a>, a small service I built that allows for native vector search in PHP.</p>
<p>Technical note: In addition to <code>$ef</code>, there is a crucial parameter called <code>$M</code>. Imagine it as the maximum number of roads that can start from an intersection. The higher <code>$M</code> is, the more connected the city is, but the more memory our map will occupy.</p>
<h3 id="the-descent-to-level-0">The descent to Level 0</h3>
<p>The main logic is in the <code>search</code> method, which we see below. Imagine looking at a satellite map and progressively zooming in. We start from the global view (the nodes of the highest level).</p>
<pre><code>public function search(array $queryVector, int $k, int $ef): array
{
    // Start from the highest level (e.g. Level 3)
    $entryPoint = $this-&gt;readHeader();

    // Calculate the initial distance, i.e., compare the Level 3 object with the search target
    $currObj = $entryPoint;
    $currDist = Math::cosineSimilarity($queryVector, $this-&gt;getVector($currObj));

    // Now progressively descend from high levels down to level 1
    // The for loop starts from the max level and repeats until we reach Level 1
    for ($lc = $maxLevel; $lc &gt;= 1; $lc--) {

        // Navigate within the current level until we find the closest point
        while (true) {
            $changed = false;

            // Read the neighbors of the current node at this level
            $node = $this-&gt;readNode($currObj);
            $neighbors = $node[&#39;connections&#39;][$lc] ?? [];

            // Search if there is a neighbor that is CLOSER to our target
            foreach ($neighbors as $neighborId) {
                $dist = Math::cosineSimilarity($queryVector, $this-&gt;getVector($neighborId));
                if ($dist &gt; $currDist) {
                    $currDist = $dist;
                    $currObj = $neighborId;
                    $changed = true; // We found a better point!
                }
            }

            // If there were no changes in choosing the best node,
            // it means we are already at the closest possible point 
            // in this level, so we can &#34;descend&#34; to the lower level
            if (!$changed) break;
        }

        // Now $currObj is set with the starting point for the lower level ($lc - 1)
    }

    // At the end of the loop we will be at Level 0 and $currObj will contain the closest point!
}</code></pre>
<p>This cycle is the equivalent of identifying the area of interest from above, moving towards the point closest to the destination, and then increasing the detail. Repeat until we are at the maximum detail level (Level 1).</p>
<h3 id="precision-search-level-0">Precision Search (Level 0)</h3>
<p>Once we arrive at Level 0, where <em>all</em> the data resides, a single point is no longer enough. We want the <strong>K</strong> best results. This is where the <code>$ef</code> (Construction/Search Size) parameter comes into play.</p>
<p><code>$ef</code> is the size of our &#34;candidate list&#34;. The higher the number, the more nodes we evaluate, and the more precise (and slow) the search will be.</p>
<p>The <code>searchLayer</code> method adopts a <strong>Greedy</strong> approach: at each step, the algorithm makes the locally optimal choice, moving towards the neighbor that maximizes similarity with the query. Instead of exploring every possible path, the algorithm &#34;follows the gradient&#34; towards the target. The <strong>Priority Queue</strong> manages this process, allowing us to explore the most promising nodes first and stop the search as soon as new candidates stop improving our list of best results ($ef$).</p>
<pre><code>public function searchLayer(int $entryPoint, array $queryVector, int $ef, int $level, ?int $k = null): array
{
    $visited = [$entryPoint =&gt; true];
    $candidates = new SplPriorityQueue(); // Promising nodes to explore

    $winners = [$entryPoint =&gt; $entrySim]; // Best results found so far (Winner list)

    while (!$candidates-&gt;isEmpty()) {
        $c = $candidates-&gt;extract(); // Take the best candidate

        // If the best candidate is worse than the worst of our current &#34;winners&#34;
        // and we have already filled the list ($ef), we can stop.
        // It&#39;s useless to explore further, we are moving away.
        if ($cSim &lt; $worstSim &amp;&amp; count($winners) &gt;= $ef) {
            break;
        }

        // Explore the candidate&#39;s neighbors
        $node = $this-&gt;readNode($c);
        $neighbors = $node[&#39;connections&#39;][$level] ?? [];

        foreach ($neighbors as $neighborId) {
            if (!isset($visited[$neighborId])) {
                $visited[$neighborId] = true;

                // For each neighbor, calculate its similarity with the target query
                $sim = Math::cosineSimilarity($queryVector, $this-&gt;getVector($neighborId));

                // If this neighbor is promising, add it to candidates
                if ($sim &gt; $worstSim || count($winners) &lt; $ef) {
                    $candidates-&gt;insert($neighborId, $sim);
                    $winners[$neighborId] = $sim;

                    // Keep the winner list W at a fixed size $ef
                    if (count($winners) &gt; $ef) {
                        asort($winners);
                        $idToRemove = array_key_first($winners); // Remove the worst
                        unset($winners[$idToRemove]);

                        // Update the &#34;worst acceptable&#34; threshold
                        asort($winners);
                        $worstSim = $winners[array_key_first($winners)];
                    }
                }
            }
        }
    }

    // ... return the top K elements from the $winners list ...
}</code></pre>
<h2 id="why-is-it-fast">Why is it fast?</h2>
<p>Let&#39;s go back to the library example.</p>
<ul>
<li>In <strong>Linear Search</strong>, the librarian checks every book. $O(N)$ operations.</li>
<li>In <strong>HNSW</strong>, the librarian looks at the &#34;Science&#34; section (Level 2), then goes to the &#34;Astronomy&#34; shelf (Level 1), and finally checks only the 50 books on that shelf (Level 0). $O(\log N)$ operations.</li>
</ul>
<p>On a dataset of 1 million objects, instead of making 1,000,000 comparisons, we might make only 500 or 1,000. It&#39;s a difference of orders of magnitude.</p>
<h2 id="building-the-map">Building the map</h2>
<p>So far we have taken for granted that these &#34;highways&#34; and &#34;neighborhood streets&#34; already exist. But how are they built? The genius of HNSW lies in the fact that the map is drawn dynamically, one point at a time.</p>
<p>When we need to insert a new piece of data (a vector) into our index, we have to decide two things:</p>
<ol>
<li><strong>Which zone is it in?</strong> (Max level)</li>
<li><strong>Who are its neighbors?</strong></li>
</ol>
<p>For the first question, HNSW relies on chance. It&#39;s like <strong>flipping a coin</strong> (or more technically, using an exponential probability distribution).
Most points will end up at <strong>Level 0</strong> (the residential neighborhood). Some lucky ones will win a &#34;ticket&#34; to <strong>Level 1</strong> (the state roads). Very few &#34;chosen ones&#34; will reach the highest levels (the highways). This ensures that the upper levels remain uncluttered and fast to traverse.</p>
<p>For the second question, <strong>we use the search seen previously to also perform the insertion.</strong></p>
<p>If our new point has been assigned to Level 1:</p>
<ol>
<li>We start from the absolute highest level (e.g. Level 3).</li>
<li>We look for the closest point to our newcomer (using the logic of <code>searchLayer</code> seen before).</li>
<li>We go down to the level below and repeat, until we reach the assigned level (Level 1).</li>
<li>Here we stop and <strong>connect</strong> the new point to its nearest neighbors (based on the parameter <code>$M</code>, the maximum number of connections).</li>
</ol>
<p>Basically, every new citizen who arrives in the city asks for directions to find their area, and once arrived, makes friends with the neighbors most similar to them. If a neighbor has too many friends, they cut ties with the least similar one to make room for the newcomer. It is this process of <em>natural selection</em> of connections that keeps the graph efficient and navigable.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Implementing HNSW from scratch is a fundamental exercise to understand how modern vector databases like Qdrant or Pinecone work. We are not just &#34;searching for data&#34;, we are navigating a multidimensional space using probabilistic shortcuts.</p>
<p>These algorithms are the basis of modern recommendation systems (&#34;Users who bought this also saw....&#34;) and RAG (Retrieval Augmented Generation) systems for artificial intelligence, allowing relevant context to be found in fractions of a second.</p>
<p>If you want to dive deeper into the complete implementation, check out the Vektor <a href="https://github.com/centamiv/vektor" target="_blank" rel="nofollow noopener noreferrer">https://github.com/centamiv/vektor</a> repository on GitHub.</p></article></div>
  </body>
</html>
