<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://moerner.com/posts/for-historical-reasons-go-string-int-conversion/">Original</a>
    <h1>&#34;For Historical Reasons&#34;: Go String and Int Conversion</h1>
    
    <div id="readability-page-1" class="page"><div>
      

<article>
  <header>
    

    
    <p><time>Nov 25, 2024</time>
      
      
      
      
    </p>
    
  </header>

  <section><p>Damilola Israel Oluwole and I have started learning Go, and decided to play
around with the language to write a toy implementation of <a href="https://en.wikipedia.org/wiki/Run-length_encoding">Run-length
encoding</a>. While working on
this little project we ran into a corner case with Go type conversion, which
turns out to be documented in the Go spec but neither of us were aware of.</p>
<p>Run-length encoding is a simple lossless text compression algorithm which
encodes each sequence of <em>n</em> identical characters <em>c</em> into the substring “cn”.
For example, “Hello” is encoded as “H1e1l2o1”, and “AAAAAAAAAAH” is encoded as
“A10H1”. Obviously in the worst case, a string with no adjacent identical
characters, an RLE encoding of a string of length <em>n</em> requires length <em>2n</em>.
However, in the best case, a string which consists of a single sequence of a
single character, the encoded length scales as the <del>square root</del> log of the
original length. (Thank you to Charles Eckman for the correction!) Our
implementation can be found on Github: <a href="https://github.com/dmoerner/go-rle">https://github.com/dmoerner/go-rle</a>.</p>
<p>But in this blog post I want to briefly cover something that tripped us up. We
store the result in a rune slice, and then keep track of the last character
written and the sequential count of such counters. We then load a
new character into a buffer, and if it’s distinct from the current sequence, we
append the count and then the new character to the result slice, and restart
the count. Here is a naive way to do this:</p>
<div><pre tabindex="0"><code data-lang="go"><span><span><span>if</span> <span>buffer</span> <span>!=</span> <span>last</span> {
</span></span><span><span>    <span>result</span> = append(<span>result</span>, rune(<span>count</span>)) <span>// critical line
</span></span></span><span><span><span></span>    <span>result</span> = append(<span>result</span>, <span>buffer</span>)
</span></span><span><span>    <span>last</span> = <span>buffer</span>
</span></span><span><span>    <span>count</span> = <span>1</span>
</span></span><span><span>}
</span></span></code></pre></div><p>However, this does not work, and nor should we expect it to. In Go, a rune is
an integer encoding a Unicode code point. Our <code>count</code> variable is not a
representation of a Unicode code point, it’s an integer. Converting a count
representing 65 letters to a rune with <code>rune()</code> will result in the Unicode code
point <code>0x41</code>, the letter ‘A’, which is not our intention.</p>
<p>Fortunately we realized this quite quickly, and I thought that we could solve
it by first converting the count into a string literal, and then converting
that into a proper rune slice. This can then be appended using a spread:</p>
<div><pre tabindex="0"><code data-lang="go"><span><span>    <span>result</span> = append(<span>result</span>, <span>rune</span>[](string(<span>count</span>))<span>...</span>)
</span></span></code></pre></div><p>However, this produces the same result! What’s appended is the Unicode code
point represented by <code>count</code>. What’s worse, we were mostly testing with small
test cases. It turns out that the lowest Unicode Characters in the single
digits are all <a href="https://en.wikipedia.org/wiki/Unicode_control_characters">control
characters</a> like “End
of Text” (U+0003). If you try to print them out following a standard debugging
procedure of littering your code with print statements, nothing is printed and
your debugging is not going very well.</p>
<p>This really stumped us, including with Googling, until we finally came across a
hint: To use <code>fmt.Sprintf</code> to convert the integer to a string instead:</p>
<div><pre tabindex="0"><code data-lang="go"><span><span>    <span>countString</span> <span>:=</span> <span>fmt</span>.<span>Sprintf</span>(<span>&#34;%d&#34;</span>, <span>count</span>)
</span></span><span><span>    <span>result</span> = append(<span>result</span>, []rune(<span>countString</span>)<span>...</span>)
</span></span></code></pre></div><p>This worked, but we didn’t understand why. It wasn’t even easy to search for an
answer; for example, the Go <a href="https://pkg.go.dev/builtin">builtin</a> docs do not list a
<code>string()</code> function but only the type. Thanks to some users on IRC for noting
that the answer lies in the <a href="https://go.dev/ref/spec#Conversions_to_and_from_a_string_type">Go
spec</a>:</p>
<blockquote>
<p>Finally, for historical reasons, an integer value may be converted to a
string type. This form of conversion yields a string containing the (possibly
multi-byte) UTF-8 representation of the Unicode code point with the given
integer value. Values outside the range of valid Unicode code points are
converted to “\uFFFD”. […Examples Omitted…] Note: This form of conversion
may eventually be removed from the language. The go vet tool flags certain
integer-to-string conversions as potential errors. Library functions such as
utf8.AppendRune or utf8.EncodeRune should be used instead.</p>
</blockquote>
<p>“For historical reasons”, <code>string(int)</code> behaves the same as <code>rune(int)</code>. In
fact, from what I understand (although I’d like to learn more about this),
tools like <code>string()</code> are not actually Go functions at all but primitives built
into the language.</p>
<p>The first moral of this story is to always read the spec. Although Go has
excellent documentation, it’s organized around Go modules. Something low-level
like this is documented in the specification itself.</p>
<p>The second moral of this story is that the language server protocol
<a href="https://pkg.go.dev/golang.org/x/tools/gopls">gopls</a> is not a complete
replacement for <a href="https://pkg.go.dev/cmd/vet">go vet</a>. The two are
complementary. As the spec notes, <code>go vet</code> would have caught our error
immediately and suggested the solution, but neither of thought to run it.</p>
<p>The third moral of this story is to rethink what a “simple” test case looks
like. We thought that we could debug the problem by focusing on the most simple
test cases like “a”. But this meant we were only looking at the Unicode <a href="https://www.compart.com/en/unicode/U+0001">Start
of Heading</a> character, which looks
like nothing at all! If we had built up a much larger set of test strings that
got out of the Unicode control characters, our debugging would have likely gone
faster.</p>
</section>

  
  

  
  
  
  
  <nav>
    
    
    <a href="https://moerner.com/posts/impossible-day-inode-exhaustion/"><span>When Impossible Day Feels Impossible: /tmp Inode Exhaustion</span><span>→</span></a>
    
  </nav>
  
  

  
  

  
  

  


  
</article>


    </div></div>
  </body>
</html>
