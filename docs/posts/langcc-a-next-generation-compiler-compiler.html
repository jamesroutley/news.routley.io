<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/jzimmerman/langcc">Original</a>
    <h1>Langcc: A Next-Generation Compiler Compiler</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
            <article itemprop="text">
<p dir="auto"><code>langcc</code> is a tool that takes the formal description of a language,
in a standard BNF-style format, and automatically generates a compiler
front-end, including data structure definitions for the language&#39;s
abstract syntax trees (AST) and traversals,
a lexer, a parser, and a pretty-printer.
<code>langcc</code> also serves as the companion software implementation to the following
technical reports, which describe several innovations on the classic
LR parsing paradigm:</p>
<ul dir="auto">
<li>Zimmerman, Joe.
<a href="https://arxiv.org/abs/2209.08383" rel="nofollow">Practical LR Parser Generation.</a>
arXiv, 2022.</li>
<li>Zimmerman, Joe.
<a href="https://arxiv.org/abs/2209.08385" rel="nofollow">langcc: A Next-Generation Compiler Compiler.</a>
arXiv, 2022.</li>
</ul>
<p dir="auto"><code>langcc</code> can be used as a replacement for the combination of <code>lex</code>
and <code>yacc</code> (or <code>flex</code> and <code>bison</code>). However, <code>langcc</code> provides many
additional features, including:</p>
<ul dir="auto">
<li>Automatic generation of AST data structures, via a standalone datatype
compiler (<code>datacc</code>).</li>
<li>Full LR parser generation as the default, rather than the more restrictive
LALR.</li>
<li>Clear presentation of LR conflicts via explicit &#34;confusing input pairs&#34;,
rather than opaque shift/reduce errors.</li>
<li>Novel efficiency optimizations for LR automata.</li>
<li>An extension of the LR paradigm to include recursive-descent (RD)
parsing actions, resulting in significantly smaller and more intuitive
automata.</li>
<li>An extension of the LR paradigm to include per-symbol attributes,
which are vital for the efficient implementation of many industrial language
constructs.</li>
<li>A general transformation for LR grammars (CPS), which significantly
expands the class of grammars the tool can support.</li>
</ul>
<p dir="auto">Unlike previous compiler compilers, <code>langcc</code> is general enough to capture
full industrial programming languages, for which existing parsers are
typically written by hand or generated from procedural descriptions.
Examples include Python 3.9.12 (<code>grammars/py.lang</code>) and Golang 1.17.8
(<code>grammars/go.lang</code>). In both cases, <code>langcc</code> automatically generates
a parser that is faster than the standard library parser for each language.
In fact, the class of grammars supported by <code>langcc</code> is general enough
that the tool is <em>self-hosting</em>: that is, one can express the &#34;language
of languages&#34; in the &#34;language of languages&#34; itself, and use <code>langcc</code>
to generate its own compiler front-end. We do this in the canonical
implementation; see the files <code>bootstrap.sh</code> and <code>grammars/meta.lang</code>
for more details.</p>
<p dir="auto"><code>langcc</code> is a research prototype and has not yet been used extensively
in production. However, we believe it is essentially stable and
feature-complete, and can be used as a standalone tool to facilitate
rapid exploration of new compilers and programming languages.</p>
<h2 dir="auto"><a id="user-content-build" aria-hidden="true" href="#build"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Build</h2>
<p dir="auto">The build has been tested on Ubuntu 22.04 and macOS 12.5,
but should also run on some other versions of Ubuntu
and macOS with minor adaptations.</p>
<p dir="auto">For Ubuntu 22.04:</p>
<div data-snippet-clipboard-copy-content="./deps_ubuntu.sh
make -j8
sudo make install"><pre><code>./deps_ubuntu.sh
make -j8
sudo make install
</code></pre></div>
<p dir="auto">For macOS 12.5 (requires Homebrew):</p>
<div data-snippet-clipboard-copy-content="./deps_macos.sh
make -j8
sudo make install"><pre><code>./deps_macos.sh
make -j8
sudo make install
</code></pre></div>
<p dir="auto">And, in order to bootstrap the <code>langcc</code> front-end itself, subsequently run:</p>

<h2 dir="auto"><a id="user-content-examples" aria-hidden="true" href="#examples"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Examples</h2>
<p dir="auto">Once <code>langcc</code> (and its companion, <code>datacc</code>) have been installed,
one can run various examples:</p>
<ul dir="auto">
<li>In the <code>examples</code> directory, there are two examples: <code>basic</code> and
<code>calc</code>. Each has its own local Makefile.</li>
<li>The main build process itself compiles <code>grammars/py.lang</code> and
<code>grammars/go.lang</code>, producing tests <code>build/go_standalone_test</code> and
<code>build/py_standalone_test</code>. (Note: These binaries require, respectively,
repositories for Golang 1.17.8 located in the directory <code>../go</code>,
and Python 3.9.12 located in the directory <code>../cpython</code>.)</li>
<li>There is the language of datatypes, <code>grammars/data.lang</code>, which describes
the input of the additional standalone tool <code>datacc</code> (used by <code>langcc</code>
to automatically generate C++ implementations of algebraic datatypes).</li>
<li>Finally, there is the language of languages itself, <code>grammars/meta.lang</code>.
This language also serves as basic documentation, as it enumerates all of
its own features.</li>
</ul>
<h2 dir="auto"><a id="user-content-documentation" aria-hidden="true" href="#documentation"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Documentation</h2>
<p dir="auto">For full documentation, see the accompanying technical report:</p>
<ul dir="auto">
<li>Zimmerman, Joe.
<a href="https://arxiv.org/abs/2209.08385" rel="nofollow">langcc: A Next-Generation Compiler Compiler.</a>
arXiv, 2022.</li>
</ul>
<p dir="auto">as well as the theoretical development:</p>
<ul dir="auto">
<li>Zimmerman, Joe.
<a href="https://arxiv.org/abs/2209.08383" rel="nofollow">Practical LR Parser Generation.</a>
arXiv, 2022.</li>
</ul>
</article>
          </div></div>
  </body>
</html>
