<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://timkellogg.me/blog/2024/01/17/htmx">Original</a>
    <h1>Htmx Is Composable?</h1>
    
    <div id="readability-page-1" class="page"><div id="post">
	<p id="time">
		<time pubdate="true">
			Wed January 17, 2024
		</time>
	</p>
	
		<p><img src="https://gist.github.com/assets/437044/e9443c0a-823a-46f1-82b8-ccb8a13d7111"/></p><p>I wrote an <a href="https://htmx.org/">HTMX</a> app and it was easy to develop a powerful plugin system within it. That surprised
me. I had assumed that JSON-driven REST APIs were the only way to make composable web APIs. In my mind, HTMX blends the 
backend and frontend together into one monolithic component. It seemed counterintuitive.</p>

<p>Let me tell you about it.</p>



<p>Before the New Year I decided to hack on an idea. I wanted a social media client for Mastodon that
displays my feed in a way that suits me ‚Äî¬†surface the information I‚Äôm trying to track and de-prioritize
everything else. Basically the reverse of how Big Tech opimizes their algorithms. I call it Fossil.</p>

<p>So I spent about 3:30 hours and produced a working app using <a href="https://streamlit.io/">streamlit</a>. Streamlit was an
amazing experience, it certainly streamlined the proof of concept phase. When <a href="https://timkellogg.me/blog/2023/12/19/fossil">I wrote about it</a>,
someone on HN said they liked the idea of having their own algorithm, they just didn‚Äôt like what I made.
What a good thought! I should turn this into a pluggable framework for creating social media
algorithms!</p>

<p>So now my goal is to make a pluggable framework, where anyone can make their own algorithm.</p>



<p>As I rewrote fossil in HTMX, I designed for a pluggable interface. The algorithm part
was easy ‚Äî 3rd parties can write a Python class that implements a few abstract methods. It‚Äôs all
Python, so it‚Äôs pretty straightforward.</p>

<p>But what if someone needs a new SQL table? Like maybe they need to cache some kind of statistics
about users (e.g. topics they post about, authoritative posts, etc.). Well, they can probably just 
run <code>CREATE TABLE</code> statements in the constructor of the class. Seems fine.</p>

<p>
graph LR
  subgraph server
    FastAPI
    SQLite
  end

  SQLite --&gt; FastAPI --&gt; HTMX
</p>

<p>Right, but what if they want to add buttons in the UI? e.g. If a user can mark a post as belonging
to the ‚Äúpolitical nonsense‚Äù topic, then we could train a model to identify posts we don‚Äôt want to see.
But that means the plugin would need to add buttons to the UI to provide that kind of feedback.</p>

<p>When I first saw Simon Wilison‚Äôs <a href="https://llm.datasette.io/en/stable/">llm</a> tool, I loved how easy it was to install plugins. Just
<code>pip install</code>. I want the same ease here too. The thing is, with components that span UI, backend and
database, that tends to be a tough sell.</p>

<p>With fossil <a href="https://timkellogg.me/blog/2024/01/12/fossil-0.2">plugins</a>, it‚Äôs become straightforward to work on any part of the stack:</p>

<ol>
  <li>UI elements ‚Äî write verbatim HTML or Jinja templates, <a href="https://github.com/tkellogg/fossil/blob/main/pyproject.toml#L26">packaged</a> into a plugin</li>
  <li>API endpoints ‚Äî¬†register them via a <a href="https://github.com/tkellogg/fossil/blob/main/fossil_mastodon/plugin_impl/toot_debug.py">decorator API</a></li>
  <li>DB tables ‚Äî¬†Create them during plugin initialization</li>
  <li>AI algorithms ‚Äî¬†register them via the <a href="https://github.com/tkellogg/fossil/blob/main/fossil_mastodon/plugin_impl/topic_cluster.py">API</a></li>
</ol>

<p>That‚Äôs neat. The whole stack.</p>

<p>
graph TD
  fossil--&gt;ui[UI Plugins]
  api[API endpoints]--&gt;fossil
  db[DB tables]--&gt;fossil
  fossil--&gt;ai[AI Algorithms]
</p>

<h2 id="toot_debugpy">toot_debug.py</h2>

<p>As a very short example, this is a real plugin in fossile core. It adds the ability to click a button
and see what the Mastodon JSON message looks like in the server terminal. I use it a lot for developing
Fossil.</p>

<div><div><pre><code><span>import</span> <span>json</span>
<span>from</span> <span>fastapi</span> <span>import</span> <span>responses</span>
<span>from</span> <span>fossil_mastodon</span> <span>import</span> <span>plugins</span><span>,</span> <span>core</span>


<span># Metadata
</span><span>plugin</span> <span>=</span> <span>plugins</span><span>.</span><span>Plugin</span><span>(</span>
    <span>name</span><span>=</span><span>&#34;Toot Debug Button&#34;</span><span>,</span>
    <span>description</span><span>=</span><span>&#34;Adds a button to toots that prints the toot&#39;s JSON to the server&#39;s console.&#34;</span><span>,</span>
<span>)</span>


<span># An API endpoint. The `plugin.api_operation` object is a FastAPI app.
</span><span>@</span><span>plugin</span><span>.</span><span>api_operation</span><span>.</span><span>post</span><span>(</span><span>&#34;/plugins/toot_debug/{id}&#34;</span><span>)</span>
<span>async</span> <span>def</span> <span>toots_debug</span><span>(</span><span>id</span><span>:</span> <span>int</span><span>):</span>
    <span>toot</span> <span>=</span> <span>core</span><span>.</span><span>Toot</span><span>.</span><span>get_by_id</span><span>(</span><span>id</span><span>)</span>
    <span>if</span> <span>toot</span> <span>is</span> <span>not</span> <span>None</span><span>:</span>
        <span>print</span><span>(</span><span>json</span><span>.</span><span>dumps</span><span>(</span><span>toot</span><span>.</span><span>orig_dict</span><span>,</span> <span>indent</span><span>=</span><span>2</span><span>))</span>
    <span># Feedback that the button was clicked. This 
</span>    <span># will replace the text of the button.
</span>    <span>return</span> <span>responses</span><span>.</span><span>HTMLResponse</span><span>(</span><span>&#34;&lt;div&gt;üíØ&lt;/div&gt;&#34;</span><span>)</span>


<span># A UI plugin. The bits of HTML are included into the `/index` response.
</span><span>@</span><span>plugin</span><span>.</span><span>toot_display_button</span>
<span>def</span> <span>get_response</span><span>(</span><span>toot</span><span>:</span> <span>core</span><span>.</span><span>Toot</span><span>,</span> <span>context</span><span>:</span> <span>plugins</span><span>.</span><span>RenderContext</span><span>)</span> <span>-&gt;</span> <span>responses</span><span>.</span><span>Response</span><span>:</span>
    <span>return</span> <span>responses</span><span>.</span><span>HTMLResponse</span><span>(</span><span>f</span><span>&#34;&#34;&#34;
        &lt;button hx-post=&#34;/plugins/toot_debug/</span><span>{</span> <span>toot</span><span>.</span><span>id</span> <span>}</span><span>&#34;&gt;ü™≤&lt;/button&gt;
    &#34;&#34;&#34;</span><span>)</span>
</code></pre></div></div>

<p>That provides an API endpoint, as well as a bit of HTML that instructs how the API endpoint is incorporated
into the application.</p>



<p>I think of APIs like UNIX-style CLI programs ‚Äî¬†a collection of tiny parts that are easy to combine
in ways the creators never thought of. Plugin systems, on the other hand, are defined by their composability.
Monoliths generally aren‚Äôt composable. I‚Äôm describing HTMX as monolithic because I tend to push all 
program logic into the backend, all in once place.</p>

<p>The problem is, I wasn‚Äôt comparing against just REST APIs, I was comparing against React + REST.</p>

<p>
graph LR
  React--&gt;API--&gt;React
</p>

<p>So, while an API might be extremely composable on it‚Äôs own, the combination of React + an API isn‚Äôt
just monolithic, it‚Äôs a monolith split across a <em>distributed system</em>. And those are <strong>extremly 
non-composable</strong>.</p>

<p>Individual React components are very composable. But 
when you combine the requirements that I need, spanning the full stack, you find yourself in what
I like to describe as a distributed system, since state is split between the client and server.</p>

<p>I‚Äôve spent a fair amount of time working with distributed systems. It‚Äôs just regular programming,
just that everything is harder. Exceptions don‚Äôt bubble up, errors can be indistinguishable from
latency, systems don‚Äôt compose, error handling doesn‚Äôt have a single best approach, even retries
are harder than they should be.</p>


<p>Stepping back, it feels like the HTML is more like a configuration language, with instructions
for how all the pieces fit together. There is state, but it‚Äôs hidden within the engine that interprets
my declarative configuration (a.k.a the browser).</p>

<p>Years ago, in .NET and Java, it was popular to use an <a href="https://docs.spring.io/spring-framework/docs/4.2.x/spring-framework-reference/html/xsd-configuration.html">Inversion of Control container</a> with
XML configuration that declared and configured different classes and objects. I think it largely
went out of style <a href="https://stackoverflow.com/q/871405/503826">because it‚Äôs complicated</a>, or at least more complicated than it needed to
be.</p>

<p>The HTML I write with HTMX feels a bit like IoC configuration, in that describes how all the 
program components fit together. But it‚Äôs more functional, because it also describes how the UI
is laid out. When I look at it as configuration, it‚Äôs clear why it‚Äôs easy to make a plugin system 
in it. It <em>is</em> a plugin system.</p>


<p>Thinking of HTMX as a sort of configuration helps me understand it‚Äôs contributions to program
composability. I‚Äôm not sure if that helps anyone else, but the entire framework makes more sense
to me since I‚Äôve started thinking about it that way. The HTMX site talks about [HTATEOAS][hateaos],
which is a different phrasing this ‚Äî the HTML <strong>is</strong> the application state.</p>


<ul>
  <li><a href="https://timkellogg.me/blog/2024/01/17/htmx">Mastodon</a></li>
  <li><a href="https://news.ycombinator.com/item?id=39026565">Hacker News</a></li>
  <li><a href="https://lobste.rs/s/xnzvea/htmx_is_composable">Lobste.rs</a></li>
</ul>


</div></div>
  </body>
</html>
