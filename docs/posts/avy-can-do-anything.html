<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://karthinks.com/software/avy-can-do-anything/">Original</a>
    <h1>Avy Can Do Anything</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
      
<p><strong>You’re using Avy wrong.</strong></p>
<p>Too harsh? Let me rephrase: you’re barely using Avy. Still too broad? Okay, the noninflammatory version: Avy, the Emacs package to jump around the screen, lends itself to efficient composable usage that’s obscured by default.</p>
<p>Without burying the lede any further, here’s a demo that uses a single Avy command (<code>avy-goto-char-timer</code>) to do various things in multiple buffers and windows, all without manually moving the cursor:</p>

<p>Copy text, kill lines or regions, move text around, mark text, bring up help buffers, look up definitions, search google, check my spelling, the list goes on. I emphasize this again: <em>Avy defines dozens of jump commands, but I’m only using one.</em> This post breaks this down in detail so you can create your own version of this, but more importantly tries to explain why this is a neat idea.</p>
<p>This is the first of two parts in a series on Avy, an Emacs package for jumping around efficiently with the keyboard. Part 1 is about about supercharging built-in customization to <strong>do anything with Avy</strong>, or some approximation thereof. Part 2 will be a more technical (elisp-y) dive into writing more complex features for your individual needs. If you are interested in the short elisp snippets in this document, they are collated into a single file <a href="https://gist.github.com/karthink/af013ffd77fe09e67360f040b57b4c7b">here</a>.</p>
<h2 id=""><span>Filter</span> → <span>Select</span> → <span>Act</span></h2>
<p>We see the same pattern repeated in most interactions with Emacs whose primary purpose isn’t typing text. To perform a task, we <span>Filter</span>, <span>Select</span> and <span>Act</span> in sequence:</p>
<p><strong><span>Filter</span></strong>: Winnow a large pile of candidates to a smaller number, usually by typing in some text. These candidates can be anything, see below for examples.</p>
<p><strong><span>Select</span></strong>: Specify a candidate as the one you need, usually with visual confirmation. If you filter a list down to one candidate, it’s automatically selected.</p>
<p><strong><span>Act</span></strong>: Run the task with this candidate as an argument.</p>
<ul>
<li>Want to open a file? Invoke a command, then type in text to <span>filter</span> a list of completions, <span>select</span> a completion, <span>find-file</span>.</li>
<li>Switch buffers? Type to <span>filter</span>, <span>select</span> a buffer, <span>switch</span>.</li>
<li><span>Autocomplete</span> a symbol in code? Type a few characters to <span>narrow</span> a pop-up list, <span>choose</span> a candidate, confirm.</li>
</ul>
<p>As ever, this model is a simplification. Helm, Ivy, Dired &amp; co let you <span>select</span> multiple candidates to <span>act</span> on, for instance. We will put this qualification aside while we explore this idea.</p>
<p>This observation leads to several interesting ideas. For one, the <span>Filter</span> → <span>Select</span> → <span>Act</span> process is often thought of as a single operation. Decoupling the filtering, selection and action phases (in code and in our heads) frees us to consider a flock of possibilities. Here’s minibuffer interaction:</p>
<figure>
    <img src="https://karthinks.com/img/minibuffer-interaction-paradigm.png" width="800px"/> 
</figure>

<p>The possibilities are, respectively: different completion styles (matching by regexps, flex, orderless), different selection interfaces (Icomplete, Ivy, Helm, Vertico, Selectrum and more by the day) and different action dispatchers (Embark, Helm/Ivy actions)<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup>. A similar mini-Cambrian explosion has happened in the <a href="https://github.com/junegunn/fzf/wiki/">space of shell utilities</a> since <a href="https://github.com/junegunn/fzf">fzf</a> arrived on the scene. In Emacs the minibuffer is where we’re used to selecting things, so it’s natural to think of these examples.</p>
<p>But this usage pattern extends to more than just minibuffer interaction. We often do things in regular buffers that involve the <span>Filter</span> → <span>Select</span> → <span>Act</span> pattern. In fact, you can look at most interactions with Emacs (whose focus isn’t typing text) this way: when you call a goto-definition command with point–the text cursor–in some text, the <span>filtering</span> stage is skipped, the <span>selection</span> is made for you by a function from the <code>thing-at-pt</code> library, and a preset <span>action</span> is called. How about a mouse interaction? <span>scroll</span> through a window full of icons, <span>move</span> the mouse cursor to an icon and <span>click</span> on it. These completely redundant examples prime us for the more interesting cases. Consider Isearch:</p>
<figure>
    <img src="https://karthinks.com/img/isearch-interaction-paradigm.png" width="800px"/> 
</figure>

<p>When you type (after <code>C-s</code>), you automatically <span>filter</span> buffer text and <span>select</span> the nearest match. You can select each subsequent match in turn, or <span>jump</span> to the first or last match. The <span>Act</span> here is the process of moving the cursor to the match location, but it can be one of a few things, like running <code>occur</code> or <code>query-replace</code> on the search string. Many Isearch commands simultaneously filter, select and act, so we’re fitting a square peg in a round hole here<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup>.</p>
<p>If you’ve spent any time using Isearch, you can appreciate the tradeoff involved in dividing a task into these three independently configurable phases. Lumping two or all three into a single operation makes Isearch a <em>wicked fast</em> keyboard interaction. When I use Isearch my brain is usually trying to catch up to my fingers. On the other hand, the advantage of modularity is expressive power. The three phase process is slower on the whole, but we can do a whole lot more by plugging in different pieces into each of the <span>Filter</span> , <span>Select</span> and <span>Act</span> slots. To see this, you have only to consider how many disparate tasks the minibuffer handles, and in how many different ways!</p>
<p>But back to Isearch: what can we do to decouple the three stages here? Not much without modifying its guts. It’s all elisp, so that’s not a tall order. For example, Protesilaos Stavrou adds many intuitive actions (such as marking candidates) to Isearch in <a href="https://www.youtube.com/watch?v=y6%5Fbmcd3nis">this video</a>. But it turns out we don’t need to modify Isearch, because <strong>Avy</strong> exists, has a killer <span>Filter</span> feature, and it separates the three stages like a champ. This makes for some very intriguing possibilities.</p>
<figure>
    <img src="https://karthinks.com/img/avy-interaction-paradigm.png" width="800px"/> 
</figure>

<h2 id="wait-what-s-avy">Wait, what’s Avy?</h2>
<p><a href="https://github.com/abo-abo/avy">Avy</a> is authored by the prolific <a href="https://oremacs.com/">abo-abo</a> (Oleh Krehel), who also wrote Ivy, Counsel, Ace-Window, Hydra, Swiper and many other mainstays of the Emacs package ecosystem that you’ve probably used. If you’re reading this, chances are you already know (and probably use) Avy. So here’s a very short version from the documentation:</p>
<blockquote>
<p>avy is a GNU Emacs package for jumping to visible text using a char-based decision tree.</p>
</blockquote>
<p>You can call an Avy command and type in some text. Any match for this text on the frame (or all Emacs frames if desired) becomes a selection candidate, with some hint characters overlaid on top. Here I type in “an” and all strings in the frame that match it are highlighted:</p>
<figure>
    <img src="https://karthinks.com/img/avy-basic-demo.png" width="800px"/> 
</figure>

<p>Typing in one of the hints then jumps the cursor to that location. Here I jump to this sentence from another window:</p>

<details>
<summary>
Play by play
</summary>
<div>
<ol>
<li>Call <code>avy-goto-char-timer</code></li>
<li>Type in “se”. This shows hints for all matches with “se”, including “sentence”.</li>
<li>Type in the hint char corresponding to “sentence”, which is <code>g</code> here.</li>
</ol>
</div>
</details>
<p>Typical Avy usage looks something like this: Jump to a location that matches your text (across all windows), then jump back with <code>pop-global-mark</code> (<code>C-x C-SPC</code>). In a later section <a href="#when-avy-is-too-clever">I go into more detail on jumping back and forth</a> with Avy. Here is a demo of this process where I jump twice with Avy and then jump back in sequence:</p>

<details>
<summary>
Play by play
</summary>
<div>
<ol>
<li>Call <code>avy-goto-char-timer</code></li>
<li>Type in “demo”. There is only one candidate for this string, so Avy jumps to the other window.</li>
<li>Type in “jump”. This shows hints for all matches with “jump”.</li>
<li>Pick one of the matches. Avy jumps again, this time to the third window.</li>
<li>Call <code>pop-global-mark</code> (<code>C-x C-SPC</code>) to jump back to the previous location.</li>
<li>Call <code>pop-global-mark</code> (<code>C-x C-SPC</code>) again to jump back to the previous location.</li>
</ol>
</div>
</details>
<p>At least that’s the official description. You can peruse the <a href="https://github.com/abo-abo/avy/blob/master/README.md">README</a> for more information, but what I find mystifying is that…</p>
<h2 id="dot-dot-dot-avy-s-documentation-leaves-out-the-best-part">…Avy’s documentation leaves out the best part</h2>
<p>Avy handles filtering automatically and the selection is made through a char-based decision tree. Here’s how it fits into our three part interaction model.</p>
<h3 id=""><span>Filter</span>,</h3>
<p>Before you call Avy <em>every text character on your screen</em> is a potential candidate for selection. The possibilites are all laid out for you, and there are too many of them!</p>
<p>You filter the candidate pool with Avy similar to how you would in the minibuffer, by typing text. This reduces the size of the pool to those that match your input. Avy provides dozens of filtering styles. It can: only consider candidates above/below point, only beginnings of words, only the current window (or frame), only whitespace, only beginnings of lines, only headings in Org files, the list goes on.</p>
<details>
<summary>
Filtering commands in Avy
</summary>
<div>

<table>
<thead>
<tr>
<th>Unit: Char</th>
<th>Unit: Word or Symbol</th>
<th>Unit: Line or other</th>
</tr>
</thead>
<tbody>
<tr>
<td>avy-goto-char-timer</td>
<td>avy-goto-word-0</td>
<td>avy-goto-line</td>
</tr>
<tr>
<td>avy-goto-char</td>
<td>avy-goto-subword-0</td>
<td>avy-goto-end-of-line</td>
</tr>
<tr>
<td>avy-goto-char-2</td>
<td>avy-goto-symbol-1-above</td>
<td>avy-goto-whitespace-end</td>
</tr>
<tr>
<td>avy-goto-char-in-line</td>
<td>avy-goto-word-0-below</td>
<td>avy-org-goto-heading-timer</td>
</tr>
<tr>
<td>avy-goto-char-2-below</td>
<td>avy-goto-word-1-below</td>
<td>avy-goto-whitespace-end-above</td>
</tr>
<tr>
<td>avy-goto-char-2-above</td>
<td>avy-goto-symbol-1-below</td>
<td>avy-goto-line-above</td>
</tr>
<tr>
<td></td>
<td>avy-goto-word-1-above</td>
<td>avy-goto-whitespace-end-below</td>
</tr>
<tr>
<td></td>
<td>avy-goto-symbol-1</td>
<td>avy-goto-line-below</td>
</tr>
<tr>
<td></td>
<td>avy-goto-word-or-subword-1</td>
<td></td>
</tr>
<tr>
<td></td>
<td>avy-goto-subword-1</td>
<td></td>
</tr>
<tr>
<td></td>
<td>avy-goto-word-1</td>
<td></td>
</tr>
<tr>
<td></td>
<td>avy-goto-word-0-above</td>
<td></td>
</tr>
</tbody>
</table>
<p>This is a <em>crazy</em> list to keep track of.</p>
</div>
</details>
<p>Filtering in Avy is independent of the selection method (as it should be), but there is a dizzying collection of filtering methods. I assume the idea is that the user will pick a couple of commands that they need most often and commit only those to memory.</p>
<p>Here’s the problem: <strong>We want to use our mental bandwidth for the problem we’re trying to solve with the text editor, not the editor itself</strong>. Conscious decision-making is expensive and distracting. As of now we need to decide on the fly between Isearch and Avy to find and act on things. If you use a fancy search tool like Swiper, Helm-swoop or Consult-line, you now have three options. Having a bunch of Avy commands on top is a recipe for mental gridlock. To that end, we just pick the most adaptable, flexible and general-purpose Avy command (<code>avy-goto-char-timer</code>) for everything.</p>
<div><pre><code data-lang="emacs-lisp">(<span>global-set-key</span> (<span>kbd</span> <span>&#34;M-j&#34;</span>) <span>&#39;avy-goto-char-timer</span>)
</code></pre></div><p>Further below <a href="https://karthinks.com/software/avy-can-do-anything/#avy-plus-isearch-seek-then-jump">I make the case</a> that you don’t need to make even this decision, you can always use Isearch and switch to Avy as needed.</p>
<p>To be clear, this decision cost has to be balanced against the cost of frequent busywork and chronic context switching that Avy helps avoid. There is a case to be made for adapting Avy’s flexible filtering options to our needs, and the <a href="https://melpa.org/#/?q=avy">number of packages</a> that offer Avy-based candidate filtering (for everything from linting errors to buffer selection) attests to this. We will examine this in depth in Part II.</p>
<p>But in this piece we are interested in a different, much less explored aspect of Avy.</p>
<h3 id=""><span>Select</span>,</h3>
<p>Every selection method that Avy offers involves typing characters that map to screen locations. This is quite different from Isearch, where you call <code>isearch-repeat-forward</code> (<code>C-s</code>, possibly with a numerical prefix argument) or the minibuffer, where you navigate a completions buffer or list with <code>C-n</code> and <code>C-p</code>. Avy’s selection method is generally faster because it minimizes, by design, the length of the character sequences it uses, and we have ten fingers that can access ∼40 keys in O(1) time. The fact that we’re often looking directly where we mean to jump means we don’t need to parse an entire screen of gibberish. Unfortunately for this article, this means using Avy is much more intuitive than looking at screenshots or watching demos.</p>
<p>This excellent design leaves us with little reason to tinker with the selection phase: it’s sufficiently modular and accommodating of different filter and act stages. You can customize <code>avy-style</code> if you want to change the set or positions of characters used for selection. Here is an example of using simple words to select candidates:</p>
<figure>
    <img src="https://karthinks.com/img/avy-words-style-demo.png" width="800px"/> 
</figure>

<p>We will pay more attention to the selection operation in part II as well.</p>
<h3 id=""><span>Act</span>!</h3>
<p>This brings us to the focus of this article. The stated purpose of Avy, jumping to things, makes it sound like a (contextually) faster Isearch. But jumping is only one of many possibilities. Avy provides a “dispatch list”, a collection of actions you can perform on a candidate, and they are all treated on equal footing with the jump action. You can show these commands any time you use Avy with <code>?</code>:</p>
<figure>
    <img src="https://karthinks.com/img/avy-dispatch-demo.png" width="800px"/> 
</figure>

<p>This means we are free to leverage Avy’s unique filtering and selection method to <em>whatever action we want to carry out</em> at any location on the screen. Our interaction model now ends in a block that looks something like this:</p>
<figure>
    <img src="https://karthinks.com/img/avy-interaction-paradigm-detailed.png" width="500px"/> 
</figure>

<p>Additionally, Avy also defines a few commands that run different actions, like copying text from anywhere on screen:</p>

<table>
<thead>
<tr>
<th>Kill</th>
<th>Copy</th>
<th>Move</th>
</tr>
</thead>
<tbody>
<tr>
<td>avy-kill-ring-save-whole-line</td>
<td>avy-copy-line</td>
<td>avy-move-line</td>
</tr>
<tr>
<td>avy-kill-ring-save-region</td>
<td>avy-copy-region</td>
<td>avy-move-region</td>
</tr>
<tr>
<td>avy-kill-region</td>
<td></td>
<td>avy-transpose-lines-in-region</td>
</tr>
<tr>
<td>avy-kill-whole-line</td>
<td></td>
<td>avy-org-refile-as-child</td>
</tr>
</tbody>
</table>
<p>The problem with this approach is that it doesn’t scale. Each of these commands defines a full <span>Filter</span> → <span>Select</span> → <span>Act</span> process, and we quickly run out of headspace and keyboard room if we want any kind of versatility or coverage. They’re also not dynamic enough: you’re locked into the pipeline and cannot change your mind once you start the command.</p>
<p>Folks love Vim’s editing model for a reason: it’s a mini-language where knowing M actions (verbs) and N cursor motions gives you M × N composite operations. This (M + N) → (M × N) ratio pays off quadratically with the effort you put into learning verbs and motions in Vim. Easymotion, which is Vim’s version of Avy<sup id="fnref:3"><a href="#fn:3" role="doc-noteref">3</a></sup>, has part of this composability built-in as a result. We seek to bring some of this to Avy, and (because this is Emacs) do a lot more than combining motions with verbs. We won’t need to step into Avy’s source code for this, it has all the hooks we need already.</p>
<h2 id="avy-actions">Avy actions</h2>
<p>The basic usage for running an arbitrary action with Avy is as follows:</p>
<ol>
<li>Call an Avy command. Any command will do, I stick to <code>avy-goto-char-timer</code>.</li>
<li><span>Filter</span>: Type in some text to shrink the candidate pool from the entire screen to a few locations.</li>
<li><span>Act</span>: Specify the action you want to run. You can pull up the dispatch help with <code>?</code>, although you won’t have to if you set it up right, see <a href="#remembering-to-avy">Remembering to Avy</a>.</li>
<li><span>Select</span>: Pick one of the candidates to run the action on.</li>
</ol>
<p>Here are some things I frequently do with Avy. Note that you can do this on any text in your frame, not just the active window!</p>
<p>First, taking the annoyance out of some common editing actions with Avy. If you use Vim and Easymotion, you get the first few actions below for free:</p>
<details open="">
<summary>
A note about these demos
</summary>
<div>
<ul>
<li>
<p>For clarity, I set Avy to desaturate the screen and to “pulse” the line during a few of these actions. These are not enabled by default. I also slowed down the operations by adding a delay to make them easier to follow. In actual usage these are instantaneous.</p>
</li>
<li>
<p>The keys Avy uses to dispatch actions on candidates are specified in <code>avy-dispatch-alist</code>.</p>
</li>
<li>
<p>We will also need to ensure that these keys don’t coincide with the ones Avy uses as selection hints on screen. Consider customizing <code>avy-keys</code> for this.</p>
</li>
</ul>
</div>
</details>
<h3 id="kill-a-candidate-word-sexp-or-line">Kill a candidate word, sexp or line</h3>
<p>Killing words or s-expressions is built-in. I added an action to kill a line. In this demo I quickly squash some typos and delete a comment, then remove some code in a different window:</p>

<details>
<summary>
Play by play
</summary>
<div>
<ol>
<li>Call <code>avy-goto-char-timer</code>.</li>
<li>Type in “is”. This shows hints for all matches for “is”.</li>
<li>Call <code>avy-action-kill</code> with <code>k</code></li>
<li>Select one of the duplicate “is” occurrence. This deletes it.</li>
<li>Repeat steps 1-4 to delete a redundant “and”.</li>
<li>Call <code>avy-Goto-Char-Timer</code>.</li>
<li>Type in “key” to filter matches for “key”.</li>
<li>Call <code>avy-action-kill-whole-line</code> with <code>K</code>.</li>
<li>Select the commented line, this removes the line.</li>
<li>Repeat steps 1-4, this time selecting “(” in the other window and killing the function definition.</li>
<li>Repeat steps 7-9, this time selecting “ad” in the other window and killing the “(advice-add …)” line.</li>
</ol>
</div>
</details>
<div><pre><code data-lang="emacs-lisp">(<span>defun</span> <span>avy-action-kill-whole-line</span> (<span>pt</span>)
  (<span>save-excursion</span>
    (<span>goto-char</span> <span>pt</span>)
    (<span>kill-whole-line</span>))
  (<span>select-window</span>
   (<span>cdr</span>
    (<span>ring-ref</span> <span>avy-ring</span> <span>0</span>)))
  <span>t</span>)

(<span>setf</span> (<span>alist-get</span> <span>?k</span> <span>avy-dispatch-alist</span>) <span>&#39;avy-action-kill-stay</span>
      (<span>alist-get</span> <span>?K</span> <span>avy-dispatch-alist</span>) <span>&#39;avy-action-kill-whole-line</span>)
</code></pre></div><h3 id="yank-a-candidate-word-sexp-or-line">Yank a candidate word, sexp or line</h3>
<p>Copy to the kill-ring or copy to point in your buffer. In this demo I copy some text from a man page into my file:</p>

<details>
<summary>
Play by play
</summary>
<div>
<ol>
<li>Call <code>avy-goto-char-timer</code>.</li>
<li>Type in “[&#34;. This filters to all matches for “[” in the frame.</li>
<li>Call <code>avy-action-yank</code>, bound to <code>y</code>.</li>
<li>Select the match corresponding to “[big-cache]&#34;. This text is copied to the buffer from the other window.</li>
<li>Call <code>avy-goto-char-timer</code>.</li>
<li>Type in “de”. This filters to matches that include “demuxer”.</li>
<li>Call <code>avy-action-yank-whole-line</code>, bound to <code>Y</code>.</li>
<li>Select one of the matches. The line is copied to the buffer.</li>
<li>Fix indentation with <code>just-one-space</code>, bound to <code>M-SPC</code> by default.</li>
</ol>
</div>
</details>
<div><pre><code data-lang="emacs-lisp">(<span>defun</span> <span>avy-action-copy-whole-line</span> (<span>pt</span>)
  (<span>save-excursion</span>
    (<span>goto-char</span> <span>pt</span>)
    (<span>cl-destructuring-bind</span> (<span>start</span> <span>.</span> <span>end</span>)
        (<span>bounds-of-thing-at-point</span> <span>&#39;line</span>)
      (<span>copy-region-as-kill</span> <span>start</span> <span>end</span>)))
  (<span>select-window</span>
   (<span>cdr</span>
    (<span>ring-ref</span> <span>avy-ring</span> <span>0</span>)))
  <span>t</span>)

(<span>defun</span> <span>avy-action-yank-whole-line</span> (<span>pt</span>)
  (<span>avy-action-copy-whole-line</span> <span>pt</span>)
  (<span>save-excursion</span> (<span>yank</span>))
  <span>t</span>)

(<span>setf</span> (<span>alist-get</span> <span>?y</span> <span>avy-dispatch-alist</span>) <span>&#39;avy-action-yank</span>
      (<span>alist-get</span> <span>?w</span> <span>avy-dispatch-alist</span>) <span>&#39;avy-action-copy</span>
      (<span>alist-get</span> <span>?W</span> <span>avy-dispatch-alist</span>) <span>&#39;avy-action-copy-whole-line</span>
      (<span>alist-get</span> <span>?Y</span> <span>avy-dispatch-alist</span>) <span>&#39;avy-action-yank-whole-line</span>)
</code></pre></div><p>Note that Avy actually defines separate commands for this: <code>avy-copy-line</code> and <code>avy-copy-region</code> to copy lines and regions from anywhere in the frame. These are a little faster since they have the <span>action</span> stage baked into the function call. You might be better served by these. But we want to avoid the mental burden of remembering too many top level commands, so we work in two simpler stages: call <code>avy-goto-char-timer</code> (to <span>filter</span> and <span>select</span>) and then dispatch on our selected candidate as we see fit.</p>
<h3 id="move-a-candidate-word-sexp-or-line">Move a candidate word, sexp or line</h3>
<p>Avy calls this “teleport”, I call it “transpose”, either way it’s bound to <code>t</code>. In this demo I move text around the buffer… without moving (much) around the buffer:</p>

<details>
<summary>
Play by play
</summary>
<div>
<ol>
<li>Make some room, type in a space.</li>
<li>Call <code>avy-goto-char-timer</code>.</li>
<li>Filter to candidates that begin with “(&#34;.</li>
<li>Press <code>t</code> to run <code>avy-action-teleport</code></li>
<li>Select the candidate that says “(parametric forcing)&#34;. It is moved over (transposed) to where the point is.</li>
<li>Jump to where it says “DOWNLOADED” in the window with <code>avy-goto-char-timer</code>. This is the only match for the input “down”, so Avy jumps there automatically. You could also just <code>isearch-backwards</code> here.</li>
<li>Call <code>avy-goto-char-timer</code>.</li>
<li>Filter to candidates matching “the”.</li>
<li>Press <code>T</code> to run =avy-action-teleport-line~.</li>
<li>Select a candidate line (the one just below the image). It is moved over (transposed) to where the point is.</li>
</ol>
</div>
</details>
<div><pre><code data-lang="emacs-lisp">(<span>defun</span> <span>avy-action-teleport-whole-line</span> (<span>pt</span>)
    (<span>avy-action-kill-whole-line</span> <span>pt</span>)
    (<span>save-excursion</span> (<span>yank</span>)) <span>t</span>)

(<span>setf</span> (<span>alist-get</span> <span>?t</span> <span>avy-dispatch-alist</span>) <span>&#39;avy-action-teleport</span>
      (<span>alist-get</span> <span>?T</span> <span>avy-dispatch-alist</span>) <span>&#39;avy-action-teleport-whole-line</span>)
</code></pre></div><h3 id="zap-to-a-candidate-position">Zap to a candidate position</h3>
<p>This is built-in and bound to <code>z</code> by default:</p>

<details>
<summary>
Play by play
</summary>
<div>
<ol>
<li>Call <code>avy-goto-char-timer</code></li>
<li>Type in “in”. This shows hints for all matches with “in”, including “In Emacs…&#34;.</li>
<li>Press <code>z</code> to run <code>avy-action-zap</code>.</li>
<li>Select a candidate char, in this case “In Emacs…&#34;. The text between point and the candidate is killed.</li>
</ol>
</div>
</details>
<h3 id="mark-a-candidate-word-or-sexp">Mark a candidate word or sexp</h3>
<p>Also built in, <code>m</code> by default. This isn’t different from jumping to the candidate using Avy and calling <code>mark-sexp</code>, but it <em>is</em> more convenient:</p>

<details>
<summary>
Play by play
</summary>
<div>
<ol>
<li>Call <code>avy-goto-char-timer</code>.</li>
<li>Type in text to filter with, in this case just “(&#34;.</li>
<li>Press <code>m</code> to run <code>avy-action-mark</code>.</li>
<li>Select a candidate word or sexp, in this case <code>(&#34;~/.local/share&#34;)</code>.</li>
<li>Repeat steps 1 to 4 twice to mark other candidates: <code>(data_directory...</code> and <code>RotatingFileHandler</code></li>
</ol>
</div>
</details>
<h3 id="mark-the-region-from-point-to-a-candidate">Mark the region from point to a candidate</h3>
<p>Avy sets the mark before it jumps, so you could use <code>C-x C-x</code> to activate the region, but this saves you the trouble.</p>

<details>
<summary>
Play by play
</summary>
<div>
<ol>
<li>Call <code>avy-goto-char-timer</code>.</li>
<li>Type in text to filter with, in this case “&#39;)&#34;.</li>
<li>Press <code>SPC</code> to run <code>avy-action-mark-to-char</code>.</li>
<li>Select a candidate char. This marks the region from point to the char and moves the point.</li>
<li>Call <code>avy-goto-char-timer</code>.</li>
<li>Type in text to filter with, in this case just a series of spaces.</li>
<li>Press <code>SPC</code> to run <code>avy-action-mark-to-char</code>.</li>
<li>Choose a candidate (series of spaces) that begins a line. This marks the region from point to the line.</li>
</ol>
</div>
</details>
<div><pre><code data-lang="emacs-lisp">(<span>defun</span> <span>avy-action-mark-to-char</span> (<span>pt</span>)
  (<span>activate-mark</span>)
  (<span>goto-char</span> <span>pt</span>))

(<span>setf</span> (<span>alist-get</span> <span>? </span> <span>avy-dispatch-alist</span>) <span>&#39;avy-action-mark-to-char</span>)
</code></pre></div><p>Next, some contextual actions automagicked by Avy:</p>
<h3 id="ispell-a-candidate-word">ispell a candidate word</h3>
<p>This is built-in, bound to <code>i</code> by default.</p>

<details>
<summary>
Play by play
</summary>
<div>
<ol>
<li>Call <code>avy-goto-char-timer</code> (or any other Avy jump command)</li>
<li><span>Type in</span> “can”, this highlights matches for “candidate” (and its misspellings)</li>
<li>Press the <span>dispatch</span> key for <code>avy-action-ispell</code>, set to <code>i</code> by default.</li>
<li><span>Select</span> one of the matches, in this case the misspelled “canddidate” match.</li>
<li>This runs <code>ispell-word</code> on the selection.</li>
<li>Pick the correct spelling.</li>
<li>Call <code>avy-goto-char-timer</code> again.</li>
<li><span>Type in</span> “te”, this highlights the match for “teh” (among others).</li>
<li>Press the <span>dispatch</span> key for <code>avy-action-ispell</code></li>
<li><span>Select</span> the candidate, in this case the “teh” match.</li>
<li>This runs <code>ispell-word</code> again, and “teh” can be corrected.</li>
</ol>
</div>
</details>
<p>You can replace <code>avy-action-ispell</code> (built-in) with a version that automatically picks the top correction for a word, automating the process:</p>
<div><pre><code data-lang="emacs-lisp">(<span>defun</span> <span>avy-action-flyspell</span> (<span>pt</span>)
  (<span>save-excursion</span>
    (<span>goto-char</span> <span>pt</span>)
    (<span>when</span> (<span>require</span> <span>&#39;flyspell</span> <span>nil</span> <span>t</span>)
      (<span>flyspell-auto-correct-word</span>)))
  (<span>select-window</span>
   (<span>cdr</span> (<span>ring-ref</span> <span>avy-ring</span> <span>0</span>)))
  <span>t</span>)

<span>;; Bind to semicolon (flyspell uses C-;)</span>
(<span>setf</span> (<span>alist-get</span> <span>?\;</span> <span>avy-dispatch-alist</span>) <span>&#39;avy-action-flyspell</span>)
</code></pre></div><h3 id="define-a-word">Define a word</h3>
<p>I use the dictionary package for Emacs, and I’m lazy about it:</p>

<details>
<summary>
Play by play
</summary>
<div>
<ol>
<li>Call <code>avy-goto-char-timer</code> (or any other Avy jump command)</li>
<li><span>Type in</span> “non”, this highlights matches for “nonpareil” (among others)</li>
<li>Press the <span>dispatch</span> key for <code>avy-action-define</code>, set to <code>=</code> here</li>
<li><span>Select</span> the candidate, in this case one of the “nonpareil” matches.</li>
<li>This produces the buffer with the definition of “nonpareil”.</li>
<li>Call <code>scroll-other-window</code> (<code>C-M-v</code>) to scroll the dictionary window.</li>
<li>Call <code>avy-goto-char-timer</code> again.</li>
<li><span>Type in</span> “fi”, this highlights the match for “finch” (among others). Note that this match is in another buffer, the one with the definition. We did not have to switch buffers.</li>
<li>Press the <span>dispatch</span> key for <code>avy-action-define</code></li>
<li><span>Select</span> the candidate, in this case the “finch” match.</li>
<li>This produces the buffer with the dictionary definition of “finch”.</li>
</ol>
</div>
</details>
<div><pre><code data-lang="emacs-lisp"><span>;Replace your package manager or preferred dict package</span>
(<span>package-install</span> <span>&#39;dictionary</span>)

(<span>defun</span> <span>dictionary-search-dwim</span> (<span>&amp;optional</span> <span>arg</span>)
  <span>&#34;Search for definition of word at point. If region is active,
</span><span>search for contents of region instead. If called with a prefix
</span><span>argument, query for word to search.&#34;</span>
  (<span>interactive</span> <span>&#34;P&#34;</span>)
  (<span>if</span> <span>arg</span>
      (<span>dictionary-search</span> <span>nil</span>)
    (<span>if</span> (<span>use-region-p</span>)
        (<span>dictionary-search</span> (<span>buffer-substring-no-properties</span>
                            (<span>region-beginning</span>)
                            (<span>region-end</span>)))
      (<span>if</span> (<span>thing-at-point</span> <span>&#39;word</span>)
          (<span>dictionary-lookup-definition</span>)
        (<span>dictionary-search-dwim</span> <span>&#39;</span>(<span>4</span>))))))

(<span>defun</span> <span>avy-action-define</span> (<span>pt</span>)
  (<span>save-excursion</span>
    (<span>goto-char</span> <span>pt</span>)
    (<span>dictionary-search-dwim</span>))
  (<span>select-window</span>
   (<span>cdr</span> (<span>ring-ref</span> <span>avy-ring</span> <span>0</span>)))
  <span>t</span>)

(<span>setf</span> (<span>alist-get</span> <span>?=</span> <span>avy-dispatch-alist</span>) <span>&#39;dictionary-search-dwim</span>)
</code></pre></div><h3 id="look-up-the-documentation-for-a-symbol">Look up the documentation for a symbol</h3>

<details>
<summary>
Play by play
</summary>
<div>
<ol>
<li>Call <code>avy-goto-char-timer</code></li>
<li>Type in text to filter with, in this case “pc”.</li>
<li>Press <code>H</code> to run <code>avy-action-helpful</code>.</li>
<li>Select a candidate phrase, in this case “pcase-lambda”. This pulls up a documentation buffer for this symbol.</li>
<li><code>scroll-other-window</code> with <code>C-M-v</code> to scroll the help buffer.</li>
<li>call <code>avy-goto-char-timer</code></li>
<li>Type in text to filter with, in this case “ma”.</li>
<li>Press <code>H</code> to run <code>avy-action-helpful</code>.</li>
<li>Select a candidate phrase, in this case “macroexp-parse-body”. Note that this is matched in the other (help) window. This pulls up the documentation for this symbol.</li>
<li>Repeat steps 5-9 to find the documentation of another symbol, in this case <code>memq</code>.</li>
</ol>
</div>
</details>
<div><pre><code data-lang="emacs-lisp"><span>;Replace with your package manager or help library of choice</span>
(<span>package-install</span> <span>&#39;helpful</span>)

(<span>defun</span> <span>avy-action-helpful</span> (<span>pt</span>)
  (<span>save-excursion</span>
    (<span>goto-char</span> <span>pt</span>)
    (<span>helpful-at-point</span>))
  (<span>select-window</span>
   (<span>cdr</span> (<span>ring-ref</span> <span>avy-ring</span> <span>0</span>)))
  <span>t</span>)

(<span>setf</span> (<span>alist-get</span> <span>?H</span> <span>avy-dispatch-alist</span>) <span>&#39;avy-action-helpful</span>)
</code></pre></div><h3 id="google-search-for-a-word-or-sexp">Google search for a word or sexp<sup id="fnref:4"><a href="#fn:4" role="doc-noteref">4</a></sup></h3>
<p>You’ll need an Emacs feature that can search Google for you. There <a href="https://melpa.org/#/?q=web%20search">are</a> <a href="https://melpa.org/#/?q=google%20search">several</a>. I use a CLI program named <a href="https://github.com/Bugswriter/tuxi%20">Tuxi</a> for this, and it’s pretty handy:</p>

<details>
<summary>
Play by play
</summary>
<div>
<ol>
<li>Call <code>avy-goto-char-timer</code> (or any other Avy jump command)</li>
<li><span>Type in</span> “ema”, this highlights matches for “Emacs” (among others)</li>
<li>Press the <span>dispatch</span> key for <code>avy-action-tuxi</code>, set to <code>C-=</code> here</li>
<li><span>Select</span> the candidate, in this case one of the “Emacs” matches.</li>
<li>This produces the buffer with the Google’s description of Emacs.</li>
<li>Call <code>avy-goto-char-timer</code> again.</li>
<li><span>Type in</span> “vi”, this highlights the match for “Vi” (among others). Note that this match is in another buffer, the one with the Google result. We did not have to switch buffers.</li>
<li>Press the <span>dispatch</span> key for <code>avy-action-tuxi</code></li>
<li><span>Select</span> the candidate, in this case the “Vi” match.</li>
<li>This produces the buffer with Google’s description of Vi.</li>
<li>Repeat steps 6-10 but selecting the string “POSIX” instead.</li>
</ol>
</div>
</details>
<p>Now: We could continue populating <code>avy-dispatch-alist</code> with functions to do increasingly arcane contextual actions, but let’s take a step back. We want a list of easily callable actions on pieces of semantically classified buffer text… now where have we seen <a href="https://karthinks.com/software/fifteen-ways-to-use-embark">something like this</a> before?</p>
<h2 id="avy-plus-embark-any-action-anywhere">Avy + Embark:  Any action, anywhere</h2>
<p>Avy and Embark plug into each other like LEGO blocks. Here are a couple of examples:</p>
<h3 id="highlight-occurrences">Highlight occurrences</h3>
<p>In this demo I highlight some keywords in a busy LaTeX document, then visit the bibliography entry of a citation key with Avy and Embark, without ever manually moving the cursor:</p>

<details>
<summary>
Play by play
</summary>
<div>
<ol>
<li>Call <code>avy-goto-char-timer</code> (or any other Avy jump command)</li>
<li>Type in “flo” to filter matches that include “Floquet”</li>
<li>Run <code>avy-action-embark</code> with <code>o</code>.</li>
<li>Select one of the matches for “Floquet”. This runs Embark on the match.</li>
<li>Select the <code>embark-toggle-highlight</code> action with <code>H</code>.</li>
<li>Repeat 1-5 to highlight “Parametric”.</li>
<li>Call <code>avy-goto-char-timer</code> again.</li>
<li>Type in “na” to match one of the citation keys (among others)</li>
<li>Run <code>avy-action-embark</code> with <code>o</code>.</li>
<li>Select the citation key match. This runs Embark on it.</li>
<li>Choose the bibtex-action to visit the Bib file, bound to <code>e</code> by the bibtex-actions package.</li>
</ol>
</div>
</details>
<h3 id="run-a-skein-through-emacs-help-systems">Run a skein through Emacs’ help systems</h3>
<p>In this demo I explore my way through a package with Avy and Embark, threading help, apropos and customization buffers, again without manually moving the cursor.</p>

<details>
<summary>
Play by play
</summary>
<div>
<ol>
<li>Call <code>avy-goto-char-timer</code>.</li>
<li>Type in text to filter with, in this case “root”.</li>
<li>Run <code>avy-action-embark</code> with <code>o</code>.</li>
<li>Select “project-root”, one of the matches. This runs Embark on the match.</li>
<li>Press <code>h</code>, which makes Embark run <code>describe-symbol</code> on the match. This opens up a help buffer for the function. (Note: we bound a help command to Avy earlier, we could have used that.)</li>
<li>Press <code>C-M-v</code> (<code>scroll-other-window</code>) to scroll the help buffer.</li>
<li>Call <code>avy-goto-char-timer</code> again.</li>
<li>Type in text to filter with, in this case “proj”.</li>
<li>Run <code>avy-action-embark</code> with <code>o</code>.</li>
<li>Select “project-x”, which is one of the matches. This runs Embark on the match.</li>
<li>Call <code>embark-cycle</code> to change the target from a file (named “project-x”) to a library (named “project-x”)</li>
<li>Press <code>h</code>, which makes Embark run <code>finder-commentary</code> on the project-x library. This opens a buffer with some commentary.</li>
<li>Repeat the previous steps to run Embark on “project-x” again. This time, run the <code>apropos-library</code> action with <code>a</code> in Embark. This opens an apropos buffer.</li>
<li>Repeat the previous steps to run Embark again, this time on the symbol “project-x-local-identfier”.</li>
<li>Choose the <code>customize-variable</code> action with <code>u</code> in Embark. This opens a customization buffer for the variable <code>project-x-local-identifier</code>.</li>
</ol>
</div>
</details>
<h3 id="a-division-of-responsibility">A division of responsibility</h3>
<p>We save ourselves a lot of redundancy and reuse muscle memory here. Avy provides its unique means of filtering and Embark does what it does best, run actions! The intermediate job of candidate selection is shared between Avy and Embark: Avy specifies the general location of the candidate, and Embark figures out the semantic unit at that position on which to act. The fact that the <span>Filter</span> → <span>Select</span> → <span>Act</span> process is helpfully chunked this way by Avy makes the elisp required to integrate the two completely trivial<sup id="fnref:5"><a href="#fn:5" role="doc-noteref">5</a></sup>:</p>
<div><pre><code data-lang="emacs-lisp">(<span>defun</span> <span>avy-action-embark</span> (<span>pt</span>)
  (<span>unwind-protect</span>
      (<span>save-excursion</span>
        (<span>goto-char</span> <span>pt</span>)
        (<span>embark-act</span>))
    (<span>select-window</span>
     (<span>cdr</span> (<span>ring-ref</span> <span>avy-ring</span> <span>0</span>))))
  <span>t</span>)

(<span>setf</span> (<span>alist-get</span> <span>?.</span> <span>avy-dispatch-alist</span>) <span>&#39;avy-action-embark</span>)
</code></pre></div><p>Note that if you don’t like the candidate that Embark picks as the unit to act on, you can call <code>embark-cycle</code> to cycle through the other targets.</p>
<p>All that, and we didn’t even move the point.<sup id="fnref:6"><a href="#fn:6" role="doc-noteref">6</a></sup></p>
<h2 id="avy-plus-isearch-seek-then-jump">Avy + Isearch: Seek, then jump</h2>
<p>Isearch and Avy have different strengths: Avy jumps quickly to any <em>visible</em> element in any window, Isearch to any matching candidate in this <em>buffer</em>. Avy is faster when you want to cover some distance in a jump, Isearch when you’re moving a small distance or a very large one. Avy is useful when your eyes are already on a target, Isearch when you’re looking for one. But you don’t have you choose. You can handily combine the two by restricting Avy’s candidate pool to Isearch candidates: now you can start Isearch and finish with Avy:</p>
<div><pre><code data-lang="emacs-lisp">(<span>define-key</span> <span>isearch-mode-map</span> (<span>kbd</span> <span>&#34;M-j&#34;</span>) <span>&#39;avy-isearch</span>)
</code></pre></div><p>Again, consciously deciding which of the two commands to call every time is a bad idea. It’s not a bad idea to always Isearch and switch to Avy when necessary:</p>

<details>
<summary>
Play by play
</summary>
<div>
<ol>
<li>Start Isearch with <code>C-s</code>. In the video I switched to <code>isearch-regexp</code> with <code>M-r</code>.</li>
<li>Type in a phrase to search for. In the video I typed in a regexp that ends in “-region”.</li>
<li>Navigate Isearch matches with <code>C-s</code>, recentering the screen with <code>C-l</code> if necessary.</li>
<li>Call <code>avy-goto-char-timer</code>. The candidate pool limits to the Isearch matches.</li>
<li>Pick an Isearch match to jump to as before.</li>
</ol>
</div>
</details>
<p>At least, that’s the usual pitch.</p>
<p>For us, however, “jump” in that description is replaced with “act”. We can <em>act</em> on any visible Isearch candidate with one of the above actions. Kill text between two isearch matches? Copy the previous line that contains a word to the current location? Check. Essentially we <span>filter</span> with Isearch and <span>select</span> and <span>Act</span> with Avy, indirectly decoupling Filter from the other two actions in Isearch.</p>
<h2 id="when-avy-is-too-clever">When Avy is too clever</h2>
<p>This usage pattern has a failure mode. When there’s a single match, Avy jumps to the location and does not offer any actions. Oops.</p>
<p>While it’s possible to force Avy to show a selection char/hint for a single match, the default DWIM behavior is usually desirable. There are two options:</p>
<ul>
<li>
<p>Filter candidates conservatively, for example by typing in a single character. Using <code>avy-goto-char</code> or <code>avy-goto-char-2</code> will almost always result in more than one match, preventing this problem. If you use one of the timer-based Avy commands, you can vary how much text to filter by on the fly.</p>
</li>
<li>
<p>Carry out the action the old-fashioned way after jumping, then jump back by popping the mark Avy sets. You can do this with the default <code>set-mark-command</code> (<code>C-u C-SPC</code>)<sup id="fnref:7"><a href="#fn:7" role="doc-noteref">7</a></sup>. You can do this for most commands that cause the point to jump, including Isearch. Vim users have the jumplist, accessed with <code>C-o</code>, and the changelist, accessed with <code>g;</code>.</p>
<p>In this demo I jump twice with Avy to edit text and then chain jump my way back to where I started:</p>

<details>
<summary>
Play by play
</summary>
<div>
<ol>
<li>Call <code>avy-goto-char-timer</code> and jump to a candidate (or end up there by accident)</li>
<li>Make your edits (or not).</li>
<li>Call <code>set-mark-command</code> with a prefix arg (<code>C-u C-SPC</code>) to jump back. You can chain these jumps.</li>
</ol>
</div>
</details>
</li>
</ul>
<h2 id="what-s-the-point-anyway">What’s the Point, anyway</h2>
<p>This section is for the pedants.</p>
<p>I’ve been using “point” and “cursor” interchangeably in this article. Yes, I’m aware of the distinction.</p>
<p>One of the illustrated advantages of using Avy to filter and select text to run actions on is that you can do it without moving the cursor. But as the above code snippets make clear with their <code>save-excursion</code> blocks, we do move the point, mostly just invisibly. The point is where the “gap” in Emacs’ gap-buffer data structure is located, so Emacs commands are all oriented around acting on the point, and usually more efficient when doing so.</p>
<p>Yes: it’s much faster to run an Avy action on some text in a different window than it is to call <code>other-window</code>, then Isearch to the text, run an action and switch back. But to me, the Point (har) is primarily a useful abstraction for writing elisp. The real advantage of Avy is in how it lets me think about the contents of the entire frame in the powerful <span>Filter</span> → <span>select</span> → <span>Act</span> paradigm. The fact that you can do this without the mental context switch involved in expressly navigating around the window or frame is a bonus.</p>
<h2 id="remembering-to-avy">Remembering to Avy</h2>
<p>In some ways, using Avy to jump around the screen is like using a mouse. You could make the case, quite successfully, that the mouse is faster here and thus preferable. This unfavorable comparison evaporates when you add your dispatch actions into the mix. Yanking a line from another window or running goto-definition on a symbol on the other edge of the screen is much faster with Avy than with the mouse selection/right-click business. And this is without taking into account the disruptive effect of frequent context switching, the reason to prefer all keyboard navigation (or all mouse, when possible) in the first place.</p>
<h3 id="the-smell-test">The smell test</h3>
<p>However, using Avy <em>actions</em> is a new way of interacting with text on your screen even if you already use Avy to jump around. To remember to use Avy actions or find new ones, I look for “smells” in my day-to-day Emacs usage:</p>
<ul>
<li>Switching windows multiple times to land my cursor on some text</li>
<li>Isearching through more than three matches to jump to the right one</li>
<li>Moving the point a long distance to run a lookup command</li>
<li>Activating the mark manually (<code>C-SPC</code>) all the time</li>
<li>Jumping to locations to delete single words</li>
</ul>
<h3 id="buried-in-keymaps">Buried in keymaps</h3>
<p>The other sense of “remembering to Avy” is that piling a new abstraction onto simple text editing means you have to learn a new keymap. Emacs already has too many of those!</p>
<p>This is true. But the effort is greatly mitigated by a choice of keys that is sensible <em>to you</em>. In the above code snippets, I made choices that mimic my Emacs’ keybindings (which are close to the default ones) so I don’t have to remember anything new:</p>
<table>
<thead>
<tr>
<th><strong>Action</strong></th>
<th><strong>Avy keybinding</strong></th>
<th><strong>Emacs keybinding</strong></th>
<th><strong>Emacs Default?</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Kill</td>
<td><code>k</code>, <code>K</code> (line)</td>
<td><code>C-k</code></td>
<td>Yes</td>
</tr>
<tr>
<td>Copy</td>
<td><code>w</code>, <code>W</code> (line)</td>
<td><code>M-w</code></td>
<td>Yes</td>
</tr>
<tr>
<td>Yank</td>
<td><code>y</code>, <code>Y</code> (line)</td>
<td><code>C-y</code></td>
<td>Yes</td>
</tr>
<tr>
<td>Transpose</td>
<td><code>t</code>, <code>T</code> (line)</td>
<td><code>C-t</code>, <code>M-t</code> etc</td>
<td>Yes</td>
</tr>
<tr>
<td>Zap</td>
<td><code>z</code></td>
<td><code>M-z</code></td>
<td>Yes</td>
</tr>
<tr>
<td>Flyspell</td>
<td><code>;</code></td>
<td><code>C-;</code></td>
<td>Yes</td>
</tr>
<tr>
<td>Mark</td>
<td><code>m</code></td>
<td><code>m</code> in special buffers</td>
<td>Yes</td>
</tr>
<tr>
<td>Activate region</td>
<td><code>SPC</code></td>
<td><code>C-SPC</code></td>
<td>Yes</td>
</tr>
<tr>
<td>Dictionary</td>
<td><code>=</code></td>
<td><code>C-h =</code></td>
<td>No</td>
</tr>
<tr>
<td>Google search</td>
<td><code>C-=</code></td>
<td><code>C-h C-=</code></td>
<td>No</td>
</tr>
<tr>
<td>Embark</td>
<td><code>o</code></td>
<td><code>C-o</code></td>
<td>No</td>
</tr>
</tbody>
</table>
<p>You can go beyond the mnemonic and simply reuse the same keybindings you use in regular editing, trading off a slightly longer key sequence for maximally reusing your muscle memory. If you’re an Embark user, you don’t even need the above keys, just one to call <code>embark-act</code>.</p>
<h2 id="the-missing-pieces">The missing pieces</h2>
<p>There are two common editing actions that still require manually moving the point elsewhere, perhaps to another window:</p>
<ul>
<li>
<p>Searching or jumping to the contents of other windows beyond the confines of the screen. This has a simple solution:</p>
<details>
<summary>
Isearching in other windows
</summary>
<div>
<div><pre><code data-lang="emacs-lisp">(<span>defun</span> <span>isearch-forward-other-window</span> (<span>prefix</span>)
    <span>&#34;Function to isearch-forward in other-window.&#34;</span>
    (<span>interactive</span> <span>&#34;P&#34;</span>)
    (<span>unless</span> (<span>one-window-p</span>)
      (<span>save-excursion</span>
        (<span>let</span> ((<span>next</span> (<span>if</span> <span>prefix</span> <span>-1</span> <span>1</span>)))
          (<span>other-window</span> <span>next</span>)
          (<span>isearch-forward</span>)
          (<span>other-window</span> (<span>-</span> <span>next</span>))))))

(<span>defun</span> <span>isearch-backward-other-window</span> (<span>prefix</span>)
  <span>&#34;Function to isearch-backward in other-window.&#34;</span>
  (<span>interactive</span> <span>&#34;P&#34;</span>)
  (<span>unless</span> (<span>one-window-p</span>)
    (<span>save-excursion</span>
      (<span>let</span> ((<span>next</span> (<span>if</span> <span>prefix</span> <span>1</span> <span>-1</span>)))
        (<span>other-window</span> <span>next</span>)
        (<span>isearch-backward</span>)
        (<span>other-window</span> (<span>-</span> <span>next</span>))))))

(<span>define-key</span> <span>global-map</span> (<span>kbd</span> <span>&#34;C-M-s&#34;</span>) <span>&#39;isearch-forward-other-window</span>)
(<span>define-key</span> <span>global-map</span> (<span>kbd</span> <span>&#34;C-M-r&#34;</span>) <span>&#39;isearch-backward-other-window</span>)
</code></pre></div></div>
</details>
<p>In keeping with <code>C-M-v</code> to scroll the other window, you can Isearch the other window with <code>C-M-s</code> without switching to it<sup id="fnref:8"><a href="#fn:8" role="doc-noteref">8</a></sup>. If you’re feeling adventurous, replace <code>(other-window next)</code> in the above functions with <code>(ace-window)</code>.</p>
<p>You can call Avy from Isearch as before, to run actions on essentially any text in the other-window’s buffer.</p>
</li>
<li>
<p>Copying regions of text. This has an Avy-based solution: <code>avy-copy-region</code>. I promised at the beginning, however, that you would only need to call one Avy command. For now you would do this the boring way, using Avy only to make shorter jumps or using Isearch+Avy. The more elispy solution will have to wait until part II of this series.</p>
</li>
</ul>
<p>This post primarily concerned itself with the <span>Act</span> part as it connects with the ideas in the the previous one about <a href="https://karthinks.com/software/fifteen-ways-to-use-embark">ways to use Embark</a>. But Avy is composed of modular pieces that makes it suitable for a wide variety of <span>Filter</span> → <span>Select</span> applications as well. In part II of this series, we will dig into the Avy API and see how to create unique commands.</p>


    </div></div>
  </body>
</html>
