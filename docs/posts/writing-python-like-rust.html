<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://oatzy.github.io/2020/05/10/writing-python-like-rust.html">Original</a>
    <h1>Writing Python Like Rust</h1>
    
    <div id="readability-page-1" class="page"><div>
        <div>
  
  <p><span>10 May 2020</span></p><p><em>Or, how I learned to stop worrying and love the type annotations.</em></p>

<p>Listen, I didn’t plan on making a whole <em>‘writing X like Y’</em> series. But here we are.</p>

<p>I’ve recently been working on a new project at work - my first project in pure Python 3. Meaning, I get to play with all the new toys!</p>

<p>And as I was writing this code, it struck me that was borrowing a lot of tricks from Rust (and a little Go).</p>



<p>One thing I’ve really gotten into in Python 3 is <a href="https://www.python.org/dev/peps/pep-0484/">type annotations</a>.</p>

<p>The format is quite like Rust</p>

<div><div><pre><code><span>def</span> <span>repeat</span><span>(</span><span>text</span><span>:</span> <span>str</span><span>,</span> <span>number</span><span>:</span> <span>int</span><span>)</span> <span>-&gt;</span> <span>str</span><span>:</span> <span>...</span>
</code></pre></div></div>

<div><div><pre><code><span>fn</span> <span>repeat</span><span>(</span><span>text</span><span>:</span> <span>&amp;</span><span>str</span><span>,</span> <span>number</span><span>:</span> <span>usize</span><span>)</span> <span>-&gt;</span> <span>&amp;</span><span>str</span> <span>{</span><span>...</span><span>}</span>
</code></pre></div></div>
<p><em>(casually ignoring lifetimes)</em></p>

<p>Unlike in a strongly typed language, the python type annotations aren’t enforced. You run a static checker like <a href="http://mypy-lang.org/">mypy</a>, which is kind of like a compile-time check. But there’s no guarantee when the code is run, that the type annotations will be respected (by external code).</p>

<p>Still, I’ve found that type checking has caught some potentially dumb bugs. In particular, it’s good at catching <code>Optional</code>s, where I haven’t checked/dealt with the case where the value might be <code>None</code>. That’s one thing I could get sloppy about in python 2 (<em>“it probably won’t be None in practice”</em>)</p>



<p>Rust and Go (and C) don’t have objects, in the traditional sense. Instead, they have structs.</p>

<p>Structs are basically containers for a collection of values.</p>

<p>The biggest roadblock to doing something like structs in python was all the boilerplate. Bu this has been greatly simplified by introduction of <a href="https://docs.python.org/3/library/dataclasses.html">dataclasses</a></p>

<p>Dataclasses were officially added in python 3.7, but is available in earlier version via a <a href="https://pypi.org/project/dataclasses/">backport</a>. There’s also <a href="https://pypi.org/project/attrs/">attrs</a>, which does basically the same thing.</p>

<p>Much like structs in Rust and Go, you declare your dataclass with its fields and the types of those fields</p>

<div><div><pre><code><span>@</span><span>dataclass</span>
<span>class</span> <span>Event</span><span>:</span>
    <span>id</span><span>:</span> <span>str</span>
    <span>type</span><span>:</span> <span>EventType</span>
    <span>timestamp</span><span>:</span> <span>datetime</span>
    <span>user</span><span>:</span> <span>str</span>
</code></pre></div></div>

<p>All the other stuff like the <code>__init__</code> method, getters, setters, string formatter, etc. are generated for you.</p>

<p>Of course, one advantage Python has over Rust in this case is being able to give fields default values.</p>



<p>Traits and interfaces define behaviours. The python equivalent is <a href="https://www.python.org/dev/peps/pep-0544/">Protocols</a>.</p>

<p>These were officially introduced in python 3.8, so for earlier versions you’ll need the <a href="https://pypi.org/project/typing-extensions/">typing_extensions</a> backport.</p>

<div><div><pre><code><span>class</span> <span>Reader</span><span>(</span><span>Protocol</span><span>):</span>

    <span>def</span> <span>read</span><span>(</span><span>self</span><span>,</span> <span>size</span><span>:</span> <span>int</span> <span>=</span> <span>-</span><span>1</span><span>)</span> <span>-&gt;</span> <span>str</span><span>:</span> <span>...</span>


<span>def</span> <span>print_contents</span><span>(</span><span>r</span><span>:</span> <span>Reader</span><span>):</span>
    <span>print</span><span>(</span><span>r</span><span>.</span><span>read</span><span>())</span>


<span>with</span> <span>open</span><span>(</span><span>&#39;example.txt&#39;</span><span>,</span> <span>&#39;r&#39;</span><span>)</span> <span>as</span> <span>f</span><span>:</span>
    <span>print_contents</span><span>(</span><span>f</span><span>)</span>
</code></pre></div></div>

<p>In the above, the open file instance doesn’t explicitly sub-class the <code>Reader</code> class, but because it implements a <code>read</code> method which matches the protocol, it passes type checking.</p>

<p>In this sense, Protocols are more like Go than Rust. In Rust, you have to explicitly <code>impl Trait for Struct</code>, where as in python and Go it’s implicit.</p>



<p>What I like about the Rust (and to a lesser extent, Go) approach to error handling is, you know up front if and what errors a function might return. And additionally, the compiler forces you to at least consider how you’re going to deal with it.</p>

<p>By comparison, the python approach to dealing with exceptions is quite chunky</p>

<div><div><pre><code><span>try</span><span>:</span>
    <span>function</span><span>()</span>
<span>except</span> <span>SomeException</span><span>:</span>
    <span># etc
</span></code></pre></div></div>
<p>I think this, in fact, encourages just letting exceptions bubble up, rather than fussing about with handling them.</p>

<p>(Of course, if you’re the sort of person who deals with errors in rust by just slapping <code>?</code> on anything that might fail, then you’re more or less just doing exceptions)</p>

<p>There is a 3rd party library - <a href="https://github.com/dry-python/returns">returns</a> - that lets you do Rust-style <code>Result</code> types. But that approach is quite ‘unpythonic’.</p>

<p>In spite of the topic of this blog, I think you should always aim to write code which is idiomatic to the language you’re using. If only so it’s accessible to whoever has to maintain your code after you’re gone.</p>



<ul>
  <li>Python 3.4 introduces <a href="https://docs.python.org/3/library/enum.html">enums</a> into the standard library. But these only support primitive types (ints, strings) - sort of like C or Java.</li>
</ul>

<p>One thing I miss from Rust is its ‘richer’ <a href="https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html">enums</a>, and pattern matching - what the functional programmers would call <a href="https://en.wikipedia.org/wiki/Tagged_union">sum types</a></p>

<p>I did find a 3rd party library for <a href="https://pypi.org/project/sumtypes/">sumtypes</a>. I’m on the fence about whether this is pythonic. Also, I’d like to see a version using <code>dataclasses</code>, rather than <code>attrs</code></p>

<ul>
  <li>
    <p><a href="https://docs.python.org/3/library/pathlib.html">pathlib</a> is a revelation. Way more pleasant than working with strings and <code>os.path</code>. And functionally, it’s quite similar to rust <a href="https://doc.rust-lang.org/std/path/struct.Path.html">Path</a></p>
  </li>
  <li>
    <p>Rust does <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html">iterators</a> as chains, e.g.</p>
  </li>
</ul>

<div><div><pre><code><span>numbers</span><span>.iter</span><span>()</span><span>.filter</span><span>(|</span><span>x</span><span>|</span> <span>x</span> <span>%</span> <span>2</span> <span>==</span> <span>0</span><span>)</span><span>.map</span><span>(|</span><span>x</span><span>|</span> <span>x</span> <span>+</span> <span>1</span><span>)</span><span>.sum</span><span>()</span>
</code></pre></div></div>

<p>And there are 3rd party libraries, like <a href="https://iterchain.readthedocs.io/en/latest/">iterchain</a> that will let you do the same sort of thing in python. But again, this isn’t really ‘pythonic’; the ‘most’ idiomatic way would be with list comprehension</p>

<div><div><pre><code><span>sum</span><span>(</span><span>x</span> <span>+</span> <span>1</span> <span>for</span> <span>x</span> <span>in</span> <span>numbers</span> <span>if</span> <span>x</span> <span>%</span> <span>2</span> <span>==</span> <span>0</span><span>)</span>
</code></pre></div></div>



<p>At this point, you’re maybe wondering why we didn’t just write the project in Rust?</p>

<p>Maybe if the python version goes down well, we’ll get an opportunity to, as the kids say, ‘rewrite it in rust’.</p>

<p>Chris</p>

<p><em>[By the transitive property, can we write bash scripts like rust..?]</em></p>

</div>



      </div></div>
  </body>
</html>
