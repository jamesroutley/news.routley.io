<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.joshwcomeau.com/react/usememo-and-usecallback/">Original</a>
    <h1>Understanding UseMemo and UseCallback</h1>
    
    <div id="readability-page-1" class="page"><article><a id="introduction"><h2>Introduction</h2></a><p>If you&#39;ve struggled to make sense of <code>useMemo</code> and <code>useCallback</code>, you&#39;re not alone! I&#39;ve spoken with <em>so many</em> React devs who have been scratching their heads about these two hooks.</p><p>My goal in this blog post is to clear up all of this confusion. We&#39;ll learn what they do, why they&#39;re useful, and how to get the most out of them.</p><p>Let&#39;s go!</p><div><h2><a name="the-basic-idea" id="the-basic-idea" href="#the-basic-idea"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg><p>Link to this heading</p></a>The basic idea</h2></div><p>Alright, so let&#39;s start with <code>useMemo</code>.</p><p>The fundamental idea with <code>useMemo</code> is that it allows us to <em>‚Äúremember‚Äù</em> a computed value between renders.</p><p>This definition requires some unpacking. In fact, it requires a pretty sophisticated mental model of how React works! So let&#39;s address that first.</p><p>The main thing that React does is keep our UI in sync with our application state. The tool that it uses to do this is called a ‚Äúre-render‚Äù.</p><p>Each re-render is a snapshot of what the application&#39;s UI should look like at a given moment in time, based on the current application state. We can think of it like a stack of photographs, each one capturing how things looked given a specific value for every state variable.</p><div></div><p>Each ‚Äúre-render‚Äù produces a mental picture of what the DOM should look like, based on the current state. In the little demo above, it&#39;s pictured as HTML, but in reality it&#39;s a bunch of JS objects. This is sometimes called the <em>‚Äúvirtual DOM‚Äù</em>, if you&#39;ve heard that term.</p><p>We don&#39;t directly tell React which DOM nodes need to change. Instead, we tell React what the UI <em>should be</em> based on the current state. By re-rendering, React creates a new snapshot, and it can figure out what needs to change by comparing snapshots, like playing a ‚Äúfind the differences‚Äù game.</p><p>React is heavily optimized out of the box, and so <em>in general</em>, re-renders aren&#39;t a big deal. But, in certain situations, these snapshots <em>do</em> take a while to create. This can lead to performance problems, like the UI not updating quickly enough after the user performs an action.</p><p>Fundamentally, <code>useMemo</code> and <code>useCallback</code> are tools built to help us optimize re-renders. They do this in two ways:</p><ol><li><p>Reducing the amount of work that needs to be done in a given render.</p></li><li><p>Reducing the number of times that a component needs to re-render.</p></li></ol><p>Let&#39;s talk about these strategies, one at a time.</p><div><h2><a name="use-case-1-heavy-computations" id="use-case-1-heavy-computations" href="#use-case-1-heavy-computations"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg><p>Link to this heading</p></a>Use case 1: Heavy computations</h2></div><p>Let&#39;s suppose we&#39;re building a tool to help users find all of the prime numbers between 0 and <code>selectedNum</code>, where <code>selectedNum</code> is a user-supplied value. A prime number is a number that can only be divided by 1 and itself, like 17.</p><p>Here&#39;s one possible implementation:</p><div><div data-id="prime-number-initial" data-can-be-annotated="false"><div data-is-fullscreened="false"><div><div><header><p>Code Playground<!-- --> </p><div><p><abbr title="Reset code"><div><div><div><div role="progressbar" aria-valuenow="false" aria-valuemin="0" aria-valuemax="90"></div></div></div></div></abbr><abbr title="Format code using Prettier"></abbr><abbr title="Open in CodeSandbox"><a href="https://codesandbox.io/api/v1/sandboxes/define?undefined" rel="noreferrer noopener" target="_blank" title="Open in CodeSandbox"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><polyline points="7.5 4.21 12 6.81 16.5 4.21"></polyline><polyline points="7.5 19.79 7.5 14.6 3 12"></polyline><polyline points="21 12 16.5 14.6 16.5 19.79"></polyline><polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline><line x1="12" y1="22.08" x2="12" y2="12"></line></svg><p>Open in CodeSandbox</p></a></abbr></p></div></header><div><div><div><div><div aria-describedby="enter-instructions-:R1k5laim:" aria-label="Code Editor for App.js" role="group" tabindex="0" translate="no"><pre><span>import</span> <span>React</span> <span>from</span> <span>&#39;react&#39;</span><span>;</span>

<span>function</span> <span>App</span><span>(</span><span>)</span> <span>{</span>
  <span>// We hold the user&#39;s selected number in state.</span>
  <span>const</span> <span>[</span><span>selectedNum</span><span>,</span> <span>setSelectedNum</span><span>]</span> = <span>React</span>.<span>useState</span><span>(</span><span>100</span><span>)</span><span>;</span>
  
  <span>// We calculate all of the prime numbers between 0 and the</span>
  <span>// user&#39;s chosen number, `selectedNum`:</span>
  <span>const</span> <span>allPrimes</span> = <span>[</span><span>]</span><span>;</span>
  <span>for</span> <span>(</span><span>let</span> <span>counter</span> = <span>2</span><span>;</span> <span>counter</span> &lt; <span>selectedNum</span><span>;</span> <span>counter</span>++<span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>isPrime</span><span>(</span><span>counter</span><span>)</span><span>)</span> <span>{</span>
      <span>allPrimes</span>.<span>push</span><span>(</span><span>counter</span><span>)</span><span>;</span>
    <span>}</span>
  <span>}</span>
  
  <span>return</span> <span>(</span>
    <span>&lt;</span><span>&gt;</span>
      <span>&lt;</span><span>form</span><span>&gt;</span>
        <span>&lt;</span><span>label</span> <span>htmlFor</span>=<span>&#34;num&#34;</span><span>&gt;</span>Your number:<span>&lt;/</span><span>label</span><span>&gt;</span>
        <span>&lt;</span><span>input</span>
          <span>type</span>=<span>&#34;number&#34;</span>
          <span>value</span>=<span>{</span><span>selectedNum</span><span>}</span>
          <span>onChange</span>=<span>{</span><span>(</span><span>event</span><span>)</span> <span>=&gt;</span> <span>{</span>
            <span>// To prevent computers from exploding,</span>
            <span>// we&#39;ll max out at 100k</span>
            <span>let</span> <span>num</span> = <span>Math</span>.<span>min</span><span>(</span><span>100_000</span><span>,</span> <span>Number</span><span>(</span><span>event</span>.<span>target</span>.<span>value</span><span>)</span><span>)</span><span>;</span>
            
            <span>setSelectedNum</span><span>(</span><span>num</span><span>)</span><span>;</span>
          <span>}</span><span>}</span>
        <span>/&gt;</span>
      <span>&lt;/</span><span>form</span><span>&gt;</span>
      <span>&lt;</span><span>p</span><span>&gt;</span>
        There are <span>{</span><span>allPrimes</span>.<span>length</span><span>}</span> prime(s) between 1 and <span>{</span><span>selectedNum</span><span>}</span>:
        <span>{</span><span>&#39; &#39;</span><span>}</span>
        <span>&lt;</span><span>span</span> <span>className</span>=<span>&#34;prime-list&#34;</span><span>&gt;</span>
          <span>{</span><span>allPrimes</span>.<span>join</span><span>(</span><span>&#39;, &#39;</span><span>)</span><span>}</span>
        <span>&lt;/</span><span>span</span><span>&gt;</span>
      <span>&lt;/</span><span>p</span><span>&gt;</span>
    <span>&lt;/</span><span>&gt;</span>
  <span>)</span><span>;</span>
<span>}</span>

<span>// Helper function that calculates whether a given</span>
<span>// number is prime or not.</span>
<span>function</span> <span>isPrime</span><span>(</span><span>n</span><span>)</span><span>{</span>
  <span>const</span> <span>max</span> = <span>Math</span>.<span>ceil</span><span>(</span><span>Math</span>.<span>sqrt</span><span>(</span><span>n</span><span>)</span><span>)</span><span>;</span>
  
  <span>if</span> <span>(</span><span>n</span> === <span>2</span><span>)</span> <span>{</span>
    <span>return</span> <span>true</span><span>;</span>
  <span>}</span>
  
  <span>for</span> <span>(</span><span>let</span> <span>counter</span> = <span>2</span><span>;</span> <span>counter</span> &lt;= <span>max</span><span>;</span> <span>counter</span>++<span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>n</span> % <span>counter</span> === <span>0</span><span>)</span> <span>{</span>
      <span>return</span> <span>false</span><span>;</span>
    <span>}</span>
  <span>}</span>

  <span>return</span> <span>true</span><span>;</span>
<span>}</span>

<span>export</span> <span>default</span> <span>App</span><span>;</span></pre></div></div></div></div></div><div><div></div><div><div><div><div></div></div></div></div></div></div></div></div></div></div><p>I don&#39;t expect you to read every line of code here, so here are the relevant highlights:</p><ul><li><span><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg></span><p>We have a single piece of state, a number called <code>selectedNum</code>.</p></li><li><span><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg></span><p>Using a <code>for</code> loop, we manually calculate all of the prime numbers between 0 and <code>selectedNum</code>.</p></li><li><span><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg></span><p>We render a controlled number input, so the user can change <code>selectedNum</code>.</p></li><li><span><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg></span><p>We show the user all of the prime numbers that we calculated.</p></li></ul><p><strong>This code requires a significant amount of computation.</strong> If the user picks a large <code>selectedNum</code>, we&#39;ll need to go through <em>tens of thousands</em> of numbers, checking if each one is prime. And, while there <em>are</em> more efficient prime-checking algorithms than the one I used above, it&#39;s always going to be computationally intensive.</p><p>We do need to perform this calculation <em>sometimes</em>, like when the user picks a new <code>selectedNum</code>. But we could potentially run into some performance problems if we wind up doing this work <em>gratuitously</em>, when it doesn&#39;t need to be done.</p><p>For example, let&#39;s suppose our example also features a digital clock:</p><div><div data-id="prime-number-with-clock" data-can-be-annotated="false"><div data-is-fullscreened="false"><div><div><header><p>Code Playground<!-- --> </p><div><p><abbr title="Reset code"><div><div><div><div role="progressbar" aria-valuenow="false" aria-valuemin="0" aria-valuemax="90"></div></div></div></div></abbr><abbr title="Format code using Prettier"></abbr><abbr title="Open in CodeSandbox"><a href="https://codesandbox.io/api/v1/sandboxes/define?undefined" rel="noreferrer noopener" target="_blank" title="Open in CodeSandbox"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><polyline points="7.5 4.21 12 6.81 16.5 4.21"></polyline><polyline points="7.5 19.79 7.5 14.6 3 12"></polyline><polyline points="21 12 16.5 14.6 16.5 19.79"></polyline><polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline><line x1="12" y1="22.08" x2="12" y2="12"></line></svg><p>Open in CodeSandbox</p></a></abbr></p></div></header><div><div><div><div><div aria-describedby="enter-instructions-:R1k75aim:" aria-label="Code Editor for App.js" role="group" tabindex="0" translate="no"><pre><span>import</span> <span>React</span> <span>from</span> <span>&#39;react&#39;</span><span>;</span>
<span>import</span> <span>format</span> <span>from</span> <span>&#39;date-fns/format&#39;</span><span>;</span>

<span>function</span> <span>App</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span><span>selectedNum</span><span>,</span> <span>setSelectedNum</span><span>]</span> = <span>React</span>.<span>useState</span><span>(</span><span>100</span><span>)</span><span>;</span>
  
  <span>// `time` is a state variable that changes once per second,</span>
  <span>// so that it&#39;s always in sync with the current time.</span>
  <span>const</span> <span>time</span> = <span>useTime</span><span>(</span><span>)</span><span>;</span>
  
  <span>// Calculate all of the prime numbers.</span>
  <span>// (Unchanged from the earlier example.)</span>
  <span>const</span> <span>allPrimes</span> = <span>[</span><span>]</span><span>;</span>
  <span>for</span> <span>(</span><span>let</span> <span>counter</span> = <span>2</span><span>;</span> <span>counter</span> &lt; <span>selectedNum</span><span>;</span> <span>counter</span>++<span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>isPrime</span><span>(</span><span>counter</span><span>)</span><span>)</span> <span>{</span>
      <span>allPrimes</span>.<span>push</span><span>(</span><span>counter</span><span>)</span><span>;</span>
    <span>}</span>
  <span>}</span>
  
  <span>return</span> <span>(</span>
    <span>&lt;</span><span>&gt;</span>
      <span>&lt;</span><span>p</span> <span>className</span>=<span>&#34;clock&#34;</span><span>&gt;</span>
        <span>{</span><span>format</span><span>(</span><span>time</span><span>,</span> <span>&#39;hh:mm:ss a&#39;</span><span>)</span><span>}</span>
      <span>&lt;/</span><span>p</span><span>&gt;</span>
      <span>&lt;</span><span>form</span><span>&gt;</span>
        <span>&lt;</span><span>label</span> <span>htmlFor</span>=<span>&#34;num&#34;</span><span>&gt;</span>Your number:<span>&lt;/</span><span>label</span><span>&gt;</span>
        <span>&lt;</span><span>input</span>
          <span>type</span>=<span>&#34;number&#34;</span>
          <span>value</span>=<span>{</span><span>selectedNum</span><span>}</span>
          <span>onChange</span>=<span>{</span><span>(</span><span>event</span><span>)</span> <span>=&gt;</span> <span>{</span>
            <span>// To prevent computers from exploding,</span>
            <span>// we&#39;ll max out at 100k</span>
            <span>let</span> <span>num</span> = <span>Math</span>.<span>min</span><span>(</span><span>100_000</span><span>,</span> <span>Number</span><span>(</span><span>event</span>.<span>target</span>.<span>value</span><span>)</span><span>)</span><span>;</span>
            
            <span>setSelectedNum</span><span>(</span><span>num</span><span>)</span><span>;</span>
          <span>}</span><span>}</span>
        <span>/&gt;</span>
      <span>&lt;/</span><span>form</span><span>&gt;</span>
      <span>&lt;</span><span>p</span><span>&gt;</span>
        There are <span>{</span><span>allPrimes</span>.<span>length</span><span>}</span> prime(s) between 1 and <span>{</span><span>selectedNum</span><span>}</span>:
        <span>{</span><span>&#39; &#39;</span><span>}</span>
        <span>&lt;</span><span>span</span> <span>className</span>=<span>&#34;prime-list&#34;</span><span>&gt;</span>
          <span>{</span><span>allPrimes</span>.<span>join</span><span>(</span><span>&#39;, &#39;</span><span>)</span><span>}</span>
        <span>&lt;/</span><span>span</span><span>&gt;</span>
      <span>&lt;/</span><span>p</span><span>&gt;</span>
    <span>&lt;/</span><span>&gt;</span>
  <span>)</span><span>;</span>
<span>}</span>

<span>function</span> <span>useTime</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span><span>time</span><span>,</span> <span>setTime</span><span>]</span> = <span>React</span>.<span>useState</span><span>(</span><span>new</span> <span>Date</span><span>(</span><span>)</span><span>)</span><span>;</span>
  
  <span>React</span>.<span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>const</span> <span>intervalId</span> = <span>window</span>.<span>setInterval</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
      <span>setTime</span><span>(</span><span>new</span> <span>Date</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span><span>,</span> <span>1000</span><span>)</span><span>;</span>
  
    <span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
      <span>window</span>.<span>clearInterval</span><span>(</span><span>intervalId</span><span>)</span><span>;</span>
    <span>}</span>
  <span>}</span><span>,</span> <span>[</span><span>]</span><span>)</span><span>;</span>
  
  <span>return</span> <span>time</span><span>;</span>
<span>}</span>

<span>function</span> <span>isPrime</span><span>(</span><span>n</span><span>)</span><span>{</span>
  <span>const</span> <span>max</span> = <span>Math</span>.<span>ceil</span><span>(</span><span>Math</span>.<span>sqrt</span><span>(</span><span>n</span><span>)</span><span>)</span><span>;</span>
  
  <span>if</span> <span>(</span><span>n</span> === <span>2</span><span>)</span> <span>{</span>
    <span>return</span> <span>true</span><span>;</span>
  <span>}</span>
  
  <span>for</span> <span>(</span><span>let</span> <span>counter</span> = <span>2</span><span>;</span> <span>counter</span> &lt;= <span>max</span><span>;</span> <span>counter</span>++<span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>n</span> % <span>counter</span> === <span>0</span><span>)</span> <span>{</span>
      <span>return</span> <span>false</span><span>;</span>
    <span>}</span>
  <span>}</span>

  <span>return</span> <span>true</span><span>;</span>
<span>}</span>

<span>export</span> <span>default</span> <span>App</span><span>;</span></pre></div></div></div></div></div><div><div></div><div><div><div><div></div></div></div></div></div></div></div></div></div></div><p>Our application now has two pieces of state, <code>selectedNum</code> and <code>time</code>. Once per second, the <code>time</code> variable is updated to reflect the current time, and that value is used to render a digital clock in the top-right corner.</p><p><strong>Here&#39;s the issue:</strong> whenever <em>either</em> of these state variables change, we re-run all of those expensive prime-number computations. And because <code>time</code> changes once per second, it means we&#39;re <em>constantly</em> re-generating that list of primes, even when the user&#39;s selected number hasn&#39;t changed!</p><span type="default"><span><span><img alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%27714%27%20height=%27332%27/%3e"/></span><img alt="Labeled screenshot of the code above, showing how whenever the time value changes, the prime numbers have to be recalculated" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic"/></span></span><p>In JavaScript, we only have one main thread, and we&#39;re keeping it <em>super</em> busy by running this code over and over, every single second. It means that the application might feel sluggish as the user tries to do other things, especially on lower-end devices.</p><p><strong>But what if we could ‚Äúskip‚Äù these calculations?</strong> If we already have the list of primes for a given number, why not <em>re-use</em> that value instead of calculating it from scratch every time?</p><p>This is precisely what <code>useMemo</code> allows us to do. Here&#39;s what it looks like:</p><pre><div><p>js</p><div data-code-snippet="true"></div></div></pre><p><code>useMemo</code> takes two arguments:</p><ol><li><p>A chunk of work to be performed, wrapped up in a function</p></li><li><p>A list of dependencies</p></li></ol><p>During mount, when this component is rendered for the very first time, React will invoke this function to run all of this logic, calculating all of the primes. <strong>Whatever we return from this function is assigned to the <code>allPrimes</code> variable.</strong></p><p>For every subsequent render, however, <strong>React has a choice to make.</strong> Should it:</p><ol><li><p>Invoke the function again, to re-calculate the value, or</p></li><li><p>Re-use the data it already has, from the <em>last</em> time it did this work.</p></li></ol><p>To answer this question, React looks at the supplied list of dependencies. Have any of them changed since the previous render? If so, React will rerun the supplied function, to calculate a new value. Otherwise, it&#39;ll skip all that work and reuse the previously-calculated value.</p><p><strong><code>useMemo</code> is essentially like a lil‚Äô cache, and the dependencies are the cache invalidation strategy.</strong></p><p>In this case, we&#39;re essentially saying ‚Äúrecalculate the list of primes <em>only when</em> <code>selectedNum</code> changes‚Äù. When the component re-renders for <em>other</em> reasons (eg. the <code>time</code> state variable changing), <code>useMemo</code> ignores the function and passes along the cached value.</p><p>This is commonly known as <em>memoization</em>, and it&#39;s why this hook is called ‚ÄúuseMemo‚Äù.</p><p>Here&#39;s a live version of this solution:</p><div><div data-id="prime-number-with-clock-solved" data-can-be-annotated="false"><div data-is-fullscreened="false"><div><div><header><p>Code Playground<!-- --> </p><div><p><abbr title="Reset code"><div><div><div><div role="progressbar" aria-valuenow="false" aria-valuemin="0" aria-valuemax="90"></div></div></div></div></abbr><abbr title="Format code using Prettier"></abbr><abbr title="Open in CodeSandbox"><a href="https://codesandbox.io/api/v1/sandboxes/define?undefined" rel="noreferrer noopener" target="_blank" title="Open in CodeSandbox"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><polyline points="7.5 4.21 12 6.81 16.5 4.21"></polyline><polyline points="7.5 19.79 7.5 14.6 3 12"></polyline><polyline points="21 12 16.5 14.6 16.5 19.79"></polyline><polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline><line x1="12" y1="22.08" x2="12" y2="12"></line></svg><p>Open in CodeSandbox</p></a></abbr></p></div></header><div><div><div><div><div aria-describedby="enter-instructions-:R1kblaim:" aria-label="Code Editor for App.js" role="group" tabindex="0" translate="no"><pre><span>import</span> <span>React</span> <span>from</span> <span>&#39;react&#39;</span><span>;</span>
<span>import</span> <span>format</span> <span>from</span> <span>&#39;date-fns/format&#39;</span><span>;</span>

<span>function</span> <span>App</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span><span>selectedNum</span><span>,</span> <span>setSelectedNum</span><span>]</span> = <span>React</span>.<span>useState</span><span>(</span><span>100</span><span>)</span><span>;</span>
  <span>const</span> <span>time</span> = <span>useTime</span><span>(</span><span>)</span><span>;</span>
  
  <span>const</span> <span>allPrimes</span> = <span>React</span>.<span>useMemo</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>const</span> <span>result</span> = <span>[</span><span>]</span><span>;</span>
    
    <span>for</span> <span>(</span><span>let</span> <span>counter</span> = <span>2</span><span>;</span> <span>counter</span> &lt; <span>selectedNum</span><span>;</span> <span>counter</span>++<span>)</span> <span>{</span>
      <span>if</span> <span>(</span><span>isPrime</span><span>(</span><span>counter</span><span>)</span><span>)</span> <span>{</span>
        <span>result</span>.<span>push</span><span>(</span><span>counter</span><span>)</span><span>;</span>
      <span>}</span>
    <span>}</span>
    
    <span>return</span> <span>result</span><span>;</span>
  <span>}</span><span>,</span> <span>[</span><span>selectedNum</span><span>]</span><span>)</span><span>;</span>
  
  <span>return</span> <span>(</span>
    <span>&lt;</span><span>&gt;</span>
      <span>&lt;</span><span>p</span> <span>className</span>=<span>&#34;clock&#34;</span><span>&gt;</span>
        <span>{</span><span>format</span><span>(</span><span>time</span><span>,</span> <span>&#39;hh:mm:ss a&#39;</span><span>)</span><span>}</span>
      <span>&lt;/</span><span>p</span><span>&gt;</span>
      <span>&lt;</span><span>form</span><span>&gt;</span>
        <span>&lt;</span><span>label</span> <span>htmlFor</span>=<span>&#34;num&#34;</span><span>&gt;</span>Your number:<span>&lt;/</span><span>label</span><span>&gt;</span>
        <span>&lt;</span><span>input</span>
          <span>type</span>=<span>&#34;number&#34;</span>
          <span>value</span>=<span>{</span><span>selectedNum</span><span>}</span>
          <span>onChange</span>=<span>{</span><span>(</span><span>event</span><span>)</span> <span>=&gt;</span> <span>{</span>
            <span>// To prevent computers from exploding,</span>
            <span>// we&#39;ll max out at 100k</span>
            <span>let</span> <span>num</span> = <span>Math</span>.<span>min</span><span>(</span><span>100_000</span><span>,</span> <span>Number</span><span>(</span><span>event</span>.<span>target</span>.<span>value</span><span>)</span><span>)</span><span>;</span>
            
            <span>setSelectedNum</span><span>(</span><span>num</span><span>)</span><span>;</span>
          <span>}</span><span>}</span>
        <span>/&gt;</span>
      <span>&lt;/</span><span>form</span><span>&gt;</span>
      <span>&lt;</span><span>p</span><span>&gt;</span>
        There are <span>{</span><span>allPrimes</span>.<span>length</span><span>}</span> prime(s) between 1 and <span>{</span><span>selectedNum</span><span>}</span>:
        <span>{</span><span>&#39; &#39;</span><span>}</span>
        <span>&lt;</span><span>span</span> <span>className</span>=<span>&#34;prime-list&#34;</span><span>&gt;</span>
          <span>{</span><span>allPrimes</span>.<span>join</span><span>(</span><span>&#39;, &#39;</span><span>)</span><span>}</span>
        <span>&lt;/</span><span>span</span><span>&gt;</span>
      <span>&lt;/</span><span>p</span><span>&gt;</span>
    <span>&lt;/</span><span>&gt;</span>
  <span>)</span><span>;</span>
<span>}</span>

<span>function</span> <span>useTime</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span><span>time</span><span>,</span> <span>setTime</span><span>]</span> = <span>React</span>.<span>useState</span><span>(</span><span>new</span> <span>Date</span><span>(</span><span>)</span><span>)</span><span>;</span>
  
  <span>React</span>.<span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>const</span> <span>intervalId</span> = <span>window</span>.<span>setInterval</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
      <span>setTime</span><span>(</span><span>new</span> <span>Date</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span><span>,</span> <span>1000</span><span>)</span><span>;</span>
  
    <span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
      <span>window</span>.<span>clearInterval</span><span>(</span><span>intervalId</span><span>)</span><span>;</span>
    <span>}</span>
  <span>}</span><span>,</span> <span>[</span><span>]</span><span>)</span><span>;</span>
  
  <span>return</span> <span>time</span><span>;</span>
<span>}</span>

<span>function</span> <span>isPrime</span><span>(</span><span>n</span><span>)</span><span>{</span>
  <span>const</span> <span>max</span> = <span>Math</span>.<span>ceil</span><span>(</span><span>Math</span>.<span>sqrt</span><span>(</span><span>n</span><span>)</span><span>)</span><span>;</span>
  
  <span>if</span> <span>(</span><span>n</span> === <span>2</span><span>)</span> <span>{</span>
    <span>return</span> <span>true</span><span>;</span>
  <span>}</span>
  
  <span>for</span> <span>(</span><span>let</span> <span>counter</span> = <span>2</span><span>;</span> <span>counter</span> &lt;= <span>max</span><span>;</span> <span>counter</span>++<span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>n</span> % <span>counter</span> === <span>0</span><span>)</span> <span>{</span>
      <span>return</span> <span>false</span><span>;</span>
    <span>}</span>
  <span>}</span>

  <span>return</span> <span>true</span><span>;</span>
<span>}</span>

<span>export</span> <span>default</span> <span>App</span><span>;</span></pre></div></div></div></div></div><div><div></div><div><div><div><div></div></div></div></div></div></div></div></div></div></div><div><h3><a name="an-alternative-approach" id="an-alternative-approach" href="#an-alternative-approach"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg><p>Link to this heading</p></a>An alternative approach</h3></div><p>So, the <code>useMemo</code> hook can indeed help us avoid unnecessary calculations here‚Ä¶ but is it <em>really</em> the best solution here?</p><p>Often, we can avoid the need for <code>useMemo</code> by restructuring things in our application.</p><p>Here&#39;s one way we could do this:</p><div><div data-id="prime-number-alt-strategy" data-can-be-annotated="false"><div data-is-fullscreened="false"><div><div><header><p>Code Playground<!-- --> </p><div><p><abbr title="Reset code"><div><div><div><div role="progressbar" aria-valuenow="false" aria-valuemin="0" aria-valuemax="90"></div></div></div></div></abbr><abbr title="Format code using Prettier"></abbr><abbr title="Open in CodeSandbox"><a href="https://codesandbox.io/api/v1/sandboxes/define?undefined" rel="noreferrer noopener" target="_blank" title="Open in CodeSandbox"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><polyline points="7.5 4.21 12 6.81 16.5 4.21"></polyline><polyline points="7.5 19.79 7.5 14.6 3 12"></polyline><polyline points="21 12 16.5 14.6 16.5 19.79"></polyline><polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline><line x1="12" y1="22.08" x2="12" y2="12"></line></svg><p>Open in CodeSandbox</p></a></abbr></p></div></header><div><div><div><div translate="no"></div><div><div aria-describedby="enter-instructions-:R1kctaim:" aria-label="Code Editor for App.js" role="group" tabindex="0" translate="no"><pre><span>import</span> <span>React</span> <span>from</span> <span>&#39;react&#39;</span><span>;</span>

<span>import</span> <span>Clock</span> <span>from</span> <span>&#39;./Clock&#39;</span><span>;</span>
<span>import</span> <span>PrimeCalculator</span> <span>from</span> <span>&#39;./PrimeCalculator&#39;</span><span>;</span>

<span>function</span> <span>App</span><span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>(</span>
    <span>&lt;</span><span>&gt;</span>
      <span>&lt;</span><span>Clock</span> <span>/&gt;</span>
      <span>&lt;</span><span>PrimeCalculator</span> <span>/&gt;</span>
    <span>&lt;/</span><span>&gt;</span>
  <span>)</span><span>;</span>
<span>}</span>

<span>export</span> <span>default</span> <span>App</span><span>;</span></pre></div></div></div></div></div><div><div></div><div><div><div><div></div></div></div></div></div></div></div></div></div></div><p>I&#39;ve extracted two new components, <code>Clock</code> and <code>PrimeCalculator</code>. By branching off from <code>App</code>, these two components each manage their own state. A re-render in one component won&#39;t affect the other.</p><p>Here&#39;s a graph showing this dynamic. Each box represents a component instance, and <span>they flash when they re-render</span>. Try clicking the ‚ÄúIncrement‚Äù button to see it in action:</p><p>We hear a lot about lifting state up, but sometimes, the better approach is to <em>push state down!</em> Each component should have a single responsibility, and in the example above, <code>App</code> was doing two totally-unrelated things.</p><p>Now, this won&#39;t always be an option. In a large, real-world app, there&#39;s lots of state that <em>needs</em> to be lifted up pretty high, and can&#39;t be pushed down.</p><p><strong>I have another trick up my sleeves for this situation.</strong></p><p>Let&#39;s look at an example. Suppose we <strong>need</strong> the <code>time</code> variable to be lifted up, above <code>PrimeCalculator</code>:</p><div><div data-id="prime-number-alt-strategy" data-can-be-annotated="false"><div data-is-fullscreened="false"><div><div><header><p>Code Playground<!-- --> </p><div><p><abbr title="Reset code"><div><div><div><div role="progressbar" aria-valuenow="false" aria-valuemin="0" aria-valuemax="90"></div></div></div></div></abbr><abbr title="Format code using Prettier"></abbr><abbr title="Open in CodeSandbox"><a href="https://codesandbox.io/api/v1/sandboxes/define?undefined" rel="noreferrer noopener" target="_blank" title="Open in CodeSandbox"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><polyline points="7.5 4.21 12 6.81 16.5 4.21"></polyline><polyline points="7.5 19.79 7.5 14.6 3 12"></polyline><polyline points="21 12 16.5 14.6 16.5 19.79"></polyline><polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline><line x1="12" y1="22.08" x2="12" y2="12"></line></svg><p>Open in CodeSandbox</p></a></abbr></p></div></header><div><div><div><div translate="no"></div><div><div aria-describedby="enter-instructions-:R1ketaim:" aria-label="Code Editor for App.js" role="group" tabindex="0" translate="no"><pre><span>import</span> <span>React</span> <span>from</span> <span>&#39;react&#39;</span><span>;</span>
<span>import</span> <span>{</span> <span>getHours</span> <span>}</span> <span>from</span> <span>&#39;date-fns&#39;</span><span>;</span>

<span>import</span> <span>Clock</span> <span>from</span> <span>&#39;./Clock&#39;</span><span>;</span>
<span>import</span> <span>PrimeCalculator</span> <span>from</span> <span>&#39;./PrimeCalculator&#39;</span><span>;</span>

<span>// Transform our PrimeCalculator into a pure component:</span>
<span>const</span> <span>PurePrimeCalculator</span> = <span>React</span>.<span>memo</span><span>(</span><span>PrimeCalculator</span><span>)</span><span>;</span>

<span>function</span> <span>App</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>time</span> = <span>useTime</span><span>(</span><span>)</span><span>;</span>

  <span>// Come up with a suitable background color,</span>
  <span>// based on the time of day:</span>
  <span>const</span> <span>backgroundColor</span> = <span>getBackgroundColorFromTime</span><span>(</span><span>time</span><span>)</span><span>;</span>

  <span>return</span> <span>(</span>
    <span>&lt;</span><span>div</span> <span>style</span>=<span>{</span><span>{</span> <span>backgroundColor</span> <span>}</span><span>}</span><span>&gt;</span>
      <span>&lt;</span><span>Clock</span> <span>time</span>=<span>{</span><span>time</span><span>}</span> <span>/&gt;</span>
      <span>&lt;</span><span>PurePrimeCalculator</span> <span>/&gt;</span>
    <span>&lt;/</span><span>div</span><span>&gt;</span>
  <span>)</span><span>;</span>
<span>}</span>

<span>const</span> <span>getBackgroundColorFromTime</span> = <span>(</span><span>time</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>const</span> <span>hours</span> = <span>getHours</span><span>(</span><span>time</span><span>)</span><span>;</span>
  
  <span>if</span> <span>(</span><span>hours</span> &lt; <span>12</span><span>)</span> <span>{</span>
    <span>// A light yellow for mornings</span>
    <span>return</span> <span>&#39;hsl(50deg 100% 90%)&#39;</span><span>;</span>
  <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>hours</span> &lt; <span>18</span><span>)</span> <span>{</span>
    <span>// Dull blue in the afternoon</span>
    <span>return</span> <span>&#39;hsl(220deg 60% 92%)&#39;</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>// Deeper blue at night</span>
    <span>return</span> <span>&#39;hsl(220deg 100% 80%)&#39;</span><span>;</span>
  <span>}</span>
<span>}</span>

<span>function</span> <span>useTime</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span><span>time</span><span>,</span> <span>setTime</span><span>]</span> = <span>React</span>.<span>useState</span><span>(</span><span>new</span> <span>Date</span><span>(</span><span>)</span><span>)</span><span>;</span>
  
  <span>React</span>.<span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>const</span> <span>intervalId</span> = <span>window</span>.<span>setInterval</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
      <span>setTime</span><span>(</span><span>new</span> <span>Date</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span><span>,</span> <span>1000</span><span>)</span><span>;</span>
  
    <span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
      <span>window</span>.<span>clearInterval</span><span>(</span><span>intervalId</span><span>)</span><span>;</span>
    <span>}</span>
  <span>}</span><span>,</span> <span>[</span><span>]</span><span>)</span><span>;</span>
  
  <span>return</span> <span>time</span><span>;</span>
<span>}</span>

<span>export</span> <span>default</span> <span>App</span><span>;</span></pre></div></div></div></div></div><div><div></div><div><div><div><div></div></div></div></div></div></div></div></div></div></div><p>Here&#39;s an updated graph, showing what&#39;s happening here:</p><p>Like a force field, <code>React.memo</code> wraps around our component and protects it from unrelated updates. Our <code>PurePrimeCalculator</code> will only re-render when it receives new data, or when its internal state changes.</p><p>This is known as a <em>pure component</em>. Essentially, we&#39;re telling React that this component will always produce the same <em>output</em> given the same <em>input</em>, and we can skip the re-renders where nothing&#39;s changed.</p><p>I wrote more about how <code>React.memo</code> works in my recent blog post, <a href="https://www.joshwcomeau.com/react/why-react-re-renders/">‚ÄúWhy React Re-Renders‚Äù</a>.</p><p><strong>There&#39;s an interesting perspective-shift here:</strong> Before, we were memoizing the result of a specific computation, calculating the prime numbers. In this case, however, <em>I&#39;ve memoized the entire component instead.</em></p><p>Either way, the expensive calculation stuff will only re-run when the user picks a new <code>selectedNum</code>. But we&#39;ve optimized the parent component rather than the specific slow lines of code.</p><p>I&#39;m not saying that one approach is better than the other; each tool has its spot in the toolbox. But in this specific case, I prefer this approach.</p><p>Now, if you&#39;ve ever tried to use pure components in a real-world setting, you&#39;ve likely noticed something peculiar: <strong>Pure components often re-render quite a bit,</strong> even when it seems like nothing&#39;s changed! üò¨</p><p>This leads us nicely into the second problem that <code>useMemo</code> solves.</p><div><h2><a name="use-case-2-preserved-references" id="use-case-2-preserved-references" href="#use-case-2-preserved-references"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg><p>Link to this heading</p></a>Use case 2: Preserved references</h2></div><p>In the example below, I&#39;ve created a <code>Boxes</code> component. It displays a set of colorful boxes, to be used for some sort of decorative purpose.</p><p>I also have a bit of unrelated state, the user&#39;s name.</p><div><div data-id="reference-trouble" data-can-be-annotated="false"><div data-is-fullscreened="false"><div><div><header><p>Code Playground<!-- --> </p><div><p><abbr title="Reset code"><div><div><div><div role="progressbar" aria-valuenow="false" aria-valuemin="0" aria-valuemax="90"></div></div></div></div></abbr><abbr title="Format code using Prettier"></abbr><abbr title="Open in CodeSandbox"><a href="https://codesandbox.io/api/v1/sandboxes/define?undefined" rel="noreferrer noopener" target="_blank" title="Open in CodeSandbox"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><polyline points="7.5 4.21 12 6.81 16.5 4.21"></polyline><polyline points="7.5 19.79 7.5 14.6 3 12"></polyline><polyline points="21 12 16.5 14.6 16.5 19.79"></polyline><polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline><line x1="12" y1="22.08" x2="12" y2="12"></line></svg><p>Open in CodeSandbox</p></a></abbr></p></div></header><div><div><div><div translate="no"></div><div><div aria-describedby="enter-instructions-:R1kitaim:" aria-label="Code Editor for App.js" role="group" tabindex="0" translate="no"><pre><span>import</span> <span>React</span> <span>from</span> <span>&#39;react&#39;</span><span>;</span>

<span>import</span> <span>Boxes</span> <span>from</span> <span>&#39;./Boxes&#39;</span><span>;</span>

<span>function</span> <span>App</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span><span>name</span><span>,</span> <span>setName</span><span>]</span> = <span>React</span>.<span>useState</span><span>(</span><span>&#39;&#39;</span><span>)</span><span>;</span>
  <span>const</span> <span>[</span><span>boxWidth</span><span>,</span> <span>setBoxWidth</span><span>]</span> = <span>React</span>.<span>useState</span><span>(</span><span>1</span><span>)</span><span>;</span>
  
  <span>const</span> <span>id</span> = <span>React</span>.<span>useId</span><span>(</span><span>)</span><span>;</span>
  
  <span>// Try changing some of these values!</span>
  <span>const</span> <span>boxes</span> = <span>[</span>
    <span>{</span> <span>flex</span><span>:</span> <span>boxWidth</span><span>,</span> <span>background</span><span>:</span> <span>&#39;hsl(345deg 100% 50%)&#39;</span> <span>}</span><span>,</span>
    <span>{</span> <span>flex</span><span>:</span> <span>3</span><span>,</span> <span>background</span><span>:</span> <span>&#39;hsl(260deg 100% 40%)&#39;</span> <span>}</span><span>,</span>
    <span>{</span> <span>flex</span><span>:</span> <span>1</span><span>,</span> <span>background</span><span>:</span> <span>&#39;hsl(50deg 100% 60%)&#39;</span> <span>}</span><span>,</span>
  <span>]</span><span>;</span>
  
  <span>return</span> <span>(</span>
    <span>&lt;</span><span>&gt;</span>
      <span>&lt;</span><span>Boxes</span> <span>boxes</span>=<span>{</span><span>boxes</span><span>}</span> <span>/&gt;</span>
      
      <span>&lt;</span><span>section</span><span>&gt;</span>
        <span>&lt;</span><span>label</span> <span>htmlFor</span>=<span>{</span><span>`</span><span>${</span><span>id</span><span>}</span><span>-name`</span><span>}</span><span>&gt;</span>
          Name:
        <span>&lt;/</span><span>label</span><span>&gt;</span>
        <span>&lt;</span><span>input</span>
          <span>id</span>=<span>{</span><span>`</span><span>${</span><span>id</span><span>}</span><span>-name`</span><span>}</span>
          <span>type</span>=<span>&#34;text&#34;</span>
          <span>value</span>=<span>{</span><span>name</span><span>}</span>
          <span>onChange</span>=<span>{</span><span>(</span><span>event</span><span>)</span> <span>=&gt;</span> <span>{</span>
            <span>setName</span><span>(</span><span>event</span>.<span>target</span>.<span>value</span><span>)</span><span>;</span>
          <span>}</span><span>}</span>
        <span>/&gt;</span>
        <span>&lt;</span><span>label</span> <span>htmlFor</span>=<span>{</span><span>`</span><span>${</span><span>id</span><span>}</span><span>-box-width`</span><span>}</span><span>&gt;</span>
          First box width:
        <span>&lt;/</span><span>label</span><span>&gt;</span>
        <span>&lt;</span><span>input</span>
          <span>id</span>=<span>{</span><span>`</span><span>${</span><span>id</span><span>}</span><span>-box-width`</span><span>}</span>
          <span>type</span>=<span>&#34;range&#34;</span>
          <span>min</span>=<span>{</span><span>1</span><span>}</span>
          <span>max</span>=<span>{</span><span>5</span><span>}</span>
          <span>step</span>=<span>{</span><span>0.01</span><span>}</span>
          <span>value</span>=<span>{</span><span>boxWidth</span><span>}</span>
          <span>onChange</span>=<span>{</span><span>(</span><span>event</span><span>)</span> <span>=&gt;</span> <span>{</span>
            <span>setBoxWidth</span><span>(</span><span>Number</span><span>(</span><span>event</span>.<span>target</span>.<span>value</span><span>)</span><span>)</span><span>;</span>
          <span>}</span><span>}</span>
        <span>/&gt;</span>
      <span>&lt;/</span><span>section</span><span>&gt;</span>
    <span>&lt;/</span><span>&gt;</span>
  <span>)</span><span>;</span>
<span>}</span>

<span>export</span> <span>default</span> <span>App</span><span>;</span></pre></div></div></div></div></div><div><div></div><div><div><div><div></div></div></div></div></div></div></div></div></div></div><p><code>Boxes</code> is a pure component, thanks to a <code>React.memo()</code> wrapping around the default export in <code>Boxes.js</code>. This means that it should only re-render whenever its props change.</p><p><em>And yet,</em> whenever the user changes their name, <code>Boxes</code> re-renders as well!</p><p>Here&#39;s a graph showing this dynamic. Try typing in the text input, and notice how both components re-render:</p><div><div><div id="app"><p>App</p><p><label for="red-boxes-name">name<!-- -->:</label></p></div></div><div><div id="redboxes"><p>RedBoxes</p><p>Props:<!-- --> { <!-- -->boxes<!-- --> }</p><p>Pure Component</p></div></div></div><p>What the heck?! Why isn&#39;t our <code>React.memo()</code> force field protecting us here??</p><p>The <code>Boxes</code> component only has 1 prop, <code>boxes</code>, and it appears as though we&#39;re giving it the exact same data on every render. It&#39;s always the same thing: a red box, a wide purple box, a yellow box. We <em>do</em> have a <code>boxWidth</code> state variable that affects the <code>boxes</code> array, but we aren&#39;t changing it!</p><p><strong>Here&#39;s the problem:</strong> every time React re-renders, we&#39;re producing a <em>brand new array</em>. They&#39;re equivalent in terms of <em>value</em>, but not in terms of <em>reference</em>.</p><p>I think it&#39;ll be helpful if we forget about React for a second, and talk about plain old JavaScript. Let&#39;s look at a similar situation:</p><pre><div><p>js</p><div data-code-snippet="true"></div></div></pre><p>What do you think? Is <code>firstResult</code> equal to <code>secondResult</code>?</p><p>In a sense, they are. Both variables hold an identical structure, <code>[1, 2, 3]</code>. But that&#39;s not what the <code>===</code> operator is actually checking.</p><p>Instead, <code>===</code> is checking whether two expressions <em>are the same thing.</em></p><p>We&#39;ve created two different arrays. They may hold the same contents, but they&#39;re not the same array, in the same way that <em>two identical twins are not the same person.</em></p><span type="default"><span><span><img alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%27542.6666666666666%27%20height=%27389%27/%3e"/></span><img alt="Illustration of two identical-looking people saying ‚Äúwe&#39;re different people!‚Äù" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic"/></span></span><p>Every time we invoke the <code>getNumbers</code> function, we create a brand-new array, a distinct thing held in the computer&#39;s memory. If we invoke it multiple times, we&#39;ll store multiple copies of this array in-memory.</p><p>Note that simple data types ‚Äî things like strings, numbers, and boolean values ‚Äî can be compared by value. But when it comes to arrays and objects, they&#39;re only compared by <em>reference</em>. For more information on this distinction, check out this wonderful blog post by Dave Ceddia: <a href="https://daveceddia.com/javascript-references/" rel="noopener noreferrer" target="_blank">A Visual Guide to References in JavaScript</a>.</p><p><strong>Taking this back to React:</strong> Our <code>Boxes</code> React component is also a JavaScript function. When we render it, we invoke that function:</p><pre><div><p>jsx</p><div data-code-snippet="true"></div></div></pre><p>When the <code>name</code> state changes, our <code>App</code> component re-renders, which re-runs all of the code. We construct a brand-new <code>boxes</code> array, and pass it onto our <code>Boxes</code> component.</p><p><strong>And <code>Boxes</code> re-renders, because we gave it a brand new array!</strong></p><p>The <em>structure</em> of the <code>boxes</code> array hasn&#39;t changed between renders, but that isn&#39;t relevant. All React knows is that the <code>boxes</code> prop has received a freshly-created, never-before-seen array.</p><p>To solve this problem, we can use the <code>useMemo</code> hook:</p><pre><div><p>js</p><div data-code-snippet="true"></div></div></pre><p>Unlike the example we saw earlier, with the prime numbers, we&#39;re not worried about a computationally-expensive calculation here. Our only goal is to <em>preserve a reference</em> to a particular array.</p><p>We list <code>boxWidth</code> as a dependency, because we <em>do</em> want the <code>Boxes</code> component to re-render when the user tweaks the width of the red box.</p><p>I think a quick sketch will help illustrate. Before, we were creating a brand new array, as part of each snapshot:</p><span type="default"><span><span><img alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%271564.5%27%20height=%27914%27/%3e"/></span><img alt="Diagram showing how each snapshot builds a brand new ‚Äúboxes‚Äù array" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic"/></span></span><p>With <code>useMemo</code>, however, we&#39;re re-using a previously-created <code>boxes</code> array:</p><span type="default"><span><span><img alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%271564.5%27%20height=%27914%27/%3e"/></span><img alt="Diagram showing how each snapshot builds a brand new ‚Äúboxes‚Äù array" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic"/></span></span><p>By preserving the same reference across multiple renders, we allow pure components to function the way we want them to, ignoring renders that don&#39;t affect the UI.</p><div><h2><a name="the-usecallback-hook" id="the-usecallback-hook" href="#the-usecallback-hook"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg><p>Link to this heading</p></a>The useCallback hook</h2></div><p>Alright, so that just about covers <code>useMemo</code>‚Ä¶ what about <code>useCallback</code>?</p><p><strong>Here&#39;s the short version:</strong> It&#39;s the exact same thing, but for <em>functions</em> instead of arrays / objects.</p><p>Similar to arrays and objects, functions are compared by reference, not by value:</p><pre><div><p>js</p><div data-code-snippet="true"></div></div></pre><p>This means that if we define a function within our components, it&#39;ll be re-generated on every single render, producing an identical-but-unique function each time.</p><p>Let&#39;s look at an example:</p><div><div data-id="usecallback-example-before" data-can-be-annotated="false"><div data-is-fullscreened="false"><div><div><header><p>Code Playground<!-- --> </p><div><p><abbr title="Reset code"><div><div><div><div role="progressbar" aria-valuenow="false" aria-valuemin="0" aria-valuemax="90"></div></div></div></div></abbr><abbr title="Format code using Prettier"></abbr><abbr title="Open in CodeSandbox"><a href="https://codesandbox.io/api/v1/sandboxes/define?undefined" rel="noreferrer noopener" target="_blank" title="Open in CodeSandbox"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><polyline points="7.5 4.21 12 6.81 16.5 4.21"></polyline><polyline points="7.5 19.79 7.5 14.6 3 12"></polyline><polyline points="21 12 16.5 14.6 16.5 19.79"></polyline><polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline><line x1="12" y1="22.08" x2="12" y2="12"></line></svg><p>Open in CodeSandbox</p></a></abbr></p></div></header><div><div><div><div translate="no"></div><div><div aria-describedby="enter-instructions-:R1kslaim:" aria-label="Code Editor for App.js" role="group" tabindex="0" translate="no"><pre><span>import</span> <span>React</span> <span>from</span> <span>&#39;react&#39;</span><span>;</span>

<span>import</span> <span>MegaBoost</span> <span>from</span> <span>&#39;./MegaBoost&#39;</span><span>;</span>

<span>function</span> <span>App</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span><span>count</span><span>,</span> <span>setCount</span><span>]</span> = <span>React</span>.<span>useState</span><span>(</span><span>0</span><span>)</span><span>;</span>

  <span>function</span> <span>handleMegaBoost</span><span>(</span><span>)</span> <span>{</span>
    <span>setCount</span><span>(</span><span>(</span><span>currentValue</span><span>)</span> <span>=&gt;</span> <span>currentValue</span> + <span>1234</span><span>)</span><span>;</span>
  <span>}</span>

  <span>return</span> <span>(</span>
    <span>&lt;</span><span>&gt;</span>
      Count: <span>{</span><span>count</span><span>}</span>
      <span>&lt;</span><span>button</span>
        <span>onClick</span>=<span>{</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
          <span>setCount</span><span>(</span><span>count</span> + <span>1</span><span>)</span>
        <span>}</span><span>}</span>
      <span>&gt;</span>
        Click me!
      <span>&lt;/</span><span>button</span><span>&gt;</span>
      <span>&lt;</span><span>MegaBoost</span> <span>handleClick</span>=<span>{</span><span>handleMegaBoost</span><span>}</span> <span>/&gt;</span>
    <span>&lt;/</span><span>&gt;</span>
  <span>)</span><span>;</span>
<span>}</span>

<span>export</span> <span>default</span> <span>App</span><span>;</span></pre></div></div></div></div></div><div><div></div><div><div><div><div></div></div></div></div></div></div></div></div></div></div><p>This sandbox depicts a typical counter application, but with a special ‚ÄúMega Boost‚Äù button. This button increases the count by a large amount, in case you&#39;re in a hurry and don&#39;t want to click the standard button a bunch of times.</p><p>The <code>MegaBoost</code> component is a pure component, thanks to <code>React.memo</code>. It doesn&#39;t depend on <code>count</code>‚Ä¶ <strong>But it re-renders whenever <code>count</code> changes!</strong></p><p>Like we saw with the <code>boxes</code> array, the problem here is that we&#39;re generating a brand new function on every render. If we render 3 times, we&#39;ll create 3 separate <code>handleMegaBoost</code> functions, breaking through the <code>React.memo</code> force field.</p><p>Using what we&#39;ve learned about <code>useMemo</code>, we could solve the problem like this:</p><pre><div><p>js</p><div data-code-snippet="true"></div></div></pre><p>Instead of returning an array, we&#39;re returning a <em>function</em>. This function is then stored in the <code>handleMegaBoost</code> variable.</p><p>This works‚Ä¶ but there&#39;s a better way:</p><pre><div><p>js</p><div data-code-snippet="true"></div></div></pre><p><code>useCallback</code> serves the same purpose as <code>useMemo</code>, but it&#39;s built specifically for functions. We hand it a function directly, and it memoizes that function, threading it between renders.</p><p>Put another way, these two expressions have the same effect:</p><pre><div><p>js</p><div data-code-snippet="true"></div></div></pre><p><strong>useCallback is syntactic sugar.</strong> It exists purely to make our lives a bit nicer when trying to memoize callback functions.</p><div><h2><a name="when-to-use-these-hooks" id="when-to-use-these-hooks" href="#when-to-use-these-hooks"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg><p>Link to this heading</p></a>When to use these hooks</h2></div><p>Alright, so we&#39;ve seen how <code>useMemo</code> and <code>useCallback</code> allow us to thread a reference across multiple renders, to reuse complex calculations or to avoid breaking pure components. The question is: <strong>how often should we use it?</strong></p><p>In my personal opinion, it would be a waste of time to wrap every single object/array/function in these hooks. The benefits are negligible in most cases; React is highly optimized, and re-renders often aren&#39;t as slow or expensive as we often think they are!</p><p>The best way to use these hooks is in response to a problem. If you notice your app becoming a bit sluggish, you can use the React Profiler to hunt down slow renders. In some cases, you&#39;ll be able to improve performance by restructuring your application. In other cases, <code>useMemo</code> and <code>useCallback</code> can help speed things up.</p><p>(If you&#39;re not sure how to use the React profiler, I covered it in my recent blog post, <a href="https://www.joshwcomeau.com/react/why-react-re-renders/">‚ÄúWhy React Re-Renders‚Äù!</a>)</p><p>That said, there are a couple of scenarios in which I <em>do</em> pre-emptively apply these hooks.</p><div><h3><a name="inside-generic-custom-hooks" id="inside-generic-custom-hooks" href="#inside-generic-custom-hooks"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg><p>Link to this heading</p></a>Inside generic custom hooks</h3></div><p>One of my favourite lil‚Äô custom hooks is <code>useToggle</code>, a friendly helper that works almost exactly like <code>useState</code>, but can only toggle a state variable between <code>true</code> and <code>false</code>:</p><pre><div><p>js</p><div data-code-snippet="true"></div></div></pre><p>Here&#39;s how this custom hook is defined:</p><pre><div><p>js</p><div data-code-snippet="true"></div></div></pre><p>Notice that the <code>toggle</code> function is memoized with <code>useCallback</code>.</p><p>When I build custom reusable hooks like this, I like to make them as efficient as possible, because <strong>I don&#39;t know where they&#39;ll be used in the future.</strong> It might be overkill in 95% of situations, but if I use this hook 30 or 40 times, there&#39;s a good chance this will help improve the performance of my application.</p><div><h3><a name="inside-context-providers" id="inside-context-providers" href="#inside-context-providers"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg><p>Link to this heading</p></a>Inside context providers</h3></div><p>When we share data across an application with context, it&#39;s common to pass a big object as the <code>value</code> attribute.</p><p>It&#39;s generally a good idea to memoize this object:</p><pre><div><p>js</p><div data-code-snippet="true"></div></div></pre><p><strong>Why is this beneficial?</strong> There might be dozens of pure components that consume this context. Without <code>useMemo</code>, all of these components would be forced to re-render if <code>AuthProvider</code>&#39;s parent happens to re-render.</p><div><h2><a name="the-joy-of-react" id="the-joy-of-react" href="#the-joy-of-react"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg><p>Link to this heading</p></a>The Joy of React</h2></div><p>Phew! You made it to the end. I know that this tutorial covers some pretty rocky ground. üòÖ</p><p>I know that these two hooks are thorny, that React itself can feel really overwhelming and confusing. It&#39;s a difficult tool!</p><p><strong>But here&#39;s the thing:</strong> If you can get over the initial hump, React is an <em color="var(--color-secondary)">absolute joy</em> to use.</p><p>I started using React back in 2015, and it&#39;s become my absolute favourite way to build complex user interfaces and web applications. I&#39;ve tried just about every JS framework under the sun, and I&#39;m just not as productive with them as I am with React.</p><p>If you&#39;ve struggled with React, I&#39;m here to help!</p><p>For the past year, I&#39;ve been hard at work on a course called <a href="https://www.joyofreact.com/" rel="noopener noreferrer" target="_blank">The Joy of React</a>. It&#39;s a beginner-friendly self-paced interactive online course that teaches you how to build next-level cool stuff with React.</p><p>If you found this blog post even a little bit helpful, I think you&#39;ll get <em>so much</em> out of my course. Unlike this blog post, the course combines interactive articles like this one with videos, exercises, mini-games, and even some real-world-style projects. It&#39;s a hands-on adventure.</p><p>The course isn&#39;t released yet, but you can learn more and sign up for updates on the course homepage:</p><ul><li><span><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg></span><div><p><a href="https://www.joyofreact.com/" rel="noopener noreferrer" target="_blank">www.joyofreact.com</a></p></div></li></ul><div><div><h3>Last Updated</h3><p>August 30th, 2022</p></div><div><h3>Hits</h3></div></div></article></div>
  </body>
</html>
