<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://guix.gnu.org/blog/2023/from-development-environments-to-continuous-integrationthe-ultimate-guide-to-software-development-with-guix/">Original</a>
    <h1>The guide to software development with Guix</h1>
    
    <div id="readability-page-1" class="page"><div><article class="page"><p>Ludovic Courtès — June  5, 2023</p><p>Guix is a handy tool for developers; <a href="https://guix.gnu.org/manual/devel/en/html_node/Invoking-guix-shell.html"><code>guix shell</code></a>,
in particular, gives a standalone development environment for your
package, no matter what language(s) it’s written in.  To benefit from
it, you have to initially write a package definition and have it either
in Guix proper, in a channel, or directly upstream as a <code>guix.scm</code> file.
This last option is appealing: all developers have to do to get set up
is clone the project&#39;s repository and run <code>guix shell</code>, with no
arguments—we looked at the rationale for <code>guix shell</code> in <a href="https://guix.gnu.org/en/blog/2021/from-guix-environment-to-guix-shell/">an earlier
article</a>.</p><p>Development needs go beyond development environments though.  How can
developers perform continuous integration of their code in Guix build
environments?  How can they deliver their code straight to adventurous
users?  This post describes a set of files developers can add
to their repository to set up Guix-based development
environments, continuous integration, and continuous delivery—all at
once.</p><p>How do we go about “Guixifying” a repository?  The first step, as we’ve
seen, will be to add a <code>guix.scm</code> at the root of the repository in
question.  We’ll take <a href="https://www.gnu.org/software/guile">Guile</a>
as an example in this post: it’s written in Scheme (mostly) and C, and
has a number of dependencies—a C compilation tool chain, C libraries,
Autoconf and its friends, LaTeX, and so on.  The resulting <code>guix.scm</code>
looks like the usual <a href="https://guix.gnu.org/manual/devel/en/html_node/Defining-Packages.html">package
definition</a>,
just without the <code>define-public</code> bit:</p><pre><code>
<span>(</span><span>use-modules</span> <span>(</span><span>guix</span><span>)</span>
             <span>(</span><span>guix</span> <span>build-system</span> <span>gnu</span><span>)</span>
             <span>(</span><span>(</span><span>guix</span> <span>licenses</span><span>)</span> <span>#:prefix</span> <span>license:</span><span>)</span>
             <span>(</span><span>gnu</span> <span>packages</span> <span>autotools</span><span>)</span>
             <span>(</span><span>gnu</span> <span>packages</span> <span>base</span><span>)</span>
             <span>(</span><span>gnu</span> <span>packages</span> <span>bash</span><span>)</span>
             <span>(</span><span>gnu</span> <span>packages</span> <span>bdw-gc</span><span>)</span>
             <span>(</span><span>gnu</span> <span>packages</span> <span>compression</span><span>)</span>
             <span>(</span><span>gnu</span> <span>packages</span> <span>flex</span><span>)</span>
             <span>(</span><span>gnu</span> <span>packages</span> <span>gdb</span><span>)</span>
             <span>(</span><span>gnu</span> <span>packages</span> <span>gettext</span><span>)</span>
             <span>(</span><span>gnu</span> <span>packages</span> <span>gperf</span><span>)</span>
             <span>(</span><span>gnu</span> <span>packages</span> <span>libffi</span><span>)</span>
             <span>(</span><span>gnu</span> <span>packages</span> <span>libunistring</span><span>)</span>
             <span>(</span><span>gnu</span> <span>packages</span> <span>linux</span><span>)</span>
             <span>(</span><span>gnu</span> <span>packages</span> <span>pkg-config</span><span>)</span>
             <span>(</span><span>gnu</span> <span>packages</span> <span>readline</span><span>)</span>
             <span>(</span><span>gnu</span> <span>packages</span> <span>tex</span><span>)</span>
             <span>(</span><span>gnu</span> <span>packages</span> <span>texinfo</span><span>)</span>
             <span>(</span><span>gnu</span> <span>packages</span> <span>version-control</span><span>)</span><span>)</span>

<span>(</span><span>package</span>
  <span>(</span><span>name</span> <span>&#34;guile&#34;</span><span>)</span>
  <span>(</span><span>version</span> <span>&#34;3.0.99-git&#34;</span><span>)</span>                            <span>(</span><span>source</span> <span>#f</span><span>)</span>                                       <span>(</span><span>build-system</span> <span>gnu-build-system</span><span>)</span>
  <span>(</span><span>native-inputs</span>
   <span>(</span><span>append</span> <span>(</span><span>list</span> <span>autoconf</span>
                 <span>automake</span>
                 <span>libtool</span>
                 <span>gnu-gettext</span>
                 <span>flex</span>
                 <span>texinfo</span>
                 <span>texlive-base</span>                                  <span>texlive-epsf</span>
                 <span>gperf</span>
                 <span>git</span>
                 <span>gdb</span>
                 <span>strace</span>
                 <span>readline</span>
                 <span>lzip</span>
                 <span>pkg-config</span><span>)</span>

                                 <span>(</span><span>if</span> <span>(</span><span>%current-target-system</span><span>)</span>
               <span>(</span><span>list</span> <span>this-package</span><span>)</span>
               <span>&#39;</span><span>(</span><span>)</span><span>)</span><span>)</span><span>)</span>
  <span>(</span><span>inputs</span>
   <span>(</span><span>list</span> <span>libffi</span> <span>bash-minimal</span><span>)</span><span>)</span>
  <span>(</span><span>propagated-inputs</span>
   <span>(</span><span>list</span> <span>libunistring</span> <span>libgc</span><span>)</span><span>)</span>

  <span>(</span><span>native-search-paths</span>
   <span>(</span><span>list</span> <span>(</span><span>search-path-specification</span>
          <span>(</span><span>variable</span> <span>&#34;GUILE_LOAD_PATH&#34;</span><span>)</span>
          <span>(</span><span>files</span> <span>&#39;</span><span>(</span><span>&#34;share/guile/site/3.0&#34;</span><span>)</span><span>)</span><span>)</span>
         <span>(</span><span>search-path-specification</span>
          <span>(</span><span>variable</span> <span>&#34;GUILE_LOAD_COMPILED_PATH&#34;</span><span>)</span>
          <span>(</span><span>files</span> <span>&#39;</span><span>(</span><span>&#34;lib/guile/3.0/site-ccache&#34;</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span>
  <span>(</span><span>synopsis</span> <span>&#34;Scheme implementation intended especially for extensions&#34;</span><span>)</span>
  <span>(</span><span>description</span>
   <span>&#34;Guile is the GNU Ubiquitous Intelligent Language for Extensions,
and it&#39;s actually a full-blown Scheme implementation!&#34;</span><span>)</span>
  <span>(</span><span>home-page</span> <span>&#34;https://www.gnu.org/software/guile/&#34;</span><span>)</span>
  <span>(</span><span>license</span> <span>license:lgpl3+</span><span>)</span><span>)</span></code></pre><p>Quite a bit of boilerplate, but now someone who’d like to hack on Guile
just needs to run:</p><pre><code>guix shell</code></pre><p>That gives them a shell containing all the dependencies of Guile: those
listed above, but also <em>implicit dependencies</em> such as the GCC tool
chain, GNU Make, sed, grep, and so on.  The chef’s recommendation:</p><pre><code>guix shell --container --link-profile</code></pre><p>That gives a shell in an isolated container, and all the dependencies
show up in <code>$HOME/.guix-profile</code>, which plays well with caches such as
<a href="https://www.gnu.org/savannah-checkouts/gnu/autoconf/manual/autoconf-2.70/html_node/Cache-Files.html"><code>config.cache</code></a>
and absolute file names recorded in generated <code>Makefile</code>s and the likes.
The fact that the shell runs in a container brings peace of mind:
nothing but the current directory and Guile’s dependencies is visible
inside the container; nothing from the system can possibly interfere
with your development.</p><p>Now that we have a package definition, why not also take advantage of it
so we can build Guile with Guix?  We had left the <code>source</code> field empty,
because <code>guix shell</code> above only cares about the <em>inputs</em> of our
package—so it can set up the development environment—not about the
package itself.</p><p>To build the package with Guix, we’ll need to fill out the <code>source</code>
field, along these lines:</p><pre><code><span>(</span><span>use-modules</span> <span>(</span><span>guix</span><span>)</span>
             <span>(</span><span>guix</span> <span>git-download</span><span>)</span>               <span>…</span><span>)</span>

<span>(</span><span>define</span> <span>vcs-file?</span>
    <span>(</span><span>or</span> <span>(</span><span>git-predicate</span> <span>(</span><span>current-source-directory</span><span>)</span><span>)</span>
      <span>(</span><span>const</span> <span>#t</span><span>)</span><span>)</span><span>)</span>                                
<span>(</span><span>package</span>
  <span>(</span><span>name</span> <span>&#34;guile&#34;</span><span>)</span>
  <span>(</span><span>version</span> <span>&#34;3.0.99-git&#34;</span><span>)</span>                            <span>(</span><span>source</span> <span>(</span><span>local-file</span> <span>&#34;.&#34;</span> <span>&#34;guile-checkout&#34;</span>
                      <span>#:recursive?</span> <span>#t</span>
                      <span>#:select?</span> <span>vcs-file?</span><span>)</span><span>)</span>
  <span>…</span><span>)</span></code></pre><p>Here’s what we changed:</p><ol><li>We added <code>(guix git-download)</code> to our set of imported modules, so we
can use its <code>git-predicate</code> procedure.</li><li>We defined <code>vcs-file?</code> as a procedure that returns true when passed
a file that is under version control.  For good measure, we add a
fallback case for when we’re not in a Git checkout: always return
true.</li><li>We set <code>source</code> to a
<a href="https://guix.gnu.org/manual/devel/en/html_node/G_002dExpressions.html#index-local_002dfile"><code>local-file</code></a>—a
recursive copy of the current directory (<code>&#34;.&#34;</code>), limited to files
under version control (the <code>#:select?</code> bit).</li></ol><p>From there on, our <code>guix.scm</code> file serves a second purpose: it lets us
build the software with Guix.  The whole point of building with Guix is
that it’s a “clean” build—you can be sure nothing from your working tree
or system interferes with the build result—and it lets you test a
variety of things.  First, you can do a plain native build:</p><pre><code>guix build -f guix.scm</code></pre><p>But you can also build for another system (possibly after setting up
<a href="https://guix.gnu.org/manual/devel/en/html_node/Daemon-Offload-Setup.html">offloading</a>
or <a href="https://guix.gnu.org/manual/devel/en/html_node/Virtualization-Services.html#index-emulation">transparent
emulation</a>):</p><pre><code>guix build -f guix.scm -s aarch64-linux -s riscv64-linux</code></pre><p>… or cross-compile:</p><pre><code>guix build -f guix.scm --target=x86_64-w64-mingw32</code></pre><p>You can also use <a href="https://guix.gnu.org/manual/devel/en/html_node/Package-Transformation-Options.html">package transformation
options</a>
to test package variants:</p><pre><code># What if we built with Clang instead of GCC?
guix build -f guix.scm \
  --with-c-toolchain=guile@3.0.99-git=clang-toolchain

# What about that under-tested configure flag?
guix build -f guix.scm \
  --with-configure-flag=guile@3.0.99-git=--disable-networking</code></pre><p>Handy!</p><p>We now have a Git repository containing (among other things) a package
definition.  Can’t we turn it into a
<a href="https://guix.gnu.org/manual/devel/en/html_node/Channels.html"><em>channel</em></a>?
After all, channels are designed to ship package definitions to users,
and that’s exactly what we’re doing with our <code>guix.scm</code>.</p><p>Turns out we can indeed turn it into a channel, but with one caveat: we
must create a separate directory for the <code>.scm</code> file(s) of our channel
so that <code>guix pull</code> doesn’t load unrelated <code>.scm</code> files when
someone pulls the channel—and in Guile, there are lots of them!  So
we’ll start like this, keeping a top-level <code>guix.scm</code> symlink for the
sake of <code>guix shell</code>:</p><pre><code>mkdir -p .guix/modules
mv guix.scm .guix/modules/guile-package.scm
ln -s .guix/modules/guile-package.scm guix.scm</code></pre><p>To make it usable as part of a channel, we
need to turn our <code>guix.scm</code> file into a
<a href="https://guix.gnu.org/manual/devel/en/html_node/Package-Modules.html">module</a>:
we do that by changing the <code>use-modules</code> form at the top to a
<code>define-module</code> form.  We also need to actually <em>export</em> a package
variable, with <code>define-public</code>, while still returning the package value
at the end of the file so we can still use <code>guix shell</code> and <code>guix build -f guix.scm</code>.  The end result looks like this (not repeating things that
haven’t changed):</p><pre><code><span>(</span><span>define-module</span> <span>(</span><span>guile-package</span><span>)</span>
  <span>#:use-module</span> <span>(</span><span>guix</span><span>)</span>
  <span>#:use-module</span> <span>(</span><span>guix</span> <span>git-download</span><span>)</span>     <span>…</span><span>)</span>

<span>(</span><span>define-public</span> <span>guile</span>
  <span>(</span><span>package</span>
    <span>(</span><span>name</span> <span>&#34;guile&#34;</span><span>)</span>
    <span>(</span><span>version</span> <span>&#34;3.0.99-git&#34;</span><span>)</span>                              <span>…</span><span>)</span><span>)</span>

<span>guile</span></code></pre><p>We need one last thing: a <a href="https://guix.gnu.org/manual/devel/en/html_node/Package-Modules-in-a-Sub_002ddirectory.html"><code>.guix-channel</code>
file</a>
so Guix knows where to look for package modules in our repository:</p><pre><code>
<span>(</span><span>channel</span>
  <span>(</span><span>version</span> <span>0</span><span>)</span>
  <span>(</span><span>directory</span> <span>&#34;.guix/modules&#34;</span><span>)</span><span>)</span>  </code></pre><p>To recap, we now have these files:</p><pre><code>.
├── .guix-channel
├── guix.scm → .guix/modules/guile-package.scm
└── .guix
    └── modules
       └── guile-package.scm</code></pre><p>And that’s it: we have a channel!  (We could do better and support
<a href="https://guix.gnu.org/manual/devel/en/html_node/Specifying-Channel-Authorizations.html"><em>channel
authentication</em></a>
so users know they’re pulling genuine code.  We’ll spare you the details
here but it’s worth considering!)  Users can pull from this channel by
<a href="https://guix.gnu.org/manual/devel/en/html_node/Specifying-Additional-Channels.html">adding it to
<code>~/.config/guix/channels.scm</code></a>,
along these lines:</p><pre><code><span>(</span><span>append</span> <span>(</span><span>list</span> <span>(</span><span>channel</span>
                <span>(</span><span>name</span> <span>&#39;guile</span><span>)</span>
                <span>(</span><span>url</span> <span>&#34;https://git.savannah.gnu.org/git/guile.git&#34;</span><span>)</span>
                <span>(</span><span>branch</span> <span>&#34;main&#34;</span><span>)</span><span>)</span><span>)</span>
        <span>%default-channels</span><span>)</span></code></pre><p>After running <code>guix pull</code>, we can see the new package:</p><pre><code>$ guix describe
Generation 264  May 26 2023 16:00:35    (current)
  guile 36fd2b4
    repository URL: https://git.savannah.gnu.org/git/guile.git
    branch: main
    commit: 36fd2b4920ae926c79b936c29e739e71a6dff2bc
  guix c5bc698
    repository URL: https://git.savannah.gnu.org/git/guix.git
    commit: c5bc698e8922d78ed85989985cc2ceb034de2f23
$ guix package -A ^guile$
guile   3.0.99-git      out,debug       guile-package.scm:51:4
guile   3.0.9           out,debug       gnu/packages/guile.scm:317:2
guile   2.2.7           out,debug       gnu/packages/guile.scm:258:2
guile   2.2.4           out,debug       gnu/packages/guile.scm:304:2
guile   2.0.14          out,debug       gnu/packages/guile.scm:148:2
guile   1.8.8           out             gnu/packages/guile.scm:77:2
$ guix build guile@3.0.99-git
[…]
/gnu/store/axnzbl89yz7ld78bmx72vpqp802dwsar-guile-3.0.99-git-debug
/gnu/store/r34gsij7f0glg2fbakcmmk0zn4v62s5w-guile-3.0.99-git</code></pre><p>That’s how, as a developer, you get your software delivered directly into
the hands of users!  No intermediaries, yet no loss of transparency and
provenance tracking.</p><p>With that in place, it also becomes trivial for anyone to create Docker
images, Deb/RPM packages, or a plain tarball with <a href="https://guix.gnu.org/manual/devel/en/html_node/Invoking-guix-pack.html"><code>guix pack</code></a>:</p><pre><code># How about a Docker image of our Guile snapshot?
guix pack -f docker -S /bin=bin guile@3.0.99-git

# And a relocatable RPM?
guix pack -f rpm -R -S /bin=bin guile@3.0.99-git</code></pre><p>We now have an actual channel, but it contains only one package.  While
we’re at it, we can <a href="https://guix.gnu.org/manual/devel/en/html_node/Defining-Package-Variants.html">define package
variants</a>
in our <code>guile-package.scm</code> file, variants that we want to be able to
test as Guile developers—similar to what we did above with
transformation options.  We can add them like so:</p><pre><code>
<span>(</span><span>define-module</span> <span>(</span><span>guile-package</span><span>)</span>
  <span>…</span><span>)</span>

<span>(</span><span>define-public</span> <span>guile</span>
  <span>…</span><span>)</span>

<span>(</span><span>define</span> <span>(</span><span>package-with-configure-flags</span> <span>p</span> <span>flags</span><span>)</span>
  <span>&#34;Return P with FLAGS as addition &#39;configure&#39; flags.&#34;</span>
  <span>(</span><span>package/inherit</span> <span>p</span>
    <span>(</span><span>arguments</span>
     <span>(</span><span>substitute-keyword-arguments</span> <span>(</span><span>package-arguments</span> <span>p</span><span>)</span>
       <span>(</span><span>(</span><span>#:configure-flags</span> <span>original-flags</span> <span>#~</span><span>(</span><span>list</span><span>)</span><span>)</span>
        <span>#~</span><span>(</span><span>append</span> <span>#$original-flags</span> <span>#$flags</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span>

<span>(</span><span>define-public</span> <span>guile-without-threads</span>
  <span>(</span><span>package</span>
    <span>(</span><span>inherit</span> <span>(</span><span>package-with-configure-flags</span> <span>guile</span>
                                           <span>#~</span><span>(</span><span>list</span> <span>&#34;--without-threads&#34;</span><span>)</span><span>)</span><span>)</span>
    <span>(</span><span>name</span> <span>&#34;guile-without-threads&#34;</span><span>)</span><span>)</span><span>)</span>

<span>(</span><span>define-public</span> <span>guile-without-networking</span>
  <span>(</span><span>package</span>
    <span>(</span><span>inherit</span> <span>(</span><span>package-with-configure-flags</span> <span>guile</span>
                                           <span>#~</span><span>(</span><span>list</span> <span>&#34;--disable-networking&#34;</span><span>)</span><span>)</span><span>)</span>
    <span>(</span><span>name</span> <span>&#34;guile-without-networking&#34;</span><span>)</span><span>)</span><span>)</span>


<span>guile</span></code></pre><p>We can build these variants as regular packages once we’ve pulled the
channel.  Alternatively, from a checkout of Guile, we can run a command like
this one from the top level:</p><pre><code>guix build -L $PWD/.guix/modules guile-without-threads</code></pre><p>This channel becomes even more interesting once we set up <a href="https://en.wikipedia.org/wiki/Continuous_integration">continuous
integration</a> (CI).
There are several ways to do that.</p><p>You can use one of the mainstream continuous integration tools, such as
GitLab-CI.  To do that, you need to make sure you run jobs in a Docker
image or virtual machine that has Guix installed.  If we were to do that
in the case of Guile, we’d have a job that runs a shell command like
this one:</p><pre><code>guix build -L $PWD/.guix/modules guile@3.0.99-git</code></pre><p>Doing this works great and has the advantage of being easy to achieve on
your favorite CI platform.</p><p>That said, you’ll really get the most of it by using
<a href="https://guix.gnu.org/en/cuirass">Cuirass</a>, a CI tool designed for and
tightly integrated with Guix.  Using it is more work than using a hosted
CI tool because you first need to set it up, but that setup phase is
greatly simplified if you use its Guix System
<a href="https://guix.gnu.org/manual/devel/en/html_node/Continuous-Integration.html">service</a>.
Going back to our example, we give Cuirass a spec file that goes like
this:</p><pre><code><span>(</span><span>list</span> <span>(</span><span>specification</span>
        <span>(</span><span>name</span> <span>&#34;guile&#34;</span><span>)</span>
        <span>(</span><span>build</span> <span>&#39;</span><span>(</span><span>channels</span> <span>guile</span><span>)</span><span>)</span>
        <span>(</span><span>channels</span>
         <span>(</span><span>append</span> <span>(</span><span>list</span> <span>(</span><span>channel</span>
                         <span>(</span><span>name</span> <span>&#39;guile</span><span>)</span>
                         <span>(</span><span>url</span> <span>&#34;https://git.savannah.gnu.org/git/guile.git&#34;</span><span>)</span>
                         <span>(</span><span>branch</span> <span>&#34;main&#34;</span><span>)</span><span>)</span><span>)</span>
                 <span>%default-channels</span><span>)</span><span>)</span><span>)</span><span>)</span></code></pre><p>It differs from what you’d do with other CI tools in two important ways:</p><ul><li>Cuirass knows it’s tracking <em>two</em> channels, <code>guile</code> and <code>guix</code>.
Indeed, our own <code>guile</code> package depends on many packages provided by
the <code>guix</code> channel—GCC, the GNU libc, libffi, and so on.  Changes to
packages from the <code>guix</code> channel can potentially influence our
<code>guile</code> build and this is something we’d like to see as soon as
possible as Guile developers.</li><li>Build results are not thrown away: they can be distributed as
<a href="https://guix.gnu.org/manual/devel/en/html_node/Substitutes.html"><em>substitutes</em></a>
so that users of our <code>guile</code> channel transparently get pre-built
binaries!</li></ul><p>From a developer’s viewpoint, the end result is this <a href="https://ci.guix.gnu.org/jobset/guile">status
page</a> listing <em>evaluations</em>: each
evaluation is a combination of commits of the <code>guix</code> and <code>guile</code>
channels providing a number of <em>jobs</em>—one job per package defined in
<code>guile-package.scm</code> times the number of target architectures.</p><p>As for substitutes, they come for free!  As an example, since our
<code>guile</code> jobset is built on ci.guix.gnu.org, which runs <a href="https://guix.gnu.org/manual/devel/en/html_node/Invoking-guix-publish.html"><code>guix publish</code></a>
in addition to Cuirass, one automatically gets substitutes for <code>guile</code>
builds from ci.guix.gnu.org; no additional work is needed for that.</p><p>The Cuirass spec above is convenient: it builds every package in our
channel, which includes a few variants.  However, this might be
insufficiently expressive in some cases: one might want specific
cross-compilation jobs, transformations, Docker images, RPM/Deb
packages, or even system tests.</p><p>To achieve that, you can write a
<a href="https://guix.gnu.org/manual/devel/en/html_node/Writing-Manifests.html"><em>manifest</em></a>.
The one we have for Guile has entries for the package variants we
defined above, as well as additional variants and cross builds:</p><pre><code>
<span>(</span><span>use-modules</span> <span>(</span><span>guix</span><span>)</span>
             <span>(</span><span>guix</span> <span>profiles</span><span>)</span>
             <span>(</span><span>guile-package</span><span>)</span><span>)</span>   
<span>(</span><span>define*</span> <span>(</span><span>package-&gt;manifest-entry*</span> <span>package</span> <span>system</span>
                                   <span>#:key</span> <span>target</span><span>)</span>
  <span>&#34;Return a manifest entry for PACKAGE on SYSTEM, optionally cross-compiled to
TARGET.&#34;</span>
  <span>(</span><span>manifest-entry</span>
    <span>(</span><span>inherit</span> <span>(</span><span>package-&gt;manifest-entry</span> <span>package</span><span>)</span><span>)</span>
    <span>(</span><span>name</span> <span>(</span><span>string-append</span> <span>(</span><span>package-name</span> <span>package</span><span>)</span> <span>&#34;.&#34;</span> <span>system</span>
                         <span>(</span><span>if</span> <span>target</span>
                             <span>(</span><span>string-append</span> <span>&#34;.&#34;</span> <span>target</span><span>)</span>
                             <span>&#34;&#34;</span><span>)</span><span>)</span><span>)</span>
    <span>(</span><span>item</span> <span>(</span><span>with-parameters</span> <span>(</span><span>(</span><span>%current-system</span> <span>system</span><span>)</span>
                            <span>(</span><span>%current-target-system</span> <span>target</span><span>)</span><span>)</span>
            <span>package</span><span>)</span><span>)</span><span>)</span><span>)</span>

<span>(</span><span>define</span> <span>native-builds</span>
  <span>(</span><span>manifest</span>
   <span>(</span><span>append</span> <span>(</span><span>map</span> <span>(</span><span>lambda</span> <span>(</span><span>system</span><span>)</span>
                  <span>(</span><span>package-&gt;manifest-entry*</span> <span>guile</span> <span>system</span><span>)</span><span>)</span>

                <span>&#39;</span><span>(</span><span>&#34;x86_64-linux&#34;</span> <span>&#34;i686-linux&#34;</span>
                  <span>&#34;aarch64-linux&#34;</span> <span>&#34;armhf-linux&#34;</span>
                  <span>&#34;powerpc64le-linux&#34;</span><span>)</span><span>)</span>
           <span>(</span><span>map</span> <span>(</span><span>lambda</span> <span>(</span><span>guile</span><span>)</span>
                  <span>(</span><span>package-&gt;manifest-entry*</span> <span>guile</span> <span>&#34;x86_64-linux&#34;</span><span>)</span><span>)</span>
                <span>(</span><span>cons</span> <span>(</span><span>package</span>
                        <span>(</span><span>inherit</span> <span>(</span><span>package-with-c-toolchain</span>
                                  <span>guile</span>
                                  <span>`</span><span>(</span><span>(</span><span>&#34;clang-toolchain&#34;</span>
                                     <span>,</span><span>(</span><span>specification-&gt;package</span>
                                       <span>&#34;clang-toolchain&#34;</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span>
                        <span>(</span><span>name</span> <span>&#34;guile-clang&#34;</span><span>)</span><span>)</span>
                      <span>(</span><span>list</span> <span>guile-without-threads</span>
                            <span>guile-without-networking</span>
                            <span>guile-debug</span>
                            <span>guile-strict-typing</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span><span>)</span>

<span>(</span><span>define</span> <span>cross-builds</span>
  <span>(</span><span>manifest</span>
   <span>(</span><span>map</span> <span>(</span><span>lambda</span> <span>(</span><span>target</span><span>)</span>
          <span>(</span><span>package-&gt;manifest-entry*</span> <span>guile</span> <span>&#34;x86_64-linux&#34;</span>
                                    <span>#:target</span> <span>target</span><span>)</span><span>)</span>
        <span>&#39;</span><span>(</span><span>&#34;i586-pc-gnu&#34;</span>
          <span>&#34;aarch64-linux-gnu&#34;</span>
          <span>&#34;riscv64-linux-gnu&#34;</span>
          <span>&#34;i686-w64-mingw32&#34;</span>
          <span>&#34;x86_64-linux-gnu&#34;</span><span>)</span><span>)</span><span>)</span><span>)</span>

<span>(</span><span>concatenate-manifests</span> <span>(</span><span>list</span> <span>native-builds</span> <span>cross-builds</span><span>)</span><span>)</span></code></pre><p>We won’t go into the details of this manifest; suffice to say that it
provides additional flexibility.  We now need to tell Cuirass to build
this manifest, which is done with a spec slightly different from the
previous one:</p><pre><code><span>(</span><span>list</span> <span>(</span><span>specification</span>
        <span>(</span><span>name</span> <span>&#34;guile&#34;</span><span>)</span>
        <span>(</span><span>build</span> <span>&#39;</span><span>(</span><span>manifest</span> <span>&#34;.guix/manifest.scm&#34;</span><span>)</span><span>)</span>
        <span>(</span><span>channels</span>
         <span>(</span><span>append</span> <span>(</span><span>list</span> <span>(</span><span>channel</span>
                         <span>(</span><span>name</span> <span>&#39;guile</span><span>)</span>
                         <span>(</span><span>url</span> <span>&#34;https://git.savannah.gnu.org/git/guile.git&#34;</span><span>)</span>
                         <span>(</span><span>branch</span> <span>&#34;main&#34;</span><span>)</span><span>)</span><span>)</span>
                 <span>%default-channels</span><span>)</span><span>)</span><span>)</span><span>)</span></code></pre><p>We changed the <code>(build …)</code> part of the spec to <code>&#39;(manifest &#34;.guix/manifest.scm&#34;)</code> so that it would pick our manifest, and that’s
it!</p><p>We picked Guile as the running example in this post and you can see the
result here:</p><ul><li><a href="https://git.savannah.gnu.org/cgit/guile.git/tree/.guix-channel?id=cd57379b3df636198d8cd8e76c1bfbc523762e79"><code>.guix-channel</code></a>;</li><li><a href="https://git.savannah.gnu.org/cgit/guile.git/tree/.guix/modules/guile-package.scm?id=cd57379b3df636198d8cd8e76c1bfbc523762e79"><code>.guix/modules/guile-package.scm</code></a>
with the top-level <code>guix.scm</code> symlink;</li><li><a href="https://git.savannah.gnu.org/cgit/guile.git/tree/.guix/manifest.scm?id=cd57379b3df636198d8cd8e76c1bfbc523762e79"><code>.guix/manifest.scm</code></a>.</li></ul><p>These days, repositories are commonly peppered with dot files for
various tools: <code>.envrc</code>, <code>.gitlab-ci.yml</code>, <code>.github/workflows</code>,
<code>Dockerfile</code>, <code>.buildpacks</code>, <code>Aptfile</code>, <code>requirements.txt</code>, and whatnot.
It may sound like we’re proposing a bunch of <em>additional</em> files, but in
fact those files are expressive enough to <em>supersede</em> most or all of
those listed above.</p><p>With a couple of files, we get support for:</p><ul><li>development environments (<code>guix shell</code>);</li><li>pristine test builds, including for package variants and for
cross-compilation (<code>guix build</code>);</li><li>continuous integration (with Cuirass or with some other tool);</li><li>continuous delivery to users (<em>via</em> the channel and with pre-built
binaries);</li><li>generation of derivative build artifacts such as Docker images or
Deb/RPM packages (<code>guix pack</code>).</li></ul><p>At the Guix headquarters, we’re quite happy about the result.  We’ve
been building a unified tool set for reproducible software deployment;
this is an illustration of how you as a developer can benefit
from it!</p><p>Thanks to Attila Lendvai, Brian Cully, and Ricardo Wurmus for providing
feedback on an earlier draft of this post.</p><h4>About GNU Guix</h4><p><a href="https://guix.gnu.org">GNU Guix</a> is a transactional package manager and
an advanced distribution of the GNU system that <a href="https://www.gnu.org/distros/free-system-distribution-guidelines.html">respects user
freedom</a>.
Guix can be used on top of any system running the Hurd or the Linux
kernel, or it can be used as a standalone operating system distribution
for i686, x86_64, ARMv7, AArch64 and POWER9 machines.</p><p>In addition to standard package management features, Guix supports
transactional upgrades and roll-backs, unprivileged package management,
per-user profiles, and garbage collection.  When used as a standalone
GNU/Linux distribution, Guix offers a declarative, stateless approach to
operating system configuration management.  Guix is highly customizable
and hackable through <a href="https://www.gnu.org/software/guile">Guile</a>
programming interfaces and extensions to the
<a href="http://schemers.org">Scheme</a> language.</p><p>Unless otherwise stated, blog posts on this site are
copyrighted by their respective authors and published under the terms of
the <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC-BY-SA 4.0</a> license and those of the <a href="https://www.gnu.org/licenses/fdl-1.3.html">GNU Free Documentation License</a> (version 1.3 or later, with no Invariant Sections, no
Front-Cover Texts, and no Back-Cover Texts).</p></article></div></div>
  </body>
</html>
