<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://tigerbeetle.com/blog/2023-03-28-random-fuzzy-thoughts/">Original</a>
    <h1>Random Fuzzy Thoughts</h1>
    
    <div id="readability-page-1" class="page"><div>
  <p>I have been doing a lot of randomized testing and fuzzing lately, and I want to document some lessons learned.
This isn’t going to be a grand unified theory of fuzzing, but rather a collection of observations useful for people who already do randomized testing.
This post will explore three related questions:</p>
<ul>
<li>How to make generative fuzzing failures robustly reproducible?</li>
<li>How to use existing randomized testing infrastructure for specifying the tests manually?</li>
<li>How to check that generative fuzzing indeed covers interesting scenarios?</li>
</ul>
<h2 id="setting-the-stage">Setting the stage</h2>
<p>The basic idea behind <strong>fuzzing</strong> is that a fuzzer can generate a slice of random bytes, a <code>[]u8</code> which then serves as an input to a <a href="https://en.wikipedia.org/wiki/System_under_test">system under test</a>.
As a bonus point, the fuzzer can also observe the coverage of the program as it processes the input, and use that to smartly devise potentially interesting variations for input data.
This technique is particularly appropriate for parsers, which work on <code>[]u8</code> directly.</p>
<p>For example, if the fuzzer provides the generated input via stdin, the test could look like this:</p>
<div><pre tabindex="0"><code data-lang="zig"><span><span><span>pub</span> <span>fn</span> main() <span>!</span><span>void</span> {
</span></span><span><span>    <span>var</span> gpa <span>=</span> std.heap.GeneralPurposeAllocator(.{}){};
</span></span><span><span>    <span>const</span> allocator <span>=</span> gpa.allocator();
</span></span><span><span>
</span></span><span><span>    <span>// Read fuzzer&#39;s input.
</span></span></span><span><span><span></span>    <span>const</span> stdin <span>=</span> std.io.getStdIn();
</span></span><span><span>    <span>const</span> data<span>:</span> []<span>u8</span> <span>=</span> <span>try</span> stdin.readToEndAlloc(
</span></span><span><span>        allocator,
</span></span><span><span>        std.math.maxInt(<span>usize</span>),
</span></span><span><span>    );
</span></span><span><span>    <span>defer</span> allocator.free(data);
</span></span><span><span>
</span></span><span><span>    <span>// Run the system under test.
</span></span></span><span><span><span></span>    _ <span>=</span> system.parse(data) <span>catch</span> <span>|</span>err<span>|</span> {
</span></span><span><span>        _ <span>=</span> err;
</span></span><span><span>    };
</span></span><span><span>}
</span></span></code></pre></div><p>As we don’t know what the input data will be, we can’t assert anything specific about the result.
We can assert general properties, however, like “it does not crash”.
And, depending on the assertion density and depth of the code under test, “it does not crash” can cover quite a bit of ground!</p>
<p>A related idea is randomized, <strong>property based testing</strong>.
Often, the input to the program is not just a pile of random bytes, but rather something with more structure to it
(trees, lists, sequences of events, etc).
For these cases, it’s often convenient to generate the entire <em>structure</em> randomly:</p>
<div><pre tabindex="0"><code data-lang="zig"><span><span><span>const</span> Tree <span>=</span> <span>struct</span> {
</span></span><span><span>    value<span>:</span> <span>u32</span>,
</span></span><span><span>    children<span>:</span> [<span>2</span>]<span>?*</span>Tree,
</span></span><span><span>};
</span></span><span><span>
</span></span><span><span><span>fn</span> random_tree(
</span></span><span><span>    allocator<span>:</span> Allocator,
</span></span><span><span>    rng<span>:</span> Random,
</span></span><span><span>    depth_max<span>:</span> <span>u32</span>,
</span></span><span><span>) <span>!?*</span>Tree {
</span></span><span><span>    <span>if</span> (depth_max <span>==</span> <span>0</span>) <span>return</span> <span>null</span>;
</span></span><span><span>    <span>var</span> result <span>=</span> <span>try</span> allocator.create(Tree);
</span></span><span><span>    <span>errdefer</span> allocator.destroy(result);
</span></span><span><span>
</span></span><span><span>    result.value <span>=</span> rng.int(<span>u32</span>);
</span></span><span><span>    <span>for</span> (result.children) <span>|*</span>child<span>|</span> {
</span></span><span><span>        <span>const</span> depth <span>=</span> rng.uintLessThan(<span>u32</span>, depth_max);
</span></span><span><span>        child.<span>*</span> <span>=</span> <span>try</span> random_tree(allocator, rng, depth);
</span></span><span><span>    }
</span></span><span><span>
</span></span><span><span>    <span>return</span> result;
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>test</span> <span>&#34;structured input&#34;</span> {
</span></span><span><span>    <span>const</span> seed <span>=</span> <span>92</span>;
</span></span><span><span>    <span>const</span> depth_max <span>=</span> <span>8</span>;
</span></span><span><span>
</span></span><span><span>    <span>var</span> random <span>=</span> std.rand.DefaultPrng.init(seed);
</span></span><span><span>    <span>const</span> rng <span>=</span> random.random();
</span></span><span><span>    <span>const</span> tree <span>=</span> <span>try</span> random_tree(testing.allocator, rng, depth_max);
</span></span><span><span>    <span>defer</span> Tree.deinit(tree, testing.allocator);
</span></span><span><span>
</span></span><span><span>    system.reverse_tree(tree);
</span></span><span><span>}
</span></span></code></pre></div><p>A third variation which comes up in distributed systems is what I call <strong>randomized interaction</strong>.
Here, rather than generating a test input upfront and then running the system under test, the system and random generator are run concurrently, responding to each other’s actions.
This often comes up in distributed systems: a randomized test models a system with several nodes connected by an unreliable network.
Randomization determines which messages are delivered and which are dropped.
A simple implementation would model the network as a set of in-flight messages, such that a random message is delivered (or dropped) on every step:</p>
<div><pre tabindex="0"><code data-lang="zig"><span><span><span>const</span> Message <span>=</span> <span>struct</span> {
</span></span><span><span>    src<span>:</span> <span>u8</span>,
</span></span><span><span>    dst<span>:</span> <span>u8</span>,
</span></span><span><span>    payload<span>:</span> []<span>u8</span>,
</span></span><span><span>};
</span></span><span><span>
</span></span><span><span><span>const</span> Network <span>=</span> std.ArrayList(Message);
</span></span><span><span>
</span></span><span><span><span>test</span> <span>&#34;distributed system&#34;</span> {
</span></span><span><span>    <span>const</span> seed <span>=</span> <span>92</span>;
</span></span><span><span>    <span>const</span> drop_message_probability <span>=</span> <span>0.1</span>;
</span></span><span><span>
</span></span><span><span>    <span>var</span> random <span>=</span> std.rand.DefaultPrng.init(seed);
</span></span><span><span>    <span>const</span> rng <span>=</span> random.random();
</span></span><span><span>
</span></span><span><span>    <span>var</span> network <span>=</span> Network.init(testing.allocator);
</span></span><span><span>    <span>defer</span> network.deinit();
</span></span><span><span>
</span></span><span><span>    <span>while</span> (<span>true</span>) {
</span></span><span><span>        <span>const</span> message_index <span>=</span> rng.uintLessThan(
</span></span><span><span>            <span>usize</span>,
</span></span><span><span>            network.items.len,
</span></span><span><span>        );
</span></span><span><span>        <span>const</span> message <span>=</span> network.swapRemove(message_index);
</span></span><span><span>
</span></span><span><span>        <span>if</span> (rng.float(<span>f32</span>) <span>&lt;</span> drop_message_probability) {
</span></span><span><span>            <span>// drop the message
</span></span></span><span><span><span></span>        } <span>else</span> {
</span></span><span><span>            <span>const</span> new_messages <span>=</span> system.deliver_message(message);
</span></span><span><span>            <span>try</span> network.appendSlice(new_messages);
</span></span><span><span>        }
</span></span><span><span>    }
</span></span><span><span>}
</span></span></code></pre></div><h2 id="finite-prng">Finite PRNG</h2>
<p>One very fruitful idea is that the distance between “let’s ask an advanced coverage-guided fuzzer to generate a slice of bytes” and “let’s use PRNG to generate a tree-shaped input” is actually quite small.
It’s possible to join the two approaches together.
Input from the fuzzer can be treated as a PRNG which generates a finite number of random bytes.</p>
<div><pre tabindex="0"><code data-lang="zig"><span><span><span>const</span> FiniteRng <span>=</span> <span>struct</span> {
</span></span><span><span>    entropy<span>:</span> []<span>const</span> <span>u8</span>,
</span></span><span><span>
</span></span><span><span>    <span>pub</span> <span>fn</span> init(entropy<span>:</span> []<span>const</span> <span>u8</span>) FiniteRng {
</span></span><span><span>        <span>return</span> FiniteRng{ .entropy <span>=</span> entropy };
</span></span><span><span>    }
</span></span><span><span>
</span></span><span><span>    <span>pub</span> <span>fn</span> random_u8(rng<span>:</span> <span>*</span>FiniteRng) <span>error</span>{OutOfEntropy}<span>!</span><span>u8</span> {
</span></span><span><span>        <span>if</span> (rng.entropy.len <span>==</span> <span>0</span>) <span>return</span> <span>error</span>.OutOfEntropy;
</span></span><span><span>        <span>const</span> result <span>=</span> rng.entropy[<span>0</span>];
</span></span><span><span>        rng.entropy <span>=</span> rng.entropy[<span>1</span>..];
</span></span><span><span>        <span>return</span> result;
</span></span><span><span>    }
</span></span><span><span>};
</span></span></code></pre></div><p>I learned this idea from the most excellent <a href="https://docs.rs/arbitrary/latest/arbitrary/">arbitrary</a> crate.
There are two benefits here:</p>
<p><em>First</em>, we can use something like <a href="https://aflplus.plus">AFL</a> to generate entropy for our <code>FiniteRng</code>.
That way, we teach a coverage guided fuzzer to generate structured inputs.
By flipping bytes in the random unstructured array, the fuzzer would effectively apply local transformations to the structure we generate from the input.
In particular, if the fuzzer can minimize the input array, it now can minimize the structured input as well!
That’s not necessarily the most effective way to get minimization for free (I <em>think</em> Python’s <a href="https://hypothesis.works">Hypothesis</a> is doing something smarter), but it definitely punches above its weight!</p>
<p><em>Second</em>, the minimization idea works even without a smart fuzzer.
That is because the length of the <code>entropy</code> slice passed to <code>FiniteRng</code> measures the complexity of the structured result.
This works especially well for interactive tests.
For example, when simulating a distributed system, you can use entropy to simulate random network faults.
After you run out of entropy, the network becomes reliable and the state of the system converges in a finite number of steps (or there’s a liveness bug which you can flag).
Binary searching the smallest amount of entropy which still triggers the bug yields a minimal test case.</p>
<p>I codified my favorite simplistic setup for these style of tests into the <a href="https://docs.rs/arbtest">arbtest</a> library.
Each test is fully defined by a seed — a <code>u64</code>.
This <code>u64</code> is actually two <code>u32</code> joined together — one component defines the length of a slice of random bytes, the other is the seed for a PRNG to fill the bytes.
As the seed is just a number, it’s easy to share it with colleagues in a chat message.
And as the seed encodes the length, it’s possible to employ a naive, but practically effective minimization strategy of just trying random seeds with smaller lengths.</p>
<p>And this is a nice segue into the next idea:</p>
<h2 id="serializing-an-instance-of-a-fuzz-test">Serializing an instance of a fuzz test</h2>
<p>We’ve already seen two ways to do this.
If the raw input to the test is a slice of bytes generated by the fuzzer, you can save that directly.
More conveniently, the sequence of bytes can be generated from a small seed for the PRNG, in which case the seed is all you need to reproduce the test.</p>
<p>Both approaches are problematic though — if you use raw random bytes to generate structured data, then small tweaks to the generation procedure can drastically change the meaning of a seed.
Really, you need two numbers for reproducibility — the seed, and the commit hash.
Trying the same seed on a different branch would probably trigger a semantically different test.</p>
<p>To stay concrete, let’s say we are <a href="https://fitzgeraldnick.com/2020/08/24/writing-a-test-case-generator.html">generating random WASM programs</a> to fuzz a WASM runtime.
We start with raw bytes, feed them through <a href="https://docs.rs/wasm-smith/latest/wasm_smith/">wasm-smith</a> to get a syntactically valid WASM module, and feed that into our compiler.
If we found a bug with a particular seed, how do we add it to our test corpus?
Again, just adding a seed won’t be robust enough — <code>cargo update -p wasm-smith</code> would probably silently break all our tests.
The answer here I think is serializing not the unstructured seed, but the actual generated structured data (the <code>.wasm</code> module in this case; see also <a href="https://github.com/camshaft/bolero/issues/91">camshaft/bolero#49</a>).
If the test infra is formulated as three nicely separated phases:</p>
<div><pre tabindex="0"><code data-lang="zig"><span><span><span>const</span> unstructured <span>=</span> get_random_data();
</span></span><span><span>
</span></span><span><span><span>const</span> structured <span>=</span> build_structure(unstructured);
</span></span><span><span>
</span></span><span><span>system.process(structured)
</span></span></code></pre></div><p>Then you can re-use the same driver code for:</p>
<ul>
<li>fuzzing with random data</li>
<li>replaying serialized fuzz failures</li>
<li>fully manual tests with hand-crafted inputs</li>
</ul>
<p>Nifty!</p>
<p>However, this strategy breaks when we go from generating a structured input to an interactive test.
Again, consider a test for a distributed system, where a PRNG is used to decide which messages in the network should be dropped.
We <em>can’t</em> just serialize the sequence of decisions of which packets to deliver — small updates to the system might lead to slightly different sequences of messages emitted.
For example, changing the heartbeat timeout changes the sequence of messages every node sends, but, intuitively, this shouldn’t meaningfully affect the set of interesting interleavings.
I don’t know a good way to handle this.</p>
<h2 id="predicate-coverage">Predicate coverage</h2>
<p>Or maybe I do — last week I got another interesting idea in this space.
I was fighting (or rather just chasing) a particularly nasty bug in TigerBeetle.
It was nasty, because it was a liveness bug, rather than a correctness bug — nothing was wrong in particular, but nothing good was happening either.
I didn’t have immediate success with smoking the bug out using our randomized testing infrastructure.
I even began to doubt whether the bug existed at all.</p>
<p>So, I decided to manually reproduce the issue.
The problem is that manually working as a nefarious mailman for a bunch of rather chatty nodes is not fun.
There was a particular sequence of interesting messages I wanted to try, but to do that, I needed to handle a whole bunch of auxiliary normal messages as well.
And then I realized that our randomized testing infrastructure, our simulator, our beloved <a href="https://github.com/tigerbeetledb/tigerbeetle/blob/main/src/vopr_hub/README.md#the-vopr">VOPR</a> can handle the boring parts for me.
In particular, I can start the simulator with all failure probabilities set to zero, such that it simulates a perfect network.
This network then handles the routine of relaying all the auxiliary messages such as heartbeats or confirmations.
On top of this normally ticking network, I can then write my nefarious test in a somewhat prologish way.
Rather than dropping a particular message or otherwise executing a particular series of steps, the test operates with predicates.
It drops all messages of a particular kind, waits until the nodes are in a particular state (this again is a predicate), then changes the condition to drop the messages.
<a href="https://github.com/tigerbeetledb/tigerbeetle/blob/2351c7a1dc9b982602d7140fadc8a10c65b3007c/src/simulator.zig#L246-L260">The end result</a> turned out to be quite concise — I was able to state, more or less directly, the scenario which would lead to a livelock, and the simulator filled in all of the blanks!</p>
<p>I think I’ve seen something similar before, in <a href="https://kenmcmil.github.io/ivy/">IVy</a> or <a href="https://github.com/wilcoxjay/mypyvy">mypyvy</a>.
Those tools can prove correctness of various distributed systems.
You specify the system as a logical formula, TLA+-style, then you spell-out the inductive invariant, and the system tries to automatically derive the invariant (or find the case where it doesn’t hold).
An interesting feature there is that you can help the prover along by providing it with intermediate results.
You dot the outline, and the tool connects the dots.</p>
<p>I think this gives us a way to robustly “serialize” interesting execution traces for interactive randomized tests.
A serialization would be a series of predicates over the state of the system.
This serialization can’t be replayed directly, but we can just pick a random trace and see if it hits the series of predicates in order.
Moreover, we can construct the trace piece-wise — we don’t have to find a single seed which goes through all of the transitions, we can use separate seeds for each transition, and discover them incrementally
(this requires the predicates to be rather tight, such that they guarantee the existence of piece-wise transitions).</p>
<p>The regression test suite can be a collection of such trace-predicates.
Curiously, this test suite will also give an answer to an important question: “how long do I fuzz each PR?”.
You fuzz just enough to hit all of the recorded traces.</p>
<h2 id="conclusions">Conclusions</h2>
<p>That’s all I have for today!
No grand theorems, but let’s recap some of the ideas</p>
<ul>
<li>Randomized and fuzz tests are great as ever!</li>
<li><em>Finite</em> PRNG is a useful concept to think about:
<ul>
<li>It glues unstructured, coverage guided fuzzed to structured property based testing.</li>
<li>It provides a natural measure of complexity for structured data.
The “length” of a graph is the size of the random seed needed to produce it.</li>
<li>It provides shrinking (test case minimization) for free.</li>
</ul>
</li>
<li>For interactive simulations, FPRNG gives a natural answer for when to wind the simulation down.</li>
<li>A PRNG seed is enough to reproduce a random test at a specific commit.
For robust reproduction across different commits, you need to persist the derived structured data, and not just the seed.</li>
<li>For interactive random tests, it’s useful to think about key frames — predicates over the state of the system, which sufficiently narrow down what the test is about, without specifying all the events in exhaustive detail.</li>
</ul>
<blockquote><p lang="en" dir="ltr">In our latest post, matklad muses about randomized testing and shares some of his lessons learned.<a href="https://t.co/5VshbiXSMS">https://t.co/5VshbiXSMS</a> <a href="https://t.co/iVs0NvhJ1y">pic.twitter.com/iVs0NvhJ1y</a></p>— TigerBeetle (@TigerBeetleDB) <a href="https://twitter.com/TigerBeetleDB/status/1640684709532299268?ref_src=twsrc%5Etfw">March 28, 2023</a></blockquote> 

</div></div>
  </body>
</html>
