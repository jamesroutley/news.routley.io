<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/WebAssembly/memory64/blob/main/proposals/memory64/Overview.md">Original</a>
    <h1>Memory64</h1>
    
    <div id="readability-page-1" class="page"><div><div><div><section aria-labelledby="file-name-id-wide file-name-id-mobile"><div data-hpc="true"><article itemprop="text">

<p dir="auto">This page describes a proposal to support linear memory of sizes larger than
2<sup>32</sup> bits. It provides no new instructions, but instead extends the
currently existing instructions to allow 64-bit indexes.</p>
<p dir="auto">In addition, in order to support source languages with 64-bit pointer width,
this proposal also extends tables to allow 64-bit indexes.  This addition was
made during phase 3 of the proposal and we refer to this addition as &#34;table64&#34;.</p>

<ul dir="auto">
<li>spec interpreter: Done</li>
<li>v8/chrome: <a href="https://chromium-review.googlesource.com/c/v8/v8/+/2679683" rel="nofollow">Done</a></li>
<li>Firefox: Done</li>
<li>Safari: ?</li>
<li>wabt: <a href="https://github.com/WebAssembly/wabt/pull/1500" data-hovercard-type="pull_request" data-hovercard-url="/WebAssembly/wabt/pull/1500/hovercard">Done</a></li>
<li>binaryen: <a href="https://github.com/WebAssembly/binaryen/pull/3202" data-hovercard-type="pull_request" data-hovercard-url="/WebAssembly/binaryen/pull/3202/hovercard">Done</a></li>
<li>emscripten: <a href="https://github.com/emscripten-core/emscripten/pull/17803" data-hovercard-type="pull_request" data-hovercard-url="/emscripten-core/emscripten/pull/17803/hovercard">Done</a></li>
</ul>
<div dir="auto"><h3 tabindex="-1" dir="auto">Implementation Status (table64)</h3><a id="user-content-implementation-status-table64" aria-label="Permalink: Implementation Status (table64)" href="#implementation-status-table64"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<ul dir="auto">
<li>spec interpreter: <a href="https://github.com/WebAssembly/table64/53">Done</a></li>
<li>v8/chrome: <a href="https://issues.chromium.org/issues/338024338" rel="nofollow">WIP</a></li>
<li>Firefox: <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1893643" rel="nofollow">WIP</a></li>
<li>Safari: -</li>
<li>wabt: Done</li>
<li>binaryen: Done</li>
<li>emscripten: Done</li>
</ul>

<p dir="auto"><a href="https://webassembly.github.io/spec/core/syntax/modules.html#memories" rel="nofollow">WebAssembly linear memory objects</a> have sizes measured in
<a href="https://webassembly.github.io/spec/core/exec/runtime.html#page-size" rel="nofollow">pages</a>. Each page is 65536 (2<sup>16</sup>) bytes. In WebAssembly
version 1, a linear memory can have at most 65536 pages, for a total of
2<sup>32</sup> bytes (4 <a href="https://en.wikipedia.org/wiki/Gibibyte" rel="nofollow">gibibytes</a>).</p>
<p dir="auto">In addition to this page limit, all <a href="https://webassembly.github.io/spec/core/syntax/instructions.html#memory-instructions" rel="nofollow">memory instructions</a> currently use the
<a href="https://webassembly.github.io/spec/core/syntax/types.html#syntax-valtype" rel="nofollow"><code>i32</code> type</a> as a memory index. This means they can address at most
2<sup>32</sup> bytes as well.</p>
<p dir="auto">For many applications, 4 gibibytes of memory is enough. Using 32-bit memory
indexes is sufficient in this case, and has the additional benefit that
pointers in the producer language are smaller, which can yield memory savings.
However, for applications that need more memory than this, there are no easy
workarounds given the current WebAssembly feature set. Allowing the WebAssembly
module to choose between 32-bit and 64-bit memory indexes addresses both
concerns.</p>
<p dir="auto">Similarly, since WebAssembly is a Virtual <a href="https://en.wikipedia.org/wiki/Instruction_set_architecture" rel="nofollow">Instruction Set Architecture</a>
(ISA), some hosts may want to use the WebAssembly binary format as a portable
executable format, in addition to supporting other non-virtual ISAs. Nearly all
ISAs have support for 64-bit memory addresses now, and a host may not want to
have to support 32-bit memory addresses in their ABI.</p>


<ul dir="auto">
<li>
<p dir="auto">The <a href="https://webassembly.github.io/spec/core/syntax/types.html#syntax-limits" rel="nofollow">limits</a> structure is changed to use <code>u64</code>
￼  - <code>limits ::= {min u64, max u64?}</code></p>
</li>
<li>
<p dir="auto">A new <code>addrtype</code> can be either <code>i32</code> or <code>i64</code></p>
<ul dir="auto">
<li><code>addrtype ::= i32 | i64</code></li>
</ul>
</li>
<li>
<p dir="auto">The <a href="https://webassembly.github.io/spec/core/syntax/types.html#memory-types" rel="nofollow">memory type</a> and <a href="https://webassembly.github.io/spec/core/syntax/types.html#table-types" rel="nofollow">table type</a>
structures are extended to include an address type</p>
<ul dir="auto">
<li><code>memtype ::= addrtype limits</code></li>
<li><code>tabletype ::= addrtype limits reftype</code></li>
</ul>
</li>
<li>
<p dir="auto">The <a href="https://webassembly.github.io/spec/core/syntax/instructions.html#syntax-memarg" rel="nofollow">memarg</a> immediate is changed to allow a 64-bit offset</p>
<ul dir="auto">
<li><code>memarg ::= {offset u64, align u32}</code></li>
</ul>
</li>
</ul>

<ul dir="auto">
<li>
<p dir="auto">Address types are classified by their value range:</p>
<ul dir="auto">
<li>
<div data-snippet-clipboard-copy-content="----------------
⊦ i32 : 2**16"><pre><code>----------------
⊦ i32 : 2**16
</code></pre></div>
</li>
<li>
<div data-snippet-clipboard-copy-content="----------------
⊦ i64 : 2**48"><pre><code>----------------
⊦ i64 : 2**48
</code></pre></div>
</li>
</ul>
</li>
<li>
<p dir="auto"><a href="https://webassembly.github.io/spec/core/valid/types.html#limits" rel="nofollow">Memory page limits</a> and <a href="https://webassembly.github.io/spec/core/valid/types.html#limits" rel="nofollow">Table entry limits</a> are
classified by their respective address types</p>
<ul dir="auto">
<li>
<div data-snippet-clipboard-copy-content="⊦ it : k    n &lt;= k    (m &lt;= k)?    (n &lt; m)?
-------------------------------------------
⊦ { min n, max m? } : it"><pre><code>⊦ it : k    n &lt;= k    (m &lt;= k)?    (n &lt; m)?
-------------------------------------------
⊦ { min n, max m? } : it
</code></pre></div>
</li>
</ul>
</li>
<li>
<p dir="auto">Memory and Table types are validated accordingly:</p>
<ul dir="auto">
<li>
<div data-snippet-clipboard-copy-content="⊦ limits : it
--------------
⊦ it limits ok"><pre><code>⊦ limits : it
--------------
⊦ it limits ok
</code></pre></div>
</li>
</ul>
</li>
<li>
<p dir="auto">All <a href="https://webassembly.github.io/spec/core/valid/instructions.html#memory-instructions" rel="nofollow">memory instructions</a> are changed to use the address type,
and the offset must also be in range of the address type</p>
<ul dir="auto">
<li>t.load memarg
<ul dir="auto">
<li>
<div data-snippet-clipboard-copy-content="C.mems[0] = at limits   2**memarg.align &lt;= |t|/8   memarg.offset &lt; 2**|at|
--------------------------------------------------------------------------
                    C ⊦ t.load memarg : [at] → [t]"><pre><code>C.mems[0] = at limits   2**memarg.align &lt;= |t|/8   memarg.offset &lt; 2**|at|
--------------------------------------------------------------------------
                    C ⊦ t.load memarg : [at] → [t]
</code></pre></div>
</li>
</ul>
</li>
<li>t.loadN_sx memarg
<ul dir="auto">
<li>
<div data-snippet-clipboard-copy-content="C.mems[0] = at limits   2**memarg.align &lt;= N/8   memarg.offset &lt; 2**|at|
------------------------------------------------------------------------
                  C ⊦ t.loadN_sx memarg : [at] → [t]"><pre><code>C.mems[0] = at limits   2**memarg.align &lt;= N/8   memarg.offset &lt; 2**|at|
------------------------------------------------------------------------
                  C ⊦ t.loadN_sx memarg : [at] → [t]
</code></pre></div>
</li>
</ul>
</li>
<li>t.store memarg
<ul dir="auto">
<li>
<div data-snippet-clipboard-copy-content="C.mems[0] = at limits   2**memarg.align &lt;= |t|/8   memarg.offset &lt; 2**|at|
--------------------------------------------------------------------------
                   C ⊦ t.store memarg : [at t] → []"><pre><code>C.mems[0] = at limits   2**memarg.align &lt;= |t|/8   memarg.offset &lt; 2**|at|
--------------------------------------------------------------------------
                   C ⊦ t.store memarg : [at t] → []
</code></pre></div>
</li>
</ul>
</li>
<li>t.storeN_sx memarg
<ul dir="auto">
<li>
<div data-snippet-clipboard-copy-content="C.mems[0] = at limits   2**memarg.align &lt;= N/8   memarg.offset &lt; 2**|t|
------------------------------------------------------------------------
                 C ⊦ t.storeN_sx memarg : [at t] → []"><pre><code>C.mems[0] = at limits   2**memarg.align &lt;= N/8   memarg.offset &lt; 2**|t|
------------------------------------------------------------------------
                 C ⊦ t.storeN_sx memarg : [at t] → []
</code></pre></div>
</li>
</ul>
</li>
<li>memory.size
<ul dir="auto">
<li>
<div data-snippet-clipboard-copy-content="   C.mems[0] = at limits
---------------------------
C ⊦ memory.size : [] → [at]"><pre><code>   C.mems[0] = at limits
---------------------------
C ⊦ memory.size : [] → [at]
</code></pre></div>
</li>
</ul>
</li>
<li>memory.grow
<ul dir="auto">
<li>
<div data-snippet-clipboard-copy-content="    C.mems[0] = at limits
-----------------------------
C ⊦ memory.grow : [at] → [at]"><pre><code>    C.mems[0] = at limits
-----------------------------
C ⊦ memory.grow : [at] → [at]
</code></pre></div>
</li>
</ul>
</li>
<li>memory.fill
<ul dir="auto">
<li>
<div data-snippet-clipboard-copy-content="    C.mems[0] = at limits
-----------------------------
C ⊦ memory.fill : [at i32 at] → []"><pre><code>    C.mems[0] = at limits
-----------------------------
C ⊦ memory.fill : [at i32 at] → []
</code></pre></div>
</li>
</ul>
</li>
<li>memory.copy
<ul dir="auto">
<li>
<div data-snippet-clipboard-copy-content="    C.mems[0] = at limits
-----------------------------
C ⊦ memory.copy : [at at at] → []"><pre><code>    C.mems[0] = at limits
-----------------------------
C ⊦ memory.copy : [at at at] → []
</code></pre></div>
</li>
</ul>
</li>
<li>memory.init x
<ul dir="auto">
<li>
<div data-snippet-clipboard-copy-content="    C.mems[0] = at limits   C.datas[x] = ok
-------------------------------------------
    C ⊦ memory.init : [at i32 i32] → []"><pre><code>    C.mems[0] = at limits   C.datas[x] = ok
-------------------------------------------
    C ⊦ memory.init : [at i32 i32] → []
</code></pre></div>
</li>
</ul>
</li>
<li>(and similar for memory instructions from other proposals)</li>
</ul>
</li>
<li>
<p dir="auto"><a href="https://webassembly.github.io/spec/core/valid/instructions.html#table-instructions" rel="nofollow">Table instructions</a> are changed to use the address type</p>
<ul dir="auto">
<li>call_indirect x y
<ul dir="auto">
<li>
<div data-snippet-clipboard-copy-content="  C.tables[x] = at limits t  C.types[y] = [t1*] → [t2*]
-------------------------------------------------------
C ⊦ call_indirect x y : [t1* at] → [t2*]"><pre><code>  C.tables[x] = at limits t  C.types[y] = [t1*] → [t2*]
-------------------------------------------------------
C ⊦ call_indirect x y : [t1* at] → [t2*]
</code></pre></div>
</li>
</ul>
</li>
<li>table.get x
<ul dir="auto">
<li>
<div data-snippet-clipboard-copy-content="  C.tables[x] = at limits t
------------------------------
C ⊦ table.get x : [at] → [t]"><pre><code>  C.tables[x] = at limits t
------------------------------
C ⊦ table.get x : [at] → [t]
</code></pre></div>
</li>
</ul>
</li>
<li>table.set x
<ul dir="auto">
<li>
<div data-snippet-clipboard-copy-content="  C.tables[x] = at limits t
------------------------------
C ⊦ table.set x : [at t] → []"><pre><code>  C.tables[x] = at limits t
------------------------------
C ⊦ table.set x : [at t] → []
</code></pre></div>
</li>
</ul>
</li>
<li>table.size x
<ul dir="auto">
<li>
<div data-snippet-clipboard-copy-content="  C.tables[x] = at limits t
------------------------------
C ⊦ table.size x : [] → [at]"><pre><code>  C.tables[x] = at limits t
------------------------------
C ⊦ table.size x : [] → [at]
</code></pre></div>
</li>
</ul>
</li>
<li>table.grow x
<ul dir="auto">
<li>
<div data-snippet-clipboard-copy-content="  C.tables[x] = at limits t
-------------------------------
C ⊦ table.grow x : [t at] → [at]"><pre><code>  C.tables[x] = at limits t
-------------------------------
C ⊦ table.grow x : [t at] → [at]
</code></pre></div>
</li>
</ul>
</li>
<li>table.fill x
<ul dir="auto">
<li>
<div data-snippet-clipboard-copy-content="  C.tables[x] = at limits t
----------------------------------
C ⊦ tables.fill x : [at t at] → []"><pre><code>  C.tables[x] = at limits t
----------------------------------
C ⊦ tables.fill x : [at t at] → []
</code></pre></div>
</li>
</ul>
</li>
<li>table.copy x y
<ul dir="auto">
<li>
<div data-snippet-clipboard-copy-content="  C.tables[d] = aN limits t   C.tables[s] = aM limits t    K = min {aN, AM}
-----------------------------------------------------------------------------
C ⊦ table.copy d s : [aN aM aK] → []"><pre><code>  C.tables[d] = aN limits t   C.tables[s] = aM limits t    K = min {aN, AM}
-----------------------------------------------------------------------------
C ⊦ table.copy d s : [aN aM aK] → []
</code></pre></div>
</li>
</ul>
</li>
<li>table.init x y
<ul dir="auto">
<li>
<div data-snippet-clipboard-copy-content="    C.tables[x] = at limits t   C.elems[y] = ok
-----------------------------------------------
    C ⊦ table.init x y : [at i32 i32] → []"><pre><code>    C.tables[x] = at limits t   C.elems[y] = ok
-----------------------------------------------
    C ⊦ table.init x y : [at i32 i32] → []
</code></pre></div>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p dir="auto">The <a href="https://github.com/webassembly/simd">SIMD proposal</a> extends <code>t.load memarg</code> and <code>t.store memarg</code>
above such that <code>t</code> may now also be <code>v128</code>, which accesses a 16-byte quantity
in memory that is also 16-byte aligned.</p>
<p dir="auto">In addition to this, it also has these SIMD specific memory operations (see
<a href="https://github.com/webassembly/simd">SIMD proposal</a> for full semantics):</p>
<ul dir="auto">
<li><code>v128.loadN_zero memarg</code> (where N = 32/64):
Load a single 32-bit or 64-bit element into the lowest bits of a <code>v128</code>
vector, and initialize all other bits of the <code>v128</code> vector to zero.</li>
<li><code>v128.loadN_splat memarg</code> (where N = 8/16/32/64):
Load a single element and splat to all lanes of a <code>v128</code> vector. The natural
alignment is the size of the element loaded.</li>
<li><code>v128.loadN_lane memarg v128 immlaneidx</code> (where N = 8/16/32/64):
Load a single element from <code>memarg</code> into the lane of the <code>v128</code> specified in
the immediate mode operand <code>immlaneidx</code>. The values of all other lanes of
the <code>v128</code> are bypassed as is.</li>
<li><code>v128.storeN_lane memarg v128 immlaneidx</code> (where N = 8/16/32/64):
Store into <code>memarg</code> the lane of <code>v128</code> specified in the immediate mode
operand <code>immlaneidx</code>.</li>
<li><code>v128.loadL_sx memarg</code> (where L is <code>8x8</code>/<code>16x4</code>/<code>32x2</code>, and sx is <code>s</code>/<code>u</code>):
Fetch consecutive integers up to 32-bit wide and produce a vector with lanes
up to 64 bits. The natural alignment is 8 bytes.</li>
</ul>
<p dir="auto">All these operations now take 64-bit address operands when used with a
64-bit memory.</p>
</li>
<li>
<p dir="auto">The <a href="https://github.com/webassembly/threads">Threads proposal</a> has <code>atomic</code> versions of <code>t.load</code>, <code>t.store</code>,
(and <code>t.loadN_u</code> / <code>t.storeN_u</code>, no sign-extend) specified above, except with
<code>.</code> replaced by <code>.atomic.</code>, and the guarantee of ordering of accesses being
sequentially consistent.</p>
<p dir="auto">In addition to this, it has the following memory operations (see
<a href="https://github.com/webassembly/threads">Threads proposal</a> for full semantics):</p>
<ul dir="auto">
<li><code>t.atomic.rmwN.op_u memarg</code> (where t = 32/64, N = 8/16/32 when &lt; t or empty
otherwise, op is <code>add</code>/<code>sub</code>/<code>and</code>/<code>or</code>/<code>xor</code>/<code>xchg</code>/<code>cmpxchg</code>, and <code>_u</code>
only present when N is not empty):
The first 6 operations atomically read a value from an address, modify the
value, and store the resulting value to the same address. They then return
the value read from memory before the modify operation was performed.
In the case of <code>cmpxchg</code>, the operands are an address, an expected value,
and a replacement value. If the loaded value is equal to the expected value,
the replacement value is stored to the same memory address. If the values
are not equal, no value is stored. In either case, the loaded value is
returned.</li>
<li><code>memory.atomic.waitN</code> (where N = 32/64):
The wait operator take three operands: an address operand, an expected
value, and a relative timeout in nanoseconds as an <code>i64</code>. The return value
is <code>0</code>, <code>1</code>, or <code>2</code>, returned as an <code>i32</code>.</li>
<li><code>memory.atomic.notify</code>:
The notify operator takes two operands: an address operand and a count as an
unsigned <code>i32</code>. The operation will notify as many waiters as are waiting on
the same effective address, up to the maximum as specified by count. The
operator returns the number of waiters that were woken as an unsigned <code>i32</code>.</li>
</ul>
<p dir="auto">All these operations now take 64-bit address operands when used with a
64-bit memory.</p>
</li>
<li>
<p dir="auto">The <a href="https://github.com/webassembly/multi-memory">Multi-memory proposal</a> extends each of these instructions
with one or two memory index immediates. The address type for that memory will
be used. For example,</p>
<ul dir="auto">
<li>memory.size x
<ul dir="auto">
<li>
<div data-snippet-clipboard-copy-content="   C.mems[x] = at limits
---------------------------
C ⊦ memory.size x : [] → [at]"><pre><code>   C.mems[x] = at limits
---------------------------
C ⊦ memory.size x : [] → [at]
</code></pre></div>
</li>
</ul>
</li>
</ul>
<p dir="auto"><code>memory.copy</code> has two memory index immediates, so will have multiple possible
signatures:</p>
<ul dir="auto">
<li>memory.copy d s
<ul dir="auto">
<li>
<div data-snippet-clipboard-copy-content="C.mems[d] = aN limits   C.mems[s] = aM limits    K = min {aN, aM}
---------------------------------------------------------------
    C ⊦ memory.copy d s : [aN aM aK] → []"><pre><code>C.mems[d] = aN limits   C.mems[s] = aM limits    K = min {aN, aM}
---------------------------------------------------------------
    C ⊦ memory.copy d s : [aN aM aK] → []
</code></pre></div>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p dir="auto"><a href="https://webassembly.github.io/spec/core/valid/modules.html#data-segments" rel="nofollow">Data segment validation</a> uses the address type</p>
<ul dir="auto">
<li>
<div data-snippet-clipboard-copy-content="C.mems[0] = at limits   C ⊦ expr: [at]   C ⊦ expr const
-------------------------------------------------------
      C ⊦ {data x, offset expr, init b*} ok"><pre><code>C.mems[0] = at limits   C ⊦ expr: [at]   C ⊦ expr const
-------------------------------------------------------
      C ⊦ {data x, offset expr, init b*} ok
</code></pre></div>
</li>
</ul>
</li>
</ul>

<ul dir="auto">
<li>
<p dir="auto"><a href="https://webassembly.github.io/spec/core/exec/runtime.html#memory-instances" rel="nofollow">Memory instances</a> are extended to have 64-bit vectors and a <code>u64</code>
max size</p>
<ul dir="auto">
<li><code>meminst ::= { data vec64(byte), max u64? }</code></li>
</ul>
</li>
<li>
<p dir="auto"><a href="https://webassembly.github.io/spec/core/exec/instructions.html#memory-instructions" rel="nofollow">Memory instructions</a> use the address type instead of <code>i32</code></p>
<ul dir="auto">
<li><code>t.load memarg</code></li>
<li><code>t.loadN_sx  memarg</code></li>
<li><code>t.store memarg</code></li>
<li><code>t.storeN memarg</code></li>
<li><code>memory.size</code></li>
<li><code>memory.grow</code></li>
<li>(spec text omitted)</li>
</ul>
</li>
<li>
<p dir="auto"><a href="https://webassembly.github.io/spec/core/exec/instructions.html#exec-memory-grow" rel="nofollow">memory.grow</a> has behavior that depends on the address type:</p>
<ul dir="auto">
<li>for <code>i32</code>: no change</li>
<li>for <code>i64</code>: check for a size greater than 2<sup>64</sup> - 1, and return
2<sup>64</sup> - 1 when <code>memory.grow</code> fails.</li>
</ul>
</li>
<li>
<p dir="auto"><a href="https://webassembly.github.io/spec/core/exec/modules.html#memories" rel="nofollow">Memory import matching</a> requires that the address type matches</p>
<ul dir="auto">
<li>
<div data-snippet-clipboard-copy-content="  at_1 = at_2   ⊦ limits_1 &lt;= limits_2
----------------------------------------
⊦ mem at_1 limits_1 &lt;= mem at_2 limits_2"><pre><code>  at_1 = at_2   ⊦ limits_1 &lt;= limits_2
----------------------------------------
⊦ mem at_1 limits_1 &lt;= mem at_2 limits_2
</code></pre></div>
</li>
</ul>
</li>
<li>
<p dir="auto">Bounds checking is required to be the same as for 32-bit memories, that is,
the address + offset (a <code>u65</code>) of a load or store operation is required to be
checked against the current memory size and trap if out of range.</p>
<p dir="auto">It is expected that the cost of this check remains low, if an implementation
can implement the address check with a branch, and the offset separately using a
guard page for all smaller offsets. Repeated accesses over the same address and
different offsets allow simple elimination of subsequent checks.</p>
</li>
</ul>

<ul dir="auto">
<li>
<p dir="auto">The <a href="https://webassembly.github.io/spec/core/binary/types.html#limits" rel="nofollow">limits</a> structure also encodes an additional value to
indicate the address type</p>
<ul dir="auto">
<li>
<div data-snippet-clipboard-copy-content="limits ::= 0x00 n:u32        ⇒ i32, {min n, max ϵ}, 0
        |  0x01 n:u32 m:u32  ⇒ i32, {min n, max m}, 0
        |  0x02 n:u32        ⇒ i32, {min n, max ϵ}, 1  ;; from threads proposal
        |  0x03 n:u32 m:u32  ⇒ i32, {min n, max m}, 1  ;; from threads proposal
        |  0x04 n:u64        ⇒ i64, {min n, max ϵ}, 0
        |  0x05 n:u64 m:u64  ⇒ i64, {min n, max m}, 0
        |  0x06 n:u64        ⇒ i64, {min n, max ϵ}, 1  ;; from threads proposal
        |  0x07 n:u64 m:u64  ⇒ i64, {min n, max m}, 1  ;; from threads proposal"><pre><code>limits ::= 0x00 n:u32        ⇒ i32, {min n, max ϵ}, 0
        |  0x01 n:u32 m:u32  ⇒ i32, {min n, max m}, 0
        |  0x02 n:u32        ⇒ i32, {min n, max ϵ}, 1  ;; from threads proposal
        |  0x03 n:u32 m:u32  ⇒ i32, {min n, max m}, 1  ;; from threads proposal
        |  0x04 n:u64        ⇒ i64, {min n, max ϵ}, 0
        |  0x05 n:u64 m:u64  ⇒ i64, {min n, max m}, 0
        |  0x06 n:u64        ⇒ i64, {min n, max ϵ}, 1  ;; from threads proposal
        |  0x07 n:u64 m:u64  ⇒ i64, {min n, max m}, 1  ;; from threads proposal
</code></pre></div>
</li>
</ul>
</li>
<li>
<p dir="auto">The <a href="https://webassembly.github.io/spec/core/binary/types.html#memory-types" rel="nofollow">memory type</a> structure is extended to use this limits
encoding</p>
<ul dir="auto">
<li>
<div data-snippet-clipboard-copy-content="memtype ::= (at, lim, _):limits ⇒ at lim"><pre><code>memtype ::= (at, lim, _):limits ⇒ at lim
</code></pre></div>
</li>
</ul>
</li>
<li>
<p dir="auto">The <a href="https://webassembly.github.io/spec/core/binary/instructions.html#binary-memarg" rel="nofollow">memarg</a>&#39;s offset is read as <code>u64</code></p>
<ul dir="auto">
<li><code>memarg ::= a:u32 o:u64</code></li>
</ul>
</li>
</ul>

<ul dir="auto">
<li>
<p dir="auto">There is a new address type:</p>
<ul dir="auto">
<li>
<div data-snippet-clipboard-copy-content="addrtype ::= &#39;i32&#39; ⇒ i32
          |  &#39;i64&#39; ⇒ i64"><pre><code>addrtype ::= &#39;i32&#39; ⇒ i32
          |  &#39;i64&#39; ⇒ i64
</code></pre></div>
</li>
</ul>
</li>
<li>
<p dir="auto">The <a href="https://webassembly.github.io/spec/core/text/types.html#text-memtype" rel="nofollow">memory type</a> definition is extended to allow an optional
address type, which must be either <code>i32</code> or <code>i64</code></p>
<ul dir="auto">
<li>
<div data-snippet-clipboard-copy-content="memtype ::= lim:limits             ⇒ i32 lim
         |  at:addrtype lim:limits  ⇒ at lim"><pre><code>memtype ::= lim:limits             ⇒ i32 lim
         |  at:addrtype lim:limits  ⇒ at lim
</code></pre></div>
</li>
</ul>
</li>
<li>
<p dir="auto">The <a href="https://webassembly.github.io/spec/core/text/modules.html#text-mem-abbrev" rel="nofollow">memory abbreviation</a> definition is extended to allow an
optional address type too, which must be either <code>i32</code> or <code>i64</code></p>
<ul dir="auto">
<li>
<div data-snippet-clipboard-copy-content="&#39;(&#39; &#39;memory&#39; id? address_type? &#39;(&#39; &#39;data&#39; b_n:datastring &#39;)&#39; &#39;)&#39; === ..."><pre><code>&#39;(&#39; &#39;memory&#39; id? address_type? &#39;(&#39; &#39;data&#39; b_n:datastring &#39;)&#39; &#39;)&#39; === ...
</code></pre></div>
</li>
</ul>
</li>
</ul>
</article></div></section></div></div></div></div>
  </body>
</html>
