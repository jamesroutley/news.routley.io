<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://duncanlock.net/blog/2022/04/06/using-windows-after-15-years-on-linux/">Original</a>
    <h1>Using Windows after 15 years on Linux</h1>
    
    <div id="readability-page-1" class="page"><section itemprop="text articleBody">
<p>I’ve been using Linux exclusively for ~15 yrs. I’ve recently started a fantastic new job – the only wrinkle was that it came with a Windows 10 laptop.</p>
<p>This is my first time using Windows after a 15-year break. This is how it’s been going.</p>
<section><h2 id="_first_impressions">First Impressions</h2><p>Windows is <em>such a mess</em>! It’s sort of shocking how much of a mess it is. Desktop Linux is often criticized for this, but Windows is much worse, somehow! It’s <em>really</em> inconsistent. Half of it is “new” <span>UI</span> and half of it is old Win32/<span>GDI</span> type <span>UI</span> - just as bad as <span>KDE</span>/<span>GTK</span> - except <em>worse</em>, because you can’t configure them to use the same theme. Also, when you install a Linux distribution, it’ll start off either all <span>KDE</span> or all <span>GTK</span>, or whatever - but with Windows you’re stuck with a random mix of both <em>right from the start</em>.</p>
<p>Thankfully, there <em>is</em> a dark theme available - but <em>only</em> for “new” <span>UI</span> things, naturally. So as soon as you randomly stumble into some old non-themed <span>UI</span>, suddenly <span>BRIGHT</span> <span>WHITE</span>!</p></section>
<section><h2 id="_you_cant_customize_anything">You can’t customize anything!</h2><p>You’re pretty much stuck with whatever Microsoft decides to give you, compared to Linux - which is <em>completely</em> customizable: you can build your own version of Linux from the ground up, choosing every software building block yourself, if you choose to. Like almost all Linux users, I <em>don’t</em> choose to - I use a Linux distribution (or “distro”), where someone else has made these choices for me. This lets me pick the distro that’s closest to my needs and customize anything I want to change. I’ve been using <a href="https://xubuntu.org/">Xubuntu</a> for years and it suits me - but there are <a href="https://distrowatch.com/">hundreds of Linux Distro’s to choose</a> from.</p></section>
<section><h2 id="_windows_wasnt_made_for_me">Windows Wasn’t Made for Me</h2><p>I am a software <span>&amp;</span> web developer - and Linux is a toolbox, full of highly polished tools, crafted over decades by software developers, for software developers. Windows is…​ not that. It’s a commercial <span>OS</span>, aimed at users of Word, Excel <span>&amp;</span> Outlook, pretty much. You can <em>feel</em> this difference all the time that you’re using it - it pervades everything.</p>
<section><h3 id="_non_composable_software">Non-composable Software</h3><p>The command line tools (echo, cat, grep, sed, awk, find, cut, sort, curl, ssh, etc…​) which make up the standard Linux/Unix toolbox are all composable and general purpose. You can join them together like Lego bricks, in whatever combination you like, to make new tools on the fly. You do this on the command line, by piping streams of text from one tool to another and using them to transform it however you need.</p>
<p>Sadly, nobody has ever <em>really</em> figured out how to make <span>GUI</span> software like this - general purpose <span>&amp;</span> composable. Windows has always focussed heavily on the <span>GUI</span>, to the almost complete exclusion of the command line - which means that it doesn’t have this foundation of composable software tools. Almost everything is a special purpose piece of <span>GUI</span> software. Which you have to go and find. And then download and install.</p>
<section><h4 id="_solution">Solution:</h4><p>You can get Windows versions of most of the <a href="https://en.wikipedia.org/wiki/List_of_GNU_Core_Utilities_commands">standard *nix userland utils</a>, which seem to work <span>OK</span> with PowerShell:</p>
<div><pre><code data-lang="console"><span>$</span><span> </span>scoop <span>install </span>coreutils</code></pre></div>
<p>(See <a href="#_installing_software">installing software for more on package managers <span>&amp;</span> scoop.</a>)</p></section></section>
<section><h3 id="_paths">Paths</h3><p>Stupidly long paths with lots of spaces in don’t matter if you’re only ever clicking on things in the <span>GUI</span> file manager - but if you’re trying to use the command line, then they’re just constant friction.</p>
<div><table><colgroup><col/><col/></colgroup><thead><tr><th>Windows Path</th><th>Linux Path</th></tr></thead><tbody><tr><td>C:\Users\DuncanLock\</td><td>/home/duncan or just ~</td></tr><tr><td>C:\Users\DuncanLock\Documents\PowerShell\Microsoft.PowerShell_profile.ps1</td><td>~/.bashrc</td></tr><tr><td>C:\Users\DuncanLock\AppData\Local</td><td>~/usr/bin or ~/bin</td></tr></tbody></table></div>
<p>…​and on and on. In fairness, they <em>have</em> got rid of a lot of the spaces in the paths since I last used Windows.</p>
<p>Thankfully, PowerShell does have a <code>~</code> alias for your home folder, and <code>cd ~</code> works!</p></section>
<section><h3 id="_environment_variables">Environment Variables</h3><p>Environment Variables look like this: <code>%PROFILE%</code>, instead of this: <code>$HOME</code>; which is fine, just different; although PowerShell seems to accept either form, which is nice.</p>
<p>What <em>isn’t fine</em>, is that they’re stored in the Windows Registry, apparently? If you update these, either using <code>setx %var% value</code>, or the <span>GUI</span>…​ <em>you have to restart your shell</em> - i.e. you type <code>exit</code>, the window/tab goes away, and you open another one. Just let that sink in for a moment.</p>
<section><h4 id="_solution_2">Solution:</h4><p>I haven’t tried this, but I think if you want to add persistent environment variables to your currently running shell, you should put a <code>setx</code> command in your <code>$profile</code> file and then reload it: <code>. $profile</code> - or maybe run <code>myvar=&#34;value&#34; &amp;&amp; setx %myvar% &#34;value&#34;</code>, or something similar.</p></section></section></section>
<section><h2 id="_installing_software">Installing Software</h2><p>Installing things is still, mostly, going to random websites, downloading an <code>.exe</code> (or a <code>.msi</code> if you’re lucky) and running it! Holy shit! You now get some click through warnings when you try to run them, but it’s still the only way to install lots of things! This is slightly terrifying and pretty mind-blowing in 2022!</p>
<p>There <em>is</em> the Microsoft Store now, but it’s just…​ awful? It manages to be both a ghost town and a cesspool of scam/shovelware at the same time, somehow? It’s got less useful stuff in it than most Linux distro “app stores” and is <em>utterly miniscule</em> compared to the Debian repositories, which have ~60,000 packages in, or Arch’s <span>AUR</span>, with 73,000 (these counts include the whole Linux <span>OS</span>, though, with is installed using the same package manager).</p>
<p>Like Netflix, the <span>MS</span> Store deliberately makes it hard to see exactly how much/little stuff they have, but in most useful categories, it’s fairly empty. It <em>usually</em> doesn’t have what I need, so far.</p>

<p><span>MS</span> <em>could</em> have fixed this with their Store, if that have a proper package manager underneath - but they don’t seem to have done this. Some team at <span>MS</span> decided to rip-off AppGet (<a href="https://keivan.io/the-day-appget-died/">killing it</a>) to create WinGet and then <a href="https://niemarwinget.medium.com/winget-is-terrible-i-want-appget-back-41b3ca598596">mostly abandon it</a>. Some other team created <span>MSIX</span>. Some other team created the Store. Etc…​</p>
<figure><img src="https://duncanlock.net/images/posts/using-windows-after-15-years-on-linux/ms_organizational_chart.webp" alt="Diagram of an imagined MS Org Chart. Each team is in a sealed bubble" width="pointing guns at each other" height="only linked to the top of the org"/>
<figcaption>Figure 1. Microsoft Org Chart, from <a href="https://bonkersworld.net/organizational-charts">https://bonkersworld.net/organizational-charts</a>. This explains a lot of things. I’m not sure what the open-source version of this looks like, but somehow they made package managers work at scale.</figcaption></figure>
<p>Some “package managers” have appeared for Windows recently - nuget, choclatey, scoop, winget, etc…​ These are just papering over the cracks. They don’t have their own package repositories, reproducible builds, package signing, etc…​ - because lots of things in Windows aren’t open source, so they mostly can’t. They just automate the process of going to the website, downloading an installer and then running it - which <em>is</em> slightly better than doing it yourself.</p>
<p>This isn’t really proper package management - it’s just automated download <span>&amp;</span> install. Linux package managers do the following things:</p>
<div><ul><li>Have a package repository of some kind, mostly storing package lists <span>&amp;</span> metadata, binary installation packages, but sometimes source code</li><li>Package signing, reproducible builds, secure downloads, etc…​</li><li>Browse <span>&amp;</span> search these packages</li><li>Install a package from the repository locally. This means:<ul><li>If it’s a source package system, compile the source and test it</li><li>Copy the files to the system, put them in the right places, and run optional installation scripts and hooks.</li><li>Record all files that are installed and know which file belongs to which package.</li></ul></li><li>When uninstalling:<ul><li>Remove all the packages files automatically</li><li>Run optional uninstallation scripts and hooks.</li><li>Make sure the software is uninstalled safely and completely.</li></ul></li><li>Be able to update packages. This means:<ul><li>Knowing what packages are installed, and what version</li><li>Having the ability to download <span>&amp;</span> update any outdated packages.</li></ul></li></ul></div>
<p>Importantly, the whole <span>OS</span> - and all applications - are installed through this system. Everything is installed the same way - and updated the same way.</p>

<p>To be fair to <span>MS</span>, the <a href="https://en.wikipedia.org/wiki/Windows_Installer"><span>MSI</span> system</a> <em>does</em> do <em>some</em> of this - but <span>MSI</span> packages have been a pain to create since the start, and apparently still are. So a lot of software <em>still</em> doesn’t use <span>MSI</span> files, 20 years later - they still come with a Nullsoft/ InstallShield/ Inno/ homegrown setup.exe. To be even fairer, there is <a href="https://docs.microsoft.com/en-us/windows/msix/overview">a new <span>MSIX</span> system</a>, which adds containerization/sandboxing of apps (like flatpak/snap) as well as updating - while being simpler to create - but it’s new…​ so almost no-one uses it.</p>
<p>Even taking that into account, there doesn’t seem to be a notion that the system as a whole could provide some kind of cohesive application install <span>&amp;</span> update experience. Windows Update <em>almost</em> provides this for the <span>OS</span>, but applications are all updated separately, even if they’re using the new <span>MSIX</span> installer system, afaik. I think the <span>MS</span> Store <em>is supposed to do this</em>, for the tiny number of apps that you can install from there? Maybe this is just me coming in while this is all party-way through being fixed?</p>
<p>In addition to this, these various “package managers” don’t all have the same packages/apps available, so you will probably end up with several of them installed eventually - and have to remember which thing you installed something with when you want to update it - if that “package manager” even supports updating, because not all of them do!</p>
<p>I fully understand the historical <span>&amp;</span> commercial reasons <em>why</em> it’s like this, but it’s still a pretty poor experience for the end user, compared to Linux.</p>
<section><h3 id="_solution_3">Solution:</h3><p><a href="https://scoop.sh/">Scoop</a> seems to be the best of the bunch, so far?</p>
<div><pre><code data-lang="console"><span>$</span><span> </span>scoop search wget
<span>$</span><span> </span>scoop info postgres
<span>$</span><span> </span>scoop <span>install </span>coreutils wget xh bat ripgrep</code></pre></div></section></section>
<section><h2 id="_a_terminal_that_doesnt_suck">A Terminal That Doesn’t Suck</h2><p>The shells <span>&amp;</span> terminal applications that come installed on Windows are just astonishingly bad. Like 1980s <span>DOS</span> in a window bad - and they haven’t changed <em>at all</em> since I last used them ~15 yrs ago. Just head shakingly awful. There’s a new <em>shell</em> now, called <a href="https://docs.microsoft.com/en-us/powershell/scripting/overview">PowerShell</a>, to run <em>inside</em> your terrible 1980s terminal window, but the terminal it’s running inside, still sucks.</p>
<p>I sometimes wondered why the <span>VS</span> Code team put so much effort into the built-in terminal inside the editor. I tried it once on Linux and never touched it again, because the terminal window I had right next to my editor was just massively better in every way. Having used Windows terminals for a while, I now <em>fully understand why it’s there</em>.</p>
<section><h3 id="_solution_4">Solution:</h3><p>It turns out that answer to this is to install <a href="https://www.microsoft.com/en-US/p/windows-terminal/9n0dx20hk701?activetab=pivot:overviewtab">Windows Terminal</a>. It’s not <a href="https://sw.kovidgoyal.net/kitty/">Kitty</a>, but at least it doesn’t suck.</p>
<p>The shell that’s running <em>inside</em> this Terminal is configurable, but I’m currently using PowerShell. It’s quite powerful, if you’re willing to learn it, I think. It also comes with enough aliases for things like <code>ls → dir</code> that it’s fairly comfortable coming from Bash<a id="_footnoteref_1" href="#_footnote_1" title="View footnote 1" role="doc-noteref">[1]</a>. It’s certainly a massive improvement over cmd.exe + whatever the old shell was called.</p></section></section>
<section><h2 id="_did_it_just_restart_itself_and_lose_all_my_terminals">Did it Just…​ Restart Itself and Lose All My Terminals‽</h2><p>I was surprised by this one morning, when I came back to my Windows machine, it had lost all my open terminals <span>&amp;</span> <span>SSH</span> sessions overnight, as well as all my VSCode windows. My Outlook, Teams and Edge windows were all still there, so <span>WFT</span>‽ I initially thought they’d crashed, but after trawling through Event Viewer, I discovered that Windows Update had decided to restart the machine without asking me!</p>
<p>Screw you software, I’m in charge, not you.</p>
<p>Turns out that some Windows Apps are “Restartable” and some aren’t - which means they get reloaded with all their windows when you restart.</p>
<p>I eventually found that Windows Terminal Preview Edition is now “Restartable” too. Sadly, but unsurprisingly, this just means that your terminal windows <span>&amp;</span> tabs come back, but not their contents, or <span>SSH</span> sessions, etc…​</p>
<p>Update: It did it again! But the Lenovo thing that’s been nagging me to install a <span>BIOS</span> update, which unsurprisingly also requires a restart, is <em>still</em> nagging me. Because there’s no system-wide package manager, so all these little things have their own installers and don’t co-ordinate anything. Ugh.</p>
<p>This is not how we do things in Linux land:</p>
<div><pre><code data-lang="console"><span>$</span><span> </span><span>uptime</span>
<span>09:33:15 up 56 days, 16:33,  1 user,  load average: 1.36, 1.29, 0.91</span></code></pre></div>
<section><h3 id="_solution_5">Solution:</h3><p>You <em>can</em> <a href="https://duckduckgo.com/?q=windows+update+disable+restart">turn this off</a> - unless your <span>IT</span> dept has set this by policy, which is the case for me.</p></section></section>
<section><h2 id="_virtual_desktopsworkspaces">Virtual Desktops/Workspaces</h2><p>Linux has had rock-solid multiple virtual desktop/workspaces support forever (30 yrs?) - Windows <em>just</em> got this in Windows 10. It was <em>possible</em> before via hacky 3rd party software, but it was <em>very</em> hacky and didn’t work very well, in my experience.</p>
<p>Using multiple workspaces/virtual desktops is a core part of my workflow on Linux - I currently have 20 of them, so this is fairly important to me.</p>
<p>The one in Windows 10 seems to work <em>better</em> than the previous hacky 3rd party ones, although I have some issues with it:</p>
<div><ul><li>There’s no way to see which desktop you’re on, except by going to the switcher.</li><li>The win+tab desktop switcher screen does a lot of things - including the only way to move windows between desktops, afaik. It can be a bit slow/janky.</li><li>When apps get restarted, <a href="https://answers.microsoft.com/en-us/windows/forum/all/restart-apps-to-the-right-desktop/7d534448-fd8e-4a62-ada8-50799e837826">they all end up on the first desktop</a>, because, clearly, people at <span>MS</span> don’t use multiple desktops.</li></ul></div>
<section><h3 id="_solutions">Solutions:</h3><div><ul><li>Install <a href="https://github.com/zgdump/windows-virtualdesktopindicator">Virtual Desktop Indicator</a> to get a desktop number indicator in your taskbar, popup desktop name on switch and mouse wheel switching.</li><li>Install <a href="https://github.com/kangyu-california/PersistentWindows">PersistentWindows</a> - which keeps track of window positions in real time, and automatically restores window layout to last matching monitor setup.</li></ul></div></section></section>
<section><h2 id="_windows_all_moved_to_main_monitor_after_sleepoff">Windows all Moved to Main Monitor After Sleep/Off</h2><p>It seems that when Windows sends DisplayPort monitors to sleep, it immediately forgets that it did this, and acts like you disconnected them - and moves all your Windows that used to be on these monitors onto the primary monitor. Every. Single. Time.
So, when you wake it up, you have to put all your windows back where they were. Every. Single. Time.</p>
<p>This seems to have been happening since Windows 7, with hundreds of people complaining, to no avail:</p>

<section><h3 id="_solutions_2">Solutions:</h3><div><ul><li>Set screen sleep timeouts really long, or off when plugged in</li><li>Install <a href="https://github.com/kangyu-california/PersistentWindows">PersistentWindows</a> - which keeps track of window positions in real time, and automatically restores window layout to last matching monitor setup.</li></ul></div></section></section>
<section><h2 id="_no_middle_click_paste">No Middle-Click Paste</h2><p>Linux (well, really the window managers, so X11 and then, i3, Wayland, etc…​) have multiple clipboards. The default ones are the Primary selection one, and the Secondary one. The names are historical accidents, but the “primary” one always has a copy of the last text you selected from anywhere, which can be pasted anywhere by clicking the middle mouse button. You just select some text and that’s it - you don’t have to do anything else and you can then middle-click paste this anywhere. The “secondary” clipboard is the “normal” Cut, Copy, Paste, Ctrl+c, Ctrl+v one.</p>
<p>The primary selection clipboard is <em>incredibly</em> useful and Windows just doesn’t have anything equivalent at all.</p>
<p>Windows Terminal <em>will</em> paste the contents of the clipboard on a right click, <em>and</em> does copy the last selection to the clipboard - which is <em>close</em> - but this doesn’t work anywhere else, sadly, only in Windows Terminal; I want this everywhere. Also, because there’s only <em>one</em> clipboard, every time you select anything in Windows Terminal, it overwrites the clipboard - which is why Linux has another clipboard, just for this.</p>
<section><h3 id="_solution_6">Solution:</h3></section></section>
<section><h2 id="_ssh"><span>SSH</span></h2><p>I tried PuTTY, which I’d heard was <em>the</em> good <span>SSH</span> thing on Windows, but it’s…​ not good, at all.
<a href="https://docs.microsoft.com/en-us/windows-server/administration/openssh/openssh_install_firstuse">PowerShell does come with an <span>SSH</span> client</a>, so once you have this working with a reasonable terminal, you can use <span>SSH</span> as normal.</p>
<section><h3 id="_solution_7">Solution:</h3></section></section>
<section><h2 id="_keyboard_shortcuts">Keyboard Shortcuts</h2><p>A few useful keyboard shortcuts I’ve started using:</p>
<div><table><colgroup><col/><col/></colgroup><thead><tr><th>Key Combo</th><th>Function</th></tr></thead><tbody><tr><td>Win+Ctrl+left/right arrow</td><td>Switch virtual desktop left/right</td></tr><tr><td>Win+Tab</td><td>Open the desktop switcher screen.</td></tr><tr><td>Win+e</td><td>Open the file manager</td></tr><tr><td>Win+x</td><td>Power users menu</td></tr></tbody></table></div>
<p>Again, these aren’t very customizable - you can get <em>some</em> more customization of global hotkeys by using the <a href="https://github.com/microsoft/PowerToys">PowerToys</a> <a href="https://docs.microsoft.com/en-gb/windows/powertoys/keyboard-manager">Keyboard Manager</a> thing, but there are lots of combination that are seemingly just not possible, for some reason; I’d like to use <code>Win+Enter</code> to launch a new terminal window, to match my Linux workflow, but that combination isn’t allowed.</p></section>
<section><h2 id="_things_that_are_better_on_windows">Things That are Better on Windows</h2><div><ul><li>Firmware installation as part of Windows Update seems to just work, so far.</li><li>…​ that’s it?</li></ul></div>
<hr/></section>
<section></section>
<hr/>

<hr/>

</section></div>
  </body>
</html>
