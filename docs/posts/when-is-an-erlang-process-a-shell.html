<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://erikarow.land/notes/erlang-process-shell">Original</a>
    <h1>When is an Erlang process a shell?</h1>
    
    <div id="readability-page-1" class="page"><section id="When-is-an-Erlang-process-a-shell">

<p>Recently, I was trying to port an Erlang function to Elixir,
with the goal of answering one question: “When is an Erlang process a shell?”</p>
<p>Answering that question involved source diving Erlang, learning new <a href="https://erikarow.land/notes/git-checkout-tag">things about git</a>, and reading mailing lists.</p>
<section id="The-Original-Code">
<h2>The Original Code</h2>
<p>The code I wanted to port was this function<label for="fn1"></label><span><span>Erlang’s syntax might seem a bit weird if you haven’t been exposed to it before. Erlang was originally <a href="https://en.wikipedia.org/wiki/Erlang_%28programming_language%29%23History">implemented in prolog</a>, which inspired much of the syntax.</span><span>Variables in Erlang are <code>UpperCase</code>, which makes them easy to pick out of code once you’re used to it, but opposite of the norm in Algol inspired languages.</span><span>The Prolog inspiration also led to a “sentence-like” structure, with commas, semicolons, and periods. Note that this function end with a <code>.</code> character.</span></span>:</p>
<pre><code>is_shell(ProcessId) -&gt;
  case erlang:process_info(ProcessId, group_leader) of
    undefined -&gt; false; %% process is dead
    {group_leader, Leader} -&gt;
      case lists:keyfind(shell, 1, group:interfaces(Leader)) of
        {shell, ProcessId} -&gt; true;
        {shell, Shell} -&gt;
          case erlang:process_info(Shell, dictionary) of
            {dictionary, Dict} -&gt;
              proplists:get_value(evaluator, Dict) =:= ProcessId;
            undefined -&gt; false %% process is dead
          end;
        false -&gt; false
      end
  end.
</code></pre>
<p>I can follow along here, we’re retrieving something called <code>group_leader</code><label for="fn2"></label><span><span>Erlang and Elixir have the concept of atoms. Atoms are equal to only themselves, and their value is exactly their name. This seems pretty useless until you consider pattern matching.</span><span>I can use a pattern like <code>{:my_atom, value}</code> to match on the <code>:my_atom</code> as a key and assign the second tuple item to the variable <code>value</code>.</span><span>Note that in Elixir atoms are typically denoted with a prefixed colon, like <code>:this</code>. In Erlang, atoms are lower case with no other markings, like <code>this</code>, which works because variables are upper case in Erlang.</span></span> from the process’s metadata. The equivalent function call in Elixir would be <code>Process.info(pid, :group_leader)</code>.</p>
<p>What is a group_leader? There was sparse information about group leaders in the Erlang documentation, but I found a mailing thread response that said this:<label for="fn3"></label><span><span>Note, the original source uses outdated terminology for <code>origin</code> and <code>peer</code>, the <code>peer</code> module superseded the previous module in <a href="https://www.erlang.org/news/157#erts-stdlib-kernel">OTP 25.0</a>. Original source <a href="https://erlang.org/pipermail/erlang-questions/2018-April/095179.html">here</a>.</span></span></p>
<blockquote>
<p>Group leaders let you redirect I/O to the right endpoint. It is one of 
the few properties that is inherited by one process to the other, 
creating a chain.</p>
<p>By default, an Erlang node has one group leader called ‘user’. This 
process owns communication with the stdio channels, and all input 
requests and output messages transit through that one.</p>
<p>Then, each shell you start becomes its own group leader. This means that 
any function you run from the shell will send all its IO data to that 
shell process.</p>
</blockquote>
<p>A group leader gives us a sense of where each process belongs to, and since each shell has its own group leader <code>is_shell/1</code> needs to unpack this information to find whether it’s a shell.</p>
<p>This answers the question about group leaders, the next curiosity in the function is <code>group:interfaces</code> which is called on the group leader process id.</p>
</section>
<section id="groupinterfaces">
<h2><code>group:interfaces</code>!?</h2>
<p>So the first thing I did was to extract the group leader of my Elixir IEx shell, and try to call <code>:group.interfaces</code><label for="fn4"></label><span><span>In this story I’m switching back and forth between Erlang and Elixir syntax. Know that <code>module:function/arity</code> in Erlang is equivalent to <code>:module.function/arity</code> in Elixir.</span><span>Elixir has first class support for calling Erlang functions, and this manifests as similar but subtly different syntax.</span></span> on that process id.</p>
<p>Just one problem, IEx raises an <code>UndefinedFunctionError</code>, telling me that it doesn’t exist. That’s okay, it’s been 11 years since the Erlang code was written, perhaps that function was taken out.</p>
<p>So the next thing I try is to repeat the same experiment directly in the Erlang shell <code>erl</code>. I open a new terminal, invoke <code>erl</code>, get the <code>erlang:process_info(self(), group_leader).</code> I pass this process id to <code>group:interfaces(GroupLeaderPid).</code>, and I get a valid list of interfaces!?</p>
<p>I’m confused for a short while, before remembering that I use <code>nix-shell</code> to manage my Elixir version. So when I ran the <code>:group.interfaces</code> invocation in IEx, it was in OTP 26, <code>erts-14.1</code>. However, when I ran <code>group:interfaces</code> in <code>erl</code>, it was in OTP 25, <code>erts-13.2.2</code>. Something must have changed in the <code>group</code> module between OTP 25 and OTP 26.<label for="fn5"></label><span><span><code>erts</code> stands for the Erlang Run-Time System Application. Erlang versions its applications separately from the OTP as a whole, leading to the two version numbers I shared.</span></span></p>
</section>
<section id="Git-Spelunking">
<h2>Git Spelunking</h2>
<p>In order to figure out what what was going with <code>group</code> I needed to turn back time.<label for="fn6"></label><span><span>Thanks to Jeff for the turn of phrase.</span></span> <code>group</code> is an internal module in Erlang, and lacks external documentation. So I needed to explore the source code directly.</p>
<p>Thankfully, <code>git</code> gives us an easy way to <a href="https://erikarow.land/notes/git-checkout-tag">checkout old code</a>. Running <code>git checkout OTP-25.0</code> on the <a href="https://github.com/erlang/otp/"><code>otp</code> repository</a> drops me into the OTP code as it was at that release.</p>
<p>A quick ripgrep for <code>interfaces/1</code> leads me to <code>lib/kernel/src/group.erl</code> and <code>interfaces/1</code>:<label for="fn7"></label><span><span>In the middle of this process, I confused <code>user_drv:interfaces</code> with <code>group:interfaces</code> and convinced myself that it had mysteriously changed from a function that didn’t do what I needed to a function that worked between OTP 25.0 and OTP 25.3. I had no basis for why this change might have happened or why it happened so late after the function was created, when it’s clear that 11 years ago in the function that starts this article, it was used in the same way as OTP 25.3.</span><span>Specifically, I think I got lost because I had backgrounded my text editor in <code>user_drv.erl</code>, and when I checked out <code>OTP 25.0</code> the <code>interfaces</code> function appeared.</span></span></p>
<pre><code>interfaces(Group) -&gt;
    case process_info(Group, dictionary) of
	{dictionary,Dict} -&gt;
	    get_pids(Dict, [], false);
	_ -&gt;
	    []
    end.

get_pids([Drv = {user_drv,_} | Rest], Found, _) -&gt;
    get_pids(Rest, [Drv | Found], true);
get_pids([Sh = {shell,_} | Rest], Found, Active) -&gt;
    get_pids(Rest, [Sh | Found], Active);
get_pids([_ | Rest], Found, Active) -&gt;
    get_pids(Rest, Found, Active);
get_pids([], Found, true) -&gt;
    Found;
get_pids([], _Found, false) -&gt;
    [].
</code></pre>
<p>In <code>interfaces</code> it first extracts the process dictionary<label for="fn8"></label><span><span>Joe Armstrong in his book, “Programming Erlang, 2nd Edition” says this: “Each process in Erlang has its own private data store called the process dictionary. The process dictionary is an associative array (in other languages this might be called a map, hashmap, or hash table) composed of a collection of keys and values. Each key has only one value.”</span><span>He continues: “Note: I rarely use the process dictionary. Using the process dictionary can introduce subtle bugs into your program and make it difficult to debug.”</span></span> then it tail recursively extract tuples that contain <code>user_drv</code> or <code>shell</code> as their first element.<label for="fn9"></label><span><span>Erlang has ad-hoc polymorphism, which it uses here in <code>get_pids</code> to succinctly pattern match on the shape of the arguments passed in.</span></span></p>
<p>In our original function, we only care about the <code>shell</code>, but otherwise I now knew enough to port <code>is_shell/1</code> into Elixir:</p>
</section>
<section id="Port-of-function-into-Elixir">
<h2>Port of function into Elixir</h2>
<p>In this version, I skipped past implementing <code>interfaces</code> and simply pulled the <code>:shell</code> key out of the process dictionary of the group leader:<label for="fn10"></label><span><span>In Elixir it’s convention to add a <code>?</code> to the name of a function that returns a boolean.</span></span><label for="fn11"></label><span><span>Joe Armstrong’s comment about the process dictionary implies that it is a keyword list, but most of the Erlang functions I see interacting with it treat it as a <code>proplist</code>. These two data structures are similar, both are built on top of the Erlang list.</span><span>A keyword list, is a list of 2-tuples, with the first element being an atom key, and the second being a value for the key. A keyword list is a valid proplist, but a proplist has a shortcut where an atom key by itself stands in for <code>{atom, true}</code>, this breaks all of Elixir’s Keyword functions, that presume a well-formed keyword list.</span><span>Keyword List Example: <code>[{:key1, &#34;value&#34;}, {:key2, 5}, {:key3, true}]</code></span><span>Proplist Example: <code>[{:key1, &#34;value&#34;}, {:key2, 5}, :key3]</code></span></span><label for="fn12"></label><span><span>In this code snippet, I use the pin operator <code>^</code>. In Erlang, variables can only be assigned once, so after their first assignment, you can use them to pattern match.</span><span>Elixir allows variable shadowing, meaning that you can reuse a variable name. In order to do pattern matching on a variable’s contents, instead of reassigning it, Elixir added the pin operator <code>^</code> to “pin” the value of the variable for the pattern match. Learn more <a href="https://hexdocs.pm/elixir/1.12/Kernel.SpecialForms.html#%5E/1">here</a>.</span></span></p>
<pre><code>def is_shell?(pid) do
  case Process.info(pid, :group_leader) do
    :undefined -&gt;
      false

    {:group_leader, leader} -&gt;
      {:dictionary, leader_dict} = Process.info(leader, :dictionary)

      case :proplists.get_value(:shell, leader_dict) do
        ^pid -&gt;
          true

        shell when is_pid(shell) -&gt;
          case Process.info(shell, :dictionary) do
            {:dictionary, dict} -&gt;
              :proplists.get_value(:evaluator, dict) === pid

            :undefined -&gt;
              false
          end

        :undefined -&gt;
          false
      end
  end
end
</code></pre>
</section>
<section id="Refactor-to-use-with">
<h2>Refactor to use <code>with</code></h2>
<p>The nested <code>case</code> statements in the previous function can be refactored using Elixir’s <code>with</code> statement for a cleaner function:</p>
<pre><code>def is_shell?(pid) do
  with {:group_leader, leader} &lt;- Process.info(pid, :group_leader),
       {:dictionary, leader_dict} &lt;- Process.info(leader, :dictionary),
       {:shell, ^pid} &lt;- :lists.keyfind(:shell, 1, leader_dict) do
    true
  else
    {:shell, shell} -&gt;
      with {:dictionary, dict} &lt;- Process.info(shell, :dictionary) do
        :proplists.get_value(:evaluator, dict) === pid
      else
        _ -&gt; false
      end

    _ -&gt;
      false
  end
end
</code></pre>
</section>
<section id="Shell-improvements-OTP-26">
<h2>Shell improvements OTP 26</h2>
<p>Earlier, I found that <code>group:interfaces/1</code> was missing from OTP 26. This seems to be connected to the <a href="https://www.erlang.org/blog/otp-26-highlights/#the-shell">OTP 26 shell improvements</a>.</p>
<p>It’s worth looking at <code>group:whereis_shell/0</code> as a comparison with my <code>is_shell?/1</code> function:</p>
<section id="groupwhereis_shell">
<h3><code>group:whereis_shell</code></h3>
<p>The OTP 26 implementation of <code>group:whereis_shell</code> contains this snippet:</p>
<pre><code>GroupPid -&gt;
  {dictionary, Dict} = 
    erlang:process_info(GroupPid, dictionary),
  proplists:get_value(shell, Dict)
</code></pre>
<p>Which is nearly identical to my pre-<code>with</code> refactor implementation in Elixir. Which means I’m probably on the right track.</p>
</section>
<section id="groupstart_shell1">
<h3><code>group:start_shell/1</code></h3>
<p>I also wanted to call attention to this comment above <code>group:start_shell/1</code>:</p>
<pre><code>%% start_shell(Shell)
%%  Spawn a shell with its group_leader from the beginning set to ourselves.
%%  If Shell [is] a pid the[n] set its group_leader.
</code></pre>
<p>Which confirms what we learned earlier about group leaders and how they relate to shells.</p>
<p>That would have been the end of the story, until I read the comment above the <code>is_shell/1</code> function in the original codebase:</p>
<pre><code>%% Theoretically pman_process:is_system_process/1 should say true for
%% the shell.  Well, it doesn&#39;t, so this is a workaround until it
%% does.
</code></pre>
<p>What is <code>pman_process</code>? Unlike <code>:group.interfaces/1</code>, the function isn’t missing, the module is gone. This led me down a rabbit hole that required learning <a href="https://erikarow.land/notes/git-spelunking-bisect">how to bisect a git repo</a>:</p>
</section>
</section>
<section id="What-is-pman_process">
<h2>What is <code>:pman_process</code>?</h2>
<p>A search for “Erlang pman” turns up a <a href="https://erlang.org/documentation/doc-5.9/lib/pman-2.7.1.1/doc/html/pman_chapter.html">process viewing tool</a> from an ancient version of Erlang. The screenshots of the interface look like they’re right out of <a href="https://en.wikipedia.org/wiki/Twm">Tab Window Manager</a>.<label for="fn13"></label><span><span>I briefly used <code>twm</code> when I used OpenBSD on the desktop, but I preferred <a href="https://en.wikipedia.org/wiki/Cwm_%28window_manager%29"><code>cwm</code></a>.</span></span></p>
<p>After a lot of digging, I found that PMan was a process viewing application built into Erlang, whose behavior was absorbed by Observer. PMan was written on the <a href="https://www.erlang.org/docs/18/apps/gs/gs.pdf">Graphics System</a> (GS) application. GS was superseded by <a href="https://www.erlang.org/doc/man/wx.html"><code>wx</code></a><label for="fn14"></label><span><span><code>wx</code> is an Erlang port of <a href="https://www.wxwidgets.org/">wxWidgets</a> a cross-platform GUI library.</span></span> for graphical applications for Erlang.</p>
<p>PMan and the GS related backends were removed in <a href="https://www.erlang.org/patches/otp-17.0">OTP 17.0</a>. If I checkout a version of OTP prior to OTP 17, I can finally find what <code>pman_process</code> is doing. Prior to its removal, it was located in <code>lib/pman/src/pman_process.erl</code>.</p>
<p>The module includes a purpose comment:</p>
<blockquote>
<p>A front-end to the <code>erlang:process_info()</code> functions, that
can handle processes on different nodes in a transparent
way.</p>
<p>Also some convenience functions for process info, as well
as some application specific functions for process 
classification.</p>
</blockquote>
<p>This purpose explains why it might contain an <code>is_system_process/1</code> function.</p>
<section id="One-Last-Mystery">
<h3>One Last Mystery</h3>
<p><code>pman_process</code> contains a few <code>-define</code> calls that declare module constants that are lists of process names and function signatures that mark something as a “system” process.</p>
<p>Where does this list come from? Why is hard coded? How do you determine what needs to be on these lists?</p>
<p><code>git blame</code> gives me no answers, the code for <code>pman_process</code> was added to the OTP git repo in its initial commit in 2009. And it remained untouched until it was removed prior to OTP 17.0.</p>
</section>
</section>
</section></div>
  </body>
</html>
