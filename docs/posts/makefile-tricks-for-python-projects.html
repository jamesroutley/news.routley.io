<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ricardoanderegg.com/posts/makefile-python-project-tricks/">Original</a>
    <h1>Makefile Tricks for Python Projects</h1>
    
    <div id="readability-page-1" class="page"><div><p>I like using Makefiles. They work great both as simple task runners as well as build systems for medium-size projects. This is my starter template for Python projects.</p><p>Note: This blog post assumes some basic knowledge of how <code>make</code> and Makefiles work.</p><h2 id="basic-configuration">Basic configuration</h2><p>I like using bash as the default shell. Then set some flags to exit on error (<code>-eu -o pipefail</code>), warn about undefined variables and disable built-in rules.</p><div><pre tabindex="0"><code data-lang="makefile"><span><span><span>SHELL</span> <span>:=</span> bash
</span></span><span><span><span>.SHELLFLAGS</span> <span>:=</span> -eu -o pipefail -c
</span></span><span><span><span>MAKEFLAGS</span> <span>+=</span> --warn-undefined-variables
</span></span><span><span><span>MAKEFLAGS</span> <span>+=</span> --no-builtin-rules
</span></span></code></pre></div><h2 id="using-the-virtual-environment">Using the virtual environment</h2><p>The next lines will create two aliases to run Python from an existing virtual environment if it exists</p><div><pre tabindex="0"><code data-lang="makefile"><span><span><span>py</span> <span>=</span> <span>$$</span><span>(</span><span>if</span> <span>[</span> -d <span>$(</span>PWD<span>)</span>/<span>&#39;.venv&#39;</span> <span>]</span><span>;</span> <span>then</span> <span>echo</span> <span>$(</span>PWD<span>)</span>/<span>&#34;.venv/bin/python3&#34;</span><span>;</span> <span>else</span> <span>echo</span> <span>&#34;python3&#34;</span><span>;</span> <span>fi</span><span>)</span>
</span></span><span><span><span>pip</span> <span>=</span> <span>$(</span>py<span>)</span> -m pip
</span></span></code></pre></div><p>Now, inside any recipe, you can use <code>$(py)</code> to call Python. The call will be converted to <code>.venv/bin/python3</code> if there’s a virtual environment. You may need to change <code>$(PWD)</code> and/or <code>.venv</code> depending on how you set up your virtual environments.</p><p><code>$(pip)</code> will also translate to <code>.venv/bin/python3 -m pip</code> if there’s a virtual environment. Otherwise, it will translate to <code>python3 -m pip</code>.</p><p>The reason to use <code>$$(some-command)</code> instead of the built-in function <code>$(shell some-command)</code> is that the expression will be evaluated every time it is called. So, every time a recipe contains <code>$(py)</code>, the call will be translated to <code>python3</code> or <code>.venv/bin/python3</code> depending on the current context. When using <code>$(shell ...)</code> the expression gets evaluated only once and reused across all the recipes.</p><h2 id="pwd-and-the-repo-root">PWD and the repo root</h2><p>I normally prefer overriding <code>PWD</code>. You can call makefiles from a different directory, which will change <code>PWD</code>. These two lines will set:</p><ul><li><code>PWD</code>: Location of the Makefile</li><li><code>WORKTREE_ROOT</code>: The root of the git repo. If this Makefile is used <strong>outside</strong> of a worktree, the variable will be an empty string.</li></ul><div><pre tabindex="0"><code data-lang="makefile"><span><span><span># Override PWD so that it&#39;s always based on the location of the file and **NOT**
</span></span></span><span><span><span># based on where the shell is when calling `make`. This is useful if `make`
</span></span></span><span><span><span># is called like `make -C &lt;some path&gt;`
</span></span></span><span><span><span></span><span>PWD</span> <span>:=</span> <span>$(</span>realpath <span>$(</span>dir <span>$(</span>abspath <span>$(</span>firstword <span>$(</span>MAKEFILE_LIST<span>)))))</span>
</span></span><span><span>
</span></span><span><span><span>WORKTREE_ROOT</span> <span>:=</span> <span>$(</span>shell git rev-parse --show-toplevel 2&gt; /dev/null<span>)</span>
</span></span></code></pre></div><h2 id="default-goal-and-help-message">Default goal and help message</h2><p>Just a recipe to run some regex over the makefile and print a help message</p><div><pre tabindex="0"><code data-lang="makefile"><span><span><span>.DEFAULT_GOAL</span> <span>:=</span> <span>help</span>
</span></span><span><span><span>.PHONY</span><span>:</span> <span>help</span>
</span></span><span><span><span>help</span><span>:</span> <span>## Display this help section
</span></span></span><span><span><span></span>	@awk <span>&#39;BEGIN {FS = &#34;:.*?## &#34;} /^[a-zA-Z\$$/]+.*:.*?##\s/ {printf &#34;\033[36m%-38s\033[0m %s\n&#34;, $$1, $$2}&#39;</span> <span>$(</span>MAKEFILE_LIST<span>)</span>
</span></span></code></pre></div><p>By setting <code>.DEFAULT_GOAL := help</code>, the <code>help</code> recipe will run when calling <code>make</code> without a target.</p><p>Now you can add a string to the recipes like this:</p><div><pre tabindex="0"><code data-lang="fallback"><span><span>some_target:  ## This help message will get printed
</span></span><span><span>	@echo hello
</span></span><span><span>	@touch some_target
</span></span></code></pre></div><h2 id="injecting-paths-into-pythonpath">Injecting paths into <code>PYTHONPATH</code></h2><p>This is probably my favourite trick. Once you have all your third-party dependencies installed, instead of installing all your packages, you can append some file system paths to the <code>PYTHONPATH</code> environment variable. This will let Python search for packages in those paths without installing the packages.</p><div><pre tabindex="0"><code data-lang="makefile"><span><span><span># PY_PATHS := list with paths to packages
</span></span></span><span><span><span></span>
</span></span><span><span><span>pypath</span> <span>:=</span> python3 -c <span>&#39;import sys, pathlib as p; print(&#34;:&#34;.join([str(p.Path(x).resolve()) for x in sys.argv[1:]]))&#39;</span>
</span></span></code></pre></div><h3 id="how-does-it-work">How does it work?</h3><p>First, you need a list of paths to python packages. For example:</p><div><pre tabindex="0"><code data-lang="makefile"><span><span><span>PY_PATHS</span> <span>:=</span> <span>$(</span>PWD<span>)</span>/pkgs/package1 <span>$(</span>PWD<span>)</span>/pkgs/package2
</span></span></code></pre></div><p>The <code>pypath</code> variable is a compressed version of this Python script:</p><div><pre tabindex="0"><code data-lang="python"><span><span><span>import</span> <span>sys</span>
</span></span><span><span><span>from</span> <span>pathlib</span> <span>import</span> <span>Path</span>
</span></span><span><span>
</span></span><span><span><span>paths</span> <span>=</span> <span>[</span><span>Path</span><span>(</span><span>x</span><span>)</span><span>.</span><span>resolve</span><span>()</span> <span>for</span> <span>x</span> <span>in</span> <span>sys</span><span>.</span><span>argv</span><span>[</span><span>1</span><span>:]]</span>
</span></span><span><span><span>paths</span> <span>=</span> <span>[</span><span>str</span><span>(</span><span>x</span><span>)</span> <span>for</span> <span>x</span> <span>in</span> <span>paths</span><span>]</span>
</span></span><span><span>
</span></span><span><span><span>joined</span> <span>=</span> <span>&#34;:&#34;</span><span>.</span><span>join</span><span>(</span><span>paths</span><span>)</span>
</span></span><span><span>
</span></span><span><span><span>print</span><span>(</span><span>joined</span><span>)</span>
</span></span></code></pre></div><h3 id="using-it">Using it</h3><div><pre tabindex="0"><code data-lang="makefile"><span><span><span>PY_PATHS</span> <span>:=</span> <span>$(</span>PWD<span>)</span>/pkgs/package1 <span>$(</span>PWD<span>)</span>/pkgs/package2
</span></span><span><span><span>pypath</span> <span>:=</span> python3 -c <span>&#39;import sys, pathlib as p; print(&#34;:&#34;.join([str(p.Path(x).resolve()) for x in sys.argv[1:]]))&#39;</span>
</span></span><span><span>
</span></span><span><span><span>.PHONY</span><span>:</span> <span>test</span>-<span>pypath</span>
</span></span><span><span><span>test-pypath</span><span>:</span> <span>export</span> <span>PYTHONPATH</span> = <span>$(</span><span>shell</span> <span>$(</span><span>pypath</span><span>)</span> <span>$(</span><span>PY_PATHS</span><span>))</span>
</span></span><span><span><span>test-pypath</span><span>:</span>
</span></span><span><span>	@python3 -c <span>&#39;import sys; print(sys.path)&#39;</span>
</span></span></code></pre></div><p>When you run this makefile, you’ll get an output like this:</p><div><pre tabindex="0"><code data-lang="python"><span><span><span>[</span><span>&#39;&#39;</span><span>,</span>
</span></span><span><span> <span>&#39;&lt;YOUR PWD&gt;/pkgs/package1&#39;</span><span>,</span>
</span></span><span><span> <span>&#39;&lt;YOUR PWD&gt;/pkgs/package2&#39;</span><span>,</span>
</span></span><span><span> <span>&#39;/opt/homebrew/Cellar/<a href="https://ricardoanderegg.com/cdn-cgi/l/email-protection" data-cfemail="3848414c505756780b160909">[email protected]</a>/3.11.3/Frameworks/Python.framework/Versions/3.11/lib/python311.zip&#39;</span><span>,</span>
</span></span><span><span> <span>&#39;/opt/homebrew/Cellar/<a href="https://ricardoanderegg.com/cdn-cgi/l/email-protection" data-cfemail="8dfdf4f9e5e2e3cdbea3bcbc">[email protected]</a>/3.11.3/Frameworks/Python.framework/Versions/3.11/lib/python3.11&#39;</span><span>,</span>
</span></span><span><span>  <span>&#39;/opt/homebrew/Cellar/<a href="https://ricardoanderegg.com/cdn-cgi/l/email-protection" data-cfemail="7c0c05081413123c4f524d4d">[email protected]</a>/3.11.3/Frameworks/Python.framework/Versions/3.11/lib/python3.11/lib-dynload&#39;</span><span>,</span>
</span></span><span><span> <span>&#39;/opt/homebrew/lib/python3.11/site-packages&#39;</span><span>]</span>
</span></span></code></pre></div><p>Now, if the paths <code>&#39;&lt;YOUR PWD&gt;/pkgs/package1&#39;</code> and <code>&#39;&lt;YOUR PWD&gt;/pkgs/package2&#39;</code> contain a Python package, the interpreter will be able to import them without having to install them first. Just make sure all their dependencies are installed.</p><h3 id="why-this-is-useful">Why this is useful</h3><p>This may be a bit unrelated to this blog post. I work using git worktrees to have multiple branches checked out at the same time. By using this trick, I can run different commands and make sure the imported package is from that branch, instead of having to <code>python3 -m pip install -e .</code> around all the packages.</p><p>I also use this to run scripts which use packages that have heavy dependencies. I can still the third-party dependencies only once and then point to different paths (branches) to run the same command. Each run will use the code from that branch, without needing to reinstall the different versions of the package in different virtual environments.</p><h3 id="adding-more-paths-when-calling-make">Adding more paths when calling <code>make</code></h3><p>If you want to allow passing extra paths when calling <code>make</code>, you can store the initial value in a variable and append it to the exported value.</p><div><pre tabindex="0"><code data-lang="makefile"><span><span><span>PY_PATHS</span> <span>:=</span> <span>$(</span>PWD<span>)</span>/pkgs/package1 <span>$(</span>PWD<span>)</span>/pkgs/package2
</span></span><span><span><span>pypath</span> <span>:=</span> python3 -c <span>&#39;import sys, pathlib as p; print(&#34;:&#34;.join([str(p.Path(x).resolve()) for x in sys.argv[1:]]))&#39;</span>
</span></span><span><span>
</span></span><span><span><span># Store the current value
</span></span></span><span><span><span></span><span>DEFAULT_PYPATH</span> <span>:=</span> <span>$(</span>shell <span>echo</span> <span>$$</span>PYTHONPATH<span>)</span>
</span></span><span><span>
</span></span><span><span>
</span></span><span><span><span>.PHONY</span><span>:</span> <span>test</span>-<span>pypath</span>
</span></span><span><span><span>test-pypath</span><span>:</span> <span>export</span> <span>PYTHONPATH</span> = <span>$(</span><span>shell</span> <span>$(</span><span>pypath</span><span>)</span> <span>$(</span><span>PY_PATHS</span><span>))</span>:<span>$(</span><span>DEFAULT_PYPATH</span><span>)</span>
</span></span><span><span><span>test-pypath</span><span>:</span>
</span></span><span><span>	@python3 -c <span>&#39;import sys, pprint; pprint.pprint(sys.path)&#39;</span>
</span></span></code></pre></div><p>Now you can do this:</p><div><pre tabindex="0"><code data-lang="sh"><span><span><span>PYTHONPATH</span><span>=</span>./some/extra/path make test-pypath
</span></span></code></pre></div><p>And <code>PYTHONPATH</code> will contain <code>./some/extra/path</code>, <code>$(PWD)/pkgs/package1</code> and <code>$(PWD)/pkgs/package2</code>.</p><h2 id="creating-a-virtual-environment">Creating a virtual environment</h2><p>This rule can change depending on what tools you use to manage your virtual environments. But I use something like:</p><div><pre tabindex="0"><code data-lang="makefile"><span><span><span>.venv</span><span>:</span> <span>requirements</span>.<span>txt</span>
</span></span><span><span>	<span>$(</span>py<span>)</span> -m venv .venv
</span></span><span><span>	<span>$(</span>pip<span>)</span> install -U pip setuptools wheel build
</span></span><span><span>	<span>$(</span>pip<span>)</span> install -U -r requirements.txt
</span></span><span><span>	touch .venv
</span></span></code></pre></div><p>This recipe will create a new environment in a <code>.venv</code> folder. It will then update and/or install <code>pip</code>, <code>setuptools</code>, <code>wheel</code> and <code>build</code>. It will install the requirements in <code>requirements.txt</code>. The last command <code>touch .venv</code> ensures that the modified date of the <code>.venv</code> folder is more recent than <code>requirements.txt</code>, which will avoid accidental rebuilds.</p><h2 id="the-template">The template</h2><div><pre tabindex="0"><code data-lang="makefile"><span><span><span>SHELL</span> <span>:=</span> bash
</span></span><span><span><span>.SHELLFLAGS</span> <span>:=</span> -eu -o pipefail -c
</span></span><span><span><span># .DELETE_ON_ERROR:
</span></span></span><span><span><span></span><span>MAKEFLAGS</span> <span>=</span> --warn-undefined-variables
</span></span><span><span><span>MAKEFLAGS</span> <span>+=</span> --no-builtin-rules
</span></span><span><span>
</span></span><span><span>
</span></span><span><span><span># Override PWD so that it&#39;s always based on the location of the file and **NOT**
</span></span></span><span><span><span># based on where the shell is when calling `make`. This is useful if `make`
</span></span></span><span><span><span># is called like `make -C &lt;some path&gt;`
</span></span></span><span><span><span></span><span>PWD</span> <span>:=</span> <span>$(</span>realpath <span>$(</span>dir <span>$(</span>abspath <span>$(</span>firstword <span>$(</span>MAKEFILE_LIST<span>)))))</span>
</span></span><span><span>
</span></span><span><span><span>WORKTREE_ROOT</span> <span>:=</span> <span>$(</span>shell git rev-parse --show-toplevel 2&gt; /dev/null<span>)</span>
</span></span><span><span>
</span></span><span><span>
</span></span><span><span><span># Using $$() instead of $(shell) to run evaluation only when it&#39;s accessed
</span></span></span><span><span><span># https://unix.stackexchange.com/a/687206
</span></span></span><span><span><span></span><span>py</span> <span>=</span> <span>$$</span><span>(</span><span>if</span> <span>[</span> -d <span>$(</span>PWD<span>)</span>/<span>&#39;.venv&#39;</span> <span>]</span><span>;</span> <span>then</span> <span>echo</span> <span>$(</span>PWD<span>)</span>/<span>&#34;.venv/bin/python3&#34;</span><span>;</span> <span>else</span> <span>echo</span> <span>&#34;python3&#34;</span><span>;</span> <span>fi</span><span>)</span>
</span></span><span><span><span>pip</span> <span>=</span> <span>$(</span>py<span>)</span> -m pip
</span></span><span><span>
</span></span><span><span><span>.DEFAULT_GOAL</span> <span>:=</span> <span>help</span>
</span></span><span><span><span>.PHONY</span><span>:</span> <span>help</span>
</span></span><span><span><span>help</span><span>:</span> <span>## Display this help section
</span></span></span><span><span><span></span>	@awk <span>&#39;BEGIN {FS = &#34;:.*?## &#34;} /^[a-zA-Z\$$/]+.*:.*?##\s/ {printf &#34;\033[36m%-38s\033[0m %s\n&#34;, $$1, $$2}&#39;</span> <span>$(</span>MAKEFILE_LIST<span>)</span>
</span></span><span><span>
</span></span><span><span><span>.venv</span><span>:</span> <span>requirements</span>.<span>txt</span>  <span>## Build the virtual environment
</span></span></span><span><span><span></span>	<span>$(</span>py<span>)</span> -m venv .venv
</span></span><span><span>	<span>$(</span>pip<span>)</span> install -U pip setuptools wheel build
</span></span><span><span>	<span>$(</span>pip<span>)</span> install -U -r requirements.txt
</span></span><span><span>	touch .venv
</span></span></code></pre></div><h2 id="everything-else">Everything else</h2><p>Now, depending on your tooling, you may want to add recipes to call <code>pip-tools</code>, <code>poetry</code>, <code>black</code>, <code>ruff</code>, etc. I didn’t include those because I think it depends on how each project is set up.</p><p>If you’re looking for a general <code>make</code> tutorial, I think <a href="https://makefiletutorial.com/">this</a> is a good place to start. The <a href="https://www.gnu.org/software/make/manual/html_node/index.html">GNU Make manual</a> is also a good place to go deeper into some topics.</p></div></div>
  </body>
</html>
