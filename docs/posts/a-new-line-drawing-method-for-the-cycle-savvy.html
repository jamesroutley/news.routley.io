<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://www.quiss.org/boo/">Original</a>
    <h1>A new line drawing method for the cycle savvy</h1>
    
    <div id="readability-page-1" class="page"><div id="main_content_wrap">

<section id="main_content">



<h2>A new line drawing method for the cycle savvy</h2>

<p>In the demoscene, there&#39;s never a boundary that can&#39;t be pushed.
My recent 4k demo <a href="https://csdb.dk/release/?id=232949">&#34;Boo!&#34;</a>, released at X 2023, is a humble attempt to contribute
to this ongoing evolution. In particular, it pioneers a new way of computing lines.</p>

<p>Apart from unlocking a number of improvements in XOR fillers and similar effects, the
method, as used in the 4k, also significantly raises the bar for realtime filled sprite vector cubes.
The cube displayed in &#34;Boo!&#34; draws over an area of size 172x172, up from 140x140 in
<a href="http://csdb.dk/release/?id=198547">Protogeo 100%</a>.
This improvement to size is because line computation that
previously either took 7+ cycles per pixel (or exhaustive amounts of memory) can
now, thanks to the BRR (&#34;bit reverse rendered&#34;) line method, done in just 5 cycles per pixel.</p>

<p>Here, a line is a linear interpolation from a value x1 to a value x2 over y steps.
There has been, through the history of the demoscene, an exhuberant number of approaches to
solving this problem. The default, typically used in XOR fillers, adds a 16 bit slope to
a running position at every step.
A similar approach, &#34;Bresenham&#34;, only works for slopes with an integer part
of 0, but does away
with the need for division by multiplying all formulas with the denominator,
and thus changing the necessary overflow check from the &#34;power of 2&#34; boundary (256) to
one against dy. Other methods include fractional precalculation which calculates
the bit pattern of when the fractional
part of the position overflows, or
full precalculation, which stores all potential slopes in memory. The
latter leverages the fact that steeper slopes can only appear for
shorter lines, thereby only storing the necessary length.</p>

<p>All these methods are slower than BRR lines, for the step-by-step computation of
the positions:</p>

<table>
<tbody><tr>
<th><b>16 bit slope</b></th>
<th><b>Bresenham</b></th>
<th><b>Fractional precomputation</b></th>
<th><b>Full slope precalculation</b></th>
<th><b>BRR Lines</b></th>
</tr>
<tr>
<td>
<pre>tya
adc zp
tay
txa
adc zp
tax
</pre>
</td>

<td>
<pre>adc zp
bcc
sbc zp
inx
</pre>
</td>

<td>
<pre>lsr zp
adc zp
</pre>
</td>

<td>
<pre>adc (zp), y
iny
</pre>
</td>

<td>
<pre>cpx #imm
adc zp
</pre>
</td>
</tr>
<tr>
<td>14 cycles</td>
<td>8-10 cycles</td>
<td>8 cycles</td>
<td>7 cycles</td>
<td>5 cycles</td>
</tr>
</tbody></table>

<p>Note that as far as the slope math goes, Bresenham is special since it doesn&#39;t require the division
of x by y, but BRR lines do. So for short line segments, Bresenham can
still &#34;win&#34;.
In fact, BRR lines also need a bit more elaborate math for the
remainder. (So this method really shines if you&#39;re able to pull in the
1541 for help. See my upcoming post about drivecode)</p>

<p>How does this work? Let&#39;s dive deeper. First off, the idea (used in fractional precomputation) of
treating the computation of integer part and fractional part of the position as different
kinds of computations is a good, since they do tend to behave differently:</p>

<p><img src="http://www.quiss.org/boo/steps1.gif" alt="test" title=""/>
<img src="http://www.quiss.org/boo/steps0.gif" alt="test" title=""/></p>

<p>Here, to the very left is a line with only an integer slope (0 and 1), and then to the
right with progressively larger fractional slope components.
Note how the integer slope yields a regular pattern, while the fractional slope
introduces additional, irregular, notches.</p>

<p>We&#39;ve been assuming that we want to space said notches evenly. Do we have to?
Turns out we don&#39;t! Here are the same lines, with one notch at 1/2, and the other at 1/4:</p>

<p><img src="http://www.quiss.org/boo/steps2.gif" alt="test" title=""/></p>

<p>These still look like lines.</p>

<p>This is exactly the method used by BRR lines. Instead of putting the notch at positions that
depend on the slope (fractional part of x/y), we instead only take the remainder of x divided
by y, which tells us how many notches we need. And now we use a <em>comparison</em> operation that
gives us exactly that many notches over a distance of y.</p>

<p><img src="http://www.quiss.org/boo/thresholds.gif" alt="test" title=""/></p>

<p>So every time a value generated from the slope is larger than the value at the pattern, we
introduce a notch. The pattern can in theory be any list of (non-repeating) numbers (even
a random permutation of 0..255 &#34;works&#34;), but I&#39;ve found that the one pattern that mimicks
real line slopes the best is the bitreverse, which is what is used above.</p>

<p>And this is how BRR lines (right) look compared to traditional line drawing (left):</p>

<p><img src="http://www.quiss.org/boo/compare.gif" alt="test" title=""/></p>

<p>You will have noticed that the slope-based lines above &#34;wiggle&#34; more. This is true, and might
be considered one of the drawbacks of the algorithm.
However, the fact that BRR lines are more temporally stable can also conceivably be useful
in some applications.</p>

<p>So if the cpx compares against the bitreverse, what&#39;s &#34;x&#34;? It&#39;s a value derived from the remainder
of x/y. In particular, it&#39;s (assuming you&#39;re drawing from y1 to y2, and interpolating from x1 to x2):</p>

<pre><code>sorted(bitreverse[y1:y2])[(x2-x1) % (y2 - y1)]
</code></pre>

<p>This looks very expensive, but it&#39;s not. You do have to divide to get the modulo, but you&#39;re doing
that anyway since you need the integer part of the slope.
And you don&#39;t actually need to sort - since you&#39;re only looking for a single value in the sorted
list, you can instead do a bit-wise quickselect.
&#34;Boo!&#34; computes up to nine line slopes, including the above formula, per frame. (In the drive)</p>

<p>I&#39;ve so far implemented two different bit-fiddling approaches for computing
the above, the Python version of which you can download <a href="http://www.quiss.org/boo/bitreverse.html">here</a>.
(Or you can dig into the drive code of &#34;Boo&#34; to find the 6502 version of the algorithm. The
 bitreverse comparison value is computed at $0401, and is based on the second implementation.)</p>

<p>So there you are. Lines are cheap now! &#34;Boo!&#34; demonstrates how that changes the playing
field in sprite vectors, but they can be used in quite a few other effects. (Hint: what else
interpolates from a to b?)</p>


</section>

    </div></div>
  </body>
</html>
