<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.timescale.com/blog/postgresql-timescaledb-1000x-faster-queries-90-data-compression-and-much-more/">Original</a>
    <h1>TimescaleDB 2.7 vs. PostgreSQL 14</h1>
    
    <div id="readability-page-1" class="page"><div>
        <!--kg-card-begin: html--><p>
        <svg width="17" height="16" viewBox="0 0 17 16" fill="none" xmlns="http://www.w3.org/2000/svg">
	</svg>
<b> Compared to PostgreSQL alone, TimescaleDB can dramatically improve query performance by 1000x or more, reduce storage utilization by 90%, and provide features essential for time-series and analytical applications. Some of these features even benefit non-time-series data–increasing query performance just by loading the extension. </b> 
    </p>
<!--kg-card-end: html--><p>PostgreSQL is today’s most advanced and most popular open-source relational database. We believe this as much today as we did <a href="https://www.timescale.com/blog/when-boring-is-awesome-building-a-scalable-time-series-database-on-postgresql-2900ea453ee2/">5 years ago</a>, when we chose PostgreSQL as the foundation of TimescaleDB because of its longevity, extensibility, and rock-solid architecture.</p><p>By loading the TimescaleDB extension into a PostgreSQL database, you can effectively “supercharge” PostgreSQL, empowering it to excel for both time-series workloads and classic transactional ones. </p><p>This article highlights how TimescaleDB improves PostgreSQL query performance at scale, increases storage efficiency (thus lowering costs), and provides developers with the tools necessary for building modern, innovative, and cost-effective time-series applications – all while retaining access to the full Postgres feature-set and ecosystem.</p><p>(To show our work this article also presents the benchmarks that compare query performance and data ingestion for 1 billion rows of time-series data between PostgreSQL 14.4 and TimescaleDB 2.7.2.  For PostgreSQL, we benchmarked both using a single-table and declarative partitioning)</p><h2 id="better-performance-at-scale">Better Performance at Scale</h2><p>With orders of magnitude better performance at scale, TimescaleDB enables developers to build on top of PostgreSQL <em>and </em>“future-proof” their applications.</p><h3 id="1000x-faster-performance-for-time-series-queries">1000x Faster Performance for Time-series Queries</h3><p>The core concept in TimescaleDB is the notion of the “hypertable”: seamless partitioning of data, while presenting the abstraction of a single, virtual table across all your data. </p><p>This partitioning enables faster queries by quickly excluding irrelevant data, as well as enabling enhancements to the query planner and execution process. In this way, a hypertable looks and feels just like a normal PostgreSQL table, but enables a lot more.</p><p>For example, one recent query planner improvement excludes data more efficiently for relative <code>now()</code>-based queries (e.g., <code>WHERE time &gt;= now()-’1 week’::interval</code>). To be even more specific, <a href="https://www.timescale.com/blog/how-we-fixed-long-running-postgresql-now-queries/">these relative time predicates are constified</a> at planning time to ignore chunks that don&#39;t have data to satisfy the query. Furthermore, as the number of partitions increases, planning times can be reduced by 100x or more over vanilla PostgreSQL for the same number of partitions.</p><p>When hypertables are compressed the amount of data that queries need to read is reduced, leading to dramatic increases in performance of 1000x or more. For more information (including a discussion of this bar chart) keep reading to the benchmark below.</p><figure><img src="https://www.timescale.com/blog/content/images/2022/09/single-query-latency-milliseconds.png" alt="" loading="lazy" width="2000" height="1053" srcset="https://www.timescale.com/blog/content/images/size/w600/2022/09/single-query-latency-milliseconds.png 600w, https://www.timescale.com/blog/content/images/size/w1000/2022/09/single-query-latency-milliseconds.png 1000w, https://www.timescale.com/blog/content/images/size/w1600/2022/09/single-query-latency-milliseconds.png 1600w, https://www.timescale.com/blog/content/images/2022/09/single-query-latency-milliseconds.png 2070w" sizes="(min-width: 720px) 720px"/><figcaption>Query latency comparison (ms) between TimescaleDB and PostgreSQL 14.4. To see the complete query, scroll down below.</figcaption></figure><p>Other enhancements in TimescaleDB apply to both hypertables and normal PostgreSQL tables: e..g, SkipScan, which <a href="https://www.timescale.com/blog/how-we-made-distinct-queries-up-to-8000x-faster-on-postgresql/">dramatically improves DISTINCT queries on any PostgreSQL table</a> with a matching B-tree index regardless of if you have time-series data or not.</p><h3 id="reduce-commonly-run-queries-to-milliseconds-even-when-the-original-query-took-minutes-or-hours">Reduce Commonly Run Queries to Milliseconds (Even When The Original Query Took Minutes or Hours)<br/></h3><p>Today nearly every time-series application reaches for rolling aggregations to query and analyze data more efficiently. The raw data could be saved per second, minute, or hour (and a plethora of other permutations in between), but what most applications display are time-based aggregates. </p><p>What&#39;s more, most time-series data applications are append-only, which means that aggregate queries return the same values over and over based on the unchanged raw data. It&#39;s much more efficient to store the results of the aggregate query and use those for analytic reporting and analysis most of the time. </p><p>Often developers try materialized views in vanilla PostgreSQL to help, however, they have two main problems with fast-changing time-series data:</p><ul><li>Materialized views <em>recreate the entire view every time the materialization process runs, </em>even if little or no data has changed.</li><li>Materialized views don&#39;t provide any data retention management. Any time you delete raw data and update the materialized view, the aggregated data is removed as well.</li></ul><p>In contrast, <a href="https://docs.timescale.com/timescaledb/latest/how-to-guides/continuous-aggregates/about-continuous-aggregates/">TimescaleDB’s continuous aggregates</a> solve both of these problems. They are updated automatically on the <a href="https://docs.timescale.com/timescaledb/latest/how-to-guides/continuous-aggregates/refresh-policies/">schedule you configure</a>, they can have data <a href="https://docs.timescale.com/timescaledb/latest/how-to-guides/data-retention/data-retention-with-continuous-aggregates/#about-data-retention-with-continuous-aggregates">retention policies applied separately from the underlying hypertable</a>, and they only update the portions of new data that have been modified since the last materialization was run.</p><p>When we compare using a continuous aggregate to querying the data directly, customers often see queries which might take minutes or even hours drop to milliseconds. When that query is powering a dashboard or a web-page this can be the difference between snappy and unusable.</p><h3 id="scale-out-postgres-easily-across-multiple-nodes-for-petabyte-scale-datasets">Scale Out Postgres Easily Across Multiple Nodes For Petabyte-scale Datasets</h3><p>A common criticism of Postgres is that once you max out your database instance you can’t scale-out effectively. This was why we developed TimescaleDB Multi-node, a way of linking multiple PostgreSQL nodes to scale out ingest and query performance for petabyte-scale datasets while inserting over 1 million rows per second. </p><p>Using multi-node to provide distributed hypertables automatically spreads data across nodes, still allowing you to access that data as you normally would.</p><h2 id="lower-storage-costs">Lower Storage Costs</h2><p>The number one driver of cost for modern time-series applications is storage. Even when storage is cheap, time-series data piles up quickly. Timescale provides two methods to reduce the amount of data being stored, compression and downsampling using continuous aggregates.</p><h3 id="90-or-more-storage-savings-via-best-in-class-compression-algorithms">90% or More Storage Savings Via Best-in-class Compression Algorithms</h3><p>The Timescale hypertable is data heavily partitioned into many, many smaller partitions called “chunks.” Timescale provides <a href="https://docs.timescale.com/timescaledb/latest/how-to-guides/compression/about-compression/">native columnar compression</a> on this per-chunk basis. </p><p>As we show in the benchmark results (and as we see often in production databases), compression reduced disk consumption by over 90% compared to the same data in vanilla PostgreSQL. Even better, TimescaleDB doesn&#39;t change anything about the PostgreSQL storage system to achieve this level of compression. Instead, TimescaleDB utilizes PostgreSQL storage features, namely TOAST, to transition historical data from row-store to column-store, a key component for querying long-term aggregates over individual columns.</p><p>To demonstrate the effectiveness of compression here’s a comparison of the total size of the cpu table and indexes in TimescaleDB and in PostgreSQL. </p><figure><img src="https://www.timescale.com/blog/content/images/2022/09/total-cpu-table-size-2.png" alt="" loading="lazy" width="2000" height="1053" srcset="https://www.timescale.com/blog/content/images/size/w600/2022/09/total-cpu-table-size-2.png 600w, https://www.timescale.com/blog/content/images/size/w1000/2022/09/total-cpu-table-size-2.png 1000w, https://www.timescale.com/blog/content/images/size/w1600/2022/09/total-cpu-table-size-2.png 1600w, https://www.timescale.com/blog/content/images/2022/09/total-cpu-table-size-2.png 2070w" sizes="(min-width: 720px) 720px"/><figcaption>Storage savings between TimescaleDB and PostgreSQL</figcaption></figure><p>This reduces the storage footprint and improves query performance even further for many time-series aggregate queries. Compression is also automatic: users set a compression horizon, and then data is automatically compressed as it ages.</p><p>This also means that users can save significant costs using cloud services that provide separation of compute and storage – such as Timescale Cloud – so that larger machines aren’t needed just for more storage. </p><h3 id="more-storage-savings-by-easily-removing-or-downsampling-data">More Storage Savings by Easily Removing or Downsampling Data</h3><p>With TimescaleDB, automated <a href="https://docs.timescale.com/timescaledb/latest/how-to-guides/data-retention/about-data-retention/">data retention </a>is achieved with <a href="https://docs.timescale.com/timescaledb/latest/how-to-guides/data-retention/create-a-retention-policy/">one SQL command</a>:</p><pre><code>SELECT add_retention_policy(&#39;cpu&#39;, INTERVAL &#39;7 days&#39;);
</code></pre><p>There&#39;s no further setup or extra extensions to install or configure. Each day any partitions older than 7 days will be dropped automatically. If you were to implement this in vanilla PostgreSQL you’d need to use DELETE to remove records, which is a very costly operation as it needs to scan for the data to remove. Even if you were using PostgreSQL declarative partitioning you’d still need to automate the process yourself, wasting precious developer time, adding additional requirements, and implementing bespoke code that needs to be supported moving forward.</p><p>One can also combine continuous aggregates and data retention policies to downsample data, and then drop the raw measurements, thus saving even more data storage. </p><p>Using this architecture, you can retain higher-level rollup values for a longer period of time, even after the raw data has been dropped from the database. This allows multiple different levels of granularity to be stored in the database, and provides even more ways to control storage costs.</p><h2 id="more-features-to-speed-up-development-time">More Features to Speed up Development Time</h2><p>TimescaleDB includes more features that speed up development time. This includes a library of over 100 hyperfunctions, which make complex time-series analysis easy using SQL, such as count approximations, statistical aggregates, and more. TimescaleDB also includes a built-in, multi-purpose job scheduling engine for setting up automated workflows.</p><h3 id="library-of-over-100-hyperfunctions-that-make-complex-analysis-easy">Library of Over 100 Hyperfunctions That Make Complex Analysis Easy</h3><p>Timescale hyperfunctions make data analysis in SQL easy. This library includes: <a href="https://docs.timescale.com/api/latest/hyperfunctions/time-weighted-averages/">time-weighted averages</a>, <a href="https://docs.timescale.com/api/latest/hyperfunctions/gapfilling-interpolation/locf/">last observation carried forward</a>, and <a href="https://docs.timescale.com/api/latest/hyperfunctions/downsample/">downsampling with LTTP or ASAP algorithms</a>, <a href="https://docs.timescale.com/api/latest/hyperfunctions/time_bucket/">time_bucket()</a>, and <a href="https://docs.timescale.com/api/latest/hyperfunctions/gapfilling-interpolation/time_bucket_gapfill/">time_bucket_gapfill()</a>. </p><p>As an example, one could get the average temperature every day for each device over the last seven days, carrying forward the last value for missing readings with the following SQL.</p><pre><code>SELECT
  time_bucket_gapfill(&#39;1 day&#39;, time) AS day,
  device_id,
  avg(temperature) AS value,
  locf(avg(temperature))
FROM metrics
WHERE time &gt; now () - INTERVAL &#39;1 week&#39;
GROUP BY day, device_id
ORDER BY day;
</code></pre><p>For more information on the extensive list of hyperfunctions in TimescaleDB, please visit our <a href="https://docs.timescale.com/api/latest/hyperfunctions/">API documentation</a>.</p><h3 id="built-in-job-scheduler-for-workflow-automation">Built-in Job Scheduler For Workflow Automation</h3><p>TimescaleDB provides the ability to schedule the execution of custom stored procedures with <a href="https://docs.timescale.com/timescaledb/latest/how-to-guides/user-defined-actions/">user-defined actions</a>. This feature provides access to the same job scheduler that TimescaleDB uses to run all of the native automation jobs for compression, continuous aggregates, data retention, and more. </p><p>This provides the similar functionality as a third party scheduler like <code>pg_cron</code>, without needing to maintain multiple PostgreSQL extensions or databases.</p><p>We see users doing all sorts of neat stuff with user-defined actions, from calculating complex SLAs, to sending event emails based on data correctness, to polling tables.</p><h2 id="still-100-postgresql-and-sql">Still 100% PostgreSQL And SQL</h2><p>Notably, because TimescaleDB is packaged as a PostgreSQL extension, it achieves these results without forking or breaking PostgreSQL.</p><h3 id="extending-postgresqlnot-forking-or-cloning">Extending PostgreSQL - Not Forking or Cloning</h3><p>Postgres is popular at the moment, but a lot of that popularity is with ‘Postgres compatible’ products which might look like Postgres, or talk like Postgres, or query somewhat like Postgres - but aren’t Postgres under the hood (and are sometimes closed-source). </p><p>TimescaleDB is just PostgreSQL. One can install other extensions, make full use of the type system, and benefit from the incredibly diverse Postgres ecosystem.</p><h3 id="100-sql">100% SQL</h3><p>Any product which can connect to Postgres can query time-series data stored with TimescaleDB using the same SQL it normally would. While we provide helper functions for working with data, we do not restrict the SQL features one can use. Once in the database, users can combine time-series and business data as necessary.</p><h3 id="rock-solid-foundations-thanks-to-postgres">Rock Solid Foundations Thanks to Postgres</h3><p>PostgreSQL is not a new database: it has years of production deployments under its belt. High availability, backup and restore, and load-balancing are all solved problems. As we mentioned earlier, we chose Postgres because it was reliable, and TimescaleDB inherits that reliability.</p><h2 id="benchmarking-setup-and-results">Benchmarking Setup And Results</h2><p>This section provides details about how we tested TimescaleDB against vanilla PostgreSQL. Feel free to download the <a href="https://github.com/timescale/tsbs">Time-Series Benchmarking Suite</a> and run it for yourself. If you&#39;d like to get started with TimescaleDB quickly you can use Timescale Cloud, which lets you <a href="https://www.timescale.com/timescale-signup">sign up for a free, 30-day trial</a>.</p><h3 id="benchmark-configuration">Benchmark Configuration</h3><p>For this benchmark, all tests were run on the same m5.2xlarge EC2 instance in AWS us-east-1 with the following configuration and software versions. </p><ul><li>Versions: TimescaleDB version 2.7.2, community edition, and PostgreSQL 14.4</li><li>One remote client machine running TSBS, one database server, both in the same cloud datacenter</li><li>TSBS Client Instance: EC2 m5.4xlarge  with 16 vCPU and 64GB memory</li><li>Database server instance: EC2 m5.2xlarge  with 8 vCPU and 32GB memory</li><li>OS: both server and client machines ran Ubuntu 20.04</li><li>Disk size: 1TB of EBS GP2 storage</li><li>TSBS config: Dev-ops profile, 4,000 devices recording metrics every 10 seconds over one month.</li></ul><p>We also deliberately chose to use EBS (elastic block storage) volumes rather than attached SSDs. While benchmark performance would certainly improve with SSDs, the baseline performance using EBS is illustrative of what many self-hosted users could expect while saving some expenses by using elastic storage.</p><h3 id="database-configuration">Database Configuration</h3><p>We ran only one PostgreSQL cluster on the EC2 database instance. The TimescaleDB extension was loaded via <code>shared_preload_libraries</code> but not installed into the PostgreSQL-only database.</p><p>To set sane defaults for the PostgreSQL cluster, we ran <code>timescaledb-tune</code> and set<code>synchronous_commit=off</code> in postgresql.conf. This is a common performance configuration for write-heavy workloads while still maintaining transactional, logged integrity. <strong>All configuration changes applied to both PostgreSQL and TimescaleDB benchmarks alike.</strong></p><h3 id="the-dataset">The Dataset</h3><p>As we mentioned earlier, for this benchmark, we used the <a href="https://github.com/timescale/tsbs">Time-Series Benchmarking Suite </a>and generated data for 4,000 devices, recording metrics every 10 seconds, for one month. This generated just over one billion rows of data. Because TimescaleDB is a PostgreSQL extension, we could use the same data file and ingestion process, ensuring identical data in each database.</p><h3 id="timescaledb-setup">TimescaleDB Setup</h3><p>TimescaleDB uses an abstraction called hypertables which splits large tables into smaller chunks, increasing performance and greatly easing management of large amounts of time-series data.</p><p>We also enabled native compression on TimescaleDB. We compressed everything but the most recent chunk of data, leaving it uncompressed. This configuration is a commonly recommended one where raw, uncompressed data is kept for recent time periods and older data is compressed, enabling greater query efficiency. The parameters we used to enable compression are as follows: we segmented by the tags_id columns and ordered by time descending and usage_user columns.</p><p><strong><em>All benchmark results were performed on a single PostgreSQL table and on an empty TimescaleDB hypertable created with 4-hour chunks.</em></strong></p><p>(And for those thinking that we also need to compare TimescaleDB with Postgres Declarative Partitioning: please read on to the end, we discuss that as well.)</p><h2 id="query-latency-deep-dive">Query Latency Deep Dive</h2><p>For this benchmark we inserted one billion rows of data and then ran a set of queries 100 times each against the respective database. The data, indexes, and queries are exactly the same for both databases. The only difference is that the TimescaleDB queries use the <code>time_bucket()</code> function for doing arbitrary interval bucketing, whereas the PostgreSQL queries use the new <code>date_bin()</code> function, introduced in PostgreSQL 13.</p><figure><img src="https://www.timescale.com/blog/content/images/2022/09/Query-latency-deep-dive--1--1.png" alt="" loading="lazy" width="2000" height="1639" srcset="https://www.timescale.com/blog/content/images/size/w600/2022/09/Query-latency-deep-dive--1--1.png 600w, https://www.timescale.com/blog/content/images/size/w1000/2022/09/Query-latency-deep-dive--1--1.png 1000w, https://www.timescale.com/blog/content/images/size/w1600/2022/09/Query-latency-deep-dive--1--1.png 1600w, https://www.timescale.com/blog/content/images/2022/09/Query-latency-deep-dive--1--1.png 2070w" sizes="(min-width: 720px) 720px"/><figcaption>Query latency comparison between PostgreSQL and TimescaleDB, for different queries</figcaption></figure><p>The results are clear and consistently reproducible. For one billion rows of data spanning one month of time (with four-hour partitions), <em><strong>TimescaleDB consistently outperformed a vanilla PostgreSQL database running 100 queries at a time.</strong></em> </p><p>There are two main reasons for Timescale&#39;s consistent query performance.</p><h3 id="compression-smaller-storage-less-work">Compression = Smaller Storage + Less Work</h3><p>In PostgreSQL (and many other databases), table data is stored in an 8Kb page (sometimes called a block). If a query has to read 1,000 pages to satisfy it, it reads ~8Mb of data. If some of that data had to be retrieved from disk, then the query will usually be slower than if all of the data was found in memory (the reserved space known as <em>shared buffers</em> in PostgreSQL, if you’re looking for some insight into Postgres caching we have <a href="https://www.timescale.com/blog/database-scaling-postgresql-caching-explained/">a blog on that</a>).</p><p>With TimescaleDB compression, queries which return the same results have to read significantly fewer pages of data (this is both because of the actual compression, and because it can return single columns rather than whole rows). For all of our benchmarking queries, this also translates into higher concurrency for the benchmark duration.</p><p>Stated another way, compression typically impacts fetching historical data most because TimescaleDB can query individual columns rather than entire rows. Because less I/O is occurring for each query, TimescaleDB can handle more queries with a lower standard deviation than vanilla PostgreSQL</p><p>Let&#39;s look at two examples of how this plays out between the two databases using two queries above, <code>cpu-max-all-1</code> and <code>single-groupby-1-1-12</code>.</p><p><strong>single-groupby-1-1-12</strong></p><p>We selected one of the queries from the benchmark and ran it on both databases. Recall that each database has the exact same data and indexes on uncompressed data. TimescaleDB has the advantage of being able to segment and order compressed data in a way that&#39;s beneficial to typical application queries.</p><pre><code>EXPLAIN (ANALYZE,BUFFERS)
SELECT time_bucket(&#39;1 minute&#39;, time) AS minute,
        max(usage_user) as max_usage_user
        FROM cpu
        WHERE tags_id IN (
          SELECT id FROM tags WHERE hostname IN (&#39;host_249&#39;)
        ) 
        AND time &gt;= &#39;2022-08-03 06:16:22.646325 +0000&#39; 
        AND time &lt; &#39;2022-08-03 18:16:22.646325 +0000&#39;
        GROUP BY minute ORDER BY minute;</code></pre><p>When we run the EXPLAIN on this query and ask for BUFFERS to be returned, we start to get a hint of what&#39;s happening.</p><figure><img src="https://www.timescale.com/blog/content/images/2022/09/single-query-latency-single-groupby-1-1-12.png" alt="" loading="lazy" width="2000" height="1053" srcset="https://www.timescale.com/blog/content/images/size/w600/2022/09/single-query-latency-single-groupby-1-1-12.png 600w, https://www.timescale.com/blog/content/images/size/w1000/2022/09/single-query-latency-single-groupby-1-1-12.png 1000w, https://www.timescale.com/blog/content/images/size/w1600/2022/09/single-query-latency-single-groupby-1-1-12.png 1600w, https://www.timescale.com/blog/content/images/2022/09/single-query-latency-single-groupby-1-1-12.png 2070w" sizes="(min-width: 720px) 720px"/><figcaption>Query latency vs volume of data that has to be read to satisfy the query, in TimescaleDB and PostgreSQL.</figcaption></figure><p>Two things quickly jump out when I view these results. First, the execution times are significantly lower than the benchmarking results above. Individually, these queries execute pretty fast, but PostgreSQL has to read approximately 27x more data to satisfy the query. When 16 workers request data across the time range, PostgreSQL has to do a lot more I/O, which consumes resources. TimescaleDB can simply handle a higher concurrency for the same workload. We can see this in the full benchmarking output, too.</p><figure><img src="https://lh4.googleusercontent.com/-W6sPlaQFmAU_TXgusnr6OFM905t45A37XkBODPT6t_sUtJ_LD4WJ-2MBEFat2eX30cfnSNuK_CqyoPv2bfCUV-oZ_GWc0YGqvH3281v9ihIN3LVlOXFfvN_7MoCApnZty7cxFF6cbfEGWpeTvnp67gPRATPq3JoRsgeGCqnNCZpPqd1NP0uosu46g" alt="" loading="lazy"/></figure><p><strong>cpu-max-all-1</strong></p><p>Again we can clearly see the impact of compression on the ability for TimescaleDB to handle a higher concurrent load when compared to vanilla PostgreSQL for time-series queries.</p><pre><code>EXPLAIN (ANALYZE, buffers) 
SELECT
   time_bucket(&#39;3600 seconds&#39;, time) AS hour,
   max(usage_user) AS max_usage_user,
   max(usage_system) AS max_usage_system,
   max(usage_idle) AS max_usage_idle,
   max(usage_nice) AS max_usage_nice,
   max(usage_iowait) AS max_usage_iowait,
   max(usage_irq) AS max_usage_irq,
   max(usage_softirq) AS max_usage_softirq,
   max(usage_steal) AS max_usage_steal,
   max(usage_guest) AS max_usage_guest,
   max(usage_guest_nice) AS max_usage_guest_nice 
FROM cpu 
WHERE  
   tags_id IN (
      SELECT id FROM tags WHERE hostname IN (&#39;host_249&#39;)
   )
   AND time &gt;= &#39;2022-08-08 18:16:22.646325 +0000&#39; 
   AND time &lt; &#39;2022-08-09 02:16:22.646325 +0000&#39; 
GROUP BY HOUR 
ORDER BY HOUR;</code></pre><figure><img src="https://www.timescale.com/blog/content/images/2022/09/single-query-latency-cpu-max-all-1.png" alt="" loading="lazy" width="2000" height="1053" srcset="https://www.timescale.com/blog/content/images/size/w600/2022/09/single-query-latency-cpu-max-all-1.png 600w, https://www.timescale.com/blog/content/images/size/w1000/2022/09/single-query-latency-cpu-max-all-1.png 1000w, https://www.timescale.com/blog/content/images/size/w1600/2022/09/single-query-latency-cpu-max-all-1.png 1600w, https://www.timescale.com/blog/content/images/2022/09/single-query-latency-cpu-max-all-1.png 2070w" sizes="(min-width: 720px) 720px"/><figcaption>Query latency vs volume of data that has to be read to satisfy the query, in TimescaleDB and PostgreSQL</figcaption></figure><figure><img src="https://lh3.googleusercontent.com/TSOwosPyGDDSxjLHiGaIEvtb3tEUMv16weLt4DaT-ckmUJJvQFgMnp9x0590cgVH3eMve1x5yLjNwgmXLzWRX6e7luLfmCRwkM4PHnB_ZQf6--nDlLr1DD0PmcpZb6N1HrHh4UpBMxwTrNBK7PPMxifcprmpUn3BTsnwKWRrwHqjCgCTLeiNCjB50Q" alt="" loading="lazy"/></figure><p>With compression, TimescaleDB does significantly less work to retrieve the same data, resulting in faster queries and higher query concurrency.</p><h3 id="time-ordered-queries-just-work-better">Time-Ordered Queries Just Work Better</h3><p>TimescaleDB hypertables require a time column to partition the data. Because time is an essential (and known) part of each row and chunk, TimescaleDB can intelligently improve how the query is planned and executed to take advantage of the time component of the data.</p><p>For example, let&#39;s query for the maximum CPU usage for each minute for the last 10 minutes.</p><pre><code>EXPLAIN (ANALYZE,BUFFERS)        
SELECT time_bucket(&#39;1 minute&#39;, time) AS minute, 
  max(usage_user) 
FROM cpu 
WHERE time &gt; &#39;2022-08-14 07:12:17.568901 +0000&#39; 
GROUP BY minute 
ORDER BY minute DESC 
LIMIT 10;
</code></pre><p>Because TimescaleDB understands that this query is aggregating on time and the result is ordered by the time column (something each chunk is already ordering by in an index), it can use the ChunkAppend custom execution node. In contrast, PostgreSQL plans five workers to scan all partitions before sorting the results and finally doing a <code>GroupAggregate</code> on the time column.</p><figure><img src="https://www.timescale.com/blog/content/images/2022/09/single-query-latency-chunkappend-1.png" alt="" loading="lazy" width="2000" height="1053" srcset="https://www.timescale.com/blog/content/images/size/w600/2022/09/single-query-latency-chunkappend-1.png 600w, https://www.timescale.com/blog/content/images/size/w1000/2022/09/single-query-latency-chunkappend-1.png 1000w, https://www.timescale.com/blog/content/images/size/w1600/2022/09/single-query-latency-chunkappend-1.png 1600w, https://www.timescale.com/blog/content/images/2022/09/single-query-latency-chunkappend-1.png 2070w" sizes="(min-width: 720px) 720px"/><figcaption>Query latency vs volume of data that has to be read to satisfy the query, in TimescaleDB and PostgreSQL</figcaption></figure><p>TimescaleDB scans less data and doesn&#39;t need to spend time re-sorting the data that it knows is already sorted in the chunk. For time-series data with a known order and constraints, TimescaleDB works better for most queries than vanilla PostgreSQL.</p><h3 id="ingest-performance">Ingest Performance</h3><p>Intriguingly, ingest performance for both TimescaleDB and PostgreSQL are nearly identical, a dramatic improvement for PostgreSQL given the <a href="https://www.timescale.com/blog/timescaledb-vs-6a696248104e/">results 5 years ago with PostgreSQL 9.6</a>. However, TimscaleDB still consistently finished with an average rate that was 3,000 to 4,000 rows/second higher than a single PostgreSQL table.</p><figure><img src="https://www.timescale.com/blog/content/images/2022/09/insert-performance-of-1-billion-rows--1--1.png" alt="" loading="lazy" width="2000" height="1349" srcset="https://www.timescale.com/blog/content/images/size/w600/2022/09/insert-performance-of-1-billion-rows--1--1.png 600w, https://www.timescale.com/blog/content/images/size/w1000/2022/09/insert-performance-of-1-billion-rows--1--1.png 1000w, https://www.timescale.com/blog/content/images/size/w1600/2022/09/insert-performance-of-1-billion-rows--1--1.png 1600w, https://www.timescale.com/blog/content/images/2022/09/insert-performance-of-1-billion-rows--1--1.png 2070w" sizes="(min-width: 720px) 720px"/><figcaption>Insert performance comparison between TimescaleDB 2.7.2 and PostgreSQL 14.4</figcaption></figure><p>This shows that while vast improvements have been made in PostgreSQL, Timescale hypertables also continue to perform exceptionally well. As well as the rate, the other characteristics of ingest performance are nearly identical between TimescaleDB and PostgreSQL. Modifying the batch size for the number of rows to insert at a time impacts each database the same: small batch sizes or a few hundred rows significantly hinder ingest performance, while batch sizes of 10,000 to 15,000 rows seem to be about optimal for this dataset.</p><h3 id="declarative-partitioning">Declarative Partitioning</h3><p>In the benchmarks above we tested TimescaleDB against a single PostgreSQL table, simply because that’s the default option that most people end up using. PostgreSQL also has support for native declarative partitioning, which has also been maturing over the past few years. </p><p>For the sake of completeness, we also tested TimescaleDB against native declarative partitioning. As the graphic below shows TimescaleDB is still 1000x faster for some queries, with strong performance gains still showing across the board. Ingest performance was similar between TimescaleDB and declarative partitioning.</p><p>In fact, if anything, the takeaway from these tests was that while declarative partitioning has matured, the gap between using a single-table and declarative partitioning has shrunk.</p><figure><img src="https://lh5.googleusercontent.com/NbxtVfQFfyX9Jni66GxBTXaSWJTZbAdzKLus09m7ICOxnUskJ4s3Zq9SgYiq2V9AImdLFwdagDAgHQr7xrVdh9zBF1yLNjuKSzJRmYslJfWPz0dsOo37n7cy95vgw_Ab7rKQ2Ab55iUnieV7zIdTn6qqT6eX7nxJ8uaqtUSoPYiKqbyxcoQ25HD3ag" alt="" loading="lazy"/><figcaption>Query latency comparison between TimescaleDB and PostgreSQL with declarative partitioning</figcaption></figure><p>Using declarative partitioning is also harder. One needs to manually pre-create partitions, ensure there are no data gaps, ensure no data is inserted outside of your partition ranges, and create more partitions as time moves on.</p><p>In contrast, with TimescaleDB, one does not need any of this. Instead, a single <code>create_hypertable</code> command is used to convert a standard table into a hypertable, and TimescaleDB takes care of the rest.</p><h2 id="conclusion">Conclusion</h2><p>TimescaleDB harnesses the power of the extension framework to supercharge PostgreSQL for time-series and analytical applications. With additional features like compression and continuous aggregates, TimescaleDB provides not only the most performant way of using time-series data in Postgres, but also the best developer experience. </p><p>When compared to traditional PostgreSQL, TimescaleDB enables 1000x faster time-series queries, compresses data by 90%, and provides access to advanced time-series analysis tools and operational features specifically designed to ease data management. TimescaleDB also provides benefits for other types of queries with features like SkipScan–just by installing the extension.</p><p>In short, TimescaleDB extends PostgreSQL to enable developers to continue to use the database they love for time-series, perform better at scale, spend less, and stream data analysis and operations. </p><p>If you’re looking to expand your database scalability, try our hosted service, <a href="https://www.timescale.com/cloud">Timescale Cloud</a>. You will get the PostgreSQL you know and love with extra features for time series (<a href="https://www.timescale.com/blog/how-we-made-data-aggregation-better-and-faster-on-postgresql-with-timescaledb-2-7/">continuous aggregation</a>, <a href="https://docs.timescale.com/api/latest/compression/">compression</a>, <a href="https://docs.timescale.com/timescaledb/latest/how-to-guides/data-retention/about-data-retention/#drop-data-by-chunk">automatic retention policies</a>, <a href="https://www.timescale.com/blog/how-postgresql-aggregation-works-and-how-it-inspired-our-hyperfunctions-design-2/">hyperfunctions</a>). Plus, a platform with <a href="https://www.timescale.com/blog/how-high-availability-works-in-our-cloud-database/">automated backups, high availability</a>, automatic upgrades, flexible resizing with autoscaling, and much more. <a href="http://tsdb.co/cloud-signup">You can use it for free for 30 days; no credit card required</a>.</p>
        <div>
          <p>The open-source relational database for time-series and analytics.</p>
          <p><a href="https://www.timescale.com/timescale-signup">
            Try Timescale for free
          </a>

        </p></div>
      </div></div>
  </body>
</html>
