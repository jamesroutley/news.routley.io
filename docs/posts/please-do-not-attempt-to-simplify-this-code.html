<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/kubernetes/kubernetes/blob/60c4c2b2521fb454ce69dee737e3eb91a25e0535/pkg/controller/volume/persistentvolume/pv_controller.go">Original</a>
    <h1>Please do not attempt to simplify this code</h1>
    
    <div id="readability-page-1" class="page"><div><section aria-labelledby="file-name-id-wide file-name-id-mobile"><div><div id="highlighted-line-menu-positioner"><div id="copilot-button-positioner"><div><div role="presentation" aria-hidden="true" data-tab-size="8" data-paste-markdown-skip="true" data-hpc="true"><div><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p><p>29</p><p>30</p><p>31</p><p>32</p><p>33</p><p>34</p><p>35</p><p>36</p><p>37</p><p>38</p><p>39</p><p>40</p><p>41</p><p>42</p><p>43</p><p>44</p><p>45</p><p>46</p><p>47</p><p>48</p><p>49</p><p>50</p><p>51</p><p>52</p><p>53</p><p>54</p><p>55</p><p>56</p><p>57</p><p>58</p><p>59</p><p>60</p><p>61</p><p>62</p><p>63</p><p>64</p><p>65</p><p>66</p><p>67</p><p>68</p><p>69</p><p>70</p><p>71</p><p>72</p><p>73</p><p>74</p><p>75</p><p>76</p><p>77</p><p>78</p><p>79</p><p>80</p><p>81</p><p>82</p><p>83</p><p>84</p><p>85</p><p>86</p><p>87</p><p>88</p><p>89</p><p>90</p><p>91</p><p>92</p><p>93</p><p>94</p><p>95</p><p>96</p><p>97</p><p>98</p><p>99</p><p>100</p><p>101</p><p>102</p><p>103</p><p>104</p><p>105</p><p>106</p><p>107</p><p>108</p><p>109</p><p>110</p><p>111</p><p>112</p><p>113</p><p>114</p><p>115</p><p>116</p><p>117</p><p>118</p><p>119</p><p>120</p><p>121</p><p>122</p><p>123</p><p>124</p><p>125</p><p>126</p><p>127</p><p>128</p><p>129</p><p>130</p><p>131</p><p>132</p><p>133</p><p>134</p><p>135</p><p>136</p><p>137</p><p>138</p><p>139</p><p>140</p><p>141</p><p>142<span></span></p><p>143</p><p>144</p><p>145</p><p>146</p><p>147</p><p>148</p><p>149</p><p>150</p><p>151</p><p>152</p><p>153</p><p>154</p><p>155</p><p>156</p><p>157</p><p>158</p><p>159</p><p>160</p><p>161</p><p>162</p><p>163</p><p>164</p><p>165</p><p>166</p><p>167</p><p>168</p><p>169</p><p>170</p><p>171</p><p>172</p><p>173</p><p>174</p><p>175</p><p>176</p><p>177</p><p>178</p><p>179</p><p>180</p><p>181</p><p>182</p><p>183</p><p>184</p><p>185</p><p>186</p><p>187</p><p>188</p><p>189</p><p>190</p><p>191</p><p>192</p><p>193</p><p>194</p><p>195</p><p>196</p><p>197</p><p>198</p><p>199</p><p>200</p><p>201</p><p>202</p><p>203</p><p>204</p><p>205</p><p>206</p><p>207</p><p>208</p><p>209</p><p>210</p><p>211</p><p>212</p><p>213</p><p>214</p><p>215</p><p>216</p><p>217</p><p>218</p><p>219</p><p>220</p><p>221</p><p>222</p><p>223</p><p>224</p><p>225</p><p>226</p><p>227</p><p>228</p><p>229</p><p>230</p><p>231</p><p>232</p><p>233</p><p>234</p><p>235</p><p>236<span></span></p><p>237</p><p>238</p><p>239</p><p>240</p><p>241</p><p>242</p><p>243</p><p>244</p><p>245</p><p>246</p><p>247</p><p>248</p><p>249</p><p>250</p><p>251</p><p>252</p><p>253</p><p>254</p><p>255</p><p>256</p><p>257</p><p>258<span></span></p><p>259</p><p>260</p><p>261</p><p>262</p><p>263</p><p>264</p><p>265</p><p>266</p><p>267</p><p>268</p><p>269</p><p>270</p><p>271</p><p>272</p><p>273</p><p>274</p><p>275</p><p>276</p><p>277</p><p>278</p><p>279</p><p>280</p><p>281</p><p>282</p><p>283</p><p>284</p><p>285</p><p>286</p><p>287</p><p>288</p><p>289</p><p>290</p><p>291</p><p>292</p><p>293</p><p>294</p><p>295</p><p>296</p><p>297</p><p>298</p><p>299</p><p>300</p><p>301</p><p>302</p><p>303</p><p>304</p><p>305<span></span></p><p>306</p><p>307</p><p>308</p><p>309</p><p>310</p><p>311</p><p>312</p><p>313</p><p>314</p><p>315</p><p>316</p><p>317</p><p>318</p><p>319</p><p>320</p><p>321</p><p>322</p><p>323</p><p>324</p><p>325</p><p>326</p><p>327</p><p>328</p><p>329</p><p>330<span></span></p><p>331</p><p>332</p><p>333</p><p>334</p><p>335</p><p>336</p><p>337</p><p>338</p><p>339</p><p>340</p><p>341</p><p>342</p><p>343</p><p>344</p><p>345</p><p>346</p><p>347</p><p>348</p><p>349</p><p>350</p><p>351</p><p>352</p><p>353</p><p>354</p><p>355</p><p>356</p><p>357</p><p>358</p><p>359</p><p>360</p><p>361</p><p>362</p><p>363</p><p>364</p><p>365</p><p>366</p><p>367</p><p>368</p><p>369</p><p>370</p><p>371</p><p>372</p><p>373</p><p>374</p><p>375</p><p>376</p><p>377</p><p>378</p><p>379</p><p>380</p><p>381</p><p>382</p><p>383</p><p>384</p><p>385</p><p>386</p><p>387</p><p>388</p><p>389</p><p>390</p><p>391</p><p>392</p><p>393</p><p>394</p><p>395</p><p>396</p><p>397</p><p>398</p><p>399</p><p>400</p><p>401</p><p>402</p><p>403</p><p>404</p><p>405</p><p>406</p><p>407</p><p>408</p><p>409</p><p>410</p><p>411</p><p>412</p><p>413</p><p>414</p><p>415</p><p>416</p><p>417</p><p>418</p><p>419</p><p>420</p><p>421</p><p>422</p><p>423</p><p>424</p><p>425</p><p>426</p><p>427</p><p>428</p><p>429</p><p>430</p><p>431</p><p>432</p><p>433</p><p>434</p><p>435</p><p>436</p><p>437</p><p>438</p><p>439</p><p>440</p><p>441</p><p>442</p><p>443</p><p>444</p><p>445</p><p>446</p><p>447</p><p>448</p><p>449</p><p>450</p><p>451</p><p>452</p><p>453</p><p>454</p><p>455</p><p>456</p><p>457</p><p>458</p><p>459</p><p>460</p><p>461</p><p>462</p><p>463</p><p>464</p><p>465</p><p>466</p><p>467</p><p>468</p><p>469</p><p>470</p><p>471</p><p>472</p><p>473</p><p>474</p><p>475</p><p>476</p><p>477</p><p>478</p><p>479</p><p>480</p><p>481</p><p>482</p><p>483</p><p>484</p><p>485</p><p>486</p><p>487</p><p>488</p><p>489</p><p>490</p><p>491<span></span></p><p>492</p><p>493</p><p>494</p><p>495</p><p>496</p><p>497</p><p>498</p><p>499</p><p>500</p><p>501</p><p>502</p><p>503</p><p>504</p><p>505</p><p>506</p><p>507</p><p>508</p><p>509</p><p>510</p><p>511</p><p>512</p><p>513</p><p>514</p><p>515</p><p>516</p><p>517</p><p>518</p><p>519</p><p>520</p><p>521</p><p>522</p><p>523</p><p>524</p><p>525</p><p>526</p><p>527</p><p>528</p><p>529</p><p>530</p><p>531</p><p>532</p><p>533</p><p>534</p><p>535</p><p>536</p><p>537</p><p>538</p><p>539</p><p>540</p><p>541</p><p>542</p><p>543</p><p>544</p><p>545</p><p>546</p><p>547</p><p>548</p><p>549</p><p>550</p><p>551</p><p>552</p><p>553</p><p>554</p><p>555</p><p>556</p><p>557</p><p>558</p><p>559</p><p>560</p><p>561<span></span></p><p>562</p><p>563</p><p>564</p><p>565</p><p>566</p><p>567</p><p>568</p><p>569</p><p>570</p><p>571</p><p>572</p><p>573</p><p>574</p><p>575</p><p>576</p><p>577</p><p>578</p><p>579</p><p>580</p><p>581</p><p>582</p><p>583</p><p>584</p><p>585</p><p>586</p><p>587</p><p>588</p><p>589</p><p>590</p><p>591</p><p>592</p><p>593</p><p>594</p><p>595</p><p>596</p><p>597</p><p>598</p><p>599</p><p>600</p><p>601</p><p>602</p><p>603</p><p>604</p><p>605</p><p>606</p><p>607</p><p>608</p><p>609</p><p>610</p><p>611</p><p>612</p><p>613</p><p>614</p><p>615</p><p>616</p><p>617</p><p>618</p><p>619</p><p>620</p><p>621</p><p>622</p><p>623</p><p>624</p><p>625</p><p>626</p><p>627</p><p>628</p><p>629</p><p>630</p><p>631</p><p>632</p><p>633</p><p>634</p><p>635</p><p>636</p><p>637</p><p>638</p><p>639</p><p>640</p><p>641</p><p>642</p><p>643</p><p>644</p><p>645</p><p>646</p><p>647</p><p>648</p><p>649</p><p>650</p><p>651</p><p>652</p><p>653</p><p>654</p><p>655</p><p>656</p><p>657</p><p>658</p><p>659</p><p>660</p><p>661</p><p>662</p><p>663</p><p>664</p><p>665</p><p>666</p><p>667</p><p>668</p><p>669</p><p>670</p><p>671</p><p>672</p><p>673</p><p>674</p><p>675</p><p>676</p><p>677</p><p>678</p><p>679</p><p>680</p><p>681</p><p>682</p><p>683</p><p>684</p><p>685</p><p>686</p><p>687</p><p>688</p><p>689</p><p>690</p><p>691</p><p>692</p><p>693</p><p>694</p><p>695</p><p>696</p><p>697</p><p>698</p><p>699</p><p>700</p><p>701</p><p>702</p><p>703</p><p>704</p><p>705</p><p>706</p><p>707</p><p>708</p><p>709</p><p>710</p><p>711</p><p>712</p><p>713</p><p>714</p><p>715</p><p>716</p><p>717</p><p>718</p><p>719</p><p>720</p><p>721</p><p>722</p><p>723</p><p>724</p><p>725</p><p>726</p><p>727</p><p>728</p><p>729</p><p>730</p><p>731</p><p>732</p><p>733</p><p>734</p><p>735</p><p>736</p><p>737</p><p>738</p><p>739</p><p>740</p><p>741</p><p>742</p><p>743</p><p>744</p><p>745</p><p>746</p><p>747</p><p>748</p><p>749</p><p>750</p><p>751</p><p>752</p><p>753</p><p>754</p><p>755</p><p>756</p><p>757</p><p>758</p><p>759</p><p>760</p><p>761</p><p>762</p><p>763</p><p>764</p><p>765</p><p>766</p><p>767</p><p>768</p><p>769</p><p>770</p><p>771</p><p>772</p><p>773</p><p>774</p><p>775</p><p>776</p><p>777</p><p>778</p><p>779</p><p>780</p><p>781</p><p>782</p><p>783<span></span></p><p>784</p><p>785</p><p>786</p><p>787</p><p>788</p><p>789</p><p>790</p><p>791</p><p>792</p><p>793</p><p>794</p><p>795</p><p>796</p><p>797</p><p>798</p><p>799</p><p>800</p><p>801</p><p>802</p><p>803</p><p>804</p><p>805</p><p>806</p><p>807</p><p>808</p><p>809</p><p>810</p><p>811</p><p>812</p><p>813</p><p>814</p><p>815</p><p>816</p><p>817</p><p>818</p><p>819</p><p>820</p><p>821</p><p>822</p><p>823</p><p>824</p><p>825</p><p>826</p><p>827</p><p>828</p><p>829</p><p>830</p><p>831</p><p>832</p><p>833</p><p>834</p><p>835</p><p>836</p><p>837</p><p>838</p><p>839</p><p>840</p><p>841</p><p>842</p><p>843</p><p>844</p><p>845</p><p>846</p><p>847</p><p>848</p><p>849</p><p>850</p><p>851</p><p>852</p><p>853</p><p>854</p><p>855</p><p>856</p><p>857</p><p>858</p><p>859</p><p>860</p><p>861</p><p>862</p><p>863</p><p>864</p><p>865</p><p>866</p><p>867</p><p>868</p><p>869</p><p>870</p><p>871</p><p>872</p><p>873</p><p>874</p><p>875</p><p>876</p><p>877</p><p>878</p><p>879</p><p>880</p><p>881</p><p>882</p><p>883</p><p>884</p><p>885</p><p>886</p><p>887</p><p>888<span></span></p><p>889</p><p>890</p><p>891</p><p>892</p><p>893</p><p>894</p><p>895</p><p>896</p><p>897</p><p>898</p><p>899</p><p>900</p><p>901</p><p>902</p><p>903</p><p>904</p><p>905</p><p>906</p><p>907</p><p>908</p><p>909</p><p>910</p><p>911<span></span></p><p>912</p><p>913</p><p>914</p><p>915</p><p>916</p><p>917</p><p>918</p><p>919</p><p>920</p><p>921</p><p>922</p><p>923</p><p>924</p><p>925</p><p>926</p><p>927</p><p>928</p><p>929</p><p>930</p><p>931</p><p>932</p><p>933</p><p>934</p><p>935</p><p>936</p><p>937</p><p>938</p><p>939</p><p>940</p><p>941<span></span></p><p>942</p><p>943</p><p>944</p><p>945</p><p>946</p><p>947</p><p>948</p><p>949</p><p>950</p><p>951</p><p>952</p><p>953</p><p>954</p><p>955</p><p>956</p><p>957</p><p>958</p><p>959</p><p>960</p><p>961</p><p>962</p><p>963</p><p>964</p><p>965</p><p>966<span></span></p><p>967</p><p>968</p><p>969</p><p>970</p><p>971</p><p>972</p><p>973</p><p>974</p><p>975</p><p>976</p><p>977</p><p>978</p><p>979</p><p>980</p><p>981</p><p>982</p><p>983</p><p>984</p><p>985</p><p>986</p><p>987</p><p>988</p><p>989</p><p>990</p><p>991</p><p>992</p><p>993</p><p>994</p><p>995<span></span></p><p>996</p><p>997</p><p>998</p><p>999</p><p>1000</p></div><div><div><div><p><span>Copyright 2016 The Kubernetes Authors.</span></p></div></div><div><div><p><span>Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);</span></p></div></div><div><div><p><span>you may not use this file except in compliance with the License.</span></p></div></div><div><div><p><span>You may obtain a copy of the License at</span></p></div></div><div><div><p><span>    http://www.apache.org/licenses/LICENSE-2.0</span></p></div></div><div><div><p><span>Unless required by applicable law or agreed to in writing, software</span></p></div></div><div><div><p><span>distributed under the License is distributed on an &#34;AS IS&#34; BASIS,</span></p></div></div><div><div><p><span>WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></p></div></div><div><div><p><span>See the License for the specific language governing permissions and</span></p></div></div><div><div><p><span>limitations under the License.</span></p></div></div><div><div><p>	utilfeature <span>&#34;k8s.io/apiserver/pkg/util/feature&#34;</span></p></div></div><div><div><p><span>&#34;k8s.io/kubernetes/pkg/features&#34;</span></p></div></div><div><div><p><span>&#34;k8s.io/kubernetes/pkg/util/slice&#34;</span></p></div></div><div><div><p>	storage <span>&#34;k8s.io/api/storage/v1&#34;</span></p></div></div><div><div><p>	apierrors <span>&#34;k8s.io/apimachinery/pkg/api/errors&#34;</span></p></div></div><div><div><p><span>&#34;k8s.io/apimachinery/pkg/api/resource&#34;</span></p></div></div><div><div><p>	metav1 <span>&#34;k8s.io/apimachinery/pkg/apis/meta/v1&#34;</span></p></div></div><div><div><p><span>&#34;k8s.io/apimachinery/pkg/util/sets&#34;</span></p></div></div><div><div><p>	clientset <span>&#34;k8s.io/client-go/kubernetes&#34;</span></p></div></div><div><div><p><span>&#34;k8s.io/client-go/kubernetes/scheme&#34;</span></p></div></div><div><div><p>	corelisters <span>&#34;k8s.io/client-go/listers/core/v1&#34;</span></p></div></div><div><div><p>	storagelisters <span>&#34;k8s.io/client-go/listers/storage/v1&#34;</span></p></div></div><div><div><p><span>&#34;k8s.io/client-go/tools/cache&#34;</span></p></div></div><div><div><p><span>&#34;k8s.io/client-go/tools/record&#34;</span></p></div></div><div><div><p>	ref <span>&#34;k8s.io/client-go/tools/reference&#34;</span></p></div></div><div><div><p><span>&#34;k8s.io/client-go/util/workqueue&#34;</span></p></div></div><div><div><p>	volerr <span>&#34;k8s.io/cloud-provider/volume/errors&#34;</span></p></div></div><div><div><p>	storagehelpers <span>&#34;k8s.io/component-helpers/storage/volume&#34;</span></p></div></div><div><div><p><span>&#34;k8s.io/kubernetes/pkg/controller/volume/common&#34;</span></p></div></div><div><div><p><span>&#34;k8s.io/kubernetes/pkg/controller/volume/events&#34;</span></p></div></div><div><div><p><span>&#34;k8s.io/kubernetes/pkg/controller/volume/persistentvolume/metrics&#34;</span></p></div></div><div><div><p><span>&#34;k8s.io/kubernetes/pkg/util/goroutinemap&#34;</span></p></div></div><div><div><p><span>&#34;k8s.io/kubernetes/pkg/util/goroutinemap/exponentialbackoff&#34;</span></p></div></div><div><div><p>	vol <span>&#34;k8s.io/kubernetes/pkg/volume&#34;</span></p></div></div><div><div><p><span>&#34;k8s.io/kubernetes/pkg/volume/util&#34;</span></p></div></div><div><div><p><span>&#34;k8s.io/kubernetes/pkg/volume/util/recyclerclient&#34;</span></p></div></div><div><div><p>	volumetypes <span>&#34;k8s.io/kubernetes/pkg/volume/util/types&#34;</span></p></div></div><div><div><p><span>// ==================================================================</span></p></div></div><div><div><p><span>// PLEASE DO NOT ATTEMPT TO SIMPLIFY THIS CODE.</span></p></div></div><div><div><p><span>// KEEP THE SPACE SHUTTLE FLYING.</span></p></div></div><div><div><p><span>// ==================================================================</span></p></div></div><div><div><p><span>// This controller is intentionally written in a very verbose style. You will</span></p></div></div><div><div><p><span>// 1. Every &#39;if&#39; statement has a matching &#39;else&#39; (exception: simple error</span></p></div></div><div><div><p><span>//    checks for a client API call)</span></p></div></div><div><div><p><span>// 2. Things that may seem obvious are commented explicitly</span></p></div></div><div><div><p><span>// We call this style &#39;space shuttle style&#39;. Space shuttle style is meant to</span></p></div></div><div><div><p><span>// ensure that every branch and condition is considered and accounted for -</span></p></div></div><div><div><p><span>// the same way code is written at NASA for applications like the space</span></p></div></div><div><div><p><span>// Originally, the work of this controller was split amongst three</span></p></div></div><div><div><p><span>// controllers. This controller is the result a large effort to simplify the</span></p></div></div><div><div><p><span>// PV subsystem. During that effort, it became clear that we needed to ensure</span></p></div></div><div><div><p><span>// that every single condition was handled and accounted for in the code, even</span></p></div></div><div><div><p><span>// if it resulted in no-op code branches.</span></p></div></div><div><div><p><span>// As a result, the controller code may seem overly verbose, commented, and</span></p></div></div><div><div><p><span>// &#39;branchy&#39;. However, a large amount of business knowledge and context is</span></p></div></div><div><div><p><span>// recorded here in order to ensure that future maintainers can correctly</span></p></div></div><div><div><p><span>// reason through the complexities of the binding behavior. For that reason,</span></p></div></div><div><div><p><span>// changes to this file should preserve and add to the space shuttle style.</span></p></div></div><div><div><p><span>// ==================================================================</span></p></div></div><div><div><p><span>// PLEASE DO NOT ATTEMPT TO SIMPLIFY THIS CODE.</span></p></div></div><div><div><p><span>// KEEP THE SPACE SHUTTLE FLYING.</span></p></div></div><div><div><p><span>// ==================================================================</span></p></div></div><div><div><p><span>// The fundamental key to this design is the bi-directional &#34;pointer&#34; between</span></p></div></div><div><div><p><span>// PersistentVolumes (PVs) and PersistentVolumeClaims (PVCs), which is</span></p></div></div><div><div><p><span>// represented here as pvc.Spec.VolumeName and pv.Spec.ClaimRef. The bi-</span></p></div></div><div><div><p><span>// directionality is complicated to manage in a transactionless system, but</span></p></div></div><div><div><p><span>// without it we can&#39;t ensure sane behavior in the face of different forms of</span></p></div></div><div><div><p><span>// trouble. For example, a rogue HA controller instance could end up racing</span></p></div></div><div><div><p><span>// and making multiple bindings that are indistinguishable, resulting in</span></p></div></div><div><div><p><span>// This controller is designed to work in active-passive high availability</span></p></div></div><div><div><p><span>// mode. It *could* work also in active-active HA mode, all the object</span></p></div></div><div><div><p><span>// transitions are designed to cope with this, however performance could be</span></p></div></div><div><div><p><span>// lower as these two active controllers will step on each other toes</span></p></div></div><div><div><p><span>// This controller supports pre-bound (by the creator) objects in both</span></p></div></div><div><div><p><span>// directions: a PVC that wants a specific PV or a PV that is reserved for a</span></p></div></div><div><div><p><span>// The binding is two-step process. PV.Spec.ClaimRef is modified first and</span></p></div></div><div><div><p><span>// PVC.Spec.VolumeName second. At any point of this transaction, the PV or PVC</span></p></div></div><div><div><p><span>// can be modified by user or other controller or completely deleted. Also,</span></p></div></div><div><div><p><span>// two (or more) controllers may try to bind different volumes to different</span></p></div></div><div><div><p><span>// claims at the same time. The controller must recover from any conflicts</span></p></div></div><div><div><p><span>// that may arise from these conditions.</span></p></div></div><div><div><p><span>// Number of retries when we create a PV object for a provisioned volume.</span></p></div></div><div><div><p><span>const</span> <span>createProvisionedPVRetryCount</span> <span>=</span> <span>5</span></p></div></div><div><div><p><span>// Interval between retries when we create a PV object for a provisioned volume.</span></p></div></div><div><div><p><span>const</span> <span>createProvisionedPVInterval</span> <span>=</span> <span>10</span> <span>*</span> <span>time</span>.<span>Second</span></p></div></div><div><div><p><span>// CSINameTranslator can get the CSI Driver name based on the in-tree plugin name</span></p></div></div><div><div><p><span>type</span> <span>CSINameTranslator</span> <span>interface</span> {</p></div></div><div><div><p><span>GetCSINameFromInTreeName</span>(<span>pluginName</span> <span>string</span>) (<span>string</span>, <span>error</span>)</p></div></div><div><div><p><span>// CSIMigratedPluginManager keeps track of CSI migration status of a plugin</span></p></div></div><div><div><p><span>type</span> <span>CSIMigratedPluginManager</span> <span>interface</span> {</p></div></div><div><div><p><span>IsMigrationEnabledForPlugin</span>(<span>pluginName</span> <span>string</span>) <span>bool</span></p></div></div><div><div><p><span>// PersistentVolumeController is a controller that synchronizes</span></p></div></div><div><div><p><span>// PersistentVolumeClaims and PersistentVolumes. It starts two</span></p></div></div><div><div><p><span>// cache.Controllers that watch PersistentVolume and PersistentVolumeClaim</span></p></div></div><div><div><p><span>type</span> <span>PersistentVolumeController</span> <span>struct</span> {</p></div></div><div><div><p><span>volumeLister</span>       corelisters.<span>PersistentVolumeLister</span></p></div></div><div><div><p><span>volumeListerSynced</span> cache.<span>InformerSynced</span></p></div></div><div><div><p><span>claimLister</span>        corelisters.<span>PersistentVolumeClaimLister</span></p></div></div><div><div><p><span>claimListerSynced</span>  cache.<span>InformerSynced</span></p></div></div><div><div><p><span>classLister</span>        storagelisters.<span>StorageClassLister</span></p></div></div><div><div><p><span>classListerSynced</span>  cache.<span>InformerSynced</span></p></div></div><div><div><p><span>podLister</span>          corelisters.<span>PodLister</span></p></div></div><div><div><p><span>podListerSynced</span>    cache.<span>InformerSynced</span></p></div></div><div><div><p><span>NodeLister</span>         corelisters.<span>NodeLister</span></p></div></div><div><div><p><span>NodeListerSynced</span>   cache.<span>InformerSynced</span></p></div></div><div><div><p><span>kubeClient</span>                clientset.<span>Interface</span></p></div></div><div><div><p><span>eventBroadcaster</span>          record.<span>EventBroadcaster</span></p></div></div><div><div><p><span>eventRecorder</span>             record.<span>EventRecorder</span></p></div></div><div><div><p><span>volumePluginMgr</span>           vol.<span>VolumePluginMgr</span></p></div></div><div><div><p><span>enableDynamicProvisioning</span> <span>bool</span></p></div></div><div><div><p><span>resyncPeriod</span>              time.<span>Duration</span></p></div></div><div><div><p><span>// Cache of the last known version of volumes and claims. This cache is</span></p></div></div><div><div><p><span>// thread safe as long as the volumes/claims there are not modified, they</span></p></div></div><div><div><p><span>// must be cloned before any modification. These caches get updated both by</span></p></div></div><div><div><p><span>// &#34;xxx added/updated/deleted&#34; events from etcd and by the controller when</span></p></div></div><div><div><p><span>// it saves newer version to etcd.</span></p></div></div><div><div><p><span>// Why local cache: binding a volume to a claim generates 4 events, roughly</span></p></div></div><div><div><p><span>// in this order (depends on goroutine ordering):</span></p></div></div><div><div><p><span>// - volume.Status update</span></p></div></div><div><div><p><span>// With these caches, the controller can check that it has already saved</span></p></div></div><div><div><p><span>// volume.Status and claim.Spec+Status and does not need to do anything</span></p></div></div><div><div><p><span>// when e.g. volume.Spec update event arrives before all the other events.</span></p></div></div><div><div><p><span>// Without this cache, it would see the old version of volume.Status and</span></p></div></div><div><div><p><span>// claim in the informers (it has not been updated from API server events</span></p></div></div><div><div><p><span>// yet) and it would try to fix these objects to be bound together.</span></p></div></div><div><div><p><span>// Any write to API server would fail with version conflict - these objects</span></p></div></div><div><div><p><span>// have been already written.</span></p></div></div><div><div><p><span>volumes</span> <span>persistentVolumeOrderedIndex</span></p></div></div><div><div><p><span>// Work queues of claims and volumes to process. Every queue should have</span></p></div></div><div><div><p><span>// exactly one worker thread, especially syncClaim() is not reentrant.</span></p></div></div><div><div><p><span>// Two syncClaims could bind two different claims to the same volume or one</span></p></div></div><div><div><p><span>// claim to two volumes. The controller would recover from this (due to</span></p></div></div><div><div><p><span>// version errors in API server and other checks in this controller),</span></p></div></div><div><div><p><span>// however overall speed of multi-worker controller would be lower than if</span></p></div></div><div><div><p><span>// it runs single thread only.</span></p></div></div><div><div><p><span>claimQueue</span>  <span>*</span>workqueue.<span>Typed</span>[<span>string</span>]</p></div></div><div><div><p><span>volumeQueue</span> <span>*</span>workqueue.<span>Typed</span>[<span>string</span>]</p></div></div><div><div><p><span>// Map of scheduled/running operations.</span></p></div></div><div><div><p><span>runningOperations</span> goroutinemap.<span>GoRoutineMap</span></p></div></div><div><div><p><span>// For testing only: hook to call before an asynchronous operation starts.</span></p></div></div><div><div><p><span>// Not used when set to nil.</span></p></div></div><div><div><p><span>preOperationHook</span> <span>func</span>(<span>operationName</span> <span>string</span>)</p></div></div><div><div><p><span>createProvisionedPVRetryCount</span> <span>int</span></p></div></div><div><div><p><span>createProvisionedPVInterval</span>   time.<span>Duration</span></p></div></div><div><div><p><span>// operationTimestamps caches start timestamp of operations</span></p></div></div><div><div><p><span>// (currently provision + binding/deletion) for metric recording.</span></p></div></div><div><div><p><span>// Detailed lifecycle/key for each operation</span></p></div></div><div><div><p><span>// 1. provision + binding</span></p></div></div><div><div><p><span>//     start time: user has NOT provide any volume ref in the claim AND</span></p></div></div><div><div><p><span>//                 there is no existing volume found for the claim,</span></p></div></div><div><div><p><span>//                 &#34;provisionClaim&#34; is called with a valid plugin/external provisioner</span></p></div></div><div><div><p><span>//     end time:   after a volume has been provisioned and bound to the claim successfully</span></p></div></div><div><div><p><span>//                 the corresponding timestamp entry will be deleted from cache</span></p></div></div><div><div><p><span>//     abort:      claim has not been bound to a volume yet but a claim deleted event</span></p></div></div><div><div><p><span>//                 has been received from API server</span></p></div></div><div><div><p><span>//     start time: when &#34;reclaimVolume&#34; process a volume with reclaim policy</span></p></div></div><div><div><p><span>//                 set to be &#34;PersistentVolumeReclaimDelete&#34;</span></p></div></div><div><div><p><span>//     end time:   after a volume deleted event has been received from API server</span></p></div></div><div><div><p><span>//                 the corresponding timestamp entry will be deleted from cache</span></p></div></div><div><div><p><span>operationTimestamps</span> metrics.<span>OperationStartTimeCache</span></p></div></div><div><div><p><span>translator</span>               <span>CSINameTranslator</span></p></div></div><div><div><p><span>csiMigratedPluginManager</span> <span>CSIMigratedPluginManager</span></p></div></div><div><div><p><span>// syncClaim is the main controller method to decide what to do with a claim.</span></p></div></div><div><div><p><span>// It&#39;s invoked by appropriate cache.Controller callbacks when a claim is</span></p></div></div><div><div><p><span>// created, updated or periodically synced. We do not differentiate between</span></p></div></div><div><div><p><span>// For easier readability, it was split into syncUnboundClaim and syncBoundClaim</span></p></div></div><div><div><p><span>func</span> (<span>ctrl</span> <span>*</span><span>PersistentVolumeController</span>) <span>syncClaim</span>(<span>ctx</span> context.<span>Context</span>, <span>claim</span> <span>*</span>v1.<span>PersistentVolumeClaim</span>) <span>error</span> {</p></div></div><div><div><p><span>logger</span> <span>:=</span> <span>klog</span>.<span>FromContext</span>(<span>ctx</span>)</p></div></div><div><div><p><span>logger</span>.<span>V</span>(<span>4</span>).<span>Info</span>(<span>&#34;Synchronizing PersistentVolumeClaim&#34;</span>, <span>&#34;PVC&#34;</span>, <span>klog</span>.<span>KObj</span>(<span>claim</span>), <span>&#34;claimStatus&#34;</span>, <span>getClaimStatusForLogging</span>(<span>claim</span>))</p></div></div><div><div><p><span>// Set correct &#34;migrated-to&#34; annotations on PVC and update in API server if</span></p></div></div><div><div><p><span>newClaim</span>, <span>err</span> <span>:=</span> <span>ctrl</span>.<span>updateClaimMigrationAnnotations</span>(<span>ctx</span>, <span>claim</span>)</p></div></div><div><div><p><span>// Nothing was saved; we will fall back into the same</span></p></div></div><div><div><p><span>// condition in the next call to this method</span></p></div></div><div><div><p><span>if</span> <span>!</span><span>metav1</span>.<span>HasAnnotation</span>(<span>claim</span>.<span>ObjectMeta</span>, <span>storagehelpers</span>.<span>AnnBindCompleted</span>) {</p></div></div><div><div><p><span>return</span> <span>ctrl</span>.<span>syncUnboundClaim</span>(<span>ctx</span>, <span>claim</span>)</p></div></div><div><div><p><span>return</span> <span>ctrl</span>.<span>syncBoundClaim</span>(<span>ctx</span>, <span>claim</span>)</p></div></div><div><div><p><span>// checkVolumeSatisfyClaim checks if the volume requested by the claim satisfies the requirements of the claim</span></p></div></div><div><div><p><span>func</span> <span>checkVolumeSatisfyClaim</span>(<span>volume</span> <span>*</span>v1.<span>PersistentVolume</span>, <span>claim</span> <span>*</span>v1.<span>PersistentVolumeClaim</span>) <span>error</span> {</p></div></div><div><div><p><span>requestedQty</span> <span>:=</span> <span>claim</span>.<span>Spec</span>.<span>Resources</span>.<span>Requests</span>[<span>v1</span>.<span>ResourceName</span>(<span>v1</span>.<span>ResourceStorage</span>)]</p></div></div><div><div><p><span>requestedSize</span> <span>:=</span> <span>requestedQty</span>.<span>Value</span>()</p></div></div><div><div><p><span>// check if PV&#39;s DeletionTimeStamp is set, if so, return error.</span></p></div></div><div><div><p><span>if</span> <span>volume</span>.<span>ObjectMeta</span>.<span>DeletionTimestamp</span> <span>!=</span> <span>nil</span> {</p></div></div><div><div><p><span>return</span> <span>fmt</span>.<span>Errorf</span>(<span>&#34;the volume is marked for deletion %q&#34;</span>, <span>volume</span>.<span>Name</span>)</p></div></div><div><div><p><span>volumeQty</span> <span>:=</span> <span>volume</span>.<span>Spec</span>.<span>Capacity</span>[<span>v1</span>.<span>ResourceStorage</span>]</p></div></div><div><div><p><span>volumeSize</span> <span>:=</span> <span>volumeQty</span>.<span>Value</span>()</p></div></div><div><div><p><span>if</span> <span>volumeSize</span> <span>&lt;</span> <span>requestedSize</span> {</p></div></div><div><div><p><span>return</span> <span>fmt</span>.<span>Errorf</span>(<span>&#34;requested PV is too small&#34;</span>)</p></div></div><div><div><p><span>requestedClass</span> <span>:=</span> <span>storagehelpers</span>.<span>GetPersistentVolumeClaimClass</span>(<span>claim</span>)</p></div></div><div><div><p><span>if</span> <span>storagehelpers</span>.<span>GetPersistentVolumeClass</span>(<span>volume</span>) <span>!=</span> <span>requestedClass</span> {</p></div></div><div><div><p><span>return</span> <span>fmt</span>.<span>Errorf</span>(<span>&#34;storageClassName does not match&#34;</span>)</p></div></div><div><div><p><span>if</span> <span>utilfeature</span>.<span>DefaultFeatureGate</span>.<span>Enabled</span>(<span>features</span>.<span>VolumeAttributesClass</span>) {</p></div></div><div><div><p><span>requestedVAC</span> <span>:=</span> <span>ptr</span>.<span>Deref</span>(<span>claim</span>.<span>Spec</span>.<span>VolumeAttributesClassName</span>, <span>&#34;&#34;</span>)</p></div></div><div><div><p><span>volumeVAC</span> <span>:=</span> <span>ptr</span>.<span>Deref</span>(<span>volume</span>.<span>Spec</span>.<span>VolumeAttributesClassName</span>, <span>&#34;&#34;</span>)</p></div></div><div><div><p><span>if</span> <span>requestedVAC</span> <span>!=</span> <span>volumeVAC</span> {</p></div></div><div><div><p><span>return</span> <span>fmt</span>.<span>Errorf</span>(<span>&#34;volumeAttributesClassName does not match&#34;</span>)</p></div></div><div><div><p><span>requestedVAC</span> <span>:=</span> <span>ptr</span>.<span>Deref</span>(<span>claim</span>.<span>Spec</span>.<span>VolumeAttributesClassName</span>, <span>&#34;&#34;</span>)</p></div></div><div><div><p><span>volumeVAC</span> <span>:=</span> <span>ptr</span>.<span>Deref</span>(<span>volume</span>.<span>Spec</span>.<span>VolumeAttributesClassName</span>, <span>&#34;&#34;</span>)</p></div></div><div><div><p><span>if</span> <span>requestedVAC</span> <span>!=</span> <span>&#34;&#34;</span> <span>||</span> <span>volumeVAC</span> <span>!=</span> <span>&#34;&#34;</span> {</p></div></div><div><div><p><span>return</span> <span>fmt</span>.<span>Errorf</span>(<span>&#34;volumeAttributesClassName is not supported when the feature-gate VolumeAttributesClass is disabled&#34;</span>)</p></div></div><div><div><p><span>if</span> <span>storagehelpers</span>.<span>CheckVolumeModeMismatches</span>(<span>&amp;</span><span>claim</span>.<span>Spec</span>, <span>&amp;</span><span>volume</span>.<span>Spec</span>) {</p></div></div><div><div><p><span>return</span> <span>fmt</span>.<span>Errorf</span>(<span>&#34;incompatible volumeMode&#34;</span>)</p></div></div><div><div><p><span>if</span> <span>!</span><span>storagehelpers</span>.<span>CheckAccessModes</span>(<span>claim</span>, <span>volume</span>) {</p></div></div><div><div><p><span>return</span> <span>fmt</span>.<span>Errorf</span>(<span>&#34;incompatible accessMode&#34;</span>)</p></div></div><div><div><p><span>// emitEventForUnboundDelayBindingClaim generates informative event for claim</span></p></div></div><div><div><p><span>// if it&#39;s in delay binding mode and not bound yet.</span></p></div></div><div><div><p><span>func</span> (<span>ctrl</span> <span>*</span><span>PersistentVolumeController</span>) <span>emitEventForUnboundDelayBindingClaim</span>(<span>claim</span> <span>*</span>v1.<span>PersistentVolumeClaim</span>) <span>error</span> {</p></div></div><div><div><p><span>reason</span> <span>:=</span> <span>events</span>.<span>WaitForFirstConsumer</span></p></div></div><div><div><p><span>message</span> <span>:=</span> <span>&#34;waiting for first consumer to be created before binding&#34;</span></p></div></div><div><div><p><span>podNames</span>, <span>err</span> <span>:=</span> <span>ctrl</span>.<span>findNonScheduledPodsByPVC</span>(<span>claim</span>)</p></div></div><div><div><p><span>reason</span> <span>=</span> <span>events</span>.<span>WaitForPodScheduled</span></p></div></div><div><div><p><span>// Although only one pod is taken into account in</span></p></div></div><div><div><p><span>// volume scheduling, more than one pods can reference</span></p></div></div><div><div><p><span>// the PVC at the same time. We can&#39;t know which pod is</span></p></div></div><div><div><p><span>// used in scheduling, all pods are included.</span></p></div></div><div><div><p><span>message</span> <span>=</span> <span>fmt</span>.<span>Sprintf</span>(<span>&#34;waiting for pods %s to be scheduled&#34;</span>, <span>strings</span>.<span>Join</span>(<span>podNames</span>, <span>&#34;,&#34;</span>))</p></div></div><div><div><p><span>message</span> <span>=</span> <span>fmt</span>.<span>Sprintf</span>(<span>&#34;waiting for pod %s to be scheduled&#34;</span>, <span>podNames</span>[<span>0</span>])</p></div></div><div><div><p><span>ctrl</span>.<span>eventRecorder</span>.<span>Event</span>(<span>claim</span>, <span>v1</span>.<span>EventTypeNormal</span>, <span>reason</span>, <span>message</span>)</p></div></div><div><div><p><span>// syncUnboundClaim is the main controller method to decide what to do with an</span></p></div></div><div><div><p><span>func</span> (<span>ctrl</span> <span>*</span><span>PersistentVolumeController</span>) <span>syncUnboundClaim</span>(<span>ctx</span> context.<span>Context</span>, <span>claim</span> <span>*</span>v1.<span>PersistentVolumeClaim</span>) <span>error</span> {</p></div></div><div><div><p><span>// This is a new PVC that has not completed binding</span></p></div></div><div><div><p><span>// OBSERVATION: pvc is &#34;Pending&#34;</span></p></div></div><div><div><p><span>logger</span> <span>:=</span> <span>klog</span>.<span>FromContext</span>(<span>ctx</span>)</p></div></div><div><div><p><span>if</span> <span>claim</span>.<span>Spec</span>.<span>VolumeName</span> <span>==</span> <span>&#34;&#34;</span> {</p></div></div><div><div><p><span>// User did not care which PV they get.</span></p></div></div><div><div><p><span>delayBinding</span>, <span>err</span> <span>:=</span> <span>storagehelpers</span>.<span>IsDelayBindingMode</span>(<span>claim</span>, <span>ctrl</span>.<span>classLister</span>)</p></div></div><div><div><p><span>volume</span>, <span>err</span> <span>:=</span> <span>ctrl</span>.<span>volumes</span>.<span>findBestMatchForClaim</span>(<span>claim</span>, <span>delayBinding</span>)</p></div></div><div><div><p><span>logger</span>.<span>V</span>(<span>2</span>).<span>Info</span>(<span>&#34;Synchronizing unbound PersistentVolumeClaim, Error finding PV for claim&#34;</span>, <span>&#34;PVC&#34;</span>, <span>klog</span>.<span>KObj</span>(<span>claim</span>), <span>&#34;err&#34;</span>, <span>err</span>)</p></div></div><div><div><p><span>return</span> <span>fmt</span>.<span>Errorf</span>(<span>&#34;error finding PV for claim %q: %w&#34;</span>, <span>claimToClaimKey</span>(<span>claim</span>), <span>err</span>)</p></div></div><div><div><p><span>logger</span>.<span>V</span>(<span>4</span>).<span>Info</span>(<span>&#34;Synchronizing unbound PersistentVolumeClaim, no volume found&#34;</span>, <span>&#34;PVC&#34;</span>, <span>klog</span>.<span>KObj</span>(<span>claim</span>))</p></div></div><div><div><p><span>// No PV could be found. Try to provision one if possible.</span></p></div></div><div><div><p><span>// OBSERVATION: pvc is &#34;Pending&#34;, will retry</span></p></div></div><div><div><p><span>logger</span>.<span>V</span>(<span>4</span>).<span>Info</span>(<span>&#34;Attempting to assign storage class to unbound PersistentVolumeClaim&#34;</span>, <span>&#34;PVC&#34;</span>, <span>klog</span>.<span>KObj</span>(<span>claim</span>))</p></div></div><div><div><p><span>updated</span>, <span>err</span> <span>:=</span> <span>ctrl</span>.<span>assignDefaultStorageClass</span>(<span>ctx</span>, <span>claim</span>)</p></div></div><div><div><p><span>metrics</span>.<span>RecordRetroactiveStorageClassMetric</span>(<span>false</span>)</p></div></div><div><div><p><span>return</span> <span>fmt</span>.<span>Errorf</span>(<span>&#34;can&#39;t update PersistentVolumeClaim[%q]: %w&#34;</span>, <span>claimToClaimKey</span>(<span>claim</span>), <span>err</span>)</p></div></div><div><div><p><span>logger</span>.<span>V</span>(<span>4</span>).<span>Info</span>(<span>&#34;PersistentVolumeClaim update successful, restarting claim sync&#34;</span>, <span>&#34;PVC&#34;</span>, <span>klog</span>.<span>KObj</span>(<span>claim</span>))</p></div></div><div><div><p><span>metrics</span>.<span>RecordRetroactiveStorageClassMetric</span>(<span>true</span>)</p></div></div><div><div><p><span>case</span> <span>delayBinding</span> <span>&amp;&amp;</span> <span>!</span><span>storagehelpers</span>.<span>IsDelayBindingProvisioning</span>(<span>claim</span>):</p></div></div><div><div><p><span>// Scheduler does not observe any pod using this claim.</span></p></div></div><div><div><p><span>if</span> <span>err</span> <span>=</span> <span>ctrl</span>.<span>emitEventForUnboundDelayBindingClaim</span>(<span>claim</span>); <span>err</span> <span>!=</span> <span>nil</span> {</p></div></div><div><div><p><span>case</span> <span>storagehelpers</span>.<span>GetPersistentVolumeClaimClass</span>(<span>claim</span>) <span>!=</span> <span>&#34;&#34;</span>:</p></div></div><div><div><p><span>// The provisionClaim function may start a new asynchronous operation to provision a volume,</span></p></div></div><div><div><p><span>// or the operation is already running. The claim will be updated in the asynchronous operation,</span></p></div></div><div><div><p><span>// so the branch should be returned directly and the bind operation is expected to continue in</span></p></div></div><div><div><p><span>if</span> <span>err</span> <span>=</span> <span>ctrl</span>.<span>provisionClaim</span>(<span>ctx</span>, <span>claim</span>); <span>err</span> <span>!=</span> <span>nil</span> {</p></div></div><div><div><p><span>ctrl</span>.<span>eventRecorder</span>.<span>Event</span>(<span>claim</span>, <span>v1</span>.<span>EventTypeNormal</span>, <span>events</span>.<span>FailedBinding</span>, <span>&#34;no persistent volumes available for this claim and no storage class is set&#34;</span>)</p></div></div><div><div><p><span>// Mark the claim as Pending and try to find a match in the next</span></p></div></div><div><div><p><span>if</span> <span>_</span>, <span>err</span> <span>=</span> <span>ctrl</span>.<span>updateClaimStatus</span>(<span>ctx</span>, <span>claim</span>, <span>v1</span>.<span>ClaimPending</span>, <span>nil</span>); <span>err</span> <span>!=</span> <span>nil</span> {</p></div></div><div><div><p><span>// Found a PV for this claim</span></p></div></div><div><div><p><span>// OBSERVATION: pvc is &#34;Pending&#34;, pv is &#34;Available&#34;</span></p></div></div><div><div><p><span>claimKey</span> <span>:=</span> <span>claimToClaimKey</span>(<span>claim</span>)</p></div></div><div><div><p><span>logger</span>.<span>V</span>(<span>4</span>).<span>Info</span>(<span>&#34;Synchronizing unbound PersistentVolumeClaim, volume found&#34;</span>, <span>&#34;PVC&#34;</span>, <span>klog</span>.<span>KObj</span>(<span>claim</span>), <span>&#34;volumeName&#34;</span>, <span>volume</span>.<span>Name</span>, <span>&#34;volumeStatus&#34;</span>, <span>getVolumeStatusForLogging</span>(<span>volume</span>))</p></div></div><div><div><p><span>if</span> <span>err</span> <span>=</span> <span>ctrl</span>.<span>bind</span>(<span>ctx</span>, <span>volume</span>, <span>claim</span>); <span>err</span> <span>!=</span> <span>nil</span> {</p></div></div><div><div><p><span>// On any error saving the volume or the claim, subsequent</span></p></div></div><div><div><p><span>// syncClaim will finish the binding.</span></p></div></div><div><div><p><span>// record count error for provision if exists</span></p></div></div><div><div><p><span>// timestamp entry will remain in cache until a success binding has happened</span></p></div></div><div><div><p><span>metrics</span>.<span>RecordMetric</span>(<span>claimKey</span>, <span>&amp;</span><span>ctrl</span>.<span>operationTimestamps</span>, <span>err</span>)</p></div></div><div><div><p><span>// OBSERVATION: claim is &#34;Bound&#34;, pv is &#34;Bound&#34;</span></p></div></div><div><div><p><span>// if exists a timestamp entry in cache, record end to end provision latency and clean up cache</span></p></div></div><div><div><p><span>// End of the provision + binding operation lifecycle, cache will be cleaned by &#34;RecordMetric&#34;</span></p></div></div><div><div><p><span>// [Unit test 12-1, 12-2, 12-4]</span></p></div></div><div><div><p><span>metrics</span>.<span>RecordMetric</span>(<span>claimKey</span>, <span>&amp;</span><span>ctrl</span>.<span>operationTimestamps</span>, <span>nil</span>)</p></div></div><div><div><p>	} <span>else</span> <span>/* pvc.Spec.VolumeName != nil */</span> {</p></div></div><div><div><p><span>// User asked for a specific PV.</span></p></div></div><div><div><p><span>logger</span>.<span>V</span>(<span>4</span>).<span>Info</span>(<span>&#34;Synchronizing unbound PersistentVolumeClaim, volume requested&#34;</span>, <span>&#34;PVC&#34;</span>, <span>klog</span>.<span>KObj</span>(<span>claim</span>), <span>&#34;volumeName&#34;</span>, <span>claim</span>.<span>Spec</span>.<span>VolumeName</span>)</p></div></div><div><div><p><span>obj</span>, <span>found</span>, <span>err</span> <span>:=</span> <span>ctrl</span>.<span>volumes</span>.<span>store</span>.<span>GetByKey</span>(<span>claim</span>.<span>Spec</span>.<span>VolumeName</span>)</p></div></div><div><div><p><span>// User asked for a PV that does not exist.</span></p></div></div><div><div><p><span>// OBSERVATION: pvc is &#34;Pending&#34;</span></p></div></div><div><div><p><span>logger</span>.<span>V</span>(<span>4</span>).<span>Info</span>(<span>&#34;Synchronizing unbound PersistentVolumeClaim， volume requested and not found, will try again next time&#34;</span>, <span>&#34;PVC&#34;</span>, <span>klog</span>.<span>KObj</span>(<span>claim</span>), <span>&#34;volumeName&#34;</span>, <span>claim</span>.<span>Spec</span>.<span>VolumeName</span>)</p></div></div><div><div><p><span>if</span> <span>_</span>, <span>err</span> <span>=</span> <span>ctrl</span>.<span>updateClaimStatus</span>(<span>ctx</span>, <span>claim</span>, <span>v1</span>.<span>ClaimPending</span>, <span>nil</span>); <span>err</span> <span>!=</span> <span>nil</span> {</p></div></div><div><div><p><span>volume</span>, <span>ok</span> <span>:=</span> <span>obj</span>.(<span>*</span>v1.<span>PersistentVolume</span>)</p></div></div><div><div><p><span>return</span> <span>fmt</span>.<span>Errorf</span>(<span>&#34;cannot convert object from volume cache to volume %q!?: %+v&#34;</span>, <span>claim</span>.<span>Spec</span>.<span>VolumeName</span>, <span>obj</span>)</p></div></div><div><div><p><span>logger</span>.<span>V</span>(<span>4</span>).<span>Info</span>(<span>&#34;Synchronizing unbound PersistentVolumeClaim, volume requested and found&#34;</span>, <span>&#34;PVC&#34;</span>, <span>klog</span>.<span>KObj</span>(<span>claim</span>), <span>&#34;volumeName&#34;</span>, <span>claim</span>.<span>Spec</span>.<span>VolumeName</span>, <span>&#34;volumeStatus&#34;</span>, <span>getVolumeStatusForLogging</span>(<span>volume</span>))</p></div></div><div><div><p><span>if</span> <span>volume</span>.<span>Spec</span>.<span>ClaimRef</span> <span>==</span> <span>nil</span> {</p></div></div><div><div><p><span>// User asked for a PV that is not claimed</span></p></div></div><div><div><p><span>// OBSERVATION: pvc is &#34;Pending&#34;, pv is &#34;Available&#34;</span></p></div></div><div><div><p><span>logger</span>.<span>V</span>(<span>4</span>).<span>Info</span>(<span>&#34;Synchronizing unbound PersistentVolumeClaim, volume is unbound, binding&#34;</span>, <span>&#34;PVC&#34;</span>, <span>klog</span>.<span>KObj</span>(<span>claim</span>))</p></div></div><div><div><p><span>if</span> <span>err</span> <span>=</span> <span>checkVolumeSatisfyClaim</span>(<span>volume</span>, <span>claim</span>); <span>err</span> <span>!=</span> <span>nil</span> {</p></div></div><div><div><p><span>logger</span>.<span>V</span>(<span>4</span>).<span>Info</span>(<span>&#34;Can&#39;t bind the claim to volume&#34;</span>, <span>&#34;volumeName&#34;</span>, <span>volume</span>.<span>Name</span>, <span>&#34;err&#34;</span>, <span>err</span>)</p></div></div><div><div><p><span>msg</span> <span>:=</span> <span>fmt</span>.<span>Sprintf</span>(<span>&#34;Cannot bind to requested volume %q: %s&#34;</span>, <span>volume</span>.<span>Name</span>, <span>err</span>)</p></div></div><div><div><p><span>ctrl</span>.<span>eventRecorder</span>.<span>Event</span>(<span>claim</span>, <span>v1</span>.<span>EventTypeWarning</span>, <span>events</span>.<span>VolumeMismatch</span>, <span>msg</span>)</p></div></div><div><div><p><span>// volume does not satisfy the requirements of the claim</span></p></div></div><div><div><p><span>if</span> <span>_</span>, <span>err</span> <span>=</span> <span>ctrl</span>.<span>updateClaimStatus</span>(<span>ctx</span>, <span>claim</span>, <span>v1</span>.<span>ClaimPending</span>, <span>nil</span>); <span>err</span> <span>!=</span> <span>nil</span> {</p></div></div><div><div><p>				} <span>else</span> <span>if</span> <span>err</span> <span>=</span> <span>ctrl</span>.<span>bind</span>(<span>ctx</span>, <span>volume</span>, <span>claim</span>); <span>err</span> <span>!=</span> <span>nil</span> {</p></div></div><div><div><p><span>// On any error saving the volume or the claim, subsequent</span></p></div></div><div><div><p><span>// syncClaim will finish the binding.</span></p></div></div><div><div><p><span>// OBSERVATION: pvc is &#34;Bound&#34;, pv is &#34;Bound&#34;</span></p></div></div><div><div><p>			} <span>else</span> <span>if</span> <span>storagehelpers</span>.<span>IsVolumeBoundToClaim</span>(<span>volume</span>, <span>claim</span>) {</p></div></div><div><div><p><span>// User asked for a PV that is claimed by this PVC</span></p></div></div><div><div><p><span>// OBSERVATION: pvc is &#34;Pending&#34;, pv is &#34;Bound&#34;</span></p></div></div><div><div><p><span>logger</span>.<span>V</span>(<span>4</span>).<span>Info</span>(<span>&#34;Synchronizing unbound PersistentVolumeClaim, volume already bound, finishing the binding&#34;</span>, <span>&#34;PVC&#34;</span>, <span>klog</span>.<span>KObj</span>(<span>claim</span>))</p></div></div><div><div><p><span>// Finish the volume binding by adding claim UID.</span></p></div></div><div><div><p><span>if</span> <span>err</span> <span>=</span> <span>ctrl</span>.<span>bind</span>(<span>ctx</span>, <span>volume</span>, <span>claim</span>); <span>err</span> <span>!=</span> <span>nil</span> {</p></div></div><div><div><p><span>// OBSERVATION: pvc is &#34;Bound&#34;, pv is &#34;Bound&#34;</span></p></div></div><div><div><p><span>// User asked for a PV that is claimed by someone else</span></p></div></div><div><div><p><span>// OBSERVATION: pvc is &#34;Pending&#34;, pv is &#34;Bound&#34;</span></p></div></div><div><div><p><span>if</span> <span>!</span><span>metav1</span>.<span>HasAnnotation</span>(<span>claim</span>.<span>ObjectMeta</span>, <span>storagehelpers</span>.<span>AnnBoundByController</span>) {</p></div></div><div><div><p><span>logger</span>.<span>V</span>(<span>4</span>).<span>Info</span>(<span>&#34;Synchronizing unbound PersistentVolumeClaim, volume already bound to different claim by user, will retry later&#34;</span>, <span>&#34;PVC&#34;</span>, <span>klog</span>.<span>KObj</span>(<span>claim</span>))</p></div></div><div><div><p><span>claimMsg</span> <span>:=</span> <span>fmt</span>.<span>Sprintf</span>(<span>&#34;volume %q already bound to a different claim.&#34;</span>, <span>volume</span>.<span>Name</span>)</p></div></div><div><div><p><span>ctrl</span>.<span>eventRecorder</span>.<span>Event</span>(<span>claim</span>, <span>v1</span>.<span>EventTypeWarning</span>, <span>events</span>.<span>FailedBinding</span>, <span>claimMsg</span>)</p></div></div><div><div><p><span>// User asked for a specific PV, retry later</span></p></div></div><div><div><p><span>if</span> <span>_</span>, <span>err</span> <span>=</span> <span>ctrl</span>.<span>updateClaimStatus</span>(<span>ctx</span>, <span>claim</span>, <span>v1</span>.<span>ClaimPending</span>, <span>nil</span>); <span>err</span> <span>!=</span> <span>nil</span> {</p></div></div><div><div><p><span>// This should never happen because someone had to remove</span></p></div></div><div><div><p><span>// AnnBindCompleted annotation on the claim.</span></p></div></div><div><div><p><span>logger</span>.<span>V</span>(<span>4</span>).<span>Info</span>(<span>&#34;Synchronizing unbound PersistentVolumeClaim, volume already bound to different claim by controller, THIS SHOULD NEVER HAPPEN&#34;</span>, <span>&#34;PVC&#34;</span>, <span>klog</span>.<span>KObj</span>(<span>claim</span>), <span>&#34;boundClaim&#34;</span>, <span>klog</span>.<span>KRef</span>(<span>volume</span>.<span>Spec</span>.<span>ClaimRef</span>.<span>Namespace</span>, <span>volume</span>.<span>Spec</span>.<span>ClaimRef</span>.<span>Name</span>))</p></div></div><div><div><p><span>claimMsg</span> <span>:=</span> <span>fmt</span>.<span>Sprintf</span>(<span>&#34;volume %q already bound to a different claim.&#34;</span>, <span>volume</span>.<span>Name</span>)</p></div></div><div><div><p><span>ctrl</span>.<span>eventRecorder</span>.<span>Event</span>(<span>claim</span>, <span>v1</span>.<span>EventTypeWarning</span>, <span>events</span>.<span>FailedBinding</span>, <span>claimMsg</span>)</p></div></div><div><div><p><span>return</span> <span>fmt</span>.<span>Errorf</span>(<span>&#34;invalid binding of claim %q to volume %q: volume already claimed by %q&#34;</span>, <span>claimToClaimKey</span>(<span>claim</span>), <span>claim</span>.<span>Spec</span>.<span>VolumeName</span>, <span>claimrefToClaimKey</span>(<span>volume</span>.<span>Spec</span>.<span>ClaimRef</span>))</p></div></div><div><div><p><span>// syncBoundClaim is the main controller method to decide what to do with a</span></p></div></div><div><div><p><span>func</span> (<span>ctrl</span> <span>*</span><span>PersistentVolumeController</span>) <span>syncBoundClaim</span>(<span>ctx</span> context.<span>Context</span>, <span>claim</span> <span>*</span>v1.<span>PersistentVolumeClaim</span>) <span>error</span> {</p></div></div><div><div><p><span>// HasAnnotation(pvc, storagehelpers.AnnBindCompleted)</span></p></div></div><div><div><p><span>// This PVC has previously been bound</span></p></div></div><div><div><p><span>// OBSERVATION: pvc is not &#34;Pending&#34;</span></p></div></div><div><div><p><span>logger</span> <span>:=</span> <span>klog</span>.<span>FromContext</span>(<span>ctx</span>)</p></div></div><div><div><p><span>if</span> <span>claim</span>.<span>Spec</span>.<span>VolumeName</span> <span>==</span> <span>&#34;&#34;</span> {</p></div></div><div><div><p><span>// Claim was bound before but not any more.</span></p></div></div><div><div><p><span>if</span> <span>_</span>, <span>err</span> <span>:=</span> <span>ctrl</span>.<span>updateClaimStatusWithEvent</span>(<span>ctx</span>, <span>claim</span>, <span>v1</span>.<span>ClaimLost</span>, <span>nil</span>, <span>v1</span>.<span>EventTypeWarning</span>, <span>&#34;ClaimLost&#34;</span>, <span>&#34;Bound claim has lost reference to PersistentVolume. Data on the volume is lost!&#34;</span>); <span>err</span> <span>!=</span> <span>nil</span> {</p></div></div><div><div><p><span>obj</span>, <span>found</span>, <span>err</span> <span>:=</span> <span>ctrl</span>.<span>volumes</span>.<span>store</span>.<span>GetByKey</span>(<span>claim</span>.<span>Spec</span>.<span>VolumeName</span>)</p></div></div><div><div><p><span>// Claim is bound to a non-existing volume.</span></p></div></div><div><div><p><span>if</span> <span>_</span>, <span>err</span> <span>=</span> <span>ctrl</span>.<span>updateClaimStatusWithEvent</span>(<span>ctx</span>, <span>claim</span>, <span>v1</span>.<span>ClaimLost</span>, <span>nil</span>, <span>v1</span>.<span>EventTypeWarning</span>, <span>&#34;ClaimLost&#34;</span>, <span>&#34;Bound claim has lost its PersistentVolume. Data on the volume is lost!&#34;</span>); <span>err</span> <span>!=</span> <span>nil</span> {</p></div></div><div><div><p><span>volume</span>, <span>ok</span> <span>:=</span> <span>obj</span>.(<span>*</span>v1.<span>PersistentVolume</span>)</p></div></div><div><div><p><span>return</span> <span>fmt</span>.<span>Errorf</span>(<span>&#34;cannot convert object from volume cache to volume %q!?: %#v&#34;</span>, <span>claim</span>.<span>Spec</span>.<span>VolumeName</span>, <span>obj</span>)</p></div></div><div><div><p><span>logger</span>.<span>V</span>(<span>4</span>).<span>Info</span>(<span>&#34;Synchronizing bound PersistentVolumeClaim, volume found&#34;</span>, <span>&#34;PVC&#34;</span>, <span>klog</span>.<span>KObj</span>(<span>claim</span>), <span>&#34;volumeName&#34;</span>, <span>claim</span>.<span>Spec</span>.<span>VolumeName</span>, <span>&#34;volumeStatus&#34;</span>, <span>getVolumeStatusForLogging</span>(<span>volume</span>))</p></div></div><div><div><p><span>if</span> <span>volume</span>.<span>Spec</span>.<span>ClaimRef</span> <span>==</span> <span>nil</span> {</p></div></div><div><div><p><span>// Claim is bound but volume has come unbound.</span></p></div></div><div><div><p><span>// Or, a claim was bound and the controller has not received updated</span></p></div></div><div><div><p><span>// volume yet. We can&#39;t distinguish these cases.</span></p></div></div><div><div><p><span>// Bind the volume again and set all states to Bound.</span></p></div></div><div><div><p><span>logger</span>.<span>V</span>(<span>4</span>).<span>Info</span>(<span>&#34;Synchronizing bound PersistentVolumeClaim, volume is unbound, fixing&#34;</span>, <span>&#34;PVC&#34;</span>, <span>klog</span>.<span>KObj</span>(<span>claim</span>))</p></div></div><div><div><p><span>if</span> <span>err</span> <span>=</span> <span>ctrl</span>.<span>bind</span>(<span>ctx</span>, <span>volume</span>, <span>claim</span>); <span>err</span> <span>!=</span> <span>nil</span> {</p></div></div><div><div><p><span>// Objects not saved, next syncPV or syncClaim will try again</span></p></div></div><div><div><p>		} <span>else</span> <span>if</span> <span>volume</span>.<span>Spec</span>.<span>ClaimRef</span>.<span>UID</span> <span>==</span> <span>claim</span>.<span>UID</span> {</p></div></div><div><div><p><span>// NOTE: syncPV can handle this so it can be left out.</span></p></div></div><div><div><p><span>// NOTE: bind() call here will do nothing in most cases as</span></p></div></div><div><div><p><span>// everything should be already set.</span></p></div></div><div><div><p><span>logger</span>.<span>V</span>(<span>4</span>).<span>Info</span>(<span>&#34;Synchronizing bound PersistentVolumeClaim, claim is already correctly bound&#34;</span>, <span>&#34;PVC&#34;</span>, <span>klog</span>.<span>KObj</span>(<span>claim</span>))</p></div></div><div><div><p><span>if</span> <span>err</span> <span>=</span> <span>ctrl</span>.<span>bind</span>(<span>ctx</span>, <span>volume</span>, <span>claim</span>); <span>err</span> <span>!=</span> <span>nil</span> {</p></div></div><div><div><p><span>// Objects not saved, next syncPV or syncClaim will try again</span></p></div></div><div><div><p><span>// Claim is bound but volume has a different claimant.</span></p></div></div><div><div><p><span>// Set the claim phase to &#39;Lost&#39;, which is a terminal</span></p></div></div><div><div><p><span>if</span> <span>_</span>, <span>err</span> <span>=</span> <span>ctrl</span>.<span>updateClaimStatusWithEvent</span>(<span>ctx</span>, <span>claim</span>, <span>v1</span>.<span>ClaimLost</span>, <span>nil</span>, <span>v1</span>.<span>EventTypeWarning</span>, <span>&#34;ClaimMisbound&#34;</span>, <span>&#34;Two claims are bound to the same volume, this one is bound incorrectly&#34;</span>); <span>err</span> <span>!=</span> <span>nil</span> {</p></div></div><div><div><p><span>// syncVolume is the main controller method to decide what to do with a volume.</span></p></div></div><div><div><p><span>// It&#39;s invoked by appropriate cache.Controller callbacks when a volume is</span></p></div></div><div><div><p><span>// created, updated or periodically synced. We do not differentiate between</span></p></div></div><div><div><p><span>func</span> (<span>ctrl</span> <span>*</span><span>PersistentVolumeController</span>) <span>syncVolume</span>(<span>ctx</span> context.<span>Context</span>, <span>volume</span> <span>*</span>v1.<span>PersistentVolume</span>) <span>error</span> {</p></div></div><div><div><p><span>logger</span> <span>:=</span> <span>klog</span>.<span>FromContext</span>(<span>ctx</span>)</p></div></div><div><div><p><span>logger</span>.<span>V</span>(<span>4</span>).<span>Info</span>(<span>&#34;Synchronizing PersistentVolume&#34;</span>, <span>&#34;volumeName&#34;</span>, <span>volume</span>.<span>Name</span>, <span>&#34;volumeStatus&#34;</span>, <span>getVolumeStatusForLogging</span>(<span>volume</span>))</p></div></div><div><div><p><span>// Set correct &#34;migrated-to&#34; annotations and modify finalizers on PV and update in API server if</span></p></div></div><div><div><p><span>newVolume</span>, <span>err</span> <span>:=</span> <span>ctrl</span>.<span>updateVolumeMigrationAnnotationsAndFinalizers</span>(<span>ctx</span>, <span>volume</span>)</p></div></div><div><div><p><span>// Nothing was saved; we will fall back into the same</span></p></div></div><div><div><p><span>// condition in the next call to this method</span></p></div></div><div><div><p><span>if</span> <span>volume</span>.<span>Spec</span>.<span>ClaimRef</span> <span>==</span> <span>nil</span> {</p></div></div><div><div><p><span>logger</span>.<span>V</span>(<span>4</span>).<span>Info</span>(<span>&#34;Synchronizing PersistentVolume, volume is unused&#34;</span>, <span>&#34;volumeName&#34;</span>, <span>volume</span>.<span>Name</span>)</p></div></div><div><div><p><span>if</span> <span>_</span>, <span>err</span> <span>:=</span> <span>ctrl</span>.<span>updateVolumePhase</span>(<span>ctx</span>, <span>volume</span>, <span>v1</span>.<span>VolumeAvailable</span>, <span>&#34;&#34;</span>); <span>err</span> <span>!=</span> <span>nil</span> {</p></div></div><div><div><p><span>// Nothing was saved; we will fall back into the same</span></p></div></div><div><div><p><span>// condition in the next call to this method</span></p></div></div><div><div><p>	} <span>else</span> <span>/* pv.Spec.ClaimRef != nil */</span> {</p></div></div><div><div><p><span>// Volume is bound to a claim.</span></p></div></div><div><div><p><span>if</span> <span>volume</span>.<span>Spec</span>.<span>ClaimRef</span>.<span>UID</span> <span>==</span> <span>&#34;&#34;</span> {</p></div></div><div><div><p><span>// The PV is reserved for a PVC; that PVC has not yet been</span></p></div></div><div><div><p><span>// bound to this PV; the PVC sync will handle it.</span></p></div></div><div><div><p><span>logger</span>.<span>V</span>(<span>4</span>).<span>Info</span>(<span>&#34;Synchronizing PersistentVolume, volume is pre-bound to claim&#34;</span>, <span>&#34;PVC&#34;</span>, <span>klog</span>.<span>KRef</span>(<span>volume</span>.<span>Spec</span>.<span>ClaimRef</span>.<span>Namespace</span>, <span>volume</span>.<span>Spec</span>.<span>ClaimRef</span>.<span>Name</span>), <span>&#34;volumeName&#34;</span>, <span>volume</span>.<span>Name</span>)</p></div></div><div><div><p><span>if</span> <span>_</span>, <span>err</span> <span>:=</span> <span>ctrl</span>.<span>updateVolumePhase</span>(<span>ctx</span>, <span>volume</span>, <span>v1</span>.<span>VolumeAvailable</span>, <span>&#34;&#34;</span>); <span>err</span> <span>!=</span> <span>nil</span> {</p></div></div><div><div><p><span>// Nothing was saved; we will fall back into the same</span></p></div></div><div><div><p><span>// condition in the next call to this method</span></p></div></div><div><div><p><span>logger</span>.<span>V</span>(<span>4</span>).<span>Info</span>(<span>&#34;Synchronizing PersistentVolume, volume is bound to claim&#34;</span>, <span>&#34;PVC&#34;</span>, <span>klog</span>.<span>KRef</span>(<span>volume</span>.<span>Spec</span>.<span>ClaimRef</span>.<span>Namespace</span>, <span>volume</span>.<span>Spec</span>.<span>ClaimRef</span>.<span>Name</span>), <span>&#34;volumeName&#34;</span>, <span>volume</span>.<span>Name</span>)</p></div></div><div><div><p><span>var</span> <span>claim</span> <span>*</span>v1.<span>PersistentVolumeClaim</span></p></div></div><div><div><p><span>claimName</span> <span>:=</span> <span>claimrefToClaimKey</span>(<span>volume</span>.<span>Spec</span>.<span>ClaimRef</span>)</p></div></div><div><div><p><span>obj</span>, <span>found</span>, <span>err</span> <span>:=</span> <span>ctrl</span>.<span>claims</span>.<span>GetByKey</span>(<span>claimName</span>)</p></div></div><div><div><p><span>// If the PV was created by an external PV provisioner or</span></p></div></div><div><div><p><span>// bound by external PV binder (e.g. kube-scheduler), it&#39;s</span></p></div></div><div><div><p><span>// possible under heavy load that the corresponding PVC is not synced to</span></p></div></div><div><div><p><span>// controller local cache yet. So we need to double-check PVC in</span></p></div></div><div><div><p><span>//   2) apiserver if not found in informer cache</span></p></div></div><div><div><p><span>// to make sure we will not reclaim a PV wrongly.</span></p></div></div><div><div><p><span>// Note that only non-released and non-failed volumes will be</span></p></div></div><div><div><p><span>// updated to Released state when PVC does not exist.</span></p></div></div><div><div><p><span>if</span> <span>volume</span>.<span>Status</span>.<span>Phase</span> <span>!=</span> <span>v1</span>.<span>VolumeReleased</span> <span>&amp;&amp;</span> <span>volume</span>.<span>Status</span>.<span>Phase</span> <span>!=</span> <span>v1</span>.<span>VolumeFailed</span> {</p></div></div><div><div><p><span>obj</span>, <span>err</span> <span>=</span> <span>ctrl</span>.<span>claimLister</span>.<span>PersistentVolumeClaims</span>(<span>volume</span>.<span>Spec</span>.<span>ClaimRef</span>.<span>Namespace</span>).<span>Get</span>(<span>volume</span>.<span>Spec</span>.<span>ClaimRef</span>.<span>Name</span>)</p></div></div><div><div><p><span>if</span> <span>err</span> <span>!=</span> <span>nil</span> <span>&amp;&amp;</span> <span>!</span><span>apierrors</span>.<span>IsNotFound</span>(<span>err</span>) {</p></div></div><div><div><p><span>found</span> <span>=</span> <span>!</span><span>apierrors</span>.<span>IsNotFound</span>(<span>err</span>)</p></div></div><div><div><p><span>obj</span>, <span>err</span> <span>=</span> <span>ctrl</span>.<span>kubeClient</span>.<span>CoreV1</span>().<span>PersistentVolumeClaims</span>(<span>volume</span>.<span>Spec</span>.<span>ClaimRef</span>.<span>Namespace</span>).<span>Get</span>(<span>ctx</span>, <span>volume</span>.<span>Spec</span>.<span>ClaimRef</span>.<span>Name</span>, metav1.<span>GetOptions</span>{})</p></div></div><div><div><p><span>if</span> <span>err</span> <span>!=</span> <span>nil</span> <span>&amp;&amp;</span> <span>!</span><span>apierrors</span>.<span>IsNotFound</span>(<span>err</span>) {</p></div></div><div><div><p><span>found</span> <span>=</span> <span>!</span><span>apierrors</span>.<span>IsNotFound</span>(<span>err</span>)</p></div></div><div><div><p><span>logger</span>.<span>V</span>(<span>4</span>).<span>Info</span>(<span>&#34;Synchronizing PersistentVolume, claim not found&#34;</span>, <span>&#34;PVC&#34;</span>, <span>klog</span>.<span>KRef</span>(<span>volume</span>.<span>Spec</span>.<span>ClaimRef</span>.<span>Namespace</span>, <span>volume</span>.<span>Spec</span>.<span>ClaimRef</span>.<span>Name</span>), <span>&#34;volumeName&#34;</span>, <span>volume</span>.<span>Name</span>)</p></div></div><div><div><p><span>// Fall through with claim = nil</span></p></div></div><div><div><p><span>claim</span>, <span>ok</span> <span>=</span> <span>obj</span>.(<span>*</span>v1.<span>PersistentVolumeClaim</span>)</p></div></div><div><div><p><span>return</span> <span>fmt</span>.<span>Errorf</span>(<span>&#34;cannot convert object from volume cache to volume %q!?: %#v&#34;</span>, <span>claim</span>.<span>Spec</span>.<span>VolumeName</span>, <span>obj</span>)</p></div></div><div><div><p><span>logger</span>.<span>V</span>(<span>4</span>).<span>Info</span>(<span>&#34;Synchronizing PersistentVolume, claim found&#34;</span>, <span>&#34;PVC&#34;</span>, <span>klog</span>.<span>KRef</span>(<span>volume</span>.<span>Spec</span>.<span>ClaimRef</span>.<span>Namespace</span>, <span>volume</span>.<span>Spec</span>.<span>ClaimRef</span>.<span>Name</span>), <span>&#34;claimStatus&#34;</span>, <span>getClaimStatusForLogging</span>(<span>claim</span>), <span>&#34;volumeName&#34;</span>, <span>volume</span>.<span>Name</span>)</p></div></div><div><div><p><span>if</span> <span>claim</span> <span>!=</span> <span>nil</span> <span>&amp;&amp;</span> <span>claim</span>.<span>UID</span> <span>!=</span> <span>volume</span>.<span>Spec</span>.<span>ClaimRef</span>.<span>UID</span> {</p></div></div><div><div><p><span>// The claim that the PV was pointing to was deleted, and another</span></p></div></div><div><div><p><span>// with the same name created.</span></p></div></div><div><div><p><span>// in some cases, the cached claim is not the newest, and the volume.Spec.ClaimRef.UID is newer than cached.</span></p></div></div><div><div><p><span>// so we should double check by calling apiserver and get the newest claim, then compare them.</span></p></div></div><div><div><p><span>logger</span>.<span>V</span>(<span>4</span>).<span>Info</span>(<span>&#34;Maybe cached claim is not the newest one, we should fetch it from apiserver&#34;</span>, <span>&#34;PVC&#34;</span>, <span>klog</span>.<span>KRef</span>(<span>volume</span>.<span>Spec</span>.<span>ClaimRef</span>.<span>Namespace</span>, <span>volume</span>.<span>Spec</span>.<span>ClaimRef</span>.<span>Name</span>))</p></div></div><div><div><p><span>claim</span>, <span>err</span> <span>=</span> <span>ctrl</span>.<span>kubeClient</span>.<span>CoreV1</span>().<span>PersistentVolumeClaims</span>(<span>volume</span>.<span>Spec</span>.<span>ClaimRef</span>.<span>Namespace</span>).<span>Get</span>(<span>ctx</span>, <span>volume</span>.<span>Spec</span>.<span>ClaimRef</span>.<span>Name</span>, metav1.<span>GetOptions</span>{})</p></div></div><div><div><p><span>if</span> <span>err</span> <span>!=</span> <span>nil</span> <span>&amp;&amp;</span> <span>!</span><span>apierrors</span>.<span>IsNotFound</span>(<span>err</span>) {</p></div></div><div><div><p><span>// Treat the volume as bound to a missing claim.</span></p></div></div><div><div><p><span>if</span> <span>claim</span>.<span>UID</span> <span>!=</span> <span>volume</span>.<span>Spec</span>.<span>ClaimRef</span>.<span>UID</span> {</p></div></div><div><div><p><span>logger</span>.<span>V</span>(<span>4</span>).<span>Info</span>(<span>&#34;Synchronizing PersistentVolume, claim has a newer UID than pv.ClaimRef, the old one must have been deleted&#34;</span>, <span>&#34;PVC&#34;</span>, <span>klog</span>.<span>KRef</span>(<span>volume</span>.<span>Spec</span>.<span>ClaimRef</span>.<span>Namespace</span>, <span>volume</span>.<span>Spec</span>.<span>ClaimRef</span>.<span>Name</span>), <span>&#34;volumeName&#34;</span>, <span>volume</span>.<span>Name</span>)</p></div></div><div><div><p><span>logger</span>.<span>V</span>(<span>4</span>).<span>Info</span>(<span>&#34;Synchronizing PersistentVolume, claim has a same UID with pv.ClaimRef&#34;</span>, <span>&#34;PVC&#34;</span>, <span>klog</span>.<span>KRef</span>(<span>volume</span>.<span>Spec</span>.<span>ClaimRef</span>.<span>Namespace</span>, <span>volume</span>.<span>Spec</span>.<span>ClaimRef</span>.<span>Name</span>), <span>&#34;volumeName&#34;</span>, <span>volume</span>.<span>Name</span>)</p></div></div><div><div><p><span>// If we get into this block, the claim must have been deleted;</span></p></div></div><div><div><p><span>// NOTE: reclaimVolume may either release the PV back into the pool or</span></p></div></div><div><div><p><span>// recycle it or do nothing (retain)</span></p></div></div><div><div><p><span>// Do not overwrite previous Failed state - let the user see that</span></p></div></div><div><div><p><span>// something went wrong, while we still re-try to reclaim the</span></p></div></div><div><div><p><span>if</span> <span>volume</span>.<span>Status</span>.<span>Phase</span> <span>!=</span> <span>v1</span>.<span>VolumeReleased</span> <span>&amp;&amp;</span> <span>volume</span>.<span>Status</span>.<span>Phase</span> <span>!=</span> <span>v1</span>.<span>VolumeFailed</span> {</p></div></div><div><div><p><span>// Also, log this only once:</span></p></div></div><div><div><p><span>logger</span>.<span>V</span>(<span>2</span>).<span>Info</span>(<span>&#34;Volume is released and reclaim policy will be executed&#34;</span>, <span>&#34;volumeName&#34;</span>, <span>volume</span>.<span>Name</span>, <span>&#34;reclaimPolicy&#34;</span>, <span>volume</span>.<span>Spec</span>.<span>PersistentVolumeReclaimPolicy</span>)</p></div></div><div><div><p><span>if</span> <span>volume</span>, <span>err</span> <span>=</span> <span>ctrl</span>.<span>updateVolumePhase</span>(<span>ctx</span>, <span>volume</span>, <span>v1</span>.<span>VolumeReleased</span>, <span>&#34;&#34;</span>); <span>err</span> <span>!=</span> <span>nil</span> {</p></div></div><div><div><p><span>// Nothing was saved; we will fall back into the same condition</span></p></div></div><div><div><p><span>// in the next call to this method</span></p></div></div><div><div><p><span>if</span> <span>err</span> <span>=</span> <span>ctrl</span>.<span>reclaimVolume</span>(<span>ctx</span>, <span>volume</span>); <span>err</span> <span>!=</span> <span>nil</span> {</p></div></div><div><div><p><span>// Release failed, we will fall back into the same condition</span></p></div></div><div><div><p><span>// in the next call to this method</span></p></div></div><div><div><p><span>if</span> <span>volume</span>.<span>Spec</span>.<span>PersistentVolumeReclaimPolicy</span> <span>==</span> <span>v1</span>.<span>PersistentVolumeReclaimRetain</span> {</p></div></div><div><div><p><span>// volume is being retained, it references a claim that does not exist now.</span></p></div></div><div><div><p><span>logger</span>.<span>V</span>(<span>4</span>).<span>Info</span>(<span>&#34;PersistentVolume references a claim that is not found&#34;</span>, <span>&#34;PVC&#34;</span>, <span>klog</span>.<span>KRef</span>(<span>volume</span>.<span>Spec</span>.<span>ClaimRef</span>.<span>Namespace</span>, <span>volume</span>.<span>Spec</span>.<span>ClaimRef</span>.<span>Name</span>), <span>&#34;claimUID&#34;</span>, <span>volume</span>.<span>Spec</span>.<span>ClaimRef</span>.<span>UID</span>, <span>&#34;volumeName&#34;</span>, <span>volume</span>.<span>Name</span>)</p></div></div><div><div><p>		} <span>else</span> <span>if</span> <span>claim</span>.<span>Spec</span>.<span>VolumeName</span> <span>==</span> <span>&#34;&#34;</span> {</p></div></div><div><div><p><span>if</span> <span>storagehelpers</span>.<span>CheckVolumeModeMismatches</span>(<span>&amp;</span><span>claim</span>.<span>Spec</span>, <span>&amp;</span><span>volume</span>.<span>Spec</span>) {</p></div></div><div><div><p><span>// Binding for the volume won&#39;t be called in syncUnboundClaim,</span></p></div></div><div><div><p><span>// because findBestMatchForClaim won&#39;t return the volume due to volumeMode mismatch.</span></p></div></div><div><div><p><span>volumeMsg</span> <span>:=</span> <span>fmt</span>.<span>Sprintf</span>(<span>&#34;Cannot bind PersistentVolume to requested PersistentVolumeClaim %q due to incompatible volumeMode.&#34;</span>, <span>claim</span>.<span>Name</span>)</p></div></div><div><div><p><span>ctrl</span>.<span>eventRecorder</span>.<span>Event</span>(<span>volume</span>, <span>v1</span>.<span>EventTypeWarning</span>, <span>events</span>.<span>VolumeMismatch</span>, <span>volumeMsg</span>)</p></div></div><div><div><p><span>claimMsg</span> <span>:=</span> <span>fmt</span>.<span>Sprintf</span>(<span>&#34;Cannot bind PersistentVolume %q to requested PersistentVolumeClaim due to incompatible volumeMode.&#34;</span>, <span>volume</span>.<span>Name</span>)</p></div></div><div><div><p><span>ctrl</span>.<span>eventRecorder</span>.<span>Event</span>(<span>claim</span>, <span>v1</span>.<span>EventTypeWarning</span>, <span>events</span>.<span>VolumeMismatch</span>, <span>claimMsg</span>)</p></div></div><div><div><p><span>if</span> <span>metav1</span>.<span>HasAnnotation</span>(<span>volume</span>.<span>ObjectMeta</span>, <span>storagehelpers</span>.<span>AnnBoundByController</span>) {</p></div></div><div><div><p><span>// The binding is not completed; let PVC sync handle it</span></p></div></div><div><div><p><span>logger</span>.<span>V</span>(<span>4</span>).<span>Info</span>(<span>&#34;Synchronizing PersistentVolume, volume not bound yet, waiting for syncClaim to fix it&#34;</span>, <span>&#34;volumeName&#34;</span>, <span>volume</span>.<span>Name</span>)</p></div></div><div><div><p><span>// Dangling PV; try to re-establish the link in the PVC sync</span></p></div></div><div><div><p><span>logger</span>.<span>V</span>(<span>4</span>).<span>Info</span>(<span>&#34;Synchronizing PersistentVolume, volume was bound and got unbound (by user?), waiting for syncClaim to fix it&#34;</span>, <span>&#34;volumeName&#34;</span>, <span>volume</span>.<span>Name</span>)</p></div></div><div><div><p><span>// In both cases, the volume is Bound and the claim is Pending.</span></p></div></div><div><div><p><span>// Next syncClaim will fix it. To speed it up, we enqueue the claim</span></p></div></div><div><div><p><span>// into the controller, which results in syncClaim to be called</span></p></div></div><div><div><p><span>// shortly (and in the right worker goroutine).</span></p></div></div><div><div><p><span>// This speeds up binding of provisioned volumes - provisioner saves</span></p></div></div><div><div><p><span>// only the new PV and it expects that next syncClaim will bind the</span></p></div></div><div><div><p><span>ctrl</span>.<span>claimQueue</span>.<span>Add</span>(<span>claimToClaimKey</span>(<span>claim</span>))</p></div></div><div><div><p>		} <span>else</span> <span>if</span> <span>claim</span>.<span>Spec</span>.<span>VolumeName</span> <span>==</span> <span>volume</span>.<span>Name</span> {</p></div></div><div><div><p><span>// Volume is bound to a claim properly, update status if necessary</span></p></div></div><div><div><p><span>logger</span>.<span>V</span>(<span>4</span>).<span>Info</span>(<span>&#34;Synchronizing PersistentVolume, all is bound&#34;</span>, <span>&#34;volumeName&#34;</span>, <span>volume</span>.<span>Name</span>)</p></div></div><div><div><p><span>if</span> <span>_</span>, <span>err</span> <span>=</span> <span>ctrl</span>.<span>updateVolumePhase</span>(<span>ctx</span>, <span>volume</span>, <span>v1</span>.<span>VolumeBound</span>, <span>&#34;&#34;</span>); <span>err</span> <span>!=</span> <span>nil</span> {</p></div></div><div><div><p><span>// Nothing was saved; we will fall back into the same</span></p></div></div><div><div><p><span>// condition in the next call to this method</span></p></div></div><div><div><p><span>// Volume is bound to a claim, but the claim is bound elsewhere</span></p></div></div><div><div><p><span>if</span> <span>metav1</span>.<span>HasAnnotation</span>(<span>volume</span>.<span>ObjectMeta</span>, <span>storagehelpers</span>.<span>AnnDynamicallyProvisioned</span>) <span>&amp;&amp;</span> <span>volume</span>.<span>Spec</span>.<span>PersistentVolumeReclaimPolicy</span> <span>==</span> <span>v1</span>.<span>PersistentVolumeReclaimDelete</span> {</p></div></div><div><div><p><span>// This volume was dynamically provisioned for this claim. The</span></p></div></div><div><div><p><span>// claim got bound elsewhere, and thus this volume is not</span></p></div></div><div><div><p><span>// Mark the volume as Released for external deleters and to let</span></p></div></div><div><div><p><span>// the user know. Don&#39;t overwrite existing Failed status!</span></p></div></div><div><div><p><span>if</span> <span>volume</span>.<span>Status</span>.<span>Phase</span> <span>!=</span> <span>v1</span>.<span>VolumeReleased</span> <span>&amp;&amp;</span> <span>volume</span>.<span>Status</span>.<span>Phase</span> <span>!=</span> <span>v1</span>.<span>VolumeFailed</span> {</p></div></div><div><div><p><span>// Also, log this only once:</span></p></div></div><div><div><p><span>logger</span>.<span>V</span>(<span>2</span>).<span>Info</span>(<span>&#34;Dynamically provisioned volume is released and it will be deleted&#34;</span>, <span>&#34;volumeName&#34;</span>, <span>volume</span>.<span>Name</span>)</p></div></div><div><div><p><span>if</span> <span>volume</span>, <span>err</span> <span>=</span> <span>ctrl</span>.<span>updateVolumePhase</span>(<span>ctx</span>, <span>volume</span>, <span>v1</span>.<span>VolumeReleased</span>, <span>&#34;&#34;</span>); <span>err</span> <span>!=</span> <span>nil</span> {</p></div></div><div><div><p><span>// Nothing was saved; we will fall back into the same condition</span></p></div></div><div><div><p><span>// in the next call to this method</span></p></div></div><div><div><p><span>if</span> <span>err</span> <span>=</span> <span>ctrl</span>.<span>reclaimVolume</span>(<span>ctx</span>, <span>volume</span>); <span>err</span> <span>!=</span> <span>nil</span> {</p></div></div><div><div><p><span>// Deletion failed, we will fall back into the same condition</span></p></div></div><div><div><p><span>// in the next call to this method</span></p></div></div><div><div><p><span>// Volume is bound to a claim, but the claim is bound elsewhere</span></p></div></div><div><div><p><span>// and it&#39;s not dynamically provisioned.</span></p></div></div><div><div><p><span>if</span> <span>metav1</span>.<span>HasAnnotation</span>(<span>volume</span>.<span>ObjectMeta</span>, <span>storagehelpers</span>.<span>AnnBoundByController</span>) {</p></div></div><div><div><p><span>// This is part of the normal operation of the controller; the</span></p></div></div><div><div><p><span>// controller tried to use this volume for a claim but the claim</span></p></div></div><div><div><p><span>// was fulfilled by another volume. We did this; fix it.</span></p></div></div><div><div><p><span>logger</span>.<span>V</span>(<span>4</span>).<span>Info</span>(<span>&#34;Synchronizing PersistentVolume, volume is bound by controller to a claim that is bound to another volume, unbinding&#34;</span>, <span>&#34;volumeName&#34;</span>, <span>volume</span>.<span>Name</span>)</p></div></div><div><div><p><span>if</span> <span>err</span> <span>=</span> <span>ctrl</span>.<span>unbindVolume</span>(<span>ctx</span>, <span>volume</span>); <span>err</span> <span>!=</span> <span>nil</span> {</p></div></div><div><div><p><span>// The PV must have been created with this ptr; leave it alone.</span></p></div></div><div><div><p><span>logger</span>.<span>V</span>(<span>4</span>).<span>Info</span>(<span>&#34;Synchronizing PersistentVolume, volume is bound by user to a claim that is bound to another volume, waiting for the claim to get unbound&#34;</span>, <span>&#34;volumeName&#34;</span>, <span>volume</span>.<span>Name</span>)</p></div></div><div><div><p><span>// This just updates the volume phase and clears</span></p></div></div><div><div><p><span>// volume.Spec.ClaimRef.UID. It leaves the volume pre-bound</span></p></div></div><div><div><p><span>if</span> <span>err</span> <span>=</span> <span>ctrl</span>.<span>unbindVolume</span>(<span>ctx</span>, <span>volume</span>); <span>err</span> <span>!=</span> <span>nil</span> {</p></div></div><div><div><p><span>// updateClaimStatus saves new claim.Status to API server.</span></p></div></div><div><div><p><span>//	claim - claim to update</span></p></div></div><div><div><p><span>//	volume - volume which Capacity is set into claim.Status.Capacity and VolumeAttributesClassName is set into claim.Status.CurrentVolumeAttributesClassName</span></p></div></div><div><div><p><span>func</span> (<span>ctrl</span> <span>*</span><span>PersistentVolumeController</span>) <span>updateClaimStatus</span>(<span>ctx</span> context.<span>Context</span>, <span>claim</span> <span>*</span>v1.<span>PersistentVolumeClaim</span>, <span>phase</span> v1.<span>PersistentVolumeClaimPhase</span>, <span>volume</span> <span>*</span>v1.<span>PersistentVolume</span>) (<span>*</span>v1.<span>PersistentVolumeClaim</span>, <span>error</span>) {</p></div></div><div><div><p><span>logger</span> <span>:=</span> <span>klog</span>.<span>FromContext</span>(<span>ctx</span>)</p></div></div><div><div><p><span>logger</span>.<span>V</span>(<span>4</span>).<span>Info</span>(<span>&#34;Updating PersistentVolumeClaim status&#34;</span>, <span>&#34;PVC&#34;</span>, <span>klog</span>.<span>KObj</span>(<span>claim</span>), <span>&#34;setPhase&#34;</span>, <span>phase</span>)</p></div></div><div><div><p><span>claimClone</span> <span>:=</span> <span>claim</span>.<span>DeepCopy</span>()</p></div></div><div><div><p><span>if</span> <span>claim</span>.<span>Status</span>.<span>Phase</span> <span>!=</span> <span>phase</span> {</p></div></div><div><div><p><span>claimClone</span>.<span>Status</span>.<span>Phase</span> <span>=</span> <span>phase</span></p></div></div><div><div><p><span>// Need to reset AccessModes, Capacity and CurrentVolumeAttributesClassName</span></p></div></div><div><div><p><span>if</span> <span>claim</span>.<span>Status</span>.<span>AccessModes</span> <span>!=</span> <span>nil</span> {</p></div></div><div><div><p><span>claimClone</span>.<span>Status</span>.<span>AccessModes</span> <span>=</span> <span>nil</span></p></div></div><div><div><p><span>if</span> <span>claim</span>.<span>Status</span>.<span>Capacity</span> <span>!=</span> <span>nil</span> {</p></div></div><div><div><p><span>claimClone</span>.<span>Status</span>.<span>Capacity</span> <span>=</span> <span>nil</span></p></div></div><div><div><p><span>if</span> <span>claim</span>.<span>Status</span>.<span>CurrentVolumeAttributesClassName</span> <span>!=</span> <span>nil</span> {</p></div></div><div><div><p><span>claimClone</span>.<span>Status</span>.<span>CurrentVolumeAttributesClassName</span> <span>=</span> <span>nil</span></p></div></div><div><div><p><span>// Need to update AccessModes, Capacity and CurrentVolumeAttributesClassName</span></p></div></div><div><div><p><span>if</span> <span>!</span><span>reflect</span>.<span>DeepEqual</span>(<span>claim</span>.<span>Status</span>.<span>AccessModes</span>, <span>volume</span>.<span>Spec</span>.<span>AccessModes</span>) {</p></div></div><div><div><p><span>claimClone</span>.<span>Status</span>.<span>AccessModes</span> <span>=</span> <span>volume</span>.<span>Spec</span>.<span>AccessModes</span></p></div></div><div><div><p><span>// Update Capacity if the claim is becoming Bound, not if it was already.</span></p></div></div><div><div><p><span>// A discrepancy can be intentional to mean that the PVC filesystem size</span></p></div></div><div><div><p><span>// doesn&#39;t match the PV block device size, so don&#39;t clobber it</span></p></div></div><div><div><p><span>if</span> <span>claim</span>.<span>Status</span>.<span>Phase</span> <span>!=</span> <span>phase</span> {</p></div></div><div><div><p><span>volumeCap</span>, <span>ok</span> <span>:=</span> <span>volume</span>.<span>Spec</span>.<span>Capacity</span>[<span>v1</span>.<span>ResourceStorage</span>]</p></div></div><div><div><p><span>return</span> <span>nil</span>, <span>fmt</span>.<span>Errorf</span>(<span>&#34;PersistentVolume %q is without a storage capacity&#34;</span>, <span>volume</span>.<span>Name</span>)</p></div></div><div><div><p><span>claimCap</span>, <span>ok</span> <span>:=</span> <span>claim</span>.<span>Status</span>.<span>Capacity</span>[<span>v1</span>.<span>ResourceStorage</span>]</p></div></div><div><div><p><span>// If PV has a resize annotation, set the claim&#39;s request capacity</span></p></div></div><div><div><p><span>if</span> <span>metav1</span>.<span>HasAnnotation</span>(<span>volume</span>.<span>ObjectMeta</span>, <span>util</span>.<span>AnnPreResizeCapacity</span>) {</p></div></div><div><div><p><span>logger</span>.<span>V</span>(<span>2</span>).<span>Info</span>(<span>&#34;Volume requires filesystem resize: setting pvc status capacity&#34;</span>, <span>&#34;PVC&#34;</span>, <span>klog</span>.<span>KObj</span>(<span>claim</span>), <span>&#34;volumeName&#34;</span>, <span>volume</span>.<span>Name</span>, <span>&#34;statusCapacity&#34;</span>, <span>volume</span>.<span>ObjectMeta</span>.<span>Annotations</span>[<span>util</span>.<span>AnnPreResizeCapacity</span>])</p></div></div><div><div><p><span>preQty</span>, <span>err</span> <span>:=</span> <span>resource</span>.<span>ParseQuantity</span>(<span>volume</span>.<span>ObjectMeta</span>.<span>Annotations</span>[<span>util</span>.<span>AnnPreResizeCapacity</span>])</p></div></div><div><div><p><span>logger</span>.<span>Info</span>(<span>&#34;Parsing pre-resize-capacity from PV failed&#34;</span>, <span>&#34;volumeName&#34;</span>, <span>volume</span>.<span>Name</span>, <span>&#34;err&#34;</span>, <span>err</span>)</p></div></div><div><div><p><span>preQty</span> <span>=</span> <span>volume</span>.<span>Spec</span>.<span>Capacity</span>[<span>v1</span>.<span>ResourceStorage</span>]</p></div></div><div><div><p><span>if</span> <span>claimClone</span>.<span>Status</span>.<span>Capacity</span> <span>==</span> <span>nil</span> {</p></div></div><div><div><p><span>claimClone</span>.<span>Status</span>.<span>Capacity</span> <span>=</span> <span>make</span>(<span>map</span>[v1.<span>ResourceName</span>]resource.<span>Quantity</span>)</p></div></div><div><div><p><span>claimClone</span>.<span>Status</span>.<span>Capacity</span>[<span>v1</span>.<span>ResourceStorage</span>] <span>=</span> <span>preQty</span></p></div></div><div><div><p>			} <span>else</span> <span>if</span> <span>!</span><span>ok</span> <span>||</span> <span>volumeCap</span>.<span>Cmp</span>(<span>claimCap</span>) <span>!=</span> <span>0</span> {</p></div></div><div><div><p><span>claimClone</span>.<span>Status</span>.<span>Capacity</span> <span>=</span> <span>volume</span>.<span>Spec</span>.<span>Capacity</span></p></div></div><div><div><p><span>if</span> <span>utilfeature</span>.<span>DefaultFeatureGate</span>.<span>Enabled</span>(<span>features</span>.<span>VolumeAttributesClass</span>) {</p></div></div><div><div><p><span>// There are two components to updating the current vac name, this controller and external-resizer.</span></p></div></div><div><div><p><span>// The controller ensures that the field is set properly when the volume is statically provisioned.</span></p></div></div><div><div><p><span>// It is safer for the controller to only set this field during binding, but not after. Without this</span></p></div></div><div><div><p><span>// constraint, there is a potential race condition where the resizer sets the field after the controller</span></p></div></div><div><div><p><span>// has set it, or vice versa. Afterwards, it should be handled only by the resizer, or if an admin wants</span></p></div></div><div><div><p><span>if</span> <span>claim</span>.<span>Status</span>.<span>Phase</span> <span>==</span> <span>v1</span>.<span>ClaimPending</span> <span>&amp;&amp;</span> <span>phase</span> <span>==</span> <span>v1</span>.<span>ClaimBound</span> <span>&amp;&amp;</span></p></div></div><div><div><p><span>!</span><span>reflect</span>.<span>DeepEqual</span>(<span>claim</span>.<span>Status</span>.<span>CurrentVolumeAttributesClassName</span>, <span>volume</span>.<span>Spec</span>.<span>VolumeAttributesClassName</span>) {</p></div></div><div><div><p><span>claimClone</span>.<span>Status</span>.<span>CurrentVolumeAttributesClassName</span> <span>=</span> <span>volume</span>.<span>Spec</span>.<span>VolumeAttributesClassName</span></p></div></div><div><div><p><span>logger</span>.<span>V</span>(<span>4</span>).<span>Info</span>(<span>&#34;Updating PersistentVolumeClaim status, phase already set&#34;</span>, <span>&#34;PVC&#34;</span>, <span>klog</span>.<span>KObj</span>(<span>claim</span>), <span>&#34;phase&#34;</span>, <span>phase</span>)</p></div></div><div><div><p><span>newClaim</span>, <span>err</span> <span>:=</span> <span>ctrl</span>.<span>kubeClient</span>.<span>CoreV1</span>().<span>PersistentVolumeClaims</span>(<span>claimClone</span>.<span>Namespace</span>).<span>UpdateStatus</span>(<span>ctx</span>, <span>claimClone</span>, metav1.<span>UpdateOptions</span>{})</p></div></div><div><div><p><span>logger</span>.<span>V</span>(<span>4</span>).<span>Info</span>(<span>&#34;Updating PersistentVolumeClaim status, set phase failed&#34;</span>, <span>&#34;PVC&#34;</span>, <span>klog</span>.<span>KObj</span>(<span>claim</span>), <span>&#34;phase&#34;</span>, <span>phase</span>, <span>&#34;err&#34;</span>, <span>err</span>)</p></div></div><div><div><p><span>_</span>, <span>err</span> <span>=</span> <span>ctrl</span>.<span>storeClaimUpdate</span>(<span>logger</span>, <span>newClaim</span>)</p></div></div><div><div><p><span>logger</span>.<span>V</span>(<span>4</span>).<span>Info</span>(<span>&#34;Updating PersistentVolumeClaim status: cannot update internal cache&#34;</span>, <span>&#34;PVC&#34;</span>, <span>klog</span>.<span>KObj</span>(<span>claim</span>), <span>&#34;err&#34;</span>, <span>err</span>)</p></div></div><div><div><p><span>logger</span>.<span>V</span>(<span>2</span>).<span>Info</span>(<span>&#34;Claim entered phase&#34;</span>, <span>&#34;PVC&#34;</span>, <span>klog</span>.<span>KObj</span>(<span>claim</span>), <span>&#34;phase&#34;</span>, <span>phase</span>)</p></div></div><div><div><p><span>// updateClaimStatusWithEvent saves new claim.Status to API server and emits</span></p></div></div><div><div><p><span>// given event on the claim. It saves the status and emits the event only when</span></p></div></div><div><div><p><span>// the status has actually changed from the version saved in API server.</span></p></div></div><div><div><p><span>//	claim - claim to update</span></p></div></div><div><div><p><span>//	volume - volume which Capacity is set into claim.Status.Capacity and VolumeAttributesClassName is set into claim.Status.CurrentVolumeAttributesClassName</span></p></div></div><div><div><p><span>//	eventtype, reason, message - event to send, see EventRecorder.Event()</span></p></div></div><div><div><p><span>func</span> (<span>ctrl</span> <span>*</span><span>PersistentVolumeController</span>) <span>updateClaimStatusWithEvent</span>(<span>ctx</span> context.<span>Context</span>, <span>claim</span> <span>*</span>v1.<span>PersistentVolumeClaim</span>, <span>phase</span> v1.<span>PersistentVolumeClaimPhase</span>, <span>volume</span> <span>*</span>v1.<span>PersistentVolume</span>, <span>eventtype</span>, <span>reason</span>, <span>message</span> <span>string</span>) (<span>*</span>v1.<span>PersistentVolumeClaim</span>, <span>error</span>) {</p></div></div><div><div><p><span>logger</span> <span>:=</span> <span>klog</span>.<span>FromContext</span>(<span>ctx</span>)</p></div></div><div><div><p><span>logger</span>.<span>V</span>(<span>4</span>).<span>Info</span>(<span>&#34;Updating updateClaimStatusWithEvent&#34;</span>, <span>&#34;PVC&#34;</span>, <span>klog</span>.<span>KObj</span>(<span>claim</span>), <span>&#34;setPhase&#34;</span>, <span>phase</span>)</p></div></div><div><div><p><span>if</span> <span>claim</span>.<span>Status</span>.<span>Phase</span> <span>==</span> <span>phase</span> {</p></div></div><div><div><p><span>logger</span>.<span>V</span>(<span>4</span>).<span>Info</span>(<span>&#34;Updating updateClaimStatusWithEvent, phase already set&#34;</span>, <span>&#34;PVC&#34;</span>, <span>klog</span>.<span>KObj</span>(<span>claim</span>), <span>&#34;phase&#34;</span>, <span>phase</span>)</p></div></div><div><div><p><span>newClaim</span>, <span>err</span> <span>:=</span> <span>ctrl</span>.<span>updateClaimStatus</span>(<span>ctx</span>, <span>claim</span>, <span>phase</span>, <span>volume</span>)</p></div></div><div><div><p><span>// Emit the event only when the status change happens, not every time</span></p></div></div><div><div><p><span>logger</span>.<span>V</span>(<span>3</span>).<span>Info</span>(<span>&#34;Claim changed status&#34;</span>, <span>&#34;PVC&#34;</span>, <span>klog</span>.<span>KObj</span>(<span>claim</span>), <span>&#34;phase&#34;</span>, <span>phase</span>, <span>&#34;message&#34;</span>, <span>message</span>)</p></div></div><div><div><p><span>ctrl</span>.<span>eventRecorder</span>.<span>Event</span>(<span>newClaim</span>, <span>eventtype</span>, <span>reason</span>, <span>message</span>)</p></div></div><div><div><p><span>// updateVolumePhase saves new volume phase to API server.</span></p></div></div><div><div><p><span>func</span> (<span>ctrl</span> <span>*</span><span>PersistentVolumeController</span>) <span>updateVolumePhase</span>(<span>ctx</span> context.<span>Context</span>, <span>volume</span> <span>*</span>v1.<span>PersistentVolume</span>, <span>phase</span> v1.<span>PersistentVolumePhase</span>, <span>message</span> <span>string</span>) (<span>*</span>v1.<span>PersistentVolume</span>, <span>error</span>) {</p></div></div><div><div><p><span>logger</span> <span>:=</span> <span>klog</span>.<span>FromContext</span>(<span>ctx</span>)</p></div></div><div><div><p><span>logger</span>.<span>V</span>(<span>4</span>).<span>Info</span>(<span>&#34;Updating PersistentVolume&#34;</span>, <span>&#34;volumeName&#34;</span>, <span>volume</span>.<span>Name</span>, <span>&#34;setPhase&#34;</span>, <span>phase</span>)</p></div></div><div><div><p><span>if</span> <span>volume</span>.<span>Status</span>.<span>Phase</span> <span>==</span> <span>phase</span> {</p></div></div><div><div><p><span>logger</span>.<span>V</span>(<span>4</span>).<span>Info</span>(<span>&#34;Updating PersistentVolume: phase already set&#34;</span>, <span>&#34;volumeName&#34;</span>, <span>volume</span>.<span>Name</span>, <span>&#34;phase&#34;</span>, <span>phase</span>)</p></div></div><div><div><p><span>volumeClone</span> <span>:=</span> <span>volume</span>.<span>DeepCopy</span>()</p></div></div><div><div><p><span>volumeClone</span>.<span>Status</span>.<span>Phase</span> <span>=</span> <span>phase</span></p></div></div><div><div><p><span>volumeClone</span>.<span>Status</span>.<span>Message</span> <span>=</span> <span>message</span></p></div></div><div><div><p><span>newVol</span>, <span>err</span> <span>:=</span> <span>ctrl</span>.<span>kubeClient</span>.<span>CoreV1</span>().<span>PersistentVolumes</span>().<span>UpdateStatus</span>(<span>ctx</span>, <span>volumeClone</span>, metav1.<span>UpdateOptions</span>{})</p></div></div><div><div><p><span>logger</span>.<span>V</span>(<span>4</span>).<span>Info</span>(<span>&#34;Updating PersistentVolume: set phase failed&#34;</span>, <span>&#34;volumeName&#34;</span>, <span>volume</span>.<span>Name</span>, <span>&#34;phase&#34;</span>, <span>phase</span>, <span>&#34;err&#34;</span>, <span>err</span>)</p></div></div><div><div><p><span>_</span>, <span>err</span> <span>=</span> <span>ctrl</span>.<span>storeVolumeUpdate</span>(<span>logger</span>, <span>newVol</span>)</p></div></div><div><div><p><span>logger</span>.<span>V</span>(<span>4</span>).<span>Info</span>(<span>&#34;Updating PersistentVolume: cannot update internal cache&#34;</span>, <span>&#34;volumeName&#34;</span>, <span>volume</span>.<span>Name</span>, <span>&#34;err&#34;</span>, <span>err</span>)</p></div></div><div><div><p><span>logger</span>.<span>V</span>(<span>2</span>).<span>Info</span>(<span>&#34;Volume entered phase&#34;</span>, <span>&#34;volumeName&#34;</span>, <span>volume</span>.<span>Name</span>, <span>&#34;phase&#34;</span>, <span>phase</span>)</p></div></div><div><div><p><span>// updateVolumePhaseWithEvent saves new volume phase to API server and emits</span></p></div></div><div><div><p><span>// given event on the volume. It saves the phase and emits the event only when</span></p></div></div><div><div><p><span>// the phase has actually changed from the version saved in API server.</span></p></div></div><div><div><p><span>func</span> (<span>ctrl</span> <span>*</span><span>PersistentVolumeController</span>) <span>updateVolumePhaseWithEvent</span>(<span>ctx</span> context.<span>Context</span>, <span>volume</span> <span>*</span>v1.<span>PersistentVolume</span>, <span>phase</span> v1.<span>PersistentVolumePhase</span>, <span>eventtype</span>, <span>reason</span>, <span>message</span> <span>string</span>) (<span>*</span>v1.<span>PersistentVolume</span>, <span>error</span>) {</p></div></div><div><div><p><span>logger</span> <span>:=</span> <span>klog</span>.<span>FromContext</span>(<span>ctx</span>)</p></div></div><div><div><p><span>logger</span>.<span>V</span>(<span>4</span>).<span>Info</span>(<span>&#34;Updating updateVolumePhaseWithEvent&#34;</span>, <span>&#34;volumeName&#34;</span>, <span>volume</span>.<span>Name</span>, <span>&#34;setPhase&#34;</span>, <span>phase</span>)</p></div></div><div><div><p><span>if</span> <span>volume</span>.<span>Status</span>.<span>Phase</span> <span>==</span> <span>phase</span> {</p></div></div><div><div><p><span>logger</span>.<span>V</span>(<span>4</span>).<span>Info</span>(<span>&#34;Updating updateVolumePhaseWithEvent: phase already set&#34;</span>, <span>&#34;volumeName&#34;</span>, <span>volume</span>.<span>Name</span>, <span>&#34;phase&#34;</span>, <span>phase</span>)</p></div></div><div><div><p><span>newVol</span>, <span>err</span> <span>:=</span> <span>ctrl</span>.<span>updateVolumePhase</span>(<span>ctx</span>, <span>volume</span>, <span>phase</span>, <span>message</span>)</p></div></div><div><div><p><span>// Emit the event only when the status change happens, not every time</span></p></div></div><div><div><p><span>logger</span>.<span>V</span>(<span>3</span>).<span>Info</span>(<span>&#34;Volume changed status&#34;</span>, <span>&#34;volumeName&#34;</span>, <span>volume</span>.<span>Name</span>, <span>&#34;changedPhase&#34;</span>, <span>phase</span>, <span>&#34;message&#34;</span>, <span>message</span>)</p></div></div><div><div><p><span>ctrl</span>.<span>eventRecorder</span>.<span>Event</span>(<span>newVol</span>, <span>eventtype</span>, <span>reason</span>, <span>message</span>)</p></div></div><div><div><p><span>// assignDefaultStorageClass updates the claim storage class if there is any, the claim is updated to the API server.</span></p></div></div><div><div><p><span>// Ignores claims that already have a storage class.</span></p></div></div><div><div><p><span>// TODO: if resync is ever changed to a larger period, we might need to change how we set the default class on existing unbound claims</span></p></div></div><div><div><p><span>func</span> (<span>ctrl</span> <span>*</span><span>PersistentVolumeController</span>) <span>assignDefaultStorageClass</span>(<span>ctx</span> context.<span>Context</span>, <span>claim</span> <span>*</span>v1.<span>PersistentVolumeClaim</span>) (<span>bool</span>, <span>error</span>) {</p></div></div><div><div><p><span>logger</span> <span>:=</span> <span>klog</span>.<span>FromContext</span>(<span>ctx</span>)</p></div></div><div><div><p><span>if</span> <span>storagehelpers</span>.<span>PersistentVolumeClaimHasClass</span>(<span>claim</span>) {</p></div></div><div><div><p><span>// The user asked for a class.</span></p></div></div><div><div><p><span>class</span>, <span>err</span> <span>:=</span> <span>util</span>.<span>GetDefaultClass</span>(<span>ctrl</span>.<span>classLister</span>)</p></div></div><div><div><p><span>logger</span>.<span>V</span>(<span>4</span>).<span>Info</span>(<span>&#34;Can not assign storage class to PersistentVolumeClaim: default storage class not found&#34;</span>, <span>&#34;PVC&#34;</span>, <span>klog</span>.<span>KObj</span>(<span>claim</span>))</p></div></div><div><div><p><span>logger</span>.<span>V</span>(<span>4</span>).<span>Info</span>(<span>&#34;Assigning StorageClass to PersistentVolumeClaim&#34;</span>, <span>&#34;PVC&#34;</span>, <span>klog</span>.<span>KObj</span>(<span>claim</span>), <span>&#34;storageClassName&#34;</span>, <span>class</span>.<span>Name</span>)</p></div></div><div><div><p><span>claim</span>.<span>Spec</span>.<span>StorageClassName</span> <span>=</span> <span>&amp;</span><span>class</span>.<span>Name</span></p></div></div><div><div><p><span>_</span>, <span>err</span> <span>=</span> <span>ctrl</span>.<span>kubeClient</span>.<span>CoreV1</span>().<span>PersistentVolumeClaims</span>(<span>claim</span>.<span>GetNamespace</span>()).<span>Update</span>(<span>ctx</span>, <span>claim</span>, metav1.<span>UpdateOptions</span>{})</p></div></div><div><div><p><span>logger</span>.<span>V</span>(<span>4</span>).<span>Info</span>(<span>&#34;Successfully assigned StorageClass to PersistentVolumeClaim&#34;</span>, <span>&#34;PVC&#34;</span>, <span>klog</span>.<span>KObj</span>(<span>claim</span>), <span>&#34;storageClassName&#34;</span>, <span>class</span>.<span>Name</span>)</p></div></div><div><div><p><span>// bindVolumeToClaim modifies given volume to be bound to a claim and saves it to</span></p></div></div><div><div><p><span>// API server. The claim is not modified in this method!</span></p></div></div><div><div><p><span>func</span> (<span>ctrl</span> <span>*</span><span>PersistentVolumeController</span>) <span>bindVolumeToClaim</span>(<span>ctx</span> context.<span>Context</span>, <span>volume</span> <span>*</span>v1.<span>PersistentVolume</span>, <span>claim</span> <span>*</span>v1.<span>PersistentVolumeClaim</span>) (<span>*</span>v1.<span>PersistentVolume</span>, <span>error</span>) {</p></div></div><div><div><p><span>logger</span> <span>:=</span> <span>klog</span>.<span>FromContext</span>(<span>ctx</span>)</p></div></div><div><div><p><span>logger</span>.<span>V</span>(<span>4</span>).<span>Info</span>(<span>&#34;Updating PersistentVolume: binding to claim&#34;</span>, <span>&#34;PVC&#34;</span>, <span>klog</span>.<span>KObj</span>(<span>claim</span>), <span>&#34;volumeName&#34;</span>, <span>volume</span>.<span>Name</span>)</p></div></div><div><div><p><span>volumeClone</span>, <span>dirty</span>, <span>err</span> <span>:=</span> <span>storagehelpers</span>.<span>GetBindVolumeToClaim</span>(<span>volume</span>, <span>claim</span>)</p></div></div></div></div></div></div></div></div></section></div></div>
  </body>
</html>
