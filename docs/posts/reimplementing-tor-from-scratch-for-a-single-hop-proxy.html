<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://foxmoss.com/blog/kurrat/">Original</a>
    <h1>Reimplementing Tor from Scratch for a Single-Hop Proxy</h1>
    
    <div id="readability-page-1" class="page"><div data-astro-cid-bvzihdzo="">   <blockquote>
<p>All of the code in this blog post is full open source at
<a href="https://github.com/FoxMoss/kurrat/">github.com/FoxMoss/kurrat/</a></p>
</blockquote>
<p>I am a student who needs a fast VPN and doesn’t want to fork over money to a provider. I use Tor for
accessing my independently hosted email sever at school, and installing Linux packages at school.
All together pretty mundane stuff. I really don’t need the anonymity that Tor provides, I just need
a fast connection first and foremost. Tor is way slower when trying to dig through Tor nodes on my
school network, and when it does make the connection, the circuit is sub par and give quite bad
download speeds.</p>
<p>So I started off with a query: could I just connect directly to an exit node via tor?</p>
<p>I think this Stack Exchange post sums it up quite succinctly:</p>
<blockquote>
<p>No, you cannot use Tor as a single-hop proxy.</p>
<p>It was intentionally disabled in <a href="https://trac.torproject.org/projects/tor/ticket/1751">#1751 - Project: Make it harder to use exits as one-hop proxies
</a>.</p>
<p>In terms of security, you’d lose all anonymity.</p>
<p>— <em><a href="https://tor.stackexchange.com/a/15109">cacahuatl on The Tor Stack Exchange</a></em></p>
</blockquote>
<p>This annoyed me, so I wove the needle through a little farther. Brute force logic here, we’re not
bumping up against unchangeable laws of physics, we’re handling malleable connections which
basically already do what we want.</p>
<p>If we can do:</p>
<pre tabindex="0" data-language="plaintext"><code><span><span>you (client) -&gt; guard -&gt; relay -&gt; exit</span></span></code></pre>
<p>We should just be able to fork the Tor client to do this and make the connection way faster:</p>
<pre tabindex="0" data-language="plaintext"><code><span><span>you (client) -&gt; exit</span></span></code></pre>
<p>After posting this musing online it was pointed out that if I had actually read what the Stack
Exchange post I would know that this wouldn’t work. Tor blocks any client connecting to an exit node
directly on the exit node. They posted this line of code from the Tor source:</p>
<pre tabindex="0" data-language="c"><code><span><span>// connection_edge.c</span></span>
<span><span>int</span><span> connection_exit_begin_conn</span><span>(</span><span>const</span><span> relay_msg_t</span><span> *</span><span>msg, </span><span>circuit_t</span><span> *</span><span>circ) {</span></span>
<span><span>    // snip!</span></span>
<span><span>    if</span><span> ((client_chan </span><span>||</span></span>
<span><span>        (</span><span>!</span><span>connection_or_digest_is_known_relay</span><span>(or_circ</span><span>-&gt;</span><span>p_chan</span><span>-&gt;</span><span>identity_digest</span><span>) </span></span>
<span><span>        &amp;&amp;</span><span> should_refuse_unknown_exits</span><span>(options)))) {</span></span>
<span><span>        /* Don&#39;t let clients use us as a single-hop proxy. It attracts</span></span>
<span><span>        * attackers and users who&#39;d be better off with, well, single-hop</span></span>
<span><span>        * proxies. */</span></span>
<span><span>    // snip!</span></span>
<span><span>}</span></span></code></pre>
<p>Hm. A setback, but lets keep following this logic.</p>
<p>So it checks the connection’s identity digest to make sure it’s a known relay before letting it
begin a connection. Lets see what the function <code>connection_or_digest_is_known_relay</code> actually does.</p>
<pre tabindex="0" data-language="c"><code><span><span>/** Return 1 if identity digest &lt;b&gt;id_digest&lt;/b&gt; is known to be a</span></span>
<span><span> * currently or recently running relay. Otherwise return 0. */</span></span>
<span><span>int</span></span>
<span><span>connection_or_digest_is_known_relay</span><span>(</span><span>const</span><span> char</span><span> *</span><span>id_digest)</span></span>
<span><span>{</span></span>
<span><span>  if</span><span> (</span><span>router_get_consensus_status_by_id</span><span>(id_digest))</span></span>
<span><span>    return</span><span> 1</span><span>;</span><span> /* It&#39;s in the consensus: &#34;yes&#34; */</span></span>
<span><span>  if</span><span> (</span><span>router_get_by_id_digest</span><span>(id_digest))</span></span>
<span><span>    return</span><span> 1</span><span>;</span><span> /* Not in the consensus, but we have a descriptor for</span></span>
<span><span>               * it. Probably it was in a recent consensus. &#34;Yes&#34;. */</span></span>
<span><span>  return</span><span> 0</span><span>;</span></span>
<span><span>}</span></span></code></pre>
<p>Okay! So what’s stopping me from just starting a relay node and pretending like I’m forwarding a
middle node when I’m really just sending my own data.</p>
<pre tabindex="0" data-language="plaintext"><code><span><span>you (relay) -&gt; exit</span></span></code></pre>
<p>Looking again at the docs along with the code, makes me suspect they there is really no IP
checking. So as long as I have the keys I should be able to act as a relay.</p>
<blockquote>
<p>Since relays have a ramp-up time it makes sense to back up the identity key to be able to restore
your relay’s reputation after a disk failure - otherwise you would have to go through the ramp-up
phase again.</p>
<p>— <em>The Tor Project <a href="https://community.torproject.org/relay/setup/post-install/">link</a></em></p>
</blockquote>
<p>Then there should be nothing stopping me.</p>
<p>Now fully nerd sniped I began my hand reimplementation of Tor.</p>
<h2 id="implementing-tor">Implementing Tor</h2>
<p>I considered basing it off of an existing implementation, but I decided against it for a couple
reasons. Both C Tor and <a href="https://arti.torproject.org/">Arti</a> (Rust Tor) are massive codebases. Arti
is supposed to be much cleaner then C Tor but, I work the fastest in C++, and I’ll be able to debug
faster if I have a good internal model on how the entire code works instead of trying to scavenge
through someone else’s codebase. The same person who pointed out discrepancies in the first idea,
had previous vibe coded a Tor snowflake implementation but the agent failed to handle the
cryptography properly, so I knew having a good mental model here would pay dividends later on.</p>
<p>I’m not completely set on my decision, but at the end of this journey we do have a CLI app that
works quite well. More info to plan off for next time I guess.</p>
<p>I also wanted it to be fully statically compiled. “Static” here meaning able to be used without
relying on system installed libraries. Dealing with 20 different package mangers on Linux is rather
cumbersome. So all I have to do is automatically fetch dependencies if a static build is needed.
Then we just build all the dependencies and bundle it all it to the binary. This way we can just
distribute a single binary to every platform provided they all run x86.</p>
<p>To make this work I either handle dependencies my self with custom CMake build scripts, or use their
CMake scripts via <a href="https://cmake.org/cmake/help/latest/module/FetchContent.html">CMake
FetchContent</a>. But generally here the
less libraries we use the better as it cuts down build time. Here we will try to stick to just
crypto libraries early on, but by the end of the project it’s clear to make it nice an usable tool
we need some more bloat.</p>
<p>I’m getting ahead of myself. How do we actually make a connection to a Tor exit node?</p>
<h2 id="cryptography-and-then-some-more-cryptography">Cryptography and then some more cryptography</h2>
<p>To initiate a connection with an exit node you have a couple of handshakes to do.</p>
<ol>
<li>TLS</li>
</ol>
<p>For the brunt of the crypt work I picked mbedtls, I really like the library after my experience
working with it for undoing Godot encryption, and we’ll keep everything portable it’s embeded by
design.</p>
<p>A TCP stream is opened</p>
<pre tabindex="0" data-language="c"><code><span><span>    if</span><span> (</span><span>no_retry_mbedtls_net_connect</span><span>(</span><span>&amp;</span><span>tcp_net, exit_node_address.</span><span>c_str</span><span>(),</span></span>
<span><span>                                     exit_port.</span><span>c_str</span><span>(),</span></span>
<span><span>                                     MBEDTLS_NET_PROTO_TCP) </span><span>!=</span><span> 0</span><span>) {</span></span>
<span><span>        // connection failed, handle appropriately</span></span>
<span><span>    }</span></span>
<span></span></code></pre>
<p><code>no_retry_mbedtls_net_connect</code> is just a quick fork of the mbedtls net functionality to add a
timeout on connection. This is useful for handling a case when the exit node is blocked by a
firewall, the connection will just stall out.</p>
<p>Then it’s as easy as plugging in the SSL connection to the TCP connection</p>
<pre tabindex="0" data-language="c"><code><span><span>    mbedtls_ssl_set_bio</span><span>(</span><span>&amp;</span><span>ssl, </span><span>&amp;</span><span>tcp_net, mbedtls_net_send, mbedtls_net_recv,</span></span>
<span><span>                        NULL</span><span>);</span></span>
<span></span>
<span><span>    if</span><span> (</span><span>mbedtls_ssl_handshake</span><span>(</span><span>&amp;</span><span>ssl) </span><span>!=</span><span> 0</span><span>) {</span></span>
<span><span>        // handle failure</span></span>
<span><span>    }</span></span></code></pre>
<ol start="2">
<li>Versions Exchange</li>
</ol>
<p>Self explanatory, I just tell the server what versions you support. Easy peasy.</p>
<ol start="3">
<li>Certs</li>
</ol>
<p>A Tor relay’s keys folder looks like this:</p>
<pre tabindex="0" data-language="plaintext"><code><span><span>-rw------- 1  64 Dec  8 22:23 ed25519_master_id_public_key</span></span>
<span><span>-rw------- 1  96 Dec  8 22:23 ed25519_master_id_secret_key</span></span>
<span><span>-rw------- 1 172 Dec  8 22:23 ed25519_signing_cert</span></span>
<span><span>-rw------- 1  96 Dec  8 22:23 ed25519_signing_secret_key</span></span>
<span><span>-rw------- 1 888 Dec  8 22:23 secret_id_key</span></span>
<span><span>-rw------- 1 888 Dec  8 22:23 secret_onion_key</span></span>
<span><span>-rw------- 1  96 Dec  8 22:23 secret_onion_key_ntor</span></span></code></pre>
<p>Tor has two key exchange systems, Ed25519 which is the newer system and RSA which despite being
deprecated everything still seems to require.</p>
<p>These are both public key signature systems, where there’s a private key and a public key. The
public key can be used to verify a message came from a specific author, if the author attaches a
signature. The signature here is just some contortion of the message and the private key, so that it
only couldve been made with that message and that private key. Thus as long as you get the public key
from a verified stream, you can verify a new message you see as authored by a specific author.</p>
<p>The only major issue is if a sender is replaying a message it got from another author, a receiver will
have no way to tell if it’s a replayed message or if it’s a completely new message fabricated for
this connection.</p>
<p>Tor combats this in two punches. The first punch is the certs, Tor will never sign arbitrary
messages with its important keys. The “important keys” being the long term identity key and the mid
term signing key. The only key that will ever sign arbitrary data is the link key, which will be
disposed after the connection is destroyed and never used again. Once a link key is verified we can
get the next part of our handshake.</p>
<ol start="4">
<li>Verification Challenge</li>
</ol>
<p>This is the second punch, to prevent replays we need to actually verify that the link key was made
for this connection. This is done by sending an authenticate packet, which uses the link key to sign
various information about the connection to prove that yes, indeed this is the connection the link
key was made for.</p>
<p>Then and only then can we verify ourselves as the owners of a specific identity.</p>
<ol start="5">
<li>Key Exchange</li>
</ol>
<p>So we’re done? Not yet.</p>
<p>Now we need an encryption key which we’ll use to send our traffic data to the exit with. This is
totally useless when we skip other nodes but if we were to send data across a guard and a middle
node we’d prefer them to not read the data. So each jump of the network has it’s own key, that
incrementally encrypts or decrypts a message. This is where <em>Onion</em> Routing gets it’s name. Each
new layer of the onion is another layer of security, that will get slowly being peeled off.</p>
<p>We’ll gloss over the full details here but essentially each node sends the other a public key,
storing it’s own corresponding private key. With the other’s sides public key and their own private
key, both sides can generate a shared secret key with a <a href="https://en.wikipedia.org/wiki/HMAC">HMAC
algorithm</a>.</p>
<p>From there we’re done and can send encrypted relay packets to and fro.</p>
<p>So in sequence all of this looks is quite simple:</p>
<pre tabindex="0" data-language="c"><code><span><span>    generate_cert_cell</span><span>(send_buffer);</span></span>
<span></span>
<span><span>    // authenticate cell needs up to date info about our stream</span></span>
<span><span>    initiator_log.</span><span>insert</span><span>(initiator_log.</span><span>end</span><span>(), send_buffer.</span><span>begin</span><span>(),</span></span>
<span><span>                       send_buffer.</span><span>end</span><span>()); </span></span>
<span></span>
<span><span>    generate_authenticate_cell</span><span>(send_buffer, initiator_log);</span></span>
<span></span>
<span><span>    // arbitrary netinfo packet i skipped over because it has no bearing on the connection</span></span>
<span><span>    generate_netinfo_cell</span><span>(send_buffer);</span></span>
<span></span>
<span><span>    // our key exchange</span></span>
<span><span>    generate_create2_cell</span><span>(send_buffer, global_circuit_id);</span></span></code></pre>
<h2 id="starting-up-a-tor-node">Starting up a Tor node</h2>
<p>So we have a working implementation, how do we get they keys? Starting a Tor node is relatively easy
if you have a VPS. Install Tor, configure files. Thankfully the hosting provider I chose BuyVM
happens to be borderline bulletproof, and <a href="https://web.archive.org/web/20190707150046/https://www.newyorker.com/tech/annals-of-technology/the-neo-nazis-of-the-daily-stormer-wander-the-digital-wilderness">has no qualms with hosting extremist
content</a>.
I’ve been a happy customer for a while for hosting tiny networking projects and personal website at
good prices, and I was pretty blissfully unaware of their darker side when I bought the service. Luckily
their very pro-free speech pro-privacy policies comes in handy for this project:</p>
<blockquote>
<p>Frantech is a strong believer and supporter of Freedom of Speech and has taken a strong, and in
some cases very public, stance against censorship. You’re welcome to run Exit, Relay, and Bridge
nodes, just follow the rules when doing so.</p>
<p>— <em><a href="https://buyvm.net/acceptable-use-policy/">BuyVM Acceptable Use Policy</a></em></p>
</blockquote>
<p>Great for us! Not so sure about that other content, but lets carry on.</p>
<p>After waiting 0-3 days <a href="https://blog.torproject.org/lifecycle-of-a-new-relay/">(according to this blog)
</a>, your relay node gets automatically added
to the Tor consensus.</p>
<p>What exactly is the Tor consensus? In a centralized system you just have one guy, one computer
telling everyone who’s in the network. That would be nice until you find out that that one guy is a
fed. Now that one guy is telling everyone that the only nodes that exist are fed nodes. Now when you
connect through a normal circuit to whistleblow to the news the feds know whats up. Because your
guard node is in cahoots with your middle and exit node so can gain information both about what
websites you’re accessing and who you are. This is fine for our use case because we don’t care about
security, but awful for everyone else.</p>
<p>As such Tor has 9 nodes which maintain the consensus. Each get votes to make changes about the Tor
network, and all of them must agree to add or remove nodes. We really just hope every consensus node
isn’t a fed, or if they are they’re all feds from different countries, unwilling to work together.</p>
<h2 id="were-on-first">We’re on first</h2>
<p>We’ve got all of our bases covered. We have the code and the keys, does it work?</p>
<p>Surprisingly, it does. I was expecting some additional barrier I hadn’t thought of, but uh no. It just
works. So lets benchmark it.</p>
<p>Checking fast.com with just random Tor nodes from either program, you get pretty comparable speeds.</p>

























<table><thead><tr><th>Connection</th><th>Download Speed</th></tr></thead><tbody><tr><td>Kurrat</td><td>20 Mbps</td></tr><tr><td>Tor Browser</td><td>12 Mbps</td></tr><tr><td>Home Internet</td><td>81 Mbps</td></tr><tr><td>My Phone’s Hotspot</td><td>3 Mbps</td></tr></tbody></table>
<p>Of course this is a pretty rough comparison, totally changes based on node selection &amp;c, but we
beat the most important metric: it’s faster then my hotspot. I’ve been daily driving this for a
while now and I’m quite pleased with my work.</p>
<p>That about wraps what’s interesting for this project, the code was pretty straight forward
networking affair, the cryptography was what was hard to get right.</p>
<p>If you’re interested in finishing the rest of the protocol for your own learning purposes, the code
is very readable with proper errors as values.</p>
<p>So contributions, and install instruction are up:
<a href="https://github.com/FoxMoss/kurrat"><img src="https://foxmoss.com/blog/kurrat/logo.png" alt="kurrat logo"/>
Github Link
</a></p>

<p>C++ is a language that evolves with time, so if you’re just learning it or coming back to it I have
some options.</p>
<p>Avoid try catch at all costs. We can have errors as values in our code. If we’re going pure C++20
all we get is <code>std::optional</code> which is alright. Where try-catch is opaque and you have to just pray
that a function can’t fail, <code>std::optional</code> is explicit. You have to purposefully ignore it to write
code with error values.</p>
<pre tabindex="0" data-language="c"><code><span><span>std::optional</span><span>&lt;</span><span>std::pair</span><span>&lt;</span><span>std::vector</span><span>&lt;</span><span>ExitInfo</span><span>&gt;</span><span>, std::string</span><span>&gt;&gt;</span><span> grab_consensus</span><span>() {</span></span>
<span><span>    // curl networking that could fail!</span></span>
<span></span>
<span><span>    if</span><span>(response_code </span><span>!=</span><span> CURL_OK) {</span></span>
<span><span>        return</span><span> {};</span><span> // no value</span></span>
<span><span>    }</span></span>
<span><span>    </span></span>
<span><span>    // parse and return values</span></span>
<span><span>    return</span><span> exit_node_information;</span></span>
<span><span>}</span></span>
<span></span>
<span><span>void</span><span> main</span><span>() {</span></span>
<span><span>    auto exit_node_information </span><span>=</span><span> grab_consensus</span><span>()</span></span>
<span><span>    if</span><span>(</span><span>!</span><span>exit_node_information</span><span>.</span><span>has_value</span><span>()) {</span></span>
<span><span>        // print out the error and handle properly</span></span>
<span><span>        return</span><span> 1</span><span>;</span></span>
<span><span>    }</span></span>
<span><span>}</span></span></code></pre>
<p><code>std::expected</code> is the bonus version of this where you can pass back errors instead of “it didn’t
work, deal with it.” Sadly std::expected is C++23 only, which is not widely available enough for me
to consider writing code in it. Instead I use a polyfill
<a href="https://github.com/TartanLlama/expected">tl::expected</a> which is great!</p>
<pre tabindex="0" data-language="c"><code><span><span>#define</span><span> ASSERT_ZERO</span><span>(val, err)                                                  </span><span>\</span></span>
<span><span>  {                                                                            </span><span>\</span></span>
<span><span>    int</span><span> ret </span><span>=</span><span> val;                                                             </span><span>\</span></span>
<span><span>    if</span><span> (ret </span><span>!=</span><span> 0</span><span>)                                                              </span><span>\</span></span>
<span><span>      return</span><span> tl::unexpected</span><span>(</span><span>err </span><span>+</span><span> std::string</span><span>(</span><span>&#34;(error code &#34;</span><span>)</span><span> +</span><span>                \</span></span>
<span><span>                            std::to_string</span><span>(</span><span>ret</span><span>)</span><span> +</span><span> std::string</span><span>(</span><span>&#34;)&#34;</span><span>));           </span><span>\</span></span>
<span><span>  }</span></span>
<span></span>
<span><span>#define</span><span> ASSERT</span><span>(val, eql, err)                                                  </span><span>\</span></span>
<span><span>  if</span><span> (val </span><span>!=</span><span> eql) {                                                            </span><span>\</span></span>
<span><span>    return</span><span> tl::unexpected</span><span>(</span><span>err</span><span>);                                                </span><span>\</span></span>
<span><span>  }</span></span>
<span></span>
<span><span>#define</span><span> ASSERT_NOT</span><span>(val, eql, err)                                              </span><span>\</span></span>
<span><span>  if</span><span> (val </span><span>==</span><span> eql) {                                                            </span><span>\</span></span>
<span><span>    return</span><span> tl::unexpected</span><span>(</span><span>err</span><span>);                                                </span><span>\</span></span>
<span><span>  }</span></span>
<span></span>
<span><span>#define</span><span> ASSERT_NON_NULL</span><span>(val, err)                                              </span><span>\</span></span>
<span><span>  if</span><span> (val </span><span>==</span><span> NULL</span><span>) {                                                           </span><span>\</span></span>
<span><span>    return</span><span> tl::unexpected</span><span>(</span><span>err</span><span>);                                                </span><span>\</span></span>
<span><span>  }</span></span>
<span></span>
<span><span>tl::expected</span><span>&lt;</span><span>std::vector</span><span>&lt;</span><span>uint8_t</span><span>&gt;</span><span>, std::string</span><span>&gt;</span></span>
<span><span>read_ed25519_secret_key</span><span>(</span><span>char</span><span> *</span><span>ed25519_secret_key_path) {</span></span>
<span><span>  FILE </span><span>*</span><span>master_id_secret_key </span><span>=</span><span> fopen</span><span>(ed25519_secret_key_path, </span><span>&#34;rb&#34;</span><span>);</span></span>
<span></span>
<span><span>  ASSERT_NON_NULL</span><span>(master_id_secret_key, </span><span>&#34;faild to read ed25519 id key&#34;</span><span>)</span></span>
<span></span>
<span><span>  ASSERT_ZERO</span><span>(</span><span>fseek</span><span>(master_id_secret_key, </span><span>0x</span><span>20</span><span>, SEEK_SET),</span></span>
<span><span>              &#34;failed to seek id secret key&#34;</span><span>);</span></span>
<span></span>
<span><span>  std::vector</span><span>&lt;</span><span>uint8_t</span><span>&gt;</span><span> master_id_secret_key_raw;</span></span>
<span><span>  master_id_secret_key_raw</span><span>.</span><span>insert</span><span>(master_id_secret_key_raw</span><span>.</span><span>end</span><span>(),</span><span> 64</span><span>,</span><span> 0</span><span>);</span></span>
<span><span>  ASSERT</span><span>(</span><span>fread</span><span>(master_id_secret_key_raw</span><span>.</span><span>data</span><span>(), </span><span>1</span><span>, </span><span>64</span><span>, master_id_secret_key),</span></span>
<span><span>         64</span><span>, </span><span>&#34;failed to read id secret key&#34;</span><span>);</span></span>
<span><span>  fclose</span><span>(master_id_secret_key);</span></span>
<span></span>
<span><span>  return</span><span> master_id_secret_key_raw;</span></span>
<span><span>}</span></span></code></pre>
<p>One of the biggest wins I found was having the foresight to modularize basically everything. This is
an aggressively portable function. No large copies later on, just mutating input variables.</p>
<pre tabindex="0" data-language="c"><code><span><span>  void</span><span> generate_cell_fixed</span><span>(std::vector</span><span>&lt;</span><span>uint8_t</span><span>&gt;</span><span> &amp;</span><span>return_buffer,</span></span>
<span><span>                           uint16_t</span><span> circuit_id, </span><span>uint8_t</span><span> command,</span></span>
<span><span>                           std::vector</span><span>&lt;</span><span>uint8_t</span><span>&gt;</span><span> &amp;</span><span>data) {</span></span>
<span></span>
<span><span>    uint16_t</span><span> circuit_id_converted </span><span>=</span><span> htons</span><span>(circuit_id);</span></span>
<span><span>    return_buffer</span><span>.</span><span>insert</span><span>(return_buffer</span><span>.</span><span>end</span><span>(),</span><span> (</span><span>uint8_t</span><span> *</span><span>)</span><span>&amp;</span><span>circuit_id_converted</span><span>,</span></span>
<span><span>                         (</span><span>uint8_t</span><span> *</span><span>)</span><span>&amp;</span><span>circuit_id_converted </span><span>+</span><span> sizeof</span><span>(</span><span>uint16_t</span><span>));</span></span>
<span><span>    return_buffer</span><span>.</span><span>push_back</span><span>(</span><span>command</span><span>);</span></span>
<span></span>
<span><span>    uint16_t</span><span> padding </span><span>=</span><span> CELL_BODY_LEN </span><span>-</span><span> data</span><span>.</span><span>size</span><span>();</span></span>
<span><span>    return_buffer</span><span>.</span><span>insert</span><span>(return_buffer</span><span>.</span><span>end</span><span>(),</span><span> data</span><span>.</span><span>begin</span><span>(),</span><span> data</span><span>.</span><span>end</span><span>());</span></span>
<span><span>    return_buffer</span><span>.</span><span>insert</span><span>(return_buffer</span><span>.</span><span>end</span><span>(),</span><span> padding</span><span>,</span><span> 0</span><span>);</span></span>
<span><span>  }</span></span></code></pre>
<p>The modular approach gives you massive gains when writing code as you can make every other packet
generation workflow just generate the specific content for it’s type of cell then pass it through
this function.</p>
<p>Same with parsing variables from a cell. Everything just mutates a cursor from a buffer and there’s
no need to think about offsets.</p>
<pre tabindex="0" data-language="c"><code><span><span>  std::optional</span><span>&lt;</span><span>bool</span><span>&gt;</span><span> parse_cert</span><span>(std::vector</span><span>&lt;</span><span>uint8_t</span><span>&gt;</span><span> &amp;</span><span>cert_buffer,</span></span>
<span><span>                                 uint64_t</span><span> &amp;</span><span>cursor) {</span></span>
<span><span>    auto count </span><span>=</span><span> parse_uint8</span><span>(cert_buffer, cursor);</span></span>
<span><span>    if</span><span> (</span><span>!</span><span>count</span><span>.</span><span>has_value</span><span>())</span></span>
<span><span>        return</span><span> {};</span></span>
<span></span>
<span><span>    for</span><span> (</span><span>uint64_t</span><span> i </span><span>=</span><span> 0</span><span>; i </span><span>&lt;</span><span> count; i</span><span>++</span><span>) {</span></span>
<span><span>        auto cert_type </span><span>=</span><span> parse_uint8</span><span>(cert_buffer, cursor);</span></span>
<span><span>        if</span><span> (</span><span>!</span><span>cert_type</span><span>.</span><span>has_value</span><span>())</span></span>
<span><span>        return</span><span> {};</span></span>
<span></span>
<span><span>        auto cert_len </span><span>=</span><span> parse_uint16</span><span>(cert_buffer, cursor);</span></span>
<span><span>        if</span><span> (</span><span>!</span><span>cert_len</span><span>.</span><span>has_value</span><span>())</span></span>
<span><span>        return</span><span> {};</span></span>
<span></span>
<span><span>        auto cert </span><span>=</span></span>
<span><span>          parse_fixed_buffer</span><span>(cert_buffer, cursor, </span><span>ntohs</span><span>(cert_len</span><span>.</span><span>value</span><span>()));</span></span>
<span><span>        if</span><span> (</span><span>!</span><span>cert</span><span>.</span><span>has_value</span><span>())</span></span>
<span><span>        return</span><span> {};</span></span>
<span></span>
<span><span>        remote_certs</span><span>.</span><span>push_back</span><span>({cert_type</span><span>.</span><span>value</span><span>(),</span><span> cert</span><span>.</span><span>value</span><span>()});</span></span>
<span></span>
<span><span>        // handle cert</span></span>
<span></span>
<span><span>    }</span></span>
<span></span>
<span><span>    return</span><span> true</span><span>;</span></span>
<span><span>  }</span></span></code></pre>
<p>This was probably obvious to everyone who’s written a networking client before me but no one told me
that before I wrote my last packet parsers.</p>
<pre tabindex="0" data-language="c"><code><span><span>// code i wrote two years ago at https://github.com/MercuryWorkshop/Woeful/blob/main/src/packets.h</span></span>
<span><span>    InfoPacket</span><span>(</span><span>unsigned</span><span> char</span><span> *</span><span>src, </span><span>size_t</span><span> src_length) {</span></span>
<span></span>
<span><span>        // this should be src[0]</span></span>
<span><span>        major_wisp_version </span><span>=</span><span> *</span><span>(</span><span>uint8_t</span><span> *</span><span>)(src);</span></span>
<span><span>        // this should be src[1]</span></span>
<span><span>        minor_wisp_version </span><span>=</span><span> *</span><span>(</span><span>uint8_t</span><span> *</span><span>)(src </span><span>+</span><span> sizeof</span><span>(</span><span>uint8_t</span><span>));</span></span>
<span></span>
<span><span>        size_t</span><span> header_size </span><span>=</span><span> sizeof</span><span>(</span><span>uint8_t</span><span>) </span><span>+</span><span> sizeof</span><span>(</span><span>uint8_t</span><span>);</span></span>
<span><span>        unsigned</span><span> char</span><span> *</span><span>data_ptr </span><span>=</span><span> src </span><span>+</span><span> header_size;</span></span>
<span></span>
<span><span>        extension_data_len </span><span>=</span><span> src_length </span><span>-</span><span> header_size;</span></span>
<span></span>
<span><span>        // a vector would be much better suited here with little performance cost</span></span>
<span><span>        // the standard library probably knows better then we do</span></span>
<span><span>        extension_data </span><span>=</span></span>
<span><span>            std::make_unique_for_overwrite</span><span>&lt;</span><span>unsigned</span><span> char</span><span>[]</span><span>&gt;</span><span>(extension_data_len);</span></span>
<span></span>
<span><span>        memcpy</span><span>(extension_data</span><span>.</span><span>get</span><span>(), data_ptr, extension_data_len);</span></span>
<span><span>    }</span></span></code></pre>
<p>Hopefully this helps someone starting to architect their own networking project.</p>  </div></div>
  </body>
</html>
