<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://eli.thegreenplace.net/2017/on-recursion-continuations-and-trampolines/">Original</a>
    <h1>Recursion, continuations and trampolines (2017)</h1>
    
    <div id="readability-page-1" class="page"><div>
                
                <p>How is tail recursion different from regular recursion? What do continuations
have to do with this, what is CPS, and how do trampolines help? This article
provides an introduction, with code samples in Python and Clojure.</p>
<div id="recursion-and-tail-recursion">
<h2>Recursion and Tail Recursion</h2>
<p>Here&#39;s a textbook version of a recursive factorial implementation in Python:</p>
<div><pre><span></span><span>def</span> <span>fact_rec</span><span>(</span><span>n</span><span>):</span>
    <span>if</span> <span>n</span> <span>==</span> <span>0</span><span>:</span>
        <span>return</span> <span>1</span>
    <span>else</span><span>:</span>
        <span>return</span> <span>n</span> <span>*</span> <span>fact_rec</span><span>(</span><span>n</span> <span>-</span> <span>1</span><span>)</span>
</pre></div>
<p><em>Tail</em> recursion is when the recursive call happens in <em>tail position</em>, meaning
that it is the last thing the function does before returning its own result.
Here&#39;s a tail-recursive version of factorial:</p>
<div><pre><span></span><span>def</span> <span>fact_tailrec</span><span>(</span><span>n</span><span>,</span> <span>result</span><span>=</span><span>1</span><span>):</span>
    <span>if</span> <span>n</span> <span>==</span> <span>0</span><span>:</span>
        <span>return</span> <span>result</span>
    <span>else</span><span>:</span>
        <span>return</span> <span>fact_tailrec</span><span>(</span><span>n</span> <span>-</span> <span>1</span><span>,</span> <span>result</span> <span>*</span> <span>n</span><span>)</span>
</pre></div>
<p>The tail call doesn&#39;t have to be directly recursive. It can call another
function as well, implementing mutual recursion or some more complex scheme.
Here&#39;s a canonical example of mutual recursion - a silly way to tell whether a
number is odd or even:</p>
<div><pre><span></span><span>def</span> <span>is_even</span><span>(</span><span>n</span><span>):</span>
    <span>if</span> <span>n</span> <span>==</span> <span>0</span><span>:</span>
        <span>return</span> <span>True</span>
    <span>else</span><span>:</span>
        <span>return</span> <span>is_odd</span><span>(</span><span>n</span> <span>-</span> <span>1</span><span>)</span>

<span>def</span> <span>is_odd</span><span>(</span><span>n</span><span>):</span>
    <span>if</span> <span>n</span> <span>==</span> <span>0</span><span>:</span>
        <span>return</span> <span>False</span>
    <span>else</span><span>:</span>
        <span>return</span> <span>is_even</span><span>(</span><span>n</span> <span>-</span> <span>1</span><span>)</span>
</pre></div>
<p>All the function calls here are in tail position.</p>
<p>Both these examples are simple in a way, because they only contain a single
call within each function. When functions make multiple calls, things become
more challenging. Computing the Fibonacci sequence is a good example:</p>
<div><pre><span></span><span>def</span> <span>fib_rec</span><span>(</span><span>n</span><span>):</span>
    <span>if</span> <span>n</span> <span>&lt;</span> <span>2</span><span>:</span>
        <span>return</span> <span>1</span>
    <span>else</span><span>:</span>
        <span>return</span> <span>fib_rec</span><span>(</span><span>n</span> <span>-</span> <span>1</span><span>)</span> <span>+</span> <span>fib_rec</span><span>(</span><span>n</span> <span>-</span> <span>2</span><span>)</span>
</pre></div>
<p>Here we have two recursive calls to <tt>fib_rec</tt> within itself. Converting this
function to a tail-call variant will be more challenging. How about this
attempt:</p>
<div><pre><span></span><span>def</span> <span>fib_almost_tail</span><span>(</span><span>n</span><span>,</span> <span>result</span><span>=</span><span>1</span><span>):</span>
    <span>if</span> <span>n</span> <span>&lt;</span> <span>2</span><span>:</span>
        <span>return</span> <span>result</span>
    <span>prev2</span> <span>=</span> <span>fib_almost_tail</span><span>(</span><span>n</span> <span>-</span> <span>2</span><span>)</span>
    <span>return</span> <span>fib_almost_tail</span><span>(</span><span>n</span> <span>-</span> <span>1</span><span>,</span> <span>prev2</span> <span>+</span> <span>result</span><span>)</span>
</pre></div>
<p>The last thing <tt>fib_almost_tail</tt> does is call itself; so is this function
tail-recursive? No, because there&#39;s another call to <tt>fib_almost_tail</tt>, and
that one is <em>not</em> in tail position. Here&#39;s a more thorough attempt:</p>
<div><pre><span></span><span>def</span> <span>fib_tail</span><span>(</span><span>n</span><span>,</span> <span>accum1</span><span>=</span><span>1</span><span>,</span> <span>accum2</span><span>=</span><span>1</span><span>):</span>
    <span>if</span> <span>n</span> <span>&lt;</span> <span>2</span><span>:</span>
        <span>return</span> <span>accum1</span>
    <span>else</span><span>:</span>
        <span>return</span> <span>fib_tail</span><span>(</span><span>n</span> <span>-</span> <span>1</span><span>,</span> <span>accum1</span> <span>+</span> <span>accum2</span><span>,</span> <span>accum1</span><span>)</span>
</pre></div>
<p>Note that this conversion wasn&#39;t as simple as for the factorial; it&#39;s much less
obvious how to come up with the algorithm, and we even changed the number of
calls - there&#39;s only one recursive call here, while the original <tt>fib_rec</tt> had
two. Obviously, it&#39;s challenging to have no calls outside a tail position in a
function that calls multiple functions.</p>
</div>
<div id="blowing-up-the-stack">
<h2>Blowing up the stack</h2>
<p>Recursive solutions tend to be succinct and elegant; however, they carry a
dangerous burden - the possibility of blowing up the runtime stack. In Python
<a href="#footnote-1" id="footnote-reference-1">[1]</a>, the <a href="https://docs.python.org/3/library/sys.html#sys.getrecursionlimit">default call stack depth</a> is 1000. If
we try the <tt>fact_rec</tt> function shown above in a terminal, we&#39;ll get:</p>
<div><pre><span></span>&gt;&gt;&gt; fact_rec(900)
... some uselessly huge number

&gt;&gt;&gt; fact_rec(1000)
... spew ...
RecursionError: maximum recursion depth exceeded in comparison
</pre></div>
<p>You may say - who needs to compute a factorial of 1000? And that may be true;
however, with multiple recursion the problems start much earlier. If you try to
compute the 50th Fibonacci number using <tt>fib_rec</tt> as shown above, you&#39;ll end
up waiting for a <em>very</em> long time, even though the request seems modest at first
glance. The reason is the <a href="http://stackoverflow.com/questions/7547133/why-is-the-complexity-of-computing-the-fibonacci-series-2n-and-not-n2">exponential complexity of the naive implementation</a>.</p>
<p>Note that <tt>fib_tail</tt> doesn&#39;t suffer from this problem because there&#39;s no
exponential tree of calls, but it will also happily blow the stack when run with
a sufficiently large number. The same is true for <tt>fact_tail</tt>, by the way.
Tail recursion itself doesn&#39;t solve the stack issue; another ingredient is
required and we&#39;ll cover it shortly.</p>
</div>
<div id="solutions-tco-or-manual-conversion-to-iteration">
<h2>Solutions: TCO or manual conversion to iteration</h2>
<p>The problems described in the previous section help motivate the discussion of
tail calls. Why convert to tail calls at all? Because then, in some languages,
the compiler can automatically elide the stack buildup by converting the tail
call to a jump. This trick is called <em>tail-call optimization</em> (TCO) <a href="#footnote-2" id="footnote-reference-2">[2]</a>. Scheme
has been doing it since the 1970s - indeed, since Scheme encourages programmers
to write recursive algorithms, TCO is at the core of the language. More modern
languages are catching up too - Lua supports TCO and JavaScript will too, once
ES6 becomes the de-facto universal version.</p>
<p>Some languages do not support TCO, however. Python is one of those - Guido
explicitly states that <a href="http://neopythonic.blogspot.com/2009/04/tail-recursion-elimination.html">TCO is unpythonic</a> and
he doesn&#39;t want it in the language. In the end of this post I&#39;ll explain why I
think it&#39;s not a big deal for Python. For other languages, it&#39;s a much bigger
problem.</p>
<p>Take Clojure for example. Since Clojure is built on top of the JVM, it has to
use JVM semantics for calls (if it wants any speed at all). The JVM doesn&#39;t have
full support for TCO; so Clojure - a Lisp, mind you - ends up without TCO <a href="#footnote-3" id="footnote-reference-3">[3]</a>
Clojure takes a pragmatic approach and faces this problem with valor - it
encourages a manual TCO conversion using the <tt><span>loop...recur</span></tt> pair:</p>
<div><pre><span></span><span>(</span><span>defn </span><span>fib_iterative</span><span></span>
<span>  </span><span>[</span><span>n</span><span>]</span><span></span>
<span>  </span><span>(</span><span>loop </span><span>[</span><span>n</span><span> </span><span>n</span><span></span>
<span>         </span><span>accum1</span><span> </span><span>1</span><span></span>
<span>         </span><span>accum2</span><span> </span><span>1</span><span>]</span><span></span>
<span>    </span><span>(</span><span>if </span><span>(</span><span>&lt; </span><span>n</span><span> </span><span>2</span><span>)</span><span></span>
<span>      </span><span>accum1</span><span></span>
<span>      </span><span>(</span><span>recur</span><span> </span><span>(</span><span>- </span><span>n</span><span> </span><span>1</span><span>)</span><span> </span><span>(</span><span>+ </span><span>accum1</span><span> </span><span>accum2</span><span>)</span><span> </span><span>accum1</span><span>))))</span><span></span>
</pre></div>
<p>Note the similarity between this code and the Python <tt>fib_tail</tt> shown
earlier. This is not a coincidence! Once the algorithm is expressed in tail
form, it&#39;s pretty easy to convert it to an iteration pattern manually; if it
wasn&#39;t easy, compilers wouldn&#39;t be able to do it automatically for the past 40
years!</p>
<p>Just as a point of reference, here&#39;s <tt>fib_iterative</tt> in Python:</p>
<div><pre><span></span><span>def</span> <span>fib_iterative</span><span>(</span><span>n</span><span>):</span>
    <span>accum1</span><span>,</span> <span>accum2</span> <span>=</span> <span>1</span><span>,</span> <span>1</span>
    <span>while</span> <span>n</span> <span>&gt;=</span> <span>2</span><span>:</span>
        <span>n</span> <span>-=</span> <span>1</span>
        <span>accum1</span><span>,</span> <span>accum2</span> <span>=</span> <span>accum1</span> <span>+</span> <span>accum2</span><span>,</span> <span>accum1</span>
    <span>return</span> <span>accum1</span>
</pre></div>
<p>Only slightly more awkward than the Clojure version - but it&#39;s essentially the
same approach. Since the tail call carries the whole state around in arguments,
we just imitate this using an explicit loop and state variables.</p>
<p>The iterative solution is what we <em>really</em> want here - it avoids the exponential
algorithm <em>and</em> the stack explosion. It also doesn&#39;t incur the costs of a
function call and return for every iteration. The only problem is that we have
to do this manually in languages that don&#39;t support TCO. The beauty of automatic
TCO is that you can write your algorithm recursively, and get the performance &amp;
runtime characteristics of an iterative solution.</p>
<p>At this point you may wonder how to convert indirect / mutual recursion to an
iterative pattern - for example the even / odd pair above. While this doesn&#39;t
present a problem for the compiler <a href="#footnote-4" id="footnote-reference-4">[4]</a>, to do it manually is indeed more
challenging. We&#39;ll be covering this topic later in the article when we get to
trampolines.</p>
</div>
<div id="more-realistic-examples">
<h2>More realistic examples</h2>
<p>Before we get to the more advanced topics, I&#39;d like to present a few more
realistic functions with an elegant recursive formulation that would be
challenging to rewrite iteratively.</p>
<p>Let&#39;s start with merge sorting. Here&#39;s a straightforward Python implementation:</p>
<div><pre><span></span><span>def</span> <span>merge_sort</span><span>(</span><span>lst</span><span>):</span>
    <span>n</span> <span>=</span> <span>len</span><span>(</span><span>lst</span><span>)</span>
    <span>if</span> <span>n</span> <span>&lt;=</span> <span>1</span><span>:</span>
        <span>return</span> <span>lst</span>
    <span>else</span><span>:</span>
        <span>mid</span> <span>=</span> <span>int</span><span>(</span><span>n</span> <span>/</span> <span>2</span><span>)</span>
        <span>return</span> <span>merge</span><span>(</span><span>merge_sort</span><span>(</span><span>lst</span><span>[:</span><span>mid</span><span>]),</span> <span>merge_sort</span><span>(</span><span>lst</span><span>[</span><span>mid</span><span>:]))</span>

<span>def</span> <span>merge</span><span>(</span><span>lst1</span><span>,</span> <span>lst2</span><span>):</span>
    <span>&#34;&#34;&#34;Merges two sorted lists into a single sorted list.</span>

<span>    Returns new list. lst1 and lst2 are destroyed in the process.&#34;&#34;&#34;</span>
    <span>result</span> <span>=</span> <span>[]</span>
    <span>while</span> <span>lst1</span> <span>or</span> <span>lst2</span><span>:</span>
        <span>if</span> <span>not</span> <span>lst1</span><span>:</span>
            <span>return</span> <span>result</span> <span>+</span> <span>lst2</span>
        <span>elif</span> <span>not</span> <span>lst2</span><span>:</span>
            <span>return</span> <span>result</span> <span>+</span> <span>lst1</span>
        <span>if</span> <span>lst1</span><span>[</span><span>0</span><span>]</span> <span>&lt;</span> <span>lst2</span><span>[</span><span>0</span><span>]:</span>
            <span># Note: pop(0) may be slow -- this isn&#39;t optimized code.</span>
            <span>result</span><span>.</span><span>append</span><span>(</span><span>lst1</span><span>.</span><span>pop</span><span>(</span><span>0</span><span>))</span>
        <span>else</span><span>:</span>
            <span>result</span><span>.</span><span>append</span><span>(</span><span>lst2</span><span>.</span><span>pop</span><span>(</span><span>0</span><span>))</span>
    <span>return</span> <span>result</span>
</pre></div>
<p>In a way, merge sort always reminds me of <em>postorder</em> tree traversal - we
recurse to the left, then recurse to the right, then combine the results. Such
algorithms are fairly tricky to convert to non-recursive code. Try it! Chances
are you&#39;ll end up emulating a stack, or coming up with an <a href="http://stackoverflow.com/questions/1557894/non-recursive-merge-sort">entirely different
algorithm</a>.</p>
<p>Merge sort is an example of multiple recursion, which as we&#39;ve seen even for the
simple Fibonacci, presents a challenge for TCO. Another common problem is
indirect recursion. We&#39;ve seen the trivial case of even / odd. For something
more realistic consider a recursive-descent parser for this grammar:</p>
<div><pre><span></span>&lt;expr&gt;    : &lt;term&gt; + &lt;expr&gt;
            &lt;term&gt;
&lt;term&gt;    : &lt;factor&gt; * &lt;factor&gt;
            &lt;factor&gt;
&lt;factor&gt;  : &lt;number&gt;
          | &#39;(&#39; &lt;expr&gt; &#39;)&#39;
&lt;number&gt;  : \d+
</pre></div>
<p>The full Python code is <a href="https://github.com/eliben/code-for-blog/blob/main/2017/continuations-trampolines/rdparser.py">here</a>;
<tt>parse_expr</tt> calls <tt>parse_term</tt>; <tt>parse_term</tt> calls <tt>parse_factor</tt>;
<tt>parse_factor</tt>, in term, calls <tt>parse_expr</tt>. For a complex expression, the
call stack will end up containing multiple instances of each function, and at
least in theory it&#39;s unbounded.</p>
</div>
<div id="continuations-and-cps">
<h2>Continuations and CPS</h2>
<p>Continuations are a cool concept in computer science, hailing from the earliest
days of functional programming. There&#39;s tons of information online about
continuations; my modest attempt to explain them here is just the beginning! If
this looks interesting, make sure to google for more information.</p>
<p>Consider the following expression:</p>

<p>One way to reason about its evaluation is:</p>
<ol>
<li>Compute <tt>value = 3 + 4</tt></li>
<li>Then compute <tt>2 * value</tt></li>
</ol>
<p>We can view <tt>2 * value</tt> to be the <em>continuation</em> of <tt>value = 3 + 4</tt>.
Similarly, if the expression above is part of the bigger expression:</p>

<p>We can say that <tt>value + 100</tt> is the continuation of <tt>2 * (3 + 4)</tt>. This may
seem a bit abstract, so let&#39;s convert it to Lisp-y syntax <a href="#footnote-5" id="footnote-reference-5">[5]</a> to bring it back
to the domain of programming. Here is one way to compute <tt>2 * (3 + 4)</tt>:</p>
<div><pre><span></span><span>(</span><span>defn </span><span>expr</span><span></span>
<span>  </span><span>[]</span><span></span>
<span>  </span><span>(</span><span>* </span><span>2</span><span> </span><span>(</span><span>+ </span><span>3</span><span> </span><span>4</span><span>)))</span><span></span>
</pre></div>
<p>Now we can call <tt>(expr)</tt> and get 14 back. Another way to express the same
computation is:</p>
<div><pre><span></span><span>(</span><span>defn </span><span>end-cont</span><span> </span><span>[</span><span>value</span><span>]</span><span> </span><span>(</span><span>print </span><span>value</span><span>))</span><span></span>

<span>(</span><span>defn </span><span>apply-cont</span><span></span>
<span>  </span><span>[</span><span>cont</span><span> </span><span>value</span><span>]</span><span></span>
<span>  </span><span>(</span><span>cont</span><span> </span><span>value</span><span>))</span><span></span>

<span>(</span><span>defn </span><span>expr-cps</span><span></span>
<span>  </span><span>[</span><span>cont</span><span>]</span><span></span>
<span>  </span><span>(</span><span>apply-cont</span><span> </span><span>cont</span><span> </span><span>(</span><span>+ </span><span>3</span><span> </span><span>4</span><span>)))</span><span></span>

<span>(</span><span>defn </span><span>make-double-cont</span><span></span>
<span>  </span><span>[</span><span>saved-cont</span><span>]</span><span></span>
<span>  </span><span>(</span><span>fn </span><span>[</span><span>value</span><span>]</span><span></span>
<span>    </span><span>(</span><span>apply-cont</span><span> </span><span>saved-cont</span><span> </span><span>(</span><span>* </span><span>2</span><span> </span><span>value</span><span>))))</span><span></span>

<span>(</span><span>expr-cps</span><span> </span><span>(</span><span>make-double-cont</span><span> </span><span>end-cont</span><span>))</span><span></span>
</pre></div>
<p>We represent continuations as functions taking a single argument <tt>value</tt>. We
also abstract away the concept of <em>applying a continuation</em> with <tt><span>apply-cont</span></tt>.
The final continuation <tt><span>end-cont</span></tt> consumes the result of the whole computation
and prints it out. Note how continuations are composed here: we invoke
<tt><span>expr-cps</span></tt>, which expects a continuation. We use the <tt><span>make-double-cont</span></tt>
constructor to create a continuation that doubles its value. Note how this
doubling continuation works: it knows what its own continuation is, and applies
it to <tt>(* 2 value)</tt>. In fact, <tt><span>make-double-cont</span></tt> is just syntactic sugar; we
could do without it:</p>
<div><pre><span></span><span>(</span><span>expr-cps</span><span> </span><span>(</span><span>fn </span><span>[</span><span>value</span><span>]</span><span> </span><span>(</span><span>apply-cont</span><span> </span><span>end-cont</span><span> </span><span>(</span><span>* </span><span>2</span><span> </span><span>value</span><span>))))</span><span></span>
</pre></div>
<p>Now let&#39;s see how to do this for the longer expression. We keep the utilities
defined earlier and add:</p>
<div><pre><span></span><span>(</span><span>defn </span><span>make-plus100-cont</span><span></span>
<span>  </span><span>[</span><span>saved-cont</span><span>]</span><span></span>
<span>  </span><span>(</span><span>fn </span><span>[</span><span>value</span><span>]</span><span></span>
<span>    </span><span>(</span><span>apply-cont</span><span> </span><span>saved-cont</span><span> </span><span>(</span><span>+ </span><span>value</span><span> </span><span>100</span><span>))))</span><span></span>

<span>(</span><span>expr-cps</span><span> </span><span>(</span><span>make-double-cont</span><span> </span><span>(</span><span>make-plus100-cont</span><span> </span><span>end-cont</span><span>)))</span><span></span>
</pre></div>
<p>What happens in this last invocation?</p>
<ol>
<li><tt><span>expr-cps</span></tt> gets called with some continuation. It computes <tt>3 + 4</tt> and
passes the result into the continuation.</li>
<li>This continuation happens to be the doubling continuation, which applies
<tt>2 * value</tt> to its <tt>value</tt> and passes this result to its own
continuation.</li>
<li>That continuation, in turn, is a &#34;plus 100&#34; continuation: it applies <tt>value
+ 100</tt> to its <tt>value</tt> and passes the result to its own continuation.</li>
<li>The last continuation in the chain happens to be <tt><span>end-cont</span></tt>, which prints
the overall result: 114</li>
</ol>
<p>If all of this looks like a masochistic exercise in inverting the call stack
(note how the continuations are composed - from the inside out), just a bit more
patience - it will all start making sense soon. The <tt><span>-cps</span></tt> suffix of
<tt><span>expr-cps</span></tt> stands for Continuation Passing Style, by the way, which is the
style of programming we&#39;re seeing here; converting &#34;normal&#34; code into this
style is called <em>CPS-transform</em> (or <em>CPS conversion</em>).</p>
<p>The lightbulb should go on when you make the following observation: all the
expressions computed in this CPS approach are in tail position. Wait, what
does it mean? The original function computing the full expression is:</p>
<div><pre><span></span><span>(</span><span>defn </span><span>expr</span><span></span>
<span>  </span><span>[]</span><span></span>
<span>  </span><span>(</span><span>+ </span><span>(</span><span>* </span><span>2</span><span> </span><span>(</span><span>+ </span><span>3</span><span> </span><span>4</span><span>)))</span><span> </span><span>100</span><span>)</span><span></span>
</pre></div>
<p>The only tail call here is to the outermost <tt>+</tt>. Both the <tt>*</tt> and the inner
<tt>+</tt> are not in tail position. However, if you carefully examine the CPS
approach, <em>all</em> the operator calls are in tail positions - their results are
passed directly into the relevant continuations, without any changes. For this
purpose we do not count the continuation application as a function call. We&#39;re
going to be using this wonderful feature of CPS very soon to great benefit. But
first, a brief dip into theory.</p>
</div>
<div id="undelimited-and-delimited-continuations">
<h2>Undelimited and delimited continuations</h2>
<p>The formulation of <tt><span>end-cont</span></tt> I&#39;m using in the example above may appear
peculiar. It <tt>print</tt>s its value - but what if we want to do something else
with it? The strange <tt>print</tt> is a trick to emulate <em>real</em>, or <em>unbounded</em>
continuations in a language that doesn&#39;t support them <a href="#footnote-6" id="footnote-reference-6">[6]</a>. Applying unbounded
continuations is not just calling a function - it&#39;s passing control without hope
of return. Just like coroutines, or <tt>longjmp</tt> in C.</p>
<p>Unbounded continuations <em>do not return to their caller</em>. They express a flow of
computation where results flow in one direction, without ever returning.
This is getting beyond the scope of the article, but when unbounded
continuations can be treated as first-class values in a language, they become so
powerful that they can be used to implement pretty much any control-flow feature
you can imagine - exceptions, threads, coroutines and so on. This is precisely
what continuations are sometimes used for in the implementation of functional
languages, where CPS-transform is one of the compilation stages.</p>
<p>I&#39;d love to expound more on the topic, but I&#39;ll have to leave it to another day.
If you&#39;re interested, read some information online and play with a language
that supports real continuations - like Scheme with <tt>call/cc</tt>. It&#39;s fun and
scary at the same time.</p>
<p>Even though most programming languages don&#39;t support real, <em>unbounded</em>
continuations, <em>bounded</em> continuations is another deal. A <em>bounded</em> continuation
is just a function that returns to its caller. We can still use CPS but just
have to be realistic about our expectations. Applying a bounded continuation
simply means calling a function - so the stack <em>will</em> grow.</p>
<p>If we cycle back to our expression, we can stop pretending our continuations are
anything except a simulation, and just define:</p>
<div><pre><span></span><span>(</span><span>defn </span><span>end-cont</span><span> </span><span>[</span><span>value</span><span>]</span><span> </span><span>value</span><span>)</span><span></span>
</pre></div>
<p>In fact, we don&#39;t even have to pretend <tt><span>(apply-cont</span> cont value)</tt> is any
different from simply calling <tt>(cont value)</tt>, so now we can rewrite our
CPS expression much more succinctly:</p>
<div><pre><span></span><span>(</span><span>defn </span><span>real-end-cont</span><span> </span><span>[</span><span>value</span><span>]</span><span> </span><span>value</span><span>)</span><span></span>

<span>(</span><span>expr-cps</span><span> </span><span>(</span><span>fn </span><span>[</span><span>value</span><span>]</span><span></span>
<span>            </span><span>((</span><span>fn </span><span>[</span><span>value</span><span>]</span><span> </span><span>(</span><span>real-end-cont</span><span> </span><span>(</span><span>+ </span><span>value</span><span> </span><span>100</span><span>)))</span><span> </span><span>(</span><span>* </span><span>2</span><span> </span><span>value</span><span>))))</span><span></span>
</pre></div>
<p>It looks a bit weird because we could just inline the <tt>(* 2 value)</tt> into
the internal call, but keeping them separate will help us later.</p>
</div>
<div id="synthesizing-tail-calls-with-cps-transform">
<h2>Synthesizing tail calls with CPS-transform</h2>
<p>Armed with this new tool, let&#39;s revisit some of the Python functions from the
beginning of the article. For the factorial, we used an extra parameter to get a
tail-call version; for Fibonacci we needed two; for more advanced examples (like
merge sort) it wasn&#39;t very clear how to do the conversion. CPS-transform to the
rescue!</p>
<p>It turns out we can convert any function to use tail calls instead of recursion
(direct or indirect) by applying the following recipe:</p>
<ol>
<li>Pass each function an extra parameter - <tt>cont</tt>.</li>
<li>Whenever the function returns an expression that doesn&#39;t contain function
calls, send that expression to the continuation <tt>cont</tt> instead.</li>
<li>Whenever a function call occurs in a tail position, call the function with
the same continuation - <tt>cont</tt>.</li>
<li>Whenever a function call occurs in an operand (non-tail) position, instead
perform this call in a new continuation that gives a name to the result and
continues with the expression.</li>
</ol>
<p>This may not make much sense without examples. Let&#39;s review the recursive
factorial first:</p>
<div><pre><span></span><span>def</span> <span>fact_rec</span><span>(</span><span>n</span><span>):</span>
    <span>if</span> <span>n</span> <span>==</span> <span>0</span><span>:</span>
        <span>return</span> <span>1</span>                       <span># (1)</span>
    <span>else</span><span>:</span>
        <span>return</span> <span>n</span> <span>*</span> <span>fact_rec</span><span>(</span><span>n</span> <span>-</span> <span>1</span><span>)</span>     <span># (2)</span>
</pre></div>
<p>The line marked with (1) hits step 2 of the recipe; the line marked with (2)
hits step 4, since a function call (to <tt>fact_rec</tt> itself) occurs in an operand
position. Here is how we transform this function to CPS:</p>
<div><pre><span></span><span>def</span> <span>fact_cps</span><span>(</span><span>n</span><span>,</span> <span>cont</span><span>):</span>
    <span>if</span> <span>n</span> <span>==</span> <span>0</span><span>:</span>
        <span>return</span> <span>cont</span><span>(</span><span>1</span><span>)</span>
    <span>else</span><span>:</span>
        <span>return</span> <span>fact_cps</span><span>(</span><span>n</span> <span>-</span> <span>1</span><span>,</span> <span>lambda</span> <span>value</span><span>:</span> <span>cont</span><span>(</span><span>n</span> <span>*</span> <span>value</span><span>))</span>
</pre></div>
<p>The application of steps 1 and 2 is straightforward. Step 4 requires a bit more
explanation. Since the call <tt>fact_rec(n - 1)</tt> is the one occurring in operand
position, we extract it out and perform it in a new continuation. This
continuation then passes <tt>n * value</tt> to the original continuation of
<tt>fact_cps</tt>. Take a moment to convince yourself that this code does, in fact,
compute the factorial. We have to run it with the &#34;end continuation&#34; discussed
before:</p>
<div><pre><span></span>&gt;&gt;&gt; end_cont = lambda value: value
&gt;&gt;&gt; fact_cps(6, end_cont)
720
</pre></div>
<p>Now let&#39;s do the same thing for Fibonacci, which demonstrates a more complex
recursion pattern:</p>
<div><pre><span></span><span>def</span> <span>fib_rec</span><span>(</span><span>n</span><span>):</span>
    <span>if</span> <span>n</span> <span>&lt;</span> <span>2</span><span>:</span>
        <span>return</span> <span>1</span>                                 <span># (1)</span>
    <span>else</span><span>:</span>
        <span>return</span> <span>fib_rec</span><span>(</span><span>n</span> <span>-</span> <span>1</span><span>)</span> <span>+</span> <span>fib_rec</span><span>(</span><span>n</span> <span>-</span> <span>2</span><span>)</span>   <span># (2)</span>
</pre></div>
<p>Once again, applying steps 1 and 2 is trivial. Step 4 will have to applied on
line marked with (2), but twice, since we have two function calls in operand
positions. Let&#39;s handle the <tt>fib_rec(n - 1)</tt> first, similarly to what we
did for the factorial:</p>
<div><pre><span></span><span>def</span> <span>fib_cps_partial</span><span>(</span><span>n</span><span>,</span> <span>cont</span><span>):</span>
    <span>if</span> <span>n</span> <span>&lt;</span> <span>2</span><span>:</span>
        <span>return</span> <span>cont</span><span>(</span><span>1</span><span>)</span>
    <span>else</span><span>:</span>
        <span>return</span> <span>fib_cps_partial</span><span>(</span>
                <span>n</span> <span>-</span> <span>1</span><span>,</span>
                <span>lambda</span> <span>value</span><span>:</span> <span>value</span> <span>+</span> <span>fib_cps_partial</span><span>(</span><span>n</span> <span>-</span> <span>2</span><span>,</span> <span>cont</span><span>))</span>
</pre></div>
<p>All calls in <tt>fib_cps_partial</tt> are in tail position now, but there&#39;s a
problem. The continuation we crafted for the recursive call... itself has a call
not in tail position. We&#39;ll have to apply CPS-transform once again, recursively.
We&#39;ll treat the expression inside the <tt>lambda</tt> as just another function
definition to transform. Here&#39;s the final version, which is fully transformed:</p>
<div><pre><span></span><span>def</span> <span>fib_cps</span><span>(</span><span>n</span><span>,</span> <span>cont</span><span>):</span>
    <span>if</span> <span>n</span> <span>&lt;</span> <span>2</span><span>:</span>
        <span>return</span> <span>cont</span><span>(</span><span>1</span><span>)</span>
    <span>else</span><span>:</span>
        <span>return</span> <span>fib_cps</span><span>(</span>
                 <span>n</span> <span>-</span> <span>1</span><span>,</span>
                 <span>lambda</span> <span>value</span><span>:</span> <span>fib_cps</span><span>(</span>
                                 <span>n</span> <span>-</span> <span>2</span><span>,</span>
                                 <span>lambda</span> <span>value2</span><span>:</span> <span>cont</span><span>(</span><span>value</span> <span>+</span> <span>value2</span><span>)))</span>
</pre></div>
<p>And once again, it&#39;s easy to see this version contains no calls that aren&#39;t
in tail position. As opposed to the conversions shown in the beginning of the
article, this one is much less ad-hoc and follows a clear recipe. In fact, it
can be performed automatically by a compiler or a source transformation tool!</p>
<p>Just to show this is actually helpful in more general cases, let&#39;s tackle merge
sort again. We have the recursive implementation at the top of this post, with
the tricky part in the line:</p>
<div><pre><span></span><span>return</span> <span>merge</span><span>(</span><span>merge_sort</span><span>(</span><span>lst</span><span>[:</span><span>mid</span><span>]),</span> <span>merge_sort</span><span>(</span><span>lst</span><span>[</span><span>mid</span><span>:]))</span>
</pre></div>
<p>But transforming merge sort to CPS turns out not much different from
transforming Fibonacci. I won&#39;t go through the partial stage for this now, and
will just present the final answer:</p>
<div><pre><span></span><span>def</span> <span>merge_sort_cps</span><span>(</span><span>lst</span><span>,</span> <span>cont</span><span>):</span>
    <span>n</span> <span>=</span> <span>len</span><span>(</span><span>lst</span><span>)</span>
    <span>if</span> <span>n</span> <span>&lt;=</span> <span>1</span><span>:</span>
        <span>return</span> <span>cont</span><span>(</span><span>lst</span><span>)</span>
    <span>else</span><span>:</span>
        <span>mid</span> <span>=</span> <span>int</span><span>(</span><span>n</span> <span>/</span> <span>2</span><span>)</span>
        <span>return</span> <span>merge_sort_cps</span><span>(</span>
                <span>lst</span><span>[:</span><span>mid</span><span>],</span>
                <span>lambda</span> <span>v1</span><span>:</span> <span>merge_sort_cps</span><span>(</span><span>lst</span><span>[</span><span>mid</span><span>:],</span>
                                          <span>lambda</span> <span>v2</span><span>:</span> <span>cont</span><span>(</span><span>merge</span><span>(</span><span>v1</span><span>,</span> <span>v2</span><span>))))</span>
</pre></div>
<p>The <a href="https://github.com/eliben/code-for-blog/blob/main/2017/continuations-trampolines/rdparser.py">recursive-descent parser sample</a>
has an example of a more complex CPS-transform applied to realistic code, if
you&#39;re interested.</p>
</div>
<div id="trampolines-to-avoid-stack-growth-in-tail-recursive-calls">
<h2>Trampolines to avoid stack growth in tail-recursive calls</h2>
<p>Now we&#39;re ready to discuss why we want to place all calls in tail position, even
if our language doesn&#39;t support TCO. The final tool that ties things together
is <em>trampolines</em>.</p>
<p><img alt="A blue jumpy trampoline" src="https://eli.thegreenplace.net/images/2017/trampolineblue.jpg"/></p><p>... not this kind!</p>
<p>Let&#39;s borrow a definition from Wikipedia:</p>
<blockquote>
As used in some Lisp implementations, a trampoline is a loop that iteratively
invokes thunk-returning functions (continuation-passing style). A single
trampoline suffices to express all control transfers of a program; a program
so expressed is trampolined, or in trampolined style; converting a program to
trampolined style is trampolining. Programmers can use trampolined functions
to implement tail-recursive function calls in stack-oriented programming
languages.</blockquote>
<p>But wait, what&#39;s a &#34;thunk-returning function&#34;?</p>
<p>A thunk, in programming language jargon, is simply some expression wrapped in an
argument-less function. This wrapping <em>delays</em> the evaluation of the expression
until the point at which the function is called:</p>
<div><pre><span></span><span>&gt;&gt;&gt;</span> <span>2</span> <span>*</span> <span>(</span><span>3</span> <span>+</span> <span>4</span><span>)</span>
<span>14</span>
<span>&gt;&gt;&gt;</span> <span>thunk</span> <span>=</span> <span>lambda</span><span>:</span> <span>2</span> <span>*</span> <span>(</span><span>3</span> <span>+</span> <span>4</span><span>)</span>
<span>&gt;&gt;&gt;</span> <span>thunk</span>
<span>&lt;</span><span>function</span> <span>&lt;</span><span>lambda</span><span>&gt;</span> <span>at</span> <span>0x7f2c2977c510</span><span>&gt;</span>
<span>&gt;&gt;&gt;</span> <span>thunk</span><span>()</span>
<span>14</span>
</pre></div>
<p>This example shows how we ask the interpreter to evaluate an expression. Then,
we wrap it in a thunk: in Python simply a <tt>lambda</tt> with no arguments. The
thunk itself is just a function. But when we call the thunk, the expression is
actually evaluated. Thunks can be used to emulate <a href="https://en.wikipedia.org/wiki/Lazy_evaluation">Lazy Evaluation</a> in languages that don&#39;t
support it by default (like Python, or Clojure). But for our uses in this post,
thunks are an essential part of the solution to the stack explosion problem.</p>
<p>The missing part of the puzzle is this:</p>
<div><pre><span></span><span>def</span> <span>trampoline</span><span>(</span><span>f</span><span>,</span> <span>*</span><span>args</span><span>):</span>
    <span>v</span> <span>=</span> <span>f</span><span>(</span><span>*</span><span>args</span><span>)</span>
    <span>while</span> <span>callable</span><span>(</span><span>v</span><span>):</span>
        <span>v</span> <span>=</span> <span>v</span><span>()</span>
    <span>return</span> <span>v</span>
</pre></div>
<p>The <em>trampoline</em> is a Python function. It takes a function and a sequence of
arguments, and applies the function to the arguments. Nothing more exciting than
delayed evaluation so far. But there&#39;s more. If the function returns a callable,
the trampoline assumes it&#39;s a thunk and calls it. And so on, until the function
returns somethings that&#39;s no longer callable <a href="#footnote-7" id="footnote-reference-7">[7]</a>.</p>
<p>Remember how I said, when discussing unbounded continuations, that in &#34;regular&#34;
languages like Python we&#39;re just cheating and simulating continuations with
function calls? Trampolines is what make this viable without blowing the stack.
Let&#39;s see how. Here&#39;s our CPS version of factorial, transformed once again to
return a thunk:</p>
<div><pre><span></span><span>def</span> <span>fact_cps_thunked</span><span>(</span><span>n</span><span>,</span> <span>cont</span><span>):</span>
    <span>if</span> <span>n</span> <span>==</span> <span>0</span><span>:</span>
        <span>return</span> <span>cont</span><span>(</span><span>1</span><span>)</span>
    <span>else</span><span>:</span>
        <span>return</span> <span>lambda</span><span>:</span> <span>fact_cps_thunked</span><span>(</span>
                         <span>n</span> <span>-</span> <span>1</span><span>,</span>
                         <span>lambda</span> <span>value</span><span>:</span> <span>lambda</span><span>:</span> <span>cont</span><span>(</span><span>n</span> <span>*</span> <span>value</span><span>))</span>
</pre></div>
<p>In this case the transformation is straightforward: we just wrap the tail calls
in an argument-less <tt>lambda</tt> <a href="#footnote-8" id="footnote-reference-8">[8]</a>. To invoke this function properly, we have
to use a trampoline. So, to compute the factorial of 6, we&#39;ll do:</p>
<div><pre><span></span><span>&gt;&gt;&gt;</span> <span>trampoline</span><span>(</span><span>fact_cps_thunked</span><span>,</span> <span>6</span><span>,</span> <span>end_cont</span><span>)</span>
<span>720</span>
</pre></div>
<p>Now comes the bang! If you carefully trace the execution of this trampoline,
you&#39;ll immediately note that <em>the stack doesn&#39;t grow</em>! Instead of calling
itself, <tt>fact_cps_thunked</tt> returns a thunk, so the call is done by the
trampoline. Indeed, if we trace the function calls for the recursive factorial
we get:</p>
<div><pre><span></span>fact_rec(6)
  fact_rec(5)
    fact_rec(4)
      fact_rec(3)
        fact_rec(2)
          fact_rec(1)
            fact_rec(0)
</pre></div>
<p>But if we do the same for the thunked version, we get:</p>
<div><pre><span></span>trampoline(&lt;callable&gt;, 6, &lt;callable&gt;)
  fact_cps_thunked(6, &lt;callable&gt;)
  fact_cps_thunked(5, &lt;callable&gt;)
  fact_cps_thunked(4, &lt;callable&gt;)
  fact_cps_thunked(3, &lt;callable&gt;)
  fact_cps_thunked(2, &lt;callable&gt;)
  fact_cps_thunked(1, &lt;callable&gt;)
  fact_cps_thunked(0, &lt;callable&gt;)
</pre></div>
<p>Remember how, earlier in the post, we&#39;ve discovered the maximum stack depth of
Python by invoking <tt>fact_rec(1000)</tt> and observing it blow up? No such problem
with the thunked version:</p>
<div><pre><span></span>&gt;&gt;&gt; trampoline(fact_cps_thunked, 1000, end_cont)
... number with 2568 digits

&gt;&gt;&gt; trampoline(fact_cps_thunked, 2000, end_cont)
... number with 5736 digits
</pre></div>
<p>The <a href="https://github.com/eliben/code-for-blog/blob/main/2017/continuations-trampolines/fib.py">full Fibonacci sample</a>
shows how to use thunks and trampolines to compute the Fibonacci sequence
without growing the stack.</p>
<p>I hope the pieces have fallen into place by now. By using a combination of CPS
and trampolines, we&#39;ve taken arbitrary recusive functions and converted them
to tail-recursive versions that consume only a bounded number of stack frames.
All of this <em>in a language without TCO support</em>.</p>
</div>
<div id="trampolines-for-mutual-recursion">
<h2>Trampolines for mutual recursion</h2>
<p>If you&#39;re left wondering how realistic this is, let&#39;s go back to the topic of
mutual recursion. As I&#39;ve mentioned before, Clojure doesn&#39;t support TCO, even
though it&#39;s a Lisp. To overcome this, the recommended programming style in
Clojure is explicit <tt><span>loop...recur</span></tt> iteration, which makes tail-recursive
algorithms relatively easy (and efficient) to express. But this still leaves
Clojure with the problem of mutual or indirect recursion, where <tt><span>loop...recur</span></tt>
doesn&#39;t help.</p>
<p>Here&#39;s that silly even/odd example again, this time in Clojure:</p>
<div><pre><span></span><span>(</span><span>declare </span><span>is-even?</span><span>)</span><span></span>

<span>(</span><span>defn </span><span>is-odd?</span><span></span>
<span>  </span><span>[</span><span>n</span><span>]</span><span></span>
<span>  </span><span>(</span><span>if </span><span>(</span><span>= </span><span>n</span><span> </span><span>0</span><span>)</span><span></span>
<span>    </span><span>false</span><span></span>
<span>    </span><span>(</span><span>is-even?</span><span> </span><span>(</span><span>- </span><span>n</span><span> </span><span>1</span><span>))))</span><span></span>

<span>(</span><span>defn </span><span>is-even?</span><span></span>
<span>  </span><span>[</span><span>n</span><span>]</span><span></span>
<span>  </span><span>(</span><span>if </span><span>(</span><span>= </span><span>n</span><span> </span><span>0</span><span>)</span><span></span>
<span>    </span><span>true</span><span></span>
<span>    </span><span>(</span><span>is-odd?</span><span> </span><span>(</span><span>- </span><span>n</span><span> </span><span>1</span><span>))))</span><span></span>
</pre></div>
<p>We can&#39;t get rid of the tail recursion here with <tt><span>loop...recur</span></tt>. But Clojure
solves the problem by offering <tt>trampoline</tt> in the <a href="https://clojuredocs.org/clojure.core/trampoline">language core</a>! Here&#39;s a thunked version:</p>
<div><pre><span></span><span>(</span><span>declare </span><span>is-even-thunked?</span><span>)</span><span></span>

<span>(</span><span>defn </span><span>is-odd-thunked?</span><span></span>
<span>  </span><span>[</span><span>n</span><span>]</span><span></span>
<span>  </span><span>(</span><span>if </span><span>(</span><span>= </span><span>n</span><span> </span><span>0</span><span>)</span><span></span>
<span>    </span><span>false</span><span></span>
<span>    </span><span>#</span><span>(</span><span>is-even-thunked?</span><span> </span><span>(</span><span>- </span><span>n</span><span> </span><span>1</span><span>))))</span><span></span>

<span>(</span><span>defn </span><span>is-even-thunked?</span><span></span>
<span>  </span><span>[</span><span>n</span><span>]</span><span></span>
<span>  </span><span>(</span><span>if </span><span>(</span><span>= </span><span>n</span><span> </span><span>0</span><span>)</span><span></span>
<span>    </span><span>true</span><span></span>
<span>    </span><span>#</span><span>(</span><span>is-odd-thunked?</span><span> </span><span>(</span><span>- </span><span>n</span><span> </span><span>1</span><span>))))</span><span></span>
</pre></div>
<p>To invoke it:</p>
<div><pre><span></span>=&gt; (trampoline is-even-thunked? 3)
false
</pre></div>
<p>Note how small the difference from the non-thunked version is. This is due to
Clojure&#39;s awesome syntax for anonymous functions, where a thunk is simply
<tt><span>#(...)</span></tt>.</p>
<p>Clojure&#39;s own implementation of <tt>trampoline</tt> is about what we&#39;d expect. Here
it is, pasted in full, including its educational docstring:</p>
<div><pre><span></span><span>(</span><span>defn </span><span>trampoline</span><span></span>
<span>  </span><span>&#34;trampoline can be used to convert algorithms requiring mutual</span>
<span>  recursion without stack consumption. Calls f with supplied args, if</span>
<span>  any. If f returns a fn, calls that fn with no arguments, and</span>
<span>  continues to repeat, until the return value is not a fn, then</span>
<span>  returns that non-fn value. Note that if you want to return a fn as a</span>
<span>  final value, you must wrap it in some data structure and unpack it</span>
<span>  after trampoline returns.&#34;</span><span></span>
<span>  </span><span>{</span><span>:added</span><span> </span><span>&#34;1.0&#34;</span><span></span>
<span>   </span><span>:static</span><span> </span><span>true</span><span>}</span><span></span>
<span>  </span><span>([</span><span>f</span><span>]</span><span></span>
<span>     </span><span>(</span><span>let </span><span>[</span><span>ret</span><span> </span><span>(</span><span>f</span><span>)]</span><span></span>
<span>       </span><span>(</span><span>if </span><span>(</span><span>fn?</span><span> </span><span>ret</span><span>)</span><span></span>
<span>         </span><span>(</span><span>recur</span><span> </span><span>ret</span><span>)</span><span></span>
<span>         </span><span>ret</span><span>)))</span><span></span>
<span>  </span><span>([</span><span>f</span><span> </span><span>&amp;</span><span> </span><span>args</span><span>]</span><span></span>
<span>(</span><span>trampoline</span><span> </span><span>#</span><span>(</span><span>apply </span><span>f</span><span> </span><span>args</span><span>))))</span><span></span>
</pre></div>
</div>
<div id="back-to-reality">
<h2>Back to reality</h2>
<p>While the tools described in this post can (and do) serve as building blocks for
some compilers of functional languages, how relevant are they to day-to-day
programming in languages like Python and Clojure?</p>
<p>The answer is, IMHO, not <em>very</em>, but they&#39;re still worth knowing about. For
Clojure, quite obviously Rich Hickey found trampolines important enough to
include them in the language. Since Clojure is not TCO&#39;d and <tt><span>loop...recur</span></tt> is
only good for direct recursion, some solution had to be offered for
mutual/indirect recursion. But how often would you use it anyway?</p>
<p>Algorithms like merge-sort, or any tree-like traversal, tend to be fine just
with regular recursion because the supported depth is more than sufficient.
Because of the logarithmic nature of depth vs. total problem size, you&#39;re
unlikely to recurse into merge-sort more than a few dozen times. An array
needing just 30 divisions has to contain about a billion items.</p>
<p>The same is true for recursive-descent parsing, since realistic expressions get
only so large. However, with some algorithms like graph traversals we definitely
have to be more careful.</p>
<p>Another important use case is state machines, which may be conveniently
expressed with indirect recursive calls for state transitions. Here&#39;s a <a href="https://github.com/eliben/code-for-blog/blob/main/2017/continuations-trampolines/statemachine.py">code
sample</a>.
Guido mentions this problem in <a href="http://neopythonic.blogspot.com/2009/04/final-words-on-tail-calls.html">his post on TCO in Python</a>, and
actually suggests trampolined tail-calls as a possible solution.</p>
</div>
<div id="python-generators-and-coroutines-as-an-alternative">
<h2>Python generators and coroutines as an alternative</h2>
<p>That said, I personally believe that Python offers better ways to solve these
problems. I&#39;ve <a href="https://eli.thegreenplace.net/2009/08/29/co-routines-as-an-alternative-to-state-machines">written before</a>
about using coroutines for modeling state machines. Since then, Python grew more
supportive features - I&#39;ve written about using <tt>yield from</tt> to <a href="https://eli.thegreenplace.net/2012/08/09/using-sub-generators-for-lexical-scanning-in-python/">implement
lexical scanning</a>,
for example, and similar techniques can be adapted for parsing.</p>
<p>In Python 3.5, <a href="https://docs.python.org/3/library/asyncio-task.html">even more features</a> were added to support
coroutines. I plan to find some time to dig in these and write more about them.</p>
<p>All of this is to say that I wouldn&#39;t find much use for direct expression of CPS
and trampolines in Python code these days. But I may be wrong! Please feel free
to make suggestions in the comments or by email - I&#39;ll be really curious to know
about realistic use cases where these techniques could be employed in modern
Python.</p>
<p>Regardless of their usefulness in modern Python, these topics are fascinating
and I feel they improve my understanding of how some programming languages work
under the hood.</p>
<hr/>








</div>

            </div></div>
  </body>
</html>
