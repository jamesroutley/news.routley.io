<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.iankduncan.com/engineering/2025-11-27-crdt-dictionary/">Original</a>
    <h1>The CRDT Dictionary: A Field Guide to Conflict-Free Replicated Data Types</h1>
    
    <div id="readability-page-1" class="page"><div>   <p>Back around 2014, I kept hearing about this cool database called <a href="https://riak.com/">Riak</a>, a distributed database that could survive network partitions and keep accepting writes. Some really interesting companies were using it at massive scale, and I was curious about it. One of the big selling points was that it could handle concurrent writes without any coordination or consensus. I was intrigued, and I started reading about it. Underlying all of this was the concept of CRDTs, Conflict-free Replicated Data Types.<sup><a href="#user-content-fn-crdt-origin" id="user-content-fnref-crdt-origin" data-footnote-ref="" aria-describedby="footnote-label">1</a></sup></p>
<p>At the time, I was working on a beer startup called Brewtown with a friend: a beer review social site and delivery subscription service. It failed for other reasons, but I was a little too enamored with shiny tech back then, and CRDTs and Riak fit the bill for shiny tech. I kept trying to find excuses to shoehorn CRDT stuff into our codebase when, honestly, we didn’t need any of it. Postgres would’ve been fine. Live and learn.</p>
<p>Anyways, the idea sounded like pure sorcery: data structures that replicate across nodes and merge deterministically, without coordination, without losing information. I got excited, read a few papers, played with some toy implementations… and then we gave up on the beer startup. I didn’t really have a reason to mess with CRDTs for a while.</p>
<p>Fast forward to 2025, I’ve just had Thanksgiving dinner, and I’m curious again. What’s the state of the art? What have I forgotten? Which CRDT should I reach for when? So I’m writing this, both as a refresher for myself and a reference for the next time I need to remember why OR-Sets exist or what WOOT stands for. (“WithOut Operational Transformation.” Yes, really.<sup><a href="#user-content-fn-woot-paper" id="user-content-fnref-woot-paper" data-footnote-ref="" aria-describedby="footnote-label">2</a></sup>)</p>
<p>So, grab a coffee.</p>
<p>Commutative. Replicated. Data Types.</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/g92-vC9iTn8?si=egtFeVe21g8SVrOm" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe>
<p>In isolation, all of the words make sense. But when you look at the literature, it’s overwhelming:</p>
<p>Suddenly you’ve moved beyond the simple terms and start seeing things like G-Counters, PN-Counters, LWW-Sets, OR-Sets, 2P-Sets, RGAs, WOOTs, Logoots (wtf?)… Each with subtle tradeoffs. Each paper assuming you’ve read the previous five. It’s overwhelming.</p>
<p>This guide will hopefully cut through that. We’ll build intuition through <strong>interactive demos</strong> and concrete examples. You’ll see how merges actually work, watch conflicts resolve (or not resolve), and develop a feel for which CRDT fits which problem.</p>
<h2 id="what-you-need-to-know">What You Need to Know</h2>
<p>You don’t need a PhD in distributed systems. If you understand:</p>
<ul>
<li>Why network failures happen</li>
<li>What “eventual consistency” means</li>
<li>Basic set operations (union, intersection)</li>
</ul>
<p>…you’re good.</p>
<h2 id="the-problem">The Problem</h2>
<p>Picture this: Alice and Bob are both editing a shared counter. Alice increments it. Bob increments it. The network is flaky, so neither sees the other’s change immediately. Later, they reconnect. What should the counter show?</p>
<p><strong>Option 1: Consensus</strong> - Use Paxos/Raft to agree on who went first. Works great! Until the network partitions and half your users can’t write because they can’t reach a quorum. Not ideal for offline-first apps.</p>
<p><strong>Option 2: Last-Write-Wins</strong> - Use timestamps. Whoever wrote last “wins.” Easy to implement! Except Bob’s increment gets completely erased if Alice’s timestamp was later. Data loss.</p>
<p><strong>Option 3: CRDTs</strong> - Design the data structure so that merging is deterministic. Both increments survive. No coordination needed. No data loss. However, you have to be okay with some level of eventual consistency.</p>
<p>What’s the trick? How do CRDTs achieve this?</p>
<p>Roughly speaking, you are working with a CRDT if your merge operation is:</p>
<ul>
<li>commutative (order doesn’t matter)</li>
<li>associative (grouping doesn’t matter)</li>
<li>idempotent (duplicates don’t matter)</li>
</ul>
<p>Once you achieve these properties, then you can use your merge operation to ensure that replicas automatically converge to the same state.</p>
<h3 id="a-quick-detour-lattices-and-why-they-matter">A Quick Detour: Lattices and Why They Matter</h3>
<p>Before we dive into specific CRDTs, let’s build some intuition about what makes merging work. In CRDT literature, this is often referred to as a “lattice”.</p>
<p>Think about natural numbers with <code>max</code> as the merge operation. If you have <code>3</code> and <code>5</code>, taking <code>max(3, 5) = 5</code> makes sense. It doesn’t matter if you compute <code>max(3, max(5, 7))</code> or <code>max(max(3, 5), 7)</code> - you get <code>7</code> either way. And <code>max(5, 5) = 5</code>, so duplicates are harmless.</p>
<p>This forms a <strong>partial order</strong>: some values are “greater than” others (<code>5 &gt; 3</code>), and there’s a <strong>join</strong> operation (<code>max</code>) that gives you the least upper bound. The fancy math term is “join-semilattice,” but think of it as: <strong>a way to consistently pick “more recent” or “more complete” information</strong>.</p>
<p>Here’s the key insight: if your data structure’s states form a lattice, and updates only move “upward” in the ordering, then:</p>
<ul>
<li>You can apply updates in any order</li>
<li>You can apply the same update twice</li>
<li>Eventually, everyone agrees on the maximum state</li>
</ul>
<p>Consider a counter where each replica tracks its own count: <code>{A: 3, B: 5}</code>. The partial order is <strong>pointwise</strong>: <code>{A: 3, B: 5} ≥ {A: 2, B: 5}</code> because each component is greater-or-equal. To join, take the <code>max</code> of each component. This is exactly how the G-Counter CRDT works!</p>
<p><strong>Why does this matter?</strong> Because if you can design your data structure so that:</p>
<ol>
<li>States form a lattice (there’s always a sensible “join”)</li>
<li>Operations only move upward (you can’t un-increment a counter)</li>
</ol>
<p>Then merging becomes trivial: just take the join. No coordination needed. No conflicts possible. The math guarantees convergence.</p>
<p>Not all CRDTs fit this clean model (some need timestamps or version vectors to determine what’s “greater”), but the lattice intuition often guides the design. When you see <code>merge = unionWith max</code> or <code>merge = union</code>, you’re seeing some pure, beautiful math-brained lattice thinking.</p>
<h3 id="state-based-vs-operation-based">State-Based vs Operation-Based</h3>
<p>Moving on…</p>
<p>There are two fundamental approaches to CRDTs:</p>
<p><strong>State-based CRDTs (CvRDTs)</strong> send the entire state to other replicas, which merge it with their local state using a join operation. The state must form a join-semilattice.<sup><a href="#user-content-fn-cvcrdt" id="user-content-fnref-cvcrdt" data-footnote-ref="" aria-describedby="footnote-label">3</a></sup></p>
<p><strong>Operation-based CRDTs (CmRDTs)</strong> send operations to other replicas, which apply them to their local state. Operations must be commutative when applied concurrently.<sup><a href="#user-content-fn-cmcrdt" id="user-content-fnref-cmcrdt" data-footnote-ref="" aria-describedby="footnote-label">4</a></sup></p>
<p>In this guide, we’ll primarily discuss state-based CRDTs, as they’re conceptually simpler and the ideas translate naturally to the operation-based variants.</p>
<h3 id="the-core-laws">The Core Laws</h3>
<p>For a data structure to be a state-based CRDT, its merge operation must satisfy:</p>
<p><strong>Associativity</strong>: <code>(a ⊔ b) ⊔ c = a ⊔ (b ⊔ c)</code> where <code>⊔</code> denotes the merge/join operation</p>
<p><strong>Commutativity</strong>: <code>a ⊔ b = b ⊔ a</code></p>
<p><strong>Idempotence</strong>: <code>a ⊔ a = a</code></p>
<p>These properties ensure that:</p>
<ul>
<li>Merging in any order produces the same result</li>
<li>Re-receiving the same state is harmless</li>
<li>Partial merges can be composed</li>
</ul>
<p>Additionally, the state must form a <strong>monotonic semilattice</strong>: updates only move “upward” in the partial order, never downward. This ensures convergence: once all updates have been delivered, all replicas reach the same state.</p>
<p>For the curious, The symbol ⊔ is called (square cup) or square union. I have no idea why regular union symbol isn’t used. Pointy-headed researchers, I guess.</p>
<p>Anyways, it’s commonly used to denote:</p>
<ul>
<li>Disjoint union - union of sets treated as disjoint</li>
<li>Join operation in lattice theory - the least upper bound (supremum) of two elements</li>
<li>Merge operation in CRDTs - combining two states by taking their least upper bound</li>
</ul>
<p>With these foundations in place, let’s explore the CRDT zoo.</p>
<h2 id="g-counter-grow-only-counter">G-Counter: Grow-Only Counter</h2>
<p>Let’s start with the simplest CRDT: a counter that only goes up.<sup><a href="#user-content-fn-gcounter-origin" id="user-content-fnref-gcounter-origin" data-footnote-ref="" aria-describedby="footnote-label">5</a></sup></p>
<h3 id="the-idea">The Idea</h3>
<p>Instead of storing one global count, each replica tracks its own count. The total is the sum of all replica counts. When replicas merge, they take the <code>max</code> of each replica’s count.</p>
<p>Why <code>max</code>? Because counts only increase. If replica A shows that replica B has counted to 5, and replica B shows it’s counted to 3, we know A has seen newer information. Taking the max ensures we never lose increments.<sup><a href="#user-content-fn-gcounter-space" id="user-content-fnref-gcounter-space" data-footnote-ref="" aria-describedby="footnote-label">6</a></sup></p>
<h3 id="implementation">Implementation</h3>
<pre tabindex="0" data-language="haskell"><code><span><span>type</span><span> GCounter</span><span> =</span><span> Map</span><span> ReplicaId</span><span> Nat</span></span>
<span></span>
<span><span>value</span><span> ::</span><span> GCounter</span><span> -&gt;</span><span> Nat</span></span>
<span><span>value counter </span><span>=</span><span> sum (Map.elems counter)</span></span>
<span></span>
<span><span>increment</span><span> ::</span><span> ReplicaId</span><span> -&gt;</span><span> GCounter</span><span> -&gt;</span><span> GCounter</span></span>
<span><span>increment r counter </span><span>=</span><span> Map.insertWith (</span><span>+</span><span>) r </span><span>1</span><span> counter</span></span>
<span></span>
<span><span>merge</span><span> ::</span><span> GCounter</span><span> -&gt;</span><span> GCounter</span><span> -&gt;</span><span> GCounter</span></span>
<span><span>merge </span><span>=</span><span> Map.unionWith max</span></span></code></pre>
<h3 id="laws-and-invariants">Laws and Invariants</h3>
<p>The merge operation forms a join-semilattice where the partial order is defined pointwise: <code>c1 ≤ c2</code> if for all replicas <code>r</code>, <code>c1[r] ≤ c2[r]</code>.</p>
<ul>
<li><strong>Associative</strong>: <code>max</code> is associative</li>
<li><strong>Commutative</strong>: <code>max</code> is commutative</li>
<li><strong>Idempotent</strong>: <code>max(x, x) = x</code></li>
<li><strong>Monotonic</strong>: Each replica’s count only increases</li>
</ul>
<h3 id="intuition">Intuition</h3>
<p>Think of each replica as having its own tally marks. When replicas sync, they each adopt the maximum tally for each replica they’ve seen. Since tallies only grow, taking the maximum ensures we never lose increments.</p>
<h3 id="tradeoffs">Tradeoffs</h3>
<p><strong>Advantages</strong>:</p>
<ul>
<li>Simple and efficient</li>
<li>No metadata overhead beyond replica counts</li>
<li>Perfect for increment-only scenarios (page views, likes, etc.)</li>
</ul>
<p><strong>Disadvantages</strong>:</p>
<ul>
<li>Cannot decrement</li>
<li>Size grows with number of replicas (though typically small)</li>
<li>No garbage collection (all replica counts retained forever)</li>
</ul>
<h3 id="when-to-use">When to Use</h3>
<p>Use G-Counter when you need to count upward-only events in a distributed system: analytics counters, like counts, view counts, or any monotonically increasing metric. (If you need to decrement, well… keep reading.)</p>
<h3 id="interactive-demo">Interactive Demo</h3>
<p>Try it yourself! Increment counters on different replicas and see how the merge operation works:</p>
<astro-island uid="Z1h8Xr8" prefix="r0" component-url="/_astro/GCounterDemo.BSvnoCcc.js" component-export="default" renderer-url="/_astro/client.JDWrnR5R.js" props="{}" ssr="" client="load" opts="{&#34;name&#34;:&#34;GCounterDemo&#34;,&#34;value&#34;:true}" await-children=""><!--astro:end--></astro-island>
<h2 id="pn-counter-positive-negative-counter">PN-Counter: Positive-Negative Counter</h2>
<p>What if we need to decrement? Enter the PN-Counter. The trick is beautifully simple.</p>
<h3 id="definition">Definition</h3>
<p>A PN-Counter contains two G-Counters: one for increments, one for decrements:</p>
<pre tabindex="0" data-language="haskell"><code><span><span>data</span><span> PNCounter</span><span> =</span><span> PNCounter</span></span>
<span><span>  { increments </span><span>::</span><span> GCounter</span></span>
<span><span>  , decrements </span><span>::</span><span> GCounter</span></span>
<span><span>  }</span></span></code></pre>
<p>The value is the difference:</p>
<pre tabindex="0" data-language="plaintext"><code><span><span>value :: PNCounter -&gt; Int</span></span>
<span><span>value (PNCounter inc dec) = value inc - value dec</span></span></code></pre>
<p>What I love about PN-Counters as a broader insight for CRDTs is that you can often build more complex CRDTs by combining simpler ones.</p>
<h3 id="operations">Operations</h3>
<p><strong>Increment</strong> (on replica <code>r</code>):</p>
<pre tabindex="0" data-language="plaintext"><code><span><span>increment r (PNCounter inc dec) = PNCounter (increment r inc) dec</span></span></code></pre>
<p><strong>Decrement</strong> (on replica <code>r</code>):</p>
<pre tabindex="0" data-language="plaintext"><code><span><span>decrement r (PNCounter inc dec) = PNCounter inc (increment r dec)</span></span></code></pre>
<p><strong>Merge</strong>:</p>
<pre tabindex="0" data-language="plaintext"><code><span><span>merge (PNCounter i1 d1) (PNCounter i2 d2) =</span></span>
<span><span>  PNCounter (merge i1 i2) (merge d1 d2)</span></span></code></pre>
<h3 id="laws-and-invariants-1">Laws and Invariants</h3>
<p>Since both components are G-Counters with valid merge operations, the PN-Counter’s merge inherits their properties and forms a semilattice.</p>
<h3 id="intuition-1">Intuition</h3>
<p>A PN-Counter is like having two separate tally sheets: one for additions, one for subtractions. The current value is the difference between them. When replicas sync, they merge both sheets independently.</p>
<h3 id="tradeoffs-1">Tradeoffs</h3>
<p><strong>Advantages</strong>:</p>
<ul>
<li>Supports both increment and decrement</li>
<li>Deterministic convergence</li>
<li>Simple to understand and implement</li>
</ul>
<p><strong>Disadvantages</strong>:</p>
<ul>
<li>Double the space of a G-Counter</li>
<li>Can never truly garbage collect old replica entries</li>
<li>No bound on the value range (can overflow)</li>
<li>Cannot reset the counter atomically</li>
</ul>
<h3 id="when-to-use-1">When to Use</h3>
<p>Use PN-Counter for any metric that can increase or decrease over time: inventory counts, resource pools, etc.</p>
<h3 id="variants">Variants</h3>
<p>Some implementations use a single map with integer values instead of two separate maps, but the principle is the same.</p>
<h2 id="g-set-grow-only-set">G-Set: Grow-Only Set</h2>
<p>Moving from numbers to collections, we consider the simplest CRDT set.</p>
<h3 id="definition-1">Definition</h3>
<p>A G-Set is simply a set that supports addition but not removal:</p>
<pre tabindex="0" data-language="haskell"><code><span><span>type</span><span> GSet</span><span> a </span><span>=</span><span> Set</span><span> a</span></span></code></pre>
<h3 id="operations-1">Operations</h3>
<p><strong>Add</strong>:</p>
<pre tabindex="0" data-language="haskell"><code><span><span>add</span><span> ::</span><span> Ord</span><span> a </span><span>=&gt;</span><span> a </span><span>-&gt;</span><span> GSet</span><span> a </span><span>-&gt;</span><span> GSet</span><span> a</span></span>
<span><span>add </span><span>=</span><span> insert</span></span></code></pre>
<p><strong>Merge</strong>:</p>
<pre tabindex="0" data-language="haskell"><code><span><span>merge</span><span> ::</span><span> Ord</span><span> a </span><span>=&gt;</span><span> GSet</span><span> a </span><span>-&gt;</span><span> GSet</span><span> a </span><span>-&gt;</span><span> GSet</span><span> a</span></span>
<span><span>merge </span><span>=</span><span> union</span></span></code></pre>
<h3 id="laws-and-invariants-2">Laws and Invariants</h3>
<p>Sets with union form a semilattice under the subset relation.</p>
<ul>
<li><strong>Associative</strong>: Set union is associative</li>
<li><strong>Commutative</strong>: Set union is commutative</li>
<li><strong>Idempotent</strong>: <code>A ∪ A = A</code></li>
<li><strong>Monotonic</strong>: Sets only grow</li>
</ul>
<h3 id="intuition-2">Intuition</h3>
<p>Once an element is added to any replica, it will eventually appear in all replicas. There’s no way to remove it.</p>
<h3 id="tradeoffs-2">Tradeoffs</h3>
<p><strong>Advantages</strong>:</p>
<ul>
<li>Minimal overhead (just the set elements)</li>
<li>Simple and efficient</li>
<li>Familiar set semantics</li>
</ul>
<p><strong>Disadvantages</strong>:</p>
<ul>
<li>Cannot remove elements</li>
<li>Grows unbounded</li>
<li>No garbage collection</li>
</ul>
<h3 id="when-to-use-2">When to Use</h3>
<p>Use G-Set for append-only collections where removal is never needed: event logs, collected tags, or immutable registries.</p>
<h2 id="2p-set-two-phase-set">2P-Set: Two-Phase Set</h2>
<p>The natural extension of G-Set to support removal.</p>
<h3 id="definition-2">Definition</h3>
<p>A 2P-Set (Two-Phase Set) contains two G-Sets: one for added elements, one for removed elements:</p>
<pre tabindex="0" data-language="haskell"><code><span><span>data</span><span> TwoPhaseSet</span><span> a </span><span>=</span><span> TwoPhaseSet</span></span>
<span><span>  { added </span><span>::</span><span> GSet</span><span> a</span></span>
<span><span>  , removed </span><span>::</span><span> GSet</span><span> a</span></span>
<span><span>  }</span></span></code></pre>
<p>An element is in the set if it’s been added but not removed:</p>
<pre tabindex="0" data-language="haskell"><code><span><span>member</span><span> ::</span><span> Ord</span><span> a </span><span>=&gt;</span><span> a </span><span>-&gt;</span><span> TwoPhaseSet</span><span> a </span><span>-&gt;</span><span> Bool</span></span>
<span><span>member x (TwoPhaseSet a r) </span><span>=</span><span> x </span><span>`Set.member`</span><span> a </span><span>&amp;&amp;</span><span> x </span><span>`Set.notMember`</span><span> r</span></span></code></pre>
<h3 id="operations-2">Operations</h3>
<p><strong>Add</strong>:</p>
<pre tabindex="0" data-language="haskell"><code><span><span>add x (TwoPhaseSet a r) </span><span>=</span><span> TwoPhaseSet (insert x a) r</span></span></code></pre>
<p><strong>Remove</strong>:</p>
<pre tabindex="0" data-language="haskell"><code><span><span>remove x (TwoPhaseSet a r) </span><span>=</span><span> TwoPhaseSet a (insert x r)</span></span></code></pre>
<p><strong>Merge</strong>:</p>
<pre tabindex="0" data-language="haskell"><code><span><span>merge (TwoPhaseSet a1 r1) (TwoPhaseSet a2 r2) </span><span>=</span></span>
<span><span>  TwoPhaseSet (union a1 a2) (union r1 r2)</span></span></code></pre>
<h3 id="laws-and-invariants-3">Laws and Invariants</h3>
<p><strong>Bias toward removal</strong>: If an element appears in the removed set, it’s not in the 2P-Set, even if it’s also in the added set.</p>
<p><strong>Once removed, forever removed</strong>: Once an element is removed at any replica, it will eventually be removed from all replicas and cannot be re-added.</p>
<h3 id="intuition-3">Intuition</h3>
<p>The 2P-Set is like marking items in a ledger: you can add entries and you can cross them out, but you can’t un-cross-out an entry. Once something is crossed out (removed), that decision is permanent.</p>
<h3 id="tradeoffs-3">Tradeoffs</h3>
<p><strong>Advantages</strong>:</p>
<ul>
<li>Supports both add and remove</li>
<li>Simple to understand</li>
<li>Deterministic convergence</li>
</ul>
<p><strong>Disadvantages</strong>:</p>
<ul>
<li>Cannot re-add removed elements (the “2P” means two-phase: add, then remove, no going back)</li>
<li>Both sets grow monotonically (removed items never truly disappear)</li>
<li>No garbage collection</li>
<li>Not suitable for scenarios where elements might be removed and re-added</li>
</ul>
<h3 id="when-to-use-3">When to Use</h3>
<p>Use 2P-Set when elements have a lifecycle of “not present → added → removed” and never need to be re-added: task completion tracking, tombstones, or revoked permissions.</p>
<h2 id="lww-element-set-last-write-wins-element-set">LWW-Element-Set: Last-Write-Wins Element Set</h2>
<p>What if we want to re-add elements? We need timestamps.</p>
<h3 id="definition-3">Definition</h3>
<p>An LWW-Element-Set associates each element with a timestamp for additions and removals:</p>
<pre tabindex="0" data-language="haskell"><code><span><span>data</span><span> LWWSet</span><span> a </span><span>=</span><span> LWWSet</span></span>
<span><span>  { addTimes </span><span>::</span><span> Map</span><span> a </span><span>Timestamp</span></span>
<span><span>  , removeTimes </span><span>::</span><span> Map</span><span> a </span><span>Timestamp</span></span>
<span><span>  }</span></span></code></pre>
<p>An element is in the set if its most recent operation was an add:</p>
<pre tabindex="0" data-language="haskell"><code><span><span>member</span><span> ::</span><span> Ord</span><span> a </span><span>=&gt;</span><span> a </span><span>-&gt;</span><span> LWWSet</span><span> a </span><span>-&gt;</span><span> Bool</span></span>
<span><span>member x (LWWSet adds removes) </span><span>=</span></span>
<span><span>  case</span><span> (Map.lookup x adds</span><span>,</span><span> Map.lookup x removes) </span><span>of</span></span>
<span><span>    (Just t1</span><span>,</span><span> Just t2) </span><span>-&gt;</span><span> t1 </span><span>&gt;</span><span> t2</span></span>
<span><span>    (Just _</span><span>,</span><span> Nothing) </span><span>-&gt;</span><span> True</span></span>
<span><span>    _ </span><span>-&gt;</span><span> False</span></span></code></pre>
<h3 id="operations-3">Operations</h3>
<p><strong>Add</strong> (with timestamp <code>t</code>):</p>
<pre tabindex="0" data-language="haskell"><code><span><span>add x t (LWWSet adds removes) </span><span>=</span><span> LWWSet (insert x t adds) removes</span></span></code></pre>
<p><strong>Remove</strong> (with timestamp <code>t</code>):</p>
<pre tabindex="0" data-language="haskell"><code><span><span>remove x t (LWWSet adds removes) </span><span>=</span><span> LWWSet adds (insert x t removes)</span></span></code></pre>
<p><strong>Merge</strong>:</p>
<pre tabindex="0" data-language="haskell"><code><span><span>merge (LWWSet a1 r1) (LWWSet a2 r2) </span><span>=</span></span>
<span><span>  LWWSet (unionWith max a1 a2) (unionWith max r1 r2)</span></span></code></pre>
<h3 id="laws-and-invariants-4">Laws and Invariants</h3>
<p>The merge operation is well-defined because <code>max</code> over timestamps forms a semilattice.</p>
<p><strong>Timestamp monotonicity</strong>: Each replica must generate increasing timestamps (typically using wall clocks plus replica IDs as tiebreakers).</p>
<p><strong>Bias</strong>: We must decide what happens when add and remove timestamps are equal. Common choices: bias toward add, or bias toward remove.</p>
<h3 id="intuition-4">Intuition</h3>
<p>Each element has a timestamp for when it was last added and when it was last removed. The most recent operation wins. When merging, we take the latest add timestamp and latest remove timestamp we’ve seen.</p>
<h3 id="tradeoffs-4">Tradeoffs</h3>
<p><strong>Advantages</strong>:</p>
<ul>
<li>Supports add, remove, and re-add</li>
<li>Can garbage collect old timestamps (carefully)</li>
<li>Natural semantics for many applications</li>
</ul>
<p><strong>Disadvantages</strong>:</p>
<ul>
<li>Requires synchronized clocks (or logical clocks with careful replica ID handling)</li>
<li>Concurrent add/remove on the same element may surprise users (one operation is discarded)</li>
<li>Loses information: if two users concurrently add the same element, only one timestamp survives</li>
<li>The “last write wins” semantics mean data loss is possible</li>
</ul>
<h3 id="when-to-use-4">When to Use</h3>
<p>Use LWW-Element-Set when you need a set with add/remove/re-add capability and can tolerate last-write-wins semantics: user preferences, feature flags, or cached collections where perfect consistency isn’t critical.</p>
<h3 id="clock-considerations">Clock Considerations</h3>
<p>The biggest pitfall of LWW-Element-Set is clock skew. If replica A’s clock is ahead of replica B’s, then A’s operations will always “win” over B’s, even if B’s operations happened later in real time. Solutions include:</p>
<ul>
<li>Use hybrid logical clocks (HLC) instead of wall clocks</li>
<li>Use replica IDs as tiebreakers (e.g., timestamps are <code>(wall_time, replica_id)</code> pairs)</li>
<li>Accept the inconsistency as a tradeoff</li>
</ul>
<h2 id="or-set-observed-remove-set">OR-Set: Observed-Remove Set</h2>
<p>The most sophisticated set CRDT, solving the re-add problem without LWW semantics.<sup><a href="#user-content-fn-orset-origin" id="user-content-fnref-orset-origin" data-footnote-ref="" aria-describedby="footnote-label">7</a></sup></p>
<h3 id="definition-4">Definition</h3>
<p>An OR-Set (Observed-Remove Set) associates each element with a set of unique tags:</p>
<pre tabindex="0" data-language="haskell"><code><span><span>type</span><span> ORSet</span><span> a </span><span>=</span><span> Map</span><span> a (</span><span>Set</span><span> Tag</span><span>)</span></span></code></pre>
<p>Tags are unique identifiers generated when adding an element (e.g., <code>(replica_id, sequence_number)</code> pairs).</p>
<p>An element is in the set if it has any tags:</p>
<pre tabindex="0" data-language="haskell"><code><span><span>member</span><span> ::</span><span> Ord</span><span> a </span><span>=&gt;</span><span> a </span><span>-&gt;</span><span> ORSet</span><span> a </span><span>-&gt;</span><span> Bool</span></span>
<span><span>member x set </span><span>=</span><span> case</span><span> Map.lookup x set </span><span>of</span></span>
<span><span>  Just tags </span><span>-&gt;</span><span> not (Set.null tags)</span></span>
<span><span>  Nothing </span><span>-&gt;</span><span> False</span></span></code></pre>
<h3 id="operations-4">Operations</h3>
<p><strong>Add</strong> (with fresh tag <code>t</code>):</p>
<pre tabindex="0" data-language="haskell"><code><span><span>add x t set </span><span>=</span><span> Map.insertWith union x (singleton t) set</span></span></code></pre>
<p><strong>Remove</strong> (with observed tags <code>ts</code>):</p>
<pre tabindex="0" data-language="haskell"><code><span><span>remove x ts set </span><span>=</span><span> Map.update (</span><span>\\</span><span>tags </span><span>-&gt;</span></span>
<span><span>  let</span><span> remaining </span><span>=</span><span> tags </span><span>\\</span><span> ts</span></span>
<span><span>  in</span><span> if</span><span> Set.null remaining </span><span>then</span><span> Nothing </span><span>else</span><span> Just remaining) x set</span></span></code></pre>
<p>The critical insight: removal removes only the tags that were observed. If concurrent adds create new tags, those survive.</p>
<p><strong>Merge</strong>:</p>
<pre tabindex="0" data-language="haskell"><code><span><span>merge </span><span>=</span><span> Map.unionWith union</span></span></code></pre>
<h3 id="laws-and-invariants-5">Laws and Invariants</h3>
<p>The merge operation forms a semilattice where <code>s1 ≤ s2</code> if for all elements <code>x</code>, <code>s1[x] ⊆ s2[x]</code>.</p>
<p><strong>Add wins</strong>: If an add and remove happen concurrently (the add’s tag wasn’t observed by the remove), the add wins.</p>
<p><strong>Causal consistency</strong>: You can only remove tags you’ve observed (seen in a prior state).</p>
<h3 id="intuition-5">Intuition</h3>
<p>Think of each addition as dropping a unique token into a bucket for that element. Removal takes specific tokens out of the bucket. If someone concurrently added a new token you haven’t seen, your removal doesn’t affect it. An element is present if its bucket has any tokens.</p>
<p>This gives us <strong>add-wins semantics</strong>: concurrent add and remove means the element stays in the set (because the remove didn’t observe the add’s tag).</p>
<h3 id="tradeoffs-5">Tradeoffs</h3>
<p><strong>Advantages</strong>:</p>
<ul>
<li>Supports add, remove, and re-add with intuitive semantics</li>
<li>No timestamp requirements</li>
<li>Add-wins semantics are often more desirable than LWW</li>
<li>Properly handles concurrent operations</li>
</ul>
<p><strong>Disadvantages</strong>:</p>
<ul>
<li>Larger space overhead (tags per element)</li>
<li>More complex implementation</li>
<li>Need garbage collection strategy for tags</li>
<li>Remove operations need to carry the observed tags (larger messages)</li>
</ul>
<h3 id="when-to-use-5">When to Use</h3>
<p>Use OR-Set when you need a set with full add/remove/re-add support and can’t tolerate LWW’s data loss: collaborative editing, shopping carts, or any scenario where concurrent adds should be preserved.</p>
<h3 id="garbage-collection">Garbage Collection</h3>
<p>Old tags can accumulate. Strategies include:</p>
<ul>
<li><strong>Tombstones</strong>: Keep removed tags for a grace period before discarding</li>
<li><strong>Version vectors</strong>: Use causal history to determine which tags are safe to remove</li>
<li><strong>Bounded tags</strong>: Limit the number of tags per element, using LWW within that bound</li>
</ul>
<h3 id="interactive-demo-1">Interactive Demo</h3>
<p>Experience the add-wins semantics of OR-Set:</p>
<astro-island uid="1UCY2P" prefix="r1" component-url="/_astro/ORSetDemo.DneF9cCn.js" component-export="default" renderer-url="/_astro/client.JDWrnR5R.js" props="{}" ssr="" client="load" opts="{&#34;name&#34;:&#34;ORSetDemo&#34;,&#34;value&#34;:true}" await-children=""><!--astro:end--></astro-island>
<h2 id="lww-register-last-write-wins-register">LWW-Register: Last-Write-Wins Register</h2>
<p>Registers store single values. The simplest register CRDT uses last-write-wins.</p>
<h3 id="definition-5">Definition</h3>
<p>An LWW-Register pairs a value with a timestamp:</p>
<pre tabindex="0" data-language="haskell"><code><span><span>data</span><span> LWWRegister</span><span> a </span><span>=</span><span> LWWRegister</span></span>
<span><span>  { value </span><span>::</span><span> a</span></span>
<span><span>  , timestamp </span><span>::</span><span> Timestamp</span></span>
<span><span>  }</span></span></code></pre>
<h3 id="operations-5">Operations</h3>
<p><strong>Write</strong> (with timestamp <code>t</code>):</p>
<pre tabindex="0" data-language="haskell"><code><span><span>write x t _ </span><span>=</span><span> LWWRegister x t</span></span></code></pre>
<p><strong>Merge</strong>:</p>
<pre tabindex="0" data-language="haskell"><code><span><span>merge r1</span><span>@</span><span>(LWWRegister v1 t1) r2</span><span>@</span><span>(LWWRegister v2 t2)</span></span>
<span><span>  |</span><span> t1 </span><span>&gt;</span><span> t2 </span><span>=</span><span> r1</span></span>
<span><span>  |</span><span> t1 </span><span>&lt;</span><span> t2 </span><span>=</span><span> r2</span></span>
<span><span>  |</span><span> otherwise </span><span>=</span><span> r1  </span><span>-- tiebreaker (could use replica ID)</span></span></code></pre>
<h3 id="laws-and-invariants-6">Laws and Invariants</h3>
<p>The merge operation is a semilattice with partial order defined by timestamps.</p>
<p><strong>One value wins</strong>: When concurrent writes occur, only one survives (the one with the higher timestamp).</p>
<h3 id="tradeoffs-6">Tradeoffs</h3>
<p><strong>Advantages</strong>:</p>
<ul>
<li>Simple and efficient</li>
<li>Small size (just value + timestamp)</li>
<li>Easy to understand</li>
</ul>
<p><strong>Disadvantages</strong>:</p>
<ul>
<li>Loses concurrent updates</li>
<li>Requires clock synchronization</li>
<li>No way to detect or recover lost updates</li>
</ul>
<h3 id="when-to-use-6">When to Use</h3>
<p>Use LWW-Register for single-value cells where you can tolerate lost updates: user profile fields, configuration settings, or cached computed values.</p>
<h3 id="interactive-demo-2">Interactive Demo</h3>
<p>See data loss in action with last-write-wins semantics:</p>
<astro-island uid="2g6pnS" prefix="r2" component-url="/_astro/LWWRegisterDemo.xg1zuJ1y.js" component-export="default" renderer-url="/_astro/client.JDWrnR5R.js" props="{}" ssr="" client="load" opts="{&#34;name&#34;:&#34;LWWRegisterDemo&#34;,&#34;value&#34;:true}" await-children=""><!--astro:end--></astro-island>
<h2 id="mv-register-multi-value-register">MV-Register: Multi-Value Register</h2>
<p>What if we want to preserve concurrent writes instead of discarding them?</p>
<h3 id="definition-6">Definition</h3>
<p>An MV-Register stores a set of value-timestamp pairs:</p>
<pre tabindex="0" data-language="haskell"><code><span><span>type</span><span> MVRegister</span><span> a </span><span>=</span><span> Set</span><span> (a</span><span>,</span><span> Timestamp</span><span>)</span></span></code></pre>
<p>When reading, you get back all concurrently written values (values with incomparable timestamps).</p>
<h3 id="operations-6">Operations</h3>
<p><strong>Write</strong> (with timestamp <code>t</code>):</p>
<pre tabindex="0" data-language="haskell"><code><span><span>write x t reg </span><span>=</span><span> Set.singleton (x</span><span>,</span><span> t)</span></span></code></pre>
<p><strong>Merge</strong>:</p>
<pre tabindex="0" data-language="haskell"><code><span><span>merge reg1 reg2 </span><span>=</span></span>
<span><span>  let</span><span> combined </span><span>=</span><span> union reg1 reg2</span></span>
<span><span>      maxTime </span><span>=</span><span> maximum (map snd combined)</span></span>
<span><span>      concurrent </span><span>=</span><span> filter (</span><span>\\</span><span>(_</span><span>,</span><span> t) </span><span>-&gt;</span><span> t </span><span>==</span><span> maxTime) combined</span></span>
<span><span>  in</span><span> fromList concurrent</span></span></code></pre>
<p>More sophisticated: keep values with causally concurrent timestamps, not just the maximum.</p>
<h3 id="laws-and-invariants-7">Laws and Invariants</h3>
<p>The merge preserves all values that might be “current” from different replicas’ perspectives.</p>
<p><strong>Concurrent values preserved</strong>: If two writes happened concurrently, both values appear until a subsequent write supersedes them.</p>
<h3 id="tradeoffs-7">Tradeoffs</h3>
<p><strong>Advantages</strong>:</p>
<ul>
<li>No data loss on concurrent updates</li>
<li>Application can detect and resolve conflicts</li>
<li>More information available for conflict resolution</li>
</ul>
<p><strong>Disadvantages</strong>:</p>
<ul>
<li>Returns sets of values, not single values</li>
<li>Application must handle conflict resolution</li>
<li>More complex semantics</li>
<li>Slightly larger space overhead</li>
</ul>
<h3 id="when-to-use-7">When to Use</h3>
<p>Use MV-Register when concurrent updates must be detected and resolved by application logic: collaborative text fields, conflict-aware configuration, or any scenario where losing an update is unacceptable.</p>
<h3 id="conflict-resolution">Conflict Resolution</h3>
<p>When reading an MV-Register returns multiple values, the application must resolve the conflict. Strategies include:</p>
<ul>
<li>Present all values to the user (collaborative editing)</li>
<li>Apply a deterministic merge function (e.g., union of tags)</li>
<li>Use application-specific semantics (e.g., prefer non-empty values)</li>
</ul>
<h2 id="or-map-observed-remove-map">OR-Map: Observed-Remove Map</h2>
<p>Maps are common. How do we make them CRDTs?</p>
<h3 id="definition-7">Definition</h3>
<p>An OR-Map is a map where each key is associated with an OR-Set of tagged values:</p>
<pre tabindex="0" data-language="haskell"><code><span><span>type</span><span> ORMap</span><span> k v </span><span>=</span><span> Map</span><span> k (</span><span>ORSet</span><span> (v</span><span>,</span><span> Tag</span><span>))</span></span></code></pre>
<p>Alternatively, implement as a composition of OR-Set (for keys) with per-key CRDTs (for values).</p>
<h3 id="operations-7">Operations</h3>
<p><strong>Put</strong> (with fresh tag <code>t</code>):</p>
<pre tabindex="0" data-language="haskell"><code><span><span>put k v t map </span><span>=</span><span> Map.insertWith union k (singleton (v</span><span>,</span><span> t)) map</span></span></code></pre>
<p><strong>Remove key</strong>:</p>
<pre tabindex="0" data-language="haskell"><code><span><span>removeKey k map </span><span>=</span><span> Map.delete k map</span></span></code></pre>
<p><strong>Remove specific value</strong>:</p>
<pre tabindex="0" data-language="haskell"><code><span><span>removeValue k v tags map </span><span>=</span><span> -- similar to OR-Set remove</span></span></code></pre>
<p><strong>Merge</strong>:</p>
<pre tabindex="0" data-language="haskell"><code><span><span>merge </span><span>=</span><span> Map.unionWith (OR</span><span>-</span><span>Set merge)</span></span></code></pre>
<h3 id="tradeoffs-8">Tradeoffs</h3>
<p><strong>Advantages</strong>:</p>
<ul>
<li>Full map operations with CRDT semantics</li>
<li>Can nest other CRDTs as values</li>
<li>Compositional</li>
</ul>
<p><strong>Disadvantages</strong>:</p>
<ul>
<li>Complex metadata management</li>
<li>Garbage collection challenges</li>
<li>Larger overhead</li>
</ul>
<h3 id="when-to-use-8">When to Use</h3>
<p>Use OR-Map when you need a distributed key-value store with CRDT guarantees: collaborative JSON documents, distributed configuration, or nested data structures.</p>
<h2 id="rga-replicated-growable-array">RGA: Replicated Growable Array</h2>
<p>Sequences are hard. How do you handle insertions in the middle when replicas disagree on positions?<sup><a href="#user-content-fn-sequence-crdt-challenge" id="user-content-fnref-sequence-crdt-challenge" data-footnote-ref="" aria-describedby="footnote-label">8</a></sup></p>
<h3 id="definition-8">Definition</h3>
<p>RGA (Replicated Growable Array) assigns each element a unique ID and stores the sequence as a tree structure based on insertion order and causality.<sup><a href="#user-content-fn-rga-paper" id="user-content-fnref-rga-paper" data-footnote-ref="" aria-describedby="footnote-label">9</a></sup></p>
<pre tabindex="0" data-language="haskell"><code><span><span>data</span><span> RGA</span><span> a </span><span>=</span><span> RGA</span></span>
<span><span>  { elements </span><span>::</span><span> Map</span><span> UID</span><span> (a</span><span>,</span><span> UID</span><span>)  </span><span>-- element ID -&gt; (value, parent ID)</span></span>
<span><span>  , root </span><span>::</span><span> UID</span></span>
<span><span>  }</span></span></code></pre>
<p>Each element knows its “parent” (the element after which it was inserted).</p>
<h3 id="operations-8">Operations</h3>
<p><strong>Insert</strong> (after element with ID <code>p</code>, with fresh ID <code>uid</code>):</p>
<pre tabindex="0" data-language="haskell"><code><span><span>insert p x uid rga </span><span>=</span><span> -- complex tree manipulation</span></span></code></pre>
<p><strong>Delete</strong> (element with ID <code>uid</code>):</p>
<pre tabindex="0" data-language="haskell"><code><span><span>delete uid rga </span><span>=</span><span> -- mark as tombstone, don&#39;t actually remove</span></span></code></pre>
<p><strong>Merge</strong>: Merge trees by reconciling insertion orders.</p>
<h3 id="laws-and-invariants-8">Laws and Invariants</h3>
<p>The challenge is that positional indices change as elements are inserted/removed. RGA solves this by using immutable IDs and causal relationships.</p>
<p><strong>Causal order preserved</strong>: If element A was inserted before element B on the same replica, that relationship is preserved globally.</p>
<h3 id="intuition-6">Intuition</h3>
<p>Instead of “insert at position 5,” you say “insert after element X.” Since X has a unique ID, this instruction is unambiguous even when other replicas are concurrently inserting elsewhere.</p>
<h3 id="tradeoffs-9">Tradeoffs</h3>
<p><strong>Advantages</strong>:</p>
<ul>
<li>Supports arbitrary insertions and deletions</li>
<li>Eventual consistency for sequences</li>
<li>Handles concurrent edits intuitively</li>
</ul>
<p><strong>Disadvantages</strong>:</p>
<ul>
<li>Complex implementation</li>
<li>Large overhead (IDs, tombstones)</li>
<li>No compaction without coordination</li>
<li>Performance degrades with many deletes (tombstones accumulate)</li>
</ul>
<h3 id="when-to-use-9">When to Use</h3>
<p>Use RGA for collaborative text editing or any replicated sequence where insertions at arbitrary positions must be supported: shared lists, collaborative documents, or distributed queues.</p>
<h3 id="alternatives">Alternatives</h3>
<p>Other sequence CRDTs include:</p>
<ul>
<li><strong>WOOT</strong> (Without Operational Transformation): similar idea, different structure</li>
<li><strong>Logoot</strong>: uses position identifiers between elements</li>
<li><strong>LSEQ</strong>: adaptive allocation of position identifiers</li>
<li><strong>YATA</strong>: optimizations for text editing workloads<sup><a href="#user-content-fn-yata-yjs" id="user-content-fnref-yata-yjs" data-footnote-ref="" aria-describedby="footnote-label">10</a></sup></li>
</ul>
<p>Each has different tradeoffs in space overhead, time complexity, and behavior under specific edit patterns.</p>
<h2 id="causal-crdts-adding-causality">Causal CRDTs: Adding Causality</h2>
<p>Advanced CRDTs incorporate causal tracking using version vectors or similar mechanisms. This enables more sophisticated semantics.</p>
<h3 id="version-vectors">Version Vectors</h3>
<p>A version vector tracks the logical clock for each replica:<sup><a href="#user-content-fn-version-vectors" id="user-content-fnref-version-vectors" data-footnote-ref="" aria-describedby="footnote-label">11</a></sup></p>
<pre tabindex="0" data-language="haskell"><code><span><span>type</span><span> VersionVector</span><span> =</span><span> Map</span><span> ReplicaId</span><span> Nat</span></span></code></pre>
<p>Operations include the version vector, allowing replicas to determine causality: whether one operation happened-before another, or whether they were concurrent.</p>
<h3 id="causal-register">Causal Register</h3>
<p>Pairs an MV-Register with version vectors:</p>
<pre tabindex="0" data-language="haskell"><code><span><span>data</span><span> CausalRegister</span><span> a </span><span>=</span><span> CausalRegister</span></span>
<span><span>  { values </span><span>::</span><span> Map</span><span> VersionVector</span><span> a</span></span>
<span><span>  }</span></span></code></pre>
<p>Only keeps values with concurrent version vectors, discarding those that are causally dominated.</p>
<h3 id="advantages-of-causality">Advantages of Causality</h3>
<ul>
<li>More precise conflict detection (concurrent vs. causally ordered)</li>
<li>Better garbage collection (can discard superseded operations)</li>
<li>Foundation for stronger consistency guarantees</li>
</ul>
<h3 id="disadvantages-of-causality">Disadvantages of Causality</h3>
<ul>
<li>Larger metadata (version vectors grow with number of replicas)</li>
<li>More complex logic</li>
<li>Still doesn’t eliminate conflicts, just detects them more precisely</li>
</ul>
<h3 id="interactive-demo-3">Interactive Demo</h3>
<p>Explore how version vectors track causality:</p>
<astro-island uid="Z1AQVOM" prefix="r3" component-url="/_astro/VectorClockDemo.CoZCB5dm.js" component-export="default" renderer-url="/_astro/client.JDWrnR5R.js" props="{}" ssr="" client="load" opts="{&#34;name&#34;:&#34;VectorClockDemo&#34;,&#34;value&#34;:true}" await-children=""><!--astro:end--></astro-island>
<h2 id="delta-crdts-efficient-state-transmission">Delta CRDTs: Efficient State Transmission</h2>
<p>State-based CRDTs have a problem: sending the entire state on every sync is wasteful. Delta CRDTs solve this.<sup><a href="#user-content-fn-delta-crdt-paper" id="user-content-fnref-delta-crdt-paper" data-footnote-ref="" aria-describedby="footnote-label">12</a></sup></p>
<h3 id="the-problem-1">The Problem</h3>
<p>Consider a G-Counter with 1000 replicas. If replica A increments its count, must it send all 1000 entries to replica B? That’s inefficient: only one entry changed!</p>
<h3 id="the-solution">The Solution</h3>
<p>Instead of sending full state, send only the <strong>delta</strong>: the part of the state that changed since the last sync.</p>
<pre tabindex="0" data-language="haskell"><code><span><span>type</span><span> Delta</span><span> a </span><span>=</span><span> a  </span><span>-- same type as state, but represents only changes</span></span>
<span></span>
<span><span>merge</span><span> ::</span><span> CRDT</span><span> a </span><span>=&gt;</span><span> a </span><span>-&gt;</span><span> Delta</span><span> a </span><span>-&gt;</span><span> a</span></span></code></pre>
<p>For G-Counter, a delta might be just <code>{A: 1}</code> instead of the full map.</p>
<h3 id="definition-9">Definition</h3>
<p>A Delta CRDT extends a state-based CRDT with delta operations:</p>
<pre tabindex="0" data-language="haskell"><code><span><span>data</span><span> DeltaCRDT</span><span> a </span><span>=</span><span> DeltaCRDT</span></span>
<span><span>  { state </span><span>::</span><span> a</span></span>
<span><span>  , lastSent </span><span>::</span><span> Map</span><span> ReplicaId</span><span> a  </span><span>-- track what we&#39;ve sent to each replica</span></span>
<span><span>  }</span></span>
<span></span>
<span><span>delta</span><span> ::</span><span> ReplicaId</span><span> -&gt;</span><span> DeltaCRDT</span><span> a </span><span>-&gt;</span><span> Delta</span><span> a</span></span>
<span><span>delta replica crdt </span><span>=</span><span> state crdt </span><span>`since`</span><span> lastSent[replica]</span></span></code></pre>
<h3 id="laws-and-invariants-9">Laws and Invariants</h3>
<p>Delta CRDTs must satisfy the same semilattice properties as regular state-based CRDTs, plus:</p>
<p><strong>Delta-state equivalence</strong>: Merging deltas incrementally must be equivalent to merging full states.</p>
<p><strong>Delta composition</strong>: Deltas can be composed: <code>delta1 ⊔ delta2</code> is itself a valid delta.</p>
<h3 id="tradeoffs-10">Tradeoffs</h3>
<p><strong>Advantages</strong>:</p>
<ul>
<li>Dramatically reduced bandwidth (send only changes)</li>
<li>Same convergence guarantees as state-based CRDTs</li>
<li>Can batch multiple deltas together</li>
<li>Easier to implement than operation-based CRDTs</li>
</ul>
<p><strong>Disadvantages</strong>:</p>
<ul>
<li>Must track what has been sent to each replica</li>
<li>Slightly more complex than pure state-based</li>
<li>Still need full state for new replicas joining</li>
</ul>
<h3 id="when-to-use-10">When to Use</h3>
<p>Use Delta CRDTs when network bandwidth is a concern or state size is large. Most production CRDT systems use delta-state internally (<a href="https://riak.com/">Riak</a>, <a href="https://automerge.org/">Automerge</a>). If you’re implementing your own CRDT system from scratch, start with deltas. Your future self will thank you.</p>
<h3 id="example-delta-g-counter">Example: Delta G-Counter</h3>
<pre tabindex="0" data-language="haskell"><code><span><span>increment</span><span> ::</span><span> ReplicaId</span><span> -&gt;</span><span> GCounter</span><span> -&gt;</span><span> (</span><span>GCounter</span><span>,</span><span> Delta</span><span> GCounter</span><span>)</span></span>
<span><span>increment r counter </span><span>=</span></span>
<span><span>  let</span><span> newCounter </span><span>=</span><span> insertWith (</span><span>+</span><span>) r </span><span>1</span><span> counter</span></span>
<span><span>      delta </span><span>=</span><span> singleton r </span><span>1</span><span>  -- only the change!</span></span>
<span><span>  in</span><span> (newCounter</span><span>,</span><span> delta)</span></span></code></pre>
<p>The delta is just the single updated entry, not the entire counter.</p>
<h2 id="woot-without-operational-transformation">WOOT: Without Operational Transformation</h2>
<p>WOOT is a sequence CRDT that predates RGA, with different design choices.<sup><a href="#user-content-fn-woot-paper" id="user-content-fnref-woot-paper-2" data-footnote-ref="" aria-describedby="footnote-label">2</a></sup></p>
<h3 id="definition-10">Definition</h3>
<p>WOOT represents a sequence as a set of character objects with unique IDs, where each character stores references to its previous and next characters:</p>
<pre tabindex="0" data-language="haskell"><code><span><span>data</span><span> WChar</span><span> a </span><span>=</span><span> WChar</span></span>
<span><span>  { charId </span><span>::</span><span> UID</span></span>
<span><span>  , value </span><span>::</span><span> a</span></span>
<span><span>  , prevId </span><span>::</span><span> UID</span></span>
<span><span>  , nextId </span><span>::</span><span> UID</span></span>
<span><span>  , isVisible </span><span>::</span><span> Bool</span></span>
<span><span>  }</span></span>
<span></span>
<span><span>type</span><span> WOOT</span><span> a </span><span>=</span><span> Set</span><span> (</span><span>WChar</span><span> a)</span></span></code></pre>
<h3 id="key-insight">Key Insight</h3>
<p>Instead of storing a linear sequence, WOOT stores constraints: “this character comes after X and before Y.” When multiple characters claim to be between X and Y, a deterministic ordering (based on UID) resolves the conflict.</p>
<h3 id="operations-9">Operations</h3>
<p><strong>Insert</strong> (after character with ID <code>prev</code>, before character with ID <code>next</code>):</p>
<pre tabindex="0" data-language="haskell"><code><span><span>insert</span><span> ::</span><span> a </span><span>-&gt;</span><span> UID</span><span> -&gt;</span><span> UID</span><span> -&gt;</span><span> UID</span><span> -&gt;</span><span> WOOT</span><span> a </span><span>-&gt;</span><span> WOOT</span><span> a</span></span>
<span><span>insert val uid prev next woot </span><span>=</span></span>
<span><span>  insert (WChar uid val prev next True) woot</span></span></code></pre>
<p><strong>Delete</strong> (character with ID <code>uid</code>):</p>
<pre tabindex="0" data-language="haskell"><code><span><span>delete</span><span> ::</span><span> UID</span><span> -&gt;</span><span> WOOT</span><span> a </span><span>-&gt;</span><span> WOOT</span><span> a</span></span>
<span><span>delete uid woot </span><span>=</span><span> -- mark character as invisible, don&#39;t remove</span></span></code></pre>
<h3 id="linearization">Linearization</h3>
<p>To read the sequence, perform a topological sort respecting the prev/next constraints, filtering out invisible characters.</p>
<h3 id="tradeoffs-11">Tradeoffs</h3>
<p><strong>Advantages</strong>:</p>
<ul>
<li>Strong eventual consistency</li>
<li>No need for causal delivery (constraints handle ordering)</li>
<li>Intuitive model (characters reference neighbors)</li>
</ul>
<p><strong>Disadvantages</strong>:</p>
<ul>
<li>Tombstones accumulate (deleted characters remain)</li>
<li>Linearization has O(n²) worst case</li>
<li>More complex than RGA</li>
<li>UIDs must be globally unique and ordered</li>
</ul>
<h3 id="comparison-with-rga">Comparison with RGA</h3>
<ul>
<li><strong>RGA</strong>: Uses a tree structure, parent-child relationships</li>
<li><strong>WOOT</strong>: Uses bidirectional constraints, more flexible but slower linearization</li>
</ul>
<h3 id="when-to-use-11">When to Use</h3>
<p>WOOT is primarily of historical interest. Modern implementations prefer RGA or YATA for better performance. But it’s a neat design, and the name alone makes it worth knowing about.</p>
<h2 id="logoot-scalable-position-identifiers">Logoot: Scalable Position Identifiers</h2>
<p>Logoot takes a different approach to sequences: instead of linking elements, assign each element a position in a dense order.<sup><a href="#user-content-fn-logoot-paper" id="user-content-fnref-logoot-paper" data-footnote-ref="" aria-describedby="footnote-label">13</a></sup></p>
<h3 id="definition-11">Definition</h3>
<p>Each element has a position identifier that is a sequence of (digit, replicaId) pairs:</p>
<pre tabindex="0" data-language="haskell"><code><span><span>type</span><span> Position</span><span> =</span><span> [(</span><span>Int</span><span>,</span><span> ReplicaId</span><span>)]</span></span>
<span></span>
<span><span>data</span><span> LogootElement</span><span> a </span><span>=</span><span> LogootElement</span></span>
<span><span>  { position </span><span>::</span><span> Position</span></span>
<span><span>  , value </span><span>::</span><span> a</span></span>
<span><span>  , isDeleted </span><span>::</span><span> Bool</span></span>
<span><span>  }</span></span>
<span></span>
<span><span>type</span><span> Logoot</span><span> a </span><span>=</span><span> Set</span><span> (</span><span>LogootElement</span><span> a)</span></span></code></pre>
<p>Positions are ordered lexicographically.</p>
<h3 id="key-insight-1">Key Insight</h3>
<p>Positions form a dense order: between any two positions, you can always allocate a new position. To insert between positions <code>p1</code> and <code>p2</code>, generate a new position <code>p</code> such that <code>p1 &lt; p &lt; p2</code>.</p>
<h3 id="operations-10">Operations</h3>
<p><strong>Insert</strong> (between positions <code>before</code> and <code>after</code>):</p>
<pre tabindex="0" data-language="haskell"><code><span><span>insert</span><span> ::</span><span> a </span><span>-&gt;</span><span> Position</span><span> -&gt;</span><span> Position</span><span> -&gt;</span><span> Logoot</span><span> a </span><span>-&gt;</span><span> Logoot</span><span> a</span></span>
<span><span>insert val before after logoot </span><span>=</span></span>
<span><span>  let</span><span> newPos </span><span>=</span><span> allocatePosition before after currentReplicaId</span></span>
<span><span>      element </span><span>=</span><span> LogootElement newPos val False</span></span>
<span><span>  in</span><span> insert element logoot</span></span></code></pre>
<p><strong>Position Allocation</strong>:</p>
<pre tabindex="0" data-language="haskell"><code><span><span>allocatePosition</span><span> ::</span><span> Position</span><span> -&gt;</span><span> Position</span><span> -&gt;</span><span> ReplicaId</span><span> -&gt;</span><span> Position</span></span>
<span><span>allocatePosition before after replicaId </span><span>=</span></span>
<span><span>  -- Find a position between before and after</span></span>
<span><span>  -- Use replicaId as tiebreaker for deterministic ordering</span></span></code></pre>
<p><strong>Delete</strong>:</p>
<pre tabindex="0" data-language="haskell"><code><span><span>delete</span><span> ::</span><span> Position</span><span> -&gt;</span><span> Logoot</span><span> a </span><span>-&gt;</span><span> Logoot</span><span> a</span></span>
<span><span>delete pos logoot </span><span>=</span><span> -- mark element at pos as deleted</span></span></code></pre>
<h3 id="laws-and-invariants-10">Laws and Invariants</h3>
<p><strong>Deterministic ordering</strong>: Elements are always ordered by their positions.</p>
<p><strong>Unique positions</strong>: Each insert generates a unique position (using replica ID in the position).</p>
<h3 id="tradeoffs-12">Tradeoffs</h3>
<p><strong>Advantages</strong>:</p>
<ul>
<li>No need to reference other elements by ID</li>
<li>Simpler merge than WOOT</li>
<li>Positions are self-describing (no need to look up IDs)</li>
<li>Can insert without knowing the full document structure</li>
</ul>
<p><strong>Disadvantages</strong>:</p>
<ul>
<li>Position identifiers grow over time (especially with many edits)</li>
<li>Still accumulates tombstones</li>
<li>Position allocation algorithm is complex</li>
<li>Pathological cases where positions become very long</li>
</ul>
<h3 id="lseq-adaptive-positions">LSEQ: Adaptive Positions</h3>
<p>LSEQ improves on Logoot by using an adaptive allocation strategy. Instead of always allocating positions the same way, LSEQ alternates between strategies to keep positions shorter on average.<sup><a href="#user-content-fn-lseq-paper" id="user-content-fnref-lseq-paper" data-footnote-ref="" aria-describedby="footnote-label">14</a></sup></p>
<h3 id="when-to-use-12">When to Use</h3>
<p>Use Logoot/LSEQ when you need a sequence CRDT and want simpler semantics than RGA/WOOT. The tradeoff is position identifier growth.</p>
<h2 id="tree-crdts-hierarchical-data">Tree CRDTs: Hierarchical Data</h2>
<p>Extending CRDTs to trees is challenging because parent-child relationships must be maintained consistently.</p>
<h3 id="the-problem-2">The Problem</h3>
<p>Trees have structural constraints:</p>
<ul>
<li>Each node has exactly one parent (except root)</li>
<li>No cycles allowed</li>
<li>Moving a node changes parent-child relationships</li>
</ul>
<p>How do we handle concurrent operations like:</p>
<ul>
<li>Two replicas move the same node to different parents?</li>
<li>One replica moves node A under node B while another moves B under A?</li>
</ul>
<h3 id="approaches">Approaches</h3>
<p><strong>OR-Tree</strong>: Combine OR-Set with parent pointers, using conflict resolution strategies when multiple parents are observed.</p>
<p><strong>CRDT-Tree</strong>: Use causal ordering to determine which move operations take precedence.</p>
<p><strong>Log-based Trees</strong>: Store operations in a replicated log and rebuild tree structure on read.</p>
<h3 id="or-tree-definition">OR-Tree Definition</h3>
<pre tabindex="0" data-language="haskell"><code><span><span>type</span><span> ORTree</span><span> a </span><span>=</span><span> Map</span><span> NodeId</span><span> (</span><span>ORSet</span><span> ParentId</span><span>,</span><span> a)</span></span></code></pre>
<p>Each node stores an OR-Set of potential parents. Conflict resolution:</p>
<ul>
<li><strong>Last-write-wins</strong>: Use timestamps to pick winning parent</li>
<li><strong>First-wins</strong>: The first parent observed wins</li>
<li><strong>Merge</strong>: Allow nodes to have multiple parents temporarily, application resolves</li>
</ul>
<h3 id="tradeoffs-13">Tradeoffs</h3>
<p><strong>Advantages</strong>:</p>
<ul>
<li>Can represent hierarchical data distributedly</li>
<li>Handles concurrent structural changes</li>
</ul>
<p><strong>Disadvantages</strong>:</p>
<ul>
<li>Complex conflict resolution strategies</li>
<li>Must prevent cycles (may require rejecting some operations)</li>
<li>Moving subtrees is complicated</li>
<li>High metadata overhead</li>
</ul>
<h3 id="when-to-use-13">When to Use</h3>
<p>Use Tree CRDTs for file systems, organizational charts, or document outlines where the hierarchy must be replicated. Be prepared for complexity in handling concurrent structural changes.</p>
<h3 id="alternatives-1">Alternatives</h3>
<p>For many use cases, an OR-Map with explicit parent fields is simpler than a full Tree CRDT, even if it doesn’t enforce tree constraints at the CRDT level.</p>

<p>A practical example combining multiple CRDT concepts.</p>
<h3 id="the-domain">The Domain</h3>
<p>An e-commerce shopping cart must support:</p>
<ul>
<li>Add product to cart</li>
<li>Remove product from cart</li>
<li>Change quantity</li>
<li>Work offline and sync later</li>
</ul>
<h3 id="naive-approach-lww-map">Naive Approach: LWW Map</h3>
<pre tabindex="0" data-language="haskell"><code><span><span>type</span><span> CartLWW</span><span> =</span><span> Map</span><span> ProductId</span><span> (</span><span>Int</span><span>,</span><span> Timestamp</span><span>)</span></span></code></pre>
<p>Problems:</p>
<ul>
<li>Concurrent additions of the same product (one wins)</li>
<li>Remove on one device, add on another (one wins, data loss)</li>
</ul>
<h3 id="better-or-set--pn-counter">Better: OR-Set + PN-Counter</h3>
<pre tabindex="0" data-language="haskell"><code><span><span>type</span><span> ShoppingCart</span><span> =</span><span> Map</span><span> ProductId</span><span> PNCounter</span></span></code></pre>
<ul>
<li>Use OR-Set semantics for which products are in cart</li>
<li>Use PN-Counter for quantities</li>
<li>Add-wins semantics for products (if concurrently added and removed, item stays)</li>
<li>Quantities merge correctly (concurrent +1 and +2 becomes +3)</li>
</ul>
<h3 id="operations-11">Operations</h3>
<p><strong>Add product with quantity</strong>:</p>
<pre tabindex="0" data-language="haskell"><code><span><span>addToCart</span><span> ::</span><span> ProductId</span><span> -&gt;</span><span> Int</span><span> -&gt;</span><span> ReplicaId</span><span> -&gt;</span><span> ShoppingCart</span><span> -&gt;</span><span> ShoppingCart</span></span>
<span><span>addToCart pid qty replica cart </span><span>=</span></span>
<span><span>  let</span><span> counter </span><span>=</span><span> lookupOr emptyCounter pid cart</span></span>
<span><span>      incremented </span><span>=</span><span> incrementN replica qty counter</span></span>
<span><span>  in</span><span> insert pid incremented cart</span></span></code></pre>
<p><strong>Remove product</strong>:</p>
<pre tabindex="0" data-language="haskell"><code><span><span>removeFromCart</span><span> ::</span><span> ProductId</span><span> -&gt;</span><span> ShoppingCart</span><span> -&gt;</span><span> ShoppingCart</span></span>
<span><span>removeFromCart pid cart </span><span>=</span><span> delete pid cart</span></span></code></pre>
<p><strong>Change quantity</strong>:</p>
<pre tabindex="0" data-language="haskell"><code><span><span>changeQuantity</span><span> ::</span><span> ProductId</span><span> -&gt;</span><span> Int</span><span> -&gt;</span><span> ReplicaId</span><span> -&gt;</span><span> ShoppingCart</span><span> -&gt;</span><span> ShoppingCart</span></span>
<span><span>changeQuantity pid delta replica cart </span><span>=</span></span>
<span><span>  let</span><span> counter </span><span>=</span><span> lookupOr emptyCounter pid cart</span></span>
<span><span>      updated </span><span>=</span><span> if</span><span> delta </span><span>&gt;</span><span> 0</span></span>
<span><span>                then</span><span> incrementN replica delta counter</span></span>
<span><span>                else</span><span> decrementN replica (</span><span>-</span><span>delta) counter</span></span>
<span><span>  in</span><span> insert pid updated cart</span></span></code></pre>
<h3 id="tradeoffs-14">Tradeoffs</h3>
<p><strong>Advantages</strong>:</p>
<ul>
<li>Handles all operations correctly</li>
<li>No data loss on concurrent modifications</li>
<li>Intuitive semantics for users</li>
</ul>
<p><strong>Disadvantages</strong>:</p>
<ul>
<li>PN-Counters can go negative (need validation)</li>
<li>Must track all replicas (for PN-Counter)</li>
<li>Slightly more overhead than simple LWW</li>
</ul>
<p>This example shows how combining basic CRDTs creates sophisticated application-level data structures.</p>
<h2 id="practical-considerations">Practical Considerations</h2>
<h3 id="choosing-a-crdt">Choosing a CRDT</h3>
<p>The choice of CRDT depends on your requirements:</p>
<p><strong>Do you need only additions?</strong> Use G-Counter or G-Set.</p>
<p><strong>Do you need removals but not re-additions?</strong> Use 2P-Set.</p>
<p><strong>Can you tolerate last-write-wins?</strong> Use LWW-Element-Set or LWW-Register.</p>
<p><strong>Do you need to preserve concurrent operations?</strong> Use OR-Set or MV-Register.</p>
<p><strong>Do you have sequences?</strong> Use RGA or similar sequence CRDT.</p>
<p><strong>Do you need nested structures?</strong> Use OR-Map with nested CRDTs.</p>
<h3 id="garbage-collection-1">Garbage Collection</h3>
<p>Garbage collection is one of the most challenging practical problems with CRDTs. The fundamental tension: CRDTs achieve convergence by monotonically accumulating information, but production systems can’t grow unbounded forever.</p>
<h4 id="the-problem-in-detail">The Problem in Detail</h4>
<p>Consider an OR-Set used for a collaborative todo list. Each time someone adds a task and removes it, we accumulate:</p>
<ul>
<li>A unique tag for the addition (never removed)</li>
<li>A tombstone tracking the removal (never removed)</li>
</ul>
<p>After 10,000 tasks have been created and completed, our “empty” todo list still contains 10,000 tags worth of metadata. In a G-Counter tracking page views, we keep a separate count for every replica that has ever incremented the counter—even if that replica hasn’t been online in years. For sequence CRDTs like RGA or WOOT, every deleted character becomes a tombstone that must be retained indefinitely. A 1000-character document that’s been heavily edited might internally contain 50,000 tombstones.</p>
<p>The core issue: <strong>CRDTs converge by retaining enough information to handle any possible merge</strong>. If replica A discards metadata about some operation, and replica B (which has been offline for weeks) later tries to merge its state—which still references that metadata—the merge may produce incorrect results.</p>
<h4 id="why-cant-we-just-delete-old-data">Why Can’t We Just Delete Old Data?</h4>
<p>Let’s make this concrete with an OR-Set example:</p>
<pre tabindex="0" data-language="haskell"><code><span><span>-- Replica A&#39;s state</span></span>
<span><span>orset_a </span><span>=</span><span> {&#34;todo</span><span>-</span><span>1</span><span>&#34;: {tag_1, tag_2}}</span></span>
<span></span>
<span><span>-- Replica B&#39;s state (has been offline)</span></span>
<span><span>orset_b = {&#34;</span><span>todo</span><span>-</span><span>1</span><span>&#34;: {tag_1, tag_2, tag_3}}</span></span>
<span></span>
<span><span>-- Replica A removes todo-1, observing tags {tag_1, tag_2}</span></span>
<span><span>-- Now A&#39;s state is:</span></span>
<span><span>orset_a = {}</span></span>
<span></span>
<span><span>-- If A garbage collects and forgets about tags {tag_1, tag_2},</span></span>
<span><span>-- then later merges with B:</span></span>
<span><span>merge(orset_a, orset_b) = {&#34;</span><span>todo</span><span>-</span><span>1</span><span>&#34;: {tag_3}}</span></span>
<span></span>
<span><span>-- The element reappears! (Zombie resurrection)</span></span></code></pre>
<p>The element we removed comes back because we lost the causal information about which tags we had observed and removed. This is the fundamental safety problem with CRDT garbage collection.</p>
<h4 id="strategies-and-tradeoffs">Strategies and Tradeoffs</h4>
<p><strong>Time-Based Expiry</strong></p>
<p>The simplest approach: discard metadata older than some threshold (e.g., 30 days). This works well when you can guarantee all replicas sync within that window.</p>
<pre tabindex="0" data-language="haskell"><code><span><span>gcTombstones</span><span> ::</span><span> Timestamp</span><span> -&gt;</span><span> ORSet</span><span> a </span><span>-&gt;</span><span> ORSet</span><span> a</span></span>
<span><span>gcTombstones cutoff set </span><span>=</span></span>
<span><span>  -- Remove tags older than cutoff</span></span>
<span><span>  Map.mapMaybe (</span><span>\\</span><span>tags </span><span>-&gt;</span></span>
<span><span>    let</span><span> recent </span><span>=</span><span> Set.filter (</span><span>\\</span><span>t </span><span>-&gt;</span><span> tagTime t </span><span>&gt;</span><span> cutoff) tags</span></span>
<span><span>    in</span><span> if</span><span> Set.null recent </span><span>then</span><span> Nothing </span><span>else</span><span> Just recent) set</span></span></code></pre>
<p><em>Advantages</em>:</p>
<ul>
<li>Simple to implement</li>
<li>No coordination required</li>
<li>Works well for frequently-syncing systems</li>
</ul>
<p><em>Disadvantages</em>:</p>
<ul>
<li>Unsafe if replicas can be offline longer than the grace period</li>
<li>Must choose grace period conservatively (wasted space)</li>
<li>Zombie resurrection if threshold is too aggressive</li>
</ul>
<p><em>When to use</em>: Mobile apps where you can bound offline time (e.g., “you must sync at least once per week”).</p>
<p><strong>Coordinated Garbage Collection</strong></p>
<p>Use distributed consensus to agree on what’s safe to discard. Once all replicas acknowledge they’ve received a particular update, the corresponding metadata can be safely removed.</p>
<pre tabindex="0" data-language="haskell"><code><span><span>data</span><span> GCState</span><span> =</span><span> GCState</span></span>
<span><span>  { pendingGC </span><span>::</span><span> Set</span><span> Tag</span><span>  -- Tags eligible for GC</span></span>
<span><span>  , replicaAcks </span><span>::</span><span> Map</span><span> ReplicaId</span><span> (</span><span>Set</span><span> Tag</span><span>)  </span><span>-- What each replica has seen</span></span>
<span><span>  }</span></span>
<span></span>
<span><span>-- When all replicas have acked a tag, it&#39;s safe to remove</span></span>
<span><span>safeToDiscard</span><span> ::</span><span> GCState</span><span> -&gt;</span><span> Set</span><span> Tag</span></span>
<span><span>safeToDiscard (GCState pending acks) </span><span>=</span></span>
<span><span>  -- Tags that all known replicas have acknowledged</span></span>
<span><span>  Set.filter (</span><span>\\</span><span>tag </span><span>-&gt;</span><span> all (Set.member tag) (Map.elems acks)) pending</span></span></code></pre>
<p><em>Advantages</em>:</p>
<ul>
<li>Completely safe (no zombie resurrections)</li>
<li>Can garbage collect aggressively once consensus is reached</li>
<li>Works with arbitrary offline periods</li>
</ul>
<p><em>Disadvantages</em>:</p>
<ul>
<li>Requires coordination (defeats CRDT’s main selling point!)</li>
<li>Slow convergence if some replicas are rarely online</li>
<li>Must track all replicas (what about replicas that never come back?)</li>
</ul>
<p><em>When to use</em>: When you have a bounded, known set of replicas and can tolerate periodic coordination rounds.</p>
<p><strong>Version Vectors for Causal Tracking</strong></p>
<p>Use version vectors to track causal history. Metadata can be discarded once it’s been causally superseded at all replicas.</p>
<pre tabindex="0" data-language="haskell"><code><span><span>data</span><span> CausalORSet</span><span> a </span><span>=</span><span> CausalORSet</span></span>
<span><span>  { elements </span><span>::</span><span> Map</span><span> a (</span><span>Set</span><span> (</span><span>Tag</span><span>,</span><span> VersionVector</span><span>))</span></span>
<span><span>  , replicaVersions </span><span>::</span><span> Map</span><span> ReplicaId</span><span> VersionVector</span><span>  -- Last known VV per replica</span></span>
<span><span>  }</span></span>
<span></span>
<span><span>-- A tag can be GC&#39;d if its version vector is dominated by all known replicas</span></span>
<span><span>canDiscardTag</span><span> ::</span><span> (</span><span>Tag</span><span>,</span><span> VersionVector</span><span>) </span><span>-&gt;</span><span> Map</span><span> ReplicaId</span><span> VersionVector</span><span> -&gt;</span><span> Bool</span></span>
<span><span>canDiscardTag (_</span><span>,</span><span> tagVV) replicaVVs </span><span>=</span></span>
<span><span>  all (</span><span>\\</span><span>replicaVV </span><span>-&gt;</span><span> tagVV </span><span>`happenedBefore`</span><span> replicaVV) (Map.elems replicaVVs)</span></span></code></pre>
<p>This is more sophisticated: we track causality explicitly and can safely discard tags that are in the causal past of all known replicas.</p>
<p><em>Advantages</em>:</p>
<ul>
<li>More precise than time-based expiry</li>
<li>No coordination needed for the happy path</li>
<li>Safe as long as causal tracking is correct</li>
</ul>
<p><em>Disadvantages</em>:</p>
<ul>
<li>Version vectors add significant overhead (O(replicas) per operation)</li>
<li>Still requires tracking all replicas</li>
<li>Complex to implement correctly</li>
<li>What about new replicas that join later?</li>
</ul>
<p><em>When to use</em>: Systems already using version vectors for causal consistency (Riak, Cassandra-style systems).</p>
<p><strong>Bounded Structures with Fallback</strong></p>
<p>Limit metadata size and use LWW semantics when bounds are exceeded. For example, keep at most 1000 tags per element in an OR-Set. If we exceed that, discard the oldest tags and accept potential anomalies.</p>
<pre tabindex="0" data-language="haskell"><code><span><span>addWithBound</span><span> ::</span><span> Ord</span><span> a </span><span>=&gt;</span><span> a </span><span>-&gt;</span><span> Tag</span><span> -&gt;</span><span> Int</span><span> -&gt;</span><span> ORSet</span><span> a </span><span>-&gt;</span><span> ORSet</span><span> a</span></span>
<span><span>addWithBound x tag maxTags set </span><span>=</span></span>
<span><span>  let</span><span> currentTags </span><span>=</span><span> Map.findWithDefault Set.empty x set</span></span>
<span><span>      newTags </span><span>=</span><span> Set.insert tag currentTags</span></span>
<span><span>      boundedTags </span><span>=</span><span> if</span><span> Set.size newTags </span><span>&gt;</span><span> maxTags</span></span>
<span><span>                    then</span><span> Set.fromList </span><span>$</span><span> take maxTags </span><span>$</span><span> </span></span>
<span><span>                         sortBy (comparing tagTimestamp) (Set.toList newTags)</span></span>
<span><span>                    else</span><span> newTags</span></span>
<span><span>  in</span><span> Map.insert x boundedTags set</span></span></code></pre>
<p><em>Advantages</em>:</p>
<ul>
<li>Bounded space overhead (guaranteed)</li>
<li>No coordination needed</li>
<li>Graceful degradation (becomes LWW-ish when bounded)</li>
</ul>
<p><em>Disadvantages</em>:</p>
<ul>
<li>Correctness sacrificed for space</li>
<li>May lose concurrent operations</li>
<li>Choosing the bound is difficult (too small = frequent anomalies, too large = still wasteful)</li>
</ul>
<p><em>When to use</em>: When you must have bounded space (embedded systems, strict SLAs) and can tolerate occasional anomalies.</p>
<p><strong>Checkpoint and Rebase</strong></p>
<p>Periodically create a “checkpoint” snapshot and discard history before that point. New replicas joining after the checkpoint start from the snapshot.</p>
<pre tabindex="0" data-language="haskell"><code><span><span>data</span><span> CheckpointedCRDT</span><span> a </span><span>=</span><span> CheckpointedCRDT</span></span>
<span><span>  { baselineState </span><span>::</span><span> a  </span><span>-- Snapshot at checkpoint</span></span>
<span><span>  , checkpointTime </span><span>::</span><span> Timestamp</span></span>
<span><span>  , deltaSince </span><span>::</span><span> [</span><span>Delta</span><span> a]  </span><span>-- Operations since checkpoint</span></span>
<span><span>  }</span></span>
<span></span>
<span><span>-- Create a new checkpoint, discarding old deltas</span></span>
<span><span>checkpoint</span><span> ::</span><span> CheckpointedCRDT</span><span> a </span><span>-&gt;</span><span> CheckpointedCRDT</span><span> a</span></span>
<span><span>checkpoint crdt </span><span>=</span><span> CheckpointedCRDT</span></span>
<span><span>  { baselineState </span><span>=</span><span> foldl merge (baselineState crdt) (deltaSince crdt)</span></span>
<span><span>  , checkpointTime </span><span>=</span><span> currentTime</span></span>
<span><span>  , deltaSince </span><span>=</span><span> []</span></span>
<span><span>  }</span></span></code></pre>
<p>Replicas that haven’t synced since before the checkpoint must do a full state sync rather than incremental merge.</p>
<p><em>Advantages</em>:</p>
<ul>
<li>Can aggressively prune old history</li>
<li>Conceptually clean (like Git’s shallow clones)</li>
<li>Works well with mostly-online systems</li>
</ul>
<p><em>Disadvantages</em>:</p>
<ul>
<li>Replicas offline during checkpoint period lose incremental sync</li>
<li>Need to track which replicas are pre-checkpoint</li>
<li>Full state sync is expensive</li>
</ul>
<p><em>When to use</em>: Collaborative editing systems where most users are online most of the time (Google Docs, Figma).</p>
<h4 id="practical-recommendations">Practical Recommendations</h4>
<p>For most applications, a <strong>hybrid approach</strong> works best:</p>
<ol>
<li>Use time-based expiry with a conservative grace period (90 days)</li>
<li>Track the oldest unsynced replica timestamp</li>
<li>Only discard metadata older than: <code>min(graceperiod, oldest_unsynced - safety_margin)</code></li>
<li>Provide manual “compact” operations for administrators</li>
<li>Use bounded structures for untrusted/public replicas</li>
</ol>
<p>Without some form of garbage collection, CRDT state grows unbounded and will eventually exhaust memory or storage. The question isn’t whether to implement GC, but which tradeoffs you’re willing to accept.</p>
<p>And, realistically speaking, you’re unlikely to implement a system that only uses CRDTs and no other data storage. You’ll almost certainly have some sort of traditional database to store your data, which
you can probably use to periodically coordinate garbage collection.</p>
<h3 id="a-note-on-causal-consistency">A note on Causal Consistency</h3>
<p>CRDTs themselves don’t enforce causal delivery. You need a causal broadcast protocol to ensure operations are delivered respecting happens-before relationships. Without causal delivery, some CRDTs (especially operation-based ones) may behave incorrectly.</p>
<h3 id="performance">Performance</h3>
<p>Different CRDTs have different performance characteristics. Consider your read/write ratio, expected contention, and replica count when choosing:</p>


























































































































<table><thead><tr><th>CRDT Type</th><th>Space Complexity</th><th>Add/Insert</th><th>Remove/Delete</th><th>Merge</th><th>Read/Query</th><th>Notes</th></tr></thead><tbody><tr><td><strong>G-Counter</strong></td><td>O(r)</td><td>O(1)</td><td>N/A</td><td>O(r)</td><td>O(r)</td><td>Space: one counter per replica</td></tr><tr><td><strong>PN-Counter</strong></td><td>O(r)</td><td>O(1)</td><td>O(1)</td><td>O(r)</td><td>O(r)</td><td>Double the space of G-Counter</td></tr><tr><td><strong>G-Set</strong></td><td>O(e)</td><td>O(1)</td><td>N/A</td><td>O(e)</td><td>O(1)</td><td>Standard set operations</td></tr><tr><td><strong>2P-Set</strong></td><td>O(e)</td><td>O(1)</td><td>O(1)</td><td>O(e)</td><td>O(1)</td><td>Both added and removed sets grow</td></tr><tr><td><strong>LWW-Element-Set</strong></td><td>O(e)</td><td>O(1)</td><td>O(1)</td><td>O(e)</td><td>O(1)</td><td>Can GC old timestamps carefully</td></tr><tr><td><strong>OR-Set</strong></td><td>O(e × t)</td><td>O(1)</td><td>O(t)</td><td>O(e × t)</td><td>O(1)</td><td>Tags accumulate, needs GC</td></tr><tr><td><strong>LWW-Register</strong></td><td>O(1)</td><td>O(1)</td><td>N/A</td><td>O(1)</td><td>O(1)</td><td>Minimal overhead</td></tr><tr><td><strong>MV-Register</strong></td><td>O(concurrent)</td><td>O(1)</td><td>N/A</td><td>O(c)</td><td>O(c)</td><td>Returns set of concurrent values</td></tr><tr><td><strong>OR-Map</strong></td><td>O(k × t)</td><td>O(1)</td><td>O(t)</td><td>O(k × t)</td><td>O(1)</td><td>Per-key OR-Set overhead</td></tr><tr><td><strong>RGA</strong></td><td>O(n + d)</td><td>O(log n)</td><td>O(log n)</td><td>O(n + d)</td><td>O(n)</td><td>Tombstones accumulate</td></tr><tr><td><strong>WOOT</strong></td><td>O(n + d)</td><td>O(n²) worst</td><td>O(log n)</td><td>O(n + d)</td><td>O(n²) worst</td><td>Linearization is expensive</td></tr><tr><td><strong>Logoot/LSEQ</strong></td><td>O(n × p)</td><td>O(log n)</td><td>O(log n)</td><td>O(n)</td><td>O(n log n)</td><td>Position identifiers grow</td></tr></tbody></table>
<p><strong>Legend:</strong></p>
<ul>
<li><code>r</code> = number of replicas</li>
<li><code>e</code> = number of elements in set</li>
<li><code>t</code> = average tags per element (OR-Set)</li>
<li><code>k</code> = number of keys in map</li>
<li><code>n</code> = number of visible elements in sequence</li>
<li><code>d</code> = number of deleted elements (tombstones)</li>
<li><code>c</code> = number of concurrent writes</li>
<li><code>p</code> = average position identifier length</li>
</ul>
<p><strong>Key Observations:</strong></p>
<ul>
<li><strong>Counter CRDTs</strong> scale with replica count, not operation count. A billion increments still cost O(replicas) space.</li>
<li><strong>Set CRDTs</strong> generally have constant-time operations, but OR-Set’s space grows with tags unless garbage collected.</li>
<li><strong>Sequence CRDTs</strong> suffer from tombstone accumulation. RGA is typically faster than WOOT in practice despite similar asymptotic complexity.</li>
<li><strong>Position-based sequences</strong> (Logoot/LSEQ) trade time complexity for avoiding explicit parent pointers, but position identifiers can grow pathologically.</li>
<li><strong>Merge operations</strong> are often the bottleneck in high-throughput systems. Delta CRDTs dramatically improve merge performance by sending only changes.</li>
</ul>
<h3 id="libraries-and-implementations">Libraries and Implementations</h3>
<p>Many CRDT libraries exist:</p>
<ul>
<li><strong>Automerge</strong>: Full-featured CRDT library for JSON-like documents<sup><a href="#user-content-fn-automerge" id="user-content-fnref-automerge" data-footnote-ref="" aria-describedby="footnote-label">15</a></sup></li>
<li><strong>Yjs</strong>: Optimized for collaborative editing<sup><a href="#user-content-fn-yjs" id="user-content-fnref-yjs" data-footnote-ref="" aria-describedby="footnote-label">16</a></sup></li>
<li><strong>Riak</strong>: Database with built-in CRDT support<sup><a href="#user-content-fn-riak" id="user-content-fnref-riak" data-footnote-ref="" aria-describedby="footnote-label">17</a></sup></li>
<li><strong>Redis Enterprise</strong>: CRDT-enabled Redis<sup><a href="#user-content-fn-redis-crdt" id="user-content-fnref-redis-crdt" data-footnote-ref="" aria-describedby="footnote-label">18</a></sup></li>
<li><strong>AntidoteDB</strong>: CRDT-native database<sup><a href="#user-content-fn-antidote" id="user-content-fnref-antidote" data-footnote-ref="" aria-describedby="footnote-label">19</a></sup></li>
</ul>
<p>Each makes different tradeoff decisions.</p>
<h2 id="further-reading">Further Reading</h2>
<p>The CRDT literature is vast and honestly a bit scattered across conference proceedings. Here are the key papers worth reading:</p>
<p><strong>Foundational</strong>:</p>
<ul>
<li>Shapiro et al., <a href="https://hal.inria.fr/inria-00609399v1/document">“Conflict-Free Replicated Data Types”</a> (2011): The original CRDT paper, defining state-based and operation-based CRDTs.</li>
<li>Shapiro et al., <a href="https://hal.inria.fr/inria-00555588/document">“A Comprehensive Study of Convergent and Commutative Replicated Data Types”</a> (2011): Detailed technical report covering many CRDTs. This is the one you want to bookmark.</li>
</ul>
<p><strong>Sequence CRDTs</strong>:</p>
<ul>
<li>Oster et al., <a href="https://hal.inria.fr/inria-00108523/document">“Data Consistency for P2P Collaborative Editing”</a> (2006): Introduces WOOT.</li>
<li>Roh et al., <a href="http://csl.skku.edu/papers/jpdc11.pdf">“Replicated Abstract Data Types: Building Blocks for Collaborative Applications”</a> (2011): Introduces RGA.</li>
<li>Weiss et al., <a href="https://hal.inria.fr/inria-00432368/document">“Logoot: A Scalable Optimistic Replication Algorithm for Collaborative Editing”</a> (2009): Introduces Logoot.</li>
<li>Nédelec et al., <a href="https://hal.archives-ouvertes.fr/hal-00921633/document">“LSEQ: An Adaptive Structure for Sequences in Distributed Collaborative Editing”</a> (2013): Introduces LSEQ.</li>
</ul>
<p><strong>Advanced Topics</strong>:</p>
<ul>
<li>Baquero et al., <a href="https://inria.hal.science/hal-01287738v1/document">“Making Operation-based CRDTs Operation-based”</a> (2014): Pure operation-based CRDTs without state.</li>
<li>Almeida et al., <a href="https://arxiv.org/abs/1603.01529">“Delta State Replicated Data Types”</a> (2018): Efficiency improvements for state-based CRDTs.</li>
<li>Kleppmann et al., <a href="https://arxiv.org/abs/1608.03960">“A Conflict-Free Replicated JSON Datatype”</a> (2017): Automerge’s design.</li>
</ul>
<p><strong>Surveys</strong>:</p>
<ul>
<li>Shapiro et al., <a href="https://inria.hal.science/inria-00555588/en/">“Convergent and Commutative Replicated Data Types”</a> (2011): The comprehensive technical report. Start here if you want depth.</li>
</ul>
<h2 id="wrapping-up">Wrapping up</h2>
<p>CRDTs are not a silver bullet. They trade coordination for metadata, strong consistency for eventual consistency, and simplicity for convergence guarantees. But in scenarios where availability matters more than immediate consistency, they’re remarkably powerful.</p>
<p>There is no “best” CRDT, only CRDTs suited to different problems; the CRDT you choose depends entirely on your application’s semantics:</p>
<ul>
<li>What operations do you need (add, remove, re-add)?</li>
<li>Can you tolerate lost updates?</li>
<li>Do you need to detect conflicts or resolve them automatically?</li>
<li>What’s your tolerance for metadata overhead?</li>
</ul>
<p>The CRDT abstraction is elegant in theory, but bewildering in practice because there are so many instances with subtle differences. Hopefully this guide has cut through some of the confusion, and given you a good intuition for how they work and when to use them.</p>
<p>I honestly still haven’t hit a use case for CRDTs that I couldn’t solve with a traditional database and some custom coordination logic. But sometimes we just want to learn for the sake of learning. If you beat me to it, let me know!</p>
   </div></div>
  </body>
</html>
