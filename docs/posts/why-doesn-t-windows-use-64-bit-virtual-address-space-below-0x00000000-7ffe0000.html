<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://devblogs.microsoft.com/oldnewthing/20221216-00/?p=107598">Original</a>
    <h1>Why doesn’t Windows use 64-bit virtual address space below 0x00000000`7ffe0000?</h1>
    
    <div id="readability-page-1" class="page"><div id="featured">

	<div>
                         <p>
            December 16th, 2022</p><!-- .entry-meta -->
        
<p>A customer used VMMap and observed that for all of their 64-bit processes, nothing was allocated at any addresses below <code>0x00000000`7ffe0000</code>. Why does the virtual address space start at <code>0x00000000`7ffe0000</code>? Is it to make it easier to catch pointer truncation bugs? And what’s so special about <code>0x00000000`7ffe0000</code>?</p>
<p>Okay, let’s go through the questions one at a time.</p>
<p>First, is it even true that the virtual address space starts at <code>0x00000000`7ffe0000</code>?</p>
<p>No. The virtual address space starts at the 64KB boundary. You can confirm this by calling <code>GetSystemInfo</code> and checking the <code>lpMinimum­Application­Address</code>. It will be <code>0x00000000`00010000</code>.</p>
<p>If the address space starts at 64KB, why is the lower 2GB pretty much ignored?</p>
<p>Because it turns out that the total address space is really big.</p>
<p>Address Space Layout Randomization (ASLR) tries to put things at unpredictable addresses. The full user-mode address space on x86-64 is 128TB, and a randomly-generated 47-bit address is very unlikely to begin with 15 consecutive zero bits. The first 2GB of address space is only 0.003% of the total available address space, so it’s a pretty small target.</p>
<p>But why is there a page of memory consistently allocated at exactly <code>0x00000000`7ffe0000</code>?</p>
<p>That is a special page of memory that is mapped read-only into user mode from kernel mode, and it contains things like the current time, so that applications can get this information quickly without having to take a kernel transition. This page is at a fixed location for performance reasons.</p>
<p>If a 64-bit application is not marked <code>/LARGEADDRESSAWARE</code>, then it receives a shrunken address space of only 2GB so that it doesn’t have to deal with any “large addresses” (namely, those above 2GB). These “64-bit processes that don’t understand addresses above 2GB” (also known <a href="https://en.wikipedia.org/wiki/What_Is..._Cliff_Clavin%3F"> in my kitchen</a> as “really stupid 64-bit processes”) still need to access the shared data, so the shared data must go below the 2GB boundary.</p>
<p>Since virtual address space granularity on Windows is 64KB, reserving a single page actually reserves an entire 64KB block, from <code>0x00000000`7ffe0000</code> to <code>0x00000000`7ffeffff</code>. Also in this range is a second read-only page mapped from kernel mode, this time for sharing information with the hypervisor, specifically the <a href="https://docs.microsoft.com/en-us/virtualization/hyper-v-on-windows/tlfs/timers#partition-reference-time-stamp-counter-page"> partition reference time stamp counter</a>. This second page is placed at a random location inside the 64KB range, not so much for ASLR reasons (since there are only 15 choices, which isn’t very random), but just to make sure that nobody accidentally takes a dependency on a fixed address. As noted in the documentation, you find this partition reference time stamp counter page by reading the <code>HV_<wbr/>X64_<wbr/>MSR_<wbr/>REFERENCE_<wbr/>TSC</code> model-specific register.</p>
<p>Okay, but why are these special shared pages in the range <code>0x00000000`7ffe0000</code> to <code>0x00000000`7ffeffff</code>? Why not put them right up at the 2GB boundary of <code>0x00000000`7fff0000</code> to <code>0x00000000`7fffffff</code>?</p>
<p>One reason is that the 64KB region immediately above and below the 2GB boundary are marked permanently invalid in order to <a title="Why is there a 64KB no-man&#39;s land near the end of the user-mode address space?" href="https://devblogs.microsoft.com/oldnewthing/20141009-00/?p=43883"> simplify address validity checks</a>: On 32-bit systems, the 2GB boundary marks the traditional boundary between user mode and kernel mode. If you put a “no man’s land” between user mode and kernel mode, then you can validate a memory range by checking that it starts in user mode, and verifying that every page is accessible. You’ll run into the inaccessible page before you get to the kernel mode addresses.</p>
<p>Okay, that explains why there’s a no man’s land on 32-bit systems, but why do we also have it on 64-bit systems?</p>
<p>On the Alpha AXP, most 32-bit constants can be generated in at most two instructions. But there’s a range of values that <a title="The Alpha AXP, part 3: Integer constants" href="https://devblogs.microsoft.com/oldnewthing/20170809-00/?p=96785"> requires three instructions</a>: <code>0x7fff8000</code> to <code>0x7fffffff</code>. Blocking off that region means that <a title="Why is address space allocation granularity 64KB?" href="https://devblogs.microsoft.com/oldnewthing/20031008-00/?p=42223"> you never have to provide a relocation fixup that targets the problematic memory range</a>. And <a href="https://devblogs.microsoft.com/oldnewthing/20220106-00/?p=106122"> the initial target of 64-bit Windows was the Alpha AXP</a>.</p>

        

		
        
	</div><!-- .entry-content -->

</div></div>
  </body>
</html>
