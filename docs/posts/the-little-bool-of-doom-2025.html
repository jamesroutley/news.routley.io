<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.svgames.pl/article/the-little-bool-of-doom">Original</a>
    <h1>The Little Bool of Doom (2025)</h1>
    
    <div id="readability-page-1" class="page"><div><p>I must confess I have a bit of a soft spot for <a rel="noopener" href="https://en.wikipedia.org/wiki/Doom_%281993_video_game%29">classic DOOM</a>.
Despite 31 long years, the game is still mighty fun to play yourself (admittedly, I rather suck at it)
or to watch others play it (this one I&#39;m better at); and with the source code being available, you can enjoy
it on every modern platform – be it desktop, smartphone,
<a rel="noopener" href="https://youtu.be/7gCZZkBATSc">digital camera</a>, <a rel="noopener" href="https://youtu.be/xZaKlLyikKg">oscilloscope</a>,
or anything else you can imagine.
As a result of this, through various circumstances, I came to maintain several DOOM-related packages in Fedora Linux.</p><p>Now, a few months before each new release, the Fedora Linux project performs a mass rebuild of all its packages.
This has a few benefits, such as ensuring ABI compatibility, updating statically-linked dependencies,
making use of new compiler optimisations/code hardening options, and so on. Either way, with Fedora Linux 42
slated to be released mid-April, the time for the Mass Rebuild has come – and, as it often happens,
not all of my packages made it through. One of those that failed the rebuild was <code>chocolate-doom</code>.</p><h2>Two times false does not make right</h2><p>Well, all right. The first step to finding out what happened was to check the build logs.</p><p><code>gcc -DHAVE_CONFIG_H -I. -I../..    -I../../src -I/usr/include/SDL2 -D_GNU_SOURCE=1 -D_REENTRANT -I/usr/include/SDL2 -D_GNU_SOURCE=1 -D_REENTRANT -I/usr/include/SDL2 -D_GNU_SOURCE=1 -D_REENTRANT -O2 -g -Wall -Wdeclaration-after-statement -Wredundant-decls -O2 -flto=auto -ffat-lto-objects -fexceptions -g -grecord-gcc-switches -pipe -Wall -Werror=format-security -Wp,-U_FORTIFY_SOURCE,-D_FORTIFY_SOURCE=3 -Wp,-D_GLIBCXX_ASSERTIONS -specs=/usr/lib/rpm/redhat/redhat-hardened-cc1 -fstack-protector-strong -specs=/usr/lib/rpm/redhat/redhat-annobin-cc1  -mbranch-protection=standard -fasynchronous-unwind-tables -fstack-clash-protection -fno-omit-frame-pointer -mno-omit-leaf-frame-pointer  -I/usr/include/SDL2 -D_GNU_SOURCE=1 -D_REENTRANT  -I/usr/include/libpng16 -DWITH_GZFILEOP -I/usr/include/pipewire-0.3 -I/usr/include/spa-0.2 -D_REENTRANT -I/usr/lib64/pkgconfig/../../include/dbus-1.0 -I/usr/lib64/pkgconfig/../../lib64/dbus-1.0/include -I/usr/include/libinstpatch-2 -I/usr/include/glib-2.0 -I/usr/lib64/glib-2.0/include -I/usr/include/sysprof-6 -pthread -I/usr/include/opus -D_DEFAULT_SOURCE -D_XOPEN_SOURCE=600 -c -o deh_bexstr.o deh_bexstr.c
In file included from ../../src/sha1.h:21,
                 from ../../src/deh_defs.h:21,
                 from deh_bexstr.c:22:
../../src/doomtype.h:113:5: error: cannot use keyword ‘false’ as enumeration constant
  113 |     false,
      |     ^~~~~
../../src/doomtype.h:113:5: note: ‘false’ is a keyword with ‘-std=c23’ onwards</code></p><p>Oh, so this was a compilation error. Having received a lot of flak over the years about cryptic
error messages, GCC spent the last few years vastly improving on this front; and now, the error
message I got, together with the note that followed it, made the issue clear. Inside the engine
code, <code>chocolate-doom</code> declares its own boolean type:</p><p><code><span>#if defined(__cplusplus) || defined(__bool_true_false_are_defined)</span>
 
<span>typedef</span> bool boolean<span>;</span>
 
<span>#else</span>
 
<span>typedef</span> <span>enum</span> 
<span>{</span>
    <span>false</span><span>,</span> 
    <span>true</span>
<span>}</span> boolean<span>;</span>
<span>#endif</span></code></p><p>So, when treating the sources as C++, it uses the C++ <code>bool</code> type, whereas when treating
the sources as C, it ships its own, custom type. This worked fine with older C standards,
as C89 did not contain a boolean type at all, whereas the type introduced by C99 was named <code>_Bool</code>
– though you could include the <code>&lt;stdbool.h&gt;</code> header, which declared <code>bool</code>, <code>true</code> and <code>false</code>
macros to make things prettier. Come C23, <code>_Bool</code> is renamed to <code>bool</code>, and all three
of <code>bool</code>, <code>true</code> and <code>false</code> are now proper keywords.</p><p>Ok, so it makes perfect sense that this custom boolean type clashes
with the <code>false</code> and <code>true</code> keywords – but begs the question, why did it fail
now, when it worked perfectly fine a few months ago? Why does it build as C23?</p><h2>A fairly standard change</h2><p>As I wrote a few paragraphs ago, one of the goals of the Mass Rebuild is to ensure that
code inside the distro can still be built with a modern compiler. If you look at
<a rel="noopener" href="https://gcc.gnu.org/releases.html">GCC&#39;s version history</a>, you&#39;ll notice that for the last decade,
the release schedule seems to follow a pattern of introducing a new major version once a year,
somewhere between April and May – which fits the Fedora Linux release schedule quite nicely,
and makes Fedora a great place to test GCC pre-releases on a large, varied codebase.</p><p>This time was no different, with <a rel="noopener" href="https://koji.fedoraproject.org/koji/buildinfo?buildID=2615313">GCC 15.0.1</a>
landing in Fedora Rawhide (the &#34;eternal alpha&#34; development version) just a few hours before
the Mass Rebuild began. Among <a rel="noopener" href="https://gcc.gnu.org/gcc-15/porting_to.html">this versions&#39;s changes</a>,
there is one relevant to my problem – the default C standard has been changed from <code>-std=gnu17</code> to <code>-std=gnu23</code>.
And sure enough, if you go back to the build log and carefully go over the compiler invocation,
you&#39;ll notice that there&#39;s no <code>-std=</code> option to explicitly set the standard.</p><p>Ok, so what now? Thinking about it for a bit, there seemed to be three solutions to this problem:</p><ol>
<li>
<p>Explicitly set the C standard to C17 or older,
so the code is built using the custom <code>boolean</code> type.</p>
</li>
<li>
<p>Modify the code by changing the <code>#ifdef</code>, so the compiler uses the built-in <code>bool</code> type
when in C23 mode.</p>
</li>
<li>Rename the enum variants to <code>False</code> and <code>True</code> and modify all the usages accordingly.</li>
</ol><p>Option 1) seemed like the easiest one, but it also felt a bit like kicking the can
down the road – plus, it introduced the question of which standard to use. Option 2) was
fairly straightforward to implement, and arguably, it made for more idiomatic code.
Option 3) was probably the safest one, but also most tedious. After brief deliberation,
I went with the second one.</p><p><code><span>--- a/src/doomtype.h</span>
<span>+++ b/src/doomtype.h</span>
<span>@@ -100,9 +100,9 @@</span>
 
 #include &lt;inttypes.h&gt;
 
<span>-#if defined<span>(</span>__cplusplus<span>)</span> || defined<span>(</span>__bool_true_false_are_defined<span>)</span></span>
<span>+#if defined<span>(</span>__cplusplus<span>)</span> || defined<span>(</span>__bool_true_false_are_defined<span>)</span> || <span>(</span>__STDC_VERSION__ &gt;= 202311L<span>)</span></span>
 
<span>-// Use builtin bool type with C++.</span>
<span>+// Use builtin bool type with C++ and C23.</span>
 
 typedef bool boolean;</code></p><p>The patch was easy to implement, and after applying it, the
Fedora package built successfully. Satisfied with my quick and easy fix,
<a rel="noopener" href="https://github.com/chocolate-doom/chocolate-doom/pull/1722">I opened a pull request upstream</a>.</p><h2>The engine goes boom</h2><p>My proposal prompted some debate between the maintainers, who eventually decided
that the best course of action will be to declare the project as written using C99.
One of them cooked up <a rel="noopener" href="https://github.com/chocolate-doom/chocolate-doom/pull/1723">another pull request</a>:</p><p><code><span>--- a/src/doomtype.h</span>
<span>+++ b/src/doomtype.h</span>
<span>@@ -99,12 +99,11 @@</span>
 // standard and defined to include stdint.h, so include this. 
 
 #include &lt;inttypes.h&gt;
<span>+#include &lt;stdbool.h&gt;</span>
 
 #if defined<span>(</span>__cplusplus<span>)</span> || defined<span>(</span>__bool_true_false_are_defined<span>)</span>
 
<span>-// Use builtin bool type with C++.</span>
<span>-</span>
<span>-typedef bool boolean;</span>
<span>+typedef int boolean;</span>
 
 #else</code></p><p>The added <code>#include</code> made perfect sense – with C99, <code>&lt;stdbool.h&gt;</code> is guaranteed to exist
and it should provide definitions for <code>bool</code>, <code>true</code> and <code>false</code>. However, the change
in the <code>typedef</code> was curious – it meant that despite the switch to C99, the code
would still store boolean values as integers, instead using of the proper <code>bool</code>/<code>_Bool</code> type.
This prompted another short discussion:</p><blockquote>
<p><strong>&lt;turol&gt;</strong></p>
<p><strong>&lt;fabiangreffrath&gt;</strong></p>
<p><strong>&lt;suve&gt;</strong></p>
<p><strong>&lt;fabiangreffrath&gt;</strong></p>
</blockquote><p>Huh. Apparently using <code>_Bool</code> for boolean values dooms the engine
to exit with an error during startup.
Interesting! Let&#39;s try debugging. From the error message, one can find the
<a rel="noopener" href="https://github.com/chocolate-doom/chocolate-doom/blob/chocolate-doom-3.1.0/src/doom/r_things.c#L136">place in the code</a>
where the error occurs:</p><p><code><span>if</span> <span>(</span>sprtemp<span>[</span>frame<span>]</span>.<span>rotate</span> <span>==</span> <span>false</span><span>)</span>
    I_Error <span>(</span><span>&#34;R_InitSprites: Sprite %s frame %c has rotations &#34;</span>
         <span>&#34;and a rot=0 lump&#34;</span><span>,</span> spritename<span>,</span> <span>&#39;A&#39;</span><span>+</span>frame<span>)</span><span>;</span></code></p><p>What exactly&#39;s happening here? I&#39;ll skip on pasting more code snippets and just
give you a quick rundown:</p><ul>
<li>
<p>The code&#39;s inside a function, <code>R_InstallSpriteLump()</code>.</p>
</li>
<li>
<p><code>frame</code> is an argument to the function. While it&#39;s not marked as <code>const</code>,
it is not modified inside the function.</p>
</li>
<li>
<p><code>sprtemp</code> is a global variable, holding an array of 29 <code>spriteframe_t</code> structs.</p>
</li>
<li>The <code>.rotate</code> field inside said struct is of <code>boolean</code> type.</li>
</ul><p>All right. So the problem is this: when <code>boolean</code> is a custom enum type, the code
works as expected and the error condition is false; but when using <code>_Bool</code>,
the condition evaluates as true and exit-on-error is triggered. Sounds rather sketchy...
Let&#39;s try poking at memory using <code>gdb</code>. I&#39;ll start with the working version.</p><p><code>$ gdb ./build/src/chocolate-doom--enum
[...]
(gdb) break src/doom/r_things.c:138
Breakpoint 1 at 0x44f822: file chocolate-doom/src/doom/r_things.c, line 138.
(gdb) run
[...]
Thread 1 &#34;chocolate-doom&#34; hit Breakpoint 1, R_InstallSpriteLump (lump=1242, frame=0, rotation=1, flipped=false) at chocolate-doom/src/doom/r_things.c:138
138     if (sprtemp[frame].rotate == false)
(gdb) print sprtemp[frame]
$1 = {rotate = (true | unknown: 0xfffffffe), lump = {-1, -1, -1, -1, -1, -1, -1, -1}, flip = &#34;\377\377\377\377\377\377\377\377&#34;}
(gdb) step
142     sprtemp[frame].rotate = true;</code></p><p>Okay, so our <code>boolean</code> value is filled with... uh, what? The notation was rather confusing for me at first,
but it turns out that since the <code>boolean</code> type is an enum, <code>gdb</code> tries to be helpful by showing how the value
can be constructed by bit-oring several legal values of the enum. (Except it doesn&#39;t really work in this case.)
Either way, <code>true</code> is 1, and bit-oring that with the &#34;unknown&#34; value gives <code>0xffffffff</code> – which suggests
that the field is initialized by writing <code>-1</code> to it at some earlier point. And indeed, looking
through the backtrace and into the calling function, one can find a
<code>memset (sprtemp,-1, sizeof(sprtemp));</code> call.</p><p>Great, so at least that&#39;s one mystery solved. Back to our breakpoint,
we have a simple comparison between <code>0xffffffff</code> and <code>0x0</code>, which evaluates as false.
That makes sense. Let&#39;s take a look at the <code>_Bool</code> version, then.</p><p><code>$ gdb ./build/src/chocolate-doom--bool
[...]
(gdb) break src/doom/r_things.c:138
Breakpoint 1 at 0x44f822: file chocolate-doom/src/doom/r_things.c, line 138.
(gdb) run
[...]
Thread 1 &#34;chocolate-doom&#34; hit Breakpoint 1, R_InstallSpriteLump (lump=1242, frame=0, rotation=1, flipped=false) at chocolate-doom/src/doom/r_things.c:138
138     if (sprtemp[frame].rotate == false)
(gdb) print sprtemp[frame]
$1 = {rotate = 255, lump = {-1, -1, -1, -1, -1, -1, -1, -1}, flip = &#34;\377\377\377\377\377\377\377\377&#34;}</code></p><p>The size of <code>boolean</code> is now smaller – down from 4 bytes to just 1 byte.
Apart from that, we&#39;re in the exact same place as before – the field&#39;s been initialized to <code>-1</code>,
and the program&#39;s about to check if <code>255 == 0</code>.</p><p><code>(gdb) step
139     I_Error (&#34;R_InitSprites: Sprite %s frame %c has rotations &#34;</code></p><p>I, uh... I mean... <em>w</em> <em>h</em> <em>a</em> <em>t</em> <em>?</em></p><h3>We need to go deeper</h3><p>Yeah, so that was rather unexpected. Thinking that there may be some hidden interaction with another part of the code
that I&#39;m not seeing, I tried reproducing the issue in a smaller program.</p><p><code><span>#include &lt;stdio.h&gt;</span>
<span>#include &lt;string.h&gt;</span>
 
<span>#ifdef DUPA</span>
<span>#include &lt;stdbool.h&gt;</span>
<span>typedef</span> bool boolean<span>;</span>
<span>#else</span>
<span>typedef</span> <span>enum</span> <span>{</span>
    <span>false</span><span>,</span>
    <span>true</span>
<span>}</span> boolean<span>;</span>
<span>#endif</span>
 
boolean some_var<span>[</span><span>30</span><span>]</span><span>;</span>
 
<span>int</span> main<span>(</span><span>void</span><span>)</span> <span>{</span>
    <span>memset</span><span>(</span>some_var<span>,</span> <span>-</span><span>1</span><span>,</span> <span>sizeof</span><span>(</span>some_var<span>)</span><span>)</span><span>;</span>
    some_var<span>[</span><span>0</span><span>]</span> <span>=</span> <span>false</span><span>;</span>
    some_var<span>[</span><span>1</span><span>]</span> <span>=</span> <span>500</span><span>;</span>
 
    <span>for</span><span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;=</span> <span>2</span><span>;</span> <span>++</span>i<span>)</span> <span>{</span>
        <span>if</span><span>(</span>some_var<span>[</span>i<span>]</span> <span>==</span> <span>false</span><span>)</span> <span>printf</span><span>(</span><span>&#34;some_var[%d] is false<span>\n</span>&#34;</span><span>,</span> i<span>)</span><span>;</span>
        <span>if</span><span>(</span>some_var<span>[</span>i<span>]</span> <span>==</span> <span>true</span><span>)</span> <span>printf</span><span>(</span><span>&#34;some_var[%d] is true<span>\n</span>&#34;</span><span>,</span> i<span>)</span><span>;</span>
        <span>printf</span><span>(</span><span>&#34;value of some_var[%d] is %d<span>\n</span>&#34;</span><span>,</span> i<span>,</span> some_var<span>[</span>i<span>]</span><span>)</span><span>;</span>
    <span>}</span>
    <span>return</span> <span>0</span><span>;</span>
<span>}</span></code></p><p>Sure enough, the behaviour was consistent with what I saw inside the game:</p><p><code>$ gcc -o booltest ./booltest.c 
$ ./booltest 
some_var[0] is false
value of some_var[0] is 0
some_var[1] is true
value of some_var[1] is 1
value of some_var[2] is -1
$ gcc -DDUPA -o booltest ./booltest.c 
$ ./booltest 
some_var[0] is false
value of some_var[0] is 0
some_var[1] is true
value of some_var[1] is 1
some_var[2] is false
some_var[2] is true
value of some_var[2] is 255</code></p><p>Somehow, setting a <code>_Bool</code> value to 255 meant that it was true and false at the same time.
I wasn&#39;t gonna get more answers by just juggling C code around, which meant that it was
time to take a look at how things look at the assembly level.
For this, I used the <a rel="noopener" href="https://godbolt.org/z/vrYbajEc9">Godbolt compiler explorer</a>.</p><p><a href="https://corinfaife.co/image/doombool-assembly.png"><img src="https://corinfaife.co/image/doombool-assembly.png" srcset="/image/doombool-assembly.png 1400w, /image/doombool-assembly:1280.png 1280w, /image/doombool-assembly:960.png 960w, /image/doombool-assembly:640.png 640w, /image/doombool-assembly:320.png 320w" alt="A screenshot from the Goldbolt compiler explorer, showing the reproducer program compiled in two modes."/></a></p><p>Ah-ha! The generated instructions were ever so slightly different. This would be great news,
if it wasn&#39;t for me forgetting about one little detail: <em>I have zero knowledge of x86 assembly</em>.</p><p>Luckily for me, there&#39;s this nifty little thing called the Internet, where you can find answers
to a lot of life&#39;s questions. After consulting some sources, I started translating the assembly
instructions into plain Polish (for your convenience, though, I&#39;ll go with English).
In all four scenarios, the code starts by loading <code>some_value[i]</code> into the <code>eax</code> register.</p><h3>boolean is an <code>enum</code>, checking for <code>true</code></h3><ol>
<li>
<p><code>CMP eax, 1</code></p>
</li>
<li><code>JNE .L4</code></li>
</ol><p>Okay, so the behaviour is flipped – instead of &#34;do stuff when variable equals 1&#34;, I got
&#34;skip over stuff when variable does not equal 1&#34; – but that makes perfect sense
in assembly. Overall, the code is exactly what I expected.</p><h3>boolean is an <code>enum</code>, checking for <code>false</code></h3><ol>
<li>
<p><code>TEST eax, eax</code></p>
</li>
<li><code>JNE .L3</code></li>
</ol><p>This time the assembly is slightly more funky, as instead of &#34;compare with zero&#34;,
I got &#34;perform bitwise AND of the value and itself&#34; – which I assume is a micro-optimisation of some sort.
Still, the code effectively does what I&#39;d expect it to – skipping the <code>printf()</code> on any non-zero value.</p><h3>boolean is <code>_Bool</code>, checking for <code>true</code></h3><ol>
<li>
<p><code>TEST al, al</code></p>
</li>
<li><code>JE .L4</code></li>
</ol><p>Now it&#39;s getting interesting! Looks like in this version, the logic is not
&#34;skip when variable does not equal 1&#34;, but rather &#34;skip when variable equals 0&#34;.</p><h3>boolean is <code>_Bool</code>, checking for <code>false</code></h3><ol>
<li>
<p><code>XOR eax, 1</code></p>
</li>
<li>
<p><code>TEST al, al</code></p>
</li>
<li><code>JE .L3</code></li>
</ol><p>Oh boy. So it flips the lowest bit, and then jumps if the post-flip value is zero.
This means that the logic becomes &#34;skip when variable equals 1&#34;.</p><h3>Summing up</h3><p>When <code>boolean</code> is an <code>enum</code>, the compiler does exactly what I expected – the <code>== false</code> condition
checks if the value is equal to 0, and the <code>== true</code> condition checks if the value is equal to 1.</p><p>However, when <code>boolean</code> is actually <code>_Bool</code>, the <code>== false</code> check is transformed into <code>!= 1</code>,
and the <code>== true</code> check is transformed into <code>!= 0</code> – which makes perfect sense in the realm
of boolean logic. But it also means that for a value of 255, hilarity ensures:
since 255 is neither 0 nor 1, both conditions pass!</p><h2>Do they really have a law for that?</h2><p>Now that I knew <em>what</em> was happening, one last riddle to solve was <em>why</em> it was happening.
I mean, sticking an invalid value into a type and getting a weird result isn&#39;t exactly unexpected,
and since we&#39;re talking about C, I was fairly certain I&#39;ve just ran into everyone&#39;s favourite
aspect of the language – Undefined Behaviour. Compiling with UBSan quickly confirmed this hypothesis.</p><p><code>$ gcc -DDUPA -fsanitize=undefined -o booltest ./booltest.c 
$ ./booltest 
some_var[0] is false
value of some_var[0] is 0
some_var[1] is true
value of some_var[1] is 1
booltest.c:22:14: runtime error: load of value 255, which is not a valid value for type &#39;_Bool&#39;
booltest.c:23:14: runtime error: load of value 255, which is not a valid value for type &#39;_Bool&#39;
some_var[2] is true
booltest.c:24:69: runtime error: load of value 255, which is not a valid value for type &#39;_Bool&#39;
value of some_var[2] is 1</code></p><p>I could call it done at this point, but I was still rather curious as to which part of the
standard was violated by the code above. I looked up a PDF version of the C99 standard and started
skimming through. Unfortunately for me, Annex J, &#34;Portability issues&#34;, which lists the many
possible ways one can stumble into unspecified behaviour, undefined behaviour or implementation-defined
behaviour, didn&#39;t explicitly say anything about invalid <code>_Bool</code> values.</p><p>After some more searching, I believe I&#39;ve found my answer in section 6.2.6, &#34;Representation of types&#34;.
Paragraph 6.2.6.1.5 states the following:</p><blockquote>
<p>Certain object representations need not represent a value of the object type. If the stored
value of an object has such a representation and is read by an lvalue expression that does
not have character type, the behavior is undeﬁned.</p>
</blockquote><p>This fit my criteria – I had a <code>_Bool</code> object that did not represent a valid <code>_Bool</code> value,
and it was being read as part of an expression that did not treat is as a <code>char</code>.
So yeah, the code was very much in UB land; luckily, nasal demons spared my nostrils this time.</p><h2>References</h2><ul>
<li>
<p><a rel="noopener" href="https://canitrundoom.org/">Can It Run Doom?</a></p>
</li>
<li>
<p><a rel="noopener" href="https://stackoverflow.com/a/14267642">Stack Overflow: Difference between JE/JNE and JZ/JNZ</a></p>
</li>
<li>
<p><a rel="noopener" href="https://stackoverflow.com/a/15191217">Stack Overflow: How do AX, AH, AL map onto EAX?</a></p>
</li>
<li>
<p><a rel="noopener" href="https://en.wikibooks.org/wiki/X86_Assembly/Control_Flow">Wikibooks: x86 Assembly: Control flow</a></p>
</li>
<li>
<p><a rel="noopener" href="https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html">Clang documentation: UndefinedBehaviorSanitizer</a></p>
</li>
<li><a rel="noopener" href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf">N1256 — final draft of the C99 standard</a></li>
</ul></div></div>
  </body>
</html>
