<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://em-tg.github.io/csborrow/">Original</a>
    <h1>A comparison of Rust’s borrow checker to the one in C#</h1>
    
    <div id="readability-page-1" class="page"><div>
      
      
      

      

<h2 id="wait-c-has-a-borrow-checker">Wait, C# has a borrow checker?</h2>

<p>Behold: the classic example of rust’s zero-cost memory safety…</p>

<div><div><pre><code><span>// error[E0597]: `shortlived` does not live long enough</span>

<span>let</span> <span>longlived</span> <span>=</span> <span>12</span><span>;</span>
<span>let</span> <span>mut</span> <span>plonglived</span> <span>=</span> <span>&amp;</span><span>longlived</span><span>;</span>
<span>{</span>
	<span>let</span> <span>shortlived</span> <span>=</span> <span>13</span><span>;</span>
	<span>plonglived</span> <span>=</span> <span>&amp;</span><span>shortlived</span><span>;</span>
<span>}</span>

<span>*</span><span>plonglived</span><span>;</span>
</code></pre></div></div>

<p>…ported to C#:</p>

<div><div><pre><code><span>// error CS8374: Cannot ref-assign &#39;shortlived&#39; to &#39;plonglived&#39; because</span>
<span>// &#39;shortlived&#39; has a narrower escape scope than &#39;plonglived&#39;</span>

<span>var</span> <span>longlived</span> <span>=</span> <span>12</span><span>;</span>
<span>ref</span> <span>var</span> <span>plonglived</span> <span>=</span> <span>ref</span> <span>longlived</span><span>;</span>
<span>{</span>
	<span>var</span> <span>shortlived</span> <span>=</span> <span>13</span><span>;</span>
	<span>plonglived</span> <span>=</span> <span>ref</span> <span>shortlived</span><span>;</span>
<span>}</span>

<span>_</span> <span>=</span> <span>plonglived</span><span>;</span>
</code></pre></div></div>

<p>OK, so C# doesn’t share the Rust concept of “borrowing,” so it wouldn’t <em>technically</em> be correct to call
this “borrow checking,” but in <em>practice</em> when people talk about “Rust’s borrow checker” they’re talking
about all of the static analysis Rust does to ensure memory safety, for which I think this qualifies.</p>

<p>When I first saw this feature in C# (and also <code>Span</code>s, <code>ref struct</code>s, and <code>stackalloc</code>), I was blown away:
where are all the angle brackets and apostrophes?  How is it possible that I can write efficient and
provably-safe code in C# without a degree in type theory?  In this document I hope to briefly summarize
my understanding of memory safety in C#, make direct comparisons between C# constructs and the corresponding
Rust ones, and maybe shed some light on what trade-offs C# made exactly to get this so user-friendly.</p>

<h2 id="a-brief-history-of-c-ref-safety">A brief history of C# ref safety</h2>

<p><a href="https://ecma-international.org/wp-content/uploads/ECMA-334_1st_edition_december_2001.pdf">Since the beginning</a>
 (2000-ish), C# has had the <code>ref</code> keyword for parameters passed into a function by
reference, but that was about all you could do with it.  If you wanted to do efficient things with
stack-allocated memory and indirection, you would generally use the “unsafe” portions of the language, or
call out to C++.  It wasn’t until 2017 with the release of
<a href="https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-version-history">C# version 7</a> that
<a href="https://devblogs.microsoft.com/dotnet/whats-new-in-csharp-7-0/#ref-returns-and-locals">we started to see</a>
this feature generalized into something more useful.  From there, C# added:</p>

<ul>
  <li><code>ref</code> local variables</li>
  <li><code>ref</code> returns</li>
  <li>safe <code>stackalloc</code> initializers</li>
  <li><code>readonly struct</code> and <code>ref struct</code></li>
  <li><code>in</code> parameters (and later <code>ref readonly</code> parameters)</li>
  <li>conditional <code>ref</code> expressions</li>
  <li>extensions to <code>stackalloc</code></li>
  <li><code>ref</code> fields</li>
</ul>

<p>In the process of adding the above features, C# needed to define rules around <code>ref</code> usage that would
continue to ensure memory safety.  The language specification calls these rules “ref safe contexts” (see
<a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/variables#972-ref-safe-contexts">here</a>
and
<a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/structs#16412-safe-context-constraint">here</a>).
A “ref safe context” is likely better-known to Rust programmers as a
<a href="https://doc.rust-lang.org/rust-by-example/scope/lifetime.html">lifetime</a>, the
region of source text in which it is valid to access/use a reference.</p>

<h2 id="a-comparison-of-ref-safe-contexts-and-lifetimes">A comparison of ref safe contexts and lifetimes</h2>

<p>Like in Rust, it is not possible in C# to explicitly declare the lifetime of a value.  <em>Unlike</em> in rust,
it is also not possible in C# to assign a name to a lifetime using generic type parameters.
In both languages, the correct usage of a function must be knowable given only its declaration, and
not require analysis of its body.  In Rust, this means that lifetimes must appear in the function
declaration:</p>

<div><div><pre><code><span>//                  V name the lifetime using generic type parameter</span>
<span>//                          V --------- V reference named lifetime in parameter and return types</span>
<span>fn</span> <span>return_reference</span><span>&lt;</span><span>&#39;a</span><span>&gt;</span><span>(</span><span>r</span><span>:</span> <span>&amp;</span><span>&#39;a</span> <span>i32</span><span>)</span> <span>-&gt;</span> <span>&amp;</span><span>&#39;a</span> <span>i32</span> <span>{</span>
	<span>r</span> <span>// &lt;-- compiler makes sure we return what we claim to in the signature</span>
<span>}</span>
</code></pre></div></div>

<p>C# has no syntax for this.  Nevertheless, the equivalent code still compiles:</p>

<div><div><pre><code><span>// No lifetimes!</span>
<span>ref</span> <span>int</span> <span>ReturnReference</span><span>(</span><span>ref</span> <span>int</span> <span>r</span><span>){</span>
	<span>return</span> <span>ref</span> <span>r</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>The C# compiler simply assumes that the lifetime of the return is the same as the
lifetime of the parameter.  Rust can do the same…</p>

<div><div><pre><code><span>// No lifetimes!</span>
<span>fn</span> <span>return_reference</span><span>(</span><span>r</span><span>:</span> <span>&amp;</span><span>i32</span><span>)</span> <span>-&gt;</span> <span>&amp;</span><span>i32</span> <span>{</span>
	<span>r</span>
<span>}</span>
</code></pre></div></div>

<p>…and calls this feature <a href="https://doc.rust-lang.org/reference/lifetime-elision.html">lifetime elision</a>.
In Rust, lifetime elision is optional, and the programmer can always explicitly state the lifetimes
of all references.  In C#, by contrast, the compiler must decide the lifetimes for all function
declarations.  For example, the following Rust function returns only one of its two arguments:</p>

<div><div><pre><code><span>//                  V---V Two lifetimes for our two parameters</span>
<span>//                              V------------------------V Return lifetime is the same as that of</span>
<span>//                                                         the first parameter</span>
<span>//                                           V Second parameter lifetime is unused</span>
<span>fn</span> <span>return_reference</span><span>&lt;</span><span>&#39;a</span><span>,</span> <span>&#39;b</span><span>&gt;</span><span>(</span><span>r</span><span>:</span> <span>&amp;</span><span>&#39;a</span> <span>i32</span><span>,</span> <span>r2</span><span>:</span> <span>&amp;</span><span>&#39;b</span> <span>i32</span><span>)</span> <span>-&gt;</span> <span>&amp;</span><span>&#39;a</span> <span>i32</span><span>{</span>
	<span>r</span> <span>// &lt;-- compiler would not allow us to return r2 here</span>
<span>}</span>
</code></pre></div></div>

<p>Lifetime elision is not implemented for functions of this form, since there doesn’t seem to be
a reasonable default to pick.  Nevertheless, C# must pick one:</p>

<div><div><pre><code><span>// No lifetimes!  Wait.  What are they, though?</span>
<span>ref</span> <span>int</span> <span>ReturnReference</span><span>(</span><span>ref</span> <span>int</span> <span>r</span><span>,</span> <span>ref</span> <span>int</span> <span>r2</span><span>){</span>
	<span>return</span> <span>ref</span> <span>r</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>Since it wouldn’t make sense to “pick” either <code>r</code> or <code>r2</code> for the lifetime of the return, C# conservatively
assumes that the return could be <em>either</em> of them.  Thus, both the arguments and the return are assumed to have
the <em>same</em> lifetime, which the specification calls “caller-context.”  The equivalent Rust function would
look like this:</p>

<div><div><pre><code><span>//                  V only one lifetime, called &#34;caller-context&#34;</span>
<span>fn</span> <span>return_reference</span><span>&lt;</span><span>&#39;cc</span><span>&gt;</span><span>(</span><span>r</span><span>:</span> <span>&amp;</span><span>&#39;cc</span> <span>i32</span><span>,</span> <span>r2</span><span>:</span> <span>&amp;</span><span>&#39;cc</span> <span>i32</span><span>)</span> <span>-&gt;</span> <span>&amp;</span><span>&#39;cc</span> <span>i32</span><span>{</span>
	<span>r</span> <span>// &lt;-- compiler allows us to return either r or r2</span>
<span>}</span>
</code></pre></div></div>

<p>This is less useful than the original Rust function.  For example, the following code will compile
successfully with the first declaration, but not with the second:</p>

<div><div><pre><code><span>fn</span> <span>wrapper</span><span>(</span><span>r</span><span>:</span> <span>&amp;</span><span>i32</span><span>)</span> <span>-&gt;</span> <span>&amp;</span><span>i32</span><span>{</span>
	<span>let</span> <span>i</span> <span>=</span> <span>12</span><span>;</span>
	<span>return_reference</span><span>(</span><span>r</span><span>,</span> <span>&amp;</span><span>i</span><span>)</span> <span>// error[E0515]: cannot return value referencing local variable `i`</span>
<span>}</span>
</code></pre></div></div>

<p>and in C#:</p>

<div><div><pre><code><span>ref</span> <span>int</span> <span>Wrapper</span><span>(</span><span>ref</span> <span>int</span> <span>r</span><span>){</span>
	<span>var</span> <span>i</span> <span>=</span> <span>12</span><span>;</span>
	<span>// Cannot use a result of &#39;Program.ReturnReference(ref int, ref int)&#39;</span>
	<span>// in this context because it may expose variables referenced by</span>
	<span>// parameter &#39;r2&#39; outside of their declaration scope</span>
	<span>return</span> <span>ref</span> <span>ReturnReference</span><span>(</span><span>ref</span> <span>r</span><span>,</span> <span>ref</span> <span>i</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<p>Here we see C#’s first trade-off: lifetimes are less explicit, but also less powerful.  The defaults
can also be unintuitive: say we wanted to write a method on a struct which returns a reference
to one of the struct’s members.  In rust, this is simple:</p>

<div><div><pre><code><span>struct</span> <span>Foo</span> <span>{</span>
	<span>member</span><span>:</span> <span>i32</span>
<span>}</span>

<span>impl</span> <span>Foo</span> <span>{</span>
	<span>fn</span> <span>get_member</span><span>&lt;</span><span>&#39;a</span><span>,</span> <span>&#39;b</span><span>&gt;</span><span>(</span><span>&amp;</span><span>&#39;a</span> <span>self</span><span>,</span> <span>unused</span><span>:</span> <span>&amp;</span><span>&#39;b</span> <span>i32</span><span>)</span> <span>-&gt;</span> <span>&amp;</span><span>&#39;a</span> <span>i32</span> <span>{</span>
		<span>&amp;</span><span>self</span><span>.member</span> <span>// &lt;-- compiler would not allow us to return `unused`</span>
	<span>}</span>
<span>}</span>
</code></pre></div></div>

<p>In fact, this is so common that Rust doesn’t require you to write the lifetimes explicitly, again thanks
to “lifetime elision:”</p>

<div><div><pre><code><span>struct</span> <span>Foo</span> <span>{</span>
	<span>member</span><span>:</span> <span>i32</span>
<span>}</span>

<span>impl</span> <span>Foo</span> <span>{</span>
	<span>fn</span> <span>get_member</span><span>(</span><span>&amp;</span><span>self</span><span>,</span> <span>unused</span><span>:</span> <span>&amp;</span><span>i32</span><span>)</span> <span>-&gt;</span> <span>&amp;</span><span>i32</span> <span>{</span>
		<span>&amp;</span><span>self</span><span>.member</span> <span>// &lt;-- would still not be allowed to return `unused`</span>
	<span>}</span>
<span>}</span>
</code></pre></div></div>

<p>The equivalent C# code doesn’t compile, though:</p>

<div><div><pre><code><span>struct</span> <span>Foo</span> <span>{</span>
	<span>int</span> <span>member</span><span>;</span>

	<span>ref</span> <span>int</span> <span>GetMember</span><span>(</span><span>ref</span> <span>int</span> <span>unused</span><span>){</span>
		<span>// error CS8170: Struct members cannot return &#39;this&#39; or</span>
		<span>// other instance members by reference</span>
		<span>return</span> <span>ref</span> <span>this</span><span>.</span><span>member</span><span>;</span>
	<span>}</span>
<span>}</span>
</code></pre></div></div>

<p>This is because C#’s default is the <em>opposite</em> of Rust’s: a struct method that returns by reference is
allowed to return any reference <em>other</em> than the implicit <code>this</code> reference.  The below compiles:</p>

<div><div><pre><code><span>struct</span> <span>Foo</span> <span>{</span>
	<span>int</span> <span>member</span><span>;</span>

	<span>ref</span> <span>int</span> <span>GetMember</span><span>(</span><span>ref</span> <span>int</span> <span>unused</span><span>){</span>
		<span>return</span> <span>ref</span> <span>unused</span><span>;</span>
	<span>}</span>
<span>}</span>
</code></pre></div></div>

<p>C#’s history is rooted in OOP/Java-style programming, and letting methods return <code>this</code> references would
prevent you from writing code like the following:</p>

<div><div><pre><code><span>ref</span> <span>int</span> <span>DoAThing</span><span>(</span><span>ref</span> <span>int</span> <span>p</span><span>){</span>
	<span>// This reference is safe to return because it</span>
	<span>// could only be referencing p</span>
	<span>return</span> <span>ref</span> <span>new</span> <span>Foo</span><span>().</span><span>DoWhatever</span><span>(</span><span>ref</span> <span>p</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<p>The lack of explicit lifetime annotations means C# has to choose which patterns are and
aren’t allowed.</p>

<h2 id="the-escape-hatch-garbage-collection">The escape hatch: garbage collection</h2>

<p>Let’s say we want to write a function which returns a reference to an integer in a buffer if it finds it:</p>

<div><div><pre><code><span>ref</span> <span>int</span> <span>Find</span><span>(</span><span>Span</span><span>&lt;</span><span>int</span><span>&gt;</span> <span>haystack</span><span>,</span> <span>int</span> <span>needle</span><span>){</span>
	<span>for</span><span>(</span><span>var</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>haystack</span><span>.</span><span>Length</span><span>;</span> <span>i</span><span>++)</span>
		<span>if</span><span>(</span><span>haystack</span><span>[</span><span>i</span><span>]</span> <span>==</span> <span>needle</span><span>)</span>
			<span>return</span> <span>ref</span> <span>haystack</span><span>[</span><span>i</span><span>];</span>

	<span>throw</span> <span>new</span> <span>Exception</span><span>(</span><span>&#34;Not Found&#34;</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<p>Instead of throwing an exception, we’ve decided that this function should always return <em>something</em>, even
if it’s not in the haystack.  We don’t have anything else to return, though!  The following code won’t compile:</p>

<div><div><pre><code><span>ref</span> <span>int</span> <span>Find</span><span>(</span><span>Span</span><span>&lt;</span><span>int</span><span>&gt;</span> <span>haystack</span><span>,</span> <span>int</span> <span>needle</span><span>){</span>
	<span>for</span><span>(</span><span>var</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>haystack</span><span>.</span><span>Length</span><span>;</span> <span>i</span><span>++)</span>
		<span>if</span><span>(</span><span>haystack</span><span>[</span><span>i</span><span>]</span> <span>==</span> <span>needle</span><span>)</span>
			<span>return</span> <span>ref</span> <span>haystack</span><span>[</span><span>i</span><span>];</span>
	<span>var</span> <span>def</span> <span>=</span> <span>0</span><span>;</span>
	<span>return</span> <span>ref</span> <span>def</span><span>;</span> <span>// Cannot return local &#39;def&#39; by reference because it is not a ref local</span>
<span>}</span>
</code></pre></div></div>

<p>Naturally, anything declared in <code>Find</code> will fall out of scope when <code>Find</code> returns, and so can’t be
returned by reference.  C# has a superpower, though.  We can write the following:</p>

<div><div><pre><code><span>ref</span> <span>int</span> <span>Find</span><span>(</span><span>Span</span><span>&lt;</span><span>int</span><span>&gt;</span> <span>haystack</span><span>,</span> <span>int</span> <span>needle</span><span>){</span>
	<span>for</span><span>(</span><span>var</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>haystack</span><span>.</span><span>Length</span><span>;</span> <span>i</span><span>++)</span>
		<span>if</span><span>(</span><span>haystack</span><span>[</span><span>i</span><span>]</span> <span>==</span> <span>needle</span><span>)</span>
			<span>return</span> <span>ref</span> <span>haystack</span><span>[</span><span>i</span><span>];</span>
	<span>var</span> <span>def</span> <span>=</span> <span>new</span> <span>int</span><span>[</span><span>1</span><span>];</span>
	<span>return</span> <span>ref</span> <span>def</span><span>[</span><span>0</span><span>];</span>
<span>}</span>
</code></pre></div></div>

<p>The array referred to by <code>def</code> and the function’s return value will live as long as there exist references
into it.  Rust has no equivalent to this.  The closest you can get (I think) is something like the following:</p>

<div><div><pre><code><span>fn</span> <span>find</span><span>(</span><span>haystack</span><span>:</span> <span>&amp;</span><span>[</span><span>i32</span><span>],</span> <span>needle</span><span>:</span> <span>i32</span><span>)</span> <span>-&gt;</span> <span>Cow</span><span>&lt;</span><span>i32</span><span>&gt;</span> <span>{</span>
	<span>for</span> <span>item</span> <span>in</span> <span>haystack</span> <span>{</span>
		<span>if</span> <span>*</span><span>item</span> <span>==</span> <span>needle</span> <span>{</span>
			<span>return</span> <span>Borrowed</span><span>(</span><span>item</span><span>);</span>
		<span>}</span>
	<span>}</span>
	<span>Owned</span><span>(</span><span>0</span><span>)</span>
<span>}</span>
</code></pre></div></div>

<p>This is not transparent to the caller of the function.  If we were willing to leak memory, then
we could write this:</p>

<div><div><pre><code><span>fn</span> <span>find</span><span>(</span><span>haystack</span><span>:</span> <span>&amp;</span><span>[</span><span>i32</span><span>],</span> <span>needle</span><span>:</span> <span>i32</span><span>)</span> <span>-&gt;</span> <span>&amp;</span><span>i32</span> <span>{</span>
	<span>for</span> <span>item</span> <span>in</span> <span>haystack</span> <span>{</span>
		<span>if</span> <span>*</span><span>item</span> <span>==</span> <span>needle</span> <span>{</span>
			<span>return</span> <span>item</span><span>;</span>
		<span>}</span>
	<span>}</span>
	<span>Box</span><span>::</span><span>leak</span><span>(</span><span>Box</span><span>::</span><span>new</span><span>(</span><span>0</span><span>))</span>
<span>}</span>
</code></pre></div></div>

<p><code>Box::leak</code> returns a reference that is converted to <code>&amp;&#39;static i32</code>, where <code>&#39;static</code> represents the program
lifespan (i.e. “forever”).  The <code>&#39;static</code> lifetime is the easiest to deal with because
<a href="https://doc.rust-lang.org/reference/subtyping.html">it can be converted to any other lifetime</a>.
In C#, the garbage collector exists
to <a href="https://devblogs.microsoft.com/oldnewthing/20100809-00/?p=13203">make references last forever</a>,
and thus every heap reference in C# can be considered equivalent to Rust’s <code>&#39;static</code>.</p>

<p>Ignoring the performance implications, this would seem to be an unambiguously good thing: <code>&#39;static</code> can
go anywhere, therefore having all heap references be <code>&#39;static</code> guarantees maximum flexibility.  Sadly, no:</p>

<div><div><pre><code><span>Action</span> <span>CreateCounter</span><span>(</span><span>ref</span> <span>int</span> <span>i</span><span>){</span>
	<span>return</span> <span>()</span> <span>=&gt;</span> <span>{</span>
		<span>// Cannot use ref, out, or in parameter &#39;i&#39; inside</span>
		<span>// an anonymous method, lambda expression, query</span>
		<span>// expression, or local function</span>
		<span>i</span> <span>+=</span> <span>1</span><span>;</span> 
	<span>};</span>
<span>}</span>
</code></pre></div></div>

<p>Because heap references can live forever, it is illegal to put <code>ref</code>s on the heap.  This means <code>ref</code>
can’t be used in lambda captures or class/struct member variables.  Instead, the language provides
<code>ref struct</code>, a kind of struct that can contain <code>ref</code>s but is also required to never go on the heap.</p>

<p>So: garbage collection lets C# do things safely that are impossible to do in Rust, but splits
the language into the “garbage collected” and “stack allocated” worlds.  Rust has a stack/heap
distinction, but doesn’t need the concept of a “stack-only” or “heap-only” type.</p>

<h2 id="sharing-xor-mutation">Sharing XOR mutation</h2>

<p>In rust, every reference is either:</p>
<ul>
  <li>Shared: multiple references may exist and be read from, but none may be written to</li>
  <li>Exclusive: The reference may be read from or written to, but only one unborrowed reference is allowed to exist</li>
</ul>

<p>This restriction is central to Rust’s safety guarantees, but C# doesn’t need it.  The reason is that Rust
has to account for the possibility that a reference may be invalidated <em>at any time</em>.  For example:</p>

<div><div><pre><code><span>let</span> <span>mut</span> <span>v</span> <span>=</span> <span>vec!</span><span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>];</span>
<span>let</span> <span>r</span> <span>=</span> <span>&amp;</span><span>v</span><span>[</span><span>0</span><span>];</span>
<span>v</span><span>.push</span><span>(</span><span>4</span><span>);</span>
<span>// r could be invalid now</span>
</code></pre></div></div>

<p>By contrast, in C# heap references are never invalid, while <code>ref</code>s can only be
invalidated by exiting from a block:</p>

<div><div><pre><code><span>var</span> <span>v</span> <span>=</span> <span>new</span> <span>List</span><span>&lt;</span><span>int</span><span>&gt;{</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>};</span>
<span>var</span> <span>sp</span> <span>=</span> <span>CollectionsMarshal</span><span>.</span><span>AsSpan</span><span>(</span><span>v</span><span>);</span>
<span>ref</span> <span>var</span> <span>r</span> <span>=</span> <span>ref</span> <span>sp</span><span>[</span><span>0</span><span>];</span>
<span>v</span><span>.</span><span>Add</span><span>(</span><span>4</span><span>);</span>
<span>// r is definitely still valid (kinda)</span>
</code></pre></div></div>

<p>To guarantee correctness, Rust’s borrow checker therefore has to disallow any operation which
could invalidate a reference as long as that reference is in use.  All C# has to do is ensure
that a <code>ref</code> to stack-allocated data never leaves the scope it was created in.</p>

<h2 id="why-does-nobody-seem-to-be-talking-about-this">Why does nobody seem to be talking about this?</h2>

<p>Maybe I’m bad at searching for these things, but these changes to C# seem to have gone completely under
the radar in places where you read about memory safety and performance.  Maybe it’s just
because the language additions have happened super slowly, or maybe the C# and Rust communities
have so little overlap that there aren’t enough people who program in both languages to notice the similarities.
Maybe there’s something that makes C#’s <code>ref</code> subset so unusable that people just ignore it (I’ll admit
to only having played around with it a bit, so far).</p>

<p>Here’s my theory: C# already had an equivalent to all of these things in its “unsafe” subset,
so when introduced, <code>ref</code>-safety changes were typically framed as “bringing the performance of safe code
closer to that of unsafe code,” which is arguably the opposite
perspective of Rust’s “bringing the safety of high-performance code closer to that of high-level languages.”
Perhaps that framing makes people miss that although the two languages are pushing in opposite directions,
they might actually be getting closer together.</p>

<h2 id="postscript-c-11">Postscript: C# 11</h2>

<p>In the time since I’ve posted this article, the C# language designers have looked at my first two “C# can’t
do this” examples, implemented a language-level fix for both of them, then travelled back in time to
November of last year to release the fix in C# 11.  They were careful
to <a href="https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-11#ref-fields-and-ref-scoped-variables">barely mention it</a>
in the release notes to maximize the chance that I’d carelessly read past it while researching.
Thank you to those who have pointed out this devious prank to me.</p>

<p>The first multi-reference example where I explain why this…</p>

<div><div><pre><code><span>ref</span> <span>int</span> <span>Wrapper</span><span>(</span><span>ref</span> <span>int</span> <span>r</span><span>){</span>
	<span>var</span> <span>i</span> <span>=</span> <span>12</span><span>;</span>
	<span>// Cannot use a result of &#39;Program.ReturnReference(ref int, ref int)&#39;</span>
	<span>// in this context because it may expose variables referenced by</span>
	<span>// parameter &#39;r2&#39; outside of their declaration scope</span>
	<span>return</span> <span>ref</span> <span>ReturnReference</span><span>(</span><span>ref</span> <span>r</span><span>,</span> <span>ref</span> <span>i</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<p>…can’t possibly work can be made to work by changing the definition of <code>ReturnReference</code> to this:</p>

<div><div><pre><code><span>ref</span> <span>int</span> <span>ReturnReference</span><span>(</span><span>ref</span> <span>int</span> <span>r</span><span>,</span> <span>scoped</span> <span>ref</span> <span>int</span> <span>r2</span><span>){</span>
	<span>return</span> <span>ref</span> <span>r</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p><code>scoped ref</code> is a new reference type which promises to never return the reference or assign it
to an output parameter.  In Rust terms, each C# function really has <em>two</em> lifetimes associated with it,
“caller-context” and “function-member”, with the latter used for <code>scoped ref</code> and the implicit <code>ref this</code>:</p>

<div><div><pre><code><span>fn</span> <span>return_reference</span><span>&lt;</span><span>&#39;cc</span><span>,</span> <span>&#39;fm</span><span>&gt;</span><span>(</span><span>r</span><span>:</span> <span>&amp;</span><span>&#39;cc</span> <span>i32</span><span>,</span> <span>r2</span><span>:</span> <span>&amp;</span><span>&#39;fm</span> <span>i32</span><span>)</span> <span>-&gt;</span> <span>&amp;</span><span>&#39;cc</span> <span>i32</span> <span>{</span>
	<span>r</span>
<span>}</span>
</code></pre></div></div>

<p>Just like we can “scope” a <code>ref</code> parameter, we can “unscope” the implicit <code>ref this</code>, which fixes
the other “C# can’t do this” example from above:</p>

<div><div><pre><code><span>struct</span> <span>Foo</span> <span>{</span>
	<span>int</span> <span>member</span><span>;</span>

	<span>[</span><span>UnscopedRef</span><span>]</span>
	<span>ref</span> <span>int</span> <span>GetMember</span><span>(</span><span>ref</span> <span>int</span> <span>unused</span><span>){</span>
		<span>return</span> <span>ref</span> <span>this</span><span>.</span><span>member</span><span>;</span>
	<span>}</span>
<span>}</span>
</code></pre></div></div>

<p>We can still find things that C# can’t do, but we start to leave the realm of
simple examples, which is quite impressive:</p>

<div><div><pre><code><span>struct</span> <span>TwoRefs</span><span>&lt;</span><span>&#39;a</span><span>,</span> <span>&#39;b</span><span>&gt;</span> <span>{</span>
	<span>a</span><span>:</span> <span>&amp;</span><span>&#39;a</span> <span>i32</span><span>,</span>
	<span>b</span><span>:</span> <span>&amp;</span><span>&#39;b</span> <span>i32</span>
<span>}</span>

<span>fn</span> <span>return_two_refs</span><span>&lt;</span><span>&#39;a</span><span>,</span> <span>&#39;b</span><span>&gt;</span><span>(</span><span>a</span><span>:</span> <span>&amp;</span><span>&#39;a</span> <span>i32</span><span>,</span> <span>b</span><span>:</span> <span>&amp;</span><span>&#39;b</span> <span>i32</span><span>)</span>
	<span>-&gt;</span> <span>TwoRefs</span><span>&lt;</span><span>&#39;a</span><span>,</span> <span>&#39;b</span><span>&gt;</span>
<span>{</span>
	<span>TwoRefs</span> <span>{</span>
		<span>a</span><span>:</span> <span>a</span><span>,</span>
		<span>b</span><span>:</span> <span>b</span>
	<span>}</span>
<span>}</span>

<span>// This works:</span>
<span>fn</span> <span>wrapper</span><span>(</span><span>r</span><span>:</span> <span>&amp;</span><span>i32</span><span>)</span> <span>-&gt;</span> <span>&amp;</span><span>i32</span><span>{</span>
	<span>let</span> <span>i</span> <span>=</span> <span>0</span><span>;</span>
	<span>&amp;</span><span>return_two_refs</span><span>(</span><span>r</span><span>,</span> <span>&amp;</span><span>i</span><span>)</span><span>.a</span>
<span>}</span>
</code></pre></div></div>

<div><div><pre><code><span>ref</span> <span>struct</span> <span>TwoRefs</span> <span>{</span>
	<span>public</span> <span>ref</span> <span>int</span> <span>a</span><span>;</span>
	<span>public</span> <span>ref</span> <span>int</span> <span>b</span><span>;</span>
<span>}</span>

<span>// There&#39;s no way to specify that the two refs we </span>
<span>// return need different lifetimes, and we can&#39;t</span>
<span>// use the `scoped` keyword for either parameter.</span>
<span>TwoRefs</span> <span>ReturnTwoRefs</span><span>(</span><span>ref</span> <span>int</span> <span>a</span><span>,</span> <span>ref</span> <span>int</span> <span>b</span><span>){</span>
	<span>return</span> <span>new</span> <span>TwoRefs</span> <span>{</span>
		<span>a</span> <span>=</span> <span>ref</span> <span>a</span><span>,</span>
		<span>b</span> <span>=</span> <span>ref</span> <span>b</span>
	<span>};</span>
<span>}</span>

<span>ref</span> <span>int</span> <span>Wrapper</span><span>(</span><span>ref</span> <span>int</span> <span>r</span><span>){</span>
	<span>var</span> <span>i</span> <span>=</span> <span>0</span><span>;</span>
	<span>// Cannot use a member of result of &#39;A.ReturnTwoRefs(ref int, ref int)&#39;</span>
	<span>// in this context because it may expose variables referenced by parameter &#39;b&#39;</span>
	<span>// outside of their declaration scope</span>
	<span>return</span> <span>ref</span> <span>ReturnTwoRefs</span><span>(</span><span>ref</span> <span>r</span><span>,</span> <span>ref</span> <span>i</span><span>).</span><span>a</span><span>;</span>
<span>}</span>
</code></pre></div></div>



      
    </div></div>
  </body>
</html>
