<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.usenix.org/publications/loginonline/codon-python-compiler#Rik%20Farrow">Original</a>
    <h1>Codon: Python Compiler</h1>
    
    <div id="readability-page-1" class="page"><div><div><div><p><span>Codon sounds too good to be true: a version of Python that gets compiled into machine code and supports multiple threads of execution. But the &#34;version of Python&#34; part is actually an important point: the builders of Codon have built a compiler that accepts a large portion of Python, including all of the most commonly used parts—but not all.</span></p><p><span>Codon got its start as Seq [4], a domain specific language (DSL) written specifically for working with genomics data. A single sequenced genome consists of a five gigabyte index and tens of gigabytes for hash tables, meaning that programs or scripts written to analyze genomes will always be working with enormous data sets. The authors of Seq had several goals:</span></p><ul><li><span>Allow researchers, who are not programmers by training, to use Pythonic syntax</span></li><li>Support parallel execution</li><li>Include specific features helpful for working with genome sequences</li></ul><p><span>I am going to quote the Seq paper here, as I think the authors did a fine job of explained how they proceeded:</span></p><p><strong><em>To achieve this, we designed a compiler with a static type system. It performs Python-style duck typing and runtime type checking at compile time, completely eliminating the substantial runtime overhead imposed by the reference Python implementation, CPython, and most other Python implementations alike. Unlike these, we reimplemented all of Python’s language features and built-in facilities from the ground up, completely independent of the CPython runtime. The Seq compiler uses an LLVM backend, and in general uses LLVM as a framework for performing general-purpose optimizations. Seq programs additionally use a lightweight (&lt;200 LOC) runtime library for I/O and memory allocation; for the latter, CPython’s reference counting is replaced with the Boehm garbage collector, a widely-used conservative GC that is a drop-in replacement for malloc.</em></strong><span><strong><em> </em></strong></span></p><p><span>I want to expand on this a little, although you can learn a lot more by reading the Seq paper, or the later paper [4] that explains Codon in more detail.</span></p><p><span>Dynamic typing is very handy, and appropriate, for scripting languages like Python. Programmers can write prototypes of programs very quickly because Python abstracts away a lot of the detail in exchange for execution performance. And, for many purposes, you don&#39;t need Python to be ten or a hundred times faster when compiled because the script you are running is not processing enormous data files.</span></p><p><span>Duck typing means that the Codon compiler uses hints found in the source or attempts to deduce them to determine the correct type, and assigns that as a static type. If you wanted to process data where the type is unknown before execution, this may not work for you, although Codon does support a union type that is a possible workaround. In most cases of processing large data sets, the types are known in advance so this is not an issue. </span></p><p><span>Codon uses LLVM because of its flexibility and support for many platforms and types of hardware, allowing the Codon authors to use it in their backend for code generation and general-purpose optimizations. Compilers begin by parsing the input file, using a set of rules to convert the code into an abstract syntax tree (AST). Later phases of the Codon compiler perform type checking, convert the AST into intermediate representations (IR) that get optimized, then finally converted into machine code through LLVM.</span></p></div></div></div></div>
  </body>
</html>
