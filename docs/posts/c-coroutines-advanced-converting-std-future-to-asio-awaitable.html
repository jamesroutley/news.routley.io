<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.ddhigh.com/en/2025/07/15/cpp-coroutine-future-to-awaitable/">Original</a>
    <h1>C&#43;&#43; Coroutines Advanced: Converting std:future to asio:awaitable</h1>
    
    <div id="readability-page-1" class="page"><div id="content"><article><header></header><p><small>July 15, 2025 · 696 words · 4 min</small></p><section><p>In modern C++ development, coroutines have brought revolutionary changes to asynchronous programming. However, when using boost::asio or standalone asio, we often encounter scenarios where we need to convert traditional <code>std::future&lt;T&gt;</code> to <code>asio::awaitable&lt;T&gt;</code>. This article will detail an efficient, thread-safe conversion method.</p><h2 id="problem-background">Problem Background</h2><p>When using asio coroutines, we often encounter scenarios like:</p><ul><li>Need to call third-party libraries that return <code>std::future</code> (such as database drivers)</li><li>Want to use <code>co_await</code> in coroutines to handle these asynchronous operations</li><li>Don’t want to block IO threads, maintaining high performance</li></ul><p>Traditional solutions might use timer polling or directly call <code>future.get()</code> in IO threads, but these methods are either inefficient or block IO threads.</p><h2 id="core-solution">Core Solution</h2><p>Our solution is based on <code>asio::async_initiate</code>, which provides perfect integration with the asio coroutine system while avoiding the problem of blocking IO threads.</p><h3 id="core-implementation">Core Implementation</h3><div><pre tabindex="0"><code data-lang="cpp"><span><span><span>#include</span> <span>&lt;asio.hpp&gt;</span><span>
</span></span></span><span><span><span>#include</span> <span>&lt;future&gt;</span><span>
</span></span></span><span><span><span>#include</span> <span>&lt;optional&gt;</span><span>
</span></span></span><span><span><span>#include</span> <span>&lt;tuple&gt;</span><span>
</span></span></span><span><span><span></span>
</span></span><span><span><span>// Thread pool for handling blocking operations
</span></span></span><span><span><span></span>asio<span>::</span>thread_pool blocking_pool(<span>4</span>);
</span></span><span><span>
</span></span><span><span><span>// Convert std::future&lt;T&gt; to asio::awaitable&lt;T&gt;
</span></span></span><span><span><span></span><span>template</span><span>&lt;</span><span>typename</span> T, <span>typename</span> CompletionToken<span>&gt;</span>
</span></span><span><span><span>auto</span> future_to_awaitable(std<span>::</span>future<span>&lt;</span>T<span>&gt;</span> future, CompletionToken<span>&amp;&amp;</span> token) {
</span></span><span><span>    <span>return</span> asio<span>::</span>async_initiate<span>&lt;</span>CompletionToken, <span>void</span>(std<span>::</span>tuple<span>&lt;</span>std<span>::</span>optional<span>&lt;</span>T<span>&gt;</span>, std<span>::</span>exception_ptr<span>&gt;</span>)<span>&gt;</span>(
</span></span><span><span>        [future <span>=</span> std<span>::</span>move(future)](<span>auto</span><span>&amp;&amp;</span> handler) <span>mutable</span> {
</span></span><span><span>            <span>auto</span> executor <span>=</span> asio<span>::</span>get_associated_executor(handler);
</span></span><span><span>            
</span></span><span><span>            <span>// Execute blocking operation in thread pool to avoid blocking IO thread
</span></span></span><span><span><span></span>            asio<span>::</span>post(blocking_pool, [future <span>=</span> std<span>::</span>move(future), handler <span>=</span> std<span>::</span>move(handler), executor]() <span>mutable</span> {
</span></span><span><span>                std<span>::</span>tuple<span>&lt;</span>std<span>::</span>optional<span>&lt;</span>T<span>&gt;</span>, std<span>::</span>exception_ptr<span>&gt;</span> result;
</span></span><span><span>                
</span></span><span><span>                <span>try</span> {
</span></span><span><span>                    T value <span>=</span> future.get();
</span></span><span><span>                    result <span>=</span> std<span>::</span>make_tuple(std<span>::</span>make_optional(std<span>::</span>move(value)), <span>nullptr</span>);
</span></span><span><span>                } <span>catch</span> (...) {
</span></span><span><span>                    result <span>=</span> std<span>::</span>make_tuple(std<span>::</span>nullopt, std<span>::</span>current_exception());
</span></span><span><span>                }
</span></span><span><span>                
</span></span><span><span>                <span>// Return to original executor context to call handler
</span></span></span><span><span><span></span>                asio<span>::</span>post(executor, [handler <span>=</span> std<span>::</span>move(handler), result <span>=</span> std<span>::</span>move(result)]() <span>mutable</span> {
</span></span><span><span>                    handler(std<span>::</span>move(result));
</span></span><span><span>                });
</span></span><span><span>            });
</span></span><span><span>        },
</span></span><span><span>        token
</span></span><span><span>    );
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>// Wrapper function specifically for coroutines
</span></span></span><span><span><span></span><span>template</span><span>&lt;</span><span>typename</span> T<span>&gt;</span>
</span></span><span><span>asio<span>::</span>awaitable<span>&lt;</span>T<span>&gt;</span> await_future(std<span>::</span>future<span>&lt;</span>T<span>&gt;</span> future) {
</span></span><span><span>    <span>auto</span> [result, exception] <span>=</span> <span>co_await</span> future_to_awaitable(std<span>::</span>move(future), asio<span>::</span>use_awaitable);
</span></span><span><span>    
</span></span><span><span>    <span>if</span> (exception) {
</span></span><span><span>        std<span>::</span>rethrow_exception(exception);
</span></span><span><span>    }
</span></span><span><span>    
</span></span><span><span>    <span>if</span> (result) {
</span></span><span><span>        <span>co_return</span> std<span>::</span>move(<span>*</span>result);
</span></span><span><span>    }
</span></span><span><span>    
</span></span><span><span>    <span>throw</span> std<span>::</span>runtime_error(<span>&#34;Unknown error: no result and no exception&#34;</span>);
</span></span><span><span>}
</span></span></code></pre></div><h2 id="usage-examples">Usage Examples</h2><h3 id="basic-usage">Basic Usage</h3><div><pre tabindex="0"><code data-lang="cpp"><span><span><span>// Simulate database query
</span></span></span><span><span><span></span>std<span>::</span>future<span>&lt;</span>std<span>::</span>string<span>&gt;</span> query_mysql(<span>const</span> std<span>::</span>string<span>&amp;</span> sql) {
</span></span><span><span>    <span>return</span> std<span>::</span>async(std<span>::</span>launch<span>::</span>async, [sql] {
</span></span><span><span>        std<span>::</span>this_thread<span>::</span>sleep_for(std<span>::</span>chrono<span>::</span>seconds(<span>1</span>));
</span></span><span><span>        <span>return</span> <span>&#34;Query result for: &#34;</span> <span>+</span> sql <span>+</span> <span>&#34; - Found 10 rows&#34;</span>;
</span></span><span><span>    });
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>// Use in coroutine
</span></span></span><span><span><span></span>asio<span>::</span>awaitable<span>&lt;</span><span>void</span><span>&gt;</span> example_coro() {
</span></span><span><span>    <span>try</span> {
</span></span><span><span>        <span>// Directly await future in coroutine
</span></span></span><span><span><span></span>        <span>auto</span> result <span>=</span> <span>co_await</span> await_future(query_mysql(<span>&#34;SELECT * FROM users&#34;</span>));
</span></span><span><span>        std<span>::</span>cout <span>&lt;&lt;</span> <span>&#34;Query successful: &#34;</span> <span>&lt;&lt;</span> result <span>&lt;&lt;</span> std<span>::</span>endl;
</span></span><span><span>    } <span>catch</span> (<span>const</span> std<span>::</span>exception<span>&amp;</span> e) {
</span></span><span><span>        std<span>::</span>cout <span>&lt;&lt;</span> <span>&#34;Query failed: &#34;</span> <span>&lt;&lt;</span> e.what() <span>&lt;&lt;</span> std<span>::</span>endl;
</span></span><span><span>    }
</span></span><span><span>}
</span></span></code></pre></div><h3 id="exception-handling">Exception Handling</h3><div><pre tabindex="0"><code data-lang="cpp"><span><span>std<span>::</span>future<span>&lt;</span>std<span>::</span>string<span>&gt;</span> query_with_error(<span>const</span> std<span>::</span>string<span>&amp;</span> sql) {
</span></span><span><span>    <span>return</span> std<span>::</span>async(std<span>::</span>launch<span>::</span>async, [sql]() <span>-&gt;</span> std<span>::</span>string {
</span></span><span><span>        std<span>::</span>this_thread<span>::</span>sleep_for(std<span>::</span>chrono<span>::</span>seconds(<span>1</span>));
</span></span><span><span>        <span>throw</span> std<span>::</span>runtime_error(<span>&#34;Database connection failed&#34;</span>);
</span></span><span><span>    });
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span>asio<span>::</span>awaitable<span>&lt;</span><span>void</span><span>&gt;</span> error_handling_example() {
</span></span><span><span>    <span>try</span> {
</span></span><span><span>        <span>auto</span> result <span>=</span> <span>co_await</span> await_future(query_with_error(<span>&#34;SELECT * FROM invalid_table&#34;</span>));
</span></span><span><span>        std<span>::</span>cout <span>&lt;&lt;</span> <span>&#34;Should not reach here&#34;</span> <span>&lt;&lt;</span> std<span>::</span>endl;
</span></span><span><span>    } <span>catch</span> (<span>const</span> std<span>::</span>exception<span>&amp;</span> e) {
</span></span><span><span>        std<span>::</span>cout <span>&lt;&lt;</span> <span>&#34;Exception caught: &#34;</span> <span>&lt;&lt;</span> e.what() <span>&lt;&lt;</span> std<span>::</span>endl;
</span></span><span><span>    }
</span></span><span><span>}
</span></span></code></pre></div><h2 id="technical-points-analysis">Technical Points Analysis</h2><h3 id="1-advantages-of-using-async_initiate">1. Advantages of Using <code>async_initiate</code></h3><ul><li><strong>Perfect Integration</strong>: Seamlessly integrates with asio coroutine system</li><li><strong>Type Safety</strong>: Compile-time type checking</li><li><strong>Performance Optimization</strong>: Avoids timer polling overhead</li></ul><h3 id="2-thread-pool-design">2. Thread Pool Design</h3><div><pre tabindex="0"><code data-lang="cpp"><span><span>asio<span>::</span>thread_pool blocking_pool(<span>4</span>);
</span></span></code></pre></div><ul><li>Dedicated to handling blocking operations</li><li>Avoids blocking IO threads</li><li>Thread count can be adjusted as needed</li></ul><h3 id="3-exception-handling-strategy">3. Exception Handling Strategy</h3><p>Using <code>std::tuple&lt;std::optional&lt;T&gt;, std::exception_ptr&gt;</code> to handle two scenarios:</p><ul><li>Normal result: <code>{std::optional&lt;T&gt;, nullptr}</code></li><li>Exception case: <code>{std::nullopt, std::exception_ptr}</code></li></ul><p>This design correctly handles edge cases, such as when the return type itself is <code>std::exception_ptr</code>.</p><h3 id="4-executor-context-preservation">4. Executor Context Preservation</h3><div><pre tabindex="0"><code data-lang="cpp"><span><span><span>auto</span> executor <span>=</span> asio<span>::</span>get_associated_executor(handler);
</span></span><span><span><span>// ...
</span></span></span><span><span><span></span>asio<span>::</span>post(executor, [handler <span>=</span> std<span>::</span>move(handler), result <span>=</span> std<span>::</span>move(result)]() <span>mutable</span> {
</span></span><span><span>    handler(std<span>::</span>move(result));
</span></span><span><span>});
</span></span></code></pre></div><p>Ensures that the final handler call occurs in the correct executor context, maintaining asio’s executor semantics.</p><h2 id="performance-considerations">Performance Considerations</h2><ol><li><strong>Avoid IO Thread Blocking</strong>: All blocking operations are executed in independent thread pools</li><li><strong>Move Semantics</strong>: Extensive use of <code>std::move</code> to avoid unnecessary copying</li><li><strong>Zero-Copy Design</strong>: Results are passed directly between threads without additional copying</li></ol><h2 id="practical-application-scenarios">Practical Application Scenarios</h2><p>This conversion method is particularly suitable for the following scenarios:</p><ol><li><strong>Database Operations</strong>: Converting database driver async interfaces to coroutine-friendly forms</li><li><strong>File I/O</strong>: Handling potentially blocking file operations</li><li><strong>Third-Party Library Integration</strong>: Integrating with libraries that return <code>std::future</code></li><li><strong>CPU-Intensive Tasks</strong>: Converting CPU-intensive tasks to awaitable forms</li></ol><h2 id="summary">Summary</h2><p>By using <code>asio::async_initiate</code> and thread pools, we’ve implemented an efficient, thread-safe solution for converting <code>std::future</code> to <code>asio::awaitable</code>. This approach not only avoids blocking IO threads but also provides perfect exception handling mechanisms, making it one of the best practices for modern C++ asynchronous programming.</p><p>This design pattern can be easily extended to other asynchronous scenarios, laying a solid foundation for building high-performance coroutine applications.</p></section></article></div></div>
  </body>
</html>
