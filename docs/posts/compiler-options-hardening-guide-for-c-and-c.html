<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://best.openssf.org/Compiler-Hardening-Guides/Compiler-Options-Hardening-Guide-for-C-and-C&#43;&#43;.html">Original</a>
    <h1>Compiler Options Hardening Guide for C and C&#43;&#43;</h1>
    
    <div id="readability-page-1" class="page"><div>
      

      

<p><em>by the <a href="https://openssf.org">Open Source Security Foundation (OpenSSF)</a> <a href="https://best.openssf.org/">Best Practices Working Group</a>, 2023-11-29</em></p>

<p>This document is a guide for compiler and linker options that contribute to delivering reliable and secure code using native (or cross) toolchains for C and C++. The objective of compiler options hardening is to produce application binaries (executables) with security mechanisms against potential attacks and/or misbehavior.</p>

<p>Hardened compiler options should also produce applications that integrate well with existing platform security features in modern operating systems (OSs). Effectively configuring the compiler options also has several benefits during development such as enhanced compiler warnings, static analysis, and debug instrumentation.</p>

<p>This document is intended for:</p>

<ul>
  <li>Those who write C or C++ code, to help them ensure that resulting code will work with hardened options, including for embedded devices, Internet of Things devices, smartphones, and personal computers.</li>
  <li>Those who build C or C++ code for use in production environments, including Linux distributions, device makers, and those who compile C or C++ for their local environment.</li>
</ul>

<p>This document focuses on recommended options for the GNU Compiler Collection (GCC) and Clang/LLVM, and we expect the recommendations to be applicable to other compilers based on GCC and Clang technology<sup id="fnref:gcc-clang-compilers" role="doc-noteref"><a href="#fn:gcc-clang-compilers" rel="footnote">1</a></sup>. In the future, we aim to expand to guide to also cover other compilers, such as Microsoft MSVC.</p>

<h2 id="tldr-what-compiler-options-should-i-use">TL;DR: What compiler options should I use?</h2>

<p>When compiling C or C++ code on compilers such as GCC and clang, turn on these flags for detecting vulnerabilities at compile time and enable run-time protection mechanisms:</p>

<div><div><pre><code><span>-O2</span> <span>-Wall</span> <span>-Wformat</span><span>=</span>2 <span>-Wconversion</span> <span>-Wtrampolines</span> <span>-Wimplicit-fallthrough</span> <span>\</span>
<span>-U_FORTIFY_SOURCE</span> <span>-D_FORTIFY_SOURCE</span><span>=</span>3 <span>\</span>
<span>-D_GLIBCXX_ASSERTIONS</span> <span>\</span>
<span>-fstrict-flex-arrays</span><span>=</span>3 <span>\</span>
<span>-fstack-clash-protection</span> <span>-fstack-protector-strong</span> <span>\</span>
<span>-Wl</span>,-z,nodlopen <span>-Wl</span>,-z,noexecstack <span>\</span>
<span>-Wl</span>,-z,relro <span>-Wl</span>,-z,now
</code></pre></div></div>

<p>When compiling code in any of the situations in the below table, add the corresponding additional options:</p>

<table>
  <thead>
    <tr>
      <th>When</th>
      <th>Additional options flags</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>for executables</td>
      <td><code>-fPIE -pie</code></td>
    </tr>
    <tr>
      <td>for shared libraries</td>
      <td><code>-fPIC -shared</code></td>
    </tr>
    <tr>
      <td>for x86_64</td>
      <td><code>-fcf-protection=full</code></td>
    </tr>
    <tr>
      <td>for aarch64</td>
      <td><code>-mbranch-protection=standard</code></td>
    </tr>
  </tbody>
</table>

<p>Developers should additionally use <a href="#-Werror"><code>-Werror</code></a>, but it is advisable to omit it when distributing source code, as <code>-Werror</code> creates a dependency on specific toolchain vendors and versions.</p>

<p>See the discussion below for <a href="#background">background</a> and for <a href="#recommended-compiler-options">detailed discussion of each option</a>.</p>

<p>In this guide, we use the term <em>production code</em> for executable code intended for use in the real world with real effects; it should be maximally reliable and performant. We use the term <em>instrumented test code</em> for executable code that is instrumented to improve defect detection and debuggability, and as such, often crashes more and is slower. Test processes should use both instrumented test code and production code.</p>

<p>Developers should ensure that both their production code and their instrumented test code pass their automated test suite with all their relevant options. We encourage developers to consider it a bug if the program cannot be compiled with these options. Those who build production code may choose to omit some hardening options that hurt performance if the program only processes trusted data, but remember that it’s not helpful to deploy programs that that are insecure and rapidly do the wrong thing. Existing programs may need to be modified over time to work with some of these options.</p>

<h2 id="background">Background</h2>

<h3 id="why-do-we-need-compiler-options-hardening">Why do we need compiler options hardening?</h3>

<p>Sadly, attackers today attack the software we use every day. Many programming languages’ compilers have options to detect potential vulnerabilities while compiling and/or insert runtime protections against potential attacks. These can be important in any language, but these options are <em>especially</em> important in C and C++.</p>

<p>Applications written in the C and C++ programming languages are prone to exhibit a class of software defects known as memory safety errors, a.k.a. memory errors. This class of defects include bugs such as buffer overflows, dereferencing a null pointer, and use-after-free errors. Memory errors can occur because the low-level memory management in C and C++ offers no language-level provisions for ensuring the memory safety of operations such as pointer arithmetic or direct memory accesses. Instead, they require software developers to write correct code when performing common operations, and this has proven to be difficult at scale. Memory errors have the potential to cause memory vulnerabilities, which can be exploited by threat actors to gain unauthorized access to computer systems through run-time attacks. Microsoft has found that 70% of all its security defects in 2006-2018 were memory safety failures<sup id="fnref:Cimpanu2019" role="doc-noteref"><a href="#fn:Cimpanu2019" rel="footnote">2</a></sup>, and the Chrome team similarly found 70% of all its vulnerabilities are memory safety issues.<sup id="fnref:Cimpanu2020" role="doc-noteref"><a href="#fn:Cimpanu2020" rel="footnote">3</a></sup></p>

<p>Most programming languages prevent such defects by default. A few languages allow programs to temporarily suspend these protections in special circumstances, but they are intended for use in a few lines, not the whole program. There have been calls to rewrite C and C++ programs in other languages, but this is expensive and time-consuming, has its own risks, is sometimes impractical today (especially for less-common CPUs). Even with universal agreement, it would take decades to rewrite all such code. Consequently, it’s important to take other steps to reduce the likelihood of defects becoming vulnerabilities. Aggressive use of compiler options can sometimes detect vulnerabilities or help counter their run-time effects.</p>

<p>Run-time attacks differ from conventional malware, which carries out its malicious program actions through a dedicated program executable, in that run-time attacks influence benign programs to behave maliciously. A run-time attack that exploits unmitigated memory vulnerabilities can be leveraged by threat actors as the initial attack vectors that allow them to gain a presence on a system, e.g., by injecting malicious code into running programs.</p>

<p>Modern, security-aware C and C++ software development practices, e.g., secure coding standards such as SEI CERT C<sup id="fnref:CMU2016C" role="doc-noteref"><a href="#fn:CMU2016C" rel="footnote">4</a></sup> and C++<sup id="fnref:CMU2016CPP" role="doc-noteref"><a href="#fn:CMU2016CPP" rel="footnote">5</a></sup>, and program analysis aim to proactively avoid introducing memory errors (and other software defects) to applications. However, in practice completely eradicating memory errors in production C and C++ software has turned out to be near-impossible.</p>

<p>Consequently, modern operating systems deploy various run-time mechanisms to protect against potential security flaws. The principal purpose of such mechanisms is to mitigate potentially exploitable memory vulnerabilities in a way that prevents a threat actor from exploiting them to gain code execution capabilities. With mitigations in place the affected application may still crash if a memory error is triggered. However, such an outcome is still preferable if the alternative is the compromise of the system’s run-time environment.</p>

<p>To benefit from the protection mechanism provided by the OS the application binaries must be prepared at build time to be compatible with the mitigations. Typically, this means enabling specific option flags for the compiler or linker when the software is built.</p>

<p>Some mechanisms may require additional configuration and fine tuning, for example due to potential compilation issues for certain unlikely edge cases, or performance overhead the mitigation adds for certain program constructs. Some compiler security features depend on data flow analysis of programs and heuristics, results of which may vary depending on program source code details. As a result, the protection mechanisms implemented by these features may not always provide full coverage.</p>

<p>These problems are exacerbated in projects that rely on an outdated version of an open source software (OSS) compiler. In general, security mitigations are more likely to be enabled by default in modern versions of compilers included with Linux distributions. Note that the defaults used by the upstream GCC project do not enable some of these mitigations.</p>

<p>If compiler options hardening is overlooked or neglected during build time it can become impossible to add hardening to already distributed executables. It is therefore good practice to evaluate which mitigations an application should support, and make conscious, informed decisions whenever not enabling a mitigation weakens the application’s defensive posture. Ensure that the software is <em>tested</em> with as many options as practical, to ensure it can be operated that way.</p>

<p>Some organizations require selecting hardening rules. For example, the US government’s NIST SP 800-218 practice PW.6 requires configuring “the compilation, interpreter, and build processes to improve executable security” <sup id="fnref:NIST-SP-800-218-1-1" role="doc-noteref"><a href="#fn:NIST-SP-800-218-1-1" rel="footnote">6</a></sup>. Carnegie Mellon University (CMU)’s “top 10 secure coding practices” recommends compiling “code using the highest warning level available for your compiler and eliminate warnings by modifying the code.”<sup id="fnref:CMU2018" role="doc-noteref"><a href="#fn:CMU2018" rel="footnote">7</a></sup> This guide can help you do that.</p>

<h3 id="what-should-you-do-when-compiling-compilers">What should you do when compiling compilers?</h3>

<p>If you are compiling a C/C++ compiler, where practical make the generated compiler’s default options the <em>secure</em> options. For example, when compiling GCC, use <code>--enable-default-pie</code> (which enables the flags <code>-fPIE</code> and <code>-pie</code> by default when using the generated compiler executable) and <code>--enable-default-ssp</code> (which enables <code>-fstack-protector-strong</code> by default). Similarly, when compiling clang on Linux systems, set <code>CLANG_DEFAULT_PIE_ON_LINUX</code> (which has a similar effect as the option <code>--enable-default-pie</code> when compiling GCC).</p>

<h3 id="what-does-compiler-options-hardening-not-do">What does compiler options hardening not do?</h3>

<p>Compiler options hardening is not a silver bullet; it is not sufficient to rely solely on security features and functions to achieve secure software. Security is an emergent property of the entire system that relies on building and integrating all parts properly. However, if properly used, secure compiler options will complement existing processes, such as static and dynamic analysis, secure coding practices, negative test suites, profiling tools, and most importantly: security hygiene as a part of a solid design and architecture.</p>

<h2 id="recommended-compiler-options">Recommended Compiler Options</h2>

<p>This section describes recommendations for compiler and linker option flags that 1) enable compile-time checks that warn developers of potential defects in the source code (Table 1), and 2) enable run-time protection mechanisms, such as checks that are designed to detect when memory vulnerabilities in the application are exploited (Table 2).</p>

<p>The recommendations in Table 1 and Table 2 are primarily applicable to compiling user space code in GNU/Linux environments using either the GCC and Binutils toolchain or the Clang / LLVM toolchain and have been included in this document because they are:</p>

<ul>
  <li>widely deployed and enabled by default for pre-built packages in major Linux distributions, including Debian, Ubuntu, Red Hat and SUSE Linux.</li>
  <li>supported both by the GCC and Clang / LLVM toolchains.</li>
  <li>cross-platform and supported on (at least) Intel and AMD 64-bit x86 architectures as well as the 64-bit version of the ARM architecture (AArch64).</li>
</ul>

<p>For historical reasons, the GCC compiler and Binutils upstream projects do not enable optimization or security hardening options by default. While some aspects of the default options can be changed when building GCC and Binutils from source, the defaults used in the toolchains shipped with GNU/Linux distributions vary. Distributions may also ship multiple versions of toolchains with different defaults. Consequently, developers need to pay attention to compiler and linker option flags, and manage them according to their need of optimization, level of warning and error detection, and security hardening of the project.</p>

<p>To identify the default flags used by GCC or Clang on your system, you can examine the output of <code>cc -v</code> <em><code>&lt;sourcefile.c&gt;</code></em> and review the full command line used by the compiler to build the specified source file. This information serves two main purposes: understanding the setup of the compiler on your system and gaining insights into the options chosen by the distribution’s maintainers. Additionally, it can be valuable for diagnosing option-related issues or troubleshooting problems that may arise during software compilation. For instance, certain option flags rely on their order of appearance; when a parameter is set more than once, the later occurrence usually takes precedence. By analyzing the complete list of utilized flags, it becomes easier to troubleshoot issues caused by interactions between order-sensitive flags.</p>

<p>Similarly, running <code>cc -O2 -dM -E - &lt; /dev/null</code> will produce a comprehensive list of macro-defined constants. This output can be useful for troubleshooting problems related to compiler or library features that are enabled through specific macro definitions.</p>

<p>It’s important to note that sourcing GCC from third-party vendor may result in your instance of GCC being preconfigured with certain default flags enabled or disabled. These flags can significantly impact the security of your compiled code. Therefore, it’s essential to review the default flags if GCC is sourced through a Package Manager, Linux Distribution, or otherwise. We recommend explicitly enabling desired compiler flags in your build scripts or build system configuration rather than relying on the toolchain defaults. If you are creating packages for Linux distributions the distributions maintainers may have their own recommended ways of incorporating build flags. In such cases refer to the corresponding distribution documentation for, e.g., Debian<sup id="fnref:debian-hardening" role="doc-noteref"><a href="#fn:debian-hardening" rel="footnote">8</a></sup>, Gentoo<sup id="fnref:gentoo-hardening" role="doc-noteref"><a href="#fn:gentoo-hardening" rel="footnote">9</a></sup>, Fedora<sup id="fnref:fedora-hardening" role="doc-noteref"><a href="#fn:fedora-hardening" rel="footnote">10</a></sup>, OpenSUSE<sup id="fnref:opensuse-hardening" role="doc-noteref"><a href="#fn:opensuse-hardening" rel="footnote">11</a></sup>, or Ubuntu<sup id="fnref:ubuntu-hardening" role="doc-noteref"><a href="#fn:ubuntu-hardening" rel="footnote">12</a></sup>.</p>

<p>Typical compiler configurations do not report warnings from system headers, since application developers typically don’t control those headers.  In GCC this is because <code>-Wno-system-headers</code> is on by default, and clang also normally suppresses warnings from system headers . You will probably want to also mark third party include files as system headers so you can strongly increase the warning levels. Directories added with the command line option <code>-isystem</code> are treated as system header directories by GCC <sup id="fnref:gcc-directory-search" role="doc-noteref"><a href="#fn:gcc-directory-search" rel="footnote">14</a></sup> and Clang <sup id="fnref:clang-isystem" role="doc-noteref"><a href="#fn:clang-isystem" rel="footnote">15</a></sup>. In a Cmake configuration file you can do this with <code>include_directories</code> by adding <code>SYSTEM</code> before its parameter <sup id="fnref:cmake-include-directories" role="doc-noteref"><a href="#fn:cmake-include-directories" rel="footnote">16</a></sup>. There are trade-offs. Silencing warnings from system headers and third party libraries may hide vulnerabilities in them that affect the application. On the other hand, <em>not</em> silencing them focuses efforts on issues that the developer typically cannot control, impede progress when using <code>-Werror</code> in CI jobs, and often make it difficult to support building with older versions of third party code.</p>

<p>Compile-time checks enabled by options in Table 1 do not have an impact on the binary code generated by the compiler and consequently do not incur any tradeoffs in terms of performance or other run-time characteristics. Rather, they only issue warnings (or errors if the <code>-Werror</code> option is enabled) that inform of potential defects found in the source code.</p>

<p>When such additional warnings are enabled, developers should take time to understand the underlying issues that are flagged by the compiler and address them.</p>

<p>The options in Table 2 can be categorized into two types:</p>

<p>1) options that cause the compiler to augment the produced binary with run-time checks aimed to detect memory errors, and
2) options that direct the compiler to adjust the properties of the generated binary or code to ensure the resulting binary is compatible with OS-enforced protection mechanisms.</p>

<p>Testing is essential to validate the impact of enabling any of the options listed in Table 2, as they affect the binary produced by the compiler. Some of the compiler options described below may influence the software’s performance. However, this performance impact is usually context-specific, and in most cases, it is either minimal or the benefits outweigh the overhead. For further information on when significant performance impacts may occur, you can find detailed descriptions of these options later in this document.</p>

<p>When dealing with software for which performance is a critical factor developers should carefully assess the trades-offs between enabling more secure options and observed performance test data, taking into account the specific use cases of their software. Before implementing any changes in production environments, it is essential to conduct thorough benchmarking and testing. This will provide insights into how the compiler options influence both performance and security aspects of the software. Keep in mind that a system that works quickly but is vulnerable to adversaries is likely to be unacceptable to users. Benchmarks should consider any relevant performance characteristics such as average time, worst-case time, and memory use during execution. Additionally, the impact on the size of the produced binaries can be a concern, particularly for embedded systems.</p>

<p>Table 1: Recommended compiler options that enable strictly compile-time checks.</p>

<table>
  <thead>
    <tr>
      <th>Compiler Flag</th>
      <th>Supported since</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><a href="#-Wall"><code>-Wall</code></a></td>
      <td>GCC 2.95.3</td>
      <td>Enable warnings for constructs often associated with defects</td>
    </tr>
    <tr>
      <td><a href="#-Wformat=2"><code>-Wformat=2</code></a></td>
      <td>GCC 2.95.3</td>
      <td>Enable additional format function warnings</td>
    </tr>
    <tr>
      <td><a href="#-Wconversion"><code>-Wconversion</code></a></td>
      <td>GCC 2.95.3</td>
      <td>Enable implicit conversion warnings</td>
    </tr>
    <tr>
      <td><a href="#-Wtrampolines"><code>-Wtrampolines</code></a></td>
      <td>GCC 4.3</td>
      <td>Enable warnings about trampolines that require executable stacks</td>
    </tr>
    <tr>
      <td><a href="#-Wimplicit-fallthrough"><code>-Wimplicit-fallthrough</code></a></td>
      <td>GCC 7</td>
      <td>Warn when a switch case falls through</td>
    </tr>
    <tr>
      <td><a href="#-Werror"><code>-Werror</code></a></td>
      <td>GCC 2.95.3</td>
      <td>Make compiler warnings into errors (use in development, not in source distribution)</td>
    </tr>
  </tbody>
</table>

<p>Table 2: Recommended compiler options that enable run-time protection mechanisms.</p>

<table>
  <thead>
    <tr>
      <th>Compiler Flag</th>
      <th>Supported since</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><a href="#-D_FORTIFY_SOURCE=3"><code>-D_FORTIFY_SOURCE=3</code></a> </td>
      <td>GCC 12.0</td>
      <td>Fortify sources with compile- and run-time checks for unsafe libc usage and buffer overflows. Some fortification levels can impact performance.</td>
    </tr>
    <tr>
      <td><a href="#-D_GLIBCXX_ASSERTIONS"><code>-D_GLIBCXX_ASSERTIONS</code></a></td>
      <td>libstdc++ 6.0</td>
      <td>Precondition checks for C++ standard library calls. Can impact performance.</td>
    </tr>
    <tr>
      <td><a href="#-fstrict-flex-arrays"><code>-fstrict-flex-arrays=3</code></a></td>
      <td>GCC 13</td>
      <td>Consider a trailing array in a struct as a flexible array if declared as <code>[]</code></td>
    </tr>
    <tr>
      <td><a href="#-fstack-clash-protection"><code>-fstack-clash-protection</code></a></td>
      <td>GCC 8</td>
      <td>Enable run-time checks for variable-size stack allocation validity. Can impact performance.</td>
    </tr>
    <tr>
      <td><a href="#-fstack-protector-strong"><code>-fstack-protector-strong</code></a></td>
      <td>GCC 4.9.0</td>
      <td>Enable run-time checks for stack-based buffer overflows. Can impact performance.</td>
    </tr>
    <tr>
      <td><a href="#-fcf-protection=full"><code>-fcf-protection=full</code></a></td>
      <td>GCC 8</td>
      <td>Enable control flow protection to counter Return Oriented Programming (ROP) and Jump Oriented Programming (JOP) attacks on many x86 architectures</td>
    </tr>
    <tr>
      <td><a href="#-mbranch-protection-standard"><code>-mbranch-protection=standard</code></a></td>
      <td>GCC 9</td>
      <td>Enable branch protection to counter Return Oriented Programming (ROP) and Jump Oriented Programming (JOP) attacks on AArch64</td>
    </tr>
    <tr>
      <td><a href="#-Wl,-z,nodlopen"><code>-Wl,-z,nodlopen</code></a></td>
      <td>Binutils 2.10</td>
      <td>Restrict <code>dlopen(3)</code> calls to shared objects</td>
    </tr>
    <tr>
      <td><a href="#-Wl,-z,noexecstack"><code>-Wl,-z,noexecstack</code></a></td>
      <td>Binutils 2.14</td>
      <td>Enable data execution prevention by marking stack memory as non-executable</td>
    </tr>
    <tr>
      <td><a href="#-Wl,-z,relro"><code>-Wl,-z,relro</code></a></td>
      <td>Binutils 2.15</td>
      <td>Mark relocation table entries resolved at load-time as read-only. <code>-Wl,-z,now</code> can impact startup performance.</td>
    </tr>
    <tr>
      <td><a href="#-fPIE_-pie"><code>-fPIE -pie</code></a></td>
      <td>Binutils 2.16</td>
      <td>Build as position-independent executable. Can impact performance on 32-bit architectures.</td>
    </tr>
    <tr>
      <td><a href="#-fPIC_-shared"><code>-fPIC -shared</code></a></td>
      <td>&lt; Binutils 2.6</td>
      <td>Build as position-independent code. Can impact performance on 32-bit architectures.</td>
    </tr>
  </tbody>
</table>

<hr/>

<h3 id="enable-warnings-for-constructs-often-associated-with-defects">Enable warnings for constructs often associated with defects</h3>

<table>
  <thead>
    <tr>
      <th>Compiler Flag</th>
      <th>Supported since</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><span id="-Wall"><code>-Wall</code></span></td>
      <td>GCC 2.95.3</td>
      <td>Enable warnings for constructs often associated with defects</td>
    </tr>
  </tbody>
</table>

<h4 id="synopsis">Synopsis</h4>

<p>Warnings are compile-time diagnostics messages that indicate programming constructs that, while not inherently erroneous, are risky or suggest a programming error may have been made.</p>

<p>The <code>-Wall</code> and <code>-Wextra</code> compiler flags enable pre-defined sets of compile-time warnings.</p>

<p>The warnings in the <code>–Wall</code> set are generally easy to avoid or can be easily prevented by modifying the offending code.</p>

<p>The <code>-Wextra</code> set of warnings are either situational, or indicate problematic constructs that are harder to avoid and in some cases may be necessary.</p>

<p>NOTE: Despite its name the <code>-Wall</code> options does NOT enable all possible warning diagnostics, but a pre-defined subset. For a complete list of specific warnings enabled by the<code>-Wall</code> and <code>-Wextra</code> compiler please consult the GCC<sup id="fnref:gcc-warnings" role="doc-noteref"><a href="#fn:gcc-warnings" rel="footnote">18</a></sup> and Clang<sup id="fnref:clang-diagnostics" role="doc-noteref"><a href="#fn:clang-diagnostics" rel="footnote">19</a></sup> documentation respectively.</p>

<hr/>

<h3 id="enable-additional-format-function-warnings">Enable additional format function warnings</h3>

<table>
  <thead>
    <tr>
      <th>Compiler Flag</th>
      <th>Supported since</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><span id="-Wformat=2"><code>-Wformat=2</code></span></td>
      <td>GCC 2.95.3</td>
      <td>Enable additional format function warnings</td>
    </tr>
  </tbody>
</table>

<h4 id="synopsis-1">Synopsis</h4>

<p>Check calls to the <code>printf</code> and <code>scanf</code> family of functions to ensure that the arguments supplied have types appropriate to the format string specified, and that the conversions specified in the format string make sense.</p>

<p>The <code>-Wformat=2</code> form of the option also enables certain additional checks, including:</p>

<ul>
  <li>Warning if the format string is not a string literal and so cannot be checked, unless the format function takes its format arguments as a va_list (<code>-Wformat-nonliteral</code>).</li>
  <li>Warning about uses of format functions that represent possible security problems (<code>-Wformat-security</code>).</li>
  <li>Warning about <code>strftime</code> formats that may yield only a two-digit year (<code>-Wformat-y2k</code>).</li>
</ul>

<hr/>

<h3 id="enable-implicit-conversion-warnings">Enable implicit conversion warnings</h3>

<table>
  <thead>
    <tr>
      <th>Compiler Flag</th>
      <th>Supported since</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><span id="-Wconversion"><code>-Wconversion</code></span></td>
      <td>GCC 2.95.3</td>
      <td>Enable implicit conversion warnings</td>
    </tr>
  </tbody>
</table>

<h4 id="synopsis-2">Synopsis</h4>

<p>Check for implicit conversions that may alter a value such as:</p>

<ul>
  <li>conversions between real and integer data types</li>
  <li>conversion between signed and unsigned data types</li>
  <li>conversion between data types of different size</li>
  <li>confusing overload resolution for user-defined conversions in C++</li>
  <li>conversions that never use a type conversion operator in C++:
  conversions to void, the same type, a base class or a reference.</li>
</ul>

<p>Conversion between data types that cause the value of the data to be altered can cause   information to be omitted or translated in a way that produces unexpected values.</p>

<p>If the resulting values are used in a context where they control memory accesses or security decisions, then dangerous behaviors may occur, e.g., integer signedness or truncation errors can cause buffer overflows.</p>

<p>For C++ warnings about conversions between signed and unsigned integers are disabled by default unless <code>-Wsign-conversion</code> is explicitly enabled.</p>

<hr/>

<h3 id="enable-warning-about-trampolines-that-require-executable-stacks">Enable warning about trampolines that require executable stacks</h3>

<table>
  <thead>
    <tr>
      <th>Compiler Flag</th>
      <th>Supported since</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><span id="-Wtrampolines"><code>-Wtrampolines</code></span></td>
      <td>GCC 4.3</td>
      <td>Enable warnings about trampolines that require executable stacks</td>
    </tr>
  </tbody>
</table>

<h4 id="synopsis-3">Synopsis</h4>

<p>Check whether the compiler generates trampolines for pointers to nested functions which may interfere with stack virtual memory protection (non-executable stack.)</p>

<p>A trampoline is a small piece of data or code that is created at run time on the stack when the address of a nested function is taken and is used to call the nested function indirectly.</p>

<p>For most target architectures, including 64-bit x86, trampolines are made up of code and thus requires the stack to be made executable for the program to work properly. This interferes with the non-executable stack mitigation which is used by all major operating system to prevent code injection attacks (see Section 2.10).</p>

<hr/>

<h3 id="warn-about-implicit-fallthrough-in-switch-statements">Warn about implicit fallthrough in switch statements</h3>

<table>
  <thead>
    <tr>
      <th>Compiler Flag</th>
      <th>Supported since</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><span id="-Wimplicit-fallthrough"><code>-Wimplicit-fallthrough</code></span></td>
      <td>GCC 7</td>
      <td>Warn when a switch case falls through</td>
    </tr>
  </tbody>
</table>

<!-- Here "a fallthrough" is a noun, "to fall through" is the verb. -->

<h4 id="synopsis-4">Synopsis</h4>

<p>Warn when an implicit fallthrough occurs in a switch statement that has not been specifically marked as intended.</p>

<p>The <code>switch</code> statement in C and C++ allows a case block to fall through to the following case block (unless preceded by break, return, goto, or similar). This is widely considered a design defect in C, because a common mistake is to have a fallthrough occur when it was <em>not</em> intended<sup id="fnref:Polacek17" role="doc-noteref"><a href="#fn:Polacek17" rel="footnote">20</a></sup>.</p>

<p>This warning flag warns when a fallthrough occurs unless it is specially marked as being <em>intended</em>. The Linux kernel project uses this flag; it led to the discovery and fixing of many bugs<sup id="fnref:Corbet19" role="doc-noteref"><a href="#fn:Corbet19" rel="footnote">21</a></sup>.</p>

<p>This warning flag does not have a performance impact. However, sometimes a fallthrough <em>is</em> intentional. This flag requires developers annotate those (rare) cases in the source code where a fallthrough <em>is</em> intentional, to suppress the warning. Obviously, this annotation should <em>only</em> be used when it is intentional. C++17 (or later) code should simply use the attribute <code>[[fallthrough]]</code> as it is standard (remember to add <code>;</code> after it).</p>

<p>The C17 standard<sup id="fnref:C2017" role="doc-noteref"><a href="#fn:C2017" rel="footnote">22</a></sup> does not provide a mechanism to mark intentional fallthroughs. Different tools support different mechanisms for marking one, including attributes and comments in various forms<sup id="fnref:Shafik15" role="doc-noteref"><a href="#fn:Shafik15" rel="footnote">23</a></sup>. A portable way to mark one, used by the Linux kernel version 5.10 and later, is to define a keyword-like macro named <code>fallthrough</code> to mark an intentional fallthrough that adjusts to the relevant tool (e.g., compiler) mechanism:</p>

<div><div><pre><code><span>#if __has_attribute(__fallthrough__)
# define fallthrough                    __attribute__((__fallthrough__))
#else
# define fallthrough                    do {} while (0)  </span><span>/* fallthrough */</span><span>
#endif
</span></code></pre></div></div>

<hr/>

<h3 id="make-compiler-warnings-into-errors">Make compiler warnings into errors</h3>

<table>
  <thead>
    <tr>
      <th>Compiler Flag</th>
      <th>Supported since</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><span id="-Werror"><code>-Werror</code></span></td>
      <td>GCC 2.95.3</td>
      <td>Make compiler warnings into errors</td>
    </tr>
  </tbody>
</table>

<h4 id="synopsis-5">Synopsis</h4>

<p>Make the compiler treat all or specific warning diagnostics as errors.</p>

<p>Developers should use <code>-Werror</code>, but it is advisable to omit it when distributing source code as <code>-Werror</code> creates a dependency on specific toolchain vendors and versions <sup id="fnref:Johnston17" role="doc-noteref"><a href="#fn:Johnston17" rel="footnote">24</a></sup>. Such toolchain dependencies, i.e., which compiler version(s) the project is expected to work with, should be clearly noted in the project documentation or the build environment should be completely captured, e.g., via container recipes.</p>

<p>A blanket <code>-Werror</code> can be used to implement a zero-warning policy, although such policies can also be enforced at CI level. CI-based zero- or bounded-warning policies are often preferable, for the reasons explained above, and because they can be expanded beyond compiler warnings. For example, they can also include warnings from static analysis tools or generate warnings when <code>FIXME</code> and <code>TODO</code> comments are found.</p>

<p>The selective form: <code>-Werror=</code><em><code>&lt;warning-flag&gt;</code></em> can be used for refined warnings-as-error control without introducing a blanket zero-warning policy. This is beneficial to ensure that certain undesirable constructs or defects do not make it into produced builds.</p>

<p>For example, developers can decide to promote warnings that indicate interference with OS defense mechanisms (e.g., <code>-Werror=trampolines</code>), undefined behavior (e.g., <code>-Werror=return-type</code>), or constructs associated with software weaknesses (e.g., <code>-Werror=conversion</code>) to errors.</p>

<hr/>

<h3 id="fortify-sources-for-unsafe-libc-usage-and-buffer-overflows">Fortify sources for unsafe libc usage and buffer overflows</h3>

<table>
  <thead>
    <tr>
      <th>Compiler Flag</th>
      <th>Supported since</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><span id="-D_FORTIFY_SOURCE=1"><code>-D_FORTIFY_SOURCE=1</code></span></td>
      <td>GCC 4.0</td>
      <td>Fortify sources with compile- and run-time checks for unsafe libc usage and buffer overflows</td>
    </tr>
    <tr>
      <td><span id="-D_FORTIFY_SOURCE=2"><code>-D_FORTIFY_SOURCE=2</code></span></td>
      <td>GCC 4.0</td>
      <td>In addition to checks covered by <code>-D_FORTIFY_SOURCE=1</code>, also trap code that may be conforming to the C standard but still unsafe</td>
    </tr>
    <tr>
      <td><span id="-D_FORTIFY_SOURCE=3"><code>-D_FORTIFY_SOURCE=3</code></span></td>
      <td>GCC 12.0</td>
      <td>Same checks as in <code>-D_FORTIFY_SOURCE=2</code>, but with significantly more calls fortified with a potential to impact performance in some rare cases</td>
    </tr>
  </tbody>
</table>

<h4 id="synopsis-6">Synopsis</h4>

<p>The <code>_FORTIFY_SOURCE</code> macro enables a set of extensions to the GNU C library (glibc) that enable checking at entry points of a number of functions to immediately abort execution when it encounters unsafe behavior. A key feature of this checking is validation of objects passed to these function calls to ensure that the call will not result in a buffer overflow. This relies on the compiler being able to compute the size of the protected object at compile time. A full list of these functions is maintained in the GNU C Library manual<sup id="fnref:glibc-fortification" role="doc-noteref"><a href="#fn:glibc-fortification" rel="footnote">25</a></sup>:</p>

<blockquote>
  <p>memcpy, mempcpy, memmove, memset, strcpy, stpcpy, strncpy, strcat, strncat, sprintf, vsprintf, snprintf, vsnprintf, gets</p>
</blockquote>

<p>The <code>_FORTIFY_SOURCE</code> mechanisms have three modes of operation:</p>

<ul>
  <li><code>-D_FORTIFY_SOURCE=1</code>: conservative, compile-time and runtime checks; will not change (defined) behavior of programs. Checking for overflows is enabled when the compiler is able to estimate a compile time constant size for the protected object.</li>
  <li><code>-D_FORTIFY_SOURCE=2</code>: stricter checks that also detect behavior that may be unsafe even though it conforms to the C standard; may affect program behavior by disallowing certain programming constructs. An example of such checks is restricting of the <code>%n</code> format specifier to read-only format strings.</li>
  <li><code>-D_FORTIFY_SOURCE=3</code>: Same checks as those covered by <code>-D_FORTIFY_SOURCE=2</code> except that checking is enabled even when the compiler is able to estimate the size of the protected object as an expression, not just a compile time constant.</li>
</ul>

<p>To benefit from <code>_FORTIFY_SOURCE</code> checks the following requirements must be met:</p>

<ul>
  <li>the application must be built with <code>-O1</code> optimizations or higher; at least <code>-O2</code> is recommended.</li>
  <li>the compiler should be able to estimate sizes of the destination buffers at compile time. This can be facilitated by applications and libraries by using function attribute extensions supported by GCC and Clang<sup id="fnref:Poyarekar23" role="doc-noteref"><a href="#fn:Poyarekar23" rel="footnote">26</a></sup>.</li>
  <li>the application code must use glibc versions of the aforementioned functions (included with standard headers, e.g. <code>&lt;stdio.h&gt;</code> and <code>&lt;string.h&gt;</code>)</li>
</ul>

<p>If checks added by <code>_FORTIFY_SOURCE</code> detect unsafe behavior at run-time they will print an error message and terminate the application.</p>

<p>A default mode for FORTIFY_SOURCE may be predefined for a given compiler, for instance GCC shipped with Ubuntu 22.04 uses FORTIFY_SOURCE=2 by default. If a mode of FORTIFY_SOURCE is set on the command line which differs from the default, the compiler warns about redefining the FORTIFY_SOURCE macro. To avoid this, the predefined mode can be unset with -U_FORTIFY_SOURCE before setting the desired value.</p>

<h4 id="performance-implications">Performance implications</h4>

<p>Both <code>_FORTIFY_SOURCE=1</code> and <code>_FORTIFY_SOURCE=2</code> are expected to have a negligible run-time performance impact (~0.1% ).</p>

<h4 id="when-not-to-use">When not to use?</h4>

<p><code>_FORTIFY_SOURCE</code> is recommended for all application that depend on glibc and should be widely deployed. Most packages in all major Linux distributions enable at least <code>_FORTIFY_SOURCE=2</code> and some even enable <code>_FORTIFY_SOURCE=3</code>. There are a couple of situations when <code>_FORTIFY_SOURCE</code> may break existing applications:</p>

<ul>
  <li>If the fortified glibc function calls show up as hotspots in your application performance profile, there is a chance that <code>_FORTIFY_SOURCE</code> may have a negative performance impact. This is not a common or widespread slowdown<sup id="fnref:Poyarekar23:1" role="doc-noteref"><a href="#fn:Poyarekar23" rel="footnote">26</a></sup> but worth keeping in mind if slowdowns are observed due to this option.</li>
  <li>Applications that use the GNU extension for flexible array members in structs<sup id="fnref:gcc-zerolengtharrays" role="doc-noteref"><a href="#fn:gcc-zerolengtharrays" rel="footnote">27</a></sup> may confuse the compiler into thinking that an object is smaller than it actually is, resulting in spurious aborts. The safe resolution for this is to port these uses to C99 flexible arrays but if that is not possible (e.g., due to the need to support a compiler that does not support C99 flexible arrays), one may need to downgrade or disable <code>_FORTIFY_SOURCE</code> protections.</li>
</ul>

<h4 id="additional-considerations">Additional Considerations</h4>

<ul>
  <li>Applications that incorrectly use <code>malloc_usable_size</code><sup id="fnref:malloc_usable_size" role="doc-noteref"><a href="#fn:malloc_usable_size" rel="footnote">28</a></sup> to use the additional size reported by the function may abort at runtime. This is a bug in the application because the additional size reported by <code>malloc_usable_size</code> is not generally safe to dereference and is for diagnostic uses only. The correct fix for such issues is to avoid using <code>malloc_usable_size</code> as the glibc manual specifically states that it is for diagnostic purposes <em>only</em> <sup id="fnref:malloc_usable_size:1" role="doc-noteref"><a href="#fn:malloc_usable_size" rel="footnote">28</a></sup>. On many Linux systems these incorrect uses can be detected by running <code>readelf -Ws &lt;path&gt;</code> on the ELF binaries and searching for <code>malloc_usable_size@GLIBC</code><sup id="fnref:kpyrd23" role="doc-noteref"><a href="#fn:kpyrd23" rel="footnote">29</a></sup>. If avoiding <code>malloc_usable_size</code> is not possible, one may call <code>realloc</code> to resize the block to its usable size and to benefit from <code>_FORTIFY_SOURCE=3</code>.</li>
</ul>

<hr/>

<h3 id="precondition-checks-for-c-standard-library-calls">Precondition checks for C++ standard library calls</h3>

<table>
  <thead>
    <tr>
      <th>Compiler Flag</th>
      <th>Supported since</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><span id="-D_GLIBCXX_ASSERTIONS"><code>-D_GLIBCXX_ASSERTIONS</code></span></td>
      <td>libstdc++ 6.0</td>
      <td>(C++ using libcstdc++ only) Precondition checks for libstdc++ calls; can impact performance.</td>
    </tr>
  </tbody>
</table>

<h4 id="synopsis-7">Synopsis</h4>

<p>The C++ standard library implementation in GCC (libstdc++) provides run-time precondition checks for C++ standard library calls, such as bounds-checks for C++ strings and containers, and null-pointer checks when dereferencing smart pointers.</p>

<p>These precondition checks can be enabled by defining the <code>-D_GLIBCXX_ASSERTIONS</code> macro when compiling C++ code that calls into libstdc++<sup id="fnref:libsdcpp-macros" role="doc-noteref"><a href="#fn:libsdcpp-macros" rel="footnote">30</a></sup>.</p>

<h4 id="performance-implications-1">Performance implications</h4>

<p>Most calls into the C++ standard library have preconditions. Some preconditions can be checked in constant-time, others are more expensive. The checks enabled by <code>-D_GLIBCXX_ASSERTIONS</code> are  intended to be lightweight<sup id="fnref:Wakely15" role="doc-noteref"><a href="#fn:Wakely15" rel="footnote">31</a></sup>, i.e., constant-time checks but the exact behavior can differ between standard library versions. In some versions of libstdc++ the <code>-D_GLIBCXX_ASSERTIONS</code> macro can have a non-trivial impact on performance. Slowdowns of up to 6% have been reported<sup id="fnref:Kraus21" role="doc-noteref"><a href="#fn:Kraus21" rel="footnote">32</a></sup>.</p>

<h4 id="when-not-to-use-1">When not to use?</h4>

<p><code>-D_GLIBCXX_ASSERTIONS</code> is recommended for C++ applications that may handle untrusted data, as well as for any C++ application during testing.</p>

<p>This option is unnecessary for security for applications in production that only handle completely trusted data.</p>

<hr/>

<h3 id="enable-strict-flexible-arrays">Enable strict flexible arrays</h3>

<table>
  <thead>
    <tr>
      <th>Compiler Flag</th>
      <th>Supported since</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><span id="-fstrict-flex-arrays"><code>-fstrict-flex-arrays=3</code></span></td>
      <td>GCC 13</td>
      <td>Consider trailing array (at the end of struct) as flexible array only if declared as <code>[]</code></td>
    </tr>
    <tr>
      <td><code>-fstrict-flex-arrays=2</code></td>
      <td>GCC 13</td>
      <td>Consider trailing array as a flexible array only if declared as <code>[]</code>, or <code>[0]</code></td>
    </tr>
    <tr>
      <td><code>-fstrict-flex-arrays=1</code></td>
      <td>GCC 13</td>
      <td>Consider trailing array as a flexible array only if declared as <code>[]</code>, <code>[0]</code>, or <code>[1]</code></td>
    </tr>
    <tr>
      <td><code>-fstrict-flex-arrays=0</code></td>
      <td>GCC 13</td>
      <td>Consider any trailing array (at the end of a struct) a flexible array (the default)</td>
    </tr>
  </tbody>
</table>

<h4 id="synopsis-8">Synopsis</h4>

<p>Modify what the compiler determines is a trailing array. The higher levels make the compiler respect the sizes of trailing arrays more strictly<sup id="fnref:gcc-Wstrict-flex-arrays" role="doc-noteref"><a href="#fn:gcc-Wstrict-flex-arrays" rel="footnote">33</a></sup> (this affects bounds checking)<sup id="fnref:Guelton22" role="doc-noteref"><a href="#fn:Guelton22" rel="footnote">34</a></sup>.</p>

<p>By default, GCC and Clang treat all trailing arrays (arrays that are placed as the last member or a structure) as flexible-sized arrays, <em>regardless</em> of <em>declared</em> size for the purposes of <code>__builtin_object_size()</code> calculations used by <code>_FORTIFY_SOURCE</code><sup id="fnref:Cook21" role="doc-noteref"><a href="#fn:Cook21" rel="footnote">35</a></sup>. This disables various bounds checks that do not always need to be disabled. For example, with the default settings, given:</p>

<div><div><pre><code><span>struct</span> <span>trailing_array</span> <span>{</span>
    <span>int</span> <span>a</span><span>;</span>
    <span>int</span> <span>b</span><span>;</span>
    <span>int</span> <span>c</span><span>[</span><span>4</span><span>];</span>
<span>};</span>
<span>struct</span> <span>trailing_array</span> <span>*</span><span>trailing</span><span>;</span>
</code></pre></div></div>

<p>The value of <code>__builtin_object_size(trailing-&gt;c, 1)</code> is  <code>-1</code> (“unknown size”), inhibiting bounds checking. The rationale for this default behavior is to allow for the “struct hack” idiom that allows for trailing arrays to be treated as variable sized (regardless of their declared size)<sup id="fnref:Guelton22:1" role="doc-noteref"><a href="#fn:Guelton22" rel="footnote">34</a></sup>.</p>

<p>The <code>-fstrict-flex-arrays</code> option makes the compiler respect the sizes of trailing array member more strictly. This allows bounds checks added by instrumentation such as <code>_FORTIFY_SOURCE</code> or <code>-fsanitize=bounds</code><sup id="fnref:gcc-fsanitize-bounds" role="doc-noteref"><a href="#fn:gcc-fsanitize-bounds" rel="footnote">36</a></sup> to be able to correctly determine the size of trailing arrays.</p>

<p>The tradeoff is that code that relies on the “struct hack” for arbitrary sized trailing arrays may break as a result<sup id="fnref:Corbet23" role="doc-noteref"><a href="#fn:Corbet23" rel="footnote">37</a></sup>. Such code may need to be modified to clearly state that it does not have a specific bound.</p>

<p>The C99 flexible array notation <code>[]</code> is the standards-based approach for notating when an array bound is not specifically stated. However, some codebases use the GCC zero-length array extension <code>[0]</code>, and some codebases use a one-sized array <code>[1]</code> to indicate a flexible array member. Option values <code>1</code> and <code>2</code> were created so programs that use <code>[0]</code> and <code>[1]</code> for such cases can have some bounds-checking without modifying their source code.<sup id="fnref:Zhao22" role="doc-noteref"><a href="#fn:Zhao22" rel="footnote">38</a></sup></p>

<p>In this guide we recommend using the standard C99 flexible array notation <code>[]</code> instead of non-standard <code>[0]</code> or misleading <code>[1]</code>, and then using <code>-fstrict-flex-arrays=3</code> to improve bounds checking in such cases. In this case, code that uses <code>[0]</code> for a flexible array will need to be modified to use <code>[]</code> instead. Code that uses <code>[1]</code> for a flexible arrays needs to be modified to use <code>[]</code> and also extensively modified to eliminate off-by-one errors. Using <code>[1]</code> is not just misleading<sup id="fnref:Edge22" role="doc-noteref"><a href="#fn:Edge22" rel="footnote">39</a></sup>, it’s error-prone; beware that <em>existing</em> code using <code>[1]</code> to indicate a flexible array may <em>currently</em> have off-by-one errors<sup id="fnref:Cook23" role="doc-noteref"><a href="#fn:Cook23" rel="footnote">40</a></sup>.</p>

<p>Once in place, bounds-checking can occur in arrays with fixed declared sizes at the end of a struct. In addition, the source code unambiguously indicates, in a standard way, the cases where a flexible array is in use. There is normally no significant performance trade-off for this option (once any necessary changes have been made).</p>

<hr/>

<h3 id="enable-run-time-checks-for-variable-size-stack-allocation-validity">Enable run-time checks for variable-size stack allocation validity</h3>

<table>
  <thead>
    <tr>
      <th>Compiler Flag</th>
      <th>Supported since</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><span id="-fstack-clash-protection"><code>-fstack-clash-protection</code></span></td>
      <td>GCC 8</td>
      <td>Enable run-time checks for variable-size stack allocation validity</td>
    </tr>
    <tr>
      <td><code>-param stack-clash-protection-guard-size=</code><em><code>&lt;gap size&gt;</code></em></td>
      <td>GCC 8</td>
      <td>Set the stack guard gap size used to determine the probe granularity of the instrumented code</td>
    </tr>
  </tbody>
</table>

<h4 id="synopsis-9">Synopsis</h4>

<p>Stack clash protection mitigates attacks that aim to bypass the operating system’s <em>stack guard gap</em>. The stack guard gap is a security feature in the Linux kernel that protects processes against sequential stack overflows that overflow the stack in order to corrupt adjacent memory regions.</p>

<p>To avoid the stack guard gap from being bypassed each fresh allocation on the stack needs to probe the freshly allocated memory for the stack guard gap if it is present. Stack clash protection ensures a single allocation may not be larger than the stack guard gap size and the compiler translates larger allocations into a series of smaller sub-allocations. In addition, it ensures that any series of sub-allocations cannot exceed the stack guard gap size without an intervening probe.</p>

<p>Probe instructions can either be implicit or explicit. Implicit probes occur naturally as part of the application’s code, such as when x86 and x86_64 call instructions push the return address onto the stack. Implicit probes do not incur any additional performance cost. Explicit probes, on the other hand, consists of additional probe instructions emitted by the compiler.</p>

<h4 id="performance-implications-2">Performance implications</h4>

<p>Applications for which functions allocate at most the size of the stack guard gap of stack space memory at a time do not exhibit adverse performance impact from stack clash protection.</p>

<p>However, stack clash protection may cause performance degradation for applications that perform large allocations that exceed the stack guard gap size. Performance impact scales with the size of large allocations and number of explicit probes required. The performance degradation can be mitigated by increasing the Linux stack guard gap size controlled via the <code>vm.heap-stack-gap</code> sysctl parameter) and compiling the application with the corresponding <code>-param stack-clash-protection-guard-size</code>. Higher values reduce the number of explicit probes, but a value larger than the kernel guard gap will leave code vulnerable to stack clash style attacks.</p>

<p>Note that <code>vm.heap-stack-gap</code> expresses the gap as multiple of page size whereas <code>stack-clash-protection-guard-size</code> is expressed as a power of two in bytes. Hence for <code>vm.heap-stack-gap=256</code> on x86 (256 * 4KiB = 1MiB gap) the corresponding <code>stack-clash-protection-guard-size</code> is 20 (2^20 = 1MiB gap).</p>

<hr/>

<h3 id="enable-run-time-checks-for-stack-based-buffer-overflows">Enable run-time checks for stack-based buffer overflows</h3>

<table>
  <thead>
    <tr>
      <th>Compiler Flag</th>
      <th>Supported since</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><span id="-fstack-protector-strong"><code>-fstack-protector-strong</code></span></td>
      <td>GCC 4.9.0</td>
      <td>Enable run-time checks for stack-based buffer overflows using strong heuristic</td>
    </tr>
    <tr>
      <td><code>-fstack-protector-all</code></td>
      <td>GCC</td>
      <td>Enable run-time checks for stack-based buffer overflows for all functions</td>
    </tr>
    <tr>
      <td><code>-fstack-protector</code></td>
      <td>GCC</td>
      <td>Enable run-time checks for stack-based buffer overflows for functions with character arrays if <em>n</em> or more bytes</td>
    </tr>
  </tbody>
</table>

<h4 id="synopsis-10">Synopsis</h4>

<p>Stack protector instruments code produced by the compiler to detect overflows in buffers allocated on the program stack at run-time (colloquially referred to as <em>“stack smashing”</em>).</p>

<p>The detection is based on inserting a <em>canary</em> value into the stack frame in the function prologue. The canary is verified against a reference value in the function epilogue. If they differ the runtime calls <code>__stack_chk_fail()</code>, which will terminate the offending application.</p>

<p>This mitigates potential control-flow hijacking attacks that may lead to arbitrary code execution by corrupting return addresses stored on the stack.</p>

<p>Out-of-date versions of GCC may not detect or defend against overflows of dynamically-sized local variables such as variable-length arrays or buffers allocated using <code>alloca()</code> when compiling for 64-bit Arm (Aarch64) processors<sup id="fnref:Meta23" role="doc-noteref"><a href="#fn:Meta23" rel="footnote">41</a></sup>. Users of GCC-based toolchains for Aarch64 should ensure they use up-to-date versions of GCC 7 or later that support an alternative stack frame layout that places all local variables below saved registers, with the stack-protector canary between them<sup id="fnref:Arm23" role="doc-noteref"><a href="#fn:Arm23" rel="footnote">42</a></sup>.</p>

<p>Some versions of GCC<sup id="fnref:CVE-2023-4039" role="doc-noteref"><a href="#fn:CVE-2023-4039" rel="footnote">43</a></sup> may not detect or defend against overflows of dynamically-sized local variables such as variable-length arrays or buffers allocated using alloca() when compiling for 64-bit Arm (Aarch64) processors<sup id="fnref:Meta23:1" role="doc-noteref"><a href="#fn:Meta23" rel="footnote">41</a></sup>. Users of GCC-based toolchains for Aarch64 should, before depending on it, determine if they support an alternative stack frame layout that places all local variables below saved registers, with the stack-protector canary between them<sup id="fnref:Arm23:1" role="doc-noteref"><a href="#fn:Arm23" rel="footnote">42</a></sup>.</p>

<h4 id="performance-implications-3">Performance implications</h4>

<p>Stack protector supports three different heuristics that are used to determine which functions are instrumented with run-time checks during compilation:</p>

<ul>
  <li><code>-fstack-protector-strong</code><sup id="fnref:Han11" role="doc-noteref"><a href="#fn:Han11" rel="footnote">44</a></sup>: instrument any function that
    <ul>
      <li>takes the address of any of its local variables on the right-hand-side of an assignment or as part of a function argument</li>
      <li>allocates a local array, regardless of type or length</li>
      <li>allocates a local struct or union which contains an array, regardless of the type of length of the array</li>
      <li>has explicit local register variables</li>
    </ul>
  </li>
  <li><code>-fstack-protector</code>: instrument functions that call alloca() or allocate character arrays of n bytes or more in size . The threshold for instrumentation is adjustable via the <code>--param=ssp-buffer-size=</code><em><code>n</code></em> option (default: 8 bytes).</li>
  <li><code>-fstack-protector-all</code>: instrument all functions.</li>
</ul>

<p>The performance overhead is dependent on the number of function’s instrumented and the frequency at which instrumented functions are activated at run-time. Enabling <code>-fstack-protector-strong</code> is recommended as it provides the best balance between function coverage and performance. Projects using older compiler versions can consider <code>-fstack-protector-all</code> or <code>-fstack-protector</code> with a stricter threshold, e.g. <code>--param=ssp-buffer-size=4</code>.</p>

<h4 id="when-not-to-use-2">When not to use?</h4>

<p><code>-fstack-protector-strong</code> is recommended for all applications with conventional stack behavior. Applications with hand-written assembler optimization that make assumptions about the layout of the stack may be incompatible with stack-protector functionality.</p>

<hr/>

<h3 id="implement-control-flow-integrity-checks">Implement control flow integrity checks</h3>

<table>
  <thead>
    <tr>
      <th>Compiler Flag</th>
      <th>Supported since</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><span id="-fcf-protection=full"><code>-fcf-protection=full</code></span><br/></td>
      <td>GCC 8</td>
      <td>Enable control flow protection to counter Return Oriented Programming (ROP) and Jump Oriented Programming (JOP) attacks on many x86 architectures</td>
    </tr>
    <tr>
      <td><span id="-mbranch-protection-standard"><code>-mbranch-protection=standard</code></span></td>
      <td>GCC 9</td>
      <td>Enable branch protection to counter Return Oriented Programming (ROP) and Jump Oriented Programming (JOP) attacks on AArch64</td>
    </tr>
  </tbody>
</table>

<h4 id="synopsis-11">Synopsis</h4>

<p>Return-oriented programming (ROP) uses an initial subversion (such as a buffer overflow) to perform an indirect jump that executes a different sequence of instructions. This is often existing code being misused, so these are often called “code reuse attacks”. A countermeasure is to ensure that jump addresses and return addresses are correct. This is not a complete solution, but it makes attacks harder to perform.</p>

<h4 id="performance-implications-4">Performance implications</h4>

<p>There are performance implications but they are typically mild due to hardware assistance. The <code>-fcf-protection=full</code> flag enables Intel’s Control-Flow Enforcement Technology (CET) <sup id="fnref:IntelCET" role="doc-noteref"><a href="#fn:IntelCET" rel="footnote">45</a></sup>, which introduces shadow stack (SHSTK) and indirect branch tracking (IBT). The <code>-mbranch-protection=standard</code> flag invokes similar protections in the AArch64. In clang <code>-mbranch-protection=standard</code> is equivalent to <code>-mbranch-protection=bti+pac-ret</code> and invokes the AArch64 Branch Target Identification (BTI) and Pointer Authentication using key A (pac-ret) <sup id="fnref:Armclang" role="doc-noteref"><a href="#fn:Armclang" rel="footnote">46</a></sup>.</p>

<hr/>



<table>
  <thead>
    <tr>
      <th>Compiler Flag</th>
      <th>Supported since</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><span id="-Wl,-z,nodlopen"><code>-Wl,-z,nodlopen</code></span><br/></td>
      <td>Binutils 2.10</td>
      <td>Restrict <code>dlopen(3)</code> calls to shared objects</td>
    </tr>
  </tbody>
</table>

<h4 id="synopsis-12">Synopsis</h4>

<p>The <code>nodlopen</code> option passed to the linker when building shared objects will mark the resulting object as not available to <code>dlopen(3)</code> calls. This can help in reducing an attacker’s ability to load and manipulate shared objects. Loading new objects or duplicating an already existing shared object in a process can constitute a part of the attack chain in runtime exploitation.</p>

<p>The <code>nodlopen</code> restrictions are based on setting the <code>DF_1_NOOPEN</code> flags in the object’s <code>.dynamic</code> section tags. Since the enforcement of restricted calls is done inside libc when <code>dlopen(3)</code> are called it is possible for attackers to bypass the check by 1) manipulating the tag embedded in the object if they have the ability to modify the object file on disk, or 2) bypassing <code>dlopen(3)</code> and loading shared objects through attacker controlled code, e.g., pieces of shellcode or return-oriented-programming gadgets. However, restrictions on <code>dlopen(3)</code> put in place at link time can still be useful in restricting the attacker before they have obtained arbitrary code execution capabilities.</p>

<h4 id="performance-implications-5">Performance implications</h4>

<p>None, marking shared objects as restricted to <code>dlopen(3)</code> does not have an impact on performance at run time.</p>

<h4 id="when-not-to-use-3">When not to use?</h4>

<p>In some cases it is desirable for applications to manage the loading of libraries directly via <code>dlopen(3)</code> without relying on the conventional dynamic linking. Such situations include:</p>

<ul>
  <li>Selecting application plugins to load</li>
  <li>Selecting a version of a library optimized for particular CPUs. Leveraged by, e.g., math libraries that provide different implementations of mathematical operations for different environments.</li>
  <li>Selecting an implementation of an API by different vendors</li>
  <li>Delay loading of shared libraries to decrease application start times. (See also lazy binding in Section 2.11)</li>
</ul>

<p>Since <code>nodlopen</code> interferes with applications that rely on to <code>dlopen(3)</code> to manipulate shared objects they cannot be used with applications that rely on such functionality.</p>

<hr/>

<h3 id="enable-data-execution-prevention">Enable data execution prevention</h3>

<table>
  <thead>
    <tr>
      <th>Compiler Flag</th>
      <th>Supported since</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><span id="-Wl,-z,noexecstack"><code>-Wl,-z,noexecstack</code></span></td>
      <td>Binutils 2.14</td>
      <td>Enable data execution prevention by marking stack memory as non-executable</td>
    </tr>
  </tbody>
</table>

<h4 id="synopsis-13">Synopsis</h4>

<p>All major modern processor architectures incorporate memory management primitives that give the OS the ability to mark certain memory areas, such as the stack and heap, as non-executable, e.g., the AMD <em>“non-execute”</em> (NX) bit and the Intel <em>“execute disable”</em> (XD) bit. This mechanism prevents the stack or heap from being used to inject malicious code during a run-time attack.</p>

<p>The <code>-Wl,-z,noexecstack</code> option tells the linker to mark the corresponding program segment as non-executable which enables the OS to configure memory access rights correctly when the program executable is loaded into memory.</p>

<p>However, some language-level programming constructs, such as taking the address of a nested function (a GNU C extension to ISO standard C) requires special compiler handling which may prevent the linker from marking stack segments correctly as non-executable<sup id="fnref:gcc-trampolines" role="doc-noteref"><a href="#fn:gcc-trampolines" rel="footnote">47</a></sup>.</p>

<p>Consequently the <code>-Wl,-z,noexecstack</code> option works best when combined with appropriate warning flags (<code>-Wtrampolines</code> where available) that indicate whether language constructs interfere with stack virtual memory protection.</p>

<h4 id="performance-implications-6">Performance implications</h4>

<p>None, marking the stack and/or heap as non-executable does not have an impact on performance at run time.</p>

<h4 id="when-not-to-use-4">When not to use?</h4>

<p>Applications that leverage just-in-time (JIT) compilation for managed bytecode or interpreted language runtimes may require specific writable memory areas, such as part of the heap to remain executable in order to execute JIT code.</p>

<p>Such applications require sandboxing techniques to protect the application’s memory integrity from potentially malicious JIT code.</p>

<p>In addition to protection against malicious code injection such applications may also require special mitigations against speculative execution side channels <sup id="fnref:Intel18" role="doc-noteref"><a href="#fn:Intel18" rel="footnote">48</a></sup>.</p>

<hr/>

<h3 id="mark-relocation-table-entries-resolved-at-load-time-as-read-only">Mark relocation table entries resolved at load-time as read-only</h3>

<table>
  <thead>
    <tr>
      <th>Compiler Flag</th>
      <th>Supported since</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><span id="-Wl,-z,relro"><code>-Wl,-z,relro</code></span></td>
      <td>Binutils 2.15</td>
      <td>Mark relocation table entries resolved at load- time as read-only</td>
    </tr>
  </tbody>
</table>

<p><em>“Read-only relocation”</em> (RELRO) marks relocation table entries as read-only after they have been resolved by the dynamic linker/loader (<code>ld.so</code>). Relocation is the process performed by <code>ld.so</code> that connects unresolved symbolic references to proper addresses of corresponding in-memory objects.</p>

<p>Marking relocations read-only will mitigate run-time attacks that corrupt Global Offset Table (GOT) entries to hijack program execution or to cause unintended data accesses. Collectively such attacks are referred to as <em>GOT overwrite attacks</em> or <em>GOT hijacking</em>.</p>

<p>RELRO can be instantiated in one of two modes: partial RELRO or full RELRO. Full RELRO is necessary for effective mitigation for GOT overwrite attacks; partial RELRO is not sufficient.</p>

<p>Partial RELRO (<code>-Wl,-z,relro</code>) will mark certain ELF sections as read-only after initialization by the runtime loader. These include <code>.init_array</code>, <code>.fini_array</code>, <code>.dynamic</code>, and the non-PLT portion of <code>.got</code>. However, in partial RELRO the auxiliary procedure linkage portion of the GOT (<code>.got.plt</code>) is still left writable to facilitate late binding.</p>

<p>Full RELRO (<code>-Wl,-z,relro -Wl,-z,now</code>) disables lazy binding. This allows <code>ld.so</code> to resolve the entire GOT at application startup and mark also the PLT portion of the GOT as read-only.</p>

<h4 id="performance-implications-7">Performance implications</h4>

<p>Since lazy binding is primarily intended to speed up application startup times by spreading out the symbol resolution operations throughout the lifetime of the application, enabling full RELRO can increase the startup time for applications with large numbers of dynamic dependencies. The performance impact scales with the number of dynamically linked functions.</p>

<h4 id="when-not-to-use-5">When not to use?</h4>

<p>Applications that are sensitive to the performance impact on startup time should consider whether the increase in startup time caused by full RELRO impacts the user experience. As an alternative, developers can consider statically linking large library dependencies to the application executable.</p>

<p>Static linking avoids the need for dynamic symbol resolution altogether but can make it more difficult to deploy patches to dependencies compared to upgrading shared libraries. Developers need to consider whether static linking is discouraged in their deployment scenarios, e.g., major Linux distributions generally forbid static linking of shared application dependencies.</p>

<hr/>

<h3 id="build-as-position-independent-code">Build as position-independent code</h3>

<table>
  <thead>
    <tr>
      <th>Compiler Flag</th>
      <th>Supported since</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><span id="-fPIE_-pie"><code>-fPIE -pie</code></span></td>
      <td>Binutils 2.16</td>
      <td>Build as position-independent executable.</td>
    </tr>
    <tr>
      <td></td>
      <td>&lt; Binutils 2.6</td>
      <td>Build as position-independent code.</td>
    </tr>
  </tbody>
</table>

<h4 id="synopsis-14">Synopsis</h4>

<p>Position-independent code (PIC) and executables (PIE) are machine code objects that execute properly regardless of the exact address at which they are loaded at in process memory.</p>

<p>GNU/Linux requires program executable to be built as PIE in order to benefit from address-space layout randomization (ASLR). ASLR is the primary means of mitigating code-reuse exploits, e.g., <em>return-to-libc</em> and <em>return-oriented programming</em> in modern GNU/Linux distributions. In code-reuse exploits the adversary corrupts vulnerable code pointers, such as return addresses stored on the program stack and makes them refer to pre-existing executable code in program memory. ASLR randomizes the location of shared libraries and the program executable every time the object is loaded into memory to make memory addresses useful in exploits harder to predict.</p>

<h4 id="performance-implications-8">Performance implications</h4>

<p>Negligible on 64-bit architectures.</p>

<p>On 32-bit x86 PIC exhibits moderate performance penalties (5-10%)<sup id="fnref:ubuntu-hardening:1" role="doc-noteref"><a href="#fn:ubuntu-hardening" rel="footnote">12</a></sup>. This is due to data accesses using mov instructions on 32-bit x86 only support absolute addresses. To make the code position-independent memory references are transformed to lookup memory addresses from a global offset table (GOT) populated at load-time with the correct addresses to program data. Consequently, data references require an additional memory load compared to non-PIC code on 32-bit x86. However, the main reason for the performance penalty is the increased register pressure resulting from keeping the lookup address to the GOT available in a register<sup id="fnref:Bendersky11a" role="doc-noteref"><a href="#fn:Bendersky11a" rel="footnote">49</a></sup>.</p>

<p>The x86_64 architecture supports mov instructions that address memory using offsets relative to the instruction pointer (i.e., the address of the currently executing instruction). This is referred to as RIP addressing. PIC on x86_64 uses RIP addressing for accessing the GOT which relieves the register pressure associated with PIC on 32-bit x86 and results in a smaller impact on performance. Shared libraries are created PIC on x86_64 by default<sup id="fnref:Bendersky11b" role="doc-noteref"><a href="#fn:Bendersky11b" rel="footnote">50</a></sup>.</p>

<h4 id="when-not-to-use-6">When not to use?</h4>

<p>Resource-constrained embedded systems may save memory by <em>prelinking</em> executables at compile time. Prelinking performs some relocation decisions, normally made by the dynamic linker, ahead of time. As a result, fewer relocations need to be performed by the dynamic linker, reducing startup time and memory consumption for applications. PIE does not prevent prelinking but enabling ASLR on prelinked binaries overrides the compile-time decisions, thus nullifying the run-time memory savings gained by prelinking. If the memory savings gained by prelinking are important for a system PIE can be enabled for a subset of executables that are at higher risk, e.g., applications that process untrusted external input.</p>

<hr/>

<h2 id="discouraged-compiler-options">Discouraged Compiler Options</h2>

<p>This section describes discouraged compiler and linker option flags that may lead to potential defects with security implications in produced binaries.</p>

<p>Table 3: List of discouraged compiler and linker options.</p>

<table>
  <thead>
    <tr>
      <th>Compiler Flag</th>
      <th>Supported since</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><a href="#-Wl,-rpath"><code>-Wl,-rpath,</code><em><code>path_to_so</code></em></a></td>
      <td>Binutils 2.11</td>
      <td>Hard-code run-time search paths in executable files or libraries</td>
    </tr>
  </tbody>
</table>

<hr/>

<h3 id="hard-code-run-time-search-paths-in-executable-files-or-libraries">Hard-code run-time search paths in executable files or libraries</h3>

<table>
  <thead>
    <tr>
      <th>Compiler Flag</th>
      <th>Supported since</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><span id="-Wl,-rpath"><code>-Wl,-rpath,</code><em><code>path_to_so</code></em></span></td>
      <td>Binutils 2.11</td>
      <td>Hard-code run-time search paths in executable files or libraries</td>
    </tr>
  </tbody>
</table>

<h4 id="synopsis-15">Synopsis</h4>

<p>The <code>-rpath</code> option records the specified path to a shared object files to the <code>DT_RPATH</code> or <code>DT_RUNPATH</code> header value in the produced ELF binary. The recorded rpath may override or supplement the system default search path used by the dynamic linker to find the specified library dependency the executable or library requires.</p>

<p>The rpath provided by the original (and default) <code>DT_RPATH</code> entry takes precedence over environmental overrides such as <code>LD_LIBRARY_PATH</code> and one object’s <code>DT_RPATH</code> can be used for resolving dependencies of another object. These were design errors rectified with the introduction of <code>DT_RUNPATH</code> value which has a lower precedence with respect to <code>LD_LIBRARY_PATH</code> and only affect the search path of an object’s own, immediate dependencies<sup id="fnref:Kerrisk23" role="doc-noteref"><a href="#fn:Kerrisk23" rel="footnote">51</a></sup>.</p>

<p>Setting rpath in release binaries (irrespective of whether <code>DT_RPATH</code> or <code>DT_RUNPATH</code> is used) is an unsafe programming practice and may under certain conditions lead to security vulnerabilities. For instance, an attacker may be able to supply their own shared files in directories where rpath is pointing to, thereby overriding those libraries that would be supplied by the operating system. This could occur as a result of setting a relative rpath (i.e. <code>foo.so</code> rather than <code>/usr/lib/foo.so</code>) in environments where an attacker can control the working directory, and point it to a directory where they can place a malicious dependency.</p>

<p>The keyword <code>$ORIGIN</code> in rpath is expanded (by the dynamic loader) to be path of the directory where the object is found. Attackers who can control the location of the object with a rpath set (e.g., via hard links) can manipulate the <code>$ORIGIN</code> to point to a directory which they can control.</p>

<p>Setting rpath in setuid/setgid programs can lead to privilege escalation under conditions where untrusted libraries loaded via a set rpath are executed as part of the privileged program. While setuid/setgid binaries ignore environmental overrides to search path (such as <code>LD_PRELOAD</code>, <code>LD_LIBRARY_PATH</code> etc.) rpath within such binaries can provide an attacker with equivalent capabilities to manipulate the dependency search paths.</p>

<hr/>

<h2 id="sanitizers">Sanitizers</h2>

<p>Sanitizers are a suite of compiler-based tools designed to detect and pinpoint memory-safety issues and other defects in applications written in C and C++. They provide similar capabilities as dynamic analysis tools built on frameworks such as Valgrind. However, unlike Valgrind, sanitizers leverage compile-time instrumentation to intercept and monitor memory accesses. This allows sanitizers to be more efficient and accurate compared to dynamic analyzers. On average, Sanitizers impose a 2× to 4× slowdown in instrumented binaries, whereas dynamic instrumentation can exhibit slowdowns as large as 20× to 50×<sup id="fnref:Kratochvil21" role="doc-noteref"><a href="#fn:Kratochvil21" rel="footnote">52</a></sup>. As a tradeoff, sanitizers must be enabled at compile time whereas Valgrind can be used with unmodified binaries. Table 4 lists sanitizer options supported by GCC and Clang.</p>

<p>While more efficient compared to dynamic analysis, sanitizers are still prohibitively expensive in terms of performance penalty and memory overhead to be used with Release builds, but excel at providing memory diagnostics in Debug, and in certain cases Test builds. For example, fuzz testing (or “fuzzing”) is a common security assurance activity designed to identify conditions that trigger memory-related bugs. Fuzzing is primarily useful for identifying memory errors that lead to application crashes. However, if fuzz testing is performed in binaries equipped with sanitizer functionality it is possible to also identify bugs which do not crash the application. Another benefit is the enhanced diagnostics information produced by sanitizers.</p>

<p>As with all testing practices, sanitizers cannot absolutely prove the absence of bugs. However, when used appropriately and regularly they can help in identifying latent memory, concurrency, and undefined behavior-related bugs which may be difficult to pinpoint.</p>

<p>Table 4: Sanitizer options in GCC and Clang.</p>

<table>
  <thead>
    <tr>
      <th>Compiler Flag</th>
      <th>Supported since</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>-fsanitize=address</code></td>
      <td>GCC 4.8</td>
      <td>Enables AddressSanitizer to detect memory errors at run-time</td>
    </tr>
    <tr>
      <td><code>-fsanitize=thread</code></td>
      <td>GCC 4.8</td>
      <td>Enables ThreadSanitizer to detect data race bugs at run time</td>
    </tr>
    <tr>
      <td><code>-fsanitize=leak</code></td>
      <td>GCC 4.8</td>
      <td>Enables LeakSanitizer to detect memory leaks at run time</td>
    </tr>
    <tr>
      <td><code>-fsanitize=undefined</code></td>
      <td>GCC 4.9</td>
      <td>Enables UndefinedBehaviorSanitizer to detect undefined behavior at run time</td>
    </tr>
  </tbody>
</table>

<hr/>

<h3 id="addresssanitizer">AddressSanitizer</h3>

<table>
  <thead>
    <tr>
      <th>Compiler Flag</th>
      <th>Supported since</th>
      <th>Description</th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>-fsanitize=address</code></td>
      <td>GCC 4.8</td>
      <td>Enables AddressSanitizer to detect memory errors at run-time</td>
      <td> </td>
      <td><code>-fsanitize=thread</code></td>
      <td>GCC 4.8</td>
      <td>Enables ThreadSanitizer to detect data race bugs at run time</td>
    </tr>
  </tbody>
</table>

<p>AddressSanitizer (ASan) is a memory error detector that can identify memory defects that involve:</p>

<ul>
  <li>Buffer overflows in the stack, on the heap, and in global variables</li>
  <li>Use-after-free conditions (dereference of dangling pointers)</li>
  <li>Use-after-return (use of stack memory reserved for locals after return from function)</li>
  <li>Use-after-scope conditions (use of stack address outside the lexical scope of variable)</li>
  <li>Initialization order bugs</li>
  <li>Memory leaks (see also LeakSanitizer in Section 0)</li>
</ul>

<p>To enable ASan add <code>-fsanitize=address</code> to the compiler flags (<code>CFLAGS</code> for C, <code>CXXFLAGS</code> for C++) and linker flags (<code>LDFLAGS</code>). Consider combining ASan with the following compiler flags:</p>

<ul>
  <li><code>-O1</code> (disables inlining and improves stack traces, higher levels improve performance)</li>
  <li><code>-g</code> (to display source file names and line numbers in the produced error messages)</li>
  <li><code>-fno-omit-frame-pointer</code> (to further improve stack traces)</li>
  <li><code>-fno-optimize-sibling-calls</code> (disable tail call optimizations)</li>
  <li><code>-fno-common</code> (disable common symbols to improve tracking of globals)</li>
</ul>

<p>The run-time behavior of ASan can be influenced using the <code>ASAN_OPTIONS</code> environment variable. The run-time options can be used enable additional memory error checks and to tweak ASan performance. An up-to-date list of supported options are available on the AddressSanitizerFlags article on the project’s GitHub Wiki<sup id="fnref:asan-flags" role="doc-noteref"><a href="#fn:asan-flags" rel="footnote">53</a></sup>. If set to <code>ASAN_OPTIONS=help=1</code> the available options are shown at startup of the instrumented program. This is particularly useful for determining which options are supported by the specific version ASan integrated to the compiler being used. A useful pre-set to enable more aggressive diagnostics compared to the default behavior is given below:</p>

<p>ASAN_OPTIONS=strict_string_checks=1:detect_stack_use_after_return=1: </p>

<p>When ASan encounters a memory error it (by default) terminates the application and prints an error message and stack trace describing the nature and location of the detected error. A systematic description of the different error types and the corresponding root causes reported by ASan can be found in the AddressSanitizer article on the project’s GitHub Wiki<sup id="fnref:asan" role="doc-noteref"><a href="#fn:asan" rel="footnote">54</a></sup>.</p>

<p>ASan cannot be used simultaneously with ThreadSanitizer or LeakSanitizer. It is not possible to mix ASan-instrumented code produced by GCC with ASan-instrumented code produced Clang as the ASan implementations in GCC and Clang are mutually incompatible.</p>

<hr/>

<h3 id="threadsanitizer">ThreadSanitizer</h3>

<table>
  <thead>
    <tr>
      <th>Compiler Flag</th>
      <th>Supported since</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>-fsanitize=thread</code></td>
      <td>GCC 4.8</td>
      <td>Enables ThreadSanitizer to detect data race bugs at run time</td>
    </tr>
  </tbody>
</table>

<p>ThreadSanitizer (TSan) is a data race detector for C/C++. Data races occur when two (or more) threads of the same process access the same memory location concurrently and without synchronization. If at least one of the accesses is a write the application risks entering an inconsistent internal state. If two or more threads attempt to write to the memory location simultaneously a data race may cause memory corruption. Data races are notoriously difficult to debug since the order of accesses is typically non-deterministic and dependent on the precise timing of events in the offending threads.</p>

<p>To enable TSan add <code>-fsanitize=thread</code> to the compiler flags (<code>CFLAGS</code> for C, <code>CXXFLAGS</code> for C++) and linker flags (<code>LDFLAGS</code>). Consider combining TSan with the following compiler flags:</p>

<ul>
  <li><code>-O2</code> (or higher for reasonable performance)</li>
  <li><code>-g</code> (to display source file names and line numbers in the produced warning messages)</li>
</ul>

<p>The run-time behavior of TSan can be influenced using the <code>TSAN_OPTIONS</code> environment variable. An up-to-date list of supported options are available on the ThreadSanitizerFlags article on the project’s GitHub Wiki<sup id="fnref:tsan-flags" role="doc-noteref"><a href="#fn:tsan-flags" rel="footnote">55</a></sup>. If set to <code>TSAN_OPTIONS=help=1</code> the available options are shown at startup of the instrumented program.</p>

<p>When TSan encounters a potential data race it (by default) reports the race by printing a warning message with a description of the program state that led to the data race. A detailed description of the report format can be found in the ThreadSanitizerReportFormat article on the project’s GitHub Wiki<sup id="fnref:tsan-reportformat" role="doc-noteref"><a href="#fn:tsan-reportformat" rel="footnote">56</a></sup>.</p>

<p>TSan cannot be used simultaneously with AddressSanitizer (ASan) or LeakSanitizer (LSan). It is not possible to mix TSan-instrumented code produced by GCC with TSan-instrumented code produced Clang as the TSan implementations in GCC and Clang are mutually incompatible. TSan generally requires all code to be compiled with <code>-fsanitize=thread</code> to operate correctly.</p>

<hr/>

<h3 id="leaksanitizer">LeakSanitizer</h3>

<table>
  <thead>
    <tr>
      <th>Compiler Flag</th>
      <th>Supported since</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>-fsanitize=leak</code></td>
      <td>GCC 4.8</td>
      <td>Enables LeakSanitizer to detect memory leaks at run time</td>
    </tr>
  </tbody>
</table>

<p>LeakSanitizer (LSan) is a stand-alone version of the memory leak detection built into ASan. It allows analysis of memory leaks without the associated slowdown introduced by ASan. Unlike ASan, LSan does not require compile-time instrumentation, but consists only of a runtime library. The <code>-fsanitize=leak</code> option instructs the linker to link the application executable against the LSan library which overrides <code>malloc()</code> and other allocator functions.</p>

<p>The run-time behavior of LSan can be influenced using the <code>LSAN_OPTIONS</code> environment variable. If set to <code>LSAN_OPTIONS=help=1</code> the available options are shown at startup of the program.</p>

<p>LSan cannot be used simultaneously with AddressSanitizer (ASan) or ThreadSanitizer (TSan). If either ASan or TSan is enabled during the build the <code>-fsanitize=leak</code> option is ignored by the linker.</p>

<hr/>

<h3 id="undefinedbehaviorsanitizer">UndefinedBehaviorSanitizer</h3>

<table>
  <thead>
    <tr>
      <th>Compiler Flag</th>
      <th>Supported since</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>-fsanitize=undefined</code></td>
      <td>GCC 4.9</td>
      <td>Enables UndefinedBehaviorSanitizer to detect undefined behavior at run time</td>
    </tr>
  </tbody>
</table>

<p>UndefinedBehaviorSanitizer (UBSan) is a detector of non-portable or erroneous program constructs which cause behavior which is not clearly defined in the ISO C standard. UBSan provides a large number of sub-options to enable / disable individual checks for different classes of undefined behavior. Consult the GCC<sup id="fnref:gcc-instrumentation" role="doc-noteref"><a href="#fn:gcc-instrumentation" rel="footnote">57</a></sup> and Clang<sup id="fnref:clang-ubsan" role="doc-noteref"><a href="#fn:clang-ubsan" rel="footnote">58</a></sup> documentation respectively for up-to-date information on supported sub-options.</p>

<p>To enable UBSan add <code>-fsanitize=undefined</code> to the compiler flags (<code>CFLAGS</code> for C, <code>CXXFLAGS</code> for C++) and linker flags (<code>LDFLAGS</code>) together with any desired sub-options. Consider combining TSan with the following compiler flags:</p>

<ul>
  <li><code>-O1</code> (required or higher for reasonable performance)</li>
  <li><code>-g</code> (to display source file names and line numbers in the produced warning messages)</li>
</ul>

<p>The run-time behavior of UBSan can be influenced using the <code>UBSAN_OPTIONS</code> environment variable. If set to <code>UBSAN_OPTIONS=help=1</code> the available options are shown at startup of the instrumented program.</p>

<hr/>

<h2 id="maintaining-debug-information-in-separate-files">Maintaining debug information in separate files</h2>

<p>An application’s debugging information can be placed in a debug info file separate from the application’s executable. This allows the executable to be shipped stripped of debug information while still allowing a debugger to obtain the debugging information from the debug info files when problems in the release executable are being diagnosed. Both the GNU Debugger (GDB) and LLVM Debugger (LLDB) allows debug information for stripped binaries to be loaded from separate debug info files.</p>

<p>There are several reasons why developers may wish to separate the debug information from the executable:</p>

<ul>
  <li>Debug information can be very large – in some cases even larger than the executable code itself! If separate, it can be omitted where it is not needed. For this reason, most Linux distributions distribute debug information for application packages in separate debug info files.</li>
  <li>It avoids inadvertently revealing some sensitive implementation details about the application if its source code is not available. The availability of symbol information makes binary analysis and reverse engineering of the application’s executable easier. However, tools like decompilers can work without debug information, so the security of a system must <em>not</em> depend on omitting such information.</li>
</ul>

<p>The following series of commands generate the debug info file, strip the debugging information from the main executable, and add the debug link section.</p>

<div><div><pre><code>objcopy <span>--only-keep-debug</span> executable_file executable_file.debug
objcopy <span>--strip-unneeded</span> executable_file
objcopy <span>--add-gnu-debuglink</span><span>=</span>executable_file.debug executable_file
</code></pre></div></div>

<h3 id="debug-information-in-the-elf-binary-format">Debug information in the ELF binary format</h3>

<p>In ELF binaries debug and symbol information are stored in discrete ELF sections unless separate debug info files are created. Table 5 shows the ELF sections which normally contain debug, symbol or other auxiliary information.</p>

<table>
  <thead>
    <tr>
      <th>Elf Section</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>.debug</code></td>
      <td>Symbolic debug information for debuggers (typically in DWARF format<sup id="fnref:DWARF17" role="doc-noteref"><a href="#fn:DWARF17" rel="footnote">59</a></sup>)</td>
    </tr>
    <tr>
      <td><code>.comment</code></td>
      <td>GCC version information</td>
    </tr>
    <tr>
      <td><code>.dynstr</code></td>
      <td>Strings needed for dynamic symbol name lookup via .dynsym</td>
    </tr>
    <tr>
      <td><code>.dynsym</code></td>
      <td>Dynamic symbol lookup table used for run-time relocations</td>
    </tr>
    <tr>
      <td><code>.note</code></td>
      <td>Auxiliary metadata, e.g, ABI tags<sup id="fnref:LF15" role="doc-noteref"><a href="#fn:LF15" rel="footnote">60</a></sup> and Build ID<sup id="fnref:binutils-ld" role="doc-noteref"><a href="#fn:binutils-ld" rel="footnote">61</a></sup></td>
    </tr>
    <tr>
      <td><code>.strtab</code></td>
      <td>Strings representing names in <code>.symtab</code></td>
    </tr>
    <tr>
      <td><code>.symtab</code></td>
      <td>Global symbol table used for symbol name lookup by debuggers</td>
    </tr>
  </tbody>
</table>

<p>Whether a particular section is present or absent in an ELF binary indicates what type of information is available. The availability of symbol information makes binary analysis easier as debuggers, disassemblers and binary code analysis tools, such as Ghidra<sup id="fnref:ghidra-homepage" role="doc-noteref"><a href="#fn:ghidra-homepage" rel="footnote">62</a></sup> and IDA Pro<sup id="fnref:idapro-homepage" role="doc-noteref"><a href="#fn:idapro-homepage" rel="footnote">63</a></sup>, can use available symbol information to automatically annotate decompiled machine code. Similarly, the availability of debug information makes dynamic analysis of the application in a debugger easier. Stripping unnecessary debug and symbol information from the binary does not make it impervious against reverse engineering, however it does considerably increase the cost and manual effort required for successful exploitation.</p>

<h3 id="creating-debug-info-files">Creating debug info files</h3>

<p>The debug info files are ordinary executables with an identical section layout as the application’s original executable, but without the executable’s data. The debug info file is created by compiling the application executable with the desired debug information included, then processing the executable with the <code>objcopy</code> utility to produce the stripped executable (without debugging information) and the debug info file (without executable data). Both GNU binutils <code>objcopy</code><sup id="fnref:binutils-objcopy" role="doc-noteref"><a href="#fn:binutils-objcopy" rel="footnote">64</a></sup> and LLVM <code>llvm-objcopy</code><sup id="fnref:llvm-objcopy" role="doc-noteref"><a href="#fn:llvm-objcopy" rel="footnote">65</a></sup> support the same options for stripping debug information and creating the debug info file. The shell snippet below shows the <code>objcopy</code> invocation for creating a debug info file from an executable with debug information.</p>

<div><div><pre><code>objcopy <span>--only-keep-debug</span> executable_file executable_file.debug
</code></pre></div></div>

<p>There are no particular requirements for the debug link filename, although a common convention is to name debug info for an executable, e.g., “executable.debug”. While the debug info file can have the same name as the executable it is preferred to use an extension such as “.debug” as it means that the debug info file can be placed in the same directory as the executable.</p>

<p>Debug info files allows the binary to be analyzed in the same way as the original binary with debug and symbol information intact. They should be handled with care and not exposed in computing environments where they may be obtained by adversaries.</p>

<h3 id="strip-debug-and-symbol-information">Strip debug and symbol information</h3>

<p>Once the debug info file has been created the debug and symbol information can be stripped from the original binary using either the <code>objcopy</code> or <code>strip</code><sup id="fnref:binutils-strip" role="doc-noteref"><a href="#fn:binutils-strip" rel="footnote">66</a></sup> utilities provided by Binutils, or the <code>llvm-objcopy</code> or <code>llvm-strip</code><sup id="fnref:llvm-strip" role="doc-noteref"><a href="#fn:llvm-strip" rel="footnote">67</a></sup> equivalents provided by LLVM. The shell snippets below show how the debug and unneeded symbol information can be removed from an executable using <code>objcopy</code> and <code>strip</code> respectively. If code signing is enforced on the application binaries the debug and symbol information must be stripped away before the binaries are signed.</p>

<div><div><pre><code>strip <span>--strip-unneeded</span> executable_file

objcopy <span>--strip-unneeded</span> executable_file
</code></pre></div></div>

<p>The <code>--strip-unneeded</code> option in <code>objcopy</code> and will remove all symbol information (ELF <code>.symtab</code> and <code>.strtab</code> sections) from the binary that is not needed for processing relocations. In addition, it will trigger the removal of any symbolic debug information from the binary (ELF <code>.debug</code> sections and all sections with the <code>.debug</code> prefix).</p>

<p>Removing symbol information used for relocations is discouraged as it may interfere with resolving dynamically linked symbols (ELF <code>.dynsym</code> and <code>.dynstr</code> sections) and Address Space Layout Randomization (ASLR) at run-time. As a result, it should be expected that debuggers and binary analysis will be able to resolve calls to dynamically linked functions to the correct symbol information. Static linking can be considered as an alternative where applicable to avoid dynamically linked symbols to remain visible in resulting binaries.</p>

<p><strong>Stripping additional sections</strong></p>

<p>Note that <code>--strip-unneeded</code> only discards standard ELF sections as unneeded. Since an ELF binary can have any number of additional sections which are unknown to <code>objcopy</code> and <code>strip</code> they cannot determine whether such unrecognized sections are safe to remove. This includes for example the <code>.comment</code> section added by GCC.  The shell snippets below show how non-standard sections, such as <code>.comment</code> can be removed in addition to the unneeded sections identified by <code>--strip-unneeded</code>. If the application includes custom, application-specific ELF sections with possible sensitive diagnostics information or metadata which is not required at run-time during normal operations developers may wish to strip such additional sections from release binaries.</p>

<div><div><pre><code>objcopy <span>--strip-unneeded</span> <span>--remove-section</span><span>=</span>.comment executable_file

strip <span>--strip-unneeded</span> <span>--remove-section</span><span>=</span>.comment executable_file
</code></pre></div></div>

<h3 id="add-a-debug-link-to-the-binary">Add a debug link to the binary</h3>

<p>To allow the debugger to identify the correct debug information the executable must be associated with its corresponding debug info file. This can be done in two ways:</p>

<ul>
  <li>Include a “debug link” within the executable that specifies the name of the corresponding debug info file.</li>
  <li>Include a “build ID”, a unique bit string, within the executable from which the debug info file’s name can be derived.</li>
</ul>

<p>In most cases the debug link is preferrable as it allows the developers to name the debug info file and verifies a checksum over the debug information files content before the symbol information is sourced from the file during debugging.</p>

<p><strong>Debug link</strong></p>

<p>A debug link is a special section (<code>.gnu_debuglink</code>) in the executable file that contains the name of the corresponding debug info file and a 32-bit cyclic redundancy checksum (CRC) computed over the debug info file’s full contents. Any executable file format can carry debug link information as long is can contain a section named <code>.gnu_debuglink</code>. The shell snippet below shows how a debug link can be added to an executable using <code>objcopy</code> (or <code>llvm-objcopy</code>).</p>

<div><div><pre><code>objcopy <span>--add-gnu-debuglink</span><span>=</span>executable_file.debug executable_file
</code></pre></div></div>

<p>If the debug information file is built in one location but is going to be later installed at a different location the <code>--add-gnu-debuglink</code> option should be used with the path to the built debug information file. The debug info file must exist at the specified path as it is required for the CRC calculation which allows the debugger to validate that the debug info file it loads matches that of the executable.</p>

<p>Note that <code>.gnu_debuglink</code> does not contain the full pathname to the debug info; only a filename with the leading directory components removed. GDB looks for the debug info file with the specified filename in a series of search directories starting from the directory where the executable is placed. For a complete list of search paths refer to the GDB documentation<sup id="fnref:gdb-debugfiles" role="doc-noteref"><a href="#fn:gdb-debugfiles" rel="footnote">68</a></sup>.</p>

<p><strong>Build ID</strong></p>

<p>A build ID is a unique bit string stored in <code>.note.gnu.build-id</code> of the ELF <code>.note</code> section that is (statistically) unique to the binary file. A debugger can use the build ID to identify the corresponding debug info file if the same build ID is also present in the debug info file.</p>

<p>If the build ID method is used the debug info file’s name is computed from the build ID. GDB searches the global debug directories (typically <code>/usr/lib/debug</code>) for a <code>.build-id/xx/yyyy.debug</code> file, where <code>xx</code> are the first two hex characters of the build ID and <code>yyyy</code> are the rest of the build ID bit string in hex (actual build ID strings are 32 or more hex characters).</p>

<p>Note that the build ID does not act as a checksum for the executable or debug info file. For more information on the build ID feature please refer to the GDB<sup id="fnref:binutils-objcopy:1" role="doc-noteref"><a href="#fn:binutils-objcopy" rel="footnote">64</a></sup> and GNU linker<sup id="fnref:binutils-ld:1" role="doc-noteref"><a href="#fn:binutils-ld" rel="footnote">61</a></sup> documentation.</p>

<h2 id="contributors">Contributors</h2>

<p>The OpenSSF Developer BEST Practices Working group thanks Ericsson for their generous initial donation of content to start collaboration on this guide.</p>

<ul>
  <li>Thomas Nyman, Ericsson</li>
  <li>Robert Byrne, Ericsson</li>
  <li>Jussi Auvinen, Ericsson</li>
  <li>Christopher “CRob” Robinson, Intel</li>
  <li>David A. Wheeler, Linux Foundation</li>
  <li>David Edelsohn, IBM</li>
  <li>Gabriel Dos Reis, Microsoft</li>
  <li>Georg Kunz, Ericsson</li>
  <li>George Wilson, IBM</li>
  <li>Jack Kelly, ControlPlane</li>
  <li>Kees Cook, Google</li>
  <li>Mark Esler, Canonical</li>
  <li>Randall T. Vasquez, Linux Foundation</li>
  <li>Robert C. Seacord, Woven by Toyota</li>
  <li>Siddharth Sharma, Red Hat</li>
  <li>Siddhesh Poyarekar, Red Hat</li>
  <li>William Huhn, Intel</li>
</ul>

<h2 id="license">License</h2>

<p>Copyright 2023, OpenSSF contributors, licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a></p>

<h2 id="appendix-list-of-considered-compiler-options">Appendix: List of Considered Compiler Options</h2>

<p>Many more security-relevant compiler options exist than are recommended in this guide. Some of these have been considered for inclusion, but for various reasons have, in-the-end been excluded from the set of recommended options. The following table lists options that have been reviewed and the rationale for their exclusion. While they are not in the recommended list, you may find them useful for your purposes.</p>

<table>
  <thead>
    <tr>
      <th>Compiler Flag</th>
      <th>Supported since</th>
      <th>Rationale</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><span id="-Wl,-z,nodump"><code>-Wl,-z,nodump</code></span></td>
      <td>Binutils 2.10</td>
      <td>Single-purpose feature for Solaris compatibility<sup id="fnref:nodump" role="doc-noteref"><a href="#fn:nodump" rel="footnote">69</a></sup>.</td>
    </tr>
    <tr>
      <td><span id="-Wl,-z,noexecheap"><code>-Wl,-z,noexecheap</code></span></td>
      <td>Binutils 2.15 (Hardened Gentoo / PaX only )</td>
      <td>Hardened Gentoo / PaX specific Binutils extension<sup id="fnref:noexecheap" role="doc-noteref"><a href="#fn:noexecheap" rel="footnote">70</a></sup>, not present in upstream toolchains.</td>
    </tr>
    <tr>
      <td><span id="-D_LIBCPP_ASSERT"><code>-D_LIBCPP_ASSERT</code></span></td>
      <td>libc++ 3.3.0</td>
      <td>Deprecated in favor of <code>_LIBCPP_ENABLE_HARDENED_MODE</code><sup id="fnref:libcpp_assert" role="doc-noteref"><a href="#fn:libcpp_assert" rel="footnote">71</a></sup></td>
    </tr>
    <tr>
      <td><span id="-D_LIBCPP_ENABLE_ASSERTIONS"><code>-D_LIBCPP_ENABLE_ASSERTIONS</code></span></td>
      <td>libc++ 3.3.0</td>
      <td>Deprecated in favor of <code>_LIBCPP_ENABLE_HARDENED_MODE</code><sup id="fnref:libcpp_assert:1" role="doc-noteref"><a href="#fn:libcpp_assert" rel="footnote">71</a></sup></td>
    </tr>
  </tbody>
</table>

<h2 id="references">References</h2>



      
      
      
    </div></div>
  </body>
</html>
