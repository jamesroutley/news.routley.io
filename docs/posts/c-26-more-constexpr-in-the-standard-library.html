<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.sandordargo.com/blog/2025/04/30/cpp26-constexpr-library-changes">Original</a>
    <h1>C&#43;&#43;26: more constexpr in the standard library</h1>
    
    <div id="readability-page-1" class="page"><div><p>Last week, we discussed <a href="https://www.sandordargo.com/blog/2025/04/23/cpp26-constexpr-language-changes">language features that are becoming <code>constexpr</code> in C++26</a>. Today, let’s turn our attention to the standard library features that will soon be usable at compile time. One topic is missing: exceptions. As they need both core language and library changes, I thought they deserved their own post.</p><h2 id="p2562r1-constexpr-stable-sorting"><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2562r1.pdf">P2562R1</a>: <code>constexpr</code> stable sorting</h2><p>This paper proposes making <code>std::stable_sort</code>, <code>std::stable_partition</code>, <code>std::inplace_merge</code>, and their <code>ranges</code> counterparts usable in constant expressions. While many algorithms have become <code>constexpr</code> over the years, this family related to stable sorting had remained exceptions — until now.</p><p>The recent introduction of <code>constexpr</code> containers gives extra motivation for this proposal. If you can construct a container at compile time, it’s only natural to want to sort it there, too. More importantly, a <code>constexpr std::vector</code> can now support efficient, stable sorting algorithms.</p><p>A key question is whether the algorithm can meet its computational complexity requirements under the constraints of constant evaluation. Fortunately, <code>std::is_constant_evaluated()</code> provides an escape hatch for implementations. For deeper details, check out the <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2562r1.pdf">proposal</a> itself.</p><h2 id="p1383r2-more-constexpr-for-cmath-and-complex"><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1383r2.pdf">P1383R2</a>: More <code>constexpr</code> for <code>&lt;cmath&gt;</code> and <code>&lt;complex&gt;</code></h2><p>While <a href="https://www.sandordargo.com/blog/2023/05/24/cpp23-constexpr#constexpr-for-cmath-and-cstdlib">P0533</a> made many <code>&lt;cmath&gt;</code> and <code>&lt;cstdlib&gt;</code> functions <code>constexpr</code>-friendly in C++23, it only addressed functions with trivial behavior — those no more complex than the basic arithmetic operators.</p><p>Floating-point computations can yield different results depending on compiler settings, optimization levels, and hardware platforms. For instance, calculating <code>std::sin(1e100)</code> may produce varying outcomes due to the intricacies of floating-point arithmetic at such scales. The paper discusses these challenges and suggests that some variability in results is acceptable, given the nature of floating-point computations.</p><p><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1383r2.pdf">The proposal</a> accepts the need for a balance between strict determinism and practical flexibility. It suggests that while some functions should produce consistent results across platforms, others may inherently allow for some variability.</p><h2 id="p3074r7-trivial-unions-was-stduninitializedt"><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3074r7.html">P3074R7</a>: trivial <code>union</code>s (was <code>std::uninitialized&lt;T&gt;</code>)</h2><p>To implement static, in-place, <code>constexpr</code>-friendly containers like non-allocating vectors, you often need uninitialized storage — typically via <code>union</code>s. However, default behavior for special members of unions has been limiting: if not all alternatives are trivial, the special member is deleted. This presents a problem for <code>constexpr</code> code where a no-op destructor isn’t quite the same as a trivial one.</p><p>The road to solving this wasn’t short: <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3074r7.html">P3074R7</a> went through seven revisions and considered five possible solutions—including library-based approaches, new annotations, and even a new union type. Ultimately, the committee decided to just <em>make it work</em> with minimal changes to the user experience.</p><p>But how?</p><p>For unions, the default constructor - if there is no default member initializer - is always going to be trivial. If the first alternative is an implicit-lifetime time, it begins its life-time and becomes the active member.</p><p>The defaulted destructor is deleted if either the union has a user-provided default constructor or there exists a variant alternative that has a default member initializer and that member’s destructor is either deleted or inaccessible. Otherwise, the destructor is trivial.</p><p>This excerpt from the proposal shows the changes well.</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td><pre><span>// trivial default constructor (does not start lifetime of s)</span>
<span>// trivial destructor</span>
<span>// (status quo: deleted default constructor and destructor)</span>
<span>union</span> <span>U1</span> <span>{</span> <span>string</span> <span>s</span><span>;</span> <span>};</span>

<span>// non-trivial default constructor</span>
<span>// deleted destructor</span>
<span>// (status quo: deleted destructor)</span>
<span>union</span> <span>U2</span> <span>{</span> <span>string</span> <span>s</span> <span>=</span> <span>&#34;hello&#34;</span><span>;</span> <span>}</span>

<span>// trivial default constructor</span>
<span>// starts lifetime of s</span>
<span>// trivial destructor</span>
<span>// (status quo: deleted default constructor and destructor)</span>
<span>union</span> <span>U3</span> <span>{</span> <span>string</span> <span>s</span><span>[</span><span>10</span><span>];</span> <span>}</span>

<span>// non-trivial default constructor (initializes next)</span>
<span>// trivial destructor</span>
<span>// (status quo: deleted destructor)</span>
<span>union</span> <span>U4</span> <span>{</span> <span>string</span> <span>s</span><span>;</span> <span>U4</span><span>*</span> <span>next</span> <span>=</span> <span>nullptr</span><span>;</span> <span>};</span>
</pre></td></tr></tbody></table></code></p></div><h2 id="p3372r2-constexpr-containers-and-adaptors"><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3372r2.html">P3372R2</a>: <code>constexpr</code> containers and adaptors</h2><p>Hana Dusíková authored <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3372r2.html">a massive proposal</a> that boils down to a simple goal: make (almost) all containers and adaptors <code>constexpr</code>.</p><p>Up until now, only a handful of them were <code>constexpr</code>-friendly (<code>std::vector</code>, <code>std::span</code>, <code>std::mdspan</code>, <code>std::basic_string</code> and <code>std::basic_string_view</code>). From now on, the situation will be flipped. Almost everything will be <code>constexpr</code>-friendly. There is one exception and one constraint:</p><ul><li><code>std::hive</code> is not included, because it doesn’t have a stable wording yet</li><li>if you want to use unordered containers at compile-time, you must provide your own hashing facility, because <code>std::hash</code> cannot be made <code>constexpr</code>-friendly due to its requirements. Its result is guaranteed to be consistent only with the duration of the program.</li></ul><p>Happy days!</p><h2 id="p3508r0-wording-for-constexpr-for-specialized-memory-algorithms"><a href="https://www.sandordargo.com/blog/2025/04/30/www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3508r0.html">P3508R0</a>: Wording for “<code>constexpr</code> for specialized memory algorithms”</h2><p>Such a strange title, isn’t? Wording for <em>something</em>…</p><p>As it turns out, there was already a paper accepted (<a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2283r2.pdf">P2283R2</a>) making specialized memory algorithms <code>constexpr</code>-friendly. Algorithms that are essential for implementing <code>constexpr</code> container support, yet they were forgotten from C++20.</p><p>These algorithms are (both in <code>std</code> and in <code>std::ranges</code> namespaces):</p><ul><li><code>uninitialized_value_construct</code></li><li><code>uninitialized_value_construct_n</code></li><li><code>uninitialized_copy</code></li><li><code>uninitialized_copy_result</code></li><li><code>uninitialized_copy_n</code></li><li><code>uninitialized_copy_n_result</code></li><li><code>uninitialized_move</code></li><li><code>uninitialized_move_result</code></li><li><code>uninitialized_move_n</code></li><li><code>uninitialized_move_n_result</code></li><li><code>uninitialized_fill</code></li><li><code>uninitialized_fill_n</code></li></ul><p>When the paper was made, the necessary implementation change was to use <code>std::construct_at</code> instead of <em>placement new</em>, as <code>std::consturct_at</code> was already <code>constexpr</code>. But in the meantime, <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2747r2.html">P2747R2</a> was accepted and <em>placement new</em> in the core language also became <code>constexpr</code>. Therefore, the implementation of the above functions doesn’t have to be changed, only their signatures have to be updated to support <code>constexpr</code>. Hence, the wording change.</p><h2 id="p3369r0-constexpr-for-uninitialized_default_construct"><a href="https://www.sandordargo.com/blog/2025/04/30/www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3369r0.html">P3369R0</a>: <code>constexpr</code> for <code>uninitialized_default_construct</code></h2><p>We saw that the <code>constexpr</code> <em>placement new</em> affected <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2283r2.pdf">P2283R2</a> and raised the need for a wording change performed in <a href="https://www.sandordargo.com/blog/2025/04/30/www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3508r0.html">P3508R0</a>. But that’s not the only side-effect it had. From the above-listed algorithm families, one is missing: <code>uninitialized_default_construct</code>. The reason is that <code>uninitialized_default_construct</code> cannot be implemented with <code>std::construct_at</code> as it always performs value initialization, default initialization was impossible.</p><p>But with <code>constexpr</code> <em>placement new</em> this is not an issue anymore, therefore <code>uninitialized_default_construct</code> can also be turned into <code>constexpr</code>.</p><h2 id="conclusion">Conclusion</h2><p>C++26 marks a huge step forward for <code>constexpr</code> support in the standard library. From stable sorting algorithms to containers, from tricky union rules to specialised memory functions, compile-time programming is becoming more and more supported.</p><p>In the next article, we’ll cover compile-time exceptions!</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,</li><li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a></li><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</li></ul><p><a href="https://www.patreon.com/sandordargo"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png"/></a></p></div></div>
  </body>
</html>
