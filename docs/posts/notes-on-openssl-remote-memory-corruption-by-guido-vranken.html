<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://guidovranken.com/2022/06/27/notes-on-openssl-remote-memory-corruption/">Original</a>
    <h1>Notes on OpenSSL remote memory corruption by Guido Vranken</h1>
    
    <div id="readability-page-1" class="page"><article id="post-2084">
	<!-- .entry-header -->

	<div>
		
<p>OpenSSL version 3.0.4, released on June 21th 2022, is susceptible to remote memory corruption which can be triggered trivially by an attacker. BoringSSL, LibreSSL and the OpenSSL 1.1.1 branch are not affected. Furthermore, only x64 systems with AVX512 support are affected. The bug is <a href="https://github.com/openssl/openssl/pull/18626">fixed</a> in the repository but a new release is still pending.</p>



<p>Somewhat peculiarly, almost nobody is talking about this. If RCE exploitation is possible this makes it worse than Heartbleed in an isolated severity assessment, though the potential blast radius is limited by the fact that many people are still using the 1.1.1 tree rather than 3, libssl has forked into LibreSSL and BoringSSL, the vulnerability has only existed for a week (HB existed for years) and an AVX512-capable CPU is required.</p>



<p>This post gives some background on how this bug came to be and some notes on its exploitability.</p>



<p>On May 31th 2022 I found and reported an issue with constant-time Montgomery modular exponentiation in OpenSSL and BoringSSL (but not LibreSSL). For some values of <code>B, E, M</code> for which <code>B ^ E % M == 0</code>, some functions would return <code>M</code> instead of 0; the result was not fully reduced.</p>



<p>It was found that there are four distinct code paths affected by this:</p>



<ul><li><a href="https://github.com/openssl/openssl/blob/b2feb9f0e394da6570346598837f1b01eb58c028/crypto/bn/bn_exp.c#L668-L669">RSAZ 1024</a></li><li><a href="https://github.com/openssl/openssl/blob/b2feb9f0e394da6570346598837f1b01eb58c028/crypto/bn/bn_exp.c#L678">RSAZ 512</a></li><li><a href="https://github.com/openssl/openssl/blob/b2feb9f0e394da6570346598837f1b01eb58c028/crypto/bn/bn_exp.c#L1448-L1452">Dual 1024 RSAZ</a></li><li><a href="https://github.com/openssl/openssl/blob/b2feb9f0e394da6570346598837f1b01eb58c028/crypto/bn/bn_exp.c#L687-L1124">Default constant-time Montgomery modular exponentiation</a></li></ul>



<p>David Benjamin of Google <a href="https://boringssl.googlesource.com/boringssl/+/13c9d5c69d04485a7a8840c12185c832026c8315">analyzed the issue extensively</a> and found that the bug does not constitute a security risk (at least not internally; external callers might end up in incorrect states depending on what they are trying to compute). Interestingly, he also found an apparent <a href="https://boringssl.googlesource.com/boringssl/+/801a801024febe1a33add5ddaa719e257d97aba5">bug in the paper</a> by Shay Gueron upon which the RSAZ code is based.</p>



<p>This took my <a href="https://github.com/guidovranken/cryptofuzz">fuzzer</a> a long time to find, because the odds of finding <code>B ^ M % E = 0</code> for large, <code>N</code>-bit values of <code>B, E, M</code> where those values are semi-random are small, so I proceeded to add a <a href="https://github.com/guidovranken/cryptofuzz/blob/dd20f87e98ca92e9e31f8dd9d0a80efb5c249df7/expmod.cpp">modular exponentation solver,</a> so the bug can now be found quite quickly, and hopefully it helps finding more, similar bugs in the future (in OpenSSL or elsewhere). (Z3’s performance in solving equations involving modular exponentiation is quite poor so I had to roll my own).</p>



<p>The <a href="https://github.com/openssl/openssl/commit/10d8a109be0fe50315e4eeb0676f6571914cd47a#diff-854689acd04b8f1b65120880bebcd98d519e89b601328820f276ec0e5c164c4f">fix</a> that was applied to the dual 1024 RSAZ code is wrong because the <a href="https://github.com/openssl/openssl/blob/eea820f3e239a4c11d618741fd5d00a6bc877347/crypto/bn/rsaz_exp_x2.c#L260-L261">reduction function is called</a> with <code>num</code> set to the bit size, where it should be number of <code>BN_ULONG</code> elements (which are always 8 bytes large, because that is the size of an unsigned long on x64 systems, which is the only architecture which can have AVX512 support). So with the input sizes being 1024 bits, 8192 bytes are accessed (read from or written to) instead of 128.</p>



<p>On to the bug internals. There are 5 distinct arrays involved. 3 arrays are overwritten.</p>



<figure><table><tbody><tr><td><strong>Variable</strong></td><td><strong>Description</strong></td><td><strong>Allocated size</strong></td><td><strong>Over-read/write</strong></td><td><strong>Total</strong></td><td><strong>Read/write?</strong></td></tr><tr><td><code>res1</code></td><td>modexp result 1</td><td>128</td><td>896</td><td>8192</td><td>Read, then write</td></tr><tr><td><code>m1</code></td><td>Modulus 1</td><td>128</td><td>896</td><td>8192</td><td>Read</td></tr><tr><td><code>res2</code></td><td>modexp result 1</td><td>128</td><td>896</td><td>8192</td><td>Read, then write</td></tr><tr><td><code>m2</code></td><td>Modulus 2</td><td>128</td><td>896</td><td>8192</td><td>Read</td></tr><tr><td><code>storage</code></td><td>Scratch space</td><td>1184</td><td>7296</td><td>8192</td><td>Write, then read</td></tr></tbody></table></figure>



<ul><li>8192 bytes are read from <code>res1</code>, <code>res2</code>, <code>m1</code>, <code>m2</code> and <code>storage</code></li><li>8192 bytes are written to <code>res1</code>, <code>res2</code> and <code>storage</code> (this is where the memory corruption takes place)</li><li>If we consider <code>res1_bn</code> to be a bignum comprising <code>res1[0..8192]</code> (where the last byte is the most significant byte) and <code>m1_bn</code> to be <code>m1[0..8192]</code>, then if <code>res1_bn &lt; m1_bn</code>, the contents of <code>res1[0..8192]</code> will be left unchanged after being overwritten. The same applies for <code>res2</code> and <code>m2</code>.</li><li>This implies that if you can set the most significant bit of <code>m1[8191]</code> to <code>1</code> and the most significant bit of <code>res1[8191]</code> to <code>0</code>, then <code>res1[0..8192]</code> will retain its original state (and no actual corruption takes place). This circumstance may occur by chance. The same applies for <code>res2</code> and <code>m2</code>.</li><li>Conversely, if <code>res1_bn &gt;= m1_bn</code>, then after the write, <code>res1[N]</code> will be one of <code>{res1[N], res1[N] - m1[N], res1[N] - m1[N] - 1}</code>. The same applies for <code>res2</code> and <code>m2</code>.</li><li>After the overwrites have occurred, <code>storage[N]</code>will be <code>~(m2[N] - res2[N])</code> or <code>~(m2[N] - res2[N])+1</code>.</li><li>From this it follows that if you control <code>m2[N]</code>and <code>res2[N]</code>, you mostly control <code>storage[N]</code>.</li><li>The original contents of <code>storage</code> is never read, so it does not influence the end state in any way.</li></ul>



<p>Summarized:</p>



<figure><table><tbody><tr><td>Variable</td><td>Post-write value</td></tr><tr><td>res1[N]</td><td><code><span>res1[N]</span></code> <em>or</em> <code><span>res1[N] - m1[n]</span></code> <em>or</em> <code><span>res1[N] - m1[N] - 1</span></code></td></tr><tr><td>res2[N]</td><td><code><span>res2[N]</span></code> <em>or</em> <code><span>res2[N] - m2[n]</span></code> <em>or</em> <code><span>res2[N] - m2[N] - 1</span></code></td></tr><tr><td>storage[N]</td><td><code><span>~(m2[N] - res2[N])</span></code> <em>or</em> <code><span>~(m2[N] - res2[N]) + 1</span></code></td></tr></tbody></table><figcaption>OpenSSL vulnerability post-write states</figcaption></figure>



<p>Each of these lemma’s are true independent of what the inputs to the modexp function are, and of any other variable or state.</p>



<p><a href="https://gist.github.com/guidovranken/b1c46bd9e42e959519009681b261a896">Here is a fuzzer</a> which demonstrates these invariants.</p>



<p>The (wrapping) subtraction mechanics at play here are interesting because you can use them to apply pointer delta’s to a function pointer to make it point to a different function and this can help circumvent <a href="https://en.wikipedia.org/wiki/Address_space_layout_randomization">ASLR</a>, because while the function addresses are randomized, their spacing is constant for every given binary.</p>



<p>For example, if:</p>



<ul><li>a single, particular <code>BN_ULONG</code> in the <code>res1</code> array is known to contain an active pointer to a specific function</li><li>and you can control the <code>BN_ULONG</code> in <code>m1</code> at the same index (for example via heap spraying)</li><li>and the rest of the state is completely unknown and uncontrolled</li></ul>



<p>then by setting <code>m1[N]</code> to <code>oldfunc - newfunc</code>, the original function pointer will be exactly <code>newfunc</code> after the overflow with a 25% probability:</p>


<div><pre title="">void goodfunc(void) { printf(&#34;good\n&#34;); }
void badfunc(void) { printf(&#34;bad\n&#34;); }
int main(void)
{
    /* Indices 0..127 are within allocated bounds */
    /* Beyond that is either unallocated or allocated by different parts
     * of the program.
     */
    struct {
        BN_ULONG storage[1024], res1[1024], m1[1024], res2[1024], m2[1024];
    } vars;

    /* Randomize everything; not known to the attacker */
    FILE* fp = fopen(&#34;/dev/urandom&#34;, &#34;rb&#34;);
    assert(fread(&amp;vars, 1, sizeof(vars), fp));
    fclose(fp);

    /* Assume res1[345] contains a function pointer used internally by OpenSSL */
    vars.res1[345] = (BN_ULONG)(&amp;goodfunc);
    /* Assume we control m1[345] */
    vars.m1[345] = (BN_ULONG)(&amp;goodfunc) - (BN_ULONG)(&amp;badfunc);

    bn_reduce_once_in_place(vars.res1, /*carry=*/0, vars.m1, vars.storage, 1024);
    bn_reduce_once_in_place(vars.res2, /*carry=*/0, vars.m2, vars.storage, 1024);

    void (*fnptr)(void) = (void*)vars.res1[345];
    fnptr(); /* good or bad? */
    return 0;
}
</pre></div>


<p>OpenSSL makes heavy use of function pointers. Running <code>find -name &#39;<em>.c&#39; -exec grep &#39;METH.</em> = {&#39; {} \; | grep -v test</code> from the repository root shows over 130 data structures that encapsulate a set of function pointers. Delta subtraction may be useful in exploiting this circumstance to make OpenSSL misbehave to varying degrees of severity.</p>



<p>Apart from code execution, there can also be scenario’s where private data is leaked to the attacker.</p>



<p>Assume:</p>



<ul id="block-004af4dd-24b9-4720-b00a-3b5d3e7902c5"><li>R¹ = <code>res[I..J]</code></li><li>M¹ = <code>m[I..J]</code></li><li>I, K &gt;= 128</li><li>J, L &lt;= 1023</li></ul>



<p>Let R¹ be an allocated space which the attacker can read and write (for example an internal TLS state whose value is, to an extent, determined by how the attacker conducts the handshake, and which can be read, to an extent, by how the TLS code subsequently behaves based on its state).</p>



<p>Let M¹ contain some kind of secret information.</p>



<p>Recall that the combination of <code>res[N]</code> (before the overwrite) and <code>m[N]</code> leaks into <code>res[N]</code>. It follows that if the attacker has read-write access to <code>R¹</code>, M¹ can be partially or completely inferred.</p>



<p>This is what I’ve deduced so far. It’s possible there are errors in this post; please e-mail <a href="mailto:guido@guidovranken.com">guido@guidovranken.com</a> and I’ll correct them and credit you. You can <a href="https://twitter.com/GuidoVranken">follow me on Twitter</a>.</p>
			</div><!-- .entry-content -->

	<!-- .entry-footer -->
</article></div>
  </body>
</html>
