<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://webapp.io/blog/github-actions-10x-faster-with-firecracker/">Original</a>
    <h1>Run end-to-end tests faster with Firecracker</h1>
    
    <div id="readability-page-1" class="page"><div id="site-main">
<div>
<article>

<figure>
<img srcset="/blog/content/images/size/w300/2022/04/Benchmark-1--1.svg 300w,
                            /blog/content/images/size/w600/2022/04/Benchmark-1--1.svg 600w,
                            /blog/content/images/size/w1000/2022/04/Benchmark-1--1.svg 1000w,
                            /blog/content/images/size/w2000/2022/04/Benchmark-1--1.svg 2000w" sizes="(max-width: 800px) 400px,
                        (max-width: 1170px) 1170px,
                            2000px" src="https://webapp.io/blog/content/images/size/w2000/2022/04/Benchmark-1--1.svg" alt="How to run end-to-end tests 10x faster with firecracker"/>
</figure>
<section>
<div>
<h3 id="end-to-end-tests-and-ci">End-to-end tests and CI </h3><p>When you make changes to code in a repository, you usually want to make sure that you haven&#39;t broken core user flows like the sign up button.</p><p>To automatically check nothing is broken, people usually start a copy of their app within their CI pipeline and then run test browsers to click around. That way you can make sure your app still builds, starts, and mostly works after every new change.</p><p>For a typical full-stack webapp, these are the sorts of steps that run after every new change:</p><figure><img src="https://webapp.io/blog/content/images/2022/04/_using-firecracker_-illustration-1-1-.svg" alt="Explanation of CI pipeline: A build step where &#34;docker-compose build&#34; runs, then a step where &#34;docker-compose up&#34; runs, then a final step where browser tests run"/></figure><p>This pipeline works fine, but it&#39;s significantly more expensive and slow than it could be:</p><ul><li>Images have to be built from scratch, or constantly pushed/pulled from a registry somewhere</li><li>The database has to be re-migrated and re-seeded every time</li><li>It&#39;s hard to parallelize things, because the setup needs to re-run for every independent copy of the environment.</li></ul><h3 id="faster-and-cheaper-e2e-tests-using-base-images">Faster and cheaper e2e tests using base images</h3><p>Since the build steps, database, and deployment definitions rarely change between code changes, it&#39;d be nice if we could have a &#34;base image&#34; of a machine which already had everything started.</p><p>This base image would have:</p><ul><li>A migrated and seeded database already running</li><li>Build caches populated with files from an earlier build</li><li>Images and large files pre-downloaded </li><li>The repository itself pre-loaded</li></ul><p>If we had such a base image, we could pull in our new change and build/start things in seconds.</p><p>For a long time this was technically infeasible, but there&#39;s an exciting new technology that facilitates this exact use-case.</p><h3 id="firecracker">Firecracker</h3><p><a href="https://firecracker-microvm.github.io/">Firecracker</a> is the framework that powers <a href="https://aws.amazon.com/lambda/">AWS Lambda</a>. It allows you to make &#34;snapshots&#34; of a running VM, which contain the entire disk/memory of the vm. When you restore one, you also restore all of the VM&#39;s files and processes.</p><figure><img src="https://webapp.io/blog/content/images/2022/04/Frame-114-1-.svg" alt="Diagram of a VM turning into a file, then back into a VM"/><figcaption>Firecracker turns VMs into files and back into VMs.</figcaption></figure><p>We could create a script that created a firecracker VM &amp; set it up to be an ideal base image. Then we could copy the file that contained the VM&#39;s files and processes,</p><h3 id="getting-started-with-firecracker">Getting started with firecracker</h3><p>It&#39;s actually relatively simple to use firecracker because of their <a href="https://github.com/firecracker-microvm/firecracker/blob/main/docs/getting-started.md">quickstart guide</a> and <a href="https://jvns.ca/blog/2021/01/23/firecracker--start-a-vm-in-less-than-a-second/">other amazing resources</a>. </p><p>Using firecracker on Linux can be as simple as a few commands:</p><pre><code># Step 1. download firecracker
curl -fSsL https://github.com/firecracker-microvm/firecracker/releases/download/v1.0.0/firecracker-v1.0.0-x86_64.tgz | tar -xz
mv firecracker-* firecracker

# Step 2. Download files required to start the VM
image_bucket_url=&#34;https://s3.amazonaws.com/spec.ccfc.min/img/quickstart_guide/$arch&#34;
wget &#34;${image_bucket_url}/kernels/vmlinux.bin&#34;
wget &#34;${image_bucket_url}/rootfs/bionic.rootfs.ext4&#34;

# Step 3. Create a config file
cat &lt;&lt;EOF &gt; vmconfig.json
{
  &#34;boot-source&#34;: {
    &#34;kernel_image_path&#34;: &#34;vmlinux.bin&#34;,
    &#34;boot_args&#34;: &#34;console=ttyS0 reboot=k panic=1 pci=off&#34;
  },
  &#34;drives&#34;: [
    {
      &#34;drive_id&#34;: &#34;rootfs&#34;,
      &#34;path_on_host&#34;: &#34;bionic.rootfs.ext4&#34;,
      &#34;is_root_device&#34;: true,
      &#34;is_read_only&#34;: false
    }
  ]
}
EOF

# Step 4. Start the VM
./firecracker --unix-socket /tmp/firecracker.socket --config-file vmconfig.json
</code></pre><h3 id="great-we-have-a-vm-now-what">Great, we have a VM, now what?</h3><p>We wanted to use firecracker to create a &#34;zygote snapshot&#34; which contained all of our dependencies. If you&#39;re following along, use <a href="https://jvns.ca/blog/2021/01/23/firecracker--start-a-vm-in-less-than-a-second/">Julia Evans&#39; tutorial</a> to set up networking, and you should be able to ssh directly into your VM!</p><p>From there, run your setup commands as necessary:</p><figure><pre><code>$ apt-get install docker postgresql
$ docker pull ubuntu:18.04
$ wget http://example.com/my-large-file.txt ~/my-large-file.txt</code></pre><figcaption>Some example commands that set up a VM with the dependencies for running brower tests</figcaption></figure><p>Finally, exit the VM and take a snapshot! (see <a href="https://github.com/firecracker-microvm/firecracker/blob/main/docs/snapshotting/snapshot-support.md">Firecracker docs</a>)</p><pre><code>curl --unix-socket /tmp/firecracker.socket -i \
    -X PATCH &#39;http://localhost/vm&#39;
    -H  &#39;Accept: application/json&#39; \
    -H  &#39;Content-Type: application/json&#39; \
    -d &#39;{&#34;state&#34;: &#34;Paused&#34;}&#39;

curl --unix-socket /tmp/firecracker.socket -i \
    -X PUT &#39;http://localhost/snapshot/create&#39; \
    -H  &#39;Accept: application/json&#39; \
    -H  &#39;Content-Type: application/json&#39; \
    -d &#39;{
            &#34;snapshot_type&#34;: &#34;Full&#34;,
            &#34;snapshot_path&#34;: &#34;./snapshot_file&#34;,
            &#34;mem_file_path&#34;: &#34;./mem_file&#34;,
            &#34;version&#34;: &#34;0.23.0&#34;
    }&#39;</code></pre><h3 id="how-it-all-fits-together">How it all fits together</h3><p>Now that we have our disk and memory snapshot files, we can just run a simple script to prepare the VM to run our CI pipeline:</p><ol><li><strong>Copy the zygote files:</strong> Â bionic.rootfs.ext4, snapshot_file, and mem_file to another directory</li><li><strong>Restore the snapshot</strong> files using the firecracker API</li><li><strong>Run the build</strong> for your pipeline within the restored VM</li></ol><figure><img src="https://webapp.io/blog/content/images/2022/04/Frame-115-1-.svg" alt=""/></figure><h2 id="benchmark">Benchmark</h2><p>Enough about theory, let&#39;s look at a benchmark!</p><p>This benchmark uses <a href="https://github.com/webappio/livechat-example">an open source Slack clone</a>, which uses Docker Compose, Go, PostgreSQL, and React.</p><h3 id="firecracker-based-ci-is-10-5x-faster">Firecracker-based CI is 10.5x faster</h3><figure><img src="https://webapp.io/blog/content/images/2022/04/Benchmark-1-.svg" alt=""/><figcaption>build / start / test for a full-stack webapp</figcaption></figure><p>This benchmark shows a drastic 10x speedup due to having a warm cache. The firecracker VM came up almost instantly, and ran the build steps in just a few seconds due to the reused caches. This meant that the whole pipeline could run in only 30s.</p><p>In comparison, the &#34;traditional CI&#34; VMs took over a minute just to boot and clone the code, and then had to re-build the images from scratch, before ever being able to run the tests.</p><p>See these links for methodology:</p><ul><li><a href="https://github.com/webappio/livechat-example/runs/6052020001?check_suite_focus=true">GitHub actions build</a></li><li><a href="https://webapp.io/layer-devops-world/livechat-example/48/main-layerfile-3">Firecracker build</a> (notice the &#34;skipped&#34; steps)</li><li><a href="https://github.com/webappio/livechat-example/pull/24/commits/be7c9121c1507a8d1627eac1dd5135597bf09055">Commit which triggered the builds</a></li></ul><h2 id="want-to-try-firecracker-based-ci-yourself">Want to try firecracker-based CI yourself?</h2><p><a href="https://webapp.io">Webapp.io</a> offers firecracker-based VMs for CI even on our free plan. If you&#39;d like to try out the approach mentioned in this post without setting it up yourself, you can create a webapp.io account and try a sample in just a few minutes at <a href="https://webapp.io">https://webapp.io</a>.</p><p>Discussions:</p><ul><li><a href="https://news.ycombinator.com/item?id=31062301">Hacker news</a></li><li><a href="https://www.reddit.com/r/programming/comments/u5r3ed/run_e2e_tests_10x_faster_using_firecracker_vms/">Reddit</a></li></ul>
</div>
</section>
<section>

</section>
</article>
</div>
</div></div>
  </body>
</html>
