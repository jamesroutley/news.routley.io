<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.startifact.com/posts/humble-for-loop-rust/">Original</a>
    <h1>The humble for loop in Rust</h1>
    
    <div id="readability-page-1" class="page"><section>
            
            
            <p>Rust has some really nice functional programming facilities built in, all
around an iterator concept. Rust being focused on performance and low level
control makes it possible to use this without paying a performance cost.
Sometimes I still prefer to use the humble <code>for</code> loop though. In quite a few
cases, it combines high performance with high readability. I thought I&#39;d
motivate why.</p>
<span id="continue-reading"></span>
<p>I&#39;ve written previously (um, well, <em>today</em>) about <a href="https://blog.startifact.com/posts/humble-for-loop-js/">the humble <code>for</code> loop in
JavaScript</a>, and I think
heuristics involved carry across languages that have collection data structures
like vectors and hashmaps (JavaScript arrays, object/HashMap, Python lists and
dictionaries). Let&#39;s see how this works out in Rust. But even if you&#39;re not an
expert in Rust you should be able to follow most of it, as I explain Rust
concepts along the way.</p>
<p>This being about Rust, I&#39;m going to give some performance numbers in this
article. The precise details of these numbers don&#39;t really matter. They will be
different depending on what data you&#39;re working with. For the purposes of this
article, whenever there&#39;s merely a percentage difference in performance, that&#39;s
relatively unimportant. Where it gets interesting is when I start to talk about
3, 10, or a 100 times faster, as these demonstrate real algorithmic differences
that hold up in many contexts, and therefore can help guide our behavior.</p>
<h3 id="map"><a href="#map" aria-label="Anchor link for: map"><span aria-hidden="true"></span></a>
Map</h3>
<p>Let&#39;s consider a transform loop first.</p>
<pre data-lang="rust"><code data-lang="rust"><span>let mut</span><span> result </span><span>= </span><span>Vec</span><span>::new();
</span><span>for</span><span> entry </span><span>in</span><span> list {
</span><span>    result.</span><span>push</span><span>(</span><span>transform</span><span>(entry));
</span><span>}
</span></code></pre>
<p>It&#39;s almost identical to examples you&#39;d see in JavaScript or Python. <code>Vec</code> is
an expandable array in Rust, like a JavaScript array or Python list.</p>
<p>The simple loop has good performance, but this is actually faster, by about 30%
for a bunch of i32 numbers :</p>
<pre data-lang="rust"><code data-lang="rust"><span>let mut</span><span> result </span><span>= </span><span>Vec</span><span>::with_capacity(list.</span><span>len</span><span>());
</span><span>for</span><span> entry </span><span>in</span><span> list {
</span><span>    result.</span><span>push</span><span>(</span><span>transform</span><span>(entry));
</span><span>}
</span></code></pre>
<p>The way <code>Vec</code> works (just like in Python and JS) is that it preallocates space
in advance, so that every <code>push</code> does not require a memory reallocation (which
requires copying the data, which is expensive). But since it doesn&#39;t know how
big the final array will be, it may not be able to avoid reallocation entirely.</p>
<p>Here we avoid reallocations altogether by giving it the final amount right away
using <code>with_capacity()</code>; we know it&#39;s going to be identical in length to the
input list.</p>
<p>Now let&#39;s look at <code>map()</code>.</p>
<pre data-lang="rust"><code data-lang="rust"><span>let</span><span> result: </span><span>Vec</span><span>&lt;</span><span>i32</span><span>&gt; </span><span>=</span><span> list.</span><span>into_iter</span><span>().</span><span>map</span><span>(transform).</span><span>collect</span><span>()
</span></code></pre>
<p>A few explanations are in order:</p>
<ul>
<li>
<p><code>into_iter()</code> turns the original vector into an iterator. The <code>for</code> loop uses
<code>into_iter()</code> too, but implicitly.</p>
</li>
<li>
<p><code>map()</code> does not return a vector, unlike in Javascript where it produces an
array. Instead it returns an iterator (that has the mapping operation
built-in). Calling <code>map()</code> does not actually take much time at all as it&#39;s
constructing an iterator, not executing it.</p>
</li>
<li>
<p><code>collect()</code> takes an iterator and turns it back into a vector. This is going
to do the actual work.</p>
</li>
</ul>
<p>I think we can agree that <code>map()</code> in Rust is pretty readable. While there are a
few more concepts invovled that you don&#39;t need to understand when you use a
<code>for</code> loop, these concepts are so fundamental to Rust you&#39;re going to have to
learn them anyway. So <code>.map()</code> wins in being more declarative.</p>
<p>Surprisingly enough, <code>map()</code> can also be a lot faster. On a loop of 10000
integers it&#39;s 6 times faster on my machine!</p>
<p>Why is <code>map</code> so much faster? I am not sure. I suspect with the <code>map()</code> option
the Rust compiler figures out it can avoid allocations altogether by simply
writing over the original vector, while with the loop it can&#39;t. Or maybe it&#39;s
using SIMD? I tried to look in the <a href="https://godbolt.org/z/fKEPaTdTv">compiler
explorer</a> but I&#39;m not competent enough yet to
figure it out. Maybe someone else can explain! </p>
<p>This is a great argument to use functional programming patterns when they&#39;re
simple! More declarative <em>and</em> more fast? Let&#39;s use it!</p>
<h3 id="fold-reduce"><a href="#fold-reduce" aria-label="Anchor link for: fold-reduce"><span aria-hidden="true"></span></a>
Fold (Reduce)</h3>
<p>In JavaScript we saw that a <code>for</code> loop for constructing a new collection was
orders of magnitude faster than using <code>reduce</code>, but does the same apply to
Rust? After all, <code>map()</code> is so good! Does this mean that with Rust we should
use <code>fold</code> (which is the equivalent of <code>reduce</code> in Rust) rather than a <code>for</code>
loop too?</p>
<p>Let&#39;s look at implementing flatten, the example I also used in my JavaScript
post. Here&#39;s the simple <code>for</code> loop:</p>
<pre data-lang="rust"><code data-lang="rust"><span>let mut</span><span> flat </span><span>= </span><span>Vec</span><span>::new();
</span><span>for</span><span> entry </span><span>in</span><span> list_of_lists {
</span><span>    flat.</span><span>extend</span><span>(entry);
</span><span>}
</span></code></pre>
<p><code>extend()</code> a way to push a whole lot of items at once, like you have in Python.
</p>
<p>Note that we can&#39;t really do much with preallocated capacity here as we don&#39;t
know the total length of the flattened list in advance, so we don&#39;t bother.</p>
<p>Here&#39;s the <code>fold</code> version closest to the one we used in JavaScript:</p>
<pre data-lang="rust"><code data-lang="rust"><span>let</span><span> flat </span><span>=</span><span> list_of_lists.</span><span>into_iter</span><span>().</span><span>fold</span><span>(</span><span>Vec</span><span>::new(), 
</span><span>  |</span><span>accumulator</span><span>, </span><span>list</span><span>| [accumulator, list].</span><span>concat</span><span>()
</span><span>);
</span></code></pre>
<p>Let&#39;s pick this one apart:</p>
<ul>
<li>
<p>We use <code>fold()</code>. Rust does have a <code>reduce()</code> but <code>fold</code> is the closest
equivalent to JavaScript <code>reduce</code>. It doesn&#39;t matter in performance.</p>
</li>
<li>
<p><code>|accumulator, list| ...</code> is a closure, a function we pass in much like we do
in JS.</p>
</li>
<li>
<p><code>[accumulator, list].concat()</code> is a way to add two vectors together to create
a new vector.</p>
</li>
</ul>
<p>The simple <code>for</code> loop is about 180 times faster for this approach (for a list
of 50,000 items after flattening).</p>
<p>If you&#39;re a Rust developer, you might object. This approach is terrible! It
allocates memory all over the place, no wonder it&#39;s slower.</p>
<p>But in Rust we can avoid instantiating vectors all over place as we have
iterators. Let&#39;s try this on the iterator level:</p>
<pre data-lang="rust"><code data-lang="rust"><span>let</span><span> flat </span><span>=</span><span> list_of_lists.</span><span>into_iter</span><span>().</span><span>fold</span><span>(</span><span>Vec</span><span>::new(), |</span><span>accumulator</span><span>, </span><span>list</span><span>| {
</span><span>    accumulator.</span><span>into_iter</span><span>().</span><span>chain</span><span>(list).</span><span>collect</span><span>()
</span><span>});
</span></code></pre>
<p>What&#39;s going on here? We use <code>.chain()</code> to combine the <code>accumulator</code> iterator
with the <code>list</code> iterator, and then we collect it.</p>
<p>Does this help? Not really -- it&#39;s faster than the <code>concat</code> version by only 20%
or so; not even close to the <code>for</code> loop.</p>
<p>Whoah, wait. We&#39;re still actually constructing vectors all over the place here,
as we collect inside the closure!</p>
<p>Can we avoid this and just create iterators and finally collect them in the end?</p>
<pre data-lang="rust"><code data-lang="rust"><span>let</span><span> iter: </span><span>Box</span><span>&lt;dyn </span><span>Iterator</span><span>&lt;Item = </span><span>i32</span><span>&gt;&gt; </span><span>= </span><span>Box</span><span>::new(std::iter::empty());
</span><span>let</span><span> flat </span><span>=</span><span> list_of_lists.</span><span>into_iter</span><span>()
</span><span>    .</span><span>fold</span><span>(iter, |</span><span>accumulator</span><span>, </span><span>list</span><span>| </span><span>Box</span><span>::new(accumulator.</span><span>chain</span><span>(list)))
</span><span>    .</span><span>collect</span><span>()
</span></code></pre>
<p>Yes we can, but we can already see this is a lot harder to read, and it
actually makes it more than 10 times slower! I&#39;m not entirely sure why -
apparently the overhead of constructing chained iterators and heap allocation
kills performance.</p>
<p>If you&#39;re new to Rust, sorry. The <code>Box&lt;dyn Iterator&lt;Item = i32&gt;&gt;</code> stuff is to
tell Rust to use dynamic dispatch so I can combine the empty iterator we start
with iterators based on the <code>chain</code>. These have different types in Rust and
this is the way to make them go together.</p>
<p>Is there then no declarative way in Rust to express this and still have
performance? I mean, besides <code>.flatten()</code> which Rust has as well? We can use
<code>flat_map</code>:</p>
<pre data-lang="rust"><code data-lang="rust"><span>let</span><span> flat </span><span>=</span><span> list_of_lists.</span><span>into_iter</span><span>().</span><span>flat_map</span><span>(|</span><span>list</span><span>| list).</span><span>collect</span><span>()
</span></code></pre>
<p><code>flat_map</code> lets you map but also produce structure, which then immediately gets
flattened. This is a lot faster than our <code>concat</code> approach, but still 4 times
slower than the <code>for</code> loop. </p>
<p>So the pattern holds: the humble <code>for</code> loop, even in Rust, is worth your
consideration. Use <code>fold()</code> if it makes your code easier to write, not because
it&#39;s necessarily faster.</p>
<h3 id="errors-and-map"><a href="#errors-and-map" aria-label="Anchor link for: errors-and-map"><span aria-hidden="true"></span></a>
Errors and map</h3>
<p>It&#39;s common in code for an operation to fail and we want to handle such
failures. Instead of using exceptions like many programming languages, Rust has
a very nice system for propagating error values just like you propagate any
return value. I won&#39;t go into the details here, but hopefully you can follow
along.</p>
<p>Let&#39;s consider <code>map()</code> again, but with errors.</p>
<pre data-lang="rust"><code data-lang="rust"><span>struct </span><span>Error</span><span>;
</span><span>
</span><span>fn </span><span>transform</span><span>(</span><span>entry</span><span>: Entry) -&gt; </span><span>Result</span><span>&lt;Transformed, Error&gt; {
</span><span>    </span><span>// do stuff to create a Transformed from Entry. It might fail
</span><span>}
</span><span>
</span><span>fn </span><span>transform_list</span><span>(</span><span>list</span><span>: </span><span>Vec</span><span>&lt;Entry&gt;) -&gt; </span><span>Result</span><span>&lt;</span><span>Vec</span><span>&lt;Transformed&gt;, Error&gt; {
</span><span>    </span><span>let mut</span><span> result </span><span>= </span><span>Vec</span><span>::with_capacity(list.</span><span>len</span><span>());
</span><span>    </span><span>for</span><span> entry </span><span>in</span><span> list {
</span><span>        result.</span><span>push</span><span>(</span><span>transform</span><span>(entry)</span><span>?</span><span>);
</span><span>    }
</span><span>    result
</span><span>}
</span></code></pre>
<p>We can see that the <code>transform</code> function returns a <code>Result</code>, which is either a
<code>Transformed</code> object (success!) or or an error (some object describing the
error).</p>
<p>Since transform is fallible, <code>transform_list</code> is also fallible and thus needs
to return <code>Result</code> too. We either get a list that was successfully transformed,
or an error.</p>
<p>As soon as we have an error, we want to bail out with it. That&#39;s what the <code>?</code>
operator after <code>transform(entry)?</code> does; it is equivalent to an if statement
that checks whether the value evaluated is an error, and if so, it immediately
returns from the function using the error value.</p>
<p>What does this look like with <code>map()</code>?</p>
<pre data-lang="rust"><code data-lang="rust"><span>fn </span><span>transform_list</span><span>(</span><span>list</span><span>: </span><span>Vec</span><span>&lt;Entry&gt;) -&gt; </span><span>Result</span><span>&lt;</span><span>Vec</span><span>&lt;Transformed&gt;, Error&gt; {
</span><span>    list.</span><span>into_iter</span><span>().</span><span>map</span><span>(transform).</span><span>collect</span><span>()
</span><span>}
</span></code></pre>
<p>This is functionally equivalent to the above, believe it or not. First we turn
the list into an iterator, so we can iterate through all the values in it. Then
we use the <code>functional</code> map with the <code>transform</code> function. Then we collect it
back into a vector. You&#39;d expect that to be <code>Vec&lt;Result&lt;Transformed&gt;, Error&gt;</code>;
a list of results - either values or error objects.</p>
<p>But since we have declared the return value of the function to be
<code>Result&lt;Vec&lt;Transformed&gt;, Error&gt;</code> a <em>different</em> <code>collect</code> is selected that
short-circuits and bails out with an error as soon as the first one is found,
just like in the <code>for</code> loop.</p>
<p>And what about <code>with_capacity</code>? We don&#39;t need it, because the implementation is
smart enough to ask the iterator whether it has a size hint for that, and since
it&#39;s based on a vector with a known length, it has one.</p>
<p>So we get a lot of cleverness for free.</p>
<h2 id="more-complex-error-handling"><a href="#more-complex-error-handling" aria-label="Anchor link for: more-complex-error-handling"><span aria-hidden="true"></span></a>
More complex error handling</h2>
<p>Again we learn that <code>map()</code> is great! Use <code>map()</code>! Sometimes however the <code>for</code>
loop makes error handling a lot more convenient. Some things are just difficult
to capture in a pattern that&#39;s both efficient and declarative. Let&#39;s consider a
fallible flatten.</p>
<pre data-lang="rust"><code data-lang="rust"><span>pub fn </span><span>fallible_flatten</span><span>(</span><span>list_of_lists</span><span>: </span><span>Vec</span><span>&lt;</span><span>Vec</span><span>&lt;</span><span>Result</span><span>&lt;</span><span>i32</span><span>, Error&gt;&gt;&gt;) -&gt; </span><span>Result</span><span>&lt;</span><span>Vec</span><span>&lt;</span><span>i32</span><span>&gt;, Error&gt; {
</span><span>    </span><span>let mut</span><span> flat </span><span>= </span><span>Vec</span><span>::new();
</span><span>    </span><span>for</span><span> entry </span><span>in</span><span> list_of_lists {
</span><span>        </span><span>for</span><span> j </span><span>in</span><span> entry {
</span><span>            flat.</span><span>push</span><span>(j</span><span>?</span><span>);
</span><span>        }
</span><span>    }
</span><span>    </span><span>Ok</span><span>(flat)
</span><span>}
</span></code></pre>
<p>We&#39;re flattening a list of lists, but each entry in the list may be an error.
If we encounter such an error during flattening, we want to bail out
immediately. We can&#39;t use <code>extend</code> here but it&#39;s pretty straightforward
otherwise. </p>
<p>How about writing this with <code>fold</code>? If we do, the brilliant Rust clippy
immediately suggest we use <code>try_fold</code> which is designed for error handling.</p>
<pre data-lang="rust"><code data-lang="rust"><span>pub fn </span><span>fallible_flatten_fold</span><span>(
</span><span>    </span><span>list_of_lists</span><span>: </span><span>Vec</span><span>&lt;</span><span>Vec</span><span>&lt;</span><span>Result</span><span>&lt;</span><span>i32</span><span>, Error&gt;&gt;&gt;,
</span><span>) -&gt; </span><span>Result</span><span>&lt;</span><span>Vec</span><span>&lt;</span><span>i32</span><span>&gt;, Error&gt; {
</span><span>    list_of_lists
</span><span>        .</span><span>into_iter</span><span>()
</span><span>        .</span><span>try_fold</span><span>(</span><span>Vec</span><span>::new(), |</span><span>accumulator</span><span>, </span><span>entry</span><span>| {
</span><span>            </span><span>let mut</span><span> result </span><span>=</span><span> accumulator.</span><span>clone</span><span>();
</span><span>            </span><span>for</span><span> j </span><span>in</span><span> entry {
</span><span>                result.</span><span>push</span><span>(j</span><span>?</span><span>);
</span><span>            }
</span><span>            </span><span>Ok</span><span>(result)
</span><span>        })
</span><span>}
</span></code></pre>
<p>If we ignore the performance difference which is inherent to folding over a
collection like this, I&#39;d still argue the <code>for</code> loop is easier to read and
write in this scenario.</p>
<h2 id="conclusion"><a href="#conclusion" aria-label="Anchor link for: conclusion"><span aria-hidden="true"></span></a>
Conclusion</h2>
<p>It&#39;s hard to go wrong with <code>map()</code> if what you&#39;re doing is transforming a
collection.</p>
<p>But <code>fold</code> is a lot more tricky. Does that mean <code>fold</code> is useless? Not at all.
I use <code>fold</code> in complex scenarios building up structures where a declarative
route really pays off. Sometimes going up a level of abstraction allows you to
do algorithmic improvements that blow even the performance of the <code>for</code> loop
completely out of the water. But the humble <code>for</code> loop still has a lot of
things going for it.</p>
<p><code>for</code> loops have <code>break</code>. You can <code>return</code> from the middle of a <code>for</code> loop too.
Complex error handling is expressed with a little <code>?</code>.</p>
<p>To avoid <code>for</code> I could scratch my head a lot and go through a bigger catalog of
concepts, and stretch my mathematical reasoning abilities. While there is
definitely a time and place for that, in many cases the trade-offs for both the
writer and reader of the code are in favor of the humble <code>for</code> loop, in Rust,
as well. Let that inform the heuristics we use as programmers.</p>

<p>I&#39;ve used simple <code>i32</code> integers for all experiments, and your performance
<em>will</em> be different with different data types. Your results will vary depending
on what you&#39;re looping through and what you&#39;re producing. Simple integers are
the simplest for machines to handle.</p>

<p>When transforming a <code>i32</code> to an <code>f64</code> <code>.map()</code> is still a lot faster. When
turning <code>i32</code> into <code>String</code> the performance difference goes away.</p>

<p>Incidentally using <code>extend</code> was almost double the speed on my benchmark
compared to an inner loop where stuff is manually pushed in an inner loop.</p>
<pre data-lang="rust"><code data-lang="rust"><span>let mut</span><span> flat </span><span>= </span><span>Vec</span><span>::new();
</span><span>for</span><span> entry </span><span>in</span><span> list_of_lists {
</span><span>    </span><span>for</span><span> j </span><span>in</span><span> entry {
</span><span>        flat.</span><span>push</span><span>(j);
</span><span>    }
</span><span>}
</span></code></pre>
<p>Still super fast compared to the alternatives, but slower.</p>

<p>When you try <code>flat_map(|list| list)</code> the Rust linter (Clippy) springs into action
suggesting you use <code>flatten()</code> instead. Bizarrely enough the <code>flat_map</code>
approach on this simple benchmark is actually 30% <em>faster</em>.</p>

<p>Here&#39;s a way to use <code>extend</code>:</p>
<pre data-lang="rust"><code data-lang="rust"><span>let</span><span> e </span><span>=</span><span> entry.</span><span>into_iter</span><span>().collect::&lt;</span><span>Result</span><span>&lt;</span><span>Vec</span><span>&lt;</span><span>_</span><span>&gt;, </span><span>_</span><span>&gt;&gt;()</span><span>?</span><span>;
</span><span>result.</span><span>extend</span><span>(e);
</span></code></pre>
<p>I suspect it&#39;s not faster as we have to instantiate the vector with <code>collect()</code>
in order to filter out errors, but I haven&#39;t measured it.</p>

        </section></div>
  </body>
</html>
