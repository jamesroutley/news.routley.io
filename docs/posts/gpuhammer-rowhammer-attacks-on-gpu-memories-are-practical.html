<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://gpuhammer.com/">Original</a>
    <h1>GPUHammer: Rowhammer attacks on GPU memories are practical</h1>
    
    <div id="readability-page-1" class="page"><article>
  
  <section><p>
  <img src="https://gpuhammer.com/gpuhammer_icon.png" alt="gpuhammer icon" width="20%"/>
</p>

<h2>GPUHammer: Rowhammer Attacks on GPU Memories are Practical 
    
    
    <span>
        <a href="#gpuhammer-rowhammer-attacks-on-gpu-memories-are-practical" aria-label="Anchor">#</a>
    </span>        
    
</h2>
<p><strong>Chris (Shaopeng) Lin<sup>‚Ä†</sup>, Joyce Qu<sup>‚Ä†</sup>, Gururaj Saileshwar, <em>from University of Toronto</em></strong></p>
<p>Published at <em>USENIX Security 2025</em> (link to <a href="https://gururaj-s.github.io/assets/pdf/SEC25_GPUHammer.pdf" target="_blank">paper</a>). Artifact available on <a href="https://github.com/sith-lab/gpuhammer" target="_blank">GitHub</a> and <a href="https://zenodo.org/records/15694512" target="_blank">Zenodo</a>.
<sup>‚Ä†</sup> equal contribution</p>
<hr/>
<!--
**TL;DR:** GPUHammer demonstrates, for the first time, that **Rowhammer attacks are practical on GDDR6 memories in NVIDIA GPUs**. Rowhammer is a hardware vulnerability where rapidly activating a memory row rapidly introduces bit flips in adjacent memory row. While this phenomenon is well known on CPU DRAM, such as DDR3 and DDR4 memories, our work discovers that **NVIDIA A6000 GPUs** are also vulnerable to the Rowhammer effects. Our findings reveal that bit-flips can be injected on a [48‚ÄØGB server-grade NVIDIA A6000 GPU](https://www.nvidia.com/en-us/products/workstations/rtx-a6000/) using carefully crafted hammering patterns that defeat in-DRAM mitigations such as Target Row Refresh (TRR). In our A6000 GPU, we discover 8 vulnerable locations incurring bit flips across 4 DRAM banks tested, including atleast one bit flip in every DRAM bank we tested. These bit flips can be introduced by a malicious user running CUDA code on the GPU to hammer the memory, and thus tamper with data of another user using the same GPU in a time-sliced manner. We demonstrate that such bit flips can be exploited to launch accuracy degradation attacks on popular machine learning models used for image recognition.Using just a single bit flip, we show that the accuracy of popular CNN models can reduce from 80% to just 0.1%. Enabling Error Correction Codes (ECC) on your A6000 GPU can eliminate the risk of such attacks. However, as per our analysis, ECC can introduce up to 10% slowdown for MLPerf inference workloads on an A6000 GPU.
-->

<h2>TL;DR 
    
    
    <span>
        <a href="#tldr" aria-label="Anchor">#</a>
    </span>        
    
</h2>
<p><a href="https://gururaj-s.github.io/assets/pdf/SEC25_GPUHammer.pdf" target="_blank">GPUHammer</a> is the first attack to show <strong>Rowhammer bit flips on GPU memories</strong>, specifically on a <strong>GDDR6 memory in an NVIDIA A6000 GPU</strong>. Our attacks <strong>induce bit flips across all tested DRAM banks</strong>, despite in-DRAM defenses like TRR, using user-level CUDA code. These bit flips allow a malicious GPU user to <strong>tamper with another user‚Äôs data on the GPU</strong> in shared, time-sliced environments. In a proof-of-concept, we use these bit flips to tamper with a victim‚Äôs DNN models and <strong>degrade model accuracy from 80% to 0.1%, using a single bit flip</strong>. Enabling Error Correction Codes (ECC) can mitigate this risk, but ECC can introduce up to a 10% slowdown for ML inference workloads on an A6000 GPU.</p>
<!--
## What's new for Rowhammering GPUs?
-->

<h2>üîç What‚Äôs New in Rowhammer for GPUs? 
    
    
    <span>
        <a href="#-whats-new-in-rowhammer-for-gpus" aria-label="Anchor">#</a>
    </span>        
    
</h2>
<p><a href="https://users.ece.cmu.edu/~yoonguk/papers/kim-isca14.pdf" target="_blank">Rowhammer</a> is a hardware vulnerability where rapidly activating a memory row introduces bit flips in adjacent memory rows.
Since 2014, this vulnerability has been widely studied in CPUs and in CPU-based memories like DDR3, DDR4, and LPDDR4.
However, with critical AI and ML workloads now running on discrete GPUs in the cloud, it is vital to assess the vulnerability of GPU memories to Rowhammer attacks.</p>
<p>Rowhammer is uniquely more challenging on GPU-based GDDR memories for the following reasons:</p>
<ul>
<li>‚è±Ô∏è  GDDR6 has higher latency and faster refresh than CPU-based DDR4, making hammering harder.</li>
<li>üß© Unknown DRAM address mappings in GDDR memories complicate crafting effective patterns.</li>
<li>üõ°Ô∏è  In-DRAM mitigations in GDDR are opaque and undocumented.</li>
</ul>
<p>Despite this, GPUHammer overcomes these barriers and launches successful attacks on GDDR6.</p>
<!--
(1) The higher memory latency (up to 4x higher than CPUs) and faster refresh rates (32ms or less) compared to CPUs (32ms - 64ms), limits the hammering intensity for Rowhammer attacks.
(2) The unknown mappings of addresses to DRAM banks within the GDDR memory makes crafting effective hammering patterns.
(3) Finally, the in-DRAM defenses against Rowhammer in GDDR memories are also unknown.

GPUHammer successfully develops attack primitives that overcome these challenges to demonstrate the vulnerability of GPU-based GDDR6 memories to Rowhammer attacks, as described next.
-->

<h3>Step 1: Reverse Engineering GPU DRAM Mappings 
    
    
    <span>
        <a href="#step-1-reverse-engineering-gpu-dram-mappings" aria-label="Anchor">#</a>
    </span>        
    
</h3>
<p>To craft effective Rowhammer attacks, we first need to identify memory addresses that map to the same DRAM bank on an NVIDIA GPU. Unlike CPUs, NVIDIA GPUs do not expose the physical addresses to user-level CUDA code, making it challenging to identify and hammer DRAM rows in the same bank. However, observing that the NVIDIA GPU driver consistently maps virtual memory to the same physical memory, we reverse engineer the virtual memory offsets to DRAM bank mappings. Inspired by the <a href="https://www.usenix.org/system/files/conference/usenixsecurity16/sec16_paper_pessl.pdf" target="_blank">DRAMA</a> technique, we use timing differences between memory accesses to the same bank vs. different banks.</p>
<p>One key obstacle, as shown in <strong>Fig. 1</strong>, is the <strong>Non-Uniform Memory Access (NUMA)</strong> effect in memory access latencies for addresses accessed in pairs, which makes it hard to pinpoint same-bank addresses. Based on the insight that addresses in the same DRAM bank must have similar latency when accessed  in isolation, we filter out such addresses contributing to the NUMA effects and clearly identify addresses mapping to the same DRAM bank (see <strong>Fig. 2</strong>). This accurately identifies same-bank address pairs needed for crafting Rowhammer patterns.</p>
<!-- One key obstacle, as shown in **Fig. 1**, is the **Non-Uniform Memory Access (NUMA)** effect, where memory addresses have varying access delays based on distance from the GPU. This cause some addresses to take significantly longer to access than the others (> 50ns), prevents us from clearly identifying SBDR addresses with row-buffer conflicts. By employing a filtering heuristic, that addresses located in the same DRAM bank must have similar access latency when accessed alone, we eliminate the NUMA effects and clearly identify addresses mapping to the same DRAM bank (see **Fig. 2**). With this technique, we now have addresses mapping to the same DRAM bank that we can now use for crafting hammering patterns.
-->
<table>
  <thead>
      <tr>
          <th><p><strong>Fig. 1:</strong>  Naively accessing pairs of addresses: different-bank latencies (320-370ns) overlap with same-bank latencies (370-380ns) due to NUMA effects.</p></th>
          <th><p><strong>Fig 2:</strong> After filtering addresses with different latencies when accessed in isolation, same and different bank address pairs are distinguishable.  </p></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><img src="https://gpuhammer.com/fig1.png" alt="fig1"/></td>
          <td><img src="https://gpuhammer.com/fig2.png" alt="fig2"/></td>
      </tr>
  </tbody>
</table>

<h3>Step-2: Maximizing Hammering Intensity 
    
    
    <span>
        <a href="#step-2-maximizing-hammering-intensity" aria-label="Anchor">#</a>
    </span>        
    
</h3>
<p>GPU memory accesses are up to <a href="https://chipsandcheese.com/p/measuring-gpu-memory-latency" target="_blank">4√ó slower</a> slower than CPUs, making it hard to reach the activation rate needed for Rowhammer attacks using naive, <strong>single-threaded</strong> hammering like in CPUs (<strong>Fig. 3</strong>, green line). To overcome this, we exploit the GPU‚Äôs <a href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/#simt-architecture" target="_blank">SIMT parallelism</a>, launching multiple threads and warps in parallel. This <strong>multi-threaded, multi-warp approach</strong> (<strong>Fig. 3</strong>, orange line) eliminates idle time in the memory controller and reaches the maximum possible hammering rate. <strong>Fig. 4</strong> shows how these strategies maximize memory controller utilization.</p>
<!--
GPUs memory access latency can be almost [4X slower](https://chipsandcheese.com/p/measuring-gpu-memory-latency) compared to CPUs. Given Rowhammer attacks are time constrained, a naive, **single-threaded** hammering pattern similar to a CPU-based attack is unable to produce a sufficient hammering intensity to inject bit flips (see **Fig. 3 Green Line**). Instead, we leverage the [SIMT capability](https://docs.nvidia.com/cuda/cuda-c-programming-guide/#simt-architecture) of GPUs to parallelize hammering using a **multi-thread** and **multi-warp**  approach (see **Fig. 3 Orange Line**), that significantly boosts the intensity of hammering. This eliminates the idle time in the memory controller and achieves the theoretical maximum hammering intensity (rate of row activations, i.e. ACTs, within a refresh period). The different parallelization strategies (thread-level and warp-level hammering) are visualized in **Fig. 4**.
-->
<center>
<div>
<table>
  <thead>
      <tr>
          <th><p><strong>Fig. 3:</strong> Number of activations in a single refresh period (tREFW) for single-thread, multi-thread, and multi-warp hammering.</p></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><p><img src="https://gpuhammer.com/fig3.png" alt="fig3"/></p></td>
      </tr>
  </tbody>
</table>
</div>
</center>
<center>
<p><strong>Fig. 4:</strong> Memory controller utilization with (a) single-thread,
(b) multi-thread, and (c) multi-warp hammering. Multi-warp
hammering minimizes idle time, maximizing activation rates.
<img src="https://gpuhammer.com/fig4.png" alt="fig4"/></p>
</center>

<h3>Step-3: Synchronizing to Refreshes, Defeating Mitigations 
    
    
    <span>
        <a href="#step-3-synchronizing-to-refreshes-defeating-mitigations" aria-label="Anchor">#</a>
    </span>        
    
</h3>
<p>Prior works like <a href="https://www.usenix.org/conference/usenixsecurity21/presentation/ridder" target="_blank">SMASH</a> and <a href="https://comsec.ethz.ch/wp-content/files/blacksmith_sp22.pdf" target="_blank">BlackSmith</a> show that synchronizing hammering to refreshes (REF) is key to bypassing in-DRAM defenses.
However, CUDA‚Äôs synchronization primitives (like <code>__syncthreads()</code>) used to synchronize threads can reorder warp execution. Instead, we use implicit per-warp delays, aligned such that REF commands overlap with our inserted delays, to align our hammering with refreshes and defeat in-DRAM mitigations like TRR while preserving warp execution order.</p>
<!--
As shown in prior works (e.g. 
effectively bypassing existing Rowhammer mitigations requires synchronization to refresh as well as hammering multiple DRAM rows in a deterministic sequence (e.g., [TRResspass]¬¥(https://arxiv.org/abs/2004.01807)).
Particularly, SMASH showed that, by adding appropriate delays after a series of Rowhammer activations, the hammering pattern can synchronize to the DRAM REF commands, during which mitigations are performed, and defeat in-DRAM Rowhammer mitigations.
Unfortunately, naive adoption of synchronization primitives such as `__syncthreads` barrier to insert synchronized delays, is not possible as the warp's execution order is not guaranteed after leaving CUDA's `__syncthreads` barrier.
Instead of explicit memory barriers, we use implicit synchronization where each warp adds its own delays. As shown in **Fig 5.**, the synchronization is achieved when REF happens implicitly during an overlapped region of all the warp's delays. Thus, we maintain the warps' execution order while inserting synchronized delays, allowing us to bypass mitigations.
-->
<center>
<p><strong>Fig. 5:</strong> Per-warp delays inserted using <code>adds</code> for synchronizing
to REF. When the delays overlap, the REF
is inserted in alignment with the hammering pattern.
<img src="https://gpuhammer.com/fig5.png" alt="fig5"/></p>
</center>

<h2>üí• What Did We Break? 
    
    
    <span>
        <a href="#-what-did-we-break" aria-label="Anchor">#</a>
    </span>        
    
</h2>
<p>We ran GPUHammer on an <strong>NVIDIA RTX A6000 (48 GB GDDR6)</strong> across four DRAM banks and observed <strong>8 distinct single-bit flips</strong>, and bit-flips <strong>across all tested banks</strong> (see Fig. 6). The <strong>minimum activation count ( T<sub>RH</sub>)</strong> to induce a flip was ~12K, consistent with prior DDR4 findings.</p>
<!--
We ran GPUHammer on an **NVIDIA RTX A6000 with 48 GB GDDR6 DRAM** across 4 different DRAM banks. As shown in **Fig. 6**, we observe **bit flips (8 in total) in all of the tested banks**. All of the bit-flips are from distinct DRAM rows, and are single bit-flips.The minimum number of activations to trigger a bit-flip, T<sub>RH</sub>, for the bit-flips is 12K, which aligns with prior observations of the T<sub>RH</sub> in DDR4 DRAM.
-->
<!--
We ran Rowhammer campaigns for 4 different DRAM banks selected at random. We perform 5 different n-sided hammering patterns in the campaign, recording bit-flips on the fly.-->
<!--
| <p style=" font-weight: normal;">**Fig. 6:** Number of bit-flips observed across 4 banks on RTX A6000 with GDDR6. We observed bit-flips on every bank.<p> | <p style=" font-weight: normal;">**Fig 7:** The minimum number of activations to trigger a bit-flip (T<sub>RH</sub>) for each bit-flip in RTX A6000, with the minimum being around 12K. <p> |
| :--------: | :------: |
| <img src="/fig6.png" alt="fig6"/> | <img src="/fig7.png" alt="fig7"/> |
-->
<!--
<center>
<div style="width: 40%; border: 1px solid black; ">

**Fig. 6:** Number of bit-flips in 4 banks on RTX A6000 with GDDR6. We observed bit-flips on each bank.
<img src="/fig6.png" alt="fig6"/>
</div>
</center>
-->
<p>Using these flips, we performed the <strong>first ML accuracy degradation attack using Rowhammer on a GPU</strong>. <a href="%28https://www.usenix.org/conference/usenixsecurity19/presentation/hong%29">Prior work</a> shows that <strong>flipping the most significant bit of a floating-point exponent</strong> in FP16 model weights can drastically reduce model accuracy. Based on this insight, we show that in a time-shared GPU setup, an attacker can position victim data into vulnerable DRAM rows via memory massaging and force the bit flips at such locations.</p>
<p>In our proof-of-concept (<strong>Fig. 7</strong>), with just <strong>a single bit flip</strong>, the accuracy of an ML model is <strong>degraded below 1%</strong> for all five tested ImageNet DNN models, resulting in up to <strong>80% accuracy loss</strong>.</p>
<!--
Using these bit-flips, we demonstrate ML accuracy degradation attacks for the first time on a GPU. [Prior work]((https://www.usenix.org/conference/usenixsecurity19/presentation/hong))
has shown that even a single bit-flip in the most siginficant bit of an exponent in amodel weight's floating point representation, can cause catastrophic degradation in the model's accuracy . We assume the attacker is sharing the GPU with the victim via [time-slicing](https://docs.run.ai/v2.17/Researcher/scheduling/GPU-time-slicing-scheduler/).
where the attacker will be able to perform memory massaging to place victim data inside vulnerable DRAM rows. Given the location of our observed bit-flips, they can be used to exploit FP16 quantized model weights. 

We show the results of our exploit in **Fig. 7**. With just a single bit flip, the accuracy of all 5 models is degraded to less than 1%, resulting in an accuracy loss of at most 80%.
-->
<table>
  <thead>
      <tr>
          <th><p><strong>Fig. 6:</strong> Number of bit-flips in 4 banks on RTX A6000 with GDDR6. We observed bit-flips on each bank.</p></th>
          <th><p><strong>Fig. 7:</strong> Accuracy degradation attack on ImageNet models on NVIDIA A6000 GPU. We report the top-1 / top-5 accuracy without (Base Acc) and with (Degraded Acc) the bit-flip, and the Relative Accuracy Drop (RAD) for the top-1 accuracy.</p></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><img src="https://gpuhammer.com/fig6.png" alt="fig6"/></td>
          <td><img src="https://gpuhammer.com/fig8.png" alt="fig7"/></td>
      </tr>
  </tbody>
</table>
<!--
<center>
<div style="width: 50%; border: 1px solid black; ">

**Fig. 7:** Accuracy degradation attack on ImageNet models
using FP16 weights on NVIDIA
A6000 GPU. We report the top-1 / top-5 accuracy without
(Base Acc) and with (Degraded Acc) the bit-flip, and the
Relative Accuracy Drop (RAD) for the top-1 accuracy.
<img  src="/fig8.png" alt="fig8"/>
</div>
</center>
-->

<h2>‚ùì FAQs 
    
    
    <span>
        <a href="#-faqs" aria-label="Anchor">#</a>
    </span>        
    
</h2>

<h4>What GPUs are vulnerable? Am I affected? 
    
    
    <span>
        <a href="#what-gpus-are-vulnerable-am-i-affected" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<p>We confirmed Rowhammer bit flips on <strong>NVIDIA A6000 GPUs with GDDR6</strong> memory. Other GDDR6 GPUs, such as the <strong>RTX 3080</strong>, did not show bit flips in our tests, possibly due to variations in DRAM vendor, chip characteristics, or operating conditions like temperature. We also observed <strong>no flips on an A100</strong> GPU with HBM memory.</p>
<!--
So far, we have demonstrated that the NVIDIA A6000 GPUs with GDDR6 memory are vulnerable. It is possible that other GPUs with GDDR6 memories may also be vulnerable. However, we were unable to observe bit flips on a laptop-based RTX 3090, the only other GDDR6 DRAM based GPU we tested. This could be because the vulnerability levels with Rowhammer can vary based on DRAM manufacturer, technology, device characteristics, and temperature. We were also unable to get successful bit flips on a server-grade A100 with HBM memories.
-->

<h4>Why test so few GPUs? Isn‚Äôt that a small sample size? 
    
    
    <span>
        <a href="#why-test-so-few-gpus-isnt-that-a-small-sample-size" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<p>Unlike CPUs, where DRAM modules can be easily swapped out for testing, <strong>GPU DRAM is soldered in</strong>, making large-scale testing expensive (GPUs can cost thousands of dollars). Our attack code is <strong>extensible to other Ampere GPUs and beyond</strong>, and we encourage future work to expand the test coverage.</p>
<!--
Unlike CPUs, where DRAM modules can be cheaply switched out for tetsing, GPU DRAM is fixed to the device. This makes running Rowhammer campaigns on a large variety of GPUs prohibitively expensive as each GPU can cost thousands dollars. However, our attack code is extensible to other Ampere generation GPUs and beyond. We expect future works will be able to extend this testing to a larger number of GPUs.
-->

<h4>How can GPUHammer be mitigated? 
    
    
    <span>
        <a href="#how-can-gpuhammer-be-mitigated" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<p>Admins can mitigate GPUHammer by <strong>enabling ECC</strong> via <code>nvidia-smi -e 1</code> (followed by a reboot). All observed bit flips so far are <strong>single-bit</strong>, which ECC can correct. However, enabling ECC may <strong>reduce performance by up to 10%</strong> and <strong>memory capacity by 6.25%</strong> on the A6000. Still, this doesn‚Äôt eliminate the root cause, a hardware flaw, which would require redesigning GDDR6 with principled mitigations like  <a href="https://arxiv.org/abs/2501.18861" target="_blank">PRAC</a>, which has been proposed for DDR5 and beyond, or probabilistic mitigations like <a href="https://gururaj-s.github.io/assets/pdf/ISCA24_Jaleel.pdf" target="_blank">PRIDE</a>.</p>
<!--
System administrators can safeguard against GPUHammer to some extent right now by enabling ECC on their GPUs by using `nvidia-smi -e 1`, followed by a restart. As all our discovered bit-flips so far are single bit flips, they are correctable by ECC, which will prevent the vulnerability. This may however impact performance and memory capacity on an A6000: this slows down performance by up to 10% on an A6000 GPU as per our analysis, and also reduces GPU memory capacity by 6.25% as per [prior work](https://dl.acm.org/doi/pdf/10.1145/3579371.3589102). However, this does not fix the root-cause of the problem in case multi-bit flips are discovered. As this is a hardware vulenrability, a full mitigation will require redesigning the GDDR6 memories with principled mitigations, such as [PRAC](https://arxiv.org/abs/2501.18861) or [PRIDE](https://gururaj-s.github.io/assets/pdf/ISCA24_Jaleel.pdf).
-->

<h4>Are newer GPUs like the H100 or RTX 5090 affected? 
    
    
    <span>
        <a href="#are-newer-gpus-like-the-h100-or-rtx-5090-affected" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<p>Currently, <strong>no</strong>. H100 (HBM3) and RTX 5090 (GDDR7) feature <strong>on-die ECC</strong>, which likely masks single-bit flips. However, future Rowhammer patterns causing multi-bit flips  may bypass such ECC, as shown in attacks like <a href="https://www.vusec.net/projects/eccploit/" target="_blank">ECCploit</a>.</p>
<!--
At this time, we do not believe the newer GPUs are impacted with our current attack patterns. As these memories adopt on-die ECC, this can mask single bit flips. However, if better Rowhammer attack patterns emerge in the future, that cause multi bit-flips, such memories may no longer be safe, as shown in [ECCploit](https://www.vusec.net/projects/eccploit/).
-->

<h4>Did you disclose this to NVIDIA? What was their response? 
    
    
    <span>
        <a href="#did-you-disclose-this-to-nvidia-what-was-their-response" aria-label="Anchor">#</a>
    </span>        
    
</h4>
<p>Yes. We <strong>responsibly disclosed</strong> GPUHammer to NVIDIA on <strong>January 15, 2025</strong>, and also to major cloud service providers (AWS, Azure, GCP, etc.). NVIDIA confirmed the issue and recommended enabling ECC as a mitigation.</p>

<h2>Further Information 
    
    
    <span>
        <a href="#further-information" aria-label="Anchor">#</a>
    </span>        
    
</h2>
<p>Please refer to our <a href="https://gururaj-s.github.io/assets/pdf/SEC25_GPUHammer.pdf" target="_blank">paper</a>, which appears at <em>USENIX Security 2025</em>. The artifacts are available on <a href="https://github.com/sith-lab/gpuhammer" target="_blank">GitHub</a> and <a href="https://zenodo.org/records/15694512" target="_blank">Zenodo</a>.</p>
<p>To cite our paper, please use:</p>
<div><pre tabindex="0"><code data-lang="bibtex"><span><span><span>@inproceedings</span><span>{</span><span>lin2025gpuhammer</span><span>,</span>
</span></span><span><span>  <span>author</span>       <span>=</span> <span>{Chris S. Lin and Joyce Qu and Gururaj Saileshwar}</span><span>,</span>
</span></span><span><span>  <span>title</span>        <span>=</span> <span>{GPUHammer: Rowhammer Attacks on GPU Memories are Practical}</span><span>,</span>
</span></span><span><span>  <span>publisher</span>    <span>=</span> <span>{USENIX Association}</span><span>,</span>
</span></span><span><span>  <span>booktitle</span>    <span>=</span> <span>{Proceedings of the 34th USENIX Conference on Security Symposium}</span><span>,</span>
</span></span><span><span>  <span>year</span>         <span>=</span> <span>{2025}</span><span>,</span>
</span></span><span><span>  <span>series</span>       <span>=</span> <span>{SEC &#39;25}</span><span>,</span>
</span></span><span><span>  <span>address</span>      <span>=</span> <span>{USA}</span><span>,</span>
</span></span><span><span>  <span>location</span>     <span>=</span> <span>{Seattle, WA, USA}</span><span>,</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div>
<h3>Acknowledgements 
    
    
    <span>
        <a href="#acknowledgements" aria-label="Anchor">#</a>
    </span>        
    
</h3>
<p>This research was supported by Natural Sciences and Engineering Research Council of Canada (NSERC) under funding reference number RGPIN-2023-04796, and an NSERC-CSE Research Communities Grant under funding reference number ALLRP-588144-23.
Any research, opinions, or positions expressed in this work are solely those of the authors and do not represent the official views of NSERC, the Communications Security Establishment Canada, or the Government of Canada.</p>
<div>
  <p><img src="https://gpuhammer.com/Cse_badge.png" alt="CSE logo"/>
  </p>
  <p><img src="https://gpuhammer.com/NSERC_RGB.png" alt="NSERC logo"/>
  </p>
</div>
<!-- 
# Markdown Syntax

This article offers a sample of basic Markdown formatting that can be used in Blowfish, also it shows how some basic HTML elements are decorated.

## Highlight boxes

  
  
  
  



<div
  
    class="flex px-4 py-3 rounded-md bg-primary-100 dark:bg-primary-900"
  
  >
  <span
    
      class="text-primary-400 ltr:pr-3 rtl:pl-3 flex items-center"
    
    >
    

  <span class="relative block icon">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M506.3 417l-213.3-364c-16.33-28-57.54-28-73.98 0l-213.2 364C-10.59 444.9 9.849 480 42.74 480h426.6C502.1 480 522.6 445 506.3 417zM232 168c0-13.25 10.75-24 24-24S280 154.8 280 168v128c0 13.25-10.75 24-23.1 24S232 309.3 232 296V168zM256 416c-17.36 0-31.44-14.08-31.44-31.44c0-17.36 14.07-31.44 31.44-31.44s31.44 14.08 31.44 31.44C287.4 401.9 273.4 416 256 416z"/></svg>

  </span>


  </span>

  <span
    
      class="dark:text-neutral-300"
    
    ><strong>Note:</strong> This is an important message!</span>
</div>


## Headings

The following HTML `<h1>`‚Äî`<h6>` elements represent six levels of section headings. `<h1>` is the highest section level while `<h6>` is the lowest.

# H1

## H2

### H3

#### H4

##### H5

###### H6

## Paragraph

Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.

Itatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.

## Blockquotes

The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a `footer` or `cite` element, and optionally with in-line changes such as annotations and abbreviations.

### Blockquote without attribution

> Tiam, ad mint andaepu dandae nostion secatur sequo quae.
> **Note** that you can use _Markdown syntax_ within a blockquote.

### Blockquote with attribution

> Don't communicate by sharing memory, share memory by communicating.<br>
> ‚Äî <cite>Rob Pike[^1]</cite>

[^1]: The above quote is excerpted from Rob Pike's [talk `about` nothing](https://www.youtube.com/watch?v=PAAkCSZUG1c) during Gopherfest, November 18, 2015.

## Tables

Tables aren't part of the core Markdown spec, but Hugo supports supports them out-of-the-box.

| Name  | Age |
| ----- | --- |
| Bob   | 27  |
| Alice | 23  |

### Inline Markdown within tables

| Italics   | Bold     | Code   |
| --------- | -------- | ------ |
| _italics_ | **bold** | `code` |

## Code Blocks

### Code block with backticks

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Example HTML5 Document</title>
  </head>
  <body>
    <p>Test</p>
  </body>
</html>
```

### Code block indented with four spaces

    <!DOCTYPE html>
    <html lang="en">
    <head>
      <meta charset="utf-8">
      <title>Example HTML5 Document</title>
    </head>
    <body>
      <p>Test</p>
    </body>
    </html>

### Code block with Hugo's internal highlight shortcode

<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="hl"><span class="lnt"> 4
</span></span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="hl"><span class="lnt"> 7
</span></span><span class="hl"><span class="lnt"> 8
</span></span><span class="hl"><span class="lnt"> 9
</span></span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-html" data-lang="html"><span class="line"><span class="cl"><span class="cp"><!DOCTYPE html></span>
</span></span><span class="line"><span class="cl"><span class="p"><</span><span class="nt">html</span> <span class="na">lang</span><span class="o">=</span><span class="s">"en"</span><span class="p">></span>
</span></span><span class="line"><span class="cl"><span class="p"><</span><span class="nt">head</span><span class="p">></span>
</span></span><span class="line hl"><span class="cl">  <span class="p"><</span><span class="nt">meta</span> <span class="na">charset</span><span class="o">=</span><span class="s">"utf-8"</span><span class="p">></span>
</span></span><span class="line"><span class="cl">  <span class="p"><</span><span class="nt">title</span><span class="p">></span>Example HTML5 Document<span class="p"></</span><span class="nt">title</span><span class="p">></span>
</span></span><span class="line"><span class="cl"><span class="p"></</span><span class="nt">head</span><span class="p">></span>
</span></span><span class="line hl"><span class="cl"><span class="p"><</span><span class="nt">body</span><span class="p">></span>
</span></span><span class="line hl"><span class="cl">  <span class="p"><</span><span class="nt">p</span><span class="p">></span>Test<span class="p"></</span><span class="nt">p</span><span class="p">></span>
</span></span><span class="line hl"><span class="cl"><span class="p"></</span><span class="nt">body</span><span class="p">></span>
</span></span><span class="line"><span class="cl"><span class="p"></</span><span class="nt">html</span><span class="p">></span></span></span></code></pre></td></tr></table>
</div>
</div>

## List Types

### Ordered List

1. First item
2. Second item
3. Third item

### Unordered List

- List item
- Another item
- And another item

### Nested list

- Fruit
  - Apple
  - Orange
  - Banana
- Dairy
  - Milk
  - Cheese

## Other Elements ‚Äî abbr, sub, sup, kbd, mark

<abbr title="Graphics Interchange Format">GIF</abbr> is a bitmap image format.

H<sub>2</sub>O

X<sup>n</sup> + Y<sup>n</sup> = Z<sup>n</sup>

Press <kbd>CTRL</kbd>+<kbd>ALT</kbd>+<kbd>Delete</kbd> to end the session.

Most <mark>salamanders</mark> are nocturnal, and hunt for insects, worms, and other small creatures. --></section>
</article></div>
  </body>
</html>
