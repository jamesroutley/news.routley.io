<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://en.wikipedia.org/wiki/Hashlife">Original</a>
    <h1>HashLife – A memoized algorithm for Conway&#39;s Game of Life and cellular automata</h1>
    
    <div id="readability-page-1" class="page"><div>
							

						<p>From Wikipedia, the free encyclopedia</p>
					</div><div id="mw-content-text"><div lang="en" dir="ltr">

<figure typeof="mw:File/Thumb"><a href="https://en.wikipedia.org/wiki/File:Turing_Machine_in_Golly.png"><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/0/05/Turing_Machine_in_Golly.png/379px-Turing_Machine_in_Golly.png" decoding="async" width="379" height="212" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/0/05/Turing_Machine_in_Golly.png/569px-Turing_Machine_in_Golly.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/0/05/Turing_Machine_in_Golly.png/758px-Turing_Machine_in_Golly.png 2x" data-file-width="1256" data-file-height="704"/></a><figcaption>The 6,366,548,773,467,669,985,195,496,000 (6 <a href="https://en.wikipedia.org/wiki/Names_of_large_numbers" title="Names of large numbers">octillionth</a>) generation of a <a href="https://en.wikipedia.org/wiki/Turing_machine" title="Turing machine">Turing machine</a> in <a href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life" title="Conway&#39;s Game of Life">Life</a> computed in less than 30 seconds on an <a href="https://en.wikipedia.org/wiki/Intel_Core" title="Intel Core">Intel Core</a> Duo 2GHz CPU using Hashlife in <a href="https://en.wikipedia.org/wiki/Golly_(program)" title="Golly (program)">Golly</a>. Computed by detecting a repeating cycle in the pattern, and skipping ahead to any requested generation.</figcaption></figure>
<p><b>Hashlife</b> is a <a href="https://en.wikipedia.org/wiki/Memoization" title="Memoization">memoized</a> <a href="https://en.wikipedia.org/wiki/Algorithm" title="Algorithm">algorithm</a> for computing the long-term fate of a given starting configuration in <a href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life" title="Conway&#39;s Game of Life">Conway&#39;s Game of Life</a> and related <a href="https://en.wikipedia.org/wiki/Cellular_automaton" title="Cellular automaton">cellular automata</a>, much more quickly than would be possible using alternative algorithms that simulate each time step of each cell of the automaton. The algorithm was first described by <a href="https://en.wikipedia.org/wiki/Bill_Gosper" title="Bill Gosper">Bill Gosper</a> in the early 1980s while he was engaged in research at the <a href="https://en.wikipedia.org/wiki/Xerox_Palo_Alto_Research_Center" title="Xerox Palo Alto Research Center">Xerox Palo Alto Research Center</a>. Hashlife was originally implemented on <a href="https://en.wikipedia.org/wiki/Symbolics" title="Symbolics">Symbolics</a> <a href="https://en.wikipedia.org/wiki/Lisp_machine" title="Lisp machine">Lisp machines</a> with the aid of the <a href="https://en.wikipedia.org/wiki/Flavors_(programming_language)" title="Flavors (programming language)">Flavors</a> extension.
</p>
<meta property="mw:PageProp/toc"/>
<h2><span id="Hashlife">Hashlife</span><span><span>[</span><a href="https://en.wikipedia.org/w/index.php?title=Hashlife&amp;action=edit&amp;section=1" title="Edit section: Hashlife"><span>edit</span></a><span>]</span></span></h2>
<p>Hashlife is designed to exploit large amounts of spatial and temporal <a href="https://en.wikipedia.org/wiki/Redundancy_(information_theory)" title="Redundancy (information theory)">redundancy</a> in most Life rules. For example, in <a href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life" title="Conway&#39;s Game of Life">Conway&#39;s Life</a>, many seemingly random patterns end up as collections of simple <a href="https://en.wikipedia.org/wiki/Still_life_(CA)" title="Still life (CA)">still lifes</a> and <a href="https://en.wikipedia.org/wiki/Oscillator_(CA)" title="Oscillator (CA)">oscillators</a>.
</p>
<h3><span id="Representation">Representation</span><span><span>[</span><a href="https://en.wikipedia.org/w/index.php?title=Hashlife&amp;action=edit&amp;section=2" title="Edit section: Representation"><span>edit</span></a><span>]</span></span></h3>
<p>The field is typically treated as a theoretically <a href="https://en.wikipedia.org/wiki/Infinity" title="Infinity">infinite</a> grid, with the <a href="https://en.wikipedia.org/w/index.php?title=Pattern_(CA)&amp;action=edit&amp;redlink=1" title="Pattern (CA) (page does not exist)">pattern</a> in question centered near the <a href="https://en.wikipedia.org/wiki/Origin_(mathematics)" title="Origin (mathematics)">origin</a>. A <a href="https://en.wikipedia.org/wiki/Quadtree" title="Quadtree">quadtree</a> is used to represent the field. Given a square of 2<sup>2<i>k</i></sup> cells, 2<sup><i>k</i></sup> on a side, at the <i>k</i>th level of the tree, the hash table stores the 2<sup><i>k</i>−1</sup>-by-2<sup><i>k</i>−1</sup> square of cells in the center, 2<sup><i>k</i>−2</sup> generations in the future.  For example, for a 4×4 square it stores the 2×2 center, one generation forward; and for an 8×8 square it stores the 4×4 center, two generations forward.
</p>
<h3><span id="Hashing">Hashing</span><span><span>[</span><a href="https://en.wikipedia.org/w/index.php?title=Hashlife&amp;action=edit&amp;section=3" title="Edit section: Hashing"><span>edit</span></a><span>]</span></span></h3>
<p>While a quadtree typically has far more <a href="https://en.wikipedia.org/wiki/Computational_overhead" title="Computational overhead">overhead</a> than other simpler representations (such as using a <a href="https://en.wikipedia.org/wiki/Matrix_(mathematics)" title="Matrix (mathematics)">matrix</a> of <a href="https://en.wikipedia.org/wiki/Bit" title="Bit">bits</a>), it allows for various optimizations. As the name suggests, the algorithm uses <a href="https://en.wikipedia.org/wiki/Hash_table" title="Hash table">hash tables</a> to store the nodes of the quadtree. Many subpatterns in the tree are usually identical to each other; for example the pattern being studied may contain many copies of the same <a href="https://en.wikipedia.org/wiki/Spaceship_(CA)" title="Spaceship (CA)">spaceship</a>, or even large swathes of empty space. These subpatterns will all <a href="https://en.wikipedia.org/wiki/Hash_function" title="Hash function">hash</a> to the same position in the hash table, and thus many copies of the same subpattern can be stored using the same hash table entry. In addition, these subpatterns only need to be evaluated once, not once per copy as in other Life algorithms.
</p><p>This itself leads to significant improvements in resource requirements; for example a generation of the various <a href="https://en.wikipedia.org/wiki/Breeder_(CA)" title="Breeder (CA)">breeders</a> and <a href="https://en.wikipedia.org/wiki/Spacefiller_(CA)" title="Spacefiller (CA)">spacefillers</a>, which grow at <a href="https://en.wikipedia.org/wiki/Polynomial" title="Polynomial">polynomial</a> speeds, can be evaluated in Hashlife using <a href="https://en.wikipedia.org/wiki/Logarithmic_growth" title="Logarithmic growth">logarithmic</a> space and time.
</p>
<h3><span id="Superspeed_and_caching">Superspeed and caching</span><span><span>[</span><a href="https://en.wikipedia.org/w/index.php?title=Hashlife&amp;action=edit&amp;section=4" title="Edit section: Superspeed and caching"><span>edit</span></a><span>]</span></span></h3>
<p>A further speedup for many patterns can be achieved by evolving different nodes at different speeds. For example, one could compute twice the number of generations forward for a node at the (<i>k</i>+1)-th level compared to one at the <i>k</i>th. For sparse or repetitive patterns such as the classical <a href="https://en.wikipedia.org/wiki/Gun_(CA)" title="Gun (CA)">glider gun</a>, this can result in tremendous speedups, allowing one to compute <i>bigger</i> patterns at <i>higher</i> generations <i>faster</i>, sometimes <a href="https://en.wikipedia.org/wiki/Exponential_growth" title="Exponential growth">exponentially</a>. To take full advantage of this feature, subpatterns from past generations should be <a href="https://en.wikipedia.org/wiki/Cache_(computing)" title="Cache (computing)">saved</a> as well.
</p><p>Since different patterns are allowed to run at different speeds, some implementations, like Gosper&#39;s own hlife program, do not have an interactive display, but simply compute a preset result for a starting pattern, usually run from the <a href="https://en.wikipedia.org/wiki/Command_line" title="Command line">command line</a>. More recent programs such as <a href="https://en.wikipedia.org/wiki/Golly_(program)" title="Golly (program)">Golly</a>, however, have a graphical interface that can drive a Hashlife-based engine.
</p><p>The typical behavior of a Hashlife program on a conducive pattern is as follows: first the algorithm runs slower compared to other algorithms because of the constant overhead associated with <a href="https://en.wikipedia.org/wiki/Hash_function" title="Hash function">hashing</a> and building the <a href="https://en.wikipedia.org/wiki/Quadtree" title="Quadtree">tree</a>; but later, enough data will be gathered and its speed will increase tremendously – the rapid increase in speed is often described as &#34;<a href="https://en.wikipedia.org/wiki/Exponential_growth" title="Exponential growth">exploding</a>&#34;.
</p>
<h2><span id="Drawbacks">Drawbacks</span><span><span>[</span><a href="https://en.wikipedia.org/w/index.php?title=Hashlife&amp;action=edit&amp;section=5" title="Edit section: Drawbacks"><span>edit</span></a><span>]</span></span></h2>
<p>Like many <a href="https://en.wikipedia.org/wiki/Memoization" title="Memoization">memoized</a> codes, Hashlife can consume significantly more <a href="https://en.wikipedia.org/wiki/Computer_memory" title="Computer memory">memory</a> than other algorithms, especially on moderate-sized patterns with a lot of entropy, or which contain subpatterns poorly aligned to the bounds of the quadtree nodes (i.e. power-of-two sizes); the cache is a vulnerable component. It can also consume more time than other algorithms on these patterns. <a href="https://en.wikipedia.org/wiki/Golly_(program)" title="Golly (program)">Golly</a>, among other Life simulators, has options for toggling between Hashlife and conventional algorithms.
</p><p>Hashlife is also significantly more complex to <a href="https://en.wikipedia.org/wiki/Computer_programming" title="Computer programming">implement</a>. For example, it needs a dedicated <a href="https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)" title="Garbage collection (computer science)">garbage collector</a> to remove unused nodes from the cache.
</p><p>Due to being designed for processing generally predictable patterns, chaotic and explosive rules generally operate much more poorly under Hashlife than they would under other implementations.<sup id="cite_ref-1"><a href="#cite_note-1">[1]</a></sup>
</p>
<h2><span id="See_also">See also</span><span><span>[</span><a href="https://en.wikipedia.org/w/index.php?title=Hashlife&amp;action=edit&amp;section=6" title="Edit section: See also"><span>edit</span></a><span>]</span></span></h2>
<ul><li><a href="https://en.wikipedia.org/wiki/Purely_functional_data_structure" title="Purely functional data structure">Purely functional data structure</a>, of which the hashed quadtree is one</li>
<li><a href="https://en.wikipedia.org/wiki/Hash_consing" title="Hash consing">Hash consing</a>, which was the key strategy used in the original implementation of Hashlife.</li></ul>
<h2><span id="References">References</span><span><span>[</span><a href="https://en.wikipedia.org/w/index.php?title=Hashlife&amp;action=edit&amp;section=7" title="Edit section: References"><span>edit</span></a><span>]</span></span></h2>
<div>
<div><ol>
<li id="cite_note-1"><span><b><a href="#cite_ref-1">^</a></b></span> <span>HashLife algorithm description in Golly: &#34;Note that HashLife performs very poorly on highly chaotic patterns, so in those cases you are better off switching to QuickLife.&#34;</span>
</li>
</ol></div></div>
<ul><li><cite id="CITEREFGosper1984">Gosper, Bill (1984). &#34;Exploiting Regularities in Large Cellular Spaces&#34;. <i>Physica D</i>. Elsevier. <b>10</b> (1–2): 75–80. <a href="https://en.wikipedia.org/wiki/Doi_(identifier)" title="Doi (identifier)">doi</a>:<a rel="nofollow" href="https://doi.org/10.1016%2F0167-2789%2884%2990251-3">10.1016/0167-2789(84)90251-3</a>.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.jtitle=Physica+D&amp;rft.atitle=Exploiting+Regularities+in+Large+Cellular+Spaces&amp;rft.volume=10&amp;rft.issue=1%E2%80%932&amp;rft.pages=75-80&amp;rft.date=1984&amp;rft_id=info%3Adoi%2F10.1016%2F0167-2789%2884%2990251-3&amp;rft.aulast=Gosper&amp;rft.aufirst=Bill&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AHashlife"></span></li></ul>
<h2><span id="External_links">External links</span><span><span>[</span><a href="https://en.wikipedia.org/w/index.php?title=Hashlife&amp;action=edit&amp;section=8" title="Edit section: External links"><span>edit</span></a><span>]</span></span></h2>
<ul><li><a rel="nofollow" href="http://www.ericweisstein.com/encyclopedias/life/HashLife.html">HashLife from Eric Weisstein&#39;s Treasure Trove of Life</a></li>
<li><a rel="nofollow" href="http://tomas.rokicki.com/hlife/">Tomas Rokicki&#39;s implementation of hashlife</a></li>
<li><a rel="nofollow" href="https://web.archive.org/web/20060210065034/http://www.argentum.freeserve.co.uk/lex_h.htm#hashlife">Entry</a> in the <a rel="nofollow" href="https://web.archive.org/web/20160712171724/http://www.argentum.freeserve.co.uk/lex_home.htm">Life Lexicon</a></li>
<li><a rel="nofollow" href="http://www.ddj.com/dept/ai/184406478">Explanation of the algorithm</a> from <i><a href="https://en.wikipedia.org/wiki/Dr._Dobb%27s_Journal" title="Dr. Dobb&#39;s Journal">Dr. Dobb&#39;s Journal</a></i></li>
<li><a rel="nofollow" href="https://web.archive.org/web/20220131050938/https://jennyhasahat.github.io/hashlife.html">Gosper&#39;s Algorithm (Hashlife) Explained</a> Archived from the <a rel="nofollow" href="https://jennyhasahat.github.io/hashlife.html">original</a></li></ul>

<!-- 
NewPP limit report
Parsed by mw‐api‐ext.eqiad.main‐774bdc5b9f‐5f7dj
Cached time: 20240102230316
Cache expiry: 2592000
Reduced expiry: false
Complications: [vary‐revision‐sha1, show‐toc]
CPU time usage: 0.226 seconds
Real time usage: 0.319 seconds
Preprocessor visited node count: 560/1000000
Post‐expand include size: 19757/2097152 bytes
Template argument size: 747/2097152 bytes
Highest expansion depth: 13/100
Expensive parser function count: 1/500
Unstrip recursion depth: 0/20
Unstrip post‐expand size: 12454/5000000 bytes
Lua time usage: 0.150/10.000 seconds
Lua memory usage: 3175419/52428800 bytes
Number of Wikibase entities loaded: 0/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  272.972      1 -total
 27.80%   75.888      1 Template:Conway's_Game_of_Life
 27.76%   75.765      1 Template:Cite_journal
 26.80%   73.169      1 Template:Navbox
 19.50%   53.236      1 Template:More_footnotes
 19.33%   52.779      1 Template:Short_description
 17.10%   46.686      1 Template:Ambox
 10.14%   27.672      2 Template:Pagetype
  5.49%   14.987      4 Template:Main_other
  4.78%   13.048      1 Template:Reflist
-->

<!-- Saved in parser cache with key enwiki:pcache:idhash:1095547-0!canonical and timestamp 20240102230316 and revision id 1193268117. Rendering was triggered because: api-parse
 -->
</div><!--esi <esi:include src="/esitest-fa8a495983347898/content" /> -->
</div></div>
  </body>
</html>
