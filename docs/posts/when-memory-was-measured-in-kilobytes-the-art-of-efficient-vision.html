<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.softwareheritage.org/2025/06/04/history_computer_vision/">Original</a>
    <h1>When memory was measured in kilobytes: The art of efficient vision</h1>
    
    <div id="readability-page-1" class="page"><div>
	
	<p><em>By Mathilde Fichen</em></p>



<p>In the early days of computer vision, when memory was scarce and every byte counted, innovation thrived under constraint. “An Efficient Chain-Linking Algorithm,” developed at Inria in the late 1980s, is a brilliant example of this spirit. Now preserved and shared by Software Heritage, this compact yet powerful piece of C code showcases how elegance and efficiency went hand in hand in outlining the future of image processing—one pixel chain at a time.</p>



<p>The code resulted from research work carried out between 1985 and 1991 at Inria, by Gérard Giraudon (research and principal investigator), Philippe Garnesson (a PhD student), and Patrick Cipière (software engineer). Down in sunny Sophia Antipolis, a <a href="https://en.wikipedia.org/wiki/Sophia_Antipolis">tech park</a> 20 minutes inland from Antibes, the team tackled computer vision with a distinctly local flavor. They called themselves PASTIS, a playful nod to the anise drink. Still, the acronym – Scene Analysis and Symbolic Image Processing Project (Projet d’Analyse de Scène et de Traitement d’Image Symbolique) – hinted at their serious mission.</p>





<h2>Preserving Inria legacy software</h2>



<p>The effort to preserve this source code is part of a broader initiative to preserve the legacy codes of <a href="https://www.inria.fr/en">Inria</a> (France’s National Institute for Research in Digital Science and Technology), launched in 2023 in a joint effort of Software Heritage, Inria Alumni, and Inria. The project to preserve Inria’s legacy software started by reaching out to the institute’s community, past and present, through a survey (as detailed in our <a href="https://ipres2024.pubpub.org/pub/hdap1420/release/1?readingCollection=21e62c05">iPres article</a>.)  This initial outreach informed a dedicated, <a href="https://www.softwareheritage.org/2024/12/10/preserving-inrias-legacy-software/">hands-on workshop in 2024</a>, which kicked off the practical work of exploring these historical codes. The current focus is on securely archiving the important legacy software we’ve identified within Software Heritage. Sharing the stories behind these codes with the broader community is just as vital.</p>



<p>The recovery of some code has been surprisingly straightforward. For instance, the code for “An Efficient Chain-Linking Algorithm” was readily accessible thanks to Gérard Giraudon’s personal preservation efforts on a local drive. That small success story is a reminder of how important individual initiative is for preserving digital work. Each piece of software recovered isn’t just code; it’s a piece of research history, carrying the stories of the people who created it.</p>


<div>
<figure><a href="https://www.softwareheritage.org/wp-content/uploads/2024/11/swhap-workshop-scaled.jpg"><img decoding="async" width="1024" height="576" src="https://www.softwareheritage.org/wp-content/uploads/2024/11/swhap-workshop-1024x576.jpg" alt="" srcset="https://www.softwareheritage.org/wp-content/uploads/2024/11/swhap-workshop-1024x576.jpg 1024w, https://www.softwareheritage.org/wp-content/uploads/2024/11/swhap-workshop-300x169.jpg 300w, https://www.softwareheritage.org/wp-content/uploads/2024/11/swhap-workshop-768x432.jpg 768w, https://www.softwareheritage.org/wp-content/uploads/2024/11/swhap-workshop-1536x864.jpg 1536w, https://www.softwareheritage.org/wp-content/uploads/2024/11/swhap-workshop-2048x1152.jpg 2048w" sizes="(max-width: 1024px) 100vw, 1024px"/></a><figcaption><em>Inria alumni workshop, October 2024, Inria Paris.</em></figcaption></figure></div>


<h2>An algorithm for outlining images </h2>



<p>The chain-linking algorithm processes a 2D pixel matrix, typically the output of a contour detection step.</p>


<div>
<figure><a href="https://www.softwareheritage.org/wp-content/uploads/2025/05/image5.png"><img loading="lazy" decoding="async" width="325" height="307" src="https://www.softwareheritage.org/wp-content/uploads/2025/05/image5.png" alt="" srcset="https://www.softwareheritage.org/wp-content/uploads/2025/05/image5.png 325w, https://www.softwareheritage.org/wp-content/uploads/2025/05/image5-300x283.png 300w" sizes="auto, (max-width: 325px) 100vw, 325px"/></a></figure></div>


<p><em>Raw image used as input for the algorithm. Source: Chaînage efficace de contour, n° 605, Février 1987, Gérard Giraudon</em></p>



<p>The output is a list of contour chains. Each chain in this list is a sequence of pixel coordinates that define a continuous boundary, ready for further steps like polygonal approximation or shape analysis..</p>



<p>Processed image. Source : Chaînage efficace de contour, n° 605, Février 1987, Gérard Giraudon</p>



<p>Basically, the chain-linking connects the edge pixels to create smooth outlines, just like tracing the shape with a pencil.</p>



<h2>Computer vision in the 80s</h2>



<p>The mid-1980s aspiration of seeing robots hit a speed bump: computer vision algorithms weren’t fast enough. The core challenge? Real-time performance – the essential ingredient for giving robots camera “eyes” that could truly see and react. At the time, such a system was conceived as a pipeline of operations from image acquisition (one shot or video) to a decision-making system. </p>



<p>The goal was to extract meaningful information from raw image data, typically represented as an 8-bit matrix of pixel intensities, and convert it into a graph in list form (i.e., from matrix to list). This process begins with detecting and recognizing shapes within the image, either in 2D or 3D, depending on the available data. From there, the system identifies objects and analyzes their spatial relationships, ultimately constructing a graph of semantic connections between them. This graph captures not just what the objects are, but how they relate to one another within the observed scene. In some cases, the analysis extends over time (3D + t), allowing for the interpretation of motion and dynamic interactions in a sequence of frames.</p>



<h2>Solving key memory issues</h2>


<div>
<figure><a href="https://www.softwareheritage.org/wp-content/uploads/2025/05/image3.png"><img loading="lazy" decoding="async" width="786" height="412" src="https://www.softwareheritage.org/wp-content/uploads/2025/05/image3.png" alt="" srcset="https://www.softwareheritage.org/wp-content/uploads/2025/05/image3.png 786w, https://www.softwareheritage.org/wp-content/uploads/2025/05/image3-300x157.png 300w, https://www.softwareheritage.org/wp-content/uploads/2025/05/image3-768x403.png 768w" sizes="auto, (max-width: 786px) 100vw, 786px"/></a></figure></div>


<p><em>The algorithm was first developed on a PerkinElmer Model 3250 computer, seen above in a brochure <a href="https://www.1000bit.it/ad/bro/perkin/PerkinElmer-3250.pdf">via 1000bit. </a></em></p>



<p>Another challenge in early image processing was the limited amount of short-term memory (RAM) available in computers. This made it essential to focus on reducing the amount of data stored and processed at any given time, while preserving important information.</p>



<p>Due to these constraints, the Efficient Chain-Linking Algorithm could only store three lines of the image at a time while reading it line by line. As each new line was read, the algorithm would build and extend chains of connected pixels on the fly, without knowing how those chains might continue in future lines. Once the entire image was scanned, a final processing stage merged pixel chains belonging to the same contour and resolved junctions or branching points. Importantly, this was done using just one full pass over the data, making it memory-efficient.</p>



<p>But the algorithm wasn’t the only clever bit. From a programming standpoint, the code’s true ingenuity lay in its dynamic memory allocation for storing the chain lists. Back then, predicting memory needs upfront was impossible, making Patrick Cipiere’s approach an elegant solution to an unpredictable challenge.</p>


<div>
<figure><a href="https://www.softwareheritage.org/wp-content/uploads/2025/05/image1.png"><img loading="lazy" decoding="async" width="425" height="339" src="https://www.softwareheritage.org/wp-content/uploads/2025/05/image1.png" alt="" srcset="https://www.softwareheritage.org/wp-content/uploads/2025/05/image1.png 425w, https://www.softwareheritage.org/wp-content/uploads/2025/05/image1-300x239.png 300w" sizes="auto, (max-width: 425px) 100vw, 425px"/></a><figcaption><em>Source code for memory allocation</em> <em>(excerpt)</em></figcaption></figure></div>


<h2>Computer vision today</h2>



<p>With the dramatic advancements in computer vision, fueled by deep learning and the prevalence of large memory capacities, contemporary methods often involve storing the full image and constructing contour chains sequentially, possibly necessitating multiple passes over the data, one for each chain. Yet, even with today’s abundant memory, this algorithm retains its power: remarkable efficiency when every byte counts. By processing the image sequentially, storing only a few lines at a time, and building pixel chains incrementally without looking back, it offers a lean and effective alternative to the memory-hungry approaches now common.</p>



<h2>Links and references</h2>



<figure><a href="https://www.softwareheritage.org/wp-content/uploads/2025/05/computer-vision.png"><img loading="lazy" decoding="async" width="1024" height="522" src="https://www.softwareheritage.org/wp-content/uploads/2025/05/computer-vision.png" alt="" srcset="https://www.softwareheritage.org/wp-content/uploads/2025/05/computer-vision.png 1024w, https://www.softwareheritage.org/wp-content/uploads/2025/05/computer-vision-300x153.png 300w, https://www.softwareheritage.org/wp-content/uploads/2025/05/computer-vision-768x392.png 768w" sizes="auto, (max-width: 1024px) 100vw, 1024px"/></a></figure>



<p>The preserved source code can be found on Software Heritage archive: <a href="https://archive.softwareheritage.org/browse/origin/directory/?origin_url=https://github.com/mathfichen/chainage_de_contour">https://archive.softwareheritage.org/browse/origin/directory/?origin_url=https://github.com/mathfichen/chainage_de_contour</a></p>



<p>The original 79-page paper in French, “Chaînage efficace de contour, n° 605, Février 1987, Gerard Giraudon” <a href="https://inria.hal.science/inria-00075949/document">https://inria.hal.science/inria-00075949/document</a></p>



<p>An Efficient Chain-Linking Algorithm, G. Giraudon, in The 5th Scandinavian Conference on Image Analysis, Stockholm, June 1987.</p>



<p>A Real Time Parallel Edge Following in Single Pass, GG, in Workshop on Computer Vision, Miami, 1987</p>



<p>Chaînage efficace de contour, G. Giraudon, 3ème Colloque Image-Cesta, Paris, Mai 1987</p>



<p>Un standard pour une représentation d’objets de type liste dans le domaine du traitement d’images, n° 82, décembre 1988 – 3ieme édition, P. Garnesson, G. Giraudon.</p>



<p>Un standard pour une représentation d’objets de type liste dans le domaine du traitement d’images, n° 82, décembre 1988 – 3ieme édition, P. Garnesson, G. Giraudon.</p>



<p>« L’approximation polygonale, bilans et perspectives », Rapport de recherche n°1621 INRIA, juin 1991  Garnesson P. and Giraudon G. </p>



<p>This work has resulted in citations and a hardware implementation presented at the 16th GRETSI COLLOQUIUM — SEPTEMBER 15-19, 1997</p>




	
			</div></div>
  </body>
</html>
