<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.wilsonb.com/posts/2024-09-27-brainfuck.html">Original</a>
    <h1>Implementing Brainfuck in APL</h1>
    
    <div id="readability-page-1" class="page"><div id="content">
            

            <p>
    Posted on September 27, 2024
    
        by Brandon Wilson
    
</p>


<p>APL is a pretty great language for quickly iterating on program architecture.
In particular, here is a quick comparison of a couple brainfuck
implementations.</p>
<p>The brainfuck virtual machine is essentially a minimal <a href="https://en.wikipedia.org/wiki/Harvard_architecture">Harvard
architecture</a>: we have an instruction space, a data tape, and indices into
each. If you are unfamiliar with the (tiny!) specification, take a look at
brainfuck’s <a href="https://brainfuck.org/">official website</a>.</p>
<p>Anyway, we start our implementation by initializing state:</p>
<pre><code>run←{
 ⎕IO∘←0 ⋄ n t b∘←0 (1e6⍴0) ⍬ ⋄ prg←⍵              ⍝ Data index, tape, and input buffer
 _←2{p[⍵]←⍺[⍺⍸⍵]}⌿⊢∘⊂⌸¯1⌽+⍀1 ¯1 0[&#39;[]&#39;⍳⍵⊣p∘←⍳≢⍵]  ⍝ Parent vector for brackets
 _←⍵ ⍺⍺⍣{⍵=¯1+≢prg}0                              ⍝ Run instructions from 0 to last
}</code></pre>
<p>This operator runs single-instruction executors recursively over the full
instruction input, which lets us plug and play different implementations of the
execution unit.</p>
<h2 id="version-0">Version 0</h2>
<p>One obvious implementation mirrors the language specification directly:</p>
<pre><code>v0←{
 ⍺[⍵]=&#39;&gt;&#39;:⍵+1⊣n+←1
 ⍺[⍵]=&#39;&lt;&#39;:⍵+1⊣n-←1
 ⍺[⍵]=&#39;+&#39;:⍵+1⊣t[n]+←1
 ⍺[⍵]=&#39;-&#39;:⍵+1⊣t[n]-←1
 ⍺[⍵]=&#39;.&#39;:⍵+1⊣⍞←⎕UCS t[n]
 ⍺[⍵]=&#39;,&#39;:⍵+1⊣t[n]←⍞
 (⍺[⍵]=&#39;[&#39;)∧t[n]≠0:⍵+1
 (⍺[⍵]=&#39;[&#39;)∧t[n]=0:⊃⌽⍸p=⍵
 (⍺[⍵]=&#39;]&#39;)∧t[n]=0:⍵+1
 (⍺[⍵]=&#39;]&#39;)∧t[n]≠0:p[⍵]
}</code></pre>
<p>This essentially gives us a big switch statement that executes each
instruction. Squinting our eyes a bit, this architecture is spiritially in the
same family as an <a href="https://en.wikipedia.org/wiki/LR_parser">LR parser</a>, since it fundamentally is limited to a small
(1 token) parse window.</p>
<p>Since brainfuck has jumps with <code>[</code> and <code>]</code> instructions, our single-instruction
executors need to also update the instruction pointer address. We’re managing
this state by taking the address in <code>⍵</code> and returning the address of the next
instruction to execute.</p>
<p>The repetition of <code>⍵+1</code> is a tad ugly, and it really seems like we should be
able to merge the <code>n+←1</code> and <code>n-←1</code> cases. Ditto for some of the other
structural repetitions. For example, a strategy like the following lets us
merge <code>&lt;</code> and <code>&gt;</code> cases:</p>
<pre><code>2&gt;i←a[⍵]∊&#39;&lt;&gt;&#39;: ⍵+1⊣n+←¯1 1[i]</code></pre>
<h2 id="version-1">Version 1</h2>
<p>Very similar code works for <code>+</code> and <code>-</code> as well; however, the similarity
between <code>&lt;&gt;</code> and <code>+-</code> cases also begs for further fusion. And what about
bracket instructions and <code>⍵+1</code> repetition?</p>
<p>Staring at the problem for a bit, we may notice that fusing instruction cases
sometimes requires updating multiple state variables in a single case. This
suggests an approach that updates all state in a single “case”. Said another
way, we can transpose how we think about the relationship between instructions
and state. Instead of dispatching a specific state update per instruction, we
can holistically update all state at once:</p>
<pre><code>v1←{
 n+←¯1 1 0[&#39;&lt;&gt;&#39;⍳⍺[⍵]]                            ⍝ Update data index
 t[n]+←¯1 1 0[&#39;-+&#39;⍳⍺[⍵]]                         ⍝ Update data cell
 _←{⍞←⎕UCS⍵}⍣(⍺[⍵]=&#39;.&#39;)⊢t[n]                     ⍝ Handle output
 _←{t[n] b∘←1 1⊂{⎕UCS⍞}⍣(b≡⍬)⊢b}⍣(⍺[⍵]=&#39;,&#39;)⊢⍬    ⍝ Handle input
 1+(3 2⍴⍵(⊃⌽⍸p=⍵)(p[⍵])⍵ ⍵ ⍵)[&#39;[]&#39;⍳⍺[⍵];t[n]=0]  ⍝ Update instruction index
}</code></pre>
<p>Not only is the code shorter, but now it has us thinking in a data-first
paradigm, compared to the more procedural flavor of <code>v0</code>. Indeed, each line of
<code>v1</code> corresponds to a single state variable, modulo input/output handling.</p>
<h2 id="a-desideratum">A Desideratum</h2>
<p>Speaking of input/output, notice the change in our input handler. Brainfuck’s
I/O instructions respectively read and write single characters at a time.
However, <code>⍞</code> accepts input up until a newline, and brainfuck applications in
the wild also typically process line-oriented input. By maintaining a buffer of
one input line in <code>b</code> and only calling <code>⍞</code> when <code>b</code> is empty, we get much
improved input UX.</p>
<p>Backporting this to <code>v0</code> changes the line</p>
<pre><code>⍺[⍵]=&#39;,&#39;:⍵+1⊣t[n]←⍞</code></pre>
<p>into</p>
<pre><code>⍺[⍵]=&#39;,&#39;:⍵+1⊣t[n] b∘←1 1⊂{⎕UCS⍞}⍣(b≡⍬)⊢b</code></pre>
<h2 id="performance">Performance</h2>
<p>How do these implementations stack up in terms of execution performance?</p>
<p>On the one hand, apart from the case-detection, <code>v0</code> executions only enough
code to execute the current instruction, while <code>v1</code> is virtually constant time
for every instruction. On the other hand, perhaps the guard statements in <code>v0</code>
overwhelm any such advantage.</p>
<p>As a simple first-order comparison, we use the <a href="https://en.wikipedia.org/wiki/Brainfuck#Hello_World!">Hello World</a> example
provided on Wikipedia:</p>
<pre><code>    PRG ←&#39;++++++++[&gt;++++[&gt;++&gt;+++&gt;+++&gt;+&lt;&lt;&lt;&lt;-]&gt;+&gt;+&gt;-&gt;&gt;+[&lt;]&lt;-]&gt;&gt;.&gt;---.+++++++.&#39;
    PRG⍪←&#39;.+++.&gt;&gt;.&lt;-.&lt;.+++.------.--------.&gt;&gt;+.&gt;++.&#39;
    cmpx &#39;v0 run PRG&#39; &#39;v1 run PRG&#39;
bf_v0 PRG → 1.2E¯1 |    0% ⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕
bf_v1 PRG → 3.7E¯1 | +198% ⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕</code></pre>
<h2 id="future-exploration">Future Exploration</h2>
<p>It’s also tempting to write a brainfuck compiler. In fact, there are obvious
opportunities for instruction fusion and parallel execution. Apart from it’s
parsimony, what stands out to me with the <code>v1</code> architecture is that it doesn’t
bake in the “single instruction at a time” constraint, making data-parallelism
more manifestly accessible.</p>
<p>Despite the above being ostensibly about a toy implementation, the procedural
vs. data-first architectural difference touches on some deep topics. More
serious projects that lean heavily on these ideas include my <a href="https://github.com/xelxebar/dayaml">dayaml</a>
parser, the <a href="https://github.com/Co-dfns/Co-dfns/">Co-dfns</a> compiler, and data-parallel proof verification<a href="https://www.dyalog.com/user-meetings/dyalog24.htm#D14">6</a>.</p>
<p>All this merits much more discussion, but that’s whole ’nother story.</p>
<h2 id="acknowledgements">Acknowledgements</h2>
<p>Many thanks to <a href="https://github.com/xelxebar/dayaml">Adám Brudzewsky</a> for taking the time to read my code and
suggest several spelling improvements in expressions. The depth of his
knowledge, easy facility with APL, and sharp wit are always mutually impressive
and a joy.</p>

        </div></div>
  </body>
</html>
