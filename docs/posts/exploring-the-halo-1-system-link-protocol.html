<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://hllmn.net/blog/2023-09-18_h1x-net/">Original</a>
    <h1>Exploring the Halo 1 System Link Protocol</h1>
    
    <div id="readability-page-1" class="page"><section id="Exploring-The-Halo-1-System-Link-Protocol">

<p><em>September 18, 2023</em></p>
<p>One of my all-time favorite games is <a href="https://en.wikipedia.org/wiki/Halo:_Combat_Evolved"><em>Halo: Combat Evolved</em></a> that launched
together with the original <a href="https://en.wikipedia.org/wiki/Xbox_(console)">Xbox</a> in 2001. One major part of the game was
multiplayer, up to 16 people at a LAN party could play together by connecting
four Xbox consoles over <a href="https://en.wikipedia.org/wiki/Ethernet">Ethernet</a>, referred to as <a href="https://en.wikipedia.org/wiki/System_Link"><em>System Link</em></a>.</p>
<p>Out of pure curiosity, we will try to look at how the Halo game instances
communicate with each other over System Link. In order to do that, we will set
up System Link, play some Halo multiplayer, and see if we can reverse engineer
the network protocol by inspecting the messages that are sent between the
consoles. Should be easy enough, right?</p>
<details><summary>Table of contents</summary>
<ul>
<li>
1 <a href="#System-Link-setup">System Link setup</a>
</li>
<li>
2 <a href="#Observing-the-traffic">Observing the traffic</a>
</li>
<li>
3 <a href="#Watching-from-inside">Watching from inside</a>
</li>
<li>
4 <a href="#Decrypting-the-traffic">Decrypting the traffic</a>
</li>
<li>
5 <a href="#Key-derivation">Key derivation</a>
</li>
<li>
6 <a href="#Man-in-the-middle">Man in the middle</a>
</li>
<li>
7 <a href="#The-game-network-protocol">The game network protocol</a>
</li>
<li>
8 <a href="#Altering-in-game-packets">Altering in-game packets</a>
</li>
<li>
9 <a href="#Summary">Summary</a>
</li>
</ul>
</details>
<section id="System-Link-setup">
<h2>System Link setup</h2>
<p>I still have a fully functional unmodified original Xbox console. We will
connect it to a computer using Ethernet cables via a network switch and run an
Xbox emulator on the computer that will play together with the console.</p>
<p>We will use the <a href="https://github.com/xemu-project/xemu">xemu</a> emulator, which is based on the excellent <a href="https://www.qemu.org/">QEMU</a>
project. The Xbox contains a more or less off-the-shelf Intel Pentium III, a
32-bit <a href="https://en.wikipedia.org/wiki/X86">x86</a> CPU. If interested, you may find a good introduction to the Xbox
architecture <a href="https://www.copetti.org/writings/consoles/xbox/">here</a>.</p>
<p>In order to run Halo with xemu, we will need some files, in particular:</p>
<ul>
<li>
a 6.9 GiB game disc, containing the game executable (<a href="https://xboxdevwiki.net/Xbe">XBE</a>) and all assets,
</li>
<li>
an HDD image in QEMU’s qcow2 format, containing a dashboard that launches the
game,
</li>
<li>
a 256 KiB <a href="https://xboxdevwiki.net/BIOS">BIOS ROM</a> (actually 1024 KiB, replicated 4 times), containing
the BIOS, bootloader and the Xbox <a href="https://xboxdevwiki.net/Kernel">kernel</a>,
</li>
<li>
a 512 B <a href="https://xboxdevwiki.net/MCPX_ROM">MCPX ROM</a> which does some configurations at boot and then decrypts
and runs the bootloader,
</li>
<li>
a 256 B <a href="https://xboxdevwiki.net/EEPROM">EEPROM</a>, with some device-specific information, e.g.
the <a href="https://en.wikipedia.org/wiki/Mac_address">MAC address</a>.
</li>
</ul>
<p>The xemu project provides pre-formatted <a href="https://xemu.app/docs/required-files/#hard-disk-image">HDD images</a> that contain a
dummy dashboard that we will use. Xemu will also automatically set up an EEPROM
for us. For the MCPX ROM, we will use an open source
<a href="https://github.com/SnowyMouse/fancy-mouse-boot-rom">reimplementation</a>. For the game disc and BIOS ROM, we will have to
use dumped images.</p>
<p>We will use <a href="https://en.wikipedia.org/wiki/PAL_region">PAL region</a> copies of the game, which differ from the ones in
NTSC regions. For example, the original NTSC version runs at 30 frames per
second while the PAL version runs at 25 frames per second<a id="fnref1" href="#fn1" role="doc-noteref"><sup>1</sup></a>.</p>
<p>Now we boot up Halo on the Xbox console, create a System Link game and connect
the console to our computer with some Ethernet cables. We then boot up the
emulator, set up the above mentioned files, make sure it is set up to use the
Ethernet <a href="https://en.wikipedia.org/wiki/Network_interface_controller">network interface</a> and then search for System Link games.</p>
<p><img alt="searching for available games, Howard is listed" src="https://jvns.ca/blog/2023/09/14/in-a-git-repository--where-do-your-files-live-/lobby_search.jpg"/></p>
<p>And voila! We find the game hosted by the console and can play some Halo over
LAN.</p>
</section>
<section id="Observing-the-traffic">
<h2>Observing the traffic</h2>
<p>While searching for games, packets should be sent between the instances
continuously, because as soon as the game is closed it is removed from the
list. We can then run e.g. <a href="https://www.tcpdump.org/"><code>tcpdump</code></a> and see if we can detect any of these
packets over our network interface.</p>
<pre><code><SPAN color="#b8bb26"><b>$</b></SPAN> tcpdump</code></pre>
<p>Besides some random traffic on my LAN, we can see that there are some
<a href="https://en.wikipedia.org/wiki/User_Datagram_Protocol">UDP</a> packets that go via a port that <code>tcpdump</code> has actually labeled as
“xbox”<a id="fnref2" href="#fn2" role="doc-noteref"><sup>2</sup></a>. We can use the <a href="https://en.wikipedia.org/wiki/Berkeley_Packet_Filter">BPF</a> expression <code>udp port xbox</code> to
filter by this UDP port, and ignore all other traffic. In order to normalize
the timestamps to be offset from the first packet, we will add the <code>-ttttt</code>
option.</p>
<p>Interestingly, the Xbox consoles always use <code>0.0.0.1</code> as the source <a href="https://en.wikipedia.org/wiki/IP_address">IP
address</a> and they send broadcast messages to <code>255.255.255.255</code>. They
seem to address each other by MAC addresses only, we therefore add the <code>-e</code>
option to display the MAC addresses in order to know which of the two machines
each packet is sent from.</p>
<p>In order to improve readability, we will strip some redundant information and
replace the MAC addresses of the machines by the names of the consoles used by
the game. My console happens to be called “Howard” and is the host of the game
while the emulator is called “Ghost” which is a guest that connects to the
host’s game. Our output should then be easier to read:</p>
<pre><code>00.000000 Ghost &gt; ff:ff:ff:ff:ff:ff, len 60</code></pre>
<p>Now we can see that the guest searches for existing games with a 60-byte packet
every 2 seconds, to which the game host quickly responds with a 324-byte
packet. If we then join the game, we initially get a rapid series of exchanged
packets:</p>
<div>
<div>
<pre><code>00.000000 Ghost &gt; Howard, len 164</code></pre>
</div>
<p><img alt="pre-game lobby screen of Howard’s game" src="https://jvns.ca/blog/2023/09/14/in-a-git-repository--where-do-your-files-live-/lobby.jpg"/></p>
</div>
<p>While we are connected to the pre-game lobby (and not pressing anything), a
316-byte packet with a 44-byte response is sent by the guest every second. The
host also sends a 60-byte packet with a 44-byte response every 5 seconds:</p>
<pre><code>00.000000 Ghost &gt; Howard, len 316</code></pre>
<p>When starting the game we get an initial exchange of packets:</p>
<div>
<div>
<pre><code>00.000000 Howard &gt; Ghost, len 60</code></pre>
</div>
<p><img alt="Screenshot from in-game, Rockets on Blood Gulch" src="https://jvns.ca/blog/2023/09/14/in-a-git-repository--where-do-your-files-live-/bloodgulch.jpg"/></p>
</div>
<p>After that we get repeating cycles of packets again:</p>
<pre><code>00.000000 Ghost &gt; Howard, len 84</code></pre>
<p>The most frequent packet is 84 bytes, it is sent by the guest every 41 ms and
receives a 132-byte response. This is close to the 25 frames per second that
PAL Halo runs at. Sometimes, another 132-byte packet is sent by the host
immediately after the first response. Every 200 ms a 44-byte packet is also
sent by the guest with no response.</p>
<p>So, some form of game data is sent between the guest and the host every frame
of the game. Now we just need to inspect those packets and see if we can
understand what information they contain, right?</p>
<p>We can supply the <code>-X</code> flag to <code>tcpdump</code> in order to show the packet data in
hexadecimal and ASCII. At first we listen during the game search as those
packets should be mostly static and perhaps contain the name of the host in
plain text. Let us try it out:</p>
<pre><code><SPAN color="#b8bb26"><b>$</b></SPAN> tcpdump <SPAN color="#fe8019">-e</SPAN> <SPAN color="#fe8019">-ttttt</SPAN> <SPAN color="#fe8019">-X</SPAN> <span><SPAN color="#bbbbbb">&#34;</SPAN></span><SPAN color="#b8bb26">udp port xbox</SPAN><span><SPAN color="#bbbbbb">&#34;</SPAN></span></code></pre>
<p>Unfortunately, these packets do not contain any readable strings, neither does
is the content static between packets. The data shown by tcpdump shows the
whole packet except for the Ethernet header, we can annotate one of the packets
as per the <a href="https://www.rfc-editor.org/rfc/rfc791#section-3.1">IP</a> and <a href="https://www.rfc-editor.org/rfc/rfc768">UDP</a> RFCs:</p>
<pre><code>/* IPv4 header */</code></pre>
<p>The actual data always starts with eight <code>0xff</code> bytes for these packets, the
remaining looks completely random, presumably encrypted. How come the packets
are encrypted? Is the System Link traffic over LAN really that critical? Oh
well, now I am even more curious to see what it contains.</p>
</section>
<section id="Watching-from-inside">
<h2>Watching from inside</h2>
<p>Even though we are not able to read the contents of the packets from outside,
the emulator must be able to read it as it has clearly managed to connect to
and play with the Xbox console. If we were able to look inside the emulator’s
memory, we should be able to inspect the decrypted packet data.</p>
<p>Like with QEMU, we can with xemu easily attach a debugger to the guest program.
We simply provide <code>-gdb tcp::1234</code> when starting xemu to create a <a href="https://en.wikipedia.org/wiki/GNU_Debugger">GDB</a>
server that listens on the TCP port 1234. We can then connect to it with GDB by
running</p>
<pre><code>(gdb) <SPAN color="#fb4934">target</SPAN> <SPAN color="#fb4934">remote</SPAN> :1234<br/></code></pre>
<p>in a GDB console.</p>
<p>However, it is not entirely trivial to find the location of a message in memory
just as it has been decrypted. But if we were to know where the decryption
occurs in the program, we could place a <a href="https://en.wikipedia.org/wiki/Breakpoint">breakpoint</a> there and read the
memory for the message right after it has been decrypted (or before it has been
encrypted).</p>
<p>I suspect that the cryptography stack is not specific to the Halo game,
probably all Xbox multiplayer games use similar type of encryption. It would
then seem plausible that the crypto code is located in a shared place, such as
for example the Xbox kernel.</p>
<p>The <a href="https://xboxdevwiki.net/Main_Page">XboxDevWiki</a> has a useful <a href="https://xboxdevwiki.net/Kernel">wiki page</a> about the kernel,
it has a list of functions and variables that it exports. Some of these exports
contain nice words like “crypt” and “key”. There is a group of exports prefixed
with “Xc” that are related to cryptography and some sort of LAN key:</p>
<table>
<tbody><tr>
<th>export</th>
<th>ordinal</th>
<th>type</th>
</tr>
<tr>
<td>XcSHAInit</td>
<td>335</td>
<td>stdcall</td>
</tr>
<tr>
<td>XcSHAUpdate</td>
<td>336</td>
<td>stdcall</td>
</tr>
<tr>
<td>XcSHAFinal</td>
<td>337</td>
<td>stdcall</td>
</tr>
<tr>
<td>XcRC4Key</td>
<td>338</td>
<td>stdcall</td>
</tr>
<tr>
<td>XcRC4Crypt</td>
<td>339</td>
<td>stdcall</td>
</tr>
<tr>
<td>XcHMAC</td>
<td>340</td>
<td>stdcall</td>
</tr>
<tr>
<td>XcModExp</td>
<td>345</td>
<td>stdcall</td>
</tr>
<tr>
<td>XcDESKeyParity</td>
<td>346</td>
<td>stdcall</td>
</tr>
<tr>
<td>XcKeyTable</td>
<td>347</td>
<td>stdcall</td>
</tr>
<tr>
<td>XcBlockCrypt</td>
<td>348</td>
<td>stdcall</td>
</tr>
<tr>
<td>XcBlockCryptCBC</td>
<td>349</td>
<td>stdcall</td>
</tr>
<tr>
<td>XboxLANKey</td>
<td>353</td>
<td>variable</td>
</tr>
</tbody></table>
<p>Searching for these on the web leads to a <a href="https://github.com/XboxDev/nxdk/blob/master/lib/xboxkrnl/xboxkrnl.h">header file</a> in the
<a href="https://github.com/XboxDev/nxdk">nxdk</a> project, an open source SDK for the Xbox. It lists the prototype
declarations of all exported kernel functions, including the <code>XcBlockCryptCBC</code>
function which looks promising:</p>
<pre><code>XBAPI VOID NTAPI XcBlockCryptCBC</code></pre>
<p>As mentioned by the table of exports, the functions use the <a href="https://en.wikipedia.org/wiki/X86_calling_conventions#stdcall"><em>stdcall</em></a>
calling convention where all arguments are pushed to the stack in
<em>right-to-left</em> order. If we can place a breakpoint when entering the
<code>XcBlockCryptCBC</code> function, we can read the input and output arguments from the
stack in order to inspect both the encrypted and decrypted messages.
Unfortunately we do not have a symbol table so we do not know where this
function is located in the program memory. Actually, we do not even have the
executable, the kernel is compressed and encrypted within the BIOS ROM.</p>
<p>Again, the emulator must be able to read it. The <a href="https://xboxdevwiki.net/Kernel">kernel wiki page</a>
mentions that the kernel base address is <code>0x8001_0000</code>.  It might then be ready
and loaded at that address already. If so, we can dump that region to a file
using GDB. We need an end address so we will go ahead with, say 1 MiB from the
base address:</p>
<pre><code>(gdb) dump binary memory xboxkrnl.exe <SPAN color="#d090b8">0x80010000</SPAN> <SPAN color="#d090b8">0x80110000</SPAN></code></pre>
<p>Oh, okay, I guess that is where it ends then, making it 180 KiB<a id="fnref3" href="#fn3" role="doc-noteref"><sup>3</sup></a>.</p>
<pre><code>(gdb) dump binary memory xboxkrnl.exe <SPAN color="#d090b8">0x80010000</SPAN> <SPAN color="#d090b8">0x8003d000</SPAN><br/></code></pre>
<p>We can now try to use e.g. <code>objdump</code> to see if it can recognize the executable
type and is able to find the exports:</p>
<pre><code><SPAN color="#b8bb26"><b>$</b></SPAN> objdump <SPAN color="#fe8019">-x</SPAN> xboxkrnl.exe</code></pre>
<p>It can indeed! The file format is detected as <a href="https://en.wikipedia.org/wiki/Portable_Executable">PE32</a>, which is an executable
format also used by Windows. The kernel has 364 exports, from ordinal 1 to 366
but with 7 and 11 missing. The <code>XcBlockCryptCBC</code> function has ordinal 349 so it
should be located at <code>0x8001_0000</code> + <code>0x0002_0c69</code> = <code>0x8003_0c69</code> in memory.
We can place a breakpoint at this address while the host has created a game and
the guest is searching:</p>
<pre><code>(gdb) <SPAN color="#fb4934">break</SPAN> *<SPAN color="#d090b8">0x80030c69</SPAN></code></pre>
<p>Examining the stack we can inspect the arguments:</p>
<pre><code>(gdb) <SPAN color="#fb4934">x</SPAN>/8xw <SPAN color="#83a5b8">$sp</SPAN></code></pre>
<p>The only value that can reasonably be the input length is the third (<code>0x20</code>),
so I assume that the first value is the return address pushed by the x86
<a href="https://www.felixcloutier.com/x86/call"><code>call</code></a> instruction and the arguments start from the second word, giving us
the following set of values for the arguments:</p>
<pre><code>dwCipher = <SPAN color="#d090b8">1</SPAN></code></pre>
<p>Since the length is only 32 bytes, this might be the initial broadcast message
from the guest and it is about to encrypt it. We can dump it to a file and read
it with hexdump directly from GDB:</p>
<pre><code>(gdb) dump binary memory out <SPAN color="#d090b8">0xd00086a8</SPAN> <SPAN color="#d090b8">0xd00086a8</SPAN>+<SPAN color="#d090b8">0x20</SPAN></code></pre>
<p>It contains no plain text data but it is clearly not encrypted or random data.
Let us continue and see if we can find the response:</p>
<pre><code>(gdb) <SPAN color="#fb4934">continue</SPAN></code></pre>
<pre><code>dwCipher = <SPAN color="#d090b8">1</SPAN></code></pre>
<p>Now, the <code>dwinputLength</code> is 304 bytes which means that this may be the response
from the host. The <code>dwOp</code> argument is set to 0 which might specify decryption
while 1 specifies encryption. We can run until we reach the return address and
dump the buffer after it has hopefully been decrypted:</p>
<pre><code>(gdb) <SPAN color="#fb4934">until</SPAN> *<SPAN color="#d090b8">0x001b3fb4</SPAN></code></pre>
<p>Oh, now we have some plain text data! The name of my Xbox “Howard” is there
(seemingly, in <a href="https://en.wikipedia.org/wiki/UCS-2">UCS-2</a> encoding). The message also seems to contain the file
path to the selected map and some odd “age in a bot” string?</p>
</section>
<section id="Decrypting-the-traffic">
<h2>Decrypting the traffic</h2>
<p>Now we could potentially just go ahead and try to analyze the messages using
GDB, but it is quite awkward and it also interferes with the gameplay as it
adds some delay. We will therefore do some more investigating to see if we can
find a way to decrypt the traffic from a separate program without affecting the
execution of the emulator.</p>
<p>We know that the encryption and decryption happens in the <code>XcBlockCryptCBC</code>
function. We are not entirely sure what kind of cipher is used, but from the
name we can guess that it is a <a href="https://en.wikipedia.org/wiki/Block_cipher">block cipher</a> with <a href="https://en.wikipedia.org/wiki/Cipher_block_chaining">cipher block
chaining</a> (CBC). The <code>Xc</code> kernel module also has a function by the name
<code>XcDESKeyParity</code>, so perhaps the <a href="https://en.wikipedia.org/wiki/Data_encryption_standard">DES</a> cipher with CBC is used. The
<code>keyTable</code> argument might be the subkeys used to decrypt each block.</p>
<p>DES uses an 8-byte key (56 key bits, 8 parity bits) and an <a href="https://en.wikipedia.org/wiki/Initialization_vector">initialization
vector</a> (IV) that matches the block size (8 bytes). There is also a successor
to DES called <a href="https://en.wikipedia.org/wiki/Triple_des">TripleDES</a> that instead takes three DES keys, i.e. a 24-byte
key.</p>
<p>We can see if we can find some higher level function that calls the
<code>XcBlockCryptCBC</code> function. We can break at the entry of <code>XcBlockCryptCBC</code>
again and look at the stack:</p>
<pre><code>(gdb) <SPAN color="#fb4934">break</SPAN> *<SPAN color="#d090b8">0x80030c69</SPAN></code></pre>
<p>Again, we have a return address as the last element in the stack, and it is the
same as last time: <code>0x001b3fb4</code>. The function was presumably entered by using
the <code>call</code> instruction which is 5 bytes long, so we can see if it lies just
above the return address:</p>
<pre><code>(gdb) <SPAN color="#fb4934">x</SPAN> /5i 0x001b3fb4-5</code></pre>
<p>It does, and it is calling a function located at <code>0x19345</code>. That function is
actually located in the game binary, rather than in the kernel. But at
<code>0x19345</code> is a jump to the kernel. The function that we see the instructions
for here ends right after calling <code>XcBlockCryptCBC</code>. We can check what the
whole function looks like:</p>
<pre><code>(gdb) (gdb) <SPAN color="#fb4934">x</SPAN> /31i 0x001b3fb4-80</code></pre>
<p>This function uses 6 arguments. From the call to <code>XcBlockCryptCBC</code> we can
immediately tell that</p>
<ul>
<li>
argument 5 is an in-place buffer used for both input and output,
</li>
<li>
argument 6 is the length of the buffer data,
</li>
<li>
argument 1 determines if it is an encryption (=1) or decryption (=0).
</li>
</ul>
<p>The earlier call is to <code>XcKeyTable</code> which might generate the subkeys from the
input key, i.e. key schedule. We can also check its signature from the
<code>xboxkrnl.h</code> header. It takes argument 2 for its <code>pbKey</code> argument which means
that</p>
<ul>
<li>
argument 2 is the encryption/decryption key.
</li>
</ul>
<p>Let us try to place a breakpoint at the function entry and look at the stack to
see what arguments it receives the next time we enter it:</p>
<pre><code>(gdb) <SPAN color="#fb4934">break</SPAN> *<SPAN color="#d090b8">0x1b3f64</SPAN></code></pre>
<p>The third argument seems to be a length, it is currently <code>0x18</code> = 24.
Interestingly, if the third argument is 8, <code>dwCipher</code> is set to 0, otherwise to
1. This might mean that</p>
<ul>
<li>
argument 3 is the key length,
</li>
</ul>
<p>and <code>dwCipher=0</code> specifies the DES cipher while <code>dwCipher=1</code> specifies the
TripleDES cipher.</p>
<p>That leaves us with only argument 4 remaining, which is used as the
<code>pwFeedback</code> argument to <code>XcBlockCryptCBC</code>. As mentioned earlier, DES also
takes an IV as input, so</p>
<ul>
<li>
argument 4 might be the IV.
</li>
</ul>
<p>We can try to write the values for each argument and check the buffer before
and after the function has executed using a GDB command:</p>
<pre><code><SPAN color="#b8bb26"><b>define cbc_crypt</b></SPAN></code></pre>
<p>Running it yields:</p>
<pre><code>(gdb) cbc_crypt</code></pre>
<p>We can use OpenSSL to verify if it is actually using TripleDES CBC. After some
trial and error, I managed to find a set of arguments that successfully
decrypts the message with the above key and IV:</p>
<pre><code><SPAN color="#b8bb26"><b>$</b></SPAN> openssl des-ede3-cbc <SPAN color="#fe8019">-d</SPAN> <SPAN color="#fe8019">-nopad</SPAN> <span><SPAN color="#bbbbbb">\</SPAN></span></code></pre>
<p>Now we can try to observe the arguments for the “cbc_crypt” function for more
packets, allowing us to make some observations:</p>
<ul>
<li>
The 24-byte key is always the same, it is <a href="https://en.wikipedia.org/wiki/Symmetric-key_algorithm">symmetric</a> and is used
for all broadcast messages.
</li>
<li>
After joining a game, two new 8-byte symmetric keys are used, one for
messages encrypted by the host and one for messages encrypted by the guest.
The same pair of keys are used until the game is closed or the guest leaves.
</li>
<li>
The crypt function is not entered for all packets, some packets are sent
without encryption.
</li>
<li>
The UDP payload of <em>encrypted</em> packets looks similar to an <a href="https://en.wikipedia.org/wiki/IPsec#Encapsulating_Security_Payload">IPSec ESP</a> in
transport mode. The payload seems to contain
<ul>
<li>
A 4-byte <a href="https://en.wikipedia.org/wiki/Security_Parameter_Index">Security Parameter Index (SPI)</a>. It is set to
<code>0xffff_ffff</code> for broadcasts, otherwise:
<ul>
<li>
1 byte indicating whether the packet is encrypted (=1) or not (=0),
</li>
<li>
2 bytes to identify the security association,
</li>
<li>
1 byte set to zero or one (unknown),
</li>
</ul>
</li>
<li>
a 4-byte sequence number, set to <code>0xffff_ffff</code> for broadcasts, incremented
once for each packet after a security association is established,
</li>
<li>
an 8-byte IV, used to decrypt the message,
</li>
<li>
an encrypted payload, containing
<ul>
<li>
an 8-byte UDP header OR a 20-byte TCP header,
</li>
<li>
a 2-byte value that is set to <code>(l &lt;&lt; 4) | 0xc</code> where <code>l</code> is the length of
the encrypted payload minus the transport layer header and padding.
</li>
<li>
1 byte always set to one.
</li>
<li>
a variable-length message,
</li>
<li>
a variable number of incrementing padding bytes,
</li>
<li>
1 byte specifying pad length,
</li>
<li>
1 byte specifying IP protocol (UDP or TCP),
</li>
</ul>
</li>
<li>
a 12-byte checksum or Integrity Check Value (ICV) of the packet.
</li>
</ul>
</li>
</ul>
<p>Typically, ESP is used directly on top of IP but, interestingly, they have
chosen to use it on top of UDP and then also use UDP or TCP packets inside the
encrypted packets.</p>
<p>A <a href="https://en.wikipedia.org/wiki/Pre-shared_key">pre-shared key</a> is used for broadcasts and first when joining, a type
of <a href="https://en.wikipedia.org/wiki/Security_association">security association</a> is established where the two instances agree on a
pair of keys to use for the remaining packets.</p>
<p>We can also confirm that the algorithm using 8-byte keys is DES, the below
openssl command successfully decrypts messages with a given key and IV:</p>
<pre><code><SPAN color="#b8bb26"><b>$</b></SPAN> openssl des-cbc <SPAN color="#fe8019">-provider</SPAN> legacy <SPAN color="#fe8019">-d</SPAN> <SPAN color="#fe8019">-nopad</SPAN> <span><SPAN color="#bbbbbb">\</SPAN></span></code></pre>
</section>
<section id="Key-derivation">
<h2>Key derivation</h2>
<p>The whole encryption stuff got me <em>intrigued</em> and I am now curious how it is
set up. If we investigate further, we might be able to create a program that
can read the packets without relying on an emulator or debugger to obtain the
keys.</p>
<p>In order to more easily understand what is going on, we will run two emulators
that connect to each other, each with a GDB instance attached to it. We will
also use tcpdump to record the packets to a file (.pcap). Each GDB instance
will run a command that sets up breakpoints at points of interest, such as when
entering a system call. Whenever a breakpoint is hit, it checks the PC to
determine which one was triggered, and then dumps internal state such as inputs
and outputs in a readable format. We can then see if any of the inputs or
outputs from the different system calls match each other or parts of the
packets and therefore follow the derivation of the keys. The workflow looks
like this:</p>
<ol>
<li>
Start two game instances, each with a separate GDB server.
</li>
<li>
Run a <a href="https://git.sr.ht/~nhellman/hllmn/tree/master/item/content/blog/2023-09-18_h1x-net/src/monitor.sh">script</a> that:
<ul>
<li>
connects a GDB client to each GDB server and loads a GDB
<a href="https://git.sr.ht/~nhellman/hllmn/tree/master/item/content/blog/2023-09-18_h1x-net/src/xboxkrnl.gdb">command</a>,
</li>
<li>
launches tcpdump to record packets to a file,
</li>
</ul>
</li>
<li>
Do something interesting, e.g. searching for or joining a game,
</li>
<li>
Inspect the traces of internal state and packet contents,
</li>
<li>
Update the GDB command with breakpoints or watchpoints at new locations of
interest,
</li>
<li>
Repeat from 2.
</li>
</ol>
<p>After some manual investigations like this we have mapped out how each client
derives the DES keys and where each piece of data comes from. The process for
each client looks something like this:</p>
<p><img alt="Derivation of the DES keys" src="https://jvns.ca/blog/2023/09/14/in-a-git-repository--where-do-your-files-live-/key.svg"/></p>
<p>The <code>XcHMAC</code> function is used extensively. It generates a typical <a href="https://en.wikipedia.org/wiki/HMAC">hash-based
message authentication code</a> using <a href="https://en.wikipedia.org/wiki/SHA-1">SHA-1</a>. It takes a 16-byte key, a
variable-length input and generates a 20-byte <a href="https://en.wikipedia.org/wiki/Message_authentication_code">message authentication
code</a>. We can replicate the implementation using e.g. OpenSSL’s SHA-1
implementation.</p>
<p>By reimplementing the system calls, most of the things in the derivation can
easily be replicated by a program of ours. Most inputs are just constants, and
some are from the packets. There is, however, one concerning source of data
here: a <a href="https://en.wikipedia.org/wiki/Pseudorandom_number_generator">pseudo-random number generator (PRNG)</a>. How could our program
possibly have a PRNG that generates the exact same number as the game instance?
Also, how can two game instances derive the same key with two different random
numbers as inputs?</p>
<p>Looking at the traces from the debugger, the two instances do indeed have
completely different exponent inputs. However, they also have different base
inputs, and they end up with the exact same output. The function in question is
the <code>XcModExp</code> function, which performs <a href="https://en.wikipedia.org/wiki/Modular_exponentiation">modular exponentiation</a>, i.e.
it calculates 
<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mrow><mi>a</mi><mo>=</mo><msup><mi>b</mi><mi>c</mi></msup><mspace width="0.22222222em"></mspace><mo>(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mspace width="0.22222222em"></mspace><mi>d</mi><mo>)</mo></mrow><annotation encoding="delim"> </annotation><annotation encoding="application/x-tex">$a = b^c \: (\mathrm{mod}\: d)$</annotation></semantics></math>.  In this case each value is a
768-bit integer (96 bytes) so brute forcing would take <em>a while</em>. The exponent
is random and the base is from one of the messages, i.e. it comes from the
other client. Looking further back in the trace we can see that the clients
first called <code>XcModExp</code> to generate one number each<a id="fnref4" href="#fn4" role="doc-noteref"><sup>4</sup></a>:</p>
<p>
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtable columnalign="left"><mtr><mtd><msub><mi>a</mi><mn>0</mn></msub><mo>=</mo><msup><msup><mn>2</mn><mn>88</mn></msup><msub><mi>c</mi><mn>0</mn></msub></msup><mspace width="0.22222222em"></mspace><mo>(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mspace width="0.22222222em"></mspace><mi>d</mi><mo>)</mo></mtd></mtr><mtr><mtd><msub><mi>a</mi><mn>1</mn></msub><mo>=</mo><msup><msup><mn>2</mn><mn>88</mn></msup><msub><mi>c</mi><mn>1</mn></msub></msup><mspace width="0.22222222em"></mspace><mo>(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mspace width="0.22222222em"></mspace><mi>d</mi><mo>)</mo></mtd></mtr></mtable></mrow><annotation encoding="delim"> </annotation><annotation encoding="application/x-tex">$
\begin{align}
a_0 = {2^88}^{c_0} \: (\mathrm{mod}\: d) \\
a_1 = {2^88}^{c_1} \: (\mathrm{mod}\: d)
\end{align}
$</annotation></semantics></math></p>
<p>where 
<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mrow><mi>d</mi></mrow><annotation encoding="delim"> </annotation><annotation encoding="application/x-tex">$d$</annotation></semantics></math> is a shared constant<a id="fnref5" href="#fn5" role="doc-noteref"><sup>5</sup></a> found in the game binary and 
<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mrow><msub><mi>c</mi><mn>0</mn></msub></mrow><annotation encoding="delim"> </annotation><annotation encoding="application/x-tex">$c_0$</annotation></semantics></math>,

<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mrow><msub><mi>c</mi><mn>1</mn></msub></mrow><annotation encoding="delim"> </annotation><annotation encoding="application/x-tex">$c_1$</annotation></semantics></math> are randomly generated numbers. The instances then share 
<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mrow><msub><mi>a</mi><mn>0</mn></msub></mrow><annotation encoding="delim"> </annotation><annotation encoding="application/x-tex">$a_0$</annotation></semantics></math> and

<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub></mrow><annotation encoding="delim"> </annotation><annotation encoding="application/x-tex">$a_1$</annotation></semantics></math> with each other in the handshake packet and then calculate</p>
<p>
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>e</mi><mo>=</mo><msup><msub><mi>a</mi><mn>1</mn></msub><msub><mi>c</mi><mn>0</mn></msub></msup><mspace width="0.22222222em"></mspace><mo>(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mspace width="0.22222222em"></mspace><mi>d</mi><mo>)</mo></mrow><annotation encoding="delim"> </annotation><annotation encoding="application/x-tex">$e = {a_1}^{c_0} \: (\mathrm{mod}\: d)$</annotation></semantics></math>
and

<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>e</mi><mo>=</mo><msup><msub><mi>a</mi><mn>0</mn></msub><msub><mi>c</mi><mn>1</mn></msub></msup><mspace width="0.22222222em"></mspace><mo>(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mspace width="0.22222222em"></mspace><mi>d</mi><mo>)</mo></mrow><annotation encoding="delim"> </annotation><annotation encoding="application/x-tex">$e = {a_0}^{c_1} \: (\mathrm{mod}\: d)$</annotation></semantics></math></p>
<p>respectively. Both end up with the same value 
<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mrow><mi>e</mi></mrow><annotation encoding="delim"> </annotation><annotation encoding="application/x-tex">$e$</annotation></semantics></math>, without ever knowing the
other instance’s 
<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mrow><mi>c</mi></mrow><annotation encoding="delim"> </annotation><annotation encoding="application/x-tex">$c$</annotation></semantics></math>-value. This is known as the <a href="https://en.wikipedia.org/wiki/Diffie_hellman">Diffie-Hellman key
exchange</a>. As a bystander, we only know 
<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mrow><msub><mi>a</mi><mn>0</mn></msub></mrow><annotation encoding="delim"> </annotation><annotation encoding="application/x-tex">$a_0$</annotation></semantics></math>, 
<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub></mrow><annotation encoding="delim"> </annotation><annotation encoding="application/x-tex">$a_1$</annotation></semantics></math> and

<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mrow><mi>d</mi></mrow><annotation encoding="delim"> </annotation><annotation encoding="application/x-tex">$d$</annotation></semantics></math>, without neither 
<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mrow><msub><mi>c</mi><mn>0</mn></msub></mrow><annotation encoding="delim"> </annotation><annotation encoding="application/x-tex">$c_0$</annotation></semantics></math> or 
<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mrow><msub><mi>c</mi><mn>1</mn></msub></mrow><annotation encoding="delim"> </annotation><annotation encoding="application/x-tex">$c_1$</annotation></semantics></math> it is very difficult for us to determine

<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mrow><mi>e</mi></mrow><annotation encoding="delim"> </annotation><annotation encoding="application/x-tex">$e$</annotation></semantics></math>. But for us to be able to derive the keys, we will have to <em>somehow</em>
determine 
<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mrow><mi>e</mi></mrow><annotation encoding="delim"> </annotation><annotation encoding="application/x-tex">$e$</annotation></semantics></math>.</p>
<p>Hmm… If we were to act as a client, we could easily mimic what the game does
and get another client to generate an 
<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mrow><mi>e</mi></mrow><annotation encoding="delim"> </annotation><annotation encoding="application/x-tex">$e$</annotation></semantics></math>-value together with us. If we can do
that with one of the clients, we should be able to do it with two clients
simultaneously. What if we could calculate an 
<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mrow><mi>e</mi></mrow><annotation encoding="delim"> </annotation><annotation encoding="application/x-tex">$e$</annotation></semantics></math>-value for two instances, and
then act as an intermediary between them… What if we could act as a…</p>
</section>
<section id="Man-in-the-middle">
<h2>Man in the middle</h2>
<p>It seems like it might be (practically) impossible for a listener to obtain the
keys used between two parties who have successfully established a security
association. However, it should be possible for us to create two security
associations, one with each party, and then simply shuffle the messages between
them by decrypting and re-encrypting each packet. It’s like playing chess with
two other players at the same time and just relaying their moves, effectively
making them play against each other. This can be considered a
<a href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack">man-in-the-middle (MITM) attack</a>. Performing such an attack would also
enable us to alter the packets without the clients knowing.</p>
<p>In order to perform the attack we will write a C program that reads and listens
to a network socket. We will be using a raw socket which picks up all packets,
regardless of the destination IP address<a id="fnref6" href="#fn6" role="doc-noteref"><sup>6</sup></a>. When running Linux, we can
achieve that by opening a socket with the <code>AF_PACKET</code> address family, the
<code>SOCK_RAW</code> socket type and the <code>ETH_P_ALL</code> protocol as described by
<a href="https://www.man7.org/linux/man-pages/man7/packet.7.html"><code>packet(7)</code></a>:</p>
<pre><code><SPAN color="#fabd2f">int</SPAN> sockfd = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL));</code></pre>
<p>We are now able to read packets from all interfaces using <a href="https://www.man7.org/linux/man-pages/man2/recv.2.html"><code>recv(2)</code></a> on the
socket:</p>
<pre><code><SPAN color="#fabd2f">uint8_t</SPAN> p[BUFSIZE];</code></pre>
<p>But in order to be able to send packets via the socket, we have to bind it to a
specific interface. We can look up the index of a specific interface using
<a href="https://www.man7.org/linux/man-pages/man2/ioctl.2.html"><code>ioctl(2)</code></a> and then bind it:</p>
<pre><code><SPAN color="#fe8019">struct</SPAN> ifreq ifr;</code></pre>
<p>We can now send packets over the interface using <a href="https://www.man7.org/linux/man-pages/man2/send.2.html"><code>send(2)</code></a>:</p>
<pre><code><SPAN color="#fabd2f">int</SPAN> send_len = send(sockfd, p, p_len, <SPAN color="#d090b8">0</SPAN>);</code></pre>
<p>As we saw previously, the searching guest client will send out a broadcast
packet to which all hosts with an active game will reply to. If we just copy a
broadcast message in full, and broadcast it ourselves, we receive replies from
the hosts as well. However, if we decrypt it, modify any byte and re-encrypt
it, we no longer receive a reply.</p>
<p>Recall that there was an ICV, i.e. a checksum of the packet contents that was
appended to the end of the packet. Can we alter the packet and simply
recalculate the ICV? I think we can. Looking at our trace from GDB, after a
packet has been encrypted and before it is sent over the network, a call to
<code>XcHMAC</code> is performed with the packet contents (starting from the UDP payload)
as the data and a constant value as the key. The first 12 bytes of the output
then matches the 12 last bytes of the packet as seen by tcpdump. We can simply
reuse that key and generate a new ICV after we have altered the packet.</p>
<p>Now we can try to decrypt the packet, alter some of the bytes, re-encrypt it
and append it with a correct ICV. Depending on what bytes we alter, we still
get a reply. After some experimentation with altering various parts in the
packets while inspecting the traces, the two broadcast packets seem to be
structured like this<a id="fnref7" href="#fn7" role="doc-noteref"><sup>7</sup></a>:</p>
<pre><code><SPAN color="#6b6c6d">/*</SPAN><SPAN color="#6b6c6d"> guest searching for games </SPAN><SPAN color="#6b6c6d">*/</SPAN></code></pre>
<p>Both packets start with a UDP header and end with a byte that specifies what
type of packet it is. This byte at least seems to be constant and unique to
each type of packet so we will use it as a packet type identifier, regardless
of its intended meaning.</p>
<p>At first, the guest initially sends a packet that specifies an ID for itself.
The host then replies with the same guest ID, and another ID for itself. It
also specifies some random data that is used in some HMAC calls on both sides
to generate the keys, as seen in the derivation diagram above. The host also
specifies its own MAC address so the guest knows where to send <a href="https://en.wikipedia.org/wiki/Unicast">unicast</a>
packets. Finally, the broadcast contains the game name and game options that we
are able to see on the screen when selecting a game to join.</p>
<p>Then, when the guest actually chooses to join a game, the guest client sends an
unencrypted handshake unicast packet to the host MAC address to which the host
immediately replies with a similar packet. The two handshake packets are
structured like this:</p>
<pre><code><SPAN color="#fe8019">struct</SPAN> handshake {</code></pre>
<p>The guest sends some randomly generated HMAC data which is used during the key
derivation, as seen in the above diagram. The <code>hmac_data1_host</code> field is just
filled with zeros. The guest also includes its 
<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mrow><msub><mi>a</mi><mn>0</mn></msub></mrow><annotation encoding="delim"> </annotation><annotation encoding="application/x-tex">$a_0$</annotation></semantics></math> value that will be used
as the base in the <code>XcModExp</code> call that we mentioned earlier. The guest also
resends the HMAC data it received from the host’s broadcast. It also includes
its MAC address so the host can send unicast packets to it.</p>
<p>The host then replies with a similar packet. But it writes its randomly
generated HMAC data to the <code>hmac_data1_host</code> field and provides its 
<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub></mrow><annotation encoding="delim"> </annotation><annotation encoding="application/x-tex">$a_1$</annotation></semantics></math>
value for <code>XcModExp</code>. Both clients now use the exchanged information to derive
a pair of DES keys that will be used for all encrypted packets from here
onwards.  Similarly, they will derive a pair of keys used for the ICV for the
remaining packets.</p>
<p>So, let us try to intercept this process. We want to make the clients think
that they are communicating with each other, while in reality they are both
talking directly to us and we are just passing the messages along (with some
small harmless alterations).</p>
<p>Since no essential information is only present in the broadcast from the guest,
we can just ignore that. But as soon as we see a broadcast reply from the host,
we will immediately copy that and broadcast it with some alterations.</p>
<p>We want the guest to send the handshake to us instead, so we will just
overwrite the <code>mac_src</code> field that contains the host MAC address with the
address of our own network interface. Now when we press join, the guest sends
the handshake packet to our address instead and the host simply ignores it and
does not respond with a handshake packet<a id="fnref8" href="#fn8" role="doc-noteref"><sup>8</sup></a>. The guest client
then displays an error message because we did not respond.</p>
<p>Next, we will simply take the handshake packet from the guest and resend it to
the host (we know the host MAC address from the <code>mac_src</code> field in its
broadcast that we intercepted). Because we do not know the secret 
<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mrow><msub><mi>c</mi><mn>0</mn></msub></mrow><annotation encoding="delim"> </annotation><annotation encoding="application/x-tex">$c_0$</annotation></semantics></math> value
of the guest, we will also have to modify the 
<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mrow><msub><mi>a</mi><mn>0</mn></msub></mrow><annotation encoding="delim"> </annotation><annotation encoding="application/x-tex">$a_0$</annotation></semantics></math> value before we pass it to
the host. Remember, the host will use it to calculate</p>
<p>
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>e</mi><mo>=</mo><msup><msub><mi>a</mi><mn>0</mn></msub><msub><mi>c</mi><mn>1</mn></msub></msup><mspace width="0.22222222em"></mspace><mo>(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mspace width="0.22222222em"></mspace><mi>d</mi><mo>)</mo><mo>.</mo></mrow><annotation encoding="delim"> </annotation><annotation encoding="application/x-tex">$e = {a_0}^{c_1} \: (\mathrm{mod}\: d).$</annotation></semantics></math></p>
<p>We need to select the value of 
<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mrow><msub><mi>a</mi><mn>0</mn></msub></mrow><annotation encoding="delim"> </annotation><annotation encoding="application/x-tex">$a_0$</annotation></semantics></math> such that we can know what value of <code>e</code>
the host will obtain. Any ideas? How about 
<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mrow><msub><mi>a</mi><mn>0</mn></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="delim"> </annotation><annotation encoding="application/x-tex">$a_0 = 1$</annotation></semantics></math>? Then we do not even need
to implement the <code>XcModExp</code> function because we can perform the 768-bit integer
calculation right here and now:</p>
<p>
<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>e</mi><mo>=</mo><msup><mn>1</mn><msub><mi>c</mi><mn>1</mn></msub></msup><mspace width="0.22222222em"></mspace><mo>(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mspace width="0.22222222em"></mspace><mi>d</mi><mo>)</mo><mo>=</mo><mn>1.</mn></mrow><annotation encoding="delim"> </annotation><annotation encoding="application/x-tex">$e = 1^{c_1} \: (\mathrm{mod}\: d) = 1.$</annotation></semantics></math></p>
<p>Easy! So if we provide 
<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mrow><msub><mi>a</mi><mn>0</mn></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="delim"> </annotation><annotation encoding="application/x-tex">$a_0=1$</annotation></semantics></math> to the host, we know it will get 
<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mrow><mi>e</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="delim"> </annotation><annotation encoding="application/x-tex">$e=1$</annotation></semantics></math>, so we
will also use that number for the key derivation.</p>
<p>Next, we will receive a reply from the host with a handshake packet. We now
have both the guest and host HMAC data so we are able to derive the DES and ICV
keys to be used for the remaining packets. We can then overwrite the host’s

<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub></mrow><annotation encoding="delim"> </annotation><annotation encoding="application/x-tex">$a_1$</annotation></semantics></math> value in the handshake packet with 1 as well, replace the MAC address
with ours and pass it along to the guest.</p>
<p>After that we are in, when joining the game, we successfully enter the game
through our MITM client! The attack can be summarized with the following
sequence diagram:</p>
<p><img alt="Sequence diagram of MITM attack" src="https://jvns.ca/blog/2023/09/14/in-a-git-repository--where-do-your-files-live-/mitm.svg"/></p>
<p>All remaining packets after the handshake can be passed through without any
modifications. Each packet is sent to our client, decrypted and re-encrypted
and then passed along to the other client using our derived keys. We no longer
need an emulator with a debugger attached to read messages. We are now able to
read and even alter packets sent between two completely unmodified consoles!</p>
</section>
<section id="The-game-network-protocol">
<h2>The game network protocol</h2>
<p>The time has come, we are now finally able and willing to do what we set out to
do in the first place, investigate the game network protocol!</p>
<p>After some experimenting with pushing various buttons and trying different
player counts while watching the packets in real-time, it seems like the
clients more or less just send the player inputs to each other. The input for
each player is contained in a 30-byte struct that looks like this:</p>
<pre><code><SPAN color="#fe8019">struct</SPAN> player {</code></pre>
<p>The <code>yaw</code> is set to the current direction that the player is facing, the
<code>pitch</code> is the current pitch<a id="fnref9" href="#fn9" role="doc-noteref"><sup>9</sup></a>. <code>forward</code> is the ground
acceleration in the forward direction, <code>left</code> for sideways ground acceleration
with left as positive. The <code>fire_duration</code> starts counting from 0 when pressing
fire and resets to zero when releasing, incrementing around 0.1 per second.</p>
<p><code>selected_weapon</code> is the index of the currently equipped weapon. Similarly for
<code>selected_grenade</code> but it is -1 when one has run out of grenades. <code>zoom</code> is -1
initially and becomes 0 for the first level of zoom and 1 for the second. These
represent the current state and will not change if you e.g. try to switch
grenades when you only have one type.</p>
<p>The <code>actions</code> field contains bits for at least 9 actions:</p>
<pre><code><SPAN color="#fe8019">enum</SPAN> action {</code></pre>
<p>Each bit is high as long as its corresponding button is held down, although the
<code>PICK_UP</code> only goes high after holding the “X” button for a short while. All of
the actions will go high when you press their corresponding button regardless
if the action can be performed or not. E.g. if you try to fire with no ammo,
the <code>FIRE</code> action will still be active.</p>
<p>These player structs are then placed in a continuous array, with one element
for each player. The guest sends one struct for each player that is local to
their console. The packet from the guest to the host is structured like this:</p>
<pre><code><SPAN color="#6b6c6d">/*</SPAN><SPAN color="#6b6c6d"> sent from each guest to the host once every tick </SPAN><SPAN color="#6b6c6d">*/</SPAN></code></pre>
<p>The guest packet also contains the index of the current tick and some unknown
data. It is not part of the struct definition here, but there is also a single
byte after the player array that is always set to <code>0x19</code><a id="fnref10" href="#fn10" role="doc-noteref"><sup>10</sup></a>.</p>
<p>The host replies with not just the player structs for all remaining players,
but <strong>it also resends the player structs of the guest that it replies to</strong>. The
packet is structured like this:</p>
<pre><code><SPAN color="#6b6c6d">/*</SPAN><SPAN color="#6b6c6d"> sent from the host to every guest once every tick </SPAN><SPAN color="#6b6c6d">*/</SPAN></code></pre>
<p>The host packet contains two tick counters that are usually the same but
sometimes go out of sync. They are typically 1 step ahead of the guest tick.
The <code>hash</code> value is sometimes the same for multiple ticks, and changes more
often when players are not idle. After the player array, there is one byte that
is always set to <code>0x14</code>.</p>
<p>The clients are more or less only sending inputs between each other, and are
then relying on each other to simulate the game identically. It seems like
there is a risk for the clients to go out of sync if any packets were to be
dropped or delayed. We can notice that when e.g. momentarily minimizing the
emulator, causing it to not reply in time, the game thereafter becomes
unplayable and eventually disconnects.</p>
</section>
<section id="Altering-in-game-packets">
<h2>Altering in-game packets</h2>
<p>So what would happen if we altered any of the game information sent between the
clients while playing? We can try to modify packets from the host at first,
e.g. make a host player walk left when firing:</p>
<pre><code><SPAN color="#fe8019">struct</SPAN> ingame_h2g *game = (<SPAN color="#fe8019">struct</SPAN> ingame_h2g *)msg;</code></pre>
<p>When the host and guest player are facing each other, and the host begins
shooting, the guest sees the host shooting and walking left for a second before
the screen changes to a full screen message:</p>
<blockquote>
<p>ATTENTION</p>
<p>Your Xbox console has gone out of sync with the other consoles in the game.
Resetting…</p>
<p>Press START to Continue</p>
</blockquote>
<p>Then the guest attempts to “reset”<a id="fnref11" href="#fn11" role="doc-noteref"><sup>11</sup></a> but disconnects shortly
thereafter. Interestingly, the clients did not just continue playing out of
sync, the guest client quickly detected<a id="fnref12" href="#fn12" role="doc-noteref"><sup>12</sup></a> that they were out of sync
and supposedly tried to reset.</p>
<p>What would happen if we instead modify the information from the guest to the
host? Remember, the host resends the player data that it receives to all guest
clients, <em>including the guest that it received it from</em>. Will the host use the
modified data and the guest use the original data, causing them to go out of
sync like we saw previously? Or will the guest check that the data is unchanged
and reject it immediately? Or will it just accept the received data and use
that instead of the data that it sent? We can try it out:</p>
<pre><code><SPAN color="#fe8019">struct</SPAN> ingame_g2h *game = (<SPAN color="#fe8019">struct</SPAN> ingame_g2h *)msg;</code></pre>
<p>If a player from a guest client is holding the flashlight button, we will
increase their speed before we send the packet off to the host. Let’s see what
happens when we run it and hold down the flashlight button as a guest player:</p>
<video controls="" src="speed.mp4"></video>

<p>We are able to run a lot faster than usual, even faster than a warthog jeep!
I was really hoping for that to work and I am quite surprised it actually did!
Heh, it is quite fun to fly around using the hills and valleys of Blood Gulch,
sort of reminds of <a href="https://en.wikipedia.org/wiki/Tribes_(video_game_series)">Tribes</a>. As you can see, it is very easy to kill oneself
from fall damage, though.</p>
<p>This must mean that the guest client sends its controls to the host and assumes
it gets back the same without actually checking it. The guest uses the response
as the actual truth, completely ignoring what it actually sent. We are also
lucky that the clients do not saturate the speed even though one can never run
faster than 1.0 units.</p>
<p>Some other things I tried with the client packets:</p>
<ul>
<li>
Changing the yaw or pitch causes the guest player camera to look one way and
fire in another direction.
</li>
<li>
Using a vehicle with increased speed: the warthog and scorpion seem to have
binary speed, either 0 or 1 and are not affected at all by a higher speed
value. The acceleration of the ghost <em>does</em> increase with a higher speed, but
going way too fast it immediately leans forward and flips over, forcing you
out of the vehicle.
</li>
<li>
Modifying the fire duration does not seem to have any effect.
</li>
<li>
Changing the selected grenade can prevent you from using grenades that you
have but cannot let you use ones that you do not have.
</li>
</ul>
<p>If you have a Linux machine and want to try it out yourself, the MITM client is
available <a href="https://git.sr.ht/~nhellman/hllmn/tree/master/item/content/blog/2023-09-18_h1x-net/src/mitm_h1.c">here</a>. Just compile it, make sure it is allowed to use
raw sockets, and specify <code>pal</code>/<code>ntsc</code> and a network interface when running:</p>
<pre><code><SPAN color="#b8bb26"><b>$</b></SPAN> cc <SPAN color="#fe8019">-lcrypto</SPAN> mitm_h1.c <SPAN color="#fe8019">-o</SPAN> mitm_h1</code></pre>
<p>You can also use <code>-DSNEAKY</code> when compiling to make it perform the attack
silently, e.g. if you want to get the to the rocket launcher first every time
at the next LAN party (people still have those, right?). Just be discrete with
the laptop that is connected to the network switch and has console text quickly
scrolling by. :&gt;</p>
</section>
<section id="Summary">
<h2>Summary</h2>
<p>We tried to simply read the messages between two consoles playing Halo, but
alas, we were immediately met by a stream of encrypted gibberish. By setting up
a game instance in an emulator and attaching GDB to it we were able to peek at
the contents of the secret messages that were sent between the instances. We
also figured out that the game uses DES and TripleDES encryption and were able
to decrypt the packets by peeking at the keys using GDB.</p>
<p>Investigating further, we determined how the instances derive the keys and
establish a security association during their initial handshake. By intervening
in that process, we were able to perform a <em>man-in-the-middle</em> attack, allowing
us to read and <em>alter</em> any packets that were sent between two consoles.</p>
<p>Then, we finally took a look at the packets that were sent while playing. After
figuring out their contents we were able to alter the packets from a guest
client and implement a “speedhack” from a remote device for a game played by
two <em>unmodified consoles</em>, using only a computer connected via a network
switch.</p>
<p>The authentication primitives are part of the Xbox kernel and are potentially
common for all System Link games. The method demonstrated here should be
possible to replicate in order to perform similar attacks for other Xbox games,
potentially enabling other more interesting hacks. For example, would it not be
cool if there was a game with a <a href="https://en.wikipedia.org/wiki/Stack_buffer_overflow">stack buffer overflow</a> bug that
allowed us to <a href="https://en.wikipedia.org/wiki/Arbitrary_code_execution">run arbitrary code</a> remotely?  That could potentially
enable us to <a href="https://en.wikipedia.org/wiki/Softmod">softmod</a> an Xbox over the network, without the need of any
special hardware<a id="fnref13" href="#fn13" role="doc-noteref"><sup>13</sup></a>.</p>
</section>
</section></div>
  </body>
</html>
