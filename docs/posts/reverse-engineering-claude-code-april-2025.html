<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://kirshatrov.com/posts/claude-code-internals">Original</a>
    <h1>Reverse engineering Claude Code (April 2025)</h1>
    
    <div id="readability-page-1" class="page"><div><p>I’ve been curious about what happens inside <a href="https://docs.anthropic.com/en/docs/agents-and-tools/claude-code/overview" target="_blank">Claude Code</a> so I’ve spent a couple hours digging through prompts that it sends back to Anthropic.</p>
<p>As I’ve been going through that, I’ve gathered some insights why Claude Code is often slower and more expensive than other tools like Cursor.</p>
<h2>Capturing prompts</h2>
<p>It turned out a lot easier than I thought, thanks to <a href="https://mitmproxy.org/" target="_blank">mitmproxy</a>:</p>
<pre><pre><code><span>$ brew install mitmproxy
</span>$ mitmweb --mode reverse:https://api.anthropic.com --listen-port 8000
<!-- -->$ ANTHROPIC_BASE_URL=http://localhost:8000/ claude
</code></pre></pre>
<h2>Getting started</h2>
<p>I opened a <a href="https://github.com/kirs/kirshatrov-com" target="_blank">repo</a> with my personal blog and entered “describe what’s in this project”.</p>
<p>The very first thing you see is that Claude Code tries to figure out whether what you have entered is a continuation of the previous conversation or a new topic.</p>
<pre><pre><code><span>Analyze if this message indicates a new conversation topic.
</span>If it does, extract a 2-3 word title that captures the new topic.
<!-- -->Format your response as a JSON object with two fields: &#39;isNewTopic&#39; (boolean) and &#39;title&#39; (string, or null if isNewTopic is false). Only include these fields, no other text.
</code></pre></pre>
<p>Once it determines that, it wraps all your inputs into this system prompt:</p>
<pre><pre><code><span>You are an agent for Claude Code, Anthropic&#39;s official CLI for Claude. Given the user&#39;s prompt, you should use the tools available to you to answer the user&#39;s question.
</span>
<!-- -->Notes:
<!-- -->1. IMPORTANT: You should be concise, direct, and to the point, since your responses will be displayed on a command line interface. Answer the user&#39;s question directly, without elaboration, explanation, or details. One word answers are best. Avoid introductions, conclusions, and explanations. You MUST avoid text before/after your response, such as \&#34;The answer is &lt;answer&gt;.\&#34;, \&#34;Here is the content of the file...\&#34; or \&#34;Based on the information provided, the answer is...\&#34; or \&#34;Here is what I will do next...\&#34;.
<!-- -->2. When relevant, share file names and code snippets relevant to the query
<!-- -->3. Any file paths you return in your final response MUST be absolute. DO NOT use relative paths.
<!-- -->Here is useful information about the environment you are running in:
<!-- -->&lt;env&gt;
<!-- -->Working directory: /Users/kir/src/github.com/kirs/kirshatrov-com
<!-- -->Is directory a git repo: Yes
<!-- -->Platform: macos
<!-- -->Today&#39;s date: 2025-04-13
<!-- -->Model: claude-3-7-sonnet-20250219
<!-- -->&lt;/env&gt;
<!-- -->
<!-- -->As you answer the user&#39;s questions, you can use the following context:
<!-- -->
<!-- -->&lt;context name=&#34;directoryStructure&#34;&gt;Below is a snapshot of this project&#39;s file structure at the start of the conversation. This snapshot will NOT update during the conversation. It skips over .gitignore patterns.
<!-- -->
<!-- -->- /Users/kir/src/github.com/kirs/kirshatrov-com/
<!-- -->  - README.md
<!-- -->  - _posts/
<!-- -->    - 2015-03-02-capistrano-unicorn-bundler.markdown
<!-- -->    - 2015-04-07-rails-5.markdown
<!-- --> ....
<!-- -->    - 2024-12-14-facebook-mysql-fork.md
<!-- -->  - bin/
<!-- -->...
<!-- -->&lt;/context&gt;
<!-- -->&lt;context name=&#34;gitStatus&#34;&gt;This is the git status at the start of the conversation. Note that this status is a snapshot in time, and will not update during the conversation.
<!-- -->Current branch: master
<!-- -->
<!-- -->Main branch (you will usually use this for PRs): master
<!-- -->
<!-- -->Status:
<!-- -->M .gitignore
<!-- --> D .ruby-version
<!-- --> M package-lock.json
<!-- -->?? playground/
<!-- -->
<!-- -->Recent commits:
<!-- -->58ce3f9 m4 --force
<!-- -->3b1052a correction
<!-- -->82fe70a fix stuff
<!-- -->cfd73d9 follow-up
<!-- -->&lt;/context&gt;
</code></pre></pre>
<p>It’s nice that the state of git is included into the context.
You can also notice that the context includes full tree directory view which can get somewhat big.</p>
<p>Part of this system prompt is a list of 11 tools that are available for the LLM to call:</p>
<pre><pre><code><span>dispatch_agent
</span>Launch a new agent that has access to the following tools: View, GlobTool, GrepTool, LS, ReadNotebook, WebFetchTool. When you are searching for a keyword or file and are not confident that you will find the right match in the first few tries, use the Agent tool to perform the search for you.
<!-- -->
<!-- -->Bash
<!-- -->Executes a given bash command in a persistent shell session with optional timeout, ensuring proper handling and security measures. Includes specialized functionality for git operations like commits and pull requests.
<!-- -->
<!-- -->BatchTool
<!-- -->Batch execution tool that runs multiple tool invocations in a single request. Tools are executed in parallel when possible, and otherwise serially. Takes a list of tool invocations (tool_name and input pairs) and returns the collected results from all invocations.
<!-- -->
<!-- -->GlobTool
<!-- -->Fast file pattern matching tool that works with any codebase size. Supports glob patterns like &#34;/*.js&#34; or &#34;src//*.ts&#34;. Returns matching file paths sorted by modification time.
<!-- -->GrepTool
<!-- -->Fast content search tool that works with any codebase size. Searches file contents using regular expressions. Supports full regex syntax and filters files by pattern with the include parameter.
<!-- -->
<!-- -->LS
<!-- -->Lists files and directories in a given path. The path parameter must be an absolute path, not a relative path. You can optionally provide an array of glob patterns to ignore.
<!-- -->
<!-- -->View
<!-- -->Reads a file from the local filesystem. The file_path parameter must be an absolute path. By default, reads up to 2000 lines starting from the beginning of the file.
<!-- -->
<!-- -->Edit
<!-- -->Tool for editing files. For moving or renaming files, use the Bash tool with the &#39;mv&#39; command instead. For larger edits, use the Write tool to overwrite files.
<!-- -->
<!-- -->Replace
<!-- -->Write a file to the local filesystem. Overwrites the existing file if there is one.
<!-- -->
<!-- -->ReadNotebook
<!-- -->Reads a Jupyter notebook (.ipynb file) and returns all of the cells with their outputs.
<!-- -->
<!-- -->NotebookEditCell
<!-- -->Completely replaces the contents of a specific cell in a Jupyter notebook (.ipynb file) with new source.
<!-- -->
<!-- -->WebFetchTool
<!-- -->Fetches content from a specified URL and processes it using an AI model. Takes a URL and a prompt as input, fetches the URL content, converts HTML to markdown, and processes the content.
</code></pre></pre>
<p>My original input (<code>“describe what’s in this project”</code>) then gets transformed into the <code>dispatch_agent</code> tool call with this instruction:</p>
<pre><pre><code><span>Analyze the repository structure and determine what kind of project this is.
</span>Look at the file structure, package.json, and any configuration files to understand the tech stack,
<!-- -->then provide a concise summary of what this project appears to be.
</code></pre></pre>
<p>This is then transformed into a few <code>view</code> tool calls for those files:</p>
<ul>
<li><code>README.md</code></li>
<li><code>package.json</code></li>
<li><code>pages/index.js</code></li>
<li><code>pages/post.js</code></li>
<li><code>pages/travels.js</code></li>
</ul>
<p>The result of feeding those files back to an LLM makes it into the following summary:</p>
<pre><pre><code><span>This is Kir Shatrov&#39;s personal website/blog built with Next.js, React, and Tailwind CSS. It includes:
</span>
<!-- -->- Blog posts on tech topics (Ruby/Rails, databases, engineering leadership)  
<!-- -->- Photography gallery  
<!-- -->- Travel map/history  
<!-- -->- Speaking engagements  
<!-- -->- Fabrication projects (woodworking/making)  
<!-- -->
<!-- -->The site uses markdown for blog content with posts dating back to 2015, following standard Next.js project structure.
</code></pre></pre>
<p>The above took 40 seconds of LLM time and cost me $0.11.</p>
<p><img width="896" height="242" src="https://kirshatrov.com/assets/post-images/2025/claude-describe.png"/></p><h2>Writing new code</h2>
<p>My next test input was:</p>
<pre><pre><code><span>Please write a bash script which displays the top story on Hacker News.
</span>It should show the title, the link, and the number of points.
</code></pre></pre>
<p>That spawned an agent use that has attempted to read <code>https://github.com/HackerNews/API</code>. But Claude’s self-limiting security policy has stopped that:</p>
<pre><pre><code><span>Error: Cannot fetch URL &#34;https://github.com/HackerNews/API&#34;. For security, you can only fetch URLs from hosts that the user has mentioned in their messages or that are found in CLAUDE.md files or project files.
</span></code></pre></pre>
<p>Then it tried to read <code>https://hackernews.api-docs.io</code> and run into the same error.</p>
<p>Then it tried to read <code>https://firebase.google.com/docs/database</code> and the same thing happened.</p>
<p>It then changed the strategy and outputted this:</p>
<pre><pre><code><span>I apologize for the limitations in accessing external URLs. Due to security restrictions, I can only fetch URLs that have been mentioned by you or are in project files.
</span>
<!-- -->The Hacker News API is hosted by Firebase and provides several endpoints, including:
<!-- -->
<!-- -->- `https://hacker-news.firebaseio.com/v0/topstories.json` - Returns IDs of top stories
<!-- -->- `https://hacker-news.firebaseio.com/v0/item/{id}.json` - Returns details of a specific item
<!-- -->
<!-- -->To create a bash script to fetch the top story, you would:
<!-- -->1. Fetch the array of top story IDs
<!-- -->2. Get the first ID from that array
<!-- -->3. Fetch the details for that ID
<!-- -->
<!-- -->Here&#39;s a basic bash script example:
<!-- -->
<!-- -->#!/bin/bash
<!-- -->...
<!-- -->
</code></pre></pre>
<p>What’s interesting is that none of that got saved or executed. So I’ve typed <code>save that and execute</code>.</p>
<p>Now, remember this prompt from the beginning?</p>
<pre><pre><code><span>Analyze if this message indicates a new conversation topic.
</span>If it does, extract a 2-3 word title that captures the new topic.
<!-- -->Format your response as a JSON object with two fields: &#39;isNewTopic&#39; (boolean) and &#39;title&#39; (string, or null if isNewTopic is false). Only include these fields, no other text.
</code></pre></pre>
<p>Like any other input, my <code>save that and execute</code> command had to be run through determining whether it&#39;s a new topic or not.</p>
<p>Saving the file involved two tool usage calls:</p>
<ul>
<li><code>Replace</code> to write the file</li>
<li><code>Bash</code> with <code>chmod +x hn_top.sh &amp;&amp; hn_top.sh</code></li>
</ul>
<p>Now comes the fun part. Any <code>Bash</code> tool use is preceded by this this prompt:</p>
<pre><pre><code><span>&lt;policy_spec&gt;
</span># Claude Code Code Bash command prefix detection
<!-- -->
<!-- -->This document defines risk levels for actions that the Claude Code agent may take. This classification system is part of a broader safety framework and is used to determine when additional user confirmation or oversight may be needed.
<!-- -->
<!-- -->## Definitions
<!-- -->
<!-- -->**Command Injection:** Any technique used that would result in a command being run other than the detected prefix.
<!-- -->
<!-- -->## Command prefix extraction examples
<!-- -->Examples:
<!-- -->- cat foo.txt =&gt; cat
<!-- -->- cd src =&gt; cd
<!-- -->- cd path/to/files/ =&gt; cd
<!-- -->- find ./src -type f -name \&#34;*.ts\&#34; =&gt; find
<!-- -->- gg cat foo.py =&gt; gg cat
<!-- -->- gg cp foo.py bar.py =&gt; gg cp
<!-- -->- git commit -m \&#34;foo\&#34; =&gt; git commit
<!-- -->- git diff HEAD~1 =&gt; git diff
<!-- -->- git diff --staged =&gt; git diff
<!-- -->- git diff $(pwd) =&gt; command_injection_detected
<!-- -->- git status =&gt; git status
<!-- -->- git status# test(`id`) =&gt; command_injection_detected
<!-- -->- git status`ls` =&gt; command_injection_detected
<!-- -->- git push =&gt; none
<!-- -->- git push origin master =&gt; git push
<!-- -->- git log -n 5 =&gt; git log
<!-- -->- git log --oneline -n 5 =&gt; git log
<!-- -->- grep -A 40 \&#34;from foo.bar.baz import\&#34; alpha/beta/gamma.py =&gt; grep
<!-- -->- pig tail zerba.log =&gt; pig tail
<!-- -->- potion test some/specific/file.ts =&gt; potion test
<!-- -->- npm run lint =&gt; none
<!-- -->- npm run lint -- \&#34;foo\&#34; =&gt; npm run lint
<!-- -->- npm test =&gt; none
<!-- -->- npm test --foo =&gt; npm test
<!-- -->- npm test -- -f \&#34;foo\&#34; =&gt; npm test
<!-- -->- pwd
<!-- --> curl example.com =&gt; command_injection_detected
<!-- -->- pytest foo/bar.py =&gt; pytest
<!-- -->- scalac build =&gt; none
<!-- -->- sleep 3 =&gt; sleep
<!-- -->&lt;/policy_spec&gt;
<!-- -->
<!-- -->The user has allowed certain command prefixes to be run, and will otherwise be asked to approve or deny the command.
<!-- -->Your task is to determine the command prefix for the following command.
<!-- -->
<!-- -->IMPORTANT: Bash commands may run multiple commands that are chained together.
<!-- -->For safety, if the command seems to contain command injection, you must return \&#34;command_injection_detected\&#34;. 
<!-- -->(This will help protect the user: if they think that they&#39;re allowlisting command A, 
<!-- -->but the AI coding agent sends a malicious command that technically has the same prefix as command A, 
<!-- -->then the safety system will see that you said “command_injection_detected” and ask the user for manual confirmation.)
<!-- -->
<!-- -->Note that not every command has a prefix. If a command has no prefix, return \&#34;none\&#34;.
<!-- -->
<!-- -->ONLY return the prefix. Do not return any other text, markdown markers, or other content or formatting.
<!-- -->
<!-- -->Command: chmod +x hn_top.sh
</code></pre></pre>
<p>Once the security is assessed, it will try to grab the actual commands to let users make them always allowed to run</p>
<pre><pre><code><span>Extract any file paths that this command reads or modifies. For commands like &#34;git diff&#34; and &#34;cat&#34;, include the paths of files being shown. Use paths verbatim -- don&#39;t add any slashes or try to resolve them. Do not try to infer paths that were not explicitly listed in the command output.
</span>Format your response as:
<!-- -->&lt;filepaths&gt;
<!-- -->path/to/file1
<!-- -->path/to/file2
<!-- -->&lt;/filepaths&gt;
<!-- -->
<!-- -->If no files are read or modified, return empty filepaths tags: &lt;filepaths&gt;&lt;/filepaths&gt;
<!-- -->Do not include any other text in your response.
</code></pre></pre>
<p>Which renders the following UX bit:</p>
<p><img width="896" height="226" src="https://kirshatrov.com/assets/post-images/2025/claude-bash.png"/></p><p>You can imagine that having to call an LLM at most twice for every <code>Bash</code> tool use makes things somewhat slower.</p>
<h2>/init</h2>
<p>Claude Code provides <code>/init</code> command which creates <code>CLAUDE.md</code> with generated contents about your project. Below is the prompt for that.</p>
<pre><pre><code><span>Please analyze this codebase and create a CLAUDE.md file containing:
</span>1. Build/lint/test commands - especially for running a single test
<!-- -->2. Code style guidelines including imports, formatting, types, naming conventions, error handling, etc.
<!-- -->
<!-- -->Usage notes:
<!-- -->- The file you create will be given to agentic coding agents (such as yourself) that operate in this repository. Make it about 20 lines long.\
<!-- -->- If there&#39;s already a CLAUDE.md, improve it.\
<!-- -->- If there are Cursor rules (in .cursor/rules/ or .cursorrules) or Copilot rules (in .github/copilot-instructions.md), make sure to include them.\
<!-- -->- Be sure to prefix the file with the following text:
<!-- -->
<!-- --># CLAUDE.md
<!-- -->
<!-- -->This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.
</code></pre></pre>
<p>The prompt launches a <code>BatchTool</code> agent with a few more tool calls to collect more files — based on that context prompt that hints it the directory tree:</p>
<pre><pre><code><span>{
</span><span>  </span><span>&#34;type&#34;</span><span>: </span><span>&#34;tool_use&#34;</span><span>,
</span><span>  </span><span>&#34;id&#34;</span><span>: </span><span>&#34;toolu_01GmZ4d81pGHKaqryDEuZQNm&#34;</span><span>,
</span><span>  </span><span>&#34;name&#34;</span><span>: </span><span>&#34;BatchTool&#34;</span><span>,
</span><span>  </span><span>&#34;input&#34;</span><span>: {
</span><span>    </span><span>&#34;description&#34;</span><span>: </span><span>&#34;Gather repository information&#34;</span><span>,
</span><span>    </span><span>&#34;invocations&#34;</span><span>: [
</span>      {
<span>        </span><span>&#34;tool_name&#34;</span><span>: </span><span>&#34;GlobTool&#34;</span><span>,
</span><span>        </span><span>&#34;input&#34;</span><span>: {
</span><span>            </span><span>&#34;pattern&#34;</span><span>: </span><span>&#34;package*.json&#34;</span><span>
</span>        }
<!-- -->      },
<!-- -->      {
<span>        </span><span>&#34;tool_name&#34;</span><span>: </span><span>&#34;GlobTool&#34;</span><span>,
</span><span>        </span><span>&#34;input&#34;</span><span>: {
</span><span>            </span><span>&#34;pattern&#34;</span><span>: </span><span>&#34;*.md&#34;</span><span>
</span>        }
<!-- -->      },
<!-- -->      {
<span>        </span><span>&#34;tool_name&#34;</span><span>: </span><span>&#34;GlobTool&#34;</span><span>,
</span><span>        </span><span>&#34;input&#34;</span><span>: {
</span><span>            </span><span>&#34;pattern&#34;</span><span>: </span><span>&#34;.cursor/rules/**&#34;</span><span>
</span>        }
<!-- -->      },
<!-- -->      {
<span>        </span><span>&#34;tool_name&#34;</span><span>: </span><span>&#34;GlobTool&#34;</span><span>,
</span><span>        </span><span>&#34;input&#34;</span><span>: {
</span><span>            </span><span>&#34;pattern&#34;</span><span>: </span><span>&#34;.cursorrules/**&#34;</span><span>
</span>        }
<!-- -->      },
<!-- -->      {
<span>        </span><span>&#34;tool_name&#34;</span><span>: </span><span>&#34;GlobTool&#34;</span><span>,
</span><span>        </span><span>&#34;input&#34;</span><span>: {
</span><span>            </span><span>&#34;pattern&#34;</span><span>: </span><span>&#34;.github/copilot-instructions.md&#34;</span><span>
</span>        }
<!-- -->      }
<!-- -->    ]
<!-- -->  }
<!-- -->}
</code></pre></pre>
<h2>Wrap up</h2>
<p>Overall, Claude Code tends to be more generic and secure for the price of extra time and money billed on more tokens.</p>
<p>This is very much unlike Cursor which would never attempt to analyze suggested bash tools. And I would have most often prefer that Claude Code&#39;s approach.</p>
<p>I&#39;ve also noticed that it uses <code>claude-3-7-sonnet</code> for most things that require reasoning, and <code>claude-3-5-haiku</code> for simpler calls like parsing Bash commands. But still, <code>claude-3.5</code> can be quite an overkill for those and <code>gpt-3.5-turbo</code> would do that 10x cheaper ($1.5 vs $15 per 1M output tokens).</p>
<p>Still, in terms of UX, Claude Code is the winner for an agentic tool that runs in console. <a href="https://github.com/Aider-AI/aider" target="_blank">Aider</a> is close, but not nearly there in terms of reliability and UX. While Claude Code is a single NPM package (still requires a modern-ish version of Node which likely requires NVM installed), Aider&#39;s installation process self-installed <code>uv</code> on my machine just because it needed it. And <a href="https://github.com/All-Hands-AI/OpenHands" target="_blank">OpenHands</a> had to download ~10Gb of Docker images.</p></div></div>
  </body>
</html>
