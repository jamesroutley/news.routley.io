<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://den.dev/blog/reverse-engineer-stream-deck-plus/">Original</a>
    <h1>Reverse Engineering the Stream Deck&#43;</h1>
    
    <div id="readability-page-1" class="page"><article>
    <header>
      
        <ol>
  
  
    
  
    
  
  <li>
    <a href="https://todaythings.substack.com/">Den Delimarsky üîê</a><span>/</span>
  </li>

  
  <li>
    <a href="https://todaythings.substack.com/blog/">Writing</a><span>/</span>
  </li>

  
  <li>
    <a href="https://todaythings.substack.com/blog/reverse-engineer-stream-deck-plus/">Reverse Engineering The Stream Deck Plus</a><span>/</span>
  </li>

</ol>


      
      
      <div>
        





  
  



  

  
  
    
  

  

  
    
  

  

  

  <p><time datetime="2024-12-26 00:00:00 +0000 UTC">December 26, 2024</time><span>¬∑</span><span>6495 words</span>
    

    
    
  </p>

  
  
    
  


      </div>
      
    </header>
    <section>
      
        
      
      <div>
        <p>Close to 4 years ago I <a href="https://todaythings.substack.com/blog/reverse-engineering-stream-deck/">talked about reverse engineering the Stream Deck</a> to gain full control of the device and remove the dependence on the Stream Deck software. Well, I still really enjoy the hardware, but the software has gotten worse - it now goes as far as to <em>requiring users for an account</em> to download extensions.</p>

  
  
  
  
  
  <figure>
    
    <img alt="You now need to create and log in with an account to install Stream Deck software extensions." src="https://assets.den.dev/images/postmedia/reverse-engineer-stream-deck-plus/software-marketplace.webp"/>
    
    <figcaption>You now need to create and log in with an account to install Stream Deck software extensions.</figcaption>
  </figure>


<p>If we‚Äôve interacted in the past, I am big on respecting customer privacy and choices, and that means - if I want to use a device without an account, I better be damn able to do that. Luckily, building on my past work with <a href="https://deck.surf/" target="_blank" rel="noreferrer noopener">DeckSurf</a>, I finally was determined to push the pedal to the metal and make my project a viable alternative to proprietary software for this extremely versatile and flexible button box.</p>
<p>This post is going to be looking at the workings of the <a href="https://www.elgato.com/us/en/p/stream-deck-plus-black" target="_blank" rel="noreferrer noopener">Stream Deck Plus</a>, a $179.99 (discounted by $20 at the time of this writing) and how you, dear reader, can use it even if you don‚Äôt want to install Elgato‚Äôs own software.</p>
<h2 id="what-are-we-working-with">What are we working with <span><a href="#what-are-we-working-with" aria-label="Anchor">#</a></span></h2>
<p>Here is the device we‚Äôll be talking about:</p>

  
  
  
  
  
  <figure>
    
    <img alt="A Stream Deck Plus on a desk." src="https://assets.den.dev/images/postmedia/reverse-engineer-stream-deck-plus/sdp.webp"/>
    
    <figcaption>A Stream Deck Plus on a desk.</figcaption>
  </figure>


<p>Stream Deck Plus sports a few capabilities that I should outline before I go more in-depth about the actual reverse-engineering process:</p>
<ol>
<li><strong>8 buttons</strong>. This is effectively the same as with all the other Stream Deck products. Numbers vary, but the behavior is consistent.</li>
<li><strong>A narrow screen</strong>. Right below the buttons is a narrow color screen band that can be used to provide auxiliary contextual information.</li>
<li><strong>4 dials</strong>. Each dial can turn right or left an unlimited number of times. They can also be pressed down (click).</li>
</ol>
<p>We‚Äôre going to dive into each of the features and how they work. I will also mention that to actually reverse-engineer this device, I used the following tooling:</p>
<ul>
<li><a href="https://www.wireshark.org/" target="_blank" rel="noreferrer noopener">Wireshark</a> with <a href="https://desowin.org/usbpcap/" target="_blank" rel="noreferrer noopener">USBPcap</a>.</li>
<li>A virtual machine where Stream Deck Plus is the only USB device connected.</li>
<li><a href="https://help.elgato.com/hc/en-us/sections/5162671529357-Elgato-Stream-Deck-Software-Release-Notes" target="_blank" rel="noreferrer noopener">Stream Deck software</a>, to inspect the traffic it sends over the wire.</li>
</ul>
<p>The way Stream Deck is built, it‚Äôs a generic HID device and it does not require you to have Stream Deck software installed to function. That is, once I reverse-engineer the protocol for the hardware, I can build my own client software that does whatever I want and doesn‚Äôt depend in any capacity on Elgato‚Äôs software stack.</p>
<h2 id="setting-up-the-inspection-process">Setting up the inspection process <span><a href="#setting-up-the-inspection-process" aria-label="Anchor">#</a></span></h2>
<p>To get started, let‚Äôs launch Wireshark and select a USB capture interface.</p>

  
  
  
  
  
  <figure>
    
    <img alt="Selecting a USB interface in Wireshark." src="https://assets.den.dev/images/postmedia/reverse-engineer-stream-deck-plus/wireshark-capture.webp"/>
    
    <figcaption>Selecting a USB interface in Wireshark.</figcaption>
  </figure>


<p>Depending on your machine configuration, you may have more than one interface available. You might need to try opening a few until you‚Äôre able to spot the connected Stream Deck.</p>
<p>To <em>find</em> the Stream Deck Plus device in my case, I can filter by the product ID (PID), that is <code>0x0084</code> (the Elgato VID, shall you need it, is <code>0x0FD9</code>). Narrowing down the traffic to just the connected Stream Deck Plus device can be done by applying the following filter string:</p>
<p>And just like that, the Stream Deck lights up in the list (in the likely <em>sea</em> of other USB traffic):</p>

  
  
  
  
  
  <figure>
    
    <img alt="Spotting the Stream Deck Plus in Wireshark." src="https://assets.den.dev/images/postmedia/reverse-engineer-stream-deck-plus/stream-deck-plus-wireshark.webp"/>
    
    <figcaption>Spotting the Stream Deck Plus in Wireshark.</figcaption>
  </figure>


<p>Based on the above, the source I need to look for is <code>3.5.0</code>. That value is also the <em>destination</em> - the ‚Äúaddress‚Äù of the device that we can use to inspect outbound traffic that actually sets things like brightness or images on the different surfaces available on the Stream Deck.</p>
<p>With this data at hand, I can now set up the filter string like this:</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span>usb.dst matches <span>&#34;3\\.5\\..*&#34;</span>
</span></span></code></pre></div><div>
  <p><img src="https://assets.den.dev/images/shared/thinking.gif" alt="Mole out of the ground, thinking."/>
  </p>
  <p>Hold on a second... You said that the address is <code>3.5.0</code> above, but in your second filter string it looks like you&#39;re matching to <i>everything</i> that follows the <code>3.5.</code> pattern. Why is that?</p>
</div>
<p>Aha! Keen eye. Indeed, I am not filtering just by <code>3.5.0</code>. The USB address is made of three components - the <strong>bus</strong>, <strong>device</strong>, and <strong>endpoint</strong>. In our case, the Stream Deck Plus is operating as <strong>bus 3</strong>, <strong>device 5</strong>, and <strong>endpoint 0</strong>, but what we also need to know is that a single device can have multiple endpoints. So for us to properly look at <em>all</em> Stream Deck Plus device traffic, we exclude the endpoint identifier.</p>
<p>We can also simplify the filter string like this:</p>
<p>This is a bit cleaner and you don‚Äôt need to worry about RegEx-ing a relatively constraint.</p>
<p>With these basics out of the way, let‚Äôs take a look at how the actual hardware interacts with my computer, and vice-versa.</p>
<h2 id="stream-deck-hardware">Stream Deck hardware <span><a href="#stream-deck-hardware" aria-label="Anchor">#</a></span></h2>
<h3 id="the-buttons">The buttons <span><a href="#the-buttons" aria-label="Anchor">#</a></span></h3>
<p>The behavior for the buttons is the same as I‚Äôve <a href="https://todaythings.substack.com/blog/reverse-engineering-stream-deck/">outlined with the Stream Deck XL</a>. I really appreciate the consistency here, and I guess from a supportability perspective this makes sense - once you have an API more or less working, why change how things act from a new hardware release to another? Kudos to Elgato on that.</p>
<p>Every button supports a 120x120 color image. The content is not dynamically updated by the device itself but rather by the host - that is, whatever computer you‚Äôre connecting it to. If there is updated status displayed on the button, that‚Äôs only because the computer is pushing new images to the Stream Deck constantly. On Windows and macOS, that responsibility <em>typically</em> falls on the Stream Deck software (that I am aiming to fully replace with DeckSurf).</p>
<h4 id="setting-images">Setting images <span><a href="#setting-images" aria-label="Anchor">#</a></span></h4>
<p>When images are set on the computer, a JPEG-encoded and usually compressed (if you use a larger resolution) image is being sent over the wire, along with some other <a href="https://todaythings.substack.com/blog/reverse-engineering-stream-deck/#-decoding-the-packets">generic packet metadata</a>.</p>
<p>The packets that set the image can be recognized by looking for the following pattern in the header (values are hexadecimal):</p>
<pre tabindex="0"><code data-lang="binary">+-------+----+----+----+----+----+----+----+----+
| Byte  |  0 |  1 |  2 |  3 |  4 |  5 |  6 |  7 |
+-------+----+----+----+----+----+----+----+----+
| Value | 02 | 07 | 18 | 00 | F8 | 03 | 00 | 00 |
+-------+----+----+----+----+----+----+----+----+
</code></pre><p>The header can be described like this:</p>
<table>
<thead>
<tr>
<th>Byte Index</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>0</code></td>
<td>Always <code>02</code></td>
</tr>
<tr>
<td><code>1</code></td>
<td>Always <code>07</code></td>
</tr>
<tr>
<td><code>2</code></td>
<td>Hexadecimal ID of the button for which the image is set. This value is zero-indexed.</td>
</tr>
<tr>
<td><code>3</code></td>
<td>Determines whether the current packet is the <em>final</em> packet that sets an image. Larger images are broken down into multiple packets, and this value can be either <code>00</code> or <code>01</code>.</td>
</tr>
<tr>
<td><code>4</code> and <code>5</code></td>
<td>16-bit Little Endian representation of the image payload length in the <em>current packet</em>.</td>
</tr>
<tr>
<td><code>6</code> and <code>7</code></td>
<td>16-bit Little Endian representation of the zero-based iteration (or, page) for cases where the image is split in multiple packets.</td>
</tr>
</tbody>
</table>
<p>Everything that follows the header is the <em>image payload</em>. If the image is split, we will see several packets, like this:</p>

  
  
  
  
  
  <figure>
    
    <img alt="Setting an image in Stream Deck software and inspecting the packets in Wireshark." src="https://assets.den.dev/images/postmedia/reverse-engineer-stream-deck-plus/set-image-stream-deck.webp"/>
    
    <figcaption>Setting an image in Stream Deck software and inspecting the packets in Wireshark.</figcaption>
  </figure>


<p>Those <code>URB_INTERRUPT out</code> packets is what we‚Äôre after. Don‚Äôt worry if you haven‚Äôt learned about this terminology yet. <code>URB</code> stands for ‚ÄúUSB Request Block‚Äù and is used as a structure to describe a USB transfer between the host and the device. <code>INTERRUPT</code> refers to the transfer type. USB interrupt transfers are designed for devices that require low-latency communication, typically for small amounts of data. These devices can be keyboards, mice, or, in our case, a Stream Deck Plus. Basically, anything that sends or receives frequent updates. Lastly, <code>out</code> indicates the direction of the transfer - <em>out</em> of the host and to the device. <code>URB_INTERRUPT out</code> means that the host (my computer) is sending data to a device using an interrupt transfer.</p>
<p>Now, notice that the packets being sent are uniform - they are <strong>1,051 bytes</strong> long. The first packet contains the JPEG header (starting bytes of the image), and every subsequent packet contains the rest of the image, split in chunks. The header is always <strong>8 bytes</strong> and the content (image payload) is declared in the header, but is usually <strong>1,016 bytes</strong>, making the total payload <strong>1,024 bytes</strong> long.</p>
<p>Do always check the header for the real length, though - never rely on these kind of assumptions as the de-facto truth, as things may change in the future.</p>
<p>To verify what image is being set, we can use a bit of command line magic. In Wireshark, select the <code>URB_INTERRUPT out</code> packets that contain the image. To make it easier to spot them, you can apply a more restrictive filter:</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span>usb.dst ~ <span>&#34;3.5&#34;</span> <span>&amp;&amp;</span> _ws.col.info <span>==</span> <span>&#34;URB_INTERRUPT out&#34;</span>
</span></span></code></pre></div><p>This will look for <code>URB_INTERRUPT out</code> packets to the specific destination only. As I mentioned, select the packets, and then from the <strong>File</strong> menu select <strong>Export Specified Packets‚Ä¶</strong>.</p>

  
  
  
  
  
  <figure>
    
    <img alt="Exporting a subset of packets in Wireshark." src="https://assets.den.dev/images/postmedia/reverse-engineer-stream-deck-plus/export-packets.webp"/>
    
    <figcaption>Exporting a subset of packets in Wireshark.</figcaption>
  </figure>


<p>In the following dialog, in the <strong>Packet Range</strong> section, click on <strong>Selected packets only</strong>.</p>

  
  
  
  
  
  <figure>
    
    <img alt="Dialog prompting to export a subset of packets in Wireshark." src="https://assets.den.dev/images/postmedia/reverse-engineer-stream-deck-plus/image-extraction-screen.webp"/>
    
    <figcaption>Dialog prompting to export a subset of packets in Wireshark.</figcaption>
  </figure>


<p>Give the file a descriptive name and store it somewhere on disk. Next, we will use a command-line tool that comes with Wireshark, called <a href="https://www.wireshark.org/docs/man-pages/tshark.html" target="_blank" rel="noreferrer noopener"><code>tshark</code></a>.</p>
<p>On Windows, <code>tshark</code> is <em>typically</em> located in the Wireshark installation folder. In my case, it was in <code>C:\Program Files\Wireshark</code>:</p>

  
  
  
  
  
  <figure>
    
    <img alt="Location of the TShark tool." src="https://assets.den.dev/images/postmedia/reverse-engineer-stream-deck-plus/tshark-location.webp"/>
    
    <figcaption>Location of the TShark tool.</figcaption>
  </figure>


<p>For easier consumption of <code>tshark</code>, you can add the Wireshark path to your system <code>PATH</code> <a href="https://superuser.com/a/284351/421794" target="_blank" rel="noreferrer noopener">environment variable</a>. Assuming that is done, we can now invoke this from the terminal:</p>
<div><pre tabindex="0"><code data-lang="powershell"><span><span><span>tshark</span> <span>-r</span> <span>.\</span><span>test-image</span><span>-extraction</span><span>.</span><span>pcapng</span> <span>-T</span> <span>fields</span> <span>-e</span> <span>usb</span><span>.</span><span>capdata</span> <span>&gt;</span> <span>data</span><span>.</span><span>txt</span>
</span></span></code></pre></div><p>What this command does is extract the HID data and dump it all in a text file. Because we‚Äôre already operating on a <code>*.pcapng</code> file that <em>only</em> contains the image packets we‚Äôre interested in, we don‚Äôt need to fiddle more with filtering, and just put everything in a text file.</p>
<p>The content will look like this:</p>

  
  
  
  
  
  <figure>
    
    <img alt="Text representation of the HID data dump." src="https://assets.den.dev/images/postmedia/reverse-engineer-stream-deck-plus/pcapng-dump-txt.webp"/>
    
    <figcaption>Text representation of the HID data dump.</figcaption>
  </figure>


<p>Not super helpful, but we spot the things I mentioned earlier - the <code>02 07</code> header starter, for example. As a quick and dirty ‚Äúhack‚Äù to dump image data from this text file, I have a PowerShell script:</p>
<div><pre tabindex="0"><code data-lang="powershell"><span><span><span>param</span> <span>(</span>
</span></span><span><span>    <span>[</span><span>string</span><span>]</span><span>$DataFile</span><span>,</span>
</span></span><span><span>    <span>[</span><span>string</span><span>]</span><span>$OutputFileName</span>
</span></span><span><span><span>)</span>
</span></span><span><span>
</span></span><span><span><span>function</span><span> </span><span>Process-HIDData</span> <span>{</span>
</span></span><span><span>    <span>param</span> <span>(</span>
</span></span><span><span>        <span>[</span><span>string</span><span>]</span><span>$DataFile</span><span>,</span>
</span></span><span><span>        <span>[</span><span>string</span><span>]</span><span>$OutputFileName</span>
</span></span><span><span>    <span>)</span>
</span></span><span><span>
</span></span><span><span>    <span>$lines</span> <span>=</span> <span>Get-Content</span> <span>-Path</span> <span>$DataFile</span>
</span></span><span><span>
</span></span><span><span>    <span>$imageBytes</span> <span>=</span> <span>@</span><span>()</span>
</span></span><span><span>
</span></span><span><span>    <span>foreach</span> <span>(</span><span>$line</span> <span>in</span> <span>$lines</span><span>)</span> <span>{</span>
</span></span><span><span>        <span>$hexBytes</span> <span>=</span> <span>$line</span><span>.</span><span>Trim</span><span>()</span>
</span></span><span><span>
</span></span><span><span>        <span>if</span> <span>(</span><span>$hexBytes</span><span>.</span><span>Length</span> <span>-gt</span> <span>16</span><span>)</span> <span>{</span>
</span></span><span><span>            <span>$processedBytes</span> <span>=</span> <span>$hexBytes</span><span>.</span><span>Substring</span><span>(</span><span>16</span><span>)</span>
</span></span><span><span>            <span>$byteArray</span> <span>=</span> <span>for</span> <span>(</span><span>$i</span> <span>=</span> <span>0</span><span>;</span> <span>$i</span> <span>-lt</span> <span>$processedBytes</span><span>.</span><span>Length</span><span>;</span> <span>$i</span> <span>+=</span> <span>2</span><span>)</span> <span>{</span>
</span></span><span><span>                <span>[</span><span>Convert</span><span>]::</span><span>ToByte</span><span>(</span><span>$processedBytes</span><span>.</span><span>Substring</span><span>(</span><span>$i</span><span>,</span> <span>2</span><span>),</span> <span>16</span><span>)</span>
</span></span><span><span>            <span>}</span>
</span></span><span><span>            <span>$imageBytes</span> <span>+=</span> <span>$byteArray</span>
</span></span><span><span>        <span>}</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>
</span></span><span><span>    <span>$binaryData</span> <span>=</span> <span>[</span><span>byte[]</span><span>]::</span><span>new</span><span>(</span><span>$imageBytes</span><span>.</span><span>Length</span><span>)</span>
</span></span><span><span>    <span>[</span><span>System.Array</span><span>]::</span><span>Copy</span><span>(</span><span>$imageBytes</span><span>,</span> <span>$binaryData</span><span>,</span> <span>$imageBytes</span><span>.</span><span>Length</span><span>)</span>
</span></span><span><span>
</span></span><span><span>    <span>$scriptDirectory</span> <span>=</span> <span>$PSScriptRoot</span>
</span></span><span><span>    <span>$outputFilePath</span> <span>=</span> <span>Join-Path</span> <span>-Path</span> <span>$scriptDirectory</span> <span>-ChildPath</span> <span>$OutputFileName</span>
</span></span><span><span>
</span></span><span><span>    <span>[</span><span>System.IO.File</span><span>]::</span><span>WriteAllBytes</span><span>(</span><span>$outputFilePath</span><span>,</span> <span>$binaryData</span><span>)</span>
</span></span><span><span>
</span></span><span><span>    <span>Write-Output</span> <span>&#34;Image saved as </span><span>$outputFilePath</span><span>&#34;</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>if</span> <span>(</span><span>-not</span> <span>$DataFile</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>Write-Error</span> <span>&#34;Data file path is required.&#34;</span>
</span></span><span><span>    <span>exit</span> <span>1</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>if</span> <span>(</span><span>-not</span> <span>$OutputFileName</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>Write-Error</span> <span>&#34;Output file name is required.&#34;</span>
</span></span><span><span>    <span>exit</span> <span>1</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>Process-HIDData</span> <span>-DataFile</span> <span>$DataFile</span> <span>-OutputFileName</span> <span>$OutputFileName</span>
</span></span></code></pre></div><p>All it really does is strips out the <em>first 8 bytes</em> from each line (one line represents one batch of HID data) and stores the binary representation as a JPEG file. It can be invoked as such:</p>
<div><pre tabindex="0"><code data-lang="powershell"><span><span><span>.\</span><span>exportimage</span><span>.</span><span>ps1</span> <span>-DataFile</span> <span>.\</span><span>data</span><span>.</span><span>txt</span> <span>-OutputFile</span> <span>image</span><span>.</span><span>jpg</span>
</span></span></code></pre></div><p>Once the script executes, we can see my test hedgehog image:</p>

  
  
  
  
  
  <figure>
    
    <img alt="Test image that is sent to the Stream Deck device." src="https://assets.den.dev/images/postmedia/reverse-engineer-stream-deck-plus/generated-image.webp"/>
    
    <figcaption>Test image that is sent to the Stream Deck device.</figcaption>
  </figure>


<p>Nice! We have an idea of how images are passed over the wire. But another characteristic of Stream Deck buttons is that, just like any other buttons, they can be pressed. I‚Äôve also <a href="https://todaythings.substack.com/blog/reverse-engineering-stream-deck/#-listening-to-key-presses">talked about this in my previous blog post</a>, but the gist is that you have to look at the <em>reverse</em> of what we were doing with images.</p>
<p>That is, your filter string is now this (make sure to adjust the <code>src</code> argument):</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span>_ws.col.info <span>==</span> <span>&#34;URB_INTERRUPT in&#34;</span> <span>&amp;&amp;</span> usb.src <span>==</span> 3.5.1
</span></span></code></pre></div><p>I am looking for interrupt data flowing <em>in</em> (to the host) from the USB device at <code>3.5.1</code>. That data, as it turns out, is very easy to parse because what happens is that with each button <em>press</em> and <em>release</em> we get the <em>entire button map</em> in the HID data.</p>
<p>The first four bytes are the header and we can ignore those. The third byte always indicates the <em>number of buttons on the panel</em> - in the Stream Deck Plus case, that‚Äôs 8. For the Stream Deck XL, that is 32. The third byte also indicates <em>how many bytes after the header</em> contain the button map. So, if I press the 4th button on the Stream Deck Plus, the data it will send to my computer is this:</p>
<pre tabindex="0"><code data-lang="binary">0000  01 00 08 00 00 00 00 01 00 00 00 00 00 00 00 00  ................ 
0010  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................ 
0020  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................ 
0030  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................ 
0040  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................ 
0050  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................ 
0060  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................ 
0070  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................ 
0080  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................ 
0090  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................ 
00A0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................ 
00B0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................ 
00C0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................ 
00D0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................ 
00E0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................ 
00F0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................ 
0100  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................ 
0110  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................ 
0120  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................ 
0130  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................ 
0140  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................ 
0150  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................ 
0160  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................ 
0170  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................ 
0180  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................ 
0190  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................ 
01A0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................ 
01B0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................ 
01C0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................ 
01D0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................ 
01E0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................ 
01F0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................ 
</code></pre><p>Yet another piece of hardware infrastructure that is not different across SKUs, which I really appreciate Elgato doing.</p>
<h3 id="the-screen">The screen <span><a href="#the-screen" aria-label="Anchor">#</a></span></h3>
<p>Let‚Äôs now talk about the second component on a Stream Deck Plus - the screen. It‚Äôs a narrow band that we can use to display a bunch of information. By default it is used to display information about the knobs right below it. From this statement, we can <em>assume</em> that there are four distinct sections of this screen associated with each knob, but that would be <em>only a partially correct assumption</em>.</p>
<p>In practice, the entire screen area is just one big image. Well, big is relative here - it‚Äôs a 800x100 image. The way I found this is by setting the background to the screen and then doing the PowerShell ‚Äúhack‚Äù I mentioned above (but with a header offset of 16 bytes instead of 8) to inspect the traffic from my computer to the connected Stream Deck Plus. What I saw was this:</p>

  
  
  
  
  
  <figure>
    
    <img alt="Background image on a Stream Deck Plus screen." src="https://assets.den.dev/images/postmedia/reverse-engineer-stream-deck-plus/narrow-band-image.webp"/>
    
    <figcaption>Background image on a Stream Deck Plus screen.</figcaption>
  </figure>


<p>What the Stream Deck software does is create a composite image of all the things you‚Äôre associating with the knobs, and then pass it to the device as one blob. If we inspect the <em>outbound</em> traffic from the host to the device, we see packets like this:</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span><span>0000</span>  <span>02</span> 0C <span>00</span> <span>00</span> <span>00</span> <span>00</span> <span>20</span> <span>03</span> <span>64</span> <span>00</span> <span>00</span> <span>00</span> <span>00</span> F0 <span>03</span> <span>00</span>  ...... .d....√∞.. 
</span></span><span><span><span>0010</span>  FF D8 FF E0 <span>00</span> <span>10</span> 4A <span>46</span> <span>49</span> <span>46</span> <span>00</span> <span>01</span> <span>01</span> <span>00</span> <span>00</span> <span>01</span>  √ø√ò√ø√†..JFIF...... 
</span></span><span><span><span>0020</span>  <span>00</span> <span>01</span> <span>00</span> <span>00</span> FF DB <span>00</span> <span>43</span> <span>00</span> <span>03</span> <span>02</span> <span>02</span> <span>03</span> <span>02</span> <span>02</span> <span>03</span>  ....√ø√õ.C........ 
</span></span><span><span><span>0030</span>  <span>03</span> <span>03</span> <span>03</span> <span>04</span> <span>03</span> <span>03</span> <span>04</span> <span>05</span> <span>08</span> <span>05</span> <span>05</span> <span>04</span> <span>04</span> <span>05</span> 0A <span>07</span>  ................ 
</span></span><span><span><span>0040</span>  <span>07</span> <span>06</span> <span>08</span> 0C 0A 0C 0C 0B 0A 0B 0B 0D 0E <span>12</span> <span>10</span> 0D  ................ 
</span></span><span><span><span>0050</span>  0E <span>11</span> 0E 0B 0B <span>10</span> <span>16</span> <span>10</span> <span>11</span> <span>13</span> <span>14</span> <span>15</span> <span>15</span> <span>15</span> 0C 0F  ................ 
</span></span><span><span><span>0060</span>  <span>17</span> <span>18</span> <span>16</span> <span>14</span> <span>18</span> <span>12</span> <span>14</span> <span>15</span> <span>14</span> FF DB <span>00</span> <span>43</span> <span>01</span> <span>03</span> <span>04</span>  .........√ø√õ.C... 
</span></span><span><span><span>0070</span>  <span>04</span> <span>05</span> <span>04</span> <span>05</span> <span>09</span> <span>05</span> <span>05</span> <span>09</span> <span>14</span> 0D 0B 0D <span>14</span> <span>14</span> <span>14</span> <span>14</span>  ................ 
</span></span></code></pre></div><p>We now have a 16-byte header, that is structured like this (judging from the starting packet that is used to send the image):</p>
<pre tabindex="0"><code data-lang="binary">+-------+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
| Byte  |  0 |  1 |  2 |  3 |  4 |  5 |  6 |  7 |  8 |  9 | 10 | 11 | 12 | 13 | 14 | 15 |
+-------+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
| Value | 02 | 0C | 00 | 00 | 00 | 00 | 20 | 03 | 64 | 00 | 00 | 00 | 00 | F0 | 03 | 00 |
+-------+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
</code></pre><p>Looking at <em>all</em> packets for a single image, I started jotting down the following assumptions for the screen image setting headers:</p>
<table>
<thead>
<tr>
<th>Byte Index</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>0</code></td>
<td>Always <code>02</code></td>
</tr>
<tr>
<td><code>1</code></td>
<td>Always <code>0C</code></td>
</tr>
<tr>
<td><code>2</code> to <code>5</code></td>
<td>Always <code>00</code></td>
</tr>
<tr>
<td><code>6</code></td>
<td>Always <code>20</code></td>
</tr>
<tr>
<td><code>7</code></td>
<td>Always <code>03</code></td>
</tr>
<tr>
<td><code>8</code></td>
<td>Always <code>64</code></td>
</tr>
<tr>
<td><code>9</code></td>
<td>Always <code>00</code></td>
</tr>
<tr>
<td><code>10</code></td>
<td>Indicates whether this is the final chunk (i.e., ‚Äúpage‚Äù) when setting an image via a multi-part packet. Can be <code>00</code> or <code>01</code>.</td>
</tr>
<tr>
<td><code>11</code></td>
<td>Chunk (i.e., ‚Äúpage‚Äù) index when setting an image via a multi-part packet.</td>
</tr>
<tr>
<td><code>12</code></td>
<td>Always <code>00</code></td>
</tr>
<tr>
<td><code>13</code> and <code>14</code></td>
<td>Little Endian representation of the payload length.</td>
</tr>
<tr>
<td><code>15</code></td>
<td>Always <code>00</code></td>
</tr>
</tbody>
</table>
<p>And this would seem <em>good enough</em>, except there is a twist. I mentioned earlier that the assumption that the whole screen is always managed as a single image is only partially correct, because when you use one of the knobs (whether you press it or turn it), there is an overlay displayed briefly on the screen showing what is happening.</p>

  
  
  
  
  
  <figure>
    
    <img alt="A screen overlay shown on Stream Deck Plus." src="https://assets.den.dev/images/postmedia/reverse-engineer-stream-deck-plus/overlay.webp"/>
    
    <figcaption>A screen overlay shown on Stream Deck Plus.</figcaption>
  </figure>


<p>These overlays, just like everything else, are managed by the Stream Deck software. What was peculiar about it, though, was that it was sent as a <em>segment</em> - that is, the image that you see above is what was sent from my PC to Stream Deck Plus. The software didn‚Äôt send the full composite, but rather just that one part of the screen.</p>
<p>Could it be that every segment of the screen is addressable? I started comparing the headers between overlay sets. The data below shows the <em>headers</em> as individual bytes, followed by a short extract of the image payload (trust me, you don‚Äôt want the whole thing here). To make it easier to analyze things, I‚Äôve split the screen in four segments, from left to right - <strong>A</strong>, <strong>B</strong>, <strong>C</strong>, and <strong>D</strong>.</p>
<h4 id="segment-a">Segment A <span><a href="#segment-a" aria-label="Anchor">#</a></span></h4>
<pre tabindex="0"><code data-lang="binary">02 0c 00 00 00 00 c8 00 64 00 00 00 00 f0 03 00 ffd8ffe000104a46
02 0c 00 00 00 00 c8 00 64 00 00 01 00 f0 03 00 62719049eff74526
02 0c 00 00 00 00 c8 00 64 00 00 02 00 f0 03 00 6b8844808f976955
02 0c 00 00 00 00 c8 00 64 00 00 03 00 f0 03 00 e7d81a2c2bbb151b
02 0c 00 00 00 00 c8 00 64 00 00 04 00 f0 03 00 0f7c678f7a666ddf
02 0c 00 00 00 00 c8 00 64 00 00 05 00 f0 03 00 434b7255d6e66e9d
02 0c 00 00 00 00 c8 00 64 00 00 06 00 f0 03 00 fc54da1adeecad78
02 0c 00 00 00 00 c8 00 64 00 00 07 00 f0 03 00 7e4095f72f5c6bc2
02 0c 00 00 00 00 c8 00 64 00 00 08 00 f0 03 00 918ba9de8b9d4edf
02 0c 00 00 00 00 c8 00 64 00 00 09 00 f0 03 00 12ebd3dd2116a218
02 0c 00 00 00 00 c8 00 64 00 01 0a 00 0a 00 00 d38bb9152295be67
</code></pre><h4 id="segment-b">Segment B <span><a href="#segment-b" aria-label="Anchor">#</a></span></h4>
<pre tabindex="0"><code data-lang="binary">02 0c c8 00 00 00 c8 00 64 00 00 00 00 f0 03 00 ffd8ffe000104a46
02 0c c8 00 00 00 c8 00 64 00 00 01 00 f0 03 00 7662eade285d4963
02 0c c8 00 00 00 c8 00 64 00 00 02 00 f0 03 00 23241008207b8c96
02 0c c8 00 00 00 c8 00 64 00 00 03 00 f0 03 00 920734728fdaf35d
02 0c c8 00 00 00 c8 00 64 00 00 04 00 f0 03 00 f41d3afd723f98ed
02 0c c8 00 00 00 c8 00 64 00 00 05 00 f0 03 00 4b14e7701b82b291
02 0c c8 00 00 00 c8 00 64 00 00 06 00 f0 03 00 78f61540d6b165b6
02 0c c8 00 00 00 c8 00 64 00 00 07 00 f0 03 00 481bb70eb8fc7fcf
02 0c c8 00 00 00 c8 00 64 00 01 08 00 05 02 00 fce4dbc726e6ea09
</code></pre><h4 id="segment-c">Segment C <span><a href="#segment-c" aria-label="Anchor">#</a></span></h4>
<pre tabindex="0"><code data-lang="binary">02 0c 90 01 00 00 c8 00 64 00 00 00 00 f0 03 00 ffd8ffe000104a46
02 0c 90 01 00 00 c8 00 64 00 00 01 00 f0 03 00 1260fa52b10e4d00
02 0c 90 01 00 00 c8 00 64 00 00 02 00 f0 03 00 e52b2649911c1ce1
02 0c 90 01 00 00 c8 00 64 00 00 03 00 f0 03 00 8cadbf5d1a6bf53d
02 0c 90 01 00 00 c8 00 64 00 00 04 00 f0 03 00 51e403cc601c8127
02 0c 90 01 00 00 c8 00 64 00 00 05 00 f0 03 00 bfd26ffc7fa25e69
02 0c 90 01 00 00 c8 00 64 00 00 06 00 f0 03 00 91d352f3fe933f3d
02 0c 90 01 00 00 c8 00 64 00 00 07 00 f0 03 00 e90ffb69fc22540d
02 0c 90 01 00 00 c8 00 64 00 01 08 00 13 01 00 9f434156b8d8df76
</code></pre><h4 id="segment-d">Segment D <span><a href="#segment-d" aria-label="Anchor">#</a></span></h4>
<pre tabindex="0"><code data-lang="binary">02 0c 58 02 00 00 c8 00 64 00 00 00 00 f0 03 00 ffd8ffe000104a46
02 0c 58 02 00 00 c8 00 64 00 00 01 00 f0 03 00 9e49ea2ad547ccd3
02 0c 58 02 00 00 c8 00 64 00 00 02 00 f0 03 00 33d453a105caa44e
02 0c 58 02 00 00 c8 00 64 00 00 03 00 f0 03 00 2d7d0e89d08caad3
02 0c 58 02 00 00 c8 00 64 00 00 04 00 f0 03 00 d7b45dcc67503a1e
02 0c 58 02 00 00 c8 00 64 00 00 05 00 f0 03 00 9e0ed72437f7b6f6
02 0c 58 02 00 00 c8 00 64 00 00 06 00 f0 03 00 b8b9d1aea3d7a351
02 0c 58 02 00 00 c8 00 64 00 01 07 00 a4 00 00 4e735a459338a458
</code></pre><h4 id="spotting-the-delta">Spotting the delta <span><a href="#spotting-the-delta" aria-label="Anchor">#</a></span></h4>
<p>Between the packets I listed above, the only things that changed in the header are the third and fourth bytes. This makes me think that those are the <em>screen segment addresses</em>. We have:</p>
<table>
<thead>
<tr>
<th>Segment</th>
<th>Address</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>A</code></td>
<td><code>00 00</code></td>
</tr>
<tr>
<td><code>B</code></td>
<td><code>C8 00</code></td>
</tr>
<tr>
<td><code>C</code></td>
<td><code>90 01</code></td>
</tr>
<tr>
<td><code>D</code></td>
<td><code>58 02</code></td>
</tr>
</tbody>
</table>
<p>If we convert the values to decimal, the table suddenly will start making more sense:</p>
<table>
<thead>
<tr>
<th>Segment</th>
<th>Address</th>
<th>Little-Endian Address</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>A</code></td>
<td><code>00 00</code></td>
<td>0</td>
</tr>
<tr>
<td><code>B</code></td>
<td><code>C8 00</code></td>
<td>200</td>
</tr>
<tr>
<td><code>C</code></td>
<td><code>90 01</code></td>
<td>400</td>
</tr>
<tr>
<td><code>D</code></td>
<td><code>58 02</code></td>
<td>600</td>
</tr>
</tbody>
</table>
<p>Amazing. The third and fourth byte in the header represent the <em>pixel offset</em> (remember how I mentioned that the full image is 800x100). Now, let‚Äôs compare all those packets to what we see when we set the <em>full</em> image:</p>
<pre tabindex="0"><code data-lang="binary">02 0c 00 00 00 00 20 03 64 00 00 00 00 f0 03 00 ffd8ffe000104a46
02 0c 00 00 00 00 20 03 64 00 00 01 00 f0 03 00 89b062cee0cd8e84
02 0c 00 00 00 00 20 03 64 00 00 02 00 f0 03 00 5805c9c63771d327
02 0c 00 00 00 00 20 03 64 00 00 03 00 f0 03 00 3dab5a71737721b3
02 0c 00 00 00 00 20 03 64 00 00 04 00 f0 03 00 618246734b6342fe
02 0c 00 00 00 00 20 03 64 00 00 05 00 f0 03 00 aa159464a0cce71d
02 0c 00 00 00 00 20 03 64 00 00 06 00 f0 03 00 8996e51482344335
02 0c 00 00 00 00 20 03 64 00 00 07 00 f0 03 00 45ae683e24bbff00
02 0c 00 00 00 00 20 03 64 00 00 08 00 f0 03 00 8bc53378a7c07e1c
02 0c 00 00 00 00 20 03 64 00 00 09 00 f0 03 00 ff005ff807e3af0b
02 0c 00 00 00 00 20 03 64 00 00 0a 00 f0 03 00 b299080709c9c02a
02 0c 00 00 00 00 20 03 64 00 00 0b 00 f0 03 00 4fb45746ef817c56
02 0c 00 00 00 00 20 03 64 00 00 0c 00 f0 03 00 c62390ac84897272
02 0c 00 00 00 00 20 03 64 00 00 0d 00 f0 03 00 27030d8e36a8e001
02 0c 00 00 00 00 20 03 64 00 00 0e 00 f0 03 00 d95ab7fa562dd956
02 0c 00 00 00 00 20 03 64 00 00 0f 00 f0 03 00 ba2eaf650de69fa4
02 0c 00 00 00 00 20 03 64 00 00 10 00 f0 03 00 efe19c9f0f3c1da1
02 0c 00 00 00 00 20 03 64 00 00 11 00 f0 03 00 7e140462b850800c
02 0c 00 00 00 00 20 03 64 00 00 12 00 f0 03 00 ec37b1e8da7b416d
02 0c 00 00 00 00 20 03 64 00 00 13 00 f0 03 00 ee1636963dec088e
02 0c 00 00 00 00 20 03 64 00 00 14 00 f0 03 00 3f06e9f2c02596f4
02 0c 00 00 00 00 20 03 64 00 00 15 00 f0 03 00 49a0d8d94b7b55d3
02 0c 00 00 00 00 20 03 64 00 00 16 00 f0 03 00 8a2ea63df238c374
02 0c 00 00 00 00 20 03 64 00 00 17 00 f0 03 00 f4b8d34433bc65c4
02 0c 00 00 00 00 20 03 64 00 00 18 00 f0 03 00 2033824b02a3712a
02 0c 00 00 00 00 20 03 64 00 00 19 00 f0 03 00 1c8ee4f526bf4da7
02 0c 00 00 00 00 20 03 64 00 00 1a 00 f0 03 00 e3da788745f19f88
02 0c 00 00 00 00 20 03 64 00 00 1b 00 f0 03 00 2755734755b7dc43
02 0c 00 00 00 00 20 03 64 00 00 1c 00 f0 03 00 e0cad297dd8f5c35
02 0c 00 00 00 00 20 03 64 00 00 1d 00 f0 03 00 c00217a1cfd8f259
02 0c 00 00 00 00 20 03 64 00 00 1e 00 f0 03 00 c1cfc8ec33f91ac7
02 0c 00 00 00 00 20 03 64 00 00 1f 00 f0 03 00 b6f30aecddb72492
02 0c 00 00 00 00 20 03 64 00 00 20 00 f0 03 00 ff00b3fb552c8b08
02 0c 00 00 00 00 20 03 64 00 00 21 00 f0 03 00 baf3fc47d99f25fe
02 0c 00 00 00 00 20 03 64 00 00 22 00 f0 03 00 c6adc4510f3644f3
02 0c 00 00 00 00 20 03 64 00 00 23 00 f0 03 00 dcb5a79842477124
02 0c 00 00 00 00 20 03 64 00 00 24 00 f0 03 00 73950000a48af069
02 0c 00 00 00 00 20 03 64 00 00 25 00 f0 03 00 032c919120c6eca0
02 0c 00 00 00 00 20 03 64 00 00 26 00 f0 03 00 63f0d3e1a787127d
02 0c 00 00 00 00 20 03 64 00 00 27 00 f0 03 00 6efb25e5add3b7a9
02 0c 00 00 00 00 20 03 64 00 00 28 00 f0 03 00 7874fe1883c53e1d
02 0c 00 00 00 00 20 03 64 00 00 29 00 f0 03 00 20d4632b5ceda74e
02 0c 00 00 00 00 20 03 64 00 01 2a 00 92 02 00 bf32e9c5367927c4
</code></pre><p>The seventh and eight bytes all of a sudden became <code>20 03</code>, and that is because, once again - we need to look at the Little Endian representation for the values. For each segment, this value has been <code>C8 00</code>, which translates to <code>200</code>. <code>20 03</code> is <code>800</code>. This is the image width. <code>64 00</code> is <code>100</code>, so it‚Äôs the image height.</p>
<p>My assumed table now took a much better shape:</p>
<table>
<thead>
<tr>
<th>Byte Index</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>0</code></td>
<td>Always <code>02</code></td>
</tr>
<tr>
<td><code>1</code></td>
<td>Always <code>0C</code></td>
</tr>
<tr>
<td><code>2</code> and <code>3</code></td>
<td>Offset from the left corner.</td>
</tr>
<tr>
<td><code>4</code> and <code>5</code></td>
<td>Always <code>00 00</code>.</td>
</tr>
<tr>
<td><code>6</code> and <code>7</code></td>
<td>Image width.</td>
</tr>
<tr>
<td><code>8</code> and <code>9</code></td>
<td>Image height.</td>
</tr>
<tr>
<td><code>10</code></td>
<td>Indicates whether this is the final chunk (i.e., ‚Äúpage‚Äù) when setting an image via a multi-part packet. Can be <code>00</code> or <code>01</code>.</td>
</tr>
<tr>
<td><code>11</code> and <code>12</code></td>
<td>Chunk (i.e., ‚Äúpage‚Äù) index when setting an image via a multi-part packet.</td>
</tr>
<tr>
<td><code>13</code> and <code>14</code></td>
<td>Little Endian representation of the payload length.</td>
</tr>
<tr>
<td><code>15</code></td>
<td>Always <code>00</code></td>
</tr>
</tbody>
</table>
<p>And that‚Äôs it, we now know how screen data is set! Not overly complicated once I started looking at the delta between packets.</p>
<p>The last thing we need to talk about here is the fact that the screen <strong>is a touch screen</strong>, so we also need to be able to spot the user pressing on a segment. Pressing on any of the screen parts are functionally equivalent to pressing the knob - the same overlay will be shown if you‚Äôre using the Stream Deck software. But how does it show up in Wireshark?</p>
<p>To check, let‚Äôs once again set the filter to this, because we want to track events that originate on the device and go to the PC:</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span>usb.src ~ <span>&#34;3.5&#34;</span> <span>&amp;&amp;</span> _ws.col.info <span>==</span> <span>&#34;URB_INTERRUPT in&#34;</span>
</span></span></code></pre></div><p>Here is the data we get, tapping from left to right.</p>
<pre tabindex="0"><code data-lang="binary">01 02 0e 00 01 01 47 00 40 00 00000000000000000
01 02 0e 00 01 01 07 01 1c 00 00000000000000000
01 02 0e 00 01 01 ee 01 32 00 00000000000000000
01 02 0e 00 01 01 b3 02 29 00 00000000000000000
</code></pre><p>That looks very random. A little too varied for us to make any definitive conclusions. But you know what, let‚Äôs try tapping the same segment in different parts of the touch screen:</p>
<pre tabindex="0"><code data-lang="binary">01 02 0e 00 01 01 b2 02 33 00 00000000000000000
01 02 0e 00 01 01 13 03 20 00 00000000000000000
01 02 0e 00 01 01 a9 02 46 00 00000000000000000
01 02 0e 00 01 01 06 03 26 00 00000000000000000
01 02 0e 00 01 01 bb 02 20 00 00000000000000000
01 02 0e 00 01 01 00 03 52 00 00000000000000000
01 02 0e 00 01 01 b6 02 3e 00 00000000000000000
01 02 0e 00 01 01 f7 02 2f 00 00000000000000000
01 02 0e 00 01 01 f1 02 1c 00 00000000000000000
01 02 0e 00 01 01 8d 02 1c 00 00000000000000000
</code></pre><p>This variability in values instantly gave me a clue - we‚Äôre looking at coordinates on the screen! The structure ends up being this:</p>
<pre tabindex="0"><code data-lang="binary">+-------+----+----+----+----+----+----+----+-----+----+-----+
| Byte  |  0 |  1 |  2 |  3 |  4 |  5 |   6 -  7 |   8 -  9 |
+-------+----+----+----+----+----+----+----+-----+----+-----+
| Value | 01 | 02 | 0E | 00 | 01 | 01 | X coord. | Y coord. |
+-------+----+----+----+----+----+----+----+-----+----+-----+
</code></pre><p>Unlike the buttons, there is no <em>release</em> event - we just get a tap, and that‚Äôs it. That means that once we get an event marked by the header above, we can compute based on the X and Y coordinates <em>which part of the screen</em> was tapped and react accordingly.</p>
<h3 id="the-knobs">The knobs <span><a href="#the-knobs" aria-label="Anchor">#</a></span></h3>
<p>Last but not least, the one thing we should talk about are the knobs. Each knob can be used in three ways:</p>
<ol>
<li>Turn right.</li>
<li>Turn left.</li>
<li>Press.</li>
</ol>
<p>To make sure I log things properly, for each knob, labeled similar to how I labeled screen segments, I took four turns to the right, four turns to the left, and then a press. The data I captured is below.</p>
<h4 id="knob-a">Knob A <span><a href="#knob-a" aria-label="Anchor">#</a></span></h4>
<h5 id="right-turns">Right turns <span><a href="#right-turns" aria-label="Anchor">#</a></span></h5>
<pre tabindex="0"><code data-lang="binary">01 03 05 00 01 01 00 00 00 0000000000
01 03 05 00 01 01 00 00 00 0000000000
01 03 05 00 01 01 00 00 00 0000000000
01 03 05 00 01 01 00 00 00 0000000000
</code></pre><h5 id="left-turns">Left turns <span><a href="#left-turns" aria-label="Anchor">#</a></span></h5>
<pre tabindex="0"><code data-lang="binary">01 03 05 00 01 ff 00 00 00 0000000000
01 03 05 00 01 ff 00 00 00 0000000000
01 03 05 00 01 ff 00 00 00 0000000000
01 03 05 00 01 ff 00 00 00 0000000000
</code></pre><h5 id="press">Press <span><a href="#press" aria-label="Anchor">#</a></span></h5>
<pre tabindex="0"><code data-lang="binary">01 03 05 00 00 01 00 00 00 0000000000
01 03 05 00 00 00 00 00 00 0000000000
</code></pre><h4 id="knob-b">Knob B <span><a href="#knob-b" aria-label="Anchor">#</a></span></h4>
<h5 id="right-turns-1">Right turns <span><a href="#right-turns-1" aria-label="Anchor">#</a></span></h5>
<pre tabindex="0"><code data-lang="binary">01 03 05 00 01 00 01 00 00 0000000000
01 03 05 00 01 00 01 00 00 0000000000
01 03 05 00 01 00 01 00 00 0000000000
01 03 05 00 01 00 01 00 00 0000000000
</code></pre><h5 id="left-turns-1">Left turns <span><a href="#left-turns-1" aria-label="Anchor">#</a></span></h5>
<pre tabindex="0"><code data-lang="binary">01 03 05 00 01 00 ff 00 00 0000000000
01 03 05 00 01 00 ff 00 00 0000000000
01 03 05 00 01 00 ff 00 00 0000000000
01 03 05 00 01 00 ff 00 00 0000000000
</code></pre><h5 id="press-1">Press <span><a href="#press-1" aria-label="Anchor">#</a></span></h5>
<pre tabindex="0"><code data-lang="binary">01 03 05 00 00 00 01 00 00 0000000000
01 03 05 00 00 00 00 00 00 0000000000
</code></pre><h4 id="knob-c">Knob C <span><a href="#knob-c" aria-label="Anchor">#</a></span></h4>
<h5 id="right-turns-2">Right turns <span><a href="#right-turns-2" aria-label="Anchor">#</a></span></h5>
<pre tabindex="0"><code data-lang="binary">01 03 05 00 01 00 00 01 00 0000000000
01 03 05 00 01 00 00 01 00 0000000000
01 03 05 00 01 00 00 01 00 0000000000
01 03 05 00 01 00 00 01 00 0000000000
</code></pre><h5 id="left-turns-2">Left turns <span><a href="#left-turns-2" aria-label="Anchor">#</a></span></h5>
<pre tabindex="0"><code data-lang="binary">01 03 05 00 01 00 00 ff 00 0000000000
01 03 05 00 01 00 00 ff 00 0000000000
01 03 05 00 01 00 00 ff 00 0000000000
01 03 05 00 01 00 00 ff 00 0000000000
</code></pre><h5 id="press-2">Press <span><a href="#press-2" aria-label="Anchor">#</a></span></h5>
<pre tabindex="0"><code data-lang="binary">01 03 05 00 00 00 00 01 00 0000000000
01 03 05 00 00 00 00 00 00 0000000000
</code></pre><h4 id="knob-d">Knob D <span><a href="#knob-d" aria-label="Anchor">#</a></span></h4>
<h5 id="right-turns-3">Right turns <span><a href="#right-turns-3" aria-label="Anchor">#</a></span></h5>
<pre tabindex="0"><code data-lang="binary">01 03 05 00 01 00 00 00 01 0000000000
01 03 05 00 01 00 00 00 01 0000000000
01 03 05 00 01 00 00 00 01 0000000000
01 03 05 00 01 00 00 00 01 0000000000
</code></pre><h5 id="left-turns-3">Left turns <span><a href="#left-turns-3" aria-label="Anchor">#</a></span></h5>
<pre tabindex="0"><code data-lang="binary">01 03 05 00 01 00 00 00 ff 0000000000
01 03 05 00 01 00 00 00 ff 0000000000
01 03 05 00 01 00 00 00 ff 0000000000
01 03 05 00 01 00 00 00 ff 0000000000
</code></pre><h5 id="press-3">Press <span><a href="#press-3" aria-label="Anchor">#</a></span></h5>
<pre tabindex="0"><code data-lang="binary">01 03 05 00 00 00 00 00 01 0000000000
01 03 05 00 00 00 00 00 00 0000000000
</code></pre><h4 id="slicing-and-dicing">Slicing and dicing <span><a href="#slicing-and-dicing" aria-label="Anchor">#</a></span></h4>
<p>Looking at the signals above, commonalities emerged rather quickly because the same values kept shifting to the right.</p>

  
  
  
  
  
  <figure>
    
    <img alt="All the patterns eventually come back to repeat themselves." src="https://assets.den.dev/images/postmedia/reverse-engineer-stream-deck-plus/ive-seen-this.gif"/>
    
    <figcaption>All the patterns eventually come back to repeat themselves.</figcaption>
  </figure>


<p>That‚Äôs basically the button press pattern that we‚Äôve seen with, well, button presses!</p>
<pre tabindex="0"><code data-lang="binary">+-------+----+----+----+----+------------+---------------+---------------+---------------+---------------+
| Byte  |  0 |  1 |  2 |  3 |          4 |             5 |             6 |             7 |             8 |
+-------+----+----+----+----+------------+---------------+---------------+---------------+---------------+
| Value | 01 | 03 | 05 | 00 | Is turning | Knob A action | Knob B action | Knob C action | Knob D action |
+-------+----+----+----+----+------------+---------------+---------------+---------------+---------------+
</code></pre><p>For each knob, we can get a combo of:</p>
<ol>
<li>Byte <code>4</code> set to <code>01</code> (turning), button-specific bytes set to <code>01</code> (turn right) or <code>FF</code> (turn left).</li>
<li>Byte <code>4</code> set to <code>00</code> (presset), button-specific bytes set to <code>01</code> (pressed) or <code>00</code> (released).</li>
</ol>
<p>Very nice - if you followed along all this time, you now know how the binary data is set for every control on the Stream Deck Plus.</p>
<h2 id="writing-a-wrapper">Writing a wrapper <span><a href="#writing-a-wrapper" aria-label="Anchor">#</a></span></h2>
<p>Alright, now that we went through the slog that is binary data analysis, it‚Äôs time to have a nicer way to deal with all this mess. To do that, <a href="https://github.com/dend/decksurf-sdk/pull/4" target="_blank" rel="noreferrer noopener">I updated the DeckSurf SDK</a> to support the Stream Deck Plus.</p>
<p>With the latest release of the <a href="https://www.nuget.org/packages/DeckSurf.SDK" target="_blank" rel="noreferrer noopener">DeckSurf SDK on NuGet</a> (0.0.4 at the time of this writing), you can use it to managed a Stream Deck Plus device!</p>
<p>Here is a fully-functioning sample in C# that shows how to handle events and set images on a Stream Deck Plus:</p>
<div><pre tabindex="0"><code data-lang="csharp"><span><span><span>using</span> <span>DeckSurf.SDK.Core</span><span>;</span>
</span></span><span><span><span>using</span> <span>DeckSurf.SDK.Models</span><span>;</span>
</span></span><span><span><span>using</span> <span>DeckSurf.SDK.Util</span><span>;</span>
</span></span><span><span><span>using</span> <span>System</span><span>;</span>
</span></span><span><span><span>using</span> <span>System.Collections.Generic</span><span>;</span>
</span></span><span><span><span>using</span> <span>System.IO</span><span>;</span>
</span></span><span><span><span>using</span> <span>System.Threading</span><span>;</span>
</span></span><span><span>
</span></span><span><span><span>namespace</span> <span>DeckSurf.SDK.StartBoard</span>
</span></span><span><span><span>{</span>
</span></span><span><span>    <span>class</span> <span>Program</span>
</span></span><span><span>    <span>{</span>
</span></span><span><span>        <span>static</span> <span>void</span> <span>Main</span><span>(</span><span>string</span><span>[]</span> <span>args</span><span>)</span>
</span></span><span><span>        <span>{</span>
</span></span><span><span>            <span>var</span> <span>exitSignal</span> <span>=</span> <span>new</span> <span>ManualResetEvent</span><span>(</span><span>false</span><span>);</span>
</span></span><span><span>            <span>var</span> <span>devices</span> <span>=</span> <span>DeviceManager</span><span>.</span><span>GetDeviceList</span><span>();</span>
</span></span><span><span>
</span></span><span><span>            <span>Console</span><span>.</span><span>WriteLine</span><span>(</span><span>&#34;The following Stream Deck devices are connected:&#34;</span><span>);</span>
</span></span><span><span>
</span></span><span><span>            <span>foreach</span> <span>(</span><span>var</span> <span>connectedDevice</span> <span>in</span> <span>devices</span><span>)</span>
</span></span><span><span>            <span>{</span>
</span></span><span><span>                <span>Console</span><span>.</span><span>WriteLine</span><span>(</span><span>connectedDevice</span><span>.</span><span>Name</span><span>);</span>
</span></span><span><span>            <span>}</span>
</span></span><span><span>
</span></span><span><span>            <span>var</span> <span>device</span> <span>=</span> <span>((</span><span>List</span><span>&lt;</span><span>ConnectedDevice</span><span>&gt;)</span><span>devices</span><span>)[</span><span>0</span><span>];</span>
</span></span><span><span>            <span>device</span><span>.</span><span>StartListening</span><span>();</span>
</span></span><span><span>            <span>device</span><span>.</span><span>OnButtonPress</span> <span>+=</span> <span>Device_OnButtonPress</span><span>;</span>
</span></span><span><span>
</span></span><span><span>            <span>byte</span><span>[]</span> <span>testImage</span> <span>=</span> <span>File</span><span>.</span><span>ReadAllBytes</span><span>(</span><span>args</span><span>[</span><span>0</span><span>]);</span>
</span></span><span><span>
</span></span><span><span>            <span>var</span> <span>image</span> <span>=</span> <span>ImageHelpers</span><span>.</span><span>ResizeImage</span><span>(</span><span>testImage</span><span>,</span> <span>device</span><span>.</span><span>ScreenWidth</span><span>,</span> <span>device</span><span>.</span><span>ScreenHeight</span><span>,</span> <span>device</span><span>.</span><span>IsButtonImageFlipRequired</span><span>);</span>
</span></span><span><span>
</span></span><span><span>            <span>device</span><span>.</span><span>SetScreen</span><span>(</span><span>image</span><span>,</span> <span>250</span><span>,</span> <span>device</span><span>.</span><span>ScreenWidth</span><span>,</span> <span>device</span><span>.</span><span>ScreenHeight</span><span>);</span>
</span></span><span><span>
</span></span><span><span>            <span>var</span> <span>keyImage</span> <span>=</span> <span>ImageHelpers</span><span>.</span><span>ResizeImage</span><span>(</span><span>testImage</span><span>,</span> <span>device</span><span>.</span><span>ButtonResolution</span><span>,</span> <span>device</span><span>.</span><span>ButtonResolution</span><span>,</span> <span>device</span><span>.</span><span>IsButtonImageFlipRequired</span><span>);</span>
</span></span><span><span>            <span>device</span><span>.</span><span>SetKey</span><span>(</span><span>1</span><span>,</span> <span>keyImage</span><span>);</span>
</span></span><span><span>
</span></span><span><span>            <span>device</span><span>.</span><span>SetBrightness</span><span>(</span><span>29</span><span>);</span>
</span></span><span><span>
</span></span><span><span>            <span>Console</span><span>.</span><span>WriteLine</span><span>(</span><span>&#34;Done&#34;</span><span>);</span>
</span></span><span><span>            <span>exitSignal</span><span>.</span><span>WaitOne</span><span>();</span>
</span></span><span><span>        <span>}</span>
</span></span><span><span>
</span></span><span><span>        <span>private</span> <span>static</span> <span>void</span> <span>Device_OnButtonPress</span><span>(</span><span>object</span> <span>source</span><span>,</span> <span>ButtonPressEventArgs</span> <span>e</span><span>)</span>
</span></span><span><span>        <span>{</span>
</span></span><span><span>            <span>Console</span><span>.</span><span>WriteLine</span><span>(</span><span>$&#34;Button with ID {e.Id} was pressed. It&#39;s identified as {e.ButtonKind}. Event is {e.EventKind}. If this is a touch screen, coordinates are {e.TapCoordinates.X} and {e.TapCoordinates.Y}. Is knob rotated: {e.IsKnobRotating}. Rotation direction: {e.KnobRotationDirection}.&#34;</span><span>);</span>
</span></span><span><span>        <span>}</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>Now, of course - this sample makes the assumption that the Stream Deck Plus device is the first one connected (index zero), so you might want to tweak that if you have more than one Stream Deck plugged in. But nonetheless, this shows you how <em>easy</em> I try to make Stream Deck interactions with the DeckSurf SDK. It‚Äôs all still in early preview, so things might break with future releases until I get it to a stable version, but until then - feel free to experiment!</p>
<p>As always, the latest documentation is available on <a href="https://docs.deck.surf/" target="_blank" rel="noreferrer noopener"><code>https://docs.deck.surf</code></a>.</p>
<h2 id="discussions">Discussions <span><a href="#discussions" aria-label="Anchor">#</a></span></h2>
<p>If you‚Äôd like to see more discussions on this, check out <a href="https://hackaday.com/2024/12/26/stream-deck-plus-reverse-engineered/" target="_blank" rel="noreferrer noopener">HACKADAY</a> and <a href="https://news.ycombinator.com/item?id=42518444" target="_blank" rel="noreferrer noopener">Hacker News</a>.</p>

      </div>
    </section>
    
  </article></div>
  </body>
</html>
