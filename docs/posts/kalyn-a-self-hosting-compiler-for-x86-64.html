<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://intuitiveexplanations.com/tech/kalyn">Original</a>
    <h1>Kalyn: A self-hosting compiler for x86-64</h1>
    
    <div id="readability-page-1" class="page"><div aria-label="Content">
<div>
<article>

<div>
<p><img src="https://intuitiveexplanations.com/assets/kalyn-module-map.png" alt="Module flow chart for Kalyn"/></p>
<p>Over the course of my Spring 2020 semester at <a href="https://www.hmc.edu/">Harvey Mudd
College</a>, I developed a self-hosting compiler
entirely from scratch. This article walks through many interesting
parts of the project. It’s laid out so you can just read from
beginning to end, but if you’re more interested in a particular topic,
feel free to jump there. Or, take a look at <a href="https://github.com/raxod502/kalyn">the project on
GitHub</a>.</p>
<p><strong>Table of contents</strong></p>

<ul>
<li><a href="#what-the-project-is-and-why-it-exists">What the project is and why it exists</a>
<ul>
<li><a href="#kalyn-by-the-numbers">Kalyn by the numbers</a></li>
</ul>
</li>
<li><a href="#about-the-language-being-compiled">About the language being compiled</a>
<ul>
<li><a href="#data-types">Data types</a>
<ul>
<li><a href="#integers">Integers</a></li>
<li><a href="#functions">Functions</a></li>
<li><a href="#inputoutput-monad">Input/output monad</a></li>
<li><a href="#user-defined-algebraic-data-types">User-defined algebraic data types</a></li>
</ul>
</li>
<li><a href="#syntax">Syntax</a>
<ul>
<li><a href="#expressions">Expressions</a></li>
<li><a href="#macros">Macros</a></li>
<li><a href="#declarations">Declarations</a></li>
</ul>
</li>
<li><a href="#module-system">Module system</a></li>
<li><a href="#typeclasses">Typeclasses</a></li>
<li><a href="#laziness">Laziness</a></li>
</ul>
</li>
<li><a href="#preliminary-technical-design-decisions">Preliminary technical design decisions</a>
<ul>
<li><a href="#in-memory-data-representations">In-memory data representations</a>
<ul>
<li><a href="#functions-1">Functions</a></li>
<li><a href="#io-monad">IO monad</a></li>
<li><a href="#user-defined-algebraic-data-types-1">User-defined algebraic data types</a></li>
</ul>
</li>
<li><a href="#calling-convention">Calling convention</a></li>
</ul>
</li>
<li><a href="#compiler-architecture-walkthrough">Compiler architecture walkthrough</a></li>
<li><a href="#how-i-implemented-it">How I implemented it</a>
<ul>
<li><a href="#lexer-reader-and-parser">Lexer, reader, and parser</a></li>
<li><a href="#standard-library">Standard library</a></li>
<li><a href="#bundler-and-resolver">Bundler and resolver</a></li>
<li><a href="#type-checker">Type checker</a></li>
<li><a href="#translator-code-generator">Translator (code generator)</a>
<ul>
<li><a href="#function-calls">Function calls</a></li>
<li><a href="#lambdas">Lambdas</a></li>
<li><a href="#data-constructors-and-pattern-matching">Data constructors and pattern matching</a></li>
<li><a href="#optimizing-function-calls">Optimizing function calls</a></li>
</ul>
</li>
<li><a href="#primitive-functions-and-bridge">Primitive functions and bridge</a></li>
<li><a href="#memory-management">Memory management</a></li>
<li><a href="#register-allocation-liveness-analysis-and-function-boilerplate">Register allocation, liveness analysis, and function boilerplate</a></li>
<li><a href="#assembler">Assembler</a></li>
<li><a href="#linker">Linker</a>
<ul>
<li><a href="#debugging-information">Debugging information</a></li>
<li><a href="#self-referential-headers">Self-referential headers</a></li>
<li><a href="#address-space-layout-and-randomization">Address space layout and randomization</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#worstfunniest-debugging-experiences">Worst/funniest debugging experiences</a></li>
<li><a href="#what-next">What next?</a></li>
</ul>

<h2 id="what-the-project-is-and-why-it-exists" tabindex="-1">What the project is and why it exists</h2>
<p>Kalyn is a <em>self-hosting</em> compiler. This means that the compiler is
itself written in the language that it knows how to compile, and so
the compiler can compile itself. Self-hosting compilers are common,
one reason being that programmers working on a compiler for language X
probably enjoy writing code in language X and so are inclined to
implement the compiler in language X.</p>
<p>Kalyn compiles a programming language of my own design, also called
Kalyn. One obstacle to developing a self-hosting compiler for a new
programming language is that in order to compile the compiler for the
first time, you have to already have a compiler: it’s a
chicken-and-egg problem. The simplest way to solve this problem is to
first write a simple version of your compiler in a different language,
and then use that compiler to compile your real compiler. So there are
two implementations of the Kalyn compiler: one in Haskell and one in
Kalyn itself. First I use the Haskell implementation to compile the
Kalyn implementation, and then after that I can use the Kalyn
implementation to compile itself.</p>
<p>I was inspired to create Kalyn by my Compilers class at <a href="https://www.hmc.edu/">Harvey Mudd
College</a>. In this class, students develop a
working compiler for a simple
<a href="https://developer.apple.com/swift/">Swift</a>-like programming language
over the course of the semester. However, I was left wanting more, for
a few reasons:</p>
<ul>
<li>Most of the compiler was designed and implemented already, with only
a few parts left as homework. This was probably a great idea for
maximizing the ratio of learning to work, but I’m the kind of person
who gets a lot of satisfaction from doing things from scratch.</li>
<li>The language we compiled in class was not really fully-featured
enough to do any serious work. Furthermore, the programming style of
Swift and similar languages does not really “<a href="https://en.wikipedia.org/wiki/Marie_Kondo#KonMari_method">spark
joy</a>” for
me, even if it’s a good idea for effective software engineering. I
prefer working in more expressive languages like
<a href="https://www.haskell.org/">Haskell</a> and
<a href="https://en.wikipedia.org/wiki/Emacs_Lisp">Lisp</a> when I’m not on the
clock. I did not feel terribly motivated in creating a compiler for
a language that I would not actually want to use.</li>
<li>The compiler we worked on in class was not truly “full-stack”, as it
were, since it reused a number of existing software components. For
example, we used the GNU linker and assembler so that we could
generate x86-64 assembly code in text format rather than binary
format, and we took advantage of the C standard library to avoid
having to implement memory management and input/output primitives.
Again, this was probably a good idea from an educational
perspective, but I wanted to take on the entire vertical from source
code to assembly opcodes.</li>
</ul>
<p>Kalyn addresses these problems in the following ways:</p>
<ul>
<li>I created <em>everything</em> from scratch, including the linker, the
assembler, and the standard library. Every single byte that ends up
in the executable binary is directly generated by my code.</li>
<li>I designed Kalyn to make it as usable as possible while being as
easy to compile as possible. It has very few core features (for
example, no lists, arrays, maps, or classes), yet is truly a
general-purpose programming language because these features can be
implemented in user code without needing special compiler support.
By aiming for a self-hosting compiler, I forced myself to prioritize
language usability, because I needed to write an entire compiler in
Kalyn.</li>
<li>I honestly think Kalyn is a good programming language and I enjoy
writing code in it. It is similar to Haskell, but uses Lisp syntax,
which is something that I have seen <a href="https://axellang.github.io/">only
rarely</a>. But since I really like
Haskell <em>except</em> for the syntax (which I consider an absolute
abomination), Kalyn adds something on top of languages that already
exist, so it feels like I am creating value. (Yes, obviously Kalyn
won’t be used in any real projects, but it was important to me that
my language couldn’t be described as “basically the same as X, but
it doesn’t work as well”.)</li>
</ul>
<h3 id="kalyn-by-the-numbers" tabindex="-1">Kalyn by the numbers</h3>
<p>So does it actually work? Yes! Kalyn can compile itself. The
performance is slow enough to be annoying, but not slow enough to be a
problem, when compared with Haskell. Here are the stats:</p>
<ul>
<li>Time for GHC to compile my Haskell implementation: <strong>13 seconds</strong></li>
<li>Time for my Haskell implementation to compile my Kalyn
implementation: <strong>2 seconds</strong></li>
<li>Time for my Kalyn implementation to compile itself: <strong>48 seconds</strong></li>
</ul>
<p>So we can see that Kalyn runs about 25 times slower than Haskell,
which I am pretty satisfied with given that Haskell has been optimized
by experts for decades and for Kalyn I basically threw together the
simplest thing that could possibly work.</p>
<p>Now here’s a different numerical perspective, the size of the project
as a function of time. The final total is <strong>4,300 lines</strong> of Haskell
code across <strong>23 modules</strong> and <strong>5,400 lines</strong> of Kalyn code across
<strong>43 modules</strong>. (Why more Kalyn? The syntax is slightly less concise,
but mostly it’s because I had to implement the entire Haskell standard
library – or at least the part I used in the compiler.) Here’s are
graphs showing lines of code and number of modules over time, from
which you can see I definitely left everything to the last minute…</p>
<p> <img alt="Total lines of code as a function of
time" src="https://intuitiveexplanations.com/assets/kalyn-graph-total-loc.png" width="75%"/> </p>
<p> <img alt="Number of modules as a function of time" src="https://intuitiveexplanations.com/assets/kalyn-graph-num-modules.png" width="75%"/> </p>
<p>For another perspective on the development process, here is a graph of
the cumulative total lines of code added and removed (so the project
size at any given time is the vertical distance between the lines).</p>
<p> <img alt="Code frequency graph" src="https://intuitiveexplanations.com/assets/kalyn-graph-codefreq.png" width="75%"/> </p>
<p>You can take a look for yourself <a href="https://github.com/raxod502/kalyn">on
GitHub</a>.</p>
<p>Now let’s get into the Kalyn programming language!</p>
<h2 id="about-the-language-being-compiled" tabindex="-1">About the language being compiled</h2>
<p>Kalyn is a combination of <a href="https://www.haskell.org/">Haskell</a> and
<a href="https://en.wikipedia.org/wiki/Lisp_(programming_language)">Lisp</a>.
Here is an example of some Haskell code that prints out the prime
numbers up to 100:</p>
<pre><code>module Main where

-- | Check if the number is prime.
isPrime :: Int -&gt; Bool
isPrime num =
  let factors = [2 .. num - 1]
  in  all (\factor -&gt; num `mod` factor /= 0) factors

main :: IO ()
main =
  let nums   = [2 .. 100]
      primes = filter isPrime nums
  in  print primes
</code></pre>
<p>Here is the same code in <a href="https://clojure.org/">Clojure</a>, a recently
developed Lisp that runs on the JVM.</p>
<pre><code>(ns hello-world.core)

(defn prime?
  &#34;Check if the number is prime.&#34;
  [n]
  (let [factors (range 2 n)]
    (every?
     (fn [factor]
       (not (zero? (mod n factor))))
     factors)))

(defn -main
  []
  (let [nums (range 2 100)
        primes (filter prime? nums)]
    (println primes)))
</code></pre>
<p>And here is the equivalent Kalyn code, which you can see combines the
idea of Haskell with the syntax of Lisp:</p>
<pre><code>(import &#34;Stdlib.kalyn&#34;)

(defn isPrime (Func Int Bool)
  &#34;Check if the number is prime.&#34;
  (num)
  (let ((factors (iterate (+ 1) 2 (- num 2))))
    (all
      (lambda (factor)
        (/=Int 0 (% num factor)))
      factors)))

(public def main (IO Empty)
  (let ((nums (iterate (+ 1) 2 98))
        (primes (filter isPrime nums)))
    (print (append (showList showInt primes) &#34;\n&#34;))))
</code></pre>
<p>The language is actually quite small, so we can go through all of it
pretty quickly. Let’s take a look.</p>
<h3 id="data-types" tabindex="-1">Data types</h3>
<p>Kalyn is a <a href="https://en.wikipedia.org/wiki/Type_system#Static_typing">statically
typed</a>
programming language, like Haskell. It has exactly four classes of
data types:</p>
<ul>
<li>Signed 64-bit integer, denoted <code>Int</code></li>
<li>Function, denoted <code>Func a b</code></li>
<li>Input/output monad, denoted <code>IO a</code></li>
<li>User-defined algebraic data types</li>
</ul>
<p>Some more explanation is clearly in order.</p>
<h4 id="integers" tabindex="-1">Integers</h4>
<p>Why only one size of integer? This makes the code generation easier
because every integer has the same size. In fact, I designed Kalyn
using what is called a <em>boxed memory representation</em>, so that <em>every</em>
data type has the same size. More on this later.</p>
<p>What about characters? These are actually just stored as integers.
This wastes a lot of space, because 56 bits out of 64 are left unused,
but again it makes the implementation much simpler if we don’t have to
worry about differently-sized data types.</p>
<h4 id="functions" tabindex="-1">Functions</h4>
<p>Kalyn has <a href="https://en.wikipedia.org/wiki/First-class_function">first-class
functions</a>,
meaning that code can dynamically create functions at runtime and pass
them around just like any other data type. This is required to support
any reasonable <a href="https://en.wikipedia.org/wiki/Functional_programming">functional
programming</a>.
Kalyn’s functions have
<a href="https://en.wikipedia.org/wiki/Closure_(computer_programming)">closures</a>,
which requires special compiler support. More on that later.</p>
<p>All functions in Kalyn are automatically
<a href="https://en.wikipedia.org/wiki/Currying">curried</a>, like in Haskell.
This means that all functions take only a single argument;
multiple-argument functions are implemented as a single-argument
function that returns another single-argument function that returns
another function, and so on. I made this decision for two reasons:
firstly, because currying is awesome, and secondly, because it
simplifies the type system and code generation if functions all take
the same number of arguments.</p>
<p>Because functions are curried, the notation <code>Func a b c</code> is really
just shorthand for <code>Func a (Func b c)</code>, where <code>a</code>, <code>b</code>, and <code>c</code> are
<em>type parameters</em> that might stand for things like <code>Int</code> and <code>List String</code> and <code>Func String Int</code>.</p>
<p>One thing you might be wondering is how functions of no arguments are
handled. The answer is there is no such thing. Since evaluating a
function has no side effects (see the next section on monadic IO),
there’s no difference between a function of no arguments that returns
some expression and just that expression itself.</p>
<h4 id="inputoutput-monad" tabindex="-1">Input/output monad</h4>
<p>Kalyn adopts Haskell’s abstraction of
<a href="http://learnyouahaskell.com/a-fistful-of-monads">monads</a> with
youthful exuberance. Explaining monads is beyond the scope of this
article, but the point is that every input/output function in the
standard library (<code>print</code>, <code>readFile</code>, <code>writeFile</code>, etc.) doesn’t
actually do IO. Instead, it returns an instance of the IO monad which
<em>represents</em> the IO action. These instances can then be chained
together using functional programming techniques, and the result is
executed only if it is returned from the <code>main</code> function of the
program.</p>
<p>Each instance of the IO monad has a return type, as in Haskell, so the
type is denoted <code>IO Int</code> or <code>IO (List String)</code> or <code>IO a</code> in general.</p>
<p>You might think that using monadic IO is in conflict with the design
goal of making Kalyn as easy as possible to compile. You would be
correct. But it’s <em>so cool!</em></p>
<h4 id="user-defined-algebraic-data-types" tabindex="-1">User-defined algebraic data types</h4>
<p>You may have noticed that most useful data types, such as booleans and
lists, are absent from Kalyn. This is because you can easily define
them yourself. This is done just as it is in Haskell, with algebraic
data types. Here is how the Kalyn standard library defines some handy
data types which will be familiar to the Haskell programmer:</p>
<pre><code>(public data Bool
  False True)

(public data (Maybe a)
  Nothing (Just a))

(public data (Either l r)
  (Left l) (Right r))

(public data (Pair a b)
  (Pair a b))

(public data (List a)
  Null (Cons a (List a)))

(public alias Word8 Int)

(public data Char (Char Word8))

(public alias String (List Char))
</code></pre>
<p>So, for example, a variable of type <code>List Int</code> could be any of:</p>
<ul>
<li><code>Null</code></li>
<li><code>Cons 5 Null</code></li>
<li><code>Cons 5 (Cons 2 Null)</code></li>
<li><code>Cons 5 (Cons 2 (Cons 9 Null))</code></li>
<li>etc.</li>
</ul>
<p>By including support for arbitrary algebraic data types, the compiler
doesn’t need any special support for booleans, lists, arrays, maps,
pairs, optionals, or anything else that would complicate the
implementation.</p>
<h3 id="syntax" tabindex="-1">Syntax</h3>
<p>Kalyn consists of declarations and expressions, both of which are
similar to Haskell except in appearance.</p>
<h4 id="expressions" tabindex="-1">Expressions</h4>
<p>First we have function calls, which are lists. Function currying is
handled automatically, so that <code>(map (+ 1) elts)</code> means we call the
<code>+</code> function with the argument <code>1</code> and then pass that to the <code>map</code>
function, and take the function returned from <code>map</code> and pass it the
argument <code>elts</code>.</p>
<p>Next, you can define anonymous functions using <code>lambda</code>, so a more
explicit form of the previous code would be:</p>
<pre><code>(map
  (lambda (x)
    (+ x 1))
  elts)
</code></pre>
<p>The type checker includes a constraint solver, so it can automatically
figure out the types of anonymous functions; there’s no need to
specify that manually (and, for simplicitly, you can’t).</p>
<p>Lambdas can have multiple arguments, but that just means they are
automatically curried, so that <code>(lambda (x y) ...)</code> is the same as
<code>(lambda (x) (lambda (y) ...))</code>.</p>
<p>You can establish local bindings using <code>let</code>:</p>
<pre><code>(let ((nums (iterate (+ 1) 2 98))
      (primes (filter isPrime nums)))
  (print (showList showInt primes)))
</code></pre>
<p>Each binding is evaluated in sequence, and it can refer to not only
previous bindings but also itself recursively. This allows you to
define recursive anonymous functions:</p>
<pre><code>(let ((explode
       (lambda (x)
         (explode (+ x 1)))))
  (explode 0))
</code></pre>
<p><a href="https://en.wikipedia.org/wiki/Mutual_recursion">Mutual recursion</a> is
notably <em>not</em> supported in <code>let</code> bindings, because internally a <code>let</code>
form with multiple bindings is translated into a series of nested
single-binding <code>let</code> forms, which makes the code generation easier.</p>
<p>The last special form is <code>case</code>, which (as in Haskell) allows you to
return different values depending on an algebraic data type. Arbitrary
patterns of data constructors and variables can be used on the
left-hand side of each branch. For example, here is Kalyn’s
implementation of the classic <code>unzip</code> function from Haskell:</p>
<pre><code>(public defn unzip (Func (List (Pair a b)) (Pair (List a) (List b)))
  (pairs)
  (case pairs
    (Null (Pair Null Null))
    ((Cons (Pair left right) pairs)
     (let (((Pair lefts rights)
            (unzip pairs)))
       (Pair (Cons left lefts)
             (Cons right rights))))))
</code></pre>
<p>You may notice that the <code>let</code> form employs <em>destructuring</em>, which is
basically the same as the pattern-matching used in <code>case</code> branches.
This can be done in function arguments as well, and the <code>@</code> syntax
from Haskell allows you to name a value while simultaneously
destructuring it:</p>
<pre><code>(lambda (<a href="https://intuitiveexplanations.com/cdn-cgi/l/email-protection" data-cfemail="177457">[email protected]</a>(Char i))
  (if (isAlphaNum c)
    [c]
    (append &#34;_u&#34; (showInt i))))
</code></pre>
<h4 id="macros" tabindex="-1">Macros</h4>
<p>That’s it for the core expression types in Kalyn. There are a few more
pieces of syntax, which the parser handles as macros. For example, the
<code>if</code> statement</p>
<pre><code>(if b
  False
  True)
</code></pre>
<p>translates into:</p>
<pre><code>(case b
  (True False)
  (False True))
</code></pre>
<p>The list literal <code>[1 2 3]</code> translates into:</p>
<pre><code>(Cons 1 (Cons 2 (Cons 3 Null)))
</code></pre>
<p>The string <code>&#34;Hello&#34;</code> translates into:</p>
<pre><code>(Cons
  (Char 72)
  (Cons
    (Char 101)
    (Cons
      (Char 108)
      (Cons
        (Char 108)
        (Cons
          (Char 111)
          Null)))))
</code></pre>
<p>The variadic <code>and</code> and <code>or</code> forms translate down to nested <code>case</code>
forms. And finally, we have the classic <code>do</code> notation from Haskell,
which translates into a sequence of <code>&gt;&gt;=</code> invocations. Now, as I’ll
discuss later, Kalyn doesn’t have typeclasses, which means there are
separate <code>&gt;&gt;=IO</code>, <code>&gt;&gt;=State</code>, etc. functions for each monad. As a
result, you have to specify which monad you’re working with at the
start of the macro. It looks like this:</p>
<pre><code>(do IO
  (with contents (readFile &#34;in.txt&#34;))
  (let reversed (reverse contents))
  (writeFile &#34;out.txt&#34; reversed)
  (setFileMode &#34;out.txt&#34; 0o600))
</code></pre>
<p>The <code>with</code> form is equivalent to Haskell’s <code>&lt;-</code> operator, while the
<code>let</code> form is the same as in Haskell. Other forms are assumed to be
monad instances whose return values are ignored (except for the last
form, which determines the return value of the entire <code>do</code> macro). The
above code translates like this:</p>
<pre><code>(&gt;&gt;=IO
  (readFile &#34;in.txt&#34;)
  (lambda (contents)
    (let ((reversed (reverse contents)))
      (&gt;&gt;=IO
        (writeFile &#34;out.txt&#34; reversed)
        (lambda (_)
          (setFileMode &#34;out.txt&#34; 0o600))))))
</code></pre>
<p>By implementing many familiar language features as macros instead of
true expressions, I was able to greatly simplify the implementation of
the compiler, since only the parser needs to know about these
features.</p>
<p>You might wonder why <code>let</code> isn’t implemented as a macro as well, since
after all <code>(let ((foo bar)) ...)</code> is equivalent to <code>((lambda (foo) ...) bar)</code>. The answer is that this would introduce a huge amount of
overhead, because a <code>let</code> can be easily translated into just a single
move instruction in the assembly, whereas a function call (especially
with proper handling of closures) is much more expensive.</p>
<h4 id="declarations" tabindex="-1">Declarations</h4>
<p>First we have <code>def</code>, which allows you to define the value of a symbol,
giving its type and an optional
<a href="https://en.wikipedia.org/wiki/Docstring">docstring</a>, like:</p>
<pre><code>(def pageSize Int
  &#34;The page size of the CPU.&#34;
  0x1000)
</code></pre>
<p>Next up is <code>defn</code>, which is for defining functions:</p>
<pre><code>(defn fst (Func (Pair a b) a)
  ((Pair a _))
  a)
</code></pre>
<p>Actually, though, <code>defn</code> is just a macro that expands to <code>def</code> and
<code>lambda</code>, like so:</p>
<pre><code>(def fst (Func (Pair a b) a)
  (lambda ((Pair a _))
    a))
</code></pre>
<p>We have algebraic data type declarations, as we’ve seen before:</p>
<pre><code>(data (Function reg)
  (Function Int Label (List (Instruction reg))))
</code></pre>
<p>And we have type aliases. This is the <code>type</code> keyword from Haskell.
(The <code>newtype</code> keyword is basically the same as <code>data</code>, and Kalyn
doesn’t care about the difference, so it doesn’t have a separate
declaration type for that.) So, for example, <code>String</code> can be used as a
shorthand for <code>List Char</code>:</p>
<pre><code>(alias String (List Char))
</code></pre>
<p>Kalyn’s standard library defines a number of aliases, like these:</p>
<pre><code>(alias Int8  Int)
(alias Int16 Int)
(alias Int32 Int)
(alias Int64 Int)

(alias Bytes String)
(alias FilePath String)
</code></pre>
<p>Of course, there is only one size of integer, and there is no
distinction between binary and text strings, but using the type
aliases is helpful to make the type signatures easier to understand.</p>
<h3 id="module-system" tabindex="-1">Module system</h3>
<p>The Kalyn compiler and standard library is split into many different
files. One file is designated by the compiler as the main module, and
it can import others, like:</p>
<pre><code>(import &#34;Stdlib.kalyn&#34;)
</code></pre>
<p>Now each declaration keyword (<code>def</code>, <code>defn</code>, <code>data</code>, <code>alias</code>) can be
optionally preceded by <code>public</code> to indicate that the declaration
should be made available to other code that imports the module. As an
aside, this solves a big annoyance I have with Haskell, which is that
there’s no way to specify which functions in a module should be public
without having to list all of them at the top of the file.</p>
<p>Ideally, Kalyn would also have a way to hide or select specific
symbols on an import, but in the interest of simplicity we don’t have
that. Qualified imports would be another useful feature, but in their
absence we get along fine by just prefixing names to avoid conflicts,
like for example <code>mapInsert</code> versus <code>setInsert</code>.</p>
<p>One key feature is that even the <code>import</code> keyword can be preceded by
<code>public</code> to indicate that all the imported symbols should be
re-exported. This allows for <code>Stdlib.kalyn</code> to <code>public import</code> many
submodules, so that user code only needs to import <code>Stdlib.kalyn</code> to
get the entire standard library.</p>
<p>The module system in Kalyn is really dirt simple. There’s no concept
of a search path or project root. Kalyn modules are just files
containing Kalyn source code (even the file extension doesn’t matter),
and imports are simply resolved as filenames relative to the directory
containing the module with the imports. This simplified the
implementation; languages like Python impose stronger conventions on
module layout but we don’t need that to get a compiler working.</p>
<h3 id="typeclasses" tabindex="-1">Typeclasses</h3>
<p>You may have noticed the conspicuous absence of one key feature of
Haskell, namely
<a href="https://en.wikipedia.org/wiki/Type_class">typeclasses</a>. This is
because it turns out that you don’t need them to get a compiler up and
running, even though they are really really nice. In Haskell, you can
define a <code>Show</code> instances like this, for example (if they weren’t
already defined in the standard library):</p>
<pre><code>instance Show Bool where
  show False = &#34;False&#34;
  show True = &#34;True&#34;

instance Show a =&gt; Show (List a) where
  show elts = &#34;[&#34; ++ intercalate &#34;,&#34; (map show elts) ++ &#34;]&#34;

show [False, True]  -- &#34;[False,True]&#34;
</code></pre>
<p>In Kalyn, we can do the same thing, we just have to define a different
function for each type:</p>
<pre><code>(alias (Show a) (Func a String))

(defn showBool (Show Bool)
  (bool)
  (case bool
    (False &#34;False&#34;)
    (True &#34;True&#34;)))

(defn showList (Func (Show a) (Show (List a)))
  (show elts)
  (concat
    [&#34;[&#34; (intercalate &#34;, &#34; (map show elts)) &#34;]&#34;]))

showList showBool [False, True]  ; &#34;[False, True]&#34;
</code></pre>
<p>Not ideal, but it kind of looks like the Haskell version if you
squint, and in practice it’s not that big of a pain. What’s more
annoying is that this approach doesn’t work for <a href="https://en.wikipedia.org/wiki/Type_class#Higher-kinded_polymorphism">higher-kinded
typeclasses</a>
like <code>Monad</code>. (Try it and see!) So it’s not possible to define a
function after the style of <code>showList</code> that would act on an arbitrary
monad if you passed it the relevant <code>&gt;&gt;=Whatever</code> bind operator.
Luckily, we only use two monads (<code>IO</code> and <code>State</code>) in the compiler, so
that wasn’t too big of a deal.</p>
<p>In retrospect, I’m pretty happy with the result. Extending the type
checker to support typeclasses would be quite complex, so I think the
limited version that I implemented was a good compromise to get a
self-hosted compiler initially off the ground.</p>
<h3 id="laziness" tabindex="-1">Laziness</h3>
<p>The other major difference from Haskell that’s worth mentioning is
laziness. Haskell is very lazy by default, so expressions are only
evaluated when they need to be. This often wreaks havoc with
evaluation order and makes it hard to understand what is running when,
although it does enable some neat tricks like being able to manipulate
infinite lists. Kalyn takes a simpler approach and evaluates
everything eagerly. There are two main disadvantages to doing things
this way:</p>
<ul>
<li>You can’t have infinite lists anymore, so idioms like <code>take 100 (iterate (+ 1) 0)</code> don’t work. I made the <code>iterate</code> function in the
standard library take an extra argument that controls the number of
iterations, so we can write <code>(iterate (+ 1) 0 100)</code> instead and it
works great. Turns out that laziness isn’t actually needed all that
often, at least in this kind of project.</li>
<li>Normally the way lazy evaluation works is that each expression is
turned into a <a href="https://en.wikipedia.org/wiki/Thunk">thunk</a> whose
value can be computed when needed and then cached. By not
implementing any of this, we lose the caching. That means the values
of top-level symbols are actually recomputed every time they’re
needed, which is unfortunate in some cases where a top-level symbol
is assigned the result of a nontrivial calculation. But in the end
it’s not <em>that</em> bad. This problem could be fixed at some additional
complexity cost, even if laziness weren’t added.</li>
</ul>
<p><em>… And that’s it for Kalyn! You now know the entire language.</em></p>
<h2 id="preliminary-technical-design-decisions" tabindex="-1">Preliminary technical design decisions</h2>
<p>Before we get into the compiler stack, we need to talk about a few
design decisions that have a big influence on how the low-level code
being generated looks.</p>
<h3 id="in-memory-data-representations" tabindex="-1">In-memory data representations</h3>
<p>The first choice I needed to make was how to represent each of the
data types in memory, since the assembly code I generate operates
directly on bytes, not monads and algebraic data types.</p>
<p>To simplify the implementation as much as possible, I selected a
<em>boxed memory representation</em>. In this representation, every data type
has exactly the same size, namely eight bytes (which we call a
<em>word</em>). So, if a data type needs eight or fewer bytes, we can just
store it directly like that. If it needs more, however, then instead
we allocate memory for it on <a href="https://en.wikipedia.org/wiki/Memory_management#Dynamic_memory_allocation">the
heap</a>
and store a pointer to that memory. If an object has sub-objects in
its fields, we can store those sub-objects in the same way: either
directly, if they are small enough, or through a pointer.</p>
<p>Now let’s talk about the individual classes of data types. Integers
are easy: since they are 64-bit, we can store them as-is in one word.
The other types are more interesting.</p>
<h4 id="functions-1" tabindex="-1">Functions</h4>
<p>Function objects must include two things: firstly, the address of
their machine instructions in memory; secondly, the arguments in their
closure. For example, suppose we run the following code:</p>
<pre><code>(let ((x 5)
      (y 7))
  (lambda (z)
    (+ (* z x) y)))
</code></pre>
<p>Then the function object returned needs to store two values in its
closure, <code>x = 5</code> and <code>y = 7</code>. In Kalyn, function objects consist of
three parts:</p>
<ul>
<li>First comes a word that contains the address of their code. (For
each <code>lambda</code> form that appears in the source code, we generate one
function in the assembly, so that each lambda has a place where its
instructions are stored.)</li>
<li>Next comes a word that specifies how many values are in the closure
of the function. In theory this could be determined automatically by
looking at the function address, since the size of each lambda’s
closure is known at compile-time, but that would impose a lot of
complexity at runtime.</li>
<li>Finally, we have one word for each of the closure values. This means
that function objects have different sizes, but because we put them
behind a pointer, we can treat them as if they are all a single
word.</li>
</ul>
<p>Note that the order of closure arguments is important! As I explain
later, the translator (code generator) arranges for the caller and the
callee to agree about what order the values should go in.</p>
<p>In summary, the function object from above might look like this on the
heap, and we would pass around a pointer to it:</p>
<pre><code>  code addr   num params  value of x  value of y
  .           .           .           .
  .           .           .           .
  .           .           .           .
+-----------+-----------+-----------+-----------+
| 0x821ad   | 2         | 5         | 7         |
+-----------+-----------+-----------+-----------+
</code></pre>
<h4 id="io-monad" tabindex="-1">IO monad</h4>
<p>I was a bit scared of figuring out exactly how to implement monadic
IO, because it seemed very abstract. It turns out, however, to be
shockingly simple. An instance of the IO monad is simply a function
object which, when called, does the IO.</p>
<p>Let’s look at an example. Suppose we want to translate this code:</p>
<pre><code>(let ((fname &#34;test.txt&#34;)
      (msg &#34;Hello, world!\n&#34;))
  (writeFile fname contents))
</code></pre>
<p>We would end up with a function object that looks like this (where
<code>fname</code> and <code>contents</code> are pointers into the heap):</p>
<pre><code>  code addr   num args    fname ptr   msg ptr
  .           .           .           .
  .           .           .           .
  .           .           .           .
+-----------+-----------+-----------+-----------+
| 0xcf73a   | 2         | 0x2eb2820 | 0x49f7988 |
+-----------+-----------+-----------+-----------+
</code></pre>
<p>This looks very similar to the function objects based on <code>lambda</code>
forms, but conceptually it’s actually rather different. Instead of
closure values, we have function arguments. With the lambda example
from before, calling the function object meant giving the code both
values from the closure together with the actual argument of the
lambda. With this example, there’s no closure and no extra argument to
provide: all the necessary information to do the IO is right there in
the function object. Despite these differences, though, the mechanics
are similar enough that both kinds of function objects can be treated
the same by Kalyn internally.</p>
<p>In the example above, the code address is not the address of
<code>writeFile</code>, because <code>writeFile</code> is the function that <em>returned</em> this
monad instance (aka function object). Instead, it’s the address of a
helper function <code>writeFile__unmonadified</code> which actually writes the
file. Each function that returns a monad has an associated helper
function to do the work.</p>
<p>Now let’s consider how we implement the monadic binding operator
<code>&gt;&gt;=IO</code>. The <code>&gt;&gt;=IO</code> function itself is just a wrapper that returns a
function object pointing at <code>&gt;&gt;=IO__unmonadified</code> which does the
actual work. What is that actual work? The helper gets two arguments
<code>ma</code> and <code>famb</code>. First, it runs <code>ma</code> to do its IO and procure the
return value. Then it passes that return value to <code>famb</code> to get
another function object which is the returned IO instance. Finally, it
must invoke <em>that</em> function object to do the rest of the IO (which
might constitute further invocations of <code>&gt;&gt;=IO</code>) before returning.</p>
<p>Finally, since <em>something</em> must kick off the IO execution in the first
place, the boilerplate code generated for Kalyn’s <code>main</code> function
first evaluates its body to get a monad instance and then invokes that
function object to do all the IO. Then it exits to terminate the
process.</p>
<h4 id="user-defined-algebraic-data-types-1" tabindex="-1">User-defined algebraic data types</h4>
<p>This is perhaps best illustrated by example. First consider booleans:</p>
<pre><code>(data Bool
  False True)
</code></pre>
<p>The value <code>False</code> is represented as 0 and the value <code>True</code> is
represented as 1. There’s no extra data, so we don’t need a pointer.</p>
<p>Now let’s look at optionals:</p>
<pre><code>(data (Maybe a)
  Nothing (Just a))
</code></pre>
<p>We can’t fit this into a single word without getting creative, and
creative is not compatible with simple, so we use a pointer for this
one. The first word on the heap is an integer that tells us which
constructor is being used, just like with booleans (0 for <code>Nothing</code>, 1
for <code>Just</code>). For <code>Nothing</code>, that’s it. For <code>Just</code>, however, the 1 is
followed by another word that contains the <code>a</code> in the <code>Just a</code>. This
could be either a piece of literal data or a pointer to more
heap-allocated data. This might seem like a waste of space in the case
of <code>Nothing</code>, but (without being creative) we need to have exactly one
place to look to find out whether we have a <code>Nothing</code> or a <code>Just</code>, so
either every constructor has to fit in a word or we have to put all of
them behind a pointer.</p>
<p>At this point you’ve seen almost everything. In general, an algebraic
data type consists of two parts:</p>
<ul>
<li>A header word to tell you which constructor was used. This is
omitted if there’s only one constructor, such as in <code>Char</code>.</li>
<li>If the constructor has fields, then the values of the fields.</li>
</ul>
<p>If the combination of those two parts fits inside one word for every
data constructor, then the type can be stored directly without a
pointer. Otherwise, we use a pointer for every constructor. In case
you’re curious, we need a pointer when <em>either</em>:</p>
<ul>
<li>any of the constructors has more than one field</li>
<li>any of the constructors has at least one field, and there’s more
than one constructor</li>
</ul>
<p>(What about <code>(data Empty)</code>, with no constructors at all? Eh… we just
use a zero. We could be smart and elide empty fields from containing
data constructors, but this would complicate the implementation.)</p>
<h3 id="calling-convention" tabindex="-1">Calling convention</h3>
<p>Okay, so now we know how Kalyn’s data types are represented. One
notable omission, however, is how to actually <em>use</em> function objects.</p>
<p>One of the first decisions I needed to make after deciding on data
types was to establish the Kalyn <a href="https://en.wikipedia.org/wiki/Calling_convention">calling
convention</a>. This
describes the way in which functions receive their arguments from
callers, and how they return results.</p>
<p>In Kalyn, function arguments are passed on <a href="https://en.wikipedia.org/wiki/Call_stack">the
stack</a>. Here is the layout
of a single <a href="https://en.wikipedia.org/wiki/Call_stack#Structure">stack
frame</a>:</p>
<pre><code>| Previous stack frame |
+----------------------+
| Function argument 1  |
| Function argument 2  |
|         ...          |
+----------------------+
|    Return address    |
+----------------------+
|  Saved base pointer  | &lt;-- base pointer
+----------------------+
|   Local variable 1   |
|   Local variable 2   |
|         ...          |
+----------------------+
|   Saved register 1   |
|   Saved register 2   |
|         ...          | &lt;-- stack pointer
+----------------------+
|   Next stack frame   |
</code></pre>
<p>As is standard in x86 assembly, two registers are used to manage the
stack: the stack pointer (<code>%rsp</code>) and the base pointer (<code>%rbp</code>). The
stack pointer always points to the last item that was pushed onto the
stack (which will be at the bottom of the stack, since in x86 the
stack grows downward). The base pointer, on the other hand, points to
a fixed point within the stack frame and does not change as items are
pushed and popped (at least until a new stack frame is entered). The
base pointer is used to easily locate specific values within the stack
frame, since indexing from the stack pointer would be difficult (as it
moves around within the frame).</p>
<p>Here is the flow of a function call:</p>
<ul>
<li>The caller pushes all of the arguments for the function onto the
stack. For regular function objects, this means all the closure
values followed by the main parameter of the function. For IO
functions, this just means the actual arguments of the function.</li>
<li>The caller invokes the function using the <code>callq</code> x86 instruction.
This automatically pushes a <a href="https://en.wikipedia.org/wiki/Return_statement">return
address</a> onto the
stack and jumps into the function.</li>
<li>The callee pushes the current base pointer (which pointed into the
caller’s stack frame) onto the stack, in order to save its value,
and then updates the base pointer to point at the current stack
pointer. Now the base pointer can be used to index into the callee’s
stack frame.</li>
<li>If the callee can’t fit all of its variables into registers (as I
discuss later in the section on register allocation), it moves the
stack pointer further downward to reserve stack space for the extra
variables.</li>
<li>The callee pushes the values of any registers it uses onto the
stack, in order to save their values.</li>
<li>The callee’s function body is executed. When it needs access to the
function arguments or local variable space, it can locate them using
the base pointer. If the callee needs to call more functions (quite
likely), it pushes their arguments and this process repeats
recursively.</li>
<li>The callee pops the values of the saved registers off the stack,
restoring their values for the caller.</li>
<li>The callee moves the stack pointer upwards to deallocate the space
it reserved for its local variables.</li>
<li>The callee pops the saved base pointer off the stack. The base
pointer now points back into the caller’s stack frame.</li>
<li>The caller puts its return value into the <code>%rax</code> registers, then
returns using the <code>retq</code> x86 instruction. This pops the return
address off the stack and jumps back to the caller.</li>
<li>The caller moves the stack pointer up to deallocate the space it
used to push the function arguments.</li>
</ul>
<p>In the stack frame diagram above, the base pointer and stack pointer
will be at the places labeled while the callee’s function body is
executing.</p>
<p>Notice that the callee’s base pointer is pointing at the saved base
pointer from the caller. That base pointer points at the saved base
pointer from the caller’s caller, and so on. Thus, by traversing the
chain of base pointers, we can construct a call stack. All we need to
do is look right above each base pointer to find the return addresses,
and that will tell us which functions we are in (and at which
instruction, which can be translated into a line number). Of course,
Kalyn does not actually provide backtraces at runtime, but the ability
to follow the base pointer chain was invaluable when debugging in
<a href="https://www.gnu.org/software/gdb/">GDB</a>.</p>
<p>Aside from stack frame layout, there is one other important
consideration when choosing a calling convention, which is to
designate <a href="https://en.wikipedia.org/wiki/Processor_register">machine
registers</a> as either
caller-saved or callee-saved. Since every function must do its work
using the same set of registers, conflicts between different functions
must be avoided. This is typically done by pushing the value of a
register onto the stack, and then later popping it off to restore its
value. Between the push and the pop, the register can safely be used
by another function. The question is whether the caller or callee is
responsible for saving the values of possibly conflicting registers.</p>
<p>In the standard x86-64 calling convention, some registers are marked
as caller-saved and others are marked as callee-saved:</p>
<ul>
<li>Caller-saved: <code>%rax</code>, <code>%rcx</code>, <code>%rdx</code>, <code>%rsi</code>, <code>%rdi</code>, <code>%r8</code>, <code>%r9</code>,
<code>%r10</code>, <code>%r11</code></li>
<li>Callee-saved: <code>%rbx</code>, <code>%r12</code>, <code>%r13</code>, <code>%r14</code>, <code>%r15</code></li>
</ul>
<p>This split was chosen as a compromise, because caller-saved registers
are better to use in some cases while callee-saved registers are
better for others. In Kalyn, however, all registers are callee-saved
except for <code>%rax</code> (which is used to store return values). This
simplifies the implementation.</p>
<p>Why all callee-saved instead of all caller-saved? I judged that it was
simpler to arrange for registers to be saved and restored at the
beginning and end of each function rather than before and after each
subroutine call. But the choice is mostly one of taste.</p>
<p>Readers familiar with x86-64 might recall that in the standard calling
convention, arguments are not passed on the stack unless there are
many of them. The first six arguments are passed in registers, namely
<code>%rdi</code>, <code>%rsi</code>, <code>%rdx</code>, <code>%rcx</code>, <code>%r8</code>, and <code>%r9</code>. This is clearly more
efficient than pushing every argument onto the stack, because memory
accesses are slow. But, it’s more complicated, so Kalyn does things
the simple way.</p>
<p>Readers familiar with assembly programming might also object “doesn’t
choosing a nonstandard calling convention prevent Kalyn from
interoperating with other code?” Well… yes! But the goal for this
project was to write everything from scratch, so in fact there is no
other code to interoperate with. The only exception is system calls,
which occur only within primitive functions that I hand-wrote in
assembly. The rest of Kalyn doesn’t need to know about system calls,
so there’s no need for it to use their calling convention.</p>
<h2 id="compiler-architecture-walkthrough" tabindex="-1">Compiler architecture walkthrough</h2>
<p>In this section I will walk you through the entire compiler pipeline
from top to bottom. Let’s follow the sample program that I used to
illustrate Kalyn’s syntax:</p>
<pre><code>(import &#34;Stdlib.kalyn&#34;)

(defn isPrime (Func Int Bool)
  &#34;Check if the number is prime.&#34;
  (num)
  (let ((factors (iterate (+ 1) 2 (- num 2))))
    (all
      (lambda (factor)
        (/=Int 0 (% num factor)))
      factors)))

(public def main (IO Empty)
  (let ((nums (iterate (+ 1) 2 98))
        (primes (filter isPrime nums)))
    (print (append (showList showInt primes) &#34;\n&#34;))))
</code></pre>
<p>The first step of the compiler is the <em>lexer</em>. This takes the program
source code and turns it into a sequence of <em>tokens</em>, which are names,
numbers, and pieces of punctuation. It looks like this:</p>
<pre><code>LPAREN
SYMBOL &#34;import&#34;
STRING &#34;Stdlib.kalyn&#34;
RPAREN
LPAREN
SYMBOL &#34;defn&#34;
SYMBOL &#34;isPrime&#34;
LPAREN
SYMBOL &#34;Func&#34;
SYMBOL &#34;Int&#34;
SYMBOL &#34;Bool&#34;
RPAREN
STRING &#34;Check if the number is prime.&#34;
LPAREN
SYMBOL &#34;num&#34;
RPAREN
LPAREN
SYMBOL &#34;let&#34;
LPAREN
LPAREN
SYMBOL &#34;factors&#34;
LPAREN
SYMBOL &#34;iterate&#34;
LPAREN
SYMBOL &#34;+&#34;
...
</code></pre>
<p>Next up is the <em>reader</em>. This converts the token stream into a
hierarchical list-of-lists representation. In other words, it parses
the Lisp syntax of Kalyn. Here is what that looks like:</p>
<pre><code>RoundList
    [ Symbol &#34;import&#34;
    , StrAtom &#34;Stdlib.kalyn&#34;
    ]
RoundList
    [ Symbol &#34;defn&#34;
    , Symbol &#34;isPrime&#34;
    , RoundList
        [ Symbol &#34;Func&#34;
        , Symbol &#34;Int&#34;
        , Symbol &#34;Bool&#34;
        ]
    , StrAtom &#34;Check if the number is prime.&#34;
    , RoundList [ Symbol &#34;num&#34; ]
    , RoundList
        [ Symbol &#34;let&#34;
        , RoundList
            [ RoundList
                [ Symbol &#34;factors&#34;
                , RoundList
                    [ Symbol &#34;iterate&#34;
                    , RoundList
                        [ Symbol &#34;+&#34;
                        , IntAtom 1
                        ]
                    ...
</code></pre>
<p>After the reader comes the <em>parser</em>, which converts the list-of-lists
representation into an <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree"><em>abstract syntax tree
(AST)</em></a> that can
be easily processed by the rest of the compiler. The AST is composed
of the declarations and expressions that I outlined earlier. Notably
it does not include any macros such as <code>if</code> or <code>do</code>, since the parser
automatically translates these into their lower-level counterparts.
Here is part of the AST for the program above:</p>
<pre><code>Import False &#34;Stdlib.kalyn&#34;
Def False &#34;isPrime&#34;
    ( Type [] &#34;Func&#34;
        [ Type [] &#34;Int&#34; []
        , Type [] &#34;Bool&#34; []
        ]
    )
    ( Lambda &#34;num&#34;
        ( Let &#34;factors&#34;
            ( Call
                ( Call
                    ( Call ( Variable &#34;iterate&#34; )
                        ( Call ( Variable &#34;+&#34; ) ( Const 1 ) )
                    ) ( Const 2 )
                )
                ( Call
                    ( Call ( Variable &#34;-&#34; ) ( Variable &#34;num&#34; ) ) ( Const 2 )
                )
            )
            ( Call
                ( Call ( Variable &#34;all&#34; )
                    ( Lambda &#34;factor&#34;
                        ( Call
                            ( Call ( Variable &#34;/=Int&#34; ) ( Const 0 ) )
                            ( Call
                                ...
</code></pre>
<p>The <code>False</code> that appears after <code>Import</code> and <code>Def</code> mean that <code>public</code>
was not used on those declarations. The empty lists after each <code>Type</code>
are because this code does not use typeclass constraints. (I wrote the
parser before deciding I could get away without typeclass support for
the first version of Kalyn, so all of the AST manipulation functions
take typeclasses into account.)</p>
<p>One interesting thing you might note is that the parser handles
function currying, so every <code>Call</code> has exactly two arguments even
though functions were called with more than two arguments in the input
program.</p>
<p>Next up is the bundler. The lexer, reader, and parser are actually all
run from the bundler, which is the real entry point to the compiler.
The bundler is responsible for handling the module system of Kalyn.
After lexing, reading, and parsing the main module, the bundler checks
for <code>Import</code> forms. If it finds any, it lexes, reads, and parses the
files referenced, and continues recursively until it has processed all
of the needed source code.</p>
<p>At this point, the bundler resolves transitive imports. In other
words, it inspects the collection of <code>import</code> and <code>public import</code>
forms in all loaded modules and determines what modules each other
module can “see”. So, if <code>A.kalyn</code> has <code>(import &#34;B.kalyn&#34;)</code> and
<code>B.kalyn</code> has <code>(import &#34;C.kalyn&#34;)</code> and <code>(public import &#34;D.kalyn&#34;)</code>,
then <code>A.kalyn</code> can see itself, <code>B.kalyn</code>, and <code>D.kalyn</code>, but not
<code>C.kalyn</code>.</p>
<p>After the bundler has finished running, it has produced a collection
of modules (each with a list of declarations and information about
what other modules are visible). This collection is called a bundle,
surprisingly enough. Before the bundle can be transformed into
assembly by the translator, it must be passed to two other side
modules: the resolver and the type checker.</p>
<p>The job of the resolver is twofold. First it must decide on a unique
name for every object that the assembly code will need to refer to
(such as variables, functions, and data constructors). This process,
called <a href="https://en.wikipedia.org/wiki/Name_mangling">name mangling</a>,
entails substituting Unicode characters with ASCII equivalents and
also making sure variables by the same name in different modules don’t
conflict with each other. For example, the <code>foldr</code> function defined in
<code>Stdlib/Lists.kalyn</code> might be given the name
<code>__src_u45kalynStdlibLists_u46kalyn__foldr</code>.</p>
<p>After the resolver decides on names, it also must generate a mapping
for each module that translates names from user code into the internal
names. So, in every module that imports <code>Stdlib/Lists.kalyn</code> there
will be a mapping from <code>foldr</code> to
<code>__src_u45kalynStdlibLists_u46kalyn__foldr</code>. The mapping also includes
type information and, for data constructor, notes on which data
constructor is in use, how many fields it has, etc. The mappings
generated by the resolver are used to look up symbol definitions in
both the type checker and translator.</p>
<p>At this point the bundle is run through the type checker. It might
surprise you to hear that the type checker doesn’t actually produce
information for any other parts of the compiler. Its only purpose is
to crash the compiler if there is a type error. You might expect that
in a strongly typed programming language we would need type
information in order to compile. In fact, however, my use of a boxed
memory representation means that code that operates on a value doesn’t
actually need to know what type that value has. This means that the
only utility in the type checker is making it so that type errors will
give you a compile-time error instead of a segmentation fault at
runtime. (Still pretty useful though.) I took advantage of this
property by not bothering to port the type checker to Kalyn. Since I
already know from the Haskell implementation that my Kalyn code
type-checks, and since compilation doesn’t require type information,
the Kalyn implementation doesn’t need a type checker to be
self-hosting. (Although obviously it <em>will</em> need one eventually, in
order to be useful.)</p>
<p>Now we arrive at the core of the compiler, the translator (also called
the code generator). At this point we have a bundle that contains AST
declarations and expressions, together with a resolver mapping that
tells us the meaning of every name that appears in the AST. The job of
the translator is to transform each declaration from the AST into a
set of one or more functions in x86 assembly. Here’s part of the
translated code for <code>isPrime</code> from our example:</p>
<pre><code>__Main_u46kalyn__isPrime:
        pushq $16
        callq memoryAlloc
        addq $8, %rsp
        movq %rax, %t0
        leaq __Main_u46kalyn__isPrime__uncurried(%rip), %t1
        movq %t1, (%t0)
        movq $0, 8(%t0)
        movq %t0, %rax
        retq
__Main_u46kalyn__isPrime__uncurried:
        movq 16(%rbp), %t2
        movq $1, %t8
        pushq %t8
        callq plus__curried0
        addq $8, %rsp
        movq %rax, %t9
        movq %t9, %t5
        pushq %t5
        movq $2, %t6
        pushq %t6
        movq %t2, %t10
        pushq %t10
        movq $2, %t11
        pushq %t11
        callq minus__uncurried
        ...
</code></pre>
<p>(Why two different functions? The first one returns the <em>value</em> of
<code>isPrime</code>, which is a function object, and the second one implements
the lambda for that function object.)</p>
<p>What ends up in the binary is, however, not only this code for user
functions, but also code for the core primitives of the language.
These are things like arithmetic and IO operations which can’t be
implemented directly in Kalyn. We have to start somewhere! I wrote
those functions manually in assembly, and they are added to the
program by the translator.</p>
<p>There are a few modules that are responsible for dealing with
primitives:</p>
<ul>
<li><em>Subroutines</em> includes code that is used to implement common logic,
like getting arguments from the stack or performing a function call.</li>
<li><em>Primitives</em> has implementations of all the basic primitive
functions that user code can call, like <code>+</code> and <code>print</code> and <code>&gt;&gt;=IO</code>.</li>
<li><em>MemoryManager</em> has internal functions that are used to handle
memory allocation. Remember, “from scratch” means no
<a href="https://en.wikipedia.org/wiki/C_dynamic_memory_allocation">malloc</a>!</li>
<li><em>Bridge</em> inspects the user code to see what primitives it calls, and
links in only those primitives to avoid bloating the binary. It also
handles wrapping primitives so that they are suitable to be called
from user code. This includes generating curried and monadic
wrappers so that I didn’t have to worry about any of that when
implementing the actual primitives.</li>
</ul>
<p>You might notice in the assembly snippet above that we are using
<em>virtual registers</em> <code>%t0</code>, <code>%t1</code>, etc. instead of just the typical x86
machine registers <code>%rax</code>, <code>%rdi</code>, <code>%rsi</code>, etc. This is because code
generation is much easier when we can pretend we have infinitely many
registers. It is the job of the <em>register allocator</em> to map these
virtual registers onto actual machine registers, and to move extra
information into local variables on the stack when there are not
enough machine registers to fit all the data.</p>
<p>The first step of register allocation is to perform a <em>liveness
analysis</em>. We analyze each assembly instruction to determine which
registers it reads from and writes to. Based on that information, we
can perform an iterative analysis to determine which registers are
<em>live</em> (might be used in the future) at each point in the program. If
two virtual registers are live at the same time, then they can’t be
assigned to the same physical register or they would conflict. Here is
part of the liveness analysis for <code>isPrime</code>:</p>
<pre><code>__Main_u46kalyn__isPrime:

;; live IN: (none)
;; used: (none)
        pushq $16
;; defined: (none)
;; live OUT: (none)

;; live IN: (none)
;; used: (none)
        callq memoryAlloc
;; defined: %rax
;; live OUT: %rax

;; live IN: %rax
;; used: (none)
        addq $8, %rsp
;; defined: %rsp
;; live OUT: %rax

;; live IN: %rax
;; used: %rax
        movq %rax, %t0
;; defined: %t0
;; live OUT: %t0

;; live IN: %t0
;; used: %rip
        leaq __Main_u46kalyn__isPrime__uncurried(%rip), %t1
;; defined: %t1
;; live OUT: %t0, %t1

;; live IN: %t0, %t1
;; used: %t0, %t1
        movq %t1, (%t0)
;; defined: (none)
;; live OUT: %t0

...
</code></pre>
<p>Based on this information, the register allocator rewrites the code to
use appropriate physical registers. You can see that <code>%t0</code> was placed
in <code>%rdx</code> and <code>%t1</code> was placed in <code>%rcx</code>:</p>
<pre><code>__Main_u46kalyn__isPrime:
        pushq $16
        callq memoryAlloc
        addq $8, %rsp
        movq %rax, %rdx
        leaq __Main_u46kalyn__isPrime__uncurried(%rip), %rcx
        movq %rcx, (%rdx)
        movq $0, 8(%rdx)
        movq %rdx, %rax
        retq
__Main_u46kalyn__isPrime__uncurried:
        movq 16(%rbp), %rsi
        movq $1, %rax
        pushq %rax
        callq plus__curried0
        addq $8, %rsp
        movq %rax, %rdx
        movq %rdx, %rcx
        pushq %rcx
        movq $2, %rcx
        pushq %rcx
        movq %rsi, %rcx
        pushq %rcx
        movq $2, %rcx
        pushq %rcx
        callq minus__uncurried
</code></pre>
<p>After code generation, there is one final transformation step on the
assembly, which is handled by the boilerplate module. This module
adapts each function to respect the Kalyn calling convention by
updating the base pointer, saving and restoring the data registers it
overwrites, and, if the function needed local variables, moving the
stack pointer to allocate and deallocate space for them. Here is part
of the final version of <code>isPrime</code>:</p>
<pre><code>__Main_u46kalyn__isPrime:
        pushq %rbp
        movq %rsp, %rbp
        pushq %rdx
        pushq %rcx
        pushq $16
        callq memoryAlloc
        addq $8, %rsp
        movq %rax, %rdx
        leaq __Main_u46kalyn__isPrime__uncurried(%rip), %rcx
        movq %rcx, (%rdx)
        movq $0, 8(%rdx)
        movq %rdx, %rax
        popq %rcx
        popq %rdx
        popq %rbp
        retq
__Main_u46kalyn__isPrime__uncurried:
        pushq %rbp
        movq %rsp, %rbp
        pushq %rsi
        pushq %rdx
        pushq %rcx
        pushq %rbx
        movq 16(%rbp), %rsi
</code></pre>
<p>At this point we have the entire program in x86 assembly format. It is
now time for the assembler to translate each assembly instruction into
the appropriate sequence of bytes. Mechanically this is a
straightforward process, although deciphering the <a href="http://ref.x86asm.net/coder64-abc.html">reference
materials</a> is quite the task.
For example, here is the binary for each instruction in
<code>__Main_u46kalyn__isPrime</code>:</p>
<pre><code>48 ff f5                pushq %rbp
48 8b ec                movq %rsp, %rbp
48 ff f2                pushq %rdx
48 ff f1                pushq %rcx
68 10 00 00 00          pushq $16
e8 f1 4e 01 00          callq memoryAlloc
48 81 c4 08 00 00 00    addq $8, %rsp
48 8b d0                movq %rax, %rdx
48 8d 0d 21 00 00 00    leaq __Main_u46kalyn__isPrime__uncurried(%rip), %rcx
48 89 8c 22 00 00 00    movq %rcx, (%rdx)
00
48 c7 84 22 08 00 00    movq $0, 8(%rdx)
00 00 00 00 00
48 8b c2                movq %rdx, %rax
48 8f c1                popq %rcx
48 8f c2                popq %rdx
48 8f c5                popq %rbp
c3                      retq
</code></pre>
<p>It’s at this point that all the labels generated by the resolver are
put to use: each one is translated to a numerical offset in bytes that
can be embedded into the binary.</p>
<p>The final step is the linker. This takes the binary code and data that
was generated by the assembler and wraps it in a header in the
<a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">Executable and Linkable Format
(ELF)</a>.
The resulting binary has metadata that is used by the operating system
to load it into memory and that is used by
<a href="https://www.gnu.org/software/gdb/">GDB</a> to display debugging
information:</p>
<pre><code>ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00
  Class:                             ELF64
  Data:                              2&#39;s complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              EXEC (Executable file)
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
  Entry point address:               0x18000
  Start of program headers:          64 (bytes into file)
  Start of section headers:          176 (bytes into file)
  Flags:                             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           56 (bytes)
  Number of program headers:         2
  Size of section headers:           64 (bytes)
  Number of section headers:         6
  Section header string table index: 1

Section Headers:
  [Nr] Name              Type             Address           Offset
       Size              EntSize          Flags  Link  Info  Align
  [ 0]                   NULL             0000000000000000  00000000
       0000000000000000  0000000000000000           0     0     0
  [ 1] .shstrtab         STRTAB           0000000000000000  00000230
       0000000000000027  0000000000000000           0     0     0
  [ 2] .symtab           SYMTAB           0000000000000000  00000257
       0000000000003348  0000000000000018           3   547     0
  [ 3] .strtab           STRTAB           0000000000000000  0000359f
       00000000000045b0  0000000000000000           0     0     0
  [ 4] .text             PROGBITS         0000000000018000  00008000
       0000000000015245  0000000000000000  AX       0     0     0
  [ 5] .data             PROGBITS         000000000002e000  0001e000
       00000000000010b7  0000000000000000  WA       0     0     0

Program Headers:
  Type           Offset             VirtAddr           PhysAddr
                 FileSiz            MemSiz              Flags  Align
  LOAD           0x0000000000008000 0x0000000000018000 0x0000000000000000
                 0x0000000000015245 0x0000000000015245  R E    0x0
  LOAD           0x000000000001e000 0x000000000002e000 0x0000000000000000
                 0x00000000000010b7 0x00000000000010b7  RW     0x0

Symbol table &#39;.symtab&#39; contains 547 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND
     1: 0000000000018326     0 FUNC    LOCAL  DEFAULT    4 __Booleans_u46kalyn__not
     2: 000000000001836e     0 FUNC    LOCAL  DEFAULT    4 __Booleans_u46kalyn__not_
     3: 00000000000183d5     0 FUNC    LOCAL  DEFAULT    4 __Booleans_u46kalyn__xor
     4: 000000000001841d     0 FUNC    LOCAL  DEFAULT    4 __Booleans_u46kalyn__xor_
     5: 000000000001847b     0 FUNC    LOCAL  DEFAULT    4 __Booleans_u46kalyn__xor_
     6: 000000000001f6c1     0 FUNC    LOCAL  DEFAULT    4 __DataTypes_u46kalyn__Cha
     ...
</code></pre>
<p>And now you know how program source code flows through the entire
Kalyn compiler stack to become an executable native binary.</p>
<h2 id="how-i-implemented-it" tabindex="-1">How I implemented it</h2>
<p>This section has a deep dive into each part of the compiler
implementation, touching on all of the interesting technical decisions
that I made.</p>
<h3 id="lexer-reader-and-parser" tabindex="-1">Lexer, reader, and parser</h3>
<ul>
<li><em>Haskell implementations:
<a href="https://github.com/raxod502/kalyn/blob/c2358a5778bdcf145fbd2b1c0eb2fbc349ce645d/src/Lexer.hs">Lexer</a>,
<a href="https://github.com/raxod502/kalyn/blob/c2358a5778bdcf145fbd2b1c0eb2fbc349ce645d/src/Reader.hs">Reader</a>,
<a href="https://github.com/raxod502/kalyn/blob/c2358a5778bdcf145fbd2b1c0eb2fbc349ce645d/src/Parser.hs">Parser</a></em></li>
<li><em>Kalyn implementations:
<a href="https://github.com/raxod502/kalyn/blob/c2358a5778bdcf145fbd2b1c0eb2fbc349ce645d/src-kalyn/Lexer.kalyn">Lexer</a>,
<a href="https://github.com/raxod502/kalyn/blob/c2358a5778bdcf145fbd2b1c0eb2fbc349ce645d/src-kalyn/Reader.kalyn">Reader</a>,
<a href="https://github.com/raxod502/kalyn/blob/c2358a5778bdcf145fbd2b1c0eb2fbc349ce645d/src-kalyn/Parser.kalyn">Parser</a></em></li>
</ul>
<p>The first step in the compiler is transforming source code into an
AST. I decided to split this process into three pieces, rather than
the usual two (lexing and parsing) or one (doing everything in the
parser). The reason is that it’s pretty easy to cleanly separate each
of the three steps, and doing this makes the implementation easier to
manage.</p>
<p>The reader, which handles the Lisp syntax of Kalyn, is implemented as
a <a href="https://en.wikipedia.org/wiki/Recursive_descent_parser">recursive descent
parser</a>. This
is a pretty simple task because there is not too much syntax and the
grammar is <a href="https://en.wikipedia.org/wiki/LL_parser">LL(1)</a> for
practical purposes. The Lisp syntax is the only part of Kalyn that
requires a real recursive descent parser, and by separating it out
into a separate reader module, I was able to make the parser itself
trivial: it simply needs to pattern-match on the lists that it
receives to decide which AST nodes they correspond to. Note that we
only get the easy LL(1) grammar because the lexer runs first and
converts runs of characters into single tokens. Without the lexer,
reader, and parser all being separate, the implementation would be
significantly more complex.</p>
<p>One thing to note about the lexer is that it doesn’t use regular
expressions, unlike most lexers, and no part of the stack uses a lexer
or parser generator. The reason for this is simple: if I had, then I
would have needed to implement the dependency (regular expressions,
lexer/parser generator) in Kalyn!</p>
<h3 id="standard-library" tabindex="-1">Standard library</h3>
<ul>
<li><em>Kalyn implementation:
<a href="https://github.com/raxod502/kalyn/tree/c2358a5778bdcf145fbd2b1c0eb2fbc349ce645d/src-kalyn/Stdlib">Stdlib</a></em></li>
</ul>
<p>By design, Kalyn omits most useful features from the core language,
deferring them instead to user-defined functions and algebraic data
types. So I needed to implement all of the data structures that I
wanted to use in the compiler. For the most part, this was just lists,
booleans, maps, and sets.</p>
<p>Lists and booleans were fairly easy. The main challenge was simply
implementing the large volume of standard library functions that I
needed in order to manipulate them properly. There are a total of 139
public functions in the Kalyn standard library, with almost all of the
names lifted directly from Haskell. I wrote most of them myself
because the Haskell standard library is pretty easy to implement for
the most part; for example, here is a typical function from
<code>Stdlib/Lists.kalyn</code>:</p>
<pre><code>(public defn drop (Func Int (List a) (List a))
  (n elts)
  (if (&lt;=Int n 0)
    elts
    (case elts
      (Null Null)
      ((Cons fst rst)
       (drop (- n 1) rst)))))
</code></pre>
<p>I did certainly have some tricky bugs caused by misimplemented
standard library functions, though.</p>
<p>The main challenge – and in fact the very first thing I implemented
in Kalyn, to make sure everything was working – was maps and sets. I
elected to use <a href="https://en.wikipedia.org/wiki/Splay_tree">splay
trees</a>, because they are one
of the simplest self-balancing trees to implement. A data structure
that did not have $$ O(n \log n) $$ operations would not be
acceptable, because the Kalyn compiler makes <em>heavy</em> use of very large
maps, and I anticipated (correctly) that Kalyn would run slowly enough
to make compiler performance an issue.</p>
<p>In retrospect, splay trees are not actually the right choice for any
standard library implementation in a functional language, because the
amortized analysis of splay trees requires that lookups be able to
mutate the tree. Unfortunately, this can’t be implemented in a
language that doesn’t support mutation without changing the interface
of map lookups, an unacceptable burden. <a href="https://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-Map-Strict.html">Haskell uses <em>size-balanced
binary
trees</em></a>.
Having noticed this problem only late into the project, I elected to
hope that my trees wouldn’t perform <em>too</em> poorly if rebalancing on
lookup were omitted. It seems to be good enough.</p>
<p>Self-balancing trees are quite tricky to implement, especially in a
functional language, so I stole a Haskell implementation from the
<a href="http://hackage.haskell.org/package/TreeStructures-0.0.2">TreeStructures</a>
package on Hackage. It did turn out that this implementation had
several bugs, which were a joy to discover while tracking down
seemingly unrelated issues in the compiler, but I was able to fix them
and Kalyn’s maps seem pretty robust now.</p>
<p>What about sets? They are just maps whose values are the <code>Empty</code>
algebraic data type that has one constructor and no fields. This
wastes space (each key-value mapping stores an extra zero), but that’s
hardly the worst memory offense of Kalyn, so I judged it to be fine.
The <code>Stdlib/Collections/Sets.kalyn</code> module has adapter functions that
wrap the map module to remove references to map values.</p>
<p>There’s one other interesting part of the standard library, which are
the typeclass instances. As I mentioned earlier, Kalyn doesn’t support
typeclasses at the moment, which was a bit tricky to deal with since
the Haskell implementation makes heavy use of the typeclass functions
<code>show</code>, <code>compare</code>, <code>(==)</code>, and <code>&gt;&gt;=</code>. My approach was to make every
function with a typeclass constraint instead take an additional
parameter which is a concrete instance of the typeclass function. So,
for example, when constructing a map of strings, you pass in the
<code>compareString</code> function. If you want to convert a list to a string,
you call the <code>showList</code> function and pass it also the appropriate
<code>showInt</code> or <code>showString</code> or whatever is appropriate for your element
type. Finding the index of an integer in a list requires passing
<code>elem</code> the <code>==Int</code> function. And so on.</p>
<p>Again as I mentioned earlier, this approach unfortunately does not
work for <code>&gt;&gt;=</code>. Luckily, we only use two important monads: <code>IO</code> and
<code>State</code> (the latter being a simple encapsulation of stateful
computation provided by the
<a href="https://hackage.haskell.org/package/mtl-2.2.2">mtl</a> package). I
simply implemented the relevant monadic combinators for each instance
that needed them (<code>mapMState</code>, <code>foldMState</code>, <code>replicateMState</code>,
<code>fmapIO</code>, <code>mapMIO</code>, etc.). Note that nothing about monads makes them
need special compiler support: only the side-effecting nature of the
<code>IO</code> monad requires extra primitives. So <code>State</code> is implemented
entirely in user code.</p>
<h3 id="bundler-and-resolver" tabindex="-1">Bundler and resolver</h3>
<ul>
<li><em>Haskell implementations:
<a href="https://github.com/raxod502/kalyn/blob/c2358a5778bdcf145fbd2b1c0eb2fbc349ce645d/src/Bundler.hs">Bundler</a>,
<a href="https://github.com/raxod502/kalyn/blob/c2358a5778bdcf145fbd2b1c0eb2fbc349ce645d/src/Resolver.hs">Resolver</a></em></li>
<li><em>Kalyn implementations:
<a href="https://github.com/raxod502/kalyn/blob/c2358a5778bdcf145fbd2b1c0eb2fbc349ce645d/src-kalyn/Bundler.kalyn">Bundler</a>,
<a href="https://github.com/raxod502/kalyn/blob/c2358a5778bdcf145fbd2b1c0eb2fbc349ce645d/src-kalyn/Resolver.kalyn">Resolver</a></em></li>
</ul>
<p>There’s not much to say about the bundler. The main decision I made
there was to make it responsible not only for reading all the modules
but also for resolving their transitive imports. I did this primarily
because resolving transitive imports requires a graph traversal
algorithm and I wanted to isolate this from the already-complex logic
of the resolver.</p>
<p>Now, the resolver is one of the biggest modules in the compiler, even
though it ostensibly doesn’t do anything very complicated. There are
just a lot of little things to take care of. The first thing to talk
about is the name mangling scheme.</p>
<p>Step 1 is to uniquify module names. By default we just prepend each
symbol’s name with the name of its module. This ensures that symbols
from different modules do not conflict. (If two imported modules <code>A</code>
and <code>B</code> define a symbol <code>Sym</code> by the same name, then we’ll get
<code>A__Sym</code> and <code>B__Sym</code>, and the resolver will report a conflict because
it’s not clear whether <code>Sym</code> in the current module should resolve to
<code>A__Sym</code> or <code>B__Sym</code>.)</p>
<p>Now, it is possible that we have both <code>Stdlib/A.kalyn</code> and
<code>User/A.kalyn</code>, in which case we try <code>StdlibA</code> and <code>UserA</code> to see if
this disambiguates all the modules. Otherwise we keep looking
backwards at the full paths until we have a unique prefix for each
module.</p>
<p>Step 2 is to sanitize module and symbol names so that they are safe to
use in assembly. This is mainly to make it so that the <code>.S</code> files
generated by Kalyn have valid syntax and can be compiled using GCC if
for some reason we want to bypass Kalyn’s assembler and linker. We
just replace non-alphanumeric characters with underscore-based escape
sequences. For example, the function <code>set\\</code> provided by <code>Sets.kalyn</code>
might encode to <code>set_u92_u92</code> with a module prefix of <code>Sets_u46kalyn</code>.</p>
<p>Step 3 is to combine the parts. By eliminating underscores in step 2,
we make it possible to use them to unambiguously namespace our
symbols. In Kalyn, all user-defined symbols start with <code>__</code>, and the
module and symbol names are separated by another <code>__</code>. This namespaces
the user symbols while reserving symbol names <em>not</em> starting with <code>__</code>
for our use (e.g. primitives like <code>print</code>). Combining everything
above, the actual full name of <code>set\\</code> from
<code>Stdlib/Collections/Sets.kalyn</code> is
<code>__StdlibCollectionsSets_u46kalyn__set_u92_u92</code>. Beautiful!</p>
<p>The rest of the resolver is long, but not terribly interesting. We
just traverse the bundle and iterate through transitive imports to
find out which fully resolved symbol each name should map to. In the
process, we collect information about symbol types, data constructor
fields, and type aliases from the top-level AST nodes. Here is an
excerpt from the returned mapping, which as you can see has a bit too
much information to read comfortably:</p>
<pre><code>module &#34;/home/raxod502/files/school/hmc/senior/spring/compilers/kalyn/src-kalyn/Main.kalyn&#34;
  ...
  &gt;&gt;=State -&gt; regular symbol __States_u46kalyn___u62_u62_u61State with type (Func (__DataTypes_u46kalyn__State s a) (Func (Func a (__DataTypes_u46kalyn__State s b)) (__DataTypes_u46kalyn__State s b))) (and 2 sublambdas)
  &gt;Int -&gt; regular symbol greaterThan with type (Func Int (Func Int __DataTypes_u46kalyn__Bool)) (and 2 sublambdas)
  Char -&gt; data constructor __DataTypes_u46kalyn__Char with index 0 out of 1 and 1 field (unboxed, no header word, field type __DataTypes_u46kalyn__Word8 for type spec __DataTypes_u46kalyn__Char)
  ...
    __Sets_u46kalyn__Set k -&gt; (__Maps_u46kalyn__Map k __DataTypes_u46kalyn__Empty)
    ...
</code></pre>
<p>(The actual mapping is around 3,900 lines of this.)</p>
<h3 id="type-checker" tabindex="-1">Type checker</h3>
<ul>
<li><em>Haskell implementation:
<a href="https://github.com/raxod502/kalyn/blob/c2358a5778bdcf145fbd2b1c0eb2fbc349ce645d/src/TypeChecker.hs">TypeChecker</a></em></li>
</ul>
<p>The type checker is perhaps the most interesting part of the compiler,
at least to me. It uses a constraint solving algorithm similar to that
used in Haskell. To illustrate how it works, let’s consider an
example, the standard library function <code>curry</code>, but the type signature
of <code>uncurry</code>:</p>
<pre><code>(defn curry (Func (Func a b c)
                  (Func (Pair a b) c))
  (f a b)
  (f (Pair a b)))
</code></pre>
<p>This desugars to the following declaration:</p>
<pre><code>(def curry (Func (Func a b c)
                 (Func (Pair a b) c))
  (lambda (f)
    (lambda (a)
      (lambda (b)
        (f ((Pair a) b))))))
</code></pre>
<p>Step 1 is to assign numerical identifiers to every expression and type
parameter in the declaration. That looks like this, using real numbers
from the type checker:</p>
<pre><code>;               0           1 2 3
;               :           : : :
     (def curry (Func (Func a b c)

;                                 1 2  3
;                                 : :  :
                      (Func (Pair a b) c))

;      0        4
;      :        :
       (lambda (f)

;        5        6
;        :        :
         (lambda (a)

;          7        8
;          :        :
           (lambda (b)

;            9  10 11 12 14   15 13
;            :  :  :  :  :    :  :
             (  f  (  (  Pair a) b))))))

;    14            16      17      16 17
;    :             :       :       :  :
     Pair :: (Func a (Func b (Pair a  b)))
</code></pre>
<p>In this numbering, we have:</p>
<ul>
<li>Local variables (4, 6, 8)</li>
<li>Intermediate expressions (5, 7, 9, 10, 11, 12, 13, 15)</li>
<li>Global symbols (0, 14)</li>
<li>Type parameters in global symbols (1, 2, 3, 16, 17)</li>
</ul>
<p>Step 2 is to generate a list of constraints based on how these
numerical identifiers appear in expressions relative to one another.
Here is the actual list of constraints generated by the type checker:</p>
<ul>
<li><code>0 == Func (Func 1 (Func 2 3)) (Func (Pair 1 2) 3)</code> (from type of
top-level symbol <code>curry</code>)</li>
<li><code>0 == Func 4 5</code> (from argument and return type of <code>lambda (f)</code>)</li>
<li><code>5 == Func 6 7</code> (from argument and return type <code>lambda (a)</code>)</li>
<li><code>7 == Func 8 9</code> (from argument and return type <code>lambda (b)</code>)</li>
<li><code>10 == Func 11 9</code> (because <code>f</code> is applied to <code>((Pair a) b)</code>)</li>
<li><code>10 == 4</code> (because <code>f</code> is bound by an enclosing <code>lambda</code>)</li>
<li><code>12 == Func 13 11</code> (because <code>Pair a</code> is applied to <code>b</code>)</li>
<li><code>14 == Func 15 12</code> (because <code>Pair</code> is applied to <code>a</code>)</li>
<li><code>14 == Func 16 (Func 17 (Pair 16 17))</code> (from type of top-level data
constructor <code>Pair</code>)</li>
<li><code>15 == 6</code> (because <code>a</code> is bound by an enclosing <code>lambda</code>)</li>
<li><code>13 == 8</code> (because <code>b</code> is bound by an enclosing <code>lambda</code>)</li>
</ul>
<p>Step 3 is to <em>unify</em> these constraints, one by one, to see if there
are any inconsistencies between them. We start with an empty mapping,
and then fill it up by processing the constraints.</p>
<ul>
<li><code>0 == Func (Func 1 (Func 2 3)) (Func (Pair 1 2) 3)</code>: Set <code>0</code> to
<code>Func (Func 1 (Func 2 3)) (Func (Pair 1 2) 3)</code> in our mapping.</li>
<li><code>0 == Func 4 5</code>: We want to set <code>0</code> to <code>Func 4 5</code>, but <code>0</code> already
has a value <code>Func (Func 1 (Func 2 3)) (Func (Pair 1 2) 3)</code>. We must
<em>unify</em> the two structures. Fortunately, both start with <code>Func</code>.
Otherwise, we would report a type error. To unify, we set <code>4</code> to
<code>Func 1 (Func 2 3)</code> and set <code>5</code> to <code>Func (Pair 1 2) 3</code>.</li>
<li><code>5 == Func 6 7</code>: Set <code>5</code> to <code>Func 6 7</code>.</li>
<li><code>7 == Func 8 9</code>: Set <code>7</code> to <code>Func 8 9</code>.</li>
<li><code>10 == Func 11 9</code>: Set <code>10</code> to <code>Func 11 9</code>.</li>
<li><code>10 == 4</code>: We want to set <code>10</code> to <code>4</code>, but <code>10</code> already has a value
<code>Func 11 9</code>. Thus we try to set <code>4</code> to <code>Func 11 9</code> instead. Since
<code>4</code> already has a value <code>Func 1 (Func 2 3)</code>, we must again unify. We
set <code>1</code> to <code>11</code> and set <code>9</code> to <code>Func 2 3</code>.</li>
<li><code>12 == Func 13 11</code>: Set <code>12</code> to <code>Func 13 11</code>.</li>
<li><code>14 == Func 15 12</code>: Set <code>14</code> to <code>Func 15 12</code>.</li>
<li><code>14 == Func 16 (Func 17 (Pair 16 17))</code>: We want to set <code>14</code> to <code>Func 16 (Func 17 (Pair 16 17))</code>, but <code>14</code> already has a value <code>Func 15 12</code>. We must unify. First we set <code>15</code> to <code>16</code>. Then we want to set
<code>12</code> to <code>Func 17 (Pair 16 17)</code>, but <code>12</code> already has a value <code>Func 13 11</code>. We can unify these by setting <code>13</code> to <code>17</code> and <code>11</code> to <code>Pair 16 17</code>.</li>
<li><code>15 == 6</code>: We want to set <code>15</code> to <code>6</code>, but <code>15</code> already has a value
<code>16</code>, so we instead set <code>16</code> to <code>6</code>.</li>
<li><code>13 == 8</code>: We want to set <code>13</code> to <code>8</code>, but <code>13</code> already has a value
<code>17</code>, so we instead set <code>17</code> to <code>8</code>.</li>
</ul>
<p>Here is the resulting mapping:</p>
<pre><code> 0 -&gt; Func (Func 1 (Func 2 3)) (Func (Pair 1 2) 3)`
 1 -&gt; 11
 4 -&gt; 5
 5 -&gt; Func 6 7
 7 -&gt; Func 8 9
 9 -&gt; Func 2 3
10 -&gt; Func 11 9
11 -&gt; Pair 16 17
12 -&gt; Func 13 11
13 -&gt; 17
14 -&gt; Func 15 12
15 -&gt; 16
16 -&gt; 6
17 -&gt; 8
</code></pre>
<p>Why didn’t we get a type error? Let’s take a closer look at our
mapping. It says that in order to make everything unify, <code>1</code> must be
<code>11</code>, and <code>11</code> must be <code>Pair 16 17</code>. But wait, <code>1</code> was the parameter
<code>a</code> in the type declaration for <code>curry</code>. The function as we’ve written
it only type-checks if <code>a</code> is a <code>Pair</code>, which is not included in the
type signature. So we have to check to make sure that any free type
parameters are not set in our mapping to specific types, and signal a
type error if they are.</p>
<p>Unfortunately, even after accounting for this, there’s an even more
subtle bug that can occur. Consider this code:</p>
<pre><code>(def bug Int
  (let ((recur
         (lambda ((Cons elt elts))
           (recur elt))))
    (length (recur Null))))
</code></pre>
<p>It clearly should not type-check because the <code>recur</code> function takes a
list of elements yet passes itself a single element. However, if you
run the unification algorithm described above, you’ll find a distinct
lack of any unification or free type parameter errors. Let’s look at
the resulting mapping, courtesy of Kalyn’s type checker:</p>
<pre><code> 0 -&gt; 2
 1 -&gt; Func 15 12
 2 -&gt; Int
 3 -&gt; List 8
 4 -&gt; List 13
 5 -&gt; List 8
 6 -&gt; List 16
 7 -&gt; List 8
 8 -&gt; List 16
 9 -&gt; 1
10 -&gt; 6
11 -&gt; Func (List 13) Int
12 -&gt; List 13
14 -&gt; 1
15 -&gt; List 16
16 -&gt; List 16
</code></pre>
<p>Hmmm… what’s going on with <code>16</code>? That turns out to the type of the
argument to <code>recur</code>! We have <code>16 == List 16 == List (List 16) == List (List (List 16))</code> and so on. If you think about it, this kind of makes
sense. The argument is <code>16</code>. From the destructuring, we know <code>16</code> is a
list of elements. But one of those elements is passed as the argument
to <code>recur</code>, so it must also <code>16</code>. The algorithm concludes happily that
<code>16</code> is list of itself. To avoid this problem, we have to manually
check after unification that no type references itself as a field of a
data constructor, either directly or indirectly.</p>
<p>Haskell programmers will recognize unification errors from GHC’s
<code>Expected type / Actual type</code> messages, free type parameter errors
from its <code>Couldn&#39;t match expected type ... a1 is a rigid type variable</code> messages, and of course <code>cannot construct the infinite type: a = [a]</code>. Needless to say, Haskell’s type errors are extremely
difficult to interpret, and frequently the only remedy is to stare at
the offending expression until it becomes clear what is wrong. The
same is true of Kalyn. Producing meaningful type errors for a language
with implicit currying is a difficult problem because any given type
error could be solved by any number of different changes to the code.</p>
<h3 id="translator-code-generator" tabindex="-1">Translator (code generator)</h3>
<ul>
<li><em>Haskell implementation:
<a href="https://github.com/raxod502/kalyn/blob/c2358a5778bdcf145fbd2b1c0eb2fbc349ce645d/src/Translator.hs">Translator</a></em></li>
<li><em>Kalyn implementation:
<a href="https://github.com/raxod502/kalyn/blob/c2358a5778bdcf145fbd2b1c0eb2fbc349ce645d/src-kalyn/Translator.kalyn">Translator</a></em></li>
</ul>
<p>The translator is by far the largest component of the compiler. Many
compilers have a number of intermediate languages between the AST and
raw assembly, but Kalyn does translation in a single step. This is
largely because Kalyn is such a simple language that there are really
only a few types of constructs to translate, and it is difficult to
come up with an intermediate language that would helpfully represent
the important parts of these constructs.</p>
<p>The main challenge of the translator is dealing with the fact that
Kalyn uses a radically different programming style than assembly,
unlike (for example) C, C++, Java, or Swift, which can all be
translated fairly directly. On the other hand, one nice thing about
Kalyn is that there are only about three constructs to figure out how
to translate (function calls, lambdas, and pattern matching), and
every other language feature doesn’t need any special support from the
compiler. For example, in Java one would need to translate objects,
classes, arrays, strings, etc., but in Kalyn all of these things (or
their equivalents) are simply part of user code.</p>
<h4 id="function-calls" tabindex="-1">Function calls</h4>
<p>Recall from earlier the in-memory representation of function objects:</p>
<pre><code>(let ((x 5)
      (y 7))
  (lambda (z)
    (+ (* z x) y)))

  code addr   num params  value of x  value of y
  .           .           .           .
  .           .           .           .
  .           .           .           .
+-----------+-----------+-----------+-----------+
| 0x821ad   | 2         | 5         | 7         |
+-----------+-----------+-----------+-----------+
</code></pre>
<p>Calling a function is fairly straightforward. Consider the following
function whose entire body is just a single function call:</p>
<pre><code>(defn call (Func (Func Int a) a)
  (func)
  (func 42))
</code></pre>
<p>Kalyn translates it like this:</p>
<pre><code>__Main_u46kalyn__call__uncurried:
        movq 16(%rbp), %t2
        movq %t2, %t4
        movq $42, %t5
        movq 8(%t4), %t7
        leaq 16(%t4), %t6
l9:
        cmpq $0, %t7
        jle l10
        pushq (%t6)
        addq $8, %t6
        dec %t7
        jmp l9
l10:
        pushq %t5
        callq *(%t4)
        movq 8(%t4), %t8
        leaq 8(%rsp, %t8, 8), %rsp
        movq %rax, %t3
        movq %t3, %rax
        retq
</code></pre>
<p>First we fetch the function object from the stack into <code>%t2</code>. Then we
extract the number of closure values from <code>%t7</code>, and enter a loop to
push all of them onto the stack in order, using <code>%t6</code> as a pointer
into the function object. Finally we push the formal argument to the
function, which is the value <code>42</code> in register <code>%t5</code>, and use <code>callq</code>
to perform an indirect call. After it finishes, we restore the stack.</p>
<p>Invoking an instance of the IO monad is very similar! The only
difference is that after pushing the values that were bundled in the
function object, we call immediately, instead of pushing an extra
argument.</p>
<h4 id="lambdas" tabindex="-1">Lambdas</h4>
<p>Okay, so now that we know how to <em>call</em> function objects, how do we
construct them? The main tricky thing here is dealing with closures.
When translating an expression, we have access to a map (originally
derived from the resolver, then augmented with local bindings) which
tells us whether any given name refers to a global symbol or to a
local variable (i.e., a virtual register like <code>%t42</code>).</p>
<p>Let’s suppose we want to translate the lambda expression from above:</p>
<pre><code>(let ((x 5)
      (y 7))
  (lambda (z)
    (+ (* z x) y)))
</code></pre>
<p>I think this is easier to explain without looking at the actual
assembly generated, which is a bit of a mess. First we want to
translate the <code>let</code>. We reserve temporaries (say <code>%t0</code>, <code>%t1</code>) for <code>x</code>
and <code>y</code>, and produce the following code:</p>
<pre><code>movq $5, %t0
movq $7, %t1
</code></pre>
<p>Now we need to create a function object. We start by inspecting the
<code>lambda</code> form recursively to find out what free variables it refers
to. Free variables are variables that are not bound by an enclosing
<code>let</code> or <code>lambda</code>. The <code>let</code> expression <em>as a whole</em> has no free
variables, but if we only look at the <code>lambda</code>, we see that the free
variables are <code>x</code> and <code>y</code>. Now we know what to put in the closure of
the function. We generate something like the following pseudocode:</p>
<pre><code>obj    := malloc(32)
obj[0] := address of lambda body&#39;s code
obj[1] := 2
obj[2] := %t0
obj[3] := %t1
</code></pre>
<p>That’s it for the function object, but now we need to deal with the
<em>body</em> of the <code>lambda</code> form. This doesn’t go into the same function as
the code above, since it might get executed later in a totally
different context (maybe it got returned from one function and then
passed into <code>map</code> in another). Let’s say the <code>lambda</code> form appeared
inside the function <code>__Main_u46kalyn__closure</code>. Then we would come up
with a fresh name for the body code, for example
<code>__Main_u46kalyn__closure__lambda15__x_y_z</code> (where the closure and
function argument get stuck in the label just for the sake of us
humans trying to read the assembly).</p>
<p>Now, when the lambda function is invoked, its argument and closure are
all on the stack, but how does it know what order they are in? This is
taken care of by the translator. When we notice that the lambda has
<code>x</code> and <code>y</code> in its closure, we automatically come up with two new
temporaries, say <code>%t2</code> and <code>%t3</code>, to store their values <em>within the
lambda</em>. (On the other hand, <code>%t0</code> and <code>%t1</code> stored the values of <code>x</code>
and <code>y</code> <em>outside</em> the lambda.) We also come up with a temporary <code>%t4</code>
for the function argument <code>z</code>. Then we stick this code at the front of
the lambda’s body:</p>
<pre><code>%t2 := first argument from stack
%t3 := second argument from stack
%t4 := third argument from stack
</code></pre>
<p>Finally, when we recursively translate the body of the lambda, we
update its map to tell it that <code>x</code> is in <code>%t2</code>, <code>y</code> is in <code>%t3</code>, and
<code>z</code> is in <code>%t4</code>. This cooperation between caller and callee is
necessary to make sure all the arguments and closure values get where
they need to go.</p>
<h4 id="data-constructors-and-pattern-matching" tabindex="-1">Data constructors and pattern matching</h4>
<p>The first two challenges of the translator were the paired operations
of function creation and function calls. Next up was another key pair
of operations: construction and matching of algebraic data types.</p>
<p>Data <em>constructors</em> are fairly straightforward. For example, the data
constructor <code>Pair</code> defined by the code</p>
<pre><code>(data (Pair a b)
  (Pair a b))
</code></pre>
<p>is essentially the same as</p>
<pre><code>(def Pair (Func a b (Pair a b))
  (lambda (a)
    (lambda (b)
      (MakePair a b))))
</code></pre>
<p>where <code>MakePair</code> is an uncurried function that takes two arguments,
allocates space for a <code>Pair</code> on the heap, and puts the arguments in
its fields. Using this transformation, we can translate data
constructors using similar code to what we used for lambdas above. In
fact, we have to do a similar thing to handle primitive functions (as
I discuss below), so there’s a subroutine in the Kalyn compiler
specifically for taking an uncurried function like <code>MakePair</code> and
generating the series of wrappers that allow it to be called in
curried fashion.</p>
<p>Pattern matching requires more code due to the need to handle nested
patterns, although it is fairly straightforward in Kalyn. There are
many cool optimizations that can be done on <code>case</code> patterns to decide
what order to perform checks in and how to avoid repeating work. Of
course, we do none of these optimizations, so we translate <code>case</code>
statements simply as a sequence of straightforward checks. First,
recall the definition of lists in Kalyn and their in-memory
representation:</p>
<pre><code>(data (List a)
  Null (Cons a (List a)))

        ctor idx
        .
        .
        .
      +-----------+
Null  | 0         |
      +-----------+

        ctor idx    head        tail
        .           .           .
        .           .           .
        .           .           .
      +-----------+-----------+-----------+
Cons  | 1         | ****      | ****      |
      +-----------+-----------+-----------+
</code></pre>
<p>Consider this expression:</p>
<pre><code>(case list
  (Null
   first)
  ((Cons x Null)
   (second x))
  ((Cons 42 <a href="https://intuitiveexplanations.com/cdn-cgi/l/email-protection" data-cfemail="443c3704">[email protected]</a>(Cons x _))
   (third x xs)))
</code></pre>
<p>We can translate it like this:</p>
<pre><code>case0:
    if list[0] != 0 then     (check if Null)
      goto case1
    result := first
    goto done
case1:
    if list[0] != 1 then     (check if Cons)
      goto case2
    if list[2][0] != 0 then  (check if tail is Null)
      goto case2
    x := list[1]
    result := (second x)
    goto done
case2:
    if list[0] != 1 then     (check if Cons)
      goto case3
    if list[1] != 42 then    (check if head is 42)
      goto case3
    if list[2][0] != 1 then  (check if tail is Cons)
    xs := list[2]
    x := list[2][1]
    result := (third x xs)
    goto done
case3:
    error &#34;pattern match failed&#34;
done:
    return result
</code></pre>
<p>The small optimizations Kalyn <em>does</em> do relate to the memory
representation of algebraic data types. Recall that the header word
indicating constructor index is only included if there is actually
more than one constructor. So, when pattern-matching an ADT like
<code>Pair</code>, we don’t need to check the constructor index. No extra cost!
Likewise, since the <code>Bool</code> ADT has no fields, there’s no need to put
it behind a pointer, so <code>if</code> “statements” in Kalyn just involve
integer comparisons.</p>
<h4 id="optimizing-function-calls" tabindex="-1">Optimizing function calls</h4>
<p>One thing you may have noticed is that function calls in Kalyn take
time $$ O(n^2) $$ in the number of arguments. First you have to call
the base function with one argument, then you call the returned
function with a closure value and the next argument, then you call the
new returned function with two closure values and the next argument,
and so on. Furthermore, each call requires a loop because you don’t
necessarily know how many closure arguments there were already. This
is clearly a bit distressing for a language whose programs are
composed almost entirely out of a huge number of function calls. Upon
finding that Kalyn was not fast enough to compile itself, I
implemented what I thought would be the highest-value simple
optimization, which is $$ O(n) $$ function calls.</p>
<p>The idea is pretty simple. We can’t optimize all function calls,
because (for example) when <code>map</code> gets passed a function, it doesn’t
know the size of its closure, so it has to do the full indirect call.
But when we’re calling a function that’s globally defined, why not
just push all the arguments right away and jump into the inner lambda?
To make this happen, I did a few things.</p>
<p>Firstly, I made the resolver inspect the AST declarations and see how
many top-level lambdas were in each symbol definition (this is
equivalent to the number of function arguments, since function
declarations expand to nested lambdas). Next, I modified the
translator so that it would detect when it was translating a top-level
lambda and give it a predictable name. For example, consider the
following standard library function:</p>
<pre><code>(defn foldr (Func (Func a b b) b (List a) b)
  (func init elts)
  (case elts
    (Null init)
    ((Cons fst rst)
     (func fst (foldr func init rst)))))
</code></pre>
<p>Before the change, we would get these functions:</p>
<ul>
<li><code>__src_u45kalynStdlibLists_u46kalyn__foldr</code></li>
<li><code>__src_u45kalynStdlibLists_u46kalyn__foldr__lambda30479__func</code></li>
<li><code>__src_u45kalynStdlibLists_u46kalyn__foldr__lambda30483__func_init</code></li>
<li><code>__src_u45kalynStdlibLists_u46kalyn__foldr__lambda30488__func_init_elts</code></li>
</ul>
<p>Aside from being a real mouthful, these functions don’t have
predictable names. After the change, we instead get these functions:</p>
<ul>
<li><code>__src_u45kalynStdlibLists_u46kalyn__foldr</code></li>
<li><code>__src_u45kalynStdlibLists_u46kalyn__foldr__curried0</code></li>
<li><code>__src_u45kalynStdlibLists_u46kalyn__foldr__curried1</code></li>
<li><code>__src_u45kalynStdlibLists_u46kalyn__foldr__uncurried</code></li>
</ul>
<p>Of course, non-top-level lambdas are still translated like before.</p>
<p>The next step was to update the translator so that it would make
direct calls when possible. Essentially, when translating a call in
the AST, we inspect the left-hand side to see if it’s a globally bound
symbol with top-level lambdas. If so, we unwind the AST to see how
many arguments the function is being passed, and jump directly into
the appropriate inner lambda. This change produced a big improvement
in runtime, although possibly not for the reason you would guess. (See
the section on register allocation.)</p>
<p>One particularly tricky aspect of this optimization is that more
bookkeeping is required when translating lambdas. Recall from the
section on lambda translation that the caller and callee must
cooperate about which order the closure arguments go in. This is fine
when a lambda function is only used from its directly containing
expression. However, now that top-level lambdas can be called directly
from other functions, those other functions must also cooperate with
the lambda about argument order: the order of the closure values
suddenly has become part of the public API of the lambda. The solution
is to add bookkeeping to the translator to keep track of the argument
order in top-level lambdas and force it to conform to what appears in
the code.</p>
<h3 id="primitive-functions-and-bridge" tabindex="-1">Primitive functions and bridge</h3>
<ul>
<li><em>Haskell implementations:
<a href="https://github.com/raxod502/kalyn/blob/c2358a5778bdcf145fbd2b1c0eb2fbc349ce645d/src/Subroutines.hs">Subroutines</a>,
<a href="https://github.com/raxod502/kalyn/blob/c2358a5778bdcf145fbd2b1c0eb2fbc349ce645d/src/Primitives.hs">Primitives</a>,
<a href="https://github.com/raxod502/kalyn/blob/c2358a5778bdcf145fbd2b1c0eb2fbc349ce645d/src/Bridge.hs">Bridge</a></em></li>
<li><em>Kalyn implementations:
<a href="https://github.com/raxod502/kalyn/blob/c2358a5778bdcf145fbd2b1c0eb2fbc349ce645d/src-kalyn/Subroutines.kalyn">Subroutines</a>,
<a href="https://github.com/raxod502/kalyn/blob/c2358a5778bdcf145fbd2b1c0eb2fbc349ce645d/src-kalyn/Primitives.kalyn">Primitives</a>,
<a href="https://github.com/raxod502/kalyn/blob/c2358a5778bdcf145fbd2b1c0eb2fbc349ce645d/src-kalyn/Bridge.kalyn">Bridge</a></em></li>
</ul>
<p>The translator handles user code, but that’s not the only thing needed
for a functioning binary. Some operations need to be implemented
directly in assembly, such as arithmetic and IO.</p>
<p>The <em>Primitives</em> module has a collection of such hand-rolled assembly
functions. The arithmetic operators are pretty simple: they just read
arguments from the stack and run them through an <code>addq</code> or <code>idivq</code>
instruction before returning. The IO functions are more complex.
Primarily, each one wraps a sequence of system calls and handles the
relevant memory allocation and error checking. For example,
<code>writeFile</code> wraps the <code>unlink</code>, <code>open</code>, <code>write</code>, and <code>close</code> system
calls, while <code>setFileMode</code> uses (appropriately enough) the <code>chmod</code>
system call.</p>
<p>The <em>Subroutines</em> module, along with various utility functions for
things like getting arguments from the stack and performing function
calls, includes two core data transformation functions, <code>packString</code>
and <code>unpackString</code>. Kalyn’s strings are (very bloated) linked lists of
characters, while system calls like <code>read</code> and <code>write</code> operate on C
strings or raw character buffers. Using hand-written copying loops and
some calls to the memory allocator, <code>packString</code> and <code>unpackString</code>
implement a two-way map between OS strings and Kalyn
linked-list-strings.</p>
<p>Also in the <em>Subroutines</em> module is a pair of function generators,
<code>curryify</code> and <code>monadify</code>. These generators take an uncurried or
side-effecting function and create additional wrapper functions that
support calling it in a curried or monadic way. This allows primitives
to be called from user code in the same way that any other function
would be, and it also supports the generation of curried data
constructors in the translator.</p>
<p>Finally, the <em>Bridge</em> module defines how all of these user and
primitive functions work together to form a complete program. It
presents all of the available primitives, including a mapping from
their user-code-facing names to their internal assembly names, their
types (declared by fiat), and the number of arguments they take (for
direct function call optimization). When all the user functions in a
program have been translated, they are scanned to find calls to
primitives, and only those primitives are included in the final
binary.</p>
<h3 id="memory-management" tabindex="-1">Memory management</h3>
<ul>
<li><em>Haskell implementation:
<a href="https://github.com/raxod502/kalyn/blob/c2358a5778bdcf145fbd2b1c0eb2fbc349ce645d/src/MemoryManager.hs">MemoryManager</a></em></li>
<li><em>Kalyn implementation:
<a href="https://github.com/raxod502/kalyn/blob/c2358a5778bdcf145fbd2b1c0eb2fbc349ce645d/src-kalyn/MemoryManager.kalyn">MemoryManager</a></em></li>
</ul>
<p>Typically, memory allocation using <code>malloc</code> is considered quite
low-level enough. We need to go even lower-level to implement our own
<code>malloc</code>. On Linux, process memory allocation is handled by means of
the <code>mmap</code> and <code>brk</code> system calls. Most modern programs use <code>mmap</code> and
<code>brk</code> is as a result somewhat discouraged, but <code>brk</code> is simpler so
that’s what Kalyn uses.</p>
<p>To understand <code>brk</code>, we need to know a little about the Linux process
execution model. In principle, when a process is executed, memory
looks something like this (although the picture is massively
simplified and somewhat wrong):</p>
<pre><code>+----------------------+
|                      |
|        Stack         |
|                      | &lt;-- stack pointers (%rsp, %rbp)
+----------------------+


          ...


+----------------------+ &lt;-- program break
|                      |
|     Data section     |
|                      |
+----------------------+
|                      |
|     Code section     |
|                      | &lt;-- instruction pointer (%rip)
+----------------------+
</code></pre>
<p>At one end of the address space are the instructions and data from the
binary, and at the other end is the stack. In between is a large
region of unmapped memory. The operating system sets all of this up
when executing a program.</p>
<p>At the end of the data section is a marker known as the <em>program
break</em>. This marks the end of the region of the address space that the
program can use. Using the <code>brk</code> system call, a program can adjust the
position of the program break. By increasing the program break, the
program can obtain additional memory to use for its heap, and then
parcel out that memory as it is needed.</p>
<p>Kalyn’s memory allocator is quite simple. At startup, it queries the
location of the program break. When user code or a primitive requests
memory from the heap, the allocator increments a pointer for the last
free byte on the heap. Once this pointer reaches the program break,
the allocator uses <code>brk</code> to request more heap space from the operating
system.</p>
<p>What about memory <em>deallocation</em>? Well… we don’t bother! That might
sound bad, but I made the guess that our compiler wouldn’t allocate
<em>so much</em> memory that it would actually run out. Modern systems have a
lot of RAM, after all. And in fact my compiler can successfully
compile itself without a <a href="https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)">garbage
collector</a>.</p>
<p>So how much RAM does it use, exactly? Well… I didn’t realize this
until after finishing the project, but in fact around 40 GB. I commend
the brilliant engineers of Linux for designing an operating system
kernel that can deal with people like me. Here, check it out:</p>

<p>Conclusion: Kalyn probably needs a GC.</p>
<h3 id="register-allocation-liveness-analysis-and-function-boilerplate" tabindex="-1">Register allocation, liveness analysis, and function boilerplate</h3>
<ul>
<li><em>Haskell implementations:
<a href="https://github.com/raxod502/kalyn/blob/c2358a5778bdcf145fbd2b1c0eb2fbc349ce645d/src/Liveness.hs">Liveness</a>,
<a href="https://github.com/raxod502/kalyn/blob/c2358a5778bdcf145fbd2b1c0eb2fbc349ce645d/src/RegisterAllocator.hs">RegisterAllocator</a>,
<a href="https://github.com/raxod502/kalyn/blob/c2358a5778bdcf145fbd2b1c0eb2fbc349ce645d/src/Boilerplate.hs">Boilerplate</a></em></li>
<li><em>Kalyn implementations:
<a href="https://github.com/raxod502/kalyn/blob/c2358a5778bdcf145fbd2b1c0eb2fbc349ce645d/src-kalyn/Liveness.kalyn">Liveness</a>,
<a href="https://github.com/raxod502/kalyn/blob/c2358a5778bdcf145fbd2b1c0eb2fbc349ce645d/src-kalyn/RegisterAllocator.kalyn">RegisterAllocator</a>,
<a href="https://github.com/raxod502/kalyn/blob/c2358a5778bdcf145fbd2b1c0eb2fbc349ce645d/src-kalyn/Boilerplate.kalyn">Boilerplate</a></em></li>
</ul>
<p><a href="https://en.wikipedia.org/wiki/Register_allocation">Register
allocation</a> is the
part of Kalyn that gave me the most grief by far. Not because it was
hard, but because it was slow. It takes more time than any other stage
of the compiler, and even after optimizing it to run about 1,200 times
faster, it still takes 25 seconds to run in the Kalyn implementation
(out of a total of 45 seconds for compiling the compiler).</p>
<p>Most effective register allocation algorithms start with an iterative
<a href="https://en.wikipedia.org/wiki/Live_variable_analysis">liveness
analysis</a>, as I
mentioned earlier. For each instruction, we retrieve a set of
registers that it reads from and a set of registers that it writes
from. Then, by analyzing local jumps, we build a flow graph for each
function that specifies the possible branches and paths of execution.
Finally, we use a set of rules to propagate liveness information
through the function until we converge to a <a href="https://en.wikipedia.org/wiki/Fixed_point_(mathematics)">fixed
point</a>.</p>
<p>One useful application of the liveness analysis, besides register
allocation, is that we can check for temporaries that are live at the
beginning of a function. If there are any, that means we might read
from a temporary that we never write to. This is the assembly
equivalent of an “undefined variable” error, and it proved to be
incredibly handy for catching bugs in the translator.</p>
<p>There are many useful optimizations for iterative liveness analysis,
but the main one that I implemented was to update liveness information
for the instructions of each function in a specific order. The
simplest approach is to just compute liveness information for every
instruction in the function in parallel, and then recompute it all
based on the updated information, repeating until the information no
longer changes. Instead, I updated the liveness information for one
instruction at a time, stepping backwards through the function, and
then repeated starting again from the end. This reduced the number of
iterations required for termination by a factor of 300 on average.</p>
<p>The other part of register allocation is using the liveness
information to assign registers to temporaries. One of the
conceptually simplest approaches to register allocation is to start by
building an <a href="https://en.wikipedia.org/wiki/Register_allocation#Graph-coloring_allocation">interference
graph</a>
which connects each pair of temporaries that cannot be put into the
same register, and then <a href="https://en.wikipedia.org/wiki/Graph_coloring">color the
graph</a> to find an
allowable register allocation. The main disadvantage with
graph-coloring allocators are that they are quite slow, since the
interference graph has size quadratic in the length of the function
(not acceptable since functions in Kalyn often have many thousands of
instructions).</p>
<p>For this reason, I based my implementation instead on <a href="http://web.cs.ucla.edu/~palsberg/course/cs132/linearscan.pdf">linear-scan
register
allocation</a>.
In linear-scan allocation, the full interference graph is not
constructed, and instead only approximated by finding the first and
last instruction where each register is live, and assuming that it is
live for the entire interval in between. It is fast and easy to check
if two live intervals intersect.</p>
<p>Now, the paper on linear-scan register allocation provides a very fast
linear-time algorithm for performing the allocation, which exploits
the structure of liveness intervals. I attempted to implement this
algorithm, but it proved to be very awkward to translate into a
functional style, so what Kalyn uses (for now) is a straightforward
“brute-force” allocation algorithm that does not run as fast as the
real linear-scan algorithm but nevertheless benefits from not having
to compute the interference graph. (See <a href="https://github.com/raxod502/kalyn/blob/dda2296f5daa4b312ee142ae4f7e5a85c621b842/src/RegisterAllocator.hs#L28-L148">the <code>linear-scan</code> branch on
GitHub</a>
for my attempt at true linear-scan register allocation.)</p>
<p>I was disappointed to find that after speeding up liveness analysis by
a factor of 300, the register allocator was still far too slow. I
solved this problem by a combination of several optimizations:</p>
<ul>
<li>Not computing a full flow graph, and instead gathering the
information needed to account for jumps on the fly during liveness
analysis.</li>
<li>Avoiding the use of $$ O(n \log n) $$ data structures like maps as
much as possible, in favor of lists plus additional bookkeeping.</li>
<li>Computing liveness intervals for all temporaries in parallel,
instead of doing it separately for each one.</li>
<li>Making small logic changes to the code that checked for available
machine registers for a temporary in order to avoid duplicating
work.</li>
<li>But most importantly, implementing the direct function-call
optimization in the translator that I discussed earlier. One way to
make the register allocator faster is to just make the code smaller
that it’s allocating registers for! (Using direct function calls
reduced the number of instructions by over 50%.)</li>
</ul>
<p>At this point, I suspect that the best way to get a performance
improvement from the register allocator may be to address the fact
that my system is 5 GB into swap when it starts running, by adding a
proper garbage collector :)</p>
<h3 id="assembler" tabindex="-1">Assembler</h3>
<ul>
<li><em>Haskell implementation:
<a href="https://github.com/raxod502/kalyn/blob/c2358a5778bdcf145fbd2b1c0eb2fbc349ce645d/src/Assembler.hs">Assembler</a></em></li>
<li><em>Kalyn implementation:
<a href="https://github.com/raxod502/kalyn/blob/c2358a5778bdcf145fbd2b1c0eb2fbc349ce645d/src-kalyn/Assembler.kalyn">Assembler</a></em></li>
</ul>
<p>The assembler was by far the slowest part of the compiler to write,
despite that it’s not really very long. This was primarily because
every existing source of documentation on x86 instruction encodings is
reprehensibly bad. For example, I dare you to look at <a href="http://ref.x86asm.net/coder64-abc.html">this
page</a> and come up with
anything comprehensible. In this section, I’ll take you through the
basics of how the encoding scheme for x86 works.</p>
<p>x86 instructions consist of a number of different parts, some of which
are not present in every instruction (so different instructions can
have different lengths):</p>
<ul>
<li>REX byte: this is optional; if it’s present, it provides certain
flags that change the behavior of the instruction, like running in
64-bit instead of 32-bit mode or changing which set of registers the
instruction operates on.</li>
<li>Opcode: this tells you what instruction it is, and what kinds of
arguments are being passed to it.</li>
<li>Mod/RM byte: this tells you what registers the instruction operates
on, and also tells you whether or not the instruction accesses
memory.</li>
<li>SIB byte: for instructions that access memory, this gives you the
information for that.</li>
<li>Displacement: this is a numerical offset used for memory accesses.</li>
<li>Immediate: this is a numerical constant used for instructions that
have one hardcoded into them.</li>
</ul>
<p>The easiest way to understand how all of this works is to encode an
example instruction. Let’s encode the following instruction:</p>
<pre><code>addq $0x42, 0x20(%r11, %rdi, 4)
</code></pre>
<p>This instruction says that we should figure out the value of <code>%r11 + %rdi * 4 + 0x20</code>, and add the value <code>0x42</code> to whatever is stored at
that memory address.</p>
<p>The first thing we do is look at the <a href="http://ref.x86asm.net/coder64-abc.html">big table of
opcodes</a>. There are quite a
few rows for <code>add</code>. We want the one that has <code>r/m16/32/64</code> in <code>op1</code>
and <code>imm16/32</code> in <code>op2</code>. The notation means that one operand is a
16-bit, 32-bit, or 64-bit memory reference, while the other is a
16-bit or 32-bit immediate (or constant). According to the table, the
opcode for this version of <code>add</code> is <code>0x81</code>, with an “opcode extension”
of 0x0. (More on that later.)</p>
<p>Next, we need to figure out the Mod/RM byte. The layout of this byte
is as follows:</p>
<pre><code>+---+---+---+---+---+---+---+---+
| mod   | reg       | rm        |
+---+---+---+---+---+---+---+---+
</code></pre>
<p>Of course, this doesn’t tell you very much. Let’s go through the
pieces. First is the <code>mod</code> field. This tells us if we are doing a
memory reference, and if so what kind. In this case we are, so we want
to set it to <code>0b10</code>. If we weren’t, we would set it to <code>0b11</code>.</p>
<p>Next is <code>reg</code>. This would normally tell you the source register for
the instruction. In this case, however, the source is an immediate, so
instead this is where we put the opcode extension. (Why? Well, the
byte had some bits free, so Intel decided to cram even more data in,
because that meant the same opcode could mean different things
depending on the value of the extra bits.) Thus <code>reg</code> is <code>0b000</code>.</p>
<p>Finally we have <code>rm</code>. This would normally tell you the destination
register for the instruction. However, in this case we are using a
memory reference, so we set it to the special value <code>0b100</code>.</p>
<p>Now, because we are using a memory reference, we have to include the
SIB byte. Here’s what that looks like:</p>
<pre><code>+---+---+---+---+---+---+---+---+
| scale | index     | base      |
+---+---+---+---+---+---+---+---+
</code></pre>
<p>Again, this doesn’t tell you very much, so we’ll go through the pieces
individually. First is <code>scale</code>. This is pretty straightforward; it
tells you the multiplier for the address computation, which is 4 in
this case. We encode 4 as its base-two logarithm <code>0b10</code>.</p>
<p>Next are <code>index</code> and <code>base</code>. These tell you the two registers that are
used in the memory reference, using the same encoding that we would
have otherwise used in the <code>mod</code> and <code>rm</code> fields. In this encoding,
the index <code>%rdi</code> is <code>0b0111</code> and the base <code>%r11</code> is <code>0b1011</code>. Now, how
can we put this into the three-bit fields <code>index</code> and <code>base</code>? The
answer is the REX byte. The lower three bits of each register go into
the SIB byte fields, while the upper bit, if needed, goes into the REX
byte. That’s our next topic.</p>
<p>The REX byte looks like this:</p>
<pre><code>+---+---+---+---+---+---+---+---+
| 0   1   0   0 | W | R | X | B |
+---+---+---+---+---+---+---+---+
</code></pre>
<p>(Why the <code>0b0100</code> at the beginning? Because the REX byte doesn’t have
to be used on all instructions, so it can’t conflict with any other
instruction’s opcode.) The meanings of the flag bits are as follows:</p>
<ul>
<li><code>W</code>: run in 64-bit mode</li>
<li><code>R</code>: the upper bit of the <code>reg</code> field in the Mod/RM byte</li>
<li><code>X</code>: the upper bit of the <code>index</code> field in the SIB byte</li>
<li><code>B</code>: the upper bit of the <code>rm</code> field in the Mod/RM byte, or the
upper bit of the <code>base</code> field in the SIB byte if the <code>rm</code> field says
we’re doing a memory reference</li>
</ul>
<p>We want to do everything in 64-bit mode, so we set the <code>W</code> bit, and
the base register in the SIB byte has the high bit set, so we also set
the <code>B</code> bit. That gives us a REX byte of <code>0b01001001</code>.</p>
<p>Now we have to encode the numerical constants. We have two, the memory
address displacement <code>0x20</code> and the immediate <code>0x42</code>. These are both
32-bit, so on a
<a href="https://en.wikipedia.org/wiki/Endianness">little-endian</a> system we
<a href="https://en.wikipedia.org/wiki/Sign_extension">sign-extend</a> the
immediates to <code>0x20000000</code> and <code>0x42000000</code>.</p>
<p>Putting all of this together, we get this 12-byte instruction
encoding:</p>
<pre><code>0x49  [0b01001001]   REX byte
0x81                 Opcode
0x84  [0b10000100]   Mod/RM byte
0xbb  [0b10111011]   SIB byte
0x20 0x00 0x00 0x00  Displacement
0x42 0x00 0x00 0x00  Immediate
</code></pre>
<p>Unfortunately, there are a lot more details that need to be taken care
of in Kalyn’s assembler. Memory references based on <code>%rip</code> are encoded
differently, some instructions like <code>imulq</code> don’t support certain
types of calls, some instructions actually encode a register number as
part of the opcode, and so on. None of that is very interesting,
though, so I won’t go into it here.</p>
<p>The one detail that’s worth mentioning is how labels are handled. How
do you encode the following instruction?</p>
<pre><code>callq __src_u45kalynStdlibLists_u46kalyn__foldr__uncurried
</code></pre>
<p>Well, first we generate assembly for each of the instructions, with
placeholders for label references. At this point we know the length of
each instruction, so we can compute an offset in bytes between any two
instructions. Now we generate assembly a second time. This time, when
we encounter an instruction like <code>callq</code> or <code>jmp</code>, we look up the
offset of that label from the current instruction, and substitute that
offset into the instruction.</p>
<h3 id="linker" tabindex="-1">Linker</h3>
<ul>
<li><em>Haskell implementation:
<a href="https://github.com/raxod502/kalyn/blob/c2358a5778bdcf145fbd2b1c0eb2fbc349ce645d/src/Linker.hs">Linker</a></em></li>
<li><em>Kalyn implementation:
<a href="https://github.com/raxod502/kalyn/blob/c2358a5778bdcf145fbd2b1c0eb2fbc349ce645d/src-kalyn/Linker.kalyn">Linker</a></em></li>
</ul>
<p>The linker was actually the component that I wrote first, and it
inspired the entire rest of Kalyn. Why? I was disappointed that in my
Compilers class we were only generate assembly code in text (<code>.S</code>)
format, and using GCC to compile it the rest of the way. How hard, I
wondered, would it be to produce a real executable by hand? The
answer, it turned out, was only 60 lines of code! Here is the original
version:</p>
<pre><code>fixedPoint :: Eq a =&gt; a -&gt; (a -&gt; a) -&gt; a
fixedPoint x f = let fx = f x in if x == fx then x else fixedPoint fx f

-- see page 20
elfIdent :: B.ByteString
elfIdent =
  toLazyByteString
    $  word8 0x7f -- magic bytes
    &lt;&gt; stringUtf8 &#34;ELF&#34;
    &lt;&gt; word8 2 -- address size, 64-bit
    &lt;&gt; word8 1 -- endianness, little-endian
    &lt;&gt; word8 1 -- version of ELF specification
    &lt;&gt; mconcat (replicate 9 $ word8 0)

-- see page 18
elfHeader :: Word16 -&gt; Word16 -&gt; B.ByteString
elfHeader elfHeaderLength programHeaderLength =
  let totalLength = elfHeaderLength + programHeaderLength
  in  toLazyByteString
        $  lazyByteString elfIdent
        &lt;&gt; word16LE 3 -- file type, relocatable executable (called &#34;shared object file&#34;)
                      -- see https://opensource.apple.com/source/dtrace/dtrace-90/sys/elf.h
        &lt;&gt; word16LE 62 -- architecture, x86_64
        &lt;&gt; word32LE 1 -- object file version
        &lt;&gt; word64LE (fromIntegral totalLength) -- entry point in virtual memory
        &lt;&gt; word64LE (fromIntegral elfHeaderLength) -- program header offset
        &lt;&gt; word64LE 0 -- section header offset, unused
        &lt;&gt; word32LE 0 -- processor-specific flags, none needed
        &lt;&gt; word16LE elfHeaderLength -- ELF header size
        &lt;&gt; word16LE programHeaderLength -- program header entry length
        &lt;&gt; word16LE 1 -- program header entry count
        &lt;&gt; word16LE 0 -- section header entry size, unused
        &lt;&gt; word16LE 0 -- section header entry count, unused
        &lt;&gt; word16LE 0 -- index of string table in section header, unused

-- see page 40
programHeader :: Word16 -&gt; Word16 -&gt; Word64 -&gt; B.ByteString
programHeader elfHeaderLength programHeaderLength imageSize =
  let totalLength = fromIntegral $ elfHeaderLength + programHeaderLength
  in  toLazyByteString
        $  word32LE 1 -- segment type, loadable code/data
        &lt;&gt; word32LE 0x7 -- permissions, allow all (see page 73)
        &lt;&gt; word64LE totalLength -- offset from beginning of file
        &lt;&gt; word64LE totalLength -- virtual address at which to map code/data
        &lt;&gt; word64LE 0 -- physical address at which to map, unused
        &lt;&gt; word64LE imageSize -- number of bytes listed in file image
        &lt;&gt; word64LE imageSize -- number of bytes to reserve in memory
        &lt;&gt; word64LE 0 -- alignment, none required

-- see page 15
elfData :: B.ByteString -&gt; B.ByteString
elfData code =
  let (ehdr&#39;, phdr&#39;) = fixedPoint (B.empty, B.empty) $ \(ehdr, phdr) -&gt;
        let elen      = fromIntegral $ B.length ehdr
            plen      = fromIntegral $ B.length phdr
            imageSize = fromIntegral $ B.length code
        in  (elfHeader elen plen, programHeader elen plen imageSize)
  in  toLazyByteString
        $  lazyByteString ehdr&#39;
        &lt;&gt; lazyByteString phdr&#39;
        &lt;&gt; lazyByteString code
</code></pre>
<p>Given that the project ended up at a total of about 9,800 lines of
code, perhaps I was slightly misled about the ease of creating a
compiler from scratch. In particular, Kalyn’s final linker has about
320 lines of code, because it supports more features than just “hello,
world”. But it was incredibly gratifying to be able to create a fully
working binary and know exactly what every byte was there for, and I’m
glad this initial linker inspired the rest of Kalyn.</p>
<p>In any case, let’s go through the linker. It is basically an
implementation of the <a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">Exectuable and Linkable Format
(ELF)</a>.
Luckily, the <a href="https://refspecs.linuxfoundation.org/elf/elf.pdf">ELF
specification</a> is
very easy to read (compared to most other specifications, at least).
Here are the basics:</p>
<ul>
<li>At the very beginning of the file there is a fixed-length header
that identifies the file as using ELF and declares fundamental
configuration options like the
<a href="https://en.wikipedia.org/wiki/Endianness">endianness</a> of the file.</li>
<li>After that comes the <em>ELF header</em>, which sets further configuration
options such as the <a href="https://en.wikipedia.org/wiki/Instruction_set_architecture">processor
architecture</a>
of the assembly code contained in the file and also identifies the
locations of the subsequent headers in the file.</li>
<li>Next, there’s a <em>program header</em> that explains how the operating
system should load the program into memory and start it executing.
This specifies where the program should be loaded in address space
and the virtual memory settings that should be applied.</li>
<li>Optionally, there’s a <em>section header</em> that provides extra metadata
which can be used by tools such as
<a href="https://www.gnu.org/software/gdb/">GDB</a>.</li>
<li>Depending on what entries there are in the section header, there may
be additional structures such as string and symbol tables.</li>
<li>And of course there is the actual code and data of the binary, as
referenced by the program header.</li>
</ul>
<h4 id="debugging-information" tabindex="-1">Debugging information</h4>
<p>What actually goes in the section header? Well, naturally enough, it
is a list of different <em>sections</em>, each of which can have a different
kind of data (and, by convention, a name that makes it easy for humans
and tools to identify its purpose). Here are the ones included in
Kalyn binaries:</p>
<pre><code>.shstrtab
.symtab
.strtab
.text
.data
</code></pre>
<p>Let’s start with <code>.text</code> and <code>.data</code>. These contain the main code and
data of the program, respectively. (There are also entries in the
program header for the text and data sections. The program header is
for the operating system while the section header is for other tools,
so they both include similar but not the same information.)</p>
<p>Next is <code>.symtab</code>. This is the <em>symbol table</em>, and it contains
debugging information for GDB: the addresses of all the symbols in the
program. Each function has an entry in the symbol table, so that GDB
knows how to display function names while debugging:</p>
<pre><code>┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃B+&gt;0xcdbd7 &lt;print__uncurried&gt;      rex.W push %rbp                ┃
┃   0xcdbda &lt;print__uncurried+3&gt;    mov    %rsp,%rbp               ┃
┃   0xcdbdd &lt;print__uncurried+6&gt;    rex.W push %rcx                ┃
┃   0xcdbe0 &lt;print__uncurried+9&gt;    pushq  $0x18                   ┃
┃   0xcdbe5 &lt;print__uncurried+14&gt;   callq  0xce5eb &lt;memoryAlloc&gt;   ┃
┃   0xcdbea &lt;print__uncurried+19&gt;   add    $0x8,%rsp               ┃
┃   0xcdbf1 &lt;print__uncurried+26&gt;   lea    -0x9c(%rip),%rcx        ┃
┃       # 0xcdb5c &lt;print__uncurried__unmonadified&gt;                 ┃
┃   0xcdbf8 &lt;print__uncurried+33&gt;   mov    %rcx,0x0(%rax,%riz,1)   ┃
┃   0xcdc00 &lt;print__uncurried+41&gt;   movq   $0x1,0x8(%rax,%riz,1)   ┃
┃   0xcdc0c &lt;print__uncurried+53&gt;   mov    0x10(%rbp,%riz,1),%rcx  ┃
┃   0xcdc14 &lt;print__uncurried+61&gt;   mov    %rcx,0x10(%rax,%riz,1)  ┃
┃   0xcdc1c &lt;print__uncurried+69&gt;   rex.W pop %rcx                 ┃
┃   0xcdc1f &lt;print__uncurried+72&gt;   rex.W pop %rbp                 ┃
┃   0xcdc22 &lt;print__uncurried+75&gt;   retq                           ┃
┃   0xcdc23 &lt;print&gt;                 rex.W push %rbp                ┃
┃   0xcdc26 &lt;print+3&gt;               mov    %rsp,%rbp               ┃
┃   0xcdc29 &lt;print+6&gt;               rex.W push %rdx                ┃
┃   0xcdc2c &lt;print+9&gt;               rex.W push %rcx                ┃
┃   0xcdc2f &lt;print+12&gt;              pushq  $0x10                   ┃
┃   0xcdc34 &lt;print+17&gt;              callq  0xce5eb &lt;memoryAlloc&gt;   ┃
┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
native process 112189 In: print.uncurried          L??   PC: 0xcdbd7
</code></pre>
<p>I did a lot of stepping through the generated assembly in GDB, so this
feature was invaluable.</p>
<p>Lastly, we have <code>.strtab</code> and <code>.shstrtab</code>. These are <em>string tables</em>
for the symbol table and section header, respectively. They are needed
because the symbol table and section header do not actually contain
any names (of symbols or sections, respectively). Instead, they
contain pointers into the appropriate string table, which is just a
big list of <a href="https://en.wikipedia.org/wiki/Null-terminated_string">null-terminated
strings</a>.</p>

<p>One tricky part of generating ELF is handling self-reference. ELF is
surprisingly self-referential! The ELF header needs to contain its own
length as well as the lengths and offsets of all the other headers,
and of course the offsets of later headers depend on the lengths of
earlier ones. The section header needs to reference its string table,
but its string table is defined by the sections in the section header.
The way we handle these problems is basically the same way we handle
label resolution in the assembler: just start with placeholders, and
then keep recompiling until we hit a fixed point :)</p>
<h4 id="address-space-layout-and-randomization" tabindex="-1">Address space layout and randomization</h4>
<p>So what does the program header tell us about address space layout? In
the final version of Kalyn’s linker, the program header has two
entries: one for code and one for data. You might expect them to be
right after one another, but this doesn’t work. The reason is that
modern CPUs use <a href="https://en.wikipedia.org/wiki/Virtual_memory">page-based virtual
memory</a>.</p>
<p>In virtual memory, the address space is divided into units called
pages, commonly 4kiB (0x1000 bytes). Each page can be mapped to a page
of the CPU’s physical memory hardware using a data structure called
the <a href="https://en.wikipedia.org/wiki/Page_table">page table</a>. By
maintaining a separate page table for each process, the operating
system can present the illusion to each process that it has command of
the entire (virtual) address space, while in fact physical memory is
shared between many different processes.</p>
<p>Page tables support additional metadata to be stored for each page.
For example, the page table can maintain different <em>permissions</em> for
each page. This allows code to be mapped on pages with only
read/execute permission, while the stack and heap can be mapped on
pages with only read/write permission. This is a plus for security,
since it mitigates attacks based on overwriting code or executing
data. In Kalyn, the code is marked as read/execute-only while the data
is marked as read/write-only. But each page can only have one
permission, so we need to align both code and data to start at page
boundaries. This is handled in concert by the assembler and linker,
because alignment affects label offsets.</p>
<p>The alignment requirement suggests this file layout, where the third
address depends on the size of the code:</p>
<pre><code>0x00000  ELF headers
0x01000  Code
0xcf000  Data
</code></pre>
<p>The simplest program header, then, would map the code at <code>0x01000</code> and
the data at <code>0xcf000</code>. Unfortunately, this doesn’t work either,
because it turns out that the operating system reserves virtual
addresses near zero (so that a <a href="https://en.wikipedia.org/wiki/Null_pointer#Null_dereferencing">null pointer
dereference</a>
will result in a <a href="https://en.wikipedia.org/wiki/Segmentation_fault">segmentation
fault</a>, among other
reasons). So we need the program header to request that the code and
data be mapped at a higher virtual address. I found that <code>0x10000</code>
worked well, so we have in the program header:</p>
<pre><code>0x00000  -&gt;  (not mapped)  ELF headers
0x01000  -&gt;  0x11000       Code
0xcf000  -&gt;  0xdf000       Data
</code></pre>
<p>Another issue with address space layout is the use of <a href="https://en.wikipedia.org/wiki/Address_space_layout_randomization">randomization
(ASLR)</a>,
which is ubiquitous today because it mitigates many attacks based on
reverse-engineering the memory layout of a process. ELF has a field
that can be used to specify whether a binary is “relocatable”, meaning
that it can be safely mapped in a different place in memory than it
asks for. Kalyn binaries are relocatable (or
<a href="https://en.wikipedia.org/wiki/Position-independent_code">position-independent</a>)
because they use <a href="https://en.wikipedia.org/wiki/Addressing_mode#PC-relative">PC-relative
addressing</a>.
This means that whenever the assembler translates a label, it does not
insert an absolute address into the instruction encoding. Instead, it
computes the offset of the label from the current instruction and
inserts directions to add this offset to the current <a href="https://en.wikipedia.org/wiki/Program_counter">instruction
pointer</a>.</p>
<p>Nevertheless, Kalyn disables relocation in its ELF header. Why? It
turns out that although Kalyn itself has no difficulty running at an
arbitrary address, GDB doesn’t know how to display symbols correctly
when randomization is enabled, at least not without additional
metadata. Rather than put in additional work, I elected to simply
disable randomization. Kalyn is not a security-hardened language :)</p>
<p>(As a side note, enabling randomization does solve the problem of the
bottom of address space being reserved by the operating system,
because the process will automatically be mapped at an appropriate
location.)</p>
<p>ASLR causes us one more difficulty. Recall that memory allocation in
Kalyn is handled by moving the program break. Normally (and based on
what I said in the section on memory management), we would expect the
program break to be at the end of the data section. However, even with
relocation disabled, the location of the program break is still
randomized to somewhere else in the address space. Notably, this
doesn’t mean all the space between the end of the data section and the
program break is free to use! So Kalyn can’t assume it knows where the
heap is located, and must invoke <code>brk</code> at startup to get the current
location of the program break, then immediately increase it in order
to get some space for the heap.</p>
<h2 id="worstfunniest-debugging-experiences" tabindex="-1">Worst/funniest debugging experiences</h2>
<p>This brings us to my favorite section of the write-up. You can see
from <a href="https://github.com/raxod502/kalyn/commits/master?after=ec3ab23b20f4cf7147e528fd7fc51be69e839742+0">my commit
messages</a>
that there were some “fun” bugs. Compilers are great because when
there’s a bug, it <em>could</em> be a bug in the code you’re compiling, or
perhaps in the standard library, or in the code generator, or the
parser, or the register allocator, or perhaps the memory allocator,
or, heck, maybe the system call documentation just lied to you!</p>
<p>Anyway, here are some of the most… interesting… bugs, in
chronological order:</p>
<ul>
<li>
<p><strong>Basically the same:</strong> Remember when I said the <a href="https://refspecs.linuxbase.org/elf/elf.pdf">ELF
specification</a> was
really great? That’s… mostly true. It turns out that there are a
few gotchas, though. One of them is that it’s only for 32-bit
systems, although nowhere is this mentioned that I’m aware of.
Apparently, there’s a <em>separate</em> document for <a href="https://uclibc.org/docs/elf-64-gen.pdf">64-bit
ELF</a>, which says “well it’s
basically the same as 32-bit, but a bunch of the fields have more
bits now”. Great. I had to find that out by manually comparing
Kalyn’s ELF header with one from GCC, byte by byte.</p>
</li>
<li>
<p><strong>The most helpful error message:</strong> “Segmentation fault” is surely
everybody’s favorite informative error message. <em>You did something
wrong. Where? Don’t ask me, you’re the one who wrote the code.</em>
Generally, I’ve assumed that segmentation faults mean my code tried
to dereference a bad pointer, or access memory without the proper
permissions. Well, it turns out that’s not the only reason you can
get one.</p>
<p>Right after I updated Kalyn’s linker to support separate code and
data sections, my binaries started failing on startup with a
segmentation fault. Naturally, I thought the “hello, world” code was
somehow messing up reading its message from the data section. Nope!
Turns out you get a segmentation fault when the program header tries
to map two sections onto different parts of the same page (this is
the problem I mentioned earlier when talking about page tables). I
fixed it by page-aligning the code and data sections.</p>
<p>This is possibly the hardest bug I’ve ever had to debug in my life,
because I still cannot think of any way that I could have figured it
out aside from what I did, which was stare at things until divine
inspiration struck. (Actually, it was courtesy of having implemented
a page table manager back in my Operating Systems class a year ago.
Thanks Prof. Rhodes!)</p>
</li>
<li>
<p><strong>A classic off-by-a-variety-of-values error:</strong> For some reason, I
had a <em>lot</em> of trouble figuring out the right way to read arguments
from the stack. I think this sequence of commits speaks for itself:</p>
<blockquote>
<p>Implement arithmetic primitives in assembly</p>
</blockquote>
<pre><code>+-- warning: gets arguments in reverse order!
 getArg n = getField (n + 1) rsp
</code></pre>
<blockquote>
<p>Fix calling convention bugs</p>
</blockquote>
<pre><code> -- warning: gets arguments in reverse order!
-getArg n = getField (n + 1) rsp
+getArg n = getField (n + 2) rbp
</code></pre>
<blockquote>
<p>Fix implementation of getArg</p>
</blockquote>
<pre><code> -- warning: gets arguments in reverse order!
-getArg n = getField (n + 2) rbp
+getArg n = getField (n + 1) rbp
</code></pre>
<blockquote>
<p>Fix calling convention</p>
</blockquote>
<pre><code> -- warning: gets arguments in reverse order!
-getArg n = getField (n + 1) rbp
+getArg n = getField n rbp
</code></pre>
<blockquote>
<p>Bugs in memory manager</p>
</blockquote>
<pre><code> -- warning: gets arguments in reverse order!
-getArg n = getField n rbp
+getArg n = getField (n - 1) rbp
</code></pre>
<blockquote>
<p>Put spilled temporaries in the right place</p>
</blockquote>
<pre><code> -- warning: gets arguments in reverse order!
-getArg n = getField (n - 1) rbp
+getArg n = getField (n - 3) rbp
</code></pre>
<blockquote>
<p>Alright now we are getting somewhere</p>
</blockquote>
<pre><code> -- warning: gets arguments in reverse order!
-getArg n = getField (n - 3) rbp
+getArg n = getField (n + 1) rbp
</code></pre>
</li>
<li>
<p><strong>Where did my memory go?:</strong> This was a great one because my program
would segfault, but only if I <em>wasn’t</em> using the debugger. Turns out
that GDB disables ASLR, which on more than one occasion changed the
behavior of my programs (either to make a bug visible or to hide
it). In this case, I was hit by ASLR putting the program break
somewhere totally different from the end of the data section.
Previously, I was initializing the memory manager by putting a
symbol called <code>heap</code> at the end of the data section, and starting
allocation there. As I mentioned earlier, I fixed the problem by
instead calling <code>brk</code> at startup to query the initial location of
the program break. It was tricky primarily because there appears to
be no documentation whatsoever on Linux address space layout and in
particular how the program break works in the context of
randomization.</p>
</li>
<li>
<p><strong>Just in case:</strong> Previously I used the
<a href="https://hackage.haskell.org/package/regex-tdfa">regex-tdfa</a> package
for Kalyn’s lexer in the Haskell implementation. One thing that
mystified me was that reading source code got suspiciously slow for
“large” files (where “large” meant a few hundred lines). I was
originally misled into thinking the parser was at fault, because
Haskell helpfully clings onto <a href="https://en.wikipedia.org/wiki/Lazy_evaluation">lazy
evaluation</a> with a
death grip, thus making it extremely difficult to correctly observe
how long anything takes to evaluate. But no, it turns out that when
you ask regex-tdfa to match a regex at the beginning of a string, if
it doesn’t match, then it helpfully scans <em>the entire rest of the
string</em>. You know, just in case? I guess? Anyway, that produced a
lovely quadratic-time lexer. I dropped regexes and switched to
manual pattern-matching, which was more elegant anyway.</p>
</li>
<li>
<p><strong>Creative field ordering:</strong> I was able to track this one down to
the following test case:</p>
<pre><code>(data Example
  (Example Int Int Int Int Int Int Int Int Int Int))

(public def main (IO Empty)
  (let ((t (Example 1 2 3 4 5 6 7 8 9 10)))
    (case t
      ((Example a b c d e f g h i j)
      (print (showList showInt [a b c d e f g h i j]))))))
</code></pre>
<p>The output:</p>
<pre><code>[9, 7, 5, 3, 1, 2, 4, 6, 8, 10]
</code></pre>
<p>… What?</p>
<p>It turned out that what was going on here was curried functions were
reading their arguments in the wrong order, so each time another
argument got passed, it got stuck onto the opposite side of the
argument list. An easy fix, but the first time I saw <em>this</em> field
ordering I was quite dumbfounded.</p>
</li>
<li>
<p><strong>Played by x86:</strong> This one took quite a while in GDB to track down.
For some reason, <code>%r11</code> was getting overwritten somewhere in the
middle of a thousand-instruction-long function, so it didn’t have
the right value anymore by time it got to the end. Luckily, GDB
supports breaking on writes to a register, so I was able to track it
down to a system call. In x86-64, the <code>%rax</code>, <code>%rdi</code>, <code>%rsi</code>,
<code>%rdx</code>, <code>%rcx</code>, <code>%r8</code>, and <code>%r9</code> registers are used for argument and
return value passing. I had assumed that these were also the
caller-saved registers. Oops. Turns out <code>%r10</code> and <code>%r11</code> are
caller-saved too.</p>
</li>
<li>
<p><strong>Removes most duplicates:</strong> This was a bug in the part of the
translator that collects free variables from an expression. Can you
spot the problem?</p>
<pre><code>freeVariables (Lambda arg body) = freeVariables body \\ [arg]
</code></pre>
<p>We collect the free variables in the body, but then <code>arg</code> doesn’t
count, so we remove it using the list-differencing operator <code>\\</code>.</p>
<p>In case you haven’t spotted it yet, here’s some code that compiled
fine:</p>
<pre><code>(lambda (foo)
  ((if b fst snd) foo))
</code></pre>
<p>And here’s some code that didn’t:</p>
<pre><code>(lambda (foo)
  (if b
    (fst foo)
    (snd foo)))
</code></pre>
<p>Yes, it turns out that <code>\\</code> only removes the <em>first</em> copy of each
element from the input list. So <code>foo</code> was returned as a free
variable only if it was used more than once in the body. Thanks,
Haskell.</p>
</li>
<li>
<p><strong>Played by my own sort implementation:</strong> There are, of course, many
fascinating sort algorithms for me to choose from for the Kalyn
standard library (<a href="https://en.wikipedia.org/wiki/Stooge_sort">stooge
sort</a>, <a href="https://www.reddit.com/r/ProgrammerHumor/comments/677ekw/sleep_sort_an_owtf_sorting_algorithm/">sleep
sort</a>,
<a href="https://xkcd.com/1185/">stack sort</a>, etc.). But since I already
went to the trouble of implementing a splay tree library, <a href="https://en.wikipedia.org/wiki/Tree_sort">tree
sort</a> was the most natural:</p>
<pre><code>(public defn sort (Func (Ord a) (List a) (List a))
  (cmp elts)
  (setToList (setFromList cmp elts)))
</code></pre>
<p>Can you spot the problem?</p>
<p>…</p>
<pre><code>+;; caution: deletes duplicates!!
 (public defn sort (Func (Ord a) (List a) (List a))
   (cmp elts)
   (setToList (setFromList cmp elts)))
</code></pre>
</li>
<li>
<p><strong>The man page lied to me:</strong> Let me quote from the man page of
<code>getcwd(2)</code>:</p>
<pre><code>SYNOPSIS

       char *getcwd(char *buf, size_t size);
       ...

RETURN VALUE
       On success, these functions return  a  pointer  to  a
       string containing the pathname of the current working
       directory.
       ...

NOTES
       Under Linux, these functions make use of the getcwd()
       system call (available since Linux 2.1.92).
       ...

   C library/kernel differences
       On Linux, the kernel provides a getcwd() system call,
       which  the  functions described in this page will use
       if possible.  The system call takes  the  same  argu‐
       ments  as  the library function of the same name, but
       is limited to returning at most PATH_MAX bytes.
       ...
</code></pre>
<p>Great! We know how to use the system call: just pass it the <code>buf</code>
and <code>size</code>, and we get a pointer to the pathname. Right?</p>
<p>Nope. Turns out what the system call returns is <em>actually</em> the
<em>length</em> of the string that was put into the buffer. To this date, I
have absolutely no idea how I was supposed to know this except for
stepping through GDB after I got a segfault from dereferencing the
return value.</p>
<p>Although frankly I’d take this documentation over the x86 reference.
At least this one is trying, even if it’s wrong.</p>
<p>(Yes, okay, okay, the documentation doesn’t <em>technically</em> say
anything that’s outright false. Only severely misleading.)</p>
</li>
<li>
<p><strong>Hanging off the edge:</strong> When I was in the final stages of getting
the compiler online, I noticed that I would sometimes get a
segmentation fault, but only if I printed enough data. Here’s what
was going on.</p>
<p>In the <em>Subroutines</em> module, I have a routine called <code>packString</code>
which takes a Kalyn-style linked-list string and packs it into a
contiguous byte array for passing to a system call. Since Kalyn
stores characters as normal 64-bit integers (with the upper 56 bits
unused), and doesn’t otherwise manipulate single bytes, I needed to
add limited support for the single-byte move instructions in x86, so
that I could copy bytes to and from packed strings without
overwriting neighboring bytes. (This is after I debugged why two
seemingly identical characters refused to compare equal. Apparently,
one of them had some garbage in the upper 56 bits because I had
accidentally copied it from neighboring memory. Helpfully, GDB
didn’t display any data from the upper bits when I told it to
display the value as a character.)</p>
<p>Unfortunately, it turned out that while I was using single-byte
moves for copying characters into the <code>packString</code> buffer, I was
using a normal <code>movq</code> for setting the null byte at the end. And if
<code>packString</code> got very unlucky, it was possible that the allocated
string buffer ended less than eight bytes from the program break (at
a page boundary), and writing the null byte as a full word would
cause an access to unmapped memory.</p>
</li>
<li>
<p><strong>And this is why we don’t trust people:</strong> For some reason, I found
that <code>setSize</code> was returning zero for a set that shouldn’t be empty.
Why? Well, I had already had bugs where I had copied the splay tree
implementation from
<a href="http://hackage.haskell.org/package/TreeStructures-0.0.2">TreeStructures</a>
incorrectly, so I suspected another one of those. Just to check,
though, I loaded TreeStructures into GHCI…</p>
<pre><code>λ size $ empty
0
λ size $ singleton (1, 2)
0
λ size $ fromList [(1, &#34;&#34;), (2, &#34;&#34;), (3, &#34;&#34;)]
2
</code></pre>
<p>Yeah, that looks about right. And this is why we don’t trust people.</p>
</li>
<li>
<p><strong>Field ordering 2: Electric Boogaloo:</strong> Argument references should
look like the following.</p>
<pre><code>movq 56(%rbp), %t792
movq 48(%rbp), %t793
movq 40(%rbp), %t794
movq 32(%rbp), %t795
movq 24(%rbp), %t796
movq 16(%rbp), %t797
</code></pre>
<p>Q: Why do they look like this instead?</p>
<pre><code>movq 56(%rbp), %t792
movq -32(%rbp), %t793
movq 56(%rbp), %t794
movq -32(%rbp), %t795
movq 56(%rbp), %t796
movq -32(%rbp), %t797
</code></pre>
<p>A: The function <code>(- 8)</code> did <em>not</em> do what I thought it did.
Corrected to <code>(flip - 8)</code>.</p>
</li>
</ul>
<h2 id="what-next" tabindex="-1">What next?</h2>
<p>Kalyn is clearly not complete. In the future, I hope to continue
development and fill in the gaps to create a truly usable
general-purpose language that can form the basis for further learning
(operating system development?). Here are some immediate improvements:</p>
<ul>
<li>Add a garbage collector. This would not only improve performance but
would also make compilation practical for larger programs. (I’m
going to run out of swap space eventually…)</li>
<li>Implement a performance profiler to identify runtime hotspots for
optimization.</li>
<li>Improve performance generally so that core development can take
place using only the self-hosted implementation.</li>
<li>Add typeclass support.</li>
<li>Report user-friendly error messages, including line numbers and
filenames.</li>
<li>Display backtraces by mapping the symbol table into memory and
walking the base pointer chain when the program has crashed.</li>
<li>Add support for inline assembly, so that primitives can be defined
in user code and do not need to be duplicated across both
implementations of the compiler.</li>
<li>Reduce the Haskell implementation to a minimal possible base in
order to reduce the effort needed to add new language features.</li>
</ul>
<p>In summary, I am extremely happy with Kalyn as a project. Developing a
compiler from scratch is an excellent learning experience because it
involves creating a large number of components, each of which is quite
different from the others. And in the process, you can develop a very
satisfying and thorough knowledge of how modern software <em>really</em>
works.</p>
<p><em>Mandatory legal notice:</em> This blog post is maintained by <a href="https://radian.codes/">Radian
LLC</a>.</p>
</div>
</article>
</div>
</div></div>
  </body>
</html>
