<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://rosenzweig.io/blog/vk13-on-the-m1-in-1-month.html">Original</a>
    <h1>Vulkan1.3 on the M1 in one month</h1>
    
    <div id="readability-page-1" class="page"> <header><p>5 Jun 2024</p></header> <p>Finally, conformant Vulkan for the M1! The new “Honeykrisp” driver is the first <a href="https://www.khronos.org/conformance/adopters/conformant-products/vulkan#submission_780">conformant Vulkan®</a> for Apple hardware on any operating system, implementing the full 1.3 spec without “portability” waivers.</p> <p>Honeykrisp is <strong>not yet released</strong> for end users. We’re continuing to add features, improve performance, and port to more hardware. <a href="https://gitlab.freedesktop.org/alyssa/mesa/-/tree/honeykrisp-20240506-2/src/asahi/vulkan?ref_type=heads">Source code</a> is available for developers.</p> <figure> <a href="https://rosenzweig.io/holocure.png"><img src="https://rosenzweig.io/holocure.avif" alt="HoloCure running on Honeykrisp ft. DXVK, FEX, and Proton."/></a> <figcaption aria-hidden="true"> <a href="https://kay-yu.itch.io/holocure">HoloCure</a> running on Honeykrisp ft. DXVK, FEX, and Proton. </figcaption> </figure> <p>Honeykrisp is not based on prior M1 Vulkan efforts, but rather <a href="https://mastodon.gamedev.place/@gfxstrand">Faith Ekstrand</a>’s open source <a href="https://www.collabora.com/news-and-blog/news-and-events/introducing-nvk.html">NVK driver</a> for NVIDIA GPUs. In her words:</p> <blockquote> <p>All Vulkan drivers in Mesa trace their lineage to the Intel Vulkan driver and started by copying+pasting from it. My hope is that NVK will eventually become the driver that everyone copies and pastes from. To that end, I’m building NVK with all the best practices we’ve developed for Vulkan drivers over the last 7.5 years and trying to keep the code-base clean and well-organized.</p> </blockquote> <p>Why spend years implementing features from scratch when we can reuse NVK? There will be friction starting out, given NVIDIA’s desktop architecture differs from the M1’s mobile roots. In exchange, we get a modern driver designed for desktop games.</p> <p>We’ll need to pass a half-million tests ensuring correctness, <a href="https://www.khronos.org/conformance/adopters">submit the results</a>, and then we’ll become conformant after 30 days of industry review. Starting from NVK and our OpenGL 4.6 driver… can we write a driver passing the Vulkan 1.3 conformance test suite <em>faster</em> than the 30 day review period?</p> <p>It’s unprecedented…</p> <p>Challenge accepted.</p> <h3 id="april-2">April 2</h3> <p>It begins with a text.</p> <blockquote> <p><em>Faith… I think I want to write a Vulkan driver.</em></p> </blockquote> <p>Her advice?</p> <blockquote> <p><em>Just start typing.</em></p> </blockquote> <p>Thre’s no copy-pasting yet – we just add M1 code to NVK and remove NVIDIA as we go. Since the kernel mediates our access to the hardware, we begin connecting “NVK” to <a href="https://vt.social/@lina">Asahi Lina</a>’s kernel driver using code shared with OpenGL. Then we plug in our shader compiler and hit the hay.</p> <h3 id="april-3">April 3</h3> <p>To access resources, GPUs use “descriptors” containing the address, format, and size of a resource. Vulkan bundles descriptors into “sets” per the application’s “descriptor set layout”. When compiling shaders, the driver lowers descriptor accesses to marry the set layout with the hardware’s data structures. As our descriptors differ from NVIDIA’s, our next task is adapting NVK’s descriptor set lowering. We start with a simple but correct approach, deleting far more code than we add.</p> <h3 id="april-4">April 4</h3> <p>With working descriptors, we can compile compute shaders. Now we program the fixed-function hardware to dispatch compute. We first add bookkeeping to map Vulkan command buffers to lists of M1 “control streams”, then we generate a compute control stream. We copy that code from our OpenGL driver, translate the GL into Vulkan, and compute works.</p> <p>That’s enough to move on to “copies” of buffers and images. We implement Vulkan’s copies with compute shaders, internally dispatched with Vulkan commands as if we were the application. The first copy test passes.</p> <h3 id="april-5">April 5</h3> <p>Fleshing out yesterday’s code, <em>all</em> copy tests pass.</p> <h3 id="april-6">April 6</h3> <p>We’re ready to tackle graphics. The novelty is handling graphics state like depth/stencil. That’s straightforward, but there’s a <em>lot</em> of state to handle. Faith’s code collects all “dynamic state” into a single structure, which we translate into hardware control words. As usual, we grab that translation from our OpenGL driver, blend with NVK, and move on.</p> <h3 id="april-7">April 7</h3> <p>What makes state “dynamic”? Dynamic state can change without recompiling shaders. By contrast, static state is baked into shader binaries called “pipelines”. If games create all their pipelines during a loading screen, there is no compiler “stutter” during gameplay. The idea hasn’t quite panned out: many game developers don’t know their state ahead-of-time so cannot create pipelines early. In response, Vulkan has <u><a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_extended_dynamic_state.html">made</a></u> <u><a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_extended_dynamic_state2.html">ever</a></u> <u><a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_extended_dynamic_state3.html">more</a></u> <u><a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_vertex_input_dynamic_state.html">state</a></u> <u><a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_graphics_pipeline_library.html">dynamic</a></u>, punctuated with the <a href="https://www.khronos.org/blog/you-can-use-vulkan-without-pipelines-today"><code>EXT_shader_object</code></a> extension that makes pipelines <em>optional</em>.</p> <p>We want full dynamic state and shader objects. Unfortunately, the M1 bakes random state into shaders: vertex attributes, fragment outputs, blending, even linked interpolation qualifiers. Like most of the industry in the 2010s, the M1’s designers bet on pipelines.</p> <p>Faced with this hardware, a reasonable driver developer would double-down on pipelines. DXVK would stutter, but we’d pass conformance.</p> <p>I am not reasonable.</p> <p>To eliminate stuttering in OpenGL, we make state dynamic with four strategies:</p> <ul> <li>Conditional code.</li> <li>Precompiled variants.</li> <li>Indirection.</li> <li>Prologs and epilogs.</li> </ul> <p>Wait, what-a-logs?</p> <p>AMD also bakes state into shaders… with a twist. They divide the hardware binary into three parts: a <em>prolog</em>, the shader, and an <em>epilog</em>. Confining dynamic state to the periphery eliminates shader variants. They compile prologs and epilogs on the fly, but that’s fast and doesn’t stutter. Linking shader parts is a quick concatenation, or long jumps avoid linking altogether. This strategy works for the M1, too.</p> <p>For Honeykrisp, let’s follow NVK’s lead and treat <em>all</em> state as dynamic. No other Vulkan driver has implemented full dynamic state and shader objects this early on, but it avoids refactoring later. Today we add the code to build, compile, and cache prologs and epilogs.</p> <p>Putting it together, we get a (dynamic) triangle:</p> <p><a href="https://rosenzweig.io/hk-triangle.png"><img src="https://rosenzweig.io/hk-triangle.avif" alt="Classic rainbow triangle"/></a></p> <h3 id="april-8">April 8</h3> <p>Guided by the list of failing tests, we wire up the little bits missed along the way, like translating border colours.</p> <div><pre><code><span><span>/* Translate an American VkBorderColor into a Canadian agx_border_colour */</span></span>
<span><span>enum</span> agx_border_colour</span>
<span>translate_border_color<span>(</span>VkBorderColor color<span>)</span></span>
<span><span>{</span></span>
<span>   <span>switch</span> <span>(</span>color<span>)</span> <span>{</span></span>
<span>   <span>case</span> VK_BORDER_COLOR_INT_TRANSPARENT_BLACK<span>:</span></span>
<span>      <span>return</span> AGX_BORDER_COLOUR_TRANSPARENT_BLACK<span>;</span></span>
<span>   <span>...</span></span>
<span>   <span>}</span></span>
<span><span>}</span></span></code></pre></div> <p>Test results are getting there.</p> <blockquote> <p><strong>Pass</strong>: 149770, <strong>Fail</strong>: 7741, <strong>Crash</strong>: 2396</p> </blockquote> <p>That’s good enough for <a href="https://github.com/Novum/vkQuake">vkQuake</a>.</p> <p><a href="https://rosenzweig.io/vkquake.png"><img src="https://rosenzweig.io/vkquake.avif" alt="Vulkan port of Quake running on Honeykrisp"/></a><br/> </p> <h3 id="april-9">April 9</h3> <p>Lots of little fixes bring us to a 99.6% pass rate… for Vulkan 1.1. Why stop there? NVK is 1.3 conformant, so let’s claim 1.3 and skip to the finish line.</p> <blockquote> <p><strong>Pass</strong>: 255209, <strong>Fail</strong>: 3818, <strong>Crash</strong>: 599</p> </blockquote> <p>98.3% pass rate for 1.3 on our 1 week anniversary.</p> <p>Not bad.</p> <h3 id="april-10">April 10</h3> <p>SuperTuxKart has a Vulkan renderer.</p> <p><a href="https://rosenzweig.io/hkr-stk.png"><img src="https://rosenzweig.io/hkr-stk.avif" alt="SuperTuxKart rendering with Honeykrisp, showing Pepper (from Pepper and Carrot) riding her broomstick in the STK Enterprise"/></a></p> <h3 id="april-11">April 11</h3> <p><a href="https://docs.mesa3d.org/drivers/zink.html">Zink</a> works too.</p> <p><a href="https://rosenzweig.io/hkr-stk-zink.png"><img src="https://rosenzweig.io/hkr-stk-zink.avif" alt="SuperTuxKart rendering with Zink on Honeykrisp, same scene but with better lighting"/></a></p> <h3 id="april-12">April 12</h3> <p>I tracked down some fails to a test bug, where an arbitrary verification threshold was too strict to pass on some devices. I filed a bug report, and it’s <a href="https://github.com/KhronosGroup/VK-GL-CTS/commit/5fd73c841d775dff1ad52d8340d79dc120d64696">resolved</a> within a few weeks.</p> <h3 id="april-16">April 16</h3> <p>The tests for “descriptor indexing” revealed a compiler bug affecting subgroup shuffles in non-uniform control flow. The M1’s shuffle instruction is quirky, but it’s easy to workaround. Fixing that fixes the descriptor indexing tests.</p> <h3 id="april-17">April 17</h3> <p>A few tests crash inside our register allocator. Their shaders contain a peculiar construction:</p> <div><pre><code><span><span>if</span> <span>(</span>condition<span>)</span> <span>{</span></span>
<span>   <span>while</span> <span>(</span>true<span>)</span> <span>{</span> <span>}</span></span>
<span><span>}</span></span></code></pre></div> <p><code>condition</code> is always false, but the compiler doesn’t know that.</p> <p>Infinite loops are nominally invalid since shaders must terminate in finite time, but this shader is syntactically valid. “All loops contain a break” seems obvious for a shader, but it’s false. It’s straightforward to fix register allocation, but what a doozy.</p> <h3 id="april-18">April 18</h3> <p>Remember copies? They’re slow, and every frame currently requires a copy to get on screen.</p> <p>For “zero copy” rendering, we need enough Linux window system integration to negotiate an efficient surface layout across process boundaries. Linux uses “modifiers” for this purpose, so we implement the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_image_drm_format_modifier.html"><code>EXT_image_drm_format_modifier</code></a> extension. And by implement, I mean copy.</p> <p>Copies to avoid copies.</p> <h3 id="april-20">April 20</h3> <blockquote> <p><em>“I’d like a 4K x86 Windows Direct3D PC game on a 16K arm64 Linux Vulkan Mac.”</em></p> <p>…</p> <p><em>“Ma’am, this is a Wendy’s.”</em></p> </blockquote> <h3 id="april-22">April 22</h3> <p>As bug fixing slows down, we step back and check our driver architecture. Since we treat all state as dynamic, we don’t pre-pack control words during pipeline creation. That adds theoretical CPU overhead.</p> <p>Is that a problem? After some optimization, <a href="https://github.com/zmike/vkoverhead">vkoverhead</a> says we’re pushing 100 million draws per second.</p> <p>I think we’re okay.</p> <h3 id="april-24">April 24</h3> <p>Time to light up YCbCr. If we don’t use special YCbCr hardware, this feature is “software-only”. However, it touches a <em>lot</em> of code.</p> <p>It touches so much code that <a href="https://mohamexiety.github.io/posts/final_report/">Mohamed Ahmed</a> spent an entire summer adding it to NVK.</p> <p>Which means he spent a summer adding it to Honeykrisp.</p> <p>Thanks, Mohamed ;-)</p> <h3 id="april-25">April 25</h3> <p>Query copies are next. In Vulkan, the application can query the number of samples rendered, writing the result into an opaque “query pool”. The result can be copied from the query pool on the CPU or GPU.</p> <p>For the CPU, the driver maps the pool’s internal data structure and copies the result. This may require nontrivial repacking.</p> <p>For the GPU, we need to repack in a compute shader. That’s harder, because we can’t just run C code on the GPU, right?</p> <p>…Actually, we can.</p> <p>A little witchcraft makes GPU query copies as easy as C.</p> <div><pre><code><span><span>void</span> copy_query<span>(</span><span>struct</span> params <span>*</span>p, <span>int</span> i<span>)</span> <span>{</span></span>
<span>  <span>uintptr_t</span> dst <span>=</span> p<span>-&gt;</span>dest <span>+</span> i <span>*</span> p<span>-&gt;</span>stride<span>;</span></span>
<span>  <span>int</span> query <span>=</span> p<span>-&gt;</span>first <span>+</span> i<span>;</span></span>
<span></span>
<span>  <span>if</span> <span>(</span>p<span>-&gt;</span>available<span>[</span>query<span>]</span> <span>||</span> p<span>-&gt;</span>partial<span>)</span> <span>{</span></span>
<span>    <span>int</span> q <span>=</span> p<span>-&gt;</span>index<span>[</span>query<span>];</span></span>
<span>    write_result<span>(</span>dst, p<span>-&gt;</span>_64, p<span>-&gt;</span>results<span>[</span>q<span>]);</span></span>
<span>  <span>}</span></span>
<span></span>
<span>  <span>...</span></span>
<span><span>}</span></span></code></pre></div> <h3 id="april-26">April 26</h3> <p>The final boss: border colours, hard mode.</p> <p>Direct3D lets the application choose an arbitrary border colour when creating a sampler. By contrast, Vulkan only requires three border colours:</p> <ul> <li><strong><code>(0, 0, 0, 0)</code></strong> – transparent black</li> <li><strong><code>(0, 0, 0, 1)</code></strong> – opaque black</li> <li><strong><code>(1, 1, 1, 1)</code></strong> – opaque white</li> </ul> <p>We handled these on April 8. Unfortunately, there are two problems.</p> <p>First, we need custom border colours for Direct3D compatibility. Both <a href="https://github.com/doitsujin/dxvk">DXVK</a> and <a href="https://github.com/HansKristian-Work/vkd3d-proton">vkd3d-proton</a> require the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_custom_border_color.html"><code>EXT_custom_border_color</code></a> extension.</p> <p>Second, there’s a subtle problem with our hardware, causing dozens of fails even without custom border colours. To understand the issue, let’s revisit texture descriptors, which contain a pixel <em>format</em> and a component reordering <em>swizzle</em>.</p> <p>Some formats are implicitly reordered. Common “BGRA” formats swap red and blue for <a href="https://stackoverflow.com/questions/74924790/why-bgra-instead-of-rgba">historical reasons</a>. The M1 does not directly support these formats. Instead, the driver composes the swizzle with the format’s reordering. If the application uses a <code>BARB</code> swizzle with a <code>BGRA</code> format, the driver uses an <code>RABR</code> swizzle with an <code>RGBA</code> format.</p> <p>There’s a catch: swizzles apply to the border colour, but formats do not. We need to <em>undo</em> the format reordering when programming the border colour for correct results after the hardware applies the composed swizzle. Our OpenGL driver implements border colours this way, because it knows the texture format when creating the sampler. Unfortunately, Vulkan doesn’t give us that information.</p> <p>Without custom border colour support, we “should” be okay. Swapping red and blue doesn’t change anything if the colour is white or black.</p> <p>There’s an even <em>subtler</em> catch. Vulkan mandates support for a packed 16-bit format with 4-bit components. The M1 supports a similar format… but with reversed “endianness”, swapping red and <em>alpha</em>.</p> <p>That still seems okay. For transparent black (all zero) and opaque white (all one), swapping components doesn’t change the result.</p> <p>The problem is opaque black: <code>(0, 0, 0, 1)</code>. Swapping red and alpha gives <code>(1, 0, 0, 0)</code>. Transparent red? Uh-oh.</p> <p>We’re stuck. No known hardware configuration implements correct Vulkan semantics.</p> <p>Is hope lost?</p> <p>Do we give up?</p> <p>A reasonable person would.</p> <p>I am not reasonable.</p> <p>Let’s jump into the deep end. If we implement custom border colours, opaque black becomes a special case. But how? The M1’s custom border colours entangle the texture format with the sampler. A reasonable person would skip Direct3D support.</p> <p>As you know, I am not reasonable.</p> <p>Although the hardware is unsuitable, we control software. Whenever a shader samples a texture, we’ll inject code to fix up the border colour. This emulation is simple, correct, and slow. We’ll use dirty driver tricks to speed it up later. For now, we eat the cost, advertise full custom border colours, and pass the opaque black tests.</p> <h3 id="april-27">April 27</h3> <p>All that’s left is some last minute bug fixing, and…</p> <blockquote> <p><strong>Pass</strong>: 686930, <strong>Fail</strong>: 0</p> </blockquote> <p>Success.</p> <h3 id="the-future">The future</h3> <p>The next task is implementing everything that <a href="https://github.com/doitsujin/dxvk/blob/master/VP_DXVK_requirements.json">DXVK</a> and <a href="https://github.com/HansKristian-Work/vkd3d-proton/blob/master/VP_D3D12_VKD3D_PROTON_profile.json">vkd3d-proton</a> require to layer Direct3D. That includes esoteric extensions like <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_transform_feedback.html">transform feedback</a>. Then <a href="https://www.winehq.org/">Wine</a> and an <a href="https://github.com/FEX-Emu/FEX">open source x86 emulator</a> will run Windows games on <a href="https://asahilinux.org/">Asahi Linux</a>.</p> <p>That’s getting ahead of ourselves. In the mean time, enjoy Linux games with our <a href="https://rosenzweig.io/blog/conformant-gl46-on-the-m1.html">conformant OpenGL 4.6</a> drivers… and stay tuned.</p> <figure> <a href="https://rosenzweig.io/babystorm.png"><img src="https://rosenzweig.io/babystorm.avif" alt="Baby Storm running on Honeykrisp ft. DXVK, FEX, and Proton."/></a> <figcaption aria-hidden="true"> <a href="https://store.steampowered.com/app/2176400/Baby_Storm/">Baby Storm</a> running on Honeykrisp ft. DXVK, FEX, and Proton. </figcaption> </figure> <hr/> <p><a href="https://rosenzweig.io/">Back to home</a></p> </div>
  </body>
</html>
