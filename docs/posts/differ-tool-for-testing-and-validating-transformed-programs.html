<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.trailofbits.com/2024/01/31/introducing-differ-a-new-tool-for-testing-and-validating-transformed-programs/">Original</a>
    <h1>Differ: Tool for testing and validating transformed programs</h1>
    
    <div id="readability-page-1" class="page"><article id="post-106148">
	<!-- .entry-header -->

	<div>
		<p><em>By Michael Brown</em></p>
<p>We recently released a new differential testing tool, called DIFFER, for finding bugs and soundness violations in transformed programs. DIFFER combines elements from differential, regression, and fuzz testing to help users find bugs in programs that have been altered by software rewriting, debloating, and hardening tools. We used DIFFER to evaluate 10 software debloating tools, and it discovered debloating failures or soundness violations in 71% of the transformed programs produced by these tools.</p>
<p>DIFFER fills a critical need in post-transformation software validation. Program transformation tools usually leave this task entirely to users, who typically have few (if any) tools beyond regression testing via existing unit/integration tests and fuzzers. These approaches do not naturally support testing transformed programs against their original versions, which can allow subtle and novel bugs to find their way into the modified programs.</p>
<p>We’ll provide some background research that motivated us to create DIFFER, describe how it works in more detail, and discuss its future.</p>
<p>If you prefer to go straight to the code, check out <a href="https://github.com/trailofbits/differ" target="_blank" rel="noopener">DIFFER on GitHub</a>.</p>
<p><a href="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/01/Differ-Tool-Design-2.png?ssl=1"><img fetchpriority="high" decoding="async" data-attachment-id="106163" data-permalink="https://blog.trailofbits.com/2024/01/31/introducing-differ-a-new-tool-for-testing-and-validating-transformed-programs/differ-tool-design-2/" data-orig-file="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/01/Differ-Tool-Design-2.png?fit=1000%2C820&amp;ssl=1" data-orig-size="1000,820" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="Differ Tool Design (2)" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/01/Differ-Tool-Design-2.png?fit=300%2C246&amp;ssl=1" data-large-file="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/01/Differ-Tool-Design-2.png?fit=690%2C566&amp;ssl=1" src="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/01/Differ-Tool-Design-2.png?resize=690%2C566&amp;ssl=1" alt="" width="690" height="566" srcset="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/01/Differ-Tool-Design-2.png?w=1000&amp;ssl=1 1000w, https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/01/Differ-Tool-Design-2.png?resize=300%2C246&amp;ssl=1 300w, https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/01/Differ-Tool-Design-2.png?resize=768%2C630&amp;ssl=1 768w" sizes="(max-width: 690px) 100vw, 690px" data-recalc-dims="1"/></a></p>
<h2>Background</h2>
<p>Software transformation has been a hot research area over the past decade and has primarily been motivated by the need to secure legacy software. In many cases, this must be done without the software’s source code (binary only) because it has been lost, is vendor-locked, or cannot be rebuilt due to an obsolete build chain. Among the more popular research topics that have emerged in this area are binary lifting, recompiling, rewriting, patching, hardening, and debloating.</p>
<p>While tools built to accomplish these goals have demonstrated some successes, they carry significant risks. When compilers lower source code to binaries, they discard contextual information once it is no longer needed. Once a program has been lowered to binary, the contextual information necessary to safely modify the original program generally cannot be fully recovered. As a result, tools that modify program binaries directly may inadvertently break them and introduce new bugs and vulnerabilities.</p>
<p>While DIFFER is application-agnostic, we originally built this tool to help us find bugs in programs that have had unnecessary features removed with a debloating tool (e.g., <a href="https://github.com/michaelbrownuc/CARVE" target="_blank" rel="noopener">Carve</a>, <a href="https://github.com/ashish-gehani/Trimmer" target="_blank" rel="noopener">Trimmer</a>, <a href="https://github.com/cxreet/razor" target="_blank" rel="noopener">Razor</a>). In general, software debloaters try to minimize a program’s attack surface by removing unnecessary code that may contain latent vulnerabilities or be reused by an attacker using code-reuse exploit patterns. Debloating tools typically perform an analysis pass over the program to map features to the code necessary to execute them. These mappings are then used to cut code that corresponds to features the user doesn’t want. However, these cuts will likely be imprecise because generating the mappings relies on imprecise analysis steps like binary recovery. As a result, new bugs and vulnerabilities can be introduced into debloated programs during cutting, which is exactly what we have designed DIFFER to detect.</p>
<h2>How does DIFFER work?</h2>
<p>At a high level, DIFFER (shown in figure 1) is used to test an unmodified version of the program against one or more modified variants of the program. DIFFER allows users to specify seed inputs that correspond to both unmodified and modified program behaviors and features. It then runs the original program and the transformed variants with these inputs and compares the outputs. Additionally, DIFFER supports template-based mutation fuzzing of these seed inputs. By providing mutation templates, DIFFER can maximize its coverage of the input space and avoid missing bugs (i.e., false negatives).</p>
<p>DIFFER expects to see the same outputs for the original and variant programs when given inputs that correspond to unmodified features. Conversely, it expects to see different outputs when it executes the programs with inputs corresponding to modified features. If DIFFER detects unexpected matching, differing, or crashing outputs, it reports them to the user. These reports help the user identify errors in the modified program resulting from the transformation process or its configuration.</p>
<div id="attachment_106156"><p><a href="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/01/DIFFER-Overview.png?ssl=1"><img decoding="async" aria-describedby="caption-attachment-106156" data-attachment-id="106156" data-permalink="https://blog.trailofbits.com/2024/01/31/introducing-differ-a-new-tool-for-testing-and-validating-transformed-programs/differ-overview/" data-orig-file="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/01/DIFFER-Overview.png?fit=1999%2C1480&amp;ssl=1" data-orig-size="1999,1480" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="DIFFER Overview" data-image-description="" data-image-caption="&lt;p&gt;Figure 1: Overview of DIFFER&lt;/p&gt;
" data-medium-file="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/01/DIFFER-Overview.png?fit=300%2C222&amp;ssl=1" data-large-file="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/01/DIFFER-Overview.png?fit=690%2C511&amp;ssl=1" src="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/01/DIFFER-Overview.png?resize=690%2C511&amp;ssl=1" alt="" width="690" height="511" srcset="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/01/DIFFER-Overview.png?w=1999&amp;ssl=1 1999w, https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/01/DIFFER-Overview.png?resize=300%2C222&amp;ssl=1 300w, https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/01/DIFFER-Overview.png?resize=1024%2C758&amp;ssl=1 1024w, https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/01/DIFFER-Overview.png?resize=768%2C569&amp;ssl=1 768w, https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/01/DIFFER-Overview.png?resize=1536%2C1137&amp;ssl=1 1536w, https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/01/DIFFER-Overview.png?resize=1200%2C888&amp;ssl=1 1200w, https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/01/DIFFER-Overview.png?w=1380&amp;ssl=1 1380w" sizes="(max-width: 690px) 100vw, 690px" data-recalc-dims="1"/></a></p><p id="caption-attachment-106156">Figure 1: Overview of DIFFER</p></div>
<p>When configuring DIFFER, the user selects one or more comparators to use when comparing outputs. While DIFFER provides many built-in comparators that check basic outputs such as return codes, console text, and output files, more advanced comparators are often needed. For this purpose, DIFFER allows users to add custom comparators for complex outputs like packet captures. Custom comparators are also useful for reducing false-positive reports by defining allowable differences in outputs (such as timestamps in console output). Our open-source release of DIFFER contains many useful comparator implementations to help users easily write their own comparators.</p>
<p>However, DIFFER does not and cannot provide formal guarantees of soundness in transformation tools or the modified programs they produce. Like other dynamic analysis testing approaches, DIFFER cannot exhaustively test the input space for complex programs in the general case.</p>
<h2>Use case: evaluating software debloaters</h2>
<p>In a recent <a href="https://arxiv.org/abs/2312.13274" target="_blank" rel="noopener">research study</a> we conducted in collaboration with our friends at GrammaTech, we used DIFFER to evaluate debloated programs created by 10 different software debloating tools. We used these tools to remove unnecessary features from 20 different programs of varying size, complexity, and purpose. Collectively, the tools created 90 debloated variant programs that we then validated with DIFFER. DIFFER discovered that 39 (~43%) of these variants still had features that debloating tools failed to remove. Even worse, DIFFER found that 25 (~28%) of the variants either crashed or produced incorrect outputs in retained features after debloating.</p>
<p>By discovering these failures, DIFFER has proven itself as a useful post-transformation validation tool. Although this study was focused on debloating transformations, we want to emphasize that DIFFER is general enough to test other transformation tools such as those used for software hardening (e.g., CFI, stack protections), translation (e.g., C-to-Rust transformers), and surrogacy (e.g., ML surrogate generators).</p>
<h2>What’s next?</h2>
<p>With DIFFER now available as open-source software, we invite the security research community to use, extend, and help maintain DIFFER via pull requests. We have several specific improvements planned as we continue to research and develop DIFFER, including the following:</p>
<ul>
<li>Support running binaries in Docker containers to reduce environmental burdens.</li>
<li>Add new built-in comparators.</li>
<li>Add support for targets that require superuser privileges.</li>
<li>Support monitoring multiple processes that make up distributed systems.</li>
<li>Add runtime comparators (via instrumentation, etc.) for “deep” equivalence checks.</li>
</ul>
<h3>Acknowledgements</h3>
<p>This material is based on work supported by the Office of Naval Research (ONR) under Contract No. N00014-21-C-1032. Any opinions, findings and conclusions, or recommendations expressed in this material are those of the author and do not necessarily reflect the views of the ONR.</p>

			</div><!-- .entry-content -->

	
</article></div>
  </body>
</html>
