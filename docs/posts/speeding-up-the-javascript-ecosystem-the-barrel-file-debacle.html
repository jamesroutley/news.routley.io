<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://marvinh.dev/blog/speeding-up-javascript-ecosystem-part-7/">Original</a>
    <h1>Speeding up the JavaScript ecosystem â€“ The barrel file debacle</h1>
    
    <div id="readability-page-1" class="page"><p>ðŸ“– tl;dr: Many projects are littered with files that just re-export other files. These so called &#34;barrel files&#34; are one of the key reasons why JavaScript tooling is slow in bigger projects.</p><div>
						<p>Let&#39;s imagine you are working on a big project with many files. You add a new file to work on a new feature and import a function from another directory into your code.</p>
						<pre><code><span>import</span> <span>{</span> foo <span>}</span> <span>from</span> <span>&#34;./some/other-file&#34;</span><span>;</span></code></pre>
						<p>Excited about finishing your feature, you run the code and realize that it takes an awfully long time to complete. The code you&#39;ve written is pretty straight forward and shouldn&#39;t consume that much time. Concerned by this, you sprinkle in some measuring code to see how long your function took to do its thing.</p>
						<pre><code><span>import</span> <span>{</span> foo <span>}</span> <span>from</span> <span>&#34;./some/other-file&#34;</span><span>;</span></code></pre>
						<p>You run the code again, and to your surprise the measurements you inserted show that it&#39;s blazing fastâ„¢. You repeat the measuring steps, but this time insert the <code>console.time()</code> statements in the main entry file of your project and run the code again. But no dice, the logged measurements just confirm that your code itself is super fast. What is happening?</p>
						<p>Well, strap in. This is the story of the devastating effects barrel files have on your code.</p>
						<h2>Gathering more information</h2>
						<p>The key piece of information we have obtained so far is that the runtime of the code isn&#39;t the issue. You measured it, and it was a fraction of the total time. This means we can assume that all the other time is wasted either <em>before</em> or <em>after</em> running our code. From experience when it comes to tooling, the time is usually spent before running the project code.</p>
						<p>You got an idea: You remember hearing that some npm packages pre-bundle their code for performance reasons. Maybe this could help here? You decide to test that theory and bundle your code with <a href="https://esbuild.github.io/">esbuild</a> into a single file. You purposely disable any forms of minifications, because you want your code to be as close as possible to the original source.</p>
						<p>Upon completion, you then run the bundled file to repeat the experiment and voilÃ¡, it finishes in a blink of an eye. Out of curiosity, you measure the time it takes to run esbuild <em>and</em> run the bundled file together and notice that both of them combined are still quicker than running the original source code. Huh? What is going on?</p>
						<p>Then it hits you: The main thing a bundler does is flatten and merge the module graph. What was once composed of thousands of files, is merged into a single file thanks to esbuild. This would be a strong indicator that the size of the module graph is the true problem here. And barrel files are the main cause of that.</p>
						<h2>Anatomy of a barrel file</h2>
						<p>Barrel files are files that only export other files and contain no code themselves. As a non-native speaker that term is confusing to me, but let&#39;s roll with it. In the days before editors had auto imports and other niceties, many developers tried to keep the number of import statements they had to write by hand to a minimum.</p>
						<pre><code></code></pre>
						<p>This gave rise to a pattern where every folder got its own <code>index.js</code> file that merely re-exported code from other files in usually the same directory. In a way this amortized the manual typing work because once such a file is in place, all the other code only needs to reference one import statement.</p>
						<pre><code></code></pre>
						<p>The previously shown import statements can now be collapsed into a single line.</p>
						<pre><code><span>import</span> <span>{</span> foo<span>,</span> bar<span>,</span> baz <span>}</span> <span>from</span> <span>&#34;../feature&#34;</span><span>;</span></code></pre>
						<p>After a while, this pattern spreads throughout the codebase and every folder in your project has an <code>index.js</code> file. Kinda neat, isn&#39;t it? Well, no.</p>
						<h2>Everything is not fine</h2>
						<p>In such a setup a module very likely imports another barrel file which pulls in a bunch of other files, which then imports yet another barrel file and so on. Ultimately, you typically end up importing every single file in your project through a spiderweb of import statements. And the bigger the project, the longer it takes to load all of these modules.</p>
						<p>Ask yourself: What&#39;s quicker? Having to load 30k files or just 10? Probably only loading 10 files is faster.</p>
						<p>It&#39;s a common misconception among JavaScript developers that modules would only be loaded when needed. This is not true, because doing so would break code relying on globals or module execution order.</p>
						<pre><code></code></pre>
						<p>If the engine wouldn&#39;t load the first <code>./a</code> import, then the code would unexpectedly log <code>undefined</code> instead of <code>123</code>.</p>
						<h2>Effects of barrel files on performance</h2>
						<p>It gets worse when you take tools like test runners in consideration. In the popular jest test runner, each test file is executed in its own child process. In effect, this means that every single test file constructs the module graph from scratch and has to pay for that cost. If constructing the module graph in a project takes 6s and you have - let&#39;s say - only 100 test files, then you waste 10 minutes in total to repeatedly construct the module graph. No test or any other code is being run during that time. It&#39;s just the time the engine needs to prepare the source code so that it can then be run.</p>
						<p>Another area where barrel files gravely affect performance is any sort of import cycle linting rules. Typically linters are run on a file-by-file basis, which means the cost of constructing the module graph needs to be paid for every single file. It&#39;s not uncommon that this alone causes linting times to spiral out of control and suddenly linting takes a couple of hours in a bigger project.</p>
						<p>To get some raw numbers, I&#39;ve generated a project with files importing each other to get a better sense of the cost of constructing the module graph. Every file is empty and contains no code other than import statements. Timings are measured on my MacBook M1 Air (2020).</p>
						<p><img src="https://vaibhavsagar.com/media/js-tools-module-cost.png" alt="Loading 500 empty modules takes 0.15s, 1000 take 0.31s, 10000 take 3.12s, 25000 take 16.81s, 50000 take 48.44s"/></p>
						<p>As you can see, loading fewer modules is very much worth it. Let&#39;s apply these numbers to a project with 100 test files where a test runner is used that spawns a new child process for each test file. Let&#39;s be generous here and say that our test runner can run 4 tests in parallel:</p>
						<ul>
							<li>500 modules: <code>0.15s * 100 / 4</code> = <code>3.75s</code> overhead</li>
							<li>1000 modules: <code>0.31s * 100 / 4</code> = <code>7.75s</code> overhead</li>
							<li>10000 modules: <code>3.12s * 100 / 4</code> = <code>1:18m</code> overhead</li>
							<li>25000 modules: <code>16.81s * 100 / 4</code> = <code>~7:00m</code> overhead</li>
							<li>50000 modules: <code>48.44s * 100 / 4</code> = <code>~20:00m</code> overhead</li>
						</ul>
						<p>Since this is a synthetic setup, these are lowball numbers. In a real project these numbers are likely worse. Barrel files are not good when it comes to tooling performance.</p>
						<h2>What to do</h2>
						<p>Having only a handful of barrel files in your code is usually fine, but it gets problematic when every single folder has one. It&#39;s unfortunately not a rare occurrence in the JavaScript industry.</p>
						<p>So if you work on a project which uses barrel files extensively, there is a free optimization you can apply that makes many tasks 60-80% faster:</p>
						<p>Get rid of all barrel files.</p>
					</div></div>
  </body>
</html>
