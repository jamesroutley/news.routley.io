<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.tjll.net/reverse-proxy-hot-dog-eating-contest-caddy-vs-nginx/">Original</a>
    <h1>35M Hot Dogs: Benchmarking Caddy vs. Nginx</h1>
    
    <div id="readability-page-1" class="page"><div>
        
        <hgroup>
            <h3>
                
                <a href="https://blog.tjll.net/one-year-with-nixos-on-framework/">«</a>
                
                35 Million Hot Dogs: Benchmarking Caddy vs. Nginx
                
            </h3>
            <div>
                
                <ul id="post-details">
                    <li>14 September, 2022</li>
                    <li>7,215 words</li>
                    <li>40 minutes read time</li>
                </ul>
                
            </div>
        </hgroup>
        
        <section id="content">
            <p>This blog post is about benchmarking Caddy against Nginx and their respective performance metrics as reverse proxies. Be forewarned: I was very thorough and there are tons of graphs and tables in here. I didn’t want to make any mistakes! Nobody is allowed to make mistakes on the Internet.</p>

<p>You can proceed to the <a href="#results">results</a> if you want to, but you’ll hurt my vain writer’s feelings if you skip past the methodology. I swear I won’t use the term “web-scale” once.</p>

<p>Also, I worked in a gimmicky title because I’m sending the <code>X-Hotdogs: aplenty</code> header to each proxy and I totaled 35,127,259 requests over the course of these tests. I pay myself in bad jokes when I’m not on the clock (my original post title was a pun about hot dog eating contests).</p>

<p>Finally, a shout-out to my clients who are facilitating my freelance work that ultimately makes things like this possible. If it weren’t for people paying me for flexible hours and projects, I’d probably be spending 9-5 rearranging kanban cards. Y’all are the real heroes (you know who you are).</p>

<ul id="markdown-toc">
  <li><a href="#background" id="markdown-toc-background">Background</a>    <ul>
      <li><a href="#on-benchmarking" id="markdown-toc-on-benchmarking">On Benchmarking</a></li>
    </ul>
  </li>
  <li><a href="#design" id="markdown-toc-design">Design</a></li>
  <li><a href="#hypothesis" id="markdown-toc-hypothesis">Hypothesis</a></li>
  <li><a href="#procedures" id="markdown-toc-procedures">Procedures</a>    <ul>
      <li><a href="#configuration" id="markdown-toc-configuration">Configuration</a>        <ul>
          <li><a href="#defaults" id="markdown-toc-defaults">Defaults</a></li>
          <li><a href="#optimized" id="markdown-toc-optimized">Optimized</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#results" id="markdown-toc-results">Results</a>    <ul>
      <li><a href="#10-clients" id="markdown-toc-10-clients">10 Clients</a></li>
      <li><a href="#200-clients" id="markdown-toc-200-clients">200 Clients</a></li>
      <li><a href="#500-clients" id="markdown-toc-500-clients">500 Clients</a></li>
      <li><a href="#1000-clients" id="markdown-toc-1000-clients">1,000 Clients</a></li>
      <li><a href="#10000-clients" id="markdown-toc-10000-clients">10,000 Clients</a></li>
    </ul>
  </li>
  <li><a href="#summary" id="markdown-toc-summary">Summary</a></li>
  <li><a href="#appendix-a-code" id="markdown-toc-appendix-a-code">Appendix A: Code</a></li>
  <li><a href="#appendix-b-caddy-sendfile" id="markdown-toc-appendix-b-caddy-sendfile">Appendix B: Caddy <code>sendfile</code></a></li>
</ul>

<h4 id="background">Background</h4>

<p>For <em>some</em> reason I’ve spent an inordinate amount of time in my career working with reverse proxies.
Apache, Nginx, traefik, various kubernetes services, and lately, Caddy.
I don’t think it’s just recency bias to say that Caddy has been my favorite: simple, modern, and quick, it does what a modern reverse proxy <em>should</em> do without much hassle.</p>

<p>However, some people (understandably!) hesitate when confronted with a choice between the <a href="https://news.netcraft.com/archives/category/web-server-survey/">current reigning champion</a>, Nginx, and a relative newcomer like Caddy.
Nginx has been around for a long time and is very good at what it does.
Caddy is new to the scene and makes tradeoffs, for better or worse - the C vs. golang authorship is just one example that is bound to result in some sort of performance delta.</p>

<p>So, I’m here to do some “&#34;”science””” on the performance differences between Nginx and Caddy.
I’ve already confessed to you that I’m a Caddy fanboy, but I’ll commit to being as impartial as I can when it comes to crunching the numbers.
I’m not being paid by either Nginx or Caddy for this!
(Although they’re welcome to if they want – I’m a <del>starving</del> freelancer.)</p>

<h5 id="on-benchmarking">On Benchmarking</h5>

<figure><img src="https://blog.tjll.net/generated/computer-race-277x277-bc82e1.png" itemprop="image" alt="Image via DALL·E"/><figcaption>Image via DALL·E</figcaption></figure>

<p>Before I get into the meat: benchmarking is really, really hard.
There are <em>so</em> many potential variables that come into play and we’re operating so high up on the computer science abstraction stack that it’s easy to make mistakes.
I spent a lot of time thinking about how to do this in a fair and reasonable way.</p>

<p>At Elastic I worked with two engineers who may be some of the best performance engineers I’ve ever personally encountered, <a href="https://github.com/danielmitterdorfer">Daniel Mitterdorfer</a> and <a href="https://github.com/dliappis">Dimitrios Liappis</a>.
Their work on <a href="https://www.elastic.co/blog/announcing-rally-benchmarking-for-elasticsearch">Rally</a> really stuck with me, particularly in regard to how careful and methodical they were when performing performance benchmarks. I drew ideas from a few different places when figuring out how to run these tests, but much of the rigor here came from the <em>real</em> professionals like them who share how to do benchmarking well.
This professional shout-out is just a nod of respect and not trying to elicit favors from anybody (although Daniel did bring me chocolate to a company all-hands one time – and it was <em>Austrian</em> chocolate, too).</p>

<p>Regarding versions, note that Nginx offers a <em>commercial</em> variant of their software - <a href="https://www.nginx.com/products/nginx/">Nginx Plus</a>. I didn’t explore this option too heavily because Caddy is <em>completely</em> open source and doesn’t have any commercial features to fall back on, so we’ll compare these proxies on equal OSS footing.</p>

<p>Finally, if people have concerns about the data or want to collaborate, please do so! <a href="#appendix-a-code">I’ll include notes here</a> about how to reproduce my data. The test setup and load testing harness are all <em>very</em> automated so duplicating my results should be very, very achievable if you’d like to try any of this yourself.</p>

<p>(One more note – I’m bound to mix terms here and probably use “latency”, “time to first byte”, and more incorrectly. I think I got pretty close, but bear with me, this is my first time cosplaying as someone who knows anything about benchmarking.)</p>

<h4 id="design">Design</h4>

<p>We’ll only be testing Caddy and Nginx today, but I’ll be cutting along many different axes to understand their respective performance profiles as accurately as possible.</p>

<p>The tests that I’ll perform will focus on three areas:</p>

<ol>
  <li>Purely in-proxy “synthetic” responses. I’m calling them “synthetic” because the proxy forms a response code and body solely within its own configuration: while processing the response, it does <em>not</em> retrieve any assets from disk and does <em>not</em> talk to a backend listening service. This isolates all responsibility for responding to requests to the reverse proxy itself and no other dependent resources.</li>
  <li>Serving files. Reverse proxies serve up precompiled static assets all the time, so this is an important use case to measure. It’s less pure than the synthetic tests since we’re now involving disk I/O, but remember that the reverse proxy can lean on caching, too.
    <ul>
      <li>Note that I’ll be cutting across this axis in two ways: with <strong>small</strong> responses – think a minimal <code>index.html</code> – and a <strong>large</strong> response body. In my tests I used <code>jquery-3.6.1.js</code> which clocks in at 109K and my index file is 4.5K according to <code>du</code>.</li>
    </ul>
  </li>
  <li>
    <p>Reverse proxying. This is a reverse proxy’s bread and butter (hopefully that’s obvious): chatting with a service listening on the backend side of the service. Although this is super important to measure, it’s tricky to do because now you’re introducing an entirely separate process that may impact response times. In practice, your backend will almost always be your bottleneck because the reverse proxy’s job is just to hand traffic along. In that regard I’m not a huge fan of this test because the performance of the backend <strong>target</strong> ends up bleeding into the numbers, but we need to do it anyway (because the “open a new socket” testing path needs to happen). Hopefully, all else equal, the <em>deltas</em> between different test runs will still be significant even if the absolute values aren’t strictly representative.</p>

    <p>I’ll be setting up a bare-bones <code>lighttpd</code> listener that itself responds with a synthetic response for quick turnaround. A <em>slower</em> backend service may be worth testing in the future so that I could measure what lots of open and waiting backend connections behaves like, but we’re already working with a lot of variables.</p>
  </li>
</ol>

<p>Those variables that I’ll change will be:</p>

<ul>
  <li>Concurrent requests. In practice, many operators/sites will very seldom break massive concurrent load, so I’m keen on hitting a few watermarks:
    <ul>
      <li>Low, casual use. What is performance like when the service isn’t under duress?</li>
      <li>High - but not error-inducing - levels of load. What kind of <em>sustained</em> performance can we achieve without sacrificing reliability?</li>
      <li>Service-breaking load (stress testing). What kind of service degradation do we observe when traffic levels exceed the capabilities of a listening proxy? Does the service queue up responses and incur longer response times? Or does it drop connections and cause client connection errors?</li>
    </ul>
  </li>
  <li>Default versus optimized settings. As we all know, <a href="https://blog.codinghorror.com/the-power-of-defaults/">defaults matter</a>, so I would expect each service to behave pretty differently when profiled “out of the box” versus highly optimized with more finely-tuned configuration files.</li>
</ul>

<p><em>What</em> I want to measure:</p>

<ul>
  <li>System resource utilization. A reverse proxy that underperforms another <em>but</em> with a fraction of the CPU and memory used can just be scaled horizontally, potentially with much greater overall capacity when you eventually reach equivalent resource use. Therefore, it’s critical to ensure that we measure process resource consumption during the test and compare them.</li>
  <li>HTTP response latency. I did some preliminary tests and found that the delta between “time to first byte” and “overall response time” ends up being pretty consistent, so I’m lumping both of those metrics into “how quickly the server responds”.
    <ul>
      <li>I ended up collecting - over the duration of each test - the minimum, median, average, 90th percentile, 95th percentile, and maximum response times. <strong>However</strong>, I’m excluding minimum and maximum latency from the visualizations because they tend to blow out the axes - minimum tends to represent “something gave out somewhere” and maximum isn’t super useful in a client scenario since, for example, serving p95 requests with great effectiveness but goofing on one hung request can skew everything similarly up. p95 will serve as “what’s the exceptionally bad case” number, then.</li>
    </ul>
  </li>
  <li>Total number of requests processed. I’m running with a 30-second window in each test, which provides a constant duration for each server to serve as <em>many</em> requests as possible.</li>
  <li>Error rate. I want the proxies to operate correctly! There’s not much use with blazing-fast responses if they don’t do it right. This includes hung connections, refused connections, that sort of thing. Embarrassingly high error rates will be punished with snark against their social media teams on Twitter.</li>
</ul>

<p>Finally, <em>how</em> I’ll measure it:</p>

<ul>
  <li>I chose <a href="https://k6.io/">k6</a> as my HTTP test driver. I’m aware of lots of different testing tools out there, the most venerable being projects like <a href="https://en.wikipedia.org/wiki/ApacheBench">ApacheBench (<code>ab</code>)</a> and <a href="https://github.com/wg/wrk"><code>wrk</code></a>, but <a href="https://en.wikipedia.org/wiki/ApacheBench#Concurrency_versus_threads"><code>ab</code> doesn’t do heavy concurrency</a> and <code>wrk</code> is… fairly old and has <a href="https://github.com/giltene/wrk2">some critiques</a>. k6 is modern and fits my needs pretty well.</li>
  <li>I’ll use <a href="https://github.com/astrofrog/psrecord"><code>psrecord</code></a> to measure each reverse proxy’s resource use. You could measure this a million different ways, from prometheus to something super heavy-handed, but <code>psrecord</code> is more than sufficient. I just want to peek at one process’s (and it’s children’s) resource usage.</li>
  <li>I’ll build hosts with Terraform (because That’s What We Use These Days) in EC2 and iterate with a simple bash script. I’ll visualize stuff with <a href="http://gnuplot.info/">gnuplot</a> because they <a href="https://twitter.com/gnuplot5/status/1564036921885708288">tweeted at me</a> (that’s a joke, I just like gnuplot)</li>
</ul>

<h4 id="hypothesis">Hypothesis</h4>

<figure><img src="https://blog.tjll.net/generated/flaming-ship-277x277-06df14.png" itemprop="image" alt="Image via DALL·E"/><figcaption>Image via DALL·E</figcaption></figure>

<p>This is my blog post, so I get to pretend to be a real scientist here.
Here’s my hypotheses for these tests:</p>

<ul>
  <li>Nginx will, overall, perform better than Caddy. I love Caddy! Don’t get me wrong. But Nginx is <em>specifically designed</em> to be a fast reverse proxy and it has had years of lead time to perfect itself. How much faster? I don’t know. That’s what we’re here to find out!</li>
  <li>Caddy may perform better with out-of-the-box defaults. Without thinking too hard about it, I’d bet that Nginx may not parallelize aggressively, while Caddy probably benefits from lots of goroutines spinning off everywhere to handle requests. We may even see better performance than Nginx in the non-optimized case, but I’ll predict against that.</li>
  <li>I would predict that the reverse proxies will perform best responding with synthetic responses, then static HTML file content, then reverse proxied requests. I may tweak tests so see whether you can make static asset responses faster via caching.</li>
</ul>

<h4 id="procedures">Procedures</h4>

<p>Lucky for you, I’ve open sourced everything that I ran in these tests so that you can see them yourself. At the conclusion of writing all of my automation, each test looked like this (once configuring my AWS credentials and entering my nix shell):</p>



<p>“VUs” are k6’s term for “virtual users”, or the number of concurrent agents simulating traffic against the system under test. This script will:</p>

<ul>
  <li>Create two EC2 instances - their default size is <code>c5.xlarge</code>. I opted for the <code>c5</code> series because I doubt I’ll be memory-bound, and I also want to give the proxies a chance to flex their concurrency chops (these instances have 4 cores). The instances are in a shared security group so that they can chatter easily.</li>
  <li>Configure the system under test (SUT) as well as the test driver with NixOS. This sets up one with the proxies ready to test (though not started) and the other with k6 installed.
    <ul>
      <li>“Why NixOS?” could be a long answer, but here’s the short one: it lets me pin everything to a specific revision so ensure my tests are 100% reproducible, from the kernel/glibc up to the nginx and caddy builds, also I am a configuration management snob and Ansible gives me hives.</li>
    </ul>
  </li>
  <li>Then for <code>nginx</code> and <code>caddy</code> – and for each test type (we’re going <code>O(n^2)</code> on tests, baby):
    <ul>
      <li><code>ssh</code> into the SUT</li>
      <li>Start the service</li>
      <li>Attach <a href="https://github.com/astrofrog/psrecord">psrecord</a> to the daemon</li>
      <li><code>ssh</code> into the test driver</li>
      <li>Execute my k6 test script</li>
      <li>Copy over the test results from the test driver</li>
      <li>Copy over the resource measurements from the SUT</li>
    </ul>
  </li>
  <li>Finally, compile the data. I’m collecting a table of metrics from the combined <code>psrecord</code> table as well as some choice data from the k6 JSON report. I’ll feed what I can to gnuplot for pretty pictures.</li>
</ul>

<p>I’d also like to call out that I did some light validation that my tests were consistent and repeatable by re-running tests in a few scenarios and I found that my results were <em>very</em> consistent. From what I could tell, my automation is stable and reliable.</p>

<h5 id="configuration">Configuration</h5>

<p><em>How</em> I’m configuring these daemons is pretty important, too.</p>

<p>In my preliminary tests I measured some differences when observing how locations (in <code>nginx.conf</code>) and matchers (in my <code>Caddyfile</code>) behave. This is expected, as encountering a conditional or predicate of some type for every request incurs overhead, so I’m working with single-purpose configuration files.</p>

<p>(To be clear, I’m talking about stanzas like <code>location / { ... }</code> in an <code>nginx.conf</code> file. Does each reverse proxy have different performance profiles for how they match incoming requests? Almost certainly. And I should probably test that! But I’m already in over my head, and this exercise is purely about “how fast can they possibly go without breaking”, so adding request matching overhead as a variable is one variable too many at the moment).</p>

<h6 id="defaults">Defaults</h6>

<p>Anyway, here’s how I configured each service with out-of-the box defaults. The synthetic response configuration files are short – first, the <code>Caddyfile</code>:</p>

<div><div><pre><code>:8080 {
  respond &#34;Hello, world!&#34;
}
</code></pre></div></div>

<p>…then the <code>nginx.conf</code>:</p>

<div><div><pre><code>events {
    use epoll;
}

http {
    access_log off;

    server {
        listen 0.0.0.0:8080;

        return 200 &#34;Hello, world!&#34;;
    }
}
</code></pre></div></div>

<p>Similarly, the settings for static file serving with minimal defaults are straightforward:</p>

<pre><code>:8080 {
  root * /srv/static
  file_server
}
</code></pre>

<div><div><pre><code>events {
    use epoll;
}

http {
    access_log off;

    server {
        listen 0.0.0.0:8080;

        location / {
            alias /srv/static/;
        }
    }
}
</code></pre></div></div>

<p>And finally, a generic reverse proxy stanza:</p>

<pre><code>:8080 {
  reverse_proxy localhost:8081
}
</code></pre>

<div><div><pre><code>events {
    use epoll;
}

http {
    access_log off;

    server {
        listen 0.0.0.0:8080;

        location / {
            proxy_pass http://127.0.0.1:8081;
        }
    }
}
</code></pre></div></div>

<p>Take note that, for both Caddy and Nginx, I am <em>not</em> enabling access logs. That’s a potential bottleneck and we aren’t trying to measure performance+logging, just trying to zero in on how fast each service serves requests.</p>

<h6 id="optimized">Optimized</h6>

<p>Compared to their defaults, what does an optimized configuration for both Caddy and Nginx look like?</p>

<p>For Caddy, I <a href="https://caddy.community/t/seeking-performance-suggestions-for-optimized-caddyfile/17052">asked the experts</a>! Both Francis and Matt (Matt is the original author and <a href="https://en.wikipedia.org/wiki/Benevolent_dictator_for_life">BDFL</a> of Caddy) offered some advice, although most of it culminated with “there’s probably not a lot to tweak”. That’s fair enough! Many of the settings they offered as knobs and dials play more into long-running or persistent connections which I hadn’t set any tests for. (Matt also suggested large response body tests, which I didn’t originally include, but was a good idea, so I had to re-run all my tests over. Alas!)</p>

<p>Additionally, Matt had two requests of me:</p>
<ol>
  <li>To test this <a href="https://caddy.community/t/seeking-performance-suggestions-for-optimized-caddyfile/17052/4">recently released beta of Caddy</a> that incorporates some changes that may impact performance one way or the other.</li>
  <li>To test <a href="https://caddy.community/t/seeking-performance-suggestions-for-optimized-caddyfile/17052/7">this pull request that implements <code>sendfile</code></a>, which should be a definite improvement (I set <code>sendfile on;</code> in the optimized Nginx configuration, for example).</li>
</ol>

<p>Sure! To be fair between Nginx and Caddy, I’ll include the tests with these added improvements as an appendix, because my goal with my standard barrage of tests is to compare vanilla, generally-available releases. Once these Caddy patches are out, their benefits (if the results identify them as such) can be directly applicable.</p>

<p>By contrast, here is a delta for my tuned Nginx configuration. Nginx is hungry – hungry for hot dogs (and more processor cores):</p>

<div><div><pre><code>     events {
         use epoll;
<span>+        worker_connections 1024;
</span>     }
<span>+
+    worker_processes auto;
</span>
     http {
         access_log off;
<span>+        sendfile on;
+        proxy_cache_path /tmp/nginx-cache keys_zone=cache:10m;
+
</span>
         server {
             listen 0.0.0.0:8080;
<span>+            proxy_cache cache;
</span></code></pre></div></div>

<p><a href="http://nginx.org/en/docs/ngx_core_module.html#worker_processes"><code>worker_processes</code></a> are going to be the magic words for Nginx here to get at those cores. <code>auto</code> is a convenient choice for us, so we’ll use that. In <a href="https://www.nginx.com/blog/tuning-nginx/">this Nginx blog post</a> there are more tips for us, including advice to bump up <code>worker_connections</code> and to use <code>sendfile()</code> in our http/server/location context. I’ll reference the advice linked to in that blog post to get caching functioning as effectively as possible, too, using those <code>proxy_*</code> settings.</p>

<p>I didn’t change a <em>ton</em> here but it’s the set of changes that appear to safely make the biggest improvements. Many of the other suggestions in that aforementioned Nginx blog post are regarding operating system-level tweaks, which I’ve applied from the beginning (you can investigate the source code for my benchmarks for the specific <code>ulimit</code> and <code>sysctl</code> changes in the <code>base.nix</code> file).</p>

<h4 id="results">Results</h4>

<p>Are you ready for numbers??????
Did you skip here from the intro?
Have you no shame?</p>

<p>Here’s how to read the following charts and graphs:</p>

<ul>
  <li>The big one in the middle is <em>total HTTP response time</em>. <strong>Lower bars are better</strong> because it means the server was responding faster.</li>
  <li>The upper right chart is errors. If they start to go up, the reverse proxy is starting to fail - refused connections, that kind of thing. <strong>Any bars are bad</strong> (it means errors happened).</li>
  <li>The lower right chart is for <em>overall number of requests</em>. This is a function of a few mechanisms which includes how quickly the test driver can fire off HTTP requests. <strong>Higher bars are better</strong>.</li>
  <li>The second set of graphs measure CPU and memory use with CPU utilization on the left Y axis and memory on the right Y axis. Lower numbers are better, generally.</li>
</ul>

<p>My graphs may look a little cramped, but I erred on the side of “ease of comparison” at the cost of density - otherwise it can be challenging to try and compare across different variables. I’ve set the <code>enhanced</code> flag on the gnuplot files, so you can click on the <strong>name</strong> of a plotted series in order to toggle it on and off. Clicking anywhere on the plot SVG will attach coordinates to your mouse but I have no idea what in the hell the numbers are (they don’t look like they’re tied to any axis).</p>

<h5 id="10-clients">10 Clients</h5>

<p>Let’s start at the beginning: 10 concurrent clients. Remember, results are in milliseconds (ms). Although 10 concurrent clients is small, I’m also not throttling clients, and once a request completes, it comes right back, so there’s no time for the proxies to rest between requests. This means that although the volume is low, the rate of activity is still pretty busy.</p>

<figure>

</figure>

<table>
  <thead>
    <tr>
      <th>test</th>
      <th>min</th>
      <th>median</th>
      <th>average</th>
      <th>p90</th>
      <th>p95</th>
      <th>max</th>
      <th>requests</th>
      <th>errors</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>nginx-default-synthetic</td>
      <td>0.10</td>
      <td>0.18</td>
      <td>0.22</td>
      <td>0.31</td>
      <td>0.40</td>
      <td>19.15</td>
      <td>1062277</td>
      <td>0</td>
    </tr>
    <tr>
      <td>caddy-default-synthetic</td>
      <td>0.12</td>
      <td>0.22</td>
      <td>0.26</td>
      <td>0.35</td>
      <td>0.48</td>
      <td>24.90</td>
      <td>937547</td>
      <td>0</td>
    </tr>
    <tr>
      <td>nginx-optimized-synthetic</td>
      <td>0.10</td>
      <td>0.18</td>
      <td>0.22</td>
      <td>0.31</td>
      <td>0.39</td>
      <td>4474.83</td>
      <td>1051255</td>
      <td>0</td>
    </tr>
    <tr>
      <td>nginx-default-html-large</td>
      <td>0.41</td>
      <td>2.18</td>
      <td>2.27</td>
      <td>3.88</td>
      <td>4.20</td>
      <td>14.76</td>
      <td>126996</td>
      <td>0</td>
    </tr>
    <tr>
      <td>caddy-default-html-large</td>
      <td>0.46</td>
      <td>1.93</td>
      <td>2.27</td>
      <td>3.71</td>
      <td>3.96</td>
      <td>11.98</td>
      <td>126978</td>
      <td>0</td>
    </tr>
    <tr>
      <td>nginx-optimized-html-large</td>
      <td>0.39</td>
      <td>2.26</td>
      <td>2.27</td>
      <td>3.67</td>
      <td>3.96</td>
      <td>22.63</td>
      <td>127025</td>
      <td>0</td>
    </tr>
    <tr>
      <td>nginx-default-html-small</td>
      <td>0.12</td>
      <td>0.22</td>
      <td>0.25</td>
      <td>0.34</td>
      <td>0.43</td>
      <td>20.13</td>
      <td>949551</td>
      <td>0</td>
    </tr>
    <tr>
      <td>caddy-default-html-small</td>
      <td>0.15</td>
      <td>0.27</td>
      <td>0.32</td>
      <td>0.43</td>
      <td>0.57</td>
      <td>18.88</td>
      <td>795378</td>
      <td>0</td>
    </tr>
    <tr>
      <td>nginx-optimized-html-small</td>
      <td>0.13</td>
      <td>0.25</td>
      <td>0.28</td>
      <td>0.39</td>
      <td>0.47</td>
      <td>20.60</td>
      <td>850631</td>
      <td>0</td>
    </tr>
    <tr>
      <td>nginx-default-proxy</td>
      <td>0.20</td>
      <td>0.69</td>
      <td>0.70</td>
      <td>0.86</td>
      <td>0.92</td>
      <td>14.42</td>
      <td>395210</td>
      <td>0</td>
    </tr>
    <tr>
      <td>caddy-default-proxy</td>
      <td>0.22</td>
      <td>0.45</td>
      <td>0.53</td>
      <td>0.78</td>
      <td>1.04</td>
      <td>14.50</td>
      <td>506388</td>
      <td>0</td>
    </tr>
    <tr>
      <td>nginx-optimized-proxy</td>
      <td>0.21</td>
      <td>0.45</td>
      <td>0.51</td>
      <td>0.67</td>
      <td>0.88</td>
      <td>49.34</td>
      <td>528288</td>
      <td>0</td>
    </tr>
  </tbody>
</table>

<p>Alright, we’re dealing with a relatively small number of concurrent users, and the results aren’t terribly surprising. That said, we’re gathering useful baselines to know which requests are more taxing than others.</p>

<ul>
  <li>The median and mode are so close for many of these tests that the little deltas almost aren’t noticeable. We hover around ~0.2ms for most requests, although the very large HTML responses take longer, which we’d expect. They’re pretty consistent at about ~2ms as well.</li>
  <li>We have one case of <code>max</code> being an outlier, which reinforces the fact that we should primarily be looking at p95 rather than <code>max</code> for worse-case scenarios. <code>max</code> is still useful to know, but not strictly representative. I’ll still include it in the tables, but I’m not intensely interested in it.</li>
  <li>No errors (I should hope so) and the differences between synthetic, file-based, and reverse proxy overall request count are about what I would expect. Synthetic should be easy, replying with HTML files is a little more, reverse proxying takes a few more bells and whistles, and large HTML responses are the most burdensome.</li>
</ul>

<p>What else? The synthetic responses - which have the least complexity - push the highest request count, as you might expect. Nginx beats out Caddy for this test whether optimized or not in terms of overall requests. This one is interesting: look at the minimum and median response times for synthetic responses for either Caddy or Nginx (default or optimized, it doesn’t matter). There’s a very consistent 0.02ms penalty on Caddy’s response time. I’m not sure what it means! But it’s an interesting finding that I would wager is a golang runtime tax.</p>

<p>The charts tell a pretty clear story: large HTML responses take a lot of time. Despite those bars skewing the Y-axis, the values are still really close (within ~2ms of each other for most stats). All other test types (synthetic, small HTML, reverse proxied) are super, super close.</p>

<p>Now let’s look at resource consumption:</p>

<figure>

</figure>

<p>First and foremost, remember that <code>c5.xlarge</code> machines have 4 cores per host. That’s important context: the first thing that pops out to me is that Caddy seems to use whatever it can (Caddy’s highest line hovers around 300%, or 3 cores), but it’s apparent that – by default – nginx is bound to one core (it caps out at 100% CPU, or using one entire core), which is <a href="http://nginx.org/en/docs/ngx_core_module.html#worker_processes">consistent with the nginx documentation that states <code>worker_processes</code> defaults to 1</a>. The optimized tests have much more breathing room and use whatever they can. Nginx uses almost no memory (relatively speaking) whereas Caddy, presumably at startup, grabs a small handful (maybe 40MB) and doesn’t go far beyond that. Presumably that’s moreso the golang runtime more than anything else.</p>

<p>I also found that the “difficulty ranking” for each test sorted by CPU utilization was interesting because it’s re-ordered based on whether we look at the Nginx or Caddy graphs. Nginx, in “most busy” order, goes proxy → HTML small → HTML large → synthetic. Caddy is ordered HTML small → proxy → synthetic → HTML large. My hunch is that Caddy may be really grinding on small HTML tests because it’s copying a lot of buffers around.</p>

<p>Remember, this is 10 concurrent connections, so there’s nothing pressing hard on our reverse proxies. <strong>YET</strong>. Let’s bump it up to 200 concurrent clients.</p>

<h5 id="200-clients">200 Clients</h5>

<figure>

</figure>

<table>
  <thead>
    <tr>
      <th>test</th>
      <th>min</th>
      <th>median</th>
      <th>average</th>
      <th>p90</th>
      <th>p95</th>
      <th>max</th>
      <th>requests</th>
      <th>errors</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>nginx-default-synthetic</td>
      <td>0.11</td>
      <td>4.15</td>
      <td>5.67</td>
      <td>12.08</td>
      <td>14.95</td>
      <td>310.66</td>
      <td>1007186</td>
      <td>0</td>
    </tr>
    <tr>
      <td>caddy-default-synthetic</td>
      <td>0.13</td>
      <td>4.14</td>
      <td>5.64</td>
      <td>11.77</td>
      <td>14.76</td>
      <td>67.48</td>
      <td>1025549</td>
      <td>0</td>
    </tr>
    <tr>
      <td>nginx-optimized-synthetic</td>
      <td>0.11</td>
      <td>4.14</td>
      <td>5.66</td>
      <td>12.05</td>
      <td>14.95</td>
      <td>69.04</td>
      <td>1016499</td>
      <td>0</td>
    </tr>
    <tr>
      <td>nginx-default-html-large</td>
      <td>0.67</td>
      <td>33.62</td>
      <td>47.03</td>
      <td>90.63</td>
      <td>213.61</td>
      <td>3210.70</td>
      <td>127116</td>
      <td>0</td>
    </tr>
    <tr>
      <td>caddy-default-html-large</td>
      <td>0.83</td>
      <td>34.48</td>
      <td>47.12</td>
      <td>90.23</td>
      <td>214.51</td>
      <td>1673.57</td>
      <td>127094</td>
      <td>0</td>
    </tr>
    <tr>
      <td>nginx-optimized-html-large</td>
      <td>0.66</td>
      <td>32.02</td>
      <td>47.00</td>
      <td>92.07</td>
      <td>212.89</td>
      <td>3207.05</td>
      <td>127212</td>
      <td>0</td>
    </tr>
    <tr>
      <td>nginx-default-html-small</td>
      <td>0.14</td>
      <td>4.66</td>
      <td>5.93</td>
      <td>11.58</td>
      <td>15.23</td>
      <td>67.54</td>
      <td>981828</td>
      <td>0</td>
    </tr>
    <tr>
      <td>caddy-default-html-small</td>
      <td>0.17</td>
      <td>4.68</td>
      <td>6.40</td>
      <td>13.26</td>
      <td>17.08</td>
      <td>210.98</td>
      <td>920272</td>
      <td>0</td>
    </tr>
    <tr>
      <td>nginx-optimized-html-small</td>
      <td>0.15</td>
      <td>4.98</td>
      <td>6.72</td>
      <td>14.44</td>
      <td>17.64</td>
      <td>74.88</td>
      <td>858443</td>
      <td>0</td>
    </tr>
    <tr>
      <td>nginx-default-proxy</td>
      <td>0.24</td>
      <td>14.69</td>
      <td>14.68</td>
      <td>17.65</td>
      <td>18.15</td>
      <td>186.88</td>
      <td>406757</td>
      <td>0</td>
    </tr>
    <tr>
      <td>caddy-default-proxy</td>
      <td>0.27</td>
      <td>10.97</td>
      <td>13.28</td>
      <td>25.70</td>
      <td>32.29</td>
      <td>103.55</td>
      <td>449154</td>
      <td>0</td>
    </tr>
    <tr>
      <td>nginx-optimized-proxy</td>
      <td>0.25</td>
      <td>9.81</td>
      <td>10.25</td>
      <td>11.47</td>
      <td>16.12</td>
      <td>63.89</td>
      <td>580416</td>
      <td>0</td>
    </tr>
  </tbody>
</table>

<p>A little more interesting. Caddy cranks out more synthetic responses than even optimized Nginx, but large HTML tests are shockingly close for all cases. Nginx does <em>extremely</em> well in the optimized proxy tests, with ½ p95 response times as Caddy and noticeably better throughput. Caddy does surprisingly well at those difficult large HTML responses: it maintains throughput parity with both Nginx configurations while clocking in a <code>max</code> turnaround <em>way</em> lower than Nginx. Going along with the resource graphs for 10 concurrent clients, Caddy seems to struggle with lots of little file buffers, as its <code>max</code> is really up there. Nginx, meanwhile, does <em>super</em> well at that case with about ~60,000 more requests in the 30-second window (though that’s the default configuration - I’m unsure why the optimized config didn’t reach that level).</p>

<figure>

</figure>

<p>This reinforces the prior guess about CPU constraints. For the more difficult tasks, Caddy is claiming all available CPU, while nginx is stuck with one in the default configuration but bursts to more in the optimized case. Given that the HTML test hits 400% but the rest don’t reach the ceiling, I would guess that the CPU might be in <code>iowait</code> for the HTML files because Caddy doesn’t have an inbuilt caching mechanism. That’s something we can investigate later. Caddy uses a little more memory, but it’s not near concerning levels yet.</p>

<p>The graph is crowded, but if you click on the line name to filter some of them out, you can see a garbage collection stairstep forming in the memory graph for Caddy’s proxy tests. This may be more pronounced as we go along.</p>

<p>Oh boy. Here comes 500 concurrent users:</p>

<h5 id="500-clients">500 Clients</h5>

<figure>

</figure>

<table>
  <thead>
    <tr>
      <th>test</th>
      <th>min</th>
      <th>median</th>
      <th>average</th>
      <th>p90</th>
      <th>p95</th>
      <th>max</th>
      <th>requests</th>
      <th>errors</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>nginx-default-synthetic</td>
      <td>0.00</td>
      <td>17.05</td>
      <td>20.64</td>
      <td>34.34</td>
      <td>51.28</td>
      <td>173.30</td>
      <td>651900</td>
      <td>1.67</td>
    </tr>
    <tr>
      <td>caddy-default-synthetic</td>
      <td>0.22</td>
      <td>13.57</td>
      <td>16.40</td>
      <td>26.06</td>
      <td>42.36</td>
      <td>140.70</td>
      <td>811764</td>
      <td>0.00</td>
    </tr>
    <tr>
      <td>nginx-optimized-synthetic</td>
      <td>0.20</td>
      <td>13.70</td>
      <td>16.56</td>
      <td>26.21</td>
      <td>43.19</td>
      <td>137.09</td>
      <td>806307</td>
      <td>0.00</td>
    </tr>
    <tr>
      <td>nginx-default-html-large</td>
      <td>1.02</td>
      <td>50.63</td>
      <td>117.64</td>
      <td>279.68</td>
      <td>464.35</td>
      <td>26494.41</td>
      <td>126886</td>
      <td>0.00</td>
    </tr>
    <tr>
      <td>caddy-default-html-large</td>
      <td>1.24</td>
      <td>51.16</td>
      <td>118.28</td>
      <td>276.32</td>
      <td>436.14</td>
      <td>26849.83</td>
      <td>127016</td>
      <td>0.00</td>
    </tr>
    <tr>
      <td>nginx-optimized-html-large</td>
      <td>0.99</td>
      <td>51.24</td>
      <td>118.19</td>
      <td>277.46</td>
      <td>432.25</td>
      <td>26929.39</td>
      <td>126922</td>
      <td>0.00</td>
    </tr>
    <tr>
      <td>nginx-default-html-small</td>
      <td>0.00</td>
      <td>17.37</td>
      <td>21.16</td>
      <td>35.42</td>
      <td>52.57</td>
      <td>168.44</td>
      <td>637746</td>
      <td>1.50</td>
    </tr>
    <tr>
      <td>caddy-default-html-small</td>
      <td>0.27</td>
      <td>14.20</td>
      <td>17.21</td>
      <td>27.44</td>
      <td>44.67</td>
      <td>225.08</td>
      <td>803503</td>
      <td>0.00</td>
    </tr>
    <tr>
      <td>nginx-optimized-html-small</td>
      <td>0.23</td>
      <td>16.48</td>
      <td>19.26</td>
      <td>30.32</td>
      <td>46.08</td>
      <td>220.35</td>
      <td>706722</td>
      <td>0.00</td>
    </tr>
    <tr>
      <td>nginx-default-proxy</td>
      <td>0.00</td>
      <td>19.30</td>
      <td>36.36</td>
      <td>31.85</td>
      <td>57.60</td>
      <td>777.42</td>
      <td>405987</td>
      <td>0.64</td>
    </tr>
    <tr>
      <td>caddy-default-proxy</td>
      <td>0.40</td>
      <td>39.62</td>
      <td>42.51</td>
      <td>68.43</td>
      <td>81.30</td>
      <td>284.87</td>
      <td>351182</td>
      <td>0.00</td>
    </tr>
    <tr>
      <td>nginx-optimized-proxy</td>
      <td>0.67</td>
      <td>24.72</td>
      <td>27.74</td>
      <td>29.83</td>
      <td>53.18</td>
      <td>1044.81</td>
      <td>536393</td>
      <td>0.00</td>
    </tr>
  </tbody>
</table>

<p>Wew lad! Now we’re cooking with gas. Most noteworthy:</p>

<ul>
  <li>Singly-cored nginx has started to throw errors. About 1.6% for synthetic tests, sub-1% for proxied tests, and around ~1.5% for small HTML tests. However, with more workers, Nginx can handle the load.</li>
  <li>It looks like Caddy does really well when it’s solely working within its own process. The Caddy synthetic response request count is <em>really</em> up there.</li>
  <li>The small HTML tests are a little surprising. Caddy outperforms Nginx even when Nginx is optimized. Especially given that optimized Nginx is caching and our GA release of Caddy doesn’t have <code>sendfile</code>, I’d expect them to be a little closer, but Caddy leads.</li>
  <li>Reverse proxy latency is still a notable pain point in the Caddy tests. The resource graphs may help explain some of this:</li>
</ul>

<figure>

</figure>

<p>Remember that default Nginx is starting to error out, so we’re observing the limits of what it can do with one <code>c5.xlarge</code> core.</p>

<p>I would venture to guess that Caddy spins out some sort of golang structure for each reverse proxy connection because we’re seeing the tell-tale signs of garbage collection in Caddy’s memory graph in the reverse proxy tests. In our blow-out test, that memory graph may be even more jagged. At 500 concurrent clients, whatever is sitting in garbage-collectible memory is starting to look non-trivial in size, too. The graph sits around at the 96MB mark.</p>

<h5 id="1000-clients">1,000 Clients</h5>

<p><strong><a href="https://knowyourmeme.com/memes/chonk-oh-lawd-he-comin">OH LAWD, HE COMIN’</a></strong></p>

<figure>

</figure>

<table>
  <thead>
    <tr>
      <th>test</th>
      <th>min</th>
      <th>median</th>
      <th>average</th>
      <th>p90</th>
      <th>p95</th>
      <th>max</th>
      <th>requests</th>
      <th>errors</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>nginx-default-synthetic</td>
      <td>0.00</td>
      <td>0.76</td>
      <td>6.62</td>
      <td>17.27</td>
      <td>31.72</td>
      <td>292.06</td>
      <td>344427</td>
      <td>97.38</td>
    </tr>
    <tr>
      <td>caddy-default-synthetic</td>
      <td>0.28</td>
      <td>28.28</td>
      <td>34.30</td>
      <td>43.66</td>
      <td>92.14</td>
      <td>225.71</td>
      <td>825893</td>
      <td>0.00</td>
    </tr>
    <tr>
      <td>nginx-optimized-synthetic</td>
      <td>0.24</td>
      <td>28.79</td>
      <td>34.56</td>
      <td>43.61</td>
      <td>91.59</td>
      <td>249.39</td>
      <td>812550</td>
      <td>0.00</td>
    </tr>
    <tr>
      <td>nginx-default-html-large</td>
      <td>1.14</td>
      <td>57.53</td>
      <td>224.04</td>
      <td>392.48</td>
      <td>752.06</td>
      <td>30031.42</td>
      <td>127304</td>
      <td>0.00</td>
    </tr>
    <tr>
      <td>caddy-default-html-large</td>
      <td>1.47</td>
      <td>64.93</td>
      <td>244.12</td>
      <td>432.91</td>
      <td>790.06</td>
      <td>53751.69</td>
      <td>127170</td>
      <td>0.00</td>
    </tr>
    <tr>
      <td>nginx-optimized-html-large</td>
      <td>1.29</td>
      <td>62.18</td>
      <td>250.73</td>
      <td>371.24</td>
      <td>738.56</td>
      <td>53439.86</td>
      <td>127237</td>
      <td>0.00</td>
    </tr>
    <tr>
      <td>nginx-default-html-small</td>
      <td>0.00</td>
      <td>0.64</td>
      <td>6.54</td>
      <td>16.37</td>
      <td>31.14</td>
      <td>309.75</td>
      <td>340595</td>
      <td>98.17</td>
    </tr>
    <tr>
      <td>caddy-default-html-small</td>
      <td>0.31</td>
      <td>30.92</td>
      <td>38.07</td>
      <td>64.27</td>
      <td>106.41</td>
      <td>333.18</td>
      <td>770682</td>
      <td>0.00</td>
    </tr>
    <tr>
      <td>nginx-optimized-html-small</td>
      <td>0.29</td>
      <td>32.73</td>
      <td>38.68</td>
      <td>49.53</td>
      <td>97.66</td>
      <td>218.20</td>
      <td>729572</td>
      <td>0.00</td>
    </tr>
    <tr>
      <td>nginx-default-proxy</td>
      <td>0.00</td>
      <td>4.09</td>
      <td>22.94</td>
      <td>24.15</td>
      <td>42.49</td>
      <td>4540.04</td>
      <td>351324</td>
      <td>72.59</td>
    </tr>
    <tr>
      <td>caddy-default-proxy</td>
      <td>0.44</td>
      <td>62.64</td>
      <td>95.01</td>
      <td>114.17</td>
      <td>157.29</td>
      <td>1604.57</td>
      <td>314757</td>
      <td>0.00</td>
    </tr>
    <tr>
      <td>nginx-optimized-proxy</td>
      <td>0.38</td>
      <td>53.87</td>
      <td>57.52</td>
      <td>66.32</td>
      <td>110.75</td>
      <td>262.62</td>
      <td>516539</td>
      <td>0.00</td>
    </tr>
  </tbody>
</table>

<p>At 1,000 concurrent clients, the singly-cored nginx starts to fall down. Error rates are very high and the overall request count reflects that fully leveraging 4 cores saves Caddy and the optimized Nginx. In the synthetic and large HTML tests, Caddy and optimized Nginx are really pretty close.</p>

<p>The most noteworthy number here are the proxy tests - optimized Nginx does <em>much</em> better than Caddy (200,000(!) more requests and much better latency turnaround time). Bravo! Synthetic tests are sort of interesting because – remember that the entire request never hits a static HTML file or reverse proxied target – latency numbers are <strong>very</strong> close but Caddy sent back 10,000 more responses.</p>

<figure>

</figure>

<p>That last graph shows some pretty clear garbage collection happening in the golang runtime. Default-config Nginx CPU use falters presumably due to lots of network traffic chaos and connections being missed. At 1,000 clients, it’s interesting to note the lack of staircase GC patterns in Caddy’s HTML and synthetic tests - the big GC sweeps get caused due to Caddy’s reverse proxy plumbing. I’m now <em>pretty</em> confident that the reverse proxy code’s GC time is what ails Caddy’s reverse proxy performance.</p>

<p>The optimized Nginx resource graphs top out at 200%, which is a little confusing. My assumption was that <code>auto</code> would use all available cores, but that may not be the case. In any event, the graphs are clear: Nginx is really efficient in either configuration style. The memory is kept low, and CPU doesn’t blow out completely - but it makes me wonder if more gains are to be had in the optimized Nginx config by altering <code>worker_processes</code>.</p>

<p><strong>Note</strong>: I’ve now tested this with a manual setting of <code>4</code> for <code>worker_processes</code> and it seems to behave the same. This probably warrants further investigation and potentially turning up the value beyond the physical core count.</p>

<h5 id="10000-clients">10,000 Clients</h5>

<p>You know what? I can’t help it. I wanted to <em>see</em> Nginx and Caddy fail to know what that behavior looks like, so here we are:</p>

<figure>

</figure>

<table>
  <thead>
    <tr>
      <th>test</th>
      <th>min</th>
      <th>median</th>
      <th>average</th>
      <th>p90</th>
      <th>p95</th>
      <th>max</th>
      <th>requests</th>
      <th>errors</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>nginx-default-synthetic</td>
      <td>0.00</td>
      <td>1.17</td>
      <td>50.17</td>
      <td>153.57</td>
      <td>304.43</td>
      <td>1293.23</td>
      <td>332152</td>
      <td>99.18</td>
    </tr>
    <tr>
      <td>caddy-default-synthetic</td>
      <td>0.19</td>
      <td>306.45</td>
      <td>386.70</td>
      <td>676.05</td>
      <td>1084.56</td>
      <td>2052.79</td>
      <td>727305</td>
      <td>0.00</td>
    </tr>
    <tr>
      <td>nginx-optimized-synthetic</td>
      <td>0.00</td>
      <td>2.38</td>
      <td>54.26</td>
      <td>130.25</td>
      <td>387.82</td>
      <td>2311.45</td>
      <td>324380</td>
      <td>95.98</td>
    </tr>
    <tr>
      <td>nginx-default-html-large</td>
      <td>0.00</td>
      <td>1.45</td>
      <td>67.31</td>
      <td>254.32</td>
      <td>463.81</td>
      <td>3715.41</td>
      <td>324881</td>
      <td>99.80</td>
    </tr>
    <tr>
      <td>caddy-default-html-large</td>
      <td>1.71</td>
      <td>218.42</td>
      <td>2874.14</td>
      <td>6649.94</td>
      <td>17990.31</td>
      <td>58944.72</td>
      <td>124604</td>
      <td>0.00</td>
    </tr>
    <tr>
      <td>nginx-optimized-html-large</td>
      <td>0.00</td>
      <td>1.53</td>
      <td>100.99</td>
      <td>142.84</td>
      <td>749.10</td>
      <td>3496.60</td>
      <td>307948</td>
      <td>95.71</td>
    </tr>
    <tr>
      <td>nginx-default-html-small</td>
      <td>0.00</td>
      <td>1.16</td>
      <td>48.19</td>
      <td>127.09</td>
      <td>281.31</td>
      <td>1629.37</td>
      <td>329233</td>
      <td>99.31</td>
    </tr>
    <tr>
      <td>caddy-default-html-small</td>
      <td>0.22</td>
      <td>343.55</td>
      <td>438.22</td>
      <td>838.89</td>
      <td>1149.83</td>
      <td>1932.29</td>
      <td>668881</td>
      <td>0.00</td>
    </tr>
    <tr>
      <td>nginx-optimized-html-small</td>
      <td>0.00</td>
      <td>2.52</td>
      <td>50.68</td>
      <td>130.00</td>
      <td>357.75</td>
      <td>2664.59</td>
      <td>325973</td>
      <td>96.36</td>
    </tr>
    <tr>
      <td>nginx-default-proxy</td>
      <td>0.00</td>
      <td>1.30</td>
      <td>61.41</td>
      <td>209.51</td>
      <td>433.00</td>
      <td>2507.88</td>
      <td>327086</td>
      <td>99.89</td>
    </tr>
    <tr>
      <td>caddy-default-proxy</td>
      <td>13.35</td>
      <td>1228.58</td>
      <td>1286.12</td>
      <td>1406.96</td>
      <td>1498.23</td>
      <td>21282.06</td>
      <td>230619</td>
      <td>0.00</td>
    </tr>
    <tr>
      <td>nginx-optimized-proxy</td>
      <td>0.00</td>
      <td>2.06</td>
      <td>47.57</td>
      <td>123.78</td>
      <td>252.50</td>
      <td>2539.05</td>
      <td>326510</td>
      <td>98.55</td>
    </tr>
  </tbody>
</table>

<p>Now <em>this</em> is interesting. First of all – our axes are blown out. It’s more worthwhile to look at the error and total request count charts and the table for everything else.</p>

<p>And… we have extremely different failure behavior! Nginx, once at capacity, will start refusing connections. Error rates are high and requests are down. By contrast, Caddy maintains an error rate of <strong>zero</strong> but sacrifices its latency turnaround times at the altar of “no errors”. You can see this clearly by comparing latency versus request count in the visual aid: Caddy starts to really lag but doesn’t give up on any requests, so responses are <em>really slow</em> but we get <em>a hell of a lot more</em> of them through. However, that’s only true for the synthetic tests and small HTML tests. For proxied requests and large HTML responses, Nginx responds with more, albeit with errors.</p>

<figure><img src="https://blog.tjll.net/generated/skeleton-meme-1000x868-9fea91.png" itemprop="image"/></figure>

<p>Nginx actually does a good job of keeping normal requests moving quickly when it drops those it can’t handle. Median and mode are decent even when it refuses many incoming connections – the ones that make it through are kept moving along speedily.</p>

<figure>

</figure>

<p>In trying to ensure that clients are served at any cost, Caddy starts eating up resources. Memory starts to climb in contrast to Nginx staying low in order to maintain better turnaround time for the clients that it <em>does</em> accept connections from. It seems like Caddy may want to spend more time ensuring that network writes are flushing out buffers to avoid bloating memory.</p>

<p>In particular, that large HTML response Caddy memory graph is troublesome. My Y-axis labels are starting to get drunk, but Caddy is really pushing it and memory reaches 1GB at one point. Oops! The jagged Caddy CPU graphs make me think that there may be a pause somewhere, but I’m not sure (I want to say that a mark and sweep might’ve happened, but that graph ranges for 30 seconds and I have a hard time imagining a GC running for multiple seconds, but maybe that is indeed what occurred).</p>

<h4 id="summary">Summary</h4>

<figure><img src="https://blog.tjll.net/generated/trophy-277x277-0ca100.png" itemprop="image" alt="Image via DALL·E"/><figcaption>Image via DALL·E</figcaption></figure>

<p>What did we learn?</p>

<ul>
  <li>The most striking piece of new knowledge for me was learning about <em>failure modes</em>. Nginx will fail by refusing or dropping connections, Caddy will fail by slowing everything down. Is one better than the other? For certain use-cases, almost certainly. Some folks will want fail-fast, while others will want to keep accepting connections at all costs. The key point is that there <em>is</em> a difference (frankly I think my preference is for fail-fast).</li>
  <li>As predicted, “synthetic” responses seem to be easiest, followed by small HTML file content, followed by reverse proxied requests, followed by <em>large</em> HTML content. Nginx’s caching behaviors let it really shine with static asset files (and, presumably, its <code>sendfile</code> capability).</li>
  <li>Caddy pays the cost for garbage collection, but it’s not an <em>oppressive</em> cost (at least at “normal” traffic levels). Nginx uses an almost effortless amount of memory. Caddy peaked at almost 160MB real memory allocated for non-breaking tests, which may or may not be significant depending on what amount of total memory is available to the OS. It remains to be seen what specific code path is causing all this <code>malloc</code>/<code>free</code>, but my tests seem to point at whatever mechanism underlies <code>reverse_proxy</code>.</li>
  <li>Caddy’s default configuration is good. We get all our cores unlocked and we rev up every resource available to use without any memory leaks. Recall that my “default” and “optimized” Caddy configurations are identical. Nginx is scoped to a single core by default (you can learn this from the documentation, but we’ve observed that against Caddy directly now).</li>
</ul>

<p>Before you hit really <strong>oppressive</strong> levels of traffic, Caddy and optimized Nginx are going to serve you well. My above bullet points are all important to consider at the edge cases, but based upon what I’ve observed, there are likely few times that the differences will come into play. Maybe when you get absolutely <em>flooded</em> with traffic. Maybe when <em>this</em> post gets flooded with traffic. Come at me bro, I’m on S3. Just try and take down Amazon.</p>

<p>Is there an answer to “is Caddy or Nginx better”? I don’t think so, but armed this knowledge, maybe you can make more informed decisions. There are other factors to consider when selecting a reverse proxy aside from performance alone. Do you want the bells and whistles that Caddy includes like first-part support for Let’s Encrypt and a native API? Do you want to carry your Nginx knowledge directly over to the well-supported k8s Nginx ingress controller? Does a C vs. golang runtime matter to you, from a performance, security, or profiling perspective?</p>

<p>I hope that this was a helpful exercise and provides useful data for future operations engineers. I really went overboard after initially asking, “are there hard numbers for this?” and ended up here. I’ll probably keep using Caddy where I am today – I make active, regular use of its Let’s Encrypt features, miscellaneous plugins, native API, and so on – but might turn to Nginx more often if I <em>know</em> I’ll be dealing with ungodly levels of inbound traffic.</p>

<p>I have no idea where this post will be shared, but you can either comment near the bottom in my embedded Discourse comments or I can find it on your tech news aggregator of choice. I’ll be there to answer questions and leave overly verbose comments.</p>

<hr/>

<h4 id="appendix-a-code">Appendix A: Code</h4>

<p>So, you want to run all these tests? <a href="https://github.com/tylerjl/benchmarking-proxies">Merry Christmas</a>, there’s nix and terraform under the tree.</p>

<p>That repository should have all the requisite documentation necessary to reproduce these results. You’ll need an AWS account and a local nix installation, but the rest is fairly automated. <em>Hopefully</em> I’ve done a good enough job that your results will be very close to mine. I’m not sure whether it matters, but my tests were performed in <code>us-west-2</code>. The instances sizes, NixOS version, and other specifics are defined in the repository.</p>

<p>My <code>bench.sh</code> test driver isn’t great – it’s sort-of-brittle bash but you’re welcome to carve it up. It doesn’t handle the Caddy <code>sendfile</code> tests out of the box. But hopefully it’s a good starting point.</p>

<h4 id="appendix-b-caddy-sendfile">Appendix B: Caddy <code>sendfile</code></h4>

<p>Okay, Matt. You ask and I deliver.</p>

<p>Per <a href="https://caddy.community/t/seeking-performance-suggestions-for-optimized-caddyfile/17052">this conversation</a>, Caddy has <em>just merged</em> <code>sendfile</code> support. This is good! <code>sendfile</code> avoids spurious memory operations and should speed things up. So let’s try it!</p>

<p>Here’s the overlay I applied to my NixOS configuration management to bring in a specific revision from the <code>master</code> branch of Caddy’s GitHub repository:</p>

<div><div><pre><code><span>+        overlays.caddyMaster = prev: final: {
+          caddyMaster = final.caddy.overrideAttrs (old: {
+            version = &#34;master&#34;;
+            src = prev.fetchFromGitHub {
+              owner = &#34;caddyserver&#34;;
+              repo = &#34;caddy&#34;;
+              rev = &#34;dd9813c65be3af8e222bda6e63f5eea9232c6eee&#34;;
+            };
+          });
+        };
</span></code></pre></div></div>

<p>I then set <code>services.caddy.package = pkgs.caddyMaster</code> to use my custom package (yes, I could’ve had my overlay override <code>caddy</code> but I was being paranoid to ensure I used the new version).</p>

<p>I then ran the same barrage of tests against a concurrency level of 500 because that number seemed to push things far without spilling over into bad p95 and max values. With those results, I can plot them against the other mainline Caddy 2.5.2 results. I’d prefer to compare apples to apples here instead of another full suite of <code>sendfile</code>-enabled Caddy against all variants of Nginx.</p>

<p><strong>Note</strong>: I’m glad I used NixOS here because a custom development build of a piece of software has the potential to be <em>very</em> different from an officially-released version. By changing the Caddy revision alone in my nix flake’s <code>nixpkgs</code> upstream, I’m getting both the identical set of system dependencies and same build process save for the project source revision.</p>

<figure>

</figure>

<table>
  <thead>
    <tr>
      <th>test</th>
      <th>min</th>
      <th>median</th>
      <th>average</th>
      <th>p90</th>
      <th>p95</th>
      <th>max</th>
      <th>requests</th>
      <th>errors</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>caddy-default-synthetic-default</td>
      <td>0.22</td>
      <td>13.57</td>
      <td>16.40</td>
      <td>26.06</td>
      <td>42.36</td>
      <td>140.70</td>
      <td>811764</td>
      <td>0.00</td>
    </tr>
    <tr>
      <td>caddy-default-synthetic-sendfile</td>
      <td>0.15</td>
      <td>13.28</td>
      <td>15.92</td>
      <td>25.23</td>
      <td>39.96</td>
      <td>135.94</td>
      <td>839971</td>
      <td>0.00</td>
    </tr>
    <tr>
      <td>caddy-default-html-large-default</td>
      <td>1.24</td>
      <td>51.16</td>
      <td>118.28</td>
      <td>276.32</td>
      <td>436.14</td>
      <td>26849.83</td>
      <td>127016</td>
      <td>0.00</td>
    </tr>
    <tr>
      <td>caddy-default-html-large-sendfile</td>
      <td>0.89</td>
      <td>50.20</td>
      <td>118.53</td>
      <td>276.54</td>
      <td>444.56</td>
      <td>26790.26</td>
      <td>127028</td>
      <td>0.00</td>
    </tr>
    <tr>
      <td>caddy-default-html-small-default</td>
      <td>0.27</td>
      <td>14.20</td>
      <td>17.21</td>
      <td>27.44</td>
      <td>44.67</td>
      <td>225.08</td>
      <td>803503</td>
      <td>0.00</td>
    </tr>
    <tr>
      <td>caddy-default-html-small-sendfile</td>
      <td>0.17</td>
      <td>14.41</td>
      <td>17.71</td>
      <td>29.28</td>
      <td>48.48</td>
      <td>155.22</td>
      <td>818401</td>
      <td>0.00</td>
    </tr>
    <tr>
      <td>caddy-default-proxy-default</td>
      <td>0.40</td>
      <td>39.62</td>
      <td>42.51</td>
      <td>68.43</td>
      <td>81.30</td>
      <td>284.87</td>
      <td>351182</td>
      <td>0.00</td>
    </tr>
    <tr>
      <td>caddy-default-proxy-sendfile</td>
      <td>0.33</td>
      <td>42.53</td>
      <td>44.83</td>
      <td>70.98</td>
      <td>82.68</td>
      <td>294.01</td>
      <td>333394</td>
      <td>0.00</td>
    </tr>
  </tbody>
</table>

<p>At a glance this appears to show that:</p>
<ul>
  <li><code>sendfile</code> brings marked improvements for synthetic tests and small HTML responses (better latency and count for synthetic, a smidge less good latency for small HTML but many more requests made it across).</li>
  <li>For large HTML responses, things seem to be about the same.</li>
  <li>For proxied requests, results are slightly <em>worse</em>. I’m not sure why! Latency is only slightly less good, but overall request count is certainly lower.</li>
</ul>

<p>At the very least this implies that the patch is probably a good thing overall. If I were a handsomely-paid consultant for Caddy, I’d suggest focusing any performance engineering on the <code>reverse_proxy</code> code path, since that regression here is paired with generally less-than-expected performance with or without the <code>sendfile</code> patch.</p>













        </section>
    </div></div>
  </body>
</html>
