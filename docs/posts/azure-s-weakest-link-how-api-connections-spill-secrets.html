<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://binarysecurity.no/posts/2025/03/api-connections">Original</a>
    <h1>Azure&#39;s Weakest Link? How API Connections Spill Secrets</h1>
    
    <div id="readability-page-1" class="page"><article>
           <p>Binary Security found the undocumented APIs for Azure API Connections. In this post we examine the inner workings of the Connections allowing us to escalate privileges and read secrets in backend resources for services ranging from Key Vaults, Storage Blobs, Defender ATP, to Enterprise Jira and SalesForce servers.
</p>
<h2 id="background">Background</h2>
<p>During a client engagement, I was checking out their Azure Resources looking for common vulnerabilities. They were utilizing a Logic App to post some messages to Slack. Usually, we can find some tokens or other sensitive information in the workflow run history of these apps, as it is common to not mark input (and output) as sensitive. I could not find anything of the sort in this case, so I moved on from the investigation. However, by chance I saw an odd response from a request automatically made from the portal when going into the API Connection resource. It was something like:</p>
<div><div><pre><code><span>GET</span> <span>/subscriptions/8e3ce52f-d45b-4347-8705-65892507465e/resourceGroups/Logic-app-tests/providers/Microsoft.Web/connections/slack?api-version=2018-07-01-preview</span> <span>HTTP</span><span>/</span><span>2</span>
<span>Host</span><span>:</span> <span>management.azure.com</span>
<span>Authorization</span><span>:</span> <span>Bearer &lt;Token&gt;</span>


HTTP/2 200 OK
Content-Length: 1893
Content-Type: application/json; charset=utf-8


{
    &#34;kind&#34;: &#34;V2&#34;,
    &#34;properties&#34;: {
        &#34;displayName&#34;: &#34;Slack&#34;,
        &#34;authenticatedUser&#34;: {},
        &#34;overallStatus&#34;: &#34;Connected&#34;,
        &#34;statuses&#34;:[
            {
                &#34;status&#34;:&#34;Connected&#34;
            }
        ],
        &#34;connectionState&#34;: &#34;Enabled&#34;,
        &#34;parameterValueSet&#34;:{
            &#34;name&#34;:&#34;oauth&#34;,
            &#34;values&#34;:{}
        },
        &#34;customParameterValues&#34;: {},
        &#34;createdTime&#34;: &#34;2025-01-24T11:46:25.0499291Z&#34;,
        &#34;changedTime&#34;: &#34;2025-01-24T11:46:25.0499291Z&#34;,
        &#34;api&#34;: {
            &#34;name&#34;: &#34;slack&#34;,
            &#34;displayName&#34;: &#34;Slack&#34;,
            &#34;description&#34;: &#34;Slack is a team communication tool, that brings together all of your team communications in one place, instantly searchable and available wherever you go.&#34;,
            &#34;iconUri&#34;: &#34;https://conn-afd-prod-endpoint-bmc9bqahasf3grgk.b01.azurefd.net/u/v-anadhar/UpdateSlackForPlugin/1.0.1715.3917/slack/icon.png&#34;,
            &#34;brandColor&#34;: &#34;#78D4B6&#34;,
            &#34;category&#34;: &#34;Standard&#34;,
            &#34;id&#34;: &#34;/subscriptions/8e3ce52f-d45b-4347-8705-65892507465e/providers/Microsoft.Web/locations/norwayeast/managedApis/slack&#34;,
            &#34;type&#34;: &#34;Microsoft.Web/locations/managedApis&#34;
        },
        &#34;testLinks&#34;: [
            {
                &#34;requestUri&#34;: &#34;https://management.azure.com:443/subscriptions/8e3ce52f-d45b-4347-8705-65892507465e/resourceGroups/Logic-app-tests/providers/Microsoft.Web/connections/slack/extensions/proxy/conversations.list?api-version=2018-07-01-preview&#34;,
                &#34;method&#34;: &#34;get&#34;
            }
        ],
        &#34;testRequests&#34;: [
            {
                &#34;body&#34;: {
                    &#34;request&#34;: {
                        &#34;method&#34;: &#34;get&#34;,
                        &#34;path&#34;: &#34;conversations.list&#34;
                    }
                },
                &#34;requestUri&#34;: &#34;https://management.azure.com:443/subscriptions/8e3ce52f-d45b-4347-8705-65892507465e/resourceGroups/Logic-app-tests/providers/Microsoft.Web/connections/slack/dynamicInvoke?api-version=2018-07-01-preview&#34;,
                &#34;method&#34;: &#34;POST&#34;
            }
        ],
        &#34;connectionRuntimeUrl&#34;: &#34;https://d84b73b612cf5960.16.common.logic-norwayeast.azure-apihub.net/apim/slack/4355f64966c34c0cbfc15d48ec41e0c3&#34;
    },
    &#34;id&#34;: &#34;/subscriptions/8e3ce52f-d45b-4347-8705-65892507465e/resourceGroups/Logic-app-tests/providers/Microsoft.Web/connections/slack&#34;,
    &#34;name&#34;: &#34;slack&#34;,
    &#34;type&#34;: &#34;Microsoft.Web/connections&#34;,
    &#34;location&#34;: &#34;norwayeast&#34;
}

</code></pre></div></div>
<p>Now, this might seem uninteresting at first glance, but there are two key fields in this response that really opened up a whole slew of possibilities.</p>
<h2 id="the-inherent-insecurity-of-api-connections">The Inherent Insecurity of API Connections</h2>
<p>Consider the <code>testLinks</code> and <code>testRequests</code> fields of the above response. It seems that they provide a sort of proxy between the Azure Management API and the actual backend server, most clearly seen by the <code>extensions/proxy</code> path. We can also see that the connection perhaps is authenticated in some way, by the <code>OAuth</code> value in the <code>parameterValueSet</code>. Now, naively, I would think that this means that some user, probably whoever set this up, is authenticated to this connection, and we would need his token to call through the connection, or maybe do an <code>OAuth</code> dance ourselves.</p>
<p>What I would <strong>not</strong> expect is that anyone with Reader permissions on the connection is allowed to arbitrarily call any endpoint on the connection:</p>
<div><div><pre><code><span>
</span><span>GET</span> <span>/subscriptions/8e3ce52f-d45b-4347-8705-65892507465e/resourceGroups/logic-app-tests/providers/Microsoft.Web/connections/jira/extensions/proxy/conversations.list</span> <span>HTTP</span><span>/</span><span>2</span>
<span>Host</span><span>:</span> <span>management.azure.com</span>
<span>Authorization</span><span>:</span> <span>Bearer &lt;Token&gt;</span>


HTTP/2 200 OK
Content-Type: application/json
Content-Length: 18329

&#34;ok&#34;: true,
&#34;channels&#34;: [
    {
        &#34;id&#34;: &#34;C08B8RB5D39&#34;,
        &#34;name&#34;: &#34;social&#34;,
        &#34;is_channel&#34;: true,
        &#34;is_group&#34;: false,
        &#34;is_im&#34;: false,
        &#34;is_mpim&#34;: false,
        &#34;is_private&#34;: false,
        &#34;created&#34;: 1738674777,
        &#34;is_archived&#34;: false,
        &#34;is_general&#34;: false,
        &#34;unlinked&#34;: 0,
        &#34;name_normalized&#34;: &#34;social&#34;,
        &#34;is_shared&#34;: false,
        &#34;is_org_shared&#34;: false,
        &#34;is_pending_ext_shared&#34;: false,
        &#34;pending_shared&#34;: [],
        &#34;context_team_id&#34;: &#34;T08BPBEC890&#34;,
        &#34;updated&#34;: 1738674779593,
        &#34;parent_conversation&#34;: null,
        &#34;creator&#34;: &#34;U08C22K3HPT&#34;,
        &#34;is_ext_shared&#34;: false,
        &#34;shared_team_ids&#34;: [
            &#34;T08BPBEC890&#34;
        ],
        &#34;pending_connected_team_ids&#34;: [],
        &#34;is_member&#34;: true,
&lt;...&gt;

</code></pre></div></div>
<p>The response is actually exactly the same as a direct query on the Slack API endpoint <a href="https://api.slack.com/methods/conversations.list">conversations.list</a></p>
<p>While the Slack case is perhaps not the most security critical, this result begs the question: Does this work for all the other types of APIs exposed through this interface?</p>
<p>The answer is yes. If you have created an API Connection to any backend server, this includes other Azure resources, all Readers on that subscription can call all <code>GET</code> requests defined on the connection. Specifically, this includes Key Vaults, SQL Databases, Jira-servers, Defender ATP, etc.</p>
<h2 id="azure-management-arm-apis-security-model">Azure Management (ARM) API’s Security Model</h2>
<p>Before I show how to exploit this properly, some background on the Azure Management API is required. While we cannot know for sure how the developers at Microsoft designed the system, it seems clear to me that initially, the security model of the management API considered that Readers should be allowed to perform <code>GET</code> requests. You would have to be <code>Contributor</code> or higher to perform any changes, i.e. using any of the <code>POST</code>, <code>PUT</code>, <code>DELETE</code>, etc methods.</p>
<p>This can be seen by for instance requiring a number of sensitive endpoints for <code>App Services</code> to be empty <code>POST</code> requests, like <a href="https://learn.microsoft.com/en-us/rest/api/appservice/web-apps/list-host-keys">List Host Keys</a>.</p>
<p>At Binary Security we have reported a number of vulnerabilities relating to the leaking of sensitive information through insecure <code>GET</code> endpoints. The result of this is that the security model has been somewhat changed in recent times, and it is now not obvious if a Reader is allowed to call a <code>GET</code> endpoint. This is, however, still a viable attack method, and reading the documentation is still a goldmine for exploitable bugs.</p>
<p>Getting back to the API Connections, it should be clear that the Management’s <code>/extensions/proxy/{action}</code> endpoints will allow all Readers to call the defined <code>GET</code> requests. And while this is not seen as a problem in the ARM world, there is of course no guarantee that the connected API adheres to this security model.</p>
<h2 id="creating-an-api-connection">Creating an API Connection</h2>
<p>API Connections are resources in the Azure world, just like Key Vaults, SQL Databases or VMs, but they are not required to be explicitly created. They are automatically created for you when setting up Actions in a Logic App, so even if you have never heard of them before, it is quite possible that there are a lot of them hanging out in your tenant. For instance, creating a connection to your Key Vault is as easy as going to the Logic App Designer view, finding the Key Vaults actions, setting some initial values and authenticating.
<img src="https://binarysecurity.no/assets/images/posts/createkeyvault-connection.png" alt="Sign in to create the connection"/></p>
<p>This of course requires that the person setting it up, and authenticating to the Key Vault has appropriate access to the Key Vault. After signing in, it is not required to even save the Workflow, the resource is still created, and will need to be explicitly deleted if it is not needed any more.</p>
<p>The flows for internal Azure Resources are all similar, where you can choose between different authentication types. For external resources, the setup varies, but in all cases, some authentication information is saved within the API Connection in some way, and this is used when querying the API.</p>
<p>This means that the authentication used on the backend API call is always the same, and does not depend on the user or principal calling the ARM API. Crucially, the backend cannot know whether the call comes from the Logic App or from the proxy endpoint, called by any Reader on the resource.</p>
<h2 id="the-api-connection-api">The API Connection API</h2>
<p>The full list of API Connections (Connectors) can be seen <a href="https://learn.microsoft.com/en-us/connectors/connector-reference/">here</a>. The proxy endpoints are not explicitly listed, but they can either be deduced from the API of the connected service, or by querying the <code>managedAPIs</code> endpoint for that specific Connector, which exposes a Swagger definition of the API. Here we query it for the definition of the Jira Connector:</p>
<div><div><pre><code><span>GET</span> <span>/subscriptions/8e3ce52f-d45b-4347-8705-65892507465e/providers/microsoft.web/locations/norwaywest/managedapis/jira?api-version=2018-07-01-preview&amp;export=true</span> <span>HTTP</span><span>/</span><span>2</span>
<span>Host</span><span>:</span> <span>management.azure.com</span>
<span>Authorization</span><span>:</span> <span>Bearer &lt;Token&gt;</span>

HTTP/2 200 OK
&lt;...&gt;

{
    &#34;/{connectionId}/3/issue/{issueIdOrKey}&#34;: {
        &#34;put&#34;: {
            &#34;description&#34;: &#34;Edits an issue. A transition may be applied and issue properties updated as part of the edit. The edits to the issue&#39;s fields are defined using update and fields.&#34;,
            &#34;summary&#34;: &#34;Edit Issue&#34;,
            &#34;tags&#34;: [
                &#34;Issues&#34;
            ],
            &#34;operationId&#34;: &#34;EditIssue&#34;,
            &#34;deprecated&#34;: false,
            &#34;produces&#34;: [
                &#34;application/json&#34;
            ],
            &#34;consumes&#34;: [
                &#34;application/json&#34;
            ],
            &#34;parameters&#34;: [
                {
                    &#34;name&#34;: &#34;connectionId&#34;,
                    &#34;in&#34;: &#34;path&#34;,
                    &#34;required&#34;: true,
                    &#34;type&#34;: &#34;string&#34;,
                    &#34;x-ms-visibility&#34;: &#34;internal&#34;
                },
                {
                    &#34;name&#34;: &#34;issueIdOrKey&#34;,
                    &#34;in&#34;: &#34;path&#34;,
                    &#34;required&#34;: true,
                    &#34;type&#34;: &#34;string&#34;,
                    &#34;x-ms-summary&#34;: &#34;Issue ID or Key&#34;,
                    &#34;description&#34;: &#34;Provide the Issue ID or Key for the issue you wish to edit&#34;,
                    &#34;x-ms-url-encoding&#34;: &#34;single&#34;
                },
&lt;...&gt;

</code></pre></div></div>
<p>The <code>{connectionId}</code> in this case is the full path to the <code>proxy</code> endpoint, something like <code>/subscription/[SUBSCRIPTION_ID]/resourceGroups/[RESOURCE_GROUP]/providers/Microsoft.Web/connections/[CONNECTION_NAME]/extensions/proxy/</code>.</p>
<p>Armed with this knowledge, we can go searching for sensitive endpoints.</p>
<h3 id="azure-key-vaults">Azure Key Vaults</h3>
<p>The Connector for Key Vaults is maybe the one with the highest impact. The Swagger definition includes these sensitive <code>GET</code> endpoints</p>
<ul>
 <li><code>/{connectionId}/secrets</code> for listing secrets</li>
 <li><code>/{connectionId}/secrets/{secretName}/value</code> to retrieve the value of the secret</li>
</ul>
<p><img src="https://binarysecurity.no/assets/images/posts/keyvault_value.png" alt="Leaking Secrets through the connection"/></p>
<h3 id="sql-databases">SQL Databases</h3>
<p>The SQL Connector is quite similar to the Key Vault, you are basically free to read whatever you want:</p>
<ul>
 <li>
   <p><code>/{connectionId}/databases</code> -  List Databases</p>
 </li>
 <li>
   <p><code>/{connectionId}/datasets</code> - List Datasets</p>
 </li>
 <li>
   <p><code>/{connectionId}/datasets({dataset})/tables({table})/items</code> - Get rows from a table</p>
 </li>
</ul>
<p><img src="https://binarysecurity.no/assets/images/posts/get-data-from-sql.png" alt="Reading the rows of the database"/></p>
<p>There is also a hilarious error message here, when trying to do some path traversing in the dataset name. It did not seem to be exploitable in any way, but I bet you have never seen a stacktrace exposed in an HTTP status message:</p>
<p><img src="https://binarysecurity.no/assets/images/posts/api-connectors-sql-error-in-status-line.png" alt="Path traversal leads to stacktrace in HTTP status message"/></p>
<h2 id="jira">Jira</h2>
<p>The Jira Connector also exposes effectively everything on your Jira instance:</p>
<ul>
 <li>
   <p><code>/{connectionId}/v2/project/search</code> - List projects</p>
 </li>
 <li>
   <p><code>/{connectionId}/user/permission/search</code> - List users</p>
 </li>
 <li>
   <p><code>/{connectionId}/2/search</code> - List issues</p>
 </li>
 <li>
   <p><code>/{connectionId}/issue/{issueKey}</code> - Read an issue</p>
 </li>
</ul>
<p>This connector is also interesting because it, of course, must be connected to your Jira instance somewhere else on the Internet. When setting up the connection, the developer gives the connection the URL of the Jira Instance. Incredibly, this is ignored in all subsequent requests, and instead, a special <code>X-Request-Jirainstance</code> header must be included in the request. This should point to your Jira instance, but there is no verification, so an attacker is free to SSRF at will. By setting this to an attacker-controlled server, the attacker will receive the API token used by the connection. This effectively also bypasses the restriction on the requests, and allows the attacker to query any endpoint with any method.</p>
<p><img src="https://binarysecurity.no/assets/images/posts/send-request-to-collaborator.png" alt="The special header will force the server to make a request to an attacker-controlled site"/></p>
<p><img src="https://binarysecurity.no/assets/images/posts/collaborator-receives-token.png" alt="The attacker receives the request, with the token in the `Authorization` header"/></p>
<p>Note that this attack is only possible when using the <code>APIToken</code> authentication mechanism. When using <code>OAuth</code>, a GUID is used to identify your Jira Instance.</p>
<h2 id="the-rest">The Rest</h2>
<p>All API Connections must be considered insecure as long as Readers can call the backend server. In nearly all cases I have seen, the connection exposes all information on the backend service. In addition to the ones above, this includes:</p>
<ul>
 <li>Salesforce</li>
 <li>Azure Storage Blobs</li>
 <li>Azure Defender ATP</li>
 <li>Google Mail, Contacts, Calendars</li>
</ul>
<p>and probably much more.</p>
<h2 id="future-work">Future work</h2>
<p>I think there is significant undiscovered potential in these connections. Without going into detail, I can tell you that API Connections have a significant amount of architecture hidden between the Management Server and the backend API. All calls go from ARM to a <em>global</em> APIM instance containing every tenant’s API Connection, utilizing a <a href="https://github.com/Azure/azure-tokens">Token Store</a>. The initial authentication setup likewise goes through a <em>global</em> Consent server for storing tokens. If this hidden infrastructure is compromised, there will be significant cross-tenant impact as well.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Hopefully by now, you have realized the impact of a lacking security model. While these endpoints are undocumented, that only makes them harder to find, not exploit. I am confident that any security researcher who had found them would immediately have noticed the glaring security hole it puts in their tenant. Hopefully, this post will allow others to discover more insecurities in Azure, so that we can be more secure in the future.</p>
<h2 id="microsoft-response">Microsoft response:</h2>
<ul>
 <li>Jan 6: Report submitted to Microsoft, both a general for API Connections and one specifically for Jira.</li>
 <li>Jan 7: API Connection case is closed by Microsoft as not valid, I submit it again with more words.</li>
 <li>Jan 10: Microsoft confirms the API Connection vulnerability</li>
 <li>Jan 12-17: Microsoft fixes the API Connection vulnerability by not allowing any requests through <code>/extensions/proxy</code> except for <code>testrequests</code>.</li>
 <li>Jan 30: Microsoft replies on the Jira ticket, saying they cannot reproduce it, which should be obvious, since now it is fixed.</li>
 <li>Feb 12: Jira Ticket is closed</li>
 <li>Feb 13: Microsoft replies to the API Connection case, saying it has been fixed.</li>
 <li>Feb 20: The case is closed as a duplicate.</li>
</ul>
       </article></div>
  </body>
</html>
