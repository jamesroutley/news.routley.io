<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://nitric.io/blog/terraform-comparison-demo">Original</a>
    <h1>Speeding up Azure development by not using Terraform</h1>
    
    <div id="readability-page-1" class="page"><article><div><p>We recently built a basic e-commerce site to demonstrate how to deploy to Microsoft Azure. We compared what the process looked like using Nitric vs. Terraform for the infrastructure.</p><p>The video below shows how we built and deployed the application. Here, we&#39;ll walk through the specifics of the infrastructure and application code when building with Nitric and then with Terraform.</p><p><iframe src="https://www.youtube-nocookie.com/embed/_n8S0IYxmSM?si=soCg6ur6HPyWIG4I" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"></iframe></p><p>The application code is kept relatively simple as we are mainly focused on the infrastructure code differences. This project will have two services, one for handling user submitted orders, and one for generating invoices for those orders. There will be a topic which binds these two services together and a bucket which will store the generated orders.</p><p>To get this running in Azure we will need to create the following resources:</p><ul><li>Resource Group - for logical grouping</li><li>2 Container Apps</li><li>Container Registry - to store the container images</li><li>Container App Environment - to run the container apps</li><li>EventGrid Topic</li><li>EventGrid Subscription</li><li>Storage Account - to configure the storage container</li><li>Storage Container</li><li>IAM rules - to implement least-privilege</li></ul><p><img src="https://nitric.io/images/blog/terraform-comparison-demo/azure-example.svg" width="1000px" alt="Diagram describing the architecture of the application"/></p><p>For an application built using traditional Infrastructure as Code (IaC) tooling like Terraform, each of these resources needs to be individually defined, configured, and bound to the application code. Using a more Infastructure <em>from</em> Code approach like Nitric, the resources are defined in your application code. We will first take a look at writing and deploying this application with Nitric, and then compare this with the same application written in HCL.</p><h2 id="building-with-nitric">Building with Nitric</h2><p>To start, ensure you have the <a href="https://nitric.io/docs/installation" target="_blank" rel="noreferrer">Nitric CLI</a> installed. We can then create our Nitric project using the following command.</p><pre><code><span>nitric new bookstore </span><span>&#34;official/TypeScript - Starter&#34;</span>
</code></pre><p>Then open the project in your preferred Typescript editor. We&#39;ll start by deleting the files in the functions folder, replacing them with two new files named <code>order.ts</code> and <code>invoices.ts</code>. Open up <code>order.ts</code> and we will add the following code.</p><pre><code><span>import</span><span> </span><span>{</span><span> api</span><span>,</span><span> topic </span><span>}</span><span> </span><span>from</span><span> </span><span>&#39;@nitric/sdk&#39;</span><span></span>
<!-- -->
<span></span><span>const</span><span> ordersApi </span><span>=</span><span> </span><span>api</span><span>(</span><span>&#39;orders&#39;</span><span>)</span><span></span>
<span></span><span>const</span><span> ordersTopic </span><span>=</span><span> </span><span>topic</span><span>(</span><span>&#39;order-updates&#39;</span><span>)</span><span>.</span><span>for</span><span>(</span><span>&#39;publishing&#39;</span><span>)</span>
</code></pre><p>This code imports api and topic resources from the Nitric typescript SDK and creates two new resources. The api is called <code>orders</code> and the topic is called <code>order-updates</code>. We will give our function permissions to publish events using our topic by specifying <code>.for(&#39;publishing&#39;)</code>. The next step is adding a route to our API so that we can publish orders. This will be a POST route on <code>/order</code> which will take the request payload and publish that to the orders topic. It will return 200 with the order and a confirmation that the order was received.</p><pre><code><span>ordersApi</span><span>.</span><span>post</span><span>(</span><span>&#39;/order&#39;</span><span>,</span><span> </span><span>async</span><span> </span><span>(</span><span>ctx</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span></span>
<span>  </span><span>const</span><span> order </span><span>=</span><span> ctx</span><span>.</span><span>req</span><span>.</span><span>json</span><span>(</span><span>)</span><span></span>
<span>  </span><span>await</span><span> ordersTopic</span><span>.</span><span>publish</span><span>(</span><span>order</span><span>)</span><span></span>
<!-- -->
<span>  </span><span>return</span><span> ctx</span><span>.</span><span>res</span><span>.</span><span>json</span><span>(</span><span>{</span><span></span>
<span>    message</span><span>:</span><span> </span><span>&#39;Order received&#39;</span><span>,</span><span></span>
<span>    order</span><span>,</span><span></span>
<span>  </span><span>}</span><span>)</span><span></span>
<span></span><span>}</span><span>)</span>
</code></pre><p>The next step is to create the handler for our order notifications. This handler uses an external API to generate a PDF with the invoice for the order. The code was extracted from the comparison application code for both the Nitric and Terraform applications. This was done to not overcomplicate the comparison. The source code for the API is available <a href="https://github.com/nitrictech/bookstore-demo/tree/main/shipping-labels" target="_blank" rel="noreferrer">here</a>. We&#39;ll start by getting the environment variables required to access this API.</p><pre><code><span>const</span><span> </span><span>INVOICE_API_URL</span><span> </span><span>=</span><span> process</span><span>.</span><span>env</span><span>.</span><span>INVOICE_API_URL</span><span></span>
<span></span><span>const</span><span> </span><span>INVOICE_API_KEY</span><span> </span><span>=</span><span> process</span><span>.</span><span>env</span><span>.</span><span>INVOICE_API_KEY</span>
</code></pre><p>Next, we will create the invoices bucket and create a subscription for the <code>order-updates</code> topic.</p><pre><code><span>import</span><span> </span><span>{</span><span> topic</span><span>,</span><span> bucket </span><span>}</span><span> </span><span>from</span><span> </span><span>&#39;@nitric/sdk&#39;</span><span></span>
<!-- -->
<span></span><span>...</span><span></span>
<!-- -->
<span></span><span>const</span><span> invoiceBucket </span><span>=</span><span> </span><span>bucket</span><span>(</span><span>&#39;invoices&#39;</span><span>)</span><span>.</span><span>for</span><span>(</span><span>&#39;writing&#39;</span><span>)</span><span></span>
<!-- -->
<span></span><span>topic</span><span>(</span><span>&#39;order-updates&#39;</span><span>)</span><span>.</span><span>subscribe</span><span>(</span><span>async</span><span> </span><span>(</span><span>ctx</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span>}</span><span>)</span>
</code></pre><p>We can then start adding our handler code for the subscription. This will first extract the payload from the request and forward this request to the invoice creation API.</p><pre><code><span>topic</span><span>(</span><span>&#39;order-updates&#39;</span><span>)</span><span>.</span><span>subscribe</span><span>(</span><span>async</span><span> </span><span>(</span><span>ctx</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span></span>
<span>  </span><span></span>
<span>  </span><span>const</span><span> </span><span>{</span><span> payload</span><span>:</span><span> order </span><span>}</span><span> </span><span>=</span><span> ctx</span><span>.</span><span>req</span><span>.</span><span>json</span><span>(</span><span>)</span><span></span>
<!-- -->
<span>  </span><span></span>
<span>  </span><span>const</span><span> response </span><span>=</span><span> </span><span>await</span><span> </span><span>fetch</span><span>(</span><span>`</span><span>${</span><span>INVOICE_API_URL</span><span>}</span><span>/invoices</span><span>`</span><span>,</span><span> </span><span>{</span><span></span>
<span>    method</span><span>:</span><span> </span><span>&#39;POST&#39;</span><span>,</span><span></span>
<span>    headers</span><span>:</span><span> </span><span>{</span><span></span>
<span>      </span><span>&#39;x-api-key&#39;</span><span>:</span><span> </span><span>INVOICE_API_KEY</span><span>,</span><span></span>
<span>    </span><span>}</span><span>,</span><span></span>
<span>    body</span><span>:</span><span> </span><span>JSON</span><span>.</span><span>stringify</span><span>(</span><span>order</span><span>)</span><span>,</span><span></span>
<span>  </span><span>}</span><span>)</span><span></span>
<span></span><span>}</span><span>)</span>
</code></pre><p>Once we have the PDF returned from the response we can add it to the bucket.</p><pre><code><span>topic</span><span>(</span><span>&#39;order-updates&#39;</span><span>)</span><span>.</span><span>subscribe</span><span>(</span><span>async</span><span> </span><span>(</span><span>ctx</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span></span>
<span>  </span><span>...</span><span></span>
<!-- -->
<span>  </span><span></span>
<span>  </span><span>if</span><span> </span><span>(</span><span>!</span><span>response</span><span>.</span><span>ok</span><span>)</span><span> </span><span>{</span><span></span>
<span>    </span><span>console</span><span>.</span><span>log</span><span>(</span><span></span>
<span>      </span><span>`</span><span>Failed to generate invoice for order </span><span>${</span><span>order</span><span>.</span><span>orderNumber</span><span>}</span><span>, status code </span><span>${</span><span></span>
<span>        response</span><span>.</span><span>status</span>
<span>      </span><span>}</span><span>, </span><span>${</span><span>await</span><span> response</span><span>.</span><span>text</span><span>(</span><span>)</span><span>}</span><span>`</span><span></span>
<span>    </span><span>)</span><span></span>
<span>    </span><span>throw</span><span> </span><span>new</span><span> </span><span>Error</span><span>(</span><span>`</span><span>Failed to generate invoice for order </span><span>${</span><span>order</span><span>.</span><span>orderNumber</span><span>}</span><span>`</span><span>)</span><span></span>
<span>  </span><span>}</span><span></span>
<!-- -->
<span>  </span><span></span>
<span>  </span><span>const</span><span> invoicePdf </span><span>=</span><span> </span><span>await</span><span> response</span><span>.</span><span>arrayBuffer</span><span>(</span><span>)</span><span></span>
<!-- -->
<span>  </span><span></span>
<span>  </span><span>await</span><span> invoiceBucket</span>
<span>    </span><span>.</span><span>file</span><span>(</span><span>`</span><span>${</span><span>order</span><span>.</span><span>orderNumber</span><span>}</span><span>.pdf</span><span>`</span><span>)</span><span></span>
<span>    </span><span>.</span><span>write</span><span>(</span><span>new</span><span> </span><span>Uint8Array</span><span>(</span><span>invoicePdf</span><span>)</span><span>)</span><span></span>
<span></span><span>}</span><span>)</span>
</code></pre><p>Now that both the services are done, we can deploy the application to the cloud. Before doing this, we must create a stack environment to describe our deployment. Run the following command and follow the prompts.</p><pre><code><span>nitric stack new</span>
</code></pre><blockquote><p>The invoice PDF API must be deployed separately for access by your application code</p></blockquote><p>We can then deploy to the cloud.</p><pre><code><span>nitric up</span>
</code></pre><p>Once deployed we can use the following cURL request to create an order. You will need to update the URL in the request to match the outputted URL from the deployment.</p><pre><code><span>curl  -X POST \</span>
<span>  &#39;https</span><span>:</span><span></span>
<span>  --header &#39;Content-Type</span><span>:</span><span> application/json&#39; \</span>
<span>  --data-raw &#39;</span><span>{</span><span></span>
<span>  </span><span>&#34;customer&#34;</span><span>:</span><span> </span><span>&#34;John Doe&#34;</span><span>,</span><span></span>
<span>  </span><span>&#34;shippingAddress&#34;</span><span>:</span><span> </span><span>{</span><span></span>
<span>    </span><span>&#34;line1&#34;</span><span>:</span><span> </span><span>&#34;123 Fake St&#34;</span><span>,</span><span></span>
<span>    </span><span>&#34;city&#34;</span><span>:</span><span> </span><span>&#34;San Francisco&#34;</span><span>,</span><span></span>
<span>    </span><span>&#34;state&#34;</span><span>:</span><span> </span><span>&#34;CA&#34;</span><span>,</span><span></span>
<span>    </span><span>&#34;postalCode&#34;</span><span>:</span><span> </span><span>&#34;94105&#34;</span><span></span>
<span>  </span><span>}</span><span>,</span><span></span>
<span>  </span><span>&#34;orderNumber&#34;</span><span>:</span><span> </span><span>&#34;250-6880554-12345&#34;</span><span>,</span><span></span>
<span>  </span><span>&#34;items&#34;</span><span>:</span><span> </span><span>[</span><span></span>
<span>    </span><span>{</span><span></span>
<span>      </span><span>&#34;name&#34;</span><span>:</span><span> </span><span>&#34;Widget&#34;</span><span>,</span><span></span>
<span>      </span><span>&#34;quantity&#34;</span><span>:</span><span> </span><span>1</span><span>,</span><span></span>
<span>      </span><span>&#34;unitPrice&#34;</span><span>:</span><span> </span><span>100</span><span></span>
<span>    </span><span>}</span><span>,</span><span></span>
<span>    </span><span>{</span><span></span>
<span>      </span><span>&#34;name&#34;</span><span>:</span><span> </span><span>&#34;Gadget&#34;</span><span>,</span><span></span>
<span>      </span><span>&#34;quantity&#34;</span><span>:</span><span> </span><span>2</span><span>,</span><span></span>
<span>      </span><span>&#34;unitPrice&#34;</span><span>:</span><span> </span><span>50</span><span></span>
<span>    </span><span>}</span><span></span>
<span>  </span><span>]</span><span></span>
<span></span><span>}</span><span>&#39;</span>
</code></pre><p>To verify that it worked as expected, you can view the bucket in your cloud console and see if there is a new invoice PDF called <code>250-6880554-12345.pdf</code> or similar.</p><h2 id="building-with-terraform">Building with Terraform</h2><p>With the Nitric version done, we can now look at how to create the same solution using Terraform. This approach separates the infrastructure and application code, so we first write the infrastructure definitions in HCL and then write our application code using Express.</p><h3 id="infrastructure-definitions">Infrastructure Definitions</h3><p>Before writing any application code, we must first define the following 11 resources. This section assumes that you have a basic understanding of how <a href="https://developer.hashicorp.com/terraform/language/modules/develop" target="_blank" rel="noreferrer">Terraform modules</a> work.</p><ul><li>Resource Group</li><li>2 Container Apps</li><li>Container Registry</li><li>Container App Environment</li><li>EventGrid Topic</li><li>EventGrid Subscription</li><li>Storage Account</li><li>Storage Container</li><li>2 IAM rules</li></ul><p>We&#39;ll start by defining our Azure providers, <code>azurerm</code> and <code>azuread</code></p><blockquote><p>You&#39;ll notice that most the defined resources require input variables. We will define them in <code>variables.tf</code> later.</p></blockquote><pre><code><span>terraform</span><span> </span><span>{</span><span></span>
<span>  </span><span>required_providers</span><span> </span><span>{</span><span></span>
<span>    </span><span>azurerm</span><span> </span><span>=</span><span> </span><span>{</span><span></span>
<span>      </span><span>source</span><span>  </span><span>=</span><span> </span><span>&#34;hashicorp/azurerm&#34;</span><span></span>
<span>      </span><span>version</span><span> </span><span>=</span><span> </span><span>&#34;= 3.84.0&#34;</span><span></span>
<span>    </span><span>}</span><span></span>
<span>    </span><span>azuread</span><span> </span><span>=</span><span> </span><span>{</span><span></span>
<span>      </span><span>source</span><span>  </span><span>=</span><span> </span><span>&#34;hashicorp/azuread&#34;</span><span></span>
<span>      </span><span>version</span><span> </span><span>=</span><span> </span><span>&#34;= 2.46.0&#34;</span><span></span>
<span>    </span><span>}</span><span></span>
<span>  </span><span>}</span><span></span>
<span></span><span>}</span><span></span>
<!-- -->
<span></span><span></span>
<span></span><span>provider</span><span> &#34;azurerm&#34; </span><span>{</span><span></span>
<span>  </span><span>client_id</span><span>       </span><span>=</span><span> var.ARM_CLIENT_ID</span>
<span>  </span><span>client_secret</span><span>   </span><span>=</span><span> var.ARM_CLIENT_SECRET</span>
<span>  </span><span>subscription_id</span><span> </span><span>=</span><span> var.ARM_SUBSCRIPTION_ID</span>
<span>  </span><span>tenant_id</span><span>       </span><span>=</span><span> var.ARM_TENANT_ID</span>
<span>  </span><span>features</span><span> </span><span>{</span><span>}</span><span></span>
<span></span><span>}</span><span></span>
<!-- -->
<span></span><span></span>
<span></span><span>provider</span><span> &#34;azuread&#34; </span><span>{</span><span>}</span>
</code></pre><p>Next, create your <a href="https://registry.terraform.io/providers/hashicorp/azurerm/latest/docs/resources/resource_group" target="_blank" rel="noreferrer">resource group</a> to logically bind all the created resources together.</p><pre><code><span></span>
<span></span><span>resource </span><span>&#34;azurerm_resource_group&#34;</span><span> </span><span>&#34;example&#34;</span><span> </span><span>{</span><span></span>
<span>  </span><span>name</span><span>     </span><span>=</span><span> var.resource_group_name</span>
<span>  </span><span>location</span><span> </span><span>=</span><span> var.resource_group_location</span>
<span></span><span>}</span>
</code></pre><p>We will then create the <a href="https://registry.terraform.io/providers/hashicorp/azurerm/latest/docs/resources/storage_account" target="_blank" rel="noreferrer">storage account</a> and the <a href="https://registry.terraform.io/providers/hashicorp/azurerm/latest/docs/resources/storage_container" target="_blank" rel="noreferrer">storage container</a>. These are created to store our generated PDFs. We first need to create the storage account so we can bind the storage container to the correct account.</p><pre><code><span></span>
<span></span><span>resource </span><span>&#34;azurerm_storage_account&#34;</span><span> </span><span>&#34;storage&#34;</span><span> </span><span>{</span><span></span>
<span>  </span><span>name</span><span>                     </span><span>=</span><span> </span><span>&#34;tfexamplestorage&#34;</span><span></span>
<span>  </span><span>resource_group_name</span><span>      </span><span>=</span><span> azurerm_resource_group.example.name</span>
<span>  </span><span>location</span><span>                 </span><span>=</span><span> azurerm_resource_group.example.location</span>
<span>  </span><span>account_tier</span><span>             </span><span>=</span><span> </span><span>&#34;Standard&#34;</span><span></span>
<span>  </span><span>account_replication_type</span><span> </span><span>=</span><span> </span><span>&#34;LRS&#34;</span><span></span>
<span></span><span>}</span><span></span>
<!-- -->
<span></span><span></span>
<span></span><span>resource </span><span>&#34;azurerm_storage_container&#34;</span><span> </span><span>&#34;invoice_files&#34;</span><span> </span><span>{</span><span></span>
<span>  </span><span>name</span><span>                  </span><span>=</span><span> </span><span>&#34;invoicefiles&#34;</span><span></span>
<span>  </span><span>storage_account_name</span><span>  </span><span>=</span><span> azurerm_storage_account.storage.name</span>
<span>  </span><span>container_access_type</span><span> </span><span>=</span><span> </span><span>&#34;private&#34;</span><span></span>
<span></span><span>}</span>
</code></pre><p>Before we create the container apps, we need to create the <a href="https://registry.terraform.io/providers/hashicorp/azurerm/latest/docs/resources/container_registry" target="_blank" rel="noreferrer">container registry</a> and the <a href="https://registry.terraform.io/providers/hashicorp/azurerm/latest/docs/resources/container_app_environment" target="_blank" rel="noreferrer">container app environment</a>. The container registry is required to store our images and the container app environment is required to manage and run each of the container apps.</p><pre><code><span></span>
<span></span><span>resource </span><span>&#34;azurerm_container_registry&#34;</span><span> </span><span>&#34;acr&#34;</span><span> </span><span>{</span><span></span>
<span>  </span><span>name</span><span>                     </span><span>=</span><span> </span><span>&#34;tfexamplereg&#34;</span><span></span>
<span>  </span><span>resource_group_name</span><span>      </span><span>=</span><span> azurerm_resource_group.example.name</span>
<span>  </span><span>location</span><span>                 </span><span>=</span><span> azurerm_resource_group.example.location</span>
<span>  </span><span>sku</span><span>                      </span><span>=</span><span> </span><span>&#34;Basic&#34;</span><span></span>
<span>  </span><span>admin_enabled</span><span>            </span><span>=</span><span> </span><span>true</span><span></span>
<span></span><span>}</span><span></span>
<!-- -->
<span></span><span></span>
<span></span><span>resource </span><span>&#34;azurerm_container_app_environment&#34;</span><span> </span><span>&#34;environment&#34;</span><span> </span><span>{</span><span></span>
<span>  </span><span>name</span><span>                       </span><span>=</span><span> </span><span>&#34;terraform-containers&#34;</span><span></span>
<span>  </span><span>location</span><span>                   </span><span>=</span><span> azurerm_resource_group.example.location</span>
<span>  </span><span>resource_group_name</span><span>        </span><span>=</span><span> azurerm_resource_group.example.name</span>
<span></span><span>}</span>
</code></pre><p>We can now push our built images to the container registry. This can be automated by using a Terraform <a href="https://developer.hashicorp.com/terraform/language/resources/terraform-data" target="_blank" rel="noreferrer">terraform_data</a> resource type. We will set it to run on every deployment by triggering a replace on the time change. The script will login using the Azure CLI, build the images, and then push to the container registry.</p><p>As our container apps definitions for each service will be almost identical, we can deduplicate it by creating a submodule and referencing it in our main module.</p><pre><code><span>resource </span><span>&#34;terraform_data&#34;</span><span> </span><span>&#34;docker_image&#34;</span><span> </span><span>{</span><span></span>
<span>  </span><span>triggers_replace</span><span> </span><span>=</span><span> </span><span>{</span><span></span>
<span>    </span><span>always_run</span><span> </span><span>=</span><span> timestamp()</span>
<span>  </span><span>}</span><span></span>
<!-- -->
<span>  </span><span>provisioner</span><span> &#34;local-exec&#34; </span><span>{</span><span></span>
<span>    </span><span>command</span><span> </span><span>=</span><span> </span><span>&lt;&lt;EOT</span>
<span>      az acr login --name ${var.acr_name} -u ${var.registry_username} -p ${var.registry_password}</span>
<span>      docker build --platform linux/amd64 -t ${var.registry_login_server}/${var.image_name} -f ${var.dockerfile} ${var.build_context}</span>
<span>      docker push ${var.registry_login_server}/${var.image_name}</span>
<span>    EOT</span><span></span>
<span>  </span><span>}</span><span></span>
<span></span><span>}</span>
</code></pre><p>We can then create the <a href="https://registry.terraform.io/providers/hashicorp/azurerm/latest/docs/resources/container_app" target="_blank" rel="noreferrer">container apps</a> app which relies on our image. There are 5 main components to the container apps resource.</p><ul><li><code>identity</code>: defines the type of managed identity to assign to the container</li><li><code>ingress</code>: defines the ingress rules</li><li><code>registry</code>: defines which registry the image is stored and how to authenticate with it</li><li><code>secret</code>: stores input value as an encrypted secret</li><li><code>template</code>: the configuration for the container, such as the container image, cpu, memory, environment variables.</li></ul><pre><code><span>resource </span><span>&#34;azurerm_container_app&#34;</span><span> </span><span>&#34;app&#34;</span><span> </span><span>{</span><span></span>
<span>  </span><span>name</span><span>                </span><span>=</span><span> var.container_app_name</span>
<span>  </span><span>resource_group_name</span><span> </span><span>=</span><span> var.resource_group_name</span>
<span>  </span><span>container_app_environment_id</span><span>      </span><span>=</span><span> var.container_app_environment_id</span>
<!-- -->
<span>  </span><span>identity</span><span> </span><span>{</span><span></span>
<span>    </span><span>type</span><span> </span><span>=</span><span> </span><span>&#34;SystemAssigned&#34;</span><span></span>
<span>  </span><span>}</span><span></span>
<!-- -->
<span>  </span><span>ingress</span><span> </span><span>{</span><span></span>
<span>    </span><span>external_enabled</span><span> </span><span>=</span><span> </span><span>true</span><span></span>
<span>    </span><span>target_port</span><span>      </span><span>=</span><span> </span><span>3000</span><span></span>
<span>    </span><span>traffic_weight</span><span> </span><span>{</span><span></span>
<span>      </span><span>percentage</span><span> </span><span>=</span><span> </span><span>100</span><span></span>
<span>      </span><span>latest_revision</span><span> </span><span>=</span><span> </span><span>true</span><span></span>
<span>    </span><span>}</span><span></span>
<span>  </span><span>}</span><span></span>
<!-- -->
<span>  </span><span>revision_mode</span><span> </span><span>=</span><span> </span><span>&#34;Single&#34;</span><span></span>
<!-- -->
<span>  </span><span></span>
<span>  </span><span>registry</span><span> </span><span>{</span><span></span>
<span>    </span><span>server</span><span> </span><span>=</span><span> var.registry_login_server</span>
<span>    </span><span></span>
<span>    </span><span>password_secret_name</span><span> </span><span>=</span><span> </span><span>&#34;pwd&#34;</span><span></span>
<span>    </span><span>username</span><span> </span><span>=</span><span> var.registry_username</span>
<span>  </span><span>}</span><span></span>
<!-- -->
<span>  </span><span></span>
<span>  </span><span>secret</span><span> </span><span>{</span><span></span>
<span>    </span><span>name</span><span> </span><span>=</span><span> </span><span>&#34;pwd&#34;</span><span></span>
<span>    </span><span>value</span><span> </span><span>=</span><span> var.registry_password</span>
<span>  </span><span>}</span><span></span>
<!-- -->
<span>  </span><span>template</span><span> </span><span>{</span><span></span>
<span>    </span><span>container</span><span> </span><span>{</span><span></span>
<span>      </span><span>name</span><span>  </span><span>=</span><span> </span><span>&#34;app&#34;</span><span></span>
<span>      </span><span>image</span><span> </span><span>=</span><span> </span><span>&#34;</span><span>$</span><span>{</span><span>var</span><span>.</span><span>registry_login_server</span><span>}</span><span>/</span><span>$</span><span>{</span><span>var</span><span>.</span><span>image_name</span><span>}</span><span>&#34;</span><span></span>
<span>      </span><span>cpu</span><span>    </span><span>=</span><span> </span><span>0.25</span><span></span>
<span>      </span><span>memory</span><span> </span><span>=</span><span> </span><span>&#34;0.5Gi&#34;</span><span></span>
<!-- -->
<span>      </span><span></span>
<span>      dynamic </span><span>&#34;env&#34;</span><span> </span><span>{</span><span></span>
<span>        </span><span>for_each</span><span> </span><span>=</span><span> var.env_vars</span>
<!-- -->
<span>        </span><span>content</span><span> </span><span>{</span><span></span>
<span>          </span><span>name</span><span>  </span><span>=</span><span> env.key</span>
<span>          </span><span>value</span><span> </span><span>=</span><span> env.value</span>
<span>        </span><span>}</span><span></span>
<span>      </span><span>}</span><span></span>
<!-- -->
<span>      </span><span>env</span><span> </span><span>{</span><span></span>
<span>        </span><span>name</span><span> </span><span>=</span><span> </span><span>&#34;buildstamp&#34;</span><span></span>
<span>        </span><span>value</span><span> </span><span>=</span><span> timestamp()</span>
<span>      </span><span>}</span><span></span>
<span>    </span><span>}</span><span></span>
<span>  </span><span>}</span><span></span>
<!-- -->
<span>  </span><span></span>
<span>  </span><span>depends_on</span><span> </span><span>=</span><span> </span><span>[</span><span>terraform_data.docker_image</span><span>]</span><span></span>
<span></span><span>}</span>
</code></pre><p>That&#39;s all the code required for the container apps module, we just need to define our input variables and our outputs. There are quite a number of inputs for our container app as we want most of the properties to be completely configurable.</p><pre><code><span>variable</span><span> &#34;resource_group_name&#34; </span><span>{</span><span></span>
<span>  </span><span>description</span><span> </span><span>=</span><span> </span><span>&#34;The name of the resource group in which to create the Container App and ACR.&#34;</span><span></span>
<span>  </span><span>type</span><span>        </span><span>=</span><span> string</span>
<span></span><span>}</span><span></span>
<!-- -->
<span></span><span>variable</span><span> &#34;location&#34; </span><span>{</span><span></span>
<span>  </span><span>description</span><span> </span><span>=</span><span> </span><span>&#34;The location/region where the Container App and ACR should be created.&#34;</span><span></span>
<span>  </span><span>type</span><span>        </span><span>=</span><span> string</span>
<span></span><span>}</span><span></span>
<!-- -->
<span></span><span>variable</span><span> &#34;acr_name&#34; </span><span>{</span><span></span>
<span>  </span><span>description</span><span> </span><span>=</span><span> </span><span>&#34;The name of the Azure Container Registry.&#34;</span><span></span>
<span>  </span><span>type</span><span>        </span><span>=</span><span> string</span>
<span></span><span>}</span><span></span>
<!-- -->
<span></span><span>variable</span><span> &#34;acr_sku&#34; </span><span>{</span><span></span>
<span>  </span><span>description</span><span> </span><span>=</span><span> </span><span>&#34;The SKU of the Azure Container Registry.&#34;</span><span></span>
<span>  </span><span>type</span><span>        </span><span>=</span><span> string</span>
<span>  </span><span>default</span><span>     </span><span>=</span><span> </span><span>&#34;Basic&#34;</span><span></span>
<span></span><span>}</span><span></span>
<!-- -->
<span></span><span>variable</span><span> &#34;container_app_name&#34; </span><span>{</span><span></span>
<span>  </span><span>description</span><span> </span><span>=</span><span> </span><span>&#34;The name of the Container App.&#34;</span><span></span>
<span>  </span><span>type</span><span>        </span><span>=</span><span> string</span>
<span></span><span>}</span><span></span>
<!-- -->
<span></span><span>variable</span><span> &#34;image_name&#34; </span><span>{</span><span></span>
<span>  </span><span>description</span><span> </span><span>=</span><span> </span><span>&#34;Name of a local image to push to ACR&#34;</span><span></span>
<span>  </span><span>type</span><span>        </span><span>=</span><span> string</span>
<span></span><span>}</span><span></span>
<!-- -->
<span></span><span>variable</span><span> &#34;build_context&#34; </span><span>{</span><span></span>
<span>  </span><span>description</span><span> </span><span>=</span><span> </span><span>&#34;Path to the location of the application to build with docker&#34;</span><span></span>
<span>  </span><span>type</span><span>        </span><span>=</span><span> string</span>
<span></span><span>}</span><span></span>
<!-- -->
<span></span><span>variable</span><span> &#34;dockerfile&#34; </span><span>{</span><span></span>
<span>  </span><span>description</span><span> </span><span>=</span><span> </span><span>&#34;Path to the applications dockerfile&#34;</span><span></span>
<span>  </span><span>type</span><span>        </span><span>=</span><span> string</span>
<span></span><span>}</span><span></span>
<!-- -->
<span></span><span>variable</span><span> &#34;registry_login_server&#34; </span><span>{</span><span></span>
<span>  </span><span>description</span><span> </span><span>=</span><span> </span><span>&#34;URI of the ACR registry images should be pushed/pulled from&#34;</span><span></span>
<span>  </span><span>type</span><span>        </span><span>=</span><span> string</span>
<span></span><span>}</span><span></span>
<!-- -->
<span></span><span>variable</span><span> &#34;registry_username&#34; </span><span>{</span><span></span>
<span>  </span><span>description</span><span> </span><span>=</span><span> </span><span>&#34;Username for the ACR registry&#34;</span><span></span>
<span>  </span><span>type</span><span>        </span><span>=</span><span> string</span>
<span></span><span>}</span><span></span>
<!-- -->
<span></span><span>variable</span><span> &#34;registry_password&#34; </span><span>{</span><span></span>
<span>  </span><span>description</span><span> </span><span>=</span><span> </span><span>&#34;Password for the ACR registry&#34;</span><span></span>
<span>  </span><span>type</span><span>        </span><span>=</span><span> string</span>
<span></span><span>}</span><span></span>
<!-- -->
<!-- -->
<span></span><span>variable</span><span> &#34;container_app_environment_id&#34; </span><span>{</span><span></span>
<span>  </span><span>description</span><span> </span><span>=</span><span> </span><span>&#34;Id of the azure container app environment to deploy to&#34;</span><span></span>
<span>  </span><span>type</span><span>        </span><span>=</span><span> string</span>
<span></span><span>}</span><span></span>
<!-- -->
<span></span><span>variable</span><span> &#34;env_vars&#34; </span><span>{</span><span></span>
<span>  </span><span>description</span><span> </span><span>=</span><span> </span><span>&#34;Environment variables for the container&#34;</span><span></span>
<span>  </span><span>type</span><span>        </span><span>=</span><span> map(string)</span>
<span>  </span><span>default</span><span>     </span><span>=</span><span> </span><span>{</span><span>}</span><span></span>
<span></span><span>}</span>
</code></pre><p>For our outputs, we will define the container app endpoint and the managed identity.</p><pre><code><span>output</span><span> &#34;container_app_identity&#34; </span><span>{</span><span></span>
<span>  </span><span>value</span><span>       </span><span>=</span><span> azurerm_container_app.app.identity.</span><span>0.</span><span>principal_id</span>
<span>  </span><span>description</span><span> </span><span>=</span><span> </span><span>&#34;The managed identity of this container app&#34;</span><span></span>
<span></span><span>}</span><span></span>
<!-- -->
<span></span><span>output</span><span> &#34;container_app_endpoint&#34; </span><span>{</span><span></span>
<span>  </span><span>value</span><span>       </span><span>=</span><span> azurerm_container_app.app.ingress</span><span>[</span><span>0</span><span>]</span><span>.fqdn</span>
<span>  </span><span>description</span><span> </span><span>=</span><span> </span><span>&#34;The application endpoint of this container app&#34;</span><span></span>
<span></span><span>}</span>
</code></pre><p>Now going back to the main module, we will implement the container apps using our submodule. We will start with the orders service, which references the EventGrid topic.</p><pre><code><span>resource </span><span>&#34;azurerm_eventgrid_topic&#34;</span><span> </span><span>&#34;orders_topic&#34;</span><span> </span><span>{</span><span></span>
<span>  </span><span>name</span><span>                </span><span>=</span><span> </span><span>&#34;terraform-order-updates&#34;</span><span></span>
<span>  </span><span>location</span><span>            </span><span>=</span><span> azurerm_resource_group.example.location</span>
<span>  </span><span>resource_group_name</span><span> </span><span>=</span><span> azurerm_resource_group.example.name</span>
<span></span><span>}</span>
</code></pre><p>We can then create our container app using the container apps module. You can reference this module using the <code>source</code> property. This passes in information about the container registry and the resource group, as well as service specific variables like the Dockerfile location and the event grid topic name.</p><pre><code><span>module</span><span> &#34;orders_container_app&#34; </span><span>{</span><span></span>
<span>  </span><span>source</span><span>              </span><span>=</span><span> </span><span>&#34;./modules/containerapps&#34;</span><span></span>
<span>  </span><span>acr_name</span><span> </span><span>=</span><span> azurerm_container_registry.acr.name</span>
<span>  </span><span>container_app_name</span><span> </span><span>=</span><span> </span><span>&#34;orders&#34;</span><span></span>
<span>  </span><span>container_app_environment_id</span><span>  </span><span>=</span><span> azurerm_container_app_environment.environment.id</span>
<!-- -->
<span>  </span><span>resource_group_name</span><span> </span><span>=</span><span> azurerm_resource_group.example.name</span>
<span>  </span><span>location</span><span>            </span><span>=</span><span> azurerm_resource_group.example.location</span>
<span>  </span><span>registry_login_server</span><span> </span><span>=</span><span> azurerm_container_registry.acr.login_server</span>
<span>  </span><span>registry_username</span><span> </span><span>=</span><span> azurerm_container_registry.acr.admin_username</span>
<span>  </span><span>registry_password</span><span> </span><span>=</span><span> azurerm_container_registry.acr.admin_password</span>
<span>  </span><span>image_name</span><span> </span><span>=</span><span> </span><span>&#34;orders:latest&#34;</span><span></span>
<span>  </span><span>build_context</span><span> </span><span>=</span><span> </span><span>&#34;.&#34;</span><span></span>
<span>  </span><span>dockerfile</span><span> </span><span>=</span><span> </span><span>&#34;./orders/Dockerfile&#34;</span><span></span>
<!-- -->
<span>  </span><span>env_vars</span><span> </span><span>=</span><span> </span><span>{</span><span></span>
<span>    </span><span>PORT</span><span>                               </span><span>=</span><span> </span><span>&#34;3000&#34;</span><span></span>
<span>    </span><span>AZURE_REGION</span><span>                       </span><span>=</span><span> azurerm_resource_group.example.location</span>
<span>    </span><span>AZURE_TOPIC</span><span>                        </span><span>=</span><span> azurerm_eventgrid_topic.orders_topic.name</span>
<span>  </span><span>}</span><span></span>
<span></span><span>}</span>
</code></pre><p>For the orders application to work, we need to give it permissions to push events to the orders topic. This will be a container app role assignment with the EventGrid Data Sender role, scoped to the topic.</p><pre><code><span>resource </span><span>&#34;azurerm_role_assignment&#34;</span><span> </span><span>&#34;orders_topic_access&#34;</span><span> </span><span>{</span><span></span>
<span>  </span><span>scope</span><span>                </span><span>=</span><span> azurerm_eventgrid_topic.orders_topic.id</span>
<span>  </span><span>role_definition_name</span><span> </span><span>=</span><span> </span><span>&#34;EventGrid Data Sender&#34;</span><span></span>
<span>  </span><span>principal_id</span><span>         </span><span>=</span><span> module.orders_container_app.container_app_identity</span>
<!-- -->
<span>  </span><span>depends_on</span><span> </span><span>=</span><span> </span><span>[</span><span></span>
<span>    module.orders_container_app</span>
<span>  </span><span>]</span><span></span>
<span></span><span>}</span>
</code></pre><p>We can then implement the invoices container. This service will be basically the same to implement. You will notice in the environment variables that instead of referencing the event grid topic, we are instead referencing the storage container so our invoices can be stored.</p><pre><code><span>module</span><span> &#34;invoices_container_app&#34; </span><span>{</span><span></span>
<span>  </span><span>source</span><span>              </span><span>=</span><span> </span><span>&#34;./modules/containerapps&#34;</span><span></span>
<span>  </span><span>acr_name</span><span> </span><span>=</span><span> azurerm_container_registry.acr.name</span>
<span>  </span><span>container_app_name</span><span> </span><span>=</span><span> </span><span>&#34;invoices&#34;</span><span></span>
<span>  </span><span>container_app_environment_id</span><span>  </span><span>=</span><span> azurerm_container_app_environment.environment.id</span>
<span>  </span><span>resource_group_name</span><span> </span><span>=</span><span> azurerm_resource_group.example.name</span>
<span>  </span><span>registry_login_server</span><span> </span><span>=</span><span> azurerm_container_registry.acr.login_server</span>
<span>  </span><span>registry_username</span><span> </span><span>=</span><span> azurerm_container_registry.acr.admin_username</span>
<span>  </span><span>registry_password</span><span> </span><span>=</span><span> azurerm_container_registry.acr.admin_password</span>
<span>  </span><span>location</span><span>            </span><span>=</span><span> azurerm_resource_group.example.location</span>
<span>  </span><span>image_name</span><span> </span><span>=</span><span> </span><span>&#34;invoices:latest&#34;</span><span></span>
<span>  </span><span>build_context</span><span> </span><span>=</span><span> </span><span>&#34;.&#34;</span><span></span>
<span>  </span><span>dockerfile</span><span> </span><span>=</span><span> </span><span>&#34;./invoices/Dockerfile&#34;</span><span></span>
<!-- -->
<!-- -->
<span>  </span><span>env_vars</span><span> </span><span>=</span><span> </span><span>{</span><span></span>
<span>    </span><span>PORT</span><span>                               </span><span>=</span><span> </span><span>&#34;3000&#34;</span><span></span>
<span>    </span><span>AZURE_REGION</span><span>                       </span><span>=</span><span> azurerm_resource_group.example.location</span>
<span>    </span><span>AZURE_STORAGE_CONNECTION_STRING</span><span>    </span><span>=</span><span> azurerm_storage_account.storage.primary_connection_string</span>
<span>    </span><span>AZURE_INVOICES_CONTAINER_NAME</span><span> </span><span>=</span><span> azurerm_storage_container.invoice_files.name</span>
<span>    </span><span>INVOICE_API_KEY</span><span> </span><span>=</span><span> var.invoice_api_key</span>
<span>    </span><span>INVOICE_API_URL</span><span> </span><span>=</span><span> var.invoice_api_url</span>
<span>  </span><span>}</span><span></span>
<span></span><span>}</span>
</code></pre><p>To push invoices to the storage container, we need to assign the Storage Blob Data Contributor role to the container app.</p><pre><code><span>resource </span><span>&#34;azurerm_role_assignment&#34;</span><span> </span><span>&#34;invoices_storage_access&#34;</span><span> </span><span>{</span><span></span>
<span>  </span><span>scope</span><span> </span><span>=</span><span> azurerm_resource_group.example.id</span>
<span>  </span><span>role_definition_name</span><span> </span><span>=</span><span> </span><span>&#34;Storage Blob Data Contributor&#34;</span><span></span>
<span>  </span><span>principal_id</span><span>         </span><span>=</span><span> module.invoices_container_app.container_app_identity</span>
<span></span><span>}</span>
</code></pre><p>Finally, we can bind our container app to events sent to the topic by setting up an EventGrid subscription.</p><pre><code><span>resource </span><span>&#34;azurerm_eventgrid_event_subscription&#34;</span><span> </span><span>&#34;invoices_subscription&#34;</span><span> </span><span>{</span><span></span>
<span>  </span><span>name</span><span>  </span><span>=</span><span> </span><span>&#34;example-eventgridsubscription-auth&#34;</span><span></span>
<span>  </span><span>scope</span><span> </span><span>=</span><span> azurerm_eventgrid_topic.orders_topic.id</span>
<!-- -->
<span>  </span><span>webhook_endpoint</span><span> </span><span>{</span><span></span>
<span>    </span><span>url</span><span> </span><span>=</span><span> </span><span>&#34;https://</span><span>$</span><span>{</span><span>module</span><span>.</span><span>invoices_container_app</span><span>.</span><span>container_app_endpoint</span><span>}</span><span>/handle-orders&#34;</span><span></span>
<span>    </span><span>max_events_per_batch</span><span>  </span><span>=</span><span> </span><span>1</span><span></span>
<span>    </span><span>preferred_batch_size_in_kilobytes</span><span> </span><span>=</span><span> </span><span>64</span><span></span>
<span>  </span><span>}</span><span></span>
<span></span><span>}</span>
</code></pre><p>The only thing left to do is define our inputs and outputs. The inputs will mostly be defaults, but also allow for configuration and binding to your deployed invoice generating API.</p><pre><code><span>variable</span><span> &#34;resource_group_name&#34; </span><span>{</span><span></span>
<span>  </span><span>description</span><span> </span><span>=</span><span> </span><span>&#34;The name of the resource group.&#34;</span><span></span>
<span>  </span><span>default</span><span>     </span><span>=</span><span> </span><span>&#34;example-resources&#34;</span><span></span>
<span></span><span>}</span><span></span>
<!-- -->
<span></span><span>variable</span><span> &#34;resource_group_location&#34; </span><span>{</span><span></span>
<span>  </span><span>description</span><span> </span><span>=</span><span> </span><span>&#34;The location of the resource group.&#34;</span><span></span>
<span>  </span><span>default</span><span>     </span><span>=</span><span> </span><span>&#34;East US&#34;</span><span></span>
<span></span><span>}</span><span></span>
<!-- -->
<span></span><span>variable</span><span> &#34;storage_account_name&#34; </span><span>{</span><span></span>
<span>  </span><span>description</span><span> </span><span>=</span><span> </span><span>&#34;The name of the storage account.&#34;</span><span></span>
<span>  </span><span>default</span><span>     </span><span>=</span><span> </span><span>&#34;examplestoracc&#34;</span><span></span>
<span></span><span>}</span><span></span>
<!-- -->
<span></span><span>variable</span><span> &#34;container_name&#34; </span><span>{</span><span></span>
<span>  </span><span>description</span><span> </span><span>=</span><span> </span><span>&#34;The name of the storage container.&#34;</span><span></span>
<span>  </span><span>default</span><span>     </span><span>=</span><span> </span><span>&#34;examplecontainer&#34;</span><span></span>
<span></span><span>}</span><span></span>
<!-- -->
<span></span><span>variable</span><span> &#34;ARM_CLIENT_ID&#34; </span><span>{</span><span></span>
<span>  </span><span>description</span><span> </span><span>=</span><span> </span><span>&#34;Azure Client ID&#34;</span><span></span>
<span>  </span><span>type</span><span>        </span><span>=</span><span> string</span>
<span>  </span><span>default</span><span>     </span><span>=</span><span> </span><span>&#34;&#34;</span><span></span>
<span></span><span>}</span><span></span>
<!-- -->
<span></span><span>variable</span><span> &#34;ARM_CLIENT_SECRET&#34; </span><span>{</span><span></span>
<span>  </span><span>description</span><span> </span><span>=</span><span> </span><span>&#34;Azure Client Secret&#34;</span><span></span>
<span>  </span><span>type</span><span>        </span><span>=</span><span> string</span>
<span>  </span><span>default</span><span>     </span><span>=</span><span> </span><span>&#34;&#34;</span><span></span>
<span></span><span>}</span><span></span>
<!-- -->
<span></span><span>variable</span><span> &#34;ARM_SUBSCRIPTION_ID&#34; </span><span>{</span><span></span>
<span>  </span><span>description</span><span> </span><span>=</span><span> </span><span>&#34;Azure Subscription ID&#34;</span><span></span>
<span>  </span><span>type</span><span>        </span><span>=</span><span> string</span>
<span>  </span><span>default</span><span>     </span><span>=</span><span> </span><span>&#34;&#34;</span><span></span>
<span></span><span>}</span><span></span>
<!-- -->
<span></span><span>variable</span><span> &#34;ARM_TENANT_ID&#34; </span><span>{</span><span></span>
<span>  </span><span>description</span><span> </span><span>=</span><span> </span><span>&#34;Azure Tenant ID&#34;</span><span></span>
<span>  </span><span>type</span><span>        </span><span>=</span><span> string</span>
<span>  </span><span>default</span><span>     </span><span>=</span><span> </span><span>&#34;&#34;</span><span></span>
<span></span><span>}</span><span></span>
<!-- -->
<span></span><span>variable</span><span> &#34;invoice_api_url&#34; </span><span>{</span><span></span>
<span>  </span><span>type</span><span> </span><span>=</span><span> string</span>
<span></span><span>}</span><span></span>
<!-- -->
<span></span><span>variable</span><span> &#34;invoice_api_key&#34; </span><span>{</span><span></span>
<span>  </span><span>type</span><span> </span><span>=</span><span> string</span>
<span></span><span>}</span>
</code></pre><p>The only output we need to define is our resource group id. This will allow you to reference this resource group in the future.</p><pre><code><span>output</span><span> &#34;resource_group_id&#34; </span><span>{</span><span></span>
<span>  </span><span>description</span><span> </span><span>=</span><span> </span><span>&#34;The ID of the resource group.&#34;</span><span></span>
<span>  </span><span>value</span><span>       </span><span>=</span><span> azurerm_resource_group.example.id</span>
<span></span><span>}</span>
</code></pre><h3 id="application-code">Application Code</h3><p>With the infrastructure definitions done, we can start writing our application code.</p><p>We&#39;ll start with the orders service. This will look fairly similar to the orders service written with Nitric, however it will use Express.js and the native Azure client. This uses the <code>EventGridPublisherClient</code> from <code>@azure/eventgrid</code> and pulls your default azure credentials using <code>DefaultAzureCredential</code> from <code>@azure/identity</code>. We will use the <code>bodyParser</code> plugin for express, which will parse our requests as JSON. You will want to add all these as dependencies to the application using <code>yarn</code> or <code>npm</code>.</p><pre><code><span>yarn</span><span> </span><span>add</span><span> express body-parser @azure/identity @azure/eventgrid</span>
</code></pre><p>With those dependencies installed, we can start by initialising our express application and the Azure client.</p><pre><code><span>import</span><span> express</span><span>,</span><span> </span><span>{</span><span> Request</span><span>,</span><span> Response </span><span>}</span><span> </span><span>from</span><span> </span><span>&#39;express&#39;</span><span></span>
<span></span><span>import</span><span> </span><span>{</span><span> EventGridPublisherClient </span><span>}</span><span> </span><span>from</span><span> </span><span>&#39;@azure/eventgrid&#39;</span><span></span>
<span></span><span>import</span><span> </span><span>{</span><span> DefaultAzureCredential </span><span>}</span><span> </span><span>from</span><span> </span><span>&#39;@azure/identity&#39;</span><span></span>
<span></span><span>import</span><span> bodyParser </span><span>from</span><span> </span><span>&#39;body-parser&#39;</span><span></span>
<!-- -->
<span></span><span></span>
<span></span><span>const</span><span> </span><span>PORT</span><span> </span><span>=</span><span> process</span><span>.</span><span>env</span><span>.</span><span>PORT</span><span> </span><span>||</span><span> </span><span>3000</span><span></span>
<span></span><span>const</span><span> </span><span>TOPIC</span><span> </span><span>=</span><span> process</span><span>.</span><span>env</span><span>.</span><span>AZURE_TOPIC</span><span> </span><span>||</span><span> </span><span>&#39;terraform-order-updates&#39;</span><span></span>
<span></span><span>const</span><span> </span><span>REGION</span><span> </span><span>=</span><span> process</span><span>.</span><span>env</span><span>.</span><span>AZURE_REGION</span><span> </span><span>||</span><span> </span><span>&#39;eastus&#39;</span><span></span>
<!-- -->
<span></span><span>const</span><span> app</span><span>:</span><span> express</span><span>.</span><span>Application </span><span>=</span><span> </span><span>express</span><span>(</span><span>)</span><span></span>
<span>app</span><span>.</span><span>use</span><span>(</span><span>bodyParser</span><span>.</span><span>json</span><span>(</span><span>)</span><span>)</span><span></span>
<!-- -->
<span></span><span></span>
<span></span><span>const</span><span> client </span><span>=</span><span> </span><span>new</span><span> </span><span>EventGridPublisherClient</span><span>(</span><span></span>
<span>  </span><span>`</span><span>https://</span><span>${</span><span>TOPIC</span><span>}</span><span>.</span><span>${</span><span>REGION</span><span>}</span><span>-1.eventgrid.azure.net/api/events</span><span>`</span><span>,</span><span></span>
<span>  </span><span>&#39;EventGrid&#39;</span><span>,</span><span></span>
<span>  </span><span>new</span><span> </span><span>DefaultAzureCredential</span><span>(</span><span>)</span><span></span>
<span></span><span>)</span>
</code></pre><p>Let&#39;s now write the <code>/order</code> route. This route will forward receive an orders payload and forward it to the topic. It will return 201 if the order was received.</p><pre><code><span>app</span><span>.</span><span>post</span><span>(</span><span>&#39;/order&#39;</span><span>,</span><span> </span><span>async</span><span> </span><span>(</span><span>req</span><span>:</span><span> Request</span><span>,</span><span> res</span><span>:</span><span> Response</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span></span>
<span>  </span><span></span>
<span>  </span><span>await</span><span> client</span><span>.</span><span>send</span><span>(</span><span>[</span><span></span>
<span>    </span><span>{</span><span></span>
<span>      eventType</span><span>:</span><span> </span><span>&#39;order.created&#39;</span><span>,</span><span></span>
<span>      subject</span><span>:</span><span> req</span><span>.</span><span>body</span><span>.</span><span>orderNumber</span><span>,</span><span></span>
<span>      dataVersion</span><span>:</span><span> </span><span>&#39;1.0&#39;</span><span>,</span><span></span>
<span>      data</span><span>:</span><span> req</span><span>.</span><span>body</span><span>,</span><span></span>
<span>    </span><span>}</span><span>,</span><span></span>
<span>  </span><span>]</span><span>)</span><span></span>
<!-- -->
<span>  </span><span></span>
<span>  </span><span>return</span><span> res</span><span>.</span><span>status</span><span>(</span><span>201</span><span>)</span><span>.</span><span>json</span><span>(</span><span>{</span><span></span>
<span>    message</span><span>:</span><span> </span><span>&#39;Order received&#39;</span><span>,</span><span></span>
<span>    order</span><span>:</span><span> req</span><span>.</span><span>body</span><span>,</span><span></span>
<span>  </span><span>}</span><span>)</span><span></span>
<span></span><span>}</span><span>)</span>
</code></pre><p>Finally, we&#39;ll start the express application on the port specified by the <code>PORT</code> environment variable, defaulting to 3000.</p><pre><code><span></span>
<span>app</span><span>.</span><span>listen</span><span>(</span><span>PORT</span><span>,</span><span> </span><span>(</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span></span>
<span>  </span><span>console</span><span>.</span><span>log</span><span>(</span><span>`</span><span>Server running at http://localhost:</span><span>${</span><span>PORT</span><span>}</span><span>/</span><span>`</span><span>)</span><span></span>
<span></span><span>}</span><span>)</span>
</code></pre><p>To deploy our application to container apps, we need to create a Dockerfile. We have already set up in the Terraform to automatically build and deploy our image. We&#39;ll start from the node base image, copying the required files into the image.</p><pre><code><span></span>
<span></span><span>FROM</span><span> node:18 </span><span>AS</span><span> builder</span><span></span>
<!-- -->
<span></span><span>WORKDIR</span><span> /app</span><span></span>
<!-- -->
<span></span><span>COPY</span><span> orders/package*.json /app/orders/</span><span></span>
<span></span><span>COPY</span><span> orders/tsconfig*.json /app/orders/</span><span></span>
<span></span><span>COPY</span><span> orders/src /app/orders/src</span>
</code></pre><p>Then install the dependencies and build the application.</p><pre><code><span>RUN</span><span> cd /app/orders &amp;&amp; yarn install &amp;&amp; yarn run build</span>
</code></pre><p>We will then create the base for our runner image and copy the built code into it. After that, we will install the production dependencies.</p><pre><code><span></span>
<span></span><span>FROM</span><span> node:18</span><span></span>
<!-- -->
<span></span><span>WORKDIR</span><span> /app</span><span></span>
<!-- -->
<span></span><span>COPY</span><span> </span><span>--from</span><span>=</span><span>builder</span><span> /app/orders/dist /app/orders/dist</span><span></span>
<span></span><span>COPY</span><span> </span><span>--from</span><span>=</span><span>builder</span><span> /app/orders/package\*.json /app/orders/</span><span></span>
<!-- -->
<span></span><span>RUN</span><span> cd /app/orders &amp;&amp; yarn install --production</span>
</code></pre><p>We can then expose port 3000 and set our built application as the entrypoint for the container app starting.</p><pre><code><span>EXPOSE</span><span> 3000</span><span></span>
<!-- -->
<span></span><span>CMD</span><span> [</span><span>&#34;node&#34;</span><span>, </span><span>&#34;./orders/dist/app.js&#34;</span><span>]</span>
</code></pre><p>We can then create the invoices application. This will use the <code>BlobServiceClient</code> from <code>@azure/storage-blob</code>. We will add this as a dependency.</p><pre><code><span>yarn</span><span> </span><span>add</span><span> </span><span>`</span><span>@azure/storage-blob</span><span>`</span>
</code></pre><p>We can then initialise the express application and the Azure storage client. We will pull out the environment variables to start, erroring if we can&#39;t find the variables required by the Azure client.</p><pre><code><span>import</span><span> express</span><span>,</span><span> </span><span>{</span><span> Request</span><span>,</span><span> Response </span><span>}</span><span> </span><span>from</span><span> </span><span>&#39;express&#39;</span><span></span>
<span></span><span>import</span><span> </span><span>{</span><span> BlobServiceClient </span><span>}</span><span> </span><span>from</span><span> </span><span>&#39;@azure/storage-blob&#39;</span><span></span>
<span></span><span>import</span><span> bodyParser </span><span>from</span><span> </span><span>&#39;body-parser&#39;</span><span></span>
<!-- -->
<span></span><span></span>
<span></span><span>const</span><span> </span><span>PORT</span><span> </span><span>=</span><span> process</span><span>.</span><span>env</span><span>.</span><span>PORT</span><span> </span><span>||</span><span> </span><span>3000</span><span></span>
<span></span><span>const</span><span> </span><span>INVOICE_API_URL</span><span> </span><span>=</span><span> process</span><span>.</span><span>env</span><span>.</span><span>INVOICE_API_URL</span><span> </span><span>||</span><span> </span><span>&#39;&#39;</span><span></span>
<span></span><span>const</span><span> </span><span>INVOICE_API_KEY</span><span> </span><span>=</span><span> process</span><span>.</span><span>env</span><span>.</span><span>INVOICE_API_KEY</span><span> </span><span>||</span><span> </span><span>&#39;&#39;</span><span></span>
<!-- -->
<span></span><span>const</span><span> app</span><span>:</span><span> express</span><span>.</span><span>Application </span><span>=</span><span> </span><span>express</span><span>(</span><span>)</span><span></span>
<span>app</span><span>.</span><span>use</span><span>(</span><span>bodyParser</span><span>.</span><span>json</span><span>(</span><span>)</span><span>)</span><span></span>
<!-- -->
<span></span><span></span>
<span></span><span>const</span><span> </span><span>STORAGE_CONN_STR</span><span> </span><span>=</span><span> process</span><span>.</span><span>env</span><span>.</span><span>AZURE_STORAGE_CONNECTION_STRING</span><span></span>
<span></span><span>if</span><span> </span><span>(</span><span>!</span><span>STORAGE_CONN_STR</span><span>)</span><span> </span><span>{</span><span></span>
<span>  </span><span>throw</span><span> </span><span>Error</span><span>(</span><span>&#39;Azure Storage Connection string not found&#39;</span><span>)</span><span></span>
<span></span><span>}</span><span></span>
<!-- -->
<span></span><span>const</span><span> </span><span>INV_CONTAINER</span><span> </span><span>=</span><span> process</span><span>.</span><span>env</span><span>.</span><span>AZURE_INVOICES_CONTAINER_NAME</span><span></span>
<span></span><span>if</span><span> </span><span>(</span><span>!</span><span>INV_CONTAINER</span><span>)</span><span> </span><span>{</span><span></span>
<span>  </span><span>throw</span><span> </span><span>Error</span><span>(</span><span>&#39;Azure Storage Container string not found&#39;</span><span>)</span><span></span>
<span></span><span>}</span><span></span>
<!-- -->
<span></span><span>const</span><span> blobServiceClient </span><span>=</span><span></span>
<span>  BlobServiceClient</span><span>.</span><span>fromConnectionString</span><span>(</span><span>STORAGE_CONN_STR</span><span>)</span><span></span>
<span></span><span>const</span><span> containerClient </span><span>=</span><span> blobServiceClient</span><span>.</span><span>getContainerClient</span><span>(</span><span>INV_CONTAINER</span><span>)</span>
</code></pre><p>We&#39;ll then write the handler that will subscribe to the orders topic. This will written on the route <code>/handle-orders</code> which was bound to the topic in the terraform code.</p><pre><code><span>app</span><span>.</span><span>post</span><span>(</span><span>&#39;/handle-orders&#39;</span><span>,</span><span> </span><span>async</span><span> </span><span>(</span><span>req</span><span>:</span><span> Request</span><span>,</span><span> res</span><span>:</span><span> Response</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span></span>
<span>  </span><span></span>
<span>  </span><span>if</span><span> </span><span>(</span><span>req</span><span>.</span><span>header</span><span>(</span><span>&#39;aeg-event-type&#39;</span><span>)</span><span> </span><span>===</span><span> </span><span>&#39;SubscriptionValidation&#39;</span><span>)</span><span> </span><span>{</span><span></span>
<span>    </span><span>const</span><span> validationCode </span><span>=</span><span> req</span><span>.</span><span>body</span><span>[</span><span>0</span><span>]</span><span>.</span><span>data</span><span>.</span><span>validationCode</span>
<span>    </span><span>return</span><span> res</span><span>.</span><span>status</span><span>(</span><span>200</span><span>)</span><span>.</span><span>send</span><span>(</span><span>{</span><span> validationResponse</span><span>:</span><span> validationCode </span><span>}</span><span>)</span><span></span>
<span>  </span><span>}</span><span></span>
<!-- -->
<span>  </span><span>const</span><span> orderEvents </span><span>=</span><span> req</span><span>.</span><span>body</span>
<span>  </span><span>if</span><span> </span><span>(</span><span>!</span><span>Array</span><span>.</span><span>isArray</span><span>(</span><span>orderEvents</span><span>)</span><span>)</span><span> </span><span>{</span><span></span>
<span>    </span><span>return</span><span> res</span><span>.</span><span>status</span><span>(</span><span>400</span><span>)</span><span>.</span><span>send</span><span>(</span><span>&#39;expected array of order events&#39;</span><span>)</span><span></span>
<span>  </span><span>}</span><span></span>
<!-- -->
<span>  </span><span>await</span><span> </span><span>Promise</span><span>.</span><span>all</span><span>(</span><span></span>
<span>    </span><span></span>
<span>    orderEvents</span><span>.</span><span>map</span><span>(</span><span>async</span><span> </span><span>(</span><span>orderEvent</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span></span>
<span>      </span><span>const</span><span> order </span><span>=</span><span> orderEvent</span><span>.</span><span>data</span>
<!-- -->
<span>      </span><span>const</span><span> response </span><span>=</span><span> </span><span>await</span><span> </span><span>fetch</span><span>(</span><span>`</span><span>${</span><span>INVOICE_API_URL</span><span>}</span><span>/invoices</span><span>`</span><span>,</span><span> </span><span>{</span><span></span>
<span>        method</span><span>:</span><span> </span><span>&#39;POST&#39;</span><span>,</span><span></span>
<span>        headers</span><span>:</span><span> </span><span>{</span><span></span>
<span>          </span><span>&#39;x-api-key&#39;</span><span>:</span><span> </span><span>INVOICE_API_KEY</span><span>,</span><span></span>
<span>        </span><span>}</span><span>,</span><span></span>
<span>        body</span><span>:</span><span> </span><span>JSON</span><span>.</span><span>stringify</span><span>(</span><span>order</span><span>)</span><span>,</span><span></span>
<span>      </span><span>}</span><span>)</span><span></span>
<!-- -->
<span>      </span><span>if</span><span> </span><span>(</span><span>!</span><span>response</span><span>.</span><span>ok</span><span>)</span><span> </span><span>{</span><span></span>
<span>        </span><span>throw</span><span> </span><span>new</span><span> </span><span>Error</span><span>(</span><span></span>
<span>          </span><span>`</span><span>Failed to generate invoice for order </span><span>${</span><span>order</span><span>.</span><span>orderNumber</span><span>}</span><span>`</span><span></span>
<span>        </span><span>)</span><span></span>
<span>      </span><span>}</span><span></span>
<span>      </span><span>const</span><span> invoiceFile </span><span>=</span><span> </span><span>await</span><span> response</span><span>.</span><span>arrayBuffer</span><span>(</span><span>)</span><span></span>
<span>      </span><span>const</span><span> blockBlobClient </span><span>=</span><span> containerClient</span><span>.</span><span>getBlockBlobClient</span><span>(</span><span></span>
<span>        </span><span>`</span><span>${</span><span>order</span><span>.</span><span>orderNumber</span><span>}</span><span>.pdf</span><span>`</span><span></span>
<span>      </span><span>)</span><span></span>
<!-- -->
<span>      </span><span></span>
<span>      </span><span>await</span><span> blockBlobClient</span><span>.</span><span>upload</span><span>(</span><span>invoiceFile</span><span>,</span><span> invoiceFile</span><span>.</span><span>byteLength</span><span>)</span><span></span>
<span>    </span><span>}</span><span>)</span><span></span>
<span>  </span><span>)</span><span></span>
<!-- -->
<span>  </span><span>return</span><span> res</span><span>.</span><span>status</span><span>(</span><span>200</span><span>)</span><span></span>
<span></span><span>}</span><span>)</span><span></span>
<!-- -->
<span></span><span></span>
<span>app</span><span>.</span><span>listen</span><span>(</span><span>PORT</span><span>,</span><span> </span><span>(</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span></span>
<span>  </span><span>console</span><span>.</span><span>log</span><span>(</span><span>`</span><span>Server running at http://localhost:</span><span>${</span><span>PORT</span><span>}</span><span>/</span><span>`</span><span>)</span><span></span>
<span></span><span>}</span><span>)</span>
</code></pre><p>We&#39;ll then create the invoices dockerfile. This is identical to the orders dockerfile, but references the orders application instead.</p><pre><code><span></span>
<span></span><span>FROM</span><span> node:18 </span><span>AS</span><span> builder</span><span></span>
<!-- -->
<span></span><span>WORKDIR</span><span> /app</span><span></span>
<!-- -->
<span></span><span></span>
<span></span><span>COPY</span><span> invoices/package*.json /app/invoices/</span><span></span>
<span></span><span>COPY</span><span> invoices/tsconfig*.json /app/invoices/</span><span></span>
<span></span><span>COPY</span><span> invoices/src /app/invoices/src</span><span></span>
<!-- -->
<span></span><span>RUN</span><span> cd /app/invoices &amp;&amp; yarn install &amp;&amp; yarn run build</span><span></span>
<!-- -->
<span></span><span></span>
<span></span><span>FROM</span><span> node:18</span><span></span>
<!-- -->
<span></span><span>WORKDIR</span><span> /app</span><span></span>
<!-- -->
<span></span><span></span>
<span></span><span>COPY</span><span> </span><span>--from</span><span>=</span><span>builder</span><span> /app/invoices/dist /app/invoices/dist</span><span></span>
<span></span><span>COPY</span><span> </span><span>--from</span><span>=</span><span>builder</span><span> /app/invoices/package*.json /app/invoices/</span><span></span>
<!-- -->
<span></span><span>RUN</span><span> cd /app/invoices &amp;&amp; yarn install --production</span><span></span>
<!-- -->
<span></span><span>EXPOSE</span><span> 3000</span><span></span>
<!-- -->
<span></span><span>CMD</span><span> [</span><span>&#34;node&#34;</span><span>, </span><span>&#34;./invoices/dist/app.js&#34;</span><span>]</span>
</code></pre><p>To deploy our application we can use the terraform CLI. Running the following command will first preview the deployment, then deploy your infrastructure.</p><pre><code><span>terraform apply</span>
</code></pre><h2 id="comparing-terraform-and-nitric-approaches">Comparing Terraform and Nitric Approaches</h2><p>The difference in these two approaches mainly comes from the separation of the infrastructure and application code. By using an Infrastructure as Code approach, such as Terraform, you have to write your infrastructure code and separately write your application code. Using <a href="https://nitric.io/blog/iac-vs-ifc">Infrastructure <em>from</em> Code</a> like Nitric means your infrastructure is inferred from your application code. Nitric removes the need for rewriting infrastructure boilerplate every time you want to write an application and is completely cloud portable. Beyond that, it removes possibilities of misconfiguration by automatically binding your infrastructure together and creating the least-privilege policies required for your application to run. If you wanted to be able to completely customise your infrastructure, using IaC can be practical. However, it is rare that an application requires any level of customisation beyond the default.</p><blockquote><p>If you do need to customise, Nitric still has the option to extend the default providers.</p></blockquote><p>Terraform can be difficult to maintain due to the size of the infrastructure code and the possibilities for infrastructure drift. Infrastructure drift is when the state of infrastructure in your cloud does not match what is defined in your infrastructure code. This difference can happen due to a number of reasons, such as making manual changes, IaC environment differences, and human error. No matter the cause, infrastructure drift can cause unwanted errors and security weaknesses in your application. By unifying your application and infrastructure with IfC you reduce the risk of drift as infrastructure is only changed depending on your application&#39;s requirements.</p><p>If you want to learn more about Nitric or more of the benefits of Infrastructure from Code, come have a chat on our <a href="https://nitric.io/chat" target="_blank" rel="noreferrer">Discord</a>.</p></div></article></div>
  </body>
</html>
