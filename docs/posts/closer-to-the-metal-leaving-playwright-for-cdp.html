<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://browser-use.com/posts/playwright-to-cdp">Original</a>
    <h1>Closer to the Metal: Leaving Playwright for CDP</h1>
    
    <div id="readability-page-1" class="page"><div><div><h2>Goodbye Playwright, Hello CDP</h2>
<p>Playwright and Puppeteer are great for making QA tests and automation scripts short and readable, but as AI browser companies have been <a href="https://www.browserbase.com/blog/taming-iframes-a-stagehand-update">learning the hard way</a> over the last year, sometimes these adapters obscure important details about the underlying browsers.</p>
<p>We decided to peek behind the curtain and figure out what the browser was really doing, and it made us decide to drop playwright entirely and just speak the browser&#39;s native tongue: CDP.</p>
<p>By switcing to raw CDP we&#39;ve massively increased the speed of element extraction, screenshots, and all our default actions. We&#39;ve also managed to add new async reaction capabilities to the agent, and proper cross-origin iframe support.</p>
<blockquote>
<p><img alt="" src="https://docs.monadical.com/uploads/b30d71c0-29ee-4053-84b6-cc23d797926a.png"/>
Obviously we ignored the (wise) advice in the header of the <a href="https://github.com/aslushnikov/getting-started-with-cdp">getting-started-with-cdp</a> docs üëå</p>
</blockquote>
<h2>The Curse of Abstraction</h2>
<p><img src="https://docs.monadical.com/uploads/0315c67b-b8db-4a62-914e-161bbc752297.png" width="36%"/></p><p>Building AI browser automation is like building on top of a jenga tower of complexity. Every layer presents its own leaky abstractions, its own subtle crashes, and its own resource constraints.</p>
<p>If you&#39;ve ever heavily depended on an adapter library and build up a large codebase around it, you know the feeling that eventually comes when you realize the adapter library is no longer saving you any time by &#34;hiding the true complexity&#34;. In our case that time has finally come for Browser-Use and playwright-python, the library that we&#39;ve historically used to drive our browsers with LLM-powered tool calls like <code>click</code>, <code>input_text</code>, <code>go_to_url</code>.</p>
<p>At first glance it may seem foolish to throw out such a mature adapter library and reinvent the wheel, but luckily the needs of AI browser agents are much narrower than the entire surface area that playwright provides, and we believe we can implement the calls we need with more specialized logic to better suit AI drivers.</p>
<p>Playwright also introduces a 2nd network hop going through a node.js playwright server websocket, which incurs a meaningful amount of latency when we do thousands of CDP calls to check for element position, opacity, paint order, JS event listeners, aria properties, etc.</p>
<hr/>
<hr/>
<h2>üìú A Quick History of Browser Automation</h2>
<p>To really understand why the browser automation is in the state it&#39;s in today, we have to look back at some history.</p>
<h4>The Dark Ages</h4>
<ul>
<li><strong>2011‚Äì2017</strong> ‚Äî Before headless Chrome, <strong>PhantomJS</strong> (a headless WebKit-based browser) filled the gap for scripting ‚Äúlike a browser,‚Äù with mixed reliability.</li>
<li><strong>2011</strong> ‚Äî Chrome ships <strong>remote debugging</strong>; work happens ‚Äúupstream‚Äù in WebKit so other ports can adopt it (post by Pavel Feldman).</li>
<li><strong>2012</strong> ‚Äî <strong>WebKit Remote Debugging Protocol v1.0</strong> announced; early docs/talks outline the domains/events model that CDP still uses.</li>
<li><strong>2013‚Äì2014</strong> ‚Äî Blink forks from WebKit; the protocol solidifies on the Chromium side and becomes known as the <strong>Chrome DevTools Protocol (CDP)</strong>. Extensions can tunnel it via <code>chrome.debugger</code> and <a href="https://groups.google.com/a/chromium.org/g/chromium-dev/c/arQE-vrM2OA"><code>--remote-debugging</code> flag</a>.</li>
<li><strong>2014</strong> ‚Äî Chrome‚Äôs <strong><code>chrome.automation</code></strong> (accessibility/automation) extension API appears (exposes the accessibility tree; separate from CDP).</li>
</ul>
<h4>Headless Chrome &amp; CDP Era</h4>
<ul>
<li><strong>Apr 2017</strong> ‚Äî <strong>Headless Chrome</strong> announced; <strong>Puppeteer</strong> introduced as a Chrome team Node library to drive Chrome (headless/full) via CDP.</li>
<li><strong>Jan 2018</strong> ‚Äî <strong>Puppeteer 1.0</strong> ships.</li>
<li><strong>Jun 2018</strong> ‚Äî <strong>WebDriver</strong> becomes a <strong>W3C Recommendation</strong> (cross-browser standard). <strong>ChromeDriver</strong> implements W3C WebDriver (and later BiDi) and is tightly coupled to Chrome releases.</li>
<li><strong>2019</strong> ‚Äî Google I/O talk by <strong>Andrey Lushnikov &amp; Joel Einbinder</strong> (DevTools/Puppeteer team) popularizes modern testing with Puppeteer.</li>
</ul>
<h4>Multi-Browser Standardization Era</h4>
<ul>
<li><strong>2019‚Äìearly 2020</strong> ‚Äî Several core Puppeteer engineers leave Google for Microsoft and start <strong>Playwright</strong> (cross-browser automation/test framework) üé≠ (oooo drama)</li>
<li><strong>Jan 31, 2020</strong> ‚Äî <strong>Playwright 0.x</strong> public release.</li>
<li><strong>May 6, 2020</strong> ‚Äî <strong>Playwright 1.0</strong> ships.</li>
<li><strong>Sep‚ÄìOct 2020 ‚Üí</strong> ‚Äî <strong>Multi-language</strong> support begins (e.g., Playwright for Python announced Sep 30, 2020).</li>
<li><strong>2023</strong> ‚Äî <strong>ChromeDriver</strong> adds <strong>WebDriver BiDi</strong> support (alongside classic WebDriver).</li>
<li><strong>2024</strong> ‚Äî <strong>Puppeteer</strong> adds <strong>WebDriver BiDi</strong> support; Selenium ‚Äúwelcomes Puppeteer to the WebDriver world.‚Äù</li>
</ul>
<h4>Modern Times: A Multitude of Choice</h4>
<p>Now in 2025 we are lucky to have many high quality driver libraries to choose between, our favorites include:</p>
<ul>
<li>‚≠êÔ∏è <a href="https://pydoll.tech/"><code>pydoll</code></a> (best python-first playwright replacement)</li>
<li>‚≠êÔ∏è <a href="https://github.com/go-rod/rod"><code>go-rod</code></a> (best CDP reference implementation), <a href="https://github.com/chromedp/chromedp"><code>chromedp</code></a> (great CDP debug tooling)</li>
<li><a href="https://deepwiki.com/puppeteer/puppeteer"><code>puppeteer</code></a> (best native chrome behavior), <a href="https://playwright.dev/"><code>playwright</code></a> (best cross-browser support)</li>
<li><a href="https://github.com/seleniumbase/SeleniumBase"><code>selenium</code></a>, <a href="https://github.com/cypress-io/cypress"><code>cypress</code></a> (automate with old-school WebDrivers)</li>
<li><a href="https://github.com/appium/appium"><code>appium</code></a> automate via system-level accessibility APIs on Android, iOS, macOS, Windows</li>
</ul>
<p>So why did we feel the need to write our own with <code>cdp-use</code>? Well for all the same reasons as everyone else: everlasting desire to be closer to the metal and have more detailed control over every step.</p>
<hr/>
<h2>How do Browser Drivers Work?</h2>
<blockquote>
<p>So what APIs does the browser actually expose anyway?
What sits underneath all these &#34;drivers&#34;?</p>
</blockquote>
<h3>üîå What are the automation APIs that Chromium actually exposes?</h3>
<p>All these adapter libraries, drivers, and AI helper extensions really just exist to pass messages and make RPC calls to these underlying browser APIs:</p>
<ul>
<li>
<p><strong>Chrome Extension APIs</strong></p>
<ul>
<li><code>chrome.tabs.captureVisibleTab()</code></li>
<li><code>chrome.automation.getTree()</code></li>
<li><code>chrome.scripting.executeScript()</code></li>
<li><code>chrome.debugger.sendCommand({tabId: 123}, &#34;Page.navigate&#34;, {url})</code>
<blockquote>
<p><strong>Chrome Extension APIs</strong> appear to be the most powerful at first glance because they encompass CDP with <code>chrome.debugger</code>, but raw CDP lets you access some calls that are not available through <code>chrome.debugger</code>, and allows parallel connections to multiple targets.</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p><strong>CDP APIs</strong> (via pure CDP Websocket or WebDriver BIDI socket)</p>
<ul>
<li><code>Page.navigate({url})</code></li>
<li><code>Target.createTarget()</code></li>
<li><code>Page.handleJavaScriptDialog({accept: true})</code></li>
<li><code>Browser.setDownloadBehavior()</code></li>
</ul>
</li>
<li>
<p><strong>OS-Level Accessibility &amp; screenreader APIs</strong> (NVDA/Voice Over/AppleScript/Appium/etc.)</p>
<ul>
<li>get a tree/rotor view of all elements shown to screenreaders (links, buttons, inputs, ...)</li>
<li>script copy/paste, mouse, keypress, and <a href="https://support.apple.com/guide/voiceover/by-dom-or-group-mode-vo2711/10/mac/15.0">element rotor</a>/tab-based navigation</li>
</ul>
</li>
<li>
<p><strong>Internal Chromium C++ APIs</strong> (within Chromium source code)</p>
<ul>
<li>you can call arbitrary helpers <code>content/browser/devtools/protocol/*_handler.cc</code></li>
<li>you can edit the CDP spec and add commands to call custom C++ APIs <code>third_party/blink/public/devtools_protocol/browser_protocol.pdl</code></li>
<li><em>... anything is possible when the call is coming from inside the house ...</em></li>
</ul>
</li>
</ul>
<h4>Ignoring These for Now</h4>
<ul>
<li>
<p>Classic WebDriver W3C / ChromeDriver REST APIs</p>
<ul>
<li><code>/session/{id}/url</code></li>
<li><code>/session/{id}/element/{eid}/click</code></li>
<li><code>/session/{id}/actions</code></li>
<li>... etc.
These are not actually exposed by any browser directly, rather they are the W3C standardized REST API shape recommended for drivers (ChromeDriver, GeckoDriver, WebKitDriver, selenium) to provide to clients above raw browser calls via CDP/BIDI.</li>
</ul>
</li>
<li>
<p>Webdriver BIDI (websocket)</p>
<ul>
<li>merger of the old REST-API based WebDriver system + CDP in a single websocket, official release delayed for years now, not feature complete yet. check back in 2027</li>
</ul>
</li>
</ul>
<hr/>
<h3>üé≠ How does Playwright work?</h3>
<p>Playwright achieves multi-languge support by using a client-server model between clients in various languages and a single core implementation that runs as a node.js websocket server.</p>
<p>The playwright node.js relay server accepts standardized &#34;playwright protocol&#34; RPC calls from playwright clients, and then sends out CDP or BIDI calls to the browser to execute them.</p>
<p><img alt="" src="https://docs.monadical.com/uploads/6cb9a368-da39-4444-85b6-d8619f52ba79.png"/></p>
<p>This API is elegant in some ways, the &#34;playwright protocol&#34; of commands provides a nicely typed RPC interface and standardizes behavior across languages. Playwright also nicely abstracts lower-level browser ideas like targets, frames, and sessions into simple <code>Page</code> and <code>BrowserContext</code> handles and (usually) manages to keep those handles in sync and not deadlocked across node.js, the browser, and python.</p>
<p>Unfortunately the double RPC through the node.js relay means some state inevitably drifts across the 3 places (and across three different languages and runtimes):</p>
<ul>
<li>live browser</li>
<li>playwright node.js relay process</li>
<li>python client process</li>
</ul>
<p>When a tab crashes in the browser or some operation is performed without focusing a page correctly, there are edge cases where the node.js process can hang indefinitely waiting for a browser reply, meanwhile the python client needs to send the CDP call the browser is expecting in order to proceed.
Currently we have no recourse but to kill -9 and attempt to reconnect to the browser from scratch with a new playwright instance.</p>
<p>There are numerous cases like that only crop up in 1% of cases with specific slow network conditions, but edge cases can quickly drag down overall success scores when we run thousands of steps per eval.</p>
<h4>ü©∏ Playwright&#39;s Sharp Edges</h4>
<p>The playwright happy paths usually work fine, but the devil is in the details:</p>
<ul>
<li><code>fullPage=True</code> screenshot on pages longer than <code>&gt;16,000px</code> high (reliably crashes playwright)</li>
<li><code>alert()</code>/<code>confirm()</code>/<code>onbeforeunload</code> handling</li>
<li>attempting to keyboard/mouse/dialog input without focusing a page</li>
<li>file upload &amp; download handling on remote browsers</li>
<li><code>about:*</code>, <code>chrome://*</code>, <code>chrome-error://</code>, <code>chrome-extension://</code>, PDF tab handling</li>
<li>chrome preferences and enterprise/registry configuration management</li>
<li>crashed tab handling for</li>
</ul>
<p><code>DEBUG=pw:api</code> helps but it only goes so far, at a certain point it doens&#39;t make sense to build workarounds around a relay layer that we&#39;re fighting to customize and control anyway.</p>
<p>Sometimes when you are forced to thoroughly stretch every nook and cranny of an adapter layer, you start to see the ugly truths of the underlying resource, and you no longer want the &#34;pretty version&#34; as a veil pulled over your eyes, you&#39;d rather see the ugly truth.</p>
<hr/>
<h2>üç≥ Starting From Scratch: Out of the frying pan and into the fire</h2>
<p>Delivering a reliable experience when so many of the underlying components are inherently unreliable (or actively adversarial) is a monumental engineering challenge.</p>
<p><strong>Did you know there are at least 10 different ways a tab can crash in Chrome?</strong></p>
<ul>
<li>all targets start in a briefly semi-&#34;crashed&#34;/unresponsive state while initial requests are inflight, before the main page JS thread starts</li>
<li>chrome zygote/root process can crash (slow user_data_dir/filesystem io, oom, cpu lag, etc.)</li>
<li>GPU process can crash, there&#39;s even a helpful CDP call <code>Browser.crashGpuProcess</code></li>
<li>page renderers can crash due to exceptions raised within chrome source (sigsev, oom, etc.)</li>
<li>page renderers can crash because the page exceeds allowed resources (<code>Page.crash()</code>)</li>
<li>page can spinlock/oom due to infinite loops or crypto mining in its JS main thread</li>
<li>scrolling/input/screenshot before <code>activateTarget</code> focus can crash targets (5sec delayed!)</li>
<li>handling a JS popup before activateTarget or attempting to handle it after already closing</li>
<li>parent frame navigation during child <code>onbeforeunload</code> &#34;are you sure you want to leave?&#34;</li>
<li>any of the above crashes in a nested OOPIF leading to subtle issues in the parent target</li>
</ul>
<p>Playwright handled about half of these well, and presented impassible barrier to solving the other half, so we made the call to switch. But now we&#39;re faced with the difficult challenge of solving 100% of these cases ourself.</p>
<p>We take on this challenge with glee, we&#39;d rather lose sleep thinking about these things so you can build reliable apps on top of us üí™.</p>
<hr/>
<hr/>
<h2>Case Studies: Key Changes in the Migration</h2>
<h3>New CDP-USE Library Providing Python Type Bindings</h3>
<p>A type-safe Python client generator for the Chrome DevTools Protocol (CDP). This library automatically generates Python bindings with full TypeScript-like type safety from the official CDP protocol specifications. It&#39;s only shallow type bindings, no complex logic for session management, pages, elements, etc. just 100% direct access.</p>
<blockquote>
<p>Check out the library here: <a href="https://github.com/browser-use/cdp-use">github.com/browser-use/cdp-use</a> ‚û°Ô∏è</p>
</blockquote>
<h2>New Event-Driven Architecturre</h2>
<p>We used to only update our view of the world between actions, right before sending the next state summary to the LLM. This makes sense when your assumption is that the page contents will only change as a result of actions, but this is not always true!</p>
<p>Take for example a slowly loading list of results that stream in, an animated carousel, or a bit of JS that runs every 3s. All of these are examples of things that can happen at any point in the agent action/runloop cycle.</p>
<p>We&#39;ve introduced a new event-driven architecture to better fit the underlying event-driven architecture of CDP. Now we can subscribe to and respond to CDP events, which we set up in &#34;watchdog&#34; services that monitor for various things.</p>
<p>For example, our <code>downloads_watchdog</code> watches for any file downloads that start spontaneously, whether triggered by a click, js executing, or any other method. <code>crash_watchdog.py</code> can now watch for page crashes in a single place by just subscribing to a crash event, and we no longer have to scatter crash detection and retry logic all over the rest of the codebase.</p>
<blockquote>
<p>Check out the library powering this: <a href="https://github.com/browser-use/bubus">github.com/browser-use/bubus</a> ‚û°Ô∏è</p>
</blockquote>
<h3>New Extracted Element Handle that works across OOPIFs</h3>
<p>A tab is not a page; it‚Äôs a constellation of <strong>targets</strong> (root + cross-origin iframes + workers), each hosting <strong>frames</strong>, each containing <strong>nodes</strong>. Abstract that away and you lose the ability to route input, correlate events, and re-find elements after DOM churn.</p>
<p>We now represent nodes with &#34;super-selectors&#34; that include <code>targetId</code>, <code>frameId</code>, <code>backendNodeId</code>, x/y position, and fallback selectors:</p>
<pre><code>@dataclass(frozen=True)
class EnhancedDOMTreeNode:
    target_id: str                 # which DevTools target owns the renderer
    frame_id: str                  # which frame inside that target
    backend_node_id: int           # renderer-local node handle
    frame_path: Tuple[str, ...]    # root ‚Üí ... ‚Üí leaf, useful for sanity checks
    element_index: int             # LLM-friendly stable ordinal for UX
    ...
</code></pre>
<p><strong>Minimal routing helpers</strong></p>
<pre><code>class BrowserSession:
    # caches are kept warm by watchers listening to Target.* and Page.*
    def cdp_client_for_frame(self, frame_id: str):
        target_id = self.target_id_by_frame_id(frame_id)
        return self.cdp_clients_for_target(target_id)[0]  # long-lived session

    def route_to_node(self, ref: EnhancedDOMRef):
        client = self.cdp_client_for_frame(ref.frame_id)
        return client, {&#34;session_id&#34;: self.session_id_by_frame_id(ref.frame_id)}
</code></pre>
<p>Outcome: zero guessing about who owns the node or where input should land, even with nested cross-origin iframes and DOM element shifts after actions.</p>
<hr/>
<hr/>
<h2>Time is a Flat Circle</h2>
</div></div></div>
  </body>
</html>
