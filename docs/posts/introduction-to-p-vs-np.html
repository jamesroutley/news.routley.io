<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://wesammikhail.com/2023/03/22/the-complexity-series-p1-p-vs-np/">Original</a>
    <h1>Introduction to P vs. NP</h1>
    
    <div id="readability-page-1" class="page"><div id="content">

	<section id="primary">
		<main id="main" role="main">

		
<article id="post-113">

	
	
	
	<div>

		
<p>In this series of articles I would like to share with you a set of ideas that are meant to help non-technical people build a better intuition as to what the current software and A.I. trends are all about. My intention is to keep this Complexity Series as readable and digestible by anyone regardless of their technical background.</p>
<p>In order for us to understand how the current trends came about and why the computer science community is so focused on A.I. and complex systems in general, we first need to understand the underlying problem(s) that the community is trying to address. That’s why I’ll kick this series off by introducing the topic of <strong>Computational Complexity</strong> and specifically a problem known as <strong>P vs. NP</strong>. From there, we’ll dive into the specifics of A.I. in the next chapter and what type of advancements we can expect moving forward. So let’s start this series with a fun little thought experiment.</p>

<p>Imagine the following scenario: The powers that be offer you endless amounts of money and fame if you could solve 4 simple math problems that any 12 year old gets to work on in school. There are only two caveats:</p>
<ol>
<li>You must do the calculations by hand. No calculators or external aid of any kind.</li>
<li>You have a time limit of 20 minutes to solve all 4 problems.</li>
</ol>
<p>You think to yourself: “Heck yea, why not? That sounds like a great deal. I’ll do it!!”</p>
<p><strong>Problem #1:</strong></p>
<pre><strong>Question</strong>: What is the <strong>product</strong> of 111 x 133?</pre>
<p>This took you 15 seconds to solve and check for errors. The test administrator verifies your answer and congratulates you on your success!</p>
<p><strong>Problem #2:</strong></p>
<pre><strong>Question</strong>: Which two <strong>integers</strong> (factors) multiply to produce 121? </pre>
<p>It took you 15 seconds to solve and check for errors. The test administrator verifies your answer and congratulates you on your success!</p>
<p><strong>Problem #3:</strong></p>
<pre><strong>Question</strong>: What is the <strong>product</strong> of 654151 x 943343?</pre>
<p>This took you ~3 minutes to solve and double check for errors. The test administrator once again verifies the answer and congratulates you. On to the fourth and final problem.</p>
<p><strong>Problem #4:</strong></p>
<pre><strong>Question</strong>: Which two <strong>integers</strong> (factors) multiply to produce 201863? </pre>
<p>You take a few minutes to think things through and come to the realisation that you don’t know of any easy way to solve this problem. The only thing that comes to mind is the “guess and check” method. So you grab your pen and paper and get to work:</p>
<pre>2 is not a viable factor because 201863 / 2 = 100931.5 which is not an integer.</pre>
<p>Before you know it, time is up. 20 minutes passed and you’ve unfortunately failed to generate the right answer in time. <span>So what went wrong?</span></p>
<p>For the #1st problem, multiplying two 3-digit numbers took you 15 seconds, meanwhile multiplying two 6-digit numbers in the #3rd problem took you 3 minutes. It is obviously the case that as the numbers <em>scale and grow larger</em>, more time and work/effort is required to solve them. But even then, 3 minutes was a pretty decent time.</p>
<p>For problems #2 and #4, going from 3-digit number (121) to a 6-digit number (201863) resulted in a much bigger increase in the amount of work/effort required. This is because while these two problems, multiplication and factorization, may seem similar, they are actually very very different in nature.</p>

<p>In the early days of computing, scientists were busy grouping problems by their scaling difficulty. Some problems, like multiplication, seemed to have algorithms (like the ones you learn in school) that we’ve discovered to solve for them in a relatively short amount of time. As the number of digits grows and the problem gets harder, our algorithms seem to keep up. Other problems, like factorization, seem to elude us. In spite of our best efforts, we can’t figure out good algorithms for solving them quickly.</p>
<p>So, in order to formalise these observations and get a better handle on the situation, computer scientists and mathematicians created <strong>classes</strong> (buckets) of problems. When we encounter a computational problem, we look at how difficult it is to solve at scale, and based on that difficulty we place it into one of the classes/buckets. Initially the following classes were created:</p>
<p><img loading="lazy" data-attachment-id="399" data-permalink="https://wesammikhail.com/2023/03/22/the-complexity-series-p1-p-vs-np/zyikc6o1/" data-orig-file="https://wesammikhail.files.wordpress.com/2023/03/zyikc6o1.png" data-orig-size="350,106" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="zYIkC6O[1]" data-image-description="" data-image-caption="" data-medium-file="https://wesammikhail.files.wordpress.com/2023/03/zyikc6o1.png?w=300" data-large-file="https://wesammikhail.files.wordpress.com/2023/03/zyikc6o1.png?w=350" src="https://wesammikhail.files.wordpress.com/2023/03/zyikc6o1.png" alt="zYIkC6O[1]" width="350" height="106" srcset="https://wesammikhail.files.wordpress.com/2023/03/zyikc6o1.png 350w, https://wesammikhail.files.wordpress.com/2023/03/zyikc6o1.png?w=150&amp;h=45 150w, https://wesammikhail.files.wordpress.com/2023/03/zyikc6o1.png?w=300&amp;h=91 300w" sizes="(max-width: 350px) 100vw, 350px"/></p>
<p><strong>Verifiability</strong>, the act of being able to prove the correctness of an answer, turned out to be just as important as being able to generate the answer itself. If I were to ask you what the product of <strong>111 x 133</strong> is, you could compute that in a short period of time as you did in Problem #1. The test administrator verified your answer by doing that same multiplication and compared the results in order to check for mistakes. That’s exactly what all techers do for their students;  They compute and compare in order to verify.<em> The fact that the multiplication problem is so easily solvable is what also made it possible for the test administrator to check your solution for mistakes</em>.</p>
<p>In the #4th problem however (factoring 201863), it took you a long time and you still did not manage to produce a solution. Yet, if I were to tell you that <strong>201863</strong> has the factors <strong>337</strong> and<strong> 599</strong>, you could easily check my work by multiplying the two factors to see if they actually produce the right number. In other words, <em>for the factorization problem, checking an answer for errors is easier than finding the two numbers</em>. This is the difference between P and NP.</p>
<p><strong>P</strong> is a class of problems that are <strong>easy to solve </strong>and <strong>easy to verify</strong>. For the sake of simplicity we can define “easiness” as: being solvable in a <a href="https://en.wikipedia.org/wiki/P_(complexity)" target="_blank" rel="noopener">reasonable amount of time</a>.</p>
<p><strong>NP</strong><span>, on the other hand, is a class of problems that are <strong>hard to solve</strong> yet <strong>easy to verify</strong>.</span></p>
<p><strong>EXP </strong>is a class of problems that are <strong>hard to solve </strong>and <strong>hard to verify. </strong>A classic example of an EXP problem would be a generic chess game. Think of a randomly generated chess board configuration with pieces all over the place, what’s the best move to make there? What algorithm do you even use to find out what the best move is? How can you even verify the correctness of any given suggestion?</p>
<p>It all boils down to <strong>scale</strong>. As you scale things up (in our math test we scaled the number of digits), certain problems grow much faster in difficulty than others and quickly become out of reach. And while we’re currently discussing algorithms and math questions, the same actually applies for any given problem we might face. <em>Cooking dinner for two people is not the same as running a restaurant – even though the act of cooking might be the same.</em> Scale is, and will always be, the fundamental challenge we have to overcome when solving important <em>generalised</em> problems of any kind.</p>
<p>Every decade or so we come across an algorithm that takes a problem from the NP domain to the P domain. This happens because some clever person makes a breakthrough that solves that problem much faster than we previously thought was possible. So the question now remains: <strong>is every NP-problem a P-problem in hiding? or are these classes fundamentally different and NP problems will forever be hard to solve? </strong></p>

<p>There is a whole host of <a href="https://en.wikipedia.org/wiki/List_of_NP-complete_problems" target="_blank" rel="noopener">problems in NP</a> that are extremely important for us to solve. They range from problems in <a href="https://en.wikipedia.org/wiki/RSA_(cryptosystem)" target="_blank" rel="noopener">encryption/security</a> and <a href="https://jcrouser.github.io/CSC250/projects/bitcoin.html" target="_blank" rel="noopener">cryptocurrency mining</a> to computational biology (ex. cancer research) and language. A subset of these problems are known as <strong>NP-Complete</strong>. That means that finding a solution that lets us solve any <strong>one</strong> of those problems will immediately help us solve <strong>all</strong> of them.</p>
<p>An example of this would be if you can find a fast algorithm for playing an N x N size <a href="https://en.wikipedia.org/wiki/Sudoku" target="_blank" rel="noopener">sudoku</a> (yes sudoku the game an NP problem), you’ve essentially rendered most online encryption systems completely useless because those are based on NP problems as well. You can use that sudoku algorithm to break into peoples’ bank accounts. You can apply that solution to the <a href="https://en.wikipedia.org/wiki/Protein_folding" target="_blank" rel="noopener">protein folding problem</a> which could help us find cures for diseases and thereby extending the average human lifespan. Heck, you could even use that algorithm to cause a lot of global political turmoil if you wanted to.</p>
<p>This is why the<strong> P vs NP</strong> question is so important. Hard to solve problems (NP/EXP/etc.) are the next frontier for us to conquer. <span><strong>Artificial Intelligence systems are actually nothing more than a way for us to try to approximate solutions for these hard to solve problems</strong>. And while A.I. may at first glance seem unrelated to the P vs NP problem, nothing could be further from the truth.</span></p>
<p>This first article was meant to set the stage. In part 2 of this series I’ll be diving into A.I. specifically and why what you’re seeing should both terrify as well as excite you. So stay tuned for the next one!</p>
<p>In the meantime, here is a phenomenal video for those of you that would like to learn more about P vs NP.</p>


<figure><p><span><iframe width="840" height="473" src="https://www.youtube.com/embed/YX40hbAHx3s?version=3&amp;rel=1&amp;showsearch=0&amp;showinfo=1&amp;iv_load_policy=1&amp;fs=1&amp;hl=en&amp;autohide=2&amp;wmode=transparent" allowfullscreen="true" sandbox="allow-scripts allow-same-origin allow-popups allow-presentation"></iframe></span>
</p></figure>

		
	</div><!-- .entry-content -->

	<!-- .entry-footer -->

</article>

	<!-- #comments -->


		</main><!-- #main -->
	</section><!-- #primary -->

	
	<!-- #secondary -->



	</div></div>
  </body>
</html>
