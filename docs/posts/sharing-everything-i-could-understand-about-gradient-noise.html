<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.pkh.me/p/42-sharing-everything-i-could-understand-about-gradient-noise.html">Original</a>
    <h1>Sharing everything I could understand about gradient noise</h1>
    
    <div id="readability-page-1" class="page"><article><p>You&#39;ve most likely heard about <strong>gradient noise</strong> through the name <em>Perlin
noise</em>, which refers to one particular implementation with various CPU
optimizations. Because it&#39;s an incredible tool for creative work, it&#39;s used
virtually everywhere: visual effects, video games, procedural mathematical art,
etc. While getting it right can sometimes be subtle, a &#34;broken&#34; implementation
can still look good or interesting. After all, &#34;it looks fine, and I&#39;m an
artist&#34;.</p>
<p>In order to gain a deeper and more meaningful understanding we will start
studying the 1D version (a case often omitted in the literature), then slowly
climb our way up in dimensions and complexity. We&#39;ll also work from a GPU
perspective rather than a CPU-based one, hence all code snippets and visuals
here are implemented in WebGL2/GLSL (hopefully without being too heavy on
performance). They should run on most modern devices; let me know if you run
into issues.</p>
<p>Before we begin, credit where it&#39;s due: most of the material here are nothing
new. This article is the result of weeks of studying and experimenting with
the maths from <a href="https://iquilezles.org/articles/">Inigo Quilez&#39;s incredible pages</a> and other scattered
resources over the Internet. But as rich and valuable these resources are, they
sometimes move quickly over the details, assuming they&#39;re obvious. This post is
an attempt to fill those gaps.</p>
<figure>
  <canvas width="600" height="140" data-fragment="/frag/noise/intro.frag"></canvas>
  <figcaption>A welcoming wavy 1D gradient noise signal</figcaption>
</figure>
<h2>Hashing function and pseudo-random values</h2>
<p>At the most elementary level, we need a deterministic coordinate based
pseudo-random system. More specifically, for any given integer coordinate we
need a random value, and as uniformly distributed as possible. Something like:</p>
<p>
\begin{aligned}
h(-3) &amp;= -0.006124 \\
h(-2) &amp;= -0.996686 \\
h(-1) &amp;= 0.200864 \\
h(0) &amp;= -1.000000 \\
h(1) &amp;= 0.053313 \\
h(2) &amp;= -0.893312 \\
h(3) &amp;= 0.854923 \\
\text{...}
\end{aligned}
</p>
<p>Perlin&#39;s implementation relies on a permutation table, which is convenient when
working on the CPU, but more awkward for a shader. On the GPU, most people rely
on various floating point hacks or sub-optimal bit tricks, which often fall
short when exploring the full 32-bit range of inputs.</p>
<div>
<p>Note</p>
<p>We can not use a PRNG because it relies on a state where we need determinism
(for one coordinate, we always want the same random value). LCG (Linear
Congruential Generator) are a sub-classes of PRNG where the state is
actually the returned value. But even then, we can not re-use the previously
returned value since we need seeking; that is the ability to get the random
value associated with our integer coordinate. Trying to feed a PRNG/LCG with
our coordinate instead of the expected state would be equivalent to changing
the seed at every call, and this may create an important bias in the random
distribution. This is the reason why we need integer hashing instead.</p>
</div>
<p>So we need a hashing function, and we will have to limit ourselves to
32-bit because we&#39;re on the GPU. Fortunately, we won&#39;t have to look for
very long because in 2018 <a href="https://nullprogram.com/blog/2018/07/31/">Chris Wellons found a pretty good one he named
lowbias32</a>, which was later <a href="https://github.com/skeeto/hash-prospector/issues/19#issuecomment-1120105785">refined by TheIronBorn</a>.</p>
<p>This is the first building block we will be using, the hashing function:</p>
<pre><code>uint hash(uint x) {
    x = (x ^ (x &gt;&gt; 16)) * 0x21f0aaadU;
    x = (x ^ (x &gt;&gt; 15)) * 0x735a2d97U;
    return x ^ (x &gt;&gt; 15);
}
</code></pre>
<p>This is sweet and all, but a 32-bit unsigned integer is not directly useful by
itself, we need a normalized float. We could naively divide by <code>0xffffffff</code>,
but we&#39;ll end up with a nonuniform distribution (this is not as important as it
may sound to be honest). Instead, we will adapt the <a href="https://prng.di.unimi.it/">technique presented by
Vigna Sebastiano for doubles</a> to floats, and in GLSL:</p>
<pre><code>float u2f(uint x) { return float(x &gt;&gt; 8U) * uintBitsToFloat(0x33800000U); }
</code></pre>
<p>Combining these two functions into <code>u2f(hash(x))</code> maps any 32-bit
coordinate <span>x</span> to a random float in <span>[0,1)</span>.</p>
<p>To match our <span>h(x)</span> function from earlier and make it more &#34;signal-like&#34;, we can
optionally center it around <span>0</span> by remapping it from <span>[0,1)</span> to <span>[-1,1)</span>:
<code>h(x)=u2f(hash(x))*2.0-1.0</code>.</p>
<h2>Expanding the hash function to more dimensions</h2>
<p>When we will work in 2 or more dimensions, our input grid coordinates will be
more than one value, but we need a way to feed them to our single parameter hash
function. One trick is to use nested xor hash:</p>
<pre><code>uint hash(uvec2 x) { return hash(x.x ^ hash(x.y)); }  // for 2D input
uint hash(uvec3 x) { return hash(x.x ^ hash(x.yz)); } // for 3D input
</code></pre>
<p>Using the pixel coordinates as input, we can test the hashing function in 2D:</p>
<pre><code>float stepnoise2(vec2 p) {
    ivec2 i = ivec2(floor(p));    // integer coordinate, or lattice
    return u2f(hash(uvec2(i)));   // non-centered h(x)
}
</code></pre>
<figure>
  <canvas width="600" height="300" data-fragment="/frag/noise/stepnoise2.frag"></canvas>
  <figcaption>Display h(x,y) by stepping the contiguous coordinates</figcaption>
</figure>
<div>
<p>Warning</p>
<p>We&#39;re going through an intermediate signed integer conversion before going
to unsigned to avoid issues with negative coordinates. Quoting GLSL 4.60
specifications: &#34;It is undefined to convert a negative floating-point value
to an uint&#34;. With this conversion we will only have a problem when the
coordinates go outside the signed 32-bit range.</p>
</div>
<h2>Basic signal and white noise</h2>
<p>Aside from stepping, we can also assign values to the integer coordinates only
and interpolate linearly between them. Let&#39;s try this in 1D:</p>
<pre><code>float value(int x) { return u2f(hash(uint(x)))*2.0 - 1.0; } // h(x)

float vnoise1_linear(float p) {
    int i = int(floor(p));                // integer coordinate, or lattice
    float f = fract(p);                   // x-position between the 2 surrounding values
    return mix(value(i), value(i+1), f);  // linear interpolation between the two
}
</code></pre>
<p>Feeding this function with the x-axis coordinate, we get the amplitude (height)
of the signal:</p>
<figure>
  <canvas width="600" height="150" data-fragment="/frag/noise/vnoise1_linear.frag"></canvas>
  <figcaption>Basic 1D value noise with linear interpolation</figcaption>
</figure>
<div>
<p>Note</p>
<p>This might not be obvious yet, but the beauty of this is that this
&#34;<strong>infinite</strong>&#34; signal is <strong>deterministic</strong> and thus <strong>seekable</strong>. Indeed,
we can move forward and backward to any real position <span>p</span> and instantly know
how the signal looks like. This is essential for <strong>procedural</strong> programming.</p>
</div>
<p>But the linear interpolation is usually not that great for a signal, so instead
of a straight line we will use a smooth fade. The two commonly used functions
are:</p>
<ul>
<li>The <strong>cubic Hermite curve</strong>, <span>f(t)=3t^2-2t^3</span> (also used in GLSL
<code>smoothstep()</code>) initially used by Ken Perlin in his first Perlin Noise
implementation.</li>
<li>The more modern (and complex) <strong>quintic curve</strong> <span>f(t)=6t^5-15t^4+10t^3</span>
introduced in 2002 by Ken Perlin in his proposed improved version of the
Perlin Noise, in order to address discontinuities in the 2nd order derivatives
<span>f&#34;(t)</span>.</li>
</ul>
<p>For the record, in GLSL:</p>
<pre><code>float fade_quintic(float t) { return ((6.0*t-15.0)*t+10.0)*t*t*t; }
float fade_hermite(float t) { return (3.0-2.0*t)*t*t; }
</code></pre>
<p>We will stick with the quintic for the rest of the article:</p>
<pre><code>#define fade fade_quintic

float vnoise1(float p) {
    int i = int(floor(p));
    float f = fract(p);
    float a = fade(f);
    return mix(value(i), value(i+1), a);
}
</code></pre>
<figure>
  <canvas width="600" height="150" data-fragment="/frag/noise/vnoise1.frag"></canvas>
  <figcaption>1D value noise with quintic interpolation as fading function</figcaption>
</figure>
<h2>1D gradient noise</h2>
<p>Still, a signal generated in such a way may not be desirable due to the abrupt
changes in slope/frequency; it is too &#34;unstable&#34;. So instead of using the
random as noise values directly, we <strong>interpret them as gradient</strong>: this is the
<em>gradient noise</em>.</p>
<figure>
  <canvas width="600" height="300" data-fragment="/frag/noise/gnoise1dancing.frag"></canvas>
  <figcaption>How the gradient values affects the signal shape</figcaption>
</figure>
<div>
<p>Note</p>
<p>If we&#39;re pedantic, in 1D they can&#39;t exactly be called gradients, we should
use the term <em>slopes</em>, or <em>angles</em>. But we will still do it for consistency
with 2 and more dimensions.</p>
</div>
<p>For each lattice, we decide to give them <span>y=0</span> at regular interval, and have
their random gradient impacts the surrounding curve. This may sound complicated
to implement but in practice it&#39;s 2 multiplications and 1 subtraction more than
the value noise (for 1D at least):</p>
<pre><code>float grad(int x) { // int lattice to random [-1,1)
    return u2f(hash(uint(x))) * 2.0 - 1.0;
}

float noise1(float p) {
    int i = int(floor(p));
    float g0 = grad(i);
    float g1 = grad(i + 1);

    float f = fract(p);
    float v0 = g0 * f;
    float v1 = g1 * (f - 1.0);

    float a = fade(f);
    return mix(v0, v1, a);
}
</code></pre>
<figure>
  <canvas width="600" height="300" data-fragment="/frag/noise/gnoise1dbg.frag"></canvas>
  <figcaption>1D gradient noise with slope indicators on the lattice coordinates</figcaption>
</figure>
<p>Geometrically speaking, <span>v_0</span> and <span>v_1</span> are y-coordinates obtained by extending
the 2 slopes (the little sticks at each lattice) around our current target
point <span>p</span> and finding where the vertical line <span>x=p</span> intersects them.
Then we smoothly interpolate between them using our fade function.</p>
<div>
<p>Note</p>
<p>One important property of the gradient noise is that it passes through <span>0</span>
at every lattice, meaning at a constant rate. In other words,
<span>\textbf{noise}_1(p)=0</span> whenever <span>p</span> is an integer.</p>
</div>
<h2>Expanding to 2 dimensions</h2>
<p>In 2D, each lattice point stores a 2-component gradient vector. To evaluate
noise at a point <span>p=(x,y)</span>, instead of a simple multiplication we compute the
dot product of each gradient vector with the vector from the lattice corner
to <span>(x,y)</span>, then <strong>bilinearly interpolate</strong> those four dot products using a 2D
fade function.</p>
<pre><code>#define bmix(a,b,c,d,x,y) mix(mix(a,b,x),mix(c,d,x),y) // bilinear interpolation

float noise2(vec2 p) {
    ivec2 i = ivec2(floor(p));
    vec2 g0 = grad(i);
    vec2 g1 = grad(i + ivec2(1, 0));
    vec2 g2 = grad(i + ivec2(0, 1));
    vec2 g3 = grad(i + ivec2(1, 1));

    vec2 f = fract(p);
    float v0 = dot(g0, f);
    float v1 = dot(g1, f - vec2(1.0, 0.0));
    float v2 = dot(g2, f - vec2(0.0, 1.0));
    float v3 = dot(g3, f - vec2(1.0, 1.0));

    vec2 a = fade(f);
    return bmix(v0, v1, v2, v3, a.x, a.y);
}
</code></pre>
<p>Since gradients are now in 2D, the random gradient function needs to be
extended: we need <strong>a normalized vector generator</strong>, that is something that
gives us a unit vector pointing in any direction.</p>
<p>A first solution would be to call the hash function twice (on itself typically)
to obtain random <span>(x,y)</span> coordinates in a square, that we then normalize to get
them on a circle:</p>
<pre><code>vec2 grad(ivec2 x) { // ivec2 lattice to random 2D unit vector (normalized square point)
    uint h1 = hash(uvec2(x));
    uint h2 = hash(h1);
    return normalize(vec2(u2f(h1), u2f(h2)) * 2.0 - 1.0);
}
</code></pre>
<p>But we can do better with only one hash and some trigonometry:</p>
<pre><code>const float TAU = 6.283185307179586;

vec2 grad(ivec2 x) { // ivec2 lattice to random 2D unit vector (circle point)
    float angle = u2f(hash(uvec2(x))) * TAU;
    return vec2(cos(angle), sin(angle));
}
</code></pre>
<p>And this is enough to get our 2D gradient noise:</p>
<figure>
  <canvas width="600" height="300" data-fragment="/frag/noise/gnoise2.frag"></canvas>
  <figcaption>2D gradient noise (with y-axis coordinates that cover -10 to 10)</figcaption>
</figure>
<h2>Expanding to 3 dimensions</h2>
<p>Similarly, for 3D gradient noise we will need these 2 changes:</p>
<ol>
<li>The interpolation happens between the 8 points of a cube: it&#39;s a <strong>trilinear
interpolation</strong>, a combination of 2 bilinear interpolations (itself being a
combination of 3 linear interpolations)</li>
<li>The random unit vectors used as gradients need to be distributed evenly on a
<strong>sphere</strong> instead of circle since we are working in 3D</li>
</ol>
<pre><code>vec3 grad(ivec3 x) { // ivec3 lattice to random 3D unit vector (sphere point)
    uint h0 = hash(uvec3(x));
    uint h1 = hash(h0);
    float theta = acos(2.0*u2f(h0) - 1.0); // use the first random for the polar angle (latitude)
    float phi = TAU * u2f(h1); // use the 2nd random for the azimuth (longitude)
    return vec3(cos(phi) * sin(theta), sin(phi) * sin(theta), cos(theta));
}

#define tmix(a,b,c,d,e,f,g,h,x,y,z) mix(bmix(a,b,c,d,x,y),bmix(e,f,g,h,x,y),z) // trilinear interpolation

float noise3(vec3 p) {
    ivec3 i = ivec3(floor(p));
    vec3 g0 = grad(i);
    vec3 g1 = grad(i + ivec3(1, 0, 0));
    vec3 g2 = grad(i + ivec3(0, 1, 0));
    vec3 g3 = grad(i + ivec3(1, 1, 0));
    vec3 g4 = grad(i + ivec3(0, 0, 1));
    vec3 g5 = grad(i + ivec3(1, 0, 1));
    vec3 g6 = grad(i + ivec3(0, 1, 1));
    vec3 g7 = grad(i + ivec3(1, 1, 1));

    vec3 f = fract(p);
    float v0 = dot(g0, f);
    float v1 = dot(g1, f - vec3(1, 0, 0));
    float v2 = dot(g2, f - vec3(0, 1, 0));
    float v3 = dot(g3, f - vec3(1, 1, 0));
    float v4 = dot(g4, f - vec3(0, 0, 1));
    float v5 = dot(g5, f - vec3(1, 0, 1));
    float v6 = dot(g6, f - vec3(0, 1, 1));
    float v7 = dot(g7, f - vec3(1, 1, 1));

    vec3 a = fade(f);
    return tmix(v0, v1, v2, v3, v4, v5, v6, v7, a.x, a.y, a.z);
}
</code></pre>
<figure>
  <canvas width="600" height="300" data-fragment="/frag/noise/gnoise3.frag"></canvas>
  <figcaption>3D gradient noise on a sphere (with 10x unzoom)</figcaption>
</figure>
<div>
<p>Note</p>
<p>The spherical representation has nothing to do with the selection of a
random 3D unit vector on a sphere. The noise in this implementation applies
to any 3D geometry. The choice of a sphere for the display was just a simple
3D shape to lay it on. If we were in 2D we could also feed the 3d noise
function with <span>p=(x,y,t)</span> where <span>t</span> is the current time, giving us a
&#34;cloudy&#34; atmospheric rendering.</p>
</div>
<p>The random gradient in 3D is starting to be a bit expensive with all the
trigonometry, so we may consider simpler approaches, like normalizing a
random position in a cube, similar to what we&#39;ve initially suggested for 2D
noise. From my observation, it doesn&#39;t seem to have any noticeable impact
visually, but maybe it would have under certain circumstances.</p>
<h2>Fractal Brownian Motion (fBm)</h2>
<p>The idea behind fBm is to sum multiple &#34;octaves&#34; of noise together to construct
a more refined pattern. In the most common cases, we would raise the frequency
by doubling it (called a &#34;lacunarity&#34; factor), and halving the amplitude (called
a &#34;gain&#34; or &#34;persistence&#34; factor):</p>
<figure>
  <canvas width="600" height="600" data-fragment="/frag/noise/gnoise1multi.frag"></canvas>
  <figcaption>Multiple signals</figcaption>
</figure>
<p>The algorithm is pretty much the same in all dimensions, it&#39;s simply a sum of
signals. In 2D for example we can write:</p>
<pre><code>const float LACUNARITY = 1.98;
const float GAIN = 0.51;

float fbm(vec2 p, int octaves) {
    float sum = 0.0;
    float amp = 1.0, freq = 1.0;
    for (int i = 0; i &lt; octaves; i++) {
        sum += amp * noise2(p * freq);
        freq *= LACUNARITY;
        amp *= GAIN;
    }
    return sum;
}
</code></pre>
<figure>
  <canvas width="600" height="300" data-fragment="/frag/noise/gnoise2fbm.frag"></canvas>
  <figcaption>2D gradient noise with 5 octaves (with y-axis coordinates that cover -2.5 to 2.5)</figcaption>
</figure>
<div>
<p>Note</p>
<p>We&#39;re not using exactly 2.0 and 0.5 for lacunarity and gain to break
correlations.</p>
</div>
<p>And in 3D for completeness (aside from the raytracer to get a sphere, the noise
code is the same, it just calls <code>noise3(p*freq)</code> and uses a <code>vec3 p</code> input):</p>
<figure>
  <canvas width="600" height="300" data-fragment="/frag/noise/gnoise3fbm.frag"></canvas>
  <figcaption>3D gradient noise with 5 octaves</figcaption>
</figure>
<h2>Derivatives</h2>
<p>Derivatives (that is the rate of change of the signal) are useful in many
situations. For example, you may have noticed that the 1D signals in this
article tend to have a lighter color when the slope is steep compared to when
it&#39;s flatter: the derivative is used to interpolate between the 2 colors.</p>
<p>Also in 1D case, to display the curve with correct thickness, I&#39;m also using
the derivatives for <a href="https://iquilezles.org/articles/distance/">Inigo&#39;s distance to curve trick</a>):</p>
<pre><code>float dist = abs(v - p.y) / sqrt(1.0 + d*d); // v: curve value, p: position, d: derivative of curve
</code></pre>
<p>Using this signed distance like any other, we can display the curve smoothly:</p>
<figure>
  <canvas width="600" height="150" data-fragment="/frag/noise/gnoise1.frag"></canvas>
  <figcaption>1D gradient noise</figcaption>
</figure>
<p>In higher dimension, we may want to use them to get some lightning: indeed,
with the derivatives we can compute the normal, which is then used for
reflections:</p>
<pre><code>// Lambertian lighting hack
vec3 normal = normalize(vec3(-d, 1.0)); // normal from the 2D partial derivatives d
float a = 5.0*TAU/8.0; // light from south-west
vec3 light_direction = normalize(vec3(cos(a), sin(a), 2.0));
float lighting = max(dot(normal, light_direction), 0.0);
col *= lighting;
</code></pre>
<figure>
  <canvas width="600" height="300" data-fragment="/frag/noise/gnoise2light.frag"></canvas>
  <figcaption>2D gradient noise with (right) and without (left) lightning</figcaption>
</figure>
<p>If you&#39;re into terrain generation, another use case is to <a href="https://iquilezles.org/articles/morenoise/">fake
erosion</a> by scaling the value of each noise layer of the fBm by
<span>\frac{1}{1+\|\sum_{i=0}^{octaves}d_i\|^2}</span>.</p>
<pre><code>float fbm2e(vec2 p) {
    float sum = 0.0;
    float amp = 1.0, freq = 1.0;
    vec2 d = vec2(0.0);
    for (int i = 0; i &lt; octaves; i++) {
        vec3 n = noise2d(p * freq);    // adjusted noise2() returning the partial derivatives in .xy
        d += n.xy;                     // cumulated derivatives without frequency scaling
        float w = 1.0/(1.0+dot(d,d));  // gradient/slope based weight
        sum += amp * n.z * w;          // value damped down by the weight
        freq *= LACUNARITY;
        amp *= GAIN;
    }
    return sum;
}
</code></pre>
<figure>
  <canvas width="600" height="300" data-fragment="/frag/noise/gnoise2erosion.frag"></canvas>
  <figcaption>2D gradient noise with (right) and without (left) erosion</figcaption>
</figure>
<p>The intuitive idea behind the formula here is that each new layer get &#34;muted&#34;
when the gradients indicate a steep mountain, preventing them from being
&#34;rugged&#34; more by higher frequency noises, and thus giving a sharper feel.</p>
<p>Anyway, these are random things we can do with the derivatives, but there are
likely others I&#39;m forgetting. The point is, they are particularly useful so
we&#39;re going to study them.</p>
<h3>Numerical vs analytical derivatives</h3>
<p>We have two methods to get the derivatives:</p>
<ol>
<li>The <strong>numerical</strong> method, where we compute the rate of change between 2 close
points. It &#34;works&#34; with all curves (given enough precision to work with), but it
has an accuracy (and sometimes speed) issue.</li>
<li>The <strong>analytical</strong> method, where we derive the exact mathematical formula.</li>
</ol>
<p>The numerical method can be implemented on the GPU thanks to the <code>dFdx</code> and
<code>dFdy</code> functions. These functions use the local and the neighbor fragments data
to calculate a derivative of the specified value. It&#39;s one of the rare function
that communicate information cross-fragment, and as you can guess it requires
synchronization and thus has performance implications.</p>
<p>But for example, let&#39;s say we take our last 2D noise scene and compare the
numerical vs the analytical derivatives:</p>
<figure>
  <canvas width="600" height="300" data-fragment="/frag/noise/gnoise2fbmderiv.frag"></canvas>
  <figcaption>2D gradient noise with their derivatives (both analytical and numerical)</figcaption>
</figure>
<p>On the left we have our standard 2D gradient fBm noise, and on the right the
length of the derivatives of the noise: first the analytical version, then the
numerical one. The latter should appear pixelized.</p>
<h3>Numerical derivatives</h3>
<p>The numerical derivatives were obtained with the following:</p>
<pre><code>float w = 2.0/resolution.y;           // size of a pixel
float v = noise2(p);                  // noise value at position p
vec2 d = vec2(dFdx(v), dFdy(v)) / w;  // numerical partial derivatives
</code></pre>
<div>
<p>Note</p>
<p>It is also possible to derive numerically ourselves with finite differences,
sampling the noise function for the neighbor positions within the same
fragment, but this is going to be extremely expensive.</p>
</div>
<h3>Analytical derivatives</h3>
<p>To get the analytical derivatives we need to combine multiple derivatives found
in the noise functions, starting from the fading function derivative. This one
is easy:</p>
<p>
\begin{aligned}
\mathrm{fade}(t)  &amp;= 6t^5-15t^4+10t^3 \\
\mathrm{fade}&#39;(t) &amp;= 30t^2(t^2-2t+1)
\end{aligned}
</p>
<p>But we will also need the derivatives of the interpolation functions for each
dimension:</p>
<ol>
<li>lerp: <span>\mathrm{mix}(a,b,x) = (1-x)a + bx</span></li>
<li>bilerp: <span>\mathrm{bmix}(a,b,c,d,x,y) = \mathrm{mix}(\mathrm{mix}(a,b,x),\mathrm{mix}(c,d,x),y)</span></li>
<li>trilerp: <span>\mathrm{tmix}(a,b,c,d,e,f,g,h,x,y,z) = \mathrm{mix}(\mathrm{bmix}(a,b,c,d,x,y),\mathrm{bmix}(e,f,g,h,x,y),z)</span></li>
</ol>
<p>So here they are:</p>
<ol>
<li><span>\partial_x\mathrm{mix}=b-a</span></li>
<li><span>\nabla\mathrm{bmix}=\mathrm{mix}(\begin{bmatrix}b\\c\end{bmatrix}-a,d-\begin{bmatrix}c\\b\end{bmatrix},\begin{bmatrix}y\\x\end{bmatrix})</span></li>
<li><span>\nabla\mathrm{tmix}=\mathrm{bmix}(\begin{bmatrix}b\\c\\e\end{bmatrix}-a,\begin{bmatrix}d-c\\d-b\\f-b\end{bmatrix},\begin{bmatrix}f-e\\g-e\\g-c\end{bmatrix},h-\begin{bmatrix}g\\f\\d\end{bmatrix},\begin{bmatrix}y\\x\\x\end{bmatrix},\begin{bmatrix}z\\z\\y\end{bmatrix})</span></li>
</ol>
<p>Following is a proof for bilinear and trilinear interpolation function partial
derivatives, you can skip them if you&#39;re not into nasty orgy of math symbols.</p>
<div>
<p>Note</p>
<p>I&#39;m introducing a new notation for the partial derivatives with values
because the usual ones are awful to make and read. An example is better than a
long explanation, so instead of something like
<span>\frac{\partial_f(x,y,z)}{\partial_x}(17,u+v,v^2)</span> or its horrendous
vertical bar version, I will instead use: <span>\partial_xf(x=17,y=u+v,z=v^2)</span></p>
</div>
<p>
\begin{aligned}
\partial_x\mathrm{bmix} &amp;= \partial_a\mathrm{mix}\cdot\partial_x\mathrm{mix} + \partial_b\mathrm{mix}\cdot\partial_x\mathrm{mix} \\
                        &amp;= \partial_a\mathrm{mix}(a=\mathrm{mix}(a,b,x),b=\mathrm{mix}(c,d,x),x=y) \cdot \partial_x\mathrm{mix}(a=a,b=b,x=x) \\
                        &amp;+ \partial_b\mathrm{mix}(a=\mathrm{mix}(a,b,x),b=\mathrm{mix}(c,d,x),x=y) \cdot \partial_x\mathrm{mix}(a=c,b=d,x=x) \\
                        &amp;= (1-y)(b-a) + y(d-c) \\
                        &amp;= \boxed{\mathrm{mix}(b-a,d-c,y)} \\
\\
\partial_y\mathrm{bmix} &amp;= \partial_x\mathrm{mix}_0(a=\mathrm{mix}(a,b,x), b=\mathrm{mix}(c,d,x), x=y) \\
                        &amp;= \mathrm{mix}(c,d,x) - \mathrm{mix}(a,b,x) \\
                        &amp;= \boxed{\mathrm{mix}(c-a,d-b,x)} \\
\\
\partial_x \mathrm{tmix} &amp;= \partial_a\mathrm{mix}\cdot\partial_x\mathrm{bmix} + \partial_b\mathrm{mix}\cdot\partial_x\mathrm{bmix} \\
                         &amp;= \partial_a\mathrm{mix}(a=\mathrm{bmix}(a,b,c,d,x,y),b=\mathrm{bmix}(e,f,g,h,x,y),z) \\
                         &amp;\cdot \partial_x\mathrm{bmix}(a=a,b=b,c=c,d=d,x=x,y=y) \\
                         &amp;+ \partial_b\mathrm{mix}(a=\mathrm{bmix}(a,b,c,d,x,y),b=\mathrm{bmix}(e,f,g,h,x,y),z) \\
                         &amp;\cdot \partial_x\mathrm{bmix}(a=e,b=f,c=g,d=h,x=x,y=y) \\
                         &amp;= (1-z)\mathrm{mix}(b-a,d-c,y) + z\mathrm{mix}(f-e,h-g,y) \\
                         &amp;= \mathrm{mix}(\mathrm{mix}(b-a,d-c,y), z\mathrm{mix}(f-e,h-g,y), z) \\
                         &amp;= \boxed{\mathrm{bmix}(b-a,d-c,f-e,h-g,y,z)} \\
\\
\partial_y \mathrm{tmix} &amp;= \partial_a\mathrm{mix}\cdot\partial_y\mathrm{bmix} + \partial_b\mathrm{mix}\cdot\partial_y\mathrm{bmix} \\
                         &amp;= \partial_a\mathrm{mix}(a=\mathrm{bmix}(a,b,c,d,x,y),b=\mathrm{bmix}(e,f,g,h,x,y),z) \\
                         &amp;\cdot \partial_y\mathrm{bmix}(a=a,b=b,c=c,d=d,x=x,y=y) \\
                         &amp;+ \partial_b\mathrm{mix}(a=\mathrm{bmix}(a,b,c,d,x,y),b=\mathrm{bmix}(e,f,g,h,x,y),z) \\
                         &amp;\cdot \partial_y\mathrm{bmix}(a=e,b=f,c=g,d=h,x=x,y=y) \\
                         &amp;= (1-z)\mathrm{mix}(c-a,d-b,x) + z\mathrm{mix}(g-e,h-f,x) \\
                         &amp;= \mathrm{mix}(\mathrm{mix}(c-a,d-b,x), z\mathrm{mix}(g-e,h-f,x), z) \\
                         &amp;= \boxed{\mathrm{bmix}(c-a,d-b,g-e,h-f,x,z)} \\
\\
\partial_z\mathrm{tmix} &amp;= \partial_x\mathrm{mix} \\
                        &amp;= \partial_x\mathrm{mix}(a=\mathrm{bmix}(a,b,c,d,x,y),b=\mathrm{bmix}(e,f,g,h,x,y),x=z) \\
                        &amp;= \mathrm{bmix}(e,f,g,h,x,y)-\mathrm{bmix}(a,b,c,d,x,y) \\
                        &amp;= \boxed{\mathrm{bmix}(e-a,f-b,g-c,h-d,x,y)}
\end{aligned}
</p>
<p>Finally, given these partial derivatives, we can figure out how to compute the
derivatives of the noise itself. It helps to know that <code>fract(p)</code> derivative
is 1 (mostly) and <code>floor(p)</code> derivative is 0 (mostly), so things simplify
themselves out fairly cleanly. I spare you the details this time:</p>
<p>
\begin{aligned}
\text{1D: } &amp; \boxed{\textbf{mix}(g_0,g_1,\textbf{fade}(f))+\partial_x\textbf{mix}(v_0,v_1)\cdot\textbf{fade}&#39;(f)} \\
\text{2D: } &amp; \boxed{\textbf{bmix}(g_0,g_1,g_2,g_3,\textbf{fade}(f))+\nabla\mathrm{bmix}(v_0,v_1,v_2,v_3,\textbf{fade}(f))\cdot\textbf{fade}&#39;(f)} \\
\text{3D: } &amp; \boxed{\textbf{tmix}(g_0,g_1,g_2,g_3,g_4,g_5,g_6,g_7,\textbf{fade}(f))+\nabla\mathrm{tmix}(v_0,v_1,v_2,v_3,v_4,v_5,v_6,v_7,\textbf{fade}(f))\cdot\textbf{fade}&#39;(f)}
\end{aligned}
</p>
<p>Adjusting our gradient noise functions to return the derivatives along with the
noise value itself:</p>
<pre><code>vec2 noise1d(float p) {
    int i = int(floor(p));
    float g0 = grad(i);
    float g1 = grad(i + 1);

    float f = fract(p);
    float v0 = g0 * f;
    float v1 = g1 * (f - 1.0);

    float a = fade(f);
    float v = mix(v0, v1, a);

    float g = mix(g0, g1, a);
    float d = v1 - v0;                    // derivative of mix with respect to the interpolant
    float da = ((f-2.0)*f+1.0)*30.0*f*f;  // fade&#39;(t): derivative of quintic interpolant

    return vec2(g + d*da, v);
}
</code></pre>
<pre><code>vec3 noise2d(vec2 p) {
    // [...]
    float v = bmix(v0, v1, v2, v3, a.x, a.y);

    vec2 g = bmix(g0, g1, g2, g3, a.x, a.y);
    vec2 d = mix(vec2(v1,v2)-v0, v3-vec2(v2,v1), a.yx); // derivatives of bmix with respect to the interpolant
    vec2 da = ((f-2.0)*f+1.0)*30.0*f*f;

    return vec3(g + d*da, v);
}
</code></pre>
<pre><code>vec4 noise3d(vec3 p) {
    // [...]
    float v = tmix(v0, v1, v2, v3, v4, v5, v6, v7, a.x, a.y, a.z);

    vec3 g = tmix(g0, g1, g2, g3, g4, g5, g6, g7, a.x, a.y, a.z);
    vec3 d = bmix(vec3(v1,v2,v4)-v0, vec3(v3-v2,v3-v1,v5-v1),  // derivatives of tmix with
                  vec3(v5-v4,v6-v4,v6-v2), v7-vec3(v6,v5,v3),  // respect to the interpolant
                  a.yxx, a.zzy);
    vec3 da = ((f-2.0)*f+1.0)*30.0*f*f;

    return vec4(g + d*da, v);
}
</code></pre>
<div>
<p>Note</p>
<p>The derivatives are in the first component so that given <code>n=noise3d(p)</code> we
can write <code>vec3 d=n.xyz</code> for x/y/z partial derivatives instead of the more
awkward <code>vec3 d=n.yzw</code>.</p>
</div>
<p>To get the equivalent derivatives for value noise, we just set <span>g=0</span> in the
final expression of the derivatives.</p>
<p>It is possible to unroll the nested <code>mix</code> expression to (maybe) make it faster,
but I find the mix expressions simple, elegant, and likely more numerically
stable.</p>
<h3>Using the derivatives</h3>
<p>There are important things to take into consideration when working with the
derivatives. Most notably, it&#39;s important to follow the <a href="https://en.wikipedia.org/wiki/Chain_rule">chain rule</a>
and the <a href="https://en.wikipedia.org/wiki/Product_rule">product rule</a>. For example, let&#39;s say we&#39;re working with
a noise function that returns the derivatives:</p>
<pre><code>float freq = 0.1;
vec4 n = noise3d(x*freq);
float v = n.a;            // value
vec2 d = n.xyz * freq;    // partial derivatives
</code></pre>
<p>If we multiply the input of our function by the frequency, then we need to
multiply the derivatives by the same frequency factor.</p>
<p>Similarly, let&#39;s say we want to move <span>v</span> from <span>[-1,1]</span> to <span>[0,1]</span>:</p>
<pre><code>v = (v + 1.0) / 2.0; // [-1,1] -&gt; [0,1]
d = d / 2.0;
</code></pre>
<p>The intuitive explanation is that if we are squeezing the value in half its
original size, then the derivatives (slopes) are getting flatter as well.</p>
<p>This may not sound very important, but failing to propagate these scale factors
correctly often leads to subtle bugs. For example in the fBm, if we want it to
return the correct derivatives it is necessary to do something like that (notice
the <code>freq</code>):</p>
<pre><code>vec4 fbm3d(vec3 p) {
    vec4 sum = vec4(0.0);
    float amp = 1.0, freq = 1.0;
    for (int i = 0; i &lt; octaves; i++) {
        vec4 n = noise3d(p * freq);
        sum.xyz += amp * n.xyz * freq; // derivatives
        sum.a += amp * n.a; // value
        freq *= LACUNARITY;
        amp *= GAIN;
    }
    return sum;
}
</code></pre>
<p>Things get tricky when the noise is being adjusted with the derivatives
themselves as we saw before with the erosion, especially since this would imply
second order derivatives.</p>
<p>Similarly, there is a technique involving the rotation of <span>p</span> at every iteration
of the fBm to reduce the correlations between noise layers. This rotation is a
linear transformation, but it requires careful adjustments to the derivatives as
well. Implementing these transformations correctly is left as an exercise;
careful bookkeeping of derivatives is essential.</p>
<h2>Going further</h2>
<p>With this introduction we only explored the tip of the iceberg. For example,
you&#39;ll be interested to know that there are alternative noises such as
<a href="https://en.wikipedia.org/wiki/OpenSimplex_noise">OpenSimplex</a>, where we interpolate with lattice positions on
a simplex grid (triangles in 2D, tetrahedra in 3D) instead of a rectangular
grid. It has useful properties, for example in fBm it yields fewer directional
artifacts, eliminating the need for ad-hoc rotations.</p>
<p>Speaking of fBm, you may want to check out <a href="https://iquilezles.org/articles/warp/">domain warping</a> where
nested fBm together make fancy effects:</p>
<figure>
  <canvas width="600" height="300" data-fragment="/frag/noise/gnoise2warp.frag"></canvas>
  <figcaption>Domain warping with fbm2(p+fbm2(p+fbm2(p+t)))</figcaption>
</figure>
<p>Another thing you&#39;ll be tempted to research is how to consistently scale the
noise so that it fits into a controlled range of value. Spoiler alert: it&#39;s a
<em>particularly</em> complex subject.</p>
<p>Similarly, we stopped ourselves at 3D, but 4D is also useful, for example let&#39;s
say we want to morph the 3D noise with time: <span>p=(x,y,z,t)</span>.</p>
<p>I hope this article was able to give a good overview of the concepts, and I&#39;ll
see you next time for new adventures.</p>
</article><p>For updates and more frequent content you can follow me on
<a href="https://fosstodon.org/@bug">Mastodon</a>. Feel also free to subscribe to the
<a href="https://blog.pkh.me/rss.xml">RSS</a> in order to be notified of new write-ups. It is also usually
possible to reach me through other means (check the footer below). Finally,
discussions on some of the articles can sometimes be found on HackerNews,
Lobste.rs and Reddit.</p></div>
  </body>
</html>
