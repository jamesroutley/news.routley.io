<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.jacobvosmaer.nl/0038-yocto-dmux/">Original</a>
    <h1>Adding d-mux support to the Yocto</h1>
    
    <div id="readability-page-1" class="page"><div><p><i><a href="https://blog.jacobvosmaer.nl/">Jacob Vosmaer&#39;s blog</a></i></p>

<p>2025-02-03</p>

<p>I modified my <a href="https://blog.jacobvosmaer.nl/0014-yocto/">Yocto</a> drum machine to work with the proprietary <a href="https://www.sequentix.com/">Sequentix</a> d-mux music interface.</p>

<h2>The d-mux protocol</h2>

<p>I make my <a href="https://soundcloud.com/collector-current">music</a> using a Sequentix Cirklon <a href="https://en.wikipedia.org/wiki/Music_sequencer">sequencer</a>. Although the Cirklon is designed around <a href="https://en.wikipedia.org/wiki/MIDI">MIDI</a> it also supports <a href="https://en.wikipedia.org/wiki/CV/gate">CV/gate</a> communication and its own proprietary &#34;Drum Mux&#34; or d-mux protocol. &#34;Mux&#34; stands for &#34;multiplexer&#34;. This protocol is meant to be used with percussion sounds.</p>

<h3>MIDI timing limitations</h3>

<p>Using MIDI for percussion can be iffy because of the inherent timing limitations of the protocol. The problem is that MIDI is slow and messages contain single notes with no timing information. The usual interpretation of a &#34;note on&#34; message is &#34;play this note right now&#34;. If you want to play three notes at the same time then really you can&#39;t: three notes means three messages that will arrive at distinct times and each will get played at its time of arrival.</p>

<p>It depends on the kind of instrument you&#39;re controlling whether this staggered one-note-at-a-time timing is a problem. Often enough you don&#39;t notice the effect at all. It&#39;s most likely to be noticeable with percussive sounds, such as drums.</p>

<p>This is probably a solved problem for most people. USB MIDI is much faster and I imagine the same is true for virtual synthesizers that run on the same computer as the sequencer. But in my 1980s retro world of hardware synths and sequencers this problem still exists.</p>

<h3>The d-mux solution: batch messages</h3>

<p>The d-mux protocol addresses this problem (simultaneous notes becoming staggered) by sending notes in batch messages. Now you can have simultaneous notes, provided they arrive in the same batch.</p>

<p>All this is proprietary to the Cirklon ecosystem. You can buy a break-out box from Sequentix that connects to the Cirklon with a 5-pin DIN cable.   The break-out box has jack sockets that allow you to connect individual cables for each trigger signal to something like a <a href="https://youtu.be/7Gt6P-AX9rw?feature=shared">Simmons SDS-800</a> or Eurorack drum modules.</p>

<h2>Yocto + d-mux = profit?</h2>

<p>A while back I came across a <a href="https://www.youtube.com/watch?v=aHov_qiQqvc">video</a> from Sequentix where Cirklon designer Colin Fraser demonstrates the difference d-mux makes by using a custom modified TR-808 drum machine. If you don&#39;t have time to watch the whole thing, jump to <a href="https://youtu.be/aHov_qiQqvc?feature=shared&amp;t=293">4:53</a>.</p>

<p>This got me thinking about whether I could add d-mux to my <a href="https://blog.jacobvosmaer.nl/0014-yocto/">Yocto</a> DIY 808 clone. The problem is that a d-mux receiver is expensive (about €400) and I&#39;d have to buy a new one just  for the Yocto. Also the way Colin does it in his video he is customizing the 808 circuit in a way that feels a little over my head.</p>

<p>But then a while later Colin <a href="http://forum.sequentix.com/viewtopic.php?p=35144#p35144">shared</a> some of the details of how the d-mux protocol works. The cool thing about the Yocto is that I wrote my own <a href="https://gitlab.com/jacobvosmaer/yocto-firmware/">firmware</a> for it and most of what&#39;s needed to receive the d-mux signals is already there.</p>

<h3>The hardware mod</h3>

<p>The Yocto has the 3 standard MIDI DIN ports (In, Out, Thru) but it also has a fourth DIN port to send out Roland &#34;Sync&#34; signals. People call this &#34;DIN sync&#34; nowadays but that is a weird name because DIN is a German standards body and Roland&#39;s 1980s sync protocol is not standardized with DIN. I digress.</p>

<p><img src="https://blog.jacobvosmaer.nl/0038-yocto-dmux/assets/yocto-ports.jpeg" alt="The DIN ports on the Yocto"/></p>

<p>The DinSync port of the Yocto connects pin 1 and 3 to the MCU and pin 2 to ground. The d-mux protocol uses all 5 pins, with pin 2 as ground, but I have to ignore one of the pins because of Yocto hardware limitations (the global accent design discussed below). This leaves 4 pins, 3 of which are already connected. Luckily for me there is a pad on the circuit board right next to the Yocto DinSync port that leads to an unused GPIO pin of the MCU. So all I had to do to connect the remaining d-mux signal was to connect pin 5 of the DIN port to the unused pad.</p>

<p><img src="https://blog.jacobvosmaer.nl/0038-yocto-dmux/assets/yocto-mod.jpeg" alt="A jumper wire connects pin 5 to the MCU"/>
<i>Instead of spending €400 on an official d-mux receiver and ripping out its circuit board, I spent €0 on a leftover piece of wire.</i></p>

<h3>Adapting the firmware</h3>

<p>The d-mux protocol works like a <a href="https://en.wikipedia.org/wiki/Shift_register#Serial-in_parallel-out_(SIPO)">latched serial in parallel out shift register</a>. I modified the Yocto firmware so that it receives the d-mux trigger bits that are being transmitted in RAM and when the sender unlatches the data the Yocto MCU (an <a href="https://www.microchip.com/en-us/product/ATmega1284p">ATmega1284P</a>) triggers the drum voices.</p>

<p>I struggled with the timing of reading the incoming d-mux serial transmission but I got it working alright using a &#34;pin change interrupt&#34; on the MCU. The MCU has to do its own SPI transmissions to the internal hardware. These are slow and waiting for SPI to complete causes me to miss incoming d-mux bits. By using a pin change interrupt I can keep up with the d-mux transmission in spite of being stuck waiting for SPI.</p>

<p>The other problem I ran into was communication between the pin change interrupt and the main thread. I ended up making a very simple lock-free queue that seems to do the job. You can see how I got it working in <a href="https://gitlab.com/jacobvosmaer/yocto-firmware/-/commit/b10af1c51c6d22178c31d6224f653af385f962a9">this commit</a>. I had to move some code around to make it work but in the end it&#39;s fairly simple.</p>

<p>There is the pin change interrupt:</p>

<pre><code>
ISR(PCINT3_vect) {
    uint8_t new_state = PIND;

    if (!(dmux.state &amp; DMUX_FRAME) &amp;&amp;
        (new_state &amp; DMUX_FRAME)) { /* frame rise */
        dmux.n = 0;
        dmux.bitmap = 0;
    } else if ((dmux.state &amp; DMUX_FRAME) &amp;&amp;
           !(new_state &amp; DMUX_FRAME)) { /* frame fall */
        if (dmux.bitmap) {
            dmux_queue.idx =
                (dmux_queue.idx + 1) % nelem(dmux_queue.frame);
            dmux_queue.frame[dmux_queue.idx] = dmux.bitmap;
        }
    } else if (!(dmux.state &amp; DMUX_CLOCK) &amp;&amp;
           (new_state &amp; DMUX_CLOCK)) { /* clock rise */
        ;
    } else if ((dmux.state &amp; DMUX_CLOCK) &amp;&amp;
           !(new_state &amp; DMUX_CLOCK)) { /* clock fall */
        if ((PINB &amp; DMUX_TRIG) &amp;&amp; dmux.n &lt; nelem(voicetab))
            dmux.bitmap |= (1 &lt;&lt; dmux.n);
        dmux.n++;
    }

    dmux.state = new_state;
}
</code></pre>

<p>And then in the main loop we check if there is a new frame in the queue:</p>

<pre><code>
        if (dmux_idx = dmux_queue.idx, dmux_idx != last_dmux_idx) {
            for (i = 0; i &lt; nelem(voicetab); i++)
                if (dmux_queue.frame[dmux_idx] &amp; (1 &lt;&lt; i))
                    voicetab[i].pulse = PULSE;
            note_on = 1;
            last_dmux_idx = dmux_idx;
        }
</code></pre>

<p>And the rest of the main loop then handles this just as if a bunch of MIDI notes arrived all at the same time.</p>

<h3>How my hack is different from what Colin showed</h3>

<p>I am happy that this works and that I avoided paying €400 for an official d-mux receiver but I have to admit that my solution is not equivalent to what Colin showed in his video.</p>

<p>The 808 lets you program drum hits with two strengths: &#34;normal&#34; and &#34;accent&#34;. The strength is a <em>global</em> setting. If a step is accented then all drum hits on that step are louder. There is a knob on the machine that lets you dial in how big the difference between &#34;normal&#34; and &#34;accent&#34; is. This system works pretty well but it&#39;s not what people expect from a modern drum machine. With MIDI you could make a snare drum roll with a crescendo. That doesn&#39;t work on the 808; even if you manually moved the accent knob during the roll to create the crescendo swell you&#39;d be raising the volume of all drum hits coming out of the machine, not just the snare drum.</p>

<p>The hardware modification Colin made to his 808 gives him control over the strength of each individual drum hit. This is a more complex modification and if I wanted to do this I would probably need a proper d-mux receiver after all.</p>

<p>What my solution does is to treat the &#34;accent&#34; as a silent &#34;meta&#34; drum hit. On the Cirklon I program it as any other drum hit and then the Yocto raises the volume as expected. This is also how it works in the original 808 user interface. While this is less flexible then varying the strength per instrument, it does give me the authentic 808 sound, with the associated improved timing, and all controlled from the Cirklon along with the rest of my song.</p>

<h2>Conclusion</h2>

<p>This was a fun project. I got better at embedded programming and I got the protocol working with a very simple hardware mod. I also have a Nava DIY clone of the TR-909 that I built myself and I think I may be able to repeat this hack there. I&#39;ll write about it if it works out. Thank you for reading!</p>
<p>Tags:  <a href="https://blog.jacobvosmaer.nl/music.html">music</a> <a href="https://blog.jacobvosmaer.nl/diy.html">diy</a> <a href="https://blog.jacobvosmaer.nl/c.html">c</a></p>
<p><a href="https://blog.jacobvosmaer.nl/">Back</a></p></div></div>
  </body>
</html>
