<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://developers.redhat.com/articles/2022/09/17/gccs-new-fortification-level">Original</a>
    <h1>GCC&#39;s new fortification level: The gains and costs (2022)</h1>
    
    <div id="readability-page-1" class="page"><div>
                  
                <div>
          <p>This article describes a new level of fortification supported in GCC. This new level detects more buffer overflows and bugs which mitigates security issues in applications at run time.</p>

<p>C programs routinely suffer from memory management problems. For several years, a <code>_FORTIFY_SOURCE</code> preprocessor macro inserted error detection to address these problems at compile time and run time. To add an extra level of security, <code>_FORTIFY_SOURCE=3</code> has been in the GNU C Library (glibc) since version 2.34. I described its mechanisms in my previous blog post, <a href="https://developers.redhat.com/blog/2021/04/16/broadening-compiler-checks-for-buffer-overflows-in-_fortify_source">Broadening compiler checks for buffer overflows in _FORTIFY_SOURCE</a>. There has been compiler support for this builtin in <a href="https://clang.llvm.org">Clang</a> for some time. Compiler support has also been available for <a href="https://gcc.gnu.org">GCC</a> since the release of version 12 in May 2022. The new mitigation should be available in GNU/Linux distributions with packaged GCC 12.</p>

<p>The following sections discuss two principal gains from this enhanced level of security mitigation and the resulting impact on applications.</p>

<p><strong>2 principal gains:</strong></p>

<ol>
	<li>
	<p>Enhanced buffer size detection</p>
	</li>
	<li>
	<p>Better fortification coverage</p>
	</li>
</ol>

<h2>1. A new builtin provides enhanced buffer size detection</h2>

<p>There is a new builtin underneath the new <code>_FORTIFY_SOURCE=3</code> macro n GCC 12 named <code>__builtin_dynamic_object_size</code>. This builtin is more powerful than the previous <code>__builtin_object_size</code> builtin used in <code>_FORTIFY_SOURCE=2</code>. When passed a pointer, <code>__builtin_object_size</code>returns as a compile-time constant that is either the maximum or minimum object size estimate of the object that pointer may be pointing to at that point in the program. On the other hand, <code>__builtin_dynamic_object_size</code> is capable of returning a size expression that is evaluated at execution time. Consequently, the <code>_FORTIFY_SOURCE=3</code> builtin detects buffer overflows in many more places than <code>_FORTIFY_SOURCE=2</code>.</p>

<p>The implementation of <code>__builtin_dynamic_object_size</code> in GCC is compatible with <code>__builtin_object_size</code> and thereby interchangeable, especially in the case of fortification. Whenever possible, the builtin computes a precise object size expression. When the builtin does not determine the size exactly, it returns either a maximum or minimum size estimate, depending on the size type argument.</p>

<p>This code snippet demonstrates the key advantage of returning precise values:</p>

<pre><code>#include &lt;string.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;stdlib.h&gt;

char *b;
char buf1[21];

char *__attribute__ ((noinline)) do_set (bool cond)
{
    char *buf = buf1;
    if (cond)
        buf = malloc (42);

    memset (buf, 0, 22);
    return buf;
}

int main (int argc, char **argv)
{
    b = do_set (false);
    return 0;
}</code></pre>

<p>The program runs to completion when built with <code>-D_FORTIFY_SOURCE=2</code>:</p>

<pre><code>gcc -O -D_FORTIFY_SOURCE=2 -o sample sample.c</code></pre>

<p>But the program aborts when built with <code>-D_FORTIFY_SOURCE=3</code> and outputs the following message:</p>

<pre><code>*** buffer overflow detected ***: terminated
Aborted (core dumped)</code></pre>

<p>The key enhancement stems from the difference in behavior between <code>__builtin_object_size</code> and <code>__builtin_dynamic_object_size</code>. <code>_FORTIFY_SOURCE=2</code> uses <code>__builtin_object_size</code> and returns the maximum estimate for object size at pointer <code>buf</code>, which is 42. Hence, GCC assumes that the <code>memset</code> operation is safe at compile time and does not add a call to check the buffer size at run time.</p>

<p>However, GCC with <code>_FORTIFY_SOURCE=3</code> invokes <code>__builtin_dynamic_object_size</code> to emit an expression that returns the precise size of the buffer that <code>buf</code> points to at that part in the program. As a result, GCC realizes that the call to <code>memset</code> might not be safe. Thus, the compiler inserts a call to <code>__memset_chk</code> into the running code with that size expression as the bound for <code>buf</code>.</p>

<h2>2. Better fortification coverage</h2>

<p>Building distribution packages with <code>_FORTIFY_SOURCE=3</code> revealed several issues that <code>_FORTIFY_SOURCE=2</code> missed. Surprisingly, not all of these issues were straightforward buffer overflows. The improved fortification also encountered issues in the GNU C library (glibc) and raised interesting questions about object lifetimes.</p>

<p>Thus, the benefit of improved fortification coverage has implications beyond buffer overflow mitigation. I will explain the outcomes of <code>_FORTIFY_SOURCE=3</code> increased coverage in the following sections.</p>

<h3>More trapped buffer overflows</h3>

<p>Building applications with <code>_FORTIFY_SOURCE=3</code> detected many simple buffer overflows, such as the <a href="https://bugzilla.redhat.com/show_bug.cgi?id=2115476">off-by-one access in clisp</a> issue. We expected these revelations, which strengthened our justification for building applications with <code>_FORTIFY_SOURCE=3</code>.</p>

<p>To further support the use of <code>_FORTIFY_SOURCE=3</code> to improve fortification, we used the <a href="https://github.com/siddhesh/fortify-metrics">Fortify metrics</a> GCC plugin to estimate the number of times _FORTIFY_SOURCE=3 resulted in a call to a checking function (<code>__memcpy_chk</code>, <code>__memset_chk</code>, etc.). We used Fedora test distribution and some of the <code>Server</code> package group as the sample, which consisted of 96 packages. The key metric is fortification coverage, defined by counting the number of calls to <code>__builtin_object_size</code> that resulted in a successful size determination and the ratio of this number taken to the total number of <code>__builtin_object_size</code> calls. The plugin also shows the number of successful calls if using <code>__builtin_dynamic_object_size</code> instead of <code>__builtin_object_size</code>, allowing us to infer the fortification coverage if all <code>__builtin_object_size</code> calls were replaced with <code>__builtin_dynamic_object_size</code>.</p>

<p>In this short study, we found that <code>_FORTIFY_SOURCE=3</code> improved fortification by nearly 4 times. For example, the Bash shell went from roughly 3.4% coverage with <code>_FORTIFY_SOURCE=2</code> to nearly 47% with <code>_FORTIFY_SOURCE=3</code>. This is an improvement of nearly 14 times. Also, fortification of programs in <code>sudo</code> went from a measly 1.3% to 49.57% â€” a jump of almost 38 times!</p>

<h3>The discovery of bugs in glibc</h3>

<p>The increased coverage of <code>_FORTIFY_SOURCE=3</code> revealed programming patterns in application programs that tripped over the fortification without necessarily a buffer overflow. While there were some bugs in glibc, we had to either explain why we did not support it or discover ways to discourage those programming patterns.</p>

<p>One example is <code>wcrtomb</code>, where glibc makes stronger assumptions about the object size passed than POSIX allowed. Specifically, glibc assumes that the buffer passed to <code>wcrtomb</code> is always at least <code>MB_CUR_MAX</code> bytes long. In contrast, the POSIX description makes no such assumption. Due to this discrepancy, any application that passed a smaller buffer would potentially make <code>wcrtomb</code> overflow the buffer during conversion. Then the fortified version <code>__wcrtomb_chk</code> aborts with a buffer overflow, expecting a buffer that is <code>MB_CUR_MAX</code> bytes long. We fixed this bug in glibc-2.36 by making glibc conform to POSIX .</p>

<p><code>_FORTIFY_SOURCE=3</code> revealed another pattern. Applications such as systemd used <code>malloc_usable_size</code> to determine available space in objects and then used the residual space. The glibc manual discourages this type of usage, dictating that <code>malloc_usable_size</code> is for diagnostic purposes only. But applications use the function as a hack to avoid reallocating buffers when there is space in the underlying malloc chunk. The implementation of <code>malloc_usable_size</code> needs to be fixed to return the allocated object size instead of the chunk size in non-diagnostic use. Alternatively, another solution is to deprecate the function. But that is a topic for discussion by the glibc community.</p>

<h3>Strict C standards compliance</h3>

<p>One interesting use case exposed by <code>_FORTIFY_SOURCE=3</code> raised the question of object lifetimes and what developers can do with freed pointers. The bug in question was in <a href="https://sourceforge.net/p/autogen/bugs/212/">AutoGen</a>, using a pointer value after reallocation to determine whether the same chunk extended to get the new block of memory. This practice allowed the developer to skip copying over some pointers to optimize for performance. At the same time, the program continued using the same pointer, not the <code>realloc</code> call result, since the old pointer did not change.</p>

<p>Seeing that the old pointer continued without an update, the compiler assumed that the object size remained the same. How could it know otherwise? The compiler then failed to account for the reallocation, resulting in an abort due to the perceived buffer overflow.</p>

<p>Strictly speaking, the C standards prohibit using a pointer to an object after its lifetime ends. It should neither be read nor dereferenced. In this context, it is a bug in the application.</p>

<p>However, this idiom is commonly used by developers to prevent making redundant copies. Future updates to <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=105217">GCC</a> may account for this idiom wherever possible, but applications should also explicitly indicate object lifetimes to remain compliant. In the AutoGen example, a simple fix is to unconditionally refresh the pointer after reallocation, ensuring the compiler can detect the new object size.</p>

<h2>The gains of improved security coverage outweigh the cost</h2>

<p>Building with <code>_FORTIFY_SOURCE=3</code> may impact the size and performance of the code. Since <code>_FORTIFY_SOURCE=2</code> generated only constant sizes, its overhead was negligible. However, <code>_FORTIFY_SOURCE=3</code> may generate additional code to compute object sizes. These additions may also cause secondary effects, such as register pressure during code generation. Code size tends to increase the size of resultant binaries for the same reason.</p>

<p>We need a proper study of performance and code size to understand the magnitude of the impact created by <code>_FORTIFY_SOURCE=3</code> additional runtime code generation. However the performance and code size overhead may well be worth it due to the magnitude of improvement in security coverage.</p>

<h2>The future of buffer overflow detection</h2>

<p><code>_FORTIFY_SOURCE=3</code> has led to significant gains in security mitigation. GCC 12 support brings those gains to distribution builds. But the new level of fortification also revealed interesting issues that require additional work to support correctly. For more background information, check out my previous article, <a href="https://www.redhat.com/en/blog/enhance-application-security-fortifysource">Enhance application security with FORTIFY_SOURCE</a>.</p>

<p>Object size determination and fortification remain relevant areas for improvements in compiler toolchains. The toolchain team at Red Hat continues to be involved in the GNU and LLVM communities to make these improvements.</p>
          
                                <p><i>Last updated:
              November 8, 2023</i>
                  </p></div>
      </div></div>
  </body>
</html>
