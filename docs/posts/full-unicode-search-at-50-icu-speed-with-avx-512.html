<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ashvardanian.com/posts/search-utf8/">Original</a>
    <h1>Full Unicode Search at 50Ã— ICU Speed with AVXâ€‘512</h1>
    
    <div id="readability-page-1" class="page"><div><p>This article is about the ugliest, but potentially most useful piece of open-source software Iâ€™ve written this year.
Itâ€™s messy, because UTF-8 is messy.
The worldâ€™s most widely used text encoding standard was introduced in 1989.
It now covers more than 1 million characters across the majority of used writing systems, so itâ€™s not exactly trivial to work with.</p><p><img alt="Searching UTF-8 in AVX-512: Safer and Faster" loading="lazy" src="https://ashvardanian.com/search-utf8/search-utf8-example.png"/></p><blockquote><p>The example above contains multiple confusable characters: German Eszett variants <span><strong>&#39;ÃŸ&#39;</strong><span><code>U+00DF</code><code>0x C3 9F</code></span>
</span>and <span><strong>&#39;áº&#39;</strong><span><code>U+1E9E</code><code>0x E1 BA 9E</code></span>
</span>, the Kelvin sign <span><strong>&#39;â„ª&#39;</strong><span><code>U+212A</code><code>0x E2 84 AA</code></span>
</span>and ASCII <span><strong>&#39;k&#39;</strong><span><code>U+006B</code><code>0x 6B</code></span>
</span>, and Greek mu <span><strong>&#39;Î¼&#39;</strong><span><code>U+03BC</code><code>0x CE BC</code></span>
</span>vs the micro sign <span><strong>&#39;Âµ&#39;</strong><span><code>U+00B5</code><code>0x C2 B5</code></span>
</span>.
Try guessing which is which and how they are encoded in UTF-8!</p></blockquote><p>Thatâ€™s why <a href="https://icu.unicode.org/">ICU</a> exists - pretty much the only comprehensive open-source library for Unicode and UTF-8 handling, powering Chrome/Chromium and probably every OS out there.
Itâ€™s feature-rich, battle-tested, and freaking slow.
<strong>Now StringZilla makes some of the most common operations much faster, leveraging AVX-512 on Intel and AMD CPUs!</strong></p><p>Namely:</p><ol><li><strong>Tokenizing</strong> text into lines or whitespace-separated tokens, handling 25 different whitespace characters and 9 newline variants; available since v4.3; <strong>10Ã— faster than alternatives</strong>.</li><li><strong>Case-folding</strong> text into lowercase form, handling all 1400+ rules and edge cases of Unicode 17 locale-agnostic expansions, available since v4.4; <strong>10Ã— faster than alternatives</strong>.</li><li><strong>Case-insensitive substring search</strong> bypassing case-folding for both European and Asian languages, available since v4.5; <strong>20â€“150Ã— faster than alternatives</strong>. Or 20,000Ã— faster, if we compare to <a href="https://www.pcre.org/">PCRE2</a> RegEx engine with case-insensitive flag!</li></ol><p>Iâ€™d like to stress that this is not just about â€œthroughputâ€ or â€œspeedâ€ - itâ€™s about â€œcorrectnessâ€ as well!
Some experimental projects try applying vectorization to broader text processing tasks, but the vast majority are limited to ASCII or ignore all the edge cases of Unicode to achieve speedups.
StringZilla, however, is tested against a synthetic suite generated on the fly from the most recent Unicode specs, so when the 18.0 of the standard comes out, updating the library to support it should be trivial.
Itâ€™s also tested against ICU on real-world data to keep it correct in typical cases.
Letâ€™s dive into the details of how this was achieved.</p><h2 id="utf-8-primers">UTF-8 Primers</h2><p>Today, almost all of the Internet is UTF-8.
Its share grew from 50% in 2010 to 98% in 2024.
The remaining ~2% is mostly legacy content in:</p><ul><li>â€œISO-8859-1â€ or â€œLatin-1â€ â€” older Western European sites</li><li>â€œWindows-1252â€ â€” legacy Windows encoding</li><li>â€œGB2312â€ and â€œGBKâ€ â€” older Chinese sites</li><li>â€œShift_JISâ€ â€” older Japanese sites</li></ul><p>So what does it look like and how it improves on previous encodings?</p><blockquote><p>If you often face those weird alternative encodings, just pull <a href="https://github.com/lemire">Daniel Lemire</a>â€™s and <a href="https://github.com/WojciechMula">Wojciech MuÅ‚a</a>â€™s <a href="https://github.com/simdutf/simdutf">simdutf</a>.</p></blockquote><h3 id="unicode-runes-vs-utf-8-encoding">Unicode Runes vs UTF-8 Encoding</h3><p>Most trained developers know that UTF-8 is a variable-length encoding for Unicode codepoints.
It means that different characters may take different numbers of bytes to represent.
The first 128 codepoints (<code>U+0000</code>â€“<code>U+007F</code>) are represented as single bytes, identical to ASCII.
Codepoints from <code>U+0080</code>â€“<code>U+07FF</code> take 2 bytes, from <code>U+0800</code>â€“<code>U+FFFF</code> take 3 bytes, and from <code>U+10000</code>â€“<code>U+10FFFF</code> take 4 bytes.
Borrowing <a href="https://en.wikipedia.org/wiki/UTF-8#Description">a table from Wikipedia</a>, hereâ€™s how the encoding works:</p><table><thead><tr><th>Codepoint Range</th><th>Byte 1</th><th>Byte 2</th><th>Byte 3</th><th>Byte 4</th></tr></thead><tbody><tr><td><code>U+0000</code>â€“<code>U+007F</code></td><td>0xxxxxxx</td><td></td><td></td><td></td></tr><tr><td><code>U+0080</code>â€“<code>U+07FF</code></td><td>110xxxxx</td><td>10xxxxxx</td><td></td><td></td></tr><tr><td><code>U+0800</code>â€“<code>U+FFFF</code></td><td>1110xxxx</td><td>10xxxxxx</td><td>10xxxxxx</td><td></td></tr><tr><td><code>U+10000</code>â€“<code>U+10FFFF</code></td><td>11110xxx</td><td>10xxxxxx</td><td>10xxxxxx</td><td>10xxxxxx</td></tr></tbody></table><p>You typically parse it left-to-right, unpacking codepoints as you go.
With 32-bit integers you can safely represent any Unicode codepoint, but as you may notice, not all 32-bit integers are valid codepoints.
Even in the <code>U+10000</code>â€“<code>U+10FFFF</code> range, only ~2.1 million codepoints are valid, while the rest are reserved.
In a C99 implementation, a verification-free toy parser may look like this:</p><div><div><table><tbody><tr><td><pre tabindex="0"><code><span id="hl-0-1"><a href="#hl-0-1"> 1</a>
</span><span id="hl-0-2"><a href="#hl-0-2"> 2</a>
</span><span id="hl-0-3"><a href="#hl-0-3"> 3</a>
</span><span id="hl-0-4"><a href="#hl-0-4"> 4</a>
</span><span id="hl-0-5"><a href="#hl-0-5"> 5</a>
</span><span id="hl-0-6"><a href="#hl-0-6"> 6</a>
</span><span id="hl-0-7"><a href="#hl-0-7"> 7</a>
</span><span id="hl-0-8"><a href="#hl-0-8"> 8</a>
</span><span id="hl-0-9"><a href="#hl-0-9"> 9</a>
</span><span id="hl-0-10"><a href="#hl-0-10">10</a>
</span><span id="hl-0-11"><a href="#hl-0-11">11</a>
</span><span id="hl-0-12"><a href="#hl-0-12">12</a>
</span><span id="hl-0-13"><a href="#hl-0-13">13</a>
</span><span id="hl-0-14"><a href="#hl-0-14">14</a>
</span><span id="hl-0-15"><a href="#hl-0-15">15</a>
</span><span id="hl-0-16"><a href="#hl-0-16">16</a>
</span><span id="hl-0-17"><a href="#hl-0-17">17</a>
</span><span id="hl-0-18"><a href="#hl-0-18">18</a>
</span><span id="hl-0-19"><a href="#hl-0-19">19</a>
</span><span id="hl-0-20"><a href="#hl-0-20">20</a>
</span><span id="hl-0-21"><a href="#hl-0-21">21</a>
</span><span id="hl-0-22"><a href="#hl-0-22">22</a>
</span><span id="hl-0-23"><a href="#hl-0-23">23</a>
</span><span id="hl-0-24"><a href="#hl-0-24">24</a>
</span><span id="hl-0-25"><a href="#hl-0-25">25</a>
</span><span id="hl-0-26"><a href="#hl-0-26">26</a>
</span></code></pre></td><td><pre tabindex="0"><code data-lang="c"><span><span><span>typedef</span> <span>uint32_t</span> <span>codepoint_t</span><span>;</span>
</span></span><span><span>
</span></span><span><span><span>void</span> <span>codepoint_parse</span><span>(</span><span>char</span> <span>const</span> <span>*</span><span>text</span><span>,</span> <span>size_t</span> <span>text_length</span><span>,</span> <span>codepoint_t</span> <span>*</span><span>codepoint</span><span>,</span> <span>size_t</span> <span>codepoint_length</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>size_t</span> <span>i</span> <span>=</span> <span>0</span><span>,</span> <span>j</span> <span>=</span> <span>0</span><span>;</span>
</span></span><span><span>    <span>while</span> <span>(</span><span>i</span> <span>&lt;</span> <span>text_length</span> <span>&amp;&amp;</span> <span>j</span> <span>&lt;</span> <span>codepoint_length</span><span>)</span> <span>{</span>
</span></span><span><span>        <span>uint8_t</span> <span>byte1</span> <span>=</span> <span>text</span><span>[</span><span>i</span><span>];</span>
</span></span><span><span>        <span>if</span> <span>(</span><span>byte1</span> <span>&lt;</span> <span>0x80</span><span>)</span> <span>{</span>
</span></span><span><span>            <span>codepoint</span><span>[</span><span>j</span><span>++</span><span>]</span> <span>=</span> <span>byte1</span><span>;</span>
</span></span><span><span>            <span>i</span> <span>+=</span> <span>1</span><span>;</span>
</span></span><span><span>        <span>}</span> <span>else</span> <span>if</span> <span>((</span><span>byte1</span> <span>&amp;</span> <span>0xE0</span><span>)</span> <span>==</span> <span>0xC0</span><span>)</span> <span>{</span>
</span></span><span><span>            <span>uint8_t</span> <span>byte2</span> <span>=</span> <span>text</span><span>[</span><span>i</span> <span>+</span> <span>1</span><span>];</span>
</span></span><span><span>            <span>codepoint</span><span>[</span><span>j</span><span>++</span><span>]</span> <span>=</span> <span>((</span><span>byte1</span> <span>&amp;</span> <span>0x1F</span><span>)</span> <span>&lt;&lt;</span> <span>6</span><span>)</span> <span>|</span> <span>(</span><span>byte2</span> <span>&amp;</span> <span>0x3F</span><span>);</span>
</span></span><span><span>            <span>i</span> <span>+=</span> <span>2</span><span>;</span>
</span></span><span><span>        <span>}</span> <span>else</span> <span>if</span> <span>((</span><span>byte1</span> <span>&amp;</span> <span>0xF0</span><span>)</span> <span>==</span> <span>0xE0</span><span>)</span> <span>{</span>
</span></span><span><span>            <span>uint8_t</span> <span>byte2</span> <span>=</span> <span>text</span><span>[</span><span>i</span> <span>+</span> <span>1</span><span>],</span> <span>byte3</span> <span>=</span> <span>text</span><span>[</span><span>i</span> <span>+</span> <span>2</span><span>];</span>
</span></span><span><span>            <span>codepoint</span><span>[</span><span>j</span><span>++</span><span>]</span> <span>=</span> <span>((</span><span>byte1</span> <span>&amp;</span> <span>0x0F</span><span>)</span> <span>&lt;&lt;</span> <span>12</span><span>)</span> <span>|</span> <span>((</span><span>byte2</span> <span>&amp;</span> <span>0x3F</span><span>)</span> <span>&lt;&lt;</span> <span>6</span><span>)</span> <span>|</span> <span>(</span><span>byte3</span> <span>&amp;</span> <span>0x3F</span><span>);</span>
</span></span><span><span>            <span>i</span> <span>+=</span> <span>3</span><span>;</span>
</span></span><span><span>        <span>}</span> <span>else</span> <span>if</span> <span>((</span><span>byte1</span> <span>&amp;</span> <span>0xF8</span><span>)</span> <span>==</span> <span>0xF0</span><span>)</span> <span>{</span>
</span></span><span><span>            <span>uint8_t</span> <span>byte2</span> <span>=</span> <span>text</span><span>[</span><span>i</span> <span>+</span> <span>1</span><span>],</span> <span>byte3</span> <span>=</span> <span>text</span><span>[</span><span>i</span> <span>+</span> <span>2</span><span>],</span> <span>byte4</span> <span>=</span> <span>text</span><span>[</span><span>i</span> <span>+</span> <span>3</span><span>];</span>
</span></span><span><span>            <span>codepoint</span><span>[</span><span>j</span><span>++</span><span>]</span> <span>=</span> <span>((</span><span>byte1</span> <span>&amp;</span> <span>0x07</span><span>)</span> <span>&lt;&lt;</span> <span>18</span><span>)</span> <span>|</span> <span>((</span><span>byte2</span> <span>&amp;</span> <span>0x3F</span><span>)</span> <span>&lt;&lt;</span> <span>12</span><span>)</span> <span>|</span> <span>((</span><span>byte3</span> <span>&amp;</span> <span>0x3F</span><span>)</span> <span>&lt;&lt;</span> <span>6</span><span>)</span> <span>|</span> <span>(</span><span>byte4</span> <span>&amp;</span> <span>0x3F</span><span>);</span>
</span></span><span><span>            <span>i</span> <span>+=</span> <span>4</span><span>;</span>
</span></span><span><span>        <span>}</span> <span>else</span> <span>{</span> <span>// Invalid UTF-8 byte sequence
</span></span></span><span><span><span></span>            <span>i</span> <span>+=</span> <span>1</span><span>;</span> <span>// Skip invalid byte
</span></span></span><span><span><span></span>        <span>}</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></td></tr></tbody></table></div></div><p>As one may notice, there is some extra effort to compact the bits from multiple bytes into a single codepoint.
Itâ€™s a modest amount of logic for modern CPUs, but the sequential dependency of processing $i+1$ byte after $i$ byte makes vectorization hard for modern CPUs.
But not impossible!</p><h3 id="unicode-in-modern-programming-languages">Unicode in Modern Programming Languages</h3><p>Iâ€™d argue, most developers donâ€™t regularly need to parse Unicode codepoints from UTF-8 strings by hand.
A <code>string</code> is the first-class citizen of practically every modern programming language.
In Rust, for example, the <code>char</code> type represents a Unicode scalar value, and the standard library provides methods for iterating over characters in a string, like so:</p><div><div><table><tbody><tr><td><pre tabindex="0"><code><span id="hl-1-1"><a href="#hl-1-1">1</a>
</span><span id="hl-1-2"><a href="#hl-1-2">2</a>
</span><span id="hl-1-3"><a href="#hl-1-3">3</a>
</span><span id="hl-1-4"><a href="#hl-1-4">4</a>
</span></code></pre></td><td><pre tabindex="0"><code data-lang="rust"><span><span><span>let</span><span> </span><span>text</span><span> </span><span>=</span><span> </span><span>&#34;Hello, ä¸–ç•Œ!&#34;</span><span>;</span><span>
</span></span></span><span><span><span></span><span>for</span><span> </span><span>ch</span><span> </span><span>in</span><span> </span><span>text</span><span>.</span><span>chars</span><span>()</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>println!</span><span>(</span><span>&#34;</span><span>{}</span><span>&#34;</span><span>,</span><span> </span><span>ch</span><span>);</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></td></tr></tbody></table></div></div><p>In other languages, the situation is more complex, as some have previously standardized smaller representations for â€œcharactersâ€.
A common thread at some point was to use fixed-width 16-bit â€œcharactersâ€, which can represent the Basic Multilingual Plane (BMP) of Unicode, but not the entire range of codepoints.
And when the need for full Unicode support arose, those languages had to introduce â€œsurrogate pairsâ€ to represent codepoints outside the BMP.</p><blockquote><p>UTF-8 encoding also has a similar concept to surrogate pairs - <strong>â€œoverlong encodingsâ€</strong>.
For example, the ASCII character <span><strong>&#39;A&#39;</strong><span><code>U+0041</code><code>0x 41</code></span>
</span>can be represented in UTF-8 as a single byte <code>0x 41</code>, but it can also be represented using two bytes <code>0x C1 81</code>, three bytes <code>0x E0 81 81</code>, or four bytes <code>0x F0 81 81 81</code>.
Those overlong encodings are invalid according to the UTF-8 standard and should be rejected by any compliant UTF-8 parser.</p></blockquote><blockquote><p>Moreover, UTF-8 has Emoji sequences that combine multiple codepoints into a single visual character via <span><strong>&#34;ZWJ&#34;</strong><span><code>U+200D</code><code>0x E2 80 8D</code></span>
</span>zero-width joiner.
For example, the family emoji ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦ is a combination of 4 emojis: <span><strong>&#39;ğŸ‘¨&#39;</strong><span><code>U+1F468</code><code>0x F0 9F 91 A8</code></span>
</span>, <span><strong>&#39;ğŸ‘©&#39;</strong><span><code>U+1F469</code><code>0x F0 9F 91 A9</code></span>
</span>, <span><strong>&#39;ğŸ‘§&#39;</strong><span><code>U+1F467</code><code>0x F0 9F 91 A7</code></span>
</span>, and <span><strong>&#39;ğŸ‘¦&#39;</strong><span><code>U+1F466</code><code>0x F0 9F 91 A6</code></span>
</span>.
Similarly, in Bengali script, the character <span><strong>&#34;à¦•à§à¦·&#34;</strong><span><code>U+0995 U+09CD U+09B7</code><code>0x E0 A6 95 E0 A7 8D E0 A6 B7</code></span>
</span>(ká¹£a) is a combination of two consonants <span><strong>&#39;à¦•&#39;</strong><span><code>U+0995</code><code>0x E0 A6 95</code></span>
</span>(ka) and <span><strong>&#39;à¦·&#39;</strong><span><code>U+09B7</code><code>0x E0 A6 B7</code></span>
</span>(á¹£a) joined by a <span><strong>&#34;Virama&#34;</strong><span><code>U+09CD</code><code>0x E0 A7 8D</code></span>
</span>, which suppresses the inherent vowel sound of the first consonant.</p></blockquote><p>Thatâ€™s how we ended up with a mess like this:</p><ul><li><strong>Rust</strong>: <code>String</code> is guaranteed valid UTF-8. Indexed by byte, not char.</li><li><strong>Go</strong>: <code>string</code> is UTF-8 bytes. <code>rune</code> type for code points.</li><li><strong>Swift</strong>: Native UTF-8 (since Swift 5). Exposes grapheme clusters.</li><li><strong>Java</strong>: UTF-16. Compressed to Latin-1 (1 byte/char) since Java 9.</li><li><strong>C#/.NET</strong>: UTF-16. Always 2 bytes minimum (surrogate pairs for non-BMP).</li><li><strong>JavaScript</strong>: UTF-16. <code>&#34;ğŸ˜€&#34;.length === 2</code> (surrogate pair).</li><li><strong>Python 3</strong>: Latin-1 / UCS-2 / UCS-4. Smallest fitting encoding.</li><li><strong>C/C++</strong>: <code>char*</code> is bytes. <code>wchar_t</code> is platform-dependent.</li></ul><p>For Python, in practice, it means that strings will massively explode in size when you add non-Latin-1 characters to them.
So if you are working on some web agents scraping HTML pages and wondering how to reduce memory consumption of your <a href="https://www.crummy.com/software/BeautifulSoup/"><code>beautifulsoup4</code></a> objects, consider switching to UTF-8 encoded <code>bytes</code> instead of <code>str</code>.
If you only need to validate UTF-8 or convert it to UTF-16/32, Daniel Lemireâ€™s <a href="https://github.com/simdutf/simdutf">SimdUTF</a> is the way to go.
But if you need to search and manipulate it - read on:</p><div><div><table><tbody><tr><td><pre tabindex="0"><code><span id="hl-2-1"><a href="#hl-2-1">1</a>
</span><span id="hl-2-2"><a href="#hl-2-2">2</a>
</span><span id="hl-2-3"><a href="#hl-2-3">3</a>
</span></code></pre></td><td><pre tabindex="0"><code data-lang="python"><span><span><span>import</span> <span>sys</span>
</span></span><span><span><span>print</span><span>(</span><span>f</span><span>&#39;Latin-1: </span><span>{</span><span>sys</span><span>.</span><span>getsizeof</span><span>(</span><span>&#34;hello&#34;</span><span>)</span><span>}</span><span> bytes&#39;</span><span>)</span> <span># prints &#34;46 bytes&#34;</span>
</span></span><span><span><span>print</span><span>(</span><span>f</span><span>&#39;UCS-4: </span><span>{</span><span>sys</span><span>.</span><span>getsizeof</span><span>(</span><span>&#34;helloğŸ˜€&#34;</span><span>)</span><span>}</span><span> bytes&#39;</span><span>)</span> <span># prints &#34;84 bytes&#34;... extra 1 char = extra 38 bytes</span>
</span></span></code></pre></td></tr></tbody></table></div></div><p>Python not only knows how to deal with Unicode codepoints natively, but it also has a built-in <code>unicodedata</code> module that provides access to the Unicode Character Database (UCD).
It provides a subset of the ICU functionality, and where more is needed - thereâ€™s a <code>PyICU</code> Python binding one can pull from PyPi.</p><table><thead><tr><th>Feature</th><th>Standard</th><th>PyICU</th><th>StringZilla</th></tr></thead><tbody><tr><td>Character names and categories</td><td>âœ“</td><td>âœ“</td><td>âœ—</td></tr><tr><td>Canonical and compatibility decompositions</td><td>âœ“</td><td>âœ“</td><td>âœ—</td></tr><tr><td>Locale-agnostic case mapping</td><td>âœ“</td><td>âœ“</td><td><strong>âœ“</strong></td></tr><tr><td>Word, sentence, and line breaking</td><td>âœ—</td><td>âœ“</td><td><strong>âœ“</strong></td></tr><tr><td>Case-insensitive search</td><td>âœ—</td><td>âœ“</td><td><strong>âœ“</strong></td></tr><tr><td>Locale-aware case mapping and collation (sorting)</td><td>âœ—</td><td>âœ“</td><td>âœ—</td></tr><tr><td>Date, time, and number formatting</td><td>âœ—</td><td>âœ“</td><td>âœ—</td></tr><tr><td>Transliteration</td><td>âœ—</td><td>âœ“</td><td>âœ—</td></tr></tbody></table><p>StringZilla is less feature-rich than both.
At least today.
But itâ€™s a lot faster for the most common operations.
This time weâ€™ll focus on just one of them - case-insensitive substring search.</p><h2 id="ideation--challenges-in-substring-search">Ideation &amp; Challenges in Substring Search</h2><h3 id="folding-expansions">Folding Expansions</h3><p>Case-folding is the process of converting text to a form that allows for case-insensitive comparisons.
Itâ€™s more complex than just converting uppercase letters to lowercase, especially in Unicode, where some characters have multiple case variants or expand into multiple characters when case-folded.
For example:</p><ul><li>German: <span><strong>&#39;ÃŸ&#39;</strong><span><code>U+00DF</code><code>0x C3 9F</code></span>
</span>and <span><strong>&#39;áº&#39;</strong><span><code>U+1E9E</code><code>0x E1 BA 9E</code></span>
</span>both case-fold into <span><strong>&#34;ss&#34;</strong><span><code>U+0073 U+0073</code><code>0x 73 73</code></span>
</span>.</li><li>Turkish: <span><strong>&#39;Ä°&#39;</strong><span><code>U+0130</code><code>0x C4 B0</code></span>
</span>case-folds into <span><strong>&#34;iÌ‡&#34;</strong><span><code>U+0069 U+0307</code><code>0x 69 CC 87</code></span>
</span>- thatâ€™s a lowercase <span><strong>&#39;i&#39;</strong><span><code>U+0069</code><code>0x 69</code></span>
</span>plus a combining dot.</li><li>Ligatures: <span><strong>&#39;ï¬ƒ&#39;</strong><span><code>U+FB03</code><code>0x EF AC 83</code></span>
</span>case-folds into <span><strong>&#34;ffi&#34;</strong><span><code>U+0066 U+0066 U+0069</code><code>0x 66 66 69</code></span>
</span>, so the original glyph contains matches for <span><strong>&#39;f&#39;</strong><span><code>U+0066</code><code>0x 66</code></span>
</span>, <span><strong>&#34;ff&#34;</strong><span><code>U+0066 U+0066</code><code>0x 66 66</code></span>
</span>, <span><strong>&#34;fi&#34;</strong><span><code>U+0066 U+0069</code><code>0x 66 69</code></span>
</span>, and <span><strong>&#34;ffi&#34;</strong><span><code>U+0066 U+0066 U+0069</code><code>0x 66 66 69</code></span>
</span>queries.</li></ul><h3 id="folding-invariants">Folding Invariants</h3><p><a href="https://home.unicode.org/">Unicode 17.0</a> defines more than 1000 locale-agnostic mappings in <code>CaseFolding.txt</code>, with expansions up to 3 codepoints.
The obvious approach to case-insensitive search is to case-fold everything and then run <a href="https://man7.org/linux/man-pages/man3/memmem.3.html"><code>memmem</code></a>.
Itâ€™s also the slowest possible approach, and it breaks match offsets unless you keep an extra mapping layer.</p><p>StringZilla takes a different route: it tries very hard to find a <strong>fold-safe window</strong> in the needle - a slice that:</p><ul><li>Can be case-folded into â‰¤16 bytes.</li><li>Doesnâ€™t trigger surprises for a chosen SIMD path: no shrinking expansions, no ligatures, no folding targets like Kelvin sign.</li><li>Has enough byte diversity to be a good SIMD filter.</li></ul><p>To do that, we split Unicode into a handful of script-ish buckets and give each its own SIMD kernel and its own <strong>alarm rules</strong>:</p><ul><li><strong>ASCII invariants</strong> (<code>00</code>â€“<code>7F</code>): the cheapest kernel; most English letters, digits, and punctuation.</li><li><strong>Western European</strong> (mostly 2-byte UTF-8): Latin-1 Supplement + Latin Extended-A, covering German/French/Spanish/Portuguese.</li><li><strong>Central European</strong> (mostly 2-byte UTF-8): Latin Extended-B and friends, covering Polish/Czech/Hungarian/Romanian.</li><li><strong>Cyrillic</strong> (<code>D0</code>/<code>D1</code> lead bytes): Russian/Ukrainian/Bulgarian and other Slavic languages.</li><li><strong>Greek</strong> (<code>CE</code>/<code>CF</code> lead bytes): Greek and Coptic.</li><li><strong>Armenian</strong> (<code>D4</code> lead byte): Armenian.</li><li><strong>Vietnamese</strong> (many 3-byte sequences): Latin extensions with diacritics and tone marks.</li></ul><p>Most of those kernels are designed around 1- and 2-byte UTF-8 sequences, which already cover the majority of European languages.
Vietnamese is the odd one out: it pulls in a lot of 3-byte Latin extensions with diacritics.</p><p>All of them not only differ in the folding kernels used on the hot path, but also in their alarm logic that triggers a slow-path verifier.
Those alarms exist for two reasons:</p><ul><li>Some characters fold into targets you really donâ€™t want to â€œjust allowâ€ in an ASCII fast path.
Example: <span><strong>&#39;â„ª&#39;</strong><span><code>U+212A</code><code>0x E2 84 AA</code></span>
</span>folds into <span><strong>&#39;k&#39;</strong><span><code>U+006B</code><code>0x 6B</code></span>
</span>.</li><li>Some folds shrink or expand in ways that break â€œsame length, same offsetsâ€ assumptions.
Example: <span><strong>&#39;Å¿&#39;</strong><span><code>U+017F</code><code>0x C5 BF</code></span>
</span>folds into <span><strong>&#39;s&#39;</strong><span><code>U+0073</code><code>0x 73</code></span>
</span>.</li></ul><p>This is why some ASCII letters are â€œunsafeâ€ depending on where they appear.
Not because they are rare, but because Unicode expansions can generate them.
Here are a few that matter in practice:</p><ul><li><strong>â€œkâ€</strong> is a folding target (Kelvin sign), so you canâ€™t just treat it as a boring ASCII byte.</li><li><strong>â€œsâ€</strong> is a folding target (long s), and <span><strong>&#39;ÃŸ&#39;</strong><span><code>U+00DF</code><code>0x C3 9F</code></span>
</span>folds into <span><strong>&#34;ss&#34;</strong><span><code>U+0073 U+0073</code><code>0x 73 73</code></span>
</span>.</li><li><strong>â€œfâ€</strong> and <strong>â€œiâ€</strong> participate in ligatures like <span><strong>&#39;ï¬&#39;</strong><span><code>U+FB01</code><code>0x EF AC 81</code></span>
</span>â†’ <span><strong>&#34;fi&#34;</strong><span><code>U+0066 U+0069</code><code>0x 66 69</code></span>
</span>.</li></ul><p>If youâ€™d like to stare at the full ban logic, grep for <code>sz_utf8_case_rune_safety_profile_</code> in the source.
Itâ€™s not poetry, but itâ€™s deterministic.</p><h3 id="safe-window-selection">Safe Window Selection</h3><p>Most needles arenâ€™t fully â€œsafeâ€.
So instead of folding the entire needle (slow, offset-hostile), we extract a window that is safe to SIMD-scan and use it as a pivot.
The needle splits into three pieces:</p><pre tabindex="0"><code>needle (bytes):   [ head ][ safe window ][ tail ]
needle (folded):  [ .... ][  &lt;=16 bytes ][ .... ]
SIMD scans only:          [  &lt;=16 bytes ]
</code></pre><p>Then every SIMD hit goes through a verifier that checks the head and tail around it.
The â€œwhyâ€ is easiest to see on a tiny example.
The needle <code>&#34;faÃŸade&#34;</code> contains <span><strong>&#39;ÃŸ&#39;</strong><span><code>U+00DF</code><code>0x C3 9F</code></span>
</span>, which is toxic for an ASCII fast path, but it also contains <code>&#34;ade&#34;</code>:</p><pre tabindex="0"><code>needle chars:   f  a  ÃŸ     a  d  e
needle bytes:   66 61 C3 9F 61 64 65
folded bytes:   66 61 73 73 61 64 65    (ÃŸ â†’ ss)
safe window:                61 64 65    (&#34;ade&#34;)
</code></pre><p>So we SIMD-search <code>&#34;ade&#34;</code> and only then do the extra legwork for the <code>&#34;faÃŸ&#34;</code> prefix (and possibly tail).
To pick optimal safe windows, we follow this algorithm:</p><ol><li>Walk possible start positions in the needle, stepping by UTF-8 characters - never mid-character.</li><li>For each start, fold forward and build per-script windows until you hit 16 bytes or an alarm.</li><li>Score candidates by byte diversity to minimize false positives on the hot SIMD path.</li><li>Pick the cheapest kernel that is both safe and applicable.</li></ol><p>If the same window is safe for multiple kernels (e.g., pure ASCII), we pick the cheapest one so we donâ€™t pay the Vietnamese folding tax for <code>&#34;xyz&#34;</code>.</p><h3 id="why-we-probe-last-bytes">Why We Probe Last Bytes</h3><p>This ties back to the UTF-8 primer: the continuation bytes (<code>10xxxxxx</code>) carry 6 payload bits each, while the leading bytes mostly encode the range.
In many scripts, that means the first byte is boring and the last byte carries the entropy.
Take Cyrillic as an example:</p><pre tabindex="0"><code>Ğ      Ğ‘      Ğ’     ... (Cyrillic alphabet)
D0 90, D0 91, D0 92 ... (leading byte repeats)
   ^^     ^^     ^^     (last byte differentiates)
</code></pre><p>If you probe the last bytes of UTF-8 characters, you get a much better SIMD filter: fewer false positives, less verifier work.
So for windows with â‰¥4 UTF-8 characters we aim probes at the last byte of the 2nd and 3rd characters, plus the first and last bytes of the whole window.
For very short windows probes overlap - thatâ€™s expected.</p><h3 id="serial-fallbacks-danger-zones-rings-and-hashes">Serial Fallbacks: Danger Zones, Rings, and Hashes</h3><p>Not every platform supports SIMD, let alone AVX-512.
Some needles are too short, some scripts are too annoying, and sometimes an alarm goes off in the middle of a hot loop.
StringZilla uses a few serial fallbacks that are still Unicode-correct:</p><ul><li>For needles that fold into 1/2/3 runes, we use a hash-free scan over the folded rune stream.</li><li>For longer needles, we use a <a href="https://en.wikipedia.org/wiki/Rabin%E2%80%93Karp_algorithm">Rabin-Karp</a> style rolling hash over folded runes with a small ring buffer, and verify on collisions.</li><li>For â€œdanger zonesâ€ detected by SIMD alarms, we scan for a cheap 1-rune candidate and validate the full match with the same head/tail verifier.</li></ul><p>Thatâ€™s pretty much the core idea of <a href="https://github.com/ashvardanian/StringZilla/releases/tag/v4.5.0">StringZilla v4.5</a>.
Letâ€™s look at the numbers.</p><h2 id="performance-benchmarks">Performance Benchmarks</h2><p>The following numbers are obtained on the <a href="https://wortschatz.uni-leipzig.de/en/download/">Leipzig Wikipedia corpora</a>, providing 100 MB+ of real-world text data for each language.
The machine used was an AWS instance with AMD Zen 5 CPUs.
For context, only a subset of those scripts are cased (have upper/lowercase distinctions):</p><ul><li>Latin basic range covers ğŸ‡¬ğŸ‡§ English, ğŸ‡®ğŸ‡¹ Italian, ğŸ‡³ğŸ‡± Dutch.</li><li>Latin extended range covers ğŸ‡©ğŸ‡ª German, ğŸ‡«ğŸ‡· French, ğŸ‡ªğŸ‡¸ Spanish, ğŸ‡µğŸ‡¹ Portuguese, ğŸ‡µğŸ‡± Polish, ğŸ‡¨ğŸ‡¿ Czech, ğŸ‡¹ğŸ‡· Turkish, ğŸ‡»ğŸ‡³ Vietnamese with various Accents, HÃ¡Äky, and Tones.</li><li>Cyrillic covers ğŸ‡·ğŸ‡º Russian, ğŸ‡ºğŸ‡¦ Ukrainian.</li><li>Distinct alphabets cover ğŸ‡¬ğŸ‡· Greek and ğŸ‡¦ğŸ‡² Armenian.</li></ul><p>Other languages/scripts like ğŸ‡®ğŸ‡± Hebrew, ğŸ‡¸ğŸ‡¦ Arabic, ğŸ‡®ğŸ‡· Persian, ğŸ‡§ğŸ‡© Bengali, ğŸ‡®ğŸ‡³ Tamil, ğŸ‡¯ğŸ‡µ Japanese, ğŸ‡°ğŸ‡· Korean, and ğŸ‡¨ğŸ‡³ Chinese are caseless, and are included to demonstrate StringZillaâ€™s ability to scan through arbitrary text without losing performance.</p><h3 id="avx-512-against-serial-stringzilla">AVX-512 Against Serial StringZilla</h3><p>Before comparing to other libraries, StringZilla first implements serial baselines for all APIs it provides for CPU architectures that donâ€™t support some of our favorite fancy SIMD instructions.</p><table><thead><tr><th>Dataset Language</th><th>Base, GB/s</th><th>SIMD, GB/s</th><th>SIMD Gains</th><th></th><th>Dataset Language</th><th>Base, GB/s</th><th>SIMD, GB/s</th><th>SIMD Gains</th></tr></thead><tbody><tr><td>ğŸ‡¬ğŸ‡§ Eng</td><td>1.15</td><td>10.93</td><td><strong>11.9Ã—</strong></td><td></td><td>ğŸ‡®ğŸ‡¹ Ita</td><td>0.81</td><td>10.63</td><td><strong>14.7Ã—</strong></td></tr><tr><td>ğŸ‡³ğŸ‡± Dut</td><td>0.85</td><td>10.91</td><td><strong>13.3Ã—</strong></td><td></td><td>ğŸ‡©ğŸ‡ª Ger</td><td>0.74</td><td>9.36</td><td><strong>13.6Ã—</strong></td></tr><tr><td>ğŸ‡«ğŸ‡· Fra</td><td>0.73</td><td>8.37</td><td><strong>15.1Ã—</strong></td><td></td><td>ğŸ‡ªğŸ‡¸ Spa</td><td>0.99</td><td>8.86</td><td><strong>10.8Ã—</strong></td></tr><tr><td>ğŸ‡µğŸ‡¹ Por</td><td>0.77</td><td>9.58</td><td><strong>14.3Ã—</strong></td><td></td><td>ğŸ‡µğŸ‡± Pol</td><td>0.62</td><td>7.51</td><td><strong>14.2Ã—</strong></td></tr><tr><td>ğŸ‡¨ğŸ‡¿ Cze</td><td>0.43</td><td>6.10</td><td><strong>17.1Ã—</strong></td><td></td><td>ğŸ‡»ğŸ‡³ Vie</td><td>0.41</td><td>6.38</td><td><strong>17.9Ã—</strong></td></tr><tr><td>ğŸ‡·ğŸ‡º Rus</td><td>0.54</td><td>3.41</td><td><strong>10.6Ã—</strong></td><td></td><td>ğŸ‡ºğŸ‡¦ Ukr</td><td>0.56</td><td>4.03</td><td><strong>10.6Ã—</strong></td></tr><tr><td>ğŸ‡¬ğŸ‡· Gre</td><td>0.31</td><td>7.04</td><td><strong>22.5Ã—</strong></td><td></td><td>ğŸ‡¦ğŸ‡² Arm</td><td>0.34</td><td>4.18</td><td><strong>17.5Ã—</strong></td></tr><tr><td>ğŸ‡¹ğŸ‡· Tur</td><td>0.81</td><td>6.78</td><td><strong>11.7Ã—</strong></td><td></td><td>ğŸ‡¬ğŸ‡ª Geo Â¹</td><td>0.65</td><td>10.56</td><td><strong>24.2Ã—</strong></td></tr><tr><td>ğŸ‡®ğŸ‡± Heb â°</td><td>0.65</td><td>9.52</td><td><strong>13.7Ã—</strong></td><td></td><td>ğŸ‡¸ğŸ‡¦ Ara â°</td><td>1.17</td><td>9.85</td><td><strong>9.8Ã—</strong></td></tr><tr><td>ğŸ‡®ğŸ‡· Per â°</td><td>0.41</td><td>11.83</td><td><strong>43.1Ã—</strong></td><td></td><td>ğŸ‡¨ğŸ‡³ Chi â°</td><td>0.43</td><td>20.07</td><td><strong>103.0Ã—</strong></td></tr><tr><td>ğŸ‡§ğŸ‡© Ben â°</td><td>0.72</td><td>11.03</td><td><strong>25.9Ã—</strong></td><td></td><td>ğŸ‡®ğŸ‡³ Tam â°</td><td>1.09</td><td>11.70</td><td><strong>21.0Ã—</strong></td></tr><tr><td>ğŸ‡¯ğŸ‡µ Jap â°</td><td>0.52</td><td>11.56</td><td><strong>26.7Ã—</strong></td><td></td><td>ğŸ‡°ğŸ‡· Kor â°</td><td>2.98</td><td>11.58</td><td><strong>3.5Ã—</strong></td></tr></tbody></table><blockquote><p>â° Those speeds for caseless benchmarks are mostly dependent on the data location.
Not only are those scripts caseless, but furthermore - many donâ€™t use whitespace to mark word boundaries, so the benchmark is often running on much longer input queries than a single word.
Expect over 10 GB/s in most cases and over 30 GB/s for cached data.
Â¹ Georgian is effectively caseless in most modern text, but Unicode case folding still touches it via historical mappings, so it currently canâ€™t be accelerated with the ASCII-agnostic path.
In the future it will require a custom script.</p></blockquote><p>Our target is to reach 5 GB/s - the typical upper bound of a single NVMe SSD read speed or the approximate RAM throughput per core of modern many-core CPUs.
That target has been met for almost all languages, except Russian, Ukrainian, and Armenian.
Still, those already achieve 10â€“20Ã— speedups over the serial baseline and will be improved further in future releases.</p><h3 id="stringzilla-against-icu-and-memchr">StringZilla Against ICU and MemChr</h3><p>ICU has bindings for Rust that provide case-folding functionality, but not case-insensitive substring search.
So we do what most programmers do as a shortcut for such functionality - we case-fold the haystack and the needle, and then search one inside the other.
To fold we use <code>icu::CaseMapper::fold_string</code> and to search - the traditional <code>memchr::memmem::Finder</code>.
Those will yield different match offsets, but the overall number of matches will be the same - good enough for a benchmark.</p><table><thead><tr><th>Dataset Language</th><th>ICU, GB/s</th><th>SZ, GB/s</th><th>SZ Gains</th><th></th><th>Dataset Language</th><th>ICU, GB/s</th><th>SZ, GB/s</th><th>SZ Gains</th></tr></thead><tbody><tr><td>ğŸ‡¬ğŸ‡§ Eng</td><td>0.08</td><td>12.79</td><td><strong>152.0Ã—</strong></td><td></td><td>ğŸ‡®ğŸ‡¹ Ita</td><td>0.08</td><td>12.99</td><td><strong>153.0Ã—</strong></td></tr><tr><td>ğŸ‡³ğŸ‡± Dut</td><td>0.09</td><td>12.61</td><td><strong>142.0Ã—</strong></td><td></td><td>ğŸ‡©ğŸ‡ª Ger</td><td>0.08</td><td>10.67</td><td><strong>126.0Ã—</strong></td></tr><tr><td>ğŸ‡«ğŸ‡· Fra</td><td>0.09</td><td>10.77</td><td><strong>123.0Ã—</strong></td><td></td><td>ğŸ‡ªğŸ‡¸ Spa</td><td>0.09</td><td>11.62</td><td><strong>132.0Ã—</strong></td></tr><tr><td>ğŸ‡µğŸ‡¹ Por</td><td>0.09</td><td>10.72</td><td><strong>125.0Ã—</strong></td><td></td><td>ğŸ‡µğŸ‡± Pol</td><td>0.09</td><td>10.50</td><td><strong>122.0Ã—</strong></td></tr><tr><td>ğŸ‡¨ğŸ‡¿ Cze</td><td>0.09</td><td>7.41</td><td><strong>82.0Ã—</strong></td><td></td><td>ğŸ‡»ğŸ‡³ Vie</td><td>0.11</td><td>4.25</td><td><strong>40.0Ã—</strong></td></tr><tr><td>ğŸ‡·ğŸ‡º Rus</td><td>0.14</td><td>7.12</td><td><strong>50.0Ã—</strong></td><td></td><td>ğŸ‡ºğŸ‡¦ Ukr</td><td>0.14</td><td>8.88</td><td><strong>63.0Ã—</strong></td></tr><tr><td>ğŸ‡¬ğŸ‡· Gre</td><td>0.13</td><td>2.57</td><td><strong>20.0Ã—</strong></td><td></td><td>ğŸ‡¦ğŸ‡² Arm</td><td>0.19</td><td>0.98</td><td><strong>5.3Ã—</strong></td></tr><tr><td>ğŸ‡¹ğŸ‡· Tur</td><td>0.09</td><td>8.18</td><td><strong>96.0Ã—</strong></td><td></td><td>ğŸ‡¬ğŸ‡ª Geo Â¹</td><td>0.19</td><td>1.03</td><td><strong>5.5Ã—</strong></td></tr><tr><td>ğŸ‡®ğŸ‡± Heb â°</td><td>0.19</td><td>34.54</td><td><strong>181.0Ã—</strong></td><td></td><td>ğŸ‡¸ğŸ‡¦ Ara â°</td><td>0.20</td><td>38.55</td><td><strong>196.0Ã—</strong></td></tr><tr><td>ğŸ‡®ğŸ‡· Per â°</td><td>0.19</td><td>26.22</td><td><strong>139.0Ã—</strong></td><td></td><td>ğŸ‡¨ğŸ‡³ Chi â°</td><td>0.24</td><td>25.65</td><td><strong>106.0Ã—</strong></td></tr><tr><td>ğŸ‡§ğŸ‡© Ben â°</td><td>0.30</td><td>28.20</td><td><strong>95.0Ã—</strong></td><td></td><td>ğŸ‡®ğŸ‡³ Tam â°</td><td>0.27</td><td>29.53</td><td><strong>110.0Ã—</strong></td></tr><tr><td>ğŸ‡¯ğŸ‡µ Jap â°</td><td>0.22</td><td>21.71</td><td><strong>101.0Ã—</strong></td><td></td><td>ğŸ‡°ğŸ‡· Kor â°</td><td>0.23</td><td>35.10</td><td><strong>150.0Ã—</strong></td></tr></tbody></table><blockquote><p>The StringZilla numbers in this table are obtained from separate runs of the <a href="https://github.com/ashvardanian/StringWars">StringWars</a> Rust suite, different from the StringZillaâ€™s own C++ benchmarks that compare internal backends against each other - so the numbers may slightly differ from the previous table.</p></blockquote><p>Despite the fact that raw <code>memmem</code> throughput can exceed 10 GB/s on already-folded text, the fold &amp; scan pipeline is typically dominated by case folding, and sits around 100-300 MB/s.
A typical throughput of StringZillaâ€™s fold &amp; scan pipeline is between 5 and 15 GB/s, suggesting a 50Ã— improvement.</p><h3 id="stringzilla-against-pcre2">StringZilla Against PCRE2</h3><p>PCRE2 is the workhorse of the digital age.
Itâ€™s by far the most popular RegEx engine ever written.
Itâ€™s not even remotely as fast as <a href="https://github.com/geofflangdale">Geoff Langdale</a>â€™s <a href="https://github.com/intel/hyperscan">HyperScan</a> or <a href="https://github.com/BurntSushi">Andrew Gallant</a>â€™s <a href="https://github.com/rust-lang/regex">Rust RegEx</a> engine, but itâ€™s one of the few that support full Unicode case-insensitive matching.
RegEx is clearly a lot harder than substring search, but in the absence of better reference points, Iâ€™m also sharing the numbers one can get with PCRE2, enabling its JIT engine to precompile the automata for every needle, and excluding that time from benchmarks.</p><table><thead><tr><th>Dataset Language</th><th>PCRE2, GB/s</th><th>SZ, GB/s</th><th>SZ Gains</th><th></th><th>Dataset Language</th><th>PCRE2, GB/s</th><th>SZ, GB/s</th><th>SZ Gains</th></tr></thead><tbody><tr><td>ğŸ‡¬ğŸ‡§ Eng</td><td>1.42</td><td>12.79</td><td><strong>9.0Ã—</strong></td><td></td><td>ğŸ‡®ğŸ‡¹ Ita</td><td>0.26</td><td>12.99</td><td><strong>51.0Ã—</strong></td></tr><tr><td>ğŸ‡³ğŸ‡± Dut</td><td>0.37</td><td>12.61</td><td><strong>34.0Ã—</strong></td><td></td><td>ğŸ‡©ğŸ‡ª Ger</td><td>1.24</td><td>10.67</td><td><strong>8.6Ã—</strong></td></tr><tr><td>ğŸ‡«ğŸ‡· Fra</td><td>0.13</td><td>10.77</td><td><strong>80.0Ã—</strong></td><td></td><td>ğŸ‡ªğŸ‡¸ Spa</td><td>0.98</td><td>11.62</td><td><strong>12.0Ã—</strong></td></tr><tr><td>ğŸ‡µğŸ‡¹ Por</td><td>0.64</td><td>10.72</td><td><strong>17.0Ã—</strong></td><td></td><td>ğŸ‡µğŸ‡± Pol</td><td>0.22</td><td>10.50</td><td><strong>48.0Ã—</strong></td></tr><tr><td>ğŸ‡¨ğŸ‡¿ Cze</td><td>0.28</td><td>7.41</td><td><strong>27.0Ã—</strong></td><td></td><td>ğŸ‡»ğŸ‡³ Vie</td><td>0.03</td><td>4.25</td><td><strong>134.0Ã—</strong></td></tr><tr><td>ğŸ‡·ğŸ‡º Rus</td><td>0.25</td><td>7.12</td><td><strong>28.0Ã—</strong></td><td></td><td>ğŸ‡ºğŸ‡¦ Ukr</td><td>0.21</td><td>8.88</td><td><strong>42.0Ã—</strong></td></tr><tr><td>ğŸ‡¬ğŸ‡· Gre</td><td>0.37</td><td>2.57</td><td><strong>6.9Ã—</strong></td><td></td><td>ğŸ‡¦ğŸ‡² Arm</td><td>0.42</td><td>0.98</td><td><strong>2.3Ã—</strong></td></tr><tr><td>ğŸ‡¹ğŸ‡· Tur</td><td>0.44</td><td>8.18</td><td><strong>19.0Ã—</strong></td><td></td><td>ğŸ‡¬ğŸ‡ª Geo Â¹</td><td>0.33</td><td>1.03</td><td><strong>3.1Ã—</strong></td></tr><tr><td>ğŸ‡®ğŸ‡± Heb â°</td><td>0.25</td><td>34.54</td><td><strong>137.0Ã—</strong></td><td></td><td>ğŸ‡¸ğŸ‡¦ Ara â°</td><td>0.30</td><td>38.55</td><td><strong>128.0Ã—</strong></td></tr><tr><td>ğŸ‡®ğŸ‡· Per â°</td><td>0.19</td><td>26.22</td><td><strong>141.0Ã—</strong></td><td></td><td>ğŸ‡¨ğŸ‡³ Chi â°</td><td>0.94</td><td>25.65</td><td><strong>27.0Ã—</strong></td></tr><tr><td>ğŸ‡§ğŸ‡© Ben â°</td><td>0.73</td><td>28.20</td><td><strong>39.0Ã—</strong></td><td></td><td>ğŸ‡®ğŸ‡³ Tam â°</td><td>0.26</td><td>29.53</td><td><strong>114.0Ã—</strong></td></tr><tr><td>ğŸ‡¯ğŸ‡µ Jap â°</td><td>0.89</td><td>21.71</td><td><strong>24.0Ã—</strong></td><td></td><td>ğŸ‡°ğŸ‡· Kor â°</td><td>0.65</td><td>35.10</td><td><strong>54.0Ã—</strong></td></tr></tbody></table><blockquote><p>The StringZilla numbers in this table are exactly the same as in the previous table, only the baseline has changed from ICU to PCRE2.</p></blockquote><p>Itâ€™s clearly not an apples-to-apples comparison, but if you are writing scripts with lots of case-insensitive matching, be informed that a better option exists.</p><blockquote><p>Funny enough, in 2019, 4 years into building <a href="https://unum.cloud">Unum</a>, before moving to Armenia, Iâ€™ve spent several days working on a RegEx engine leveraging similar optimizations to the ones described here, but still lost to HyperScan at the time.
Six years have passed and just like every other geek passionate about software - there is always one more project to finalize before returning to that one!</p></blockquote><h3 id="stringzilla-against-icu-built-in-search">StringZilla Against ICU Built-in Search</h3><blockquote><p>Iâ€™ve just told you that ICU doesnâ€™t provide case-insensitive substring search two paragraphs ago.
100Ã— speedups donâ€™t exist.
This article is clearly a scam ğŸ˜‚</p></blockquote><p>ICU has many bindings.
The Rust one doesnâ€™t expose any substring search functionality, but the Python one does:</p><div><div><table><tbody><tr><td><pre tabindex="0"><code><span id="hl-6-1"><a href="#hl-6-1">1</a>
</span><span id="hl-6-2"><a href="#hl-6-2">2</a>
</span><span id="hl-6-3"><a href="#hl-6-3">3</a>
</span><span id="hl-6-4"><a href="#hl-6-4">4</a>
</span><span id="hl-6-5"><a href="#hl-6-5">5</a>
</span><span id="hl-6-6"><a href="#hl-6-6">6</a>
</span><span id="hl-6-7"><a href="#hl-6-7">7</a>
</span><span id="hl-6-8"><a href="#hl-6-8">8</a>
</span><span id="hl-6-9"><a href="#hl-6-9">9</a>
</span></code></pre></td><td><pre tabindex="0"><code data-lang="python"><span><span><span>import</span> <span>icu</span>
</span></span><span><span>
</span></span><span><span><span>collator</span> <span>=</span> <span>icu</span><span>.</span><span>Collator</span><span>.</span><span>createInstance</span><span>(</span><span>icu</span><span>.</span><span>Locale</span><span>.</span><span>getRoot</span><span>())</span>
</span></span><span><span><span>collator</span><span>.</span><span>setStrength</span><span>(</span><span>icu</span><span>.</span><span>Collator</span><span>.</span><span>SECONDARY</span><span>)</span>  <span># Case-insensitive</span>
</span></span><span><span><span>searcher</span> <span>=</span> <span>icu</span><span>.</span><span>StringSearch</span><span>(</span><span>needle</span><span>,</span> <span>haystack</span><span>,</span> <span>collator</span><span>)</span>
</span></span><span><span><span>last_offset</span><span>,</span> <span>count_matches</span> <span>=</span> <span>searcher</span><span>.</span><span>nextMatch</span><span>(),</span> <span>0</span>
</span></span><span><span>
</span></span><span><span><span>while</span> <span>last_offset</span> <span>!=</span> <span>-</span><span>1</span><span>:</span>
</span></span><span><span>    <span>last_offset</span><span>,</span> <span>count_matches</span> <span>=</span> <span>searcher</span><span>.</span><span>nextMatch</span><span>(),</span> <span>count_matches</span> <span>+</span> <span>1</span>
</span></span></code></pre></td></tr></tbody></table></div></div><p>Luckily, StringWars benchmarks have Python counterparts, and StringZilla also has pure CPython <a href="https://peps.python.org/pep-0590/"><code>METH_FASTCALL</code></a> bindings (some of the thinest in the industry, of course).
Moreover, Python has a separate <a href="https://github.com/mrabarnett/mrab-regex">RegEx library</a> written by <a href="https://github.com/mrabarnett">Matthew Barnett</a> in C.
It implements full Unicode casefolding, correctly handles the German example in the beginning of this article, and is quite easy to use:</p><div><div><table><tbody><tr><td><pre tabindex="0"><code><span id="hl-7-1"><a href="#hl-7-1">1</a>
</span><span id="hl-7-2"><a href="#hl-7-2">2</a>
</span><span id="hl-7-3"><a href="#hl-7-3">3</a>
</span><span id="hl-7-4"><a href="#hl-7-4">4</a>
</span></code></pre></td><td><pre tabindex="0"><code data-lang="python"><span><span><span>import</span> <span>regex</span>
</span></span><span><span>
</span></span><span><span><span>pattern</span> <span>=</span> <span>regex</span><span>.</span><span>compile</span><span>(</span><span>regex</span><span>.</span><span>escape</span><span>(</span><span>needle</span><span>),</span> <span>regex</span><span>.</span><span>IGNORECASE</span> <span>|</span> <span>regex</span><span>.</span><span>FULLCASE</span><span>)</span>
</span></span><span><span><span>count_matches</span> <span>=</span> <span>sum</span><span>(</span><span>1</span> <span>for</span> <span>_</span> <span>in</span> <span>pattern</span><span>.</span><span>finditer</span><span>(</span><span>haystack</span><span>))</span>
</span></span></code></pre></td></tr></tbody></table></div></div><p>This might be an interesting comparison point, assuming its the same workload for the same datasets, but a different language.</p><table><thead><tr><th>Dataset Language</th><th>ICU, GB/s</th><th>RegEx, GB/s</th><th>SZ, GB/s</th><th></th><th>Dataset Language</th><th>ICU, GB/s</th><th>RegEx, GB/s</th><th>SZ, GB/s</th></tr></thead><tbody><tr><td>ğŸ‡¬ğŸ‡§ Eng</td><td>0.06</td><td>0.77</td><td><strong>5.61</strong></td><td></td><td>ğŸ‡®ğŸ‡¹ Ita</td><td>0.06</td><td>0.97</td><td><strong>8.87</strong></td></tr><tr><td>ğŸ‡³ğŸ‡± Dut</td><td>0.06</td><td>0.86</td><td><strong>7.99</strong></td><td></td><td>ğŸ‡©ğŸ‡ª Ger</td><td>0.06</td><td>0.90</td><td><strong>6.08</strong></td></tr><tr><td>ğŸ‡«ğŸ‡· Fra</td><td>0.06</td><td>1.10</td><td><strong>6.83</strong></td><td></td><td>ğŸ‡ªğŸ‡¸ Spa</td><td>0.06</td><td>1.02</td><td><strong>6.33</strong></td></tr><tr><td>ğŸ‡µğŸ‡¹ Por</td><td>0.06</td><td>1.10</td><td><strong>8.12</strong></td><td></td><td>ğŸ‡µğŸ‡± Pol</td><td>0.06</td><td>1.29</td><td><strong>8.02</strong></td></tr><tr><td>ğŸ‡¨ğŸ‡¿ Cze</td><td>0.06</td><td>1.38</td><td><strong>6.36</strong></td><td></td><td>ğŸ‡»ğŸ‡³ Vie</td><td>0.05</td><td>1.07</td><td><strong>1.12</strong></td></tr><tr><td>ğŸ‡·ğŸ‡º Rus</td><td>0.10</td><td>2.30</td><td><strong>5.70</strong></td><td></td><td>ğŸ‡ºğŸ‡¦ Ukr</td><td>0.10</td><td>2.26</td><td><strong>5.35</strong></td></tr><tr><td>ğŸ‡¬ğŸ‡· Gre</td><td>0.09</td><td>1.38</td><td><strong>2.48</strong></td><td></td><td>ğŸ‡¦ğŸ‡² Arm</td><td>0.11</td><td><strong>2.07</strong></td><td>0.86</td></tr><tr><td>ğŸ‡¹ğŸ‡· Tur</td><td>0.06</td><td>1.49</td><td><strong>5.25</strong></td><td></td><td>ğŸ‡¬ğŸ‡ª Geo</td><td>0.16</td><td><strong>3.20</strong></td><td>0.62</td></tr><tr><td>ğŸ‡®ğŸ‡± Heb</td><td>0.11</td><td>2.92</td><td><strong>15.72</strong></td><td></td><td>ğŸ‡¸ğŸ‡¦ Ara</td><td>0.08</td><td>3.01</td><td><strong>14.78</strong></td></tr><tr><td>ğŸ‡®ğŸ‡· Per</td><td>0.09</td><td>2.36</td><td><strong>10.70</strong></td><td></td><td>ğŸ‡¨ğŸ‡³ Chi</td><td>0.09</td><td>5.40</td><td><strong>13.94</strong></td></tr><tr><td>ğŸ‡§ğŸ‡© Ben</td><td>0.14</td><td>4.51</td><td><strong>21.19</strong></td><td></td><td>ğŸ‡®ğŸ‡³ Tam</td><td>0.16</td><td>5.81</td><td><strong>23.11</strong></td></tr><tr><td>ğŸ‡¯ğŸ‡µ Jap</td><td>0.10</td><td>4.88</td><td><strong>13.17</strong></td><td></td><td>ğŸ‡°ğŸ‡· Kor</td><td>0.06</td><td>4.59</td><td><strong>20.05</strong></td></tr></tbody></table><p>I was genuinely quite surprised that the <code>regex</code> module outperformed <code>stringzilla</code> on Armenian, so there must be a lot more things I can optimize in future releases.
In the meantime, feel free to reproduce the benchmarks on your hardware, but keep in mind that the numbers wonâ€™t be as impressive if you donâ€™t have AVX-512.
More ISA backends will come in the future.</p><h3 id="reproducing-benchmarks">Reproducing Benchmarks</h3><p>The original Serial vs AVX-512 benchmarks can be found right inside the StringZilla repository.
To run it locally:</p><div><div><table><tbody><tr><td><pre tabindex="0"><code><span id="hl-8-1"><a href="#hl-8-1">1</a>
</span><span id="hl-8-2"><a href="#hl-8-2">2</a>
</span><span id="hl-8-3"><a href="#hl-8-3">3</a>
</span><span id="hl-8-4"><a href="#hl-8-4">4</a>
</span><span id="hl-8-5"><a href="#hl-8-5">5</a>
</span><span id="hl-8-6"><a href="#hl-8-6">6</a>
</span><span id="hl-8-7"><a href="#hl-8-7">7</a>
</span><span id="hl-8-8"><a href="#hl-8-8">8</a>
</span><span id="hl-8-9"><a href="#hl-8-9">9</a>
</span></code></pre></td><td><pre tabindex="0"><code data-lang="bash"><span><span>git clone https://github.com/ashvardanian/StringZilla.git <span>&amp;&amp;</span> <span>cd</span> StringZilla
</span></span><span><span>cmake -D <span>STRINGZILLA_BUILD_BENCHMARK</span><span>=</span><span>1</span> -B build_release
</span></span><span><span>cmake --build build_release --config Release --target stringzilla_bench_unicode_cpp20
</span></span><span><span>
</span></span><span><span><span>STRINGWARS_DATASET</span><span>=</span>README.md <span>\
</span></span></span><span><span><span></span>    <span>STRINGWARS_TOKENS</span><span>=</span>words <span>\
</span></span></span><span><span><span></span>    <span>STRINGWARS_DURATION</span><span>=</span><span>30</span> <span>\
</span></span></span><span><span><span></span>    <span>STRINGWARS_FILTER</span><span>=</span><span>&#34;case_insensitive_find&#34;</span> <span>\
</span></span></span><span><span><span></span>    build_release/stringzilla_bench_unicode_cpp20
</span></span></code></pre></td></tr></tbody></table></div></div><p>For the Rust StringWars suite the similar environment variables can be used:</p><div><div><table><tbody><tr><td><pre tabindex="0"><code><span id="hl-9-1"><a href="#hl-9-1">1</a>
</span><span id="hl-9-2"><a href="#hl-9-2">2</a>
</span><span id="hl-9-3"><a href="#hl-9-3">3</a>
</span><span id="hl-9-4"><a href="#hl-9-4">4</a>
</span><span id="hl-9-5"><a href="#hl-9-5">5</a>
</span><span id="hl-9-6"><a href="#hl-9-6">6</a>
</span><span id="hl-9-7"><a href="#hl-9-7">7</a>
</span></code></pre></td><td><pre tabindex="0"><code data-lang="bash"><span><span>git clone https://github.com/ashvardanian/StringWars.git <span>&amp;&amp;</span> <span>cd</span> StringWars
</span></span><span><span>
</span></span><span><span><span>STRINGWARS_DATASET</span><span>=</span>README.md <span>\
</span></span></span><span><span><span></span>    <span>STRINGWARS_TOKENS</span><span>=</span>words <span>\
</span></span></span><span><span><span></span>    <span>STRINGWARS_FILTER</span><span>=</span><span>&#34;case-insensitive-find&#34;</span> <span>\
</span></span></span><span><span><span></span>    <span>RUSTFLAGS</span><span>=</span><span>&#34;-C target-cpu=native&#34;</span> <span>\
</span></span></span><span><span><span></span>    cargo criterion --features <span>&#34;bench_unicode&#34;</span> bench_unicode --jobs <span>1</span>
</span></span></code></pre></td></tr></tbody></table></div></div><p>Similarly, for the Python benchmarks:</p><div><div><table><tbody><tr><td><pre tabindex="0"><code><span id="hl-10-1"><a href="#hl-10-1">1</a>
</span><span id="hl-10-2"><a href="#hl-10-2">2</a>
</span><span id="hl-10-3"><a href="#hl-10-3">3</a>
</span><span id="hl-10-4"><a href="#hl-10-4">4</a>
</span><span id="hl-10-5"><a href="#hl-10-5">5</a>
</span><span id="hl-10-6"><a href="#hl-10-6">6</a>
</span></code></pre></td><td><pre tabindex="0"><code data-lang="bash"><span><span>git clone https://github.com/ashvardanian/StringWars.git <span>&amp;&amp;</span> <span>cd</span> StringWars
</span></span><span><span>
</span></span><span><span><span>STRINGWARS_DATASET</span><span>=</span>README.md <span>\
</span></span></span><span><span><span></span>    <span>STRINGWARS_TOKENS</span><span>=</span>words <span>\
</span></span></span><span><span><span></span>    <span>STRINGWARS_FILTER</span><span>=</span><span>&#34;case-insensitive-find&#34;</span> <span>\
</span></span></span><span><span><span></span>    uv run bench_unicode.py
</span></span></code></pre></td></tr></tbody></table></div></div><p>To run on the same files, fetch the datasets listed in <a href="https://github.com/ashvardanian/StringWars?tab=readme-ov-file#leipzig-corpora-collection">StringWars</a>, and pull them with <code>curl</code> like this:</p><div><div><table><tbody><tr><td><pre tabindex="0"><code><span id="hl-11-1"><a href="#hl-11-1">1</a>
</span><span id="hl-11-2"><a href="#hl-11-2">2</a>
</span><span id="hl-11-3"><a href="#hl-11-3">3</a>
</span></code></pre></td><td><pre tabindex="0"><code data-lang="bash"><span><span>curl -fL https://downloads.wortschatz-leipzig.de/corpora/eng_wikipedia_2016_1M.tar.gz <span>|</span> tar -xzf - -O <span>&#39;eng_wikipedia_2016_1M/eng_wikipedia_2016_1M-sentences.txt&#39;</span> <span>|</span> cut -f2 &gt; leipzig1M_en.txt
</span></span><span><span>curl -fL https://downloads.wortschatz-leipzig.de/corpora/deu_wikipedia_2021_1M.tar.gz <span>|</span> tar -xzf - -O <span>&#39;deu_wikipedia_2021_1M/deu_wikipedia_2021_1M-sentences.txt&#39;</span> <span>|</span> cut -f2 &gt; leipzig1M_de.txt
</span></span><span><span>curl -fL https://downloads.wortschatz-leipzig.de/corpora/rus_wikipedia_2021_1M.tar.gz <span>|</span> tar -xzf - -O <span>&#39;rus_wikipedia_2021_1M/rus_wikipedia_2021_1M-sentences.txt&#39;</span> <span>|</span> cut -f2 &gt; leipzig1M_ru.txt
</span></span></code></pre></td></tr></tbody></table></div></div><h2 id="kernel-optimizations">Kernel Optimizations</h2><p>Every script family has its own folding kernel and â€œalarmâ€.
The fold rewrites bytes in place so probes can reuse the same verifier, while the alarm spots ligatures or shrinking expansions that require a slow-path correction.
The â€œnaiveâ€ approach is to check equality against each byte value, then prefix-AND masks of consecutive 1-, 2-, or 3-byte sequences, and finally OR all danger masks together.</p><blockquote><p>In the Unicode 17 folding tables we target, multi-codepoint fold expansions never produce 4-byte UTF-8 sequences, so the expansion slow-path can safely ignore them.</p></blockquote><p>That, however, introduces a remarkable amount of port pressure on x86 CPUs.
The <code>VPCMPB K, ZMM, ZMM</code> instruction takes:</p><ul><li>3 cycles on port 5 on Ice Lake.</li><li>5 cycles on ports 0 or 1 on AMD Zen 4.</li></ul><p>Shifting the produced masks between <code>K</code> registers and ALUs and expanding them back to ZMMs for further processing is similarly expensive.
So next to every â€œnaiveâ€ baseline kernel for AVX-512 - I wrote â€œefficientâ€ versions using harder-to-trace logic, but comparing every streamed-through buffer against the â€œnaiveâ€ baseline in debug builds to ensure correctness.</p><h3 id="equality-comparisons-port-pressure">Equality Comparisons Port Pressure</h3><p>The Western/Central alarms originally hammered port 5 with 12+ equality checks every 64 bytes.
By compressing entire ranges into a single subtraction + comparison and deriving the actual member with <code>VPTESTNMB</code>, we freed the port for real work.</p><div><div><table><tbody><tr><td><pre tabindex="0"><code><span id="hl-12-1"><a href="#hl-12-1">1</a>
</span><span id="hl-12-2"><a href="#hl-12-2">2</a>
</span><span id="hl-12-3"><a href="#hl-12-3">3</a>
</span><span id="hl-12-4"><a href="#hl-12-4">4</a>
</span></code></pre></td><td><pre tabindex="0"><code data-lang="c"><span><span><span>__mmask64</span> <span>in_e1_e2</span> <span>=</span> <span>_mm512_cmplt_epu8_mask</span><span>(</span><span>off_e1</span><span>,</span> <span>_mm512_set1_epi8</span><span>(</span><span>0x02</span><span>));</span>
</span></span><span><span><span>__mmask64</span> <span>is_e1</span> <span>=</span> <span>in_e1_e2</span> <span>&amp;</span> <span>_mm512_testn_epi8_mask</span><span>(</span><span>off_e1</span><span>,</span> <span>off_e1</span><span>);</span>
</span></span><span><span><span>__mmask64</span> <span>is_e2</span> <span>=</span> <span>in_e1_e2</span> <span>&amp;</span> <span>~</span><span>is_e1</span><span>;</span>
</span></span><span><span><span>__mmask64</span> <span>danger</span> <span>=</span> <span>((</span><span>is_e1</span> <span>&lt;&lt;</span> <span>1</span><span>)</span> <span>&amp;</span> <span>is_ba</span><span>)</span> <span>|</span> <span>((</span><span>is_e2</span> <span>&lt;&lt;</span> <span>1</span><span>)</span> <span>&amp;</span> <span>is_84</span><span>);</span>
</span></span></code></pre></td></tr></tbody></table></div></div><p>Central Europe performs the same trick for the <code>C3</code>â€“<code>C5</code> block: one range check plus two ternary tests produce the <strong>â€˜â„ªâ€™</strong>/<strong>â€˜ÃŸâ€™</strong>/<strong>â€˜Ä°â€™</strong>/<strong>â€˜Å¿â€™</strong> masks without congesting the execution unit.</p><div><div><table><tbody><tr><td><pre tabindex="0"><code><span id="hl-13-1"><a href="#hl-13-1">1</a>
</span><span id="hl-13-2"><a href="#hl-13-2">2</a>
</span><span id="hl-13-3"><a href="#hl-13-3">3</a>
</span></code></pre></td><td><pre tabindex="0"><code data-lang="c"><span><span><span>__mmask64</span> <span>in_c3_c5</span> <span>=</span> <span>_mm512_cmplt_epu8_mask</span><span>(</span><span>off_c3</span><span>,</span> <span>_mm512_set1_epi8</span><span>(</span><span>0x03</span><span>));</span>
</span></span><span><span><span>__mmask64</span> <span>is_c3</span> <span>=</span> <span>in_c3_c5</span> <span>&amp;</span> <span>_mm512_testn_epi8_mask</span><span>(</span><span>off_c3</span><span>,</span> <span>off_c3</span><span>);</span>
</span></span><span><span><span>__mmask64</span> <span>is_c5</span> <span>=</span> <span>in_c3_c5</span> <span>&amp;</span> <span>_mm512_testn_epi8_mask</span><span>(</span><span>_mm512_xor_si512</span><span>(</span><span>off_c3</span><span>,</span> <span>x_02</span><span>),</span> <span>_mm512_xor_si512</span><span>(</span><span>off_c3</span><span>,</span> <span>x_02</span><span>));</span>
</span></span></code></pre></td></tr></tbody></table></div></div><h3 id="ternary-logic-and-blends">Ternary Logic and Blends</h3><p>The ASCII fast path leans on ternary logic.
For â‰¤3-byte windows we broadcast the first/middle/last byte, XOR the haystack at three offsets, merge via <code>VPTERNLOG</code> (imm8 <code>0xFE</code>), and let <code>VPTESTNMB</code> turn zero lanes into positions.
No extra window replay is needed because all bytes are covered.</p><div><div><table><tbody><tr><td><pre tabindex="0"><code><span id="hl-14-1"><a href="#hl-14-1">1</a>
</span><span id="hl-14-2"><a href="#hl-14-2">2</a>
</span><span id="hl-14-3"><a href="#hl-14-3">3</a>
</span><span id="hl-14-4"><a href="#hl-14-4">4</a>
</span><span id="hl-14-5"><a href="#hl-14-5">5</a>
</span></code></pre></td><td><pre tabindex="0"><code data-lang="c"><span><span><span>__m512i</span> <span>diff0</span> <span>=</span> <span>_mm512_xor_si512</span><span>(</span><span>h0</span><span>,</span> <span>probe0</span><span>);</span>
</span></span><span><span><span>__m512i</span> <span>diff1</span> <span>=</span> <span>_mm512_xor_si512</span><span>(</span><span>h1</span><span>,</span> <span>probe1</span><span>);</span>
</span></span><span><span><span>__m512i</span> <span>diff2</span> <span>=</span> <span>_mm512_xor_si512</span><span>(</span><span>h2</span><span>,</span> <span>probe2</span><span>);</span>
</span></span><span><span><span>__m512i</span> <span>combined</span> <span>=</span> <span>_mm512_ternarylogic_epi64</span><span>(</span><span>diff0</span><span>,</span> <span>diff1</span><span>,</span> <span>diff2</span><span>,</span> <span>0xFE</span><span>);</span>
</span></span><span><span><span>__mmask64</span> <span>matches</span> <span>=</span> <span>_mm512_testn_epi8_mask</span><span>(</span><span>combined</span><span>,</span> <span>combined</span><span>);</span>
</span></span></code></pre></td></tr></tbody></table></div></div><p>For â‰¥4-byte windows we add a fourth probe plus a cached 16-byte window.
Once the probes line up we replay the window via <code>_mm_maskz_loadu_epi8</code> and only then call the shared verifier.
The Greek folding kernel benefits from ternary logic even more: it builds five independent offset vectors (e.g., <code>+0x20</code>, <code>-0x20</code>, <code>+0x26</code>, <code>+0x25</code>, <code>-1</code>) and collapses them with two chained <code>VPTERNLOG</code>s before a single <code>_mm512_add_epi8</code>.
That removes the eight-step mask-move chain we previously had and keeps port 5 from saturating.</p><div><div><table><tbody><tr><td><pre tabindex="0"><code><span id="hl-15-1"><a href="#hl-15-1">1</a>
</span><span id="hl-15-2"><a href="#hl-15-2">2</a>
</span><span id="hl-15-3"><a href="#hl-15-3">3</a>
</span></code></pre></td><td><pre tabindex="0"><code data-lang="c"><span><span><span>__m512i</span> <span>off123</span> <span>=</span> <span>_mm512_ternarylogic_epi64</span><span>(</span><span>off1</span><span>,</span> <span>off2</span><span>,</span> <span>off3</span><span>,</span> <span>0xFE</span><span>);</span>
</span></span><span><span><span>offset_zmm</span> <span>=</span> <span>_mm512_ternarylogic_epi64</span><span>(</span><span>off123</span><span>,</span> <span>off4</span><span>,</span> <span>off5</span><span>,</span> <span>0xFE</span><span>);</span>
</span></span><span><span><span>result_zmm</span> <span>=</span> <span>_mm512_add_epi8</span><span>(</span><span>result_zmm</span><span>,</span> <span>offset_zmm</span><span>);</span>
</span></span></code></pre></td></tr></tbody></table></div></div><h3 id="byte-table-shuffles">Byte-Table Shuffles</h3><p>Greek and Cyrillic folds use <code>VPSHUFB</code> lookups instead of branchy ranges.
We mask off the high nibble of each continuation byte, shuffle a 16-entry table, and add the resulting offset back to the registerâ€”three disjoint subranges handled in one go.</p><div><div><table><tbody><tr><td><pre tabindex="0"><code><span id="hl-16-1"><a href="#hl-16-1">1</a>
</span><span id="hl-16-2"><a href="#hl-16-2">2</a>
</span><span id="hl-16-3"><a href="#hl-16-3">3</a>
</span></code></pre></td><td><pre tabindex="0"><code data-lang="c"><span><span><span>__m512i</span> <span>high</span> <span>=</span> <span>_mm512_and_si512</span><span>(</span><span>_mm512_srli_epi16</span><span>(</span><span>text_zmm</span><span>,</span> <span>4</span><span>),</span> <span>_mm512_set1_epi8</span><span>(</span><span>0x0F</span><span>));</span>
</span></span><span><span><span>__m512i</span> <span>offsets</span> <span>=</span> <span>_mm512_shuffle_epi8</span><span>(</span><span>offset_lut</span><span>,</span> <span>high</span><span>);</span>
</span></span><span><span><span>result_zmm</span> <span>=</span> <span>_mm512_add_epi8</span><span>(</span><span>result_zmm</span><span>,</span> <span>offsets</span><span>);</span>
</span></span></code></pre></td></tr></tbody></table></div></div><p>For Greek we encode per-range offsets in a single LUT so that one shuffle handles the entire <code>CE</code> lead byte:</p><ul><li><code>+0x26</code> for <span><strong>&#39;Î†&#39;</strong><span><code>U+0386</code><code>0x CE 86</code></span>
</span>and friends</li><li><code>+0x25</code> for <span><strong>&#39;Îˆ&#39;</strong><span><code>U+0388</code><code>0x CE 88</code></span>
</span>, <span><strong>&#39;Î‰&#39;</strong><span><code>U+0389</code><code>0x CE 89</code></span>
</span>, <span><strong>&#39;ÎŠ&#39;</strong><span><code>U+038A</code><code>0x CE 8A</code></span></span></li><li><code>+0x20</code> for <span><strong>&#39;Î‘&#39;</strong><span><code>U+0391</code><code>0x CE 91</code></span>
</span>â€“<span>
<strong>&#39;ÎŸ&#39;</strong><span><code>U+039F</code><code>0x CE 9F</code></span></span></li><li><code>-0x20</code> for <span><strong>&#39;Î &#39;</strong><span><code>U+03A0</code><code>0x CE A0</code></span>
</span>â€“<span>
<strong>&#39;Î©&#39;</strong><span><code>U+03A9</code><code>0x CE A9</code></span>
</span>and dialytika cases</li></ul><p>Cyrillic is even tidier: every uppercase lives in <code>D0 80</code>â€“<code>D0 AF</code>, and every lowercase twin sits either <code>+0x10</code>, <code>+0x20</code>, or <code>-0x20</code> away in the same byte lane.
Mapping the high nibble of the 2nd UTF-8 byte (<code>8</code>, <code>9</code>, <code>A</code>) into those offsets lets a single <code>VPSHUFB</code> drive the entire block, while a post-shuffle mask flips <code>D0</code>â†’<code>D1</code> whenever the nibble was <code>8</code> or <code>A</code>.</p><h2 id="using-stringzilla">Using StringZilla</h2><p>At this point you must be itching to try it out.
StringZilla is available under the Apache 2.0 license on GitHub: <a href="https://github.com/ashvardanian/StringZilla">github.com/ashvardanian/StringZilla</a>.
Several language bindings already have the Unicode functionality exposed.
One important detail: offsets and lengths in the Unicode APIs are in <strong>bytes</strong>, not codepoints.</p><h3 id="c-and-c-apis">C and C++ APIs</h3><p>StringZilla is header-only.
No linking, no runtime deps, no nonsense.
Copy the headers, add a submodule, or use CMake <code>FetchContent</code>:</p><div><div><table><tbody><tr><td><pre tabindex="0"><code><span id="hl-17-1"><a href="#hl-17-1">1</a>
</span><span id="hl-17-2"><a href="#hl-17-2">2</a>
</span><span id="hl-17-3"><a href="#hl-17-3">3</a>
</span><span id="hl-17-4"><a href="#hl-17-4">4</a>
</span><span id="hl-17-5"><a href="#hl-17-5">5</a>
</span><span id="hl-17-6"><a href="#hl-17-6">6</a>
</span><span id="hl-17-7"><a href="#hl-17-7">7</a>
</span></code></pre></td><td><pre tabindex="0"><code data-lang="cmake"><span><span><span>include</span><span>(</span><span>FetchContent</span><span>)</span><span>
</span></span></span><span><span><span></span><span>FetchContent_Declare</span><span>(</span>
</span></span><span><span>    <span>stringzilla</span>
</span></span><span><span>    <span>GIT_REPOSITORY</span> <span>https://github.com/ashvardanian/StringZilla.git</span>
</span></span><span><span>    <span>GIT_TAG</span> <span>v4.5.0</span> <span># pin a version tag, don&#39;t chase `main`
</span></span></span><span><span><span></span><span>)</span><span>
</span></span></span><span><span><span></span><span>FetchContent_MakeAvailable</span><span>(</span><span>stringzilla</span><span>)</span><span>
</span></span></span></code></pre></td></tr></tbody></table></div></div><p>But if you are building Operating Systems, Browsers, or Database Engines - you can probably tolerate some extra legwork if it brings you multi-versioned kernels with dynamic dispatch at runtime.
It means compiling StringZilla as a separate library with all ISA backends enabled, shipping it alongside your binaries, and expecting it to automatically detect if the CPU supports every weird SIMD instruction set you care about.</p><div><div><table><tbody><tr><td><pre tabindex="0"><code><span id="hl-18-1"><a href="#hl-18-1">1</a>
</span><span id="hl-18-2"><a href="#hl-18-2">2</a>
</span></code></pre></td><td><pre tabindex="0"><code data-lang="cmake"><span><span><span>target_link_libraries</span><span>(</span><span>your_target</span> <span>PRIVATE</span> <span>stringzilla::stringzilla_shared</span><span>)</span>  <span># also links LibC
</span></span></span><span><span><span></span><span>target_link_libraries</span><span>(</span><span>your_target</span> <span>PRIVATE</span> <span>stringzilla::stringzilla_bare</span><span>)</span>    <span># no LibC linkage
</span></span></span></code></pre></td></tr></tbody></table></div></div><p>If you want to further reduce the latency of dynamic dispatch and use some other feature-detection mechanism, you can still manually address the different backends, grab the function pointers, and call them directly:</p><div><div><table><tbody><tr><td><pre tabindex="0"><code><span id="hl-19-1"><a href="#hl-19-1">1</a>
</span><span id="hl-19-2"><a href="#hl-19-2">2</a>
</span><span id="hl-19-3"><a href="#hl-19-3">3</a>
</span><span id="hl-19-4"><a href="#hl-19-4">4</a>
</span><span id="hl-19-5"><a href="#hl-19-5">5</a>
</span><span id="hl-19-6"><a href="#hl-19-6">6</a>
</span></code></pre></td><td><pre tabindex="0"><code data-lang="c"><span><span><span>sz_find</span><span>(</span><span>text</span><span>,</span> <span>length</span><span>,</span> <span>pattern</span><span>,</span> <span>3</span><span>);</span>          <span>// Auto-dispatch
</span></span></span><span><span><span></span><span>sz_find_westmere</span><span>(</span><span>text</span><span>,</span> <span>length</span><span>,</span> <span>pattern</span><span>,</span> <span>3</span><span>);</span> <span>// Intel Westmere+ SSE4.2
</span></span></span><span><span><span></span><span>sz_find_haswell</span><span>(</span><span>text</span><span>,</span> <span>length</span><span>,</span> <span>pattern</span><span>,</span> <span>3</span><span>);</span>  <span>// Intel Haswell+ AVX2
</span></span></span><span><span><span></span><span>sz_find_skylake</span><span>(</span><span>text</span><span>,</span> <span>length</span><span>,</span> <span>pattern</span><span>,</span> <span>3</span><span>);</span>  <span>// Intel Skylake+ AVX-512
</span></span></span><span><span><span></span><span>sz_find_neon</span><span>(</span><span>text</span><span>,</span> <span>length</span><span>,</span> <span>pattern</span><span>,</span> <span>3</span><span>);</span>     <span>// Arm NEON 128-bit
</span></span></span><span><span><span></span><span>sz_find_sve</span><span>(</span><span>text</span><span>,</span> <span>length</span><span>,</span> <span>pattern</span><span>,</span> <span>3</span><span>);</span>      <span>// Arm SVE 128/256/512/1024/2048-bit
</span></span></span></code></pre></td></tr></tbody></table></div></div><p>Unicode case folding expands characters, so the output buffer must be at least 3Ã— larger than the input.</p><div><div><table><tbody><tr><td><pre tabindex="0"><code><span id="hl-20-1"><a href="#hl-20-1">1</a>
</span><span id="hl-20-2"><a href="#hl-20-2">2</a>
</span><span id="hl-20-3"><a href="#hl-20-3">3</a>
</span><span id="hl-20-4"><a href="#hl-20-4">4</a>
</span><span id="hl-20-5"><a href="#hl-20-5">5</a>
</span><span id="hl-20-6"><a href="#hl-20-6">6</a>
</span></code></pre></td><td><pre tabindex="0"><code data-lang="c"><span><span><span>#include</span> <span>&lt;string.h&gt;</span><span>
</span></span></span><span><span><span>#include</span> <span>&lt;stringzilla/stringzilla.h&gt;</span><span>
</span></span></span><span><span><span></span>
</span></span><span><span><span>char</span> <span>source</span><span>[]</span> <span>=</span> <span>&#34;StraÃŸe&#34;</span><span>;</span>
</span></span><span><span><span>char</span> <span>destination</span><span>[</span><span>64</span><span>];</span> <span>// Must be at least 3Ã— source length
</span></span></span><span><span><span></span><span>sz_size_t</span> <span>result_len</span> <span>=</span> <span>sz_utf8_case_fold</span><span>(</span><span>source</span><span>,</span> <span>strlen</span><span>(</span><span>source</span><span>),</span> <span>destination</span><span>);</span>
</span></span></code></pre></td></tr></tbody></table></div></div><p>The case-insensitive search API returns a pointer to the start of the first match (or <code>NULL</code> if not found).
It also outputs the length of the matched substring in bytes, which can differ from the needle length due to expansions.</p><div><div><table><tbody><tr><td><pre tabindex="0"><code><span id="hl-21-1"><a href="#hl-21-1"> 1</a>
</span><span id="hl-21-2"><a href="#hl-21-2"> 2</a>
</span><span id="hl-21-3"><a href="#hl-21-3"> 3</a>
</span><span id="hl-21-4"><a href="#hl-21-4"> 4</a>
</span><span id="hl-21-5"><a href="#hl-21-5"> 5</a>
</span><span id="hl-21-6"><a href="#hl-21-6"> 6</a>
</span><span id="hl-21-7"><a href="#hl-21-7"> 7</a>
</span><span id="hl-21-8"><a href="#hl-21-8"> 8</a>
</span><span id="hl-21-9"><a href="#hl-21-9"> 9</a>
</span><span id="hl-21-10"><a href="#hl-21-10">10</a>
</span><span id="hl-21-11"><a href="#hl-21-11">11</a>
</span><span id="hl-21-12"><a href="#hl-21-12">12</a>
</span><span id="hl-21-13"><a href="#hl-21-13">13</a>
</span><span id="hl-21-14"><a href="#hl-21-14">14</a>
</span><span id="hl-21-15"><a href="#hl-21-15">15</a>
</span><span id="hl-21-16"><a href="#hl-21-16">16</a>
</span><span id="hl-21-17"><a href="#hl-21-17">17</a>
</span><span id="hl-21-18"><a href="#hl-21-18">18</a>
</span><span id="hl-21-19"><a href="#hl-21-19">19</a>
</span></code></pre></td><td><pre tabindex="0"><code data-lang="c"><span><span><span>#include</span> <span>&lt;string.h&gt;</span><span>
</span></span></span><span><span><span>#include</span> <span>&lt;stringzilla/stringzilla.h&gt;</span><span>
</span></span></span><span><span><span></span>
</span></span><span><span><span>char</span> <span>const</span> <span>*</span><span>haystack</span> <span>=</span> <span>&#34;Der groÃŸe Hund&#34;</span><span>;</span>
</span></span><span><span><span>char</span> <span>const</span> <span>*</span><span>needle</span> <span>=</span> <span>&#34;GROSSE&#34;</span><span>;</span>
</span></span><span><span><span>sz_size_t</span> <span>haystack_len</span> <span>=</span> <span>strlen</span><span>(</span><span>haystack</span><span>);</span>
</span></span><span><span><span>sz_size_t</span> <span>needle_len</span> <span>=</span> <span>strlen</span><span>(</span><span>needle</span><span>);</span>
</span></span><span><span>
</span></span><span><span><span>sz_utf8_case_insensitive_needle_metadata_t</span> <span>metadata</span> <span>=</span> <span>{};</span>
</span></span><span><span><span>sz_size_t</span> <span>match_length</span> <span>=</span> <span>0</span><span>;</span>
</span></span><span><span><span>sz_cptr_t</span> <span>match</span> <span>=</span> <span>sz_utf8_case_insensitive_find</span><span>(</span>
</span></span><span><span>    <span>haystack</span><span>,</span> <span>haystack_len</span><span>,</span>
</span></span><span><span>    <span>needle</span><span>,</span> <span>needle_len</span><span>,</span>
</span></span><span><span>    <span>&amp;</span><span>metadata</span><span>,</span>    <span>// Reuse for queries with the same needle
</span></span></span><span><span><span></span>    <span>&amp;</span><span>match_length</span> <span>// Output: bytes consumed in haystack
</span></span></span><span><span><span></span><span>);</span>
</span></span><span><span>
</span></span><span><span><span>if</span> <span>(</span><span>match</span><span>)</span>
</span></span><span><span>    <span>printf</span><span>(</span><span>&#34;match at byte %zu, length %zu</span><span>\n</span><span>&#34;</span><span>,</span> <span>(</span><span>size_t</span><span>)(</span><span>match</span> <span>-</span> <span>haystack</span><span>),</span> <span>(</span><span>size_t</span><span>)</span><span>match_length</span><span>);</span>
</span></span></code></pre></td></tr></tbody></table></div></div><p>In C++ the same functionality is exposed on string views and via a pre-compiled needle type:</p><div><div><table><tbody><tr><td><pre tabindex="0"><code><span id="hl-22-1"><a href="#hl-22-1">1</a>
</span><span id="hl-22-2"><a href="#hl-22-2">2</a>
</span><span id="hl-22-3"><a href="#hl-22-3">3</a>
</span><span id="hl-22-4"><a href="#hl-22-4">4</a>
</span><span id="hl-22-5"><a href="#hl-22-5">5</a>
</span><span id="hl-22-6"><a href="#hl-22-6">6</a>
</span><span id="hl-22-7"><a href="#hl-22-7">7</a>
</span></code></pre></td><td><pre tabindex="0"><code data-lang="cpp"><span><span><span>namespace</span> <span>sz</span> <span>=</span> <span>ashvardanian</span><span>::</span><span>stringzilla</span><span>;</span>
</span></span><span><span>
</span></span><span><span><span>sz</span><span>::</span><span>string_view</span> <span>text</span> <span>=</span> <span>&#34;Der groÃŸe Hund&#34;</span><span>;</span>
</span></span><span><span><span>auto</span> <span>[</span><span>offset</span><span>,</span> <span>length</span><span>]</span> <span>=</span> <span>text</span><span>.</span><span>utf8_case_insensitive_find</span><span>(</span><span>&#34;GROSSE&#34;</span><span>);</span>
</span></span><span><span>
</span></span><span><span><span>sz</span><span>::</span><span>utf8_case_insensitive_needle</span> <span>pattern</span><span>(</span><span>&#34;STRASSE&#34;</span><span>);</span>
</span></span><span><span><span>auto</span> <span>match</span> <span>=</span> <span>sz</span><span>::</span><span>string_view</span><span>(</span><span>&#34;StraÃŸe&#34;</span><span>).</span><span>utf8_case_insensitive_find</span><span>(</span><span>pattern</span><span>);</span>
</span></span></code></pre></td></tr></tbody></table></div></div><h3 id="cpython-bindings">CPython Bindings</h3><p>StringZilla is in the top 1% of Pythonâ€™s most downloaded packages on PyPI.
Installation should be trivial:</p><div><div><table><tbody><tr><td><pre tabindex="0"><code><span id="hl-23-1"><a href="#hl-23-1">1</a>
</span></code></pre></td><td><pre tabindex="0"><code data-lang="bash"><span><span>pip install stringzilla
</span></span></code></pre></td></tr></tbody></table></div></div><p>It will pull one of the <a href="https://pypi.org/project/stringzilla/#files">96 platform-specific wheels</a> compiled per release, at the time of writing.</p><blockquote><p>I love to flex, that for comparison, <a href="https://pypi.org/project/numpy/#files">NumPy ships 74 wheels per release</a>.
And unlike NumPy, StringZilla doesnâ€™t redirect calls to your <a href="https://en.wikipedia.org/wiki/Basic_Linear_Algebra_Subprograms">BLAS</a> (or LibC in this case) - it ships hand-rolled kernels for every popular ISA family.
Ohâ€¦ and there is also a separate package for parallel extensions on GPUs and high core-count CPUs, which makes this comparison even more unfair.
So in case you are doing Web-scale LLM dataset preprocessing <a href="https://commoncrawl.org/">Common Crawl</a> at some Frontier AI lab or aligned/sketching Petabytes of protein and DNA data - to snatch the next Biology Nobel Prize before <a href="https://deepmind.google/science/alphafold/">AlphaFold</a> 4 comes out, install one of these too:</p><div><div><table><tbody><tr><td><pre tabindex="0"><code><span id="hl-24-1"><a href="#hl-24-1">1</a>
</span><span id="hl-24-2"><a href="#hl-24-2">2</a>
</span></code></pre></td><td><pre tabindex="0"><code data-lang="bash"><span><span>pip install stringzilla-cpus    <span># Multi-core CPU parallelism</span>
</span></span><span><span>pip install stringzilla-cuda    <span># NVIDIA GPU acceleration</span>
</span></span></code></pre></td></tr></tbody></table></div></div><p>More on this topic in the <a href="https://ashvardanian.com/posts/stringwars-on-gpus/">â€œProcessing Strings 109x Faster than Nvidia on H100â€ post</a> ğŸ¤—</p></blockquote><p>Once installed, case-insensitive search is a one-liner:</p><div><div><table><tbody><tr><td><pre tabindex="0"><code><span id="hl-25-1"><a href="#hl-25-1">1</a>
</span><span id="hl-25-2"><a href="#hl-25-2">2</a>
</span><span id="hl-25-3"><a href="#hl-25-3">3</a>
</span><span id="hl-25-4"><a href="#hl-25-4">4</a>
</span><span id="hl-25-5"><a href="#hl-25-5">5</a>
</span></code></pre></td><td><pre tabindex="0"><code data-lang="python"><span><span><span>import</span> <span>stringzilla</span> <span>as</span> <span>sz</span>
</span></span><span><span>
</span></span><span><span><span>sz</span><span>.</span><span>utf8_case_insensitive_find</span><span>(</span><span>&#34;Der groÃŸe Hund&#34;</span><span>,</span> <span>&#34;GROSSE&#34;</span><span>)</span>  <span># 4 (byte offset)</span>
</span></span><span><span><span>sz</span><span>.</span><span>utf8_case_insensitive_find</span><span>(</span><span>&#34;StraÃŸe&#34;</span><span>,</span> <span>&#34;STRASSE&#34;</span><span>)</span>         <span># 0 â€” ÃŸ matches &#34;SS&#34;</span>
</span></span><span><span><span>sz</span><span>.</span><span>utf8_case_insensitive_find</span><span>(</span><span>&#34;eï¬ƒcient&#34;</span><span>,</span> <span>&#34;EFFICIENT&#34;</span><span>)</span>      <span># 0 â€” ï¬ƒ ligature matches &#34;FFI&#34;</span>
</span></span></code></pre></td></tr></tbody></table></div></div><p>For repeated searches, use the iterator - it can reuse internal needle metadata:</p><div><div><table><tbody><tr><td><pre tabindex="0"><code><span id="hl-26-1"><a href="#hl-26-1">1</a>
</span><span id="hl-26-2"><a href="#hl-26-2">2</a>
</span><span id="hl-26-3"><a href="#hl-26-3">3</a>
</span><span id="hl-26-4"><a href="#hl-26-4">4</a>
</span><span id="hl-26-5"><a href="#hl-26-5">5</a>
</span></code></pre></td><td><pre tabindex="0"><code data-lang="python"><span><span><span>import</span> <span>stringzilla</span> <span>as</span> <span>sz</span>
</span></span><span><span>
</span></span><span><span><span>haystack</span> <span>=</span> <span>&#34;StraÃŸe STRASSE strasse&#34;</span>
</span></span><span><span><span>for</span> <span>match</span> <span>in</span> <span>sz</span><span>.</span><span>utf8_case_insensitive_find_iter</span><span>(</span><span>haystack</span><span>,</span> <span>&#34;strasse&#34;</span><span>):</span>
</span></span><span><span>    <span>print</span><span>(</span><span>match</span><span>,</span> <span>match</span><span>.</span><span>offset_within</span><span>(</span><span>haystack</span><span>))</span>
</span></span></code></pre></td></tr></tbody></table></div></div><h3 id="rust-bindings">Rust Bindings</h3><p>Same story in Rust:</p><p>You get both a one-off function and a pre-compiled needle type:</p><div><div><table><tbody><tr><td><pre tabindex="0"><code><span id="hl-28-1"><a href="#hl-28-1">1</a>
</span><span id="hl-28-2"><a href="#hl-28-2">2</a>
</span><span id="hl-28-3"><a href="#hl-28-3">3</a>
</span><span id="hl-28-4"><a href="#hl-28-4">4</a>
</span><span id="hl-28-5"><a href="#hl-28-5">5</a>
</span><span id="hl-28-6"><a href="#hl-28-6">6</a>
</span></code></pre></td><td><pre tabindex="0"><code data-lang="rust"><span><span><span>use</span><span> </span><span>stringzilla</span>::<span>stringzilla</span>::<span>{</span><span>utf8_case_insensitive_find</span><span>,</span><span> </span><span>Utf8CaseInsensitiveNeedle</span><span>};</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>assert_eq!</span><span>(</span><span>utf8_case_insensitive_find</span><span>(</span><span>&#34;StraÃŸe&#34;</span><span>,</span><span> </span><span>&#34;STRASSE&#34;</span><span>),</span><span> </span><span>Some</span><span>((</span><span>0</span><span>,</span><span> </span><span>7</span><span>)));</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>let</span><span> </span><span>needle</span><span> </span><span>=</span><span> </span><span>Utf8CaseInsensitiveNeedle</span>::<span>new</span><span>(</span><span>b</span><span>&#34;STRASSE&#34;</span><span>);</span><span>
</span></span></span><span><span><span></span><span>assert_eq!</span><span>(</span><span>utf8_case_insensitive_find</span><span>(</span><span>&#34;strasse&#34;</span><span>,</span><span> </span><span>&amp;</span><span>needle</span><span>),</span><span> </span><span>Some</span><span>((</span><span>0</span><span>,</span><span> </span><span>7</span><span>)));</span><span>
</span></span></span></code></pre></td></tr></tbody></table></div></div><h3 id="swift-bindings">Swift Bindings</h3><p>Add the package in SwiftPM:</p><div><div><table><tbody><tr><td><pre tabindex="0"><code><span id="hl-29-1"><a href="#hl-29-1">1</a>
</span><span id="hl-29-2"><a href="#hl-29-2">2</a>
</span><span id="hl-29-3"><a href="#hl-29-3">3</a>
</span></code></pre></td><td><pre tabindex="0"><code data-lang="swift"><span><span><span>dependencies</span><span>:</span> <span>[</span>
</span></span><span><span>    <span>.</span><span>package</span><span>(</span><span>url</span><span>:</span> <span>&#34;https://github.com/ashvardanian/stringzilla&#34;</span><span>)</span>
</span></span><span><span><span>]</span>
</span></span></code></pre></td></tr></tbody></table></div></div><p>Then search:</p><div><div><table><tbody><tr><td><pre tabindex="0"><code><span id="hl-30-1"><a href="#hl-30-1">1</a>
</span><span id="hl-30-2"><a href="#hl-30-2">2</a>
</span><span id="hl-30-3"><a href="#hl-30-3">3</a>
</span><span id="hl-30-4"><a href="#hl-30-4">4</a>
</span><span id="hl-30-5"><a href="#hl-30-5">5</a>
</span><span id="hl-30-6"><a href="#hl-30-6">6</a>
</span><span id="hl-30-7"><a href="#hl-30-7">7</a>
</span></code></pre></td><td><pre tabindex="0"><code data-lang="swift"><span><span><span>import</span> <span>StringZilla</span>
</span></span><span><span>
</span></span><span><span><span>let</span> <span>haystack</span> <span>=</span> <span>&#34;Der groÃŸe Hund&#34;</span>
</span></span><span><span><span>let</span> <span>needle</span> <span>=</span> <span>&#34;GROSSE&#34;</span>
</span></span><span><span><span>if</span> <span>let</span> <span>range</span> <span>=</span> <span>haystack</span><span>.</span><span>utf8CaseInsensitiveFind</span><span>(</span><span>substring</span><span>:</span> <span>needle</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>print</span><span>(</span><span>haystack</span><span>[</span><span>range</span><span>])</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></td></tr></tbody></table></div></div><h3 id="nodejs-bindings">Node.js Bindings</h3><p>JavaScript bindings are available via NPM:</p><div><div><table><tbody><tr><td><pre tabindex="0"><code><span id="hl-31-1"><a href="#hl-31-1">1</a>
</span></code></pre></td><td><pre tabindex="0"><code data-lang="bash"><span><span>npm install stringzilla
</span></span></code></pre></td></tr></tbody></table></div></div><p>That said, due to the extreme fragmentation of the JavaScript ecosystem - Iâ€™m never quite sure about how smooth the installation will be on your environment.
There are also limitations to accessing the internal contents of strings in JavaScript, so the API expects <code>Buffer</code>s instead of <code>string</code>s.
Thatâ€™s true for pretty much all of StringZilla functionality in Node.js.</p><div><div><table><tbody><tr><td><pre tabindex="0"><code><span id="hl-32-1"><a href="#hl-32-1">1</a>
</span><span id="hl-32-2"><a href="#hl-32-2">2</a>
</span><span id="hl-32-3"><a href="#hl-32-3">3</a>
</span><span id="hl-32-4"><a href="#hl-32-4">4</a>
</span><span id="hl-32-5"><a href="#hl-32-5">5</a>
</span><span id="hl-32-6"><a href="#hl-32-6">6</a>
</span><span id="hl-32-7"><a href="#hl-32-7">7</a>
</span><span id="hl-32-8"><a href="#hl-32-8">8</a>
</span><span id="hl-32-9"><a href="#hl-32-9">9</a>
</span></code></pre></td><td><pre tabindex="0"><code data-lang="js"><span><span><span>import</span> <span>sz</span> <span>from</span> <span>&#34;stringzilla&#34;</span><span>;</span>
</span></span><span><span>
</span></span><span><span><span>const</span> <span>text</span> <span>=</span> <span>Buffer</span><span>.</span><span>from</span><span>(</span><span>&#34;StraÃŸe&#34;</span><span>);</span>
</span></span><span><span><span>const</span> <span>patternBytes</span> <span>=</span> <span>Buffer</span><span>.</span><span>from</span><span>(</span><span>&#34;STRASSE&#34;</span><span>);</span>
</span></span><span><span>
</span></span><span><span><span>console</span><span>.</span><span>log</span><span>(</span><span>sz</span><span>.</span><span>utf8CaseInsensitiveFind</span><span>(</span><span>text</span><span>,</span> <span>patternBytes</span><span>));</span> <span>// { index: 0n, length: 7n } (byte offsets)
</span></span></span><span><span><span></span>
</span></span><span><span><span>const</span> <span>pattern</span> <span>=</span> <span>new</span> <span>sz</span><span>.</span><span>Utf8CaseInsensitiveNeedle</span><span>(</span><span>patternBytes</span><span>);</span>
</span></span><span><span><span>console</span><span>.</span><span>log</span><span>(</span><span>pattern</span><span>.</span><span>findIn</span><span>(</span><span>text</span><span>));</span>
</span></span></code></pre></td></tr></tbody></table></div></div><h3 id="golang-bindings">GoLang Bindings</h3><p>GoLang installation might be the trickiest, as it <a href="https://go.dev/doc/asm">uses a different Assembly syntax and calling convention</a>.
Yes, you still need to <code>go get</code> the package, but before that you need to pull the precompiled shared libraries from GitHub Releases and place them in your dynamic linker path:</p><div><div><table><tbody><tr><td><pre tabindex="0"><code><span id="hl-33-1"><a href="#hl-33-1">1</a>
</span></code></pre></td><td><pre tabindex="0"><code data-lang="bash"><span><span>go get github.com/ashvardanian/stringzilla/golang@latest
</span></span></code></pre></td></tr></tbody></table></div></div><p>You can grab the binaries from <a href="https://github.com/ashvardanian/StringZilla/releases">GitHub Releases</a>.</p><p>On Linux, thatâ€™s typically <code>LD_LIBRARY_PATH</code>. On macOS, thatâ€™s <code>DYLD_LIBRARY_PATH</code>.</p><p>Sadly, thatâ€™s a common limitation of Go.
Moreover, switching from Goâ€™s lightweight goroutines to OS threads for calling into C is also quite expensive, so you wonâ€™t win much unless you are calling into a longer operation.
It meant limited applicability of StringZilla in Go for operations like hashing and exact substring search, but case-insensitive search over Unicode is a much better fit, so the bindings are available:</p><div><div><table><tbody><tr><td><pre tabindex="0"><code><span id="hl-34-1"><a href="#hl-34-1"> 1</a>
</span><span id="hl-34-2"><a href="#hl-34-2"> 2</a>
</span><span id="hl-34-3"><a href="#hl-34-3"> 3</a>
</span><span id="hl-34-4"><a href="#hl-34-4"> 4</a>
</span><span id="hl-34-5"><a href="#hl-34-5"> 5</a>
</span><span id="hl-34-6"><a href="#hl-34-6"> 6</a>
</span><span id="hl-34-7"><a href="#hl-34-7"> 7</a>
</span><span id="hl-34-8"><a href="#hl-34-8"> 8</a>
</span><span id="hl-34-9"><a href="#hl-34-9"> 9</a>
</span><span id="hl-34-10"><a href="#hl-34-10">10</a>
</span><span id="hl-34-11"><a href="#hl-34-11">11</a>
</span></code></pre></td><td><pre tabindex="0"><code data-lang="go"><span><span><span>package</span> <span>main</span>
</span></span><span><span>
</span></span><span><span><span>import</span> <span>(</span>
</span></span><span><span>    <span>&#34;fmt&#34;</span>
</span></span><span><span>    <span>sz</span> <span>&#34;github.com/ashvardanian/stringzilla/golang&#34;</span>
</span></span><span><span><span>)</span>
</span></span><span><span>
</span></span><span><span><span>func</span> <span>main</span><span>()</span> <span>{</span>
</span></span><span><span>    <span>start64</span><span>,</span> <span>len64</span><span>,</span> <span>_</span> <span>:=</span> <span>sz</span><span>.</span><span>Utf8CaseInsensitiveFind</span><span>(</span><span>&#34;StraÃŸe&#34;</span><span>,</span> <span>&#34;STRASSE&#34;</span><span>,</span> <span>true</span><span>)</span>
</span></span><span><span>    <span>fmt</span><span>.</span><span>Println</span><span>(</span><span>start64</span><span>,</span> <span>len64</span><span>)</span> <span>// 0 7
</span></span></span><span><span><span></span><span>}</span>
</span></span></code></pre></td></tr></tbody></table></div></div><h2 id="future-plans">Future Plans</h2><p>There are clearly some blind spots in the library.
Georgian script deserves its own SIMD kernels, Korean and other language performance can also clearly be improved.
Even more importantly, porting this to Arm wonâ€™t be trivial.
I donâ€™t expect this workload to benefit much from SVE2, so NEON will be the main target.
Itâ€™s limited to 128-bit vectors, so to stick to the same 64-byte wide blocks with up-to 16-byte safe slices, weâ€™ll need to process 4 vectors in parallel, also covering inter-register boundaries with intra-register shufflesâ€¦</p><p>I wonâ€™t be doing that tomorrow.
There is one more massive open-source release I want to finish this year and youâ€™ll never guess what it is about, but hereâ€™s a <a href="https://github.com/unum-cloud">hint</a> ğŸ˜‰</p><blockquote data-dnt="true"><p lang="en" dir="ltr">This is the ugliest, but potentially the most important piece of open-source software I&#39;ve written this year.</p>â€” Ash Vardanian (@ashvardanian) <a href="https://twitter.com/ashvardanian/status/2000611501875376494?ref_src=twsrc%5Etfw">December 15, 2025</a></blockquote></div></div>
  </body>
</html>
