<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://fly.io/blog/sqlite-internals-rollback-journal/">Original</a>
    <h1>How SQLite Helps You Do ACID</h1>
    
    <div id="readability-page-1" class="page"><section> <img src="https://podviaznikov.com/blog/2022-08-10/cover.png" alt="A pencil writing in a journal of sandwiches I&#39;ve eaten."/> <p><a href="http://fly.io/">Fly.io</a> runs apps close to users around the world, by taking containers and upgrading them to full-fledged virtual machines running on our own hardware around the world. Sometimes those containers run SQLite and we make that easy too. <a href="https://fly.io/docs/speedrun/">Give us a whirl</a> and get up and running quickly.</p><p>When database vendors recite their long list of features, they never enumerate &#34;doesn&#39;t lose your data&#34; as one of those features. It&#39;s just assumed. That&#39;s what a database is supposed to do. However, in reality, the best database vendors <a href="https://www.sqlite.org/howtocorrupt.html">tell you exactly how their database will lose your data</a>.</p> <p>I&#39;ve written before about <a href="https://fly.io/blog/sqlite-internals-btree/">how SQLite stores your data</a>. In order not to lose any of it when a transaction goes wrong, SQLite implements a journal. It has two different modes: the rollback journal &amp; the write-ahead log. Today we&#39;re diving into the rollback journal: what it is, how it works, and when to use it.</p> <h2 id="how-to-lose-your-data"><a href="#how-to-lose-your-data" aria-label="Anchor"></a>How to Lose Your Data</h2><p>To understand why you need a database journal, let&#39;s look at what happens without one. <a href="https://podviaznikov.com/blog/sqlite-internals-btree/">In the last post</a>, we talked about how SQLite is split up into 4KB chunks called &#34;pages&#34;. Any time you make a change—even a 1 byte change—SQLite will write a full 4KB page.</p> <p>If you tried to overwrite a page in your database file directly, it would work fine 99% of the time. However, that 1% of the time is catastrophic. If your server suddenly shut down halfway through a page write then you&#39;ll end up with a corrupted database.</p> <p>The database needs to ensure that all page writes for a transaction either get written or don&#39;t. No halfsies. This is called <em>atomicity</em>.</p> <p>But that&#39;s not all. If another process is querying the database, it&#39;ll have no consistent view of the data since you&#39;re overwriting pages willy-nilly. The database needs to ensure each transaction has a snapshot view of the database for its entire duration. This is called <em>isolation</em>.</p> <p>Finally, we need to make sure bytes actually get flushed to disk. This part is called <em>durability</em>.</p> <p>Those make up 3 of the 4 letters of the <a href="https://en.wikipedia.org/wiki/ACID">ACID transactional guarantee</a> that every database blog post is required to mention. The &#34;C&#34; stands for <em>consistency</em> but that doesn&#39;t involve the rollback journal so we&#39;ll skip that.</p> <h2 id="all-for-one-or-none-at-all"><a href="#all-for-one-or-none-at-all" aria-label="Anchor"></a>All for One, or None at All</h2><p>Every textbook definition of transactions involves a bank transfer where someone withdraws money from one account and deposits in another. Both actions must happen or neither must happen.</p> <p>This example gets trotted out because atomicity is so unusual in the physical world that it&#39;s hard to find anything else that&#39;s as intuitive to understand.</p> <p>But it turns out that atomicity doesn&#39;t &#34;just happen&#34; in databases either. It&#39;s all smoke and mirrors. So let&#39;s use a better example that involves our favorite topic: sandwiches.</p> <h3 id="building-a-sandwich"><a href="#building-a-sandwich" aria-label="Anchor"></a>Building a Sandwich</h3><p>When you go to a sandwich shop, you walk up to the counter, announce your order, and you get a tasty sandwich in hand a short time after. To you, the consumer, this is atomic. If you order a ham-and-cheese sandwich, you won&#39;t receive just a slice of ham or two pieces of dry bread. You either get a sandwich or you don&#39;t.</p> <p>But behind the counter, there are multiple steps involved: grab the bread, add the ham, add the cheese, hand it to the customer. If the sandwich maker gets to the cheese step and realizes they&#39;re out of cheese, they can tell you they can&#39;t make the sandwich and then put the ham and bread back where they found it. The internal state of the sandwich shop is restored to how it was before the order started.</p> <p>The rollback journal is similar. It records the state of the database before any changes are made. If anything goes wrong before we get to the end, we can use the journal to put the database back in its previous state.</p> <h3 id="our-first-transaction"><a href="#our-first-transaction" aria-label="Anchor"></a>Our First Transaction</h3><p>Let&#39;s start our first transaction by creating a table in a <code>sandwiches.db</code> database:</p> <div><pre><code>CREATE TABLE sandwiches (
    id INTEGER PRIMARY KEY,
    name TEXT
);
</code></pre></div><p>SQLite starts by creating a <code>sandwiches.db-journal</code> file next to our <code>sandwiches.db</code> database file and <a href="https://github.com/sqlite/sqlite/blob/3cf46ee508e97b46736a2607ded9c84c2c16229f/src/pager.c#L1425-L1439">writing a journal header</a>:</p> <div><pre><code>00000000 00000000 00000000 f65ddb21 00000000 00000200 00001000
</code></pre></div><p>The first 12 bytes are filled with zeros but they&#39;ll be overwritten at the end of our transaction so let&#39;s skip them for now.</p> <p>The value <code>0xf65ddb21</code> is called a nonce and it&#39;s a randomly generated number that we&#39;ll use to compute checksums for our entries in the journal. SQLite has <a href="https://www.sqlite.org/pragma.html#pragma_journal_mode">some journal modes</a> where it&#39;ll overwrite the journal instead of delete it so the checksums help SQLite know when its working with contiguous set of entries and not reading old entries left behind from previous transactions.</p> <p>Next, we have <code>0x00000000</code> which is the size of the database before the transaction started. Since this is the first transaction, our database was empty before the transaction.</p> <p>Then we specify the sector size of <code>0x00000200</code> (or 512). A disk sector is the smallest unit we typically work with for disk drives and SQLite keeps the journal header on its own sector. It does this because journal header is later rewritten and we don&#39;t want to accidentally corrupt one of our pages if a sector write fails.</p> <p>Finally, we have <code>0x00001000</code> (or 4,096) which is the page size for our database, in bytes.</p> <p>SQLite can now freely write changes to the database file while knowing that it has written down the state of the database from before the transaction started.</p> <p>When you go to commit the changes, SQLite will rewrite the first 12 bytes of the journal header with two new fields: <a href="https://en.wikipedia.org/wiki/Magic_number_(programming)">the magic number</a> &amp; the number of page entries in the journal.</p> <div><pre><code>d9d505f9 20a163d7 00000000
</code></pre></div><p>The &#34;magic number&#34; is a ridiculous name for a constant value that is written to the beginning of a file to indicate its file type. For journal files, this magic number is <code>d9d505f9 20a163d7</code>. We don&#39;t have any page entries since our database was empty so the page count stays as zeros.</p> <p>Next, we&#39;ll <a href="https://github.com/sqlite/sqlite/blob/3cf46ee508e97b46736a2607ded9c84c2c16229f/src/pager.c#L4184-L4218">sync the journal to disk</a> to make sure we don&#39;t lose it.</p> <p>The final step that ends the commit is when SQLite deletes the file. If any of the previous steps fail then SQLite can use the rollback journal to revert the state of the database. Just like with your ham-and-cheese, the transaction doesn&#39;t happen until you have a sandwich in your hand.</p> <p><img src="https://podviaznikov.com/blog/2022-08-10/journal-header-only.png" alt="Diagram of the database with 2 pages and a journal file with only a header."/></p> <h3 id="copying-out-to-the-journal"><a href="#copying-out-to-the-journal" aria-label="Anchor"></a>Copying Out to the Journal</h3><p>Now let&#39;s see how the journal works with an existing database. Our first transaction left us with a 2-page database. The first page holds our database header and some metadata about our schema. The second page is an empty leaf page for our <code>sandwiches</code> table.</p> <p>We&#39;ll insert our sandwich into our table:</p> <div><pre><code>BEGIN;
INSERT INTO sandwiches (name) VALUES (&#39;ham and cheese&#39;);
</code></pre></div><p>This will create a new journal with the following header:</p> <div><pre><code>00000000 00000000 00000000 0600399E 00000002 00000200 00001000
</code></pre></div><p>It looks similar to before but we have a new randomly-generated nonce (<code>0x0600399e</code>) and our database size before the transaction is now <code>0x00000002</code> pages instead of zero.</p> <p>Since our transaction is updating the leaf page, SQLite needs to copy out the original version of the page to the journal as a page record. The journal page records are comprised of 3 fields.</p> <p>First, we have the page number to indicate that we&#39;re updating page 2:</p> <p>Then it&#39;s followed by a copy of the 4,096 bytes that were in the page before the transaction started. Finally, it computes a 32-bit checksum on the data in the page:</p> <p>Interestingly, the checksum is only calculated on a very sparse number of bytes in the page and is primarily meant to guard against incomplete writes. Since SQLite 3.0.0 dates back to 2004 and it works on minimal hardware, reducing any overhead can be critical. You can see the evolution of computing power as the WAL mode, which was introduced in 2010, checksums the entire page.</p> <p>With our original copy of the page in the journal, we can update our copy in the main database file without having to re-copy the page. We can add a second sandwich to our transaction and SQLite will only update the main database file:</p> <div><pre><code>INSERT INTO sandwiches (name) VALUES (&#39;cheesesteak&#39;);
</code></pre></div><p>The database and journal end up looking like this:</p> <p><img src="https://podviaznikov.com/blog/2022-08-10/journal-with-entry.png" alt="Diagram of copying page 2 from the database to an entry in the journal file."/></p> <h2 id="when-sandwiches-go-bad"><a href="#when-sandwiches-go-bad" aria-label="Anchor"></a>When Sandwiches Go Bad</h2><p>Back to our sandwich shop example, let&#39;s say there is a catastrophic sandwich event that occurs in the middle of your order. Perhaps your sandwich artist couldn&#39;t stand to make one more ham-and-cheese sandwich and abruptly quit.</p> <p>So our shop owner subs out a new employee to replace the old one so the sandwich production can continue. But how do we deal with the in-process sandwich? The new employee could try to finish the sandwich but maybe the customer gave specific instructions to the old employee. When you&#39;re dealing with something as critical as lunch, it&#39;s best to start over and do it right.</p> <p>When SQLite encounters a failure scenario, such as an application dying or a server losing power, it needs to go through a process called &#34;<a href="https://github.com/sqlite/sqlite/blob/3cf46ee508e97b46736a2607ded9c84c2c16229f/src/pager.c#L2691-L2747">recovery</a>&#34;. For a rollback journal, this is simple. We can walk through our journal page records and copy each page back into the main database file. At the end, we truncate our main database file to the size specified in the journal header.</p> <p><img src="https://podviaznikov.com/blog/2022-08-10/recovery.png" alt="Diagram of the journal entry being copied back to the database file during recovery."/></p> <p>Rollback journals are even resistant to failures during their own recovery. If your server crashes midway through a recovery process, SQLite will simply start the recovery process from the beginning of the journal file.</p> <p>The procedure is idempotent and is not considered complete until the pages copied back are synced to disk and the journal file is deleted. For example, let&#39;s say we&#39;d only copied half of page 2 in our diagram from the journal back to the database file and then our server crashed. When we restart, we still have our journal file in place and we can simply try copying that page again.</p> <h2 id="keeping-track-of-our-ingredients"><a href="#keeping-track-of-our-ingredients" aria-label="Anchor"></a>Keeping Track of Our Ingredients</h2><p>Our sandwich shop owner begins to suspect that employees are skimming pickles off the line and decides to hire folks to inventory ingredients periodically. However, the owner quickly realizes that the inventory numbers are off because the inventory specialists are trying to count ingredients while sandwich makers are taking those same ingredients to put into sandwiches.</p> <p>To fix this, the owner decides that the store must be locked while a sandwich is being made. However, when a sandwich isn&#39;t being made, any number of inventory specialists can come in and count ingredients.</p> <p>This is how it works in SQLite when using the rollback journal. Any number of read-only transactions can occur at the same time. However, when we start a write transaction then we need to wait for the readers to finish and block all new readers until the write is done.</p> <p>This makes sense now that you know that we&#39;re changing the main database file during a write transaction. We&#39;d have no way to give read transactions a snapshot view of the database if we&#39;re updating the same underlying data.</p> <h3 id="read-write-locks-on-the-file-system"><a href="#read-write-locks-on-the-file-system" aria-label="Anchor"></a>Read/write Locks on the File System</h3><p>Since SQLite allows multiple processes to access it, it needs to perform locking at the file system level. There are 3 lock bytes that are used to implement the read/write lock at the file system level:</p> <ul> <li><code>SHARED</code> - held by read transactions, prevents writers from starting </li><li><code>RESERVED</code> - held by the write transaction </li><li><code>PENDING</code> - held by the write transaction to prevent readers from starting </li></ul> <p>When a read transaction starts, it checks the <code>PENDING</code> lock first to ensure a writer is not inside a write transaction or that a writer is not waiting to start a transaction. If the reader can obtain the <code>PENDING</code> lock then it obtains a shared lock on the <code>SHARED</code> lock byte and holds it until the end of the transaction.</p> <p>For write transactions, it first obtains an exclusive lock on the <code>PENDING</code> lock byte to prevent new read transactions from starting. It then tries to obtain an exclusive lock on the <code>SHARED</code> lock byte to wait for in-process read transactions to finish. Finally, it obtains an exclusive lock on the <code>RESERVED</code> lock byte to indicate that a write transaction is in-process.</p> <p>This series of steps ensure that only one write transaction is in effect at any time and that new readers won&#39;t block it.</p> <p><img src="https://podviaznikov.com/blog/2022-08-10/lock-page.png" alt="Diagram of the structure of the lock page."/></p> <p>Locks are located on a page at the 1GB position in the database file and this page is unusable by SQLite as <a href="https://github.com/sqlite/sqlite/blob/3cf46ee508e97b46736a2607ded9c84c2c16229f/src/os.h#L104-L158">some Windows versions use mandatory locks</a> instead of advisory locks. If a database is smaller than 1GB, this page is never allocated and only exists within the operating system&#39;s lock accounting system.</p> <p>Within the lock page, a byte is used for the <code>PENDING</code> lock and another byte for the <code>RESERVED</code> lock. After that, 510 bytes are used for the <code>SHARED</code> lock. A byte range is used here to accommodate older Windows versions with mandatory locks. In those cases, a randomly chosen byte is locked by a client within that range. On Unix, the entire range is locked using <code>fctnl()</code> and <code>F_RDLCK</code>.</p> <h2 id="how-to-improve-on-journaling"><a href="#how-to-improve-on-journaling" aria-label="Anchor"></a>How to Improve on Journaling</h2><p>The rollback journal is a simple trick to simulate atomicity and isolation and to provide durability to a database. Simple tricks are the best kind of tricks when you write a database so it&#39;s a great place to start.</p> <p>But it certainly has its trade-offs. Kicking out all other transactions whenever you need to write something can become a bottleneck for many applications that have concurrent users. When people say that SQLite doesn&#39;t scale, it&#39;s typically because they used the rollback journal.</p> <p>However, SQLite continued to improve and eventually introduced the write-ahead log (WAL) journaling mode and even the <code>wal2</code> journaling mode. These provide significantly better support for concurrent readers.</p> <p>This means that our inventory specialists in our example could each have a point-in-time view of all the ingredients—even while the sandwich maker continues to make sandwiches! We&#39;ll get into how this works in our next post on WAL mode.</p>  </section></div>
  </body>
</html>
