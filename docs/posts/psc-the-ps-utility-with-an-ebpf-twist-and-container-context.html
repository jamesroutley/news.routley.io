<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/loresuso/psc">Original</a>
    <h1>psc: The ps utility, with an eBPF twist and container context</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto"><strong>psc</strong> (ps container) is a fast process scanner that uses eBPF iterators and Google CEL to query system state with precision and full container context.</p>

<div dir="auto"><h3 tabindex="-1" dir="auto">Fast Kernel-Level Access with eBPF Iterators</h3><a id="user-content-fast-kernel-level-access-with-ebpf-iterators" aria-label="Permalink: Fast Kernel-Level Access with eBPF Iterators" href="#fast-kernel-level-access-with-ebpf-iterators"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">psc uses eBPF iterators to read process and file descriptor information directly from kernel data structures. This approach is:</p>
<ul dir="auto">
<li><strong>Fast</strong>: eBPF iterators are highly efficient compared to the proc filesystem, where traditional tooling spends most of its time executing system calls</li>
<li><strong>Complete</strong>: Access kernel information not traditionally exposed through <code>/proc</code>. I plan to add also a way to access certain fields of the <code>task_struct</code> on demand for advanced use, but this is just an idea</li>
<li><strong>Tamper-resistant</strong>: Bypasses the <code>/proc</code> filesystem entirely, providing visibility that cannot be subverted by userland rootkits or <code>LD_PRELOAD</code> tricks</li>
</ul>
<div dir="auto"><h3 tabindex="-1" dir="auto">Readable Queries with CEL</h3><a id="user-content-readable-queries-with-cel" aria-label="Permalink: Readable Queries with CEL" href="#readable-queries-with-cel"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Traditional Linux tools like <code>ps</code>, <code>lsof</code>, and <code>ss</code> are powerful but inflexible. They output fixed formats that require extensive piping through <code>grep</code>, <code>awk</code>, and <code>sed</code>:</p>
<div dir="auto" data-snippet-clipboard-copy-content="# Traditional: Find nginx processes owned by root
ps aux | grep nginx | grep root | grep -v grep

# psc: Express exactly what you mean
psc &#39;process.name == &#34;nginx&#34; &amp;&amp; process.user == &#34;root&#34;&#39;"><pre><span><span>#</span> Traditional: Find nginx processes owned by root</span>
ps aux <span>|</span> grep nginx <span>|</span> grep root <span>|</span> grep -v grep

<span><span>#</span> psc: Express exactly what you mean</span>
psc <span><span>&#39;</span>process.name == &#34;nginx&#34; &amp;&amp; process.user == &#34;root&#34;<span>&#39;</span></span></pre></div>
<div dir="auto" data-snippet-clipboard-copy-content="# Traditional: Find processes with established connections on port 443
ss -tnp | grep ESTAB | grep :443 | awk &#39;{print $6}&#39; | cut -d&#39;&#34;&#39; -f2

# psc: One clear expression
psc &#39;socket.state == established &amp;&amp; socket.dstPort == uint(443)&#39;"><pre><span><span>#</span> Traditional: Find processes with established connections on port 443</span>
ss -tnp <span>|</span> grep ESTAB <span>|</span> grep :443 <span>|</span> awk <span><span>&#39;</span>{print $6}<span>&#39;</span></span> <span>|</span> cut -d<span><span>&#39;</span>&#34;<span>&#39;</span></span> -f2

<span><span>#</span> psc: One clear expression</span>
psc <span><span>&#39;</span>socket.state == established &amp;&amp; socket.dstPort == uint(443)<span>&#39;</span></span></pre></div>
<p dir="auto">psc uses the <a href="https://github.com/google/cel-go">Common Expression Language (CEL)</a> to filter processes. CEL expressions read almost like natural language, making your scripts self-documenting and maintainable. No more deciphering complex pipelines of <code>grep | awk | sed | xargs</code>.</p>
<p dir="auto">The <code>-o</code> flag lets you output exactly the fields you need, eliminating post-processing entirely:</p>
<div dir="auto" data-snippet-clipboard-copy-content="psc &#39;socket.state == listen&#39; -o process.name,socket.srcPort"><pre>psc <span><span>&#39;</span>socket.state == listen<span>&#39;</span></span> -o process.name,socket.srcPort</pre></div>
<p dir="auto">Output presets are also available to quickly print common information:</p>
<div dir="auto" data-snippet-clipboard-copy-content="psc &#39;socket.type == tcp &amp;&amp; socket.dstPort == uint(443)&#39; -o sockets "><pre>psc <span><span>&#39;</span>socket.type == tcp &amp;&amp; socket.dstPort == uint(443)<span>&#39;</span></span> -o sockets </pre></div>

<p dir="auto">Traditional tools have no concept of containers. Getting container information requires parsing cgroup paths, querying container runtimes, and correlating PIDs manually:</p>
<div dir="auto" data-snippet-clipboard-copy-content="# Traditional: Find containerized processes (fragile, incomplete)
ps aux | xargs -I{} sh -c &#39;cat /proc/{}/cgroup 2&gt;/dev/null | grep -q docker &amp;&amp; echo {}&#39;

# psc: Native container support
psc &#39;container.runtime == docker&#39;"><pre><span><span>#</span> Traditional: Find containerized processes (fragile, incomplete)</span>
ps aux <span>|</span> xargs -I{} sh -c <span><span>&#39;</span>cat /proc/{}/cgroup 2&gt;/dev/null | grep -q docker &amp;&amp; echo {}<span>&#39;</span></span>

<span><span>#</span> psc: Native container support</span>
psc <span><span>&#39;</span>container.runtime == docker<span>&#39;</span></span></pre></div>
<p dir="auto">psc extracts container context (ID, name, image, runtime, labels) automatically for Docker, containerd, CRI-O, and Podman. Debug any container&#39;s processes, files, and network connections directly from the host:</p>
<div dir="auto" data-snippet-clipboard-copy-content="# Show all processes in a specific container
psc &#39;container.name == &#34;my-app&#34;&#39; --tree

# Find containers running as root
psc &#39;container.runtime == docker &amp;&amp; process.user == &#34;root&#34;&#39;

# List containers with their images
psc &#39;container.id != &#34;&#34;&#39; -o process.pid,process.name,container.name,container.image"><pre><span><span>#</span> Show all processes in a specific container</span>
psc <span><span>&#39;</span>container.name == &#34;my-app&#34;<span>&#39;</span></span> --tree

<span><span>#</span> Find containers running as root</span>
psc <span><span>&#39;</span>container.runtime == docker &amp;&amp; process.user == &#34;root&#34;<span>&#39;</span></span>

<span><span>#</span> List containers with their images</span>
psc <span><span>&#39;</span>container.id != &#34;&#34;<span>&#39;</span></span> -o process.pid,process.name,container.name,container.image</pre></div>


<ul dir="auto">
<li>Linux kernel 5.8 or later (eBPF iterators were introduced in this version)</li>
<li>Go 1.25 or later</li>
<li>Clang and LLVM</li>
<li>libbpf development headers</li>
<li>Linux kernel headers</li>
<li>bpftool (for generating vmlinux.h)</li>
</ul>

<p dir="auto">On Debian/Ubuntu:</p>
<div dir="auto" data-snippet-clipboard-copy-content="sudo apt-get install clang llvm libbpf-dev linux-headers-$(uname -r) linux-tools-$(uname -r)"><pre>sudo apt-get install clang llvm libbpf-dev linux-headers-<span><span>$(</span>uname -r<span>)</span></span> linux-tools-<span><span>$(</span>uname -r<span>)</span></span></pre></div>
<p dir="auto">On Fedora/RHEL:</p>
<div dir="auto" data-snippet-clipboard-copy-content="sudo dnf install clang llvm libbpf-devel kernel-devel bpftool"><pre>sudo dnf install clang llvm libbpf-devel kernel-devel bpftool</pre></div>

<div dir="auto" data-snippet-clipboard-copy-content="# Generate vmlinux.h (required once per kernel version)
make vmlinux

# Build the binary
make build"><pre><span><span>#</span> Generate vmlinux.h (required once per kernel version)</span>
make vmlinux

<span><span>#</span> Build the binary</span>
make build</pre></div>
<p dir="auto">Or manually:</p>
<div dir="auto" data-snippet-clipboard-copy-content="bpftool btf dump file /sys/kernel/btf/vmlinux format c &gt; bpf/vmlinux.h
go generate ./...
go build -o psc"><pre>bpftool btf dump file /sys/kernel/btf/vmlinux format c <span>&gt;</span> bpf/vmlinux.h
go generate ./...
go build -o psc</pre></div>



<p dir="auto">psc requires <strong>root privileges</strong> to load eBPF programs.</p>

<div dir="auto" data-snippet-clipboard-copy-content="# List all processes
sudo psc

# List all processes as a tree
sudo psc --tree"><pre><span><span>#</span> List all processes</span>
sudo psc

<span><span>#</span> List all processes as a tree</span>
sudo psc --tree</pre></div>
<div dir="auto"><h3 tabindex="-1" dir="auto">Filtering with CEL Expressions</h3><a id="user-content-filtering-with-cel-expressions" aria-label="Permalink: Filtering with CEL Expressions" href="#filtering-with-cel-expressions"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Pass a CEL expression as the first argument to filter processes:</p>
<div dir="auto" data-snippet-clipboard-copy-content="# Filter by process name
psc &#39;process.name == &#34;nginx&#34;&#39;

# Filter by user
psc &#39;process.user == &#34;root&#34;&#39;

# Filter by command line content
psc &#39;process.cmdline.contains(&#34;--config&#34;)&#39;

# Filter by PID range
psc &#39;process.pid &gt; 1000 &amp;&amp; process.pid &lt; 2000&#39;

# Combine conditions
psc &#39;process.name == &#34;bash&#34; || process.name == &#34;zsh&#34;&#39;"><pre><span><span>#</span> Filter by process name</span>
psc <span><span>&#39;</span>process.name == &#34;nginx&#34;<span>&#39;</span></span>

<span><span>#</span> Filter by user</span>
psc <span><span>&#39;</span>process.user == &#34;root&#34;<span>&#39;</span></span>

<span><span>#</span> Filter by command line content</span>
psc <span><span>&#39;</span>process.cmdline.contains(&#34;--config&#34;)<span>&#39;</span></span>

<span><span>#</span> Filter by PID range</span>
psc <span><span>&#39;</span>process.pid &gt; 1000 &amp;&amp; process.pid &lt; 2000<span>&#39;</span></span>

<span><span>#</span> Combine conditions</span>
psc <span><span>&#39;</span>process.name == &#34;bash&#34; || process.name == &#34;zsh&#34;<span>&#39;</span></span></pre></div>

<div dir="auto" data-snippet-clipboard-copy-content="# Show only containerized processes
psc &#39;container.id != &#34;&#34;&#39;

# Filter by container runtime (constants: docker, containerd, crio, podman)
psc &#39;container.runtime == docker&#39;

# Filter by container name
psc &#39;container.name == &#34;nginx&#34;&#39;

# Filter by container image
psc &#39;container.image.contains(&#34;nginx:latest&#34;)&#39;

# Show as tree to see container process hierarchy
psc &#39;container.runtime == docker&#39; --tree"><pre><span><span>#</span> Show only containerized processes</span>
psc <span><span>&#39;</span>container.id != &#34;&#34;<span>&#39;</span></span>

<span><span>#</span> Filter by container runtime (constants: docker, containerd, crio, podman)</span>
psc <span><span>&#39;</span>container.runtime == docker<span>&#39;</span></span>

<span><span>#</span> Filter by container name</span>
psc <span><span>&#39;</span>container.name == &#34;nginx&#34;<span>&#39;</span></span>

<span><span>#</span> Filter by container image</span>
psc <span><span>&#39;</span>container.image.contains(&#34;nginx:latest&#34;)<span>&#39;</span></span>

<span><span>#</span> Show as tree to see container process hierarchy</span>
psc <span><span>&#39;</span>container.runtime == docker<span>&#39;</span></span> --tree</pre></div>
<div dir="auto"><h3 tabindex="-1" dir="auto">Socket and File Descriptor Filtering</h3><a id="user-content-socket-and-file-descriptor-filtering" aria-label="Permalink: Socket and File Descriptor Filtering" href="#socket-and-file-descriptor-filtering"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Understanding why a process exists often requires looking at its open file descriptors and network connections:</p>
<div dir="auto" data-snippet-clipboard-copy-content="# Find processes with listening TCP sockets
psc &#39;socket.type == tcp &amp;&amp; socket.state == listen&#39;

# Find processes with established connections
psc &#39;socket.state == established&#39;

# Find processes connected to a specific port
psc &#39;socket.dstPort == uint(443)&#39;

# Find processes using Unix sockets
psc &#39;socket.family == unix&#39;

# Find processes with files open in /etc
psc &#39;file.path.startsWith(&#34;/etc&#34;)&#39;"><pre><span><span>#</span> Find processes with listening TCP sockets</span>
psc <span><span>&#39;</span>socket.type == tcp &amp;&amp; socket.state == listen<span>&#39;</span></span>

<span><span>#</span> Find processes with established connections</span>
psc <span><span>&#39;</span>socket.state == established<span>&#39;</span></span>

<span><span>#</span> Find processes connected to a specific port</span>
psc <span><span>&#39;</span>socket.dstPort == uint(443)<span>&#39;</span></span>

<span><span>#</span> Find processes using Unix sockets</span>
psc <span><span>&#39;</span>socket.family == unix<span>&#39;</span></span>

<span><span>#</span> Find processes with files open in /etc</span>
psc <span><span>&#39;</span>file.path.startsWith(&#34;/etc&#34;)<span>&#39;</span></span></pre></div>

<p dir="auto"><strong>Process fields</strong> (<code>process.X</code>):</p>
<ul dir="auto">
<li><code>name</code> - Process name (string)</li>
<li><code>pid</code> - Process ID (int)</li>
<li><code>ppid</code> - Parent process ID (int)</li>
<li><code>tid</code> - Thread ID (int)</li>
<li><code>euid</code> - Effective user ID (int)</li>
<li><code>ruid</code> - Real user ID (int)</li>
<li><code>suid</code> - Saved set-user-ID (int)</li>
<li><code>user</code> - Username (string)</li>
<li><code>cmdline</code> - Full command line (string)</li>
<li><code>state</code> - Process state (uint)</li>
</ul>
<p dir="auto"><strong>Capability fields</strong> (<code>process.capabilities.X</code>):</p>
<ul dir="auto">
<li><code>effective</code> - Effective capabilities bitmask (uint)</li>
<li><code>permitted</code> - Permitted capabilities bitmask (uint)</li>
<li><code>inheritable</code> - Inheritable capabilities bitmask (uint)</li>
</ul>
<p dir="auto"><strong>Namespace fields</strong> (<code>process.namespaces.X</code>):</p>
<ul dir="auto">
<li><code>net</code> - Network namespace inode (uint)</li>
<li><code>pid</code> - PID namespace inode (uint)</li>
<li><code>mnt</code> - Mount namespace inode (uint)</li>
<li><code>uts</code> - UTS namespace inode (uint)</li>
<li><code>ipc</code> - IPC namespace inode (uint)</li>
<li><code>cgroup</code> - Cgroup namespace inode (uint)</li>
</ul>
<p dir="auto"><strong>Container fields</strong> (<code>container.X</code>):</p>
<ul dir="auto">
<li><code>id</code> - Container ID (string)</li>
<li><code>name</code> - Container name (string)</li>
<li><code>image</code> - Container image (string)</li>
<li><code>runtime</code> - Container runtime (string)</li>
<li><code>labels</code> - Container labels (map)</li>
</ul>
<p dir="auto"><strong>File/Socket fields</strong> (<code>file.X</code> or <code>socket.X</code>):</p>
<ul dir="auto">
<li><code>path</code> - File path (string)</li>
<li><code>fd</code> - File descriptor number (int)</li>
<li><code>srcPort</code> - Source port (uint, use <code>uint()</code> for comparisons: <code>socket.srcPort == uint(80)</code>)</li>
<li><code>dstPort</code> - Destination port (uint, use <code>uint()</code> for comparisons: <code>socket.dstPort == uint(443)</code>)</li>
<li><code>type</code> - Socket type (tcp, udp)</li>
<li><code>state</code> - Socket state (for filtering, use constants like <code>listen</code>, <code>established</code>)</li>
<li><code>family</code> - Address family (unix, inet, inet6)</li>
<li><code>unixPath</code> - Unix socket path (string)</li>
<li><code>fdType</code> - FD type (file_type, socket_type)</li>
</ul>

<p dir="auto">Use these without quotes in expressions:</p>
<ul dir="auto">
<li><strong>Runtimes</strong>: <code>docker</code>, <code>containerd</code>, <code>crio</code>, <code>podman</code></li>
<li><strong>Socket types</strong>: <code>tcp</code>, <code>udp</code></li>
<li><strong>Address families</strong>: <code>unix</code>, <code>inet</code>, <code>inet6</code></li>
<li><strong>Socket states</strong> (for filtering): <code>established</code>, <code>listen</code>, <code>syn_sent</code>, <code>syn_recv</code>, <code>fin_wait1</code>, <code>fin_wait2</code>, <code>time_wait</code>, <code>close</code>, <code>close_wait</code>, <code>last_ack</code>, <code>closing</code></li>
<li><strong>FD types</strong>: <code>file_type</code>, <code>socket_type</code></li>
</ul>
<blockquote>
<p dir="auto"><strong>Note</strong>: Output uses <code>ss</code>-style state names: <code>ESTAB</code>, <code>LISTEN</code>, <code>SYN-SENT</code>, etc. For UDP sockets, only <code>UNCONN</code> (unconnected) or <code>ESTAB</code> (connected) are shown since UDP is connectionless.</p>
</blockquote>

<p dir="auto">CEL provides string manipulation functions:</p>
<ul dir="auto">
<li><code>.contains(&#34;substr&#34;)</code> - Check if string contains substring</li>
<li><code>.startsWith(&#34;prefix&#34;)</code> - Check if string starts with prefix</li>
<li><code>.endsWith(&#34;suffix&#34;)</code> - Check if string ends with suffix</li>
</ul>

<ul dir="auto">
<li><code>--tree</code>, <code>-t</code> - Display processes as a tree</li>
<li><code>--no-color</code> - Disable colored output</li>
<li><code>-o</code>, <code>--output</code> - Custom output columns (comma-separated field names or preset)</li>
</ul>

<ul dir="auto">
<li><code>psc fields</code> - List all available CEL fields, constants, and output presets</li>
<li><code>psc version</code> - Show version information</li>
</ul>

<p dir="auto">The <code>-o</code> flag lets you specify exactly which fields to display. You can use <strong>presets</strong> for common use cases or specify individual fields.</p>
<p dir="auto"><strong>Presets:</strong></p>
<ul dir="auto">
<li><code>sockets</code> - Process info + full socket details (family, type, state, addresses, ports)</li>
<li><code>files</code> - Process info + file descriptor details (fd, type, path)</li>
<li><code>containers</code> - Process info + container details (name, image, runtime)</li>
<li><code>network</code> - Compact network view (pid, name, type, state, ports)</li>
</ul>
<div dir="auto" data-snippet-clipboard-copy-content="# Use a preset
psc &#39;socket.state == listen&#39; -o sockets
psc &#39;container.id != &#34;&#34;&#39; -o containers

# Or specify individual fields
psc -o process.pid,process.name,process.user
psc &#39;socket.state == listen&#39; -o process.pid,process.name,socket.srcPort,socket.state"><pre><span><span>#</span> Use a preset</span>
psc <span><span>&#39;</span>socket.state == listen<span>&#39;</span></span> -o sockets
psc <span><span>&#39;</span>container.id != &#34;&#34;<span>&#39;</span></span> -o containers

<span><span>#</span> Or specify individual fields</span>
psc -o process.pid,process.name,process.user
psc <span><span>&#39;</span>socket.state == listen<span>&#39;</span></span> -o process.pid,process.name,socket.srcPort,socket.state</pre></div>
<p dir="auto">When the output includes file/socket fields and the filter matches multiple files per process, each match gets its own row:</p>
<div dir="auto" data-snippet-clipboard-copy-content="$ psc &#39;socket.state == listen&#39; -o network

PID      NAME      TYPE   STATE    SRCPORT   DSTPORT
1234     nginx     tcp    LISTEN   80        0
1234     nginx     tcp    LISTEN   443       0
5678     sshd      tcp    LISTEN   22        0"><pre>$ psc <span><span>&#39;</span>socket.state == listen<span>&#39;</span></span> -o network

PID      NAME      TYPE   STATE    SRCPORT   DSTPORT
1234     nginx     tcp    LISTEN   80        0
1234     nginx     tcp    LISTEN   443       0
5678     sshd      tcp    LISTEN   22        0</pre></div>

<p dir="auto">Find all web servers:</p>
<div dir="auto" data-snippet-clipboard-copy-content="psc &#39;process.name == &#34;nginx&#34; || process.name == &#34;apache2&#34; || process.name == &#34;httpd&#34;&#39;"><pre>psc <span><span>&#39;</span>process.name == &#34;nginx&#34; || process.name == &#34;apache2&#34; || process.name == &#34;httpd&#34;<span>&#39;</span></span></pre></div>
<p dir="auto">Find processes listening on privileged ports:</p>
<div dir="auto" data-snippet-clipboard-copy-content="psc &#39;socket.state == listen &amp;&amp; socket.srcPort &lt; uint(1024)&#39;"><pre>psc <span><span>&#39;</span>socket.state == listen &amp;&amp; socket.srcPort &lt; uint(1024)<span>&#39;</span></span></pre></div>
<p dir="auto">Find processes in a different network namespace (useful for container/pod inspection):</p>
<div dir="auto" data-snippet-clipboard-copy-content="psc &#39;process.namespaces.net != uint(4026531840)&#39; -o process.pid,process.name,process.namespaces.net"><pre>psc <span><span>&#39;</span>process.namespaces.net != uint(4026531840)<span>&#39;</span></span> -o process.pid,process.name,process.namespaces.net</pre></div>
<p dir="auto">Show capabilities for privileged processes:</p>
<div dir="auto" data-snippet-clipboard-copy-content="psc &#39;process.euid == 0&#39; -o process.pid,process.name,process.capabilities.effective,process.capabilities.permitted"><pre>psc <span><span>&#39;</span>process.euid == 0<span>&#39;</span></span> -o process.pid,process.name,process.capabilities.effective,process.capabilities.permitted</pre></div>
<p dir="auto">Find processes that elevated privileges via SUID binaries (real UID differs from effective UID):</p>
<div dir="auto" data-snippet-clipboard-copy-content="psc &#39;process.ruid != process.euid&#39;"><pre>psc <span><span>&#39;</span>process.ruid != process.euid<span>&#39;</span></span></pre></div>
<p dir="auto">Find processes with connections to external services:</p>
<div dir="auto" data-snippet-clipboard-copy-content="psc &#39;socket.state == established &amp;&amp; socket.dstPort == uint(443)&#39;"><pre>psc <span><span>&#39;</span>socket.state == established &amp;&amp; socket.dstPort == uint(443)<span>&#39;</span></span></pre></div>
<p dir="auto">Show network connections with custom columns:</p>
<div dir="auto" data-snippet-clipboard-copy-content="psc &#39;socket.state == established&#39; -o process.pid,process.name,socket.srcPort,socket.dstPort,socket.dstAddr"><pre>psc <span><span>&#39;</span>socket.state == established<span>&#39;</span></span> -o process.pid,process.name,socket.srcPort,socket.dstPort,socket.dstAddr</pre></div>

<p dir="auto">MIT</p>
</article></div></div>
  </body>
</html>
