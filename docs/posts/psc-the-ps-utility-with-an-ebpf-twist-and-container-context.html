<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/loresuso/psc">Original</a>
    <h1>psc: The ps utility, with an eBPF twist and container context</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto"><strong>psc</strong> (ps container) is a process scanner that uses eBPF iterators and Google CEL to query system state with precision and full container context.</p>
<p dir="auto">psc requires root privileges to load eBPF programs.</p>

<p dir="auto">Traditional Linux tools like <code>ps</code>, <code>lsof</code>, and <code>ss</code> are powerful but inflexible. They output fixed formats that require extensive piping through <code>grep</code>, <code>awk</code>, and <code>sed</code> to extract useful information:</p>
<div dir="auto" data-snippet-clipboard-copy-content="# Find all nginx processes owned by root
ps aux | grep nginx | grep root | grep -v grep

# With psc:
psc &#39;process.name == &#34;nginx&#34; &amp;&amp; process.user == &#34;root&#34;&#39;"><pre><span><span>#</span> Find all nginx processes owned by root</span>
ps aux <span>|</span> grep nginx <span>|</span> grep root <span>|</span> grep -v grep

<span><span>#</span> With psc:</span>
psc <span><span>&#39;</span>process.name == &#34;nginx&#34; &amp;&amp; process.user == &#34;root&#34;<span>&#39;</span></span></pre></div>
<div dir="auto" data-snippet-clipboard-copy-content="# Find processes with established connections on port 443
ss -tnp | grep ESTAB | grep :443 | awk &#39;{print $6}&#39; | cut -d&#39;&#34;&#39; -f2

# With psc:
psc &#39;socket.state == established &amp;&amp; socket.dstPort == uint(443)&#39;"><pre><span><span>#</span> Find processes with established connections on port 443</span>
ss -tnp <span>|</span> grep ESTAB <span>|</span> grep :443 <span>|</span> awk <span><span>&#39;</span>{print $6}<span>&#39;</span></span> <span>|</span> cut -d<span><span>&#39;</span>&#34;<span>&#39;</span></span> -f2

<span><span>#</span> With psc:</span>
psc <span><span>&#39;</span>socket.state == established &amp;&amp; socket.dstPort == uint(443)<span>&#39;</span></span></pre></div>
<div dir="auto" data-snippet-clipboard-copy-content="# Find containerized processes
ps aux | xargs -I{} sh -c &#39;cat /proc/{}/cgroup 2&gt;/dev/null | grep -q docker &amp;&amp; echo {}&#39;

# With psc:
psc &#39;container.runtime == docker&#39;"><pre><span><span>#</span> Find containerized processes</span>
ps aux <span>|</span> xargs -I{} sh -c <span><span>&#39;</span>cat /proc/{}/cgroup 2&gt;/dev/null | grep -q docker &amp;&amp; echo {}<span>&#39;</span></span>

<span><span>#</span> With psc:</span>
psc <span><span>&#39;</span>container.runtime == docker<span>&#39;</span></span></pre></div>
<p dir="auto">These tools also read from <code>/proc</code>, a virtual filesystem that can be manipulated by userland rootkits. A compromised library loaded via <code>LD_PRELOAD</code> can intercept system calls and hide processes, network connections, or files from these traditional utilities.</p>

<div dir="auto"><h3 tabindex="-1" dir="auto">eBPF Iterators for Kernel-Level Visibility</h3><a id="user-content-ebpf-iterators-for-kernel-level-visibility" aria-label="Permalink: eBPF Iterators for Kernel-Level Visibility" href="#ebpf-iterators-for-kernel-level-visibility"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">psc uses eBPF iterators to read process and file descriptor information directly from kernel data structures. This bypasses the <code>/proc</code> filesystem entirely, providing visibility that cannot be subverted by userland rootkits or <code>LD_PRELOAD</code> tricks. When an attacker uses <code>LD_PRELOAD</code> to inject a malicious shared library that intercepts calls to <code>readdir()</code> or <code>open()</code>, traditional tools see only what the rootkit allows. psc reads kernel memory directly via eBPF, seeing the true system state.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">Google CEL for Flexible Queries</h3><a id="user-content-google-cel-for-flexible-queries" aria-label="Permalink: Google CEL for Flexible Queries" href="#google-cel-for-flexible-queries"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Instead of chaining <code>grep</code> commands, psc uses the <a href="https://github.com/google/cel-go">Common Expression Language (CEL)</a> to filter processes. CEL is a simple, safe expression language designed for evaluating boolean conditions. It allows you to answer:</p>
<ul dir="auto">
<li><strong>What</strong> is running: Filter by process name, command line, user, or PID</li>
<li><strong>Where</strong> it is running: Filter by container runtime, container name, image, or labels</li>
<li><strong>Why</strong> it is running: Inspect open file descriptors, network connections (ports, states, protocols), and socket types to understand what a process is doing and why it exists</li>
</ul>
<div dir="auto"><h3 tabindex="-1" dir="auto">Debug Containers from the Host</h3><a id="user-content-debug-containers-from-the-host" aria-label="Permalink: Debug Containers from the Host" href="#debug-containers-from-the-host"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">With psc, you can inspect any container&#39;s processes, open files, and network connections directly from the host.</p>


<ul dir="auto">
<li>Linux kernel 5.8 or later (eBPF iterators were introduced in this version)</li>
<li>Go 1.25 or later</li>
<li>Clang and LLVM</li>
<li>libbpf development headers</li>
<li>Linux kernel headers</li>
<li>bpftool (for generating vmlinux.h)</li>
</ul>

<p dir="auto">On Debian/Ubuntu:</p>
<div dir="auto" data-snippet-clipboard-copy-content="sudo apt-get install clang llvm libbpf-dev linux-headers-$(uname -r) linux-tools-$(uname -r)"><pre>sudo apt-get install clang llvm libbpf-dev linux-headers-<span><span>$(</span>uname -r<span>)</span></span> linux-tools-<span><span>$(</span>uname -r<span>)</span></span></pre></div>
<p dir="auto">On Fedora/RHEL:</p>
<div dir="auto" data-snippet-clipboard-copy-content="sudo dnf install clang llvm libbpf-devel kernel-devel bpftool"><pre>sudo dnf install clang llvm libbpf-devel kernel-devel bpftool</pre></div>

<div dir="auto" data-snippet-clipboard-copy-content="# Generate vmlinux.h (required once per kernel version)
make vmlinux

# Build the binary
make build"><pre><span><span>#</span> Generate vmlinux.h (required once per kernel version)</span>
make vmlinux

<span><span>#</span> Build the binary</span>
make build</pre></div>
<p dir="auto">Or manually:</p>
<div dir="auto" data-snippet-clipboard-copy-content="bpftool btf dump file /sys/kernel/btf/vmlinux format c &gt; bpf/vmlinux.h
go generate ./...
go build -o psc"><pre>bpftool btf dump file /sys/kernel/btf/vmlinux format c <span>&gt;</span> bpf/vmlinux.h
go generate ./...
go build -o psc</pre></div>




<div dir="auto" data-snippet-clipboard-copy-content="# List all processes
psc

# List all processes as a tree
psc --tree"><pre><span><span>#</span> List all processes</span>
psc

<span><span>#</span> List all processes as a tree</span>
psc --tree</pre></div>
<div dir="auto"><h3 tabindex="-1" dir="auto">Filtering with CEL Expressions</h3><a id="user-content-filtering-with-cel-expressions" aria-label="Permalink: Filtering with CEL Expressions" href="#filtering-with-cel-expressions"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Pass a CEL expression as the first argument to filter processes:</p>
<div dir="auto" data-snippet-clipboard-copy-content="# Filter by process name
psc &#39;process.name == &#34;nginx&#34;&#39;

# Filter by user
psc &#39;process.user == &#34;root&#34;&#39;

# Filter by command line content
psc &#39;process.cmdline.contains(&#34;--config&#34;)&#39;

# Filter by PID range
psc &#39;process.pid &gt; 1000 &amp;&amp; process.pid &lt; 2000&#39;

# Combine conditions
psc &#39;process.name == &#34;bash&#34; || process.name == &#34;zsh&#34;&#39;"><pre><span><span>#</span> Filter by process name</span>
psc <span><span>&#39;</span>process.name == &#34;nginx&#34;<span>&#39;</span></span>

<span><span>#</span> Filter by user</span>
psc <span><span>&#39;</span>process.user == &#34;root&#34;<span>&#39;</span></span>

<span><span>#</span> Filter by command line content</span>
psc <span><span>&#39;</span>process.cmdline.contains(&#34;--config&#34;)<span>&#39;</span></span>

<span><span>#</span> Filter by PID range</span>
psc <span><span>&#39;</span>process.pid &gt; 1000 &amp;&amp; process.pid &lt; 2000<span>&#39;</span></span>

<span><span>#</span> Combine conditions</span>
psc <span><span>&#39;</span>process.name == &#34;bash&#34; || process.name == &#34;zsh&#34;<span>&#39;</span></span></pre></div>

<div dir="auto" data-snippet-clipboard-copy-content="# Show only containerized processes
psc &#39;container.id != &#34;&#34;&#39;

# Filter by container runtime (constants: docker, containerd, crio, podman)
psc &#39;container.runtime == docker&#39;

# Filter by container name
psc &#39;container.name == &#34;nginx&#34;&#39;

# Filter by container image
psc &#39;container.image.contains(&#34;nginx:latest&#34;)&#39;

# Show as tree to see container process hierarchy
psc &#39;container.runtime == docker&#39; --tree"><pre><span><span>#</span> Show only containerized processes</span>
psc <span><span>&#39;</span>container.id != &#34;&#34;<span>&#39;</span></span>

<span><span>#</span> Filter by container runtime (constants: docker, containerd, crio, podman)</span>
psc <span><span>&#39;</span>container.runtime == docker<span>&#39;</span></span>

<span><span>#</span> Filter by container name</span>
psc <span><span>&#39;</span>container.name == &#34;nginx&#34;<span>&#39;</span></span>

<span><span>#</span> Filter by container image</span>
psc <span><span>&#39;</span>container.image.contains(&#34;nginx:latest&#34;)<span>&#39;</span></span>

<span><span>#</span> Show as tree to see container process hierarchy</span>
psc <span><span>&#39;</span>container.runtime == docker<span>&#39;</span></span> --tree</pre></div>
<div dir="auto"><h3 tabindex="-1" dir="auto">Socket and File Descriptor Filtering</h3><a id="user-content-socket-and-file-descriptor-filtering" aria-label="Permalink: Socket and File Descriptor Filtering" href="#socket-and-file-descriptor-filtering"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Understanding why a process exists often requires looking at its open file descriptors and network connections:</p>
<div dir="auto" data-snippet-clipboard-copy-content="# Find processes with listening TCP sockets
psc &#39;socket.type == tcp &amp;&amp; socket.state == listen&#39;

# Find processes with established connections
psc &#39;socket.state == established&#39;

# Find processes connected to a specific port
psc &#39;socket.dstPort == uint(443)&#39;

# Find processes using Unix sockets
psc &#39;socket.family == unix&#39;

# Find processes with files open in /etc
psc &#39;file.path.startsWith(&#34;/etc&#34;)&#39;"><pre><span><span>#</span> Find processes with listening TCP sockets</span>
psc <span><span>&#39;</span>socket.type == tcp &amp;&amp; socket.state == listen<span>&#39;</span></span>

<span><span>#</span> Find processes with established connections</span>
psc <span><span>&#39;</span>socket.state == established<span>&#39;</span></span>

<span><span>#</span> Find processes connected to a specific port</span>
psc <span><span>&#39;</span>socket.dstPort == uint(443)<span>&#39;</span></span>

<span><span>#</span> Find processes using Unix sockets</span>
psc <span><span>&#39;</span>socket.family == unix<span>&#39;</span></span>

<span><span>#</span> Find processes with files open in /etc</span>
psc <span><span>&#39;</span>file.path.startsWith(&#34;/etc&#34;)<span>&#39;</span></span></pre></div>

<p dir="auto"><strong>Process fields</strong> (<code>process.X</code>):</p>
<ul dir="auto">
<li><code>name</code> - Process name (string)</li>
<li><code>pid</code> - Process ID (int)</li>
<li><code>ppid</code> - Parent process ID (int)</li>
<li><code>tid</code> - Thread ID (int)</li>
<li><code>euid</code> - Effective user ID (int)</li>
<li><code>ruid</code> - Real user ID (int)</li>
<li><code>suid</code> - Saved set-user-ID (int)</li>
<li><code>user</code> - Username (string)</li>
<li><code>cmdline</code> - Full command line (string)</li>
<li><code>state</code> - Process state (uint)</li>
</ul>
<p dir="auto"><strong>Capability fields</strong> (<code>process.capabilities.X</code>):</p>
<ul dir="auto">
<li><code>effective</code> - Effective capabilities bitmask (uint)</li>
<li><code>permitted</code> - Permitted capabilities bitmask (uint)</li>
<li><code>inheritable</code> - Inheritable capabilities bitmask (uint)</li>
</ul>
<p dir="auto"><strong>Namespace fields</strong> (<code>process.namespaces.X</code>):</p>
<ul dir="auto">
<li><code>net</code> - Network namespace inode (uint)</li>
<li><code>pid</code> - PID namespace inode (uint)</li>
<li><code>mnt</code> - Mount namespace inode (uint)</li>
<li><code>uts</code> - UTS namespace inode (uint)</li>
<li><code>ipc</code> - IPC namespace inode (uint)</li>
<li><code>cgroup</code> - Cgroup namespace inode (uint)</li>
</ul>
<p dir="auto"><strong>Container fields</strong> (<code>container.X</code>):</p>
<ul dir="auto">
<li><code>id</code> - Container ID (string)</li>
<li><code>name</code> - Container name (string)</li>
<li><code>image</code> - Container image (string)</li>
<li><code>runtime</code> - Container runtime (string)</li>
<li><code>labels</code> - Container labels (map)</li>
</ul>
<p dir="auto"><strong>File/Socket fields</strong> (<code>file.X</code> or <code>socket.X</code>):</p>
<ul dir="auto">
<li><code>path</code> - File path (string)</li>
<li><code>fd</code> - File descriptor number (int)</li>
<li><code>srcPort</code> - Source port (uint, use <code>uint()</code> for comparisons: <code>socket.srcPort == uint(80)</code>)</li>
<li><code>dstPort</code> - Destination port (uint, use <code>uint()</code> for comparisons: <code>socket.dstPort == uint(443)</code>)</li>
<li><code>type</code> - Socket type (tcp, udp)</li>
<li><code>state</code> - Socket state (for filtering, use constants like <code>listen</code>, <code>established</code>)</li>
<li><code>family</code> - Address family (unix, inet, inet6)</li>
<li><code>unixPath</code> - Unix socket path (string)</li>
<li><code>fdType</code> - FD type (file_type, socket_type)</li>
</ul>

<p dir="auto">Use these without quotes in expressions:</p>
<ul dir="auto">
<li><strong>Runtimes</strong>: <code>docker</code>, <code>containerd</code>, <code>crio</code>, <code>podman</code></li>
<li><strong>Socket types</strong>: <code>tcp</code>, <code>udp</code></li>
<li><strong>Address families</strong>: <code>unix</code>, <code>inet</code>, <code>inet6</code></li>
<li><strong>Socket states</strong> (for filtering): <code>established</code>, <code>listen</code>, <code>syn_sent</code>, <code>syn_recv</code>, <code>fin_wait1</code>, <code>fin_wait2</code>, <code>time_wait</code>, <code>close</code>, <code>close_wait</code>, <code>last_ack</code>, <code>closing</code></li>
<li><strong>FD types</strong>: <code>file_type</code>, <code>socket_type</code></li>
</ul>
<blockquote>
<p dir="auto"><strong>Note</strong>: Output uses <code>ss</code>-style state names: <code>ESTAB</code>, <code>LISTEN</code>, <code>SYN-SENT</code>, etc. For UDP sockets, only <code>UNCONN</code> (unconnected) or <code>ESTAB</code> (connected) are shown since UDP is connectionless.</p>
</blockquote>

<p dir="auto">CEL provides string manipulation functions:</p>
<ul dir="auto">
<li><code>.contains(&#34;substr&#34;)</code> - Check if string contains substring</li>
<li><code>.startsWith(&#34;prefix&#34;)</code> - Check if string starts with prefix</li>
<li><code>.endsWith(&#34;suffix&#34;)</code> - Check if string ends with suffix</li>
</ul>

<ul dir="auto">
<li><code>--tree</code>, <code>-t</code> - Display processes as a tree</li>
<li><code>--no-color</code> - Disable colored output</li>
<li><code>-o</code>, <code>--output</code> - Custom output columns (comma-separated field names)</li>
</ul>

<p dir="auto">The <code>-o</code> flag lets you specify exactly which fields to display. You can use <strong>presets</strong> for common use cases or specify individual fields.</p>
<p dir="auto"><strong>Presets:</strong></p>
<ul dir="auto">
<li><code>sockets</code> - Process info + full socket details (family, type, state, addresses, ports)</li>
<li><code>files</code> - Process info + file descriptor details (fd, type, path)</li>
<li><code>containers</code> - Process info + container details (name, image, runtime)</li>
<li><code>network</code> - Compact network view (pid, name, type, state, ports)</li>
</ul>
<div dir="auto" data-snippet-clipboard-copy-content="# Use a preset
psc &#39;socket.state == listen&#39; -o sockets
psc &#39;container.id != &#34;&#34;&#39; -o containers

# Or specify individual fields
psc -o process.pid,process.name,process.user
psc &#39;socket.state == listen&#39; -o process.pid,process.name,socket.srcPort,socket.state"><pre><span><span>#</span> Use a preset</span>
psc <span><span>&#39;</span>socket.state == listen<span>&#39;</span></span> -o sockets
psc <span><span>&#39;</span>container.id != &#34;&#34;<span>&#39;</span></span> -o containers

<span><span>#</span> Or specify individual fields</span>
psc -o process.pid,process.name,process.user
psc <span><span>&#39;</span>socket.state == listen<span>&#39;</span></span> -o process.pid,process.name,socket.srcPort,socket.state</pre></div>
<p dir="auto">When the output includes file/socket fields and the filter matches multiple files per process, each match gets its own row:</p>
<div dir="auto" data-snippet-clipboard-copy-content="$ psc &#39;socket.state == listen&#39; -o network

PID      NAME      TYPE   STATE    SRCPORT   DSTPORT
1234     nginx     tcp    LISTEN   80        0
1234     nginx     tcp    LISTEN   443       0
5678     sshd      tcp    LISTEN   22        0"><pre>$ psc <span><span>&#39;</span>socket.state == listen<span>&#39;</span></span> -o network

PID      NAME      TYPE   STATE    SRCPORT   DSTPORT
1234     nginx     tcp    LISTEN   80        0
1234     nginx     tcp    LISTEN   443       0
5678     sshd      tcp    LISTEN   22        0</pre></div>
<p dir="auto">Use <code>psc fields</code> to list all available fields and presets:</p>


<p dir="auto">Find all web servers:</p>
<div dir="auto" data-snippet-clipboard-copy-content="psc &#39;process.name == &#34;nginx&#34; || process.name == &#34;apache2&#34; || process.name == &#34;httpd&#34;&#39;"><pre>psc <span><span>&#39;</span>process.name == &#34;nginx&#34; || process.name == &#34;apache2&#34; || process.name == &#34;httpd&#34;<span>&#39;</span></span></pre></div>
<p dir="auto">Find processes listening on privileged ports:</p>
<div dir="auto" data-snippet-clipboard-copy-content="psc &#39;socket.state == listen &amp;&amp; socket.srcPort &lt; uint(1024)&#39;"><pre>psc <span><span>&#39;</span>socket.state == listen &amp;&amp; socket.srcPort &lt; uint(1024)<span>&#39;</span></span></pre></div>
<p dir="auto">Find processes in a different network namespace (useful for container/pod inspection):</p>
<div dir="auto" data-snippet-clipboard-copy-content="psc &#39;process.namespaces.net != uint(4026531840)&#39; -o process.pid,process.name,process.namespaces.net"><pre>psc <span><span>&#39;</span>process.namespaces.net != uint(4026531840)<span>&#39;</span></span> -o process.pid,process.name,process.namespaces.net</pre></div>
<p dir="auto">Show capabilities for privileged processes:</p>
<div dir="auto" data-snippet-clipboard-copy-content="psc &#39;process.euid == 0&#39; -o process.pid,process.name,process.capabilities.effective,process.capabilities.permitted"><pre>psc <span><span>&#39;</span>process.euid == 0<span>&#39;</span></span> -o process.pid,process.name,process.capabilities.effective,process.capabilities.permitted</pre></div>
<p dir="auto">Find processes that elevated privileges via SUID binaries (real UID differs from effective UID):</p>
<div dir="auto" data-snippet-clipboard-copy-content="psc &#39;process.ruid != process.euid&#39;"><pre>psc <span><span>&#39;</span>process.ruid != process.euid<span>&#39;</span></span></pre></div>
<p dir="auto">Find Docker containers running as root:</p>
<div dir="auto" data-snippet-clipboard-copy-content="psc &#39;container.runtime == docker &amp;&amp; process.user == &#34;root&#34;&#39;"><pre>psc <span><span>&#39;</span>container.runtime == docker &amp;&amp; process.user == &#34;root&#34;<span>&#39;</span></span></pre></div>
<p dir="auto">Debug a specific container:</p>
<div dir="auto" data-snippet-clipboard-copy-content="psc &#39;container.name == &#34;my-app&#34;&#39; --tree"><pre>psc <span><span>&#39;</span>container.name == &#34;my-app&#34;<span>&#39;</span></span> --tree</pre></div>
<p dir="auto">Find processes with connections to external services:</p>
<div dir="auto" data-snippet-clipboard-copy-content="psc &#39;socket.state == established &amp;&amp; socket.dstPort == uint(443)&#39;"><pre>psc <span><span>&#39;</span>socket.state == established &amp;&amp; socket.dstPort == uint(443)<span>&#39;</span></span></pre></div>
<p dir="auto">Show network connections with custom columns:</p>
<div dir="auto" data-snippet-clipboard-copy-content="psc &#39;socket.state == established&#39; -o process.pid,process.name,socket.srcPort,socket.dstPort,socket.dstAddr"><pre>psc <span><span>&#39;</span>socket.state == established<span>&#39;</span></span> -o process.pid,process.name,socket.srcPort,socket.dstPort,socket.dstAddr</pre></div>
<p dir="auto">List containerized processes with their container info:</p>
<div dir="auto" data-snippet-clipboard-copy-content="psc &#39;container.id != &#34;&#34;&#39; -o process.pid,process.name,process.user,container.name,container.image"><pre>psc <span><span>&#39;</span>container.id != &#34;&#34;<span>&#39;</span></span> -o process.pid,process.name,process.user,container.name,container.image</pre></div>

<p dir="auto">MIT</p>
</article></div></div>
  </body>
</html>
