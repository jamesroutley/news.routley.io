<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://crocidb.com/post/rendering-doom-with-emojis/">Original</a>
    <h1>Rendering Doom with Emojis</h1>
    
    <div id="readability-page-1" class="page"><article>
      <p>It seems that creating a doom port, or hacking doom in general, is a common place for programmers. If you search for <a href="https://github.com/search?q=doom+port&amp;type=Repositories">“doom port” on github</a>, it’s inspiring how diverse projects you can find. The fact that the source code for the game is completely open and self-contained (meaning it doesn’t require dependencies) contributes a lot for this.</p>
<p>Back in 2020, I had an idea of a simple project to render doom using emojis because of some other doom renderer I saw on Twitter. I decided to take it as a weekend project, and although it took me around a week and a lot of bad code, it works and it’s actually pretty interesting. I don’t think anybody wants to play the game like that, but it certainly <em>looks cool</em>:</p>
<iframe width="770" height="433" src="https://www.youtube.com/embed/pkuXc9W0XkU" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>
<p>The project can be found in <a href="https://github.com/CrociDB/doomoji">GitHub</a>. The whole code for this rendering experiment is contained inside the files <a href="https://github.com/CrociDB/doomoji/blob/master/doomgeneric/doomgeneric_sdl.c"><code>doomgeneric_sdl.c</code></a> and <a href="https://github.com/CrociDB/doomoji/blob/master/doomgeneric/hashtable.h"><code>hashtable.h</code></a>.</p>

<p>I started using the <a href="https://github.com/ozkl/doomgeneric">doomgeneric</a> project, because they made the very-portable doom code even more portable by isolating the drawing and input functions in a single file, so you just need to implement some specific functions. I used SDL for this port because it’s simple enough to give me the results I wanted. So I imported the doomgeneric project and implemented the specified functions using SDL to have a proper doom being rendered.</p>
<p>I needed a set of emojis, and I found that Twitter has their emojis open source, so I downloaded the package with the emojis <a href="https://github.com/twitter/twemoji">here</a>. That’s really kind, but they offer them in separated files, and it would take ages for the game to load individually thousands of small images, so I combined them in a single image file:</p>
<p><a href="https://github.com/CrociDB/doomoji/blob/master/emoji_all.png?raw=true"><img src="https://github.com/CrociDB/doomoji/blob/master/emoji_all.png?raw=true" alt="emojis for rendering doom"/></a>
(click to enlarge)</p>
<p>Alright, that’s all I needed to start.</p>

<p>So, the idea all along was getting each pixel of the final framebuffer of the game and find an emoji that had a similar color. In order to categorize the emoji, I would save the average color in it, basically summing up all the colors together and dividing by the amount of pixels. That would mean that I would need one emoji per pixel, however, this brings me a problem.</p>
<p>The original doom resolutions is <code>320x200</code>. If I’m displaying a 10x10 emoji, that would already require a <code>3200x2000</code>. That’s massive, and 10x10 is still a very small size for you to recognize what the emojis are. So after some tests, I decided to go with a 18x18 emoji size and scale the framebuffer by one third, making the game resolution a bit too small, but the emojis big enough to be identified. Now I have resolution of <code>1920x1200</code>.</p>
<div><pre tabindex="0"><code data-lang="c"><span><span><span>#define ORIGINAL_SCALE                  0.33
</span></span></span><span><span><span>#define EMOJI_WIDTH                     18
</span></span></span><span><span><span>#define EMOJI_HEIGHT                    18
</span></span></span></code></pre></div>
<p>The main idea is that an emoji can represent one pixel of color of the original framebuffer. In face of the 3k+ emojis and the almost 21k+ pixels in screen, I tried to think a simpler categorization of color. So I came up with this where I have 7 lists of base colors: <code>[Red, Green, Blue, Cyan, Magenta, Yellow, Gray]</code> and the images would go in each of the list sorted by their <code>brightness</code>:</p>
<div><pre tabindex="0"><code data-lang="c"><span><span><span>typedef</span> <span>struct</span> _emoji_data
</span></span><span><span>{
</span></span><span><span>    SDL_Rect rect;
</span></span><span><span>    <span>uint8_t</span> brightness;
</span></span><span><span>} emoji_data;
</span></span><span><span>
</span></span><span><span><span>typedef</span> <span>struct</span> _emoji_table
</span></span><span><span>{
</span></span><span><span>    emoji_data red[EMOJI_TABLE_MAX_COL];
</span></span><span><span>    emoji_data green[EMOJI_TABLE_MAX_COL];
</span></span><span><span>    emoji_data blue[EMOJI_TABLE_MAX_COL];
</span></span><span><span>    emoji_data cyan[EMOJI_TABLE_MAX_COL];
</span></span><span><span>    emoji_data magenta[EMOJI_TABLE_MAX_COL];
</span></span><span><span>    emoji_data yellow[EMOJI_TABLE_MAX_COL];
</span></span><span><span>    emoji_data gray[EMOJI_TABLE_MAX_COL];
</span></span><span><span>
</span></span><span><span>    <span>uint8_t</span> r, nr, g, ng, b, nb, gr;
</span></span><span><span>} emoji_t;
</span></span></code></pre></div><p>Then I get the average color of the emoji and then I first check what’s the most saturated color out of the list, basically checking every component using a magic saturation color, which in my case is <code>EMOJI_COLOR_SATURATION = .79</code>.</p>
<div><pre tabindex="0"><code data-lang="c"><span><span>    <span>// This will check which color component is 21% more saturated than the other components
</span></span></span><span><span><span></span>    <span>float</span> xr <span>=</span> EMOJI_COLOR_SATURATION;
</span></span><span><span>    <span>float</span> ur <span>=</span> <span>1.0</span> <span>+</span> (<span>1.0</span> <span>-</span> EMOJI_COLOR_SATURATION);
</span></span><span><span>    
</span></span><span><span>    <span>if</span> (r <span>&gt;</span> g <span>*</span> ur <span>&amp;&amp;</span> r <span>&gt;</span>  b <span>*</span> ur)
</span></span><span><span>        <span>// Red value is 21% higher than blue and green
</span></span></span><span><span><span></span>    <span>else</span> <span>if</span> (g <span>&gt;</span> r <span>*</span> ur <span>&amp;&amp;</span> g <span>&gt;</span> b <span>*</span> ur)
</span></span><span><span>        <span>// Green
</span></span></span><span><span><span></span>    <span>else</span> <span>if</span> (b <span>&gt;</span> g <span>*</span> ur <span>&amp;&amp;</span> b <span>&gt;</span>  r <span>*</span> ur)
</span></span><span><span>        <span>// Blue
</span></span></span><span><span><span></span>    <span>else</span> <span>if</span> (r <span>&lt;</span> g <span>*</span> xr <span>&amp;&amp;</span> r <span>&lt;</span> b <span>*</span> xr)
</span></span><span><span>        <span>// Cyan, because red value is lower than 79% of blue and green
</span></span></span><span><span><span></span>    <span>else</span> <span>if</span> (g <span>&lt;</span> r <span>*</span> xr <span>&amp;&amp;</span> g <span>&lt;</span> b <span>*</span> xr)
</span></span><span><span>        <span>// Magenta
</span></span></span><span><span><span></span>    <span>else</span> <span>if</span> (b <span>&lt;</span> g <span>*</span> xr <span>&amp;&amp;</span> b <span>&lt;</span> r <span>*</span> xr)
</span></span><span><span>        <span>// Yellow
</span></span></span><span><span><span></span>    <span>else</span>
</span></span><span><span>        <span>// The remaining is treated as gray
</span></span></span></code></pre></div><p>And after sorting that by brightness, I get a table similar to this one:</p>
<p><img src="https://crocidb.com/post/rendering-doom-with-emojis/images/table.png" alt="doomoji emoji pallete"/></p>
<p>One thing to note is that not all colors have all the 60 entries, but that’s simply because there’s not enough emojis on the table that follows the strict color rule we are using.</p>
<p>That was giving me an okay result, as seen on this video:</p>
<iframe width="770" height="433" src="https://www.youtube.com/embed/QsQr-bZ_7qo" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>

<p>Another approach I thought initially was to treat colors as 3d points and check the distance between them. In this case I was going to get the most accurate color for every pixel in the framebuffer.</p>
<div><pre tabindex="0"><code data-lang="c"><span><span><span>typedef</span> <span>struct</span>
</span></span><span><span>{
</span></span><span><span>    <span>uint8_t</span> r, g, b;
</span></span><span><span>} color_t;
</span></span><span><span>
</span></span><span><span><span>inline</span> <span>float</span> <span>color_sqr_dist</span>(color_t a, color_t b)
</span></span><span><span>{
</span></span><span><span>    <span>return</span> (<span>float</span>)((a.r <span>-</span> b.r) <span>*</span> (a.r <span>-</span> b.r)) <span>+</span> ((a.g <span>-</span> b.g) <span>*</span> (a.g <span>-</span> b.g)) <span>+</span> ((a.b <span>-</span> b.b) <span>*</span> (a.b <span>-</span> b.b));
</span></span><span><span>}
</span></span></code></pre></div><p>The only data needed for the emoji is its base color and where its located in the original atlas:</p>
<div><pre tabindex="0"><code data-lang="c"><span><span><span>typedef</span> <span>struct</span> _emoji_data
</span></span><span><span>{
</span></span><span><span>    SDL_Rect rect;
</span></span><span><span>    color_t color;
</span></span><span><span>} emoji_data;
</span></span></code></pre></div><p>Then all the emojis will get evaluated and added to the <code>emoji_data</code> array on startup, and it will get the emoji with the closest color to that pixel color on every frame:</p>
<div><pre tabindex="0"><code data-lang="c"><span><span>emoji_data <span>get_emoji</span>(<span>uint8_t</span> r, <span>uint8_t</span> g, <span>uint8_t</span> b)
</span></span><span><span>{
</span></span><span><span>    color_t color;
</span></span><span><span>    color.r <span>=</span> r;
</span></span><span><span>    color.g <span>=</span> g;
</span></span><span><span>    color.b <span>=</span> b;
</span></span><span><span>
</span></span><span><span>    <span>int</span> index <span>=</span> <span>0</span>;
</span></span><span><span>    <span>float</span> distance <span>=</span> <span>99999.0</span>;
</span></span><span><span>
</span></span><span><span>    <span>for</span> (<span>int</span> i <span>=</span> <span>0</span>; i <span>&lt;</span> emoji_table_size; i<span>++</span>)
</span></span><span><span>    {
</span></span><span><span>        <span>float</span> d <span>=</span> color_sqr_dist(color, emoji_table[i].color);
</span></span><span><span>        <span>if</span> (d <span>&lt;</span> distance)
</span></span><span><span>        {
</span></span><span><span>            distance <span>=</span> d;
</span></span><span><span>            index <span>=</span> i;
</span></span><span><span>        }
</span></span><span><span>    }
</span></span><span><span>
</span></span><span><span>    <span>return</span> emoji_table[index];
</span></span><span><span>}
</span></span></code></pre></div><p>This approach is a lot more simple and produces a much better result. It looks incredible better already on the title screen. Here’s a comparison:</p>
<p><img src="https://crocidb.com/post/rendering-doom-with-emojis/images/comparison.jpg" alt="doomoji title with new approach"/></p>
<p>However, the framerate is extremely low due to the many computations every frame. There are over <em>65k color</em> searches happening every frame.</p>

<p>The most simple way of solving this is associating the pixel colors with their closest matched emoji, so that we wouldn’t need to do the search all over again every time that color is on screen. Considering that C doesn’t provide any sort of hashtable implementation, I wrote a simple one my own, losely following this post: <a href="https://benhoyt.com/writings/hash-table-in-c/">How to implement a hash table (in C)</a>, but simplifying a lot to something specific for this case. All the implementation is in the <a href="https://github.com/CrociDB/doomoji/blob/master/doomgeneric/hashtable.h">hashtable.h</a> file.</p>
<p><em>You can skip this part if you’re familiar with how hashtables work.</em></p>
<p>A good way to start is defining the interface to set and get matches to the table, the association is for a <code>color_t</code> to a <code>emoji_data*</code>:</p>
<div><pre tabindex="0"><code data-lang="c"><span><span><span>bool</span> <span>set_ht_emoji</span>(<span>/* table */</span>, color_t color, emoji_data<span>*</span> data);
</span></span><span><span>emoji_data<span>*</span> <span>get_ht_emoji</span>(<span>/* table */</span>, color_t color);
</span></span></code></pre></div><p><strong>The hashtable is nothing but a big array of entries and a hash function that transforms the <code>key</code> value into one unsigned integer which is a position in the array. In case of collisions, we keep increasing the position (in a cyclic way) until a free position is reached.</strong></p>
<p>So here’s the entry struct for the entry:</p>
<div><pre tabindex="0"><code data-lang="c"><span><span><span>typedef</span> <span>struct</span>
</span></span><span><span>{
</span></span><span><span>    <span>uint32_t</span> key;
</span></span><span><span>    <span>void</span><span>*</span> value;
</span></span><span><span>} ht_entry; 
</span></span></code></pre></div><p>I made the key <code>uint32_t</code> and not a <code>color_t</code>, so I could use a <code>uint32_t -&gt; uin32t_t</code> hash function. I’ll explain later how to pack the three color components into one single variable. The value is <code>void*</code> because it won’t manage that memory, only point to it, so the type is irrelevant. The hashtable structure goes like:</p>
<div><pre tabindex="0"><code data-lang="c"><span><span><span>typedef</span> <span>struct</span>
</span></span><span><span>{
</span></span><span><span>    ht_entry<span>*</span> entries;
</span></span><span><span>    size_t capacity;
</span></span><span><span>    size_t length;
</span></span><span><span>} ht;
</span></span></code></pre></div><p>The <code>capacity</code> is the total number of entries allocated, and the <code>length</code> is how many of those are being used.</p>
<div><pre tabindex="0"><code data-lang="c"><span><span><span>#define HT_MAX_CAPACITY		1024000
</span></span></span></code></pre></div><p>All <code>HT_MAX_CAPACITY</code> entries must be allocated upon creation and destroyed when requested:</p>
<div><pre tabindex="0"><code data-lang="c"><span><span>ht<span>*</span> <span>ht_create</span>()
</span></span><span><span>{
</span></span><span><span>    ht<span>*</span> table <span>=</span> (ht<span>*</span>)malloc(<span>sizeof</span>(ht));
</span></span><span><span>    <span>if</span> (<span>!</span>table) <span>return</span> NULL;
</span></span><span><span>
</span></span><span><span>    table<span>-&gt;</span>length <span>=</span> <span>0</span>;
</span></span><span><span>    table<span>-&gt;</span>capacity <span>=</span> HT_MAX_CAPACITY;
</span></span><span><span>
</span></span><span><span>    table<span>-&gt;</span>entries <span>=</span> (ht_entry<span>*</span>)calloc(table<span>-&gt;</span>capacity, <span>sizeof</span>(ht_entry));
</span></span><span><span>    <span>if</span> (<span>!</span>table<span>-&gt;</span>entries)
</span></span><span><span>    {
</span></span><span><span>        free(table);
</span></span><span><span>        <span>return</span> NULL;
</span></span><span><span>    }
</span></span><span><span>
</span></span><span><span>    <span>return</span> table;
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>void</span> <span>ht_destroy</span>(ht<span>*</span> table)
</span></span><span><span>{
</span></span><span><span>    free(table<span>-&gt;</span>entries);
</span></span><span><span>    free(table);
</span></span><span><span>}
</span></span></code></pre></div><h2 id="hashing">Hashing</h2>
<p>I used a simple <code>integer -&gt; integer</code> hash function I found <a href="https://stackoverflow.com/questions/664014/what-integer-hash-function-are-good-that-accepts-an-integer-hash-key">here</a>. Apparently even <a href="https://opensource.apple.com/source/Libc/Libc-1439.141.1/collections/Source/collections_map.c">Apple’s <strong>libc</strong> uses that function for maps</a>. It’s incredibly simple:</p>
<div><pre tabindex="0"><code data-lang="c"><span><span><span>uint32_t</span> <span>hash</span>(<span>uint32_t</span> x)
</span></span><span><span>{
</span></span><span><span>    x <span>=</span> ((x <span>&gt;&gt;</span> <span>16</span>) <span>^</span> x) <span>*</span> <span>0x45d9f3b</span>;
</span></span><span><span>    x <span>=</span> ((x <span>&gt;&gt;</span> <span>16</span>) <span>^</span> x) <span>*</span> <span>0x45d9f3b</span>;
</span></span><span><span>    x <span>=</span> (x <span>&gt;&gt;</span> <span>16</span>) <span>^</span> x;
</span></span><span><span>    <span>return</span> x;
</span></span><span><span>}
</span></span></code></pre></div><p>But in order to use a color as an integer, I packed all the 3 components of the color, all 8bit unsigned integers, into one 32bit unsigned integer:</p>
<div><pre tabindex="0"><code data-lang="c"><span><span><span>uint32_t</span> <span>get_key</span>(color_t color)
</span></span><span><span>{
</span></span><span><span>    <span>return</span> color.b <span>+</span> (color.g <span>&lt;&lt;</span> <span>8</span>) <span>+</span> (color.r <span>&lt;&lt;</span> <span>16</span>);
</span></span><span><span>}
</span></span></code></pre></div><h2 id="getting-and-setting-entries">Getting and Setting Entries</h2>
<p>All is ready to finally apply the hash function to find out the final position in the array:</p>
<div><pre tabindex="0"><code data-lang="c"><span><span><span>void</span><span>*</span> <span>ht_get</span>(ht<span>*</span> table, <span>uint32_t</span> key)
</span></span><span><span>{
</span></span><span><span>    <span>uint32_t</span> hash_key <span>=</span> hash(key);
</span></span><span><span>    size_t index <span>=</span> (size_t)(hash_key <span>&amp;</span> (<span>uint32_t</span>)table<span>-&gt;</span>capacity <span>-</span> <span>1</span>);
</span></span><span><span>
</span></span><span><span>    <span>uint8_t</span> collision <span>=</span> <span>0</span>;
</span></span><span><span>    <span>while</span> (table<span>-&gt;</span>entries[index].key <span>!=</span> NULL <span>&amp;&amp;</span> collision<span>++</span> <span>&lt;</span> HT_MAX_COLLISION)
</span></span><span><span>    {
</span></span><span><span>        <span>if</span> (table<span>-&gt;</span>entries[index].key <span>==</span> key)
</span></span><span><span>            <span>return</span> table<span>-&gt;</span>entries[index].value;
</span></span><span><span>
</span></span><span><span>        index <span>=</span> (index <span>+</span> <span>1</span>) <span>%</span> table<span>-&gt;</span>capacity;
</span></span><span><span>    }
</span></span><span><span>
</span></span><span><span>    <span>return</span> NULL;
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>bool</span> <span>ht_set</span>(ht<span>*</span> table, <span>uint32_t</span> key, <span>void</span><span>*</span> value)
</span></span><span><span>{
</span></span><span><span>    <span>if</span> (table<span>-&gt;</span>length <span>&gt;=</span> table<span>-&gt;</span>capacity) <span>return</span> false;
</span></span><span><span>
</span></span><span><span>    <span>uint32_t</span> hash_key <span>=</span> hash(key);
</span></span><span><span>    size_t index <span>=</span> (size_t)(hash_key <span>&amp;</span> (<span>uint32_t</span>)table<span>-&gt;</span>capacity <span>-</span> <span>1</span>);
</span></span><span><span>
</span></span><span><span>    <span>uint8_t</span> collision <span>=</span> <span>0</span>;
</span></span><span><span>    <span>while</span> (table<span>-&gt;</span>entries[index].key <span>!=</span> NULL <span>&amp;&amp;</span> collision<span>++</span> <span>&lt;</span> HT_MAX_COLLISION)
</span></span><span><span>    {
</span></span><span><span>        <span>if</span> (table<span>-&gt;</span>entries[index].key <span>==</span> key)
</span></span><span><span>        {
</span></span><span><span>            <span>// key already exists, updates
</span></span></span><span><span><span></span>            table<span>-&gt;</span>entries[index].value <span>=</span> value;
</span></span><span><span>            <span>return</span> true;
</span></span><span><span>        }
</span></span><span><span>
</span></span><span><span>        index <span>=</span> (index <span>+</span> <span>1</span>) <span>%</span> table<span>-&gt;</span>capacity;
</span></span><span><span>    }
</span></span><span><span>
</span></span><span><span>    table<span>-&gt;</span>entries[index].key <span>=</span> key;
</span></span><span><span>    table<span>-&gt;</span>entries[index].value <span>=</span> value;
</span></span><span><span>    table<span>-&gt;</span>length<span>++</span>;
</span></span><span><span>
</span></span><span><span>    <span>return</span> false;
</span></span><span><span>}
</span></span></code></pre></div>
<p>Now completing the interface functions to get and set data into the <a href="https://github.com/CrociDB/doomoji/blob/master/doomgeneric/doomgeneric_sdl.c"><code>doomgeneric_sdl.c</code></a> file, so we can automatically apply the color packing and do the emoji data casting:</p>
<div><pre tabindex="0"><code data-lang="c"><span><span>emoji_data<span>*</span> <span>get_ht_emoji</span>(ht<span>*</span> table, color_t color)
</span></span><span><span>{
</span></span><span><span>    <span>return</span> (emoji_data<span>*</span>)ht_get(table, get_key(color));
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>bool</span> <span>set_ht_emoji</span>(ht<span>*</span> table, color_t color, emoji_data<span>*</span> data)
</span></span><span><span>{
</span></span><span><span>    <span>return</span> ht_set(table, get_key(color), (<span>void</span><span>*</span>)data);
</span></span><span><span>}
</span></span></code></pre></div><p>Then just a slight change to the original <code>get_emoji</code> will do the trick:</p>
<div><pre tabindex="0"><code data-lang="c"><span><span>emoji_data <span>get_emoji</span>(<span>uint8_t</span> r, <span>uint8_t</span> g, <span>uint8_t</span> b)
</span></span><span><span>{
</span></span><span><span>    color_t color;
</span></span><span><span>    color.r <span>=</span> r;
</span></span><span><span>    color.g <span>=</span> g;
</span></span><span><span>    color.b <span>=</span> b;
</span></span><span><span>
</span></span><span><span>    <span>// check if the pixel color has an emoji already associated with it,
</span></span></span><span><span><span></span>    <span>// then return it
</span></span></span><span><span><span></span>    emoji_data<span>*</span> e <span>=</span> get_ht_emoji(emoji_ht, color);
</span></span><span><span>    <span>if</span> (e <span>!=</span> NULL)
</span></span><span><span>    {
</span></span><span><span>        <span>return</span> <span>*</span>e;
</span></span><span><span>    }
</span></span><span><span>
</span></span><span><span>    <span>// otherwise, search it in the emoji-table...
</span></span></span><span><span><span></span>
</span></span><span><span>    <span>int</span> index <span>=</span> <span>0</span>;
</span></span><span><span>    <span>float</span> distance <span>=</span> <span>99999.0</span>;
</span></span><span><span>
</span></span><span><span>    <span>for</span> (<span>int</span> i <span>=</span> <span>0</span>; i <span>&lt;</span> emoji_table_size; i<span>++</span>)
</span></span><span><span>    {
</span></span><span><span>        <span>float</span> d <span>=</span> color_sqr_dist(color, emoji_table[i].color);
</span></span><span><span>        <span>if</span> (d <span>&lt;</span> distance)
</span></span><span><span>        {
</span></span><span><span>            distance <span>=</span> d;
</span></span><span><span>            index <span>=</span> i;
</span></span><span><span>        }
</span></span><span><span>    }
</span></span><span><span>
</span></span><span><span>    <span>// .. and save it to the hashtable
</span></span></span><span><span><span></span>    <span>if</span> (ht_available(emoji_ht))
</span></span><span><span>    {
</span></span><span><span>        set_ht_emoji(emoji_ht, color, <span>&amp;</span>emoji_table[index]);
</span></span><span><span>    }
</span></span><span><span>
</span></span><span><span>    <span>return</span> emoji_table[index];
</span></span><span><span>}
</span></span></code></pre></div><p>Now the game runs at a reasonable speed. It’s important to note that everytime a new color is used, it will have to do the search on the emoji list all over again, that’s why the title screen and the beginning of gameplay still look a bit janky. But that’s something I’m okay with for this project.</p>

<p>It was a fun project. It’s clearly not meant for people to play it like that, as it would be pretty difficult, but more of cool challange for me. I know there are still stuff that could be made to improve it, and I leave that for anybody who wants to do it, but I had to call it done at some point.</p>
<p>Fork <a href="https://github.com/CrociDB/doomoji">the project</a> if you feel like and don’t hesitate to submit a PR if you manage to make something cool with it. :)</p>

      </article></div>
  </body>
</html>
