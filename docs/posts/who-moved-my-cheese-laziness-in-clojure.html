<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://otee.dev/2022/01/17/lazy-clojure.html">Original</a>
    <h1>Who Moved My Cheese: Laziness in Clojure</h1>
    
    <div id="readability-page-1" class="page"><article><a href="https://www.addictionjournal.org/cv.pdf">
            
<p><small>January 17, 2022</small></p>

<p>In this post, I try to understand what lazy sequences are and how to create our own lazy sequence in Clojure.</p>

<h2 id="lazy-sequences-in-clojure">Lazy Sequences in Clojure</h2>

</a><p><a href="https://www.addictionjournal.org/cv.pdf"></a><a href="https://clojure.org/reference/sequences">Clojure reference</a> explains laziness as:</p>

<blockquote>
  <p>Most of the sequence library functions are lazy, i.e. functions that return seqs do so incrementally, as they are consumed, and thus consume any seq arguments incrementally as well.</p>
</blockquote>

<p>The important parts of this is that many library functions that produce sequences (e.g. lists) do so incrementally, as they are consumed. This means that <strong>unless there is someone to consume the sequence, nothing really happens</strong>.</p>

<p>This was particularly perplexing to the eyes of a beginner learning Clojure, especially as to why the following the following does not print anything:</p>

<div><div><pre><code><span>(</span><span>defn</span><span> </span><span>print-numbers</span><span>
  </span><span>[</span><span>n</span><span>]</span><span>
  </span><span>(</span><span>map</span><span> </span><span>println</span><span> </span><span>(</span><span>range</span><span> </span><span>n</span><span>))</span><span> </span><span>;; .... (1)</span><span>
  </span><span>(</span><span>println</span><span> </span><span>&#34;Done printing: &#34;</span><span> </span><span>n</span><span>))</span><span>
</span></code></pre></div></div>

<p>When this function was called with proper arguments, the REPL produced the following output:</p>

<div><div><pre><code>butterfly.core<span>=&gt;</span> <span>(</span>print-numbers 9<span>)</span>
Done printing:  9
nil
</code></pre></div></div>

<p>It turns out that the function <code>print-numbers</code> produces a lazy sequence on line 1 (as indicated on the code-block above), i.e., the <code>map</code> produces a lazy sequence. As no one is consuming the sequence from <code>map</code>, it is never really realised. For this reason, the <code>println</code> inside the <code>map</code> is never executed. This is what lazy evaluation means.</p>

<p>This can be fixed in any of the following ways.</p>

<h3 id="using-mapv">Using mapv</h3>

<p>Use a non-lazy version of <code>map</code>, i.e., <code>mapv</code></p>

<div><div><pre><code><span>(</span><span>defn</span><span> </span><span>print-numbers</span><span>
  </span><span>[</span><span>n</span><span>]</span><span>
  </span><span>(</span><span>mapv</span><span> </span><span>println</span><span> </span><span>(</span><span>range</span><span> </span><span>n</span><span>))</span><span>
  </span><span>(</span><span>println</span><span> </span><span>&#34;Done printing: &#34;</span><span> </span><span>n</span><span>))</span><span>

</span></code></pre></div></div>

<h3 id="using-map--doall">Using map + doall</h3>

<p>Wrap <code>map</code> with <code>doall</code> which realises a lazy sequence</p>

<div><div><pre><code><span>(</span><span>defn</span><span> </span><span>print-numbers</span><span>
  </span><span>[</span><span>n</span><span>]</span><span>
  </span><span>(</span><span>doall</span><span> </span><span>(</span><span>map</span><span> </span><span>println</span><span> </span><span>(</span><span>range</span><span> </span><span>n</span><span>)))</span><span>
  </span><span>(</span><span>println</span><span> </span><span>&#34;Done printing: &#34;</span><span> </span><span>n</span><span>))</span><span>

</span></code></pre></div></div>

<h3 id="using-doseq">Using doseq</h3>

<p>Instead of generating a sequence, we can use <code>doseq</code> which acts on each element of a sequence</p>

<div><div><pre><code><span>(</span><span>defn</span><span> </span><span>print-numbers</span><span>
  </span><span>[</span><span>n</span><span>]</span><span>
  </span><span>(</span><span>doseq</span><span> </span><span>[</span><span>i</span><span> </span><span>(</span><span>range</span><span> </span><span>n</span><span>)]</span><span>
    </span><span>(</span><span>println</span><span> </span><span>i</span><span>))</span><span>
  </span><span>(</span><span>println</span><span> </span><span>&#34;Done printing: &#34;</span><span> </span><span>n</span><span>))</span><span>
</span></code></pre></div></div>

<h3 id="using-run">Using run!</h3>

<p>A better version (for the present example) than using <code>doseq</code> is to use <code>run!</code> which applies a given function on every element of a sequence, without generating another sequence (unlike <code>map</code>)</p>

<div><div><pre><code><span>(</span><span>defn</span><span> </span><span>print-numbers</span><span>
  </span><span>[</span><span>n</span><span>]</span><span>
  </span><span>(</span><span>run!</span><span> </span><span>println</span><span> </span><span>(</span><span>range</span><span> </span><span>n</span><span>))</span><span>
  </span><span>(</span><span>println</span><span> </span><span>&#34;Done printing: &#34;</span><span> </span><span>n</span><span>))</span><span>
</span></code></pre></div></div>

<h2 id="generating-a-lazy-sequence-">Generating a Lazy Sequence üí™üèº</h2>

<p>Let us now try to generate an infinite lazy sequence of prime numbers.</p>

<p>First,  we write a function which returns <code>true</code> if a number is prime</p>

<div><div><pre><code><span>(</span><span>defn</span><span> </span><span>is-prime?</span><span>
  </span><span>[</span><span>n</span><span>]</span><span>
  </span><span>(</span><span>not-any?</span><span> </span><span>(</span><span>fn</span><span> </span><span>[</span><span>factor</span><span>]</span><span>
              </span><span>(</span><span>zero?</span><span> </span><span>(</span><span>mod</span><span> </span><span>n</span><span> </span><span>factor</span><span>)))</span><span>
            </span><span>(</span><span>range</span><span> </span><span>2</span><span> </span><span>(</span><span>dec</span><span> </span><span>n</span><span>))))</span><span>

</span></code></pre></div></div>

<p>Let us now define an infinite sequence of prime numbers:</p>

<div><div><pre><code><span>(</span><span>def</span><span> </span><span>infinite-primes</span><span>
  </span><span>(</span><span>filter</span><span> </span><span>is-prime?</span><span> </span><span>(</span><span>drop</span><span> </span><span>2</span><span> </span><span>(</span><span>range</span><span>))))</span><span>
</span></code></pre></div></div>

<p>This <code>infinite-primes</code> var is doing a <code>filter</code> operation on an infinite sequence of numbers. Because <code>filter</code> and <code>range</code> both produce lazy sequences, this will not halt our program. In fact, this is the power of lazy sequences, that we can compute as many number of prime numbers, as we need <strong>when we need it</strong> without having to know apriori how many we may need.</p>

<p>Thus, all of the following generates prime number sequences of varying lengths:</p>

<div><div><pre><code><span>user</span><span>=&gt;</span> <span>(</span>take 5 infinite-primes<span>)</span>
<span>(</span>2 3 5 7 11<span>)</span>
<span>user</span><span>=&gt;</span> <span>(</span>take 10 infinite-primes<span>)</span>
<span>(</span>2 3 5 7 11 13 17 19 23 29<span>)</span>
<span>user</span><span>=&gt;</span> <span>(</span>take 100 infinite-primes<span>)</span>
<span>(</span>2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 101 103 107 109 113 127 131 137 139 149 151 157 163 167 173 179 181 191 193 197 199 211 223 227 229 233 239 241 251 257 263 269 271 277 281 283 293 307 311 313 317 331 337 347 349 353 359 367 373 379 383 389 397 401 409 419 421 431 433 439 443 449 457 461 463 467 479 487 491 499 503 509 521 523 541<span>)</span>

</code></pre></div></div>

<h2 id="constructing-a-lazy-sequence-from-scratch-">Constructing a Lazy Sequence from Scratch üßôüèº</h2>

<p>In the above part, we generated a lazy sequence by leveraging the library functions <code>filter</code> and <code>range</code> both of which are lazy.</p>

<p>In order to construct a lazy sequence from scratch, we can use <code>lazy-seq</code>. But before writing a <code>lazy-primes</code> function, let us write an <code>eager-primes</code> function that constructs a sequence of prime numbers from scratch:</p>

<div><div><pre><code><span>(</span><span>defn</span><span> </span><span>eager-primes</span><span>
  </span><span>([</span><span>n</span><span>]</span><span> </span><span>(</span><span>eager-primes</span><span> </span><span>n</span><span> </span><span>2</span><span> </span><span>[]))</span><span>
  </span><span>([</span><span>n</span><span> </span><span>curr</span><span> </span><span>xs</span><span>]</span><span>
   </span><span>(</span><span>if</span><span> </span><span>(</span><span>=</span><span> </span><span>(</span><span>count</span><span> </span><span>xs</span><span>)</span><span> </span><span>n</span><span>)</span><span>
     </span><span>xs</span><span>
     </span><span>(</span><span>if</span><span> </span><span>(</span><span>is-prime?</span><span> </span><span>curr</span><span>)</span><span>
       </span><span>(</span><span>recur</span><span> </span><span>n</span><span> </span><span>(</span><span>inc</span><span> </span><span>curr</span><span>)</span><span> </span><span>(</span><span>conj</span><span> </span><span>xs</span><span> </span><span>curr</span><span>))</span><span> 
       </span><span>(</span><span>recur</span><span> </span><span>n</span><span> </span><span>(</span><span>inc</span><span> </span><span>curr</span><span>)</span><span> </span><span>xs</span><span>)))))</span><span>
</span></code></pre></div></div>
<p>Here‚Äôs the how <code>eager-primes</code> can be used:</p>

<div><div><pre><code>butterfly.core<span>=&gt;</span> <span>(</span>eager-primes 8<span>)</span>
<span>[</span>2 3 5 7 11 13 17 19]

</code></pre></div></div>

<p>This is not a lazy sequence, because <strong>irrespective of how many primes are consumed, <code>eager-primes</code> will always generate <code>n</code> prime numbers, no more, no less</strong>.</p>

<p>So, in order to make it lazy, first we need to get rid of <code>n</code>, so that the production of primes depends on how many are consumed and not on a pre-defined number. For example, here we need only <code>10</code> primes, but <code>eager-primes</code> will still generate <code>100</code> primes</p>

<div><div><pre><code><span>(</span><span>take</span><span> </span><span>10</span><span> </span><span>(</span><span>eager-primes</span><span> </span><span>100</span><span>))</span><span>
</span></code></pre></div></div>
<p>In order to make it a lazy sequence, we need to stop the recursion. The way to do this is to wrap the recursive call around <code>lazy-seq</code>. What this will do is that it will tell Clojure that if any one is consuming from this sequence, this is the step to repeat. In other words, if we have a pause/resume functionality around <code>recur</code>, we have essentially generated a lazy sequence. But, in practice, we cannot actually use <code>recur</code> because when we use <code>lazy-seq</code> around the recursive call, the recursive call is no longer a tail call. So, we have to make the recursive call by using the function name.</p>

<div><div><pre><code><span>(</span><span>defn</span><span> </span><span>primes</span><span>
  </span><span>([]</span><span> </span><span>(</span><span>primes</span><span> </span><span>2</span><span>))</span><span>
  </span><span>([</span><span>curr</span><span>]</span><span>
   </span><span>(</span><span>if</span><span> </span><span>(</span><span>is-prime?</span><span> </span><span>curr</span><span>)</span><span>
     </span><span>(</span><span>cons</span><span> </span><span>curr</span><span> </span><span>(</span><span>lazy-seq</span><span> </span><span>(</span><span>primes</span><span> </span><span>(</span><span>inc</span><span> </span><span>curr</span><span>))))</span><span>
     </span><span>(</span><span>lazy-seq</span><span> </span><span>(</span><span>primes</span><span> </span><span>(</span><span>inc</span><span> </span><span>curr</span><span>))))))</span><span>
</span></code></pre></div></div>

<p>Output:</p>

<div><div><pre><code>butterfly.core<span>=&gt;</span> <span>(</span>def all-primes <span>(</span>primes<span>))</span>
<span>#&#39;butterfly.core/all-primes</span>

butterfly.core<span>=&gt;</span> <span>(</span>take 5 all-primes <span>)</span>
<span>(</span>2 3 5 7 11<span>)</span>

butterfly.core<span>=&gt;</span> <span>(</span>take 10 all-primes <span>)</span>
<span>(</span>2 3 5 7 11 13 17 19 23 29<span>)</span>

butterfly.core<span>=&gt;</span> <span>(</span>take 15 all-primes <span>)</span>
<span>(</span>2 3 5 7 11 13 17 19 23 29 31 37 41 43 47<span>)</span>
</code></pre></div></div>
<p>Important things to note:</p>

<ol>
  <li>
    <p><strong>Why we must use <code>cons</code></strong>: <code>cons</code> appends an element to a sequence at the beginning, <strong>without traversing the rest of the sequence</strong>. This is important because, if we are generating an infinite sequence, we cannot traverse the sequence fully because the sequence is infinite. In contrast, <code>conj</code> appends a new element at the end of the sequence, which, by definition, requires traversal of the whole sequence (to find the end). This is why we must use <code>cons</code> instead of <code>conj</code>.</p>
  </li>
  <li>
    <p><strong>Use of <code>lazy-seq</code></strong>: Whenever Clojure sees <code>lazy-seq</code> it stops evaluation until someone is realising it. This means that a <code>cons</code> on a lazy sequence is a sequence which has not really been computed. It will be computed when someone is traversing that list, i.e., realising it. The way this works is that <code>cons</code> points to an element and a lazy sequence which, again, includes a <code>cons</code> cell that points to an element and another lazy sequence. The Clojure environment evaluates these <code>lazy-seq</code>s as demanded as the traversal progresses. Therefore, it only evaluates that part of the sequence which has been traversed at least once.</p>
  </li>
</ol>

<p>To visualize the above, let us try to understand how a lazy sequence is traversed upon realization. For example, when four elements are taken out of the lazy sequence, the following happens:</p>

<p><img src="https://www.addictionjournal.org/assets/images/lazy-seq.png" width="100%"/></p>

<p>Every <code>cons</code> cell has a subsequent sequence, which is lazy. This means that it has not been computed. Therefore, only when we traverse that lazy sequence, do we find another <code>cons</code> cell with the next prime number, followed by another lazy sequence. <strong>This can be thought of as the proverbial <a href="https://en.wikipedia.org/wiki/Matryoshka_doll">Russian Dolls</a></strong>. Only by opening the first doll do you see the next doll (and not any more).</p>

<p>This traversal of lazy sequences and realisation (and caching of realised <code>cons</code> cells) is transparently done by Clojure, as they are consumed by some enclosing code. As a corollary, by virtue of the REPL having an eval step, lazy sequences are realised on the spot if directly written on the REPL (i.e., the REPL tries to consume the entire lazy sequence).</p>

<div><div><pre><code><span>user</span><span>=&gt;</span> <span>(</span>cons 1 <span>(</span>range<span>))</span>
<span>;;</span> this will never finish on the REPL
</code></pre></div></div>

<h2 id="who-moved-my-cheese-why-laziness-is-not-a-bad-thing">Who Moved My Cheese: Why laziness is not a bad thing</h2>

<p>In the book <a href="https://www.amazon.in/s?k=who+moved+my+cheese&amp;i=stripbooks&amp;ref=nb_sb_noss">‚ÄòWho Moved My Cheese‚Äô</a>, the author says that the lazy mouse ultimately loses out on life because when the going gets tough, the hard-working mouse (eager mouse) finds a solution and the lazy one, out of sheer laziness, perishes.</p>

<p>However, in a modern-day language like Clojure, a lazy sequence can prove to be very useful because some problems, like the prime numbers sequence, by definition, are infinite. If we built a web-page that displayed a   paginated result of prime numbers, any language that did not implement a lazy sequence of prime numbers, would have to re-evaluate all the prime numbers for every page. This means that to generate the 500th prime number, we would have to generate 499 prime numbers and then the 500th one. Consequently, to generate the 501st prime number, we would have to re-generate the first 500 prime numbers all over again (as seen in the <code>eager-primes</code> example above). This in Clojure would not be required because we maintain only one sequence of prime numbers that are realised as required and no recomputaton would be necessary.</p>

<p><strong>Edit:</strong> <em>In an earlier version, I had mentioned that a lazy sequence can provide efficiency. This is not accurate: a lazy sequence does not improve the inherent algorithmic efficiency of an expression. (However, caching of a lazy sequence does prevent recomputations).   Thanks to <a href="https://github.com/adityaathalye"><strong>Aditya Athalye</strong></a>, for pointing this out!</em></p>



        </article></div>
  </body>
</html>
