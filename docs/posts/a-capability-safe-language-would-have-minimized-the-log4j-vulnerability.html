<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://justinpombrio.net/2021/12/26/preventing-log4j-with-capabilities.html">Original</a>
    <h1>A capability-safe language would have minimized the Log4j vulnerability</h1>
    
    <div id="readability-page-1" class="page"><div>

<p>A capability-safe language would have minimized the impact of, or even
prevented, the <a href="https://www.lunasec.io/docs/blog/log4j-zero-day/">log4j
vulnerability</a>.</p>

<p>If this is the first time you’re hearing about that vulnerability, you should go
read about it instead of this post! And also go patch it, if you have Java
software that uses or might transitively use <code>log4j</code> to log.  It’s a doozy.</p>

<p>There are multiple issues surrouding this vulnerability that I’ll talk about in
this post:</p>

<ol>
  <li>It’s doing string interpolation on user supplied strings.</li>
  <li>It’s accessing the network, without anyone realizing it might do that.
(This is the part that capabilities would help with.)</li>
</ol>

<h2 id="the-surface-issue-string-interpolation-on-user-supplied-strings">The surface issue: String interpolation on user supplied strings</h2>

<p>The first issue is that <code>log4j</code> was performing string replacement on user
supplied strings, not just on the template strings written by the developer.
For example, if the developer using <code>log4j</code> writes this:</p>

<div><pre><code><span>logger</span><span>.</span><span>debug</span><span>(</span><span>&#34;user-name={}&#34;</span><span>,</span> <span>userName</span><span>);</span>
</code></pre>
</div>

<p>Then <code>log4j</code> will substitute <code>userName</code> into <code>{}</code> as it should, but it will
<em>also</em> perform string replacements inside <code>userName</code>. So if someone picks the
user name <code>{o}${o}</code> because they think it looks like a pair of glasses, then
this line of code will attempt to expand <code>${o}</code> by looking up what <code>o</code> expands
to in a developer provided configuration file.</p>

<p>But that’s non-sensical: a user name is a <em>string</em>, not a <em>logging template</em>.
The user that picked <code>{o}${o}</code> probably doesn’t even know how to program and
they were not attempting to write a <code>log4j</code> string template, they were drawing a
pair of glasses!</p>

<p>Contrast that to this code:</p>

<div><pre><code><span>logger</span><span>.</span><span>debug</span><span>(</span><span>&#34;user-name=&#34;</span> <span>+</span> <span>userName</span><span>);</span>
</code></pre>
</div>

<p>In this case, <code>logger.debug()</code> has no way of knowing that <code>userName</code> might
contain user data: it was simply just handed a single argument, and its first
argument is meant to be a template. Thus it is appropriate for it to try to
expand <code>${o}</code> in the log message. Writing this code is a mistake by the
<em>developer</em> using <code>log4j</code>, whereas the behavior of the <code>&#34;user-name={}&#34;</code> code is
a bug in <code>log4j</code>.</p>

<p>If this bug wasn’t present then there would probably be a lot fewer vulnerable
applications in the wild, because many developers using <code>log4j</code> probably did use
the form <code>&#34;user-name={}&#34;</code> instead of the form <code>&#34;user-name=&#34; + userName</code>.</p>

<h2 id="the-deeper-issue-why-is-my-logger-using-the-network">The deeper issue: Why is my logger using the network?</h2>

<p>That was one issue. Another, deeper, issue is that <code>log4j</code> was fetching
arbitrary Java code off the network and executing it, <em>when no one expected it
to</em>.</p>

<p>I have, in my head, a little person who was born and raised in a world where
capability-safe software is the default. And this person is yelling. He is
yelling:</p>

<blockquote>
  <p>I hear this vulnerability affected pretty much everyone using <code>log4j</code>.  But
why did everyone pass the network to the logger? Sure, maybe some people
wanted to use JNDI and LDAP or something, but most people didn’t, so why would
those people <em>give the logger the network</em>?</p>
</blockquote>

<p>The answer, of course, is that no one “gave” the logger access to the network.
It just <em>had</em> access, because <em>all code</em> in Java has access to the network.
You can tell by these type signatures in the Java <code>net</code> library:</p>

<div><pre><code><span>public</span> <span>class</span> <span>URL</span> <span>{</span>
    <span>// Make a new URL. Anyone can do it.</span>
    <span>public</span> <span>URL</span><span>(</span><span>String</span><span>)</span> <span>;</span>

    <span>// Turn a URL into a URLConnection. Anyone can do it.</span>
    <span>// (Despite the name, this doesn&#39;t actually open the connection,</span>
    <span>//  it just makes a URLConnection object.)</span>
    <span>public</span> <span>URLConnection</span> <span>openConnection</span><span>();</span>
<span>}</span>

<span>public</span> <span>class</span> <span>URLConnection</span> <span>{</span>
    <span>// Actually open the connection. Anyone can do it.</span>
    <span>public</span> <span>abstract</span> <span>void</span> <span>connect</span><span>();</span>
<span>}</span>
</code></pre>
</div>

<p>(Links: <a href="https://docs.oracle.com/javase/7/docs/api/java/net/URL.html#URL(java.lang.String)">new URL</a>, <a href="https://docs.oracle.com/javase/7/docs/api/java/net/URL.html#openConnection()">openConnection</a>, <a href="https://docs.oracle.com/javase/7/docs/api/java/net/URLConnection.html#connect()">connect</a>.)</p>

<p>By chaining these three methods together, arbitrary Java code can open a
connection to any URL it wants to. This may not look strange to you or me, but
it looks <em>very</em> problematic to the little capability-person in my head. He is
saying:</p>

<blockquote>
  <p>Wait, these three methods together let you create a network connection <em>from
nothing</em>? That’s a violation of the integrity of your type system!</p>
</blockquote>

<blockquote>
  <p>It’s like… say there is an authentication package, that <em>all</em> authentication
goes through, and you can try to authenticate a user, and if it passes you’ll
get an <code>AuthenticatedUser</code>, and then you can use the <code>AuthenticatedUser</code> to
perform more privileged actions.</p>

  <p>For this to work well, it’s important that <em>all</em> authentication happens in the
authentication package, and that <em>only it</em> can create an <code>AuthenticatedUser</code>.
You can do this in Java, by making the constructors for <code>AuthenticatedUser</code>
non-public and ensuring that they are only called in the authentication
package, and only if the authentication succeeds. This can be a very useful
abstraction in a large codebase: it tells you that (certain kinds of)
authentication bugs can <em>only</em> happen inside the authentication package.</p>

  <p>And this abstraction <em>breaks</em> if random code can conjure up an
<code>AuthenticatedUser</code> <em>from nothing</em>, and use it to perform privileged actions.</p>

  <p>Likewise, you shouldn’t be able to conjure up a network connection <em>from
nothing</em>. Any network connection must ultimately originate from the <code>Network</code>
object.</p>

  <p>[…listening…]</p>

  <p>Oh, you don’t <em>have</em> a <code>Network</code> object? So any random library code can just
access the network, on its own. And this is true not only of your
dependencies, but the dependencies of your dependencies. So the only way to
check if your application might transitively access the network would be to like…
search through the source code of all of your transitive dependencies? <em>Wow.</em>
Just wow. And you’re wondering why you have so many vulner—</p>
</blockquote>

<p>Let’s cut off my imaginary capabilities-person there, he’s getting a little
snarky.</p>

<p>What he’s making fun of us for not having is a different API that looks
like this (or something like it; there are a lot of ways to organize it):</p>

<div><pre><code><span>public</span> <span>class</span> <span>URL</span> <span>{</span>
    <span>// Make a new URL. Anyone can do it.</span>
    <span>new</span> <span>URL</span><span>(</span><span>String</span><span>);</span>
<span>}</span>

<span>// The ultimate source of all network access.</span>
<span>// This class is a capability. It grants access to all URLs.</span>
<span>class</span> <span>Network</span> <span>{</span>
    <span>// Turn a URL into a URLConnection.</span>
    <span>// You can only do this if you have a Network object.</span>
    <span>// Once it&#39;s done, the URLConnection grants the capability to open the</span>
    <span>// connection to that url.</span>
    <span>public</span> <span>URLConnection</span> <span>openConnection</span><span>(</span><span>URL</span><span>);</span>
<span>}</span>

<span>// This class is a capability. It grants access to one particular URL.</span>
<span>class</span> <span>URLConnection</span> <span>{</span>
    <span>// Actually open the connection.</span>
    <span>public</span> <span>abstract</span> <span>void</span> <span>connect</span><span>();</span>
<span>}</span>
</code></pre>
</div>

<p>This begs the question: who can construct a <code>Network</code> object? If anyone can just
make one, then nothing substantial has changed. The <code>log4j</code> package (or really,
its JNDI dependency) would privately construct a <code>Network</code> and otherwise do the
same thing.</p>

<p>The trick is, <em>there are no constructors for <code>Network</code></em>. Instead, there is
exactly one <code>Network</code> object ever in existence, and it is passed in to the
program at one location, perhaps as an argument to <code>main</code>. (Actually, if the
operating system was capability-safe and Java was cooperating with it, then
<code>main</code> would be given a <code>Network</code> if and only if the executable was given
network access.) And likewise for similar capabilities like a <code>FileSystem</code>
object:</p>

<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span>
    <span>String</span> <span>args</span><span>[],</span>
    <span>Network</span> <span>network</span><span>,</span>
    <span>Filesystem</span> <span>filesystem</span><span>)</span> <span>{</span>
      <span>...</span>
<span>}</span>
</code></pre>
</div>

<p>The point is to use unforgeable Java objects to grant capabilities. Unforgable
means that arbitrary code can’t create one from nothing; this can be
accomplished in Java simply by it not having constructors. If you pass some code
a reference to one of these capability objects, directly or indirectly, you are
granting it access to the resource it represents. This is the essense of
capabilities: <strong>unforgeable objects that grant access to the resource they
represent</strong>. It’s very simple.</p>

<p>Let’s see how capability safety would influence <code>log4j</code>. First off, here’s what
<code>log4j</code>’s interface looks like currently:</p>

<div><pre><code><span>import</span> <span>org.apache.log4j.Logger</span><span>;</span>

<span>public</span> <span>class</span> <span>Incrementer</span> <span>{</span>
    <span>private</span> <span>static</span> <span>final</span> <span>Logger</span> <span>LOGGER</span>
      <span>=</span> <span>Logger</span><span>.</span><span>getLogger</span><span>(</span><span>Incrementer</span><span>.</span><span>class</span><span>);</span>

    <span>public</span> <span>int</span> <span>increment</span><span>(</span><span>int</span> <span>number</span><span>)</span> <span>{</span>
        <span>LOGGER</span><span>.</span><span>info</span><span>(</span><span>&#34;Adding one&#34;</span><span>);</span>
        <span>return</span> <span>number</span> <span>+</span> <span>1</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
</div>

<p>Notice that <code>Network</code> isn’t passed to <code>LOGGER</code>. Thus <code>log4j</code> <em>can’t</em> access
the network! So when the <code>log4j</code> maintainers considered implementing the JNDI
feature that introduced the vulnerability, a few things could have happened
next:</p>

<ol>
  <li>They decide that it’s totally reasonable for a logging
library to access the network all the time by default, and add a <code>Network</code>
argument to the <code>Logger.getLogger()</code> method. Some users accept this and fall
prey to the vulnerability, but more discerning users are concerned by this
request for network access and switch to a simpler logging library that
doesn’t require it, thus avoiding the vulnerability.</li>
  <li>They don’t think a logging library should be accessing the
network at all, or feel that requiring a <code>Network</code> parameter would be
frightening or inconvenient to users, and reject the feature.</li>
  <li>They think that the feature is worthwhile, but don’t want
the breaking API change of modifying <code>getLogger</code> to require a <code>Network</code>. So
instead they introduce a new method, perhaps called
<code>Logger.getLoggerWithNetwork(MyClass.class, network)</code>. Since most users don’t
use this method and <code>log4j</code> can’t access the network without it, this
prevents the great majority of vulnerabilities.</li>
</ol>

<p>All three possibilities are better than what actually happened, which was that
<code>log4j</code> suddenly gained the ability to access the network, but its API did
not change to reflect this so users did not notice. Thus, a capability-safe
language would have saved, or at least mitigated, the day.</p>

<p>So future language designers, please consider making your language capability
safe.</p>

<p>I’m not actually sure what’s a good reference for more reading, besides Mark
Miller’s thesis if you really want to get into it. But here are some
possibilities:</p>

<ul>
  <li><a href="http://www.erights.org/talks/thesis/markm-thesis.pdf">Mark Miller’s thesis</a></li>
  <li><a href="https://fuchsia.dev/fuchsia-src/concepts/components/v2/capabilities?hl=en">Capabilities in
Fuschia</a></li>
  <li><a href="https://github.com/bytecodealliance/cap-std">Capabilities in Rust</a></li>
</ul>


<p>
December 26, 2021
<a href="https://justinpombrio.net/feed.xml"><img width="16rem" src="https://justinpombrio.net/src/img/rss.png"/></a>
</p>
</div></div>
  </body>
</html>
