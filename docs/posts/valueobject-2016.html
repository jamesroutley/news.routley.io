<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://martinfowler.com/bliki/ValueObject.html">Original</a>
    <h1>ValueObject (2016)</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>When programming, I often find it&#39;s useful to represent things as a compound. A
  2D coordinate consists of an x value and y value. An amount of money
  consists of a number and a currency. A date range consists of start and end dates, which
  themselves can be compounds of year, month, and day.</p>

<p>As I do this, I run into the question of whether two compound objects are the same.
  If I have two point objects that both represent the Cartesian coordinates
  of (2,3), it makes sense to treat them as equal. Objects that are equal due to the value
  of their properties, in this case their x and y coordinates, are called value
  objects.</p>

<p>But unless I&#39;m careful when programming, I may not get that
  behavior in my programs</p>

<p>Say I want to represent a point in JavaScript.</p>

<pre>const p1 = {x: 2, y: 3};
const p2 = {x: 2, y: 3};
assert(p1 !== p2);  // NOT what I want</pre>

<p>Sadly that test passes. It does so because JavaScript tests equality for js objects
  by looking at their references, ignoring the values they contain. </p>

<p>In many situations using references rather than values makes sense. If I&#39;m loading
  and manipulating a bunch of sales orders, it makes sense to load each order into a
  single place. If I then need to see if the Alice&#39;s latest order is in the next delivery,
  I can take the memory reference, or identity, of Alice&#39;s order and see if that reference
  is in the list of orders in the delivery. For this test, I don&#39;t have to worry about
  what&#39;s in the order. Similarly I might rely on a unique order number, testing to see if
  Alice&#39;s order number is on the delivery list.</p>

<p>Therefore I find it useful to think of two classes of object: value objects and reference
  objects, depending on how I tell them apart . I need to ensure that I know how I expect each
  object to handle equality and to program them so they behave according to my
  expectations. How I do that depends on the programming language I&#39;m working in.</p>

<p>Some languages treat all compound data as values. If I make a simple compound in Clojure, it
  looks like this.</p>

<pre>&gt; (= {:x 2, :y 3} {:x 2, :y 3})
true
</pre>

<p>That&#39;s the functional style - treating everything as immutable values.</p>

<p>But if I&#39;m not in a functional language, I can still often create value objects. In
  Java for example, the default point class behaves how I&#39;d like. </p>

<pre>assertEquals(new Point(2, 3), new Point(2, 3)); // Java</pre>

<p>The way this works is that the point class overrides the default <code>equals</code>
  method with the tests for the values. Â </p>

<p>I can do something similar in JavaScript.</p>

<pre>class Point {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
  equals (other) {
    return this.x === other.x &amp;&amp; this.y === other.y;
  }
}
</pre>

<pre>const p1 = new Point(2,3);
const p2 = new Point(2,3);
assert(p1.equals(p2));</pre>

<p>The problem with JavaScript here is that this equals method I defined is a mystery to
  any other JavaScript library. </p>

<pre>const somePoints = [new Point(2,3)];
const p = new Point(2,3);
assert.isFalse(somePoints.includes(p)); // not what I want

//so I have to do this
assert(somePoints.some(i =&gt; i.equals(p)));</pre>

<p>This isn&#39;t an issue in Java because
  <code>Object.equals</code> is defined in the core library and all other libraries use it
  for comparisons (<code>==</code> is usually used only for primitives). </p>

<p>One of the nice consequences of value objects is that I don&#39;t need to care about
  whether I have a reference to the same object in memory or a different reference with an
  equal value. However if I&#39;m not careful that happy ignorance can lead to a problem,
  which I&#39;ll illustrate with a bit of Java.</p>

<pre>Date retirementDate = new Date(Date.parse(&#34;Tue 1 Nov 2016&#34;));

// this means we need a retirement party
Date partyDate = retirementDate;

// but that date is a Tuesday, let&#39;s party on the weekend
partyDate.setDate(5);

assertEquals(new Date(Date.parse(&#34;Sat 5 Nov 2016&#34;)), retirementDate);
// oops, now I have to work three more days :-(</pre>

<p>This is an example of an <a href="https://martinfowler.com/bliki/AliasingBug.html">Aliasing Bug</a>, I change a date in one place
  and it has consequences beyond what I expected . To avoid
  aliasing bugs I follow a simple but important rule: <b>value objects should be
  immutable</b>. If I want to change my party date, I create a new
  object instead.</p>

<pre>Date retirementDate = new Date(Date.parse(&#34;Tue 1 Nov 2016&#34;));
Date partyDate = retirementDate;

// treat date as immutable
partyDate = new Date(Date.parse(&#34;Sat 5 Nov 2016&#34;));

// and I still retire on Tuesday
assertEquals(new Date(Date.parse(&#34;Tue 1 Nov 2016&#34;)), retirementDate);</pre>

<p>Of course, it makes it much easier to treat value objects as immutable if they really
  are immutable. With objects I can usually do this by simply not providing any setting
  methods. So my earlier JavaScript class would look like this: </p>

<pre>class Point {
  constructor(x, y) {
    this._data = {x: x, y: y};
  }
  get x() {return this._data.x;}
  get y() {return this._data.y;}
  equals (other) {
    return this.x === other.x &amp;&amp; this.y === other.y;
  }
}
</pre>

<p>While immutability is my favorite technique to avoid aliasing bugs, it&#39;s also
  possible to avoid them by ensuring assignments always make a copy. Some languages
  provide this ability, such as structs in C#.</p>

<p>Whether to treat a concept as a reference object or value object depends on your
  context. In many situations it&#39;s worth treating a postal address as a simple structure
  of text with value equality. But a more sophisticated mapping system might link postal
  addresses into a sophisticated hierarchic model where references make more sense. As
  with most modeling problems, different contexts lead to different solutions. </p>

<p>It&#39;s often a good idea to replace common primitives, such as strings, with appropriate
  value objects. While I can represent a telephone number as a string, turning into a
  telephone number object makes variables and parameters more explicit (with type checking
  when the language supports it), a natural focus for validation, and avoiding
  inapplicable behaviors (such as doing arithmetic on integer id numbers).</p>

<p>Small objects, such as points, monies, or ranges, are good examples of value objects.
  But larger structures can often be programmed as value objects if they don&#39;t have any
  conceptual identity or don&#39;t need share references around a program. This is a more
  natural fit with functional languages that default to immutability. </p>

<p>I find that value objects, particularly small ones, are often overlooked - seen as
  too trivial to be worth thinking about. But once I&#39;ve spotted a good set of value
  objects, I find I can create a rich behavior over them. For taste of this try using a
  <a href="https://martinfowler.com/eaaDev/Range.html">Range class</a> and see how it prevents all sorts of duplicate
  fiddling with start and end attributes by using richer behaviors. I often run into code
  bases where domain-specific value objects like this can act as a focus for refactoring,
  leading to a drastic simplification of a system. Such a simplification often surprises
  people, until they&#39;ve seen it a few times - by then it is a good friend.</p>

<div>
<h2>Acknowledgements</h2>

<p>James Shore, Beth Andres-Beck, and Pete Hodgson shared their experiences of using
    value objects in JavaScript.</p>

<p>

      Graham Brooks, James Birnie, Jeroen Soeters, Mariano Giuffrida, Matteo Vaccari, Ricardo
    Cavalcanti, and Steven Lowe


    provided valuable comments on our internal mailing lists.</p>
</div>

<div>
<h2>Further Reading</h2>

<p>Vaughn Vernon&#39;s description is probably the <a href="https://www.amazon.com/gp/product/0321834577/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0321834577&amp;linkCode=as2&amp;tag=martinfowlerc-20">best in-depth
    discussion of value objects</a> from a DDD perspective. He covers how to decide
    between values and entities, implementation tips, and the techniques for persisting
    value objects.</p>

<p>The term started gaining traction in the early noughties. Two books that talk about
    them from that time are <a href="https://martinfowler.com/books/eaa.html">PoEAA</a> and <a href="https://www.amazon.com/gp/product/0321125215/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0321125215&amp;linkCode=as2&amp;tag=martinfowlerc-20">DDD</a>. There was also some interesting discussion on <a href="http://c2.com/cgi/wiki?ValueObject">Ward&#39;s Wiki</a>.</p>

<p>One source of terminological confusion is that around the turn of the century some
    J2EE literature used &#34;value object&#34; for <a href="https://martinfowler.com/eaaCatalog/dataTransferObject.html">Data Transfer Object</a>. That usage has
    mostly disappeared by now, but you might run into it.</p>
</div>


</div></div>
  </body>
</html>
