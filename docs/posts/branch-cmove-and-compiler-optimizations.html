<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://kristerw.github.io/2022/05/24/branchless/">Original</a>
    <h1>Branch/Cmove and Compiler Optimizations</h1>
    
    <div id="readability-page-1" class="page"><div>
    <p>I have recently seen several discussions on Twitter where people have been
surprised/annoyed by what the compilers do to their branchless code. Here
are some random comments on what the compilers do (and why).</p>


<p>Branch misprediction is very expensive. But conditional moves are also costly (as they increase the length of dependency chains), so it is not obvious that a branch that sometimes mispredicts is slower than a conditional move. <a href="https://www.agner.org/optimize/optimizing_assembly.pdf">Agner Fog’s optimization manual</a> says (for “<code>a = b &gt; c ? d : e;</code>”):</p>

<blockquote>
  <p>As a rule of thumb, we can say that a conditional jump is faster than a conditional move if the code is part of a dependency chain and the prediction rate is better than 75%.
A conditional jump is also preferred if we can avoid a lengthy calculation of <code>d</code> or <code>e</code> when the other operand is chosen.</p>
</blockquote>

<p>Most I see written about branches and conditional moves focus on writing branchless code. But branch predictors are amazing<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" rel="footnote">1</a></sup> – they can easily find a pattern in
how a branch is taken, and use correlated branches to improve the prediction rate.
So it is often the case that branches that seem unpredictable predict
better than 75% in reality, and doing it branchless makes the program slower.</p>


<p>One way that seems natural to get the compiler to generate branchless code
is to use the ternary operator, but that does not work. The reason is that</p>

<p>does evaluate <code>a</code> only when the condition <code>c</code> is true and <code>b</code> only when
<code>c</code> is false, so the compiler front end must generate the same IR for this as for</p>
<div><div><pre><code><span>if</span> <span>(</span><span>c</span><span>)</span>
  <span>r</span> <span>=</span> <span>a</span><span>;</span>
<span>else</span>
  <span>r</span> <span>=</span> <span>b</span><span>;</span>
</code></pre></div></div>
<p>At least when <code>a</code> and <code>b</code> may have side effects.</p>

<p>Both GCC and Clang generate IR with branches for ternary operators (even with
no side effects), so later optimization passes do not see any difference
between source code using the ternary operator or branches.</p>


<h3 id="branches">Branches</h3>
<p>GCC is rather aggressive in using conditional moves for x86_64, and it is
common to find cases where using a branch instead would improve
performance.
It is often possible to make GCC emit a branch instruction by using
<code>__builtin_expect_with_probability</code> to tell it that the
branch is very likely.<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" rel="footnote">2</a></sup> For example, the function</p>
<div><div><pre><code><span>int</span> <span>foo</span><span>(</span><span>int</span> <span>a</span><span>,</span> <span>int</span> <span>b</span><span>,</span> <span>int</span> <span>c</span><span>)</span>
<span>{</span>
  <span>if</span> <span>(</span><span>a</span> <span>==</span> <span>b</span><span>)</span>
    <span>a</span> <span>&amp;=</span> <span>c</span><span>;</span>
  <span>return</span> <span>a</span><span>;</span>
<span>}</span>
</code></pre></div></div>
<p>is compiled to code using <code>cmove</code> while</p>
<div><div><pre><code><span>#define VERY_LIKELY(x) __builtin_expect_with_probability(!!(x), 1, 0.999)
</span>
<span>int</span> <span>foo</span><span>(</span><span>int</span> <span>a</span><span>,</span> <span>int</span> <span>b</span><span>,</span> <span>int</span> <span>c</span><span>)</span>
<span>{</span>
  <span>if</span> <span>(</span><span>VERY_LIKELY</span><span>(</span><span>a</span> <span>==</span> <span>b</span><span>))</span>
    <span>a</span> <span>&amp;=</span> <span>c</span><span>;</span>
  <span>return</span> <span>a</span><span>;</span>
<span>}</span>
</code></pre></div></div>
<p>is compiled to code with branches. (<a href="https://godbolt.org/z/Gzr7bEaef">godbolt</a>)</p>

<h3 id="branchless">Branchless</h3>
<p>Many (most?) cases where GCC incorrectly decides to use a branch instead of
emitting branchless code comes from optimization passes transforming the
code to a form where the backend cannot change it to use conditional
moves.</p>

<p>For example, the program in <a href="https://lemire.me/blog/2021/07/14/faster-sorted-array-unions-by-reducing-branches/">this blog post</a> has a loop (<a href="https://godbolt.org/z/ehhfzYqed">godbolt</a>)</p>
<div><div><pre><code><span>while</span> <span>((</span><span>pos1</span> <span>&lt;</span> <span>size1</span><span>)</span> <span>&amp;</span> <span>(</span><span>pos2</span> <span>&lt;</span> <span>size2</span><span>))</span> <span>{</span>
  <span>v1</span> <span>=</span> <span>input1</span><span>[</span><span>pos1</span><span>];</span>
  <span>v2</span> <span>=</span> <span>input2</span><span>[</span><span>pos2</span><span>];</span>
  <span>output_buffer</span><span>[</span><span>pos</span><span>++</span><span>]</span> <span>=</span> <span>(</span><span>v1</span> <span>&lt;=</span> <span>v2</span><span>)</span> <span>?</span> <span>v1</span> <span>:</span> <span>v2</span><span>;</span>
  <span>pos1</span> <span>=</span> <span>(</span><span>v1</span> <span>&lt;=</span> <span>v2</span><span>)</span> <span>?</span> <span>pos1</span> <span>+</span> <span>1</span> <span>:</span> <span>pos1</span><span>;</span>
  <span>pos2</span> <span>=</span> <span>(</span><span>v1</span> <span>&gt;=</span> <span>v2</span><span>)</span> <span>?</span> <span>pos2</span> <span>+</span> <span>1</span> <span>:</span> <span>pos2</span><span>;</span>
<span>}</span>
</code></pre></div></div>
<p>The comparisons are unpredictable, so the program runs faster if the loop
body is generated as branchless code, but GCC emits branches for updating <code>pos1</code> and <code>pos2</code>. The reason is that the sequence</p>
<div><div><pre><code>  <span>pos1</span> <span>=</span> <span>(</span><span>v1</span> <span>&lt;=</span> <span>v2</span><span>)</span> <span>?</span> <span>pos1</span> <span>+</span> <span>1</span> <span>:</span> <span>pos1</span><span>;</span>
  <span>pos2</span> <span>=</span> <span>(</span><span>v1</span> <span>&gt;=</span> <span>v2</span><span>)</span> <span>?</span> <span>pos2</span> <span>+</span> <span>1</span> <span>:</span> <span>pos2</span><span>;</span>
</code></pre></div></div>
<p>has been optimized by <a href="https://developers.redhat.com/blog/2019/03/13/intro-jump-threading-optimizations#">jump threading</a> to</p>
<div><div><pre><code>  <span>if</span> <span>(</span><span>v1</span> <span>&lt;=</span> <span>v2</span><span>)</span> <span>{</span>
    <span>pos1</span> <span>=</span> <span>pos1</span> <span>+</span> <span>1</span><span>;</span>
    <span>if</span> <span>(</span><span>v2</span> <span>==</span> <span>v1</span><span>)</span>
      <span>goto</span> <span>skip</span><span>;</span>
  <span>}</span> <span>else</span> <span>{</span>
<span>skip:</span>
    <span>pos2</span> <span>=</span> <span>pos2</span> <span>+</span> <span>1</span><span>;</span>
  <span>}</span>
</code></pre></div></div>
<p>which is too complex for the backend to emit as branchless code.</p>

<p>We can get rid of the branches in this case by rewriting the loop to prevent
jump threading from optimizing it:</p>
<div><div><pre><code><span>while</span> <span>((</span><span>pos1</span> <span>&lt;</span> <span>size1</span><span>)</span> <span>&amp;</span> <span>(</span><span>pos2</span> <span>&lt;</span> <span>size2</span><span>))</span> <span>{</span>
  <span>v1</span> <span>=</span> <span>input1</span><span>[</span><span>pos1</span><span>];</span>
  <span>v2</span> <span>=</span> <span>input2</span><span>[</span><span>pos2</span><span>];</span>
  <span>output_buffer</span><span>[</span><span>pos</span><span>++</span><span>]</span> <span>=</span> <span>(</span><span>v1</span> <span>&lt;=</span> <span>v2</span><span>)</span> <span>?</span> <span>v1</span> <span>:</span> <span>v2</span><span>;</span>
  <span>pos1</span> <span>+=</span> <span>(</span><span>v1</span> <span>&lt;=</span> <span>v2</span><span>);</span>
  <span>pos2</span> <span>+=</span> <span>(</span><span>v1</span> <span>&gt;=</span> <span>v2</span><span>);</span>
<span>}</span>
</code></pre></div></div>


<p>LLVM optimization passes are aggressive in changing branchy code to use the
<a href="https://llvm.org/docs/LangRef.html#select-instruction"><code>select</code></a> IR
instruction (that choose one value based on a condition, without IR-level
branching) when possible. And <code>select</code> is typically generated as
a <code>cmove</code> instruction, so it should be easy to get branchless code. But <code>cmove</code>
is often slower than branches, so the backend can change <code>select</code> to branches
when it believes it is better.</p>

<p>This can be seen in this example taken from <a href="https://github.com/llvm/llvm-project/issues/39374">Bug 39374</a> (<a href="https://godbolt.org/z/qxv96ofbM">godbolt</a>)</p>
<div><div><pre><code><span>#include &lt;cstddef&gt;
#include &lt;cstdint&gt;
#include &lt;utility&gt;
</span>
<span>void</span> <span>downHeap</span><span>(</span><span>uint64_t</span><span>*</span> <span>top</span><span>,</span> <span>size_t</span> <span>size</span><span>,</span> <span>size_t</span> <span>pos</span><span>)</span> <span>{</span>
  <span>size_t</span> <span>parent</span> <span>=</span> <span>pos</span><span>;</span>
  <span>size_t</span> <span>child</span><span>;</span>
  <span>while</span> <span>((</span><span>child</span> <span>=</span> <span>2</span> <span>*</span> <span>parent</span> <span>+</span> <span>2</span><span>)</span> <span>&lt;</span> <span>size</span><span>)</span> <span>{</span>
    <span>auto</span> <span>left</span> <span>=</span> <span>child</span> <span>-</span> <span>1</span><span>;</span>
    <span>child</span> <span>=</span> <span>top</span><span>[</span><span>left</span><span>]</span> <span>&lt;</span> <span>top</span><span>[</span><span>child</span><span>]</span> <span>?</span> <span>child</span> <span>:</span> <span>left</span><span>;</span>  <span>// &lt;&lt;-- Unpredictable, should be CMOV</span>
    <span>if</span> <span>(</span><span>top</span><span>[</span><span>parent</span><span>]</span> <span>&lt;</span> <span>top</span><span>[</span><span>child</span><span>])</span> <span>{</span>
      <span>std</span><span>::</span><span>swap</span><span>(</span><span>top</span><span>[</span><span>parent</span><span>],</span> <span>top</span><span>[</span><span>child</span><span>]);</span>
      <span>parent</span> <span>=</span> <span>child</span><span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>return</span><span>;</span>
    <span>}</span>
  <span>}</span>
  <span>if</span> <span>(</span><span>--</span><span>child</span> <span>&lt;</span> <span>size</span> <span>&amp;&amp;</span> <span>top</span><span>[</span><span>parent</span><span>]</span> <span>&lt;</span> <span>top</span><span>[</span><span>child</span><span>])</span> <span>{</span>
    <span>std</span><span>::</span><span>swap</span><span>(</span><span>top</span><span>[</span><span>parent</span><span>],</span> <span>top</span><span>[</span><span>child</span><span>]);</span>
  <span>}</span>
<span>}</span>
</code></pre></div></div>
<p>Clang supports <code>__builtin_unpredictable</code> that tells the compiler that the
branch condition is unpredictable and should therefore better be generated
as branchless code. But this built-in only affects the middle-end passes,
so it does not help the case above where it is the backend that is changing
the <code>select</code> instruction to branches.</p>


<p>Compilers may generate branches for straight-line code without ternary operators too.</p>

<h3 id="clang">Clang</h3>
<p>The function below (taken from a <a href="https://dsprenkels.com/cmov-conversion.html">blog post</a> by Daan Sprenkels) tries to read an element from an array in a
side-channel resistant way, but the generated code generated by <code>clang</code>
contains branches that depend on the secret index.
(<a href="https://godbolt.org/z/oM5aWeYW4">godbolt</a>)</p>
<div><div><pre><code><span>#include &lt;cstddef&gt;
#include &lt;cstdint&gt;
</span>
<span>// Select an element from an array in constant time.</span>
<span>uint64_t</span> <span>constant_time_lookup</span><span>(</span><span>const</span> <span>size_t</span> <span>secret_idx</span><span>,</span>
                              <span>const</span> <span>uint64_t</span> <span>table</span><span>[</span><span>8</span><span>])</span> <span>{</span>
  <span>uint64_t</span> <span>result</span> <span>=</span> <span>0</span><span>;</span>
  <span>for</span> <span>(</span><span>size_t</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>8</span><span>;</span> <span>i</span><span>++</span><span>)</span> <span>{</span>
    <span>const</span> <span>bool</span> <span>cond</span> <span>=</span> <span>i</span> <span>==</span> <span>secret_idx</span><span>;</span>
    <span>const</span> <span>uint64_t</span> <span>mask</span> <span>=</span> <span>(</span><span>-</span><span>(</span><span>int64_t</span><span>)</span><span>cond</span><span>);</span>
    <span>result</span> <span>|=</span> <span>table</span><span>[</span><span>i</span><span>]</span> <span>&amp;</span> <span>mask</span><span>;</span>
  <span>}</span>
  <span>return</span> <span>result</span><span>;</span>
<span>}</span>
</code></pre></div></div>
<p>Here, the LLVM <code>instcombine</code> pass has optimized the sequence</p>
<div><div><pre><code>  %9 = icmp eq i64 %4, %0
  %11 = zext i1 %9 to i64
  %12 = sub nsw i64 0, %11
  %15 = and i64 %14, %12
</code></pre></div></div>
<p>to</p>
<div><div><pre><code>  %9 = icmp eq i64 %4, %0
  %15 = select i1 %9, i64 %14, i64 0
</code></pre></div></div>
<p>and the <code>select</code> instruction is then changed to branches in the backend.</p>

<h3 id="gcc">GCC</h3>
<p>GCC can also introduce branches in straight-line code. For example, the
front end generates IR for</p>
<div><div><pre><code><span>unsigned</span> <span>r</span> <span>=</span> <span>((</span><span>a</span> <span>&amp;</span> <span>0xffff0000</span><span>)</span> <span>!=</span> <span>0</span><span>)</span> <span>&lt;&lt;</span> <span>4</span><span>;</span>
</code></pre></div></div>
<p>as<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" rel="footnote">3</a></sup></p>
<div><div><pre><code><span>unsigned</span> <span>r</span><span>;</span>
<span>if</span> <span>(</span><span>a</span> <span>&gt;</span> <span>65535</span><span>)</span>
  <span>r</span> <span>=</span> <span>16</span><span>;</span>
<span>else</span>
  <span>r</span> <span>=</span> <span>0</span><span>;</span>
</code></pre></div></div>
<p>This is typically turned back to straight-line code by later optimizations,
but not always – it is easy to construct similar examples where the branches
are present in the generated code: (<a href="https://godbolt.org/z/3GqMsY6v3">godbolt</a>)</p>
<div><div><pre><code><span>unsigned</span> <span>foo</span><span>(</span><span>unsigned</span> <span>a</span><span>,</span> <span>unsigned</span> <span>b</span><span>)</span>
<span>{</span>
  <span>unsigned</span> <span>t</span> <span>=</span> <span>((</span><span>a</span> <span>&gt;</span> <span>2</span><span>)</span> <span>!=</span> <span>0</span><span>)</span> <span>&lt;&lt;</span> <span>1</span><span>;</span>
  <span>t</span> <span>|=</span> <span>((</span><span>a</span> <span>&lt;</span> <span>10</span><span>)</span> <span>!=</span> <span>0</span><span>)</span> <span>&lt;&lt;</span> <span>2</span><span>;</span>
  <span>return</span> <span>b</span> <span>&gt;&gt;</span> <span>t</span><span>;</span>
<span>}</span>
</code></pre></div></div>


<p>To summarize the main points made in this blog post:</p>
<ul>
  <li>Branches are sometimes faster than <code>cmove</code>, and <code>cmove</code> is sometimes faster
than branches.</li>
  <li>Sometimes compilers do the wrong thing:
    <ul>
      <li><code>__builtin_expect</code> does not help convince GCC to use branches…</li>
      <li>… but <code>__builtin_expect_with_probability</code> may help.</li>
      <li><code>__builtin_unpredictable</code> does not guarantee that LLVM generates
branchless code.</li>
    </ul>
  </li>
  <li>Compilers may insert branches in straight-line code.</li>
</ul>



<hr/>



  </div></div>
  </body>
</html>
