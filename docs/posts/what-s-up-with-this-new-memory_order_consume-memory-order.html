<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://devblogs.microsoft.com/oldnewthing/20230427-00/?p=108107">Original</a>
    <h1>What&#39;s up with this new memory_order_consume memory order?</h1>
    
    <div id="readability-page-1" class="page"><div id="featured">

	<div>
                         <p>
            April 27th, 2023</p><!-- .entry-meta -->
        
<p>C++20 introduces a new atomic memory order: <code>std::<wbr/>memory_<wbr/>order::<wbr/>consume</code>, more commonly known as <code>std::<wbr/>memory_<wbr/>order_<wbr/>consume</code>, What is this guy?</p>
<p>The <code>consume</code> memory order is a weaker form of <code>acquire</code>. Whereas <code>acquire</code> prevents <i>all</i> future memory accesses from being ordered ahead of the load, the <code>consume</code> order only prevents <i>dependent</i> future memory accesses from being reorder ahead of the load.</p>
<p>In all the examples, let’s assume global variables declared and initialized as</p>
<pre>int v1 = 1;
int v2 = 2;
std::atomic&lt;int*&gt; p{ &amp;v1 };
</pre>
<p>Okay, let’s do some consuming.</p>
<pre>auto sample_consume()
{
    auto q = p.load(std::memory_order_consume);
    return *q + v2;
}
</pre>
<p>The compiler is required to read the value from <code>p</code> into <code>q</code>, and any future calculations depending on that value must occur after the load.</p>
<p>This reordering is allowed:</p>
<pre>auto sample_consume_allowed()
{
    auto prefetch2 = v2;
    auto q = p.load(std::memory_order_consume);
    return *q + prefetch2;
}
</pre>
<p>The value of <code>v2</code> is not dependent on what was loaded from <code>p</code>. Therefore, the compiler and processor are permitted to advance the fetch of <code>v2</code> ahead of the load of <code>p</code>. Note that an <code>acquire</code> load of <code>p</code> would have prohibited this reordering, since acquire loads block <i>all</i> future memory access, even if unrelated to the value being acquired.</p>
<p>However, this reordering of the above code is not allowed:</p>
<pre>auto sample_consume_disallowed()
{
    auto speculate1 = v1;
    auto q = p.load(std::memory_order_consume);
    if (q == &amp;v1) return speculate1 + v2;
    return *q + v2;
}
</pre>
<p>This speculation lets the code hide the memory latency of accessing <code>v1</code> behind the load of <code>p</code>, and a compiler might choose to take advantage of this based on profiling feedback, and a processor might do it unilaterally because processors like to do speculative things nowadays. This would be allowed if the load from <code>p</code> were <code>relaxed</code>.</p>
<p>However, the <code>consume</code> memory order prohibits this transformation: The value loaded from <code>p</code> is dereferenced, and that dereference operation is dependent upon the value that was loaded, so the <code>consume</code> memory order requires that the dereference occur after the load.</p>
<p>Here’s a table, because people like tables.</p>
<table>
<tbody>
<tr>
<th>Ordering</th>
<th>Relaxed</th>
<th>Consume</th>
<th>Acquire</th>
</tr>
<tr>
<td>Load <code>v2</code> before <code>p</code></td>
<td>Allowed</td>
<td>Allowed</td>
<td>Prohibited</td>
</tr>
<tr>
<td>Dereference <code>p</code> before load</td>
<td>Allowed</td>
<td>Prohibited</td>
<td>Prohibited</td>
</tr>
</tbody>
</table>
<p>The <code>consume</code> memory order is not used much. Atomic variables are typically tied to other variables in ways that don’t show up in expression dependency graphs, such as for use as mutual exclusion locks. The <code>acquire</code> memory order is much more commonly used than <code>consume</code>.</p>

        

		
        
	</div><!-- .entry-content -->

</div></div>
  </body>
</html>
