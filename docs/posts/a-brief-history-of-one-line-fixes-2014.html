<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://flak.tedunangst.com/post/a-brief-history-of-one-line-fixes">Original</a>
    <h1>A brief history of one line fixes (2014)</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>
<a href="https://www.imperialviolet.org/2014/02/22/applebug.html">Apple recently made a booboo</a>, unlike any other booboo in the history of programming. Even though Apple’s bug is unprecedented, here’s a brief overview of some predecessor bugs.<br/></p><h4>X</h4><p>Back in 2006, the X server checked to make sure the user was root, but <a href="http://www.x.org/releases/X11R7.0/patches/xorg-server-1.0.1-geteuid.diff">forgot to actually call the function</a>.</p><pre><code><span>--- hw/xfree86/common/xf86Init.c</span>
<span>+++ hw/xfree86/common/xf86Init.c</span>
<span>@@ -1677,7 +1677,7 @@</span>
   }
   if (!strcmp(argv[i], &#34;-configure&#34;))
   {
<span>-    if (getuid() != 0 &amp;&amp; geteuid == 0) {</span>
<span>+    if (getuid() != 0 &amp;&amp; geteuid() == 0) {</span>
        ErrorF(&#34;The &#39;-configure&#39; option can only be used by root.\n&#34;);
        exit(1);
     }</code></pre><p>How is this possible? Does nobody use a compiler that warns about comparisons always being false?<br/></p><h4>Debian OpenSSL</h4><p>Remember that time back in 2008 when Debian shipped a special limited edition OpenSSL? <a href="http://www.debian.org/security/2008/dsa-1571">“As a result, cryptographic key material may be guessable.”</a></p><pre><code><span>--- openssl-a/md_rand.c</span>
<span>+++ openssl-b/md_rand.c</span>
<span>@@ -271,10 +271,7 @@</span>
                else
                        MD_Update(&amp;m,&amp;(state[st_idx]),j);

<span>-/*             </span>
<span>- * Don&#39;t add uninitialised data.</span>
                MD_Update(&amp;m,buf,j);
<span>-*/</span>
                MD_Update(&amp;m,(unsigned char *)&amp;(md_c[0]),sizeof(md_c));
                MD_Final(&amp;m,local_md);
                md_c[1]++;</code></pre><p>OK, I’m cheating here, it’s a three line fix. How is this possible? Does nobody read the OpenSSL mailing list or the Debian bug tracker? Whatever happened to code review?<br/></p><h4>Regular OpenSSL</h4><p>Also in OpenSSL and also from 2008, <a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-5077">“OpenSSL 0.9.8i and earlier does not properly check the return value from the EVP_VerifyFinal function, which allows remote attackers to bypass validation of the certificate chain via a malformed SSL/TLS signature for DSA and <span>ECDSA</span> keys.”</a></p><pre><code><span>--- lib/libssl/src/ssl/s3_srvr.c</span>
<span>+++ lib/libssl/src/ssl/s3_srvr.c</span>
<span>@@ -2009,7 +2009,7 @@ static int ssl3_get_client_certificate(S</span>
 	else
 		{
 		i=ssl_verify_cert_chain(s,sk);
<span>-		if (!i)</span>
<span>+		if (i &lt;= 0)</span>
 			{
 			al=ssl_verify_alarm_type(s-&gt;verify_result);
 			SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,SSL_R_NO_CERTIFICATE_RETURNED);</code></pre><p>Bypass validation of the certificate chain? That’s bad, right? Like “worst security bug you could possibly imagine” bad, right?<br/></p><h4>Android</h4><p>Let’s look at the 2010 <a href="https://code.google.com/p/android-source-browsing/source/detail?spec=svn.platform--bootable--bootloader--legacy.734756ca3968b54e32acab867a05b10fc5e13d07&amp;r=734756ca3968b54e32acab867a05b10fc5e13d07&amp;repo=platform--bootable--bootloader--legacy">memset fix</a>.</p><pre><code><span>--- libc-a/memset.c</span>
<span>+++ libc-b/memset.c</span>
<span>@@ -1,6 +1,6 @@</span>
 void *memset(void *_p, unsigned v, unsigned count)
 {
     unsigned char *p = _p;
<span>-    while(count-- &gt; 0) *p++ = 0;</span>
<span>+    while(count-- &gt; 0) *p++ = v;</span>
     return _p;
 }</code></pre><p>How is this possible? Does nobody use a compiler that warns about unused parameters? Where are the unit tests?<br/></p><h4>Tarsnap</h4><p>From 2011, <a href="http://www.daemonology.net/blog/2011-01-18-tarsnap-critical-security-bug.html">“I took this opportunity to ‘refactor’ the <span>AES-CTR</span> code.”</a></p><pre><code><span>--- tarsnap-autoconf-1.0.27/lib/crypto/crypto_file.c</span>
<span>+++ tarsnap-autoconf-1.0.28/lib/crypto/crypto_file.c</span>
<span>@@ -108,7 +108,7 @@</span>

        /* Encrypt the data. */
        if ((stream =
<span>-           crypto_aesctr_init(&amp;encr_aes-&gt;key, encr_aes-&gt;nonce)) == NULL)</span>
<span>+           crypto_aesctr_init(&amp;encr_aes-&gt;key, encr_aes-&gt;nonce++)) == NULL)</span>
                goto err0;
        crypto_aesctr_stream(stream, buf, filebuf + CRYPTO_FILE_HLEN, len);
        crypto_aesctr_free(stream);</code></pre><p>Pretty obvious what went wrong here: using goto with an unbraced if. Even novice programmers know that using the correct coding style prevents refactoring errors.<br/></p><h4>mysql</h4><p>MySQL would let you login using <a href="http://marc.info/?l=oss-security&amp;m=133925698725885&amp;w=2">one out of every 256</a> randomly generated passwords because ints are bigger than bools.</p><pre><code><span>--- sql/password.c      2011-07-03 15:47:37 +0000</span>
<span>+++ sql/password.c      2012-04-06 09:04:07 +0000</span>
<span>@@ -531,7 +531,7 @@</span>
   mysql_sha1_reset(&amp;sha1_context);
   mysql_sha1_input(&amp;sha1_context, buf, SHA1_HASH_SIZE);
   mysql_sha1_result(&amp;sha1_context, hash_stage2_reassured);
<span>-  return memcmp(hash_stage2, hash_stage2_reassured, SHA1_HASH_SIZE);</span>
<span>+  return test(memcmp(hash_stage2, hash_stage2_reassured, SHA1_HASH_SIZE));</span>
 }
 
 </code></pre><p>I can’t even.<br/></p><h4>lessons</h4><p>What do all these earlier mistakes have in common? First, they’re all exemples of “catastrophic loss of structural integrity” as I used to say in my Star Trek days. Second, they all date from before 2013. That’s how we know the NSA wasn’t involved.<br/></p><h4>update</h4><p>I was fairly certain the sarcasm (or satire as I prefer to call it; sounds more intellectual) would be obvious. If the first few attempts didn’t work, surely the Tarsnap commentary would make my point unmistakeably clear. Alas, not. And no sooner was the <a href="https://www.gitorious.org/gnutls/gnutls/commit/6aa26f78150ccbdf0aec1878a41c17c41d358a3b">latest GnuTLS diff</a> announced than somebody asks “How is this possible?” I have failed utterly.</p><p><a href="https://flak.tedunangst.com/post/thoughts-on-style-the-TLS-and-errors">A few more thoughts</a>.<br/></p><h4>sendmail</h4><p>Another one for the record books. <span>CVE-2014-3956</span>.</p><pre><code><span>--- gnu/usr.sbin/sendmail/sendmail/conf.c	12 Jun 2013 21:27:22 -0000	1.35</span>
<span>+++ gnu/usr.sbin/sendmail/sendmail/conf.c	5 Jun 2014 10:16:18 -0000</span>
<span>@@ -5267,8 +5267,8 @@ closefd_walk(lowest, fd)</span>
 */
 
 void
<span>-sm_close_on_exec(highest, lowest)</span>
<span>-	int highest, lowest;</span>
<span>+sm_close_on_exec(lowest, highest)</span>
<span>+	int lowest, highest;</span>
 {
 #if HASFDWALK
 	(void) fdwalk(closefd_walk, &amp;lowest);</code></pre></div><div><p>
Posted 01 Mar 2014 15:00 by tedu Updated: 03 Feb 2015 21:58 
</p></div></div>
  </body>
</html>
