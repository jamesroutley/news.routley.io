<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lwn.net/Articles/444910/">Original</a>
    <h1>Object oriented design patterns in the Linux kernel (2011)</h1>
    
    <div id="readability-page-1" class="page"><div>
<center>
           <div><b>Benefits for LWN subscribers</b><p>The primary benefit from <a href="https://lwn.net/subscribe/">subscribing to LWN</a>
       is helping to keep us publishing, but, beyond that, subscribers get
       immediate access to all site content and access to a number of extra
       site features.  Please sign up today!</p></div>
           </center>
           <p>
Despite the fact that the Linux Kernel is mostly written in C, it
makes broad use of some techniques from the field of object-oriented
programming.
Developers wanting to use these object-oriented techniques receive
little support or guidance from the language and so are left to fend
for themselves.  As is often the case, this is a double-edged sword.
The developer has enough flexibility to do really cool things, and
equally the flexibility to do really stupid things, and it isn&#39;t
always clear at first glance which is which, or more accurately: where
on the spectrum a particular approach sits.
</p><p>
Instead of looking to the language to provide guidance, a software
engineer must look to established practice to find out what works well
and what is best avoided.  Interpreting established practice is not
always as easy as one might like and the effort, once made, is worth
preserving.
To preserve that effort on your author&#39;s part, this article brings
another installment in an
<a href="https://lwn.net/Articles/336224/">occasional series</a> on Linux Kernel Design
Patterns and attempts to set out - with examples - the design patterns
in the Linux Kernel which effect an object-oriented style of
programming.
</p><p>
Rather than providing a brief introduction to the object-oriented
style, tempting though that is, we will assume the reader has a basic
knowledge of objects, classes, methods, inheritance, and similar
terms.  For those as yet unfamiliar with these, there are plenty of
resources to be found elsewhere on the web.
</p><p>
Over two weeks we will look for patterns in just two areas:  method
dispatch and data inheritance.  Despite their apparent
simplicity they lead to some rich veins for investigation.
This first article will focus on method dispatch.
</p>
<h3>Method Dispatch</h3>
<p>
The large variety of styles of inheritance and rules for its usage in
languages today seems to suggest that there is no uniform
understanding of what &#34;object-oriented&#34; really means.  The term is a bit like
&#34;love&#34;: everyone thinks they know what it means but when you get down
to details people can find they have very different ideas.

While what it means to be &#34;oriented&#34; might not be clear, what we mean
by an &#34;object&#34; does seem to be uniformly agreed upon.  It is simply an
abstraction comprising both state and behavior.  An object is like a
record (Pascal) or struct (C), except that some of the names of members
refer to functions which act on the other fields in the object.
These function members are sometimes referred to a &#34;methods&#34;.
</p><p>
The most obvious way to implement objects in C is to declare a
&#34;struct&#34; where some fields are pointers to functions which take a
pointer to the struct itself as their first argument.  The calling
convention for method &#34;foo&#34; in object &#34;bar&#34; would simply be:
<tt>bar-&gt;foo(bar, ...args);</tt>

While this pattern is used in the Linux kernel it is not the dominant
pattern so we will leave discussion of it until a little later.
</p><p>
As methods (unlike state) are not normally changed on a per-object
basis, a more common and only slightly less obvious approach is to
collect all the methods for a particular class of objects into a
separate structure, sometimes known as a &#34;virtual function table&#34; or
<a href="http://en.wikipedia.org/wiki/Virtual_method_table">vtable</a>.

The object then has a single pointer to this table rather than a
separate pointer for each method, and consequently uses less memory.
</p><p>
This then leads to our first pattern - a <b>pure vtable</b> being a
structure which contains only function pointers where the first argument of
each is a pointer to some other structure (the object type) which itself
contains a pointer to this vtable.

Some simple examples of this in the Linux kernel are the
<a href="http://lxr.linux.no/#linux+v2.6.39/include/linux/fs.h#L1062"><tt>file_lock_operations</tt></a>
structure which contains two function pointers
each of which take a pointer to a <tt>struct file_lock</tt>, and the
<a href="http://lxr.linux.no/#linux+v2.6.39/include/linux/seq_file.h#L29"><tt>seq_operations</tt></a> vtable which contains four function pointers
which each operate on a <tt>struct seq_file</tt>.

These two examples display an obvious naming pattern - the structure
holding a vtable is named for the structure holding the object
(possibly abbreviated) followed by &#34;_operations&#34;.  While this pattern is
common it is by no means universal.   Around the time of 2.6.39
there are approximately 30 &#34;*_operations&#34; structures along with well over
100 &#34;*_ops&#34; structures, most if not all of which are vtables of some
sort. There are also several structs such as <tt>struct mdk_personality</tt>
which are essentially vtables but do not have particularly helpful
names.
</p><p>
Among these nearly 200 vtable structures there is plenty of variability
and so plenty of scope to look for interesting patterns.  In
particular we can look for common variations from the &#34;pure vtable&#34;
pattern described above and determine how these variations contribute
to our understanding of object use in Linux.
</p>
<h4>NULL function pointers</h4>
<p>
The first observation is that some function pointers in some vtables
are allowed to be NULL.  Clearly trying to call such a function would
be futile, so the code that calls into these methods generally
contains an explicit test for the pointer being NULL.  There are a few
different reasons for these NULL pointers.

Probably easiest to justify is the incremental development
reason.  Because of the way vtable structures are initialized, adding
a new function pointer to the structure definition causes all existing
table declarations to initialise that pointer to NULL.  Thus it is
possible to add a caller of the new method before any instance
supports that method, and have it check for NULL and perform a default
behavior.   Then as incremental development continues those vtable
instances which need it can get non-default methods.
</p><p>
A recent example is commit
<a href="http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commitdiff;h=77af1b2641faf4">77af1b2641faf4</a> adding
<tt>set_voltage_time_sel()</tt> to <tt>struct regulator_ops</tt> which acts on
<tt>struct regulator_dev</tt>.  Subsequent commit
<a href="http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commitdiff;h=42ab616afe8844">42ab616afe8844</a>
defines that method
for a particular device.  This is simply the most recent example of a
very common theme.
</p><p>
Another common reason is that certain methods are not particularly
meaningful in certain cases so the calling code simply tests for NULL
and returns an appropriate error when found.  There are multiple
examples of this in the virtual filesystem (VFS) layer.  For instance,
the <tt>create()</tt> function in
<a href="http://lxr.linux.no/#linux+v2.6.39/include/linux/fs.h#L1569"><tt>inode_operations</tt></a>
is only meaningful if the inode in question is a
directory.  So <tt>inode_operations</tt> structures for non-directories
typically have NULL for the <tt>create()</tt> function (and many others) and
the calling code in <tt>vfs_create()</tt> checks for NULL and returns <tt>-EACCES</tt>.
</p><p>
A final reason that vtables sometimes contain NULL is that an element
of functionality might be being transitioned from one interface to
another.  A good example of this is the <tt>ioctl()</tt> operation in
<a href="http://lxr.linux.no/#linux+v2.6.39/include/linux/fs.h#L1537"><tt>file_operations</tt></a>.
In 2.6.11, a new method, <tt>unlocked_ioctl()</tt> was added
which was called without the big kernel lock held.  In 2.6.36, when all
drivers and filesystems had been converted to use <tt>unlocked_ioctl()</tt>,
the original <tt>ioctl()</tt> was finally removed.  During this transition a file system
would typically define only one of two, leaving the other defaulting to NULL.
</p><p>
A slightly more subtle example of this is <tt>read()</tt> and <tt>aio_read()</tt>, also in
<tt>file_operations</tt>, and the corresponding <tt>write()</tt> and <tt>aio_write()</tt>.
<tt>aio_read()</tt> was introduced to support asynchronous IO, and if it is
provided the regular synchronous <tt>read()</tt> is not needed (it is effected
using <tt>do_sync_read()</tt> which calls the <tt>aio_read()</tt> method).  In this case
there appears to be no intention of ever removing <tt>read()</tt> - it will
remain for cases where async IO is not relevant such as special
filesystems like procfs and sysfs.  So it is still the case that only one of each
pair need be defined by a filesystem, but it is not simply a transition, it is
a long-term state.
</p><p>
Though there seem to be several different reasons for a NULL function pointer,
almost every case is an example of one simple pattern - that of providing a
default implementation for the method.  In the &#34;incremental development&#34;
examples and the non-meaningful method case, this is fairly straightforward.
e.g. the default for <tt>inode-&gt;create()</tt> is simply to return an error.
In the interface transition case it is only slightly less obvious.  The default for
<tt>unlocked_ioctl()</tt> would be to take the kernel lock and then call
the <tt>ioctl()</tt> method.  The
default for <tt>read()</tt> is exactly <tt>do_sync_read()</tt> and some filesystems such
as <tt><a href="http://lxr.linux.no/#linux+v2.6.39/fs/ext3/file.c#L55">ext3</a></tt>
actually provide this value explicitly rather than using
&#34;NULL&#34; to indicate a default.
</p><p>
With that in mind, a little reflection suggests that if the real goal is to
provide a default, then maybe the best approach would be to explicitly give a
default rather than using the circuitous route of using a default of NULL and
interpreting it specially.
</p><p>
While NULL is certainly the easiest value to provide as a default - as the C
standard assures us that uninitialized members of a structure do get set to
NULL - it is not very much harder to set a more meaningful default.
I am indebted to LWN reader
<a href="https://lwn.net/Articles/437878/">wahern</a> for the observation that
C99 allows fields in a structure to be initialized multiple times with only the
final value taking effect and that this allows easy setting of default values
such as by following the simple model:
</p>
<pre>    #define FOO_DEFAULTS  .bar = default_bar, .baz = default_baz
    struct foo_operations my_foo = { FOO_DEFAULTS,
	.bar = my_bar,
    };
</pre><p>
This will declare <tt>my_foo</tt> with a predefined default value for <tt>baz</tt> and a
localized value for <tt>bar</tt>.  Thus for the small cost of defining a few &#34;default&#34;
functions and including a &#34;<tt>_DEFAULTS</tt>&#34; entry to each declaration, the
default value for any field can easily be chosen when the field is first
created, and automatically included in every use of the structure.
</p><p>
Not only are meaningful defaults easy to implement, they can lead to a more
efficient implementation.  In those cases where the function pointer actually
is NULL it is probably faster to test and branch rather than to make an
indirect function call.  However the NULL case is very often
the exception rather than the rule, and optimizing for an
exception is not normal practice.  In the more common case when
the function pointer is not NULL, the test for NULL is simply a
waste of code space and a waste of execution time.  If we
disallow NULLs we can make all call sites a little bit smaller and simpler.
</p><p>
In general, any testing performed by the caller before calling a method
can be seen as an instance of the &#34;mid-layer mistake&#34; discussed
<a href="https://lwn.net/Articles/336262/">in a previous article</a>.  It shows that the
mid-layer is making 
assumptions about the behavior of the lower level driver rather than simply
giving the driver freedom to behave in whatever way is most
suitable.  This may not always be an expensive mistake, but it
is still best avoided where possible.

Nevertheless there is a clear pattern in the Linux kernel that
pointers in vtables can sometimes be NULLable, typically though not
always to enable a transition, and the call sites should in these
cases test for NULL before proceeding with the call.
</p><p>
The observant reader will have noticed a hole in the above logic
denouncing the use NULL pointers for defaults.  In the case where the
default is the common case and where performance is paramount, the
reasoning does not hold and a NULL pointer could well be justified.
Naturally the Linux kernel provides an example of such a case for our
examination.
</p><p>
One of the data structures used by the VFS for caching filesystem
information is the &#34;dentry&#34;.  A &#34;dentry&#34; represents a name in the
filesystem, and so each &#34;dentry&#34; has a parent, being the directory
containing it, and an &#34;inode&#34; representing the named file.  The dentry
is separate from the inode because a single file can have multiple
names (so an &#34;inode&#34; can have multiple &#34;dentry&#34;s).

There is a <tt>dentry_operations</tt> vtable with a number of operations including,
for example, &#34;d_compare&#34; which will compare two names and &#34;d_hash&#34;
which will generate a hash for the name to guide the storage of the
&#34;dentry&#34; in a hash table.  Most filesystems do not need this flexibility.  They
treat names as uninterpreted strings of bytes so the default compare and hash
functions are the common case.  A few filesystems define these to
handle case-insensitive names but that is not the norm.
</p><p>
Further, filename lookup is a common operation in Linux and so
optimizing it is a priority.  Thus these two operations
appear to be good candidates where a test for NULL and an inlined
default operation might be appropriate.  What we find though is that
when such an optimization is warranted it is not by itself enough.

The code that calls <tt>d_compare()</tt> and <tt>d_hash()</tt> (and a couple of other dentry
operations) does not test these functions for NULL directly.  Rather
they require that a few flag bits (DCACHE_OP_HASH, DCACHE_OP_COMPARE)
in the &#34;dentry&#34; are set up to indicate whether the common default
should be used, or whether the function should be called.  As the flag
field is likely to be in cache anyway, and the <tt>dentry_operations</tt>
structure will often be not needed at all, this avoids a memory fetch
in a hot path.
</p><p>
So we find that the one case where using a NULL function pointer to
indicate a default could be justified, it is not actually used; instead, a
different, more efficient,
mechanism is used to indicate that the default method is requested.
</p>
<h4>Members other than function pointers</h4>
<p>
While most vtable-like structures in the kernel contain exclusively
function pointers, there are a significant minority that have
non-function-pointer fields.  Many of these appear on the surface
quite arbitrary and a few closer inspections suggest that some of them
result of poor design or bit-rot and their removal would only improve
the code.
</p><p>
There is one exception to the &#34;functions only&#34; pattern that occurs
repeatedly and provides real value, and so is worth exploring.
This pattern is seen in its most general form in
<a href="http://lxr.linux.no/#linux+v2.6.39/drivers/md/md.h#L348"><tt>struct mdk_personality</tt></a>
which provides operations for a particular software
RAID level.  In particular this structure contains an &#34;owner&#34;, a
&#34;name&#34;, and a &#34;list&#34;.  The &#34;owner&#34; is the module that provides the
implementation.  The &#34;name&#34; is a simple identifier: some vtables have
string names, some have numeric names, and it is often called
something different like &#34;version&#34;, &#34;family&#34;, &#34;drvname&#34;, or
&#34;level&#34;.  But conceptually it is still a name.  In the present example
there are two names, a string and a numeric &#34;level&#34;.
</p><p>
The &#34;list&#34;, while part of the same functionality, is less
common. The mdk_personality structure has a <tt>struct list_head</tt>, as does
<a href="http://lxr.linux.no/#linux+v2.6.39/include/linux/textsearch.h#L37"><tt>struct ts_ops</tt></a>.
<a href="http://lxr.linux.no/#linux+v2.6.39/include/linux/fs.h#L1793"><tt>struct file_system_type</tt></a> 
has a simple pointer to the next
<tt>struct file_system_type</tt>.

The underlying idea here is that for any particular implementation of
an interface (or &#34;final&#34; definition of a class) to be usable, it must
be registered in some way so that it can be found.  Further, once it
has been found it must be possible to ensure that the module holding
the implementation is not removed while it is in use.
</p><p>
There seem to be nearly as many styles of registration against an
interface in Linux as there are interfaces to register against, so
finding strong patterns there would be a difficult task.  However it
is fairly common for a &#34;vtable&#34; to be treated as the primary handle on
a particular implementation of an interface and to have an &#34;owner&#34;
pointer which can be used to get a reference on the module which
provides the implementation.
</p><p>
So the pattern we find here is that a structure of function pointers
used as a &#34;vtable&#34; for object method dispatch should normally contain
<b>only</b> function pointers.  Exceptions require clear justification.  A
common exception allows a module pointer and possible other fields such
as a name and a list pointer. These fields are used to support
the registration protocol for the particular interface.
When there is no list pointer it is very likely that the entire vtable will
be treated as read-only.  In this case the vtable will often be declared as
a <tt>const</tt> structure and so could even be stored in read-only memory.

</p>
<h4>Combining Methods for different objects</h4>
<p>
A final common deviation from the &#34;pure vtable&#34; pattern that we see in
the Linux kernel occurs when the first argument to the function is not
always the same object type.  In a pure vtable which is referenced by
a pointer in a particular data structure, the first argument of
each function is exactly that data structure.  What reason could there
be for deviating from that pattern?  It turns out that there are few,
some more interesting than others.
</p><p>
The simplest and least interesting explanation is that, for no apparent
reason, the target data structure is listed elsewhere in the argument
list.  For example all functions in
<a href="http://lxr.linux.no/#linux+v2.6.39/include/linux/fb.h#L623"><tt>struct
fb_ops</tt></a>
take a <tt>struct fb_info</tt>.  While in 18 cases that structure is the first argument, in
five cases it is the last.  There is nothing obviously wrong with this
choice and it is unlikely to confuse developers.  It is only a problem
for data miners like your author who need to filter it out as an
irrelevant pattern.
</p><p>
A slight deviation on this pattern is seen in
<a href="http://lxr.linux.no/#linux+v2.6.39/include/linux/rfkill.h#L145"><tt>struct rfkill_ops</tt></a>
where two functions take a <tt>struct rkfill</tt> but the third - <tt>set_block()</tt> -
takes a <tt>void *data</tt>.  Further investigation shows that this opaque
<tt>data</tt> is exactly that which is stored in <tt>rfkill-&gt;data</tt>, so <tt>set_block()</tt>
could easily be defined to take a <tt>struct rfkill</tt> and simply to follow
the <tt>-&gt;data</tt> link itself.  This deviation is sufficiently non-obvious
that it could conceivably confuse developers as well as data miners
and so should be avoided.
</p><p>
The next deviation in seen for example in
<a href="http://lxr.linux.no/#linux+v2.6.39/include/linux/suspend.h#L108"><tt>platform_suspend_ops</tt></a>,
<a href="http://lxr.linux.no/#linux+v2.6.39/include/linux/oprofile.h#L51"><tt>oprofile_operations</tt></a>,
<a href="http://lxr.linux.no/#linux+v2.6.39/include/linux/security.h#L1375"><tt>security_operations</tt></a>
and a few others.  These
take an odd assortment of arguments with no obvious pattern.  However
these are really very different sorts of vtable structures in that the
object they belong to are singletons.  There is only one active
platform, only one profiler, only one security policy.  Thus the
&#34;object&#34; on which these operations act is part of the global state and
so does not need to be included in the arguments of any functions.
</p><p>
Having filtered these two patterns out as not being very interesting
we are left with two that do serve to tell us something about object
use in the kernel.
</p><p>
<a href="http://lxr.linux.no/#linux+v2.6.39/include/linux/quota.h#L301"><tt>quota_format_ops</tt></a>
and
<a href="http://lxr.linux.no/#linux+v2.6.39/include/linux/exportfs.h#L167"><tt>export_operations</tt></a>
are two different operations structures that operate on a variety of different
data structures.  In each case the apparent primary object (e.g. a
<tt>struct super_block</tt> or a <tt>struct dentry</tt>) already has a vtable
structure dedicated to it (such as <tt>super_operations</tt> or
<tt>dentry_operations</tt>) and these new structures add new operations.  In
each case the new operations form a cohesive unit providing a related
set of functionality - whether supporting disk quotas or NFS export.
They don&#39;t all act on the same object simply because the functionality
in question depends on a variety of objects.
</p><p>
The best term from the language of object-oriented programming for this
is probably the &#34;<a href="http://en.wikipedia.org/wiki/Mixin">mixin</a>&#34;.
Though the fit may not be perfect -
depending on what your exact understanding of mixin is - the idea of
bringing in a collection of functionality without using strict hierarchical
inheritance is very close to the purpose of <tt>quota_format_ops</tt> and
<tt>export_operations</tt>.
</p><p>
Once we know to be on the lookout for mixins like these we can find
quite a few more examples.  The pattern to be alert for is not the one
that led us here - an operations structure that operates on a variety
of different objects - but rather the one we found where the functions
in an &#34;operations&#34; structure operate on objects that already have their
own &#34;operations&#34; structure.  When an object has a large number of
operations that are relevant and these operations naturally group into
subsets, it makes a lot of sense to divide them into separate
vtable-like structures.  There are several examples of this in the
networking code where for instance both
<a href="http://lxr.linux.no/#linux+v2.6.39/include/net/tcp.h#L661"><tt>tcp_congestion_ops</tt></a>
and
<a href="http://lxr.linux.no/#linux+v2.6.39/include/net/inet_connection_sock.h#L38"><tt>inet_connection_sock_af_ops</tt></a>
operate (primarily) on a <tt>struct sock</tt>,
which itself has already got a small set of dedicated operations.
</p><p>
So the pattern of a &#34;mixin&#34; - at least as defined as a set of operations
which apply to one or more objects without being the primary
operations for those objects - is a pattern that is often found in the
kernel and appears to be quite valuable in allowing better
modularization of code.
</p><p>
The last pattern which explains non-uniform function targets is
probably the most interesting, particularly in its contrast to the
obvious application of object-oriented programming style.

Examples of this pattern abound with
<a href="http://lxr.linux.no/#linux+v2.6.39/include/linux/libata.h#L803"><tt>ata_port_operations</tt></a>,
<a href="http://lxr.linux.no/#linux+v2.6.39/include/linux/tty_driver.h#L243"><tt>tty_operations</tt></a>,
<a href="http://lxr.linux.no/#linux+v2.6.39/include/linux/nfs_xdr.h#L1125"><tt>nfs_rpc_ops</tt></a>
and
<a href="http://lxr.linux.no/#linux+v2.6.39/include/linux/atmdev.h#L388"><tt>atmdev_ops</tt></a>
all appearing as
useful examples.  However we will focus primarily on some examples
from the filesystem layer, particularly
<a href="http://lxr.linux.no/#linux+v2.6.39/include/linux/fs.h#L1613"><tt>super_operations</tt></a>
and
<a href="http://lxr.linux.no/#linux+v2.6.39/include/linux/fs.h#L1569"><tt>inode_operations</tt></a>.
</p><p>
There is a strong hierarchy of objects in the implementation of a
filesystem where the filesystem - represented by a &#34;super_block&#34; - has a
number of files (<tt>struct inode</tt>) which may have a number of names or
links (<tt>struct dentry</tt>).  Further each file might store data in the page
cache (<tt>struct address_space</tt>) which comprises a number of individual
pages (<tt>struct page</tt>).

There is a sense in which all of these different objects belong to the
filesystem as a whole.  If a page needs to be loaded with data from a
file, the filesystem knows how to do that, and it is probably the same
mechanism for every page in every file.  Where it isn&#39;t always the
same, the filesystem knows that too.  So we could conceivably store
every operation on every one of these objects in the
<tt>struct super_block</tt>, as it represents the filesystem and could know what to
do in each case.
</p><p>
In practice that extreme is not really helpful.  It is quite likely
that while there are similarities between the storage of a regular file
and a directory, there are also important differences and being able
to encode those differences in separate vtables can be helpful.
Sometimes small symbolic links are stored directly in the inode while
larger links are stored like the contents of a regular file.  Having
different <tt>readlink()</tt> operations for the two cases can make the code a
lot more readable.
</p><p>
While the extreme of every operation attached to the one central
structure is not ideal, it is equally true that the opposite extreme
is not ideal either.  The <tt>struct page</tt> in Linux does not have a
vtable pointer at all - in part because we want to keep the structure
as small as possible because it is so populous.  Rather the
<tt>address_space_operations</tt> structure contains the operations that act
on a page.  Similarly the <tt>super_operations</tt> structure contains some
operations that apply to inodes, and <tt>inode_operations</tt> contains some
operations that apply to dentries.
</p><p>
It is clearly possible to have operations structures attached to a
parent of the target object - providing the target holds a reference
to the parent, which it normally does - though it is not quite so clear that
it is always beneficial.  In the case of <tt>struct page</tt> which avoids
having a vtable pointer altogether the benefit is clear.  In the case
of <tt>struct inode</tt> which has its own vtable pointer, the benefit of
having some operations (such as <tt>destroy_inode()</tt> or <tt>write_inode()</tt>)
attached to the super_block is less clear.
</p><p>
As there are several vtable structures where any given function
pointer could be stored, the actual choice is in many cases little
more than historical accident.  Certainly the proliferation
of <tt>struct dentry</tt> operations in <tt>inode_operations</tt> seems to be
largely due to the fact that some of them used to act directly
on the inode, but changes in the VFS eventually required this
to change.  For example in 2.1.78-pre1, each of <tt>link()</tt>,
<tt>readlink()</tt>, <tt>followlink()</tt> (and some others which are now
defunct) were 
<a href="http://git.kernel.org/?p=linux/kernel/git/davej/history.git;a=commitdiff;h=5770cca79b11eaf962b41008c2eb1e845c3aae51#patch45">changed</a>
from taking a <tt>struct inode</tt> to
take a <tt>struct dentry</tt> instead.  This set the scene for &#34;dentry&#34;
operations to be in <tt>inode_operations</tt>, so when setattr and getattr
were added for 2.3.48, it probably seemed completely natural to
include them in <tt>inode_operations</tt> despite the fact that they acted
primarily on a dentry.
</p><p>
Possibly we could simplify things by getting rid of
<tt>dentry_operations</tt> altogether.  Some operations that act on dentries
are already in <tt>inode_operations</tt> and <tt>super_operations</tt> - why not move
them all there?  While dentries are not as populous as <tt>struct page</tt>
there are still a lot of them and removing the &#34;d_op&#34; field could save
5% of the memory used by that structure (on x86-64).
</p><p>
With two exceptions, every active filesystem only has a single dentry
operations structure in effect.  Some filesystem implementations like
&#34;vfat&#34; define two - e.g. one with case-sensitive matching and one with
case-insensitive matching - but there is only one active per
super-block.  So it would seem that the operations in
dentry_operations could be moved to <tt>super_operations</tt>, or at
least accessed through &#34;s_d_op&#34;.

The two exceptions are ceph and procfs.  These filesystems use
different <tt>d_revalidate()</tt> operations in different parts of the
filesystem and - in the case of procfs - different <tt>d_release()</tt>
operations.  The necessary distinctions could easily be made in
per-superblock versions of these operations.  Do these cases justify the 5%
space cost?  Arguably not.
</p>
<h4>Directly embedded function pointers</h4>
<p>
Finally it is appropriate to reflect on the alternate pattern
mentioned at the start, where function pointers are stored directly in
the object rather than in a separate vtable structure.

This pattern can be seen in
<a href="http://lxr.linux.no/#linux+v2.6.39/include/linux/blkdev.h#L263"><tt>struct request_queue</tt></a>
which has nine function
pointers,
<a href="http://lxr.linux.no/#linux+v2.6.39/include/linux/efi.h#L251"><tt>struct efi</tt></a>
which has ten function pointers, and
<a href="http://lxr.linux.no/#linux+v2.6.39/include/net/sock.h#L238"><tt>struct sock</tt></a>
which has six function pointers.
</p><p>
The cost of embedded pointers is obviously space.  
When vtables are used, there is only one copy
of the vtable and multiple copies of an object (in most cases) so if
more than one function pointer is needed, a vtable would save space.

The cost of a vtable is an extra memory reference, though cache might
reduce much of this cost in some cases.  A vtable also has a cost of
flexibility.  When each object needs exactly the same set of operations
a vtable is good, but if there is a need to individually tailor some
of the operations for each object, then embedded function pointer can
provide that flexibility.  This is illustrated quite nicely by the
comment with &#34;zoom_video&#34; in <tt>struct pcmcia_socket</tt>
</p>
<pre>	/* Zoom video behaviour is so chip specific its not worth adding
	   this to _ops */
</pre><p>
So where objects are not very populous, where the list of function
pointers is small, and where multiple mixins are needed,
embedded function pointers are used instead of a separate vtable.
</p>
<h4>Method Dispatch Summary</h4>
<p>
If we combine all the pattern elements that we have found in
Linux we find that:
</p>
<blockquote>
<p>
Method pointers that operate on a particular type of object are
normally collected in a vtable associated directly with that
object, though they can also appear:
</p>
<ul>
<li> In a mixin vtable that collects related functionality which
    may be selectable independently of the base type of the
    object.
</li><li> In the vtable for a &#34;parent&#34; object when doing so avoids
    the need for a vtable pointer in a populous object
</li><li> Directly in the object when there are few method pointers,
    or they need to be individually tailored to the particular
    object.
</li></ul>
<p>
These vtables rarely contain anything other than function
pointers, though fields needed to register the object class can
be appropriate.  Allowing these function pointers to be NULL is
a common but not necessarily ideal technique for handling
defaults.
</p>
</blockquote>
<p>
So in exploring the Linux Kernel code we have found that even
though it is not written in an object-oriented language, it
certainly contains objects, classes (represented as vtables),
and even mixins.  It also contains concepts not normally
found in object-oriented languages such as delegating
object methods to a &#34;parent&#34; object.
</p><p>
Hopefully understanding these different patterns and the
reasons for choosing between them can lead to more uniform
application of the patterns across the kernel, and hence make
it easier for a newcomer to understand which pattern is being
followed.

In the second part of our examination of object
oriented patterns we will explore the various ways that 
data inheritance is achieved in the Linux kernel
and discuss the strengths and weaknesses of each approach so
as to see where each is most appropriate.
</p></div></div>
  </body>
</html>
