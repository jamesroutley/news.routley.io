<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://aoli.al/blogs/chrome-bug/">Original</a>
    <h1>Chrome Returns 206 when the Server Returns 403</h1>
    
    <div id="readability-page-1" class="page"><article>
  
  <section>
    <h2 id="postmortem">Postmortem</h2>
<p>It is a feature not a bug! I got detailed explanation from chrome developers which is very helpful. You may find the complete response in the <a href="https://issues.chromium.org/issues/390229583">bug ticket</a>. Also this blog post draws a lot of attention after I post it on Hackers News. You may find comments <a href="https://news.ycombinator.com/item?id=43244680">here</a>.</p>
<p><strong>Updates:</strong> I did know the people who replied my issue are not the developers as pointed out by a HN comment.</p>
<blockquote>
<p>I was also pretty surprised when the OP said ‚Äúthe Chromium team refused to use my server to reproduce the bug‚Äù, when the actual comments of the ticket were ‚Äúclone this repo and run my giant node app‚Äù and the tester‚Äôs response was ‚ÄúIt seems a bit difficult to set up an build environment to run the static server, could you provide a more minimal repro case?‚Äù. OP‚Äôs description of the tester‚Äôs reasonable concerns seems very unfair.</p></blockquote>
<p>And I would like to withdraw my statement about Chromium team refused to use my server to reproduce the bug. However, I do believing providing a place to allow users to showcase their weird servers is not a bad idea. Debugging and failure reproduction is always hard! I still think offering GCP credits to issue reporters is a practical approachüòÅ.</p>
<p>You may continue to read the original post if you want to learn an interesting debugging experience.</p>
<h2 id="original-post">Original Post</h2>
<p>Sorry for the clickbait, but it is true.</p>
<p>I was helping my partner debug an interesting bug in his fancy <a href="https://github.com/XiangpengHao/parquet-viewer/issues/7">parquet viewer</a>. The website crashes when a user tries to access S3.</p>
<p>So the symptom is that <a href="https://github.com/apache/opendal">OpenDAL</a> (one of the parquet viewer‚Äôs dependencies) crashes because it did not receive enough data from S3 storage.</p>
<img src="https://aoli.al/images/chrome-bug/parquet-viewer-bug.png"/>
<h2 id="my-initial-attempt">My Initial Attempt</h2>
<p>Initially, I thought this was a bug inside OpenDAL, so I tried compiling everything on my native machine, but the bug disappeared. This allowed me to narrow the bugs to all WASM-related components.</p>
<p>My goal was to find the first program location where the data is lost. Unfortunately, debugging the WASM code is not fun, and I have fallen back to print debugging. So I was doing the following manually, starting with parquet viewer:</p>
<ol>
<li>download and compile the project</li>
<li>insert debugging code to print the size of the data</li>
<li>check if data is already shorter than expected</li>
<li>if true, download and compile the library it used to fetch the data and go back to step 1</li>
</ol>
<p>I have gone through Paquet Viewer, OpenDAL, and reqwest and all the way to the standard library. This process wasn‚Äôt easy, especially since I needed to find the right location to insert my debug code. Fortunately, LLMs helped me greatly.</p>
<p>But to my surprise, the application received chopped data from the very beginning.</p>
<h2 id="my-second-attempt">My Second Attempt</h2>
<p>Having spent a day debugging nothing was frustrating, and I was questioning what had gone wrong. As a reflection, the main issue of my debugging process is that I set the wrong <strong>trust boundary</strong> at the very beginning. I was assuming Chrome was functioning correctly and jumped into the rabbit hole of debugging application code.</p>
<p>After removing the trust boundary, the first thing I did was verify what exactly Chrome had received from the server. We found some surprising results with our old friend Wireshark: the server returns 403 for the second request. And more things are going on:</p>
<p>My client sends two requests to the server and I‚Äôm using the equivalent fetch command to show them:</p>
<p>The first request has range <code>4-138724</code>:</p>
<div><pre tabindex="0"><code data-lang="js"><span><span><span>fetch</span>(<span>&#34;...&#34;</span>, {
</span></span><span><span>  <span>&#34;headers&#34;</span><span>:</span> {
</span></span><span><span>    <span>&#34;range&#34;</span><span>:</span> <span>&#34;bytes=4-138724&#34;</span>,
</span></span><span><span>  },
</span></span><span><span>  <span>&#34;body&#34;</span><span>:</span> <span>null</span>,
</span></span><span><span>  <span>&#34;method&#34;</span><span>:</span> <span>&#34;GET&#34;</span>,
</span></span><span><span>  <span>&#34;mode&#34;</span><span>:</span> <span>&#34;cors&#34;</span>,
</span></span><span><span>  <span>&#34;credentials&#34;</span><span>:</span> <span>&#34;omit&#34;</span>
</span></span><span><span>})
</span></span></code></pre></div><p>The server successfully sends the requested data back and replied 206, and the Wireshark confirms that my server indeed responds to 206.</p>
<p>For the second request, it becomes interesting. The second request has a range <code>4-1943507</code>:</p>
<div><pre tabindex="0"><code data-lang="js"><span><span><span>fetch</span>(<span>&#34;...&#34;</span>, {
</span></span><span><span>  <span>&#34;headers&#34;</span><span>:</span> {
</span></span><span><span>    <span>&#34;range&#34;</span><span>:</span> <span>&#34;bytes=4-1943507&#34;</span>,
</span></span><span><span>  },
</span></span><span><span>  <span>&#34;body&#34;</span><span>:</span> <span>null</span>,
</span></span><span><span>  <span>&#34;method&#34;</span><span>:</span> <span>&#34;GET&#34;</span>,
</span></span><span><span>  <span>&#34;mode&#34;</span><span>:</span> <span>&#34;cors&#34;</span>,
</span></span><span><span>  <span>&#34;credentials&#34;</span><span>:</span> <span>&#34;omit&#34;</span>
</span></span><span><span>})
</span></span></code></pre></div><p>However, when Chrome sends the request to the server Wireshark shows that the real request is:</p>
<div><pre tabindex="0"><code data-lang="js"><span><span><span>fetch</span>(<span>&#34;...&#34;</span>, {
</span></span><span><span>  <span>&#34;headers&#34;</span><span>:</span> {
</span></span><span><span>    <span>&#34;range&#34;</span><span>:</span> <span>&#34;bytes=138725-1943507&#34;</span>,
</span></span><span><span>  },
</span></span><span><span>  <span>&#34;body&#34;</span><span>:</span> <span>null</span>,
</span></span><span><span>  <span>&#34;method&#34;</span><span>:</span> <span>&#34;GET&#34;</span>,
</span></span><span><span>  <span>&#34;mode&#34;</span><span>:</span> <span>&#34;cors&#34;</span>,
</span></span><span><span>  <span>&#34;credentials&#34;</span><span>:</span> <span>&#34;omit&#34;</span>
</span></span><span><span>})
</span></span></code></pre></div><p>The range field is changed. This is because Chrome noticed that the first <code>4-138724</code> bytes are already cached, and therefore, it only needs to request the rest part. Hmm, this sounds a great optimization to save data! But when the server responds, it becomes chaotic. Let‚Äôs first check what Chrome shows in the response:</p>
<img src="https://aoli.al/images/chrome-bug/chrome-response.png"/>
<p>Chrome says it has successfully gotten the data and even indicates bytes <code>4-1943507</code> in the response header. But in the response viewer, it shows that the response only has 138720 bytes of data!</p>
<img src="https://aoli.al/images/chrome-bug/chrome-data.png"/>
<p>This is crazy. Where did the rest of the data go? Now, if we go back to Wireshark, it will tell us that the second request to the server failed with 403 (it is another story why the server returns 403 for the second request)! However, Chrome still returns 206 to the application with only partial data.</p>
<h2 id="report-to-chromium-team">Report to Chromium Team</h2>
<p>This seems to be a bug in Chrome, so I decided to report it to the developers. To make their lives easier, I also created a buggy server to mimic the behavior I have encountered.</p>
<p>Here is the issue: <a href="https://issues.chromium.org/issues/390229583">https://issues.chromium.org/issues/390229583</a>. You may follow the steps to reproduce the bug if you are interested and I promise, it will not take more than 10 minutes.</p>
<p>Initially, I thought the developers would immediately acknowledge the issue and then fix it. But to my surprise, the issue was open for two months, and eventually, they thought it was a feature, not a bug.</p>
<img src="https://aoli.al/images/chrome-bug/feature-not-bug.png" width="250"/>
<p>After the issue was submitted, <del>the Chromium team refused to use my server to reproduce the bug and asked me to submit</del> a <a href="%5Bhttps://www.chromium.org/for-testers/providing-network-details/%5D(https://www.chromium.org/for-testers/providing-network-details/)">network</a> log while reproducing it. So I did, out of curiosity. The Netlog looks scary because it not only contains the traffic while I reproduced the bug but also 1) all traffic from the Chrome plugins and 2) many websites that I have browsed before but haven‚Äôt visited during the recording. While I promise there is nothing in my browser history üòâ. But I still don‚Äôt share it with public. So when I share my netlog, I added a restriction to the file.</p>
<img src="https://aoli.al/images/chrome-bug/restriction.png" width="400"/>
<p>But to my surprise, this blocks the Chromium team from accessing the file too. After all the back and forth, the Chromium team finally understands the issue. But they think this is a feature, not a bug, and you may find the complete response in the <a href="https://issues.chromium.org/issues/390229583">bug ticket</a>.</p>
<blockquote>
<p>All we‚Äôre saying is that this is how the range requests for partially-cached content in Chrome interact with the cache and it isn‚Äôt likely to change because there aren‚Äôt any really good ways to change the behavior that won‚Äôt also break existing applications. The existing behavior is at least consistent and can be worked with in application code by requesting the missing part of the range after the 2nd request completes (at which point you should get a 403 since none of the range overlaps with what is in cache).</p></blockquote>
<p>What a bug or a feature! I think I will probably stop tracking this issue since I‚Äôm working on neither web technologies nor browsers. I‚Äôm just a fan of tracking down and solving those elusive bugs. I opened an issue in <a href="https://github.com/apache/opendal/issues/5689">OpenDAL</a> because if Chrome is not going to fix it, they may need to fix it.</p>
<p>Also, maybe a lesson for me is that finding the right <strong>trust boundary</strong> can significantly speed up debugging!</p>

  </section>

  
</article></div>
  </body>
</html>
