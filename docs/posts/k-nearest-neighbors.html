<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.pinecone.io/learn/k-nearest-neighbor/">Original</a>
    <h1>K-Nearest Neighbors</h1>
    
    <div id="readability-page-1" class="page"><div><div><div><p>Have you ever heard of the Gestalt Principles? These are part of a theory of perception that examines how humans group similar objects in order to interpret the complex world around them.</p><p>According to the Gestalt principle of proximity, elements that are closer together are perceived to be more related than elements that are farther apart, helping us understand and organize information faster and more efficiently.</p><p><img src="https://d33wubrfki0l68.cloudfront.net/b299239fd6acc22a98378d127f543cc7bbf329eb/600e0/images/knn-proximity.jpg" alt="KNN Proximity"/>
<small>Our brains perceive these sets of closely placed elements as groups. Proximity is essential to our perception. Source: <a href="https://uxmisfit.com/2019/04/23/ui-design-in-practice-gestalt-principles/">UXMISFIT</a></small></p><p>Likewise, in Machine Learning, the concepts of proximity and similarity are tightly linked. Meaning that the closer two data points are, the more similar they are to one another than to other data points. The content recommendation systems you use every day for movies, texts, songs, and more, rely on this principle.</p><p>One Machine Learning algorithm that relies on the concepts of proximity and similarity is <strong>K-Nearest Neighbor (KNN)</strong>. KNN is a supervised learning algorithm capable of performing both classification and regression tasks.</p><hr/><p><strong>Note: As you’ll see in this article, doing KNN-search or even ANN-search at scale can be slow and expensive. That’s why we made <a href="https://www.pinecone.io/">Pinecone</a> — an API for fast, fresh, filtered, and low-cost ANN search at any scale.</strong></p><hr/><p>As opposed to unsupervised learning — where there is no output variable to guide the learning process and where data is explored by algorithms to find patterns — in supervised learning your existing data is already labeled and you know which behavior you want to predict in the new data you obtain.</p><p>The KNN algorithm predicts responses for new data (testing data) based upon its similarity with other known data (training) samples. It assumes that data with similar traits sit together and uses distance measures at its core.</p><p>KNN belongs to the class of non-parametric models as it doesn’t learn parameters from the training dataset to come up with a discriminative function to predict new unseen data. It operates by memorizing the training dataset.</p><p>Given its flexibility, KNN is used in industries such as:</p><ul><li>Agriculture: to perform climate forecasting, estimating soil water parameters, or predicting crop yields.</li><li>Finance: to predict bankruptcies, understanding and managing financial risk.</li><li>Healthcare: to identify cancer risk factors, predict heart attacks, or analyze gene expression data.</li><li>Internet: using clickstream data from websites, to provide automatic recommendations to users on additional content.</li></ul><h2 id="distance-measures">Distance Measures</h2><p>How near are two data points? It depends on how you measure it, and in Machine Learning, there isn’t just one way of measuring distances.</p><p>A distance measure is an objective score that summarizes the relative difference between two objects in a problem domain and plays an important role in most algorithms. Some of the main measures are:</p><ul><li><strong>Euclidean</strong> is probably the most intuitive one and represents the shortest distance between two points. It’s calculated using the well-known Pythagorean theorem. Conceptually, it should be <a href="https://aigents.co/data-science-blog/publication/distance-metrics-for-machine-learning">used whenever we are comparing observations with continuous features</a>, like height, weight, or salaries. This distance measure is often the “default” distance used in algorithms like KNN.</li></ul><p><img src="https://d33wubrfki0l68.cloudfront.net/5ebf9b4f952c98e2222efdd0c333c724454f6332/67d06/images/knn-euclidean-distance.png" alt="Euclidean distance"/>
<small>Euclidean distance between two points. Source: <a href="https://vitalflux.com/different-types-of-distance-measures-in-machine-learning/">VitalFlux</a></small></p><ul><li><strong>Manhattan</strong> is used to estimate the distance to get from one data point to another if a grid-like path is taken. Unlike Euclidean distance, the Manhattan distance calculates the sum of the absolute values of the difference of the coordinates of two points. This way, instead of estimating a straight line between two points, we “walk” through available paths. The Manhattan distance is useful when our observations are distributed along a grid, like in chess or city blocks (when the <a href="https://aigents.co/data-science-blog/publication/distance-metrics-for-machine-learning">features of our observations are entire integers</a> with no decimal parts).</li></ul><p><img src="https://d33wubrfki0l68.cloudfront.net/b6dbb0cdc34043e07189d91fe6c8bc6ddecf37fd/c2b0b/images/knn-manhattan-distance.png" alt="Manhattan distance"/>
<small>Manhattan distance between two points A and B. Source: <a href="https://vitalflux.com/different-types-of-distance-measures-in-machine-learning/">VitalFlux</a></small></p><ul><li><strong>Cosine</strong> is employed to calculate similarity between two <a href="https://www.pinecone.io/learn/vector-embeddings/">vectors</a>. Through this measure, data objects in a dataset are treated as vectors, and similarity is calculated by the cosine of the angle between two vectors. Vectors which are most similar will have a value of 0 degrees between them (the value of cos = 0 is 1), while vectors that are most dissimilar will have a value of -1. The smaller the angle, the higher the similarity. This different perspective about distance can provide novel insights which might not be found using the previous distance metrics.</li></ul><p><img src="https://d33wubrfki0l68.cloudfront.net/3bcc6095326fce3e2d71faf9da93d5deb930392d/da868/images/knn-cosign-vectors.png" alt="Cosign vectors"/>
<small>Two cosine vectors that are aligned in the same orientation will have a similarity measurement of 1, whereas two vectors aligned perpendicularly will have a similarity of 0. If two vectors are diametrically opposed, meaning they are oriented in exactly opposite directions (i.e. back-to-back), then the similarity measurement is -1. Source: <a href="https://deepai.org/machine-learning-glossary-and-terms/cosine-similarity">DeepAI</a></small></p><ul><li><strong>Hamming</strong> represents the number of points at which two corresponding pieces of data can be different. While comparing two vectors of equal length, Hamming distance is the number of bit positions in which they differ. This metric is generally used when comparing texts or binary vectors.</li></ul><p><img src="https://d33wubrfki0l68.cloudfront.net/b53863611fbfa44c80f3e6228a7c19dbf45788cc/4d88f/images/knn-hamming-distance.png" alt="Hamming distance"/>
<small>How many bits are different between Data A and Data B? You can easily figure out the difference just by comparing bit by bit. In this case, you would figure out only one bit difference , ande: that’s the Hamming difference between both vectors. Source: <a href="https://www.sharetechnote.com/html/Handbook_Communication_HammingDistance.html">ShareTechnote</a></small></p><p>Here is a <a href="https://www.liebertpub.com/doi/10.1089/big.2018.0175">complete review</a> of different distance measures applied to KNN.</p><h2 id="how-knn-works">How KNN works</h2><p>KNN performs classification or regression tasks for new data by calculating the distance between the new example and all the existing examples in the dataset. But how?</p><p>Here’s the secret: The algorithm stores the entire dataset and classifies each new data point based on the existing data points that are similar to it. KNN makes predictions based on the training or “known” data only.</p><p>After the user defines a distance function, like the ones we mentioned earlier, KNN calculates the distance between data points in order to find the closest data points from our training data for any new data point. The existing data points closest to the new data point using the defined distance will become the “k-neighbors”. For a classification task, KNN will use the most frequent of all values from the k-neighbors to predict the new data label. For a regression task, the algorithm will use the average of all values from the k-neighbors to predict the new data value.</p><video autoplay="" loop="" muted="" playsinline="">
  <source src="https://d33wubrfki0l68.cloudfront.net/fd08ab24b0af82f034db86b1079c713be3ef681f/3f57c/images/knn.mp4" type="video/mp4"/></video><p><small>In a classification task with K=3, an unlabelled data point is labeled as pink due to the majority vote of the 3 most similar labeled examples. Source: <a href="https://towardsdatascience.com/beginners-guide-to-k-nearest-neighbors-in-r-from-zero-to-hero-d92cd4074bdb">Towards Data Science</a></small></p><p>All KNN does is store the complete dataset, and without doing any calculation or modeling on top of it, measure the distance between the new data point and its closest data points. For this reason, and since there’s not really a learning process happening, KNN is called a “lazy” algorithm (as opposed to “eager” algorithms like Decision Trees that build generalized models before performing predictions on new data points).</p><h2 id="how-to-find-k">How to find k?</h2><p>With KNN, in order to make a classification/regression task, you need to define a number of neighbors, and that number is given by the parameter “k”. In other words, “k” determines the number of neighbors the algorithm looks at when assigning a value to any new observation.</p><p>This number can go from 1 (in which case the algorithm only looks at the closest neighbor for each prediction) to the total number of data points of the dataset (in which case the algorithm would predict the majority class of the complete dataset).</p><p><img src="https://d33wubrfki0l68.cloudfront.net/e12ea9a13b7f7b2c4b9abf54b4f132a2e1d4549b/35d1a/images/knn-k.png" alt="Finding K"/>
<small>In the above example, if k=3 then the new data point will be classified as B. But if k=6, then it will be classified as A because the majority of points are from class A. Source: <a href="https://www.sharetechnote.com/html/Handbook_Communication_HammingDistance.html">ShareTechnote</a></small></p><p>So how can you know the optimum value of “k”? We can decide based on the error calculation of a training and testing set. Separating the data into training and test sets allows for an objective model evaluation.</p><p>One popular approach is testing different numbers of “k” and measuring the resulting error, choosing the “k” value at which an increase will cause a very small decrease in the error sum, while a decrease will sharply increase the error sum. This point that defines the optimal number is known as the “elbow point”.</p><p><img src="https://d33wubrfki0l68.cloudfront.net/acb6d99fd48dbaec7ae53e9d36e85877db61a392/c8cf4/images/knn-error-rates.png" alt="Error rates vs K value"/>
<small>The “k” value best suited for a dataset is selected by using the error rate (this is, the difference between the real and predicted values). After a certain point, the error rate becomes almost constant. Source: <a href="https://ai.plainenglish.io/k-nearest-neighbors-knn-algorithm-for-machine-learning-ab6f17df4a7f">AI in Plain English</a></small></p><p>Above, we can see that after “k” &gt; 23, the error rate stabilizes and becomes almost constant. For this reason, “k” = 23 seems to be the optimal value.</p><p>Another alternative for deciding the value of “k” is using grid search to find the best value. Grid search is a process that searches exhaustively through a specified numerical space for the algorithm to optimize a given parameter (which in this case is the error rate). Tools like Python’s <a href="https://realpython.com/knn-python/">GridSearchCV</a> can automate the fit of KNN on the training set while validating the performance on the testing set in order to identify the optimal value of “k”.</p><h2 id="why-knn">Why KNN</h2><p>In contrast to many other Machine Learning algorithms, KNN is simple to implement and intuitive. It’s flexible (has many distance metrics to choose from), evolves as new data is revealed, and has one single hyperparameter to tune (the value of “k”). It can detect linear or nonlinear distributed data, and since it is non-parametric, there are no assumptions to be met to implement it (i.e. <a href="https://www.fromthegenesis.com/pros-and-cons-of-k-nearest-neighbors/">as opposed to linear regression models</a> that have plenty of assumptions to be met by the data before they can be employed).</p><p>Like every algorithm, it has some downsides. The choice of “k” and the distance metric are critical to its performance and need to be carefully tuned. KNN is also very sensitive to outliers and imbalanced datasets. Also, since all the algorithm does is store the training data to perform its predictions, the memory needs grow linearly with the number of data points you provide for training.</p><p>KNN is definitely an algorithm worth learning. Whether it’s for dealing with <a href="https://www.analyticsvidhya.com/blog/2021/05/20-questions-to-test-your-skills-on-k-nearest-neighbour/">missing data</a> or <a href="https://meesho.io/blog/predicting-visual-similarities-in-product-images-using-knn">predicting image similarity</a>, this is a tool that you can’t miss!</p></div></div></div></div>
  </body>
</html>
