<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lambdaland.org/posts/2024-11-21_powerful_or_safe_languages/">Original</a>
    <h1>Should programming languages be safe or powerful?</h1>
    
    <div id="readability-page-1" class="page"><article>
  
  
  <h5>21 Nov 2024</h5>



  

  
  
  



<p>Should a programming language be powerful and let a programmer do a lot, or should it be safe and protect the programmer from bad mistakes? Contrary to what the title insinuates, these are <em>not</em> diametrically opposed attributes. Nevertheless, this is the mindset that underlies notions such as, “macros, manual memory management, etc. are power tools—they’re not supposed to be safe.” If safety and power are not necessarily opposed, why does this notion persist?</p>
<p>The problem—I think—is that historically you <em>did</em> have to trade safety for certain kinds of power: if you wanted to write a high-performance device driver, C—with all its unsafe behavior—was your only option. This founded the idea that the “power tools” of the industry were fundamentally dangerous.</p>
<p>There’s a few things wrong with this though:</p>
<ol>
<li>
<p><strong>Power is relative to the domain of interest.</strong> Both Haskell and C are powerful, but in completely different ways. So, when judging whether an aspect of a language is powerful or not, consider its application.</p>
</li>
<li>
<p><strong>Expressive languages get you power without sacrificing safety.</strong> New advances in programming language research have found ways to express problem domains more precisely. This means that we have less and less reason to breach safety and reach into the unsafe implementation details to get our work done.</p>
</li>
<li>
<p><strong>It’s good to add safety to power tools.</strong> A safe power tool is more trustworthy than an unsafe one. This holds for real-world tools: I will never use a table saw without a functioning saw stop.</p>
</li>
</ol>
<p>Specifically in the case of macros, there’s been an evolution from powerful-but-unsafe procedural macros in Lisp to safe-but-less-powerful pattern macros in Scheme, and finally to <strong>powerful-and-safe</strong> macros in Racket.</p>
<p>More safety means higher reliability—something that everyone wants. And with advances in making languages more expressive, you can have a language perfectly suited to a particular domain without sacrificing safety.</p>
<h2 id="what-makes-a-language-powerful">
  What makes a language powerful?
  <a href="#what-makes-a-language-powerful">#</a>
</h2>
<p>A language that lets you do more of what you want to do is more powerful than a language where you can’t do what you want. But what does “what you want to do” encompass? If you want to write device drivers, then C is great for you. However, C is not as expressive in some of the ways that, say, Haskell is. For example, in Haskell, I can write lazy, recursive definitions. Here’s a list of all<label for="sn1"></label>

<span>
Yes, <em>all</em> the Fibonacci numbers. Haskell is lazy; this will compute as many as you ask for.
</span>
the Fibonacci numbers:</p>
<div><pre tabindex="0"><code data-lang="haskell"><span><span><span>fibs</span> <span>=</span> <span>0</span> <span>:</span> <span>1</span> <span>:</span> zipWith <span>(</span><span>+</span><span>)</span> fibs <span>(</span>tail fibs<span>)</span>
</span></span></code></pre></div><p>Before you tell me that that’s just a useless cute trick, I actually had to use this when I was building the balancing algorithm in my rope data structure for <a href="https://codeberg.org/ashton314/ysue">my text editor written in Haskell</a>. Haskell is incredibly powerful in an <em>expressive</em> sense: a single line of code can elegantly capture a complicated computation.</p>
<div>
<blockquote>
<p>The purpose of abstraction is not to be vague, but to create a new semantic level in which one can be absolutely precise.</p>

</blockquote>
</div>
<p>Power is closely related to the domain of interest: a language is powerful in a particular realm of problems. C is powerful for working with memory directly. Conversely, Haskell or Racket is more powerful than C in pretty much every other domain because these languages give the user tremendous ability to <em>match the program to the domain</em>. This is a meta-power that sets high-level languages apart from lower-level ones.</p>
<p>Safe languages can be just as powerful as their unsafe counterparts—in many cases, they are <em>more</em> powerful because the abstractions they create better fit the domain. Whenever a tradeoff between power and safety must be made, that is a sign that the language is not the right fit for the domain.</p>
<p>Consider how immutability gives you <em>local reasoning power</em>. At one of my industry jobs, our codebase was a mixture of Ruby and Elixir. Both are safe languages, but Elixir is immutable. When I was working on some Elixir code, I could read:</p>
<div><pre tabindex="0"><code data-lang="elixir"><span><span>user <span>=</span> get_user<span>(</span>session<span>)</span>
</span></span><span><span>name <span>=</span> get_user_name<span>(</span>user<span>)</span>
</span></span><span><span>do_something_else<span>(</span>user<span>)</span>
</span></span></code></pre></div><p>and I didn’t have to worry about <code>user</code> getting modified in the call to <code>get_user_name</code>. To understand the output of this function, I didn’t have to worry too much about the implementation of <code>get_user_name</code>.</p>
<p>In contrast, if you did the same sort of thing in Ruby:</p>
<div><pre tabindex="0"><code data-lang="ruby"><span><span>user <span>=</span> get_user<span>(</span>session<span>)</span>
</span></span><span><span><span>name</span> <span>=</span> user<span>.</span>get_name<span>()</span>
</span></span><span><span>user<span>.</span>do_something_else<span>()</span>
</span></span></code></pre></div><p>the <code>get_name</code> method <em>could</em> do something sneaky like set name to <code>&#34;blank&#34;</code> if it didn’t exist.<label for="sn2"></label>

<span>
You might think, “well, just document that behavior.” Now I need to read the documentation of <em>every</em> function I encounter—I might as well go read the code to be sure the documentation isn’t out of date. Local reasoning means to understand what <code>do_something_else</code> is passed, I don’t have to worry <em>in the first place</em> if <code>get_name</code> will do somethig to the result of <code>get_user</code>.
</span>
In this case, I <em>did</em> have to understand what every method call did to understand the function. This made it harder to track down errors because I had to account for all the side effects that <em>could</em> happen at every method call.</p>
<p>Certain things like immutability might seem constraining, but <a href="https://www.youtube.com/watch?v=GqmsQeSzMdw">constraints can liberate you</a> by allowing you to rely on particular behaviors. Elixir doesn’t let you modify things in-place, but you can rely on this, which makes understanding and composing code easier. Haskell forces you to express side-effects in the type system, but this lets you know that calling a function with a signature like <code>String → Int</code> won’t do any IO or throw an exception. Rust doesn’t have <code>null</code> like in Java, but you know when you get a pointer, you can safely dereference it and you don’t have to do all the null checking that you have to do in Java.</p>
<h2 id="case-study-macros-in-lisp-scheme-and-racket">
  Case study: macros in Lisp, Scheme, and Racket
  <a href="#case-study-macros-in-lisp-scheme-and-racket">#</a>
</h2>
<p>The evolution of syntax macros in Lisp, Scheme, and Racket provide an interesting real-world instance of how safety and power can start off as a trade-off, but with better language design, become complimentary.</p>
<h3 id="lisp-macros-unsafe-but-powerful">
  Lisp macros: unsafe but powerful
  <a href="#lisp-macros-unsafe-but-powerful">#</a>
</h3>
<p>I don’t have the space here to do a deep dive into Lisp macros, but here’s the short of it: Lisp macros are just functions that receive code as data. This code is represented as nested lists of symbols. All a macro needs to do is return a <em>new</em> list of symbols that will be spliced right into the call site.</p>
<div><pre tabindex="0"><code data-lang="lisp"><span><span><span>(</span><span>defmacro</span> my-or <span>(</span>thing1 thing2<span>)</span>
</span></span><span><span>  <span>`</span><span>(</span><span>let</span> <span>((</span>tmp <span>,</span>thing1<span>))</span>
</span></span><span><span>     <span>(</span><span>if</span> tmp tmp <span>,</span>thing2<span>)))</span>
</span></span><span><span>
</span></span><span><span><span>;; calling the macro</span>
</span></span><span><span><span>(</span>my-or <span>1</span> <span>2</span><span>)</span>
</span></span><span><span><span>;; expands to</span>
</span></span><span><span><span>(</span><span>let</span> <span>((</span>tmp <span>1</span><span>))</span>
</span></span><span><span>  <span>(</span><span>if</span> tmp tmp <span>2</span><span>))</span>  <span>;=&gt; 1</span>
</span></span></code></pre></div><p>The problem with this is that these macros are <em>unhygienic</em>: if I introduce a new variable, as I did with <code>tmp</code> in <code>my-or</code>, that is just a bare symbol that can be inadvertently captured producing unexpected output:</p>
<div><pre tabindex="0"><code data-lang="lisp"><span><span><span>(</span><span>let</span> <span>((</span>tmp <span>99</span><span>))</span> <span>(</span>my-or <span>nil</span> tmp<span>))</span>
</span></span><span><span><span>;; expands to</span>
</span></span><span><span><span>(</span><span>let</span> <span>((</span>tmp <span>99</span><span>))</span> <span>(</span><span>let</span> <span>((</span>tmp <span>nil</span><span>))</span> <span>(</span><span>if</span> tmp tmp tmp<span>)))</span> <span>;=&gt; nil</span>
</span></span></code></pre></div><p>This is very bad! To use a macro safely, you need to be sure that it’s not introducing variables that you might accidentally capture. Lisp provides a mechanism<label for="sn3"></label>

<span>
Lisp has a function called <code>gensym</code> which makes a fresh symbol for you to use. Some other languages such as <a href="https://docs.julialang.org/en/v1/base/base/#Base.gensym">Julia</a> have a <code>gensym</code> function; <code>gensym</code> is a poor substitute for proper hygiene.
</span>
to avoid some of the pitfalls with variable capture, but that’s not the end of the danger. If I have a macro that expands to a call to a function, e.g. <code>printf</code>, I would expect this to be the <code>printf</code> in scope at the time I defined the macro. However, this might not be the case—a user might inadvertently redefine a function, and then the macro would not behave in the expected way.</p>
<h3 id="scheme-macros-safe-but-less-powerful">
  Scheme macros: safe but less powerful
  <a href="#scheme-macros-safe-but-less-powerful">#</a>
</h3>
<p>Scheme has a faculty called <code>syntax-rules</code>, which lets you define transformations between a pattern and a template:</p>
<div><pre tabindex="0"><code data-lang="scheme"><span><span><span>(</span><span>define-syntax </span>my-or
</span></span><span><span>  <span>(</span><span>syntax-rules </span><span>()</span>
</span></span><span><span>    <span>((</span><span>_</span> thing1 thing2<span>)</span> <span>(</span><span>let </span><span>((</span><span>tmp</span> thing1<span>))</span>
</span></span><span><span>                         <span>(</span><span>if </span>tmp tmp thing2<span>)))))</span>
</span></span></code></pre></div><p><a href="https://doc.rust-lang.org/book/ch19-06-macros.html">Rust’s <code>macro_rules!</code> form</a> is essentially <code>syntax-rules</code> from Scheme, but a little fancier with some syntax classes like <code>:expr</code> and such.</p>
<p>This is safe; the examples from the Lisp run as expected:</p>
<div><pre tabindex="0"><code data-lang="scheme"><span><span><span>(</span><span>my-or</span> <span>1</span> <span>2</span><span>)</span>                      <span>;=&gt; 1</span>
</span></span><span><span><span>(</span><span>my-or</span> <span>#f</span> <span>42</span><span>)</span>                    <span>;=&gt; 42</span>
</span></span><span><span><span>(</span><span>let </span><span>((</span><span>tmp</span> <span>99</span><span>))</span> <span>(</span><span>my-or</span> <span>#f</span> tmp<span>))</span>  <span>;=&gt; 99</span>
</span></span></code></pre></div><p>However, we’ve lost some of the power because we can only define transformations between templates. We can’t, for example, write a macro that does some deep inspection of the code and makes decisions on how to expand. Furthermore, there’s no way for us to intentionally break hygiene when we really want to.</p>
<h3 id="racket-macros-the-best-of-both-worlds">
  Racket macros: the best of both worlds
  <a href="#racket-macros-the-best-of-both-worlds">#</a>
</h3>
<p>Racket resolves the dilemma between having to choose between powerful Lisp-like procedural macros, and safe Scheme-like hygienic macros by giving us fully hygienic procedural macros! I have <a href="https://lambdaland.org/posts/2023-10-17_fearless_macros/">another blog post discussing macros in Lisp, Scheme, and Racket</a> and I go into some detail about the evolution of those macro systems.</p>

<p>The upshot of it is that Racket uses a combination of features (scope sets, syntax objects, etc.) to give the user a richer way of specifying syntax than simple dumb lists of symbols. This avoids inadvertent variable capture as well as keeps function references lined up nicely. However, macros can still do arbitrary computation, which means that we’re not constrained in the way that the pattern-transformation macros in Scheme are.</p>
<p>And just to prove that Racket is just as powerful as Common Lisp, here’s the classic <code>aif</code> macro:</p>
<div><pre tabindex="0"><code data-lang="racket"><span><span><span>#lang </span><span>racket</span>
</span></span><span><span><span>(</span><span>require</span> racket/stxparam syntax/parse/define<span>)</span>
</span></span><span><span>
</span></span><span><span><span>(</span>define-syntax-parameter it
</span></span><span><span>  <span>(</span><span>lambda</span> <span>(</span>stx<span>)</span>
</span></span><span><span>    <span>(</span><span>raise-syntax-error</span> <span>(</span><span>syntax-e</span> stx<span>)</span>
</span></span><span><span>                        <span>&#34;can only be used inside aif&#34;</span><span>)))</span>
</span></span><span><span>
</span></span><span><span><span>(</span><span>define-syntax</span> <span>(</span>aif stx<span>)</span>
</span></span><span><span>  <span>(</span>syntax-parse stx
</span></span><span><span>    <span>[(</span><span>_</span> test tcase fcase<span>)</span>
</span></span><span><span>     <span>#&#39;</span><span>(</span><span>let</span> <span>([</span>tmp test<span>])</span>
</span></span><span><span>         <span>(</span><span>if</span> tmp
</span></span><span><span>             <span>(</span>syntax-parameterize
</span></span><span><span>                 <span>([</span>it <span>(</span><span>make-rename-transformer</span> <span>#&#39;</span>tmp<span>)])</span>
</span></span><span><span>               tcase<span>)</span>
</span></span><span><span>             fcase<span>))]))</span>
</span></span><span><span>
</span></span><span><span><span>(</span>aif <span>41</span> <span>(</span><span>+</span> it <span>1</span><span>)</span> <span>&#39;</span><span>whatever</span><span>)</span> <span>;=&gt; 42</span>
</span></span><span><span>it                          <span>;error: it: can only be used inside aif</span>
</span></span></code></pre></div><p>This example is inspired by Greg Hendershott’s fabulous tutorial <a href="https://www.greghendershott.com/fear-of-macros/index.html"><em>Fear of Macros</em></a>. The <code>define-syntax-parameter</code> bit lets us introduce new bindings <em>intentionally</em>, whilst still keeping us from accidental breaches of macro hygiene.</p>
<p>Consequentially, <strong>Racket’s macro system is far more useful than Lisp or Scheme’s systems, and this because of Racket’s safety and expressiveness.</strong> You can actually build trustworthy systems on top of Racket’s macro system because you’re not constantly foot-gunning yourself with hygiene malfunctions, and the macros are expressive enough to do some <a href="https://lambdaland.org/posts/2023-08-14_types_with_macros/">rather complicated things</a>.</p>
<h2 id="towards-greater-safety-and-reliability">
  Towards greater safety and reliability
  <a href="#towards-greater-safety-and-reliability">#</a>
</h2>
<p>Safe systems let us build software that is more capable and more reliable. <strong>Unsafe power is something to improve, not grudgingly accept—and much less defend as somehow desirable.</strong> Languages like Rust and Zig have made systems programming immune to whole hosts of errors by being more expressive than C, and languages like Racket are leading the way in making metaprogramming more useful reliable and less like dark magic.</p>
<h2 id="further-reading">
  Further reading
  <a href="#further-reading">#</a>
</h2>
<p>If you want to learn more about writing macros in Racket, check out <a href="https://beautifulracket.com/"><em>Beautiful Racket</em></a> by Matthew Butterick and <a href="https://www.greghendershott.com/fear-of-macros/index.html"><em>Fear of Macros</em></a> by Greg Hendershott.</p>
<p>I highly recommend listening Runar Bjarnason’s talk at Scala World, <a href="https://www.youtube.com/watch?v=GqmsQeSzMdw"><em>Constraints Liberate, Liberties Constrain</em></a>, wherein he discusses how constraining one part of a system can open up freedoms of later components that build on that constrained part.</p>
</article></div>
  </body>
</html>
