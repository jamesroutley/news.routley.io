<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.spatters.ca/mma-matmul">Original</a>
    <h1>Implementing a fast Tensor Core matmul on the Ada Architecture</h1>
    
    <div id="readability-page-1" class="page"><div aria-label="Content">
      <div>
        <article>

  

  <div>
    <p>Using tensor cores is a prerequisite to get anywhere near peak performance matrix multiplication on NVIDIA GPUs from Volta onwards.</p>

<p>In this post we work through the process of developing an efficient Tensor Core matrix multiplication kernel targeting the Ada architecture. We start with a naive implementation and by incorporating techniques used in CUTLASS<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" rel="footnote">1</a></sup>, finish with a kernel that matches cuBLAS performance (on one particular problem specification):</p>

<table>
  <thead>
    <tr>
      <th>Kernel</th>
      <th>Execution Time</th>
      <th>TFLOP/s    </th>
      <th>% cuBLAS    </th>
      <th>% 4090 peak          </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>cublasGemmEx</td>
      <td>895 us</td>
      <td>153.6</td>
      <td>100%</td>
      <td>93.0%</td>
    </tr>
    <tr>
      <td>Kernel 1.0: Naive mma</td>
      <td>4680 us</td>
      <td>29.4</td>
      <td>19.1%</td>
      <td>17.8%</td>
    </tr>
    <tr>
      <td>Kernel 1.1: Naive + 2x tiling</td>
      <td>2400 us</td>
      <td>57.3</td>
      <td>37.3%</td>
      <td>34.7%</td>
    </tr>
    <tr>
      <td>Kernel 2.0: Permuted shmem</td>
      <td>1080 us</td>
      <td>127.3</td>
      <td>82.9%</td>
      <td>77.0%</td>
    </tr>
    <tr>
      <td>Kernel 2.1: Permuted shmem + register tweak</td>
      <td>1030 us</td>
      <td>133.4</td>
      <td>86.9%</td>
      <td>80.8%</td>
    </tr>
    <tr>
      <td>Kernel 3.0: N-stage async pipeline</td>
      <td>1000 us</td>
      <td>137.4</td>
      <td>89.5%</td>
      <td>83.2%</td>
    </tr>
    <tr>
      <td>Kernel 3.1: N-stage + 4x tiling</td>
      <td>895 us</td>
      <td>153.6</td>
      <td>100%</td>
      <td>93.0%</td>
    </tr>
  </tbody>
</table>

<p>In the process we’ll learn about the <code>mma</code>, <code>ldmatrix</code> and <code>cp.async</code> PTX instructions, how CUTLASS’s permuted shared memory layout avoids bank conflicts and how to set up an n-stage global to shared memory pipeline. The code is written as simply as possible: the aim is ease of understanding rather than generality or robustness.</p>

<p>As may be clear already, this post was heavily inspired by Simon Boehm’s great worklog on optimizing a CUDA matmul kernel<sup id="fnref:8" role="doc-noteref"><a href="#fn:8" rel="footnote">2</a></sup>.</p>

<h2 id="problem-definition">Problem Definition</h2>
<p>We’ll focus on one particular problem shape: M=N=K=4096, for <code>fp16</code> A/B and <code>fp32</code> C/D. This operation is <code>2*4096^3 = 137.4 GFLOP</code><sup id="fnref:2" role="doc-noteref"><a href="#fn:2" rel="footnote">3</a></sup> (conventional to count one FMA as 2 FLOP) and the peak <code>fp16/32</code> throughput of the RTX 4090 is 165.2 TFLOP/s<sup id="fnref:6" role="doc-noteref"><a href="#fn:6" rel="footnote">4</a></sup>, so the lower bound on kernel execution time is ~830 us.</p>

<p>We can use the peak throughput number to deduce how many cycles one Tensor Core instruction takes to complete (latency). All our kernels will use the PTX <code>m16n8k16</code> <code>mma</code> instruction, this is the largest Tensor Core matmul supported on Ada so it’s reasonable to assume the peak throughput is obtained using this instruction.</p>

<p>The m16n8k16 operation is <code>2*16*8*16=4096</code> FLOPS, and there are 512 Tensor Cores on the RTX 4090, hence computing one mma on all Tensor Cores gives 2,097,152 FLOPS. Given the peak throughput of 165.2 TFLOPS/s at the boost clock of 2520 MHz, it must take 12.7 ns = 32 cycles for the <code>m16n8k16</code> <code>mma</code> operation to complete. This is roughly consistent with empirical benchmarks<sup id="fnref:7" role="doc-noteref"><a href="#fn:7" rel="footnote">5</a></sup>.</p>

<p>Our problem shape of M=N=K=4096 requires 256x512x256 = 33,554,432 individual m16n8k16 <code>mma</code> instructions, which is 65,536 card-wide waves of <code>mma</code>s. Hence in the best case, with no cycles stalled waiting for input, the minimum number of cycles this will take is 65,636 * 32 = 2,097,152, which is 832 us at the boost clock of 2520 MHz. Note this agrees with the number computed using peak throughput by definition as we computed the 32 cycle latency from the throughput.</p>

<h2 id="benchmarking-setup">Benchmarking Setup</h2>
<p>As a baseline for performance we use the cuBLAS <code>cublasGemmEx</code> API with <code>fp16</code> inputs and<code>fp32</code> accumulation. This performs a <code>M=N=K=4096</code> matrix multiply in 895 us which is a throughput of 153.6 TFLOPS/s, 93.0% of the RTX 4090’s peak.</p>

<p>How to accurately time CUDA kernel execution could fill an entire post but in summary either CUDA events or nsight-compute give broadly consistent results if you first lock the gpu and memory clocks. I used nsight-compute as it measures kernel execution more precisely than possible using events <sup id="fnref:5" role="doc-noteref"><a href="#fn:5" rel="footnote">6</a></sup>.</p>

<p>By default nsight-compute locks to the GPU’s base clock, but as I wanted to compare to the RTX 4090’s stated peak throughput I locked at the boost clock of 2520 MHz. Kernels were run 55 times, the first 5 runs discarded and average results on the remaining 50 reported.</p>
<div><div><pre><code><span>sudo </span>nvidia-smi <span>-pm</span> ENABLED
<span>sudo </span>nvidia-smi <span>--lock-gpu-clocks</span><span>=</span>2550     <span># lock at boost clock</span>
<span>sudo </span>nvidia-smi <span>--lock-memory-clocks</span><span>=</span>10501 <span># max for RTX 4090</span>
ncu <span>-s</span> 5 <span>-k</span> <span>$my_kernel_name</span> <span>--clock-control</span> none <span>--print-summary</span> per-gpu <span>$my_executable</span>
</code></pre></div></div>
<p>Benchmarks were run on Pop!_OS 22.04 LTS, CUDA Toolkit Version 12.4, CUDA Driver Version 550.67.</p>

<h3 id="aside-tensor-core-matrix-multiply-apis">Aside: Tensor Core Matrix Multiply APIs</h3>
<p>There are three separate Tensor Core matmul APIs in CUDA/PTX:</p>
<ul>
  <li>WMMA: High level API available in both <a href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#warp-matrix-functions">CUDA</a> and <a href="https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#matrix-multiply-accumulate-operation-using-wmma-instructions">PTX</a></li>
  <li>MMA: Lower level API just available in <a href="https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#matrix-multiply-accumulate-operation-using-mma-instruction">PTX</a></li>
  <li>WGMMA: sm_90 only API that operates on warp-groups (consecutive groups of 4 warps). Just available in <a href="https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#asynchronous-warpgroup-level-matrix-multiply-accumulate-instructions">PTX</a></li>
</ul>

<p>All kernels in this post use the PTX mma API. wgmma is not an option as I am using an Ada architecture GPU. I chose mma over wmma as mma is a lower level API and my aim is to build an understanding of the underlying Tensor Core operations. Using mma also reportedly delivers higher performance than wmma though that comparison is old<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" rel="footnote">7</a></sup>.</p>

<h2 id="kernel-10-naive-mma-kernel">Kernel 1.0: Naive mma kernel</h2>
<p>The first kernel is a naive implementation resulting from reading the <code>mma</code> instruction documentation and handling data movement from global memory to registers in the simplest way possible.</p>

<p>In the Ada architecture there are 4 warp schedulers per SM, each with their own Tensor Core. Hence we want at least 4 warps per thread block (not strictly required as multiple thread blocks can run concurrently on one SM). In this kernel we use a 16x16 thread block, containing 8 warps. Each warp computes one 16x8 output tile and we arrange the warps in a 2 row x 4 column grid, so that each thread block computes a 32x32 output tile.</p>

<div><div><pre><code><span>// arrangement of warps in output tile</span>
<span>// (warp_0 | warp_1 | warp_2 | warp_3)</span>
<span>// (warp_4 | warp_5 | warp_6 | warp_7)</span>
</code></pre></div></div>
<p>There are multiple <code>mma</code> instructions for different data types and matrix shapes. As mentioned previously, in this and all subsequent kernels we’ll use</p>
<ul>
  <li><code>mma.sync.aligned.m16n8k16.row.col.f32.f16.f16.f32</code></li>
</ul>

<p>which performs (per warp) the matrix multiplication <code>D = A * B + C</code> where A is a <code>16x16</code> <code>fp16</code> matrix, <code>B</code> is <code>16x8</code> <code>fp16</code> matrix and C/D are <code>16x8</code> <code>fp32</code> matrices.</p>

<p>As <code>mma</code> is a PTX instruction, calling it from CUDA code requires using <a href="https://docs.nvidia.com/cuda/inline-ptx-assembly/index.html">inline PTX</a> which we wrap in a helper function:</p>

<div><div><pre><code><span>__device__</span> <span>void</span> <span>mma_m16n8k16</span><span>(</span><span>const</span> <span>unsigned</span> <span>*</span><span>A</span><span>,</span> <span>const</span> <span>unsigned</span> <span>*</span><span>B</span><span>,</span> <span>float</span> <span>*</span><span>C</span><span>,</span> <span>float</span> <span>*</span><span>D</span><span>)</span> <span>{</span>
  <span>asm</span><span>(</span>
      <span>&#34;mma.sync.aligned.m16n8k16.row.col.f32.f16.f16.f32 &#34;</span>
      <span>&#34;{%0,%1,%2,%3}, {%4,%5,%6,%7}, {%8,%9}, {%10,%11,%12,%13};</span><span>\n</span><span>&#34;</span>
      <span>:</span> <span>&#34;=f&#34;</span><span>(</span><span>D</span><span>[</span><span>0</span><span>]),</span> <span>&#34;=f&#34;</span><span>(</span><span>D</span><span>[</span><span>1</span><span>]),</span> <span>&#34;=f&#34;</span><span>(</span><span>D</span><span>[</span><span>2</span><span>]),</span> <span>&#34;=f&#34;</span><span>(</span><span>D</span><span>[</span><span>3</span><span>])</span>
      <span>:</span>
      <span>&#34;r&#34;</span><span>(</span><span>A</span><span>[</span><span>0</span><span>]),</span> <span>&#34;r&#34;</span><span>(</span><span>A</span><span>[</span><span>1</span><span>]),</span> <span>&#34;r&#34;</span><span>(</span><span>A</span><span>[</span><span>2</span><span>]),</span> <span>&#34;r&#34;</span><span>(</span><span>A</span><span>[</span><span>3</span><span>]),</span>
      <span>&#34;r&#34;</span><span>(</span><span>B</span><span>[</span><span>0</span><span>]),</span> <span>&#34;r&#34;</span><span>(</span><span>B</span><span>[</span><span>1</span><span>]),</span>
      <span>&#34;f&#34;</span><span>(</span><span>C</span><span>[</span><span>0</span><span>]),</span> <span>&#34;f&#34;</span><span>(</span><span>C</span><span>[</span><span>1</span><span>]),</span> <span>&#34;f&#34;</span><span>(</span><span>C</span><span>[</span><span>2</span><span>]),</span> <span>&#34;f&#34;</span><span>(</span><span>C</span><span>[</span><span>3</span><span>])</span>
      <span>);</span>
<span>}</span>
</code></pre></div></div>

<p>The <code>mma</code> instruction is warp-wide, each of the 32 threads provides 8 <code>fp16</code> elements from A, 4 <code>fp16</code> elements from B and 4 <code>fp32</code> elements from C, and recieves 4 output <code>fp32</code> elements from D. The 8 <code>fp16</code> elements of A are packed into 4 32 bit registers, and similarly the 4 elements of B into 2 32 bit registers.</p>

<p>The matrix elements held by each thread in its registers are called a matrix fragment, and the required mapping from thread ID to fragments for A is shown below:
<img src="https://www.spatters.ca/assets/images/a-fragment.png" alt="a-fragment"/>
A is split into 4 <code>8x8</code> submatrices, and each submatrix is split across the warp in a row major fashion which each thread holding two <code>fp16</code> values in one of its 32 bit registers. Mappings for <code>B, C &amp; D</code> are defined similarly and can be found in the <a href="https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#warp-level-matrix-fragment-mma-16816-float">PTX docs</a>.</p>

<p>We will later use the <code>ldmatrix</code> instruction to load fragements to registers, but for now we’ll do this per thread to demostrate the mapping. The main loop of Kernel 1.0 contains the code to load matrix fragments to registers and call the <code>mma</code> instruction.</p>

<div><div><pre><code><span>for</span> <span>(</span><span>int</span> <span>kStart</span><span>=</span><span>0</span><span>;</span> <span>kStart</span> <span>&lt;</span> <span>K</span><span>;</span> <span>kStart</span> <span>+=</span> <span>K_BLOCK</span><span>)</span> <span>{</span>
  <span>// load from global to shared memory</span>
  <span>for</span> <span>(</span><span>int</span> <span>m</span><span>=</span><span>0</span><span>;</span> <span>m</span> <span>&lt;</span> <span>2</span><span>;</span> <span>++</span><span>m</span><span>)</span> <span>{</span>
    <span>As</span><span>[</span><span>m</span><span>*</span><span>K_BLOCK</span> <span>+</span> <span>ty</span><span>][</span><span>tx</span><span>]</span> <span>=</span> <span>A</span><span>[(</span><span>mBlock</span> <span>+</span> <span>ty</span> <span>+</span> <span>m</span><span>*</span><span>K_BLOCK</span><span>)</span><span>*</span><span>K</span> <span>+</span> <span>kStart</span> <span>+</span> <span>tx</span><span>];</span>
  <span>}</span>
  <span>for</span> <span>(</span><span>int</span> <span>n</span><span>=</span><span>0</span><span>;</span> <span>n</span> <span>&lt;</span> <span>2</span><span>;</span> <span>++</span><span>n</span><span>)</span> <span>{</span>
    <span>Bs</span><span>[</span><span>ty</span><span>][</span><span>n</span><span>*</span><span>K_BLOCK</span> <span>+</span> <span>tx</span><span>]</span> <span>=</span> <span>B</span><span>[(</span><span>kStart</span> <span>+</span> <span>ty</span><span>)</span> <span>*</span> <span>K</span> <span>+</span> <span>nBlock</span> <span>+</span> <span>n</span><span>*</span><span>K_BLOCK</span> <span>+</span> <span>tx</span><span>];</span>
  <span>}</span>
  <span>__syncthreads</span><span>();</span>

  <span>// load from shmem to fp16 registers</span>
  <span>aReg</span><span>[</span><span>0</span><span>]</span> <span>=</span> <span>As</span><span>[</span><span>mWarp</span> <span>+</span> <span>groupID</span>    <span>][</span><span>groupLaneID</span><span>*</span><span>2</span>    <span>];</span>
  <span>aReg</span><span>[</span><span>1</span><span>]</span> <span>=</span> <span>As</span><span>[</span><span>mWarp</span> <span>+</span> <span>groupID</span>    <span>][</span><span>groupLaneID</span><span>*</span><span>2</span> <span>+</span> <span>1</span><span>];</span>
  <span>aReg</span><span>[</span><span>2</span><span>]</span> <span>=</span> <span>As</span><span>[</span><span>mWarp</span> <span>+</span> <span>groupID</span> <span>+</span> <span>8</span><span>][</span><span>groupLaneID</span><span>*</span><span>2</span>    <span>];</span>
  <span>aReg</span><span>[</span><span>3</span><span>]</span> <span>=</span> <span>As</span><span>[</span><span>mWarp</span> <span>+</span> <span>groupID</span> <span>+</span> <span>8</span><span>][</span><span>groupLaneID</span><span>*</span><span>2</span> <span>+</span> <span>1</span><span>];</span>
  <span>aReg</span><span>[</span><span>4</span><span>]</span> <span>=</span> <span>As</span><span>[</span><span>mWarp</span> <span>+</span> <span>groupID</span>    <span>][</span><span>groupLaneID</span><span>*</span><span>2</span> <span>+</span> <span>8</span><span>];</span>
  <span>aReg</span><span>[</span><span>5</span><span>]</span> <span>=</span> <span>As</span><span>[</span><span>mWarp</span> <span>+</span> <span>groupID</span>    <span>][</span><span>groupLaneID</span><span>*</span><span>2</span> <span>+</span> <span>9</span><span>];</span>
  <span>aReg</span><span>[</span><span>6</span><span>]</span> <span>=</span> <span>As</span><span>[</span><span>mWarp</span> <span>+</span> <span>groupID</span> <span>+</span> <span>8</span><span>][</span><span>groupLaneID</span><span>*</span><span>2</span> <span>+</span> <span>8</span><span>];</span>
  <span>aReg</span><span>[</span><span>7</span><span>]</span> <span>=</span> <span>As</span><span>[</span><span>mWarp</span> <span>+</span> <span>groupID</span> <span>+</span> <span>8</span><span>][</span><span>groupLaneID</span><span>*</span><span>2</span> <span>+</span> <span>9</span><span>];</span>

  <span>bReg</span><span>[</span><span>0</span><span>]</span> <span>=</span> <span>Bs</span><span>[</span><span>groupLaneID</span><span>*</span><span>2</span> <span>+</span> <span>0</span><span>][</span><span>nWarp</span> <span>+</span> <span>groupID</span><span>];</span>
  <span>bReg</span><span>[</span><span>1</span><span>]</span> <span>=</span> <span>Bs</span><span>[</span><span>groupLaneID</span><span>*</span><span>2</span> <span>+</span> <span>1</span><span>][</span><span>nWarp</span> <span>+</span> <span>groupID</span><span>];</span>
  <span>bReg</span><span>[</span><span>2</span><span>]</span> <span>=</span> <span>Bs</span><span>[</span><span>groupLaneID</span><span>*</span><span>2</span> <span>+</span> <span>8</span><span>][</span><span>nWarp</span> <span>+</span> <span>groupID</span><span>];</span>
  <span>bReg</span><span>[</span><span>3</span><span>]</span> <span>=</span> <span>Bs</span><span>[</span><span>groupLaneID</span><span>*</span><span>2</span> <span>+</span> <span>9</span><span>][</span><span>nWarp</span> <span>+</span> <span>groupID</span><span>];</span>
  <span>// pack fp16 registers to u32 and call mma</span>
  <span>unsigned</span> <span>const</span> <span>*</span><span>aPtr</span> <span>=</span> <span>reinterpret_cast</span><span>&lt;</span><span>unsigned</span> <span>const</span> <span>*&gt;</span><span>(</span><span>&amp;</span><span>aReg</span><span>);</span>
  <span>unsigned</span> <span>const</span> <span>*</span><span>bPtr</span> <span>=</span> <span>reinterpret_cast</span><span>&lt;</span><span>unsigned</span> <span>const</span> <span>*&gt;</span><span>(</span><span>&amp;</span><span>bReg</span><span>);</span>
  <span>mma_m16n8k16</span><span>(</span><span>aPtr</span><span>,</span> <span>bPtr</span><span>,</span> <span>dReg</span><span>,</span> <span>dReg</span><span>);</span>
  <span>__syncthreads</span><span>();</span>
<span>}</span>
</code></pre></div></div>
<h3 id="performance">Performance</h3>
<p>Kernel 1.0 has an execution time of 4.67 ms, giving a throughput of 29.4 TFLOP/s, 19.1% of cuBLAS and 17.8% of peak RTX 4090 performance. In fact it only achieves 35.6% of the RTX 4090’s peak FP32 performance, so a reasonably optimized non Tensor Core kernel would be faster. The reasons for the poor performance are:</p>
<ol>
  <li>Each thread loads individual 16b values in an uncoalesced load pattern</li>
  <li>The loads from shared memory to registers have multiple bank conflicts</li>
  <li>Each element loaded is only used in the input to one <code>mma</code> instruction, so the ratio of memory access to computation is low</li>
</ol>

<p>The Warp State Statistics chart in nsight-compute shows the impact of these problems: on average per instruction executed a warp spends 31 cycles stalled on shared memory throttles (MIO), 15 cycles stalled on barrier waits and 11 stalled on long scoreboard (global load) dependencies.</p>

<p><img src="https://www.spatters.ca/assets/images/kernel-1-warp-stats-1.png" alt="kernel-1-warp-stats"/></p>

<p>We can also use the profiler to  query the count of <code>mma</code> instructions executed and elapsed cycles:</p>
<div><div><pre><code><span>-------------------------------------------</span> <span>-----------</span> <span>-------------</span>
Metric Name                                 Metric Unit  Metric Value
<span>-------------------------------------------</span> <span>-----------</span> <span>-------------</span>
sm__cycles_elapsed.avg                            cycle 11,787,459.33
sm__cycles_elapsed.max                            cycle    11,822,127
sm__cycles_elapsed.min                            cycle    11,739,016
sm__cycles_elapsed.sum                            cycle 1,508,794,794
smsp__inst_executed_pipe_tensor_op_hmma.avg        inst        65,536
smsp__inst_executed_pipe_tensor_op_hmma.max        inst        66,048
smsp__inst_executed_pipe_tensor_op_hmma.min        inst        65,024
smsp__inst_executed_pipe_tensor_op_hmma.sum        inst    33,554,432
<span>-------------------------------------------</span> <span>-----------</span> <span>-------------</span>
</code></pre></div></div>
<p>The total number of <code>mma</code> instructions is 33,554,432 as calculated earlier, with 65,536 being computed on each Tensor Core. The number of cycles elapsed per <code>mma</code> was 11,787,459 / 65,536 = 179.9, so we are far from the 32 cycles best case.</p>

<p>The three problems described above will be addressed in Kernel 2: Point 1 by using vectorized and coalesced loads, Point 2 by using a permuted shared memory layout and Point 3 as each warp will compute multiple output tiles.</p>

<p>To isolate the impact made just by tiling vs the other changes, we add 2x tiling in the M and N dimensions in Kernel 1.1. In this kernel each warp executes 4 <code>mma</code> instructions meaning each thread block computes a 64x64 output tile. This reduces execution time to 2.40 ms, increasing throughput to 57.3 TFLOP/s, 37.3% cuBLAS, 34.7% peak performance.</p>


<p>In this kernel we use some of the techniques (vectorized loads and permuted shared memory layout) discussed in the GTC 2020 CUTLASS presentation<sup id="fnref:3:1" role="doc-noteref"><a href="#fn:3" rel="footnote">1</a></sup> to resolve the performance issues of Kernel 1. The memory layout diagrams in this section are taken from that presentation. The majority of the performance of the final kernel comes from the permuted shared memory layout introduced in this section.</p>

<p>Throughout this kernel we operate on <code>uint4</code> 128b vectors containing 8 consecutive <code>fp16</code> elements in the K dimension of A and B. Working with 128b vectors is natural when using Tensor Cores as the fundamental Tensor Core operation is an 8 by 8 by 128b matrix multiply, i.e. each 128b vector forms one row of the input matrices. Using 128b vectors also means we can vectorize memory operations.</p>

<p>We keep the 16x16 thread block dimensions from Kernel 1. The main loop of the kernel is shown below:</p>

<div><div><pre><code><span>// row / column indices when storing to shared memory</span>
<span>int</span> <span>storeRow</span> <span>=</span> <span>warpID</span> <span>*</span> <span>4</span> <span>+</span> <span>laneID</span> <span>/</span> <span>8</span><span>;</span>
<span>int</span> <span>storeCol</span> <span>=</span> <span>(</span><span>laneID</span> <span>%</span> <span>8</span><span>)</span> <span>^</span> <span>(</span><span>laneID</span> <span>/</span> <span>8</span><span>);</span>

<span>// row/column indices when loading from permuted shmem layout to registers</span>
<span>int</span> <span>loadRowA</span> <span>=</span> <span>(</span><span>laneID</span> <span>%</span> <span>16</span><span>)</span> <span>/</span> <span>2</span><span>;</span>
<span>int</span> <span>loadColA</span> <span>=</span> <span>(</span><span>laneID</span> <span>/</span> <span>16</span> <span>+</span> <span>4</span> <span>*</span> <span>(</span><span>laneID</span> <span>%</span> <span>2</span><span>))</span> <span>^</span> <span>(</span><span>loadRowA</span> <span>%</span> <span>4</span><span>);</span>
<span>int</span> <span>loadRowB</span> <span>=</span> <span>(</span><span>laneID</span> <span>%</span> <span>8</span><span>)</span> <span>/</span> <span>2</span><span>;</span>
<span>int</span> <span>loadColB</span> <span>=</span> <span>(</span><span>laneID</span> <span>/</span> <span>8</span> <span>+</span> <span>4</span> <span>*</span> <span>(</span><span>laneID</span> <span>%</span> <span>2</span><span>))</span> <span>^</span> <span>(</span><span>loadRowB</span> <span>%</span> <span>4</span><span>);</span>

<span>for</span> <span>(</span><span>int</span> <span>k</span> <span>=</span> <span>0</span><span>;</span> <span>k</span> <span>&lt;</span> <span>K</span><span>/</span><span>8</span><span>;</span> <span>k</span> <span>+=</span> <span>4</span><span>)</span> <span>{</span>
  <span>As</span><span>[</span><span>storeRow</span><span>][</span><span>storeCol</span><span>]</span> <span>=</span> <span>globalTileA</span><span>[(</span><span>warpID</span><span>*</span><span>8</span> <span>+</span> <span>laneID</span><span>/</span><span>4</span><span>)</span><span>*</span><span>K</span><span>/</span><span>8</span> <span>+</span> <span>k</span> <span>+</span> <span>laneID</span><span>%</span><span>4</span><span>];</span>
  <span>Bs</span><span>[</span><span>storeRow</span><span>][</span><span>storeCol</span><span>]</span> <span>=</span> <span>globalTileB</span><span>[(</span><span>warpID</span><span>*</span><span>8</span> <span>+</span> <span>laneID</span><span>/</span><span>4</span><span>)</span><span>*</span><span>K</span><span>/</span><span>8</span> <span>+</span> <span>k</span> <span>+</span> <span>laneID</span><span>%</span><span>4</span><span>];</span>
  <span>__syncthreads</span><span>();</span>

  <span>// loop over the two (M/N=16, K=4) tiles of a and b</span>
  <span>for</span> <span>(</span><span>int</span> <span>m</span> <span>=</span> <span>0</span><span>;</span> <span>m</span> <span>&lt;</span> <span>2</span><span>;</span> <span>m</span><span>++</span><span>)</span> <span>{</span>
    <span>int</span> <span>mTile</span> <span>=</span> <span>m</span> <span>*</span> <span>8</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> <span>n</span> <span>=</span> <span>0</span><span>;</span> <span>n</span> <span>&lt;</span> <span>2</span><span>;</span> <span>n</span><span>++</span><span>)</span> <span>{</span>
      <span>int</span> <span>nTile</span> <span>=</span> <span>n</span> <span>*</span> <span>4</span><span>;</span>
      <span>load_matrix_x4</span><span>(</span><span>aReg</span><span>,</span> <span>(</span><span>As</span><span>[</span><span>mWarp</span> <span>+</span> <span>mTile</span> <span>+</span> <span>loadRowA</span><span>]</span> <span>+</span> <span>loadColA</span><span>));</span>
      <span>load_matrix_x2</span><span>(</span><span>bReg</span><span>,</span> <span>(</span><span>Bs</span><span>[</span><span>nWarp</span> <span>+</span> <span>nTile</span> <span>+</span> <span>loadRowB</span><span>]</span> <span>+</span> <span>loadColB</span><span>));</span>
      <span>mma_m16n8k16</span><span>(</span><span>aReg</span><span>,</span> <span>bReg</span><span>,</span> <span>dReg</span><span>[</span><span>m</span><span>][</span><span>n</span><span>],</span> <span>dReg</span><span>[</span><span>m</span><span>][</span><span>n</span><span>]);</span>
      <span>load_matrix_x4</span><span>(</span><span>aReg</span><span>,</span> <span>(</span><span>As</span><span>[</span><span>mWarp</span> <span>+</span> <span>mTile</span> <span>+</span> <span>loadRowA</span><span>]</span> <span>+</span> <span>(</span><span>loadColA</span><span>^</span><span>2</span><span>)));</span>
      <span>load_matrix_x2</span><span>(</span><span>bReg</span><span>,</span> <span>(</span><span>Bs</span><span>[</span><span>nWarp</span> <span>+</span> <span>nTile</span> <span>+</span> <span>loadRowB</span><span>]</span> <span>+</span> <span>(</span><span>loadColB</span><span>^</span><span>2</span><span>)));</span>
      <span>mma_m16n8k16</span><span>(</span><span>aReg</span><span>,</span> <span>bReg</span><span>,</span> <span>dReg</span><span>[</span><span>m</span><span>][</span><span>n</span><span>],</span> <span>dReg</span><span>[</span><span>m</span><span>][</span><span>n</span><span>]);</span>
    <span>}</span>
  <span>}</span>
  <span>__syncthreads</span><span>();</span>
<span>}</span>
</code></pre></div></div>
<p>Looking first at the load from global to shared, each thread block loads A/B tiles of shape <code>(M/N=64, K=4)</code> <code>uint4</code> values from global memory to shared memory in a K-major fashion (i.e. row-major for A and column-major for B), with consecutive threads loading consecutive <code>uint4</code> values in the K-dimension using vectorized 128b loads. To coalesce these loads, the kernel requires A to be stored row-major in global memory and to be B stored column-major.</p>

<p>At the warp level, we load <code>uint4</code> tiles of shape <code>(M/N=8, K=4)</code> containing 8 rows/columns of A/B each containing 4 <code>uint4</code> values. This results in eight 64B memory transactions, each transaction reading two 32B sectors out of a 128B cache line containing four sectors in total.</p>

<p>This tile is stored in a <code>uint4</code> shared memory array of shape <code>(4, 8)</code> with two K=4 row/column slices stored per shared memory row. This shared memory shape is used as shared memory has 32 banks which are each 4 bytes wide, hence a row of 8 <code>uint4</code> values spans the 32 shared memory banks.</p>

<p>To avoid bank conflicts, threads which are part of the same memory request must not access addresses which map to the same bank. When each thread requests a 16B (128b) value, the warp level 512B request is split into 4 phases each consisting of 8 consecutive threads, as the max shared memory bandwidth is 32 banks * 4B = 128B. This means that it is sufficient to avoid bank conflicts within the 8 threads in each phase, rather within the full warp of 32 threads.</p>

<p>When storing to shared memory, the column indices for each row are permuted by XORing them with the row index: <code>storeCol = (laneID % 8) ^ (laneID / 8)</code>. The store from global to shared would be bank conflict free without this permutation, but it is required to avoid bank conflicts when loading data to registers from shared memory.</p>

<p>This diagram from <sup id="fnref:3:2" role="doc-noteref"><a href="#fn:3" rel="footnote">1</a></sup> illustrates how one warp loads from global to shared using the permuted layout:</p>

<p><img src="https://www.spatters.ca/assets/images/load-global-store-shared.png" alt="load-global-store-shared"/></p>

<p>Once data is loaded to shared memory, each warp computes a matmul on a <code>(M=32, K=4)</code> tile of A and a <code>(N=16, K=4)</code> tile of B. As the <code>mma</code> instruction computes a M=16, N=8, K=16 matmul we split these tiles into two <code>(M=16, K=4)</code> tiles of A / <code>(N=8, K=4)</code> tiles of B and compute their products in a nested loop. At the innermost level of this loop, we first load the <code>k=0..1</code> subtiles of the current A and B tiles into registers and compute their product using the <code>mma</code> instruction. We then load the <code>k=2..3</code> subtiles and perform a second <code>mma</code>.</p>

<p>We use the <code>ldmatrix</code> PTX instruction to load these tiles from shared memory to registers. This warp-wide instruction loads 1, 2 or 4 <code>8x128b</code> matrices and stores each matrix in one 32b register per thread in the fragment layout discussed previously. Each 128b row of these matrices is stored in one <code>uint4</code> vector in shared memory and each thread in the warp provides the address of one of these rows as described in the docs:</p>

<p><img src="https://www.spatters.ca/assets/images/ldmatrix-ptx-docs.png" alt="ldmatrix-docs"/></p>

<p>This means that to load a <code>(M=16, k=0..1)</code> subtile of <code>A</code>, we use the <code>.x4</code> variant of <code>ldmatrix</code>, with threads <code>0..15</code> providing the addresses of the elements with indices <code>m=0..15, k=0</code> and threads <code>16..31</code> providing the addresses of elements with indices <code>m=0..15, k=1</code>. Crucially, we permuted the layout of the tiles of A when storing to shared memory, and hence each thread needs to compute the address of its required element in the permuted layout.</p>

<p>Each <code>(M=16, K=4)</code> tile of A is stored in a 8 consecutive row subarray of the <code>As</code> shared memory array and each <code>(N=8, K=4)</code> tile of B is stored in a 4 consecutive row subarray of <code>Bs</code>. The <code>mWarp, nWarp</code> and <code>mTile, nTile</code> variables specify the start row of the subarrays of <code>As</code>, <code>Bs</code> for each warp / each iteration of the tile loop. Within each subarray the <code>loadRowA/B, loadColA/B</code> variables specify the location of the required element in the permuted layout.</p>

<p>The following diagram from <sup id="fnref:3:3" role="doc-noteref"><a href="#fn:3" rel="footnote">1</a></sup> illustrates the locations in shared memory provided by each thread to <code>ldmatrix</code> when loading a <code>(M=16, K=4)</code> tile of A:</p>

<p><img src="https://www.spatters.ca/assets/images/shared-register.png" alt="shared-register"/></p>

<p>The elements of the <code>k=0</code> slice of the subtile, loaded by threads <code>0..15</code> are shaded in blue. The elements loaded by threads <code>0..7</code> are all in distinct shared memory banks due to the permuted layout, as are those loaded by threads <code>8..15</code> and hence there are no bank conflicts.</p>

<p>This is also true for the <code>k=1</code> slice which is shaded in green. If the permutation had not been applied, threads <code>0,2,4,6</code> would all access banks <code>0..3</code> and threads <code>1,3,5,7</code> would all access banks <code>16..19</code>, causing multiple bank conflicts.</p>

<p>The elements shaded in yellow/gray belong to the <code>k=2..3</code> slices, which are inputs to the second <code>mma</code>. The column indices for these slices can be computed efficiently from the column indices of the <code>k=0..1</code> slices by applying <code>xor 2</code> to those indices.</p>

<p>Loading the <code>k=0..1</code> and <code>k=2..3</code> subtiles of B is similar except that as the subtile dimension is <code>(N=8, k=0..1)</code> there are only 16 128b matrix rows to load. Hence we use <code>ldmatrix.x2</code> which loads 2 8x128b matrices, using only the addresses in threads <code>0..15</code>.</p>

<p>As with the <code>mma</code> instruction, we define helper functions <code>load_matrix_x4</code>, <code>load_matrix_x2</code> to wrap the inline PTX. Looking at <code>load_matrix_x4</code> as an example:</p>

<div><div><pre><code><span>__device__</span> <span>void</span> <span>load_matrix_x4</span><span>(</span><span>unsigned</span> <span>*</span><span>destReg</span><span>,</span> <span>uint4</span> <span>*</span><span>srcAddr</span><span>)</span> <span>{</span>
  <span>unsigned</span> <span>ptxSrcAddr</span> <span>=</span> <span>__cvta_generic_to_shared</span><span>(</span><span>srcAddr</span><span>);</span>
  <span>asm</span> <span>volatile</span><span>(</span>
      <span>&#34;ldmatrix.sync.aligned.x4.m8n8.shared.b16 {%0, %1, %2, %3}, [%4];</span><span>\n</span><span>&#34;</span>
      <span>:</span> <span>&#34;=r&#34;</span><span>(</span><span>destReg</span><span>[</span><span>0</span><span>]),</span> <span>&#34;=r&#34;</span><span>(</span><span>destReg</span><span>[</span><span>1</span><span>]),</span> <span>&#34;=r&#34;</span><span>(</span><span>destReg</span><span>[</span><span>2</span><span>]),</span> <span>&#34;=r&#34;</span><span>(</span><span>destReg</span><span>[</span><span>3</span><span>])</span>
      <span>:</span>  <span>&#34;r&#34;</span><span>(</span><span>ptxSrcAddr</span><span>)</span>
      <span>);</span>
<span>}</span>
</code></pre></div></div>

<p>Two things to note</p>
<ol>
  <li><code>__cvta_generic_to_shared</code> is a CUDA function that takes a standard C/C++ pointer, which is 64b, and converts to a 32b pointer as shared memory is a 32b address space</li>
  <li>The <code>volatile</code> qualifier is needed for this instruction: without it the loads do not get synchronized properly and threads end up with incorrect data, as I discovered after much painful debugging.</li>
</ol>

<p>Once the main loop has finished, the output tile for each warp is contained in <code>dReg</code>, the output registers of the <code>mma</code> instructions. There is a <code>stmatrix</code> instruction to copy back from registers to shared memory but this requires <code>sm_90</code> so we need to handle this ourselves. We write directly from registers to global memory, it may be possible to optimize this by writing first to shared and then writing to global in a coalesced pattern but that requires more shared memory and could reduce occupancy. I experimented with this but did not see a performance improvement.</p>

<h3 id="performance-1">Performance</h3>
<p>Kernel 2.0 has greatly increased performance. Execution time is 1080 us, a throughput of 127.3 TFLOP/s which is 82.9% cuBLAS and 77.0% of RTX 4090 peak performance. We can make one minor tweak to the kernel to improve performance further. Currently we reload each tile of A for each tile of B, this reduces register usage but introduces redundant loads from shared memory to registers.</p>

<p>In Kernel 2.1 we only load each tile of A once, this improves performance to 1030 us, 133.4 TFLOP/s, 86.9% of cuBLAS, 80.8% peak. The elapsed cycles per mma for Kernel 2.1 is 38, much closer to the minimum of 32.</p>

<p>The permuted shared memory layout should make these kernels bank-conflict free and we verify this for Kernel 2.1:</p>

<p><img src="https://www.spatters.ca/assets/images/kernel-2b-conflict.png" alt="kernel-2b-conflict"/></p>

<p>Looking at the warp stats shows that the most frequent cause of stalls is now waiting for the Tensor Cores to be free - this is good!</p>

<p><img src="https://www.spatters.ca/assets/images/kernel-2b-warp-stats-1.png" alt="2b-warp-stats"/></p>

<p>There are still considerable number of barrier and long scoreboard stalls, which we’ll address in Kernel 3.0 by introducing an n-stage pipeline from global to shared memory using the <code>cp.async</code> instruction.</p>


<p>There are asynchronous copy APIs both in CUDA (<code>cuda::memcpy_async</code>) and PTX (<code>cp.async</code>). The <code>cuda::memcp_async</code> API does not support copying with a permuted layout and hence we use the PTX <code>cp.async</code> API. As before we define a wrapper function for the inline PTX call:</p>

<div><div><pre><code><span>__device__</span> <span>void</span> <span>cp_async</span><span>(</span><span>uint4</span> <span>*</span><span>dstAddr</span><span>,</span> <span>const</span> <span>uint4</span> <span>*</span><span>srcAddr</span><span>)</span> <span>{</span>
  <span>unsigned</span> <span>ptxDstAddr</span> <span>=</span> <span>__cvta_generic_to_shared</span><span>(</span><span>dstAddr</span><span>);</span>
  <span>asm</span> <span>volatile</span><span>(</span><span>&#34;cp.async.cg.shared.global.L2::128B [%0], [%1], %2;</span><span>\n</span><span>&#34;</span>
      <span>::</span> <span>&#34;r&#34;</span><span>(</span><span>ptxDstAddr</span><span>),</span>
      <span>&#34;l&#34;</span><span>(</span><span>srcAddr</span><span>),</span>
      <span>&#34;n&#34;</span><span>(</span><span>16</span><span>));</span>
<span>}</span>
</code></pre></div></div>

<p>The final <code>&#34;n&#34;(16)</code> input is the number of bytes to copy, and needs to be a compile time constant.</p>

<p>We can then use this function to replace the global to shared load:</p>
<div><div><pre><code><span>// Replace this</span>
<span>As</span><span>[</span><span>storeRow</span><span>][</span><span>storeCol</span><span>]</span> <span>=</span> <span>globalTileA</span><span>[(</span><span>warpID</span><span>*</span><span>8</span> <span>+</span> <span>laneID</span><span>/</span><span>4</span><span>)</span><span>*</span><span>K</span><span>/</span><span>8</span> <span>+</span> <span>k</span> <span>+</span> <span>laneID</span><span>%</span><span>4</span><span>];</span>
<span>Bs</span><span>[</span><span>storeRow</span><span>][</span><span>storeCol</span><span>]</span> <span>=</span> <span>globalTileB</span><span>[(</span><span>warpID</span><span>*</span><span>8</span> <span>+</span> <span>laneID</span><span>/</span><span>4</span><span>)</span><span>*</span><span>K</span><span>/</span><span>8</span> <span>+</span> <span>k</span> <span>+</span> <span>laneID</span><span>%</span><span>4</span><span>];</span>
<span>// With</span>
<span>cp_async</span><span>(</span><span>As</span><span>[</span><span>storeRow</span><span>]</span> <span>+</span> <span>storeCol</span><span>,</span> <span>globalTileA</span><span>[(</span><span>warpID</span><span>*</span><span>8</span> <span>+</span> <span>laneID</span><span>/</span><span>4</span><span>)</span><span>*</span><span>K</span><span>/</span><span>8</span> <span>+</span> <span>k</span> <span>+</span> <span>laneID</span><span>%</span><span>4</span><span>]);</span>
<span>cp_async</span><span>(</span><span>Bs</span><span>[</span><span>storeRow</span><span>]</span> <span>+</span> <span>storeCol</span><span>,</span> <span>globalTileB</span><span>[(</span><span>warpID</span><span>*</span><span>8</span> <span>+</span> <span>laneID</span><span>/</span><span>4</span><span>)</span><span>*</span><span>K</span><span>/</span><span>8</span> <span>+</span> <span>k</span> <span>+</span> <span>laneID</span><span>%</span><span>4</span><span>]);</span>
<span>asm</span> <span>volatile</span><span>(</span><span>&#34;cp.async.commit_group;</span><span>\n</span><span>&#34;</span> <span>::</span><span>);</span>
</code></pre></div></div>
<p>The <code>cp.async.commit_group</code> instruction groups these copies together in a <code>cp.async-group</code> which can later be waited on using <code>cp.async.wait_group</code>.</p>

<p>We now use <code>cp.async</code> to set up an n-stage pipeline from global to shared memory. We create circular buffers of size <code>N_STAGES</code> for A and B in shared memory. Before the main loop of the kernel we preload the first <code>N_STAGES - 1</code> stages into these shared memory buffers using <code>cp.async</code>:</p>

<div><div><pre><code><span>__shared__</span> <span>uint4</span> <span>As</span><span>[</span><span>N_STAGES</span><span>*</span><span>32</span><span>][</span><span>8</span><span>];</span>
<span>__shared__</span> <span>uint4</span> <span>Bs</span><span>[</span><span>N_STAGES</span><span>*</span><span>32</span><span>][</span><span>8</span><span>];</span>
<span>// PRELUDE: load first (N_STAGES - 1) into shared memory</span>
<span>for</span> <span>(</span><span>int</span> <span>nStage</span><span>=</span><span>0</span><span>;</span> <span>nStage</span> <span>&lt;</span> <span>N_STAGES</span> <span>-</span> <span>1</span><span>;</span> <span>nStage</span><span>++</span><span>)</span> <span>{</span>
  <span>int</span> <span>kStart</span> <span>=</span> <span>nStage</span> <span>*</span> <span>4</span><span>;</span>
  <span>aStorePtr</span> <span>=</span> <span>As</span> <span>+</span> <span>32</span> <span>*</span> <span>nStage</span><span>;</span>
  <span>bStorePtr</span> <span>=</span> <span>Bs</span> <span>+</span> <span>32</span> <span>*</span> <span>nStage</span><span>;</span>
  <span>cp_async</span><span>(</span><span>aStorePtr</span><span>[</span><span>storeRow</span><span>]</span> <span>+</span> <span>storeCol</span><span>,</span> <span>aGlobalAddress</span> <span>+</span> <span>kStart</span><span>);</span>
  <span>cp_async</span><span>(</span><span>bStorePtr</span><span>[</span><span>storeRow</span><span>]</span> <span>+</span> <span>storeCol</span><span>,</span> <span>bGlobalAddress</span> <span>+</span> <span>kStart</span><span>);</span>
  <span>asm</span> <span>volatile</span><span>(</span><span>&#34;cp.async.commit_group;</span><span>\n</span><span>&#34;</span> <span>::</span><span>);</span>
<span>}</span>
</code></pre></div></div>
<p>At the start of the main loop there are at most <code>N_STAGES-1</code> <code>cp.async</code> operations pending, this is an invariant that will be maintained at each loop iteration. We initialize shared memory load and store pointers to stages <code>0</code> and <code>N_STAGES-1</code> respectively and then wait for the first copy to complete, i.e. until there are at most <code>N_STAGES-2</code> cp.async operations pending. Note that a <code>__syncthreads</code> is required after <code>wait_group</code> as <code>wait_group</code> just synchronizes copy operations within each thread, not across threads.</p>

<div><div><pre><code><span>//  MAIN LOOP OVER K BLOCKS</span>
<span>for</span> <span>(</span><span>int</span> <span>nStage</span><span>=</span><span>0</span><span>;</span> <span>nStage</span> <span>&lt;</span> <span>K</span><span>/</span><span>32</span><span>;</span> <span>nStage</span><span>++</span><span>)</span> <span>{</span>
  <span>int</span> <span>kStart</span> <span>=</span> <span>(</span><span>N_STAGES</span><span>-</span><span>1</span><span>+</span><span>nStage</span><span>)</span> <span>*</span> <span>4</span><span>;</span>
  <span>aStorePtr</span> <span>=</span> <span>As</span> <span>+</span> <span>32</span> <span>*</span> <span>((</span><span>nStage</span> <span>+</span> <span>N_STAGES</span><span>-</span><span>1</span><span>)</span> <span>%</span> <span>N_STAGES</span><span>);</span>
  <span>bStorePtr</span> <span>=</span> <span>Bs</span> <span>+</span> <span>32</span> <span>*</span> <span>((</span><span>nStage</span> <span>+</span> <span>N_STAGES</span><span>-</span><span>1</span><span>)</span> <span>%</span> <span>N_STAGES</span><span>);</span>
  <span>aLoadPtr</span> <span>=</span> <span>As</span> <span>+</span> <span>32</span> <span>*</span> <span>(</span><span>nStage</span> <span>%</span> <span>N_STAGES</span><span>);</span>
  <span>bLoadPtr</span> <span>=</span> <span>Bs</span> <span>+</span> <span>32</span> <span>*</span> <span>(</span><span>nStage</span> <span>%</span> <span>N_STAGES</span><span>);</span>
  
  <span>asm</span> <span>volatile</span><span>(</span><span>&#34;cp.async.wait_group %0;</span><span>\n</span><span>&#34;</span> <span>::</span> <span>&#34;n&#34;</span><span>(</span><span>N_STAGES</span><span>-</span><span>2</span><span>));</span>
  <span>__syncthreads</span><span>();</span>

  <span>// Preload the fragments for k=0..1, k=2..3 for both A/B tiles </span>
  <span>for</span> <span>(</span><span>int</span> <span>m</span><span>=</span><span>0</span><span>;</span> <span>m</span><span>&lt;</span><span>2</span><span>;</span> <span>m</span><span>++</span><span>)</span> <span>{</span>
    <span>load_matrix_x4</span><span>(</span><span>aReg</span><span>[</span><span>m</span><span>]</span>    <span>,</span> <span>aLoadPtr</span><span>[</span><span>m</span><span>*</span><span>8</span> <span>+</span> <span>warpOffsetA</span> <span>+</span> <span>loadRowA</span><span>]</span> <span>+</span> <span>loadColA</span><span>);</span>
    <span>load_matrix_x4</span><span>(</span><span>aReg</span><span>[</span><span>m</span><span>]</span> <span>+</span> <span>4</span><span>,</span> <span>aLoadPtr</span><span>[</span><span>m</span><span>*</span><span>8</span> <span>+</span> <span>warpOffsetA</span> <span>+</span> <span>loadRowA</span><span>]</span> <span>+</span> <span>(</span><span>loadColA</span><span>^</span><span>2</span><span>));</span>
  <span>}</span>
  <span>for</span> <span>(</span><span>int</span> <span>n</span><span>=</span><span>0</span><span>;</span> <span>n</span><span>&lt;</span><span>2</span><span>;</span> <span>n</span><span>++</span><span>)</span> <span>{</span>
    <span>load_matrix_x2</span><span>(</span><span>bReg</span><span>[</span><span>n</span><span>]</span>   <span>,</span> <span>bLoadPtr</span><span>[</span><span>n</span><span>*</span><span>4</span> <span>+</span> <span>warpOffsetB</span> <span>+</span> <span>loadRowB</span><span>]</span> <span>+</span> <span>loadColB</span><span>);</span>
    <span>load_matrix_x2</span><span>(</span><span>bReg</span><span>[</span><span>n</span><span>]</span><span>+</span> <span>2</span><span>,</span> <span>bLoadPtr</span><span>[</span><span>n</span><span>*</span><span>4</span> <span>+</span> <span>warpOffsetB</span> <span>+</span> <span>loadRowB</span><span>]</span> <span>+</span> <span>(</span><span>loadColB</span><span>^</span><span>2</span><span>));</span>
  <span>}</span>

  <span>// Start next cp.async: on last N_STAGES-1 iterations the results of </span>
  <span>// these copies are not used. The copies are done solely to allow</span>
  <span>// us to keep the argument to `wait_group` fixed at N_STAGES-2</span>
  <span>kStart</span> <span>=</span> <span>(</span><span>kStart</span> <span>&gt;</span> <span>512</span><span>-</span><span>4</span><span>)</span> <span>?</span> <span>512</span><span>-</span><span>4</span> <span>:</span> <span>kStart</span><span>;</span>
  <span>cp_async</span><span>(</span><span>aStorePtr</span><span>[</span><span>storeRow</span><span>]</span> <span>+</span> <span>storeCol</span><span>,</span> <span>aGlobalAddress</span> <span>+</span> <span>kStart</span><span>);</span>
  <span>cp_async</span><span>(</span><span>bStorePtr</span><span>[</span><span>storeRow</span><span>]</span> <span>+</span> <span>storeCol</span><span>,</span> <span>bGlobalAddress</span> <span>+</span> <span>kStart</span><span>);</span>
  <span>asm</span> <span>volatile</span><span>(</span><span>&#34;cp.async.commit_group;</span><span>\n</span><span>&#34;</span> <span>::</span><span>);</span>

  <span>// Compute the mmas</span>
  <span>for</span> <span>(</span><span>int</span> <span>m</span><span>=</span><span>0</span><span>;</span> <span>m</span><span>&lt;</span><span>2</span><span>;</span> <span>m</span><span>++</span><span>)</span> <span>{</span>
    <span>for</span> <span>(</span><span>int</span> <span>n</span><span>=</span><span>0</span><span>;</span> <span>n</span><span>&lt;</span><span>2</span><span>;</span> <span>n</span><span>++</span><span>)</span> <span>{</span>
      <span>mma_m16n8k16</span><span>(</span><span>aReg</span><span>[</span><span>m</span><span>]</span>    <span>,</span> <span>bReg</span><span>[</span><span>n</span><span>]</span>    <span>,</span> <span>dReg</span><span>[</span><span>m</span><span>][</span><span>n</span><span>]);</span>
      <span>mma_m16n8k16</span><span>(</span><span>aReg</span><span>[</span><span>m</span><span>]</span> <span>+</span> <span>4</span><span>,</span> <span>bReg</span><span>[</span><span>n</span><span>]</span> <span>+</span> <span>2</span><span>,</span> <span>dReg</span><span>[</span><span>m</span><span>][</span><span>n</span><span>]);</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre></div></div>
<p>Next we load the current shared memory stage to registers. In this kernel we preload the entire <code>(M/N=64, K=4)</code> tile into registers, requiring 16 registers for <code>A</code> and 8 for <code>B</code>. The extra shared memory required by the <code>N_STAGES</code> shared memory buffers is the occupancy bottleneck so using these extra registers makes sense to parallelize the loads as much as possible. After the starting the loads to registers, we submit the next <code>cp.async</code> instruction, and finally we perform the <code>mma</code> instructions and increment the load and store pointers modulo N_STAGES.</p>

<p>As <code>N_STAGES-1</code> K blocks were loaded before the main loop, on the last <code>N_STAGES-1</code> iterations through the main loop we don’t need to load any more data from global memory. However the argument to <code>cp.async.wait_group</code> needs to be a compile time constant and submitting superfluous copies is a hacky way to keep the argument to <code>wait_group</code> fixed at <code>N_STAGES-2</code>. Without these copies the kernel would be incorrect unless we decreased this argument on each of the last <code>N_STAGES-1</code> iterations.</p>

<h3 id="performance-2">Performance</h3>
<p>Sadly after all that effort Kernel 3.0 is a very minor improvement over Kernel 2.1. For <code>N_STAGES=3</code>, the execution time is 1000 us, giving 137.4 TFLOP/s, 89.5% cuBLAS, 83.2% 4090 peak performance. Setting <code>N_STAGES=4</code> has similar performance and higher than this reduces performance. Looking at the warp state stats shows that overall stalls are lower than in Kernel 2.1:</p>

<p><img src="https://www.spatters.ca/assets/images/kernel-3-warp-stats.png" alt="3-warp-stats"/></p>

<p>This is partially due to reduced occupancy: Kernel 2.1 has 32 warps per SM while Kernel 3.0 has 24 due to the extra shared memory requirements.</p>

<p>As stalls due to barrier synchronization are still high, a reasonable optimization is to try increasing the work each warp does within a main loop iteration. We do this in Kernel 3.1 by increasing the tiling in the M/N dimensions from 2 to 4. This doubles the thread block tile size to <code>(M/N=128, K=4)</code> meaning that each warp performs 4x4x2=32 <code>mma</code> instructions per main loop iteration.</p>

<p>Kernel 3.1 has an execution time of 895 us, giving throughput of 153.6 TFLOP/s, 100% cuBLAS, 93.0% of RTX 4090 peak performance. Looking at the warp state stats shows that the vast majority of stalls are now due to waiting for Tensor Cores, in fact each warp now waits on average 36 cycles for a Tenor Core to be available:</p>

<p><img src="https://www.spatters.ca/assets/images/kernel-3b-warp-stats.png" alt="3b-warp-stats"/></p>

<p>The ratio of elapsed cycles to mma instructions for Kernel 3.1 is 34.2, consistent with the figure of 93.5% peak performance.</p>

<p>Surprisingly nsight-compute shows the Tensor Core utilization as only 47.3% so what is going on?</p>

<p><img src="https://www.spatters.ca/assets/images/tensor-core-util.png" alt="tc-util"/></p>

<p>It seems that nsight uses a fixed latency of 16 cycles when computing <code>smsp__pipe_tensor_op_hmma_cycles_active</code> as the metric value is consistently 16 times the value of <code>smsp__inst_executed_pipe_tensor_op_hmma</code>. This seems to be an error as the latency for the <code>m16n8k16</code> <code>mma</code> instruction should be 32, so the utilization should be 94.6%.</p>

<p>One final thing I noticed is that both Kernels 3.0 &amp; 3.1 have bank conflicts, for 3.1 nsight shows:</p>

<p><img src="https://www.spatters.ca/assets/images/kernel-3b-conflict.png" alt="kernel-3b-conflict"/></p>

<p>Confusingly in this view (Memory Tables) the conflicts appear only in the shared loads, whereas in the source metrics they appear both when copying from global to shared and when loading from shared to registers. The shared loads in particular use the same <code>ldmatrix</code> instruction as in Kernel 2, so I’m not sure how moving to <code>cp.async</code> introduces a conflict there.</p>

<p>It’s possible these conflicts are not real, nsight-compute reports erroneous conflicts in some cases as described <a href="https://forums.developer.nvidia.com/t/shared-memory-bank-conflicts-and-nsight-metric/115731/12">here</a>. I need to look into this further and will update the post if/when I find out what’s going on.</p>

<h2 id="conclusion">Conclusion</h2>
<p>We’ve gone from a naive implementation with correspondingly poor performance, to a kernel that is on par with cuBLAS, at least for this extremely specific problem formulation. In the process we’ve developed an understanding of <code>mma</code> and related PTX instructions, along with the techniques needed to feed data to Tensor Cores efficiently.</p>

<h2 id="code">Code</h2>
<p>The code for all Kernels is available here: <a href="https://github.com/spatters/mma-matmul">https://github.com/spatters/mma-matmul</a>.</p>

<h3 id="appendix-floating-point-accuracy">Appendix: Floating Point Accuracy</h3>
<p>NVIDIA does not fully document the exact numerical behavior of the Tensor Core <code>mma</code> instruction. The PTX ISA states: 
<img src="https://www.spatters.ca/assets/images/mma-numeric.png" alt="mma-numeric"/>
Getting into these details is not the focus of this post, but one example of rounding error is worth noting. Kernel 1.0 accumulates the results of the main loop over K directly in <code>dReg</code> meaning at each iteration the accumulation <code>dReg = dReg + aReg * bReg</code> happens within the <code>mma</code> operation, which can cause loss of precision if <code>dReg</code> is large compared to <code>aReg * bReg</code>.</p>

<p>When testing correctness of the implementation I initialize inputs with <code>U[0,1)</code> values. This means <code>dReg</code> grows monotonically as we loop over K, and performing the accumulation directly in the <code>mma</code> operation causes round off such that the result using <code>mma</code> is consistently lower than a reference implementation using <code>fp16/fp32</code> operations on CUDA cores (relative difference around 1e-5). This issue can be avoided by instead performing an mma without accumulation, and accumulating the results outside, i.e.</p>
<div><div><pre><code><span>float4</span> <span>dRegAcc</span> <span>=</span> <span>0</span><span>;</span>
<span>float</span> <span>cReg</span><span>[</span><span>4</span><span>]</span> <span>=</span> <span>{</span><span>0.</span><span>};</span>
<span>mma_m16n8k16</span><span>(</span><span>aPtr</span><span>,</span> <span>bPtr</span><span>,</span> <span>cReg</span><span>,</span> <span>dReg</span><span>);</span>
<span>float4</span> <span>*</span><span>dRegPtr</span> <span>=</span> <span>reinterpret_cast</span><span>&lt;</span><span>float4</span> <span>*&gt;</span><span>(</span><span>dReg</span><span>);</span>
<span>dRegAcc</span><span>.</span><span>x</span> <span>+=</span> <span>dRegPtr</span><span>-&gt;</span><span>x</span><span>;</span>
<span>dRegAcc</span><span>.</span><span>y</span> <span>+=</span> <span>dRegPtr</span><span>-&gt;</span><span>y</span><span>;</span>
<span>dRegAcc</span><span>.</span><span>z</span> <span>+=</span> <span>dRegPtr</span><span>-&gt;</span><span>z</span><span>;</span>
<span>dRegAcc</span><span>.</span><span>w</span> <span>+=</span> <span>dRegPtr</span><span>-&gt;</span><span>w</span><span>;</span>
</code></pre></div></div>
<p>Applied to Kernel 3.1, this incurs a performance penalty of around 10 us, reduces the difference to the reference kernel by two orders of magnitude and centers it. Detailed investigation into the numerical behavior of Tensor Cores in general can be found in <sup id="fnref:4" role="doc-noteref"><a href="#fn:4" rel="footnote">8</a></sup>.</p>

<h3 id="references">References</h3>



  </div>

</article>

      </div>
    </div></div>
  </body>
</html>
