<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.ganssle.io/articles/2018/03/pytz-fastest-footgun.html">Original</a>
    <h1>Pytz: The Fastest Footgun in the West</h1>
    
    <div id="readability-page-1" class="page"><div>
<section id="content">
  <article>
    
    <div><p>Whenever I give a talk about time zones, someone comes up to me afterwards and tells me that they have broken code <em>currently in production</em>, because they misunderstood how <tt>pytz</tt> works. This is because <tt>pytz</tt> uses its own non-standard interface for handling time zone information that is partially but not entirely compatible with the way Python&#39;s <tt>datetime</tt> library was intended to work, which leads to a lot of confusion from people naively using <tt>pytz</tt> as a time zone provider. This incompatibility is why, as of Python 3.6, the <a href="https://docs.python.org/3/library/datetime.html#tzinfo-objects">tzinfo documentation</a> recommends <tt>dateutil.tz</tt> rather than <tt>pytz</tt> as an IANA time zone provider. <a href="#python-docs" id="footnote-reference-1">[1]</a></p>
<p>In this post, I will cover both time zone models and if I cannot convince you to switch to <a href="https://github.com/dateutil/dateutil"><tt>dateutil.tz</tt></a>, at least provide some intuition about the differences between <tt>pytz</tt> and the standard time zone model.</p>
<div id="python-s-time-zone-model">
<h2>Python&#39;s time zone model</h2>
<p>In the <tt>datetime</tt> module, Python provides support for <em>time zones</em> rather than time zone offsets - which is to say that a <tt>datetime.tzinfo</tt> object is expected to provide not a fixed offset and name but a set of rules for what the time zone information is <em>as a function of the datetime</em>. This is so that something like this will work:</p>
<div><pre><span></span><span>from</span> <span>dateutil</span> <span>import</span> <span>tz</span>
<span>from</span> <span>datetime</span> <span>import</span> <span>datetime</span><span>,</span> <span>timedelta</span>

<span>NYC</span> <span>=</span> <span>tz</span><span>.</span><span>gettz</span><span>(</span><span>&#39;America/New_York&#39;</span><span>)</span>
<span>dt_winter</span> <span>=</span> <span>datetime</span><span>(</span><span>2018</span><span>,</span> <span>2</span><span>,</span> <span>14</span><span>,</span> <span>12</span><span>,</span> <span>tzinfo</span><span>=</span><span>NYC</span><span>)</span>
<span>print</span><span>(</span><span>dt_winter</span><span>)</span>
<span># 2018-02-14 12:00:00-05:00</span>

<span>dt_spring</span> <span>=</span> <span>dt_winter</span> <span>+</span> <span>timedelta</span><span>(</span><span>days</span><span>=</span><span>60</span><span>)</span>
<span>print</span><span>(</span><span>dt_spring</span><span>)</span>
<span># 2018-04-15 12:00:00-04:00</span>
</pre></div>
<p>If <tt>NYC</tt> were a static, fixed offset, you&#39;d need to attach a <em>different</em> <tt>tzinfo</tt> to each datetime depending on whether or not you&#39;re in standard or daylight time, and any time you did any math on your datetime, you&#39;d have to redo the calculations in case the offset had changed. Thus, Python&#39;s model is that any <tt>tzinfo</tt> subclass should implement the following three methods:</p>
<ul>
<li><code>tzname(self, dt)</code>: The name of the offset at the given datetime (e.g. EST, PDT)</li>
<li><code>utcoffset(self, dt)</code>: The offset from UTC at the given datetime</li>
<li><code>dst(self, dt)</code>: The difference between the current offset and the zone&#39;s &#34;standard offset&#34; <a href="#standard-offset" id="footnote-reference-2">[2]</a></li>
</ul>
<p>These values are not only implemented as a function, they are also invoked <em>lazily</em>, so there are no hooks in the <tt>datetime</tt> constructor that call these â€“ they are only invoked when a user wants to know one or more of these pieces of information.</p>
</div>
<div id="pytz-s-time-zone-model">
<h2>pytz&#39;s time zone model</h2>
<p>The biggest mistake people make with <tt>pytz</tt> is simply attaching its time zones to the constructor, since that is the standard way to add a time zone to a <tt>datetime</tt> in Python. If you try and do that, the best case scenario is that you&#39;ll get something obviously absurd:</p>
<div><pre><span></span><span>import</span> <span>pytz</span>
<span>from</span> <span>datetime</span> <span>import</span> <span>datetime</span><span>,</span> <span>timedelta</span>

<span>NYC</span> <span>=</span> <span>pytz</span><span>.</span><span>timezone</span><span>(</span><span>&#39;America/New_York&#39;</span><span>)</span>
<span>dt</span> <span>=</span> <span>datetime</span><span>(</span><span>2018</span><span>,</span> <span>2</span><span>,</span> <span>14</span><span>,</span> <span>12</span><span>,</span> <span>tzinfo</span><span>=</span><span>NYC</span><span>)</span>
<span>print</span><span>(</span><span>dt</span><span>)</span>
<span># 2018-02-14 12:00:00-04:56</span>
</pre></div>
<p>Why is the time offset -04:56 and not -05:00? Because that was the local solar mean time in New York before standardized time zones were adopted, and is thus the first entry in the <tt>America/New_York</tt> time zone. Why did <tt>pytz</tt> return that? Because unlike the standard library&#39;s model of lazily-computed time zone information, <tt>pytz</tt> takes an eager calculation approach. Whenever you construct an aware <tt>datetime</tt> from a naive one, you need to call the <tt>localize</tt> function on it:</p>
<div><pre><span></span><span>dt</span> <span>=</span> <span>NYC</span><span>.</span><span>localize</span><span>(</span><span>datetime</span><span>(</span><span>2018</span><span>,</span> <span>2</span><span>,</span> <span>14</span><span>,</span> <span>12</span><span>))</span>
<span>print</span><span>(</span><span>dt</span><span>)</span>
<span># 2018-02-14 12:00:00-05:00</span>
</pre></div>
<p>Each <tt>pytz</tt> time zone contains a list of possible fixed offset &#34;time zone&#34; objects that are valid at different times in that zone, and the <tt>localize</tt> function figures out which one is valid at that local date and time and attaches it. In this case it detects correctly that 2018-02-14 should be EST with offset -05:00 and DST -00:00. Now what happens when you perform the arithmetic on a localized datetime?</p>
<div><pre><span></span><span>from</span> <span>datetime</span> <span>import</span> <span>timedelta</span>

<span>dt_spring</span> <span>=</span> <span>dt</span> <span>+</span> <span>timedelta</span><span>(</span><span>days</span><span>=</span><span>60</span><span>)</span>
<span>print</span><span>(</span><span>dt_spring</span><span>)</span>
<span># 2018-04-15 12:00:00-05:00</span>
</pre></div>
<p>Since the <tt>localize</tt> function eagerly attached EST to the datetime, the offset is not updated in response to the arithmetic. In order to fix this error, any time you do any arithmetic on a <tt>pytz</tt>-aware datetime, you need to call the <tt>normalize</tt> function:</p>
<div><pre><span></span><span>print</span><span>(</span><span>NYC</span><span>.</span><span>normalize</span><span>(</span><span>dt_spring</span><span>))</span>
<span># 2018-04-15 13:00:00-04:00</span>
</pre></div>
<p>This is, again, just eagerly doing the calculation that would be done lazily by a <tt>dateutil.tz</tt> time zone object <a href="#semantics" id="footnote-reference-3">[3]</a>.</p>
</div>
<div id="ambiguous-datetimes">
<h2>Ambiguous datetimes</h2>
<p>Why was <tt>pytz</tt> designed this way, given that it doesn&#39;t mesh well with Python&#39;s standard time zone model? Consider the scenario of an <em>ambiguous datetime</em>, which occurs during a daylight saving time transition, e.g. <tt><span>2018-11-04</span> <span>01:30-04:00</span></tt>, and an hour later, <tt><span>2018-11-04</span> <span>01:30-05:00</span></tt>. How would you write a function that takes the <tt><span>2018-11-04</span> 01:30</tt> portion of that datetime, and returns the correct answer? You can&#39;t, because there are <em>two</em> correct answers.</p>
<p><tt>pytz</tt> is able to solve this problem because during the <tt>localize</tt> step, the time zone could take in the additional information of whether you wanted to be on the DST or STD side of the transition:</p>
<div><pre><span></span><span>dt_dst</span> <span>=</span> <span>NYC</span><span>.</span><span>localize</span><span>(</span><span>datetime</span><span>(</span><span>2018</span><span>,</span> <span>11</span><span>,</span> <span>4</span><span>,</span> <span>1</span><span>,</span> <span>30</span><span>),</span> <span>is_dst</span><span>=</span><span>True</span><span>)</span>
<span>print</span><span>(</span><span>dt_dst</span><span>)</span>
<span># 2018-11-04 01:30:00-04:00</span>

<span>dt_std</span> <span>=</span> <span>NYC</span><span>.</span><span>localize</span><span>(</span><span>datetime</span><span>(</span><span>2018</span><span>,</span> <span>11</span><span>,</span> <span>4</span><span>,</span> <span>1</span><span>,</span> <span>30</span><span>),</span> <span>is_dst</span><span>=</span><span>False</span><span>)</span>
<span>print</span><span>(</span><span>dt_std</span><span>)</span>
<span># 2018-11-04 01:30:00-05:00</span>
</pre></div>
<p>This is because some of the information about the <tt>datetime</tt> (which side of DST it represents) is now encoded in the <tt>tzinfo</tt> that was attached to it. Using the standard Python interface, this problem was not solved until Python 3.6 with the introduction of <a href="https://www.python.org/dev/peps/pep-0495/">PEP 495</a>, which added the <tt>fold</tt> attribute to the <tt>datetime</tt> class. This allows the &#34;which side of an ambiguous datetime do I fall on&#34; decision to be encoded <em>in the datetime itself</em>, allowing for lazy calculation of ambiguous datetimes. If <tt>dt.fold</tt> is 0, ambiguous datetimes resolve to the <em>first</em> occurrence of a time in a given zone, if it&#39;s 1, they resolve to the <em>second</em> occurrence. So to represent the example above:</p>
<div><pre><span></span><span>from</span> <span>dateutil</span> <span>import</span> <span>tz</span>
<span>NYC_du</span> <span>=</span> <span>tz</span><span>.</span><span>gettz</span><span>(</span><span>&#39;America/New_York&#39;</span><span>)</span>

<span>dt_dst</span> <span>=</span> <span>datetime</span><span>(</span><span>2018</span><span>,</span> <span>11</span><span>,</span> <span>4</span><span>,</span> <span>1</span><span>,</span> <span>30</span><span>,</span> <span>fold</span><span>=</span><span>0</span><span>,</span> <span>tzinfo</span><span>=</span><span>NYC_du</span><span>)</span>
<span>print</span><span>(</span><span>dt_dst</span><span>)</span>
<span># 2018-11-04 01:30:00-04:00</span>

<span>dt_std</span> <span>=</span> <span>datetime</span><span>(</span><span>2018</span><span>,</span> <span>11</span><span>,</span> <span>4</span><span>,</span> <span>1</span><span>,</span> <span>30</span><span>,</span> <span>fold</span><span>=</span><span>1</span><span>,</span> <span>tzinfo</span><span>=</span><span>NYC_du</span><span>)</span>
<span>print</span><span>(</span><span>dt_std</span><span>)</span>
<span># 2018-11-04 01:30:00-05:00</span>
</pre></div>
<p>Additionally, <tt>dateutil</tt> is able to backport this to earlier versions of Python by providing a <tt>tz.enfold</tt> function that will, if necessary, create a <tt>datetime</tt> subclass providing the <tt>fold</tt> attribute. So, on Python 2.7 you get:</p>
<div><pre><span></span><span>&gt;&gt;&gt; </span><span>tz</span><span>.</span><span>enfold</span><span>(</span><span>datetime</span><span>(</span><span>2018</span><span>,</span> <span>11</span><span>,</span> <span>4</span><span>,</span> <span>1</span><span>,</span> <span>30</span><span>),</span> <span>fold</span><span>=</span><span>0</span><span>)</span>
<span>datetime.datetime(2018, 11, 4, 1, 30)</span>

<span>&gt;&gt;&gt; </span><span>tz</span><span>.</span><span>enfold</span><span>(</span><span>datetime</span><span>(</span><span>2018</span><span>,</span> <span>11</span><span>,</span> <span>4</span><span>,</span> <span>1</span><span>,</span> <span>30</span><span>),</span> <span>fold</span><span>=</span><span>1</span><span>)</span>
<span>_DatetimeWithFold(2018, 11, 4, 1, 30)</span>
</pre></div>
<p>Now that this issue is resolved, <tt>pytz</tt> no longer has the advantage of being the best way to handle ambiguous datetimes, but retains the <em>disadvantage</em> of its somewhat clunky interface and eagerly-calculated time zone information.</p>
</div>

<div id="conclusions">
<h2>Conclusions</h2>
<p>At the time of its creation, <tt>pytz</tt> was cleverly designed to optimize for performance and correctness, but with the changes introduced by PEP 495 and the performance improvements to <tt>dateutil</tt>, the reasons to use it are dwindling. As mentioned in the previous sections, there are some use cases where <tt>pytz</tt>&#39;s IANA time zones are faster, but common use cases where they are slower as well. Historically, they provided a &#34;more correct&#34; time zone implementation, but now they solve the ambiguous time problem in a way that is inconsistent with Python&#39;s time zone model.</p>
<p>The biggest reason to use <tt>dateutil</tt> over <tt>pytz</tt> is the fact that <tt>dateutil</tt> uses the standard interface and <tt>pytz</tt> doesn&#39;t, and as a result it is very easy to <tt>pytz</tt> incorrectly. Even if <em>you</em> now know the right way to use <tt>pytz</tt>, are you sure that you&#39;re not going to pass your datetime to a function expecting something that uses the standard <tt>tzinfo</tt> interface? Are you sure that anyone maintaining your code or consuming its outputs are going to know to avoid these mistakes?</p>
</div>

</div>
  </article>
</section>


    </div></div>
  </body>
</html>
