<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://smlx.dev/posts/goodwe-sems-protocol-teardown/">Original</a>
    <h1>Reverse-engineering an encrypted IoT protocol</h1>
    
    <div id="readability-page-1" class="page"><div><h2 id="tldr"><a href="#tldr">##</a>
TL;DR</h2><ul><li>I reverse-engineered the encrypted protocol <a href="https://www.goodwe.com.au/">GoodWe</a> smart meters and solar inverters use to send metrics to the cloud.</li><li>I used this research to build a <a href="https://github.com/smlx/goodwe-exporters">prometheus exporter</a>.</li></ul><h2 id="the-sun-so-hot-right-now"><a href="#the-sun-so-hot-right-now">##</a>
The Sun: so hot right now</h2><p>I got a solar <abbr title="Photovoltaic">PV</abbr> system installed in my house in mid 2023.
I did the bare minimum of research beforehand - just talked to a couple of different installers about pricing, sizing and the economics of a battery.</p><p>One thing I certainly did <em>not</em> do is any research into brands and their relative hackability or security merits.
I just specified that I wanted to monitor the devices and see some metrics.
The installer told me that this required a smart meter and a mobile app.
Honestly I assumed that all brands would be equally horrific <abbr title="Internet of Things">IoT</abbr> junk, so I just went with the recommendation of the installer.
At least that way the <em>electrical</em> functionality had to be reasonable, right?</p><p>The result of my lucky dip was a <a href="https://www.goodwe.com.au/dns-g3-au">GoodWe DNS G3 Inverter</a> and a <a href="https://www.goodwe.com.au/single-phase-homekit">GoodWe HomeKit 1000 Smart Meter</a>.
These devices look quite slick, and so does the website.
They are also popular here in Australia, so my hopes were high that it would be easy to set up local monitoring, because surely someone else had figured out how to do it.</p><h2 id="post-install-setup"><a href="#post-install-setup">##</a>
Post-install setup</h2><h3 id="metrics-you-need-to-be-online"><a href="#metrics-you-need-to-be-online">###</a>
Metrics? You need to be online.</h3><p>Right after physical installation the system is producing power, but the metrics aren’t visible anywhere.
The documented way to see metrics is to connect the device to GoodWe’s cloud, and then use their web <abbr title="User Interface">UI</abbr> or mobile app.</p><p>The devices act in simultaneous wireless <abbr title="Access Point">AP</abbr> and <abbr title="Station (client)">STA</abbr> modes, and setup works like so:</p><ol><li>Connect to the device’s <abbr title="Wireless Local Area Network">WLAN</abbr>, which will be named <code>Solar-WiFiXXXXXXXX</code>, where the <code>X</code>s are the serial number of the device. The password is, naturally, <code>admin</code>.</li><li>Visit the device’s web <abbr title="User Interface">UI</abbr> on <code>10.10.100.253</code>.</li><li>Log in (using credentials <code>admin</code> / <code>admin</code>, of course!).</li><li>In the web <abbr title="User Interface">UI</abbr>, select the <abbr title="Wireless Local Area Network">WLAN</abbr> that you want the device to use to connect to the Internet.</li></ol><p>Now the devices are connected to GoodWe’s cloud.
But you still can’t see any metrics.</p><h3 id="sems-portal-account-required"><a href="#sems-portal-account-required">###</a>
SEMS Portal account required</h3><p>The next step is to go to GoodWe’s <a href="https://www.semsportal.com"><abbr title="Smart Energy Management System">SEMS</abbr> Portal</a> and create an account.
Then let the installer know that the devices are connected, and the email you used to create an account on the <abbr title="Smart Energy Management System">SEMS</abbr> Portal.
Then the installer will <em>email</em> GoodWe (!?) to tell them to assocate your account with the serial number of the devices, and at some point GoodWe will action that request (I was assured they checked their inbox regularly).</p><p>Finally after a day or so the device’s metrics are visible in the <abbr title="Smart Energy Management System">SEMS</abbr> Portal.</p><p><img src="https://words.filippo.io/dispatches/secure-elements/sems.png" alt="Screenshot of SEMS portal showing power usage over a day" title="" width="867" height="270"/></p><p>According to <a href="https://en.goodwe.com/Ftp/EN/Downloads/Datasheet/GW_SEMS_Flyer-EN.pdf">this flyer</a>, it seems that the installer would have a portfolio of “power plants”, and they can use the <abbr title="Smart Energy Management System">SEMS</abbr> Portal to perform “Fault self-analysis &amp; troubleshooting”.</p><blockquote><p>SEMS includes a range of functions and features to ensure reliable operation and to deliver precise information to operators at the press of a button. It is accessible by multiple accounts with different levels of access for owners, installers and EPC companies</p></blockquote><h2 id="post-setup-state-of-play"><a href="#post-setup-state-of-play">##</a>
Post-setup state of play</h2><p>So now these two devices were physically installed, and connected to GoodWe’s cloud over the internet via my isolated <abbr title="Internet of Things">IoT</abbr> <abbr title="Virtual Local Area Network">VLAN</abbr>.
But I had questions:</p><ol><li>I wanted to scrape metrics locally, dammit! Why should I have to use the crappy cloud <abbr title="User Interface">UI</abbr> or equally bad mobile app?</li><li>What else can GoodWe do with this connection? E.g. can they remotely administer the devices? If so, can I disable this “feature”?</li></ol><p>It turns out that the inverter is powered by the solar panels, not by the grid.
So it loses power and goes offline as soon as the sun goes down.
And since I mostly have time to hack on this stuff after dark, I concentrated on the smart meter.</p><p>There is quite a cottage industry online documenting how to extract data from GoodWe <em>inverters</em>.
They respond to <a href="https://en.wikipedia.org/wiki/Modbus">Modbus</a> queries, an <a href="https://en.wikipedia.org/wiki/Operational_technology">Operational Technology</a> standard.
There are many Github repositories with useful information about the GoodWe Modbus protocol, such as:</p><ul><li>a <a href="https://github.com/marcelblijleven/goodwe">python library for extracting metrics</a>;</li><li>a <a href="https://github.com/mletenay/home-assistant-goodwe-inverter">Home Assistant integration</a>, built on that library; and</li><li>some <a href="https://github.com/tkubec/GoodWe/wiki">GoodWe-specific</a> <a href="https://github.com/MiG-41/Modbus-GoodWe-DT">field documentation</a>.</li></ul><p>Unfortunately, my Homekit 1000 smart meter is not supported by any of these libraries.</p><h2 id="hacking-the-homekit-1000"><a href="#hacking-the-homekit-1000">##</a>
Hacking the Homekit 1000</h2><p>I’m presenting the process I followed in chronological order.
So if you want to find out what actually worked, skip to the end.</p><h3 id="nmap"><a href="#nmap">###</a>
nmap</h3><p>The first thing I did was fire up <code>nmap</code>, and point it at the <abbr title="Homekit 1000">HK1000</abbr>.
It showed listening <abbr title="Transmission Control Protocol">TCP</abbr> port <code>23</code> - good old <a href="https://en.wikipedia.org/wiki/Telnet">Telnet</a>!
Connecting to this port and trying Username: <code>admin</code>, Password: <code>admin</code> gave me a command prompt!</p><pre tabindex="0"><code>$ nc 192.168.18.17 23
Login as:admin
Password:admin
CMD&gt;?
cfg         net         os          mft         
CMD&gt;
</code></pre><p>Poking around this prompt soon showed that it was pretty limited<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup>, and it seemed to be a development interface that was left enabled.
I couldn’t get any metrics out of it.</p><p>I also ran <code>nmap</code> in aggressive mode and was rewarded with a hard crash in the web server, and the device resetting back to factory settings.</p><h3 id="packet-capture"><a href="#packet-capture">###</a>
Packet capture</h3><p>Sniffing the traffic from the device showed that it was connecting out to <code>tcp.goodwe-power.com:20001</code>, and sending packets at regular intervals.
However a quick look at the traffic revealed that while the serial number of my inverter was visible, the main body of the payload was a high-entropy blob.
So the metrics data I was after seemed to be encrypted.</p><p>I also found <a href="https://github.com/mletenay/home-assistant-goodwe-inverter/issues/3#issuecomment-1523697494">a Github comment</a> which came to the same conclusion.</p><h3 id="modbus"><a href="#modbus">###</a>
Modbus</h3><p>There is a <a href="https://github.com/jantenhove/GoodWeLogger/files/6024769/Goodwe_Modbus_PROTOCOL_Grid_English-ningzenkun20200527.1.pdf">GoodWe Modbus protocol</a> spec sheet and register map floating around the internet which was invaluable in understanding how GoodWe encodes metrics from their inverters.
From this documentation I built a Modbus scanner that simply queried every register.
The address is only 2 bytes wide, so there are ~65k possible addresses.</p><p>Unfortunately the <abbr title="Homekit 1000">HK1000</abbr> only returns a value for a single register address.
I forget which register it was, but it was something useless like Firmware Version.</p><h3 id="aa55-protocol"><a href="#aa55-protocol">###</a>
AA55 protocol</h3><p>GoodWe devices also support another (older?) protocol known as the AA55 protocol.
I couldn’t find much info about it except for <a href="https://yamasun.com.tw/upload/F_20170313191367UrC8jo.PDF">another old spec sheet</a>.</p><p>I built a scanner for this too, but the <abbr title="Homekit 1000">HK1000</abbr> didn’t respond to any queries.</p><h3 id="zz5a5a-protocol-mobile-app"><a href="#zz5a5a-protocol-mobile-app">###</a>
ZZ/5A5A protocol (mobile app)</h3><p>The <abbr title="Smart Energy Management System">SEMS</abbr> portal mobile app has an interesting function where you can connect to the <code>SOLAR-Wifixxxx</code> network, and configure the device using the app but <em>without</em> any authentication.</p><p>Sniffing this traffic (thanks to <a href="https://aircrack-ng.org/doku.php?id=airodump-ng">airodump-ng</a> and <a href="https://wiki.wireshark.org/HowToDecrypt802.11">Wireshark’s WPA2 decrypt support</a>) shows that the device can be configured without authentication by sending plaintext <abbr title="User Datagram Protocol">UDP</abbr> packets to the right port.
Of course, this port is listening on all interfaces so it also probably works via whichever local wifi network you connect the device to.
Gross.</p><p><img src="https://words.filippo.io/dispatches/secure-elements/zz-protocol.png" alt="Screenshot of UDP dump showing the ZZ protocol" title="" width="552" height="91"/></p><p>However, this protocol appeared to <em>only</em> be used for network configuration.
I didn’t find any way of extracting data from the device using this protocol.</p><h3 id="firmware-reverse-engineering"><a href="#firmware-reverse-engineering">###</a>
Firmware Reverse Engineering</h3><p>After no success with the query protocols, I decided that maybe the network was the wrong approach and I should try firmware instead.
I managed to dump the firmware of the device using the command prompt and a command similar to this<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup>:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>echo -e <span>&#39;admin\nadmin\nspi rd 0 2097152\n&#39;</span> | nc 192.168.18.17 <span>23</span> | tee ~/download/hk1000.spi2.img
</span></span></code></pre></div><p>This hexdump is interspersed with log lines, and the bytes are transposed.
So I dumped it twice, diffed the two dumps to eliminate the log lines, and fixed the transposition manually using vim.</p><p>Then I <a href="https://docs.python.org/3/library/binascii.html#binascii.unhexlify">unhexlified</a> the binary with <a href="https://manpages.debian.org/testing/xxd/xxd.1.en.html">xxd</a>:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>xxd -r -p hk1000.spi.img &gt; hk1000.spi.bin.img
</span></span></code></pre></div><p>And ran <a href="">binwalk</a> over it:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>binwalk -eM hk1000.spi.bin.img
</span></span></code></pre></div><p>This revealed that the OS was <a href="https://www.ecoscentric.com/ecos/index.shtml">eCos RTOS</a> on a <a href="https://en.wikipedia.org/wiki/MIPS_architecture">MIPS architecture</a>.
I spent some time trying to reverse this binary using <a href="https://ghidra-sre.org/">Ghidra</a>, but honestly I just don’t know what I’m doing when it comes to binary reverse engineering.</p><p>Finally, while staring at the binwalk output, these lines caught my eye:</p><pre tabindex="0"><code>1976456       0x1E2888        AES Inverse S-Box
1977752       0x1E2D98        AES S-Box
</code></pre><h3 id="packet-capture-redux"><a href="#packet-capture-redux">###</a>
Packet Capture redux</h3><p>Going back to the packet capture I finally noticed that the length of the encrypted blob section was always a multiple of 16, plus 2.</p><p>Wait a second… <a href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard"><abbr title="Advanced Encryption Standard">AES</abbr></a> block size is 16 bytes!</p><h2 id="analysis-of-the-goodwe-metrics-protocol"><a href="#analysis-of-the-goodwe-metrics-protocol">##</a>
Analysis of the GoodWe metrics protocol</h2><p>Since this is was a black-box analysis, I had to rely on probing via the <abbr title="Input / Output">I/O</abbr> I controlled: network and power.</p><h3 id="network-glitching3"><a href="#network-glitching3">###</a>
Network “glitching”<sup id="fnref:3"><a href="#fn:3" role="doc-noteref">3</a></sup></h3><p>It was at this point that I found what would be the key to cracking the encryption scheme.</p><p>Back in October 2021, someone else did basically all the same work I did, and presented it at the <a href="https://www.mlug-au.org">Melbourne Linux User’s Group</a>.
Not only that, but they put their presentation <a href="https://www.mlug-au.org/lib/exe/fetch.php?media=20210726-goodwe.pdf">online</a>!
Thank you Danny!</p><p>Anyway, Danny made a very interesting observation: if the internet connection went down, the device would buffer messages, and send them all at once when the connection came back up.
Crucially, for buffered frames sent in the same second, the first few 16-byte blocks of ciphertext were identical!</p><p>I was able to replicate this locally!</p><h3 id="empathy-a-powerful-reverse-engineering-tool"><a href="#empathy-a-powerful-reverse-engineering-tool">###</a>
Empathy: a powerful reverse-engineering tool</h3><p>When I’m looking at a problem like this, I like to put myself in the shoes of the developer.
What kind of person are they?
What are their motivations?</p><p>In this case, we can observe:</p><ul><li>Telnet left on in a production firmware image, with credentials <code>admin:admin</code>.</li><li><code>nmap</code> can crash the device hard enough to factory reset.</li><li>Packets sent over <abbr title="Transmission Control Protocol">TCP</abbr> with identifying data (serial number) in the clear.</li><li>The metrics seem to be poorly encrypted (identical section of ciphertext in consecutive frames).</li><li>Unauthenticated configuration protocol.</li><li>A web <abbr title="User Interface">UI</abbr> that looks like it was hacked together in an afternoon. Inspecting the source shows lots of commented out HTML blocks.</li></ul><p>In Danny’s presentation, he used this slide after discovering the Telnet port password:</p><p><img src="https://words.filippo.io/dispatches/secure-elements/telnet-password.png" alt="Picard facepalm meme" title="" width="631" height="460"/></p><p>However I think this is more appropriate:</p><p><video title="Michael Scott wow meme" autoplay="" loop="" muted="" playsinline="">
<source src="michael-scott-wow.mp4" type="video/mp4"/>There should have been an animation here but your browser doesn&#39;t seem to
support it.</video></p><p>What these observations tell me is that GoodWe doesn’t put a great deal of effort into securing their devices, and therefore the developers working on this device didn’t have much incentive to create a secure protocol.
So there’s a chance I can hack around their encryption.</p><p>Putting myself into the shoes of these developers, what would I need to implement a metric protocol?</p><ul><li>Framing: this is <abbr title="Transmission Control Protocol">TCP</abbr>; it’s a byte stream. So we need a header of some kind to know where frames start.</li><li>Length: how many bytes after the header do we need to read to get the full frame?</li><li>Detecting data corruption: not anything malicious, just bitflips.</li></ul><p>Looking at the packet captures, it is easy to see <code>POSTGW</code> is the frame header, and the very next field looks like a big-endian encoded int32 with a value consistently three bytes shy of the length of the data before the next <code>POSTGW</code>.
That must be the length!</p><p>And finally: detecting data corruption.
In the GoodWe Modbus document linked above, there is a description of the <abbr title="Cyclic Redundancy Check">CRC</abbr> used to detect data corruption.
It is a standard <a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check#Polynomial_representations">Modbus CRC-16</a> (two bytes), designed to effectively detect bitflips.
Again, assuming I am a software developer who is familiar with Modbus but who has been tasked with sending data over the internet (and didn’t really care much for security), why wouldn’t I use an algorithm or library I am already familiar with?</p><p>A quick check proves that running the data between the length field and the last two bytes through the Modbus <abbr title="Cyclic Redundancy Check">CRC</abbr> algorithm returns a value matching the last two bytes of the frame.</p><figure><img src="https://words.filippo.io/dispatches/secure-elements/postgw.png" alt="Annotated hexdump of protocol frame showing the components"/><figcaption><h4>An annotated frame, with length in red, device type and serial in green, timestamp in blue and purple, and encrypted blob in yellow.</h4></figcaption></figure><p>My best guess for the length field being <em>three</em> bytes shy of the length of data rather than two is that it is just a sloppy implementation with an off-by-one error, which matches my profile of the developers.</p><p>Another data point to paint a picture of the engineering quality: the <abbr title="Cyclic Redundancy Check">CRC</abbr> of frames from the client are encoded in big-endian byte order (same as all the other integers encoded in the protocol).
However the <em>server</em> sends the <abbr title="Cyclic Redundancy Check">CRC</abbr> in little-endian byte order.
Why?
Maybe the server is <code>x86</code> and the developer forgot to call <a href="https://pubs.opengroup.org/onlinepubs/9699919799/functions/htonl.html"><code>htons()</code></a>?</p><p>Now I just had the encrypted blob to decipher.</p><h3 id="encryption-scheme"><a href="#encryption-scheme">###</a>
Encryption scheme</h3><p>I guessed that they must be using <abbr title="Advanced Encryption Standard">AES</abbr> in <a href="https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Cipher_block_chaining_(CBC)"><abbr title="Cipher Block Chaining">CBC</abbr></a> mode because:</p><ul><li>The identical section of ciphertext in consecutive frames is a <a href="https://cwe.mitre.org/data/definitions/329.html">classic <abbr title="Cipher Block Chaining">CBC</abbr> failure mode</a> when reusing <abbr title="Initialization Vector">IV</abbr>s.</li><li>This is an old mode and widely supported in libraries, making it easy to use.</li><li>Since they don’t care about security they are hardly likely to be using <abbr title="Authenticated Encryption with Additional Data">AEAD</abbr> modes.</li></ul><p>When implementing a scheme using <abbr title="Cipher Block Chaining">CBC</abbr>, it is critically important that initialization vectors are not reused.
Otherwise identical plaintext will give you identical ciphertext.
Metrics from a smart meter are highly likely to be the same minute-to-minute, which is probably why we see identical sections of ciphertext in successive frames with the same <abbr title="Initialization Vector">IV</abbr>!</p><p>A common practice is to prefix the <abbr title="Initialization Vector">IV</abbr> to the ciphertext.
This is known as an explicit initialization vector, and it doesn’t need to be secret - just randomly generated in a cryptographically secure manner.
However what if you are running on a microcontroller without a <a href="https://en.wikipedia.org/wiki/Hardware_random_number_generator"><abbr title="Non-deterministic Random Bit Generator">NRBG</abbr></a>? Or maybe you just don’t know or care about <abbr title="Cipher Block Chaining">CBC</abbr> footguns?
Then you have to use some other “unique-ish” value!</p><p>The device is designed to only send metrics every minute.
Therefore the developers may have assumed that time based <abbr title="Initialization Vector">IV</abbr>s will be unique enough, without taking into account buffering on network outage.</p><h3 id="power-glitching"><a href="#power-glitching">###</a>
Power “glitching”</h3><p>The final and most difficult question: what is the encryption key?</p><p>The first thing I checked was what happened when the device rebooted: was there any key exchange or handshake?
Fortunately the web <abbr title="User Interface">UI</abbr> has a reboot button, so it was easy to confirm that no, there is no key exchange on startup.</p><p>So because we are assuming <abbr title="Advanced Encryption Standard">AES</abbr> (symmetric encryption), that probably means… fixed keys!</p><p>Since the keys are fixed, they are likely hard-coded.
<abbr title="Advanced Encryption Standard">AES</abbr> can use 16, 24, or 32 byte keys, so I started by assuming a 16-byte key.
I suspected they’d use some string like <code>GoodWeSolarPower</code>, and store it as a static string or byte array.
I poked around in the firmware a bit with Ghidra, but didn’t find any promising strings.</p><p>But in any case, there was another problem.
One of the properties of <abbr title="Advanced Encryption Standard">AES</abbr>-<abbr title="Cipher Block Chaining">CBC</abbr> is that you can plug <em>any</em> <abbr title="Initialization Vector">IV</abbr> and secret key into it and it will “decrypt”.
But unless the <abbr title="Initialization Vector">IV</abbr> and key are correct, the output will be garbage.
So how to know if I manage to correctly guess the <abbr title="Initialization Vector">IV</abbr> and key?</p><p>At this point I made another educated guess.
The frame header and length field use <a href="https://en.wikipedia.org/wiki/ASCII"><abbr title="American Standard Code for Information Interchange">ASCII</abbr></a> characters and leading null bytes respectively.
Assuming the plaintext metric data is similarly structured, it will have relatively low <a href="https://en.wikipedia.org/wiki/Entropy_(information_theory)">Shannon entropy</a>.
Another property of <abbr title="Advanced Encryption Standard">AES</abbr> is that it is a <a href="https://crypto.stackexchange.com/a/1651">secure block cipher</a>.
That is, the ciphertext should be indistinguishable from random bytes.
Therefore, using the incorrect key or <abbr title="Initialization Vector">IV</abbr> should result in <em>high entropy</em> garbage.</p><p>Assuming the timestamp in the frame (which is null-padded to 16 bytes) is the <abbr title="Initialization Vector">IV</abbr>, I wrote a really dumb tool to:</p><ol><li>step through the firmware one byte at a time, taking the next 16 bytes as a key.</li><li>“decrypt” the encrypted blob using that key, and the timestamp prefix as the <abbr title="Initialization Vector">IV</abbr>.</li><li>calculate the entropy of the decrypted blob. If it is below a given threshold, print the plaintext and key.</li></ol><p>Fortunately although this was a very naïve brute force algorithm, one great thing about 2024 is that computers are fast.</p><p>Running this tool over the firmware dump from my device only took a few seconds and yielded… nothing.
Huh.</p><p>Fortunately my previous googling efforts had discovered a <a href="https://drive.google.com/drive/folders/110hBxoNVC4M9F_GK5sKP7uq_aDNxwstZ">public Google drive</a> with relatively recent updates (early 2023) containing firmware for (all?) GoodWe inverters<sup id="fnref:4"><a href="#fn:4" role="doc-noteref">4</a></sup>.
Running the tool over a firmware image for another device yielded… nothing again!</p><p>Finally on the third attempt, I got a single hit:</p><p><img src="https://words.filippo.io/dispatches/secure-elements/key.png" alt="Screenshot of the firmware scan tool showing plaintext, the key used for decryption, and an entropy calculation of 2.862" title="" width="818" height="280"/></p><p>Of course!
The key was just all bits set.
Why not!?</p><p>I doubt this was actually hard-coded as a key anywhere in the binary blob.
I think I just got lucky that this firmware had a run of <code>0xff</code> bytes.</p><p>Finally I had a plaintext with obvious structure, but nothing mapping fields to metrics values.
However I did have an <a href="https://en.wikipedia.org/wiki/Oracle_machine#Oracles">oracle</a>: the <abbr title="Smart Energy Management System">SEMS</abbr> Portal API!
I was able to dump metric values for my smart meter using <a href="https://curl.se/">curl</a> on the <abbr title="Smart Energy Management System">SEMS</abbr> Portal API, and observe the metrics changing every time a packet was sent from the smart meter.</p><p>Then by eyeballing the packets and the values (assuming standard <a href="https://en.wikipedia.org/wiki/Two%27s_complement">two’s complement</a> signed integer encoding) it was relatively straightforward, though a little time consuming, to map offsets to metrics values.</p><p>This wiring diagram was helpful to understand that there were really only two <abbr title="Current Transformer">CT</abbr> sensors and every other metric was calculated from those two numbers:</p><p><img src="https://words.filippo.io/dispatches/secure-elements/hk-wiring.png" alt="High-level Homekit 1000 wiring diagram" title="" width="924" height="358"/></p><h2 id="prometheus--grafana"><a href="#prometheus--grafana">##</a>
Prometheus &amp; Grafana</h2><p>I like <a href="https://prometheus.io/">Prometheus</a> for gathering metrics.
So I built an <a href="https://github.com/smlx/goodwe-exporters">exporter</a> based on the research described above.
It works by conducting a <a href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack">man-in-the-middle attack</a> on the protocol.
Pointing the <abbr title="Homekit 1000">HK1000</abbr> at the <abbr title="Internet Protocol">IP</abbr> address of the exporter when it requests <code>tcp.goodwe-power.com</code> will cause the <abbr title="Homekit 1000">HK1000</abbr> to connect to the exporter instead of the GoodWe cloud.
Then the exporter will sniff the metrics out of the frames and forward them to the real <code>tcp.goodwe-power.com</code>.</p><p>The nice thing about this design is that you still get metrics in <abbr title="Smart Energy Management System">SEMS</abbr> Portal.
These metrics are visible to your installer, so if you have problems it is easy for them to troubleshoot.
I also added support for my inverter, which uses approximately the same protocol.</p><p>In addition, the Prometheus exporter will reject any packets from the server that it doesn’t understand.
So <em>hopefully</em> unsolicited firmware updates will be blocked.</p><p>Finally, I created a <a href="https://grafana.com/grafana/dashboards/20479-household-power/">dashboard</a> in <a href="https://grafana.com/">Grafana</a>:</p><p><img src="https://words.filippo.io/dispatches/secure-elements/grafana.png" alt="Household Power Grafana dashboard, showing a summary of power usage over a single day" title="" width="1007" height="396"/></p><h2 id="conclusions"><a href="#conclusions">##</a>
Conclusions</h2><ul><li>This exercise has reinforced my prejudice that <abbr title="Internet of Things">IoT</abbr> devices are horribly insecure. In the case of GoodWe, where they even <em>have</em> authentication, they use fixed default passwords such as <code>admin</code>, and leave Telnet debug interfaces listening on their production devices.</li><li>Although the metrics protocol and encryption scheme are insecure, I didn’t find anything that could really be described as a security vulnerability as opposed to a design decision.</li><li>Only the metrics were encrypted in the data sent to <abbr title="Smart Energy Management System">SEMS</abbr> Portal over the internet.
Not the model or serial number.
So even with (bad) encryption, they have left the most sensitive data unprotected.
I guess they are just obfuscating the metrics?
Or maybe the boss asked for encryption?
<a href="https://youtu.be/_k7U55anSW8?t=132">“He said encryption! Give him encryption!”</a>.</li><li>Conversely the <em>hardware</em> seems pretty good, functions well, and looks great!</li><li>I spent months tinkering on this on-and-off.
I was motivated by equal parts indignant anger at not being able to scrape metrics locally from a device so intimately integrated into <em>my</em> house and running on <em>my</em> network, and morbid curiosity about what security flaw I was going to uncover next.
Now I understand what jwz means when he talks about <a href="https://www.jwz.org/hacks/">writing software in self-defence</a>.</li></ul><h2 id="how-to-secure-goodwe-devices"><a href="#how-to-secure-goodwe-devices">##</a>
How to secure GoodWe devices</h2><p>Finally, here’s my advice if you have a GoodWe device:</p><ul><li>Whatever else you do, keep these things off the public internet!
Preferably in your private, firewalled <abbr title="Internet of Things">IoT</abbr> <abbr title="Virtual Local Area Network">VLAN</abbr>.</li><li>There doesn’t seem to be a simple way to disable the <code>Solar-Wifixxxx</code> <abbr title="Wireless Local Area Network">WLAN</abbr> after the devices are set up.
So set a strong password, because the default is <code>admin</code>.
You can do this via the web <abbr title="User Interface">UI</abbr>.</li><li>The web server is listening on all interfaces, so it is accessible from your <abbr title="Virtual Local Area Network">VLAN</abbr>.
Change the password for the web UI from <code>admin</code> to something a bit more secure.
Note: not all devices have this option easily accessible.
For example the <abbr title="Homekit 1000">HK1000</abbr> only allows changing this password via the Telnet interface.</li></ul><p>For the paranoid:</p><ul><li>My prometheus exporter drops incoming packets it doesn’t recognize. Only metrics will flow, not e.g. firmware updates (I hope - I haven’t seen any come through yet). So in theory it will block remote administration of the devices.</li></ul><h2 id="miscellaneous-notes"><a href="#miscellaneous-notes">##</a>
Miscellaneous notes</h2><p>This section contains a few notes I made that didn’t fit into the narrative of the blog post, but are interesting nonetheless.</p><h3 id="goodwes-cyber-security-claims"><a href="#goodwes-cyber-security-claims">###</a>
GoodWe’s Cyber Security claims</h3><p>GoodWe has a page on Cyber Security on their website with a nice infographic, basically confirming everything I have just discovered:</p><blockquote><p>In order to prevent cyber-attacks on photovoltaic systems to the greatest extent, inverter manufacturers usually deploy various security policies on the equipment side and server side. Taking GoodWe as an example, to ensure the security of data transmission between the inverter and the server, we use the transmission protocols of CRC+AES and TLS respectively for communication with servers with different functions.</p></blockquote><p><img src="https://words.filippo.io/dispatches/secure-elements/goodwe-cyber.png" alt="Infographic diagram of an inverter and a laptop connecting to the cloud. The inverter connection has a lock icon and is labelled AES 128. The laptop connection also has a lock icon and is labelled HTTPS." title="" width="909" height="548"/></p><p>This is a great demonstration of how you can use secure cryptographic primitives such as <abbr title="Advanced Encryption Standard">AES</abbr>-<abbr title="Cipher Block Chaining">CBC</abbr>, and still come up with an insecure encryption scheme.</p><h3 id="hi-flying-and-xinwu"><a href="#hi-flying-and-xinwu">###</a>
Hi-Flying and Xinwu</h3><p>The GoodWe devices seem to use an <abbr title="Internet of Things">IoT</abbr> platform common to several Chinese manufacturers, for example <a href="https://github.com/StephanJoubert/home_assistant_solarman/blob/03470164fcad6b57d528f8c5b72dbc5603b0b2df/custom_components/solarman/scanner.py#L12">Solarman</a>.
It has a unique discovery protocol where you broadcast a special packet to a given port, and the device replies with its <abbr title="Internet Protocol">IP</abbr>, <abbr title="Medium Access Control">MAC</abbr>, and <abbr title="Service Set IDentifier">SSID</abbr> (which includes the device serial).</p><p>For example (in separate terminals):</p><div><pre tabindex="0"><code data-lang="bash"><span><span>nc -u -l -p <span>50123</span>
</span></span><span><span>192.168.18.17,907856FECDAB,Solar-WiFi12345678
</span></span></code></pre></div><div><pre tabindex="0"><code data-lang="bash"><span><span>echo -n WIFIKIT-214028-READ | nc -u -b -p <span>50123</span> 192.168.18.255 <span>48899</span>
</span></span></code></pre></div><p>According to the config dumped from the Telnet command prompt, the chip in the <abbr title="Homekit 1000">HK1000</abbr> is the <a href="http://www.hi-flying.com/hf-a21">HF-A21</a>, from a company called Hi-Flying, <a href="http://www.hi-flying.com/index.php?route=information/contact">based in Shanghai</a>.
You can build your <abbr title="Internet of Things">IoT</abbr> device on top of this platform by loading your own application onto it, while the included <abbr title="Operating System">OS</abbr> takes care of the hardware, network etc.</p><p>An interesting part of the discovery protocol is the string <code>214028</code>.
Where does this come from?
Well approximately 150km from the Hi-Flying office is <a href="https://en.wikipedia.org/wiki/Xinwu,_Wuxi">Xinwu district, Wuxi</a>.
According to Wikipedia:</p><blockquote><p>In 2013, the output value of Internet of Things (IoT) core industry in Wuxi New District exceeded 70 billion yuan, accounting for 38.4 percent of the output value of the whole high-tech industry in the district. Wuxi New District has formed a cloud computing industrial distribution, featuring hardware, platform and application.</p></blockquote><p>Xinwu’s postcode is 214028.</p><h3 id="remote-administration"><a href="#remote-administration">###</a>
Remote administration</h3><p>According to market researchers, GoodWe was the <a href="https://www.woodmac.com/press-releases/top-10-solar-pv-inverter-vendors-account-for-86-of-global-market-share/">fifth largest supplier of solar inverters worldwide in 2022</a>.
GoodWe have full remote administration capability on the devices, including the capability to <a href="https://www.4x4community.co.za/forum/showthread.php/329200-Goodwe-Remote-firmware-update">push firmware updates</a>.
This seems like a lot of power for any company, let alone a company headquartered in a totalitarian dictatorship, to have over national power grids.</p><h3 id="batman-mode"><a href="#batman-mode">###</a>
Batman mode</h3><p><del>To validate the <abbr title="Man-In-The-Middle">MITM</abbr> functionality</del> For fun, I implemented Batman mode in the prometheus exporter.
In this mode, rather than forwarding metrics to the <abbr title="Smart Energy Management System">SEMS</abbr> Portal, the exporter replaces them with the <a href="https://math.stackexchange.com/q/54506">batman equation</a>.</p><p><img src="https://words.filippo.io/dispatches/secure-elements/batman.png" alt="Screenshot of SEMS Portal showing batman logo plotted on the power graph" title="" width="648" height="766"/></p><h3 id="dns-updates"><a href="#dns-updates">###</a>
DNS updates</h3><p>The GoodWe devices send their metrics to <code>tcp.goodwe-power.com:20001</code>.
When I first started investigating the protocol in mid 2023, this resolved to an <abbr title="Internet Protocol">IP</abbr> address in Alibaba Cloud.
However late last year this was updated to now resolve to a pair of <abbr title="Elastic Load Balancer">ELB</abbr>s in <abbr title="Amazon Web Services">AWS</abbr>.</p><p><img src="https://words.filippo.io/dispatches/secure-elements/dns.goodwe-power.png" alt="Screenshot of SecurityTrails showing the historical DNS records for tcp.goodwe-power.com" title="" width="992" height="318"/>
<img src="https://words.filippo.io/dispatches/secure-elements/dns.semsportal.png" alt="Screenshot of SecurityTrails showing the historical DNS records for www.semsportal.com" title="" width="986" height="366"/></p><p>In both Alibaba Cloud and in <abbr title="Amazon Web Services">AWS</abbr> they seem to be doing <abbr title="Domain Name System">DNS</abbr> load balancing, because while the <a href="https://securitytrails.com/">SecurityTrails</a> screenshots above show <abbr title="United States">US</abbr> <abbr title="Internet Protocol">IP</abbr>s, from here in Australia both those domains resolved to <abbr title="Internet Protocol">IP</abbr>s in Alibaba Cloud China (previously), and now to <abbr title="Amazon Web Services">AWS</abbr> Sydney.</p></div></div>
  </body>
</html>
