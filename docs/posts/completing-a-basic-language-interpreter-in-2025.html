<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://nanochess.org/ecs_basic_2.html">Original</a>
    <h1>Completing a BASIC language interpreter in 2025</h1>
    
    <div id="readability-page-1" class="page"><div>

<div>

<p><img src="https://nanochess.org/img/ecsbasic_11.jpg" width="30%" alt="The printed source code of my UFO game. The paper roll is really old."/></p><p>
This is a follow-up to my previous article <a href="https://nanochess.org/ecs_basic.html">Developing a BASIC language in 2025</a>, where I describe how I got inspired to start coding a new BASIC interpreter for the 1983 Mattel ECS add-on for Intellivision.
</p>
<p>
Although my interpreter was already pretty fast and with enough statements to build games, I wasn&#39;t satisfied because it still missed one thing that the ECS BASIC implements: text strings. Only three, A$, B$, and C$, with SET, GET and PUT, for things like assigning a string, getting a name from the keyboard, or showing a name. Each string a maximum of 20 characters.
</p>
<p>
I thought about strings for four days, then I decided to code things like I know what I was doing.  I added a string stack pointer <i>bas_strptr</i> where any created string is added.
</p>
<div><p>
The first thing to implement was an array for the string variables (</p><tt>A$</tt><p>-</p><tt>Z$</tt><p>) each element pointing to the current string contained (or zero if none). I modified the whole of the expression parser to insert the type in the Carry flag (Clear = it is a number, Set = it is a string), then I made the first string support in the language where it detects if a string name appears (letter plus the $ sign) and reads it and copies it to a new string on the stack, returning this pointer as expression value (and of course the carry flag set)
</p></div>
<p>
The next step was assigning string variables, it simply took the pointer and stored it into the respective string variable pointer. Of course, I was afraid that I was creating a monster because I wasn&#39;t planning for the garbage collector.
</p>
<div><p>
Then I went full-steam ahead and put support in </p><tt>INPUT</tt><p>, </p><tt>PRINT</tt><p>, and added the concatenation of strings using the plus operator, also the functions </p><tt>ASC</tt><p>, </p><tt>CHR$</tt><p>, </p><tt>LEN</tt><p>, </p><tt>LEFT$</tt><p>, </p><tt>RIGHT$</tt><p>, </p><tt>MID$</tt><p>, </p><tt>INSTR</tt><p>, </p><tt>VAL</tt><p>, and </p><tt>STR$</tt><p>. By the way, the original Mattel ECS BASIC has none of these!
</p></div>
<p>
Now I had string support in my BASIC language for the ECS, but at some point in the execution it would fill up the stack, and crash with an &#34;Out of Memory&#34; error.
</p>
<h2>Garbage collection</h2>
<p>
It was kind of crazy having a BASIC with string support but no garbage collection. I needed a way to copy strings into the respective variable, and delete the work-in-progress strings created as expressions are evaluated.
</p>
<p>
It would be easy when having a C memory management system as you only have to replace the pointer, and free the original. But any memory management comes with headers and linked lists, extra memory requirements, and slowness. Given the Intellivision CP1610 processor is already slow enough (894 khz), I decided against it.
</p>
<p>
However, I noticed that temporary strings are only created inside the expression parser. So what about a double stack? One stack for strings in variables, and one stack for temporary strings.
</p>
<p>
I added a secondary pointer <i>bas_strbase</i> (I like how it sounds like star base)
</p>
<p>
At the start of each statement, <i>bas_strbase</i> is copied to <i>bas_strptr</i> (thus effectively erasing the temporary strings) A problem needed to be solved: growing <i>bas_strbase</i> on each string assignment.
</p>
<p>
I was going to implement the most simple solution: go over the 26 string variables doing comparison and movement of pointers, and insert the new string in its place.
</p>
<div><p>
Just as I was coding this, I noticed I had an easier solution. As I was working with 16-bit words, not all values are used. I could use a value like </p><tt>0xcafe</tt><p> to mark a non-used space, and boom! I had an idea.
</p></div>
<div><p>
When doing the assignment, delete the original string (fill it with </p><tt>0xcafe</tt><p> words), now explore the <i>strbase</i> area to find a string of </p><tt>0xcafe</tt><p> words big enough to save the new string.
</p></div>
<div><p>
The better part is when there is no space for the string, I simply copy the string pointer as the new </p><tt>bas_strbase</tt><p> pointer (effectively growing the base memory area), and all words between the end of the string and the previous </p><tt>bas_strbase</tt><p> pointer (ahead in memory) are filled with </p><tt>0xcafe</tt><p> words.
</p></div>
<p>
Full string support with garbage collection at very small price of performance. Exactly what a CP1610 processor needs.
</p>
<pre><small>
STRING_TRASH:	EQU $CAFE

    ;
    ; String assign.
    ; R1 = Pointer to string variable.
    ; R3 = New string.
    ;
string_assign:	PROC
    PSHR R5
    MVII #STRING_TRASH,R4

    ;
    ; Erase the used space of the stack.
    ;
    MOVR R3,R2
    MVI@ R2,R0
    INCR R2
    ADDR R0,R2
    MVI bas_strbase,R0
    CMPR R0,R2
    BC @@3
@@4:
    MVO@ R4,R2
    INCR R2
    CMPR R0,R2
    BNC @@4
@@3:
    ;
    ; Erase the old string.
    ;
    MVI@ R1,R2
    TSTR R2
    BEQ @@1
    MVI@ R2,R0
    MVO@ R4,R2
    INCR R2
    TSTR R0
    BEQ @@1
@@2:
    MVO@ R4,R2
    INCR R2
    DECR R0
    BNE @@2
    ;
    ; Search for space at higher-addresses.
    ;
@@1:
    MVII #start_strings-1,R2
    CMP bas_strbase,R2	; All examined?
    BNC @@6			; Yes, jump.
@@5:
    CMP@ R2,R4		; Space found?
    BNE @@7			; No, keep searching.
    CLRR R5
@@8:
    INCR R5
    DECR R2
    CMP bas_strbase,R2
    BNC @@9
    CMP@ R2,R4
    BEQ @@8
@@9:
    INCR R2
    MVI@ R3,R0
    INCR R0
    CMPR R0,R5		; The string fits?
    BNC @@7
    ;
    ; The string fits in previous space.
    ;
    MOVR R3,R4
    MOVR R2,R5
    MVO@ R2,R1		; New address.
@@10:
    MVI@ R4,R2
    MVO@ R2,R5
    DECR R0
    BNE @@10
    PULR PC

@@7:
    DECR R2
    CMP bas_strbase,R2
    BC @@5

    ;
    ; No space available.
    ;
@@6:
    MVO R3,bas_strbase	; Grow space for string variables.
    MVO@ R3,R1
    PULR PC
    ENDP
</small></pre> 
<div>
    <p><img src="https://nanochess.org/img/ecsbasic_14.gif" width="40%" alt="Program for my ECS BASIC interpreter."/> <img src="https://nanochess.org/img/ecsbasic_15.gif" width="40%"/></p></div>
<h2>Going mathematic</h2>
<p><img src="https://nanochess.org/img/ecsbasic_16.gif" width="30%" alt="BASIC mathematical functions on my ECS BASIC interpreter."/></p><p>
Since my floating-point library was complete with the four operations, I had an ace under the sleeve: I already had tested <i>sin</i> and <i>cos</i> functions with it, but for some reason these had a bug. For <i>sin(1°)</i> the resulting value was 0.0172.
</p>
<p>
These functions were ported from my <a href="https://nanochess.org/pascal.html">Pascal compiler for transputer</a>. As Pascal happens to have exactly the same mathematical function set as a BASIC interpreter.
</p>
<p>
After a whole day examining the operation instruction-by-instruction (the jzintv debugger shines here), I discovered that I did a comparison in the wrong way and corrected it.
</p>
<div><p>
I was so happy that I went immediately to port the remaining mathematical functions (</p><tt>ATN</tt><p>, </p><tt>TAN</tt><p>, </p><tt>LOG</tt><p>, </p><tt>EXP</tt><p>, and derived </p><tt>SQR</tt><p> and the power-of </p><tt>^</tt><p> operator). There were no pitfalls along the way, except one, my BASIC has a mantissa with one extra bit of precision, and </p><tt>EXP(LOG(64))</tt><p> returned 63.999999
</p></div>
<div><p>
Both operations use a multiplication with a constant (<i>log</i> does it at the end, and <i>exp</i> in the start). I noticed that the value was misrounded for 25 bits of mantissa, so I calculated a better constant, and et voila! </p><tt>EXP(LOG(64))</tt><p> returned 64.
</p></div>
<h2>Making it easier for the user</h2>
<div><p>
A lot of BASIC interpreters in the eighties didn&#39;t supported instructions for graphics. The Commodore 64 was particularly known for requiring </p><tt>POKE</tt><p> for almost anything, unless you had the somewhat expensive Simon BASIC cartridge.
</p></div>
<p>
However, in the Intellivision you have few graphics capabilities. In the Color Stack mode you have something called Colored Squares. This means each tile on the screen (20x12) can have four colors. This means a bloxel resolution of 40x24, and each bloxel can have one of eight colors (one being the background).
</p>
<div><p>
I implemented </p><tt>PLOT</tt><p> with these limitations, and also added </p><tt>PRINT AT</tt><p> (for putting text at any screen position), and </p><tt>TIMER</tt><p> to measure time.
</p></div>
<p>
One of the most difficult things was implementing the floating-point number parsing. I finally decided to approach it like parsing an integer, taking note of the number of digits parsed, and take note of the position of a period. Once it reaches the biggest number it can represent (9,999,999) then it starts ignoring any further digit (but it keeps counting them)
</p>
<p>
The final calculation step is to multiply it, or divide it taking in account the period position. Also taking in account any exponent present (for example, e+1 or e-3)
</p>
<div><p>
It wasn&#39;t so expensive in computation time. I added along a </p><tt>FRE(0)</tt><p> function to know how much space remains for writing programs.
</p></div>
</div>
<h2>It is the eighties</h2>
<p>
Let&#39;s suppose we are working to make this BASIC interpreter really useful for the Mattel ECS. We still need two things: cassette, and printer.
</p>
<p>
Fortunately, a lot of people at Atariage Forums have worked along the years to decipher the ECS hardware (thanks to <i>intvnut</i>, <i>lathe26</i>, and <i>decle</i>)
</p>
<p>
The ECS contains the hardware to interface to a cassette recorder/player at 300 bauds with FSK (Frequency-Shift Keying) of 2400/4800 hz (technically this is a modem) and it also includes a UART (Universal Asynchronous Receiver/Transmitter) patterned losely after a Motorola MC6850, but the frequency selector is separated, allowing to turn on/off a relay (cassette remote control), and to switch between two ports (the cassete and the AUX port for the printer)
</p>
<p>
Now for the cassette, I was going to use 300 bauds, this means around 30 characters per second. Do you remember your 56K modem? It was 186 times faster! I needed to optimize my BASIC as I was using token numbers above $0100, so I moved them to the area $0080-$00ff. Now all the words are only used in the lower 8 bits, and the tokenized program can be saved as bytes.
</p>
<div><p>
I coded the cassette routines based on code published by decle in his article <a href="https://forums.atariage.com/topic/310486-ecs-text-editor-written-in-intybasic-with-tape-support/">ECS Text Editor written in IntyBASIC with tape support</a> and added LOAD, SAVE, and VERIFY.
</p></div>
<p>
I was very happy when these cassette routines worked in emulation, and I ordered cables from Amazon for trying to record and play in my cellphone.
</p>
<p>
For some reason probably related to audio levels and automatic compression, I could record audio from the ECS in my cellphone, but playing it back never resulted in anything.
</p>
<p>
I was tired, and I decided to try my PC. I connected the ECS to the Mic In, and Line Out, and same problem. Besides the Windows utilities make amazingly hard to change the source and playing line. I got the Audacity program, and it has the line input/output options easily selectable. Again no results.
</p>
<p>
I wrote a small program to read the UART continuously, and I couldn&#39;t see anything. I decided to try the Audacity&#39;s amplify effect, and et voila! My UART program started throwing decoded bytes. I stopped the program, and I tried the VERIFY command (remember I had just saved the same program), but it didn&#39;t worked. Worst, when I ran again my test program, I didn&#39;t got any data!
</p>
<p>
I revised my setup values for the UART, but nothing. I was mystified for some hours until I got memories of a chip that basically went nuts if you accessed it too fast. Could it be that? Is the CP1610 so fast? I added a delay after <i>every</i> access to the UART chip.
</p>
<p>
I typed again my test program, I did SAVE, recorded on the PC, amplified it, I RUN my program, and played the audio back. Ok, UART was reading things. Now I stopped the test program, I did VERIFY, and I played the audio back from my PC. The longest 20 seconds of my life. And it worked!
</p>
<p>
Immediately I resetted the ECS, losing the program, and I did LOAD (of course, playing back the audio), and again it worked!
</p>
<div>
    <p><img src="https://nanochess.org/img/ecsbasic_8.jpg" width="80%" alt="My UART test program after a successful LOAD statement."/></p></div>
<p>Notice that although it saves BASIC programs, these programs aren&#39;t compatible with the original ECS BASIC because it is a completely different BASIC language.</p>
<div><p>
Break time: As I couldn&#39;t lose programs anymore, I decided to test my BASIC language with a &#34;real&#34; long program. So I took Tim Hartnell&#39;s Giant Book of Computer Games (Mexican edition), and I typed the Reversi game. I had to adapt it, because my BASIC doesn&#39;t allow for multidimensional arrays, and the screen positioning. I found a few bugs in my interpreter (</p><tt>INPUT W$</tt><p> still wasn&#39;t written with the garbage-collector support, and the variables weren&#39;t deleted properly on </p><tt>RUN</tt><p>), but it was amazing to watch the Reversi game playing against me. I&#39;ve put a WAV file recording <a href="https://forums.atariage.com/topic/384664-typing-basic-on-my-ecs/page/4/#findComment-5729066">here</a>.
</p></div>
<div>
    <p><img src="https://nanochess.org/img/ecsbasic_9.jpg" width="80%" alt="Reversi game from the Tim Hartnell&#39;s Giant Book of Computer Games book working with my BASIC interpreter for the Mattel ECS."/></p></div>
<h2>The printer is in the room</h2>
<div><p>
After reading <a href="https://forums.atariage.com/topic/323929-aquarius-printer-technical-info-and-reverse-engineering/">Aquarius Printer Technical Info and Reverse Engineering</a> and the <a href="http://spatula-city.org/~im14u2c/intv/tech/ecs.html">jzintv ECS document</a>, I decided using the printer was very easy, and I went to buy a Mattel Aquarius sourced locally because it included the printer and some thermal paper.
</p></div>
<div><p>
While the printer was in shipping process, I implemented </p><tt>LLIST</tt><p>, and </p><tt>LPRINT</tt><p>. I modified the core of both statements to access the output through an indirect function. So you only change the pointer to target the screen or the printer. I detected here a bug in jzintv that prevents it from outputting the printer data to a file.
</p></div>
<p>
I got the Mattel Aquarius along the printer a few days later. I had to clean it because it was pretty dusty. The printer doesn&#39;t have the top cover that protected the paper roll, but it included a paper roll, and fortunately it still had the cylinder that helps the papel to roll.
</p>
<div>
    <p><img src="https://nanochess.org/img/ecsbasic_10.jpg" width="80%" alt="Mattel Aquarius computer with expansion board, two games, cables, and the Aquarius printer."/></p></div>
<p>
I adjusted the paper, powered on the printer, and verified I could advance the paper (having a working motor is 90% of the printer).
</p>
<p>
I built the cable with the instructions from lathe26&#39;s article, and the first time it didn&#39;t worked (I grounded the CTS cable accidentally), but after correcting it, I expected trash for my first print, instead, I got a pretty nice printing!
</p>
<p>
Of course, I couldn&#39;t resist printing some listings, and a sine wave.
</p>
<div>
    <p><img src="https://nanochess.org/img/ecsbasic_11.jpg" width="80%" alt="The printed source code of my UFO game. The paper roll is really old."/></p></div>
<h2>What remains to do?</h2>
<div><p>
I added the </p><tt>DRAW</tt><p> and </p><tt>CIRCLE</tt><p> statements, and </p><tt>POINT</tt><p> functions to complete the graphics support. These are enough to make some nice games without using sprites. I made a graphics demo for filling the screen with lines, and I noticed my pseudo random number generator didn&#39;t covered the screen, so I had to improve it.
</p></div>
<div>
    <p><img src="https://nanochess.org/img/ecsbasic_12.gif" width="40%" alt="DRAW program for my ECS BASIC interpreter."/></p></div>
<div><p>
Also I added the </p><tt>POS</tt><p> and </p><tt>LPOS</tt><p> functions to know the horizontal position of the cursor. The </p><tt>SPC</tt><p> and </p><tt>TAB</tt><p> functions for </p><tt>PRINT</tt><p>. Plus a </p><tt>HEX$</tt><p> function to ease system programming.
</p></div>
<p>
In the tokenization table, I added placeholders to expand the language and don&#39;t break compatibility with any cassette tape being created.
</p>
<p>
With this it has become a full-fledged BASIC interpreter for the Mattel ECS that uses 19 kilowords, instead of the 24 kilowords of the slow and limited Mattel ECS BASIC interpreter.
</p>
<p>
I don&#39;t see anything more I could do in the near future, except maybe expanding the editor to be a full-screen editor. Currently, it is a line editor that reads its input from the screen.
</p>
<p>
At this point, it is a fun experience the process of typing BASIC programs in the ECS, and watch the results back. You can save the programs, or print it. And of course, you can only imagine the success that Mattel Electronics would have enjoyed if they put together a good BASIC with its Mattel ECS.
</p>
<p>
    Small statistics of the assembler code:
</p>
<ul>
    <li><i>basic.asm</i>: 5333 lines.</li>
    <li><i>fplib.asm</i>: 718 lines.</li>
    <li><i>fpio.asm</i>: 462 lines.</li>
    <li><i>fpmath.asm</i>: 516 lines.</li>
    <li><i>uart.asm</i>: 341 lines.</li>
    <li>Total of 7370 lines of assembler code written between Sep/17 and Oct/12, around 300 lines written daily.</li>
</ul>
<p>
The source code is released at <a href="https://github.com/nanochess/ecsbasic">https://github.com/nanochess/ecsbasic</a>. I tried to release it so early as possible, so you can get a glance of how it was growing in the commits.
</p>
<div><p>
Enjoy it! <i>Did you like this article? <a href="https://ko-fi.com/nanochess">Invite me a coffee on ko-fi!</a></i>
</p></div>
<h2>Related links</h2>
<ul>
    <li><a href="https://github.com/nanochess/ecsbasic">My BASIC interpreter for Mattel ECS</a>, full assembler source code, and ROM for running on Flash cartridges (don&#39;t forget to enable the 8K of extra RAM)</li>
    <li><a href="https://forums.atariage.com/topic/384664-typing-basic-on-my-ecs/">Typing BASIC on my ECS</a>. The original thread where I posted my experiences typing a game on the ECS, and later started posting about my BASIC interpreter.</li>
    <li><a href="https://nanochess.org/intybasic.html">The IntyBASIC cross-compiler</a>.</li>
    <li><a href="https://history.blueskyrangers.com/hardware/ecs.html">The history of the ECS</a> from the people who developed it.</li>
</ul>
<p>Last modified: Oct/12/2025</p>
</div></div>
  </body>
</html>
