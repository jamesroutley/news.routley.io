<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://ernestmicklei.com/melrose/introduction_melrose/">Original</a>
    <h1>Melrōse, a language to program and play music</h1>
    
    <div id="readability-page-1" class="page"><div id="main">



<div>

  

  <h3 id="tldr">TL;DR</h3>
<p>Melrōse is both a language and a tool to create and listen to music interactively, The language uses musical primitives (note, sequence, chord) and many functions (map, group, transpose) that can be used to create more complex patterns, loops and tracks. Melrōse uses MIDI output to produce sound by any (hard or software) device attached. Melrōse can also react on MIDI inputs to start, record and stop playing musical objects. A plugin is available for Microsoft Visual Studio for the best usage experience. For a quickstart, without any installation, you can use the <a href="https://play.melr%C5%8Dse.org">Melrōse playground</a>.</p>
<h2 id="introduction">Introduction</h2>
<p>Music composition is both a creative process and one that follows many rules (chords, scales, patterns). Exploring variations and combinations can be done by playing instruments. With the availabilty of many digital instruments, both soft- and hardware, it is also possible to create music using digital programming methods.</p>
<p>Melrōse offers a fully human-centric approach to algorithmic composition [1] of music. It defines a new programming language and includes a tool to play music by evaluating expressions in that language. With Melrōse, exploring patterns in music is done by creating musical objects that can be played and changed while listening.</p>
<h2 id="language">Language</h2>
<h3 id="note">Note</h3>
<p>The language design started by defining a number of musical primitives, objects that can be composed to larger complex ones. The first such primitive is a <strong>note</strong> and is a symbol to represent a sound. To create a note, you write this expression:</p>
<pre><code>note(&#39;c&#39;)
</code></pre><p>You can also express the fraction (affects duration), octave, accidental (sharp,flat) and dynamic (forte, pianissimo) in one notation:</p>
<pre><code>note(&#39;8a#3++&#39;)  // ⅛ note A, sharp, 3rd octave, forte
</code></pre><p>This is a compact notation that exactly describes multiple aspects of a musical note.
The note name can be both lowercase (no shift key needed) and uppercase.</p>
<p>The two slashes // can be used to put comments in a script, at the end of an expression or in between expression lines.</p>
<h3 id="combining-notes">Combining notes</h3>
<p>Creating melodies by stitching together individual note objects is not practical as it requires lots of scripting to achieve simple melodies. Therefore, a second basic musical object is introduced, the sequence:</p>
<pre><code>sequence(&#39;c e g&#39;)
</code></pre><p>This expression creates a sequence of notes in which each note is described using the same notation as used with the note function. The notes will be played in the order as it appears in the sequence using the current tempo (bpm).
Additionally, a sequence one can also describe grouping of notes using parentheses:</p>
<pre><code>sequence(&#39;(c e g) = (g c5 e5)&#39;) // C chord and its first inversion, separated by a quarter rest
</code></pre><p>Other basic musical objects that combine notes are: scale, chord, chordsequence and chordprogression.</p>
<h3 id="functions-for-properties">Functions for properties</h3>
<p>Recall the example of creating a note:</p>
<pre><code>note(&#39;8a#3++&#39;)  // ⅛ note A, sharp, 3rd octave, forte
</code></pre><p>In this expression, all note properties (pitch,duration,velocity) are part of the input string.
The main reason for having a programmable music language is to be able to modify all such properties using functions that manipulate them. Therefore, functions are added to the language such as transpose (changing the pitch), fraction (changing duration) and velocity (changing the loudness to change properties of musical objects. For example, the same note can also be expressed like this:</p>
<pre><code>fraction(8, octave(-1, dynamic(&#39;++&#39;, transpose(1,note(&#39;a&#39;)))))
</code></pre><p>With this verbose structure, it is possible to change the properties of the note A by changing the first parameter of each function.</p>
<p>Let us write a loop that drives the pitch of a note.</p>
<pre><code>a = note(&#39;a&#39;)
t = interval(-4,4,1) // from -4 to 4 by 1

loop( transpose(t,a), next(t))
</code></pre><p>Running this loop will play each argument starting with <code>transpose(t,a)</code> and then <code>next(t)</code>. Because of the function, the note a will be transposed with <code>t</code> semitones ;the current value of <code>t</code> is -4. The next function will simplify increase <code>t</code> by 1.</p>
<h3 id="functions-that-change-structure">Functions that change structure</h3>
<p>Other functions exist in the language that change the structure of a sequence. Examples are  <code>resequence, map, replace</code> and <code>group</code>. The purpose of these functions is to easily explore variations of a given sequence without copy-paste-modifying them.</p>
<h4 id="ungroup">(un)group</h4>
<p>The group function will create a new music object from all the notes in a sequence.</p>
<pre><code>group(sequence(&#39;c e g&#39;)) // (C E G) which is C chord
ungroup(chord(&#39;c&#39;)) // C E G, which are the notes in sequence
</code></pre><h4 id="map">map</h4>
<p>In general, a map takes notes of a sequence and apply some transformation on it. One such map function is <code>octavemap</code>.</p>
<pre><code>octavemap(&#39;1:0 2:-1 3:1&#39;, sequence(&#39;A B C5&#39;)) // A B3 C6
</code></pre><h3 id="functions-that-create-patterns">Functions that create patterns</h3>
<p>The last category of functions to explain here are the ones that create patterns. A typical example is one that creates a drum pattern with an instrument of a drum set. By creating multiple patterns and combining them into one, you can program the drum section of a song.</p>
<pre><code>kick = note(&#39;16c2’)
clap = note(&#39;16f2’)
drum = merge(
notemap(&#39;!...!...!...!&#39;, kick)
notemap(&#39;.!!..!!..!!..&#39;, clap))
</code></pre><p>This script starts by defining two variables <code>kick</code> and <code>clap</code> with note objects. The duration is 1/16. Next the <code>drum</code> variable is the result of merging 2 patterns created with a notemap.
Using “dots and bangs”, you can notate the occurrence of a note inside the pattern. If an exclamation mark (!) is seen then the <code>kick</code> will be played. Dots are needed to get the timing right. You can merge any number of patterns with any number of notes.</p>
<h2 id="play">Play</h2>
<p>An important step in the creative process of making music is to get fast audible feedback. Starting from an initial idea, you want to try out variations and combinations by repeatedly making a change and listen to the result. To fully support this process, a program (the melrose tool) is needed that is able to understand the language and can produce the sounds from the written expressions.</p>
<p>Many programs exist that can produce sounds and are known as digital audio workstations (DAW) e.g Ableton, LMMS and Logic. The standard way to communicate with these tools is by sending MIDI messages. Playing one note requires two MIDI messages ; one to start the note and one to stop the note at a later moment in time.</p>
<p>So for the melrose tool to produce sound from a musical object, it just needs to translate the object into sequences of notes and send MIDI messages with the right timing, duration and tempo (bpm).</p>
<h3 id="loops-for-live-feedback">Loops for live feedback</h3>
<p>A powerful feature of the melrose tool is the ability to play musical objects in a timing loop while modifying any object that is part of it. To understand this, let us have a look at a small example:</p>
<pre><code>p = 0
loop( transpose (p, sequence(&#39;c = e = g =&#39;)))
</code></pre><p>If you play this program (an assignment and a loop) then you will hear the 3 notes C,E,G separated by a rest, over and over again.</p>
<p>For most programming languages, a program is first compiled into an artifact that then can be run. However, this means that any change to the program would require stopping it, changing the program, compile and run it again. This would also mean that all sounds will silenced which clearly negatively impacts the flow of creativity. Therefore instead, the melrose tool is not compiling the program but evaluating the expressions in the program on each loop entry.</p>
<p>So while running the loop from the example above, you can change the value of <code>p</code> to a different number which will cause the sequence to be transposed with a new number of semitones. This applies to many other kinds of changes, even the loop itself can be changed while it is running.</p>
<h3 id="parallel">Parallel</h3>
<p>Melrose can play any number of musical objects at the same time because it uses its own clock to produce notes in the specify tempo (bpm). For example, you can start playing a loop and while listening to it, you can program another and play that one and so on.
If “m” is a melody and “b” is the bass line and “d” is the drum layer then you can either play:</p>
<pre><code>sync( m, b, d)  // play all at once, once
</code></pre><p>or start and stop loops with your own timing. Any next loop will start and the end of the first loop. So if you play loop d first and later want to start playing loop b, it will actually start on the next loop start of d.</p>
<pre><code>loop(d) // if you play this first
loop(b) // then playing this later will sync with the next d
loop(m) 
</code></pre><h2 id="device-and-channel">Device and channel</h2>
<p>Music is typically arranged with multiple instruments playing together melodies, rythmic drums or others sounds. Because melrose is a MIDI producing tool, it can leverage the available MIDI devices and use up to 16 MIDI channels per device.</p>
<p>Without specifying a device or channel, the default values are used to play a musical object. To send the notes to one specific device and channel, you can use enclosing functions to make that happen.</p>
<pre><code>c = chordprogression(&#39;c&#39;, &#39;i iv v&#39;)
loop( device(2, channel(4, c))
</code></pre><p>The device id “2” refers to an entry in your MIDI devices list.</p>
<h3 id="key-trigger">Key trigger</h3>
<p>An alternative way to start playing (and stopping) melodies using the editor and keyboard shortcuts, is to use a MIDI hardware device to trigger an action. Using the functions key and listen you can program what should happen if you hit a key on your controller or turn a knob.</p>
<pre><code>onkey(&#39;c&#39;,loop1) // if the C is played on the default input MIDI device then start or stop loop1
</code></pre><h3 id="final-note--">Final note :-)</h3>
<p>Any programming language should have just enough features to allow you to create as much as possible. The language will only be extended with more functions if that new feature cannot be easily achieved by composition of existing functions.</p>
<p>The tool Melrōse is not and will not become a DAW. Instead it can feed into it because any DAW can be a MIDI output device from the perspective of the Melrōse tool [2].</p>
<p>The features of the tool and its plugin is driven by its actual use by the author and hopefully other interested musicians/programmers. If you want to contribute somehow, please go the project site [3].</p>
<p><a href="https://en.wikipedia.org/wiki/Algorithmic_composition">[1] Algorithmic_composition</a></p>
<p><a href="https://melr%C5%8Dse.org">[2] melrōse.org</a></p>
<p><a href="https://github/emicklei/melrose">[3] sources on github</a></p>


  



  



<p><a href="http://disqus.com/">comments powered by </a>


</p></div>

</div></div>
  </body>
</html>
