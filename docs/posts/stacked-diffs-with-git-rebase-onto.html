<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://dineshpandiyan.com/blog/stacked-diffs-with-rebase-onto/">Original</a>
    <h1>Stacked Diffs with git rebase —onto</h1>
    
    <div id="readability-page-1" class="page"><div>
    <p><em><strong>tldr;</strong> Use <code>git rebase --onto</code> to cleanly rebase a dependent branch without dragging along commits that don’t belong to it.</em></p>
<div><pre tabindex="0"><code data-lang="bash"><span><span>1</span><span>git rebase --onto &lt;new-base&gt; &lt;old-base&gt; &lt;branch&gt;
</span></span></code></pre></div><p>If you’ve ever worked on a larger feature and split your work into multiple PRs that depend on each other, you’ve probably experienced the pain of keeping them in sync. This workflow is called <strong>stacked diffs</strong> (or stacked PRs), and it’s incredibly powerful. But it comes with a learning curve. The secret weapon? <code>git rebase --onto</code>.</p>
<p>Here’s what we’ll cover:</p>
<ul>
<li>Why stacked diffs are worth the effort</li>
<li>The difference between a regular <code>git rebase</code> and <code>git rebase --onto</code></li>
<li>Step-by-step: first sync, ongoing syncs, and post-merge cleanup</li>
</ul>
<h2 id="why-stacked-diffs">
  <a href="#why-stacked-diffs" aria-describedby="Why Stacked Diffs?">#</a>
  Why Stacked Diffs?
</h2>
<p>Let’s say you’re building a large feature. You could dump everything into one massive PR, but reviewers hate that. Large PRs get superficial reviews (or no reviews at all), and you end up waiting forever for approvals.</p>
<p><strong>Stacked diffs</strong> solve this by breaking your work into smaller, dependent PRs:</p>
<div><pre tabindex="0"><code data-lang="text"><span><span>main
</span></span><span><span>  └── feature-1 (auth layer)
</span></span><span><span>        └── feature-2 (user profile)
</span></span><span><span>              └── feature-3 (profile settings)
</span></span></code></pre></div><p>Each PR is small, focused, and easy to review. The catch? When <code>main</code> updates or when <code>feature-1</code> gets rebased, you need to sync all the downstream branches. That’s where most people get stuck.</p>
<h2 id="regular-rebase-vs-rebase-onto">
  <a href="#regular-rebase-vs-rebase-onto" aria-describedby="Regular rebase vs rebase –onto">#</a>
  Regular rebase vs rebase –onto
</h2>
<h3 id="regular-rebase">
  <a href="#regular-rebase" aria-describedby="Regular rebase">#</a>
  Regular rebase
</h3>
<p>A regular <code>git rebase main</code> replays your commits on top of the target branch:</p>
<div><pre tabindex="0"><code data-lang="text"><span><span>Before:
</span></span><span><span>main:      A---B---C
</span></span><span><span>                \
</span></span><span><span>feature:         D---E
</span></span><span><span>
</span></span><span><span>After git rebase main:
</span></span><span><span>main:      A---B---C
</span></span><span><span>                    \
</span></span><span><span>feature:             D&#39;---E&#39;
</span></span></code></pre></div><p>Simple enough. But what happens with stacked branches?</p>
<h3 id="the-problem-with-stacked-branches">
  <a href="#the-problem-with-stacked-branches" aria-describedby="The Problem with Stacked Branches">#</a>
  The Problem with Stacked Branches
</h3>
<p>Here’s a typical stacked setup:</p>
<div><pre tabindex="0"><code data-lang="text"><span><span>main:        A---B---C
</span></span><span><span>                  \
</span></span><span><span>feature-1:         D---E
</span></span><span><span>                        \
</span></span><span><span>feature-2:               F---G
</span></span></code></pre></div><p>Now <code>main</code> gets updated with new commits:</p>
<div><pre tabindex="0"><code data-lang="text"><span><span>main:        A---B---C---H---I
</span></span><span><span>                  \
</span></span><span><span>feature-1:         D---E
</span></span><span><span>                        \
</span></span><span><span>feature-2:               F---G
</span></span></code></pre></div><p>You rebase <code>feature-1</code> onto <code>main</code>:</p>
<div><pre tabindex="0"><code data-lang="text"><span><span>main:        A---B---C---H---I
</span></span><span><span>                  \          \
</span></span><span><span>old:               D---E      D&#39;---E&#39;  ← feature-1 (new hashes!)
</span></span><span><span>                        \
</span></span><span><span>feature-2:               F---G  ← Still based on old D---E!
</span></span></code></pre></div><p>See the problem? <code>feature-2</code> is still based on the <strong>old</strong> <code>D---E</code> commits. If you try a regular <code>git rebase feature-1</code> on <code>feature-2</code>, git will try to include those old commits again and you’ll end up with duplicates or conflicts.</p>
<h3 id="enter-git-rebase-onto">
  <a href="#enter-git-rebase-onto" aria-describedby="Enter: git rebase –onto">#</a>
  Enter: git rebase –onto
</h3>
<p>This is where <code>git rebase --onto</code> shines. It lets you specify exactly which commits to move and where to put them:</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span>git rebase --onto &lt;new-base&gt; &lt;old-base&gt; &lt;branch&gt;
</span></span><span><span>                      ↑          ↑          ↑
</span></span><span><span>                new parent  old parent   branch to rebase
</span></span></code></pre></div><p>Think of it as saying: “Take everything after <code>&lt;old-base&gt;</code> on <code>&lt;branch&gt;</code>, and replay it onto <code>&lt;new-base&gt;</code>.”</p>
<h2 id="step-by-step-using-rebase-onto">
  <a href="#step-by-step-using-rebase-onto" aria-describedby="Step-by-Step: Using rebase –onto">#</a>
  Step-by-Step: Using rebase –onto
</h2>
<h3 id="first-rebase-onto">
  <a href="#first-rebase-onto" aria-describedby="First rebase –onto">#</a>
  First rebase –onto
</h3>
<p>When you first create <code>feature-2</code> off of <code>feature-1</code>, also create a marker branch:</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span>1</span><span>git checkout feature-1
</span></span><span><span>2</span><span>git checkout -b feature-2
</span></span><span><span>3</span><span>
</span></span><span><span>4</span><span><span># feature-2-base is your marker</span>
</span></span><span><span>5</span><span><span># when you update feature-1 later,</span>
</span></span><span><span>6</span><span><span># the marker will have feature-1 branch&#39;s previous state</span>
</span></span><span><span>7</span><span>git branch feature-2-base feature-1
</span></span></code></pre></div><p>The first time <code>main</code> updates and you need to sync your stack:</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span>1</span><span><span># 1. Rebase feature-1 onto main</span>
</span></span><span><span>2</span><span>git checkout feature-1
</span></span><span><span>3</span><span>git rebase main
</span></span><span><span>4</span><span>
</span></span><span><span>5</span><span><span># 2. Rebase feature-2 onto the updated feature-1</span>
</span></span><span><span>6</span><span>git rebase --onto feature-1 feature-2-base feature-2
</span></span><span><span>7</span><span>
</span></span><span><span>8</span><span><span># 3. Update the marker branch after successful rebase</span>
</span></span><span><span>9</span><span>git branch -f feature-2-base feature-1
</span></span></code></pre></div><blockquote>
<p>That last step is critical. Without it, your next sync will break.</p></blockquote>
<h3 id="syncing-main">
  <a href="#syncing-main" aria-describedby="Syncing main">#</a>
  Syncing main
</h3>
<p>Every time <code>main</code> updates, you repeat the same pattern:</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span>1</span><span><span># Rebase feature-1 onto main</span>
</span></span><span><span>2</span><span>git checkout feature-1
</span></span><span><span>3</span><span>git rebase main
</span></span><span><span>4</span><span>
</span></span><span><span>5</span><span><span># Sync feature-2</span>
</span></span><span><span>6</span><span>git rebase --onto feature-1 feature-2-base feature-2
</span></span><span><span>7</span><span>git branch -f feature-2-base feature-1  <span># ← Don&#39;t forget!</span>
</span></span></code></pre></div><p>The marker update isn’t optional. It’s what makes repeat syncs work.</p>
<h3 id="once-a-feature-branch-merges">
  <a href="#once-a-feature-branch-merges" aria-describedby="Once a feature branch merges">#</a>
  Once a feature branch merges
</h3>
<p>When <code>feature-1</code> finally lands in <code>main</code>, you no longer need its commits in your <code>feature-2</code> history. Here’s how to clean up:</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span>1</span><span>git checkout feature-2
</span></span><span><span>2</span><span>git rebase -i main
</span></span></code></pre></div><p>In the interactive rebase, you’ll see all commits including the ones from <code>feature-1</code>:</p>
<div><pre tabindex="0"><code data-lang="text"><span><span>pick abc123 D&#39; ...  ← DELETE (from feature-1)
</span></span><span><span>pick def456 E&#39; ...  ← DELETE (from feature-1)
</span></span><span><span>pick 789ghi F  ...  ← KEEP (your work)
</span></span><span><span>pick 012jkl G  ...  ← KEEP (your work)
</span></span></code></pre></div><p>Delete (or mark as <code>drop</code>) the commits from <code>feature-1</code>, and Git will replay only your <code>feature-2</code> commits directly onto <code>main</code>.</p>
<h3 id="putting-it-all-together-visually">
  <a href="#putting-it-all-together-visually" aria-describedby="Putting it all together visually">#</a>
  Putting it all together visually
</h3>
<div><pre tabindex="0"><code data-lang="text"><span><span>BEFORE REBASE:
</span></span><span><span>==============
</span></span><span><span>main:             A---B---C---H---I
</span></span><span><span>                       \
</span></span><span><span>feature-1:              D---E              (needs rebase onto main)
</span></span><span><span>                            ↑
</span></span><span><span>feature-2-base:             * (marker pointing to E)
</span></span><span><span>                             \
</span></span><span><span>feature-2:                    F---G
</span></span><span><span>
</span></span><span><span>
</span></span><span><span>AFTER REBASING FEATURE-1:
</span></span><span><span>=========================
</span></span><span><span>main:             A---B---C---H---I
</span></span><span><span>                       \          \
</span></span><span><span>old commits:            D---E      D&#39;---E&#39;  (feature-1, new hashes!)
</span></span><span><span>                            ↑
</span></span><span><span>feature-2-base:             * (still pointing to old E!)
</span></span><span><span>                             \
</span></span><span><span>feature-2:                    F---G         (orphaned on old commits)
</span></span><span><span>
</span></span><span><span>
</span></span><span><span>AFTER REBASE --ONTO:
</span></span><span><span>====================
</span></span><span><span>main:             A---B---C---H---I
</span></span><span><span>                                  \
</span></span><span><span>feature-1:                         D&#39;---E&#39;
</span></span><span><span>                                        ↑
</span></span><span><span>feature-2-base:                         * (updated to new E&#39;)
</span></span><span><span>                                         \
</span></span><span><span>feature-2:                                F&#39;---G&#39;  (synced!)
</span></span></code></pre></div><h2 id="closing-thoughts">
  <a href="#closing-thoughts" aria-describedby="Closing Thoughts">#</a>
  Closing Thoughts
</h2>
<p><code>git rebase --onto</code> is one of those commands that looks intimidating but becomes second nature once you understand what each parameter does:</p>
<p>The marker branch pattern takes the guesswork out of tracking the old base. Use it, update it, and your stacked diffs will stay clean.</p>
<p>Here are a few thoughts to keep in mind when using this workflow:</p>
<ol>
<li>
<p><strong>Force pushes are required</strong>: Every rebase changes commit hashes, so you’ll be doing <code>git push --force-with-lease</code> a lot.</p>
</li>
<li>
<p><strong>Marker branches need discipline</strong>: If you forget to update your marker, your next sync will be painful. Consider aliasing the full command:</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span>1</span><span><span>alias</span> <span>gsync</span><span>=</span><span>&#39;git rebase --onto $1 $2-base $2 &amp;&amp; git branch -f $2-base $1&#39;</span>
</span></span></code></pre></div></li>
<li>
<p><strong>Merge conflicts multiply</strong>: If you have conflicts when rebasing <code>feature-1</code>, you might hit them again when rebasing <code>feature-2</code>. That’s the nature of the beast.</p>
</li>
<li>
<p><strong>Don’t stack too deep</strong>: Two or three levels is manageable. Beyond that, the maintenance overhead outweighs the benefits. I personally try to keep it at 2 levels max.</p>
</li>
</ol>
<p>Is this workflow more complex than just having one big branch? Absolutely. But the payoff (smaller PRs, faster reviews, and cleaner history) is worth the investment. Just remember to update those marker branches!</p>
<p>Happy rebasing! Have a great day!</p>

  </div></div>
  </body>
</html>
