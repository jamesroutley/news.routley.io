<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://wiredream.com/llm-optimizing-digit-diff/">Original</a>
    <h1>LLMs and Code Optimization</h1>
    
    <div id="readability-page-1" class="page"><div>
    <article>
      

      <span> David G. Andersen <span></span> January 04, 2025 <span></span></span>

    


<p>Prologue: Well, in the spirit of &#34;own your own stuff&#34;, I&#39;ve decided to claw back my blog onto self-ish hosted space (the blog is static, though I&#39;m not hosting it on my own metal, so it&#39;s easy to migrate). Welcome to the new blog, same as the old blog.</p>
<p>Max Woolf recently asked <a rel="noopener" target="_blank" href="https://minimaxir.com/2025/01/write-better-code/">whether repeatedly prompting</a> a large language model (LLM) to &#34;write better code&#34; would make it, well, write better code. His answer - summarized briefly - was &#34;kinda, maybe, up to a point&#34; (you should read the original article).</p>
<p>But what jumped out to me in the article was an obvious missed optimization that none of the prompts to the LLM identified, and that got me curious about where an LLM would or wouldn&#39;t help in optimizing. Because his example is fresh and unlikely to yet be in the training corpus for LLMs, I&#39;m using his problem for this post and seeing how much farther we can go -- with or without an LLM.</p>
<p>We&#39;ll start with the prompt Max used:</p>
<pre data-lang="LLM"><code data-lang="LLM"><span>Write Python code to solve this problem:
</span><span>
</span><span>Given a list of 1 million random integers between 1 and 100,000, 
</span><span>find the difference between the smallest and the largest numbers 
</span><span>whose digits sum up to 30.
</span></code></pre>
<p>For this example, I&#39;ll use GPT 4o through Copilot for all examples. Copilot generates substantially the same code for me that it did for Max, in Python:</p>
<pre data-lang="python"><code data-lang="python"><span><span><span>import</span> <span><span>random</span></span></span>
</span><span>
</span><span></span><span><span><span>random_integers</span></span> <span>=</span> <span><span>[</span><span><span><span>random</span></span><span><span>.</span></span><span><span><span>randint</span></span></span></span><span><span>(</span><span>1</span><span>,</span> <span>100000</span><span>)</span></span> <span><span>for</span> <span>_</span> <span>in</span></span> <span><span><span><span>range</span></span></span></span><span><span>(</span><span>1000000</span><span>)</span></span><span>]</span></span>
</span><span>
</span><span><span><span><span>def</span></span> <span><span>digit_sum</span></span></span><span><span>(</span></span><span><span>n</span><span>)</span></span><span><span>:</span></span>
</span><span>    <span>return</span> <span><span><span><span>sum</span></span></span></span><span><span>(</span><span><span><span><span>int</span></span></span></span><span><span>(</span><span><span>digit</span></span><span>)</span></span> <span><span>for</span> <span>digit</span> <span>in</span></span> <span><span><span><span>str</span></span></span></span><span><span>(</span><span><span>n</span></span><span>)</span></span><span>)</span></span>
</span><span>
</span><span></span><span><span><span>filtered_numbers</span></span> <span>=</span> <span><span>[</span><span><span>num</span></span> <span><span>for</span> <span>num</span> <span>in</span></span> <span><span>random_integers</span></span> <span>if</span> <span><span><span><span>digit_sum</span></span></span></span><span><span>(</span><span><span>num</span></span><span>)</span></span> <span>==</span> <span>30</span><span>]</span></span>
</span><span>
</span><span><span><span>if</span> <span><span>filtered_numbers</span></span><span>:</span></span>
</span><span>    <span><span>min_number</span></span> <span>=</span> <span><span><span><span>min</span></span></span></span><span><span>(</span><span><span>filtered_numbers</span></span><span>)</span></span>
</span><span>    <span><span>max_number</span></span> <span>=</span> <span><span><span><span>max</span></span></span></span><span><span>(</span><span><span>filtered_numbers</span></span><span>)</span></span>
</span><span>    <span><span>difference</span></span> <span>=</span> <span><span>max_number</span></span> <span>-</span> <span><span>min_number</span></span>
</span><span>    <span><span><span><span>print</span></span></span></span><span><span>(</span><span>f</span><span><span><span>&#34;</span></span></span><span><span>The difference between the largest and smallest numbers whose digits sum up to 30 is: </span><span><span>{</span><span><span><span>difference</span></span></span></span><span><span>}</span></span><span><span>&#34;</span></span></span><span>)</span></span>
</span><span><span><span>else</span><span>:</span></span>
</span><span>    <span><span><span><span>print</span></span></span></span><span><span>(</span><span><span><span>&#34;</span></span></span><span><span>No numbers found with digits summing up to 30.<span>&#34;</span></span></span><span>)</span></span>
</span></code></pre>
<p>This code takes 520ms on my M1 MBP. Great baseline. You&#39;ve already seen Max&#39;s code, so we know it can be a <i>lot</i> faster using a few different techniques:</p>
<ul>
<li>Numpy / native code</li>
<li>Parallelization / vectorization</li>
<li>Reducing redundant work</li>
</ul>
<p>Because Python introduces some artificial weirdness in approaching this problem, let&#39;s jump to Rust, where things like the effects of using JIT or native code through numpy aren&#39;t as big, and we can see effects of our performance choices a little more clearly. Here&#39;s the same LLM-written starter code in Rust:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span>use</span> <span>rand<span>::</span></span>Rng<span>;</span>
</span><span>
</span><span><span><span><span>fn</span> </span><span>digit_sum</span></span><span><span><span>(</span><span>n</span><span>:</span> <span>i32</span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>i32</span></span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    n<span>.</span><span>to_string</span><span><span>(</span></span><span><span>)</span></span><span>.</span><span>chars</span><span><span>(</span></span><span><span>)</span></span><span>.</span><span>map</span><span><span>(</span><span><span><span>|</span></span></span><span><span><span>c</span><span>|</span></span> </span><span>c<span>.</span><span>to_digit</span><span><span>(</span><span>10</span></span><span><span>)</span></span><span>.</span><span>unwrap</span><span><span>(</span></span><span><span>)</span></span> <span>as</span> <span>i32</span></span></span><span><span>)</span></span><span>.</span><span>sum</span><span><span>(</span></span><span><span>)</span></span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span><span>
</span><span><span><span><span>fn</span> </span><span>main</span></span><span><span><span>(</span></span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span>let</span> <span>mut</span> rng <span>=</span> <span>rand<span>::</span></span>thread_rng<span><span>(</span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>    <span>let</span> numbers<span>:</span> <span><span>Vec</span><span>&lt;</span><span>i32</span><span>&gt;</span></span> <span>=</span> <span><span>(</span><span>0</span><span>..</span><span>1_000_000</span></span><span><span>)</span></span><span>.</span><span>map</span><span><span>(</span><span><span><span>|</span></span></span><span><span>_<span>|</span></span> </span><span>rng<span>.</span><span>gen_range</span><span><span>(</span><span>1</span><span>..</span><span>=</span><span>100_000</span></span><span><span>)</span></span></span></span><span><span>)</span></span><span>.</span><span>collect</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    <span>let</span> <span>mut</span> min_number <span>=</span> <span>i32</span><span><span>::</span></span><span>MAX</span><span>;</span>
</span></span></span><span><span><span>    <span>let</span> <span>mut</span> max_number <span>=</span> <span>i32</span><span><span>::</span></span><span>MIN</span><span>;</span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    <span>for</span> <span>&amp;</span>number <span>in</span> <span>&amp;</span>numbers <span><span>{</span>
</span></span></span></span><span><span><span><span>        <span>if</span> <span>digit_sum</span><span><span>(</span>number</span><span><span>)</span></span> <span>==</span> <span>30</span> <span><span>{</span>
</span></span></span></span></span><span><span><span><span><span>            <span>if</span> number <span>&lt;</span> min_number <span><span>{</span>
</span></span></span></span></span></span><span><span><span><span><span><span>                min_number <span>=</span> number<span>;</span>
</span></span></span></span></span></span><span><span><span><span><span><span>            </span><span><span>}</span></span>
</span></span></span></span></span><span><span><span><span><span>            <span>if</span> number <span>&gt;</span> max_number <span><span>{</span>
</span></span></span></span></span></span><span><span><span><span><span><span>                max_number <span>=</span> number<span>;</span>
</span></span></span></span></span></span><span><span><span><span><span><span>            </span><span><span>}</span></span>
</span></span></span></span></span><span><span><span><span><span>        </span><span><span>}</span></span>
</span></span></span></span><span><span><span><span>    </span><span><span>}</span></span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    <span>if</span> min_number <span>==</span> <span>i32</span><span><span>::</span></span><span>MAX</span> <span>||</span> max_number <span>==</span> <span>i32</span><span><span>::</span></span><span>MIN</span> <span><span>{</span>
</span></span></span></span><span><span><span><span>        <span>println!</span><span><span>(</span></span><span><span><span>&#34;</span>No numbers with digit sum of 30 found.<span>&#34;</span></span></span><span><span>)</span></span><span>;</span>
</span></span></span></span><span><span><span><span>    </span><span><span>}</span></span> <span>else</span> <span><span>{</span>
</span></span></span></span><span><span><span><span>        <span>let</span> difference <span>=</span> max_number <span>-</span> min_number<span>;</span>
</span></span></span></span><span><span><span><span>        <span>println!</span><span><span>(</span></span><span><span><span>&#34;</span>Difference between the largest and smallest numbers with digit sum of 30: <span>{}</span><span>&#34;</span></span></span><span><span>,</span> difference<span>)</span></span><span>;</span>
</span></span></span></span><span><span><span><span>    </span><span><span>}</span></span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>Intriguingly, the Rust code uses the same &#34;split the string&#34; approach that the Python code does. This code takes 42ms to run. <b>Speed improvement going to Rust: 12x</b>.</p>
<p>But, of course, this hides a bit, because the &#34;Explode the string&#34; function is so slow. Let&#39;s tell the LLM to make it faster. Selecting the code and typing &#34;make this code faster&#34; gives a new version:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span><span>fn</span> </span><span>digit_sum</span></span><span><span><span>(</span><span>n</span><span>:</span> <span>i32</span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>i32</span></span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span>let</span> <span>mut</span> sum <span>=</span> <span>0</span><span>;</span>
</span></span></span><span><span><span>    <span>let</span> <span>mut</span> num <span>=</span> n<span>;</span>
</span></span></span><span><span><span>    <span>while</span> num <span>&gt;</span> <span>0</span> <span><span>{</span>
</span></span></span></span><span><span><span><span>        sum <span>+=</span> num <span>%</span> <span>10</span><span>;</span>
</span></span></span></span><span><span><span><span>        num <span>/=</span> <span>10</span><span>;</span>
</span></span></span></span><span><span><span><span>    </span><span><span>}</span></span>
</span></span></span><span><span><span>    sum
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>Which is correct. New time: 13.2ms. <b>Speed improvement from better digit_sum: 3.2x</b>. Notably, this gain is hidden in Python: moving to the better string sum doesn&#39;t change things much because, while it&#39;s better, it involves more python-level operations.</p>
<p>Selecting the main function and asking the LLM to make it faster fails. Copilot tries to parallelize the checking of the numbers vector but, of course, Rust won&#39;t let you have multiple threads modifying the same variable at the same time:</p>
<pre><code><span>   Compiling initial v0.1.0 (/Users/dga/blog/code_examples/llm-digit-diff-examples/rust/initial)
</span><span>error[E0594]: cannot assign to `min_number`, as it is a captured variable in a `Fn` closure
</span><span>  --&gt; src/main.rs:29:17
</span><span>   |
</span><span>29 |                 min_number = number;
</span><span>   |                 ^^^^^^^^^^^^^^^^^^^ cannot assign
</span></code></pre>
<p>So here, alas, we have to part ways with our LLM, but we&#39;ll use it a little more later.</p>
<p>Here&#39;s where our first human optimization comes in, and it&#39;s a simple one that I was quite surprised that none of Max&#39;s or my attempts at LLM-based optimization caught: Check to see if the number is useful <i>before</i> doing the comparatively expensive digit sum test. All of the LLM-generated code goes the opposite way: Filter by digit-sum and then compare. This is a manual change but an easy one:</p>
<pre data-lang="rust"><code data-lang="rust"><span>    <span>for</span> <span>&amp;</span>number <span>in</span> <span>&amp;</span>numbers <span><span>{</span>
</span></span><span><span>        <span>if</span> number <span>&lt;</span> min_number <span>||</span> number <span>&gt;</span> max_number <span><span>{</span>
</span></span></span><span><span><span>            <span>if</span> <span>digit_sum</span><span><span>(</span>number</span><span><span>)</span></span> <span>==</span> <span>30</span> <span><span>{</span>
</span></span></span></span><span><span><span><span>                <span>if</span> number <span>&lt;</span> min_number <span><span>{</span>
</span></span></span></span></span><span><span><span><span><span>                    min_number <span>=</span> number<span>;</span>
</span></span></span></span></span><span><span><span><span><span>                </span><span><span>}</span></span>
</span></span></span></span><span><span><span><span>                <span>if</span> number <span>&gt;</span> max_number <span><span>{</span>
</span></span></span></span></span><span><span><span><span><span>                    max_number <span>=</span> number<span>;</span>
</span></span></span></span></span><span><span><span><span><span>                </span><span><span>}</span></span>
</span></span></span></span><span><span><span><span>            </span><span><span>}</span></span>
</span></span></span><span><span><span>        </span><span><span>}</span></span>
</span></span><span><span>    </span><span><span>}</span></span>
</span></code></pre>
<p>New time: 10.7ms. Speedup: 1.2x. This is much smaller than the 5x speedup the same change made with the Python code, because the optimized digit_sum function is much faster in Rust. But actually it&#39;s faster than that, because we&#39;re bottlenecked on an entirely different part of the code...</p>
<p>One major limitation the LLM has is that it can&#39;t run a profiler on the code, but we can. (This would be a fun thing to do in the future - feed the output of perf to the LLM and say &#39;now optimize&#39;). To save a little time, I&#39;ll tell you that a major cost of the Rust code is, surprisingly, in generating the vector of random numbers. Rust&#39;s rand package defaults to a cryptographically secure RNG that&#39;s not very fast.  We&#39;ll address this by switching to the fastrand package. Note, however, that I&#39;m cheating here because I picked it because it&#39;s friendly to some parallelization we&#39;ll introduce later. Our LLM makes this easy, but the change was simple on its own:</p>
<pre data-lang="LLM"><code data-lang="LLM"><span>switch to using fastrand instead of rand
</span></code></pre>
<p>The changes were correct, and the only substantial change was:</p>
<pre data-lang="rust"><code data-lang="rust"><span>    <span>let</span> numbers<span>:</span> <span><span>Vec</span><span>&lt;</span><span>i32</span><span>&gt;</span></span> <span>=</span> <span><span>(</span><span>0</span><span>..</span><span>1_000_000</span></span><span><span>)</span></span><span>.</span><span>map</span><span><span>(</span><span><span><span>|</span></span></span><span><span>_<span>|</span></span> </span><span><span>fastrand<span>::</span></span>i32<span><span>(</span><span>1</span><span>..</span><span>=</span><span>100_000</span></span><span><span>)</span></span></span></span><span><span>)</span></span><span>.</span><span>collect</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
</span></code></pre>
<p>New time: 2.8ms. Speedup: About 3.8x.</p>
<p>I tried a few generic &#34;make it faster&#34; prompts to the LLM but it didn&#39;t generate anything that helped - and usually didn&#39;t even compile. So I got more specific. That random generation is still a bottleneck, so let&#39;s speed it up by giving more specific instructions, selecting the &#34;let numbers&#34; line and saying:</p>
<pre data-lang="LLM"><code data-lang="LLM"><span>Parallelize this code using rayon
</span></code></pre>
<p>And it did:</p>
<pre data-lang="rust"><code data-lang="rust"><span>        <span>use</span> <span>rayon<span>::</span></span><span>prelude<span>::</span></span><span>*</span><span>;</span>
</span><span>        <span>let</span> numbers<span>:</span> <span><span>Vec</span><span>&lt;</span><span>i32</span><span>&gt;</span></span> <span>=</span> <span><span>(</span><span>0</span><span>..</span><span>1_000_000</span></span><span><span>)</span></span><span>.</span><span>into_par_iter</span><span><span>(</span></span><span><span>)</span></span><span>.</span><span>map</span><span><span>(</span><span><span><span>|</span></span></span><span><span>_<span>|</span></span> </span><span><span>fastrand<span>::</span></span>i32<span><span>(</span><span>1</span><span>..</span><span>=</span><span>100_000</span></span><span><span>)</span></span></span></span><span><span>)</span></span><span>.</span><span>collect</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
</span></code></pre>
<p>New time: 2.35ms. Speedup: About 1.2x.</p>
<p>At this point, you might think we&#39;re kinda done - after all, we&#39;re about 2.5x faster than the fastest, numba+numpy JIT-optimized 6ms run from Python (where presumably most of the time was spent in C).</p>
<p>Except we&#39;re not. We can parallelize, but we have to do so intelligently. A naive parallelization can&#39;t retain the &#34;check first&#34; optimization because it updates those min/max&#39;s across threads, so we now have to get human on the problem and realize where the trick is: After processing a few thousand numbers, we&#39;ve found some OK candidates for max_number and min_number. They&#39;re probably not the best ones, but they let us avoid a lot of work. After we do that, <i>then</i> we can parallelize without having to worry about something icky like updating those with a shared lock. So we add a second loop, and it looks like this:</p>
<pre data-lang="rust"><code data-lang="rust"><span>        <span>const</span> <span>PREGEN</span><span>:</span> <span>usize</span> <span>=</span> <span>10_000</span><span>;</span>
</span><span>        <span>for</span> <span>_</span> <span>in</span> <span>0</span><span>..</span><span>PREGEN</span> <span><span>{</span>
</span></span><span><span>            <span>let</span> num <span>=</span> <span>fastrand<span>::</span></span>i32<span><span>(</span><span>1</span><span>..</span><span>100000</span></span><span><span>)</span></span><span>;</span>
</span></span><span><span>            <span>if</span> num <span>&lt;</span> min_num <span>||</span> num <span>&gt;</span> max_num <span><span>{</span>
</span></span></span><span><span><span>                <span>if</span> <span>digit_sum</span><span><span>(</span>num</span><span><span>)</span></span> <span>==</span> <span>30</span> <span><span>{</span>
</span></span></span></span><span><span><span><span>                    min_num <span>=</span> <span>min</span><span><span>(</span>min_num<span>,</span> num</span><span><span>)</span></span><span>;</span>
</span></span></span></span><span><span><span><span>                    max_num <span>=</span> <span>max</span><span><span>(</span>max_num<span>,</span> num</span><span><span>)</span></span><span>;</span>
</span></span></span></span><span><span><span><span>                </span><span><span>}</span></span>
</span></span></span><span><span><span>            </span><span><span>}</span></span>
</span></span><span><span>        </span><span><span>}</span></span>
</span><span>        <span>let</span> numbers<span>:</span> <span><span>Vec</span><span>&lt;</span><span>i32</span><span>&gt;</span></span> <span>=</span> <span><span>(</span><span>0</span><span>..</span><span><span>(</span><span>1_000_000</span> <span>-</span> <span>PREGEN</span></span><span><span>)</span></span></span><span><span>)</span></span>
</span><span>            <span>.</span><span>into_par_iter</span><span><span>(</span></span><span><span>)</span></span>
</span><span>            <span>.</span><span>map</span><span><span>(</span><span><span><span>|</span></span></span><span><span>_<span>|</span></span> </span><span><span>fastrand<span>::</span></span>i32<span><span>(</span><span>1</span><span>..</span><span>100000</span></span><span><span>)</span></span></span></span><span><span>)</span></span>
</span><span>            <span>.</span><span>filter</span><span><span>(</span><span><span><span>|</span></span></span><span><span><span>&amp;</span><span>x</span><span>|</span></span> </span><span><span><span>(</span>x <span>&lt;</span> min_num <span>||</span> x <span>&gt;</span> max_num</span><span><span>)</span></span> <span>&amp;&amp;</span> <span>digit_sum</span><span><span>(</span>x</span><span><span>)</span></span> <span>==</span> <span>30</span></span></span><span><span>)</span></span>
</span><span>            <span>.</span><span>collect</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
</span><span>
</span><span>        <span>for</span> num <span>in</span> numbers <span><span>{</span>
</span></span><span><span>            <span>if</span> num <span>&lt;</span> min_num <span>||</span> num <span>&gt;</span> max_num <span><span>{</span>
</span></span></span><span><span><span>                min_num <span>=</span> <span>min</span><span><span>(</span>min_num<span>,</span> num</span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>                max_num <span>=</span> <span>max</span><span><span>(</span>max_num<span>,</span> num</span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>            </span><span><span>}</span></span>
</span></span><span><span>        </span><span><span>}</span></span>
</span></code></pre>
<p>New time: 760 microseconds. Speedup: 3.6x. Relative to the initial LLM-generated Rust version, we&#39;re about 55x faster, and about 17x faster than the &#34;not stupid digit_sum&#34; version.</p>
<p>Note that this is a very project Euler-like question. It admits additional mathematical optimization that I&#39;ve deliberately ignored, because I like the pattern of the problem as a general one: Given a choice of a few ways to eliminate candidates, some of which parallelize and some of which are more tricky, find an order in which to do so.</p>
<p>I think it&#39;s revealing how limited the LLMs were in <i>algorithmically</i> optimizing this problem vs approaches like &#34;add some parallelism&#34; or &#34;use numpy&#34;, for which they were quite decent in Python and somewhat less decent in Rust. It&#39;s surprising to me that unless I prompted it overly-specifically, GPT 4o didn&#39;t suggest using a faster rand implementation, as that was a pretty effective, easy step.</p>
<p>I suspect that part of why is that this problem turns out to be unexpectedly interesting from a parallelization perspective: Because the digit_sum function is one of the biggest costs (once you fix rand), a naive parallelization <i>does more work</i> than a version of the code using the fast check first: With 1M numbers, the &#34;fast check&#34; code only calls digit sum about 5,000 times, whereas a naively parallel version calls it 1M times. The naively parallel version is still faster than the non-parallel fast check code, but at a really high cost in total work (and therefore, energy and machine cost). That tradeoff made this problem perhaps a more interesting LLM testcase than the author had intended, but it&#39;s a very real kind of issue: Many approaches to parallelization may end up trading off work for latency, and it requires a thoughtful programmer to figure out how to navigate it.</p>
<p>The code written for this post can be found <a rel="noopener" target="_blank" href="https://github.com/dave-andersen/llm-digit-diff-examples">here</a>.</p>
<p>Unfortunately, of course, if you&#39;re reading this after 2025, the LLM will probably have been trained on this blog post and will apply these optimizations for you if you try to reproduce it.</p>

      <nav>
        
        
      </nav>
    </article>
  </div></div>
  </body>
</html>
