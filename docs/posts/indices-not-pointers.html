<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://joegm.github.io/blog/indices-not-pointers/">Original</a>
    <h1>Indices, not Pointers</h1>
    
    <div id="readability-page-1" class="page"><div id="content">
      
      
  <p>Jul 15, 2025</p>
  
  
  <p>There is a pattern I’ve learned while using Zig which I’ve never seen used in any other language. It’s an extremely simple trick which - when applied to a data structure - reduces memory usage, reduces memory allocations, speeds up accesses, makes freeing instantaneous, and generally makes everything much, much faster. The trick is to use indices, not pointers.</p><p>This is something I learned from a <a href="https://youtu.be/IroPQ150F6c?si=8EidewgCw7bz4kCP&amp;t=848" target="_blank">talk by Andrew Kelley</a> (Zig’s creator) on data-oriented design. It’s used in Zig’s compiler to make very memory-efficient ASTs, and can be applied to pretty much any node-based data structure, usually trees.</p><p>So what does this mean exactly? Well, to use indices means to store the nodes of the data structure in a dynamic array, appending new nodes instead of individually allocating them. Nodes can then reference each other via indices instead of pointers.</p><figure><img src="https://joegm.github.io/blog/indices-not-pointers/Layout-Comparison.svg" width="800"/>
<figcaption>A comparison of memory layouts with different storage methods</figcaption></figure><p>Pretty simple, right? But this strategy has some major performance benefits.</p><div id="smaller-nodes"><h2><a href="#smaller-nodes">Smaller Nodes</a></h2><p>A pointer costs 8 bytes to store on a modern 64-bit system, but unless your planning on storing over 4 billion nodes in memory, an index can be stored in just 4 bytes.</p></div><div id="faster-access"><h2><a href="#faster-access">Faster Access</a></h2><p>Due to the reduced node size and the fact that nodes are stored contiguously in memory, the data structure will fit into fewer memory pages and more nodes will fit in the cpu’s cache line, which generally improves access times significantly.</p></div><div id="less-allocation-overhead"><h2><a href="#less-allocation-overhead">Less Allocation Overhead</a></h2><p>The way most people learn to implement data structures like trees is to make a separate allocation for each individual node, one at a time. This is a very naive way of allocating memory, however, as each memory allocation comes with a small but significant overhead which can really slow things down for a large number of nodes. Storing nodes in a growable arraylist minimizes this overhead as arraylists grow superlinearly (e.g, doubling in size each time more space is needed) meaning the majority of new nodes can just be placed in the next available slot without requesting more memory!</p><figure><img src="https://joegm.github.io/blog/indices-not-pointers/Arraylist-Resize.svg" width="800"/>
<figcaption>An arraylist growing by moving elements to a bigger allocation</figcaption></figure></div><div id="instant-frees"><h2><a href="#instant-frees">Instant Frees</a></h2><p>Freeing structures which are allocated in the traditional “nest of pointers” fashion can be very slow, as the entire structure has to be traversed to find and individually free each node. Storing nodes in a single allocation eliminates this problem entirely and freeing the structure becomes just a single free call, as it should be.</p></div><div id="a-downside-freeing-single-nodes"><h2><a href="#a-downside-freeing-single-nodes">A Downside - Freeing Single Nodes</a></h2><p>One disadvantage of storing all the nodes in a contiguous buffer is that it makes it harder to free an individual node as removing a single element from an arraylist would involve shifting over all the elements after it, a linear time operation which is almost always too slow to be practical. In practice this isn’t something you normally need to do as many data structures, like an AST, can be freed all at once, but if you need to be able to free individual nodes and still want to use this technique then the obvious solution would be to use a freelist.</p></div><div id="freelists"><h3><a href="#freelists">Freelists</a></h3><p>A freelist is, as the name suggests, a list used to track free slots in memory allocators. In our case we can simply use a stack to store indices of free slots in our arraylist and attempt to pop off this stack any time we add a new element. The extra code complexity should be weighed against the actual performance benefit when considering this approach.</p><figure><img src="https://joegm.github.io/blog/indices-not-pointers/Freelist-Allocation.svg" width="800"/>
<figcaption>A node allocation using a freelist</figcaption></figure></div><div id="code-examples"><h2><a href="#code-examples">Code Example</a></h2><p>Here is a short demo of this technique in Zig (v0.14.1). There are some Zig quirks involved like passing memory allocators and using an enum as an index type but hopefully the general idea is clear.</p><pre><code><span>pub</span> <span>fn</span> <span>main</span><span>(</span><span>)</span> <span>!</span><span>void</span> <span>{</span>
    <span>var</span> <span>debug_allocator</span> <span>=</span> <span>std</span><span>.</span><span>heap</span><span>.</span><span>DebugAllocator</span><span>(</span><span>.</span><span>{</span><span>}</span><span>)</span><span>.</span><span>init</span><span>;</span>
    <span>defer</span> <span>_</span> <span>=</span> <span>debug_allocator</span><span>.</span><span>deinit</span><span>(</span><span>)</span><span>;</span>

    <span>var</span> <span>tree</span> <span>=</span> <span>Tree</span><span>{</span>
        
        <span>.</span><span>nodes</span> <span>=</span> <span>ArrayList</span><span>(</span><span>Tree</span><span>.</span><span>Node</span><span>)</span><span>.</span><span>init</span><span>(</span><span>debug_allocator</span><span>.</span><span>allocator</span><span>(</span><span>)</span><span>)</span><span>,</span>
    <span>}</span><span>;</span>
    <span>defer</span> <span>tree</span><span>.</span><span>nodes</span><span>.</span><span>deinit</span><span>(</span><span>)</span><span>;</span>

    
    <span>const</span> <span>root</span> <span>=</span> <span>try</span> <span>tree</span><span>.</span><span>createNode</span><span>(</span><span>45</span><span>)</span><span>;</span>

    <span>const</span> <span>a</span> <span>=</span> <span>try</span> <span>tree</span><span>.</span><span>createNode</span><span>(</span><span>-</span><span>10</span><span>)</span><span>;</span>
    <span>const</span> <span>b</span> <span>=</span> <span>try</span> <span>tree</span><span>.</span><span>createNode</span><span>(</span><span>89000</span><span>)</span><span>;</span>
    <span>const</span> <span>c</span> <span>=</span> <span>try</span> <span>tree</span><span>.</span><span>createNode</span><span>(</span><span>2</span><span>)</span><span>;</span>

    <span>tree</span><span>.</span><span>setLeftChild</span><span>(</span><span>root</span><span>,</span> <span>a</span><span>)</span><span>;</span>
    <span>tree</span><span>.</span><span>setRightChild</span><span>(</span><span>root</span><span>,</span> <span>b</span><span>)</span><span>;</span>
    <span>tree</span><span>.</span><span>setLeftChild</span><span>(</span><span>b</span><span>,</span> <span>c</span><span>)</span><span>;</span>

    <span>printTree</span><span>(</span><span>&amp;</span><span>tree</span><span>)</span><span>;</span>
<span>}</span>

<span>const</span> <span>Tree</span> <span>=</span> <span>struct</span> <span>{</span>
    
    <span>nodes</span><span>:</span> <span>ArrayList</span><span>(</span><span>Node</span><span>)</span><span>,</span>

    <span>const</span> <span>Node</span> <span>=</span> <span>struct</span> <span>{</span>
        <span>data</span><span>:</span> <span>i32</span><span>,</span>
        <span>left_child</span><span>:</span> <span>NodeIndex</span> <span>=</span> <span>.</span><span>none</span><span>,</span>
        <span>right_child</span><span>:</span> <span>NodeIndex</span> <span>=</span> <span>.</span><span>none</span><span>,</span>
    <span>}</span><span>;</span>

    
    
    <span>const</span> <span>NodeIndex</span> <span>=</span> <span>enum</span><span>(</span><span>u32</span><span>)</span> <span>{</span>
        
        <span>none</span> <span>=</span> <span>0</span><span>,</span>
        <span>_</span><span>,</span>
    <span>}</span><span>;</span>

    <span>fn</span> <span>createNode</span><span>(</span><span>tree</span><span>:</span> <span>*</span><span>Tree</span><span>,</span> <span>value</span><span>:</span> <span>i32</span><span>)</span> <span>std</span><span>.</span><span>mem</span><span>.</span><span>Allocator</span><span>.</span><span>Error</span><span>!</span><span>NodeIndex</span> <span>{</span>
        <span>const</span> <span>index</span><span>:</span> <span>NodeIndex</span> <span>=</span> <span>@enumFromInt</span><span>(</span><span>@as</span><span>(</span><span>u32</span><span>,</span> <span>@intCast</span><span>(</span><span>tree</span><span>.</span><span>nodes</span><span>.</span><span>items</span><span>.</span><span>len</span><span>)</span><span>)</span><span>)</span><span>;</span>
        <span>try</span> <span>tree</span><span>.</span><span>nodes</span><span>.</span><span>append</span><span>(</span><span>.</span><span>{</span> <span>.</span><span>data</span> <span>=</span> <span>value</span> <span>}</span><span>)</span><span>;</span>
        <span>return</span> <span>index</span><span>;</span>
    <span>}</span>

    <span>fn</span> <span>setLeftChild</span><span>(</span><span>tree</span><span>:</span> <span>*</span><span>const</span> <span>Tree</span><span>,</span> <span>parent</span><span>:</span> <span>NodeIndex</span><span>,</span> <span>child</span><span>:</span> <span>NodeIndex</span><span>)</span> <span>void</span> <span>{</span>
        <span>tree</span><span>.</span><span>nodes</span><span>.</span><span>items</span><span>[</span><span>@intFromEnum</span><span>(</span><span>parent</span><span>)</span><span>]</span><span>.</span><span>left_child</span> <span>=</span> <span>child</span><span>;</span>
    <span>}</span>

    <span>fn</span> <span>setRightChild</span><span>(</span><span>tree</span><span>:</span> <span>*</span><span>const</span> <span>Tree</span><span>,</span> <span>parent</span><span>:</span> <span>NodeIndex</span><span>,</span> <span>child</span><span>:</span> <span>NodeIndex</span><span>)</span> <span>void</span> <span>{</span>
        <span>tree</span><span>.</span><span>nodes</span><span>.</span><span>items</span><span>[</span><span>@intFromEnum</span><span>(</span><span>parent</span><span>)</span><span>]</span><span>.</span><span>right_child</span> <span>=</span> <span>child</span><span>;</span>
    <span>}</span>
<span>}</span><span>;</span>

<span>fn</span> <span>printTree</span><span>(</span><span>tree</span><span>:</span> <span>*</span><span>const</span> <span>Tree</span><span>)</span> <span>void</span> <span>{</span>
    <span>assert</span><span>(</span><span>tree</span><span>.</span><span>nodes</span><span>.</span><span>items</span><span>.</span><span>len</span> <span>&gt;</span> <span>0</span><span>)</span><span>;</span>

    
    <span>printNode</span><span>(</span><span>tree</span><span>,</span> <span>@enumFromInt</span><span>(</span><span>0</span><span>)</span><span>,</span> <span>0</span><span>)</span><span>;</span>
<span>}</span>

<span>fn</span> <span>printNode</span><span>(</span><span>tree</span><span>:</span> <span>*</span><span>const</span> <span>Tree</span><span>,</span> <span>node_index</span><span>:</span> <span>Tree</span><span>.</span><span>NodeIndex</span><span>,</span> <span>depth</span><span>:</span> <span>u32</span><span>)</span> <span>void</span> <span>{</span>
    <span>const</span> <span>node</span> <span>=</span> <span>tree</span><span>.</span><span>nodes</span><span>.</span><span>items</span><span>[</span><span>@intFromEnum</span><span>(</span><span>node_index</span><span>)</span><span>]</span><span>;</span>

    <span>for</span> <span>(</span><span>0</span><span>..</span><span>depth</span><span>)</span> <span>|</span><span>_</span><span>|</span> <span>print</span><span>(</span><span>&#34;  &#34;</span><span>,</span> <span>.</span><span>{</span><span>}</span><span>)</span><span>;</span>
    <span>print</span><span>(</span><span>&#34;[{d}] {d}</span><span>\n</span><span>&#34;</span><span>,</span> <span>.</span><span>{</span> <span>@intFromEnum</span><span>(</span><span>node_index</span><span>)</span><span>,</span> <span>node</span><span>.</span><span>data</span> <span>}</span><span>)</span><span>;</span>

    <span>if</span> <span>(</span><span>node</span><span>.</span><span>left_child</span> <span>!=</span> <span>.</span><span>none</span><span>)</span> <span>printNode</span><span>(</span><span>tree</span><span>,</span> <span>node</span><span>.</span><span>left_child</span><span>,</span> <span>depth</span> <span>+</span> <span>1</span><span>)</span><span>;</span>
    <span>if</span> <span>(</span><span>node</span><span>.</span><span>right_child</span> <span>!=</span> <span>.</span><span>none</span><span>)</span> <span>printNode</span><span>(</span><span>tree</span><span>,</span> <span>node</span><span>.</span><span>right_child</span><span>,</span> <span>depth</span> <span>+</span> <span>1</span><span>)</span><span>;</span>
<span>}</span>

<span>const</span> <span>std</span> <span>=</span> <span>@import</span><span>(</span><span>&#34;std&#34;</span><span>)</span><span>;</span>
<span>const</span> <span>ArrayList</span> <span>=</span> <span>std</span><span>.</span><span>ArrayList</span><span>;</span>
<span>const</span> <span>assert</span> <span>=</span> <span>std</span><span>.</span><span>debug</span><span>.</span><span>assert</span><span>;</span>
<span>const</span> <span>print</span> <span>=</span> <span>std</span><span>.</span><span>debug</span><span>.</span><span>print</span><span>;</span>
</code></pre>
<p>And here is the output:</p><pre><code><span>$</span><span> </span><span>zig</span> <span>run</span> <span>indices.zig</span>
[0] <span>45</span>
  [1] -<span>10</span>
  [2] <span>89000</span>
    [3] 2
</code></pre>
</div>

    </div></div>
  </body>
</html>
