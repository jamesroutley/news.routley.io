<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://semaphoreci.com/blog/property-based-testing-python-hypothesis-pytest">Original</a>
    <h1>Getting Started with Property-Based Testing in Python with Hypothesis and Pytest</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">

		
<p>This tutorial will be your gentle guide to property-based testing. Property-based testing is a testing philosophy; a way of approaching testing, much like unit testing is a testing philosophy in which we write tests that verify individual components of your code.</p>



<p>By going through this tutorial, you will:</p>



<ul>
<li>learn what property-based testing is;</li>



<li>understand the key benefits of using property-based testing;</li>



<li>see how to create property-based tests with Hypothesis;</li>



<li>attempt a small challenge to understand how to write good property-based tests; and</li>



<li>Explore several situations in which you can use property-based testing with zero overhead.</li>
</ul>



<h2 id="what-is-property-based-testing"><strong>What is Property-Based Testing?</strong></h2>



<p>In the most common types of testing, you write a test by running your code and then checking if the result you got matches the reference result you expected. This is in contrast with <em>property-based testing</em>, where you write tests that check that the results satisfy certain <em>properties</em>. This shift in perspective makes property-based testing (with Hypothesis) a great tool for a variety of scenarios, like fuzzing or testing roundtripping.</p>



<p>In this tutorial, we will be learning about the concepts behind property-based testing, and then we will put those concepts to practice. In order to do that, we will use three tools: Python, pytest, and Hypothesis.</p>



<ul>
<li><a href="https://www.python.org/">Python</a> will be the programming language in which we will write both our functions that need testing and our tests.</li>



<li><a href="https://docs.pytest.org/">pytest</a> will be the testing framework.</li>



<li><a href="https://hypothesis.works/">Hypothesis</a> will be the framework that will enable property-based testing.</li>
</ul>



<p>Both Python and pytest are simple enough that, even if you are not a Python programmer or a pytest user, you should be able to follow along and get benefits from learning about property-based testing.</p>



<h2 id="setting-up-your-environment-to-follow-along"><strong>Setting up your environment to follow along</strong></h2>



<p>If you want to follow along with this tutorial and run the snippets of code and the tests yourself – which is highly recommendable – here is how you set up your environment.</p>



<h3 id="installing-python-and-pip"><strong>Installing Python and pip</strong></h3>



<p>Start by making sure you have a recent version of Python installed. Head to the <a href="https://www.python.org/downloads/">Python downloads page</a> and grab the most recent version for yourself. Then, make sure your Python installation also has pip installed. [<a href="https://pip.pypa.io/en/stable/#">pip</a>] is the package installer for Python and you can check if you have it on your machine by running the following command:</p>



<pre><code lang="bash">python -m pip --version</code></pre>



<p>(This assumes<code> python</code> is the command to run Python on your machine.) If pip is not installed, follow their <a href="https://pip.pypa.io/en/stable/installation/">installation instructions</a>.</p>



<h3 id="installing-pytest-and-hypothesis"><strong>Installing pytest and Hypothesis</strong></h3>



<p>pytest, the Python testing framework, and Hypothesis, the property-based testing framework, are easy to install after you have pip. All you have to do is run this command:</p>



<pre><code lang="bash">python -m pip install pytest hypothesis --upgrade</code></pre>



<p>This tells pip to install pytest and Hypothesis and additionally it tells pip to update to newer versions if any of the packages are already installed.</p>



<p>To make sure pytest has been properly installed, you can run the following command:</p>



<pre><code lang="bash">&gt; python -m pytest --version
pytest 7.2.0</code></pre>



<p>The output on your machine may show a different version, depending on the exact version of pytest you have installed.</p>



<p>To ensure Hypothesis has been installed correctly, you have to open your Python REPL by running the following:</p>



<pre><code lang="python">python</code></pre>



<p>and then, within the REPL, type <code>import hypothesis</code>. If Hypothesis was properly installed, it should look like nothing happened. Immediately after, you can check for the version you have installed with <code>hypothesis.__version__</code>. Thus, your REPL session would look something like this:</p>



<pre><code lang="python">&gt;&gt;&gt; import hypothesis
&gt;&gt;&gt; hypothesis.__version__
&#39;6.60.0&#39;</code></pre>



<h2 id="your-first-property-based-test"><strong>Your first property-based test</strong></h2>



<p>In this section, we will write our very first property-based test for a small function. This will show how to write basic tests with Hypothesis.</p>



<h3 id="the-function-to-test"><strong>The function to test</strong></h3>



<p>Suppose we implemented a function <code>gcd(n, m)</code> that computes the <a href="https://en.wikipedia.org/wiki/Greatest_common_divisor">greatest common divisor</a> of two integers. (The greatest common divisor of <code>n</code> and <code>m</code> is the largest integer <code>d</code> that divides evenly into <code>n</code> <em>and</em> <code>m</code>.) What’s more, suppose that our implementation handles positive and negative integers. Here is what this implementation could look like:</p>



<pre><code lang="python">def gcd(n, m):
    &#34;&#34;&#34;Compute the GCD of two integers by Euclid&#39;s algorithm.&#34;&#34;&#34;

    n, m = abs(n), abs(m)
    n, m = min(n, m), max(n, m)  # Sort their absolute values.
    while m % n:         # While `n` doesn&#39;t divide into `m`:
        n, m = m % n, n  # update the values of `n` amd `m`.
    return n</code></pre>



<p>If you save that into a file, say <code>gcd.py</code>, and then run it with:</p>



<pre><code lang="bash">&gt; python -i gcd.py</code></pre>



<p>you will enter an interactive REPL with your function already defined. This allows you to play with it a bit:</p>



<pre><code lang="python">λ python -i main.py
&gt;&gt;&gt; gcd(15, 6)
3
&gt;&gt;&gt; gcd(15, 5)
5
&gt;&gt;&gt; gcd(-9, 15)
3</code></pre>



<p>Now that the function is running and looks about right, we will test it with Hypothesis.</p>



<h3 id="the-property-test"><strong>The property test</strong></h3>



<p>A property-based test isn’t wildly different from a standard (pytest) test, but there are some key differences. For example, instead of writing inputs to the function <code>gcd</code>, we let Hypothesis generate arbitrary inputs. Then, instead of hardcoding the expected outputs, we write assertions that ensure that the solution satisfies the properties that it <em>should</em> satisfy.</p>



<p>Thus, to write a <em>property-based</em> test, you need to determine the <em>properties</em> that your answer should satisfy.</p>



<p>Thankfully for us, we already know the properties that the result of <code>gcd</code> must satisfy:</p>



<p>“[…] the greatest common divisor (GCD) of two or more integers […] is the largest positive integer that divides each of the integers.”</p>



<p>So, from that Wikipedia quote, we know that if <code>d</code> is the result of <code>gcd(n, m)</code>, then:</p>



<ol>
<li><code>d</code> is positive;</li>



<li><code>d</code> divides <code>n</code>;</li>



<li><code>d</code> divides <code>m</code>; and</li>



<li>no other number larger than <code>d </code>divides both <code>n</code> and <code>m</code>.</li>
</ol>



<p>To turn these properties into a test, we start by writing the signature of a <code>test_</code> function that accepts the same inputs as the function <code>gcd</code>:</p>



<pre><code lang="python">def test_gcd(n, m):
    ...</code></pre>



<p>(The prefix <code>test_</code> is not significant for Hypothesis. We are using Hypothesis with pytest and pytest looks for functions that start with <code>test_</code>, so that is why our function is called <code>test_gcd</code>.)</p>



<p>The arguments <code>n</code> and <code>m</code>, which are also the arguments of <code>gcd</code>, will be filled in by Hypothesis. For now, we will just assume that they are available.</p>



<p>If <code>n</code> and <code>m</code> are arguments that are available and for which we want to test the function <code>gcd</code>, we have to start by calling <code>gcd</code> with <code>n</code> and <code>m</code> and then saving the result. It is after calling gcd with the supplied arguments and getting the answer that we get to test the answer against the four properties listed above.</p>



<p>Taking the four properties into account, our test function could look like this:</p>



<pre><code lang="python">def test_gcd(n, m):
    d = gcd(n, m)

    assert d &gt; 0  # 1) `d` is positive
    assert n % d == 0  # 2) `d` divides `n`
    assert m % d == 0  # 3) `d` divides `m`

    # 4) no other number larger than `d` divides both `n` and `m`
    for i in range(d + 1, min(n, m)):
        assert (n % i) or (m % i)</code></pre>



<p>Go ahead and put this test function next to the function <code>gcd</code> in the file <code>gcd.py</code>. Typically, tests live in a different file from the code being tested but this is such a small example that we can have everything in the same file.</p>



<h3 id="plugging-in-hypothesis"><strong>Plugging in Hypothesis</strong></h3>



<p>We have written the test function but we still haven’t used Hypothesis to power the test. Let’s go ahead and use Hypothesis’ magic to generate a bunch of arguments <code>n</code> and <code>m</code> for our function gcd. In order to do that, we need to figure out what are <em>all</em> the legal inputs that our function gcd should handle.</p>



<p>For our function<code> gcd</code>, the valid inputs are all integers, so we need to tell Hypothesis to generate integers and feed them into <code>test_gcd</code>. To do that, we need to import a couple of things:</p>



<pre><code lang="python">from hypothesis import given, strategies as st</code></pre>



<p><code>given</code> is what we will use to tell Hypothesis that a test function needs to be <em>given</em> data. The submodule <code>strategies</code> is the module that contains lots of tools that know how to generate data.</p>



<p>With these two imports, we can annotate our test:</p>



<pre><code lang="python">from hypothesis import given, strategies as st

def gcd(n, m):
    ...

@given(st.integers(), st.integers())
def test_gcd(n, m):
    d = gcd(n, m)
    # ...</code></pre>



<p>You can read the decorator <code>@given(st.integers(), st.integers())</code> as “the test function needs to be given one integer, and then another integer”. To run the test, you can just use <code>pytest</code>:</p>



<pre><code lang="bash">λ pytest gcd.py</code></pre>



<p>(Note: depending on your operating system and the way you have things configured, pytest may not end up in your path, and the command <code>pytest gcd.py</code> may not work. If that is the case for you, you can use the command <code>python -m pytest gcd.py</code> instead.)</p>



<p>As soon as you do so, Hypothesis will scream an error message at you, saying that you got a <code>ZeroDivisionError</code>. Let us try to understand what Hypothesis is telling us by looking at the bottom of the output of running the tests:</p>



<pre><code lang="bash">...
gcd.py:8: ZeroDivisionError
--------------------------------- Hypothesis ----------------------------------
Falsifying example: test_gcd(
    m=0, n=0,
)
=========================== short test summary info ===========================
FAILED gcd.py::test_gcd - ZeroDivisionError: integer division or modulo by zero
============================== 1 failed in 0.67s ==============================</code></pre>



<p>This shows that the tests failed with a <code>ZeroDivisionError</code>, and the line that reads “Falsifying example: …” contains information about the test case that blew our test up. In our case, this was <code>n = 0</code> and <code>m = 0</code>. So, Hypothesis is telling us that when the arguments are both zero, our function fails because it raises a <code>ZeroDivisionError</code>.</p>



<p>The problem lies in the usage of the modulo operator <code>%</code>, which does not accept a right argument of zero. The right argument of <code>%</code> is zero if <code>n</code> is zero, in which case the result should be <code>m</code>. Adding an if statement is a possible fix for this:</p>



<pre><code lang="python">def gcd(n, m):
    &#34;&#34;&#34;Compute the GCD of two integers by Euclid&#39;s algorithm.&#34;&#34;&#34;

    n, m = abs(n), abs(m)
    n, m = min(n, m), max(n, m)  # Sort their absolute values.

    if not n:
        return m

    while m % n:         # While `n` doesn&#39;t divide into `m`:
        n, m = m % n, n  # update the values of `n` and `m`.
    return n</code></pre>



<p>However, Hypothesis still won’t be happy. If you run your test again, with <code>pytest gcd.py</code>, you get this output:</p>



<pre><code lang="bash">&gt; pytest gcd.py
...

FAILED gcd.py::test_gcd - assert 0 &gt; 0</code></pre>



<p>This time, the issue is with the very first property that should be satisfied. We can know this because Hypothesis tells us which assertion failed while also telling us which arguments led to that failure. In fact, if we look further up the output, this is what we see:</p>



<pre><code lang="bash">n = 0, m = 0   &lt;-- Hypothesis tells you what arguments broke the test

    @example(0, 0)
    @given(st.integers().filter(lambda n: n != 0), st.integers())
    def test_gcd(n, m):
        d = gcd(n, m)

&gt;       assert d &gt; 0  # 1) `d` is positive
E       assert 0 &gt; 0
E       Falsifying explicit example: test_gcd(
E           n=0, m=0,
E       )

gcd.py:23: AssertionError
===================== short test summary info =====================
FAILED gcd.py::test_gcd - assert 0 &gt; 0</code></pre>



<p>This time, the issue isn’t really our fault. The greatest common divisor is not defined when both arguments are zero, so it is ok for our function to not know how to handle this case. Thankfully, Hypothesis lets us customise the strategies used to generate arguments. In particular, we can say that we only want to generate integers between a minimum and a maximum value.</p>



<p>The code below changes the test so that it only runs with integers between 1 and 100 for the first argument (<code>n</code>) and between -500 and 500 for the second argument (<code>m</code>):</p>



<pre><code lang="python">@given(
    st.integers(min_value=1, max_value=100),
    st.integers(min_value=-500, max_value=500),
)
def test_gcd(n, m):
    d = gcd(n, m)
    # ...</code></pre>



<p>That is it! This was your very first property-based test.</p>



<h2 id="why-bother-with-property-based-testing"><strong>Why bother with Property-Based Testing?</strong></h2>



<p>To write good property-based tests you need to analyse your problem carefully to be able to write down <em>all</em> the properties that are relevant. This may look quite cumbersome. However, using a tool like Hypothesis has very practical benefits:</p>



<ul>
<li>Hypothesis can generate dozens or hundreds of tests for you, while you would typically only write a couple of them;</li>



<li>tests you write by hand will typically only cover the edge cases you have <em>already</em> thought of, whereas Hypothesis will not have that bias; and</li>



<li>thinking about your solution to figure out its properties can give you deeper insights into the problem, leading to even better solutions.</li>
</ul>



<p>These are just some of the advantages of using property-based testing.</p>



<h2 id="using-hypothesis-for-free"><strong>Using Hypothesis for free</strong></h2>



<p>There are some scenarios in which you can use property-based testing essentially for free (that is, without needing to spend your precious brain power), because you don’t even need to think about properties. Let’s look at two such scenarios.</p>



<h3 id="testing-roundtripping"><strong>Testing Roundtripping</strong></h3>



<p>Hypothesis is a great tool to test roundtripping. For example, the built-in functions <code>int</code> and <code>str</code> in Python should roundtrip. That is, if<code> x</code> is an integer, then <code>int(str(x))</code> should still be <code>x</code>. In other words, converting <code>x</code> to a string and then to an integer again should not change its value.</p>



<p>We can write a simple property-based test for this, leveraging the fact that Hypothesis generates dozens of tests for us. Save this in a Python file:</p>



<pre><code lang="python">from hypothesis import given, strategies as st

@given(st.integers())
def test_int_str_roundtripping(x):
    assert x == int(str(x))</code></pre>



<p>Now, run this file with pytest. Your test should pass!</p>



<h3 id="fuzzing"><strong>Fuzzing</strong></h3>



<p>Did you notice that, in our gcd example above, the very first time we ran Hypothesis we got a <code>ZeroDivisionError</code>? The test failed, not because of an assert, but simply because our function crashed.</p>



<p>Hypothesis can be used for tests like this. You do not need to write a single property because you are just using Hypothesis to see if your function can deal with different inputs. Of course, even a buggy function can pass a fuzzing test like this, but this helps catch some types of bugs in your code.</p>



<h3 id="comparing-against-a-gold-standard"><strong>Comparing against a gold standard</strong></h3>



<p>Sometimes, you want to test a function <code>f</code> that computes something that could be computed by some other function <code>f_alternative</code>. You know this other function is correct (that is why you call it a “gold standard”), but you cannot use it in production because it is very slow, or it consumes a lot of resources, or for some other combination of reasons.</p>



<p>Provided it is ok to use the function <code>f_alternative</code> in a testing environment, a suitable test would be something like the following:</p>



<pre><code lang="python">@given(...)
def test_f(...):
    assert f(...) == f_alternative(...)</code></pre>



<p>When possible, this type of test is very powerful because it directly tests if your solution is correct for a series of different arguments.</p>



<p>For example, if you refactored an old piece of code, perhaps to simplify its logic or to make it more performant, Hypothesis will give you confidence that your new function will work as it should.</p>



<h2 id="the-importance-of-property-completeness"><strong>The importance of property completeness</strong></h2>



<p>In this section you will learn about the importance of being thorough when listing the properties that are relevant. To illustrate the point, we will reason about property-based tests for a function called <code>my_sort</code>, which is your implementation of a sorting function that accepts lists of integers.</p>



<h3 id="the-results-are-sorted"><strong>The results are sorted</strong></h3>



<p>When thinking about the properties that the result of <code>my_sort</code> satisfies, you come up with the obvious thing: the result of <code>my_sort</code> must be sorted.</p>



<p>So, you set out to assert this property is satisfied:</p>



<pre><code lang="python">@given(...)
def test_my_sort(int_list):
    result = my_sort(int_list)
    for a, b in zip(result, result[1:]):
        assert a &lt;= b</code></pre>



<p>Now, the only thing missing is the appropriate strategy to generate lists of integers. Thankfully, Hypothesis knows a strategy to generate lists, which is called <code>lists</code>. All you need to do is give it a strategy that generates the elements of the list.</p>



<pre><code lang="python">from hypothesis import given, strategies as st


@given(st.lists(st.integers()))
def test_my_sort(int_list):
    result = my_sort(int_list)
    for a, b in zip(result, result[1:]):
        assert a &lt;= b</code></pre>



<p><ins><br/></ins>Now that the test has been written, here is a challenge. Copy this code into a file called <code>my_sort.py</code>. Between the import and the test, define a function <code>my_sort</code> that is wrong (that is, write a function that does not sort lists of integers) and yet passes the test if you run it with <code>pytest my_sort.py</code>. (Keep reading when you are ready for spoilers.)</p>



<p>Notice that the only property that we are testing is “all elements of the result are sorted”, so we can return <em>whatever result we want</em>, as long as it is sorted. Here is my fake implementation of <code>my_sort</code>:</p>



<pre><code lang="python">def my_sort(int_list):
    return []</code></pre>



<p>This passes our property test and yet is clearly wrong because we always return an empty list. So, are we missing a property? Perhaps.</p>



<h3 id="the-lengths-are-the-same"><strong>The lengths are the same</strong></h3>



<p>We can try to add another obvious property, which is that the input and the output should have the same length, obviously. This means that our test becomes:</p>



<pre><code lang="python">@given(st.lists(st.integers()))
def test_my_sort(int_list):
    result = my_sort(int_list)

    assert len(result) == len(int_list)

    for a, b in zip(result, result[1:]):
        assert a &lt;= b</code></pre>



<p>Now that the test has been improved, here is a challenge. Write a new version of <code>my_sort</code> that passes this test and is still wrong. (Keep reading when you are ready for spoilers.)</p>



<p>Notice that we are only testing for the length of the result and whether or not its elements are sorted, but we don’t test <em>which</em> elements are contained in the result. Thus, this fake implementation of <code>my_sort</code> would work:</p>



<pre><code lang="python">def my_sort(int_list):
    return list(range(len(int_list)))</code></pre>



<h3 id="use-the-right-numbers"><strong>Use the right numbers</strong></h3>



<p>To fix this, we can add the obvious property that the result should only contain numbers from the original list. With sets, this is easy to test:</p>



<pre><code lang="python">@given(st.lists(st.integers()))
def test_my_sort(int_list):
    result = my_sort(int_list)

    assert len(result) == len(int_list)  # Should have same length.

    assert set(result) &lt;= set(int_list)  # Should use numbers from input.

    for a, b in zip(result, result[1:]):  # Result is actually sorted.
        assert a &lt;= b</code></pre>



<p>Now that our test has been improved, I have yet another challenge. Can you write a fake version of <code>my_sort</code> that passes this test? (Keep reading when you are ready for spoilers).</p>



<p>Here is a fake version of <code>my_sort</code> that passes the test above:</p>



<pre><code lang="python">def my_sort(int_list):
    if not int_list:
        return []
    return len(int_list) * [int_list[0]]</code></pre>



<p>The issue here is that we were not precise enough with our new property. In fact, <code>set(result) &lt;= set(int_list)</code> ensures that we only use numbers that were available in the original list, but it doesn’t ensure that we use all of them. What is more, we can’t fix it by simply replacing the <code>&lt;=</code> with <code>==</code>. Can you see why?I will give you a hint. If you just replace the <code>&lt;=</code> with a <code>==</code>, so that the test becomes:</p>



<pre><code lang="python">@given(st.lists(st.integers()))
def test_my_sort(int_list):
    result = my_sort(int_list)

    assert len(result) == len(int_list)  # Should have same length.

    assert set(result) == set(int_list)  # Same numbers as input.

    for a, b in zip(result, result[1:]):  # Result is actually sorted.
        assert a &lt;= b</code></pre>



<p>then you can write this passing version of <code>my_sort</code> that is still wrong:</p>



<pre><code lang="python">def my_sort(int_list):
    if not int_list:
        return []

    s = sorted(set(int_list))
    return s + [s[-1]] * (len(int_list) - len(s))</code></pre>



<p>This version is wrong because it reuses the largest element of the original list without respecting the number of times each integer should be used. For example, for the input list<code> [1, 1, 2, 2, 3, 3]</code> the result should be unchanged, whereas this version of <code>my_sort</code> returns <code>[1, 2, 3, 3, 3, 3]</code>.</p>



<h3 id="the-final-test"><strong>The final test</strong></h3>



<p>A test that is correct and complete would have to take into account how many times each number appears in the original list, which is something the built-in <code>set</code> is not prepared to do. Instead, one could use the <code>collections.Counter</code> from the standard library:</p>



<pre><code lang="python">@given(st.lists(st.integers()))
def test_my_sort(int_list):
    result = my_sort(int_list)

    assert len(result) == len(int_list)  # Should have same length.

    assert Counter(result) == Counter(int_list)  # Should use numbers from input.

    for a, b in zip(result, result[1:]):  # Result is actually sorted.
        assert a &lt;= b</code></pre>



<p>So, at this point, your test function <code>test_my_sort</code> is complete. At this point, it is no longer possible to fool the test! That is, the only way the test will pass is if <code>my_sort</code> is a real sorting function.</p>



<h3 id="use-properties-and-specific-examples"><strong>Use properties and specific examples</strong></h3>



<p>This section showed that the properties that you test should be well thought-through and you should strive to come up with a set of properties that are as specific as possible. When in doubt, it is better to have properties that may look redundant over having too few.</p>



<p>Another strategy that you can follow to help mitigate the danger of having come up with an insufficient set of properties is to mix property-based testing with other forms of testing, which is perfectly reasonable.</p>



<p>For example, on top of having the property-based test <code>test_my_sort</code>, you could add the following test:</p>



<pre><code lang="python">def test_my_sort_specific_examples():
    assert my_sort([]) == []
    assert my_sort(list(range(10)[::-1])) == list(range(10))
    assert my_sort([42, 73, 0, 16, 10]) == [0, 10, 16, 42, 73]</code></pre>



<h2 id="conclusion"><strong>Conclusion</strong></h2>



<p>This article covered two examples of functions to which we added property-based tests. We only covered the basics of using Hypothesis to run property-based tests but, more importantly, we covered the <em>fundamental concepts</em> that enable a developer to reason about and write complete property-based tests.</p>



<p>Property-based testing isn’t a one-size-fits-all solution that means you will never have to write any other type of test, but it does have characteristics that you should take advantage of whenever possible. In particular, we saw that property-based testing with Hypothesis was beneficial in that:</p>



<ul>
<li>Hypothesis can generate dozens or hundreds of tests for you, while you would typically only write a couple of them;</li>



<li>tests you write by hand will typically only cover the edge cases you have <em>already</em> thought of, whereas Hypothesis will not have that bias; and</li>



<li>thinking about your solution to figure out its properties can give you deeper insights into the problem, leading to even better solutions.</li>
</ul>



<p>This article also went over a couple of common gotchas when writing property-based tests and listed scenarios in which property-based testing can be used with no overhead.</p>



<p>If you are interested in learning more about Hypothesis and property-based testing, we recommend you take a look at the <a href="https://hypothesis.readthedocs.io/en/latest/">Hypothesis docs</a> and, in particular, to the page <a href="https://hypothesis.readthedocs.io/en/latest/data.html">“What you can generate and how”</a>.</p>


	</div></div>
  </body>
</html>
