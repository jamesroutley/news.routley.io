<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://codingnest.com/modern-sat-solvers-fast-neat-underused-part-1-of-n/">Original</a>
    <h1>Modern SAT solvers: fast, neat and underused (2018)</h1>
    
    <div id="readability-page-1" class="page"><div role="main">

    <article>

        <header>
            
            <section>
                By <a href="https://blog.plover.com/author/horenmar/">Martin Hořeňovský</a>
                <time datetime="2018-08-03"> Aug 3rd 2018</time>
                <span>Tags: <a href="https://blog.plover.com/tag/computer-science/">Computer Science</a>, <a href="https://blog.plover.com/tag/sat/">SAT</a>, <a href="https://blog.plover.com/tag/cpp/">C++</a></span>
            </section>
        </header>

        <section>
            <p>Before I started doing research for <a href="http://ida.felk.cvut.cz/">Intelligent Data Analysis (IDA) group at FEE CTU</a>, I saw SAT solvers as academically interesting but didn&#39;t think that they have many practical uses outside of other academic applications. After spending ~1.5 years working with them, I have to say that modern SAT solvers are fast, neat and criminally underused by the industry.</p>
<h2 id="introduction">Introduction</h2>
<p>Boolean satisfiability problem (SAT) is the problem of deciding whether a formula in boolean logic is satisfiable. A formula is <em>satisfiable</em> when at least one interpretation (an assignment of <code>true</code> and <code>false</code> values to logical variables) leads to the formula evaluating to <code>true</code>. If no such interpretation exists, the formula is <em>unsatisfiable</em>.</p>
<p>What makes SAT interesting is that a variant of it was the first problem to be proven <a href="https://en.wikipedia.org/wiki/Cook%E2%80%93Levin_theorem">NP-complete</a>, which roughly means that a lot of other problems can be translated into SAT in reasonable<sup><a href="#fn1" id="fnref1">[1]</a></sup> time, and the solution to this translated problem can be converted back into a solution for the original problem.</p>
<p>As an example, the often-talked-about dependency management problem, is also NP-Complete and thus translates into SAT<sup><a href="#fn2" id="fnref2">[2]</a></sup><sup><a href="#fn3" id="fnref3">[3]</a></sup>, and SAT could be translated into dependency manager. The problem our group worked on, generating key and lock cuttings based on user-provided lock-chart and manufacturer-specified geometry, is also NP-complete.</p>
<p>I will likely write about master-key systems and our approach towards solving them later, but to keep this post reasonably short, we will instead use <a href="https://en.wikipedia.org/wiki/Sudoku">Sudoku</a> for practical examples.</p>
<h2 id="usingsatsolvers">Using SAT solvers</h2>
<p>These days, SAT almost always refers to CNF-SAT<sup><a href="#fn4" id="fnref4">[4]</a></sup>, a boolean satisfaction problem for formulas in <a href="https://en.wikipedia.org/wiki/Conjunctive_normal_form">conjunctive normal form (CNF)</a>. This means that the entire formula is a conjunction (AND) of clauses, with each clause being a disjunction (OR) of literals. Some examples:</p>
<ul>
<li>$(A \vee B) \wedge (B \vee C)$</li>
<li>$(A \vee B) \wedge C$</li>
<li>$A \vee B$</li>
<li>$A \wedge C$</li>
</ul>
<p>There are two ways to pass a formula to a SAT solver: by using a semi-standard file format known as <a href="http://www.satcompetition.org/2009/format-benchmarks2009.html">DIMACS</a>, or by using the SAT solver as a library. In real-world applications, I prefer using SAT solver as a library (e.g. <a href="https://github.com/master-keying/minisat/">MiniSat for C++</a>), but the DIMACS format lets you prototype your application quickly, and quickly test the performance characteristics of different solvers on your problem.</p>
<h3 id="dimacsformat">DIMACS format</h3>
<p>DIMACS is a line oriented format, consisting of 3 different basic types of lines.</p>
<ol>
<li>A comment line. Any line that starts with &#34;c&#34; is comment line.</li>
<li>A summary line. This line contains information about the kind and size of the problem within the file. A summary line starts with &#34;p&#34;, continues with the kind of the problem (in most cases &#34;cnf&#34;), the number of variables and the number of clauses within this problem. Some DIMACS parsers expect this line to be the first non-comment line, but some parsers can handle the file without it.</li>
<li>A clause line. A clause line consists of space-separated numbers, ending with a 0. Each non-zero number denotes a literal, with negative numbers being negative literals of that variable, and 0 being the terminator of a line.</li>
</ol>
<p>As an example, this formula</p>
<pre><code>c An example formula
c
p cnf 3 4
1 2 3 0
-1 2 3 0
1 -2 3 0
1 2 -3 0
</code></pre>
<h3 id="minisatscinterface">Minisat&#39;s C++ interface</h3>
<p><a href="http://minisat.se/">MiniSat</a> is a fairly simple and performant SAT solver that also provides a nice C++ interface and we <a href="https://github.com/master-keying/minisat/">maintain a modernised fork with CMake integration</a>. The C++ interface to MiniSat uses 3 basic vocabulary types:</p>
<ul>
<li><code>Minisat::Solver</code> - Implementation of the core solver and its algorithms.</li>
<li><code>Minisat::Var</code> - Representation of a <em>variable</em>.</li>
<li><code>Minisat::Lit</code> - Representation of a concrete (positive or negative) <em>literal</em> of a variable.</li>
</ul>
<p>The difference between a variable and a literal is that the literal is a concrete &#34;evaluation&#34; of a variable inside a clause. As an example, formula $ (A \vee B \vee \neg C) \wedge (\neg A \vee \neg B) $ contains 3 variables, $A$, $B$ and $C$, but it contains 5 literals, $A$, $\neg A$, $B$, $\neg B$ and $\neg C$.</p>
<p>MiniSat&#39;s interface also uses one utility type: <code>Minisat::vec&lt;T&gt;</code>, a container similar to <code>std::vector</code>, that is used to pass clauses to the solver.</p>
<p>The following example uses MiniSat&#39;s C++ API to solve the same clause as we used in the DIMACS example.</p>
<pre><code>// main.cpp:
#include &lt;minisat/core/Solver.h&gt;

#include &lt;iostream&gt;

int main() {
    using Minisat::mkLit;
    using Minisat::lbool;

    Minisat::Solver solver;
    // Create variables
    auto A = solver.newVar();
    auto B = solver.newVar();
    auto C = solver.newVar();
    
    // Create the clauses
    solver.addClause( mkLit(A),  mkLit(B),  mkLit(C));
    solver.addClause(~mkLit(A),  mkLit(B),  mkLit(C));
    solver.addClause( mkLit(A), ~mkLit(B),  mkLit(C));
    solver.addClause( mkLit(A),  mkLit(B), ~mkLit(C));
    
    // Check for solution and retrieve model if found
    auto sat = solver.solve();
    if (sat) {
        std::clog &lt;&lt; &#34;SAT\n&#34;
                  &lt;&lt; &#34;Model found:\n&#34;;
        std::clog &lt;&lt; &#34;A := &#34; &lt;&lt; (solver.modelValue(A) == l_True) &lt;&lt; &#39;\n&#39;;
        std::clog &lt;&lt; &#34;B := &#34; &lt;&lt; (solver.modelValue(B) == l_True) &lt;&lt; &#39;\n&#39;;
        std::clog &lt;&lt; &#34;C := &#34; &lt;&lt; (solver.modelValue(C) == l_True) &lt;&lt; &#39;\n&#39;;
    } else {
        std::clog &lt;&lt; &#34;UNSAT\n&#34;;
        return 1;
    }
}
</code></pre>
<p>Because all of our clauses have length $\le 3$, we can get away with just using utility overloads that MiniSat provides, and don&#39;t need to use <code>Minisat::vec</code> for the clauses.</p>
<p>We will also need to build the binary. Assuming you have installed our fork of MiniSat (either from <a href="https://github.com/master-keying/minisat/">GitHub</a>, or from <a href="https://github.com/Microsoft/vcpkg">vcpkg</a>), it provides proper CMake integration and writing the CMakeLists.txt is trivial:</p>
<pre><code>cmake_minimum_required (VERSION 3.5)
project (minisat-example LANGUAGES CXX)

set(CMAKE_CXX_EXTENSIONS OFF)

find_package(MiniSat 2.2 REQUIRED)

add_executable(minisat-example
    main.cpp
)
target_link_libraries(minisat-example MiniSat::libminisat)
</code></pre>
<p>Building the example and running it should<sup><a href="#fn5" id="fnref5">[5]</a></sup> give you this output:</p>
<pre><code>SAT
Model found:
A := 0
B := 1
C := 1
</code></pre>
<h3 id="conversiontocnf">Conversion to CNF</h3>
<p>Very few problems are naturally expressed as a logical formula in the CNF format, which means that after formulating a problem as a SAT, we often need to convert it into CNF. The most basic approach is to create an equivalent formula using De-Morgan laws, distributive law and the fact that two negations cancel out. This approach has two advantages: one, it is simple and obviously correct. Two, it does not introduce new variables. However, it has one significant disadvantage: some formulas lead to exponentially large CNF conversion.</p>
<p>The other approach is to create an equisatisfiable<sup><a href="#fn6" id="fnref6">[6]</a></sup> CNF formula, but we won&#39;t be covering that in this post.</p>
<p>Some common equivalencies are in the table below.</p>
<table>
<thead>
<tr>
<th>Original clause</th>
<th>Equivalent clause</th>
</tr>
</thead>
<tbody>
<tr>
<td>$ \neg \neg \alpha $</td>
<td>$ \alpha $</td>
</tr>
<tr>
<td>$ \alpha \implies \beta $</td>
<td>$ \neg \alpha \vee \beta $</td>
</tr>
<tr>
<td>$ \neg ( \alpha \wedge \beta ) $</td>
<td>$ \neg \alpha \vee \neg \beta $</td>
</tr>
<tr>
<td>$ \neg ( \neg \alpha \wedge \neg \beta ) $</td>
<td>$ \alpha \vee \beta $</td>
</tr>
<tr>
<td>$ (\alpha \wedge \beta) \vee \gamma $</td>
<td>$ (\alpha \vee \gamma) \wedge (\beta \vee \gamma) $</td>
</tr>
<tr>
<td>$ \alpha \iff \beta $</td>
<td>$ \left(\alpha \implies \beta \right) \wedge \left(\alpha \impliedby \beta \right) $</td>
</tr>
</tbody>
</table>
<p>Obviously, you don&#39;t have to remember these identities, but knowing at least some of them (implication) is much faster than deriving them from the truth tables every time.</p>
<h2 id="solvingsudokuusingsat">Solving Sudoku using SAT</h2>
<p>With this background, we can now look at how we could use a real-world problem, such as <a href="https://en.wikipedia.org/wiki/Sudoku">Sudoku</a>, using a SAT solver. First, we will go over the rules of Sudoku and how they can be translated into (CNF-)SAT. Then we will go over implementing this converter in C++ and benchmarking the results.</p>
<h3 id="quickoverviewofsudoku">Quick overview of Sudoku</h3>
<p>Sudoku is a puzzle where you need to place numbers 1-9 into a 9x9 grid consisting of 9 3x3 boxes<sup><a href="#fn7" id="fnref7">[7]</a></sup>, following these rules:</p>
<ol>
<li>Each row contains all of the numbers 1-9</li>
<li>Each column contains all of the numbers 1-9</li>
<li>Each of the 3x3 boxes contains all of the numbers 1-9</li>
</ol>
<p>We can also restate this rules as:</p>
<ol>
<li>No row contains duplicate numbers</li>
<li>No column contains duplicate numbers</li>
<li>No 3x3 box contains duplicate numbers</li>
</ol>
<p>Because these rules alone wouldn&#39;t make for a good puzzle, some of the positions are prefilled by the puzzle setter, and a proper Sudoku puzzle should have only one possible solution.</p>
<h3 id="translatingtherules">Translating the rules</h3>
<p>The first step in translating a problem to SAT is to decide what should be modelled via variables, and what should be modelled via clauses over these variables. With Sudoku, the natural thing to do is to model positions as variables, but in SAT, each variable can only have 2 values: &#34;true&#34; and &#34;false&#34;. This means we cannot just assign each position a variable, instead we have to assign each combination of position <em>and</em> value a variable. We will denote such variable as $x_{r, c}^{v}$. If variable $x_{r, c}^{v}$ is set to &#34;true&#34;, then the number in $r$-th row and $c$-th column is $v$.</p>
<p>Using this notation, let&#39;s translate the Sudoku rules from the previous section into SAT.</p>
<p><strong>Rule 1 (No row contains duplicate numbers)</strong></p>
<p>In plain words, for each row and each value, we want exactly one column in that row to have that value. We do that by using a helper called $\operatorname{exactly-one}$, that generates a set of clauses that ensure that exactly <em>one</em> of the passed-in literals evaluate to &#34;true&#34;.</p>
<p>We will see how to define $\operatorname{exactly-one}$ later. First, we will translate the other Sudoku rules into these pseudo-boolean formulas.</p>
<p><strong>Rule 2 (No column contains duplicate numbers)</strong></p>
<p>This works analogically with Rule 1, in that for each column and each value, we want exactly one row to have that value.</p>
<p><strong>Rule 3 (None of the 3x3 boxes contain duplicate numbers)</strong></p>
<p>This rule works exactly the same way as the first two: for each box and each value, we want exactly one position in the box to have that value.</p>
<p>\[</p>
<p>Even though it seems to be enough at first glance, these 3 rules are in fact <em>not</em> enough to properly specify Sudoku. This is because a solution like this one:</p>
<table>
<thead>
<tr>
<th></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>x</td>
<td>.</td>
<td>.</td>
<td>.</td>
<td>.</td>
<td>.</td>
<td>.</td>
<td>.</td>
<td>.</td>
</tr>
<tr>
<td>1</td>
<td>.</td>
<td>.</td>
<td>.</td>
<td>x</td>
<td>.</td>
<td>.</td>
<td>.</td>
<td>.</td>
<td>.</td>
</tr>
<tr>
<td>2</td>
<td>.</td>
<td>.</td>
<td>.</td>
<td>.</td>
<td>.</td>
<td>.</td>
<td>x</td>
<td>.</td>
<td>.</td>
</tr>
<tr>
<td>3</td>
<td>.</td>
<td>x</td>
<td>.</td>
<td>.</td>
<td>.</td>
<td>.</td>
<td>.</td>
<td>.</td>
<td>.</td>
</tr>
<tr>
<td>4</td>
<td>.</td>
<td>.</td>
<td>.</td>
<td>.</td>
<td>x</td>
<td>.</td>
<td>.</td>
<td>.</td>
<td>.</td>
</tr>
<tr>
<td>5</td>
<td>.</td>
<td>.</td>
<td>.</td>
<td>.</td>
<td>.</td>
<td>.</td>
<td>.</td>
<td>x</td>
<td>.</td>
</tr>
<tr>
<td>6</td>
<td>.</td>
<td>.</td>
<td>x</td>
<td>.</td>
<td>.</td>
<td>.</td>
<td>.</td>
<td>.</td>
<td>.</td>
</tr>
<tr>
<td>7</td>
<td>.</td>
<td>.</td>
<td>.</td>
<td>.</td>
<td>.</td>
<td>x</td>
<td>.</td>
<td>.</td>
<td>.</td>
</tr>
<tr>
<td>8</td>
<td>.</td>
<td>.</td>
<td>.</td>
<td>.</td>
<td>.</td>
<td>.</td>
<td>.</td>
<td>.</td>
<td>x</td>
</tr>
</tbody>
</table>
<p>where &#34;x&#34; denotes a position where <em>all</em> variables are set to &#34;true&#34; and &#34;.&#34; denotes a position where <em>no</em> variables are set to &#34;true&#34;, is valid according to the rules as given to the SAT solver.</p>

<p>This is because we operate with an unstated assumption, that each position can contain only one number. This makes perfect sense to a human, but the SAT solver does not understand the meaning of the variables, it only sees clauses it was given. We can fix this simply by adding one more rule:</p>
<p><strong>Rule 4 (Each position contains exactly one number)</strong></p>
<p>\[</p>
<p>With this rule in place, we have fully translated the rules of Sudoku into SAT and can use a SAT solver to help us solve sudoku instances. But before we do that, we need to define the $\operatorname{exactly-one}$ helper our description of Sudoku relies on.</p>
<h4 id="exactlyonehelper">exactly-one helper</h4>
<p>There is no way to encode numeric constraints natively in boolean logic, but often you can decompose these constraints into simpler terms and encode these. Many research papers have been written about the efficient encoding of specific constraints and other gadgets, but in this post, we only need to deal with the most common and one of the simplest constraints possible: &#34;exactly one of this set of literals has to evaluate to true&#34;. Everyone who works with SAT often can write this constraint from memory, but we will derive it from first principles because it shows how more complex constraints can be constructed.</p>
<p>The first step is to decompose the constraint $x == n$ into two parts: $x \ge n$ and $x \le n$, or for our specific case, $x \ge 1$ and $x \le 1$, or, translated into the world of SAT, at least 1 literal has to evaluate to &#34;true&#34;, and no more than 1 literal can evaluate to &#34;true&#34;. Forcing at <em>least one</em> literal to be true is easy, just place all of them into one large disjunction:</p>
<p>\[</p>
<p>Forcing <em>at most</em> one literal to be true seems harder, but with a slight restating of the logic, it also becomes quite easy. At most one literal is true when <em>there is no pair of literals where both of the literals are true at the same time</em>.</p>
<p>\[</p>
<p>This set of clauses says exactly that, but it has one problem: it is not in CNF. To convert them into CNF, we have to use <a href="#conversiontocnf">some of the identities in the previous section on converting formulas to CNF</a>. Specifically, the fact that negating a disjunction leads to a conjunction of negations, and negating a conjunction leads to a disjunction of negations. Using these, we get the following CNF formula:</p>
<p>\[</p>
<p>We can also use the fact that both conjunction and disjunction are commutative (there is no difference between $x \wedge y$ and $y \wedge x$) to halve the number of clauses we create, as we only need to consider literal pairs where $i &lt; j$.</p>
<p>Now that we know how to limit the number of &#34;true&#34; literals to both <em>at least</em> 1 and <em>at most</em> 1, limiting the number of &#34;true&#34; literals to <em>exactly</em> 1 is trivial; just apply both constraints at the same time via conjunction.</p>
<h3 id="cimplementation">C++ implementation</h3>
<p>Now that we know how to describe Sudoku as a set of boolean clauses in CNF, we can implement a C++ code that uses this knowledge to solve arbitrary Sudoku. For brevity, this post will only contain relevant excerpts, <a href="https://github.com/horenmar/sudoku-example">but you can find the entire resulting code on GitHub</a><sup><a href="#fn8" id="fnref8">[8]</a></sup>.</p>
<p>The first thing we need to solve is addressing variables, specifically converting a (row, column, value) triple into a specific value that represents it in the SAT solver. Because Sudoku is highly regular, we can get away with linearizing the three dimensions into one, and get the number of variable corresponding to $x_{r, c}^{v}$ as <code>r * 9 * 9 + c * 9 + v</code>. We can also use the fact that <code>Minisat::Var</code>is just a plain <code>int</code> numbered from 0 to avoid storing the variables at all because we can always compute the corresponding variable on-demand:</p>
<pre><code>Minisat::Var toVar(int row, int column, int value) {
    return row * columns * values + column * values + value;
}
</code></pre>
<p>Now that we can quickly retrieve the SAT variable from a triplet of (row, column, value), but before we can use the variables, they need to be allocated inside the SAT solver:</p>
<pre><code>void Solver::init_variables() {
    for (int r = 0; r &lt; rows; ++r) {
        for (int c = 0; c &lt; columns; ++c) {
            for (int v = 0; v &lt; values; ++v) {
                static_cast&lt;void&gt;(solver.newVar());
            }
        }
    }
}
</code></pre>
<p>With the variables allocated, we can start converting the SAT version of Sudoku rules into C++ code.</p>
<p><strong>Rule 1 (No row contains duplicate numbers)</strong></p>
<pre><code>for (int row = 0; row &lt; rows; ++row) {
    for (int value = 0; value &lt; values; ++value) {
        Minisat::vec&lt;Minisat::Lit&gt; literals;
        for (int column = 0; column &lt; columns; ++column) {
            literals.push(Minisat::mkLit(toVar(row, column, value)));
        }
        exactly_one_true(literals);
    }
}
</code></pre>
<p><strong>Rule 2 (No column contains duplicate numbers)</strong></p>
<pre><code>for (int column = 0; column &lt; columns; ++column) {
    for (int value = 0; value &lt; values; ++value) {
        Minisat::vec&lt;Minisat::Lit&gt; literals;
        for (int row = 0; row &lt; rows; ++row) {
            literals.push(Minisat::mkLit(toVar(row, column, value)));
        }
        exactly_one_true(literals);
    }
}
</code></pre>
<p><strong>Rule 3 (None of the 3x3 boxes contain duplicate numbers)</strong></p>
<pre><code>for (int r = 0; r &lt; 9; r += 3) {
    for (int c = 0; c &lt; 9; c += 3) {
        for (int value = 0; value &lt; values; ++value) {
            Minisat::vec&lt;Minisat::Lit&gt; literals;
            for (int rr = 0; rr &lt; 3; ++rr) {
                for (int cc = 0; cc &lt; 3; ++cc) {
                    literals.push(Minisat::mkLit(toVar(r + rr, c + cc, value)));
                }
            }
            exactly_one_true(literals);
        }
    }
}
</code></pre>
<p><strong>Rule 4 (Each position contains exactly one number)</strong></p>
<pre><code>for (int row = 0; row &lt; rows; ++row) {
    for (int column = 0; column &lt; columns; ++column) {
        Minisat::vec&lt;Minisat::Lit&gt; literals;
        for (int value = 0; value &lt; values; ++value) {
            literals.push(Minisat::mkLit(toVar(row, column, value)));
        }
        exactly_one_true(literals);
    }
}
</code></pre>
<p>We also need to define the <code>exactly_one_true</code> helper:</p>
<pre><code>void Solver::exactly_one_true(Minisat::vec&lt;Minisat::Lit&gt; const&amp; literals) {
    solver.addClause(literals);
    for (size_t i = 0; i &lt; literals.size(); ++i) {
        for (size_t j = i + 1; j &lt; literals.size(); ++j) {
            solver.addClause(~literals[i], ~literals[j]);
        }
    }
}
</code></pre>
<p>With these snippets, we have defined a model of Sudoku as SAT. There are still 2 pieces of the solver missing: a method to specify values in the pre-filled positions of the board and a method that extracts the found solution to the puzzle.</p>
<p>Fixing the values in specific positions is easy, we can just add a unary clause for each specified position:</p>
<pre><code>bool Solver::apply_board(board const&amp; b) {
    for (int row = 0; row &lt; rows; ++row) {
        for (int col = 0; col &lt; columns; ++col) {
            auto value = b[row][col];
            if (value != 0) {
                solver.addClause(Minisat::mkLit(toVar(row, col, value - 1)));
            }
        }
    }
    return ret;
}
</code></pre>
<p>Because the only way to satisfy a unary clause is to set the appropriate variable to the polarity of the contained literal, this forces the specific position to always contain the desired value.</p>
<p>To retrieve a solution, we need to be able to determine a position&#39;s value. Because only one of the variables for any given position can be set to true, the value corresponding to that specific variable is the value of the given position:</p>
<pre><code>board Solver::get_solution() const {
    board b(rows, std::vector&lt;int&gt;(columns));
    for (int row = 0; row &lt; rows; ++row) {
        for (int col = 0; col &lt; columns; ++col) {
            for (int val = 0; val &lt; values; ++val) {
                if (solver.modelValue(toVar(row, col, val)).isTrue()) {
                    b[row][col] = val + 1;
                    break;
                }
            }
        }
    }
    return b;
}
</code></pre>
<p>With the solver finished, we can go on to benchmarking its performance.</p>
<h2 id="benchmarks">Benchmarks</h2>
<p>As far as I could tell from a cursory search, there are no standard test suites for benchmarking Sudoku solvers. I decided to follow <a href="http://norvig.com/sudoku.html">Norvig&#39;s blog post about his own Sudoku solver</a> and use <a href="https://raw.githubusercontent.com/horenmar/sudoku-example/master/inputs/benchmark/top95.txt">this set of 95 hard Sudokus</a> for measuring the performance of my solver.</p>
<p>The measurements were done on PC with factory-clocked i5-6600K CPU @ 3.5 GHz, the code was compiled using <code>g++</code> under Windows Subsystem for Linux, and each input was run 10 times. After that, I took the mean of the results for each problem and put all of them into a boxplot. Since I am a proponent of LTO builds, I also compiled the whole thing, including MiniSat, with LTO enabled, and then benchmarked the binary.</p>
<p>These are the results:</p>
<p><img src="https://blog.plover.com/content/images/2018/08/hi-qual-plot.png" alt="hi-qual-plot"/></p>
<p>As you can see, the LTO build performed somewhat better, but not significantly so. What is interesting, is that the number of outliers <em>above</em> the box, and the relative lengths of the whiskers, suggest that the underlying distribution of solver&#39;s running time over all of the inputs is heavy-tailed. This means that the longest-running inputs will need significantly longer to be solved than the others, and it is a common attribute of solvers for NP-complete problems. This is because a single wrong decision during the search for a solution can lengthen the total runtime significantly.</p>
<p>There is one more question to answer, namely, how does this performance compare with high-performance Sudoku-specialized solvers? I picked 2, <a href="http://forum.enjoysudoku.com/3-77us-solver-2-8g-cpu-testcase-17sodoku-t30470-90.html#p216748">ZSolver</a> and <a href="https://github.com/dobrichev/fsss2">fsss2</a>, and tried running them on the same set of problems. Not too surprisingly, they both outperformed our SAT-based solver badly. The sort of &#34;converting&#34; solver we wrote will always be slower than a well-tuned specialised solver, but they do have some advantages that can make them desirable. As an example, I have no prior domain-specific knowledge about solving Sudokus, but I was able to write the SAT-based Sudoku solver in less than 2 hours. It is also much more readable and extendable<sup><a href="#fn9" id="fnref9">[9]</a></sup>.</p>
<hr/>
<p><em>That is all for part 1, but I have much more I want to say about SAT solvers, so you can expect more posts about both using them, and about their internals and the theory behind why are they so fast.</em></p>
<p><em>There are more <a href="https://codingnest.com/modern-sat-solvers-fast-neat-and-underused-part-1-5-of-n/">benchmarks in part 1.5</a>, and <a href="https://codingnest.com/modern-sat-solvers-fast-neat-and-underused-part-2-of-n/">part 2 shows how to implement a SAT-based solver for master-key systems</a>.</em></p>
<hr/>
<section>
<ol>
<li id="fn1"><p>This means polynomial, because when it comes to complexity theory, algorithms with polynomial complexity are generally considered tractable, no matter how high the exponent in the polynomial is, and algorithms with exponential complexity are considered intractable. <a href="#fnref1">↩︎</a></p>
</li>
<li id="fn2"><p>At least as long as we assume that</p><ul>
<li>To install a package, all its dependencies must be installed</li>
<li>A package can list specific versions of other packages as dependencies</li>
<li>Dependency sets of each version of a package can be different</li>
<li>Only one version of a package can be installed</li></ul>
 <a href="#fnref2">↩︎</a></li>
<li id="fn3"><p>In fact, various dependency managers in the wild already use SAT solvers, such as <a href="https://fedoraproject.org/wiki/Features/DNF#Detailed_Description">Fedora&#39;s DNF</a>, Eclipse&#39;s plugin manager, <a href="https://github.com/freebsd/pkg/tree/master/external/picosat">FreeBSD&#39;s pkg</a>, Debian&#39;s apt (optionally), and others. <a href="#fnref3">↩︎</a></p>
</li>
<li id="fn4"><p>There are some extensions like XOR-SAT, which lets you natively encode XOR clauses, but these are relatively rare and only used in specialist domain, e.g. cryptanalysis. <a href="#fnref4">↩︎</a></p>
</li>
<li id="fn5"><p>When using the library interface of MiniSat, it defaults to being entirely deterministic. This means that if you are using the same version of MiniSat, the result will always be the same, even though there are different models. <a href="#fnref5">↩︎</a></p>
</li>
<li id="fn6"><p>Two formulas, f1 and f2, are equisatisfiable when f1 being satisfied means that f2 is also satisfied and vice versa. <a href="#fnref6">↩︎</a></p>
</li>
<li id="fn7"><p>There is also a notion of generalised sudoku, where you have to fill in numbers 1-N in NxN grid according to the same rules. It is proven to be <a href="http://www-imai.is.s.u-tokyo.ac.jp/~yato/data2/SIGAL87-2.pdf">NP-complete</a>. <a href="#fnref7">↩︎</a></p>
</li>
<li id="fn8"><p>The real code differs in places, especially in that it is coded much more defensively and contains more validity checking in the form of assertions. <a href="#fnref8">↩︎</a></p>
</li>
<li id="fn9"><p>Try reading through the code of the linked solvers and imagine extending them to work with 18x18 boards. With our solver, it is just a matter of changing 3 constants on top of a file from 9 to 18. <a href="#fnref9">↩︎</a></p>
</li>
</ol>
</section>

        </section>

        
    <!--
    If you want Disqus comments, uncomment this. Make sure to set your disqus shortname in partials/comments.hbs first!
     -->
    </article>
</div></div>
  </body>
</html>
