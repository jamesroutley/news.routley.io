<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.pixelmelt.dev/kindle-web-drm/">Original</a>
    <h1>How I bypassed Amazon&#39;s Kindle web DRM</h1>
    
    <div id="readability-page-1" class="page"><div id="site-main">
<article>

    <header>

        

        

            <p>As it turns out they don&#39;t actually want you to do this (and have some interesting ways to stop you)</p>

        

            <figure>
                <img srcset="https://images.unsplash.com/photo-1656115914684-2845b7a13476?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=M3wxMTc3M3wwfDF8c2VhcmNofDF8fGNhdCUyMGtpbmRsZXxlbnwwfHx8fDE3NjAzMTQ5NDd8MA&amp;ixlib=rb-4.1.0&amp;q=80&amp;w=300 300w,
                            https://images.unsplash.com/photo-1656115914684-2845b7a13476?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=M3wxMTc3M3wwfDF8c2VhcmNofDF8fGNhdCUyMGtpbmRsZXxlbnwwfHx8fDE3NjAzMTQ5NDd8MA&amp;ixlib=rb-4.1.0&amp;q=80&amp;w=600 600w,
                            https://images.unsplash.com/photo-1656115914684-2845b7a13476?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=M3wxMTc3M3wwfDF8c2VhcmNofDF8fGNhdCUyMGtpbmRsZXxlbnwwfHx8fDE3NjAzMTQ5NDd8MA&amp;ixlib=rb-4.1.0&amp;q=80&amp;w=1000 1000w,
                            https://images.unsplash.com/photo-1656115914684-2845b7a13476?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=M3wxMTc3M3wwfDF8c2VhcmNofDF8fGNhdCUyMGtpbmRsZXxlbnwwfHx8fDE3NjAzMTQ5NDd8MA&amp;ixlib=rb-4.1.0&amp;q=80&amp;w=2000 2000w" sizes="(min-width: 1400px) 1400px, 92vw" src="https://images.unsplash.com/photo-1656115914684-2845b7a13476?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=M3wxMTc3M3wwfDF8c2VhcmNofDF8fGNhdCUyMGtpbmRsZXxlbnwwfHx8fDE3NjAzMTQ5NDd8MA&amp;ixlib=rb-4.1.0&amp;q=80&amp;w=2000" alt="How I Reversed Amazon&#39;s Kindle Web Obfuscation Because Their App Sucked"/>
                    <figcaption><span>Photo by </span><a href="https://unsplash.com/@madalyncox?utm_source=ghost&amp;utm_medium=referral&amp;utm_campaign=api-credit"><span>Madalyn Cox</span></a><span> / </span><a href="https://unsplash.com/?utm_source=ghost&amp;utm_medium=referral&amp;utm_campaign=api-credit"><span>Unsplash</span></a></figcaption>
            </figure>

    </header>

    <section>
        <h2 id="tldr">TL;DR</h2><ul><li>I bought my first ebook from amazon</li><li>Amazon&#39;s Kindle Android app was really buggy and crashed a bunch</li><li>Tried to download my book to use with a functioning reader app</li><li>Realized Amazon no longer lets you do that</li><li>Decided to reverse engineer their obfuscation system out of spite</li><li>Discovered multiple layers of protection including randomized alphabets</li><li>Defeated all of them with font matching wizardry</li></ul><h2 id="part-1-amazon-made-this-personal">Part 1: Amazon Made This Personal</h2><h3 id="the-one-time-i-tried-to-do-things-the-right-way">The One Time I Tried To Do Things The Right Way</h3><p>I&#39;ve been &#34;obtaining&#34; ebooks for years. But this ONE time, I thought: &#34;Let&#39;s support the author.&#34;</p><p>Download Kindle app on Android. Open book.</p><p><strong>Crash.</strong></p><h3 id="i-just-wanted-to-read-my-book">I Just Wanted To Read My Book</h3><p>App crashes. Fine, I&#39;ll use the web reader.</p><p>Oh wait, can&#39;t download it for offline reading. What if I&#39;m on a plane?</p><p>Hold on, I can&#39;t even export it to Calibre? Where I keep ALL my other books?</p><p>So let me get this straight:</p><ul><li>I paid money for this book</li><li>I can only read it in Amazon&#39;s broken app</li><li>I can&#39;t download it</li><li>I can&#39;t back it up</li><li>I don&#39;t actually own it</li><li>Amazon can delete it whenever they want</li></ul><p><strong>This is a rental, not a purchase.</strong></p><figure><img src="https://blog.pixelmelt.dev/content/images/2025/10/image.png" alt="" loading="lazy" width="495" height="354"/><figcaption><span>This does not say &#34;Rent&#34;</span></figcaption></figure><h3 id="it-becomes-personal">It Becomes Personal</h3><p>I could&#39;ve refunded and &#34;obtained&#34; it in 30 seconds. Would&#39;ve been easier.</p><p>But that&#39;s not the point.</p><p>The point is I PAID FOR THIS BOOK. It&#39;s mine. And I&#39;m going to read it in Calibre with the rest of my library even if I have to reverse engineer their web client to do it.</p><h3 id="reversal-time">Reversal Time</h3><p>Kindle Cloud Reader (the web version) actually works. While looking through the network requests, I spotted this:</p><pre><code>https://read.amazon.com/renderer/render
</code></pre><p>To download anything, you need:</p><p>1. Session cookies - standard Amazon login</p><p>2. Rendering token - from the startReading API call</p><p>3. ADP session token - extra auth layer</p><p>Sending the same headers and cookies the browser does returns a TAR file.</p><h3 id="whats-inside-the-tar">What&#39;s Inside The TAR?</h3><pre><code>page_data_0_4.json   # The &#34;text&#34; (spoiler: it&#39;s not text)
glyphs.json          # SVG definitions for every character
toc.json             # Table of contents
metadata.json        # Book info
location_map.json    # Position mappings</code></pre><h2 id="part-3-amazons-obfuscation-layers-of-ebook-hell">Part 3: Amazon&#39;s Obfuscation Layers of Ebook Hell</h2><p>Downloaded the first few pages, expected to see text. Got this instead:</p><pre><code>{
  &#34;type&#34;: &#34;TextRun&#34;,
  &#34;glyphs&#34;: [24, 25, 74, 123, 91, 18, 19, 30, 4, ...],
  &#34;style&#34;: &#34;paragraph&#34;
}</code></pre><p>These aren&#39;t letters. They&#39;re glyph IDs. Character &#39;T&#39; isn&#39;t Unicode 84, it&#39;s glyph 24.</p><p>And glyph 24 is just a series of numbers that define a stroke path, its just an image of a letter.</p><p>It&#39;s a substitution cipher! Each character maps to a non-sequential glyph ID.</p><h3 id="the-alphabet-changes-every-five-pages">The Alphabet Changes Every. Five. Pages.</h3><p>Downloaded the next batch of pages. Same letter &#39;T&#39; is now glyph 87.</p><p>Next batch? Glyph 142.</p><p><strong>They randomize the entire alphabet on EVERY request.</strong></p><p>This means:</p><ul><li>You can only get 5 pages at a time (API hard limit)</li><li>Each request gets completely new glyph mappings</li><li>Glyph IDs are meaningless across requests</li><li>You can&#39;t build one mapping table for the whole book</li></ul><h3 id="let-me-show-you-how-bad-this-is">Let Me Show You How Bad This Is</h3><p>For my 920-page book:</p><ul><li><strong>184 separate API requests</strong> needed</li><li><strong>184 different random alphabets</strong> to crack</li><li><strong>361 unique glyphs</strong> discovered (a-z, A-Z, punctuation, ligatures)</li><li><strong>1,051,745 total glyphs</strong> to decode</li></ul><h3 id="fake-font-hints-theyre-getting-sneaky">Fake Font Hints (They&#39;re Getting Sneaky)</h3><p>Some SVG paths contained this garbage:</p><pre><code>M695.068,0 L697.51,-27.954 m3,1 m1,6 m-4,-7 L699.951,-55.908 ...</code></pre><p>Looking at it, we see these tiny <code>m3,1 m1,6 m-4,-7</code> commands, they are micro MoveTo operations.</p><p><strong>Why this is evil:</strong></p><ul><li>Browsers handle them fine (native Path2D)</li><li>Python SVG libraries create spurious connecting lines</li><li>Makes glyphs look corrupted when rendered naively</li><li>Breaks path-sampling approaches</li></ul><p>This is deliberate anti-scraping. The glyphs render perfectly in browser but make it so we cant just compare paths in our parser.</p><p>Take a look</p><figure><img src="https://blog.pixelmelt.dev/content/images/2025/10/image-2.png" alt="" loading="lazy" width="1768" height="609" srcset="https://blog.pixelmelt.dev/content/images/size/w600/2025/10/image-2.png 600w, https://blog.pixelmelt.dev/content/images/size/w1000/2025/10/image-2.png 1000w, https://blog.pixelmelt.dev/content/images/size/w1600/2025/10/image-2.png 1600w, https://blog.pixelmelt.dev/content/images/2025/10/image-2.png 1768w" sizes="(min-width: 720px) 720px"/><figcaption><span>Fun!</span></figcaption></figure><p>Eventually I figured out that filling in the complete path mitigated this.</p><figure><img src="https://blog.pixelmelt.dev/content/images/2025/10/id_131_bookerly.png" alt="" loading="lazy" width="200" height="200"/></figure><h3 id="multiple-font-variants">Multiple Font Variants</h3><p>Not just one font. FOUR variants:</p><ul><li>bookerly_normal (99% of glyphs)</li><li>bookerly_italic (emphasis)</li><li>bookerly_bold (headings)</li><li>bookerly_bolditalic (emphasized headings)</li></ul><p>Plus special ligatures: ff, fi, fl, ffi, ffl</p><p>More variations = more unique glyphs to crack = more pain.</p><h3 id="ocr-is-mid-my-failed-attempt">OCR Is Mid (My Failed Attempt)</h3><p>Tried running OCR on rendered glyphs. Results:</p><ul><li>178/348 glyphs recognized (51%)</li><li>170 glyphs failed completely</li></ul><p>OCR just sucks at single characters without context. Confused &#39;l&#39; with &#39;I&#39; with &#39;1&#39;. Couldn&#39;t handle punctuation. Gave up on ligatures entirely.</p><p>OCR probably need words and sentences to work well.</p><h2 id="part-4-the-solution-that-actually-worked">Part 4: The Solution That Actually Worked</h2><p>Every request includes `glyphs.json` with SVG path definitions:</p><pre><code>{
  &#34;24&#34;: {
    &#34;path&#34;: &#34;M 450 1480 L 820 1480 L 820 0 L 1050 0 L 1050 1480 ...&#34;,
    &#34;fontFamily&#34;: &#34;bookerly_normal&#34;
  },
  &#34;87&#34;: {
    &#34;path&#34;: &#34;M 450 1480 L 820 1480 L 820 0 L 1050 0 L 1050 1480 ...&#34;,
    &#34;fontFamily&#34;: &#34;bookerly_normal&#34;
  }
}</code></pre><p><strong>Glyph IDs change, but SVG shapes don&#39;t.</strong></p><h3 id="why-direct-svg-comparison-failed">Why Direct SVG Comparison Failed</h3><p>First attempt: normalize and compare SVG path coordinates.</p><p>Failed because:</p><ul><li>Coordinates vary slightly</li><li>Path commands represented differently</li></ul><h3 id="pixel-perfect-matching">Pixel-Perfect Matching</h3><p>Screw coordinate comparison. Let&#39;s just render everything and compare pixels.</p><figure><img src="https://blog.pixelmelt.dev/content/images/2025/10/id_028_bookerly.png" alt="" loading="lazy" width="128" height="128"/><figcaption><span>Render that A</span></figcaption></figure><p>1. <strong>Render every SVG as an image</strong></p><ul><li>Use cairosvg (lets us handle those fake font hints correctly)</li><li>Render at 512 x 512px for accuracy</li></ul><p>2. <strong>Generate perceptual hashes</strong></p><ul><li>Hash each rendered image</li><li>The hash becomes the unique identifier</li><li>Same shape = same hash, regardless of glyph ID</li></ul><p>3. <strong>Build normalized glyph space</strong></p><ul><li>Map all 184 random alphabets to hash-based IDs</li><li>Now glyph &#34;a1b2c3d4...&#34; always means letter &#39;T&#39;</li></ul><p>4. <strong>Match to actual characters</strong></p><ul><li>Download Bookerly TTF fonts</li><li>Render every character (A-Z, a-z, 0-9, punctuation)</li><li>Use SSIM (Structural Similarity Index) to match</li></ul><h3 id="why-ssim-is-perfect-for-this">Why SSIM Is Perfect For This</h3><p>SSIM compares image structure, not pixels directly. It handles:</p><ul><li>Slight rendering differences</li><li>Anti-aliasing variations</li><li>Minor scaling issues</li></ul><p>For each unknown glyph, find the TTF character with highest SSIM score. That&#39;s your letter.</p><h3 id="handling-the-edge-cases">Handling The Edge Cases</h3><p><strong>Ligatures:</strong> ff, fi, fl, ffi, ffl</p><ul><li>These are single glyphs for multiple characters</li><li>Had to add them to TTF library manually</li></ul><p><strong>Special characters:</strong> em-dash, quotes, bullets</p><ul><li>Extended character set beyond basic ASCII</li><li>Matched against full Unicode range in Bookerly</li></ul><p><strong>Font variants:</strong> Bold, italic, bold-italic</p><ul><li>Built separate libraries for each variant</li><li>Match against all libraries, pick best score</li></ul><h2 id="part-5-the-moment-it-all-worked">Part 5: The Moment It All Worked</h2><h3 id="final-statistics">Final Statistics</h3><pre><code>=== NORMALIZATION PHASE ===
Total batches processed: 184
Unique glyphs found: 361
Total glyphs in book: 1,051,745

=== MATCHING PHASE ===
Successfully matched 361/361 unique glyphs (100.00%)
Failed to match: 0 glyphs
Average SSIM score: 0.9527

=== DECODED OUTPUT ===
Total characters: 5,623,847
Pages: 920</code></pre><p>Perfect. Every single character decoded correctly.</p><h3 id="epub-reconstruction-with-perfect-formatting">EPUB Reconstruction With Perfect Formatting</h3><p>The JSON includes positioning for every text run:</p><pre><code>{
  &#34;glyphs&#34;: [24, 25, 74],
  &#34;rect&#34;: {&#34;left&#34;: 100, &#34;top&#34;: 200, &#34;right&#34;: 850, &#34;bottom&#34;: 220},
  &#34;fontStyle&#34;: &#34;italic&#34;,
  &#34;fontWeight&#34;: 700,
  &#34;fontSize&#34;: 12.5,
  &#34;link&#34;: {&#34;positionId&#34;: 7539}
}</code></pre><p>I used this to preserve:</p><ul><li>Paragraph breaks (Y-coordinate changes)</li><li>Text alignment (X-coordinate patterns)</li><li>Bold/italic styling</li><li>Font sizes</li><li>Internal links</li></ul><p>The final EPUB is near indistinguishable from the original!</p><h2 id="the-real-conclusion">The Real Conclusion</h2><p>Amazon put real effort into their web obfuscation.</p><h3 id="was-it-worth-it">Was It Worth It?</h3><p>To read one book? No.</p><p>To prove a point? Absolutely.</p><p>To learn about SVG rendering, perceptual hashing, and font metrics? Probably yes.</p><h3 id="use-this-knowledge-responsibly">Use This Knowledge Responsibly</h3><p>This is for backing up books YOU PURCHASED.</p><p>Don&#39;t get me sued into oblivion thanks.</p><div><p>Due to the nature of this post, if you are in any way affiliated with Amazon, please reach out to pixelmelt + at + protonmail.com.</p></div>
    </section>

        

</article>
</div></div>
  </body>
</html>
