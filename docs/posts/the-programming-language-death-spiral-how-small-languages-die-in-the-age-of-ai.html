<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://hamy.xyz/blog/2025-12_programming-language-death-spiral">Original</a>
    <h1>The Programming Language Death Spiral - How Small Languages Die in the Age of AI</h1>
    
    <div id="readability-page-1" class="page"><p>DISCLOSURE: If you buy through affiliate links, I may earn a small commission. <a href="https://sqlite.org/blog/disclosures">(disclosures)</a></p><div><p>The programming language death spiral has been top of mind for me as I shift my primary language <a href="https://hamy.xyz/blog/2025-11_why-im-moving-blog-fsharp-to-csharp">from F# (a top 50 lang) to C# (a top 5 lang)</a>.</p>
<p>I first discussed this phenomenon back in <a href="https://hamy.xyz/blog/2023-06-state-of-fsharp#f-salaries-2023">2023 in the State of F#</a> as the greatest existential threat to the language and ecosystem.</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/x2Gf04W_ff8?si=5HGwhH4UzXroMcMT" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe>
<h2 id="big-languages-have-a-virtuous-cycle">Big Languages have a virtuous cycle</h2>
<p><img src="https://storage.googleapis.com/iamhamy-static/labs/posts/2025/2025-12_programming-language-death-spiral/2025-11_programming-language-death-spiral_virtuous-vicious-cycle.png" alt="Virtuous and Vicious Cycle"/></p>
<p>The basic premise is:</p>
<ul>
<li>Lots of companies use mainstream languages</li>
<li>Lots of jobs are available in them</li>
<li>Lots of projects are built in them - as part of work, from ppl who know them, funded by these companies</li>
<li>Lots of people learn them - as they can make money and onboarding is ~easy</li>
<li>New companies are built in these languages - on the ecosystem, by the people that know them</li>
</ul>
<p>This is a virtuous cycle.</p>
<ul>
<li>More companies mean more jobs / funding</li>
<li>More jobs / funding mean more projects / resources</li>
<li>More projects / resources means more people learn them</li>
<li>More people learning them mean more companies are built with them</li>
</ul>
<p>Plus companies are often slow to move - it&#39;s very costly to overhaul a whole system to a new technology / language so often once a company uses one, that thing sticks around for a long time. This means it continues getting funding, maintaining jobs, and improving the ecosystem long into the future. Examples of these include the COBOL and FORTRAN mainframes still running many large companies today.</p>
<h2 id="small-languages-have-a-vicious-cycle-a-death-spiral">Small languages have a vicious cycle - a death spiral</h2>
<ul>
<li>Few companies use it meaning less jobs / funding</li>
<li>Few jobs / funding available for it means less projects / resources available for it</li>
<li>Few projects / resources means less people learn it</li>
<li>Few people learning it means less companies built with it</li>
</ul>
<p>As much as we&#39;d like the best theoretical technology to win, humans don&#39;t always act rationally or maybe they do but there&#39;s a lot of other influences on their decision.</p>
<ul>
<li>Why use thing A when thing B makes money?</li>
<li>Why use thing A when thing B is easier to onboard to / debug?</li>
<li>Why learn thing A when I&#39;m already getting paid to learn thing B?</li>
</ul>
<p>Of course this isn&#39;t a static cycle. When new tools come around, they can escape the small language death spiral and take market share away from other big players. But those tools typically must be much better than their predecessors or have some edge vs the others - a killer feature that makes it worthwhile to invest in the language even if the potential payoff is years in the future.</p>
<p><em>I don&#39;t know HOW much better they need to be but I&#39;d posit it needs to feel 2-5x better for engineers to warrant a shift AND it needs to be as good or better at accomplishing the task if it doesn&#39;t have a killer feature for the usecase.</em></p>
<p>Examples of new languages popping up that chip away at incumbent&#39;s virtuous cycles:</p>
<ul>
<li>TypeScript bringing some sanity in the form of types to the chaos that is JavaScript. Also the types are really good (if not always real). (Plug for F# which the TS type system was based on).</li>
<li>Go making performant, memory-managed system-level programming accessible to the masses due to its simple design (<a href="https://hamy.xyz/blog/2025-01_programming-language-tier-list">overly simple in my opinion</a>) - taking market share from projects that might be built in lower level C, C++, C#, Java, and even higher level Python, Ruby,</li>
<li>Rust making highly performant, memory safe coding possible with guardrails in the type system which nerdsniped a whole generation of the type, performance, and low-level obsessed programmers - taking market share from low level langs like C, C++, and many who were into more niche languages with cool type systems like Haskell</li>
<li>Kotlin slowly chipping away at Java with its more expressive, less boilerplatey type system and ergonomics</li>
</ul>
<h2 id="ai-amplifies-these-adoption-cycles">AI amplifies these adoption cycles</h2>
<p><img src="https://storage.googleapis.com/iamhamy-static/labs/posts/2025/2025-12_programming-language-death-spiral/2025-11_programming-language-death-spiral_ai-amplifies-cycles.png" alt="AI Amplifies Adoption Cycles"/></p>
<p>AI is a big shift in how we build software:</p>
<ul>
<li>Essentially replaced programming reference sites like Stack Overflow</li>
<li>Can build small, well-defined features reliably</li>
<li>Slowly improving at building larger, more complex features</li>
</ul>
<p>It&#39;s not perfect but it&#39;s changing the way a large portion of the industry builds software and that&#39;s really impressive in the short time it&#39;s been on the scene.</p>
<p><img src="https://storage.googleapis.com/iamhamy-static/labs/posts/2025/2025-12_programming-language-death-spiral/2025-11_programming-lang-death-spiral_top-langs-github.png" alt="Top 10 programming languages on GitHub by activity"/></p>
<p><em>Source: <a href="https://madnight.github.io/githut/#/pushes/2024/1">GitHut 2.0</a></em></p>
<p>AI coding proficiency is currently directly tied to training data. Top 10 langs have 10-100x more code examples and docs online than those outside it. This means that the AIs will have more training data to work on for gathering patterns, best practices, and knowledge of available tools.</p>
<p><em>When I compare C# (3.329%) and F# (0.107%) by activity, we see a ~30x difference. This isn&#39;t quite equal to available training data but it is a reasonable proxy.</em></p>
<p>Plus AI companies will have a higher monetary incentive to benchmark and improve in those languages. Large companies like Microsoft and Google will fund research teams and AI model providers to improve training on languages they use and promote - C#, TypeScript, Go, and Python being likely contenders. Extend this to the SP500 and there will be a lot of money invested in AI models to improve software generation in the langs those cos are using and, largely, those cos are using top 10 mainstream languages and therefore will be the ones getting majority investment.</p>
<p>Essentially we can expect AI to amplify the network effects already present in the programming language ecosystem.</p>
<p><img src="https://storage.googleapis.com/iamhamy-static/labs/posts/2025/2025-12_programming-language-death-spiral/2025-11_programming-lang-death-spiral_benchmarks.png" alt="LLM Benchmarks on Large and Small languages"/></p>
<p><em>Source: <a href="https://arxiv.org/html/2410.03981v3#S5">A Survey on LLM-based Code Generation for Low-Resource and Domain-Specific Programming Languages</a></em></p>
<p>When we compare AI coding today in large vs small langs, we can expect a 2-3x difference in code &#34;quality&#34;. This gap gets wider depending on the gap in usage and if a lang is small enough, it may not have critical mass of training data to be able to code in it at all.</p>
<p><em>Here&#39;s an anecdotal experience from someone trying to use AI to code F#: &#34;none of the models are very good at generating modern, idiomatic F#&#34;, &#34;None of them generated useful, working code. To get any of it working, I had to do way-too-much syntax fixing, and then way-too-much debugging.&#34; - <a href="https://www.scottarbeit.com/blog/llm-s-and-smaller-less-popular-programming-languages">Scott Arbeit</a></em></p>
<p>As companies and the industry shift to use more AI in their workflows, AI is going to become a greater force multiplier. Those languages that don&#39;t keep up will be fighting an increasingly uphill battle for adoption.</p>
<h2 id="theres-still-hope-for-small-languages">There&#39;s still hope for small languages</h2>
<blockquote><p lang="en" dir="ltr">If F# (or any other niche language) wants to stay relevant in the age of LLMs, we need to see a lot more good, working code online.</p>‚Äî Hamilton Greene üê∑ü¶î (@SIRHAMY) <a href="https://twitter.com/SIRHAMY/status/1991573764270666151?ref_src=twsrc%5Etfw">November 20, 2025</a></blockquote> 
<p>Small languages can make a comeback but it is an uphill battle.</p>
<p>They basically need:</p>
<ul>
<li>More public code examples</li>
<li>More blog posts</li>
<li>More prodding AI cos to benchmark, tweak, and train for their languages</li>
</ul>
<p>And who knows? There may be some structural improvements on the horizon.</p>
<ul>
<li>If AI ever achieves reasoning, it may be able to train and correct itself - particularly because it can test itself against a real compiler and inputs / outputs</li>
<li>We may find new scaffolding techniques for generating &#34;skill libraries&#34; that AIs can reference to boost their proficiency in languages their base model wasn&#39;t trained for. If these can be built with AI then this could be a scalable solution for all langs.</li>
</ul>
<p>But the onus is on the few users of the small languages. No large co is going to do this for them - they can&#39;t make a business case to even use the language, much less fund the open source projects / maintainers for tech they don&#39;t rely on.</p>
<p><em>We should also be a bit wary of the AI training data bit rot. There have been <a href="https://www.technologyreview.com/2025/09/25/1124005/ai-wikipedia-vulnerable-languages-doom-spiral/">attempts to use AI to translate rare human languages</a> before and while there&#39;s some success, they often miss enough to potentially corrupt their own training data in the future. This means the more stuff created with it, the worse it gets. Programming languages are slightly different in that they can be objectively tested with compilers and input/output but smth to be aware of.</em></p>
<h2 id="next">Next</h2>
<p>The programming language death spiral has been around a long time. AI just amplifies it.</p>
<p>I don&#39;t think this necessarily means you should avoid small languages. If you love or are interested in a niche technology, I think you should dive in. You&#39;ll certainly learn something and likely enjoy the process even if you don&#39;t stick with it long term. Voting with your actions is one of the best things you can do to keep it around.</p>
<p>But I&#39;m also a weird person with weird interests - I program for <em>fun</em>. A lot of people don&#39;t so I think we need to be cognizant of this paradigm and realize that this is how the market currently acts. If you want to change it, this is what you&#39;re up against.</p>
<p><em>After writing this, I realized this has similar properties to the OO vs functional paradigm (OO is more mainstream, functional more niche). Good video on this is <a href="https://www.youtube.com/watch?v=QyJZzq0v7Z4">Why Isn&#39;t Functional Programming the Norm? ‚Äì Richard Feldman</a></em></p>
<p>If you liked this post you might also like:</p>
<ul>
<li><a href="https://hamy.xyz/blog/2025-12_software-engineers-ai">If AI can code, what will Software Engineers do?</a></li>
<li><a href="https://hamy.xyz/blog/2025-07_stop-vibe-coding">Stop Vibe Coding, Start Power Coding - How To Write Quality Software Faster With Agentic AI</a></li>
<li><a href="https://hamy.xyz/blog/2025-10_how-i-actually-use-ai">How I Actually Code with AI as a Senior Software Engineer</a></li>
</ul>
</div></div>
  </body>
</html>
