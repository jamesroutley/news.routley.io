<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://domm.plix.at/perl/2024_06_chopping_utf8.html">Original</a>
    <h1>How to chop off bytes of an UTF-8 string to fit into a small slot and look nice</h1>
    
    <div id="readability-page-1" class="page"><div id="content">
      <p>While researching a very weird bug in <a href="https://koha-community.org/">Koha</a> I had to figure out a way chop a string to a specific maximum length. In <b>bytes</b> and not in <b>characters</b>, because in that case the horrible format <a href="https://www.loc.gov/marc/specifications/specrecstruc.html"><span>USMARC</span></a> is used, whose spec starts with two red flags: It&#39;s from January 2000, and it&#39;s an &#34;implementation of the American national standard&#34;, so you can bet that it only works (well) with <span>ASCII </span>and will be ... interesting when handling Unicode. But it&#39;s generally broken for longer strings.</p>

<h3>Bytes vs. Characters</h3>

<p>I assume you know the difference between bytes and characters (or code points). If not: <a href="https://perldoc.perl.org/perlunicode#Byte-and-Character-Semantics">read this</a>!</p>

<p>As you&#39;ve probably haven&#39;t read the link, here&#39;s a very short summary:</p>

<ul>
<li><span>UTF8 </span>uses variable length to store letters in zeros and ones. Older formats (like <span>ASCII</span>) used a fixed length (eg one byte = 8 bit), but could therefore only represent a limited amount of letters.</li>
<li>&#34;Regular&#34; letters (if you&#39;re talking about English) take 1 byte.</li>
<li>But we can handle letters besides English. And we have &#34;letters&#34; like ðŸš². ðŸš² takes 4 bytes. See a lot of details <a href="https://codepoints.net/U+1F6B2">here</a>.</li>
<li>Usually, if a regular person talks about the length of a string, they count letters: &#34;Hello&#34; has 5 letters. &#34;HelloðŸš²&#34; has 6 letters.</li>
<li>Unfortunately, computers sometimes need to know the number of bytes (eg to store the data somewhere). &#34;Hello&#34; takes 5 bytes. &#34;HelloðŸš²&#34; takes <b>9</b> bytes.</li>
</ul>

<h3>How long is my string?</h3>

<p>So let&#39;s compare &#34;I love to ride my bicycle&#34; with &#34;I â™¥ to ride my ðŸš²&#34;.</p>

<pre><code>~$ perl -C -Mutf8 -MEncode -E &#39;say q{&#34;I love to ride my bicycle&#34; vs. &#34;I â™¥ to ride my ðŸš²&#34;}&#39;
   &#34;I love to ride my bicycle&#34; vs. &#34;I â™¥ to ride my ðŸš²&#34;</code></pre>

<p>The maybe weird command line flags are explained in this footnote.</p>

<p>Per default, Perl counts characters, using <code>length()</code>:</p>

<pre><code>~$ perl -C -Mutf8 -MEncode -E &#39;say length(&#34;I love to ride my bicycle&#34;)&#39;
   25</code></pre>

<p>So 25 characters.</p>

<pre><code>~$ perl -C -Mutf8 -MEncode -E &#39;say length(&#34;I â™¥ to ride my ðŸš²&#34;)&#39;
   16</code></pre>

<p>And now only 16.</p>

<p>If we want to count bytes (which is something you should not usually do, because the computers should handle it for you), we need to use <code>bytes::length()</code>:</p>

<pre><code>~$ perl -C -Mutf8 -MEncode -E &#39;say bytes::length(&#34;I love to ride my bicycle&#34;)&#39;
   25</code></pre>

<p>Also 25 bytes, because each of the basic English letters takes one byte.</p>

<pre><code>~$ perl -C -Mutf8 -MEncode -E &#39;say bytes::length(&#34;I â™¥ to ride my ðŸš²&#34;)&#39;
   21</code></pre>

<p>But the fancy Unicode version now takes 21 bytes, because â™¥ takes 3 bytes and ðŸš² 4, so <code>3 + 4 - 2 = 5</code> bytes more than characters.</p>

<h3>Stuff it into limited space</h3>

<p>Now say we only have 20 bytes to store this string. So we need to chop of some of the text, using <code>substr()</code>:</p>

<pre><code>~$ perl -C -Mutf8 -MEncode -E &#39;say substr(&#34;I love to ride my bicycle&#34;, 0, 20)&#39;
   I love to ride my bi</code></pre>

<p>Works!</p>

<p>If we do that on the fancy Unicode version:</p>

<pre><code>~$ perl -C -Mutf8 -MEncode -E &#39;say substr(&#34;I â™¥ to ride my ðŸš²&#34;, 0, 20)&#39;
   I â™¥ to ride my ðŸš²</code></pre>

<p>We get the same string back! Because, by default, Perl counts characters. And the string only has 16 characters. But 21 bytes. Which is 1 byte too much. So we need to use <code>bytes::substr()</code>:</p>

<pre><code>~$ perl -C -Mutf8 -MEncode -E &#39;say bytes::substr(&#34;I â™¥ to ride my ðŸš²&#34;, 0, 20)&#39;
   I Ã¢Â¥ to ride my Ã°</code></pre>

<h3>What&#39;s that garbage?</h3>

<p>As we&#39;re leaving the safe and padded space of regular Perl string handling and calling <code>bytes</code>, we unfortunately have to be a bit more careful and know about some Perl internals (which I will handwave a bit): Perl tracks if a string contains <span>UTF</span>-8. If you call <code>bytes</code>, it sort of forgets that the string contains the <span>UTF</span>-8 and now outputs raw bytes. But we want Perl to interpret that string returned from <code>bytes::substr</code> as <span>UTF</span>-8, so we explicitly have to tell it via <code>decode_utf8</code> (imported from <code>Encode</code>). I find the name <code>decode_utf8</code> a bit confusing, but it helps (me) to think about it like this: Decode this string of bytes (or <code>octets</code> as the docs say) which we know to contain <span>UTF</span>-8 into a Perl string of characters. So:</p>

<pre><code>~$ perl -C -Mutf8 -MEncode -E &#39;say decode_utf8(bytes::substr(&#34;I â™¥ to ride my ðŸš²&#34;, 0, 20))&#39;
   I â™¥ to ride my ï¿½</code></pre>

<p>Yay, we have the â™¥ back!</p>

<p>Another way to do this (so we don&#39;t have to use <code>bytes</code>) is to pass <code>substr</code> the byte representation of the strings, which we can generate using <code>encode_utf8</code>. Which is again a bit confusing, unless you think about it like this: Take this Perl string and encode it into a bunch of bytes using <span>UTF</span>-8:</p>

<pre><code>perl -C -Mutf8 -MEncode -E &#39;say decode_utf8(substr(encode_utf8(&#34;I â™¥ to ride my ðŸš²&#34;), 0, 20))&#39;
   I â™¥ to ride my ï¿½</code></pre>

<p>Same, but a tiny bit nicer!</p>

<p>Anyway, we have the â™¥ back. But the resulting string is bit ugly, because it ends with &#34;ï¿½&#34;. As we&#39;ve chopped a few bytes of the ðŸš², we do indeed end up with an invalid symbol, which is rendered as ï¿½.</p>

<p>But how long is this mangled string?</p>

<pre><code>~$ perl -C -Mutf8 -MEncode -E &#39;say bytes::length(bytes::substr(&#34;I â™¥ to ride my ðŸš²&#34;, 0, 20))&#39;
   20</code></pre>

<p>Yay, 20 bytes, now it fits!</p>

<h3>Stuff it into limited space, but without trailing garbage</h3>

<p>Now maybe we don&#39;t like that ï¿½ at the end. There&#39;s a nice flag you can pass to <code>decode_utf8()</code> that I&#39;ve learned about while working with/against the original bug: <code>Encode::FB_QUIET</code>.</p>

<pre><code>perl -C -Mutf8 -MEncode -E &#39;say decode_utf8(substr(encode_utf8(&#34;I â™¥ to ride my ðŸš²&#34;),0,20),Encode::FB_QUIET)&#39;
   I â™¥ to ride my </code></pre>

<p>No more ï¿½! Because <code>FB_QUIET</code> tells <code>decode_utf8</code> to <a href="https://perldoc.perl.org/Encode#Handling-Malformed-Data">ignore invalid bytes</a>.</p>

<p>And how long is it?</p>

<pre><code>perl -C -Mutf8 -MEncode -E &#39;say bytes::length(decode_utf8(substr(encode_utf8(&#34;I â™¥ to ride my ðŸš²&#34;),0,20),Encode::FB_QUIET))&#39;
   17</code></pre>

<p>Even shorter, because now the string does not contain any bicycle parts :-)</p>

<h3>All the strings</h3>

<p>For fun, here are all the substrings from 1 to original string, without any &#34;half&#34; / invalid characters. You can see quite nicely that ðŸš² takes a few steps before it can be completely rendered:</p>

<pre><code>perl -C -Mutf8 -MEncode -E &#39;my $s= &#34;I â™¥ to ride my ðŸš²&#34;; for my $l (1 .. bytes::length($s)) { say decode_utf8(substr(encode_utf8($s),0,$l),Encode::FB_QUIET)}&#39;
I
I 
I 
I 
I â™¥
I â™¥ 
I â™¥ t
I â™¥ to
I â™¥ to 
I â™¥ to r
I â™¥ to ri
I â™¥ to rid
I â™¥ to ride
I â™¥ to ride 
I â™¥ to ride m
I â™¥ to ride my
I â™¥ to ride my 
I â™¥ to ride my 
I â™¥ to ride my 
I â™¥ to ride my 
I â™¥ to ride my ðŸš²</code></pre>

<h3>Footnotes</h3>







<ul>
<li><code>-C</code> is short for <code>-CESL</code> which turns on <span>UTF</span>-8 for various input and output streams (STDOUT etc). See <code>perldoc perlrun</code>.</li>
<li><code>-Mutf8</code> loads the module <code>utf8</code> and is the same as calling <code>use utf8;</code> in the source code. This tells Perl that the source code itself contains <span>UTF</span>-8 characters. Like ðŸš²...</li>
<li><code>-MEncode</code> loads <code>Encode</code>.</li>
</ul>
    </div></div>
  </body>
</html>
