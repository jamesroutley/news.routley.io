<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://bencher.dev/learn/engineering/sqlite-performance-tuning/">Original</a>
    <h1>Why SQLite Performance Tuning Made Bencher 1200x Faster</h1>
    
    <div id="readability-page-1" class="page"><div> <section> <div> <div>  <nav> <div> <p><img src="https://s3.amazonaws.com/public.bencher.dev/author/everett-pompeii-500.jpg" width="32" alt="Everett Pompeii"/> </p>  </div> </nav> <hr/>  <astro-island uid="wEfOa" component-url="/_astro/SelfHostedRedirct.T-EoBPBO.js" component-export="default" renderer-url="/_astro/client.deXdCEd9.js" props="{&#34;path&#34;:[0,&#34;/docs/api&#34;]}" ssr="" client="only" opts="{&#34;name&#34;:&#34;SelfHostedRedirect&#34;,&#34;value&#34;:&#34;solid-js&#34;}"></astro-island>  <p>Last week, I got <a href="https://github.com/bitcoin/bitcoin/issues/27284#issuecomment-2046870296">feedback from a user</a>
that <a href="https://bencher.dev/perf/0xb10c-s-bitcoin-core">their Bencher Perf Page</a> was taking a while to load.
So I decided to check it out, and oh, man were they being nice.
It took sooo long to load! Embarrassingly long.
Especially for the leading <a href="https://bencher.dev/docs/explanation/continuous-benchmarking/">Continuous Benchmarking</a> tool.</p>
<p>In the past, I‚Äôve used the <a href="https://bencher.dev/perf/rustls-821705769?notify_kind=alert&amp;notify_text=Learn+more+about+continuous+benchmarking+for+the+Rustls+project.&amp;notify_timeout=2147483647&amp;notify_link_url=https%3A%2F%2Fbencher.dev%2Flearn%2Fcase-study%2Frustls%2F&amp;notify_link_text=Read+the+case+study">Rustls Perf Page</a> as my litmus test.
They have 112 benchmarks and <a href="https://bencher.dev/learn/case-study/rustls/">one of the most impressive Continuous Benchmarking setups out there</a>.
It used to take about 5 seconds load. This time around it took‚Ä¶ ‚è≥üëÄ ‚Ä¶ 38.8 seconds!
With that sort of latency, I had to dig in. Performance bugs are bugs, after all!</p>
<div><figure><img src="https://s3.amazonaws.com/public.bencher.dev/engineering/sqlite-performance-tuning/http-response-times.png" width="2368" height="1472" alt="High HTTP Response Times"/><figcaption>The worst HTTP response time hit 2 minutes!</figcaption></figure></div>
<h2 id="background">Background<a href="#background"><small><i aria-hidden="true"></i></small></a></h2>
<p>From the very start, I knew that the <a href="https://bencher.dev/docs/api/projects/perf/#get-v0projectsprojectperf">Bencher Perf API</a>
was going to be one of the most demanding endpoints performance wise.
I believe the main reason that so many folks have had to <a href="https://bencher.dev/docs/reference/prior-art/#benchmark-tracking-tools">reinvent the benchmark tracking wheel</a>
is that the existing off-the-shelf tools don‚Äôt handle the high dimensionality required.
By ‚Äúhigh dimensionality‚Äù, I mean being able to track performance over time and across multiple dimensions:
<a href="https://bencher.dev/docs/explanation/benchmarking/#branch">Branches</a>, <a href="https://bencher.dev/docs/explanation/benchmarking/#testbed">Testbeds</a>, <a href="https://bencher.dev/docs/explanation/benchmarking/#benchmarks">Benchmarks</a>, and <a href="https://bencher.dev/docs/explanation/benchmarking/#measures">Measures</a>.
This ability to slice and dice across five different dimensions leads to a very complex model.</p>
<p>Because of this inherent complexity and the nature of the data,
I considered using a time series database for Bencher.
In the end though, I settled on using SQLite instead.
I figured it was better to <a href="https://paulgraham.com/ds.html">do things that don‚Äôt scale</a>
than to spend the extra time learning an entirely new database architecture that may or may not actually help.</p>
<p>Over time, the demands on the Bencher Perf API have also increased.
Originally, you had to select all of the dimensions that you wanted to plot manually.
This created a lot of friction for users to get to a useful plot.
To solve this, I <a href="https://github.com/bencherdev/bencher/issues/133">added a list of the most recent Reports</a> to the Perf Pages,
and by default, the most recent Report was selected and plotted.
This means that if there were 112 benchmarks in the most recent Report, then all 112 would be plotted.
The model also got even more complicated with the ability to track and visualize <a href="https://bencher.dev/docs/explanation/thresholds/">Threshold Boundaries</a>.</p>
<p>With this in mind, I made a few performance related improvements.
Since the Perf Plot needs the most recent Report to start plotting,
I refactored the <a href="https://bencher.dev/docs/api/projects/reports/#get-v0projectsprojectreports">Reports API</a> to get a Report‚Äôs result data in a single call to the database instead of iterating.
The time window for the default Report query was set to four weeks, instead of being unbounded.
I also drastically limited the scope of all database handles, reducing lock contention.
To help communicate to users, I added a status bar spinner for both <a href="https://bencher.dev/docs/reference/changelog/#v0317">the Perf Plot</a> and <a href="https://bencher.dev/docs/reference/changelog/#v045">the dimension tabs</a>.</p>
<p>I also had a failed attempt last fall at using a composite query to get all Perf results into a single query,
instead of using a quadruple nested for loop.
This lead to me hitting the <a href="https://doc.rust-lang.org/reference/attributes/limits.html#the-recursion_limit-attribute">Rust type system recursion limit</a>,
repeatedly overflowing the stack,
suffering through insane (much longer than 38 seconds) compile times,
and finally dead ending at <a href="https://www.sqlite.org/limits.html">SQLite‚Äôs max number of terms in a compound select statement</a>.</p>
<p>With all of that under my belt, I knew that I really needed to dig in here
and put my performance engineer pants on.
I had never profiled a SQLite database before,
and honestly, I had never really profiled <em>any</em> database before.
Now wait a minute you might might be thinking.
<a href="https://www.linkedin.com/in/epompeii/">My LinkedIn profile</a> says I was a ‚ÄúDatabase Administrator‚Äù for almost two years.
And I <em>never</em> profiled a database‚ÄΩ
Yep. That‚Äôs a story for another time I suppose.</p>
<h2 id="from-orm-to-sql-query">From ORM to SQL Query<a href="#from-orm-to-sql-query"><small><i aria-hidden="true"></i></small></a></h2>
<p>The first hurdle I ran into was getting the SQL query out of my Rust code.
I use <a href="https://github.com/diesel-rs/diesel">Diesel</a> as the object‚Äìrelational mapper (ORM) for Bencher.</p>
<blockquote>
<p>üê∞ Fun Fact: Diesel uses Bencher for their <a href="https://bencher.dev/docs/how-to/track-benchmarks/#relative-continuous-benchmarking">Relative Continuous Benchmarking</a>.
Check out <a href="https://bencher.dev/perf/diesel">the Diesel Perf Page</a>!</p>
</blockquote>
<p>Diesel creates parameterized queries.
It sends the SQL query and its bind parameters separately to the database.
That is, the substitution is done by the database.
Therefore, Diesel cannot provide a complete query to the user.
The best method that I found was using <a href="https://docs.rs/diesel/2.1.5/diesel/fn.debug_query.html">the <code>diesel::debug_query</code> function</a> to output the parameterized query:</p>
<div><figure><pre data-language="rust"><code><div><p><span>Query</span><span> { sql</span><span>:</span><span> </span><span>&#34;SELECT `branch`.`id`, `branch`.`uuid`, `branch`.`project_id`, `branch`.`name`, `branch`.`slug`, `branch`.`start_point_id`, `branch`.`created`, `branch`.`modified`, `testbed`.`id`, `testbed`.`uuid`, `testbed`.`project_id`, `testbed`.`name`, `testbed`.`slug`, `testbed`.`created`, `testbed`.`modified`, `benchmark`.`id`, `benchmark`.`uuid`, `benchmark`.`project_id`, `benchmark`.`name`, `benchmark`.`slug`, `benchmark`.`created`, `benchmark`.`modified`, `measure`.`id`, `measure`.`uuid`, `measure`.`project_id`, `measure`.`name`, `measure`.`slug`, `measure`.`units`, `measure`.`created`, `measure`.`modified`, `report`.`uuid`, `report_benchmark`.`iteration`, `report`.`start_time`, `report`.`end_time`, `version`.`number`, `version`.`hash`, `threshold`.`id`, `threshold`.`uuid`, `threshold`.`project_id`, `threshold`.`measure_id`, `threshold`.`branch_id`, `threshold`.`testbed_id`, `threshold`.`model_id`, `threshold`.`created`, `threshold`.`modified`, `model`.`id`, `model`.`uuid`, `model`.`threshold_id`, `model`.`test`, `model`.`min_sample_size`, `model`.`max_sample_size`, `model`.`window`, `model`.`lower_boundary`, `model`.`upper_boundary`, `model`.`created`, `model`.`replaced`, `boundary`.`id`, `boundary`.`uuid`, `boundary`.`threshold_id`, `boundary`.`model_id`, `boundary`.`metric_id`, `boundary`.`baseline`, `boundary`.`lower_limit`, `boundary`.`upper_limit`, `alert`.`id`, `alert`.`uuid`, `alert`.`boundary_id`, `alert`.`boundary_limit`, `alert`.`status`, `alert`.`modified`, `metric`.`id`, `metric`.`uuid`, `metric`.`report_benchmark_id`, `metric`.`measure_id`, `metric`.`value`, `metric`.`lower_value`, `metric`.`upper_value` FROM (((`metric` INNER JOIN ((`report_benchmark` INNER JOIN ((`report` INNER JOIN (`version` INNER JOIN (`branch_version` INNER JOIN `branch` ON (`branch_version`.`branch_id` = `branch`.`id`)) ON (`branch_version`.`version_id` = `version`.`id`)) ON (`report`.`version_id` = `version`.`id`)) INNER JOIN `testbed` ON (`report`.`testbed_id` = `testbed`.`id`)) ON (`report_benchmark`.`report_id` = `report`.`id`)) INNER JOIN `benchmark` ON (`report_benchmark`.`benchmark_id` = `benchmark`.`id`)) ON (`metric`.`report_benchmark_id` = `report_benchmark`.`id`)) INNER JOIN `measure` ON (`metric`.`measure_id` = `measure`.`id`)) LEFT OUTER JOIN (((`boundary` INNER JOIN `threshold` ON (`boundary`.`threshold_id` = `threshold`.`id`)) INNER JOIN `model` ON (`boundary`.`model_id` = `model`.`id`)) LEFT OUTER JOIN `alert` ON (`alert`.`boundary_id` = `boundary`.`id`)) ON (`boundary`.`metric_id` = `metric`.`id`)) WHERE ((((((`branch`.`uuid` = ?) AND (`testbed`.`uuid` = ?)) AND (`benchmark`.`uuid` = ?)) AND (`measure`.`uuid` = ?)) AND (`report`.`start_time` &gt;= ?)) AND (`report`.`end_time` &lt;= ?)) ORDER BY `version`.`number`, `report`.`start_time`, `report_benchmark`.`iteration`&#34;</span><span>, binds</span><span>:</span><span> [</span><span>BranchUuid</span><span>(a7d8366a</span><span>-</span><span>4f9b</span><span>-</span><span>452e</span><span>-</span><span>987e</span><span>-</span><span>2ae56e4bf4a3), </span><span>TestbedUuid</span><span>(5b4a6f3e</span><span>-</span><span>a27d</span><span>-</span><span>4cc3</span><span>-</span><span>a2ce</span><span>-</span><span>851dc6421e6e), </span><span>BenchmarkUuid</span><span>(88375e7c</span><span>-</span><span>f1e0</span><span>-</span><span>4cbb</span><span>-</span><span>bde1</span><span>-</span><span>bdb7773022ae), </span><span>MeasureUuid</span><span>(b2275bbc</span><span>-</span><span>2044</span><span>-</span><span>4f8e</span><span>-</span><span>aecd</span><span>-</span><span>3c739bd861b9), </span><span>DateTime</span><span>(</span><span>2024</span><span>-</span><span>03</span><span>-</span><span>12T12</span><span>:</span><span>23</span><span>:</span><span>38Z), </span><span>DateTime</span><span>(</span><span>2024</span><span>-</span><span>04</span><span>-</span><span>11T12</span><span>:</span><span>23</span><span>:</span><span>38Z)] }</span></p></div></code></pre></figure></div>
<p>And then hand cleaning and parameterizing the query into valid SQL:</p>
<div><figure><pre data-language="sql"><code><div><p><span>SELECT</span><span> </span><span>branch</span><span>.</span><span>id</span><span>, </span><span>branch</span><span>.</span><span>uuid</span><span>, </span><span>branch</span><span>.</span><span>project_id</span><span>, </span><span>branch</span><span>.</span><span>name</span><span>, </span><span>branch</span><span>.</span><span>slug</span><span>, </span><span>branch</span><span>.</span><span>start_point_id</span><span>, </span><span>branch</span><span>.</span><span>created</span><span>, </span><span>branch</span><span>.</span><span>modified</span><span>, </span><span>testbed</span><span>.</span><span>id</span><span>, </span><span>testbed</span><span>.</span><span>uuid</span><span>, </span><span>testbed</span><span>.</span><span>project_id</span><span>, </span><span>testbed</span><span>.</span><span>name</span><span>, </span><span>testbed</span><span>.</span><span>slug</span><span>, </span><span>testbed</span><span>.</span><span>created</span><span>, </span><span>testbed</span><span>.</span><span>modified</span><span>, </span><span>benchmark</span><span>.</span><span>id</span><span>, </span><span>benchmark</span><span>.</span><span>uuid</span><span>, </span><span>benchmark</span><span>.</span><span>project_id</span><span>, </span><span>benchmark</span><span>.</span><span>name</span><span>, </span><span>benchmark</span><span>.</span><span>slug</span><span>, </span><span>benchmark</span><span>.</span><span>created</span><span>, </span><span>benchmark</span><span>.</span><span>modified</span><span>, </span><span>measure</span><span>.</span><span>id</span><span>, </span><span>measure</span><span>.</span><span>uuid</span><span>, </span><span>measure</span><span>.</span><span>project_id</span><span>, </span><span>measure</span><span>.</span><span>name</span><span>, </span><span>measure</span><span>.</span><span>slug</span><span>, </span><span>measure</span><span>.</span><span>units</span><span>, </span><span>measure</span><span>.</span><span>created</span><span>, </span><span>measure</span><span>.</span><span>modified</span><span>, </span><span>report</span><span>.</span><span>uuid</span><span>, </span><span>report_benchmark</span><span>.</span><span>iteration</span><span>, </span><span>report</span><span>.</span><span>start_time</span><span>, </span><span>report</span><span>.</span><span>end_time</span><span>, </span><span>version</span><span>.</span><span>number</span><span>, </span><span>version</span><span>.</span><span>hash</span><span>, </span><span>threshold</span><span>.</span><span>id</span><span>, </span><span>threshold</span><span>.</span><span>uuid</span><span>, </span><span>threshold</span><span>.</span><span>project_id</span><span>, </span><span>threshold</span><span>.</span><span>measure_id</span><span>, </span><span>threshold</span><span>.</span><span>branch_id</span><span>, </span><span>threshold</span><span>.</span><span>testbed_id</span><span>, </span><span>threshold</span><span>.</span><span>model_id</span><span>, </span><span>threshold</span><span>.</span><span>created</span><span>, </span><span>threshold</span><span>.</span><span>modified</span><span>, </span><span>model</span><span>.</span><span>id</span><span>, </span><span>model</span><span>.</span><span>uuid</span><span>, </span><span>model</span><span>.</span><span>threshold_id</span><span>, </span><span>model</span><span>.</span><span>test</span><span>, </span><span>model</span><span>.</span><span>min_sample_size</span><span>, </span><span>model</span><span>.</span><span>max_sample_size</span><span>, </span><span>model</span><span>.</span><span>window</span><span>, </span><span>model</span><span>.</span><span>lower_boundary</span><span>, </span><span>model</span><span>.</span><span>upper_boundary</span><span>, </span><span>model</span><span>.</span><span>created</span><span>, </span><span>model</span><span>.</span><span>replaced</span><span>, </span><span>boundary</span><span>.</span><span>id</span><span>, </span><span>boundary</span><span>.</span><span>uuid</span><span>, </span><span>boundary</span><span>.</span><span>threshold_id</span><span>, </span><span>boundary</span><span>.</span><span>model_id</span><span>, </span><span>boundary</span><span>.</span><span>metric_id</span><span>, </span><span>boundary</span><span>.</span><span>baseline</span><span>, </span><span>boundary</span><span>.</span><span>lower_limit</span><span>, </span><span>boundary</span><span>.</span><span>upper_limit</span><span>, </span><span>alert</span><span>.</span><span>id</span><span>, </span><span>alert</span><span>.</span><span>uuid</span><span>, </span><span>alert</span><span>.</span><span>boundary_id</span><span>, </span><span>alert</span><span>.</span><span>boundary_limit</span><span>, </span><span>alert</span><span>.</span><span>status</span><span>, </span><span>alert</span><span>.</span><span>modified</span><span>, </span><span>metric</span><span>.</span><span>id</span><span>, </span><span>metric</span><span>.</span><span>uuid</span><span>, </span><span>metric</span><span>.</span><span>report_benchmark_id</span><span>, </span><span>metric</span><span>.</span><span>measure_id</span><span>, </span><span>metric</span><span>.</span><span>value</span><span>, </span><span>metric</span><span>.</span><span>lower_value</span><span>, </span><span>metric</span><span>.</span><span>upper_value</span><span> </span><span>FROM</span><span> (((metric </span><span>INNER JOIN</span><span> ((report_benchmark </span><span>INNER JOIN</span><span> ((report </span><span>INNER JOIN</span><span> (</span><span>version</span><span> </span><span>INNER JOIN</span><span> (branch_version </span><span>INNER JOIN</span><span> branch </span><span>ON</span><span> (</span><span>branch_version</span><span>.</span><span>branch_id</span><span> </span><span>=</span><span> </span><span>branch</span><span>.</span><span>id</span><span>)) </span><span>ON</span><span> (</span><span>branch_version</span><span>.</span><span>version_id</span><span> </span><span>=</span><span> </span><span>version</span><span>.</span><span>id</span><span>)) </span><span>ON</span><span> (</span><span>report</span><span>.</span><span>version_id</span><span> </span><span>=</span><span> </span><span>version</span><span>.</span><span>id</span><span>)) </span><span>INNER JOIN</span><span> testbed </span><span>ON</span><span> (</span><span>report</span><span>.</span><span>testbed_id</span><span> </span><span>=</span><span> </span><span>testbed</span><span>.</span><span>id</span><span>)) </span><span>ON</span><span> (</span><span>report_benchmark</span><span>.</span><span>report_id</span><span> </span><span>=</span><span> </span><span>report</span><span>.</span><span>id</span><span>)) </span><span>INNER JOIN</span><span> benchmark </span><span>ON</span><span> (</span><span>report_benchmark</span><span>.</span><span>benchmark_id</span><span> </span><span>=</span><span> </span><span>benchmark</span><span>.</span><span>id</span><span>)) </span><span>ON</span><span> (</span><span>metric</span><span>.</span><span>report_benchmark_id</span><span> </span><span>=</span><span> </span><span>report_benchmark</span><span>.</span><span>id</span><span>)) </span><span>INNER JOIN</span><span> measure </span><span>ON</span><span> (</span><span>metric</span><span>.</span><span>measure_id</span><span> </span><span>=</span><span> </span><span>measure</span><span>.</span><span>id</span><span>)) </span><span>LEFT OUTER JOIN</span><span> (((boundary </span><span>INNER JOIN</span><span> threshold </span><span>ON</span><span> (</span><span>boundary</span><span>.</span><span>threshold_id</span><span> </span><span>=</span><span> </span><span>threshold</span><span>.</span><span>id</span><span>)) </span><span>INNER JOIN</span><span> model </span><span>ON</span><span> (</span><span>boundary</span><span>.</span><span>model_id</span><span> </span><span>=</span><span> </span><span>model</span><span>.</span><span>id</span><span>)) </span><span>LEFT OUTER JOIN</span><span> alert </span><span>ON</span><span> (</span><span>alert</span><span>.</span><span>boundary_id</span><span> </span><span>=</span><span> </span><span>boundary</span><span>.</span><span>id</span><span>)) </span><span>ON</span><span> (</span><span>boundary</span><span>.</span><span>metric_id</span><span> </span><span>=</span><span> </span><span>metric</span><span>.</span><span>id</span><span>)) </span><span>WHERE</span><span> ((((((</span><span>branch</span><span>.</span><span>uuid</span><span> </span><span>=</span><span> </span><span>&#39;a7d8366a-4f9b-452e-987e-2ae56e4bf4a3&#39;</span><span>) </span><span>AND</span><span> (</span><span>testbed</span><span>.</span><span>uuid</span><span> </span><span>=</span><span> </span><span>&#39;5b4a6f3e-a27d-4cc3-a2ce-851dc6421e6e&#39;</span><span>)) </span><span>AND</span><span> (</span><span>benchmark</span><span>.</span><span>uuid</span><span> </span><span>=</span><span> </span><span>&#39;88375e7c-f1e0-4cbb-bde1-bdb7773022ae&#39;</span><span>)) </span><span>AND</span><span> (</span><span>measure</span><span>.</span><span>uuid</span><span> </span><span>=</span><span> </span><span>&#39;b2275bbc-2044-4f8e-aecd-3c739bd861b9&#39;</span><span>)) </span><span>AND</span><span> (</span><span>report</span><span>.</span><span>start_time</span><span> </span><span>&gt;=</span><span> </span><span>0</span><span>)) </span><span>AND</span><span> (</span><span>report</span><span>.</span><span>end_time</span><span> </span><span>&lt;=</span><span> </span><span>1712838648197</span><span>)) </span><span>ORDER BY</span><span> </span><span>version</span><span>.</span><span>number</span><span>, </span><span>report</span><span>.</span><span>start_time</span><span>, </span><span>report_benchmark</span><span>.</span><span>iteration</span><span>;</span></p></div></code></pre></figure></div>
<p>If you know of a better way, please let me know!
This is the way that <a href="https://stackoverflow.com/questions/76467831/ho-to-get-final-sql-query-from-diesel">the maintainer of the project suggested</a> though,
so I just went with it.
Now that I had a SQL query, I was finally ready to‚Ä¶ read a whole lot of documentation.</p>
<h2 id="sqlite-query-planner">SQLite Query Planner<a href="#sqlite-query-planner"><small><i aria-hidden="true"></i></small></a></h2>
<p>The SQLite website has <a href="https://www.sqlite.org/queryplanner.html">great documentation for its Query Planner</a>.
It explains exactly how SQLite goes about executing your SQL query,
and it teaches you which indexes are useful and what operations to look out for, like full table scans.</p>
<p>In order to see how the Query Planner would execute my Perf query,
I needed to add a new tool to my tool belt: <a href="https://www.sqlite.org/eqp.html"><code>EXPLAIN QUERY PLAN</code></a>
You can either prefix your SQL query with <code>EXPLAIN QUERY PLAN</code>
or run the <code>.eqp on</code> dot command before your query.
Either way, I got a result that looks like this:</p>
<div><figure><pre data-language="plaintext"><code><div><p><span>QUERY PLAN</span></p></div><div><p><span>|--MATERIALIZE (join-5)</span></p></div><div><p><span>|  |--SCAN boundary</span></p></div><div><p><span>|  |--SEARCH threshold USING INTEGER PRIMARY KEY (rowid=?)</span></p></div><div><p><span>|  |--SEARCH model USING INTEGER PRIMARY KEY (rowid=?)</span></p></div><div><p><span>|  |--BLOOM FILTER ON alert (boundary_id=?)</span></p></div><div><p><span>|  `--SEARCH alert USING AUTOMATIC COVERING INDEX (boundary_id=?) LEFT-JOIN</span></p></div><div><p><span>|--SEARCH branch USING INDEX sqlite_autoindex_branch_1 (uuid=?)</span></p></div><div><p><span>|--SEARCH measure USING INDEX sqlite_autoindex_measure_1 (uuid=?)</span></p></div><div><p><span>|--SEARCH benchmark USING INDEX sqlite_autoindex_benchmark_1 (uuid=?)</span></p></div><div><p><span>|--SEARCH testbed USING INDEX sqlite_autoindex_testbed_1 (uuid=?)</span></p></div><div><p><span>|--SCAN metric</span></p></div><div><p><span>|--SEARCH report_benchmark USING INTEGER PRIMARY KEY (rowid=?)</span></p></div><div><p><span>|--SEARCH report USING INTEGER PRIMARY KEY (rowid=?)</span></p></div><div><p><span>|--SEARCH version USING INTEGER PRIMARY KEY (rowid=?)</span></p></div><div><p><span>|--SEARCH branch_version USING COVERING INDEX sqlite_autoindex_branch_version_1 (branch_id=? AND version_id=?)</span></p></div><div><p><span>|--BLOOM FILTER ON (join-5) (metric_id=?)</span></p></div><div><p><span>|--SEARCH (join-5) USING AUTOMATIC COVERING INDEX (metric_id=?) LEFT-JOIN</span></p></div><div><p><span>`--USE TEMP B-TREE FOR ORDER BY</span></p></div></code></pre></figure></div>
<p>Oh, boy!
There is a lot here.
But the three big things that jumped out to me where:</p>
<ol>
<li>SQLite is creating a materialized view on-the-fly that scans the <em>entire</em> <code>boundary</code> table</li>
<li>SQLite is then scanning the <em>entire</em> <code>metric</code> table</li>
<li>SQLite is creating two on the fly indexes</li>
</ol>
<p>And just how big are the <code>metric</code> and <code>boundary</code> tables?
Well they just so happen to be the two largest tables,
as they are where all the <a href="https://bencher.dev/docs/explanation/benchmarking/#metrics">Metrics</a> and <a href="https://bencher.dev/docs/explanation/thresholds/">Boundaries</a> are stored.</p>
<p>Since this was my first SQLite performance tuning rodeo,
I wanted to consult an expert before making any changes.</p>

<p>SQLite has an experimental ‚Äúexpert‚Äù mode that can be enabled with <a href="https://sqlite.org/cli.html#special_commands_to_sqlite3_dot_commands_">the <code>.expert on</code> command</a>.
It suggests indexes for queries, so I decided to give it a try.
This is what it suggested:</p>
<div><figure><pre data-language="plaintext"><code><div><p><span>CREATE INDEX report_benchmark_idx_fc6f3e5b ON report_benchmark(report_id, benchmark_id);</span></p></div><div><p><span>CREATE INDEX report_idx_55aae6d8 ON report(testbed_id, end_time);</span></p></div><div><p><span>CREATE INDEX alert_idx_e1882f70 ON alert(boundary_id);</span></p></div><div></div><div><p><span>MATERIALIZE (join-5)</span></p></div><div><p><span>SCAN boundary</span></p></div><div><p><span>SEARCH threshold USING INTEGER PRIMARY KEY (rowid=?)</span></p></div><div><p><span>SEARCH model USING INTEGER PRIMARY KEY (rowid=?)</span></p></div><div><p><span>SEARCH alert USING INDEX alert_idx_e1882f70 (boundary_id=?) LEFT-JOIN</span></p></div><div><p><span>SEARCH branch USING INDEX sqlite_autoindex_branch_1 (uuid=?)</span></p></div><div><p><span>SEARCH benchmark USING INDEX sqlite_autoindex_benchmark_1 (uuid=?)</span></p></div><div><p><span>SEARCH testbed USING INDEX sqlite_autoindex_testbed_1 (uuid=?)</span></p></div><div><p><span>SEARCH measure USING INDEX sqlite_autoindex_measure_1 (uuid=?)</span></p></div><div><p><span>SEARCH report USING INDEX report_idx_55aae6d8 (testbed_id=? AND end_time&lt;?)</span></p></div><div><p><span>SEARCH version USING INTEGER PRIMARY KEY (rowid=?)</span></p></div><div><p><span>SEARCH branch_version USING COVERING INDEX sqlite_autoindex_branch_version_1 (branch_id=? AND version_id=?)</span></p></div><div><p><span>SEARCH report_benchmark USING INDEX report_benchmark_idx_fc6f3e5b (report_id=? AND benchmark_id=?)</span></p></div><div><p><span>SEARCH metric USING INDEX sqlite_autoindex_metric_2 (report_benchmark_id=? AND measure_id=?)</span></p></div><div><p><span>BLOOM FILTER ON (join-5) (metric_id=?)</span></p></div><div><p><span>SEARCH (join-5) USING AUTOMATIC COVERING INDEX (metric_id=?) LEFT-JOIN</span></p></div><div><p><span>USE TEMP B-TREE FOR ORDER BY</span></p></div></code></pre></figure></div>
<p>This is definitely an improvement!
It got rid of the scan on the <code>metric</code> table and both of the on-the-fly indexes.
Honestly, I wouldn‚Äôt have gotten the first two indexes on my own.
Thank you, SQLite Expert!</p>
<div><figure><pre data-language="sql"><code><div><p><span>CREATE</span><span> </span><span>INDEX</span><span> </span><span>index_report_testbed_end_time</span><span> </span><span>ON</span><span> report(testbed_id, end_time);</span></p></div><div><p><span>CREATE</span><span> </span><span>INDEX</span><span> </span><span>index_report_benchmark</span><span> </span><span>ON</span><span> report_benchmark(report_id, benchmark_id);</span></p></div><div><p><span>CREATE</span><span> </span><span>INDEX</span><span> </span><span>index_alert_boundary</span><span> </span><span>ON</span><span> alert(boundary_id);</span></p></div></code></pre></figure></div>
<p>Now the only thing left to get rid of is that darn on-the-fly materialized view.</p>
<h2 id="materialized-view">Materialized View<a href="#materialized-view"><small><i aria-hidden="true"></i></small></a></h2>
<p>When I added the ability to track and visualize <a href="https://bencher.dev/docs/explanation/thresholds/">Threshold Boundaries</a> last year,
I had a decision to make in the database model.
There is a 1-to-0/1 relationship between a Metric and its corresponding Boundary.
That is a Metric can relate to zero or one Boundary, and a Boundary can only ever relate to one Metric.
So I could have just expanded the <code>metric</code> table to include all of the <code>boundary</code> data with every <code>boundary</code> related field being nullable.
Or I could create a separate <code>boundary</code> table with a <code>UNIQUE</code> foreign key to <code>metric</code> table.
To me the latter option felt a lot cleaner, and I figured I could always deal with any performance implications later.</p>
<p>These were the effective queries used to create the <code>metric</code> and <code>boundary</code> tables:</p>
<div><figure><pre data-language="sql"><code><div><p><span>CREATE</span><span> </span><span>TABLE</span><span> </span><span>metric</span><span> (</span></p></div><div><p><span><span>    </span></span><span>id </span><span>INTEGER</span><span> </span><span>PRIMARY KEY</span><span> </span><span>NOT NULL</span><span>,</span></p></div><div><p><span><span>    </span></span><span>uuid </span><span>TEXT</span><span> </span><span>NOT NULL</span><span> </span><span>UNIQUE</span><span>,</span></p></div><div><p><span><span>    </span></span><span>report_benchmark_id </span><span>INTEGER</span><span> </span><span>NOT NULL</span><span>,</span></p></div><div><p><span><span>    </span></span><span>measure_id </span><span>INTEGER</span><span> </span><span>NOT NULL</span><span>,</span></p></div><div><p><span>    </span><span>value</span><span> DOUBLE </span><span>NOT NULL</span><span>,</span></p></div><div><p><span><span>    </span></span><span>lower_value DOUBLE,</span></p></div><div><p><span><span>    </span></span><span>upper_value DOUBLE,</span></p></div><div><p><span>    </span><span>FOREIGN KEY</span><span> (report_benchmark_id) </span><span>REFERENCES</span><span> report_benchmark (id) </span><span>ON DELETE CASCADE</span><span>,</span></p></div><div><p><span>    </span><span>FOREIGN KEY</span><span> (measure_id) </span><span>REFERENCES</span><span> measure (id),</span></p></div><div><p><span>    </span><span>UNIQUE</span><span>(report_benchmark_id, measure_id)</span></p></div><div><p><span>);</span></p></div></code></pre></figure></div>
<div><figure><pre data-language="sql"><code><div><p><span>CREATE</span><span> </span><span>TABLE</span><span> </span><span>boundary</span><span> (</span></p></div><div><p><span><span>    </span></span><span>id </span><span>INTEGER</span><span> </span><span>PRIMARY KEY</span><span> </span><span>NOT NULL</span><span>,</span></p></div><div><p><span><span>    </span></span><span>uuid </span><span>TEXT</span><span> </span><span>NOT NULL</span><span> </span><span>UNIQUE</span><span>,</span></p></div><div><p><span><span>    </span></span><span>threshold_id </span><span>INTEGER</span><span> </span><span>NOT NULL</span><span>,</span></p></div><div><p><span><span>    </span></span><span>statistic_id </span><span>INTEGER</span><span> </span><span>NOT NULL</span><span>,</span></p></div><div><p><span><span>    </span></span><span>metric_id </span><span>INTEGER</span><span> </span><span>NOT NULL</span><span> </span><span>UNIQUE</span><span>,</span></p></div><div><p><span><span>    </span></span><span>baseline DOUBLE </span><span>NOT NULL</span><span>,</span></p></div><div><p><span><span>    </span></span><span>lower_limit DOUBLE,</span></p></div><div><p><span><span>    </span></span><span>upper_limit DOUBLE,</span></p></div><div><p><span>    </span><span>FOREIGN KEY</span><span> (threshold_id) </span><span>REFERENCES</span><span> threshold (id),</span></p></div><div><p><span>    </span><span>FOREIGN KEY</span><span> (statistic_id) </span><span>REFERENCES</span><span> statistic (id),</span></p></div><div><p><span>    </span><span>FOREIGN KEY</span><span> (metric_id) </span><span>REFERENCES</span><span> metric (id) </span><span>ON DELETE CASCADE</span></p></div><div><p><span>);</span></p></div></code></pre></figure></div>
<p>And it turns out ‚Äúlater‚Äù had arrived.
I tried to simply add an index for <code>boundary(metric_id)</code> but that did not help.
I believe the reason has to do with the fact that the Perf query is originating from the <code>metric</code> table
and because that relationship is 0/1 or put another way, nullable it has to be scanned (O(n))
and cannot be searched (O(log(n))).</p>
<p>This left me with one clear option.
I needed to create a materialized view that flattened the <code>metric</code> and <code>boundary</code> relationship
to keep SQLite from having to create an on-the-fly materialized view.</p>
<p>This is the query I used to create the new <code>metric_boundary</code> materialized view:</p>
<div><figure><pre data-language="sql"><code><div><p><span>CREATE</span><span> </span><span>VIEW</span><span> </span><span>metric_boundary</span><span> </span><span>AS</span></p></div><div><p><span>SELECT</span><span> </span><span>metric</span><span>.</span><span>id</span><span> </span><span>AS</span><span> metric_id,</span></p></div><div><p><span>    </span><span>metric</span><span>.</span><span>uuid</span><span> </span><span>AS</span><span> metric_uuid,</span></p></div><div><p><span>    </span><span>metric</span><span>.</span><span>report_benchmark_id</span><span>,</span></p></div><div><p><span>    </span><span>metric</span><span>.</span><span>measure_id</span><span>,</span></p></div><div><p><span>    </span><span>metric</span><span>.</span><span>value</span><span>,</span></p></div><div><p><span>    </span><span>metric</span><span>.</span><span>lower_value</span><span>,</span></p></div><div><p><span>    </span><span>metric</span><span>.</span><span>upper_value</span><span>,</span></p></div><div><p><span>    </span><span>boundary</span><span>.</span><span>id</span><span>,</span></p></div><div><p><span>    </span><span>boundary</span><span>.</span><span>uuid</span><span> </span><span>AS</span><span> boundary_uuid,</span></p></div><div><p><span>    </span><span>boundary</span><span>.</span><span>threshold_id</span><span> </span><span>AS</span><span> threshold_id,</span></p></div><div><p><span>    </span><span>boundary</span><span>.</span><span>model_id</span><span>,</span></p></div><div><p><span>    </span><span>boundary</span><span>.</span><span>baseline</span><span>,</span></p></div><div><p><span>    </span><span>boundary</span><span>.</span><span>lower_limit</span><span>,</span></p></div><div><p><span>    </span><span>boundary</span><span>.</span><span>upper_limit</span></p></div><div><p><span>FROM</span><span> metric</span></p></div><div><p><span>    </span><span>LEFT OUTER JOIN</span><span> boundary </span><span>ON</span><span> (</span><span>boundary</span><span>.</span><span>metric_id</span><span> </span><span>=</span><span> </span><span>metric</span><span>.</span><span>id</span><span>);</span></p></div></code></pre></figure></div>
<p>With this solution, I‚Äôm trading off space for runtime performance.
How much space?
Surprisingly only about a 4% increase, even though this view is for the two largest tables in the database.
Best of all, it lets me have my cake and eat it too in my source code.</p>
<p><a href="https://deterministic.space/diesel-view-table-trick.html">Creating a materialized view with Diesel</a> was surprisingly easy.
I just had to use the exact same macros that Diesel uses when generating my normal schema.
With that said, I learned to appreciate Diesel a lot more throughout this experience.
See <a href="#bonus-bug">Bonus Bug</a> for all the juicy details.</p>
<h2 id="wrap-up">Wrap Up<a href="#wrap-up"><small><i aria-hidden="true"></i></small></a></h2>
<p>With the three new indexes and a materialized view added, this is what the Query Planner now shows:</p>
<div><figure><pre data-language="plaintext"><code><div><p><span>QUERY PLAN</span></p></div><div><p><span>|--SEARCH branch USING INDEX sqlite_autoindex_branch_1 (uuid=?)</span></p></div><div><p><span>|--SEARCH testbed USING INDEX sqlite_autoindex_testbed_1 (uuid=?)</span></p></div><div><p><span>|--SEARCH benchmark USING INDEX sqlite_autoindex_benchmark_1 (uuid=?)</span></p></div><div><p><span>|--SEARCH measure USING INDEX sqlite_autoindex_measure_1 (uuid=?)</span></p></div><div><p><span>|--SEARCH report USING INDEX index_report_testbed_end_time (testbed_id=? AND end_time&lt;?)</span></p></div><div><p><span>|--SEARCH version USING INTEGER PRIMARY KEY (rowid=?)</span></p></div><div><p><span>|--SEARCH branch_version USING COVERING INDEX sqlite_autoindex_branch_version_1 (branch_id=? AND version_id=?)</span></p></div><div><p><span>|--SEARCH report_benchmark USING INDEX index_report_benchmark (report_id=? AND benchmark_id=?)</span></p></div><div><p><span>|--SEARCH metric USING INDEX sqlite_autoindex_metric_2 (report_benchmark_id=? AND measure_id=?)</span></p></div><div><p><span>|--SEARCH boundary USING INDEX sqlite_autoindex_boundary_2 (metric_id=?) LEFT-JOIN</span></p></div><div><p><span>|--SEARCH threshold USING INTEGER PRIMARY KEY (rowid=?) LEFT-JOIN</span></p></div><div><p><span>|--SEARCH model USING INTEGER PRIMARY KEY (rowid=?) LEFT-JOIN</span></p></div><div><p><span>|--SEARCH alert USING INDEX index_alert_boundary (boundary_id=?) LEFT-JOIN</span></p></div><div><p><span>`--USE TEMP B-TREE FOR ORDER BY</span></p></div></code></pre></figure></div>
<p>Look at all of those beautify <code>SEARCH</code>es all with existing indexes! ü•≤</p>
<p>And after deploying my changes to production:</p>
<div><figure><img src="https://s3.amazonaws.com/public.bencher.dev/engineering/sqlite-performance-tuning/http-response-times-sql-performance-tuning.png" width="2368" height="1472" alt="Fixed High HTTP Response Times"/><figcaption>The new HTTP response times don‚Äôt even register on the old scale!</figcaption></figure></div>
<p>Now it was time for the final test.
How fast does that Rustls Perf page load?</p>
<p>Here I‚Äôll even give you anchor tag. Click it and then refresh the page.</p>
<h3 id="performance-matters">Performance Matters<a href="#performance-matters"><small><i aria-hidden="true"></i></small></a></h3>

</div> </div> </section> </div></div>
  </body>
</html>
