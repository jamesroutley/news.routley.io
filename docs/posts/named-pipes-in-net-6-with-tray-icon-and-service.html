<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://erikengberg.com/named-pipes-in-net-6-with-tray-icon-and-service/">Original</a>
    
    <div id="readability-page-1" class="page"><article>
                                                
<p>There are many examples out there which explains how to build an application with a tray icon and a Windows Service. A few posts describe how to communicate between the two.</p>



<p><strong>Since I haven‚Äôt found any guide which describes how to do all of those things using .NET 6</strong>, I decided to write a detailed guide where you can follow along.</p>



<p><strong>Since we are targeting .NET 6, you will need Visual Studio 2022.</strong></p>



<figure><img loading="lazy" width="1024" height="536" src="https://erikengberg.com/wp-content/uploads/2021/11/TrayIcon-and-Service.drawio-1024x536.png" alt="" srcset="https://erikengberg.com/wp-content/uploads/2021/11/TrayIcon-and-Service.drawio-1024x536.png 1024w, https://erikengberg.com/wp-content/uploads/2021/11/TrayIcon-and-Service.drawio-300x157.png 300w, https://erikengberg.com/wp-content/uploads/2021/11/TrayIcon-and-Service.drawio-768x402.png 768w, https://erikengberg.com/wp-content/uploads/2021/11/TrayIcon-and-Service.drawio.png 1302w" sizes="(max-width: 1024px) 100vw, 1024px"/><figcaption>App which communicates with a Windows Service over named pipes</figcaption></figure>





<p>‚Äì <strong>Why would you want to have a Windows Service which can communicate with your application?</strong></p>



<ul><li><strong>You have an application which runs in user context</strong>, without any administrative rights, and you need to perform some tasks which requires higher privileges.</li><li><strong>You already have a Windows Service</strong>, but you need a user interface where the user can interact with the service.</li></ul>



<p>The examples in this guide will also work for communication between multiple processes running in the same context.</p>







<p>‚Äì <strong>Why Named Pipes in .NET 6?</strong></p>



<ul><li><strong>Named pipes is a good way to implement inter process communication</strong>, i.e. the ability for processes to talk to each other.</li><li><strong>.NET 6 has cross platform support</strong>. You can reuse many parts of this application on Linux and MacOS. This is not the case with .NET Framework</li><li><strong>.NET 6 the latest version of .NET as of today</strong>, and currently the most future safe.</li><li><strong>.NET 6 has <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/using-directive" target="_blank" rel="noreferrer noopener">global</a> and <a href="https://docs.microsoft.com/en-us/dotnet/core/project-sdk/overview#implicit-using-directives" target="_blank" rel="noreferrer noopener">implicit usings</a></strong>, which makes our code look cleaner.</li></ul>



<p>A lot of the code will however work in earlier versions of .NET</p>







<h3><span id="Nuget_Packages_Used">Nuget Packages Used</span></h3>



<ul><li><a href="https://www.nuget.org/packages/H.Pipes/" rel="noreferrer noopener nofollow" target="_blank"><strong>H.Pipes</strong></a> ‚Äì Wrapper for .NET Pipes</li><li><a href="https://www.nuget.org/packages/Hardcodet.NotifyIcon.Wpf/" target="_blank" rel="noreferrer noopener nofollow"><strong>Hardcodet.NotifyIcon.Wpf</strong></a> ‚Äì Tray Icons for WPF projects</li><li><a href="https://www.nuget.org/packages/System.ServiceProcess.ServiceController/" target="_blank" rel="noreferrer noopener nofollow"><strong>System.ServiceProcess.ServiceController</strong></a> ‚Äì Create a Windows Service</li></ul>







<h3><span id="Out_of_Scope_for_this_Guide_things_you_might_want_to_change_later">Out of Scope for this Guide (things you might want to change later)</span></h3>



<p>While this is very comprehensive guide, <strong>some things had to be left</strong> out so we can focus on the core value. When following along, you should have in mind that the following concepts have been left out:</p>



<ul><li>Interfaces for services etc. ‚Äì which allows for dependency injection and unit tests</li><li>Unit tests / integration tests</li><li>Proper error handling</li><li>More null checks</li><li>Proper logging</li><li>Namespace and project folder structure</li></ul>







<div>
<div>




<ul><li><strong>The source code for this guide can be found on GitHub:</strong></li></ul>
</div>
</div>



<hr/>







<h2><span id="Windows_Service">Windows Service</span></h2>



<p>‚Äì <strong>Let‚Äôs start by creating our Windows Service</strong>. It will contain the following main components:</p>



<ul><li><strong>Service Host</strong> ‚Äì A class which is responsible for running our service</li><li><strong>Pipe Server</strong> ‚Äì A class which creates a server for named pipes</li><li><strong>Tray Icon Service</strong> ‚Äì A class which uses <a href="https://taskbarcorner.com/" target="_blank" rel="noreferrer noopener"><strong>Taskbar Corner Customizer</strong> to hide and show our tray icon</a>.</li></ul>







<div>
<div>




<p>‚Äì <strong>We start by creating a new Console Application</strong>. Since we want to use .NET 6, make sure to <strong><em>not</em> </strong>select the .NET Framework alternative.</p>
</div>



<div>
<figure><img loading="lazy" width="1014" height="675" src="https://erikengberg.com/wp-content/uploads/2021/11/image-32.png" alt="" srcset="https://erikengberg.com/wp-content/uploads/2021/11/image-32.png 1014w, https://erikengberg.com/wp-content/uploads/2021/11/image-32-300x200.png 300w, https://erikengberg.com/wp-content/uploads/2021/11/image-32-768x511.png 768w" sizes="(max-width: 1014px) 100vw, 1014px"/></figure>
</div>
</div>



<div>
<div>




<p>‚Äì <strong>Give your solution and your project a name</strong> which makes sense.</p>
</div>



<div>
<figure><img loading="lazy" width="734" height="385" src="https://erikengberg.com/wp-content/uploads/2021/11/image-33.png" alt="" srcset="https://erikengberg.com/wp-content/uploads/2021/11/image-33.png 734w, https://erikengberg.com/wp-content/uploads/2021/11/image-33-300x157.png 300w" sizes="(max-width: 734px) 100vw, 734px"/></figure>
</div>
</div>



<div>
<div>




<p>‚Äì <strong>Make sure to select</strong> <strong>.NET 6</strong> as target framework.</p>
</div>



<div>
<figure><img loading="lazy" width="646" height="223" src="https://erikengberg.com/wp-content/uploads/2021/11/image-34.png" alt="" srcset="https://erikengberg.com/wp-content/uploads/2021/11/image-34.png 646w, https://erikengberg.com/wp-content/uploads/2021/11/image-34-300x104.png 300w" sizes="(max-width: 646px) 100vw, 646px"/></figure>
</div>
</div>







<h3><span id="Service_Host">Service Host</span></h3>



<p><strong>‚Äì Install Nuget package</strong> <code>System.ServiceProcess.ServiceController</code> and create a class called <code><kbd>ServiceHost</kbd></code>. This class should inherit from <code>ServiceBase</code>, which makes it possible to run our assembly as a service.</p>



<ul><li><strong>Create a default constructor</strong> and set the <code>ServiceName</code> property.</li><li><strong>Override</strong> <code>OnStart</code>, <code>OnStop</code> <strong>and </strong><code>OnShutdown</code> <strong>methods</strong>. This will make it possible to control what happens when the service is started or stopped.</li></ul>



<pre><code lang="csharp">using System.ServiceProcess;

namespace NamedPipesSample.WindowsService
{
    internal class ServiceHost : ServiceBase
    {
        public ServiceHost()
        {
            ServiceName = &#34;Named Pipes Sample Service&#34;;
        }

        protected override void OnStart(string[] args)
        {

        }

        protected override void OnStop()
        {
            
        }

        protected override void OnShutdown()
        {
            
        }
    }
}</code></pre>







<p><strong>‚Äì Now, we need to add some methods</strong> so we can have a separate background thread running for our service.</p>



<ul><li><code>Run(string [args])</code> ‚Äì Create a new background thread and starts it.</li><li><code>InitializeServiceThread()</code> ‚Äì The actual service thread. Will run while <code>stopping == false</code>. Without the 100ms delay in the loop, one of our CPU cores would be running at 100%. This loop can later be replaced by other continuously running code.</li><li><code>Abort()</code> ‚Äì Sets stopping to true which shuts down our service thread.</li></ul>



<pre><code lang="csharp">using System.ServiceProcess;
using System.Threading;
using System.Threading.Tasks;

namespace NamedPipesSample.WindowsService
{
    internal class ServiceHost : ServiceBase
    {
        private static Thread serviceThread;
        private static bool stopping;

        //...

        public static void Run(string[] args)
        {
            serviceThread = new Thread(InitializeServiceThread)
            {
                Name = &#34;Named Pipes Sample Service Thread&#34;,
                IsBackground = true
            };
            serviceThread.Start();            
        }

        public static void Abort()
        {
            stopping = true;
        }

        private static void InitializeServiceThread()
        {
            while(!stopping)
            {
                Task.Delay(100).GetAwaiter().GetResult();
            }
        }
    }
}</code></pre>







<p>‚Äì <strong>We need to make sure</strong> <code>Run</code> is called when the service starts.</p>



<pre><code lang="csharp">protected override void OnStart(string[] args)
{
	Run(args);
}</code></pre>







<p><strong>‚Ä¶and that our service thread exits</strong> when the service is stopping.</p>



<pre><code lang="csharp">protected override void OnStop()
{
	Abort();
}

protected override void OnShutdown()
{
	Abort();
}</code></pre>







<h3><span id="Programcs_-_Application_Entry_Point">Program.cs ‚Äì Application Entry Point</span></h3>



<p><strong>‚Äì Now, let‚Äôs update our</strong> <code>Main</code> <strong>method in <kbd>Program.cs</kbd></strong>, so we can test our service host. </p>



<ul><li><strong>In .NET 6 we can omit</strong> both <code>namespace</code>, <code>class Program</code> and <code>public static void Main(string[] args)</code> from our console application‚Äôs entry point <code>Program.cs</code>.</li><li><code>ServiceBase.Run</code> <strong>can only be invoked when our service is actually running is a Windows service</strong>. It cannot be invoked from a <strong>console application</strong>. Therefore, we need to check if we are in <code>UserInteractive</code> environment, and use <code>ServiceHost.Run</code> directly in this scenario.</li></ul>



<pre><code lang="csharp">using NamedPipesSample.WindowsService;
using System.ServiceProcess;

Console.WriteLine(&#34;Starting Service...&#34;);

if (!Environment.UserInteractive)
{
	using (var serviceHost = new ServiceHost())
		ServiceBase.Run(serviceHost);
}
else
{
	Console.WriteLine(&#34;User interactive mode&#34;);

	ServiceHost.Run(args);

	Console.WriteLine(&#34;Press ESC to stop...&#34;);
	while (Console.ReadKey(true).Key != ConsoleKey.Escape)
	{

	}

	ServiceHost.Abort();
}</code></pre>







<p><strong>‚Äì It‚Äôs time to test our service host.</strong></p>



<figure><img loading="lazy" width="979" height="147" src="https://erikengberg.com/wp-content/uploads/2021/11/image-5.png" alt="" srcset="https://erikengberg.com/wp-content/uploads/2021/11/image-5.png 979w, https://erikengberg.com/wp-content/uploads/2021/11/image-5-300x45.png 300w, https://erikengberg.com/wp-content/uploads/2021/11/image-5-768x115.png 768w" sizes="(max-width: 979px) 100vw, 979px"/></figure>



<p><strong>It works!</strong></p>







<h2><span id="Common_Project">Common Project</span></h2>



<p><strong>Since we want to communicate between two assemblies</strong>, we need to have a model which describes the data being sent between our client and server. </p>



<p><strong>‚Äì Good practice is to have this model within a separate common project</strong>, which is referenced by our service and client project. </p>



<div>
<div>
<figure><img loading="lazy" width="1024" height="741" src="https://erikengberg.com/wp-content/uploads/2021/11/Common-Project-1024x741.png" alt="" srcset="https://erikengberg.com/wp-content/uploads/2021/11/Common-Project-1024x741.png 1024w, https://erikengberg.com/wp-content/uploads/2021/11/Common-Project-300x217.png 300w, https://erikengberg.com/wp-content/uploads/2021/11/Common-Project-768x556.png 768w, https://erikengberg.com/wp-content/uploads/2021/11/Common-Project.png 1302w" sizes="(max-width: 1024px) 100vw, 1024px"/></figure>
</div>



<div>




<p>‚Äì <strong>The service and client project should not have any ‚Äúknowledge‚Äù about each others existence</strong>. Also, the common project should not hold any references to the other projects. By doing this, we have <strong><em>loose coupling</em></strong> and we can easily replace the client or server without having to modify the other projects.</p>
</div>
</div>







<h3><span id="Create_new_Common_Project">Create new Common Project</span></h3>







<div>
<div>




<p><strong>‚Äì Create a new class library</strong>. Make sure to <strong>not </strong>select the .NET Framework option.</p>
</div>



<div>
<figure><img loading="lazy" width="1014" height="675" src="https://erikengberg.com/wp-content/uploads/2021/11/image-35.png" alt="" srcset="https://erikengberg.com/wp-content/uploads/2021/11/image-35.png 1014w, https://erikengberg.com/wp-content/uploads/2021/11/image-35-300x200.png 300w, https://erikengberg.com/wp-content/uploads/2021/11/image-35-768x511.png 768w" sizes="(max-width: 1014px) 100vw, 1014px"/></figure>
</div>
</div>



<div>
<div>




<p><strong>‚Äì Name your common project</strong>. A good naming convention would be <code>&lt;SolutionName&gt;.&lt;ProjectName&gt;</code>.</p>
</div>



<div>
<figure><img loading="lazy" width="715" height="306" src="https://erikengberg.com/wp-content/uploads/2021/11/image-36.png" alt="" srcset="https://erikengberg.com/wp-content/uploads/2021/11/image-36.png 715w, https://erikengberg.com/wp-content/uploads/2021/11/image-36-300x128.png 300w" sizes="(max-width: 715px) 100vw, 715px"/></figure>
</div>
</div>



<div>
<p><strong>‚Äì For this project</strong>, we can <strong>use</strong> <strong>.NET Standard 2.0</strong>, which makes it possible to reference this project from any recent .NET version including .NET Framework.</p>



<div>
<figure><img loading="lazy" width="620" height="216" src="https://erikengberg.com/wp-content/uploads/2021/11/image-37.png" alt="" srcset="https://erikengberg.com/wp-content/uploads/2021/11/image-37.png 620w, https://erikengberg.com/wp-content/uploads/2021/11/image-37-300x105.png 300w" sizes="(max-width: 620px) 100vw, 620px"/></figure>
</div>
</div>



<p><strong>‚Äì Start by removing</strong> the initial <strong>Class1.cs</strong> file we got in the new project and create a new class called <strong>PipeMessage.cs</strong>. Make the class public.</p>







<h3><span id="PipeMessagecs">PipeMessage.cs</span></h3>



<p>‚Äì <strong>Create a new class</strong> <kbd>PipeMessage.cs</kbd></p>



<p><strong>‚Äì Create a public Enum</strong> <code>ActionType</code> in this file. This enum will let us specify what kind of action we would like the receiving part to perform. The enum should contain the following constants:</p>



<ul><li><code>Unknown</code> ‚Äì If we have assigned a value to our enum property, the enum will have the Unknown value. This is good practice to avoid unwanted behavior if we forget to assign a value.</li><li><code>SendText</code> ‚Äì This action will be used when we want to send a text message from the service to the client or vice versa.</li><li><code>ShowTrayIcon</code> ‚Äì An action that we will use later in this tutorial to pin a tray icon to the taskbar corner.</li><li><code>HideTrayIcon</code> ‚Äì An action that we will use later in this tutorial to move a pinned tray icon to the overflow menu.</li></ul>



<pre><code lang="csharp">public enum ActionType
{
	Unknown,
	SendText,
	ShowTrayIcon,
	HideTrayIcon
}</code></pre>







<p>The <code>PipeMessage</code> class should have the following public properties:</p>



<ul><li><code>Id</code> (<code>Guid</code>) ‚Äì A unique id for each message.</li><li><code>Action</code> (<code>ActionType</code>) ‚Äì The action we want to perform.</li><li><code>Text</code> (<code>string</code>) ‚Äì Only used when our action is <code>SendMessage</code>.</li></ul>



<p>Also, make sure to add the Serializable attribute so instances of this class can be transferred over our pipe.</p>



<pre><code lang="csharp">using System;

namespace NamedPipesSample.Common
{
    [Serializable]
    public class PipeMessage
    {
        public PipeMessage()
        {
            Id = Guid.NewGuid();
        }

        public Guid Id { get; set; }
        public ActionType Action { get; set; }
        public string Text { get; set; }
    }
	
	//...
}
</code></pre>







<h2><span id="Named_Pipes_Server_in_Service_Project">Named Pipes Server in Service Project</span></h2>



<p>‚Äì <strong>Go back to our Windows service</strong> project and add a <strong>project reference</strong> to the <strong>Common project</strong> we just created.</p>



<div>
<p>‚Äì <strong>Install Nuget package</strong> <code>H.Pipes</code>.</p>



<div>
<figure><img loading="lazy" width="500" height="97" src="https://erikengberg.com/wp-content/uploads/2021/11/image-11.png" alt="" srcset="https://erikengberg.com/wp-content/uploads/2021/11/image-11.png 500w, https://erikengberg.com/wp-content/uploads/2021/11/image-11-300x58.png 300w" sizes="(max-width: 500px) 100vw, 500px"/></figure>
</div>
</div>



<p>‚Äì <strong>Create a new class </strong>called <code><kbd>NamedPipesServer.cs</kbd></code>. This class will be responsible for listening to connections over named pipes, and invoking actions based on messages received. We also make sure that this class implements <code>IDisposable</code>, so that we can dispose our pipe properly.</p>



<ul><li>Define a name for our pipe. <strong>This name must be unique on the system</strong>. Choose carefully to avoid collisions.</li><li>Create a new <code>PipeServer</code> instance of type <code>PipeMessage</code>. <code>PipeServer</code> in this case comes from the <code>H.Pipes</code> package. <code>PipeMessage</code> is the class we created in our <strong>common project</strong>.</li><li>Define an async method called <code>InitializeAsync</code>. Since <strong>we cannot have async constructurs</strong>, it‚Äôs better to have a separate async method for initialization.</li><li>Wire up some events for <code>ClientConnected</code>, <code>ClientDisconnected</code>, <code>MessageReceived</code> and <code>OnExceptionOccured</code>, each to a separate <strong>private method</strong>.</li><li>Create a method <code>OnClientConnectedAsync</code> where we write a message to the console and send a text message to the client.</li><li>Define a method <code>OnClientDisconnected</code> where we write a message to the console. If we need to put some other logic which needs to be called on client disconnect later on, we can add it to this method.</li></ul>



<pre><code lang="csharp">using H.Pipes;
using H.Pipes.Args;
using NamedPipesSample.Common;

namespace NamedPipesSample.WindowsService
{
    public class NamedPipesServer : IDisposable
    {
        const string PIPE_NAME = &#34;samplepipe&#34;;

        private PipeServer&lt;PipeMessage&gt; server;

        public async Task InitializeAsync()
        {
            server = new PipeServer&lt;PipeMessage&gt;(PIPE_NAME);

            server.ClientConnected += async (o, args) =&gt; await OnClientConnectedAsync(args);
            server.ClientDisconnected += (o, args) =&gt; OnClientDisconnected(args);
            server.MessageReceived += (sender, args) =&gt; OnMessageReceived(args.Message);
            server.ExceptionOccurred += (o, args) =&gt; OnExceptionOccurred(args.Exception);

            await server.StartAsync();
        }

        private void OnClientConnected(ConnectionEventArgs&lt;PipeMessage&gt; args)
        {
            Console.WriteLine($&#34;Client {args.Connection.Id} is now connected!&#34;);

            await args.Connection.WriteAsync(new PipeMessage
            {
                Action = ActionType.SendText,
                Text = &#34;Hi from server&#34;
            });
        }

        private void OnClientDisconnected(ConnectionEventArgs&lt;PipeMessage&gt; args)
        {
            Console.WriteLine($&#34;Client {args.Connection.Id} disconnected&#34;);
        }

        //...
    }
}
</code></pre>







<p><strong>‚Äì Continue by implementing</strong> <code>OnMessageReceived</code>. We switch case on the message action.</p>



<ul><li>If we receive a message from the client, we write it to the console.</li><li><code>ShowTrayIcon</code> and <code>HideTrayIcon</code> will be implemented later on in this tutorial.</li><li>If we do not recognize the message action, we write the action name to the console.</li></ul>



<pre><code lang="csharp">private void OnMessageReceived(PipeMessage? message)
{
	switch(message.Action)
	{
		case ActionType.SendText:
			Console.WriteLine($&#34;Text from client: {message.Text}&#34;);
			break;

		case ActionType.ShowTrayIcon:
			throw new NotImplementedException();

		case ActionType.HideTrayIcon:
			throw new NotImplementedException();

		default:
			Console.WriteLine($&#34;Unknown Action Type: {message.Action}&#34;);
			break;
	}
}</code></pre>







<p><strong>‚Äì We also make sure to implement</strong> <code>OnExceptionOccurred</code>, which lets us see any pipe errors occurring in the console window. In a real-world scenario, we would want to add some logging here.</p>



<pre><code lang="csharp">private void OnExceptionOccurred(Exception ex)
{
	Console.WriteLine($&#34;Exception occured in pipe: {ex}&#34;);
}</code></pre>







<p>‚Äì <strong>Finally</strong>, <strong>we implement</strong> <code>Dispose()</code> for <code>IDisposable</code>. We also create a separate <code>DisposeAsync()</code> method since we want to dispose our server async where possible. We call the <code>DisposeAsync</code> method from the <code>Dipose</code> method and make sure this call is run synchronously by appending <code>.GetAwaiter().GetResult()</code>.</p>



<pre><code lang="csharp">public void Dispose()
{
	DisposeAsync().GetAwaiter().GetResult();
}

public async Task DisposeAsync()
{
	if(server != null)
		await server.DisposeAsync();
}</code></pre>







<h2><span id="Start_NamedPipesServer_in_ServiceHost">Start NamedPipesServer in ServiceHost</span></h2>



<p>‚Äì <strong>We have our pipe server ready</strong> and<strong> </strong>we need to make sure it starts with the Windows Service.</p>



<ul><li>Add a <code>private static NamedPipesServer</code> field called <kbd>pipeServer</kbd> in the <kbd>ServiceHost.cs</kbd> class.</li></ul>



<pre><code lang="csharp">private static NamedPipesServer pipeServer;</code></pre>







<p><strong>‚Äì Add two rows in the top of </strong><code>InitializeServiceThread()</code>:</p>



<ul><li>Create an instance of <code>NamedPipesServer</code> and assign it to the <code>pipeServer</code> field.</li><li>Call <code>IntializeAsync()</code> on our <code>pipeServer</code>. Since this method is marked as async and <code>InitializeServiceThread</code> is synchronous, we append <code>.GetAwaiter().GetResult()</code> which makes this call run synchronous.</li></ul>



<pre><code lang="csharp">private static void InitializeServiceThread()
{
	pipeServer = new NamedPipesServer();
	pipeServer.InitializeAsync().GetAwaiter().GetResult();

	while(!stopping)
	{
		Task.Delay(100).GetAwaiter().GetResult();
	}
}</code></pre>







<h2><span id="Tray_Icon_Client_Application">Tray Icon (Client Application)</span></h2>



<p>A tray icon typically runs in user context. </p>



<p><strong>‚Äì Using the</strong> <code>Hardcodet.NotifyIcon.Wpf</code><strong> Nuget package</strong>, we can quite easily build a WPF-based application with a tray icon.</p>







<h3><span id="Create_a_new_project">Create a new project</span></h3>



<div>
<div>




<p>‚Äì<strong> This time, we select WPF Application</strong>. As earlier, make sure to <strong>not </strong>select the .NET Framework alternative.</p>
</div>



<div>
<figure><img loading="lazy" width="1014" height="675" src="https://erikengberg.com/wp-content/uploads/2021/11/image-38.png" alt="" srcset="https://erikengberg.com/wp-content/uploads/2021/11/image-38.png 1014w, https://erikengberg.com/wp-content/uploads/2021/11/image-38-300x200.png 300w, https://erikengberg.com/wp-content/uploads/2021/11/image-38-768x511.png 768w" sizes="(max-width: 1014px) 100vw, 1014px"/></figure>
</div>
</div>



<div>
<div>




<p><strong>‚Äì Choose a name</strong> for your project.</p>
</div>



<div>
<figure><img loading="lazy" width="745" height="286" src="https://erikengberg.com/wp-content/uploads/2021/11/image-39.png" alt="" srcset="https://erikengberg.com/wp-content/uploads/2021/11/image-39.png 745w, https://erikengberg.com/wp-content/uploads/2021/11/image-39-300x115.png 300w" sizes="(max-width: 745px) 100vw, 745px"/></figure>
</div>
</div>



<div>
<div>




<p><strong>‚Äì Select .NET 6</strong> as target framework.</p>
</div>



<div>
<figure><img loading="lazy" width="647" height="198" src="https://erikengberg.com/wp-content/uploads/2021/11/image-40.png" alt="" srcset="https://erikengberg.com/wp-content/uploads/2021/11/image-40.png 647w, https://erikengberg.com/wp-content/uploads/2021/11/image-40-300x92.png 300w" sizes="(max-width: 647px) 100vw, 647px"/></figure>
</div>
</div>



<h3><span id="Add_Tray_Icon_to_project">Add Tray Icon to project</span></h3>



<div>
<p><strong>‚Äì First, install</strong> <code>Hardcodet.NotifyIcon.Wpf</code>  Nuget package.</p>



<div>
<figure><img loading="lazy" width="505" height="100" src="https://erikengberg.com/wp-content/uploads/2021/11/image-15.png" alt="" srcset="https://erikengberg.com/wp-content/uploads/2021/11/image-15.png 505w, https://erikengberg.com/wp-content/uploads/2021/11/image-15-300x59.png 300w" sizes="(max-width: 505px) 100vw, 505px"/></figure>
</div>
</div>



<p>We need to have an .ico file in our project which can be used as the tray icon. You can download sample icon files <a href="https://icon-icons.com/" target="_blank" rel="noreferrer noopener nofollow">here</a>.</p>



<div>
<div>




<p><strong>‚Äì Add the .ico file to your project</strong> and set <code><strong>Build Action</strong></code> to <code>Resource</code>.</p>
</div>



<div>
<figure><img loading="lazy" width="349" height="279" src="https://erikengberg.com/wp-content/uploads/2021/11/image-42.png" alt="" srcset="https://erikengberg.com/wp-content/uploads/2021/11/image-42.png 349w, https://erikengberg.com/wp-content/uploads/2021/11/image-42-300x240.png 300w" sizes="(max-width: 349px) 100vw, 349px"/></figure>
</div>
</div>







<h3><span id="Resource_Dictionary">Resource Dictionary</span></h3>



<p><strong>‚Äì Now we need to create a </strong><code>Resource Dictionary</code> so we can display our tray icon.</p>



<ul><li>Add a new item of type <strong>Resource Dictionary</strong> to the Tray Icon project. We can name this <kbd>NotifyIconResources.xaml</kbd>.</li></ul>



<figure><img loading="lazy" width="941" height="653" src="https://erikengberg.com/wp-content/uploads/2021/11/image-20.png" alt="" srcset="https://erikengberg.com/wp-content/uploads/2021/11/image-20.png 941w, https://erikengberg.com/wp-content/uploads/2021/11/image-20-300x208.png 300w, https://erikengberg.com/wp-content/uploads/2021/11/image-20-768x533.png 768w" sizes="(max-width: 941px) 100vw, 941px"/></figure>







<p>‚Äì <strong>We need to tell the resource dictionary where to find the .ico file</strong>. What we also want to add is a <strong>context menu</strong> with a few items and bindings. This makes it possible to right-click our tray icon and bring up a context menu. This sample code is taken from <a href="https://www.codeproject.com/script/Articles/ViewDownloads.aspx?aid=36468" target="_blank" rel="noreferrer noopener nofollow">here</a>.</p>



<ul><li>Edit the .xaml file just created</li><li>Paste the code below</li><li>Make sure <code>clr-namespace</code> matches your project‚Äôs namespace</li><li>Make sure <code>IconSource</code> points to your .ico file</li><li>We also define our <code>DataContext</code>, which is <code>NotifyIconViewModel</code>. This view model will be implemented later on.</li></ul>



<pre><code lang="xml">&lt;ResourceDictionary xmlns=&#34;http://schemas.microsoft.com/winfx/2006/xaml/presentation&#34;
                    xmlns:x=&#34;http://schemas.microsoft.com/winfx/2006/xaml&#34;
                    xmlns:tb=&#34;http://www.hardcodet.net/taskbar&#34;
                    xmlns:local=&#34;clr-namespace:NamedPipesSample.TrayIcon&#34;&gt;

    &lt;!-- The taskbar context menu - the first row is a dummy to show off simple data binding --&gt;
    &lt;!--
        The &#34;shared&#34; directive is needed if we reopen the sample window a few times - WPF will otherwise
        reuse the same context menu (which is a resource) again (which will have its DataContext set to the old TaskbarIcon)
  --&gt;
    &lt;ContextMenu x:Shared=&#34;false&#34; x:Key=&#34;SysTrayMenu&#34;&gt;
        &lt;MenuItem Header=&#34;Show Window&#34; Command=&#34;{Binding ShowWindowCommand}&#34; /&gt;
        &lt;MenuItem Header=&#34;Hide Window&#34; Command=&#34;{Binding HideWindowCommand}&#34; /&gt;
        &lt;Separator /&gt;
        &lt;MenuItem Header=&#34;Exit&#34; Command=&#34;{Binding ExitApplicationCommand}&#34; /&gt;
    &lt;/ContextMenu&gt;


    &lt;!-- the application&#39;s NotifyIcon - started from App.xaml.cs. Declares its own view model. --&gt;
    &lt;tb:TaskbarIcon x:Key=&#34;NotifyIcon&#34;
                    IconSource=&#34;/trayicon.ico&#34;
                    ToolTipText=&#34;Double-click for window, right-click for menu&#34;
                    DoubleClickCommand=&#34;{Binding ShowWindowCommand}&#34;
                    ContextMenu=&#34;{StaticResource SysTrayMenu}&#34;&gt;

        &lt;!-- self-assign a data context (could also be done programmatically) --&gt;
        &lt;tb:TaskbarIcon.DataContext&gt;
            &lt;local:NotifyIconViewModel /&gt;
        &lt;/tb:TaskbarIcon.DataContext&gt;
    &lt;/tb:TaskbarIcon&gt;

&lt;/ResourceDictionary&gt;</code></pre>







<h3><span id="DelegateCommandcs">DelegateCommand.cs</span></h3>



<p><strong>‚Äì Create a new class</strong> <code><kbd>DelegateCommand.cs</kbd></code>. In this class we define logic for our command bindings we are about to implement in the view model. The sample code is taken from <a href="https://www.codeproject.com/script/Articles/ViewDownloads.aspx?aid=36468" target="_blank" rel="noreferrer noopener nofollow">here</a>.</p>



<ul><li>We add <strong>two public properties</strong> which are not defined by the interface, but will be used in our view model:<ul><li><code>Action CommandAction</code> lets us define method calls in our view model which are invoked when we execute a command.</li><li><code>Func&lt;bool&gt; CanExecuteFunc</code> lets us define an expressions in the view model which defines if the command can execute.</li></ul></li><li><code>DelegateCommand</code> class <strong>should implement</strong> <code>ICommand</code> which defines the following methods and event:<ul><li><code>event EventHandler? CanExecuteChanged</code> occurs when changes occur that affect whether or not the command should execute.</li><li><code>bool CanExecute(object? parameter)</code> is true if this command can be executed; otherwise, false. This allows us to add some custom logic to globally check if a commands can execute. In the implementation we return true if <code>CanExecuteFunc</code> has not been set by the view model.</li><li><code>void Execute(object? parameter)</code> defines the method to be called when the command is invoked. This makes it possible to add our custom code globally whenever a command is executed ‚Äì for instance we could add some logging or tracking.</li></ul></li></ul>



<pre><code lang="csharp">using System;
using System.Windows.Input;

namespace NamedPipesSample.TrayIcon
{
    public class DelegateCommand : ICommand
    {
        public Action CommandAction { get; set; }
        public Func&lt;bool&gt; CanExecuteFunc { get; set; }

        public void Execute(object parameter)
        {
            CommandAction();
        }

        public bool CanExecute(object parameter)
        {
            return CanExecuteFunc == null || CanExecuteFunc();
        }

        public event EventHandler? CanExecuteChanged
        {
            add { CommandManager.RequerySuggested += value; }
            remove { CommandManager.RequerySuggested -= value; }
        }
    }
}</code></pre>







<h3><span id="View_Model_for_Tray_Icon">View Model for Tray Icon</span></h3>



<div>
<div>




<p>‚Äì <strong>Add a new class</strong> <kbd>NotifyIconViewModel.cs</kbd>. Here we will be defining the <strong>ViewModel</strong> for our Tray Icon. It provides bindable properties and commands for the Tray Icon.</p>



<p>Here, we implement the bindings as <code>ICommand</code> from our resource dictionary. The sample code is taken from <a href="https://www.codeproject.com/script/Articles/ViewDownloads.aspx?aid=36468" target="_blank" rel="noreferrer noopener">here</a>.</p>
</div>



<div>
<figure><img loading="lazy" width="343" height="254" src="https://erikengberg.com/wp-content/uploads/2021/11/image-22.png" alt="" srcset="https://erikengberg.com/wp-content/uploads/2021/11/image-22.png 343w, https://erikengberg.com/wp-content/uploads/2021/11/image-22-300x222.png 300w" sizes="(max-width: 343px) 100vw, 343px"/></figure>
</div>
</div>



<ul><li><code>ShowWindowCommand</code> returns a new <code>DelegateCommand</code> which shows our application‚Äôs <code>MainWindow</code>.</li><li><code>HideWindowCommand</code> hides our <code>MainWindow</code>.</li><li><code>ExitApplicationCommand</code> shuts down our application.</li></ul>



<pre><code lang="csharp">using System.Windows;
using System.Windows.Input;

namespace NamedPipesSample.TrayIcon
{
    public class NotifyIconViewModel
    {
        /// &lt;summary&gt;
        /// Shows a window, if none is already open.
        /// &lt;/summary&gt;
        public ICommand ShowWindowCommand
        {
            get
            {
                return new DelegateCommand
                {
                    CanExecuteFunc = () =&gt; Application.Current.MainWindow == null ||
                        !Application.Current.MainWindow.IsVisible,

                    CommandAction = () =&gt;
                    {
                        Application.Current.MainWindow = new MainWindow();
                        Application.Current.MainWindow.Show();
                    }
                };
            }
        }

        /// &lt;summary&gt;
        /// Hides the main window. This command is only enabled if a window is open.
        /// &lt;/summary&gt;
        public ICommand HideWindowCommand
        {
            get
            {
                return new DelegateCommand
                {
                    CommandAction = () =&gt; Application.Current.MainWindow.Close(),

                    CanExecuteFunc = () =&gt; Application.Current.MainWindow != null &amp;&amp;
                        Application.Current.MainWindow.IsVisible
                };
            }
        }


        /// &lt;summary&gt;
        /// Shuts down the application.
        /// &lt;/summary&gt;
        public ICommand ExitApplicationCommand
        {
            get
            {
                return new DelegateCommand { CommandAction = () =&gt; Application.Current.Shutdown() };
            }
        }
    }
}</code></pre>







<h3><span id="Tray_Icons_Application_Entry_Point">Tray Icon‚Äôs Application Entry Point</span></h3>



<p>At this stage <strong>we need to wire things up</strong> in <kbd>App.xaml</kbd> which is the entry point of a WPF application in .NET.</p>



<ul><li>We set <code>ShudownMode</code> to <code>OnExplicitShutdown</code>. <strong>If not, our app will exit when the main Window is closed</strong> (an our tray icon will be no more)</li><li>If we do not want the main window to open when the application starts (which we might), we can omit <code>StartupUri</code> and its value.<code> </code>For now, we leave it here.</li><li>We specify the file where our <strong>resource dictionary</strong> resides, so it can be found by our app.</li></ul>



<pre><code lang="xml">&lt;Application x:Class=&#34;NamedPipesSample.TrayIcon.App&#34;
             xmlns=&#34;http://schemas.microsoft.com/winfx/2006/xaml/presentation&#34;
             xmlns:x=&#34;http://schemas.microsoft.com/winfx/2006/xaml&#34;
             xmlns:local=&#34;clr-namespace:NamedPipesSample.TrayIcon&#34;
             ShutdownMode=&#34;OnExplicitShutdown&#34;
             StartupUri=&#34;MainWindow.xaml&#34;&gt;
    
    &lt;Application.Resources&gt;
      
        &lt;ResourceDictionary&gt;
            &lt;ResourceDictionary.MergedDictionaries&gt;
                &lt;ResourceDictionary Source=&#34;NotifyIconResources.xaml&#34; /&gt;
            &lt;/ResourceDictionary.MergedDictionaries&gt;
        &lt;/ResourceDictionary&gt;

    &lt;/Application.Resources&gt;
&lt;/Application&gt;
</code></pre>







<p><strong>The next step</strong> is to tell our project to use our resource dictionary. Open <code><kbd>App.xaml.cs</kbd></code>. This file is the code behind for App.xaml. This sample code is taken from <a href="https://www.codeproject.com/script/Articles/ViewDownloads.aspx?aid=36468" target="_blank" rel="noreferrer noopener nofollow">here</a>.</p>



<ul><li>We add a private nullable field <code>TaskbarIcon notifyIcon</code> which holds our <code>NotifyIcon</code> from the resource dictionary.</li><li>By overriding <code>OnStartup</code> we make sure that the <code>notifyIcon</code> field is assigned when the application start. We also make sure to <strong>call the OnStartup method in our base class</strong>.</li><li>Good practice is to dispose our <code>TaskbarIcon</code> on application exit. We can do this by overriding <code>OnExit</code>. Here, we finish up by <strong>invoking OnExit in the base class</strong>.</li></ul>



<pre><code lang="csharp">using Hardcodet.Wpf.TaskbarNotification;
using System.Windows;

namespace NamedPipesSample.TrayIcon
{
    public partial class App : Application
    {
        private TaskbarIcon? notifyIcon;

        protected override void OnStartup(StartupEventArgs e)
        {
            base.OnStartup(e);

            notifyIcon = (TaskbarIcon)FindResource(&#34;NotifyIcon&#34;);
        }

        protected override void OnExit(ExitEventArgs e)
        {
            notifyIcon?.Dispose();
            base.OnExit(e);
        }
    }
}</code></pre>







<h3><span id="Testing_our_Tray_Icon">Testing our Tray Icon</span></h3>







<div>
<div>
<p>‚Äì <strong>We should now be able do a test run of our tray icon. </strong></p>



<p>The main window will open given that the <code>StartupUri</code><span> </span>wasn‚Äôt removed from App.xaml.</p>




</div>



<div>
<figure><img loading="lazy" width="800" height="450" src="https://erikengberg.com/wp-content/uploads/2021/11/image-23.png" alt="" srcset="https://erikengberg.com/wp-content/uploads/2021/11/image-23.png 800w, https://erikengberg.com/wp-content/uploads/2021/11/image-23-300x169.png 300w, https://erikengberg.com/wp-content/uploads/2021/11/image-23-768x432.png 768w" sizes="(max-width: 800px) 100vw, 800px"/></figure>
</div>
</div>



<div>
<div>
<p><strong>If everything worked alright</strong>, we should also be able to see our tray icon. Right-clicking the icon hopefully brings up our context menu where we can show and hide the main window as well as exit the app.</p>



<p>Here, we can see the effect of <code>CanExecuteFunc</code> which were assigned in our view model. I.e. the Show Window command is disabled when the main window is visible.</p>
</div>



<div>
<figure><img loading="lazy" width="311" height="130" src="https://erikengberg.com/wp-content/uploads/2021/11/image-43.png" alt="" srcset="https://erikengberg.com/wp-content/uploads/2021/11/image-43.png 311w, https://erikengberg.com/wp-content/uploads/2021/11/image-43-300x125.png 300w" sizes="(max-width: 311px) 100vw, 311px"/></figure>
</div>
</div>







<h2><span id="Pipe_Client_in_Tray_Icon">Pipe Client in Tray Icon</span></h2>



<p>Finally it‚Äôs time to connect our client app to the Windows service.</p>



<p><strong>‚Äì Install Nuget package</strong> <kbd>H.Pipes</kbd> in the tray icon project.</p>



<p>‚Äì <strong>Add a project reference to the common project</strong>.</p>



<p>‚Äì <strong>Create a new class</strong> <kbd>NamedPipesClient.cs</kbd>.</p>



<p><strong>We implement this class as a singleton</strong>, so that we can easily call it everywhere in our project.</p>



<ul><li>Make sure the <code>NamedPipesClient</code> class implements <code>IDisposable</code> so we can dispose the client on application exit.</li><li>Add a <code>const string</code> which defines the pipe‚Äôs name. <strong>This constant should have the same value as in our pipe server</strong>.</li><li>Create a private <code>static NamedPipesClient</code> field called <code>instance</code> will hold our single instance of this class.</li><li>Create a static property <code>Instance</code> which returns <code>NamedPipesClient</code>. This property does not have a setter. <strong>The getter returns our instance field if not null</strong>, otherwise it returns a new <code>NamedPipesClient</code>.</li><li>Add a <strong>private constructor</strong> which takes 0 arguments. <strong>In the constructor we set</strong> the private <code>instance</code> field <strong>to the current instance</strong> of our class. Since this is a singleton, the constructor will only be called once.</li></ul>



<pre><code lang="csharp">using H.Pipes;
using NamedPipesSample.Common;
using System;
using System.Threading.Tasks;
using System.Windows;

namespace NamedPipesSample.TrayIcon
{
    public class NamedPipesClient : IDisposable
    {
        const string pipeName = &#34;samplepipe&#34;;

        private static NamedPipesClient instance;
        private PipeClient&lt;PipeMessage&gt; client;

        public static NamedPipesClient Instance
        {
            get
            {
                return instance ?? new NamedPipesClient();
            }
        }

        private NamedPipesClient()
        {
            instance = this;
        }
    }

    //...
}</code></pre>







<p>‚Äì <strong>Continue by adding an</strong> <code>IntializeAsync()</code> <strong>method to</strong> <code>NamedPipesClient</code>.</p>



<ul><li>If the client is already connected we do not continue with the initialization.</li><li><strong>We create a new</strong> <code>PipeClient</code> instance with the <code>pipeName</code> constant of type <code>PipeMessage</code>.</li><li>Events are wired up. Some events invoke a method using a property from args. For simplicity in this demo, we just show a message on connect and disconnect.</li><li>We then connect the client and send a hello message to the server.</li></ul>



<pre><code lang="csharp">public async Task InitializeAsync()
{
	if (client != null &amp;&amp; client.IsConnected)
		return;

	client = new PipeClient&lt;PipeMessage&gt;(pipeName);
	client.MessageReceived += (sender, args) =&gt; OnMessageReceived(args.Message);
	client.Disconnected += (o, args) =&gt; MessageBox.Show(&#34;Disconnected from server&#34;);
	client.Connected += (o, args) =&gt; MessageBox.Show(&#34;Connected to server&#34;);
	client.ExceptionOccurred += (o, args) =&gt; OnExceptionOccurred(args.Exception);

	await client.ConnectAsync();

	await client.WriteAsync(new PipeMessage
	{
		Action = ActionType.SendText,
		Text = &#34;Hello from client&#34;,
	});
}</code></pre>







<ul><li>We implement <code>OnMessageReceived</code> <strong>in a similar way to what we did in the server</strong>. In the client however, we only need to be able to listen for text messages from the server. In this demo, we just show any message in a message box.</li><li><strong>If an exception occurs in the pipe</strong>, we show the exception in message box, which makes it easier to troubleshoot any issues during the initial development phase. This is not suitable for a production app.</li></ul>



<pre><code lang="csharp">private void OnMessageReceived(PipeMessage message)
{
	switch (message.Action)
	{
		case ActionType.SendText:
			MessageBox.Show(message.Text);
			break;
		default:
			MessageBox.Show($&#34;Method {message.Action} not implemented&#34;);
			break;
	}
}

private void OnExceptionOccurred(Exception exception)
{
	MessageBox.Show($&#34;An exception occured: {exception}&#34;);
}</code></pre>







<p>We finish up  <code>NamedPipesClient</code> by implementing the <code>Dispose()</code> method, where we dispose the pipe client, given that it‚Äôs not null.</p>



<pre><code lang="csharp">public void Dispose()
{
	if (client != null)
		client.DisposeAsync().GetAwaiter().GetResult();
}</code></pre>







<h2><span id="Initialize_and_Dispose_Pipe_Client_in_Appxamlcs">Initialize and Dispose Pipe Client in App.xaml.cs</span></h2>



<p>As the entry point for our tray icon is <kbd>App.xaml.cs</kbd>, this should also be where we initialize <code>NamedPipesClient</code> and have it connect to our pipe server.</p>



<ul><li>In the constructor, we call <code>InitializeAsync()</code></li><li>Since <strong>this call is async</strong> ‚Äì <strong>but happens in an synchronous method</strong>, and we want to catch any errors we add <code>ContinueWith</code> to display any errors in a <code>MessageBox</code>.</li><li>We make sure <strong>only exceptions</strong> call <code>MessageBox.Show</code> by adding a second argument of <code>TaskContinuationOptions.OnlyOnFaulted</code></li><li>In a production app you probably want to handle any errors occurring in a different way.</li><li>We also make sure to <strong>dispose the pipe client</strong> (and thereby disconnect from pipe server) by adding calling <code>NamedPipesClient.Instance.Dipose()</code> in the first line of <code>OnExit</code> method..</li></ul>



<pre><code lang="csharp">using Hardcodet.Wpf.TaskbarNotification;
using System.Threading.Tasks;
using System.Windows;

namespace NamedPipesSample.TrayIcon
{
    public partial class App : Application
    {
        private TaskbarIcon notifyIcon;

        public App()
        {
            NamedPipesClient.Instance.InitializeAsync().ContinueWith(t =&gt; 
                MessageBox.Show($&#34;Error while connecting to pipe server: {t.Exception}&#34;),
                TaskContinuationOptions.OnlyOnFaulted);
        }

        protected override void OnStartup(StartupEventArgs e)
        {
            base.OnStartup(e);
            
            notifyIcon = (TaskbarIcon)FindResource(&#34;NotifyIcon&#34;);
        }

        protected override void OnExit(ExitEventArgs e)
        {
            NamedPipesClient.Instance.Dispose();
            notifyIcon.Dispose();

            base.OnExit(e);
        }
    }
}
</code></pre>







<h2><span id="Testing_Named_Pipes_Connection">Testing Named Pipes Connection</span></h2>



<p>At this stage, we should be able to connect from our tray icon to the Windows service. What we have achieved in our solution so far is:</p>



<ul><li>Built a Windows service.</li><li>Created Common project which holds our model for communication.</li><li>Implemented a named pipes server within our Windows service.</li><li>Crafted a client app where can hide and show the main window from the tray icon‚Äôs context menu.</li><li>Added a named pipes client which can connect to our server.</li></ul>



<div>
<div>
<p><strong>‚Äì Let‚Äôs start the server and client project!</strong></p>



<p>If we configure multiple startup projects for our solution, we can easily debug both projects simultaneously.</p>
</div>



<div>
<figure><img loading="lazy" width="786" height="544" src="https://erikengberg.com/wp-content/uploads/2021/11/image-44.png" alt="" srcset="https://erikengberg.com/wp-content/uploads/2021/11/image-44.png 786w, https://erikengberg.com/wp-content/uploads/2021/11/image-44-300x208.png 300w, https://erikengberg.com/wp-content/uploads/2021/11/image-44-768x532.png 768w" sizes="(max-width: 786px) 100vw, 786px"/></figure>
</div>
</div>



<div>
<div>




<p><strong>It works!</strong></p>



<p>Feel free to get rid of those annoying messages by modifying <kbd>NamedPipesClient.cs</kbd> üòä</p>
</div>



<div>
<figure><img loading="lazy" width="978" height="465" src="https://erikengberg.com/wp-content/uploads/2021/11/image-45.png" alt="" srcset="https://erikengberg.com/wp-content/uploads/2021/11/image-45.png 978w, https://erikengberg.com/wp-content/uploads/2021/11/image-45-300x143.png 300w, https://erikengberg.com/wp-content/uploads/2021/11/image-45-768x365.png 768w" sizes="(max-width: 978px) 100vw, 978px"/></figure>
</div>
</div>



<p>Now, that we have everything working <strong>we will continue by adding some functionality which requires admin privileges</strong> in the Windows service, which can be controlled from the client app.</p>







<h2><span id="Implementing_Taskbar_Corner_Customizer">Implementing Taskbar Corner Customizer</span></h2>



<p>As mentioned earlier, a typical scenario for the Windows Service ‚Äì Tray Icon app is to <strong>make it possible for a user without admin rights to perform some specific tasks which requires higher privileges</strong>.</p>



<p>In this example, we will implement the <a href="https://taskbarcorner.com/implement-taskbar-corner-customizer-developer-edition/" target="_blank" rel="noreferrer noopener"><strong>Developer Edition</strong></a> of <a href="https://taskbarcorner.com/" target="_blank" rel="noreferrer noopener"><strong>Taskbar Corner Customizer</strong></a>. This solution makes it possible for developers to <strong>make sure the application‚Äôs tray icon is always visible in the Windows notification area</strong> aka taskbar corner. As this solution requires admin privileges (or local system) to work, it makes a good fit for the purpose of this guide.</p>



<p>‚Äì <strong>First, we will implement TCC‚Äôs functionality in our service</strong>, and then continue by adding some buttons in the client app‚Äôs main window, where we can tell the service to perform those actions.</p>



<p><em><strong>Please note: For this part of the guide to work properly, your client app project‚Äôs assembly name must be</strong></em> <kbd>NamedPipesSample.TrayIcon</kbd>. <em>The TCC license attached for this guide is only valid for a tray icon process with this name.</em></p>



<figure><img loading="lazy" width="421" height="114" src="https://erikengberg.com/wp-content/uploads/2021/11/image-46.png" alt="" srcset="https://erikengberg.com/wp-content/uploads/2021/11/image-46.png 421w, https://erikengberg.com/wp-content/uploads/2021/11/image-46-300x81.png 300w" sizes="(max-width: 421px) 100vw, 421px"/></figure>







<h3><span id="Add_Taskbar_Corner_Customizer_package_to_Windows_Service_project">Add Taskbar Corner Customizer package to Windows Service project</span></h3>



<div>
<div>
<p>‚Äì <strong>Start by downloading this file:</strong></p>







<p>We are then going to <strong>add its contents to a folder</strong> called <kbd>TCC</kbd> in <kbd>NamedPipesSample.WindowsService</kbd>.</p>
</div>



<div>
<figure><img loading="lazy" width="350" height="358" src="https://erikengberg.com/wp-content/uploads/2021/11/image-47.png" alt="" srcset="https://erikengberg.com/wp-content/uploads/2021/11/image-47.png 350w, https://erikengberg.com/wp-content/uploads/2021/11/image-47-293x300.png 293w" sizes="(max-width: 350px) 100vw, 350px"/></figure>
</div>
</div>



<div>
<div>




<p>‚Äì <strong>Select all files</strong> in the TCC folder, right click and select properties. <strong>Modify</strong> the <code>Copy to Output Directory setting</code> to <code>Copy if newer</code>.</p>
</div>



<div>
<figure><img loading="lazy" width="688" height="413" src="https://erikengberg.com/wp-content/uploads/2021/11/image-49.png" alt="" srcset="https://erikengberg.com/wp-content/uploads/2021/11/image-49.png 688w, https://erikengberg.com/wp-content/uploads/2021/11/image-49-300x180.png 300w" sizes="(max-width: 688px) 100vw, 688px"/></figure>
</div>
</div>







<h3><span id="TrayIconService_in_Windows_Service">TrayIconService in Windows Service</span></h3>



<p>While Taskbar Corner Customizer (TCC) can be implemented in any code independent of language, the .NET implementation is a little bit easier and more powerful. First, <strong>we need to have a reference to the .NET lib in TCC</strong>.</p>



<div>
<p>‚Äì <strong>Add a project reference</strong> to <kbd>TaskbarCornerCustomizer.Shared.dll</kbd></p>



<div>
<figure><img loading="lazy" width="482" height="257" src="https://erikengberg.com/wp-content/uploads/2021/11/image-50.png" alt="" srcset="https://erikengberg.com/wp-content/uploads/2021/11/image-50.png 482w, https://erikengberg.com/wp-content/uploads/2021/11/image-50-300x160.png 300w" sizes="(max-width: 482px) 100vw, 482px"/></figure>
</div>
</div>



<div>
<div>




<p>‚Äì <strong>Install Nuget package</strong> <code><kbd>System.Management</kbd></code>. This is required for TCC.</p>
</div>



<div>
<figure><img loading="lazy" width="410" height="99" src="https://erikengberg.com/wp-content/uploads/2021/11/image-52.png" alt="" srcset="https://erikengberg.com/wp-content/uploads/2021/11/image-52.png 410w, https://erikengberg.com/wp-content/uploads/2021/11/image-52-300x72.png 300w" sizes="(max-width: 410px) 100vw, 410px"/></figure>
</div>
</div>







<p>Create a new class <kbd>TrayIconService</kbd> in the Windows service project.</p>



<ul><li>This class <strong>should implement</strong> <code>IDisposable</code>, so that we properly dispose the <code>TrayManager</code> from TCC.</li><li>We add a private field <code>trayManager</code> of type <code>TrayManager</code>. This field will hold our instance of TCC‚Äôs TrayManager.</li><li>In the constructor we first <strong>find the correct path to our TCC folder</strong> by:<ul><li>Getting the path to our executing assembly</li><li>Getting the path to the folder of this assembly path</li><li>Combining this folder path with the TCC folder</li></ul></li><li><strong>A new instance</strong> of <code>TrayManager</code> is created and assigned to our private field. We pass the <code>tccFolderPath</code> as <code>folderPath</code> argument to our TrayManager.</li><li>If any errors occur when we create our <code>TrayManager</code> instance, we log this to the console.</li></ul>



<pre><code lang="csharp">using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using TaskbarCornerCustomizer.Shared;
using TaskbarCornerCustomizer.Shared.Models;

namespace NamedPipesSample.WindowsService
{
    internal class TrayIconService : IDisposable
    {
        private TrayManager? trayManager;

        public TrayIconService()
        {
            try
            {
                var tccFolderPath = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), &#34;TCC&#34;);
                trayManager = new TrayManager(folderPath: tccFolderPath);

            }
            catch (Exception ex)
            {
                Console.WriteLine($&#34;Could not start tray manager: {ex}&#34;);
            }
        }

	//...
    }
}
</code></pre>







<p>We will expose two public methods in <kbd>TrayIconService.cs</kbd> which then use TCC to modify the visibility of our tray icon.</p>



<ul><li>We define a <code>private constant string TRAY_ICON_PROCESS_NAME</code> which holds the name of our tray icon process.</li><li><code>ShowTrayIcon()</code> <strong>iterates over user SIDs for all currently logged on users</strong>, and then calls <code>SetConfig</code> on our <code>TrayManager</code> with a single entry <code>Dictionary</code> <strong>which sets the visibility state of our tray icon</strong> to <code>Visible</code>.</li><li><code>HideTrayIcon()</code> does the same, but sets the visibility state to <code>Hidden</code>.</li></ul>



<pre><code lang="csharp">private const string TRAY_ICON_PROCESS_NAME = &#34;NamedPipesSample.TrayIcon&#34;;

public void ShowTrayIcon()
{
	var usersSids = trayManager.GetCurrentlyLoggedOnUsersSids().ToList();

	foreach (var userSid in usersSids)
	{
		trayManager.SetConfig(userSid, new Dictionary&lt;string, TrayIconState&gt;() { { TRAY_ICON_PROCESS_NAME, TrayIconState.Visible } });
	}
}

public void HideTrayIcon()
{
	var usersSids = trayManager.GetCurrentlyLoggedOnUsersSids().ToList();

	foreach (var userSid in usersSids)
	{
		trayManager.SetConfig(userSid, new Dictionary&lt;string, TrayIconState&gt;() { { TRAY_ICON_PROCESS_NAME, TrayIconState.Hidden } });
	}
}</code></pre>







<p>‚Äì <strong>Finally, we implement the <code>Dispose</code> method</strong>, where we dispose our <code>TrayManager</code>.</p>



<pre><code lang="csharp">public void Dispose()
{
	trayManager?.Dispose();
}</code></pre>







<h3><span id="Call_TrayIconService_in_Pipe_Server">Call TrayIconService in Pipe Server</span></h3>



<p>Now it‚Äôs time to implement the actions for show and hide tray icon in <kbd>NamedPipesServer.cs</kbd>.</p>



<ul><li><strong>Add a private field</strong> called <code>trayIconService</code> of type <code>TrayIconService</code>. You guessed it, this field will hold our TrayIconService‚Ä¶</li><li><strong>Create a constructor</strong> which takes 0 arguments, creates a new instance of <code>TrayIconService</code> and assigns it to our field.</li></ul>



<pre><code lang="csharp">private TrayIconService trayIconService;

public NamedPipesServer()
{
	trayIconService = new TrayIconService();
}</code></pre>







<p>We also need to implement the calls in  <code>OnMessageReceived</code>.</p>



<ul><li><strong>Modify the case</strong> for <code>ActionType.ShowTrayIcon</code> to call <code>ShowTrayIcon</code> on <code>trayIconService</code>. Add a break statement afterwards.</li><li><strong>Do the same</strong> for <code>ActionType.HideTrayIcon</code>, but invoke <code>HideTrayIcon()</code> instead.</li></ul>



<pre><code lang="csharp">private void OnMessageReceived(PipeMessage message)
{
	switch(message.Action)
	{
		case ActionType.SendText:
			Console.WriteLine($&#34;Text from client: {message.Text}&#34;);
			break;

		case ActionType.ShowTrayIcon:
			trayIconService.ShowTrayIcon();
			break;

		case ActionType.HideTrayIcon:
			trayIconService.HideTrayIcon();
			break;

		default:
			Console.WriteLine($&#34;Unknown Action Type: {message.Action}&#34;);
			break;
	}
}</code></pre>







<p><strong>The Windows service project is now completed.</strong></p>







<h2><span id="Show_and_Hide_Tray_Icon_from_Client_App">Show and Hide Tray Icon from Client App</span></h2>



<p>The last thing we need to do is provide some UI where we can tell the service to do things.</p>



<p><strong>‚Äì In</strong> NamedPipesClient.cs,<strong> add two async methods:</strong></p>



<ul><li><code>ShowTrayIconAsync</code> will send a message to the server with an <code>ActionType</code> of <code>ShowTrayIcon</code>.</li><li><code>HideTrayIconAsync</code> will do the same, but with an <code>ActionType</code> of <code>HideTrayIcon</code>.</li></ul>



<pre><code lang="csharp">public async Task ShowTrayIconAsync()
{
	await client.WriteAsync(new PipeMessage
	{
		Action = ActionType.ShowTrayIcon
	});
}

public async Task HideTrayIconAsync()
{
	await client.WriteAsync(new PipeMessage
	{
		Action = ActionType.HideTrayIcon
	});
}</code></pre>











<p><strong>‚Äì Edit MainWindow.xaml and add the xaml code below.</strong></p>



<ul><li>We set the title of our main window to NamedPipesSample</li><li>We add two buttons which invokes methods in our code behind.</li></ul>



<pre><code lang="xml">&lt;Window x:Name=&#34;MainWindow1&#34; x:Class=&#34;NamedPipesSample.TrayIcon.MainWindow&#34;
        xmlns=&#34;http://schemas.microsoft.com/winfx/2006/xaml/presentation&#34;
        xmlns:x=&#34;http://schemas.microsoft.com/winfx/2006/xaml&#34;
        xmlns:d=&#34;http://schemas.microsoft.com/expression/blend/2008&#34;
        xmlns:mc=&#34;http://schemas.openxmlformats.org/markup-compatibility/2006&#34;
        xmlns:local=&#34;clr-namespace:NamedPipesSample.TrayIcon&#34;
        mc:Ignorable=&#34;d&#34;
        Title=&#34;NamedPipesSample&#34; Height=&#34;450&#34; Width=&#34;800&#34;&gt;
    &lt;Grid&gt;
        &lt;Button x:Name=&#34;ShowTrayIconBtn&#34; Content=&#34;Show TrayIcon&#34; HorizontalAlignment=&#34;Left&#34; Margin=&#34;107,0,0,0&#34; VerticalAlignment=&#34;Center&#34; Height=&#34;73&#34; Width=&#34;207&#34; Click=&#34;ShowTrayIconBtn_Click&#34;/&gt;
        &lt;Button x:Name=&#34;HideTrayIconBtn&#34; Content=&#34;Hide TrayIcon&#34; HorizontalAlignment=&#34;Left&#34; Margin=&#34;472,0,0,0&#34; VerticalAlignment=&#34;Center&#34; Height=&#34;73&#34; Width=&#34;207&#34; Click=&#34;HideTrayIconBtn_Click&#34;/&gt;
    &lt;/Grid&gt;
&lt;/Window&gt;
</code></pre>







<p><strong>‚Äì As a last step, we must implement the Click event methods for our buttons.</strong></p>



<ul><li>We make the methods async so that we don‚Äôt lock up the UI while the code executes.</li><li><code>ShowTrayIconBtn_Click</code> calls <code>ShowTrayIconAsync</code> on the <code>NamedPipesClient</code>.</li><li><code>HideTrayIconBtc_Click</code> calls <code>HideTrayIconAsync</code> on the <code>NamedPipesClient</code>.</li></ul>



<pre><code lang="csharp">using System.Windows;

namespace NamedPipesSample.TrayIcon
{
    /// &lt;summary&gt;
    /// Interaction logic for MainWindow.xaml
    /// &lt;/summary&gt;
    public partial class MainWindow : Window
    {
        public MainWindow()
        {
            InitializeComponent();
        }

        private async void ShowTrayIconBtn_Click(object sender, RoutedEventArgs e)
        {
            await NamedPipesClient.Instance.ShowTrayIconAsync();
        }

        private async void HideTrayIconBtn_Click(object sender, RoutedEventArgs e)
        {
            await NamedPipesClient.Instance.HideTrayIconAsync();
        }
    }
}
</code></pre>







<h2><span id="Testing_What_Weve_Built">Testing What We‚Äôve Built</span></h2>



<p><strong>‚Äì Restart Visual Studio as Administrator</strong>. For the Taskbar Corner Customizer library to work, we need to run the Windows Service with admin rights.</p>



<p><strong>‚Äì Start both the Windows service and the tray icon project</strong>. Now, we should be able to test the buttons in our main window.</p>



<figure><img loading="lazy" width="786" height="443" src="https://erikengberg.com/wp-content/uploads/2021/11/image-53.png" alt="" srcset="https://erikengberg.com/wp-content/uploads/2021/11/image-53.png 786w, https://erikengberg.com/wp-content/uploads/2021/11/image-53-300x169.png 300w, https://erikengberg.com/wp-content/uploads/2021/11/image-53-768x433.png 768w" sizes="(max-width: 786px) 100vw, 786px"/></figure>



<p><strong>‚Äì Clicking Show or Hide will then move our tray icon</strong> between the notification area aka taskbar corner, and the taskbar corner‚Äôs overflow menu.</p>







<h3><span id="Testing_as_a_Windows_Service">Testing as a Windows Service</span></h3>



<p>Up until now we have only been debugging our Windows service project. It‚Äôs time to test it in the wild.</p>



<p>‚Äì <strong>Start a</strong> <code>cmd</code> (or PowerShell) prompt <strong>as admin</strong>.</p>



<p><strong>‚Äì Create a new Windows service on your machine and specify the path to the exe of our service as</strong> <code>binPath</code>.</p>



<pre><code lang="bash">sc.exe create &#34;NamedPipesSample&#34; binPath=&#34;&lt;PATH_TO_SOLUTION&gt;\NamedPipesSample.WindowsService\bin\Debug\net6.0-windows\NamedPipesSample.WindowsService.exe&#34;</code></pre>







<div>
<p>If everything is working you should see a <code>SUCCESS</code> message.</p>



<div>
<figure><img loading="lazy" width="979" height="193" src="https://erikengberg.com/wp-content/uploads/2021/11/image-56.png" alt="" srcset="https://erikengberg.com/wp-content/uploads/2021/11/image-56.png 979w, https://erikengberg.com/wp-content/uploads/2021/11/image-56-300x59.png 300w, https://erikengberg.com/wp-content/uploads/2021/11/image-56-768x151.png 768w" sizes="(max-width: 979px) 100vw, 979px"/></figure>
</div>
</div>



<p>‚Äì <strong>Run</strong> <code>services.msc</code> <strong>as admin</strong>.</p>



<p>‚Äì <strong>Right click, and select Start</strong>.</p>



<figure><img loading="lazy" width="880" height="134" src="https://erikengberg.com/wp-content/uploads/2021/11/image-57.png" alt="" srcset="https://erikengberg.com/wp-content/uploads/2021/11/image-57.png 880w, https://erikengberg.com/wp-content/uploads/2021/11/image-57-300x46.png 300w, https://erikengberg.com/wp-content/uploads/2021/11/image-57-768x117.png 768w" sizes="(max-width: 880px) 100vw, 880px"/></figure>



<p><strong>‚Äì Press F5 to refresh to verify that your service is still running and has not crashed.</strong></p>







<p>Now we need to test the service with our tray icon.</p>



<div>
<p><strong>‚Äì Start the tray icon project in Visual Studio.</strong></p>



<div>
<figure><img loading="lazy" width="557" height="82" src="https://erikengberg.com/wp-content/uploads/2021/11/image-58.png" alt="" srcset="https://erikengberg.com/wp-content/uploads/2021/11/image-58.png 557w, https://erikengberg.com/wp-content/uploads/2021/11/image-58-300x44.png 300w" sizes="(max-width: 557px) 100vw, 557px"/></figure>
</div>
</div>



<figure><img loading="lazy" width="786" height="443" src="https://erikengberg.com/wp-content/uploads/2021/11/image-59.png" alt="" srcset="https://erikengberg.com/wp-content/uploads/2021/11/image-59.png 786w, https://erikengberg.com/wp-content/uploads/2021/11/image-59-300x169.png 300w, https://erikengberg.com/wp-content/uploads/2021/11/image-59-768x433.png 768w" sizes="(max-width: 786px) 100vw, 786px"/></figure>



<p><strong>‚Äì We can see that we are connected to our server and can receive messages. </strong></p>



<p>All done.</p>



<div>
<p>You can delete the Windows service afterwards by running <code>sc delete</code> in an <strong>elevated </strong>command prompt.</p>



<div>
<pre><code lang="bash">sc delete &#34;NamedPipesSample&#34;</code></pre>
</div>
</div>







<p><strong>In a future post we will create an installer for our solution using WixSharp.</strong></p>
                        
                                                
                    </article></div>
  </body>
</html>
