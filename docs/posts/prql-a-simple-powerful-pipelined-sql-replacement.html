<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://prql-lang.org/">Original</a>
    <h1>PRQL: a simple, powerful, pipelined SQL replacement</h1>
    
    <div id="readability-page-1" class="page"><div id="main"><section><div><div><div><div><h4>For data engineers</h4><ul><li>PRQL is concise, with abstractions such as variables &amp; functions</li><li>PRQL is database agnostic, compiling to many dialects of SQL</li><li>PRQL isn’t limiting — it can contain embedded SQL where necessary</li><li>PRQL has bindings to most major languages <em>(and more are in progress)</em></li><li>PRQL allows for column lineage and type inspection <em>(in progress)</em></li></ul></div></div><div><div><h4>For analysts</h4><ul><li>PRQL is ergonomic for data exploration — for example, commenting out a filter, or a column in a list, maintains a valid query</li><li>PRQL is simple, and easy to understand, with a small number of powerful concepts</li><li>PRQL allows for powerful autocomplete, type-checking, and helpful error messages <em>(in progress)</em></li></ul></div></div><div><div><h4>For tools</h4><ul><li>PRQL is a stable foundation to build on; we’re open-source and will never have a commercial product</li><li>PRQL is a single secular standard which tools can target</li><li>PRQL is easy for machines to read &amp; write</li></ul></div></div><div><div><h4>For HackerNews enthusiasts</h4><ul><li>The PRQL compiler is written in rust</li><li>We talk about “orthogonal language features” a lot</li></ul></div></div></div></div></section><section><div><div><div><p><h2>Showcase</h2></p><p>PRQL consists of a curated set of orthogonal transformations, which are combined together to form a pipeline. That makes it easy to compose and extend queries. The language also benefits from modern features, such syntax for dates, ranges and f-strings as well as functions, type checking and better null handling.</p><p><a href="https://prql-lang.org/playground/">Playground</a>
<a href="https://prql-lang.org/book/">Book</a></p></div><div><div id="v-pills-tabContent"><div id="v-pills-basics" role="tabpanel" aria-labelledby="v-pills-basics-tab" tabindex="0"><pre><code data-lang="prql">from employees
select [id, first_name, age]
sort age
take 10
</code></pre><pre><code data-lang="sql">SELECT id, first_name, age
FROM employees
ORDER BY age
LIMIT 10
</code></pre></div><div id="v-pills-friendly-syntax" role="tabpanel" aria-labelledby="v-pills-friendly-syntax-tab" tabindex="0"><pre><code data-lang="prql">from order               # This is a comment
filter status == &#34;done&#34;
sort [-amount]           # sort order
</code></pre><pre><code data-lang="sql">SELECT
  order.*
FROM
  order
WHERE
  status = &#39;done&#39;
ORDER BY
  amount DESC
</code></pre></div><div id="v-pills-dates" role="tabpanel" aria-labelledby="v-pills-dates-tab" tabindex="0"><pre><code data-lang="prql">from employees
derive [
  age_at_year_end = (@2022-12-31 - dob),
  first_check_in = start + 10days,
]
</code></pre><pre><code data-lang="sql">SELECT
  employees.*,
  DATE &#39;2022-12-31&#39; - dob AS age_at_year_end,
  start + INTERVAL &#39;10&#39; DAY AS first_check_in
FROM
  employees
</code></pre></div><div id="v-pills-orthogonal" role="tabpanel" aria-labelledby="v-pills-orthogonal-tab" tabindex="0"><pre><code data-lang="prql">from employees
# Filter before aggregations
filter start_date &gt; @2021-01-01
group country (
  aggregate [max_salary = max salary]
)
# And filter after aggregations!
filter max_salary &gt; 100000
</code></pre><pre><code data-lang="sql">SELECT
  country,
  MAX(salary) AS max_salary
FROM
  employees
WHERE
  start_date &gt; DATE &#39;2021-01-01&#39;
GROUP BY
  country
HAVING
  MAX(salary) &gt; 100000
</code></pre></div><div id="v-pills-f-strings" role="tabpanel" aria-labelledby="v-pills-f-strings-tab" tabindex="0"><pre><code data-lang="prql">from web
# Just like Python
select url = f&#34;http://www.{domain}.{tld}/{page}&#34;
</code></pre><pre><code data-lang="sql">SELECT CONCAT(&#39;http://www.&#39;, domain, &#39;.&#39;, tld,
  &#39;/&#39;, page) AS url
FROM web
</code></pre></div><div id="v-pills-windows" role="tabpanel" aria-labelledby="v-pills-windows-tab" tabindex="0"><pre><code data-lang="prql">from employees
group employee_id (
  sort month
  window rolling:12 (
    derive [trail_12_m_comp = sum paycheck]
  )
)
</code></pre><pre><code data-lang="sql">SELECT
  employees.*,
  SUM(paycheck) OVER (
    PARTITION BY employee_id
    ORDER BY
      month ROWS BETWEEN 11 PRECEDING
      AND CURRENT ROW
  ) AS trail_12_m_comp
FROM
  employees
</code></pre></div><div id="v-pills-functions" role="tabpanel" aria-labelledby="v-pills-functions-tab" tabindex="0"><pre><code data-lang="prql">func fahrenheit_from_celsius temp -&gt; temp * 9/5 + 32

from weather
select temp_f = (fahrenheit_from_celsius temp_c)
</code></pre><pre><code data-lang="sql">SELECT
  temp_c * 9/5 + 32 AS temp_f
FROM
  weather
</code></pre></div><div id="v-pills-top-n" role="tabpanel" aria-labelledby="v-pills-top-n-tab" tabindex="0"><pre><code data-lang="prql"># Most recent employee in each role
# Quite difficult in SQL...
from employees
group role (
  sort join_date
  take 1
)
</code></pre><pre><code data-lang="sql">WITH table_0 AS (
  SELECT
    employees.*,
    ROW_NUMBER() OVER (
      PARTITION BY role
      ORDER BY
        join_date
    ) AS _rn
  FROM
    employees
)
SELECT
  table_0.*
FROM
  table_0
WHERE
  _rn &lt;= 1
</code></pre></div><div id="v-pills-s-string" role="tabpanel" aria-labelledby="v-pills-s-string-tab" tabindex="0"><pre><code data-lang="prql"># There&#39;s no `version` in PRQL, but
# we have an escape hatch:
derive db_version = s&#34;version()&#34;
</code></pre><pre><code data-lang="sql">SELECT
  version() AS db_version
</code></pre></div><div id="v-pills-joins" role="tabpanel" aria-labelledby="v-pills-joins-tab" tabindex="0"><pre><code data-lang="prql">from employees
join benefits [==employee_id]
join side:left p=positions [id==employee_id]
select [employee_id, role, vision_coverage]
</code></pre><pre><code data-lang="sql">SELECT
  employee_id,
  role,
  vision_coverage
FROM
  employees
  JOIN benefits USING(employee_id)
  LEFT JOIN positions AS p ON id = employee_id
</code></pre></div><div id="v-pills-null-handling" role="tabpanel" aria-labelledby="v-pills-null-handling-tab" tabindex="0"><pre><code data-lang="prql">from users
filter last_login != null
filter deleted_at == null
derive channel = channel ?? &#34;unknown&#34;
</code></pre><pre><code data-lang="sql">SELECT
  users.*,
  COALESCE(channel, &#39;unknown&#39;) AS channel
FROM
  users
WHERE
  last_login IS NOT NULL
  AND deleted_at IS NULL
</code></pre></div><div id="v-pills-dialects" role="tabpanel" aria-labelledby="v-pills-dialects-tab" tabindex="0"><pre><code data-lang="prql">prql sql_dialect:mssql  # Will generate TOP rather than LIMIT

from employees
sort age
take 10
</code></pre><pre><code data-lang="sql">SELECT
  TOP (10) employees.*
FROM
  employees
ORDER BY
  age
</code></pre></div></div></div></div></div></section><section><div><div><div><div><h4>Pipelined</h4><p><strong>A PRQL query is a linear pipeline of transformations</strong></p><p>Each line of the query is a transformation of the previous line’s result. This makes it easy to read, and simple to write.</p></div></div><div><div><h4>Simple</h4><p><strong>PRQL serves both sophisticated engineers and analysts without coding experience.</strong></p><p>By providing a small number of powerful &amp; orthogonal primitives, queries are simple and composable — there’s only one way of expressing each operation. We can eschew the debt that SQL has built up.</p></div></div><div><div><h4>Open</h4><p><strong>PRQL is open-source, with an open community</strong></p><p>PRQL will always be fully open-source and will never have a commercial product. By compiling to SQL, PRQL is compatible with most databases, existing tools, and programming languages that manage SQL. We’re a welcoming community for users, contributors, and other projects.</p></div></div><div><div><h4>Extensible</h4><p><strong>PRQL is designed to be extended, from functions to language bindings</strong></p><p>PRQL has abstractions which make it a great platform to build on. Its explicit versioning allows changes without breaking backward-compatibility. And in the cases where PRQL doesn’t yet have an implementation, it allows embedding SQL with S-Strings.</p></div></div><div><div><h4>Analytical</h4><p><strong>PRQL’s focus is analytical queries</strong></p><p>PRQL was originally designed to serve the growing need of writing analytical queries, emphasizing data transformations, development speed, and readability. We de-emphasize other SQL features such as inserting data or transactions.</p></div></div></div></div></section><section><div><div><div><div><h4><a href="https://github.com/prql/dbt-prql" target="_blank" rel="noopener">dbt<sup><i></i></sup></a></h4><p>Allows writing PRQL in dbt models. This combines the benefits of PRQL’s power &amp; simplicity within queries; with dbt’s version control, lineage &amp; testing across queries.</p></div></div><div><div><h4><a href="https://pyprql.readthedocs.io/en/latest/magic_readme.html" target="_blank" rel="noopener">Jupyter/IPython<sup><i></i></sup></a></h4><p>PyPrql contains a Jupyter extension, which executes a PRQL cell against a database. It can also set up an in-memory DuckDB instance, populated with a pandas DataFrame.</p></div></div><div><div><h4><a href="https://prql-lang.org/book/integrations/prefect.html" target="_blank" rel="noopener">Prefect<sup><i></i></sup></a></h4><p>Add PRQL models to your Prefect workflows with a single function.</p></div></div></div></div></section><section><div><div><div><div><h4><a href="https://prql-lang.org/playground/" target="_blank" rel="noopener">Playground<sup><i></i></sup></a></h4><p>Online in-browser playground that compiles PRQL to SQL as you type.</p></div></div><div><div><h4><a href="https://github.com/prql/PyPrql" target="_blank" rel="noopener">PyPrql<sup><i></i></sup></a></h4><p>Python TUI for connecting to databases.
Provides a native interactive console with auto-complete for column names and Jupyter/IPython cell magic.</p><p><code>pip install pyprql</code></p></div></div><div><div><h4><a href="https://github.com/PRQL/prql" target="_blank" rel="noopener">prql-compiler<sup><i></i></sup></a></h4><p>Reference compiler implementation. Has a CLI utility that can transpile, format and annotate PRQL queries.</p><p><code>brew install prql/PRQL/prql-compiler</code></p></div></div></div></div></section><section id="bindings"><div><div><div><div><h4><a href="https://www.npmjs.com/package/prql-js" target="_blank" rel="noopener">prql-js<sup><i></i></sup></a></h4><p>JavaScript bindings for prql-compiler.</p></div></div><div><div><h4><a href="https://eitsupi.r-universe.dev/ui#package:prqlr" target="_blank" rel="noopener">prqlr<sup><i></i></sup></a></h4><p>R bindings for prql-compiler.</p></div></div><div><div><h4><a href="https://crates.io/crates/prql-compiler" target="_blank" rel="noopener">prql-compiler<sup><i></i></sup></a></h4><p>PRQL’s compiler library, written in Rust.</p><p><code>cargo install prql-compiler</code></p></div></div></div></div></section></div></div>
  </body>
</html>
