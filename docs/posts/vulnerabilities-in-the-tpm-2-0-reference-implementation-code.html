<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.quarkslab.com/vulnerabilities-in-the-tpm-20-reference-implementation-code.html">Original</a>
    <h1>Vulnerabilities in the TPM 2.0 reference implementation code</h1>
    
    <div id="readability-page-1" class="page"><div>
  

  <p>In this blog post we discuss the details of two vulnerabilities we discovered in the Trusted Platform Module (TPM) 2.0 reference implementation code. These two vulnerabilities, an out-of-bounds write (<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-1017">CVE-2023-1017</a>) and an out-of-bounds read (<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-1018">CVE-2023-1018</a>), affected several TPM 2.0 software implementations (such as the ones used by virtualization software) as well as a number of hardware TPMs.</p>

  <h2>Introduction</h2>
<p>In October 2021, Microsoft released Windows 11. One of the installation requirements that stood out was the need for a Trusted Platform Module (TPM) 2.0.
An implication of this requirement is that, in order to be able to run Windows 11 within a virtual machine, virtualization software must provide a TPM to VMs, either by doing passthrough to the hardware TPM on the host machine, or by supplying a virtual TPM to them.</p>
<p>We found this to be an interesting topic for vulnerability research, since the addition of virtual TPMs means extended attack surface on virtualization software that can be reached from within a guest, and so it could potentially be used for a virtual machine escape. As a result of the research effort, we discovered two security issues: an out-of-bounds write identified as <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-1017">CVE-2023-1017</a>, and an out-of-bounds read identified as <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-1018">CVE-2023-1018</a>. They can be triggered from user-mode applications by sending malicious TPM 2.0 commands with encrypted parameters. Interestingly, these two vulnerabilities turned out to have a way longer reach than we initially thought: given that they originate in the reference implementation code published by the Trusted Computing Group (TCG for short, the nonprofit organization that publishes and maintains the TPM specification), these security bugs affected not only every virtualization software we tested, but hardware implementations as well.</p>
<p>Note that most of our assessments in this blog post (e.g. regarding exploitability, impact, or which platforms are affected) are based on our analysis of software-based virtual TPMs, because we can debug them in an easy way to perform dynamic analysis (well, debugging Hyper-V&#39;s virtual TPM is harder because it runs as an <a href="https://learn.microsoft.com/en-us/windows/win32/procthread/isolated-user-mode--ium--processes">IUM process</a>, but that&#39;s another story). On the contrary, getting visibility of what&#39;s happening at runtime in the firmware of a TPM, running in a separate chip without debugging interfaces, is an entirely different problem to tackle. Even doing static analysis of the firmware of a hardware TPM proved to be difficult: the few TPM firmware updates we attempted to analyze happened to be encrypted. Therefore, the lack of specific assessment on hardware TPMs doesn&#39;t mean that they are not affected; it just means that we couldn&#39;t evaluate how most of them are impacted due to the lack of observability. However, using the Proof-of-Concept code published in this blog post, we have verified that at least some discrete TPM chips are vulnerable. After attempting the OOB write, the chip would stop responding (i.e. it didn&#39;t recognize commands anymore) and require a hard reboot of the computer to be operational again, thus confirming its vulnerable condition.</p>
<h2>Affected platforms</h2>
<p>This is a non-exhaustive list of affected software and hardware platforms. Products listed here are those in which we could certainly demonstrate the existence of the vulnerabilities with the help of the PoC provided within this blog post, but it&#39;s very likely for other TPMs - either virtual or physical- to be vulnerable as well.</p>
<ul>
<li>The vulnerable code was present in the latest available version (at the time we performed our research) of the TPM 2.0 reference implementation: <a href="https://trustedcomputinggroup.org/wp-content/uploads/Trusted-Platform-Module-Library-Family-2.0-Level-00-Revision-1.59_pub.zip">Trusted Platform Module Library Specification, Family &#34;2.0&#34;, Level 00, Revision 01.59 â€“ November 2019</a>;</li>
<li>Microsoft Hyper-V on Windows 10 (affected module: <code>TPMEngUM.dll</code> version 10.0.19041.1415);</li>
<li>VMware Workstation version 16.2.4 build-20089737 (affected module: <code>tpm2emu.exe</code> - no version information in the executable);</li>
<li><a href="https://github.com/stefanberger/libtpms">Libtpms/SWTPM</a>, used by Qemu and VirtualBox (compiled from the master branch, commit <code>520a2fa27d27a4ab18f4cf1c597662c6a468565f</code>);</li>
<li>Nuvoton hardware TPM (firmware version: 1.3.0.1);</li>
<li>In general, all TPMs 2.0 whose firmware is based on the Trusted Computing Group reference implementation code are expected to be affected.</li>
</ul>
<h2>A threat to cloud computing</h2>
<p>All the major cloud computing providers offer instances with virtual TPMs. This exposes an interesting scenario, since a malicious actor could attempt to exploit these vulnerabilities in the virtual TPM in order to escape from a virtual machine and compromise the host system.</p>
<ul>
<li>Amazon AWS has <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/nitrotpm.html">NitroTPM</a>;</li>
<li>Microsoft Azure provides virtual TPMs as part of <a href="https://learn.microsoft.com/en-us/azure/virtual-machines/trusted-launch">Trusted Launch</a>;</li>
<li>Google Cloud offers virtual TPMs as part of <a href="https://cloud.google.com/blog/products/identity-security/virtual-trusted-platform-module-for-shielded-vms-security-in-plaintext">Shielded VMs</a>;</li>
<li>Oracle Cloud Infrastructure provides virtual TPMs as part of <a href="https://blogs.oracle.com/cloud-infrastructure/post/introducing-shielded-instances-for-oci-compute">Shielded Instances</a>.</li>
</ul>
<p>Those providers using a virtual TPM based on the TCG reference implementation are expected to be vulnerable. In the case of Google Cloud, the blog post linked above mentions that the core of their virtual TPM comes from <a href="https://sourceforge.net/projects/ibmswtpm2/">code published by IBM</a>, which is extracted automatically from the full source code of the TPM 2.0 spec, and we verified that the bugs in the <code>CryptParameterDecryption</code> function are present in it. In the case of Microsoft Azure, the documentation linked before mentions that their virtual TPM is &#34;compliant with the TPM 2.0 spec&#34;, and we have verified that the virtual TPM included in the version of Hyper-V that is available on Windows 10 is indeed vulnerable. The bugs were also present in Microsoft&#39;s <a href="https://github.com/microsoft/ms-tpm-20-ref">open source reference implementation</a>.  </p>
<p>Regarding Amazon AWS and Oracle Cloud Infrastructure, we don&#39;t have much details about what they use, except that the NitroTPM documentation mentions that it &#34;<em>conforms to the TPM 2.0 specification</em>&#34; with a link to the TCG website.</p>
<h2>Fixes</h2>
<h3>Reference implementation</h3>
<ul>
<li>The Trusted Computing Group published <a href="https://trustedcomputinggroup.org/wp-content/uploads/TPM-2.0-Library-Spec-v1.59-Errata-v1.4_pub.pdf">errata version 1.4 for TCG Trusted Platform Module Library</a>, with suggested fixes 
for the two bugs.</li>
</ul>
<h3>Software products</h3>
<ul>
<li>Microsoft patched the bugs in Hyper-V in their March, 2023 security update. Their assessment of impact for the OOB write is low in TPM 2.0 in Pluton/HCL/Overlake/Manticore standard server for Azure because the overwrite is only 2 bytes and their team have not identified a consistent and easily achievable way to obtain EoP or RCE with only 2 bytes.</li>
<li>Microsoft also patched their open source reference implementation with commit <a href="https://github.com/microsoft/ms-tpm-20-ref/commit/9bdd9f0aaba5e54b3c314cfff02cf532281a067e">9bdd9f0aaba5e54b3c314cfff02cf532281a067e</a>.  </li>
<li>VMware is expected to issue fixes for the bugs in April, 2023. </li>
<li>Libtpms patched the bugs in commit <a href="https://github.com/stefanberger/libtpms/commit/324dbb4c27ae789c73b69dbf4611242267919dd4">324dbb4c27ae789c73b69dbf4611242267919dd4</a>.</li>
<li>Chromium OS patched the vulnerabilities in commit <a href="https://chromium.googlesource.com/chromiumos/third_party/tpm2/+/3b87ed233acb4c76c27872e1ac0b74dc032199f1%5E%21/">3b87ed233acb4c76c27872e1ac0b74dc032199f1</a>.</li>
<li>IBM patched their open source implementation in commit <a href="https://sourceforge.net/p/ibmswtpm2/tpm2/ci/102893a5f45dbb0b0ecc0eb52a8dd4defe559f92/">102893a5f45dbb0b0ecc0eb52a8dd4defe559f92</a>.</li>
</ul>
<h3>Hardware products</h3>
<ul>
<li>Nuvoton published security advisory <a href="https://www.nuvoton.com/support/security/security-advisories/sa-003/">SA-003</a> for their <em>NPCT65x</em> TPM chip. </li>
<li>Lenovo published security advisory <a href="https://support.lenovo.com/us/en/product_security/LEN-118320">LEN-118320</a> regarding affected products using said Nuvoton TPM.</li>
</ul>
<p>Check the website of your computer manufacturer for TPM firmware updates.</p>
<h2>Technical details</h2>
<h3>A primer on TPM encrypted parameters</h3>
<p>As described in the <a href="https://trustedcomputinggroup.org/wp-content/uploads/TCG_TPM2_r1p59_Part1_Architecture_pub.pdf">Trusted Platform Module Library Specification, Family 2.0, Part 1: Architecture</a> document, Section 21 - &#34;<em>Session-based encryption</em>&#34;, several TPM 2.0 commands have parameters that may need to be encrypted going to or from the TPM. Session-based encryption may be used to ensure confidentiality of these parameters. Quoting the specification:</p>
<div><pre><span></span><code>Not all commands support parameter encryption. If session-based encryption is allowed, only the first
parameter in the parameter area of a request or response may be encrypted. That parameter must have
an explicit size field. Only the data portion of the parameter is encrypted. The TPM should support
session-based encryption using XOR obfuscation. Support for a block cipher using CFB mode is platform
specific. These two encryption methods (XOR and CFB) do not require that the data be padded for
encryption, so the encrypted data size and the plain-text data size is the same.

[...]

Session-based encryption uses the algorithm parameters established when the session is started and
values that are derived from the session-specific sessionKey.

[...]

If sessionAttributes.decrypt is SET in a session in a command, and the first parameter of the command is
a sized buffer, then that parameter is encrypted using the encryption parameters of the session.
</code></pre></div>

<p>A TPM 2.0 command with encrypted parameters is composed of a base command header, followed by a <code>handleArea</code>, then a <code>sessionArea</code>, finishing with the (encrypted) <code>parameterArea</code>. The following diagram illustrates said structure:</p>
<div><pre><span></span><code><span>+---------------------+</span><span></span>
<span>|                     |</span>
<span>|                     |</span>
<span>| Base command header |</span>
<span>|                     |</span>
<span>|                     |</span>
<span>+---------------------+</span><span></span>
<span>|                     |</span>
<span>|     handleArea      |</span>
<span>|                     |</span>
<span>+---------------------+</span><span></span>
<span>|                     |</span>
<span>|    sessionArea      |</span>
<span>|                     |</span>
<span>+---------------------+</span><span></span>
<span>|                     |</span>
<span>|   parameterArea     |</span>
<span>|                     |</span>
<span>+---------------------+</span><span></span>
</code></pre></div>

<p>In the TPM 2.0 reference implementation, the <code>ExecuteCommand</code> function in <code>ExecCommand.c</code>  checks that the <code>authorizationSize</code> field of the <code>sessionArea</code> is at least <code>9</code> ([1]). After that, at [2], it calculates the start of the <code>parameterArea</code> (located right after the <code>sessionArea</code>) and saves it to the <code>parmBufferStart</code> variable. At <code>[3]</code> it calculates the size of the <code>parameterArea</code>, and saves it to the <code>parmBufferSize</code> variable. Then it calls <code>ParseSessionBuffer()</code> ([3]), passing  <code>parmBufferStart</code> and <code>parmBufferSize</code> as parameters ([5], [6]).</p>
<div><pre><span></span><code><span>//           ExecuteCommand()</span>
<span>//</span>
<span>//     The function performs the following steps.</span>
<span>//     a) Parses the command header from input buffer.</span>
<span>//     b) Calls ParseHandleBuffer() to parse the handle area of the command.</span>
<span>//     c) Validates that each of the handles references a loaded entity.</span>
<span>//</span>
<span>//     d) Calls ParseSessionBuffer() () to:</span>
<span>//          1) unmarshal and parse the session area;</span>
<span>//          2) check the authorizations; and</span>
<span>//          3) when necessary, decrypt a parameter.</span>

<span>       </span><span>[...]</span><span></span>

<span>LIB_EXPORT</span><span> </span><span>void</span><span></span>
<span>ExecuteCommand</span><span>(</span><span></span>
<span>    </span><span>unsigned</span><span>    </span><span>int</span><span>      </span><span>requestSize</span><span>,</span><span>       </span><span>//   IN: command buffer size</span>
<span>    </span><span>unsigned</span><span>    </span><span>char</span><span>    </span><span>*</span><span>request</span><span>,</span><span>           </span><span>//   IN: command buffer</span>
<span>    </span><span>unsigned</span><span>    </span><span>int</span><span>     </span><span>*</span><span>responseSize</span><span>,</span><span>      </span><span>//   OUT: response buffer size</span>
<span>    </span><span>unsigned</span><span>    </span><span>char</span><span>    </span><span>**</span><span>response</span><span>          </span><span>//   OUT: response buffer</span>
<span>    </span><span>)</span><span></span>
<span>{</span><span></span>
<span>        </span><span>[...]</span><span></span>
<span>        </span><span>// Find out session buffer size.</span>
<span>        </span><span>result</span><span> </span><span>=</span><span> </span><span>UINT32_Unmarshal</span><span>(</span><span>&amp;</span><span>authorizationSize</span><span>,</span><span> </span><span>&amp;</span><span>buffer</span><span>,</span><span> </span><span>&amp;</span><span>size</span><span>);</span><span></span>
<span>        </span><span>if</span><span>(</span><span>result</span><span> </span><span>!=</span><span> </span><span>TPM_RC_SUCCESS</span><span>)</span><span></span>
<span>            </span><span>goto</span><span> </span><span>Cleanup</span><span>;</span><span></span>
<span>        </span><span>// Perform sanity check on the unmarshaled    value. If it is smaller than</span>
<span>        </span><span>// the smallest possible session or larger    than the remaining size of</span>
<span>        </span><span>// the command, then it is an error. NOTE:    This check could pass but the</span>
<span>        </span><span>// session size could still be wrong. That    will be determined after the</span>
<span>        </span><span>// sessions are unmarshaled.</span>
<span>[</span><span>1</span><span>]</span><span>     </span><span>if</span><span>(</span><span>    </span><span>authorizationSize</span><span> </span><span>&lt;</span><span> </span><span>9</span><span></span>
<span>            </span><span>||</span><span> </span><span>authorizationSize</span><span> </span><span>&gt;</span><span> </span><span>(</span><span>UINT32</span><span>)</span><span> </span><span>size</span><span>)</span><span></span>
<span>        </span><span>{</span><span></span>
<span>             </span><span>result</span><span> </span><span>=</span><span> </span><span>TPM_RC_SIZE</span><span>;</span><span></span>
<span>             </span><span>goto</span><span> </span><span>Cleanup</span><span>;</span><span></span>
<span>        </span><span>}</span><span></span>
<span>        </span><span>// The sessions, if any, follows authorizationSize.</span>
<span>        </span><span>sessionBufferStart</span><span> </span><span>=</span><span> </span><span>buffer</span><span>;</span><span></span>
<span>        </span><span>// The parameters follow the session area.</span>
<span>[</span><span>2</span><span>]</span><span>     </span><span>parmBufferStart</span><span> </span><span>=</span><span> </span><span>sessionBufferStart</span><span> </span><span>+</span><span> </span><span>authorizationSize</span><span>;</span><span></span>
<span>        </span><span>// Any data left over after removing the authorization sessions is</span>
<span>        </span><span>// parameter data. If the command does not have parameters, then an</span>
<span>        </span><span>// error will be returned if the remaining size is not zero. This is</span>
<span>        </span><span>// checked later.</span>
<span>[</span><span>3</span><span>]</span><span>     </span><span>parmBufferSize</span><span> </span><span>=</span><span> </span><span>size</span><span> </span><span>-</span><span> </span><span>authorizationSize</span><span>;</span><span></span>
<span>        </span><span>// The actions of ParseSessionBuffer() are described in the introduction.</span>
<span>[</span><span>4</span><span>]</span><span>     </span><span>result</span><span> </span><span>=</span><span> </span><span>ParseSessionBuffer</span><span>(</span><span>commandCode</span><span>,</span><span></span>
<span>                                    </span><span>handleNum</span><span>,</span><span></span>
<span>                                    </span><span>handles</span><span>,</span><span></span>
<span>                                    </span><span>sessionBufferStart</span><span>,</span><span></span>
<span>                                    </span><span>authorizationSize</span><span>,</span><span></span>
<span>[</span><span>5</span><span>]</span><span>                                 </span><span>parmBufferStart</span><span>,</span><span></span>
<span>[</span><span>6</span><span>]</span><span>                                 </span><span>parmBufferSize</span><span>);</span><span></span>
<span>        </span><span>[...]</span><span></span>
</code></pre></div>

<p>Function <code>ParseSessionBuffer</code> in <code>SessionProcess.c</code> parses the <code>sessionArea</code> of the command. If a session has the <code>Decrypt</code> attribute set ([1]), and if the command code allows for parameter encryption, then <code>ParseSessionBuffer</code> calls <code>CryptParameterDecryption()</code> ([2]), propagating the <code>parmBufferSize</code> ([3]) and <code>parmBufferStart</code> ([4]) parameters:</p>
<div><pre><span></span><code><span>//           ParseSessionBuffer()</span>
<span>//</span>
<span>//       This function is the entry function for command session processing. It iterates sessions in session area</span>
<span>//       and reports if the required authorization has been properly provided. It also processes audit session and</span>
<span>//       passes the information of encryption sessions to parameter encryption module.</span>
<span>//</span>
<span>//       Error Returns                   Meaning</span>
<span>//</span>
<span>//       various                         parsing failure or authorization failure</span>
<span>//</span>
<span>TPM_RC</span><span></span>
<span>ParseSessionBuffer</span><span>(</span><span></span>
<span>    </span><span>TPM_CC</span><span>              </span><span>commandCode</span><span>,</span><span>                    </span><span>//   IN:   Command code</span>
<span>    </span><span>UINT32</span><span>              </span><span>handleNum</span><span>,</span><span>                      </span><span>//   IN:   number of element in handle array</span>
<span>    </span><span>TPM_HANDLE</span><span>          </span><span>handles</span><span>[],</span><span>                      </span><span>//   IN:   array of handle</span>
<span>    </span><span>BYTE</span><span>               </span><span>*</span><span>sessionBufferStart</span><span>,</span><span>             </span><span>//   IN:   start of session buffer</span>
<span>    </span><span>UINT32</span><span>              </span><span>sessionBufferSize</span><span>,</span><span>              </span><span>//   IN:   size of session buffer</span>
<span>    </span><span>BYTE</span><span>               </span><span>*</span><span>parmBufferStart</span><span>,</span><span>                </span><span>//   IN:   start of parameter buffer</span>
<span>    </span><span>UINT32</span><span>              </span><span>parmBufferSize</span><span>                  </span><span>//   IN:   size of parameter buffer</span>
<span>    </span><span>)</span><span></span>
<span>{</span><span></span>
<span>        </span><span>[...]</span><span></span>
<span>        </span><span>// Decrypt the first parameter if applicable. This should be the last operation</span>
<span>        </span><span>// in session processing.</span>
<span>        </span><span>// If the encrypt session is associated with a handle and the handle&#39;s</span>
<span>        </span><span>// authValue is available, then authValue is concatenated with sessionAuth to</span>
<span>        </span><span>// generate encryption key, no matter if the handle is the session bound entity</span>
<span>        </span><span>// or not.</span>
<span>[</span><span>1</span><span>]</span><span>     </span><span>if</span><span>(</span><span>s_decryptSessionIndex</span><span> </span><span>!=</span><span> </span><span>UNDEFINED_INDEX</span><span>)</span><span></span>
<span>        </span><span>{</span><span></span>
<span>           </span><span>// Get size of the leading size field in decrypt parameter</span>
<span>           </span><span>if</span><span>(</span><span>    </span><span>s_associatedHandles</span><span>[</span><span>s_decryptSessionIndex</span><span>]</span><span> </span><span>!=</span><span> </span><span>TPM_RH_UNASSIGNED</span><span></span>
<span>               </span><span>&amp;&amp;</span><span> </span><span>IsAuthValueAvailable</span><span>(</span><span>s_associatedHandles</span><span>[</span><span>s_decryptSessionIndex</span><span>],</span><span></span>
<span>                                       </span><span>commandCode</span><span>,</span><span></span>
<span>                                       </span><span>s_decryptSessionIndex</span><span>)</span><span></span>
<span>             </span><span>)</span><span></span>
<span>           </span><span>{</span><span></span>
<span>                </span><span>extraKey</span><span>.</span><span>b</span><span>.</span><span>size</span><span>=</span><span></span>
<span>                    </span><span>EntityGetAuthValue</span><span>(</span><span>s_associatedHandles</span><span>[</span><span>s_decryptSessionIndex</span><span>],</span><span></span>
<span>                                       </span><span>&amp;</span><span>extraKey</span><span>.</span><span>t</span><span>.</span><span>buffer</span><span>);</span><span></span>
<span>           </span><span>}</span><span></span>
<span>           </span><span>else</span><span></span>
<span>           </span><span>{</span><span></span>
<span>                </span><span>extraKey</span><span>.</span><span>b</span><span>.</span><span>size</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span><span></span>
<span>           </span><span>}</span><span></span>
<span>           </span><span>size</span><span> </span><span>=</span><span> </span><span>DecryptSize</span><span>(</span><span>commandCode</span><span>);</span><span></span>
<span>[</span><span>2</span><span>]</span><span>        </span><span>result</span><span> </span><span>=</span><span> </span><span>CryptParameterDecryption</span><span>(</span><span></span>
<span>                         </span><span>s_sessionHandles</span><span>[</span><span>s_decryptSessionIndex</span><span>],</span><span></span>
<span>                         </span><span>&amp;</span><span>s_nonceCaller</span><span>[</span><span>s_decryptSessionIndex</span><span>].</span><span>b</span><span>,</span><span></span>
<span>[</span><span>3</span><span>]</span><span>                      </span><span>parmBufferSize</span><span>,</span><span> </span><span>(</span><span>UINT16</span><span>)</span><span>size</span><span>,</span><span></span>
<span>                         </span><span>&amp;</span><span>extraKey</span><span>,</span><span></span>
<span>[</span><span>4</span><span>]</span><span>                      </span><span>parmBufferStart</span><span>);</span><span></span>
</code></pre></div>

<h3>Vulnerabilities in the CryptParameterDecryption function</h3>
<p>Function <code>CryptParameterDecryption</code> in <code>CryptUtil.c</code> performs in-place decryption of an encrypted command parameter.</p>
<div><pre><span></span><code><span>//       10.2.9.9   CryptParameterDecryption()</span>
<span>//</span>
<span>//       This function does in-place decryption of a command parameter.</span>
<span>//</span>
<span>//       Error Returns                  Meaning</span>
<span>//</span>
<span>//       TPM_RC_SIZE                    The number of bytes in the input buffer is less than the number of</span>
<span>//                                      bytes to be decrypted.</span>
<span>//</span>
<span>TPM_RC</span><span></span>
<span>CryptParameterDecryption</span><span>(</span><span></span>
<span>   </span><span>TPM_HANDLE</span><span>          </span><span>handle</span><span>,</span><span>                 </span><span>//   IN: encrypted session handle</span>
<span>   </span><span>TPM2B</span><span>              </span><span>*</span><span>nonceCaller</span><span>,</span><span>            </span><span>//   IN: nonce caller</span>
<span>   </span><span>UINT32</span><span>              </span><span>bufferSize</span><span>,</span><span>             </span><span>//   IN: size of parameter buffer</span>
<span>   </span><span>UINT16</span><span>              </span><span>leadingSizeInByte</span><span>,</span><span>      </span><span>//   IN: the size of the leading size field in</span>
<span>                                               </span><span>//       byte</span>
<span>   </span><span>TPM2B_AUTH</span><span>         </span><span>*</span><span>extraKey</span><span>,</span><span>               </span><span>//   IN: the authValue</span>
<span>   </span><span>BYTE</span><span>               </span><span>*</span><span>buffer</span><span>                  </span><span>//   IN/OUT: parameter buffer to be decrypted</span>
<span>   </span><span>)</span><span></span>
<span>{</span><span></span>
<span>   </span><span>SESSION</span><span>         </span><span>*</span><span>session</span><span> </span><span>=</span><span> </span><span>SessionGet</span><span>(</span><span>handle</span><span>);</span><span> </span><span>// encrypt session</span>
<span>   </span><span>// The HMAC key is going to be the concatenation of the session key and any</span>
<span>   </span><span>// additional key material (like the authValue). The size of both of these</span>
<span>   </span><span>// is the size of the buffer which can contain a TPMT_HA.</span>
<span>   </span><span>TPM2B_TYPE</span><span>(</span><span>HMAC_KEY</span><span>,</span><span> </span><span>(</span><span> </span><span>sizeof</span><span>(</span><span>extraKey</span><span>-&gt;</span><span>t</span><span>.</span><span>buffer</span><span>)</span><span></span>
<span>                         </span><span>+</span><span> </span><span>sizeof</span><span>(</span><span>session</span><span>-&gt;</span><span>sessionKey</span><span>.</span><span>t</span><span>.</span><span>buffer</span><span>)));</span><span></span>
<span>   </span><span>TPM2B_HMAC_KEY</span><span>          </span><span>key</span><span>;</span><span>            </span><span>// decryption key</span>
<span>   </span><span>UINT32</span><span>                  </span><span>cipherSize</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span><span> </span><span>// size of cipher text</span>
<span>   </span><span>pAssert</span><span>(</span><span>session</span><span>-&gt;</span><span>sessionKey</span><span>.</span><span>t</span><span>.</span><span>size</span><span> </span><span>+</span><span> </span><span>extraKey</span><span>-&gt;</span><span>t</span><span>.</span><span>size</span><span> </span><span>&lt;=</span><span> </span><span>sizeof</span><span>(</span><span>key</span><span>.</span><span>t</span><span>.</span><span>buffer</span><span>));</span><span></span>
<span>   </span><span>// Retrieve encrypted data size.</span>
<span>   </span><span>if</span><span>(</span><span>leadingSizeInByte</span><span> </span><span>==</span><span> </span><span>2</span><span>)</span><span></span>
<span>   </span><span>{</span><span></span>
<span>       </span><span>// The first two bytes of the buffer are the size of the</span>
<span>       </span><span>// data to be decrypted</span>
<span>[</span><span>1</span><span>]</span><span>    </span><span>cipherSize</span><span> </span><span>=</span><span> </span><span>(</span><span>UINT32</span><span>)</span><span>BYTE_ARRAY_TO_UINT16</span><span>(</span><span>buffer</span><span>);</span><span></span>
<span>[</span><span>2</span><span>]</span><span>    </span><span>buffer</span><span> </span><span>=</span><span> </span><span>&amp;</span><span>buffer</span><span>[</span><span>2</span><span>];</span><span>    </span><span>// advance the buffer</span>
<span>   </span><span>}</span><span></span>
<span>#ifdef TPM4B</span>
<span>   </span><span>else</span><span> </span><span>if</span><span>(</span><span>leadingSizeInByte</span><span> </span><span>==</span><span> </span><span>4</span><span>)</span><span></span>
<span>   </span><span>{</span><span></span>
<span>       </span><span>// the leading size is four bytes so get the four byte size field</span>
<span>       </span><span>cipherSize</span><span> </span><span>=</span><span> </span><span>BYTE_ARRAY_TO_UINT32</span><span>(</span><span>buffer</span><span>);</span><span></span>
<span>       </span><span>buffer</span><span> </span><span>=</span><span> </span><span>&amp;</span><span>buffer</span><span>[</span><span>4</span><span>];</span><span>    </span><span>//advance pointer</span>
<span>   </span><span>}</span><span></span>
<span>#endif</span>
<span>   </span><span>else</span><span></span>
<span>   </span><span>{</span><span></span>
<span>       </span><span>pAssert</span><span>(</span><span>FALSE</span><span>);</span><span></span>
<span>   </span><span>}</span><span></span>
<span>[</span><span>3</span><span>]</span><span> </span><span>if</span><span>(</span><span>cipherSize</span><span> </span><span>&gt;</span><span> </span><span>bufferSize</span><span>)</span><span></span>
<span>       </span><span>return</span><span> </span><span>TPM_RC_SIZE</span><span>;</span><span></span>
<span>   </span><span>// Compute decryption key by concatenating sessionAuth with extra input key</span>
<span>   </span><span>MemoryCopy2B</span><span>(</span><span>&amp;</span><span>key</span><span>.</span><span>b</span><span>,</span><span> </span><span>&amp;</span><span>session</span><span>-&gt;</span><span>sessionKey</span><span>.</span><span>b</span><span>,</span><span> </span><span>sizeof</span><span>(</span><span>key</span><span>.</span><span>t</span><span>.</span><span>buffer</span><span>));</span><span></span>
<span>   </span><span>MemoryConcat2B</span><span>(</span><span>&amp;</span><span>key</span><span>.</span><span>b</span><span>,</span><span> </span><span>&amp;</span><span>extraKey</span><span>-&gt;</span><span>b</span><span>,</span><span> </span><span>sizeof</span><span>(</span><span>key</span><span>.</span><span>t</span><span>.</span><span>buffer</span><span>));</span><span></span>
<span>   </span><span>if</span><span>(</span><span>session</span><span>-&gt;</span><span>symmetric</span><span>.</span><span>algorithm</span><span> </span><span>==</span><span> </span><span>TPM_ALG_XOR</span><span>)</span><span></span>
<span>       </span><span>// XOR parameter decryption formulation:</span>
<span>       </span><span>//    XOR(parameter, hash, sessionAuth, nonceNewer, nonceOlder)</span>
<span>       </span><span>// Call XOR obfuscation function</span>
<span>[</span><span>4</span><span>]</span><span>    </span><span>CryptXORObfuscation</span><span>(</span><span>session</span><span>-&gt;</span><span>authHashAlg</span><span>,</span><span> </span><span>&amp;</span><span>key</span><span>.</span><span>b</span><span>,</span><span> </span><span>nonceCaller</span><span>,</span><span></span>
<span>                                  </span><span>&amp;</span><span>(</span><span>session</span><span>-&gt;</span><span>nonceTPM</span><span>.</span><span>b</span><span>),</span><span> </span><span>cipherSize</span><span>,</span><span> </span><span>buffer</span><span>);</span><span></span>
<span>   </span><span>else</span><span></span>
<span>       </span><span>// Assume that it is one of the symmetric block ciphers.</span>
<span>[</span><span>5</span><span>]</span><span>    </span><span>ParmDecryptSym</span><span>(</span><span>session</span><span>-&gt;</span><span>symmetric</span><span>.</span><span>algorithm</span><span>,</span><span> </span><span>session</span><span>-&gt;</span><span>authHashAlg</span><span>,</span><span></span>
<span>                             </span><span>session</span><span>-&gt;</span><span>symmetric</span><span>.</span><span>keyBits</span><span>.</span><span>sym</span><span>,</span><span></span>
<span>                             </span><span>&amp;</span><span>key</span><span>.</span><span>b</span><span>,</span><span> </span><span>nonceCaller</span><span>,</span><span> </span><span>&amp;</span><span>session</span><span>-&gt;</span><span>nonceTPM</span><span>.</span><span>b</span><span>,</span><span></span>
<span>                             </span><span>cipherSize</span><span>,</span><span> </span><span>buffer</span><span>);</span><span></span>
<span>   </span><span>return</span><span> </span><span>TPM_RC_SUCCESS</span><span>;</span><span></span>
<span>}</span><span></span>
</code></pre></div>

<p><strong>Two security issues arise in this function</strong>:</p>
<ul>
<li><strong>Bug #1 - OOB read</strong> (<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-1018">CVE-2023-1018</a>): At [1], the function uses the <code>BYTE_ARRAY_TO_UINT16</code> macro to read a 16-bit field (<code>cipherSize</code>) from the buffer pointed by <code>parmBufferStart</code> without checking if there&#39;s any parameter data past the session area. The only length check was performed earlier in function <code>ExecuteCommand</code>, but that check only verified that the <code>sessionArea</code> of the command is at least 9 bytes in size. As a result, if a malformed command doesn&#39;t contain a <code>parameterArea</code> past the <code>sessionArea</code>, it will trigger an <strong>out-of-bounds memory read</strong>, making the TPM access memory past the end of the command.</li>
</ul>
<p>Note that the <code>BYTE_ARRAY_TO_UINT16</code> macro doesn&#39;t perform any bounds check:</p>
<div><pre><span></span><code><span>#define BYTE_ARRAY_TO_UINT16(b)         (UINT16)( ((b)[0] &lt;&lt; 8) \</span>
<span>                                                + (b)[1])</span>
</code></pre></div>

<p>The <code>UINT16_Unmarshal</code> function should have been used instead, which performs proper size checks before reading from a given buffer.</p>
<ul>
<li><strong>Bug #2 - OOB write</strong> (<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-1017">CVE-2023-1017</a>): If a proper <code>parameterArea</code> is provided (avoiding bug #1), the first two bytes of the <code>parameterArea</code> are interpreted as the size of the data to be decrypted (<code>cipherSize</code> variable at [1]). Right after reading <code>cipherSize</code>, at [2], the <code>buffer</code> pointer is advanced by 2. At [3] there&#39;s a sanity check (if the <code>cipherSize</code> value is greater than the actual buffer size, then it bails out), but there&#39;s a problem here: after reading the <code>cipherSize</code> 16-bit field and advancing the <code>buffer</code> pointer by 2, the function forgets to subtract 2 from <code>bufferSize</code>, to account for the two bytes that were already processed. Therefore, it is possible to successfully pass the sanity check at [3] with a <code>cipherSize</code> value that is, in fact, larger by 2 than the actual size of the remaining data. As a consequence, when either <code>CryptXORObfuscation()</code> or <code>ParmDecryptSym()</code> functions are called (at [4] and [5], respectively) to actually decrypt the data in the <code>parameterArea</code> following the <code>cipherSize</code> field, the TPM ends up writing 2 bytes past the end of the buffer, resulting in an <strong>out-of-bounds write</strong>.</li>
</ul>
<p>An OOB write of just 2 bytes may not seem like a very powerful primitive at first, but remember that last year our colleagues Damiano Melotti and Maxime Rossi Bellom managed to <a href="https://blog.quarkslab.com/attacking-titan-m-with-only-one-byte.html">obtain code execution on Google&#39;s Titan M chip</a> with an OOB write of a single byte with value <code>0x01</code>.</p>
<h2>Impact</h2>
<p>1) OOB read: function <code>CryptParameterDecryption</code> in <code>CryptUtil.c</code> can read 2 bytes past the end of the received TPM command. If an affected TPM doesn&#39;t zero out the command buffer between received commands, it can result in the affected function reading whatever 16-bit value was already there from the previous command. This is dependent on the implementation: for example, VMware doesn&#39;t clear out the command buffer between requests, so the OOB read can access whatever value is already there from the previous command; on the contrary, Hyper-V&#39;s virtual TPM pads the unused bytes in the command buffer with zeros every time it receives a request, so the OOB access ends up reading just zeros.</p>
<p>2) OOB write: functions <code>CryptXORObfuscation</code>/<code>ParmDecryptSym</code> in <code>CryptUtil.c</code> (called from <code>CryptParameterDecryption</code>) can write 2 bytes past the end of the command buffer, resulting in memory corruption.</p>
<p>This second bug is definitely the most interesting one. The chances of being able to overwrite something useful depend on how each implementation allocates the buffer that receives TPM commands. As an example:</p>
<ul>
<li>VMware uses an oversized buffer of size 0x10000, way bigger than the usual maximum TPM command size of 0x1000 bytes;</li>
<li>Hyper-V uses a static variable of size 0x1000 as the command buffer;</li>
<li>SWTPM uses <code>malloc()</code> to allocate a command buffer of size 0x1008 (8 bytes for a <code>send command prefix</code> that can be used to modify the <code>locality</code>, plus 0x1000 bytes for the maximum TPM command size).</li>
</ul>
<p>Therefore, the chances of having something useful adjacent to the command buffer that we can overwrite with the OOB write are really implementation-dependent. All the three virtual TPMs mentioned above use a completely different approach for allocating the command buffer. In a similar way, the likeliness of having something useful to overwrite located right after the command buffer in the firmware of a given hardware TPM depends entirely on how that specific hardware vendor allocates the buffer that holds incoming commands.</p>
<h2>Triggering the bugs</h2>
<p>In order to reproduce any of the 2 bugs described above, it is necessary to send 2 commands to the target TPM. In both cases, the first command must be a <code>TPM2_StartAuthSession</code> command, to start an authorization session. For simplicity, we can specify <code>TPM_ALG_XOR</code> as the symmetric algorithm to be used. As a result, we get a TPM response containing a <em>session handle</em>.</p>
<p>After that, we need to send a command that supports parameter encryption. We used <code>TPM2_CreatePrimary</code>, although a few other commands should probably work as well. We pass the <em>session handle</em> obtained in the previous step in the <code>sessionArea</code> of the <code>TPM2_CreatePrimary</code> command, and we set the <code>Decrypt</code> flag in the <code>sessionAttributes</code> field. Then:</p>
<ul>
<li>To reproduce bug #1 (OOB read), we send the <code>TPM2_CreatePrimary</code> command with a minimal valid <code>sessionArea</code>, and no data after it, i.e. with a missing <code>parameterArea</code>.</li>
<li>To reproduce bug #2 (OOB write), we send the <code>TPM2_CreatePrimary</code> command with its total size equal to the maximum supported TPM command size (<code>0x1000</code> bytes). In this case we do include a <code>parameterArea</code>, with the <code>cipherSize</code> field set to <code>0xfe5</code> (<code>0x1000 - sizeof(command_base_header) - sizeof(handleArea) - sizeof(sessionArea)</code>), followed by <code>0xfe3</code> bytes with any value (filling the place of the encrypted parameter) to complete the <code>0x1000</code> bytes of the whole <code>TPM2_CreatePrimary</code> command.</li>
</ul>
<h2>Proof-of-Concept</h2>
<p>You can <a href="https://blog.quarkslab.com/resources/2022-12-05_tpm_vulns/tpm-vulns-poc.zip">download here</a> a Proof-of-Concept to reproduce both vulnerabilities. The <code>.zip</code> file contains a Python version of the PoC, meant to be run on Linux systems, and a C version in case you intend to run it from a Windows machine.</p>
<h2>Conclusions</h2>
<p>We discovered two security issues in the code of the TPM 2.0 reference implementation: an out-of-bounds read and an out-of-bounds write. As a result, every TPM (either software or hardware implementations) whose firmware is based on the reference code published by the Trusted Computing Group is expected to be affected.</p>
<p>Interestingly, although all affected TPMs share the exact same vulnerable function, which stems from the reference implementation code, the likeliness of successful exploitation depends on how the command buffer is implemented, and that part is left to each implementation. From what we saw, everyone seems to handle it in a different way: some clear out the command buffer between received requests, but others don&#39;t; some allocate the command buffer in the heap via <code>malloc()</code>, while others use a global variable for it.</p>
<p>We were able to verify that these vulnerabilities are present in the software TPMs included in major desktop virtualization solutions such as VMware Workstation, Microsoft Hyper-V and Qemu. Virtual TPMs available in the biggest cloud computing providers were also likely affected. For instance, Google Cloud uses code published by IBM automatically extracted from the TCG reference implementation, and we verified that the bugs were present in the code provided by IBM. In the case of Microsoft Azure, we already mentioned that Hyper-V on Windows 10 is affected, and since the Azure hypervisor is based on Hyper-V, we expect these two vulnerabilities to be present on Microsoft&#39;s cloud platform as well.</p>
<p>Finally, we expect most TPM hardware vendors to be affected too. The lack of a debugging setup to get visibility on what&#39;s going on in the TPM firmware at runtime makes it harder to confirm the presence of the vulnerabilities in a physical chip. Static analysis could be an alternative to assess whether a hardware TPM is vulnerable or not, but in the few TPM firmware updates we managed to get our hands on were encrypted.</p>
<h2>Acknowledgments</h2>
<p>I&#39;d like to thank IvÃ¡n Arce, for the lot of valuable inputs and ideas he provided while discussing these bugs, as well as for taking care of handling such a complicated disclosure process with so many parties involved.</p>
<h2>Disclosure timeline</h2>
<p>This timeline is not exhaustive and only lists events that we deemed relevant to the disclosure process.</p>
<ul>
<li><strong>2022-11-24</strong> Quarkslab sent the vulnerability report to VMWare.</li>
<li><strong>2022-11-24</strong> Quarkslab sent the vulnerability report and PoC to Microsoft.</li>
<li><strong>2022-11-24</strong> VMWare acknowledged the report.</li>
<li><strong>2022-11-25</strong> Quarkslab notified CERT/CC of vulns in TCG TPM2 reference implementation, and opened a case in the VINCE portal. The vulnerabilities are tracked as VU#782720.1 and VU#782720.2.</li>
<li><strong>2022-11-28</strong> Quarkslab notified CERT-FR of vulns in TCG TPM2 reference implementation.</li>
<li><strong>2022-11-28</strong> CERT-FR, CERT/CC and Google acknowledged the report.</li>
<li><strong>2022-11-28</strong> Quarkslab filed the vulnerability report in Google&#39;s security issue tracker stating that since their virtual TPM (vTPM) for Google Cloud Platform Shielded VMs <a href="https://cloud.google.com/blog/products/identity-security/virtual-trusted-platform-module-for-shielded-vms-security-in-plaintext">uses the reference implementation</a>, it is likely vulnerable.</li>
<li><strong>2022-11-28</strong> CERT/CC asked if a date is set for disclosure of the bugs.</li>
<li><strong>2022-11-28</strong> Quarkslab informed CERT/CC, VMWare and Google that the disclosure date was set to February 28th, 2023.</li>
<li><strong>2022-11-28</strong> Google requested a Proof-of-Concept program for Linux.</li>
<li><strong>2022-11-28</strong> Quarkslab sent Linux PoC to Google.</li>
<li><strong>2022-11-29</strong> Quarkslab sent the vulnerability report to STMicroelectronics, an automated acknowledgement was received.</li>
<li><strong>2022-11-29</strong> CERT/CC communicated to all vendors that it reserved two CVE IDs to identify the vulnerabilities.</li>
<li><strong>2022-11-29</strong> Google asked if the report was sent to the Trusted Computing Group and if the vulnerability is under a coordinated embargo, as it wanted to push a fix to public code and executables.</li>
<li><strong>2022-11-29</strong> Microsoft told Quarkslab that the report met their criteria for security servicing.</li>
<li><strong>2022-11-29</strong> Quarkslab told Google that the disclosure date was set to February 28th, 2023 to let other vendors work on fixes, as it is likely that vendors of TPM hardware will require more time to release fixed firmware, that CERT/CC has contacted the TCG and to discuss disclosure with other vendor on CERT&#39;s VINCE portal.  </li>
<li><strong>2022-11-29</strong> Cisco indicated that it started tracking the report internally.</li>
<li><strong>2022-12-02</strong> Quarkslab noticed that more than 1600 vendors (up from 43 the prior day) had access to the vulnerability report on the VINCE portal and asked CERT/CC if it was a mistake or as intended.</li>
<li><strong>2022-12-02</strong> CERT/CC clarified that expanding access to all registered vendors was as intended because several PC OEM and hardware vendors expressed interest in reaching out to other vendors up and down their supply chain.</li>
<li><strong>2022-12-02</strong> Quarkslab told CERT/CC that the probability of information about the vulnerabilities being leaked is now considered significantly higher, and they should make preparations for that scenario.</li>
<li><strong>2022-12-02</strong> Aruba Networks asked if there was a PoC program for Linux, Quarkslab provided all parties with a PoC in Python that uses <code>/dev/tpm0</code> to communicate with the TPM.</li>
<li><strong>2022-12-02</strong> Intel indicated that it was investigating the report.</li>
<li><strong>2022-12-02</strong> Fujistu PSIRT asked if Quarkslab analyzed TPM chips, Quarkslab replied that hardware TPMs were not analyzed due to lack of debugging or monitoring capabilities to determine what is running inside of them to find out if the bugs are triggered.</li>
<li><strong>2022-12-04</strong> Nuvoton indicated that <em>current</em> versions of their TPM chip firmware are not affected.</li>
<li><strong>2022-12-05</strong> Trusted Computing Group VRT indicated that it was tracking the issue and coordinating triage with TPM Group co-chairs.</li>
<li><strong>2022-12-05</strong> SUSE Linux identified <code>libtpms</code> as affected and asked if the maintainers were notified.</li>
<li><strong>2022-12-05</strong> Quarkslab replied to SUSE Linux saying that it had not notified the <code>libtpms</code> maintainers and deferred to CERT/CC for coordination with them.</li>
<li><strong>2022-12-05</strong> CERT/CC indicated that it had notified the IBM security group, which owns the vulnerable code.</li>
<li><strong>2022-12-05</strong> Google notified Quarkslab that they&#39;ve shared the PoC internally, forwarded comments about disclosure to the appropriate team and were in contact with Trusted Computing Group and would coordinate with them as appropriate.</li>
<li><strong>2022-12-05</strong> Quarkslab asked Google if it had an estimated date for the rollout of fixes, and if it planned to issue fixes for the vTPM code in GCP only or also to any externally visible code.</li>
<li><strong>2022-12-05</strong> The TCG notified all vendors that their Vulnerability Response Team (VRT) was engaged on the issue and reached out to the TPM Group co-chairs for triaging the report and would provide actionable information when available.</li>
<li><strong>2022-12-05</strong> A CERT notified all parties that information about the vulnerabilities was publicly available on the issue tracker of a China-based Linux distribution.</li>
<li><strong>2022-12-06</strong> CERT/CC notified all parties that upon their request the China-based Linux distribution had removed public access to the issues leaking the vulnerabilities. The coordinated disclosure date remains February 28th, 2023 and CERT/CC reminded everyone not to disclosure the issues publicly and to communicate the private nature of the report to any third parties that may receive the information.</li>
<li><strong>2022-12-07</strong> Conference call between CERT/CC and Quarkslab to discuss how to proceed in light of the leak, both parties agree to not modify the planned disclosure date and try to speed up the vendor&#39;s processes to release fixes. CERT/CC requested permission to share the PoC programs with the US DHS CISA Threats team. Quarkslab granted permission.</li>
<li><strong>2022-12-07</strong> Microsoft asked Quarkslab for additional information to reproduce the bugs.</li>
<li><strong>2022-12-08</strong> CERT-JP said it had notified multiple vendors in Japan making them aware of the embargo date.</li>
<li><strong>2022-12-09</strong> Quarkslab provided a new version of the PoC programs for Linux and Windows on CERT/CC&#39;s VINCE portal.</li>
<li><strong>2022-12-12</strong> Quarkslab asked Google for an update and estimated date to release fixes.</li>
<li><strong>2022-12-13</strong> Crestron Electronics asked if an output of <code>DeviceIOControl error 87 (Invalid Parameter)</code> of the Windows PoC indicates that the TPM is not vulnerable. Quarkslab replied that the error message revealed a bug in the PoC(!) that will be fixed shortly, and that determining if a given TPM chip is vulnerable or not without any log or debugging capabilities is difficult and without source code access it is only possible to do it by reverse engineering firmware which is a very time-consuming effort.</li>
<li><strong>2022-12-13</strong> Siemens asked if the vulnerabilities were present in previous versions of TCG&#39;s TPM and if implementations of older versions are also affected. Quarkslab explained that the vulnerabilities were found in the code included in the TPM2.0 specification document and that they are present in all of IBM&#39;s <code>ibmswtpm2</code> TPM2.0 <a href="https://sourceforge.net/projects/ibmswtpm2/files/">reference implementation releases</a> dating back to at least March 21st, 2017. Therefore any implementation of TPM2.0 based on them is likely affected. Quarkslab did not check any TPM1.2 implementation.</li>
<li><strong>2022-12-14</strong> Infineon stated that Infineon TPM chips are NOT affected by the reported issues.</li>
<li><strong>2022-12-14</strong> Microsoft reiterated their request for additional information to reproduce the bugs.</li>
<li><strong>2022-12-16</strong> Quarkslab updated the PoC programs for Linux and Windows fixing a bug that prevented testing certain TPMs.</li>
<li><strong>2022-12-16</strong> Quarkslab asked Google for an update and answers to the questions sent previously on Dec. 5th and 12th. Also notified Google that it found out that a fix for the vulns we reported <a href="https://chromium.googlesource.com/chromiumos/third_party/tpm2/+/3b87ed233acb4c76c27872e1ac0b74dc032199f1">was committed to the Chromium OS TPM2 code</a> on December 1st, and that since the repository is publicly visible, Quarkslab considered knowledge about the existence of the bugs to be public now. Asked Google for their plan to roll out these fixes to supported devices.</li>
<li><strong>2022-12-16</strong> Quarkslab provided Microsoft a detailed description of how to debug the vTPM in Hyper-V to reproduce the bugs.</li>
<li><strong>2022-12-16</strong> Microsoft confirmed that it could reproduce the bugs. Quarkslab noted that they should coordinate disclosure with CERT/CC and the TCG.</li>
<li><strong>2022-12-18</strong> Google said they were with the proposed February 28, 2023 embargo date, and that were working with TCG and CERT to resolve the issue, and would get back with an answer to the remaining question as soon as they have one.</li>
<li><strong>2022-12-19</strong> Microsoft asked if it would be possible to coordinate disclosure for April 2023, to align with their security release of that month. Quarkslab replied that disclosure is being coordinated by CERT/CC, and that since other vendors are involved and a fix was already committed to a publicly available source code repository, it is more likely that the release of fixes and public disclosure will have to be accelerated rather than delayed. Suggested to discuss the matter with CERT/CC and other vendors.</li>
<li><strong>2022-12-23</strong> Quarkslab updated the PoC programs for Linux and Windows to query and print the manufacturer strings of the TPM implementation.</li>
<li><strong>2022-12-26</strong> Quarkslab updated the PoC programs for Linux and Windows to query and print the firmware version of the TPM implementation, also provided the output of a run of the PoC identifying a vulnerable chip.</li>
<li><strong>2023-01-03</strong> Google VRP informed that the bugs do not meet criteria for a reward, as they don&#39;t affect Google products but nonetheless passed the report to Chrome VRP for further evaluation.</li>
<li><strong>2023-01-05</strong> Google followed up indicating that while they consider the code changes to be public, they do not consider them to break embargo per discussion with CERT and TCG. Also that they cannot provide an answer to the question about their plan to roll out fixes to their devices.</li>
<li><strong>2023-01-09</strong> VMware asked if the disclosure date could be extended until the end of March or April.</li>
<li><strong>2023-01-16</strong> Quarkslab replied to VMware stating that the vulnerabilities should be considered public knowledge and the disclosure process involved multiple vendors as well as CERT and TCG, so it would be difficult to move it but they should discuss with them.</li>
<li><strong>2023-01-16</strong> Quarkslab asked Google VRP to clarify if the bugs are eligible because Google products aren&#39;t affected, are affected but not exploitable, or are in a third-party component. Noted that the fix committed in the Chromium OS repository seemed to indicate that at least one product was affected.</li>
<li><strong>2023-01-17</strong> Google replied that the issue was sent to the VRP panel for reconsideration.</li>
<li><strong>2023-01-17</strong> Chrome VRP informed that they were considering the issue. Gave access to the corresponding entry in their (separate) bug tracking system.</li>
<li><strong>2023-01-17</strong> Quarkslab gets access to the issue in the Chromium bug tracker. The entry, dated January 4th, indicated that the bugs were reported externally, were fixed, and their analysis deemed them not exploitable.</li>
<li><strong>2023-02-01</strong> STMicroelectronics reported that their products are not affected...</li>
<li><strong>2023-02-02</strong> Chrome VRP awards 20K USD for the bugs.</li>
<li><strong>2023-02-08</strong> Call with CERT to synchronize status and discuss further steps. Quarkslab agrees to publish technical details on March 14th, CERT and TCG will publish their security advisories and errata on February 28th.</li>
<li><strong>2023-02-15</strong> Microsoft informed that they will try to accelerate the release of the patches, and asked if they could preview the blog post to be published on March 14th.</li>
<li><strong>2023-02-15</strong> Quarkslab replied to Microsoft providing an updated PoC and agreed to send a draft of the blog post when it is ready.</li>
<li><strong>2023-02-28</strong> CERT/CC published their <a href="https://kb.cert.org/vuls/id/782720">vulnerability note</a>.</li>
<li><strong>2023-02-28</strong> Trusted Computing Group published their <a href="https://trustedcomputinggroup.org/wp-content/uploads/TCGVRT0007-Advisory-FINAL.pdf">security advisory</a> and <a href="https://trustedcomputinggroup.org/wp-content/uploads/TPM-2.0-Library-Spec-v1.59-Errata-v1.4_pub.pdf">errata</a>.</li>
<li><strong>2023-03-06</strong> Nuvoton published a <a href="https://www.nuvoton.com/support/security/security-advisories/sa-003/">security advisory</a>.</li>
<li><strong>2023-03-06</strong> Lenovo published a <a href="https://support.lenovo.com/us/en/product_security/LEN-118320">security advisory</a>.</li>
<li><strong>2023-03-06</strong> libtpms <a href="https://github.com/stefanberger/libtpms/commit/6e95c68503964d22d21704bdf99cd19dcb8748b1">added tests cases</a> for the vulnerabilities.</li>
<li><strong>2023-03-09</strong> Microsoft committed a <a href="https://github.com/microsoft/ms-tpm-20-ref/commit/9bdd9f0aaba5e54b3c314cfff02cf532281a067e">fix</a> to their open source reference implementation.</li>
<li><strong>2023-03-10</strong> Draft of the blog post sent to Microsoft.</li>
<li><strong>2023-03-13</strong> Microsoft replied with their impact assessment for Azure servers.</li>
<li><strong>2023-03-14</strong> This blog post is published.</li>
</ul>
</div></div>
  </body>
</html>
