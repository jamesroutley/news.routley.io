<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://sqlsync.dev/posts/stop-syncing-everything/">Original</a>
    <h1>Stop Syncing Everything</h1>
    
    <div id="readability-page-1" class="page"><div>  <a href="https://sqlsync.dev/" data-astro-prefetch="" data-astro-cid-egg7nqdx="true"> <svg width="1em" height="1em" data-astro-cid-egg7nqdx="true" data-icon="mdi:arrow-up-left">   <symbol id="ai:mdi:arrow-up-left" viewBox="0 0 24 24"><path fill="currentColor" d="M20 18v2h-6.5A6.5 6.5 0 0 1 7 13.5V7.83l-3.09 3.09L2.5 9.5L8 4l5.5 5.5l-1.41 1.41L9 7.83v5.67C9 16 11 18 13.5 18z"></path></symbol><use href="#ai:mdi:arrow-up-left"></use>  </svg> back
</a>  <section data-astro-cid-egg7nqdx="">  <nav data-astro-cid-egg7nqdx=""> <strong data-astro-cid-egg7nqdx="">Outline</strong> <ul data-astro-cid-egg7nqdx=""> <li data-astro-cid-egg7nqdx=""> <a href="#a-different-approach-to-edge-replication" aria-label="A different approach to edge replication" data-astro-prefetch="" data-astro-cid-egg7nqdx="true">A different approach to edge replication</a> </li><li data-astro-cid-egg7nqdx=""> <a href="#lazy-sync-at-your-own-pace" aria-label="Lazy: Sync at your own pace" data-astro-prefetch="" data-astro-cid-egg7nqdx="true">Lazy: Sync at your own pace</a> </li><li data-astro-cid-egg7nqdx=""> <a href="#partial-sync-only-whats-needed" aria-label="Partial: Sync only what’s needed" data-astro-prefetch="" data-astro-cid-egg7nqdx="true">Partial: Sync only what’s needed</a> </li><li data-astro-cid-egg7nqdx=""> <a href="#edge-sync-close-to-the-action" aria-label="Edge: Sync close to the action" data-astro-prefetch="" data-astro-cid-egg7nqdx="true">Edge: Sync close to the action</a> </li><li data-astro-cid-egg7nqdx=""> <a href="#consistency-sync-safely" aria-label="Consistency: Sync safely" data-astro-prefetch="" data-astro-cid-egg7nqdx="true">Consistency: Sync safely</a> </li><li data-astro-cid-egg7nqdx=""> <a href="#what-can-you-build-with-graft" aria-label="What can you build with Graft?" data-astro-prefetch="" data-astro-cid-egg7nqdx="true">What can you build with Graft?</a> </li><li data-astro-cid-egg7nqdx=""> <a href="#the-graft-sqlite-extension-libgraft" aria-label="The Graft SQLite Extension (libgraft)" data-astro-prefetch="" data-astro-cid-egg7nqdx="true">The Graft SQLite Extension (libgraft)</a> </li><li data-astro-cid-egg7nqdx=""> <a href="#how-to-get-involved" aria-label="How to get involved" data-astro-prefetch="" data-astro-cid-egg7nqdx="true">How to get involved</a> </li><li data-astro-cid-egg7nqdx=""> <a href="#appendix" aria-label="Appendix" data-astro-prefetch="" data-astro-cid-egg7nqdx="true">Appendix</a> </li><li data-astro-cid-egg7nqdx=""> <a href="#roadmap" aria-label="Roadmap" data-astro-prefetch="" data-astro-cid-egg7nqdx="true">Roadmap</a> </li><li data-astro-cid-egg7nqdx=""> <a href="#comparison-with-other-sqlite-replication-solutions" aria-label="Comparison with other SQLite replication solutions" data-astro-prefetch="" data-astro-cid-egg7nqdx="true">Comparison with other SQLite replication solutions</a> </li> </ul> </nav> </section> <p>Partial replication sounds easy—just sync the data your app needs, right? But choosing an approach is tricky: logical replication precisely tracks every change, complicating strong consistency, while physical replication avoids that complexity but requires syncing every change, even discarded ones. <strong>What if your app could combine the simplicity of physical replication with the efficiency of logical replication?</strong> That’s the key idea behind <strong><a href="https://github.com/orbitinghail/graft" data-astro-prefetch="">Graft</a></strong>, the open-source transactional storage engine I’m launching today. It’s designed specifically for lazy, partial replication with strong consistency, horizontal scalability, and object storage durability.</p>
<p>Graft is designed with the following <a href="#what-can-you-build-with-graft" data-astro-prefetch="">use cases</a> in mind:</p>
<ul>
<li><strong>Offline-first &amp; mobile apps</strong>: <a href="https://x.com/artman/status/1558081811040948230" data-astro-prefetch="">Simplify development</a> and improve reliability by offloading replication and storage to Graft.</li>
<li><strong>Cross-platform sync</strong>: Share data smoothly across devices, browsers, and platforms without vendor lock-in.</li>
<li><strong>Stateless multi-writer replicas</strong>: Deploy replicas anywhere, including serverless and embedded environments.</li>
<li><strong>Any data type</strong>: Replicate databases, files, or custom formats—all with strong consistency.</li>
</ul>
<p>I first discovered the need for Graft while building <a href="https://sqlsync.dev" data-astro-prefetch="">SQLSync</a>. SQLSync is a frontend optimized database stack built on top of <a href="https://www.sqlite.org/" data-astro-prefetch="">SQLite</a> with a synchronization engine powered by ideas from Git and distributed systems. SQLSync makes multiplayer SQLite databases a reality, powering interactive apps that run directly in your browser.</p>
<p>However, SQLSync replicates the entire log of changes to every client—similar to how some databases implement physical replication. While this approach works fine on servers, it’s poorly suited to the constraints of edge and browser environments.</p>
<p>After shipping SQLSync, I decided to find a replication solution more suited to the edge. I needed something that could:</p>
<ul>
<li>Let clients <strong>sync at their own pace</strong></li>
<li><strong>Sync only what they need</strong></li>
<li><strong>Sync from anywhere</strong>, including the edge and offline devices</li>
<li>Replicate <strong>arbitrary data</strong><sup><a href="#user-content-fn-any-data" data-astro-prefetch="" id="user-content-fnref-any-data" data-footnote-ref="" aria-describedby="footnote-label">1</a></sup></li>
<li>All while providing <strong>strong consistency guarantees</strong>.</li>
</ul>
<p>That didn’t exist. So I built it.</p>
<h2 id="a-different-approach-to-edge-replication"><a href="#a-different-approach-to-edge-replication" data-astro-prefetch="">#</a>A different approach to edge replication</h2>
<p><img src="https://sqlsync.dev/_astro/graft-logo.CmQL8Gao_1jCWHt.webp" alt="A cartoon image of two bonsai trees being grafted together using duct tape." width="1268" height="617" loading="lazy" decoding="async"/></p>
<p>If you’ve ever tried to keep data in sync across clients and servers, you know it’s harder than it sounds. Most existing solutions fall into one of two camps:</p>
<ul>
<li><strong>Full replication</strong>, which syncs the entire dataset to each client—not practical for constrained environments like serverless functions or web apps.</li>
<li><strong>Schema-aware diffs</strong>, like <a href="https://en.wikipedia.org/wiki/Change_data_capture" data-astro-prefetch="">Change Data Capture (CDC)</a> or <a href="https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type" data-astro-prefetch="">Conflict-free Replicated Data Types (CRDTs)</a>, which track logical changes at the row or field level—but require deep application integration and don’t generalize to arbitrary data.</li>
</ul>
<p>Graft takes a different path.</p>
<p>Like full replication, Graft is schema-agnostic. It doesn’t know or care what kind of data you’re storing—it just replicates bytes<sup><a href="#user-content-fn-pages" data-astro-prefetch="" id="user-content-fnref-pages" data-footnote-ref="" aria-describedby="footnote-label">2</a></sup>. But instead of sending all the data, it behaves more like logical replication: clients receive a compact description of what’s changed since their last sync.</p>
<p>At the core of this model is the Volume: a sparse, ordered collection of fixed-size Pages. Clients interact with Volumes through a transactional API, reading and writing at specific Snapshots. Under the hood, Graft persists and replicates only what’s necessary—using object storage as a durable, scalable backend.</p>
<p>The result is a system that’s lazy, partial, edge-capable, and consistent.</p>
<blockquote data-callout="tip" data-expandable="false" data-expanded="false">

                <div>
                  
                  <p>Want to try the managed version of Graft?</p>
                </div>
                
              
<p>Join the waitlist to get early access: <a href="https://sqlsync.dev/out/signup-graft-service" data-astro-prefetch="">Sign up here →</a></p>
</blockquote>
<p>Each of these properties deserves a closer look—let’s unpack them one by one.</p>
<h3 id="lazy-sync-at-your-own-pace"><a href="#lazy-sync-at-your-own-pace" data-astro-prefetch="">#</a>Lazy: Sync at your own pace</h3>
<p>Graft is designed for the real world—where edge clients wake up occasionally, face unreliable networks, and run in short-lived, resource-constrained environments. Instead of relying on continuous replication, clients choose <strong>when</strong> to sync, and Graft makes it easy to fast forward to the latest snapshot.</p>
<p>That sync starts with a simple question: <em>what changed since my last snapshot?</em></p>
<p><img src="https://sqlsync.dev/_astro/pull_changes.DjOYfgBf_2biXxv.webp" alt="A client pulling a graft of changes from the server containing versions v2-v4" width="1268" height="792" loading="lazy" decoding="async"/></p>
<p>The server responds with a <strong><code>graft</code></strong>—a compact bitset of page indexes that have changed across all commits since that snapshot<sup><a href="#user-content-fn-graft" data-astro-prefetch="" id="user-content-fnref-graft" data-footnote-ref="" aria-describedby="footnote-label">3</a></sup>. This is where the project gets its name: a <code>graft</code> attaches new changes to an existing snapshot—like grafting a branch onto a tree. They act as a guide, informing the
client which pages can be reused and which need to be fetched if needed.</p>
<p>Critically, when a client pulls a <code>graft</code> from the server, it doesn’t receive any actual data—only metadata about what changed. This gives the client full control over what to fetch and when, laying the foundation for partial replication.</p>
<h3 id="partial-sync-only-whats-needed"><a href="#partial-sync-only-whats-needed" data-astro-prefetch="">#</a>Partial: Sync only what’s needed</h3>
<p>When you’re building for edge environments—browser tabs, mobile apps, serverless functions—you can’t afford to download the entire dataset just to serve a handful of queries. That’s where partial replication comes in.</p>
<p>After a client pulls a <code>graft</code>, it knows exactly what’s changed. It can use that information to determine precisely which pages are still valid and which pages need to be fetched. Instead of pulling everything, clients selectively retrieve only the pages they’ll actually use—nothing more, nothing less.</p>
<p><img src="https://sqlsync.dev/_astro/partial_replication.SHCa4vx5_1mBVIx.webp" alt="A volume with some pages cached from previous versions, some pages in a pending state, and some pages being fetched" width="1268" height="654" loading="lazy" decoding="async"/></p>
<p>To keep things snappy, Graft supports several ways to prefetch pages:</p>
<ol>
<li><strong>General-purpose prefetching</strong>: Graft includes a built-in prefetcher based on the <a href="https://www.usenix.org/system/files/atc20-maruf.pdf" data-astro-prefetch="">Leap</a> algorithm, which predicts future page accesses by identifying patterns<sup><a href="#user-content-fn-patterns" data-astro-prefetch="" id="user-content-fnref-patterns" data-footnote-ref="" aria-describedby="footnote-label">4</a></sup>.</li>
<li><strong>Domain-specific prefetching</strong>: Applications can leverage domain knowledge to preemptively fetch relevant pages. For instance, if your app frequently queries a user’s profile, Graft can prefetch pages related to that profile before the data is needed.</li>
<li><strong>Proactive fetching</strong>: Clients can always fall back to pulling all changes if needed, essentially reverting to full replication. This is particularly useful for Graft workloads running on the server side.</li>
</ol>
<p>And because Graft hosts pages directly on object storage, they’re naturally durable and scalable, creating a strong foundation for edge-native replication.</p>
<h3 id="edge-sync-close-to-the-action"><a href="#edge-sync-close-to-the-action" data-astro-prefetch="">#</a>Edge: Sync close to the action</h3>
<p><img src="https://sqlsync.dev/_astro/global_topology.BU4YETI2_Z1J7CYY.webp" alt="Graft&#39;s global replication topology, with clients pulling data through the edge cache all over the world" width="1268" height="700" loading="lazy" decoding="async"/></p>
<p>Edge replication isn’t just about choosing what data to sync—it’s about making sure that data is available where it’s actually needed. Graft does this in two key ways.</p>
<p>First, pages are served from object-storage through a global fleet of edge servers, allowing frequently accessed (“hot”) pages to be cached near clients. This keeps latency low and responsiveness high, no matter where in the world your users happen to be.</p>
<p>Second, the Graft client itself is lightweight and designed specifically to be embedded. With minimal dependencies and a tiny runtime, it integrates into constrained environments like browsers, devices, mobile apps, and serverless functions.</p>
<p>The result? Your data is always cached exactly where it’s most valuable—right at the edge and embedded in your application.</p>
<p>But caching data on the edge brings new challenges, particularly around maintaining consistency and safely handling conflicts. That’s where Graft’s robust consistency model comes in.</p>
<h3 id="consistency-sync-safely"><a href="#consistency-sync-safely" data-astro-prefetch="">#</a>Consistency: Sync safely</h3>
<p>Strong consistency is critical—especially when syncing data between clients that might occasionally conflict. Graft addresses this by providing a clear and robust consistency model: <a href="https://distributed-computing-musings.com/2022/02/transactions-serializable-snapshot-isolation/" data-astro-prefetch="">Serializable Snapshot Isolation</a>.<sup><a href="#user-content-fn-isomodel" data-astro-prefetch="" id="user-content-fnref-isomodel" data-footnote-ref="" aria-describedby="footnote-label">5</a></sup></p>
<p>This model gives clients isolated, consistent views of data at specific snapshots, allowing reads to proceed concurrently without interference. At the same time, it ensures that writes are <a href="https://jepsen.io/consistency/models/strong-serializable" data-astro-prefetch="">strictly serialized</a>, so there’s always a clear, globally consistent order for every transaction.</p>
<p>However, because Graft is designed for offline-first, lazy replication, clients sometimes attempt to commit changes based on an outdated snapshot. Accepting these commits blindly would violate strict serializability. Instead, Graft safely rejects the commit and lets the client choose how to resolve the situation. Typically, clients will:</p>
<ol>
<li><strong>Reset and replay</strong>, by pulling the latest snapshot, reapplying local transactions, and trying again.
<ul>
<li>Globally, the data remains strictly serializable.</li>
<li>Locally, the client experiences <strong>Optimistic Snapshot Isolation</strong>, meaning:
<ul>
<li>Reads always observe internally consistent snapshots.</li>
<li>However, these snapshots may later be discarded if the commit is rejected.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Merge</strong> their local state with the latest snapshot from the server. This may degrade the global consistency model to <a href="https://jepsen.io/consistency/models/snapshot-isolation" data-astro-prefetch="">snapshot isolation</a>.</li>
<li><strong>Fork the volume permanently</strong>, creating a new, separate volume—thus maintaining global serializability.</li>
</ol>
<p><img src="https://sqlsync.dev/_astro/rejection_retry.3SWufPCv_ghUB1.webp" alt="A client attempts to commit with an outdated snapshot, is rejected, pulls the latest version, and successfully commits" width="1268" height="745" loading="lazy" decoding="async"/></p>
<p>In short, Graft ensures you never have to sacrifice consistency—even when clients sync sporadically, operate offline, or collide with concurrent writes.</p>
<h2 id="what-can-you-build-with-graft"><a href="#what-can-you-build-with-graft" data-astro-prefetch="">#</a>What can you build with Graft?</h2>
<p>Combining lazy syncing, partial replication, edge-friendly deployment, and strong consistency, Graft provides a robust foundation for a variety of edge-native applications. Here are just a few examples of what you can build with Graft:</p>
<p><strong>Offline-first apps</strong>:
Note-taking, task management, or CRUD apps that operate partially offline. Graft takes care of syncing, allowing the application to forget the network even exists. When combined with a conflict handler, Graft can also enable multiplayer on top of arbitrary data.</p>
<p><strong>Cross-platform data</strong>:
Eliminate vendor lock-in and allow your users to seamlessly access their data across mobile platforms, devices, and the web. Graft is architected to be embedded anywhere<sup><a href="#user-content-fn-embed-anywhere" data-astro-prefetch="" id="user-content-fnref-embed-anywhere" data-footnote-ref="" aria-describedby="footnote-label">6</a></sup>.</p>
<p><strong>Stateless read replicas</strong>:
Due to Graft’s unique approach to replication, a database replica can be spun up with no local state, retrieve the latest snapshot metadata, and immediately start running queries. No need to download all the data and replay the log.</p>
<p><strong>Replicate anything</strong>:
Graft is just focused on consistent page replication. It doesn’t care about what’s inside those pages. So go crazy! Use Graft to sync AI models, <a href="https://en.wikipedia.org/wiki/Apache_Parquet" data-astro-prefetch="">Parquet</a> or <a href="https://github.com/lancedb/lance" data-astro-prefetch="">Lance</a> files, <a href="https://docs.mapbox.com/help/glossary/mbtiles/" data-astro-prefetch="">Geospatial tilesets</a>, or just photos of your <a href="https://www.google.com/search?udm=2&amp;q=cats" data-astro-prefetch="">cats</a>. The sky’s the limit with Graft.</p>
<h2 id="the-graft-sqlite-extension-libgraft"><a href="#the-graft-sqlite-extension-libgraft" data-astro-prefetch="">#</a>The Graft SQLite Extension (<code>libgraft</code>)</h2>
<p>Today, <code>libgraft</code> is the easiest way to start using Graft. It’s a native SQLite extension that works anywhere SQLite does. It uses Graft to replicate just the parts of the database that a client actually uses, making it possible to run SQLite in resource constrained environments.</p>
<p><code>libgraft</code> implements a <a href="https://www.sqlite.org/vfs.html" data-astro-prefetch="">SQLite virtual file system (VFS)</a> allowing it to intercept all reads and writes to the database. It provides the same transactional and concurrency semantics as SQLite does when running in <a href="https://www.sqlite.org/wal.html" data-astro-prefetch="">WAL mode</a>. Using <code>libgraft</code> provides your application with the following benefits:</p>
<ul>
<li>asynchronous replication to and from object storage</li>
<li>lazy partial replicas on the edge and in devices</li>
<li><a href="https://distributed-computing-musings.com/2022/02/transactions-serializable-snapshot-isolation/" data-astro-prefetch="">Serializable Snapshot Isolation</a></li>
<li>point in time restore</li>
</ul>
<p>If you’re interested in using <code>libgraft</code>, <a href="https://github.com/orbitinghail/graft/blob/main/docs/sqlite.md" data-astro-prefetch="">you can find the documentation here</a>.</p>
<h2 id="how-to-get-involved"><a href="#how-to-get-involved" data-astro-prefetch="">#</a>How to get involved</h2>
<p>Graft is developed openly on <a href="https://github.com/orbitinghail/graft" data-astro-prefetch="">GitHub</a>, and contributions from the community are very welcome. You can open issues, participate in discussions, or submit pull requests—check out our <a href="https://github.com/orbitinghail/graft/blob/main/CONTRIBUTING.md" data-astro-prefetch="">contribution guide</a> for details.</p>
<p>If you’d like to chat about Graft, <a href="https://discord.gg/etFk2N9nzC" data-astro-prefetch="">join the Discord</a> or <a href="https://sqlsync.dev/cdn-cgi/l/email-protection#08606d64646748677a6a617c61666f60696164266c6d7e" data-astro-prefetch="">send me an email</a>. I’d love your feedback on Graft’s approach to lazy, partial edge replication.</p>
<p>I’m also planning on launching a Graft Managed Service. If you’d like to join the waitlist, you can <a href="https://sqlsync.dev/out/signup-graft-service" data-astro-prefetch="">sign up here</a>.</p>
<blockquote data-callout="tip" data-expandable="false" data-expanded="false">

                <div>
                  
                  <p>But wait, there’s more!</p>
                </div>
                <p>Keep reading to learn about Graft’s roadmap as well as a detailed comparison between Graft and existing SQLite replication solutions.</p>
              
</blockquote>
<h2 id="appendix"><a href="#appendix" data-astro-prefetch="">#</a>Appendix</h2>
<h3 id="roadmap"><a href="#roadmap" data-astro-prefetch="">#</a>Roadmap</h3>
<p>Graft is the result of a year of research, many iterations, and one major pivot<sup><a href="#user-content-fn-pivot" data-astro-prefetch="" id="user-content-fnref-pivot" data-footnote-ref="" aria-describedby="footnote-label">7</a></sup>. But Graft is far from done. There’s a lot left to build, and the roadmap is ambitious. In no particular order, here’s what’s planned:</p>
<p><strong><a href="https://en.wikipedia.org/wiki/WebAssembly" data-astro-prefetch="">WebAssembly</a> support</strong>:
Supporting WebAssembly (Wasm) would allow Graft to be used in the browser. I’d like to eventually support <a href="https://www.sqlite.org/wasm/doc/trunk/index.md" data-astro-prefetch="">SQLite’s official Wasm build</a>, <a href="https://github.com/rhashimoto/wa-sqlite" data-astro-prefetch="">wa-sqlite</a>, and <a href="https://github.com/sql-js/sql.js/" data-astro-prefetch="">sql.js</a>.</p>
<p><strong>Integrating Graft and SQLSync</strong>:
Once Graft supports Wasm, integrating it with SQLSync will be straightforward. The plan is to split out SQLSync’s mutation, rebase, and query subscription layers so it can lay on top of a database using Graft replication.</p>
<p><strong>More client libraries</strong>:
I’d love to see native Graft-client wrappers for popular languages including Python, Javascript, Go, and Java. This would allow Graft to be used to replicate arbitrary data in those languages rather than being restricted to SQLite.<sup><a href="#user-content-fn-libgraft-everywhere" data-astro-prefetch="" id="user-content-fnref-libgraft-everywhere" data-footnote-ref="" aria-describedby="footnote-label">8</a></sup></p>
<p><strong>Low-latency writes</strong>:
Graft currently blocks push operations until they have been fully committed into object storage. This can be addressed in a number of ways:</p>
<ol>
<li>Experiment with S3 express zone</li>
<li>Buffer writes in a low-latency durable consensus group sitting in front of object storage.</li>
</ol>
<p><strong>Garbage collection, checkpointing, and compaction</strong>:
These features are needed to maximize query performance, minimize wasted space, and enable deleting data permanently. They all relate to Graft’s decision to store data directly in object storage, and batch changes together into files called segments.</p>
<p><strong>Authentication and authorization</strong>:
This is a fairly broad task that encompasses everything from accounts on the Graft managed service to fine-grained authorization to read/write Volumes.</p>
<p><strong>Volume forking</strong>:
The Graft service is already setup to perform zero-copy forks, since it can easily copy Segment references over to the new Volume. However, to perform a local fork, Graft currently needs to copy all of the pages. This could be solved by layering volumes locally and allowing reads to fall through or changing how pages are addressed locally.</p>
<p><strong>Conflict handling</strong>:
Graft should offer built-in conflict resolution strategies and extension points so applications can control how conflicts are handled. The initial built-in strategy will automatically merge non-overlapping transactions. While this relaxes global consistency to optimistic snapshot isolation, it can significantly boost performance in collaborative and multiplayer scenarios.</p>
<h3 id="comparison-with-other-sqlite-replication-solutions"><a href="#comparison-with-other-sqlite-replication-solutions" data-astro-prefetch="">#</a>Comparison with other SQLite replication solutions</h3>
<p>Graft builds on ideas pioneered by many other projects, while adding its own unique contributions to the space. Here is a brief overview of the SQLite replication landscape and how Graft compares.</p>
<blockquote data-callout="caution" data-expandable="false" data-expanded="false">

                
                
              
<p>The information in this section has been gathered from documentation and blog posts, and might not be perfectly accurate. Please <a href="https://sqlsync.dev/cdn-cgi/l/email-protection#9af2fff6f6f5daf5e8f8f3eef3f4fdf2fbf3f6b4feffec" data-astro-prefetch="">let me know</a> if I’ve misrepresented or misunderstood a project.</p>
</blockquote>
<h4 id="mvsqlite"><a href="#mvsqlite" data-astro-prefetch="">#</a>mvSQLite</h4>
<p>Among SQLite-based projects, <a href="https://github.com/losfair/mvsqlite" data-astro-prefetch="">mvSQLite</a> is the closest in concept to Graft. It implements a custom VFS layer that stores SQLite pages directly in <a href="https://www.foundationdb.org/" data-astro-prefetch="">FoundationDB</a>.</p>
<p>In mvSQLite, each page is stored by its content hash and referenced by <code>(page_number, snapshot version)</code>. This structure allows readers to lazily fetch pages from FoundationDB as needed. By leveraging page-level versioning, mvSQLite supports concurrent write transactions, provided their read and write sets don’t overlap.</p>
<p><em>How Graft compares</em>: Graft and mvSQLite share similar storage-layer designs, using page-level versioning to allow lazy, on-demand fetching and partial database views. The key difference lies in data storage location and how page changes are tracked. mvSQLite depends on FoundationDB, requiring all nodes to have direct cluster access—making it unsuitable for widely distributed edge devices and web applications. Additionally, Graft’s <a href="https://github.com/orbitinghail/splinter-rs" data-astro-prefetch="">Splinter</a>-based changesets are self-contained, easily distributable, and do not require direct queries against FoundationDB to determine changed page versions.</p>
<h4 id="litestream"><a href="#litestream" data-astro-prefetch="">#</a>Litestream</h4>
<p><a href="https://litestream.io/" data-astro-prefetch="">Litestream</a> is a streaming backup solution that continuously replicates <a href="https://www.sqlite.org/wal.html" data-astro-prefetch="">SQLite WAL</a> frames to object storage. Its primary focus is async durability, point-in-time restore, and read replicas. It runs externally to your application, monitoring SQLite’s WAL through the filesystem.</p>
<p><em>How Graft compares</em>: Unlike Litestream, Graft integrates directly into SQLite’s commit process via its custom VFS, enabling lazy, partial replication, and distributed writes. Like Litestream, Graft replicates pages to object storage and supports point-in-time restores.</p>
<h4 id="cr-sqlite"><a href="#cr-sqlite" data-astro-prefetch="">#</a>cr-sqlite</h4>
<p><a href="https://github.com/vlcn-io/cr-sqlite" data-astro-prefetch="">cr-sqlite</a> is a SQLite extension which turns tables into <a href="https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type" data-astro-prefetch="">Conflict-free Replicated Data Types (CRDTs)</a>, enabling logical, row-level replication. It offers automatic conflict resolution but requires schema awareness and application-level integration.</p>
<p><em>How Graft compares</em>: Graft is schema-agnostic and doesn’t depend on logical CRDTs, making it compatible with arbitrary SQLite extensions and custom data structures. However, to achieve global serializability, Graft expects applications to handle conflict resolution explicitly. In contrast, cr-sqlite automatically merges changes from multiple writers, achieving <a href="https://jepsen.io/consistency/models/causal" data-astro-prefetch="">causal consistency</a>.</p>
<h4 id="cloudflare-durable-objects-with-sqlite-storage-9"><a href="#cloudflare-durable-objects-with-sqlite-storage-9" data-astro-prefetch="">#</a>Cloudflare Durable Objects with SQLite Storage <sup><a href="#user-content-fn-cf-do-name" data-astro-prefetch="" id="user-content-fnref-cf-do-name" data-footnote-ref="" aria-describedby="footnote-label">9</a></sup></h4>
<p><a href="https://blog.cloudflare.com/sqlite-in-durable-objects/" data-astro-prefetch="">By combining Durable Objects with SQLite</a>, you get a strongly consistent and highly durable database wrapped with your business logic and hosted hopefully close to your users in Cloudflare’s massive edge network. Under the hood, this solution is similar to Litestream in that it replicates the SQLite WAL to object storage and performs periodic checkpoints.</p>
<p><em>How Graft compares</em>: Graft exposes replication as a first class citizen, and is designed to replicate efficiently to and from the edge. In comparison, SQLite in Durable Objects is focused on extending Durable Objects with the full power of SQLite.</p>
<h4 id="cloudflare-d1"><a href="#cloudflare-d1" data-astro-prefetch="">#</a>Cloudflare D1</h4>
<p><a href="https://developers.cloudflare.com/d1/" data-astro-prefetch="">Cloudflare D1</a> is a managed SQLite database operating similarly to traditional database services like <a href="https://aws.amazon.com/rds/" data-astro-prefetch="">Amazon RDS</a> or <a href="https://turso.tech/" data-astro-prefetch="">Turso</a>, accessed by applications via an HTTP API.</p>
<p><em>How Graft compares</em>: Graft replicates data directly to the edge, embedding it within client applications. This decentralized replication model contrasts significantly with D1’s centralized data service.</p>
<h4 id="turso--libsql"><a href="#turso--libsql" data-astro-prefetch="">#</a>Turso &amp; libSQL</h4>
<p><a href="https://turso.tech/" data-astro-prefetch="">Turso</a> provides managed SQLite databases and embedded replicas via <a href="https://github.com/tursodatabase/libsql" data-astro-prefetch="">libSQL</a>, an open-source SQLite fork. Similar to Litestream and Cloudflare Durable Objects SQL Storage, Turso replicates SQLite WAL frames to object storage and periodically checkpoints. Replicas catch up by retrieving these checkpoints and replaying the log.</p>
<p><em>How Graft compares</em>: Graft distinguishes itself with partial replication and support for arbitrary, schema-agnostic data structures. Graft’s backend service operates directly at the page level and outsources the entire transactional lifecycle to clients.</p>
<h4 id="rqlite--dqlite"><a href="#rqlite--dqlite" data-astro-prefetch="">#</a>rqlite &amp; dqlite</h4>
<p>The key idea behind <a href="https://github.com/rqlite/rqlite" data-astro-prefetch="">rqlite</a> and <a href="https://dqlite.io/" data-astro-prefetch="">dqlite</a> is to distribute SQLite across multiple servers. This is achieved through <a href="https://en.wikipedia.org/wiki/Raft_(algorithm)" data-astro-prefetch="">Raft</a> based consensus and routing SQLite operations through a network protocol to the current Raft leader.</p>
<p><em>How Graft compares:</em> These projects are focused on increasing SQLite’s durability and availability through consensus and traditional replication. They are designed to scale across a set of stateful nodes that maintain connectivity to one another. Graft fundamentally differs by being a stateless system built on top of object storage, designed to replicate data to and from the edge.</p>
<h4 id="verneuil"><a href="#verneuil" data-astro-prefetch="">#</a>Verneuil</h4>
<p><a href="https://github.com/backtrace-labs/verneuil" data-astro-prefetch="">Verneuil</a> focuses on asynchronously replicating SQLite snapshots to read replicas via object storage, prioritizing reliability without introducing additional failure modes. Verneuil explicitly avoids mechanisms to minimize replication latency or staleness.</p>
<p><em>How Graft compares</em>: Graft behaves more like a multi-writer distributed database, emphasizing selective, real-time partial replication. Verneuil’s approach, meanwhile, emphasizes unidirectional asynchronous snapshot replication without guarantees around replication freshness.</p>
  </div></div>
  </body>
</html>
