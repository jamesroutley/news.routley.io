<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://mergify.com/blog/await-is-not-a-context-switch-understanding-python-s-coroutines-vs-tasks">Original</a>
    <h1>Await Is Not a Context Switch: Understanding Python&#39;s Coroutines vs. Tasks</h1>
    
    <div id="readability-page-1" class="page"><p data-styles-preset="At_eTy7lJ">Python’s async model is misunderstood, especially by engineers coming from JS or C#. In Python, awaiting a coroutine doesn’t yield to the event loop. Only tasks create concurrency. This post explains why that distinction matters and how it affects locking, design, and correctness.</p><div data-framer-component-type="RichTextContainer"><p>Every engineer has had that moment during a review where a comment sticks in their head longer than it should.</p><p>In my case, it was a simple suggestion:</p><blockquote><p>“You should add more locks here: this code is async, so anything might interleave.”</p></blockquote><p>The code in question touched a shared cache, and on the surface the comment made sense. Multiple asyncio tasks were hitting the same structure, and the function modifying it was async. Shouldn&#39;t that mean I need more locks?</p><p>That review pushed me down a rabbit hole. Not about the cache (it was tiny) but about the mental model many engineers (including experienced ones) bring to Python&#39;s async system. A model shaped by JavaScript or C#: all languages where await means <em>&#34;yield to the runtime now.&#34;</em></p><p>But Python isn&#39;t those languages. And misunderstanding this <strong>fundamental difference</strong> leads to unnecessary locking, accidental complexity, and subtle bugs.</p><p>This post is the explanation I wish more engineers had.</p><h2><strong>The misconception: await gives up control (in every language… right?)</strong></h2><p>If you&#39;re coming from JavaScript, the rule is simple:</p><ul><li data-preset-tag="p"><p>Every await always yields to the event loop.</p></li><li data-preset-tag="p"><p>Every async function always returns a task (a Promise).</p></li><li data-preset-tag="p"><p>The moment you write await, the runtime can schedule something else.</p></li></ul><p>In C#, the story is nearly identical:</p><ul><li data-preset-tag="p"><p><code>async</code> functions return <code>Task&lt;T&gt;</code> or <code>Task</code>.</p></li><li data-preset-tag="p"><p><code>await</code> always represents a suspension point.</p></li><li data-preset-tag="p"><p>The runtime decides when to resume you.</p></li></ul><p>In Java&#39;s virtual-thread world (Project Loom), the principle is very similar: when you submit work to run asynchronously, typically via an <code>ExecutorService</code> backed by virtual threads, you&#39;re creating tasks. And when you call <code>Future.get()</code>, the virtual thread suspends until the result is ready. The suspension is inexpensive, but it still constitutes a full scheduling boundary.</p><p>So developers internalize one big rule:</p><blockquote><p>“Any async boundary is a suspension point.“</p></blockquote><p>And then they bring that rule to Python.</p><h2><strong>But Python is different: it has two async concepts</strong></h2><p>Python splits things into:</p><h3><strong>1. Coroutines</strong></h3><p>Defined with async def, but not scheduled. A coroutine object is <em>just</em> a state machine with potential suspension points.</p><p>When you run:</p><p>Python immediately steps into the coroutine and executes it <strong>inside the current task</strong>, synchronously, until it either finishes or hits a suspension point (await something_not_ready).</p><p>No event-loop scheduling happens here.</p><h3><strong>2. Tasks</strong></h3><p>Created with asyncio.create_task(coro). Tasks are the unit of concurrency in Python. The event loop interleaves tasks, not coroutines.</p><p>This distinction is not cosmetic: it’s the reason many developers misunderstand Python&#39;s async semantics.</p><h2><strong>The key truth: await on a coroutine does NOT yield to the event loop</strong></h2><p>This sentence is the entire post:</p><blockquote><p>Awaiting a coroutine does not give control back to the event loop. Awaiting a task does.</p></blockquote><p>A coroutine is more like a nested function call that can pause, but it doesn&#39;t pause <em>by default</em>. It only yields if and when it reaches an awaitable that isn&#39;t ready.</p><p>In contrast:</p><ul><li data-preset-tag="p"><p>JavaScript</p></li><li data-preset-tag="p"><p>Java</p></li><li data-preset-tag="p"><p>C#</p></li></ul><p>Do not expose this difference. In those languages, an &#34;async function&#34; is <em>always</em> a task. You never await a &#34;bare coroutine.&#34; Every await is a potential context switch.</p><p>Python breaks that assumption.</p><h2><strong>Concrete Example 1: Awaiting a coroutine is synchronous</strong></h2><p>Let&#39;s make the behavior painfully explicit.</p><p>Output:</p><p>Notice what <strong>didn&#39;t</strong> happen:</p><ul><li data-preset-tag="p"><p>No other task ran between &#34;child start&#34; and &#34;child end&#34;.</p></li><li data-preset-tag="p"><p><code>await child()</code> did not give the event loop a chance to schedule anything else until <code>child()</code> itself awaited <code>asyncio.sleep</code>.</p></li></ul><p><code>await child()</code> simply <em>inlined</em> the coroutine&#39;s body.</p><p>This is not how JavaScript behaves. This is not how C# behaves. This is not how Java behaves.</p><h2><strong>Concrete Example 2: Tasks actually introduce concurrency</strong></h2><p>Change one line:</p><p>Now the output interleaves depending on the scheduler:</p><p>Because now we have a <strong>task</strong>, and awaiting a task <em>does</em> yield to the event loop.</p><p>Tasks are where concurrency comes from, not coroutines.</p><p>This single difference is where most incorrect locking recommendations arise.</p><h2><strong>Suspension points define concurrency, not async or await</strong></h2><p>Now let&#39;s extract the general rule:</p><ul><li data-preset-tag="p"><p>An async def function is <em>not</em> automatically concurrent.</p></li><li data-preset-tag="p"><p><code>await</code> is <em>not</em> a scheduling point unless the inner awaitable suspends.</p></li><li data-preset-tag="p"><p>Concurrency exists <strong>only across tasks</strong> and <strong>only at actual suspension points</strong>.</p></li></ul><p>This is why the code review suggestion I received, &#34;add more locks, it’s async!&#34;, was based on the wrong mental model.</p><p>My mutation block contained <strong>no awaits</strong>. The only awaits happened before acquiring the lock. Therefore:</p><ul><li data-preset-tag="p"><p>The critical section was atomic relative to the event loop.</p></li><li data-preset-tag="p"><p>No other task could interleave inside the mutation.</p></li><li data-preset-tag="p"><p>More locks would not increase safety.</p></li></ul><p>The cache wasn&#39;t the story. My reviewer&#39;s misconception was.</p><h2><strong>Why Python chose this design</strong></h2><p>Python&#39;s async model evolved from generators (<code>yield</code>, <code>yield from</code>), rather than green threads or promises. Coroutines are an evolution of these primitives.</p><p>This legacy leads to:</p><ul><li data-preset-tag="p"><p>A more explicit boundary between <em>structured control flow</em> and <em>scheduled concurrency</em>.</p></li><li data-preset-tag="p"><p>The ability to write async code that behaves synchronously until a real suspension occurs.</p></li><li data-preset-tag="p"><p>Fine-grained control over when interleaving can happen.</p></li></ul><p>It also leads to confusion among developers coming from JavaScript, Java, or C#, languages where async automatically means &#34;this is a task.&#34;</p><p>Python leaves &#34;is this a task?&#34; up to you.</p><h2><strong>Putting it all together: a mental model that actually works</strong></h2><p>Here is the model I now advocate whenever reviewing asyncio code:</p><ol><li data-preset-tag="p"><p><strong>Coroutines are callables with potential suspension points: </strong>they do not run concurrently.</p></li><li data-preset-tag="p"><p><strong>Only tasks introduce concurrency:  </strong>if you never call <code>asyncio.create_task</code>, you may not have any concurrency at all.</p></li><li data-preset-tag="p"><p><strong>Concurrency occurs only at suspension points: </strong>no await inside a block → no interleave → no need for locks there.</p></li><li data-preset-tag="p"><p><strong>Locks should protect data across tasks, not coroutines: </strong>lock where suspension is possible, not where the keyword async appears.</p></li></ol><h2><strong>Practical guidelines for real codebases</strong></h2><ul><li data-preset-tag="p"><p><strong>Audit where tasks are created: </strong>every <code>asyncio.create_task()</code> is a concurrency boundary.</p></li><li data-preset-tag="p"><p><strong>Scan critical sections for suspension points: </strong>if there&#39;s no await inside the lock, the block is atomic relative to the event loop.</p></li><li data-preset-tag="p"><p><strong>Prefer &#34;compute outside, mutate inside&#34;: </strong>compute values before acquiring the lock, then mutate quickly inside it.</p></li><li data-preset-tag="p"><p><strong>Teach the difference explicitly: </strong>a surprising number of experienced engineers haven&#39;t internalized coroutine vs task separation.</p></li></ul><h2><strong>Conclusion: Python async isn’t JavaScript async</strong></h2><p>Once you internalize that:</p><ul><li data-preset-tag="p"><p>JavaScript: async function → always a task</p></li><li data-preset-tag="p"><p>C#: async → always a task</p></li><li data-preset-tag="p"><p>Java (Loom&#39;s <code>VirtualThread</code>)): async → always a task</p></li><li data-preset-tag="p"><p><strong>Python: async def → only a coroutine; task creation is explicit</strong></p></li></ul><p>Then the whole model makes sense.</p><p>Python&#39;s await isn&#39;t a context switch. It&#39;s a structured control flow that <em>might</em> suspend.</p><p>That difference is why I didn&#39;t add more locks to my cache code. And it&#39;s why I now review Python async code by asking a much better question:</p><blockquote><p>&#34;Where can this code actually interleave?&#34;</p></blockquote><p>That single question catches more bugs and eliminates more unnecessary complexity than any blanket rule about locking in async systems.</p></div></div>
  </body>
</html>
