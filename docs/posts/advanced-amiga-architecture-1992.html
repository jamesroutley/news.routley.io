<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://archive.org/details/advanced-amiga-architecture">Original</a>
    <h1>Advanced Amiga Architecture (1992)</h1>
    
    <div id="readability-page-1" class="page"><div role="main"><article><header><section><span><a href="https://thevaluable.dev/tags/vim/">#Vim</a></span></section></header><section><picture><source srcset="https://thevaluable.dev/images/2023/nvim-tree-sitter/sitting_in_tree.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2023/nvim-tree-sitter/sitting_in_tree.jpg" alt="Sitting in a tree with Tree-sitter"/></picture><p>It’s again a boring day for you and your colleagues at the offices of MegaCorpMoneyMaker, the company you work for. Davina, your colleague developer, seems to be fascinated by a tree you can see through a small window; curious, you ask her what she’s thinking about.</p><p>“I was considering configuring Tree-sitter for the Best Editor In The Universe™!”, she answers with sudden determination. Wondering what was this Tree-sitter she’s speaking about, but too afraid to show your lack of knowledge, you answer that sitting on a tree has nothing to do with editors, and she should go see a doctor.
She looks at you with amusement, before pulling you suddenly to her computer. “Tree-sitter is a library able to create a parse tree from some source code. Neovim can use it to implement different functionalities, like syntax highlighting for example.”</p><p>Surely, something fishy is going on. Syntax highlighting exists since the dawn of humanity! There’s only one possible explanation: Davina finally lost her mind after too much boredom.</p><p>“Why on Earth this Tree-sitter thing’s better than the usual syntax highlighting?” you ask, as innocent as a baby from the womb.</p><p>“I will show you!”, answer Davina. This article is the result of her explanation, captured by The Old Gods to enlighten the ones who want to get The Knowledge. The author is only the messenger.</p><p>We’ll see, more specifically:</p><ul><li>Why using Tree-sitter at the first place.</li><li>How Tree-sitter works.</li><li>How to enable syntax highlighting using Tree-sitter in Neovim.</li><li>How to customize a color scheme for this syntax highlighting.</li><li>What are the plugins which can help you use Tree-sitter for other functionalities.</li></ul><p>There’s also a <a href="https://github.com/Phantas0s/the_valuable_dev_companion/tree/main/neovim-treesitter" target="_blank" rel="noopener">companion repository</a> containing all the files we’ll use in this article.</p><p>Are you ready to climb up the tree?</p><h2 id="why-using-tree-sitter">Why Using Tree-sitter?</h2><p>Tree-sitter is a small C library used to parse some source code (often a file at a time). Because it’s fast and small, it can be easily embedded into text editors or IDEs to answer all their parsing needs: syntax highlighting, code analysis, or incremental selection for example.</p><p>Before Tree-sitter, your beautiful source code was parsed using some sort of regex engine in most editors. But there are many problems with this solution: it’s potentially slow and inaccurate.</p><p>Regex engines, depending on their implementation and the functionalities they offer, can be indeed slow. For example, your editor might need to parse the entire source code each time you modify it, decreasing further the performances. Regexes can also be inaccurate in many situations: it’s difficult to parse nested constructs, for example.</p><p>On top of that, your regexes can be very different from one language to another; look at the syntax between C++ and Clojure for example. You’ll need a different set of regexes for each.</p><p>Tree-sitter tries to solve these problems by implementing the following:</p><ul><li>Tree-sitter can parse your source code and spit up a parse tree, also called CST (<a href="https://en.wikipedia.org/wiki/Parse_tree" target="_blank" rel="noopener">Concrete Syntax Tree</a>). You’ll need one parser per programming language, but the CST itself is the same for every single one of them. It brings needed consistency, making the development of functionalities using Tree-sitter easier.</li><li>The Tree-sitter library was optimized for speed.</li><li>The parsers are often faster than a bunch of regexes. But it might not be the case: it entirely depends on their implementation.</li><li>If you modify your source code, the parser will only parse what was modified, and only updates the section of the CST which changed. This is called incremental parsing, making Tree-sitter even faster.</li><li>Using a tree is more accurate than a bunch of regexes, correctly identifying tokens even when the source code is quite complex.</li></ul><p>Now that we saw why Tree-sitter is better than a bunch of regexes, let’s get closer to this beast and look at how it really works.</p><h2 id="how-tree-sitter-works">How Tree-sitter Works</h2><h3 id="grammar-file">Grammar File</h3><p>To parse our source code and create a CST, we first need a specific parser for the programming language of our choice. A parser can be generated from a grammar file <code>grammar.json</code> (or <code>grammar.js</code>), describing all the constructs of the language, and how to write them in term of other constructs. The <a href="https://github.com/Tree-sitter/Tree-sitter/tree/master/cli" target="_blank" rel="noopener">Tree-sitter CLI</a> gives you the command “generate”, taking the grammar file as input to output the parser itself (a C file).</p><p>This CLI is a dependency for Neovim, so you should already have it on your system.</p><p>Here’s a small extract of a grammar file for the Lua programming language:</p><div><pre tabindex="0"><code data-lang="json"><span><span> <span>&#34;if_statement&#34;</span><span>:</span> <span>{</span>
</span></span><span><span>      <span>&#34;type&#34;</span><span>:</span> <span>&#34;SEQ&#34;</span><span>,</span>
</span></span><span><span>      <span>&#34;members&#34;</span><span>:</span> <span>[</span>
</span></span><span><span>        <span>{</span>
</span></span><span><span>          <span>&#34;type&#34;</span><span>:</span> <span>&#34;STRING&#34;</span><span>,</span>
</span></span><span><span>          <span>&#34;value&#34;</span><span>:</span> <span>&#34;if&#34;</span>
</span></span><span><span>        <span>},</span>
</span></span><span><span><span>...</span>
</span></span></code></pre></div><p>You can find the complete file in the <a href="https://github.com/Phantas0s/the_valuable_dev_companion/blob/main/neovim-treesitter/grammar.json" target="_blank" rel="noopener">companion repository</a></p><p>The parser created from the grammar file can then be used to parse any file containing source code of the chosen programming language (Lua here), and create the CST we all desire.</p><h3 id="parsers">Parsers</h3><p>Without going too much into the nitty-gritty, the parser includes a lexer and an array mapping a given token to an action. For example, if the parser find an <code>if</code> in the source code, it should create an <code>if_statement</code> node in the CST. Each node of the tree include the token, as well as its beginning and end in the source code.</p><p>Two algorithms are used to parse this source code: LR and GLR parsing. You can look at <a href="https://github.com/Phantas0s/alexandria-library/raw/master/computing/_PAPERS/dev_tools/1998_practical_algorithm_for_incremental_software_development.pdf" target="_blank" rel="noopener">this paper</a> if you want to know more about them.</p><h3 id="queries">Queries</h3><p>It’s great to have a tree, but how can we use it? Let’s take syntax highlighting to illustrate the process. If we want all the conditionals of our source code (<code>if</code>, <code>else</code>, and the like) to be red, we need to:</p><ol><li>Query the tree to find all the nodes we want.</li><li>Capture these nodes.</li><li>Map the capture to the color of our choice (red here).</li></ol><p>The LISP lovers out there will be glad to learn that these queries use a simple language based on <a href="https://en.wikipedia.org/wiki/S-expression" target="_blank" rel="noopener">S-expressions</a>; it’s basically a syntax relying heavily on parentheses.</p><p>Queries are written in files with extension “scm”, like source code written in Scheme (a LISP dialect). Don’t be fooled: this query language has little in common with Scheme (except maybe the use of S-expressions in both cases).</p><p>For example, let’s look at the file <a href="https://github.com/nvim-treesitter/nvim-treesitter/blob/master/queries/lua/highlights.scm" target="_blank" rel="noopener">highlight.scm</a>, gathering queries for highlighting the programming language Lua. Here’s one query:</p><pre tabindex="0"><code data-lang="query">(if_statement
[
  &#34;if&#34;
  &#34;elseif&#34;
  &#34;else&#34;
  &#34;then&#34;
  &#34;end&#34;
] @conditional)
</code></pre><p>Again, you can find the complete file in the <a href="https://github.com/Phantas0s/the_valuable_dev_companion/blob/main/neovim-treesitter/queries/lua/highlights.scm" target="_blank" rel="noopener">companion repository</a>.</p><p>This query look at conditionals (the tokens <code>if</code>, <code>elseif</code>, <code>else</code>, and so on) in a CST created from a Lua source code, and capture them under the name <code>@conditional</code>. In Neovim, we can then use this capture to highlight these conditionals.</p><p>Most of the time, each specific feature of Neovim using Tree-sitter (like syntax highlighting) will use a different set of queries.</p><p>To summarize the process:</p><p>flowchart LR
A[&#34;Grammar&#34;]--define--&gt;B[&#34;Parser&#34;]--parse--&gt;C[&#34;Source code&#34;]
B--create--&gt;D[&#34;CST&#34;]
E[Query]--capture--&gt;D</p><h2 id="syntax-highlighting-with-tree-sitter-and-neovim">Syntax Highlighting with Tree-sitter and Neovim</h2><p>Now that we understand better how Tree-sitter works, let’s dive into a concrete example: how can we enable Lua syntax highlighting using Tree-sitter in Neovim?</p><p>First, it’s important to note that the support for Tree-sitter in our favorite editor is still experimental. Future changes might crash your carefully crafted configuration, for example. But it works well enough to be able to use it today.</p><p>We could directly use the plugin <a href="https://github.com/nvim-treesitter/nvim-treesitter" target="_blank" rel="noopener">nvim-treesitter</a> to use Tree-sitter with Neovim. But I think it’s useful to try to configure the syntax highlighting for Lua without any plugin at the beginning, for two reasons:</p><ul><li>It helps understand how Tree-sitter works with Neovim; it’s useful if you run into some problems trying to configure it.</li><li>Some users (including me) don’t necessarily want to install 938792387 plugins, especially Neovim ones. In my experience, they have tendency to change often and break my configuration, especially when Neovim itself gets a version bump. It’s even more true when we deal with experimental features.</li></ul><p>By default, Vim and Neovim use regexes for syntax highlighting. It can be set on and off with the Ex commands <code>:syntax on</code> and <code>:syntax off</code> respectively. Now, if you want to use Tree-sitter, I’d recommend turning off the syntax, to be sure that the highlighting indeed use Tree-sitter. It’s normally set off by default when enablin syntax highlighting with Tree-sitter, but setting it off early can show you if some of your plugins require this regex-based syntax to be on.</p><p>To enable our syntax highlighting for Lua, we first need a Lua parser. It needs to be a shared library (with the extension <code>so</code>) for Neovim to be able to use it.</p><p>It’s where we bump into our first problem: as we saw above, the Tree-sitter CLI can generate parsers from a grammar file for a specific programming language; but this parser is a simple C file, not a shared library. You can find many of these parsers direclty from <a href="https://Tree-sitter.github.io/Tree-sitter/" target="_blank" rel="noopener">the official Tree-sitter documentation</a>, so we don’t need to generate them manually. But you won’t find easily shared libraries for these parsers.</p><p>For example, here’s a <a href="https://github.com/MunifTanjim/Tree-sitter-lua/tree/main/src" target="_blank" rel="noopener">Github repo with a Lua parser</a>. The parser is called <code>parser.c</code>. To generate a shared library, you’ll need to download both files <code>parser.c</code> and <code>scanner.c</code>, and then use a C compiler.</p><p>Using gcc on Linux, you can run the following command:</p><div><pre tabindex="0"><code data-lang="sh"><span><span>gcc -o lua.so -shared parser.c scanner.c -Os -fPIC
</span></span></code></pre></div><p>Why do we need this file <code>scanner.c</code> now? It depends on the parser; some will need one of these scanner files, others won’t. As a general rule of thumb, if you see a file <code>scanner.c</code> (or <code>scanner.cc</code>) in the directory <code>src</code> of a parser’s source code, always use it to compile your shared library.</p><p>You can also look <a href="https://github.com/nvim-treesitter/nvim-treesitter/blob/0e266bfc29a1ab17b9143235870c695ea74d6490/lua/nvim-treesitter/parsers.lua" target="_blank" rel="noopener">at this file from the plugin nvim-treesitter</a> to see what files are used to compile some of these parsers.</p><p>You won’t necessarily need the option <code>-fPIC</code>; again, it depends on the parser. Don’t worry about that: if you need it, your compiler will throw an error message and abort the compilation anyway.</p><p>The command above will output the wonderful file <code>lua.so</code>. The name of the parser should be the name of the programming language it parses.</p><p>You’ll then need to copy this file into one of Neovim’s <a href="https://thevaluable.dev/vim-runtime-guide-example/">runtimepath</a>, in a new “parser” subfolder. For example, on my Linux-based system, I’d need to copy <code>lua.so</code> into <code>~/.config/nvim/parser/lua.so</code>.</p><p>Now that we have our parser in the form of a shared library, we need some queries to capture the nodes in order to highlight them. The plugin nvim-treesitter can help us again: it includes many queries for many programming languages, including <a href="https://github.com/nvim-treesitter/nvim-treesitter/tree/master/queries/lua" target="_blank" rel="noopener">some queries for Lua</a>.</p><p>We need to get the file <code>highlights.scm</code> and put it in Neovim’s runtimepath again, under the directory <code>queries/lua</code>. For example, on my system, I’d need to download the query file in <code>~/.config/nvim/queries/lua/highlights.scm</code>.</p><p>Finally, we can try to open a Lua file in our buffer and enable Tree-sitter highlighting with the following Ex command:</p><div><pre tabindex="0"><code data-lang="vim"><span><span><span>:</span><span>lua</span> <span>vim</span>.<span>Tree</span><span>-</span><span>sitter</span>.<span>start</span><span>()</span><span>
</span></span></span></code></pre></div><p>The function <code>start()</code> can have two arguments:</p><ol><li>The buffer number</li><li>The programming language we want to parse.</li></ol><p>If you don’t specify the buffer, it will try to parse the current one by default (the buffer 0). If you don’t specify the second argument, it will take the filetype of the buffer and try to find a parser with this name, in our case <code>lua.so</code>.</p><p>The following Ex commands is equivalent to the one above:</p><div><pre tabindex="0"><code data-lang="vim"><span><span><span>:</span><span>lua</span> <span>vim</span>.<span>Tree</span><span>-</span><span>sitter</span>.<span>start</span><span>(</span><span>0</span><span>,</span> <span>&#34;lua&#34;</span><span>)</span><span>
</span></span></span></code></pre></div><p>This command will also turn off the default regex-based syntax highlighting. It’s like running the Ex command <code>:syntax off</code>.</p><p>That’s it! You have now some beautiful syntax highlighting powered by Tree-sitter.</p><p>You can find all the files necessary to create the shared library, as well as the shared library and the query file, in this <a href="https://github.com/Phantas0s/the_valuable_dev_companion/tree/main/neovim-treesitter" target="_blank" rel="noopener">companion repository</a>.</p><p>That’s great, but how can we customize the color scheme of the syntax highlighting?</p><div><p><i></i> Vim help</p><div><ul><li><code>:help treesitter</code></li><li><code>:help treesitter-parsers</code></li><li><code>:help treesitter-query</code></li></ul></div></div><h2 id="tree-sitter-and-color-schemes">Tree-sitter and Color Schemes</h2><p>Good news, everyone! Vim’s color schemes are compatible with Tree-sitter. If you want to keep the same color scheme as before, you don’t have to do anything; it should <em>mostly</em> work.</p><p>You can also use specific highlight groups for Tree-sitter, allowing you to customize the color scheme. Before Neovim 0.8, these highlight groups were all prefixed with “TS”; for example “TSBoolean”. But for Neovim 0.8 and up, these highlight groups are not relevant anymore. I assume here that you’re using Neovim 0.8 or greater; if not, you can find these <a href="https://github.com/nvim-treesitter/nvim-treesitter/commit/42ab95d5e11f247c6f0c8f5181b02e816caa4a4f" target="_blank" rel="noopener">deprecated highlight groups here</a>.</p><p>With Neovim 0.8 and higher, we can use the capture of our Tree-sitter queries as highlight group. For example, if you open the file <a href="https://github.com/Phantas0s/the_valuable_dev_companion/blob/main/neovim-treesitter/queries/lua/highlights.scm" target="_blank" rel="noopener">highlight.scm</a>, you’ll find queries like the following:</p><pre tabindex="0"><code data-lang="query">(repeat_statement
[
  &#34;repeat&#34;
  &#34;until&#34;
] @repeat)

(if_statement
[
  &#34;if&#34;
  &#34;elseif&#34;
  &#34;else&#34;
  &#34;then&#34;
  &#34;end&#34;
] @conditional)
</code></pre><p>You can then use the capture <code>@repeat</code> and <code>@conditional</code> in a color scheme file. For example, using Vimscript:</p><div><pre tabindex="0"><code data-lang="vim"><span><span><span>hi</span> @<span>conditional</span> <span>ctermfg</span><span>=</span><span>red</span> <span>ctermbg</span><span>=</span><span>NONE</span> <span>cterm</span><span>=</span><span>NONE</span><span>
</span></span></span><span><span><span></span><span>hi</span> @<span>repeat</span> <span>ctermfg</span><span>=</span><span>blue</span> <span>ctermbg</span><span>=</span><span>NONE</span> <span>cterm</span><span>=</span><span>NONE</span><span>
</span></span></span></code></pre></div><p>You can write these two lines in a file <code>mycolorscheme.vim</code>, put it in your runtimepath in the subfolder “colors” (for example <code>~/.config/nvim/colors/mycolorscheme.vim</code>), and load it with the Ex command <code>:colors mycolorscheme</code>.</p><p>You can do the same in Lua; look at <code>:help nvim_set_hl</code>.</p><p>You can even modify the queries if you want to customize even more your color scheme, and create your own beautiful little world. If you want a more complete example, you can <a href="https://github.com/Phantas0s/.dotfiles/blob/master/nvim/colors/hypnos.vim" target="_blank" rel="noopener">look at my own color scheme</a>. It’s far from perfect, but at least it’s quite simple.</p><p>Finally, you can enable automatically Tree-sitter highlighting for specific filetypes using the runtimepath <code>ftplugin</code>. For example, I can add the following line in my file <code>~/.config/nvim/ftplugin/lua.vim</code> to automatically enable Tree-sitter highlighting for Lua buffers:</p><div><pre tabindex="0"><code data-lang="vim"><span><span><span>lua</span> <span>vim</span>.<span>Tree</span><span>-</span><span>sitter</span>.<span>start</span><span>()</span><span>
</span></span></span></code></pre></div><p>If you want to know more about the runtimepath and its power, I’ve written <a href="https://thevaluable.dev/vim-runtime-guide-example/">an article about that here</a>.</p><div><p><i></i> Vim help</p><div><ul><li><code>:help treesitter-highlight</code></li><li><code>:help &#39;runtimepath&#39;</code></li><li><code>:help ftplugin</code></li><li><code>:help nvim_set_hl</code></li></ul></div></div><h2 id="neovim-plugin">Neovim Plugin</h2><p>To enable manually syntax highlighting for one specific programming language, we had to find a parser, compile it, find the queries, and move all these files in the good directories. Looking at this process, a word comes to my mind: cumbersome.</p><p>Thankfully, the plugin <a href="https://github.com/nvim-treesitter/nvim-treesitter" target="_blank" rel="noopener">nvim-treesitter</a> can automate this process for you.</p><h3 id="the-nvim-treesitter-plugin">The nvim-treesitter Plugin</h3><p>We already spoke about it above: <a href="https://github.com/nvim-treesitter/nvim-treesitter" target="_blank" rel="noopener">nvim-treesitter</a> is the plugin everybody seems to use to easily benefit from Tree-sitter. It can compile parsers using one Ex command, provide many queries for many different functionalities (called “modules”) and programming languages.</p><p>At the time of the writing, these modules are:</p><ul><li>Highlighting</li><li>Incremental selection</li><li>Indentation</li><li>Folding</li></ul><p>They are not necessarily available for all programming languages, however.</p><p>I won’t explain how to configure this plugin in this article, the <a href="https://github.com/nvim-treesitter/nvim-treesitter/blob/master/README.md" target="_blank" rel="noopener">README</a> is already doing a great job in that regard. But I can give you a brief summary of the most useful commands:</p><table><tbody><tr><th>Ex command</th><th>Description</th></tr><tr><td><code>TSInstall &lt;language&gt;</code></td><td>Compile a parser for the language <code>&lt;language&gt;</code>, and put it in the “parser” directory of the plugin.</td></tr><tr><td><code>TSUpdate &lt;language&gt;</code></td><td>Update the parser for the language <code>&lt;language&gt;</code>, or update all of them if <code>&lt;language&gt;</code> is not specified.</td></tr><tr><td><code>TSUninstall &lt;language&gt;</code></td><td>Uninstall a previously installed parser.</td></tr><tr><td><code>TSInstallInfo</code></td><td>Display all the parsers available, with indicators for the ones you’ve already installed.</td></tr><tr><td><code>TSModuleInfo</code></td><td>Display all the modules and their availability per language.</td></tr><tr><td><code>TSEnable &lt;module&gt;</code></td><td>Enable a <code>&lt;module&gt;</code> for the current session.</td></tr><tr><td><code>TSDisable &lt;module&gt;</code></td><td>Disable a <code>&lt;module&gt;</code> for the current session.</td></tr></tbody></table><p>There are more Ex commands available; I invite you to read the plugin’s README to know more about them.</p><p>For example, on my system, when I run <code>TSInstall go</code>, it will compile a go parser in <code>~/.config/nvim/plugged/nvim-treesitter/parser</code> (I’m using <a href="https://github.com/junegunn/vim-plug/wiki/tutorial" target="_blank" rel="noopener">vim-plug</a> as plugin manager, that’s why I’ve this directory <code>plugged</code>).</p><p>Personally, I use this plugin only to compile the parsers I need, and I copy them <a href="https://github.com/Phantas0s/.dotfiles/tree/master/nvim/parser" target="_blank" rel="noopener">into my own runtimepath</a> (that is, in my case, from <code>~/.config/nvim/plugged/nvim-treesitter/parser</code> to <code>~/.config/nvim/parser</code>). I’m only interested in experimenting with Tree-sitter syntax highlighting for now, so it’s enough for me. That said, if you want to use other features, you’ll have to configure the plugin according to your own needs.</p><div><p><i></i> Vim help</p><div><ul><li><code>:help nvim-treesitter</code></li><li><code>:help nvim-treesitter-modules</code></li></ul></div></div><h3 id="the-playground-plugin">The playground Plugin</h3><p>There’s another plugin which can help you understand how Tree-sitter works. It allows you to display the CST, the nodes captured by queries, and more. Please welcome <a href="https://github.com/nvim-treesitter/playground" target="_blank" rel="noopener">nvim-treesitter playground</a>. You’ll need to have <a href="https://github.com/nvim-treesitter/nvim-treesitter" target="_blank" rel="noopener">nvim-treesitter</a> installed to use it.</p><p>As you might have guessed, it’s a great tool if you want to modify your queries to customize your syntax highlighting, or any other module offered by nvim-treesitter for that matter.</p><p>Since neovim 0.9 and above, you don’t need this plugin to look at the CST, however. One of these native Ex commands can do that for you:</p><table><tbody><tr><th>Ex command</th><th>Description</th></tr><tr><td><code>:Inspect</code></td><td>Inspect the token under the cursor and display useful information.</td></tr><tr><td><code>:InspectTree</code></td><td>Open a new window and display the CST for the current buffer.</td></tr></tbody></table><p>This is already really useful.</p><p>Coming back to our plugin nvim-treesitter playground, here are the Ex commands I find the most useful:</p><table><tbody><tr><th>Ex command</th><th>Description</th></tr><tr><td><code>:TSPlaygroundToggle</code></td><td>Open a new window and display the CST for the current buffer.</td></tr><tr><td><code>:TSHighlightCapturesUnderCursor</code></td><td>Show the syntax highlighting for the token under the cursor.</td></tr><tr><td><code>:TSNodeUnderCursor</code></td><td>Show the Tree-sitter node for the token under the cursor.</td></tr></tbody></table><p>You can also use a couple of NORMAL mode keystrokes directly in the playground (the buffer created when you run <code>:TSPlaygroundToggle</code>). Here are the most interesting ones:</p><table><tbody><tr><th>Keystroke</th><th>Description</th></tr><tr><td><code>ENTER</code></td><td>Move the cursor to the token represented by the node under the cursor.</td></tr><tr><td><code>i</code></td><td>Toggle the highlight groups of each node.</td></tr><tr><td><code>I</code></td><td>Toggle the language of each node.</td></tr><tr><td><code>R</code></td><td>Reload the playground.</td></tr></tbody></table><p>There are other tools offered by the playground plugin to simplify the creation of queries: a query editor, an <a href="https://thevaluable.dev/vim-veteran/#completion-in-insert-mode" target="_blank" rel="noopener">omni-completion</a> for Tree-sitter query files, a linter…</p><p>If you want me to dive more into the details of Tree-sitter’s queries, don’t hesitate to let me know via <a href="https://thevaluable.dev/page/newsletter/">the newsletter</a>; you can also let a comment.</p><h2 id="are-we-at-the-top-of-tree-sitter">Are We at the Top of Tree-sitter?</h2><p>We’ve seen, in this article, how Tree-sitter works with Neovim, especially to highlight our source code. For other functionalities, Neovim only offer a thin interface, forcing the user to implement these functionalities themselves if they don’t want to use an external plugin.</p><p>Let’s summarize what we’ve seen in this article:</p><ul><li>Tree-sitter can parse source code faster and more accurately than the usual regex-based parsing offered by many editors out there.</li><li>A parser for a specific language can be generated from a grammar file thanks to the Tree-sitter CLI.</li><li>A parser can parse source code and output a parse tree (or CST, for Concrete Syntax Tree).</li><li>A parse tree can be queried thanks to special Tree-sitter queries, to capture a set of nodes, allowing them to be highlighted or folded, for example.</li><li>It’s quite cumbersome to install parsers manually. The plugin <a href="https://github.com/nvim-treesitter/nvim-treesitter" target="_blank" rel="noopener">nvim-treesitter</a> can help you to automate the process.</li></ul><p>After Davina finishes explaining the why and the how of Tree-sitter, you look again out of the window: you don’t see a tree anymore, just a bunch of nodes captured by wild queries. You’ve unraveled the curtain of reality to admire the essence of existence, you beautiful freak.</p></section></article></div></div>
  </body>
</html>
