<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://healeycodes.com/a-fair-cancelable-semaphore-in-go">Original</a>
    <h1>A Fair, Cancelable Semaphore in Go</h1>
    
    <div id="readability-page-1" class="page"><div><div><p>They say that you don&#39;t fully understand something unless you can build it from scratch. To wit, my challenge to the more technical readers of this blog is: can you build a semaphore from scratch in your favorite programming language? Bonus points for also handling context cancellation.</p><p>I attempted this in Go and it was about 5x harder than I thought it would be. Largely due to concurrency/locking bugs – I assume you&#39;ll have an easier time in, say, JavaScript.</p><p>A brief reminder: semaphores are tools used in programming to limit how many tasks can run at the same time by controlling access to shared resources.</p><p>Here&#39;s a quick example of their use-case. Your operating system has limits on the amount of file descriptors that can be open but you didn&#39;t know this when you wrote the following program:</p><pre><div><div><p><span>g</span><span>,</span><span> ctx </span><span>:=</span><span> errgroup</span><span>.</span><span>WithContext</span><span>(</span><span>context</span><span>.</span><span>Background</span><span>(</span><span>)</span><span>)</span><span></span></p><p><span></span><span>for</span><span> </span><span>_</span><span>,</span><span> path </span><span>:=</span><span> </span><span>range</span><span> files </span><span>{</span><span></span></p><p><span>    g</span><span>.</span><span>Go</span><span>(</span><span>func</span><span>(</span><span>p </span><span>string</span><span>)</span><span> </span><span>error</span><span> </span><span>{</span><span></span></p><p><span>        f</span><span>,</span><span> err </span><span>:=</span><span> os</span><span>.</span><span>Open</span><span>(</span><span>p</span><span>)</span><span></span></p><p><span>        </span><span>if</span><span> err </span><span>!=</span><span> </span><span>nil</span><span> </span><span>{</span><span></span></p><p><span>            </span><span>return</span><span> err</span></p><p><span>        </span><span>}</span><span></span></p><p><span>        </span><span>defer</span><span> f</span><span>.</span><span>Close</span><span>(</span><span>)</span><span></span></p><p><span>        </span><span>return</span><span> </span><span>processFile</span><span>(</span><span>f</span><span>)</span><span></span></p><p><span>    </span><span>}</span><span>(</span><span>path</span><span>)</span><span>)</span><span></span></p><p><span></span><span>}</span><span></span></p><p><span></span><span>if</span><span> err </span><span>:=</span><span> g</span><span>.</span><span>Wait</span><span>(</span><span>)</span><span>;</span><span> err </span><span>!=</span><span> </span><span>nil</span><span> </span><span>{</span><span></span></p><p><span>    </span><span>return</span><span> err</span></p><p><span></span><span>}</span></p></div></div></pre><p>When there&#39;s a large amount of files, you hit an error like:</p><pre><div><div><p><span>panic: open /my/file: too many open files!</span></p></div></div></pre><h2 id="channels">Channels</h2><p>In Go, channels are a built-in concurrency primitive for communicating between goroutines. Which is exactly what we need to do here: the goroutine that&#39;s finished using the resource needs to tell one of the goroutines that&#39;s waiting that it can start using it.</p><pre><div><div><p><span>g</span><span>,</span><span> ctx </span><span>:=</span><span> errgroup</span><span>.</span><span>WithContext</span><span>(</span><span>context</span><span>.</span><span>Background</span><span>(</span><span>)</span><span>)</span><span></span></p><p><span></span><span>// Initialize buffered channel with 10 empty structs</span><span></span></p><p><span>sema </span><span>:=</span><span> </span><span>make</span><span>(</span><span>chan</span><span> </span><span>struct</span><span>{</span><span>}</span><span>,</span><span> </span><span>10</span><span>)</span><span> </span></p><p><span></span><span>for</span><span> </span><span>_</span><span>,</span><span> path </span><span>:=</span><span> </span><span>range</span><span> files </span><span>{</span><span></span></p><p><span>    g</span><span>.</span><span>Go</span><span>(</span><span>func</span><span>(</span><span>p </span><span>string</span><span>)</span><span> </span><span>error</span><span> </span><span>{</span><span></span></p><p><span>        </span><span>// Acquire a semaphore slot (blocks if the buffer is full)</span><span></span></p><p><span>        sema </span><span>&lt;-</span><span> </span><span>struct</span><span>{</span><span>}</span><span>{</span><span>}</span><span></span></p><p><span>        </span><span>defer</span><span> </span><span>func</span><span>(</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>            </span><span>&lt;-</span><span>sema </span><span>// Release the semaphore slot</span><span></span></p><p><span>        </span><span>}</span><span>(</span><span>)</span><span></span></p><p><span>        f</span><span>,</span><span> err </span><span>:=</span><span> os</span><span>.</span><span>Open</span><span>(</span><span>p</span><span>)</span><span></span></p><p><span>        </span><span>if</span><span> err </span><span>!=</span><span> </span><span>nil</span><span> </span><span>{</span><span></span></p><p><span>            </span><span>return</span><span> err</span></p><p><span>        </span><span>}</span><span></span></p><p><span>        </span><span>defer</span><span> f</span><span>.</span><span>Close</span><span>(</span><span>)</span><span></span></p><p><span>        </span><span>return</span><span> </span><span>processFile</span><span>(</span><span>f</span><span>)</span><span></span></p><p><span>    </span><span>}</span><span>(</span><span>path</span><span>)</span><span>)</span><span></span></p><p><span></span><span>}</span></p></div></div></pre><p>This works great as a simple limiter but it&#39;s missing two features that I often need in the semaphores I use:</p><ul><li>First In First Out (FIFO) ordering. Requests are served in arrival order, which makes behavior easier to reason about and debug.</li><li>Context cancellation. Waiting or in-progress operations can be aborted when they&#39;re no longer needed, preventing wasted work and resource leaks.</li></ul><p>Why is the above snippet <em>not</em> FIFO? Multiple goroutines sending to the channel compete with each other. The scheduler decides which send proceeds first, so ordering isn&#39;t guaranteed. There&#39;s no explicit queue.</p><p>Just using a <code>chan</code> isn&#39;t going to cut it.</p><h2 id="adding-a-queue">Adding a Queue</h2><p>Go has a doubly linked list in the standard library that we can use as the queue. This queue will contain the channels that are used to wake up the blocked call to acquire the semaphore.</p><p>Trying to acquire a semaphore has one of two immediate outcomes:</p><ul><li>The fast path: there&#39;s an available permit and the call returns right away.</li><li>The slow path: there&#39;s no permits, and we enqueue a channel and wait.</li></ul><pre><div><div><p><span>When there are no available permits, G2 blocks on the Acquire() call</span></p><p><span>until an earlier goroutine, G1, calls Release().</span></p><p><span>Time →</span></p><p><span>────────────────────────────────────────</span></p><p><span>G2: Acquire() ──── blocks ─────▶ resumes</span></p><p><span>                     ▲</span></p><p><span>G1: Release() ───────┘</span></p></div></div></pre><p>We need four bits of state:</p><ul><li>The maximum number of permits</li><li>The available number of permits</li><li>A queue structure that stores channels</li><li>A lock to protect access to all the above</li></ul><pre><div><div><p><span>import</span><span> </span><span>(</span><span></span></p><p><span>    </span><span>&#34;container/list&#34;</span><span></span></p><p><span>    </span><span>&#34;sync&#34;</span><span></span></p><p><span></span><span>)</span><span></span></p><p><span></span><span>type</span><span> Semaphore </span><span>struct</span><span> </span><span>{</span><span></span></p><p><span>    mu      sync</span><span>.</span><span>Mutex</span></p><p><span>    free    </span><span>int64</span><span>     </span><span>// available permits</span><span></span></p><p><span>    max     </span><span>int64</span><span>     </span><span>// maximum permits</span><span></span></p><p><span>    waiters list</span><span>.</span><span>List </span><span>// queue of chan struct{}, closed to wake</span><span></span></p><p><span></span><span>}</span><span></span></p><p><span></span><span>// NewSemaphore creates a semaphore with n permits.</span><span></span></p><p><span></span><span>func</span><span> </span><span>NewSemaphore</span><span>(</span><span>n </span><span>int64</span><span>)</span><span> </span><span>*</span><span>Semaphore </span><span>{</span><span></span></p><p><span>    </span><span>return</span><span> </span><span>&amp;</span><span>Semaphore</span><span>{</span><span></span></p><p><span>        free</span><span>:</span><span> n</span><span>,</span><span></span></p><p><span>        max</span><span>:</span><span>  n</span><span>,</span><span></span></p><p><span>    </span><span>}</span><span></span></p><p><span></span><span>}</span><span></span></p><p><span></span><span>// Acquire blocks until a permit is available, then takes it.</span><span></span></p><p><span></span><span>func</span><span> </span><span>(</span><span>s </span><span>*</span><span>Semaphore</span><span>)</span><span> </span><span>Acquire</span><span>(</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>    s</span><span>.</span><span>mu</span><span>.</span><span>Lock</span><span>(</span><span>)</span><span></span></p><p><span>    </span><span>// Fast path: permit available</span><span></span></p><p><span>    </span><span>if</span><span> s</span><span>.</span><span>free </span><span>&gt;</span><span> </span><span>0</span><span> </span><span>{</span><span></span></p><p><span>        s</span><span>.</span><span>free</span><span>--</span><span></span></p><p><span>        s</span><span>.</span><span>mu</span><span>.</span><span>Unlock</span><span>(</span><span>)</span><span></span></p><p><span>        </span><span>return</span><span></span></p><p><span>    </span><span>}</span><span></span></p><p><span>    </span><span>// Slow path: enqueue ourselves and wait</span><span></span></p><p><span>    waiter </span><span>:=</span><span> </span><span>make</span><span>(</span><span>chan</span><span> </span><span>struct</span><span>{</span><span>}</span><span>)</span><span></span></p><p><span>    s</span><span>.</span><span>waiters</span><span>.</span><span>PushBack</span><span>(</span><span>waiter</span><span>)</span><span></span></p><p><span>    s</span><span>.</span><span>mu</span><span>.</span><span>Unlock</span><span>(</span><span>)</span><span></span></p><p><span>    </span><span>&lt;-</span><span>waiter </span><span>// blocks until Release closes the channel</span><span></span></p><p><span></span><span>}</span><span></span></p><p><span></span><span>// Release returns a permit. Panics if over-released.</span><span></span></p><p><span></span><span>func</span><span> </span><span>(</span><span>s </span><span>*</span><span>Semaphore</span><span>)</span><span> </span><span>Release</span><span>(</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>    s</span><span>.</span><span>mu</span><span>.</span><span>Lock</span><span>(</span><span>)</span><span></span></p><p><span>    </span><span>if</span><span> s</span><span>.</span><span>free</span><span>+</span><span>1</span><span> </span><span>&gt;</span><span> s</span><span>.</span><span>max </span><span>{</span><span></span></p><p><span>        s</span><span>.</span><span>mu</span><span>.</span><span>Unlock</span><span>(</span><span>)</span><span></span></p><p><span>        </span><span>panic</span><span>(</span><span>&#34;semaphore: released more than acquired&#34;</span><span>)</span><span></span></p><p><span>    </span><span>}</span><span></span></p><p><span>    s</span><span>.</span><span>free</span><span>++</span><span></span></p><p><span>    </span><span>// Wake the first waiter if any</span><span></span></p><p><span>    </span><span>if</span><span> front </span><span>:=</span><span> s</span><span>.</span><span>waiters</span><span>.</span><span>Front</span><span>(</span><span>)</span><span>;</span><span> front </span><span>!=</span><span> </span><span>nil</span><span> </span><span>{</span><span></span></p><p><span>        s</span><span>.</span><span>waiters</span><span>.</span><span>Remove</span><span>(</span><span>front</span><span>)</span><span></span></p><p><span>        s</span><span>.</span><span>free</span><span>--</span><span> </span><span>// reserve permit for waiter</span><span></span></p><p><span>        s</span><span>.</span><span>mu</span><span>.</span><span>Unlock</span><span>(</span><span>)</span><span></span></p><p><span>        </span><span>close</span><span>(</span><span>front</span><span>.</span><span>Value</span><span>.</span><span>(</span><span>chan</span><span> </span><span>struct</span><span>{</span><span>}</span><span>)</span><span>)</span><span> </span><span>// wake waiter (non-blocking)</span><span></span></p><p><span>        </span><span>return</span><span></span></p><p><span>    </span><span>}</span><span></span></p><p><span>    s</span><span>.</span><span>mu</span><span>.</span><span>Unlock</span><span>(</span><span>)</span><span></span></p><p><span></span><span>}</span></p></div></div></pre><p>I&#39;m pretty happy with this. The only way I think I could use less LOC is by removing the panic on calling <code>Release()</code> too many times (then we don&#39;t need to track <code>max</code>).</p><p>The code would be easier to read if the <code>Acquire()</code> call reserved its own permit in all cases but I couldn&#39;t figure out a way to do this while keeping the FIFO constraint. Some semaphores do allow permit stealing behavior (sometimes called &#34;barging&#34;) to increase throughput at the cost of fairness.</p><h2 id="context-cancellation">Context Cancellation</h2><p>Good programs don&#39;t keep doing work after it no longer matters. Adding context cancellation lets a blocked operation stop waiting when the surrounding task is canceled or times out, which prevents wasted effort and makes systems easier to reason about and shut down cleanly.</p><p>Inside <code>Acquire()</code>, when waiting on the signal from a <code>Release()</code> call via the channel, we need to race the context being cancelled.</p><p>When the context is cancelled, there are two possible outcomes:</p><ul><li>The <code>Acquire()</code> call is still queued and it needs to clean its state up (by removing itself from the queue), and then return a context error.</li><li>The <code>Acquire()</code> call has already been granted a permit and owns it, and so it needs to release that permit before returning a context error.</li></ul><p>In order to tell these cases apart, we need a new bit of data: a <code>granted</code> flag that tracks whether a permit has been granted. Which I&#39;ve wrapped inside this <code>waiter</code> struct with the existing channel:</p><pre><div><div><p><span>type</span><span> waiter </span><span>struct</span><span> </span><span>{</span><span></span></p><p><span>    ch      </span><span>chan</span><span> </span><span>struct</span><span>{</span><span>}</span><span></span></p><p><span>    granted </span><span>bool</span><span></span></p><p><span></span><span>}</span></p></div></div></pre><p><code>Acquire()</code> checks <code>granted</code> under the lock on cancellation. If we were granted a permit but are canceling anyway, we must release it:</p><pre><div><div><p><span>func</span><span> </span><span>(</span><span>s </span><span>*</span><span>Semaphore</span><span>)</span><span> </span><span>Acquire</span><span>(</span><span>ctx context</span><span>.</span><span>Context</span><span>)</span><span> </span><span>error</span><span> </span><span>{</span><span></span></p><p><span>    s</span><span>.</span><span>mu</span><span>.</span><span>Lock</span><span>(</span><span>)</span><span></span></p><p><span>    </span><span>// Fast path</span><span></span></p><p><span>    </span><span>if</span><span> s</span><span>.</span><span>free </span><span>&gt;</span><span> </span><span>0</span><span> </span><span>{</span><span></span></p><p><span>        s</span><span>.</span><span>free</span><span>--</span><span></span></p><p><span>        s</span><span>.</span><span>mu</span><span>.</span><span>Unlock</span><span>(</span><span>)</span><span></span></p><p><span>        </span><span>return</span><span> </span><span>nil</span><span></span></p><p><span>    </span><span>}</span><span></span></p><p><span>    w </span><span>:=</span><span> </span><span>&amp;</span><span>waiter</span><span>{</span><span>ch</span><span>:</span><span> </span><span>make</span><span>(</span><span>chan</span><span> </span><span>struct</span><span>{</span><span>}</span><span>)</span><span>}</span><span></span></p><p><span>    elem </span><span>:=</span><span> s</span><span>.</span><span>waiters</span><span>.</span><span>PushBack</span><span>(</span><span>w</span><span>)</span><span></span></p><p><span>    s</span><span>.</span><span>mu</span><span>.</span><span>Unlock</span><span>(</span><span>)</span><span></span></p><p><span>    </span><span>// Race the release signal and the context</span><span></span></p><p><span>    </span><span>select</span><span> </span><span>{</span><span></span></p><p><span>    </span><span>case</span><span> </span><span>&lt;-</span><span>w</span><span>.</span><span>ch</span><span>:</span><span></span></p><p><span>        </span><span>return</span><span> </span><span>nil</span><span></span></p><p><span>    </span><span>case</span><span> </span><span>&lt;-</span><span>ctx</span><span>.</span><span>Done</span><span>(</span><span>)</span><span>:</span><span></span></p><p><span>        s</span><span>.</span><span>mu</span><span>.</span><span>Lock</span><span>(</span><span>)</span><span></span></p><p><span>        </span><span>if</span><span> w</span><span>.</span><span>granted </span><span>{</span><span></span></p><p><span>            </span><span>// Permit was reserved for us, but we&#39;re canceling</span><span></span></p><p><span>            </span><span>// Must release the permit we own</span><span></span></p><p><span>            s</span><span>.</span><span>mu</span><span>.</span><span>Unlock</span><span>(</span><span>)</span><span></span></p><p><span>            s</span><span>.</span><span>Release</span><span>(</span><span>)</span><span></span></p><p><span>            </span><span>return</span><span> ctx</span><span>.</span><span>Err</span><span>(</span><span>)</span><span></span></p><p><span>        </span><span>}</span><span></span></p><p><span>        </span><span>// Not yet granted, remove from queue</span><span></span></p><p><span>        s</span><span>.</span><span>waiters</span><span>.</span><span>Remove</span><span>(</span><span>elem</span><span>)</span><span></span></p><p><span>        s</span><span>.</span><span>mu</span><span>.</span><span>Unlock</span><span>(</span><span>)</span><span></span></p><p><span>        </span><span>return</span><span> ctx</span><span>.</span><span>Err</span><span>(</span><span>)</span><span></span></p><p><span>    </span><span>}</span><span></span></p><p><span></span><span>}</span></p></div></div></pre><p>And <code>Release()</code> sets <code>granted = true</code> under the lock before waking the waiter:</p><pre><div><div><p><span>func</span><span> </span><span>(</span><span>s </span><span>*</span><span>Semaphore</span><span>)</span><span> </span><span>Release</span><span>(</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>    s</span><span>.</span><span>mu</span><span>.</span><span>Lock</span><span>(</span><span>)</span><span></span></p><p><span>    </span><span>if</span><span> s</span><span>.</span><span>free</span><span>+</span><span>1</span><span> </span><span>&gt;</span><span> s</span><span>.</span><span>max </span><span>{</span><span></span></p><p><span>        s</span><span>.</span><span>mu</span><span>.</span><span>Unlock</span><span>(</span><span>)</span><span></span></p><p><span>        </span><span>panic</span><span>(</span><span>&#34;semaphore: released more than acquired&#34;</span><span>)</span><span></span></p><p><span>    </span><span>}</span><span></span></p><p><span>    s</span><span>.</span><span>free</span><span>++</span><span></span></p><p><span>    </span><span>// Wake the first waiter if any</span><span></span></p><p><span>    </span><span>if</span><span> front </span><span>:=</span><span> s</span><span>.</span><span>waiters</span><span>.</span><span>Front</span><span>(</span><span>)</span><span>;</span><span> front </span><span>!=</span><span> </span><span>nil</span><span> </span><span>{</span><span></span></p><p><span>        w </span><span>:=</span><span> front</span><span>.</span><span>Value</span><span>.</span><span>(</span><span>*</span><span>waiter</span><span>)</span><span></span></p><p><span>        s</span><span>.</span><span>waiters</span><span>.</span><span>Remove</span><span>(</span><span>front</span><span>)</span><span></span></p><p><span>        s</span><span>.</span><span>free</span><span>--</span><span>        </span><span>// reserve permit for waiter</span><span></span></p><p><span>        w</span><span>.</span><span>granted </span><span>=</span><span> </span><span>true</span><span> </span><span>// mark granted under the lock</span><span></span></p><p><span>        s</span><span>.</span><span>mu</span><span>.</span><span>Unlock</span><span>(</span><span>)</span><span></span></p><p><span>        </span><span>close</span><span>(</span><span>w</span><span>.</span><span>ch</span><span>)</span><span> </span><span>// wake waiter</span><span></span></p><p><span>        </span><span>return</span><span></span></p><p><span>    </span><span>}</span><span></span></p><p><span>    s</span><span>.</span><span>mu</span><span>.</span><span>Unlock</span><span>(</span><span>)</span><span></span></p><p><span></span><span>}</span></p></div></div></pre><p>To put it all together, here&#39;s the semaphore being used in my original example at the top:</p><pre><div><div><p><span>g</span><span>,</span><span> ctx </span><span>:=</span><span> errgroup</span><span>.</span><span>WithContext</span><span>(</span><span>context</span><span>.</span><span>Background</span><span>(</span><span>)</span><span>)</span><span></span></p><p><span>sema </span><span>:=</span><span> </span><span>NewSemaphore</span><span>(</span><span>10</span><span>)</span><span></span></p><p><span></span><span>for</span><span> </span><span>_</span><span>,</span><span> path </span><span>:=</span><span> </span><span>range</span><span> files </span><span>{</span><span></span></p><p><span>    g</span><span>.</span><span>Go</span><span>(</span><span>func</span><span>(</span><span>p </span><span>string</span><span>)</span><span> </span><span>error</span><span> </span><span>{</span><span></span></p><p><span>        err </span><span>:=</span><span> sema</span><span>.</span><span>Acquire</span><span>(</span><span>ctx</span><span>)</span><span> </span><span>// acquire a permit (and wait if needed)</span><span></span></p><p><span>        </span><span>if</span><span> err </span><span>!=</span><span> </span><span>nil</span><span> </span><span>{</span><span></span></p><p><span>            </span><span>return</span><span> err</span></p><p><span>        </span><span>}</span><span></span></p><p><span>        </span><span>defer</span><span> sema</span><span>.</span><span>Release</span><span>(</span><span>)</span><span> </span><span>// release the permit when we return</span><span></span></p><p><span>        f</span><span>,</span><span> err </span><span>:=</span><span> os</span><span>.</span><span>Open</span><span>(</span><span>p</span><span>)</span><span></span></p><p><span>        </span><span>if</span><span> err </span><span>!=</span><span> </span><span>nil</span><span> </span><span>{</span><span></span></p><p><span>            </span><span>return</span><span> err</span></p><p><span>        </span><span>}</span><span></span></p><p><span>        </span><span>defer</span><span> f</span><span>.</span><span>Close</span><span>(</span><span>)</span><span></span></p><p><span>        </span><span>return</span><span> </span><span>processFile</span><span>(</span><span>f</span><span>)</span><span></span></p><p><span>    </span><span>}</span><span>(</span><span>path</span><span>)</span><span>)</span><span></span></p><p><span></span><span>}</span><span></span></p><p><span></span><span>if</span><span> err </span><span>:=</span><span> g</span><span>.</span><span>Wait</span><span>(</span><span>)</span><span>;</span><span> err </span><span>!=</span><span> </span><span>nil</span><span> </span><span>{</span><span></span></p><p><span>    </span><span>return</span><span> err</span></p><p><span></span><span>}</span></p></div></div></pre><p>In the end, a semaphore is &#34;just&#34; a counter plus a way to park goroutines until the counter says they can proceed. The surprising part is everything around that core: what order you unblock waiters in, what happens when work becomes irrelevant, and what invariants you need to keep to avoid deadlocks and leaks.</p><p>A plain buffered channel is a good-enough concurrency limiter but it doesn&#39;t give you FIFO semantics when many goroutines contend at once, and it doesn&#39;t naturally compose with cancellation.</p><h2 id="bugs-i-ran-into">Bugs I Ran Into</h2><p>While iterating on this semaphore, I ran into two particularly tricky bugs.</p><p>The first was a deadlock caused by <code>Release()</code> sending a message on an unbuffered channel without a listener:</p><ol start="1"><li><code>Release()</code> removes the waiter from the queue and is about to send the wake-up message</li><li>The waiter&#39;s <code>select</code> chooses <code>ctx.Done()</code> first and returns without receiving</li><li><code>Release()</code> blocks forever on the send because nobody is receiving anymore!</li></ol><p>I fixed this by closing the channel in <code>Release()</code> instead of sending an empty struct.</p><p>The second was a permit leak caused by trying to detect &#34;was I granted a permit?&#34; by checking whether the channel was closed. There was a race between <code>Release()</code> reserving the permit and the waiter observing that fact:</p><ol start="1"><li><code>Release()</code> reserves a permit for a waiter (<code>s.free--</code>)</li><li>The waiter&#39;s context is cancelled, the waiter re-locks</li><li>The waiter tries to infer &#34;granted&#34; from the channel state, gets the wrong answer</li><li>The waiter returns <code>ctx.Err()</code> without releasing the permit that was reserved for it</li></ol><p>That permit is gone forever. I fixed this with the <code>granted</code> flag — it&#39;s set under the lock, so the waiter can reliably check whether it owns a permit.</p><p>After I had everything working, I looked up the source code of the semaphore I would typically use, <a href="https://pkg.go.dev/golang.org/x/sync/semaphore">x/sync/semaphore</a> from Go&#39;s extended library. I found that it uses the same patterns: closing the channel to avoid the deadlock, and keeping all waiter state under the mutex to avoid the permit leak. The channel is just the notification mechanism, and the mutex-protected state is the source of truth.</p></div></div></div>
  </body>
</html>
