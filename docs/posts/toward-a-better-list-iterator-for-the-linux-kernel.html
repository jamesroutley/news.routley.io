<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lwn.net/SubscriberLink/887097/7ca69c6bfa3584c0/">Original</a>
    <h1>Toward a better list iterator for the Linux kernel</h1>
    
    <div id="readability-page-1" class="page"><div>
<!-- $Id: slink-none,v 1.2 2005-11-04 22:11:18 corbet Exp $ -->
<blockquote>
<div>
<h3>Welcome to LWN.net</h3>
<p>
The following subscription-only content has been made available to you 
by an LWN subscriber.  Thousands of subscribers depend on LWN for the 
best news from the Linux and free software communities.  If you enjoy this 
article, please consider <a href="https://lwn.net/subscribe/">subscribing to LWN</a>.  Thank you
for visiting LWN.net!
</p></div>
</blockquote>
<p>
Linked lists are conceptually straightforward; they tend to be taught
toward the beginning of entry-level data-structures classes.  It might thus
be surprising that the kernel community is concerned about its longstanding
linked-list implementation and is not only looking for ways to solve some
problems, but has been struggling to find that solution.  It now appears
that some improvements might be at hand: after more than 30 years, the kernel
developers may have found a better way to safely iterate through a linked list.
</p><h4>Kernel linked lists</h4>
<p>
C, of course, makes the creation of linked lists relatively easy.  What it
does not do, though, is help in the creation of <i>generic</i> linked lists
that can contain any type of structure.  By
its nature, C lends itself to the creation of ad hoc linked lists in every
situation where they are needed, resulting in boilerplate code and
duplicated definitions.  Every linked-list implementation must be reviewed
for correctness.  It would be far nicer to have a single implementation
that was known to work so that kernel developers could more profitably use
their time introducing bugs into code that is truly unique to their problem
area.
</p><p>
The kernel, naturally, has a few solutions for linked lists, but the most
commonly used is <a href="https://elixir.bootlin.com/linux/v5.17-rc5/source/include/linux/types.h#L177"><tt>struct
list_head</tt></a>:
</p><pre>    struct list_head {
	struct list_head *next, *prev;
    };
</pre>
<p>
This structure can be employed in the obvious way to create doubly linked
lists; a portion of such a list might look like:
</p><blockquote>
<img src="https://static.lwn.net/images/2022/list-head.svg" width="400"/>
</blockquote>
<p>
<tt>struct list_head</tt> can represent a linked list nicely, but has one significant
disadvantage: it cannot hold any other information.  Usually, this kind of
data structure is needed to link some other data of interest; the list
structure by itself isn&#39;t the point.  C does not make it easy to
create a linked list with an arbitrary payload, but it <i>is</i> easy to
embed <tt>struct list_head</tt> inside the structure that the developer
actually wants to organize into a list:
</p><blockquote>
<img src="https://static.lwn.net/images/2022/list-head2.svg" width="400"/>
</blockquote>
<p>
This is how linked lists are typically constructed in the kernel.  Macros
like <a href="https://elixir.bootlin.com/linux/v5.16.12/source/tools/include/linux/kernel.h#L25"><tt>container_of()</tt></a>
can be used to turn a pointer to a <tt>list_head</tt> structure into a
pointer to the containing structure.  Code that works with linked lists
will almost always use this macro (often indirectly) to gain access to
the larger payload.
</p><p>
One final detail that is worthy of note is that the actual head of the list
tends to be a <tt>list_head</tt> structure that is not embedded within the
structure type of interest:
</p><blockquote>
<img src="https://static.lwn.net/images/2022/list-head3.svg" width="450"/>
</blockquote>
<p>
For a real-world example of how this infrastructure is used, consider <a href="https://elixir.bootlin.com/linux/latest/source/include/linux/fs.h#L615"><tt>struct
inode</tt></a>, which represents a file within a filesystem.  Inodes can be
on a lot of lists simultaneously, so <tt>struct inode</tt> contains no less
than five separate <tt>list_head</tt> structures; unfortunately, your
editor&#39;s meager artistic skills are not up to the task of showing what the
resulting data structure looks like.  One of those <tt>list_head</tt>
structures,  
<tt>i_sb_list</tt>, is used to associate the inode with the superblock of
the filesystem it belongs to.  The <tt>list_head</tt>
structure that anchors this list is the <tt>s_inodes</tt> field of <a href="https://elixir.bootlin.com/linux/latest/source/include/linux/fs.h#L1463"><tt>struct
super_block</tt></a>.  That is the one <tt>list_head</tt> structure in this
particular list that is not embedded within an instance of <tt>struct
inode</tt>. 
</p><p>
Traversal of a linked list will typically begin at the anchor and follow
the <tt>next</tt> pointers until the head is found again.  One can, of
course, open-code this traversal, but the kernel also provides <a href="https://elixir.bootlin.com/linux/v5.17-rc5/source/include/linux/list.h">a
long list of functions and macros</a> for this purpose.  One of those is
<a href="https://elixir.bootlin.com/linux/v5.17-rc5/source/scripts/kconfig/list.h#L43"><tt>list_for_each_entry()</tt></a>,
which will go through the entire list, providing a pointer to the
containing structure at each node.  Typical code using this macro <a href="https://elixir.bootlin.com/linux/v5.17-rc5/source/fs/drop_caches.c#L18">looks
like this</a>:
</p><pre>    struct inode *inode;

    /* ... */
    list_for_each_entry(inode, &amp;sb-&gt;s_inodes, i_sb_list) {
	/* Process each inode here */
    }
    /* Should not use the iterator here */
</pre>
<p>

Within the loop, the macro uses <tt>container_of()</tt> to point
<tt>inode</tt> at the containing <tt>inode</tt> structure for each list entry.  The
problem is: what is the value of <tt>inode</tt> on exit from the loop?
If code exited the loop with a <tt>break</tt> statement, <tt>inode</tt>
will point to the element under consideration at that time.  If, however,
execution passes through the entire list, <tt>inode</tt> will be the
result of using <tt>container_of()</tt> on the separate list head, which is
not contained within an <tt>inode</tt> structure.  That puts the kernel
deeply into undefined-behavior territory and could lead to any of a number
of bad things.
</p><p>
For this reason, the rule for macros like <tt>list_for_each_entry()</tt> is
that the iterator variable should not be used outside of the loop.  If a
value needs to be accessed after the loop, it should be saved in a separate
variable for that purpose.  It&#39;s an
implicit rule, though; nobody felt the need to actually note this
restriction in the documentation for the macros themselves.
Unsurprisingly, this rule is thus more of a guideline at best; the kernel
is full of code that does, indeed, use the iterator variable after the
loop.
</p><h4>The search for a safer iterator</h4>
<p>
When we last <a href="https://lwn.net/Articles/885941/">looked at this issue</a>, Jakob
Koschel had posted patches fixing some of these sites; he 
<a href="https://lwn.net/ml/linux-kernel/20220228110822.491923-1-jakobkoschel@gmail.com/">continued
this project</a> afterward.  Linus
Torvalds, however, <a href="https://lwn.net/ml/linux-kernel/CAHk-=whLK11HyvpUtEftOjc3Gup2V77KpAQ2fycj3uai=qceHw@mail.gmail.com/">thought
that this approach was inadequate</a> because it did nothing to prevent future
problems from being introduced:
</p><blockquote>
	So if we have the basic rule being &#34;don&#39;t use the loop iterator
	after the loop has finished, because it can cause all kinds of
	subtle issues&#34;, then in _addition_ to fixing the existing code
	paths that have this issue, I really would want to (a) get a
	compiler warning for future cases and (b) make it not actually
	_work_ for future cases.
<p>
	Because otherwise it will just happen again.
</p></blockquote>
<p>
Along the way, the developers came to the realization that moving to a
newer version of the C 
standard might help, since it would allow the declaration of the iterator
variable within the loop itself (thus making it invisible outside of the
loop).  Torvalds <a href="https://lwn.net/Articles/887189/">made
an initial attempt</a> at a solution that looked like this:
</p><pre>    #define list_for_each_entry(pos, head, member)				\
	for (typeof(pos) __iter = list_first_entry(head, typeof(*pos), member);	\
	     !list_entry_is_head(__iter, head, member) &amp;&amp; (((pos)=__iter),1);	\
	     __iter = list_next_entry(__iter, member))
</pre>
<p>
This version of the macro still accepts the iterator variable as an
argument, keeping the same prototype as before; this is important, since
there are thousands of instances of this macro in the kernel source.  But
it declares a new variable to do the actually iteration, and only sets the
passed-in iterator within the loop itself.  Since the loop itself may never
be executed (if the list is empty), the possibility exists that it will not
set the iterator, so it could be uninitialized afterward.
</p><p>
This version was quickly followed by <a href="https://lwn.net/ml/linux-kernel/CAHk-=wiTCvLQkHcJ3y0hpqH7FEk9D28LDvZZogC6OVLk7naBww@mail.gmail.com/">a
second attempt</a>, described as &#34;<span>a work of art</span>&#34;:
</p><pre>    #define list_for_each_entry(pos, head, member)				\
	for (typeof(pos) pos = list_first_entry(head, typeof(*pos), member);	\
	     !list_entry_is_head(pos, head, member);				\
 	     pos = list_next_entry(pos, member))
</pre>
<p>
Now the loop-scope iteration variable is declared with the same name as the
outer variable, shadowing it.  With this version, the iterator variable
declared in the outer scope will never be used within the loop at all.

</p><p>
Torvalds&#39;s hope with both of these attempts was that this would cause the compiler to
generate warnings if the (outer) iterator was used outside the loop, since
it will no longer have been initialized by the loop itself.  That did not
work, though; there are places in the code that explicitly initialize the
iterator now and, in any case, the &#34;use of uninitialized variable&#34; warning
is disabled in the kernel due to excessive false positives.
</p><p>
James Bottomley <a href="https://lwn.net/ml/linux-kernel/73fa82a20910c06784be2352a655acc59e9942ea.camel@HansenPartnership.com/">suggested</a>
a different approach:
</p><pre>    #define list_for_each_entry(pos, head, member)				\
	for (pos = list_first_entry(head, typeof(*pos), member);		\
	     !list_entry_is_head(pos, head, member) &amp;&amp; ((pos = NULL) == NULL;	\
	     pos = list_next_entry(pos, member))
</pre>
<p>
This version would explicitly set the iterator variable to <tt>NULL</tt> on
exit from the loop, causing any code that uses it to (presumably) fail.
Torvalds <a href="https://lwn.net/ml/linux-kernel/CAHk-=wiT5HX6Kp0Qv4ZYK_rkq9t5fZ5zZ7vzvi6pub9kgp=72g@mail.gmail.com/">pointed
out</a> the obvious problem with this attempt: it changes the semantics of
a macro that is widely used throughout the kernel and would likely introduce
bugs.  It would also make life difficult for developers backporting patches
to stable kernels that didn&#39;t have the newer semantics.
</p><p>
Yet another approach was <a href="https://lwn.net/ml/linux-kernel/20220301075839.4156-3-xiam0nd.tong@gmail.com/">proposed</a>
by Xiaomeng Tong:
</p><pre>    #define list_for_each_entry_inside(pos, type, head, member)		\
	for (type * pos = list_first_entry(head, type, member);		\
	     !list_entry_is_head(pos, head, member);			\
	     pos = list_next_entry(pos, member))
</pre>
<p>
Tong&#39;s patch set created a new set of macros, with new names, with the idea
that existing code could be converted over one usage at a time.  There
would be no externally declared iterator at all; instead, the name and type
of the iterator are passed as arguments, and the iterator is declared
within the scope of the loop itself.  Torvalds, however, <a href="https://lwn.net/ml/linux-kernel/CAHk-=whJX52b1jNsmzXeVr6Z898R=9rBcSYx2oLt69XKDbqhOg@mail.gmail.com/">disliked
this approach</a> as well.  Its use leads to long, difficult-to-read lines
of code in almost every use and, he said, puts the pain in the wrong place:
&#34;<span>We should strive for the *bad* cases to have to do extra work, and 
even there we should really strive for legibility</span>&#34;.
</p><h4>A solution at last?</h4>
<p>
After having rejected various solutions, Torvalds went off to think about
what a good solution might look like.  Part of the problem, he <a href="https://lwn.net/ml/linux-kernel/CAHk-=wjesxw9U6JvTw34FREFAsayEE196Fi=VHtJXL8_9wgi=A@mail.gmail.com/">concluded</a>,
is that the type of the containing structure is separate from the
<tt>list_head</tt> structure, making the writing of iterator macros harder.
If those two types could be joined somehow, things would be easier.
Shortly thereafter, he <a href="https://lwn.net/ml/linux-kernel/CAHk-=wiacQM76xec=Hr7cLchVZ8Mo9VDHmXRJzJ_EX4sOsApEA@mail.gmail.com/">came
up with a solution</a> that implements this idea.  It starts with a new
declaration macro:
</p><pre>     #define list_traversal_head(type,name,target_member) \
	union { struct list_head name; type *name##_traversal_type; }
</pre>
<p>
This macro would be used to declare the real head of the list — not the
<tt>list_head</tt> entries contained within other structures.
Specifically, it declares a variable of this new union type containing a
<tt>list_head</tt> structure called <tt>name</tt>, and a pointer to the containing
structure <tt>type</tt> called <tt><i>name</i>_traversal_type</tt>.  The
pointer is never used as such; it is just a way of tying the type of the
containing structure to the <tt>list_head</tt> variable.
</p><p>
Then, there is a new iterator:
</p><pre>    #define list_traverse(pos, head, member) \
	for (typeof(*head##_traversal_type) pos = list_first_entry(head, typeof(*pos), member);\
	    !list_entry_is_head(pos, head, member);	\
	    pos = list_next_entry(pos, member))
</pre>
<p>
Code can walk through a list by using <tt>list_traverse()</tt> instead of
<tt>list_for_each_entry()</tt>.  The iterator variable will be
<tt>pos</tt>; it will only exist within the loop itself.  The anchor of the
list is passed as <tt>head</tt>, while <tt>member</tt> is the name of the
<tt>list_head</tt> structure within the containing structure.  The patch
includes a couple of conversions to show what the usage would look like.
</p><p>
This, Torvalds <a href="https://lwn.net/ml/linux-kernel/CAHk-=wjnsmmGdh-SZzaPD=e1rKhoBkQAF3JeVhGvpa=Gax--7g@mail.gmail.com/">thinks</a>,
is &#34;<span>the way forward</span>&#34;.  Making this change is probably a
years-long project; there are over 15,000 uses of
<tt>list_for_each_entry()</tt> (and variants) within the kernel.  Each of
those will eventually need to be changed, and the declaration of the list
anchor must also change at the same time.  So it is not a quick fix, but it
could lead to a safer linked-list implementation in the kernel in the long
run.
</p><p>
One might argue that all of this is self-inflicted pain caused by the
continued use of C in the kernel.  That may be true, but better
alternatives are in somewhat short supply.  For example, since the Rust
language, for all of its merits, <a href="https://rust-unofficial.github.io/too-many-lists/">does not make life
easy</a> for anybody wanting to implement a linked list, a
switch to that language would not automatically solve the problem.  So
kernel developers seem likely to have to get by with this kind of tricky
infrastructure for some time yet.<br clear="all"/></p>
               </div></div>
  </body>
</html>
