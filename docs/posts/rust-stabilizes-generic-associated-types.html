<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/rust-lang/rust/pull/96709">Original</a>
    <h1>Rust stabilizes generic associated types</h1>
    
    <div id="readability-page-1" class="page"><div>
        <div>
  
  <task-lists disabled="" sortable="">
    <div>
      <p dir="auto"><span aria-label="This pull request closes issue #44265.">Closes</span> <a data-error-text="Failed to load title" data-id="254795552" data-permission-text="Title is private" data-url="https://github.com/rust-lang/rust/issues/44265" data-hovercard-type="issue" data-hovercard-url="/rust-lang/rust/issues/44265/hovercard" href="https://github.com/rust-lang/rust/issues/44265">#44265</a></p>
<p dir="auto">r? <a data-hovercard-type="user" data-hovercard-url="/users/nikomatsakis/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/nikomatsakis">@nikomatsakis</a></p>

<ul>
<li> There have been several serious concerns raised, <a href="https://github.com/rust-lang/rust/pull/96709#issuecomment-1129311660" data-hovercard-type="pull_request" data-hovercard-url="/rust-lang/rust/pull/96709/hovercard">summarized here</a>.</li>
<li> There has also been a <a href="https://github.com/rust-lang/rust/pull/96709#issuecomment-1167220240" data-hovercard-type="pull_request" data-hovercard-url="/rust-lang/rust/pull/96709/hovercard">deep-dive comment</a> explaining some of the &#34;patterns of code&#34; that are enabled by GATs, based on use-cases posted to this thread or on the tracking issue.</li>
<li> We have modeled some aspects of GATs in <a href="https://github.com/nikomatsakis/a-mir-formality">a-mir-formality</a> to give better confidence in how they will be resolved in the future. <a href="https://github.com/rust-lang/types-team/blob/master/minutes/2022-07-08-implied-bounds-and-wf-checking.md">You can read a write-up here</a>.</li>
<li> The major points of the discussion have been <a href="https://rust-lang.github.io/generic-associated-types-initiative/mvp.html" rel="nofollow">summarized on the GAT initiative repository</a>.</li>
<li> <a href="https://github.com/rust-lang/rust/pull/96709#issuecomment-1129311660" data-hovercard-type="pull_request" data-hovercard-url="/rust-lang/rust/pull/96709/hovercard">FCP has been proposed</a> and we are awaiting final decisions and discussion amidst the relevant team members.</li>
</ul>

<p dir="auto">This PR proposes the stabilization of <code>#![feature(generic_associated_types)]</code>. While there a number of future additions to be made and bugs to be fixed (both discussed below), properly doing these will require significant language design and will ultimately likely be backwards-compatible. Given the overwhelming desire to have some form of generic associated types (GATs) available on stable and the stability of the &#34;simple&#34; uses, stabilizing the current subset of GAT features is almost certainly the correct next step.</p>
<p dir="auto">Tracking issue: <a data-error-text="Failed to load title" data-id="254795552" data-permission-text="Title is private" data-url="https://github.com/rust-lang/rust/issues/44265" data-hovercard-type="issue" data-hovercard-url="/rust-lang/rust/issues/44265/hovercard" href="https://github.com/rust-lang/rust/issues/44265">#44265</a></p>
<h2 dir="auto">Motivation</h2>
<p dir="auto">There are a myriad of potential use cases for GATs. Stabilization unblocks probable future language features (e.g. async functions in traits), potential future standard library features (e.g. a <code>LendingIterator</code> or some form of <code>Iterator</code> with a lifetime generic), and a plethora of user use cases (some of which can be seen just by scrolling through the tracking issue and looking at all the issues linking to it).</p>
<p dir="auto">There are a myriad of potential use cases for GATs. First, there are many users that have chosen to not use GATs primarily because they are not stable (some of which can be seen just by scrolling through the tracking issue and looking at all the issues linking to it). Second, while language feature desugaring isn&#39;t <em>blocked</em> on stabilization, it gives more confidence on using the feature. Likewise, library features like <code>LendingIterator</code> are not necessarily blocked on stabilization to be implemented unstably; however few, if any, public-facing APIs actually use unstable features.</p>
<p dir="auto">This feature has a long history of design, discussion, and developement - the RFC was first introduced roughly 6 years ago. While there are still a number of features left to implement and bugs left to fix, it&#39;s clear that it&#39;s unlikely those will have backwards-incompatibility concerns. Additionally, the bugs that do exist do not strongly impede the most-common use cases.</p>
<h2 dir="auto">What is stabilized</h2>
<p dir="auto">The primary language feature stabilized here is the ability to have generics on associated types, as so. Additionally, where clauses on associated types will now be accepted, regardless if the associated type is generic or not.</p>
<div dir="auto" data-snippet-clipboard-copy-content="trait ATraitWithGATs {
    type Assoc&lt;&#39;a, T&gt; where T: &#39;a;
}

trait ATraitWithoutGATs&lt;&#39;a, T&gt; {
    type Assoc where T: &#39;a;
}"><pre><span>trait</span> <span>ATraitWithGATs</span> <span>{</span>
    <span>type</span> <span>Assoc</span><span>&lt;</span><span>&#39;</span>a<span>,</span> <span>T</span><span>&gt;</span> <span>where</span> <span>T</span><span>:</span> <span>&#39;</span>a<span>;</span>
<span>}</span>

<span>trait</span> <span>ATraitWithoutGATs</span><span>&lt;</span><span>&#39;</span>a<span>,</span> <span>T</span><span>&gt;</span> <span>{</span>
    <span>type</span> <span>Assoc</span> where <span>T</span><span>:</span> <span>&#39;</span>a<span>;</span>
<span>}</span></pre></div>
<p dir="auto">When adding an impl for a trait with generic associated types, the generics for the associated type are copied as well. Note that where clauses are allowed both after the specified type and before the equals sign; however, the latter is a warn-by-default deprecation.</p>
<div dir="auto" data-snippet-clipboard-copy-content="struct X;
struct Y;

impl ATraitWithGATs for X {
    type Assoc&lt;&#39;a, T&gt; = &amp;&#39;a T
      where T: &#39;a;
}
impl ATraitWithGATs for Y {
    type Assoc&lt;&#39;a, T&gt;
      where T: &#39;a
    = &amp;&#39;a T;
}"><pre><span>struct</span> <span>X</span><span>;</span>
<span>struct</span> <span>Y</span><span>;</span>

<span>impl</span> <span>ATraitWithGATs</span> <span>for</span> <span>X</span> <span>{</span>
    <span>type</span> <span>Assoc</span><span>&lt;</span><span>&#39;</span>a<span>,</span> <span>T</span><span>&gt;</span> = <span>&amp;</span><span>&#39;</span>a <span>T</span>
      <span>where</span> <span>T</span><span>:</span> <span>&#39;</span>a<span>;</span>
<span>}</span>
<span>impl</span> <span>ATraitWithGATs</span> <span>for</span> <span>Y</span> <span>{</span>
    <span>type</span> <span>Assoc</span><span>&lt;</span><span>&#39;</span>a<span>,</span> <span>T</span><span>&gt;</span>
      <span>where</span> <span>T</span><span>:</span> <span>&#39;</span>a
    = <span>&amp;</span><span>&#39;</span>a <span>T</span><span>;</span>
<span>}</span></pre></div>
<p dir="auto">To use a GAT in a function, generics are specified on the associated type, as if it was a struct or enum. GATs can also be specified in trait bounds:</p>
<div dir="auto" data-snippet-clipboard-copy-content="fn accepts_gat&lt;&#39;a, T&gt;(t: &amp;&#39;a T) -&gt; T::Assoc&lt;&#39;a, T&gt;
  where for&lt;&#39;x&gt; T: ATraitWithGATs&lt;Assoc&lt;&#39;a, T&gt; = &amp;&#39;a T&gt; {
    ...
}"><pre><span>fn</span> <span>accepts_gat</span><span>&lt;</span><span>&#39;</span>a<span>,</span> <span>T</span><span>&gt;</span><span>(</span><span>t</span><span>:</span> <span>&amp;</span><span>&#39;</span>a <span>T</span><span>)</span> -&gt; <span>T</span><span>::</span><span>Assoc</span><span>&lt;</span><span>&#39;</span>a<span>,</span> <span>T</span><span>&gt;</span>
  <span>where</span> <span>for</span><span>&lt;</span><span>&#39;</span>x<span>&gt;</span> <span>T</span><span>:</span> <span>ATraitWithGATs</span><span>&lt;</span><span>Assoc</span><span>&lt;</span><span>&#39;</span>a<span>,</span> <span>T</span><span>&gt;</span> = <span>&amp;</span><span>&#39;</span>a <span>T</span><span>&gt;</span> <span>{</span>
    ..<span>.</span><span></span>
<span>}</span></pre></div>
<p dir="auto">GATs can also appear in trait methods. However, depending on how they are used, they may confer where clauses on the associated type definition. More information can be found <a href="https://github.com/rust-lang/rust/issues/87479" data-hovercard-type="issue" data-hovercard-url="/rust-lang/rust/issues/87479/hovercard">here</a>. Briefly, where clauses are required when those bounds can be proven in the methods that <em>construct</em> the GAT or other associated types that use the GAT in the trait. This allows impls to have maximum flexibility in the types defined for the associated type.</p>
<p dir="auto">To take a relatively simple example:</p>
<div dir="auto" data-snippet-clipboard-copy-content="trait Iterable {
    type Item&lt;&#39;a&gt;;
    type Iterator&lt;&#39;a&gt;: Iterator&lt;Item = Self::Item&lt;&#39;a&gt;&gt;;

    fn iter&lt;&#39;x&gt;(&amp;&#39;x self) -&gt; Self::Iterator&lt;&#39;x&gt;;
    //^ We know that `Self: &#39;a` for `Iterator&lt;&#39;a&gt;`, so we require that bound on `Iterator`
    //  `Iterator` uses `Self::Item`, so we also require a `Self: &#39;a` on `Item` too
}"><pre><span>trait</span> <span>Iterable</span> <span>{</span>
    <span>type</span> <span>Item</span><span>&lt;</span><span>&#39;</span>a<span>&gt;</span><span>;</span>
    <span>type</span> <span>Iterator</span><span>&lt;</span><span>&#39;</span>a<span>&gt;</span><span>:</span> <span>Iterator</span><span>&lt;</span><span>Item</span> = <span>Self</span><span>::</span><span>Item</span><span>&lt;</span><span>&#39;</span>a<span>&gt;</span><span>&gt;</span><span>;</span>

    <span>fn</span> <span>iter</span><span>&lt;</span><span>&#39;</span>x<span>&gt;</span><span>(</span><span>&amp;</span><span>&#39;</span>x <span>self</span><span>)</span> -&gt; <span>Self</span><span>::</span><span>Iterator</span><span>&lt;</span><span>&#39;</span>x<span>&gt;</span><span>;</span>
    <span>//^ We know that `Self: &#39;a` for `Iterator&lt;&#39;a&gt;`, so we require that bound on `Iterator`</span>
    <span>//  `Iterator` uses `Self::Item`, so we also require a `Self: &#39;a` on `Item` too</span>
<span>}</span></pre></div>
<p dir="auto">A couple well-explained examples are available in a previous <a href="https://blog.rust-lang.org/2021/08/03/GATs-stabilization-push.html" rel="nofollow">blog post</a>.</p>
<h2 dir="auto">What isn&#39;t stabilized/implemented</h2>
<h3 dir="auto">Universal type/const quantification</h3>
<p dir="auto">Currently, you can write a bound like <code>X: for&lt;&#39;a&gt; Trait&lt;Assoc&lt;&#39;a&gt; = &amp;&#39;a ()&gt;</code>. However, you cannot currently write <code>for&lt;T&gt; X: Trait&lt;Assoc&lt;T&gt; = T&gt;</code> or <code>for&lt;const N&gt; X: Trait&lt;Assoc&lt;N&gt; = [usize; N]&gt;</code>.</p>
<p dir="auto">Here is an example where this is needed:</p>
<div dir="auto" data-snippet-clipboard-copy-content="trait Foo {}

trait Trait {
    type Assoc&lt;F: Foo&gt;;
}

trait Trait2: Sized {
    fn foo&lt;F: Foo, T: Trait&lt;Assoc&lt;F&gt; = F&gt;&gt;(_t: T);
}"><pre><span>trait</span> <span>Foo</span> <span>{</span><span>}</span>

<span>trait</span> <span>Trait</span> <span>{</span>
    <span>type</span> <span>Assoc</span><span>&lt;</span><span>F</span><span>:</span> <span>Foo</span><span>&gt;</span><span>;</span>
<span>}</span>

<span>trait</span> <span>Trait2</span><span>:</span> <span>Sized</span> <span>{</span>
    <span>fn</span> <span>foo</span><span>&lt;</span><span>F</span><span>:</span> <span>Foo</span><span>,</span> <span>T</span><span>:</span> <span>Trait</span><span>&lt;</span><span>Assoc</span><span>&lt;</span><span>F</span><span>&gt;</span> = <span>F</span><span>&gt;</span><span>&gt;</span><span>(</span><span>_t</span><span>:</span> <span>T</span><span>)</span><span>;</span>
<span>}</span></pre></div>
<p dir="auto">In the above example, the <em>caller</em> must specify <code>F</code>, which is likely not what is desired.</p>
<h3 dir="auto">Object-safe GATs</h3>
<p dir="auto">Unlike non-generic associated types, traits with GATs are not currently object-safe. In other words the following are not allowed:</p>
<div dir="auto" data-snippet-clipboard-copy-content="trait Trait {
    type Assoc&lt;&#39;a&gt;;
}

fn foo(t: &amp;dyn for&lt;&#39;a&gt; Trait&lt;Assoc&lt;&#39;a&gt; = &amp;&#39;a ()&gt;) {}
         //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not allowed

let ty: Box&lt;dyn for&lt;&#39;a&gt; Trait&lt;Assoc&lt;&#39;a&gt; = &amp;&#39;a ()&gt;&gt;;
          //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not allowed"><pre><span>trait</span> <span>Trait</span> <span>{</span>
    <span>type</span> <span>Assoc</span><span>&lt;</span><span>&#39;</span>a<span>&gt;</span><span>;</span>
<span>}</span>

<span>fn</span> <span>foo</span><span>(</span>t<span>:</span> <span>&amp;</span><span>dyn</span> <span>for</span>&lt;<span>&#39;</span>a&gt; <span>Trait</span><span>&lt;</span><span>Assoc</span><span>&lt;</span><span>&#39;</span>a<span>&gt;</span> = <span>&amp;</span><span>&#39;</span>a <span>(</span><span>)</span><span>&gt;</span><span>)</span> <span>{</span><span>}</span>
         <span>//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not allowed</span>

<span>let</span> ty<span>:</span> <span>Box</span>&lt;<span>dyn</span> <span>for</span>&lt;<span>&#39;</span>a&gt; <span>Trait</span><span>&lt;</span><span>Assoc</span><span>&lt;</span><span>&#39;</span>a<span>&gt;</span> = <span>&amp;</span><span>&#39;</span>a <span>(</span><span>)</span><span>&gt;</span>&gt;<span>;</span>
          <span>//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not allowed</span></pre></div>
<h3 dir="auto">Higher-kinded types</h3>
<p dir="auto">You cannot write currently (and there are no current plans to implement this):</p>
<div dir="auto" data-snippet-clipboard-copy-content="struct Struct&lt;&#39;a&gt; {}

fn foo(s: for&lt;&#39;a&gt; Struct&lt;&#39;a&gt;) {}"><pre><span>struct</span> <span>Struct</span><span>&lt;</span><span>&#39;</span>a<span>&gt;</span> <span>{</span><span>}</span>

<span>fn</span> <span>foo</span><span>(</span>s<span>:</span> <span>for</span>&lt;<span>&#39;</span>a&gt; <span>Struct</span><span>&lt;</span><span>&#39;</span>a<span>&gt;</span><span>)</span> <span>{</span><span>}</span></pre></div>
<h2 dir="auto">Tests</h2>
<p dir="auto">There are many tests covering GATs that can be found in  <code>src/test/ui/generic-associated-types</code>. Here, I&#39;ll list (in alphanumeric order) tests highlight some important behavior or contain important patterns.</p>
<ul dir="auto">
<li><code>./parse/*</code>: Parsing of GATs in traits and impls, and the trait path with GATs</li>
<li><code>./collections-project-default.rs</code>: Interaction with associated type defaults</li>
<li><code>./collections.rs</code>: The <code>Collection</code> pattern</li>
<li><code>./const-generics-gat-in-trait-return-type-*.rs</code>: Const parameters</li>
<li><code>./constraint-assoc-type-suggestion.rs</code>: Emit correct syntax in suggestion</li>
<li><code>./cross-crate-bounds.rs</code>: Ensure we handles bounds across crates the same</li>
<li><code>./elided-in-expr-position.rs</code>: Disallow lifetime elision in return position</li>
<li><code>./gat-in-trait-path-undeclared-lifetime.rs</code>: Ensure we error on undeclared lifetime in trait path</li>
<li><code>./gat-in-trait-path.rs</code>: Base trait path case</li>
<li><code>./gat-trait-path-generic-type-arg.rs</code>: Don&#39;t allow shadowing of parameters</li>
<li><code>./gat-trait-path-parenthesised-args.rs</code>: Don&#39;t allow paranthesized args in trait path</li>
<li><code>./generic-associated-types-where.rs</code>: Ensure that we require where clauses from trait to be met on impl</li>
<li><code>./impl_bounds.rs</code>: Check that the bounds on GATs in an impl are checked</li>
<li><code>./issue-76826.rs</code>: <code>Windows</code> pattern</li>
<li><code>./issue-78113-lifetime-mismatch-dyn-trait-box.rs</code>: Implicit &#39;static diagnostics</li>
<li><code>./issue-84931.rs</code>: Ensure that we have a where clause on GAT to ensure trait parameter lives long enough</li>
<li><code>./issue-87258_a.rs</code>: Unconstrained opaque type with TAITs</li>
<li><code>./issue-87429-2.rs</code>: Ensure we can use bound vars in the bounds</li>
<li><code>./issue-87429-associated-type-default.rs</code>: Ensure bounds hold with associated type defaults, for both trait and impl</li>
<li><code>./issue-87429-specialization.rs</code>: Check that bounds hold under specialization</li>
<li><code>./issue-88595.rs</code>: Under the outlives lint, we require a bound for both trait and GAT lifetime when trait lifetime is used in function</li>
<li><code>./issue-90014.rs</code>: Lifetime bounds are checked with TAITs</li>
<li><code>./issue-91139.rs</code>: Under migrate mode, but not NLL, we don&#39;t capture implied bounds from HRTB lifetimes used in a function and GATs</li>
<li><code>./issue-91762.rs</code>: We used to too eagerly pick param env candidates when normalizing with GATs. We now require explicit parameters specified.</li>
<li><code>./issue-95305.rs</code>: Disallow lifetime elision in trait paths</li>
<li><code>./iterable.rs</code>: <code>Iterable</code> pattern</li>
<li><code>./method-unsatified-assoc-type-predicate.rs</code>: Print predicates with GATs correctly in method resolve error</li>
<li><code>./missing_lifetime_const.rs</code>: Ensure we must specify lifetime args (not elidable)</li>
<li><code>./missing-where-clause-on-trait.rs</code>: Ensure we don&#39;t allow stricter bounds on impl than trait</li>
<li><code>./parameter_number_and_kind_impl.rs</code>: Ensure paramters on GAT in impl match GAT in trait</li>
<li><code>./pointer_family.rs</code>: <code>PointerFamily</code> pattern</li>
<li><code>./projection-bound-cycle.rs</code>: Don&#39;t allow invalid cycles to prove bounds</li>
<li><code>./self-outlives-lint.rs</code>: Ensures that an e.g. <code>Self: &#39;a</code> is written on the traits GAT if that bound can be implied from the GAT usage in the trait</li>
<li><code>./shadowing.rs</code>: Don&#39;t allow lifetime shadowing in params</li>
<li><code>./streaming_iterator.rs</code>: <code>StreamingIterator</code>(<code>LendingIterator</code>) pattern</li>
<li><code>./trait-objects.rs</code>: Disallow trait objects for traits with GATs</li>
<li><code>./variance_constraints.rs</code>: Require that GAT substs be invariant</li>
</ul>
<h2 dir="auto">Remaining bugs and open issues</h2>
<p dir="auto">A full list of remaining open issues can be found at: 
<a id="label-d424d1" href="https://github.com/rust-lang/rust/labels/F-generic_associated_types" data-name="F-generic_associated_types" data-view-component="true">
  F-generic_associated_types</a>
  <tool-tip for="label-d424d1" data-direction="s" data-type="description" data-view-component="true">`#![feature(generic_associated_types)]` a.k.a. GATs</tool-tip>
</p>
<p dir="auto">There are some <code>known-bug</code> tests in-tree at <code>src/test/ui/generic-associated-types/bugs</code>.</p>
<p dir="auto">Here I&#39;ll categorize most of those that GAT bugs (or involve a pattern found more with GATs), but not those that include GATs but not a GAT issue in and of itself. (I also won&#39;t include issues directly for things listed elsewhere here.)</p>
<p dir="auto">Using the concrete type of a GAT instead of the projection type can give errors, since lifetimes are chosen to be early-bound vs late-bound.</p>
<ul dir="auto">
<li><span><svg title="Open" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M8 9.5a1.5 1.5 0 100-3 1.5 1.5 0 000 3z"></path><path fill-rule="evenodd" d="M8 0a8 8 0 100 16A8 8 0 008 0zM1.5 8a6.5 6.5 0 1113 0 6.5 6.5 0 01-13 0z"></path></svg><a data-error-text="Failed to load title" data-id="897604200" data-permission-text="Title is private" data-url="https://github.com/rust-lang/rust/issues/85533" data-hovercard-type="issue" data-hovercard-url="/rust-lang/rust/issues/85533/hovercard" href="https://github.com/rust-lang/rust/issues/85533">Intervening type alias of GAT to causes incorrect E0581<span> #85533</span></a></span></li>
<li><span><svg title="Open" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M8 9.5a1.5 1.5 0 100-3 1.5 1.5 0 000 3z"></path><path fill-rule="evenodd" d="M8 0a8 8 0 100 16A8 8 0 008 0zM1.5 8a6.5 6.5 0 1113 0 6.5 6.5 0 01-13 0z"></path></svg><a data-error-text="Failed to load title" data-id="962139799" data-permission-text="Title is private" data-url="https://github.com/rust-lang/rust/issues/87803" data-hovercard-type="issue" data-hovercard-url="/rust-lang/rust/issues/87803/hovercard" href="https://github.com/rust-lang/rust/issues/87803">Typecheck fails when providing explicit types instead of GAT<span> #87803</span></a></span></li>
</ul>
<p dir="auto">In certain cases, we can run into cycle or overflow errors. This is more generally a problem with associated types.</p>
<ul dir="auto">
<li><span><svg title="Open" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M8 9.5a1.5 1.5 0 100-3 1.5 1.5 0 000 3z"></path><path fill-rule="evenodd" d="M8 0a8 8 0 100 16A8 8 0 008 0zM1.5 8a6.5 6.5 0 1113 0 6.5 6.5 0 01-13 0z"></path></svg><a data-error-text="Failed to load title" data-id="960116388" data-permission-text="Title is private" data-url="https://github.com/rust-lang/rust/issues/87755" data-hovercard-type="issue" data-hovercard-url="/rust-lang/rust/issues/87755/hovercard" href="https://github.com/rust-lang/rust/issues/87755">Overflow evaluating the requirement with a where clause on associated type<span> #87755</span></a></span></li>
<li><span><svg title="Open" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M8 9.5a1.5 1.5 0 100-3 1.5 1.5 0 000 3z"></path><path fill-rule="evenodd" d="M8 0a8 8 0 100 16A8 8 0 008 0zM1.5 8a6.5 6.5 0 1113 0 6.5 6.5 0 01-13 0z"></path></svg><a data-error-text="Failed to load title" data-id="960308217" data-permission-text="Title is private" data-url="https://github.com/rust-lang/rust/issues/87758" data-hovercard-type="issue" data-hovercard-url="/rust-lang/rust/issues/87758/hovercard" href="https://github.com/rust-lang/rust/issues/87758">Stall from overflow caused by <code>for&lt;&#39;a&gt; F: FnOnce(Self::Gat&lt;&#39;a&gt;)</code><span> #87758</span></a></span></li>
</ul>
<p dir="auto">Bounds on an associatd type need to be proven by an impl, but where clauses need to be proven by the usage. This can lead to confusion when users write one when they mean the other.</p>
<ul dir="auto">
<li><span><svg title="Open" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M8 9.5a1.5 1.5 0 100-3 1.5 1.5 0 000 3z"></path><path fill-rule="evenodd" d="M8 0a8 8 0 100 16A8 8 0 008 0zM1.5 8a6.5 6.5 0 1113 0 6.5 6.5 0 01-13 0z"></path></svg><a data-error-text="Failed to load title" data-id="963031707" data-permission-text="Title is private" data-url="https://github.com/rust-lang/rust/issues/87831" data-hovercard-type="issue" data-hovercard-url="/rust-lang/rust/issues/87831/hovercard" href="https://github.com/rust-lang/rust/issues/87831">Inconsistent treatment of different kinds of trait bounds with GATs<span> #87831</span></a></span></li>
<li><span><svg title="Open" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M8 9.5a1.5 1.5 0 100-3 1.5 1.5 0 000 3z"></path><path fill-rule="evenodd" d="M8 0a8 8 0 100 16A8 8 0 008 0zM1.5 8a6.5 6.5 0 1113 0 6.5 6.5 0 01-13 0z"></path></svg><a data-error-text="Failed to load title" data-id="1044920202" data-permission-text="Title is private" data-url="https://github.com/rust-lang/rust/issues/90573" data-hovercard-type="issue" data-hovercard-url="/rust-lang/rust/issues/90573/hovercard" href="https://github.com/rust-lang/rust/issues/90573">HRTB with GAT behaving differently in associated type bound vs where clause<span> #90573</span></a></span></li>
</ul>
<p dir="auto">We sometimes can&#39;t normalize closure signatures fully. Really an asociated types issue, but might happen a bit more frequently with GATs, since more obvious place for HRTB lifetimes.</p>
<ul dir="auto">
<li><span><svg title="Open" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M8 9.5a1.5 1.5 0 100-3 1.5 1.5 0 000 3z"></path><path fill-rule="evenodd" d="M8 0a8 8 0 100 16A8 8 0 008 0zM1.5 8a6.5 6.5 0 1113 0 6.5 6.5 0 01-13 0z"></path></svg><a data-error-text="Failed to load title" data-id="980947309" data-permission-text="Title is private" data-url="https://github.com/rust-lang/rust/issues/88382" data-hovercard-type="issue" data-hovercard-url="/rust-lang/rust/issues/88382/hovercard" href="https://github.com/rust-lang/rust/issues/88382">Wrong (?) [E0631] signature mismatch for function with Fn trait arguments with GAT arguments<span> #88382</span></a></span></li>
</ul>
<p dir="auto">When calling a function, we assign types to parameters &#34;too late&#34;, after we already try (and fail) to normalize projections. Another associated types issue that might pop up more with GATs.</p>
<ul dir="auto">
<li><span><svg title="Open" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M8 9.5a1.5 1.5 0 100-3 1.5 1.5 0 000 3z"></path><path fill-rule="evenodd" d="M8 0a8 8 0 100 16A8 8 0 008 0zM1.5 8a6.5 6.5 0 1113 0 6.5 6.5 0 01-13 0z"></path></svg><a data-error-text="Failed to load title" data-id="982103014" data-permission-text="Title is private" data-url="https://github.com/rust-lang/rust/issues/88460" data-hovercard-type="issue" data-hovercard-url="/rust-lang/rust/issues/88460/hovercard" href="https://github.com/rust-lang/rust/issues/88460">E0277 (bound not satisfied) for bound on generic associated types when combined with HRTB<span> #88460</span></a></span></li>
<li><span><svg title="Open" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M8 9.5a1.5 1.5 0 100-3 1.5 1.5 0 000 3z"></path><path fill-rule="evenodd" d="M8 0a8 8 0 100 16A8 8 0 008 0zM1.5 8a6.5 6.5 0 1113 0 6.5 6.5 0 01-13 0z"></path></svg><a data-error-text="Failed to load title" data-id="1208976558" data-permission-text="Title is private" data-url="https://github.com/rust-lang/rust/issues/96230" data-hovercard-type="issue" data-hovercard-url="/rust-lang/rust/issues/96230/hovercard" href="https://github.com/rust-lang/rust/issues/96230">Error typechecking lifetime-GAT bound when &#34;parent&#34; bound is inferred<span> #96230</span></a></span></li>
</ul>
<p dir="auto">We don&#39;t fully have implied bounds for lifetimes appearing in GAT trait paths, which can lead to unconstrained type errors.</p>
<ul dir="auto">
<li><span><svg title="Open" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M8 9.5a1.5 1.5 0 100-3 1.5 1.5 0 000 3z"></path><path fill-rule="evenodd" d="M8 0a8 8 0 100 16A8 8 0 008 0zM1.5 8a6.5 6.5 0 1113 0 6.5 6.5 0 01-13 0z"></path></svg><a data-error-text="Failed to load title" data-id="983578458" data-permission-text="Title is private" data-url="https://github.com/rust-lang/rust/issues/88526" data-hovercard-type="issue" data-hovercard-url="/rust-lang/rust/issues/88526/hovercard" href="https://github.com/rust-lang/rust/issues/88526">Introducing a GAT parameter leads to a false positive E0207 for another parameter constrained by Fn type<span> #88526</span></a></span></li>
</ul>
<p dir="auto">Suggestion for adding lifetime bounds can suggest unhelpful fixes (<code>T: &#39;a</code> instead of <code>Self: &#39;a</code>), but the next compiler error after making the suggested change is helpful.</p>
<ul dir="auto">
<li><span><svg title="Open" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M8 9.5a1.5 1.5 0 100-3 1.5 1.5 0 000 3z"></path><path fill-rule="evenodd" d="M8 0a8 8 0 100 16A8 8 0 008 0zM1.5 8a6.5 6.5 0 1113 0 6.5 6.5 0 01-13 0z"></path></svg><a data-error-text="Failed to load title" data-id="1051467069" data-permission-text="Title is private" data-url="https://github.com/rust-lang/rust/issues/90816" data-hovercard-type="issue" data-hovercard-url="/rust-lang/rust/issues/90816/hovercard" href="https://github.com/rust-lang/rust/issues/90816">Wrong <code>where Self: &#39;a</code> GAT bound suggested<span> #90816</span></a></span></li>
<li><span><svg title="Open" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M8 9.5a1.5 1.5 0 100-3 1.5 1.5 0 000 3z"></path><path fill-rule="evenodd" d="M8 0a8 8 0 100 16A8 8 0 008 0zM1.5 8a6.5 6.5 0 1113 0 6.5 6.5 0 01-13 0z"></path></svg><a data-error-text="Failed to load title" data-id="1084014265" data-permission-text="Title is private" data-url="https://github.com/rust-lang/rust/issues/92096" data-hovercard-type="issue" data-hovercard-url="/rust-lang/rust/issues/92096/hovercard" href="https://github.com/rust-lang/rust/issues/92096">GAT <code>Self: &#39;a</code> bounds break some <code>async</code> blocks with <code>impl Trait</code><span> #92096</span></a></span></li>
<li><span><svg title="Open" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M8 9.5a1.5 1.5 0 100-3 1.5 1.5 0 000 3z"></path><path fill-rule="evenodd" d="M8 0a8 8 0 100 16A8 8 0 008 0zM1.5 8a6.5 6.5 0 1113 0 6.5 6.5 0 01-13 0z"></path></svg><a data-error-text="Failed to load title" data-id="1179221117" data-permission-text="Title is private" data-url="https://github.com/rust-lang/rust/issues/95268" data-hovercard-type="issue" data-hovercard-url="/rust-lang/rust/issues/95268/hovercard" href="https://github.com/rust-lang/rust/issues/95268">No syntactic way to specify GATs with where bounds in where clauses<span> #95268</span></a></span></li>
</ul>
<p dir="auto">We can end up requiring that <code>for&lt;&#39;a&gt; I: &#39;a</code> when we really want <code>for&lt;&#39;a where I: &#39;a&gt; I: &#39;a</code>. This can leave unhelpful errors than effectively can&#39;t be satisfied unless <code>I: &#39;static</code>. Requires bigger changes and not only GATs.</p>
<ul dir="auto">
<li><span><svg title="Open" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M8 9.5a1.5 1.5 0 100-3 1.5 1.5 0 000 3z"></path><path fill-rule="evenodd" d="M8 0a8 8 0 100 16A8 8 0 008 0zM1.5 8a6.5 6.5 0 1113 0 6.5 6.5 0 01-13 0z"></path></svg><a data-error-text="Failed to load title" data-id="1075158542" data-permission-text="Title is private" data-url="https://github.com/rust-lang/rust/issues/91693" data-hovercard-type="issue" data-hovercard-url="/rust-lang/rust/issues/91693/hovercard" href="https://github.com/rust-lang/rust/issues/91693">lifetime bound not satisfied for a lending iterator (using generic associated types) with <code>for_each</code> method<span> #91693</span></a></span></li>
</ul>
<p dir="auto">Unlike with non-generic associated types, we don&#39;t eagerly normalize with param env candidates. This is intended behavior (for now), to avoid accidentaly stabilizing picking arbitrary impls.</p>
<ul dir="auto">
<li><span><svg title="Open" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M8 9.5a1.5 1.5 0 100-3 1.5 1.5 0 000 3z"></path><path fill-rule="evenodd" d="M8 0a8 8 0 100 16A8 8 0 008 0zM1.5 8a6.5 6.5 0 1113 0 6.5 6.5 0 01-13 0z"></path></svg><a data-error-text="Failed to load title" data-id="1077262526" data-permission-text="Title is private" data-url="https://github.com/rust-lang/rust/issues/91762" data-hovercard-type="issue" data-hovercard-url="/rust-lang/rust/issues/91762/hovercard" href="https://github.com/rust-lang/rust/issues/91762">Typecheck error when using a equality-constrained GAT in a trait.<span> #91762</span></a></span></li>
</ul>
<p dir="auto">Some Iterator adapter patterns (namely <code>filter</code>) require Polonius or unsafe to work.</p>
<ul dir="auto">
<li><span><svg title="Open" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M8 9.5a1.5 1.5 0 100-3 1.5 1.5 0 000 3z"></path><path fill-rule="evenodd" d="M8 0a8 8 0 100 16A8 8 0 008 0zM1.5 8a6.5 6.5 0 1113 0 6.5 6.5 0 01-13 0z"></path></svg><a data-error-text="Failed to load title" data-id="1105207002" data-permission-text="Title is private" data-url="https://github.com/rust-lang/rust/issues/92985" data-hovercard-type="issue" data-hovercard-url="/rust-lang/rust/issues/92985/hovercard" href="https://github.com/rust-lang/rust/issues/92985">Filter adapter for <code>LendingIterator</code> requires Polonius<span> #92985</span></a></span></li>
</ul>
<h2 dir="auto">Potential Future work</h2>
<h3 dir="auto">Universal type/const quantification</h3>
<p dir="auto">No work has been done to implement this. There are also some questions around implied bounds.</p>
<h3 dir="auto">Object-safe GATs</h3>
<p dir="auto">The intention is to make traits with GATs object-safe. There are some design work to be done around well-formedness rules and general implementation.</p>
<h3 dir="auto">GATified std lib types</h3>
<p dir="auto">It would be helpful to either introduce new std lib traits (like <code>LendingIterator</code>) or to modify existing ones (adding a <code>&#39;a</code> generic to <code>Iterator::Item</code>). There also a number of other candidates, like <code>Index</code>/<code>IndexMut</code> and <code>Fn</code>/<code>FnMut</code>/<code>FnOnce</code>.</p>
<h3 dir="auto">Reduce the need for <code>for&lt;&#39;a&gt;</code></h3>
<p dir="auto">Seen <a href="https://github.com/rust-lang/rfcs/pull/1598#issuecomment-2611378730" data-hovercard-type="pull_request" data-hovercard-url="/rust-lang/rfcs/pull/1598/hovercard">here</a>. One possible syntax:</p>
<div dir="auto" data-snippet-clipboard-copy-content="trait Iterable {
    type Iter&lt;&#39;a&gt;: Iterator&lt;Item = Self::Item&lt;&#39;a&gt;&gt;;
}

fn foo&lt;T&gt;() where T: Iterable, T::Item&lt;let &#39;a&gt;: Display { } //note the `let`!"><pre><span>trait</span> <span>Iterable</span> <span>{</span>
    <span>type</span> <span>Iter</span><span>&lt;</span><span>&#39;</span>a<span>&gt;</span><span>:</span> <span>Iterator</span><span>&lt;</span><span>Item</span> = <span>Self</span><span>::</span><span>Item</span><span>&lt;</span><span>&#39;</span>a<span>&gt;</span><span>&gt;</span><span>;</span>
<span>}</span>

<span>fn</span> <span>foo</span><span>&lt;</span><span>T</span><span>&gt;</span><span>(</span><span>)</span> <span>where</span> <span>T</span><span>:</span> <span>Iterable</span><span>,</span> <span>T</span><span>::</span><span>Item</span><span>&lt;</span>let <span>&#39;</span>a<span>&gt;</span><span>:</span> <span>Display</span> <span>{</span> <span>}</span> <span>//note the `let`!</span></pre></div>
<h3 dir="auto">Better implied bounds on higher-ranked things</h3>
<p dir="auto">Currently if we have a <code>type Item&lt;&#39;a&gt; where self: &#39;a</code>, and a <code>for&lt;&#39;a&gt; T: Iterator&lt;Item&lt;&#39;a&gt; = &amp;&#39;a ()</code>, this requires <code>for&lt;&#39;a&gt; Self: &#39;a</code>. Really, we want <code>for&lt;&#39;a where T: &#39;a&gt; ...</code></p>
<p dir="auto">There was some mentions of this all the back in the RFC thread <a href="https://github.com/rust-lang/rfcs/pull/1598#issuecomment-264340514" data-hovercard-type="pull_request" data-hovercard-url="/rust-lang/rfcs/pull/1598/hovercard">here</a>.</p>
<h2 dir="auto">Alternatives</h2>
<h3 dir="auto">Make generics on associated type in bounds a binder</h3>
<p dir="auto">Imagine the bound <code>for&lt;&#39;a&gt; T: Trait&lt;Item&lt;&#39;a&gt;= &amp;&#39;a ()&gt;</code>. It might be that <code>for&lt;&#39;a&gt;</code> is &#34;too large&#34; and it should instead be <code>T: Trait&lt;for&lt;&#39;a&gt; Item&lt;&#39;a&gt;= &amp;&#39;a ()&gt;</code>. Brought up in RFC thread <a href="https://github.com/rust-lang/rfcs/pull/1598#issuecomment-229443863" data-hovercard-type="pull_request" data-hovercard-url="/rust-lang/rfcs/pull/1598/hovercard">here</a> and in a few places since.</p>
<p dir="auto">Another related question: Is <code>for&lt;&#39;a&gt;</code> the right syntax? Maybe <code>where&lt;&#39;a&gt;</code>? Also originally found in RFC thread <a href="https://github.com/rust-lang/rfcs/pull/1598#issuecomment-261639969" data-hovercard-type="pull_request" data-hovercard-url="/rust-lang/rfcs/pull/1598/hovercard">here</a>.</p>
<h3 dir="auto">Stabilize lifetime GATs first</h3>
<p dir="auto">This has been brought up a few times. The idea is to only allow GATs with lifetime parameters to in initial stabilization. This was probably most useful prior to actual implementation. At this point, lifetimes, types, and consts are all implemented and work. It feels like an arbitrary split without strong reason.</p>
<h2 dir="auto">History</h2>
<ul dir="auto">
<li>On 2016-04-30, <a href="https://github.com/rust-lang/rfcs/pull/1598" data-hovercard-type="pull_request" data-hovercard-url="/rust-lang/rfcs/pull/1598/hovercard">RFC opened</a></li>
<li>On 2017-09-02, RFC merged and <a href="https://github.com/rust-lang/rust/issues/44265" data-hovercard-type="issue" data-hovercard-url="/rust-lang/rust/issues/44265/hovercard">tracking issue opened</a></li>
<li>On 2017-10-23, <a href="https://github.com/rust-lang/rust/pull/44766" data-hovercard-type="pull_request" data-hovercard-url="/rust-lang/rust/pull/44766/hovercard">Move Generics from MethodSig to TraitItem and ImplItem</a></li>
<li>On 2017-12-01, <a href="https://github.com/rust-lang/rust/pull/45904" data-hovercard-type="pull_request" data-hovercard-url="/rust-lang/rust/pull/45904/hovercard">Generic Associated Types Parsing &amp; Name Resolution</a></li>
<li>On 2017-12-15, <span><svg title="Merged" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M5 3.254V3.25v.005a.75.75 0 110-.005v.004zm.45 1.9a2.25 2.25 0 10-1.95.218v5.256a2.25 2.25 0 101.5 0V7.123A5.735 5.735 0 009.25 9h1.378a2.251 2.251 0 100-1.5H9.25a4.25 4.25 0 01-3.8-2.346zM12.75 9a.75.75 0 100-1.5.75.75 0 000 1.5zm-8.5 4.5a.75.75 0 100-1.5.75.75 0 000 1.5z"></path></svg><a data-error-text="Failed to load title" data-id="281604487" data-permission-text="Title is private" data-url="https://github.com/rust-lang/rust/issues/46706" data-hovercard-type="pull_request" data-hovercard-url="/rust-lang/rust/pull/46706/hovercard" href="https://github.com/rust-lang/rust/pull/46706">Lifetime Resolution for Generic Associated Types<span> #46706</span></a></span></li>
<li>On 2018-04-23, <a href="https://github.com/rust-lang/rust/pull/49368" data-hovercard-type="pull_request" data-hovercard-url="/rust-lang/rust/pull/49368/hovercard">Feature gate where clauses on associated types</a></li>
<li>On 2018-05-10, <a href="https://github.com/rust-lang/rust/pull/49423" data-hovercard-type="pull_request" data-hovercard-url="/rust-lang/rust/pull/49423/hovercard">Extend tests for RFC1598 (GAT)</a></li>
<li>On 2018-05-24, <a href="https://github.com/rust-lang/chalk/pull/134" data-hovercard-type="pull_request" data-hovercard-url="/rust-lang/chalk/pull/134/hovercard">Finish implementing GATs (Chalk)</a></li>
<li>On 2019-12-21, <a href="https://github.com/rust-lang/rust/pull/67160" data-hovercard-type="pull_request" data-hovercard-url="/rust-lang/rust/pull/67160/hovercard">Make GATs less ICE-prone</a></li>
<li>On 2020-02-13, <a href="https://github.com/rust-lang/rust/pull/68938" data-hovercard-type="pull_request" data-hovercard-url="/rust-lang/rust/pull/68938/hovercard">fix lifetime shadowing check in GATs</a></li>
<li>On 2020-06-20, <a href="https://github.com/rust-lang/rust/pull/72788" data-hovercard-type="pull_request" data-hovercard-url="/rust-lang/rust/pull/72788/hovercard">Projection bound validation</a></li>
<li>On 2020-10-06, <a href="https://github.com/rust-lang/rust/pull/73905" data-hovercard-type="pull_request" data-hovercard-url="/rust-lang/rust/pull/73905/hovercard">Separate projection bounds and predicates</a></li>
<li>On 2021-02-05, <a href="https://github.com/rust-lang/rust/pull/79554" data-hovercard-type="pull_request" data-hovercard-url="/rust-lang/rust/pull/79554/hovercard">Generic associated types in trait paths</a></li>
<li>On 2021-02-06, <a href="https://github.com/rust-lang/rust/issues/81823" data-hovercard-type="issue" data-hovercard-url="/rust-lang/rust/issues/81823/hovercard">Trait objects do not work with generic associated types</a></li>
<li>On 2021-04-28, <a href="https://github.com/rust-lang/rust/pull/84622" data-hovercard-type="pull_request" data-hovercard-url="/rust-lang/rust/pull/84622/hovercard">Make traits with GATs not object safe</a></li>
<li>On 2021-05-11, <a href="https://github.com/rust-lang/rust/pull/82272" data-hovercard-type="pull_request" data-hovercard-url="/rust-lang/rust/pull/82272/hovercard">Improve diagnostics for GATs</a></li>
<li>On 2021-07-16, <a href="https://github.com/rust-lang/rust/pull/84623" data-hovercard-type="pull_request" data-hovercard-url="/rust-lang/rust/pull/84623/hovercard">Make GATs no longer an incomplete feature</a></li>
<li>On 2021-07-16, <a href="https://github.com/rust-lang/rust/pull/86993" data-hovercard-type="pull_request" data-hovercard-url="/rust-lang/rust/pull/86993/hovercard">Replace associated item bound vars with placeholders when projecting</a></li>
<li>On 2021-07-26, <a href="https://github.com/rust-lang/rust/issues/87479" data-hovercard-type="issue" data-hovercard-url="/rust-lang/rust/issues/87479/hovercard">GATs: Decide whether to have defaults for <code>where Self: &#39;a</code></a></li>
<li>On 2021-08-25, <a href="https://github.com/rust-lang/rust/pull/85499" data-hovercard-type="pull_request" data-hovercard-url="/rust-lang/rust/pull/85499/hovercard">Normalize projections under binders</a></li>
<li>On 2021-08-03, <a href="https://blog.rust-lang.org/2021/08/03/GATs-stabilization-push.html" rel="nofollow">The push for GATs stabilization</a></li>
<li>On 2021-08-12, <a href="https://github.com/rust-lang/rust/pull/88336" data-hovercard-type="pull_request" data-hovercard-url="/rust-lang/rust/pull/88336/hovercard">Detect stricter constraints on gats where clauses in impls vs trait</a></li>
<li>On 2021-09-20, <a href="https://github.com/rust-lang/rust/issues/89122" data-hovercard-type="issue" data-hovercard-url="/rust-lang/rust/issues/89122/hovercard">Proposal: Change syntax of where clauses on type aliases</a></li>
<li>On 2021-11-06, <a href="https://github.com/rust-lang/rust/pull/89970" data-hovercard-type="pull_request" data-hovercard-url="/rust-lang/rust/pull/89970/hovercard">Implementation of GATs outlives lint</a></li>
<li>On 2021-12-29. <a href="https://github.com/rust-lang/rust/pull/92118" data-hovercard-type="pull_request" data-hovercard-url="/rust-lang/rust/pull/92118/hovercard">Parse and suggest moving where clauses after equals for type aliases</a></li>
<li>On 2022-01-15, <a href="https://github.com/rust-lang/rust/pull/92865" data-hovercard-type="pull_request" data-hovercard-url="/rust-lang/rust/pull/92865/hovercard">Ignore static lifetimes for GATs outlives lint</a></li>
<li>On 2022-02-08, <a href="https://github.com/rust-lang/rust/pull/92917" data-hovercard-type="pull_request" data-hovercard-url="/rust-lang/rust/pull/92917/hovercard">Don&#39;t constrain projection predicates with inference vars in GAT substs</a></li>
<li>On 2022-02-15, <a href="https://github.com/rust-lang/rust/pull/93820" data-hovercard-type="pull_request" data-hovercard-url="/rust-lang/rust/pull/93820/hovercard">Rework GAT where clause check</a></li>
<li>On 2022-02-19, <a href="https://github.com/rust-lang/rust/pull/93892" data-hovercard-type="pull_request" data-hovercard-url="/rust-lang/rust/pull/93892/hovercard">Only mark projection as ambiguous if GAT substs are constrained</a></li>
<li>On 2022-03-03, <a href="https://github.com/rust-lang/rust/pull/94009" data-hovercard-type="pull_request" data-hovercard-url="/rust-lang/rust/pull/94009/hovercard">Support GATs in Rustdoc</a></li>
<li>On 2022-03-06, <a href="https://github.com/rust-lang/rust/pull/90076" data-hovercard-type="pull_request" data-hovercard-url="/rust-lang/rust/pull/90076/hovercard">Change location of where clause on GATs</a></li>
<li>On 2022-05-04, <a href="https://jackh726.github.io/rust/2022/05/04/a-shiny-future-with-gats.html" rel="nofollow">A shiny future with GATs blog post</a></li>
<li>On 2022-05-04, <a href="https://github.com/rust-lang/rust/pull/96709" data-hovercard-type="pull_request" data-hovercard-url="/rust-lang/rust/pull/96709/hovercard">Stabilization PR</a></li>
</ul>
    </div>
  </task-lists>
  
</div>

      </div></div>
  </body>
</html>
