<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.peterullrich.com/listen-to-database-changes-with-postgres-triggers-and-elixir">Original</a>
    <h1>How to Listen to Database Changes Using Postgres Triggers in Elixir</h1>
    
    <div id="readability-page-1" class="page"><div>
      <div>
  <h2>Hey! I recorded a video course!</h2>
  
  
</div>
 <p>Welcome back to another blog post :) Before we begin, one question:</p>

<div><div><pre><code>Why do cows have hooves instead of feet?

Because they lactose!
</code></pre></div></div>

<p>Alright, now letâ€™s dive into todayâ€™s topic: <strong>How to listen to database changes using Postgres triggers and Elixir</strong></p>
<h2 id="why-listen-at-all">
  
  
    <a href="#why-listen-at-all">ðŸ”—</a> Why listen at all?
  
  
</h2>
    

<p>In almost all codebases, you have subsequent processes depending on previous processes. Imagine a sign-up flow for new users. After a user signs up, you might want to start sending marketing emails periodically. This is called a <code>downstream process</code>. The sign-up to the marketing emails depends on the userâ€™s registration. When your software is still simple enough, you usually get away with calling these processes in sequence. Your code might look something like this:</p>

<div><div><pre><code><span>def</span> <span>register_user</span><span>(</span><span>params</span><span>)</span> <span>do</span>
  <span>with</span> <span>{</span><span>:ok</span><span>,</span> <span>user</span><span>}</span> <span>&lt;-</span> <span>Repo</span><span>.</span><span>create_user</span><span>(</span><span>params</span><span>),</span>
       <span>:ok</span> <span>&lt;-</span> <span>sign_up_for_marketing_emails</span><span>(</span><span>user</span><span>)</span> <span>do</span>
    <span>:ok</span>
  <span>end</span>
<span>end</span>
</code></pre></div></div>

<p>In this simple case, you only have one <code>downstream</code> process: the sign-up for the marketing emails. But what if your software becomes more complex and you add more and more such downstream processes? Your <code>register_user/1</code> function will grow and grow. Maybe your company grows as well and adds more dev teams. Thatâ€™s great, but now you have more teams adding their own downstream calls to <code>register_user/1</code>, making them all dependent on each other.</p>

<p>Imagine that one of the many calls fails. Usually, the entire user registration will roll back, undoing the changes in every team that placed their downstream call before the failed one. In the worst case, you might have an incomplete registration, where some calls succeed and others fail and you didnâ€™t roll back properly. Now, the teams with failed calls need to somehow fetch the missing user data and reconcile it with everything that might have happened after the registration. Itâ€™s simply a mess.</p>

<p>A frequent solution to untangle these dependencies is to implement an event system. <a href="https://hexdocs.pm/phoenix_pubsub/Phoenix.PubSub.html" target="_blank" rel="noopener noreferrer">Phoenix.PubSub</a> is such a system for example. Event systems have many advantages (and disadvantages), but in this case, they help us to reverse the code dependency between upstream and downstream processes. Without an event system, <code>register_user/1</code> has to call <code>sign_up_for_marketing_emails/1</code> directly. <code>register_user/1</code> is <strong>aware</strong> of the downstream process and it needs to change if the downstream process changes, for example when we need to provide more info, like which marketing emails the user subscribed to and which ones they didnâ€™t. Our upstream code, <code>register_user/1</code>, depends on the downstream process, <code>sign_up_for_marketing_emails/1</code>.</p>

<p>Now, with an event system, we can reverse that dependency. Our <code>register_user/1</code> call could simply broadcast an event using <code>PubSub.broadcast/4</code>. Our downstream process can then subscribe and react to the events. Now, our upstream code is unaware of the downstream process. It doesnâ€™t care whether it succeeds or fails or if it changes. Instead, the downstream code now depends on <code>register_user/1</code> to publish the necessary data. Thatâ€™s it. If we want to change the marketing email sign-up, we simply handle the received data differently in <code>sign_up_for_marketing_emails/1</code>. No need to change <code>register_user/1</code>. Perfect!</p>
<h2 id="how-to-listen">
  
  
    <a href="#how-to-listen">ðŸ”—</a> How to listen?
  
  
</h2>
    

<p>I mentioned <code>Phoenix.PubSub</code> before and if Iâ€™m implementing an Elixir application, that would be my go-to event system if I need to send and react to basic notifications. If I need more advanced systems, <code>Kafka</code>, <code>RabbitMQ</code>, or <code>Amazon&#39;s SQS</code> would come to <a href="https://medium.com/systemdesign-us-blog/kafka-vs-rabbitmq-vs-sqs-70d1bfefa274" target="_blank" rel="noopener noreferrer">mind</a>. But thereâ€™s another, low-effort solution that you probably already have in your tech stack: <code>Postgres</code>.</p>

<p><code>Postgres</code> offers quick and simple <a href="https://www.postgresql.org/docs/current/sql-notify.html" target="_blank" rel="noopener noreferrer">Notifications</a> that can help you react to changes in your database without much overhead. They are particularly interesting if you canâ€™t use Phoenixâ€™s <code>PubSub</code>, for example, if another non-Elixir application also makes changes to your database.</p>

<p>Letâ€™s see how you can set up Postgres notifications in your Phoenix app.</p>
<h2 id="the-migration">
  
  
    <a href="#the-migration">ðŸ”—</a> The Migration
  
  
</h2>
    

<p>The first step is to add the notifications using Postgres SQL. The migration below adds a trigger to a table called <code>appointments</code> that sends a notification whenever an appointment is canceled or uncanceled. Letâ€™s have a look:</p>

<div><div><pre><code><span>defmodule</span> <span>Demo</span><span>.</span><span>Repo</span><span>.</span><span>Migrations</span><span>.</span><span>AddAppointmentCanceledTrigger</span> <span>do</span>
  <span>use</span> <span>Ecto</span><span>.</span><span>Migration</span>

  <span>def</span> <span>up</span> <span>do</span>
    <span>execute</span> <span>&#34;&#34;&#34;
    CREATE OR REPLACE FUNCTION notify_canceled_changed()
      RETURNS trigger AS $trigger$
      DECLARE
        payload TEXT;
      BEGIN
        IF (TG_OP = &#39;UPDATE&#39;) AND (OLD.canceled != NEW.canceled) THEN
          payload := json_build_object(&#39;id&#39;,OLD.id,&#39;old&#39;,row_to_json(OLD),&#39;new&#39;,row_to_json(NEW));
          PERFORM pg_notify(&#39;appointments_canceled_changed&#39;, payload);
        END IF;

        RETURN NEW;
      END;
      $trigger$ LANGUAGE plpgsql;
    &#34;&#34;&#34;</span>

    <span>execute</span> <span>&#34;&#34;&#34;
    CREATE TRIGGER appointments_canceled_changed_trigger
      AFTER UPDATE ON appointments FOR EACH ROW
      WHEN ( OLD.canceled IS DISTINCT FROM NEW.canceled )
      EXECUTE PROCEDURE notify_canceled_changed();
    &#34;&#34;&#34;</span>
  <span>end</span>

  <span>def</span> <span>down</span> <span>do</span>
    <span>execute</span> <span>&#34;&#34;&#34;
    DROP TRIGGER appointments_canceled_changed_trigger ON appointments;
    &#34;&#34;&#34;</span>

    <span>execute</span> <span>&#34;&#34;&#34;
    DROP FUNCTION notify_canceled_changed();
    &#34;&#34;&#34;</span>
  <span>end</span>
<span>end</span>
</code></pre></div></div>

<p>Thatâ€™s a lot of SQL, but in short, the migration first adds a function called <code>notify_canceled_changed()</code> which sends a notification to the channel <code>appoiments_canceled_changed</code> with the <code>id</code> of the appointment and the before and after state of the appointment encoded as JSON. We add the function as a trigger to the <code>appointments</code> table using <code>CREATE TRIGGER ...</code>. The function is only executed if the appointment is <code>updated</code>, so not <code>inserted</code> or <code>deleted</code>, and only if the <code>appointment.canceled</code> boolean field has changed.</p>

<p>In our <code>notify_canceled_changed</code> function, we double-check these validations as a precaution (i.e. the record is updated and <code>canceled</code> has changed). We wouldnâ€™t need to though since Postgres will execute this function only if these requirements are met. But it never hurts to double-check!</p>

<p>You might have noticed that we donâ€™t use an <code>EVENT TRIGGER</code> here. The <a href="https://stackoverflow.com/questions/36174459/what-s-the-difference-between-trigger-and-event-trigger-in-postgresql" target="_blank" rel="noopener noreferrer">difference</a> between a <code>TRIGGER</code> and an <code>EVENT TRIGGER</code> is that the latter handles database-wide events (e.g. <code>CREATE TABLE</code>) whereas the former handles events specific to a given table (e.g. <code>INSERT|UPDATE|READ|DELETE| row</code>). We are only interested in changes to the <code>appointments</code> table which is why we use a simple <code>TRIGGER</code>.</p>

<p>Another detail you might have spotted is that we execute the trigger <strong>after</strong> a row was updated with <code>AFTER UPDATE ON</code>. For our use-case, the distinction between <code>BEFORE</code> and <code>AFTER</code> update doesnâ€™t matter, but if you wanted to change the new data before it is written to the row, you would need to use the <code>BEFORE UPDATE</code> statement. Read <a href="https://dba.stackexchange.com/questions/153525/what-is-the-difference-between-an-after-update-and-a-before-update-in-postgresql" target="_blank" rel="noopener noreferrer">this</a> for more details on the difference between the two.</p>

<p>If you want more examples of triggers, <a href="https://gist.github.com/carterbryden/e7b19d1ba1ea92e241fed259fea23491" target="_blank" rel="noopener noreferrer">here</a> <a href="https://github.com/commanded/eventstore/blob/master/priv/event_store/migrations/v1.3.2.sql" target="_blank" rel="noopener noreferrer">are</a> <a href="https://gist.github.com/goliatone/5fbeb1912e5937e8e3cf94618be9bebf" target="_blank" rel="noopener noreferrer">some</a>.</p>

<p>Now with the migration in place, run <code>mix ecto.migrate</code> to add the function and trigger to your database. However, if you run your application now and update an appointment, you wonâ€™t see anything. Thatâ€™s because weâ€™re not yet listening to such events from our Elixir application. Letâ€™s change that.</p>
<h2 id="the-listener">
  
  
    <a href="#the-listener">ðŸ”—</a> The Listener
  
  
</h2>
    

<p>We will use the <a href="https://hexdocs.pm/postgrex/Postgrex.Notifications.html" target="_blank" rel="noopener noreferrer">Postgrex.Notifications</a> module to listen to and handle messages from Postgres. Hereâ€™s our listener:</p>

<div><div><pre><code><span>defmodule</span> <span>Demo</span><span>.</span><span>DatabaseListener</span> <span>do</span>
  <span>use</span> <span>GenServer</span>

  <span>@channel</span> <span>&#34;appointments_canceled_changed&#34;</span>

  <span>def</span> <span>start_link</span><span>(</span><span>init_args</span><span>)</span> <span>do</span>
    <span>GenServer</span><span>.</span><span>start_link</span><span>(</span><span>__MODULE__</span><span>,</span> <span>[</span><span>init_args</span><span>],</span> <span>name:</span> <span>__MODULE__</span><span>)</span>
  <span>end</span>

  <span>def</span> <span>init</span><span>(</span><span>_args</span><span>)</span> <span>do</span>
    <span>repo_config</span> <span>=</span> <span>Demo</span><span>.</span><span>Repo</span><span>.</span><span>config</span><span>()</span>
    
    <span>{</span><span>:ok</span><span>,</span> <span>pid</span><span>}</span> <span>=</span> <span>Postgrex</span><span>.</span><span>Notifications</span><span>.</span><span>start_link</span><span>(</span><span>repo_config</span><span>)</span>
    <span>{</span><span>:ok</span><span>,</span> <span>ref</span><span>}</span> <span>=</span> <span>Postgrex</span><span>.</span><span>Notifications</span><span>.</span><span>listen</span><span>(</span><span>pid</span><span>,</span> <span>@channel</span><span>)</span>

    <span>{</span><span>:ok</span><span>,</span> <span>{</span><span>pid</span><span>,</span> <span>ref</span><span>}}</span>
  <span>end</span>

  <span>def</span> <span>handle_info</span><span>({</span><span>:notification</span><span>,</span> <span>_pid</span><span>,</span> <span>_ref</span><span>,</span> <span>@channel</span><span>,</span> <span>payload</span><span>},</span> <span>state</span><span>)</span> <span>do</span>
    <span>payload</span> <span>=</span> <span>Jason</span><span>.</span><span>decode!</span><span>(</span><span>payload</span><span>)</span>
    <span>IO</span><span>.</span><span>puts</span><span>(</span><span>&#34;Received a notification for appointment </span><span>#{</span><span>payload</span><span>[</span><span>&#34;id&#34;</span><span>]</span><span>}</span><span>&#34;</span><span>)</span>
    <span>IO</span><span>.</span><span>puts</span><span>(</span><span>payload</span><span>)</span>

    <span>{</span><span>:noreply</span><span>,</span> <span>state</span><span>}</span>
  <span>end</span>
<span>end</span>
</code></pre></div></div>

<p>We created a <code>GenServer</code> for our listener with its own message queue to handle incoming Postgres messages. Be aware that this listener can easily become a bottleneck if you have lots of messages. If you canâ€™t handle the messages quickly enough, the message queue will fill up and crash your application. If youâ€™re worried about this case, you could create one listener per channel or use a <a href="https://hexdocs.pm/elixir/1.14/PartitionSupervisor.html" target="_blank" rel="noopener noreferrer">PartitionSupervisor</a> to start more handlers and spread out the work.</p>

<p>Our listener is pretty straightforward. First, we spawn another process that connects to Postgres using our Repo config. Then, we start listening to that process which means that weâ€™ll receive any Postgres messages it might catch. Whenever a notification comes in, our <code>handle_info/2</code> callback will handle it. In this case, we simply decode its JSON payload and log it to the console.</p>

<p>The last step is to start our listener whenever our application starts. Open your <code>lib/application.ex</code> and add the listener to the supervisorâ€™s children, like this:</p>

<div><div><pre><code><span># lib/application.ex</span>
<span>def</span> <span>start</span><span>(</span><span>_type</span><span>,</span> <span>_args</span><span>)</span> <span>do</span>
  <span>children</span> <span>=</span> <span>[</span>
    <span># Other modules</span>
    <span>Demo</span><span>.</span><span>Repo</span><span>,</span> 
    <span># Make sure to start the listener AFTER your Repo.</span>
    <span># Otherwise, your listener won&#39;t connect.</span>
    <span>Demo</span><span>.</span><span>DatabaseListener</span>
  <span>]</span>

  <span>opts</span> <span>=</span> <span>[</span><span>strategy:</span> <span>:one_for_one</span><span>,</span> <span>name:</span> <span>Demo</span><span>.</span><span>Supervisor</span><span>]</span>
  <span>Supervisor</span><span>.</span><span>start_link</span><span>(</span><span>children</span><span>,</span> <span>opts</span><span>)</span>
<span>end</span>
</code></pre></div></div>

<p>And thatâ€™s it! Now, whenever we start our application, we establish a link to Postgres and listen to messages on the given channel. If such a message comes in, our <code>handle_info/2</code> will log it. Letâ€™s try it out!</p>
<h2 id="the-test">
  
  
    <a href="#the-test">ðŸ”—</a> The Test
  
  
</h2>
    

<p>Now with everything in place, we can test-run the setup. Letâ€™s create and update an appointment:</p>

<div><div><pre><code><span>iex</span><span>&gt;</span> <span>{</span><span>:ok</span><span>,</span> <span>a</span><span>}</span> <span>=</span> <span>Demo</span><span>.</span><span>Appointments</span><span>.</span><span>create_appointment</span><span>(%{</span><span>canceled:</span> <span>false</span><span>})</span>
<span>{</span><span>:ok</span><span>,</span> <span>%</span><span>Appointment</span><span>{</span><span>...</span><span>}}</span>
<span>iex</span><span>&gt;</span> <span>{</span><span>:ok</span><span>,</span> <span>a</span><span>}</span> <span>=</span> <span>Demo</span><span>.</span><span>Appointments</span><span>.</span><span>update_appointment</span><span>(</span><span>a</span><span>,</span> <span>%{</span><span>canceled:</span> <span>true</span><span>})</span>
<span>{</span><span>:ok</span><span>,</span> <span>%</span><span>Appointment</span><span>{</span><span>...</span><span>}}</span>
<span>&#34;Received a notification for appointment 1&#34;</span>
<span>%{</span>
  <span>&#34;id&#34;</span> <span>=&gt;</span> <span>1</span><span>,</span>
  <span>&#34;old&#34;</span> <span>=&gt;</span> <span>%{</span>
    <span>&#34;id&#34;</span> <span>=&gt;</span> <span>1</span><span>,</span>
    <span>&#34;canceled&#34;</span> <span>=&gt;</span> <span>false</span><span>,</span>
    <span>&#34;inserted_at&#34;</span> <span>=&gt;</span> <span>&#34;2023-02-11T17:36:56&#34;</span><span>,</span>
    <span>&#34;updated_at&#34;</span> <span>=&gt;</span> <span>&#34;2023-02-11T17:37:03&#34;</span>
  <span>},</span>
  <span>&#34;new&#34;</span> <span>=&gt;</span> <span>%{</span>
    <span>&#34;id&#34;</span> <span>=&gt;</span> <span>1</span><span>,</span>
    <span>&#34;canceled&#34;</span> <span>=&gt;</span> <span>true</span><span>,</span>
    <span>&#34;inserted_at&#34;</span> <span>=&gt;</span> <span>&#34;2023-02-11T17:36:56&#34;</span><span>,</span>
    <span>&#34;updated_at&#34;</span> <span>=&gt;</span> <span>&#34;2023-02-11T17:44:48&#34;</span>
  <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>After updating the <code>canceled</code>-flag of our appointment, we received a message from Postgres! It works! Yey!</p>
<h2 id="conclusion">
  
  
    <a href="#conclusion">ðŸ”—</a> Conclusion
  
  
</h2>
    

<p>And thatâ€™s it! I hope you enjoyed this article! If you have questions or comments, letâ€™s discuss them on <a href="https://twitter.com/pjullrich" target="_blank" rel="noopener noreferrer">Twitter</a>. Follow me on <a href="https://twitter.com/pjullrich" target="_blank" rel="noopener noreferrer">Twitter</a> or subscribe to my newsletter below if you want to get notified when I publish the next blog post. Until the next time! Cheerio ðŸ‘‹</p>
    </div></div>
  </body>
</html>
