<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.blog/2021-12-09-introducing-stack-graphs/">Original</a>
    <h1>Stack Graphs</h1>
    
    <div id="readability-page-1" class="page"><div>

	<p>Today, we announced the general availability of <a href="https://github.blog/2021-12-09-precise-code-navigation-python-code-navigation-pull-requests/">precise code navigation</a> for all public and private Python repositories on GitHub.com. Precise code navigation is powered by <a href="https://docs.rs/stack-graphs/*/stack_graphs/">stack graphs</a>, a new open source framework we’ve created that lets you define the name binding rules for a programming language using a declarative, domain-specific language (DSL). With stack graphs, we can generate code navigation data for a repository <em>without</em> requiring any configuration from the repository owner, and <em>without</em> tapping into a build process or other CI job. In this post, I’ll dig into how stack graphs work, and how they achieve these results.</p>
<p><em>(This post is a condensed version of a talk that I gave at <a href="https://dcreager.net/talks/2021-strange-loop/">Strange Loop</a> in October 2021. Please check out the video of that talk if you’d like to learn even more!)</em></p>
<h2 id="what-is-code-navigation">What is code navigation?<a href="#what-is-code-navigation" aria-label="What is code navigation?" data-anchorjs-icon="#"></a></h2>
<p>Code navigation is a family of features that let you explore the relationships in your code and its dependencies at a deep level.  The most basic code navigation features are “jump to definition” and “find all references.” Both build on the fact that <em>names</em> are pervasive in the code that we write. Programming languages let us <em>define</em> things — functions, classes, modules, methods, variables, and more.  Those things have names so that we can <em>refer</em> back to them in other parts of our code.</p>
<p>A picture (even a simple one) is worth a thousand words:</p>
<p><img loading="lazy" src="https://github.blog/wp-content/uploads/2021/12/python-simple.png?resize=511%2C659" alt="a simple Python module" width="511" height="659" srcset="https://github.blog/wp-content/uploads/2021/12/python-simple.png?resize=511%2C659?w=511 511w, https://github.blog/wp-content/uploads/2021/12/python-simple.png?resize=511%2C659?w=233 233w" sizes="(max-width: 511px) 100vw, 511px" data-recalc-dims="1"/></p>
<p>In this Python module, the reference to <code>broil</code> at the end of the file refers to the function definition earlier in the file. (Throughout this post, I’ll highlight definitions in red and references in blue.)</p>
<p>Our goal, then, is to collect information about the lists of definitions and references, and to be able to determine which definitions each reference maps to, for <em>all</em> of the code hosted on GitHub.</p>
<h2 id="why-is-this-hard">Why is this hard?<a href="#why-is-this-hard" aria-label="Why is this hard?" data-anchorjs-icon="#"></a></h2>
<p>In the above example, the definition and reference were close to each other, and it was easy to visually see the relationship between them. But it won’t always be that easy!</p>
<p><img loading="lazy" src="https://github.blog/wp-content/uploads/2021/12/shadow-vs-conflict.png?resize=1024%2C623" alt="names can shadow each other in Python but not in Rust" width="1024" height="623" srcset="https://github.blog/wp-content/uploads/2021/12/shadow-vs-conflict.png?resize=1024%2C623?w=1059 1059w, https://github.blog/wp-content/uploads/2021/12/shadow-vs-conflict.png?resize=1024%2C623?w=300 300w, https://github.blog/wp-content/uploads/2021/12/shadow-vs-conflict.png?resize=1024%2C623?w=768 768w, https://github.blog/wp-content/uploads/2021/12/shadow-vs-conflict.png?resize=1024%2C623?w=1024 1024w" sizes="(max-width: 1000px) 100vw, 1000px" data-recalc-dims="1"/></p>
<p>For instance, what if there are multiple definitions with the same name? In Python, names can <em>shadow</em> each other, which means that the <code>broil</code> reference should refer to the <em>latter</em> of the two definitions.</p>
<p>But these rules are language-specific! In Rust, top-level definitions are not allowed to shadow each other, but local variables are. So, this transliteration of my example from Python to Rust is an error according to the Rust language spec. If we were writing a Rust compiler, we would want to surface this error for the programmer to fix. But what about for an exploration feature like code navigation?  We might want to show <em>some</em> result even for erroneous code. We’re only human, after all!</p>
<p><img loading="lazy" src="https://github.blog/wp-content/uploads/2021/12/python-two-packages.png?resize=1024%2C495" alt="code can live in multiple packages" width="1024" height="495" srcset="https://github.blog/wp-content/uploads/2021/12/python-two-packages.png?resize=1024%2C495?w=1964 1964w, https://github.blog/wp-content/uploads/2021/12/python-two-packages.png?resize=1024%2C495?w=300 300w, https://github.blog/wp-content/uploads/2021/12/python-two-packages.png?resize=1024%2C495?w=768 768w, https://github.blog/wp-content/uploads/2021/12/python-two-packages.png?resize=1024%2C495?w=1024 1024w, https://github.blog/wp-content/uploads/2021/12/python-two-packages.png?resize=1024%2C495?w=1536 1536w" sizes="(max-width: 1000px) 100vw, 1000px" data-recalc-dims="1"/></p>
<p>Up to now, I’ve only shown you examples consisting of a single file. But when was the last time you worked on a software project consisting of a single file? It’s much more likely that your code will be split across multiple files, multiple packages, and multiple repositories. Programming languages give us the ability to refer to definitions that might be quite far away. But as you might expect, the rules for how you refer to things in other files are different for different languages.</p>
<p>In the above example, I’ve split everything up into three files living in two separate packages or repositories. (I’m using emoji to represent the package names.) In Python, <code>import</code> statements let us refer to names defined in other modules, and the name of a module is determined by the name of the file containing its code. Together, this lets us see that the <code>broil</code> reference in <code>chef.py</code> in the “chef” package refers to the <code>broil</code> definition in <code>stove.py</code> in the “frying pan” package.</p>
<p><img loading="lazy" src="https://github.blog/wp-content/uploads/2021/12/python-intermediate-update.png?resize=1024%2C494" alt="code can change" width="1024" height="494" srcset="https://github.blog/wp-content/uploads/2021/12/python-intermediate-update.png?resize=1024%2C494?w=1968 1968w, https://github.blog/wp-content/uploads/2021/12/python-intermediate-update.png?resize=1024%2C494?w=300 300w, https://github.blog/wp-content/uploads/2021/12/python-intermediate-update.png?resize=1024%2C494?w=768 768w, https://github.blog/wp-content/uploads/2021/12/python-intermediate-update.png?resize=1024%2C494?w=1024 1024w, https://github.blog/wp-content/uploads/2021/12/python-intermediate-update.png?resize=1024%2C494?w=1536 1536w" sizes="(max-width: 1000px) 100vw, 1000px" data-recalc-dims="1"/></p>
<p>Code changes and evolves over time. What happens when one of your dependencies changes the implementation of a function that you’re calling? Here, the maintainers of the “frying pan” package have added some logging to the <code>broil</code> function. As a result, the <code>broil</code> reference in <code>chef.py</code> now refers to a different definition. Insidiously, it was an intermediate file that changed — not the file containing the reference, nor the file containing the original definition! If we’re not careful, we’ll have to reanalyze <em>every</em> file in the repository, <em>and in all its dependencies</em>, whenever <em>any</em> file changes! This makes the amount of work we must do quadratic in the number of changed files, rather than linear, which is especially problematic at GitHub’s scale.</p>
<p>Our last difficulty is one of scale. As mentioned above, we want to provide this feature for <em>all</em> of the code hosted on GitHub. Moreover, we don’t want to require any manual configuration on the part of each repository owner. You shouldn’t have to figure out how to produce code navigation data for your language and project, or have to configure a CI build to generate that data. Code navigation should Just Work.</p>
<p>At GitHub’s scale, this poses two problems. The first is the sheer amount of code that comes in every minute of every day. In each commit that we receive, it’s very likely that only a small number of files have been modified. We <em>must</em> be able to rely on <strong><em>incremental processing and storage</em></strong>, reusing the results that we’ve already calculated and saved for the files that haven’t changed.</p>
<p>The second challenge is the number of programming languages that we need to (eventually) support. GitHub hosts code written in every programming language imaginable. Git itself doesn’t care what language you use for your project — to Git, everything is just bytes. But for a feature like code navigation, where the name binding rules are different for each language, we must know how to parse and interpret the <em>content</em> of those files. To support this at scale, it must be as easy as possible for GitHub engineers and external language communities to describe the name binding rules for a language.</p>
<p>To summarize:</p>
<ul>
<li>Different languages have different name binding rules.</li>
<li>Some of those rules can be quite complex.</li>
<li>The result might depend on intermediate ﬁles.</li>
<li>We don’t want to require manual per-repository conﬁguration.</li>
<li>We need incremental processing to handle our scale.</li>
</ul>
<h2 id="stack-graphs">Stack graphs<a href="#stack-graphs" aria-label="Stack graphs" data-anchorjs-icon="#"></a></h2>
<p>After examining the problem space, we created stack graphs to tackle these challenges, based on the <a href="https://pl.ewi.tudelft.nl/research/projects/scope-graphs/">scope graphs</a> framework from <a href="https://eelcovisser.org/">Eelco Visser’s</a> research group at <a href="https://pl.ewi.tudelft.nl/">TU Delft</a>. Below I’ll discuss what stack graphs are and how they work.</p>
<p>Because we must rely on incremental results, it’s important that at <em>index time</em> (that is, when we receive pushes containing new commits), we <em>look at each file completely in isolation</em>. Our goal is to extract “facts” about each file that describe the definitions and references in the file, and all possible things that each reference could resolve to.</p>
<p>For instance, consider this example:</p>
<p><img loading="lazy" src="https://github.blog/wp-content/uploads/2021/12/python-two-files.png?resize=1024%2C571" alt="two Python files" width="1024" height="571" srcset="https://github.blog/wp-content/uploads/2021/12/python-two-files.png?resize=1024%2C571?w=1171 1171w, https://github.blog/wp-content/uploads/2021/12/python-two-files.png?resize=1024%2C571?w=300 300w, https://github.blog/wp-content/uploads/2021/12/python-two-files.png?resize=1024%2C571?w=768 768w, https://github.blog/wp-content/uploads/2021/12/python-two-files.png?resize=1024%2C571?w=1024 1024w" sizes="(max-width: 1000px) 100vw, 1000px" data-recalc-dims="1"/></p>
<p>Our final result must be able to encode the fact that the <code>broil</code> reference and definition live in different files. But to be incremental, our analysis must look at each file separately. I’m going to step into each file to show you what information GitHub can extract in isolation.</p>
<p><img loading="lazy" src="https://github.blog/wp-content/uploads/2021/12/python-two-files-stove-graph.png?resize=1024%2C551" alt="the stack graph for stove.py" width="1024" height="551" srcset="https://github.blog/wp-content/uploads/2021/12/python-two-files-stove-graph.png?resize=1024%2C551?w=1546 1546w, https://github.blog/wp-content/uploads/2021/12/python-two-files-stove-graph.png?resize=1024%2C551?w=300 300w, https://github.blog/wp-content/uploads/2021/12/python-two-files-stove-graph.png?resize=1024%2C551?w=768 768w, https://github.blog/wp-content/uploads/2021/12/python-two-files-stove-graph.png?resize=1024%2C551?w=1024 1024w, https://github.blog/wp-content/uploads/2021/12/python-two-files-stove-graph.png?resize=1024%2C551?w=1536 1536w" sizes="(max-width: 1000px) 100vw, 1000px" data-recalc-dims="1"/></p>
<p>Looking first at <code>stove.py</code>, we can see that it contains a definition of <code>broil</code>. From the name of the file, we know that this definition lives in a module called <code>stove</code>, giving a <em>fully qualified name</em> of <code>stove.broil</code>. We can create a graph structure representing this fact (along with information about the other symbols in the file). Each definition (including the module itself) gets a red, double-bordered <em>definition node</em>. The other nodes, and the pattern of how we’ve connected these nodes with edges, define the scoping and shadowing rules for these symbols.  For other programming languages, which don’t implement the same shadowing behavior as Python, we’d use a different pattern of edges to connect everything.</p>
<p><img loading="lazy" src="https://github.blog/wp-content/uploads/2021/12/python-two-files-kitchen-graph.png?resize=1024%2C435" alt="the stack graph for kitchen.py" width="1024" height="435" srcset="https://github.blog/wp-content/uploads/2021/12/python-two-files-kitchen-graph.png?resize=1024%2C435?w=1900 1900w, https://github.blog/wp-content/uploads/2021/12/python-two-files-kitchen-graph.png?resize=1024%2C435?w=300 300w, https://github.blog/wp-content/uploads/2021/12/python-two-files-kitchen-graph.png?resize=1024%2C435?w=768 768w, https://github.blog/wp-content/uploads/2021/12/python-two-files-kitchen-graph.png?resize=1024%2C435?w=1024 1024w, https://github.blog/wp-content/uploads/2021/12/python-two-files-kitchen-graph.png?resize=1024%2C435?w=1536 1536w" sizes="(max-width: 1000px) 100vw, 1000px" data-recalc-dims="1"/></p>
<p>We can do the same thing for <code>kitchen.py</code>. The <code>broil</code> reference is represented by a blue, single-bordered <em>reference node</em>. The <code>import</code> statement also appears in the graph, as a gadget of nodes involving the <code>broil</code> and <code>stove</code> symbols.</p>
<p>Because we are looking at this file in isolation, we don’t yet know what the <code>broil</code> reference resolves to. The <code>import</code> statement means that it <em>might</em> resolve to <code>stove.broil</code>, defined in some other file — but that depends on whether there <em>is</em> a file defining that symbol. This example does in fact contain such a file (we just looked at it!), but we must ignore that while extracting incremental facts about <code>kitchen.py</code>.</p>
<p>At <em>query time</em>, however, we’re able to bring together the data from all files in the commit that you’re looking at. We can load the graphs for each of the files, producing a single “merged” graph for the entire commit:</p>
<p><img loading="lazy" src="https://github.blog/wp-content/uploads/2021/12/python-two-files-merged-graph.png?resize=1024%2C411" alt="the merged stack graph" width="1024" height="411" srcset="https://github.blog/wp-content/uploads/2021/12/python-two-files-merged-graph.png?resize=1024%2C411?w=1852 1852w, https://github.blog/wp-content/uploads/2021/12/python-two-files-merged-graph.png?resize=1024%2C411?w=300 300w, https://github.blog/wp-content/uploads/2021/12/python-two-files-merged-graph.png?resize=1024%2C411?w=768 768w, https://github.blog/wp-content/uploads/2021/12/python-two-files-merged-graph.png?resize=1024%2C411?w=1024 1024w, https://github.blog/wp-content/uploads/2021/12/python-two-files-merged-graph.png?resize=1024%2C411?w=1536 1536w" sizes="(max-width: 1000px) 100vw, 1000px" data-recalc-dims="1"/></p>
<p>Within this merged graph, every valid name binding is represented by a path from a reference node to a definition node.</p>
<p>However, not every path in the graph represents a valid name binding! For instance, looking only at the graph structure, there are perfectly fine paths from the <code>broil</code> reference node to the <code>saute</code> and <code>bake</code> definition nodes. To rule out those paths, we also maintain a <strong><em>symbol stack</em></strong> while searching for paths. Each blue node pushes a symbol onto the stack, and each red node pops a symbol from the stack. Importantly, we <em>are not allowed</em> to move into a “pop” node if its symbol does not match the top of the stack.</p>
<p>We’ve shown the contents of the symbol stack at a handful of places in the path that’s highlighted above. Most importantly, when we reach the portion of the graph containing the <code>saute</code>, <code>broil</code>, and <code>bake</code> definition nodes, the symbol stack contains <code>⟨broil⟩</code>, ensuring that the only <em>valid</em> path that we discover is the one that ends at the <code>broil</code> definition.</p>
<p>We can also use different graph structures to handle my other examples. For example:</p>
<p><img loading="lazy" src="https://github.blog/wp-content/uploads/2021/12/python-two-files-stove-graph-conflict.png?resize=1024%2C551" alt="the stack graph for shadowed Python definitions" width="1024" height="551" srcset="https://github.blog/wp-content/uploads/2021/12/python-two-files-stove-graph-conflict.png?resize=1024%2C551?w=1546 1546w, https://github.blog/wp-content/uploads/2021/12/python-two-files-stove-graph-conflict.png?resize=1024%2C551?w=300 300w, https://github.blog/wp-content/uploads/2021/12/python-two-files-stove-graph-conflict.png?resize=1024%2C551?w=768 768w, https://github.blog/wp-content/uploads/2021/12/python-two-files-stove-graph-conflict.png?resize=1024%2C551?w=1024 1024w, https://github.blog/wp-content/uploads/2021/12/python-two-files-stove-graph-conflict.png?resize=1024%2C551?w=1536 1536w" sizes="(max-width: 1000px) 100vw, 1000px" data-recalc-dims="1"/></p>
<p>In this graph, we annotate some of the graph edges with a <em>precedence</em> value. Paths that include edges with a higher precedence value are preferred over those with lower precedences. This lets us correctly handle Python’s shadowing behavior.</p>
<p>For other programming languages, which don’t implement the same shadowing behavior as Python, we’d use a different pattern of edges to connect everything. For instance, the stack graph for my Rust example from earlier would be:</p>
<p><img loading="lazy" src="https://github.blog/wp-content/uploads/2021/12/rust-stove-graph.png?resize=1024%2C491" alt="the stack graph for conflicting Rust definitions" width="1024" height="491" srcset="https://github.blog/wp-content/uploads/2021/12/rust-stove-graph.png?resize=1024%2C491?w=1400 1400w, https://github.blog/wp-content/uploads/2021/12/rust-stove-graph.png?resize=1024%2C491?w=300 300w, https://github.blog/wp-content/uploads/2021/12/rust-stove-graph.png?resize=1024%2C491?w=768 768w, https://github.blog/wp-content/uploads/2021/12/rust-stove-graph.png?resize=1024%2C491?w=1024 1024w" sizes="(max-width: 1000px) 100vw, 1000px" data-recalc-dims="1"/></p>
<p>To model Rust’s rule that top-level definitions with the same name are conflicts, we have a single node that all definitions hang off of. We can use precedences to choose whether to show all conflicting definitions (by giving them all the same precedence value), or just the first one (by assigning precedences sequentially).</p>
<p>With a stack graph available to us, we can implement “jump to definition:”</p>
<ol>
<li>The user clicks on a reference.</li>
<li>We load in the stack graphs for each file in the commit, and merge them</li>
<li>We perform a path-finding search starting from the reference node</li>
<li>Any valid paths that we find represent the definitions that the reference</li>
</ol>
<h2 id="creating-stack-graphs-using-tree-sitter">Creating stack graphs using Tree-sitter<a href="#creating-stack-graphs-using-tree-sitter" aria-label="Creating stack graphs using Tree-sitter" data-anchorjs-icon="#"></a></h2>
<p>I’ve described how to <em>use</em> stack graphs to perform code navigation lookups, but I haven’t mentioned how to create stack graphs from the source code that you push to GitHub.</p>
<p>For that, we turned to <a href="https://tree-sitter.github.io/">Tree-sitter</a>, an open source parsing framework. The Tree-sitter community has already written parsers for a <a href="https://tree-sitter.github.io/tree-sitter/#available-parsers">wide variety</a> of programming languages, and we already use Tree-sitter in many places across GitHub. This makes it a natural choice to build stack graphs on.</p>
<p>Tree-sitter’s parsers already let us efficiently <em>parse</em> the code that our users upload. For instance, the Tree-sitter parser for Python produces a <em>concrete syntax tree</em> (CST) for our <code>stove.py</code> example file:</p>
<pre><code>$ tree-sitter parse stove.py
(module [0, 0] - [10, 0]
  (function_definition [0, 0] - [1, 8]
    name: (identifier [0, 4] - [0, 8])
    parameters: (parameters [0, 8] - [0, 10])
    body: (block [1, 4] - [1, 8]
      (pass_statement [1, 4] - [1, 8])))
  (function_definition [3, 0] - [4, 8]
    name: (identifier [3, 4] - [3, 9])
    parameters: (parameters [3, 9] - [3, 11])
    body: (block [4, 4] - [4, 8]
      (pass_statement [4, 4] - [4, 8])))
  (function_definition [6, 0] - [7, 8]
    name: (identifier [6, 4] - [6, 9])
    parameters: (parameters [6, 9] - [6, 11])
    body: (block [7, 4] - [7, 8]
      (pass_statement [7, 4] - [7, 8]))))
</code></pre>
<p>Tree-sitter also provides a query language that lets us look for patterns within the CST:</p>
<pre><code>(function_definition
  name: (identifier) @name) @function
</code></pre>
<p>This query would locate all three of our example method definitions, annotating each definition as a whole with a <code>@function</code> label and the name of each method with a <code>@name</code> label.</p>
<p>As part of developing stack graphs, we’ve added a new <a href="https://github.com/tree-sitter/tree-sitter-graph"><em>graph construction</em> language</a> to Tree-sitter, which lets you construct arbitrary graph structures (including but not limited to stack graphs) from parsed CSTs. You use <em>stanzas</em> to define the gadget of graph nodes and edges that should be created for each occurrence of a Tree-sitter query, and how the newly created nodes and edges should connect to graph content that you’ve already created elsewhere. For instance, the following snippet would create the stack graph definition node for my example Python method definitions:</p>
<pre><code>(function_definition
  name: (identifier) @name) @function
{
    node @function.def
    attr (@function.def) kind = &#34;definition&#34;
    attr (@function.def) symbol = @name
    edge @function.containing_scope -&gt; @function.def
}
</code></pre>
<p>This approach lets us create stack graphs incrementally for each source file that we receive, while only having to analyze the source code content, and without having to invoke any language-specific tooling or build systems. (The only language-specific part is the set of graph construction rules for that language!)</p>
<h2 id="but-wait-theres-more">But wait, there’s more!<a href="#but-wait-theres-more" aria-label="But wait, there’s more!" data-anchorjs-icon="#"></a></h2>
<p>This post is already quite long, and I’ve only scratched the surface. You might be wondering:</p>
<ul>
<li>Performing a full path-finding search for every “jump to definition” query seems wasteful. Can we precalculate more information at index time while still being incremental?
</li>
<li>
<p>All the examples we’ve shown are pretty trivial. Can we handle more complex examples?</p>
<p>For instance, how about the following Python file, where we need to use <em>dataflow</em> to trace what particular value was passed in as a parameter to <code>passthrough</code> to correctly resolve the reference to <code>one</code> on the final line?</p>
<pre><code>def passthrough(x):
  return x

class A:
  one = 1

passthrough(A).one
</code></pre>
<p>Or the following Java file, where we have to trace inheritance and generic type parameters to see that the reference to <code>length</code> should resolve to <code>String.length</code> from the Java standard library?</p>
<pre><code>import java.util.HashMap;

class MyMap extends HashMap&lt;String, String&gt; {
  int firstLength() {
      return this.entrySet().iterator().next().getKey().length();
  }
}
</code></pre>
</li>
<li>Why aren’t we using the <a href="https://microsoft.github.io/language-server-protocol/">Language Server Protocol</a> (LSP) or <a href="https://code.visualstudio.com/blogs/2019/02/19/lsif">Language Server Index Format</a> (LSIF)?
</li>
</ul>
<p>To dig even deeper and learn more, I encourage you to check out my <a href="https://dcreager.net/talks/2021-strange-loop/">Strange Loop</a> talk and the <code><a href="https://github.com/github/stack-graphs/">stack-graphs</a></code> crate: our open source Rust implementation of these ideas. And in the meantime, keep navigating!</p>

	

	

</div></div>
  </body>
</html>
