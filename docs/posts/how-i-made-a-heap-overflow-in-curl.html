<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://daniel.haxx.se/blog/2023/10/11/how-i-made-a-heap-overflow-in-curl/">Original</a>
    <h1>How I Made a Heap Overflow in Curl</h1>
    
    <div id="readability-page-1" class="page"><div>
		
<p>In association with the release of <a href="https://daniel.haxx.se/blog/2023/10/11/curl-8-4-0/" data-type="post" data-id="23241">curl 8.4.0</a>, we publish a security advisory and all the details for <a href="https://curl.se/docs/CVE-2023-38545.html">CVE-2023-38545</a>. This problem is the worst security problem found in curl in a long time. We set it to severity <strong>HIGH</strong>.</p>



<p>While the advisory contains all the necessary details. I figured I would use a few additional words and expand the explanations for anyone who cares to understand how this flaw works and how it happened.</p>



<h2>Background</h2>



<p>curl has supported <a href="https://en.wikipedia.org/wiki/SOCKS">SOCKS5</a> since <a href="https://github.com/curl/curl/commit/8aa3f143035ad982acb6e596a8653ac41a7860cc">August 2002</a>.</p>



<p>SOCKS5 is a proxy protocol. It is a rather simple protocol for setting up network communication via a dedicated “middle man”. The protocol is for example typically used when setting up communication to get done over Tor but also for accessing Internet from within organizations and companies.</p>



<p>SOCKS5 has two different host name resolver modes.  Either the client resolves the host name <em>locally</em> and passes on the destination as a resolved address, or the client passes on the entire host name to the proxy and lets the proxy itself resolve the host <em>remotely</em>.</p>



<p>In early 2020 I assigned myself an old long-standing curl issue: to convert the function that connects to a SOCKS5 proxy from a blocking call into a non-blocking state machine. This is for example much noticeable when an application performs a large amount of parallel transfers that all go over SOCKS5.</p>



<p>On February 14 2020 I landed the <a href="https://github.com/curl/curl/commit/4a4b63daaa">main commit for this</a> change in master. It shipped in 7.69.0 as the first release featuring this enhancement. And by extension also the first release  vulnerable to CVE-2023-38545.</p>



<h2>A less wise decision</h2>



<p>The state machine is called repeatedly when there is more network data to work on until it is done: when the connection is established.</p>



<p>At the top of the function I made <a href="https://github.com/curl/curl/blob/d1b0317f9b3e4535fd9006b1faab41cbfa912753/lib/socks.c#L573">this</a>:</p>



<pre>bool socks5_resolve_local =
  (proxytype == CURLPROXY_SOCKS5) ? TRUE : FALSE;</pre>



<p>This boolean variable holds information about whether curl should resolve the host or just pass on the name to the proxy. This assignment is done at the top and thus for every invocation while the state machine is running.</p>



<p>The state machine starts in the INIT state, in which <a href="https://github.com/curl/curl/blob/d1b0317f9b3e4535fd9006b1faab41cbfa912753/lib/socks.c#L589-L593">the main bug</a> for today’s story time lies. The flaw is inherited from the function from before it was turned into a state-machine.</p>



<pre>if(!socks5_resolve_local &amp;&amp; hostname_len &gt; 255) {
  socks5_resolve_local = TRUE;
}</pre>



<p>SOCKS5 allows the host name field to be up to 255 bytes long, meaning a SOCKS5 proxy cannot resolve a longer host name. On finding a too long host name. the curl code  makes the bad decision to instead switch over to local resolve mode. It sets the local variable for that purpose to TRUE. (This condition is a leftover from code added ages ago. I think it was downright wrong to switch mode like this, since the user asked for remote resolve curl should stick to that or fail. It is not even likely to work to just switch, even in “good” situations.)</p>



<p>The state machine then switches state and continues.</p>



<h2>The issue triggers</h2>



<p>If the state machine cannot continue because it has no more data to work with, like if the SOCKS5 server is not fast enough, it returns. It gets called again when there is data available to continue working on. Moments later.</p>



<p>But now, look at the local variable <strong>socks5_resolve_local</strong> at the top of the function again. It again gets set to a value depending on proxy mode – <em>not remembering the changed value because of the too long host name</em>. Now it again holds a value that says the proxy should resolve the name remotely. But the name is too long…</p>



<p>curl builds a protocol frame in a memory buffer, and it copies the destination to that buffer. Since the code wrongly thinks it should pass on the host name, even though the host name is too long to fit, the memory copy can overflow the allocated target buffer. Of course depending on the length of the host name and the size of the target buffer.</p>



<h2>Target buffer</h2>



<p>The allocated memory area curl uses to build the protocol frame in to send to the proxy, is the same as the regular download buffer. It is simply reused for this purpose before the transfer starts. The download buffer is 16kB by default but can also be set to use a different size at the request of the application. The curl tool sets the buffer size to 100kB. The minimum accepted size is 1024 bytes.</p>



<p>If the buffer size is set smaller than 65541 bytes this overflow is possible. The smaller the size, the larger the possible overflow. </p>



<h2>Host name length</h2>



<p>A host name in a URL has no real size limit, but libcurl’s URL parser refuses to accept names longer than 65535 bytes. DNS only accepts host names up 253 bytes. So, a legitimate name that is longer than 253 bytes is unusual. A real name that is longer than 1024 is virtually unheard of.</p>



<p>Thus it pretty much requires a malicious actor to feed a super-long host name into this equation to trigger this flaw. To use it in an attack. The name needs to be longer than the target buffer to make the memory copy overwrite heap memory.</p>



<h2>Host name contents</h2>



<p>The host name field of a URL can only contain a subset of octets. A range of byte values are plain invalid and would cause the URL parser to reject it. If libcurl is built to use an IDN library, that one might also reject invalid host names. This bug can therefore only trigger if the right set of bytes are used in the host name.</p>



<h2>Attack</h2>



<p>An attacker that controls an HTTPS server that a libcurl using client accesses over a SOCKS5 proxy (using the proxy-resolver-mode) can make it return a crafted redirect to the application via a HTTP 30x response.</p>



<p>Such a 30x redirect would then contain a Location: header in the style of:</p>



<pre>Location: https://aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa/</pre>



<p>… where the host name is longer than 16kB and up to 64kB</p>



<p>If the libcurl using client has automatic redirect-following enabled, and the SOCKS5 proxy is “slow enough” to trigger the local variable bug, it will copy the crafted host name into the too small allocated buffer and into the adjacent heap memory.</p>



<p>A heap buffer overflow has then occurred.</p>



<h2>The fix</h2>



<p>curl should <em>not</em> switch mode from remote resolve to local resolve due to too long host name. It should rather return an error and starting in curl 8.4.0, it does.</p>



<p>We now also have a dedicated test case for this scenario.</p>



<h2>Credits</h2>



<p>This issue was reported, analyzed and patched by Jay Satiro.</p>



<p>This is the largest curl bug-bounty paid to date:  <strong>4,660 USD</strong> (plus 1,165 USD to the curl project, as per <a href="https://hackerone.com/ibb?type=team">IBB policy</a>)</p>


<div>
<figure><a href="https://daniel.haxx.se/blog/wp-content/uploads/2023/10/dilbert-minivan.png"><img decoding="async" width="1200" height="364" src="https://daniel.haxx.se/blog/wp-content/uploads/2023/10/dilbert-minivan.png" alt=""/></a><figcaption>Classic related Dilbert strip. The original URL seems to no longer be available.</figcaption></figure></div>


<h2>Rewrite it?</h2>



<p>Yes, this family of flaws would have been impossible if curl had been written in a memory-safe language instead of C, but porting curl to another language is not on the agenda. I am sure the news about this vulnerability will trigger a new flood of questions about and calls for that and I can sigh, roll my eyes and try to answer this again.</p>



<p>The only approach in that direction I consider viable and sensible is to:</p>



<ol>
<li>allow, use and support more dependencies written in memory-safe languages and</li>



<li>potentially and gradually replace parts of curl piecemeal, like with the introduction of <a href="https://daniel.haxx.se/blog/2020/10/09/rust-in-curl-with-hyper/" data-type="post" data-id="14663">hyper</a>.</li>
</ol>



<p>Such development is however currently happening in a near glacial speed and shows with painful clarity the challenges involved. curl will remain written in C for the foreseeable future.</p>



<p>Everyone not happy about this are of course welcome to roll up their sleeves and get working.</p>



<p>Including the latest two CVEs reported for curl 8.4.0, the accumulated total says that <strong>41%</strong> of the security vulnerabilities ever found in curl would likely not have happened should we have used a memory-safe language. But also: the rust language was not even a possibility for practical use for this purpose during the time in which we introduced maybe the first 80% of the C related problems.</p>



<h2>It burns in my soul</h2>



<p>Reading the code now it is impossible not to see the bug. Yes, it truly aches having to accept the fact that I did this mistake without noticing and that the flaw then remained undiscovered in code for 1315 days. I apologize. I am but a human.</p>



<p>It could have been detected with a better set of tests. We repeatedly run several static code analyzers on the code and none of them have spotted any problems in this function.</p>



<p>In hindsight, shipping a heap overflow in code installed in over twenty billion instances is not an experience I would recommend.</p>



<h2>Behind the scenes</h2>



<p>To learn how this flaw was reported and we worked on the issue before it was made public. Go check the Hackerone report (will be made public asap).</p>
	</div></div>
  </body>
</html>
