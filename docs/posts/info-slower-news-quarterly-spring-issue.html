<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://slowernews.substack.com/p/2023-spring">Original</a>
    <h1>|INFO| Slower News Quarterly - Spring Issue.</h1>
    
    <div id="readability-page-1" class="page"><div><p>Effects are an escape hatch from the React paradigm. They let you ‚Äústep outside‚Äù of React and synchronize your components with some external system like a non-React widget, network, or the browser DOM. If there is no external system involved (for example, if you want to update a component‚Äôs state when some props or state change), you shouldn‚Äôt need an Effect. Removing unnecessary Effects will make your code easier to follow, faster to run, and less error-prone.</p>
<div><h3>You will learn</h3><ul>
<li>Why and how to remove unnecessary Effects from your components</li>
<li>How to cache expensive computations without Effects</li>
<li>How to reset and adjust component state without Effects</li>
<li>How to share logic between event handlers</li>
<li>Which logic should be moved to event handlers</li>
<li>How to notify parent components about changes</li>
</ul></div>
<h2 id="how-to-remove-unnecessary-effects">How to remove unnecessary Effects <a href="#how-to-remove-unnecessary-effects" aria-label="Link for How to remove unnecessary Effects " title="Link for How to remove unnecessary Effects "><svg width="1em" height="1em" viewBox="0 0 13 13" xmlns="http://www.w3.org/2000/svg"><g fill="currentColor" fill-rule="evenodd"><path d="M7.778 7.975a2.5 2.5 0 0 0 .347-3.837L6.017 2.03a2.498 2.498 0 0 0-3.542-.007 2.5 2.5 0 0 0 .006 3.543l1.153 1.15c.07-.29.154-.563.25-.773.036-.077.084-.16.14-.25L3.18 4.85a1.496 1.496 0 0 1 .002-2.12 1.496 1.496 0 0 1 2.12 0l2.124 2.123a1.496 1.496 0 0 1-.333 2.37c.16.246.42.504.685.752z"></path><path d="M5.657 4.557a2.5 2.5 0 0 0-.347 3.837l2.108 2.108a2.498 2.498 0 0 0 3.542.007 2.5 2.5 0 0 0-.006-3.543L9.802 5.815c-.07.29-.154.565-.25.774-.036.076-.084.16-.14.25l.842.84c.585.587.59 1.532 0 2.122-.587.585-1.532.59-2.12 0L6.008 7.68a1.496 1.496 0 0 1 .332-2.372c-.16-.245-.42-.503-.685-.75z"></path></g></svg></a></h2>
<p>There are two common cases in which you don‚Äôt need Effects:</p>
<ul>
<li><strong>You don‚Äôt need Effects to transform data for rendering.</strong> For example, let‚Äôs say you want to filter a list before displaying it. You might feel tempted to write an Effect that updates a state variable when the list changes. However, this is inefficient. When you update the state, React will first call your component functions to calculate what should be on the screen. Then React will <a href="https://slowernews.substack.com/learn/render-and-commit">‚Äúcommit‚Äù</a> these changes to the DOM, updating the screen. Then React will run your Effects. If your Effect <em>also</em> immediately updates the state, this restarts the whole process from scratch! To avoid the unnecessary render passes, transform all the data at the top level of your components. That code will automatically re-run whenever your props or state change.</li>
<li><strong>You don‚Äôt need Effects to handle user events.</strong> For example, let‚Äôs say you want to send an <code>/api/buy</code> POST request and show a notification when the user buys a product. In the Buy button click event handler, you know exactly what happened. By the time an Effect runs, you don‚Äôt know <em>what</em> the user did (for example, which button was clicked). This is why you‚Äôll usually handle user events in the corresponding event handlers.</li>
</ul>
<p>You <em>do</em> need Effects to <a href="https://slowernews.substack.com/learn/synchronizing-with-effects#what-are-effects-and-how-are-they-different-from-events">synchronize</a> with external systems. For example, you can write an Effect that keeps a jQuery widget synchronized with the React state. You can also fetch data with Effects: for example, you can synchronize the search results with the current search query. Keep in mind that modern <a href="https://slowernews.substack.com/learn/start-a-new-react-project#production-grade-react-frameworks">frameworks</a> provide more efficient built-in data fetching mechanisms than writing Effects directly in your components.</p>
<p>To help you gain the right intuition, let‚Äôs look at some common concrete examples!</p>
<h3 id="updating-state-based-on-props-or-state">Updating state based on props or state <a href="#updating-state-based-on-props-or-state" aria-label="Link for Updating state based on props or state " title="Link for Updating state based on props or state "><svg width="1em" height="1em" viewBox="0 0 13 13" xmlns="http://www.w3.org/2000/svg"><g fill="currentColor" fill-rule="evenodd"><path d="M7.778 7.975a2.5 2.5 0 0 0 .347-3.837L6.017 2.03a2.498 2.498 0 0 0-3.542-.007 2.5 2.5 0 0 0 .006 3.543l1.153 1.15c.07-.29.154-.563.25-.773.036-.077.084-.16.14-.25L3.18 4.85a1.496 1.496 0 0 1 .002-2.12 1.496 1.496 0 0 1 2.12 0l2.124 2.123a1.496 1.496 0 0 1-.333 2.37c.16.246.42.504.685.752z"></path><path d="M5.657 4.557a2.5 2.5 0 0 0-.347 3.837l2.108 2.108a2.498 2.498 0 0 0 3.542.007 2.5 2.5 0 0 0-.006-3.543L9.802 5.815c-.07.29-.154.565-.25.774-.036.076-.084.16-.14.25l.842.84c.585.587.59 1.532 0 2.122-.587.585-1.532.59-2.12 0L6.008 7.68a1.496 1.496 0 0 1 .332-2.372c-.16-.245-.42-.503-.685-.75z"></path></g></svg></a></h3>
<p>Suppose you have a component with two state variables: <code>firstName</code> and <code>lastName</code>. You want to calculate a <code>fullName</code> from them by concatenating them. Moreover, you‚Äôd like <code>fullName</code> to update whenever <code>firstName</code> or <code>lastName</code> change. Your first instinct might be to add a <code>fullName</code> state variable and update it in an Effect:</p>
<!--$--><div><div><div><div><pre><code><p><span>function</span> <span>Form</span><span>(</span><span>)</span> <span>{</span><br/></p><p><span>const</span> <span>[</span><span>firstName</span><span>,</span> <span>setFirstName</span><span>]</span> = <span>useState</span><span>(</span><span>&#39;Taylor&#39;</span><span>)</span><span>;</span><br/></p><p><span>const</span> <span>[</span><span>lastName</span><span>,</span> <span>setLastName</span><span>]</span> = <span>useState</span><span>(</span><span>&#39;Swift&#39;</span><span>)</span><span>;</span><br/></p><p><span>// üî¥ Avoid: redundant state and unnecessary Effect</span><br/></p><p><span>const</span> <span>[</span><span>fullName</span><span>,</span> <span>setFullName</span><span>]</span> = <span>useState</span><span>(</span><span>&#39;&#39;</span><span>)</span><span>;</span><br/></p><p><span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span><br/></p><p><span>setFullName</span><span>(</span><span>firstName</span> + <span>&#39; &#39;</span> + <span>lastName</span><span>)</span><span>;</span><br/></p><p><span>}</span><span>,</span> <span>[</span><span>firstName</span><span>,</span> <span>lastName</span><span>]</span><span>)</span><span>;</span><br/></p><p><span>// ...</span><br/></p><p><span>}</span></p></code></pre></div></div></div></div><!--/$-->
<p>This is more complicated than necessary. It is inefficient too: it does an entire render pass with a stale value for <code>fullName</code>, then immediately re-renders with the updated value. Remove the state variable and the Effect:</p>
<!--$--><div><div><div><div><pre><code><p><span>function</span> <span>Form</span><span>(</span><span>)</span> <span>{</span><br/></p><p><span>const</span> <span>[</span><span>firstName</span><span>,</span> <span>setFirstName</span><span>]</span> = <span>useState</span><span>(</span><span>&#39;Taylor&#39;</span><span>)</span><span>;</span><br/></p><p><span>const</span> <span>[</span><span>lastName</span><span>,</span> <span>setLastName</span><span>]</span> = <span>useState</span><span>(</span><span>&#39;Swift&#39;</span><span>)</span><span>;</span><br/></p><p><span>// ‚úÖ Good: calculated during rendering</span><br/></p><p><span>const</span> <span>fullName</span> = <span>firstName</span> + <span>&#39; &#39;</span> + <span>lastName</span><span>;</span><br/></p><p><span>// ...</span><br/></p><p><span>}</span></p></code></pre></div></div></div></div><!--/$-->
<p><strong>When something can be calculated from the existing props or state, <a href="https://slowernews.substack.com/learn/choosing-the-state-structure#avoid-redundant-state">don‚Äôt put it in state.</a> Instead, calculate it during rendering.</strong> This makes your code faster (you avoid the extra ‚Äúcascading‚Äù updates), simpler (you remove some code), and less error-prone (you avoid bugs caused by different state variables getting out of sync with each other). If this approach feels new to you, <a href="https://slowernews.substack.com/learn/thinking-in-react#step-3-find-the-minimal-but-complete-representation-of-ui-state">Thinking in React</a> explains what should go into state.</p>
<h3 id="caching-expensive-calculations">Caching expensive calculations <a href="#caching-expensive-calculations" aria-label="Link for Caching expensive calculations " title="Link for Caching expensive calculations "><svg width="1em" height="1em" viewBox="0 0 13 13" xmlns="http://www.w3.org/2000/svg"><g fill="currentColor" fill-rule="evenodd"><path d="M7.778 7.975a2.5 2.5 0 0 0 .347-3.837L6.017 2.03a2.498 2.498 0 0 0-3.542-.007 2.5 2.5 0 0 0 .006 3.543l1.153 1.15c.07-.29.154-.563.25-.773.036-.077.084-.16.14-.25L3.18 4.85a1.496 1.496 0 0 1 .002-2.12 1.496 1.496 0 0 1 2.12 0l2.124 2.123a1.496 1.496 0 0 1-.333 2.37c.16.246.42.504.685.752z"></path><path d="M5.657 4.557a2.5 2.5 0 0 0-.347 3.837l2.108 2.108a2.498 2.498 0 0 0 3.542.007 2.5 2.5 0 0 0-.006-3.543L9.802 5.815c-.07.29-.154.565-.25.774-.036.076-.084.16-.14.25l.842.84c.585.587.59 1.532 0 2.122-.587.585-1.532.59-2.12 0L6.008 7.68a1.496 1.496 0 0 1 .332-2.372c-.16-.245-.42-.503-.685-.75z"></path></g></svg></a></h3>
<p>This component computes <code>visibleTodos</code> by taking the <code>todos</code> it receives by props and filtering them according to the <code>filter</code> prop. You might feel tempted to store the result in state and update it from an Effect:</p>
<!--$--><div><div><div><div><pre><code><p><span>function</span> <span>TodoList</span><span>(</span><span>{</span> <span>todos</span><span>,</span> <span>filter</span> <span>}</span><span>)</span> <span>{</span><br/></p><p><span>const</span> <span>[</span><span>newTodo</span><span>,</span> <span>setNewTodo</span><span>]</span> = <span>useState</span><span>(</span><span>&#39;&#39;</span><span>)</span><span>;</span><br/></p><p><span>// üî¥ Avoid: redundant state and unnecessary Effect</span><br/></p><p><span>const</span> <span>[</span><span>visibleTodos</span><span>,</span> <span>setVisibleTodos</span><span>]</span> = <span>useState</span><span>(</span><span>[</span><span>]</span><span>)</span><span>;</span><br/></p><p><span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span><br/></p><p><span>setVisibleTodos</span><span>(</span><span>getFilteredTodos</span><span>(</span><span>todos</span><span>,</span> <span>filter</span><span>)</span><span>)</span><span>;</span><br/></p><p><span>}</span><span>,</span> <span>[</span><span>todos</span><span>,</span> <span>filter</span><span>]</span><span>)</span><span>;</span><br/></p><p><span>// ...</span><br/></p><p><span>}</span></p></code></pre></div></div></div></div><!--/$-->
<p>Like in the earlier example, this is both unnecessary and inefficient. First, remove the state and the Effect:</p>
<!--$--><div><div><div><div><pre><code><p><span>function</span> <span>TodoList</span><span>(</span><span>{</span> <span>todos</span><span>,</span> <span>filter</span> <span>}</span><span>)</span> <span>{</span><br/></p><p><span>const</span> <span>[</span><span>newTodo</span><span>,</span> <span>setNewTodo</span><span>]</span> = <span>useState</span><span>(</span><span>&#39;&#39;</span><span>)</span><span>;</span><br/></p><p><span>// ‚úÖ This is fine if getFilteredTodos() is not slow.</span><br/></p><p><span>const</span> <span>visibleTodos</span> = <span>getFilteredTodos</span><span>(</span><span>todos</span><span>,</span> <span>filter</span><span>)</span><span>;</span><br/></p><p><span>// ...</span><br/></p><p><span>}</span></p></code></pre></div></div></div></div><!--/$-->
<p>Usually, this code is fine! But maybe <code>getFilteredTodos()</code> is slow or you have a lot of <code>todos</code>. In that case you don‚Äôt want to recalculate <code>getFilteredTodos()</code> if some unrelated state variable like <code>newTodo</code> has changed.</p>
<p>You can cache (or <a href="https://en.wikipedia.org/wiki/Memoization" target="_blank" rel="nofollow noopener noreferrer">‚Äúmemoize‚Äù</a>) an expensive calculation by wrapping it in a <a href="https://slowernews.substack.com/reference/react/useMemo"><code>useMemo</code></a> Hook:</p>
<!--$--><div><div><div><div><pre><code><p><span>import</span> <span>{</span> <span>useMemo</span><span>,</span> <span>useState</span> <span>}</span> <span>from</span> <span>&#39;react&#39;</span><span>;</span><br/></p><p><span>function</span> <span>TodoList</span><span>(</span><span>{</span> <span>todos</span><span>,</span> <span>filter</span> <span>}</span><span>)</span> <span>{</span><br/></p><p><span>const</span> <span>[</span><span>newTodo</span><span>,</span> <span>setNewTodo</span><span>]</span> = <span>useState</span><span>(</span><span>&#39;&#39;</span><span>)</span><span>;</span><br/></p><p><span>const</span> <span>visibleTodos</span> = <span>useMemo</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span><br/></p><p><span>// ‚úÖ Does not re-run unless todos or filter change</span><br/></p><p><span>return</span> <span>getFilteredTodos</span><span>(</span><span>todos</span><span>,</span> <span>filter</span><span>)</span><span>;</span><br/></p><p><span>}</span><span>,</span> <span>[</span><span>todos</span><span>,</span> <span>filter</span><span>]</span><span>)</span><span>;</span><br/></p><p><span>// ...</span><br/></p><p><span>}</span></p></code></pre></div></div></div></div><!--/$-->
<p>Or, written as a single line:</p>
<!--$--><div><div><div><div><pre><code><p><span>import</span> <span>{</span> <span>useMemo</span><span>,</span> <span>useState</span> <span>}</span> <span>from</span> <span>&#39;react&#39;</span><span>;</span><br/></p><p><span>function</span> <span>TodoList</span><span>(</span><span>{</span> <span>todos</span><span>,</span> <span>filter</span> <span>}</span><span>)</span> <span>{</span><br/></p><p><span>const</span> <span>[</span><span>newTodo</span><span>,</span> <span>setNewTodo</span><span>]</span> = <span>useState</span><span>(</span><span>&#39;&#39;</span><span>)</span><span>;</span><br/></p><p><span>// ‚úÖ Does not re-run getFilteredTodos() unless todos or filter change</span><br/></p><p><span>const</span> <span>visibleTodos</span> = <span>useMemo</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>getFilteredTodos</span><span>(</span><span>todos</span><span>,</span> <span>filter</span><span>)</span><span>,</span> <span>[</span><span>todos</span><span>,</span> <span>filter</span><span>]</span><span>)</span><span>;</span><br/></p><p><span>// ...</span><br/></p><p><span>}</span></p></code></pre></div></div></div></div><!--/$-->
<p><strong>This tells React that you don‚Äôt want the inner function to re-run unless either <code>todos</code> or <code>filter</code> have changed.</strong> React will remember the return value of <code>getFilteredTodos()</code> during the initial render. During the next renders, it will check if <code>todos</code> or <code>filter</code> are different. If they‚Äôre the same as last time, <code>useMemo</code> will return the last result it has stored. But if they are different, React will call the inner function again (and store its result).</p>
<p>The function you wrap in <a href="https://slowernews.substack.com/reference/react/useMemo"><code>useMemo</code></a> runs during rendering, so this only works for <a href="https://slowernews.substack.com/learn/keeping-components-pure">pure calculations.</a></p>
<details><summary tabindex="-1"><h5><svg width="1.5em" height="1.5em" viewBox="0 0 72 72" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M34.7409 59.7228L32.9567 58.9094C27.2672 56.3157 20.7328 56.3157 15.0433 58.9094C12.6018 60.0224 9.39163 59.0275 8.44602 56.0621C7.45647 52.9589 5.99975 46.5898 6 35.9997C6.00029 23.5648 8.00803 18.3599 9.11099 16.4196C9.67795 15.4222 10.5255 14.8455 11.2254 14.5264L12.0179 14.1651C19.6351 10.6926 28.4011 10.6738 36 14.1733C43.5989 10.6738 52.3649 10.6926 59.9821 14.1651L60.7746 14.5264C61.4745 14.8455 62.3221 15.4222 62.889 16.4196C63.992 18.3599 65.9997 23.5648 66 35.9997C66.0002 46.5898 64.5435 52.9589 63.554 56.0621C62.6084 59.0275 59.3982 60.0224 56.9567 58.9094C51.2672 56.3157 44.7328 56.3157 39.0433 58.9094L37.2591 59.7228C37.1986 59.7508 37.1373 59.7767 37.0753 59.8004C36.4484 60.0411 35.7556 60.0653 35.1102 59.8648C34.9847 59.8258 34.8613 59.7784 34.7409 59.7228ZM14.5068 19.6246C20.3733 16.9501 27.0874 16.8775 33 19.4067V52.473C26.7613 50.32 19.9378 50.471 13.7811 52.9261C13.0005 49.9843 11.9998 44.547 12 35.9998C12.0002 25.5786 13.4879 21.1893 14.1179 19.8018L14.5068 19.6246ZM39 52.473C45.2387 50.32 52.0622 50.471 58.2189 52.9261C58.9995 49.9843 60.0002 44.547 60 35.9998C59.9998 25.5786 58.5121 21.1893 57.8821 19.8018L57.4932 19.6246C51.6267 16.9501 44.9126 16.8775 39 19.4067V52.473Z" fill="currentColor"></path></svg>Deep Dive</h5><div><h4 id="how-to-tell-if-a-calculation-is-expensive">How to tell if a calculation is expensive? <a href="#how-to-tell-if-a-calculation-is-expensive" aria-label="Link for How to tell if a calculation is expensive? " title="Link for How to tell if a calculation is expensive? "><svg width="1em" height="1em" viewBox="0 0 13 13" xmlns="http://www.w3.org/2000/svg"><g fill="currentColor" fill-rule="evenodd"><path d="M7.778 7.975a2.5 2.5 0 0 0 .347-3.837L6.017 2.03a2.498 2.498 0 0 0-3.542-.007 2.5 2.5 0 0 0 .006 3.543l1.153 1.15c.07-.29.154-.563.25-.773.036-.077.084-.16.14-.25L3.18 4.85a1.496 1.496 0 0 1 .002-2.12 1.496 1.496 0 0 1 2.12 0l2.124 2.123a1.496 1.496 0 0 1-.333 2.37c.16.246.42.504.685.752z"></path><path d="M5.657 4.557a2.5 2.5 0 0 0-.347 3.837l2.108 2.108a2.498 2.498 0 0 0 3.542.007 2.5 2.5 0 0 0-.006-3.543L9.802 5.815c-.07.29-.154.565-.25.774-.036.076-.084.16-.14.25l.842.84c.585.587.59 1.532 0 2.122-.587.585-1.532.59-2.12 0L6.008 7.68a1.496 1.496 0 0 1 .332-2.372c-.16-.245-.42-.503-.685-.75z"></path></g></svg></a></h4></div></summary><div><p>In general, unless you‚Äôre creating or looping over thousands of objects, it‚Äôs probably not expensive. If you want to get more confidence, you can add a console log to measure the time spent in a piece of code:</p><!--$--><div><div><div><div><pre><code><p><span>console</span>.<span>time</span><span>(</span><span>&#39;filter array&#39;</span><span>)</span><span>;</span><br/></p><p><span>const</span> <span>visibleTodos</span> = <span>getFilteredTodos</span><span>(</span><span>todos</span><span>,</span> <span>filter</span><span>)</span><span>;</span><br/></p><p><span>console</span>.<span>timeEnd</span><span>(</span><span>&#39;filter array&#39;</span><span>)</span><span>;</span></p></code></pre></div></div></div></div><!--/$--><p>Perform the interaction you‚Äôre measuring (for example, typing into the input). You will then see logs like <code>filter array: 0.15ms</code> in your console. If the overall logged time adds up to a significant amount (say, <code>1ms</code> or more), it might make sense to memoize that calculation. As an experiment, you can then wrap the calculation in <code>useMemo</code> to verify whether the total logged time has decreased for that interaction or not:</p><!--$--><div><div><div><div><pre><code><p><span>console</span>.<span>time</span><span>(</span><span>&#39;filter array&#39;</span><span>)</span><span>;</span><br/></p><p><span>const</span> <span>visibleTodos</span> = <span>useMemo</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span><br/></p><p><span>return</span> <span>getFilteredTodos</span><span>(</span><span>todos</span><span>,</span> <span>filter</span><span>)</span><span>;</span> <span>// Skipped if todos and filter haven&#39;t changed</span><br/></p><p><span>}</span><span>,</span> <span>[</span><span>todos</span><span>,</span> <span>filter</span><span>]</span><span>)</span><span>;</span><br/></p><p><span>console</span>.<span>timeEnd</span><span>(</span><span>&#39;filter array&#39;</span><span>)</span><span>;</span></p></code></pre></div></div></div></div><!--/$--><p><code>useMemo</code> won‚Äôt make the <em>first</em> render faster. It only helps you skip unnecessary work on updates.</p><p>Keep in mind that your machine is probably faster than your users‚Äô so it‚Äôs a good idea to test the performance with an artificial slowdown. For example, Chrome offers a <a href="https://developer.chrome.com/blog/new-in-devtools-61/#throttling" target="_blank" rel="nofollow noopener noreferrer">CPU Throttling</a> option for this.</p><p>Also note that measuring performance in development will not give you the most accurate results. (For example, when <a href="https://slowernews.substack.com/reference/react/StrictMode">Strict Mode</a> is on, you will see each component render twice rather than once.) To get the most accurate timings, build your app for production and test it on a device like your users have.</p></div></details>
<h3 id="resetting-all-state-when-a-prop-changes">Resetting all state when a prop changes <a href="#resetting-all-state-when-a-prop-changes" aria-label="Link for Resetting all state when a prop changes " title="Link for Resetting all state when a prop changes "><svg width="1em" height="1em" viewBox="0 0 13 13" xmlns="http://www.w3.org/2000/svg"><g fill="currentColor" fill-rule="evenodd"><path d="M7.778 7.975a2.5 2.5 0 0 0 .347-3.837L6.017 2.03a2.498 2.498 0 0 0-3.542-.007 2.5 2.5 0 0 0 .006 3.543l1.153 1.15c.07-.29.154-.563.25-.773.036-.077.084-.16.14-.25L3.18 4.85a1.496 1.496 0 0 1 .002-2.12 1.496 1.496 0 0 1 2.12 0l2.124 2.123a1.496 1.496 0 0 1-.333 2.37c.16.246.42.504.685.752z"></path><path d="M5.657 4.557a2.5 2.5 0 0 0-.347 3.837l2.108 2.108a2.498 2.498 0 0 0 3.542.007 2.5 2.5 0 0 0-.006-3.543L9.802 5.815c-.07.29-.154.565-.25.774-.036.076-.084.16-.14.25l.842.84c.585.587.59 1.532 0 2.122-.587.585-1.532.59-2.12 0L6.008 7.68a1.496 1.496 0 0 1 .332-2.372c-.16-.245-.42-.503-.685-.75z"></path></g></svg></a></h3>
<p>This <code>ProfilePage</code> component receives a <code>userId</code> prop. The page contains a comment input, and you use a <code>comment</code> state variable to hold its value. One day, you notice a problem: when you navigate from one profile to another, the <code>comment</code> state does not get reset. As a result, it‚Äôs easy to accidentally post a comment on a wrong user‚Äôs profile. To fix the issue, you want to clear out the <code>comment</code> state variable whenever the <code>userId</code> changes:</p>
<!--$--><div><div><div><div><pre><code><p><span>export</span> <span>default</span> <span>function</span> <span>ProfilePage</span><span>(</span><span>{</span> <span>userId</span> <span>}</span><span>)</span> <span>{</span><br/></p><p><span>const</span> <span>[</span><span>comment</span><span>,</span> <span>setComment</span><span>]</span> = <span>useState</span><span>(</span><span>&#39;&#39;</span><span>)</span><span>;</span><br/></p><p><span>// üî¥ Avoid: Resetting state on prop change in an Effect</span><br/></p><p><span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span><br/></p><p><span>setComment</span><span>(</span><span>&#39;&#39;</span><span>)</span><span>;</span><br/></p><p><span>}</span><span>,</span> <span>[</span><span>userId</span><span>]</span><span>)</span><span>;</span><br/></p><p><span>// ...</span><br/></p><p><span>}</span></p></code></pre></div></div></div></div><!--/$-->
<p>This is inefficient because <code>ProfilePage</code> and its children will first render with the stale value, and then render again. It is also complicated because you‚Äôd need to do this in <em>every</em> component that has some state inside <code>ProfilePage</code>. For example, if the comment UI is nested, you‚Äôd want to clear out nested comment state too.</p>
<p>Instead, you can tell React that each user‚Äôs profile is conceptually a <em>different</em> profile by giving it an explicit key. Split your component in two and pass a <code>key</code> attribute from the outer component to the inner one:</p>
<!--$--><div><div><div><div><pre><code><p><span>export</span> <span>default</span> <span>function</span> <span>ProfilePage</span><span>(</span><span>{</span> <span>userId</span> <span>}</span><span>)</span> <span>{</span><br/></p><p><span>return</span> <span>(</span><br/></p><p><span>&lt;</span><span>Profile</span><br/></p><p><span>userId</span>=<span>{</span><span>userId</span><span>}</span><br/></p><p><span>key</span>=<span>{</span><span>userId</span><span>}</span><br/></p><p><span>/&gt;</span><br/></p><p><span>)</span><span>;</span><br/></p><p><span>}</span><br/></p><p><span>function</span> <span>Profile</span><span>(</span><span>{</span> <span>userId</span> <span>}</span><span>)</span> <span>{</span><br/></p><p><span>// ‚úÖ This and any other state below will reset on key change automatically</span><br/></p><p><span>const</span> <span>[</span><span>comment</span><span>,</span> <span>setComment</span><span>]</span> = <span>useState</span><span>(</span><span>&#39;&#39;</span><span>)</span><span>;</span><br/></p><p><span>// ...</span><br/></p><p><span>}</span></p></code></pre></div></div></div></div><!--/$-->
<p>Normally, React preserves the state when the same component is rendered in the same spot. <strong>By passing <code>userId</code> as a <code>key</code> to the <code>Profile</code> component, you‚Äôre asking React to treat two <code>Profile</code> components with different <code>userId</code> as two different components that should not share any state.</strong> Whenever the key (which you‚Äôve set to <code>userId</code>) changes, React will recreate the DOM and <a href="https://slowernews.substack.com/learn/preserving-and-resetting-state#option-2-resetting-state-with-a-key">reset the state</a> of the <code>Profile</code> component and all of its children. Now the <code>comment</code> field will clear out automatically when navigating between profiles.</p>
<p>Note that in this example, only the outer <code>ProfilePage</code> component is exported and visible to other files in the project. Components rendering <code>ProfilePage</code> don‚Äôt need to pass the key to it: they pass <code>userId</code> as a regular prop. The fact <code>ProfilePage</code> passes it as a <code>key</code> to the inner <code>Profile</code> component is an implementation detail.</p>
<h3 id="adjusting-some-state-when-a-prop-changes">Adjusting some state when a prop changes <a href="#adjusting-some-state-when-a-prop-changes" aria-label="Link for Adjusting some state when a prop changes " title="Link for Adjusting some state when a prop changes "><svg width="1em" height="1em" viewBox="0 0 13 13" xmlns="http://www.w3.org/2000/svg"><g fill="currentColor" fill-rule="evenodd"><path d="M7.778 7.975a2.5 2.5 0 0 0 .347-3.837L6.017 2.03a2.498 2.498 0 0 0-3.542-.007 2.5 2.5 0 0 0 .006 3.543l1.153 1.15c.07-.29.154-.563.25-.773.036-.077.084-.16.14-.25L3.18 4.85a1.496 1.496 0 0 1 .002-2.12 1.496 1.496 0 0 1 2.12 0l2.124 2.123a1.496 1.496 0 0 1-.333 2.37c.16.246.42.504.685.752z"></path><path d="M5.657 4.557a2.5 2.5 0 0 0-.347 3.837l2.108 2.108a2.498 2.498 0 0 0 3.542.007 2.5 2.5 0 0 0-.006-3.543L9.802 5.815c-.07.29-.154.565-.25.774-.036.076-.084.16-.14.25l.842.84c.585.587.59 1.532 0 2.122-.587.585-1.532.59-2.12 0L6.008 7.68a1.496 1.496 0 0 1 .332-2.372c-.16-.245-.42-.503-.685-.75z"></path></g></svg></a></h3>
<p>Sometimes, you might want to reset or adjust a part of the state on a prop change, but not all of it.</p>
<p>This <code>List</code> component receives a list of <code>items</code> as a prop, and maintains the selected item in the <code>selection</code> state variable. You want to reset the <code>selection</code> to <code>null</code> whenever the <code>items</code> prop receives a different array:</p>
<!--$--><div><div><div><div><pre><code><p><span>function</span> <span>List</span><span>(</span><span>{</span> <span>items</span> <span>}</span><span>)</span> <span>{</span><br/></p><p><span>const</span> <span>[</span><span>isReverse</span><span>,</span> <span>setIsReverse</span><span>]</span> = <span>useState</span><span>(</span><span>false</span><span>)</span><span>;</span><br/></p><p><span>const</span> <span>[</span><span>selection</span><span>,</span> <span>setSelection</span><span>]</span> = <span>useState</span><span>(</span><span>null</span><span>)</span><span>;</span><br/></p><p><span>// üî¥ Avoid: Adjusting state on prop change in an Effect</span><br/></p><p><span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span><br/></p><p><span>setSelection</span><span>(</span><span>null</span><span>)</span><span>;</span><br/></p><p><span>}</span><span>,</span> <span>[</span><span>items</span><span>]</span><span>)</span><span>;</span><br/></p><p><span>// ...</span><br/></p><p><span>}</span></p></code></pre></div></div></div></div><!--/$-->
<p>This, too, is not ideal. Every time the <code>items</code> change, the <code>List</code> and its child components will render with a stale <code>selection</code> value at first. Then React will update the DOM and run the Effects. Finally, the <code>setSelection(null)</code> call will cause another re-render of the <code>List</code> and its child components, restarting this whole process again.</p>
<p>Start by deleting the Effect. Instead, adjust the state directly during rendering:</p>
<!--$--><div><div><div><div><pre><code><p><span>function</span> <span>List</span><span>(</span><span>{</span> <span>items</span> <span>}</span><span>)</span> <span>{</span><br/></p><p><span>const</span> <span>[</span><span>isReverse</span><span>,</span> <span>setIsReverse</span><span>]</span> = <span>useState</span><span>(</span><span>false</span><span>)</span><span>;</span><br/></p><p><span>const</span> <span>[</span><span>selection</span><span>,</span> <span>setSelection</span><span>]</span> = <span>useState</span><span>(</span><span>null</span><span>)</span><span>;</span><br/></p><p><span>// Better: Adjust the state while rendering</span><br/></p><p><span>const</span> <span>[</span><span>prevItems</span><span>,</span> <span>setPrevItems</span><span>]</span> = <span>useState</span><span>(</span><span>items</span><span>)</span><span>;</span><br/></p><p><span>if</span> <span>(</span><span>items</span> !== <span>prevItems</span><span>)</span> <span>{</span><br/></p><p><span>setPrevItems</span><span>(</span><span>items</span><span>)</span><span>;</span><br/></p><p><span>setSelection</span><span>(</span><span>null</span><span>)</span><span>;</span><br/></p><p><span>}</span><br/></p><p><span>// ...</span><br/></p><p><span>}</span></p></code></pre></div></div></div></div><!--/$-->
<p><a href="https://slowernews.substack.com/reference/react/useState#storing-information-from-previous-renders">Storing information from previous renders</a> like this can be hard to understand, but it‚Äôs better than updating the same state in an Effect. In the above example, <code>setSelection</code> is called directly during a render. React will re-render the <code>List</code> <em>immediately</em> after it exits with a <code>return</code> statement. React has not rendered the <code>List</code> children or updated the DOM yet, so this lets the <code>List</code> children skip rendering the stale <code>selection</code> value.</p>
<p>When you update a component during rendering, React throws away the returned JSX and immediately retries rendering. To avoid very slow cascading retries, React only lets you update the <em>same</em> component‚Äôs state during a render. If you update another component‚Äôs state during a render, you‚Äôll see an error. A condition like <code>items !== prevItems</code> is necessary to avoid loops. You may adjust state like this, but any other side effects (like changing the DOM or setting timeouts) should stay in event handlers or Effects to <a href="https://slowernews.substack.com/learn/keeping-components-pure">keep components pure.</a></p>
<p><strong>Although this pattern is more efficient than an Effect, most components shouldn‚Äôt need it either.</strong> No matter how you do it, adjusting state based on props or other state makes your data flow more difficult to understand and debug. Always check whether you can <a href="#resetting-all-state-when-a-prop-changes">reset all state with a key</a> or <a href="#updating-state-based-on-props-or-state">calculate everything during rendering</a> instead. For example, instead of storing (and resetting) the selected <em>item</em>, you can store the selected <em>item ID:</em></p>
<!--$--><div><div><div><div><pre><code><p><span>function</span> <span>List</span><span>(</span><span>{</span> <span>items</span> <span>}</span><span>)</span> <span>{</span><br/></p><p><span>const</span> <span>[</span><span>isReverse</span><span>,</span> <span>setIsReverse</span><span>]</span> = <span>useState</span><span>(</span><span>false</span><span>)</span><span>;</span><br/></p><p><span>const</span> <span>[</span><span>selectedId</span><span>,</span> <span>setSelectedId</span><span>]</span> = <span>useState</span><span>(</span><span>null</span><span>)</span><span>;</span><br/></p><p><span>// ‚úÖ Best: Calculate everything during rendering</span><br/></p><p><span>const</span> <span>selection</span> = <span>items</span>.<span>find</span><span>(</span><span>item</span> <span>=&gt;</span> <span>item</span>.<span>id</span> === <span>selectedId</span><span>)</span> ?? <span>null</span><span>;</span><br/></p><p><span>// ...</span><br/></p><p><span>}</span></p></code></pre></div></div></div></div><!--/$-->
<p>Now there is no need to ‚Äúadjust‚Äù the state at all. If the item with the selected ID is in the list, it remains selected. If it‚Äôs not, the <code>selection</code> calculated during rendering will be <code>null</code> because no matching item was found. This behavior is different, but arguably better because most changes to <code>items</code> preserve the selection.</p>
<h3 id="sharing-logic-between-event-handlers">Sharing logic between event handlers <a href="#sharing-logic-between-event-handlers" aria-label="Link for Sharing logic between event handlers " title="Link for Sharing logic between event handlers "><svg width="1em" height="1em" viewBox="0 0 13 13" xmlns="http://www.w3.org/2000/svg"><g fill="currentColor" fill-rule="evenodd"><path d="M7.778 7.975a2.5 2.5 0 0 0 .347-3.837L6.017 2.03a2.498 2.498 0 0 0-3.542-.007 2.5 2.5 0 0 0 .006 3.543l1.153 1.15c.07-.29.154-.563.25-.773.036-.077.084-.16.14-.25L3.18 4.85a1.496 1.496 0 0 1 .002-2.12 1.496 1.496 0 0 1 2.12 0l2.124 2.123a1.496 1.496 0 0 1-.333 2.37c.16.246.42.504.685.752z"></path><path d="M5.657 4.557a2.5 2.5 0 0 0-.347 3.837l2.108 2.108a2.498 2.498 0 0 0 3.542.007 2.5 2.5 0 0 0-.006-3.543L9.802 5.815c-.07.29-.154.565-.25.774-.036.076-.084.16-.14.25l.842.84c.585.587.59 1.532 0 2.122-.587.585-1.532.59-2.12 0L6.008 7.68a1.496 1.496 0 0 1 .332-2.372c-.16-.245-.42-.503-.685-.75z"></path></g></svg></a></h3>
<p>Let‚Äôs say you have a product page with two buttons (Buy and Checkout) that both let you buy that product. You want to show a notification whenever the user puts the product in the cart. Calling <code>showNotification()</code> in both buttons‚Äô click handlers feels repetitive so you might be tempted to place this logic in an Effect:</p>
<!--$--><div><div><div><div><pre><code><p><span>function</span> <span>ProductPage</span><span>(</span><span>{</span> <span>product</span><span>,</span> <span>addToCart</span> <span>}</span><span>)</span> <span>{</span><br/></p><p><span>// üî¥ Avoid: Event-specific logic inside an Effect</span><br/></p><p><span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span><br/></p><p><span>if</span> <span>(</span><span>product</span>.<span>isInCart</span><span>)</span> <span>{</span><br/></p><p><span>showNotification</span><span>(</span><span>`Added ${</span><span>product</span>.<span>name</span><span>} to the shopping cart!`</span><span>)</span><span>;</span><br/></p><p><span>}</span><br/></p><p><span>}</span><span>,</span> <span>[</span><span>product</span><span>]</span><span>)</span><span>;</span><br/></p><p><span>function</span> <span>handleBuyClick</span><span>(</span><span>)</span> <span>{</span><br/></p><p><span>addToCart</span><span>(</span><span>product</span><span>)</span><span>;</span><br/></p><p><span>}</span><br/></p><p><span>function</span> <span>handleCheckoutClick</span><span>(</span><span>)</span> <span>{</span><br/></p><p><span>addToCart</span><span>(</span><span>product</span><span>)</span><span>;</span><br/></p><p><span>navigateTo</span><span>(</span><span>&#39;/checkout&#39;</span><span>)</span><span>;</span><br/></p><p><span>}</span><br/></p><p><span>// ...</span><br/></p><p><span>}</span></p></code></pre></div></div></div></div><!--/$-->
<p>This Effect is unnecessary. It will also most likely cause bugs. For example, let‚Äôs say that your app ‚Äúremembers‚Äù the shopping cart between the page reloads. If you add a product to the cart once and refresh the page, the notification will appear again. It will keep appearing every time you refresh that product‚Äôs page. This is because <code>product.isInCart</code> will already be <code>true</code> on the page load, so the Effect above will call <code>showNotification()</code>.</p>
<p><strong>When you‚Äôre not sure whether some code should be in an Effect or in an event handler, ask yourself <em>why</em> this code needs to run. Use Effects only for code that should run <em>because</em> the component was displayed to the user.</strong> In this example, the notification should appear because the user <em>pressed the button</em>, not because the page was displayed! Delete the Effect and put the shared logic into a function called from both event handlers:</p>
<!--$--><div><div><div><div><pre><code><p><span>function</span> <span>ProductPage</span><span>(</span><span>{</span> <span>product</span><span>,</span> <span>addToCart</span> <span>}</span><span>)</span> <span>{</span><br/></p><p><span>// ‚úÖ Good: Event-specific logic is called from event handlers</span><br/></p><p><span>function</span> <span>buyProduct</span><span>(</span><span>)</span> <span>{</span><br/></p><p><span>addToCart</span><span>(</span><span>product</span><span>)</span><span>;</span><br/></p><p><span>showNotification</span><span>(</span><span>`Added ${</span><span>product</span>.<span>name</span><span>} to the shopping cart!`</span><span>)</span><span>;</span><br/></p><p><span>}</span><br/></p><p><span>function</span> <span>handleBuyClick</span><span>(</span><span>)</span> <span>{</span><br/></p><p><span>buyProduct</span><span>(</span><span>)</span><span>;</span><br/></p><p><span>}</span><br/></p><p><span>function</span> <span>handleCheckoutClick</span><span>(</span><span>)</span> <span>{</span><br/></p><p><span>buyProduct</span><span>(</span><span>)</span><span>;</span><br/></p><p><span>navigateTo</span><span>(</span><span>&#39;/checkout&#39;</span><span>)</span><span>;</span><br/></p><p><span>}</span><br/></p><p><span>// ...</span><br/></p><p><span>}</span></p></code></pre></div></div></div></div><!--/$-->
<p>This both removes the unnecessary Effect and fixes the bug.</p>
<h3 id="sending-a-post-request">Sending a POST request <a href="#sending-a-post-request" aria-label="Link for Sending a POST request " title="Link for Sending a POST request "><svg width="1em" height="1em" viewBox="0 0 13 13" xmlns="http://www.w3.org/2000/svg"><g fill="currentColor" fill-rule="evenodd"><path d="M7.778 7.975a2.5 2.5 0 0 0 .347-3.837L6.017 2.03a2.498 2.498 0 0 0-3.542-.007 2.5 2.5 0 0 0 .006 3.543l1.153 1.15c.07-.29.154-.563.25-.773.036-.077.084-.16.14-.25L3.18 4.85a1.496 1.496 0 0 1 .002-2.12 1.496 1.496 0 0 1 2.12 0l2.124 2.123a1.496 1.496 0 0 1-.333 2.37c.16.246.42.504.685.752z"></path><path d="M5.657 4.557a2.5 2.5 0 0 0-.347 3.837l2.108 2.108a2.498 2.498 0 0 0 3.542.007 2.5 2.5 0 0 0-.006-3.543L9.802 5.815c-.07.29-.154.565-.25.774-.036.076-.084.16-.14.25l.842.84c.585.587.59 1.532 0 2.122-.587.585-1.532.59-2.12 0L6.008 7.68a1.496 1.496 0 0 1 .332-2.372c-.16-.245-.42-.503-.685-.75z"></path></g></svg></a></h3>
<p>This <code>Form</code> component sends two kinds of POST requests. It sends an analytics event when it mounts. When you fill in the form and click the Submit button, it will send a POST request to the <code>/api/register</code> endpoint:</p>
<!--$--><div><div><div><div><pre><code><p><span>function</span> <span>Form</span><span>(</span><span>)</span> <span>{</span><br/></p><p><span>const</span> <span>[</span><span>firstName</span><span>,</span> <span>setFirstName</span><span>]</span> = <span>useState</span><span>(</span><span>&#39;&#39;</span><span>)</span><span>;</span><br/></p><p><span>const</span> <span>[</span><span>lastName</span><span>,</span> <span>setLastName</span><span>]</span> = <span>useState</span><span>(</span><span>&#39;&#39;</span><span>)</span><span>;</span><br/></p><p><span>// ‚úÖ Good: This logic should run because the component was displayed</span><br/></p><p><span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span><br/></p><p><span>post</span><span>(</span><span>&#39;/analytics/event&#39;</span><span>,</span> <span>{</span> <span>eventName</span><span>:</span> <span>&#39;visit_form&#39;</span> <span>}</span><span>)</span><span>;</span><br/></p><p><span>}</span><span>,</span> <span>[</span><span>]</span><span>)</span><span>;</span><br/></p><p><span>// üî¥ Avoid: Event-specific logic inside an Effect</span><br/></p><p><span>const</span> <span>[</span><span>jsonToSubmit</span><span>,</span> <span>setJsonToSubmit</span><span>]</span> = <span>useState</span><span>(</span><span>null</span><span>)</span><span>;</span><br/></p><p><span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span><br/></p><p><span>if</span> <span>(</span><span>jsonToSubmit</span> !== <span>null</span><span>)</span> <span>{</span><br/></p><p><span>post</span><span>(</span><span>&#39;/api/register&#39;</span><span>,</span> <span>jsonToSubmit</span><span>)</span><span>;</span><br/></p><p><span>}</span><br/></p><p><span>}</span><span>,</span> <span>[</span><span>jsonToSubmit</span><span>]</span><span>)</span><span>;</span><br/></p><p><span>function</span> <span>handleSubmit</span><span>(</span><span>e</span><span>)</span> <span>{</span><br/></p><p><span>e</span>.<span>preventDefault</span><span>(</span><span>)</span><span>;</span><br/></p><p><span>setJsonToSubmit</span><span>(</span><span>{</span> <span>firstName</span><span>,</span> <span>lastName</span> <span>}</span><span>)</span><span>;</span><br/></p><p><span>}</span><br/></p><p><span>// ...</span><br/></p><p><span>}</span></p></code></pre></div></div></div></div><!--/$-->
<p>Let‚Äôs apply the same criteria as in the example before.</p>
<p>The analytics POST request should remain in an Effect. This is because the <em>reason</em> to send the analytics event is that the form was displayed. (It would fire twice in development, but <a href="https://slowernews.substack.com/learn/synchronizing-with-effects#sending-analytics">see here</a> for how to deal with that.)</p>
<p>However, the <code>/api/register</code> POST request is not caused by the form being <em>displayed</em>. You only want to send the request at one specific moment in time: when the user presses the button. It should only ever happen <em>on that particular interaction</em>. Delete the second Effect and move that POST request into the event handler:</p>
<!--$--><div><div><div><div><pre><code><p><span>function</span> <span>Form</span><span>(</span><span>)</span> <span>{</span><br/></p><p><span>const</span> <span>[</span><span>firstName</span><span>,</span> <span>setFirstName</span><span>]</span> = <span>useState</span><span>(</span><span>&#39;&#39;</span><span>)</span><span>;</span><br/></p><p><span>const</span> <span>[</span><span>lastName</span><span>,</span> <span>setLastName</span><span>]</span> = <span>useState</span><span>(</span><span>&#39;&#39;</span><span>)</span><span>;</span><br/></p><p><span>// ‚úÖ Good: This logic runs because the component was displayed</span><br/></p><p><span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span><br/></p><p><span>post</span><span>(</span><span>&#39;/analytics/event&#39;</span><span>,</span> <span>{</span> <span>eventName</span><span>:</span> <span>&#39;visit_form&#39;</span> <span>}</span><span>)</span><span>;</span><br/></p><p><span>}</span><span>,</span> <span>[</span><span>]</span><span>)</span><span>;</span><br/></p><p><span>function</span> <span>handleSubmit</span><span>(</span><span>e</span><span>)</span> <span>{</span><br/></p><p><span>e</span>.<span>preventDefault</span><span>(</span><span>)</span><span>;</span><br/></p><p><span>// ‚úÖ Good: Event-specific logic is in the event handler</span><br/></p><p><span>post</span><span>(</span><span>&#39;/api/register&#39;</span><span>,</span> <span>{</span> <span>firstName</span><span>,</span> <span>lastName</span> <span>}</span><span>)</span><span>;</span><br/></p><p><span>}</span><br/></p><p><span>// ...</span><br/></p><p><span>}</span></p></code></pre></div></div></div></div><!--/$-->
<p>When you choose whether to put some logic into an event handler or an Effect, the main question you need to answer is <em>what kind of logic</em> it is from the user‚Äôs perspective. If this logic is caused by a particular interaction, keep it in the event handler. If it‚Äôs caused by the user <em>seeing</em> the component on the screen, keep it in the Effect.</p>
<h3 id="chains-of-computations">Chains of computations <a href="#chains-of-computations" aria-label="Link for Chains of computations " title="Link for Chains of computations "><svg width="1em" height="1em" viewBox="0 0 13 13" xmlns="http://www.w3.org/2000/svg"><g fill="currentColor" fill-rule="evenodd"><path d="M7.778 7.975a2.5 2.5 0 0 0 .347-3.837L6.017 2.03a2.498 2.498 0 0 0-3.542-.007 2.5 2.5 0 0 0 .006 3.543l1.153 1.15c.07-.29.154-.563.25-.773.036-.077.084-.16.14-.25L3.18 4.85a1.496 1.496 0 0 1 .002-2.12 1.496 1.496 0 0 1 2.12 0l2.124 2.123a1.496 1.496 0 0 1-.333 2.37c.16.246.42.504.685.752z"></path><path d="M5.657 4.557a2.5 2.5 0 0 0-.347 3.837l2.108 2.108a2.498 2.498 0 0 0 3.542.007 2.5 2.5 0 0 0-.006-3.543L9.802 5.815c-.07.29-.154.565-.25.774-.036.076-.084.16-.14.25l.842.84c.585.587.59 1.532 0 2.122-.587.585-1.532.59-2.12 0L6.008 7.68a1.496 1.496 0 0 1 .332-2.372c-.16-.245-.42-.503-.685-.75z"></path></g></svg></a></h3>
<p>Sometimes you might feel tempted to chain Effects that each adjust a piece of state based on other state:</p>
<!--$--><div><div><div><div><pre><code><p><span>function</span> <span>Game</span><span>(</span><span>)</span> <span>{</span><br/></p><p><span>const</span> <span>[</span><span>card</span><span>,</span> <span>setCard</span><span>]</span> = <span>useState</span><span>(</span><span>null</span><span>)</span><span>;</span><br/></p><p><span>const</span> <span>[</span><span>goldCardCount</span><span>,</span> <span>setGoldCardCount</span><span>]</span> = <span>useState</span><span>(</span><span>0</span><span>)</span><span>;</span><br/></p><p><span>const</span> <span>[</span><span>round</span><span>,</span> <span>setRound</span><span>]</span> = <span>useState</span><span>(</span><span>1</span><span>)</span><span>;</span><br/></p><p><span>const</span> <span>[</span><span>isGameOver</span><span>,</span> <span>setIsGameOver</span><span>]</span> = <span>useState</span><span>(</span><span>false</span><span>)</span><span>;</span><br/></p><p><span>// üî¥ Avoid: Chains of Effects that adjust the state solely to trigger each other</span><br/></p><p><span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span><br/></p><p><span>if</span> <span>(</span><span>card</span> !== <span>null</span> &amp;&amp; <span>card</span>.<span>gold</span><span>)</span> <span>{</span><br/></p><p><span>setGoldCardCount</span><span>(</span><span>c</span> <span>=&gt;</span> <span>c</span> + <span>1</span><span>)</span><span>;</span><br/></p><p><span>}</span><br/></p><p><span>}</span><span>,</span> <span>[</span><span>card</span><span>]</span><span>)</span><span>;</span><br/></p><p><span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span><br/></p><p><span>if</span> <span>(</span><span>goldCardCount</span> &gt; <span>3</span><span>)</span> <span>{</span><br/></p><p><span>setRound</span><span>(</span><span>r</span> <span>=&gt;</span> <span>r</span> + <span>1</span><span>)</span><br/></p><p><span>setGoldCardCount</span><span>(</span><span>0</span><span>)</span><span>;</span><br/></p><p><span>}</span><br/></p><p><span>}</span><span>,</span> <span>[</span><span>goldCardCount</span><span>]</span><span>)</span><span>;</span><br/></p><p><span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span><br/></p><p><span>if</span> <span>(</span><span>round</span> &gt; <span>5</span><span>)</span> <span>{</span><br/></p><p><span>setIsGameOver</span><span>(</span><span>true</span><span>)</span><span>;</span><br/></p><p><span>}</span><br/></p><p><span>}</span><span>,</span> <span>[</span><span>round</span><span>]</span><span>)</span><span>;</span><br/></p><p><span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span><br/></p><p><span>alert</span><span>(</span><span>&#39;Good game!&#39;</span><span>)</span><span>;</span><br/></p><p><span>}</span><span>,</span> <span>[</span><span>isGameOver</span><span>]</span><span>)</span><span>;</span><br/></p><p><span>function</span> <span>handlePlaceCard</span><span>(</span><span>nextCard</span><span>)</span> <span>{</span><br/></p><p><span>if</span> <span>(</span><span>isGameOver</span><span>)</span> <span>{</span><br/></p><p><span>throw</span> <span>Error</span><span>(</span><span>&#39;Game already ended.&#39;</span><span>)</span><span>;</span><br/></p><p><span>}</span> <span>else</span> <span>{</span><br/></p><p><span>setCard</span><span>(</span><span>nextCard</span><span>)</span><span>;</span><br/></p><p><span>}</span><br/></p><p><span>}</span><br/></p><p><span>// ...</span></p></code></pre></div></div></div></div><!--/$-->
<p>There are two problems with this code.</p>
<p>One problem is that it is very inefficient: the component (and its children) have to re-render between each <code>set</code> call in the chain. In the example above, in the worst case (<code>setCard</code> ‚Üí render ‚Üí <code>setGoldCardCount</code> ‚Üí render ‚Üí <code>setRound</code> ‚Üí render ‚Üí <code>setIsGameOver</code> ‚Üí render) there are three unnecessary re-renders of the tree below.</p>
<p>Even if it weren‚Äôt slow, as your code evolves, you will run into cases where the ‚Äúchain‚Äù you wrote doesn‚Äôt fit the new requirements. Imagine you are adding a way to step through the history of the game moves. You‚Äôd do it by updating each state variable to a value from the past. However, setting the <code>card</code> state to a value from the past would trigger the Effect chain again and change the data you‚Äôre showing. Such code is often rigid and fragile.</p>
<p>In this case, it‚Äôs better to calculate what you can during rendering, and adjust the state in the event handler:</p>
<!--$--><div><div><div><div><pre><code><p><span>function</span> <span>Game</span><span>(</span><span>)</span> <span>{</span><br/></p><p><span>const</span> <span>[</span><span>card</span><span>,</span> <span>setCard</span><span>]</span> = <span>useState</span><span>(</span><span>null</span><span>)</span><span>;</span><br/></p><p><span>const</span> <span>[</span><span>goldCardCount</span><span>,</span> <span>setGoldCardCount</span><span>]</span> = <span>useState</span><span>(</span><span>0</span><span>)</span><span>;</span><br/></p><p><span>const</span> <span>[</span><span>round</span><span>,</span> <span>setRound</span><span>]</span> = <span>useState</span><span>(</span><span>1</span><span>)</span><span>;</span><br/></p><p><span>// ‚úÖ Calculate what you can during rendering</span><br/></p><p><span>const</span> <span>isGameOver</span> = <span>round</span> &gt; <span>5</span><span>;</span><br/></p><p><span>function</span> <span>handlePlaceCard</span><span>(</span><span>nextCard</span><span>)</span> <span>{</span><br/></p><p><span>if</span> <span>(</span><span>isGameOver</span><span>)</span> <span>{</span><br/></p><p><span>throw</span> <span>Error</span><span>(</span><span>&#39;Game already ended.&#39;</span><span>)</span><span>;</span><br/></p><p><span>}</span><br/></p><p><span>// ‚úÖ Calculate all the next state in the event handler</span><br/></p><p><span>setCard</span><span>(</span><span>nextCard</span><span>)</span><span>;</span><br/></p><p><span>if</span> <span>(</span><span>nextCard</span>.<span>gold</span><span>)</span> <span>{</span><br/></p><p><span>if</span> <span>(</span><span>goldCardCount</span> &lt;= <span>3</span><span>)</span> <span>{</span><br/></p><p><span>setGoldCardCount</span><span>(</span><span>goldCardCount</span> + <span>1</span><span>)</span><span>;</span><br/></p><p><span>}</span> <span>else</span> <span>{</span><br/></p><p><span>setGoldCardCount</span><span>(</span><span>0</span><span>)</span><span>;</span><br/></p><p><span>setRound</span><span>(</span><span>round</span> + <span>1</span><span>)</span><span>;</span><br/></p><p><span>if</span> <span>(</span><span>round</span> === <span>5</span><span>)</span> <span>{</span><br/></p><p><span>alert</span><span>(</span><span>&#39;Good game!&#39;</span><span>)</span><span>;</span><br/></p><p><span>}</span><br/></p><p><span>}</span><br/></p><p><span>}</span><br/></p><p><span>}</span><br/></p><p><span>// ...</span></p></code></pre></div></div></div></div><!--/$-->
<p>This is a lot more efficient. Also, if you implement a way to view game history, now you will be able to set each state variable to a move from the past without triggering the Effect chain that adjusts every other value. If you need to reuse logic between several event handlers, you can <a href="#sharing-logic-between-event-handlers">extract a function</a> and call it from those handlers.</p>
<p>Remember that inside event handlers, <a href="https://slowernews.substack.com/learn/state-as-a-snapshot">state behaves like a snapshot.</a> For example, even after you call <code>setRound(round + 1)</code>, the <code>round</code> variable will reflect the value at the time the user clicked the button. If you need to use the next value for calculations, define it manually like <code>const nextRound = round + 1</code>.</p>
<p>In some cases, you <em>can‚Äôt</em> calculate the next state directly in the event handler. For example, imagine a form with multiple dropdowns where the options of the next dropdown depend on the selected value of the previous dropdown. Then, a chain of Effects is appropriate because you are synchronizing with network.</p>
<h3 id="initializing-the-application">Initializing the application <a href="#initializing-the-application" aria-label="Link for Initializing the application " title="Link for Initializing the application "><svg width="1em" height="1em" viewBox="0 0 13 13" xmlns="http://www.w3.org/2000/svg"><g fill="currentColor" fill-rule="evenodd"><path d="M7.778 7.975a2.5 2.5 0 0 0 .347-3.837L6.017 2.03a2.498 2.498 0 0 0-3.542-.007 2.5 2.5 0 0 0 .006 3.543l1.153 1.15c.07-.29.154-.563.25-.773.036-.077.084-.16.14-.25L3.18 4.85a1.496 1.496 0 0 1 .002-2.12 1.496 1.496 0 0 1 2.12 0l2.124 2.123a1.496 1.496 0 0 1-.333 2.37c.16.246.42.504.685.752z"></path><path d="M5.657 4.557a2.5 2.5 0 0 0-.347 3.837l2.108 2.108a2.498 2.498 0 0 0 3.542.007 2.5 2.5 0 0 0-.006-3.543L9.802 5.815c-.07.29-.154.565-.25.774-.036.076-.084.16-.14.25l.842.84c.585.587.59 1.532 0 2.122-.587.585-1.532.59-2.12 0L6.008 7.68a1.496 1.496 0 0 1 .332-2.372c-.16-.245-.42-.503-.685-.75z"></path></g></svg></a></h3>
<p>Some logic should only run once when the app loads.</p>
<p>You might be tempted to place it in an Effect in the top-level component:</p>
<!--$--><div><div><div><div><pre><code><p><span>function</span> <span>App</span><span>(</span><span>)</span> <span>{</span><br/></p><p><span>// üî¥ Avoid: Effects with logic that should only ever run once</span><br/></p><p><span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span><br/></p><p><span>loadDataFromLocalStorage</span><span>(</span><span>)</span><span>;</span><br/></p><p><span>checkAuthToken</span><span>(</span><span>)</span><span>;</span><br/></p><p><span>}</span><span>,</span> <span>[</span><span>]</span><span>)</span><span>;</span><br/></p><p><span>// ...</span><br/></p><p><span>}</span></p></code></pre></div></div></div></div><!--/$-->
<p>However, you‚Äôll quickly discover that it <a href="https://slowernews.substack.com/learn/synchronizing-with-effects#how-to-handle-the-effect-firing-twice-in-development">runs twice in development.</a> This can cause issues‚Äîfor example, maybe it invalidates the authentication token because the function wasn‚Äôt designed to be called twice. In general, your components should be resilient to being remounted. This includes your top-level <code>App</code> component.</p>
<p>Although it may not ever get remounted in practice in production, following the same constraints in all components makes it easier to move and reuse code. If some logic must run <em>once per app load</em> rather than <em>once per component mount</em>, add a top-level variable to track whether it has already executed:</p>
<!--$--><div><div><div><div><pre><code><p><span>let</span> <span>didInit</span> = <span>false</span><span>;</span><br/></p><p><span>function</span> <span>App</span><span>(</span><span>)</span> <span>{</span><br/></p><p><span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span><br/></p><p><span>if</span> <span>(</span>!<span>didInit</span><span>)</span> <span>{</span><br/></p><p><span>didInit</span> = <span>true</span><span>;</span><br/></p><p><span>// ‚úÖ Only runs once per app load</span><br/></p><p><span>loadDataFromLocalStorage</span><span>(</span><span>)</span><span>;</span><br/></p><p><span>checkAuthToken</span><span>(</span><span>)</span><span>;</span><br/></p><p><span>}</span><br/></p><p><span>}</span><span>,</span> <span>[</span><span>]</span><span>)</span><span>;</span><br/></p><p><span>// ...</span><br/></p><p><span>}</span></p></code></pre></div></div></div></div><!--/$-->
<p>You can also run it during module initialization and before the app renders:</p>
<!--$--><div><div><div><div><pre><code><p><span>if</span> <span>(</span><span>typeof</span> <span>window</span> !== <span>&#39;undefined&#39;</span><span>)</span> <span>{</span> <span>// Check if we&#39;re running in the browser.</span><br/></p><p><span>// ‚úÖ Only runs once per app load</span><br/></p><p><span>checkAuthToken</span><span>(</span><span>)</span><span>;</span><br/></p><p><span>loadDataFromLocalStorage</span><span>(</span><span>)</span><span>;</span><br/></p><p><span>}</span><br/></p><p><span>function</span> <span>App</span><span>(</span><span>)</span> <span>{</span><br/></p><p><span>// ...</span><br/></p><p><span>}</span></p></code></pre></div></div></div></div><!--/$-->
<p>Code at the top level runs once when your component is imported‚Äîeven if it doesn‚Äôt end up being rendered. To avoid slowdown or surprising behavior when importing arbitrary components, don‚Äôt overuse this pattern. Keep app-wide initialization logic to root component modules like <code>App.js</code> or in your application‚Äôs entry point.</p>
<h3 id="notifying-parent-components-about-state-changes">Notifying parent components about state changes <a href="#notifying-parent-components-about-state-changes" aria-label="Link for Notifying parent components about state changes " title="Link for Notifying parent components about state changes "><svg width="1em" height="1em" viewBox="0 0 13 13" xmlns="http://www.w3.org/2000/svg"><g fill="currentColor" fill-rule="evenodd"><path d="M7.778 7.975a2.5 2.5 0 0 0 .347-3.837L6.017 2.03a2.498 2.498 0 0 0-3.542-.007 2.5 2.5 0 0 0 .006 3.543l1.153 1.15c.07-.29.154-.563.25-.773.036-.077.084-.16.14-.25L3.18 4.85a1.496 1.496 0 0 1 .002-2.12 1.496 1.496 0 0 1 2.12 0l2.124 2.123a1.496 1.496 0 0 1-.333 2.37c.16.246.42.504.685.752z"></path><path d="M5.657 4.557a2.5 2.5 0 0 0-.347 3.837l2.108 2.108a2.498 2.498 0 0 0 3.542.007 2.5 2.5 0 0 0-.006-3.543L9.802 5.815c-.07.29-.154.565-.25.774-.036.076-.084.16-.14.25l.842.84c.585.587.59 1.532 0 2.122-.587.585-1.532.59-2.12 0L6.008 7.68a1.496 1.496 0 0 1 .332-2.372c-.16-.245-.42-.503-.685-.75z"></path></g></svg></a></h3>
<p>Let‚Äôs say you‚Äôre writing a <code>Toggle</code> component with an internal <code>isOn</code> state which can be either <code>true</code> or <code>false</code>. There are a few different ways to toggle it (by clicking or dragging). You want to notify the parent component whenever the <code>Toggle</code> internal state changes, so you expose an <code>onChange</code> event and call it from an Effect:</p>
<!--$--><div><div><div><div><pre><code><p><span>function</span> <span>Toggle</span><span>(</span><span>{</span> <span>onChange</span> <span>}</span><span>)</span> <span>{</span><br/></p><p><span>const</span> <span>[</span><span>isOn</span><span>,</span> <span>setIsOn</span><span>]</span> = <span>useState</span><span>(</span><span>false</span><span>)</span><span>;</span><br/></p><p><span>// üî¥ Avoid: The onChange handler runs too late</span><br/></p><p><span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span><br/></p><p><span>onChange</span><span>(</span><span>isOn</span><span>)</span><span>;</span><br/></p><p><span>}</span><span>,</span> <span>[</span><span>isOn</span><span>,</span> <span>onChange</span><span>]</span><span>)</span><br/></p><p><span>function</span> <span>handleClick</span><span>(</span><span>)</span> <span>{</span><br/></p><p><span>setIsOn</span><span>(</span>!<span>isOn</span><span>)</span><span>;</span><br/></p><p><span>}</span><br/></p><p><span>function</span> <span>handleDragEnd</span><span>(</span><span>e</span><span>)</span> <span>{</span><br/></p><p><span>if</span> <span>(</span><span>isCloserToRightEdge</span><span>(</span><span>e</span><span>)</span><span>)</span> <span>{</span><br/></p><p><span>setIsOn</span><span>(</span><span>true</span><span>)</span><span>;</span><br/></p><p><span>}</span> <span>else</span> <span>{</span><br/></p><p><span>setIsOn</span><span>(</span><span>false</span><span>)</span><span>;</span><br/></p><p><span>}</span><br/></p><p><span>}</span><br/></p><p><span>// ...</span><br/></p><p><span>}</span></p></code></pre></div></div></div></div><!--/$-->
<p>Like earlier, this is not ideal. The <code>Toggle</code> updates its state first, and React updates the screen. Then React runs the Effect, which calls the <code>onChange</code> function passed from a parent component. Now the parent component will update its own state, starting another render pass. It would be better to do everything in a single pass.</p>
<p>Delete the Effect and instead update the state of <em>both</em> components within the same event handler:</p>
<!--$--><div><div><div><div><pre><code><p><span>function</span> <span>Toggle</span><span>(</span><span>{</span> <span>onChange</span> <span>}</span><span>)</span> <span>{</span><br/></p><p><span>const</span> <span>[</span><span>isOn</span><span>,</span> <span>setIsOn</span><span>]</span> = <span>useState</span><span>(</span><span>false</span><span>)</span><span>;</span><br/></p><p><span>function</span> <span>updateToggle</span><span>(</span><span>nextIsOn</span><span>)</span> <span>{</span><br/></p><p><span>// ‚úÖ Good: Perform all updates during the event that caused them</span><br/></p><p><span>setIsOn</span><span>(</span><span>nextIsOn</span><span>)</span><span>;</span><br/></p><p><span>onChange</span><span>(</span><span>nextIsOn</span><span>)</span><span>;</span><br/></p><p><span>}</span><br/></p><p><span>function</span> <span>handleClick</span><span>(</span><span>)</span> <span>{</span><br/></p><p><span>updateToggle</span><span>(</span>!<span>isOn</span><span>)</span><span>;</span><br/></p><p><span>}</span><br/></p><p><span>function</span> <span>handleDragEnd</span><span>(</span><span>e</span><span>)</span> <span>{</span><br/></p><p><span>if</span> <span>(</span><span>isCloserToRightEdge</span><span>(</span><span>e</span><span>)</span><span>)</span> <span>{</span><br/></p><p><span>updateToggle</span><span>(</span><span>true</span><span>)</span><span>;</span><br/></p><p><span>}</span> <span>else</span> <span>{</span><br/></p><p><span>updateToggle</span><span>(</span><span>false</span><span>)</span><span>;</span><br/></p><p><span>}</span><br/></p><p><span>}</span><br/></p><p><span>// ...</span><br/></p><p><span>}</span></p></code></pre></div></div></div></div><!--/$-->
<p>With this approach, both the <code>Toggle</code> component and its parent component update their state during the event. React <a href="https://slowernews.substack.com/learn/queueing-a-series-of-state-updates">batches updates</a> from different components together, so there will only be one render pass.</p>
<p>You might also be able to remove the state altogether, and instead receive <code>isOn</code> from the parent component:</p>
<!--$--><div><div><div><div><pre><code><p><span>// ‚úÖ Also good: the component is fully controlled by its parent</span><br/></p><p><span>function</span> <span>Toggle</span><span>(</span><span>{</span> <span>isOn</span><span>,</span> <span>onChange</span> <span>}</span><span>)</span> <span>{</span><br/></p><p><span>function</span> <span>handleClick</span><span>(</span><span>)</span> <span>{</span><br/></p><p><span>onChange</span><span>(</span>!<span>isOn</span><span>)</span><span>;</span><br/></p><p><span>}</span><br/></p><p><span>function</span> <span>handleDragEnd</span><span>(</span><span>e</span><span>)</span> <span>{</span><br/></p><p><span>if</span> <span>(</span><span>isCloserToRightEdge</span><span>(</span><span>e</span><span>)</span><span>)</span> <span>{</span><br/></p><p><span>onChange</span><span>(</span><span>true</span><span>)</span><span>;</span><br/></p><p><span>}</span> <span>else</span> <span>{</span><br/></p><p><span>onChange</span><span>(</span><span>false</span><span>)</span><span>;</span><br/></p><p><span>}</span><br/></p><p><span>}</span><br/></p><p><span>// ...</span><br/></p><p><span>}</span></p></code></pre></div></div></div></div><!--/$-->
<p><a href="https://slowernews.substack.com/learn/sharing-state-between-components">‚ÄúLifting state up‚Äù</a> lets the parent component fully control the <code>Toggle</code> by toggling the parent‚Äôs own state. This means the parent component will have to contain more logic, but there will be less state overall to worry about. Whenever you try to keep two different state variables synchronized, try lifting state up instead!</p>
<h3 id="passing-data-to-the-parent">Passing data to the parent <a href="#passing-data-to-the-parent" aria-label="Link for Passing data to the parent " title="Link for Passing data to the parent "><svg width="1em" height="1em" viewBox="0 0 13 13" xmlns="http://www.w3.org/2000/svg"><g fill="currentColor" fill-rule="evenodd"><path d="M7.778 7.975a2.5 2.5 0 0 0 .347-3.837L6.017 2.03a2.498 2.498 0 0 0-3.542-.007 2.5 2.5 0 0 0 .006 3.543l1.153 1.15c.07-.29.154-.563.25-.773.036-.077.084-.16.14-.25L3.18 4.85a1.496 1.496 0 0 1 .002-2.12 1.496 1.496 0 0 1 2.12 0l2.124 2.123a1.496 1.496 0 0 1-.333 2.37c.16.246.42.504.685.752z"></path><path d="M5.657 4.557a2.5 2.5 0 0 0-.347 3.837l2.108 2.108a2.498 2.498 0 0 0 3.542.007 2.5 2.5 0 0 0-.006-3.543L9.802 5.815c-.07.29-.154.565-.25.774-.036.076-.084.16-.14.25l.842.84c.585.587.59 1.532 0 2.122-.587.585-1.532.59-2.12 0L6.008 7.68a1.496 1.496 0 0 1 .332-2.372c-.16-.245-.42-.503-.685-.75z"></path></g></svg></a></h3>
<p>This <code>Child</code> component fetches some data and then passes it to the <code>Parent</code> component in an Effect:</p>
<!--$--><div><div><div><div><pre><code><p><span>function</span> <span>Parent</span><span>(</span><span>)</span> <span>{</span><br/></p><p><span>const</span> <span>[</span><span>data</span><span>,</span> <span>setData</span><span>]</span> = <span>useState</span><span>(</span><span>null</span><span>)</span><span>;</span><br/></p><p><span>// ...</span><br/></p><p><span>return</span> <span>&lt;</span><span>Child</span> <span>onFetched</span>=<span>{</span><span>setData</span><span>}</span> <span>/&gt;</span><span>;</span><br/></p><p><span>}</span><br/></p><p><span>function</span> <span>Child</span><span>(</span><span>{</span> <span>onFetched</span> <span>}</span><span>)</span> <span>{</span><br/></p><p><span>const</span> <span>data</span> = <span>useSomeAPI</span><span>(</span><span>)</span><span>;</span><br/></p><p><span>// üî¥ Avoid: Passing data to the parent in an Effect</span><br/></p><p><span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span><br/></p><p><span>if</span> <span>(</span><span>data</span><span>)</span> <span>{</span><br/></p><p><span>onFetched</span><span>(</span><span>data</span><span>)</span><span>;</span><br/></p><p><span>}</span><br/></p><p><span>}</span><span>,</span> <span>[</span><span>onFetched</span><span>,</span> <span>data</span><span>]</span><span>)</span><span>;</span><br/></p><p><span>// ...</span><br/></p><p><span>}</span></p></code></pre></div></div></div></div><!--/$-->
<p>In React, data flows from the parent components to their children. When you see something wrong on the screen, you can trace where the information comes from by going up the component chain until you find which component passes the wrong prop or has the wrong state. When child components update the state of their parent components in Effects, the data flow becomes very difficult to trace. Since both the child and the parent need the same data, let the parent component fetch that data, and <em>pass it down</em> to the child instead:</p>
<!--$--><div><div><div><div><pre><code><p><span>function</span> <span>Parent</span><span>(</span><span>)</span> <span>{</span><br/></p><p><span>const</span> <span>data</span> = <span>useSomeAPI</span><span>(</span><span>)</span><span>;</span><br/></p><p><span>// ...</span><br/></p><p><span>// ‚úÖ Good: Passing data down to the child</span><br/></p><p><span>return</span> <span>&lt;</span><span>Child</span> <span>data</span>=<span>{</span><span>data</span><span>}</span> <span>/&gt;</span><span>;</span><br/></p><p><span>}</span><br/></p><p><span>function</span> <span>Child</span><span>(</span><span>{</span> <span>data</span> <span>}</span><span>)</span> <span>{</span><br/></p><p><span>// ...</span><br/></p><p><span>}</span></p></code></pre></div></div></div></div><!--/$-->
<p>This is simpler and keeps the data flow predictable: the data flows down from the parent to the child.</p>
<h3 id="subscribing-to-an-external-store">Subscribing to an external store <a href="#subscribing-to-an-external-store" aria-label="Link for Subscribing to an external store " title="Link for Subscribing to an external store "><svg width="1em" height="1em" viewBox="0 0 13 13" xmlns="http://www.w3.org/2000/svg"><g fill="currentColor" fill-rule="evenodd"><path d="M7.778 7.975a2.5 2.5 0 0 0 .347-3.837L6.017 2.03a2.498 2.498 0 0 0-3.542-.007 2.5 2.5 0 0 0 .006 3.543l1.153 1.15c.07-.29.154-.563.25-.773.036-.077.084-.16.14-.25L3.18 4.85a1.496 1.496 0 0 1 .002-2.12 1.496 1.496 0 0 1 2.12 0l2.124 2.123a1.496 1.496 0 0 1-.333 2.37c.16.246.42.504.685.752z"></path><path d="M5.657 4.557a2.5 2.5 0 0 0-.347 3.837l2.108 2.108a2.498 2.498 0 0 0 3.542.007 2.5 2.5 0 0 0-.006-3.543L9.802 5.815c-.07.29-.154.565-.25.774-.036.076-.084.16-.14.25l.842.84c.585.587.59 1.532 0 2.122-.587.585-1.532.59-2.12 0L6.008 7.68a1.496 1.496 0 0 1 .332-2.372c-.16-.245-.42-.503-.685-.75z"></path></g></svg></a></h3>
<p>Sometimes, your components may need to subscribe to some data outside of the React state. This data could be from a third-party library or a built-in browser API. Since this data can change without React‚Äôs knowledge, you need to manually subscribe your components to it. This is often done with an Effect, for example:</p>
<!--$--><div><div><div><div><pre><code><p><span>function</span> <span>useOnlineStatus</span><span>(</span><span>)</span> <span>{</span><br/></p><p><span>// Not ideal: Manual store subscription in an Effect</span><br/></p><p><span>const</span> <span>[</span><span>isOnline</span><span>,</span> <span>setIsOnline</span><span>]</span> = <span>useState</span><span>(</span><span>true</span><span>)</span><span>;</span><br/></p><p><span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span><br/></p><p><span>function</span> <span>updateState</span><span>(</span><span>)</span> <span>{</span><br/></p><p><span>setIsOnline</span><span>(</span><span>navigator</span>.<span>onLine</span><span>)</span><span>;</span><br/></p><p><span>}</span><br/></p><p><span>updateState</span><span>(</span><span>)</span><span>;</span><br/></p><p><span>window</span>.<span>addEventListener</span><span>(</span><span>&#39;online&#39;</span><span>,</span> <span>updateState</span><span>)</span><span>;</span><br/></p><p><span>window</span>.<span>addEventListener</span><span>(</span><span>&#39;offline&#39;</span><span>,</span> <span>updateState</span><span>)</span><span>;</span><br/></p><p><span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span><br/></p><p><span>window</span>.<span>removeEventListener</span><span>(</span><span>&#39;online&#39;</span><span>,</span> <span>updateState</span><span>)</span><span>;</span><br/></p><p><span>window</span>.<span>removeEventListener</span><span>(</span><span>&#39;offline&#39;</span><span>,</span> <span>updateState</span><span>)</span><span>;</span><br/></p><p><span>}</span><span>;</span><br/></p><p><span>}</span><span>,</span> <span>[</span><span>]</span><span>)</span><span>;</span><br/></p><p><span>return</span> <span>isOnline</span><span>;</span><br/></p><p><span>}</span><br/></p><p><span>function</span> <span>ChatIndicator</span><span>(</span><span>)</span> <span>{</span><br/></p><p><span>const</span> <span>isOnline</span> = <span>useOnlineStatus</span><span>(</span><span>)</span><span>;</span><br/></p><p><span>// ...</span><br/></p><p><span>}</span></p></code></pre></div></div></div></div><!--/$-->
<p>Here, the component subscribes to an external data store (in this case, the browser <code>navigator.onLine</code> API). Since this API does not exist on the server (so it can‚Äôt be used for the initial HTML), initially the state is set to <code>true</code>. Whenever the value of that data store changes in the browser, the component updates its state.</p>
<p>Although it‚Äôs common to use Effects for this, React has a purpose-built Hook for subscribing to an external store that is preferred instead. Delete the Effect and replace it with a call to <a href="https://slowernews.substack.com/reference/react/useSyncExternalStore"><code>useSyncExternalStore</code></a>:</p>
<!--$--><div><div><div><div><pre><code><p><span>function</span> <span>subscribe</span><span>(</span><span>callback</span><span>)</span> <span>{</span><br/></p><p><span>window</span>.<span>addEventListener</span><span>(</span><span>&#39;online&#39;</span><span>,</span> <span>callback</span><span>)</span><span>;</span><br/></p><p><span>window</span>.<span>addEventListener</span><span>(</span><span>&#39;offline&#39;</span><span>,</span> <span>callback</span><span>)</span><span>;</span><br/></p><p><span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span><br/></p><p><span>window</span>.<span>removeEventListener</span><span>(</span><span>&#39;online&#39;</span><span>,</span> <span>callback</span><span>)</span><span>;</span><br/></p><p><span>window</span>.<span>removeEventListener</span><span>(</span><span>&#39;offline&#39;</span><span>,</span> <span>callback</span><span>)</span><span>;</span><br/></p><p><span>}</span><span>;</span><br/></p><p><span>}</span><br/></p><p><span>function</span> <span>useOnlineStatus</span><span>(</span><span>)</span> <span>{</span><br/></p><p><span>// ‚úÖ Good: Subscribing to an external store with a built-in Hook</span><br/></p><p><span>return</span> <span>useSyncExternalStore</span><span>(</span><br/></p><p><span>subscribe</span><span>,</span> <span>// React won&#39;t resubscribe for as long as you pass the same function</span><br/></p><p><span>(</span><span>)</span> <span>=&gt;</span> <span>navigator</span>.<span>onLine</span><span>,</span> <span>// How to get the value on the client</span><br/></p><p><span>(</span><span>)</span> <span>=&gt;</span> <span>true</span> <span>// How to get the value on the server</span><br/></p><p><span>)</span><span>;</span><br/></p><p><span>}</span><br/></p><p><span>function</span> <span>ChatIndicator</span><span>(</span><span>)</span> <span>{</span><br/></p><p><span>const</span> <span>isOnline</span> = <span>useOnlineStatus</span><span>(</span><span>)</span><span>;</span><br/></p><p><span>// ...</span><br/></p><p><span>}</span></p></code></pre></div></div></div></div><!--/$-->
<p>This approach is less error-prone than manually syncing mutable data to React state with an Effect. Typically, you‚Äôll write a custom Hook like <code>useOnlineStatus()</code> above so that you don‚Äôt need to repeat this code in the individual components. <a href="https://slowernews.substack.com/reference/react/useSyncExternalStore">Read more about subscribing to external stores from React components.</a></p>
<h3 id="fetching-data">Fetching data <a href="#fetching-data" aria-label="Link for Fetching data " title="Link for Fetching data "><svg width="1em" height="1em" viewBox="0 0 13 13" xmlns="http://www.w3.org/2000/svg"><g fill="currentColor" fill-rule="evenodd"><path d="M7.778 7.975a2.5 2.5 0 0 0 .347-3.837L6.017 2.03a2.498 2.498 0 0 0-3.542-.007 2.5 2.5 0 0 0 .006 3.543l1.153 1.15c.07-.29.154-.563.25-.773.036-.077.084-.16.14-.25L3.18 4.85a1.496 1.496 0 0 1 .002-2.12 1.496 1.496 0 0 1 2.12 0l2.124 2.123a1.496 1.496 0 0 1-.333 2.37c.16.246.42.504.685.752z"></path><path d="M5.657 4.557a2.5 2.5 0 0 0-.347 3.837l2.108 2.108a2.498 2.498 0 0 0 3.542.007 2.5 2.5 0 0 0-.006-3.543L9.802 5.815c-.07.29-.154.565-.25.774-.036.076-.084.16-.14.25l.842.84c.585.587.59 1.532 0 2.122-.587.585-1.532.59-2.12 0L6.008 7.68a1.496 1.496 0 0 1 .332-2.372c-.16-.245-.42-.503-.685-.75z"></path></g></svg></a></h3>
<p>Many apps use Effects to kick off data fetching. It is quite common to write a data fetching Effect like this:</p>
<!--$--><div><div><div><div><pre><code><p><span>function</span> <span>SearchResults</span><span>(</span><span>{</span> <span>query</span> <span>}</span><span>)</span> <span>{</span><br/></p><p><span>const</span> <span>[</span><span>results</span><span>,</span> <span>setResults</span><span>]</span> = <span>useState</span><span>(</span><span>[</span><span>]</span><span>)</span><span>;</span><br/></p><p><span>const</span> <span>[</span><span>page</span><span>,</span> <span>setPage</span><span>]</span> = <span>useState</span><span>(</span><span>1</span><span>)</span><span>;</span><br/></p><p><span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span><br/></p><p><span>// üî¥ Avoid: Fetching without cleanup logic</span><br/></p><p><span>fetchResults</span><span>(</span><span>query</span><span>,</span> <span>page</span><span>)</span>.<span>then</span><span>(</span><span>json</span> <span>=&gt;</span> <span>{</span><br/></p><p><span>setResults</span><span>(</span><span>json</span><span>)</span><span>;</span><br/></p><p><span>}</span><span>)</span><span>;</span><br/></p><p><span>}</span><span>,</span> <span>[</span><span>query</span><span>,</span> <span>page</span><span>]</span><span>)</span><span>;</span><br/></p><p><span>function</span> <span>handleNextPageClick</span><span>(</span><span>)</span> <span>{</span><br/></p><p><span>setPage</span><span>(</span><span>page</span> + <span>1</span><span>)</span><span>;</span><br/></p><p><span>}</span><br/></p><p><span>// ...</span><br/></p><p><span>}</span></p></code></pre></div></div></div></div><!--/$-->
<p>You <em>don‚Äôt</em> need to move this fetch to an event handler.</p>
<p>This might seem like a contradiction with the earlier examples where you needed to put the logic into the event handlers! However, consider that it‚Äôs not <em>the typing event</em> that‚Äôs the main reason to fetch. Search inputs are often prepopulated from the URL, and the user might navigate Back and Forward without touching the input.</p>
<p>It doesn‚Äôt matter where <code>page</code> and <code>query</code> come from. While this component is visible, you want to keep <code>results</code> <a href="https://slowernews.substack.com/learn/synchronizing-with-effects">synchronized</a> with data from the network for the current <code>page</code> and <code>query</code>. This is why it‚Äôs an Effect.</p>
<p>However, the code above has a bug. Imagine you type <code>&#34;hello&#34;</code> fast. Then the <code>query</code> will change from <code>&#34;h&#34;</code>, to <code>&#34;he&#34;</code>, <code>&#34;hel&#34;</code>, <code>&#34;hell&#34;</code>, and <code>&#34;hello&#34;</code>. This will kick off separate fetches, but there is no guarantee about which order the responses will arrive in. For example, the <code>&#34;hell&#34;</code> response may arrive <em>after</em> the <code>&#34;hello&#34;</code> response. Since it will call <code>setResults()</code> last, you will be displaying the wrong search results. This is called a <a href="https://en.wikipedia.org/wiki/Race_condition" target="_blank" rel="nofollow noopener noreferrer">‚Äúrace condition‚Äù</a>: two different requests ‚Äúraced‚Äù against each other and came in a different order than you expected.</p>
<p><strong>To fix the race condition, you need to <a href="https://slowernews.substack.com/learn/synchronizing-with-effects#fetching-data">add a cleanup function</a> to ignore stale responses:</strong></p>
<!--$--><div><div><div><div><pre><code><p><span>function</span> <span>SearchResults</span><span>(</span><span>{</span> <span>query</span> <span>}</span><span>)</span> <span>{</span><br/></p><p><span>const</span> <span>[</span><span>results</span><span>,</span> <span>setResults</span><span>]</span> = <span>useState</span><span>(</span><span>[</span><span>]</span><span>)</span><span>;</span><br/></p><p><span>const</span> <span>[</span><span>page</span><span>,</span> <span>setPage</span><span>]</span> = <span>useState</span><span>(</span><span>1</span><span>)</span><span>;</span><br/></p><p><span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span><br/></p><p><span>let</span> <span>ignore</span> = <span>false</span><span>;</span><br/></p><p><span>fetchResults</span><span>(</span><span>query</span><span>,</span> <span>page</span><span>)</span>.<span>then</span><span>(</span><span>json</span> <span>=&gt;</span> <span>{</span><br/></p><p><span>if</span> <span>(</span>!<span>ignore</span><span>)</span> <span>{</span><br/></p><p><span>setResults</span><span>(</span><span>json</span><span>)</span><span>;</span><br/></p><p><span>}</span><br/></p><p><span>}</span><span>)</span><span>;</span><br/></p><p><span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span><br/></p><p><span>ignore</span> = <span>true</span><span>;</span><br/></p><p><span>}</span><span>;</span><br/></p><p><span>}</span><span>,</span> <span>[</span><span>query</span><span>,</span> <span>page</span><span>]</span><span>)</span><span>;</span><br/></p><p><span>function</span> <span>handleNextPageClick</span><span>(</span><span>)</span> <span>{</span><br/></p><p><span>setPage</span><span>(</span><span>page</span> + <span>1</span><span>)</span><span>;</span><br/></p><p><span>}</span><br/></p><p><span>// ...</span><br/></p><p><span>}</span></p></code></pre></div></div></div></div><!--/$-->
<p>This ensures that when your Effect fetches data, all responses except the last requested one will be ignored.</p>
<p>Handling race conditions is not the only difficulty with implementing data fetching. You might also want to think about caching responses (so that the user can click Back and see the previous screen instantly), how to fetch data on the server (so that the initial server-rendered HTML contains the fetched content instead of a spinner), and how to avoid network waterfalls (so that a child can fetch data without waiting for every parent).</p>
<p><strong>These issues apply to any UI library, not just React. Solving them is not trivial, which is why modern <a href="https://slowernews.substack.com/learn/start-a-new-react-project#production-grade-react-frameworks">frameworks</a> provide more efficient built-in data fetching mechanisms than fetching data in Effects.</strong></p>
<p>If you don‚Äôt use a framework (and don‚Äôt want to build your own) but would like to make data fetching from Effects more ergonomic, consider extracting your fetching logic into a custom Hook like in this example:</p>
<!--$--><div><div><div><div><pre><code><p><span>function</span> <span>SearchResults</span><span>(</span><span>{</span> <span>query</span> <span>}</span><span>)</span> <span>{</span><br/></p><p><span>const</span> <span>[</span><span>page</span><span>,</span> <span>setPage</span><span>]</span> = <span>useState</span><span>(</span><span>1</span><span>)</span><span>;</span><br/></p><p><span>const</span> <span>params</span> = <span>new</span> <span>URLSearchParams</span><span>(</span><span>{</span> <span>query</span><span>,</span> <span>page</span> <span>}</span><span>)</span><span>;</span><br/></p><p><span>const</span> <span>results</span> = <span>useData</span><span>(</span><span>`/api/search?${</span><span>params</span><span>}`</span><span>)</span><span>;</span><br/></p><p><span>function</span> <span>handleNextPageClick</span><span>(</span><span>)</span> <span>{</span><br/></p><p><span>setPage</span><span>(</span><span>page</span> + <span>1</span><span>)</span><span>;</span><br/></p><p><span>}</span><br/></p><p><span>// ...</span><br/></p><p><span>}</span><br/></p><p><span>function</span> <span>useData</span><span>(</span><span>url</span><span>)</span> <span>{</span><br/></p><p><span>const</span> <span>[</span><span>data</span><span>,</span> <span>setData</span><span>]</span> = <span>useState</span><span>(</span><span>null</span><span>)</span><span>;</span><br/></p><p><span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span><br/></p><p><span>let</span> <span>ignore</span> = <span>false</span><span>;</span><br/></p><p><span>fetch</span><span>(</span><span>url</span><span>)</span><br/></p><p>      .<span>then</span><span>(</span><span>response</span> <span>=&gt;</span> <span>response</span>.<span>json</span><span>(</span><span>)</span><span>)</span><br/></p><p>      .<span>then</span><span>(</span><span>json</span> <span>=&gt;</span> <span>{</span><br/></p><p><span>if</span> <span>(</span>!<span>ignore</span><span>)</span> <span>{</span><br/></p><p><span>setData</span><span>(</span><span>json</span><span>)</span><span>;</span><br/></p><p><span>}</span><br/></p><p><span>}</span><span>)</span><span>;</span><br/></p><p><span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span><br/></p><p><span>ignore</span> = <span>true</span><span>;</span><br/></p><p><span>}</span><span>;</span><br/></p><p><span>}</span><span>,</span> <span>[</span><span>url</span><span>]</span><span>)</span><span>;</span><br/></p><p><span>return</span> <span>data</span><span>;</span><br/></p><p><span>}</span></p></code></pre></div></div></div></div><!--/$-->
<p>You‚Äôll likely also want to add some logic for error handling and to track whether the content is loading. You can build a Hook like this yourself or use one of the many solutions already available in the React ecosystem. <strong>Although this alone won‚Äôt be as efficient as using a framework‚Äôs built-in data fetching mechanism, moving the data fetching logic into a custom Hook will make it easier to adopt an efficient data fetching strategy later.</strong></p>
<p>In general, whenever you have to resort to writing Effects, keep an eye out for when you can extract a piece of functionality into a custom Hook with a more declarative and purpose-built API like <code>useData</code> above. The fewer raw <code>useEffect</code> calls you have in your components, the easier you will find to maintain your application.</p>
<section><h2 id="recap">Recap<a href="#recap" aria-label="Link for Recap" title="Link for Recap"><svg width="1em" height="1em" viewBox="0 0 13 13" xmlns="http://www.w3.org/2000/svg"><g fill="currentColor" fill-rule="evenodd"><path d="M7.778 7.975a2.5 2.5 0 0 0 .347-3.837L6.017 2.03a2.498 2.498 0 0 0-3.542-.007 2.5 2.5 0 0 0 .006 3.543l1.153 1.15c.07-.29.154-.563.25-.773.036-.077.084-.16.14-.25L3.18 4.85a1.496 1.496 0 0 1 .002-2.12 1.496 1.496 0 0 1 2.12 0l2.124 2.123a1.496 1.496 0 0 1-.333 2.37c.16.246.42.504.685.752z"></path><path d="M5.657 4.557a2.5 2.5 0 0 0-.347 3.837l2.108 2.108a2.498 2.498 0 0 0 3.542.007 2.5 2.5 0 0 0-.006-3.543L9.802 5.815c-.07.29-.154.565-.25.774-.036.076-.084.16-.14.25l.842.84c.585.587.59 1.532 0 2.122-.587.585-1.532.59-2.12 0L6.008 7.68a1.496 1.496 0 0 1 .332-2.372c-.16-.245-.42-.503-.685-.75z"></path></g></svg></a></h2><ul>
<li>If you can calculate something during render, you don‚Äôt need an Effect.</li>
<li>To cache expensive calculations, add <code>useMemo</code> instead of <code>useEffect</code>.</li>
<li>To reset the state of an entire component tree, pass a different <code>key</code> to it.</li>
<li>To reset a particular bit of state in response to a prop change, set it during rendering.</li>
<li>Code that runs because a component was <em>displayed</em> should be in Effects, the rest should be in events.</li>
<li>If you need to update the state of several components, it‚Äôs better to do it during a single event.</li>
<li>Whenever you try to synchronize state variables in different components, consider lifting state up.</li>
<li>You can fetch data with Effects, but you need to implement cleanup to avoid race conditions.</li>
</ul></section>
</div></div>
  </body>
</html>
