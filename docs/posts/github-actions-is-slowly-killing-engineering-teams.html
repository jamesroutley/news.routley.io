<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.iankduncan.com/engineering/2026-02-05-github-actions-killing-your-team/">Original</a>
    <h1>GitHub Actions is slowly killing engineering teams</h1>
    
    <div id="readability-page-1" class="page"><div>   <p>I was an early employee at CircleCI. I have used, in anger, nearly every CI system that has ever existed. Jenkins, Travis, CircleCI, Semaphore, Drone, Concourse, Wercker (remember Wercker?), TeamCity, Bamboo, GitLab CI, CodeBuild, and probably a half dozen others I’ve mercifully forgotten. I have mass-tested these systems so that you don’t have to, and I have the scars to show for it, and I am here to tell you: GitHub Actions is not good. It’s not even fine. It has market share because it’s <em>right there</em> in your repo, and that’s about the nicest thing I can say about it.</p>
<p>Buildkite is what CI should feel like. But first, let me tell you what CI should <em>not</em> feel like.</p>
<h2 id="if-youre-a-nix-shop-you-can-leave-early">If You’re a Nix Shop, You Can Leave Early</h2>
<p>Before I get into it: if you’re a Nix shop, take a look at <a href="https://garnix.io">Garnix</a>. It evaluates your flake, figures out what needs building, and builds it. No YAML. No pipeline configuration. It just looks at your <code>flake.nix</code> and does the right thing. Sometimes the best CI configuration is no CI configuration.</p>
<p>Most shops are not Nix shops. This post is for the rest of you. I’m sorry.</p>
<hr/>

<h2 id="the-log-viewer-or-where-your-afternoon-goes-to-die">The Log Viewer, or: Where Your Afternoon Goes to Die</h2>
<p>Let me start with the most visceral thing, the thing that will sound like I’m exaggerating but I am not.</p>
<p>Your build fails. You get a red X on your pull request. You click through to see what happened. This is where the ordeal begins.</p>
<p>First you land on the checks summary page, which shows you a list of workflow runs. Maybe one failed. Maybe three failed. You click the one that looks relevant. Now you’re on the workflow run page, which shows you a list of jobs. You click the failed job. Now you’re on the job page, which shows you a list of steps, all collapsed. You click the step that failed. The page hitches. You scroll. There is a pause, a held breath, and then the logs appear, slowly, like a manuscript being revealed one line at a time to a supplicant who has not yet proven worthy.</p>
<p>That’s three or four clicks just to see the error, and every one of them loads a new page with its own loading spinner, and none of them are fast. You are navigating a bureaucracy. You are filling out forms at the DMV of CI.</p>
<p>And then the log viewer itself. I have used every CI system known to man, and the GitHub Actions log viewer is the only one that has <em>crashed my browser</em>. Not once. Repeatedly. Reliably. Open a long build log, try to search for an error, and Chrome will look you in the eye and die. This is the log viewer for the most popular CI system in the world. This is the tool you are expected to use to understand why your build failed. It cannot survive contact with its own output.</p>
<p>With large logs (and if you have a real build system, you have large logs) you often can’t even scroll to the bottom. The page just gives up. The scrollbar is there, technically, but it’s decorative. It’s a suggestion. You drag it down and the page chokes and stutters and eventually you realize you’re not going to get there this way. So you download the raw log artifact and open it in a text editor like it’s 2003 and you’re reading Apache access logs on a shared hosting box. Except it’s 2025 and this is a product made by one of the richest companies on earth.</p>
<p>And when you’re done, when you’ve finally found the error, processed your grief, and want to go back to the pull request that started this whole ordeal, you hit the back button. Does it take you to the PR? No. It takes you to some other page in the GitHub Actions UI. A summary page, maybe. Or a different run. Or a page you don’t recognize. The back button in the GitHub Actions UI is a roulette wheel. You will land somewhere. It will not be where you wanted to go. You will click the back button again. You will land somewhere else. Eventually you give up and type the PR URL from memory or go find it in your browser history, which is now 80% GitHub Actions URLs, a fact that will haunt you when you look at it later.</p>
<p>So the logs have betrayed you, or perhaps they simply could not be made to appear at all. Now begins the second ritual: the debugging.</p>
<p>You push a commit. You wait. A runner picks it up. You watch logs scroll. Something fails. The error looks like someone fed a stack trace through a paper shredder and then set the shredder on fire. You add a <code>run: env</code> step to see what’s going on. You push again. You wait again. A twenty-minute feedback loop for a one-line change. You do this fourteen times. This is your afternoon now. You had plans. You were going to go outside. The afternoon belongs to the CI now. It has always belonged to the CI. You are only now perceiving this truth.</p>
<p>There is something devotional about the experience. You approach the logs. You make your offering of clicks and patience. The page considers your request. Sometimes it grants you the knowledge you seek. Sometimes it takes your browser tab instead, a small sacrifice, consumed, gone. You open a new tab. You try again. This is the ritual. You did not choose it. The work continues.</p>
<h2 id="the-yaml-trap">The YAML Trap</h2>
<p>Every CI system eventually becomes “a bunch of YAML.” I’ve been through the five stages of grief about it and emerged on the other side, diminished but functional. But GitHub Actions YAML is a special breed. It’s YAML with its own expression language bolted on, its own context object model, its own string interpolation rules, and a scattering of gotchas that will slowly hollow you out as a person. Each gotcha leaves a mark. The marks do not fade.</p>
<p>Have you ever tried to conditionally set an environment variable based on which branch you’re on? Have you done the <code>${{ }}</code> expression dance, misquoted something, and then waited four minutes for a runner to spin up just to discover your string got eaten? Of course you have. We all have. We have all stared at a diff that changes one character in a YAML expression and thought “I went to college for this.”</p>
<p>The expression syntax has the quality of a language that grew in the dark, unsupervised. It began as a convenience. It accreted features. Somewhere along the way it crossed a threshold, and now it exists in a liminal space- too complex to be configuration, too constrained to be a proper language. You learn its grammar not from documentation but from failure, each error message a koan that points toward understanding but does not provide it.</p>
<h2 id="but-the-marketplace">”But the Marketplace!”</h2>
<p>Ah yes, the GitHub Actions Marketplace. The npm of CI. A bazaar of community-maintained actions of varying quality, most of which are shell scripts with a <code>Dockerfile</code> and a dream.</p>
<p>Every time you type <code>uses: some-stranger/cool-action@v2</code>, you’re handing a stranger access to your repo, your secrets, and your build environment. Yes, you can pin to a SHA. Nobody does. And even if you do, you’re still running opaque code you didn’t write and probably haven’t read, in a context where it has access to your <code>GITHUB_TOKEN</code> and whatever else you’ve stuffed in there. Every action you add is another set of house keys you’re handing to someone you’ve never met and hoping for the best.</p>
<p>The Marketplace has the energy of a night market in a city you don’t know, where every stall sells something that claims to solve your problem. Some of them do. Some of them have other intentions. You cannot tell which is which from the outside. You can only install them and see what happens. This is called “dependency management.” We have normalized it. The normalization does not make it safe.</p>
<h2 id="you-dont-own-your-compute">You Don’t Own Your Compute</h2>
<p>With GitHub Actions, you’re renting Microsoft’s runners. They’re slow, they’re resource-constrained, you can’t customize them in any meaningful way, and you’re at the mercy of GitHub’s capacity planning. Need a beefy machine for a big build? You can pay for a larger runner, at prices that will get you a calendar invite from finance titled “we need to talk,” and you still don’t control the environment.</p>
<p>You know how I know GitHub’s runners are bad? Because there’s an entire cottage industry of companies whose sole product is “GitHub Actions, but the runners don’t suck.” Namespace, Blacksmith, Actuated, Runs-on, BuildJet. There are at least half a dozen startups that exist purely to solve the problem of GitHub Actions being slow. Their pitch is, essentially, “keep your workflows, we’ll just make them not take forever.” The fact that this is a viable business model, that multiple companies can sustain themselves on the premise that the default compute for the world’s most popular CI system is inadequate, tells you everything you need to know.</p>
<p>Now, to be fair, you <em>can</em> bring your own runners to GitHub Actions. Self-hosted runners exist. You can set up your own machines, install Nix, configure your environment exactly how you want it. And this does solve the compute problem. Your builds will be faster. Your caches will be warm. But you’ll still be writing GitHub Actions YAML. You’ll still be fighting the expression syntax and the permissions model and the marketplace and the log viewer that crashes your browser. You’ve upgraded the engine but you’re still driving the car that catches fire when you turn on the radio.</p>
<p>I think the people who originally built GitHub Actions were probably well-intentioned. They probably cared about developer experience. But this is a Microsoft product now, and Microsoft is where ambitious developer tools go to become enterprise SKUs. The original engineers have long since been reorged into other divisions or ground down into product managers. The vision, if there was one, is entombed now. But if you press your ear to the floor during a particularly slow build, you can still hear its heart beating, faintly, beneath the floorboards.</p>
<h2 id="the-little-things">The Little Things</h2>
<p>Things that seem small but accumulate. Each one is survivable. Together they form a compelling case for simply walking into the sea. The sea does not have YAML. The sea does not require a <code>GITHUB_TOKEN</code>.</p>
<p>The <code>actions/cache</code> action is an exercise in futility. Cache keys are confusing, cache misses are silent, and cache eviction is opaque. You will spend more time debugging caching than you save by having a cache.</p>
<p>Reusable workflows can’t be nested beyond a certain depth, can’t access the calling workflow’s context cleanly, and live in YAML files that are impossible to test in isolation. At some point you realize you’re writing a distributed system in YAML and you have to sit down and think about the choices that led you here. The thinking changes you. You do not get the old version of yourself back. That person didn’t know what a <code>workflow_call</code> trigger was. That person was happy.</p>
<p>The <code>GITHUB_TOKEN</code> permissions model is a maze. <code>permissions: write-all</code> is a hammer, fine-grained permissions are a puzzle, and the interaction between repository settings, workflow settings, and job-level settings will make you want to lie down on the floor. I once spent an entire day on token permissions. I will never get that day back. It’s gone. I could have learned to paint. I could have called my mother. I could have mass-tested a new CI system. Anything.</p>
<p>Concurrency controls are blunt. Cancel in-progress runs on the same branch? Sure, one line. Anything more nuanced? No. The system does not wish to discuss nuance. The system has other concerns.</p>
<p>Secrets can’t be used in <code>if</code> conditions. This means you can’t do things like <code>if: secrets.DEPLOY_KEY != &#39;&#39;</code> to conditionally run a step based on whether a secret is configured. GitHub doesn’t want secret values leaking into logs via expression evaluation, which is a reasonable security concern. But the practical result is that you can’t write workflows that gracefully degrade when optional secrets aren’t present. Instead you need awkward workarounds like setting a non-secret environment variable that flags whether the real secret exists. It’s one of those decisions that makes perfect sense in a security review and makes you want to scream when you’re actually trying to write a workflow that works in both forks and the main repo.</p>
<h2 id="just-write-bash-scripts">”Just Write Bash Scripts”</h2>
<p>At some point in every engineer’s CI journey, a temptation presents itself.</p>
<p>“What if I just wrote bash scripts?” the voice whispers. “What if I stopped fighting the CI system and just <code>run:</code>’d a big shell script that does everything? I could run it locally. I could test it. I’d be free.”</p>
<p>I understand the appeal. I have felt it myself, late at night, after the fourth failed workflow run in a row. The desire to burn down the YAML temple and return to the simple honest earth of <code>#!/bin/bash</code> and <code>set -euo pipefail</code>. To cast off the chains of marketplace actions and reusable workflows and just <em>write the damn commands</em>. It feels like liberation. It is not.</p>
<p>Here’s what actually happens. Your bash script works. You feel clever. You tell your coworkers about it. Then the script grows. It acquires conditionals. It acquires functions. It acquires argument parsing. It acquires a second script that it sources. Someone adds error handling. Someone else adds logging. Someone (and this person should be stopped, but never is) adds “just a little bit of parallelism.”</p>
<p>Three months later you have 800 lines of bash that reimplements job parallelism with <code>wait</code> and PID files, has its own retry logic built on a <code>for</code> loop and <code>sleep</code>, and parses its own output to determine success or failure. The script has become self-aware. There’s a race condition in the cleanup trap that only manifests on Linux kernel 6.x, and you are the only person who understands the script, and you are on vacation, and your phone is ringing.</p>
<p>You have not escaped CI. You have built a CI system. It’s just worse than every other CI system, because it’s written in bash, and nobody can follow it, and it has no test framework, and <code>shellcheck</code> is screaming into the void, and the void is also written in bash.</p>
<p>Bash is fine for glue. Bash is fine for “run these four commands in order.” Bash is not a build system. Bash is not a test harness. The fact that it can be coerced into impersonating both is not a recommendation. It’s a warning sign. You are not simplifying. You are moving complexity from a place with guardrails to a place with none. The complexity will not be grateful for its new freedom. The complexity will use its freedom to make your life worse.</p>
<hr/>

<p>There are other ways to live. Buildkite is what CI should feel like. Not joyful, nothing about CI is joyful, but <em>tolerable</em>. A tool that understands its purpose and does not fight you. Let me tell you how the other half lives.</p>
<h2 id="a-log-viewer-that-does-not-consume-your-browser">A Log Viewer That Does Not Consume Your Browser</h2>
<p>Buildkite’s log viewer is just a web page that shows you logs and doesn’t crash. I realize that’s a low bar. It’s a bar that GitHub Actions trips over and falls face-first into the mud, gets up, slips again, and somehow sets the mud on fire.</p>
<p>The terminal output rendering is excellent. Build logs look like terminal output, because they are terminal output. ANSI colors work. Your test framework’s fancy formatting comes through intact. You’re not squinting at a web UI that has eaten your escape codes and rendered them as mojibake. This sounds minor. It is not minor. You are reading build logs dozens of times a day. The experience of reading them matters in the way that a comfortable chair matters. You only notice how much it matters after you’ve been sitting in a bad one for six hours and your back has filed a formal complaint.</p>
<p>Annotations let your build steps write rich Markdown output (test failure summaries, coverage reports, deploy links,) right into the build page. You don’t have to dig through log output to find the thing you care about. The information comes to you. After years of fighting GitHub Actions’ collapsible log groups and wondering which of the seventeen nested folds contains the actual error message, this feels like stepping out of a cave into sunlight.</p>
<p>And debugging? Buildkite doesn’t make CI debugging fun. Nothing does. Nothing can. It is one of the irreducible sufferings of our craft. But because the agent runs on your infrastructure, you can SSH into the box. You can look at what’s actually happening. You can reproduce the environment locally because <em>you built the environment</em>. You are still mortal, but at least you have tools.</p>
<h2 id="yaml-that-knows-its-place">YAML That Knows Its Place</h2>
<p>Buildkite has YAML too, but the difference is that Buildkite’s YAML is <em>just describing a pipeline</em>. Steps, commands, plugins. It’s a data structure, not a programming language cosplaying as a config format. When you need actual logic? You write a script. In a real language. That you can run locally. Like a human being with dignity and a will to live.</p>
<p>This is the boundary the bash zealots were actually looking for: not “put everything in bash,” but “put the orchestration in config and the logic in code.” Buildkite respects this boundary. GitHub Actions blurs it until you can no longer tell where configuration ends and programming begins, and then the programming happens in a language that can’t do basic arithmetic without <code>${{ }}</code> and a prayer.</p>
<h2 id="you-own-your-compute">You Own Your Compute</h2>
<p>With Buildkite, the agent is a single binary that runs on <em>your</em> machines. Your cloud, your on-prem boxes, your weird custom hardware. You control the instance types, the caching, the local storage, the network. Run agents on a fleet of massive EC2 instances with NVMe drives and 20 gigs of Docker layer cache. Run them on a Raspberry Pi. It doesn’t care. The fastest CI is the one with a warm cache on a big machine that you control.</p>
<p>You don’t see a cottage industry of “Buildkite, but faster.” You don’t need one. You just run bigger machines.</p>
<p>GitHub Actions will never give you this. GitHub Actions will give you a mass-produced Ubuntu VM with the emotional warmth of a hospital waiting room.</p>
<h3 id="a-note-on-running-your-own-infrastructure">A Note on Running Your Own Infrastructure</h3>
<p>I can hear the objection forming: “But I don’t want to run my own CI infrastructure. I just want to push code and have tests run.”</p>
<p>Fair. Running your own agents is not for everyone. If you’re maintaining a small open source library in your spare time, you shouldn’t have to spin up EC2 instances and manage autoscaling groups. GitHub Actions’ free tier for public repos is genuinely valuable for the OSS ecosystem, and I’m not here to tell a solo maintainer they need to set up Terraform to run their unit tests.</p>
<p>This post is mostly aimed at teams running production systems at businesses, places where you’re already managing infrastructure, where CI time is measured in engineering hours lost per week, where the build that takes 45 minutes is costing you real money in both compute and salary. If that’s you, the overhead of running Buildkite agents pays for itself quickly. If you’re publishing a 200-line npm package on your weekends, the calculus is different and that’s fine.</p>
<h2 id="dynamic-pipelines">Dynamic Pipelines</h2>
<p>In Buildkite, pipeline steps are just data. You can <em>generate them</em>.</p>
<p>Your pipeline YAML can contain a step that runs a script, and that script can emit more pipeline steps. Dynamically. At runtime. Based on whatever logic you want: which files changed, what day of the week it is, the phase of the moon, whether the build gods are feeling merciful.</p>
<p>So you write a script that looks at your monorepo, figures out what changed, and uploads exactly the right set of steps for the things that need building and testing. No hardcoded matrix. No <code>if: contains(github.event.pull_request...)</code> spaghetti. Just a program that outputs steps.</p>
<p>GitHub Actions has <code>matrix</code> strategies and <code>if</code> conditions and reusable workflows and all sorts of mechanisms that try to approximate this. They’re all worse. They’re declarative in the worst sense: you’re declaring things in a language that isn’t powerful enough to express what you mean, so you end up building a Rube Goldberg machine out of YAML and regret. The machine grows. You feed it. It does not thank you.</p>
<h2 id="on-the-matter-of-plugins">On the Matter of Plugins</h2>
<p>I’ll be honest: Buildkite’s plugin system is structurally pretty similar to the GitHub Actions Marketplace. You’re still pulling in third-party code from a repo. You’re still trusting someone else’s work. I won’t pretend there’s some magic architectural difference that makes this safe.</p>
<p>The real difference is narrower than I’d like: Buildkite plugins tend to be thin shell hooks rather than entire Docker images with their own runtime, so there’s less surface area to hide things in, and you can usually read the whole plugin in a few minutes. More importantly, they run on <em>your</em> infrastructure, so at least the blast radius is something you control. It’s not a solved problem. It’s a smaller problem.</p>
<h2 id="the-small-delights">The Small Delights</h2>
<p>Buildkite has custom emoji. You can put a little <code>:parrot:</code> or <code>:docker:</code> or your team’s custom emoji next to your pipeline steps. This is, objectively, a frivolous feature. It is also one of my favorite things about Buildkite, because it tells you something about the people who built it. They thought about what it <em>feels like</em> to use their product. They knew that CI is a slog and that a small dumb thing like a custom emoji next to your deploy step can make the slog a fraction more bearable.</p>
<p>GitHub Actions would never do this. GitHub Actions is a product designed by a committee that has never once asked “but is it delightful?” and it shows.</p>
<p>Buildkite is built by people who clearly use CI every day and have thought hard about what makes it tolerable. The result is a tool that, if not exactly joyful, at least does not make you want to lie down on the floor. In this industry, that’s high praise.</p>
<hr/>
<h2 id="but-everyone-uses-it">But Everyone Uses It!</h2>
<p>Yeah. GitHub Actions won by being the default, not by being good. It’s free for public repos, it’s built into the platform everyone already uses, and it’s Good Enough. It’s the Internet Explorer of CI. It ships with the thing. People use it because switching costs are real and life is finite and we’re all just trying to ship code and go home.</p>
<p>If you’re a small team with a simple app and straightforward tests, it’s probably fine. I’m not going to tell you to rip it out.</p>
<p>But if you’re running a real production system, if you have a monorepo, if your builds take more than five minutes, if you care about supply chain security, if you want to actually <em>own</em> your CI: look at Buildkite.</p>
<p>I’ve been doing this for a long time. I’ve watched CI systems come and go. I’ve helped build one. The pattern is always the same: the CI system that wins market share is never the one that’s best at being a CI system. It’s the one that’s easiest to start using.</p>
<p>GitHub Actions is the easiest CI to start using. Buildkite is the best CI to keep using. And in the long run (assuming your CI hasn’t already ground you into a fine paste, assuming the YAML hasn’t hollowed you out entirely, assuming there’s still someone left who remembers what it was like before,) that’s what matters.</p>
<hr/>
<p><em>If your CI works and you’re happy, great, keep going. But if you’ve got that nagging feeling that it’s fighting you more than helping you: you’re not the problem. The tooling is. There are other ways to live.</em></p>   </div></div>
  </body>
</html>
