<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://qwenlm.github.io/blog/qwen-moe/">Original</a>
    <h1>Qwen1.5-Moe: Matching 7B Model Performance with 1/3 Activated Parameters</h1>
    
    <div id="readability-page-1" class="page"><div><article><div><p><a href="https://github.com/QwenLM/Qwen1.5" target="_blank">GITHUB</a>
<a href="https://huggingface.co/Qwen" target="_blank">HUGGING FACE</a>
<a href="https://modelscope.cn/organization/qwen" target="_blank">MODELSCOPE</a>
<a href="https://huggingface.co/spaces/Qwen/Qwen1.5MoE-A2.7B-Chat" target="_blank">DEMO</a>
<a href="https://discord.gg/yPEP2vHTu4" target="_blank">DISCORD</a></p><p>Since the surge in interest sparked by Mixtral, research on mixture-of-expert (MoE) models has gained significant momentum. Both researchers and practitioners are keenly interested in understanding how to effectively train such models and assessing their efficiency and effectiveness. Today, we introduce Qwen1.5-MoE-A2.7B, a small MoE model with only 2.7 billion activated parameters yet matching the performance of state-of-the-art 7B models like Mistral 7B and Qwen1.5-7B.</p><p>Compared to Qwen1.5-7B, which contains 6.5 billion non-embedding parameters, Qwen1.5-MoE-A2.7B contains only 2.0 billion non-embedding parameters, approximately one-third of Qwen1.5-7B’s size. Notably, it achieves a 75% decrease in training expenses and accelerates inference speed by a factor of 1.74, offering substantial improvements in resource utilization without compromising performance.</p><figure><img src="https://qianwen-res.oss-accelerate.aliyuncs.com/assets/blog/qwen1.5/qwen-moe.jpg#center" width="100%"/></figure><p>We build the Qwen1.5-MoE models with a specially designed MoE architecture. Typically, as seen in methods like Mixtral, MoE layers within each transformer block employ eight experts and utilize a top-2 gating strategy for routing purposes. This configuration, while straightforward and efficacious, presents ample scope for enhancement. Consequently, through an extensive series of experiments, we have introduced several modifications to this architecture:</p><ul><li>Finegrained experts</li><li>Initialization, which we call it “upcycling”</li><li>Routing mechanism, with shared and routing experts</li></ul><p>Previous research projects such as DeepSeek-MoE and DBRX have demonstrated the effectiveness of using fine-grained experts. Conventionally, when transitioning from a standard FFN layer to a Mixture-of-Experts (MoE) layer, one merely replicates the FFN multiple times to create multiple experts. However, in the context of fine-grained experts, the goal is to generate a larger number of experts without increasing the parameter count. To accomplish this, we partition a single FFN into several segments, each serving as an individual expert. This is a more nuanced approach to constructing experts. We have identified an optimal configuration with a total of 64 experts, representing an 8-time increase compared to the conventional MoE setup of 8 experts.</p><p>The initialization stage of the model is critical. Our initial experiments suggest that training a MoE model from scratch may prove inefficient and challenging to elevate it to the anticipated peak performance. Instead, we start by repurposing our existing Qwen-1.8B, transforming it into Qwen1.5-MoE-A2.7B. A noteworthy finding is that introducing randomness during initialization significantly expedites convergence and results in superior overall performance throughout the pre-training process.</p><p>An essential aspect deserving attention is the routing methodology employed. Presently, there is a growing trend towards using shared and routing-specific experts within the MoE layer. To view it from a broader perspective, this is a generalized MoE routing approach, as having zero shared experts effectively reduces to the conventional MoE routing setup. In the case of Qwen1.5-MoE-A2.7B model, we have incorporated 4 shared experts to be always activated alongside 60 routing experts with 4 to be activated. This configuration offers a more adaptable method for constructing the MoE routing mechanism, providing greater flexibility and efficiency.</p><p>In order to thoroughly assess and showcase the capabilities and superiority of our newly developed model, we have conducted extensive evaluations across various benchmark datasets for both the base and chat models. For the base model, we evaluated its performance on 3 benchmarks: MMLU, GSM8K, and HumanEval for evaluating language understanding, mathematics, and coding. Additionally, to gauge its multilingual proficiency, we followed the evaluation protocol of Qwen1.5 and tested it on several benchmarks that spanned diverse domains such as exams, understanding, math, and translation, presenting an aggregate score in the “Multilingual” column. For the chat model, rather than employing traditional benchmarks, we subjected it to testing using MT-Bench.</p><p>In this comparative analysis, we juxtaposed Qwen1.5-MoE-A2.7B against top-performing 7B base models like Mistral-7B (v0.1 base and v0.2 instruct), Gemma-7B, and Qwen1.5-7B. Furthermore, we included a comparison with other MoE models of comparable parameter counts, notably DeepSeekMoE 16B. The results are summarized in the table below:</p><table><thead><tr><th>Model</th><th>MMLU</th><th>GSM8K</th><th>HumanEval</th><th>Multilingual</th><th>MT-Bench</th></tr></thead><tbody><tr><td>Mistral-7B</td><td>64.1</td><td>47.5</td><td>27.4</td><td>40.0</td><td>7.60</td></tr><tr><td>Gemma-7B</td><td>64.6</td><td>50.9</td><td>32.3</td><td>-</td><td>-</td></tr><tr><td>Qwen1.5-7B</td><td>61.0</td><td>62.5</td><td>36.0</td><td>45.2</td><td>7.60</td></tr><tr><td>DeepSeekMoE 16B</td><td>45.0</td><td>18.8</td><td>26.8</td><td>-</td><td>6.93</td></tr><tr><td>Qwen1.5-MoE-A2.7B</td><td>62.5</td><td>61.5</td><td>34.2</td><td>40.8</td><td>7.17</td></tr></tbody></table><p>The Qwen1.5-MoE-A2.7B model has demonstrated competitive performance akin to the top 7B models in various evaluations. Despite this parity, our analysis reveals untapped potential for enhancement in the domain of chat models specifically. As such, we are committed to furthering our research efforts towards refining the effective finetuning strategies for MoE models.</p><p>The training costs of MoE models deviates significantly from that of their dense counterparts. Despite a larger parameter count, MoE models’ training expenses can be notably reduced due to sparsity. To better understand this, let’s first delve into three key components: total number of parameters, the count of active parameters, and non-embedding parameters and make a comparison between models:</p><table><thead><tr><th>Model</th><th>#Parameters</th><th>#(Activated) Parameters</th><th>#(Activated) Non-embedding parameters</th></tr></thead><tbody><tr><td>Mistral-7B</td><td>7.2</td><td>7.2</td><td>7.0</td></tr><tr><td>Qwen1.5-7B</td><td>7.7</td><td>7.7</td><td>6.4</td></tr><tr><td>Gemma-7B</td><td>8.5</td><td>7.8</td><td>7.8</td></tr><tr><td>DeepSeekMoE 16B</td><td>16.4</td><td>2.8</td><td>2.4</td></tr><tr><td>Qwen1.5-MoE-A2.7B</td><td>14.3</td><td>2.7</td><td>2.0</td></tr></tbody></table><p>It is obvious that the count of non-embedding parameters of our MoE model is much smaller than those of 7B models. In our practical implementation, we have observed a remarkable reduction of 75% in training costs when using Qwen1.5-MoE-A2.7B in comparison to Qwen1.5-7B. Of particular significance is the fact that, through upcycling, the necessity for training an equivalent volume of tokens as in the original model has been eliminated. This constitutes a substantial enhancement in terms of economizing on training expenses.</p><p>We have deployed both Qwen1.5-7B and Qwen1.5-MoE-A2.7B models with vLLM and conducted performance tests using a single NVIDIA A100-80G GPU. Under the experimental setup where the input token count was set at 1000 and the output tokens at 1000, we measured the performance in terms of throughput (requests processed per second) and tokens per second (TPS):</p><table><thead><tr><th>Model</th><th>Throughput</th><th>TPS</th></tr></thead><tbody><tr><td>Qwen1.5-7B-Chat</td><td>1.15</td><td>2298.89</td></tr><tr><td>Qwen1.5-MoE-A2.7B-Chat</td><td>2.01</td><td>4010.27</td></tr></tbody></table><p>The Qwen1.5-MoE-A2.7B model exhibits an impressive improvement in speed, being approximately 1.74 times faster compared to the Qwen1.5-7B model. This acceleration is primarily attributed to the fact that the MoE architecture activates a notably smaller portion of its total parameters, thereby reducing computational demands. Moreover, the integration of shared experts contributes substantially to enhancing the model’s inference efficiency. Consequently, despite the increased memory requirements associated with MoE models, they demonstrate clear advantages in terms of both throughput and inference speed.</p><p>To utilize the Qwen1.5-MoE model with the <code>qwen2_moe</code> implementation in Hugging Face’s transformers, since the latest release does not include this feature yet, you will have to install transformers from source instead of installing it via pip or conda:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>git clone https://github.com/huggingface/transformers
</span></span><span><span><span>cd</span> transformers
</span></span><span><span>pip install -e .
</span></span></code></pre></div><p>The following step is indeed straightforward and akin to using models such as Qwen1.5, Mistral, or Llama. We demonstrate an example of the usage of Qwen1.5-MoE-A2.7B-Chat. To use the quantized model instead, you can just substitute the model name <code>Qwen1.5-MoE-A2.7B-Chat</code> with <code>Qwen1.5-MoE-A2.7B-Chat-GPTQ-Int4</code> (temporarily AWQ is not supported).</p><div><pre tabindex="0"><code data-lang="python"><span><span><span>from</span> <span>transformers</span> <span>import</span> <span>AutoModelForCausalLM</span><span>,</span> <span>AutoTokenizer</span>
</span></span><span><span>
</span></span><span><span><span>model</span> <span>=</span> <span>AutoModelForCausalLM</span><span>.</span><span>from_pretrained</span><span>(</span>
</span></span><span><span>    <span>&#34;Qwen/Qwen1.5-MoE-A2.7B-Chat-GPTQ-Int4&#34;</span><span>,</span>
</span></span><span><span>    <span>device_map</span><span>=</span><span>&#34;auto&#34;</span>
</span></span><span><span><span>)</span>
</span></span><span><span><span>tokenizer</span> <span>=</span> <span>AutoTokenizer</span><span>.</span><span>from_pretrained</span><span>(</span><span>&#34;Qwen/Qwen1.5-MoE-A2.7B-Chat&#34;</span><span>)</span>
</span></span><span><span>
</span></span><span><span><span>prompt</span> <span>=</span> <span>&#34;Give me a short introduction to large language model.&#34;</span>
</span></span><span><span><span>messages</span> <span>=</span> <span>[</span>
</span></span><span><span>    <span>{</span><span>&#34;role&#34;</span><span>:</span> <span>&#34;system&#34;</span><span>,</span> <span>&#34;content&#34;</span><span>:</span> <span>&#34;You are a helpful assistant.&#34;</span><span>},</span>
</span></span><span><span>    <span>{</span><span>&#34;role&#34;</span><span>:</span> <span>&#34;user&#34;</span><span>,</span> <span>&#34;content&#34;</span><span>:</span> <span>prompt</span><span>}</span>
</span></span><span><span><span>]</span>
</span></span><span><span><span>text</span> <span>=</span> <span>tokenizer</span><span>.</span><span>apply_chat_template</span><span>(</span>
</span></span><span><span>    <span>messages</span><span>,</span>
</span></span><span><span>    <span>tokenize</span><span>=</span><span>False</span><span>,</span>
</span></span><span><span>    <span>add_generation_prompt</span><span>=</span><span>True</span>
</span></span><span><span><span>)</span>
</span></span><span><span><span>model_inputs</span> <span>=</span> <span>tokenizer</span><span>([</span><span>text</span><span>],</span> <span>return_tensors</span><span>=</span><span>&#34;pt&#34;</span><span>)</span><span>.</span><span>to</span><span>(</span><span>model</span><span>.</span><span>device</span><span>)</span>
</span></span><span><span>
</span></span><span><span><span>generated_ids</span> <span>=</span> <span>model</span><span>.</span><span>generate</span><span>(</span>
</span></span><span><span>    <span>model_inputs</span><span>.</span><span>input_ids</span><span>,</span>
</span></span><span><span>    <span>max_new_tokens</span><span>=</span><span>512</span>
</span></span><span><span><span>)</span>
</span></span><span><span><span>generated_ids</span> <span>=</span> <span>[</span>
</span></span><span><span>    <span>output_ids</span><span>[</span><span>len</span><span>(</span><span>input_ids</span><span>):]</span> <span>for</span> <span>input_ids</span><span>,</span> <span>output_ids</span> <span>in</span> <span>zip</span><span>(</span><span>model_inputs</span><span>.</span><span>input_ids</span><span>,</span> <span>generated_ids</span><span>)</span>
</span></span><span><span><span>]</span>
</span></span><span><span>
</span></span><span><span><span>response</span> <span>=</span> <span>tokenizer</span><span>.</span><span>batch_decode</span><span>(</span><span>generated_ids</span><span>,</span> <span>skip_special_tokens</span><span>=</span><span>True</span><span>)[</span><span>0</span><span>]</span>
</span></span></code></pre></div><p>To use the model with vLLM, follow our fork first and then install vLLM from source as well:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>git clone https://github.com/vllm-project/vllm.git
</span></span><span><span><span>cd</span> vllm
</span></span><span><span>pip install -e .
</span></span></code></pre></div><p>Here we demonstrate an example to show how to use vLLM to build an OpenAI-API compatible interface for our model:</p><div><pre tabindex="0"><code data-lang="shell"><span><span>python -m vllm.entrypoints.openai.api_server --model Qwen/Qwen1.5-MoE-A2.7B-Chat
</span></span></code></pre></div><div><pre tabindex="0"><code data-lang="shell"><span><span>curl http://localhost:8000/v1/chat/completions <span>\
</span></span></span><span><span><span></span>    -H <span>&#34;Content-Type: application/json&#34;</span> <span>\
</span></span></span><span><span><span></span>    -d <span>&#39;{
</span></span></span><span><span><span>    &#34;model&#34;: &#34;Qwen/Qwen1.5-MoE-A2.7B-Chat&#34;,
</span></span></span><span><span><span>    &#34;messages&#34;: [
</span></span></span><span><span><span>    {&#34;role&#34;: &#34;system&#34;, &#34;content&#34;: &#34;You are a helpful assistant.&#34;},
</span></span></span><span><span><span>    {&#34;role&#34;: &#34;user&#34;, &#34;content&#34;: &#34;Tell me something about large language models.&#34;}
</span></span></span><span><span><span>    ]
</span></span></span><span><span><span>    }&#39;</span>
</span></span></code></pre></div><p>There remains an extensive array of tasks on our agenda, including the support of llama.cpp for GGUF files, MLX support, etc. We will continue updating the support of third-party frameworks.</p><p>We are thrilled to introduce our pioneering MoE model, Qwen1.5-MoE-A2.7B, which achieves parity with contemporary 7B parameter models. Furthermore, we have shown substantial reductions in both training costs and inference time when compared to conventional 7B models. Our model developments underscore the vast potential of MoE models. In light of these encouraging outcomes, we remain steadfast in our commitment to advancing this technology further.</p></div></article></div></div>
  </body>
</html>
