<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://emilkowal.ski/ui/building-a-toast-component">Original</a>
    <h1>Building a Toast Component</h1>
    
    <div id="readability-page-1" class="page"><div><p>Back in 2023, I decided to build a toast library called <a href="https://sonner.emilkowal.ski/" target="_blank">Sonner</a>. It’s now downloaded over 7,000,000 times per week from npm and used by companies like Cursor, X, and Vercel. It’s also the default toast component in shadcn/ui.</p>
<p>When I was making it, the toast “market” was already crowded. So what made Sonner stand out? Why did people choose it over proven alternatives?</p>
<p>Let’s start with the name.</p>

<a href="#naming"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none"><path d="M10 19.0004L9.82843 19.1719C8.26634 20.734 5.73368 20.734 4.17158 19.1719L3.82843 18.8288C2.26634 17.2667 2.26633 14.734 3.82843 13.1719L7.17158 9.8288C8.73368 8.2667 11.2663 8.2667 12.8284 9.8288L13.1716 10.1719C13.8252 10.8256 14.2053 11.6491 14.312 12.5004" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path><path d="M9.68799 12.5004C9.79463 13.3516 10.1748 14.1752 10.8284 14.8288L11.1715 15.1719C12.7336 16.734 15.2663 16.734 16.8284 15.1719L20.1715 11.8288C21.7336 10.2667 21.7336 7.73404 20.1715 6.17194L19.8284 5.8288C18.2663 4.2667 15.7336 4.2667 14.1715 5.8288L14 6.00037" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path></svg><h2 id="naming">Naming</h2></a>
<p>My thinking was that naming things based on their function feels cheap.</p>
<p>The way I came up with Sonner is I looked up French words related to notifications. Sonner, which means “to ring” was one of them.</p>
<div><p><span>sonner</span></p><div><div><svg xmlns="http://www.w3.org/2000/svg" width="14" height="9" fill="none" viewBox="0 0 14 9"><g clip-path="url(#clip0_2_101)"><path fill="#fff" d="M0 0h14v9H0z"></path><path fill="color(display-p3 0.0431 0.1451 0.3176)" d="M0 0h4.667v9H0z"></path><path fill="color(display-p3 0.7412 0.1765 0.1843)" d="M9.333 0H14v9H9.333z"></path></g><path stroke="#000" stroke-opacity="0.08" d="M.5.5h13v8H.5z"></path><defs><clipPath id="clip0_2_101"><path fill="#fff" d="M0 0h14v9H0z"></path></clipPath></defs></svg><p><span>/sɔ.ne/ <span>Verb [intransitive]</span></span></p></div><p><span>Inherited from Old French <em>soner</em>,<!-- --> <em>suner</em>, from Latin sonāre.</span></p></div><div><div><div><ol><li><span>1.</span> to<!-- --> <em>sound</em></li><li><span>2.</span> to<!-- --> <em>ring</em></li><p><span><span>Sonner</span> la cloche (Ring the bell).</span><span><span>Sonner</span> a la porte (Give a ring).</span></p></ol></div></div></div></div>
<p>While I’m sacrificing discoverability and clarity, it feels elegant to me. It’s also a name that feels different, which is important if I want it to stand out.</p>
<a href="#animations"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none"><path d="M10 19.0004L9.82843 19.1719C8.26634 20.734 5.73368 20.734 4.17158 19.1719L3.82843 18.8288C2.26634 17.2667 2.26633 14.734 3.82843 13.1719L7.17158 9.8288C8.73368 8.2667 11.2663 8.2667 12.8284 9.8288L13.1716 10.1719C13.8252 10.8256 14.2053 11.6491 14.312 12.5004" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path><path d="M9.68799 12.5004C9.79463 13.3516 10.1748 14.1752 10.8284 14.8288L11.1715 15.1719C12.7336 16.734 15.2663 16.734 16.8284 15.1719L20.1715 11.8288C21.7336 10.2667 21.7336 7.73404 20.1715 6.17194L19.8284 5.8288C18.2663 4.2667 15.7336 4.2667 14.1715 5.8288L14 6.00037" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path></svg><h2 id="animations">Animations</h2></a>
<p>I believe Sonner took off immediately because of the stacking animation which was done by some companies before, but never open sourced.</p>
<p>This is what made people fall in love with this tiny component, it just felt right when you saw it animate. Here’s Theo’s reaction to it for example:</p>
<p><span><div><div><p>Theo’s reaction to Sonner’s animations.</p></div></div></span>
<span><div><div><p>Theo’s reaction to Sonner’s animations.</p></div></div></span></p><p>I knew I had to highlight this motion when introducing the library so I experimented with a few different announcement videos where the focus was on that stacking animation. Here’s what I ended up with back in 2023:</p>
<p><span><div><div><p>You can view the tweet <a href="https://x.com/emilkowalski/status/1628742238548250624" target="_blank">here</a>.</p></div></div></span>
<span><div><div><p>You can view the tweet <a href="https://x.com/emilkowalski/status/1628742238548250624" target="_blank">here</a>.</p></div></div></span></p><p>When it comes to the code, I initially used CSS keyframes for the animations, but they aren’t interruptible. Try quickly adding a few toasts below. As you add more toasts, the older ones jump into their new position instead of smoothly transitioning.</p>
<div><p>Notice how toasts jump into place when you add them quickly.</p></div>
<p>That’s one downside of keyframes: you can’t smoothly change the end position while the animation is running. CSS transitions, on the other hand, can be interrupted and retargeted, even before the first transition has finished, so I used them instead:</p>

<p>To mimic the enter keyframes, I use a <code>useEffect</code> hook to set <code>mounted</code> to <code>true</code> after the initial render. This makes the toast start at <code>translateY(100%)</code> and transition to <code>translateY(0)</code>. The styles are applied through data attributes.</p>
<div data-rehype-pretty-code-fragment=""><pre tabindex="0" data-language="jsx" data-theme="default"><code data-language="jsx" data-theme="default"><span data-line=""><span>React.</span><span>useEffect</span><span>(() </span><span>=&gt;</span><span> {</span></span>
<span data-line=""><span>  </span><span>setMounted</span><span>(</span><span>true</span><span>);</span></span>
<span data-line=""><span>}, []);</span></span>
<span data-line=""> </span>
<span data-line=""><span>//...</span></span>
<span data-line=""> </span>
<span data-line=""><span>&lt;</span><span>li</span><span> </span><span>data-mounted</span><span>=</span><span>{mounted}&gt;</span></span></code></pre></div>
<div data-rehype-pretty-code-fragment=""><pre tabindex="0" data-language="css" data-theme="default"><code data-language="css" data-theme="default"><span data-line=""><span>.sonner-toast</span><span> {</span></span>
<span data-line=""><span>  </span><span>transition</span><span>: transform </span><span>400</span><span>ms</span><span> </span><span>ease</span><span>;</span></span>
<span data-line=""><span>}</span></span>
<span data-line=""> </span>
<span data-line=""><span>[</span><span>data-mounted</span><span>=</span><span>&#34;true&#34;</span><span>] {</span></span>
<span data-line=""><span>  </span><span>transform</span><span>: </span><span>translateY</span><span>(</span><span>0</span><span>);</span></span>
<span data-line=""><span>}</span></span>
<span data-line=""> </span>
<span data-line=""><span>[</span><span>data-mounted</span><span>=</span><span>&#34;false&#34;</span><span>] {</span></span>
<span data-line=""><span>  </span><span>transform</span><span>: </span><span>translateY</span><span>(</span><span>100</span><span>%</span><span>);</span></span>
<span data-line=""><span>}</span></span></code></pre></div>
<p>This can now also be solved with the <code>@starting-style</code> CSS at-rule, which would make the implementation much simpler. I might update the code to use this soon.</p>
<a href="#stacking-toasts"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none"><path d="M10 19.0004L9.82843 19.1719C8.26634 20.734 5.73368 20.734 4.17158 19.1719L3.82843 18.8288C2.26634 17.2667 2.26633 14.734 3.82843 13.1719L7.17158 9.8288C8.73368 8.2667 11.2663 8.2667 12.8284 9.8288L13.1716 10.1719C13.8252 10.8256 14.2053 11.6491 14.312 12.5004" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path><path d="M9.68799 12.5004C9.79463 13.3516 10.1748 14.1752 10.8284 14.8288L11.1715 15.1719C12.7336 16.734 15.2663 16.734 16.8284 15.1719L20.1715 11.8288C21.7336 10.2667 21.7336 7.73404 20.1715 6.17194L19.8284 5.8288C18.2663 4.2667 15.7336 4.2667 14.1715 5.8288L14 6.00037" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path></svg><h2 id="stacking-toasts">Stacking toasts</h2></a>
<p>To create the stacking effect, I multiply the gap between toasts by the toast’s <code>index</code> to get the <code>y</code> position. Each toast uses <code>position: absolute</code> to simplify the stacking. I also scale them down by <code>0.05</code> * <code>index</code> to create a sense of depth.</p>
<p>Here’s the simplified CSS for it:</p>
<div data-rehype-pretty-code-fragment=""><pre tabindex="0" data-language="css" data-theme="default"><code data-language="css" data-theme="default"><span data-line=""><span>[</span><span>data-sonner-toast</span><span>][</span><span>data-expanded</span><span>=</span><span>&#34;false&#34;</span><span>][</span><span>data-front</span><span>=</span><span>&#34;false&#34;</span><span>] {</span></span>
<span data-line=""><span>  </span><span>--scale</span><span>: </span><span>var</span><span>(</span><span>--toasts-before</span><span>) * </span><span>0.05</span><span> + </span><span>1</span><span>;</span></span>
<span data-line=""><span>  </span><span>--y</span><span>: </span><span>translateY</span><span>(</span><span>calc</span><span>(</span><span>var</span><span>(</span><span>--lift-amount</span><span>) </span><span>*</span><span> </span><span>var</span><span>(</span><span>--toasts-before</span><span>)))</span></span>
<span data-line=""><span>    </span><span>scale</span><span>(</span><span>calc</span><span>((</span><span>-1</span><span> </span><span>*</span><span> </span><span>var</span><span>(</span><span>--toasts-before</span><span>) </span><span>*</span><span> </span><span>0.05</span><span>) + </span><span>1</span><span>));</span></span>
<span data-line=""><span>}</span></span></code></pre></div>
<p>This works great until you have toasts with different heights - they won’t stick out evenly. The fix is to make all the toasts the height of the toast in front when in stacked mode. Here’s how the toasts would look with different heights:</p>

<a href="#swiping"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none"><path d="M10 19.0004L9.82843 19.1719C8.26634 20.734 5.73368 20.734 4.17158 19.1719L3.82843 18.8288C2.26634 17.2667 2.26633 14.734 3.82843 13.1719L7.17158 9.8288C8.73368 8.2667 11.2663 8.2667 12.8284 9.8288L13.1716 10.1719C13.8252 10.8256 14.2053 11.6491 14.312 12.5004" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path><path d="M9.68799 12.5004C9.79463 13.3516 10.1748 14.1752 10.8284 14.8288L11.1715 15.1719C12.7336 16.734 15.2663 16.734 16.8284 15.1719L20.1715 11.8288C21.7336 10.2667 21.7336 7.73404 20.1715 6.17194L19.8284 5.8288C18.2663 4.2667 15.7336 4.2667 14.1715 5.8288L14 6.00037" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path></svg><h2 id="swiping">Swiping</h2></a>
<p>Another Sonner feature is the swipe gesture. This is especially useful on devices where people are already used to swiping to dismiss notifications.</p>
<div><div><p>You can also swipe on desktop.</p></div></div>
<p>The toasts can be swiped down to dismiss. That’s just a simple event listener on the toast which updates a variable responsible for the <code>translateY</code> value.</p>
<div data-rehype-pretty-code-fragment=""><pre tabindex="0" data-language="jsx" data-theme="default"><code data-language="jsx" data-theme="default"><span data-line=""><span>// This is a simplified version of the code</span></span>
<span data-line=""><span>const</span><span> </span><span>onMove</span><span> </span><span>=</span><span> (</span><span>event</span><span>) </span><span>=&gt;</span><span> {</span></span>
<span data-line=""><span>  </span><span>const</span><span> </span><span>yPosition</span><span> </span><span>=</span><span> event.clientY </span><span>-</span><span> pointerStartRef.current.y;</span></span>
<span data-line=""> </span>
<span data-line=""><span>  toastRef.current.style.</span><span>setProperty</span><span>(</span><span>&#34;--swipe-amount&#34;</span><span>, </span><span>`${</span><span>yPosition</span><span>}px`</span><span>);</span></span>
<span data-line=""><span>};</span></span></code></pre></div>
<p>The swipe is momentum-based, meaning you don’t have to drag the toast past a specific threshold to dismiss it. If the swipe is fast enough, the toast will still be removed even if the distance is short, because the velocity is high enough.</p>
<div><div><p>Notice how just a quick swipe is enough to dismiss the toast.</p></div></div>
<p>I check how much time has passed since the drag started and divide the absolute drag distance by the elapsed time to get the velocity. If the swipe amount is greater than the threshold or velocity is higher than in this case <code>0.11</code>, I remove the toast.</p>
<div data-rehype-pretty-code-fragment=""><pre tabindex="0" data-language="js" data-theme="default"><code data-language="js" data-theme="default"><span data-line=""><span>const</span><span> </span><span>timeTaken</span><span> </span><span>=</span><span> </span><span>new</span><span> </span><span>Date</span><span>().</span><span>getTime</span><span>() </span><span>-</span><span> dragStartTime.current.</span><span>getTime</span><span>();</span></span>
<span data-line=""><span>const</span><span> </span><span>velocity</span><span> </span><span>=</span><span> Math.</span><span>abs</span><span>(swipeAmount) </span><span>/</span><span> timeTaken;</span></span>
<span data-line=""> </span>
<span data-line=""><span>// 0.11 is just a number that I ended up on through simple trial and error</span></span>
<span data-line=""><span>if</span><span> (Math.</span><span>abs</span><span>(swipeAmount) </span><span>&gt;=</span><span> </span><span>SWIPE_THRESHOLD</span><span> </span><span>||</span><span> velocity </span><span>&gt;</span><span> </span><span>0.11</span><span>) {</span></span>
<span data-line=""><span>  </span><span>removeToast</span><span>(toast);</span></span>
<span data-line=""><span>}</span></span></code></pre></div>
<a href="#expanding-toasts"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none"><path d="M10 19.0004L9.82843 19.1719C8.26634 20.734 5.73368 20.734 4.17158 19.1719L3.82843 18.8288C2.26634 17.2667 2.26633 14.734 3.82843 13.1719L7.17158 9.8288C8.73368 8.2667 11.2663 8.2667 12.8284 9.8288L13.1716 10.1719C13.8252 10.8256 14.2053 11.6491 14.312 12.5004" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path><path d="M9.68799 12.5004C9.79463 13.3516 10.1748 14.1752 10.8284 14.8288L11.1715 15.1719C12.7336 16.734 15.2663 16.734 16.8284 15.1719L20.1715 11.8288C21.7336 10.2667 21.7336 7.73404 20.1715 6.17194L19.8284 5.8288C18.2663 4.2667 15.7336 4.2667 14.1715 5.8288L14 6.00037" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path></svg><h2 id="expanding-toasts">Expanding toasts</h2></a>
<p>When the toasts are in stacked mode, you can hover over the toast area to expand and see all the toasts:</p>

<p>I calculate each toast’s expanded position by adding the heights of all preceding toasts and the gap between them. This value becomes the new <code>translateY</code> value when the user hovers over the toast area.</p>
<div data-rehype-pretty-code-fragment=""><pre tabindex="0" data-language="jsx" data-theme="default"><code data-language="jsx" data-theme="default"><span data-line=""><span>const</span><span> </span><span>toastsHeightBefore</span><span> </span><span>=</span><span> React.</span><span>useMemo</span><span>(() </span><span>=&gt;</span><span> {</span></span>
<span data-line=""><span>  </span><span>return</span><span> heights.</span><span>reduce</span><span>((</span><span>prev</span><span>, </span><span>curr</span><span>, </span><span>reducerIndex</span><span>) </span><span>=&gt;</span><span> {</span></span>
<span data-line=""><span>    </span><span>// Calculate offset up until current toast</span></span>
<span data-line=""><span>    </span><span>if</span><span> (reducerIndex </span><span>&gt;=</span><span> heightIndex) {</span></span>
<span data-line=""><span>      </span><span>return</span><span> prev;</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""> </span>
<span data-line=""><span>    </span><span>return</span><span> prev </span><span>+</span><span> curr.height;</span></span>
<span data-line=""><span>  }, </span><span>0</span><span>);</span></span>
<span data-line=""><span>}, [heights, heightIndex]);</span></span>
<span data-line=""> </span>
<span data-line=""><span>// We then use this value as a CSS variable, &#34;--offset&#34;: ${offset}px</span></span>
<span data-line=""><span>const</span><span> </span><span>offset</span><span> </span><span>=</span><span> React.</span><span>useMemo</span><span>(</span></span>
<span data-line=""><span>  () </span><span>=&gt;</span><span> heightIndex </span><span>*</span><span> </span><span>GAP</span><span> </span><span>+</span><span> toastsHeightBefore,</span></span>
<span data-line=""><span>  [heightIndex, toastsHeightBefore],</span></span>
<span data-line=""><span>);</span></span></code></pre></div>
<p>You can also use this expanded mode as the default behavior if you want to ensure that all toasts are visible at all times. This can be enabled by simply adding the <code>expand</code> prop on the <code>&lt;Toaster /&gt;</code> component:</p>

<a href="#developer-experience"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none"><path d="M10 19.0004L9.82843 19.1719C8.26634 20.734 5.73368 20.734 4.17158 19.1719L3.82843 18.8288C2.26634 17.2667 2.26633 14.734 3.82843 13.1719L7.17158 9.8288C8.73368 8.2667 11.2663 8.2667 12.8284 9.8288L13.1716 10.1719C13.8252 10.8256 14.2053 11.6491 14.312 12.5004" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path><path d="M9.68799 12.5004C9.79463 13.3516 10.1748 14.1752 10.8284 14.8288L11.1715 15.1719C12.7336 16.734 15.2663 16.734 16.8284 15.1719L20.1715 11.8288C21.7336 10.2667 21.7336 7.73404 20.1715 6.17194L19.8284 5.8288C18.2663 4.2667 15.7336 4.2667 14.1715 5.8288L14 6.00037" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path></svg><h2 id="developer-experience">Developer experience</h2></a>
<p>This was also extremely important to get right. If the component is not easy to use, people will give up before they even try it. Developer experience is <em>key</em>.</p>
<p>That’s why I built a fully custom documentation site for Sonner, where you can find lots of interactive examples with code snippets that are ready to be used.</p>

<p>This lets people touch the product, play with it, get familiar with it, and understand how it works before they even use it in their own projects.</p>
<p>Good documentation and clear instructions can drastically lower the barrier to use <em>any</em> product, not just a component. I think it’s often overlooked and done as an afterthought when it shouldn’t be.</p>
<p>But let’s also cover the technical details of the developer experience.</p>
<p>To avoid using React’s Context, I manage the state via the <a href="https://javascriptpatterns.vercel.app/patterns/design-patterns/observer-pattern" target="_blank">Observer Pattern</a>. I subscribe to the observable object in the <code>&lt;Toaster /&gt;</code> component. Whenever the <code>toast()</code> function is called, the <code>&lt;Toaster /&gt;</code> component (the subscriber) is notified and updates its state. I can then render all the toasts using <code>Array.map()</code>.</p>
<div data-rehype-pretty-code-fragment=""><pre tabindex="0" data-language="jsx" data-theme="default"><code data-language="jsx" data-theme="default"><span data-line=""><span>function</span><span> </span><span>Toaster</span><span>() {</span></span>
<span data-line=""><span>  </span><span>const</span><span> [</span><span>toasts</span><span>, </span><span>setToasts</span><span>] </span><span>=</span><span> React.</span><span>useState</span><span>([]);</span></span>
<span data-line=""> </span>
<span data-line=""><span>  React.</span><span>useEffect</span><span>(() </span><span>=&gt;</span><span> {</span></span>
<span data-line=""><span>    </span><span>return</span><span> ToastState.</span><span>subscribe</span><span>((</span><span>toast</span><span>) </span><span>=&gt;</span><span> {</span></span>
<span data-line=""><span>      </span><span>setToasts</span><span>((</span><span>toasts</span><span>) </span><span>=&gt;</span><span> [</span><span>...</span><span>toasts, toast]);</span></span>
<span data-line=""><span>    });</span></span>
<span data-line=""><span>  }, []);</span></span>
<span data-line=""> </span>
<span data-line=""><span>  </span><span>// ...</span></span>
<span data-line=""> </span>
<span data-line=""><span>  </span><span>return</span><span> (</span></span>
<span data-line=""><span>    &lt;</span><span>ol</span><span>&gt;</span></span>
<span data-line=""><span>      {toasts.</span><span>map</span><span>((</span><span>toast</span><span>, </span><span>index</span><span>) </span><span>=&gt;</span><span> (</span></span>
<span data-line=""><span>        &lt;</span><span>Toast</span><span> </span><span>key</span><span>=</span><span>{toast.id} </span><span>toast</span><span>=</span><span>{toast} /&gt;</span></span>
<span data-line=""><span>      ))}</span></span>
<span data-line=""><span>    &lt;/</span><span>ol</span><span>&gt;</span></span>
<span data-line=""><span>  );</span></span>
<span data-line=""><span>}</span></span></code></pre></div>
<p>To create a new toast, I simply import <code>toast</code> and call it. There’s no need for hooks or context, just a straightforward function call that can be done from anywhere.</p>
<div data-rehype-pretty-code-fragment=""><pre tabindex="0" data-language="jsx" data-theme="default"><code data-language="jsx" data-theme="default"><span data-line=""><span>import</span><span> { toast } </span><span>from</span><span> </span><span>&#34;sonner&#34;</span><span>;</span></span>
<span data-line=""> </span>
<span data-line=""><span>// ...</span></span>
<span data-line=""> </span>
<span data-line=""><span>toast</span><span>(</span><span>&#34;My toast&#34;</span><span>);</span></span></code></pre></div>
<p>People often praise Sonner’s promise API. You simply pass in a promise, specify what the toast should say in all 3 states, <code>loading</code>, <code>success</code>, <code>error</code>, and that’s it. Most engineers find it pretty intuitive.</p>
<a href="https://x.com/theo/status/1812778167121354878" target="_blank"><div><p><img alt="Theo" loading="lazy" width="38" height="38" decoding="async" data-nimg="1" srcset="/_next/image?url=%2Fbuilding-a-toast-component%2Ftheo.jpg&amp;w=48&amp;q=75 1x, /_next/image?url=%2Fbuilding-a-toast-component%2Ftheo.jpg&amp;w=96&amp;q=75 2x" src="https://emilkowal.ski/_next/image?url=%2Fbuilding-a-toast-component%2Ftheo.jpg&amp;w=96&amp;q=75"/></p><p><span>Theo<!-- --> <svg viewBox="0 0 22 22" aria-label="Verified account" role="img"><path d="M20.396 11c-.018-.646-.215-1.275-.57-1.816-.354-.54-.852-.972-1.438-1.246.223-.607.27-1.264.14-1.897-.131-.634-.437-1.218-.882-1.687-.47-.445-1.053-.75-1.687-.882-.633-.13-1.29-.083-1.897.14-.273-.587-.704-1.086-1.245-1.44S11.647 1.62 11 1.604c-.646.017-1.273.213-1.813.568s-.969.854-1.24 1.44c-.608-.223-1.267-.272-1.902-.14-.635.13-1.22.436-1.69.882-.445.47-.749 1.055-.878 1.688-.13.633-.08 1.29.144 1.896-.587.274-1.087.705-1.443 1.245-.356.54-.555 1.17-.574 1.817.02.647.218 1.276.574 1.817.356.54.856.972 1.443 1.245-.224.606-.274 1.263-.144 1.896.13.634.433 1.218.877 1.688.47.443 1.054.747 1.687.878.633.132 1.29.084 1.897-.136.274.586.705 1.084 1.246 1.439.54.354 1.17.551 1.816.569.647-.016 1.276-.213 1.817-.567s.972-.854 1.245-1.44c.604.239 1.266.296 1.903.164.636-.132 1.22-.447 1.68-.907.46-.46.776-1.044.908-1.681s.075-1.299-.165-1.903c.586-.274 1.084-.705 1.439-1.246.354-.54.551-1.17.569-1.816zM9.662 14.85l-3.429-3.428 1.293-1.302 2.072 2.072 4.4-4.794 1.347 1.246z" fill="currentColor"></path></svg></span><span>@theo</span></p></div><p>Sonner is so cracked holy shit. The `toast.promise` API is SO good. Never had such good toast states with so little code. It’s like React Query for toasts and I didn’t know I needed it until now.</p><img alt="Theo&#39;s tweet" loading="lazy" width="3600" height="1264" decoding="async" data-nimg="1" srcset="/_next/image?url=%2Fbuilding-a-toast-component%2Ftheo-tweet.jpeg&amp;w=3840&amp;q=75 1x" src="https://emilkowal.ski/_next/image?url=%2Fbuilding-a-toast-component%2Ftheo-tweet.jpeg&amp;w=3840&amp;q=75"/><p><time datetime="2024-07-15T09:16:09.000Z">5:16 AM · Jul 15, 2024 · Twitter Web App</time></p></a>
<p>The API design is inspired by <a href="https://react-hot-toast.com/" target="_blank">react-hot-toast</a>. The state management is different, but the way you render the toasts is very similar to that library, because it’s simply very good. <a href="https://x.com/timolins" target="_blank">Timo</a> did a great job there.</p>
<a href="#the-big-little-details"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none"><path d="M10 19.0004L9.82843 19.1719C8.26634 20.734 5.73368 20.734 4.17158 19.1719L3.82843 18.8288C2.26634 17.2667 2.26633 14.734 3.82843 13.1719L7.17158 9.8288C8.73368 8.2667 11.2663 8.2667 12.8284 9.8288L13.1716 10.1719C13.8252 10.8256 14.2053 11.6491 14.312 12.5004" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path><path d="M9.68799 12.5004C9.79463 13.3516 10.1748 14.1752 10.8284 14.8288L11.1715 15.1719C12.7336 16.734 15.2663 16.734 16.8284 15.1719L20.1715 11.8288C21.7336 10.2667 21.7336 7.73404 20.1715 6.17194L19.8284 5.8288C18.2663 4.2667 15.7336 4.2667 14.1715 5.8288L14 6.00037" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path></svg><h2 id="the-big-little-details">The big little details</h2></a>
<p>Some smaller things, while smaller, and harder to notice, are still important. They are what makes Sonner feel the way it does. Here are a few of them.</p>
<p>By default the toast disappears after 4 seconds unless you hover over it. But what if a toast is triggered and the user switches to a different tab? 4 seconds would pass and the toast would never be seen.</p>
<p>That’s why there’s a <code>useIsDocumentHidden</code> hook that checks if the document (tab) is hidden and if so, it will pause the timer. A small detail, that improves the experience.</p>
<div><div><p>Notice how the toast doesn’t disappear when the tab is inactive.</p></div></div>
<p>The code for this is relatively simple and leverages the <code>document.hidden</code> property.</p>
<div data-rehype-pretty-code-fragment=""><pre tabindex="0" data-language="jsx" data-theme="default"><code data-language="jsx" data-theme="default"><span data-line=""><span>export</span><span> </span><span>const</span><span> </span><span>useIsDocumentHidden</span><span> </span><span>=</span><span> () </span><span>=&gt;</span><span> {</span></span>
<span data-line=""><span>  </span><span>const</span><span> [</span><span>isDocumentHidden</span><span>, </span><span>setIsDocumentHidden</span><span>] </span><span>=</span><span> React.</span><span>useState</span><span>(</span></span>
<span data-line=""><span>    document.hidden,</span></span>
<span data-line=""><span>  );</span></span>
<span data-line=""> </span>
<span data-line=""><span>  React.</span><span>useEffect</span><span>(() </span><span>=&gt;</span><span> {</span></span>
<span data-line=""><span>    </span><span>function</span><span> </span><span>handleVisibilityChange</span><span>() {</span></span>
<span data-line=""><span>      </span><span>setIsDocumentHidden</span><span>(document.hidden);</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""> </span>
<span data-line=""><span>    document.</span><span>addEventListener</span><span>(</span><span>&#34;visibilitychange&#34;</span><span>, handleVisibilityChange);</span></span>
<span data-line=""><span>    </span><span>return</span><span> () </span><span>=&gt;</span></span>
<span data-line=""><span>      document.</span><span>removeEventListener</span><span>(</span><span>&#34;visibilitychange&#34;</span><span>, handleVisibilityChange);</span></span>
<span data-line=""><span>  }, []);</span></span>
<span data-line=""> </span>
<span data-line=""><span>  </span><span>return</span><span> isDocumentHidden;</span></span>
<span data-line=""><span>};</span></span>
<span data-line=""> </span>
<span data-line=""><span>// ...</span></span>
<span data-line=""> </span>
<span data-line=""><span>const</span><span> </span><span>isDocumentHidden</span><span> </span><span>=</span><span> </span><span>useIsDocumentHidden</span><span>();</span></span>
<span data-line=""> </span>
<span data-line=""><span>if</span><span> (isDocumentHidden) {</span></span>
<span data-line=""><span>  </span><span>pauseTimer</span><span>();</span></span>
<span data-line=""><span>}</span></span></code></pre></div>
<p>It’s one of those things that unless you’ve implemented it yourself before, you probably won’t notice, and that’s okay, because it’s the expected behavior. An inactive tab is well... inactive, so it feels obvious that the toasts should freeze while the tab is not in use.</p>
<p>Another interesting one is maintaining correct hover state.</p>
<p>The hover state depends on whether you are hovering over one of the toasts, but there are also gaps between the toasts that don’t belong to any toast. Hovering over those areas would make the toasts lose their hover state.</p>
<p>To address this, I add an <code>:after</code> pseudo-element to fill these gaps to maintain a consistent hover state.</p>
<div><p>The dark bars show where the pseudo-elements are added to fill in the gaps.</p></div>
<p>Another one: What if, while dragging the toast, the pointer goes outside of it? The drag event would stop, because you are not hovering over the toast anymore. So the correct pointer capture needs to be maintained.</p>
<p>Once I start dragging, I set the toast to capture all future pointer events. This ensures that even if the mouse or our thumb moves outside the toast while dragging, the toast remains the target of the pointer events. As a result, dragging remains possible, even if the pointer is outside of the toast, leading to a better user experience.</p>
<div><div><p>Notice how the toast still responds to drag events even if the pointer is outside of it.</p></div></div>
<p>One thing that can also be seen on the video above is friction. Instead of just not allowing the toast to be dragged upwards, you can still drag it, but it will slow down and eventually stop. It’s nicer than just stopping the toast immediately.</p>
<p>Not all of these details are noticed by the user, but that’s okay. These details add up. Together, they create a component that feels just right.</p>
<a href="https://paulgraham.com/hp.html" target="_blank"><span><span>“</span><p>All those unseen details combine to produce something that’s just stunning,
like a thousand barely audible voices all singing in tune.</p><span>”</span></span><div><p><span>Paul Graham<span><span>, </span> <!-- -->Hackers and Painters</span></span></p></div></a>
<p>The less details users notice, the better. It means the experience is intuitive. They don’t have to think about how it work and can focus at the task at hand. They appreciate it more that way, even if only on a subconscious level.</p>
<a href="#why-is-sonner-successful?"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none"><path d="M10 19.0004L9.82843 19.1719C8.26634 20.734 5.73368 20.734 4.17158 19.1719L3.82843 18.8288C2.26634 17.2667 2.26633 14.734 3.82843 13.1719L7.17158 9.8288C8.73368 8.2667 11.2663 8.2667 12.8284 9.8288L13.1716 10.1719C13.8252 10.8256 14.2053 11.6491 14.312 12.5004" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path><path d="M9.68799 12.5004C9.79463 13.3516 10.1748 14.1752 10.8284 14.8288L11.1715 15.1719C12.7336 16.734 15.2663 16.734 16.8284 15.1719L20.1715 11.8288C21.7336 10.2667 21.7336 7.73404 20.1715 6.17194L19.8284 5.8288C18.2663 4.2667 15.7336 4.2667 14.1715 5.8288L14 6.00037" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path></svg><h2 id="why-is-sonner-successful?">Why is Sonner successful?</h2></a>
<p>There are two main reasons.</p>
<p>One is that the developer experience is good. No hooks, no context, you insert <code>&lt;Toaster /&gt;</code> once and you call <code>toast()</code> to create a toast. That’s it.</p>
<p>Two is that it looks good. It has nice defaults and good animations. This is the real differentiator. People simply like beautiful things. Beauty is generally underutilized in software so you can use it as leverage to stand out.</p>
<p>If you want to learn how to build components like Sonner, and make your work stand out as well, you can check out my animation course:</p>
<a href="https://animations.dev/" target="_blank"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M13.1161 5.36612C13.6043 4.87796 14.3957 4.87796 14.8839 5.36612L20.6339 11.1161C20.8683 11.3505 21 11.6685 21 12C21 12.3315 20.8683 12.6494 20.6339 12.8839L14.8839 18.6339C14.3957 19.122 13.6043 19.122 13.1161 18.6339C12.628 18.1457 12.628 17.3543 13.1161 16.8661L16.7322 13.25H4.25C3.55964 13.25 3 12.6903 3 12C3 11.3096 3.55964 10.75 4.25 10.75H16.7322L13.1161 7.13388C12.628 6.64573 12.628 5.85427 13.1161 5.36612Z" fill="currentColor"></path></svg>Check out animations.dev</a></div></div>
  </body>
</html>
