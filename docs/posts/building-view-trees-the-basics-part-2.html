<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.stanistan.com/writes/building-view-trees-in-go-part-2/">Original</a>
    <h1>Building view-trees: The basics [Part 2]</h1>
    
    <div id="readability-page-1" class="page"><section>
            <p>We laid our goals in the <a href="https://www.stanistan.com/writes/building-view-trees-in-go-part-1">part 1</a>.</p>
<hr/>

<pre data-lang="go"><code data-lang="go"><span>import </span><span>&#34;html/template&#34;
</span><span>
</span><span>type </span><span>RenderFunc </span><span>func</span><span>(r </span><span>Renderable</span><span>) (template.</span><span>HTML</span><span>, </span><span>error</span><span>)
</span><span>
</span><span>type </span><span>Renderable </span><span>interface </span><span>{
</span><span>    </span><span>Template</span><span>() (</span><span>*</span><span>template.</span><span>Template</span><span>, </span><span>error</span><span>)
</span><span>    </span><span>TemplateData</span><span>() (</span><span>any</span><span>, </span><span>error</span><span>)
</span><span>}
</span></code></pre>
<p>Let&#39;s start with interfaces and type definitions of the concepts:</p>
<ol>
<li>We want to be able to <code>Render</code> a <code>Renderable</code> struct into HTML,
this can fail.</li>
<li>We also want the Renderable thing to give us all of the information
it needs so we can render it. This can also fail.</li>
</ol>
<p>This interface is small, let&#39;s see how far we can push this.</p>
<h2 id="first-implementation">First Implementation</h2>
<pre data-lang="go"><code data-lang="go"><span>func </span><span>Render</span><span>(r </span><span>Renderable</span><span>) (template.</span><span>HTML</span><span>, </span><span>error</span><span>) {
</span><span>    </span><span>var </span><span>empty template.</span><span>HTML
</span><span>
</span><span>    tpl, err </span><span>:= </span><span>r.Template()
</span><span>    </span><span>if </span><span>err </span><span>!= </span><span>nil </span><span>{
</span><span>        </span><span>return </span><span>empty, err
</span><span>    }
</span><span>
</span><span>    data, err </span><span>:= </span><span>r.TemplateData()
</span><span>    </span><span>if </span><span>err </span><span>!= </span><span>nil </span><span>{
</span><span>        </span><span>return </span><span>empty, err
</span><span>    }
</span><span>
</span><span>    </span><span>var </span><span>bs bytes.</span><span>Buffer
</span><span>    </span><span>if </span><span>err </span><span>:= </span><span>tpl.Execute(</span><span>&amp;</span><span>bs, data); err </span><span>!= </span><span>nil </span><span>{
</span><span>        </span><span>return </span><span>empty, err
</span><span>    }
</span><span>
</span><span>    </span><span>return </span><span>template.HTML(bs.String()), </span><span>nil
</span><span>}
</span></code></pre>
<p>The implementation is small, too, but what good are components
if you can&#39;t compose them.</p>

<p>In order to bring the component into our tree composition view library,
we need to have <code>Renderable</code> objects have subtrees.</p>
<pre data-lang="go"><code data-lang="go"><span>_, _ </span><span>:= </span><span>Render(ContainerView{
</span><span>    Heading: ChildView1{},
</span><span>    Body:    ChildView2{},
</span><span>})
</span></code></pre>
<pre data-lang="mustache"><code data-lang="mustache"><span>&lt;</span><span>div</span><span>&gt;
</span><span>    &lt;</span><span>div </span><span>class=</span><span>&#34;heading&#34;</span><span>&gt;</span><span>{{ </span><span>slot </span><span>&#34;heading&#34; </span><span>}}</span><span>&lt;/</span><span>div</span><span>&gt;
</span><span>    &lt;</span><span>div </span><span>class=</span><span>&#34;body&#34;</span><span>&gt;</span><span>{{ </span><span>slot </span><span>&#34;body&#34; </span><span>}}</span><span>&lt;/</span><span>div</span><span>&gt;
</span><span>&lt;/</span><span>div</span><span>&gt;
</span></code></pre>
<h2 id="the-poc">The POC</h2>
<p>The basic idea is to leverage <code>template.FuncMap</code> to create a
<code>slot</code> function.</p>
<pre data-lang="go"><code data-lang="go"><span>func </span><span>(v </span><span>ContainerView</span><span>) </span><span>Template</span><span>() (</span><span>*</span><span>template.</span><span>Template</span><span>, </span><span>error</span><span>) {
</span><span>    </span><span>return </span><span>template.New(</span><span>&#34;containerView&#34;</span><span>).Funcs(template.FuncMap{
</span><span>        </span><span>&#34;slot&#34;</span><span>: </span><span>func</span><span>(name </span><span>string</span><span>) (template.</span><span>HTML</span><span>, </span><span>error</span><span>) {
</span><span>            </span><span>switch </span><span>name {
</span><span>            </span><span>case </span><span>&#34;heading&#34;</span><span>:
</span><span>                </span><span>return </span><span>Render(v.Heading)
</span><span>            </span><span>case </span><span>&#34;body&#34;</span><span>:
</span><span>                </span><span>return </span><span>Render(v.Body)
</span><span>            </span><span>default</span><span>:
</span><span>                </span><span>return </span><span>template.HTML(</span><span>&#34;&#34;</span><span>), </span><span>nil
</span><span>            }
</span><span>        },
</span><span>    }).Parse(</span><span>`&lt;div&gt;
</span><span>    &lt;div class=&#34;heading&#34;&gt;</span><span>{{ slot </span><span>&#34;heading&#34; </span><span>}}</span><span>&lt;/div&gt;
</span><span>    &lt;div class=&#34;body&#34;&gt;</span><span>{{ slot </span><span>&#34;body&#34; </span><span>}}</span><span>&lt;/div&gt;
</span><span>&lt;/div&gt;`</span><span>)
</span><span>}
</span></code></pre>
<h3 id="alternate-approach">Alternate approach</h3>
<p>Alternatively, we can directly inline the fields in the data so our template
looks more like this:</p>
<pre data-lang="mustache"><code data-lang="mustache"><span>&lt;</span><span>div </span><span>class=</span><span>&#34;heading&#34;</span><span>&gt;</span><span>{{ </span><span>render .Slots.Heading </span><span>}}</span><span>&lt;/</span><span>div</span><span>&gt;
</span></code></pre>
<h2 id="template-compilation">Template compilation</h2>
<p><em>Refactor 1</em>: Making it so that we can do pre-compilation of the template,
we can pre-parse it. The immediate issue is that we don&#39;t have slots,
and the slot func is necessary to compile the tempalte. We can stub that out:</p>
<pre data-lang="go"><code data-lang="go"><span>func </span><span>slotFuncStub</span><span>(name </span><span>string</span><span>) (template.</span><span>HTML</span><span>, </span><span>error</span><span>) {
</span><span>    </span><span>return </span><span>template.HTML(</span><span>&#34;&#34;</span><span>), </span><span>nil
</span><span>}
</span><span>
</span><span>func </span><span>mustParseTemplate</span><span>(name, contents </span><span>string</span><span>) </span><span>*</span><span>template.</span><span>Template </span><span>{
</span><span>    </span><span>return </span><span>template.Must(
</span><span>        template.New(name).
</span><span>        Funcs(template.FuncMap{</span><span>&#34;slot&#34;</span><span>: slotFuncStub}).
</span><span>        Parse(contents),
</span><span>    )
</span><span>}
</span><span>
</span><span>var </span><span>containerViewTpl </span><span>= </span><span>mustParseTemplate(</span><span>&#34;containerView&#34;</span><span>, </span><span>`&lt;div&gt;
</span><span>    &lt;div class=&#34;heading&#34;&gt;</span><span>{{ slot </span><span>&#34;heading&#34; </span><span>}}</span><span>&lt;/div&gt;
</span><span>    &lt;div class=&#34;body&#34;&gt;</span><span>{{ slot </span><span>&#34;body&#34; </span><span>}}</span><span>&lt;/div&gt;
</span><span>&lt;/div&gt;`</span><span>)
</span></code></pre>
<p>And then update our <code>Template()</code> function:</p>
<pre data-lang="go"><code data-lang="go"><span>containerViewTpl.Funcs(template.FuncMap{
</span><span>    </span><span>&#34;slot&#34;</span><span>: </span><span>func</span><span>(name </span><span>string</span><span>) (template.</span><span>HTML</span><span>, </span><span>error</span><span>) {
</span><span>        </span><span>switch </span><span>name {
</span><span>        </span><span>case </span><span>&#34;heading&#34;</span><span>:
</span><span>            </span><span>return </span><span>Render(v.Heading)
</span><span>        </span><span>case </span><span>&#34;body&#34;</span><span>:
</span><span>            </span><span>return </span><span>Render(v.Body)
</span><span>        </span><span>default</span><span>:
</span><span>            </span><span>return </span><span>template.HTML(</span><span>&#34;&#34;</span><span>), </span><span>nil
</span><span>        }
</span><span>    },
</span><span>})
</span></code></pre>
<p><em>Refactor 2:</em> We can clean up the real slot function so that it
is less brittle when views/slots are added and removed.</p>
<pre data-lang="go"><code data-lang="go"><span>func </span><span>tplWithRealSlotFunc</span><span>(
</span><span>    tpl </span><span>*</span><span>template.</span><span>Template</span><span>,
</span><span>    slots </span><span>map</span><span>[</span><span>string</span><span>]</span><span>Renderable</span><span>,
</span><span>) </span><span>*</span><span>template.</span><span>Template </span><span>{
</span><span>    </span><span>return </span><span>tpl.Funcs(template.FuncMap{
</span><span>        </span><span>&#34;slot&#34;</span><span>: </span><span>func</span><span>(name </span><span>string</span><span>) (template.</span><span>HTML</span><span>, </span><span>error</span><span>) {
</span><span>            slot, ok </span><span>:= </span><span>slots[name]
</span><span>            </span><span>if </span><span>ok {
</span><span>                </span><span>return </span><span>Render(slot)
</span><span>            }
</span><span>            </span><span>return </span><span>template.HTML(</span><span>&#34;&#34;</span><span>), </span><span>nil
</span><span>        },
</span><span>    })
</span><span>}
</span><span>
</span><span>// ... snip ...
</span><span>
</span><span>return </span><span>tplWithRealSlotFunc(containerViewTpl, </span><span>map</span><span>[</span><span>string</span><span>]</span><span>Renderable</span><span>{
</span><span>    </span><span>&#34;heading&#34;</span><span>: v.Heading,
</span><span>    </span><span>&#34;body&#34;</span><span>:    v.Body,
</span><span>}), </span><span>nil
</span></code></pre>
<p>At this point we&#39;ve extracted common implementation details but have
kept our main interface the same, which is cool! Our base renderer
doesn&#39;t need to know much about anything else, doesn&#39;t need to know
about slots, or funcs, or where templates come from.</p>
<h2 id="a-view">A <code>View{}</code></h2>
<p>This is generally all well and good, we might want to have
something produce a <code>Renderable</code> struct, in fact we might have a
struct that is represents a <code>Renderable</code> object, what if we could
capture the above pattern in a piece of data as well as behavior?</p>
<pre data-lang="go"><code data-lang="go"><span>type </span><span>View </span><span>struct </span><span>{
</span><span>    Tpl   </span><span>*</span><span>template.</span><span>Template
</span><span>    Slots </span><span>map</span><span>[</span><span>string</span><span>]</span><span>Renderable
</span><span>    Data  </span><span>any
</span><span>}
</span><span>
</span><span>func </span><span>(v </span><span>View</span><span>) </span><span>Template</span><span>() (</span><span>*</span><span>template.</span><span>Template</span><span>, </span><span>error</span><span>) {
</span><span>    </span><span>return </span><span>tplWithRealSlotFunc(v.Tpl, v.Slots), </span><span>nil
</span><span>}
</span><span>
</span><span>func </span><span>(v </span><span>View</span><span>) </span><span>TemplateData</span><span>() (</span><span>any</span><span>, </span><span>error</span><span>) {
</span><span>    </span><span>return </span><span>v.Data, </span><span>nil
</span><span>}
</span></code></pre>
<p>The container becomes representable in a different way and it
would have the equivalent outcome when rendered.</p>
<pre data-lang="go"><code data-lang="go"><span>View{
</span><span>  Tpl: containerViewTpl,
</span><span>  Slots: </span><span>map</span><span>[</span><span>string</span><span>]</span><span>Renderable</span><span>{
</span><span>    </span><span>&#34;heading&#34;</span><span>: ChildView1{},
</span><span>    </span><span>&#34;body&#34;</span><span>:    ChildView2{},
</span><span>  }
</span><span>}
</span></code></pre>
<p>But we still might want to have ContainerView be the thing we can
&#34;render&#34;, how would we do both?</p>
<pre data-lang="go"><code data-lang="go"><span>type </span><span>AsRenderable </span><span>interface </span><span>{
</span><span>    </span><span>func </span><span>Renderable</span><span>() (</span><span>Renderable</span><span>, </span><span>error</span><span>)
</span><span>}
</span><span>
</span><span>type </span><span>Slots </span><span>map</span><span>[</span><span>string</span><span>]</span><span>AsRenderable
</span></code></pre>
<p>And updating the <code>Render</code> function for the first time to take
<code>AsRenderable</code> instead gives us our first really big interface
change, but it unlocks something, too. A simpler way to build views:</p>
<pre data-lang="go"><code data-lang="go"><span>func </span><span>(v </span><span>ContainerView</span><span>) </span><span>Renderable</span><span>() (</span><span>Renderable</span><span>, </span><span>error</span><span>) {
</span><span>    </span><span>return </span><span>View{
</span><span>        Tpl:   containerViewTpl,
</span><span>        Slots: Slots{</span><span>&#34;heading&#34;</span><span>: v.Heading, </span><span>&#34;body&#34;</span><span>: v.Body},
</span><span>    ), </span><span>nil
</span><span>}
</span></code></pre>

        </section></div>
  </body>
</html>
