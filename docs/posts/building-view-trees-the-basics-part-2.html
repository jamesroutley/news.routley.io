<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.stanistan.com/writes/building-view-trees-in-go-part-2/">Original</a>
    <h1>Building view-trees: The basics [Part 2]</h1>
    
    <div id="readability-page-1" class="page"><article>
        
        <div>
            
    
    
    
    <p><a href="https://raw.githubusercontent.com/stanistan/stanistan.github.io/the-details/content/writes/building-view-trees-in-go-part-2.md">.md</a>
 |
            <a href="https://www.stanistan.com/writes/building-view-trees-in-go-part-2/">permalink</a>
            
            | Published on December 04, 2023
            
        </p></div>

        

        

        <section>
            <p>We laid our goals in the <a href="https://tsdiagram.com/writes/building-view-trees-in-go-part-1">part 1</a>.</p>
<hr/>

<pre data-lang="go"><code data-lang="go"><span>import </span><span>&#34;html/template&#34;
</span><span>
</span><span>type </span><span>RenderFunc </span><span>func</span><span>(r </span><span>Renderable</span><span>) (template.</span><span>HTML</span><span>, </span><span>error</span><span>)
</span><span>
</span><span>type </span><span>Renderable </span><span>interface </span><span>{
</span><span>    </span><span>Template</span><span>() (</span><span>*</span><span>template.</span><span>Template</span><span>, </span><span>error</span><span>)
</span><span>    </span><span>TemplateData</span><span>() (</span><span>any</span><span>, </span><span>error</span><span>)
</span><span>}
</span></code></pre>
<p>Let&#39;s start with interfaces and type definitions of the concepts:</p>
<ol>
<li>We want to be able to <code>Render</code> a <code>Renderable</code> struct into HTML,
this can fail.</li>
<li>We also want the Renderable thing to give us all of the information
it needs so we can render it. This can also fail.</li>
</ol>
<p>This interface is small, let&#39;s see how far we can push this.</p>
<h2 id="first-implementation">First Implementation</h2>
<pre data-lang="go"><code data-lang="go"><span>func </span><span>Render</span><span>(r </span><span>Renderable</span><span>) (template.</span><span>HTML</span><span>, </span><span>error</span><span>) {
</span><span>    </span><span>var </span><span>empty template.</span><span>HTML
</span><span>
</span><span>    tpl, err </span><span>:= </span><span>r.Template()
</span><span>    </span><span>if </span><span>err </span><span>!= </span><span>nil </span><span>{
</span><span>        </span><span>return </span><span>empty, err
</span><span>    }
</span><span>
</span><span>    data, err </span><span>:= </span><span>r.TemplateData()
</span><span>    </span><span>if </span><span>err </span><span>!= </span><span>nil </span><span>{
</span><span>        </span><span>return </span><span>empty, err
</span><span>    }
</span><span>
</span><span>    </span><span>var </span><span>bs bytes.</span><span>Buffer
</span><span>    </span><span>if </span><span>err </span><span>:= </span><span>tpl.Execute(</span><span>&amp;</span><span>bs, data); err </span><span>!= </span><span>nil </span><span>{
</span><span>        </span><span>return </span><span>empty, err
</span><span>    }
</span><span>
</span><span>    </span><span>return </span><span>template.HTML(bs.String()), </span><span>nil
</span><span>}
</span></code></pre>
<p>The implementation is small, too, but what good are components
if you can&#39;t compose them.</p>
<h3 id="patches">Patches</h3>




<details>
<summary>Initial implementation</summary>

<pre data-lang="patch"><code data-lang="patch"><span>90edfc07f2585860932c24a2619b3977c933fd6a Initial Renderer implementation
</span><span>diff --git a/renderer.go b/renderer.go
</span><span>new file mode 100644
</span><span>index 0000000..c96d89d
</span><span>---</span><span> /dev/null
</span><span>+++</span><span> b/renderer.go
</span><span>@@ -0,0 +1,39 @@
</span><span>+</span><span>package veun
</span><span>+
</span><span>+</span><span>import (
</span><span>+</span><span>	&#34;bytes&#34;
</span><span>+</span><span>	&#34;fmt&#34;
</span><span>+</span><span>	&#34;html/template&#34;
</span><span>+</span><span>)
</span><span>+
</span><span>+</span><span>type RenderFunc func(r Renderable) (template.HTML, error)
</span><span>+
</span><span>+</span><span>type Renderable interface {
</span><span>+</span><span>	Template() (*template.Template, error)
</span><span>+</span><span>	TemplateData() (any, error)
</span><span>+</span><span>}
</span><span>+
</span><span>+</span><span>func Render(r Renderable) (template.HTML, error) {
</span><span>+</span><span>	var empty template.HTML
</span><span>+
</span><span>+</span><span>	tpl, err := r.Template()
</span><span>+</span><span>	if err != nil {
</span><span>+</span><span>		return empty, err
</span><span>+</span><span>	}
</span><span>+
</span><span>+</span><span>	if tpl == nil {
</span><span>+</span><span>		return empty, fmt.Errorf(&#34;missing template&#34;)
</span><span>+</span><span>	}
</span><span>+
</span><span>+</span><span>	data, err := r.TemplateData()
</span><span>+</span><span>	if err != nil {
</span><span>+</span><span>		return empty, err
</span><span>+</span><span>	}
</span><span>+
</span><span>+</span><span>	var bs bytes.Buffer
</span><span>+</span><span>	if err := tpl.Execute(&amp;bs, data); err != nil {
</span><span>+</span><span>		return empty, err
</span><span>+</span><span>	}
</span><span>+
</span><span>+</span><span>	return template.HTML(bs.String()), nil
</span><span>+</span><span>}
</span><span>
</span></code></pre>


</details>




<details>
<summary>Testing rendering Person()</summary>

<pre data-lang="patch"><code data-lang="patch"><span>23ca88bbcdc25dce2036dec8295720abc26e6cec Initial test for rendering PersonView(Person...)
</span><span>diff --git a/go.mod b/go.mod
</span><span>index 09551ac..ec2216f 100644
</span><span>---</span><span> a/go.mod
</span><span>+++</span><span> b/go.mod
</span><span>@@ -1,3 +1,9 @@
</span><span> module github.com/stanistan/veun
</span><span> 
</span><span> go 1.21.4
</span><span>+
</span><span>+</span><span>require (
</span><span>+</span><span>	github.com/alecthomas/assert/v2 v2.4.0 // indirect
</span><span>+</span><span>	github.com/alecthomas/repr v0.3.0 // indirect
</span><span>+</span><span>	github.com/hexops/gotextdiff v1.0.3 // indirect
</span><span>+</span><span>)
</span><span>diff --git a/go.sum b/go.sum
</span><span>new file mode 100644
</span><span>index 0000000..bb218ed
</span><span>---</span><span> /dev/null
</span><span>+++</span><span> b/go.sum
</span><span>@@ -0,0 +1,6 @@
</span><span>+</span><span>github.com/alecthomas/assert/v2 v2.4.0 h1:/ZiZ0NnriAWPYYO+4eOjgzNELrFQLaHNr92mHSHFj9U=
</span><span>+</span><span>github.com/alecthomas/assert/v2 v2.4.0/go.mod h1:fw5suVxB+wfYJ3291t0hRTqtGzFYdSwstnRQdaQx2DM=
</span><span>+</span><span>github.com/alecthomas/repr v0.3.0 h1:NeYzUPfjjlqHY4KtzgKJiWd6sVq2eNUPTi34PiFGjY8=
</span><span>+</span><span>github.com/alecthomas/repr v0.3.0/go.mod h1:Fr0507jx4eOXV7AlPV6AVZLYrLIuIeSOWtW57eE/O/4=
</span><span>+</span><span>github.com/hexops/gotextdiff v1.0.3 h1:gitA9+qJrrTCsiCl7+kh75nPqQt1cx4ZkudSTLoUqJM=
</span><span>+</span><span>github.com/hexops/gotextdiff v1.0.3/go.mod h1:pSWU5MAI3yDq+fZBTazCSJysOMbxWL1BSow5/V2vxeg=
</span><span>diff --git a/render_person_test.go b/render_person_test.go
</span><span>new file mode 100644
</span><span>index 0000000..64a542b
</span><span>---</span><span> /dev/null
</span><span>+++</span><span> b/render_person_test.go
</span><span>@@ -0,0 +1,41 @@
</span><span>+</span><span>package veun_test
</span><span>+
</span><span>+</span><span>import (
</span><span>+</span><span>	&#34;html/template&#34;
</span><span>+</span><span>	&#34;testing&#34;
</span><span>+
</span><span>+</span><span>	&#34;github.com/alecthomas/assert/v2&#34;
</span><span>+</span><span>	&#34;github.com/stanistan/veun&#34;
</span><span>+</span><span>)
</span><span>+
</span><span>+</span><span>type Person struct {
</span><span>+</span><span>	Name string
</span><span>+</span><span>}
</span><span>+
</span><span>+</span><span>type personView struct {
</span><span>+</span><span>	Person Person
</span><span>+</span><span>}
</span><span>+
</span><span>+</span><span>func PersonView(person Person) *personView {
</span><span>+</span><span>	return &amp;personView{Person: person}
</span><span>+</span><span>}
</span><span>+
</span><span>+</span><span>var _ veun.Renderable = &amp;personView{}
</span><span>+
</span><span>+</span><span>var personViewTpl = template.Must(
</span><span>+</span><span>	template.New(&#34;PersonView&#34;).Parse(`&lt;div&gt;Hi, {{ .Name }}.&lt;/div&gt;`),
</span><span>+</span><span>)
</span><span>+
</span><span>+</span><span>func (v *personView) Template() (*template.Template, error) {
</span><span>+</span><span>	return personViewTpl, nil
</span><span>+</span><span>}
</span><span>+
</span><span>+</span><span>func (v *personView) TemplateData() (any, error) {
</span><span>+</span><span>	return v.Person, nil
</span><span>+</span><span>}
</span><span>+
</span><span>+</span><span>func TestRenderPerson(t *testing.T) {
</span><span>+</span><span>	html, err := veun.Render(PersonView(Person{Name: &#34;Stan&#34;}))
</span><span>+</span><span>	assert.NoError(t, err)
</span><span>+</span><span>	assert.Equal(t, html, template.HTML(`&lt;div&gt;Hi, Stan.&lt;/div&gt;`))
</span><span>+</span><span>}
</span><span>
</span></code></pre>


</details>

<p>In order to bring the component into our tree composition view library,
we need to have <code>Renderable</code> objects have subtrees.</p>
<pre data-lang="go"><code data-lang="go"><span>_, _ </span><span>:= </span><span>Render(ContainerView{
</span><span>    Heading: ChildView1{},
</span><span>    Body:    ChildView2{},
</span><span>})
</span></code></pre>
<pre data-lang="mustache"><code data-lang="mustache"><span>&lt;</span><span>div</span><span>&gt;
</span><span>    &lt;</span><span>div </span><span>class=</span><span>&#34;heading&#34;</span><span>&gt;</span><span>{{ </span><span>slot </span><span>&#34;heading&#34; </span><span>}}</span><span>&lt;/</span><span>div</span><span>&gt;
</span><span>    &lt;</span><span>div </span><span>class=</span><span>&#34;body&#34;</span><span>&gt;</span><span>{{ </span><span>slot </span><span>&#34;body&#34; </span><span>}}</span><span>&lt;/</span><span>div</span><span>&gt;
</span><span>&lt;/</span><span>div</span><span>&gt;
</span></code></pre>
<h2 id="the-poc">The POC</h2>
<p>The basic idea is to leverage <code>template.FuncMap</code> to create a
<code>slot</code> function.</p>
<pre data-lang="go"><code data-lang="go"><span>func </span><span>(v </span><span>ContainerView</span><span>) </span><span>Template</span><span>() (</span><span>*</span><span>template.</span><span>Template</span><span>, </span><span>error</span><span>) {
</span><span>    </span><span>return </span><span>template.New(</span><span>&#34;containerView&#34;</span><span>).Funcs(template.FuncMap{
</span><span>        </span><span>&#34;slot&#34;</span><span>: </span><span>func</span><span>(name </span><span>string</span><span>) (template.</span><span>HTML</span><span>, </span><span>error</span><span>) {
</span><span>            </span><span>switch </span><span>name {
</span><span>            </span><span>case </span><span>&#34;heading&#34;</span><span>:
</span><span>                </span><span>return </span><span>Render(v.Heading)
</span><span>            </span><span>case </span><span>&#34;body&#34;</span><span>:
</span><span>                </span><span>return </span><span>Render(v.Body)
</span><span>            </span><span>default</span><span>:
</span><span>                </span><span>return </span><span>template.HTML(</span><span>&#34;&#34;</span><span>), </span><span>nil
</span><span>            }
</span><span>        },
</span><span>    }).Parse(</span><span>`&lt;div&gt;
</span><span>    &lt;div class=&#34;heading&#34;&gt;</span><span>{{ slot </span><span>&#34;heading&#34; </span><span>}}</span><span>&lt;/div&gt;
</span><span>    &lt;div class=&#34;body&#34;&gt;</span><span>{{ slot </span><span>&#34;body&#34; </span><span>}}</span><span>&lt;/div&gt;
</span><span>&lt;/div&gt;`</span><span>)
</span><span>}
</span></code></pre>




<details>
<summary>POC implementation and tests</summary>

<pre data-lang="patch"><code data-lang="patch"><span>40fb4895f4da3511b61334414de612417cd2932f test for v1 of composition
</span><span>diff --git a/render_container_test.go b/render_container_test.go
</span><span>new file mode 100644
</span><span>index 0000000..951acb3
</span><span>---</span><span> /dev/null
</span><span>+++</span><span> b/render_container_test.go
</span><span>@@ -0,0 +1,73 @@
</span><span>+</span><span>package veun_test
</span><span>+
</span><span>+</span><span>import (
</span><span>+</span><span>	&#34;html/template&#34;
</span><span>+</span><span>	&#34;testing&#34;
</span><span>+
</span><span>+</span><span>	&#34;github.com/alecthomas/assert/v2&#34;
</span><span>+
</span><span>+</span><span>	. &#34;github.com/stanistan/veun&#34;
</span><span>+</span><span>)
</span><span>+
</span><span>+</span><span>type ContainerView struct {
</span><span>+</span><span>	Heading Renderable
</span><span>+</span><span>	Body    Renderable
</span><span>+</span><span>}
</span><span>+
</span><span>+</span><span>func (v ContainerView) Template() (*template.Template, error) {
</span><span>+</span><span>	return template.New(&#34;containerView&#34;).Funcs(template.FuncMap{
</span><span>+</span><span>		&#34;slot&#34;: func(name string) (template.HTML, error) {
</span><span>+</span><span>			switch name {
</span><span>+</span><span>			case &#34;heading&#34;:
</span><span>+</span><span>				return Render(v.Heading)
</span><span>+</span><span>			case &#34;body&#34;:
</span><span>+</span><span>				return Render(v.Body)
</span><span>+</span><span>			default:
</span><span>+</span><span>				return template.HTML(&#34;&#34;), nil
</span><span>+</span><span>			}
</span><span>+</span><span>		},
</span><span>+</span><span>	}).Parse(`&lt;div&gt;
</span><span>+</span><span>	&lt;div class=&#34;heading&#34;&gt;{{ slot &#34;heading&#34; }}&lt;/div&gt;
</span><span>+</span><span>	&lt;div class=&#34;body&#34;&gt;{{ slot &#34;body&#34; }}&lt;/div&gt;
</span><span>+</span><span>&lt;/div&gt;`)
</span><span>+</span><span>}
</span><span>+
</span><span>+</span><span>func (v ContainerView) TemplateData() (any, error) {
</span><span>+</span><span>	return nil, nil
</span><span>+</span><span>}
</span><span>+
</span><span>+</span><span>var childViewTemplate = template.Must(
</span><span>+</span><span>	template.New(&#34;childView&#34;).Parse(`{{ . }}`),
</span><span>+</span><span>)
</span><span>+
</span><span>+</span><span>type ChildView1 struct{}
</span><span>+
</span><span>+</span><span>func (v ChildView1) Template() (*template.Template, error) {
</span><span>+</span><span>	return childViewTemplate, nil
</span><span>+</span><span>}
</span><span>+
</span><span>+</span><span>func (v ChildView1) TemplateData() (any, error) {
</span><span>+</span><span>	return &#34;HEADING&#34;, nil
</span><span>+</span><span>}
</span><span>+
</span><span>+</span><span>type ChildView2 struct{}
</span><span>+
</span><span>+</span><span>func (v ChildView2) Template() (*template.Template, error) {
</span><span>+</span><span>	return childViewTemplate, nil
</span><span>+</span><span>}
</span><span>+
</span><span>+</span><span>func (v ChildView2) TemplateData() (any, error) {
</span><span>+</span><span>	return &#34;BODY&#34;, nil
</span><span>+</span><span>}
</span><span>+
</span><span>+</span><span>func TestRenderContainer(t *testing.T) {
</span><span>+</span><span>	html, err := Render(&amp;ContainerView{
</span><span>+</span><span>		Heading: ChildView1{},
</span><span>+</span><span>		Body:    ChildView2{},
</span><span>+</span><span>	})
</span><span>+</span><span>	assert.NoError(t, err)
</span><span>+</span><span>	assert.Equal(t, template.HTML(`&lt;div&gt;
</span><span>+</span><span>	&lt;div class=&#34;heading&#34;&gt;HEADING&lt;/div&gt;
</span><span>+</span><span>	&lt;div class=&#34;body&#34;&gt;BODY&lt;/div&gt;
</span><span>+</span><span>&lt;/div&gt;`), html)
</span><span>+</span><span>}
</span><span>
</span></code></pre>


</details>
<h3 id="alternate-approach">Alternate approach</h3>
<p>Alternatively, we can directly inline the fields in the data so our template
looks more like this:</p>
<pre data-lang="mustache"><code data-lang="mustache"><span>&lt;</span><span>div </span><span>class=</span><span>&#34;heading&#34;</span><span>&gt;</span><span>{{ </span><span>render .Slots.Heading </span><span>}}</span><span>&lt;/</span><span>div</span><span>&gt;
</span></code></pre>
<h2 id="template-compilation">Template compilation</h2>
<p><em>Refactor 1</em>: Making it so that we can do pre-compilation of the template,
we can pre-parse it. The immediate issue is that we don&#39;t have slots,
and the slot func is necessary to compile the tempalte. We can stub that out:</p>
<pre data-lang="go"><code data-lang="go"><span>func </span><span>slotFuncStub</span><span>(name </span><span>string</span><span>) (template.</span><span>HTML</span><span>, </span><span>error</span><span>) {
</span><span>    </span><span>return </span><span>template.HTML(</span><span>&#34;&#34;</span><span>), </span><span>nil
</span><span>}
</span><span>
</span><span>func </span><span>mustParseTemplate</span><span>(name, contents </span><span>string</span><span>) </span><span>*</span><span>template.</span><span>Template </span><span>{
</span><span>    </span><span>return </span><span>template.Must(
</span><span>        template.New(name).
</span><span>        Funcs(template.FuncMap{</span><span>&#34;slot&#34;</span><span>: slotFuncStub}).
</span><span>        Parse(contents),
</span><span>    )
</span><span>}
</span><span>
</span><span>var </span><span>containerViewTpl </span><span>= </span><span>mustParseTemplate(</span><span>&#34;containerView&#34;</span><span>, </span><span>`&lt;div&gt;
</span><span>    &lt;div class=&#34;heading&#34;&gt;</span><span>{{ slot </span><span>&#34;heading&#34; </span><span>}}</span><span>&lt;/div&gt;
</span><span>    &lt;div class=&#34;body&#34;&gt;</span><span>{{ slot </span><span>&#34;body&#34; </span><span>}}</span><span>&lt;/div&gt;
</span><span>&lt;/div&gt;`</span><span>)
</span></code></pre>
<p>And then update our <code>Template()</code> function:</p>
<pre data-lang="go"><code data-lang="go"><span>containerViewTpl.Funcs(template.FuncMap{
</span><span>    </span><span>&#34;slot&#34;</span><span>: </span><span>func</span><span>(name </span><span>string</span><span>) (template.</span><span>HTML</span><span>, </span><span>error</span><span>) {
</span><span>        </span><span>switch </span><span>name {
</span><span>        </span><span>case </span><span>&#34;heading&#34;</span><span>:
</span><span>            </span><span>return </span><span>Render(v.Heading)
</span><span>        </span><span>case </span><span>&#34;body&#34;</span><span>:
</span><span>            </span><span>return </span><span>Render(v.Body)
</span><span>        </span><span>default</span><span>:
</span><span>            </span><span>return </span><span>template.HTML(</span><span>&#34;&#34;</span><span>), </span><span>nil
</span><span>        }
</span><span>    },
</span><span>})
</span></code></pre>




<details>
<summary>implementing this refactor</summary>

<pre data-lang="patch"><code data-lang="patch"><span>48ddc3cce42cbb9337027a7f1df7fd241217ca85 After refactor (1)
</span><span>diff --git a/render_container_test.go b/render_container_test.go
</span><span>index 951acb3..526d1b8 100644
</span><span>---</span><span> a/render_container_test.go
</span><span>+++</span><span> b/render_container_test.go
</span><span>@@ -9,13 +9,30 @@ import (
</span><span> 	. &#34;github.com/stanistan/veun&#34;
</span><span> )
</span><span> 
</span><span>+</span><span>func slotFuncStub(name string) (template.HTML, error) {
</span><span>+</span><span>	return template.HTML(&#34;&#34;), nil
</span><span>+</span><span>}
</span><span>+
</span><span> type ContainerView struct {
</span><span> 	Heading Renderable
</span><span> 	Body    Renderable
</span><span> }
</span><span> 
</span><span>+</span><span>func mustParseTemplate(name, contents string) *template.Template {
</span><span>+</span><span>	return template.Must(
</span><span>+</span><span>		template.New(name).
</span><span>+</span><span>			Funcs(template.FuncMap{&#34;slot&#34;: slotFuncStub}).
</span><span>+</span><span>			Parse(contents),
</span><span>+</span><span>	)
</span><span>+</span><span>}
</span><span>+
</span><span>+</span><span>var containerViewTpl = mustParseTemplate(&#34;containerView&#34;, `&lt;div&gt;
</span><span>+</span><span>	&lt;div class=&#34;heading&#34;&gt;{{ slot &#34;heading&#34; }}&lt;/div&gt;
</span><span>+</span><span>	&lt;div class=&#34;body&#34;&gt;{{ slot &#34;body&#34; }}&lt;/div&gt;
</span><span>+</span><span>&lt;/div&gt;`)
</span><span>+
</span><span> func (v ContainerView) Template() (*template.Template, error) {
</span><span>-	return template.New(&#34;containerView&#34;).Funcs(template.FuncMap{
</span><span>+</span><span>	return containerViewTpl.Funcs(template.FuncMap{
</span><span> 		&#34;slot&#34;: func(name string) (template.HTML, error) {
</span><span> 			switch name {
</span><span> 			case &#34;heading&#34;:
</span><span>@@ -26,10 +43,7 @@ func (v ContainerView) Template() (*template.Template, error) {
</span><span> 				return template.HTML(&#34;&#34;), nil
</span><span> 			}
</span><span> 		},
</span><span>-	}).Parse(`&lt;div&gt;
</span><span>-	&lt;div class=&#34;heading&#34;&gt;{{ slot &#34;heading&#34; }}&lt;/div&gt;
</span><span>-	&lt;div class=&#34;body&#34;&gt;{{ slot &#34;body&#34; }}&lt;/div&gt;
</span><span>-&lt;/div&gt;`)
</span><span>+</span><span>	}), nil
</span><span> }
</span><span> 
</span><span> func (v ContainerView) TemplateData() (any, error) {
</span><span>
</span></code></pre>


</details>
<p><em>Refactor 2:</em> We can clean up the real slot function so that it
is less brittle when views/slots are added and removed.</p>
<pre data-lang="go"><code data-lang="go"><span>func </span><span>tplWithRealSlotFunc</span><span>(
</span><span>    tpl </span><span>*</span><span>template.</span><span>Template</span><span>,
</span><span>    slots </span><span>map</span><span>[</span><span>string</span><span>]</span><span>Renderable</span><span>,
</span><span>) </span><span>*</span><span>template.</span><span>Template </span><span>{
</span><span>    </span><span>return </span><span>tpl.Funcs(template.FuncMap{
</span><span>        </span><span>&#34;slot&#34;</span><span>: </span><span>func</span><span>(name </span><span>string</span><span>) (template.</span><span>HTML</span><span>, </span><span>error</span><span>) {
</span><span>            slot, ok </span><span>:= </span><span>slots[name]
</span><span>            </span><span>if </span><span>ok {
</span><span>                </span><span>return </span><span>Render(slot)
</span><span>            }
</span><span>            </span><span>return </span><span>template.HTML(</span><span>&#34;&#34;</span><span>), </span><span>nil
</span><span>        },
</span><span>    })
</span><span>}
</span><span>
</span><span>// ... snip ...
</span><span>
</span><span>return </span><span>tplWithRealSlotFunc(containerViewTpl, </span><span>map</span><span>[</span><span>string</span><span>]</span><span>Renderable</span><span>{
</span><span>    </span><span>&#34;heading&#34;</span><span>: v.Heading,
</span><span>    </span><span>&#34;body&#34;</span><span>:    v.Body,
</span><span>}), </span><span>nil
</span></code></pre>
<p>At this point we&#39;ve extracted common implementation details but have
kept our main interface the same, which is cool! Our base renderer
doesn&#39;t need to know much about anything else, doesn&#39;t need to know
about slots, or funcs, or where templates come from.</p>




<details>
<summary>Patch implementing this slot refactor</summary>

<pre data-lang="patch"><code data-lang="patch"><span>510eb19285474bc41c882a6a4ef9941e9070539c after refactor (2)
</span><span>diff --git a/render_container_test.go b/render_container_test.go
</span><span>index 526d1b8..c372d45 100644
</span><span>---</span><span> a/render_container_test.go
</span><span>+++</span><span> b/render_container_test.go
</span><span>@@ -31,18 +31,22 @@ var containerViewTpl = mustParseTemplate(&#34;containerView&#34;, `&lt;div&gt;
</span><span> 	&lt;div class=&#34;body&#34;&gt;{{ slot &#34;body&#34; }}&lt;/div&gt;
</span><span> &lt;/div&gt;`)
</span><span> 
</span><span>-func (v ContainerView) Template() (*template.Template, error) {
</span><span>-	return containerViewTpl.Funcs(template.FuncMap{
</span><span>+</span><span>func tplWithRealSlotFunc(tpl *template.Template, slots map[string]Renderable) *template.Template {
</span><span>+</span><span>	return tpl.Funcs(template.FuncMap{
</span><span> 		&#34;slot&#34;: func(name string) (template.HTML, error) {
</span><span>-			switch name {
</span><span>-			case &#34;heading&#34;:
</span><span>-				return Render(v.Heading)
</span><span>-			case &#34;body&#34;:
</span><span>-				return Render(v.Body)
</span><span>-			default:
</span><span>-				return template.HTML(&#34;&#34;), nil
</span><span>+</span><span>			slot, ok := slots[name]
</span><span>+</span><span>			if ok {
</span><span>+</span><span>				return Render(slot)
</span><span> 			}
</span><span>+</span><span>			return template.HTML(&#34;&#34;), nil
</span><span> 		},
</span><span>+</span><span>	})
</span><span>+</span><span>}
</span><span>+
</span><span>+</span><span>func (v ContainerView) Template() (*template.Template, error) {
</span><span>+</span><span>	return tplWithRealSlotFunc(containerViewTpl, map[string]Renderable{
</span><span>+</span><span>		&#34;heading&#34;: v.Heading,
</span><span>+</span><span>		&#34;body&#34;:    v.Body,
</span><span> 	}), nil
</span><span> }
</span><span> 
</span><span>
</span></code></pre>


</details>
<h2 id="a-view">A <code>View{}</code></h2>
<p>This is generally all well and good, we might want to have
something produce a <code>Renderable</code> struct, in fact we might have a
struct that is represents a <code>Renderable</code> object, what if we could
capture the above pattern in a piece of data as well as behavior?</p>
<pre data-lang="go"><code data-lang="go"><span>type </span><span>View </span><span>struct </span><span>{
</span><span>    Tpl   </span><span>*</span><span>template.</span><span>Template
</span><span>    Slots </span><span>map</span><span>[</span><span>string</span><span>]</span><span>Renderable
</span><span>    Data  </span><span>any
</span><span>}
</span><span>
</span><span>func </span><span>(v </span><span>View</span><span>) </span><span>Template</span><span>() (</span><span>*</span><span>template.</span><span>Template</span><span>, </span><span>error</span><span>) {
</span><span>    </span><span>return </span><span>tplWithRealSlotFunc(v.Tpl, v.Slots), </span><span>nil
</span><span>}
</span><span>
</span><span>func </span><span>(v </span><span>View</span><span>) </span><span>TemplateData</span><span>() (</span><span>any</span><span>, </span><span>error</span><span>) {
</span><span>    </span><span>return </span><span>v.Data, </span><span>nil
</span><span>}
</span></code></pre>
<p>The container becomes representable in a different way and it
would have the equivalent outcome when rendered.</p>




<details>
<summary>view.go implementation (and tests)</summary>

<pre data-lang="patch"><code data-lang="patch"><span>745d3ae0d69260b83c0ae50491b7bacd3f37dafe with initial view.go and test
</span><span>diff --git a/render_container_as_view_test.go b/render_container_as_view_test.go
</span><span>new file mode 100644
</span><span>index 0000000..7123b23
</span><span>---</span><span> /dev/null
</span><span>+++</span><span> b/render_container_as_view_test.go
</span><span>@@ -0,0 +1,26 @@
</span><span>+</span><span>package veun_test
</span><span>+
</span><span>+</span><span>import (
</span><span>+</span><span>	&#34;html/template&#34;
</span><span>+</span><span>	&#34;testing&#34;
</span><span>+
</span><span>+</span><span>	&#34;github.com/alecthomas/assert/v2&#34;
</span><span>+
</span><span>+</span><span>	. &#34;github.com/stanistan/veun&#34;
</span><span>+</span><span>)
</span><span>+
</span><span>+</span><span>func TestRenderContainerAsView(t *testing.T) {
</span><span>+</span><span>	html, err := Render(View{
</span><span>+</span><span>		Tpl: containerViewTpl,
</span><span>+</span><span>		Slots: map[string]Renderable{
</span><span>+</span><span>			&#34;heading&#34;: ChildView1{},
</span><span>+</span><span>			&#34;body&#34;:    ChildView2{},
</span><span>+</span><span>		},
</span><span>+</span><span>	})
</span><span>+</span><span>	assert.NoError(t, err)
</span><span>+</span><span>	assert.Equal(t, template.HTML(`&lt;div&gt;
</span><span>+</span><span>	&lt;div class=&#34;heading&#34;&gt;HEADING&lt;/div&gt;
</span><span>+</span><span>	&lt;div class=&#34;body&#34;&gt;BODY&lt;/div&gt;
</span><span>+</span><span>&lt;/div&gt;`), html)
</span><span>+
</span><span>+</span><span>}
</span><span>diff --git a/render_container_test.go b/render_container_test.go
</span><span>index c372d45..4bc829c 100644
</span><span>---</span><span> a/render_container_test.go
</span><span>+++</span><span> b/render_container_test.go
</span><span>@@ -9,24 +9,12 @@ import (
</span><span> 	. &#34;github.com/stanistan/veun&#34;
</span><span> )
</span><span> 
</span><span>-func slotFuncStub(name string) (template.HTML, error) {
</span><span>-	return template.HTML(&#34;&#34;), nil
</span><span>-}
</span><span>-
</span><span> type ContainerView struct {
</span><span> 	Heading Renderable
</span><span> 	Body    Renderable
</span><span> }
</span><span> 
</span><span>-func mustParseTemplate(name, contents string) *template.Template {
</span><span>-	return template.Must(
</span><span>-		template.New(name).
</span><span>-			Funcs(template.FuncMap{&#34;slot&#34;: slotFuncStub}).
</span><span>-			Parse(contents),
</span><span>-	)
</span><span>-}
</span><span>-
</span><span>-var containerViewTpl = mustParseTemplate(&#34;containerView&#34;, `&lt;div&gt;
</span><span>+</span><span>var containerViewTpl = MustParseTemplate(&#34;containerView&#34;, `&lt;div&gt;
</span><span> 	&lt;div class=&#34;heading&#34;&gt;{{ slot &#34;heading&#34; }}&lt;/div&gt;
</span><span> 	&lt;div class=&#34;body&#34;&gt;{{ slot &#34;body&#34; }}&lt;/div&gt;
</span><span> &lt;/div&gt;`)
</span><span>diff --git a/view.go b/view.go
</span><span>new file mode 100644
</span><span>index 0000000..ee54469
</span><span>---</span><span> /dev/null
</span><span>+++</span><span> b/view.go
</span><span>@@ -0,0 +1,41 @@
</span><span>+</span><span>package veun
</span><span>+
</span><span>+</span><span>import &#34;html/template&#34;
</span><span>+
</span><span>+</span><span>type View struct {
</span><span>+</span><span>	Tpl   *template.Template
</span><span>+</span><span>	Slots map[string]Renderable
</span><span>+</span><span>	Data  any
</span><span>+</span><span>}
</span><span>+
</span><span>+</span><span>func (v View) Template() (*template.Template, error) {
</span><span>+</span><span>	return tplWithRealSlotFunc(v.Tpl, v.Slots), nil
</span><span>+</span><span>}
</span><span>+
</span><span>+</span><span>func (v View) TemplateData() (any, error) {
</span><span>+</span><span>	return v.Data, nil
</span><span>+</span><span>}
</span><span>+
</span><span>+</span><span>func tplWithRealSlotFunc(tpl *template.Template, slots map[string]Renderable) *template.Template {
</span><span>+</span><span>	return tpl.Funcs(template.FuncMap{
</span><span>+</span><span>		&#34;slot&#34;: func(name string) (template.HTML, error) {
</span><span>+</span><span>			slot, ok := slots[name]
</span><span>+</span><span>			if ok {
</span><span>+</span><span>				return Render(slot)
</span><span>+</span><span>			}
</span><span>+</span><span>			return template.HTML(&#34;&#34;), nil
</span><span>+</span><span>		},
</span><span>+</span><span>	})
</span><span>+</span><span>}
</span><span>+
</span><span>+</span><span>func slotFuncStub(name string) (template.HTML, error) {
</span><span>+</span><span>	return template.HTML(&#34;&#34;), nil
</span><span>+</span><span>}
</span><span>+
</span><span>+</span><span>func MustParseTemplate(name, contents string) *template.Template {
</span><span>+</span><span>	return template.Must(
</span><span>+</span><span>		template.New(name).
</span><span>+</span><span>			Funcs(template.FuncMap{&#34;slot&#34;: slotFuncStub}).
</span><span>+</span><span>			Parse(contents),
</span><span>+</span><span>	)
</span><span>+</span><span>}
</span><span>
</span></code></pre>


</details>
<pre data-lang="go"><code data-lang="go"><span>View{
</span><span>  Tpl: containerViewTpl,
</span><span>  Slots: </span><span>map</span><span>[</span><span>string</span><span>]</span><span>Renderable</span><span>{
</span><span>    </span><span>&#34;heading&#34;</span><span>: ChildView1{},
</span><span>    </span><span>&#34;body&#34;</span><span>:    ChildView2{},
</span><span>  }
</span><span>}
</span></code></pre>
<p>But we still might want to have ContainerView be the thing we can
&#34;render&#34;, how would we do both?</p>
<pre data-lang="go"><code data-lang="go"><span>type </span><span>AsRenderable </span><span>interface </span><span>{
</span><span>    </span><span>func </span><span>Renderable</span><span>() (</span><span>Renderable</span><span>, </span><span>error</span><span>)
</span><span>}
</span><span>
</span><span>type </span><span>Slots </span><span>map</span><span>[</span><span>string</span><span>]</span><span>AsRenderable
</span></code></pre>
<p>And updating the <code>Render</code> function for the first time to take
<code>AsRenderable</code> instead gives us our first really big interface
change, but it unlocks something, too. A simpler way to build views:</p>
<pre data-lang="go"><code data-lang="go"><span>func </span><span>(v </span><span>ContainerView</span><span>) </span><span>Renderable</span><span>() (</span><span>Renderable</span><span>, </span><span>error</span><span>) {
</span><span>    </span><span>return </span><span>View{
</span><span>        Tpl:   containerViewTpl,
</span><span>        Slots: Slots{</span><span>&#34;heading&#34;</span><span>: v.Heading, </span><span>&#34;body&#34;</span><span>: v.Body},
</span><span>    ), </span><span>nil
</span><span>}
</span></code></pre>




<details>
<summary>AsRenderable implementation (and tests)</summary>

<pre data-lang="patch"><code data-lang="patch"><span>3fb3dcf7e2abacff8a42d8b3da86f85f6576e08e Renderable and AsRenderable
</span><span>diff --git a/render_container_as_view_test.go b/render_container_as_view_test.go
</span><span>index 7123b23..a3a0c37 100644
</span><span>---</span><span> a/render_container_as_view_test.go
</span><span>+++</span><span> b/render_container_as_view_test.go
</span><span>@@ -12,7 +12,7 @@ import (
</span><span> func TestRenderContainerAsView(t *testing.T) {
</span><span> 	html, err := Render(View{
</span><span> 		Tpl: containerViewTpl,
</span><span>-		Slots: map[string]Renderable{
</span><span>+</span><span>		Slots: map[string]AsRenderable{
</span><span> 			&#34;heading&#34;: ChildView1{},
</span><span> 			&#34;body&#34;:    ChildView2{},
</span><span> 		},
</span><span>diff --git a/render_container_test.go b/render_container_test.go
</span><span>index 4bc829c..14dd884 100644
</span><span>---</span><span> a/render_container_test.go
</span><span>+++</span><span> b/render_container_test.go
</span><span>@@ -10,8 +10,8 @@ import (
</span><span> )
</span><span> 
</span><span> type ContainerView struct {
</span><span>-	Heading Renderable
</span><span>-	Body    Renderable
</span><span>+</span><span>	Heading AsRenderable
</span><span>+</span><span>	Body    AsRenderable
</span><span> }
</span><span> 
</span><span> var containerViewTpl = MustParseTemplate(&#34;containerView&#34;, `&lt;div&gt;
</span><span>@@ -19,7 +19,7 @@ var containerViewTpl = MustParseTemplate(&#34;containerView&#34;, `&lt;div&gt;
</span><span> 	&lt;div class=&#34;body&#34;&gt;{{ slot &#34;body&#34; }}&lt;/div&gt;
</span><span> &lt;/div&gt;`)
</span><span> 
</span><span>-func tplWithRealSlotFunc(tpl *template.Template, slots map[string]Renderable) *template.Template {
</span><span>+</span><span>func tplWithRealSlotFunc(tpl *template.Template, slots map[string]AsRenderable) *template.Template {
</span><span> 	return tpl.Funcs(template.FuncMap{
</span><span> 		&#34;slot&#34;: func(name string) (template.HTML, error) {
</span><span> 			slot, ok := slots[name]
</span><span>@@ -32,7 +32,7 @@ func tplWithRealSlotFunc(tpl *template.Template, slots map[string]Renderable) *t
</span><span> }
</span><span> 
</span><span> func (v ContainerView) Template() (*template.Template, error) {
</span><span>-	return tplWithRealSlotFunc(containerViewTpl, map[string]Renderable{
</span><span>+</span><span>	return tplWithRealSlotFunc(containerViewTpl, map[string]AsRenderable{
</span><span> 		&#34;heading&#34;: v.Heading,
</span><span> 		&#34;body&#34;:    v.Body,
</span><span> 	}), nil
</span><span>@@ -42,12 +42,20 @@ func (v ContainerView) TemplateData() (any, error) {
</span><span> 	return nil, nil
</span><span> }
</span><span> 
</span><span>+</span><span>func (v ContainerView) Renderable() (Renderable, error) {
</span><span>+</span><span>	return v, nil
</span><span>+</span><span>}
</span><span>+
</span><span> var childViewTemplate = template.Must(
</span><span> 	template.New(&#34;childView&#34;).Parse(`{{ . }}`),
</span><span> )
</span><span> 
</span><span> type ChildView1 struct{}
</span><span> 
</span><span>+</span><span>func (v ChildView1) Renderable() (Renderable, error) {
</span><span>+</span><span>	return v, nil
</span><span>+</span><span>}
</span><span>+
</span><span> func (v ChildView1) Template() (*template.Template, error) {
</span><span> 	return childViewTemplate, nil
</span><span> }
</span><span>@@ -66,6 +74,10 @@ func (v ChildView2) TemplateData() (any, error) {
</span><span> 	return &#34;BODY&#34;, nil
</span><span> }
</span><span> 
</span><span>+</span><span>func (v ChildView2) Renderable() (Renderable, error) {
</span><span>+</span><span>	return v, nil
</span><span>+</span><span>}
</span><span>+
</span><span> func TestRenderContainer(t *testing.T) {
</span><span> 	html, err := Render(&amp;ContainerView{
</span><span> 		Heading: ChildView1{},
</span><span>diff --git a/render_person_test.go b/render_person_test.go
</span><span>index 64a542b..80ef587 100644
</span><span>---</span><span> a/render_person_test.go
</span><span>+++</span><span> b/render_person_test.go
</span><span>@@ -34,6 +34,10 @@ func (v *personView) TemplateData() (any, error) {
</span><span> 	return v.Person, nil
</span><span> }
</span><span> 
</span><span>+</span><span>func (v *personView) Renderable() (veun.Renderable, error) {
</span><span>+</span><span>	return v, nil
</span><span>+</span><span>}
</span><span>+
</span><span> func TestRenderPerson(t *testing.T) {
</span><span> 	html, err := veun.Render(PersonView(Person{Name: &#34;Stan&#34;}))
</span><span> 	assert.NoError(t, err)
</span><span>diff --git a/renderer.go b/renderer.go
</span><span>index c96d89d..cb2c5f0 100644
</span><span>---</span><span> a/renderer.go
</span><span>+++</span><span> b/renderer.go
</span><span>@@ -6,14 +6,25 @@ import (
</span><span> 	&#34;html/template&#34;
</span><span> )
</span><span> 
</span><span>-type RenderFunc func(r Renderable) (template.HTML, error)
</span><span>-
</span><span> type Renderable interface {
</span><span> 	Template() (*template.Template, error)
</span><span> 	TemplateData() (any, error)
</span><span> }
</span><span> 
</span><span>-func Render(r Renderable) (template.HTML, error) {
</span><span>+</span><span>type AsRenderable interface {
</span><span>+</span><span>	Renderable() (Renderable, error)
</span><span>+</span><span>}
</span><span>+
</span><span>+</span><span>func Render(r AsRenderable) (template.HTML, error) {
</span><span>+</span><span>	rr, err := r.Renderable()
</span><span>+</span><span>	if err != nil {
</span><span>+</span><span>		return template.HTML(&#34;&#34;), err
</span><span>+</span><span>	}
</span><span>+
</span><span>+</span><span>	return render(rr)
</span><span>+</span><span>}
</span><span>+
</span><span>+</span><span>func render(r Renderable) (template.HTML, error) {
</span><span> 	var empty template.HTML
</span><span> 
</span><span> 	tpl, err := r.Template()
</span><span>diff --git a/view.go b/view.go
</span><span>index ee54469..bb33a3d 100644
</span><span>---</span><span> a/view.go
</span><span>+++</span><span> b/view.go
</span><span>@@ -4,7 +4,7 @@ import &#34;html/template&#34;
</span><span> 
</span><span> type View struct {
</span><span> 	Tpl   *template.Template
</span><span>-	Slots map[string]Renderable
</span><span>+</span><span>	Slots map[string]AsRenderable
</span><span> 	Data  any
</span><span> }
</span><span> 
</span><span>@@ -16,7 +16,11 @@ func (v View) TemplateData() (any, error) {
</span><span> 	return v.Data, nil
</span><span> }
</span><span> 
</span><span>-func tplWithRealSlotFunc(tpl *template.Template, slots map[string]Renderable) *template.Template {
</span><span>+</span><span>func (v View) Renderable() (Renderable, error) {
</span><span>+</span><span>	return v, nil
</span><span>+</span><span>}
</span><span>+
</span><span>+</span><span>func tplWithRealSlotFunc(tpl *template.Template, slots map[string]AsRenderable) *template.Template {
</span><span> 	return tpl.Funcs(template.FuncMap{
</span><span> 		&#34;slot&#34;: func(name string) (template.HTML, error) {
</span><span> 			slot, ok := slots[name]
</span><span>
</span></code></pre>


</details>

        </section>

        

    </article></div>
  </body>
</html>
