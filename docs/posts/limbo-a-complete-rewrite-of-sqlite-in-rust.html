<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://turso.tech/blog/introducing-limbo-a-complete-rewrite-of-sqlite-in-rust">Original</a>
    <h1>Limbo: A complete rewrite of SQLite in Rust</h1>
    
    <div id="readability-page-1" class="page"><div><p>2 years ago, we forked SQLite. We were huge fans of the embedded nature of SQLite, but longed for a more open model of development. <a href="https://github.com/tursodatabase/libsql">libSQL</a> was born as an Open Contribution project, and we invited the community to build it with us.</p>
<p>As a result, libSQL is an astounding success. With over 12k Github stars, 85 contributors, and features like native replication and vector search, libSQL is the engine that powers the <a href="https://turso.tech/">Turso</a> platform.</p>
<p>Today we are announcing a more ambitious experiment: what could we achieve, if we were to completely <em>rewrite</em> SQLite in a memory-safe language (Rust)? With the Limbo project, now available at <a href="https://github.com/tursodatabase/limbo">github.com/tursodatabase/limbo</a>, we are now trying to answer that question.</p>
<h2 id="the-pros-and-cons-of-forking"><a href="#the-pros-and-cons-of-forking">#</a><a aria-hidden="true" tabindex="-1" href="#the-pros-and-cons-of-forking"><span></span></a>The pros and cons of forking</h2>
<p>When we forked SQLite, forking was not the only alternative. We considered rewriting it entirely, but were concerned about the huge lead time needed to have something production-ready, and the toil involved in keeping compatibility. A fork would also allow us to keep back-merging from SQLite, adopting new features as they come.</p>
<p>On the other hand, there are disadvantages as well: SQLite‚Äôs test suite is proprietary, meaning that it is hard to achieve the confidence to make very large changes. It is also written in C, an unsafe language, which makes evolving the codebase with confidence even harder.</p>
<p>Weighing the pros and cons, forking was the way to go, and the libSQL project was born.</p>
<h2 id="a-new-approach"><a href="#a-new-approach">#</a><a aria-hidden="true" tabindex="-1" href="#a-new-approach"><span></span></a>A new approach</h2>
<p>Adding Vector search to SQLite was an eye opener. We didn‚Äôt want to do this as an extension, since we wanted to make the syntax as straightforward and natural as possible. That would require changes to the bytecode generation, which we did. We are able to expose vectors as a data type, query relational and vector data together in the same table, and as long as the query doesn‚Äôt need an index, use perfectly boring SQL syntax.</p>
<p>But for searches with an index, without making very invasive changes, it was hard to achieve the syntax that we wanted:</p>
<pre><code><span>SELECT</span> title, <span>year</span>
   <span>FROM</span> movies
   <span>ORDER</span> <span>BY</span> vector_distance_cos(embedding, vector(<span>&#39;[4,5,6]&#39;</span>))
   LIMIT <span>3</span>;
</code></pre>
<p>And we ended up settling for</p>
<pre><code><span>SELECT</span> title, <span>year</span>
   <span>FROM</span> vector_top_k(<span>&#39;movies_idx&#39;</span>, vector(<span>&#39;[4,5,6]&#39;</span>), <span>3</span>)
   <span>JOIN</span> movies
   <span>ON</span> movies.rowid <span>=</span> id;
</code></pre>
<p>The index is represented as a separate table, and we have to explicitly join it with the main table.</p>
<p>At that point, we decided to try a new approach and answer the question: how much effort was it <em>really</em> involved in rewriting SQLite from scratch ? And can we do it in a way that effortlessly keeps compatibility? Would that make it easier for us to be more aggressive and do some of the things we wanted to do in our fork (like asynchronous I/O) with a high degree of confidence?</p>
<p>To answer those questions, Pekka started an ambitious experiment on hist <a href="https://github.com/penberg/limbo">personal github account</a>. It was named Limbo as a codename temporarily, and it did extremely well. Without much press, just me talking about it on ùïè, the project grew to 1,000 github stars, and attracted more than 30 contributors organically.</p>
<h2 id="the-next-step"><a href="#the-next-step">#</a><a aria-hidden="true" tabindex="-1" href="#the-next-step"><span></span></a>The next step</h2>
<p>With the success of this experiment, we have decided to turn Limbo into an official project at Turso. It is still an experiment, but now an official Turso experiment, which will allow us to pour more resources into it, including more time from other engineers in the company.</p>
<p>Our goal is to build a reimplementation of SQLite from scratch, fully compatible at the language and file format level,  with the same or higher reliability SQLite is known for, but with full memory safety and on a new, modern architecture.</p>
<p>That is not to say that we‚Äôre building a competitor or alternative to libSQL: if it succeeds, this codebase just becomes libSQL. The code is available under the same license as libSQL (MIT), and with the same community-friendly attitude that defined our project.</p>
<h2 id="can-we-match-sqlite-s-world-famous-reliability-"><a href="#can-we-match-sqlite-s-world-famous-reliability-">#</a><a aria-hidden="true" tabindex="-1" href="#can-we-match-sqlites-world-famous-reliability"><span></span></a>Can we match SQLite‚Äôs world-famous reliability?</h2>
<p>Since this is a reimplementation, doesn‚Äôt that mean that testing is now even harder? The reality is that it is the other way around. Since we are reimplementing it from scratch, we are doing it with Deterministic Simulation Testing (DST) built-in from the get-go. We have both added DST facilities to the core of the database, and partnered with Antithesis to achieve a level of reliability in the database that lives up to SQLite‚Äôs reputation.</p>
<p>Deterministic Simulation Testing is a paradigm made famous by the folks at <a href="https://tigerbeetle.com/">TigerBeetle</a>, that we at Turso already dipped our toes into with our <a href="https://turso.tech/blog/a-deep-look-into-our-new-massive-multitenant-architecture">server-side code</a>. With DST, we believe we can achieve an even higher degree of robustness than SQLite, since it is easier to simulate unlikely scenarios in a simulator, test years of execution with different event orderings, and upon finding issues, reproduce them 100% reliably.</p>
<p>In the DST world, writing our own simulator is akin to writing unit tests: they allow us to move fast, experiment easily, and stress changes thoroughly. But much as unit testing does not do away with the need for higher level integration testing that tests the behavior of the system at a higher level, we felt like we needed to go the extra mile to achieve the levels of reliability that we wanted.</p>
<p>To complete the puzzle, we wanted to deterministically test the behavior of the database when interacting with the operating system and other components. To do that, we are partnering with <a href="https://antithesis.com/">Antithesis</a>, a company that provides a system-level Deterministic Simulation Testing framework, and can simulate all sorts of hardware and software failures. Antithesis does that by providing a deterministic hypervisor that runs many fuzzing threads in parallel, allowing us to quickly search the input space.</p>
<p>As an example of why this is important, they have already helped us find issues in our <code>io_uring</code> implementation under partial writes. Our own DST framework would not have caught this, since the actual I/O loop is replaced by the simulated I/O loop in testing. Partial writes are an extremely rare condition, and therefore, hard to test in an automated fashion.</p>
<p>Aside from Deterministic simulation testing, we also routinely fuzz inputs, and then make sure that the generated bytecode is the same, for both Limbo and SQLite.</p>
<h2 id="the-current-status"><a href="#the-current-status">#</a><a aria-hidden="true" tabindex="-1" href="#the-current-status"><span></span></a>The current status</h2>
<p>While Limbo is still in early stages, it has already achieved some important milestones that are already a couple of things worth noting:</p>
<h3 id="fully-asynchronous-i-o"><a href="#fully-asynchronous-i-o">#</a><a aria-hidden="true" tabindex="-1" href="#fully-asynchronous-io"><span></span></a>Fully asynchronous I/O</h3>
<p>Limbo is designed to be fully asynchronous. SQLite itself has a synchronous interface, meaning driver authors who want asynchronous behavior need to have the extra complication of using helper threads. Because SQLite queries <em>tend</em> to be fast, since no network round trips are involved, a lot of those drivers just settle for a synchronous interface. However, this has two fundamental problems:
Not all SQLite queries are fast. Aggregations over large data, for example, will always be slow, even if the data is fully local.
In modern environments, it is actually desirable that queries go over the network. One example is Turso, which serves SQLite over HTTP. Another example are implementations of SQLite over S3 providing the illusion of infinite storage space, where data <em>can</em> be cached locally, but parts of it may be remote.</p>
<p>Limbo is designed to be asynchronous from the ground up. It extends <code>sqlite3_step</code>, the main entry point API to SQLite, to be asynchronous, allowing it to return to the caller if data is not ready to consume immediately. On Linux, Limbo uses <code>io_uring</code>, a performant API for asynchronous system calls.</p>
<h3 id="designed-for-wasm"><a href="#designed-for-wasm">#</a><a aria-hidden="true" tabindex="-1" href="#designed-for-wasm"><span></span></a>Designed for WASM</h3>
<p>While SQLite can compile to WASM, it is mostly an afterthought for SQLite. In practice, projects like wa-sqlite exist to extend SQLite and allow it to function in WASM environments like <a href="https://stackblitz.com">Stackblitz</a> . Limbo is designed from the ground up to have a WASM build, and already has a VFS implementation that works with popular tools like Drizzle without any changes. For example, it is possible to write:</p>
<pre><code><span>import</span> { drizzle } <span>from</span> <span>&#39;drizzle-orm/better-sqlite3&#39;</span>;
<span>import</span> * <span>as</span> s <span>from</span> <span>&#39;drizzle-orm/sqlite-core&#39;</span>;
<span>import</span> { <span>Database</span> } <span>from</span> <span>&#39;limbo-wasm&#39;</span>;

<span>const</span> sqlite = <span>new</span> <span>Database</span>(<span>&#39;sqlite.db&#39;</span>);
<span>const</span> db = <span>drizzle</span>({ <span>client</span>: sqlite });
<span>const</span> users = s.<span>sqliteTable</span>(<span>&#34;users&#34;</span>, {
  <span>id</span>: s.<span>integer</span>(),
  <span>name</span>: s.<span>text</span>(),
})

<span>const</span> result = db.<span>select</span>().<span>from</span>(users).<span>all</span>();

<span>console</span>.<span>log</span>(result);
</code></pre>
<p>Browser support is in the works.</p>
<h3 id="performance"><a href="#performance">#</a><a aria-hidden="true" tabindex="-1" href="#performance"><span></span></a>Performance</h3>
<p>SQLite is known for its stellar performance, but in many operations, Limbo is already on par or faster than SQLite. Executing <code>cargo bench</code> on Limbo‚Äôs main directory, we can compare SQLite running <code>SELECT * FROM users LIMIT 1</code> (620ns on my Macbook Air M2), with Limbo executing the same query (506ns), which is 20% faster.</p>
<h3 id="simplicity"><a href="#simplicity">#</a><a aria-hidden="true" tabindex="-1" href="#simplicity"><span></span></a>Simplicity</h3>
<p>Despite the fact that SQLite‚Äôs file-based nature makes working with it extremely simple, SQLite grew a considerable amount of tunables over the years, which make getting top performance out of it non-obvious (the SQLite numbers on the benchmark above are after tuning). For maximum performance, users have to choose WAL mode over journal mode, disable POSIX advisory locks, etc.</p>
<p>Limbo, while maintaining compatibility with SQLite‚Äôs bytecode and file format, drops a lot of the features that we consider less important for modern environments (including SQLite‚Äôs ‚Äúamalgamation‚Äù, the build system that generates a single C file), providing a better out-of-the-box experience.</p>
<h2 id="interested-in-learning-more-"><a href="#interested-in-learning-more-">#</a><a aria-hidden="true" tabindex="-1" href="#interested-in-learning-more"><span></span></a>Interested in learning more?</h2>
<p>Limbo is available under the MIT license <a href="https://github.com/tursodatabase/limbo">on our Github</a>. If you are interested in building an embedded database with the bold vision of taking the promise of SQLite to the next level, come build with us.</p></div></div>
  </body>
</html>
