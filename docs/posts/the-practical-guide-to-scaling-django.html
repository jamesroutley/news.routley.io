<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://slimsaas.com/blog/django-scaling-performance/">Original</a>
    <h1>The Practical Guide to Scaling Django</h1>
    
    <div id="readability-page-1" class="page"><div>  <article>  <p>
By <a href="http://tinylogger.com/author/andrew"> Andrew </a> on 11/10/2024 </p> <img src="https://images.unsplash.com/photo-1516110723075-c29d0b4e6cc1?q=80&amp;w=3135&amp;auto=format&amp;fit=crop&amp;ixlib=rb-4.0.3&amp;ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D" alt="The Practical Guide to Scaling Django"/> <p>Most Django scaling guides focus on theoretical maximums. But real scaling isn’t about handling hypothetical millions of users - it’s about systematically eliminating bottlenecks as you grow. Here’s how to do it right, based on patterns that work in production.</p>
<p>Django is the framework of choice for many of the largest web applications (e.g. Instagram, Pinterest, etc.). But it’s not hard to get bogged down by common pitfalls.</p>
<h2 id="first-know-your-actual-bottlenecks">First, Know Your Actual Bottlenecks</h2>
<p>Before diving into solutions, understand that Django performance usually hits these bottlenecks in order:</p>
<ol>
<li>Database queries</li>
<li>Template rendering</li>
<li>Python processing</li>
<li>Cache misses</li>
<li>File I/O</li>
<li>Network latency</li>
</ol>
<p>Don’t optimize what isn’t slowing you down. Here’s how to tackle each when they become real problems:</p>
<h2 id="database-optimization">Database Optimization</h2>
<h3 id="1-query-optimization">1. Query Optimization</h3>
<pre tabindex="0" data-language="python"><code><span><span># Bad: N+1 queries</span></span>
<span><span>for</span><span> user </span><span>in</span><span> Users.objects.all():</span></span>
<span><span>    print</span><span>(user.profile.bio)  </span><span># One query per user</span></span>
<span></span>
<span><span># Good: Single query with select_related</span></span>
<span><span>users </span><span>=</span><span> User.objects.select_related(</span><span>&#39;profile&#39;</span><span>).all()</span></span>
<span><span>for</span><span> user </span><span>in</span><span> users:</span></span>
<span><span>    print</span><span>(user.profile.bio)  </span><span># No additional queries</span></span>
<span></span></code></pre>
<h3 id="2-database-indexing">2. Database Indexing</h3>
<pre tabindex="0" data-language="python"><code><span><span>class</span><span> Order</span><span>(</span><span>models</span><span>.</span><span>Model</span><span>):</span></span>
<span><span>    user </span><span>=</span><span> models.ForeignKey(User)</span></span>
<span><span>    created_at </span><span>=</span><span> models.DateTimeField(</span><span>auto_now_add</span><span>=</span><span>True</span><span>)</span></span>
<span><span>    status </span><span>=</span><span> models.CharField(</span><span>max_length</span><span>=</span><span>20</span><span>)</span></span>
<span></span>
<span><span>    class</span><span> Meta</span><span>:</span></span>
<span><span>        indexes </span><span>=</span><span> [</span></span>
<span><span>            models.Index(</span><span>fields</span><span>=</span><span>[</span><span>&#39;created_at&#39;</span><span>, </span><span>&#39;status&#39;</span><span>]),</span></span>
<span><span>            models.Index(</span><span>fields</span><span>=</span><span>[</span><span>&#39;user&#39;</span><span>, </span><span>&#39;status&#39;</span><span>]),</span></span>
<span><span>        ]</span></span>
<span></span></code></pre>
<h3 id="3-queryset-optimization">3. Queryset Optimization</h3>
<pre tabindex="0" data-language="python"><code><span><span># Bad: Loading entire objects</span></span>
<span><span>users </span><span>=</span><span> User.objects.all()</span></span>
<span></span>
<span><span># Good: Only loading needed fields</span></span>
<span><span>users </span><span>=</span><span> User.objects.values(</span><span>&#39;id&#39;</span><span>, </span><span>&#39;email&#39;</span><span>)</span></span>
<span></span>
<span><span># Better: Using iterator() for large querysets</span></span>
<span><span>for</span><span> user </span><span>in</span><span> User.objects.iterator():</span></span>
<span><span>    process_user(user)</span></span>
<span></span></code></pre>
<h2 id="caching">Caching</h2>
<h3 id="1-view-level-caching">1. View-Level Caching</h3>
<pre tabindex="0" data-language="python"><code><span><span>from</span><span> django.views.decorators.cache </span><span>import</span><span> cache_page</span></span>
<span></span>
<span><span>@cache_page</span><span>(</span><span>60</span><span> *</span><span> 15</span><span>)  </span><span># Cache for 15 minutes</span></span>
<span><span>def</span><span> product_list</span><span>(request):</span></span>
<span><span>    products </span><span>=</span><span> Product.objects.all()</span></span>
<span><span>    return</span><span> render(request, </span><span>&#39;products/list.html&#39;</span><span>, {</span><span>&#39;products&#39;</span><span>: products})</span></span>
<span></span></code></pre>
<h3 id="2-template-fragment-caching">2. Template Fragment Caching</h3>
<pre tabindex="0" data-language="html"><code><span><span>{% load cache %}</span></span>
<span></span>
<span><span>{% cache 500 sidebar request.user.id %}</span></span>
<span><span>    {% for item in expensive_query %}</span></span>
<span><span>        {{ item }}</span></span>
<span><span>    {% endfor %}</span></span>
<span><span>{% endcache %}</span></span>
<span></span></code></pre>
<h3 id="3-low-level-cache-api">3. Low-Level Cache API</h3>
<pre tabindex="0" data-language="python"><code><span><span>from</span><span> django.core.cache </span><span>import</span><span> cache</span></span>
<span></span>
<span><span>def</span><span> get_expensive_result</span><span>(user_id):</span></span>
<span><span>    cache_key </span><span>=</span><span> f</span><span>&#39;expensive_result_</span><span>{</span><span>user_id</span><span>}</span><span>&#39;</span></span>
<span><span>    result </span><span>=</span><span> cache.get(cache_key)</span></span>
<span><span>    </span></span>
<span><span>    if</span><span> result </span><span>is</span><span> None</span><span>:</span></span>
<span><span>        result </span><span>=</span><span> expensive_computation(user_id)</span></span>
<span><span>        cache.set(cache_key, result, </span><span>timeout</span><span>=</span><span>3600</span><span>)</span></span>
<span><span>    </span></span>
<span><span>    return</span><span> result</span></span>
<span></span></code></pre>
<h2 id="async-when-you-need-concurrent-connections">Async: When You Need Concurrent Connections</h2>
<pre tabindex="0" data-language="python"><code><span><span># views.py</span></span>
<span><span>async</span><span> def</span><span> async_view</span><span>(request):</span></span>
<span><span>    async</span><span> with</span><span> aiohttp.ClientSession() </span><span>as</span><span> session:</span></span>
<span><span>        async</span><span> with</span><span> session.get(</span><span>&#39;http://api.example.com/data&#39;</span><span>) </span><span>as</span><span> response:</span></span>
<span><span>            data </span><span>=</span><span> await</span><span> response.json()</span></span>
<span><span>    return</span><span> JsonResponse(data)</span></span>
<span></span>
<span><span># urls.py</span></span>
<span><span>path(</span><span>&#39;async-data/&#39;</span><span>, async_view)</span></span>
<span></span></code></pre>
<h2 id="background-tasks-dont-block-the-request-response-cycle">Background Tasks: Don’t Block the Request-Response Cycle</h2>
<pre tabindex="0" data-language="python"><code><span><span>from</span><span> django.core.mail </span><span>import</span><span> send_mail</span></span>
<span><span>from</span><span> celery </span><span>import</span><span> shared_task</span></span>
<span></span>
<span><span>@shared_task</span></span>
<span><span>def</span><span> send_welcome_email</span><span>(user_id):</span></span>
<span><span>    user </span><span>=</span><span> User.objects.get(</span><span>id</span><span>=</span><span>user_id)</span></span>
<span><span>    send_mail(</span></span>
<span><span>        &#39;Welcome!&#39;</span><span>,</span></span>
<span><span>        &#39;Thanks for joining.&#39;</span><span>,</span></span>
<span><span>        &#39;from@example.com&#39;</span><span>,</span></span>
<span><span>        [user.email],</span></span>
<span><span>    )</span></span>
<span></span>
<span><span># In your view</span></span>
<span><span>def</span><span> signup</span><span>(request):</span></span>
<span><span>    user </span><span>=</span><span> User.objects.create_user(</span><span>...</span><span>)</span></span>
<span><span>    send_welcome_email.delay(user.id)</span></span>
<span><span>    return</span><span> redirect(</span><span>&#39;home&#39;</span><span>)</span></span>
<span></span></code></pre>
<h2 id="load-balancing-when-single-server-isnt-enough">Load Balancing: When Single Server Isn’t Enough</h2>
<pre tabindex="0" data-language="python"><code><span><span># settings.py for multiple servers</span></span>
<span><span>DATABASES</span><span> =</span><span> {</span></span>
<span><span>    &#39;default&#39;</span><span>: {</span></span>
<span><span>        &#39;ENGINE&#39;</span><span>: </span><span>&#39;django.db.backends.postgresql&#39;</span><span>,</span></span>
<span><span>        &#39;NAME&#39;</span><span>: </span><span>&#39;mydb&#39;</span><span>,</span></span>
<span><span>        &#39;HOST&#39;</span><span>: </span><span>&#39;primary.database.host&#39;</span><span>,</span></span>
<span><span>        &#39;CONN_MAX_AGE&#39;</span><span>: </span><span>60</span><span>,</span></span>
<span><span>    },</span></span>
<span><span>    &#39;read_replica&#39;</span><span>: {</span></span>
<span><span>        &#39;ENGINE&#39;</span><span>: </span><span>&#39;django.db.backends.postgresql&#39;</span><span>,</span></span>
<span><span>        &#39;NAME&#39;</span><span>: </span><span>&#39;mydb&#39;</span><span>,</span></span>
<span><span>        &#39;HOST&#39;</span><span>: </span><span>&#39;replica.database.host&#39;</span><span>,</span></span>
<span><span>        &#39;CONN_MAX_AGE&#39;</span><span>: </span><span>60</span><span>,</span></span>
<span><span>    }</span></span>
<span><span>}</span></span>
<span></span></code></pre>
<h2 id="media-files-move-to-cdn-early">Media Files: Move to CDN Early</h2>
<pre tabindex="0" data-language="python"><code><span><span># settings.py</span></span>
<span><span>DEFAULT_FILE_STORAGE</span><span> =</span><span> &#39;storages.backends.s3boto3.S3Boto3Storage&#39;</span></span>
<span><span>STATICFILES_STORAGE</span><span> =</span><span> &#39;storages.backends.s3boto3.S3StaticStorage&#39;</span></span>
<span></span>
<span><span>AWS_ACCESS_KEY_ID</span><span> =</span><span> &#39;your-access-key&#39;</span></span>
<span><span>AWS_SECRET_ACCESS_KEY</span><span> =</span><span> &#39;your-secret-key&#39;</span></span>
<span><span>AWS_STORAGE_BUCKET_NAME</span><span> =</span><span> &#39;your-bucket-name&#39;</span></span>
<span><span>AWS_S3_CUSTOM_DOMAIN</span><span> =</span><span> f</span><span>&#39;</span><span>{AWS_STORAGE_BUCKET_NAME}</span><span>.s3.amazonaws.com&#39;</span></span>
<span></span></code></pre>
<h2 id="real-world-scaling-checkpoints">Real-World Scaling Checkpoints</h2>
<h3 id="at-100-requestssecond">At 100 Requests/Second</h3>
<ul>
<li>Implement basic caching</li>
<li>Add database indexes</li>
<li>Move static files to CDN</li>
</ul>
<h3 id="at-1000-requestssecond">At 1,000 Requests/Second</h3>
<ul>
<li>Add read replicas</li>
<li>Implement fragment caching</li>
<li>Move to managed Redis/Memcached</li>
</ul>
<h3 id="at-10000-requestssecond">At 10,000 Requests/Second</h3>
<ul>
<li>Shard databases</li>
<li>Implement service-level caching</li>
<li>Consider microservices for heavy operations</li>
</ul>
<h2 id="the-scaling-checklist">The Scaling Checklist</h2>
<p>Before adding complexity, verify you’ve done these:</p>
<p>□ Optimized database queries (select_related, prefetch_related)</p>
<p>□ Added proper database indexes</p>
<p>□ Implemented view and template caching</p>
<p>□ Moved static/media files to CDN</p>
<p>□ Set up monitoring and alerting</p>
<p>□ Configured connection pooling</p>
<p>□ Implemented background tasks for heavy operations</p>
<p>□ Added read replicas for heavy read loads</p>
<p>□ Set up proper logging and error tracking</p>
<p>Remember: Django can handle more load than most people think when properly optimized. Start simple, measure everything, and scale what actually needs scaling.</p>
<p>The best scaling strategy isn’t adding more resources - it’s eliminating waste in your existing ones.</p> <a href="http://tinylogger.com/">
Build Faster
</a> </article>  </div></div>
  </body>
</html>
