<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://prog21.dadgum.com/23.html">Original</a>
    <h1>Is it possible to write games like Pac-Man in a functional language? (2008)</h1>
    
    <div id="readability-page-1" class="page"><div id="c1"><p>When I started looking into functional languages in 1998, I had just come off a series of projects writing video games for underpowered hardware: Super Nintendo, SEGA Saturn, early PowerPC-based Macintoshes without any graphics acceleration.  My benchmark for usefulness was &#34;Can a programming language be used to write complex, performance intensive video games?&#34;   </p><p>After working through basic tutorials, and coming to grips with the lack of destructive updates, I started thinking about how to write trivial games, like Pac-Man or Defender, in a purely functional manner.  Then I realized that it wasn&#39;t performance that was the issue, it was much more fundamental.</p><p><i>I had no idea how to structure the most trivial of games without using destructive updates.</i></p><p>Pac-Man is dead simple in any language that fits the same general model as C.  There are a bunch of globals representing the position of Pac-Man, the score, the level, and so on.  Ghost information is stored in a short array of structures.  Then there&#39;s an array representing the maze, where each element is either a piece of the maze or a dot.  If Pac-Man eats a dot, the maze array is updated.  If Pac-Man hits a blue ghost, that ghost&#39;s structure is updated to reflect a new state.  There were dozens and dozens of Pac-Man clones in the early 1980s, including tiny versions that you could type in from a magazine.</p><p>In a purely functional language, none of this works.  If Pac-Man eats a dot, the maze can&#39;t be directly updated.  If Pac-Man hits a blue ghost, there&#39;s no way to directly change the state of the ghost.  How could this possibly work?</p><p>That was a long time ago, and I&#39;ve spent enough time with functional languages to have figured out how to implement non-trivial, interactive applications like video games.  My plan is to cover this information in a short series of entries.  I&#39;m sticking with 8-bit retrogames because they&#39;re simple and everyone knows what Pac-Man looks like.  I don&#39;t want to use abstract examples involving hypothetical game designs.  I&#39;m also sticking with purely functional programming language features, because that&#39;s the challenge.  I know that ML has references and that processes in Erlang can be used to mimic objects, but if you go down that road you might as well be using C.</p><p>The one exception to &#34;purely functional&#34; is that I don&#39;t care about trying to make I/O fit a functional model.  In a game, there are three I/O needs: input from the user, a way to render graphics on the screen, and a real-time clock.  Fortunately, these only matter at the very highest level outer loop, one that looks like:</p><pre>repeat forever {
   get user input
   process one frame
   draw everything on the screen
   wait until a frame&#39;s worth of time has elapsed
}</pre><p>&#34;Process one frame&#34; is the interesting part.  It takes the current game state and user input as parameters and returns a new game state.  Then that game state can be used for the &#34;draw everything&#34; step.  &#34;Draw everything&#34; can also be purely functional, returning an abstract list of sprites and coordinates, a list that can be passed directly to a lower level, and inherently impure, function that talks to the graphics hardware.</p><p>An open question is &#34;Is being purely functional, even excepting I/O, worthwhile?&#34;  Or is it, as was suggested to me via email earlier this year, the equivalent of writing a novel without using the letter &#39;e&#39;?</p><p><a href="https://prog21.dadgum.com/24.html">Part 2</a></p><p><a href="https://prog21.dadgum.com/23.html" id="perm">permalink</a> <i>April 12, 2008</i></p><ul><li><a href="https://prog21.dadgum.com/22.html">My Road to Erlang</a></li><li><a href="https://prog21.dadgum.com/21.html">Slumming with BASIC Programmers</a></li><li><a href="https://prog21.dadgum.com/20.html">In Praise of Non-Alphanumeric Identifiers</a></li><li><a href="https://prog21.dadgum.com/19.html">Five Memorable Books About Programming</a></li><li><a href="https://prog21.dadgum.com/18.html">Back to the Basics of Functional Programming</a></li></ul></div></div>
  </body>
</html>
