<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://emschwartz.me/short-circuiting-correlated-subqueries-in-sqlite/">Original</a>
    <h1>Short-Circuiting Correlated Subqueries in SQLite</h1>
    
    <div id="readability-page-1" class="page"><div>
    

    

    
        

        <p>
            <i>
                <time datetime="2025-12-17T11:30Z">
    17 Dec, 2025
</time>
            </i>
        </p>
    

    <p>I recently added domain exclusion lists and paywalled content filtering to <a href="https://scour.ing">Scour</a>. This blog post describes a small but useful SQL(ite) query optimization I came across between the first and final drafts of these features: using an uncorrelated scalar subquery to skip a correlated subquery (if you don&#39;t know what that means, I&#39;ll explain it below).</p>
<p>Scour searches noisy sources for content related to users&#39; interests. At the time of writing, it ingests between 1 and 3 million pieces of content from over 15,000 sources each month. For better and for worse, Scour does ranking on the fly, so the performance of the ranking database query directly translates to page load time.</p>
<h2 id="the-ranking-sql-query">The Ranking SQL Query</h2><p>The main SQL query Scour uses for ranking applies a number of filters and streams the item embeddings through the application code for scoring.</p>
<p>Scour uses brute force search rather than a vector database, which works well enough for now because of three factors:</p>
<ol>
<li>Scour uses SQLite, so the data is colocated with the application code.</li>
<li>It uses <a href="https://emschwartz.me/binary-vector-embeddings-are-so-cool/">binary-quantized vector embeddings</a> with <a href="https://emschwartz.me/unnecessary-optimization-in-rust-hamming-distances-simd-and-auto-vectorization/">Hamming Distance comparisons, which only take ~5 nanoseconds each</a>.</li>
<li>We care most about recent posts so we can significantly narrow the search set by publish date.</li>
</ol>
<p>A simplified version of the query looks something like:</p>
<div><pre><span></span><span>SELECT</span><span> </span><span>*</span>
<span>FROM</span><span> </span><span>items</span><span> </span><span>i</span>
<span>WHERE</span><span> </span><span>i</span><span>.</span><span>lang</span><span> </span><span>IN</span><span> </span><span>(</span><span>SELECT</span><span> </span><span>lang</span><span> </span><span>FROM</span><span> </span><span>user_languages</span><span> </span><span>WHERE</span><span> </span><span>user_id</span><span> </span><span>=</span><span> </span><span>?</span><span>1</span><span>)</span>
<span>AND</span><span> </span><span>i</span><span>.</span><span>published</span><span> </span><span>BETWEEN</span><span> </span><span>?</span><span>2</span><span> </span><span>AND</span><span> </span><span>?</span><span>3</span>
<span>AND</span><span> </span><span>...(</span><span>more</span><span> </span><span>filters</span><span>)...</span>
</pre></div>
<p>The query plan shows that this makes good use of indexes:</p>
<div><pre><span></span>QUERY PLAN
   |--SEARCH i USING INDEX idx_items_lang_published (lang=? AND published&gt;? AND published&lt;?)
   `--LIST SUBQUERY 1
      `--SEARCH user_languages USING COVERING INDEX sqlite_autoindex_user_languages_1 (user_id=?)
</pre></div>
<h2 id="domain-filters-using-correlated-subqueries">Domain Filters Using Correlated Subqueries</h2><p>To add user-specified domain blocklists, I created the <code>user_excluded_domains</code> table and added this filter clause to the main ranking query:</p>
<div><pre><span></span><span>AND</span><span> </span><span>NOT</span><span> </span><span>EXISTS</span><span> </span><span>(</span>
<span>    </span><span>SELECT</span><span> </span><span>1</span>
<span>    </span><span>FROM</span><span> </span><span>user_excluded_domains</span><span> </span><span>ued</span>
<span>    </span><span>WHERE</span><span> </span><span>user_id</span><span> </span><span>=</span><span> </span><span>?</span><span>1</span>
<span>    </span><span>AND</span><span> </span><span>ued</span><span>.</span><span>domain</span><span> </span><span>=</span><span> </span><span>i</span><span>.</span><span>domain</span>
<span>)</span>
</pre></div>
<p>The domain exclusion table uses <code>(user_id, domain)</code> as a primary key, so the lookup is efficient. However, this lookup is done for <em>every row</em> returned from the first part of the query. This is a <em>correlated subquery</em>:</p>
<div><pre><span></span>QUERY PLAN
   |--SEARCH i USING INDEX idx_items_lang_published (lang=? AND published&gt;? AND published&lt;?)
   |--LIST SUBQUERY 1
   |  `--SEARCH user_languages USING COVERING INDEX sqlite_autoindex_user_languages_1 (user_id=?)
   `--CORRELATED SCALAR SUBQUERY 2
      `--SEARCH ued USING COVERING INDEX sqlite_autoindex_user_excluded_domains_1 (user_id=? AND domain=?)
</pre></div>
<h2 id="short-circuiting-correlated-subqueries">Short-Circuiting Correlated Subqueries</h2><p>A problem with the way we just added this feature is that most users don&#39;t exclude any domains, but we&#39;ve added a check that is run for every row anyway.</p>
<p>To speed up the queries for users who aren&#39;t using the feature, we could first check the user&#39;s settings and then dynamically build the query. But we don&#39;t have to, because we can accomplish the same effect within one static query.</p>
<p>We can change our domain exclusion filter to first check whether the user has <em>any</em> excluded domains:</p>
<div><pre><span></span><span>AND</span><span> </span><span>(</span>
<span>    </span><span>NOT</span><span> </span><span>EXISTS</span><span> </span><span>(</span>
<span>        </span><span>SELECT</span><span> </span><span>1</span>
<span>        </span><span>FROM</span><span> </span><span>user_excluded_domains</span>
<span>        </span><span>WHERE</span><span> </span><span>user_id</span><span> </span><span>=</span><span> </span><span>?</span><span>1</span>
<span>    </span><span>)</span>
<span>    </span><span>OR</span><span> </span><span>NOT</span><span> </span><span>EXISTS</span><span> </span><span>(</span>
<span>           </span><span>SELECT</span><span> </span><span>1</span>
<span>           </span><span>FROM</span><span> </span><span>user_excluded_domains</span><span> </span><span>ued</span>
<span>           </span><span>WHERE</span><span> </span><span>user_id</span><span> </span><span>=</span><span> </span><span>?</span><span>1</span>
<span>           </span><span>AND</span><span> </span><span>ued</span><span>.</span><span>domain</span><span> </span><span>=</span><span> </span><span>i</span><span>.</span><span>domain</span>
<span>    </span><span>)</span>
<span>)</span>
</pre></div>
<p>Since the <code>OR</code> short-circuits, if the first <code>NOT EXISTS</code> returns <code>true</code> (when the user has no excluded domains), SQLite never evaluates the correlated subquery at all.</p>
<p>The first <code>NOT EXISTS</code> clause does not reference any column in <code>items</code>, so SQLite can evaluate it once and reuse the boolean result for all of the rows. This &#34;uncorrelated scalar subquery&#34; is extremely cheap to evaluate and, when it returns <code>true</code>, lets us short-circuit and skip the more expensive correlated subquery that checks each item&#39;s domain against the exclusion list.</p>
<p>Here is the query plan for this updated query. Note how the second subquery says <code>SCALAR SUBQUERY</code>, whereas the third one is a <code>CORRELATED SCALAR SUBQUERY</code>. The latter is the per-row check, but it can be skipped by the second subquery.</p>
<div><pre><span></span>QUERY PLAN
   |--SEARCH i USING INDEX idx_items_lang_published (lang=? AND published&gt;? AND published&lt;?)
   |--LIST SUBQUERY 1
   |  `--SEARCH user_languages USING COVERING INDEX sqlite_autoindex_user_languages_1 (user_id=?)
   |--SCALAR SUBQUERY 2
   |  `--SEARCH user_excluded_domains USING COVERING INDEX sqlite_autoindex_user_excluded_domains_1 (user_id=?)
   `--CORRELATED SCALAR SUBQUERY 3
      `--SEARCH ued USING COVERING INDEX sqlite_autoindex_user_excluded_domains_1 (user_id=? AND domain=?)
</pre></div>
<h2 id="benchmarking">Benchmarking</h2><p>To test the performance of each of these queries, I replaced the <code>SELECT *</code> with <code>SELECT COUNT(*)</code> and used a simple bash script to invoke the <code>sqlite3</code> binary 100 times for each query on my laptop. Starting up the <code>sqlite3</code> process each time adds overhead, but we&#39;re comparing relative differences.</p>
<p>At the time of this benchmark, the last week had 235,975 items, 144,229 of which were in English. The two example users I tested this for below only look for English content.</p>
<h3 id="user-without-excluded-domains">User Without Excluded Domains</h3><p>This test represents most users, who have not configured any excluded domains:</p>
<table>
<thead>
<tr>
  <th>Approach</th>
  <th>Min (ms)</th>
  <th>Max (ms)</th>
  <th>Avg (ms)</th>
  <th>Stddev (ms)</th>
  <th>Diff (ms)</th>
  <th>Diff (%)</th>
</tr>
</thead>
<tbody>
<tr>
  <td>Baseline (no filter)</td>
  <td>67</td>
  <td>91</td>
  <td><strong>72.7</strong></td>
  <td>4.7</td>
  <td>—</td>
  <td>—</td>
</tr>
<tr>
  <td>Correlated Subquery</td>
  <td>80</td>
  <td>108</td>
  <td>85.2</td>
  <td>5.5</td>
  <td>+12.5</td>
  <td>+17.1%</td>
</tr>
<tr>
  <td>With Short-Circuit</td>
  <td>69</td>
  <td>91</td>
  <td><strong>72.7</strong></td>
  <td>3.8</td>
  <td>+0</td>
  <td><strong>+0%</strong></td>
</tr>
</tbody>
</table>
<p>This shows that the short-circuit query adds practically no overhead for users without excluded domains, whereas the correlated subquery alone makes queries 17% slower for these users.</p>
<h3 id="user-with-excluded-domains">User with Excluded Domains</h3><p>This test uses an example user that has excluded content from 2 domains:</p>
<table>
<thead>
<tr>
  <th>Approach</th>
  <th>Min (ms)</th>
  <th>Max (ms)</th>
  <th>Avg (ms)</th>
  <th>Stddev (ms)</th>
  <th>Diff (ms)</th>
  <th>Diff (%)</th>
</tr>
</thead>
<tbody>
<tr>
  <td>Baseline (no filter)</td>
  <td>68</td>
  <td>99</td>
  <td>76.2</td>
  <td>7.6</td>
  <td>—</td>
  <td>—</td>
</tr>
<tr>
  <td>Correlated Subquery</td>
  <td>84</td>
  <td>112</td>
  <td><strong>90.5</strong></td>
  <td>6.8</td>
  <td>+14.3</td>
  <td>+18.7%</td>
</tr>
<tr>
  <td>With Short-Circuit</td>
  <td>82</td>
  <td>109</td>
  <td><strong>88.5</strong></td>
  <td>8.1</td>
  <td>+12.3</td>
  <td>+16.1%</td>
</tr>
</tbody>
</table>
<p>In this case, we do need to check each row against the domain filter. But this shows that the short-circuit still adds no overhead on top of the query.</p>
<h2 id="conclusion">Conclusion</h2><p>When using SQL subqueries to filter down result sets, it&#39;s worth thinking about whether each subquery is really needed for most users or most queries. If the check is needed most of the time, this approach won&#39;t help. However if the per-row check isn&#39;t always needed, using an uncorrelated scalar subquery to short-circuit a condition can dramatically speed up the average case with practically zero overhead.</p>
<p>This is extra important because the slow-down from each additional subquery compounds. In this blog post, I described and benchmarked a single additional filter. But this is only one of multiple subquery filters.</p>
<p>Earlier, I also mentioned that users had asked for a way to filter out paywalled content. This works similarly to filtering out content from excluded domains. Some users opt-in to hiding paywalled content. For those users, we check if each item is paywalled. If so, we check if it comes from a site the user has specifically allowed paywalled content from (because they have a subscription). I used the same uncorrelated subquery approach to first check if the feature is enabled for the user and, only then, does SQLite need to check each row.</p>
<p>Concretely, the paywalled content filter subquery looks like:</p>
<div><pre><span></span><span>AND</span><span> </span><span>(</span>
<span>    </span><span>(</span>
<span>        </span><span>SELECT</span><span> </span><span>COALESCE</span><span>(</span><span>hide_paywalled_content</span><span>,</span><span> </span><span>0</span><span>)</span><span> </span><span>=</span><span> </span><span>0</span>
<span>        </span><span>FROM</span><span> </span><span>users</span>
<span>        </span><span>WHERE</span><span> </span><span>user_id</span><span> </span><span>=</span><span> </span><span>?</span><span>1</span>
<span>    </span><span>)</span><span> </span><span>-- note these parentheses are needed so SQLite doesn&#39;t mistakenly think this query is correlated with `items`</span>
<span>    </span><span>OR</span><span> </span><span>COALESCE</span><span>(</span><span>i</span><span>.</span><span>is_paywalled</span><span>,</span><span> </span><span>0</span><span>)</span><span> </span><span>=</span><span> </span><span>0</span>
<span>    </span><span>OR</span><span> </span><span>i</span><span>.</span><span>domain</span><span> </span><span>IN</span><span> </span><span>(</span>
<span>        </span><span>SELECT</span><span> </span><span>domain</span>
<span>        </span><span>FROM</span><span> </span><span>user_paywall_allowed_domains</span>
<span>        </span><span>WHERE</span><span> </span><span>user_id</span><span> </span><span>=</span><span> </span><span>?</span><span>1</span>
<span>    </span><span>)</span>
<span>)</span>
</pre></div>
<p>In short, a trivial uncorrelated scalar subquery can help us short-circuit and avoid a more expensive per-row check when we don&#39;t need it.</p>
<h2 id="appendix-codenot-existscode-vs-codenot-incode-vs-codeleft-joincode">Appendix: <code>NOT EXISTS</code> vs <code>NOT IN</code> vs <code>LEFT JOIN</code></h2><p>There are multiple ways to exclude rows from an SQL query.</p>
<p>Here are the results from the same benchmark I ran above, but with two other ways of checking for whether an item comes from an excluded domain.</p>
<p>The <code>NULL-safe NOT IN</code> version of the query uses the subquery:</p>
<div><pre><span></span><span>...</span>
<span>AND</span><span> </span><span>(</span>
<span>    </span><span>i</span><span>.</span><span>domain</span><span> </span><span>IS</span><span> </span><span>NULL</span>
<span>    </span><span>OR</span><span> </span><span>i</span><span>.</span><span>domain</span><span> </span><span>NOT</span><span> </span><span>IN</span><span> </span><span>(</span>
<span>        </span><span>SELECT</span><span> </span><span>domain</span>
<span>        </span><span>FROM</span><span> </span><span>user_excluded_domains</span>
<span>        </span><span>WHERE</span><span> </span><span>user_id</span><span> </span><span>=</span><span> </span><span>?</span><span>1</span>
<span>    </span><span>)</span>
<span>)</span>
</pre></div>
<p>The <code>LEFT JOIN</code> variation joins <code>items</code> with <code>user_excluded_domains</code> and then checks for <code>NULL</code>:</p>
<div><pre><span></span><span>SELECT</span><span> </span><span>*</span>
<span>FROM</span><span> </span><span>items</span><span> </span><span>i</span>
<span>LEFT</span><span> </span><span>JOIN</span><span> </span><span>user_excluded_domains</span><span> </span><span>ued</span><span> </span><span>on</span><span> </span><span>ued</span><span>.</span><span>user_id</span><span> </span><span>=</span><span> </span><span>?</span><span>1</span><span> </span><span>AND</span><span> </span><span>ued</span><span>.</span><span>domain</span><span> </span><span>=</span><span> </span><span>i</span><span>.</span><span>domain</span>
<span>WHERE</span><span> </span><span>i</span><span>.</span><span>lang</span><span> </span><span>IN</span><span> </span><span>(</span><span>SELECT</span><span> </span><span>lang</span><span> </span><span>FROM</span><span> </span><span>user_languages</span><span> </span><span>WHERE</span><span> </span><span>user_id</span><span> </span><span>=</span><span> </span><span>?</span><span>1</span><span>)</span>
<span>AND</span><span> </span><span>i</span><span>.</span><span>published</span><span> </span><span>BETWEEN</span><span> </span><span>?</span><span>2</span><span> </span><span>AND</span><span> </span><span>?</span><span>3</span>
<span>AND</span><span> </span><span>ued</span><span>.</span><span>domain</span><span> </span><span>IS</span><span> </span><span>NULL</span>
</pre></div>
<p>And here are the full benchmarks:</p>
<h3 id="user-without-excluded-domains">User Without Excluded Domains</h3><table>
<thead>
<tr>
  <th>Approach</th>
  <th>Min (ms)</th>
  <th>Max (ms)</th>
  <th>Avg (ms)</th>
  <th>Stddev (ms)</th>
  <th>Diff (ms)</th>
  <th>Diff (%)</th>
</tr>
</thead>
<tbody>
<tr>
  <td>Baseline (no filter)</td>
  <td>67</td>
  <td>91</td>
  <td>72.7</td>
  <td>4.7</td>
  <td>—</td>
  <td>—</td>
</tr>
<tr>
  <td>NOT EXISTS (no short-circuit)</td>
  <td>80</td>
  <td>108</td>
  <td>85.2</td>
  <td>5.5</td>
  <td>+12.5</td>
  <td>+17.1%</td>
</tr>
<tr>
  <td><strong>NOT EXISTS + short-circuit</strong></td>
  <td><strong>69</strong></td>
  <td><strong>91</strong></td>
  <td><strong>72.7</strong></td>
  <td><strong>3.8</strong></td>
  <td><strong>+0</strong></td>
  <td><strong>+0%</strong></td>
</tr>
<tr>
  <td>NULL-safe NOT IN (no short-circuit)</td>
  <td>75</td>
  <td>111</td>
  <td>79.5</td>
  <td>7.1</td>
  <td>+6.8</td>
  <td>+9.3%</td>
</tr>
<tr>
  <td>NULL-safe NOT IN + short-circuit</td>
  <td>69</td>
  <td>103</td>
  <td>74.8</td>
  <td>6.6</td>
  <td>+2.1</td>
  <td>+2.8%</td>
</tr>
<tr>
  <td>LEFT JOIN (no short-circuit)</td>
  <td>74</td>
  <td>100</td>
  <td>79.1</td>
  <td>5.1</td>
  <td>+6.4</td>
  <td>+8.8%</td>
</tr>
<tr>
  <td>LEFT JOIN + short-circuit</td>
  <td>76</td>
  <td>103</td>
  <td>84.4</td>
  <td>7.4</td>
  <td>+11.7</td>
  <td>+16.0%</td>
</tr>
</tbody>
</table>
<p>For users without excluded domains, we can see that the <code>NOT EXISTS</code> query using the short-circuit wins and adds no overhead.</p>
<h3 id="user-with-excluded-domains">User With Excluded Domains</h3><table>
<thead>
<tr>
  <th>Approach</th>
  <th>Min (ms)</th>
  <th>Max (ms)</th>
  <th>Avg (ms)</th>
  <th>Stddev (ms)</th>
  <th>Diff (ms)</th>
  <th>Diff (%)</th>
</tr>
</thead>
<tbody>
<tr>
  <td>Baseline (no filter)</td>
  <td>68</td>
  <td>99</td>
  <td>76.2</td>
  <td>7.6</td>
  <td>—</td>
  <td>—</td>
</tr>
<tr>
  <td>NOT EXISTS (no short-circuit)</td>
  <td>84</td>
  <td>112</td>
  <td>90.5</td>
  <td>6.8</td>
  <td>+14.3</td>
  <td>+18.7%</td>
</tr>
<tr>
  <td><strong>NOT EXISTS + short-circuit</strong></td>
  <td><strong>82</strong></td>
  <td><strong>109</strong></td>
  <td><strong>88.5</strong></td>
  <td><strong>8.1</strong></td>
  <td><strong>+12.3</strong></td>
  <td><strong>+16.1%</strong></td>
</tr>
<tr>
  <td>NULL-safe NOT IN (no short-circuit)</td>
  <td>83</td>
  <td>112</td>
  <td>89.7</td>
  <td>8.4</td>
  <td>+13.5</td>
  <td>+17.7%</td>
</tr>
<tr>
  <td>NULL-safe NOT IN + short-circuit</td>
  <td>84</td>
  <td>112</td>
  <td>91.3</td>
  <td>8.2</td>
  <td>+15.1</td>
  <td>+19.8%</td>
</tr>
<tr>
  <td><strong>LEFT JOIN (no short-circuit)</strong></td>
  <td><strong>81</strong></td>
  <td><strong>107</strong></td>
  <td><strong>86.3</strong></td>
  <td><strong>6.7</strong></td>
  <td><strong>+10.1</strong></td>
  <td><strong>+13.2%</strong></td>
</tr>
<tr>
  <td>LEFT JOIN + short-circuit</td>
  <td>82</td>
  <td>126</td>
  <td>89.8</td>
  <td>7.7</td>
  <td>+13.6</td>
  <td>+17.8%</td>
</tr>
</tbody>
</table>
<p>For users who do have excluded domains, the <code>LEFT JOIN</code> is faster than the <code>NOT EXISTS</code> version. However, this version raises the exact problem this whole blog post is designed to address. Since joins happen no matter what, we cannot use the short-circuit to avoid the overhead for users without excluded domains. At least for now, this is why I&#39;ve gone with the <code>NOT EXISTS</code> subquery using the short-circuit.</p>
<hr/>
<p>Discuss on <a href="https://news.ycombinator.com/item?id=46300776">Hacker News</a>, <a href="https://lobste.rs/s/lfd78r/short_circuiting_correlated_subqueries">Lobsters</a>, <a href="https://www.reddit.com/r/programming/comments/1pou7p8/shortcircuiting_correlated_subqueries_in_sqlite/">r/programming</a>, <a href="https://www.reddit.com/r/sqlite/comments/1pou80l/shortcircuiting_correlated_subqueries_in_sqlite/">r/sqlite</a>.</p>
<hr/>


    

    
        
            <p>
                
                
                    <a rel="nofollow" href="https://emschwartz.me/blog/?q=scour">#scour</a>
                
            </p>
        

        
            <form id="upvote-form" action="/upvote/" method="post">
    <small>
        
        

        
    </small>        
</form>


        

        
            
        
    


  </div></div>
  </body>
</html>
