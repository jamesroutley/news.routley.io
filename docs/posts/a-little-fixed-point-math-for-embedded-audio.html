<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jamesmunns.com/blog/fixed-point-math/">Original</a>
    <h1>A little fixed point math for embedded audio</h1>
    
    <div id="readability-page-1" class="page"><div>
            
<div>
  
  <p><span>2022-04-26</span></p><hr/>
  <p>Recently, I wanted to generate some sounds for <a href="https://jamesmunns.com/blog/mnemos-initial-release/">MnemOS</a>, and I wanted it to go fast.</p>
<p>This is a little mini-blog post describing how I did that using fixed point math, and reduced the total CPU usage to about 20% of the original amount.</p>

<p>I wanted to generate a sine wave to play out of a speaker on my small embedded device. My end goal was to generate 44.1kHz PCM samples, which meant I needed to generate 44100 <code>i16</code>s per second.</p>
<p>I also needed to generate stereo audio, but for now, I just play the same sine wave on both channels.</p>
<p>In embedded Rust, the core library doesn&#39;t actually link in routines for things like <code>sin</code> operations.</p>
<p>This means that typically you have two choices to &#34;provide&#34; these operations:</p>
<ol>
<li>The <a href="https://docs.rs/libm"><code>libm</code></a> crate, which provides very accurate implementations of math operations like <code>sin</code>, but is often (relatively) slow, and the code size is (relatively) large, as these are fit for very low error rate calculations.</li>
<li>The <a href="https://docs.rs/micromath/"><code>micromath</code></a> crate, which provides reasonable approximations of many operations like <code>sin</code>, to some respectable precision (but less precise than <code>libm</code>).</li>
</ol>
<p>Since I knew I didn&#39;t need <em>crazy</em> accurate data, I didn&#39;t even try libm for this. My initial code using <code>micromath</code> looked like this, for generating my sine wave data:</p>
<pre><span>// Generate N samples, interleaving left and right i16 PCM samples
</span><span>for </span><span>(i, dat) in idata.</span><span>chunks_exact_mut</span><span>(</span><span>2</span><span>).</span><span>enumerate</span><span>() {
    </span><span>use </span><span>micromath::F32Ext;
    </span><span>let mut</span><span> value = (i as </span><span>f32</span><span>);
    value *= (</span><span>2.0 </span><span>* core::f32::consts::</span><span>PI </span><span>* </span><span>441.0</span><span>);
    value /= </span><span>44100.0</span><span>;
    </span><span>let</span><span> ival = (value.</span><span>sin</span><span>() * (</span><span>i16</span><span>::</span><span>MAX </span><span>as </span><span>f32</span><span>)) as </span><span>i16</span><span>;
    dat.</span><span>iter_mut</span><span>().</span><span>for_each</span><span>(|</span><span>i</span><span>| *i = ival);
}
</span></pre>
<p>I profiled this on my 64MHz Cortex-M4F CPU, and found it took an acceptable, but not impressive, average of 114 CPU cycles per loop iteration.</p>
<p><strong>This meant that to generate 44100 samples per second, I would spend a total of 5.02M cycles/second generating the audio, out of a total of 64M cycles I had total, which was 7.9% of my entire CPU time.</strong></p>
<p>So instead, I decided to use a slightly different approach, using a phase accumulator, and fixed point math, and a pre-calculated 256-entry look up table.</p>
<p>Generating the sine table was pretty straightforward, I ran this on my desktop, and copy and pasted the output into an array:</p>
<pre><span>// Generate a 256 point sine look up table
</span><span>for</span><span> i in </span><span>0</span><span>..</span><span>256 </span><span>{
    </span><span>let</span><span> val = </span><span>2.0 </span><span>* core::f32::consts::</span><span>PI </span><span>* ((i as </span><span>f32</span><span>) / </span><span>256.0</span><span>);
    </span><span>let</span><span> val = (</span><span>i16</span><span>::</span><span>MAX </span><span>as </span><span>f32</span><span>) * val.</span><span>sin</span><span>();
    print!(&#34;</span><span>{}</span><span>, </span><span>&#34;, val.</span><span>round</span><span>() as </span><span>i16</span><span>);
}
println!();
</span></pre>
<p>That code looked like this:</p>
<pre><span>// A pre-calculated Sine Look Up Table, or LUT.
</span><span>use crate</span><span>::</span><span>SINE_TABLE</span><span>; </span><span>// : [i16; 256];

// We have a sample rate at 44.1kHz. Figure out how many samples it
// will take to play a single loop of our sine wave. For example,
// at 441hz, it will take 100 samples to &#34;traverse&#34; one
// whole sine wave.
</span><span>let</span><span> samp_per_cyc: </span><span>f32 </span><span>= </span><span>44100.0 </span><span>/ </span><span>441.0</span><span>;

</span><span>// The increment is (how many items are in our look up table)
// divided by (how long it takes to go through one look up table)
</span><span>let</span><span> fincr = </span><span>256.0 </span><span>/ samp_per_cyc;

</span><span>// Convert this number to an i32, which we use as a fixed point
// decimal, basically 8bits.24bits, where the 8 bits are which LUT
// position we are currently in, and the 24 bits are like a &#34;decimal&#34;
// describing where we are between the LUT positions
</span><span>let</span><span> incr: </span><span>i32 </span><span>= (((</span><span>1 </span><span>&lt;&lt; </span><span>24</span><span>) as </span><span>f32</span><span>) * fincr) as </span><span>i32</span><span>;

</span><span>// This calculation is based on the current &#34;phase angle&#34; of the sine
// table. This works because we increment our progress through the
// 256 value in our 8.24 fixed point number, and it will wrap around
// correctly whenever we &#34;overflow&#34; (this is a good thing! our sine
// table is the same loop over and over and over and...)
</span><span>let mut</span><span> cur_offset = </span><span>0</span><span>i32</span><span>;

</span><span>// generate the next N samples...
</span><span>idata.</span><span>chunks_exact_mut</span><span>(</span><span>2</span><span>).</span><span>for_each</span><span>(|</span><span>i</span><span>| {
    </span><span>let</span><span> val = cur_offset as </span><span>u32</span><span>;

    </span><span>// Mask off the top 8 bits. This tells us which LUT position
    // we are in
    </span><span>let</span><span> idx_now = ((val &gt;&gt; </span><span>24</span><span>) &amp; </span><span>0xFF</span><span>) as </span><span>u8</span><span>;
    </span><span>// Add one (wrapping), to tell us what the NEXT LUT position is.
    </span><span>let</span><span> idx_nxt = idx_now.</span><span>wrapping_add</span><span>(</span><span>1</span><span>);

    </span><span>// Get the i16 value of the two LUT data points
    </span><span>let</span><span> base_val = </span><span>SINE_TABLE</span><span>[idx_now as </span><span>usize</span><span>] as </span><span>i32</span><span>;
    </span><span>let</span><span> next_val = </span><span>SINE_TABLE</span><span>[idx_nxt as </span><span>usize</span><span>] as </span><span>i32</span><span>;

    </span><span>// Distance to next value - perform 256 slot linear interpolation

    // Here, I take the top 8 bits of the 24 bit &#34;decimal&#34; part of
    // the number. This will be used to interpolate one of
    // 256 positions between the two LUT positions.
    //
    // This is to reduce error between the &#34;steps&#34; of each LUT
    // value in our table
    </span><span>let</span><span> off = ((val &gt;&gt; </span><span>16</span><span>) &amp; </span><span>0xFF</span><span>) as </span><span>i32</span><span>; </span><span>// 0..=255

    // Here, we &#34;weight&#34; each sample based on how close we are at. We
    // multiply this to a total of 256x larger than our original
    // sample, split between how close we are between the two samples.
    // We multiply each, then add them back together
    </span><span>let</span><span> cur_weight = base_val.</span><span>wrapping_mul</span><span>(</span><span>256</span><span>i32</span><span>.</span><span>wrapping_sub</span><span>(off));
    </span><span>let</span><span> nxt_weight = next_val.</span><span>wrapping_mul</span><span>(off);
    </span><span>let</span><span> ttl_weight = cur_weight.</span><span>wrapping_add</span><span>(nxt_weight);

    </span><span>// Our number is now the weighted average of the two LUT samples,
    // but 256x too big. Reduce it down with a right shift operation.
    </span><span>let</span><span> ttl_val = ttl_weight &gt;&gt; </span><span>8</span><span>; </span><span>// div 256

    // Un-sign-extend this back to an i16, to use as a sample
    </span><span>let</span><span> ttl_val = ttl_val as </span><span>i16</span><span>;

    </span><span>// Set the linearly interpolated value to the left and
    // right channel
</span><span>    i.</span><span>iter_mut</span><span>().</span><span>for_each</span><span>(|</span><span>i</span><span>| *i = ttl_val);

    </span><span>// Adjust our phase angle by the &#34;increment&#34; we calculated earlier
</span><span>    cur_offset = cur_offset.</span><span>wrapping_add</span><span>(incr);
});
</span></pre>
<p><strong>When profiling this approach, My average loop time was now down to 22 cycles per iteration, meaning it would now only take me 970.2k CPU cycles per second, or 1.5% of my total CPU time!</strong></p>
<p>I also checked my approximation against the &#34;real&#34; floating point sine operation, and found a maximum error of 0.012% for any <code>i16</code> value, which is more than close enough for my ears!</p>
<p>There&#39;s no long term lesson here, I just wanted to share the technique I used, and explain it a little bit. These approaches are widely used in high performance audio equipment, but I hadn&#39;t found too many clear examples to use when writing my code.</p>

</div>

    
    
    


        </div></div>
  </body>
</html>
