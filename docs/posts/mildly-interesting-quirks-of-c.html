<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://gist.github.com/fay59/5ccbe684e6e56a7df8815c3486568f01">Original</a>
    <h1>Mildly Interesting Quirks of C</h1>
    
    <div id="readability-page-1" class="page"><div>
  <div id="file-quirks-of-c-md">
      
      <div id="file-quirks-of-c-md-readme">
    <article itemprop="text"><p dir="auto">Here&#39;s a list of mildly interesting things about the C language that I learned mostly by consuming Clang&#39;s ASTs. Although surprises are getting sparser, I might continue to update this document over time.</p>
<p dir="auto">There are many more mildly interesting features of C++, but the language is literally known for being weird, whereas C is usually considered smaller and simpler, so this is (almost) only about C.</p>
<h2 dir="auto"><a id="user-content-1-combined-type-and-variablefield-declaration-inside-a-struct-scope-httpsgodboltorggrh94go" aria-hidden="true" href="#1-combined-type-and-variablefield-declaration-inside-a-struct-scope-httpsgodboltorggrh94go"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>1. Combined type and variable/field declaration, inside a struct scope [<a href="https://godbolt.org/g/Rh94Go" rel="nofollow">https://godbolt.org/g/Rh94Go</a>]</h2>
<div dir="auto"><pre><span>struct</span> foo {
   <span>struct</span> bar {
       <span>int</span> x;
   } baz;
};

<span>void</span> <span>frob</span>() {
   <span>struct</span> bar b; <span><span>//</span> &lt;-- defined in body of `struct foo`</span>
}</pre></div>
<h2 dir="auto"><a id="user-content-2-compound-literals-are-lvalues-httpsgodboltorggzup5zb" aria-hidden="true" href="#2-compound-literals-are-lvalues-httpsgodboltorggzup5zb"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>2. Compound literals are lvalues [<a href="https://godbolt.org/g/Zup5ZB" rel="nofollow">https://godbolt.org/g/Zup5ZB</a>]</h2>
<div dir="auto"><pre><span>struct</span> foo {
    <span>int</span> bar;
};

<span>void</span> <span>baz</span>() {
    <span><span>//</span> compound literal:</span>
    <span><span>//</span> https://en.cppreference.com/w/c/language/compound_literal</span>
    (<span>struct</span> foo){};

    <span><span>//</span> these are actually lvalues</span>
    ((<span>struct</span> foo){}).<span>bar</span> = <span>4</span>;
    &amp;(<span>struct</span> foo){};
}</pre></div>
<h2 dir="auto"><a id="user-content-3-switch-cases-anywhere-httpsgodboltorggfsel18" aria-hidden="true" href="#3-switch-cases-anywhere-httpsgodboltorggfsel18"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>3. Switch cases anywhere [<a href="https://godbolt.org/g/fSeL18" rel="nofollow">https://godbolt.org/g/fSeL18</a>]</h2>
<div dir="auto"><pre><span>void</span> <span>foo</span>(<span>int</span> p, <span>char</span>* complicated) {
    <span>switch</span> (p) {
    <span>case</span> <span>0</span>:
        <span>if</span> (complicated[<span>0</span>] == <span><span>&#39;</span>a<span>&#39;</span></span>) {
            <span>if</span> (complicated[<span>1</span>] == <span><span>&#39;</span>b<span>&#39;</span></span>) {
    <span>case</span> <span>1</span>:
                complicated[<span>2</span>] = <span><span>&#39;</span>c<span>&#39;</span></span>;
            }
        }
        <span>break</span>;
    }
}</pre></div>
<p dir="auto">(also see: <a href="https://en.wikipedia.org/wiki/Duff%27s_device" rel="nofollow">Duff&#39;s Device</a>)</p>
<h2 dir="auto"><a id="user-content-4-flexible-array-members-httpsgodboltorgghcjfzx" aria-hidden="true" href="#4-flexible-array-members-httpsgodboltorgghcjfzx"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>4. Flexible array members [<a href="https://godbolt.org/g/HCjfzX" rel="nofollow">https://godbolt.org/g/HCjfzX</a>]</h2>
<div dir="auto"><pre><span>struct</span> flex {
    <span>int</span> count;
    <span>int</span> elems[]; <span><span>//</span> &lt;-- flexible array member</span>
};

<span><span>//</span> this lays out the object exactly as expected</span>
<span>struct</span> flex f = {
    .<span>count</span> = <span>3</span>,
    .<span>elems</span> = {<span>32</span>, <span>31</span>, <span>30</span>}
};

<span>_Static_assert</span>(<span>sizeof</span>(<span>struct</span> flex) == sizeof(<span>int</span>), &#34;&#34;);
<span><span>//</span> sizeof(f) does not include the size of statically-declared elements</span>
<span>_Static_assert</span>(<span>sizeof</span>(f) == sizeof(<span>struct</span> flex), &#34;&#34;);

<span><span>//</span> this only builds because .elems is not initialized:</span>
<span>struct</span> flex g[<span>2</span>];</pre></div>
<h2 dir="auto"><a id="user-content-5-0-as-a-universal-initializer-httpsgodboltorggmpkkxv" aria-hidden="true" href="#5-0-as-a-universal-initializer-httpsgodboltorggmpkkxv"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>5. {0} as a universal initializer [<a href="https://godbolt.org/g/MPKkXv" rel="nofollow">https://godbolt.org/g/MPKkXv</a>]</h2>
<div dir="auto"><pre><span>typedef</span> <span>int</span> <span>empty_array_t</span>[<span>0</span>];
<span>typedef</span> <span>struct</span> {} <span>empty_struct_t</span>;
<span>typedef</span> <span>int</span> <span>array_t</span>[<span>10</span>];
<span>typedef</span> <span>struct</span> { <span>int</span> f; } <span>struct_t</span>;
<span>typedef</span> <span>float</span> <span>vector_t</span> <span>__attribute__</span>((ext_vector_type(<span>4</span>)));

<span><span>//</span> {} can initialize structs and arrays and vectors, but not scalars:</span>
<span>empty_array_t</span> ea = {};
<span>empty_struct_t</span> es = {};
<span>array_t</span> a = {};
<span>struct_t</span> s = {};
<span>vector_t</span> v = {};
<span>void</span>* p = {}; <span><span>//</span> &lt;-- error</span>
<span>int</span> i = {}; <span><span>//</span> &lt;-- error</span>

<span><span>//</span> {0} can initialize any data type, including empty arrays/structs.</span>
<span>empty_array_t</span> eaa = {<span>0</span>};
<span>empty_struct_t</span> ess = {<span>0</span>};
<span>array_t</span> aa = {<span>0</span>};
<span>struct_t</span> bb = {<span>0</span>};
<span>vector_t</span> cc = {<span>0</span>};
<span>void</span>* dd = {<span>0</span>}; <span><span>//</span> &lt;-- happy!</span>
<span>int</span> ee = {<span>0</span>}; <span><span>//</span> &lt;-- happy!</span></pre></div>
<h2 dir="auto"><a id="user-content-6-function-typedefs-httpsgodboltorgg5ctrlv" aria-hidden="true" href="#6-function-typedefs-httpsgodboltorgg5ctrlv"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>6. Function typedefs [<a href="https://godbolt.org/g/5ctrLv" rel="nofollow">https://godbolt.org/g/5ctrLv</a>]</h2>
<div dir="auto"><pre><span>typedef</span> <span>void</span> (*<span>function_pointer_t</span>)(<span>int</span>); <span><span>//</span> &lt;-- this creates a function pointer type</span>
<span>typedef</span> <span>void</span> <span>function_t</span>(<span>int</span>); <span><span>//</span> &lt;-- this creates a function type</span>
<span><span>//</span> function_pointer_t == function_t*</span>

<span>function_t</span> my_func; <span><span>//</span> &lt;-- this declares &#34;void my_func(int)&#34;</span>

<span>void</span> <span>bar</span>() {
    <span>my_func</span>(<span>42</span>);
}</pre></div>
<h2 dir="auto"><a id="user-content-7-array-pointers-httpsgodboltorggn85dvv" aria-hidden="true" href="#7-array-pointers-httpsgodboltorggn85dvv"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>7. Array pointers [<a href="https://godbolt.org/g/N85dvv" rel="nofollow">https://godbolt.org/g/N85dvv</a>]</h2>
<div dir="auto"><pre><span>typedef</span> <span>int</span> <span>array_t</span>[<span>10</span>]; <span><span>//</span> array typedef</span>
<span>typedef</span> <span>array_t</span>* <span>array_ptr_t</span>; <span><span>//</span> array pointer typedef</span>
<span><span>//</span> same as:</span>
<span><span>//</span> typedef int (*array_ptr_t)[10];</span>

<span>void</span> <span>foo</span>(<span>array_ptr_t</span> array_ptr) {
    <span>int</span> x = (*array_ptr)[<span>1</span>];
}

<span>void</span> <span>bar</span>() {
    <span>int</span> arr_10[<span>10</span>];
    <span>foo</span>(&amp;arr_10); <span><span>//</span> &lt;-- yep</span>
    
    <span>int</span> arr_11[<span>11</span>];
    <span>foo</span>(&amp;arr_11); <span><span>//</span> &lt;-- nope</span>
}</pre></div>
<h2 dir="auto"><a id="user-content-8-modifiers-to-array-sizes-in-parameter-definitions-httpsgodboltorgzfnwyus" aria-hidden="true" href="#8-modifiers-to-array-sizes-in-parameter-definitions-httpsgodboltorgzfnwyus"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>8. Modifiers to array sizes in parameter definitions [<a href="https://godbolt.org/z/FnwYUs" rel="nofollow">https://godbolt.org/z/FnwYUs</a>]</h2>
<div dir="auto"><pre><span>void</span> <span>foo</span>(<span>int</span> arr[<span>static</span> <span>const</span> <span>restrict</span> <span>volatile</span> <span>10</span>]) {
    <span><span>//</span> static: the array contains at least 10 elements</span>
    <span><span>//</span> const, volatile and restrict all apply to the array type.</span>
}</pre></div>
<p dir="auto">(corrected by Reddit user /u/romv1)</p>
<h2 dir="auto"><a id="user-content-9-flat-initializer-lists-httpsgodboltorggrmwnog" aria-hidden="true" href="#9-flat-initializer-lists-httpsgodboltorggrmwnog"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>9. Flat initializer lists [<a href="https://godbolt.org/g/RmwnoG" rel="nofollow">https://godbolt.org/g/RmwnoG</a>]</h2>
<div dir="auto"><pre><span>struct</span> foo {
    <span>int</span> x, y;
};

<span>struct</span> lots_of_inits {
    <span>struct</span> foo z[<span>2</span>];
    <span>int</span> w[<span>3</span>];
};

<span><span>//</span> this is probably more typical</span>
<span>struct</span> lots_of_inits init = {
    {{<span>1</span>, <span>2</span>}, {<span>3</span>, <span>4</span>}}, {<span>5</span>, <span>6</span>, <span>7</span>}
};

<span><span>//</span> but braces for inner elements are optional</span>
<span>struct</span> lots_of_inits flat_init = {
    <span>1</span>, <span>2</span>, <span>3</span>, <span>4</span>, <span>5</span>, <span>6</span>, <span>7</span>
};</pre></div>
<h2 dir="auto"><a id="user-content-10-whats-an-lvalue-anyway-httpsgodboltorgg5echfm" aria-hidden="true" href="#10-whats-an-lvalue-anyway-httpsgodboltorgg5echfm"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>10. What’s an lvalue, anyway [<a href="https://godbolt.org/g/5echfM" rel="nofollow">https://godbolt.org/g/5echfM</a>]</h2>
<div dir="auto"><pre><span>struct</span> bitfield {
    <span>unsigned</span> x: <span>3</span>;
};

<span>void</span> <span>foo</span>() {
    <span>int</span> a[<span>2</span>];
    <span>int</span> i;
    <span>const</span> <span>int</span> j;
    <span>struct</span> bitfield bf;

    <span><span>//</span> these are all lvalues</span>
    a; <span><span>//</span> DeclRefExpr &lt;col:5&gt; &#39;int [2]&#39; lvalue Var 0x556800650150 &#39;a&#39; &#39;int [2]&#39;</span>
    i; <span><span>//</span> DeclRefExpr &lt;col:5&gt; &#39;int&#39; lvalue Var 0x56289851bf20 &#39;i&#39; &#39;int&#39;</span>
    j; <span><span>//</span> DeclRefExpr &lt;col:5&gt; &#39;const int&#39; lvalue Var 0x555fc6694ff0 &#39;j&#39; &#39;const int&#39;</span>
    bf.<span>x</span>; <span><span>//</span> MemberExpr &lt;col:5, col:8&gt; &#39;unsigned int&#39; lvalue bitfield .x 0x55dab002de28</span>

    <span><span>//</span> this is not an lvalue</span>
    foo; <span><span>//</span> DeclRefExpr &lt;col:6&gt; &#39;void ()&#39; Function 0x563cb79da098 &#39;foo&#39; &#39;void ()&#39;</span>

    <span><span>//</span> ... but you can&#39;t assign to all of them</span>
    <span><span>//</span> a = (int [2]){1, 2};</span>
    i = <span>4</span>;
    <span><span>//</span> j = 4;</span>
    bf.<span>x</span> = <span>4</span>;

    <span><span>//</span> ... and you can&#39;t take all of their addresses</span>
    &amp;a;
    &amp;i;
    &amp;j;
    <span><span>//</span> &amp;bf.x;</span>
    &amp;foo; <span><span>//</span> but you can take the address of a function, which is not an lvalue</span>

    <span><span>//</span> so, an lvalue is a value that:</span>
    <span><span>//</span> - can have its address taken...</span>
    <span><span>//</span>  - unless it is a bitfield (still an lvalue)</span>
    <span><span>//</span>  - unless it is a function (not an lvalue)</span>
    <span><span>//</span> - can be assigned to...</span>
    <span><span>//</span>  - unless it is an array (still an lvalue)</span>
    <span><span>//</span>  - unless it is a constant (still an lvalue)</span>
}</pre></div>
<h2 dir="auto"><a id="user-content-11-void-globals-httpsgodboltorgzc52wn2" aria-hidden="true" href="#11-void-globals-httpsgodboltorgzc52wn2"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>11. Void globals [<a href="https://godbolt.org/z/C52Wn2" rel="nofollow">https://godbolt.org/z/C52Wn2</a>]</h2>
<div dir="auto"><pre><span><span>//</span> You can declare extern globals to incomplete types,</span>
<span><span>//</span> including `void`.</span>
<span>extern</span> <span>void</span> foo;</pre></div>
<h2 dir="auto"><a id="user-content-12-alignment-implications-of-bitfields-httpsgodboltorgzkmb4cb" aria-hidden="true" href="#12-alignment-implications-of-bitfields-httpsgodboltorgzkmb4cb"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>12. Alignment implications of bitfields [<a href="https://godbolt.org/z/KmB4CB" rel="nofollow">https://godbolt.org/z/KmB4CB</a>]</h2>
<div dir="auto"><pre><span>struct</span> foo {
    <span>char</span> a;
    <span>long</span> b: <span>16</span>;
    <span>char</span> c;
};

<span><span>//</span> `struct foo` has the alignment of its most-aligned member:</span>
<span><span>//</span> `long b` has an alignment of 8...</span>
<span>int</span> alignof_foo = _Alignof(<span>struct</span> foo);

<span><span>//</span> ...but `long b: 16` is a bitfield, and is aligned on a char</span>
<span><span>//</span> boundary.</span>
<span>int</span> offsetof_c = __builtin_offsetof(<span>struct</span> foo, c);</pre></div>
<h2 dir="auto"><a id="user-content-13-static-variables-are-scope-local-httpsgodboltorgzhdclyw" aria-hidden="true" href="#13-static-variables-are-scope-local-httpsgodboltorgzhdclyw"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>13. <code>static</code> variables are scope-local [<a href="https://godbolt.org/z/hdcLYW" rel="nofollow">https://godbolt.org/z/hdcLYW</a>]</h2>
<div dir="auto"><pre><span>int</span> <span>foo</span>() {
    <span>int</span>* a;
    <span>int</span>* b;
    {
        <span>static</span> <span>int</span> foo;
        a = &amp;foo;
    }
    {
        <span>static</span> <span>int</span> foo;
        b = &amp;foo;
    }
    <span><span>//</span> this always returns false: two static variables with the same name</span>
    <span><span>//</span> but declared in different scope refer to different storage.</span>
    <span>return</span> a == b;
}</pre></div>
<h2 dir="auto"><a id="user-content-14-typedef-goes-anywhere-httpsgodboltorgzvzmgha" aria-hidden="true" href="#14-typedef-goes-anywhere-httpsgodboltorgzvzmgha"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>14. Typedef goes anywhere [<a href="https://godbolt.org/z/vZmgha" rel="nofollow">https://godbolt.org/z/vZmgha</a>]</h2>
<div dir="auto"><pre><span>short</span> <span>typedef</span> <span>signed</span> s16;
<span>unsigned</span> <span>int</span> <span>typedef</span> u32;
<span>struct</span> foo { <span>int</span> bar } <span>const</span> <span>typedef</span> baz;

s16 a;
u32 b;
baz c;</pre></div>
<h2 dir="auto"><a id="user-content-15-indexing-into-an-integer-httpsgodboltorgziba5gr" aria-hidden="true" href="#15-indexing-into-an-integer-httpsgodboltorgziba5gr"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>15. Indexing into an integer [<a href="https://godbolt.org/z/IBA5Gr" rel="nofollow">https://godbolt.org/z/IBA5Gr</a>]</h2>
<div dir="auto"><pre><span>int</span> <span>foo</span>(<span>int</span>* ptr, <span>int</span> index) {
    <span><span>//</span> When indexing, the pointer and integer parts</span>
    <span><span>//</span> of the subscript expression are interchangeable.</span>
    <span>return</span> ptr[<span>index</span>] + <span>index</span>[ptr];
    <span><span>//</span> It works this way, according to the standard (§6.5.2.1:2),</span>
    <span><span>//</span> because A[B] is the same as *(A + B), and addition</span>
    <span><span>//</span> is commutative.</span>
}</pre></div>

<h2 dir="auto"><a id="user-content-1-the-power-of-ub-httpsgodboltorggh6mbft" aria-hidden="true" href="#1-the-power-of-ub-httpsgodboltorggh6mbft"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>1. The power of UB [<a href="https://godbolt.org/g/H6mBFT" rel="nofollow">https://godbolt.org/g/H6mBFT</a>]</h2>
<div dir="auto"><pre><span>extern</span> <span>void</span> <span>this_is_not_directly_called_by_main</span>();

<span>static</span> <span>void</span> (*side_effects)() = 0;

<span>void</span> <span>bar</span>() {
    side_effects = this_is_not_directly_called_by_main;
}

<span>int</span> <span>main</span>() {
    <span>side_effects</span>();
}</pre></div>
<p dir="auto">compiles to:</p>
<pre><code>bar:                                    # @bar
        ret
main:                                   # @main
        push    rax
        xor     eax, eax
        call    this_is_not_directly_called_by_main
        xor     eax, eax
        pop     rcx
        ret
</code></pre>
<p dir="auto">Main directly calls <code>this_is_not_directly_called_by_main</code> in this implementation. This happens because:</p>
<ol dir="auto">
<li>LLVM sees that <code>side_effects</code> has only two possible values: NULL (the initial value) or <code>this_is_not_directly_called_by_main</code> (if <code>bar</code> is called)</li>
<li>LLVM sees that <code>side_effects</code> is called, and it is UB to call a null pointer</li>
<li>UB is impossible, so LLVM assumes that <code>bar</code> will have executed by the time <code>main</code> runs rather than face the consequences</li>
<li>Under this assumption, <code>side_effects</code> is always <code>this_is_not_directly_called_by_main</code>.</li>
</ol>
<h2 dir="auto"><a id="user-content-2-a-constant-expression-macro-that-tells-you-if-an-expression-is-an-integer-constant-httpsgodboltorgga41gmx" aria-hidden="true" href="#2-a-constant-expression-macro-that-tells-you-if-an-expression-is-an-integer-constant-httpsgodboltorgga41gmx"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>2. A constant-expression macro that tells you if an expression is an integer constant [<a href="https://godbolt.org/g/a41gmx" rel="nofollow">https://godbolt.org/g/a41gmx</a>]</h2>
<div dir="auto"><pre>#<span>define</span> <span>ICE_P</span>(<span>x</span>) (<span>sizeof</span>(<span>int</span>) == <span>sizeof</span>(*(<span>1</span> ? ((<span>void</span>*)((x) * <span>0l</span>)) : (<span>int</span>*)<span>1</span>)))

<span>int</span> is_a_constant = ICE_P(<span>4</span>);
<span>int</span> is_not_a_constant = ICE_P(is_a_constant);</pre></div>
<p dir="auto">From Martin Uecker, on the Linux kernel ML. <code>__builtin_constant_p</code> does the same thing on Clang and GCC.</p>
<h2 dir="auto"><a id="user-content-3-labels-inside-expression-statements-in-really-weird-places-httpsgodboltorggk9wdrf" aria-hidden="true" href="#3-labels-inside-expression-statements-in-really-weird-places-httpsgodboltorggk9wdrf"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>3. Labels inside expression statements in really weird places [<a href="https://godbolt.org/g/k9wDRf" rel="nofollow">https://godbolt.org/g/k9wDRf</a>]</h2>
<p dir="auto">You can make some pretty weird stuff in C, but for a real disaster, you need C++.</p>
<div dir="auto"><pre><span>class</span> <span>foo</span> {
    <span>int</span> x;

<span>public:</span>
    <span>foo</span>();
};

<span>foo::foo</span>() : x(({ a: <span>4</span>; })) {
    <span>goto</span> a;
}</pre></div>
<p dir="auto">Needless to say, statement expressions are not standard C++ (or standard C), but if your compiler has them, chances are that you can use them in <em>really</em> interesting ways.</p>
</article>
  </div>

  </div>
</div></div>
  </body>
</html>
