<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://logtalk.org/rationale.html">Original</a>
    <h1>Why Logtalk?</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody"><h2 id="why-logtalk">Why Logtalk?</h2>

<p>Logtalk is designed to <em>extend</em> and <em>leverage</em> Prolog. It provides an alternative for Prolog modules, subsuming their functionality, complemented with a comprehensive set of <a href="https://logtalk.org/tools.html">developer tools</a> (several of them state-of-the-art or absent from most Prolog systems). By Prolog modules we assume here the de facto standard module system introduced by Quintus Prolog and adapted by most of the Prolog systems that provide an implementation of modules. Although Prolog systems adapted the original module system introducing several proprietary variations (and consequent severe portability issues), the fundamental characteristics remain:</p>

<ul>
  <li>Designed as a simple solution to hide auxiliary predicates</li>
  <li>Based on a <em>predicate prefixing</em> compilation mechanism</li>
  <li>Reuse based on <em>import/export</em> semantics</li>
  <li>Default importing of module exported predicates when loading a module file</li>
  <li>Strongly biased towards implicit predicate qualification</li>
</ul>

<p>These fundamental characteristics make module systems relatively simple to implement but also effectively prevent extending them to provide several key features present in Logtalk, some of them described here, that support a wide range of code encapsulation and reuse scenarios typically found in applications. Notably, Logtalk enables simple implementations of <a href="https://github.com/LogtalkDotOrg/logtalk3/tree/master/examples/design_patterns">common design patterns</a> that are cumbersome at best using Prolog modules.</p>

<p>Logtalk also fixes some murky predicate semantics found in Prolog, improves some of its key mechanisms, and provides unique <a href="https://logtalk.org/manuals/libraries/index.html">libraries</a>. Note that all advantages described next <em>coexist</em> with Prolog. I.e. Logtalk acts strictly as an <em>add-on</em>. It does not patch or modify Prolog’s own built-in features.</p>

<h3 id="protocols-interfaces">Protocols (interfaces)</h3>

<p>Protocols are first-class entities in Logtalk. Being able to define a protocol (or interface) and provide multiple implementations is key for most design patterns in software engineering and one of the most basic features for an encapsulation mechanism. Its absence in module systems twists practice and leads to non scalable, brittle solutions.</p>

<p>The current and recommended practice with Prolog modules is that <em>exported</em> predicates should not clash and to prefer <code>use_module/1</code> directives over <code>use_module/2</code> directives or explicit module qualification. These recommendations are as convenient (specially for new users) as they are problematic. The first consequence, is that modules, as encapsulation units, are in practice only there to prevent clashes between <em>private</em> predicates. But there isn’t any central authority for modules. Nor is reasonable to expect or demand that programmers all over the world sync before deciding the names of exported predicates when releasing a public module library. Users may also find that newly released libraries clash with their own modules. The preference for <code>use_module/1</code> directives also means that adding a new exported predicate to a module library can cause a module conflict and thus break existing applications that, necessarily, don’t use the new predicate. A common symptom (and workaround) for these issues is prefixing exported module predicates with an abbreviation of the module name to prevent clashes (see e.g. the <code>ordsets</code>, <code>random</code>, or <code>rbtrees</code> modules).</p>

<p>Note that separation of interface and implementation for modules, with multiple modules implementing the same interface, is not a question of finding an hypothetical ingenious solution. The semantics of the <code>:/2</code> module qualification operator and the <code>module/2</code> directive don’t provide the necessary distinction between <em>declaring</em> and <em>defining</em> a predicate.</p>

<h3 id="declaring-a-predicate-vs-defining-a-predicate"><em>Declaring</em> a predicate vs <em>defining</em> a predicate</h3>

<p>Logtalk provides a clear distinction between <em>declaring</em> and <em>defining</em> a predicate and thus clear closed world assumption semantics. Messages or calls for declared but undefined predicates fail. Messages or calls for unknown (not declared) predicates throw an error. Note that this is a fundamental requirement for protocols/interfaces: we must be able to <em>declare</em> a predicate without necessarily <em>defining</em> it.</p>

<p>In contrast, in module systems it’s either a compiler error to try to export a predicate that is not defined or a predicate existence error to try to call an exported predicate that is not defined. The absence of a protocol/interface concept in module systems is sometimes hacked using <code>include/1</code> directives. But that leads to versioning of files instead of versioning of interfaces and does not provide a clean solution that allows two or more modules to implement the same interface as discussed above.</p>

<p>Note that modules are a <em>predicate prefixing</em> solution and thus any call to a module predicate requires it to be defined in the module that is implicit or explicit in the call (otherwise a predicate existence error is generated). There is no predicate <em>lookup</em> that would allow to verify that a predicate is <em>declared</em> prior to calling it or that would allow <em>inheriting</em> a predicate definition.</p>

<h3 id="consistent-predicate-call-semantics">Consistent predicate call semantics</h3>

<p>In Logtalk, implicit message sending, using <code>uses/2</code> directive to resolve the messages, and explicit message sending, using the <code>::/2</code> control construct, have the same semantics for both meta-predicates and non meta-predicates. I.e. using implicit or explicit messages is simply a matter of programming style and programmer preference. For meta-predicates, this results in clear and clean meta-predicate call semantics: meta-arguments are <strong>always</strong> called in the meta-predicate <em>calling context</em>.</p>

<p>Prolog modules, however, provide different semantics for implicit and explicit qualified calls to meta-predicates. Calling a module meta-predicate with implicit qualification (by using <code>use_module/1-2</code> directives) results in the meta-arguments being called in the meta-predicate <em>calling context</em>. But calling the same module meta-predicate using explicit qualification results in the meta-arguments being called in the meta-predicate <em>definition context</em>, not in the <em>calling context</em>.</p>

<p>Consistent predicate call semantics require an implicit and comprehensive execution context that is alien to module systems. In Logtalk, this implicit execution context allows the language runtime to be aware of the <em>calling context</em> and thus fully support not only consist predicate call semantics but also key features such as messages to <em>self</em> and <em>super</em> calls (which must preserve <em>self</em> for correct semantics).</p>

<h3 id="no-predicate-loading-conflicts">No predicate loading conflicts</h3>

<p>Module predicate import/export semantics and the common (and often recommended) practice of using <code>use_module/1</code> directives prevents loading in the same context two modules exporting the same predicate. This means that <strong>any</strong> update that strictly adds new exported predicates to module libraries have the potential to break existing applications. These loading conflicts can only be prevented by using <code>use_module/2</code> directives or resorting to explicit qualification. Preventing these loading conflicts also results in practice in programmers continuously inventing new predicate names instead of reusing existing names that convey the same <em>intention</em>.</p>

<p>In contrast, loading two or more objects that declare the same predicate as public does not create any conflicts as Logtalk does not use the concept of predicates importing/exporting found in Prolog modules and a default implicit predicate importing upon loading. This means e.g. that a Logtalk update that strictly adds new public predicates to its libraries cannot break existing applications as implicit message sending is only possible using <code>uses/2</code> directives. By design, no equivalent to a <code>use_module/1</code> directive is provided.</p>

<h3 id="loading-a-file-vs-using-an-entity"><em>Loading</em> a file vs <em>using</em> an entity</h3>

<p>Logtalk provides a clear separation between loading a file and using an entity. Loading a file does not imply any kind of <em>using</em> relation between existing entities and the entities being loaded. But in Prolog module systems, the <code>use_module/1-2</code> directives take as first argument a specification of a file to be loaded and not a module name (which may or may not be the same as the file basename) and both load the file and import the listed predicates (in case of a <code>use_module/2</code> directive) or all exported predicates of the module being loaded (in case of a <code>use_module/1</code> directive). The <code>ensure_loaded/1</code> directive also takes a file specification as argument but, depending on the Prolog system, it either behaves as <code>use_module/1</code> directive or as a <code>use_module/2</code> directive with an empty list as second argument. The potential problems of the implicit importing of the <code>use_module/1</code> directive have already been discussed.</p>

<h3 id="predicate-names-are-not-owned-by-objects">Predicate names are not owned by objects</h3>

<p>The same predicate name can be a public predicate of any number of objects. This means that object interfaces can use the best possible predicate names, simplifying and minimizing protocols vocabulary, making APIs easy to learn. In contrast, current practice with Prolog modules is that exported predicates should never conflict. But this is not scalable and results with different vocabulary being used for otherwise similar module interfaces. As an example, <code>member/2</code> is a predicate usually exported by a <code>lists</code> module. But <code>member/2</code> is also a good name for e.g. modules representing sets or trees. But the emphasis in implicit qualification using <code>use_module/1</code> directives effectively prevents using the <code>member/2</code> predicate name for anything other than lists.</p>

<h3 id="simple-scope-rules-for-flags">Simple scope rules for flags</h3>

<p>The <code>set_logtalk_flag</code> <strong>directive</strong> is always local to the entity or source file that contains it. Only calls to the <code>set_logtalk_flag</code> <strong>predicate</strong> set the global default value for a flag.</p>

<p>In contrast, some Prolog flags have local scope while others have global scope. Worse, there are differences between Prolog systems that support modules with some flags being local to a module in a system and global in another. A notable case are <code>op/3</code> directives, which are local to modules in some systems and global in others.</p>

<h3 id="enforcement-of-encapsulation">Enforcement of encapsulation</h3>

<p>Most Prolog module systems allow any predicate to be called using explicit qualification. This is usually not an issue when  coding guidelines are enforced by strong team discipline. Logtalk, instead of relying solely in good practices, enforces encapsulation and generates an error on any attempt to call a predicate that is out of scope. Logtalk also prevents using specially crafted meta-predicates to break encapsulation and using code loading order to hack an object or category predicate to become multifile.</p>

<p>Some Prolog module systems also allow a module to change the properties (e.g. dynamic or multifile) of another module predicate (this is partially a consequence of modules being first and foremost a <em>predicate-prefixing mechanism</em>, not an encapsulation solution). Allowing these hacks not only breaks encapsulation but also means that a client of a module cannot be sure that the module predicate properties (and thus the module interface) are not being changed elsewhere. Logtalk detects and prevents these hacks, which result in a compilation error.</p>

<h3 id="strict-compiler">Strict compiler</h3>

<p>Most Prolog compilers are permissive, silently accepting problematic code. The Logtalk compiler is strict and either rejects or warns the user of a <a href="https://logtalk.org/tools.html#lint-checker">large number of code issues</a>, contributing to earlier detection and warning of source code issues.</p>

<h3 id="objects-subsume-modules">Objects subsume modules</h3>

<p>Logtalk objects <em>subsume</em> Prolog modules but the reverse is not true in general. You can’t go from an object solution to a module solution easily or without significant hacking when you’re taking advantage of e.g. inheritance, <em>self</em> and <em>super</em> calls, protocols, or parametric objects. Using a more general solution is worthy by itself and orthogonal to the programming in the small/large perspective.</p>

<p>As Prolog modules <em>are</em> objects, prototypes to be exact, most module-based solution can be easily translated into an object-based solution. So easy in fact that the Logtalk compiler does it for you (minus proprietary stuff that chokes it, which varies from Prolog system to Prolog system; blame lack of standardization).</p>

<div><div><pre><code><span>:- module</span><span>(</span>foo<span>,</span> <span>[</span>bar<span>/</span><span>1</span><span>,</span> baz<span>/</span><span>2</span><span>]).</span>
<span>...</span>
</code></pre></div></div>

<p>or</p>

<div><div><pre><code><span>:- module</span><span>(</span>foo<span>,</span> <span>[]).</span>
<span>:- export</span><span>([</span>bar<span>/</span><span>1</span><span>,</span> baz<span>/</span><span>2</span><span>]).</span>
<span>...</span>
</code></pre></div></div>

<p>is simply interpreted by the Logtalk compiler as:</p>

<div><div><pre><code><span>:- object</span><span>(</span>foo<span>).</span>
<span>    :- public</span><span>([</span>bar<span>/</span><span>1</span><span>,</span> baz<span>/</span><span>2</span><span>]).</span>
    <span>...</span>
<span>:- end_object</span><span>.</span>
</code></pre></div></div>

<p>The Logtalk code is as readable as the module code, provides the same performance, and requires just one more directive, <code>end_object/0</code>, that any decent editor will type for you by expanding an object template. Note, however, that Logtalk does not use a predicate prefixing mechanism and does not provide the predicate exporting semantics found in Prolog modules. Thus, the interpretation of modules as objects is not a just a case of alternative syntax but results in different predicate <strong>usage</strong> semantics: by compiling a Prolog module as a Logtalk object, the exported predicates become public predicates that must be called either using the <code>::/2</code> message sending control construct or using an <code>uses/2</code> directive to list them as implicit messages to the object.</p>

<h3 id="portability">Portability</h3>

<p>Logtalk is written in highly portable code and currently supports <a href="https://logtalk.org/download.html#requirements">15 backend Prolog systems</a>. It can support any Prolog system that complies with official and de facto core standards. Logtalk <a href="https://logtalk.org/manuals/libraries/index.html">libraries</a> and <a href="https://logtalk.org/tools.html">developer tools</a> are also portable. Portability contributes to robustness (by allowing testing with a larger number of Prolog systems) and risk mitigation (by facilitating switching between Prolog systems).</p>

<p>In contrast, the ISO Prolog standard for modules is ignored (for sound reasons) by Prolog implementers. Worse, Prolog systems implementing a module system have significant differences that hinder portability. A few examples:</p>

<ul>
  <li>Ciao Prolog - <code>module/3</code> proprietary directive</li>
  <li>ECLiPSe - no <code>module/2</code> directive</li>
  <li>SICStus Prolog and XSB - no <code>reexport/1-2</code> directives</li>
  <li>ISO standard - no <code>use_module/1-2</code> directives; <code>metapredicate/1</code> instead of <code>meta_predicate/1</code> directive</li>
  <li>Ciao Prolog and SWI-Prolog - operators are local to modules</li>
  <li>SICStus Prolog - operators are global</li>
  <li>XSB - atom-based module system</li>
  <li>ECLiPSe, SICStus Prolog, SWI-Prolog, YAP - predicate-based module system</li>
</ul>

<p>But even when two Prolog systems provide the same syntax constructs, different semantics exist. For example, in ECLiPSe the <code>ensure_loaded/1</code> directive is equivalent to a <code>use_module/2</code> directive with an empty list of imported predicates while in SWI-Prolog the <code>ensure_loaded/1</code> directive is equivalent to a <code>use_module/1</code> directive.</p>

<p>In addition, not all Prolog systems implement modules. Examples include B-Prolog, CxProlog, GNU Prolog, and Qu-Prolog. Logtalk highly portable code works as-is and independently of the presence or absence of a module system.</p>

<h3 id="key-mechanisms">Key mechanisms</h3>

<p>Logtalk provides <strong>fully portable</strong> implementations of key mechanisms to all supported backend Prolog compilers. These include:</p>

<ul>
  <li><a href="https://logtalk.org/manuals/refman/directives/conditional_compilation_directives.html">Conditional compilation</a></li>
  <li><a href="https://logtalk.org/manuals/userman/expansion.html">Term-expansion</a></li>
  <li><a href="https://logtalk.org/manuals/userman/printing.html">Message printing</a></li>
  <li><a href="https://logtalk.org/manuals/userman/printing.html#asking-questions">Question asking</a></li>
  <li><a href="https://logtalk.org/manuals/userman/reflection.html">Reflection</a></li>
</ul>

<p>Conditional compilation directives are found nowadays in most Prolog systems although some implementations are buggy, including in some high profile systems, if you need more than the very basic usage.</p>

<p>The term-expansion mechanism can be traced back to Quintus Prolog. Nevertheless, it is only found in some of the supported systems but with proprietary variations that hinder portability. The Logtalk implementation, besides being portable and working the same in all supported systems, provides improved functionality that subsumes most existing implementations and allows fine control of expansion pipelines.</p>

<p>The message printing mechanism can also be traced back to Quintus Prolog. But it is only supported by some Prolog systems. The Logtalk implementation extends the original implementation by introducing a <em>component</em> argument that allows easy filtering of messages per component in large applications and helps avoiding message term conflicts between components. It also provides support for <em>meta messages</em> avoiding the need of defining grammar rules for translating each and every message as in the original implementation.</p>

<p>The question asking mechanism is original to Logtalk and the dual of the message printing mechanism. It allows abstracting asking questions to a user in the same way that the message printing mechanism abstracts printing messages to the user. It is an uncommon mechanism. But it facilitates abstracting applications input/output interfaces while also allowing common requested features such as logging to be plugged in.</p>

<p>Logtalk provides extensive and portable reflection support that enables developer tools to display and use comprehensive information about applications and their libraries, files, and predicates with full cross-referencing information. All Logtalk developer tools are regular applications using only the public reflection API. In constrast, most Prolog systems support for reflection is either non-existant or limited with tools support often limited to a basic built-in debugger.</p>

<h2 id="why-not-logtalk">Why not Logtalk?</h2>

<p>Logtalk materializes a number of design choices that may not be ideal for some Prolog programming scenarios. Some of them, however, are a consequence of the current compiler/runtime implementation, not the language itself.</p>

<h3 id="increased-startup-times">Increased startup times</h3>

<p>Starting a Logtalk application requires loading both the chosen backend Prolog system and the Logtalk compiler and runtime. This necessarily increases the time it takes to start an application. This may be an issue where very fast startup times are required (of course, this is only meaningful if the applications themselves are small compared with the size of the Logtalk compiler and runtime). Note, however, that the Logtalk compiler and runtime can be precompiled by some Prolog systems for faster loading thus minimizing startup time (e.g. SWI-Prolog supports a Quick Load Format, QLF). The same solution when available can be applied to a Logtalk application.</p>

<h3 id="increased-application-compilation-times">Increased application compilation times</h3>

<p>Currently, Logtalk is implemented as a trans-compiler to Prolog. This means that a Logtalk source file is compiled into an intermediate Prolog source file that in turn is compiled using the chosen backend Prolog compiler, thus potentially increasing application compilation times compared with a Prolog only solution. That said, a portable <em>make</em> tool is provided to limit source file recompilation to only changed files helping minimize compilation time during development. Note that a comparison of application compilation times is only meaningful, however, for applications that don’t take advantage of Logtalk unique features.</p>

<h3 id="compatibility-with-prolog-native-tools">Compatibility with Prolog native tools</h3>

<p>Although Logtalk provides a complete set of <a href="https://logtalk.org/tools.html">developer tools</a>, it only supports <a href="https://logtalk.org/tools.html#third-party-tools">selected</a> native Prolog developer tools.
Complex applications may require using both Logtalk and Prolog tools, demanding that the programmer learns how to be productive with a larger number of tools.</p>

<h3 id="dynamic-binding-performance">Dynamic binding performance</h3>

<p>Logtalk applications making heavy use of dynamic binding may require a backend Prolog compiler with good predicate clause indexing for best performance.</p>

<h3 id="no-implicit-predicate-imports">No implicit predicate imports</h3>

<p>Logtalk favors resilience to changes over convenience and thus does not support implicit predicate imports as in the Prolog <code>use_module/1</code> directive. In objects (and categories), only <code>use_module/2</code> directives (or its Logtalk equivalent, the <code>uses/2</code> directive) can be used. The practical consequence is that you need to use a <code>use_module/2</code> directive for implicitly calling module predicates and a <code>uses/2</code> directive for implicitly sending messages to objects. I.e. you need to either explicitly list the predicates or use explicit message sending. This can make the code a bit more verbose but it also prevents applications from breaking when new library predicates are implemented.</p>

<p>Note: the adapter files for some Prolog systems are able to convert on the fly Prolog <code>use_module/1</code> directives into Logtalk <code>use_module/2</code> directives in some cases. This, however, is not recommended for the reasons stated above and thus is not officially supported.</p>

<h3 id="temporary-files">Temporary files</h3>

<p>The Logtalk compiler generates temporary Prolog files when compiling and loading source files. By default, these temporary files are kept out of the way and automatically deleted. This requires Logtalk to either work from a writable volume or to define the operating-system temporary directory as the scratch directory. As all common operating-systems natively provide a directory for temporary files, this is not considered an actual limitation although it is a worth noting characteristic. Note that running embedded Logtalk applications doesn’t not require any runtime compilation of the application source files (as embedding is accomplished using precompiled code).</p>
</div></div>
  </body>
</html>
