<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://h4x0r.org/big-mac-ro-attack/">Original</a>
    <h1>Recursive macros in C, demystified (once the ugly crying stops)</h1>
    
    <div id="readability-page-1" class="page"><div><article><section><div><p><em>In which it becomes clear, the C Preprocessor was designed by <del>a</del> Kafka <del>fan</del></em></p><p>So you have heard rumors whispered between peers, that a rare few people somehow manage to make compile-time recursion work in C? And you want to have some insight into how that might be possible??</p><p>I should warn you, you‚Äôre risking your sanity‚Ä¶ but I‚Äôll indulge you.</p><p>Wait, did I really just say that? I must be a glutton for punishment, because the macro system is, by far, the thing I like least about C.</p><p>C has many advantages that have led to its longevity (60 years as perhaps the most important language). It has many quirks due to its age, most of which are easy to look past. But despite 30 years writing C, I still bristle at C‚Äôs macro system.</p><p>That‚Äôs not just because there are many languages (including C++) with more modern takes on compile-time execution. Macros appear simple, but have subtleties that make them poorly suited for anything other than light wrappers.</p><p>Still, being C‚Äôs only compile-time execution capability (currently), it is still both critical and important. <em>Critical</em>, in that many venerable critical systems heavily depend on them, and wouldn‚Äôt compile without them. <em>Important</em>, in that it‚Äôs often the only way to abstract out complexity that would lead to safety or security issues if exposed, such as automatically adding sentinels or static type checks.</p><p>C macros being hard to use does discourage their overuse. It‚Äôs easy for too much abstraction to make it too difficult for other people to maintain the code, so in some ways, as painful as they are, I can find some things to appreciate, and do occasionally find reason to use them for something non-trivial.</p><p>But it doesn‚Äôt take much for a macro to be non-trivial, because, while C macros can look like functions, they cannot be called recursively (at least, not easily, as we will see).</p><p>I have never been able to find out <em>why</em> recursion is limited in C macros. It could have started off intentional, but compile time execution wasn‚Äôt really on people‚Äôs minds then; the challenge was abstracting over many platform differences as cheaply as possible.</p><p>I suspect the system evolved as needed in the early days, without really thinking about it as something that perhaps <em>should</em> support recursion. Certainly at some point, the question would get raised; but it‚Äôs easy to imagine:</p><ol><li>The organic evolution of the macro system coupled with early success made it brittle, and hard to evolve.</li><li>People were worried about build issues like hanging compile times due to infinite loops, or crashing with no diagnostics, due to infinite recursion.</li></ol><p>Depending on which of these two was more prominent, I could equally imagine the lack of recursion being an accident, or being an intentional choice.</p><p>However it happened, that die was cast in a completely different era‚Äîpeople have definitely woken up to the value of pushing as much into compile time as possible.</p><p>Either way, it all seems archaic and unnecessary now.</p><p>So, let‚Äôs roll up our sleeves and learn to cope with the issue!</p><h2 id="motivation">Motivation</h2><p>If you have anything interesting you need done with the preprocessor, you probably need to generalize over multiple items.</p><p>Maybe you want to add automatic sanity checks around parameters, or add automatic type checking. You might want to pre-fill arrays, or generate a list of functions based on some data. Generally, we should be able to do such things at compile time, and in cases like type checking, it is often incredibly challenging to defer the work till runtime. So the lack of a good compile time solution for such things is problematic.</p><p>I tend to reach for macros when they can remove the potential for human error; for example, calling an API wrong. That can indeed be adding automatic casts, enforcing that null terminators get added on variable argument arrays, etc.</p><p>In all of those scenarios, we would need something to move macros toward Turing completeness at compile time. But macros do not advertise support for either of the things we‚Äôd be looking for there: <em>iteration</em>, and <em>recursion</em>.</p><p>Thankfully, we can get there. But it‚Äôs not going to be easy.</p><p>To frame our discussion, let‚Äôs pick a simple, but highly valuable goal. We‚Äôre going to build a macro that counts the number of variable arguments in a function-like macro that accepts variable arguments.</p><p>Why that problem? Because from there it‚Äôs a short jump to dealing with some common issues, where we can remove large sources of human error:</p><ol><li>Variadic functions (aka varargs) are error prone, because the implementation has to figure out where the arguments stop; the language doesn‚Äôt give you a way to know. The caller has to remember to follow your convention (like adding a null terminator). And that convention can often back fire, for example, when a null value is a valid argument . Being able to count the number of variadic arguments allows us to provide a <a href="https://h4x0r.org/vargs/">single, general approach to dealing with this,</a> and to not put the burden on the caller to have to count correctly.</li><li>There are plenty of cases where we‚Äôd want to apply a transformation to each argument of a variable argument function, like statically checking that parameters are all the same type, or automatically adding a layer of sanity checking to a third party API, so that the people calling your function can remain blissfully unaware. These don‚Äôt directly require counting, but once we can count recursively, it‚Äôs a small change to give ourselves a more general purpose <code>map</code> construct to make such transformations.</li></ol><p>You might be surprised that the language doesn‚Äôt provide a way to count variable arguments in a macro, especially if you noticed the recent addition of a pre-defined macro called <code>__COUNTER__</code> in the draft C2Y standard. The new <code>__COUNTER__</code> macro is intended to make it easier to provide uniqueness for situations where macros need to generate identifiers and labels; it definitely isn‚Äôt for counting variadic macro arguments.</p><h2 id="apparently-math-is-hard">Apparently math is hard?</h2><p>If there‚Äôs no primitive to count variadic macro arguments, well, we need to create one, right? And if we have to create one, that means it should be pretty easy, one would hope?</p><p>I see you‚Äôre skeptical. But an optimist who wanted to delve into compile-time coding in C for the first time might give it a go. But they will quickly find that the obvious approach below, that feels like it should work, absolutely <em><strong>does not work</strong></em>:</p><div><pre tabindex="0"><code data-lang="java"><span><span><span>// The first macro... counts one argument, then we&#39;d like it to recurse.</span>
</span></span><span><span><span>#</span>define <span>_COUNT_ONE</span>(x, ...) <span>+</span> 1 <span>_COUNT_TOP</span>(__VA_ARGS__)
</span></span><span><span><span>#</span>define <span>_COUNT_TOP</span>(...)    __VA_OPT__(_COUNT_ONE(__VA_ARGS__))
</span></span><span><span><span>#</span>define <span>COUNT</span>(...)        (_COUNT_TOP(__VA_ARGS__) <span>+</span> 0)
</span></span></code></pre></div><p>Try to call this code, and‚Ä¶</p><p>Yup, it‚Äôll barf.</p><p>What this doe-eyed attempt is <em>trying</em> to do, is generate an expression (at compile time) of the form <code>(+ 1 + 1 + ‚Ä¶ + 0)</code>, by iterating over each argument at a call site (via recursion). It doesn‚Äôt care what the arguments are, it just wants to generate a <code>+ 1</code> for each valid argument, and a <code>+ 0</code> at the end, both to make it a valid expression and to handle the case where there are no arguments passed.</p><p>If we‚Äôre successful, the addition will all happen at compile time, and will be what C calls an <em>integer constant expression</em>. That means, the compiler will, at compile time, fold this into a single static integer. So, even if it feels inefficient, there is no run-time cost involved.</p><p>Why three macros? That seems a bit excessive, right?</p><p>Unfortunately, C currently doesn‚Äôt have an easy way to do the equivalent of an <code>if()</code> statement at compile time. It‚Äôs possible to create something with macros, but that‚Äôs just extra hackery.</p><p>Instead, we split the primary body into its own macro‚Äî <code>_COUNT_ONE()</code>, which adds the <code>1 +</code> and then triggers recursion (we wish, anyway; again, the recursion part won‚Äôt work this easily).</p><p>The intent the behind <code>_COUNT_TOP()</code> macro is evaluating an exit condition for our recursion. Specifically, we want to stop when we have no more arguments left in the function. The builtin macro <code>__VA_OPT__()</code> allows us to do exactly that‚Äî the text inside the parentheses gets expanded only if there are arguments. And when there are no arguments, the text inside the parentheses is discarded.</p><p>This gives us a lightweight way to separate the one argument case from the two argument case, without need for a kind of <code>if</code> statement; the 0-case won‚Äôt generate a recursive call. To combine this with <code>_COUNT_ONE()</code>, we‚Äôd need a primitive that allowed us to specify a replacement that only expands when there are <em>no</em> arguments, which doesn‚Äôt come out of the box.</p><p>The outer <code>COUNT()</code> macro could be factored out trivially; I leave it because it keeps what‚Äôs going on a bit clearer. This macro is the actual entry point, adds the ‚Äò0‚Äô a single time the end, and wraps the whole thing in parentheses, which helps avoid running afoul of operator precedence rules.</p><p>If we directly combine it with <code>_COUNT_TOP()</code> in the obvious way, it would compute the right thing, but it would do it by adding the <code>+ 0</code> after EVERY term, and parenthesizing the expression in a way that would come off as odd if you were looking at the resulting C code. For instance, we‚Äôd be aiming for a three argument function to generate:</p><p><code>( + 1 ( + 1 ( + 1 ( + 0 ) + 0 ) + 0 ) + 0 )</code>
If we were to generate this code, it‚Äôd be ugly, but most people would declare success and move on. But unfortunately, the above code does not work, and will never work, no matter how many iterations of the standard are released between now and the heat death of the universe‚Äî changing the behavior would be too likely to impact plenty of real code.</p><p>For example, let‚Äôs attempt to use the above implementation like so:</p><div><pre tabindex="0"><code data-lang="c"><span><span><span>#include</span> <span>&lt;stdio.h&gt;</span><span>
</span></span></span><span><span><span></span>
</span></span><span><span><span>int</span>
</span></span><span><span><span>main</span>()
</span></span><span><span>{
</span></span><span><span>    <span>printf</span>(<span>&#34;COUNT() = %d</span><span>\n</span><span>&#34;</span>, <span>COUNT</span>(<span>1</span>, <span>2</span>, <span>3</span>));
</span></span><span><span>    <span>return</span> <span>0</span>;
</span></span><span><span>}
</span></span></code></pre></div><p>With <code>clang</code>, I get:</p><div><pre tabindex="0"><code data-lang="yaml"><span><span><span>tmp.c:8:30: error</span>: <span>expected &#39;)&#39;</span>
</span></span><span><span>    <span>8</span> <span>|     printf(&#34;COUNT() = %d\n&#34;, COUNT(1, 2, 3));</span>
</span></span><span><span>      <span>|                              ^</span>
</span></span><span><span><span>tmp.c:4:28: note</span>: <span>expanded from macro &#39;COUNT&#39;</span>
</span></span><span><span>    <span>4</span> <span>|</span> <span>#define COUNT(...)        (_COUNT_TOP(__VA_ARGS__) + 0)</span>
</span></span><span><span>      <span>|                            ^</span>
</span></span><span><span><span>tmp.c:3:39: note</span>: <span>expanded from macro &#39;_COUNT_TOP&#39;</span>
</span></span><span><span>    <span>3</span> <span>|</span> <span>#define _COUNT_TOP(...)    __VA_OPT__(_COUNT_ONE(__VA_ARGS__))</span>
</span></span><span><span>      <span>|                                       ^</span>
</span></span><span><span><span>tmp.c:2:32: note</span>: <span>expanded from macro &#39;_COUNT_ONE&#39;</span>
</span></span><span><span>    <span>2</span> <span>|</span> <span>#define _COUNT_ONE(x, ...) + 1 _COUNT_TOP(__VA_ARGS__)</span>
</span></span><span><span>      <span>|                                ^</span>
</span></span><span><span><span>tmp.c:39:30: note</span>: <span>to match this &#39;(&#39;</span>
</span></span><span><span><span>tmp.c:4:27: note</span>: <span>expanded from macro &#39;COUNT&#39;</span>
</span></span><span><span>    <span>4</span> <span>|</span> <span>#define COUNT(...)        (_COUNT_TOP(__VA_ARGS__) + 0)</span>
</span></span></code></pre></div><p>Wow, that‚Äôs a lot of error messages, saying little that makes sense.</p><p>I‚Äôm sure you can already get the feeling that, when you have a problem with your macros, it‚Äôs incredibly challenging to translate the resulting errors into what‚Äôs actually wrong. Here, it‚Äôs complaining about balancing parentheses, and with just a bit more complexity in our macros, it‚Äôd be incredibly easy for someone to spend 10 minutes trying to figure out where the parenthesis is missing, when <em>no parenthesis is missing whatsoever</em>.</p><p>Or, we could have taken advantage of the fact that C is perfectly happy to accept <code>+ + 0</code>, and write <code>1 +</code> instead of <code>+ 1</code>.</p><p>Making that microscopic change, merely transposing two tokens, completely changes the error <code>clang</code> produces:</p><div><pre tabindex="0"><code data-lang="c"><span><span>tmp.c:<span>8</span><span>:</span><span>30</span><span>:</span> error: call to undeclared function <span>&#39;</span>_COUNT_TOP<span>&#39;</span>; ISO C99 and later <span>do</span> not support implicit function declarations [<span>-</span>Wimplicit<span>-</span>function<span>-</span>declaration]
</span></span><span><span>   <span>8</span> <span>|</span>     <span>printf</span>(<span>&#34;COUNT() = %d</span><span>\n</span><span>&#34;</span>, <span>COUNT</span>(<span>1</span>, <span>2</span>, <span>3</span>));
</span></span></code></pre></div><p>Hey, at least that message is concise. Never mind that it‚Äôs <em>totally different</em>, and also <strong>unrelated to the real issue</strong>.</p><h2 id="not-counting-on-it">Not counting on it</h2><p>The C Preprocessor (which I will usually call CPP) is responsible for macro expansion and processing lines with a leading <code>#</code>. As we‚Äôve said, it does not fully support recursion. As you might expect, that‚Äôs the core of the actual problem in our first attempt. Yet, the preprocessor happily thinks it did its job. We‚Äôll see in more detail what‚Äôs going on, but the crux of this particular problem is <em>how</em> recursion is disallowed, not that it IS disallowed.</p><p>The problem here is that C macros are their own programming language, being used to generate C code. The macro language doesn‚Äôt model most of the interesting parts of the language, and it is quite easy to produce code that the preprocessor finds acceptable, that the compiler cannot understand (as we will see).</p><p>In both these cases, the preprocessor feels like it‚Äôs done its job, and passes off its work to the C compiler. The C compiler gets the generated code, and has no idea that macros were used. It calls the error as it sees it.</p><p>This disconnect between the preprocessor and the compiler is one of the things that makes macros in C so unfriendly.</p><p>If a macro expansion (basically the same as an ‚Äòevaluation‚Äô) is recursive, the CPP decides ‚Äúthey can‚Äôt possibly have wanted recursion here, because that might loop forever, so this must be plain old text I have to substitute‚Äù. <em>As a result, the emitted code will still contain the unexpanded macro.</em></p><p>How can we confirm this? If we can‚Äôt understand the resulting transformations, we‚Äôre going to end up stumbling around in the dark.</p><p>Many developers don‚Äôt know how to see what the C preprocessor actually produces. If the preprocessor successfully exits, we <em>can</em> see it‚Äôs output by stopping the compiler after the preprocessing phase, generally with the <code>-E</code> flag. If we don‚Äôt give a file name (via the <code>-o</code> flag), we should see the results on the terminal. And at least in the case of <code>clang</code>, we will even get output up to the point that we did something so wrong that the preprocessor gives us an error.</p><p>For the code above, running <code>cc -E tmp.c</code> works without errors, and dumps the output of CPP to my terminal.</p><p>That consists of a lot of stuff you might not expect to see. The output contains our code after the preprocessor has <em>fully</em> expanded it. But that full expansion includes the results of it preprocessing all of the header files we pulled in, which in our case was <code>stdio.h</code>, and any cascading dependencies it might have.</p><p>However, our code is easy to find in that noise. The last thing output will be our fully translated <code>main()</code> function, ready to be input into the C compiler. For the case where we add <code>+1</code> at the beginning of the macro, we will see:</p><div><pre tabindex="0"><code data-lang="c"><span><span><span>int</span>
</span></span><span><span><span>main</span>()
</span></span><span><span>{
</span></span><span><span>    <span>printf</span>(<span>&#34;COUNT() = %d</span><span>\n</span><span>&#34;</span>, (<span>+</span><span>1</span> <span>_COUNT_TOP</span>(<span>2</span>, <span>3</span>) <span>+</span> <span>0</span>));
</span></span><span><span>    <span>return</span> <span>0</span>;
</span></span><span><span>}
</span></span></code></pre></div><p>Here, the compiler doesn‚Äôt have to try to look up the symbol <code>_COUNT_TOP</code>; it knows that it doesn‚Äôt make sense to have a function call after a number with no operator in between.</p><p>When we reverse the <code>+</code> and the <code>1</code>, the line of code is valid, as long as there‚Äôs a function C can resolve called <code>_COUNT_TOP</code>. Because there isn‚Äôt, the compiler bails.</p><p>That explains why we get two different errors, for such a minor change.</p><p>Because CPP and the compiler itself are oblivious to the execution of the other, and because we have to live with the fact that recursive macros aren‚Äôt errors to the CPP (silently passing them through unexpanded), it‚Äôs quite a bit of work for any compiler to even try to tell you that your problem here is attempting to use recursion in a macro. It could be done, and maybe it <em>should</em> be done, because otherwise, compilers are effectively trying to gaslight you into believing you have a syntax error of some sort.</p><p>Because the preprocessor is much more permissive than the compiler, without the compiler having any awareness of macros even existing is perhaps the most significant reason why writing non-trivial macros is so hard to do.</p><p>Again, we can hack our way around the recursion problem. The semantics are arcane and intricate enough that, even knowing the rules (and doing macro work with a copy of the standard at the ready), macro development is incredibly challenging the second you have any problem at all. Decades later, I often feel like I‚Äôm stumbling around in the dark when a macro I write blows up on me.</p><p>If this is all too intimidating, absolutely we can plagiarize our way to success. Though, personally, I really prefer not to cut-and-paste code from Stack Overflow, especially if it‚Äôs code I don‚Äôt understand. Similarly, while Claude and I are casual acquaintances, I do not trust his code. It‚Äôs my unwillingness to <em>using code I don‚Äôt understand</em> in production that keeps me learning and growing.
Instead, I avoid non-trivial macros, unless (as I said above), I make an exception when they will be a huge net positive for helping the developer, usually by removing potential failure modes, or with significant clarity improvements.
Meaning, if you can use them to provide an abstraction that makes the code more robust, and is also not going to be hard to maintain if the need arises, then I‚Äôd consider it (even if you have to get Claude to write it).
Here, automating size detection statically feels like a good enough use case for my tastes, because macros will not only make variadic functions easier to write, but also make it far easier to call them correctly.</p><p>So, I‚Äôd like to help those interested understand how to navigate through the pain, and shine a light on it, in the hopes that this is another area of the language that the modern standards committee can make massively better.</p><h2 id="that-doesnt-count">That doesn‚Äôt count</h2><p>If we want to know how to circumvent the recursion restriction, we probably need to understand the detection mechanism we are attempting to evade.</p><p>It sure would be nice if we could debug by having our compiler give us intermediate expansions, up until the point that it breaks. This is not directly built into any compiler as far as I know. And my experience with macro debuggers has been that they have a hard time matching compiler semantics. I dusted one of them off when working on this article, and it was easy to get it to expand macros as valid that CPP barfed on, and vice versa.
Despite the lack of tooling, I‚Äôll walk through the expansion process in detail so we can all understand.</p><p>The rules for C macro evaluation are hard to explain in a way that‚Äôs simultaneously precise and clear. But for function-like macros, the main process of evaluating a macro boils down to:</p><ol><li><strong>Replace the macro text.</strong> <em>Stashing aside the arguments used to call the macro</em>, we replace the full macro with the textual body, within the larger token stream we‚Äôre processing.</li><li><strong>Add placeholder tokens.</strong> Instances of ‚Äòarguments‚Äô in the body get replaced with placeholder tokens, to prevent them from being evaluated as macros in any nested argument expansion we might have. This includes <code>__VA_ARGS__</code> and <code>__VA_OPT__()</code> invocations.</li><li><strong>Evaluate preprocessor operators</strong> in the body that take operands , particularly <code>#</code> and <code>##</code>. We don‚Äôt make good use of these operators in this article, so we won‚Äôt cover in too much depth. Note, however, that <code>__VA_OPT__()</code> is also a preprocessor operator that takes arguments. We inhibited expansion within the replacement text, when we were evaluating operators, but at the end of this phase, we put it back; it can get expanded in the next step.</li><li><strong>Rescanning the body</strong>. The body is then scanned for more macros to expand, starting from our cursor in the token stream. The ‚Äúinput‚Äù head moves forward a token at a time, until we mind a macro to expand, or reach the end of the macro we‚Äôre evaluating. When we find a macro to expand, we recursively apply the algorithm.</li></ol><p>There are some pretty large subtleties here. As long as a macro invocation starts in the scope of a rescan, the scanning head position can move past the end of the original macro. For example, consider this basic scenario:</p><div><pre tabindex="0"><code data-lang="c"><span><span><span>#define CONCAT(X, Y)  X ## Y
</span></span></span><span><span><span></span>
</span></span><span><span><span>int</span> PRINT_INT <span>=</span> <span>100</span>;
</span></span><span><span>
</span></span><span><span><span>int</span>
</span></span><span><span><span>main</span>()
</span></span><span><span>{
</span></span><span><span>    <span>printf</span>(<span>&#34;%d</span><span>\n</span><span>&#34;</span>, <span>CONCAT</span>(PRINT_, INT));
</span></span><span><span>}
</span></span></code></pre></div><p>The <code>##</code> operator, seen used in the <code>CONCAT</code> macro, appends two tokens together, turning them into a single preprocessor token.</p><p>When the preprocessor evaluates <code>CONCAT()</code>, it will result in the token <code>PRINT_INT</code>. If <code>PRINT_INT</code> were a macro, the preprocessor would do further expansion. But it is not, so the preprocessor outputs <code>PRINT_INT</code>. The C compiler does not complain, because it sees a variable named <code>PRINT_INT</code>.</p><p>So far, depending on your background, the semantics may or may not being intuitive. But either way, what do you think should happen in this slightly more complex scenario?</p><div><pre tabindex="0"><code data-lang="c"><span><span><span>#define CONCAT(X, Y)  X ## Y
</span></span></span><span><span><span></span>
</span></span><span><span><span>#define PRINT_INT(N)  printf(&#34;look an integer %d\n&#34;, (N));
</span></span></span><span><span><span></span>
</span></span><span><span><span>int</span> PRINT_INT <span>=</span> <span>100</span>;
</span></span><span><span>
</span></span><span><span><span>int</span>
</span></span><span><span><span>main</span>()
</span></span><span><span>{
</span></span><span><span>    <span>printf</span>(<span>&#34;%d</span><span>\n</span><span>&#34;</span>, <span>CONCAT</span>(PRINT_, INT));
</span></span><span><span>    <span>CONCAT</span>(PRINT_,INT)(<span>100</span>);
</span></span><span><span>}
</span></span></code></pre></div><p>It would be reasonable to think there‚Äôs an error here, but this code will compile and run. Why? In both cases, the preprocessor will generate the token <code>PRINT_INT</code>. In the first case, everything will happen the same way it did in our first example, and the compiler will see the variable <code>PRINT_INT</code>.</p><p>But, with the second use of <code>CONCAT</code>, the preprocessor will see that there is a parenthesis immediately following the token <code>PRINT_INT</code>. Since it has a function-like macro with that name, it will prefer the macro interpretation.</p><p>That‚Äôs true, even though we didn‚Äôt directly write <code>PRINT_INT</code> in the code, there. The effective result of the preprocessor‚Äôs expansion would look like this:</p><div><pre tabindex="0"><code data-lang="c"><span><span><span>#define CONCAT(X, Y)  X ## Y
</span></span></span><span><span><span></span>
</span></span><span><span><span>#define PRINT_INT(N)  printf(&#34;look an integer %d\n&#34;, (N));
</span></span></span><span><span><span></span>
</span></span><span><span><span>int</span> PRINT_INT <span>=</span> <span>100</span>;
</span></span><span><span>
</span></span><span><span><span>int</span>
</span></span><span><span><span>main</span>()
</span></span><span><span>{
</span></span><span><span>    <span>printf</span>(<span>&#34;%d</span><span>\n</span><span>&#34;</span>, <span>100</span>);
</span></span><span><span>    <span>printf</span>(<span>&#34;look an integer %d</span><span>\n</span><span>&#34;</span>, <span>100</span>);
</span></span><span><span>}
</span></span></code></pre></div><p>That‚Äôs because C‚Äôs macros come in two flavors, with slightly different semantics:</p><ol><li><em><strong>Function-like macros</strong></em>, which take arguments, and syntactically LOOK like functions. As we see here, if the preprocessor sees a token with the same name as a function like macro, but it‚Äôs not used like a function like macro, it will pass it through, letting the C compiler resolve the token.</li><li><em><strong>Object-like macros</strong></em>, the definitions of which look like variables, and do not take arguments. If the C preprocessor sees a left parenthesis after an object-like macro, that token will just be passed through directly to the compiler.</li></ol><p>That is why the following code does NOT error. In fact, it runs quite happily:</p><div><pre tabindex="0"><code data-lang="bash"><span><span><span>#define OBJECT_LIKE_MACRO printf</span>
</span></span><span><span><span>#include &lt;stdio.h&gt;</span>
</span></span><span><span>int main<span>()</span>
</span></span><span><span><span>{</span>
</span></span><span><span>  OBJECT_LIKE_MACRO<span>(</span><span>&#34;Hello, world!\n&#34;</span><span>)</span>;
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>Meaning, if we we have an object-like macro and it looks like we‚Äôre trying to call it, the C preprocessor isn‚Äôt going to call it. It‚Äôs just going to pass the token through, and let the compiler figure it out.</p><p>As you can see, the preprocessor‚Äôs philosophy is to do its job, and nothing else.</p><p>Another preprocessor subtlety that‚Äôs easy to miss, yet important to understand is:</p><table><tbody><tr><td>‚ÑπÔ∏èÔ∏è</td><td>Arguments to function-like macros are expanded at the call site. For expansions that trigger inside the body where those arguments are used, the contents of the <i>expanded arguments will not be available to be part of any additional expansion.</i></td></tr></tbody></table><p>The preprocessor‚Äôs approach of substituting arguments with placeholder tokens during evaluation is pretty effective at stopping a bunch of accidental recursion that would be non-intuitive. Although, it‚Äôs not the problem for the recursion we‚Äôre trying to solve. The barrier we‚Äôre hitting is a subtlety that we haven‚Äôt discussed yet, but we‚Äôll get to it soon enough.</p><p>Before that, let‚Äôs solidify our understanding by walking through the relevant steps with our invocation of <code>COUNT(1)</code> .</p><table><caption><h2>Big Mac-ro expansion example</h2></caption><tbody><tr><td><asciinema-marker-player src="/asciinema/macro_expansion.cast"></asciinema-marker-player></td></tr></tbody></table><p>We‚Äôve learned that, when <code>COUNT()</code> has an invocation of <code>_COUNT_TOP()</code>, the replacement text cannot lead to recursion. The expansion endures the rescan, and nothing attempts to expand it.</p><p>The rule that‚Äôs preventing the expansion is effectively an explicit anti-recursion rule. Formally, when we replace a macro, that macro is marked as currently being replaced. The mark stays, until that replacement is totally finished, including its rescan.</p><p>And, unfortunately, marked macros are ineligible for replacement. Note the rescan ineligibility is IN THE CALLING ENVIRONMENT. That‚Äôs going to cause us some grief in a few minutes.</p><p>For whatever reason, the original C89 standards committee referred to a macro marked as ineligible for expansion as <em>painted blue</em>.</p><table><tbody><tr><td>‚ùì</td><td>Why the term <em>painted blue</em>? Perhaps the standards committee at the time realized how miserable it was going to make future C developers?
It‚Äôs not a term mentioned in the standard, but is often used when people try to explain the whole process.</td></tr></tbody></table><h2 id="im-blue-because-i-cant-count-on-you">I‚Äôm blue, because I can‚Äôt count on you</h2><p>We <em>can</em> work around the problem, despite there being no way in C to opt out of your macro getting painted blue. But the work-around is going to be hard fought.</p><p>First, let‚Äôs give ourselves a cause to be optimistic: the restriction that‚Äôs preventing <code>_COUNT_TOP()</code> from recursively expanding is relaxed when the second <code>_COUNT_TOP()</code> gets replaced. If, instead, the restriction stayed in full force the entire time we‚Äôve evaluating <code>COUNT()</code>, then you would not be able to do the following:</p><div><pre tabindex="0"><code data-lang="c"><span><span><span>#include</span> <span>&lt;stdio.h&gt;</span><span>
</span></span></span><span><span><span>#define H4X(x) # x </span><span>// convert to string
</span></span></span><span><span><span></span><span>#define DUPE(token) H4X(token) H4X(token)
</span></span></span><span><span><span></span>
</span></span><span><span><span>int</span> 
</span></span><span><span><span>main</span>() {
</span></span><span><span>    <span>printf</span>(<span>&#34;%s</span><span>\n</span><span>&#34;</span>, <span>DUPE</span>(h4x0r));
</span></span><span><span>}
</span></span></code></pre></div><p>But that will absolutely work. The preprocessor will output exactly what I intended:</p><div><pre tabindex="0"><code data-lang="c"><span><span><span>int</span>
</span></span><span><span><span>main</span>()
</span></span><span><span>{
</span></span><span><span>    <span>printf</span>(<span>&#34;%s</span><span>\n</span><span>&#34;</span>, <span>&#34;h4x0r&#34;</span> <span>&#34;h4x0r&#34;</span>);
</span></span><span><span>}
</span></span></code></pre></div><p>In C, two string literals next to each other are merged into a single literal at compile time, so this program prints:</p><p>This leads us to believe that the blue paint wears off when the rescan moves past an expanded macro, after we‚Äôve processed its replacement.</p><p>So our hypothesis right now might be that <code>_COUNT_ONE()</code> expanding inside <code>COUNT()</code> is fine, as long as it happens after the processing head moves past the start of where the macro was, after expansion.</p><p>If that‚Äôs the case, then all we need to do now is add another layer of indirection, right? Let the calling macro evaluate its recursive call on rescan!</p><p>That would make sense! We‚Äôll rewrite our attempt at recursion to add a proxy layer to call <code>_COUNT_TOP()</code>, knowing it cannot re-expand.</p><div><pre tabindex="0"><code data-lang="java"><span><span><span>#</span>define <span>_COUNT_ONE</span>(x, ...) <span>+</span> 1 <span>_COUNT_TOP</span>(__VA_ARGS__)
</span></span><span><span><span>#</span>define <span>_COUNT_TOP</span>(...)    __VA_OPT__(_COUNT_ONE(__VA_ARGS__))
</span></span><span><span><span>#</span>define <span>_COUNT_PROXY</span>(...)  (_COUNT_TOP(__VA_ARGS__) <span>+</span> 0)
</span></span><span><span><span>#</span>define <span>COUNT</span>(...)         _COUNT_PROXY(__VA_ARGS__)
</span></span></code></pre></div><p>We‚Äôd now expect the replacement when our evaluation gets back up to <code>COUNT(1, 2, 3)</code> to look like:</p><div><pre tabindex="0"><code data-lang="java"><span><span>(<span>+</span>1 <span>_COUNT_TOP</span>(2, 3) <span>+</span> 0))
</span></span></code></pre></div><p>So now, we‚Äôre thinking that escaped the paint, and <code>_COUNT_TOP()</code> will further expand, right? ü¶óü¶óü¶ó</p><p>It‚Äôs time to shatter our youthful optimism with the bitter pill of experience. Yes, we‚Äôve added an extra indirection, but here‚Äôs what it expands to:</p><div><pre tabindex="0"><code data-lang="java"><span><span>(<span>+</span>1 <span>_COUNT_TOP</span>(2, 3) <span>+</span> 0))
</span></span></code></pre></div><h2 id="heading-2">ü§Ø</h2><p>That‚Äôs the same as our intermediate expansion, but nothing further was done to the macro! I thought we made our way past the paint?</p><p>Clearly, there are subtleties to the rules somewhere. Clearly, the author is a jerk, and must have intentionally failed to mention it above.</p><p>It‚Äôs true I am a jerk, and it‚Äôs also true that I failed to mention the restriction that‚Äôs biting us right now. That‚Äôs because it‚Äôs a part of the journey‚Äî no tutorial or explanation I‚Äôve ever seen made it clear to me that restrictions on expanded macros can survive past the call site.</p><p>So maybe I‚Äôm just obtuse, and torturing others because I once suffered long ago. Let‚Äôs go look at the relevant text in the C23 standard, shall we? It‚Äôll either be enlightening‚Ä¶ or further torture.</p><table><tbody><tr><td>‚ÑπÔ∏èÔ∏è</td><td><p>After all parameters in the replacement list have been substituted and # and ## processing has taken place, all place-marker preprocessing tokens are removed. The resulting preprocessing token sequence is then rescanned, along with all subsequent preprocessing tokens of the source file, for more macro names to replace.</p><p><strong>If the name of the macro being replaced is found during this scan of the replacement list (not including the rest of the source file‚Äôs preprocessing tokens), it is not replaced.</strong> <i>Furthermore, if any nested replacements encounter the name of the macro being replaced, it is not replaced. These non-replaced macro name preprocessing tokens are no longer available for further replacement even if they are later (re)examined in contexts in which that macro name preprocessing token would otherwise have been replaced.</i></p></td></tr></tbody></table><p>The sentence I bolded, I think we clearly understood; I did explain it above. The two sentences afterward, which I put in italics, is where the restriction that‚Äôs hurting us is specified.</p><p>For <em>years</em>, I took that to mean, ‚ÄúEven at the top level where the macro was called, no matter how many times subsequent replacement text gets rescanned, the called macro is still ineligible for expansion.‚Äù</p><p>What am I doing wrong? Why does the blue paint leave and then come back? This makes no sense. Right? Right?</p><h2 id="heading-3">üò≠üò≠</h2><p>(I warned you, there‚Äôd be ugly crying. Better me than you though; I clearly deserve it).</p><h2 id="close-n-counter">Close n-counter</h2><p>Perhaps it would be obvious to most readers that I had misinterpreted the standard. Perhaps, but even once I finally realized that my original interpretation couldn‚Äôt possibly be right, I still feel the above text from the standard is bit under-specified.</p><p>Specifically, what are the boundaries for ‚Äúnested replacement‚Äù? Clearly it‚Äôs not the case that once a macro is called, a parent of the calling macro can never replace it again. So does it mean, ‚Äúthe resulting text can never, in any way be involved in an expansion which produces an expansion ever again?‚Äù requiring full taint tracking of the replacement through all future transformations as long as the text could possibly be rescanned, no matter what?</p><p>Or, does it only apply to any text with the name of the function we called, and the second that changes, it could change back?</p><p>Or maybe there are some different semantics?</p><p>Let‚Äôs roll up our sleeves, with another little experiment, to help us determine how we should interpret the above test. What we‚Äôd like to see, is, can <code>_COUNT_ONE()</code> produce a macro invocation with a different name, that we <em>don‚Äôt try to expand</em> until after leaving the context in which it and <code>_COUNT_TOP()</code> are painted, and then somehow replace that macro with <code>_COUNT_TOP()</code>?</p><p>If we can make that happen, then we‚Äôll test to see if we can call the resulting function is callable. Let‚Äôs junk our previous experiment, and go back to where we were before:</p><div><pre tabindex="0"><code data-lang="java"><span><span><span>#</span>define <span>_COUNT_ONE</span>(x, ...) <span>+</span> 1 <span>_COUNT_TOP</span>(__VA_ARGS__)
</span></span><span><span><span>#</span>define <span>_COUNT_TOP</span>(...)    __VA_OPT__(_COUNT_ONE(__VA_ARGS__))
</span></span><span><span><span>#</span>define <span>COUNT</span>(...)        (_COUNT_TOP(__VA_ARGS__) <span>+</span> 0)
</span></span></code></pre></div><p>Now, we want to try to change the value of <code>_COUNT_TOP</code> to something else to escape detection. It‚Äôs got to be a valid macro, but one that we‚Äôre NOT going to end up expanding when rescanning <code>_COUNT_ONE()</code> or <code>_COUNT_TOP()</code>. If we call it <code>_COUNT_INDIRECT</code>, we don‚Äôt want <code>_COUNT_INDIRECT(2,3)</code> to evaluate until we pop all the way back up into <code>_COUNT()</code>.</p><p>Sounds like a tall order, but there‚Äôs are a couple of facts we‚Äôve already learned, that can help us:</p><ol><li>We know that, if we have a function-like macro named <code>X()</code>, the preprocessor does not consider a bare <code>X</code> with no parenthesis next to it to be an invocation of <code>X</code>.</li><li>Rescans start at the replacement site, they don‚Äôt back up tokens.</li></ol><p>So perhaps we can separate the function name and the arguments for a while, and somehow bring them together in a way where we could rescan it inside <code>COUNT()</code>.</p><p>Having the function name separate from an argument list will both keep it from running, and will help us avoid a rescan the first time we get the left parenthesis to plop down in the right place.</p><p>We just need a way to add a spacer of some sort that goes away at rescan, to keep apart the name <code>_COUNT_ONE</code> from its argument list. That is, we‚Äôd conceptually like to do:</p><div><pre tabindex="0"><code data-lang="java"><span><span><span>#</span>define <span>_COUNT_ONE</span>(x, ...) <span>\</span>
</span></span><span><span>   <span>+</span> 1 <span>__VA_OPT__</span>(_COUNT_ONE <span>&lt;&lt;</span>SPACER<span>&gt;&gt;</span> (__VA_ARGS__))
</span></span></code></pre></div><p>But we‚Äôre going to change the name of <code>_COUNT_ONE</code> to <code>_COUNT_INDRECT</code>. If we just do:</p><div><pre tabindex="0"><code data-lang="java"><span><span><span>#</span>define _COUNT_INDIRECT _COUNT_ONE
</span></span></code></pre></div><p>Then we‚Äôre going to re-generate <code>_COUNT_ONE</code> on the rescan, which is painted blue.</p><p>So it‚Äôs actually <code>_COUNT_INDIRECT</code> where we currently have the dire need to postpone evaluating it.</p><p>Therefore, we need to turn <code>_COUNT_INDIRECT</code> into a function, and keep THAT identifier separated from the parentheses that trigger it, via our to-be-written spacer. So this is the definition we want instead:</p><div><pre tabindex="0"><code data-lang="java"><span><span><span>#</span>define <span>_COUNT_INDIRECT</span>() _COUNT_ONE
</span></span></code></pre></div><p>We‚Äôll also need to add the empty parameter list to invoke it on the other side of our spacer. So here‚Äôs what we really need <code>_COUNT_ONE</code> to look like:</p><div><pre tabindex="0"><code data-lang="java"><span><span><span>#</span>define <span>_COUNT_ONE</span>(x, ...) <span>\</span>
</span></span><span><span>   <span>+</span> 1 <span>__VA_OPT__</span>(_COUNT_INDIRECT <span>&lt;&lt;</span>SPACER<span>&gt;&gt;</span> ()(__VA_ARGS__))
</span></span></code></pre></div><p>As we cascade up with replacements, we want the spacer to disappear, leaving:</p><p>Remember, in the contents where we replace the spacer, we will have advanced the input head past <code>_COUNT_INDIRECT</code>. So if the spacer expands to nothing, the rescan will know that <code>()</code> isn‚Äôt a replaceable macro, and go on with its day. But it will leave <code>_COUNT_INDIRECT</code> next to the <code>()</code> so it can be called above, to generate the correct name.</p><h2 id="you-can-count-on-me-being-empty-inside">You can count on me being empty inside</h2><p>It‚Äôs not hard to get something to expand to the empty string.</p><p>And then, once we get back up to <code>COUNT()</code>, we will evaluate <code>_COUNT_INDIRECT()</code>, which will leave us with <code>_COUNT_ONE(2,3)</code>.</p><p>Once we get that far, will tinker to find if there are any conditions where we can re-invoke <code>_COUNT_ONE()</code>. Because hey, we already know there are, we just might not know WHAT they are.</p><p>It‚Äôs not hard to create a spacer. We can define a macro named <code>EMPTY</code> like this:</p><p>And use that as our spacer. If you‚Äôve ever peeked into someone‚Äôs recursive macros and been dumbfounded with what you saw, there‚Äôs a good chance you saw a macro named <code>EMPTY</code> and at the time were thinking, ‚Äúwhat the heck could that possibly do?‚Äù</p><p>Now you know. But when you did see it, it was probably defined as a function-like macro instead:</p><p>Using it to postpone evaluation is as easy as:</p><div><pre tabindex="0"><code data-lang="java"><span><span>_COUNT_INDIRECT <span>EMPTY</span>() () (2, 3)
</span></span></code></pre></div><p>Why would we use a function-like macro for our spacer? Doing so makes it easy for us to control how long we want to wait before we‚Äôre able to evaluate what we‚Äôre separating.</p><p>Specifically, let‚Äôs say we nest our recursive call several levels down. Every level, we use the same trick recursively, separating <code>EMPTY()</code> apart‚Ä¶ using another <code>EMPTY()</code> invocation.</p><p>For instance, if we need to postpone a total of three layers, we could write:</p><div><pre tabindex="0"><code data-lang="java"><span><span>_COUNT_INDIRECT EMPTY EMPTY <span>EMPTY</span>() () () () (2, 3)
</span></span></code></pre></div><p>Honestly, <code>EMPTY()</code> is a confusing name that detracts from what‚Äôs happening. we can encapsulate this into a more readable macro‚Ä¶ or macros, one for each level we might want to postpone evaluation:</p><div><pre tabindex="0"><code data-lang="java"><span><span><span>#</span>define <span>POSTPONE1</span>(macro_name, args) macro_name <span>EMPTY</span>() args
</span></span><span><span><span>#</span>define <span>POSTPONE2</span>(macro_name, args) macro_name EMPTY <span>EMPTY</span>()() args
</span></span><span><span><span>#</span>define <span>POSTPONE3</span>(macro_name, args) <span>\</span>
</span></span><span><span>                               macro_name EMPTY EMPTY <span>EMPTY</span>()()() args
</span></span></code></pre></div><p>We‚Äôll only need the first of these by the way; but now you know, if you never have a use case where you have deeper nesting (though if you do, maybe worry your macros are getting too complex to be readable?)</p><p>Our <code>POSTPONE1</code> macro encapsulates the unintuitive <code>EMPTY()</code> madness for us, allowing us to instead write:</p><div><pre tabindex="0"><code data-lang="java"><span><span><span>#</span>define <span>_COUNT_ONE</span>(x, ...) <span>\</span>
</span></span><span><span>                    <span>+</span> 1 <span>__VA_OPT__</span>(POSTPONE1(_COUNT_INDIRECT, ())(__VA_ARGS__))
</span></span></code></pre></div><p>The <code>EMPTY()</code> invocation is hidden inside <code>POSTPONE1()</code> That makes the code we use here, it‚Äôs more explicit that we‚Äôre going to postpone expanding <code>_COUNT_INDIRECT</code>. We‚Äôve even added the args we want to call it with as a second parameter, to make it more clear what we‚Äôre doing, instead of having a bunch of consecutive argument lists detached from their identifier, which many engineers find alien and incomprehensible.</p><p>So far, the rest of what we have is:</p><div><pre tabindex="0"><code data-lang="java"><span><span><span>#</span>define <span>_COUNT_TOP</span>(...)   __VA_OPT__(_COUNT_ONE(__VA_ARGS__))
</span></span><span><span><span>#</span>define <span>COUNT</span>(...)        (_COUNT_TOP(__VA_ARGS__) <span>+</span> 0)
</span></span><span><span><span>#</span>define <span>_COUNT_INDIRECT</span>() _COUNT_ONE
</span></span></code></pre></div><p>Let‚Äôs now see if it is getting the right text up to the top, even though we won‚Äôt yet try to get it to expand (and thus, we will get a compiler error). If we invoke as <code>COUNT(1, 2)</code> again, CPP will generate the following expansion:</p><div><pre tabindex="0"><code data-lang="java"><span><span>(<span>+</span>1 <span>_COUNT_INDIRECT</span> ()(2) <span>+</span> 0)
</span></span></code></pre></div><p>That‚Ä¶ looks exactly like what we were hoping to see. As we wanted, the pieces came together, and <code>_COUNT_INDIRECT()</code> did NOT get evaluated during the rescan process. If we had made a mistake, and the rescan had happened, it would have been replaced with <code>_COUNT_ONE</code>, which we already know we could <em>not</em> trigger for re-evaluation.</p><p>Okay, let‚Äôs now see what happens if we try to force the expansion of the above, to finally get an answer to our question as to the true scope of blue paint.</p><p>Let‚Äôs wrap the body of <code>COUNT()</code> with a call to a passthrough macro, which we‚Äôll name <code>EVAL()</code>:</p><div><pre tabindex="0"><code data-lang="java"><span><span><span>#</span>define <span>EVAL</span>(...)  __VA_ARGS__
</span></span><span><span><span>#</span>define <span>COUNT</span>(...) EVAL((_COUNT_TOP(__VA_ARGS__) <span>+</span> 0))
</span></span></code></pre></div><p>Based on our rules above, <code>EVAL()</code> will substitute, and then rescan. So this passthrough macro forces the rescan we want.</p><p>The test case for our macro should be:</p><div><pre tabindex="0"><code data-lang="c"><span><span><span>#include</span> <span>&lt;stdio.h&gt;</span><span>
</span></span></span><span><span><span></span>
</span></span><span><span><span>int</span>
</span></span><span><span><span>main</span>()
</span></span><span><span>{
</span></span><span><span>    <span>printf</span>(<span>&#34;%d</span><span>\n</span><span>&#34;</span>, <span>COUNT</span>(<span>1</span>, <span>2</span>));
</span></span><span><span>}
</span></span></code></pre></div><p>You might notice, <em>this actually compiles</em>. And if you run it, <em>it gives the right answer</em>.</p><p>Wow, are we done?</p><h3 id="heading-5">ü§£üòÇü§£üòÇü§£üòÇü§£üòÇü§£üòÇü§£üòÇü§£üòÇü§£üòÇü§£üòÇü§£üòÇü§£üòÇü§£üòÇü§£üòÇü§£</h3><p>While we may be farther than expected, we don‚Äôt have something that will fully work. What‚Äôs important is that we‚Äôve shown that blue paint FULLY gets removed from a macro when:</p><ol><li>We have finished all rescans of that macro where it was called; and</li><li>EITHER the macro does not appear in the replacement text, or we completely exit the recursive expansion.</li></ol><p>Unfortunately, we still have a problem. If you change your invocation to <code>COUNT(1, 2, 3)</code> then your code will no longer compile. Instead, it will expand to:</p><div><pre tabindex="0"><code data-lang="java"><span><span>(<span>+</span>1 <span>+</span>1 <span>_COUNT_INDIRECT</span> ()(3) <span>+</span> 0))
</span></span></code></pre></div><p>What‚Äôs happening should be clear at this point: while we are iterating over arguments, we are stopping after the second iteration.</p><p>Great, that‚Äôs easy to fix. We can do so by‚Ä¶</p><p>Passing the output of <code>EVAL()</code> to another call of <code>EVAL()</code>, like so:</p><div><pre tabindex="0"><code data-lang="java"><span><span><span>#</span>define <span>COUNT</span>(...) EVAL(EVAL((_COUNT_TOP(__VA_ARGS__) <span>+</span> 0)))
</span></span></code></pre></div><p>Before we address the obvious complaint, I‚Äôd like to point out that the extra <code>EVAL()</code> doesn‚Äôt mess up the results if we change our test invocation to <code>COUNT()</code> or <code>COUNT(1)</code>.</p><p><code>EVAL()</code> will expand, but it doesn‚Äôt break anything when there are no macros in the text passed to it that are eligible for expansion. Once the last possible expansion happens, it will just keep copying its arguments to the replacement text, per the algorithm above; the associated rescans have nothing to do.</p><p>Given that, it‚Äôs common to say, ‚ÄúNobody needs more than 10 arguments!‚Äù and do something like:</p><div><pre tabindex="0"><code data-lang="java"><span><span><span>#</span>define <span>_E</span>(...) __VA_ARGS__
</span></span><span><span><span>#</span>define <span>EVAL</span>(...) _E(_E(_E(_E(_E(_E(_E(_E(_E(_E(__VA_ARGS__))))))))))
</span></span></code></pre></div><p>Although, more commonly, you‚Äôd probably see people do more expansions, perhaps enough to accommodate 20 or 50 arguments. Even there, I‚Äôve seen some Microsoft APIs that convince me, that‚Äôs too low a limit, so I‚Äôd suggest at least 100 iterations.</p><p>We can use a much smarter approach that can still fairly compactly get us as many expansions as we think we might ever need.</p><p>I‚Äôd guess that, if we saw a function with 1024 arguments, it would be explicitly TRYING to break our macro. So let‚Äôs do the base 2 version of the Spinal Tap ‚Äúone more‚Äù, and get to 1025 expansions:</p><div><pre tabindex="0"><code data-lang="java"><span><span><span>#</span>define <span>_E1</span>(...)    __VA_ARGS__
</span></span><span><span><span>#</span>define <span>_E8</span>(...)    _E1(_E1(_E1(_E1(_E1(_E1(_E1(_E1(__VA_ARGS__))))))))
</span></span><span><span><span>#</span>define <span>_E64</span>(...)   _E8(_E8(_E8(_E8(_E8(_E8(_E8(_E8(__VA_ARGS__))))))))
</span></span><span><span><span>#</span>define <span>_E256</span>(...)  _E64(_E64(_E64(_E64(__VA_ARGS__))))
</span></span><span><span><span>#</span>define <span>_E1024</span>(...) _E256(_E256(_E256(_E256(__VA_ARGS__))))
</span></span><span><span><span>#</span>define <span>EVAL</span>(...)   _E1024(__VA_ARGS__)
</span></span></code></pre></div><p>The last expansion really is gratuitous; we could name <code>_E1024()</code> to<code>EVAL()</code> and stop on the power of two, but what fun is that?</p><p>Before writing this article, I generally stopped at 256 iterations, but I was curious as to whether the compiler‚Äôs CPP was smart enough to skip unnecessary evaluations, given it‚Äôs a common idiom. I ramped the number of iterations up to 65,636, and built a minimal program that would trigger 100 different calls to eval. On a Macbook Pro using <code>clang</code>, that many expansions took .13 seconds; when setting EVAL to 256 expansions, compiling took .06 seconds. When using <code>gcc</code>, both times were a bit more than twice as expensive.</p><p>So no, we definitely shouldn‚Äôt keep going until we get to 2^64; it‚Äôs unlikely to work. But, I‚Äôve never noticed compile time impact due to 256 iterations, even in programs using recursive macros extensively, and can recommend it, but it also seems 2^16 expansions is totally acceptable for cases where you might need it (probably when you‚Äôre iterating over something other than call arguments).</p><p>NOW we can declare victory.</p><p>Hang on, I‚Äôm going to go cry again, but this time tears of joy. üò≠üò≠</p><h3 id="you-can-count-me-out">You can count me out</h3><p>While the <code>EVAL</code>approach works, you may find it feels kludgy. Why ask the preprocessor to do all that additional work? <em>maybe</em> it can recognize the idiom and short-circuit a bunch of work with an <code>EVAL()</code>? Is there really no better way?
There <em>is</em> a technique that facilitates the kind of compile-time recursion we‚Äôre trying to do here, without unnecessary layers of expansion.
The basic idea is related to the concept of <em>continuations</em>; every macro passes a bag of state to the ‚Äònext‚Äô function-like macro that should get called, doing it in a way that allows us to BOTH dodge blue paint, AND terminate without oblivious expansions.
However:</p><ol><li>The approach is MUCH more complicated than what we‚Äôve done so far (and I hope anyone reading should agree what we‚Äôve done today is already much too complicated).</li><li>Having used the continuation approach, I find it too brittle (as implementable in CPP), and significantly harder to debug than more traditional recursion work-arounds.</li><li>The extra evals in the approach we‚Äôre using tend to be cheap enough, that the massive amount of extra complexity buys you virtually nothing.</li><li>I suspect the continuation technique cannot be done without relying on undefined behavior (specifically, how the compiler chooses to resolve cases where there are multiple possible ambiguous valid expansions).
But, it‚Äôs still really cool, and if you‚Äôre interested (and really want to risk your head going ü§Ø), <a href="https://github.com/camel-cdr/bfcpp/">check out this brainf‚Äî interpreter</a> written entirely in C macros.</li></ol><p>I should note, there are still other ways we could avoid such deep compile-time recursion, or even all recursion if we aren‚Äôt trying to get close to an arbitrary number of arguments. It‚Äôs all far uglier (and way more challenging to understand), and what we‚Äôre doing is performant, enough so that added ugliness isn‚Äôt merited, IMHO.</p><p>Though, one thing I do recommend you do differently from what we‚Äôve done today, is that you should add a common prefix to all your names, to remove the risk of name collisions ‚Äî many libraries already define things like <code>EVAL()</code> and <code>EMPTY()</code>for themselves, and you never know what might make its way into your system, and cause chaos.</p><p>You can‚Äôt be bothered? Okay, I‚Äôm a pushover (and feel strongly about the issue). So I‚Äôve provided a complete version for you at the end of this article.</p><h2 id="count-your-blessings">Count your blessings</h2><p>This journey has taken us further down the macro rabbit hole than anyone should ever have to go, yet we didn‚Äôt have to sacrifice ALL of our remaining sanity (it helps that I was already tapped out).
As much as C actively worked to thwart us from our goal, we got there; now we have a good tool for better compile-time checking of C code in a number of cases, such as when we want to support variable argument functions.
And, with incredibly minor changes, we can re-use the code to operate on each argument, to support other things we might want to automate to make our code more robust. For instance, we could add automatic casts or calls to runtime type checkers, or so on.
All you really need to do is, take the text we insert (generating the addition that the compiler can easily fold into a count), and replace it with an invocation of a macro that the caller passes in, passing that macro the current argument.
Yes, the C standard committee has good reason to disallow recursion‚Äî removing the restriction would undoubtedly break existing code. Yet, the difficulty of the whole exercise hopefully demonstrates the need for some quality-of-life improvements in C2Y, all of which can be done without significant backward compatibility risk.</p><p>Most of all, I‚Äôd love to be able to do far more meaningful work at compile time much more sanely, minimizing my use of macros (as I know many others would too). For that, the language should extend <code>constexpr</code> capabilities, giving us good, full-fledged <code>constexpr</code> functions, with as few limitations as possible. That may be a tall order for C2Y, given the complexity of that change.
But even still, I‚Äôd want to improve the macro system too:</p><ol><li>Add a builtin macro, <code>__VA_COUNT__</code>. We need it to avoid null truncation problems for varargs, and shouldn‚Äôt have to keep reinventing the wheel (or doling out <code>__VA_ARGS__</code> in our code like it‚Äôs Halloween candy).</li><li>Add another builtin macro, <code>__VA_EMPTY__(...)</code>, which would be the inverse of <code>__VA_OPT__(...)</code>; its arguments would only get expanded only when the are NO variadic arguments. This would make it even easier to ensure people have good tools to easily terminate the kind of recursion we did today. Assuming <code>constexpr</code> functions take longer to do well, A <code>__VA_EMPTY__</code> macro can also bridge the gap of not having a good compile-time IF available for complex use cases; it would be much easier to cobble together a reasonably robust one one in macros than it is today by pairing it with <code>__VA_OPT__</code>.</li><li>Add a <code>__VA_EVAL__(...)</code>which simply expands its contents, with two semantic changes to the process that other macro goes through:<ol><li>When an expansion fully finishes, the entire macro gets rescanned again, as many times as necessary, until the full expansion reaches a fix-point (meaning, no more expansions are possible). That would allow us to worry about artificial limits on <code>EVAL()</code> macros; they‚Äôd just stop when they should stop.</li><li>Every top-level rescan should remove all blue paint generated during one expansion, before starting the next expansion (alternately, it could forego further painting macros in the first place).</li></ol></li><li>A more general purpose <code>__MAP__(body_macro, state, ...)</code>would be useful (though, to be fair, much less of a problem to build robustly if the rest of the above were present).</li><li>While waiting for <code>constexr</code> functions, it would be valuable to have a preprocessor built-in <code>__SHA256__</code> that‚Ä¶ replaces the contents passed to it (after expansion) with the SHA256 hash of those contents. I‚Äôve seen more than a few cases where this would be incredibly useful for saving both startup costs, and ongoing costs. No? Why can‚Äôt we have nice things??!! Interestingly, doing a compile-time only implementation of <code>SHA-256</code> using only C macros may seem possible, but I‚Äôve built it (for strings one block in length), and it completely overwhelms both GCC and Clang, even with significantly reduced rounds.</li></ol><p>If the committee were to adopt most of the above, it sure would make one of the ugliest legacies the language has needed to carry forward far more tolerable.</p><p>We mere mortals would be able to get the gist of expansion rules more easily, if we could tell ourselves, ‚Äúmacro recursion is disallowed unless you use <code>__EVAL__()</code>‚Äù. That removes a huge source of confusion, but still leaves us with the problem of getting termination conditions right, which are a bit tricky.
Adding <code>__VA_EMPTY__()</code> makes it pretty easy for someone to get the exit condition right in the common case where our recursion is being used to iterate over the arguments passed to function-like macros. <code>__EVAL__()</code> would then essentially be able to function as a ‚Äúdo what I mean‚Äù operator, for most of the things people bang their head against when trying to write useful, robust macros to hide C‚Äôs unnecessary complexity. With just these two things, you would be able to implement <code>__VA_COUNT__(‚Ä¶)</code><em>fairly</em> simply:</p><div><pre tabindex="0"><code data-lang="java"><span><span><span>#</span>define <span>__REST__</span>(x, ...) __VA_ARGS__
</span></span><span><span><span>#</span>define <span>__VA_COUNT__</span>(...) <span>\</span>
</span></span><span><span>    __VA_EMPTY__(0) <span>\</span>
</span></span><span><span>    __VA_OPT__(1 <span>+</span> __EVAL__(__VA_COUNT__(__REST__(__VA_ARGS__))))
</span></span></code></pre></div><p>Sure, it‚Äôs still a little obtuse, but it‚Äôs far more sane than our final product.</p><h2 id="does-this-count">Does this count?</h2><p>I said there was no price for my full implementation, and there‚Äôs not. But, if you really feel obliged, then spend a minute indulging me.</p><p>I can count the times I‚Äôve written the word ‚Äúcount‚Äù more than 100 times in a week on one finger. The entire time I‚Äôve been working on this article, I keep thinking about what might be my favorite dad joke ever, but I spent far more time in ‚Äúmacro hell‚Äù than I like. So, before we talk about our final implementation, I‚Äôm going to indulge myself. It will only make sense to people who grew up with US kids programming, and does not in any way contribute to this topic:</p><p><em>Person A:</em> ‚ÄúWho‚Äôs your favorite vampire?‚Äù</p><p><em>Person B:</em> ‚ÄúWithout a doubt, the one who lives on Sesame Street.‚Äù</p><p><em>Person A:</em> ‚ÄúThe puppet? He doesn‚Äôt count!‚Äù</p><p><em>Person B:</em> ‚ÄúI assure you, he does.‚Äù</p><h2 id="ha-ha-ha-">‚ö°Ô∏èHa! Ha! Ha! ‚ö°Ô∏è</h2><pre tabindex="0"><code>              oooOOOooo
           oOOOOOOOOOOOOOo
         oOO&#34;           &#34;OO
    ____oOO  ====   ====  OOo____ 
    \   OO&#39;      ! !.---. &#39;OO   /
     \  OO   &lt;0&gt; ! !!&lt;0&gt;!  OO  /
      \ Oo       ! !&#39;---&#39;  oO /
       \o        \_/        o/
        .&#39; _______________ &#39;.
      ,&#39;   :   V     V   :   &#39;.
    ,&#39;      -_         _-      &#39;.
  ,&#39;          &#34;oOOOOOo&#34;          &#39;.
,&#39;              OOOOO              &#39;.
-----------     &#34;OOO&#34;     -----------
                 &#34;O&#34;             
</code></pre><p>Okay, if you sat through that (or were smart enough to skip it), you‚Äôve earned the full code.</p><p>As I mentioned above, I added a <code>H4X0R_</code> prefix to everything to avoid name collisions. Additionally, internal helpers have a leading underscore. The notion of <code>_</code> indicating an internal variable has a long heritage (it is particularly prominent in Python, for example).</p><p>Our new top-level count macro is named <code>H4X0R_VA_COUNT()</code>; I added the <code>VA</code> to indicate we‚Äôre counting variable arguments (but didn‚Äôt want to make it too verbose, either).</p><p>But I actually made some other changes from what we did above.</p><p>Specifically, I first built a macro, <code>H4X0R_MAP(macro, ...)</code>. The implementation of this new macro is structured in pretty much the same way as our <code>COUNT()</code> macro above, at least in terms of the recursion. Our major change, besides the names is that, whereas for each argument, <code>COUNT()</code> ignores the argument and replaces it with <code>+1</code>, <code>H4X0R_MAP()</code> takes the argument, and passes it to a macro supplied by the caller. That caller-supplied macro gets passed the value of the parameter currently being visited.</p><p>That makes it trivial to create <code>H4X0R_VA_COUNT()</code>; we just have to call our new macro, and pass in a body macro that simply does <code>+1</code> (ignoring the parameter value).</p><p>This new macro gives us more flexibility, hopefully lessening the need to write future recursive macros.</p><div><pre tabindex="0"><code data-lang="java"><span><span><span>// To keep this compact width-wise (given the prefix), we only do two </span>
</span></span><span><span><span>// expansions per line, and stop at 256 expansions. Extend as desired.</span>
</span></span><span><span>
</span></span><span><span><span>#</span>define <span>H4X0R_EVAL1</span>(...)    __VA_ARGS__
</span></span><span><span><span>#</span>define <span>H4X0R_EVAL2</span>(...)    H4X0R_EVAL1(H4X0R_EVAL1(__VA_ARGS__))
</span></span><span><span><span>#</span>define <span>H4X0R_EVAL4</span>(...)    H4X0R_EVAL2(H4X0R_EVAL2(__VA_ARGS__))
</span></span><span><span><span>#</span>define <span>H4X0R_EVAL8</span>(...)    H4X0R_EVAL4(H4X0R_EVAL4(__VA_ARGS__))
</span></span><span><span><span>#</span>define <span>H4X0R_EVAL16</span>(...)   H4X0R_EVAL8(H4X0R_EVAL8(__VA_ARGS__))
</span></span><span><span><span>#</span>define <span>H4X0R_EVAL32</span>(...)   H4X0R_EVAL16(H4X0R_EVAL16(__VA_ARGS__))
</span></span><span><span><span>#</span>define <span>H4X0R_EVAL64</span>(...)   H4X0R_EVAL32(H4X0R_EVAL32(__VA_ARGS__))
</span></span><span><span><span>#</span>define <span>H4X0R_EVAL128</span>(...)  H4X0R_EVAL64(H4X0R_EVAL64(__VA_ARGS__))
</span></span><span><span><span>#</span>define <span>H4X0R_EVAL</span>(...)     H4X0R_EVAL128(H4X0R_EVAL128(__VA_ARGS__))
</span></span><span><span>
</span></span><span><span><span>#</span>define <span>H4X0R_EMPTY</span>()
</span></span><span><span><span>#</span>define <span>H4X0R_POSTPONE1</span>(macro) macro <span>H4X0R_EMPTY</span>()
</span></span><span><span>
</span></span><span><span><span>// MAP(); If you remove the macro parameter, and replace the call</span>
</span></span><span><span><span>// `macro(x)` with `+1`, you&#39;ll see this is structurally the same</span>
</span></span><span><span><span>// as COUNT() above.</span>
</span></span><span><span><span>#</span>define <span>H4X0R_MAP</span>(macro, ...) <span>\</span>
</span></span><span><span>    __VA_OPT__(H4X0R_EVAL(_H4X0R_MAP_ONE(macro, __VA_ARGS__)))
</span></span><span><span><span>#</span>define <span>_H4X0R_MAP_ONE</span>(macro, x, ...) macro(x) <span>\</span>
</span></span><span><span>    __VA_OPT__(H4X0R_POSTPONE1(_H4X0R_MAP_INDIRECT)()(macro, __VA_ARGS__))
</span></span><span><span><span>#</span>define <span>_H4X0R_MAP_INDIRECT</span>() _H4X0R_MAP_ONE
</span></span><span><span>
</span></span><span><span><span>// A re-implementation of count on top of H4X0R_MAP()... it&#39;s simple now!</span>
</span></span><span><span><span>#</span>define <span>_H4X0R_COUNT_BODY</span>(x) <span>+</span>1
</span></span><span><span><span>#</span>define <span>H4X0R_VA_COUNT</span>(...)  <span>\</span>
</span></span><span><span>                           (H4X0R_MAP(_H4X0R_COUNT_BODY, __VA_ARGS__) <span>+</span> 0)
</span></span></code></pre></div><p>The new <code>H4X0R_MAP()</code> call gives us a more general purpose way to apply transformations to a list of individual arguments. This can help us automate static type checking per-argument, for instance, when we‚Äôre implementing variable-argument functions and want to statically ensure all items at the call site have the same time (as done in the <a href="https://codeberg.org/h4x0r/vargs">variadic function arguments</a> implementation I <a href="https://h4x0r.org/vargs/">wrote about last week</a>.</p><p>For a use case like that, we need to add the commas back in from the original call site. But we won‚Äôt want to add the comma at the end of last argument, because the C compiler will complain. There are plenty of different ways to handle this problem, including:</p><ul><li>If the output is being passed to a C varargs function where the same arguments we‚Äôre iterating over will have a correct <code>count</code> parameter before the values, we can simply add a dummy value (probably 0 since that‚Äôll pass through easily in most contexts). This one is trivial when appropriate, but I don‚Äôt love it, as it isn‚Äôt always appropriate.</li><li>We can rework our map implementation to call a different callback for the last parameter, or to call a separate callback in between parameters. This is definitely more workable, but requires more recursive macro work, overcomplicating things. And then, the extra parameter can easily be forgotten by callers, which would lead to confusing errors (any time you make a mistake calling a macro, but the error isn‚Äôt detected until the compilation step, we should expect it to be confusing).</li><li>We can let the caller handle the first argument separately, and then for any subsequent arguments, add the comma at the beginning, separating it from the previous argument that we know must be present.</li></ul><p>I personally think the third option is the best compromise. Let‚Äôs look at a simple little example. While I normally would want to add more static type checking, sometimes the need might arise to convert a bunch of items of different types into <code>void *</code> .</p><p>If we only need to do it for integer types and pointers, it‚Äôs not too hard to use a union to statically convert one item at a time to <code>void *</code>.</p><p>We will create a temporary union, with two fields, one being our largest standard unsigned int type (<code>unsigned long long</code>, guaranteed to be at least 64 bits), and a <code>void *</code>. We will use a cast to assign to the first field, allowing us to insert any integer or pointer type into the anonymous union:</p><ul><li>Shorter integers will happily promote to a larger size.</li><li>Pointers will convert, since they are never more than 64 bits in size today.</li><li>The first field being unsigned prevents unwanted sign extension, when we insert signed values that are kept in smaller values.</li></ul><p>We then will take the value out of the anonymous union, using the <code>void *</code> . The compiler is smart enough to not generate a real temporary object for this conversion.</p><div><pre tabindex="0"><code data-lang="java"><span><span><span>#</span>define <span>_H4X0R_CONVERT_ONE</span>(arg)                  <span>\</span>
</span></span><span><span>    ((union { unsigned <span>long</span> <span>long</span> u; <span>void</span> <span>*</span>v; }){ <span>\</span>
</span></span><span><span>         .<span>u</span> <span>=</span> (unsigned <span>long</span> <span>long</span>)arg,           <span>\</span>
</span></span><span><span>     }).<span>v</span>    
</span></span></code></pre></div><p>Next, let‚Äôs build a macro to return the first parameter item in a variable list:</p><div><pre tabindex="0"><code data-lang="java"><span><span><span>#</span>define <span>H4X0R_FIRST</span>(...)     __VA_OPT__(_H4X0R_FIRST(__VA_ARGS__))
</span></span><span><span><span>#</span>define <span>_H4X0R_FIRST</span>(x, ...) x
</span></span></code></pre></div><p>The reason for two macros here, is that we want to be able to tolerate cases where no arguments are provided.</p><p>We then can do the same thing to get all the rest of the arguments, after carving off the first argument:</p><div><pre tabindex="0"><code data-lang="java"><span><span><span>#</span>define <span>H4X0R_REST</span>(...)     __VA_OPT__(_H4X0R_REST(__VA_ARGS__))
</span></span><span><span><span>#</span>define <span>_H4X0R_REST</span>(x, ...) __VA_ARGS__
</span></span></code></pre></div><p>When we process the first argument, we‚Äôll be able to call <code>_H4X0R_CONVERT_ONE()</code> directly. For the rest of the arguments, we‚Äôre going to want to pass a macro to process the argument, which can reuse <code>_H4X0R_CONVERT_ONE()</code>, but does need to add a comma before the argument. So it‚Äôs as simple as:</p><div><pre tabindex="0"><code data-lang="java"><span><span><span>#</span>define <span>_H4X0R_CONVERT_LATER_ARG</span>(arg) , _H4X0R_CONVERT_ONE(arg)
</span></span></code></pre></div><p>We‚Äôll want to pass that macro to our map implementation. Here‚Äôs the call to our map function:</p><div><pre tabindex="0"><code data-lang="java"><span><span><span>#</span>define <span>_H4X0R_CONVERT_LIST</span>(...) H4X0R_MAP(_H4X0R_CONVERT_LATER_ARG, __VA_ARGS__)
</span></span></code></pre></div><p>To stitch this all together, we just need to peal off the first argument from the rest, and concatenate the two resulting pieces. The only caveat is that we need to be careful to avoid adding a spurious comma or semicolons in between the two bits we need. When in doubt, use <code>cc -E</code> to review what‚Äôs getting produced.</p><div><pre tabindex="0"><code data-lang="java"><span><span><span>#</span>define <span>H4X0R_VA_VOID_STAR_CONVERT</span>(...)          <span>\</span>
</span></span><span><span>    _H4X0R_CONVERT_ONE(H4X0R_FIRST(__VA_ARGS__)) <span>\</span>
</span></span><span><span>    _H4X0R_CONVERT_LIST(H4X0R_REST(__VA_ARGS__))
</span></span></code></pre></div><p>A dumb test case to show this working:</p><div><pre tabindex="0"><code data-lang="c"><span><span><span>#include</span> <span>&lt;stdio.h&gt;</span><span>
</span></span></span><span><span><span></span>
</span></span><span><span><span>int</span>
</span></span><span><span><span>main</span>()
</span></span><span><span>{
</span></span><span><span>    <span>printf</span>(<span>&#34;%d items: (%p, %p, %p)</span><span>\n</span><span>&#34;</span>,
</span></span><span><span>           <span>H4X0R_VA_COUNT</span>(<span>1</span>, <span>2</span>, <span>3</span>),
</span></span><span><span>           <span>H4X0R_VA_VOID_STAR_CONVERT</span>(<span>1</span>, <span>2</span>, <span>3</span>));
</span></span><span><span>}
</span></span></code></pre></div><p>As you may expect, this prints:</p><p>With our knowledge, and our final <code>H4X0R_MAP()</code> and <code>H4X0R_COUNT()</code> implementations, we can now do some significant transformations easily most people find mind boggling.</p><p>I find it astounding, the level of difficulty required to understand enough about C macros to be able to build a primitive as basic as counting arguments statically at a call site.</p><p>There‚Äôs such a high level of complexity involved, that it‚Äôs even more amazing to me, that once we got the understanding we needed, we could implement both macros in a mere 18 lines of code, exactly half of that being the rote <code>H4X0R_EVAL()</code>implementation.</p><p>And in my view, by choosing comprehensible names, despite all the hurdles we‚Äôve had to overcome, the final result looks almost trivial. Yet, the code alone does not hint at the knowledge you need to write it.</p><p>I‚Äôm confident that nearly anyone who lacks a solid understanding of those basics who tries to gain understanding by trying to rebuild this code, but using it has a guide (perhaps to a slightly different use case), will be inflicting gruesome self-torture on themselves. They might have preferred to code their algorithm in the Brainf‚Äî implementation mentioned above!</p><p>Why is this stuff so hard after decades of standardization? Is the committee secretly a cabal of Rust zealots, that built time travel and went back to 1989, to maximize their torture of C developers?? Maybe that was the inspiration for the movie <em>12 Monkeys</em> ü§î¬†Sounds plausible. Or did they just beam that into my head?! Where did I leave my tin foil hat?</p><p><strong>Happy hacking</strong> (but hopefully not on C macros)!</p><p>‚Äî L33 T. (with a <code>#</code>-ing headache)</p><h2 id="acknowledgements">Acknowledgements</h2><p>This post started as an out-of-control sidebar in my post on <a href="https://h4x0r.org/vargs/">variable argument functions in C.</a></p><p>I owe a huge debt of gratitude to Robert Seacord; his early feedback gave me the clarity I needed to (hopefully) help other C programmers over what is probably one of the biggest hurdles in the language‚Ä¶ people who become C developers eventually master pointers, but to many senior developers, macro recursion has remained a dark art, requiring a magic incantation borrowed from Stack Overflow, Claude or the like.</p><p>Ivan O‚ÄôDay also was critical here, BUT is responsible for me taking several extra weeks to get the article out once it was in decent shape‚Ä¶ because he helped me see that I really needed the step-by-step example of a macro expansion, which I then had to find time to do!</p></div></section></article></div></div>
  </body>
</html>
