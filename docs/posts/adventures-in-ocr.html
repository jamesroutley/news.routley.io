<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.medusis.com/38_Adventures&#43;in&#43;OCR.html">Original</a>
    <h1>Show HN: Adventures in OCR</h1>
    
    <div id="readability-page-1" class="page"><div>
				<div><p>This past few weeks I&#39;ve been working on OCRing an ancient book: a late 19th century edition of 18th century memoirs, in French: <em>Les Mémoires de Saint-Simon</em>.</p>
<p><a href="https://en.wikipedia.org/wiki/Louis_de_Rouvroy,_duc_de_Saint-Simon">Saint-Simon</a> was a courtier in Versailles during the last part of the reign of Louis XIV; his enormous memoirs (over 3 million words) are a first-hand testimony of this time and place, but are more revered today for their literary value than for their accuracy. They have had a profound influence on the most prominent French writers of the 19th and 20th centuries, including <a href="https://en.wikipedia.org/wiki/Fran%C3%A7ois-Ren%C3%A9_de_Chateaubriand">Chateaubriand</a>, <a href="https://en.wikipedia.org/wiki/Stendhal">Stendhal</a>, <a href="https://en.wikipedia.org/wiki/Victor_Hugo">Hugo</a>, <a href="https://en.wikipedia.org/wiki/Gustave_Flaubert">Flaubert</a>, the <a href="https://en.wikipedia.org/wiki/Goncourt_brothers">Goncourt brothers</a>, <a href="https://en.wikipedia.org/wiki/%C3%89mile_Zola">Zola</a>, and of course <a href="https://en.wikipedia.org/wiki/Marcel_Proust">Proust</a>, whose entire project was to produce a new, fictitious version of the memoirs for his time. (Although it hasn&#39;t stopped many from trying, it&#39;s difficult to truly appreciate Proust if one isn&#39;t familiar with Saint-Simon.) <a href="https://en.wikipedia.org/wiki/Leo_Tolstoy">Tolstoy</a> was also a fan, and many others.</p>
<p>Only abridged and partial translations of the Mémoires are available in English, which may be a unique case for a French author of such importance, and likely due to their sheer volume. In French however, many editions exist. The one still considered the best was made by Boislisle between 1879 and 1930 (Boislisle himself died in 1908 but the work was continued by other editors, including his son). This edition has rich, detailed, fantastic footnotes about any topic or person. We&#39;re talking about 45 volumes with roughly 600 pages each.</p>
<p>The French National Library (Bibliothèque nationale) scanned these physical books years ago, and they&#39;re available <a href="https://gallica.bnf.fr/ark:/12148/bpt6k52571">online</a>, but only as images and through a pretty clunky interface that makes reading quite difficult.</p>
<p>My goal is simple: create a proper text version that can be read through (without mangling footnotes and comments into the main text), that&#39;s searchable and that people can actually copy and paste from. The OCR part itself was the easy bit - parsing what the OCR engine spits out is where the real challenge lies. Here&#39;s a breakdown of the tasks, issues, and solutions.</p>
<p><a href="https://divers.medusis.net/boislisle/pub">The result is available here</a> (only the first volume is online for now, and not optimized for mobile).</p>
<h2>What&#39;s at stake</h2>
<p><a href="https://divers.medusis.net/boislisle/pub/#57" title="see live" target="_blank"><img src="https://blog.medusis.com/assets/38/ss_example_zones_colors.jpg" width="200"/></a></p>
<p>Pages contain the following possible zones (colors refer to the image:</p>
<ul>
<li>header (blue)</li>
<li>comments in the margins (green)</li>
<li>main text (pink)</li>
<li>footnotes (yellow)</li>
<li>signature mark (purple)</li>
</ul>
<p>OCRing the books means correclty parsing the words in those different zones and reconstructing them properly, so as to produce readable text (and not just being able to &#39;randomly&#39; find words in a page, like what Google Books does, for example).</p>
<h2>Preparing the images for OCR</h2>
<p>Getting started with Gallica&#39;s PDFs is pretty straightforward. You can download the full scanned books, and there are lots of ways to extract the images. I went with PDFTK, a free tool that works on both Linux and Windows:</p>
<pre><code>pdftk document.pdf burst</code></pre>
<p>This command simply splits <code>document.pdf</code> into individual PDFs, one per page.</p>
<p>Looking at the images in this particular document, they&#39;re not great - low resolution and some are a bit tilted. Since OCR quality heavily depends on input image quality, I needed to fix these issues by enlarging the images and straightening them out. ImageMagick turned out to be perfect for this - it&#39;s a command-line tool that&#39;s incredibly versatile.</p>
<p>Here&#39;s the command I used to process all PDF files from one directory to another:</p>
<pre><code>for file in &#34;$SOURCE_DIR&#34;/*.pdf; do
    if [ -f &#34;$file&#34; ]; then
        filename=$(basename &#34;$file&#34; .pdf)
        echo &#34;Converting $file to $TARGET_DIR/$filename.jpg&#34;
        convert -density 300 -deskew 30 &#34;$file&#34; -quality 100 &#34;$TARGET_DIR/$filename.jpg&#34;
    fi
done</code></pre>
<p>Now we&#39;ve got a directory full of processed images ready to feed into an OCR engine.</p>
<h2>Sending the images to an OCR engine</h2>
<p>For the actual OCR work (turning pictures into text), I went with <a href="https://cloud.google.com/vision?hl=en">Google Vision</a>, which is excellent, and very reasonably priced. Here&#39;s the Python code to send an image to their API:</p>
<pre><code>client = vision.ImageAnnotatorClient()
with open(image_path, &#39;rb&#39;) as image_content:
    image = vision.Image(content=image_content.read())

request = vision.AnnotateImageRequest(
    image=image,
    features=[{&#34;type_&#34;: vision.Feature.Type.DOCUMENT_TEXT_DETECTION}],
)
response = client.annotate_image(request=request)</code></pre>
<p>The API sends back a JSON structure with two main parts:</p>
<ul>
<li>
<p><strong>text_annotations</strong>: a list of words, where the first item is the full page text, and all other items are individual words with their bounding boxes (4 points coordinates)</p>
</li>
<li>
<p><strong>full_text_annotation</strong>: a list of blocks and letters, also with bounding boxes (I didn&#39;t end up using this)</p>
</li>
</ul>
<p>(For some reason, italics are not recognized, though, which is a problem, but not a huge one. See at the end of this post a discussion about possible alternatives.)</p>
<h2>Getting to a readable text</h2>
<p><a href="https://divers.medusis.net/boislisle/pub/#57" title="see live" target="_blank"><img src="https://blog.medusis.com/assets/38/ss_example_zones.jpg" width="200"/></a></p>
<p>The words in <code>text_annotations</code> come roughly in document order, from top-left to bottom-right. You&#39;d think the full text from the first element would be exactly what we need, but there&#39;s a catch. Several catches, actually:</p>
<ul>
<li>
<p>Many pages have comments or subtitles in the margins that don&#39;t belong in the main text, but the OCR mixes them in following the page flow, creating a mess</p>
</li>
<li>
<p>There are extensive footnotes that need to be properly tagged since they&#39;re not part of the main text</p>
</li>
<li>
<p>Each page has a header that we need to remove for smooth reading across pages</p>
</li>
<li>
<p>Every 16 pages, there&#39;s a &#39;signature mark&#39; at the bottom. These need to go too</p>
</li>
</ul>
<p>So we need to process the OCR output to properly identify all these elements and mark paragraphs correctly.</p>
<h3>Digression: more details about traditional book printing and the role of the signature mark</h3>
<p>Books used to be printed on large sheets that were later folded in 8 (<em>in octavo</em>) or in 4 (<em>in quarto</em>) and then sewed together to make a book. Here&#39;s an example of an <a href="https://about.illinoisstate.edu/shakespeareinsheets/folding-octavo-sheets/">in-octavo printing sheet</a> from a Shakespeare play:</p>
<p><img src="https://blog.medusis.com/assets/38/Venus-and-Adonis-image-of-A-sheet-1024x668.png" width="100%" title="Example of in-octavo printing sheet"/></p><p>The folding and assembling were done by different teams than the ones operating the printing press, and they needed instructions so as to fold and group pages <a href="https://en.wikipedia.org/wiki/Book_size">in the correct order</a>. That&#39;s the purpose of the <a href="https://en.wikipedia.org/wiki/Signature_mark">signature mark</a>: to tell the binder how to fold the sheets and, once folded, how to group the resulting booklets.</p>
<p>The signature mark therefore typically contains the name of the book (so that it doesn&#39;t end up mixed with other books in the printing factory) and a number or a letter that tells its order. It&#39;s printed on just one side of the sheet, where the first page should appear when the sheet is folded; so for an in-octavo it will appear once every 16 pages in the printed book (or on the scans).</p>
<p>We need to remove it because if not, it will end up polluting the final text. A very crude method would be to remove the last line every 16 pages but that would not be very robust if there were missing scans or inserts, etc. I prefer to check every last line of every page for the content of the signature mark, and measuring a <a href="https://en.wikipedia.org/wiki/Levenshtein_distance">Levenshtein distance</a> to account for OCR errors.</p>
<h3>Center vs margin</h3>
<p>First up: figuring out what&#39;s main text and what&#39;s margin commentary. Pages aren&#39;t all exactly the same size or layout, so we can&#39;t use fixed coordinates. But the main text is always full-justified, and words come in (roughly) document order.</p>
<p>So in order to identify left and right margins I do a fist pass on all words in the page to identify leftmost and rightmost words (and mark them as such):</p>
<ul>
<li>
<p>Track each word&#39;s horizontal position</p>
</li>
<li>
<p>A leftmost word is when a word&#39;s x position is less than the previous word</p>
</li>
<li>
<p>A rightmost word is the one before a leftmost word</p>
</li>
</ul>
<p>The margins will be where the &#39;majority&#39; of those leftmost and rightmost words are.</p>
<p>To understand, let&#39;s look at the left margin for example:</p>
<ul>
<li>
<p>some words are way to the left because they belong to comments in the left margin, so if we simply took the lowest horizontal position of any word on the page, we would end up with a left margin too far to the left (and therefore, comments would be mixed up inside the main text)</p>
</li>
<li>
<p>some words, while being the first word on a line, have a horizontal offset, either because they mark the start of a paragraph (left indent) or because they&#39;re quotes or verse, etc.</p>
</li>
</ul>
<p>By grouping leftmost words into buckets, and selecting the largest bucket, we can find words that are &#34;aligned&#34; along the true left margin, and therefore, find the left margin.</p>
<p>We can find these &#34;majority&#34; positions either through statistical methods like <a href="https://en.wikipedia.org/wiki/Interquartile_range">interquartile range</a>, or by rounding x positions and picking the most common values.</p>
<p>Once we&#39;ve got these two groups of edge words, anything further left than the left group is comment in the left margin, and anything further right than the right group is comment in the right margin.</p>
<p>Then we can do another pass to properly sort everything into either margin comments, or center block.</p>
<h3>Lines</h3>
<p>Since we&#39;re not using the full text but individual words, we have to build lines (and then paragraphs), using words&#39; coordinates.</p>
<p>Making lines is pretty straightforward: we group words by vertical position in each section, then sort each line by the x position of the words.</p>
<p>To group by vertical position, I just go through words in order:</p>
<ul>
<li>
<p>If a word is close enough vertically to the previous word (within some threshold), it goes in the current line</p>
</li>
<li>
<p>If it&#39;s too far, it starts a new line</p>
</li>
</ul>
<p>Finding the right threshold takes some trial and error. Too big and you&#39;ll merge different lines; too small and you&#39;ll split single lines unnecessarily.</p>
<p>But getting the proper vertical position is trickier than it sounds. Even on perfectly straight pages, words on the same line often have different y-positions, because their bounding boxes include different letter parts (like the tail of a &#39;p&#39; or the top of a &#39;t&#39;).</p>
<p>As it is, the word &#39;maman&#39; with no tall or hanging letters will have a different y-position than &#39;parent&#39; which has both. What we would really need is the <a href="https://en.wikipedia.org/wiki/Baseline_(typography)">baseline</a>, but unfortunately we don&#39;t have that.</p>
<p><img src="https://blog.medusis.com/assets/38/Typography_Line_Terms.svg.png" alt="Baseline image"/></p>
<p>While processing lines, we also:</p>
<ul>
<li>
<p>Remove the header (it&#39;s always the first line, except on title pages)</p>
</li>
<li>
<p>Spot and remove signature marks by checking their content (see above)</p>
</li>
</ul>
<h3>Identifying footnotes block</h3>
<p>One main goal here is making those rich footnotes accessible, so identifying them properly matters. But doing it automatically isn&#39;t simple.</p>
<p>I tried spotting footnotes by word or line density, but that wasn&#39;t reliable enough.</p>
<p>What we know about footnotes:</p>
<ul>
<li>
<p>They&#39;re separated from the main text by a gap; yet there are other gaps too, so we can&#39;t just take the first one we find</p>
</li>
<li>
<p>Working up from the bottom to the first gap works better, but footnotes can have gaps too</p>
</li>
<li>
<p>Footnotes usually start with numbers and the first one on a page is typically &#39;1.&#39; - that helps. But sometimes footnotes continue from the previous page with no number, and some pages have footnotes-within-footnotes using letters (a. b. c.)</p>
</li>
</ul>
<p>Using all this info, I built a system that gets it right about 90% of the time.</p>
<p>For the rest, I had to add manual input (more on that in the web section).</p>
<h3>Finding paragraphs</h3>
<p>Finding paragraphs should be simple - they start with a positive indent from the left margin. But because, even after deskewing, images aren&#39;t perfectly straight, the true left margin isn&#39;t a vertical line, so some words look indented when they&#39;re really not. We can try using the rightmost word of the left side as reference (excluding outliers of course), but then we miss some actual paragraphs (classic tradeoff between false positives and false negatives).</p>
<p>The real problem with skewed images is that they&#39;re not just rotated, they&#39;re distorted, which means the angle changes across the page. Standard deskewing can&#39;t fix this, and I haven&#39;t found a way to correct the distortion that actually works and is fast enough, whether using ImageMagick or Python libraries like PIL or scipy. Truly distorted images are fairly rare so I didn&#39;t spend too much time looking, though.</p>
<h3>Logs</h3>
<p>I cannot recommend logging highly enough! It stores all sorts of information during parsing so that one can examine it later to identify problems, spotting outliers for further review, and in general keep a record of what happened. The excellent <code>logging</code> Python module is versatile and efficient. Here&#39;s an example output:</p>
<p><img src="https://blog.medusis.com/assets/38/example_log.jpg" width="100%" title="Log example"/></p><p>And here are the corresponding configuration parameters:</p>
<pre><code>logging.basicConfig(
    filename = os.sep.join([tomes_path, logfile]),
    encoding = &#34;utf-8&#34;,
    filemode = &#34;a&#34;,
    format = &#34;%(asctime)s - %(levelname)s - %(filename)s - %(funcName)s: %(message)s&#34;,
    style = &#34;%&#34;,
    datefmt = &#34;%Y-%m-%d %H:%M&#34;,
    level = logging.DEBUG,
    )</code></pre>
<h3>Web interface</h3>
<p>I built a web interface to make it easy to input manual page info and check OCR quality. It shows recognized zones and line numbers for each page. If the zones are wrong, you can just type in where the footnotes actually start. It can be done in no time (perhaps 10 minutes for a 600 pages book, if that).</p>
<p>You can check out where we&#39;re at <a href="https://divers.medusis.net/boislisle/pub">here</a>. Hover over the OCR text highlights that zone in the page image. I&#39;m planning to add text correction features too.</p>
<h3>Things left to do</h3>
<h4>Spellcheck</h4>
<p>I&#39;ve done basic spellcheck for hyphenated words: the program checks a French word list for the unhyphenated version and uses it if found. This fixes hyphenations at line ends.</p>
<p>Since proper nouns for persons or places aren&#39;t in standard French dictionaries, the program keeps track of unknown words for manual review and dictionary updates.</p>
<p>I still need to build a more complete spellcheck system, though.</p>
<h4>Lies, Damned Lies, and LLMs (about footnotes references)</h4>
<p>Footnotes references show up twice: before the footnotes themselves in normal text, and next to words in the main text as superscript. But the OCR often misses the superscript ones - they&#39;re too small and the scans too rough. Some turn into apostrophes or asterisks, but most just vanish.</p>
<p>I tried using AI for this. The idea was to have a model place footnote references in the main text based on what the footnotes were about. To make sure it caught everything, I asked the model to give me:</p>
<ul>
<li>Number of footnotes found</li>
<li>Number of references placed</li>
<li>Whether these matched</li>
</ul>
<p>It was a complete flop. Using <a href="https://openrouter.ai">OpenRouter</a>, I tested over 200 models. More than 70% couldn&#39;t even count the footnotes right, but that wasn&#39;t the worst part.</p>
<p>The &#34;best&#34; models just made stuff up to meet the requirements. They lied in three ways:</p>
<ul>
<li>Basic (stupid) lies: wrong counts but claiming they matched (&#39;foonotes: 5, references: 3, match: true&#39;)</li>
<li>Better lies: claiming they placed references when they hadn&#39;t</li>
<li>Premium lies: making up new text to attach footnotes to when they weren&#39;t sure where they went (against explicit instructions in the prompt never to do that)</li>
</ul>
<h3>Other general approaches</h3>
<p>The main difficulty of the is project lies in correctly identifying page zones; wouldn&#39;t it be possible to properly find the zones during the OCR phase itself instead of rebuilding them afterwards?</p>
<p>Tesseract for example can in theory do <a href="https://pyimagesearch.com/2021/11/15/tesseract-page-segmentation-modes-psms-explained-how-to-improve-your-ocr-accuracy/">page segmentation</a> but it&#39;s brittle and I could never get it to work reliably. (Its quality in OCR is also way lower than Google Vision in my experience.) Trying to get LLMs with vision to properly identify zones also were found to be slow and unreliable, and the risk of hallucinated results is unacceptable, especially as a first step. Non-deterministic systems may be fine for creative projects, but not here. (Once we have a reliable reference we can then play with LLMs and if necessary, control the results by measuring the distance to the source.)</p>
<p>But the more fundamental reason why I think it&#39;s better to first do OCR and then analyze the results to reconstruct the text, is that OCR is costly, and parsing JSON isn&#39;t. All the more so when the number of pages is large.</p>
<p>When OCR fails and you have to do it again, it takes time and money.  On the contrary, parsing JSON with Python is mostly instantaneous, doesn&#39;t require any special hardware, and can therefore be improved and run again and again until the result is satisfactory.</p>
<h4>Human review</h4>
<p>After these experiments, it&#39;s clear some human review is needed for the text, including spelling fixes and footnote placement. Initial tests show it takes 1-2 minutes per page, so about two days per volume (10-20 hours) or six months for the whole book. It&#39;s a lot, but doable. That&#39;s our next step.</p>
<p>Still, I keep improving the automatic parsing described above. It&#39;s important not to jump into manual text corrections too early - once we start making those changes by hand, running the automatic parsing again becomes tricky or impossible. So for now, we&#39;ll focus on making the automatic process as good as it can get.</p></div>
				</div></div>
  </body>
</html>
