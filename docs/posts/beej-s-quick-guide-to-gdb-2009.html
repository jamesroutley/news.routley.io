<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://beej.us/guide/bggdb/">Original</a>
    <h1>Beej&#39;s Quick Guide to GDB (2009)</h1>
    
    <div id="readability-page-1" class="page">


<i>Release 2 (2009 Jun 14)</i>

<p>Translations:
</p><ul>
<li><a href="https://paintingvalley.com/ru-bggdb">Russian</a>
</li></ul>

<p>This is a very quick-and-dirty guide meant to get you started with
the GNU Debugger, <b>gdb</b>, from the command line in a
terminal.  Often times <b>gdb</b> is run via an IDE, but
many people out there shun IDEs for a variety of reasons, and this
tutorial is for you!</p>

<p>Again, this is only a getting-started guide.  There&#39;s much much MUCH
more to learn about what the debugger does than is written in these few
short paragraphs.  Check out your &#34;man&#34; pages or the online resources
listed below for more info.</p>

<p>This tutorial is meant to be read in order, up to, but not including,
the &#34;Misc&#34; section.</p>

<!-- ================================================================ -->
<h2>Contents</h2>
<ul>
<li><a href="#compiling">Compiling to use a debugger</a>
</li><li><a href="#more">More Information</a>
</li><li><a href="#license">License</a>
</li><li><a href="#starting">Starting <b>gdb</b> and getting to <tt>main()</tt></a>
</li><li><a href="#breakpoints">Breakpoints</a>
</li><li><a href="#stepping">Stepping Around</a>
</li><li><a href="#exvars">Examining Variables</a>
</li><li><a href="#misc">Misc Stuff</a>
	<ul>
	<li><a href="#stackman">Stack Manipulation</a>
	</li><li><a href="#morestep">Additional Stepping Methods</a>
	</li><li><a href="#jump">Jumping to an Arbitrary Section of Code</a>
	</li><li><a href="#varmod">Changing Variables and Values at Runtime</a>
	</li><li><a href="#hardwatch">Hardware Watchpoints</a>
	</li><li><a href="#attach">Attach to a Running Process</a>
	</li><li><a href="#coredump">Using Coredumps for Postmortem Analysis</a>
	</li><li><a href="#window">Window Functions</a>
	</li><li><a href="#regasm">Display Registers and Assembly</a>
	</li><li><a href="#frontend">Writing a Front-End</a>
	</li></ul>
</li><li><a href="#qref">Quick Reference Cheat Sheet</a>
</li></ul>

<!-- ================================================================ -->
<a name="compiling"></a>
<h2>Compiling</h2>

<p>You have to tell your compiler to compile your code with symbolic
debugging information included.  Here&#39;s how to do it with <b>gcc</b>, with the <b>-g</b> switch:</p>

<pre>

$ <b>gcc -g hello.c -o hello</b>

$ <b>g++ -g hello.cpp -o hello</b>

</pre>

<p>Once you&#39;ve done that, you should be able to view program listings in
the debugger.</p>

<!-- ================================================================ -->
<a name="more"></a>
<h2>More Information</h2>

<p>Check out the <a target="_blank" href="http://www.gnu.org/software/gdb/documentation/">Official GDB
Documentation</a> for more information than you can shake a stick
at!</p>

<p>Also, a good GNU GDB front-end is <a target="_blank" href="http://www.gnu.org/software/ddd/">DDD, the
DataDisplayDebugger</a>.</p>

<!-- ================================================================ -->
<a name="license"></a>
<h2>License</h2>

<a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/us/" target="_blank"><img alt="Creative Commons License" src="https://thomasbroadley.com/blog/i-m-joining-arc-evals/88x31.png"/></a><p><span xmlns:dc="http://purl.org/dc/elements/1.1/" href="http://purl.org/dc/dcmitype/Text" property="dc:title" rel="dc:type">Beej&#39;s Quick Guide to GDB</span> by <a xmlns:cc="http://creativecommons.org/ns#" href="http://beej.us/guide/bggdb/" property="cc:attributionName" rel="cc:attributionURL">Brian &#34;Beej Jorgensen&#34; Hall</a> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/us/" target="_blank">Creative Commons Attribution-Noncommercial-No Derivative Works 3.0 United States License</a>.</p>

<!-- ================================================================ -->
<a name="starting"></a>
<h2>Starting The Debugger</h2>

<p>First things first: you can enter <b>help</b> at
any <b>gdb</b> prompt and get more information.  Also,
you can enter <b>quit</b> to quit the debugger.
Finally, just hitting <b>RETURN</b> will repeat the
last command entered. Now let&#39;s fire it up!</p>

<p>There are several ways to start the debugger (e.g. if you were an IDE
you might start it with a particular mode that&#39;s not so human-friendly)
but I&#39;ll mention two of them here: vanilla console mode and curses GUI
mode.  The GUI is better, but let&#39;s quickly cover the simple one, and
launch a program called <b>hello</b> in the debugger:</p>

<pre>$ <b>gdb hello</b>
GNU gdb 6.8
Copyright (C) 2008 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type &#34;show copying&#34;
and &#34;show warranty&#34; for details.
This GDB was configured as &#34;i486-slackware-linux&#34;...
(gdb) <b>run</b>
Starting program: /home/beej/hello 
Hello, world!

Program exited normally.
(gdb) 
</pre>

<p>The last line is the <b>gdb</b> prompt, waiting for
you to tell it what to do.  Type <b>r</b> or <b>run</b> to run the program.  (<b>gdb</b> allows you to abbreviate commands until they
become ambiguous.)</p>

<p><b>To start in neato and highly-recommended GUI mode</b>, start the
debugger with <b>gdb -tui</b>.  (For many of the
examples, below, I show the output of <b>gdb</b>&#39;s dumb
terminal mode, but in real life I use TUI mode exclusively.)</p>

<p>And here is a screenshot of what you&#39;ll see, approximately:</p>

<center><img src="https://thomasbroadley.com/blog/i-m-joining-arc-evals/hellotui.png"/></center>

<p>All the normal <b>gdb</b> commands will work in GUI
mode, and additionally the arrow keys and pgup/pgdown keys will scroll
the source window (when it has focus, which it does by default).  Also,
you can change which file or function is displayed in the source window
by giving the command <b>list</b> with a location as
an argument, for example, &#34;<b>list hello.c:5</b> to
bring up the file <tt>hello.c</tt> on line 5.  (See &#34;<a href="#breakpoints">Breakpoints</a>&#34;, below, for sample
locations—the same locations that work with breakpoints will work
with the <b>list</b> command.)  As a side note, <b>list</b> also works in dumb terminal mode.</p>

<p>Now, notice that we passed the name of the executable on the command
line.  Another option you have is to just start <b>gdb</b> with nothing else on the command line, then give
it the command <b>file hello</b>, and that will cause
the executable &#34;hello&#34; to be loaded up.</p><p>Command line arguments!  What if you have to get something into <tt>argv</tt> in your program?  Pass them as arguments to
the <b>run</b> command when you start execution:</p>

<pre>$ <b>gdb hello</b>
GNU gdb 6.8
Copyright (C) 2008 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type &#34;show copying&#34;
and &#34;show warranty&#34; for details.
This GDB was configured as &#34;i486-slackware-linux&#34;...
(gdb) <b>run arg1 arg2</b>
Starting program: /home/beej/hello arg1 arg2
Hello, world!

Program exited normally.
(gdb) 
</pre>

<p>Notice where it says &#34;Starting Program&#34;, above, it shows the
arguments &#34;arg1&#34; and &#34;arg2&#34; being passed to &#34;hello&#34;.</p>

<!-- ================================================================ -->
<a name="breakpoints"></a>
<h2>Breakpoints</h2>

<p>Just starting the debugger to run the program straight through isn&#39;t
very useful—we need to stop execution and get into stepping
mode.

</p><p>First, before you issue the <b>run</b> command, you
need to set a breakpoint someplace you&#39;d like to stop.  You use the <b>break</b> or <b>b</b> command, and
specify a location, which can be a function name, a line number, or a
source file and line number.  These are examples of locations, which are
used by various other commands as well as <b>break</b>:</p>

<center><table>

<tbody><tr><td><b>break main</b></td><td>Break at the beginning of the <tt>main()</tt> function</td></tr>

<tr><td><b>break 5</b></td><td>Break at line 5 of the current file</td></tr>

<tr><td><b>break hello.c:5</b></td><td>Break at line 5 of <tt>hello.c</tt></td></tr>

</tbody></table>
</center>

<p>So for this test, let&#39;s set a breakpoint at <tt>main()</tt>, and start the program:

</p><pre>$ <b>gdb hello</b>
GNU gdb 6.8
Copyright (C) 2008 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type &#34;show copying&#34;
and &#34;show warranty&#34; for details.
This GDB was configured as &#34;i486-slackware-linux&#34;...
(gdb) <b>b main</b>
Breakpoint 1 at 0x8048395: file hello.c, line 5.
(gdb) <b>r</b>
Starting program: /home/beej/hello 

Breakpoint 1, main () at hello.c:5
5		printf(&#34;Hello, world!\n&#34;);
(gdb)
</pre>

<p>As you see, we&#39;ve arrived at <tt>main()</tt> and
execution has stopped at the breakpoint we set there.  If you&#39;re running
in dumb terminal mode, <b>gdb</b> will print the line it
will execute next.  If you&#39;re running in cool GUI mode, the line it will
execute next will be highlighted in the source window.</p>

<p>To list the current breakpoints, use the <b>info</b> command, like so: &#34;<b>info
breakpoints</b>&#34; (or the shorter &#34;<b>i b</b>&#34;):</p>

<pre>(gdb) <b>b main</b>
Breakpoint 1 at 0x8048395: file hello.c, line 5.
(gdb) <b>i b</b>
Num     Type           Disp Enb Address    What
1       breakpoint     keep y   0x08048395 in main at hello.c:5
</pre>

<p>To clear a breakpoint, use the <b>clear</b> command
with the breakpoint location.  You can also clear a breakpoint by number
with the <b>delete</b> command.</p>

<p>Additionally, you can <b>enable</b> or <b>disable</b> breakpoints, though these two commands
take a breakpoint number as an argument, not a location!  The
enabled/disabled status of a breakpoint is visible under the &#34;Enb&#34;
column in the breakpoint listing.</p>

<pre>(gdb) <b>i b</b>
Num     Type           Disp Enb Address    What
1       breakpoint     keep y   0x08048395 in main at hello.c:5
(gdb) <b>disable 1</b>
(gdb) <b>i b</b>
Num     Type           Disp Enb Address    What
1       breakpoint     keep n   0x08048395 in main at hello.c:5
(gdb) <b>clear main</b>
Deleted breakpoint 1 
(gdb) <b>i b</b>
No breakpoints or watchpoints.
</pre>

<!-- ================================================================ -->
<a name="stepping"></a>
<h2>Stepping Around</h2>

<p>Once execution stops at a breakpoint, you can tell the debugger to do
a few things.  Let&#39;s start with the <b>next</b>
command (or <b>n</b>).  This command moves you to the
next statement in the current function (or returns to the function&#39;s
caller if you&#39;ve stepped off the end of the function.)  Here&#39;s a sample
run; remember that <b>gdb</b> is printing the line <i>it
will execute next</i> just before the &#34;(gdb)&#34; prompt.  Also notice that
when we run <b>next</b> on the <tt>printf()</tt> line, we see the output appear.</p>

<pre>(gdb) <b>b main</b>
Breakpoint 1 at 0x8048395: file hello.c, line 5.
(gdb) <b>r</b>
Starting program: /home/beej/hello 

Breakpoint 1, main () at hello.c:5
5		printf(&#34;Hello, world!\n&#34;);
(gdb) <b>next</b>
Hello, world!
7		return 0;
(gdb) <b>next</b>
8	}
(gdb) <b>next</b>
0xb7d6c6a5 in __libc_start_main () from /lib/libc.so.6
(gdb) <b>next</b>
Single stepping until exit from function __libc_start_main, 
which has no line number information.

Program exited normally.
(gdb) 
</pre>

<p>(That weird stuff at the end about <tt>
__libc_start_main()</tt> shows you that there was another function that
called your <tt>main()</tt> function!  It wasn&#39;t
compiled with debugging information so we can&#39;t see the source, but we
can still step through it—which we do—and the program exits
normally.)</p>

<p>Now, notice that <b>next</b> <i>steps over</i>
function calls. This doesn&#39;t mean that function doesn&#39;t get called; it
means that <b>next</b> will execute the function until
it&#39;s done, and then return you to the next line in your current
function.</p>

<p>What if you have a function you want to <i>step into</i> from your
current function, and trace through that function line-by-line?  Use the
<b>step</b> (or <b>s</b>) command to
do this.  It works just like <b>next</b>, except it
steps into functions.</p>

<p>Let&#39;s say you&#39;re tired of single stepping, and just want the program
to run again.  Use the <b>continue</b> (or <b>c</b>) command to continue execution.</p><p>What if the program is running but you forgot to set breakpoints?
You can hit <b>CTRL-C</b> and that&#39;ll stop the program
wherever it happens to be and return you to a &#34;(gdb)&#34; prompt.  At that
point, you could set up a proper breakpoint somewhere and <b>continue</b> to that breakpoint.</p>

<p>One final shortcut is that just hitting <b>RETURN</b> will repeat the last command entered; this
will save you typing <b>next</b> over and over
again.</p>

<!-- ================================================================ -->
<a name="exvars"></a>
<h2>Examining Variables</h2>

<p>If you have some variables you wish to inspect over the course of the
run, you can <b>display</b> them, but only if the
variable is currently in scope.  Each time you step the code, the value
of the variable will be displayed (if it&#39;s in scope).</p>

<p>(The following output is missing source code output between lines for
clarity—it&#39;s what you&#39;d see in GUI mode.  Imagine you&#39;re seeing
the highlight bar bouncing around the source code while you&#39;re running
this:)</p>

<pre>(gdb) <b>b main</b>
Breakpoint 1 at 0x8048365: file hello.c, line 5.
(gdb) <b>r</b>
Starting program: /home/beej/hello 

Breakpoint 1, main () at hello.c:5
(gdb) <b>disp i</b>
1: i = -1207447872
(gdb) <b>next</b>
1: i = 1
(gdb) <b>next</b>
1: i = 1
(gdb) <b>next</b>
1: i = 2
(gdb) <b>next</b>
1: i = 2
(gdb) <b>next</b>
1: i = 4
(gdb) <b>next</b>
1: i = 4
(gdb) <b>next</b>
1: i = 4
(gdb) 
</pre>

<p>The number to the left of &#34;i&#34;, above, is the display number of the
variable.  Use this number to <b>undisplay</b> the
variable.  If you forget the display numbers, you can type <b>info display</b> to get them:</p>

<pre>(gdb) <b>b main</b>
Breakpoint 1 at 0x8048365: file hello.c, line 5.
(gdb) <b>r</b>
Starting program: /home/beej/hello 

Breakpoint 1, main () at hello.c:5
(gdb) <b>display i</b>
1: i = -1207447872
(gdb) <b>info display</b>
Auto-display expressions now in effect:
Num Enb Expression
1:   y  i
(gdb) <b>undisplay 1</b>
(gdb)
</pre>

<p>If you just want to one-off know the value of a variable, you can <b>print</b> it.  Here we see the value of &#34;i&#34; is 40:</p>

<pre>(gdb) <b>print i</b>
$1 = 40
(gdb)
</pre>

<p>(The &#34;$&#34; with the number after it means something, but it&#39;s not
important for beginners.)</p>

<p>There&#39;s also a handy <b>printf</b> command that you
can use to better format your output if you want to:

</p><pre>(gdb) <b>printf &#34;%d\n&#34;, i</b>
40
(gdb) <b>printf &#34;%08X\n&#34;, i</b>
00000028
(gdb)
</pre>

<a name="misc"></a>

<!-- ================================================================ -->
<a name="misc"></a>
<h2>Misc Stuff</h2>

<p>This is stuff that doesn&#39;t really fit in the earlier sections, but it
fun enough to list somewhere.</p>

<!-- ============================ -->
<a name="stackman"></a>
<h3>Stack Manipulation</h3>

<p>The command <b>backtrace</b> (or <b>bt</b>) will show you the current function call
stack, with the current function at the top, and the callers in order
beneath it:</p>

<pre>(gdb) <b>backtrace</b>
#0  subsubfunction () at hello.c:5
#1  0x080483a7 in subfunction () at hello.c:10
#2  0x080483cf in main () at hello.c:16
(gdb)
</pre>

<p>Type <b>help stack</b> for more info on what you
can do with this.</p>

<!-- ============================ -->
<a name="morestep"></a>
<h3>Additional Stepping Methods</h3>

<p>To exit the current function and return to the calling function, use
the <b>finish</b> command.</p>

<p>To step for a single assembly instruction, use the <b>stepi</b> command.</p>

<p>To continue to a specific location, use the <b>advance</b> command, specifying a location like those
shown in the &#34;<a href="#breakpoints">Breakpoints</a>&#34; section, above.
Here&#39;s an example which advances from the current location until the
function <tt>subsubfunction()</tt> is called:</p>

<pre>Breakpoint 1, main () at hello.c:15
15		printf(&#34;Hello, world!\n&#34;);
(gdb) <b>advance subsubfunction</b>
Hello, world!
subsubfunction () at hello.c:5
5		printf(&#34;Deepest!\n&#34;);
(gdb) 
</pre>

<p><b>advance</b> is just shorthand for &#34;continue to
this temporary breakpoint.&#34;</p>

<!-- ============================ -->
<a name="jump"></a>
<h3>Jumping to an Arbitrary Section of Code</h3>

<p>The <b>jump</b> command works exactly like <b>continue</b>, except it takes a location to jump to as
an argument.  (See the the &#34;<a href="#breakpoints">Breakpoints</a>&#34;
section, above, for more information on locations.)</p>

<p>If you need to stop at the jump destination, set a breakpoint there
first.</p>

<!-- ============================ -->
<a name="varmod"></a>
<h3>Changing Variables and Values at Runtime</h3>

<p>You can use the <b>set variable</b> command with an
expression to evaluate, and this allows you to change the value of a
variable during the run.  You can also shorthand this by just using <b>set</b> with a parenthesized expression after it:</p>

<pre>Breakpoint 1, main () at hello.c:15
15		int i = 10;
(gdb) <b>print i</b>
$1 = -1208234304
(gdb) <b>set (i = 20)</b>
(gdb) <b>print i</b>
$2 = 20
(gdb) <b>set variable i = 40</b>
(gdb) <b>print i</b>
$3 = 40
(gdb) 
</pre>

<p>This, along with the <b>jump</b> command, can help
you repeat sections of code without restarting the program.</p>

<!-- ============================ -->
<a name="hardwatch"></a>
<h3>Hardware Watchpoints</h3>

<p>Hardware watchpoints are special breakpoints that will trigger
whenever an expression changes.  Often you just want to know when a
variable changes (is written to), and for that you can use the <b>watch</b> command:</p>

<pre>Breakpoint 1, main () at hello.c:5
5		int i = 1;
(gdb) <b>watch i</b>
Hardware watchpoint 2: i
(gdb) <b>continue</b>
Continuing.
Hardware watchpoint 2: i

Old value = -1208361280
New value = 2
main () at hello.c:7
7		while (i &lt; 100) {
(gdb) <b>continue</b>
Continuing.
Hardware watchpoint 2: i

Old value = 2
New value = 3
main () at hello.c:7
7		while (i &lt; 100) {
(gdb)
</pre>

<p>Note that <b>watch</b> takes an expression as an
argument, so you can put a variable name in there, or something more
complex like <tt>*(p+5)</tt> or <tt>a[15]</tt>.  I&#39;ve even tried it with conditional
expressions like <tt>i &gt; 10</tt>, but have had
mixed results.</p>

<p>You can get a list of watch points with <b>info
break</b> or <b>info watch</b>, and you can delete
them by number with the <b>delete</b> command.</p>

<p>Finally, you can use <b>rwatch</b> to detect when a
variable is read, and you can use <b>awatch</b> to
detect when a variable is either read or written.</p>

<!-- ============================ -->
<a name="attach"></a>
<h3>Attach to a Running Process</h3>

<p>If your program is already going and you want to stop it and debug,
first you&#39;ll need the process ID (PID), which will be a number.  (Get it
from Unix&#39;s <b>ps</b> command.)  Then you&#39;ll use the <b>attach</b> command with the PID to attach to (and
break) the running program.</p>

<p>For this, you can just start <b>gdb</b> with no
arguments.</p>

<p>In the following complete run, you&#39;ll notice a few things.  First I
attach to the running process, and it tells me it&#39;s in some function
deep down called <tt>__nanosleep_nocancel()</tt>, which
isn&#39;t too surprising since I called <tt>sleep()</tt> in
my code.  Indeed, asking for a <b>backtrace</b> shows
exactly this call stack.  So I say <b>finish</b> a
couple times to get back up to <tt>main()</tt>.

</p><pre>$ <b>gdb</b>
GNU gdb 6.8
Copyright (C) 2008 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type &#34;show copying&#34;
and &#34;show warranty&#34; for details.
This GDB was configured as &#34;i486-slackware-linux&#34;.
(gdb) <b>attach 3490</b>
Attaching to process 3490
Reading symbols from /home/beej/hello...done.
Reading symbols from /lib/libsafe.so.2...done.
Loaded symbols for /lib/libsafe.so.2
Reading symbols from /lib/libc.so.6...done.
Loaded symbols for /lib/libc.so.6
Reading symbols from /lib/libdl.so.2...done.
Loaded symbols for /lib/libdl.so.2
Reading symbols from /lib/ld-linux.so.2...done.
Loaded symbols for /lib/ld-linux.so.2
0xb7eab21b in __nanosleep_nocancel () from /lib/libc.so.6
(gdb) <b>backtrace </b>
#0  0xb7eab21b in __nanosleep_nocancel () from /lib/libc.so.6
#1  0xb7eab05f in sleep () from /lib/libc.so.6
#2  0x080483ab in main () at hello.c:10
(gdb) <b>finish</b>
Run till exit from #0  0xb7eab21b in __nanosleep_nocancel ()
   from /lib/libc.so.6
0xb7eab05f in sleep () from /lib/libc.so.6
(gdb) <b>finish</b>
Run till exit from #0  0xb7eab05f in sleep () from /lib/libc.so.6
0x080483ab in main () at hello.c:10
10			sleep(1);
(gdb) <b>list</b>
5	{
6		int i = 1;
7	
8		while (i &lt; 60) {
9			i++;
10			sleep(1);
11		}
12	
13		return 0;
14	}
(gdb) <b>print i</b>
$1 = 19
(gdb) <b>quit</b>
The program is running.  Quit anyway (and detach it)? (y or n) <b>y</b>
Detaching from program: /home/beej/hello, process 3490
</pre>

<p>Notice that when I get back to <tt>main()</tt>, I
print the value of <tt>i</tt> and it&#39;s 19—because in this case the
program has been running for 19 seconds, and <tt>i</tt> gets incremented
once per second.</p>

<p>Once we&#39;ve quit the debugger and detached from the program, the
program returns to running normally.</p>

<p>Mix this with <b>set variable</b>, above, and
you&#39;ve got some power!</p>

<!-- ============================ -->
<a name="coredump"></a>
<h3>Using Coredumps for Postmortem Analysis</h3>

<p>Let&#39;s say you build and run a program, and it dumps core on you for
some reason or another:</p>

<pre>$ <b>cc -g -o foo foo.c</b>
$ <b>./foo</b>
Segmentation fault (core dumped)
</pre>

<p>This means that a core file (with a memory snapshot from the time of
the crash) has been created with the name &#34;core&#34;.  If you&#39;re not getting
a core file (that is, it only says &#34;Segmentation fault&#34; and no core file
is created), you might have your ulimit set too low; try typing <b>ulimit -c unlimited</b> at your shell
prompt.</p>

<p>You can fire up <b>gdb</b> with the <b>-c</b> option to specify a core file:</p>

<pre>$ <b>gdb -tui -c core foo</b>
</pre>

<p>And, if in TUI mode, you&#39;ll be greeted with a screen of information,
telling you why the program exited (&#34;signal 11, Segmentation fault&#34;),
and the highlight will be on the offending line.  (In dumb terminal
mode, the offending line is printed out.)</p>

<p>In this example, I print the variable that&#39;s causing the problem.
Indeed it is NULL:</p>

<center><img src="https://thomasbroadley.com/blog/i-m-joining-arc-evals/coredump.png"/></center>

<p>Even if you don&#39;t have all the source code, it&#39;s often useful to get
a <b>backtrace</b> from the point the program
crashed.</p>

<!-- ============================ -->
<a name="window"></a>
<h3>Window Functions</h3>

<p>In TUI mode, you can get a list of existing windows with the <b>info win</b> command.  You can then change which
window has focus with the <b>focus</b> (or <b>fs</b>) command.  <b>focus</b> takes
either a window name, or &#34;prev&#34; or &#34;next&#34; as an argument.  Valid window
names are &#34;SRC&#34; (source window), &#34;CMD&#34; (command window), &#34;REGS&#34;
(registers window), and &#34;ASM&#34; (assembly window).  See the next section
for how to use these other windows.</p>

<p>Note that when the SRC window has focus, the arrow keys will move the
source code, but when the CMD window has focus, the arrow keys will
select the previous and next commands in the command history.  (For the
record, the commands to move the SRC window single lines and single
pages are <b>+</b>, <b>-</b>, <b>&lt;</b>, and <b>&gt;</b>.)</p>

<pre>(gdb) <b>info win</b>
        SRC     (36 lines)  &lt;has focus&gt;
        CMD     (18 lines)
(gdb) <b>fs next</b>
Focus set to CMD window.
(gdb) <b>info win</b>
        SRC     (36 lines)
        CMD     (18 lines)  &lt;has focus&gt;
(gdb) <b>fs SRC</b>
Focus set to SRC window.
(gdb)
</pre>

<p>(Window names are case in-sensitive.)</p>

<p>The <b>winheight</b> (or <b>wh</b>) command sets the height of a particular
window, but I&#39;ve had bad luck with this working well.</p>

<!-- ============================ -->
<a name="regasm"></a>
<h3>Display Registers and Assembly</h3>

<p>In TUI mode, the <b>layout</b> command controls
which windows you see.  Additionally, the <b>tui
reg</b> allows control of the register window, and will open it if it&#39;s
not already open.</p>

<!---->The commands are:

<center><table>

<tbody><tr><td><b>layout src</b></td><td>Standard layout—source on top, command window on the
bottom</td></tr>

<tr><td><b>layout asm</b></td><td>Just like the &#34;src&#34; layout, except it&#39;s an assembly window
on top</td></tr>

<tr><td><b>layout split</b></td><td>Three windows: source on top, assembly in the middle, and
command at the bottom</td></tr>

<tr><td><b>layout reg</b></td><td>Opens the register window on top of either source or
assembly, whichever was opened last</td></tr>

<tr><td><b>tui reg general</b></td><td>Show the general registers</td></tr>

<tr><td><b>tui reg float</b></td><td>Show the floating point registers</td></tr>

<tr><td><b>tui reg system</b></td><td>Show the &#34;system&#34; registers</td></tr>

<tr><td><b>tui reg next</b></td><td>Show the next page of registers—this is important
because there might be pages of registers that aren&#39;t in the &#34;general&#34;,
&#34;float&#34;, or &#34;system&#34; sets</td></tr>

</tbody></table></center>

<p>Here&#39;s a nifty screenshot to whet your appetite, showing source and
assembly in &#34;split&#34; mode:</p>

<center><img src="https://thomasbroadley.com/blog/i-m-joining-arc-evals/gdbwinss.png"/></center>

<p>Assembly code comes in two flavors on Intel machines: Intel and
AT&amp;T.  You can set which one appears in the disassembly window with
<b>set disassembly-flavor</b>.  Valid values are
&#34;intel&#34; and &#34;att&#34;.  If you already have the assembly window open, you&#39;ll
have to close it and reopen it (<b>layout src</b>
followed by <b>layout split</b>, for example.)</p>

<p>To display registers in dumb terminal mode, type <b>info registers</b> for the integer registers, or <b>info all-registers</b> for everything.</p>

<!-- ============================ -->
<a name="frontend"></a>
<h3>Writing a Front-End</h3>

<p>You&#39;re thinking, &#34;Wow, this is pretty cool, but I could write a
killer front-end for this thing that worked so much better!  How do I do
it?&#34;</p>

<p>GDB supports what it calls the &#34;machine interface interpreter&#34;, or
GDB/MI.  The interpreter is selected on the <b>gdb</b>
command line with the <b>--interpreter</b> switch.</p>

<p>Basically you&#39;ll launch <b>gdb</b> and read commands
and results to and from it (probably using pipes).  Pretty
straightforward.</p>

<p>See the <a target="_blank" href="http://sourceware.org/gdb/current/onlinedocs/gdb_26.html#SEC263">GDB
documentation for all the details</a>.</p>


<!-- ================================================================ -->
<a name="qref"></a>
<h2>Quick Reference</h2>

<p>Command parameters are in italics.  Optional parameters are in square
brackets.  All commands can be abbreviated until they become ambiguous.</p>

<p><i>This list is very very incomplete, and only shows things talked
about in this tutorial!</i></p>

<center><table>

<tbody><tr><td colspan="2"><b>Help Commands</b></td></tr>

<tr><td><b>help
<i>command</i></b></td><td>Get help on a certain command</td></tr>

<tr><td><b>apropos
<i>keyword</i></b></td><td>Search help for a particular
keyword</td></tr>



<tr><td colspan="2"><b>Starting and Quitting</b></td></tr>

<tr><td><b>gdb <i>[-tui]
[-c core] [exename]</i></b></td><td><b>(Unix Command)</b>
Start <b>gdb</b> on an executable or standalone; specify
&#34;-tui&#34; to start the TUI GUI; specify &#34;-c&#34; with a corefile name to see
where a crash occurred</td></tr>

<tr><td><b>run <i>[arg1] [arg2]
[...]</i></b></td><td>Run the currently loaded program with
the given command line arguments</td></tr>

<tr><td><b>quit</b></td><td>Exit the debugger</td></tr>

<tr><td><b>file
<i>exename</i></b></td><td>Load an executable file by
name</td></tr>



<tr><td colspan="2"><b>Breakpoints and Watchpoints</b></td></tr>

<tr><td><b>break
<i>location</i></b></td><td>Set a breakpoint at a location,
line number, or file (e.g. &#34;main&#34;, &#34;5&#34;, or &#34;hello.c:23&#34;)</td></tr>

<tr><td><b>watch
<i>expression</i></b></td><td>Break when a variable is
written to</td></tr>

<tr><td><b>rwatch
<i>expression</i></b></td><td>Break when a variable is
read from</td></tr>

<tr><td><b>awatch
<i>expression</i></b></td><td>Break when a variable is
written to or read from</td></tr>

<tr><td><b>info break</b></td><td>Display breakpoint and watchpoint information and numbers</td></tr>

<tr><td><b>info watch</b></td><td>Same as <b>info break</b></td></tr>

<tr><td><b>clear
<i>location</i></b></td><td>Clear a breakpoint from a
location</td></tr>

<tr><td><b>delete <i>num</i></b></td><td>Delete a breakpoint or watchpoint by number</td></tr>


<tr><td colspan="2"><b>Stepping and Running</b></td></tr>

<tr><td><b>next</b></td><td>Run to the next line of this function</td></tr>

<tr><td><b>step</b></td><td>Step into the function on this line, if possible</td></tr>

<tr><td><b>stepi</b></td><td>Step a single assembly instruction</td></tr>

<tr><td><b>continue</b></td><td>Keep running from here</td></tr>

<tr><td><b>CTRL-C</b></td><td>Stop running, wherever you are</td></tr>

<tr><td><b>finish</b></td><td>Run until the end of the current function</td></tr>

<tr><td><b>advance
<i>location</i></b></td><td>Advance to a location,
line number, or file (e.g. &#34;somefunction&#34;, &#34;5&#34;, or &#34;hello.c:23&#34;)</td></tr>

<tr><td><b>jump <i>location</i></b></td><td>Just like <b>continue</b>, except jump to
a particular location first.</td></tr>


<tr><td colspan="2"><b>Examining and Modifying Variables</b></td></tr>

<tr><td><b>display
<i>expression</i></b></td><td>Display the value of a
variable or expression every step of the program—the expression
must make sense in the current scope</td></tr>

<tr><td><b>info display</b></td><td>Show a list of expressions currently being displayed and
their numbers</td></tr>

<tr><td><b>undisplay
<i>num</i></b></td><td>Stop showing an expression
identified by its number (see <b>info display</b>)</td></tr>

<tr><td><b>print
<i>expression</i></b></td><td>Print the value of a variable
or expression</td></tr>

<tr><td><b>printf <i>formatstr</i> <i>expressionlist</i></b></td><td>Do some
formatted output with <tt>printf()</tt> e.g. <tt>printf &#34;i = %d, p = %s\n&#34;, i, p</tt></td></tr>

<tr><td><b>set variable
<i>expression</i></b></td><td>Set a variable to value, e.g.
<tt>set variable x=20</tt></td></tr>

<tr><td><b>set
(<i>expression</i>)</b></td><td>Works like <b>set variable</b></td></tr>


<tr><td colspan="2"><b>Window Commands</b></td></tr>

<tr><td><b>info win</b></td><td>Shows current window info</td></tr>

<tr><td><b>focus
<i>winname</i></b></td><td>Set focus to a particular window
bby name (&#34;SRC&#34;, &#34;CMD&#34;, &#34;ASM&#34;, or &#34;REG&#34;) or by position (&#34;next&#34; or
&#34;prev&#34;)</td></tr>

<tr><td><b>fs</b></td><td>Alias for <b>focus</b></td></tr>

<tr><td><b>layout <i>type</i></b></td><td>Set the window layout (&#34;src&#34;, &#34;asm&#34;, &#34;split&#34;, or &#34;reg&#34;)</td></tr>

<tr><td><b>tui reg <i>type</i></b></td><td>Set the register window layout (&#34;general&#34;, &#34;float&#34;,
&#34;system&#34;, or &#34;next&#34;)</td></tr>

<tr><td><b>winheight <i>val</i></b></td><td>Set the window height (either an absolute value, or a
relative value prefaced with &#34;+&#34; or &#34;-&#34;)</td></tr>

<tr><td><b>wh</b></td><td>Alias for <b>winheight</b></td></tr>

<tr><td><b>set disassembly-flavor <i>flavor</i></b></td><td>Set the look-and-feel of the disassembly.  On Intel
machines, valid flavors are <b>intel</b> and <b>att</b></td></tr>



<tr><td colspan="2"><b>Misc Commands</b></td></tr>

<tr><td><b>RETURN</b></td><td>Hit RETURN to repeat the last command</td></tr>

<tr><td><b>backtrace</b></td><td>Show the current stack</td></tr>

<tr><td><b>bt</b></td><td>Alias for <b>backtrace</b></td></tr>

<tr><td><b>attach <i>pid</i></b></td><td>Attach to an already-running process by its PID</td></tr>

<tr><td><b>info registers</b></td><td>Dump integer registers to screen</td></tr>

<tr><td><b>info all-registers</b></td><td>Dump all registers to screen</td></tr>

<!--
<tr><td align="left" colspan="2"><b class="tableheader"></b></td></tr>
<tr><td class="rightpad" align="left"><b class="userinput"></b></td><td align="left"></td></tr>
-->
</tbody></table></center>

<hr/>

<p>Copyright 2009 Brian &#34;Beej Jorgensen&#34; Hall 
&lt;<a href="mailto:beej@beej.us">beej@beej.us</a>&gt;</p>




</div>
  </body>
</html>
