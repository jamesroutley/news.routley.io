<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://00f.net/2023/12/11/webassembly-compilation-to-c/">Original</a>
    <h1>The best WebAssembly runtime may be no runtime</h1>
    
    <div id="readability-page-1" class="page"><div id="wrap">
<header>

  

</header>



<section>
<h2>The best WebAssembly runtime may be no runtime at all</h2>
<article>
 <section>
    <p>When we think “a fast AOT WebAssembly compiler and runtime”, we typically think about V8, Wasmer, WasmEdge or Wasmtime.</p>

<p>All of these have in common that they are large, complicated pieces of software, that come with a lot of overhead, and only work on a limited set of platforms.</p>

<p>But how about transpiling WebAssembly code to C source code, and leveraging the state-of-the-art optimization passes of C compilers?</p>

<p>This is the approach taken by the <code>wasm2c</code> tool from the <a href="https://github.com/WebAssembly/wabt">WABT</a> package, as well as the <a href="https://github.com/ziglang/zig/blob/master/stage1/wasm2c.c">single-file WebAssembly transpiler</a> used to <a href="https://ziglang.org/news/goodbye-cpp/">bootstrap the Zig compiler</a>.</p>

<p>The output of these tools is really a line-by-line conversion of the WebAssembly code to dumb, unoptimized C code.</p>

<p>There are instant benefits to this. First, the ouptut is kinda human readable, which is useful for debugging. A WebAssembly function shows up as a regular C function, that can be directly called from C or any language with a C FFI.</p>

<p>Take existing C code, compile it to WebAssembly, transpile it back to C, and you get the same code, but sandboxed. The transformation acts as a sanitizer that improves safety by restricting the range of virtual memory accessible to each instance.</p>

<p>Of course, that works with any WebAssembly module, no matter what original languages it was written in.</p>

<p>With this approach, assembling different WebAssembly modules also becomes very easy.</p>

<p>Startup time is negligible. There’s no overhead. No runtime either. Just WebAssembly functions directly transpiled to C functions, that are trivial to embed in any project.</p>

<p>The reponsibility to compile that source code to native code is left to a regular C compiler. If the generated C source code is portable enough, this is also a great way to compile and run WebAssembly on embedded targets and new operating systems, that require custom compilers.</p>

<p>This approach can also greatly improve security and reliability. Because they don’t perform any optimization, WebAssembly to C transpilers are extremely small and simple. And the resulting code can even be compiled with formally-verified C compilers such as <a href="https://compcert.org">CompCert</a> for high assurance code generation.</p>

<p>But how about features, usability and performance?</p>

<h2 id="w2c2">w2c2</h2>

<p><a href="https://github.com/turbolent/w2c2">w2c2</a> is probably the most advanced of these transpilers.</p>

<p>Among other things, it supports many WebAssembly extensions, including WASI-core and threads.</p>

<p>This is a fantastic piece of software, but it unfortunately requires a bit of work to setup and use.</p>

<h2 id="installing-w2c2">Installing w2c2</h2>

<p>Clone the <code>w2c2</code> repository:</p>

<div><div><pre><code>git clone &lt;https://github.com/turbolent/w2c2&gt;
<span>cd </span>w2c2
</code></pre></div></div>

<p>Compile it:</p>

<div><div><pre><code><span>mkdir </span>build
<span>cd </span>build
cmake <span>-DCMAKE_BUILD_TYPE</span><span>=</span>Release ..
make
</code></pre></div></div>

<p>Define where the files will be installed:</p>

<div><div><pre><code><span>export </span><span>W2C2_DIR</span><span>=</span>/tmp/w2c2
</code></pre></div></div>

<p>Install them:</p>

<div><div><pre><code><span>install</span> <span>-d</span> <span>&#34;</span><span>$W2C2_DIR</span><span>&#34;</span>/<span>{</span>bin,lib,include/<span>{</span>w2c2,wasi<span>}}</span>
<span>install</span> <span>-s</span> w2c2/w2c2 <span>&#34;</span><span>$W2C2_DIR</span><span>&#34;</span>/bin/
<span>install </span>wasi/libw2c2wasi.a <span>&#34;</span><span>$W2C2_DIR</span><span>&#34;</span>/lib/
<span>install</span> <span>-m</span> 0644 ../w2c2/w2c2_base.h <span>&#34;</span><span>$W2C2_DIR</span><span>&#34;</span>/include/w2c2/
<span>install</span> <span>-m</span> 0644 ../wasi/wasi.h <span>&#34;</span><span>$W2C2_DIR</span><span>&#34;</span>/include/wasi/
</code></pre></div></div>

<p>Alright, let’s get back to the root directory, and add <code>w2c2</code> to the <code>PATH</code> environment variable:</p>

<div><div><pre><code><span>cd</span> ../..
<span>export </span><span>PATH</span><span>=</span><span>&#34;</span><span>$W2C2_DIR</span><span>&#34;</span>/bin:<span>$PATH</span>
rehash <span># only needed on some shells such as zsh</span>
</code></pre></div></div>

<p>On macOS, the <code>w2c2</code> command weights about 150KB only. Yes, that’s all we need to compile WebAssembly modules.
For reference, the <code>wasmer</code> executable alone is 42MB large.</p>

<h2 id="creating-a-webassembly-file">Creating a WebAssembly file</h2>

<p>Next, let’s clone the Zig project boilerplate in order to get an example WebAssembly module:</p>

<div><div><pre><code><span>mkdir test</span> <span>&amp;&amp;</span> <span>cd test
</span>zig init
zig build <span>-Dtarget</span><span>=</span>wasm32-wasi <span>-Doptimize</span><span>=</span>ReleaseSmall <span>\</span>
  <span>-Dcpu</span><span>=</span>baseline+bulk_memory+sign_ext+nontrapping_fptoint
</code></pre></div></div>

<p>The resulting WebAssembly module can be found in <code>zig-out/bin/test.wasm</code>.</p>

<p>By defaut, WebAssembly modules created by Zig aim at maximizing portability, so they target the <code>baseline</code> virtual CPU, that doesn’t enable any WebAssembly extension.</p>

<p>However, bulk memory, sign extension and non-trapping floating point are not a problem for <code>w2c2</code>, so we enable them.</p>

<p>The above example doesn’t use threads, but since Zig supports WASI threads, we could add <code>+atomic</code> to the list of features in order to run multithreaded WebAssembly code.</p>

<h2 id="compiling-webassembly-to-c">Compiling WebAssembly to C</h2>

<p>Now that we have a <code>test.wasm</code> WebAssembly module, the time has come to convert it to C.</p>

<div><div><pre><code><span>mkdir </span>transpiled <span>&amp;&amp;</span> <span>cd </span>transpiled

w2c2 <span>-p</span> ../zig-out/bin/test.wasm test.c
</code></pre></div></div>

<p>The above command creates the <code>test.c</code> and <code>test.h</code> files, containing a C version of our WebAssembly module.</p>

<p>Since the module was named <code>test</code>, automatically generated functions are given <code>test</code> prefix. This allows multiple modules to be used together in the same application without name collisions.</p>

<p>Let’s try compiling this to native code, using a C compiler.</p>

<div><div><pre><code>zig cc test.c <span>-I</span><span>.</span> <span>-I</span><span>&#34;</span><span>$W2C2_DIR</span><span>&#34;</span>/include <span>-L</span><span>&#34;</span><span>$W2C2_DIR</span><span>&#34;</span>/lib <span>-lw2c2wasi</span>

error: undefined reference to symbol_main
error: undefined reference to symbol _wasiMemory
    note: referenced <span>in</span> /private/tmp/w2c2/lib/libw2c2wasi.a<span>(</span>wasi.c.o<span>)</span>
error: undefined reference to symbol_trap
    note: referenced <span>in</span> /Users/j/.cache/zig/o/5868ac77d407c9e2eae52a37fd79e706/test.o
</code></pre></div></div>

<p>The code contains our translated functions, but we still need to instantiate the module and call functions in order to get an application we can actually run.</p>

<p>Let’s create a <code>main.c</code> file to do so:</p>

<div><div><pre><code><span>#include</span> <span>&lt;stdio.h&gt;</span><span>
#include</span> <span>&lt;stdlib.h&gt;</span><span>
#include</span> <span>&lt;w2c2_base.h&gt;</span><span>
#include</span> <span>&lt;wasi.h&gt;</span><span>
#include</span> <span>&#34;test.h&#34;</span><span>
</span>
<span>void</span> <span>trap</span><span>(</span><span>Trap</span> <span>trap</span><span>)</span>
<span>{</span>
    <span>fprintf</span><span>(</span><span>stderr</span><span>,</span> <span>&#34;TRAP: %s</span><span>\n</span><span>&#34;</span><span>,</span> <span>trapDescription</span><span>(</span><span>trap</span><span>));</span>
    <span>abort</span><span>();</span>
<span>}</span>

<span>wasmMemory</span> <span>*</span><span>wasiMemory</span><span>(</span><span>void</span> <span>*</span><span>instance</span><span>)</span>
<span>{</span>
    <span>return</span> <span>test_memory</span><span>((</span><span>testInstance</span> <span>*</span><span>)</span> <span>instance</span><span>);</span>
<span>}</span>

<span>extern</span> <span>char</span> <span>**</span><span>environ</span><span>;</span>

<span>int</span> <span>main</span><span>(</span><span>int</span> <span>argc</span><span>,</span> <span>char</span> <span>*</span><span>argv</span><span>[])</span>
<span>{</span>
    <span>testInstance</span> <span>i</span><span>;</span>

    <span>testInstantiate</span><span>(</span><span>&amp;</span><span>i</span><span>,</span> <span>NULL</span><span>);</span>
    <span>if</span> <span>(</span><span>!</span><span>wasiInit</span><span>(</span><span>argc</span><span>,</span> <span>argv</span><span>,</span> <span>environ</span><span>))</span> <span>{</span>
        <span>fprintf</span><span>(</span><span>stderr</span><span>,</span> <span>&#34;failed to initialize WASI</span><span>\n</span><span>&#34;</span><span>);</span>
        <span>return</span> <span>1</span><span>;</span>
    <span>}</span>
    <span>test__start</span><span>(</span><span>&amp;</span><span>i</span><span>);</span>
    <span>testFreeInstance</span><span>(</span><span>&amp;</span><span>i</span><span>);</span>

    <span>return</span> <span>0</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>In WebAssembly commands, the entry point is named <code>_start()</code>. Functions transpiled to C are named <code>&lt;module name&gt;_&lt;function name&gt;</code>, so in order to call the <code>_start()</code> function, we simply call <code>test__start()</code> with the instance as an argument.</p>

<p>Now that we have a main function, let’s compile all this, and link the <code>w2c2</code> WASI-core implementation by the way since our test example uses it.</p>

<div><div><pre><code>zig cc <span>-o</span> <span>test</span> <span>-O3</span> <span>-s</span> main.c test.c <span>\</span>
  <span>-I</span><span>.</span> <span>-I</span><span>&#34;</span><span>$W2C2_DIR</span><span>&#34;</span>/include/w2c2 <span>-I</span><span>&#34;</span><span>$W2C2_DIR</span><span>&#34;</span>/include/wasi <span>\</span>
  <span>-L</span><span>&#34;</span><span>$W2C2_DIR</span><span>&#34;</span>/lib <span>-lw2c2wasi</span>
</code></pre></div></div>

<p>Done!</p>

<p>We can now run our application:</p>

<div><div><pre><code>./test

All your codebase are belong to us.
</code></pre></div></div>

<p>Yep, that’s it! Our WebAssembly module got converted into a small, self-contained, native executable. Executable size and memory usage are ridiculously small compared to traditional runtimes.</p>

<h2 id="how-about-speed">How about speed?</h2>

<p>Certainly, code blindly transpiled to C cannot be as efficient as a dedicated WebAssembly compiler, right?</p>

<p>Let’s compile the famous <a href="https://libsodium.org">libsodium</a> test/benchmark suite to WebAssembly:</p>

<div><div><pre><code>zig build <span>-Denable_benchmarks</span> <span>-Dtarget</span><span>=</span>wasm32-wasi <span>-Doptimize</span><span>=</span>ReleaseFast <span>\</span>
  <span>-Dcpu</span><span>=</span>baseline+bulk_memory+sign_ext+nontrapping_fptoint
</code></pre></div></div>

<p>The resulting tests are placed into the <code>zig-out/bin</code> directory.</p>

<p>Now, let’s try a pretty heavy one, such as the Ed25519 signature test: <code>zig-out/bin/sign.wasm</code>.</p>

<p>The tests print the time they take to complete, excluding initialization and finalization.</p>

<p>First, with <code>wasmtime</code>, enabling all the supported extensions:</p>

<div><div><pre><code>❯ <span>time </span>wasmtime run <span>--wasm-features</span><span>=</span>all test.wasm
625928560000

wasmtime run <span>--wasm-features</span><span>=</span>all /tmp/test.wasm  124.76s user 0.02s system 99% cpu 2:05.21 total
</code></pre></div></div>

<p>Then, after transpiling the module to C using <code>w2c2</code> and compiling it with <code>zig cc</code>:</p>

<div><div><pre><code>❯ <span>time</span> ./test
361604070000

./test  73.38s user 0.01s system 99% cpu 1:13.65 total
</code></pre></div></div>

<p>You got that right. A naive transpilation to C almost always beats dedicated WebAssembly compilers, sometimes by a large margin. That may change over time, though.</p>

<h2 id="downsides">Downsides</h2>

<p>Of course, there are downsides. An obvious one being that this is incompatible with just-in-time compilation or singlepass compilation. Compilation is not fast, since an initial transpilation pass is required.</p>

<p>The wasm-to-C approach would thus not be a good fit for running arbitrary code in a Web browser.</p>

<p>But no matter what the runtime is, with the <code>wasm32</code> target, memory accesses are limited to 32-bit offsets.
Taking advantage of this and virtual memory, runtimes usually add guard pages around each instance’s memory in order to catch accesses outside the reserved areas.</p>

<p>But the code currently generated by <code>w2c2</code> doesn’t automatically setup these guard pages. This is still left to the application.</p>

<p>As an alternative to guard pages, for <code>wasm64</code> or on platforms without virtual memory, some traditional WebAssembly compilers can decorate memory accesses with bound-checking code. <code>w2c2</code> currently can’t, but it totally could.</p>

<p>In spite of having excellent support for WebAssembly extensions, WASI-core and WASI-threads, <code>w2c2</code> intentionally doesn’t have bells and whistles, some of them being critical for some applications. For example, traditional runtimes often support gas metering and preemption, which are mandatory for many applications.</p>

<h2 id="is-it-for-you">Is it for you?</h2>

<p>If the justification to use WebAssembly is the ability to improve code safety, then <code>w2c2</code> (and the generic wasm-to-C approach) is for you. The result will be small, efficient and easy to use in any language with a C FFI.</p>

<p>On platforms not supported by big runtimes, <code>w2c2</code> may also work for you, and the resulting native code will be faster than interpreters such as <code>wasm3</code>.</p>

<p>For all other cases, traditional runtimes still offer way more features and flexibility.</p>

 </section>
</article>

<nav>
  <a rel="home" href="https://00f.net">Jump back to the home page</a>
</nav>



</section>





</div></div>
  </body>
</html>
