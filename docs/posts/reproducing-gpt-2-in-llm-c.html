<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/karpathy/llm.c/discussions/481">Original</a>
    <h1>Reproducing GPT-2 in llm.c</h1>
    
    <div id="readability-page-1" class="page"><div role="presentation" data-paste-markdown-skip="">
    <tbody data-target-translation-id="6743246" data-target-translation-type="discussion">
        <tr>
    <td>
        <p dir="auto">Let&#39;s reproduce the <a href="https://github.com/openai/gpt-2">GPT-2</a> (124M) in <strong>llm.c</strong> (~4,000 lines of C/CUDA) in 90 minutes for $20. The 124M model is the smallest model in the GPT-2 series released by OpenAI in 2019, and is actually quite accessible today, even for the GPU poor. With llm.c, which is quite efficient at up to ~60% model flops utilization, reproducing this model on one 8X A100 80GB SXM node takes ~90 minutes. For example, on <a href="https://lambdalabs.com" rel="nofollow">Lambda</a> this node goes for ~$14/hr, so the total cost of reproducing this model today is about $20. You can train the model with a single GPU too, it would just take proportionally longer (e.g. ~4-24 hours depending on the GPU). In addition, llm.c still has a lot of pending optimizations and people haven&#39;t tried to tune the training in the style of <a href="https://arxiv.org/abs/2212.14034" rel="nofollow">cramming</a>, so I&#39;d say we&#39;re likely to see significant improvements on this number. So here is the run, training the 12-layer, 12-headed, 768-dimension, 124M Transformer on 10 billion tokens of <a href="https://huggingface.co/datasets/HuggingFaceFW/fineweb" rel="nofollow">FineWeb</a>:</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://private-user-images.githubusercontent.com/241138/334477228-3f456798-4db3-41fb-8cd6-5ae3c8bce2bc.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3MTY5OTk4MDUsIm5iZiI6MTcxNjk5OTUwNSwicGF0aCI6Ii8yNDExMzgvMzM0NDc3MjI4LTNmNDU2Nzk4LTRkYjMtNDFmYi04Y2Q2LTVhZTNjOGJjZTJiYy5wbmc_WC1BbXotQWxnb3JpdGhtPUFXUzQtSE1BQy1TSEEyNTYmWC1BbXotQ3JlZGVudGlhbD1BS0lBVkNPRFlMU0E1M1BRSzRaQSUyRjIwMjQwNTI5JTJGdXMtZWFzdC0xJTJGczMlMkZhd3M0X3JlcXVlc3QmWC1BbXotRGF0ZT0yMDI0MDUyOVQxNjE4MjVaJlgtQW16LUV4cGlyZXM9MzAwJlgtQW16LVNpZ25hdHVyZT03NDhkM2ZkMTI0OWU3ZWVjMTg4OTVhMzY1MTYzNmQwNjA4YWQ0OGU2MjEzNjg5MTA5Nzg0MjI0MDVlNjkxZWZlJlgtQW16LVNpZ25lZEhlYWRlcnM9aG9zdCZhY3Rvcl9pZD0wJmtleV9pZD0wJnJlcG9faWQ9MCJ9.oGIJKy2N0zgOV5_jSrrON2Dh0cdFwVZGQ6Pp09Ydcak"><img src="https://private-user-images.githubusercontent.com/241138/334477228-3f456798-4db3-41fb-8cd6-5ae3c8bce2bc.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3MTY5OTk4MDUsIm5iZiI6MTcxNjk5OTUwNSwicGF0aCI6Ii8yNDExMzgvMzM0NDc3MjI4LTNmNDU2Nzk4LTRkYjMtNDFmYi04Y2Q2LTVhZTNjOGJjZTJiYy5wbmc_WC1BbXotQWxnb3JpdGhtPUFXUzQtSE1BQy1TSEEyNTYmWC1BbXotQ3JlZGVudGlhbD1BS0lBVkNPRFlMU0E1M1BRSzRaQSUyRjIwMjQwNTI5JTJGdXMtZWFzdC0xJTJGczMlMkZhd3M0X3JlcXVlc3QmWC1BbXotRGF0ZT0yMDI0MDUyOVQxNjE4MjVaJlgtQW16LUV4cGlyZXM9MzAwJlgtQW16LVNpZ25hdHVyZT03NDhkM2ZkMTI0OWU3ZWVjMTg4OTVhMzY1MTYzNmQwNjA4YWQ0OGU2MjEzNjg5MTA5Nzg0MjI0MDVlNjkxZWZlJlgtQW16LVNpZ25lZEhlYWRlcnM9aG9zdCZhY3Rvcl9pZD0wJmtleV9pZD0wJnJlcG9faWQ9MCJ9.oGIJKy2N0zgOV5_jSrrON2Dh0cdFwVZGQ6Pp09Ydcak" alt="chart124M"/></a></p>
<p dir="auto">The left pane shows that we outperform the checkpoint released by OpenAI on the FineWeb withheld validation dataset. This is not the ideal metric because the data distribution of GPT-2 was different (it was trained on the never released &#34;WebText&#34; dataset) and the statistics of the internet may have been different 5 years ago, so it&#39;s not a super fair comparison. Therefore, in addition on the right we also plot the <a href="https://rowanzellers.com/hellaswag/" rel="nofollow">HellaSwag</a> accuracy, a benchmark commonly used to assess LLM capability that is nice, smooth, and well-behaved. I&#39;d mostly look at HellaSwag, but FineWeb val is a nice confirmation. That said, HellaSwag has no math/code so it slightly favors our setting (common crawl-like data). One more point of reference is that GPT-3 in Appendix H cites HellaSwag accuracy at 33.7 for GPT-3 Small (124M) model. We get to 29.9 here, which surpasses GPT-2 (124M) at 29.4. Keep in mind that here we trained for 10B tokens, while GPT-3 models were all trained for 300B tokens.</p>
<p dir="auto">Now here is the shortest path to reproducing this result yourself. You&#39;ll need a GPU. I like and run my work on <a href="https://lambdalabs.com" rel="nofollow">Lambda labs</a> (who graciously sponsors in llm.c development), though the inventory can be limited at times. Many other providers exist and you can use the Discussion below for tips and tricks around this. Here is the example process for a Linux x86 64bit Ubuntu 22.04 with CUDA 12 (this is somewhere around the current, default &#34;modern&#34; configuration). If you&#39;re on a different system, the comments and discussion in the main <a href="https://github.com/karpathy/llm.c">README file</a> might be helpful.</p>
<div dir="auto" data-snippet-clipboard-copy-content="
# install miniconda
mkdir -p ~/miniconda3
wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh -O ~/miniconda3/miniconda.sh
bash ~/miniconda3/miniconda.sh -b -u -p ~/miniconda3
rm -rf ~/miniconda3/miniconda.sh
~/miniconda3/bin/conda init bash
source ~/.bashrc

# pytorch nightly (optional) https://pytorch.org/get-started/locally/
# conda install --yes pytorch torchvision torchaudio pytorch-cuda=12.1 -c pytorch-nightly -c nvidia

# pip installs so we can tokenize the FineWeb dataset
yes | pip install tqdm tiktoken requests datasets

# install cudnn so we can use FlashAttention and run fast (optional)
# https://developer.nvidia.com/cudnn-downloads
# for me, CUDA 12 (run `nvcc --version`) running on Linux x86_64 Ubuntu 22.04
wget https://developer.download.nvidia.com/compute/cudnn/9.1.1/local_installers/cudnn-local-repo-ubuntu2204-9.1.1_1.0-1_amd64.deb
sudo dpkg -i cudnn-local-repo-ubuntu2204-9.1.1_1.0-1_amd64.deb
sudo cp /var/cudnn-local-repo-ubuntu2204-9.1.1/cudnn-*-keyring.gpg /usr/share/keyrings/
sudo apt-get update
sudo apt-get -y install cudnn-cuda-12

# &#34;install&#34; cudnn-frontend to ~/
git clone https://github.com/NVIDIA/cudnn-frontend.git

# install MPI (optional, if you intend to use multiple GPUs)
sudo apt install openmpi-bin openmpi-doc libopenmpi-dev

# tokenize the FineWeb dataset 10B tokens sample (takes ~1 hour, get lunch?)
# writes ~19GB of raw GPT-2 tokens to dev/data/fineweb10B
# and ~46GB in ~/.cache/huggingface/datasets/HuggingFaceFW___fineweb
git clone https://github.com/karpathy/llm.c.git
cd llm.c
python dev/data/fineweb.py --version 10B

# compile llm.c (mixed precision, with cuDNN flash-attention)
# first compilation is ~1 minute, mostly due to cuDNN
make train_gpt2cu USE_CUDNN=1

# train on a single GPU
./train_gpt2cu \
    -i &#34;dev/data/fineweb10B/fineweb_train_*.bin&#34; \
    -j &#34;dev/data/fineweb10B/fineweb_val_*.bin&#34; \
    -o log124M \
    -e &#34;d12&#34; \
    -b 64 -t 1024 \
    -d 524288 \
    -r 1 \
    -z 1 \
    -c 0.1 \
    -l 0.0006 \
    -q 0.0 \
    -u 700 \
    -n 5000 \
    -v 250 -s 20000 \
    -h 1

# if you have multiple GPUs (e.g. 8), simply prepend the mpi command, e.g.:
# mpirun -np 8 ./train_gpt2cu \ ... (the rest of the args are same)"><pre><span><span>#</span> install miniconda</span>
mkdir -p <span>~</span>/miniconda3
wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh -O <span>~</span>/miniconda3/miniconda.sh
bash <span>~</span>/miniconda3/miniconda.sh -b -u -p <span>~</span>/miniconda3
rm -rf <span>~</span>/miniconda3/miniconda.sh
<span>~</span>/miniconda3/bin/conda init bash
<span>source</span> <span>~</span>/.bashrc

<span><span>#</span> pytorch nightly (optional) https://pytorch.org/get-started/locally/</span>
<span><span>#</span> conda install --yes pytorch torchvision torchaudio pytorch-cuda=12.1 -c pytorch-nightly -c nvidia</span>

<span><span>#</span> pip installs so we can tokenize the FineWeb dataset</span>
yes <span>|</span> pip install tqdm tiktoken requests datasets

<span><span>#</span> install cudnn so we can use FlashAttention and run fast (optional)</span>
<span><span>#</span> https://developer.nvidia.com/cudnn-downloads</span>
<span><span>#</span> for me, CUDA 12 (run `nvcc --version`) running on Linux x86_64 Ubuntu 22.04</span>
wget https://developer.download.nvidia.com/compute/cudnn/9.1.1/local_installers/cudnn-local-repo-ubuntu2204-9.1.1_1.0-1_amd64.deb
sudo dpkg -i cudnn-local-repo-ubuntu2204-9.1.1_1.0-1_amd64.deb
sudo cp /var/cudnn-local-repo-ubuntu2204-9.1.1/cudnn-<span>*</span>-keyring.gpg /usr/share/keyrings/
sudo apt-get update
sudo apt-get -y install cudnn-cuda-12

<span><span>#</span> &#34;install&#34; cudnn-frontend to ~/</span>
git clone https://github.com/NVIDIA/cudnn-frontend.git

<span><span>#</span> install MPI (optional, if you intend to use multiple GPUs)</span>
sudo apt install openmpi-bin openmpi-doc libopenmpi-dev

<span><span>#</span> tokenize the FineWeb dataset 10B tokens sample (takes ~1 hour, get lunch?)</span>
<span><span>#</span> writes ~19GB of raw GPT-2 tokens to dev/data/fineweb10B</span>
<span><span>#</span> and ~46GB in ~/.cache/huggingface/datasets/HuggingFaceFW___fineweb</span>
git clone https://github.com/karpathy/llm.c.git
<span>cd</span> llm.c
python dev/data/fineweb.py --version 10B

<span><span>#</span> compile llm.c (mixed precision, with cuDNN flash-attention)</span>
<span><span>#</span> first compilation is ~1 minute, mostly due to cuDNN</span>
make train_gpt2cu USE_CUDNN=1

<span><span>#</span> train on a single GPU</span>
./train_gpt2cu \
    -i <span><span>&#34;</span>dev/data/fineweb10B/fineweb_train_*.bin<span>&#34;</span></span> \
    -j <span><span>&#34;</span>dev/data/fineweb10B/fineweb_val_*.bin<span>&#34;</span></span> \
    -o log124M \
    -e <span><span>&#34;</span>d12<span>&#34;</span></span> \
    -b 64 -t 1024 \
    -d 524288 \
    -r 1 \
    -z 1 \
    -c 0.1 \
    -l 0.0006 \
    -q 0.0 \
    -u 700 \
    -n 5000 \
    -v 250 -s 20000 \
    -h 1

<span><span>#</span> if you have multiple GPUs (e.g. 8), simply prepend the mpi command, e.g.:</span>
<span><span>#</span> mpirun -np 8 ./train_gpt2cu \ ... (the rest of the args are same)</span></pre></div>
<p dir="auto"><strong>Args guide.</strong> A lot of these hyperparameters follow the <a href="https://arxiv.org/abs/2005.14165" rel="nofollow">GPT-3 paper</a> instead of the GPT-2 paper, because it was a lot more detailed. Args explanation:</p>
<ul dir="auto">
<li><code>-i -j</code> are training and validation splits token files, written by <code>fineweb.py</code></li>
<li><code>-o</code> is the output directory to write logs and checkpoints into</li>
<li><code>-e &#34;d12&#34;</code> asks to initialize, a depth 12 GPT-2 model from scratch</li>
<li><code>-b 64</code> sets the micro-batch size to 64 . If you are running out of memory, decrease this value, e.g. try 32, 16, 8, all the way down to 1 potentially.</li>
<li><code>-t 1024</code> sets the maximum sequence length to 1024, as GPT-2 did</li>
<li><code>-d 524288</code> requests that the total batch size per single update be ~0.5M tokens. The code will take this desired batch size and calculate the needed gradient accumulation &#34;inner loop&#34; steps of the optimization. For example on 8 GPUs, at -b 64 and -t 1024, every microbatch is doing exactly 8 X 64 X 1024 = 524288 tokens, so there is no need for gradient accumulation. But if we we only have 1 GPU, then the code will set it to 8, and do an inner loop of 8 iterations to add up to this &#34;total batch size&#34; per step. While the batch size used to train GPT-2 is unknown, this number ~0.5M comes from the GPT-3 paper table, for this model size.</li>
<li><code>-r 1</code> sets the recompute setting = 1, so we will re-compute the GeLU activations. This slightly increases the runtime, but saves quite a bit of memory, allowing us to increase the batch size and get a net increase in token throughput.</li>
<li><code>-z 1</code> turns on ZeRO-1 (i.e. optimizer state sharding) across multiple GPUs. If you&#39;re training with &gt; 1 GPU, this setting is a no-brainer and should basically always be on. On 1 GPU this setting is a no-op.</li>
<li><code>-c 0.1</code> sets the weight decay to 0.1. Only (2D) weights are decayed exactly as in GPT-2, and this number comes from the GPT-3 paper</li>
<li><code>-l 0.0006</code> sets the maximum learning rate, from GPT-3 paper.</li>
<li><code>-q 0.0</code> says that we will decay the learning rate to 0 over the course of training.</li>
<li><code>-u 700</code> says that we will ramp up the learning rate from 0 to max learning rate over the first 700 iterations, which at total batch size 0.5M is 350M tokens, following GPT-3 paper.</li>
<li><code>-n 5000</code> asks to save model checkpoints every 5000 steps.</li>
<li><code>-v 250</code> asks to evaluate and log the validation loss every 250 steps</li>
<li><code>-s 20000</code> asks to sample some tokens every 20000 steps. Because the total number of steps will be less than this (see below), this basically turns generation off and we will only basically sample a single time at the very end.</li>
<li><code>-h 1</code> asks to evaluate the HellaSwag accuracy, something we can compare across papers.</li>
<li>Because we did not set the maximum number of steps using <code>-x</code> flag, it defaults to exactly one epoch over the training data, i.e. 10B tokens. Because the total batch size is ~0.5M and total number of tokens is 10B, there will be a total of ~ 10B/0.5M = 20K steps.</li>
</ul>
<p dir="auto">There&#39;s a lot of detail above but the TLDR is that we&#39;re training a 12-layer GPT-2 (124M), from scratch, on 10B tokens of FineWeb, with max sequence length of 1024 tokens. If you are running out of memory, I would first make sure you have <code>-r 1</code> turned on, and then I would start decreasing the batch size <code>-b</code> by dividing it by 2, until the runs. Once it runs, I&#39;d see if you can get away with turning <code>-r 0</code> back on to recover a little bit of speed.</p>
<p dir="auto"><strong>Training</strong>. The code will print something like this over time (this is an example of a single A100 40GB PCIe GPU, $1.29/hr):</p>
<div data-snippet-clipboard-copy-content="step   80/18865 | train loss 7.577051 | norm 1.1461 | lr 6.86e-05 | 2950.68 ms | 49.0% A100 fp16 MFU | 177968 tok/s
step   81/18865 | train loss 7.540626 | norm 1.4001 | lr 6.94e-05 | 2952.59 ms | 49.0% A100 fp16 MFU | 177948 tok/s
step   82/18865 | train loss 7.465753 | norm 1.0613 | lr 7.03e-05 | 2953.98 ms | 48.9% A100 fp16 MFU | 177924 tok/s
step   83/18865 | train loss 7.472681 | norm 1.1553 | lr 7.11e-05 | 2955.67 ms | 48.9% A100 fp16 MFU | 177897 tok/s"><pre><code>step   80/18865 | train loss 7.577051 | norm 1.1461 | lr 6.86e-05 | 2950.68 ms | 49.0% A100 fp16 MFU | 177968 tok/s
step   81/18865 | train loss 7.540626 | norm 1.4001 | lr 6.94e-05 | 2952.59 ms | 49.0% A100 fp16 MFU | 177948 tok/s
step   82/18865 | train loss 7.465753 | norm 1.0613 | lr 7.03e-05 | 2953.98 ms | 48.9% A100 fp16 MFU | 177924 tok/s
step   83/18865 | train loss 7.472681 | norm 1.1553 | lr 7.11e-05 | 2955.67 ms | 48.9% A100 fp16 MFU | 177897 tok/s
</code></pre></div>
<p dir="auto">What is going on? Well, we have 10B training tokens and our batch size is ~0.5M, so we&#39;d expect about 10B/0.5M ~= 20K steps in total. It actually works out to exactly 18,865 because one of the data shards is reserved for validation data and the exact batch size is a nice power of 2 @ 524,288. So here we are on step 80/18865, which in total took 2950.68ms. MFU is short for &#34;Model Flops Utilization&#34;. The A100 claims to offer 312 TFLOPS, but in practice this is very hard to achieve because the training is memory-bound and we can&#39;t feed the TensorCores that do the matrix multiplies. On this A100 40GB PCIe GPU, we see that when we count up the FLOPs we&#39;re doing and divide by time, we&#39;re roughly at half the theoretical, maximum peak FLOPS, which is quite good. If you used the A100 80GB SXM with higher memory bandwidth and max thermal design power, this goes up to ~60%. (If you use a GPU that is not A100, ignore this number because it is in units of A100 fp16 FLOPS). We also see that the token throughput we are achieving is about 178K tok/s. Next, our current loss is 7.577. The lower this is, the better our model is at predicting the next token in the sequence on average. Step 80 is very early in the training here. Because the perplexity is exp(7.577) ~= 2K, our model is as confused about each next token on average, as if it was guessing at random from 2,000 tokens. The full vocab size is 50,257. By the end of the optimization we&#39;ll get to about 3.29, so it&#39;s as if we&#39;re guessing uniformly at random from exp(3.29) ~= 27 tokens at each time step. Finally we see the gradient norm is 1.1461. When this number spikes, the gradient is exploding and this is very bad. To mitigate gradient explosions, as is standard, llm.c uses gradient clipping at 1.0, so if the gradient norm exceeds 1.0 (like in this time step) we forcefully scale it down so it&#39;s norm is up to 1.0. Later in the optimization, the gradient norm usually &#34;calms down&#34; to lower values.</p>
<p dir="auto"><strong>Visualization</strong>. Finally, you&#39;ll want to make pretty charts like the one I posted up above. For that, our program is printing some very rudimentary logs to an improvised <code>log124M/main.log</code> file. I have attached an example <a href="https://github.com/karpathy/llm.c/blob/master/dev/vislog.ipynb">Jupyter notebook</a> that parses these files and visualizes them in the style above.</p>
<p dir="auto"><strong>Tokenizer.</strong> When you&#39;re training up above, you&#39;ll see a warning that llm.c couldn&#39;t find the GPT-2 tokenizer .bin file. That&#39;s totally fine for training, but it means that we can&#39;t decode - i.e. we can&#39;t convert integer tokens that we sample into little string pieces, to create text that we can read. Here is how we can generate it:</p>
<div dir="auto" data-snippet-clipboard-copy-content="
# install pytorch nightly
conda install --yes pytorch torchvision torchaudio pytorch-cuda=12.1 -c pytorch-nightly -c nvidia

# install huggingface transformers
pip install transformers

# preprocess the TinyShakespeare dataset (very fast, much faster than FineWeb)
python dev/data/tinyshakespeare.py

# run a little training loop in Python/PyTorch
# it saved a lot of .bin files, including the Tokenizer
python train_gpt2.py"><pre><span><span>#</span> install pytorch nightly</span>
conda install --yes pytorch torchvision torchaudio pytorch-cuda=12.1 -c pytorch-nightly -c nvidia

<span><span>#</span> install huggingface transformers</span>
pip install transformers

<span><span>#</span> preprocess the TinyShakespeare dataset (very fast, much faster than FineWeb)</span>
python dev/data/tinyshakespeare.py

<span><span>#</span> run a little training loop in Python/PyTorch</span>
<span><span>#</span> it saved a lot of .bin files, including the Tokenizer</span>
python train_gpt2.py</pre></div>
<p dir="auto">The Python script is a parallel implementation to llm.c used for error checking and unit tests (but doesn&#39;t have full feature parity). In particular, if we run it like above it will write the file <code>gpt2_tokenizer.bin</code>, which the C code can read and use to output nice text during sampling.</p>
<p dir="auto"><strong>Sampling.</strong> The code is currently not really intended for inference, but you can hack the code to do inference very inefficiently (without any kv-cache etc.) with something like this:</p>
<div dir="auto" data-snippet-clipboard-copy-content="make train_gpt2cu USE_CUDNN=1
./train_gpt2cu \
    -i &#34;dev/data/fineweb10B/fineweb_train_*.bin&#34; \
    -j &#34;dev/data/fineweb10B/fineweb_val_*.bin&#34; \
    -e &#34;log124M/gpt2_124M_00018865.bin&#34; \
    -b 1 -t 1024 \
    -x 1 \
    -l 0.0 \
    -s 1 -g 256"><pre>make train_gpt2cu USE_CUDNN=1
./train_gpt2cu \
    -i <span><span>&#34;</span>dev/data/fineweb10B/fineweb_train_*.bin<span>&#34;</span></span> \
    -j <span><span>&#34;</span>dev/data/fineweb10B/fineweb_val_*.bin<span>&#34;</span></span> \
    -e <span><span>&#34;</span>log124M/gpt2_124M_00018865.bin<span>&#34;</span></span> \
    -b 1 -t 1024 \
    -x 1 \
    -l 0.0 \
    -s 1 -g 256</pre></div>
<p dir="auto">The <code>-i -j</code> flags are spurious. <code>-e</code> flag is pointing at the final model checkpoint of our GPT-2 124M model, which llm.c will initialize the model from. The <code>-b 1</code> is saying to use only a single batch element (one row of length 1024 tokens in which we sample from left to right). The <code>-x 1</code> is saying we only want to run for a single step, and <code>-l 0.0</code> is setting the learning rate to zero so we don&#39;t actually train the model on this single step. Finally <code>-s 1</code> is saying &#34;sample every step&#34; and <code>-g 256</code> is saying sample 256 tokens.</p>
<p dir="auto">Now, the above is just unconditional sampling. It&#39;s possible to hack the code to do conditional sampling, i.e. sequence completion. E.g. I asked our 124M model to complete the text <em>&#34;The GitHub project llm.c is a&#34;</em>, and it continued:  <em>&#34;free service to enhance the scholarly infrastructure of the academic community.&#34;</em>. I then re-sampled with a different seed and got &#34;<em>The GitHub project llm.c is a collaborative effort that rocks GitHub itself</em>&#34;. So, not bad I guess :) I had to directly hack the code by setting <code>gen_tokens[1:10]</code> to be the prompt tokens 464, 21722, 1628, 32660, 76, 13, 66, 318, 257 (from <a href="https://tiktokenizer.vercel.app/?model=gpt2" rel="nofollow">tiktokenizer</a> ty), then hacked the loop index that samples to start at token position 10, ... you get the idea TLDR conditional generation is not really supported but in principle possible, possibly coming soon.</p>
<p dir="auto"><strong>Code</strong>. 95% of the heavy lifting is in the <a href="https://github.com/karpathy/llm.c/blob/master/train_gpt2.cu">train_gpt2.cu</a> file. It started as a nice clean 1,000 LOC C code, but has grown quite a bit and now it&#39;s closer to 3,500 LOC, with 4 supporting files of file I/O utils, tokenizer, dataloader, and random number generation. Roughly speaking, the first 500 LOC are just basic setup of up MPI, NCCL, cuDNN, cuBLAS, etc etc. The next 1,500 LOC are all the layers of the Transformer, and both their forward and backward implementation in efficient CUDA code. All the CUDA kernel development for these files happens in <code>dev/cuda</code>. So for example there is a <code>gelu_forward()</code> and then also a <code>gelu_backward()</code>, and the same way for all the other layers. The next 1,000 LOC are the <code>gpt2</code> model, which just strings together the layers and itself has one big <code>gpt2_forward()</code> and <code>gpt2_backward()</code>. The last 1,000 LOC are int main(), which has the main training loop and all the related bookkeeping and argument parsing, and a lot of tedious code around e.g. resuming training from a previous checkpoint, etc.</p>
<p dir="auto"><strong>350M model</strong>. Overnight I also reproduced the 350M parameter model. Take a look at the file <a href="https://github.com/karpathy/llm.c/blob/master/run350M.sh">run350M.sh</a> for the exact launch command. I found that 10B tokens was not enough for the 350M model, so you&#39;ll have to download and preprocess the FineWeb100B (or try to do multiple epochs on just the 10B above, which might work, I have not checked). I configured it to train for 30B tokens, so we have that:</p>
<p dir="auto">FLOPS using 6ND approximation:</p>
<ul dir="auto">
<li>124M on 10B tokens =&gt; 6 * 124e6 * 10e9 = 7.44e18 ~= 7e18 capability model</li>
<li>350M on 30B tokens =&gt; 6 * 350e6 * 31.5e9 = 6.615e19 ~= 7e19 capability model (~10X)</li>
</ul>
<p dir="auto">On 8X A100 80GB SXM the 350M stepped at 820ms/iter. Trained for 60K steps (instead of ~20K), for a total of ~30B tokens (instead of ~10B tokens). Total training time 14 hours. Cost $14/hr =&gt; 14 X 14 ~= $200 (10X of 124M). However looking at the plot, it&#39;s possible that we could have gotten away with slightly less:</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://private-user-images.githubusercontent.com/241138/334477479-87dc0952-d18d-41a5-9f4c-7f6667034fd4.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3MTY5OTk4MDUsIm5iZiI6MTcxNjk5OTUwNSwicGF0aCI6Ii8yNDExMzgvMzM0NDc3NDc5LTg3ZGMwOTUyLWQxOGQtNDFhNS05ZjRjLTdmNjY2NzAzNGZkNC5wbmc_WC1BbXotQWxnb3JpdGhtPUFXUzQtSE1BQy1TSEEyNTYmWC1BbXotQ3JlZGVudGlhbD1BS0lBVkNPRFlMU0E1M1BRSzRaQSUyRjIwMjQwNTI5JTJGdXMtZWFzdC0xJTJGczMlMkZhd3M0X3JlcXVlc3QmWC1BbXotRGF0ZT0yMDI0MDUyOVQxNjE4MjVaJlgtQW16LUV4cGlyZXM9MzAwJlgtQW16LVNpZ25hdHVyZT0xZGVkZjM3MzRkNTZjMWNhNDE5YjNmZjhhZGMzMjdhN2E0YmY5N2FkMTZjNjdlNjc3ODJmNjc5YWE5MDkyYjc2JlgtQW16LVNpZ25lZEhlYWRlcnM9aG9zdCZhY3Rvcl9pZD0wJmtleV9pZD0wJnJlcG9faWQ9MCJ9.mliZEb15yDjAY9jJazphfyL4TeXst7Hxc1DL-m2QM3Y"><img src="https://private-user-images.githubusercontent.com/241138/334477479-87dc0952-d18d-41a5-9f4c-7f6667034fd4.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3MTY5OTk4MDUsIm5iZiI6MTcxNjk5OTUwNSwicGF0aCI6Ii8yNDExMzgvMzM0NDc3NDc5LTg3ZGMwOTUyLWQxOGQtNDFhNS05ZjRjLTdmNjY2NzAzNGZkNC5wbmc_WC1BbXotQWxnb3JpdGhtPUFXUzQtSE1BQy1TSEEyNTYmWC1BbXotQ3JlZGVudGlhbD1BS0lBVkNPRFlMU0E1M1BRSzRaQSUyRjIwMjQwNTI5JTJGdXMtZWFzdC0xJTJGczMlMkZhd3M0X3JlcXVlc3QmWC1BbXotRGF0ZT0yMDI0MDUyOVQxNjE4MjVaJlgtQW16LUV4cGlyZXM9MzAwJlgtQW16LVNpZ25hdHVyZT0xZGVkZjM3MzRkNTZjMWNhNDE5YjNmZjhhZGMzMjdhN2E0YmY5N2FkMTZjNjdlNjc3ODJmNjc5YWE5MDkyYjc2JlgtQW16LVNpZ25lZEhlYWRlcnM9aG9zdCZhY3Rvcl9pZD0wJmtleV9pZD0wJnJlcG9faWQ9MCJ9.mliZEb15yDjAY9jJazphfyL4TeXst7Hxc1DL-m2QM3Y" alt="chart350M"/></a></p>
<p dir="auto"><strong>Coming up.</strong> That&#39;s it for now! We are moving on to the 740M and then, of course, the actual &#34;GPT-2&#34; 1558M. If I can find the GPUs... By very rough napkin math, on my single 8X A100 80GB GPU box, the 1558M model would take ~1 week and cost ~$2.5K. This is in acceptable territory, but we&#39;ll want to take some time to make the current code better, cleaner, better tested, and add multi-node training support. And also very much still on my mind, I want to <a href="https://x.com/karpathy/status/1760388761349927356?lang=en" rel="nofollow">build the whole thing again</a>, from scratch and piece by piece, coming to you soon^TM.</p>
<p dir="auto"><strong>FAQ:</strong></p>
<ul dir="auto">
<li>Can I <strong>sample</strong> from it? kind of, but it&#39;s inefficient and a bit weird.</li>
<li>Can I <strong>chat</strong> with it? no, this is currently only pretraining, not chat finetuning.</li>
<li>Can you train <strong>multi-node</strong> distributed? in principle yes, there is a slurm <a href="https://github.com/karpathy/llm.c/pull/426" data-hovercard-type="pull_request" data-hovercard-url="/karpathy/llm.c/pull/426/hovercard">PR</a> up that got this working for up 50 nodes. In practice I personally haven&#39;t tried yet.</li>
<li>Are you bitwise <strong>deterministic</strong>? No but we are very close, one more kernel to patch.</li>
<li>Can you train in <strong>fp8</strong>? No, we&#39;re currently mostly training in bf16, but coming soon.</li>
<li>I have a non-NVIDIA GPU (<strong>AMD, Apple Silicon</strong>, etc.) can I run llm.c? No, llm.c supports C/CUDA only, but I am very happy to link to any forks under &#34;notable forks&#34; section, or accept PRs that would make porting llm.c to other platforms easier.</li>
<li>I only have a <strong>CPU</strong>, can I play? You won&#39;t be able to reproduce GPT-2 models, but you can take on fun projects by finetuning OpenAI GPT-2 models on other data, e.g. TinyShakespeare or TinyStories. Support for these datasets, initialization, and CPU finetuning exists in llm.c in train_gpt2.c. (It&#39;s a lot more rudimentary though, intended mostly as a reference for the CUDA code).</li>
<li>How does this compare to <strong>PyTorch</strong>? llm.c is a &#34;straight up&#34; C/CUDA implementation. The PyTorch code at <code>train_gpt2.py</code> does not have full feature parity (e.g. doesn&#39;t do sharded data loading, etc.) and is meant to be more as a reference, but I think you can get something similar to the 124M model above stepping as follows: <code>torchrun --standalone --nproc_per_node=4 python train_gpt2.py --input_bin dev/data/fineweb10B/fineweb_train_000001.bin --write_tensors 0 --model d12 --batch_size 64 --sequence_length 1024 --total_batch_size 524288 --dtype bfloat16 --compile 1 --tensorcores 1 --flash 1 --num_iterations 18865 --weight_decay 0.1 --overfit_single_batch 0</code>. I am interested in and would accept PRs that bring the PyTorch training closer up to feature parity to the llm.c training loop.</li>
<li>Why do you care so much about <strong>GPT-2</strong>? GPT-2 is the grand-daddy of LLMs, the first time that the modern LLM stack came together in a recognizably modern form, and the parameters were released by OpenAI. GPT-3 actually didn&#39;t change too much at all about the model (context size 1024 -&gt; 2048, I think that&#39;s it?). GPT-4 details were never published. Many other LLMs also strongly resemble GPT-2, despite it being from 2019, e.g. Llama 3 from the architecture perspective is a non-linearity change in the MLP and the addition of the RoPE relative positional encoding.</li>
</ul>
<p dir="auto"><strong>Acknowledgements</strong></p>
<p dir="auto">Please feel free to use the Discussions for any FAQ and related, or if you&#39;d like something faster, #llmc on <a href="https://discord.gg/3zy8kqD9Cp" rel="nofollow">Discord</a>, or #llmdotc on CUDA MODE Discord.</p>
    </td>
  </tr>

    </tbody>
  </div></div>
  </body>
</html>
