<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://rogersm.net/posts/developing-a-go-bot-embedding-ichiban-prolog/">Original</a>
    <h1>Developing a Go bot embedding Ichiban Prolog</h1>
    
    <div id="readability-page-1" class="page"><div>
<p><a href="https://github.com/ichiban/Prolog">Ichiban Prolog</a> is a #golang implementation of an ISO compatible Prolog. To learn how to embed it, I decided to add Prolog support to <a href="https://github.com/whyrusleeping/Hellabot">Hellabot</a>, a simple irc bot.</p>
<p>Hellabot design requires to program its triggers using a two step process as described in the code below:</p>
<div><pre tabindex="0"><code data-lang="go"><span><span><span>type</span> Trigger <span>struct</span> {
</span></span><span><span>    <span>// Returns true if this trigger applies to the passed in message
</span></span></span><span><span><span></span>    Condition <span>func</span>(<span>*</span>Bot, <span>*</span>Message) <span>bool</span>
</span></span><span><span>    <span>// The action to perform if Condition is true
</span></span></span><span><span><span></span>    <span>// return true if the message was &#39;consumed&#39;
</span></span></span><span><span><span></span>    Action <span>func</span>(<span>*</span>Bot, <span>*</span>Message) <span>bool</span>
</span></span><span><span>}
</span></span></code></pre></div><p>Because the code to develop the trigger is in go, it requires to re-compile the bot every time a new trigger is created/updated. Because of this, embedding a language that can read the code externally is an attractive solution. In this case, I have selected Prolog due to being a flexible, high level language,  <a href="https://www.metalevel.at/Prolog">extremely well documented</a> and ideal to parse text using <a href="https://www.metalevel.at/Prolog/dcg">Prolog’s DCGs.</a></p>
<p>Our strategy to remove the recompilation dependency, we will update bot to read Prolog code from a file that can be edited any time by the user. In this post, the Prolog code will be loaded when Hellabot triggers the even on message reception. This will allow the user to change the bot’s logic without the need to recompile and redeploy the bot.</p>
<p>To make this job easier, we first simplify the trigger struct to have a single function that will execute the Prolog code. This new Exec() function will trigger the condition and execute the action in a single step. To make this possible we create a new struct to be used for Prolog triggers:</p>
<div><pre tabindex="0"><code data-lang="go"><span><span><span>type</span> PrologTrigger <span>struct</span> {
</span></span><span><span>   <span>// Returns true if the Prolog code executes correctly
</span></span></span><span><span><span></span>   Exec <span>func</span>(<span>*</span>hbot.Bot, <span>*</span>hbot.Message) <span>bool</span>
</span></span><span><span>}
</span></span></code></pre></div><p>The first version of the code implements a extremely simple logic. PrologTrigger’s Exec function will:</p>
<ol>
<li>Instantiate a new ichiban Prolog interpreter.</li>
<li>Share the irc message to the interprter.</li>
<li>Load the external file with the irc message terms generated in #2.</li>
<li>Execute the Prolog clause to execute the script.</li>
<li>Print the clause output to the irc client (using Hellabot API).</li>
</ol>
<p>Each step has it’s own interesting challenges:</p>
<h2 id="1-instantiate-a-new-ichiban-prolog-interpreter">1. Instantiate a new ichiban Prolog interpreter</h2>
<p>This is probably the easiest step, because it just requires to instantiate ichiban Prolog runtime without any need for it to read/write from any descriptor.</p>
<div><pre tabindex="0"><code data-lang="go"><span><span><span>var</span> PrologTrigger = PrologTrigger{
</span></span><span><span>	Exec: <span>func</span>(irc <span>*</span>hbot.Bot, message <span>*</span>hbot.Message) <span>bool</span> {
</span></span><span><span> 
</span></span><span><span> 		plRuntime <span>:=</span> Prolog.<span>New</span>(<span>nil</span>, <span>nil</span>)
</span></span><span><span>	[<span>...</span>]
</span></span><span><span>	}
</span></span><span><span> }
</span></span></code></pre></div>
<p>For the Prolog code to have access to the <code>*hbot.Message</code> provided by Exec(), we need to make it available to the Prolog code. The easiest solution is to add the Hellabot message as Prolog terms that can be accessed by the Prolog code. This simplifies the code substantially, and even if it does not allow the code to access the Hellabot api directly, this is not a drawback, because the trigger is fired for each message and the message does not change during the code execution.</p>
<p>For this we transform the different fields of the <code>*hbot.Message</code> to Prolog terms using a function called MessageToTerms() and store its results in a string to be loaded by the next step.</p>
<div><pre tabindex="0"><code data-lang="Prolog"><span><span><span>message_command</span>(<span>&#34;&lt;IRC_COMMAND&gt;&#34;</span>).
</span></span><span><span><span>message_content</span>(<span>&#34;&lt;MSG_TEXT&gt;&#34;</span>).
</span></span><span><span>[...]
</span></span><span><span><span>message_from</span>(<span>&#34;&lt;USER_FROM&gt;&#34;</span>).
</span></span><span><span><span>message_to</span>(<span>&#34;&lt;USER_TO&gt;&#34;</span>).
</span></span></code></pre></div><h2 id="3-load-the-external-file-with-the-irc-message-terms-generated-in-2">3. Load the external file with the irc message terms generated in #2</h2>
<p>To load the Prolog code, we decide for the Hellabot to load the code from a hardcoded file (bot.pl) stored in the same directory as the bot’s binary using the function readPl. Once read we’ll combine the message terms and the code to feed ichiban’s runtime Exec()</p>
<div><pre tabindex="0"><code data-lang="go"><span><span><span>var</span> PrologTrigger = PrologTrigger{
</span></span><span><span>	Exec: <span>func</span>(irc <span>*</span>hbot.Bot, message <span>*</span>hbot.Message) <span>bool</span> {
</span></span><span><span> 
</span></span><span><span> 		[..]
</span></span><span><span>   
</span></span><span><span>		plCode <span>:=</span> <span>MessageToTerms</span>(m)
</span></span><span><span>		plCode <span>+=</span> <span>readPl</span>(<span>&#34;./bot.pl&#34;</span>)
</span></span><span><span>
</span></span><span><span>		<span>if</span> err <span>:=</span> plRuntime.<span>Exec</span>(plCode); err <span>!=</span> <span>nil</span> {
</span></span><span><span>			irc.Logger.<span>Crit</span>(<span>&#34;Prolog exec&#34;</span>, <span>&#34;err&#34;</span>, err)
</span></span><span><span>			<span>return</span> <span>false</span>
</span></span><span><span>		}
</span></span><span><span>		[..]
</span></span><span><span>	}
</span></span><span><span> }
</span></span></code></pre></div><h2 id="4-execute-the-prolog-clause-to-execute-the-script">4. Execute the Prolog clause to execute the script</h2>
<p>For this sample, we have an extremely simple Prolog code that is our bot.pl file</p>
<div><pre tabindex="0"><code data-lang="Prolog"><span><span><span>bot</span>(<span>Output</span>) :- <span>message_command</span>(<span>&#34;PRIVMSG&#34;</span>),
</span></span><span><span>               <span>message_content</span>(<span>&#34;-Prolog&#34;</span>),
</span></span><span><span>               <span>Output</span> <span>=</span> <span>&#34;This is the Prolog message&#34;</span>.
</span></span></code></pre></div><p>the bot term checks that the message command is “PRIVMSG” and the message content (the text received) is “-Prolog”. If this is correct, Output will be unified to the string “This is the Prolog message”.</p>
<p>To start the code in bot.pl we exect the clause <code>Bot(Message)</code> using Hellabot Query() function.</p>
<div><pre tabindex="0"><code data-lang="go"><span><span><span>var</span> PrologTrigger = PrologTrigger{
</span></span><span><span>	Exec: <span>func</span>(irc <span>*</span>hbot.Bot, message <span>*</span>hbot.Message) <span>bool</span> {
</span></span><span><span> 
</span></span><span><span> 		[..]
</span></span><span><span>   
</span></span><span><span>		sols, err <span>:=</span> plRuntime.<span>Query</span>(<span>&#34;bot(Message).&#34;</span>)
</span></span><span><span>
</span></span><span><span>		<span>if</span> err <span>!=</span> <span>nil</span> {
</span></span><span><span>			irc.Logger.<span>Crit</span>(<span>&#34;Prolog query&#34;</span>, <span>&#34;err&#34;</span>, err)
</span></span><span><span>			<span>return</span> <span>false</span>
</span></span><span><span>		}
</span></span><span><span>	    <span>defer</span> sols.<span>Close</span>()
</span></span><span><span>
</span></span><span><span>		[..]
</span></span><span><span>}
</span></span></code></pre></div><h2 id="5-print-the-clause-output-to-the-irc-client-using-hellabot-api">5. Print the clause output to the irc client (using Hellabot API)</h2>
<p>Once we have queried the Prolog runtime we need to retrieve the message we want to send back to our client using the ichiban API. Because in Prolog we can return multiple solutions, ichiban designers decided to mimic sql go api, forcing us to loop through a set of solutions.</p>
<p>In our code we will have a single solution “This is the Prolog message”, but in case we had multiple ones the <code>for sols.Next() { [...] }</code> loop would ensure we capture all of them and return it to the client via the call <code>irc.Reply()</code>.</p>
<div><pre tabindex="0"><code data-lang="go"><span><span><span>var</span> PrologTrigger = PrologTrigger{
</span></span><span><span>	Exec: <span>func</span>(irc <span>*</span>hbot.Bot, message <span>*</span>hbot.Message) <span>bool</span> {
</span></span><span><span> 
</span></span><span><span> 		[..]
</span></span><span><span>
</span></span><span><span>		<span>for</span> sols.<span>Next</span>() {
</span></span><span><span>
</span></span><span><span>			<span>var</span> returns <span>struct</span> { Message <span>string</span> }
</span></span><span><span>
</span></span><span><span>			<span>if</span> err <span>:=</span> sols.<span>Scan</span>(<span>&amp;</span>returns); err <span>!=</span> <span>nil</span> {
</span></span><span><span>				irc.Logger.<span>Crit</span>(<span>&#34;Prolog scan&#34;</span>, <span>&#34;err&#34;</span>, err)
</span></span><span><span>    			<span>return</span> <span>false</span>
</span></span><span><span>			}
</span></span><span><span>
</span></span><span><span>			irc.<span>Reply</span>(m, returns.Message)
</span></span><span><span>  
</span></span><span><span>		}
</span></span><span><span>
</span></span><span><span>  		[..]
</span></span><span><span>    
</span></span><span><span>		<span>// Additional error checks
</span></span></span><span><span><span></span>	}
</span></span><span><span>}
</span></span></code></pre></div><p>Implementing these five simple steps allow us <a href="https://codeberg.org/rogersm/bottie/src/branch/basic/main.go">to have a some code that covers our expectations.</a></p>

<p>The current solution is an easy way of integrating ichiban Prolog without having to develop code to enable Prolog to call go (see <a href="https://github.com/ichiban/Prolog/blob/main/examples/call_go_from_Prolog/main.go">this code</a>). There are some possibilities worth exploring to improve the code:</p>
<ol>
<li>
<p>One would be to reduce the impact of setting up a new Prolog interpreter for every trigger: we can use a single interpreter for the whole program and serialise the access to it. Alternatively, using a pool of interpreters that are pre-initialised will surely reduce the <code>Prolog.New(nil, nil)</code> call. This will be left for a future post, because we need to describe the impact to the bot semantics.</p>
</li>
<li>
<p>Another option would be to move more code to the Prolog code, simplifying the go code and further reducing the need to recompile the bot when some changes are needed.</p>
</li>
</ol>
<p>Options to move more code into Prolog would allow us to develop something like this:</p>
<div><pre tabindex="0"><code data-lang="Prolog"><span><span>:- <span>set_Prolog_flag</span>(<span>double_quotes</span>, <span>atom</span>).
</span></span><span><span>
</span></span><span><span><span>% message(?Command, ?Content, ?Raw, ?TimeStamp, ?To, ?From)</span>
</span></span><span><span><span>% message retrieves the fields from Hellabot *hbot.Message</span>
</span></span><span><span>
</span></span><span><span>
</span></span><span><span><span>% send_irc_message(+Text)</span>
</span></span><span><span><span>% sends a Text to the irc connection.</span>
</span></span><span><span>
</span></span><span><span><span>bot</span> <span>:-</span> <span>message</span>(<span>&#34;PRIVMSG&#34;</span>, <span>&#34;-Prolog&#34;</span>, <span>_</span>, <span>_</span>, <span>_</span>, <span>_</span>),
</span></span><span><span>       <span>send_irc_message</span>(<span>&#34;This is the Prolog message&#34;</span>).
</span></span></code></pre></div><p>this would require to register a new predicate <code>message/6</code> to access the message data and another predicate <code>send_irc_message/1</code> to send data. This will be also left for a future post.</p>

</div></div>
  </body>
</html>
