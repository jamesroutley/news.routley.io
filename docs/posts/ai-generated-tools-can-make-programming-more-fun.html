<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.geoffreylitt.com/2024/12/22/making-programming-more-fun-with-an-ai-generated-debugger.html">Original</a>
    <h1>AI-generated tools can make programming more fun</h1>
    
    <div id="readability-page-1" class="page"><div><p>I want to tell you about a neat experience I had with AI-assisted programming this week. What‚Äôs unusual here is: <strong>the AI didn‚Äôt write a single line of my code.</strong> Instead, I used AI to build a <em>custom debugger UI</em>‚Ä¶ which made it more fun for me to do the coding myself.</p>

<p>* * *</p>

<p>I was hacking on a Prolog interpreter as a learning project. <a href="https://en.wikipedia.org/wiki/Prolog">Prolog</a> is a logic language where the user defines facts and rules, and then the system helps answer queries. A basic interpreter for this language turns out to be an elegant little program with surprising power‚Äîa perfect project for a fun learning experience.</p>

<p>The trouble is: it‚Äôs also a bit finicky to get the details right. I encountered some bugs in my implementation of a key step called <a href="https://en.wikipedia.org/wiki/Unification_(computer_science)"><em>unification</em></a>‚Äîsolving symbolic equations‚Äîwhich was leading to weird behavior downstream. I tried logging some information at each step of execution, but I was still parsing through screens of text output looking for patterns.</p>

<p>I needed better visibility. So, I asked <a href="https://support.anthropic.com/en/articles/9487310-what-are-artifacts-and-how-do-i-use-them">Claude Artifacts</a> to whip up a custom UI for viewing one of my execution traces. After a few iterations, here‚Äôs where it ended up:</p>

<video autoplay="" loop="" controls="controls" preload="auto" muted="muted" data-video="0" type="video/mp4" src="/images/article_images/debugger/demo.mp4" width="100%"></video>

<p>I could step through an execution and see a clear visualization of my interpreter‚Äôs stack: how it has broken down goals to solve; which rule it‚Äôs currently evaluating; variable assignments active in the current context; when it‚Äôs come across a solution. The timeline shows an overview of the execution, letting me manually jump to any point to inspect the state. I could even leave a note annotating that point of the trace.</p>

<p>Oh yeah, and don‚Äôt forget the most important feature: the retro design üòé.</p>

<p>Using this interactive debug UI gave me far clearer visibility than a terminal of print statements. I caught a couple bugs immediately just by being able to see variable assignments more clearly. A repeating pattern of solutions in the timeline view led me to discover an infinite loop bug.</p>

<p><strong>And, above all: I started having more fun!</strong> When I got stuck on bugs, it felt like I was getting stuck in interesting, essential ways, not on dumb mistakes. I was able to get an intuitive grasp of my interpreter‚Äôs operation, and then hone in on problems. As a bonus, the visual aesthetic made debugging feel more like a puzzle game than a depressing slog.</p>

<p>* * *</p>

<p>Two things that stick out to me about this experience are 1) how fast it was to get started, and 2) how fast it was to iterate.</p>

<p>When I first had the idea, I just copy-pasted my interpreter code and a sample execution trace into Claude, and asked it to build a React web UI with the rough functionality I wanted. I also specified ‚Äúa fun hacker vibe, like the matrix‚Äù, because why not? About a minute later (after a single iteration for a UI bug which Claude fixed on its own), I had a solid first version up and running:</p>

<p><img src="https://www.geoffreylitt.com/images/article_images/debugger/prompt.png?1734903615" alt="My prompt to Claude"/></p>

<p><strong>That fast turnaround is absolutely critical, because it meant I didn‚Äôt need to break focus from the main task at hand.</strong> I was trying to write a Prolog interpreter here, not build a debug UI. Without AI support, I would have just muddled through with my existing tools, lacking the time or focus to build a debug UI. Simon Willison says: <a href="https://simonwillison.net/2023/Mar/27/ai-enhanced-development/">‚ÄúAI-enhanced development makes me more ambitious with my projects‚Äù</a>. In this case: AI-enhanced development made me more ambitious with my <em>dev tools</em>.</p>

<p>By the way: I was confident Claude 3.5-Sonnet would do well at this task, because it‚Äôs great at building straightforward web UIs. That‚Äôs all this debugger is, at the end of the day: a simple view of a JSON blob; an easy task for a competent web developer. In some sense, you can think of this workflow as a technique for turning that narrow, limited programming capability‚Äîrapidly and automatically building straightforward UIs‚Äîinto an accelerant for more advanced kinds of programming.</p>

<p>Whether you‚Äôre an AI-programming skeptic or an enthusiast, the reality is that many programming tasks are beyond the reach of today‚Äôs models. But many decent <em>dev tools</em> are actually quite easy for AI to build, and can help the rest of the programming go smoother. In general, these days any time I‚Äôm spending more than a minute staring at a JSON blob, I consider whether it‚Äôs worth building a custom UI for it.</p>

<p>* * *</p>

<p>As I used the tool in my debugging, I would notice small things I wanted to visualize differently: improving the syntax display for the program, allocating screen real estate better, adding the timeline view to get a sense of the full history.</p>

<p>Each time, I would just switch windows, spend a few seconds asking Claude to make the change, and then switch back to my code editor and resume working. When I came back at my next breaking point, I‚Äôd have a new debugger waiting for me. Usually things would just work the first time. Sometimes a minor bug fix was necessary, but I let Claude handle it every time. I still haven‚Äôt looked at the UI code.</p>

<p>Eventually we landed on a fairly nice design, where each feature had been motivated by an immediate need that I had felt during use:</p>

<p><img src="https://www.geoffreylitt.com/images/article_images/debugger/debugger-annotated.png?1734903615" alt=""/></p>

<p>Claude wasn‚Äôt perfect‚Äîit did get stuck one time when I asked it to add a <a href="https://www.brendangregg.com/flamegraphs.html">flamegraph</a> view of the stack trace changing over time. Perhaps I could have prodded it into building this better, or even resorted to building it myself. But instead I just decided to abandon that idea and carry on. <strong>AI development works well when your requirements are flexible</strong> and you‚Äôre OK changing course to work within the current limits of the model.</p>

<p>Overall, <strong>it felt incredible that it only took seconds to go from noticing something I wanted in my debugger to having it there in the UI.</strong> The AI support let me stay in flow the whole time; I was free to think about interpreter code and not debug tool code. I had a yak-shaving intern at my disposal.</p>

<p>This is the dream of <a href="https://www.geoffreylitt.com/2023/03/25/llm-end-user-programming">malleable software</a>: editing software at the speed of thought. Starting with just the minimal thing we need for our particular use case, adding things immediately as we come across new requirements. Ending up with a tool that‚Äôs molded to our needs like a leather shoe, not some complicated generic thing designed for a million users.</p>



<ul>
<li>For more zoomed-out thoughts on the possibilities of custom AI-generated tools, check out <a href="https://www.geoffreylitt.com/2023/03/25/llm-end-user-programming">Malleable software in the age of LLMs</a></li>
<li>I‚Äôve written before about using AI to develop one-off custom personal tools, like <a href="https://www.geoffreylitt.com/2023/07/25/building-personal-tools-on-the-fly-with-llms">a Japanese text message translation app with a formality slider</a>.</li>
<li>A few months ago, a collaborator and I had a similar experience building <a href="https://x.com/geoffreylitt/status/1821666220644683950">a custom visualization tool for bounding boxes on PDFs</a>.</li>
<li>The idea of custom tools for debugging programming systems has been explored in depth by many live programming tools; e.g. check out <a href="https://gtoolkit.com/">Glamorous Toolkit</a> and <a href="https://clerk.vision/">Clerk</a>.</li>
</ul>
</div></div>
  </body>
</html>
