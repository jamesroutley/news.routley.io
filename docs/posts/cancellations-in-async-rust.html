<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://sunshowers.io/posts/cancelling-async-rust/">Original</a>
    <h1>Cancellations in async Rust</h1>
    
    <div id="readability-page-1" class="page"><div><div><div><p><em>This is an edited, written version of my RustConf 2025 talk about cancellations in async Rust. Like <a href="https://sunshowers.io/posts/beyond-ctrl-c-signals/">the written version of my RustConf 2023 talk</a>, I’ve tried to retain the feel of a talk while making it readable as a standalone blog entry. Some links:</em></p><ul><li><em><a href="https://www.youtube.com/watch?v=zrv5Cy1R7r4">Video of the talk</a> on YouTube.</em></li><li><em><a href="https://docs.google.com/presentation/u/1/d/e/2PACX-1vTMc4EdHRf6ulz-xaAhZFGZwxJ7jPQgYWczT6pEIvwfXILV4ZEgMdLuoRh70bgh9SP7mxblEnyXuZD0/pub?start=false&amp;loop=false&amp;delayms=60000">Slides</a> on Google Slides.</em></li><li><em><a href="https://github.com/sunshowers/cancelling-async-rust">Repository with links and notes</a> on GitHub.</em></li><li><em><a href="https://lwn.net/Articles/1036924/">Coverage on Linux Weekly News</a>.</em></li></ul><p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share; fullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/zrv5Cy1R7r4?autoplay=0&amp;controls=1&amp;end=0&amp;loop=0&amp;mute=0&amp;start=0" title="YouTube video"></iframe></p><h2 id="introduction">Introduction<a href="#introduction" arialabel="Anchor">#</a></h2><p>Let’s start with a simple example – you decide to read from a channel in a loop and gather a bunch of messages:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>loop</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>match</span><span> </span><span>rx</span><span>.</span><span>recv</span><span>().</span><span>await</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>Ok</span><span>(</span><span>msg</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>process</span><span>(</span><span>msg</span><span>),</span><span>
</span></span></span><span><span><span>        </span><span>Err</span><span>(</span><span>_</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>return</span><span>,</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>All good, nothing wrong with this, but you realize sometimes the channel is empty for long periods of time, so you add a timeout and print a message:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>loop</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>match</span><span> </span><span>timeout</span><span>(</span><span>Duration</span>::<span>from_secs</span><span>(</span><span>5</span><span>),</span><span> </span><span>rx</span><span>.</span><span>recv</span><span>()).</span><span>await</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>Ok</span><span>(</span><span>Ok</span><span>(</span><span>msg</span><span>))</span><span> </span><span>=&gt;</span><span> </span><span>process</span><span>(</span><span>msg</span><span>),</span><span>
</span></span></span><span><span><span>        </span><span>Ok</span><span>(</span><span>Err</span><span>(</span><span>_</span><span>))</span><span> </span><span>=&gt;</span><span> </span><span>return</span><span>,</span><span>
</span></span></span><span><span><span>        </span><span>Err</span><span>(</span><span>_</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>println!</span><span>(</span><span>&#34;no messages for 5 seconds&#34;</span><span>),</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>There’s nothing wrong with this code—it behaves as expected.</p><p>Now you realize you need to write a bunch of messages out to a channel in a loop:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>loop</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>msg</span><span> </span><span>=</span><span> </span><span>next_message</span><span>();</span><span>
</span></span></span><span><span><span>    </span><span>match</span><span> </span><span>tx</span><span>.</span><span>send</span><span>(</span><span>msg</span><span>).</span><span>await</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>Ok</span><span>(</span><span>_</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>println!</span><span>(</span><span>&#34;sent successfully&#34;</span><span>),</span><span>
</span></span></span><span><span><span>        </span><span>Err</span><span>(</span><span>_</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>return</span><span>,</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>But sometimes the channel gets too full and blocks, so you add a timeout and print a message:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>loop</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>msg</span><span> </span><span>=</span><span> </span><span>next_message</span><span>();</span><span>
</span></span></span><span><span><span>    </span><span>match</span><span> </span><span>timeout</span><span>(</span><span>Duration</span>::<span>from_secs</span><span>(</span><span>5</span><span>),</span><span> </span><span>tx</span><span>.</span><span>send</span><span>(</span><span>msg</span><span>)).</span><span>await</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>Ok</span><span>(</span><span>Ok</span><span>(</span><span>_</span><span>))</span><span> </span><span>=&gt;</span><span> </span><span>println!</span><span>(</span><span>&#34;sent successfully&#34;</span><span>),</span><span>
</span></span></span><span><span><span>        </span><span>Ok</span><span>(</span><span>Err</span><span>(</span><span>_</span><span>))</span><span> </span><span>=&gt;</span><span> </span><span>return</span><span>,</span><span>
</span></span></span><span><span><span>        </span><span>Err</span><span>(</span><span>_</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>println!</span><span>(</span><span>&#34;no space for 5 seconds&#34;</span><span>),</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>It turns out that <em>this</em> code is often incorrect, because not all messages make their way to the channel.</p><p>Hi, I’m Rain, and this post is about cancelling async Rust. This post is split into three parts:</p><ol><li><a href="https://sunshowers.io/posts/cancelling-async-rust/#1-what-is-cancellation"><em>What is cancellation?</em></a> It’s an extremely powerful part of async Rust but also one that is very hard to reason thoroughly about.</li><li><a href="https://sunshowers.io/posts/cancelling-async-rust/#2-analyzing-cancellations"><em>Analyzing cancellations:</em></a> Going deep into their mechanics and providing some helpful ways to think about them.</li><li><a href="https://sunshowers.io/posts/cancelling-async-rust/#3-what-can-be-done"><em>What can be done?</em></a> Solutions, including practical guidance, and real bugs we’ve found and fixed in production codebases.</li></ol><p>Before we begin, I want to lay my cards on the table – I really love async Rust!</p><figure><img src="https://sunshowers.io/images/beyond-ctrl-c.jpg" alt="Me speaking at RustConf 2023. Beyond Ctrl-C: The dark corners of Unix signal handling."/><figcaption>Me speaking at RustConf 2023.</figcaption></figure><ul><li><p>I gave <a href="https://sunshowers.io/posts/beyond-ctrl-c-signals/">a talk</a> at RustConf a couple years ago talking about how async Rust is a great fit for signal handling in complex applications.</p></li><li><p>I’m also the author of <a href="https://nexte.st/">cargo-nextest</a>, a next-generation test runner for Rust, where async Rust is the best way I know of to express some really complex algorithms that I wouldn’t know how to express otherwise. I wrote <a href="https://sunshowers.io/posts/nextest-and-tokio/">a blog post</a> about this a few years ago.</p></li></ul><p>Now, I work at <a href="https://oxide.computer/">Oxide Computer Company</a>, where we make <em>cloud-in-a-box computers</em>. We make vertically integrated systems where you provide power and networking on one end, and the software you want to run on the other end, and we take care of everything in between.</p><p>Of course, we use Rust everywhere, and in particular we use async Rust extensively for our higher-level software, such as <a href="https://github.com/oxidecomputer/crucible">storage</a>, <a href="https://github.com/oxidecomputer/maghemite">networking</a> and the <a href="https://github.com/oxidecomputer/omicron/">customer-facing management API</a>. But along the way we’ve encountered a number of issues around async cancellation, and a lot of this post is about what we learned along the way.</p><h2 id="1-what-is-cancellation">1. What is cancellation?<a href="#1-what-is-cancellation" arialabel="Anchor">#</a></h2><p>What does cancellation mean? Logically, a cancellation is exactly what it sounds like: you start some work, and then change your mind and decide to stop doing that work.</p><p>As you might imagine this is a useful thing to do:</p><ul><li>You may have started a large download or a long network request</li><li>Maybe you’ve started reading a file, similar to the <code>head</code> command.</li></ul><p>But then you change your mind: you want to cancel it rather than continue it to completion.</p><h3 id="cancellations-in-synchronous-rust">Cancellations in synchronous Rust<a href="#cancellations-in-synchronous-rust" arialabel="Anchor">#</a></h3><p>Before we talk about async Rust, it’s worth thinking about how you’d do cancellations in synchronous Rust.</p><p>One option is to have some kind of <em>flag</em> you periodically check, maybe stored in an atomic:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>while</span><span> </span><span>!</span><span>should_cancel</span><span>.</span><span>load</span><span>(</span><span>Ordering</span>::<span>Relaxed</span><span>)</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>expensive_operation</span><span>();</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><ul><li>The code that wishes to perform the cancellation can set that flag.</li><li>Then, the code which checks that flag can exit early.</li></ul><p>This approach is fine for smaller bits of code but doesn’t really scale well to large chunks of code since you’d have to sprinkle these checks everywhere.</p><p>A related option, if you’re working with a framework as part of your work, is to <em>panic with a special payload</em> of some kind.</p><ul><li>If that feels strange to you, you’re not alone! But the <a href="https://github.com/salsa-rs/salsa">Salsa</a> framework for incremental computation, used by—among other things—<a href="https://github.com/rust-lang/rust-analyzer">rust-analyzer</a>, uses this approach.</li><li>Something I learned recently was that this only works on build targets which have a notion of <a href="https://doc.rust-lang.org/std/panic/fn.catch_unwind.html">panic unwinding</a>, or being able to bubble up the panic. Not all platforms support this, and in particular, <a href="https://webassembly.org/">Wasm</a> doesn’t. This means that Salsa cancellations don’t work if you build rust-analyzer for Wasm.</li></ul><p>A third option is to <em>kill the whole process</em>. This is a <em>very heavyweight</em> approach, but an effective one in case you spawn processes to do your work.</p><p>Rather than kill the whole process, can you kill a single thread?</p><ul><li>While <a href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-terminatethread">some OSes have APIs</a> to perform this action, they tend to warn very strongly against it. That’s because in general, most code is <a href="https://sunshowers.io/posts/nextest-process-per-test/#appendix">just not ready</a> for a thread disappearing from underneath.</li><li>In particular, thread killing is not permitted by safe Rust, since it can cause serious corruption. For example, Rust mutexes would likely stay locked forever.</li></ul><p>All of these options are suboptimal or of limited use in some way. In general, the way I think about it is that there isn’t a <em>universal protocol</em> for cancellation in synchronous Rust.</p><p>In contrast, there <em>is</em> such a protocol in async Rust, and in fact cancellations are extraordinarily easy to perform in async Rust.</p><p>Why is that so? To understand that, let’s look at what a future is.</p><h3 id="what-is-a-future">What is a future?<a href="#what-is-a-future" arialabel="Anchor">#</a></h3><p>Here’s a simple example of a future:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>// This creates a state machine.
</span></span></span><span><span><span></span><span>let</span><span> </span><span>future</span><span> </span><span>=</span><span> </span><span>async</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>data</span><span> </span><span>=</span><span> </span><span>request</span><span>().</span><span>await</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>process</span><span>(</span><span>data</span><span>).</span><span>await</span><span>
</span></span></span><span><span><span></span><span>};</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>// Nothing executes yet. `future` is just a struct in memory.
</span></span></span></code></pre></div><p>In this future, you first perform a network request which returns some data, and then you process it.</p><p>The Rust compiler looks at this future and generates a state machine, which is just a struct or enum in memory:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>// The compiler generates something like:
</span></span></span><span><span><span></span><span>enum</span> <span>MyFuture</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>Start</span><span>,</span><span>
</span></span></span><span><span><span>    </span><span>WaitingForNetwork</span><span>(</span><span>NetworkFuture</span><span>),</span><span>
</span></span></span><span><span><span>    </span><span>WaitingForProcess</span><span>(</span><span>ProcessFuture</span><span>,</span><span> </span><span>Data</span><span>),</span><span>
</span></span></span><span><span><span>    </span><span>Done</span><span>(</span><span>Result</span><span>),</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>// It&#39;s just data, no running code!
</span></span></span></code></pre></div><p>If you’ve written async Rust before the <code>async</code> and <code>await</code> keywords, you’ve probably written code like it by hand. It’s basically just an enum describing all the possible states the future can be in.</p><p>The compiler also generates an implementation of <a href="https://doc.rust-lang.org/std/future/trait.Future.html">the <code>Future</code> trait</a> for this future:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>impl</span><span> </span><span>Future</span><span> </span><span>for</span><span> </span><span>MyFuture</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>fn</span> <span>poll</span><span>(</span><span>/* ... */</span><span>)</span><span> </span>-&gt; <span>Poll</span><span>&lt;</span><span>Self</span>::<span>Output</span><span>&gt;</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>match</span><span> </span><span>self</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>            </span><span>Start</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span> </span><span>/* ... */</span><span> </span><span>}</span><span>
</span></span></span><span><span><span>            </span><span>WaitingForNetwork</span><span>(</span><span>fut</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span> </span><span>/* ... */</span><span> </span><span>}</span><span>
</span></span></span><span><span><span>            </span><span>// etc
</span></span></span><span><span><span></span><span>        </span><span>}</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>and when you call <code>.await</code> on the future, it gets translated down to this underlying <code>poll</code> function. It is only when <code>await</code> or this <code>poll</code> function is called that something actually happens.</p><p>Note that this is diametrically opposed to how async works in other languages like Go, JavaScript, or C#. In those languages, when you create a future to await on, it starts doing its thing, immediately, in the background:</p><div><pre tabindex="0"><code data-lang="js"><span><span><span>// JavaScript: starts running immediately
</span></span></span><span><span><span></span><span>const</span> <span>promise</span> <span>=</span> <span>fetch</span><span>(</span><span>&#39;/api/data&#39;</span><span>);</span>
</span></span></code></pre></div><p>That’s regardless of whether you await it or not.</p><p>In Rust, this <code>get</code> call does nothing until you actually call <code>.await</code> on it:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>// Rust: just data, does nothing!
</span></span></span><span><span><span></span><span>let</span><span> </span><span>future</span><span> </span><span>=</span><span> </span><span>reqwest</span>::<span>get</span><span>(</span><span>&#34;/api/data&#34;</span><span>);</span><span>
</span></span></span></code></pre></div><p>I know I sound a bit like a broken record here, but if you can take away one thing from this post, it would be that futures are passive, and completely inert until awaited or polled.</p><h3 id="the-universal-protocol">The universal protocol<a href="#the-universal-protocol" arialabel="Anchor">#</a></h3><p>So what does the universal protocol to cancel futures look like? It is simply to <em>drop</em> the future, or to not await it, or poll it any more. Since a future is just a state machine, you can throw it away at any time the poll function isn’t actively being called.</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>let</span><span> </span><span>future</span><span> </span><span>=</span><span> </span><span>some_async_work</span><span>();</span><span>
</span></span></span><span><span><span></span><span>drop</span><span>(</span><span>future</span><span>);</span><span> </span><span>// cancelled
</span></span></span></code></pre></div><p>The upshot of all this is that any Rust future can be cancelled at any await point.</p><p>Given how hard cancellation tends to be in synchronous environments, the ability to easily cancel futures in async Rust is extraordinarily powerful—in many ways its greatest strength!</p><p>But there is a flip side, which is that cancelling futures is far, far too easy. This is for two reasons.</p><ol><li><p>First, it’s just way too easy to quietly drop a future. As we’re going to see, there are all kinds of code patterns that lead to silently dropping futures.</p></li><li><p>Now this wouldn’t be so bad, if not for the second reason: that cancellation of parent futures propagates down to child futures.</p><p>Because of Rust’s <a href="https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html">single ownership model</a>, child futures are owned by parent ones. If a parent future is dropped or cancelled, the same happens to the child.</p><p>To figure out whether a child future’s cancellation can cause issues, you have to look at its parent, and grandparent, and so on. Reasoning about cancellation becomes a very complicated <em>non-local operation</em>.</p></li></ol><h2 id="2-analyzing-cancellations">2. Analyzing cancellations<a href="#2-analyzing-cancellations" arialabel="Anchor">#</a></h2><p>I’m going to cover some examples in a bit, but before we do that I want to talk about a couple terms, some of which you might have seen references to already.</p><h3 id="cancel-safety-and-cancel-correctness">Cancel safety and cancel correctness<a href="#cancel-safety-and-cancel-correctness" arialabel="Anchor">#</a></h3><p>The first term is <strong>cancel safety</strong>. You might have seen mentions of this in the Tokio documentation. Cancel safety, as generally defined, means the property of a future that can be cancelled (i.e. dropped) without any side effects.</p><p>For example, a <a href="https://docs.rs/tokio/latest/tokio/time/fn.sleep.html">Tokio sleep future</a> is cancel safe: you can just stop waiting on the sleep and it’s completely fine.</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>let</span><span> </span><span>future</span><span> </span><span>=</span><span> </span><span>tokio</span>::<span>time</span>::<span>sleep</span><span>();</span><span>
</span></span></span><span><span><span></span><span>drop</span><span>(</span><span>future</span><span>);</span><span> </span><span>// this has no side effects
</span></span></span></code></pre></div><p>An example of a future that is not cancel safe is <a href="https://docs.rs/tokio/latest/tokio/sync/mpsc/struct.Sender.html#method.send">Tokio’s MPSC send</a>, which sends a message over a channel:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>let</span><span> </span><span>message</span><span> </span><span>=</span><span> </span><span>/* ... */</span><span>;</span><span>
</span></span></span><span><span><span></span><span>let</span><span> </span><span>future</span><span> </span><span>=</span><span> </span><span>sender</span><span>.</span><span>send</span><span>(</span><span>message</span><span>);</span><span>
</span></span></span><span><span><span></span><span>drop</span><span>(</span><span>future</span><span>);</span><span> </span><span>// message is lost!
</span></span></span></code></pre></div><p>If this future is dropped, the message is lost forever.</p><p>The important thing is that cancel safety is a <em>local property</em> of an <em>individual future</em>.</p><p>But cancel safety is not all that one needs to care about. What actually matters is the context the cancellation happens in, or in other words whether the cancellation actually causes some kind of larger property in the system to be violated.</p><ul><li>For example, if you drop a future which sends a message, but for whatever reason you don’t care about the message any more, it’s not really a bug!</li></ul><p>To capture this I tend to use a different term called <strong>cancel correctness</strong>, which I define as a <em>global property</em> of <em>system correctness</em> in the face of cancellations. (This isn’t a standard term, but it’s a framing I’ve found really helpful in understanding cancellations.)</p><p>When is cancel correctness violated? It requires three things:</p><ol><li><p><em>The system has a cancel-unsafe future somewhere within it.</em> As we’ll see, many APIs that are cancel-unsafe can be reworked to be cancel-safe. If there aren’t any cancel-unsafe futures in the system, then the system is cancel correct.</p></li><li><p><em>A cancel-unsafe future is actually cancelled.</em> This may sound a bit trivial, but if cancel-unsafe futures are always run to completion, then the system can’t have cancel correctness bugs.</p></li><li><p><em>Cancelling the future violates some property of a system.</em> This could be data loss as with <code>Sender::send</code>, some kind of invariant violation, or some kind of cleanup that must be performed but isn’t.</p></li></ol><p>So a lot of making Rust async robust is about trying to tackle one of these three things.</p><p>I want to zoom in for a second on invariant violations and talk about an example of a Tokio API that is very prone to cancel correctness issues: <a href="https://docs.rs/tokio/latest/tokio/sync/struct.Mutex.html">Tokio mutexes</a>.</p><h3 id="the-pain-of-tokio-mutexes">The pain of Tokio mutexes<a href="#the-pain-of-tokio-mutexes" arialabel="Anchor">#</a></h3><p>The way Tokio mutexes work is: you create a mutex, you lock it which gives you mutable access to the data underneath, and then you unlock it by releasing the mutex.</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>let</span><span> </span><span>guard</span><span> </span><span>=</span><span> </span><span>mutex</span><span>.</span><span>lock</span><span>().</span><span>await</span><span>;</span><span>
</span></span></span><span><span><span></span><span>// Access guard.data, protected by the mutex...
</span></span></span><span><span><span></span><span>drop</span><span>(</span><span>guard</span><span>);</span><span>
</span></span></span></code></pre></div><p>If you look at the <a href="https://docs.rs/tokio/latest/tokio/sync/struct.Mutex.html#method.lock"><code>lock</code> function’s documentation</a>, in the “cancel safety” section it says:</p><blockquote><p>This method uses a queue to fairly distribute locks in the order they were requested. Cancelling a call to lock makes you lose your place in the queue.</p></blockquote><p>Okay, so not totally cancel safe, but the only kind of unsafety is fairness, which doesn’t sound too bad.</p><p>But the problems lie in what you actually do with the mutex. In practice, most uses of mutexes are in order to <em>temporarily violate invariants</em> that are otherwise upheld when a lock isn’t held.</p><p>I’ll use a real world example of a cancel correctness bug that we found at my job at Oxide: we had code to manage a bunch of data sent over by our computers, which we call sleds. The shared state was guarded by a mutex, and a typical operation was:</p><ol><li>Obtain a lock on the mutex.</li><li>Obtain the sled-specific data by value, moving it to an invalid <code>None</code> state.</li><li>Perform an action.</li><li>Set the sled-specific data back to the next valid state.</li></ol><p>Here’s a rough sketch of what that looks like:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>let</span><span> </span><span>guard</span><span> </span><span>=</span><span> </span><span>mutex</span><span>.</span><span>lock</span><span>().</span><span>await</span><span>;</span><span>
</span></span></span><span><span><span></span><span>// guard.data is Option&lt;T&gt;: Some to begin with
</span></span></span><span><span><span></span><span>let</span><span> </span><span>data</span><span> </span><span>=</span><span> </span><span>guard</span><span>.</span><span>data</span><span>.</span><span>take</span><span>();</span><span> </span><span>// guard.data is now None
</span></span></span><span><span><span></span><span>
</span></span></span><span><span><span></span><span>let</span><span> </span><span>new_data</span><span> </span><span>=</span><span> </span><span>process_data</span><span>(</span><span>data</span><span>);</span><span>
</span></span></span><span><span><span></span><span>guard</span><span>.</span><span>data</span><span> </span><span>=</span><span> </span><span>Some</span><span>(</span><span>new_data</span><span>);</span><span> </span><span>// guard.data is Some again
</span></span></span></code></pre></div><p>This is all well and good, but the problem is that the action being performed actually had an await point within it:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>let</span><span> </span><span>guard</span><span> </span><span>=</span><span> </span><span>mutex</span><span>.</span><span>lock</span><span>().</span><span>await</span><span>;</span><span>
</span></span></span><span><span><span></span><span>// guard.data is Option&lt;T&gt;: Some to begin with
</span></span></span><span><span><span></span><span>let</span><span> </span><span>data</span><span> </span><span>=</span><span> </span><span>guard</span><span>.</span><span>data</span><span>.</span><span>take</span><span>();</span><span> </span><span>// guard.data is now None
</span></span></span><span><span><span></span><span>
</span></span></span><span><span><span></span><span>// DANGER: cancellation here leaves data in None state!
</span></span></span><span><span><span></span><span>let</span><span> </span><span>new_data</span><span> </span><span>=</span><span> </span><span>process_data</span><span>(</span><span>data</span><span>).</span><span>await</span><span>;</span><span>
</span></span></span><span><span><span></span><span>guard</span><span>.</span><span>data</span><span> </span><span>=</span><span> </span><span>Some</span><span>(</span><span>new_data</span><span>);</span><span> </span><span>// guard.data is Some again
</span></span></span></code></pre></div><p>If the code that operated on the mutex got cancelled at that await point, then the data would be stuck in the invalid <code>None</code> state. Not great!</p><p>And keep in mind the non-local reasoning aspect: when doing this analysis, you need to look at the whole chain of callers.</p><h3 id="cancellation-patterns">Cancellation patterns<a href="#cancellation-patterns" arialabel="Anchor">#</a></h3><p>Now that we’ve talked about some of the bad things that can happen during cancellations, it’s worth asking what kinds of code patterns lead to futures being cancelled.</p><p>The most straightforward example, and maybe a bit of a silly one, is that you create a future but simply forget to call <code>.await</code> on it.</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>some_async_work</span><span>();</span><span> </span><span>// missing .await
</span></span></span></code></pre></div><p>Now Rust actually warns you if you don’t call <code>.await</code> on the future:</p><div><pre tabindex="0"><code data-lang="text"><span><span>warning: unused implementer of `Future` that must be used
</span></span><span><span>   |
</span></span><span><span>11 |     some_async_work();
</span></span><span><span>   |     ^^^^^^^^^^^^^^^^^
</span></span><span><span>   |
</span></span><span><span>   = note: futures do nothing unless you `.await` or poll them
</span></span></code></pre></div><p>But a code pattern I’ve sometimes made mistakes with is that the future returns a <code>Result</code>, and you want to ignore the result so you assign it to an underscore like so:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>let</span><span> </span><span>_</span><span> </span><span>=</span><span> </span><span>some_async_work</span><span>();</span><span> </span><span>// future returns Result
</span></span></span></code></pre></div><p>If I forget to call <code>.await</code> on the future, Rust doesn’t warn me about it at all, and then I’m left scratching my head about why this code didn’t run. I know this sounds really silly and basic, but I’ve made this mistake a bunch of times.</p><p><em>(After my talk, it was pointed out to me that Clippy 1.67 and above have a <a href="https://rust-lang.github.io/rust-clippy/master/index.html#let_underscore_future"><code>let_underscore_future</code></a> warn-by-default lint for this. Hooray!)</em></p><p>Another example of futures being cancelled is <code>try</code> operations, such as Tokio’s <a href="https://docs.rs/tokio/latest/tokio/macro.try_join.html"><code>try_join</code> macro</a>. For example:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>async</span><span> </span><span>fn</span> <span>do_stuff_async</span><span>()</span><span> </span>-&gt; <span>Result</span><span>&lt;</span><span>(),</span><span> </span><span>&amp;</span><span>&#39;static</span><span> </span><span>str</span><span>&gt;</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>// async work
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>async</span><span> </span><span>fn</span> <span>more_async_work</span><span>()</span><span> </span>-&gt; <span>Result</span><span>&lt;</span><span>(),</span><span> </span><span>&amp;</span><span>&#39;static</span><span> </span><span>str</span><span>&gt;</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>// more here
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>let</span><span> </span><span>res</span><span> </span><span>=</span><span> </span><span>tokio</span>::<span>try_join!</span><span>(</span><span>
</span></span></span><span><span><span>    </span><span>do_stuff_async</span><span>(),</span><span>
</span></span></span><span><span><span>    </span><span>more_async_work</span><span>(),</span><span>
</span></span></span><span><span><span></span><span>);</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>// ...
</span></span></span></code></pre></div><p>If you call <code>try_join</code> with a bunch of futures, and all of them succeed, it’s all good. But if one of them fails, the rest simply get cancelled.</p><p>In fact, at Oxide we had a pretty bad bug around this: we had code to stop a bunch of services, all expressed as futures. We used <code>try_join</code>:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>try_join!</span><span>(</span><span>
</span></span></span><span><span><span>    </span><span>stop_service_a</span><span>(),</span><span>
</span></span></span><span><span><span>    </span><span>stop_service_b</span><span>(),</span><span>
</span></span></span><span><span><span>    </span><span>stop_service_c</span><span>(),</span><span>
</span></span></span><span><span><span></span><span>)</span><span>?</span><span>;</span><span>
</span></span></span></code></pre></div><p>If one of these operations failed for whatever reason, we would stop running the code to wait for the other services to exit. Oops!</p><p>But perhaps the most well-known source of cancellations is Tokio’s <a href="https://docs.rs/tokio/latest/tokio/macro.select.html"><code>select</code> macro</a>. Select is this incredibly beautiful operation. It is called with a set of futures, and it drives all of them forward concurrently:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>tokio</span>::<span>select!</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>result1</span><span> </span><span>=</span><span> </span><span>future1</span><span> </span><span>=&gt;</span><span> </span><span>handle_result1</span><span>(</span><span>result1</span><span>),</span><span>
</span></span></span><span><span><span>    </span><span>result2</span><span> </span><span>=</span><span> </span><span>future2</span><span> </span><span>=&gt;</span><span> </span><span>handle_result2</span><span>(</span><span>result2</span><span>),</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>Each future has a code block associated with it (above, <code>handle_result1</code> and <code>handle_result2</code>). If one of the futures completes, the corresponding code block is called. But also, all of the other futures are always cancelled!</p><p>For a variety of reasons, select statements in general, and <em>select loops</em> in particular, are particularly prone to cancel correctness issues. So a lot of the documentation about cancel safety talks about select loops. But I want to emphasize here that select is not the <em>only</em> source of cancellations, just a particularly <em>notable</em> one.</p><h2 id="3-what-can-be-done">3. What can be done?<a href="#3-what-can-be-done" arialabel="Anchor">#</a></h2><p>So, now that we’ve looked at all of these issues with cancellations, what can be done about it?</p><p>First, I want to break the bad news to you – there is <em>no general, fully reliable solution for this</em> in Rust today. But in our experience there are a few patterns that have been successful at reducing the likelihood of cancellation bugs.</p><p>Going back to our definition of cancel correctness, there are three prongs all of which come together to produce a bug:</p><ul><li>A cancel-unsafe future exists</li><li>This cancel-unsafe future is cancelled</li><li>The cancellation violates a system property</li></ul><p>Most solutions we’ve come up with try and tackle one of these prongs.</p><h3 id="making-futures-cancel-safe">Making futures cancel-safe<a href="#making-futures-cancel-safe" arialabel="Anchor">#</a></h3><p>Let’s look at the first prong: the system has a cancel-unsafe future somewhere in it. Can we use code patterns to make futures be cancel-safe? It turns out we can! I’ll give you two examples here.</p><p>The first is MPSC sends. Let’s come back to the example from earlier where we would lose messages entirely:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>loop</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>msg</span><span> </span><span>=</span><span> </span><span>next_message</span><span>();</span><span>
</span></span></span><span><span><span>    </span><span>match</span><span> </span><span>timeout</span><span>(</span><span>Duration</span>::<span>from_secs</span><span>(</span><span>5</span><span>),</span><span> </span><span>tx</span><span>.</span><span>send</span><span>(</span><span>msg</span><span>)).</span><span>await</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>Ok</span><span>(</span><span>Ok</span><span>(</span><span>_</span><span>))</span><span> </span><span>=&gt;</span><span> </span><span>println!</span><span>(</span><span>&#34;sent successfully&#34;</span><span>),</span><span>
</span></span></span><span><span><span>        </span><span>Ok</span><span>(</span><span>Err</span><span>(</span><span>_</span><span>))</span><span> </span><span>=&gt;</span><span> </span><span>return</span><span>,</span><span>
</span></span></span><span><span><span>        </span><span>Err</span><span>(</span><span>_</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>println!</span><span>(</span><span>&#34;no space for 5 seconds&#34;</span><span>),</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>Can we find a way to make this cancel safe?</p><p>In this case, yes, and we do so by breaking up the operation into two parts:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>loop</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>msg</span><span> </span><span>=</span><span> </span><span>next_message</span><span>();</span><span>
</span></span></span><span><span><span>    </span><span>loop</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>match</span><span> </span><span>timeout</span><span>(</span><span>Duration</span>::<span>from_secs</span><span>(</span><span>5</span><span>),</span><span> </span><span>tx</span><span>.</span><span>reserve</span><span>()).</span><span>await</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>            </span><span>Ok</span><span>(</span><span>Ok</span><span>(</span><span>permit</span><span>))</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span> </span><span>permit</span><span>.</span><span>send</span><span>(</span><span>msg</span><span>);</span><span> </span><span>break</span><span>;</span><span> </span><span>}</span><span>
</span></span></span><span><span><span>            </span><span>Ok</span><span>(</span><span>Err</span><span>(</span><span>_</span><span>))</span><span> </span><span>=&gt;</span><span> </span><span>return</span><span>,</span><span>
</span></span></span><span><span><span>            </span><span>Err</span><span>(</span><span>_</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>println!</span><span>(</span><span>&#34;no space for 5 seconds&#34;</span><span>),</span><span>
</span></span></span><span><span><span>        </span><span>}</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><ul><li>The first component is the operation to <a href="https://docs.rs/tokio/latest/tokio/sync/mpsc/struct.Sender.html#method.reserve">reserve a permit</a> or slot in the channel. This is an initial async operation that’s cancel-safe.</li><li>The second is to actually <a href="https://docs.rs/tokio/latest/tokio/sync/mpsc/struct.Permit.html#method.send">send the message</a>, which is an operation that becomes infallible.</li></ul><p>(I want to put an asterisk here that reserve is not entirely cancel-safe, since Tokio’s MPSC follows a first-in-first-out pattern and dropping the future means losing your place in line. Keep this in mind for now.)</p><hr/><p>The second is with <a href="https://docs.rs/tokio/latest/tokio/io/trait.AsyncWrite.html">Tokio’s <code>AsyncWrite</code></a>.</p><p>If you’ve written synchronous Rust you’re probably familiar with <a href="https://doc.rust-lang.org/std/io/trait.Write.html#method.write_all">the <code>write_all</code> method</a>, which writes an entire buffer out:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>use</span><span> </span><span>std</span>::<span>io</span>::<span>Write</span><span>;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>let</span><span> </span><span>buffer</span>: <span>&amp;</span><span>[</span><span>u8</span><span>]</span><span> </span><span>=</span><span> </span><span>/* ... */</span><span>;</span><span>
</span></span></span><span><span><span></span><span>writer</span><span>.</span><span>write_all</span><span>(</span><span>buffer</span><span>)</span><span>?</span><span>;</span><span>
</span></span></span></code></pre></div><p>In synchronous Rust, this is a great API. But within async Rust, the <code>write_all</code> pattern is absolutely not cancel safe! If the future is dropped before completion, you have no idea how much of this buffer was written out.</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>use</span><span> </span><span>tokio</span>::<span>io</span>::<span>AsyncWriteExt</span><span>;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>let</span><span> </span><span>buffer</span>: <span>&amp;</span><span>[</span><span>u8</span><span>]</span><span> </span><span>=</span><span> </span><span>/* ... */</span><span>;</span><span>
</span></span></span><span><span><span></span><span>writer</span><span>.</span><span>write_all</span><span>(</span><span>buffer</span><span>).</span><span>await</span><span>?</span><span>;</span><span> </span><span>// Not cancel-safe!
</span></span></span></code></pre></div><p>But there’s an alternative API that is cancel-safe, called <a href="https://docs.rs/tokio/latest/tokio/io/trait.AsyncWriteExt.html#method.write_all_buf"><code>write_all_buf</code></a>. This API is carefully designed to enable the reporting of partial progress, and it doesn’t just accept a <em>buffer</em>, but rather something that looks like a cursor on top of it:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>use</span><span> </span><span>tokio</span>::<span>io</span>::<span>AsyncWriteExt</span><span>;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>let</span><span> </span><span>mut</span><span> </span><span>buffer</span>: <span>io</span>::<span>Cursor</span><span>&lt;&amp;</span><span>[</span><span>u8</span><span>]</span><span>&gt;</span><span> </span><span>=</span><span> </span><span>/* ... */</span><span>;</span><span>
</span></span></span><span><span><span></span><span>writer</span><span>.</span><span>write_all_buf</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>buffer</span><span>).</span><span>await</span><span>?</span><span>;</span><span>
</span></span></span></code></pre></div><p>When part of the buffer is written out, the cursor is advanced by that number of bytes. So if you call <code>write_all_buf</code> in a loop, you’ll be resuming from this partial progress, which works great.</p><h3 id="not-cancelling-futures">Not cancelling futures<a href="#not-cancelling-futures" arialabel="Anchor">#</a></h3><p>Going back to the three prongs: the second prong is about actually cancelling futures. What code patterns can be used to not cancel futures? Here are a couple of examples.</p><p>The first one is, in a place like a select loop, resume futures rather than cancelling them each time. You’d typically achieve this by <a href="https://doc.rust-lang.org/std/pin/">pinning a future</a>, and then polling a mutable reference to that future. For example:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>let</span><span> </span><span>mut</span><span> </span><span>future</span><span> </span><span>=</span><span> </span><span>Box</span>::<span>pin</span><span>(</span><span>channel</span><span>.</span><span>reserve</span><span>());</span><span>
</span></span></span><span><span><span></span><span>loop</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>tokio</span>::<span>select!</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>result</span><span> </span><span>=</span><span> </span><span>&amp;</span><span>mut</span><span> </span><span>future</span><span> </span><span>=&gt;</span><span> </span><span>break</span><span> </span><span>result</span><span>,</span><span>
</span></span></span><span><span><span>        </span><span>_</span><span> </span><span>=</span><span> </span><span>other_condition</span><span> </span><span>=&gt;</span><span> </span><span>continue</span><span>,</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>Coming back to our example of MPSC sends, the one asterisk with <code>reserve</code> is that cancelling it makes you lose your place in line. Instead, if you pin the <code>reserve</code> future and poll a mutable reference to it, you don’t lose your place in line.</p><p>(Does the difference here matter? It depends, but you can now have this strategy available to you.)</p><hr/><p>The second example is to use tasks. I mentioned earlier that futures are Rust are diametrically opposed to similar notions in languages like JavaScript. Well, there’s an alternative in async Rust that’s much closer to the JavaScript idea, and that’s <a href="https://docs.rs/tokio/latest/tokio/task/">tasks</a>.</p><ul><li>Unlike futures which are driven by the caller, tasks are driven by the runtime (such as Tokio).</li><li>With Tokio, dropping a handle to a task does not cause it to be cancelled, which means they’re a good place to run cancel-unsafe code.</li></ul><p>A fun example is that at Oxide, we have an HTTP server called <a href="https://docs.rs/dropshot">Dropshot</a>. Previously, whenever an HTTP request came in, we’d use a future for it, and drop the future if the TCP connection was closed.</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>// Before: Future cancelled on TCP close
</span></span></span><span><span><span></span><span>handle_request</span><span>(</span><span>req</span><span>).</span><span>await</span><span>;</span><span>
</span></span></span></code></pre></div><p>This was really bad because future cancellations could happen due to the behavior of not just the parent future, but of a process that was running across a network! This is a rather extreme form of non-local reasoning.</p><p>We addressed this by spinning up a task for each HTTP request, and by running the code to completion even if the connection is closed:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>// After: Task runs to completion
</span></span></span><span><span><span></span><span>tokio</span>::<span>spawn</span><span>(</span><span>handle_request</span><span>(</span><span>req</span><span>));</span><span>
</span></span></span></code></pre></div><h3 id="systematic-solutions">Systematic solutions?<a href="#systematic-solutions" arialabel="Anchor">#</a></h3><p>The last thing I want to say is that <strong>this sucks</strong>!</p><p>The promise of Rust is that you don’t need to do this kind of non-local reasoning—that you can analyze small bits of code for local correctness, and scale that up to global correctness. Almost everything in Rust, from <code>&amp;</code> and <code>&amp;mut</code> to <code>unsafe</code>, is geared towards making that possible. Future cancellations fly directly in the face of that, and I think they’re probably the <strong>least Rusty part of Rust</strong>. This is all really unfortunate.</p><p>Can we come up with something more systematic than this kind of ad-hoc reasoning?</p><p>There doesn’t exist anything in safe Rust today, but there are a few different ideas people have come up with. I wanted to give a nod to those ideas:</p><ul><li><em>Async drop</em> would let you run async code when a future is cancelled. This would handle some, though not all, of the cases we discussed today.</li><li>There’s also a couple different proposals for what are called <em>linear types</em>, where you could force some code to be run on drop, or mark a particular future as non-cancellable (once it’s been created it must be driven to completion).</li></ul><p>All of these options have really significant implementation challenges, though. This <a href="https://without.boats/blog/asynchronous-clean-up/">blog post from boats</a> covers some of these solutions, and the implementation challenges with them.</p><h2 id="conclusion">Conclusion<a href="#conclusion" arialabel="Anchor">#</a></h2><p>In this post, we:</p><ul><li>Saw that futures are passive</li><li>Introduced cancel safety and cancel correctness as concepts</li><li>Examined some bugs that can occur with cancellation</li><li>Looked at some recommendations you can use to mitigate the downsides of cancellation</li></ul><p>Some of the recommendations are:</p><ul><li>Avoid Tokio mutexes</li><li>Rewrite APIs to make futures cancel-safe</li><li>Find ways to ensure that cancel-unsafe futures are driven to completion</li></ul><p>There’s a very deep well of complexity here, a lot more than I can cover in one blog post:</p><ul><li>Why are futures passive, anyway?</li><li>Cooperative cancellation: cancellation tokens</li><li>Actor model as an alternative to Tokio mutexes</li><li>Task aborts</li><li>Structured concurrency</li><li>Relationship to panic safety and mutex poisoning</li></ul><p>If you’re curious about any of these, check out <a href="https://github.com/sunshowers/cancelling-async-rust">this link</a> where I’ve put together a collection of documents and blog posts about these concepts. In particular, I’d recommend reading these two Oxide RFDs:</p><ul><li><a href="https://rfd.shared.oxide.computer/rfd/397">RFD 397 Challenges with async/await in the control plane</a> by David Pacheco</li><li><a href="https://rfd.shared.oxide.computer/rfd/400">RFD 400 Dealing with cancel safety in async Rust</a> by myself</li></ul><p><em>Thank you for reading this post to the end! And thanks to many of my coworkers at Oxide for reviewing the talk and the RFDs linked above, and for suggestions and constructive feedback.</em></p></div></div></div></div>
  </body>
</html>
