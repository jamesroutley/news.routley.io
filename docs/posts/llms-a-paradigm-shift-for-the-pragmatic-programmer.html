<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://the.scapegoat.dev/llms-a-paradigm-shift-for-the-pragmatic-programmer/">Original</a>
    <h1>LLMs: a paradigm shift for the pragmatic programmer</h1>
    
    <div id="readability-page-1" class="page"><div>
<div><p><img alt="the scapegoat dev" src="https://bear-images.sfo2.cdn.digitaloceanspaces.com/manuel-1678490731-0.png"/></p>
<p>I have always been a software development aficionado: I love all the tools, I love all the paradigms, I love all the languages, I love all the frameworks. I have a blast writing code in C, PHP, Haskell, Common Lisp, Java, Javascript, Typescript, Go, Forth, Rust; I love functional, OO, procedural, event-driven; type-driven or dynamic, s-expressions or RPN syntax, code generation and macros or tab-completing immense amounts of boilerplate; relational or graph or object or just raw bytes on flash; Emacs, vim, big IDEs and custom editors; TDD or yeet into prod, code review workflows and ticketing systems. I love them all and they all love me (kind of).</p>
<p>I love thinking hard about architecture and then writing code that gets shit done. If there is a problem, there is a way to solve it and having effective tools and knowing how to use them is what gets you there. <strong>Being a &#34;scholar&#34; and a &#34;practicioner&#34; come hand in hand, because our field is young and moves at the speed of the internet.</strong> Different paradigms shape your way of framing a problem and not becoming too attached to one is the key to using them effectively.</p>
<p><strong>Most importantly, having a wide array of tools at your disposal is what allows you to be pragmatic. And pragmatically, large language models represent the biggest paradigm shift in programming that I have personally experienced.</strong> It feels an order of magnitude more life-changing than discovering Common Lisp, and I&#39;m only 3 months into using these things intensely.</p>
<p>In this series of blog posts, I will present a high-level overview of the different areas of my practice that I found to be deeply affected by this evolving technology. I won&#39;t go into concrete details, and plan to dedicate a full post to each technique presented here, with copious examples and exercises.</p>
<p>In this first post, I will cover:</p>
<ul>
<li>why knowing the fundamentals of software development is key</li>
<li>how language models can be used to do &#34;machine-augmented&#34; test driven development</li>
<li>how language models are game-changers for fuzz-testing</li>
</ul>
<p>Future sections will cover:</p>
<ul>
<li>debugging, monitoring and observability</li>
<li>building tools and user-centered development</li>
<li>changes to software architecture</li>
<li>writing documentation and technical strategy</li>
<li>searching for documentation and learning</li>
<li>personal productivity and cognitive impact</li>
</ul>
<h2 id="fundamentals-are-key">Fundamentals are key</h2>
<p>I think that using large language models needs to be approached as a mix of software development workflow, tooling and architectural paradigm.</p>
<p>To quickly and naively recap: <strong>a language model is something that models the probability of a token given a certain context.</strong> In simpler words, a language model has been trained to &#34;predict&#34; what the most probable word is given a certain amount of other text, based on a metric (usually, match the token appearing in a gargantuan amount of data scraped from the internet, further refined using different techniques).</p>
<p>There is a tremendous amount of research in this field, with new approaches and techniques coming out every day. Feel free to delve into the details... I personally don&#39;t have much practical experience doing deeper work, but I have a reasonable grasp of the fundamentals of deep learning, and try to read 2 or 3 papers a week.</p>
<p>The large language models we have these days (GPT3 and ChatGPT being the ones I use personally) are called &#34;foundational&#34; models. They have been trained on a pretty indiscriminate corpus, have an absolutely mind-blowing amount of parameters, and suffer from ludicrous training costs . Large language models seem to exhibit <a href="https://ai.googleblog.com/2022/11/characterizing-emergent-phenomena-in.html">emergent effects</a> when growing in parameter size. This allows them to function as &#34;<a href="https://ai.stanford.edu/blog/understanding-incontext/">in-context learners</a>&#34;, which means that they can be further &#34;trained&#34; by inputting a short prompt. They can be used to write Terraform just as they can be used to create comedy skits or translate from French to Farsi. It&#39;s all in the prompt.</p>
<p>Concretely, this means that the context you provide to the large language model before phrasing your concrete request is of extreme importance. <strong>The field is called <a href="https://learnprompting.org">prompt engineering</a> and while often derided, is a fascinating field and the key to effectively</strong> <strong>wield</strong> <strong>these tools for daily development.</strong> Tools like Github Copilot do a <a href="https://thakkarparth007.github.io/copilot-explorer/posts/copilot-internals.html">tremendous amount</a> of context work without using human language, and developers need to learn to do the same.</p>
<p><strong>A consequence of this probabilistic machine learning approach, as, say, compared to a symbolic approach, means that large language models by definition &#34;make plausible shit up.&#34;</strong> There are emergent effects that seem akin to understanding (the finer points of that research and debate are way out of my league, and not that interesting to me as a practitioner) break down fairly quickly.</p>
<p>This means that these models will (more often than not) output code that looks plausible but doesn&#39;t work, that mixes multiple patterns, uses APIs that don&#39;t exist (or exist in another language).</p>
<p><strong>Furthermore, these models are usually autoregressive, which means that they take their own output into consideration when predicting further tokens—this means that once they start veering off-script, they will continue doing so if not corrected.</strong> A conversational UX as offered by ChatGPT is a tremendous asset. However, a more straightforward use of the GPT3 API requires considerable attention to the prompt to avoid oblique answers.</p>
<p>This means that a programmer cannot just take the code generated by an LLM and expect it to work—careful review is needed. In fact, <strong>I found reviewing code generated by an LLM to be much more difficult to review than code written by a human.</strong> It will of course look highly plausible and be off in strange, alien ways. A human would never submit code for review that uses APIs that don&#39;t exist, or assumes that just because a named SQL pattern uses &#34;%s&#34; as syntax, it will function like <code>printf</code>.</p>
<p>I had the best results when asking the LLM to generate code in a domain that I know extremely well. This is because I am able to spot subtle mistakes at a glance. When asked to generate code in domains I know less well, I will enter what I call a &#34;hack at it&#34; loop. <strong>The model is very adept at promising you that writing &#34;just one more prompt will make the code work&#34;, encouraging you to hack at some misguided piece of code without actually looking up proper information in the reference or tutorials written by humans.</strong></p>
<p><strong>This means that fundamentals continue to be absolutely crucial, if not more critical than they already are.</strong> I found my use of LLMs to be most efficient in a domain I know extremely well, not just at a &#34;this code will work or not,&#34; but in a way where I can intuit what the LLM will &#34;understand&#34; and what will derail it. Fundamentals are what allow you to write a complex and critical piece of code but leave the tedious part to the model; they are what allow you to redirect the model to use the right pattern (&#34;use a fluent constructor API&#34;, &#34;use a map reduce&#34;, &#34;write a factory with spring-style dependency injection&#34;, &#34;use a WITH query&#34;); they are what allows you to understand which context to give the LLM, which piece of code to throw at it, which files to visit with copilot, which comments to write to get a proper answer.</p>
<h2 id="testing-and-observability">Testing and observability</h2>
<p>Many articles have been written about Copilot and ChatGPT being the harbingers of low-quality copy-pasted and error-riddled code, mindlessly inserted into the critical sections of our pristine codebases. I found that heavy use of LLMs actually improved the quality of my code, by shifting their use from generating &#34;problem solving&#34; code to &#34;solution verification&#34; code. <strong>Language models are extremely apt at repeating code patterns that they are prompted with, and applying those to the immense amount of code they have seen online.</strong></p>
<h3 id="machine-augmented-test-driven-development">Machine-augmented Test Driven Development</h3>
<p>While we might picture ourselves as brilliant scientists and engineers, building elegant solutions to unique problems, most of the code we produce has been written a million times before. This is especially true of unit tests and the edge cases they cover. <strong>Using an LLM, I am now not only able to write an order of magnitude more tests than before. However, the model often reminds me of edge cases I hadn&#39;t considered.</strong></p>
<p>Here is a workflow that I call &#34;machine-augmented TDD&#34; that I found works extremely well.</p>
<ul>
<li><strong>Think hard about the problem</strong> and develop the first sketch of a valid API. Don&#39;t write any code yet, an interface is enough</li>
<li><strong>Paste the interface into ChatGPT and ask for a list of edge cases</strong>, downsides, upsides. Rewrite the API if necessary</li>
<li><strong>Paste the suggested edge cases back into your editor</strong>, and write out a unit test or two by hand, so that the LLM can learn your style (which unit testing library, scaffolding patterns, documentation and naming style, etc...)</li>
<li>Documentation is free, and ChatGPT is proficient at writing clear, if a bit stiff, documentation, so write some! I found that many unit tests suffer from poorly written documentation. This makes it really challenging to come back to a test suite and understand which edge cases were being covered</li>
<li><strong>Autocomplete as many unit tests as seem necessary.</strong> You can usually write at the speed of tab-complete, so no reason to be conservative</li>
<li><strong>If the boilerplate becomes overwhelming, think about how they can be refactored</strong>, write the API necessary for the refactor (for example, <code>createTable(columns, rows)</code>), paste all the unit tests back into ChatGPT and ask it to refactor them (literally, &#34;refactor using this interface&#34;).<ul>
<li>Ask it to write the actual <code>createTable</code> function. LLMs are highly effective at generating test data, so again, don&#39;t skimp on how clever you can be</li>
</ul>
</li>
<li><strong>Take a break, go on a little walk.</strong> When you come back, turn off ChatGPT, and sit with your code for a moment. Is everything correct? Are there more tests to be written? Would your colleagues approve of this? Should we actually use a different interface altogether? Is the documentation adequate? <strong>Using an LLM frees up time to actually do some big picture thinking, use it</strong>!</li>
<li><strong>Once you are satisfied with your test suite, implement the actual function</strong></li>
</ul>
<p>Here is an example where I generated a test scaffold for a function that converts an integer column index to an Excelalpha string column index. I did switch from 1-indexed to 0-indexed midway without realizing, so that threw the whole thing off a bit, but I&#39;m letting it stay as is, as an example of what happens when things are a bit misaligned.</p>
<p>(I am not able to embed the iframe here on bearblog).</p>
<p><a href="https://share.descript.com/embed/P3EQM5HZ1aD" target="_blank">VIDEO: Machine-Augmented TDD with ChatGPT and Copilot</a></p>
<h3 id="generating-fuzzing-scaffolds">Generating fuzzing scaffolds</h3>
<p>Fuzzing is a technique that I have only recently started applying, but found to be applicable to a wide variety of problems. It can of course be used to identify security issues, but with proper fuzzing harnesses, fuzzing can be used to do <a href="https://arxiv.org/abs/2211.04712">model checking of state machines</a>, check for data quality problems, find <a href="https://undo-bytes.medium.com/how-to-debug-concurrency-bugs-using-thread-fuzzing-a5d742e5a507">concurrency issues</a> and much more.</p>
<p>They are most effective when using proper fuzzing harnesses. A harness is often a wrapper layer that drives the logic you want to test with a grammar that can be easily modified through common fuzzing heuristics. You can also provide and configure custom heuristics, which could allow the fuzzing engine to explore more problematic parts of your code more quickly (there is some black magic to this, and sticking with standard heuristics is often effective enough).</p>
<p>Writing these harnesses is tedious but very structured. Furthermore, they need to be adapted every time your code changes, which tends to be more expensive than just refactoring unit tests.</p>
<p><strong>One strength of large language models is their ability to translate between semi-structured language structures. They are able to recognize patterns of abstraction in the input and transform these patterns into a different representation, sometimes climbing up or down the abstraction ladder.</strong> This makes them extremely effective at working with grammars, code generation and semi-formal languages. I find this code sometimes fun, often very taxing to write. Walking ASTs, getting a parser to behave correctly, and especially later on maintaining this code is quite time consuming and error prone. Ad-hoc DSL languages are typically reified and not modified with the agility necessary to leverage fuzzing during exploratory programming.</p>
<p>Being able to rewrite a fuzzing scaffold at the &#34;speed of mouth&#34; is a life-changing experience. The workflow itself is very similar to the TDD workflow presented in the previous section.</p>
<p><a href="https://share.descript.com/embed/lDCA06yOGLM" target="_blank">VIDEO: Fuzz Testing with LLMs</a></p>
<h3 id="notes-on-the-videos">Notes on the videos</h3>
<p>These videos are obviously toy examples and were recorded pretty quickly. Large language models make it very tempting to work at full speed and get a full unit test suite and fuzz test suite done in 20 minutes. However, it is easy to be fooled by the ease of chatting with the machine. What I recommend doing is using the time saved by not typing to actually take a short break. Then, come back, turn off ChatGPT and take a close look at the code itself. I will elaborate on the cognitive shifts I had to learn to work effectively with these tools.</p>
<h2 id="what-s-coming-next">What&#39;s coming next</h2>
<p>I was picturing this article to be a quick overview of what makes LLMs so incredibly effective in my daily workflow. It turns out that even with just a single example and a quick write-up of the individual points I want to present, this exposition will be a whole series on its own. After covering the additional topics in the introduction, I plan on doing an in-depth analysis of each technique, using different languages, presenting different strategies, showing the ugly side when possible and providing a copious list of exercises.</p>
<p>See you then!</p>
<hr/>

</div>
</div></div>
  </body>
</html>
