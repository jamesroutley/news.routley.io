<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lightpanda.io/blog/posts/migrating-our-dom-to-zig">Original</a>
    <h1>Lightpanda migrate DOM implementation to Zig</h1>
    
    <div id="readability-page-1" class="page"><div><div><div><p><img src="https://cdn.lightpanda.io/website/assets/images/blog/authors/karl_seguin.png" alt="Karl Seguin"/></p><div><h3>Karl Seguin</h3><h4>Software Engineer</h4></div></div></div><div><p><time datetime="Thursday, January 8, 2026">Thursday, January 8, 2026</time></p></div><figure><img src="https://cdn.lightpanda.io/website/assets/images/blog/posts/migrating-our-dom-to-zig/migratingdomtozig_large.png" alt="Migrating our DOM to Zig"/></figure><h2 id="tldr">TL;DR<a href="#tldr" aria-label="Permalink for this section"></a></h2>
<p>We replaced LibDOM with our own Zig-based DOM implementation. The original design created friction between V8, our Zig layer, and LibDOM, especially around events, Custom Elements, and ShadowDOM. After six months of spare-time prototyping, we built zigdom: a leaner, more cohesive DOM that gives us full control over memory, events, and future enhancements. We also swapped in html5ever for parsing and added V8 snapshots to cut startup time. There are single-digit % performance gains, but the real win is a unified codebase that’s easier to extend.</p>
<h2 id="why-we-replaced-libdom">Why We Replaced LibDOM<a href="#why-we-replaced-libdom" aria-label="Permalink for this section"></a></h2>
<p>At a high level, the Lightpanda codebase can be described as a Zig layer sitting between V8 and LibDOM. When JavaScript is executed, like , V8 calls into the Zig layer which then forwards the request to the underlying LibDOM document object and then forwards the result back to V8. By using LibDOM, we gained a robust and fairly comprehensive DOM implementation with minimal effort.</p>
<p>However, as we worked to increase compatibility with websites in the wild, we felt ever-increasing friction between our three layers. One example is the event system baked into LibDOM. This proved awkward to expand beyond DOM-based events (e.g. input events) or even just bubbling DOM events to our Zig-based Window implementation. Another larger challenge, was integrating support for Custom Elements and ShadowDOM, written in Zig, with LibDOM. Finally, there was some concern about the lack of cohesion with respect to things like memory management and how that would impact potential future changes, like better multi-threading support.</p>
<p>If we were to restart the integration from scratch, knowing what we know now, we’d probably be able to avoid most of the friction we’re currently seeing. While we do modify LibDOM as needed, one approach would be to integrate V8 and LibDOM directly, applying fixes and additions directly to LibDOM. But as we wrote before, we’re <a href="https://lightpanda.io/blog/posts/why-we-built-lightpanda-in-zig" target="_blank" rel="noreferrer">fans of Zig<!-- --> <svg fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.7" viewBox="0 0 24 24" height="1em"><path d="M7 17L17 7"></path><path d="M7 7h10v10"></path></svg></a> so the discussions and prototypes we built always leaned towards replacing LibDOM with a custom Zig implementation.</p>
<h3 id="zigdom">zigdom<a href="#zigdom" aria-label="Permalink for this section"></a></h3>
<p>Work on a prototype for having a Zig-based DOM started roughly six months ago. This was a casual in-our-spare-time effort. In the spirit of experimentation, this prototype also replaced V8 with <a href="https://github.com/quickjs-ng/quickjs" target="_blank" rel="noreferrer">QuickJS-NG<!-- --> <svg fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.7" viewBox="0 0 24 24" height="1em"><path d="M7 17L17 7"></path><path d="M7 7h10v10"></path></svg></a>. By mid-November, we felt the prototype had tackled enough unknowns to start integrating it into Lightpanda (with V8). Thankfully, porting features was relatively simple; commits to the  branch could usually be ported to the  branch.</p>
<p>The design is straightforward. A  has a linked list of children and an optional . Furthermore, a  has a  tagged union field to represent the type of node, and a  field to capture its supertype:</p>

<p>Since a modern website can have tens of thousands of nodes and thousands of elements, we obviously care about the size of our ,  and . That’s why every type in our union is a pointer. That means that when we create a div, we need to allocate the Div, HTMLElement, Element, Node and EventTarget. But rather than doing five separate allocations, we do 1 large allocation for the total size and parcel it out.</p>
<p>Another area where we’ve been able to optimize for our use-case is to lazily parse/load certain properties. While a website might have thousands of elements, most JavaScript will only access the classes, styles, relLists, dataset, etc, of a few elements. Rather than having these stored on each element, even as empty lazily loaded containers, they’re attached to a page in an element -&gt; property lookup. While this adds lookup overhead, it removes ~6 pointers from every element.</p>
<p>The real win is having a more cohesive design for events, custom elements and ShadowDOM and a simpler foundation for future enhancements. That said, performance, both in terms of memory usage and CPU load are slightly improved (both single digit % improvements).</p>
<h3 id="html5ever">html5ever<a href="#html5ever" aria-label="Permalink for this section"></a></h3>
<p>We saw benefits to writing our own DOM implementation, but not our own HTML parser. For that, we turned to <a href="https://servo.org/" target="_blank" rel="noreferrer">servo’s<!-- --> <svg fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.7" viewBox="0 0 24 24" height="1em"><path d="M7 17L17 7"></path><path d="M7 7h10v10"></path></svg></a> <a href="https://github.com/servo/html5ever" target="_blank" rel="noreferrer">html5ever<!-- --> <svg fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.7" viewBox="0 0 24 24" height="1em"><path d="M7 17L17 7"></path><path d="M7 7h10v10"></path></svg></a> written in Rust. I almost forgot to mention it in this post because the experience was so painless and worked from the get-go that I haven’t had to think about it for a while. You setup html5ever with a bunch of callbacks (for creating a node, attaching a node to a parent, creating text, etc.), feed it your HTML, and away you go. My Rust is very bad, but writing a C binding for it was manageable.</p>
<h3 id="bonus---v8-snapshot">Bonus - V8 Snapshot<a href="#bonus---v8-snapshot" aria-label="Permalink for this section"></a></h3>
<p>Some of the porting was tedious. For a change of pace, I took time to see how we could leverage V8 snapshots. As a short summary, whenever you create a V8 environment to execute code, you have to do a lot of setup. Every type (hundreds) with all the functions and properties need to be registered with the V8 environment. For a simple page, this can represent anywhere from 10-30% of the total time. V8 snapshots let you setup a pseudo-environment upfront, extract a Snapshot (a binary blob), and use that blob to bootstrap and speedup future environments.</p>
<p>When in debug mode, we generated the snapshot on startup. In release mode, the snapshot is generated at compile-time and embedded into the binary, reducing startup time and memory. The overall impact depends on the relative cost of setting up the environment vs processing the page. Complex websites that load hundreds of external scripts probably won’t benefit. But incremental improvements hopefully add up and, if nothing else, help balance the performance cost of new features and complexity.</p>
<h3 id="ai-coding-agent">AI Coding Agent<a href="#ai-coding-agent" aria-label="Permalink for this section"></a></h3>
<p>This was the first large feature that I developed with the aid of an AI coding agent - specifically Claude. The experience was positive, but not flawless. I’ve personally always liked participating in code reviews / PRs. I can spend hours every day reviewing PRs, so working with Claude is kind of fun for me. If reading code isn’t something you consider fun, it could be a frustrating experience.</p>
<p>I was almost always impressed with the quality of code written and “understanding” that Claude exhibited. I’m only guessing here, but I have to imagine that building a DOM, something which has a very explicit specification, tons of documentation and many implementations, was an ideal task for a coding agent.</p>
<p>That said, I do think this is first and foremost a code-review exercise, and the Claude CLI is lacking in that respect. When you’re trying to understand and think through a change, you need a comfortable interface that lets you navigate and access whatever context you’re missing. Anything more than a few lines becomes challenging to review, especially as it’s presented for you to accept one piece at a time.</p>
<p>In the end, it’s a tool that supplements my own abilities.</p>
<h2 id="whats-next">What’s Next<a href="#whats-next" aria-label="Permalink for this section"></a></h2>
<p>Implementing our own DOM from scratch should make it easier for us to add new features and enhancements. Something we’ve already seen with better custom element and ShadowRoot support. Much of the benefits don’t come directly from implementing a new DOM, but by simply having a more cohesive codebase. For us, expanding our usage of Zig made the most sense.</p>
<p>zigdom is now merged into Lightpanda’s main branch. If you want to see how we structured the Node, Element, and event system in Zig, check out the <a href="https://github.com/lightpanda-io/browser" target="_blank" rel="noreferrer">source code on GitHub<!-- --> <svg fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.7" viewBox="0 0 24 24" height="1em"><path d="M7 17L17 7"></path><path d="M7 7h10v10"></path></svg></a>.</p><hr/><div><div><p><img src="https://cdn.lightpanda.io/website/assets/images/blog/authors/karl_seguin.png" alt="Karl Seguin"/></p><div><h3>Karl Seguin</h3><h4>Software Engineer</h4></div></div><p>Karl is a software engineer, creator of popular open-source Zig libraries like http.zig or websocket.zig. Karl has been writing about programming for years on his blog openmymind.net and is the author of Learning Zig, a series of articles to help other developers pick up the language. At Lightpanda, he works on building the core browser engine.</p></div></div></div>
  </body>
</html>
