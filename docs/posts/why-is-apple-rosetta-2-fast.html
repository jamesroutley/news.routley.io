<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://dougallj.wordpress.com/2022/11/09/why-is-rosetta-2-fast/">Original</a>
    <h1>Why is Apple Rosetta 2 fast?</h1>
    
    <div id="readability-page-1" class="page"><div>
		
<p>Rosetta 2 is remarkably fast when compared to other x86-on-ARM emulators. I’ve spent a little time looking at how it works, out of idle curiosity, and found it to be quite unusual, so I figured I’d put together my notes.<a rel="me" href="https://mastodon.social/@dougall"></a></p>



<p>My understanding is a bit rough, and is mostly based on reading the ahead-of-time translated code, and making inferences about the runtime from that. Let me know if you have any corrections, or find any tricks I’ve missed.</p>



<figure><a href="https://dougallj.wordpress.com/wp-content/uploads/2022/11/fupg8ipuuaehi0a-1.jpg"><img data-attachment-id="1483" data-permalink="https://dougallj.wordpress.com/2022/11/09/why-is-rosetta-2-fast/fupg8ipuuaehi0a-1/" data-orig-file="https://dougallj.wordpress.com/wp-content/uploads/2022/11/fupg8ipuuaehi0a-1.jpg" data-orig-size="1790,1050" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="fupg8ipuuaehi0a-1" data-image-description="" data-image-caption="" data-medium-file="https://dougallj.wordpress.com/wp-content/uploads/2022/11/fupg8ipuuaehi0a-1.jpg?w=300" data-large-file="https://dougallj.wordpress.com/wp-content/uploads/2022/11/fupg8ipuuaehi0a-1.jpg?w=628" src="https://dougallj.wordpress.com/wp-content/uploads/2022/11/fupg8ipuuaehi0a-1.jpg?w=1024" alt="" width="614" height="359" srcset="https://dougallj.wordpress.com/wp-content/uploads/2022/11/fupg8ipuuaehi0a-1.jpg?w=1024 1024w, https://dougallj.wordpress.com/wp-content/uploads/2022/11/fupg8ipuuaehi0a-1.jpg?w=612 612w, https://dougallj.wordpress.com/wp-content/uploads/2022/11/fupg8ipuuaehi0a-1.jpg?w=1224 1224w, https://dougallj.wordpress.com/wp-content/uploads/2022/11/fupg8ipuuaehi0a-1.jpg?w=150 150w, https://dougallj.wordpress.com/wp-content/uploads/2022/11/fupg8ipuuaehi0a-1.jpg?w=300 300w" sizes="(max-width: 614px) 100vw, 614px"/></a><figcaption>IDA Pro screenshot: side-by-side comparison of Rosetta 2 ahead-of-time code, and the original x86 code, for a function incorrectly named “parity64”, that computes the 8-bit parity an argument using the x86 parity-flag.</figcaption></figure>



<h2>Ahead-of-time translation</h2>



<p>Rosetta 2 translates the entire text segment of the binary from x86 to ARM up-front. It also supports just-in-time (JIT) translation, but that is used relatively rarely, avoiding both the direct runtime cost of compilation, and any indirect instruction and data cache effects.</p>



<p>Other interpreters typically translate code in execution order, which can allow faster startup times, but doesn’t preserve code locality.</p>



<h2>Usually one-to-one translation</h2>



<p>[<em>Correction:</em> an earlier version of this post said that every ahead-of-time translated instruction was a valid entry point. While I still believe it would be valid to jump to almost any ahead-of-time translated instruction, the lookup tables used do not allow for this. I believe this is an optimisation to keep the lookup size small. The prologue/epilogue optimisation was also discovered after the initial version of this post.]</p>



<p>Each x86 instruction is translated to one or more ARM instructions once within the ahead-of-time binary (with the exception of NOPs, which are ignored). When an indirect jump or call sets the instruction pointer to an arbitrary offset in the text segment, the runtime will look up the corresponding translated instruction, and branch there.</p>



<p>This uses an x86 to ARM lookup table that contains all function starts, and other basic blocks that are otherwise not referenced. If it misses this, for example while handling a switch-statement, it can fall back to the JIT.</p>



<p>To allow for precise exception handling, sampling profiling, and attaching debuggers, Rosetta 2 maintains a mapping from translated ARM instructions to their original x86 address, and guarantees that the state will be canonical between each instruction.</p>



<p>This almost entirely prevents inter-instruction optimisations. There are two known exceptions. The first is an “unused-flags” optimisation, which avoids calculating x86 flags value if they are not used before being overwritten on every path from a flag-setting instruction. The other combines function prologues and epilogues, combining push and pop instructions and delaying updates of the stack pointer. In the ARM to x86 address mapping these appear as though they were a single instruction.</p>



<p>There are some tradeoffs to keeping state canonical between each instruction:</p>



<ul>
<li>Either all emulated register values must be kept in host registers, or you need load or store instructions every time certain registers are used. 64-bit x86 has half as many registers as 64-bit ARM, so this isn’t a problem for Rosetta 2, but it would be a significant drawback to this technique for emulating 64-bit ARM on x86, or PPC on 64-bit ARM.</li>



<li>There are very few inter-instruction optimisations, leading to surprisingly poor code generation in some cases. However, in general, the code has already been generated by an optimising compiler for x86, so the benefits of many optimisations would be limited.</li>
</ul>



<p>However there are significant benefits:</p>



<ul>
<li>Generally translating each instruction only once has significant instruction-cache benefits – other emulators typically cannot reuse code when branching to a new target.</li>



<li>Precise exceptions, without needing to store much more information than instruction boundaries.</li>



<li>The debugger (LLDB) works with x86 binaries, and can attach to Rosetta 2 processes.</li>



<li>Having fewer optimisations simplifies code generation, making translation faster. Translation speed is important for both first-start time (where tens of megabytes of code may be translated), and JIT translation time, which is critical to the performance of applications that use JIT compilers.</li>
</ul>



<p>Optimising for the instruction-cache might not <em>seem</em> like a significant benefit, but it typically is in emulators, as there’s already an expansion-factor when translating between instruction sets. Every one-byte x86 push becomes a four byte ARM instruction, and every read-modify-write x86 instruction is three ARM instructions (or more, depending on addressing mode). And that’s if the perfect instruction is available. When the instructions have slightly different semantics, even more instructions are needed to get the required behaviour.</p>



<p>Given these constraints, the goal is generally to get as close to one-ARM-instruction-per-x86-instruction as possible, and the tricks described in the following sections allow Rosetta to achieve this surprisingly often. This keeps the expansion-factor as low as possible. For example, the instruction size expansion factor for an sqlite3 binary is ~1.64x (1.05MB of x86 instructions vs 1.72MB of ARM instructions).</p>



<p>(The two lookups (one from x86 to ARM and the other from ARM to x86) are found via the fragment list found in <strong>LC_AOT_METADATA</strong>. Branch target results are cached in a hash-map. Various structures can be used for these, but in one binary the performance-critical x86 to ARM mapping used a two-level binary search, and the much larger, less-performance-critical ARM to x86 mapping used a top-level binary search, followed by a linear scan through bit-packed data.)</p>



<h2>Memory layout</h2>



<p>An <strong>ADRP</strong> instruction followed by an <strong>ADD</strong> is used to emulate x86’s RIP-relative addressing. This is limited to a +/-1GB range. Rosetta 2 places the translated binary after the non-translated binary in memory, so you roughly have [untranslated code][data][translated code][runtime support code]. This means that <strong>ADRP</strong> can reference data and untranslated code as needed. Loading the runtime support functions immediately after the translated code also allows translated code to make direct calls into the runtime.</p>



<h2>Return address prediction</h2>



<p>All performant processors have a return-address-stack to allow branch prediction to correctly predict return instructions.</p>



<p>Rosetta 2 takes advantage of this by rewriting x86 <strong>CALL</strong> and <strong>RET</strong> instructions to ARM <strong>BL</strong> and <strong>RET</strong> instructions (as well as the architectural loads/stores and stack-pointer adjustments). This also requires some extra book-keeping, saving the expected x86 return-address and the corresponding translated jump target on a special stack when calling, and validating them when returning, but it allows for correct return prediction.</p>



<p>This trick is also used in the GameCube/Wii emulator Dolphin.</p>



<h2>ARM flag-manipulation extensions</h2>



<p>A lot of overhead comes from small differences in behaviour between x86 and ARM, like the semantics of flags. Rosetta 2 uses the ARM flag-manipulation extensions (FEAT_FlagM and FEAT_FlagM2) to handle these differences efficiently.</p>



<p>For example, x86 uses “subtract-with-borrow”, whereas ARM uses “subtract-with-carry”. This effectively inverts the carry flag when doing a subtraction, as opposed to when doing an addition. As <strong>CMP</strong> is a flag-setting subtraction without a result, it’s much more common to use the flags from a subtraction than an addition, so Rosetta 2 chooses inverted as the canonical form of the carry flag. The <strong>CFINV</strong> instruction (carry-flag-invert) is used to invert the carry after any <strong>ADD</strong> operation where the carry flag is used or may escape (and to rectify the carry flag, when it’s the input to an add-with-carry instruction).</p>



<p>x86 shift instructions also require complicated flag handling, as it shifts bits into the carry flag. The <strong>RMIF</strong> instruction (rotate-mask-insert-flags) is used within rosetta to move an arbitrary bit from a register into an arbitrary flag, which makes emulating fixed-shifts (among other things) relatively efficient. Variable shifts remain relatively inefficient if flags escape, as the flags must not be modified when shifting by zero, requiring a conditional branch.</p>



<p>Unlike x86, ARM doesn’t have any 8-bit or 16-bit operations. These are generally easy to emulate with wider operations (which is how compilers implement operations on these values), with the small catch that x86 requires preserving the original high-bits. However, the <strong>SETF8</strong> and <strong>SETF16</strong> instructions help to emulate the flag-setting behaviour of these narrower instructions.</p>



<p>Those were all from FEAT_FlagM. The instructions from FEAT_FlagM2 are <strong>AXFLAG</strong> and <strong>XAFLAG</strong>, which convert floating-point condition flags to/from a mysterious “external format”. By some strange coincidence, this format is x86, so these instruction are used when dealing with floating point flags.</p>



<h2>Floating-point handling</h2>



<p>x86 and ARM both implement IEEE-754, so the most common floating-point operations are almost identical. One exception is the handling of the different possible bit patterns underlying NaN values, and another is whether tininess is detected before or after rounding. Most applications won’t mind if you get this wrong, but some will, and to get it right would require expensive checks on every floating-point operation. Fortunately, this is handled in hardware.</p>



<p>There’s a standard ARM alternate floating-point behaviour extension (FEAT_AFP) from ARMv8.7, but the M1 design predates the v8.7 standard, so Rosetta 2 uses a non-standard implementation.</p>



<p>(What a coincidence – the “alternative” happens to exactly match x86. It’s quite funny to me that ARM will put “Javascript” in the description of an instruction, but needs two different euphemisms for “x86”.)</p>



<h2>Total store ordering (TSO)</h2>



<p>One non-standard ARM extension available on the Apple M1 that has been widely publicised is hardware support for TSO (total-store-ordering), which, when enabled, gives regular ARM load-and-store instructions the same ordering guarantees that loads and stores have on an x86 system.</p>



<p>As far as I know this is not part of the ARM standard, but it also isn’t Apple specific: Nvidia Denver/Carmel and Fujitsu A64fx are other 64-bit ARM processors that also implement TSO (<a href="https://twitter.com/marcan42/status/1534053625110351872">thanks to marcan for these details</a>).</p>



<h2>Apple’s secret extension</h2>



<p>There are only a handful of different instructions that account for 90% of all operations executed, and, near the top of that list are addition and subtraction. On ARM these can optionally set the four-bit NZCV register, whereas on x86 these always set six flag bits: CF, ZF, SF and OF (which correspond well-enough to NZCV), as well as PF (the parity flag) and AF (the adjust flag).</p>



<p>Emulating the last two in software is possible (and seems to be supported by Rosetta 2 for Linux), but can be rather expensive. Most software won’t notice if you get these wrong, but some software will. The Apple M1 has an undocumented extension that, when enabled, ensures instructions like <strong>ADDS</strong>, <strong>SUBS</strong> and <strong>CMP</strong> compute PF and AF and store them as bits 26 and 27 of NZCV respectively, providing accurate emulation with no performance penalty.</p>



<h2>Fast hardware</h2>



<p>Ultimately, the M1 is incredibly fast. By being so much wider than comparable x86 CPUs, it has a remarkable ability to avoid being throughput-bound, even with all the extra instructions Rosetta 2 generates. In some cases (iirc, IDA Pro) there really isn’t much of a speedup going from Rosetta 2 to native ARM.</p>



<h2>Conclusion</h2>



<p>I believe there is room for performance improvement in Rosetta 2, by performing more inter-instruction optimisations. However, this would come at the cost of significantly increased complexity (especially for debugging and exception handling), and increased translation times.</p>



<p>Engineering is about making the right tradeoffs, and I’d say Rosetta 2 has done exactly that. While other emulators might require inter-instruction optimisations for performance, Rosetta 2 is able to trust a fast CPU, generate code that respects its caches and predictors, and solve the messiest problems in hardware.</p>



<p>You can follow me at <a href="https://mastodon.social/@dougall"></a><a href="https://mastodon.social/@dougall">@dougall@mastodon.social</a>.</p>



<h2>Update: SSE2 support</h2>



<p>After reading some comments I realised this was a significant omission from the original post. Rosetta 2 provides full emulation for the SSE2 SIMD instruction set. These instructions have been enabled in compilers by default for many years, so this would have been required for compatibility. However, all common operations are translated to a reasonably-optimised sequence of NEON operations. This is critical to the performance of software that has been optimised to use these instructions.</p>



<p>Many emulators also use this SIMD to SIMD translation approach, but other use SIMD to scalar, or call out to runtime support functions for each SIMD operation.</p>



<h2>Update: Unused flag optimisation</h2>



<p>This is one of two inter-instruction optimisations mentioned earlier, but it deserves its own section. Rosetta 2 avoids computing flags when they are unused and don’t escape. This means that even with the flag-manipulation instructions, the vast majority of flag-setting x86 instructions can be translated to non-flag-setting ARM instructions, with no fix-up required. This improves instruction count and size a lot.</p>



<p>It’s even more valuable for Rosetta 2 in Linux VMs. In VMs, Rosetta is unable to enable the Apple parity-flag extension, and instead computes the value manually. (It may or may not also compute the adjust-flag). This is relatively expensive, so it’s very valuable to avoid it.</p>



<h2>Update: Prologue/epilogue combining</h2>



<p>The last inter-instruction optimisation I’m aware of is prologue/epilogue combining. Rosetta 2 finds groups of instructions that set up or tear down stack frames, and merges them, pairing loads and stores, and delaying stack-pointer updates. This is equivalent to the “stack engine” found in hardware implementations of x86.</p>



<p>For example, the following prologue:</p>



<pre><code>push rbp
mov rbp, rsp
push rbx
push rax</code></pre>



<p>Becomes:</p>



<pre><code>stur x5, [x4,#-8]
sub x5, x4, #8
stp x0, x3, [x4,#-0x18]!</code></pre>



<p>This greatly reduces the number of loads, stores, and arithmetic instructions that modify the stack-pointer, improving performance and code size. These paired loads and stores execute as a single operation on the Apple M1, which, as far as I know, isn’t possible on x86 CPUs, giving Rosetta 2 an advantage here.</p>



<h2>Appendix: Research Method</h2>



<p>This exploration was based on the methods and information described in Koh M. Nakagawa’s excellent <a href="https://ffri.github.io/ProjectChampollion/">Project Champollion</a>.</p>



<p>To see ahead-of-time translated Rosetta code, I believe I had to disable SIP, compile a new x86 binary, give it a unique name, run it, and then run <strong>otool -tv /var/db/oah/*/*/unique-name.aot</strong> (or use your tool of choice – it’s just a Mach-O binary). This was done on an old version of macOS, so things may have changed and improved since then.</p>



<h2>Update: Appendix: Compatibility</h2>



<p>Although it has nothing to do with why Rosetta 2 is fast, there are a couple of impressive compatibility features that seem worth mentioning.</p>



<p>Rosetta 2 has a full, slow, software implementation of x87’s 80-bit floating point numbers. This allows software that uses those instructions to run correctly. Windows on Arm approaches this by using 64-bit float operations, which generally works, but the decreased precision cause problems on in rare cases. Most software either doesn’t use x87, or was designed to run on older hardware, so even though this emulation is slow, the performance typically works out.</p>



<p>[<em>Update: </em>An earlier version of this post stated that I didn’t believe Windows on Arm handled x87. Thanks to kode54 for correcting this in a comment.]</p>



<p>Rosetta 2 also apparently supports the full 32-bit instruction set for Wine. Support for native 32-bit macOS applications was dropped prior to the launch of Apple Silicon, but support for the 32-bit x86 instruction set allegedly lives on. (I haven’t investigated this myself.)</p>




			</div></div>
  </body>
</html>
