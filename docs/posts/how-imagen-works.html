<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.assemblyai.com/blog/how-imagen-actually-works/">Original</a>
    <h1>How Imagen Works</h1>
    
    <div id="readability-page-1" class="page"><section>
      <p>While the Machine Learning world was still coming to terms with the impressive results of <a href="https://www.assemblyai.com/blog/how-dall-e-2-actually-works/">DALL-E 2</a>, released earlier this year, Google upped the ante by releasing its own text-to-image model <strong>Imagen,</strong> which appears to push the boundaries of caption-conditional image generation even further. </p><p>Imagen, released just last month, can generate high-quality, high-resolution images given only a description of a scene, regardless of how logical or plausible such a scene may be in the real world. Below you can see several examples of such images with their corresponding captions beneath:</p><figure><img src="https://www.assemblyai.com/blog/content/images/2022/06/imagen_examples.png" alt="" loading="lazy" width="2000" height="873" srcset="https://www.assemblyai.com/blog/content/images/size/w600/2022/06/imagen_examples.png 600w, https://www.assemblyai.com/blog/content/images/size/w1000/2022/06/imagen_examples.png 1000w, https://www.assemblyai.com/blog/content/images/size/w1600/2022/06/imagen_examples.png 1600w, https://www.assemblyai.com/blog/content/images/size/w2400/2022/06/imagen_examples.png 2400w" sizes="(min-width: 720px) 720px"/><figcaption>Images created by Imagen given the corresponding captions (adapted from <a href="https://imagen.research.google/">source</a>)</figcaption></figure><p>These impressive results no doubt have many wondering <strong>how Imagen actually works</strong>. In this article, we&#39;ll explain how Imagen works at several levels.</p><p>First, we will examine Imagen from a <strong>bird&#39;s-eye view</strong> in order to understand its high-level components and how they relate to one another. We&#39;ll then go into a bit more detail regarding these components, each with its own subsection, in order to understand how they themselves work. Finally, we&#39;ll perform a <strong>Deep Dive</strong> into Imagen that is intended for Machine Learning researchers, students, and practitioners.</p><p>Without further ado, letâ€™s dive in!</p><h2 id="introduction">Introduction</h2><p>In the past few years, there has been a significant amount of progress made in the <strong>text-to-image domain</strong> of Machine Learning. A text-to-image model takes in a short textual description of a scene and then generates an image which reflects the described scene. An example input description (or &#34;caption&#34;) and output image can be seen below:</p><figure><img src="https://www.assemblyai.com/blog/content/images/2022/06/tti_intro_crop.png" alt="" loading="lazy" width="960" height="324" srcset="https://www.assemblyai.com/blog/content/images/size/w600/2022/06/tti_intro_crop.png 600w, https://www.assemblyai.com/blog/content/images/2022/06/tti_intro_crop.png 960w" sizes="(min-width: 720px) 720px"/><figcaption>Input and output of a text-to-image model (image and description pulled from <a href="https://imagen.research.google/">source</a>)</figcaption></figure><p>It is important to note that high-performing text-to-image models will <strong>necessarily be able to combine unrelated concepts and objects in semantically plausible ways</strong>. These models must therefore overcome challenges like capturing spatial relationships, understanding cardinality, and properly interpreting how words in the description relate to one another. If we more closely inspect the image from the above figure, we can see that Imagen performs well on these fronts upon first inspection.</p><figure><img src="https://www.assemblyai.com/blog/content/images/2022/06/tti_annotation_crop.png" alt="" loading="lazy" width="563" height="473"/><figcaption>Imagen captures semantic and logical relationship well (image adapted from <a href="https://imagen.research.google/">source</a>)</figcaption></figure><p>It is hard to understate just how impressive these models are. They are not using a database to search for and return an image which <em>matches</em> the description, and they are not even &#34;stitching&#34; together pre-existing sub-images in a clean way such that the result corresponds to the caption. They instead generate <strong>entirely</strong> <strong>novel </strong>images that convey visually the semantic information contained in the caption.</p><p>Now that we understand what text-to-image models are in general, we can take a look at how the text-to-image model <strong>Imagen </strong>works from a bird&#39;s-eye view.</p><h2 id="how-imagen-works-a-birds-eye-view">How Imagen Works: A Bird&#39;s-Eye View</h2><p>In this section, we&#39;ll learn what the salient components of Imagen do and how they relate to one another. First, we&#39;ll look at the overarching architecture of Imagen with a high-level explanation of how it works, and then inspect each component more thoroughly in the subsections below.</p><p>Here is a short video outlining how Imagen works, with a breakdown of what&#39;s going on below:</p><figure><div><video src="https://www.assemblyai.com/blog/content/media/2022/06/birds_eye.mp4" poster="https://img.spacergif.org/v1/1920x1080/0a/spacer.png" width="1920" height="1080" loop="" autoplay="" muted="" playsinline="" preload="metadata"></video><div><div><p><span>0:00</span></p><p>/<span></span></p></div></div></div><figcaption>How Imagen works (bird&#39;s-eye view)</figcaption></figure><ol><li>First, the caption is input into a <strong>text encoder</strong>. This encoder converts the textual caption to a numerical representation that <strong>encapsulates the semantic information within the text</strong>. </li><li>Next, an image-generation model creates an image by starting with noise, or &#34;TV static&#34;, and slowly transforming it into an output image. To guide this process, the image-generation model receives the text encoding as an input, which has the effect of <strong>telling the model what is in the caption</strong> so it can create a corresponding image. The output is a small image that reflects visually the caption we input to the text encoder!</li><li>The small image is then passed into a <strong>super-resolution model</strong>, which grows the image to a higher resolution.<strong> </strong>This model also takes the text encoding as input, which helps the model decide how to behave as it &#34;fills in the gaps&#34; of missing information that necessarily arise from quadrupling the size of our image. The result is a <strong>medium sized image</strong> of what we want.</li><li>Finally, this medium sized image is then passed into yet <strong>another super-resolution model</strong>, which operates near-identically to the previous one, except this time it takes our <em>medium</em> sized image and grows it to a <strong>high-resolution</strong> image. The result is 1024 x 1024 pixel image that visually reflects the semantics within our caption.</li></ol><p>At the highest level, that is all there is to it! For a slightly more detailed look at each of Imagen&#39;s big components, check out the below subsections. Otherwise, you can jump down to the <a href="https://www.assemblyai.com/blog/how-imagen-actually-works/#how-imagen-works-a-deep-dive">Deep Dive</a> section to get into the nitty-gritty of how Imagen works, or jump straight down to the <a href="https://www.assemblyai.com/blog/how-imagen-actually-works/#final-words">Final Words</a>.</p><h3 id="text-encoder">Text Encoder</h3><p>In this subsection, we will take a closer look at <strong>Imagen&#39;s text encoder</strong>. As we can tell from the above video, the text encoder is critical to Imagen&#39;s performance. It conditions <em>all </em>of Imagen&#39;s other components and is responsible for encoding the textual caption in a useful way.</p><p>The text encoder in Imagen is a Transformer encoder. If you are unfamiliar with Transformers, don&#39;t worry. The most important detail here is that such an encoder ensures that the <strong>text encoding understands how the words within the caption relate to one another</strong> (by a method called &#34;self-attention&#34;). This is <strong>very important </strong>because the English language encodes information via its syntactic structure that affects the semantic meaning of a given sentence. </p><p>If Imagen only paid attention to individual words and not how they relate to one other, we could get high-quality images that capture individual elements of the caption, but do not portray them in a way that appropriately reflects the semantics of the caption. We can see this difference in the below example, where a lack of consideration for how words relate to one another could yield an extremely poor (albeit hilarious) result:</p><figure><img src="https://www.assemblyai.com/blog/content/images/2022/06/pitfall.png" alt="" loading="lazy" width="1198" height="860" srcset="https://www.assemblyai.com/blog/content/images/size/w600/2022/06/pitfall.png 600w, https://www.assemblyai.com/blog/content/images/size/w1000/2022/06/pitfall.png 1000w, https://www.assemblyai.com/blog/content/images/2022/06/pitfall.png 1198w" sizes="(min-width: 720px) 720px"/></figure><!--kg-card-begin: html--><div data-template="accordion">
  <header>
    <p>Small Note</p>
  </header>
	<p>While the above example is intended to highlight the need for a Transformer encoder/self-attention, results would not even be as good as the &#34;incorrect&#34; image. For example, without a means to understand the syntactic relationship between words, the model would not understand that &#34;standing on&#34; requires both direct and indirect objects and would therefore fail to portray this concept correctly.</p>
</div>
   <!--kg-card-end: html--><p>The text-encoder is <strong>frozen</strong> during training, meaning that it does not learn or change the way it creates the encodings. It is <em>only</em> used to generate encodings that are fed to the rest of the model, which <strong>is</strong> trained.</p><p>Now that we understand more about Imagen&#39;s text encoder, let&#39;s take a look at the component that actually generates images.</p><h3 id="image-generator">Image Generator</h3><p>The text-encoder generates a useful representation of the caption input to Imagen, but we still need to devise a method to <em>generate </em>an image<em> </em>that uses this representation. To do this, Imagen uses a <strong>Diffusion Model</strong>, which is a type of generative model that has gained significant popularity in recent years due to its State-of-the-Art performance on several tasks. Before moving forward, let&#39;s look at a brief recap of Diffusion Models now.</p><!--kg-card-begin: html--><h4>What are Diffusion Models?</h4><!--kg-card-end: html--><p>Diffusion Models are a method of creating data that is similar to a set of training data. They train by destroying the training data through the addition of noise, and then learning to recover the data by reversing this noising process. Given an input image, the Diffusion Model will iteratively corrupt the image with Gaussian noise in a series of <strong>timesteps</strong>, ultimately leaving pure Gaussian noise, or &#34;TV static&#34;.</p><figure><img src="https://www.assemblyai.com/blog/content/images/2022/06/image-5.png" alt="" loading="lazy" width="1584" height="257" srcset="https://www.assemblyai.com/blog/content/images/size/w600/2022/06/image-5.png 600w, https://www.assemblyai.com/blog/content/images/size/w1000/2022/06/image-5.png 1000w, https://www.assemblyai.com/blog/content/images/2022/06/image-5.png 1584w" sizes="(min-width: 720px) 720px"/><figcaption>Diffusion Models&#39; iterative noising process (modified from <a href="https://arxiv.org/pdf/2006.11239.pdf">source</a>)</figcaption></figure><p>The Diffusion Model will then work backwards, learning how to isolate and remove the noise at each timestep, undoing the destruction process that just occurred.</p><p>Once trained, the model can then be &#34;split in half&#34;, and we can <em>start </em>from randomly sampled Gaussian noise which we use the Diffusion Model to gradually denoise in order to generate an image.</p><figure><img src="https://www.assemblyai.com/blog/content/images/2022/06/image-4.png" alt="" loading="lazy" width="1025" height="173" srcset="https://www.assemblyai.com/blog/content/images/size/w600/2022/06/image-4.png 600w, https://www.assemblyai.com/blog/content/images/size/w1000/2022/06/image-4.png 1000w, https://www.assemblyai.com/blog/content/images/2022/06/image-4.png 1025w" sizes="(min-width: 720px) 720px"/><figcaption>A Diffusion Model starts from noise and &#34;denoises&#34; it to generate images (modified from <a href="https://arxiv.org/pdf/2006.11239.pdf">source</a>)</figcaption></figure><p>Below we can see an example of handwritten digits being generated from pure Gaussian noise:</p><figure><img src="https://www.assemblyai.com/blog/content/images/2022/06/movie.gif" alt="" loading="lazy" width="122" height="122"/><figcaption>A Diffusion Model can generate novel handwritten digits from Gaussian noise (<a href="https://www.assemblyai.com/blog/diffusion-models-for-machine-learning-introduction/">source</a>)</figcaption></figure><p>For a full treatment of Diffusion Models, feel free to check out our article covering them.</p><!--kg-card-begin: html--><center><a data-template="button" href="https://www.assemblyai.com/blog/diffusion-models-for-machine-learning-introduction/" target="_blank">
    Introduction to Diffusion Models for Machine Learning
    </a></center><!--kg-card-end: html--><!--kg-card-begin: html--><h4>Caption Conditioning</h4><!--kg-card-end: html--><p>To summarize, a trained Diffusion Model starts with Gaussian noise and then iteratively generates an image that is similar to the images on which it was trained. It may be apparent at this point that we have <strong>no control </strong>over what image is actually output - we simply input Gaussian noise into the model, and it spits out a random image that looks like it could belong to the training dataset. Recall that <strong>our goal is to create<em> </em>images that encapsulate the semantic information of the caption</strong> we input into Imagen, so we need a method of incorporating the caption into the diffusion process. How do we accomplish this?</p><p>Recall from above that our text encoder produced a representative encoding of the caption. This &#34;encoding&#34; is actually a sequence of vectors. To inject this encoding information into the Diffusion Model, we pool these vectors together and condition our diffusion model on them. By conditioning on this vector, the Diffusion Model learns how to adapt its denoising procedure in order to produce an image that is well-aligned with the caption. This process can be visualized in the video below:</p><figure><div><video src="https://www.assemblyai.com/blog/content/media/2022/06/cap_cond.mp4" poster="https://img.spacergif.org/v1/1920x1080/0a/spacer.png" width="1920" height="1080" loop="" autoplay="" muted="" playsinline="" preload="metadata"></video><div><div><p><span>0:00</span></p><p>/<span></span></p></div></div></div><figcaption>Conditioning the image-generation process on the caption.</figcaption></figure><h3 id="image-super-resolution">Image Super-Resolution</h3><p>The image generator, or &#34;base&#34; model, outputs a small 64x64 image. To upsample this model to the final 1024x1024 version we use a super-resolution model to intelligently upsample the image. </p><p>For the super-resolution model, Imagen again uses a Diffusion Model. The overall process is basically the same as the base model; except, instead of conditioning on just the caption encoding, we also condition on the smaller image which we are upsampling. The overall process can be visualized in the below video:</p><figure><div><video src="https://www.assemblyai.com/blog/content/media/2022/06/super_res.mp4" poster="https://img.spacergif.org/v1/1920x1080/0a/spacer.png" width="1920" height="1080" loop="" autoplay="" muted="" playsinline="" preload="metadata"></video><div><div><p><span>0:00</span></p><p>/<span></span></p></div></div></div></figure><p>The output of this super-resolution model is actually not our final output but a <em>medium</em> sized image. To upscale this image to the final 1024x1024 resolution, yet <em>another</em> super-resolution model is used. The two super-resolution architectures are approximately equivalent, so we will not belabor the point by going into the details of the second super-resolution model.</p><p><strong>The output of the second super-resolution model is the final output of Imagen</strong>.</p><h3 id="summary">Summary</h3><figure><img src="https://www.assemblyai.com/blog/content/images/2022/06/image-6.png" alt="" loading="lazy" width="1100" height="625" srcset="https://www.assemblyai.com/blog/content/images/size/w600/2022/06/image-6.png 600w, https://www.assemblyai.com/blog/content/images/size/w1000/2022/06/image-6.png 1000w, https://www.assemblyai.com/blog/content/images/2022/06/image-6.png 1100w" sizes="(min-width: 720px) 720px"/></figure><p>To summarize, <strong>the caption is input into a pre-trained and frozen Transformer encoder</strong> which outputs a sequence of vectors (the text encoding). These vectors are important because they encode how words in the caption relate to one another and act as conditioning information for all other components of the model.</p><p>The text encodings are then passed into an <strong>image generation Diffusion Model</strong>, which starts with Gaussian noise and then gradually removes noise to generate a novel image which reflects the semantic information within the caption. The output of this model is a 64x64 pixel image.</p><p>After this, two more Diffusion Models are used to <strong>super-resolve this image to the final 1024x1024 size</strong>, again conditioned on the text encodings (as well as lower resolution images).</p><p>Now that we have a bird&#39;s-eye understanding of Imagen, we can dive into the details in the next section. Alternatively, feel free to jump down to the <a href="https://www.assemblyai.com/blog/how-imagen-actually-works/#results-and-analysis">Results and Analysis</a> or <a href="https://www.assemblyai.com/blog/how-imagen-actually-works/#final-words">Final Words</a>.</p><h2 id="how-imagen-works-a-deep-dive">How Imagen Works: A Deep Dive</h2><p>In the below sections, we will perform a Deep Dive into each of Imagen&#39;s components, highlighting certain structural features design-choice logic. We start with the text encoder.</p><h2 id="text-encoder-1">Text Encoder</h2><p>The text encoder in Imagen is the encoder network of T5 (<a href="https://arxiv.org/abs/1910.10683"><strong>T</strong>ext-<strong>t</strong>o-<strong>T</strong>ext <strong>T</strong>ransfer <strong>T</strong>ransformer</a>), a language model released by Google in 2019. T5 is a text-to-text model that serves as a general framework for many NLP tasks by framing them as text-to-text problems. We can see several examples of this approach in the below diagram, where translation, sentence-acceptability determination (cola), sentence-similarity estimation (stsb), and summarization are all cast in this manner.</p><figure><img src="https://www.assemblyai.com/blog/content/images/2022/06/t5_tasksgif.gif" alt="" loading="lazy" width="640" height="240"/><figcaption>(<a href="https://ai.googleblog.com/2020/02/exploring-transfer-learning-with-t5.html">source</a>)</figcaption></figure><p>T5 is intended to be finetuned for any NLP task that can be cast in this text-to-text manner.</p><!--kg-card-begin: html--><div data-template="accordion">
  <header>
    <p>Transfer Learning Recap</p>
  </header>
	<div>
    <p>Recall that transfer learning is a technique by which a very large model is trained on a large, diverse, and general dataset (called &#34;pretraining&#34;) in order to provide a foundational model that has &#34;general knowledge&#34;. Given a task and related dataset, the model is then modified as needed and trained on the task-specific dataset (called &#34;finetuning&#34;), using the &#34;general knowledge&#34; to more quickly learn for the specific task.</p>
        <p>In the computer vision domain, this process could manifest itself as training an autoencoder in order to learn feature maps that are useful for any task given that all objects are composed of the same elements - edges, corners, textures, colors, etc. Once these feature maps are learned, the encoder can be extracted and e.g. a classifier can be built on top of it and then trained on a task-specific dataset, leveraging the already-learned feature extractors in order to more quickly learn the classification network, in this case determining whether or not an input image is one of pizza.</p>
        </div>
</div><!--kg-card-end: html--><h3 id="why-is-t5-used-in-imagen">Why is T5 Used in Imagen?</h3><p>Some other text-to-image models like DALL-E 2 use text-encoders which are trained on image-caption pairs and an associated objective that is explicitly designed for the purpose of linking textual and visual representations of the same semantic concept. Such encoders, having been trained in an image-adjacent fashion, seem to therefore map more naturally to the problem of text-to-image generation than an NLP-specific text-encoder trained without regard to the image domain. <strong>It is therefore sensible to ask why the Imagen authors chose to use T5 as a text-encoder for Imagen</strong>.</p><p>The central intuition in using T5 is that <strong>extremely large language models</strong>, by virtue of their sheer size alone, <strong>may still learn useful representations</strong> despite the fact that they are not explicitly trained with any text/image task in mind. In addition to the extremely large size of some language models, it is also true that language models are trained on text-only corpi, which can be notably larger than datasets of paired text/images. The size and quality of a dataset that a model is trained on is arguably more important than the specifics of the model itself. In fact, T5 sees performance comparable to BERT even with only <a href="https://www.youtube.com/watch?v=eKqWC577WlI&amp;t=2480s">25% of the training time</a> thanks to its dataset. The combination of huge models and massive, diverse datasets leave plenty of headroom for learning powerful textual representations that may be useful in other domains. </p><p>Therefore, the central question being addressed by this choice is <strong>whether or not a massive language model trained on a massive dataset independent of the task of image generation is a worthwhile trade-off for a non-specialized text encoder</strong>. The Imagen authors bet on the side of the large language model, and it is a bet that seems to pay off well.</p><h2 id="image-generator-1">Image Generator</h2><p>As mentioned above, the image generator in Imagen is a Diffusion Model, an unsurprising choice given their past few years of incredible progress. You can find a brief recap of Diffusion Models <a href="https://www.assemblyai.com/blog/how-imagen-actually-works/#image-generator">above</a> or check out our dedicated <a href="https://www.assemblyai.com/blog/diffusion-models-for-machine-learning-introduction/">Introduction to Diffusion Models for Machine Learning</a> them for a full treatment.</p><p>With a basic understanding of Diffusion Models assumed, we will now explore the specifics of Imagen&#39;s implementation.</p><h3 id="network-architecture">Network Architecture</h3><p>A Diffusion Model is really sort of a &#34;metamodel&#34; framework that tells us <strong><em>how </em>to use</strong> <strong>a neural model</strong> to denoise images. The architecture of the neural model itself has yet to be discussed or established, and the only relevant restriction on the neural model is that its input and output dimensionalities must be the same. That is, the image must not change size during the diffusion process. </p><p>With this restriction in mind, the authors select a U-Net architecture, as is common, which is left generally unmodified from the implementation by <a href="https://arxiv.org/pdf/2102.09672.pdf">Nichol and Dhariwal</a>. We can see the U-Net&#39;s overarching architecture below:</p><figure><img src="https://www.assemblyai.com/blog/content/images/2022/06/image-15.png" alt="" loading="lazy" width="912" height="683" srcset="https://www.assemblyai.com/blog/content/images/size/w600/2022/06/image-15.png 600w, https://www.assemblyai.com/blog/content/images/2022/06/image-15.png 912w" sizes="(min-width: 720px) 720px"/><figcaption>replace</figcaption></figure><p>Each residual block is composed of two sub-blocks, and each of these sub-blocks is composed of a Batch Normalization, ReLU, and 3x3 Convolution in sequence.</p><figure><img src="https://www.assemblyai.com/blog/content/images/2022/06/residual_block_2.png" alt="" loading="lazy" width="1455" height="724" srcset="https://www.assemblyai.com/blog/content/images/size/w600/2022/06/residual_block_2.png 600w, https://www.assemblyai.com/blog/content/images/size/w1000/2022/06/residual_block_2.png 1000w, https://www.assemblyai.com/blog/content/images/2022/06/residual_block_2.png 1455w" sizes="(min-width: 720px) 720px"/></figure><h3 id="timestep-conditioning">Timestep Conditioning</h3><p>In Imagen (and generally Diffusion Models as a whole), the same denoising U-Net is used at every timestep. Recall that different amounts of noise are removed at different timesteps in a Diffusion Model. We must therefore devise a way to inject timestep information into the model (i.e. <em>condition</em> on the timestep). The Imagen authors utilize a technique introduced by the original Transformer paper called <strong>positional encoding</strong>. </p><!--kg-card-begin: html--><div data-template="accordion">
  <header>
    <p>Positional Encoding - Additional Details</p>
  </header>
	<div>
    <p>The original language Transformer was intended to be used on sentences, a context in which the order of words is critically important; however, Transformer encoders operate on <b>sets</b>, meaning that word order does not matter to them. In order to inject position information into Transformers, the authors used a clever method of generating a <b>unique positional encoding vector</b> for each word index, where the dimensionality of the positional vector is the same as that of the word embedding vectors. By adding these positional encodings to the word embeddings, positionally-encoded word embeddings are created which inject positional information into the Transformer.</p>
        <p>This phenomenon is visualized in the video below. It is easy to see that, despite the fact that the two instances of the word &#34;really&#34; have identical word embeddings, their positionally-encoded word embeddings are different given that their positional encoding vectors are different.</p>
</div>
</div>
   <!--kg-card-end: html--><p>In Imagen, a unique <strong>timestep encoding vector</strong> is generated for each timestep (corresponding to &#34;word position&#34; in the original positional embedding implementation). At different resolutions in the U-Net, this vector is projected to having <em>c</em> components, where <em>c</em> is the number of channels in the U-Net at that resolution. After projection, each component of the vector is added to the corresponding channel (across its height and width) in the image. </p><p>This process is visualized below for the case of a 3x3 image with 8 channels:</p><figure><div><video src="https://www.assemblyai.com/blog/content/media/2022/06/time_enc.mp4" poster="https://img.spacergif.org/v1/1920x1080/0a/spacer.png" width="1920" height="1080" loop="" autoplay="" muted="" playsinline="" preload="metadata"></video><div><div><p><span>0:00</span></p><p>/<span></span></p></div></div></div></figure><p>While this is not <em>exactly </em>how timestep conditioning works in Imagen, it is very close and is in fact identical to how some other Diffusion Models inject timestep information. Note that some form of timestep encoding is required for <em>any</em> Diffusion Model (at least as they are commonly implemented) and is not unique to Imagen.</p><h3 id="caption-conditioning">Caption Conditioning</h3><p>We&#39;ve yet to incorporate information from our image caption into the Diffusion Model U-Net, so we need to do that now. This caption conditioning happens in two ways.</p><p>First, the output vectors from the T5 text encoder are pooled and added into the timestep embedding from above. This process is visualized in the below image:</p><figure><img src="https://www.assemblyai.com/blog/content/images/2022/06/caption_condition-.png" alt="" loading="lazy" width="960" height="540" srcset="https://www.assemblyai.com/blog/content/images/size/w600/2022/06/caption_condition-.png 600w, https://www.assemblyai.com/blog/content/images/2022/06/caption_condition-.png 960w" sizes="(min-width: 720px) 720px"/></figure><p>Next, the model is conditioned on the entire encoding <em>sequence </em>by adding cross attention over the text embeddings at several resolutions. The cross attention is implemented by concatenating the text embedding sequence to the key-value pairs of each self-attention layer.</p><!--kg-card-begin: html--><div data-template="accordion">
  <header>
    <p>Implementation Detail</p>
  </header>
	<p>Additionally, layer normalization was found to be critical for text embeddings in both the attention and pooling layers.</p>
</div>
   <!--kg-card-end: html--><h3 id="classifier-free-guidance">Classifier-Free Guidance</h3><p>Imagen also takes advantage of Classifier-Free Guidance. Classifier-Free Guidance is a method of increasing the image fidelity of a Diffusion Model at the cost of image diversity. The method is named as such due to the fact that it is a related and simpler version/extension of a previous method called Classifier Guidance, which was used for the same purposes.</p><!--kg-card-begin: html--><div data-template="accordion">
  <header>
    <p>Classifier Guidance</p>
  </header>
	<div>
    <p>Classifier Guidance is a method for trading off the fidelity and diversity of images generated by a Diffusion Model. This method requires a trained classifier model, which is used to push the diffusion process towards feature regimes of high class probability. That is, the classifier is used to guide the image towards the classifier&#39;s own modes.</p>
        <p>Consider the following equation:</p>
        </div>
</div>
   <!--kg-card-end: html--><p>Classifier-Free Guidance works by training a Diffusion Model to be both conditional and unconditional <em>at the same time</em>. In order to do this, the Diffusion Model is cast as a conditional model and is trained with the conditioning information randomly dropped out a small fraction of the time (by replacing the conditional information with a NULL value). To use the model in an unconditional way, the NULL value is simply provided as the &#34;conditional information&#34; to the model.</p><p>Given such a model, Classifier-Free guidance works loosely by <em>interpolating between the unconditional and conditional gradients<strong> </strong></em>during inference. By magnifying the effect of the conditional gradient (i.e. making the &#34;<strong>guidance weight</strong>&#34; greater than 1), better samples can be obtained:</p><figure><img src="https://www.assemblyai.com/blog/content/images/2022/06/guidance.png" alt="" loading="lazy" width="1551" height="843" srcset="https://www.assemblyai.com/blog/content/images/size/w600/2022/06/guidance.png 600w, https://www.assemblyai.com/blog/content/images/size/w1000/2022/06/guidance.png 1000w, https://www.assemblyai.com/blog/content/images/2022/06/guidance.png 1551w" sizes="(min-width: 720px) 720px"/><figcaption>Comparison of unguided and guided GLIDE images generated by the prompt &#34;a religious place&#34; (<a href="https://arxiv.org/pdf/2112.10741.pdf">source</a>)</figcaption></figure><p>Although Classifier-Free Guidance was first introduced by <a href="https://openreview.net/pdf?id=qw8AKxfYbI">Ho and Salimans</a>, it was soon after notably used in OpenAI&#39;s <a href="https://arxiv.org/pdf/2112.10741.pdf">GLIDE</a> in order to create very high quality (albeit lower diversity) images. For a great resource on Classifier/Classifier-Free Guidance, check out <a href="https://benanne.github.io/2022/05/26/guidance.html">this </a>write-up.</p><p>According to Imagen&#39;s paper, <strong>Imagen depends critically on classifier-free guidance for effective text conditioning</strong>.</p><h3 id="large-guidance-weight-samplers">Large Guidance Weight Samplers</h3><p>Classifier-Free Guidance is a very powerful way to improve the caption alignment of generated images, but it has <a href="https://arxiv.org/pdf/2112.10741.pdf">been</a> <a href="https://arxiv.org/abs/2105.05233">previously</a> <a href="https://arxiv.org/abs/2204.06125">observed</a> that extremely high guidance weights damage fidelity by yielding saturated and unnatural images.</p><p>The Imagen authors investigate this phenomenon and find that it arises from a <strong>train-test mismatch</strong>. In particular, the pixel values for the training data are scaled to the range [-1, 1], but <strong>high guidance weights cause the network outputs to exceed these bounds</strong> at given timestep. To make matters worse, since the same model is iteratively applied to its own output during diffusion, this effect compounds as the diffusion process proceeds, leading even potentially to divergence.</p><p>High guidance weights are found to be crucial for achieving State-of-the-Art image quality, so avoiding the problem by simply using lower guidance weights is not an option. Instead, the authors address the problem by devising two methods to threshold pixel values - <strong>static thresholding</strong> and <strong>dynamic thresholding</strong>. These methods address the train-test mismatch noted above and dynamic thresholding in particular is found to be critical to Imagen&#39;s performance.</p><!--kg-card-begin: html--><h4>Static Thresholding</h4><!--kg-card-end: html--><p>In static thresholding, the pixel values at each timestep are simply clipped to the range [-1, 1]. This process can be visualized in the example below. </p><p>For the sale of example, let our pixel values be normally distributed. Applying static thresholding to these values means that any distribution weight that it outside of the pixel bounds (light red area) is pushed onto -1 for negative values and 1 for positive values. As we can see, as the variance of the distribution grows, the probability of being at an extreme value grows.</p><figure><div><video src="https://www.assemblyai.com/blog/content/media/2022/06/static_threshold.mp4" poster="https://img.spacergif.org/v1/2400x1168/0a/spacer.png" width="2400" height="1168" loop="" autoplay="" muted="" playsinline="" preload="metadata"></video><div><div><p><span>0:00</span></p><p>/<span></span></p></div></div></div><figcaption>Visualization of static thresholding. Distribution weight outside of the pixel bounds are pushed onto the pixel value extrema.</figcaption></figure><p>While this has some mitigating effect, images are unsurprisingly still oversaturated and less detailed as the guidance weight is increased. Therefore, the authors devised a better method of thresholding - dynamic thresholding.</p><!--kg-card-begin: html--><h4>Dynamic Thresholding</h4><!--kg-card-end: html--><p>With dynamic thresholding, a certain percentile absolute pixel value is chosen. At each timestep, if that percentile value <em>s</em> exceeds 1, then the pixel values are thresholded to [-<em>s</em>, <em>s</em>] and divided by <em>s</em>. This process can be visualized in the below video:</p><figure><div><video src="https://www.assemblyai.com/blog/content/media/2022/06/dynamic_threshold.mp4" poster="https://img.spacergif.org/v1/2400x1168/0a/spacer.png" width="2400" height="1168" loop="" autoplay="" muted="" playsinline="" preload="metadata"></video><div><div><p><span>0:00</span></p><p>/<span></span></p></div></div></div><figcaption>Visualization of dynamic thresholding. The distribution has a &#34;gravitational pull&#34; back towards 0, affecting all pixels and not just saturated ones.</figcaption></figure><p>Dynamic thresholding has the effect of bringing all pixel values back to the range [-1, 1], but operating on all pixels and not just those at the extreme. There is a &#34;gravitational pull&#34; back to 0 which balances the potential for divergence under an iteratively applied model.</p><p>The authors find that this method leads to much better photorealism and alignment, especially for large guidance weights.</p><p>It should be noted that this method is <em>asymmetric</em> - for images or datasets whose pixel values tend to be very low, dynamic thresholding will not be invoked given that a high percentile pixel value is unlikely to be greater than 1 (consider shifting the mean of the above distribution to the left). This fact is not noted in the Imagen paper, but it luckily does not seem to be an issue that affects Imagen&#39;s performance.</p><!--kg-card-begin: html--><h4>Comparison</h4><!--kg-card-end: html--><p>Below are several images depicting the effects of increasing the guidance weight for three models - one that is not thresholded, one that is statically thresholded, and one that is dynamically thresholded. Two distinct points (&#34;pt1&#34; and &#34;pt2&#34;) are shown for each model and are the same between models. For each model and each point, several images are shown corresponding to different guidance weights (the only change). </p><figure><img src="https://www.assemblyai.com/blog/content/images/2022/06/thresholding.png" alt="" loading="lazy" width="2000" height="1564" srcset="https://www.assemblyai.com/blog/content/images/size/w600/2022/06/thresholding.png 600w, https://www.assemblyai.com/blog/content/images/size/w1000/2022/06/thresholding.png 1000w, https://www.assemblyai.com/blog/content/images/size/w1600/2022/06/thresholding.png 1600w, https://www.assemblyai.com/blog/content/images/2022/06/thresholding.png 2297w" sizes="(min-width: 720px) 720px"/><figcaption>As the guidance weight is turned up (down each column), differences in quality can be observed based on thresholding method. (adapted from <a href="https://arxiv.org/pdf/2205.11487.pdf#page=20&amp;zoom=100,144,692">source</a>)</figcaption></figure><p>As we can see, static thresholding improves performance, at least yielding reasonable images for high guidance weights (even if saturated), unlike the unthresholded images which are almost completely black. Dynamic thresholding significantly improves performance, yielding reasonable and unsaturated images even to high guidance weights. While static and dynamic thresholding yield similar results at low guidance weights, differences in image saturation become more apparent at high guidance weights. These differences are especially evident when comparing the left columns of the two methods.</p><h2 id="super-resolution-models">Super-Resolution Models</h2><p>Recall that image generator Diffusion Model (or &#34;base model&#34;) outputs 64x64 images. Imagen uses two conditional diffusion models to bring the image up to 1024x1024 resolution. Let&#39;s inspect these models now.</p><h3 id="small-to-medium-architecture">Small-to-Medium Architecture</h3><p>The Small-to-Medium (STM) super-resolution model &#34;takes in&#34; (is conditioned on) the 64x64 image generated by the base model and super-resolves it to a 256x256 image. The STM model is yet another diffusion model, and is also conditioned on the caption encoding in addition to the low-resolution image. Cross-attention is implemented similarly to the base model.</p><p>The architecture of the STM model is another U-Net, again adapted from <a href="https://arxiv.org/abs/2102.09672">Nichol and Dhariwal</a> like the Image Generator. The authors make several modifications to the model to improve memory efficiency, inference time, and convergence speed. They call this model <em>Efficient U-Net</em>, which is 2-3 times faster in steps/second than the unmodified version.</p><!--kg-card-begin: html--><div data-template="accordion">
  <header>
    <p>Additional Details</p>
  </header>
	<div>
    <p>Efficient U-Net makes the following modifications:</p>
        <ol>
            <li>
                <b>Shifting Model Parameters:</b> The model parameters are shifting from high-resolution blocks to low-resolution blocks by adding more residual blocks at lower dimensions. Since these blocks have more channels, the model capacity is increased without severe memory/computation costs.
            </li>
            <li>
                <b>Scaling Skip Connections:</b> With the larger number of residual blocks at the lower resolutions, the skip connections are scaled by 1/sqrt(2) to improve convergence speed.
            </li>
            <li>
                <b>Changing Order of Operations:</b> In the downsampling blocks, they change the order of the downsampling and convolution operations such that convolution happens after the downsampling operation, and vice versa for the upsampling blocks. This improves forward pass speed with no performance degredation.
            </li>
        </ol>
  </div>
</div>
   <!--kg-card-end: html--><h3 id="medium-to-large-architecture">Medium-to-Large Architecture</h3><p>The Medium-to-Large (MTL) super-resolution model super-resolves the 256x256 image generated by the STM model to a 1024x1204 image. The MTL model is very similar to the STM model, being a diffusion model that is conditioned on the caption encoding and the STM output image.</p><p>The architecture is generally similar to the STM model except that the self-attention layers are removed. Since there are no self-attention layers in this model, explicit cross-attention layers are added to attend over the text embeddings in contrast to the base and STM models.</p><h3 id="robust-cascaded-diffusion-models">Robust Cascaded Diffusion Models</h3><p>Imagen uses noise conditioning augmentation in the super-resolution models in order to make them aware of the amount of noise added. This conditioning improves sample quality and the ability of the models to handle artifacts resulting from the lower resolution models. The <strong>authors find this approach to be critical for generating high fidelity images</strong>.</p><p>The noise conditioning augmentation works by corrupting the low-resolution image upon which the super-resolution model is conditioned with Gaussian noise, and then conditioning the super-resolution model in addition on the corruption noise level. During training, the corruption noise level, or &#34;augmentation level&#34;, is chosen randomly, whereas during inference this value is swept over to find the best sample quality.</p><p>The pseudocode for these processes can be seen below, where the authors are utilizing the JAX package.</p><figure><img src="https://www.assemblyai.com/blog/content/images/2022/06/image-16.png" alt="" loading="lazy" width="1576" height="440" srcset="https://www.assemblyai.com/blog/content/images/size/w600/2022/06/image-16.png 600w, https://www.assemblyai.com/blog/content/images/size/w1000/2022/06/image-16.png 1000w, https://www.assemblyai.com/blog/content/images/2022/06/image-16.png 1576w" sizes="(min-width: 720px) 720px"/><figcaption>(<a href="https://arxiv.org/pdf/2205.11487.pdf#page=44&amp;zoom=100,144,324">source</a>)</figcaption></figure><!--kg-card-begin: html--><!--kg-card-end: html--><h2 id="deep-dive-summary">Deep Dive Summary</h2><p>To summarize, the input caption is fed into a T5 encoder, which is frozen during training. The text encoding conditions a base Diffusion Model, which uses a U-Net with self-attention layers at low resolutions to generate an image. The text encoding conditioning happens via addition to the timestep conditioning tensor (&#34;positional encoding&#34;), and via cross-attention through key-value concatenation to the self-attention layers. Dynamic thresholding and classifier-free guidance are implemented.</p><p>After the base model image has been generated, it is passed through two more Diffusion Models for super-resolution, which are conditioned on the images that they are upsampling in addition to conditioning on the timestep and text encoding. These models use noise conditioning augmentation to improve quality and remove artifacts.</p><p>The result is a 1024x1024 image that matches the input caption.</p><h2 id="results-and-analysis">Results and Analysis</h2><h3 id="quantitative">Quantitative</h3><p>COCO is a dataset used to evaluate text-to-image models, with FID used to measure image fidelity and CLIP used to measure image-caption alignment. The authors find that<strong> Imagen achieves a State-of-the-Art zero-shot FID of 7.27 </strong>on COCO, outperforming DALL-E 2 and even models that were <em>trained </em>on COCO.</p><h3 id="qualitative">Qualitative</h3><p>The authors note that both FID and CLIP have limitations. FID is not fully aligned with human perceptual quality, and CLIP is ineffective at counting. Therefore, they use human evaluation to assess quality and caption similarity, with 200 ground-truth caption-image pairs chosen at random from the COCO validation set used as a baseline. Subjects were shown batches of 50 of these images.</p><!--kg-card-begin: html--><div data-template="accordion">
  <header>
    <p>Quality Control</p>
  </header>
	<p>Interleaved &#34;control&#34; trials were also used, and rater data was only included if the rater answered at least 80% of the control questions correctly. This netted 73 ratings per image for image quality and 51 ratings per image for image-caption alignment.</p>
</div>
   <!--kg-card-end: html--><!--kg-card-begin: html--><h4>Quality</h4><!--kg-card-end: html--><p>To probe the quality of Imagen&#39;s generated images, the human rater is asked to select between Imagen&#39;s generated image and a reference image using the question &#34;<em>Which image is more photorealistic (looks more real)?</em>&#34;. The percentage of times raters choose Imagen&#39;s generated image over the reference image, called the <strong>preference rate</strong> is reported.</p><p><strong>Imagen achieves a preference rate of 39.2% for photorealism.</strong></p><!--kg-card-begin: html--><h4>Caption Similarity</h4><!--kg-card-end: html--><p>To probe image-caption alignment, the rater is shown an image and a caption and asked &#34;<em>Does the caption accurately describe the above image?</em>&#34;. The rater must respond with &#34;<em>yes</em>&#34;, &#34;<em>somewhat</em>&#34;, or &#34;<em>no</em>&#34;. The responses are scored as 100, 50, and 0 respectively and obtained independently for model samples and references images, with both being reported.</p><p><strong>The authors find that Imagen is on-par with original reference images for caption similarity</strong>.</p><!--kg-card-begin: html--><h4>DrawBench</h4><!--kg-card-end: html--><p>Noting several shortcomings of COCO, the authors also introduce <strong>DrawBench </strong>- a comprehensive and challenging set of prompts that is intended to support the evaluation and comparison of text-to-image models.</p><p>Below the results of comparing Imagen to DALL-E 2, GLIDE, VQGAN+CLIP, and Laten Diffusion on DrawBench are shown, where the bar heights correspond to user preference rates (with 95% confidence intervals) for both image fidelity and alignment. <strong>It is easy to see that Imagen outperforms all other models</strong>.</p><figure><img src="https://www.assemblyai.com/blog/content/images/2022/06/image-18.png" alt="" loading="lazy" width="2000" height="613" srcset="https://www.assemblyai.com/blog/content/images/size/w600/2022/06/image-18.png 600w, https://www.assemblyai.com/blog/content/images/size/w1000/2022/06/image-18.png 1000w, https://www.assemblyai.com/blog/content/images/size/w1600/2022/06/image-18.png 1600w, https://www.assemblyai.com/blog/content/images/2022/06/image-18.png 2156w" sizes="(min-width: 720px) 720px"/></figure><h3 id="why-is-imagen-better-than-dall-e-2">Why is Imagen Better than DALL-E 2?</h3><p>Answering exactly <em>why</em> Imagen is better than DALL-E 2 is difficult; however, a non-negligible portion of the performance gap seems to stem from the differences in how the two models encode the caption/prompt.</p><p>DALL-E 2 uses a contrastive objective to determine how related a text encoding is to an image (essentially CLIP). The text and image encoders tune their parameters such that the cosine similarities of like caption-image pairs are maximized, while the cosine similarities of differing caption-image pairs are minimized. While this objective is very intuitive in the text-to-image domain, especially in reflection of the usage of the prior sub-model in DALL-E 2, what shortcomings does it have? We see three potential options.</p><!--kg-card-begin: html--><h4>Sheer Size</h4><!--kg-card-end: html--><p>It may very well be that a notable portion of the performance gap stems from the fact that Imagen&#39;s text encoder is much larger than that of DALL-E 2&#39;s and is trained on more data. As evidence of this hypothesis, we can inspect the performance of Imagen as the text encoder is scaled up. Below we see pareto curves of Imagen&#39;s performance as a function of both encoder size as U-Net size. </p><figure><img src="https://www.assemblyai.com/blog/content/images/2022/06/image-22.png" alt="" loading="lazy" width="1408" height="575" srcset="https://www.assemblyai.com/blog/content/images/size/w600/2022/06/image-22.png 600w, https://www.assemblyai.com/blog/content/images/size/w1000/2022/06/image-22.png 1000w, https://www.assemblyai.com/blog/content/images/2022/06/image-22.png 1408w" sizes="(min-width: 720px) 720px"/></figure><p>The effect of scaling up the text encoder is shockingly high, and that of scaling up the U-Net is shockingly low. This result suggests that relatively simple diffusion models can produce high-quality results <strong>as long as they are conditioned on powerful encodings</strong>. </p><p>Given that the T5 text encoder is so much larger than the CLIP text encoder, combined with the fact that natural language training data is necessarily more plentiful than image-caption pairs, much of the performance gap may be attributable to this difference, a fact which the Imagen authors note.</p><!--kg-card-begin: html--><h4>The Image Encoder Crutch</h4><!--kg-card-end: html--><p>During CLIP training, both the text encoder and image encoder are tuned to satisfy the demands of the objective function. It is possible that there is a degree of freedom in how much each of these models are tuned in order to satisfy these demands. In particular, it may be the case that the image encoder in CLIP learns to produce richer encodings more quickly than the text encoder, adapting to the relatively lower performance of the text encoder. This would have the effect of lowering loss overall but simultaneously acting as a crutch to the text encoder. This crutch may lower the expressive power of the text encoder, leading to lower performance when repurposed for the purposes of DALL-E 2.</p><p>This observation is somewhat unintuitive. CLIP yields a space in which textual and visual manifestations of the same concepts are understood and mapped between with the prior in DALL-E 2. On the other hand, the responsibility of mapping textual encodings to visual concepts is put on the shoulders of the image generator in Imagen. Nevertheless, it may be the case that a weakened &#34;starting point&#34; for the prior in DALL-E 2 lowers the effectiveness of the prior, which ultimately propagates to the image generation sub-model.</p><!--kg-card-begin: html--><h4>Similar Concepts in Different Data Points</h4><!--kg-card-end: html--><p>The next potential shortcoming of the CLIP text-encoding method is that the blanket objective of maximizing the cosine similarity of corresponding caption-image pairs while minimizing that of differing ones <em>does not account for similar concepts in distinct data points</em>. In particular, if two captions are very similar, they will properly be mapped to similar vectors, <strong>but the CLIP objective will push these vectors apart</strong>. To make matters worse, they will be pushed just as much apart as either of them together with a highly dissimilar caption vector. This penalty has the potential to weaken the learned encodings depending on the nature of the training dataset. Given the importance of the text encodings to text-to-image diffusion models, this behavior may weaken the quality of generated images.</p><p>While any of these factors may contribute to the performance gap, there are certainly other implementation details of Imagen that are relevant to our analysis, some of which are listed below in the &#34;Key Takeaways&#34; section.</p><h3 id="key-takeaways">Key Takeaways</h3><p>Above notes regarding DALL-E 2 aside, the authors list several key takeaways from Imagen, including the following:</p><ol><li><strong>Scaling the text encoder is very effective</strong></li><li><strong>Scaling the text encoder is more important than U-Net size</strong></li><li><strong>Dynamic thresholding is critical</strong></li><li><strong>Noise conditioning augmentation in the super-resolution models is critical</strong></li><li><strong>Text conditioning via cross attention is critical</strong></li><li><strong>Efficient U-Net is critical</strong></li></ol><p>These insights provide valuable direction for other researchers who are working on Diffusion Models and are not useful only in the text-to-image subdomain.</p><h2 id="final-words">Final Words</h2><p>Imagen&#39;s results speak for themselves and mark another great success in the area text-to-image generation and generative modelling more generally. Imagen also adds to the list of the great accomplishments of Diffusion Models, which have taken the Machine Learning world by storm over the past few years with a string of absurdly impressive results.</p><p>Check out our article on <a href="https://www.assemblyai.com/blog/diffusion-models-for-machine-learning-introduction/">Diffusion Models</a> to learn more about them, or check out our article on <a href="https://www.assemblyai.com/blog/how-dall-e-2-actually-works/">DALL-E 2</a> to learn more about the previous king of text-to-image generation. Otherwise, feel free to follow our newsletter to stay in-the-loop for future articles like this.</p><!--kg-card-begin: html--><!--kg-card-end: html-->
    </section></div>
  </body>
</html>
