<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lwn.net/SubscriberLink/914458/a6d5816bad1890e4/">Original</a>
    <h1>Rust in the 6.2 kernel</h1>
    
    <div id="readability-page-1" class="page"><p>

<h2>[LWN subscriber-only content]</h2>
</p><div>
<!-- $Id: slink-none,v 1.2 2005-11-04 22:11:18 corbet Exp $ -->
<blockquote>
<div>
<h3>Welcome to LWN.net</h3>
<p>
The following subscription-only content has been made available to you 
by an LWN subscriber.  Thousands of subscribers depend on LWN for the 
best news from the Linux and free software communities.  If you enjoy this 
article, please consider <a href="https://lwn.net/subscribe/">subscribing to LWN</a>.  Thank you
for visiting LWN.net!
</p></div>
</blockquote>
<p>
The merge window for the 6.1 release brought in <a href="https://lwn.net/Articles/910762/">basic support</a> for writing kernel code in Rust
— with an emphasis on &#34;basic&#34;.  It is possible to create a &#34;hello world&#34;
module for 6.1, but not much can be done beyond that.  There is, however, a
lot more Rust code for the kernel out there; it&#39;s just waiting for its turn to be
reviewed and merged into the mainline.  Miguel Ojeda has now posted <a href="https://lwn.net/ml/linux-kernel/20221110164152.26136-1-ojeda@kernel.org/">the next
round</a> of Rust patches, adding to the support infrastructure in the
kernel.
</p><p>
This 28-part patch series is focused on low-level support code, still
without much in the way of abstractions for dealing with the rest of the
kernel.  There will be no shiny new drivers built on this base alone.  But
it does show another step toward the creation of a workable environment for
the development of code in the Linux kernel.
</p><p>
As an example of how stripped-down the initial Rust support is, consider
that the kernel has <a href="https://docs.kernel.org/next/core-api/printk-basics.html">eight
different logging levels</a>, from &#34;debug&#34; through &#34;emergency&#34;.  There is a
macro defined for each level to make printing simple; screaming about an
imminent crash can be done with <tt>pr_emerg()</tt>, for example.  The Rust
code in 6.1 defines equivalent macros, but only two of them:
<a href="https://elixir.bootlin.com/linux/v6.1-rc5/source/rust/kernel/print.rs#L151"><tt>pr_info!()</tt>
and <tt>pr_emerg!()</tt></a>; the macros for the other log 
levels were left out.  The first order of business
for 6.2 appears to be to fill in the rest of the set, from
<tt>pr_debug!()</tt> at one end through <tt>pr_alert!()</tt> at the other.
There is also <tt>pr_cont!()</tt> for messages that are pieced together
from multiple calls.
<a href="https://lwn.net/ml/linux-kernel/20221110164152.26136-5-ojeda@kernel.org/">This
sample kernel module</a> shows all of the print macros in action.
</p><p>
A rather more complex macro added in this series is <tt>#[vtable]</tt>.
The kernel makes extensive use of structures full of pointers to functions;
these structures are at the core of the kernel&#39;s object model.  A classic
example is <a href="https://elixir.bootlin.com/linux/latest/source/include/linux/fs.h#L2093"><tt>struct
file_operations</tt></a>, which is used to provide implementations of the
many things that can be done with an open file.  The functions found
therein vary from relatively obvious operations like <tt>read()</tt> and
<tt>write()</tt> through to more esoteric functionality like
<tt>setlease()</tt> or <tt>remap_file_range()</tt>.  Anything in the kernel
that can be represented as an open file provides one of these structures to
implement the operations on that file.
</p><p>
Operations structures like <tt>file_operations</tt> thus look a lot like
<a href="https://doc.rust-lang.org/book/ch10-02-traits.html">Rust
traits</a>, and they can 
indeed be modeled as traits in Rust code.  But the kernel allows any given
implementation to leave out any functions that are not relevant; a
<tt>remap_file_range()</tt> operation will make no sense in most device
drivers, for example.  In the kernel&#39;s C code, missing operations are
represented by a null pointer; code that calls those operations will detect
the null pointer and execute a default action instead.  Null pointers,
though, are the sort of thing that the Rust world goes out of its way to
avoid, so representing an operations structure in Rust requires some extra
work. 
</p><p>
The <tt>#[vtable]</tt> macro is intended to perform the necessary impedance
matching between C operations structures and Rust traits.  Both the
declaration of a trait and of any implementations will use this macro, so a
trait definition will look like:
</p><pre>    #[vtable]
    pub trait Operations {
        /// Corresponds to the `open` function pointer in `struct file_operations`.
    	fn open(context: &amp;Self::OpenData, file: &amp;File) -&gt; Result&lt;Self::Data&gt;;
    // ...
    }
</pre>
<p>
While an implementation for a specific device looks like:
</p><pre>    #[vtable]
    impl kernel::file::Operations for some_driver {
        fn open(_data: &amp;(), _file: &amp;File) -&gt; Result {
            Ok(())
        }
	// ...
    }
</pre>
<p>
If this implementation is to be passed into the rest of the kernel, it must
be turned into the proper C structure.  Rust can create the structure, but
it is hard-put to detect which operations have been implemented and which
should, instead, be represented by a null pointer.  The <tt>#[vtable]</tt>
macro helps by generating a special constant member for each defined
function; in the above example, the <tt>some_driver</tt> type would have a
constant <tt>HAS_OPEN</tt> member set to <tt>true</tt>.  The code that
generates the C operations structure can query those constants (at compile
time) and insert null pointers for missing operations; the details of how
that works can be seen in <a href="https://lwn.net/ml/linux-kernel/20221110164152.26136-7-ojeda@kernel.org/">this
patch</a>.
</p><p>
The submission for 6.2 adds <tt>#[vtable]</tt> but does not include any
uses of it.  The curious can see it in use by looking at <a href="https://lwn.net/ml/linux-kernel/20220802015052.10452-18-ojeda@kernel.org/">this
large patch</a> posted in August; searching for <tt>#[vtable]</tt> and
<tt>HAS_</tt> will turn up the places where this infrastructure is used.
</p><p>
Yet another new macro is <tt>declare_err!()</tt>, which can be used to
declare the various error-code constants like <tt>EPERM</tt>.  The 6.2
kernel will likely include <a href="https://lwn.net/ml/linux-kernel/20221110164152.26136-10-ojeda@kernel.org/">a full
set of error codes</a> declared with this macro rather than the minimal set
included in 6.1.  There is also <a href="https://lwn.net/ml/linux-kernel/20221110164152.26136-11-ojeda@kernel.org/">a
mechanism</a> to translate many internal Rust error into Linux error codes.
</p><p>
The Rust <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><tt>Vec</tt>
type</a> implements an array that will grow as needed to
hold whatever is put into it.  Growing, of course, involves memory
allocation, which can fail in the kernel.  In 6.2, <tt>Vec</tt> as
implemented in the kernel will likely have two methods called
<tt>try_with_capacity()</tt> and <tt>try_with_capacity_in()</tt>.  They act
like the standard <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.with_capacity"><tt>with_capacity()</tt></a>
and <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.with_capacity_in"><tt>with_capacity_in()</tt></a> 
<tt>Vec</tt> methods in that they preallocate memory for data to be stored
later, but with the difference that they can return a failure 
code.  The <tt>try_</tt> variants will allow kernel code to attempt to
allocate <tt>Vec</tt>s of
the needed size and do the right thing if the allocation fails, rather than
just calling <tt>panic()</tt> like the standard versions do.
</p><p>
One of the more confusing aspects of Rust for a neophyte like your editor
is the existence of two string types: <a href="https://doc.rust-lang.org/std/primitive.str.html"><tt>str</tt></a>
and <a href="https://doc.rust-lang.org/std/string/struct.String.html"><tt>String</tt></a>;
the
former represents a borrowed reference to a string stored elsewhere, while
the latter actually owns the string.  The kernel&#39;s Rust support will define
two variants of those, called <a href="https://lwn.net/ml/linux-kernel/20221110164152.26136-17-ojeda@kernel.org/"><tt>CStr</tt></a>
and <a href="https://lwn.net/ml/linux-kernel/20221110164152.26136-22-ojeda@kernel.org/"><tt>CString</tt></a>,
which 
serve the same function for C strings.  Specifically, they deal with a
string that is represented as an array of bytes and terminated with a
<tt>NUL</tt> character.  Rust code that passes strings into the rest of the
kernel will need to use these types.
</p><p>
The series ends with a grab-bag of components that will be useful for
future additions.  The <a href="https://lwn.net/ml/linux-kernel/20221110164152.26136-24-ojeda@kernel.org/"><tt>dbg!()</tt>
macro</a> makes certain types of debugging easier.  There is <a href="https://lwn.net/ml/linux-kernel/20221110164152.26136-25-ojeda@kernel.org/">code for
compile-time assertions</a> and to <a href="https://lwn.net/ml/linux-kernel/20221110164152.26136-26-ojeda@kernel.org/">force
build errors</a>.  The <a href="https://lwn.net/ml/linux-kernel/20221110164152.26136-28-ojeda@kernel.org/"><tt>Either</tt>
type</a> can hold an object that can be either one of two distinct types.
Finally, the <a href="https://lwn.net/ml/linux-kernel/20221110164152.26136-29-ojeda@kernel.org/"><tt>Opaque</tt>
type</a> is for structures used by the kernel that are never accessed by
Rust code.  Using this type can improve performance by removing the need to
zero-initialize the memory holding it before calling the initialization
function.
</p><p>
As can be seen, these patches are slowly building the in-kernel Rust code
up so that real functionality can be implemented in Rust, but this process
has some ground to cover yet.  It&#39;s not clear whether more Rust code will
be proposed for 6.2, or whether this is the full set.  The pace of change
may seem slow to developers who would like to start doing real work in
Rust, but it does have the advantage of moving in steps that can be
understood — and reviewed — by the kernel community.  The Rust-for-Linux
work has been underway for a few years already; getting up to full
functionality may well take a while longer yet.<br clear="all"/></p><table>
           <tbody><tr><th colspan="2">Index entries for this article</th></tr>
           <tr><td><a href="https://lwn.net/Kernel/Index">Kernel</a></td><td><a href="https://lwn.net/Kernel/Index#Development_tools-Rust">Development tools/Rust</a></td></tr>
            </tbody></table></div></div>
  </body>
</html>
