<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://sites.google.com/view/elizagen-org/eliza-is-turing-complete">Original</a>
    <h1>ELIZA is Turing Complete</h1>
    
    <div id="readability-page-1" class="page"><div role="main" tabindex="-1" dir="ltr"><section id="h.383899e7b0e44c4d_4"><div><div tabindex="-1"><div><div><div jscontroller="sGwD4d" jsaction="zXBUYb:zTPCnb;zQF9Uc:Qxe3nd;" jsname="F57UId"><div><div id="h.383899e7b0e44c4d_1"><div><div><p dir="ltr"><span>ELIZA is Turing Complete</span></p><p dir="ltr"><span>by Anthony Hay and Peter Millican (Professor of Philosophy, Hertford College, University of Oxford)</span></p><p dir="ltr"><span>L</span><span>ast updated 2022-1</span><span>1</span><span>-1</span><span>4</span><span>; </span><span>Originally published 2022-11-12</span></p><p dir="ltr"><span>ELIZA is </span><span><em>Turing complete</em></span><span>. In other words, any possible Turing machine program can be implemented by a suitable ELIZA script, conforming to the specification given by Joseph Weizenbaum in his famous 1966 CACM paper. </span></p><p dir="ltr"><span>This does not, of course, mean that every possible Turing machine program could in practice have been executed on Weizenbaum’s software and hardware in 1966, for both would have had finite capacity (whereas a Turing machine tape is potentially of infinite length). But the syntax of his ELIZA rule-set involves no relevant restriction – for example, there is no specified limit on list size – and hence enables the expression of textual transformations that are sufficient to replicate the abstract processing of any arbitrary Turing machine. So any (terminating) Turing machine program can be executed by an ELIZA script consisting of such transformations, if run on software that faithfully implements Weizenbaum’s specification, and on hardware of sufficient capacity.</span></p><p dir="ltr"><span>The parenthetical restriction above, to </span><span><em>terminating</em></span><span> Turing machine programs, does not reflect any limitation of ELIZA. For example, the computing machines in Turing’s original 1936 article were designed to write potentially infinite sequences of binary digits onto a tape, going on and on without ever stopping. Clearly this would be beyond the practical representational capacity of </span><span><em>any</em></span><span> physical hardware, no matter how the Turing machine was implemented.</span></p><h2 id="h.eq5tgmfsqow8_l" dir="ltr" tabindex="-1"><div jscontroller="Ae65rd" jsaction="touchstart:UrsOsc; click:KjsqPd; focusout:QZoaZ; mouseover:y0pDld; mouseout:dq0hvd;fv1Rjc:jbFSOd;CrfLRd:SzACGe;"><p><span>The Significance of Turing Completeness</span></p></div></h2><p dir="ltr"><span>Turing completeness is significant because it appears that </span><span><em>any effectively calculable function can be computed by some Turing machine</em></span><span>. This is known as the Church-Turing Thesis, for which Turing gave powerful arguments in §9 and §10 of his 1936 paper, though it is not strictly provable because of the vagueness of “effectively calculable”. So the fact that ELIZA can implement any Turing machine implies that an ELIZA script can, in principle, be created to calculate anything that we know how to calculate!</span></p><p dir="ltr"><span>Amongst these possibilities, an ELIZA script can be created to implement a “Universal Turing Machine” (UTM), which can itself execute any Turing machine program (after the desired program has been suitably encoded and given as input to the ELIZA script). This is not of any serious </span><span><em>practical </em></span><span>use, since it would be </span><span><em>hugely </em></span><span>inefficient! But it is </span><span><em>theoretically</em></span><span> interesting that ELIZA, as defined by Weizenbaum, has such computational power </span><span><em>in principle</em></span><span>.</span></p><h2 id="h.n4cn27msuqrq_l" dir="ltr" tabindex="-1"><div jscontroller="Ae65rd" jsaction="touchstart:UrsOsc; click:KjsqPd; focusout:QZoaZ; mouseover:y0pDld; mouseout:dq0hvd;fv1Rjc:jbFSOd;CrfLRd:SzACGe;"><p><span>The Structure and Operation of a Turing Machine</span></p></div></h2><p dir="ltr"><span>A Turing Machine consists of a long tape divided into squares, onto which symbols can be written and later erased, together with a read/write head (as in a tape recorder) which can write (or erase) symbols and also read them. Such reading and writing can only take place on the particular square where the read/write head is placed, but the head is capable of moving – one square at a time – in either direction. So by moving repeatedly left or right, any square on the tape can eventually be reached if required. (And the tape is potentially infinite in length: new tape is created whenever necessary so that the head never runs out of space.) Each square can contain at most one symbol, so writing a new symbol on a square automatically erases any previous symbol.</span></p><p dir="ltr"><span>In order to &#34;remember what it is doing&#34;, the Turing Machine has a very limited memory in the form of a &#34;state&#34;, which can take any of a specified – and finite – range of values. One of these is the beginning state, from which computation starts. Computation then proceeds in the following way:</span></p><ol><li dir="ltr"><p dir="ltr"><span>Read symbol from current square</span></p></li><li dir="ltr"><p dir="ltr"><span>Depending on the symbol read, and the current state:</span></p></li></ol><ol><li dir="ltr"><p dir="ltr"><span>Erase the symbol, or write a new one;</span></p></li><li dir="ltr"><p dir="ltr"><span>Move left or right on the tape;</span></p></li><li dir="ltr"><p dir="ltr"><span>Change to a new state.</span></p></li></ol><p dir="ltr"><span>Stage 2 here is governed by a &#34;machine table&#34; which states what operations (a), (b) and (c) are to be carried out for each combination of symbol read and current state. For a video showing a Turing machine in action (in the context of a discussion of their significance) see the first talk at<a href="https://www.google.com/url?q=https%3A%2F%2Fwww.philocomp.net%2Fvideos%2Fturing.htm&amp;sa=D&amp;sntz=1&amp;usg=AOvVaw06WG_Eq02J8v4FdxX9PS7L" target="_blank"> </a></span><span><a href="https://www.google.com/url?q=https%3A%2F%2Fwww.philocomp.net%2Fvideos%2Fturing.htm&amp;sa=D&amp;sntz=1&amp;usg=AOvVaw06WG_Eq02J8v4FdxX9PS7L" target="_blank">https://www.philocomp.net/videos/turing.htm</a></span><span>. [</span><span>See also<a href="https://www.google.com/url?q=https%3A%2F%2Fwww.philocomp.net%2Fcomputing%2Fturing1936.htm&amp;sa=D&amp;sntz=1&amp;usg=AOvVaw1MiIZ8sa4b7dblcAnlcj9f" target="_blank"> </a></span><span><a href="https://www.google.com/url?q=https%3A%2F%2Fwww.philocomp.net%2Fcomputing%2Fturing1936.htm&amp;sa=D&amp;sntz=1&amp;usg=AOvVaw1MiIZ8sa4b7dblcAnlcj9f" target="_blank">https://www.philocomp.net/computing/turing1936.htm</a></span><span>, from which the Turing machine description above is taken.]</span></p><h2 id="h.p2px3jzf89cx_l" dir="ltr" tabindex="-1"><div jscontroller="Ae65rd" jsaction="touchstart:UrsOsc; click:KjsqPd; focusout:QZoaZ; mouseover:y0pDld; mouseout:dq0hvd;fv1Rjc:jbFSOd;CrfLRd:SzACGe;"><p><span>How to Implement a Turing Machine as an ELIZA Script</span></p></div></h2><p dir="ltr"><span>ELIZA is well suited for straightforward implementation of a Turing machine, because it operates by transforming text strings, and a text string provides a natural representation of a Turing machine tape. Since ELIZA operates at the level of words, we represent each Turing machine symbol as a word, with spaces as separators between them, and we represent any blank square as an underscore “_”. In addition, we need to represent the current position of the read/write head on the tape, which can be done by using an asterisk “*” on each side of the relevant symbol (again separated by spaces) </span><span>[</span><span>Or we could use distinct symbols for the left and right of the current square, for example “[“ and “]”.]</span></p><p dir="ltr"><span>Turing machine </span><span><em>states </em></span><span>are represented by ELIZA </span><span><em>keywords</em></span><span>, and transitions between states are implemented as (potentially recursive) transitions from one keyword to another using the “PRE” operator as described in Weizenbaums’s paper.  Let us now turn to see how this works in detail.</span></p><p dir="ltr"><span>The general form of text transformation rules in an ELIZA script is</span></p><p dir="ltr"><span>(keyword</span></p><p dir="ltr"><span>	</span><span>((decomposition rule 1)</span></p><p dir="ltr"><span>(reassembly rule 1.1)</span></p><p dir="ltr"><span>(reassembly rule 1.2)</span></p><p dir="ltr"><span>(…))</span></p><p dir="ltr"><span>	</span><span>((decomposition rule 2)</span></p><p dir="ltr"><span>(reassembly rule 2.1)</span></p><p dir="ltr"><span>(reassembly rule 2.2)</span></p><p dir="ltr"><span>(…))</span></p><p dir="ltr"><span>	</span><span>…)</span></p><p dir="ltr"><span>Text entered by the user is tested …</span><span>[Possibly Say more about how keywords are identified and selected]</span></p><p dir="ltr"><span>When a keyword is selected the decomposition rules are tried, in order, against the input text. The first decomposition rule that successfully matches the input text is selected and one of the associated reassembly rules is used to form ELIZA’s response to the input text. (If there are multiple reassembly rules associated with a given decomposition rule they are cycled through on successive decomposition rule matches.)</span></p><p dir="ltr"><span>One of the reassembly rules allowed in an ELIZA script is called PRE. Joseph Weizenbaum describes this rule in his 1966 CACM paper:</span></p><p dir="ltr"><span><em>Under still other conditions it may be desirable to perform a preliminary transformation on the input text before subjecting it to the decompositions and reassemblies which finally yield the output text. For example, the keyword “you’re” should lead to the transformation rules associated with “you” but should first be replaced by a word pair. The dictionary entry for “you’re” is therefore:</em></span></p><p dir="ltr"><span><em>(“you’re&#34; = I’m ((0 I’m 0) (PRE (I AM 3) (=YOU))))</em></span></p><p dir="ltr"><span><em>which has the following effect:</em></span></p><ol><li dir="ltr"><p dir="ltr"><span><em>Whenever “you’re” is found in the input text, it is replaced by “I’m”.</em></span></p></li><li dir="ltr"><p dir="ltr"><span><em>If “you’re” is actually selected as the regnant keyword, then the input text is decomposed into three constituent parts, namely, all text in front of the first occurrence of “I’m”, the word “I’m” itself, and all the text following the first occurrence of “I’m”.</em></span></p></li><li dir="ltr"><p dir="ltr"><span><em>The reassembly rule beginning with the code “PRE” is encountered and the decomposed text reassembled such that the words “I AM” appear in front of the third constituent determined by the earlier decomposition.</em></span></p></li><li dir="ltr"><p dir="ltr"><span><em>Control is transferred, so to speak, to the transformation rules associated with the keyword “you”, where further decompositions etc. are attempted.</em></span></p></li></ol><p dir="ltr"><span><em>It is to be noted that the set</em></span></p><p dir="ltr"><span><em>(PRE (I AM 3) (=YOU))</em></span></p><p dir="ltr"><span><em>Is logically in the place of a reassembly rule and may therefore be one of many reassembly rules associated with the given decomposition.</em></span></p><p dir="ltr"><span>(Weizenbaum, 1966, page 41)</span></p><p dir="ltr"><span>Given these tools we can construct a Turing machine as follows:</span></p><ol><li dir="ltr"><p dir="ltr"><span>The “tape” is the input list of words. Each word is a “cell” on the tape.</span></p></li><li dir="ltr"><p dir="ltr"><span>The current position of the Turing machine “head” is marked by symbols that are not part of the Turing machine alphabet, one either side of the current head position. We use asterisks in the example below.</span></p></li><li dir="ltr"><p dir="ltr"><span>States are encoded as keywords. Each state (keyword) has one decomposition rule for each possible symbol under the head. The decomposition rule will match the tape only when the particular symbol is under the head (between the asterisks). The associated reassembly rule is a PRE rule that rewrites the tape according to the required change to the symbol, if any, and moves the head, if a move is required. Finally, the PRE rule tells ELIZA to continue processing the tape with the specified keyword, thus changing to a new state, if required.</span></p></li><li dir="ltr"><p dir="ltr"><span>Each state begins by extending the tape to the left and right, if necessary, by appending an empty cell. The state is unchanged. The tape is extended only when there is no cell before (or after) the current head position. This makes the tape effectively infinite.</span></p></li></ol><p dir="ltr"><span>Here is a complete ELIZA script. It encodes a Turing Machine to decide whether the user’s input text is a palindrome. (This and other examples from Turing&#39;s paper and execution traces are at: </span><span><a href="https://www.google.com/url?q=https%3A%2F%2Fgithub.com%2Fjeffshrager%2Felizagen.org%2Ftree%2Fmaster%2FTuringCompleteness&amp;sa=D&amp;sntz=1&amp;usg=AOvVaw3oIRSDj6XP5_8DzC6jYYki" target="_blank">https://github.com/jeffshrager/elizagen.org/tree/master/TuringCompleteness</a></span><span>, and Anthony Hay&#39;s ELIZA is here: </span><span><a href="https://www.google.com/url?q=https%3A%2F%2Fgithub.com%2Fanthay%2FELIZA&amp;sa=D&amp;sntz=1&amp;usg=AOvVaw3j6P-yTnjhyhpNerlriiLE" target="_blank">https://github.com/anthay/ELIZA</a></span><span>)</span></p><p dir="ltr"><span>(ELIZA CAN DECIDE IF A STRING OF LETTERS IS A PALINDROME.</span></p><p dir="ltr"><span> TYPE THE WORD PALP FOLLOWED BY A STRING OF A AND B LETTERS,</span></p><p dir="ltr"><span> WITH SPACES BETWEEN EACH LETTER. ELIZA WILL RESPOND TRUE IF</span></p><p dir="ltr"><span> THE STRING IS A PALINDROME, OTHERWISE ELIZA RESPONDS FALSE.</span></p><p dir="ltr"><span> EG. TYPE PALP A B B A AND ELIZA WILL RESPOND TRUE.)</span></p><p dir="ltr"><span>(PALP</span></p><p dir="ltr"><span>    ((PALP)</span></p><p dir="ltr"><span>        (PRE (* _ *) (=Q0)))    ; position head at empty cell</span></p><p dir="ltr"><span>    ((PALP A 0)</span></p><p dir="ltr"><span>        (PRE (* A * 3) (=Q0)))  ; position head at first A</span></p><p dir="ltr"><span>    ((PALP B 0)</span></p><p dir="ltr"><span>        (PRE (* B * 3) (=Q0)))  ; position head at first B</span></p><p dir="ltr"><span>    ((0)</span></p><p dir="ltr"><span>        (YOU MUST START WITH THE WORD PALP</span></p><p dir="ltr"><span>         AND FOLLOW THAT WITH ANY COMBINATION OF THE LETTERS</span></p><p dir="ltr"><span>         A AND B WITH SPACES BETWEEN EACH LETTER.)))</span></p><p dir="ltr"><span>; Q=current state</span></p><p dir="ltr"><span>; R=read this symbol at head</span></p><p dir="ltr"><span>; W=write this symbol at head (blank means don&#39;t write anything)</span></p><p dir="ltr"><span>; M=move head left (L) or right (R), or blank for don&#39;t move head</span></p><p dir="ltr"><span>; Q&#39;=new state</span></p><p dir="ltr"><span>;</span></p><p dir="ltr"><span>; In state Q, when the symbol at the head is R, then write W, move M</span></p><p dir="ltr"><span>; and set the new state to Q&#39;</span></p><p dir="ltr"><span>                                                      ; Q   R  W  M  Q&#39;</span></p><p dir="ltr"><span>(Q0</span></p><p dir="ltr"><span>    ((* 0) (PRE (_ * 2) (=Q0)))</span></p><p dir="ltr"><span>    ((0 *) (PRE (1 * _) (=Q0)))</span></p><p dir="ltr"><span>    ((0 1 * A * 1 0) (PRE (1   2   _ * 6 * 7) (=Q1))) ; Q0  A  _  R  Q1</span></p><p dir="ltr"><span>    ((0 1 * B * 1 0) (PRE (1   2   _ * 6 * 7) (=Q4))) ; Q0  B  _  R  Q4</span></p><p dir="ltr"><span>    ((0 1 * _ * 1 0) (=QACCEPT)))                     ; Q0  _        QACCEPT</span></p><p dir="ltr"><span>(Q1</span></p><p dir="ltr"><span>    ((* 0) (PRE (_ * 2) (=Q1)))</span></p><p dir="ltr"><span>    ((0 *) (PRE (1 * _) (=Q1)))</span></p><p dir="ltr"><span>    ((0 1 * A * 1 0) (PRE (1   2   A * 6 * 7) (=Q1))) ; Q1  A     R  Q1</span></p><p dir="ltr"><span>    ((0 1 * B * 1 0) (PRE (1   2   B * 6 * 7) (=Q1))) ; Q1  B     R  Q1</span></p><p dir="ltr"><span>    ((0 1 * _ * 1 0) (PRE (1 * 2 * _   6   7) (=Q2)))); Q1  _     L  Q2</span></p><p dir="ltr"><span>(Q2</span></p><p dir="ltr"><span>    ((* 0) (PRE (_ * 2) (=Q2)))</span></p><p dir="ltr"><span>    ((0 *) (PRE (1 * _) (=Q2)))</span></p><p dir="ltr"><span>    ((0 1 * A * 1 0) (PRE (1 * 2 * _   6   7) (=Q3))) ; Q2  A  _  L  Q3</span></p><p dir="ltr"><span>    ((0 1 * B * 1 0) (=QREJECT))                      ; Q2  B        QREJECT</span></p><p dir="ltr"><span>    ((0 1 * _ * 1 0) (=QACCEPT)))                     ; Q2  _        QACCEPT</span></p><p dir="ltr"><span>(Q3</span></p><p dir="ltr"><span>    ((* 0) (PRE (_ * 2) (=Q3)))</span></p><p dir="ltr"><span>    ((0 *) (PRE (1 * _) (=Q3)))</span></p><p dir="ltr"><span>    ((0 1 * A * 1 0) (PRE (1 * 2 * A   6   7) (=Q3))) ; Q3  A     L  Q3</span></p><p dir="ltr"><span>    ((0 1 * B * 1 0) (PRE (1 * 2 * B   6   7) (=Q3))) ; Q3  B     L  Q3</span></p><p dir="ltr"><span>    ((0 1 * _ * 1 0) (PRE (1   2   _ * 6 * 7) (=Q0)))); Q3  _     R  Q0</span></p><p dir="ltr"><span>(Q4</span></p><p dir="ltr"><span>    ((* 0) (PRE (_ * 2) (=Q4)))</span></p><p dir="ltr"><span>    ((0 *) (PRE (1 * _) (=Q4)))</span></p><p dir="ltr"><span>    ((0 1 * A * 1 0) (PRE (1   2   A * 6 * 7) (=Q4))) ; Q4  A     R  Q4</span></p><p dir="ltr"><span>    ((0 1 * B * 1 0) (PRE (1   2   B * 6 * 7) (=Q4))) ; Q4  B     R  Q4</span></p><p dir="ltr"><span>    ((0 1 * _ * 1 0) (PRE (1 * 2 * _   6   7) (=Q5)))); Q4  _     L  Q5</span></p><p dir="ltr"><span>(Q5</span></p><p dir="ltr"><span>    ((* 0) (PRE (_ * 2) (=Q5)))</span></p><p dir="ltr"><span>    ((0 *) (PRE (1 * _) (=Q5)))</span></p><p dir="ltr"><span>    ((0 1 * A * 1 0) (=QREJECT))                      ; Q5  A        QREJECT</span></p><p dir="ltr"><span>    ((0 1 * B * 1 0) (PRE (1 * 2 * _   6   7) (=Q3))) ; Q5  B  _  L  Q3</span></p><p dir="ltr"><span>    ((0 1 * _ * 1 0) (=QACCEPT)))                     ; Q5  _        QACCEPT</span></p><p dir="ltr"><span>(QACCEPT</span></p><p dir="ltr"><span>    ((0)</span></p><p dir="ltr"><span>        (TRUE)))</span></p><p dir="ltr"><span>(QREJECT</span></p><p dir="ltr"><span>    ((0)</span></p><p dir="ltr"><span>        (FALSE)))</span></p><p dir="ltr"><span>(NONE</span></p><p dir="ltr"><span>    ((0)</span></p><p dir="ltr"><span>        (TRY TYPING PALP A B A)</span></p><p dir="ltr"><span>        (TRY PALP A A A A)</span></p><p dir="ltr"><span>        (TRY PALP B A, ELIZA SHOULD RESPOND FALSE)</span></p><p dir="ltr"><span>        (TRY PALP B A B, ELIZA SHOULD RESPOND TRUE)))</span></p><p dir="ltr"><span>(TURING</span></p><p dir="ltr"><span>    ((0)</span></p><p dir="ltr"><span>        (MACHINE)))</span></p><p dir="ltr"><span>(MEMORY TURING</span></p><p dir="ltr"><span>    (0 = TURING MACHINE)</span></p><p dir="ltr"><span>    (0 = TURING MACHINE)</span></p><p dir="ltr"><span>    (0 = TURING MACHINE)</span></p><p dir="ltr"><span>    (0 = TURING MACHINE))</span></p><p dir="ltr"><span>This particular Turing machine requires that the symbols on the tape be ‘A’, ‘B’ and ‘_’, the latter representing an empty cell.</span></p><p dir="ltr"><span>On entry to Q0 the head must be positioned at the first cell in the sequence to be tested. If we are testing A B B A the cells on the tape (list of words) must be</span></p><p dir="ltr"><span>* A * B B A</span></p><p dir="ltr"><span>In operation the machine erases the A or B at the start of the sequence (Q0), travels to the end (Q1 for A, Q4 for B) and then expects to find a corresponding A (Q2) or B (Q5) at the end, which it also erases, before returning (Q3) to the start to repeat the process (Q0).</span></p><p dir="ltr"><span>Here are some traces of the ELIZA &#34;program&#34; (script) above executing several examples. Because most of the action takes place internally, via PRE calls, someone actually having a conversation with ELIZA won&#39;t see anything except the result (true or false). Here Anthony Hay has instrumented his ELIZA clone to display the &#34;tape&#34; (sentence) as it executes recursively through the PRE calls. First we just show the tape, then some more detailed versions that include the states and pattern matches and re-assemblies. </span><span>(This and other examples from Turing&#39;s paper and execution traces are at: </span><span><a href="https://www.google.com/url?q=https%3A%2F%2Fgithub.com%2Fjeffshrager%2Felizagen.org%2Ftree%2Fmaster%2FTuringCompleteness&amp;sa=D&amp;sntz=1&amp;usg=AOvVaw3oIRSDj6XP5_8DzC6jYYki" target="_blank">https://github.com/jeffshrager/elizagen.org/tree/master/TuringCompleteness</a></span><span>, and Anthony Hay&#39;s ELIZA is here: </span><span><a href="https://www.google.com/url?q=https%3A%2F%2Fgithub.com%2Fanthay%2FELIZA&amp;sa=D&amp;sntz=1&amp;usg=AOvVaw3j6P-yTnjhyhpNerlriiLE" target="_blank">https://github.com/anthay/ELIZA</a></span><span>)</span></p><p dir="ltr"><span>PALP A B B A A A B B A</span></p><p dir="ltr"><span>* A * B B A A A B B A</span></p><p dir="ltr"><span>_ * A * B B A A A B B A</span></p><p dir="ltr"><span>_ _ * B * B A A A B B A</span></p><p dir="ltr"><span>_ _ B * B * A A A B B A</span></p><p dir="ltr"><span>_ _ B B * A * A A B B A</span></p><p dir="ltr"><span>_ _ B B A * A * A B B A</span></p><p dir="ltr"><span>_ _ B B A A * A * B B A</span></p><p dir="ltr"><span>_ _ B B A A A * B * B A</span></p><p dir="ltr"><span>_ _ B B A A A B * B * A</span></p><p dir="ltr"><span>_ _ B B A A A B B * A *</span></p><p dir="ltr"><span>_ _ B B A A A B B * A * _</span></p><p dir="ltr"><span>_ _ B B A A A B B A * _ *</span></p><p dir="ltr"><span>_ _ B B A A A B B A * _ * _</span></p><p dir="ltr"><span>_ _ B B A A A B B * A * _ _</span></p><p dir="ltr"><span>_ _ B B A A A B * B * _ _ _</span></p><p dir="ltr"><span>_ _ B B A A A * B * B _ _ _</span></p><p dir="ltr"><span>_ _ B B A A * A * B B _ _ _</span></p><p dir="ltr"><span>_ _ B B A * A * A B B _ _ _</span></p><p dir="ltr"><span>_ _ B B * A * A A B B _ _ _</span></p><p dir="ltr"><span>_ _ B * B * A A A B B _ _ _</span></p><p dir="ltr"><span>_ _ * B * B A A A B B _ _ _</span></p><p dir="ltr"><span>_ * _ * B B A A A B B _ _ _</span></p><p dir="ltr"><span>_ _ * B * B A A A B B _ _ _</span></p><p dir="ltr"><span>_ _ _ * B * A A A B B _ _ _</span></p><p dir="ltr"><span>_ _ _ B * A * A A B B _ _ _</span></p><p dir="ltr"><span>_ _ _ B A * A * A B B _ _ _</span></p><p dir="ltr"><span>_ _ _ B A A * A * B B _ _ _</span></p><p dir="ltr"><span>_ _ _ B A A A * B * B _ _ _</span></p><p dir="ltr"><span>_ _ _ B A A A B * B * _ _ _</span></p><p dir="ltr"><span>_ _ _ B A A A B B * _ * _ _</span></p><p dir="ltr"><span>_ _ _ B A A A B * B * _ _ _</span></p><p dir="ltr"><span>_ _ _ B A A A * B * _ _ _ _</span></p><p dir="ltr"><span>_ _ _ B A A * A * B _ _ _ _</span></p><p dir="ltr"><span>_ _ _ B A * A * A B _ _ _ _</span></p><p dir="ltr"><span>_ _ _ B * A * A A B _ _ _ _</span></p><p dir="ltr"><span>_ _ _ * B * A A A B _ _ _ _</span></p><p dir="ltr"><span>_ _ * _ * B A A A B _ _ _ _</span></p><p dir="ltr"><span>_ _ _ * B * A A A B _ _ _ _</span></p><p dir="ltr"><span>_ _ _ _ * A * A A B _ _ _ _</span></p><p dir="ltr"><span>_ _ _ _ A * A * A B _ _ _ _</span></p><p dir="ltr"><span>_ _ _ _ A A * A * B _ _ _ _</span></p><p dir="ltr"><span>_ _ _ _ A A A * B * _ _ _ _</span></p><p dir="ltr"><span>_ _ _ _ A A A B * _ * _ _ _</span></p><p dir="ltr"><span>_ _ _ _ A A A * B * _ _ _ _</span></p><p dir="ltr"><span>_ _ _ _ A A * A * _ _ _ _ _</span></p><p dir="ltr"><span>_ _ _ _ A * A * A _ _ _ _ _</span></p><p dir="ltr"><span>_ _ _ _ * A * A A _ _ _ _ _</span></p><p dir="ltr"><span>_ _ _ * _ * A A A _ _ _ _ _</span></p><p dir="ltr"><span>_ _ _ _ * A * A A _ _ _ _ _</span></p><p dir="ltr"><span>_ _ _ _ _ * A * A _ _ _ _ _</span></p><p dir="ltr"><span>_ _ _ _ _ A * A * _ _ _ _ _</span></p><p dir="ltr"><span>_ _ _ _ _ A A * _ * _ _ _ _</span></p><p dir="ltr"><span>_ _ _ _ _ A * A * _ _ _ _ _</span></p><p dir="ltr"><span>_ _ _ _ _ * A * _ _ _ _ _ _</span></p><p dir="ltr"><span>_ _ _ _ * _ * A _ _ _ _ _ _</span></p><p dir="ltr"><span>_ _ _ _ _ * A * _ _ _ _ _ _</span></p><p dir="ltr"><span>_ _ _ _ _ _ * _ * _ _ _ _ _</span></p><p dir="ltr"><span>_ _ _ _ _ * _ * _ _ _ _ _ _</span></p><p dir="ltr"><span>_ _ _ _ _ * _ * _ _ _ _ _ _</span></p><p dir="ltr"><span>TRUE</span></p><p dir="ltr"><span>=================================================                                                                             </span></p><p dir="ltr"><span>palp a                                                                                                                        </span></p><p dir="ltr"><span>TRUE                                                                                                                          </span></p><p dir="ltr"><span>STATE   INPUT             MATCH            ASSMBL                                                                             </span></p><p dir="ltr"><span>-------------------------------------------------                                                                             </span></p><p dir="ltr"><span>PALP    PALP A            PALP A 0        ( PRE ( * A * 3 ) ( =Q0 ) )                                                         </span></p><p dir="ltr"><span>Q0      : * A *           * 0             ( PRE ( _ * 2 ) ( =Q0 ) )                                                           </span></p><p dir="ltr"><span>Q0      : _ * A *         0 *             ( PRE ( 1 * _ ) ( =Q0 ) )                                                           </span></p><p dir="ltr"><span>Q0      : _ * A * _       0 1 * A * 1 0   ( PRE ( 1 2 _ * 6 * 7 ) ( =Q1 ) )                                                   </span></p><p dir="ltr"><span>Q1      : _ _ * _ *       0 *             ( PRE ( 1 * _ ) ( =Q1 ) )                                                           </span></p><p dir="ltr"><span>Q1      : _ _ * _ * _     0 1 * _ * 1 0   ( PRE ( 1 * 2 * _ 6 7 ) ( =Q2 ) )                                                   </span></p><p dir="ltr"><span>Q2      : _ * _ * _ _     0 1 * _ * 1 0   =QACCEPT                                                                            </span></p><p dir="ltr"><span>QACCEPT  _ * _ _          0             TRUE                                                                                  </span></p><p dir="ltr"><span>=================================================                                                                             </span></p><p dir="ltr"><span>palp a b                                                                                                                      </span></p><p dir="ltr"><span>FALSE                                                                                                                         </span></p><p dir="ltr"><span>STATE   INPUT             MATCH            ASSMBL                                                                             </span></p><p dir="ltr"><span>-------------------------------------------------                                                                             </span></p><p dir="ltr"><span>PALP    PALP A B          PALP A 0        ( PRE ( * A * 3 ) ( =Q0 ) )                                                         </span></p><p dir="ltr"><span>Q0      : * A * B         * 0             ( PRE ( _ * 2 ) ( =Q0 ) )                                                           </span></p><p dir="ltr"><span>Q0      : _ * A * B       0 1 * A * 1 0   ( PRE ( 1 2 _ * 6 * 7 ) ( =Q1 ) )                                                   </span></p><p dir="ltr"><span>Q1      : _ _ * B *       0 *             ( PRE ( 1 * _ ) ( =Q1 ) )                                                           </span></p><p dir="ltr"><span>Q1      : _ _ * B * _     0 1 * B * 1 0   ( PRE ( 1 2 B * 6 * 7 ) ( =Q1 ) )                                                   </span></p><p dir="ltr"><span>Q1      : _ _ B * _ *     0 *             ( PRE ( 1 * _ ) ( =Q1 ) )                                                           </span></p><p dir="ltr"><span>Q1      : _ _ B * _ * _   0 1 * _ * 1 0   ( PRE ( 1 * 2 * _ 6 7 ) ( =Q2 ) )                                                   </span></p><p dir="ltr"><span>Q2      : _ _ * B * _ _   0 1 * B * 1 0   =QREJECT                                                                            </span></p><p dir="ltr"><span>QREJECT * B * _ _         0             FALSE      </span></p><p dir="ltr"><span>=================================================                                                                             </span></p><p dir="ltr"><span>palp a b a                                                                                                                    </span></p><p dir="ltr"><span>TRUE                                                                                                                          </span></p><p dir="ltr"><span>STATE   INPUT             MATCH            ASSMBL                                                                             </span></p><p dir="ltr"><span>-------------------------------------------------                                                                             </span></p><p dir="ltr"><span>PALP    PALP A B A        PALP A 0        ( PRE ( * A * 3 ) ( =Q0 ) )                                                         </span></p><p dir="ltr"><span>Q0      : * A * B A       * 0             ( PRE ( _ * 2 ) ( =Q0 ) )                                                           </span></p><p dir="ltr"><span>Q0      : _ * A * B A     0 1 * A * 1 0   ( PRE ( 1 2 _ * 6 * 7 ) ( =Q1 ) )                                                   </span></p><p dir="ltr"><span>Q1      : _ _ * B * A     0 1 * B * 1 0   ( PRE ( 1 2 B * 6 * 7 ) ( =Q1 ) )                                                   </span></p><p dir="ltr"><span>Q1      : _ _ B * A *     0 *             ( PRE ( 1 * _ ) ( =Q1 ) )                                                           </span></p><p dir="ltr"><span>Q1      : _ _ B * A * _   0 1 * A * 1 0   ( PRE ( 1 2 A * 6 * 7 ) ( =Q1 ) )                                                   </span></p><p dir="ltr"><span>Q1      : _ _ B A * _ *   0 *             ( PRE ( 1 * _ ) ( =Q1 ) )                                                           </span></p><p dir="ltr"><span>Q1      : _ _ B A * _ * _ 0 1 * _ * 1 0   ( PRE ( 1 * 2 * _ 6 7 ) ( =Q2 ) )                                                   </span></p><p dir="ltr"><span>Q2      : _ _ B * A * _ _ 0 1 * A * 1 0   ( PRE ( 1 * 2 * _ 6 7 ) ( =Q3 ) )                                                   </span></p><p dir="ltr"><span>Q3      : _ _ * B * _ _ _ 0 1 * B * 1 0   ( PRE ( 1 * 2 * B 6 7 ) ( =Q3 ) )                                                   </span></p><p dir="ltr"><span>Q3      : _ * _ * B _ _ _ 0 1 * _ * 1 0   ( PRE ( 1 2 _ * 6 * 7 ) ( =Q0 ) )                                                   </span></p><p dir="ltr"><span>Q0      : _ _ * B * _ _ _ 0 1 * B * 1 0   ( PRE ( 1 2 _ * 6 * 7 ) ( =Q4 ) )                                                   </span></p><p dir="ltr"><span>Q4      : _ _ _ * _ * _ _ 0 1 * _ * 1 0   ( PRE ( 1 * 2 * _ 6 7 ) ( =Q5 ) )                                                   </span></p><p dir="ltr"><span>Q5      : _ _ * _ * _ _ _ 0 1 * _ * 1 0   =QACCEPT                                                                            </span></p><p dir="ltr"><span>QACCEPT * _ * _ _ _       0             TRUE            </span></p><p dir="ltr"><span>=================================================                                                                             </span></p><p dir="ltr"><span>palp a b b a                                                                                                                  </span></p><p dir="ltr"><span>TRUE                                                                                                                          </span></p><p dir="ltr"><span>STATE   INPUT                  MATCH            ASSMBL                                                                        </span></p><p dir="ltr"><span>------------------------------------------------------                                                                        </span></p><p dir="ltr"><span>PALP    PALP A B B A           PALP A 0        ( PRE ( * A * 3 ) ( =Q0 ) )                                                    </span></p><p dir="ltr"><span>Q0      : * A * B B A          * 0             ( PRE ( _ * 2 ) ( =Q0 ) )                                                      </span></p><p dir="ltr"><span>Q0      : _ * A * B B A        0 1 * A * 1 0   ( PRE ( 1 2 _ * 6 * 7 ) ( =Q1 ) )                                              </span></p><p dir="ltr"><span>Q1      : _ _ * B * B A        0 1 * B * 1 0   ( PRE ( 1 2 B * 6 * 7 ) ( =Q1 ) )                                              </span></p><p dir="ltr"><span>Q1      : _ _ B * B * A        0 1 * B * 1 0   ( PRE ( 1 2 B * 6 * 7 ) ( =Q1 ) )                                              </span></p><p dir="ltr"><span>Q1      : _ _ B B * A *        0 *             ( PRE ( 1 * _ ) ( =Q1 ) )                                                      </span></p><p dir="ltr"><span>Q1      : _ _ B B * A * _      0 1 * A * 1 0   ( PRE ( 1 2 A * 6 * 7 ) ( =Q1 ) )                                              </span></p><p dir="ltr"><span>Q1      : _ _ B B A * _ *      0 *             ( PRE ( 1 * _ ) ( =Q1 ) )                                                      </span></p><p dir="ltr"><span>Q1      : _ _ B B A * _ * _    0 1 * _ * 1 0   ( PRE ( 1 * 2 * _ 6 7 ) ( =Q2 ) )                                              </span></p><p dir="ltr"><span>Q2      : _ _ B B * A * _ _    0 1 * A * 1 0   ( PRE ( 1 * 2 * _ 6 7 ) ( =Q3 ) )                                              </span></p><p dir="ltr"><span>Q3      : _ _ B * B * _ _ _    0 1 * B * 1 0   ( PRE ( 1 * 2 * B 6 7 ) ( =Q3 ) )                                              </span></p><p dir="ltr"><span>Q3      : _ _ * B * B _ _ _    0 1 * B * 1 0   ( PRE ( 1 * 2 * B 6 7 ) ( =Q3 ) )                                              </span></p><p dir="ltr"><span>Q3      : _ * _ * B B _ _ _    0 1 * _ * 1 0   ( PRE ( 1 2 _ * 6 * 7 ) ( =Q0 ) )                                              </span></p><p dir="ltr"><span>Q0      : _ _ * B * B _ _ _    0 1 * B * 1 0   ( PRE ( 1 2 _ * 6 * 7 ) ( =Q4 ) )                                              </span></p><p dir="ltr"><span>Q4      : _ _ _ * B * _ _ _    0 1 * B * 1 0   ( PRE ( 1 2 B * 6 * 7 ) ( =Q4 ) )                                              </span></p><p dir="ltr"><span>Q4      : _ _ _ B * _ * _ _    0 1 * _ * 1 0   ( PRE ( 1 * 2 * _ 6 7 ) ( =Q5 ) )                                              </span></p><p dir="ltr"><span>Q5      : _ _ _ * B * _ _ _    0 1 * B * 1 0   ( PRE ( 1 * 2 * _ 6 7 ) ( =Q3 ) )                                              </span></p><p dir="ltr"><span>Q3      : _ _ * _ * _ _ _ _    0 1 * _ * 1 0   ( PRE ( 1 2 _ * 6 * 7 ) ( =Q0 ) )                                              </span></p><p dir="ltr"><span>Q0      : _ _ _ * _ * _ _ _    0 1 * _ * 1 0   =QACCEPT                                                                       </span></p><p dir="ltr"><span>QACCEPT _ * _ * _ _ _          0             TRUE       </span></p></div></div></div></div></div></div></div></div></div></section></div></div>
  </body>
</html>
