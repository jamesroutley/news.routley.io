<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://nicole.express/2024/phasing-in-and-out-of-existence.html">Original</a>
    <h1>Apple II graphics: More than you wanted to know</h1>
    
    <div id="readability-page-1" class="page"><div aria-label="Content">
      <div>
        <article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    <p>The Apple ][ is one of the most iconic vintage computers of all time. But since Wozniak’s monster lasted all the way until 1993 (1995 if you could the IIe card, which I won’t count until I get one), it can be easy to forget that in 1977, it was a video <em>extravaganza</em>. The competitors– even much bigger and established companies like Commodore and Tandy– generally only had text modes, let alone pixel-addressable graphics, and they certainly didn’t have sixteen colors. (Gray and grey are different colors, right?)</p>

<h2 id="preliminary">Preliminary</h2>

<p>My main source here is going to be <em>Understanding the Apple II</em> by Jim Sather. You might say, why should I read this post then, when I can go to the source? And honestly <a href="https://archive.org/details/utaii">yeah go do that</a>. What I’ll do here is try to digest it for myself by writing it in a form I find understandable, focused on details I find interesting. I’ll also throw together some looks at my own personal Apple II, maybe an oscilloscope, that sort of thing.</p>

<p><img src="https://words.filippo.io/assets/a2p-2.JPG" title="This photo is from one of the earliest posts on this blog" alt="The Apple II, plugged into a greenscreen monitor"/></p>

<p>Now, my personal Apple ][<sub><i>plus</i></sub> and the book have something in common: they predate the Apple IIe. So this blog post will focus on the original Apple ][ designed machines. So when I talk about graphics mode, you won’t see the 80 column or double-width graphics modes. Those were IIe features; there were no provisions for such things on the original models. If this post proves interesting maybe I’ll dig into them later; I have an Apple IIgs, so certainly I <em>can</em> explore IIe exclusives. (And Jim Sather even wrote a follow-up book, <em>Understanding the Apple IIe</em>)</p>



<p><img src="https://words.filippo.io/assets/img/2apple2furious/lang.jpeg" title="taking out the language card is a pain so I left it in" alt="Apple II motherboard"/></p>

<p>Here is the motherboard of my Apple II plus. It’s serial number 820-0044-01, which despite the 1979 copyright date, implies it’s definitely one of the later Apple IIs of its type– in 1981, the 820-0044-XX motherboard series was created by Apple in order to try to reduce radio-frequency interference (RFI), so this is known as the “RFI” motherboard. Go dig into <a href="https://archive.org/details/apple-ii-circuit-description/page/n157/mode/2up"><em>The Apple II Circuit Description</em></a> for all the nitty-gritty on motherboard variants.</p>

<p><img src="https://words.filippo.io/assets/img/2apple2furious/serial.jpeg" title="I want a Rev 0 so bad" alt="Apple II motherboard serial number"/></p>

<p>It’s worth noting for those not familiar with the Apple II that the “Apple II” and the “Apple II plus” are the same system, whose major difference is just the ROM. After the introduction of the new ROMs in 1979, there was a period where the same motherboard, when sold with the original Integer BASIC ROM set, it was an Apple II; when Applesoft (Microsoft BASIC for the Apple) was baked in instead, the badge was changed to II plus. Eventually all Apples shipped with Applesoft and the original II badges stopped being used. The internal capabilities are identical, including all the graphics modes I’ll talk about.</p>

<h2 id="everything-but-the-kitchen-sync">Everything but the kitchen sync</h2>

<p>Television video systems predate computers wanting to use them. Therefore, they are greedy– a video signal must produce the expected signals at the expected times, or your television will lose synchronization with the signal. Regaining synchronization will likely result in a delay, and definitely a loss of visual signals.</p>

<p>So when the video signal is being drawn, everything else has to bow to the video system’s will. The <a href="https://words.filippo.io/2022/the-nes-as-an-artifact.html">Nintendo Entertainment System</a> creates a separate world, the PPU bus, for the video system to inhabit, and the developer should avoid touching it unless it’s convenient. Other machine did things differently– the Atari 130XE I recently <a href="https://words.filippo.io/2024/have-you-typed-atari-today.html">upgraded the keyboard</a> on uses a variant of the 6502 processor with an extra pin whose sole purpose is to halt the CPU whenever the video chip needs extra time to access RAM. Both the 130XE and the NES have a 1.7MHz CPU, but the NES can run its just a little faster. (The 130XE has literally 64 times the CPU-accessible RAM, it’ll be fine)</p>



<p>The Apple II is a little bit different than that. The CPU can access RAM whenever it wants. The graphics system, known as the video scanner (it’s not one chip), can also access the RAM it needs whenever it wants. How did Woz do this? A clue is hidden in the <a href="http://www.6502.org/documents/datasheets/synertek/">6502 datasheets</a>– specifically, this diagram is from the August 1976 “SY6500/MCS6500 Microcomputer Family Hardware Manual”.</p>

<p><img src="https://words.filippo.io/assets/img/2apple2furious/book.png" title="This diagram is vintage" alt="Timing diagram for the 6502, showing that the address and data only both need be valid when the clock is down"/></p>

<p>The important thing to note is to look at φ<sub>2</sub>, the input clock. The data output of external memory only needs to be valid at the very end of the period in which φ<sub>2</sub> is low. The <em>entire</em> period when φ<sub>2</sub> is high, the 6502 is doing internal stuff, and you don’t actually want its signals to show up on the data bus. So if you have sufficiently fast memory, you can have your memory off doing something else while φ<sub>2</sub> is low, and the 6502 will never know the difference.</p>



<p>Now, my understanding is that the Commodore VIC-20 interlaces its memory accesses the same way. But there are three major differences between the Apple II and the Commodore VIC-20. Well, okay, there’s more than that. But there are a few particularly relevant ones:</p>

<ol>
  <li>The VIC-20 uses static RAM. The Apple II’s video scanner also handles DRAM refresh, while the Commodore doesn’t need to worry about that.</li>
  <li>The VIC-20 has no directly-accessible-pixel screen modes.</li>
  <li>The VIC-20’s Video Interface Chip is, well, a chip. A highly integrated circuit that is opaque to exterior analysis, and with room for extra logic to simplify the external interface. The Apple II video scanner is constructed out of easily-analyzable discrete logic, and wears its implementation details on its sleeve.</li>
</ol>

<p>It’s that last one that I think is really important here. A lot of the fiddly details of the Apple II’s video that a programmer has to put up with could have been papered over with a few extra logic gates, internal registers, and buffers. On an integrated circuit this wouldn’t be a big deal as long as everything still fit within the planned mask size. But Steve Wozniak was building the Apple II out of discrete logic, and Apple paid for each one of those chips. So it was in the interest of cost-effectiveness that Apple offloaded some complexity to the programmer.</p>

<h3 id="what-frequency-is-it-anyways">What frequency is it anyways?</h3>

<p>Let’s talk about pixels. The Apple II has a core oscillator at 14.318180MHz (“14M”), which is divided by two to create a 7.15909MHz (“7M”) signal, and then divided again to create a 3.579545MHz signal. This latter suspiciously-specific frequency is the NTSC “colorburst” frequency. 7M is our pixel clock; during active display, a pixel is output every (1 / 7.15909MHz). A division of 7M by 7 gives you 1.0227MHz, which sounds like the 1MHz CPU clock. <em>But is it?</em></p>

<p>The horizontal scanning rate of NTSC television is 15.734kHz. PAL is 15.625kHz, but we’ll ignore that which challenges us. That means we have 63.56μs to finish a line, or a quick trip to <a href="https://www.wolframalpha.com/input?i=%281+%2F+15.734kHz%29+%2F+%281+%2F+14.318180MHz%29">Wolfram Alpha</a> says that’s 910 clicks of our 14M clock. 65 clicks of 1.0227MHz, 455 pixels (including in blanking periods; 280 pixels the screen actually draws), and therefore 227.5 ticks of our color reference. Which isn’t evenly divided.</p>

<p>That’s actually correct and how the spec expects it, however, we need to keep all the accesses perfectly synchronized, and we want the color reference to also be constant relative to the CPU. (Ever wonder why systems like PC clones don’t always have consistent artifact colors?) So the Apple II lengthens that last 65th clock– it’s the “long cycle”, taking an extra tick. Now the scanline frequency is dropped to 15.700kHz (fine for most TVs), but also now the Apple II CPU clock is <strong>not constant</strong>, it varies based off of where the screen is drawing. It’s 1.0205MHz on average, but only on average.</p>

<p>Combine that with the knowledge of the Apple II’s <a href="https://words.filippo.io/2021/stop-mocking-me.html">audio system</a> and the stock Apple II’s lack of any hardware timers, and this is actually worth knowing. Unfortunately, the Apple II doesn’t give the programmer any ability to know where in its cycle the video scanner is at any given time. (<i>Understanding the Apple II</i> has a few possible mods you can do to your computer to let it know, though!)</p>

<h2 id="text-mode">TEXT mode</h2>

<p>Many vintage computers are defined by their fonts. The PET’s PETSCII is iconic, of course (though probably moreso for its use on the Commodore 64). The TRS-80 had its “pseudographics” characters allowing for very blocky pixel graphics despite only having text mode. And I’ve always enjoyed the thick letters of the Atari 8-bit font, which not only look nice, but also help readability on a system whose text mode is single-color (varying only in luminance) and would be viewed by most users over a noisy RF modulator.</p>

<p><img src="https://words.filippo.io/assets/img/dasatari/name-intro.jpg" title="Please exclusively refer to me as (5-note tune) from now on" alt="The point in the software described above"/></p>

<p>And then we get to the Apple II, with its stark simple character forms, and absolutely no special characters to speak of. (Though at least it has built in inverse and flashing text modes, always useful?) One can easily imagine Steve Jobs in the mindset that would lead to the lack of arrow keys on the first Macintosh keyboard, insisting that since the Apple II’s standout feature was its graphics modes, there would be no special incentives to create pseudographics with text mode.</p>

<p><video src="/assets/img/2apple2furious/txt.mp4" width="640px" autoplay="" loop="" muted=""> You don&#39;t have a video tag support or something? So you can&#39;t see this footage of The Apple II, showing its narrow font? Ah too bad.</video></p>

<p>You could think that, but you’d be wrong. Early revisions of the Apple II used the Signetics 2513 character generator ROM. This was a commercial, off the shelf part. You can go find its datasheet online.</p>

<p><img src="https://words.filippo.io/assets/img/2apple2furious/sign.png" title="Understanding the Apple II says it was a GI version but everything was second and third sourced those days" alt="Signetics logo advertising a 2513 HIGH SPEED 64x7x5 CHARACTER GENERATOR"/></p>

<p>This was a popular part that Woz had used earlier in the Apple 1, and was a popular use for hobbyist projects like the famous 1973 <a href="https://en.wikipedia.org/wiki/TV_Typewriter">TV Typewriter</a>. So the message the Apple II font actually sends is “hey tinkerers, this is for you”. Now later models of the Apple II, like my II plus, use a more standard mask ROM instead of this weird 5-bit character-specific ROM; you can even mod it to put your own EEPROM in. On my RFI board, it’s “ROM SPCL” deep under the keyboard.</p>

<p><img src="https://words.filippo.io/assets/img/2apple2furious/spcl.jpeg" title="a special rom for a special computer &lt;3" alt="ROM SPCL is underneath the keyboard PCB. It is only visible by the edge of its socket"/></p>

<p>Despite the Signetics ROM being only 5 pixels wide, text characters on the Apple II are 7 pixels wide. But why 7? Well, the reason is all that screen math again. The memory access clock is 7M divided by 7 to get the memory timing; so you have one memory cycle to get 7 pixels. We have 40 columns in the visible area, and 24 rows, fine for low resolution text mode. Pretty basic, right?</p>

<p><img src="https://words.filippo.io/assets/img/2apple2furious/steve.jpg" title="I swear this won&#39;t become a habit but I couldn&#39;t resist" alt="Steve Jobs saying &#39;One More Thing&#39;"/></p>

<h3 id="memory-layout">Memory layout</h3>

<p>The official Apple <em>Apple II Reference Manual</em>, signed by Woz on the cover, provides some detail on the memory layout that starts to be a bit concerning.</p>

<blockquote>
  <p>The area of memory which is used for the primary text page starts at location number 1024 and extends to location number 2047. The secondary screen begins at location number 2048 and extends to location 3071. In machine language, the primary page is from hexadecimal address $400 to address $7FF; the secondary page is from $800 to $BFF. Each of these pages is 1,024 bytes long. Those of you intrepid enough to do the multiplication will realize that there are only 960 characters displayed on the screen. The remaining 64 bytes in each page which are not displayed on the screen are used as temporary storage locations by programs stored in PROM on Apple Intelligent Interface (r) peripheral boards (see page 82).</p>
</blockquote>

<p>You might wonder why they’re giving memory addresses in decimal– well, that was pretty normal for 70’s and 80’s computer manuals. You might also wonder why they’re so desperate for RAM that such a small amount of extra RAM would be in demand for peripheral cards– well, the original Apple II was sold with a base RAM configuration of 4kiB, so no addresses above <code>0x1000</code> would exist.</p>

<p>But the real question is how that memory is laid out. The Reference Manual just gives a screen map, but it doesn’t tell you <em>why</em> it is the way it is. My scan of this isn’t great, but you can see that the rows are very much not sequential.</p>

<p><img src="https://words.filippo.io/assets/img/2apple2furious/text.png" title="and you thought microsoft was bad at counting to ten" alt="Screen layout diagram"/></p>

<p>I’ve called the Apple II screen memory layout bizarre before, and from a programmer’s perspective, it really is. But I was also criticized for that– because Steve Wozniak is really doing something quite impressive here. You have to understand the constraints he was under.</p>

<ol>
  <li><strong>Use as few chips as possible</strong>. Each piece of discrete logic costs money. So wherever possible work with the signals you have– the binary counters that are used for all that counting logic, for example.</li>
  <li><strong>But don’t waste RAM</strong>. The constraints of the television standard give us 40 columns wide. That’s not a simple binary number; you could have a gap after every text line, but that’d give 24 small areas of wasted RAM.</li>
  <li><strong>Refresh DRAM</strong>. DRAM addressing is pretty complicated, relying on “row” and “column” signals. But long story short, when going through the screen to display video, you also need to access every “row” address every 2ms. A 60Hz frame is 16.67ms. (Note that each chip is either 4kiB or 16kiB, so if you refresh the right range in one chip you can simultaneously refresh the rest)</li>
</ol>

<p>I’m not going to go into the full detail of the design because I think I’d just be repeating Jim Sather’s book in full here. But more-or-less, the screen is divided into three areas: top, middle, and bottom, each of eight rows. Then, the memory page, let’s use the primary text page <code>0x400</code>, is divided into eight subsections of 128 bytes each– 128 bytes gives us something our binary counters can easily catch. Each of these 128 byte sections is as follows:</p>

<ul>
  <li>One row of 40 characters for the top area</li>
  <li>One row of 40 characters for the middle area</li>
  <li>One row of 40 characters for the bottom area</li>
  <li>One 8 byte “screen hole” given to the Apple Intelligent Interface (r) peripheral boards</li>
</ul>

<p>In order to refresh a larger part of the screen during TEXT and LORES modes, the video scanner actually accesses different addresses during the horizontal blanking period, which allows it to refresh a wider range. These are wrong for video, but there’s no video during the blanking period. It doesn’t need to do this in HIRES mode, so it doesn’t.</p>



<p>From the programmer’s perspective, this usually just is papered over with a lookup table, and isn’t a big deal in the end.</p>

<h2 id="hires-mode">HIRES mode</h2>

<p>The Apple II offers no ability to customize the blocks in text mode; that Signetics ROM could not be replaced with RAM. This was the case for all three machines of the 1977 “Trinity”, but later Commodore machines would allow it. Unlike the other two “Trinity” machines, though, Apple lets you address the screen pixels directly.</p>

<p>With 40 bytes per row, and 24 * 8 = 192 rows in the visible area, you’d need at least 7.5kiB for just one screen. So we’ve abandoned the 4kiB Apple II users here– the 4kiB Apple II was not on the market very long though, and the upgraded 16kiB was the low-end model for most of the late 70’s. By the time of later models like my plus, 48kiB was more or less assumed anyways. With 16kiB you get one HIRES page at <code>0x2000</code>, with 48kiB you can get a second one at <code>0x4000</code>. (Double-buffering in 1977?) Of course, that’s a lot of RAM, so if you don’t need it a program will probably use it for something else.</p>

<p>Now, there’s an interesting problem that HIRES memory has to handle– the addresses and layout for text mode are very carefully chosen and set up to allow DRAM refresh. But now we need to get eight times as many addresses, with as few changes as possible. How do we do it? HIRES mode uses <em>higher</em> address bits, which are mapped to the DRAM “columns”, mostly not impacting the careful dance of refresh. But this creates a pretty wild memory layout.</p>

<p>
<svg width="640" height="860" viewBox="-10 0 320 420" xmlns="http://www.w3.org/2000/svg" title="oh gods please age well SVG" alt="Memory map">
    
    <defs>
        <pattern id="striped" viewBox="0,0,7,8" width="4.16%" height="4.16%">
            <rect fill="#0000ff" x="-2" y="0" width="40" height="1"></rect>
            <rect fill="#00a0a0" x="-2" y="1" width="40" height="1"></rect>
            <rect fill="#00ff00" x="-2" y="2" width="40" height="1"></rect>
            <rect fill="#a0a000" x="-2" y="3" width="40" height="1"></rect>
            <rect fill="#ff0000" x="-2" y="4" width="40" height="1"></rect>
            <rect fill="#a0a0ff" x="-2" y="5" width="40" height="1"></rect>
            <rect fill="#ffa0a0" x="-2" y="6" width="40" height="1"></rect>
            <rect fill="#a000a0" x="-2" y="7" width="40" height="1"></rect>
        </pattern>
    </defs>
    <rect fill="#fff" x="-20" y="-20" width="320" height="450"></rect>
    <text x="0" y="12">Screen</text>
    <rect fill="url(#striped)" height="192" width="240" x="0" y="20"></rect>
    <text x="0" y="227">Memory</text>
    <rect fill="#0000ff" x="0" y="230" width="240" height="24"></rect>
    <rect fill="#00a0a0" x="0" y="254" width="240" height="24"></rect>
    <rect fill="#00ff00" x="0" y="278" width="240" height="24"></rect>
    <rect fill="#a0a000" x="0" y="302" width="240" height="24"></rect>
    <rect fill="#ff0000" x="0" y="326" width="240" height="24"></rect>
    <rect fill="#a0a0ff" x="0" y="350" width="240" height="24"></rect>
    <rect fill="#ffa0a0" x="0" y="374" width="240" height="24"></rect>
    <rect fill="#a000a0" x="0" y="398" width="240" height="24"></rect>
</svg>
</p>

<p>Apologies to the colorblind for the graph above! In fact, maybe I should just apologize to everyone with eyes. The SVGs are an experiment, we’ll see how they go.</p>

<p>Essentially, the HIRES memory space is divided into eight sections. The first section is the top row of pixels for each 7x8 text mode tile, the second section the second row, etc. etc. Each section (the large colored blocks in memory above) is itself laid out the same way as TEXT mode, complete with some screen holes. Confusing? Sure, but again, most programmers made a lookup table or two and called it a day. Each byte has seven pixels, the first bit being ignored. (The bits are also pushed to the screen in <em>opposite</em> order to how they’re usually written, but this is all just convention anyway)</p>

<h3 id="color">Color</h3>

<p><img src="https://words.filippo.io/assets/img/softcard/monitor3.jpg" title="Probably because it looks awesome" alt="The Monitor III sitting on the Apple II plus"/></p>

<p>Everything I just described is good enough for business software and users of the monochrome Monitor ///. But this is an Apple II, the ultimate gaming PC of 1977. We want <em>color</em>. You probably know about “NTSC artifacts”, but what does that mean? And that’s where all our timing synchronization comes into play.</p>

<p>Imagine the Apple II drawing an alternating pixel pattern, <code>0101</code>. It draws those pixels at the rate of its pixel clock, <code>7M</code>. An important thing to remember about square waves is that the frequency is the frequency of a <em>complete cycle</em>, both the “up” and “down” of the wave.</p>

<p>
<svg width="500" height="325" viewBox="0 0 100 65" xmlns="http://www.w3.org/2000/svg" title="oh gods please age well SVG" alt="Pixel timing diagram">
    
    <rect fill="#fff" x="0" y="0" width="100" height="100"></rect>
    <text x="5" y="7">7M (pixel clock)</text>
    <polyline points="10,10 10,20 20,20 20,10 30,10 30,20 40,20 40,10 50,10 50,20 60,20 60,10 70,10 70,20 80,20 80,10 90,10 90,20" stroke="red" stroke-width="2" fill="none"></polyline>
    <text x="5" y="27">3.5M (color signal)</text>
    <polyline points="10,30 10,40 30,40 30,30 50,30 50,40 70,40 70,30 90,30" stroke="blue" stroke-width="2" fill="none"></polyline>
    <text x="5" y="47">Pixels</text>
    <rect fill="#000" x="10" y="50" width="20" height="10" rx="4"></rect>
    <rect fill="#000" x="50" y="50" width="20" height="10" rx="4"></rect>
</svg>
</p>

<p>That is to say, if you alternate pixels, you’re creating a signal that repeats at the colorburst frequency! This is a real color signal, just like you’d generate if you had one of those fancy TMS9918As or something, but it’s being generated using the same mechanism that generates the pixels. (Sure, it’s a square wave here, but that’s what signal filters and such are for) Also, as the programmer, you get to control it directly.</p>

<p><img src="https://words.filippo.io/assets/img/pang-sparts/rf2av.jpg" title="Yep it&#39;s a rainbow" alt="Pong with rainbow backgrounds and art"/></p>

<p>This is a screenshot from <a href="https://words.filippo.io/2024/super-duper-rainbow-pong.html">Atari’s <em>Pong Sports IV</em></a>, which like Atari’s other <em>Home Pong</em> series of consoles, uses a slightly out of phase crystal to create a cool rainbow effect. Obviously that isn’t possible here– with such strict pixel timing, we can only create two color phase shifts. And now you know why the “long cycle” that keeps the memory accesses in sync with the colorburst frequency is so important, or the phase shifts would also be different on each scanline.</p>

<p>
<svg width="500" height="400" viewBox="0 0 100 80" xmlns="http://www.w3.org/2000/svg" title="oh gods please age well SVG" alt="Pixel timing diagram">
    
    <rect fill="#fff" x="0" y="0" width="100" height="100"></rect>
    <text x="5" y="7">7M (pixel clock)</text>
    <polyline points="10,10 10,20 20,20 20,10 30,10 30,20 40,20 40,10 50,10 50,20 60,20 60,10 70,10 70,20 80,20 80,10 90,10 90,20" stroke="red" stroke-width="2" fill="none"></polyline>
    <text x="5" y="27">3.5M (color signal)</text>
    <polyline points="10,30 10,40 30,40 30,30 50,30 50,40 70,40 70,30 90,30" stroke="blue" stroke-width="2" fill="none"></polyline>
    <text x="5" y="47">Patterns</text>
    <polyline points="10,50 10,60 30,60 30,50 50,50 50,60 70,60 70,50 90,50" stroke="orange" stroke-width="2" fill="none"></polyline>
    <polyline points="10,75 10,65 30,65 30,75 50,75 50,65 70,65 70,75 90,75" stroke="orange" stroke-width="2" fill="none"></polyline>
    <rect fill="rgba(0, 0, 0, 0.5)" x="10" y="50" width="20" height="10" rx="4"></rect>
    <rect fill="rgba(0, 0, 0, 0.5)" x="50" y="50" width="20" height="10" rx="4"></rect>
    <rect fill="rgba(0, 0, 0, 0.5)" x="30" y="65" width="20" height="10" rx="4"></rect>
    <rect fill="rgba(0, 0, 0, 0.5)" x="70" y="65" width="20" height="10" rx="4"></rect>
</svg>
</p>

<p>I deliberately used the chosen colors above because they are <em>not</em> the colors generated, because I don’t necessarily have the phase relationships perfectly correct. Take the diagrams above as basic conceptual scribbles, not necessarily oscilloscope traces– the point is, there are two signals: one in phase with the colorburst, one 180° out of phase with the colorburst. But the colorburst is itself defined as 180° out of phase with the color carrier, so this is a bit complex.</p>

<p><img src="https://words.filippo.io/assets/img/2apple2furious/snek.png" title="no step on snek" alt="Ultima II showing a green dorky-looking snake in a dungeon"/></p>

<p>Anyway long story short, as <em>Ultima II</em> shows us above, it’s pink and green, the colors are pink and green. Well, pink is looking awfully purplish today, but that’s the wonder of NTSC. (And the horizontal lines visible on the green snake are the wonder of using square waves and this particular upscaler-capture combo) Notice those horizontal lines also picked up some color– if you want to guarantee white, you’ll need to create a signal with a frequency that <em>isn’t</em> a color carrier. The line above is just one pixel, but two pixels next to each other will do it.</p>

<p>
<svg width="500" height="325" viewBox="0 0 100 65" xmlns="http://www.w3.org/2000/svg" title="oh gods please age well SVG" alt="Pixel timing diagram">
    
    <rect fill="#fff" x="0" y="0" width="100" height="100"></rect>
    <text x="5" y="7">7M (pixel clock)</text>
    <polyline points="10,10 10,20 20,20 20,10 30,10 30,20 40,20 40,10 50,10 50,20 60,20 60,10 70,10 70,20 80,20 80,10 90,10 90,20" stroke="red" stroke-width="2" fill="none"></polyline>
    <text x="5" y="27">3.5M (color signal)</text>
    <polyline points="10,30 10,40 30,40 30,30 50,30 50,40 70,40 70,30 90,30" stroke="blue" stroke-width="2" fill="none"></polyline>
    <text x="5" y="47">Pixels</text>
    <polyline points="10,50 10,60 50,60 50,50 90,50 90,60" stroke="orange" stroke-width="2" fill="none"></polyline>
    <rect fill="rgba(0, 0, 0, 0.5)" x="10" y="50" width="20" height="10" rx="4"></rect>
    <rect fill="rgba(0, 0, 0, 0.5)" x="30" y="50" width="20" height="10" rx="4"></rect>
</svg>
</p>

<p>Even if you alternate groups of two pixels, that signal isn’t at 3.579545MHz, so your television won’t be able to pull out any color information from it– it’ll just be treated as monochrome white. Modulo some higher-frequency fringes, after all, this <em>is</em> still good old-fashioned <a href="https://words.filippo.io/2021/shouldve-had-field-sequential.html">composite video</a> and no filter is perfect. Apple II users got used to some color fringing, or used a monochrome monitor.</p>

<p>Now, unfortunately, there is another catch here. Our addressable pixel areas are 7 pixels wide, which is not evenly divisible by two.<sup><i>citation needed</i></sup> This means that if you have a pattern, <code>x0101010</code>, whether it’s pink or green will depend on its position relative to the beginning of the line. Odd addresses will have one color, even addresses the other. This is why many Apple II games, like <em>Ultima III: Exodus</em>, create a grid of 14-pixel wide tiles that things move about on.</p>

<p><img src="https://words.filippo.io/assets/img/2apple2furious/exy.png" title="let my people go?" alt="Exodus, showing a tiled area"/></p>

<p>This is still HIRES graphics mode, not a tile-based mode– the developer is just implementing tiles to make their lives easier. And on this title screen they only do so where things will move around in the bottom half.</p>

<h3 id="whats-the-big-deal">What’s the big deal?</h3>

<p>Now you might have noticed something about the screenshot above. It’s got colors that aren’t pink and green– it’s got blue water, and red lava. That’s true, but it’s only true because my Apple II isn’t a Revision 0. Those early adopters only have a three-color HIRES mode. The rest of us have something better.</p>

<p>Remember that first bit? It’d be pretty wasteful to just leave that unused. This is especially true from the perspective of the video scanner– this bit is fully decoded and just sitting there, waiting to have a use applied for it. What Woz did was have it delay the output of pixels by one cycle of the <em>14M</em> master clock, breaking the 7M pixel clock, but creating new phase shifts.</p>

<p>
<svg width="500" height="400" viewBox="0 0 100 80" xmlns="http://www.w3.org/2000/svg" title="oh gods please age well SVG" alt="Pixel timing diagram">
    
    <rect fill="#fff" x="0" y="0" width="100" height="100"></rect>
    <text x="5" y="7">7M (pixel-ish clock)</text>
    <polyline points="10,10 10,20 20,20 20,10 30,10 30,20 40,20 40,10 50,10 50,20 60,20 60,10 70,10 70,20 80,20 80,10 90,10 90,20" stroke="red" stroke-width="2" fill="none"></polyline>
    <text x="5" y="27">3.5M (color signal)</text>
    <polyline points="10,30 10,40 30,40 30,30 50,30 50,40 70,40 70,30 90,30" stroke="blue" stroke-width="2" fill="none"></polyline>
    <text x="5" y="47">Patterns (offset)</text>
    <polyline points="9,50 20,50 20,60 40,60 40,50 60,50 60,60 80,60 80,50 90,50" stroke="#0d0" stroke-width="2" fill="none"></polyline>
    <polyline points="9,75 20,75 20,65 40,65 40,75 60,75 60,65 80,65 80,75 90,75" stroke="#0d0" stroke-width="2" fill="none"></polyline>
    <polyline points="10,50 10,60 30,60 30,50 50,50 50,60 70,60 70,50 90,50" stroke="rgba(0,0,0,0.2)" stroke-width="2" fill="none"></polyline>
    <polyline points="10,75 10,75 10,65 30,65 30,75 50,75 50,65 70,65 70,75 90,75" stroke="rgba(0,0,0,0.2)" stroke-width="2" fill="none"></polyline>
</svg>
</p>

<p>This gives us two more phases to work with, 90° out of phase with the pink and green colors we had before– blue and red-orange. But remember, we’re limited to using them within groups of 7 pixels. You can almost think of this as like being able to choose a palette for a 1-pixel high and 7-pixel wide area, except for…</p>

<h3 id="the-boundaries">The boundaries</h3>

<p>An interesting thing can be seen in this screenshot from Sega’s <em>Frogger</em>. You should now understand why Frogger is white, and why the colored areas are laid out the way they are. But take a look at where the coast meets the water. The green areas and the blue areas don’t quite line up.</p>

<p><img src="https://words.filippo.io/assets/img/2apple2furious/f1.png" title="Frogger on the TRS-80 has horizontal scrolling" alt="Frogger port"/></p>

<p><img src="https://words.filippo.io/assets/img/2apple2furious/zoom.png" title="plus turtles arent as big as trucks, inaccurate" alt="Zoomed in to show misaligned blocks"/></p>

<p>Why don’t they line up? It’s not the developer’s fault, it’s because they can’t. Take a look at what happens if I plug the Apple II’s output into the component luma input on the OSSC. (This is actually how I got most of the text mode captures too, to avoid unnecessary color noise)</p>

<p><img src="https://words.filippo.io/assets/img/2apple2furious/f2.jpeg" title="the wormhole aliens HATE the apple ii because it is linear" alt="Frogger port all made out of lines"/></p>

<p>The lines just don’t line up. The Apple II can get you in a mindset trap; of <em>course</em> it can’t line up, you might start to think. But on a system where the luminance and chrominance are set separately, and where it can output analog values, not just 0 or 1, of course it can. On the Apple II, all sorts of weirdness will happen where non-delayed pixels interact with delayed pixels. Say, at the edge of the screen, when we enter the screen border, the seven pixels will be abruptly cut off, leaving a half-pixel at the edge.</p>

<p>
<svg width="500" height="250" viewBox="0 40 100 50" xmlns="http://www.w3.org/2000/svg" title="oh gods please age well SVG" alt="Pixel timing diagram">
    
    <rect fill="#fff" x="0" y="0" width="100" height="100"></rect>
    <text x="30" y="45">Screen boundary</text>
    <line stroke-width="2" x1="70" y1="0" x2="70" y2="100" stroke="#f00"></line>
    <polyline points="9,50 20,50 20,60 40,60 40,50 60,50 60,60 90,60" stroke="#0d0" stroke-width="2" fill="none"></polyline>
    <polyline points="9,75 20,75 20,65 40,65 40,75 60,75 60,65 70,65 70,75 90,75" stroke="#0d0" stroke-width="2" fill="none"></polyline>
</svg>
</p>

<p>Now, do these effects matter? On a CRT, probably not, but you might see some fun color fringes here and there. But if you’re wondering why your Apple II image capture is looking so much worse than your other systems, even over composite? Well, stuff like this doesn’t help.</p>

<p>HIRES is by far the most important graphics mode on the Apple II; more games used it than any of the other options, and even business software used it to do things like implement 80-column text in software. A bit awkward and weird? People got over it. I’ll end this discussion with one of my more nostalgic vintage HIRES intro sequences, from <em>Ultima II</em>. Sorry about the lack of audio; I kept the internal speaker wired up separately when I installed the Mockingboard, and this game only uses the internal beeper.</p>

<p><video src="/assets/img/2apple2furious/u2.mp4" width="640px" controls="">You can&#39;t see this due to lacking video tag support. It&#39;s pretty cool, a dragon shows up and breathes fire.</video></p>

<p>I especially like the color animation on the “II” from toggling that seventh bit.</p>

<h2 id="kill-it-with-fire-or-a-transistor-will-do">Kill it with fire, or a transistor will do</h2>

<p>With all the above in mind, text mode <em>should</em> have the same color fringing everywhere that you see in HIRES graphics mode. The pixels are the same size, and Apple didn’t even design the font, so it’d be pretty impressive if it had been optimized to not fringe. But on most displays you’ll see nice pure white in Apple II text mode. How come?</p>

<p>Well, take a look at a screenshot of <em>Mission Asteroid</em> by Sierra. This uses a mixed mode, which I won’t really go into detail on how it works, but basically has four lines worth of text mode at the bottom of the screen underneath the graphics mode. And in this mode, the text fringes quite a bit. All those single-pixel horizontal lines suffer the same problem as the horizontal lines the snake was hanging out in in <em>Ultima II</em>.</p>

<p><img src="https://words.filippo.io/assets/img/yellow/mission.jpg" title="this is art hang it in the louvre" alt="A secretary sits at a desk. The game is a text adventure with a prompt at the bottom of the screen."/></p>

<p>If I had a Revision 0 Apple II, I’d have the same experience with the pure text mode. But I don’t– that’s because later revisions of the Apple II like mine added a circuit called the “color killer”, which removes the color burst when in text mode. In theory, a signal without a color burst should always be interpreted by the TV as a monochrome signal, because NTSC is backwards-compatible. The problem is, the color killer isn’t great– it merely reduces the color burst.</p>

<p>Here’s the signal with the color burst present, which I obtained by booting BASIC and typing <code>HGR</code>.</p>

<p><img src="https://words.filippo.io/assets/img/2apple2furious/color1.png" title="doctor please my color&#39;s burst" alt="Oscilloscope trace showing color burst"/></p>

<p>And here it is with the color burst on, which I obtained by typing <code>TEXT</code> with the same trace showing. I’m kind of surprised this ever doesn’t work, honestly– I guess that little bit of a cycle must be enough to confuse a sufficiently sensitive detector. Interesting, <em>Understanding the Apple II</em> suggests you mod your TV to detect the color burst, only suggesting modding the computer as a last resort, despite the many other computer mods recommended.</p>

<p><img src="https://words.filippo.io/assets/img/2apple2furious/color2.png" title="dont like all that noise" alt="Oscilloscope trace showing color burst gone, except for a cycle"/></p>

<p>This impact for me has always shown up on higher-quality scalers, which are desperate to try to extract a color signal. The color killer works fine on a cheap AV2HD box, but the Micromsoft Framemeister ends up with a fringy mess. Check out my <a href="https://words.filippo.io/2021/composite-conflict-completed.html#test-10-the-apple-">composite scaler competition</a> post for more details on that.</p>

<p><img src="https://words.filippo.io/assets/img/composhoot/apii-meister.gif" title="I talk about the color killer way too much" alt="Poorly color killed signal"/></p>

<h2 id="lores-mode">LORES mode</h2>

<p>The Apple II’s LORES graphics mode is very impressive. It can display any pixel on screen in any of 16 colors. Well, 15. More or less. There’s two greys that are usually the same. But still, far more colors than HIRES, and with pure pixel-level color selection. So what’s the catch? The resolution is a whopping 40x48. When even <a href="https://words.filippo.io/2024/radio-keith-orpheum.html">RCA Studio II</a> fans think you could use a few more pixels, you’re in trouble.</p>

<p><img src="https://words.filippo.io/assets/img/2apple2furious/duke1.png" title="Duke Nukem accepts all babes, regardless of how few pixels" alt="Duke Nukem port in LORES mode"/></p>

<p>That’s not to say LORES mode is useless. <a href="http://deater.net/weave/vmwprod/duke/">Deater</a> has done quite a few demakes into LORES mode; such a low resolution makes it fast to update the whole screen even doing things like parallax, and the mixed text/graphics mode means you can use text mode for things that absolutely have to be readable, like scores and such.</p>

<p><img src="https://words.filippo.io/assets/img/mock-me/little-brick-out.png" title="cuz she&#39;s a brick... OUT" alt="Game Over screen in Little Brick Out. Only a few bricks are broken and the game is telling me my score is not too good."/></p>

<p>And honestly LORES mode is part of the heart of the Apple II. It’s the mode that Wozniak created so that, having done <em>Breakout</em> in hardware for Atari, he could now do it in software with <em>Little Brick Out</em>. It’s the mode classic business simulation <em>Lemonade Stand</em> used. It justified the rainbow Apple logo. So how does it work?</p>

<p><img src="https://words.filippo.io/assets/img/2apple2furious/lores.png" title="I took a new version of this picture, because I love you" alt="LORES color palette from the Diagonstics II plus disk"/></p>

<p>The Koryuu I’m using here has a filter option that kind of blurs everything horizontally; I generally keep it disabled, but it does at least blur the lines together and gets rid of the high frequency noise. Of course, as we’ll see, that noise is the point. By the way, these color bars are from the Apple Diagnostics II+ disk.</p>

<p><img src="https://words.filippo.io/assets/img/2apple2furious/blurry.png" title="fuzzy" alt="LORES color palette from the Diagonstics II plus disk, blurred a bit"/></p>

<p>The LORES mode is twice the height of TEXT mode, and that’s no coincidence. The same screen data as text mode is used, with the same layout– the difference is, the two “nybbles” of each byte each become one of 16 colors, stacked on top of each other. A LORES pixel is 7 HIRES pixels wide, and four HIRES pixels tall.</p>

<p>But how does LORES get so many colors?</p>

<p>
<svg width="500" height="325" viewBox="0 0 100 65" xmlns="http://www.w3.org/2000/svg" title="oh gods please age well SVG" alt="Pixel timing diagram">
    
    <rect fill="#fff" x="0" y="0" width="100" height="100"></rect>
    <line stroke-width="2" x1="50" y1="0" x2="50" y2="100" stroke="#ccc"></line>
    <text x="5" y="07">14M (oscillator)</text>
    <polyline points="10,10 10,20 15,20 15,10 20,10 20,20 25,20 25,10 30,10 30,20 35,20 35,10 40,10 40,20 45,20 45,10 50,10 50,20 55,20 55,10 60,10 60,20 65,20 65,10 70,10 70,20 75,20 75,10 80,10 80,20 85,20 85,10 90,10 90,20" stroke="green" stroke-width="2" fill="none"></polyline>
    <text x="5" y="27">7M (TEXT pixel clock)</text>
    <polyline points="10,30 10,40 20,40 20,30 30,30 30,40 40,40 40,30 50,30 50,40 60,40 60,30 70,30 70,40 80,40 80,30 90,30 90,40" stroke="red" stroke-width="2" fill="none"></polyline>
    <text x="5" y="47">3.5M (color signal)</text>
    <polyline points="10,50 10,60 30,60 30,50 50,50 50,60 70,60 70,50 90,50" stroke="blue" stroke-width="2" fill="none"></polyline>
</svg>
</p>

<p>Notice that for every four cycles of the <code>14M</code> master oscillator, there’s one cycle of the 3.5MHz color burst signal. So if you repeat a four-bit pattern at the rate of the 14MHz clock, you’ll create a signal with a period of 3.5MHz. That’s all <code>LORES</code> mode is doing to create its colors. Sure, there will be components of the signal at other frequencies– you can see the OSSC trying to show the high-frequency lines, while other devices like an RF modulator might blur the high-frequency signal out into a flat luminance.</p>

<p><img src="https://words.filippo.io/assets/img/2apple2furious/lores2.png" title="i am the lores, i speak for the pixels" alt="LORES color palette in monochrome, showing lines"/></p>

<p>And the repeating patterns? That’s the genius part– they <em>are</em> the nybble in question. Take a look at the chart again. Repeating <code>0000</code> over and over again? Of course that’s a pure black. Repeating <code>1111</code> again and again? That’s pure white. What are the grey patterns? <code>0101</code> (5) and <code>1010</code> (10), which alternate fast enough that they don’t really have a low-frequency component, so no color to pick up on. There are two alternating patterns, so two greys. (For homework, consider what happens when those two greys are next to each other)</p>

<p>There is a bit more to it; for example, the phase inversion caused by having 7-pixel-wide slots is compensated for in LORES, but in general this is really a very clever graphics mode. Double HIRES mode on the 80-column Apple IIe uses the same pixel patterns, but that’s a story for another time.</p>

<h2 id="apple-ii-forever">Apple II Forever</h2>

<p><img src="https://words.filippo.io/assets/img/2apple2furious/oregon.png" title="not going to lie I have more nostalgia for the monochrome Mac oregon trail" alt="Oregon Trail: NICOLE has cholera"/></p>

<p>The Apple II is one of the oldest computers I recall using; my kindergarten in 1995 had an old machine they let the kids bang on to avoid them breaking anything new. And yet that computer still fascinates me to this day. I think it’s because it’s not only a useful machine, with a lot of history, but also that despite its rougher edges, it’s something that beckons to be understood. And is well documented to boot. Definitely beats the arcade boards for that.</p>

<p><img src="https://words.filippo.io/assets/img/2apple2furious/timezone.png" title="this is the opening to TIME ZONE, the biggest Apple II game of all time, and the most expensive at release. if you can afford this game, you can afford this big house" alt="YOU ARE IN FRONT OF YOUR OWN HOUSE. Underneath an image of a house, from the Apple II game TIME ZONE."/></p>

<p>Since Jim Sather’s book was crucial to the completion of this blog post, I think it’s only fair that we end with a quote from <em>Understanding the Apple 2</em>.</p>

<p><img src="https://words.filippo.io/assets/img/2apple2furious/suzy.png" title="what are you talking about" alt="...bus system. This means that a peripheral card can control all hardware features of the Apple. It is as if you could plug a Suzy brain into Johnny and have the Suzy brain control Johnny&#39;s body, a concept much in vogue in some circles."/></p>

<p>Jim Sather is in way cooler circles than me.</p>

  </div>

  
</article>

      </div>
    </div></div>
  </body>
</html>
