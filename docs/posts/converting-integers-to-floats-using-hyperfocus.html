<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.m-ou.se/floats/">Original</a>
    <h1>Converting Integers to Floats Using Hyperfocus</h1>
    
    <div id="readability-page-1" class="page"><div>
      <p>A few years ago, due to some random chain of events, I ended up implementing a conversion from 128 bit integers to 64 bit floats.
This would’ve turned out to be a complete waste of time,
except that my final version is faster than the builtin conversion every compiler I tested.
In this blog post, I’ll explain what happened, how floats work, how this conversion works, and how it got a bit out of hand.</p>
<h2 id="prologue">Prologue</h2>
<p>It was a beautiful day in August, a few summers ago,
when <a href="https://twitter.com/yaahc_">a friend of mine</a>
was reviewing a pull request containing something like the following snippet:</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>f64</span>::<span>from_str</span><span>(</span><span>&amp;</span><span>some_u128</span><span>.</span><span>to_string</span><span>()).</span><span>unwrap</span><span>()</span><span>
</span></span></span></code></pre></div><p>This was used to convert a <code>u128</code> to a <code>f64</code>.
It did so by converting it to a string first, and parsing that as a float next.
Since this method isn’t great in various ways,
she went to her <em>secret underground <del>lair</del> Discord Server</em> to ask the <em><del>leet hackers</del> bored programmers</em> there if anyone had a better way of doing this.</p>
<p>In an attempt to appear helpful but actually just trying to <a href="https://twitter.com/reduct_rs/status/1222658513459019777">impress</a> some of the people there,
I implemented a sort-of mostly correct version of this conversion by calculating the raw bit representation of the <code>f64</code> and using
<a href="https://doc.rust-lang.org/stable/std/primitive.f64.html#method.from_bits"><code>f64::from_bits</code></a>.</p>
<p>After rewriting it several times—a process which involved
fixing bugs for certain rarely used values like zero,
wrongly accusing <code>u128::to_string</code> of having bugs,
implementing rounding almost correctly,
wrongly accusing <code>f64::from_str</code> of having bugs,
implementing rounding slightly more correctly,
and trying to write comments but giving up because it’s undecipherable anyway—I finally
ended up with <a href="https://twitter.com/m_ou_se/status/1291775088107433987">about 7 lines of unreadable bit twiddling code</a>
that seemed to do the trick,
while implementing the correct rounding mode <sub><sup><s>almost</s></sup></sub> perfectly.</p>
<p>Everyone was slightly disgusted and slightly impressed.</p>
<p>Mission accomplished.</p>
<p>..</p>
<p>Eventually we came up with something even shorter:</p>
<p>..</p>
<p>Uh.</p>
<p>Yeah.</p>
<p>So.</p>
<p>Somehow nobody involved even considered the possibility that <code>_ as f64</code> might just work.
Between <code>u128</code> being experimental until somewhat recently and no mainstream processor providing this conversion natively,
we had all simply assumed incorrectly that this was not a thing.</p>
<p>But it was.</p>
<p>And I felt tricked.</p>
<p>By Rustc.</p>
<p>While I was sitting there, struggling for hours <em>banging virtual rocks together</em> to light a spark to
make a campfire, Rustc was just sitting there with a lighter in its pocket.
“Hey you never asked,” Rustc laughed, “I figured you were just having fun.”</p>
<p>So, out of <em>pure spite</em> and a strong sense of needing to prove that <em>yes I am having fun damnit!</em>,
I spent the next several days and nights angrily writing many variants of my code, determined to take revenge on Rustc, somehow.</p>
<hr/>
<p>In this blog post, I’ll try to trace back my steps to implement this integer-to-floating-point conversion
until we reach the same seven lines of unreadable code as I did in 2020.</p>
<p>But first, we’ll need to understand how floating point values are represented as bits.</p>
<h2 id="the-bits-of-an-f64">The bits of an <code>f64</code></h2>
<p>The 64 bits of a <code>f64</code> encode a floating point value following the IEEE 754 binary64 standard,
also known as a “double precision floating point value” or <code>double</code>.
Pretty much all processors that support floating point calculations support this format.</p>
<p>This format splits up the 64 bits into three parts: one sign bit, an 11 bit <em>exponent</em>, and a 52 bit <em>mantissa</em>:</p>
<pre><code>
f64 bits = 0 10001110110 1100100101000100001000100010001000011111010001010101
           │ └─┬───────┘ └────────────┬─────────────────────────────────────┘
     sign ─┘   └─ exponent            └─ mantissa
</code></pre>
<p>The sign bit indicates whether the number is positive (0) or negative (1).
The next 11 bits represent a number, the <em>exponent</em>, which gives position of the first <code>1</code> bit of the binary floating point number.
1023 if the first <code>1</code> bit is immediately left of the decimal point (i.e. in the ones place),
1024 if it is in the second digit left of the decimal point (i.e. in the twos place),
and so on, and in the other direction too: 1022 if it is immediately right of the decimal point (in the halves place), etc.
The remaining 52 bits, called the <em>mantissa</em>, are the bits that come right after that first <code>1</code> bit of the number.</p>
<p>So, using the letter <code>m</code> to represent the 52 bits of the mantissa,
this is what the decoded binary floating point number looks like
for different values of the exponent:</p>
<pre><code>
   :   \
1026    1mmm.mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm
1025     1mm.mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm
1024      1m.mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm
1023       1.mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm
1022       0.1mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm
1021       0.01mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm
1020       0.001mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm
   :            \
</code></pre>
<p>A concrete example: the value 9.75 in binary looks like 1001.11,
so it is represented as a <code>f64</code> with an exponent of 1026, and a (binary) mantissa of 001110000⋯0.</p>
<pre><code>
9.75 in decimal = 1001.11 in binary
                  │└─┬──┘
                  │  └─ mantissa: the bits after the first 1 bit
                  └─ position of the first 1 bit: 3

f64 bits = 0 10000000010 0011100000000000000000000000000000000000000000000000
           │ └─┬───────┘ └────────────┬─────────────────────────────────────┘
     sign ─┘   └─ exponent (1023+3)   └─ mantissa
</code></pre>
<p>If we extend the table above all the way to the top, we get to extremely high numbers.
The maximum exponent value of 2047 is used to represent the special ’not a number’ and infinity values.</p>
<pre><code>
2047    Infinity or NaN
2046    1mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm00000⋯00000.0
2045     1mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm0000⋯00000.0
2044      1mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm000⋯00000.0
2043       1mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm00⋯00000.0
   :        \                              960 zero bits omitted ─┘
</code></pre>
<p>Similarly, if we extend the table all the way to the bottom, we get to the extremely small numbers.
The minimum exponent value of zero is also special, and used for the extremely small <em>subnormal</em> numbers.
Going from an exponent of one to zero does not move the mantissa another bit to the right,
but instead turns the first <code>1</code> bit into a <code>0</code> bit.
This allows us to represent the number zero: an exponent of zero and a mantissa of zero.
In other words, <code>f64::from_bits(0)</code> equals <code>0.0</code>.</p>
<pre><code>
   :                 \
   4       0.00000⋯0001mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm
   3       0.00000⋯00001mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm
   2       0.00000⋯000001mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm
   1       0.00000⋯0000001mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm
   0       0.00000⋯0000000mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm (subnormals)
                  └─ 1010 zero bits omitted
</code></pre>
<h2 id="converting-integers">Converting integers</h2>
<p>Back to the original problem: converting an 128-bit unsigned integer (<code>u128</code>) to an <code>f64</code>:</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>pub</span><span> </span><span>fn</span> <span>u128_to_f64</span><span>(</span><span>x</span>: <span>u128</span><span>)</span><span> </span>-&gt; <span>f64</span> <span>{</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>bits</span>: <span>u64</span> <span>=</span><span> </span><span>???</span><span>;</span><span> </span><span>// TODO
</span></span></span><span><span><span></span><span>    </span><span>f64</span>::<span>from_bits</span><span>(</span><span>bits</span><span>)</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>The input being an integer means we never have to deal with subnormals, except for zero:</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>    </span><span>if</span><span> </span><span>x</span><span> </span><span>==</span><span> </span><span>0</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>return</span><span> </span><span>0.0</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span></code></pre></div><p>Edge-case handled. Now we can continue with the fun part: every other integer.</p>
<p>As the input is unsigned, we already know one bit: the sign bit is always zero.</p>
<p>One bit down, sixty-three left!</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>    </span><span>let</span><span> </span><span>sign</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>exponent</span><span> </span><span>=</span><span> </span><span>??</span><span>;</span><span> </span><span>// TODO
</span></span></span><span><span><span></span><span>    </span><span>let</span><span> </span><span>mantissa</span><span> </span><span>=</span><span> </span><span>??</span><span>;</span><span> </span><span>// TODO
</span></span></span><span><span><span></span><span>    </span><span>let</span><span> </span><span>bits</span>: <span>u64</span> <span>=</span><span> </span><span>(</span><span>sign</span><span> </span><span>&lt;&lt;</span><span> </span><span>63</span><span>)</span><span> </span><span>+</span><span> </span><span>(</span><span>exponent</span><span> </span><span>&lt;&lt;</span><span> </span><span>52</span><span>)</span><span> </span><span>+</span><span> </span><span>mantissa</span><span>;</span><span>
</span></span></span></code></pre></div><p>Next up: the exponent. For this we need to know the position of the highest <code>1</code> bit, and add 1023 because that’s how floats work.
Easy, just use <code>u128::leading_zeros</code> to count the zeros before the first <code>1</code> bit, and subtract that from 127 to get the position of the <code>1</code> bit:</p>
<pre><code>
          ┌─ n leading zeros
          │     ┌─ first 1 bit
        ┌─┴───┐ │
input = 000⋯000 1 110010010100010000100010001000100001111101000101010010101001011⋯000101011
        │       │                                                                         │
     bit 127    │                                                                       bit 0
            bit (127 - n)
</code></pre>
<p>So,</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>    </span><span>let</span><span> </span><span>n</span><span> </span><span>=</span><span> </span><span>x</span><span>.</span><span>leading_zeros</span><span>();</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>exponent</span><span> </span><span>=</span><span> </span><span>(</span><span>127</span><span> </span><span>-</span><span> </span><span>n</span><span>)</span><span> </span><span>+</span><span> </span><span>1023</span><span>;</span><span>
</span></span></span></code></pre></div><p>Boom, 11 more bits done. 52 left: the mantissa.</p>
<p>For the mantissa, we need the 52 bits that followed the highest <code>1</code> bit.
If we left-shift away all the leading zeros and then also left-shift away the highest <code>1</code> bit,
what remains are the bits right after that first <code>1</code> bit.
Then all we need to do is right-shift the (128 − 52 =) 76 unwanted bits away:</p>
<pre><code>
          ┌─ n leading zeros
          │     ┌─ first 1 bit           ┌─ next 52 bits                 ┌─ remaining bits
        ┌─┴───┐ │ ┌──────────────────────┴───────────────────────────┐ ┌─┴─────────────────┐
input = 000⋯000 1 1100100101000100001000100010001000011111010001010100 10101001011⋯000101011
                │ │                                                  │
        ┌───────┘ │                                                  │
        │ ┌───────┘                                          ┌───────┘
        │ │                                                  │
 &lt;&lt; n = 1 1100100101000100001000100010001000011111010001010100 10101001011⋯000101011 000⋯000
          │                                                  │
        ┌─┘                                                ┌─┘
        │                                                  │
 &lt;&lt; 1 = 1100100101000100001000100010001000011111010001010100 10101001011⋯000101011  000⋯0000
        │                                                  │
        └───────────────────────────────┐                  └───────────────────────────────┐
                                        │                                                  │
&gt;&gt; 76 = 000000000000000⋯000000000000000 1100100101000100001000100010001000011111010001010100
                                        │                                                  │
               f64 bits = 0 10001110110 1100100101000100001000100010001000011111010001010100
                          │ └─┬───────┘ └────────────┬─────────────────────────────────────┘
                    sign ─┘   └─ exponent            └─ mantissa
</code></pre>
<p>So, just three shift operations:</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>    </span><span>let</span><span> </span><span>mantissa</span><span> </span><span>=</span><span> </span><span>x</span><span> </span><span>&lt;&lt;</span><span> </span><span>n</span><span> </span><span>&lt;&lt;</span><span> </span><span>1</span><span> </span><span>&gt;&gt;</span><span> </span><span>76</span><span>;</span><span>
</span></span></span></code></pre></div><p>So.. That’s it? We’re done?</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>pub</span><span> </span><span>fn</span> <span>u128_to_f64</span><span>(</span><span>x</span>: <span>u128</span><span>)</span><span> </span>-&gt; <span>f64</span> <span>{</span><span>
</span></span></span><span><span><span>    </span><span>if</span><span> </span><span>x</span><span> </span><span>==</span><span> </span><span>0</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>return</span><span> </span><span>0.0</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>sign</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>n</span><span> </span><span>=</span><span> </span><span>x</span><span>.</span><span>leading_zeros</span><span>();</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>exponent</span><span> </span><span>=</span><span> </span><span>(</span><span>127</span><span> </span><span>-</span><span> </span><span>n</span><span>)</span><span> </span><span>+</span><span> </span><span>1023</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>mantissa</span><span> </span><span>=</span><span> </span><span>x</span><span> </span><span>&lt;&lt;</span><span> </span><span>n</span><span> </span><span>&lt;&lt;</span><span> </span><span>1</span><span> </span><span>&gt;&gt;</span><span> </span><span>76</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>bits</span><span> </span><span>=</span><span> </span><span>(</span><span>sign</span><span> </span><span>&lt;&lt;</span><span> </span><span>63</span><span>)</span><span> </span><span>+</span><span> </span><span>((</span><span>exponent</span><span> </span><span>as</span><span> </span><span>u64</span><span>)</span><span> </span><span>&lt;&lt;</span><span> </span><span>52</span><span>)</span><span> </span><span>+</span><span> </span><span>mantissa</span><span> </span><span>as</span><span> </span><span>u64</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>f64</span>::<span>from_bits</span><span>(</span><span>bits</span><span>)</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>#[test]</span><span>
</span></span></span><span><span><span></span><span>fn</span> <span>test</span><span>()</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>assert_eq!</span><span>(</span><span>u128_to_f64</span><span>(</span><span>1234</span><span>),</span><span> </span><span>1234.0</span><span>);</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><div><pre tabindex="0"><code data-lang="fallback"><span><span>$ cargo test
</span></span><span><span>   Compiling stuff v0.1.0
</span></span><span><span>    Finished test [unoptimized + debuginfo] target(s) in 0.43s
</span></span><span><span>     Running unittests src/lib.rs
</span></span><span><span>
</span></span><span><span>running 1 test
</span></span><span><span>test test ... ok
</span></span><span><span>
</span></span><span><span>test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</span></span></code></pre></div><p><span>🎉</span></p>
<p>Yes!</p>
<p>It works for one number!
Therefore, our code must work correctly for all numbers. 😌</p>
<p>Okay, let’s try one more:</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>    </span><span>assert_eq!</span><span>(</span><span>u128_to_f64</span><span>(</span><span>123_456_789_123_456_789</span><span>),</span><span> </span><span>123_456_789_123_456_789.0</span><span>);</span><span>
</span></span></span></code></pre></div><div><pre tabindex="0"><code data-lang="fallback"><span><span>$ cargo test
</span></span><span><span>…
</span></span><span><span>test result: ok
</span></span></code></pre></div><p>Works great!
It works for two numbers, which means we can now vaguely gesture at
<a href="https://en.wikipedia.org/wiki/Mathematical_induction">mathematical induction</a>,
and happily conclude it works for all numbers. 😌</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>    </span><span>assert_eq!</span><span>(</span><span>u128_to_f64</span><span>(</span><span>123_456_789_123_456_789_123</span><span>),</span><span> </span><span>123_456_789_123_456_789_123.0</span><span>);</span><span>
</span></span></span></code></pre></div><div><pre tabindex="0"><code data-lang="fallback"><span><span>$ cargo test
</span></span><span><span>…
</span></span><span><span>test test ... FAILED
</span></span><span><span>
</span></span><span><span>failures:
</span></span><span><span>
</span></span><span><span>---- test stdout ----
</span></span><span><span>thread &#39;test&#39; panicked at &#39;assertion failed: `(left == right)`
</span></span><span><span>  left: `1.2345678912345678e20`,
</span></span><span><span> right: `1.234567891234568e20`&#39;, src/lib.rs:17:5
</span></span></code></pre></div><p>Oh.</p>
<p>Maybe not.</p>
<h2 id="rounding">Rounding</h2>
<p>As it turns out, we shouldn’t just ignore the bits that don’t fit in the <code>f64</code>.
We cannot store all 128 bits in it, since we only have space for 53 bits:
the first <code>1</code> bit encoded by the exponent, and the next 52 bits stored in the mantissa.
Depending on the location of the first <code>1</code> bit,
there are up to (128 − 53 =) 75 bits that get lost.</p>
<p>The IEEE 754 standard tells us that we shouldn’t just ignore those bits,
effectively truncating the number after its 53rd significant bit,
but instead use round the number to the closest number a <code>f64</code> can represent.</p>
<pre><code>
The number from our test:
123_456_789_123_456_789_123 = 00⋯001101011000101001110100111111001101100001101111100110110101010000011
                                   └─────────────┬─────────────────────────────────────┘
                                                 └─ 53 significant bits

The (truncated) number our function returned:
123_456_789_123_456_778_240 = 00⋯001101011000101001110100111111001101100001101111100110100000000000000
                                                                                        └──────────┬─┘
                                                                          remaining bits are gone ─┘

The right answer, by rounding to the nearest representable number:
123_456_789_123_456_794_624 = 00⋯001101011000101001110100111111001101100001101111100111000000000000000
                                                                                      ├┘
                                                           the number was rounded up ─┘
</code></pre>
<p>The specification also tells us to break ties by rounding to an even mantissa: the one that ends in a zero bit.</p>
<p>So, in decimal: 9.25 rounds to 9, 9.75 rounds to 10, and 9.5 also rounds to 10, but 8.5 rounds to 8.</p>
<p>Or, in binary: 1001.01 rounds to 1001, 1001.11 rounds to 1010, and 1001.10 also rounds to 1010, but 1000.10 rounds to 1000.</p>
<p>Applying this to properly rounding the mantissa in our conversion,
this means that we need to check if the bits we’re throwing away
are less, equal, or higher than 100⋯00 in binary.
If we left-shift the original number to shift out the 53 significant bits,
we are left with exactly the bits that we dropped before.
That value will tell us whether to round up or down:</p>
<pre><code>
         ┌─ first 1 bit           ┌─ next 52 bits                 ┌─ 75 dropped bits
         │ ┌──────────────────────┴───────────────────────────┐ ┌─┴─────────────────────────┐
x &lt;&lt; n = 1 1100100101000100001000100010001000011111010001010100 10101001011⋯000101011 000⋯000
                                                                │                           │
         ┌──────────────────────────────────────────────────────┘                  ┌────────┘
         │                                                                         │
 &lt;&lt; 53 = 101010010110000001111010100100101000100111101010110100000100010101100000000 000⋯000
       &gt; 100000000000000000000000000000000000000000000000000000000000000000000000000 000⋯000
       │
       └─ bigger, so we round up
</code></pre>
<p>This gives us the following code, if we also include the round-to-even tie-breaking part:</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>mantissa</span><span> </span><span>=</span><span> </span><span>x</span><span> </span><span>&lt;&lt;</span><span> </span><span>n</span><span> </span><span>&lt;&lt;</span><span> </span><span>1</span><span> </span><span>&gt;&gt;</span><span> </span><span>76</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>dropped_bits</span><span> </span><span>=</span><span> </span><span>x</span><span> </span><span>&lt;&lt;</span><span> </span><span>n</span><span> </span><span>&lt;&lt;</span><span> </span><span>53</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>if</span><span> </span><span>dropped_bits</span><span> </span><span>&lt;</span><span> </span><span>1</span><span> </span><span>&lt;&lt;</span><span> </span><span>127</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>// round down
</span></span></span><span><span><span></span><span>    </span><span>}</span><span> </span><span>else</span><span> </span><span>if</span><span> </span><span>dropped_bits</span><span> </span><span>&gt;</span><span> </span><span>1</span><span> </span><span>&lt;&lt;</span><span> </span><span>127</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>// round up
</span></span></span><span><span><span></span><span>        </span><span>mantissa</span><span> </span><span>+=</span><span> </span><span>1</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>// tie! round to even
</span></span></span><span><span><span></span><span>        </span><span>if</span><span> </span><span>mantissa</span><span> </span><span>&amp;</span><span> </span><span>1</span><span> </span><span>==</span><span> </span><span>1</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>            </span><span>mantissa</span><span> </span><span>+=</span><span> </span><span>1</span><span>;</span><span>
</span></span></span><span><span><span>        </span><span>}</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span></code></pre></div><p>Okay great, but now we have another problem: the mantissa might no longer fit in the 52 bits it needs to fit in,
if it is rounded up beyond its maximum.
If that happens, it means the entire resulting number has become one digit longer, similar to how rounding 999 up to 1000 increases
it from three to four digits.
So, in that case we’ll need to increase the exponent and clear out the remaining bits:</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>    </span><span>if</span><span> </span><span>mantissa</span><span> </span><span>==</span><span> </span><span>1</span><span> </span><span>&lt;&lt;</span><span> </span><span>53</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>exponent</span><span> </span><span>+=</span><span> </span><span>1</span><span>;</span><span>
</span></span></span><span><span><span>        </span><span>mantissa</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span></code></pre></div><p>Okay.</p>
<p>Does it work now?</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>pub</span><span> </span><span>fn</span> <span>u128_to_f64</span><span>(</span><span>x</span>: <span>u128</span><span>)</span><span> </span>-&gt; <span>f64</span> <span>{</span><span>
</span></span></span><span><span><span>    </span><span>if</span><span> </span><span>x</span><span> </span><span>==</span><span> </span><span>0</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>return</span><span> </span><span>0.0</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>sign</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>n</span><span> </span><span>=</span><span> </span><span>x</span><span>.</span><span>leading_zeros</span><span>();</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>exponent</span><span> </span><span>=</span><span> </span><span>(</span><span>127</span><span> </span><span>-</span><span> </span><span>n</span><span>)</span><span> </span><span>+</span><span> </span><span>1023</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>mantissa</span><span> </span><span>=</span><span> </span><span>x</span><span> </span><span>&lt;&lt;</span><span> </span><span>n</span><span> </span><span>&lt;&lt;</span><span> </span><span>1</span><span> </span><span>&gt;&gt;</span><span> </span><span>76</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>dropped_bits</span><span> </span><span>=</span><span> </span><span>x</span><span> </span><span>&lt;&lt;</span><span> </span><span>n</span><span> </span><span>&lt;&lt;</span><span> </span><span>53</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>if</span><span> </span><span>dropped_bits</span><span> </span><span>&lt;</span><span> </span><span>1</span><span> </span><span>&lt;&lt;</span><span> </span><span>127</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>// round down.
</span></span></span><span><span><span></span><span>    </span><span>}</span><span> </span><span>else</span><span> </span><span>if</span><span> </span><span>dropped_bits</span><span> </span><span>&gt;</span><span> </span><span>1</span><span> </span><span>&lt;&lt;</span><span> </span><span>127</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>// round up
</span></span></span><span><span><span></span><span>        </span><span>mantissa</span><span> </span><span>+=</span><span> </span><span>1</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>// tie! round to even
</span></span></span><span><span><span></span><span>        </span><span>if</span><span> </span><span>mantissa</span><span> </span><span>&amp;</span><span> </span><span>1</span><span> </span><span>==</span><span> </span><span>1</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>            </span><span>mantissa</span><span> </span><span>+=</span><span> </span><span>1</span><span>;</span><span>
</span></span></span><span><span><span>        </span><span>}</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span>    </span><span>if</span><span> </span><span>mantissa</span><span> </span><span>==</span><span> </span><span>1</span><span> </span><span>&lt;&lt;</span><span> </span><span>53</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>exponent</span><span> </span><span>+=</span><span> </span><span>1</span><span>;</span><span>
</span></span></span><span><span><span>        </span><span>mantissa</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>bits</span><span> </span><span>=</span><span> </span><span>(</span><span>sign</span><span> </span><span>&lt;&lt;</span><span> </span><span>63</span><span>)</span><span> </span><span>+</span><span> </span><span>((</span><span>exponent</span><span> </span><span>as</span><span> </span><span>u64</span><span>)</span><span> </span><span>&lt;&lt;</span><span> </span><span>52</span><span>)</span><span> </span><span>+</span><span> </span><span>mantissa</span><span> </span><span>as</span><span> </span><span>u64</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>f64</span>::<span>from_bits</span><span>(</span><span>bits</span><span>)</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>#[test]</span><span>
</span></span></span><span><span><span></span><span>fn</span> <span>test</span><span>()</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>    </span><span>assert_eq!</span><span>(</span><span>u128_to_f64</span><span>(</span><span>1234</span><span>),</span><span> </span><span>1234.0</span><span>);</span><span>
</span></span></span><span><span><span>    </span><span>assert_eq!</span><span>(</span><span>u128_to_f64</span><span>(</span><span>123_456_789_123_456_789</span><span>),</span><span> </span><span>123_456_789_123_456_789.0</span><span>);</span><span>
</span></span></span><span><span><span>    </span><span>assert_eq!</span><span>(</span><span>u128_to_f64</span><span>(</span><span>123_456_789_123_456_788</span><span>),</span><span> </span><span>123_456_789_123_456_788.0</span><span>);</span><span>
</span></span></span><span><span><span>    </span><span>assert_eq!</span><span>(</span><span>u128_to_f64</span><span>(</span><span>123_456_789_123_456_789_123</span><span>),</span><span> </span><span>123_456_789_123_456_789_123.0</span><span>);</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><div><pre tabindex="0"><code data-lang="fallback"><span><span>$ cargo test
</span></span><span><span>…
</span></span><span><span>test test ... ok
</span></span></code></pre></div><p><span>🎉</span></p>
<p>Yes!</p>
<p>Testing the other 340282366920938463463374607431768211452 integers is left as an exercise to the reader.</p>
<h2 id="cleaning-up">Cleaning up</h2>
<p>Okay this is great and all, but the code could be a lot shorter if we clean things up a bit:</p>
<ul>
<li>Remove the useless <code>sign</code> variable.</li>
<li>Inline the <code>bits</code> variable into the final expression.</li>
<li>Extract <code>x &lt;&lt; n</code> into its own variable, <code>y</code>, to avoid repetition.</li>
<li>Simplify the if-else-if-else-if structure for rounding.
It either increments the mantissa by one, or not.
So this can be written as a single condition.</li>
</ul>
<p>Poof, much better:</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>pub</span><span> </span><span>fn</span> <span>u128_to_f64</span><span>(</span><span>x</span>: <span>u128</span><span>)</span><span> </span>-&gt; <span>f64</span> <span>{</span><span>
</span></span></span><span><span><span>    </span><span>if</span><span> </span><span>x</span><span> </span><span>==</span><span> </span><span>0</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>return</span><span> </span><span>0.0</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>n</span><span> </span><span>=</span><span> </span><span>x</span><span>.</span><span>leading_zeros</span><span>();</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>y</span><span> </span><span>=</span><span> </span><span>x</span><span> </span><span>&lt;&lt;</span><span> </span><span>n</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>exponent</span><span> </span><span>=</span><span> </span><span>(</span><span>127</span><span> </span><span>-</span><span> </span><span>n</span><span>)</span><span> </span><span>+</span><span> </span><span>1023</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>mantissa</span><span> </span><span>=</span><span> </span><span>y</span><span> </span><span>&lt;&lt;</span><span> </span><span>1</span><span> </span><span>&gt;&gt;</span><span> </span><span>76</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>dropped_bits</span><span> </span><span>=</span><span> </span><span>y</span><span> </span><span>&lt;&lt;</span><span> </span><span>53</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>if</span><span> </span><span>dropped_bits</span><span> </span><span>&gt;</span><span> </span><span>1</span><span> </span><span>&lt;&lt;</span><span> </span><span>127</span><span> </span><span>||</span><span> </span><span>(</span><span>dropped_bits</span><span> </span><span>==</span><span> </span><span>1</span><span> </span><span>&lt;&lt;</span><span> </span><span>127</span><span> </span><span>&amp;&amp;</span><span> </span><span>mantissa</span><span> </span><span>&amp;</span><span> </span><span>1</span><span> </span><span>==</span><span> </span><span>1</span><span>)</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>mantissa</span><span> </span><span>+=</span><span> </span><span>1</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span>    </span><span>if</span><span> </span><span>mantissa</span><span> </span><span>==</span><span> </span><span>1</span><span> </span><span>&lt;&lt;</span><span> </span><span>53</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>exponent</span><span> </span><span>+=</span><span> </span><span>1</span><span>;</span><span>
</span></span></span><span><span><span>        </span><span>mantissa</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span>    </span><span>f64</span>::<span>from_bits</span><span>(((</span><span>exponent</span><span> </span><span>as</span><span> </span><span>u64</span><span>)</span><span> </span><span>&lt;&lt;</span><span> </span><span>52</span><span>)</span><span> </span><span>+</span><span> </span><span>mantissa</span><span> </span><span>as</span><span> </span><span>u64</span><span>)</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><h2 id="tricks">Tricks</h2>
<p>Now let’s do some cool tricks to <del>obfuscate</del> optimize things even further.</p>
<p>First, let’s look at the final <code>if</code>, which handles an overflowing mantissa when rounding up.
This <code>if</code> is important, because otherwise the 53rd bit
of the overflowed mantissa would end up getting added to the 53rd bit of the final bit representation of the float,
which is not part of the 52-bit mantissa, but instead is where the least significant bit of the exponent goes.</p>
<pre><code>
                           ┌─ 53rd bit
                           │
max. mantissa = 000000000000 1111111111111111111111111111111111111111111111111111
          + 1 = 000000000001 0000000000000000000000000000000000000000000000000000
                           │ │                                                  │
    f64 bits = 0 10001110111 0000000000000000000000000000000000000000000000000000
               │ └─┬───────┘ └────────────┬─────────────────────────────────────┘
         sign ─┘   └─ exponent!           └─ mantissa (only 52 bits!)
</code></pre>
<p>So, to prevent the mantissa from overflowing outside of its bounds,
this <code>if</code> handles this case by removing that bit from the mantissa,
and adding a 1 to the exponent instead.
Makes sense.</p>
<p>Uh.</p>
<p>Wait.</p>
<p>Back up.</p>
<p>To prevent the 53rd bit from getting added to the 53rd bit.. we remove it and instead add it to the exponent.. which..
is stored at the 53rd bit.</p>
<p>Well that sounds useless.</p>
<p>Okay cool.</p>
<p>So, we remove that entire <code>if</code>, and get the exact same results as before:</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>pub</span><span> </span><span>fn</span> <span>u128_to_f64</span><span>(</span><span>x</span>: <span>u128</span><span>)</span><span> </span>-&gt; <span>f64</span> <span>{</span><span>
</span></span></span><span><span><span>    </span><span>if</span><span> </span><span>x</span><span> </span><span>==</span><span> </span><span>0</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>return</span><span> </span><span>0.0</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>n</span><span> </span><span>=</span><span> </span><span>x</span><span>.</span><span>leading_zeros</span><span>();</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>y</span><span> </span><span>=</span><span> </span><span>x</span><span> </span><span>&lt;&lt;</span><span> </span><span>n</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>exponent</span><span> </span><span>=</span><span> </span><span>(</span><span>127</span><span> </span><span>-</span><span> </span><span>n</span><span>)</span><span> </span><span>+</span><span> </span><span>1023</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>mantissa</span><span> </span><span>=</span><span> </span><span>y</span><span> </span><span>&lt;&lt;</span><span> </span><span>1</span><span> </span><span>&gt;&gt;</span><span> </span><span>76</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>dropped_bits</span><span> </span><span>=</span><span> </span><span>y</span><span> </span><span>&lt;&lt;</span><span> </span><span>53</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>if</span><span> </span><span>dropped_bits</span><span> </span><span>&gt;</span><span> </span><span>1</span><span> </span><span>&lt;&lt;</span><span> </span><span>127</span><span> </span><span>||</span><span> </span><span>(</span><span>dropped_bits</span><span> </span><span>==</span><span> </span><span>1</span><span> </span><span>&lt;&lt;</span><span> </span><span>127</span><span> </span><span>&amp;&amp;</span><span> </span><span>mantissa</span><span> </span><span>&amp;</span><span> </span><span>1</span><span> </span><span>==</span><span> </span><span>1</span><span>)</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>mantissa</span><span> </span><span>+=</span><span> </span><span>1</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span>    </span><span>f64</span>::<span>from_bits</span><span>(((</span><span>exponent</span><span> </span><span>as</span><span> </span><span>u64</span><span>)</span><span> </span><span>&lt;&lt;</span><span> </span><span>52</span><span>)</span><span> </span><span>+</span><span> </span><span>mantissa</span><span> </span><span>as</span><span> </span><span>u64</span><span>)</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><h2 id="more-tricks">More tricks</h2>
<p>Now let’s look at the shift operations.
The <code>y &lt;&lt; 1 &gt;&gt; 76</code> operation looks almost like it could just be <code>y &gt;&gt; 75</code>.
Except it can’t, because that <code>&lt;&lt; 1</code> is important to get rid of the most significant 1 bit.
If we didn’t remove that bit, it would end up in the 53rd of the mantissa,
which will end up in the exponent field, resulting in an off-by-one exponent:</p>
<pre><code>
                ┌─ first 1 bit           ┌─ next 52 bits
                │ ┌──────────────────────┴───────────────────────────┐
    x = 000⋯000 1 1100100101000100001000100010001000011111010001010100 10101001011⋯000101011
                │ │                                                  │
        ┌───────┘ │                                                  │
        │ ┌───────┘                                          ┌───────┘
        │ │                                                  │
 &lt;&lt; n = 1 1100100101000100001000100010001000011111010001010100 10101001011⋯000101011 000⋯000
        │ │                                                  │
        │ └─────────────────────────────┐                    └─────────────────────────────┐
        └─────────────────────────────┐ │                                                  │
                                      │ │                                                  │
&gt;&gt; 75 = 00000000000000⋯00000000000000 1 1100100101000100001000100010001000011111010001010100
                                      │ │                                                  │
               f64 bits = 0 10001110111 1100100101000100001000100010001000011111010001010100
                          │ └─┬───────┘ └────────────┬─────────────────────────────────────┘
                    sign ─┘   └─ exponent            └─ mantissa
</code></pre>
<p>But! We can deal with that!
We can introduce a counteracting off-by-one error to correct the exponent back
to what it should be by changing the <code>1023</code> constant to <code>1022</code>. :)</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>pub</span><span> </span><span>fn</span> <span>u128_to_f64</span><span>(</span><span>x</span>: <span>u128</span><span>)</span><span> </span>-&gt; <span>f64</span> <span>{</span><span>
</span></span></span><span><span><span>    </span><span>if</span><span> </span><span>x</span><span> </span><span>==</span><span> </span><span>0</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>return</span><span> </span><span>0.0</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>n</span><span> </span><span>=</span><span> </span><span>x</span><span>.</span><span>leading_zeros</span><span>();</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>y</span><span> </span><span>=</span><span> </span><span>x</span><span> </span><span>&lt;&lt;</span><span> </span><span>n</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>exponent</span><span> </span><span>=</span><span> </span><span>(</span><span>127</span><span> </span><span>-</span><span> </span><span>n</span><span>)</span><span> </span><span>+</span><span> </span><span>1022</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>mantissa</span><span> </span><span>=</span><span> </span><span>y</span><span> </span><span>&gt;&gt;</span><span> </span><span>75</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>dropped_bits</span><span> </span><span>=</span><span> </span><span>y</span><span> </span><span>&lt;&lt;</span><span> </span><span>53</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>if</span><span> </span><span>dropped_bits</span><span> </span><span>&gt;</span><span> </span><span>1</span><span> </span><span>&lt;&lt;</span><span> </span><span>127</span><span> </span><span>||</span><span> </span><span>(</span><span>dropped_bits</span><span> </span><span>==</span><span> </span><span>1</span><span> </span><span>&lt;&lt;</span><span> </span><span>127</span><span> </span><span>&amp;&amp;</span><span> </span><span>mantissa</span><span> </span><span>&amp;</span><span> </span><span>1</span><span> </span><span>==</span><span> </span><span>1</span><span>)</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>mantissa</span><span> </span><span>+=</span><span> </span><span>1</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span>    </span><span>f64</span>::<span>from_bits</span><span>(((</span><span>exponent</span><span> </span><span>as</span><span> </span><span>u64</span><span>)</span><span> </span><span>&lt;&lt;</span><span> </span><span>52</span><span>)</span><span> </span><span>+</span><span> </span><span>mantissa</span><span> </span><span>as</span><span> </span><span>u64</span><span>)</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><h2 id="avoiding-128-bit-operations">Avoiding 128-bit operations</h2>
<p>Next up: the rounding <code>if</code>. I don’t like it.
It does several operations on 128-bit integers, which don’t fit in normal cpu registers.
I haven’t looked at the disassembly yet, but it smells expensive.
Unfortunately, we can’t fit it into a 64-bit integer,
as there are up to 75 relevant bits:</p>
<pre><code>
               ┌─ first 1 bit           ┌─ next 52 bits                 ┌─ 75 dropped bits
               │ ┌──────────────────────┴───────────────────────────┐ ┌─┴─────────────────────────┐
  y = x &lt;&lt; n = 1 1100100101000100001000100010001000011111010001010100 10101001011⋯000101011 000⋯000
                                                                      │                           │
               ┌──────────────────────────────────────────────────────┘                  ┌────────┘
dropped_bits   │                                                                         │
   = y &lt;&lt; 53 = 101010010110000001111010100100101000100111101010110100000100010101100000000 0000⋯000
               └───┬─────────────────────────────────────────────────────────────────────┘ └────┬─┘
                   └─ does not fit in a 64 bit integer                             always zero ─┘
</code></pre>
<p>However, we <em>only</em> need to know whether <code>dropped_bits</code> is lower, equal, or higher than <code>1 &lt;&lt; 127</code>.
If the highest bit is not set, we know it’s lower, and we don’t need to look at the other bits at all.
If the highest bit is set and <em>all</em> other bits are zero, it is equal.
If the highest bit is set and any of the other bits is set, it is higher.
So, we don’t care about the individual bits beyond the highest one.
We only need to know whether any of them was set.</p>
<pre><code>
0xxxxxxxxxxxxxxxx⋯xxxxxxxxxxxxxxx: round down
10000000000000000⋯000000000000000: round to even
1xxxxxxxxxxxxxxxx⋯xxxxxxxxxxxxxxx: round up

(x: don&#39;t care)
</code></pre>
<p>This means that we can binary-or (<code>|</code>) some of the bits together without losing the information we need.
We can use that to squash it all into 64 bits, so it fits in a single register.
Let’s split up the 75 relevant bits into a chunk of 64 bits and a chunk of 11 bits, and
binary-or them together:</p>
<pre><code>
                                         ┌─ the 75 dropped bits that we care about
               ┌─────────────────────────┴───────────────────────────────────────────────┐
dropped_bits = 101010010110000001111010100100101000100111101010110100000100010101100000000 000⋯000
               │                                                        ┌─────┼┘  ┌──────┘
               └───┐                                                    │     └───┼┐
                   │                                                    01100000000│  last 11 dropped bits
                   1010100101100000011110101001001010001001111010101101000001000101┘  first 64 dropped bits
                   ---------------------------------------------------------------- binary or
        squashed = 1010100101100000011110101001001010001001111010101101001101000101
                 &gt; 1000000000000000000000000000000000000000000000000000000000000000
                 │
                 └─ bigger, so we round up
</code></pre>
<p>In code, that looks like this:</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>    </span><span>let</span><span> </span><span>dropped_bits</span>: <span>u128</span> <span>=</span><span> </span><span>y</span><span> </span><span>&lt;&lt;</span><span> </span><span>53</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>dropped_bits_squashed</span>: <span>u64</span> <span>=</span><span> </span><span>(</span><span>dropped_bits</span><span> </span><span>&gt;&gt;</span><span> </span><span>64</span><span>)</span><span> </span><span>as</span><span> </span><span>u64</span><span> </span><span>|</span><span> </span><span>(</span><span>dropped_bits</span><span> </span><span>&gt;&gt;</span><span> </span><span>53</span><span> </span><span>&amp;</span><span> </span><span>0b11111111111</span><span>)</span><span> </span><span>as</span><span> </span><span>u64</span><span>;</span><span>
</span></span></span></code></pre></div><p><code>dropped_bits_squashed</code> now has the same most significant bit as <code>dropped_bits</code>,
and the other 127 bits were split into two chunks and binary-or’ed together, to preserve the information we need:
whether any of them was set.</p>
<p>If we inline the last usage of <code>dropped_bits</code>, we get <code>y &lt;&lt; 53 &gt;&gt; 53</code>, which we can reduce to just <code>y</code> since we’re
cutting everything beyond the 11nd bit off anyway:</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>    </span><span>let</span><span> </span><span>dropped_bits</span>: <span>u128</span> <span>=</span><span> </span><span>y</span><span> </span><span>&lt;&lt;</span><span> </span><span>53</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>dropped_bits_squashed</span>: <span>u64</span> <span>=</span><span> </span><span>(</span><span>dropped_bits</span><span> </span><span>&gt;&gt;</span><span> </span><span>64</span><span>)</span><span> </span><span>as</span><span> </span><span>u64</span><span> </span><span>|</span><span> </span><span>(</span><span>y</span><span> </span><span>as</span><span> </span><span>u64</span><span> </span><span>&amp;</span><span> </span><span>0b1111111111</span><span>);</span><span>
</span></span></span></code></pre></div><p>Now note that it would work fine if we had not picked 11, but 12, or 13, or any other number up to 63 bits from <code>y</code> instead.
It would mean that some of the bits from <code>y</code> would end up both in the left and right chunk, but that’s fine.
We only care about whether any of them was set.</p>
<p>Processors usually like working with powers of two and might even have an instruction for taking the lower 32 bits of a 64 bit number,
so let’s take 32 bits instead of 11:</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>    </span><span>let</span><span> </span><span>dropped_bits</span>: <span>u128</span> <span>=</span><span> </span><span>y</span><span> </span><span>&lt;&lt;</span><span> </span><span>53</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>dropped_bits_squashed</span>: <span>u64</span> <span>=</span><span> </span><span>(</span><span>dropped_bits</span><span> </span><span>&gt;&gt;</span><span> </span><span>64</span><span>)</span><span> </span><span>as</span><span> </span><span>u64</span><span> </span><span>|</span><span> </span><span>(</span><span>y</span><span> </span><span>as</span><span> </span><span>u64</span><span> </span><span>&amp;</span><span> </span><span>0xFFFFFFFF</span><span>);</span><span>
</span></span></span></code></pre></div><p>Or, visually:</p>
<pre><code>
                                                                        ┌─ 75 dropped bits
                                                                      ┌─┴─────────────────────────┐
           y = 1 1100100101000100001000100010001000011111010001010100 10101001011⋯000101011 000⋯000
                                                                      │                           │
               ┌──────────────────────────────────────────────────────┘                  ┌────────┘
               │                                                                         │
dropped_bits = 101010010110000001111010100100101000100111101010110100000100010101100000000 0000⋯000
               :                                   ┌──────┘                   :   ┌──────┘
               └───┐                               │                          └───┼┐
                   │                               01010110100000100010101100000000│ last 32 dropped bits
                   1010100101100000011110101001001010001001111010101101000001000101┘ first 64 dropped bits
                   ---------------------------------------------------------------- binary or
                   1010100101100000011110101001001011011111111010101111101101000101
                 &gt; 1000000000000000000000000000000000000000000000000000000000000000
                 │
                 └─ bigger, so we round up
</code></pre>
<p>To make things <del>even more unreadable</del> shorter,
we can inline the other usage of the <code>dropped_bits</code> variable and merge <code>y &lt;&lt; 53 &gt;&gt; 64</code> into a single <code>y &gt;&gt; 11</code>,
since the high 64 bits are dropped afterwards by the cast to <code>u64</code>:</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>    </span><span>let</span><span> </span><span>dropped_bits</span><span> </span><span>=</span><span> </span><span>(</span><span>y</span><span> </span><span>&gt;&gt;</span><span> </span><span>11</span><span> </span><span>|</span><span> </span><span>y</span><span> </span><span>&amp;</span><span> </span><span>0xFFFFFFFF</span><span>)</span><span> </span><span>as</span><span> </span><span>u64</span><span>;</span><span>
</span></span></span></code></pre></div><p>Adjusting the condition of the <code>if</code> for our new 64-bit variable, we now have:</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>pub</span><span> </span><span>fn</span> <span>u128_to_f64</span><span>(</span><span>x</span>: <span>u128</span><span>)</span><span> </span>-&gt; <span>f64</span> <span>{</span><span>
</span></span></span><span><span><span>    </span><span>if</span><span> </span><span>x</span><span> </span><span>==</span><span> </span><span>0</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>return</span><span> </span><span>0.0</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>n</span><span> </span><span>=</span><span> </span><span>x</span><span>.</span><span>leading_zeros</span><span>();</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>y</span><span> </span><span>=</span><span> </span><span>x</span><span> </span><span>&lt;&lt;</span><span> </span><span>n</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>exponent</span><span> </span><span>=</span><span> </span><span>(</span><span>127</span><span> </span><span>-</span><span> </span><span>n</span><span>)</span><span> </span><span>+</span><span> </span><span>1022</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>mantissa</span><span> </span><span>=</span><span> </span><span>y</span><span> </span><span>&gt;&gt;</span><span> </span><span>75</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>dropped_bits</span><span> </span><span>=</span><span> </span><span>(</span><span>y</span><span> </span><span>&gt;&gt;</span><span> </span><span>11</span><span> </span><span>|</span><span> </span><span>y</span><span> </span><span>&amp;</span><span> </span><span>0xFFFFFFFF</span><span>)</span><span> </span><span>as</span><span> </span><span>u64</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>if</span><span> </span><span>dropped_bits</span><span> </span><span>&gt;</span><span> </span><span>1</span><span> </span><span>&lt;&lt;</span><span> </span><span>63</span><span> </span><span>||</span><span> </span><span>(</span><span>dropped_bits</span><span> </span><span>==</span><span> </span><span>1</span><span> </span><span>&lt;&lt;</span><span> </span><span>63</span><span> </span><span>&amp;&amp;</span><span> </span><span>mantissa</span><span> </span><span>&amp;</span><span> </span><span>1</span><span> </span><span>==</span><span> </span><span>1</span><span>)</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>mantissa</span><span> </span><span>+=</span><span> </span><span>1</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span>    </span><span>f64</span>::<span>from_bits</span><span>(((</span><span>exponent</span><span> </span><span>as</span><span> </span><span>u64</span><span>)</span><span> </span><span>&lt;&lt;</span><span> </span><span>52</span><span>)</span><span> </span><span>+</span><span> </span><span>mantissa</span><span> </span><span>as</span><span> </span><span>u64</span><span>)</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><h2 id="branch-free-rounding">Branch-free rounding</h2>
<p>It’s great that we’ve gotten rid of some potentially expensive 128-bit operations,
but that <code>if</code> still looks bad with that large condition,
due to the tie-breaking round-to-even stuff.</p>
<p>Is there a way we can get rid of it entirely? Making rounding <em>branch free</em>?</p>
<p>The body of the <code>if</code> statement only increments the mantissa by one,
so all we need is an expression that is <code>0</code> when the condition is false,
and <code>1</code> when the condition is true, and unconditionally add that to the mantissa.</p>
<p>If we didn’t have to take rounding ties into account,
we could replace the entire <code>if</code> by:</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>    </span><span>mantissa</span><span> </span><span>+=</span><span> </span><span>dropped_bits</span><span> </span><span>&gt;&gt;</span><span> </span><span>63</span><span>;</span><span>
</span></span></span></code></pre></div><p>This works, because <code>dropped_bits &gt;&gt; 63</code> is <code>1</code> when equal or higher than <code>1 &lt;&lt; 63</code>,
and <code>0</code> when it is lower.</p>
<pre><code>
dropped_bits = 1010100101100000011110101001001010001001111010101101000001000000
               │
               └──────────────────────────────────────────────────────────────┐
                                                                              │
       &gt;&gt; 63 = 0000000000000000000000000000000000000000000000000000000000000001
                                                                              │
                                                          one, so we round up ┘
</code></pre>
<p>Unfortunately, we need to deal with rounding ties to even.</p>
<p>To see for which cases exactly we need to correct, let’s put all the different cases in a table:</p>
<pre><code>
│     dropped_bits      │  mantissa  │ increment │
│ high bit │ other bits │ lowest bit │ mantissa  │
├──────────┼────────────┼────────────┼───────────┤
│    0     │     -      │     0      │     no    │
│    0     │     -      │     1      │     no    │
│    1     │     0      │     0      │     no    │ !
│    1     │     0      │     1      │    yes    │
│    1     │    &gt;0      │     0      │    yes    │
│    1     │    &gt;0      │     1      │    yes    │
</code></pre>
<p>The first column shows the result of <code>dropped_bits &gt;&gt; 63</code>,
and the last column shows whether we actually need to increment the mantissa.
There’s only one case where they don’t match: the third row,
which is the case where the mantissa is even while breaking a tie.</p>
<p>We can attempt to correct by subtracting one from <code>dropped_bits</code> to flip the outcome:</p>
<pre><code>
Tie:

dropped_bits = 1000000000000000000000000000000000000000000000000000000000000000
          -1 = 0111111111111111111111111111111111111111111111111111111111111111
               │
               └─ flipped to zero, so we round down

Not a tie:

dropped_bits = 1010100101100000011110101001001010001001111010101101000001000000
          -1 = 1010100101100000011110101001001010001001111010101101000000111111
               │
               └─ still one, so we round up
</code></pre>
<p>We need to apply this correction when the high bit of <code>dropped_bits</code> is set,
and the low bit of <code>mantissa</code> is not set,
which we can conveniently express as <code>(dropped_bits &gt;&gt; 63) &amp; !mantissa</code>.</p>
<p>This means we can now replace the entire <code>if</code> statement by:</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>    </span><span>mantissa</span><span> </span><span>+=</span><span> </span><span>(</span><span>dropped_bits</span><span> </span><span>-</span><span> </span><span>((</span><span>dropped_bits</span><span> </span><span>&gt;&gt;</span><span> </span><span>63</span><span>)</span><span> </span><span>&amp;</span><span> </span><span>!</span><span>mantissa</span><span>))</span><span> </span><span>&gt;&gt;</span><span> </span><span>63</span><span>;</span><span>
</span></span></span></code></pre></div><p>Putting it all together, we now only have one <code>if</code> left:</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>pub</span><span> </span><span>fn</span> <span>u128_to_f64</span><span>(</span><span>x</span>: <span>u128</span><span>)</span><span> </span>-&gt; <span>f64</span> <span>{</span><span>
</span></span></span><span><span><span>    </span><span>if</span><span> </span><span>x</span><span> </span><span>==</span><span> </span><span>0</span><span> </span><span>{</span><span>
</span></span></span><span><span><span>        </span><span>return</span><span> </span><span>0.0</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>}</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>n</span><span> </span><span>=</span><span> </span><span>x</span><span>.</span><span>leading_zeros</span><span>();</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>y</span><span> </span><span>=</span><span> </span><span>x</span><span> </span><span>&lt;&lt;</span><span> </span><span>n</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>exponent</span><span> </span><span>=</span><span> </span><span>(</span><span>127</span><span> </span><span>-</span><span> </span><span>n</span><span>)</span><span> </span><span>+</span><span> </span><span>1022</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>mantissa</span><span> </span><span>=</span><span> </span><span>(</span><span>y</span><span> </span><span>&gt;&gt;</span><span> </span><span>75</span><span>)</span><span> </span><span>as</span><span> </span><span>u64</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>dropped_bits</span><span> </span><span>=</span><span> </span><span>(</span><span>y</span><span> </span><span>&gt;&gt;</span><span> </span><span>11</span><span> </span><span>|</span><span> </span><span>y</span><span> </span><span>&amp;</span><span> </span><span>0xFFFFFFFF</span><span>)</span><span> </span><span>as</span><span> </span><span>u64</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>mantissa</span><span> </span><span>+=</span><span> </span><span>(</span><span>dropped_bits</span><span> </span><span>-</span><span> </span><span>((</span><span>dropped_bits</span><span> </span><span>&gt;&gt;</span><span> </span><span>63</span><span>)</span><span> </span><span>&amp;</span><span> </span><span>!</span><span>mantissa</span><span>))</span><span> </span><span>&gt;&gt;</span><span> </span><span>63</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>f64</span>::<span>from_bits</span><span>(((</span><span>exponent</span><span> </span><span>as</span><span> </span><span>u64</span><span>)</span><span> </span><span>&lt;&lt;</span><span> </span><span>52</span><span>)</span><span> </span><span>+</span><span> </span><span>mantissa</span><span>)</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><h2 id="removing-the-last-branch">Removing the last branch</h2>
<p>Do we need that last remaining <code>if</code>? What happens if we remove it?</p>
<p><code>x.leading_zeros()</code> would result in <code>n = 128</code> when <code>x</code> is zero, which is fine,
but then <code>x &lt;&lt; n</code> on the next line could panic.
Let’s swap that for <code>x.wrapping_shl(n)</code>, such that it never panics,
but instead just results in zero when <code>x</code> is zero and <code>n</code> is 128.
The calculation of the mantissa all just results in a zero, which is exactly correct.
Unfortunately, the calculation of the exponent does not result in a zero, so we’ll have to keep an <code>if</code> there.
Maybe if we squeeze it on one line at the end, no one will notice.
(And maybe the compiler will be able to turn it into a branch-free conditional move,
now that the <code>if</code> just selects between two integers.)</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>pub</span><span> </span><span>fn</span> <span>u128_to_f64</span><span>(</span><span>x</span>: <span>u128</span><span>)</span><span> </span>-&gt; <span>f64</span> <span>{</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>n</span><span> </span><span>=</span><span> </span><span>x</span><span>.</span><span>leading_zeros</span><span>();</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>y</span><span> </span><span>=</span><span> </span><span>x</span><span>.</span><span>wrapping_shl</span><span>(</span><span>n</span><span>);</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>mut</span><span> </span><span>mantissa</span><span> </span><span>=</span><span> </span><span>(</span><span>y</span><span> </span><span>&gt;&gt;</span><span> </span><span>75</span><span>)</span><span> </span><span>as</span><span> </span><span>u64</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>dropped_bits</span><span> </span><span>=</span><span> </span><span>(</span><span>y</span><span> </span><span>&gt;&gt;</span><span> </span><span>11</span><span> </span><span>|</span><span> </span><span>y</span><span> </span><span>&amp;</span><span> </span><span>0xFFFFFFFF</span><span>)</span><span> </span><span>as</span><span> </span><span>u64</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>mantissa</span><span> </span><span>+=</span><span> </span><span>(</span><span>dropped_bits</span><span> </span><span>-</span><span> </span><span>(</span><span>dropped_bits</span><span> </span><span>&gt;&gt;</span><span> </span><span>63</span><span> </span><span>&amp;</span><span> </span><span>!</span><span>mantissa</span><span>))</span><span> </span><span>&gt;&gt;</span><span> </span><span>63</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>exponent</span><span> </span><span>=</span><span> </span><span>if</span><span> </span><span>x</span><span> </span><span>==</span><span> </span><span>0</span><span> </span><span>{</span><span> </span><span>0</span><span> </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span><span> </span><span>127</span><span> </span><span>-</span><span> </span><span>n</span><span> </span><span>+</span><span> </span><span>1022</span><span> </span><span>};</span><span>
</span></span></span><span><span><span>    </span><span>f64</span>::<span>from_bits</span><span>(((</span><span>exponent</span><span> </span><span>as</span><span> </span><span>u64</span><span>)</span><span> </span><span>&lt;&lt;</span><span> </span><span>52</span><span>)</span><span> </span><span>+</span><span> </span><span>mantissa</span><span>)</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>Now all we need to do to make this function <del>even less readable</del> prettier,
is to fold some of the remaining constants, remove unnecessary parentheses,
and to only use single letter variables to make every line start with <code>let _ =</code>:</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>pub</span><span> </span><span>fn</span> <span>u128_to_f64</span><span>(</span><span>x</span>: <span>u128</span><span>)</span><span> </span>-&gt; <span>f64</span> <span>{</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>n</span><span> </span><span>=</span><span> </span><span>x</span><span>.</span><span>leading_zeros</span><span>();</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>y</span><span> </span><span>=</span><span> </span><span>x</span><span>.</span><span>wrapping_shl</span><span>(</span><span>n</span><span>);</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>a</span><span> </span><span>=</span><span> </span><span>(</span><span>y</span><span> </span><span>&gt;&gt;</span><span> </span><span>75</span><span>)</span><span> </span><span>as</span><span> </span><span>u64</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>b</span><span> </span><span>=</span><span> </span><span>(</span><span>y</span><span> </span><span>&gt;&gt;</span><span> </span><span>11</span><span> </span><span>|</span><span> </span><span>y</span><span> </span><span>&amp;</span><span> </span><span>0xFFFFFFFF</span><span>)</span><span> </span><span>as</span><span> </span><span>u64</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>m</span><span> </span><span>=</span><span> </span><span>a</span><span> </span><span>+</span><span> </span><span>(</span><span>b</span><span> </span><span>-</span><span> </span><span>(</span><span>b</span><span> </span><span>&gt;&gt;</span><span> </span><span>63</span><span> </span><span>&amp;</span><span> </span><span>!</span><span>a</span><span>))</span><span> </span><span>&gt;&gt;</span><span> </span><span>63</span><span>;</span><span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>e</span><span> </span><span>=</span><span> </span><span>if</span><span> </span><span>x</span><span> </span><span>==</span><span> </span><span>0</span><span> </span><span>{</span><span> </span><span>0</span><span> </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span><span> </span><span>1149</span><span> </span><span>-</span><span> </span><span>n</span><span> </span><span>as</span><span> </span><span>u64</span><span> </span><span>};</span><span>
</span></span></span><span><span><span>    </span><span>f64</span>::<span>from_bits</span><span>((</span><span>e</span><span> </span><span>&lt;&lt;</span><span> </span><span>52</span><span>)</span><span> </span><span>+</span><span> </span><span>m</span><span>)</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>Beautiful!</p>
<h2 id="disassembly">Disassembly</h2>
<p>If we compile this for x86-64, we’ll see that the resulting machine code is entirely branchless!</p>
<p>Good job, <del>Rustc</del> LLVM!</p>
<p>Look, no labels, no jumps:</p>
<div><pre tabindex="0"><code data-lang="asm"><span><span><span>u128_to_f64:</span>
</span></span><span><span>  <span>bsr</span>     <span>rax</span><span>,</span> <span>rdi</span>
</span></span><span><span>  <span>mov</span>     <span>edx</span><span>,</span> <span>127</span>
</span></span><span><span>  <span>cmovne</span>  <span>rdx</span><span>,</span> <span>rax</span>
</span></span><span><span>  <span>xor</span>     <span>rdx</span><span>,</span> <span>63</span>
</span></span><span><span>  <span>add</span>     <span>rdx</span><span>,</span> <span>64</span>
</span></span><span><span>  <span>bsr</span>     <span>rcx</span><span>,</span> <span>rsi</span>
</span></span><span><span>  <span>xor</span>     <span>rcx</span><span>,</span> <span>63</span>
</span></span><span><span>  <span>test</span>    <span>rsi</span><span>,</span> <span>rsi</span>
</span></span><span><span>  <span>cmove</span>   <span>rcx</span><span>,</span> <span>rdx</span>
</span></span><span><span>  <span>mov</span>     <span>rax</span><span>,</span> <span>rsi</span>
</span></span><span><span>  <span>shld</span>    <span>rax</span><span>,</span> <span>rdi</span><span>,</span> <span>cl</span>
</span></span><span><span>  <span>mov</span>     <span>rdx</span><span>,</span> <span>rdi</span>
</span></span><span><span>  <span>shl</span>     <span>rdx</span><span>,</span> <span>cl</span>
</span></span><span><span>  <span>xor</span>     <span>r8d</span><span>,</span> <span>r8d</span>
</span></span><span><span>  <span>test</span>    <span>cl</span><span>,</span> <span>64</span>
</span></span><span><span>  <span>cmovne</span>  <span>rax</span><span>,</span> <span>rdx</span>
</span></span><span><span>  <span>cmovne</span>  <span>rdx</span><span>,</span> <span>r8</span>
</span></span><span><span>  <span>mov</span>     <span>r9</span><span>,</span> <span>rax</span>
</span></span><span><span>  <span>shr</span>     <span>r9</span><span>,</span> <span>11</span>
</span></span><span><span>  <span>shld</span>    <span>rax</span><span>,</span> <span>rdx</span><span>,</span> <span>53</span>
</span></span><span><span>  <span>mov</span>     <span>edx</span><span>,</span> <span>edx</span>
</span></span><span><span>  <span>or</span>      <span>rdx</span><span>,</span> <span>rax</span>
</span></span><span><span>  <span>shl</span>     <span>rcx</span><span>,</span> <span>52</span>
</span></span><span><span>  <span>movabs</span>  <span>r10</span><span>,</span> <span>0x47d0000000000000</span>
</span></span><span><span>  <span>sub</span>     <span>r10</span><span>,</span> <span>rcx</span>
</span></span><span><span>  <span>or</span>      <span>rdi</span><span>,</span> <span>rsi</span>
</span></span><span><span>  <span>cmove</span>   <span>r10</span><span>,</span> <span>r8</span>
</span></span><span><span>  <span>shr</span>     <span>rax</span><span>,</span> <span>63</span>
</span></span><span><span>  <span>add</span>     <span>rdx</span><span>,</span> <span>r9</span>
</span></span><span><span>  <span>mov</span>     <span>ecx</span><span>,</span> <span>r9d</span>
</span></span><span><span>  <span>not</span>     <span>ecx</span>
</span></span><span><span>  <span>and</span>     <span>eax</span><span>,</span> <span>ecx</span>
</span></span><span><span>  <span>sub</span>     <span>rdx</span><span>,</span> <span>rax</span>
</span></span><span><span>  <span>shr</span>     <span>rdx</span><span>,</span> <span>63</span>
</span></span><span><span>  <span>or</span>      <span>rdx</span><span>,</span> <span>r10</span>
</span></span><span><span>  <span>movq</span>    <span>xmm0</span><span>,</span> <span>rdx</span>
</span></span><span><span>  <span>ret</span>
</span></span></code></pre></div><p>I don’t know about you, but if I was an x86 processor,
I’d think this code is really pretty.</p>
<h2 id="results">Results</h2>
<p>As it turns out, we could’ve saved a lot of effort by just doing:</p>
<div><pre tabindex="0"><code data-lang="rust"><span><span><span>pub</span><span> </span><span>fn</span> <span>u128_to_f64</span><span>(</span><span>x</span>: <span>u128</span><span>)</span><span> </span>-&gt; <span>f64</span> <span>{</span><span>
</span></span></span><span><span><span>    </span><span>x</span><span> </span><span>as</span><span> </span><span>f64</span><span>
</span></span></span><span><span><span></span><span>}</span><span>
</span></span></span></code></pre></div><p>But that’s obviously no fun.</p>
<p>Unfortunately, we cannot measure fun. What we can measure, though, is speed.</p>
<p>Quickly throwing together a benchmark using <a href="https://crates.io/crates/criterion"><code>criterion</code></a>
to test the builtin <code>as f64</code> conversion gives the following results on my computer:</p>
<p><img src="https://nickdrozd.github.io/2022/05/floats-bench-builtin.svg"/>
</p>
<p>An average of 7.7 nanoseconds per conversion. Not bad.</p>
<p>..</p>
<p>Okay. Moment of truth…</p>
<p>Let’s try the same benchmark on our own implementation…</p>
<p><img src="https://nickdrozd.github.io/2022/05/floats-bench-soft.svg"/>
</p>
<p>..</p>
<p>Wow. 4.8 nanoseconds per iteration. That’s almost twice as fast!</p>
<p><span>😮</span></p>
<h2 id="epilogue">Epilogue</h2>
<p>Having beaten Rustc’s builtin <code>as f64</code> operator,
I had proven to Rustc that, no, I totally didn’t just waste my time by forgetting about its builtin conversions.
I could finally pretend like this was my goal all along.</p>
<p>The resulting dopamine rush left me craving for more, which resulted in me spending the next several days and nights
implementing conversions from every single integer type to the floating point types, and back.
I worked on benchmarks and tests, and started tracking the differences in the
generated machine code for several different architectures, just to try to find
the version of the Rust code that compiled down to the best and most performant code on all platforms.
In the end I also made some architecture-specific versions,
such as an implementation that makes use of native i64-to-f64 instructions
to perform u128-to-f64 conversion another two times faster (2.3 nanoseconds),
by using some tricks that could fill their own blog post.</p>
<p>Eventually, tired but satisfied, I <a href="https://github.com/m-ou-se/floatconv">pushed it all to GitHub</a>
and slowly woke up from my hyperfocus fueled week-long fever dream,
wondering when I had last slept or eaten.
I ate, slept, and then never cared about integer-float conversion ever again.</p>
    </div></div>
  </body>
</html>
