<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.miguelgrinberg.com/post/it-s-time-for-a-change-datetime-utcnow-is-now-deprecated">Original</a>
    <h1>datetime.utcnow() is now deprecated</h1>
    
    <div id="readability-page-1" class="page"><div><p>I was going through the <a href="https://docs.python.org/3/whatsnew/3.12.html">release notes</a> of the new Python 3.12 version the other day, and one item caught my attention in the deprecations section:</p>
<blockquote>
<p><code>datetime.datetime</code>â€™s <code>utcnow()</code> and <code>utcfromtimestamp()</code> are deprecated and will be removed in a future version.</p>
</blockquote>
<p>If you have followed my web development tutorials you must have seen me use <code>utcnow()</code> a lot, so I will clearly need to re-train myself to use an alternative, in preparation for the eventual removal of this function (likely a few years out, so no need to panic!).</p>
<p>In this short article I&#39;ll tell you more about why these functions are getting the axe, and what to replace them with.</p>
<h2>What&#39;s Wrong with utcnow() and utcfromtimestamp()?</h2>
<p>The problem that the Python maintainers have found comes from the fact that these functions return <a href="https://docs.python.org/3/library/datetime.html#aware-and-naive-objects">&#34;naive&#34; datetime objects</a>. A naive <code>datetime</code> object is one that does not have a timezone, which means that it can only be used in a context where the timezone does not matter or is already known in advance. This is in contrast to &#34;aware&#34; <code>datetime</code> objects, which do have a timezone attached to them explicitly.</p>
<p>If you ask me, I think the names of these functions are misleading. A function that is called <code>utcnow()</code> should be expected to return UTC datetimes, as implied by the name. I would have made it more clear that these functions work with naive time, maybe by calling them <code>naive_utcnow()</code> and <code>naive_utcfromtimestamp()</code>.</p>
<p>But their names are not the problem here. The specific issue is that some Python date and time functions accept naive timestamps and assume that they represent local time, according to the timezone that is configured on the computer running the code. There is a <a href="https://github.com/python/cpython/issues/81669">GitHub issue from 2019</a> that provides some background into this, with the following example:</p>
<pre><code>&gt;&gt;&gt; from datetime import datetime
&gt;&gt;&gt; dt = datetime.utcfromtimestamp(0)
&gt;&gt;&gt; dt
datetime.datetime(1970, 1, 1, 0, 0)
&gt;&gt;&gt; dt.timestamp()
18000
</code></pre>
<p>The example above was executed on a computer that was configured for Eastern Standard Time (EST). First, <code>dt</code> is assigned a naive <code>datetime</code> that is converted from the &#34;zero&#34; time or <a href="https://en.wikipedia.org/wiki/Unix_time">UNIX epoch</a>, which is January 1st, 1970 at midnight.</p>
<p>When this object is converted back to a timestamp, the <code>dt.timestamp()</code> method finds that it does not have a timezone to use in the conversion, so it uses the computer&#39;s own timezone, which in this example was EST (note that the EST timezone is 5 hours, or 18,000 seconds behind UTC). So we have a UNIX timestamp that originated as midnight on January 1st, 1970, and after being converted to a <code>datetime</code> and back ends up as 5 am.</p>
<p>If you read the issue linked above, they suggest that this ambiguity did not exist in Python 2 and for that reason this was not a problem for a long time, but it now is and needs to be addressed. This sounded strange, so I had to go and check, and sure enough, the <code>timestamp()</code> method that returns the incorrect UNIX time in the example was introduced in Python 3.3 and nothing similar appears to have existed back in Python 2 times.</p>
<p>So basically, at some point they&#39;ve added a <code>datetime.timestamp()</code> method (and possibly others as well) that accept both aware and naive datetimes and this was a mistake, because these methods must have a timezone to work.</p>
<p>These methods should have been designed to fail when a naive <code>datetime</code> object is passed to them, but for some strange reason they decided that when a timezone is not provided the timezone from the system should be used. This is really the bug, but instead of fixing the broken implementations of these methods they are now trying to force people to move to aware datetimes by deprecating the two main functions that generate naive ones. They think that because a few functions assume that naive timestamps represent local times, all naive uses that are not in local time should be discouraged.</p>
<p>I may be missing something here, but I don&#39;t really follow this logic.</p>
<h2>Do We Need Naive Datetimes Anyway?</h2>
<p>To me it is clear that the Python maintainers behind this deprecation have a problem with naive datetimes and are using this supposed problem as an excuse to cripple them.</p>
<p>So why would you want to work with naive datetimes in the first place?</p>
<p>An application may be designed in such a way that all dates and times are in a single timezone that is known in advance. In this case there is no need for individual <code>datetime</code> instances to carry their own timezones, since this uses more memory and processing power for no benefit, since all these timezones would be the same and it would never be necessary to perform timezone math or conversions.</p>
<p>This is actually very common in web applications or other types of networking servers, which are configured with <a href="https://en.wikipedia.org/wiki/Coordinated_Universal_Time">UTC</a> time and normalize all dates and times to this timezone when they enter the system. It is also a best practice to store naive datetimes representing UTC in databases. The <a href="https://docs.sqlalchemy.org/en/stable/core/type_basics.html#sqlalchemy.types.DateTime">DateTime</a> type in SQLAlchemy represents a naive <code>datetime</code> object by default, for example. This is such a common database pattern that SQLAlchemy provides a <a href="https://docs.sqlalchemy.org/en/20/core/custom_types.html#store-timezone-aware-timestamps-as-timezone-naive-utc">recipe</a> for applications that use aware <code>datetime</code> objects to convert these to and from naive ones on the fly as they are saved to or loaded from the database.</p>
<p>So yes, I expect naive <code>datetime</code> objects will continue to be used, in spite of these deprecations.</p>
<h2>Updating Your Code</h2>
<p>Even though the deprecations are disappointing, it is important to keep in mind that it may take a few years for the functions to actually be removed. The problem is that once you switch to Python 3.12 or newer you will start seeing deprecation messages on your console and your logs, and these can get annoying. Here is an example of what you can expect to see:</p>
<pre><code>$ python
Python 3.12.0 (main, Oct  5 2023, 10:46:39) [GCC 11.4.0] on linux
Type &#34;help&#34;, &#34;copyright&#34;, &#34;credits&#34; or &#34;license&#34; for more information.
&gt;&gt;&gt; from datetime import datetime
&gt;&gt;&gt; datetime.utcnow()
&lt;stdin&gt;:1: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC).
datetime.datetime(2023, 11, 18, 11, 22, 54, 263206)
</code></pre>
<p>I&#39;m only using Python 3.12 in a small number of projects, and I&#39;m already tired of seeing these warnings. So let&#39;s go ahead and look at how these two functions can be replaced.</p>
<p>The advice from the Python maintainers is to switch to aware <code>datetime</code> objects. The deprecation warning provides a hint of what they think we should use, and the deprecation notices included in the documentation are even more specific. Here is what the notice for the <code>utcnow()</code> function says:</p>
<blockquote>
<p>Deprecated since version 3.12: Use <code>datetime.now()</code> with <code>UTC</code> instead.</p>
</blockquote>
<p>Below you can see the one for <code>utcfromtimestamp()</code>:</p>
<blockquote>
<p>Deprecated since version 3.12: Use <code>datetime.fromtimestamp()</code> with <code>UTC</code> instead.</p>
</blockquote>
<p>So this gives us an idea of what can be done. Here are my custom versions of the deprecated functions, with the additional option to choose between aware or naive implementations:</p>
<pre><code>from datetime import datetime, timezone

def aware_utcnow():
    return datetime.now(timezone.utc)

def aware_utcfromtimestamp(timestamp):
    return datetime.fromtimestamp(timestamp, timezone.utc)

def naive_utcnow():
    return aware_utcnow().replace(tzinfo=None)

def naive_utcfromtimestamp(timestamp):
    return aware_utcfromtimestamp(timestamp).replace(tzinfo=None)

print(aware_utcnow())
print(aware_utcfromtimestamp(0))
print(naive_utcnow())
print(naive_utcfromtimestamp(0))
</code></pre>
<p>Note that if you are using Python 3.11 or newer, you can replace <code>datetime.timezone.utc</code> with a shorter <code>datetime.UTC</code>.</p>
<p>Running this script I get the following results:</p>
<pre><code>2023-11-18 11:36:35.137639+00:00
1970-01-01 00:00:00+00:00
2023-11-18 11:36:35.137672
1970-01-01 00:00:00
</code></pre>
<p>You can tell that the first and second lines show aware <code>datetime</code> instances from the <code>+00:00</code> suffix that indicates that the timezone is 00:00 or UTC. The third and fourth lines show abstract timestamps without a timezone, fully compatible with those returned by the deprecated functions.</p>
<p>What I like about these implementations is that they give you the choice to work with or without timezones, removing any ambiguity. Explicit is better than implicit, as <a href="https://peps.python.org/pep-0020/">the old adage</a> says.</p></div></div>
  </body>
</html>
