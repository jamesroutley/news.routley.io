<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/tylerhou/fiber">Original</a>
    <h1>Show HN: Python decorator that enables arbitrarily-deep tail/non-tail recursion</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
          <article itemprop="text">
<p dir="auto">Fiber implements an proof-of-concept Python decorator that rewrites a function
so that it can be paused and resumed (by moving stack variables to a heap frame
and adding if statements to simulate jumps/gotos to specific lines of code).</p>
<p dir="auto">Then, using a trampoline function that simulates the call stack on the heap, we
can call functions that recurse arbitrarily deeply without stack overflowing
(assuming we don&#39;t run out of heap memory).</p>
<div data-snippet-clipboard-copy-content="cache = {}

@fiber.fiber(locals=locals())
def fib(n):
    assert n &gt;= 0
    if n in cache:
        return cache[n]
    if n == 0:
        return 0
    if n == 1:
        return 1
    cache[n] = fib(n-1) + fib(n-2)
    return cache[n]

print(sys.getrecursionlimit())  # 1000 by default

# https://www.wolframalpha.com/input/?i=fib%281010%29+mod+10**5
print(trampoline.run(fib, [1010]) % 10 ** 5) # 74305"><pre><span>cache</span> <span>=</span> {}

<span>@<span>fiber</span>.<span>fiber</span>(<span>locals</span><span>=</span><span>locals</span>())</span>
<span>def</span> <span>fib</span>(<span>n</span>):
    <span>assert</span> <span>n</span> <span>&gt;=</span> <span>0</span>
    <span>if</span> <span>n</span> <span>in</span> <span>cache</span>:
        <span>return</span> <span>cache</span>[<span>n</span>]
    <span>if</span> <span>n</span> <span>==</span> <span>0</span>:
        <span>return</span> <span>0</span>
    <span>if</span> <span>n</span> <span>==</span> <span>1</span>:
        <span>return</span> <span>1</span>
    <span>cache</span>[<span>n</span>] <span>=</span> <span>fib</span>(<span>n</span><span>-</span><span>1</span>) <span>+</span> <span>fib</span>(<span>n</span><span>-</span><span>2</span>)
    <span>return</span> <span>cache</span>[<span>n</span>]

<span>print</span>(<span>sys</span>.<span>getrecursionlimit</span>())  <span># 1000 by default</span>

<span># https://www.wolframalpha.com/input/?i=fib%281010%29+mod+10**5</span>
<span>print</span>(<span>trampoline</span>.<span>run</span>(<span>fib</span>, [<span>1010</span>]) <span>%</span> <span>10</span> <span>**</span> <span>5</span>) <span># 74305</span></pre></div>
<p dir="auto">Please do not use this in production.</p>
<h2 dir="auto"><a id="user-content-toc" aria-hidden="true" href="#toc"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>TOC</h2>
<ul dir="auto">
<li><a href="#fiber">Fiber</a>
<ul dir="auto">
<li><a href="#how-it-works">How it works</a></li>
<li><a href="#performance">Performance</a></li>
<li><a href="#limitations">Limitations</a>
<ul dir="auto">
<li><a href="#possible-improvements">Possible improvements</a></li>
</ul>
</li>
<li><a href="#questions">Questions</a>
<ul dir="auto">
<li><a href="#why-didnt-you-use-python-generators">Why didn&#39;t you use Python generators?</a></li>
<li><a href="#why-did-you-write-this">Why did you write this?</a></li>
</ul>
</li>
<li><a href="#contributing">Contributing</a></li>
<li><a href="#license">License</a></li>
<li><a href="#disclaimer">Disclaimer</a></li>
</ul>
</li>
</ul>
<h2 dir="auto"><a id="user-content-how-it-works" aria-hidden="true" href="#how-it-works"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>How it works</h2>
<p dir="auto">A quick refresher on the call stack: normally, when some function A calls
another function B, A is &#34;paused&#34; while B runs to completion. Then, once B
finishes, A is resumed.</p>
<p dir="auto">In order to move the call stack to the heap, we need to transform function A
to (1) store all variables on the heap, and (2) be able to resume execution
at specific lines of code within the function.</p>
<p dir="auto">The first step is easy: we rewrite all local loads and stores to instead load
and store in a frame dictionary that is passed into the function. The second is
more difficult: because Python doesn&#39;t support goto statements, we have to
insert if statements to skip the code prefix that we don&#39;t want to execute.</p>
<p dir="auto">There are a variety of <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Special-Forms.html" rel="nofollow">&#34;special
forms&#34;</a>
that cannot be jumped into. These we must handle by rewriting them into a form
that we do handle.</p>
<p dir="auto">For example, if we recursively call a function inside a for loop, we would like
to be able to resume execution on the same iteration. However, when Python
executes a for loop on an non-iterator iterable it will create a new iterator
every time. To handle this case, we rewrite for loops into the equivalent while
loop. Similarly, we must rewrite boolean expressions that short circuit (<code>and</code>,
<code>or</code>) into the equivalent if statements.</p>
<p dir="auto">Lastly, we must replace all recursive calls and normal returns by instead
returning an instruction to a trampoline to call the child function or return
the value to the parent function, respectively.</p>
<p dir="auto">To recap, here are the AST passes we currently implement:</p>
<ol dir="auto">
<li>Rewrite special forms:
<ul dir="auto">
<li><code>for_to_while</code>: Transforms for loops into the equivalent while loops.</li>
<li><code>promote_while_cond</code>: Rewrites the while conditional to use a temporary
variable that is updated every loop iteration so that we can control when
it is evaluated (e.g. if the loop condition includes a recursive call).</li>
<li><code>bool_exps_to_if</code>: Converts <code>and</code> and <code>or</code> expressions into the
equivalent if statements.</li>
</ul>
</li>
<li><code>promote_to_temporary</code>: Assigns the results of recursive calls into
temporary variables. This is necessary when we make multiple recursive calls
in the same statement (e.g. <code>fib(n-1) + fib(n-2)</code>): we need to resume
execution in the middle of the expression.</li>
<li><code>remove_trivial_temporaries</code>: Removes temporaries that are assigned to only
once and are directly assigned to some other variable, replacing subsequent
usages with that other variable. This helps us detect tail calls.</li>
<li><code>insert_jumps</code>: Marks the statement after yield points (currently recursive
calls and normal returns) with a <code>pc</code> index, and inserts if statements so
that re-execution of the function will resume at that program counter.</li>
<li><code>lift_locals_to_frame</code>: Replaces loads and stores of local variables to
loads and stores in the frame object.</li>
<li><code>add_trampoline_returns</code>: Replaces places where we must yield (recursive
calls and normal returns) with returns to the trampoline function.</li>
<li><code>fix_fn_def</code>: Rewrites the function defintion to take a <code>frame</code> parameter.</li>
</ol>
<p dir="auto">See the <a href="https://github.com/tylerhou/fiber/blob/main/examples"><code>examples</code></a> directory for functions and the results after
each AST pass. Also, see <a href="https://github.com/tylerhou/fiber/blob/main/src/trampoline_test.py"><code>src/trampoline_test.py</code></a> for
some test cases.</p>
<h2 dir="auto"><a id="user-content-performance" aria-hidden="true" href="#performance"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Performance</h2>
<p dir="auto">A simple tail-recursive function that computes the sum of an array takes about
10-11 seconds to compute with Fiber. 1000 iterations of the equivalent for loop
takes 7-8 seconds to compute. So we are slower by roughly a factor of 1000.</p>
<div data-snippet-clipboard-copy-content="lst = list(range(1, 100001))

# fiber
@fiber.fiber(locals=locals())
def sum(lst, acc):
    if not lst:
        return acc
    return sum(lst[1:], acc + lst[0])

# for loop
total = 0
for i in lst:
    total += i

print(total, trampoline.run(sum, [lst, 0]))  # 5000050000, 5000050000"><pre><span>lst</span> <span>=</span> <span>list</span>(<span>range</span>(<span>1</span>, <span>100001</span>))

<span># fiber</span>
<span>@<span>fiber</span>.<span>fiber</span>(<span>locals</span><span>=</span><span>locals</span>())</span>
<span>def</span> <span>sum</span>(<span>lst</span>, <span>acc</span>):
    <span>if</span> <span>not</span> <span>lst</span>:
        <span>return</span> <span>acc</span>
    <span>return</span> <span>sum</span>(<span>lst</span>[<span>1</span>:], <span>acc</span> <span>+</span> <span>lst</span>[<span>0</span>])

<span># for loop</span>
<span>total</span> <span>=</span> <span>0</span>
<span>for</span> <span>i</span> <span>in</span> <span>lst</span>:
    <span>total</span> <span>+=</span> <span>i</span>

<span>print</span>(<span>total</span>, <span>trampoline</span>.<span>run</span>(<span>sum</span>, [<span>lst</span>, <span>0</span>]))  <span># 5000050000, 5000050000</span></pre></div>
<p dir="auto">We could improve the performance of the code by eliminating redundant if
checks in the generated code. Also, as we statically know the stack variables,
we can use an array for the stack frame and integer indexes (instead of a
dictionary and string hashes + lookups). This should improve the performance
significantly, but there will still probably be a large amount of overhead.</p>
<p dir="auto">Another performance improvement is to inline the stack array: instead of
storing a list of frames in the trampoline, we could variables directly in the
stack. Again, we can compute the frame size statically. Based on some tests in
a handwritten JavaScript implementation, this has the potential to speed up the
code by roughly a factor of 2-3, at the cost of a more complex implementation.</p>
<h2 dir="auto"><a id="user-content-limitations" aria-hidden="true" href="#limitations"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Limitations</h2>
<ul dir="auto">
<li>
<p dir="auto">The transformation works on the AST level, so we don&#39;t support other
decorators (for example, we cannot use
<a href="https://docs.python.org/3.10/library/functools.html#functools.cache" rel="nofollow">functools.cache</a>
in the above Fibonacci example).</p>
</li>
<li>
<p dir="auto">The function can only access variables that are passed in the <code>locals=</code>
argument. As a consequence of this, to resolve recursive function calls,
we maintain a global mapping of all fiber functions by name. This means that
fibers must have distinct names.</p>
</li>
<li>
<p dir="auto">We don&#39;t support some special forms (ternaries, comprehensions). These can
easily be added as a rewrite transformation.</p>
</li>
<li>
<p dir="auto">We don&#39;t support exceptions. This would require us to keep track of exception
handlers in the trampoline and insert returns to the trampoline to register
and deregister handlers.</p>
</li>
<li>
<p dir="auto">We don&#39;t support generators. To add support, we would have to modify the
trampoline to accept another operation type (yield) that sends a value to the
function that called <code>next()</code>. Also, the trampoline would have to support
multiple call stacks.</p>
</li>
</ul>
<h3 dir="auto"><a id="user-content-possible-improvements" aria-hidden="true" href="#possible-improvements"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Possible improvements</h3>
<ul dir="auto">
<li>Improve test coverage on some of the AST transformations.
<ul dir="auto">
<li><code>remove_trivial_temporaries</code> may have a bug if the variable that it is
replaced with is reassigned to another value.</li>
</ul>
</li>
<li>Support more special forms (comprehensions, generators).</li>
<li>Support exceptions.</li>
<li>Support recursive calls that don&#39;t read the return value.</li>
</ul>
<h2 dir="auto"><a id="user-content-questions" aria-hidden="true" href="#questions"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Questions</h2>
<h3 dir="auto"><a id="user-content-why-didnt-you-use-python-generators" aria-hidden="true" href="#why-didnt-you-use-python-generators"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Why didn&#39;t you use Python generators?</h3>
<p dir="auto">It&#39;s less interesting as the transformations are easier. Here, we are
effectively implementing generators in userspace (i.e. not needing VM support);
see the answer to the next question for why this is useful.</p>
<p dir="auto">Also, people have used generators to do this; see <a href="https://hurryabit.github.io/blog/stack-safety-for-free/" rel="nofollow">one recent generator
example</a>.</p>
<h3 dir="auto"><a id="user-content-why-did-you-write-this" aria-hidden="true" href="#why-did-you-write-this"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Why did you write this?</h3>
<ul dir="auto">
<li>
<p dir="auto"><a href="https://web.archive.org/web/20211208153249/https://cs61a.org/articles/about/#a-grades" rel="nofollow">A+ project for CS 61A at
Berkeley.</a>
During the course, we created a Scheme interpreter. The extra credit
question we to replace tail calls in Python with a return to a trampoline,
with the goal that tail call optimization in Python would let us evaluate
tail calls to arbitrary depth in Scheme, in constant space.</p>
<p dir="auto">The test cases for the question checked whether interpreting tail-call
recursive functions in Scheme caused a Python stack overflow. Using this
Fiber implementation, (1) without tail call optimization in our trampoline,
we would still be able to pass the test cases (we just wouldn&#39;t use constant
space) and (2) we can now evaluate any Scheme expression to arbitrary depth,
even if they are not in tail form.</p>
</li>
<li>
<p dir="auto">The React framework has an a bug open which explores a compiler transform to
rewrite JavaScript generators to a state machine so that recursive operations
(render, reconcilation) can be written more easily. This is necessary because
some JavaScript engines still don&#39;t support generators.</p>
<p dir="auto">This project basically implements a rough version of that compiler transform
as a proof of concept, just in Python.
<a href="https://github.com/facebook/react/pull/18942">https://github.com/facebook/react/pull/18942</a></p>
</li>
</ul>
<h2 dir="auto"><a id="user-content-contributing" aria-hidden="true" href="#contributing"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Contributing</h2>
<p dir="auto">See <a href="https://github.com/tylerhou/fiber/blob/main/CONTRIBUTING.md"><code>CONTRIBUTING.md</code></a> for more details.</p>
<h2 dir="auto"><a id="user-content-license" aria-hidden="true" href="#license"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>License</h2>
<p dir="auto">Apache 2.0; see <a href="https://github.com/tylerhou/fiber/blob/main/LICENSE"><code>LICENSE</code></a> for more details.</p>
<h2 dir="auto"><a id="user-content-disclaimer" aria-hidden="true" href="#disclaimer"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Disclaimer</h2>
<p dir="auto">This is a personal project, not an official Google project. It is not supported
by Google and Google specifically disclaims all warranties as to its quality,
merchantability, or fitness for a particular purpose.</p>
</article>
        </div></div>
  </body>
</html>
