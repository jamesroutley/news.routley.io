<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/gvelesandro/constructor-theory-simulator">Original</a>
    <h1>Show HN: Python Simulator of David Deutsch’s “Constructor Theory of Time”</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto">A <strong>Python implementation</strong> of David Deutsch’s Constructor Theory framework, exposing key concepts—from simple Tasks and branching substrates to quantum-gravity and electromagnetism—entirely in code. Includes a “universal constructor” that can bootstrap itself from a list of Tasks, demonstrating self-replication and the power of Constructor Theory.</p>
<blockquote>
<p dir="auto"><em>“A demonstration of how constructor theory <strong>could</strong> be explored in code, not a high-precision physics engine. For the formal definitions, see David Deutsch and Chiara Marletto’s recent paper “<a href="https://arxiv.org/abs/2505.08692" rel="nofollow">Constructor Theory of Time</a>” (May 13, 2025).</em></p>
</blockquote>
<hr/>

<ul dir="auto">
<li>
<p dir="auto"><strong>Core framework</strong>: Attributes, Substrates, Tasks, Constructors</p>
</li>
<li>
<p dir="auto"><strong>Irreversible &amp; quantum tasks</strong>: Many-worlds branching, decoherence guards</p>
</li>
<li>
<p dir="auto"><strong>Timers &amp; Clocks</strong>: Simulate proper-time, special/general relativity corrections</p>
</li>
<li>
<p dir="auto"><strong>Fungibility &amp; SwapConstructor</strong>: Free exchange of identical substrates</p>
</li>
<li>
<p dir="auto"><strong>ASCII visualizer</strong>: <code>ascii_branch()</code> for quick text-based branch inspection</p>
</li>
<li>
<p dir="auto"><strong>Continuous dynamics</strong>: 1D &amp; 2D substrates, <code>DynamicsTask</code>, RK4 &amp; symplectic integrators</p>
</li>
<li>
<p dir="auto"><strong>Coupling tasks</strong>:</p>
<ul dir="auto">
<li>Gravitational two-body (1D)</li>
<li>Coulomb coupling (1D)</li>
<li>Lorentz-force (2D) for charged particles in a magnetic field</li>
</ul>
</li>
<li>
<p dir="auto"><strong>Quantum-Gravity &amp; Electromagnetism</strong>: Graviton &amp; Photon emission/absorption Tasks</p>
</li>
<li>
<p dir="auto"><strong>UniversalConstructor</strong>: Bootstraps any list of Tasks into a working Constructor</p>
</li>
<li>
<p dir="auto"><strong>Hydrogen atom constructors</strong>: Excitation, deexcitation and two-atom collisions</p>
</li>
<li>
<p dir="auto"><strong>Demo scripts</strong>:</p>
<ul dir="auto">
<li><code>demo.py</code> – shows every constructor in action</li>
<li><code>bootstrap_demo.py</code> – elegant self-replication via the UniversalConstructor</li>
</ul>
</li>
</ul>
<hr/>


<ul dir="auto">
<li>Python 3.8+</li>
<li>(Optional) <code>matplotlib</code> for phase-space plots</li>
</ul>

<div dir="auto" data-snippet-clipboard-copy-content="git clone https://github.com/gvelesandro/constructor-theory-simulator.git
cd constructor-theory-simulator"><pre>git clone https://github.com/gvelesandro/constructor-theory-simulator.git
<span>cd</span> constructor-theory-simulator</pre></div>

<div dir="auto" data-snippet-clipboard-copy-content="python -m unittest ct_tests.py"><pre>python -m unittest ct_tests.py</pre></div>

<div dir="auto" data-snippet-clipboard-copy-content="python demo.py
python bootstrap_demo.py"><pre>python demo.py
python bootstrap_demo.py</pre></div>
<blockquote>
<p dir="auto"><strong>Note:</strong> If you don’t have <code>matplotlib</code>, the demos will still run; plots will simply be skipped with a warning.</p>
</blockquote>
<hr/>

<div dir="auto" data-snippet-clipboard-copy-content="from ct_framework import (
    Attribute, Substrate,
    PhotonEmissionTask, PhotonAbsorptionTask,
    UniversalConstructor, ascii_branch
)

# 1) Define your “program” of photon Tasks
ELEC = Attribute(&#34;charge_site&#34;)
prog = [
    PhotonEmissionTask(ELEC, emission_energy=5.0, carry_residual=False),
    PhotonAbsorptionTask(ELEC, absorption_energy=5.0)
]

# 2) Build a Constructor at runtime
uc      = UniversalConstructor()
em_cons = uc.build(prog)

# 3) Emit a photon
atom = Substrate(&#34;A&#34;, ELEC, energy=20.0)
branches = em_cons.perform(atom)
print(ascii_branch(branches))
# =&gt; * charge_site (A)
#    * photon      (A)

# 4) Absorb it back
photon   = next(w for w in branches if w.attr.label==&#34;photon&#34;)
restored = em_cons.perform(photon)[0]
print(restored)
# =&gt; A:charge_site(E=20.0,Q=0,t=2,F=charge_site)"><pre><span>from</span> <span>ct_framework</span> <span>import</span> (
    <span>Attribute</span>, <span>Substrate</span>,
    <span>PhotonEmissionTask</span>, <span>PhotonAbsorptionTask</span>,
    <span>UniversalConstructor</span>, <span>ascii_branch</span>
)

<span># 1) Define your “program” of photon Tasks</span>
<span>ELEC</span> <span>=</span> <span>Attribute</span>(<span>&#34;charge_site&#34;</span>)
<span>prog</span> <span>=</span> [
    <span>PhotonEmissionTask</span>(<span>ELEC</span>, <span>emission_energy</span><span>=</span><span>5.0</span>, <span>carry_residual</span><span>=</span><span>False</span>),
    <span>PhotonAbsorptionTask</span>(<span>ELEC</span>, <span>absorption_energy</span><span>=</span><span>5.0</span>)
]

<span># 2) Build a Constructor at runtime</span>
<span>uc</span>      <span>=</span> <span>UniversalConstructor</span>()
<span>em_cons</span> <span>=</span> <span>uc</span>.<span>build</span>(<span>prog</span>)

<span># 3) Emit a photon</span>
<span>atom</span> <span>=</span> <span>Substrate</span>(<span>&#34;A&#34;</span>, <span>ELEC</span>, <span>energy</span><span>=</span><span>20.0</span>)
<span>branches</span> <span>=</span> <span>em_cons</span>.<span>perform</span>(<span>atom</span>)
<span>print</span>(<span>ascii_branch</span>(<span>branches</span>))
<span># =&gt; * charge_site (A)</span>
<span>#    * photon      (A)</span>

<span># 4) Absorb it back</span>
<span>photon</span>   <span>=</span> <span>next</span>(<span>w</span> <span>for</span> <span>w</span> <span>in</span> <span>branches</span> <span>if</span> <span>w</span>.<span>attr</span>.<span>label</span><span>==</span><span>&#34;photon&#34;</span>)
<span>restored</span> <span>=</span> <span>em_cons</span>.<span>perform</span>(<span>photon</span>)[<span>0</span>]
<span>print</span>(<span>restored</span>)
<span># =&gt; A:charge_site(E=20.0,Q=0,t=2,F=charge_site)</span></pre></div>
<hr/>

<p dir="auto">This is intended as an <strong>educational resource</strong> and proof-of-concept. Contributions are very welcome! Please:</p>
<ul dir="auto">
<li>File issues for missing tasks or physics modules</li>
<li>Submit pull requests for new constructors (e.g. chemical reactions, friction)</li>
<li>Improve documentation or add more demos</li>
</ul>
<hr/>

<p dir="auto">Released under the <strong>MIT License</strong>.</p>
<hr/>

<ul dir="auto">
<li>Inspired by David Deutsch and Chiara Marletto’s work in <strong>Constructor Theory</strong> and their May 13, 2025 paper “<a href="https://arxiv.org/abs/2505.08692" rel="nofollow">Constructor Theory of Time</a>.”</li>
<li>Thanks to the quantum-foundations community for feedback and discussion.</li>
</ul>
</article></div></div>
  </body>
</html>
