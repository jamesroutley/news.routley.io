<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://maskray.me/blog/2023-04-12-elf-hash-function">Original</a>
    <h1>ELF hash function may overflow</h1>
    
    <div id="readability-page-1" class="page"><div id="wrap">
      

      <div>
        <section id="main"><article id="post-elf-hash-function" itemprop="blogPost" itemscope="" itemtype="https://schema.org/BlogPosting">
  
  <div>
    
    
      <header>
        
  
    
  

      </header>
    
    <div itemprop="articleBody">
      
        <p>This article describes an interesting overflow bug in the ELF hash
function.</p>
<p>The System V Application Binary Interface (generic ABI) specifies the
ELF object file format. When producing an output executable or shared
object needing a dynamic symbol table (<code>.dynsym</code>), a linker
generates a <code>.hash</code> section with type <code>SHT_HASH</code>
to hold a <a target="_blank" rel="noopener" href="http://www.sco.com/developers/gabi/latest/ch5.dynamic.html#hash">symbol
hash table</a>. A <code>DT_HASH</code> tag is produced to hold the
address of <code>.hash</code>.</p>
<p><code>DT_HASH</code> is used by a dynamic loader to perform symbol
lookup (for dynamic relocations and <code>dlsym</code> family
functions). A detailed description of the format can be found in <a target="_blank" rel="noopener" href="https://flapenguin.me/elf-dt-hash">ELF: symbol lookup via
<code>DT_HASH</code></a>.</p>
<h2 id="other-use-cases">Other use cases</h2>
<p>In a Solaris Version Definition Section, <code>vd_hash</code> holds a
value generated using the ELF hash function. The GNU symbol versioning
scheme inherits this field from Solaris.</p>
<p>There are usually very few version definitions, so the overflow bug
below is very unlikely to cause any problem.</p>
<h2 id="overflow-bug">Overflow bug</h2>
<p>The generic ABI gives the following code fragment in &#34;Figure 5-13:
Hashing Function&#34;. </p><figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span><span>unsigned</span> <span>long</span></span></pre></td></tr></tbody></table></figure>
<p>The function is supposed to return a value no larger than 0x0fffffff.
Unfortunately, there is a bug. When <code>unsigned long</code> consists
of more than 32 bits, the return value may be larger than
<code>UINT32_MAX</code>. For instance,
<code>elf_hash((const unsigned char *)&#34;\xff\x0f\x0f\x0f\x0f\x0f\x12&#34;)</code>
returns 0x100000002, which is clearly unintended, as the function should
behave the same way regardless of whether <code>long</code> represents a
32-bit integer or a 64-bit integer.</p>
<p>It is possible to use 7-bit ASCII characters to trigger the issue.
For instance,</p>
<ul>
<li><code>elf_hash((const unsigned char *)&#34;iiiiii\na&#34;)) == 100000001</code></li>
<li><code>elf_hash((const unsigned char *)&#34;ZZZZZX+a&#34;)) == 100000011</code></li>
<li><code>elf_hash((const unsigned char *)&#34;ZZZZZW9p&#34;)) == 100000000</code></li>
</ul>
<p>Most ELF operating systems have switched from <code>DT_HASH</code> to
<code>DT_GNU_HASH</code> for many years and prefer
<code>DT_GNU_HASH</code> for symbol search. We can build a shared object
with <code>ld -shared --hash-style=sysv</code> and check whether a
dynamic symbol named &#34;ZZZZZW9p&#34; can be bound by relocation
resolver/<code>dlsym</code>.</p>
<h2 id="project-survey">Project survey</h2>
<p>glibc <a target="_blank" rel="noopener" href="https://sourceware.org/git/?p=glibc.git;a=commit;h=6e33fad374814f1a4bf80aa37d4ded9c9096edab">fixed
the overflow issue</a> while optimizing the function in April 1995. The
two XOR operations were <a target="_blank" rel="noopener" href="https://sourceware.org/git/?p=glibc.git;a=commit;h=f039c043071f2f55943d052fa7d4ad5f1a67db09">optimized
to one</a> in Dec 2011.</p>
<p>binutils-gdb <a target="_blank" rel="noopener" href="https://sourceware.org/git/?p=binutils-gdb.git;a=commit;h=32dfa85d9015feea4a06d423fe58f6eaf841456e">fixed
the overflow issue</a> in May 2003.</p>
<p>musl has had the elegant and efficient implementation since June 2011
(initial check-in of the dynamic linker). It is worth noting that
<code>uint_fast32_t</code> is used, so that an architecture can optimize
the implementation if the architecture has slow 32-bit integer
arithmetic operations. </p><figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span><span><span>static</span> <span>uint32_t</span> <span>sysv_hash</span><span>(<span>const</span> <span>char</span> *s0)</span></span></span></pre></td></tr></tbody></table></figure>
<p>Nathan Sidwell <a target="_blank" rel="noopener" href="https://reviews.llvm.org/D147890">raised the
issue for llvm-project</a> and pointed out a bug about using
<code>char</code> instead of <code>unsigned char</code> on
2023-04-09.</p>
<p>I asked <a target="_blank" rel="noopener" href="https://groups.google.com/g/generic-abi/c/8J_jtjsonrE/m/dd3V9JAIBgAJ">What
if the result of elf_hash is larger than UINT32_MAX?</a> on
2023-04-11.</p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="https://maskray.me/blog/2023-03-19-lld-16-elf-changes" id="article-nav-older">
      <strong>Older</strong>
      <p>lld 16 ELF changes</p>
    </a>
  
</nav>

  
</article>




</section>
        
          
        
      </div>
      

    </div></div>
  </body>
</html>
