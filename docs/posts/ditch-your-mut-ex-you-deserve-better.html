<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://chrispenner.ca/posts/mutexes">Original</a>
    <h1>Ditch your (mut)ex, you deserve better</h1>
    
    <div id="readability-page-1" class="page"><article>
        <p>Having access to multiple parallel CPU cores isn&#39;t a new thing by any
means, people have been programming in parallel for half a century now,
but recent years we&#39;ve found ourselves at an inflection point. Moore&#39;s
law is dying, beefy single cores are no longer keeping up. Modern
computers come with multiple CPU cores, so exploiting parallel compute
is more important than ever. Given how long it&#39;s been an area of
research we can naturally expect that effective tools have taken root
and that synchronizing threads is trivial now right...?</p>
<p>Unfortunately this has not been my experience, and I&#39;m willing to bet
it hasn&#39;t been yours either. Managing shared state across threads is
hard, and the most commonly used tools: mutexes and semaphores, simply
haven&#39;t evolved much since their inception.</p>
<p>The words that follow will dig into the problems inherent to mutexes
and synchronizing shared mutable state. Afterwards we&#39;ll look into other
avenues which should prove more helpful.</p>

<p>Let&#39;s begin by crafting a simple software system which needs
synchronization in the first place.</p>
<p>I&#39;ll present a commonly used example: the task of managing bank
account balances correctly in spite of parallel transfer requests.</p>
<p>Of course real banks don&#39;t store all their account balances in RAM,
so I&#39;ll hope that the reader can apply the concepts from this
pedagogical example to a their own domain as necessary, it serves as a
stand-in for any sufficiently complex system which requires ad-hoc
synchronization of arbitrary data between multiple threads.</p>
<p>Here&#39;s some golang&#39;ish pseudo-code (please don&#39;t try to actually
compile it) for a simple bank account and the operations upon it. I&#39;m
focused on the synchronization problems here, so forgive me for skipping
the double-entry accounting, input validation, and other real-world
complexities.</p>
<div id="cb1"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span>struct</span> Account <span>{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  balance <span>int</span><span>,</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span>// Deposit money into an account</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span>func</span> <span>(</span>a <span>*</span>Account<span>)</span> deposit<span>(</span>amount <span>int</span><span>)</span> <span>{</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  a<span>.</span>balance <span>+=</span> amount</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span>// Withdraw money from an account, or return false if there are insufficient funds</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span>func</span> <span>(</span>a <span>*</span>Account<span>)</span> withdraw<span>(</span>amount <span>int</span><span>)</span> <span>bool</span> <span>{</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>  <span>if</span> <span>(</span>a<span>.</span>balance <span>&lt;=</span> amount<span>)</span> <span>{</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    <span>return</span> <span>false</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>  <span>}</span> <span>else</span> <span>{</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    balance <span>-=</span> amount</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    <span>return</span> <span>true</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>  <span>}</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>Great! This defines our Account type and some methods for withdrawing
and depositing money into such an account. Now let&#39;s add a function to
transfer money between accounts:</p>
<div id="cb2"><pre><code><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span>func</span> transfer<span>(</span>from <span>*</span>Account<span>,</span> to <span>*</span>Account<span>,</span> amount <span>int</span><span>)</span> <span>bool</span> <span>{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span>if</span> <span>(</span>from<span>.</span>withdraw<span>(</span>amount<span>))</span> <span>{</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    to<span>.</span>deposit<span>(</span>amount<span>)</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span>return</span> <span>true</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  <span>}</span> <span>else</span> <span>{</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span>return</span> <span>false</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>  <span>}</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>Looks good, but now what happens when we start handling multiple
requests concurrently?</p>
<div id="cb3"><pre><code><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span>struct</span> TransferRequest <span>{</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  from <span>*</span>Account<span>,</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  to <span>*</span>Account<span>,</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  amount <span>int</span><span>,</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span>func</span> main<span>()</span> <span>{</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>  <span>// loop forever, accepting transfer requests and processing them in goroutines</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>  <span>for</span> <span>{</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    req <span>:=</span> acceptTransferRequest<span>()</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    <span>go</span> transfer<span>(</span>req<span>.</span>from<span>,</span> req<span>.</span>to<span>,</span> req<span>.</span>amount<span>)</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>  <span>}</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>Things may work well in your tests if you&#39;re (un)lucky, and might
even work well in production for a while, but sooner or later you&#39;re
going to lose track of money and have some confused and angry
customers.</p>
<p>Do you see why? This brings us to our first synchronization problem
to solve, <strong>Data Races</strong>.</p>
<h3 id="data-races">Data races</h3>
<p><strong>Most</strong> programming languages are imperative with
mutable data structures <strong>[citation needed]</strong>, so passing
pointers to multiple threads leads to <em>shared mutable data</em>, and
<em>shared mutable data</em> necessarily causes <em>data races</em>.</p>
<p>A data race occurs any time two threads access the same memory
location concurrently and non-deterministically when at least one of the
accesses is a write. When a data race is present two runs of the same
code with the same state may non-deterministically have a different
result.</p>
<p>We&#39;re passing accounts by reference here, so multiple threads have
access to modify the same account. With multiple transfer go-routines
running on the same account, each could be paused by the scheduler at
nearly any point during its execution. This means that even within this
simple example we&#39;ve already introduced a data race. Take another look
at the <code>withdraw</code> function, I&#39;ll point it out:</p>
<div id="cb4"><pre><code><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span>// Withdraw money from an account, or return false if there are insufficient funds</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span>func</span> <span>(</span>a <span>*</span>Account<span>)</span> withdraw<span>(</span>amount <span>int</span><span>)</span> <span>bool</span> <span>{</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  hasFunds <span>:=</span> a<span>.</span>balance <span>&gt;=</span> amount </span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  <span>// HERE! The scheduler could pause execution here and switch to another thread</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  <span>if</span> <span>(</span>hasFunds<span>)</span> <span>{</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    balance <span>-=</span> amount</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    <span>return</span> <span>true</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>  <span>}</span> <span>else</span> <span>{</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    <span>return</span> <span>false</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>  <span>}</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>If two threads are withdrawing $100 from Alice&#39;s account, which only
has $150 in it, it&#39;s possible that thread 1 checks the balance, sees
there&#39;s enough money, then gets paused by the scheduler. Thread 2 runs,
checks the balance, also sees there&#39;s enough money, then withdraws $100.
When thread 1 later resumes execution <em>after the check</em> it
withdraws its $100 too, Alice&#39;s account ends up with a negative balance
of -$50, which is invalid even though we had validation!</p>
<p>This sort of concurrency error is particularly insidious because the
original <code>withdraw</code> method is perfectly reasonable,
idiomatic, and correct in a single-threaded program; however when we
decide to add concurrency at a <strong>completely different
place</strong> in the system we&#39;ve introduced a bug deep within existing
previously correct code. The idea that a perfectly normal evolution from
a single-threaded to a multi-threaded program can introduce
<strong>critical system-breaking bugs</strong> in completely unrelated
code without so much as a warning is quite frankly <em>completely
unacceptable</em>. As a craftsman I expect better from my tools.</p>
<p>Okay, but now that we&#39;ve lost thousands if not millions of dollars,
how do we fix this?</p>
<p>Traditional knowledge points us towards <strong>Mutexes</strong>.</p>
<h3 id="mutexes">Mutexes</h3>
<p>Okay, we&#39;ve encountered a problem with our shared mutable state, the
traditional approach to solving these problems is to enforce
<em>exclusive access</em> to the shared data in so-called &#34;critical
sections&#34;. Mutexes are so-named because they provide
<strong>mut</strong>ual <strong>ex</strong>clusion, meaning only a
single thread may access a given virtual resource at a time.</p>
<p>Here&#39;s how we can edit our program to fix the data race problems
using a mutex:</p>
<div id="cb5"><pre><code><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span>struct</span> Account <span>{</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  mutex Mutex<span>,</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  balance <span>int</span><span>,</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span>func</span> <span>(</span>a <span>*</span>Account<span>)</span> deposit<span>(</span>amount <span>int</span><span>)</span> <span>{</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>  a<span>.</span>mutex<span>.</span>lock<span>()</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>  <span>defer</span> a<span>.</span>mutex<span>.</span>unlock<span>()</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>  a<span>.</span>balance <span>+=</span> amount</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a><span>func</span> <span>(</span>a <span>*</span>Account<span>)</span> withdraw<span>(</span>amount <span>int</span><span>)</span> <span>bool</span> <span>{</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>  a<span>.</span>mutex<span>.</span>lock<span>()</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>  <span>defer</span> a<span>.</span>mutex<span>.</span>unlock<span>()</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>  hasFunds <span>:=</span> a<span>.</span>balance <span>&gt;=</span> amount </span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>  <span>if</span> <span>(</span>hasFunds<span>)</span> <span>{</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>    balance <span>-=</span> amount</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>    <span>return</span> <span>true</span></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>  <span>}</span> <span>else</span> <span>{</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>    <span>return</span> <span>false</span></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>  <span>}</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>Now every <code>Account</code> has a mutex on it, which acts as an
exclusive lock.</p>
<p>It&#39;s much like a bathroom key in a busy restaurant. When you want to
use the bathroom, you take the key, there&#39;s only one key available for
each bathroom, so while you&#39;ve got hold of it nobody else can use that
bathroom. Now you&#39;re free to do your business, then you return the key
to the hook on the wall for the next person.</p>
<p>Unlike a bathroom key however, mutexes are only <em>conceptual</em>
locks, not <em>real</em> locks, and as such they operate on the honor
system.</p>
<p>If the programmer forgets to lock the mutex the system won&#39;t stop
them from accessing the data anyways, and even then there&#39;s no actual
link between the data being locked and the lock itself, we need to trust
the programmers to both <em>understand</em> and <em>respect</em> the
agreement. A risky prospect on both counts.</p>
<p>In this case, we&#39;ve addressed the data-race within
<code>withdraw</code> and <code>deposit</code> by using mutexes, but
we&#39;ve still got a problem within the <code>transfer</code> function.</p>
<p>What happens if a thread is pre-empted between the calls to
<code>withdraw</code> and <code>deposit</code> while running the
<code>transfer</code> function? It&#39;s possible that money will been
withdrawn from an account, but won&#39;t have yet been deposited in the
other. This is an inconsistent state of the system, the money has
temporarily disappeared, existing only in the operating memory of a
thread, but not visible in any externally observable state. This can
(and will) result in <em>very</em> strange behaviour.</p>
<p>As a concrete way to observe the strangeness let&#39;s write a
<code>report</code> function which prints out all account balances:</p>
<div id="cb6"><pre><code><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span>func</span> report<span>()</span> <span>{</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span>for</span> _<span>,</span> account <span>:=</span> <span>range</span> accounts <span>{</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>        account<span>.</span>mutex<span>.</span>lock<span>()</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>        fmt<span>.</span>Println<span>(</span>account<span>.</span>balance<span>)</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>        account<span>.</span>mutex<span>.</span>unlock<span>()</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    <span>}</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>If we run a <code>report</code> while transfers are ongoing we&#39;ll
likely see that the count of the total amount of money that exists
within the system is incorrect, and changes from report to report, which
should be impossible in a closed system like this! This inconsistency
occurs even if we obtain the locks for each individual account before
checking the balance.</p>
<p>In larger systems this sort of inconsistency problem can cause flaws
in even simple logic, since choices may be made against inconsistent
system states. The root of this issue is that the <code>transfer</code>
function requires holding multiple independent locks, but they&#39;re not
grouped in any way into an atomic operation.</p>
<h3 id="composing-critical-sections">Composing Critical Sections</h3>
<p>We need some way to make the entire transfer operation atomic, at
least from the perspective of other threads who are respecting our
mutexes.</p>
<p>Okay, well no problem, we can just lock both accounts, right?</p>
<div id="cb7"><pre><code><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span>func</span> transfer<span>(</span>from <span>*</span>Account<span>,</span> to <span>*</span>Account<span>,</span> amount <span>int</span><span>)</span> <span>bool</span> <span>{</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>  from<span>.</span>mutex<span>.</span>lock<span>()</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  to<span>.</span>mutex<span>.</span>lock<span>()</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>  <span>defer</span> from<span>.</span>mutex<span>.</span>unlock<span>()</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>  <span>defer</span> to<span>.</span>mutex<span>.</span>unlock<span>()</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>  <span>if</span> <span>(</span>from<span>.</span>withdraw<span>(</span>amount<span>))</span> <span>{</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    to<span>.</span>deposit<span>(</span>amount<span>)</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    <span>return</span> <span>true</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>  <span>}</span> <span>else</span> <span>{</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>    <span>return</span> <span>false</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>  <span>}</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>I&#39;m sure some readers have already seen a problem here, but have you
seen <em>two</em> problems here?</p>
<p>The first is obvious when you point it out, remember that
<code>withdraw</code> and <code>deposit</code> <em>also</em> lock the
mutex on the account, so we&#39;re trying to acquire the same lock twice in
the <em>same thread</em>.</p>
<p><code>transfer</code> won&#39;t even begin to run in this state, it will
block forever inside <code>withdraw</code> when it tries to lock the
<code>from.mutex</code> for the second time.</p>
<p>Some systems, like <em>re-entrant locks</em> and Java&#39;s
<code>synchronized</code> keyword do some additional book-keeping which
allow a single thread to lock the same mutex multiple times, so using a
re-entrant lock here would solve this particular problem. However other
systems, like golang, avoid providing re-entrant locks <a href="https://groups.google.com/g/golang-nuts/c/XqW1qcuZgKg/m/Ui3nQkeLV80J">on
a matter of principle</a>.</p>
<p>So what can we do? I suppose we&#39;ll need to pull the locks <em>out
of</em> <code>withdraw</code> and <code>deposit</code> so we can lock
them in <code>transfer</code> instead.</p>
<div id="cb8"><pre><code><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span>func</span> <span>(</span>a <span>*</span>Account<span>)</span> deposit<span>(</span>amount <span>int</span><span>)</span> <span>{</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>  a<span>.</span>balance <span>+=</span> amount</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span>func</span> <span>(</span>a <span>*</span>Account<span>)</span> withdraw<span>(</span>amount <span>int</span><span>)</span> <span>bool</span> <span>{</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>  hasFunds <span>:=</span> a<span>.</span>balance <span>&gt;=</span> amount </span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>  <span>if</span> <span>(</span>hasFunds<span>)</span> <span>{</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    balance <span>-=</span> amount</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>    <span>return</span> <span>true</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>  <span>}</span> <span>else</span> <span>{</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    <span>return</span> <span>false</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>  <span>}</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a><span>func</span> transfer<span>(</span>from <span>*</span>Account<span>,</span> to <span>*</span>Account<span>,</span> amount <span>int</span><span>)</span> <span>bool</span> <span>{</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>  from<span>.</span>mutex<span>.</span>lock<span>()</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>  to<span>.</span>mutex<span>.</span>lock<span>()</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>  <span>defer</span> from<span>.</span>mutex<span>.</span>unlock<span>()</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>  <span>defer</span> to<span>.</span>mutex<span>.</span>unlock<span>()</span></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>  <span>if</span> <span>(</span>from<span>.</span>withdraw<span>(</span>amount<span>))</span> <span>{</span></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>    to<span>.</span>deposit<span>(</span>amount<span>)</span></span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>    <span>return</span> <span>true</span></span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>  <span>}</span> <span>else</span> <span>{</span></span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a>    <span>return</span> <span>false</span></span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a>  <span>}</span></span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>Ugh, a correct <code>transfer</code> function should conceptually
just be the <em>composition</em> of our well encapsulated
<code>withdraw</code> and a <code>deposit</code> functions, but defining
it <em>correctly</em> has forced us to remove the locking from both
<code>withdraw</code> and <code>deposit</code>, making both of them
<em>less safe</em> to use. It has placed the burden of locking on the
caller (without <em>any</em> system-maintained guarantees), and even
worse, we now need to remember to go and <em>add</em> locking around
every existing <code>withdraw</code> and <code>deposit</code> call in
the entire codebase. Even if we try to encapsulate everything within the
module and only export &#34;safe&#34; operations we&#39;ve caused duplication since
we now need synchronized and unsynchronized versions of our
<code>withdraw</code> and <code>deposit</code> operations. And we&#39;d
still need to expose the mutexes if we want to allow callers to
synchronize operations with other non-<code>Account</code> data.</p>
<p>What I&#39;m getting at is that mutexes don&#39;t <em>compose</em>! They
don&#39;t allow us to chain multiple critical sections into a single atomic
unit, they force us to break encapsulation and thrust the implementation
details of mutexes and locking onto the caller who shouldn&#39;t need to
know the details about which invariants must be maintained deep within
the implementation. Adding or removing access to synchronized variables
within an operation will also necessitate adding or removing locking to
<em>every call site</em>, and those call sites may be in a completely
different application or library. This is an absolute mess.</p>
<p>All that sounds pretty bad, but would you believe those aren&#39;t the
only problems here? It&#39;s not just composition that&#39;s broken here though,
in fixing <code>transfer</code> to make it an atomic operation we&#39;ve
managed to introduce a new, extra-well-hidden deadlock bug.</p>
<h3 id="deadlockslivelocks">Deadlocks/Livelocks</h3>
<p>Recall that in our main loop we&#39;re accepting arbitrary transfer
requests and spawning them off in goroutines. What happens in our system
if we have two transfer requests, Alice is trying to Venmo Bob $25 for
the beanbag chair she just bought off him, meanwhile Bob remembers he
needs to Venmo Alice the $130 he owes her for Weird Al concert
tickets.</p>
<p>If by sheer coincidence they both submit their requests at the same
time, we have two <code>transfer</code> calls:</p>
<ul>
<li><code>transfer(aliceAccount, bobAccount, 25)</code></li>
<li><code>transfer(bobAccount, aliceAccount, 130)</code></li>
</ul>
<p>Each of these calls will attempt to lock their <code>from</code>
account and <em>then</em> their <code>to</code> account. If Alice and
Bob get very unlucky, the system will start the first
<code>transfer</code> and lock Alice&#39;s account, then get paused by the
scheduler. When the second <code>transfer</code> call comes in, it first
locks Bob&#39;s account, then tries to lock Alice&#39;s account, but can&#39;t
because it&#39;s already locked by the first <code>transfer</code> call.</p>
<p>This is a classic deadlock situation. Both threads will be stuck
forever, and worse, both Alice and Bob&#39;s accounts will be locked until
the system restarts.</p>
<p>This is a pretty disastrous consequence for a problem which is
relatively hard to spot even in this trivially simple example. In a real
system with dozens or hundreds of methods being parallelized in a
combinatorial explosion of ways it&#39;s <strong>very difficult</strong> to
reason about this, and can be a lot of work to ensure locks are obtained
in a safe and consistent order.</p>
<p>Golang gets some credit here in that it does provide <em>some</em>
runtime tools for detecting both dead-locks and data-races, which is
great, but these detections only help if your tests encounter the
problem; they don&#39;t prevent the problem from happening in the first
place. Most languages aren&#39;t so helpful, these issues can be very
difficult to track down in production systems.</p>
<h3 id="assessing-the-damage">Assessing the damage</h3>
<p>What a dumpster fire we&#39;ve gotten ourselves into...</p>
<p>While it may be no accident that the example I&#39;ve engineered happens
to hit all of the worst bugs at once, in my experience, given enough
time and complexity these sorts of problems will crop up any system
eventually. Solving them with mutexes is especially dangerous because it
will <em>seem</em> to be an effective solution at first. Mutexes work
fine in small localized use-cases, thus tempting us to use them, but as
the system grows organically we stretch them too far and they fail
catastrophically as the complexity of the system scales up, causing all
sorts of hacky workarounds. I&#39;m of the opinion that crossing your
fingers and hoping for the best is not an adequate software-engineering
strategy.</p>
<p>So, we&#39;ve seen that architecting a correct software system using
mutexes is <em>possible</em>, but <strong>very difficult</strong>. Every
attempt we&#39;ve made to fix one problem has spawned a couple more.</p>
<p>Here&#39;s a summary of the problems we&#39;ve encountered:</p>
<ul>
<li>Data races causing non-determinism and logic bugs</li>
<li>Lack of atomicity causing inconsistent system states</li>
<li>Lack of composition causing
<ul>
<li>Broken encapsulation</li>
<li>Code duplication</li>
<li>Cognitive overload on callers</li>
</ul></li>
<li>Deadlocks/livelocks causing system-wide freezes</li>
<li>New features may require changes to every call-site</li>
</ul>
<p>In my opinion, we&#39;ve tried to stretch mutexes beyond their limits,
both in this blog post and in the industry as a whole. Mutexes work
great in small, well-defined scopes where you&#39;re locking a
<em>single</em> resource which is only ever accessed in a handful of
functions in the same module, but they&#39;re too hard to wrangle in larger
complex systems with many interacting components maintained by dozens or
hundreds of developers. We need to evolve our tools and come up with
more reliable solutions.</p>
<h2 id="cleaning-up-the-chaos">Cleaning up the Chaos</h2>
<p>Thankfully, despite an over-reliance on mutexes, we as an industry
have still learned a thing or two since the 1960s. Particularly I think
that enforcing <em>immutability by default</em> goes a <em>long</em> way
here. For many programmers this is a paradigm shift from what they&#39;re
used to, which usually causes some uneasiness. Seatbelts, too, were
often scorned in their early years for their restrictive nature, but
over time it has become the prevailing opinion that the mild
inconvenience is more than worth the provided safety.</p>
<p>More and more languages (Haskell, Clojure, Erlang, Gleam, Elixir,
Roc, Elm, Unison, ...) are realizing this and are adopting this as core
design principle. Obviously not every programmer can switch to an
immutable-first language over night, but I think it would behoove most
programmers to strongly consider an immutable language if parallelism is
a large part of their project&#39;s workload.</p>
<p>Using immutable data structures immediately prevents data-races,
full-stop. So stick with immutable data everywhere you can, but in a
world of immutability we&#39;ll still need some way to synchronize parallel
processes and for that most of these languages do still provide some
form of mutable reference. It&#39;s never the default, and there&#39;s typically
some additional ceremony or tracking in the type system which acts as an
immediate sign-post that shared-mutable state is involved; here there be
dragons.</p>
<p>Even better than mutable references, decades of research and
industrial research have provided us with a swath battle-tested
high-level concurrency patterns which are built on top of lower-level
synchronization primitives like mutexes or mutable references, typically
exposing much safer interfaces to the programmer.</p>
<h3 id="concurrency-patterns">Concurrency Patterns</h3>
<p>Actor systems and Communicating Sequential Processes (CSP) are some
of the most common concurrency orchestration patterns. Each of these
operate by defining independent sub-programs which have their own
isolated states which only they can access. Each actor or process
receives messages from other units and can respond to them in turn. Each
of these deserves a talk or blog post of their own so I won&#39;t dive too
deeply into them here, but please look into them deeper if this is the
first you&#39;re hearing of them.</p>
<p>These approaches work great for <em>task parallelism</em>, where
there are independent processes to run, and where your parallelism needs
are bounded by the number of tasks you&#39;d like to run. As an example, I
used an actor-based system when building Unison&#39;s code-syncing protocol.
There was one actor responsible for loading and sending requests for
code, one for receiving and unpacking code, and one for validating the
hashes of received code. This system required <strong>exactly</strong> 3
workers to co-operate regardless of <em>how many things</em> I was
syncing. Actor and CSP systems are great choices when the number of
workers/tasks we need to co-ordinate is statically known, i.e. a fixed
number of workers, or a pre-defined map-reduce pipeline. These patterns
can scale well to many cores since each actor or process can run
independently on its own core without worrying about synchronizing
access to shared mutable state, and as a result can often scale to
multiple machines as well.</p>
<p>However, there are also problems where the parallelism is
<em>dynamic</em> or ad-hoc, meaning there could be any number of
runtime-spawned concurrent actors that must co-ordinate well with each
other. In those cases these systems tend to break down. I&#39;ve seen
consultants describe complex patterns for dynamically introducing
actors, one-actor-per-resource systems, tree-based actor resource
hierarchies and other complex ideas but in my opinion these systems
quickly outgrow the ability of any one developer to understand and
debug.</p>
<p>So how then do we model a system like the bank account example? Even
if we were to limit the system to a fixed number of transfer-workers
they&#39;d still be concurrently accessing the same data (the bank accounts)
and need some way to express <strong>atomic transfers</strong> between
them, which isn&#39;t easily accomplished with actors or CSP.</p>
<p>What&#39;s a guy to do?</p>
<h2 id="a-new-old-synchronization-primitive">A new (old) synchronization
primitive</h2>
<p>In the vast majority of cases using a streaming system, actors or CSP
is going to be most effective and understandable. However in cases where
we must synchronize individual chunks of data across many workers, and
require operations to affect multiple chunks of data atomically, there&#39;s
only one name in town that gets the job done right.</p>
<p>Software Transactional Memory (STM) is a criminally under-utilized
synchronization tool which solves all of the problems we&#39;ve encountered
so far while providing more safety, better compositionality, and cleaner
abstractions. Did I mention they prevent most deadlocks and livelocks
too?</p>
<p>To understand how STM works, think of database transactions; in a
database transaction isolation provides you with a consistent view of
data in spite of concurrent access. Each transaction sees an isolated
view of the data, untampered by other reads and writes. After making all
your reads and writes you <em>commit</em> the transaction. Upon commit,
the transaction either succeeds completely and applies <em>ALL</em> the
changes you made to the data snapshot, or it may result in a
<em>conflict</em>. In cases of a conflict the transaction <em>fails</em>
and <em>rolls back</em> all your changes as though nothing happened,
then it can retry on the new data snapshot.</p>
<p>STM works in much the same way, but instead of the rows and columns
in a database, transactions operate on normal in-memory data structures
and variables.</p>
<p>To explore this technique let&#39;s convert our bank account example into
Haskell so we can use STM instead of mutexes.</p>
<div id="cb9"><pre><code><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span>data</span> <span>Account</span> <span>=</span> <span>Account</span> {</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>  <span>-- Data that needs synchronization is stored in a </span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  <span>-- Transactional Variable, a.k.a. TVar</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span>  balanceVar ::</span> <span>TVar</span> <span>Int</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span>-- Deposit money into an account.</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a><span>deposit ::</span> <span>Account</span> <span>-&gt;</span> <span>Int</span> <span>-&gt;</span> <span>STM</span> ()</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>deposit <span>Account</span>{balanceVar} amount <span>=</span> <span>do</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>  <span>-- We interact with the data using TVar operations which</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>  <span>-- build up an STM transaction.</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>  modifyTVar balanceVar (\existing <span>-&gt;</span> existing <span>+</span> amount)</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a><span>-- Withdraw money from an account</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a><span>-- Everything within the `do` block</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a><span>-- is part of the same transaction.</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a><span>-- This guarantees a consistent view of the TVars we </span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a><span>-- access and mutate.</span></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a><span>withdraw ::</span> <span>Account</span> <span>-&gt;</span> <span>Int</span> <span>-&gt;</span> <span>STM</span> <span>Bool</span></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>withdraw <span>Account</span>{balanceVar} amount <span>=</span> <span>do</span></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>  existing <span>&lt;-</span> readTVar balanceVar</span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>  <span>if</span> existing <span>&lt;=</span> amount</span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a>    <span>then</span> (<span>return</span> <span>False</span>)</span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a>    <span>else</span> <span>do</span></span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a>      writeTVar balanceVar (existing <span>-</span> amount)</span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a>      <span>return</span> <span>True</span></span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true" tabindex="-1"></a><span>-- Transfer money between two accounts atomically</span></span>
<span id="cb9-29"><a href="#cb9-29" aria-hidden="true" tabindex="-1"></a><span>transfer ::</span> <span>Account</span> <span>-&gt;</span> <span>Account</span> <span>-&gt;</span> <span>Int</span> <span>-&gt;</span> <span>STM</span> <span>Bool</span></span>
<span id="cb9-30"><a href="#cb9-30" aria-hidden="true" tabindex="-1"></a>transfer from to amount <span>=</span> <span>do</span></span>
<span id="cb9-31"><a href="#cb9-31" aria-hidden="true" tabindex="-1"></a>  <span>-- These two individual transactions seamlessly</span></span>
<span id="cb9-32"><a href="#cb9-32" aria-hidden="true" tabindex="-1"></a>  <span>-- compose into one larger transaction, guaranteeing</span></span>
<span id="cb9-33"><a href="#cb9-33" aria-hidden="true" tabindex="-1"></a>  <span>-- consistency without any need to change the individual</span></span>
<span id="cb9-34"><a href="#cb9-34" aria-hidden="true" tabindex="-1"></a>  <span>-- operations.</span></span>
<span id="cb9-35"><a href="#cb9-35" aria-hidden="true" tabindex="-1"></a>  withdrawalSuccessful <span>&lt;-</span> withdraw from amount</span>
<span id="cb9-36"><a href="#cb9-36" aria-hidden="true" tabindex="-1"></a>  <span>if</span> successful</span>
<span id="cb9-37"><a href="#cb9-37" aria-hidden="true" tabindex="-1"></a>    <span>then</span> <span>do</span></span>
<span id="cb9-38"><a href="#cb9-38" aria-hidden="true" tabindex="-1"></a>      deposit to amount</span>
<span id="cb9-39"><a href="#cb9-39" aria-hidden="true" tabindex="-1"></a>      <span>return</span> <span>True</span></span>
<span id="cb9-40"><a href="#cb9-40" aria-hidden="true" tabindex="-1"></a>    <span>else</span> </span>
<span id="cb9-41"><a href="#cb9-41" aria-hidden="true" tabindex="-1"></a>      <span>return</span> <span>False</span></span></code></pre></div>
<p>Let&#39;s do another lap over all the problems we had with mutexes to see
how this new approach fares.</p>
<h3 id="data-races-1">Data Races</h3>
<p>Data races are a problem which I believe are best solved at the
language level itself. As mentioned earlier, using immutable data by
default simply prevents data races from existing in the first place.
Since data in Haskell is all immutable by default, pre-emption can occur
at any point in normal code and <strong>we know</strong> we won&#39;t get a
data race.</p>
<p>When we need <em>mutable data</em>, it&#39;s made explicit by wrapping
that data in <code>TVar</code>s. The language further protects us by
only allowing us to mutate these variables within transactions, which we
compose into operations which are guaranteed a consistent uncorrupted
view of the data.</p>
<p>Let&#39;s convert <code>withdraw</code> to use STM and our
<code>balaceVar</code> TVar.</p>
<div id="cb10"><pre><code><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span>-- Withdraw money from an account</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span>withdraw ::</span> <span>Account</span> <span>-&gt;</span> <span>Int</span> <span>-&gt;</span> <span>STM</span> <span>Bool</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>withdraw <span>Account</span>{balanceVar} amount <span>=</span> <span>do</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>  existing <span>&lt;-</span> readTVar balanceVar</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>  <span>if</span> existing <span>&lt;=</span> amount</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    <span>then</span> (<span>return</span> <span>False</span>)</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    <span>else</span> <span>do</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>      <span>-- No data races here!</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>      writeTVar balanceVar (existing <span>-</span> amount)</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>      <span>return</span> <span>True</span></span></code></pre></div>
<p>We can see that the code we wrote looks very much like the original
unsynchronized golang version, but while using STM it&#39;s perfectly safe
from data races! Even if it the thread is pre-empted in the middle of
the operation, the transaction-state is invisible to other threads until
the transaction commits.</p>
<h3 id="deadlocklivelock">Deadlock/Livelock</h3>
<p>STM is an <strong>optimistic concurrency system</strong>. This means
that threads <strong>never block waiting for locks</strong>. Instead,
each concurrent operation proceeds, possibly in parallel, on their own
independent transaction log. Each transaction tracks which pieces of
data it has accessed or mutated and if at commit time it is detected
that some other transaction has been committed and altered data which
this transaction also accessed, then the latter transaction is rolled
back and is simply retried.</p>
<p>This arrangement is fundamentally different from a lock-based
exclusive access system. In STM, you don&#39;t deal with locks at all, you
simply read and write data within a transaction as necessary. Our
<code>transfer</code> function reads and writes two different
<code>TVar</code>s, but since we&#39;re not obtaining exclusive
<em>locks</em> to these vars, we don&#39;t need to worry about deadlock
<em>at all</em>. If two threads happen to be running a
<code>transfer</code> on the same <code>TVars</code> at the same time,
whichever commits first will atomically apply its updates to both
accounts and the other transaction will detect this update at
commit-time and will retry against the new balances.</p>
<p>This <em>can</em> cause some contention and possibly even starvation
of any single transaction if many threads are trying to update the same
data at the same time, but since a conflict can only occur if some other
transaction has been committed, it does still have the guarantee that
the system will make progress on at least some work. In Haskell, STM
transactions must be <em>pure</em> code, and can&#39;t do IO, so most
transactions are relatively short-running and should proceed eventually.
This seems like a downside, but in practice it only surfaces as a rare
annoyance and can usually be worked around without too much trouble.</p>
<h3 id="composition">Composition</h3>
<p>It may not be immediately obvious from the types if you&#39;re not used
to Haskell code, but all three of <code>withdraw</code>,
<code>deposit</code>, and <code>transfer</code> are all functions which
return their results wrapped in the <code>STM</code> monad, which is
essentially a sequence of operations which we can ask to execute in a
transaction using the <code>atomically</code> function.</p>
<p>We can call out to any arbitrary methods which return something
wrapped in <code>STM</code> and it will automatically be joined in as
part of the current transaction.</p>
<p>Unlike our mutex setup, callers don&#39;t need to manually handle locks
when calling<code>withdraw</code> and <code>deposit</code>, nor do we
need to expose special <strong>synchronized</strong> versions of these
methods for things to be safe. We can define them exactly once and use
that one definition either on its own or within a more complex operation
like <code>transfer</code> without any additional work. The abstraction
is leak-proof, the caller doesn&#39;t need to know which synchronized data
is accessed or lock or unlock any mutexes. It simply runs the
transaction and the STM system happily handles the rest for you.</p>
<p>Here&#39;s what it looks like to actually run our STM transactions, which
we do using the <code>atomically</code> function:</p>
<div id="cb11"><pre><code><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span>main ::</span> <span>IO</span> ()</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>main <span>=</span> <span>do</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  forever <span>$</span> <span>do</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    req <span>&lt;-</span> acceptTransferRequest</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    <span>-- Run each transfer on its own green-thread, in an atomic transaction.</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    forkIO (atomically (transfer req<span>.</span>from req<span>.</span>to req<span>.</span>amount)</span></code></pre></div>
<p>If we&#39;d like to compile a report of all account balances as we did
previously, we can do that too. This time however we won&#39;t get a
potentially inconsistent snapshot of the system by accident, instead the
type-system forces us to make an explicit choice of which behaviour we&#39;d
like.</p>
<p>We can either:</p>
<ul>
<li>Access and print each account balance individually as <em>separate
transaction</em> which means accounts may be edited in-between
transactions, leading to an inconsistent report like we saw
earlier.</li>
<li>Or, we can wrap the entire report into <strong>a single
transaction</strong>, reading all account balances in a single
transaction. This <em>will</em> provide a consistent snapshot of the
system, but due to the optimistic transaction system, the entire
transaction will be retried if any individual <em>transfers</em> commit
and edit accounts while we&#39;re collecting the report. It&#39;s possible that
if transfers are happening <strong>very</strong> frequently, the report
may be retried many times before it can complete.</li>
</ul>
<p>This is a legitimate tradeoff that the developer of the system should
be forced to consider.</p>
<p>Here&#39;s what those two different implementations look like:</p>
<div id="cb12"><pre><code><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span>-- Inconsistent report, may see money disappear/appear</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span>reportInconsistent ::</span> [<span>Account</span>] <span>-&gt;</span> <span>IO</span> ()</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>reportInconsistent accounts <span>=</span> <span>do</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>  for_ accounts <span>$</span> \<span>Account</span>{balanceVar} <span>-&gt;</span> <span>do</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    balance <span>&lt;-</span> atomically (readTVar balanceVar)</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    <span>print</span> balance</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a><span>-- Consistent report, may be retried indefinitely </span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a><span>-- if transfers are happening too frequently</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a><span>reportConsistent ::</span> [<span>Account</span>] <span>-&gt;</span> <span>IO</span> ()</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>reportConsistent accounts <span>=</span> <span>do</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>  balances <span>&lt;-</span> atomically <span>do</span> </span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>    for accounts <span>$</span> \<span>Account</span>{balanceVar} <span>-&gt;</span> <span>do</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>      readTVar balanceVar</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>  <span>-- Now that we&#39;ve got a snapshot we can print it out</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>  for_ balances <span>print</span></span></code></pre></div>
<h2 id="smart-retries">Smart Retries</h2>
<p>One last benefit of STM which we haven&#39;t yet discussed is that it
supports <em>intelligent transaction retries</em> based on conditions of
the synchronized data itself. For instance, if we have a task to
withdraw $100 from Alice&#39;s account but it only has $50 in it, the
mutex-based system has no choice to but fail the withdrawal entirely and
return the failure up the stack. We can wrap that call with code to try
again later, but how will we know when it&#39;s reasonable to try again?
This would once again require the caller to understand the
<em>implementation details</em>, and which locks the method is
accessing.</p>
<p>STM, instead, supports failure and retrying as a first-class concept.
At any point in an STM transaction you can simply call
<code>retry</code>, this will record every <code>TVar</code> that the
transaction has accessed up until that point, then will abort the
current transaction and will sleep until any of those <code>TVar</code>s
has been modified by some other successful transaction. This avoids
busy-waiting, and allows writing some very simple and elegant code.</p>
<p>For example, here&#39;s a new version of our <code>withdraw</code>
function which instead of returning a failure will simply block the
current thread until sufficient funds are available, retrying only when
the balance of that account is changed by some other transaction&#39;s
success.</p>
<div id="cb13"><pre><code><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span>-- Withdraw money from an account, blocking until sufficient funds are available</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span>withdraw ::</span> <span>Account</span> <span>-&gt;</span> <span>Int</span> <span>-&gt;</span> <span>STM</span> ()</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>withdraw <span>Account</span>{balanceVar} amount <span>=</span> <span>do</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>  existing <span>&lt;-</span> readTVar balanceVar</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>  <span>if</span> existing <span>&lt;=</span> amount</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    <span>then</span> retry</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>    <span>else</span> <span>do</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>      writeTVar balanceVar (existing <span>-</span> amount)</span></code></pre></div>
<p>You typically wouldn&#39;t use this to wait for an event which may take
days or weeks to occur like in this example; but it&#39;s a very elegant and
efficient solution for waiting on a channel, waiting for a future to
produce a result, or waiting on any other short-term condition to be
met.</p>
<p>Here&#39;s an example utility for zipping together two STM queues. The
transaction will only succeed and produce a result when a value is
available on both queues, and if that&#39;s not the case, it will only
bother retrying when one of the queues is modified since
<code>readTQueue</code> calls <code>retry</code> internally if the queue
is empty.</p>
<div id="cb14"><pre><code><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span>zipQueues ::</span> <span>TQueue</span> a <span>-&gt;</span> <span>TQueue</span> b <span>-&gt;</span> <span>STM</span> (a, b)</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>zipQueues q1 q2 <span>=</span> <span>do</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>  val1 <span>&lt;-</span> readTQueue q1</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>  val2 <span>&lt;-</span> readTQueue q2</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>  <span>return</span> (val1, val2)</span></code></pre></div>
<p>Nifty!</p>

<p>We&#39;ve covered a <em>lot</em> in this post, if there&#39;s only one thing
you can take away from it, I hope that you&#39;ve taken the time to consider
whether mutexes with shared mutable state are providing you with utility
which outweighs their inherent costs and complexities. Unless you need
peak performance, you may want to think twice about using such dangerous
tools. Instead, consider using a concurrency pattern like actors, CSP,
streaming, or map-reduce if it matches your use-case.</p>
<p>If you need something which provides greater flexibility or
lower-level control, Software Transactional Memory (STM) is a fantastic
choice if it&#39;s available in your language of choice, though note that
not all languages support it, or if they do, may not be able to provide
sufficient safety guarantees due to mutable variables and data
structures.</p>
<p>If you&#39;re starting a new project for which concurrency or parallelism
is a first-class concern, consider trying out a language that supports
STM properly, I can recommend Unison or Haskell as great starting
points.</p>

        <p>
          Hopefully you learned something ! If you did, please consider
          joining <a href="https://www.patreon.com/join/ChrisPenner">my Patreon</a>
          to keep up with my projects, or
          check out my book: It teaches the principles of using optics in
          Haskell and other functional programming languages and takes you all
          the way from an beginner to wizard in all types of optics! You can get
          it <a href="https://leanpub.com/optics-by-example/">here</a>. Every
          sale helps me justify more time writing blog posts like this one and
          helps me to continue writing educational functional programming
          content. Cheers!
        </p>

        <!--Share buttons-->
        

        <!-- Disqus Comments -->
        <!-- <div id="disqus_thread"></div> -->
        <!-- <script type="text/javascript"> -->
        <!--     var disqus_shortname = 'chrispenner'; -->
        <!--     var disqus_identifier = ''; -->
        <!--     var disqus_url = 'http://chrispenner.ca'; -->

        <!-- (function() { -->
        <!-- var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true; -->
        <!-- dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js'; -->
        <!-- (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq); -->
        <!-- })(); -->
        <!-- </script> -->
      </article></div>
  </body>
</html>
