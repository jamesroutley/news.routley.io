<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.iankduncan.com/engineering/2025-11-24-json-schema-demystified/">Original</a>
    <h1>JSON Schema Demystified: Dialects, Vocabularies and Metaschemas</h1>
    
    <div id="readability-page-1" class="page"><div>   <p>If you’ve ever tried to dive into JSON Schema, you’ve probably encountered a wall of terminology that makes your head spin: schemas, metaschemas, dialects, vocabularies, keywords, anchors, dynamic references. It feels like the community invented new words for things that already had perfectly good names, just to make the rest of us feel inadequate.</p>
<p>I’ve been working on a Haskell JSON Schema library that’s actually fully spec-compliant, which meant I had to figure all of this out. The problem isn’t that the concepts are inherently difficult. The terminology creates artificial barriers to understanding.</p>
<p>This post will break down the key concepts in JSON Schema in a way that actually makes sense, connecting the dots between all these terms that seem designed to confuse. By the end, you’ll understand not just what these words mean, but how they fit together into a coherent system.</p>
<h2 id="starting-simple">Starting simple</h2>
<p>Before we dive into terminology, let’s look at what we’re actually trying to accomplish. JSON Schema is fundamentally about describing the shape and constraints of JSON data. Here’s a simple example:</p>
<pre tabindex="0" data-language="json"><code><span><span>{</span></span>
<span><span>  &#34;type&#34;</span><span>:</span><span> &#34;object&#34;</span><span>,</span></span>
<span><span>  &#34;properties&#34;</span><span>:</span><span> {</span></span>
<span><span>    &#34;name&#34;</span><span>:</span><span> { </span><span>&#34;type&#34;</span><span>:</span><span> &#34;string&#34;</span><span> }</span><span>,</span></span>
<span><span>    &#34;age&#34;</span><span>:</span><span> { </span><span>&#34;type&#34;</span><span>:</span><span> &#34;number&#34;</span><span>,</span><span> &#34;minimum&#34;</span><span>:</span><span> 0</span><span> }</span></span>
<span><span>  }</span><span>,</span></span>
<span><span>  &#34;required&#34;</span><span>:</span><span> [</span><span>&#34;name&#34;</span><span>]</span></span>
<span><span>}</span></span></code></pre>
<p>This schema says: “I expect a JSON object with a string <code>name</code> field (required) and an optional numeric <code>age</code> field that must be non-negative.” Simple enough, right?</p>
<p>Now here’s where it gets interesting: this schema is itself valid JSON. And since JSON can describe the structure of JSON documents, we can describe the structure of schemas using more schemas. This recursive property is what gives rise to metaschemas, and where the terminology starts to get confusing.</p>
<h2 id="whats-a-schema-anyway">What’s a schema anyway?</h2>
<p>A schema is just a JSON document that describes constraints on other JSON documents. That’s it. The example above is a schema.</p>
<p>Schemas tell you what type a value should be (string, number, object, array), what values are allowed or disallowed, what properties must or may exist on an object, how many items should be in an array. When you write a schema, you’re essentially writing rules that say “valid JSON documents that I care about look like this.”</p>
<pre tabindex="0" data-language="json"><code><span><span>{</span></span>
<span><span>  &#34;type&#34;</span><span>:</span><span> &#34;string&#34;</span><span>,</span></span>
<span><span>  &#34;minLength&#34;</span><span>:</span><span> 1</span><span>,</span></span>
<span><span>  &#34;maxLength&#34;</span><span>:</span><span> 100</span></span>
<span><span>}</span></span></code></pre>
<p>This schema says: “I want a string between 1 and 100 characters long.” Any JSON validator that understands JSON Schema can take this schema and your data and tell you whether your data follows the rules.</p>
<p>The confusing part is that schemas themselves are JSON documents. So naturally, you might ask: “What describes the structure of a schema?” And that leads us to the next layer.</p>

<p>A metaschema is a schema that describes the structure of other schemas. The “schema of schemas,” if you will.</p>
<p>This sounds abstract and philosophical, but it’s actually quite practical. Remember how our simple schema used keywords like <code>&#34;type&#34;</code>, <code>&#34;properties&#34;</code>, and <code>&#34;minimum&#34;</code>? The metaschema defines what those keywords mean, what values they can have, and how they work together.</p>
<p>Here’s a tiny excerpt of what a metaschema might look like:</p>
<pre tabindex="0" data-language="json"><code><span><span>{</span></span>
<span><span>  &#34;$id&#34;</span><span>:</span><span> &#34;https://json-schema.org/draft/2020-12/schema&#34;</span><span>,</span></span>
<span><span>  &#34;type&#34;</span><span>:</span><span> [</span><span>&#34;object&#34;</span><span>,</span><span> &#34;boolean&#34;</span><span>]</span><span>,</span></span>
<span><span>  &#34;properties&#34;</span><span>:</span><span> {</span></span>
<span><span>    &#34;type&#34;</span><span>:</span><span> {</span></span>
<span><span>      &#34;anyOf&#34;</span><span>:</span><span> [</span></span>
<span><span>        { </span><span>&#34;enum&#34;</span><span>:</span><span> [</span><span>&#34;null&#34;</span><span>,</span><span> &#34;boolean&#34;</span><span>,</span><span> &#34;object&#34;</span><span>,</span><span> &#34;array&#34;</span><span>,</span><span> &#34;number&#34;</span><span>,</span><span> &#34;string&#34;</span><span>] }</span><span>,</span></span>
<span><span>        { </span><span>&#34;type&#34;</span><span>:</span><span> &#34;array&#34;</span><span>,</span><span> &#34;items&#34;</span><span>:</span><span> { </span><span>&#34;$ref&#34;</span><span>:</span><span> &#34;#/properties/type/anyOf/0&#34;</span><span> } }</span></span>
<span><span>      ]</span></span>
<span><span>    }</span><span>,</span></span>
<span><span>    &#34;properties&#34;</span><span>:</span><span> {</span></span>
<span><span>      &#34;type&#34;</span><span>:</span><span> &#34;object&#34;</span><span>,</span></span>
<span><span>      &#34;additionalProperties&#34;</span><span>:</span><span> { </span><span>&#34;$dynamicRef&#34;</span><span>:</span><span> &#34;#meta&#34;</span><span> }</span></span>
<span><span>    }</span></span>
<span><span>  }</span></span>
<span><span>}</span></span></code></pre>
<p>This fragment says things like: “The <code>type</code> keyword can be a single type string or an array of type strings” and “The <code>properties</code> keyword should be an object where each value is itself a schema.”</p>
<p>Why does this matter? Well, you can validate that your schema is well-formed by checking it against the metaschema. If someone writes <code>&#34;type&#34;: &#34;stirng&#34;</code> (typo!), the metaschema validation will catch it. The metaschema is also the formal specification of what’s allowed in schemas. Tools that process schemas (validators, code generators, documentation generators) use the metaschema to understand what they’re working with.</p>
<p>The relationship is simple: schemas validate data, metaschemas validate schemas.</p>
<pre tabindex="0" data-language="plaintext"><code><span><span>Data → validated by → Schema → validated by → Metaschema</span></span></code></pre>
<p>Here’s where it gets recursive: since a metaschema is also a schema (JSON describing JSON structure), it can validate itself. The JSON Schema metaschema is designed to be self-describing. This is similar to how a compiler written in its own language can compile itself (bootstrapping). <img src="https://www.iankduncan.com/_astro/doge.DoAm8LyA_M59LV.webp" alt="Such meta. Very recursive." loading="lazy" decoding="async" fetchpriority="auto" width="24" height="24"/></p>
<h2 id="dialects-when-versions-matter">Dialects: when versions matter</h2>
<p>So we have schemas and metaschemas. But JSON Schema has evolved over time. Different versions have added new keywords, changed behavior, and deprecated old features. How do we keep track of which version of JSON Schema we’re using?</p>
<p>A dialect is a specific version or flavor of JSON Schema, defined by a particular metaschema. When someone says they’re using “Draft 2020-12” or “Draft 7,” they’re referring to specific dialects.</p>
<p>Each dialect has its own metaschema that defines which keywords are available, its own set of behaviors and validation rules, and is identified by a URI (usually something like <code>https://json-schema.org/draft/2020-12/schema</code>).</p>
<p>You declare which dialect your schema uses with the <code>$schema</code> keyword:</p>
<pre tabindex="0" data-language="json"><code><span><span>{</span></span>
<span><span>  &#34;$schema&#34;</span><span>:</span><span> &#34;https://json-schema.org/draft/2020-12/schema&#34;</span><span>,</span></span>
<span><span>  &#34;type&#34;</span><span>:</span><span> &#34;object&#34;</span><span>,</span></span>
<span><span>  &#34;properties&#34;</span><span>:</span><span> {</span></span>
<span><span>    &#34;name&#34;</span><span>:</span><span> { </span><span>&#34;type&#34;</span><span>:</span><span> &#34;string&#34;</span><span> }</span></span>
<span><span>  }</span></span>
<span><span>}</span></span></code></pre>
<p>This tells validators: “Hey, interpret this schema according to the Draft 2020-12 rules.”</p>
<p>Different dialects can have different keywords and different behaviors. Draft 4 didn’t have the <code>const</code> keyword, but Draft 6 added it. The <code>$id</code> keyword worked differently in Draft 4 versus Draft 7. Draft 2019-09 introduced the concept of vocabularies (we’ll get to that).</p>
<p>If you write a schema using Draft 2020-12 features and someone tries to validate it with a Draft 4 validator, things won’t work correctly. The <code>$schema</code> keyword ensures everyone is on the same page.</p>
<p>Think of dialects like programming language versions. Python 2 and Python 3 are different dialects of Python. Your code needs to declare which one it’s written for, or chaos ensues.</p>
<h2 id="vocabularies-the-modular-twist">Vocabularies: the modular twist</h2>
<p>Here’s where JSON Schema gets really interesting (and where my initial confusion peaked). Starting with Draft 2019-09, JSON Schema introduced the concept of vocabularies.</p>
<p>A vocabulary is a named collection of keywords that work together to provide a specific kind of functionality. Instead of having one monolithic metaschema that defines all possible keywords, you can compose metaschemas from smaller, focused vocabularies.</p>
<p>Think of vocabularies as modules or packages. Each vocabulary provides a set of related keywords. The core vocabulary has fundamental keywords like <code>$id</code>, <code>$schema</code>, <code>$ref</code>, and <code>$defs</code>. The applicator vocabulary has keywords that apply schemas to different parts of the data like <code>properties</code>, <code>items</code>, and <code>additionalProperties</code>. The validation vocabulary has keywords for constraints like <code>minimum</code>, <code>maxLength</code>, <code>pattern</code>, and <code>enum</code>. The metadata vocabulary has keywords for human-readable information like <code>title</code>, <code>description</code>, and <code>examples</code>.</p>
<p>Here’s a schema using keywords from different vocabularies:</p>
<pre tabindex="0" data-language="json"><code><span><span>{</span></span>
<span><span>  &#34;$id&#34;</span><span>:</span><span> &#34;https://example.com/my-schema&#34;</span><span>,</span></span>
<span><span>  &#34;title&#34;</span><span>:</span><span> &#34;User Name&#34;</span><span>,</span></span>
<span><span>  &#34;description&#34;</span><span>:</span><span> &#34;The user&#39;s full name&#34;</span><span>,</span></span>
<span><span>  &#34;type&#34;</span><span>:</span><span> &#34;string&#34;</span><span>,</span></span>
<span><span>  &#34;minLength&#34;</span><span>:</span><span> 5</span><span>,</span></span>
<span><span>  &#34;pattern&#34;</span><span>:</span><span> &#34;^[A-Z]&#34;</span></span>
<span><span>}</span></span></code></pre>
<p>The <code>$id</code> comes from the core vocabulary, <code>title</code> and <code>description</code> from the metadata vocabulary, <code>type</code> from the applicator vocabulary, and <code>minLength</code> and <code>pattern</code> from the validation vocabulary.</p>
<p>Why vocabularies? They enable modularity and extensibility. You can pick and choose which vocabularies your dialect supports. Maybe you want validation but not format checking? Just include the vocabularies you need. You can define your own vocabulary with custom keywords specific to your domain. For example, a database schema dialect might add keywords like <code>indexed</code> or <code>foreignKey</code>. Each vocabulary is independently specified, making it easier to understand and implement different parts of JSON Schema.</p>
<p>Here’s how a metaschema declares which vocabularies it uses:</p>
<pre tabindex="0" data-language="json"><code><span><span>{</span></span>
<span><span>  &#34;$schema&#34;</span><span>:</span><span> &#34;https://json-schema.org/draft/2020-12/schema&#34;</span><span>,</span></span>
<span><span>  &#34;$vocabulary&#34;</span><span>:</span><span> {</span></span>
<span><span>    &#34;https://json-schema.org/draft/2020-12/vocab/core&#34;</span><span>:</span><span> true</span><span>,</span></span>
<span><span>    &#34;https://json-schema.org/draft/2020-12/vocab/applicator&#34;</span><span>:</span><span> true</span><span>,</span></span>
<span><span>    &#34;https://json-schema.org/draft/2020-12/vocab/validation&#34;</span><span>:</span><span> true</span><span>,</span></span>
<span><span>    &#34;https://json-schema.org/draft/2020-12/vocab/meta-data&#34;</span><span>:</span><span> false</span></span>
<span><span>  }</span></span>
<span><span>}</span></span></code></pre>
<p>The <code>true</code> versus <code>false</code> values indicate whether the vocabulary is required or optional. If a validator doesn’t understand a required vocabulary, it should refuse to process the schema. If it doesn’t understand an optional vocabulary, it can safely ignore those keywords.</p>
<h2 id="extending-with-your-own-keywords">Extending with your own keywords</h2>
<p>Here’s where this all gets practical. Once you understand vocabularies, you realize you can extend JSON Schema with your own domain-specific keywords. This is incredibly powerful.</p>
<p>In fact, you’ve probably already used extended JSON Schema without realizing it. OpenAPI (the spec for describing REST APIs) is exactly this: JSON Schema extended with custom keywords for HTTP-specific concerns like <code>operationId</code>, <code>responses</code>, <code>parameters</code>, and so on. OpenAPI is JSON Schema plus a vocabulary for APIs. And you could extend OpenAPI further with your own vocabulary for framework-specific behaviors or company-specific conventions.</p>
<p>Say you’re building an API framework and you want to annotate your schemas with HTTP-specific metadata. Standard JSON Schema doesn’t have keywords for things like “this field comes from a query parameter” or “this response uses status code 201.” So you create your own vocabulary.</p>
<p>First, you define your custom keywords in a vocabulary document:</p>
<pre tabindex="0" data-language="json"><code><span><span>{</span></span>
<span><span>  &#34;$id&#34;</span><span>:</span><span> &#34;https://api.example.com/vocab/http&#34;</span><span>,</span></span>
<span><span>  &#34;$schema&#34;</span><span>:</span><span> &#34;https://json-schema.org/draft/2020-12/schema&#34;</span><span>,</span></span>
<span><span>  &#34;$vocabulary&#34;</span><span>:</span><span> {</span></span>
<span><span>    &#34;https://json-schema.org/draft/2020-12/vocab/core&#34;</span><span>:</span><span> true</span></span>
<span><span>  }</span><span>,</span></span>
<span><span>  &#34;type&#34;</span><span>:</span><span> &#34;object&#34;</span><span>,</span></span>
<span><span>  &#34;properties&#34;</span><span>:</span><span> {</span></span>
<span><span>    &#34;httpSource&#34;</span><span>:</span><span> {</span></span>
<span><span>      &#34;enum&#34;</span><span>:</span><span> [</span><span>&#34;query&#34;</span><span>,</span><span> &#34;path&#34;</span><span>,</span><span> &#34;header&#34;</span><span>,</span><span> &#34;body&#34;</span><span>]</span></span>
<span><span>    }</span><span>,</span></span>
<span><span>    &#34;httpStatus&#34;</span><span>:</span><span> {</span></span>
<span><span>      &#34;type&#34;</span><span>:</span><span> &#34;integer&#34;</span><span>,</span></span>
<span><span>      &#34;minimum&#34;</span><span>:</span><span> 100</span><span>,</span></span>
<span><span>      &#34;maximum&#34;</span><span>:</span><span> 599</span></span>
<span><span>    }</span></span>
<span><span>  }</span></span>
<span><span>}</span></span></code></pre>
<p>This vocabulary document describes the structure of your custom keywords. Now you can use them in your schemas:</p>
<pre tabindex="0" data-language="json"><code><span><span>{</span></span>
<span><span>  &#34;$schema&#34;</span><span>:</span><span> &#34;https://api.example.com/schema&#34;</span><span>,</span></span>
<span><span>  &#34;$vocabulary&#34;</span><span>:</span><span> {</span></span>
<span><span>    &#34;https://json-schema.org/draft/2020-12/vocab/core&#34;</span><span>:</span><span> true</span><span>,</span></span>
<span><span>    &#34;https://json-schema.org/draft/2020-12/vocab/validation&#34;</span><span>:</span><span> true</span><span>,</span></span>
<span><span>    &#34;https://api.example.com/vocab/http&#34;</span><span>:</span><span> true</span></span>
<span><span>  }</span><span>,</span></span>
<span><span>  &#34;type&#34;</span><span>:</span><span> &#34;object&#34;</span><span>,</span></span>
<span><span>  &#34;properties&#34;</span><span>:</span><span> {</span></span>
<span><span>    &#34;userId&#34;</span><span>:</span><span> {</span></span>
<span><span>      &#34;type&#34;</span><span>:</span><span> &#34;string&#34;</span><span>,</span></span>
<span><span>      &#34;httpSource&#34;</span><span>:</span><span> &#34;path&#34;</span><span>,</span></span>
<span><span>      &#34;pattern&#34;</span><span>:</span><span> &#34;^[0-9]+$&#34;</span></span>
<span><span>    }</span><span>,</span></span>
<span><span>    &#34;filter&#34;</span><span>:</span><span> {</span></span>
<span><span>      &#34;type&#34;</span><span>:</span><span> &#34;string&#34;</span><span>,</span></span>
<span><span>      &#34;httpSource&#34;</span><span>:</span><span> &#34;query&#34;</span></span>
<span><span>    }</span></span>
<span><span>  }</span></span>
<span><span>}</span></span></code></pre>
<p>Your validator needs to understand what to do with <code>httpSource</code>, of course. When it encounters a schema using your custom vocabulary, it checks whether it supports that vocabulary. If the vocabulary is marked as required and the validator doesn’t support it, validation should fail with an error saying “I don’t understand this vocabulary.” If it’s optional, the validator can safely ignore those keywords.</p>
<p>The beauty of this approach is that your extensions are explicit and discoverable. Someone reading your schema can see exactly which vocabularies it uses. A validator can definitively say whether it supports your schema or not. You’re not just stuffing random properties into schemas and hoping validators ignore them.</p>
<p>You can extend validation rules too. Maybe you’re working with database schemas and want to validate that certain string fields match database identifier conventions. You could define a custom keyword like <code>dbIdentifier</code>:</p>
<pre tabindex="0" data-language="json"><code><span><span>{</span></span>
<span><span>  &#34;type&#34;</span><span>:</span><span> &#34;string&#34;</span><span>,</span></span>
<span><span>  &#34;dbIdentifier&#34;</span><span>:</span><span> true</span><span>,</span></span>
<span><span>  &#34;description&#34;</span><span>:</span><span> &#34;Must be a valid PostgreSQL identifier&#34;</span></span>
<span><span>}</span></span></code></pre>
<p>Your validator would implement the logic to check PostgreSQL identifier rules (no leading numbers, only certain special characters, length limits, etc.). Standard JSON Schema validators would ignore this keyword if you mark the vocabulary as optional, or refuse to process the schema if you mark it as required.</p>
<p>This extensibility is why JSON Schema has all this vocabulary machinery. It’s not just academic complexity for its own sake. The vocabulary system lets you build domain-specific validation languages on top of JSON Schema’s foundation, while maintaining clear boundaries about what’s standard and what’s custom.</p>
<h2 id="putting-it-all-together">Putting it all together</h2>
<p>Let’s connect all the dots. You write a schema that describes your data structure (like a User object). The schema uses keywords like <code>type</code>, <code>properties</code>, and <code>minimum</code> to express constraints. These keywords are defined by vocabularies (the validation vocabulary, applicator vocabulary). The vocabularies are bundled into a dialect (like Draft 2020-12). The dialect is defined by a metaschema that describes which keywords are available and how they work. Your schema declares its dialect using the <code>$schema</code> keyword.</p>
<p>Here’s a visual:</p>
<pre tabindex="0" data-language="plaintext"><code><span><span>Your Data (JSON)</span></span>
<span><span>    ↓ validated by</span></span>
<span><span>Your Schema (JSON)</span></span>
<span><span>    ↓ uses keywords from</span></span>
<span><span>Vocabularies (sets of related keywords)</span></span>
<span><span>    ↓ bundled into</span></span>
<span><span>Dialect (specific version/flavor)</span></span>
<span><span>    ↓ defined by</span></span>
<span><span>Metaschema (schema of schemas)</span></span></code></pre>
<p>A concrete example showing all the layers:</p>
<pre tabindex="0" data-language="json"><code><span><span>{</span></span>
<span><span>  &#34;$schema&#34;</span><span>:</span><span> &#34;https://json-schema.org/draft/2020-12/schema&#34;</span><span>,</span></span>
<span><span>  &#34;$id&#34;</span><span>:</span><span> &#34;https://example.com/schemas/user&#34;</span><span>,</span></span>
<span></span>
<span><span>  &#34;title&#34;</span><span>:</span><span> &#34;User&#34;</span><span>,</span></span>
<span><span>  &#34;description&#34;</span><span>:</span><span> &#34;A registered user in the system&#34;</span><span>,</span></span>
<span></span>
<span><span>  &#34;type&#34;</span><span>:</span><span> &#34;object&#34;</span><span>,</span></span>
<span><span>  &#34;properties&#34;</span><span>:</span><span> {</span></span>
<span><span>    &#34;username&#34;</span><span>:</span><span> {</span></span>
<span><span>      &#34;type&#34;</span><span>:</span><span> &#34;string&#34;</span><span>,</span></span>
<span><span>      &#34;pattern&#34;</span><span>:</span><span> &#34;^[a-zA-Z0-9_]+$&#34;</span><span>,</span></span>
<span><span>      &#34;minLength&#34;</span><span>:</span><span> 3</span><span>,</span></span>
<span><span>      &#34;maxLength&#34;</span><span>:</span><span> 20</span></span>
<span><span>    }</span><span>,</span></span>
<span><span>    &#34;email&#34;</span><span>:</span><span> {</span></span>
<span><span>      &#34;type&#34;</span><span>:</span><span> &#34;string&#34;</span><span>,</span></span>
<span><span>      &#34;format&#34;</span><span>:</span><span> &#34;email&#34;</span></span>
<span><span>    }</span><span>,</span></span>
<span><span>    &#34;age&#34;</span><span>:</span><span> {</span></span>
<span><span>      &#34;type&#34;</span><span>:</span><span> &#34;integer&#34;</span><span>,</span></span>
<span><span>      &#34;minimum&#34;</span><span>:</span><span> 13</span><span>,</span></span>
<span><span>      &#34;maximum&#34;</span><span>:</span><span> 120</span></span>
<span><span>    }</span></span>
<span><span>  }</span><span>,</span></span>
<span><span>  &#34;required&#34;</span><span>:</span><span> [</span><span>&#34;username&#34;</span><span>,</span><span> &#34;email&#34;</span><span>]</span></span>
<span><span>}</span></span></code></pre>
<p>Breaking this down: <code>$schema</code> declares we’re using the Draft 2020-12 dialect. <code>$id</code> is a core vocabulary keyword that uniquely identifies this schema. <code>title</code> and <code>description</code> are metadata vocabulary keywords for documentation. <code>type</code>, <code>properties</code>, and <code>required</code> are applicator vocabulary keywords that apply constraints. <code>pattern</code>, <code>minLength</code>, <code>minimum</code>, and <code>format</code> are validation vocabulary keywords that enforce rules.</p>
<p>All of these keywords are defined in the Draft 2020-12 metaschema, which specifies their meaning and behavior.</p>
<h2 id="other-terms-youll-encounter">Other terms you’ll encounter</h2>
<p>While we’ve covered the big four (schema, metaschema, dialect, vocabulary), there are a few other terms worth understanding.</p>
<p>A keyword is a specific property name with defined semantics in a schema. Examples: <code>type</code>, <code>properties</code>, <code>minimum</code>, <code>$ref</code>. Keywords are the building blocks defined by vocabularies. Some keywords are universal (<code>type</code>, <code>properties</code>), while others are specific to certain vocabularies (<code>contentMediaType</code> from the content vocabulary, <code>deprecated</code> from the metadata vocabulary).</p>
<p>There’s also a distinction between annotations and assertions. Assertions are keywords that can make validation fail (like <code>type</code>, <code>minimum</code>, <code>required</code>, <code>pattern</code>). If your data violates an assertion, validation fails. Annotations are keywords that just provide information and never cause validation to fail (like <code>title</code>, <code>description</code>, <code>examples</code>, <code>default</code>). Annotations are useful for documentation and tooling but don’t affect validity. Some keywords can produce both annotations and assertions. For instance, <code>properties</code> asserts the types of the properties while also annotating which properties were validated.</p>
<p>Anchors provide named locations within a schema that you can reference. They’re like bookmarks:</p>
<pre tabindex="0" data-language="json"><code><span><span>{</span></span>
<span><span>  &#34;$defs&#34;</span><span>:</span><span> {</span></span>
<span><span>    &#34;address&#34;</span><span>:</span><span> {</span></span>
<span><span>      &#34;$anchor&#34;</span><span>:</span><span> &#34;addr&#34;</span><span>,</span></span>
<span><span>      &#34;type&#34;</span><span>:</span><span> &#34;object&#34;</span><span>,</span></span>
<span><span>      &#34;properties&#34;</span><span>:</span><span> {</span></span>
<span><span>        &#34;street&#34;</span><span>:</span><span> { </span><span>&#34;type&#34;</span><span>:</span><span> &#34;string&#34;</span><span> }</span></span>
<span><span>      }</span></span>
<span><span>    }</span></span>
<span><span>  }</span><span>,</span></span>
<span><span>  &#34;properties&#34;</span><span>:</span><span> {</span></span>
<span><span>    &#34;billingAddress&#34;</span><span>:</span><span> { </span><span>&#34;$ref&#34;</span><span>:</span><span> &#34;#addr&#34;</span><span> }</span><span>,</span></span>
<span><span>    &#34;shippingAddress&#34;</span><span>:</span><span> { </span><span>&#34;$ref&#34;</span><span>:</span><span> &#34;#addr&#34;</span><span> }</span></span>
<span><span>  }</span></span>
<span><span>}</span></span></code></pre>
<p>Dynamic anchors (<code>$dynamicAnchor</code> and <code>$dynamicRef</code>) are more advanced. They allow references to be resolved differently depending on the “context” of evaluation. This is mostly useful for extending metaschemas and creating recursive schemas that can be overridden. Honestly, you can probably ignore dynamic anchors until you’re doing very advanced schema composition.</p>
<p>A bundled schema is a single schema document that contains multiple schema resources, usually via <code>$defs</code>. This is handy for distributing related schemas together:</p>
<pre tabindex="0" data-language="json"><code><span><span>{</span></span>
<span><span>  &#34;$id&#34;</span><span>:</span><span> &#34;https://example.com/schemas/bundle&#34;</span><span>,</span></span>
<span><span>  &#34;$defs&#34;</span><span>:</span><span> {</span></span>
<span><span>    &#34;user&#34;</span><span>:</span><span> {</span></span>
<span><span>      &#34;$id&#34;</span><span>:</span><span> &#34;user&#34;</span><span>,</span></span>
<span><span>      &#34;type&#34;</span><span>:</span><span> &#34;object&#34;</span><span>,</span></span>
<span><span>      &#34;properties&#34;</span><span>:</span><span> { </span><span>&#34;name&#34;</span><span>:</span><span> { </span><span>&#34;type&#34;</span><span>:</span><span> &#34;string&#34;</span><span> } }</span></span>
<span><span>    }</span><span>,</span></span>
<span><span>    &#34;product&#34;</span><span>:</span><span> {</span></span>
<span><span>      &#34;$id&#34;</span><span>:</span><span> &#34;product&#34;</span><span>,</span></span>
<span><span>      &#34;type&#34;</span><span>:</span><span> &#34;object&#34;</span><span>,</span></span>
<span><span>      &#34;properties&#34;</span><span>:</span><span> { </span><span>&#34;title&#34;</span><span>:</span><span> { </span><span>&#34;type&#34;</span><span>:</span><span> &#34;string&#34;</span><span> } }</span></span>
<span><span>    }</span></span>
<span><span>  }</span></span>
<span><span>}</span></span></code></pre>
<p>Now you can reference <code>https://example.com/schemas/user</code> and <code>https://example.com/schemas/product</code> from other schemas, even though they’re defined in the same document.</p>
<h2 id="why-is-the-terminology-so-confusing">Why is the terminology so confusing?</h2>
<p>You might be wondering: why did they make this so complicated? The answer is that JSON Schema has evolved significantly over more than a decade, and the terminology evolved with it.</p>
<p>Early versions (Draft 3, Draft 4) had simpler, more monolithic metaschemas. As the specification matured, the community recognized the need for modularity, extensibility, and clearer versioning. That’s when concepts like dialects and vocabularies were formalized.</p>
<p>The terminology can feel academic because it comes from formal specification work. These are precise technical terms designed for specification writers and implementers, not necessarily for end users. Unfortunately, they leaked into the documentation that everyone reads, creating a steep learning curve.</p>
<p>But here’s the thing: you don’t need to think about most of this complexity to use JSON Schema effectively.</p>
<h2 id="what-do-you-actually-need-to-know">What do you actually need to know?</h2>
<p>For 95% of JSON Schema usage, you need to understand that schemas describe data structure and constraints, <code>$schema</code> declares which version (dialect) you’re using, and keywords like <code>type</code>, <code>properties</code>, and <code>minimum</code> define your rules.</p>
<p>That’s it. You can write perfectly good schemas for years without ever thinking about metaschemas or vocabularies in depth.</p>
<p>The deeper concepts matter when you’re building tools that process schemas (validators, code generators), extending JSON Schema with custom keywords, working on the specification itself, or debugging complex reference resolution issues. For everyone else, just know that these concepts exist and form a coherent system. If you encounter them in documentation, you’ll know what they mean, but you probably won’t need to think about them day-to-day.</p>
<h2 id="some-practical-advice">Some practical advice</h2>
<p>Always specify <code>$schema</code> to make it explicit which dialect you’re using:</p>
<pre tabindex="0" data-language="json"><code><span><span>{</span></span>
<span><span>  &#34;$schema&#34;</span><span>:</span><span> &#34;https://json-schema.org/draft/2020-12/schema&#34;</span><span>,</span></span>
<span><span>  &#34;type&#34;</span><span>:</span><span> &#34;object&#34;</span></span>
<span><span>}</span></span></code></pre>
<p>This ensures validators interpret your schema correctly.</p>
<p>Start with the latest stable dialect. As of this writing, that’s Draft 2020-12. It has the most features and best tooling support. Don’t worry about older drafts unless you’re maintaining legacy schemas.</p>
<p>Use clear, descriptive metadata. Even though <code>title</code>, <code>description</code>, and <code>examples</code> don’t affect validation, they make your schemas much more useful:</p>
<pre tabindex="0" data-language="json"><code><span><span>{</span></span>
<span><span>  &#34;type&#34;</span><span>:</span><span> &#34;object&#34;</span><span>,</span></span>
<span><span>  &#34;title&#34;</span><span>:</span><span> &#34;User Account&#34;</span><span>,</span></span>
<span><span>  &#34;description&#34;</span><span>:</span><span> &#34;Represents a user account in the system&#34;</span><span>,</span></span>
<span><span>  &#34;properties&#34;</span><span>:</span><span> {</span></span>
<span><span>    &#34;username&#34;</span><span>:</span><span> {</span></span>
<span><span>      &#34;type&#34;</span><span>:</span><span> &#34;string&#34;</span><span>,</span></span>
<span><span>      &#34;description&#34;</span><span>:</span><span> &#34;Unique username for login (alphanumeric and underscores only)&#34;</span><span>,</span></span>
<span><span>      &#34;examples&#34;</span><span>:</span><span> [</span><span>&#34;john_doe&#34;</span><span>,</span><span> &#34;alice123&#34;</span><span>]</span></span>
<span><span>    }</span></span>
<span><span>  }</span></span>
<span><span>}</span></span></code></pre>
<p>For complex schemas, use <code>$defs</code> to break things into reusable pieces:</p>
<pre tabindex="0" data-language="json"><code><span><span>{</span></span>
<span><span>  &#34;$defs&#34;</span><span>:</span><span> {</span></span>
<span><span>    &#34;timestamp&#34;</span><span>:</span><span> {</span></span>
<span><span>      &#34;type&#34;</span><span>:</span><span> &#34;string&#34;</span><span>,</span></span>
<span><span>      &#34;format&#34;</span><span>:</span><span> &#34;date-time&#34;</span></span>
<span><span>    }</span><span>,</span></span>
<span><span>    &#34;identifier&#34;</span><span>:</span><span> {</span></span>
<span><span>      &#34;type&#34;</span><span>:</span><span> &#34;string&#34;</span><span>,</span></span>
<span><span>      &#34;pattern&#34;</span><span>:</span><span> &#34;^[a-z0-9-]+$&#34;</span></span>
<span><span>    }</span></span>
<span><span>  }</span><span>,</span></span>
<span><span>  &#34;type&#34;</span><span>:</span><span> &#34;object&#34;</span><span>,</span></span>
<span><span>  &#34;properties&#34;</span><span>:</span><span> {</span></span>
<span><span>    &#34;id&#34;</span><span>:</span><span> { </span><span>&#34;$ref&#34;</span><span>:</span><span> &#34;#/$defs/identifier&#34;</span><span> }</span><span>,</span></span>
<span><span>    &#34;createdAt&#34;</span><span>:</span><span> { </span><span>&#34;$ref&#34;</span><span>:</span><span> &#34;#/$defs/timestamp&#34;</span><span> }</span></span>
<span><span>  }</span></span>
<span><span>}</span></span></code></pre>
<p>If you’re ever confused about whether a keyword exists or how it works, check the metaschema. The Draft 2020-12 metaschema lives at: <a href="https://json-schema.org/draft/2020-12/schema">https://json-schema.org/draft/2020-12/schema</a></p>
<p>Test your schemas with online validators or schema testing tools to ensure they work as expected. The official JSON Schema website has a validator you can try: <a href="https://www.jsonschemavalidator.net/">https://www.jsonschemavalidator.net/</a></p>
<h2 id="wrapping-up">Wrapping up</h2>
<p>JSON Schema’s terminology can feel intimidating, but the core ideas are straightforward. Schemas describe data. Metaschemas describe schemas. Dialects are specific versions of JSON Schema. Vocabularies are modular collections of keywords. Keywords are the actual properties you use in schemas.</p>
<p>The terminology exists to support a powerful, extensible system for describing JSON data structures. But for everyday use, you can mostly ignore the academic terminology and focus on writing clear, useful schemas.</p>
<p>The next time you see “metaschema” or “vocabulary” in JSON Schema documentation, don’t panic. You know what these terms mean now, and more importantly, you understand how they fit together. That’s the real goal: building a mental model of how the system works, not memorizing definitions.</p>
<p>Now go forth and write some schemas. And remember: if you find yourself confused by JSON Schema terminology again, you’re not alone. The important thing is that underneath the jargon, there’s a well-designed system for a genuinely useful purpose.</p>   </div></div>
  </body>
</html>
