<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jpmens.net/2024/02/23/totp-codes-in-the-terminal/">Original</a>
    <h1>TOTP Codes in the Terminal</h1>
    
    <div id="readability-page-1" class="page"><div id="content">  
	    <div id="searchres">
		<div postid="4307">
		    
		    <p>The <a href="https://jpmens.net/2024/02/17/notes-to-self-authy-desktop-is-dead/">demise of Authy desktop</a> has brought about a number of changes, probably the one of which I most appreciate is a mobile app which lets me edit codes: with <a href="https://2fas.com">2FAS</a> I can edit labels on codes, and I’ve finally been able to associate a code which I couldn’t identify (it had neither brand logo nor description other than an email address) to the platform it’s for. A cleanup was due and is welcome, and a migration to <a href="https://2fas.com">2FAS</a> was easy with export/import after I <a href="https://github.com/token2/authy-migration/pull/6">patched authy-migration</a> to produce JSON.</p>

<p><img src="https://jpmens.net/media/2024a/IMG_7155.PNG" alt="2fas totp code"/></p>

<p>However, Authy killing off its desktop offering also means when at the desktop I have to use a mobile device and type the 6 digits into a Web form. Not a huge problem, but copy/paste was comfortable. While both Open Source TOTP apps I studied more closely, <a href="https://2fas.com">2FAS</a> and <a href="https://raivo-otp.com">Raivo OTP</a>, have a desktop app which interacts in some way with the mobile, they didn’t convince me. I’m sure other people are happy with how they work.</p>

<p>I think I’ve found a solution for myself to the desktop problem.</p>

<p>I always have a terminal open, so copy paste from a program I launch there into a Web browser field is simple.</p>

<div><div><pre><code><span>$</span><span> </span>otp ali
<span>872348 13 Alibaba JP
</span></code></pre></div></div>

<p>For lack of imagination the jumble of utilities is called <em>otp</em> and it expects a <em>regular expression</em> to search for in 2FAS’ <em>name</em> and <em>account</em> fields. Easy. The output is the TOTP code, the remaining time (TTL) for the code, followed by <em>name</em> and <em>account</em>, and a double-click on the 6 digits followed by a CMD-V in the Web browser field completes a login procedure.</p>

<p>I create a <a href="https://2fas.com">2FAS</a> backup which contains <a href="https://gist.github.com/jpmens/47a080d0a7e423255f2eb100fcf07223">JSON of all the codes</a>, transfer that to Unix/Linux and simplify it using <a href="https://github.com/tomnomnom/gron">gron</a>. (I later simplify this by <a href="https://gist.github.com/jpmens/973a987f47257ef496bce17e90efbf44">reading the encrypted backup and directly producing the JSON</a> I want.)</p>

<div><div><pre><code><span>$</span><span> </span>gron Backup_2024-02-22.2fas |
<span>        egrep &#39;\.(name|otp.account|secret)&#39; |
        sed -e &#39;s/otp\.//&#39; |
        gron -u
{
  &#34;services&#34;: [
    {
      &#34;account&#34;: &#34;JP&#34;,
      &#34;name&#34;: &#34;Aliaba&#34;,
      &#34;secret&#34;: &#34;MFRHEYLDMFSGCYTSMEYDAMBR&#34;
    },
</span><span>    ...
</span></code></pre></div></div>

<p>I then store this blob in a <a href="https://github.com/getsops/sops">SOPS</a> store using one or more <a href="https://github.com/FiloSottile/age">age</a> identities (private keys). This combination suits me well: I very much appreciate the ease and simplicity of <a href="https://github.com/FiloSottile/age">age</a>, and having interacted with <a href="https://github.com/getsops/sops">SOPS</a> a bit I like its utility.</p>

<p>So, easy enough, but how to do this without leaving private keys (<a href="https://github.com/FiloSottile/age">age</a> calls these <em>identities</em> contrary to their public keys which are <em>recipients</em>) lying around?</p>

<p>I work on macOS and decide to store the <em>age</em> identity in Keychain Access. I’m sure there’s something adequate for Linux and possibly Windows.</p>

<p>A key is generated and written directly as a new <em>password</em> to macOS Keychain. Note that the clear text of the key doesn’t touch the disk. age shows me the public key (<em>recipient</em>) which I need once only to initialize the SOPS file.</p>

<div><div><pre><code>$ security add-generic-password -a jpmens -j &#34;age key for SOPS&#34; -s sopsk1 -w &#34;$(age-keygen | grep AGE-SECRET-KEY )&#34;
Public key: age1w5g63f708smrguhujaxn72q2vs0wppfwgj3uy88cqd7e6zn5sczsjuadau
</code></pre></div></div>

<p>I verify that the <em>identity</em> has correctly been stored; it’ll be displayed on <em>stdout</em>. I can also search for <code>sopsk1</code> in the Keychain Access app:</p>

<div><div><pre><code><span>$</span><span> </span>security find-generic-password <span>-a</span> jpmens <span>-s</span> sopsk1 <span>-w</span>
<span>AGE-SECRET-KEY-1MQ955QVPDNL5LAYPYAFY5GRDFE2XQ3Q24TXZZ4KQ0CL9YHKCXJKQWK9TP3
</span></code></pre></div></div>

<p>At any time I need <em>age</em>’s public key (<em>recipient</em>), I can derive it from the <em>identity</em>; it matches what was shown us above.</p>

<div><div><pre><code><span>$</span><span> </span>security find-generic-password <span>-a</span> jpmens <span>-s</span> sopsk1 <span>-w</span> | age-keygen <span>-y</span>
<span>age1w5g63f708smrguhujaxn72q2vs0wppfwgj3uy88cqd7e6zn5sczsjuadau
</span></code></pre></div></div>

<p>So far we’ve got an <a href="https://github.com/FiloSottile/age">age</a> private key (or <em>identity</em>) stashed away safely (safely enough for me anyway), and we can derive the public key (<em>recipient</em>) from it.</p>

<p>Using <a href="https://github.com/getsops/sops">SOPS</a> I now create the encrypted JSON container file. The <code>sops</code> utility expects a comma-separated list of <em>age</em> recipients on the command line and will create the named file and encrypt the values of JSON elements therein to the specified recipients. The following command drops me into $EDITOR where I will add the JSON obtained above after <em>gronning</em> and <em>ungronning</em> it. (Those are verbs now. :)</p>

<div><div><pre><code><span>$</span><span> </span>sops <span>--age</span> age1w5g63f708smrguhujaxn72q2vs0wppfwgj3uy88cqd7e6zn5sczsjuadau t.json
</code></pre></div></div>

<p>The <a href="https://gist.github.com/jpmens/2d051b7481e18a062d80e7993da859fb">result is a file containing SOPS data</a>. (The more recipients I specify, the larger the file gets; recipients’ keys are encrypted into SOPS output so that each can decrypt.)</p>

<p>Now I have a file with all TOTP codes <a href="https://words.filippo.io/dispatches/age-authentication/">securely encrypted</a> into it.</p>

<p>What’s missing is a wrapper around decrypting the TOTP storage file (here: <code>t.json</code>), selecting the entries I need with <code>grep(1)</code>, and producing the actual TOTP code from its seed (<code>secret</code>) in the JSON dict.</p>

<div><div><pre><code><span>#</span><span>!</span>/usr/bin/env bash
<span>
</span><span>[ $</span><span># -ne 1 ] &amp;&amp; { echo &#34;Usage: $0 pattern&#34; &gt;&amp;2; exit 2; }</span>
<span>
SOPS_AGE_KEY_FILE=&lt;( security find-generic-password -a jpmens -s sopsk1 -w) sops --decrypt t.json |
        jq -r &#39;.services[] | [.secret, .name, .account] | @tsv&#39; |
</span><span>        grep -i -- &#34;$</span>@<span>&#34; |
</span><span>        while read secret name account;</span><span> </span><span>do
</span><span>                echo &#34;$</span><span>(echo </span><span>$secret</span><span> | genotp) </span><span>$name</span><span> </span><span>$account</span><span>&#34;</span>
<span>        done
</span></code></pre></div></div>

<p>The <a href="https://github.com/FiloSottile/age">age</a> <em>identity</em> is read from Keychain and via a FIFO into a variable and provided to <code>sops</code> which decrypts our JSON store to <em>stdout</em> from whence we reformat with <code>jq(1)</code> into TAB-separated lines and <code>grep(1)</code> our way through. Lines which match are passed to <code>genotp</code> , a small Golang program which does the work of calculating the TOTP code from the secret. (I <a href="https://rednafi.com/go/totp_client/">stole the hard bits</a>.) The result are TOTP codes and their TTL directly in the shell.</p>

<div><div><pre><code><span>$</span><span> </span>otp bab
<span>872348 13 Alibaba JP
</span></code></pre></div></div>

<p>I’ll have to backup <a href="https://2fas.com">2FAS</a> TOTP list periodically, but I’m no longer adding codes as frequently as I used to; au contraire – I’m actually deleting accounts: Xing, Linked-In, and foremost Twitter are some of the ones I’ve given up.</p>

<p>As such the manual interaction is fine for my use case.</p>

<p>I would have liked to be able to read through <a href="https://2fas.com">2FAS</a>’ <a href="https://gist.github.com/jpmens/dc3450289fb1389072a58475436ceeba">encrypted export</a> which, from a glance at the source code of their iOS app, uses generated RSA keys, <del>but I’ll leave that to  one of you to implement for me. Until then, there is a brief window of time during which the list of unencrypted TOTP seeds hits the disk here, but that’s a risk I’m willing to take</del>. Seconds before hitting “publish” on this post, I thought I’d ask the internets, and there are utilities which do this. I ran the Ruby tool below on my encrypted backup and got clear text.</p>

<h3 id="further-reading">Further reading</h3>

<ul>
  <li><a href="https://github.com/elliotwutingfeng/2fas-backup-decryptor">lib2fas Python</a>, reads <a href="https://2fas.com">2FAS</a> backup files and prints TOTP codes</li>
  <li><a href="https://github.com/wodny/decrypt-2fas-backup">decrypt-2fas-backup</a>, Python 2FAS app encrypted export decryption tool. Tested and works.</li>
  <li>
    <p><a href="https://gh.mlsub.net/elliotwutingfeng/2fas-backup-decryptor">2FAS Backup Decryptor</a>, Ruby CLI tool to decrypt backup files exported from the 2FAS Authenticator app. Tested and works.</p>

  </li>
</ul>



	
		

			<!-- postfoot -->


	
		</div><!-- post -->
	    </div><!-- inner -->
        </div></div>
  </body>
</html>
