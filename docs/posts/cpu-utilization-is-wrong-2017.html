<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.brendangregg.com/blog/2017-05-09/cpu-utilization-is-wrong.html">Original</a>
    <h1>CPU Utilization Is Wrong (2017)</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>The metric we all use for CPU utilization is deeply misleading, and getting worse every year. What is CPU utilization? How busy your processors are? No, that&#39;s not what it measures. Yes, I&#39;m talking about the &#34;%CPU&#34; metric used <em>everywhere</em>, by <em>everyone</em>. In every performance monitoring product. In top(1).</p>

<p>What you may think 90% CPU utilization means:</p>

<center><a href="https://www.brendangregg.com/blog/images/2017/cpubusyidle.png"><img src="https://www.brendangregg.com/blog/images/2017/cpubusyidle.png" width="700"/></a></center>

<p>What it might really mean:</p>

<center><a href="https://www.brendangregg.com/blog/images/2017/cpubusystalledidle.png"><img src="https://www.brendangregg.com/blog/images/2017/cpubusystalledidle.png" width="700"/></a></center>

<p>Stalled means the processor was not making forward progress with instructions, and usually happens because it is waiting on memory I/O. 
The ratio I drew above (between busy and stalled) is what I typically see in production. Chances are, you&#39;re mostly stalled, but don&#39;t know it.</p>

<p>What does this mean for you? Understanding how much your CPUs are stalled can direct performance tuning efforts between reducing code or reducing memory I/O.
Anyone looking at CPU performance, especially on clouds that auto scale based on CPU, would benefit from knowing the stalled component of their %CPU.</p>

<h2>What really is CPU Utilization?</h2>

<p>The metric we call CPU utilization is really &#34;non-idle time&#34;: the time the CPU was not running the idle thread. Your operating system kernel (whatever it is) usually tracks this during context switch. If a non-idle thread begins running, then stops 100 milliseconds later, the kernel considers that CPU utilized that entire time.</p>

<p>This metric is as old as time sharing systems. The Apollo Lunar Module guidance computer (a pioneering time sharing system) called its idle thread the &#34;DUMMY JOB&#34;, and engineers tracked cycles running it vs real tasks as a important computer utilization metric. (I wrote about this <a href="http://www.brendangregg.com/usemethod.html#Apollo">before</a>.)</p>

<p>So what&#39;s wrong with this?</p>

<p>Nowadays, CPUs have become much faster than main memory, and waiting on memory dominates what is still called &#34;CPU utilization&#34;. When you see high %CPU in top(1), you might think of the processor as being the bottleneck – the CPU package under the heat sink and fan – when it&#39;s really those banks of DRAM.</p>

<p>This has been getting worse. For a long time processor manufacturers were scaling their clockspeed quicker than DRAM was scaling its access latency (the &#34;CPU DRAM gap&#34;). That levelled out around 2005 with 3 GHz processors, and since then processors have scaled using more cores and hyperthreads, plus multi-socket configurations, all putting more demand on the memory subsystem. Processor manufacturers have tried to reduce this memory bottleneck with larger and smarter CPU caches, and faster memory busses and interconnects. But we&#39;re still usually stalled.</p>

<!--
You might be wondering: can't the kernel context switch out a thread that is memory stalled so that it can run something else? No. That takes way too long (microseconds, instead of nanoseconds), plus, the kernel has no way to pause a thread mid-instruction (Intel, that's not a feature request). What modern CPUs can do, is "switch" out stalled instructions and run other *hyperthreads* to reclaim those cycles (yes, I'm simplifying, what really happens is micro-ops, but if I tried to explain it all this would become a book). Hyperthreads help, but the typical ratio I drew above is already after their help.
-->

<h2>How to tell what the CPUs are really doing</h2>

<p>By using Performance Monitoring Counters (PMCs): hardware counters that can be read using <a href="https://www.brendangregg.com/perf.html">Linux perf</a>, and other tools. For example, measuring the entire system for 10 seconds:</p>

<pre># <b>perf stat -a -- sleep 10</b>

 Performance counter stats for &#39;system wide&#39;:

     641398.723351      task-clock (msec)         #   64.116 CPUs utilized            (100.00%)
           379,651      context-switches          #    0.592 K/sec                    (100.00%)
            51,546      cpu-migrations            #    0.080 K/sec                    (100.00%)
        13,423,039      page-faults               #    0.021 M/sec                  
 1,433,972,173,374      cycles                    #    2.236 GHz                      (75.02%)
   &lt;not supported&gt;      stalled-cycles-frontend  
   &lt;not supported&gt;      stalled-cycles-backend   
 1,118,336,816,068      instructions              #    <b>0.78  insns per cycle</b>          (75.01%)
   249,644,142,804      branches                  #  389.218 M/sec                    (75.01%)
     7,791,449,769      branch-misses             #    3.12% of all branches          (75.01%)

      10.003794539 seconds time elapsed
</pre>

<p>The key metric here is <strong>instructions per cycle</strong> (<tt>insns per cycle</tt>: IPC), which shows on average how many instructions we were completed for each CPU clock cycle. The higher, the better (a simplification). The above example of 0.78 sounds not bad (78% busy?) until you realize that this processor&#39;s top speed is an IPC of 4.0. This is also known as <em>4-wide</em>, referring to the instruction fetch/decode path. Which means, the CPU can retire (complete) four instructions with every clock cycle. So an IPC of 0.78 on a 4-wide system, means the CPUs are running at 19.5% their top speed. Newer Intel processors may move to 5-wide.</p>

<p>There are hundreds more PMCs you can use to dig further: measuring stalled cycles directly by different types.</p>

<h3>In the cloud</h3>

<p>If you are in a virtual environment, you might not have access to PMCs, depending on whether the hypervisor supports them for guests. I recently posted about <a href="https://www.brendangregg.com/blog/2017-05-04/the-pmcs-of-ec2.html">The PMCs of EC2: Measuring IPC</a>, showing how PMCs are now available for dedicated host types on the AWS EC2 Xen-based cloud.</p>

<h2>Interpretation and actionable items</h2>

<p>If your <strong>IPC is &lt; 1.0</strong>, you are likely memory stalled, and software tuning strategies include reducing memory I/O, and improving CPU caching and memory locality, especially on NUMA systems. Hardware tuning includes using processors with larger CPU caches, and faster memory, busses, and interconnects.</p>

<p>If your <strong>IPC is &gt; 1.0</strong>, you are likely instruction bound. Look for ways to reduce code execution: eliminate unnecessary work, cache operations, etc. <a href="http://www.brendangregg.com/FlameGraphs/cpuflamegraphs.html">CPU flame graphs</a> are a great tool for this investigation. For hardware tuning, try a faster clock rate, and more cores/hyperthreads.</p>

<p>For my above rules, I split on an IPC of 1.0. Where did I get that from? I made it up, based on my prior work with PMCs. Here&#39;s how you can get a value that&#39;s custom for your system and runtime: write two dummy workloads, one that is CPU bound, and one memory bound. Measure their IPC, then calculate their mid point.</p>

<h2>What performance monitoring products should tell you</h2>

<p>Every performance tool should show IPC along with %CPU. Or break down %CPU into instruction-retired cycles vs stalled cycles, eg, %INS and %STL.</p>

<p>As for top(1), there is tiptop(1) for Linux, which shows IPC by process:</p>

<pre>tiptop -                  [root]
Tasks:  96 total,   3 displayed                               screen  0: default

  <b>PID</b> [ %CPU] %SYS    P   Mcycle   Minstr   <b>IPC</b>  %MISS  %BMIS  %BUS <b>COMMAND</b>
 <b>3897</b>   35.3  28.5    4   274.06   178.23  <b>0.65</b>   0.06   0.00   0.0 <b>java</b>
 <b>1319+</b>   5.5   2.6    6    87.32   125.55  <b>1.44</b>   0.34   0.26   0.0 <b>nm-applet</b>
  <b>900</b>    0.9   0.0    6    25.91    55.55  <b>2.14</b>   0.12   0.21   0.0 <b>dbus-daemo</b>
</pre>

<h2>Other reasons CPU utilization is misleading</h2>

<p>It&#39;s not just memory stall cycles that makes CPU utilization misleading. Other factors include:</p>

<ul>
<li>Temperature trips stalling the processor.</li>
<li>Turboboost varying the clockrate.</li>
<li>The kernel varying the clock rate with speed step.</li>
<li>The problem with averages: 80% utilized over 1 minute, hiding bursts of 100%.</li>
<li>Spin locks: the CPU is utilized, and has high IPC, but the app is not making logical forward progress.</li>
</ul>

<h2>Update: is CPU utilization actually wrong?</h2>

<p>There have been hundreds of comments on this post, here (below) and elsewhere (<a href="https://news.ycombinator.com/item?id=14301739">1</a>, <a href="https://www.reddit.com/r/programming/comments/6a6v8g/cpu_utilization_is_wrong/">2</a>). Thanks to everyone for taking the time and the interest in this topic. To summarize my responses: I&#39;m not talking about iowait at all (that&#39;s disk I/O), and there are actionable items if you know you are memory bound (see above).</p>

<p>But is CPU utilization actually wrong, or just deeply misleading? I think many people interpret high %CPU to mean that the processing unit is the bottleneck, which is wrong (as I said earlier). At that point you don&#39;t yet know, and it is often something external. Is the metric technically correct? If the CPU stall cycles can&#39;t be used by anything else, aren&#39;t they are therefore &#34;utilized waiting&#34; (which sounds like an oxymoron)? In some cases, yes, you could say that %CPU as an OS-level metric is technically correct, but deeply misleading. With hyperthreads, however, those stalled cycles can now be used by another thread, so %CPU may count cycles as utilized that are in fact available. That&#39;s wrong. In this post I wanted to focus on the interpretation problem and suggested solutions, but yes, there are technical problems with this metric as well.</p>

<p>You might just say that utilization as a metric was already broken, as Adrian Cockcroft discussed <a href="http://www.hpts.ws/papers/2007/Cockcroft_HPTS-Useless.pdf">previously</a>.</p>

<h2>Conclusion</h2>

<p>CPU utilization has become a deeply misleading metric: it includes cycles waiting on main memory, which can dominate modern workloads. Perhaps %CPU should be renamed to %CYC, short for cycles. You can figure out what %CPU really means by using additional metrics, including instructions per cycle (IPC). An IPC &lt; 1.0 likely means memory bound, and an IPC &gt; 1.0 likely means instruction bound. I covered IPC in my <a href="https://www.brendangregg.com/blog/2017-05-04/the-pmcs-of-ec2.html">previous post</a>, including an introduction to the Performance Monitoring Counters (PMCs) needed to measure it.</p>

<p>Performance monitoring products that show %CPU – which is all of them – should also show PMC metrics to explain what that means, and not mislead the end user. For example, they can show %CPU with IPC, and/or instruction-retired cycles vs stalled cycles. Armed with these metrics, developers and operators can choose how to better tune their applications and systems.</p>

<!--
And BTW, the companies that make these products are unlikely to add IPC on their own: in my experience, they are *coin-operated*, and only add features when enough paying customers ask for it. So go ask for it.
-->

</div></div>
  </body>
</html>
