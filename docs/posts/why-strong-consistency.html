<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://brooker.co.za/blog/2025/11/18/consistency.html">Original</a>
    <h1>Why Strong Consistency?</h1>
    
    <div id="readability-page-1" class="page"><div id="post">






<p>Eventual consistency makes your life harder.</p>

<p>When I started at AWS in 2008, we ran the EC2 control plane on a tree of MySQL databases: a primary to handle writes, a secondary to take over from the primary, a handful of read replicas to scale reads, and some extra replicas for doing latency-insensitive reporting stuff. All of thing was linked together with MySQL’s statement-based replication. It worked pretty well day to day, but two major areas of pain have stuck with me ever since: operations were costly, and eventual consistency made things weird.</p>

<p>Since then, managed databases like Aurora MySQL have made relational database operations orders of magnitude easier. Which is great. But eventual consistency is still a feature of most database architectures that try scale reads. Today, I want to talk about why eventual consistency is a pain, and why we invested heavily in making all reads strongly consistent in Aurora DSQL.</p>

<p><strong>Eventual Consistency is a Pain for Customers</strong></p>

<p>Consider the following piece of code, running against an API exposed by a database-backed service:</p>

<figure><pre><code data-lang="python"><span>id</span> <span>=</span> <span>create_resource</span><span>(...)</span>
<span>get_resource_state</span><span>(</span><span>id</span><span>,</span> <span>...)</span></code></pre></figure>

<p>In the world of read replicas, the latter statement can do something a little baffling: reply ‘<code>id</code> does not exist’. The reason for this is simple: <code>get_resource_state</code> is a read-only call, likely routed to a read replica, and is racing the write from <code>create_resource</code>. If replication wins, this code works as expected. If the client wins, it has to handle to weird sensation of time moving backwards.</p>

<p>Application programmers don’t really have a principled way to work around this, so they end up writing code like this:</p>

<figure><pre><code data-lang="python"><span>id</span> <span>=</span> <span>create_resource</span><span>(...)</span>
<span>while</span> <span>True</span><span>:</span>
  <span>try</span><span>:</span>
    <span>get_resource_state</span><span>(</span><span>id</span><span>,</span> <span>...)</span>
    <span>return</span>
  <span>except</span> <span>ResourceDoesNotExist</span><span>:</span>
    <span>sleep</span><span>(</span><span>100</span><span>)</span></code></pre></figure>

<p>Which fixes the problem. Kinda. Other times, especially if <code>ResourceDoesNotExist</code> can be thrown if <code>id</code> is deleted, it causes an infinite loop. It also creates more work for client and server, adds latency, and requires the programmer to choose a magic number for <code>sleep</code> that balances between the two. Ugly.</p>

<p>But that’s not all. Marc Bowes pointed out that this problem is even more insidious:</p>

<figure><pre><code data-lang="python"><span>def</span> <span>wait_for_resource</span><span>(</span><span>id</span><span>):</span>
  <span>try</span><span>:</span>
    <span>get_resource_state</span><span>(</span><span>id</span><span>,</span> <span>...)</span>
    <span>return</span>
  <span>except</span> <span>ResourceDoesNotExist</span><span>:</span>
    <span>sleep</span><span>(</span><span>100</span><span>)</span>
  
<span>id</span> <span>=</span> <span>create_resource</span><span>(...)</span>
<span>wait_for_resource</span><span>(</span><span>id</span><span>)</span>
<span>get_resource_state</span><span>(</span><span>id</span><span>)</span>    </code></pre></figure>

<p>Could <em>still</em> fail, because the second <code>get_resource_state</code> call could go to an entirely different read replica that hasn’t heard the news yet<sup><a href="#foot3">3</a></sup>.</p>

<p>Strong consistency avoids this whole problem<sup><a href="#foot1">1</a></sup>, ensuring that the first code snippet works as expected.</p>

<p><strong>Eventual Consistency is a Pain for Application Builders</strong></p>

<p>The folks building the service behind that API run into exactly the same problems. To get the benefits of read replicas, application builders need to route as much read traffic as possible to those read replicas. But consider the following code:</p>

<figure><pre><code data-lang="python"><span>block_attachment_changes</span><span>(</span><span>id</span><span>,</span> <span>...)</span>
<span>for</span> <span>attachment</span> <span>in</span> <span>get_attachments_to_thing</span><span>(</span><span>id</span><span>):</span>
  <span>remove_attachment</span><span>(</span><span>id</span><span>,</span> <span>attachment</span><span>)</span>
<span>assert_is_empty</span><span>(</span><span>get_attachments_to_thing</span><span>(</span><span>id</span><span>))</span></code></pre></figure>

<p>This is a fairly common code pattern inside microservices. A kind a little workflow that cleans something up. But, in the wild world of eventual consistency, it has at least three possible bugs:</p>

<ul>
  <li>The <code>assert</code> could trigger because the second <code>get_attachments_to_thing</code> hasn’t heard the news of all the <code>remove_attachments</code>.</li>
  <li>The <code>remove_attachment</code> could fail because it hasn’t heard of one of the attachments listed by <code>get_attachments_to_thing</code>.</li>
  <li>The first <code>get_attachments_to_thing</code> could have an incomplete list because it read stale data, leading to incomplete clean up.</li>
</ul>

<p>And there are a couple more. The application builder has to avoid these problems by making sure that all reads that are used to trigger later writes are sent to the primary. This requires more logic around routing (a simple “this API is read-only” is not sufficient), and reduces the effectiveness of scaling by reducing traffic that can be sent to replicas.</p>

<p><strong>Eventual Consistency Makes Scaling Harder</strong></p>

<p>Which brings us to our third point: read-modify-write is the canonical transactional workload. That applies to explicit transactions (anything that does an <code>UPDATE</code> or <code>SELECT</code> followed by a write in a transaction), but also things that do implicit transactions (like the example above). Eventual consistency makes read replicas less effective, because the reads used for read-modify-write can’t, in general, be used for writes without having weird effects.</p>

<p>Consider the following code:</p>

<figure><pre><code data-lang="sql"><span>UPDATE</span> <span>dogs</span> <span>SET</span> <span>goodness</span> <span>=</span> <span>goodness</span> <span>+</span> <span>1</span> <span>WHERE</span> <span>name</span> <span>=</span> <span>&#39;sophie&#39;</span></code></pre></figure>

<p>If the read for that read-modify-write is read from a read replica, then the value of <code>goodness</code> may not be changed in the way you expect. Now, the database could internally do something like this:</p>

<figure><pre><code data-lang="sql"><span>SELECT</span> <span>goodness</span> <span>AS</span> <span>g</span><span>,</span> <span>version</span> <span>AS</span> <span>v</span> <span>FROM</span> <span>dogs</span> <span>WHERE</span> <span>name</span> <span>=</span> <span>&#39;sophie&#39;</span><span>;</span> <span>-- To read replica</span>
<span>UPDATE</span> <span>sophie</span> <span>SET</span> <span>goodness</span> <span>=</span> <span>g</span> <span>+</span> <span>1</span><span>,</span> <span>version</span> <span>=</span> <span>v</span> <span>+</span> <span>1</span> <span>WHERE</span> <span>name</span> <span>=</span> <span>&#39;sophie&#39;</span> <span>AND</span> <span>version</span> <span>=</span> <span>v</span><span>;</span> <span>-- To primary</span></code></pre></figure>

<p>And then checking it actually updated a row<sup><a href="#foot2">2</a></sup>, but that adds a ton of work.</p>

<p>The nice thing about making scale-out reads strongly consistent is that the query processor can read from any replica, even in read-write transactions. It also doesn’t need to know up-front whether a transaction is read-write or read-only to pick a replica.</p>

<p><strong>How Aurora DSQL Does Consistent Reads with Read Scaling</strong></p>

<p>As I said above, in Aurora DSQL all reads are strongly consistent. DSQL can also scale out reads by adding additional replicas of any hot shards. So how does it ensure that all reads are strongly consistent? Let’s remind ourselves about the basics of the DSQL architecture.</p>

<p><img src="https://brooker.co.za/blog/images/1205_write_arch.jpg" alt="Architecture diagram showing Aurora DSQL components: three AZ Endpoints, four Query Processors, three Adjudicators, three Journals, and six Storage nodes arranged left to right, with the top AZ Endpoint connecting to the second Query Processor via orange &#34;Reads and Writes&#34; line, the second Query Processor connecting to the first two Adjudicators via red &#34;Commits&#34; lines, a red &#34;Commits&#34; line between the first two Adjudicators, the second Adjudicator connecting to the second Journal via red &#34;Commits&#34; line, and the second Journal connecting to the second and fourth Storage nodes via red &#34;Commits&#34; lines, with legend showing orange for &#34;Reads and Writes&#34;, green dashed for &#34;Reads&#34;, and red for &#34;Commits&#34;"/></p>

<p>Each storage replica gets its updates from one or more journals. Writes on each journal are strictly monotonic, so once a storage node has seen an update from time $\tau$ it knows it has seen all updates for times $t \leq \tau$. Once it has seen $t \geq \tau$ from all the journals it has subscribed to, it knows that it can return data for time $\tau$ without missing any updates. When a query processor starts a transaction, it picks a time stamp $\tau_{start}$, and every time it does a read from a replica it says to the replica “give me data as of $\tau_{start}$”. If the replica has seen higher timestamps from all journals, its good to go. If it hasn’t yet, it blocks the read until the write streams catch up.</p>

<p>I go into some detail on how $\tau_{start}$ is picked here:</p>

<iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/rLjK64J8ev4?si=K4jkEDodAtygkgvs&amp;start=3386" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe>

<p><strong>Conclusion</strong></p>

<p>Strong consistency sounds like a complex topic for distributed systems nerds, but is a real thing that applications built on traditional database replication architectures need to start dealing with at modest scale - or even at very small scale if they’re trying to offer high availability. DSQL goes to some internal lengths to make all reads consistent - with the aim of saving application builders and end users from having to deal with this complexity.</p>

<p>I don’t mean to say that eventual consistency is always bad. Latency and connectivity trade-offs do exist (although the <a href="https://brooker.co.za/blog/2024/07/25/cap-again.html">choose-two framing of CAP is bunk</a>), and eventual consistency has its place. However, that place is probably not in your services or API.</p>

<p><em>Footnotes</em></p>

<ol>
  <li><a name="foot1"></a> You might point out that this particular problem can be fixed with a weaker set of guarantees, like Read Your Writes, provided by client stickiness. However, this falls down pretty quickly in more complex data models, and cases like IaC where ‘your writes’ is less well defined.</li>
  <li><a name="foot2"></a> Yes, I know there are other ways to do this.</li>
  <li><a name="foot3"></a> If we want to get technical, this is because the typical database read replica pattern doesn’t offer <em>monotonic reads</em>, where the set of writes a reader sees is increasing over time. Instead, writes at the tip can appear to come and go arbitrarily, as requests are routed to different replicas. See Doug Terry’s <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2011/10/ConsistencyAndBaseballReport.pdf">Replicated Data Consistency Explained Through Baseball</a> for an easy introduction into these terms.</li>
</ol>

</div></div>
  </body>
</html>
