<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.jonashietala.se/blog/2022/08/29/rewriting_my_blog_in_rust_for_fun_and_profit/">Original</a>
    <h1>Rewriting my blog in Rust for fun and profit</h1>
    
    <div id="readability-page-1" class="page"><div>
      

      
<article>
  <header>
    
    
    <span>
      <time datetime="2022-08-29">August 29, 2022</time>
    </span>
    
  </header>

  

  <h2 id="background"><a href="#background">Background</a></h2>
<p>I’ve used <a href="https://jaspervdj.be/hakyll/" title="Hakyll static site generator">Hakyll</a> as my static site generator for around 9 years now. Before that I think I used <a href="https://jekyllrb.com/" title="Simple, blog-aware, static sites">Jekyll</a> and also more dynamic pages with <a href="https://mojolicious.org/" title="Perl real-time web framework">Mojolicious</a> in Perl and <a href="https://kohanaframework.org/" title="The Switft PHP Framework">Kohana</a> in PHP, but I can’t be completely sure as the git history doesn’t go back that far.</p>
<p>But all good things come to an end and I’ve now migrated to my own custom site generator written in Rust.</p>
<h3 id="problems-with-my-previous-setup"><a href="#problems-with-my-previous-setup">Problems with my previous setup</a></h3>
<p>These are the main annoyances I wanted to solve with this rewrite:</p>
<ol>
<li>
<p>It was starting to get slow.</p>
<p>On my crappy laptop a full site rebuild took 75 seconds. (Not compile, just to generate the site.) I only have 240 posts so I don’t think it should be that slow. While there is a good caching system and a watch command that only updates the changed post during editing, it was still annoyingly slow.</p>
</li>
<li>
<p>Several external dependencies.</p>
<p>While the site generator itself is written in Haskell, there were other dependencies apart from a number of Haskell libs. My blog helper script was written in Perl, I used <a href="https://github.com/sass/sassc" title="libsass command line driver">sassc</a> to convert sass, <a href="https://pygments.org/" title="Python syntax highlighter">pygments</a> in Python for syntax highlighting, and <a href="https://github.com/s3tools/s3cmd" title="S3cmd tool for Amazon Simple Storage Service (S3)">s3cmd</a> for uploading the generated site to S3.</p>
<p>It’s annoying to install all these and to keep them up-to-date, it would be great to just have a single thing to worry about.</p>
</li>
<li>
<p>Setup problems.</p>
<p>Related to the previous point, sometimes things just break and I have to spend time to debug and fix them. This is especially frustrating when I have some good idea of something to write about, just to find out that I have some issue with my site generator.</p>
<p>You might think, what could possibly go wrong?</p>
<p>Well, sometimes I update some packages that might break things in weird ways. For example:</p>
<ul>
<li>
<p>After GHC is updated it <a href="https://www.jonashietala.se/blog/2020/05/09/ghc_cannot_find_cabal_packages/" title="ghc 8.8.3 cannot find cabal 3.0.0.0 packages">can no longer find cabal packages</a>.</p>
</li>
<li>
<p>When I run the Haskell binary on I get this:</p>
<pre><code>[ERROR] Prelude.read: no parse
</code></pre>
<p>(Only on my desktop, it works fine on my laptop.)</p>
</li>
<li>
<p>Or this Perl error:</p>
<pre><code>Magic.c: loadable library and perl binaries are mismatched (got handshake key 0xcd00080, needed 0xeb00080)
</code></pre>
<p>(Only on my laptop, it works fine on my desktop.)</p>
</li>
<li>
<p>When Hakyll changed Pandoc arguments between versions, <a href="https://github.com/jaspervdj/hakyll/issues/662" title="GitHub: Syntax highlighting creating anchor tags? #662">breaking code rendering in my Atom feed</a>.</p>
</li>
</ul>
<p>I know that these are all solvable, but I just want something that just works™.</p>
</li>
<li>
<p>Mental overhead with Haskell.</p>
<p>I kind of like Haskell—especially the purely functional parts of it, and I am a fan of the declarative approach Hakyll takes to site configuration. Take the generation of static (i.e. standalone pages) for instance:</p>
<pre><code>match <span><span>&#34;</span>static/*.markdown<span>&#34;</span></span> <span>$</span> <span>do</span>
    route   staticRoute
    compile <span>$</span> pandocCompiler streams
        <span>&gt;&gt;=</span> loadAndApplyTemplate <span><span>&#34;</span>templates/static.html<span>&#34;</span></span> siteCtx
        <span>&gt;&gt;=</span> loadAndApplyTemplate <span><span>&#34;</span>templates/site.html<span>&#34;</span></span> siteCtx
        <span>&gt;&gt;=</span> deIndexUrls</code></pre>
<p>Even if you don’t understand the <code><span>$</span></code> and <code><span>&gt;&gt;=</span></code>, I still think it’s clear that we’re finding files from the <code>static/</code> folder, sending them to <code>pandocCompiler</code> (to convert from markdown), to some templates and then de-indexing urls (to avoid links ending with <code>index.html</code>).</p>
<p>Simple and clear!</p>
<p>But I haven’t used Haskell in years, and the overhead for me to add slightly more complex things to the site is quite large.</p>
<p>For example, I wanted to add next/prev links to posts, but then I had to spend some time relearning Haskell and Hakyll. And even then the solution I came up with was super slow because it was a linear search to find the next/previous posts, but I couldn’t figure out how to do this properly with the way Hakyll is setup.</p>
<p>I’m sure you can do it in an efficient manner, but for me it was too much effort for such a small feature for me to bother.</p>
</li>
</ol>
<h3 id="why-rust"><a href="#why-rust">Why Rust?</a></h3>
<ol>
<li>I enjoy using Rust, and it’s important for a hobby project like this.</li>
<li>Rust is quite performant and transforming text is a task it should be good at.</li>
<li>Cargo is fire and forget. As long as you have Rust installed, it should be enough to just do <code>cargo build</code> and it should just work™.</li>
</ol>
<h3 id="why-reinvent-the-wheel-again"><a href="#why-reinvent-the-wheel-again">Why reinvent the wheel again?</a></h3>
<p>I wanted to write my own static site generator as a fun and interesting project. It shouldn’t be <em>that</em> hard and it would give me complete control over the site, which should give me a bit more flexibility than if I used an existing site generator.</p>
<p>(Yes I know that projects like <a href="https://cobalt-org.github.io/docs/" title="cobalt.rs site generator">cobalt</a> allows you to make any kind of transformation, using whatever language you want, to your pages.)</p>
<h2 id="implementation-details"><a href="#implementation-details">Implementation details</a></h2>
<p>I’m not going to describe everything I did here, take a look at the <a href="https://github.com/treeman/jonashietala" title="Source code to this site">source code</a> if you’re interested.</p>
<h3 id="delegate-the-hard-things"><a href="#delegate-the-hard-things">Delegate the hard things</a></h3>
<p>At first I was worried that it would be hard to replicate all the features I enjoyed with Hakyll, like the templating engine, the syntax highlighting for numerous languages or the <code>watch</code> command that automatically regenerates any pages you edit and acts as a file server so I can view the post in the browser during the writing process.</p>
<p>Turns out that it’s easy if you let existing crates handle the hard parts. Here are some of the libraries I used to good effect:</p>
<ul>
<li>
<p><a href="https://tera.netlify.app/" title="A powerful, easy to use template engine for Rust">tera</a> for a templating engine.</p>
<p>It’s more powerful than what Hakyll provides, as it can do things like loop:</p>
<pre><code><span><span>&lt;</span><span>div</span> <span><span>class</span><span>=</span></span><span><span><span>&#34;</span></span></span><span><span><span>post-footer</span><span>&#34;</span></span></span><span>&gt;</span></span>
  <span><span>&lt;</span><span>nav</span> <span><span>class</span><span>=</span></span><span><span><span>&#34;</span></span></span><span><span><span>tag-links</span><span>&#34;</span></span></span><span>&gt;</span></span>
      Posted in {% for tag in tags %}{% if loop.index0 &gt; 0 %}, {% endif %}<span><span>&lt;</span><span>a</span> <span><span>href</span><span>=</span></span><span><span><span>&#34;</span>{{ tag.href }}<span>&#34;</span></span></span><span>&gt;</span></span>{{ tag.name }}<span><span>&lt;/</span><span>a</span><span>&gt;</span></span>{% endfor %}.
  <span><span>&lt;/</span><span>nav</span><span>&gt;</span></span>
<span><span>&lt;/</span><span>div</span><span>&gt;</span></span></code></pre></li>
<li>
<p><a href="https://crates.io/crates/pulldown-cmark" title="A pull parser for CommonMark">pulldown-cmark</a> for parsing Markdown.</p>
<p>It’s really for <a href="https://commonmark.org/" title="A strongly defined, highly compatible specification of Markdown">CommonMark</a> which is a standard, unambiguous syntax specification for Markdown.</p>
<p>While fast, it doesn’t support as many things as <a href="https://pandoc.org/MANUAL.html" title="Pandoc">Pandoc</a> does, so I had to extend it with some more features. More on that later.</p>
</li>
<li>
<p><a href="https://crates.io/crates/syntect" title="library for high quality syntax highlighting and code intelligence using Sublime Text&#39;s grammars">syntect</a> for syntax highlighting, supporting Sublime Text’s grammars.</p>
</li>
<li>
<p><a href="https://crates.io/crates/yaml-front-matter" title="YAML Front Matter (YFM) parser for Markdown files ">yaml-front-matter</a> to parse metadata from posts.</p>
</li>
<li>
<p><a href="https://crates.io/crates/grass" title="A near-feature-complete Sass compiler written purely in Rust">grass</a> as a Sass compiler purely in Rust.</p>
</li>
<li>
<p><a href="https://crates.io/crates/axum" title="Web framework that focuses on ergonomics and modularity">axum</a> to create <a href="https://github.com/tokio-rs/axum/tree/main/examples/static-file-server">a static file server</a> used to host the site locally.</p>
</li>
<li>
<p><a href="https://crates.io/crates/hotwatch" title="A Rust library for conveniently watching and handling file changes">hotwatch</a> to watch for file changes, so we can update pages whenever a file is updated.</p>
</li>
<li>
<p><a href="https://crates.io/crates/scraper" title="HTML parsing and querying with CSS selectors">scraper</a> to parse the generated html. Used in some of my tests and for some specific transformations.</p>
</li>
<li>
<p><a href="https://crates.io/crates/rust-s3" title="Rust library for working with Amazon S3 and compatible object storage APIs">rust-s3</a> to upload the generated site to S3 storage.</p>
</li>
</ul>
<p>Even with these libraries the Rust source files themselves contained over 6000 lines. In some cases Rust can be verbose, and my code is really not beautiful, but writing this project was still more work than expected. (Isn’t that always the case?)</p>
<h3 id="markdown-transformations"><a href="#markdown-transformations">Markdown transformations</a></h3>
<p>While it would be easy if my posts were just standard markdown, over the years I’ve included various features and extensions that my markdown parsers of choice <a href="https://crates.io/crates/pulldown-cmark" title="A pull parser for CommonMark">pulldown-cmark</a> don’t support. So I had to code them myself.</p>
<h4 id="preprocessing"><a href="#preprocessing">Preprocessing</a></h4>
<p>I have a preprocessing step that I use to create figures with multiple images. It’s a generalized processing step that takes the form:</p>
<pre><code>::: &lt;type&gt;
&lt;content&gt;
:::
</code></pre>
<p>I use this for different kinds of image collections, such as <code>Flex</code>, <code>Figure</code> and <code>Gallery</code>. For example this:</p>
<pre><code>::: Flex
/images/img1.png
/images/img2.png
/images/img3.png

Figcaption goes here
:::
</code></pre>
<p>Would be transformed to:</p>
<pre><code><span><span>&lt;</span><span>figure</span> <span><span>class</span><span>=</span></span><span><span><span>&#34;</span></span></span><span><span><span>flex-33</span><span>&#34;</span></span></span><span>&gt;</span></span>
<span><span>&lt;</span><span>img</span> <span><span>src</span><span>=</span></span><span><span><span>&#34;</span>/images/img1.png<span>&#34;</span></span></span><span> /&gt;</span></span>
<span><span>&lt;</span><span>img</span> <span><span>src</span><span>=</span></span><span><span><span>&#34;</span>/images/img2.png<span>&#34;</span></span></span><span> /&gt;</span></span>
<span><span>&lt;</span><span>img</span> <span><span>src</span><span>=</span></span><span><span><span>&#34;</span>/images/img3.png<span>&#34;</span></span></span><span> /&gt;</span></span>
<span><span>&lt;</span><span>figcaption</span><span>&gt;</span></span>Figcaption goes here<span><span>&lt;/</span><span>figcaption</span><span>&gt;</span></span>
<span><span>&lt;/</span><span>figure</span><span>&gt;</span></span></code></pre>
<p>And how did I implement this magic? Using Regex of course!</p>
<pre><code><span>use</span> <span>lazy_static<span>::</span></span>lazy_static<span>;</span>
<span>use</span> <span>regex<span>::</span></span><span><span>{</span>Captures<span>,</span> Regex</span><span><span>}</span></span><span>;</span>
<span>use</span> <span>std<span>::</span></span><span>borrow<span>::</span></span>Cow<span>;</span>

<span>lazy_static!</span> <span><span>{</span>
    <span>static</span> <span>ref</span> <span>BLOCK</span><span>:</span> Regex <span>=</span> <span>Regex<span>::</span></span>new<span><span>(</span>
        <span><span>r</span><span>#</span>&#34;(?xsm)
        ^
        # Opening :::
        :{3}
        \s+
        # Parsing id type
        (?P&lt;id&gt;\w+)
        \s*
        $

        # Content inside
        (?P&lt;content&gt;.+?)

        # Ending :::
        ^:::$
        <span>&#34;#</span></span>
    </span><span><span>)</span></span>
    .<span>unwrap</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
</span><span><span>}</span></span>

<span><span><span>pub</span> <span>fn</span> </span><span>parse_fenced_blocks</span></span><span><span><span>(</span><span>s</span><span>:</span> <span>&amp;</span><span>str</span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>Cow<span>&lt;</span><span>str</span><span>&gt;</span></span></span> </span><span><span><span>{</span>
    <span>BLOCK</span>.<span>replace_all</span><span><span>(</span>s<span>,</span> <span><span><span>|</span></span></span><span><span><span>caps</span><span>:</span> <span>&amp;</span>Captures<span>|</span></span> <span><span>-&gt;</span> String</span> </span><span><span><span>{</span>
        <span>parse_block</span><span><span>(</span>
            caps.<span>name</span><span><span>(</span><span><span>&#34;</span>id<span>&#34;</span></span></span><span><span>)</span></span>.<span>unwrap</span><span><span>(</span></span><span><span>)</span></span>.<span>as_str</span><span><span>(</span></span><span><span>)</span></span><span>,</span>
            caps.<span>name</span><span><span>(</span><span><span>&#34;</span>content<span>&#34;</span></span></span><span><span>)</span></span>.<span>unwrap</span><span><span>(</span></span><span><span>)</span></span>.<span>as_str</span><span><span>(</span></span><span><span>)</span></span><span>,</span>
        </span><span><span>)</span></span>
    </span><span><span>}</span></span></span></span><span><span>)</span></span>
</span><span><span>}</span></span></span>

<span><span><span>fn</span> </span><span>parse_block</span></span><span><span><span>(</span><span>id</span><span>:</span> <span>&amp;</span><span>str</span>, <span>content</span><span>:</span> <span>&amp;</span><span>str</span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> String</span> </span><span><span><span>{</span>
    <span>...</span>
</span><span><span>}</span></span></span></code></pre>
<p>(The image and figure parsing is more verbose, so let’s skip that shall we?)</p>
<h4 id="extending-pulldown_cmark"><a href="#extending-pulldown_cmark">Extending pulldown_cmark</a></h4>
<p>I’ve also extended <a href="https://crates.io/crates/pulldown-cmark" title="A pull parser for CommonMark">pulldown-cmark</a> with transformations of my own:</p>
<pre><code><span>let</span> transformed <span>=</span> <span>Parser<span>::</span></span>new_with_broken_link_callback<span><span>(</span>s<span>,</span> <span>Options<span>::</span></span>all<span><span>(</span></span><span><span>)</span></span><span>,</span> <span>Some</span><span><span>(</span><span>&amp;</span><span>mut</span> cb</span><span><span>)</span></span></span><span><span>)</span></span><span>;</span>
<span>let</span> transformed <span>=</span> <span>TransformHeaders<span>::</span></span>new<span><span>(</span>transformed</span><span><span>)</span></span><span>;</span>
<span>let</span> transformed <span>=</span> <span>AutoFigures<span>::</span></span>new<span><span>(</span>transformed</span><span><span>)</span></span><span>;</span>
<span>let</span> transformed <span>=</span> <span>EmbedYoutube<span>::</span></span>new<span><span>(</span>transformed</span><span><span>)</span></span><span>;</span>
<span>let</span> transformed <span>=</span> <span>CodeBlockSyntaxHighlight<span>::</span></span>new<span><span>(</span>transformed</span><span><span>)</span></span><span>;</span>
<span>let</span> transformed <span>=</span> <span>InlineCodeSyntaxHighlight<span>::</span></span>new<span><span>(</span>transformed</span><span><span>)</span></span><span>;</span>
<span>let</span> transformed <span>=</span> <span>QuoteAttrs<span>::</span></span>new<span><span>(</span>transformed</span><span><span>)</span></span><span>;</span>
<span>let</span> transformed <span>=</span> <span>TableAttrs<span>::</span></span>new<span><span>(</span>transformed</span><span><span>)</span></span><span>;</span></code></pre>
<p>Demoting headers and <a href="https://www.jonashietala.se/blog/2014/09/01/embedding_youtube_videos_with_hakyll/" title="Embedding youtube videos with Hakyll">embedding bare YouTube links</a> is something I used to do before, and were fairly straightforward do implement. (It might have been better to embed YouTube links in a pre- or post-processing step though.)</p>
<p>Pandoc had support for adding attributes and classes to arbitrary elements, which was very useful. So for instance this:</p>
<pre><code><span>![](/images/img1.png){ height=100 }
</span></code></pre>
<p>Would be transformed into this:</p>
<pre><code><span><span>&lt;</span><span>figure</span><span>&gt;</span></span>
  <span><span>&lt;</span><span>img</span> <span><span>src</span><span>=</span></span><span><span><span>&#34;</span>/images/img1.png<span>&#34;</span></span></span> <span><span>height</span><span>=</span></span><span><span><span>&#34;</span>100<span>&#34;</span></span></span><span>&gt;</span></span>
<span><span>&lt;/</span><span>figure</span><span>&gt;</span></span></code></pre>
<p>I used it all over the place, so I reimplemented it… in less general and hacky manner.</p>
<p>Another feature I used in Pandoc that wasn’t supported was evaluating markdown inside html tags. So this would no longer render correctly:</p>
<pre><code><span><span><span>&lt;</span><span>aside</span><span>&gt;</span></span>
My [link][link_ref]
<span><span>&lt;/</span><span>aside</span><span>&gt;</span></span>
</span></code></pre>
<p>At first my plan was to do this with the generalized preprocessing step, but then I’d lose track of link references. So in this example:</p>
<pre><code><span>::: Aside
My <span><span>[</span></span><span>link</span><span><span>]</span></span><span><span>[</span><span>link_ref</span><span>]</span></span>
:::

</span><span><span>[</span><span>link_ref</span><span>]</span><span>:</span> <span>/some/path</span>
</span></code></pre>
<p><code>link</code> would not be turned into a link as we would only parse inside <code>:::</code>.</p>
<pre><code><span><span><span>&gt;</span> Some text
{ :notice }
</span></span></code></pre>
<p>That would call a <code>notice</code> parser, which in this case would create a <code><span><span>&lt;</span><span>aside</span><span>&gt;</span></span></code> tag instead of a <code><span><span>&lt;</span><span>blockquote</span><span>&gt;</span></span></code> tag, while preserving the parsed markdown.</p>
<p>While there are existing crates that adds code highlighting using <a href="https://crates.io/crates/syntect" title="library for high quality syntax highlighting and code intelligence using Sublime Text&#39;s grammars">syntect</a>, I wrote my own that wraps it in a <code><span><span>&lt;</span><span>code</span><span>&gt;</span></span></code> tag and supports inline code highlighting. For example “Inside row: <code><span>let</span> x <span>=</span> <span>2</span><span>;</span></code>” is produced by:</p>
<pre><code><span>Inside row: <span><span>`</span>let x = 2;<span>`</span></span>rust
</span></code></pre><h3 id="performance-improvements"><a href="#performance-improvements">Performance improvements</a></h3>
<p>I didn’t spend that much time into improving the performance, but two things had a significant impact:</p>
<p>The first thing is that if you use <a href="https://crates.io/crates/syntect" title="library for high quality syntax highlighting and code intelligence using Sublime Text&#39;s grammars">syntect</a> and have custom syntaxes, you really should <a href="https://docs.rs/syntect/latest/syntect/dumps/index.html">compress <code>SyntaxSet</code> to a binary format</a>.</p>
<p>The other thing was to parallelize rendering using <a href="https://docs.rs/rayon/latest/rayon/" title="Data-parallelism library that makes it easy to convert sequential computations into parallel">rayon</a>. Rendering is the markdown parsing, applying templates and creating the output file. Rayon is great is this task is limited by CPU and it’s very easy to use (if the code is structured correctly). This is for instance a simplified view of the rendering:</p>
<pre><code><span><span><span>fn</span> </span><span>render</span></span><span><span><span>(</span><span>&amp;</span><span>self</span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>Result<span>&lt;</span><span>(</span><span>)</span><span>&gt;</span></span></span> </span><span><span><span>{</span>
    <span>let</span> <span>mut</span> items <span>=</span> <span>Vec</span><span><span>::</span></span>new<span><span>(</span></span><span><span>)</span></span><span>;</span>

        <span>for</span> post <span>in</span> <span>&amp;</span><span>self</span>.content.posts <span><span>{</span>
        items.<span>push</span><span><span>(</span>post.<span>as_ref</span><span><span>(</span></span><span><span>)</span></span></span><span><span>)</span></span><span>;</span>
    </span><span><span>}</span></span>

        items
        .<span>iter</span><span><span>(</span></span><span><span>)</span></span>
        .<span>try_for_each</span><span><span>(</span><span><span><span>|</span></span></span><span><span><span>item</span><span>|</span></span> </span><span><span>self</span>.<span>render_item</span><span><span>(</span><span>*</span>item</span><span><span>)</span></span></span></span><span><span>)</span></span>
</span><span><span>}</span></span></span></code></pre>
<p>To parallelize this all we need to do is change <code><span>iter</span><span><span>(</span></span><span><span>)</span></span></code> into <code><span>par_iter</span><span><span>(</span></span><span><span>)</span></span></code>:</p>
<pre><code><span>use</span> <span>rayon<span>::</span></span><span>iter<span>::</span></span><span><span>{</span>IntoParallelRefIterator<span>,</span> ParallelIterator</span><span><span>}</span></span><span>;</span>

items
    .<span>par_iter</span><span><span>(</span></span><span><span>)</span></span>     .<span>try_for_each</span><span><span>(</span><span><span><span>|</span></span></span><span><span><span>item</span><span>|</span></span> </span><span><span>self</span>.<span>render_item</span><span><span>(</span><span>*</span>item</span><span><span>)</span></span></span></span><span><span>)</span></span></code></pre>
<p>And that’s it!</p>
<p>Admittedly, my performance improvements are quite minor, and the big performance gains comes from the libraries I use. For instance my old site used an external <a href="https://pygments.org/" title="Python syntax highlighter">pygments</a> process written in Python for syntax highlighting, while I now have a highlighter in Rust that’s <em>much</em> faster, and can easily be parallelized.</p>
<h3 id="sanity-checks"><a href="#sanity-checks">Sanity checks</a></h3>
<p>One thing that always bothered me with the site is how easy it was to make a mistake. For example linking to a non-existent page or image, or not defining a link reference at all with <code>[my link][todo]</code>, and forgetting to update it before publishing.</p>
<p>So in addition to testing basic functionality like the watch command, I also parse the whole site and check that all internal links exists and are correct (so it validates <code>some-title</code> in <code>/blog/my-post#some-title</code> too). I also check external links, but that’s with a manual command.</p>
<p>During generation I also take a hard stance and <code>panic</code> early and often, just to reduce the risk that something weird slips by.</p>
<h2 id="how-did-it-go"><a href="#how-did-it-go">How did it go?</a></h2>
<p>In the beginning of this post I listed some issues I had with my previous setup, so let’s see if I managed to improve them?</p>
<ol>
<li>
<p><strong>Performance</strong></p>
<p>On my crappy laptop a full site rebuild (not including compilation time) now takes 4 seconds. An 18x performance improvement is not too shabby I’d say. I’m sure this could be improved further—for example I use <a href="https://docs.rs/rayon/latest/rayon/" title="Data-parallelism library that makes it easy to convert sequential computations into parallel">rayon</a> for file IO while async would be more beneficial, and I don’t have a caching system so I regenerate all files every time I build. (During watching it’s smarter though.)</p>
<p>Please note that this is not to say that Rust this much faster than Haskell, instead see it as a comparison of two implementations. I’m sure someone could make it super fast in Haskell.</p>
</li>
<li>
<p><strong>A single dependency</strong></p>
<p>Now I’ve got everything in Rust, with no external scripts or tools I need to install and keep working.</p>
</li>
<li>
<p><strong>Cargo “just works”</strong></p>
<p>As long as I have rust on the system, <code>cargo build</code> is just rock solid. I think this is low-key one of Rust’s biggest strengths—the build system <em>just works</em>.</p>
<p>You don’t have to manually hunt down missing dependencies, sacrifice a child to make it cross-platform or pull your hair out when the build system automagically pulls down an update that breaks everything again. You just lean back and wait for your code to compile.</p>
</li>
<li>
<p><strong>I had an easier time with Rust</strong></p>
<p>While I did find it easier to implement things like <a href="https://www.jonashietala.se/series" title="Many blog posts makes a series">series</a> or prev/next links (which aren’t live yet as I haven’t styled them properly), I don’t think it means that Rust is simpler or easier than Haskell, it just means that I personally had an easier time to grok Rust than Haskell.</p>
<p>The biggest reason why probably comes down to practice. While I’ve been using Rust a fair bit lately, I’ve barely touched Haskell since I started using it for this site around a decade ago.</p>
<p>I’m sure that if I don’t use Rust for 10 years and you ask me to use it again, I’ll struggle a fair bit as well.</p>
</li>
</ol>
<p>Overall, I’m quite pleased. It was a fun—albeit a larger than I had anticipated—project that also removed some of my annoyances with this site.</p>


  

  
</article>

    </div></div>
  </body>
</html>
