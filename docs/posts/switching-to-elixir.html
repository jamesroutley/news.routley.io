<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.leemeichin.com/posts/switching-to-elixir.html">Original</a>
    <h1>Switching to Elixir</h1>
    
    <div id="readability-page-1" class="page"><div id="content">
<header>

</header><p>
A few months ago I started a new job at a company that uses Elixir as its main language on the backend. I&#39;ve never written a line of Elixir or Erlang before in my life, but I&#39;ve heard a lot about it and Erlang is familiar because I&#39;ve played around with Prolog for a bit.
</p>

<p>
Thanks to the heavily Ruby-inspired syntax, Elixir was a synch to pick up. I might not be an expert on best practices, architecture, and lower level Erlang concepts yet, but none of this has been a barrier to entry.
</p>

<p>
In fact, I might go as far as saying that Elixir gives you a fun language (like Ruby) while leaving out the stateful footguns OOP languages give you. There are no classes, no instances, no inheritanceâ€¦it&#39;s immutable and functional and you&#39;re not bogged down by a static type system.
</p>

<p>
I see this as a benefit because code that holds mutable state is immensely harder to maintain than code that doesn&#39;t, and it isn&#39;t always clear to a developer if state should be local to a function, to an instance, or to a class. In Ruby you&#39;ll tend to get a mix of all three in an attempt to build an intuitive DSL, because literally everything is an object and therefore every object can hold state. It&#39;s called an Eigenclass, which is like a class of a class, and every class has one (and is how one instance of a class can mutate the state of every other instance, without knowing about them, by modifying the eigenclass).
</p>

<p>
Speaking of which, Elixir mimics Ruby in its support for DSLs (Domain Specific Languages) too, with a very familiar syntax. The key difference is that Elixir DSLs are compile-time macros and they generate runtime code, whereas Ruby DSLs depend on modifying the runtime by defining objects and methods dynamically.
</p>

<p>
I like this because I don&#39;t need to write a test to confirm that I used a library correctly. Either I used the macro wrong and I get an error from the library, or the generated macro was wrong and I get an error from the compiler. All of this happens at compile time, so I can just focus on writing tests on my actual application logic.
</p>

<p>
The pipeline syntax is nice, but I like Clojure&#39;s &#39;threading&#39; operators a lot. They&#39;re not related to concurrency, you just have two operators: <code>-&gt;</code> is the same as Elixir&#39;s <code>|&gt;</code>, and it inserts the result of the previous expression into the first argument of the next function; <code>-&gt;&gt;</code> in Clojure inserts the same result into the <i>last</i> argument. It seems minor but works great with interop without having to write an anonymous function.
</p>

<p>
I love the <code>with</code> expression, if only because it reminds me of Haskell and Lisp with <code>let</code>, while baking in <code>otherwise</code>. This basically lets you split a complex function in half, with the happy path in the top part and the error handling at the bottom. It works best with a <code>Result</code> tuple because if you can&#39;t pattern match on <code>{:ok, result}</code> then you have a recoverable error.
</p>

<p>
Exceptions, then! In Ruby it&#39;s common to use exceptions for control flow. It often feels cleaner to do that because it&#39;s not common to return explicit error types; usually you either get a successful result or <code>nil</code> or <code>false</code>, and if you&#39;re lucky the error state was actually stored in one of the objects you were using. If you call <code>model.update(params)</code> in Ruby, then it returns <code>false</code> if it fails and updates <code>model.errors</code> with what went wrong. Mutable state.
</p>

<p>
I&#39;m happy to see the <code>Result</code> / <code>Either</code> monad get mainstream traction compared to that. Exceptions for exceptional stuff, and a tuple that gives you <code>ok</code> and <code>error</code> as a return value (or <code>left</code> and <code>right</code> with the <code>Either</code> type).
</p>

<p>
I&#39;ve only scratched the surface really, and I&#39;m sure I&#39;ll have more thoughts as I continue to work, but after 3 months of Elixir I have to say that I <i>genuinely</i> enjoy writing it and it carries Ruby&#39;s torch of programming being fun.
</p>
</div></div>
  </body>
</html>
