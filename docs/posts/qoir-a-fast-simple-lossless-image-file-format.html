<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://nigeltao.github.io/blog/2022/qoir.html">Original</a>
    <h1>QOIR: A fast, simple, lossless image file format</h1>
    
    <div id="readability-page-1" class="page"><div>
      
      
      

      

<p>The <a href="http://qoiformat.org/">QOI lossless image file format</a> was <a href="https://phoboslab.org/log/2021/11/qoi-fast-lossless-image-compression">announced
about a year
ago</a>.
It’s remarkably competitive with the ubiquitous PNG lossless image file format,
in terms of compression ratio, given that the QOI prototype was only <em>300 lines
of C code with no dependencies</em> (except for really basic stdlib things like
<code>malloc</code> and <code>memset</code>). That’s since blown out to <a href="https://github.com/phoboslab/qoi/blob/660839cb/qoi.h">650 lines of
code</a>, although the first
200 of those are comments.</p>

<p>I’ve <a href="https://nigeltao.github.io/blog/2021/json-with-commas-comments.html">previously mentioned</a> the Morris
Principle of software comprehensibility:</p>

<blockquote>
  <p>Software has a Peter Principle. If a piece of code is comprehensible, someone
will extend it, so they can apply it to their own problem. If it’s
incomprehensible, they’ll write their own code instead. Code tends to be
extended to its level of incomprehensibility.</p>
</blockquote>

<p>The QOI code was comprehensible, so I played around with extending it (in an
file format incompatible way) to produce the <strong>QOIR lossless image file
format</strong>.</p>

<p>(I’m <a href="https://github.com/nigeltao/qoi2-bikeshed/issues">not the only one</a> to
extend QOI like this, although e.g.
<a href="https://github.com/MarcioPais/SIF">MarcioPais/SIF</a> does not support images
with an alpha channel. Being limited to fully opaque images is a valid game to
play, but it’s a different game from the one that QOIR is playing.)</p>

<p>Getting back to QOIR, it compresses smaller, encodes faster and decodes faster
than QOI (and, like QOI, decodes much faster than PNG), but it’s also more
complicated than QOI (around 3000 lines of C plus 4000 lines of data tables).</p>

<p>Focusing just on (single-threaded) relative decode speed versus relative
compression ratio, here’s a chart showing a variety of image codecs. See the
<a href="https://github.com/nigeltao/qoir">QOIR GitHub page</a> for more details,
including raw benchmark numbers and reproduction instructions.</p>

<p><img src="https://nigeltao.github.io/blog/2022/qoir.png" alt="QOIR RelDecSpeed vs RelCmpRatio"/></p>

<p>Having done that experiment, though, I learned a couple of things.</p>

<p>One is that, for “maximum 8 bits per channel” <em>lossless</em>, WebP is at a pretty
good place on the “decode speed versus compression ratio” Pareto frontier. It
also has the benefit that caniuse.com reports more than <a href="https://caniuse.com/webp">97% browser
support</a> <em>today</em>. <a href="https://github.com/golang/image/tree/master/vp8l">VP8L is not a complicated
codec</a>. It shouldn’t be that
hard to write a single file C library for decoding WebP lossless. But that
would be another story, for another time.</p>

<p><a href="https://github.com/catid/Zpng">catid/ZPNG</a> is also very simple (around 700
lines of C++ code plus a zstd dependency), and hence extensible, but also on
the Pareto frontier and close to QOIR. It might be interesting to combine it
with other ideas from QOI/QOIR, WebP lossless and elsewhere, and see how far we
can push the frontier out. But that would be another story, for another time.</p>

<h2 id="roll-your-own-format">Roll Your Own Format</h2>

<p>A meta-lesson from QOI (300 lines of code) and ZPNG (700 lines of code plus a
zstd dependency which you can substitute an LZ4 dependency instead) is that
it’s not actually that hard to roll your own image file format, if you care
more about codec speed than compression ratio, or if you have a CPU budget or
code size budget. And you don’t care about interoperability or wider adoption.</p>

<p>For example, if you have a relatively wimpy camera that streams out a 160×120
grayscale image, it might be fun to see how far you can push something like
combining:</p>

<ol>
  <li>Truncating from 8 or more bits per pixel to 6,</li>
  <li>Delta encoding, where <code>encoded(x, y) = original(x, y) - original(x-1, y)</code>,
roughly speaking, and</li>
  <li>LZ4 compression, as an upgrade on basic <a href="https://en.wikipedia.org/wiki/Run-length_encoding">run-length
encoding</a>.</li>
</ol>

<p>That sort of thing might not beat WebP or JPEG-XL <em>in general</em>, but it might be
small enough (in terms of compression), fast enough (encode and decode) and
small enough (in terms of code size) to be useful in some niche circumstances.
Or it could just be a fun and educational afternoon.</p>

<hr/>

<p>Published: 2022-12-05</p>


      
    </div></div>
  </body>
</html>
