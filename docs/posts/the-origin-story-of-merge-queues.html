<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://mergify.com/blog/the-origin-story-of-merge-queues">Original</a>
    <h1>The Origin Story of Merge Queues</h1>
    
    <div id="readability-page-1" class="page"><p data-styles-preset="At_eTy7lJ">From Bors and Homu to Bulldozer, Kodiak, Mergify, and now GitHub and GitLab, merge queues have shaped how we keep main branches green. This article traces their history, why they emerged, and how they became a standard in modern software development.</p><div data-framer-component-type="RichTextContainer"><p>If you use <!--$--><a href="https://github.com" target="_blank" rel="noopener">GitHub</a><!--/$--> or <!--$--><a href="https://gitlab.com" target="_blank" rel="noopener">GitLab</a><!--/$--> today, merge queues feel like a built-in feature of modern development. But their story goes back over a decade, long before &#34;merge queue&#34; was a product term.</p><p>It started with a simple problem: How do you keep your main branch green when dozens of developers are merging code simultaneously? Continuous integration clarified that &#34;just merge and hope&#34; wasn&#39;t good enough. The solution wasn&#39;t a new testing framework but a new workflow.</p><p>From early scripts in the Rust project (Bors, Homu) to <!--$--><a href="https://shopify.engineering/introducing-the-merge-queue" target="_blank" rel="noopener">Shopify&#39;s Shipit</a><!--/$-->, to modern SaaS offerings like Mergify and built-in queues from GitHub and GitLab, merge queues evolved out of necessity. What began as side-project bots has become a standard practice for engineering teams at scale.</p><p>This post walks through that history — the motivations, the people behind it, and how these tools shaped the way we merge code today.</p><h2>The &#34;Not Rocket Science&#34; Rule and Early Experiments</h2><p>The idea of a <em>merge queue</em> – automatically ensuring that a main branch is never broken by merged changes – can be traced back over two decades. In the early 2000s, developer Ben Elliston devised a system of cron jobs, multiple repositories, and a database to <strong>&#34;automatically maintain a repository of code that always passes all the tests&#34;</strong>. This approach, later dubbed the<!--$--><a href="https://graydon.livejournal.com/186550.html" target="_blank" rel="noopener"> <em>&#34;Not Rocket Science Rule of Software Engineering,&#34;</em> </a><!--/$-->kept a known-good code branch for developers and customers, preventing the headaches of broken main builds.</p><p><img alt="" width="688" height="432" src="https://framerusercontent.com/images/HhDOPD7vjfyEMca4z8cbViHM.png?width=1376&amp;height=864" srcset="https://framerusercontent.com/images/HhDOPD7vjfyEMca4z8cbViHM.png?scale-down-to=512&amp;width=1376&amp;height=864 512w,https://framerusercontent.com/images/HhDOPD7vjfyEMca4z8cbViHM.png?scale-down-to=1024&amp;width=1376&amp;height=864 1024w,https://framerusercontent.com/images/HhDOPD7vjfyEMca4z8cbViHM.png?width=1376&amp;height=864 1376w" data-framer-original-sizes="" sizes="(min-width: 1440px) 100vw, (min-width: 1200px) and (max-width: 1439.98px) 100vw, (min-width: 810px) and (max-width: 1199.98px) 100vw, (max-width: 809.98px) 100vw"/></p><p>Fast forward to 2013: Graydon Hoare (creator of the Rust language) faced a similar challenge as Rust&#39;s contributor base grew. Remembering Elliston&#39;s rule, Hoare implemented a small bot named <!--$--><a href="https://github.com/graydon/bors" target="_blank" rel="noopener"><strong>Bors</strong></a><!--/$--> to enforce it. Bors integrated with Rust&#39;s build farm and GitHub: it would monitor pull requests, wait for a reviewer&#39;s &#34;approve&#34; command, <strong>merge the PR into a temporary branch, and run the full test suite</strong>. If tests passed, Bors would fast-forward the main branch to that tested merge commit; if not, it would report the failure and leave the main branch untouched. This ensured that Rust&#39;s master branch was always green (always passing tests). The motivation was to avoid <strong>&#34;merge skew,&#34;</strong> where changes appear compatible when reviewed in isolation but break once merged into an updated main. (A classic example of merge skew is two PRs that individually pass tests – one renames a function, and another adds a call to the old name, resulting in a broken main after sequential merges). By <strong>&#34;testing it first, then promoting it&#34;</strong> to main, Bors kept Rust&#39;s primary branch stable without human intervention to update or revert commits.</p><p>Rust&#39;s experience proved the concept&#39;s value. As Hoare noted, the approach <em>&#34;is not rocket science&#34;</em> – it&#39;s just tedious to do manually, hence ripe for automation. Bors&#39; success meant that by 2014 the Rust and Mozilla Servo projects were using such bots to gate all merges on tests. However, Bors itself was a quick script, and the need for a more extensible solution soon became apparent.</p><h2>Rust&#39;s Homu and the Rise of Merge Bots</h2><p>To build a more general tool, Rust contributor Barosl Lee created <strong>Homu</strong> as a reimplementation and extension of the original Bors bot. Homu was designed to be generic (not Rust-specific) and easier for others to adopt. It implemented the same core idea: maintain a tested integration branch (often called <strong>&#34;auto&#34;</strong>) that includes pending PRs, and only fast-forward <code>main</code> to <code>auto</code> when tests on <code>auto</code> pass. In practice, Homu reversed the usual merge process: instead of merging a PR then testing, it tested the PR <em>before</em> it landed on main by temporarily combining it with the up-to-date main branch. This ensured that <strong>&#34;the main branch is always a copy of </strong><code><strong>auto</strong></code><strong> that passed all tests</strong>, processing approved PRs one at a time in order.</p><p><img alt="" width="688" height="432" src="https://framerusercontent.com/images/V1FQIxaTAaE3NNTqXyNnLjLyYk.png?width=1376&amp;height=864" srcset="https://framerusercontent.com/images/V1FQIxaTAaE3NNTqXyNnLjLyYk.png?scale-down-to=512&amp;width=1376&amp;height=864 512w,https://framerusercontent.com/images/V1FQIxaTAaE3NNTqXyNnLjLyYk.png?scale-down-to=1024&amp;width=1376&amp;height=864 1024w,https://framerusercontent.com/images/V1FQIxaTAaE3NNTqXyNnLjLyYk.png?width=1376&amp;height=864 1376w" data-framer-original-sizes="" sizes="(min-width: 1440px) 100vw, (min-width: 1200px) and (max-width: 1439.98px) 100vw, (min-width: 810px) and (max-width: 1199.98px) 100vw, (max-width: 809.98px) 100vw"/></p><p>Homu was open source and quickly became integral to Rust&#39;s workflow (Rust&#39;s own Homu instance was named &#34;bors&#34;). In 2015, Barosl even launched <strong>Homu as a service (homu.io)</strong>, making it easy for other open-source projects to use a hosted merge queue bot. This service gained users in various communities, demonstrating a broader demand for maintaining green main branches. Homu&#39;s design was language-agnostic, so projects beyond Rust/Servo could adopt it with their CI systems.</p><p>However, by around 2018, the original Homu service began to stagnate. The maintainer stopped updating it, the web frontend&#39;s source was lost, and eventually the <strong>homu.io domain expired</strong>. Some projects (like Rust itself) forked and maintained their own Homu instances, but there was clearly room for a modern replacement. This set the stage for the next evolution of merge queue tools.</p><h2>Bors-NG: Modern Successor to Homu</h2><p>Enter <!--$--><a href="https://github.com/bors-ng/bors-ng" target="_blank" rel="noopener"><strong>Bors-NG</strong></a><!--/$--> (Bors &#34;Next Generation&#34;), created by Michael Howell. Bors-NG was a complete open-source replacement for Homu, first released around 2017. It was built to be faster, more user-friendly, and easier to host, while preserving the same core idea of tested-then-merged pull requests. Unlike homu.io, Bors-NG had no closed-source components – the public instance at <code>app.bors.tech</code> ran the same code that anyone could self-host.</p><p><img alt="" width="688" height="432" src="https://framerusercontent.com/images/MY38f4lm7QS5JlR8vgnjRqFrFhY.png?width=1376&amp;height=864" srcset="https://framerusercontent.com/images/MY38f4lm7QS5JlR8vgnjRqFrFhY.png?scale-down-to=512&amp;width=1376&amp;height=864 512w,https://framerusercontent.com/images/MY38f4lm7QS5JlR8vgnjRqFrFhY.png?scale-down-to=1024&amp;width=1376&amp;height=864 1024w,https://framerusercontent.com/images/MY38f4lm7QS5JlR8vgnjRqFrFhY.png?width=1376&amp;height=864 1376w" data-framer-original-sizes="" sizes="(min-width: 1440px) 100vw, (min-width: 1200px) and (max-width: 1439.98px) 100vw, (min-width: 810px) and (max-width: 1199.98px) 100vw, (max-width: 809.98px) 100vw"/></p><p>Bors-NG quickly became popular, especially for teams on GitHub that needed a merge queue before GitHub offered any native solution. Many saw it as the <em>&#34;</em><!--$--><a href="https://theunixzoo.co.uk/blog/2023-11-16-migrating-to-gh-merge-queues.html" target="_blank" rel="noopener"><em>spiritual successor to Homu, the original Rust merge bot</em></a><!--/$--><em>&#34;</em>. It integrated with GitHub pull requests and CI services, allowing maintainers to use the familiar <code>bors r+</code> command to enqueue PRs for merging once tests pass. For years, this combo of <strong>Bors-NG + CI</strong> filled a critical gap, giving projects large and small a way to avoid merge skew and keep their main branch healthy.</p><p>Notably, the Kubernetes project developed a similar concept in parallel – their <!--$--><a href="https://docs.prow.k8s.io/docs/components/core/tide/" target="_blank" rel="noopener">Prow/Tide</a><!--/$--> system – and other communities like OpenStack had long used a gating bot (<!--$--><a href="https://zuul-ci.org/" target="_blank" rel="noopener">Zuul</a><!--/$-->) for Gerrit. These all share the same philosophy pioneered by Bors. Merge queues became recognized as <em>best practice</em> for high-velocity projects where broken merges are unacceptable.</p><p>By 2023, however, the landscape changed: GitHub announced its own merge queue feature (more on that later). The author of Bors-NG announced <!--$--><a href="https://bors.tech/newsletter/2023/04/30/tmib-76/" target="_blank" rel="noopener">the public Bors-NG service would be <strong>deprecated in favor of GitHub’s native Merge Queue</strong></a><!--/$-->. While Bors-NG remains open source for self-hosters, the availability of an official tool signaled a shift. It was a full-circle moment – a concept that started as a community hack had become mainstream enough for GitHub itself to support it out-of-the-box.</p><h2>Industry Solutions: Bulldozer, Mergify, and Kodiak</h2><p>In parallel to the Rust community&#39;s bots, other engineers and companies were solving the same problem, often &#34;scratching their own itch.&#34; This gave rise to several notable merge automation tools in the late 2010s:</p><ul><li data-preset-tag="p"><p><!--$--><a href="https://github.com/palantir/bulldozer" target="_blank" rel="noopener"><strong>Bulldozer</strong></a><!--/$--><strong> (2017):</strong> Developers at Palantir created Bulldozer as a GitHub App to automate merging and updating PRs. Palantir open-sourced the tool, which could be self-hosted or installed on repos. Bulldozer automatically merges pull requests when all required checks and reviews are satisfied, and it can also auto-update PR branches to keep them in sync with the base branch. Essentially, it removes the manual &#34;update and merge&#34; drudgery in a fast-moving trunk-based development workflow. <!--$--><a href="https://acv.engineering/posts/bulldozer" target="_blank" rel="noopener">An example use case is at ACV Auctions</a><!--/$-->, where engineers adopted Palantir&#39;s Bulldozer to ensure everyone&#39;s feature branch stays up-to-date with <code>main</code> and merges immediately once tests pass (They noted that for public GitHub usage, Bulldozer could be run as a custom instance, as it wasn&#39;t officially listed on the marketplace at the time)</p></li><li data-preset-tag="p"><p><!--$--><a href="https://mergify.com" target="_blank" rel="noopener"><strong>Mergify</strong></a><!--/$--><strong> (2018):</strong> That&#39;s us! Frustration with manual PR management led Julien Danjou and Mehdi Abaakouk to build a small merge automation tool for their team in 2018. That side project struck a chord and soon evolved into <strong>Mergify</strong>, a full-fledged SaaS product and company. Mergify introduced features to <strong>queue, update, and merge PRs</strong> with flexible rules, effectively bringing merge queues to any GitHub repository via a cloud service. The founders (long-time open source contributors) initially open-sourced Mergify&#39;s code and offered it free for OSS projects. Over the years, Mergify became a popular &#34;CI companion&#34; for teams worldwide, offering advanced queue configurations, priority rules, batch merging, and more on top of GitHub&#39;s API. It was essentially <strong>&#34;merge queue as a service,&#34;</strong> well before GitHub&#39;s native feature. (As an aside, <!--$--><a href="https://articles.mergify.com/why-mergify-codebase-isnt-open-source-anymore-a-tale-of-growth-change-and-adaptation/" target="_blank" rel="noopener">Mergify&#39;s engine was eventually made closed-source in 2022</a><!--/$--> as the business matured, but it continues to serve thousands of developers.)</p></li><li data-preset-tag="p"><p><!--$--><a href="https://github.com/chdsbd/kodiak" target="_blank" rel="noopener"><strong>Kodiak</strong></a><!--/$--><strong> (2019):</strong> In early 2019, developer Christopher Blump faced constant delays from having to rebase and update PRs in a busy repo with an always-green main policy. He evaluated existing tools like Bulldozer and others, even contributing a patch, but found <strong>&#34;none of the existing projects… solved the problem of efficiently updating and merging pull requests.&#34;</strong> So during his college finals in May 2019, he built the first version of <strong>Kodiak</strong>. Kodiak is an open-source GitHub App that automates the “update with latest main and merge if tests pass&#34; dance. It introduced a proper queue to merge PRs in order, eliminating the race condition when multiple developers try to merge at once. The initial version was basic (queue in memory, no persistent state) but solved the pain point. By that summer, Kodiak’s usefulness caught on – it got a considerable boost when Vercel’s CEO tweeted about using it to auto-merge and deploy changes. This endorsement in July 2019 brought a wave of adopters, and Kodiak rapidly grew via word-of-mouth in the open-source community. Kodiak added features like configuration files, persistent queues, and GitHub checks for transparency. It became another popular option for teams wanting a hosted merge bot, though it is not actively maintained anymore.</p></li></ul><p><img alt="" width="688" height="432" src="https://framerusercontent.com/images/fUYzKqM4xYFDtpyB4ARAl2Ouf8o.png?width=1376&amp;height=864" srcset="https://framerusercontent.com/images/fUYzKqM4xYFDtpyB4ARAl2Ouf8o.png?scale-down-to=512&amp;width=1376&amp;height=864 512w,https://framerusercontent.com/images/fUYzKqM4xYFDtpyB4ARAl2Ouf8o.png?scale-down-to=1024&amp;width=1376&amp;height=864 1024w,https://framerusercontent.com/images/fUYzKqM4xYFDtpyB4ARAl2Ouf8o.png?width=1376&amp;height=864 1376w" data-framer-original-sizes="" sizes="(min-width: 1440px) 100vw, (min-width: 1200px) and (max-width: 1439.98px) 100vw, (min-width: 810px) and (max-width: 1199.98px) 100vw, (max-width: 809.98px) 100vw"/></p><p>These tools all shared a common purpose: <strong>to safely remove human bottlenecks in merging PRs.</strong> They watched for PRs meeting defined conditions (CI passes, approvals present, specific labels, etc.) and then automatically merged them in a controlled way. Many could also keep branches rebased or updated to prevent stale merges. In effect, they implemented merge queues or <strong>merge trains</strong> outside of the platform – a testament to how universal the need had become by 2018–2019.</p><p>It&#39;s worth noting that GitLab users were also early to this idea: GitLab introduced an official <strong>Merge Trains</strong> feature in mid-2019 (GitLab Premium 12.0) to queue merge requests and run <strong>&#34;pipelines for merge results&#34;</strong> on each in sequence. This was GitLab&#39;s integrated solution to guarantee that each MR is tested with all prior changes before landing, much like Bors/Homu&#39;s approach. Merge Trains made it easy to auto-merge a series of MRs without breaking the target branch, and even supported batching multiple MR commits into one pipeline run for efficiency. In other words, by 2019 the concept of merge queues had leapt from niche bots to <strong>built-in VCS platform features</strong> – at least on GitLab.</p><h2>Internal Merge Queues in Tech Giants</h2><p>Large-scale organizations soon recognized that hand-rolling merge queues was often the only way to keep their main branches stable amid heavy developer activity. <strong>Uber</strong>, for instance, built a system called <!--$--><a href="https://www.uber.com/blog/research/keeping-master-green-at-scale/" target="_blank" rel="noopener"><strong>SubmitQueue</strong></a><!--/$--> to verify and land changes in their monorepo, reducing CI wait times by 74% and dramatically improving merge throughput while keeping the mainline green. <strong>Shopify</strong>, working on a massive Rails-based monolith, added a merge queue into their deployment tool, <!--$--><a href="https://shopify.engineering/introducing-shipit" target="_blank" rel="noopener"><em>Shipit</em></a><!--/$-->, to prevent accidental merges during backlog surges and maintain pipeline reliability. Similarly, <strong>Strava</strong> created an internal tool dubbed <!--$--><a href="https://labs.strava.com/blog/butler-merge-queue-how-strava-merges-code/" target="_blank" rel="noopener"><em>Butler</em></a><!--/$-->, a CI-integrated merge queue that enforces orderly merging for their fast-moving engineering teams.</p><p><img alt="" width="800" height="150" src="https://framerusercontent.com/images/NMy68B5OcwXtlTKMTJNrTQENhxw.png?width=1600&amp;height=300" srcset="https://framerusercontent.com/images/NMy68B5OcwXtlTKMTJNrTQENhxw.png?scale-down-to=512&amp;width=1600&amp;height=300 512w,https://framerusercontent.com/images/NMy68B5OcwXtlTKMTJNrTQENhxw.png?scale-down-to=1024&amp;width=1600&amp;height=300 1024w,https://framerusercontent.com/images/NMy68B5OcwXtlTKMTJNrTQENhxw.png?width=1600&amp;height=300 1600w" data-framer-original-sizes="" sizes="(min-width: 1440px) 100vw, (min-width: 1200px) and (max-width: 1439.98px) 100vw, (min-width: 810px) and (max-width: 1199.98px) 100vw, (max-width: 809.98px) 100vw"/></p><p>At <!--$--><a href="https://shopify.engineering/introducing-the-merge-queue" target="_blank" rel="noopener">Shopify</a><!--/$-->, developers gave positive feedback early on: <em>“By getting automation involved earlier in the pipeline, we were able to take some of the load off our developers, make them happier, and more productive.”</em> In fact, <strong>over 90% of pull requests</strong> to Shopify’s core application now use the <strong>Shipit Merge Queue</strong>. This demonstrates how merge queues aren’t just technical enablers—they improve engineering experience at scale.</p><h2>Mainstream Adoption: GitHub&#39;s Merge Queue</h2><p>Given the success of these systems, it was perhaps only a matter of time before GitHub provided native support. Historically, GitHub&#39;s stance was more manual: they added a basic <strong>&#34;Auto-merge&#34;</strong> option in late 2020 that lets a PR merge after checks pass. However, that still didn&#39;t handle multiple PRs interacting or ensure rebasing. The true paradigm shift came in <strong>2022–2023</strong>.</p><p>GitHub’s own Merge Queue wasn’t born from product planning—it was born from <strong>internal necessity</strong>. By 2016, GitHub engineers were merging nearly <strong>1,000 pull requests per month</strong> into their expansive monorepo. The resulting chaos mandated a smarter system. What emerged was the concept of a <strong>&#34;train&#34; </strong>— a bundle of PRs tested, deployed, and merged together under human orchestration. This was a precursor to today&#39;s fully automated queues. An internal shift began in <strong>2020</strong>, when multiple teams pooled efforts to streamline PR merging across internal projects. By mid-2021, GitHub piloted a merge queue in smaller repos and, by <strong>2023</strong>, had rolled out an internal system powering thousands of merges monthly—cutting average wait times by <strong>33%</strong> and calling the Merge Queue &#34;one of the best quality-of-life improvements&#34; they&#39;d seen</p><p>Then, GitHub decided to release its internal merge queue as part of its product. They began experimenting with a first-party <strong>Pull Request Merge Queue (PRMQ)</strong>. After a closed beta, <strong>in February 2023, GitHub released its merge queue feature in public beta</strong>, and by July 2023,<!--$--><a href="https://github.blog/changelog/2023-07-12-pull-request-merge-queue-is-now-generally-available" target="_blank" rel="noopener"> it was generally available</a><!--/$-->.</p><p>GitHub&#39;s Merge Queue closely mirrors the principles established by Bors and others: it maintains a queue of PRs waiting to merge. It ensures each PR is tested in a merged state (often by creating a temporary merge branch for the PR and running CI) <strong>before</strong> it lands on the base branch. In effect, it automates the formerly tedious process of constantly rebasing or updating PRs and serializing their merges. As GitHub&#39;s announcement put it, developers used to have to update their feature branches one-by-one and re-run CI to avoid breaking main; <strong>&#34;Merge Queue automates this process&#34;</strong> by queuing PRs and testing them with any earlier queued changes. The result is higher velocity and confidence that incompatible changes never break the default branch.</p><p><img alt="" width="688" height="432" src="https://framerusercontent.com/images/6K6xHV41oz3TJJ5cNvPYPyaXydc.png?width=1376&amp;height=864" srcset="https://framerusercontent.com/images/6K6xHV41oz3TJJ5cNvPYPyaXydc.png?scale-down-to=512&amp;width=1376&amp;height=864 512w,https://framerusercontent.com/images/6K6xHV41oz3TJJ5cNvPYPyaXydc.png?scale-down-to=1024&amp;width=1376&amp;height=864 1024w,https://framerusercontent.com/images/6K6xHV41oz3TJJ5cNvPYPyaXydc.png?width=1376&amp;height=864 1376w" data-framer-original-sizes="" sizes="(min-width: 1440px) 100vw, (min-width: 1200px) and (max-width: 1439.98px) 100vw, (min-width: 810px) and (max-width: 1199.98px) 100vw, (max-width: 809.98px) 100vw"/></p><p>The introduction of GitHub&#39;s own merge queue was a watershed moment. It validated the approach pioneered by community tools and brought it to a much broader audience. Organizations on GitHub Enterprise Cloud or public open-source projects can now simply toggle on a merge queue in settings, without needing an external bot. The impact was immediately felt: maintainers of Bors-NG announced the phase-out of their hosted service in favor of GitHub&#39;s queue, and guidelines for migrating from Bors to GH Merge Queue emerged. Essentially, the ecosystem came full circle – what started as a custom script to enforce an &#34;always-green&#34; rule evolved into a standard platform feature.</p><p>It&#39;s important to note that GitHub&#39;s initial implementation has some differences in workflow. For example, GH Merge Queue uses a two-phase testing approach (one run on the PR itself, and a second run after queueing when merged into a temporary branch) whereas tools like Bors performed a single integrated test cycle. There are also limitations: among others, GitHub&#39;s queue is FIFO only (no priority reordering) and lacks batch merging capabilities. Third-party services like Mergify have pointed out these gaps quickly, since their products offer more advanced queue configurations (multiple queues, priority rules, batching to merge several PRs at once, etc.). In fact, even after GitHub&#39;s native queue launch, some teams continued to use or switch to tools like Mergify or others for more flexibility. Nonetheless, the core need is now officially recognized and supported by GitHub, a significant milestone in the history of merge queues.</p><h2>Conclusion: From Niche Scripts to Essential Workflow</h2><p>In a little over a decade, merge queue systems have gone from an obscure hack to <strong>an essential part of modern software delivery</strong>. The progression tells a story of increasing scale and quality demands:</p><ul><li data-preset-tag="p"><p><strong>Early 2010s:</strong> Only very large or risk-averse projects (like Rust, Servo, or OpenStack) felt the pain strongly enough to build bespoke solutions (Bors, Homu, Zuul) to guarantee unbreakable main branches. These were novel, community-driven efforts born out of necessity – enforcing the &#34;always passes all tests&#34; rule that was known but rarely automated.</p></li><li data-preset-tag="p"><p><strong>Late 2010s:</strong> As continuous integration became ubiquitous and teams adopted trunk-based development, the <em>merge skew</em> problem became more common across the industry. This spurred a wave of tools – some open-source, some commercial – to automate PR merging (Bulldozer, Mergify, Kodiak, and others). They enabled even smaller teams to achieve what only giants could before: continuously integrating code without constantly babysitting CI or worrying about conflicting changes. The fact that a lone developer could write Kodiak in a weekend to solve his team&#39;s annoyance, and that it immediately found a user base, speaks to how widespread the need had become.</p></li><li data-preset-tag="p"><p><strong>2020s:</strong> Merge queues became mainstream best practice. Platform support (GitLab&#39;s Merge Trains, GitHub&#39;s Merge Queue) lowered the barrier to adoption. Today, even teams that never heard of &#34;bors&#34; or &#34;homu&#34; are benefiting from the lessons those tools taught. On GitHub, you can simply enable a branch protection that uses a merge queue, and achieve the same guarantee that <strong>“the main branch is never broken by incompatible changes.”</strong> The ecosystem around merge automation is still evolving – with third-party services pushing the envelope on features – but the fundamental approach is here to stay.</p></li></ul><p><img alt="" width="688" height="432" src="https://framerusercontent.com/images/gOhfVlBS6yDyn05xkyBCQJZr4g.png?width=1376&amp;height=864" srcset="https://framerusercontent.com/images/gOhfVlBS6yDyn05xkyBCQJZr4g.png?scale-down-to=512&amp;width=1376&amp;height=864 512w,https://framerusercontent.com/images/gOhfVlBS6yDyn05xkyBCQJZr4g.png?scale-down-to=1024&amp;width=1376&amp;height=864 1024w,https://framerusercontent.com/images/gOhfVlBS6yDyn05xkyBCQJZr4g.png?width=1376&amp;height=864 1376w" data-framer-original-sizes="" sizes="(min-width: 1440px) 100vw, (min-width: 1200px) and (max-width: 1439.98px) 100vw, (min-width: 810px) and (max-width: 1199.98px) 100vw, (max-width: 809.98px) 100vw"/></p><p>In an academic sense, it&#39;s fascinating how a principle from the early 2000s configuration management became a pillar of modern DevOps. The story of merge queue systems is one of <strong>increasing automation to support software quality at scale</strong>. By eliminating the integration risk of each incremental change, developers can move faster without fear.</p><p>What began as Graydon Hoare&#39;s small Rust bot named after a knight (Bors) has grown into a standard tool in software teams&#39; arsenal, ensuring that code integration is <em>&#34;not rocket science&#34;</em> but a well-engineered process. Merge queues have evolved from niche hacks into an industry standard—because as PR velocity increased, they weren&#39;t a luxury, they became an operational necessity.</p></div></div>
  </body>
</html>
