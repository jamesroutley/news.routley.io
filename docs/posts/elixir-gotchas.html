<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://pragtob.wordpress.com/2024/05/01/10-elixir-gotchas/">Original</a>
    <h1>Elixir Gotchas</h1>
    
    <div id="readability-page-1" class="page"><article id="post-3769">
	<!-- .entry-header -->

	<div>
		
<p>No, I‚Äôve not gone to the click-baiters (‚Äú10 tips that will change your life today!!!‚Äù), but I chose to limit myself to just 10 so that I don‚Äôt pull what is considered a ‚ÄúTobi‚Äù and spend days writing a blog post so huge no one wants to read it anyhow. I‚Äôll write a follow-up post with more üôÇ</p>



<p>Anyhow, what are <strong>‚Äúgotchas‚Äù</strong>? For this purpose I‚Äôd define them as ‚Äú<strong>slightly confusing or irritating behavior, prone to lead to errors especially when you‚Äôre new to Elixir</strong>‚Äú. There are good reasons for many of these, however some of them are also more arcane. Running on the great basis that <a href="https://www.erlang.org/">Erlang</a> built is probably Elixir‚Äôs biggest asset ‚Äì it gives us a lot of functionality and properties that helps Elixir thrive especially in the modern multi-core and multi-node environment. However, Erlang also comes with its fair share of baggage as a programming language conceived almost 40 years ago. Erlang‚Äôs focus on backwards compatibility also means many of these decisions still live on today.</p>



<p>The list is brought to you by:</p>



<ol>
<li>My own experience learning Elixir</li>



<li>Me teaching Elixir to folks both at Liefery and at Remote over the years</li>



<li>Horrifying discoveries in production code</li>
</ol>



<p>Apologies for the lack of syntax highlighting, but wordpress borked the last way that was working for elixir and I didn‚Äôt want to yak shave this too far. I hope that you can sill enjoy them and may learn from them!</p>



<h2>1. A list of numbers becomes text in iex</h2>



<figure><a href="https://pragtob.wordpress.com/wp-content/uploads/2024/05/image.png"><img data-attachment-id="3822" data-permalink="https://pragtob.wordpress.com/2024/05/01/10-elixir-gotchas/image/" data-orig-file="https://pragtob.wordpress.com/wp-content/uploads/2024/05/image.png" data-orig-size="325,55" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image" data-image-description="" data-image-caption="" data-medium-file="https://pragtob.wordpress.com/wp-content/uploads/2024/05/image.png?w=300" data-large-file="https://pragtob.wordpress.com/wp-content/uploads/2024/05/image.png?w=325" tabindex="0" role="button" width="325" height="55" src="https://pragtob.wordpress.com/wp-content/uploads/2024/05/image.png?w=325" alt="" srcset="https://pragtob.wordpress.com/wp-content/uploads/2024/05/image.png 325w, https://pragtob.wordpress.com/wp-content/uploads/2024/05/image.png?w=150 150w, https://pragtob.wordpress.com/wp-content/uploads/2024/05/image.png?w=300 300w" sizes="(max-width: 325px) 100vw, 325px"/></a></figure>



<p>Let‚Äôs start with an oldie but goldie that pretty much every beginner book tells you about: <strong>Why does this random list of integers print out as text?</strong></p>


<div><pre title="">iex&gt; [69, 108, 105, 120, 105, 114]
~c&#34;Elixir&#34;
</pre></div>


<p>This is because <a href="https://hexdocs.pm/elixir/1.16.2/binaries-strings-and-charlists.html#charlists">charlists</a>, denoted by <code>~c&#34;text&#34;</code> or <code>&#39;text&#39;</code>, are actually just that ‚Äì a <strong>list of integers</strong>. So <code>iex</code> literally can‚Äôt tell the difference and does its own best guess work: it checks if the integers are in a range between 0 and 127 and will then print it as text.</p>



<p>You can also show that it literally is a list by using <code>Enum</code> functions on it:</p>


<div><pre title="">iex&gt; Enum.map(~c&#34;elixir&#34;, fn integer -&gt; integer + 100 end)
[201, 208, 205, 220, 205, 214]
iex&gt; Enum.map(~c&#34;elixir&#34;, fn integer -&gt; integer - 32 end)
~c&#34;ELIXIR&#34;
</pre></div>


<p>The first line changes the integers to be outside of the printable range with +100 so <code>iex</code> prints it as a list of integers again. The second one just uses the knowledge that the difference between lower case and upper case letters in ASCII is 32 to transform it.</p>



<h2>2. Charlists vs. Strings</h2>



<p>All this brings us to the following questions: <strong>Why do we even have charlists and strings in elixir?</strong> What‚Äôs the difference between them? When do I use which one? Great question! It‚Äôs a source of a lot of confusion, esp. since <strong>in most languages single and double-quoted strings only sport minor differences</strong> ‚Äì in Elixir they are backed by entirely different data structures. While single-quoted strings are just a list of integers, <strong>double-quoted strings are UTF-8 encoded binaries</strong> and so resemble strings you are used to in most modern programming languages.</p>



<p><strong>As a rule of thumb, use strings aka double-quotes (<code>&#34;string&#34;)</code></strong>. The major use case for charlists / <code>&#39;charlists&#39;</code>/<code>~c&#34;charlists&#34;</code> is interfacing with erlang or erlang libraries. Or in the words of the <a href="https://hexdocs.pm/elixir/binaries-strings-and-charlists.html#charlists">documentation</a>:</p>



<blockquote>
<p>In practice, you will not come across them often, only in specific scenarios such as interfacing with older Erlang libraries that do not accept binaries as arguments.</p>
</blockquote>



<p>The other mystery here are the 2 different syntaxes in use for charlists ‚Äì single quotes (<code>&#39;charlist&#39;</code>) vs. the <code>~c&#34;charlist&#34;</code> sigil. That‚Äôs a rather recent development, it was changed in <a href="https://hexdocs.pm/elixir/1.15/changelog.html#1-enhancements-4">Elixir 1.15</a>, after <a href="https://elixirforum.com/t/convert-charlists-into-c-charlists/49455">some discussion</a>. The reason for this is what I mentioned initially ‚Äì it caused a lot of confusion:</p>



<blockquote>
<p>In many languages, <code>&#39;foobar&#39;</code> is equivalent to <code>&#34;foobar&#34;</code>, that‚Äôs not the case in Elixir and we believe it leads to confusion.</p>
</blockquote>



<p>So, it‚Äôs now less confusing but still confusing ‚Äì which is why it made this list.</p>



<h2>3. <code>%{}</code> matches any Map</h2>



<p>Pattern matching is one of Elixir‚Äôs chief features! You can see it utilized frequently, for instance in a recursive function where we want to end recursion on empty list:</p>


<div><pre title="">def list([]) do
  IO.puts(&#34;list is empty&#34;)
end
</pre></div>


<p>That works flawlessly, however <strong>if you try the same with a map it‚Äôll always match</strong> ‚Äì no matter the map:</p>


<div><pre title="">def map(%{}) do
  IO.puts(&#34;Empty map or is it?&#34;)
end
</pre></div>

<div><pre title="">iex&gt; map(%{not: &#34;empty&#34;})
Empty map or is it?
</pre></div>


<p>The reason is simple ‚Äì pattern matches on lists and maps just work different. In a list we‚Äôre looking for an exact match of the elements, whereas for maps it is basically checked if the structure is included:</p>


<div><pre title="">iex&gt; [a, b, c] = [1, 2, 3]
[1, 2, 3]
iex&gt; [a, b, c] = [1, 2, 3, 4]
** (MatchError) no match of right hand side value: [1, 2, 3, 4]
iex&gt; [] = [1, 2, 3]
** (MatchError) no match of right hand side value: [1, 2, 3]
iex&gt; %{action: action} = %{action: &#34;learn&#34;}
%{action: &#34;learn&#34;}
iex&gt; %{action: action} = %{action: &#34;learn&#34;, more: &#34;can be&#34;, provided: true}
%{
  more: &#34;can be&#34;,
  action: &#34;learn&#34;,
  provided: true
}
iex&gt; %{} = %{action: &#34;learn&#34;, more: &#34;can be&#34;, provided: true}
%{
  more: &#34;can be&#34;,
  action: &#34;learn&#34;,
  provided: true
}
iex&gt; %{action: action} = %{no_action: &#34;sad&#34;}
** (MatchError) no match of right hand side value: %{no_action: &#34;sad&#34;}
</pre></div>


<p>If you do want to execute a function only when given an empty map you can <strong>use either of the following guards: <code>map_size(map) == 0</code> or <code>map == %{}</code></strong> ‚Äì which also showcases the difference between the match <code>(=)</code> and equality (<code>==</code>) operators. One full example from <a href="https://hexdocs.pm/elixir/1.16.2/patterns-and-guards.html#why-guards">the docs</a>:</p>


<div><pre title="">def empty_map?(map) when map_size(map) == 0, do: true
def empty_map?(map) when is_map(map), do: false
</pre></div>


<h2>4. Structs are Maps</h2>



<p>While we‚Äôre in the topic of maps let‚Äôs talk about structs! We can easily create and use a struct:</p>


<div><pre title="">iex&gt; defmodule Human do
...&gt; defstruct [:name, :age]
...&gt; end
iex&gt; tobi = %Human{name: &#34;Tobi&#34;, age: 34}
%Human{name: &#34;Tobi&#34;, age: 34}
</pre></div>


<p>It gets more interesting around pattern matching again, let‚Äôs try <code>%{}</code> from the previous section:</p>


<div><pre title="">iex&gt; %{} = %Human{name: &#34;Tobi&#34;, age: 34}
%Human{name: &#34;Tobi&#34;, age: 34}
iex&gt; is_map(%Human{name: &#34;Tobi&#34;, age: 34})
true
</pre></div>


<p>It matches and it is a map! <strong>Structs are nothing more than special maps with a <code>__struct__</code> key</strong> that tells it which struct it is. It gets even weirder when you know that some of the built-in data types are structs and hence maps:</p>


<div><pre title="">iex&gt; is_map(1..10)
true
iex&gt; is_map(Date.utc_today())
true
iex&gt; is_map(~r/elixir/)
true
</pre></div>


<p>We can see their map nature more easily in an example! With a bit of meddling we can also tell <code>IO.inspect</code> to not print a prettified version showing us the real map underneath:</p>


<div><pre title="">iex&gt; tobi = %Human{name: &#34;Tobi&#34;, age: 34}
%Human{name: &#34;Tobi&#34;, age: 34}
iex&gt; tobi.__struct__
Human
iex&gt; Map.keys(tobi)
[:name, :__struct__, :age]
iex&gt; Map.values(tobi)
[&#34;Tobi&#34;, Human, 34]
iex&gt; IO.inspect(tobi, structs: false)
%{name: &#34;Tobi&#34;, __struct__: Human, age: 34}
%Human{name: &#34;Tobi&#34;, age: 34}
iex&gt; IO.inspect(1..10, structs: false)
%{first: 1, last: 10, step: 1, __struct__: Range}
1..10
</pre></div>


<p>Now, you might think this all doesn‚Äôt matter too much. But it does! Be aware that <strong>every pattern match on a map might also match on a struct with the same keys, so will every <code>is_map</code> check</strong>. And yes, dates and ranges may match as well as shown above:</p>


<div><pre title="">iex&gt; %{first: number} = 1..10
1..10
iex&gt; number
1
</pre></div>


<p>I have seen bugs in code that first matched on something being a map and only later matched on specific structs. So, instead of the struct specific code the more general map code was run ‚Äì and hence another hard to track down bug was born.</p>



<p>In order to combat this, the Elixir team i<a href="https://github.com/elixir-lang/elixir/pull/13534">ntroduced a new <code>is_non_struct_map/1</code> guard</a>.</p>



<h2>5. Structs don‚Äôt implement Access</h2>



<p>So, I just told you that structs are just maps. But then you try to use random key access via <code>[]</code> on them and you are confused again:</p>


<div><pre title="">iex(18)&gt; tobi[:age]
** (UndefinedFunctionError) function Human.fetch/2 is undefined (Human does not implement the Access behaviour

You can use the &#34;struct.field&#34; syntax to access struct fields. You can also use Access.key!/1 to access struct fields dynamically inside get_in/put_in/update_in)
    Human.fetch(%Human{name: &#34;Tobi&#34;, age: 34}, :age)
    (elixir 1.16.0-rc.1) lib/access.ex:309: Access.get/3
    iex:18: (file)
iex(18)&gt; tobi.age
34
iex(19)&gt; map_tobi = %{name: &#34;Tobi&#34;, age: 34}
%{name: &#34;Tobi&#34;, age: 34}
iex(20)&gt; map_tobi[:age]
34
iex(21)&gt; map_tobi.age
34
</pre></div>


<p>As usual, elixir is amazing and already tells us that the problem is that the struct doesn‚Äôt implement the <a href="https://hexdocs.pm/elixir/main/Access.html">Access behaviour</a>. <strong>As structs have predefined keys, you should use the  dot-syntax of <code>struct.key</code> to access them.</strong> However, since sometimes you do still want to randomly access struct keys you can use the fact that structs are still just maps to your advantage using functions like <a href="https://hexdocs.pm/elixir/1.16/Map.html#get/3"><code>Map.get/</code>3</a>:</p>


<div><pre title="">iex(22)&gt; attribute = :age
:age
iex(23)&gt; Map.get(tobi, attribute)
34
</pre></div>


<p>You can also take it further than that and use <code><a href="https://hexdocs.pm/elixir/main/Kernel.html#get_in/2">get_in/2</a></code>. It doesn‚Äôt work in a plain attempt, but can work thanks to <code><a href="https://hexdocs.pm/elixir/1.16.2/Access.html#key/2">Access.key/2</a></code>:</p>


<div><pre title="">iex(25)&gt; get_in(tobi, [attribute])
** (UndefinedFunctionError) function Human.fetch/2 is undefined (Human does not implement the Access behaviour
# etc....
iex(25)&gt; get_in(tobi, [Access.key(attribute)])
34
</pre></div>


<p>Be mindful to only use these if you really do need random key access on structs. Otherwise there are <a href="https://hexdocs.pm/elixir/main/Kernel.html#get_in/2-working-with-structs">many other ways</a>, such as good old plain dot-based access or pattern matching even.</p>



<h2>6. Keyword lists are a bit awkward as options and in pattern matches</h2>



<p>Another somewhat special data structure in elixir are <a href="https://hexdocs.pm/elixir/main/keywords-and-maps.html#keyword-lists">keyword lists</a>. Again, these are backed by ‚Äúsyntactic sugar‚Äù on top of lists. A keyword list is a list of 2 element tuples, where the first element is an atom. </p>


<div><pre title="">iex&gt; [{:option, true}] == [option: true]
true
</pre></div>


<p>When you call functions with keywordlists as the last argument you can even omit the brackets as seen before when we wrote <code>IO.inspect(tobi, structs: false)</code> ‚Äì <code>structs: false</code> is a keyword list here. These properties make it the default data structure for passing along options to functions in Elixir.</p>



<p>However, since it‚Äôs a list the order matters here (and keys can be duplicated!) which often isn‚Äôt what you want for options: order usually doesn‚Äôt matter and duplicated options should not be a thing. It‚Äôs great for DSLs such as <a href="https://github.com/elixir-ecto/ecto">ecto</a>, but when used as options it means it‚Äôs hard to pattern match on them. Let‚Äôs check out the following function:</p>


<div><pre title="">def option(warning: true) do
  IO.puts &#34;warning!&#34;
end

def option(_anything) do
  IO.puts &#34;No warning!&#34;
end
</pre></div>


<p>It only matches when our options are <strong>exactly</strong> <code>warning: true</code> ‚Äì any additional data makes it a different list and hence fails the pattern match:</p>


<div><pre title="">iex&gt; option warning: true
warning!
iex&gt; option warning: true, more: true
No warning!
iex&gt; option more: true, warning: true
No warning!
</pre></div>


<p>It‚Äôs an issue<a href="https://elixirforum.com/t/passing-in-options-maps-vs-keyword-lists/1963"> I struggled with early in my Elixir days</a>. There are plenty of solutions for this. What I do in <a href="https://github.com/bencheeorg/benchee">benchee</a> is accept the options as a keyword list but <strong>internally convert it to a map</strong> (well, actually a struct even!). So, internally I can work with a nice structure that is easy to pattern match, but preserves the nice &amp; idiomatic interface.</p>



<p>You can also use <code><a href="https://hexdocs.pm/elixir/main/Keyword.html#get/3">Keyword.get/3</a></code> to get the value of whatever option you‚Äôre looking for. You can also use <code><a href="https://hexdocs.pm/elixir/1.16.2/Keyword.html#validate/2">Keyword.validate/2</a></code> to make sure only well known options are supplied and that you provide good defaults ‚Äì <a href="https://www.linkedin.com/feed/update/urn:li:activity:7191447313477718016?commentUrn=urn%3Ali%3Acomment%3A%28activity%3A7191447313477718016%2C7191455673849671680%29&amp;dashCommentUrn=urn%3Ali%3Afsd_comment%3A%287191455673849671680%2Curn%3Ali%3Aactivity%3A7191447313477718016%29">hat tip to Vinicius</a>.</p>



<h2>7. Everything can be compared to Everything</h2>



<p>Another surprise might be that <strong>you can compare literally every elixir term with one another</strong> without raising an exception:</p>


<div><pre title="">iex&gt; nil &lt; 8
false
iex&gt; 8 &lt; &#34;hello&#34;
true
iex&gt; {1, 2} &lt; [&#34;a&#34;]
true
</pre></div>


<p>Most people would probably expect this to raise an error as it does in many other languages. It doesn‚Äôt, as Elixir does <a href="https://hexdocs.pm/elixir/main/Kernel.html#module-structural-comparison">structural comparisons</a> and follows <strong>Erlang‚Äôs <a href="https://hexdocs.pm/elixir/main/Kernel.html#module-term-ordering">term ordering</a></strong> which basically gives all terms a predetermined order:</p>



<p><code>number &lt; atom &lt; reference &lt; function &lt; port &lt; pid &lt; tuple &lt; map &lt; list &lt; bitstring</code></p>



<p>Why is it done like this?</p>



<blockquote>
<p>This means <strong>comparisons in Elixir are structural</strong>, as it has the goal of comparing data types as efficiently as possible to create flexible and performant data structures.</p>
</blockquote>



<p>All in all being able to compare everything to everything may sound mildly annoying but can also lead to some really bad bugs. In a conditional, this will just silently run the wrong code:</p>


<div><pre title="">iex&gt; maximum = &#34;100&#34; # forgot to parse
&#34;100&#34;
iex&gt; if 9999 &lt; maximum, do: &#34;you pass&#34;
&#34;you pass&#34;
</pre></div>


<p>I have seen similar bugs in production code bases, esp. since <code>nil</code> also doesn‚Äôt raise and is more likely to slip through. Thankfully, if you try to compare structs elixir issues a warning these days:</p>


<div><pre title="">iex&gt; %Human{} &gt; nil
warning: invalid comparison with struct literal %Human{}. Comparison operators (&gt;, &lt;, &gt;=, &lt;=, min, and max) perform structural and not semantic comparison. Comparing with a struct literal is unlikely to give a meaningful result. Struct modules typically define a compare/2 function that can be used for semantic comparison
‚îî‚îÄ iex:6

true
</pre></div>


<p>It‚Äôs note-worthy that this gotcha and the next one are currently <a href="https://twitter.com/josevalim/status/1785989792141890015">already being addressed at Elixir targeted for the 1.17 release</a>, thanks to the introduction of the type system. Beyond that, <a href="https://github.com/sabiwara/cmp">sabiwara also wrote the micro library <code>cmp</code> to take care of the problem</a>.</p>



<h2>8. Proper Date comparisons</h2>



<p>Speaking of which, how do you compare dates?</p>


<div><pre title="">iex(18)&gt; ~D[2024-05-01] &gt; ~D[2024-05-02]
warning: invalid comparison with struct literal ~D[2024-05-01]. Comparison operators (&gt;, &lt;, &gt;=, &lt;=, min, and max) perform structural and not semantic comparison. Comparing with a struct literal is unlikely to give a meaningful result. Struct modules typically define a compare/2 function that can be used for semantic comparison
‚îî‚îÄ iex:18
false
</pre></div>


<p>Whoops, there is that warning again! Obviously, we shouldn‚Äôt compare them like this ‚Äì but it still works, and <strong>might even produce the correct result by accident slipping through tests</strong>!</p>



<p>The correct way to <a href="https://hexdocs.pm/elixir/1.16.2/Date.html#module-comparing-dates">compare dates</a> is <code><a href="https://hexdocs.pm/elixir/1.16.2/Date.html#compare/2">Date.compare/2</a></code> and friends:</p>


<div><pre title="">iex&gt; Date.compare(~D[2024-05-01], ~D[2024-05-02])
:lt
</pre></div>


<p>Again, you may be surprised how often this has snuck past someone.</p>



<h2><code>9. nil[&#34;something&#34;]</code> is valid and returns <code>nil</code></h2>



<p>Another surprise may be this:</p>


<div><pre title="">iex&gt; nil[&#34;something&#34;]
nil
</pre></div>


<p>Of course, you‚Äôd never write it like this but if a <code>nil</code> value had gotten past you and was in your <code>map</code> variable there‚Äôd be no way to tell:</p>


<div><pre title="">iex&gt; map = nil
nil
iex&gt; map[&#34;something&#34;]
nil
</pre></div>


<p>Which, can be very dangerous. Why is it like this? So that you can use <code>[]</code> to safely access nested values:</p>


<div><pre title="">iex&gt; map = %{a: %{b: :c}}
%{a: %{b: :c}}
iex&gt; map[:a][:b]
:c
iex&gt; map[:d][:b]
nil
</pre></div>


<p>In that last example <code>map[:d]</code> returns <code>nil</code> and then <code>nil[:b]</code> evaluates to <code>nil</code> again without crashing. If you wanted to assure that the keys are there, you got a lot of possibilities but one of them is pattern matching:</p>


<div><pre title="">iex&gt; %{a: %{b: value}} = map
%{a: %{b: :c}}
iex&gt; value
:c
iex&gt; %{d: %{b: value}} = map
** (MatchError) no match of right hand side value: %{a: %{b: :c}}
</pre></div>


<h2>10. How to use constants</h2>



<p>Another question that‚Äôs common among Elixir newcomers is: ‚ÄúCool, so how do I define constants?‚Äù and the answer is‚Ä¶ there are no real constants in Elixir/Erlang. The best workaround we have are <a href="https://hexdocs.pm/elixir/1.16.2/module-attributes.html#as-constants">module attributes</a>. However, they are not visible to the outside by default so you have to provide a function to access them:</p>


<div><pre title="">defmodule Constants do
  @my_constant &#34;super constant&#34;
  def my_constant do
    @my_constant
  end
end
</pre></div>

<div><pre title="">iex&gt; Constants.my_constant()
&#34;super constant&#34;
</pre></div>


<p>That works, however one unfortunate thing about module attributes is that they aren‚Äôt‚Ä¶ <strong>you know, truly constant.</strong> You can redefine a module attribute later on in a module without any warning and if you then use it again below the new definition ‚Äì with its value will have changed:</p>


<div><pre title="">defmodule Constants do
  @my_constant &#34;super constant&#34;
  def my_constant do
    @my_constant
  end

  @my_constant &#34;ch-ch-changes!&#34;
  def my_constant_again do
    @my_constant
  end
end
</pre></div>

<div><pre title="">iex&gt; Constants.my_constant_again()
&#34;ch-ch-changes!&#34;
iex&gt; Constants.my_constant()
&#34;super constant&#34;
</pre></div>


<p>Interestingly, the <strong>value is <em>not</em> changed retroactively</strong> so <code>my_constant/0</code> still returns the original value (and is a true constant in that sense). But it <em>can</em> change throughout the module, which is necessary for other use cases of module attributes. So, if you accesses it in a function and someone happened to define it again with a newer value above, you may be in for a bad time.</p>



<p>Hence, I whole-heartedly agree with my friend Micha≈Ç here:</p>



<figure><div>
<div><blockquote data-width="550" data-dnt="true"><p lang="en" dir="ltr">We need proper first-class constants in Erlang that a module can define</p>‚Äî Micha≈Ç Muska≈Ça (@michalmuskala) <a href="https://twitter.com/michalmuskala/status/1785313458470191559?ref_src=twsrc%5Etfw">April 30, 2024</a></blockquote></div>
</div></figure>



<p>It‚Äôs also worth nothing that you don‚Äôt <em>need</em> module attributes ‚Äì you can also just define a function that returns a constant value:</p>


<div><pre title="">def my_other_constant do
  &#34;This is cool as well&#34;
end
</pre></div>


<p>In many cases, the compiler is smart enough to realize it‚Äôs a constant value (even with some operations applied) and so you won‚Äôt suffer a performance penalty for this. However, there are cases where it doesn‚Äôt work (f.ex. reading a file) and certain <a href="https://hexdocs.pm/elixir/1.16.2/patterns-and-guards.html#guards">guards</a> require module attributes (f.ex. around enum checking). Hat tip to <a href="https://twitter.com/josevalim/status/1785781791682372044">discussing this with Jos√©</a>.</p>



<p>To help with this, <a href="https://github.com/hauleth/defconst">hauleth has also created a new miny library called <code>defconst</code></a>.</p>



<h2>Closing</h2>



<p>Hope you enjoyed these gotchas and they helped you! What gotchas are missing? Let me know in the comments or elsewhere and I‚Äôll try to cover them in future editions ‚Äì I still got ~10 on my TODO list so far though üòÖ</p>



<p>It‚Äôs also worth mentioning that Elixir is well aware of a lot of these ‚Äì if you follow the links I posted, they will frequently send you to Elixir‚Äôs own documentation explaining these. From the early days, there have also already been quite some improvements and more warnings emitted to help you. As <strong>Elixir is amazing, and cares a lot about the developer experience</strong>.</p>



<p>If you enjoyed this post and think ‚ÄúWorking with Tobi may be cool!‚Äù ‚Äì you‚Äôre in luck as <a href="https://pragtob.wordpress.com/2024/04/08/looking-for-a-job-2/"><strong>I‚Äôm still looking for a job</strong></a> ‚Äì so give me a shout, will ya? üíö</p>



<p>Update 1 (2024-05-02): </p>



<ul>
<li>Extended on using just functions as constant after <a href="https://twitter.com/josevalim/status/1785781791682372044">discussion with Jos√©</a>.</li>



<li><a href="https://twitter.com/josevalim/status/1785989792141890015">Recent advancements for more warnings, again by Jos√©.</a></li>



<li>Point to <code>Keyword.validate/</code>2 <a href="https://www.linkedin.com/feed/update/urn:li:activity:7191447313477718016?commentUrn=urn%3Ali%3Acomment%3A%28activity%3A7191447313477718016%2C7191455673849671680%29&amp;dashCommentUrn=urn%3Ali%3Afsd_comment%3A%287191455673849671680%2Curn%3Ali%3Aactivity%3A7191447313477718016%29">thanks to Vinicius</a>.</li>
</ul>



<p>Update 2 (2024-05-04)</p>



<ul>
<li><a href="https://elixirforum.com/t/blog-post-10-elixir-gotchas/63278/30?u=pragtob">Jos√© pointed out why structural comparison/term ordering are a thing</a></li>



<li>Clarify that the changing nature of module attributes has a reason</li>



<li>Mention <code><a href="https://github.com/hauleth/defconst">defconst</a></code></li>
</ul>



<p>Update 3 (2024-05-11)</p>



<ul>
<li>A new <a href="https://github.com/elixir-lang/elixir/pull/13534"><code>is_non_struct_map/1</code> guard was added to Elixir</a>!</li>



<li>Mention <code><a href="https://github.com/sabiwara/cmp">cmp</a></code></li>
</ul>




			</div><!-- .entry-content -->

	<!-- .entry-footer -->
</article></div>
  </body>
</html>
