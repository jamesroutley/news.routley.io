<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.sqlite.org/cgi/src/doc/wal2/doc/wal2.md">Original</a>
    <h1>SQLite: Wal2 Mode</h1>
    
    <div id="readability-page-1" class="page"><div>

<h2>Activating/Deactivating Wal2 Mode</h2>
<p>&#34;Wal2&#34; mode is very similar to &#34;wal&#34; mode. To change a database to wal2 mode,
use the command:</p>

<blockquote>
<pre><code> PRAGMA journal_mode = wal2;
</code></pre>
</blockquote>

<p>It is not possible to change a database directly from &#34;wal&#34; mode to &#34;wal2&#34;
mode. Instead, it must first be changed to rollback mode. So, to change a wal
mode database to wal2 mode, the following two commands may be used:</p>

<blockquote>
<pre><code> PRAGMA journal_mode = delete;
 PRAGMA journal_mode = wal2;
</code></pre>
</blockquote>

<p>A database in wal2 mode may only be accessed by versions of SQLite compiled
from this branch. Attempting to use any other version of SQLite results in an
SQLITE_NOTADB error. A wal2 mode database may be changed back to rollback mode
(making it accessible by all versions of SQLite) using:</p>

<blockquote>
<pre><code> PRAGMA journal_mode = delete;
</code></pre>
</blockquote>

<h2>The Advantage of Wal2 Mode</h2>
<p>In legacy wal mode, when a writer writes data to the database, it doesn&#39;t
modify the database file directly. Instead, it appends new data to the
&#34;&lt;database&gt;-wal&#34; file. Readers read data from both the original database
file and the &#34;&lt;database&gt;-wal&#34; file. At some point, data is copied from the
&#34;&lt;database&gt;-wal&#34; file into the database file, after which the wal file can
be deleted or overwritten. Copying data from the wal file into the database
file is called a &#34;checkpoint&#34;, and may be done explictly (either by &#34;PRAGMA
wal_checkpoint&#34; or sqlite3_wal_checkpoint_v2()), or
automatically (by configuring &#34;PRAGMA wal_autocheckpoint&#34; - this is the
default).</p>

<p>Checkpointers do not block writers, and writers do not block checkpointers.
However, if a writer writes to the database while a checkpoint is ongoing,
then the new data is appended to the end of the wal file. This means that,
even following the checkpoint, the wal file cannot be overwritten or deleted,
and so all subsequent transactions must also be appended to the wal file. The
work of the checkpointer is not wasted - SQLite remembers which parts of the
wal file have already been copied into the db file so that the next checkpoint
does not have to do so again - but it does mean that the wal file may grow
indefinitely if the checkpointer never gets a chance to finish without a
writer appending to the wal file. There are also circumstances in which
long-running readers may prevent a checkpointer from checkpointing the entire
wal file - also causing the wal file to grow indefinitely in a busy system.</p>

<p>Wal2 mode does not have this problem. In wal2 mode, wal files do not grow
indefinitely even if the checkpointer never has a chance to finish
uninterrupted.</p>

<p>In wal2 mode, the system uses two wal files instead of one. The files are named
&#34;&lt;database&gt;-wal&#34; and &#34;&lt;database&gt;-wal2&#34;, where &#34;&lt;database&gt;&#34; is of
course the name of the database file. When data is written to the database, the
writer begins by appending the new data to the first wal file. Once the first
wal file has grown large enough, writers switch to appending data to the second
wal file. At this point the first wal file can be checkpointed (after which it
can be overwritten). Then, once the second wal file has grown large enough and
the first wal file has been checkpointed, writers switch back to the first wal
file. And so on.</p>

<h2>Application Programming</h2>
<p>From the point of view of the user, the main differences between wal and 
wal2 mode are to do with checkpointing:</p>

<ul>
<li><p>In wal mode, a checkpoint may be attempted at any time. In wal2 
mode, the checkpointer has to wait until writers have switched 
to the &#34;other&#34; wal file before a checkpoint can take place.</p></li>
<li><p>In wal mode, the wal-hook (callback registered using
sqlite3_wal_hook()) is invoked after a transaction is committed
with the total number of pages in the wal file as an argument. In wal2
mode, the argument is either the total number of uncheckpointed pages in
both wal files, or - if the &#34;other&#34; wal file is empty or already
checkpointed - 0.</p></li>
</ul>

<p>Clients are recommended to use the same strategies for checkpointing wal2 mode
databases as for wal databases - by registering a wal-hook using
sqlite3_wal_hook() and attempting a checkpoint when the parameter
exceeds a certain threshold.</p>

<p>However, it should be noted that although the wal-hook is invoked after each
transaction is committed to disk and database locks released, it is still
invoked from within the sqlite3_step() call used to execute the &#34;COMMIT&#34;
command. In BEGIN CONCURRENT systems, where the &#34;COMMIT&#34; is often protected by
an application mutex, this may reduce concurrency. In such systems, instead of
executing a checkpoint from within the wal-hook, a thread might defer this
action until after the application mutex has been released.</p>

</div></div>
  </body>
</html>
