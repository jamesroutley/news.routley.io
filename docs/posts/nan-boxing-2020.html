<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://piotrduperas.com/posts/nan-boxing/">Original</a>
    <h1>NaN Boxing (2020)</h1>
    
    <div id="readability-page-1" class="page"><div><p><span>
      <a href="https://nickdrozd.github.io/static/8155ded05e080254e7eaf9861eb83f85/0f98f/nanboxing.jpg" target="_blank" rel="noopener">
    <span></span>
  <picture>
          <source srcset="/static/8155ded05e080254e7eaf9861eb83f85/8ac56/nanboxing.webp 240w,
/static/8155ded05e080254e7eaf9861eb83f85/d3be9/nanboxing.webp 480w,
/static/8155ded05e080254e7eaf9861eb83f85/e46b2/nanboxing.webp 960w,
/static/8155ded05e080254e7eaf9861eb83f85/f992d/nanboxing.webp 1440w,
/static/8155ded05e080254e7eaf9861eb83f85/882b9/nanboxing.webp 1920w" sizes="(max-width: 960px) 100vw, 960px" type="image/webp"/>
          <source srcset="/static/8155ded05e080254e7eaf9861eb83f85/09b79/nanboxing.jpg 240w,
/static/8155ded05e080254e7eaf9861eb83f85/7cc5e/nanboxing.jpg 480w,
/static/8155ded05e080254e7eaf9861eb83f85/6a068/nanboxing.jpg 960w,
/static/8155ded05e080254e7eaf9861eb83f85/644c5/nanboxing.jpg 1440w,
/static/8155ded05e080254e7eaf9861eb83f85/0f98f/nanboxing.jpg 1920w" sizes="(max-width: 960px) 100vw, 960px" type="image/jpeg"/>
          <img src="https://nickdrozd.github.io/static/8155ded05e080254e7eaf9861eb83f85/6a068/nanboxing.jpg" alt="Photo of pipes" title="Photo of pipes" loading="lazy"/>
        </picture>
  </a>
    </span>
<em></em></p><center><em>Photo by Anete Lūsiņa on Unsplash. Not without reason, it presents packing.</em></center>
<figure>
	<blockquote>
		<p>“Sometimes the line between genius and madness is hair thin.”</p>
		
	</blockquote>
</figure>
<p>There are many programming languages that are <em>dynamically typed</em>, which means that you can reassign variables many times using completely different types of value. Let’s see this in JavaScript:</p>
<div data-language="javascript"><pre><code><span>let</span> a <span>=</span> <span>&#34;foo&#34;</span><span>;</span> 
a <span>=</span> <span>{</span>bar<span>:</span> <span>1</span><span>}</span><span>;</span>  
a <span>=</span> <span>123</span><span>;</span>       </code><span aria-hidden="true"><span></span><span></span><span></span></span></pre></div>
<p>Some people criticize this style, some find it useful. No matter what group you belong to, doesn’t it seem interesting how this works? I will show you some solutions, but the most interesting will be the last one, so wait for it :)</p>
<h3 id="general-idea-for-this-article"><a href="#general-idea-for-this-article" aria-label="general idea for this article permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>General idea for this article</h3>
<p>Let’s say we are implementing our own dynamically-typing language in C, like e.g. CPython. We need to invent a way of recognizing types of our values and storing different types of them. Of course, these processes should be as simple as possible and memory-efficient, so that our virtual machine can run blazingly fast.</p>
<p>For the sake of this article, we assume that our language supports six possible types: </p>
<ol>
<li>64-bit floating-point numbers, </li>
<li>32-bit integers, </li>
<li>strings, </li>
<li>null, </li>
<li>booleans,</li>
<li>objects. </li>
</ol>
<p>They create a wide spectrum of representations. Numbers can occupy 64 or 32 bits, null is just one special value and for booleans, we need two of them: <em>true</em> and <em>false</em>. Objects and strings have to be stored as pointers, as we do not know in advance their size. Moreover, the size of a pointer depends on the chip’s architecture. In most modern computers, they can have 32 or 64 bits.</p>
<p>How to pack all of them?</p>
<h2 id="very-very-bad-approach"><a href="#very-very-bad-approach" aria-label="very very bad approach permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Very very bad approach</h2>
<p>This might be the first solution that comes to mind. We define a struct with an enum <strong>tag</strong>, which tells what type the value holds now, and has all possible types listed.</p>
<div data-language="c"><pre><code><span>typedef</span> <span>struct</span> <span>{</span>
  <span>enum</span> <span>{</span>
    TYPE_DOUBLE<span>,</span>
    TYPE_INT<span>,</span>
    TYPE_STRING<span>,</span>
    TYPE_OBJECT<span>,</span>
    TYPE_BOOLEAN<span>,</span>
    TYPE_NULL
  <span>}</span> type<span>;</span>

  <span>double</span> as_double<span>;</span>
  <span>int32_t</span> as_int<span>;</span>
  <span>char</span><span>*</span> as_string<span>;</span>
  <span>void</span><span>*</span> as_object<span>;</span>
  <span>char</span> as_boolean<span>;</span> 
<span>}</span> value<span>;</span></code><span aria-hidden="true"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>Probably you have noticed that we do not have the <code>as_null</code> field. That is, of course, because null has only one possible value, so if we know it is null, there is no need to analyze its value further.</p>
<p>Setting different values here is pretty straightforward:</p>
<div data-language="c"><pre><code>value foo<span>;</span>


foo<span>.</span>type <span>=</span> TYPE_INT<span>;</span>
foo<span>.</span>as_int <span>=</span> <span>123</span><span>;</span>


foo<span>.</span>type <span>=</span> TYPE_BOOLEAN<span>;</span>
foo<span>.</span>as_boolean <span>=</span> <span>0</span><span>;</span> 


foo<span>.</span>type <span>=</span> TYPE_STRING<span>;</span>
foo<span>.</span>as_string <span>=</span> <span>&#34;bar&#34;</span><span>;</span></code><span aria-hidden="true"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>Testing types and reading values is also not a rocket-science:</p>
<div data-language="c"><pre><code><span>switch</span><span>(</span>foo<span>.</span>type<span>)</span><span>{</span>
  <span>case</span> TYPE_DOUBLE<span>:</span>
    <span>printf</span><span>(</span><span>&#34;%lf&#34;</span><span>,</span> foo<span>.</span>as_double<span>)</span><span>;</span>
    <span>break</span><span>;</span>
  <span>case</span> TYPE_NULL<span>:</span>
    <span>printf</span><span>(</span><span>&#34;null&#34;</span><span>)</span><span>;</span>
  <span>case</span> TYPE_STRING<span>:</span>
    <span>printf</span><span>(</span><span>&#34;%s&#34;</span><span>,</span> foo<span>.</span>as_string<span>)</span><span>;</span>
    <span>break</span><span>;</span>
  <span>default</span><span>:</span>
    <span>printf</span><span>(</span><span>&#34;It&#39;s something else&#34;</span><span>)</span><span>;</span>
<span>}</span></code><span aria-hidden="true"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>It seems to work, doesn’t it? Everything is easy, we can store different values and even do not have to care about any C type size. Actually, we do not care about size at all.</p>
<h3 id="and-this-is-wrong"><a href="#and-this-is-wrong" aria-label="and this is wrong permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>And this is <strong>wrong</strong>.</h3>
<p>Let’s count how big is our value struct, assuming we are programming for some 64-bit systems.</p>
<ol>
<li><code>enum type</code> is probably the same size as <code>int</code> — typically <strong>4 bytes</strong></li>
<li><code>double as_double</code> should have 64 bits — <strong>8 bytes</strong></li>
<li><code>int32_t as_int</code> has 32 bits — <strong>4 bytes</strong></li>
<li><code>char* as_string</code> is a pointer — 64 bits or <strong>8 bytes</strong></li>
<li><code>void* as_object</code> the same — <strong>8 bytes</strong></li>
<li><code>char as_boolean</code> is usually pretty small — <strong>1 byte</strong></li>
</ol>
<p>The sum of these sizes gives us <strong>33 bytes</strong> (or 264 bits). Well, we had better check our calculations:</p>
<div data-language="c"><pre><code><span>printf</span><span>(</span><span>&#34;%d\n&#34;</span><span>,</span> <span>sizeof</span><span>(</span>value<span>)</span><span>)</span><span>;</span></code><span aria-hidden="true"><span></span></span></pre></div>
<p>On my computer, compiled with <code>gcc</code>, it displays <strong>48</strong>. It is much more than our 33 bytes. Are our calculations <strong>so much</strong> wrong?</p>
<h3 id="padding"><a href="#padding" aria-label="padding permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Padding</h3>
<p>They are actually right in terms of additions. However, structs in C do not behave this way. The sum of ingredients does not have to be the overall size of a struct.
This happens because of an effect called <strong>padding</strong>. The compilers are <em>to blame</em> for it. They can put some empty space inside of a struct or after it in order to make the overall size look <em>better</em>.</p>
<p>What does it mean <em>better</em>? Let’s do a little recap of how computers work closer to the metal.</p>
<p>When CPU wants to read something from memory, it has to read whole <em>words</em> — chunks of data of fixed size, usually like 64 or 32 bits. If our struct has such a good size, the CPU can read it pretty directly and fast. If not, like our 33-byte value struct with one dangling byte, CPU has to do some shifts in memory and it is harder to pack more of these structs in its registers.</p>
<p>Because of that, compilers put some empty bytes between our struct members or at the end of a struct in order to ensure that the overall size will be good enough for CPU. A compiler can also change the order of fields if this could improve the speed of reading them. This is also a reason why it is not a good idea to directly serialize structs as binary data — the same struct can look differently on different computers.</p>
<h4 id="lets-go-back-to-our-code"><a href="#lets-go-back-to-our-code" aria-label="lets go back to our code permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Let’s go back to our code</h4>
<p>It seems like a compiler added 15 empty bytes somewhere in the struct, making it by almost 50% bigger just in vain (for us, for CPU it could be better). We could reduce the size to 32 bytes just by removing some fields and trying to move its function somewhere else. For example, we can get rid of <code>as_boolean</code> like this:</p>
<div data-language="c"><pre><code><span>typedef</span> <span>struct</span> <span>{</span>
  <span>enum</span> <span>{</span>
    TYPE_DOUBLE<span>,</span>
    TYPE_INT<span>,</span>
    TYPE_STRING<span>,</span>
    TYPE_OBJECT<span>,</span>
    TYPE_BOOLEAN_TRUE<span>,</span>
    TYPE_BOOLEAN_FALSE<span>,</span>
    TYPE_NULL
  <span>}</span> type<span>;</span>

  <span>int32_t</span> as_int<span>;</span>
  <span>double</span> as_double<span>;</span>
  <span>void</span><span>*</span> as_object<span>;</span>
  <span>char</span><span>*</span> as_string<span>;</span>
<span>}</span> value<span>;</span></code><span aria-hidden="true"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>Notice that I have also changed the order of <code>as_int</code> and <code>as_double</code>. Without that, my compiler still used to push additional space inside for better alignment. Now, it is aligned <code>4 4 8 8 8</code>, which is fairly well and gives overall size 32 bytes.</p>
<h4 id="but"><a href="#but" aria-label="but permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>But…</h4>
<p>…it is as much as 32 bytes! It looks like a real overdose for storing values with the longest one being just 8 bytes.
Moreover, if we decide to add a new type in the future, the struct’s size will grow even more.</p>
<p>We need something better. We need tagged unions!</p>
<h2 id="tagged-union"><a href="#tagged-union" aria-label="tagged union permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Tagged union</h2>
<p>Let’s see the better version of our little big struct:</p>
<div data-language="c"><pre><code><span>typedef</span> <span>struct</span> <span>{</span>
  <span>enum</span> <span>{</span>
    TYPE_DOUBLE<span>,</span>
    TYPE_INT<span>,</span>
    TYPE_STRING<span>,</span>
    TYPE_OBJECT<span>,</span>
    TYPE_BOOLEAN<span>,</span>
    TYPE_NULL
  <span>}</span> type<span>;</span>

  <span>union</span> <span>{</span>
    <span>double</span> double_num<span>;</span>
    <span>int32_t</span> int_num<span>;</span>
    <span>char</span><span>*</span> string_ptr<span>;</span>
    <span>void</span><span>*</span> object_ptr<span>;</span>
    <span>char</span> boolean<span>;</span> 
  <span>}</span> as<span>;</span>
  
<span>}</span> value<span>;</span></code><span aria-hidden="true"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>If you are familiar with unions in C, you can skip this little paragraph. If not, here is a quick recap.</p>
<h3 id="unions"><a href="#unions" aria-label="unions permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Unions</h3>
<p>A union is a special value representation in C that allows storing some data in multiple formats in the same place in memory. It is a perfect solution for our problem, as it can store our <em>value</em>, no matter what it is exactly, without much care of its type. It just squeezes all possible types in one place in memory by overlapping them and such bits can be read as representing one of the member types.</p>
<p>Here is a little sketch of this union:</p>
<div data-language="c"><pre><code><span>union</span> <span>{</span>
  <span>char</span> foo<span>;</span>
  <span>int</span> bar<span>;</span>
<span>}</span><span>;</span></code><span aria-hidden="true"><span></span><span></span><span></span><span></span></span></pre></div>
<p><span>
      <a href="https://nickdrozd.github.io/static/39e016906576f5ba7dde909b29458a13/31aff/union.png" target="_blank" rel="noopener">
    <span></span>
  <picture>
          <source srcset="/static/39e016906576f5ba7dde909b29458a13/8ac56/union.webp 240w,
/static/39e016906576f5ba7dde909b29458a13/d3be9/union.webp 480w,
/static/39e016906576f5ba7dde909b29458a13/7fbc2/union.webp 823w" sizes="(max-width: 823px) 100vw, 823px" type="image/webp"/>
          <source srcset="/static/39e016906576f5ba7dde909b29458a13/8ff5a/union.png 240w,
/static/39e016906576f5ba7dde909b29458a13/e85cb/union.png 480w,
/static/39e016906576f5ba7dde909b29458a13/31aff/union.png 823w" sizes="(max-width: 823px) 100vw, 823px" type="image/png"/>
          <img src="https://nickdrozd.github.io/static/39e016906576f5ba7dde909b29458a13/31aff/union.png" alt="Sketch of a union" title="Sketch of a union" loading="lazy"/>
        </picture>
  </a>
    </span></p>
<p>We have 4 bytes for <code>int</code> and 1 byte for <code>char</code>. In memory, these two types overlap each other. In other words, these bytes can be interpreted as <code>char</code> or as <code>int</code>.</p>
<p>Unions have always the size of their biggest member. In this case, the union is 4 bytes long, as <code>int</code> is of the longest one type inside.</p>
<h3 id="getting-back-to-our-code"><a href="#getting-back-to-our-code" aria-label="getting back to our code permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Getting back to our code</h3>
<p>So, by using union, our code for setting and getting values changes a little:</p>
<div data-language="c"><pre><code>value foo<span>;</span>

foo<span>.</span>type <span>=</span> TYPE_INT<span>;</span>
foo<span>.</span>as<span>.</span>int_num <span>=</span> <span>123</span><span>;</span>

<span>if</span><span>(</span>foo<span>.</span>type <span>==</span> TYPE_STRING<span>)</span><span>{</span>
  <span>printf</span><span>(</span><span>&#34;string %s\n&#34;</span><span>,</span> foo<span>.</span>as<span>.</span>string_ptr<span>)</span><span>;</span>
<span>}</span></code><span aria-hidden="true"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>However, it is still pretty straightforward and fast. The greatest advantage over the previous <em>bad</em> version is reduced struct’s size. Now, it is just the enum, which is <strong>4 bytes</strong> long, and union, which has the longest type (<code>double</code>, or pointers) of <strong>8 bytes</strong>, which overall gives us 12 bytes. It can be optimized further by choosing <code>char</code> instead of enum to 9 bytes. Either way, compilers probably align the struct to 16 bytes.</p>
<p>That is much better than the previous 48 or even 32 bytes. Actually, such an implementation is useful for simulating dynamic types in statically-typed languages like C/C++.</p>
<p>But our problem of storing and accessing types resolved at runtime still looks quite inefficiently. From 25% to almost half of the struct’s memory is allocated in vain. 16 bytes means that on the 64-bit machine two writes are required to load the value into CPU’s registers.</p>
<p>So, two obvious improvements can come to mind:</p>
<ol>
<li>Compression of the union — if it is shorter than 8 bytes, it would be possible to fit everything in 8 bytes.</li>
<li>Removal of the type tag — it gives the dangling byte, so if we can get rid of it or cram it somewhere, the struct will be 8 bytes long as well.</li>
</ol>
<p>The first option seems to be impossible with our condition that we would like to store <code>double</code> directly. This type just has to have all the 64 bits present. The same situation is for… pointers?</p>
<p><span>
      <a href="https://nickdrozd.github.io/static/d1981b5337d2a2b740ad8fc49e0350ea/6a068/well.jpg" target="_blank" rel="noopener">
    <span></span>
  <picture>
          <source srcset="/static/d1981b5337d2a2b740ad8fc49e0350ea/8ac56/well.webp 240w,
/static/d1981b5337d2a2b740ad8fc49e0350ea/d3be9/well.webp 480w,
/static/d1981b5337d2a2b740ad8fc49e0350ea/e46b2/well.webp 960w" sizes="(max-width: 960px) 100vw, 960px" type="image/webp"/>
          <source srcset="/static/d1981b5337d2a2b740ad8fc49e0350ea/09b79/well.jpg 240w,
/static/d1981b5337d2a2b740ad8fc49e0350ea/7cc5e/well.jpg 480w,
/static/d1981b5337d2a2b740ad8fc49e0350ea/6a068/well.jpg 960w" sizes="(max-width: 960px) 100vw, 960px" type="image/jpeg"/>
          <img src="https://nickdrozd.github.io/static/d1981b5337d2a2b740ad8fc49e0350ea/6a068/well.jpg" alt="Well, yes, but actually no" title="Well, yes, but actually no" loading="lazy"/>
        </picture>
  </a>
    </span></p>
<p>We can cut off a pretty significant part of a pointer’s bits actually, without losing any of its meaning. Read carefully and you will see!</p>
<h2 id="lets-begin-making-things-a-little-crazy"><a href="#lets-begin-making-things-a-little-crazy" aria-label="lets begin making things a little crazy permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Let’s begin making things a little crazy</h2>
<p>Just for a moment assume that we do not have to pack <code>double</code> inside our structure. Instead of this, let’s use <code>double*</code> pointing to the actual value of this number. As we saw, double was the problematic union’s member, so now things should go easier, shouldn’t they? But do not worry about the <code>double</code>, we will restore it later, I promise!</p>
<h3 id="what-if-our-struct-looked-like-this"><a href="#what-if-our-struct-looked-like-this" aria-label="what if our struct looked like this permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What if our struct looked like this?</h3>
<div data-language="c"><pre><code><span>typedef</span> <span>union</span> <span>{</span>
  <span>uint64_t</span> as_uint64<span>;</span>
  <span>void</span><span>*</span> as_object_ptr<span>;</span>
<span>}</span> value<span>;</span></code><span aria-hidden="true"><span></span><span></span><span></span><span></span></span></pre></div>
<p>Well, it is not a struct anymore, just a union now. It has 8 bytes, but what happened with all the fields we used to have? What happened with the tag? How to recognize what type it represents? Why did we introduce some unsigned int of 64-bit size? It is not obvious. Or it was not for me when I saw it for the first time.</p>
<h4 id="padding-again"><a href="#padding-again" aria-label="padding again permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Padding again</h4>
<p>Do you remember the struct alignment mentioned in some paragraphs above? There — it hurts a little, here it helps.</p>
<p>Not only do compilers try to align everything to some multiple of 8, but memory allocator does the same as well. It means that it is pretty sure that whether you allocate some memory at the heap, you will get a pointer which address is divisible by 8, especially when you want to allocate chunks of 8 bytes, like our good old struct value (or union now). </p>
<p>The advantage is that the last 3 bits of every pointer from <code>malloc</code> should be zeros. Actually, I suppose there is no guarantee about that, but in reality, all allocators do so. For example, GNU libc malloc, even on 32-bit platforms, aligns addresses to multiples of 8.</p>
<p>These three bits are the place where the tag, missing at the first glance in this union, is moved. They give us 8 possible values, which are enough for our needs about a few types. But this approach will not let us store and read values as directly as before. We will need to use some bitmasks.</p>
<h3 id="jugling-bits-is-what-tigers-like-best"><a href="#jugling-bits-is-what-tigers-like-best" aria-label="jugling bits is what tigers like best permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Jugling bits is what tigers like best!</h3>
<p>This is how a typical 64-bit pointer looks like:</p>
<p><span>
      <a href="https://nickdrozd.github.io/static/d10b86abd523738fa37d6103227d18af/fd28b/pointer.png" target="_blank" rel="noopener">
    <span></span>
  <picture>
          <source srcset="/static/d10b86abd523738fa37d6103227d18af/8ac56/pointer.webp 240w,
/static/d10b86abd523738fa37d6103227d18af/d3be9/pointer.webp 480w,
/static/d10b86abd523738fa37d6103227d18af/a63ac/pointer.webp 811w" sizes="(max-width: 811px) 100vw, 811px" type="image/webp"/>
          <source srcset="/static/d10b86abd523738fa37d6103227d18af/8ff5a/pointer.png 240w,
/static/d10b86abd523738fa37d6103227d18af/e85cb/pointer.png 480w,
/static/d10b86abd523738fa37d6103227d18af/fd28b/pointer.png 811w" sizes="(max-width: 811px) 100vw, 811px" type="image/png"/>
          <img src="https://nickdrozd.github.io/static/d10b86abd523738fa37d6103227d18af/fd28b/pointer.png" alt="Sketch of a pointer" title="Sketch of a pointer" loading="lazy"/>
        </picture>
  </a>
    </span></p>
<p>It means that we can treat all our <em>values</em> as e.g. <code>void *</code> pointers when the last three bits are 000. With a little help from macros, we can dereference and set such pointers directly:</p>
<div data-language="c"><pre><code><span><span>#</span><span>define</span> <span>IS_OBJECT_PTR</span><span><span>(</span>v<span>)</span> <span>(</span><span>(</span>v<span>.</span>as_uint64 <span>&amp;</span> <span>7</span><span>)</span> <span>==</span> <span>0</span><span>)</span></span></span>

value foo<span>;</span>
<span>void</span><span>*</span> bar<span>;</span> 


foo<span>-&gt;</span>as_object_ptr <span>=</span> bar<span>;</span>


<span>if</span><span>(</span><span>IS_OBJECT_PTR</span><span>(</span>foo<span>)</span><span>)</span><span>{</span>
  <span>printf</span><span>(</span><span>&#34;It&#39;s an object with address %p\n&#34;</span><span>,</span> foo<span>-&gt;</span>as_object_ptr<span>)</span><span>;</span>
<span>}</span></code><span aria-hidden="true"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>Not so bad, isn’t it?</p>
<p>Let’s pack other types! Now, it is completely our decision which bit patterns represent which type, so I will go for this way:</p>
<p><span>
      <a href="https://nickdrozd.github.io/static/1113a666e6b212e5c008ef21802aa5ee/d2a60/pointers.png" target="_blank" rel="noopener">
    <span></span>
  <picture>
          <source srcset="/static/1113a666e6b212e5c008ef21802aa5ee/8ac56/pointers.webp 240w,
/static/1113a666e6b212e5c008ef21802aa5ee/d3be9/pointers.webp 480w,
/static/1113a666e6b212e5c008ef21802aa5ee/9ec5a/pointers.webp 807w" sizes="(max-width: 807px) 100vw, 807px" type="image/webp"/>
          <source srcset="/static/1113a666e6b212e5c008ef21802aa5ee/8ff5a/pointers.png 240w,
/static/1113a666e6b212e5c008ef21802aa5ee/e85cb/pointers.png 480w,
/static/1113a666e6b212e5c008ef21802aa5ee/d2a60/pointers.png 807w" sizes="(max-width: 807px) 100vw, 807px" type="image/png"/>
          <img src="https://nickdrozd.github.io/static/1113a666e6b212e5c008ef21802aa5ee/d2a60/pointers.png" alt="Sketch of pointers" title="Sketch of pointers" loading="lazy"/>
        </picture>
  </a>
    </span></p>
<p>You might have noticed that I have not mentioned the integer type. It can work kind of differently:</p>
<p><span>
      <a href="https://nickdrozd.github.io/static/efda309367c99e4f5e3c5bf417e1832e/3534c/int.png" target="_blank" rel="noopener">
    <span></span>
  <picture>
          <source srcset="/static/efda309367c99e4f5e3c5bf417e1832e/8ac56/int.webp 240w,
/static/efda309367c99e4f5e3c5bf417e1832e/d3be9/int.webp 480w,
/static/efda309367c99e4f5e3c5bf417e1832e/2b269/int.webp 808w" sizes="(max-width: 808px) 100vw, 808px" type="image/webp"/>
          <source srcset="/static/efda309367c99e4f5e3c5bf417e1832e/8ff5a/int.png 240w,
/static/efda309367c99e4f5e3c5bf417e1832e/e85cb/int.png 480w,
/static/efda309367c99e4f5e3c5bf417e1832e/3534c/int.png 808w" sizes="(max-width: 808px) 100vw, 808px" type="image/png"/>
          <img src="https://nickdrozd.github.io/static/efda309367c99e4f5e3c5bf417e1832e/3534c/int.png" alt="Sketch of &#34;int pointer&#34;" title="Sketch of &#34;int pointer&#34;" loading="lazy"/>
        </picture>
  </a>
    </span></p>
<p>Everything that has 1 at the end is treated as an integer. It might seem like a waste of our precious 3 bits to use 1 of them just for encoding one type. However, it is not me who invented such an approach. But before I explain it, let’s see some code for dealing with these crazy patterns.</p>
<div data-language="c"><pre><code><span><span>#</span><span>define</span> <span>NULL_VALUE</span> <span><span>0x6</span></span></span>
<span><span>#</span><span>define</span> <span>TRUE_VALUE</span> <span><span>0x1E</span></span></span>
<span><span>#</span><span>define</span> <span>FALSE_VALUE</span> <span><span>0x0E</span></span></span>

<span><span>#</span><span>define</span> <span>IS_OBJECT_PTR</span><span><span>(</span>v<span>)</span> <span>(</span><span>(</span>v<span>.</span>as_uint64 <span>&amp;</span> <span>0x7</span><span>)</span> <span>==</span> <span>0x0</span><span>)</span></span></span>
<span><span>#</span><span>define</span> <span>IS_STRING_PTR</span><span><span>(</span>v<span>)</span> <span>(</span><span>(</span>v<span>.</span>as_uint64 <span>&amp;</span> <span>0x7</span><span>)</span> <span>==</span> <span>0x2</span><span>)</span></span></span>
<span><span>#</span><span>define</span> <span>IS_DOUBLE_PTR</span><span><span>(</span>v<span>)</span> <span>(</span><span>(</span>v<span>.</span>as_uint64 <span>&amp;</span> <span>0x7</span><span>)</span> <span>==</span> <span>0x4</span><span>)</span></span></span>
<span><span>#</span><span>define</span> <span>IS_NULL</span><span><span>(</span>v<span>)</span> <span>(</span>v<span>.</span>as_uint64 <span>==</span> NULL_VALUE<span>)</span></span></span>
<span><span>#</span><span>define</span> <span>IS_BOOL</span><span><span>(</span>v<span>)</span> <span>(</span><span>(</span>v<span>.</span>as_uint64 <span>&amp;</span> <span>0xF</span><span>)</span> <span>==</span> <span>0xE</span><span>)</span></span></span>
<span><span>#</span><span>define</span> <span>IS_INT</span><span><span>(</span>v<span>)</span> <span>(</span>v<span>.</span>as_uint64 <span>&amp;</span> <span>0x1</span><span>)</span></span></span>

<span><span>#</span><span>define</span> <span>GET_AS_OBJECT_PTR</span><span><span>(</span>v<span>)</span> <span>(</span>v<span>.</span>as_object_ptr<span>)</span></span></span>
<span><span>#</span><span>define</span> <span>GET_AS_STRING_PTR</span><span><span>(</span>v<span>)</span> <span>(</span><span>(</span><span>char</span><span>*</span><span>)</span><span>(</span>v<span>.</span>as_uint64 <span>^</span> <span>0x2</span><span>)</span><span>)</span></span></span>
<span><span>#</span><span>define</span> <span>GET_AS_DOUBLE_PTR</span><span><span>(</span>v<span>)</span> <span>(</span><span>(</span><span>double</span><span>*</span><span>)</span><span>(</span>v<span>.</span>as_uint64 <span>^</span> <span>0x4</span><span>)</span><span>)</span></span></span>
<span><span>#</span><span>define</span> <span>GET_AS_BOOL</span><span><span>(</span>v<span>)</span> <span>(</span><span>(</span><span>char</span><span>)</span><span>(</span>v<span>.</span>as_uint64 <span>&gt;&gt;</span> <span>4</span><span>)</span><span>)</span></span></span>
<span><span>#</span><span>define</span> <span>GET_AS_INT</span><span><span>(</span>v<span>)</span> <span>(</span><span>(</span><span>int32_t</span><span>)</span><span>(</span>v<span>.</span>as_uint64 <span>&gt;&gt;</span> <span>1</span><span>)</span><span>)</span></span></span>

<span><span>#</span><span>define</span> <span>MAKE_OBJECT_PTR</span><span><span>(</span>p<span>)</span> <span>(</span><span>(</span><span>uint64_t</span><span>)</span><span>(</span>p<span>)</span><span>)</span></span></span>
<span><span>#</span><span>define</span> <span>MAKE_STRING_PTR</span><span><span>(</span>p<span>)</span> <span>(</span><span>(</span><span>uint64_t</span><span>)</span><span>(</span>p<span>)</span> <span>|</span> <span>0x2</span><span>)</span></span></span>
<span><span>#</span><span>define</span> <span>MAKE_DOUBLE_PTR</span><span><span>(</span>p<span>)</span> <span>(</span><span>(</span><span>uint64_t</span><span>)</span><span>(</span>p<span>)</span> <span>|</span> <span>0x4</span><span>)</span></span></span>
<span><span>#</span><span>define</span> <span>MAKE_INT</span><span><span>(</span>i<span>)</span> <span>(</span><span>(</span><span>(</span><span>uint64_t</span><span>)</span><span>(</span>i<span>)</span> <span>&lt;&lt;</span> <span>1</span><span>)</span> <span>|</span> <span>0x1</span><span>)</span></span></span>



value foo<span>;</span>
<span>char</span><span>*</span> some_string<span>;</span>



foo<span>.</span>as_uint64 <span>=</span> <span>MAKE_STRING_PTR</span><span>(</span>some_string<span>)</span><span>;</span>
foo<span>.</span>as_uint64 <span>=</span> <span>MAKE_INT</span><span>(</span><span>234</span><span>)</span><span>;</span>
foo<span>.</span>as_uint64 <span>=</span> FALSE_VALUE<span>;</span> 



<span>if</span><span>(</span><span>IS_STRING_PTR</span><span>(</span>foo<span>)</span><span>)</span><span>{</span>
  <span>printf</span><span>(</span><span>&#34;string: %s\n&#34;</span><span>,</span> <span>GET_AS_STRING_PTR</span><span>(</span>foo<span>)</span><span>)</span><span>;</span>
<span>}</span>
<span>else</span> <span>if</span><span>(</span><span>IS_INT</span><span>(</span>foo<span>)</span><span>)</span><span>{</span>
  <span>printf</span><span>(</span><span>&#34;int: %d\n&#34;</span><span>,</span> <span>GET_AS_INT</span><span>(</span>foo<span>)</span><span>)</span><span>;</span>
<span>}</span>
<span>else</span> <span>if</span><span>(</span><span>IS_BOOL</span><span>(</span>foo<span>)</span><span>)</span><span>{</span>
  <span>printf</span><span>(</span><span>&#34;bool: %s\n&#34;</span><span>,</span> <span>GET_AS_BOOL</span><span>(</span>foo<span>)</span> <span>?</span> <span>&#34;true&#34;</span> <span>:</span> <span>&#34;false&#34;</span><span>)</span><span>;</span>
<span>}</span></code><span aria-hidden="true"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>Lots of macros, but using all the types is still pretty simple.</p>
<h3 id="who-is-using-this"><a href="#who-is-using-this" aria-label="who is using this permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Who is using this?</h3>
<p>This way of squeezing many types into a pointer is a method called <strong><a href="https://en.wikipedia.org/wiki/Tagged_pointer" target="_blank" rel="nofollow noopener noreferrer">tagged pointers</a></strong>. I suppose it is a pretty old trick, but surprisingly, it is still widely used. </p>
<p>One of JavaScript’s implementations, Google’s V8 engine, actually uses tagged pointers for dynamic typing. Moreover, it uses the same way of storing integers as above!</p>
<p>Wait, integers in JavaScript? This language supports only doubles, so why do they store integers as an additional type? Well, integers are faster than doubles and in many cases, in JavaScript, we actually use integers, for example in loops:</p>
<div data-language="javascript"><pre><code><span>for</span><span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> someArray<span>.</span>length<span>;</span> i<span>++</span><span>)</span><span>{</span>
  
<span>}</span></code><span aria-hidden="true"><span></span><span></span><span></span></span></pre></div>
<p>If the engine uses integers under the hood instead of doubles, such loops become a little faster.</p>
<p>Okay, they have integers, but why do they use only one bit for recognizing them? One of the reasons might be the backward compatibility with 32-bit architectures. As with 64-bit pointers, you can store a full 32-bit integer, in a 32-bit pointer, you cannot cram it fully without ambiguity. So they decided that on 32-bit platforms they store 31-bit “small integers”, called ”<a href="https://source.chromium.org/chromium/v8/v8.git/+/master:src/objects/smi.h" target="_blank" rel="nofollow noopener noreferrer">Smis</a>”. The 32nd bit is for recognizing them from pointers. The same approach was followed above in my code.</p>
<h3 id="pros-and-cons"><a href="#pros-and-cons" aria-label="pros and cons permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Pros and cons</h3>
<p>Tagged pointers are actually used. It means that they are fairly good. Actually, they take only 8 bytes on 64-bit machines or even 4 bytes on 32-bit ones. Reading and storing data, when we have those macros defined above, is still pretty easy and fast, as processing units are very keen on bitwise operations. Moreover, there is still a chance that our macros can be optimized by compilers for specific platforms. Finally, they are pretty portable — allocators tend to behave gracefully and align memory cells to multiples of 8.</p>
<p>One of the disadvantages of tagged pointers is that they can store only a few different types, e.g. only 8 types of pointers with straightforward casting. They might also seem quite complicated and require those macros to make things easier. There are <a href="https://en.wikipedia.org/wiki/Tagged_pointer#Null_versus_aligned_pointer" target="_blank" rel="nofollow noopener noreferrer">some views</a> that problems with null pointers can occur, but without storing actual <code>nullptr</code> everything should work.</p>
<p>But the biggest problem from our perspective (do you remember our goal here?) is that storing doubles directly seems impossible. Fortunately, probably many decades ago, some powerful engineers invented another way of packing types called <strong>NaN boxing</strong>…</p>
<h2 id="-and-this-is-the-real-genius"><a href="#-and-this-is-the-real-genius" aria-label=" and this is the real genius permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>… and this is the real genius!</h2>
<p>Okay, let’s change our value struct/union again.</p>
<div data-language="c"><pre><code><span>typedef</span> <span>union</span> <span>{</span>
  <span>uint64_t</span> as_uint64<span>;</span>
  <span>double</span> as_double<span>;</span>
<span>}</span> value<span>;</span></code><span aria-hidden="true"><span></span><span></span><span></span><span></span></span></pre></div>
<p>Previously, we had a pointer, now we have <code>double</code>. The unsigned integer is still there, as it is useful for bitwise manipulations. It means that know we can read directly floating-point numbers. But how can we get pointers from such a union? You will see in a moment.</p>
<h3 id="quick-recap-about-floating-point-numbers"><a href="#quick-recap-about-floating-point-numbers" aria-label="quick recap about floating point numbers permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Quick recap about floating-point numbers.</h3>
<p>They allow us to store a great range of numbers with quite big precision and in our <code>double</code> case they occupy 64 bits. In this article, we do not care how they work actually, but it is vital to see how they are stored in memory:</p>
<p><span>
      <a href="https://nickdrozd.github.io/static/76516d959e3803c73693f27d21296285/90712/double.png" target="_blank" rel="noopener">
    <span></span>
  <picture>
          <source srcset="/static/76516d959e3803c73693f27d21296285/8ac56/double.webp 240w,
/static/76516d959e3803c73693f27d21296285/d3be9/double.webp 480w,
/static/76516d959e3803c73693f27d21296285/9d646/double.webp 882w" sizes="(max-width: 882px) 100vw, 882px" type="image/webp"/>
          <source srcset="/static/76516d959e3803c73693f27d21296285/8ff5a/double.png 240w,
/static/76516d959e3803c73693f27d21296285/e85cb/double.png 480w,
/static/76516d959e3803c73693f27d21296285/90712/double.png 882w" sizes="(max-width: 882px) 100vw, 882px" type="image/png"/>
          <img src="https://nickdrozd.github.io/static/76516d959e3803c73693f27d21296285/90712/double.png" alt="Double scheme" title="Double scheme" loading="lazy"/>
        </picture>
  </a>
    </span></p>
<p>There is one bit that says whether the number is negative or positive, 11 bits for exponent and 52 bits of the fraction part, also called mantissa.</p>
<p>No matter how it all works, we need to learn one more thing. There is a special value called <strong>NaN</strong> (Not a Number), which is yielded as a result of some illegal computations (like 0/0 or square of a negative number). We can see how it looks:</p>
<div data-language="c"><pre><code><span><span>#</span><span>include</span><span>&lt;math.h&gt;</span></span>

value bar<span>;</span>
bar<span>.</span>as_double <span>=</span> NAN<span>;</span>

<span>printf</span><span>(</span><span>&#34;%lx&#34;</span><span>,</span> barr<span>.</span>as_uint64<span>)</span><span>;</span> </code><span aria-hidden="true"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>Fortunately or not, there is more than one NaN. <a href="https://en.wikipedia.org/wiki/IEEE_754" target="_blank" rel="nofollow noopener noreferrer">IEEE 754</a> standard says that every floating-point value with all the exponent bits filled with 1 and at least one fraction bit as 1 (in order to distinguish from infinity) is NaN. It says that the remaining 51 bits (or 52 if sign bit counts) do not actually matter. They are called <em>payload</em> and can serve as a place for storing some information about the reason for NaN.</p>
<h3 id="lets-hide-something-inside"><a href="#lets-hide-something-inside" aria-label="lets hide something inside permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Let’s hide something inside</h3>
<p>I suppose you have already guessed what we are going to do with them. Those remaining bits of NaN can be a place for storing our data, however, one might wonder if those bits may be filled somehow in NaNs yielded by arithmetic operations. The answer is “they should not be filled”. Every modern computer architecture leaves them as zeros. Moreover, probably every computer also sets the first bit of fraction to 1 when it is a NaN (if you are interested, read about <em>quiet</em> and <em>signaling</em> NaN). Thanks to this fact we can distinguish an actual NaN (always <code>7ff8000000000000</code>) from our own NaN-ish value which is still useful for us after some bitwise manipulation.</p>
<p>Okay, the first step is to distinguish non-NaN doubles and the real NaN from our <em>secret</em> NaNs.</p>
<p><span>
      <a href="https://nickdrozd.github.io/static/c28dd513fd8104f12a39245a9b507f78/35751/boxed.png" target="_blank" rel="noopener">
    <span></span>
  <picture>
          <source srcset="/static/c28dd513fd8104f12a39245a9b507f78/8ac56/boxed.webp 240w,
/static/c28dd513fd8104f12a39245a9b507f78/d3be9/boxed.webp 480w,
/static/c28dd513fd8104f12a39245a9b507f78/d21af/boxed.webp 873w" sizes="(max-width: 873px) 100vw, 873px" type="image/webp"/>
          <source srcset="/static/c28dd513fd8104f12a39245a9b507f78/8ff5a/boxed.png 240w,
/static/c28dd513fd8104f12a39245a9b507f78/e85cb/boxed.png 480w,
/static/c28dd513fd8104f12a39245a9b507f78/35751/boxed.png 873w" sizes="(max-width: 873px) 100vw, 873px" type="image/png"/>
          <img src="https://nickdrozd.github.io/static/c28dd513fd8104f12a39245a9b507f78/35751/boxed.png" alt="Boxed value scheme" title="Boxed value scheme" loading="lazy"/>
        </picture>
  </a>
    </span></p>
<p>The first bit in the mantissa is a flag that says “it is kind of NaN”. The second bit means “it is <em>our</em> NaN, no the usual one”. Doing so wastes one bit of our precious memory, however, it makes type checking easier than if we checked presents of any bit “outside” the normal NaN.</p>
<div data-language="c"><pre><code><span><span>#</span><span>define</span> <span>NANISH</span> <span><span>0x7ffc000000000000</span></span></span>

<span><span>#</span><span>define</span> <span>IS_DOUBLE</span><span><span>(</span>v<span>)</span> <span>(</span><span>(</span>v<span>.</span>as_uint64 <span>&amp;</span> NANISH<span>)</span> <span>!=</span> NANISH<span>)</span></span></span>

<span><span>#</span><span>define</span> <span>GET_AS_DOUBLE</span><span><span>(</span>v<span>)</span> <span>(</span>v<span>.</span>as_double<span>)</span></span></span></code><span aria-hidden="true"><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>How does it work? </p>
<ol>
<li>If <code>v</code> is the real NaN, the left side is equal to the real NaN, which is different from our <em>NaN-ish</em>.</li>
<li>If <code>v</code> is a valid number, at least one of the exponent bits is zero, which makes it different from any NaN.</li>
<li>If <code>v</code> is kind of boxed value, the only difference from <em>NaN-ish</em> is <em>outside</em> the mask, so it gives us the <em>NaN-ish</em> mask.</li>
</ol>
<p>It is pretty complicated, isn’t it? But still, it is fast and efficient, and with other types, everything will be a little easier now.</p>
<h3 id="simple-values"><a href="#simple-values" aria-label="simple values permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Simple values</h3>
<p>The time has come for null, booleans and integers. They will have a pretty straightforward representation. We are going to use the third bit of a fraction part and the last two bits. Third bit as 1 will mean “it is boolean or null”, as 0 “it is an integer”. The actual value will be encoded at the end of the fraction part, like this:</p>
<p><span>
      <a href="https://nickdrozd.github.io/static/395dc9f5febb9df6b20236f56217535c/561da/simplevalues.png" target="_blank" rel="noopener">
    <span></span>
  <picture>
          <source srcset="/static/395dc9f5febb9df6b20236f56217535c/8ac56/simplevalues.webp 240w,
/static/395dc9f5febb9df6b20236f56217535c/d3be9/simplevalues.webp 480w,
/static/395dc9f5febb9df6b20236f56217535c/e46b2/simplevalues.webp 960w,
/static/395dc9f5febb9df6b20236f56217535c/bd9c6/simplevalues.webp 969w" sizes="(max-width: 960px) 100vw, 960px" type="image/webp"/>
          <source srcset="/static/395dc9f5febb9df6b20236f56217535c/8ff5a/simplevalues.png 240w,
/static/395dc9f5febb9df6b20236f56217535c/e85cb/simplevalues.png 480w,
/static/395dc9f5febb9df6b20236f56217535c/d9199/simplevalues.png 960w,
/static/395dc9f5febb9df6b20236f56217535c/561da/simplevalues.png 969w" sizes="(max-width: 960px) 100vw, 960px" type="image/png"/>
          <img src="https://nickdrozd.github.io/static/395dc9f5febb9df6b20236f56217535c/d9199/simplevalues.png" alt="Encoding scheme" title="Encoding scheme" loading="lazy"/>
        </picture>
  </a>
    </span></p>
<p>And the mighty code for this:</p>
<div data-language="c"><pre><code><span><span>#</span><span>define</span> <span>NANISH_MASK</span> <span><span>0xffff000000000000</span></span></span>
<span><span>#</span><span>define</span> <span>BOOLEAN_MASK</span> <span><span>0x7ffe000000000002</span></span></span>
<span><span>#</span><span>define</span> <span>INTEGER_MASK</span> <span><span>0x7ffc000000000000</span></span></span>

<span><span>#</span><span>define</span> <span>TRUE_VALUE</span> <span><span>(</span>BOOLEAN_MASK <span>|</span> <span>3</span><span>)</span></span></span>
<span><span>#</span><span>define</span> <span>FALSE_VALUE</span> <span><span>(</span>BOOLEAN_MASK <span>|</span> <span>2</span><span>)</span></span></span>
<span><span>#</span><span>define</span> <span>NULL_VALUE</span> <span><span>0x7ffe000000000000</span></span></span>

<span><span>#</span><span>define</span> <span>IS_NULL</span><span><span>(</span>v<span>)</span> <span>(</span>v<span>.</span>as_uint64 <span>==</span> NULL_VALUE<span>)</span></span></span>
<span><span>#</span><span>define</span> <span>IS_BOOL</span><span><span>(</span>v<span>)</span> <span>(</span><span>(</span>v<span>.</span>as_uint64 <span>&amp;</span> BOOLEAN_MASK<span>)</span> <span>==</span> BOOLEAN_MASK<span>)</span></span></span>
<span><span>#</span><span>define</span> <span>IS_INT</span><span><span>(</span>v<span>)</span> <span>(</span><span>(</span>v<span>.</span>as_uint64 <span>&amp;</span> NANISH_MASK<span>)</span> <span>==</span> INTEGER_MASK<span>)</span></span></span>

<span><span>#</span><span>define</span> <span>GET_AS_BOOL</span><span><span>(</span>v<span>)</span> <span>(</span><span>(</span><span>char</span><span>)</span><span>(</span>v<span>.</span>as_uint64 <span>&amp;</span> <span>0x1</span><span>)</span><span>)</span></span></span>
<span><span>#</span><span>define</span> <span>GET_AS_INT</span><span><span>(</span>v<span>)</span> <span>(</span><span>(</span><span>int32_t</span><span>)</span><span>(</span>v<span>.</span>as_uint64<span>)</span><span>)</span></span></span></code><span aria-hidden="true"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<h3 id="pointers"><a href="#pointers" aria-label="pointers permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Pointers</h3>
<p>Okay, now pointers. But as far as we know, on 64-bit architectures pointers have 64 bits and our tricks with NaN can hold only around 52 bits. If we can cut off some insignificant pointer’s bits… Yes, I told that the last 3 bits tend to be zeros, but that is still not enough. But there is another issue worth observing. </p>
<p>64 bits gives us a huge amount of memory addresses. So huge, that most of them are not necessary with today’s memory capacities. Because of that, 64-bit architectures use only 48 lowest bits of every pointer which still give plenty of addresses. It means that only <strong>48 bits</strong> in a pointer <strong>are significant</strong> and that is enough for our NaN boxing. What about the rest? It’s quite <a href="https://en.wikipedia.org/wiki/X86-64#Virtual_address_space_details" target="_blank" rel="nofollow noopener noreferrer">strange</a>, but on most popular systems they should be zeros. There are some problems with systems like e.g. <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=577056" target="_blank" rel="nofollow noopener noreferrer">Solaris</a>, but it is still possible to fix them somehow and it is out of scope of this little article.</p>
<p>In our implementation, we can store pointers in the last 48 bits of our union. The sign bit can indicate that it is some kind of pointer, and first free bits of fraction part can decide about its real type, like this:</p>
<p><span>
      <a href="https://nickdrozd.github.io/static/1f04b4a221b4f4169fe9b5d15ebf8246/65654/nanpointers.png" target="_blank" rel="noopener">
    <span></span>
  <picture>
          <source srcset="/static/1f04b4a221b4f4169fe9b5d15ebf8246/8ac56/nanpointers.webp 240w,
/static/1f04b4a221b4f4169fe9b5d15ebf8246/d3be9/nanpointers.webp 480w,
/static/1f04b4a221b4f4169fe9b5d15ebf8246/a8a2c/nanpointers.webp 872w" sizes="(max-width: 872px) 100vw, 872px" type="image/webp"/>
          <source srcset="/static/1f04b4a221b4f4169fe9b5d15ebf8246/8ff5a/nanpointers.png 240w,
/static/1f04b4a221b4f4169fe9b5d15ebf8246/e85cb/nanpointers.png 480w,
/static/1f04b4a221b4f4169fe9b5d15ebf8246/65654/nanpointers.png 872w" sizes="(max-width: 872px) 100vw, 872px" type="image/png"/>
          <img src="https://nickdrozd.github.io/static/1f04b4a221b4f4169fe9b5d15ebf8246/65654/nanpointers.png" alt="Pointers scheme" title="Pointers scheme" loading="lazy"/>
        </picture>
  </a>
    </span></p>
<div data-language="c"><pre><code><span><span>#</span><span>define</span> <span>OBJECT_MASK</span> <span><span>0xfffc000000000000</span></span></span>
<span><span>#</span><span>define</span> <span>STRING_MASK</span> <span><span>0xfffe000000000000</span></span></span>

<span><span>#</span><span>define</span> <span>IS_OBJECT_PTR</span><span><span>(</span>v<span>)</span> <span>(</span><span>(</span>v<span>.</span><span>uint64_t</span> <span>&amp;</span> NANISH_MASK<span>)</span> <span>==</span> OBJECT_MASK<span>)</span></span></span>
<span><span>#</span><span>define</span> <span>IS_STRING_PTR</span><span><span>(</span>v<span>)</span> <span>(</span><span>(</span>v<span>.</span><span>uint64_t</span> <span>&amp;</span> NANISH_MASK<span>)</span> <span>==</span> STRING_MASK<span>)</span></span></span>

<span><span>#</span><span>define</span> <span>GET_AS_OBJECT_PTR</span><span><span>(</span>v<span>)</span> <span>(</span><span>(</span><span>void</span><span>*</span><span>)</span><span>(</span>v<span>.</span>as_uint64 <span>&amp;</span> <span>0xFFFFFFFFFFFF</span><span>)</span><span>)</span></span></span>
<span><span>#</span><span>define</span> <span>GET_AS_STRING_PTR</span><span><span>(</span>v<span>)</span> <span>(</span><span>(</span><span>char</span><span>*</span><span>)</span><span>(</span>v<span>.</span>as_uint64 <span>&amp;</span> <span>0xFFFFFFFFFFFF</span><span>)</span><span>)</span></span></span></code><span aria-hidden="true"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<h3 id="setters"><a href="#setters" aria-label="setters permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Setters</h3>
<p>The last things we need to do are setter macros. We do not need such a macro for <code>double</code>, however, adding it could be useful if we wished to make all setter uniformly. But I will not do so here. This article is long enough now :)</p>
<div data-language="c"><pre><code><span><span>#</span><span>define</span> <span>MAKE_OBJECT_PTR</span><span><span>(</span>p<span>)</span> <span>(</span><span>(</span><span>uint64_t</span><span>)</span><span>(</span>p<span>)</span> <span>|</span> OBJECT_MASK<span>)</span></span></span>
<span><span>#</span><span>define</span> <span>MAKE_STRING_PTR</span><span><span>(</span>p<span>)</span> <span>(</span><span>(</span><span>uint64_t</span><span>)</span><span>(</span>p<span>)</span> <span>|</span> STRING_MASK<span>)</span></span></span>
<span><span>#</span><span>define</span> <span>MAKE_INT</span><span><span>(</span>i<span>)</span> <span>(</span><span>(</span><span>uint64_t</span><span>)</span><span>(</span>i<span>)</span> <span>|</span> INTEGER_MASK<span>)</span></span></span></code><span aria-hidden="true"><span></span><span></span><span></span></span></pre></div>
<p>Fairly easy, isn’t it? And we are done!</p>
<h2 id="is-it-madness"><a href="#is-it-madness" aria-label="is it madness permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Is it madness?</h2>
<p>NaN boxing seems really crazy. Almost every possible combination of those 64 bits can store some valid value, we juggle with all those masks and bits. But is it very useful? Yes.</p>
<p>This peculiar technique is used by LuaJIT, <a href="http://wingolog.org/archives/2011/05/18/value-representation-in-javascript-implementations" target="_blank" rel="nofollow noopener noreferrer">Mozilla’s JavaScriptCore</a> and some other dynamically-typed languages implementations. </p>
<h3 id="upsides-of-nan-boxing"><a href="#upsides-of-nan-boxing" aria-label="upsides of nan boxing permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Upsides of NaN boxing</h3>
<ol>
<li>It is memory-efficient, especially on 64-bit architectures, using a minimal amount of memory for those types — 8 bytes.</li>
<li>Unlike tagged pointers, it allows storing 64-bit floating-point numbers. There is no need for storing them on the heap and passing by pointers — which can be expensive.</li>
<li>It seems like <strong>as fast</strong> option <strong>as tagged pointers</strong> (we will check that in a moment).</li>
</ol>
<h3 id="downsides"><a href="#downsides" aria-label="downsides permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Downsides</h3>
<ol>
<li>It is complicated, you see.</li>
<li>On 32-bit computers it is still some waste of memory — tagged pointers use only 4 bytes.</li>
<li>It is based on many quite blurry assumptions about memory allocators, floating-point arithmetics, pointers’ sizes, etc., which might not be true for some platforms and not be future-proof.</li>
</ol>
<p>For example, I did a little research in order to ask the question: why did not V8 go for it? It seems like there is no one special reason for that, but many. <a href="https://news.ycombinator.com/item?id=16985390" target="_blank" rel="nofollow noopener noreferrer">Firstly</a>, the second point of downsides — memory waste on 32 bits, which can be crucial for some devices. Secondly, they have tagged pointers, which is still a good option. Finally, they are said to have decent memory management with the doubles on the heap.</p>
<h3 id="make-pointers-fast-again"><a href="#make-pointers-fast-again" aria-label="make pointers fast again permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Make pointers fast again</h3>
<p>Actually, while implementing NaN boxing, we can take one of two approaches. We can <em>prefer</em> doubles or pointers. In the implementation above, we chose to treat the union <em>by deault</em> as doubles, so getting their values does not require any bitwise operations and is faster. But with more <em>bitpain</em> we could store pointers directly, and shift and mask our union to get double value, which could be helpful if we would like to dereference pointers quickly. I suppose it is a matter of taste here. <a href="https://anniecherkaev.com/the-secret-life-of-nan" target="_blank" rel="nofollow noopener noreferrer">SpiderMonkey</a> favors doubles, Webkit is pointer-friendly.</p>
<h2 id="benchmark"><a href="#benchmark" aria-label="benchmark permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Benchmark</h2>
<p>I decided to check if there is a real difference between all those representations of dynamic types, so I prepared some time tests. <a href="https://nickdrozd.github.io/media/nanboxing/nanb_benchmark.zip">Here</a> you can download them if you wish.</p>
<p>The benchmark allocates many of our value representations, and then it stores, checks, and reads random types and data in a big loop, 500.000.000 times. The results I obtained are not so surprising:</p>
<p><span>
      <a href="https://nickdrozd.github.io/static/9618ba5f9c6ac97ae8405cfc7fee2243/c1b63/benchmark.png" target="_blank" rel="noopener">
    <span></span>
  <picture>
          <source srcset="/static/9618ba5f9c6ac97ae8405cfc7fee2243/8ac56/benchmark.webp 240w,
/static/9618ba5f9c6ac97ae8405cfc7fee2243/d3be9/benchmark.webp 480w,
/static/9618ba5f9c6ac97ae8405cfc7fee2243/e46b2/benchmark.webp 960w,
/static/9618ba5f9c6ac97ae8405cfc7fee2243/92f8c/benchmark.webp 1200w" sizes="(max-width: 960px) 100vw, 960px" type="image/webp"/>
          <source srcset="/static/9618ba5f9c6ac97ae8405cfc7fee2243/8ff5a/benchmark.png 240w,
/static/9618ba5f9c6ac97ae8405cfc7fee2243/e85cb/benchmark.png 480w,
/static/9618ba5f9c6ac97ae8405cfc7fee2243/d9199/benchmark.png 960w,
/static/9618ba5f9c6ac97ae8405cfc7fee2243/c1b63/benchmark.png 1200w" sizes="(max-width: 960px) 100vw, 960px" type="image/png"/>
          <img src="https://nickdrozd.github.io/static/9618ba5f9c6ac97ae8405cfc7fee2243/d9199/benchmark.png" alt="Benchmark chart" title="Benchmark chart" loading="lazy"/>
        </picture>
  </a>
    </span></p>
<p>Conclusion: struct size matters. The smaller our structure is, the faster it can be loaded into CPU registers and everything should work more efficiently. </p>
<p>I noticed that there is little performance difference between tagged pointers and NaN boxing. Actually, they have the same memory print and similar techniques for assignments and reads. This might be another reason why both these solutions are popular in e.g. JavaScript implementations.</p>
<h2 id="summary"><a href="#summary" aria-label="summary permalink"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Summary</h2>
<p>When I noticed the NaN boxing method for the first time in Robert Nystrom’s book <a href="https://craftinginterpreters.com/optimization.html" target="_blank" rel="nofollow noopener noreferrer">Crafting Interpreters</a>, it really surprised me. It is so tricky, but as a great admirer of tiny optimizations, I consider it beautiful as well. </p>
<p>However, there is little information about it around the web despite its popularity among language hackers. It is always great to discover such tricks and to test them, as the knowledge of how things work under the hood makes you always be a little better programmer, writing a little more efficient things. </p></div></div>
  </body>
</html>
