<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.joshtumath.uk/posts/2024-11-08-how-a-bbc-navigation-bar-component-broke-depending-on-which-external-monitor-it-was-on/">Original</a>
    <h1>A BBC navigation bar component broke depending on the external monitor</h1>
    
    <div id="readability-page-1" class="page"><div><p>Recently, my team and I fixed an absolutely bizarre bug that only one person in the team could reproduce. And to make it even weirder, she was only able to reproduce the issue when using her work laptop at home; it worked fine with the same laptop in the office.</p><h2 id="heading-so-what-was-the-bug">So what was the bug?<a href="#heading-so-what-was-the-bug"><span> permalink</span><svg fill="currentColor" aria-hidden="true" focusable="false" width="1em" height="1em" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.199 13.599a5.99 5.99 0 0 0 3.949 2.345 5.987 5.987 0 0 0 5.105-1.702l2.995-2.994a5.992 5.992 0 0 0 1.695-4.285 5.976 5.976 0 0 0-1.831-4.211 5.99 5.99 0 0 0-6.431-1.242 6.003 6.003 0 0 0-1.905 1.24l-1.731 1.721a.999.999 0 1 0 1.41 1.418l1.709-1.699a3.985 3.985 0 0 1 2.761-1.123 3.975 3.975 0 0 1 2.799 1.122 3.997 3.997 0 0 1 .111 5.644l-3.005 3.006a3.982 3.982 0 0 1-3.395 1.126 3.987 3.987 0 0 1-2.632-1.563A1 1 0 0 0 9.201 13.6zm5.602-3.198a5.99 5.99 0 0 0-3.949-2.345 5.987 5.987 0 0 0-5.105 1.702l-2.995 2.994a5.992 5.992 0 0 0-1.695 4.285 5.976 5.976 0 0 0 1.831 4.211 5.99 5.99 0 0 0 6.431 1.242 6.003 6.003 0 0 0 1.905-1.24l1.723-1.723a.999.999 0 1 0-1.414-1.414L9.836 19.81a3.985 3.985 0 0 1-2.761 1.123 3.975 3.975 0 0 1-2.799-1.122 3.997 3.997 0 0 1-.111-5.644l3.005-3.006a3.982 3.982 0 0 1 3.395-1.126 3.987 3.987 0 0 1 2.632 1.563 1 1 0 0 0 1.602-1.198z"></path></svg></a></h2><p>The BBC&#39;s UK website uses a <code>click</code> event to respond to when a user activates the &#39;More&#39; button. <code>click</code> events aren&#39;t just activated by the click of a mouse; they can also be activated by touch and the &#39;enter&#39; or &#39;space&#39; keys on a keyboard.</p><p><img src="https://bjorg.bjornroche.com/images/2024-11-08-bbc-global-nav.png" alt="Screenshot of BBC global navigation bar opened using the &#39;more&#39; button." loading="lazy" width="792" height="280"/></p><p>Our &#39;more&#39; button should open a menu. However, when she was clicking on it at home, the <code>click</code> event didn&#39;t seem to do anything. Instead, the menu opened using our no-JavaScript fallback behaviour.</p><p><em>That&#39;s strange.</em> ðŸ’­</p><p>When we looked into it a bit more, we found out that the bug only happened when her web browser window was on one of her external monitors. She had two external monitors and it happened on both. But when she clicked the button on her laptop screen, the button worked as expected.</p><p><em>What?</em> ðŸ¤¯</p><p>And to make it even stranger, the bug didn&#39;t happen in Safari.</p><p><em>What? What? What?</em> ðŸ¤¯ ðŸ¤¯ ðŸ¤¯</p><p>So why on earth was something like a user&#39;s external monitor set up affecting <code>click</code> events on our website? And why was this bug not happening to everyone else in our team who used an external monitor? It was very strange indeed.</p><h2 id="heading-reproducing-the-issue">Reproducing the issue<a href="#heading-reproducing-the-issue"><span> permalink</span><svg fill="currentColor" aria-hidden="true" focusable="false" width="1em" height="1em" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.199 13.599a5.99 5.99 0 0 0 3.949 2.345 5.987 5.987 0 0 0 5.105-1.702l2.995-2.994a5.992 5.992 0 0 0 1.695-4.285 5.976 5.976 0 0 0-1.831-4.211 5.99 5.99 0 0 0-6.431-1.242 6.003 6.003 0 0 0-1.905 1.24l-1.731 1.721a.999.999 0 1 0 1.41 1.418l1.709-1.699a3.985 3.985 0 0 1 2.761-1.123 3.975 3.975 0 0 1 2.799 1.122 3.997 3.997 0 0 1 .111 5.644l-3.005 3.006a3.982 3.982 0 0 1-3.395 1.126 3.987 3.987 0 0 1-2.632-1.563A1 1 0 0 0 9.201 13.6zm5.602-3.198a5.99 5.99 0 0 0-3.949-2.345 5.987 5.987 0 0 0-5.105 1.702l-2.995 2.994a5.992 5.992 0 0 0-1.695 4.285 5.976 5.976 0 0 0 1.831 4.211 5.99 5.99 0 0 0 6.431 1.242 6.003 6.003 0 0 0 1.905-1.24l1.723-1.723a.999.999 0 1 0-1.414-1.414L9.836 19.81a3.985 3.985 0 0 1-2.761 1.123 3.975 3.975 0 0 1-2.799-1.122 3.997 3.997 0 0 1-.111-5.644l3.005-3.006a3.982 3.982 0 0 1 3.395-1.126 3.987 3.987 0 0 1 2.632 1.563 1 1 0 0 0 1.602-1.198z"></path></svg></a></h2><p>We wanted to be able to reproduce the bug to properly investigate it, so we needed to understand what it was in her home environment that triggered it.</p><p>Since the bug only occurred on her external monitors, we noticed that it stopped if she repositioned them in the OS settings. Her external monitors were positioned above her laptop, so once we replicated that arrangement in our OS settings, we were finally able to reproduce the bug, too.</p><p><em>Bingo!</em></p><p><img src="https://bjorg.bjornroche.com/images/2024-11-08-multi-monitor-negative.png" alt="Screenshot of macOS display settings. Second monitor is shown arranged top left of the built-in laptop monitor." loading="lazy" width="1516" height="916"/></p><h2 id="heading-our-investigation">Our investigation<a href="#heading-our-investigation"><span> permalink</span><svg fill="currentColor" aria-hidden="true" focusable="false" width="1em" height="1em" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.199 13.599a5.99 5.99 0 0 0 3.949 2.345 5.987 5.987 0 0 0 5.105-1.702l2.995-2.994a5.992 5.992 0 0 0 1.695-4.285 5.976 5.976 0 0 0-1.831-4.211 5.99 5.99 0 0 0-6.431-1.242 6.003 6.003 0 0 0-1.905 1.24l-1.731 1.721a.999.999 0 1 0 1.41 1.418l1.709-1.699a3.985 3.985 0 0 1 2.761-1.123 3.975 3.975 0 0 1 2.799 1.122 3.997 3.997 0 0 1 .111 5.644l-3.005 3.006a3.982 3.982 0 0 1-3.395 1.126 3.987 3.987 0 0 1-2.632-1.563A1 1 0 0 0 9.201 13.6zm5.602-3.198a5.99 5.99 0 0 0-3.949-2.345 5.987 5.987 0 0 0-5.105 1.702l-2.995 2.994a5.992 5.992 0 0 0-1.695 4.285 5.976 5.976 0 0 0 1.831 4.211 5.99 5.99 0 0 0 6.431 1.242 6.003 6.003 0 0 0 1.905-1.24l1.723-1.723a.999.999 0 1 0-1.414-1.414L9.836 19.81a3.985 3.985 0 0 1-2.761 1.123 3.975 3.975 0 0 1-2.799-1.122 3.997 3.997 0 0 1-.111-5.644l3.005-3.006a3.982 3.982 0 0 1 3.395-1.126 3.987 3.987 0 0 1 2.632 1.563 1 1 0 0 0 1.602-1.198z"></path></svg></a></h2><p>We had two clues to begin our investigation:</p><ul><li><strong>1st clue:</strong> <mark>The bug didn&#39;t occur on Safari</mark>.</li><li><strong>2nd clue:</strong> <mark>The bug only happened when the external monitors were positioned above and left of the main monitor</mark>.</li></ul><p>Our next step was to investigate our &#39;more&#39; button&#39;s <code>click</code> event handler function.</p><p>While reproducing the issue, a <code>console.log</code> of our &#39;more&#39; button&#39;s click event showed our <strong>3rd clue:</strong> that, <mark>on Chrome and Firefox, the <code>screenX</code> and <code>screenY</code> properties were negative numbers</mark>.</p><blockquote><p><strong>Note:</strong></p></blockquote><p>That surprised me, because I didn&#39;t know those properties were allowed to have negative numbers. I checked the <a href="https://w3c.github.io/uievents/#dom-mouseevent-screenx">DOM UI Events spec</a> to see if that was correct, but there didn&#39;t seem to be any specific information about it.</p><p>With some <a href="https://www.youtube.com/watch?v=iwzOhHFGZKw">Ace Attorney Investigations-style logic</a>, when we put together the fact that <mark>the bug didn&#39;t occur on Safari</mark> and that, <mark>on Chrome and Firefox, the <code>screenX</code> and <code>screenY</code> properties were negative numbers</mark>, we could deduce that browsers have an interoperability issue in how they represent screen coordinates in multi-monitor set ups.</p><p><img src="https://bjorg.bjornroche.com/images/2024-11-08-aai-logic.gif" alt="Animation of the logic sequence in Ace Attorney Investigations. The player picks from clues to connect and the game shows if they successfully connected." loading="lazy" width="400" height="225"/></p><blockquote><p><strong>Note:</strong></p></blockquote><p>That knowledge gave rise to our <strong>4th clue:</strong> <mark>the bug only occurred if <code>screenX</code> and <code>screenY</code> were negative</mark>.</p><p>With some more Ace Attorney Investigations-style deductions, when we combined that with our 2nd clue â€“ that <mark>the bug only happened when the external monitors were positioned above and left of the main monitor</mark> â€“ we could deduce our <strong>5th clue:</strong> <mark>on Chrome and Firefox, the <code>screenX</code> and <code>screenY</code>&#39;s (0,0) coordinate is the top left of the main monitor</mark>.</p><p>On a multi-monitor set up, browsers&#39; screen coordinate systems treat multiple monitors as if it were one big monitor. So two 800px wide monitors positioned horizontally would have <em>x</em> coordinates ranging of 0 to 1600. On Safari, that range is always a positive number starting from the top left most monitor, but it looks like, in Chrome and Firefox, they are relative to the main monitor instead and use negative coordinates.</p><p>We needed to find the <code>click</code> event handler in our code and see how it was reading the <code>screenX</code> and <code>screenY</code> coordinates from the <code>event</code> object.</p><p>This is what we found:</p><pre><code><span><span>const</span> <span>isInvokedByMouse</span> <span>=</span> <span>event</span> <span>=&gt;</span> event<span>.</span>screenX <span>&gt;</span> <span>0</span> <span>||</span> event<span>.</span>screenY <span>&gt;</span> <span>0</span><span>;</span></span></code></pre><p>The <code>isInvokedByMouse</code> was checking whether the <code>click</code> event was invoked by a mouse or touch pointer â€“ rather than a keyboard â€“ by checking if the <code>screenX</code> or <code>screenY</code> coordinates were a positive number.</p><p>That gave us our <strong>final clue:</strong> <mark>the code assumes <code>click</code> events invoked by pointers have positive <code>screenX</code> and <code>screenY</code> coordinate numbers</mark>.</p><p>When a user clicked the &#39;more&#39; button on a monitor with negative screen coordinates, the event handler wasn&#39;t acknowledging the click and instead falling back to the default behaviour of the &#39;more&#39; button.</p><p>We could finally finish our investigation. We could deduce from our final two clues the solution: <strong>we need to check for negative numbers as well as positive numbers when checking the <code>screenX</code> and <code>screenY</code> coordinates.</strong></p><h2 id="heading-the-fix">The fix<a href="#heading-the-fix"><span> permalink</span><svg fill="currentColor" aria-hidden="true" focusable="false" width="1em" height="1em" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.199 13.599a5.99 5.99 0 0 0 3.949 2.345 5.987 5.987 0 0 0 5.105-1.702l2.995-2.994a5.992 5.992 0 0 0 1.695-4.285 5.976 5.976 0 0 0-1.831-4.211 5.99 5.99 0 0 0-6.431-1.242 6.003 6.003 0 0 0-1.905 1.24l-1.731 1.721a.999.999 0 1 0 1.41 1.418l1.709-1.699a3.985 3.985 0 0 1 2.761-1.123 3.975 3.975 0 0 1 2.799 1.122 3.997 3.997 0 0 1 .111 5.644l-3.005 3.006a3.982 3.982 0 0 1-3.395 1.126 3.987 3.987 0 0 1-2.632-1.563A1 1 0 0 0 9.201 13.6zm5.602-3.198a5.99 5.99 0 0 0-3.949-2.345 5.987 5.987 0 0 0-5.105 1.702l-2.995 2.994a5.992 5.992 0 0 0-1.695 4.285 5.976 5.976 0 0 0 1.831 4.211 5.99 5.99 0 0 0 6.431 1.242 6.003 6.003 0 0 0 1.905-1.24l1.723-1.723a.999.999 0 1 0-1.414-1.414L9.836 19.81a3.985 3.985 0 0 1-2.761 1.123 3.975 3.975 0 0 1-2.799-1.122 3.997 3.997 0 0 1-.111-5.644l3.005-3.006a3.982 3.982 0 0 1 3.395-1.126 3.987 3.987 0 0 1 2.632 1.563 1 1 0 0 0 1.602-1.198z"></path></svg></a></h2><p>As is often the case with bugs, the problem was very complex to figure out, but the solution was very simple.</p><p>All we had to do was change the <code>isInvokedByMouse</code> to check that <code>screenX</code> and <code>screenY</code> don&#39;t equal 0, rather than checking if they are greater than 0.</p><pre><code><span><span>const</span> <span>isInvokedByMouse</span> <span>=</span> <span>event</span> <span>=&gt;</span></span></code></pre><p>Now everyone with weird multi-monitor layouts can enjoy the BBC website&#39;s navigation bar in peace.</p><p>We should probably do further refactoring of the event handler function, since it&#39;s complicated by the fact that it also handles <code>keydown</code> events. For now, though, this fix will do just fine.</p><p>So that was fun! Who would have thought web developers could break an experience for users because of which monitor they&#39;re viewing the page on?</p></div></div>
  </body>
</html>
