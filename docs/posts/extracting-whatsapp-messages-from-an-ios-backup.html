<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://yasoob.me/posts/extracting-whatsapp-messages-from-ios-backup/">Original</a>
    <h1>Extracting WhatsApp Messages from an iOS Backup</h1>
    
    <div id="readability-page-1" class="page"><article itemscope="" itemtype="http://schema.org/BlogPosting">
			<span>
				<a target="_blank" href="https://github.com/yasoob/personal_blog/tree/master/content/posts/extracting-whatsapp-messages-from-ios-backup.md">Source</a>
			</span>
			
				<p><img src="https://d33wubrfki0l68.cloudfront.net/beeed8136dcd6b6747fd7e52491c1ea5223feea5/df4eb/images/exploring-ios-backup/hero.png"/>
				</p>
			
			
			<span>
				
				<time itemprop="datePublished" datetime="2022-04-24">April 24, 2022</time>
				
			</span>
			<section itemprop="entry-text">
				

<p>Hi everyone! üëã I was recently exploring how to get a local backup of WhatsApp messages from my iPhone. I switched from Android to iOS in the past and lost all of my WhatsApp messages. I wanted to make sure that if I switched again from iOS to Android I don‚Äôt lose any messages. I don‚Äôt really care if I can import the messages in WhatsApp. I just don‚Äôt want to lose all of the important information I have in my chats. I don‚Äôt have any immediate plans for switching (if ever) but it seemed like a fun challenge and so I started surveying the available tools and how they work.</p>

<p>This was mostly a learning exercise for me regarding how Apple stores iOS backups and how I can selectively extract information and data from one. My target was to have a local copy of WhatsApp messages that I can read and search through locally. It would be doubly awesome if I can move the messages to an Android device but, as I mentioned before, that wasn‚Äôt my main aim.</p>

<h3 id="exploring-ios-backup">Exploring iOS backup</h3>

<p>By default, when you create an iOS backup on Mac (Catalina in my case), it is stored under <code>~/Library/Application Support/MobileSync/Backup/</code>. This folder contains sub-folders with unique device identifiers. Each sub-folder is a backup and contains a bunch of additional subfolders along with the following 4 important files:</p>

<ul>
<li><code>Info.plist</code></li>
<li><code>Manifest.db</code></li>
<li><code>Manifest.plist</code></li>
<li><code>Status.plist</code></li>
</ul>

<p>We mainly care about both of the <code>Manifest</code> files.</p>

<p>The <code>Manifest.plist</code> file is a binary Property List file that contains information about the backup. It contains:</p>

<ul>
<li>Backup keybag: The Backup keybag contains a set of data protection class keys that are different from the keys in the System keybag, and backed-up data is re-encrypted with the new class keys. Keys in the Backup keybag facilitate the secure storage of backups. We will learn about protection classes later</li>
<li>Date: This is the timestamp of a backup created or last updated</li>
<li>ManifestKey: This is the key used to encrypt Manifest.db (wrapped with protection class four)</li>
<li>WasPasscodeSet: This identifies whether a passcode was set on the device when it was last synced</li>
<li>And much more‚Ä¶</li>
</ul>

<p>Source: <a href="https://www.oreilly.com/library/view/practical-mobile-forensics/9781788839198/6c69c5a8-5226-4211-916e-9a56fd7bdd2c.xhtml">O‚ÄôReilly</a> + <a href="https://www.richinfante.com/2017/3/16/reverse-engineering-the-ios-backup">Richinfante</a></p>

<p>Whereas, the <code>Manifest.db</code> file contains all the juicy info about the files in the backup and their paths. The only problem is that the <code>Manifest.db</code> file is encrypted and we need to use the information from the <code>Manifest.plist</code> file to decrypt it. If the backup was not encrypted, we could have probably gotten away without making use of the <code>Manifest.plist</code> file.</p>

<p>We can verify that the db file is encrypted by opening it in any SQL db viewer. I used ‚Äú<a href="https://sqlitebrowser.org/">DB Browser for SQLite</a>‚Äù and it showed me this screen:</p>

<p><img src="https://nayak.io/images/exploring-ios-backup/SQLCipher%20encryption.png" alt="SQLCipher Encryption"/></p>

<p>This clearly shows that the db is encrypted. Later we will see that not only is the DB encrypted, but every file is also encrypted with its own random per-file encryption key.</p>

<h3 id="decrypting-the-manifest-db-file">Decrypting the Manifest.db file</h3>

<p>The basic decryption process is as follows:</p>

<ol>
<li>Decode the keybag stored in the <code>BackupKeyBag</code> entry of <code>Manifest.plist</code>. A high-level overview of this structure is given in the <a href="https://www.apple.com/ca/business-docs/iOS_Security_Guide.pdf">iOS Security Whitepaper</a>. The <a href="http://theiphonewiki.com/wiki/index.php?title=ITunes_Backup#BackupKeyBag">iPhone Wiki</a> describes the binary format: a 4-byte string type field, a 4-byte big-endian length field, and then the value itself.</li>
</ol>

<p>The important values are the PBKDF2 <code>ITER</code>ations and <code>SALT</code>, the double protection salt <code>DPSL</code> and iteration count <code>DPIC</code>, and then for each protection <code>CLS</code>, the <code>WPKY</code> wrapped key.</p>

<ol>
<li>Using the backup password derive a 32-byte key using the correct PBKDF2 salt and number of iterations. First, use a SHA256 round with <code>DPSL</code> and <code>DPIC</code>, then a SHA1 round with <code>ITER</code> and <code>SALT</code>.</li>
</ol>

<p>Unwrap each wrapped key according to <a href="http://www.apps.ietf.org/rfc/rfc3394.html">RFC 3394</a>.</p>

<ol>
<li><p>Decrypt the manifest database by pulling the 4-byte protection class and longer key from the <code>ManifestKey</code> in <code>Manifest.plist</code>, and unwrapping it. You now have a SQLite database with all file metadata.</p></li>

<li><p>For each file of interest, get the class-encrypted per-file encryption key and protection class code by looking in the <code>Files.file</code> database column for a binary plist containing <code>EncryptionKey</code> and <code>ProtectionClass</code> entries. Strip the initial four-byte length tag from <code>EncryptionKey</code> before using.</p></li>
</ol>

<p>Then, derive the final decryption key by unwrapping it with the class key that was unwrapped with the backup password. Then decrypt the file using AES in CBC mode with a zero IV.</p>

<p>Source: <a href="https://stackoverflow.com/questions/1498342/how-to-decrypt-an-encrypted-apple-itunes-iphone-backup/13793043#13793043">StackOverflow</a></p>

<p>If protection classes and double protection doesn‚Äôt make much sense, I would highly recommend reading the <a href="https://www.apple.com/ca/business-docs/iOS_Security_Guide.pdf">iOS Security Whitepaper</a> from page 12 onwards. It provides details about all of this and why iOS uses these protection classes.</p>

<p>If you don‚Äôt know what a <strong>Keybag</strong> is, Apple has <a href="https://support.apple.com/guide/security/aside/sec8e00e0dd8/1/web/1">decent documentation</a>:</p>

<blockquote>
<p>A data structure used to store a collection of class keys. Each type (user, device, system, backup, escrow, or iCloud Backup) has the same format.</p>

<p>A header containing: Version (set to four in iOS 12 or later), Type (system, backup, escrow, or iCloud Backup), Keybag UUID, an HMAC if the keybag is signed, and the method used for wrapping the class keys‚Äîtangling with the UID or PBKDF2, along with the salt and iteration count.</p>

<p>A list of class keys: Key UUID, Class (which file or Keychain Data Protection class), wrapping type (UID-derived key only; UID-derived key and passcode-derived key), wrapped class key, and a public key for asymmetric classes.</p>
</blockquote>

<p>We can read the <code>Manifest.plist</code> file in Python using the <a href="https://bitbucket.org/wooster/biplist/src/master/"><code>biplist</code></a> module. You can install it using <code>pip</code>:</p>

<pre><code>pip install biplist
</code></pre>

<p>And then use it like this:</p>

<pre><code>from biplist import readPlist
import os

backup_directory = os.path.expanduser(&#34;~/Library/Application Support/MobileSync/Backup/&lt;unique_id&gt;&#34;)
plist_path = os.path.join(backup_directory, &#34;Manifest.plist&#34;)
plist = readPlist(&#34;Manifest.plist&#34;)
</code></pre>

<p><strong>Note:</strong> Don‚Äôt forget to replace <code>&lt;unique_id&gt;</code> with the name of you particular device backup folder.</p>

<p>This is what the <code>plist</code> contents would look like:</p>

<p><img src="https://d33wubrfki0l68.cloudfront.net/0fb5091bbd01fa10f7db3b5b2f6d91c1398a50da/6d95d/images/exploring-ios-backup/image-20220423162825355.png" alt="Manifest.plist"/></p>

<p>From this dict, we require the <code>backupKeyBag</code> and <code>ManifestKey</code>. It will help us decrypt the <code>Manifest.db</code> file. The <code>BackupKeybag</code> is a binary string with the following format:</p>

<ul>
<li>4-byte block identifier</li>
<li>4-byte block length (most significant byte first), length 4 means total block length of 0xC bytes.</li>
<li>data</li>
</ul>

<p>The first block is ‚ÄúVERS‚Äù with a version number of 3. There are a lot of block types: VERS, TYPE, UUID, HMCK, WRAP, SALT, ITER, UUID, CLAS, WRAP, KTYP, WPKY, etc.</p>

<p>Source: <a href="https://www.theiphonewiki.com/wiki/ITunes_Backup#BackupKeyBag">IPhone Wiki</a></p>

<h3 id="decrypting-the-keybag">Decrypting the keybag</h3>

<p>There are quite a few resources available online that show you how you can decrypt the keybag. It uses PBKDF2 for key generation and AES for encryption. You can take a look at <a href="https://stackoverflow.com/a/13793043">this StackOverflow answer</a> for working Python code to decrypt the keybag. I will be making use of the code from that answer.</p>

<p>There are a bunch of different protection classes. The one used for the manifest database is class 3. We can find this by reading the first 4 bytes of the <code>ManifestKey</code> value in our <code>Manifest.plist</code> file:</p>

<pre><code>import struct
manifest_class = struct.unpack(&#39;&lt;l&#39;, plist[&#39;ManifestKey&#39;][:4])[0]
# Output: 3
</code></pre>

<p>I encrypted my iOS backup. This is beneficial because Apple doesn‚Äôt back up sensitive data unless the backup is encrypted. Sensitive data includes stuff like WiFi passwords. Now we can use the code from StackOverflow, the initial backup encryption passphrase you used while creating the backup, and the rest of the ManifestKey from the <code>Manifest.plist</code> to decrypt the <code>Manifest.db</code> file:</p>

<pre><code>manifest_key = plist[&#39;ManifestKey&#39;][4:]

kb = Keybag(plist[&#39;BackupKeyBag&#39;])
kb.unlockWithPassphrase(&#39;passphrase&#39;)
key = kb.unwrapKeyForClass(manifest_class, manifest_key)

with open(&#39;Manifest.db&#39;, &#39;rb&#39;) as f:
    encrypted_db = f.read()

decrypted_data = AESdecryptCBC(encrypted_db, key)

with open(&#39;decrypted_manifest.db&#39;, &#39;wb&#39;) as f:
    f.write(decrypted_data)
</code></pre>

<p>As you can see above, if you don‚Äôt remember the passphrase you used while backing up your iOS device, you can not decrypt anything. It is necessary to continue the rest of the decryption process.</p>

<p>Now if we try to open the <code>decrypted_manifest.db</code> in a SQL viewer we can see the actual data:</p>

<p><img src="https://d33wubrfki0l68.cloudfront.net/550d8e1109ea5fd842bf983034048db633115a72/03781/images/exploring-ios-backup/decrypted-manifest.png" alt="decrypted manifest.plist"/></p>

<p>We can search for all files associated with WhatsApp by doing a global search for WhatsApp. The chats are stored in a <code>ChatStorage.sqlite</code> file:</p>

<p><img src="https://d33wubrfki0l68.cloudfront.net/345556335dc42d5ba96cbd5ca096471a2ba3444c/3b4bb/images/exploring-ios-backup/whatsapp-manifest-plist.png" alt="whatsapp-manifest-plist"/></p>

<p>We can get this record using Python:</p>

<pre><code>import sqlite3

db_conn = sqlite3.connect(&#39;decrypted_manifest.db&#39;)
relative_path = &#34;Chatstorage.sqlite&#34;
query = &#34;&#34;&#34;
    SELECT fileID, file
    FROM Files
    WHERE relativePath = ?
    ORDER BY domain, relativePath
    LIMIT 1;
&#34;&#34;&#34;
cur = db_conn.cursor()
cur.execute(query, (relative_path,))
result = cur.fetchone()
file_id, file_bplist = result
</code></pre>

<p>One thing to note is that the <code>fileID</code> is made up of a hash of the domain + file name so it would probably be the same for you. It is generated like this:</p>

<pre><code>import hashlib

domain = &#34;AppDomainGroup-group.net.whatsapp.WhatsApp.shared&#34;
relative_path = &#34;ChatStorage.sqlite&#34;
hash = hashlib.sha1(f&#34;{domain}-{relative_path}&#34;.encode()).hexdigest()

# hash = 7c7fba66680ef796b916b067077cc246adacf01d
</code></pre>

<p>The record in the db contains the binary plist file associated with <code>ChatStorage.sqlite</code> file. We got a hold of that by running the above query. We can take a look inside by using the <code>readPlistFromString</code> method of the <code>biplist</code> module and extract the required information:</p>

<pre><code>from biplist import readPlistFromString
file_plist = readPlistFromString(file_bplist)

# print(file_plist)

# {&#39;$archiver&#39;: &#39;NSKeyedArchiver&#39;,
#  &#39;$objects&#39;: [&#39;$null&#39;,
#               {&#39;$class&#39;: Uid(5),
#                &#39;Birth&#39;: 1617036196,
#                &#39;EncryptionKey&#39;: Uid(3),
#                &#39;Flags&#39;: 0,
#                &#39;GroupID&#39;: 501,
#                &#39;InodeNumber&#39;: 45839007,
#                &#39;LastModified&#39;: 1650483880,
#                &#39;LastStatusChange&#39;: 1650481761,
#                &#39;Mode&#39;: 33188,
#                &#39;ProtectionClass&#39;: 3,
#                &#39;RelativePath&#39;: Uid(2),
#                &#39;Size&#39;: 22056960,
#                &#39;UserID&#39;: 501},
#               &#39;ChatStorage.sqlite&#39;,
#               {&#39;$class&#39;: Uid(4),
#                &#39;NS.data&#39;: b&#39;\x03\x00\x00\x00tE1\xd1H\n&#34;e\x06\xf7\x1cl&#39;
#                           b&#39;\x82\xed\x05\xe7\x1d\x1c\xd6\x97\x0e\xe9\x8b&#34;&#39;
#                           b&#39;\xfa\x16\x93\x9c3\x18\xbe\n\x14\x1eR;f\x98\xe3v&#39;},
#               {&#39;$classes&#39;: [&#39;NSMutableData&#39;, &#39;NSData&#39;, &#39;NSObject&#39;],
#                &#39;$classname&#39;: &#39;NSMutableData&#39;},
#               {&#39;$classes&#39;: [&#39;MBFile&#39;, &#39;NSObject&#39;], &#39;$classname&#39;: &#39;MBFile&#39;}],
#  &#39;$top&#39;: {&#39;root&#39;: Uid(1)},
#  &#39;$version&#39;: 100000}
</code></pre>

<pre><code>file_data = file_plist[&#39;$objects&#39;][file_plist[&#39;$top&#39;][&#39;root&#39;].integer]
protection_class = file_data[&#39;ProtectionClass&#39;]

encryption_key = file_plist[&#39;$objects&#39;][file_data[&#39;EncryptionKey&#39;].integer][&#39;NS.data&#39;][4:]

# file_data
# {&#39;$class&#39;: Uid(5),
#  &#39;Birth&#39;: 1617036196,
#  &#39;EncryptionKey&#39;: Uid(3),
#  &#39;Flags&#39;: 0,
#  &#39;GroupID&#39;: 501,
#  &#39;InodeNumber&#39;: 45839007,
#  &#39;LastModified&#39;: 1650483880,
#  &#39;LastStatusChange&#39;: 1650481761,
#  &#39;Mode&#39;: 33188,
#  &#39;ProtectionClass&#39;: 3,
#  &#39;RelativePath&#39;: Uid(2),
#  &#39;Size&#39;: 22056960,
#  &#39;UserID&#39;: 501}

# protection_class
# 3

# encryption_key
# ---truncated---
</code></pre>

<p>Now we need to use the keybag class (<code>kb</code>) to unwrap the encryption key from above for the specified protection class (3):</p>

<pre><code>file_decryption_key = kb.unwrapKeyForClass(protection_class, encryption_key)
</code></pre>

<h3 id="decrypting-chatstorage-sqlite">Decrypting ChatStorage.sqlite</h3>

<p>Sweet! All that is left is to decrypt the actual chat db. But where is it stored? Apple stores files in the backup folder in a predictable format. It puts them in a subdirectory with the name starting with the first two characters of fileID (eg <code>7c/7c7fba66680ef796b916b067077cc246adacf01d</code>). We can get the full path to the chat db file like this:</p>

<pre><code>filename_in_backup = os.path.join(backup_directory, file_id[:2], file_id)
</code></pre>

<p>This will allow us to open the encrypted file and decrypt it using the <code>file_decryption_key</code> we extracted above:</p>

<pre><code>with open(filename_in_backup, &#39;rb&#39;) as encrypted_file:
    encrypted_data = encrypted_file.read()

decrypted_data = AESdecryptCBC(encrypted_data, file_decryption_key)
</code></pre>

<p><strong>Note:</strong> This <code>AESdecryptCBC</code> function is a part of the code we got from StackOverflow</p>

<p>Sometimes the encryption introduces padding at the end of the data to make it a multiple of the blocksize. So we need to make sure we remove any padding from the end of the data as well:</p>

<pre><code>def removePadding(data, blocksize=16):
    n = int(data[-1])  # RFC 1423: last byte contains number of padding bytes.
    if n &gt; blocksize or n &gt; len(data):
        raise Exception(&#39;Invalid CBC padding&#39;)
    return data[:-n]
    
decrypted_data = removePadding(decrypted_data)
</code></pre>

<p>We can save this decrypted data in a new SQLite file:</p>

<pre><code>with open(&#39;decrypted_ChatStorage.sqlite&#39;, &#39;wb&#39;) as f:
    f.write(decrypted_data)
</code></pre>

<p>If we now open this new file in a SQLite browser, we can see all the tables:</p>

<p><img src="https://d33wubrfki0l68.cloudfront.net/a460589e5533f600ce534f3329f6b7f5d0146dc4/00208/images/exploring-ios-backup/whatsapp-messages-table.png" alt="WhatsApp Messages Table"/></p>

<p>The chats are stored in the <code>ZWAMESSAGE</code> table:</p>

<p><img src="https://d33wubrfki0l68.cloudfront.net/c791f3be57977d27381e67763da2b9367d932506/ddf56/images/exploring-ios-backup/whatsapp-messages.png" alt="WhatsApp Messages"/></p>

<p>If you are looking for all the media files that were sent with messages, you will have to go back to the decrypted <code>Manifest.db</code> file and filter for media files stored under <code>Message/Media</code>:</p>

<p><img src="https://d33wubrfki0l68.cloudfront.net/83ee9c57eb4f114546d11d9eeaeba1e7ed31048b/d53b2/images/exploring-ios-backup/media-manifest-plist.png" alt="media manifest.plist"/></p>

<p>You can use the following SQL query to get all of these media files:</p>

<pre><code>&#34;&#34;&#34;
SELECT fileID,
       relativePath,
       flags,
       file
FROM Files
WHERE relativePath
    LIKE &#39;Message/Media/%&#39;
&#34;&#34;&#34;
</code></pre>

<p>Now here comes the best part. You don‚Äôt have to do any of this yourself. There is already a Python program out there that can parse through your iOS backup, download all the media files, chats, and contact list, and convert them into HTML format. This way you can read your chats without porting the backup into a WhatsApp client.</p>

<p><a href="https://github.com/KnugiHK/Whatsapp-Chat-Exporter">Whatsapp-Chat-Exporter</a> works with iOS and Android ‚ú®</p>

<p>I used this tool to eventually convert all of my WhatsApp messages into HTML format for easy browsing on my laptop.</p>

<h3 id="useful-resources">Useful Resources</h3>

<p>I took some help from a bunch of different sources while writing this article. You can go through them to get a deeper understanding of some of the stuff mentioned in this article:</p>

<ul>
<li><a href="https://www.richinfante.com/2017/3/16/reverse-engineering-the-ios-backup">Reverse Engineering the iOS Backup</a> - Contains a detailed listing of all the different files in the backup folder and what they contain</li>
<li><a href="https://stackoverflow.com/a/13793043">StackOverflow: How to decrypt an encrypted Apple iTunes iPhone backup?</a> - This answer contains all the information required to successfully write a decryption program for iOS backups</li>
<li><a href="https://github.com/KnugiHK/iphone_backup_decrypt">iphone-backup-decrypt</a> - A Python tool that can decrypt a local iOS backup and help you extract files from it. This is based on the SO answer above</li>
<li><a href="https://github.com/KnugiHK/Whatsapp-Chat-Exporter">Whatsapp-Chat-Exporter</a> - A Python tool based on <code>iphone-backup-decrypt</code> that can extract WhatsApp data from iOS backup and convert it into HTML files for reading without the WhatsApp client</li>
</ul>

<h3 id="conclusion">Conclusion</h3>

<p>I hope you learned a thing or two from this article. I had a fun time diving into the weeds of iOS backups. I had no idea how Apple was storing the backup and how easy/hard it was going to be to get the particular file I wanted from that backup. Suffice to say it wasn‚Äôt too hard and taught me a few fun things in the process.</p>

			


			<section id="privacy-button-links">
    



  <ul>
    
      <li>
          <a href="https://yasoob.me/categories/programming/">programming</a>
        </li>
      <li>
          <a href="https://yasoob.me/categories/python/">python</a>
        </li>
      <li>
          <a href="https://yasoob.me/categories/reverse-engineering/">reverse-engineering</a>
        </li>
      <li>
          <a href="https://yasoob.me/categories/ios/">ios</a>
        </li></ul>

    
</section>
			</section>
		</article></div>
  </body>
</html>
