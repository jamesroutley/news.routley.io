<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://build-your-own.org/blog/20251015_db_in_3000/">Original</a>
    <h1>Build a Database in 3000 Lines with 0 Dependencies</h1>
    
    <div id="readability-page-1" class="page"><div>





<div>
<h2 id="complex-systems-are-built-from-simple-ideas">01. Complex systems
are built from simple ideas</h2>
<p>Complex software like databases, compilers, and browsers are treated
like black boxes. You use them every day as a <em>user</em>, but you
probably don’t understand them as a <em>programmer</em>, even though
they are nothing but code. Why?</p>
<ul>
<li>They have little in common with programmers’ daily task.</li>
<li>Their code bases are so large, so discouraging.</li>
</ul>
<p>But that doesn’t mean you can’t learn these things. People have built
small, toy versions of these things for learning purposes, such as <a href="https://github.com/rswier/c4">C in 4 Functions</a>, <a href="http://craftinginterpreters.com/">Crafting Interpreters</a>, <a href="https://browser.engineering/">Web Browser Engineering</a>. It
turns out that if you minimize uninteresting details and focus on the
essentials, you can recreate seemingly complex software and learn its
core ideas.</p>
<p>For compilers, some of the core ideas include:</p>
<ul>
<li>Parsing stuff with recursion.</li>
<li>Representing a program as a tree and simulate it.</li>
<li>Representing a program as a list of instructions with gotos.</li>
<li>Stack machine or register machine.</li>
</ul>
<p>None of these ideas are complicated. So a compiler is a viable and
useful exercise for programmers.</p>
<h2 id="what-are-the-core-ideas-of-databases">02. What are the core
ideas of databases?</h2>
<p>I’ve built a <a href="https://build-your-own.org/database/">small database in 3000 lines</a>
from scratch in Go to learn the core ideas of databases. It’s not that
complicated if you approach it in a certain way.</p>
<h3 id="power-loss-atomicity">2.1 Power-loss atomicity</h3>
<p>A database stores data on disk, but why not just use files? Why is
the filesystem not a database? Because databases eliminate a common
source of data corruption: partially written files caused by a crash or
power loss.</p>
<p>Video games warn you not to turn off the power while saving, because
a partially written save file can destroy all your progress. Building a
database will teach you how to eliminate this concern. The solution is
an <strong>append-only log with a checksum for each item</strong>.</p>
<ul>
<li>Append-only means that writes will not destroy existing data.</li>
<li>Checksum means that partial writes will be detected and discarded,
making appends power-loss atomic.</li>
</ul>
<pre><code>╔═══╤════╦═══╤════╦══╌╌╌══╦═══╤════╗
║sum│data║sum│data║more...║sum│data║
╚═══╧════╩═══╧════╩══╌╌╌══╩═══╧════╝
                          ╰───┬────╯
                    possible partial write</code></pre>
<p>These are the first 2 ideas. But they are not enough to build a
database.</p>
<h3 id="index-data-with-data-structures">2.2 Index data with data
structures</h3>
<p>Logs have uses for systems like Kafka, but you cannot just put
everything in a log and forget about it. You have to find stuff in it,
so you need data structures like B+trees, LSM-trees, hashtables. That’s
where I started, I built a B+tree in 366 lines.</p>
<p>But if you just put a data structure on disk, you have the partial
write problem. Is it possible to apply the log-based ideas to data
structures? There are 2 ideas:</p>
<p>The first idea is to make the data structure append-only, like a log.
There are ways to make a B+tree append-only, also called a
<strong>copy-on-write B+tree</strong>. A copy-on-write tree does not
overwrite existing nodes, it creates new nodes from leaf to root for the
entire path. New nodes can be appended like a log.</p>
<pre><code>    d           d         D*
   / \         / \       / \
  b   e  ──►  b   e  +  B*  e
 / \         / \       / \
a   c       a   c     a   C*
            original  updated</code></pre>
<p>The other idea is to use both a log and a main data structure:</p>
<ol type="1">
<li>Before updating the main data structure, store the intended updates
in the log. Each log record contains a list of “write this data to that
position”.</li>
<li>Then apply the updates to the main data structure.</li>
<li>When the databases start, it can always apply the last log record to
fix possible partial writes in the main data structure, regardless of
its status.</li>
</ol>
<p>I chose the copy-on-write B+tree because it doesn’t require a log,
which reduces the LoC. Moving the B+tree to disk involves interfacing
with the filesystem, including the <code>fsync()</code>. In 601 lines, I
have an append-only KV store on disk.</p>
<h3 id="recycle-and-reuse-unused-space">2.3 Recycle and reuse unused
space</h3>
<p>I have to handle the consequence of append-only because storage is
not infinite. I simply added a free list to recycle unused B+tree nodes.
In 731 lines, I have a practical KV store.</p>
<pre><code>                     first_item
                         ↓
list_head ─► [ next |    xxxxx ]
                ↓
             [ next | xxxxxxxx ]
                ↓
list_tail ─► [ NULL | xxxx     ]
                         ↑
                     last_item</code></pre>
<h3 id="relational-db-on-kv">2.4 Relational DB on KV</h3>
<p>A SQL query can be arbitrarily complex, but it boils down to 2 data
structure operations: point query and range query. That’s why I started
with B+tree data structures. Databases are built on data structures, not
on some theories about relations.</p>
<p>I added a layer on top of KV to store records with primary keys and
columns. Each record is encoded as KV pair. The LoC increased to 1107.
But it’s still just a KV. So I added 2 more features:</p>
<ul>
<li>Range query, 1294 lines.</li>
<li>Secondary index, 1438 lines.</li>
</ul>
<p>I didn’t bother with SQL at this point because SQL is just a user
interface. I built APIs for databases which is called a <em>storage
engine</em>.</p>
<h3 id="concurrent-control">2.5 Concurrent control</h3>
<p>I can ignore concurrency and make everything serialized. But using a
copy-on-write B+tree means that readers get snapshot isolation for free,
because updates do not destroy old versions. So readers will not be
blocked by the writer.</p>
<p>I went a step further to allow write transactions to run
concurrently, and then merge the updates at the end of the transaction.
This requires detecting and rejecting conflicting updates. In 1702
lines, I have a transactional interface.</p>
<h3 id="sql-like-query-language">2.6 SQL-like query language</h3>
<p>My user interface is just a set of APIs to operate the database. The
next step is a query language. I chose a SQL-like syntax. I only
implemented simple queries with a single point/range query, so there is
no query planner.</p>
<p>Parsing SQL is not a database topic, but a compiler topic. It’s done
by applying recursion in a specific way, which is hardly an idea once
you’ve learned it.</p>
<p>A query language is not just about data, it can do computations, like
<code>SELECT a + b FROM c</code>. So I need an interpreter.</p>
<p>Then I need lots of glue code between the query language and the
database. The lines of code increased from 1702 to 2795, most of them
uninteresting.</p>
<h2 id="database-in-3000-lines-incrementally">03. Database in 3000
lines, incrementally</h2>
<p>This is my minimalist attempt to build a database from scratch. Each
step adds an essential part while minimizing uninteresting details.</p>

<table>
<thead>
<tr>
<th>LoC</th>
<th>Step</th>
</tr>
</thead>
<tbody>
<tr>
<td>366</td>
<td>B+tree data structure.</td>
</tr>
<tr>
<td>601</td>
<td>Append-only KV.</td>
</tr>
<tr>
<td>731</td>
<td>Practical KV with a free list.</td>
</tr>
<tr>
<td>1107</td>
<td>Tables on KV.</td>
</tr>
<tr>
<td>1294</td>
<td>Range queries.</td>
</tr>
<tr>
<td>1438</td>
<td>Secondary indexes.</td>
</tr>
<tr>
<td>1461</td>
<td>Transactional interfaces.</td>
</tr>
<tr>
<td>1702</td>
<td>Concurrency control.</td>
</tr>
<tr>
<td>2795</td>
<td>SQL-like query language.</td>
</tr>
</tbody>
</table>
<h3 id="the-lessons-as-a-book">The lessons as a book</h3>
<p>I’ve turned this into a <a href="https://build-your-own.org/database/">book</a> so that you can
follow my steps. The first half of the book is free online and contains
the most interesting parts of the storage engine, which is usable as a
KV on its own.</p>

<p><a href="https://build-your-own.org/database/">
<img width="200" src="https://build-your-own.org/database/img/book_byodb_cover_1800.png" alt="Build Your Own Database"/></a></p>
<p>3000 lines is not much, but it’s an effective exercise. The first
edition took me only 2 months of free time. The book is updated whenever
I learn something new, so this is the second edition.</p>
<!-- ([Discussed on HN](https://news.ycombinator.com/item?id=42725163)) -->
</div>
</div></div>
  </body>
</html>
