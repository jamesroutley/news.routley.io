<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://interjectedfuture.com/effects-as-protocols-and-context-as-agents/">Original</a>
    <h1>Effects as Protocols and Context as Agents</h1>
    
    <div id="readability-page-1" class="page"><div id="site-main">
<article>

    <header>

        

        


        <div>
        <section>

            <ul>
                <li>
                    <a href="https://interjectedfuture.com/author/wil/">
                        <img src="https://www.gravatar.com/avatar/915aac3dfde2fb502ce415d77643a72d?s=250&amp;d=mm&amp;r=x" alt="Wil"/>
                    </a>
                </li>
            </ul>

            <div>
                <h4><a href="https://interjectedfuture.com/author/wil/">Wil</a></h4>
                <p><time datetime="2025-01-28">Jan 28, 2025</time>
                        <span><span>•</span> 11 min read</span>
                </p>
            </div>

        </section>
        </div>

            <figure>
                <img srcset="/content/images/size/w300/2025/01/DALL-E-2025-01-27-21.39.24---An-origami-inspired-illustration-emphasizing-the-concept-of-effects-through-interconnected-symbols-such-as-origami-style-arrows--folded-paper-envelope.jpeg 300w,
                            /content/images/size/w600/2025/01/DALL-E-2025-01-27-21.39.24---An-origami-inspired-illustration-emphasizing-the-concept-of-effects-through-interconnected-symbols-such-as-origami-style-arrows--folded-paper-envelope.jpeg 600w,
                            /content/images/size/w1000/2025/01/DALL-E-2025-01-27-21.39.24---An-origami-inspired-illustration-emphasizing-the-concept-of-effects-through-interconnected-symbols-such-as-origami-style-arrows--folded-paper-envelope.jpeg 1000w,
                            /content/images/size/w2000/2025/01/DALL-E-2025-01-27-21.39.24---An-origami-inspired-illustration-emphasizing-the-concept-of-effects-through-interconnected-symbols-such-as-origami-style-arrows--folded-paper-envelope.jpeg 2000w" sizes="(min-width: 1400px) 1400px, 92vw" src="https://interjectedfuture.com/content/images/size/w2000/2025/01/DALL-E-2025-01-27-21.39.24---An-origami-inspired-illustration-emphasizing-the-concept-of-effects-through-interconnected-symbols-such-as-origami-style-arrows--folded-paper-envelope.jpeg" alt="Effects as Protocols and Context as Agents"/>
            </figure>

    </header>

    <section>
        <h4 id="introduction">Introduction</h4><p>What if we thought of effects not as mysterious side operations but as conversations with an agent managing our program&#39;s context? This reframing offers a powerful perspective on how effects unify various programming paradigms, from state and exceptions to closures and continuations. By viewing effects as communication protocols with the program&#39;s context, we gain not only a more structured mental model but also the tools for building modular, extensible interpreters.</p><p>Effects—often thought of in terms of state changes or I/O—are at the core of how programs interact with their environment. But effects are more than just side operations; they are the mechanisms by which a program and its context communicate. This post dives into the concept of effects as protocols and explores why this perspective is foundational for extensible interpreters and modular programming. Whether you&#39;re designing compilers, writing functional code, or architecting distributed systems, understanding effects through this lens will elevate your approach to program design.</p><hr/><h4 id="what-are-effects-really">What Are Effects, Really?</h4><p>At its core, an effect is an interaction with the context. Context here means anything external to a specific computation: it could be state, the file system, a database, or even the set of variables in scope. When a program performs an effect, it sends a request to this context and receives a response. This interaction is bidirectional, forming a protocol between the program and the context.</p><p>Let’s clarify this with an example. Consider a program that manages state:</p><pre><code>get :: State Int Int
put :: Int -&gt; State Int ()
</code></pre><p>The <code>get</code> operation requests the current state, and <code>put</code> updates it. These operations don’t directly manipulate state; instead, they describe what the program <em>wants</em> to do. The actual state management happens in a handler that processes these requests and replies with results. This separation between effect description and effect handling is what makes the protocol explicit.</p><p>Effects, therefore, are not limited to observable changes like I/O. They encompass any interaction with the program&#39;s context, including resolving variable bindings or managing closures. Whether we treat something as an effect often depends on what level of abstraction we’re working at. For example, accessing a variable might not feel like an effect when evaluating a function, but it’s undeniably a contextual interaction when designing an interpreter.</p><hr/><h4 id="effects-as-protocols-the-communication-model">Effects as Protocols: The Communication Model</h4><p>The most useful way to understand effects is as protocols. The program sends <strong>requests</strong> to the context, and the context responds. This interaction formalizes what the program needs to proceed, and how the context provides that information. By treating effects as protocols, we gain a clear structure for reasoning about complex computations.</p><p>Let’s break this down using Oleg Kiselyov’s extensible interpreter as an example. In this model, effects are represented as requests. For instance, resolving a variable might be represented by:</p><pre><code>Req (ReqVar v) k
</code></pre><p>Here:</p><ul><li><code>ReqVar v</code> is the request to resolve the variable <code>v</code>.</li><li><code>k</code> is the continuation, or callback, that specifies what to do once the variable is resolved.</li></ul><p>Similarly, creating a closure (a function with its environment) is modeled as:</p><pre><code>Req (ReqClosure v body) k
</code></pre><p>This protocol treats the context as an agent responsible for handling these requests. For example:</p><ul><li>If a variable <code>v</code> exists in the current environment, the context retrieves its value and passes it to the continuation <code>k</code>.</li><li>If the request is for a closure, the context captures the current environment and returns a function bundled with this environment.</li></ul><p><strong>Why Protocols Matter</strong>:</p><ol><li><strong>Simplified Reasoning</strong>: By abstracting the mechanics of effects into a protocol, the program’s logic becomes more explicit and easier to follow.</li><li><strong>Modularity</strong>: Effects can be implemented or interpreted differently without changing the program’s logic. For example, state effects could be handled in memory or by a database—the protocol remains the same.</li><li><strong>Recursiveness</strong>: Protocols naturally support recursive computations where subexpressions may themselves involve effects.</li></ol><hr/><h4 id="why-formulate-effects-as-protocols">Why Formulate Effects as Protocols?</h4><p>One of the key motivations for formulating effects as protocols is the need for extensible interpreters. In traditional interpreters, adding new features like state or exceptions often requires invasive changes throughout the evaluation engine. Every piece of the interpreter must be updated to support the new feature. This tightly couples the interpreter’s logic to its features, making it harder to maintain and extend.</p><p>Treating effects as protocols solves this problem by isolating the description of an effect from its implementation. Each effect is a request that can be handled independently by a handler. For example, to add state to an interpreter, you might define:</p><pre><code>get :: StateReq
put :: Int -&gt; StateReq
</code></pre><p>And implement a handler like this:</p><pre><code>handleState :: State -&gt; Comp -&gt; Comp
handleState s (Done x) = Done x
handleState s (Req (ReqState Get) k) = handleState s (k s)
handleState s (Req (ReqState (Put newState)) k) = handleState newState (k ())
</code></pre><p>This handler processes state requests (<code>Get</code> and <code>Put</code>) without touching the rest of the interpreter. By defining effects as protocols, we decouple their handling from the core evaluation logic, enabling modular and extensible designs.</p><p>Other advantages of this approach include:</p><ul><li><strong>Composability</strong>: Handlers for different effects can be combined easily. For example, you might handle state and logging together.</li><li><strong>Reusability</strong>: Handlers can be reused across different interpreters or systems. For example, a state handler could back state with a file system, in-memory variables, or a database.</li></ul><p>Protocols also allow for <strong>dynamic extension</strong>, where new effects can be added without modifying existing code. This flexibility is particularly valuable for building domain-specific languages or experimental runtime systems.</p><hr/><h4 id="effects-and-closures-a-deep-dive">Effects and Closures: A Deep Dive</h4><p>Closures are one of the most elegant features of modern programming languages, enabling functions to carry their surrounding environment wherever they are invoked. However, from the perspective of effects as protocols, closures reveal a fascinating interaction between program and context. Closures inherently involve capturing context, which makes them a prime example of contextual interactions treated as effects.</p><p>When a closure is created, it captures the current environment, which maps variable names to their corresponding values. This environment is then bundled with the closure and carried along wherever the closure goes. In terms of effects, closure creation can be modeled as a request:</p><pre><code>Req (ReqClosure v body) k
</code></pre><p>Here:</p><ul><li><code>ReqClosure v body</code> represents the operation of creating a closure for the parameter <code>v</code> with the function body <code>body</code>.</li><li><code>k</code> is the continuation that specifies what to do after the closure is created.</li></ul><p>The handler for this request performs two critical tasks:</p><ol><li>Captures the current environment (a context interaction).</li><li>Constructs a new function (<code>DCFun</code>) that extends the environment with a new binding when the closure is invoked.</li></ol><p>Consider the following code:</p><pre><code>let f = \x -&gt; \y -&gt; x + y in
let g = f 5 in
g 3
</code></pre><p>When <code>f</code> is evaluated, the interpreter generates a closure that captures the current environment, binding <code>x</code>. When <code>f</code> is applied to <code>5</code>, the resulting closure for <code>g</code> further captures <code>x = 5</code>. Finally, invoking <code>g</code> with <code>3</code> resolves both <code>x</code> and <code>y</code> in the extended environment, computing <code>5 + 3 = 8</code>.</p><h4 id="managing-the-environment">Managing the Environment</h4><p>The environment—a mapping of variable names to values or closures—is central to how closures interact with their context. The handler maintains the environment and updates it dynamically:</p><ol><li><strong>Capturing Context</strong>: When creating a closure, the current environment is saved and frozen.</li><li><strong>Extending Context</strong>: When a closure is applied, the environment is extended with new variable bindings for the closure’s parameters.</li><li><strong>Resolving Variables</strong>: When a variable is referenced, the handler looks it up in the current environment.</li></ol><p>This recursive interaction ensures that closures remain self-contained and predictable, with no unintended interference between different parts of the program. The environment’s immutability—each extension creates a new environment rather than modifying the old one—further ensures that closures behave consistently.</p><h4 id="code-walkthrough-nested-closures">Code Walkthrough: Nested Closures</h4><p>Let’s walk through a detailed example of nested closures:</p><pre><code>let f = \x -&gt; \y -&gt; x + y in
let g = f 2 in
g 3
</code></pre><p><strong>Create <code>f</code></strong>:</p><ul><li><code>Req (ReqClosure &#34;x&#34; (\y -&gt; x + y)) Done</code></li><li>The handler creates a closure:</li></ul><pre><code>DCFun $ \x -&gt; handleVar (&#34;x&#34;, x : env) (\y -&gt; x + y)
</code></pre><p><strong>Assign <code>g = f 2</code></strong>:</p><ul><li>Apply the closure <code>f</code> to <code>2</code>:</li></ul><pre><code>app (DCFun $ \x -&gt; ...) 2
</code></pre><ul><li>The environment is extended: <code>(&#34;x&#34;, 2)</code>.</li><li>A new closure is returned:</li></ul><pre><code>DCFun $ \y -&gt; handleVar (&#34;y&#34;, y : &#34;x&#34;, 2 : env) (x + y)
</code></pre><p><strong>Invoke <code>g 3</code></strong>:</p><ul><li>Apply the closure <code>g</code> to <code>3</code>:</li></ul><pre><code>app (DCFun $ \y -&gt; ...) 3
</code></pre><ul><li>The environment is extended: <code>(&#34;y&#34;, 3), (&#34;x&#34;, 2)</code>.</li><li>Resolves <code>x + y</code> as <code>2 + 3 = 5</code>.</li></ul><p>This example demonstrates how closures, environments, and effects intertwine to create a modular and extensible mechanism for managing contextual interactions.</p><h3 id="why-effects-are-perspective-dependent">Why Effects Are Perspective-Dependent</h3><p>One of the fascinating aspects of effects is how their interpretation shifts based on the lens through which we view computation. Effects can be considered context interactions, but what we choose to define as an effect depends heavily on our goals and focus. This perspective shapes how we design, implement, and reason about our systems.</p><h4 id="viewing-effects-in-context">Viewing Effects in Context</h4><p>At the lowest level, every interaction with the context can be treated as an effect. For example:</p><ul><li>Accessing a variable involves querying the current environment.</li><li>Creating a closure involves capturing a surrounding context of variable bindings.</li></ul><p>From this viewpoint, even basic operations like variable lookups are contextual interactions, and thus, effects.</p><p>However, at a higher abstraction level, these interactions may not be regarded as effects. For instance, in functional programming, accessing a variable is often treated as a pure operation because it is deterministic and fully encapsulated within the program logic. The same operation could be seen as an effect in a compiler where performance optimizations require considering the cost of variable access.</p><h4 id="practical-examples-of-perspective">Practical Examples of Perspective</h4><p><strong>Expression Evaluation</strong>:</p><ul><li>When focusing on the result of a computation, the emphasis is on observable side effects, like state changes, I/O operations, or exceptions. Variable lookups and function calls are often abstracted away as pure operations.</li></ul><p><strong>Performance Optimization</strong>:</p><ul><li>Compilers, on the other hand, must treat even basic operations like variable lookups as effects. For example, accessing a local variable versus a global variable might differ in cost, making such distinctions crucial during optimization.</li></ul><p><strong>System Design</strong>:</p><ul><li>When building extensible interpreters or domain-specific languages, effects are explicitly modeled to simplify reasoning and modularity. Here, even the act of resolving a variable or managing a closure may be treated as an effectful operation.</li></ul><h4 id="effects-as-abstraction-boundaries">Effects as Abstraction Boundaries</h4><p>The key insight is that effects serve as abstraction boundaries. They let us compartmentalize the parts of a system we want to reason about explicitly while abstracting away others. By treating context interactions as protocols, we focus on how different components communicate, leaving implementation details to handlers or the runtime.</p><p>This abstraction also enables different degrees of modularity. For instance:</p><ul><li>Algebraic effects allow the separation of effect declarations from their implementations.</li><li>Protocol-based systems like event-driven architectures encapsulate interactions between components.</li></ul><p>Whether something is an effect or a pure operation depends on where we draw the boundary—and this boundary is determined by the system’s goals.</p><hr/><h3 id="why-monads-naturally-arise">Why Monads Naturally Arise</h3><p>Monads have long been the cornerstone for managing effects in functional programming. They provide a structured way to encapsulate context interactions while preserving equational reasoning and modularity. What makes monads particularly elegant is how naturally they emerge from the need to manage sequential context interactions.</p><h4 id="sequencing-interactions">Sequencing Interactions</h4><p>At their core, effects involve sequencing: one interaction with the context depends on the result of a previous interaction. Monads formalize this sequencing by encapsulating both the context and the continuation—what happens next—into a single abstraction.</p><p>Take the state monad as an example:</p><pre><code>newtype State s a = State { runState :: s -&gt; (a, s) }

instance Monad (State s) where
  return x = State $ \s -&gt; (x, s)
  (State f) &gt;&gt;= g = State $ \s -&gt; let (a, s&#39;) = f s
                                   in runState (g a) s&#39;
</code></pre><p>This structure accomplishes two key things:</p><ol><li><strong>Context Management</strong>: The state (<code>s</code>) is threaded through each computation.</li><li><strong>Continuation Chaining</strong>: Each computation produces a result (<code>a</code>) and an updated context (<code>s&#39;</code>), which are passed to the next computation (<code>g</code>).</li></ol><h4 id="monads-as-protocols">Monads as Protocols</h4><p>Monads encapsulate context interactions by defining two operations:</p><ol><li><strong><code>return</code></strong>: Embeds a value into the monadic context.</li><li><strong><code>&gt;&gt;=</code> (bind)</strong>: Sequences computations by chaining their interactions with the context.</li></ol><p>This mirrors the protocol-like structure of effects:</p><ul><li>A computation describes what it needs from the context (e.g., <code>get</code>, <code>put</code>, <code>throw</code>).</li><li>The monadic structure determines how these requests are sequenced and how their results flow through subsequent computations.</li></ul><h4 id="algebraic-effects-vs-monads">Algebraic Effects vs. Monads</h4><p>While monads are powerful, they intertwine the description of effects with their sequencing. Algebraic effects take this one step further by decoupling these concerns:</p><ul><li><strong>Monads</strong>: Encapsulate both the description and the sequencing of effects.</li><li><strong>Algebraic Effects</strong>: Separate the declaration of effects (e.g., <code>get</code>, <code>put</code>) from their interpretation (handlers).</li></ul><p>This separation allows for greater composability and modularity. For example, an algebraic effect system can handle state, exceptions, and I/O independently, combining them only where necessary.</p><h4 id="monads-in-practice">Monads in Practice</h4><p>Monads are widely used in functional programming languages like Haskell because they:</p><ol><li><strong>Preserve Equational Reasoning</strong>: Monads enforce explicit sequencing, making it easier to reason about dependencies between computations.</li><li><strong>Encourage Modularity</strong>: Different monads (e.g., <code>State</code>, <code>Reader</code>, <code>IO</code>) can encapsulate distinct types of effects, enabling reusable and composable abstractions.</li><li><strong>Unify Context Interactions</strong>: Monads provide a consistent interface for describing and managing effects, regardless of their nature.</li></ol><p>By managing effects through monads, programmers gain control over the flow of context interactions, ensuring that programs remain predictable and maintainable.</p><hr/><h3 id="challenges-and-counterarguments">Challenges and Counterarguments</h3><p>While the perspective of effects as context interactions is powerful, it is not without challenges. There are practical limitations and critiques, especially when it comes to composability, reasoning, and implementation.</p><h4 id="composability-issues">Composability Issues</h4><p>One of the most significant challenges with effects is composability. While algebraic effects and monads provide frameworks for managing effects, some effects do not compose cleanly:</p><ul><li><strong>Non-Commutative Effects</strong>: Certain effects, like state and continuations, interact in non-intuitive ways. For example, combining <code>State</code> and <code>Cont</code> (continuations) can lead to subtle bugs because their interactions depend on the order of operations.</li><li><strong>Nested Effects</strong>: Handling multiple layers of effects (e.g., state within I/O within exceptions) can introduce significant complexity, especially when effects need to interleave.</li></ul><h4 id="observable-effects">Observable Effects</h4><p>Observable side effects, like I/O, present unique challenges for reasoning and modularity:</p><ul><li><strong>Equational Reasoning</strong>: Observable effects break the ability to substitute expressions freely because the order of operations matters.</li><li><strong>Encapsulation</strong>: Unlike algebraic effects, observable effects often require tight coupling with the runtime, making them harder to abstract and test.</li></ul><h4 id="broader-critiques">Broader Critiques</h4><p>Some critics argue that treating all context interactions as effects can dilute the concept of effects. For example, resolving a variable in a closure might be seen as &#34;too low-level&#34; to warrant modeling as an effect in most practical systems. The balance between theoretical purity and practical applicability remains an ongoing discussion.</p><hr/><h3 id="practical-implications-for-programmers">Practical Implications for Programmers</h3><p>Understanding effects as protocols has profound implications for how we design, implement, and reason about programs. By explicitly modeling effects, we gain modularity, clarity, and control over program behavior.</p><h4 id="how-to-think-about-effects">How to Think About Effects</h4><p><strong>Explicit Boundaries</strong>:</p><ul><li>Treat effects as abstraction boundaries. Anything crossing a boundary—whether state, I/O, or variable lookup—should be modeled explicitly to ensure clarity and modularity.</li></ul><p><strong>Protocol Design</strong>:</p><ul><li>Design effects as protocols between your program and its context. For example, state effects might describe &#34;get&#34; and &#34;put&#34; operations, while exceptions might define &#34;throw&#34; and &#34;catch&#34; operations.</li></ul><p><strong>Use Handlers</strong>:</p><ul><li>Handlers centralize the implementation of effects, making it easier to modify or extend their behavior without disrupting the program’s logic.</li></ul><h4 id="language-design-lessons">Language Design Lessons</h4><p>Many modern programming languages incorporate ideas from this perspective:</p><ul><li><strong>Haskell</strong>: Uses monads to manage effects, providing explicit sequencing and control.</li><li><strong>Koka</strong>: Emphasizes algebraic effects, decoupling effect declaration from interpretation.</li><li><strong>Elm</strong>: Treats effects as explicit commands (<code>Cmd Msg</code>), which are passed to the runtime for execution.</li></ul><h4 id="everyday-programming">Everyday Programming</h4><p>For everyday programmers, this perspective encourages a disciplined approach to managing complexity:</p><ul><li>Use monads or algebraic effects to encapsulate and isolate context interactions.</li><li>Model effects explicitly in interfaces to make dependencies clear.</li><li>Leverage handlers to modularize and extend behavior as your system grows.</li></ul><hr/><h3 id="conclusion">Conclusion</h3><p>Effects are best understood as protocols for interacting with context. This perspective provides a unifying lens through which we can manage state, I/O, exceptions, and even closures. By treating effects explicitly, we enable modularity, extensibility, and clearer reasoning about program behavior.</p><p>From designing compilers to writing functional programs to building scalable systems, the key insight is that effects are tools for abstraction. Whether implemented as monads, algebraic effects, or something else entirely, they provide a structured way to manage the interplay between a program and its context.</p><p>Understanding effects through this lens doesn’t just make you a better programmer—it fundamentally changes how you think about computation.</p>
    </section>


</article>
</div></div>
  </body>
</html>
