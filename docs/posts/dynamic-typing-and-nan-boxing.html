<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://averyburke.github.io//blog/2023/09/12/Nan-Boxing.html">Original</a>
    <h1>Dynamic Typing and NaN Boxing</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
    <p>I’m making a Lisp.  And I’m checking it twice. My Lisp, like most Lisp dialects, is <em>dynamically-typed</em>.  There are many ways to define dynamic typing. But for the purposes of this post the following definition will be the most helpful: <strong>in a dynamically-typed language type checking happens at runtime</strong>. Dynamically typed languages benefit from more flexible code than their statically typed counterparts. Variables don’t require type declarations and they can be reassigned data of different types, at different stages, in the same execution scope. And in dynamically typed languages functions can accept and return any type of data.</p>

<p>If you type check at runtime you need a way to store values and type information while the program is being evaluated.  The obvious way to store this information is out of band; that is, store the value and the type information separately. But the value will need to be associated with the type somehow and the most common solutions to this problem have disadvantages (described below) when it comes to memory usage and speed.  In this post I’ll describe a clever optimization called <em>NaN Boxing</em> that addresses these issues by storing the value and the type together in one 64 bit representation.</p>

<p>“NaN” is an abbreviation for “not a number”. Most programming languages support <a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format">IEEE 754 double precision floating point numbers</a> (<em>doubles</em>), which is a format with well-defined operations supported directly on modern CPUs. NaN is a special value in doubles that usually turns up when you do operations the CPU wasn’t prepared for, like getting the square root of -1.</p>

<p>NaN Boxing works by storing data in the unused bits of NaN. By the way, NaN has unused bits. The idea is that every value can be stored in the space of a double. Valid doubles can be read directly and all the other types have their data stuffed into those fallow NaN bits I just mentioned. Before I go into further detail it will be helpful to know a little more about how doubles are represented internally.</p>



<p>A double is an 8 byte (64 bit) representation of a floating point number. Sections of the bits of a double are designated to represent different aspects of the floating point number. I hereby submit my contribution to the already voluminous corpus of illustrations of IEEE 754 standard for representing a double precision floating-point number. Behold!</p>

<figure>
    <pre>        <div>
            <div>
                <p><span>sign</span></p>
                <p><span>exponent</span></p>
                <p><span>mantissa</span></p>
                <p><span>s</span></p>
                <p><span>eeeeeee</span></p>
                <p><span>eeee<span>mmmm</span></span></p>
                <p><span>mmmmmmmm</span></p>
                <p><span>mmmmmmmm</span></p>
                <p><span>mmmmmmmm</span></p>
                <p><span>mmmmmmmm</span></p>
                <p><span>mmmmmmmm</span></p>
                <p><span>mmmmmmmm</span></p>
                <p><span> = (-1)<sup><span>s</span></sup> * <span>m</span><sup><span>e</span></sup></span></p>
            </div>
        </div>
    </pre>
</figure>

<p>Going from left to right, the first bit (dubed, normatively, the <em>most significant bit</em>) is the  <span><em>sign bit</em></span>, which signals weather the number is positive or negative. The next 11 bits are the <span><em>exponent bits</em></span>. The exponent is <a href="https://en.wikipedia.org/wiki/Exponent_bias">biased</a>. This is both a standard for encoding exponents with either negative or positive values and a slanderous accusation about the exponent’s character.  An 11 bit biased exponent can represent a number between −1022 and +1023.  The remaining 52 bits are the <span><em>mantissa</em></span>. And for those of us interested in optimizing run time type checking, that’s where the magic happens.</p>

<p>Some examples of doubles:</p>
<figure>
    <pre>    <span><span>0</span> <span>01111111111</span> <span>0000000000000000000000000000000000000000000000000000</span> = 1</span>
    <span><span>1</span> <span>10000000000</span> <span>0000000000000000000000000000000000000000000000000000</span> = -2</span>
    <span><span>0</span> <span>01111111000</span> <span>0101101111110000101010000111010000100111111100000001</span> = 2.7182818</span>
    <span><span>0</span> <span>11111111111</span> <span>1000000000000000000000000000000000000000000000000000</span> = NaN</span>
    <span><span>0</span> <span>11111111111</span> <span>1000000000000000100000000000000000100000000000000000</span> = NaN</span>
    <span><span>1</span> <span>11111111111</span> <span>0101101111110000101010000111010000100111111100000001</span> = NaN</span>
</pre>
</figure>
<p>As you can see from the last three examples NaN can be encoded in many different ways. Any double whose exponent bits are all 1s is treated as Not a Number.</p>

<p>There are actually two kinds of NaNs.  If the most significant bit of the mantissa is 0, then this is a signaling NaN (<em>sNaN</em>). IEEE 754 specifies that the CPU may <a href="https://www.geeksforgeeks.org/interrupts-and-exceptions/">raise an exception</a> if an sNaN is used in certain operations. But if the most significant mantissa bit is a 1, wellsir you’ve got yourself a quiet NaN (<em>qNaN</em>).  qNaNs are produced when the result of an operation is not a number. And, most importantly for NaN boxing, qNaNs do not raise an exception, so we are free to (ab)use them without causing our program to crash.</p>

<p>IEEE 754 suggests that the mantissa of a qNaN should, <a href="https://iremi.univ-reunion.fr/IMG/pdf/ieee-754-2008.pdf#page=46"><em>by means left to the implementer’s discretion</em></a>, contain diagnostic information. We can instead use the mantissa to pass around our values and type information.</p>

<p>All the code examples below are written in C, since that’s the language in which I’m implementing my Lisp. I’m going to assume the reader has a little familiarity with that language and with the concept of <a href="https://en.wikipedia.org/wiki/Mask_(computing)">bitmasking</a>.</p>



<p>One way to store type information and values together is to use a <em>tagged union</em>. Consider the following example:</p>

<div><div><pre><code><span>struct</span> <span>Expression</span> <span>{</span>
    <span>enum</span> <span>{</span> <span>TYPE_FLOAT</span><span>,</span> <span>TYPE_INT</span><span>,</span> <span>TYPE_STRING</span> <span>}</span> <span>tag</span><span>;</span>
    <span>union</span> <span>{</span>
        <span>double</span> <span>as_float</span><span>;</span>
        <span>char</span> <span>*</span><span>as_string</span><span>;</span> 
        <span>int</span> <span>as_int</span><span>;</span> 
 <span>}</span>  <span>value</span><span>;</span>
<span>}</span>
</code></pre></div></div>
<p>An <em>Expression</em> is a struct with two fields: <code>tag</code> and <code>value</code>. The <code>value</code> field is a <em>union</em>. A union is a special data type that overlays all its members in one location in memory. The enum <code>tag</code> is meant to signal which member of the union is actually stored in the <code>value</code> field.</p>

<p>Then, a tagged union is a special structure with a value field, which could have one of several different fixed types, and a tag field that indicates which type is in use. For instance, an Expression of type float is created like this:</p>

<div><div><pre><code><span>struct</span> <span>Expression</span> <span>*</span><span>e</span> <span>=</span> <span>malloc</span><span>(</span><span>sizeof</span> <span>Expression</span><span>);</span><span>// declare e as a pointer to an Expression, allocate enough heap memory to sore e</span>
<span>e</span><span>-&gt;</span><span>tag</span> <span>=</span> <span>TYPE_FLOAT</span><span>;</span><span>// tag e as a float</span>
<span>e</span><span>-&gt;</span><span>value</span><span>.</span><span>as_float</span> <span>=</span> <span>2</span><span>.</span><span>71828</span><span>;</span><span>// store a value in e as a float</span>
</code></pre></div></div>
<p>We declare a pointer <code>e</code> to an Expression, then tag it as a float, store a value in the appropriate member of the union and then release the Expression back into the wild.</p>

<p>Operations on Expressions can then switch on the tag:</p>
<div><div><pre><code><span>void</span> <span>print_expression</span><span>(</span><span>Expression</span> <span>*</span><span>e</span><span>)</span>
<span>{</span>
    <span>switch</span><span>(</span><span>e</span><span>-&gt;</span><span>tag</span><span>)</span>
    <span>{</span>
        <span>case</span> <span>TYPE_FLOAT</span> <span>:{</span>
            <span>/* print a float */</span>
	        <span>printf</span><span>(</span><span>“</span><span>%</span><span>f</span><span>”</span><span>,</span> <span>e</span><span>-&gt;</span><span>value</span><span>.</span><span>as_float</span><span>);</span>
        <span>break</span><span>;</span>
        <span>}</span>
        <span>case</span> <span>TYPE_INT</span> <span>:{</span>
            <span>/* print an int */</span>
	        <span>printf</span><span>(</span><span>“</span><span>%</span><span>d</span><span>”</span><span>,</span> <span>e</span><span>-&gt;</span><span>value</span><span>.</span><span>as_int</span><span>);</span>
        <span>break</span><span>;</span>
        <span>}</span>
        <span>case</span> <span>TYPE_STRING</span> <span>:{</span>
            <span>/* print a string */</span>
	        <span>printf</span><span>(</span><span>“</span><span>%</span><span>s</span><span>”</span><span>,</span> <span>e</span><span>-&gt;</span><span>value</span><span>.</span><span>as_string</span><span>);</span>
        <span>break</span><span>;</span>
        <span>}</span>
       <span>default</span> <span>:</span><span>{</span>
            <span>printf</span><span>(</span><span>“</span><span>unknown</span> <span>type</span><span>”</span><span>);</span>
	    <span>break</span><span>;</span>
       <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>
<p>Without the tag we wouldn’t be able to print the value safely because we wouldn’t know which of the three possible types of data was actually stored at the <code>value</code> address.</p>

<p>Now to the disadvantages I mentioned in the introduction: Obviously the <code>tag</code> and the <code>value</code> fields of an Expression both occupy space. Further, a union must allocate <a href="https://www.geeksforgeeks.org/c-unions/">enough memory for its largest member</a>. So an Expression is going to be larger than the 64 bits needed for a double or for a pointer (the <code>value</code> field’s two largest members) regardless of what value is actually stored in the <code>value</code> field. And, therefore, an  Expression represented as a tagged union will be larger than a NaN. A more compact representation would mean that more Expressions fit into the <a href="https://lemire.me/blog/2022/06/06/data-structure-size-and-cache-line-accesses/">cache line</a> and that affects speed.</p>

<p>Another disadvantage to storing values and type information with structs of any kind is that structs tend to be passed by reference and stored in heap memory.  In the example I gave above the first line allocates some heap memory and returns a pointer. Referencing Expressions this way will lead to <a href="https://redis.com/glossary/cache-miss/">cache misses</a>, which also affect speed.</p>

<p>NaN boxing addresses these issues and you get the illicit thrill of breaking IEEE protocol.</p>



<p>Recall that the plan is to stuff extra values into the mantissa bits of a qNaN. We have 51 mantissa bits available. The most significant 3 available bits will be reserved for the tag. This gives us 48 mantissa bits to store value information. I’ll refer to these bits as the <em>payload</em>. Behold!</p>

<figure>
    <pre>        <div>
            <div>
                <p><span>sign</span></p>
                <p><span>exponent</span></p>
                <p><span>payload</span></p>
                <p><span>signal</span></p>
                <p><span>tag</span></p>
                <p><span>s</span></p>
                <p><span>1111111</span></p>
                <p><span>1111<span>1</span><span>ttt</span></span></p>
                <p><span>pppppppp</span></p>
                <p><span>pppppppp</span></p>
                <p><span>pppppppp</span></p>
                <p><span>pppppppp</span></p>
                <p><span>pppppppp</span></p>
                <p><span>pppppppp</span></p>
                <p><span> = tagged NaN</span></p>
            </div>
        </div>
    </pre>
</figure>

<p>Data can be encoded and retrieved through bit masking. We need masks for important NaN segments:</p>

<div><div><pre><code><span>#define MASK_QNAN 0x7ff8000000000000 //0111111111111000000000000000000000000000000000000000000000000000
#define MASK_PAYLOAD 0x0000ffffffffffff //0000000000000000111111111111111111111111111111111111111111111111
#define MASK_TAG 0x0007000000000000 //0000000000000111000000000000000000000000000000000000000000000000
#define MASK_EXPONENT 0x7ff0000000000000 //0111111111110000000000000000000000000000000000000000000000000000
</span></code></pre></div></div>
<p>Encoding is done by functions that take the original value and use bitwise-or to build a tagged NaN with the original value encoded into the payload</p>

<div><div><pre><code><span>double</span> <span>encode_value</span><span>(</span><span>value</span> <span>val</span><span>)</span>
<span>{</span> 
    <span>return</span> <span>MASK_QNAN</span> <span>|</span> <span>MASK_VALUE_TYPE</span> <span>|</span> <span>(</span><span>uint64_t</span><span>)</span><span>val</span><span>;</span> 
<span>}</span>
</code></pre></div></div>
<p>We need maks for our types:</p>
<div><div><pre><code><span>#define MASK_INT 0x0001000000000000 //0000000000000001000000000000000000000000000000000000000000000000
#define MASK_STRING 0x0002000000000000 //0000000000000010000000000000000000000000000000000000000000000000
</span></code></pre></div></div>
<p>We don’t need a mask for floats because any non-NaN is a float.  We get them for free!</p>

<p>Decoding is done by functions that take a tagged NaN and use bitwise-and to isolate the payload and cast it to the expected type.</p>
<div><div><pre><code><span>value</span> <span>decode_value</span><span>(</span><span>double</span> <span>tagged_nan</span><span>)</span><span>//notice this function returns the made up type *value*.</span>
<span>{</span>
    <span>return</span> <span>tagged_nan</span> <span>&amp;</span> <span>MASK_PAYLOAD</span><span>;</span> 
<span>}</span>
</code></pre></div></div>

<p>We can store an int directly in the payload. Even though the payload is 48 bits, I am going to use 32 bit ints because these are well defined in IEEE and supported in C.  So we will need a special mask for the 32 bit payload.</p>
<div><div><pre><code><span>#define MASK_PAYLOAD_INT 0x00000000ffffffff //0000000000000000000000000000000011111111111111111111111111111111
</span></code></pre></div></div>
<p>On line 3 of the <em>encode_int</em> function I am casting the value to a 32 bit int before casting to a 64 bit int. This is to avoid an operation called <a href="https://en.wikipedia.org/wiki/Sign_extension#:~:text=Sign%20extension%20(abbreviated%20as%20sext,positive%2Fnegative)%20and%20value">sign extension</a> that is meant to preserve the sign of a binary number when increasing its size. Under sign extension the most significant bit of the original number is extended to fill the new significant bits of the extended number. For instance this 16 bit integer <code>1101000000000100</code> would be sign-extended to this 32 bit integer <code>11111111111111111101000000000100</code>. Obviously this would be a problem.</p>

<p>The strange type casting one line 5 is an example of a technique called <a href="https://en.wikipedia.org/wiki/Type_punning">type punning</a>. In this case it ensures that the compiler will read the raw 64 bits of the encoded NaN without any conversion shenanigans.</p>
<div><div><pre><code><span>double</span> <span>encode_int</span><span>(</span><span>double</span> <span>value</span><span>)</span>
<span>{</span>
   <span>uint32_t</span> <span>narrowed</span> <span>=</span> <span>value</span><span>;</span><span>//avoid sign extension</span>
   <span>uint64_t</span> <span>boxed</span> <span>=</span> <span>MASK_QNAN</span> <span>|</span> <span>MASK_INT</span> <span>|</span> <span>(</span><span>uint64_t</span><span>)</span><span>narrowed</span><span>;</span>
      <span>return</span> <span>*</span><span>(</span><span>double</span> <span>*</span><span>)</span><span>&amp;</span><span>boxed</span><span>;</span><span>//type punning. This says, roughly, treat “boxed” as a pointer, then cast it as a pointer to a double, then dereference that pointer</span>
<span>}</span>
</code></pre></div></div>
<p>Then decoding an int just involves some more type punning—so the compiler will read the bare 64 bits—masking the 32 bits off the payload and returning the truncated 32 bits of the result.</p>
<div><div><pre><code><span>int32_t</span> <span>decode_int</span><span>(</span><span>double</span> <span>value</span><span>)</span><span>//notice this function returns an int32_t</span>
<span>{</span>
   <span>return</span> <span>*</span><span>(</span><span>uint64_t</span> <span>*</span><span>)</span><span>&amp;</span><span>value</span> <span>&amp;</span> <span>MASK_PAYLOAD_INT</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>Encoding strings is slightly more involved than encoding ints because we can’t store a string directly in the payload. But we can store a <em>string pointer</em> in the payload. You might be worried that the payload isn’t big enough. After all, on a 64 bit architecture pointers are 64 bits long. True. But 64 bits is a huge address space and modern 64 bit architectures only use the lower 48 bits of a pointer and ignore the rest. So we have just enough payload to store the meaningful portion of a pointer.</p>

<p>We’ll need two functions for encoding a string. One function takes a string pointer and returns a double. This function will allocate heap memory for the string and the terminating character, copy the string to the new address and pass the new address to the string encoding function.</p>
<div><div><pre><code><span>double</span> <span>new_string</span><span>(</span><span>char</span> <span>*</span><span>str</span><span>)</span>
<span>{</span>
   <span>char</span> <span>*</span><span>new_address</span> <span>=</span> <span>malloc</span><span>(</span><span>strlen</span><span>(</span><span>str</span><span>)</span> <span>+</span> <span>1</span><span>);</span>
   <span>strcpy</span><span>(</span><span>new_address</span><span>,</span> <span>str</span><span>);</span>
   <span>return</span> <span>encode_string</span><span>(</span><span>new_address</span><span>);</span>
<span>}</span>
</code></pre></div></div>
<p>From here the encoding function takes a char pointer and returns a double. It works pretty much the same way as <em>encode_int</em>.</p>
<div><div><pre><code><span>double</span> <span>encode_string</span><span>(</span><span>char</span> <span>*</span><span>str</span><span>)</span>
<span>{</span>
    <span>uint64_t</span> <span>encoded</span> <span>=</span> <span>MASK_QNAN</span> <span>|</span> <span>MASK_STRING</span> <span>|</span> <span>(</span><span>uint64_t</span><span>)</span><span>str</span><span>;</span>
    <span>return</span> <span>*</span><span>(</span><span>double</span> <span>*</span><span>)</span><span>&amp;</span><span>encoded</span><span>;</span>
<span>}</span>
</code></pre></div></div>
<p>Decoding a string works the same as decoding an int, but we use the 48-bit mask.</p>
<div><div><pre><code><span>char</span> <span>*</span><span>decode_string</span><span>(</span><span>double</span> <span>value</span><span>)</span><span>//notice this function returns a char pointer</span>
<span>{</span>
   <span>return</span> <span>*</span><span>(</span><span>uint64_t</span> <span>*</span><span>)</span><span>&amp;</span><span>value</span> <span>&amp;</span> <span>MASK_PAYLOAD</span><span>;</span>
<span>}</span>
</code></pre></div></div>


<p>Our previous enum <em>tag</em> can be re-define as a type.</p>
<div><div><pre><code><span>typedef</span> <span>enum</span> <span>Tag</span> <span>{</span> 
        <span>TYPE_FLOAT</span><span>,</span> 
        <span>TYPE_INT</span><span>,</span> 
        <span>TYPE_STRING</span><span>,</span>
        <span>TYPE_ERROR</span> <span>//I’ve added an error type</span>
        <span>}</span> <span>Tag</span><span>;</span>
</code></pre></div></div>
<p>Then we can use it in a helper function that takes an encoded value and returns the type.</p>
<div><div><pre><code><span>Tag</span> <span>get_type</span><span>(</span><span>double</span> <span>value</span><span>)</span>
<span>{</span>
  <span>uint64_t</span> <span>converted</span> <span>=</span> <span>*</span><span>(</span><span>uint64_t</span> <span>*</span><span>)</span><span>&amp;</span><span>value</span><span>;</span>
  <span>uint64_t</span> <span>type</span> <span>=</span> <span>converted</span> <span>&amp;</span> <span>MASK_TAG</span><span>;</span>
  <span>/* if the value is NOT NaN then it is a float*/</span>
  <span>if</span> <span>((</span><span>~</span><span>converted</span> <span>&amp;</span> <span>MASK_EXPONENT</span><span>)</span> <span>!=</span> <span>0</span><span>)</span>
    <span>return</span> <span>TYPE_FLOAT</span><span>;</span>
  <span>switch</span> <span>(</span><span>type</span><span>)</span>
  <span>{</span>
  <span>case</span> <span>(</span><span>MASK_QNAN</span> <span>|</span> <span>MASK_INT</span><span>):</span>
    <span>return</span> <span>TYPE_INT</span><span>;</span>
  <span>case</span> <span>(</span><span>MASK_QNAN</span> <span>|</span> <span>MASK_STRING</span><span>):</span>
    <span>return</span> <span>TYPE_STRING</span><span>;</span>
  <span>}</span>
  <span>return</span> <span>TYPE_ERROR</span><span>;</span><span>//this is where the new error type comes in handy</span>
<span>}</span>
</code></pre></div></div>
<p>Finally, our previous print function only needs some slight adjustments:</p>
<div><div><pre><code><span>void</span> <span>print_value</span><span>(</span><span>double</span> <span>value</span><span>)</span><span>// print_expression changed to print_value; *e changed to value</span>
<span>{</span>
    <span>switch</span><span>(</span><span>get_type</span><span>(</span><span>value</span><span>))</span><span>// e-&gt;tag changed to get_type(value)</span>
    <span>{</span>
        <span>case</span> <span>TYPE_FLOAT</span> <span>:{</span>
            <span>/* print a float */</span>
	        <span>printf</span><span>(</span><span>“</span><span>%</span><span>f</span><span>”</span><span>,</span> <span>value</span><span>);</span><span>// no need to decode non-NaN floats. We get them for free.                      </span>
        <span>break</span><span>;</span>
        <span>}</span>
        <span>case</span> <span>TYPE_INT</span> <span>:{</span>
            <span>/* print an int */</span>
	        <span>printf</span><span>(</span><span>“</span><span>%</span><span>d</span><span>”</span><span>,</span> <span>decode_int</span><span>(</span><span>value</span><span>));</span> <span>// e-&gt;as_int changed to decode_int(value)</span>
        <span>break</span><span>;</span>
        <span>}</span>
        <span>case</span> <span>TYPE_STRING</span> <span>:{</span>
            <span>/* print a string */</span>
	        <span>printf</span><span>(</span><span>“</span><span>%</span><span>s</span><span>”</span><span>,</span> <span>decode_string</span><span>(</span><span>value</span><span>));</span><span>// e-&gt;as_string  changed to decode_string(value)</span>
        <span>break</span><span>;</span>
        <span>}</span>
        <span>case</span> <span>TYPE_ERROR</span> <span>:{</span>
            <span>printf</span><span>(</span><span>“</span><span>unknown</span> <span>type</span><span>”</span><span>);</span>
	    <span>break</span><span>;</span>
       <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>


<p>I’ve created a <a href="https://github.com/AveryBurke/nan_boxing">repo for this project</a> that implements a simple repl. The repl makes a roundtrip from parsing input, to encoding the parsed input into a tagged nan, to decoding the parsed input and printing the result.</p>

<div><div><pre><code>    <span>$&gt;</span> <span>(</span><span>+</span> <span>8</span> <span>-8</span> <span>.1234</span><span>)</span>
    <span>type:</span> <span>string,</span> <span>value:</span> <span>(</span>
    <span>type:</span> <span>string,</span> <span>value:</span> <span>+</span>
    <span>type:</span> <span>int,</span> <span>value:</span> <span>8</span>
    <span>type:</span> <span>int,</span> <span>value:</span> <span>-8</span>
    <span>type:</span> <span>float,</span> <span>value:</span> <span>0.123400</span>
    <span>type:</span> <span>string,</span> <span>value:</span> <span>)</span>
</code></pre></div></div>
<p>This uses all the encoding functions, decoding functions and bitmasks described in this post. The only difference is the addition of the repl and the parser, and the extra information in the print output.</p>

<p>In the full Lips the <code>string</code> type will be replaced with a <code>symbol</code> type and <code>print_value</code> will be replaced with an <code>eval</code> function that looks up the symbol definitions in an environment.</p>



<p>I’m working on this lisp during my time at the <a href="https://www.recurse.com/">Recurse Center</a> and, as seems to happen to me quite often, I just learned that another Recurser got to this topic before I did. So for a much more thorough treatment read: <a href="https://anniecherkaev.com/the-secret-life-of-nan">The Secret Life of NaN, by Annie Cherkaev</a></p>

<p>Robert Nystrom has a <a href="https://craftinginterpreters.com/optimization.html#nan-boxing">section on NaN boxing in the final chapter of Crafting Interpreters</a></p>

<p>I first came across this topic while reading <a href="https://github.com/Robert-van-Engelen/tinylisp/blob/main/tinylisp.pdf">this article</a></p>


  </div></div>
  </body>
</html>
