<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://mazzo.li/posts/uring-multiplex.html">Original</a>
    <h1>Waiting for many things at once with io_uring</h1>
    
    <div id="readability-page-1" class="page"><div id="wrapper">



<p>When doing systems programming we often need to wait for something to happen. Common examples might be waiting for some data to come through a socket or waiting on a lock. We also often want to wait on any of several conditions to become true. A web server might be handling many sockets at once, waiting for any number of them to become readable or writeable.</p>
<p>This short blog post is concerned with the latter scenario in Linux. Until recently there was no generic framework which allowed us to wait on many arbitrary events, but now there is, thanks to <code>io_uring</code>.</p>
<hr/>
<p>The way one usually waits for something to happen is through a system call. For instance:</p>
<ul>
<li><a href="https://man.archlinux.org/man/read.2.en"><code>read()</code></a> waits until there’s data in a file descriptor;</li>
<li><a href="https://man.archlinux.org/man/nanosleep.2.en"><code>nanosleep()</code></a> waits until some time has passed;</li>
<li><a href="https://man.archlinux.org/man/futex.2.en"><code>FUTEX_WAIT</code></a> waits until the value at a certain address changes – a syscall which can be used to implement most user space concurrency primitives such as locks;</li>
<li><a href="https://man.archlinux.org/man/waitid.2.en"><code>wait()</code></a> waits for a child processes to terminate;</li>
<li><a href="https://man.archlinux.org/man/fcntl.2.en#F_SETLKW"><code>F_SETLKW</code></a> acquires a file lock, waiting if it’s currently held by someone else.</li>
</ul>
<p>This list is by no means exhaustive but it gives an overview of what kind of waiting we might want to do.</p>
<p>In many scenarios we might need to wait on many events at once. We’ve already mentioned the most common example: handling many file descriptors. In that case we’re in luck, since we can use syscalls such as <a href="https://man.archlinux.org/man/epoll_wait.2.en"><code>epoll_wait</code></a> for that exact purpose.</p>
<p>Moreover many “waiting” syscalls can be phrased in terms of waiting on a file descriptor. Sleeping for a certain time can be done via <a href="https://man.archlinux.org/man/timerfd_create.2.en"><code>timerfd_create</code></a>, signals can be waited on through <a href="https://man.archlinux.org/man/signalfd4.2.en"><code>signalfd</code></a>, and so on.</p>
<p>However some instances of waiting do <em>not</em> fall within the purview of file descriptors. The most notable exception is <a href="https://man.archlinux.org/man/futex.2.en"><code>futex()</code></a>. The futex is the most foundational concurrency primitive offered by the Linux kernel, and it can be used to implement most of the user space concurrency primitives you’re already familiar with, such as locks and semaphores.</p>
<p>For instance we might implement a queue using a futex, so that a consumer can read from it, blocking until at least an element is present.</p>
<div>
<p>It’s then easy to imagine a situation where a process might want to wait on an element to appear on any of several queues.<a href="#fn1" id="fnref1" role="doc-noteref"><sup>1</sup></a> Or maybe a process is waiting for some sockets to be writeable at the same time as waiting for elements to appear on a queue.</p>
<p>Sadly waiting on a futex through a file descriptor is not possible.<a href="#fn2" id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
<p>This is where <code>io_uring</code> comes in handy – not only for futexes but for all cases of wanting to wait on many things at once.</p>
<p><code>io_uring</code> allows us to set up two queues between user space and the kernel: one to ask the kernel for something to be done (the submission queue), and one to get answers (the completion queue). Once this system is established, instead of performing individual syscalls <a href="https://man.archlinux.org/listing/liburing">we just submit a request corresponding to that syscall</a>, and then wait for the answer.</p>
<p>Notably we can submit many things at once, and wait for any of them to complete. The literature on <code>io_uring</code> usually focuses on its performance advantages: we can reduce many syscalls to one,<a href="#fn3" id="fnref3" role="doc-noteref"><sup>3</sup></a> and we avoid copying buffers from user space to kernel space since the the relevant buffers when reading or writing are shared between user space and the kernel.</p>
<p>However by this point you might have realized the other advantage: we can submit an arbitrary number of requests and wait on any of them. This essentially allows to multiplex any Linux waiting task which is supported by <code>io_uring</code>. Crucially, <code>io_uring</code> <a href="https://man.archlinux.org/man/extra/liburing/io_uring_prep_futex_wait.3.en">recently added support for futexes</a>, an important addition to a <a href="https://man.archlinux.org/listing/liburing">very large list of supported functionality</a>.</p>
<p>This should allow for the creation of a generic async framework where one writes code which looks almost identical to code using blocking Linux syscalls, but which instead submits and completes actions through <code>io_uring</code>. Concurrency primitives can then be built on top of <code>futex</code> and friends, allowing for seamless interaction between IO and user space synchronization.</p>
</div>

<h2 id="acknowledgements">Acknowledgements <a href="#acknowledgements">#</a></h2>
<p>Thanks to Peter Cawley for reading drafts of this blog posts.</p>






</div></div>
  </body>
</html>
