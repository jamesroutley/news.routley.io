<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://thomasw.dev/post/mac-floppy-emu/">Original</a>
    <h1>Emulating the Early Macintosh Floppy Drive</h1>
    
    <div id="readability-page-1" class="page"><article>

<div>
<p>I have been working on an emulator for <a href="https://github.com/twvd/snow">early (Motorola 68000-powered) Macintosh computers</a>.
While implementing the disk drive, I noticed documentation was scattered and hard to
find. Now that I have a working implementation, this post is my attempt to document everything in one place.</p>
<p><img src="https://elijer.github.io/assets/posts/mac/floppyq.png" alt="Floppy with question mark"/></p>

<p>The 68000 CPU interfaces with the disk drive through a controller, called ‘IWM’ (Integrated Woz Machine,
a reference to Apple co-founder <a href="https://en.m.wikipedia.org/wiki/Steve_Wozniak">Steve Wozniak</a>, who designed it).
This controller handles all the logic and analog signals to the drive itself and exposes them in a
usable way to the CPU.</p>
<p>The IWM controller was originally designed for 5.25” drives for the Apple II but the implementation
has been modernized for 3.5” drives and the Macintosh. Many elements are, however, still the same
and will be familiar to those familiar with the Apple II. For example, the CS0/CS1/CS2 I/O lines
were used in the Apple II to move the drive head, but have been repurposed for register access in
the 3.5”/Macintosh version.</p>
<p>From the Macintosh Plus onwards, it can control up to two disk drives.</p>
<h2 id="io">I/O</h2>
<p>All IWM I/O lines are memory-mapped from the CPUs perspective. There are addresses to set and clear
certain signals and read/write bytes from and to the controller. The table below outlines the addresses,
their associated I/O line, their purpose and whether they enable or disable the line.</p>
<p>Note that the ‘HEADSEL’ line is not directly memory mapped but has to be toggled through the VIA
(Register A, bit 5).</p>
<table>
<thead>
<tr>
<th>Line</th>
<th>Enable address</th>
<th>Disable address</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td>CS0</td>
<td><code>0xDFE3FF</code></td>
<td><code>0xDFE1FF</code></td>
<td>Drive register selection</td>
</tr>
<tr>
<td>CS1</td>
<td><code>0xDFE7FF</code></td>
<td><code>0xDFE5FF</code></td>
<td>Drive register selection</td>
</tr>
<tr>
<td>CS2</td>
<td><code>0xDFEBFF</code></td>
<td><code>0xDFE9FF</code></td>
<td>Drive register selection</td>
</tr>
<tr>
<td>LSTRB</td>
<td><code>0xDFEFFF</code></td>
<td><code>0xDFEDFF</code></td>
<td>Drive register write strobe</td>
</tr>
<tr>
<td>ENABLE</td>
<td><code>0xDFF3FF</code></td>
<td><code>0xDFF1FF</code></td>
<td>Drive enable</td>
</tr>
<tr>
<td>SELECT</td>
<td><code>0xDFF7FF</code></td>
<td><code>0xDFF5FF</code></td>
<td>Drive select</td>
</tr>
<tr>
<td>Q6</td>
<td><code>0xDFFBFF</code></td>
<td><code>0xDFF9FF</code></td>
<td>Selects which IWM register to access</td>
</tr>
<tr>
<td>Q7</td>
<td><code>0xDFFFFF</code></td>
<td><code>0xDFFDFF</code></td>
<td>Selects which IWM register to access</td>
</tr>
<tr>
<td>HEADSEL</td>
<td>Through VIA</td>
<td>Through VIA</td>
<td>Two purposes: selects the drive head to read/write data from either side of the disk (in double-sided drives) and plays part in drive register selection.</td>
</tr>
</tbody>
</table>
<p>Note that either reading or writing any of these locations will affect the associated I/O line.</p>
<p>The Macintosh ROM will only ever access these addresses as bytes. Only the
lower eight data lines of the 68000’s data bus are connected to the IWM, meaning it should only be accessed on byte addresses
with the lowest address bit set.</p>
<p>In the event a less well behaved application attempts access to an even address, it is
worth noting that:</p>
<ul>
<li>The 68000’s UDS and LDS lines are not connected to the IWM, meaning any byte-sized write will go through as if
bit 0 is ignored for even addresses because the CPU outputs the byte on the lower as well as the upper eight
data lines.</li>
<li>Reads to even addresses will be undefined as the upper 8 data lines are not connected to the IWM.</li>
</ul>
<h2 id="iwm-registers">IWM registers</h2>
<p>Note the differentiation above between IWM and drive registers. The IWM registers are part of the
controller. The drive registers are per-drive, however, they are queried through the IWM status
register, as will be described later on.</p>
<p>The ENABLE, Q6 and Q7 lines together select which IWM register to write or query:</p>
<table>
<thead>
<tr>
<th>ENABLE</th>
<th>Q6</th>
<th>Q7</th>
<th>Read/Write</th>
<th>Register addressed</th>
</tr>
</thead>
<tbody>
<tr>
<td>on</td>
<td>off</td>
<td>off</td>
<td>R</td>
<td>Data register (reading track)</td>
</tr>
<tr>
<td>on</td>
<td>on</td>
<td>on</td>
<td>W</td>
<td>Data register (writing track)</td>
</tr>
<tr>
<td>on</td>
<td>on</td>
<td>off</td>
<td>R</td>
<td>Status register</td>
</tr>
<tr>
<td>on</td>
<td>off</td>
<td>on</td>
<td>R</td>
<td>Handshake register</td>
</tr>
<tr>
<td>off</td>
<td>on</td>
<td>off</td>
<td>W</td>
<td>Mode register</td>
</tr>
</tbody>
</table>
<h3 id="mode-register">Mode register</h3>
<p>The mode register configures the operation of the IWM and is shared among all drives. Although this
register is write-only, it can be read back as part of the status register.</p>
<p>The Macintosh will normally always set the mode to <code>$1F</code> during very early boot and never change it
during normal operation.
However, it is known that some applications may change the mode register as part of disk copy protection
(e.g. by changing the IWM clock speed).</p>
<p>To change the mode register, software would:</p>
<ol>
<li>Read the status register to confirm the mode needs changing,</li>
<li>Access ‘ENABLE off’ (<code>0xDFF1FF</code>),</li>
<li>Access ‘Q6 on’ (<code>0xDFFBFF</code>),</li>
<li>Write the desired value to ‘Q7 on’ (<code>0xDFFFFF</code>),</li>
<li>Read the status register to confirm the mode has changed. If not, start over.</li>
</ol>
<p>The bits in the mode register are described below.</p>
<table>
<thead>
<tr>
<th>Bit(s)</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>7-5</td>
<td>Reserved/irrelevant</td>
</tr>
<tr>
<td>4</td>
<td>Clock speed</td>
</tr>
<tr>
<td>3</td>
<td>Bit cell timing</td>
</tr>
<tr>
<td>2</td>
<td>Spindle motor shutdown delay</td>
</tr>
<tr>
<td>1</td>
<td>Write handshake protocol</td>
</tr>
<tr>
<td>0</td>
<td>Data latch mode</td>
</tr>
</tbody>
</table>
<h3 id="status-register-and-drive-registers">Status register and drive registers</h3>
<p>The status register reports a few general controller status bits but also allows for reading 1-bit disk
drive registers. To read the status register, software would do the following:</p>
<ol>
<li>Set ‘SELECT’ according to the drive to be queried,</li>
<li>Set the CS0, CS1, CS2 and HEADSEL to select the desired drive register,</li>
<li>Access ‘ENABLE on’ (<code>0xDFF3FF</code>),</li>
<li>Access ‘Q6 on’ (<code>0xDFFBFF</code>),</li>
<li>Read the status byte from ‘Q7 off’ (<code>0xDFFDFF</code>).</li>
</ol>
<p>The table below describes the bits in the status byte:</p>
<table>
<thead>
<tr>
<th>Bit(s)</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>7</td>
<td>SENSE</td>
</tr>
<tr>
<td>6</td>
<td>Reserved</td>
</tr>
<tr>
<td>5</td>
<td>ENABLE line status. 0 = enable off, 1 = enable on.</td>
</tr>
<tr>
<td>4-0</td>
<td>Same as bit 4-0 of the mode register.</td>
</tr>
</tbody>
</table>
<p>The table below shows a list of drive registers that can be queried:</p>
<table>
<thead>
<tr>
<th>CS2</th>
<th>CS1</th>
<th>CS0</th>
<th>HEADSEL</th>
<th>Register</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>off</td>
<td>off</td>
<td>off</td>
<td>off</td>
<td>DIRTN</td>
<td>Head step direction</td>
</tr>
<tr>
<td>off</td>
<td>off</td>
<td>off</td>
<td>on</td>
<td>CISTN</td>
<td>Disk inserted</td>
</tr>
<tr>
<td>off</td>
<td>off</td>
<td>on</td>
<td>off</td>
<td>STEP</td>
<td>Head stepping in progress</td>
</tr>
<tr>
<td>off</td>
<td>off</td>
<td>on</td>
<td>on</td>
<td>WRTPRT</td>
<td>Disk write protect status</td>
</tr>
<tr>
<td>off</td>
<td>on</td>
<td>off</td>
<td>off</td>
<td>MOTORON</td>
<td>Spindle motor running</td>
</tr>
<tr>
<td>off</td>
<td>on</td>
<td>off</td>
<td>on</td>
<td>TKO</td>
<td>Head at track 0</td>
</tr>
<tr>
<td>off</td>
<td>on</td>
<td>on</td>
<td>on</td>
<td>TACH</td>
<td>Spindle motor tachometer</td>
</tr>
<tr>
<td>on</td>
<td>off</td>
<td>off</td>
<td>off</td>
<td>RDDATA0</td>
<td>Live track data (1-bit), lower head</td>
</tr>
<tr>
<td>on</td>
<td>off</td>
<td>off</td>
<td>on</td>
<td>RDDATA1</td>
<td>Live track data (1-bit), upper head</td>
</tr>
<tr>
<td>on</td>
<td>on</td>
<td>off</td>
<td>off</td>
<td>SIDES</td>
<td>Drive head count</td>
</tr>
<tr>
<td>on</td>
<td>on</td>
<td>off</td>
<td>on</td>
<td>READY(?)</td>
<td>Disk ready (? unsure if correct)</td>
</tr>
<tr>
<td>on</td>
<td>on</td>
<td>on</td>
<td>off</td>
<td>INSTALLED</td>
<td>Disk drive installed</td>
</tr>
<tr>
<td>on</td>
<td>on</td>
<td>on</td>
<td>on</td>
<td>PRESENT/HD(?)</td>
<td>Disk drive installed (? unsure if correct)</td>
</tr>
</tbody>
</table>
<h3 id="drive-commands--writing-registers">Drive commands / writing registers</h3>
<p>Disk drives can also receive commands through a similar selection mechanism as above.</p>
<ol>
<li>Set ‘SELECT’ according to the drive to be commanded,</li>
<li>Set the CS0, CS1, CS2 and HEADSEL to select the desired drive command,</li>
<li>Access ‘ENABLE on’ (<code>0xDFF3FF</code>),</li>
<li>Access ‘LSTRB on’ (<code>0xDFEFFF</code>),</li>
<li>Access ‘LSTRB off’ (<code>0xDFEDFF</code>) after a minimum of 1 µs (except EJECT).</li>
</ol>
<p>The table below shows the possible drive commands:</p>
<table>
<thead>
<tr>
<th>CS2</th>
<th>CS1</th>
<th>CS0</th>
<th>HEADSEL</th>
<th>Command</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>off</td>
<td>off</td>
<td>off</td>
<td>off</td>
<td>TRACKUP</td>
<td>Sets head movement direction to higher tracks</td>
</tr>
<tr>
<td>on</td>
<td>off</td>
<td>off</td>
<td>off</td>
<td>TRACKDN</td>
<td>Sets head movement direction to lower tracks</td>
</tr>
<tr>
<td>off</td>
<td>off</td>
<td>on</td>
<td>off</td>
<td>TRACKSTEP</td>
<td>Moves the drive head one track in the selected direction. A step may take up to 30 ms for the head to settle. If the destination track is in a different speed group, it can take up to 150 ms for the motor to reach the proper speed.</td>
</tr>
<tr>
<td>off</td>
<td>on</td>
<td>off</td>
<td>off</td>
<td>MOTORON</td>
<td>Enables the spindle motor. Note that the spindle motor will not actually run unless there is a disk in the drive. The motor will be running at the proper speed within 400 ms.</td>
</tr>
<tr>
<td>on</td>
<td>on</td>
<td>off</td>
<td>off</td>
<td>MOTOROFF</td>
<td>Stops the spindle motor.</td>
</tr>
<tr>
<td>on</td>
<td>on</td>
<td>on</td>
<td>off</td>
<td>EJECT</td>
<td>Ejects the disk. Note that the LSTRB signal must remain active for 750ms for the eject to occur.*</td>
</tr>
</tbody>
</table>
<p><em>*: the Macintosh Plus briefly asserts eject during boot for unknown reasons. This does not cause an actual eject on hardware, but re-emphasizes the need to observe the 750ms in an emulator.</em></p>
<h3 id="handshake-register">Handshake register</h3>
<p>The handshake register is used when writing data to the disk to synchronize the write timing between
the IWM and the CPU. See ‘Write data register’ below on how the disk writing process works.
To read the handshake register, software would do the following:</p>
<ol>
<li>Set ‘SELECT’ according to the drive to be queried,</li>
<li>Access ‘ENABLE on’ (<code>0xDFF3FF</code>),</li>
<li>Access ‘Q7 on’ (<code>0xDFFFFF</code>),</li>
<li>Read the handshake byte from ‘Q6 off’ (<code>0xDFF9FF</code>).</li>
</ol>
<p>The table below describes the bits in the handshake byte:</p>
<table>
<thead>
<tr>
<th>Bit(s)</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>7</td>
<td>Ready for data (data register empty)</td>
</tr>
<tr>
<td>6</td>
<td>Buffer underrun (write completed)</td>
</tr>
<tr>
<td>5-0</td>
<td>Reserved</td>
</tr>
</tbody>
</table>
<p>In an idle situation, where the disk is not being written, ‘ready for data’ is set and ‘underrun’ is clear.</p>
<h3 id="read-data-register">Read data register</h3>
<p>In latch mode (always enabled on Mac), while the drive motor is running, every bit that passes under the head is
left-shifted into a shift register. When the IWM sees the most significant bit in this register is
set, the contents are copied into the data register and the shift register is cleared. This mechanism works
based on the fact that, in GCR encoding, any valid byte has the most significant bit set. If there was already
a byte in the data register, that byte is lost.</p>
<p>Reading the data register clears it to 0. The data read from this register is raw, encoded track data.
Decoding the bytes, locating the right sector, etc. is all done in software. To read the data register, software would:</p>
<ol>
<li>Set ‘SELECT’ according to the drive to be queried,</li>
<li>Access ‘ENABLE on’ (<code>0xDFF3FF</code>),</li>
<li>Access ‘Q7 off’ (<code>0xDFFDFF</code>),</li>
<li>Read the data byte from ‘Q6 off’ (<code>0xDFF9FF</code>).</li>
</ol>
<h3 id="write-data-register">Write data register</h3>
<p>Writing to the write data register makes the drive write to the disk. The data register is a buffer for
the write shift register. When the write shift register is empty, the content of the data register is
copied to the shift register. From this point, the data register can be filled again.</p>
<p>As the drive head progresses over the track, bits from the shift register are shifted out (from the
most significant bit) and written to the disk.</p>
<p>There are two flags in the handshake register that are used to keep the buffer filled and synchronize
the write process:</p>
<ul>
<li>Ready for data: this flag is set as soon as the data register content is moved to the shift
register, signalling that the write data register needs to be filled with the next byte.</li>
<li>Underrun: if the shift register is empty and there is no new byte waiting in the data register,
writing stops and the underrun flag is set.</li>
</ul>
<p>Software would follow the following process to write to disk:</p>
<ol>
<li>Select the desired drive, enable drive motor, move to desired track,</li>
<li>Wait for the correct track position to line up under the head,</li>
<li>Write the next byte to write to the data register:
<ol>
<li>Access ‘Q7 on’ (<code>0xDFFFFF</code>),</li>
<li>Write the desired value to ‘Q6 on’ (<code>0xDFFBFF</code>),</li>
</ol>
</li>
<li>If there is data left to be written, wait for the ‘ready for data’ bit to be set, then return to step 3.</li>
<li>If there is no data left, wait for underrun.</li>
</ol>

<p>Macintosh floppies use <a href="https://en.wikipedia.org/wiki/Group_coded_recording">Group Coded Recording (GCR) encoding</a>
in 6-and-2 encoding. Tracks are divided in sectors. Every sector can store an effective number
of 512 (logical) bytes.</p>
<p>Sectors contain headers called ‘address markers’. These markers are used to locate specific
sectors on the track. They contain:</p>
<ul>
<li>A preamble pattern used to locate the start of a header,</li>
<li>The sector number,</li>
<li>The track number and disk side,</li>
<li>The disk format - <code>$02</code> for single-sided 400K disks, <code>$22</code> for double-sided 800K disks,</li>
<li>A checksum of the header,</li>
<li>A few trailing bytes.</li>
</ul>

<p>Macintosh disk drives spin at a Constant Linear Velocity, meaning the speed in which the
disk spins increases towards the inside of the disk. By reading the outer
tracks at a lower speed, it was possible to store data bits more densely packed together.
This allowed Macintosh computers to store 400KB on a single-sided diskette or 800K on a
double-sided diskette, where a PC would only manage to store 360KB or 720KB of data.</p>
<p>The disadvantage of this technique was that there was no interoperability with PC diskettes
possible, at all, even with software changes.
For the Macintosh, this changed with the
introduction of the Macintosh SE in 1987. The Macintosh SE had a new floppy drive controller,
the ‘SWIM’ (Super Woz Integrated Machine) and a new disk drive which could read and write both
Macintosh CLV and PC CAV formatted diskettes.</p>
<p>Below, there’s a table which shows the varying drive speeds per track and the amount of physical
(e.g. encoded) bits per track.</p>
<table>
<thead>
<tr>
<th>Track range</th>
<th>Drive speed</th>
<th>Physical bits per track</th>
</tr>
</thead>
<tbody>
<tr>
<td>0 - 15</td>
<td>~402 rpm</td>
<td>74640</td>
</tr>
<tr>
<td>16 - 31</td>
<td>~438 rpm</td>
<td>68240</td>
</tr>
<tr>
<td>32 - 47</td>
<td>~482 rpm</td>
<td>62200</td>
</tr>
<tr>
<td>48 - 63</td>
<td>~536 rpm</td>
<td>55980</td>
</tr>
<tr>
<td>64 - 79</td>
<td>~603 rpm</td>
<td>49760</td>
</tr>
</tbody>
</table>
<p>The approximate amount of CPU cycles per disk bit can be calculated using:</p>
<pre><code>clock_speed * 60 / track_rpm / bits_per_track
</code></pre>
<p>At 8 MHz, the drive head produces a new bit approximately every 16 cycles, regardless of the track.</p>
<h2 id="speed-control-in-the-early-macintosh">Speed control in the early Macintosh</h2>
<p>In the Macintosh 128K and 512K with the 400K disk drives, the speed of the spindle motor is
controlled by software using a PWM signal that is written to the LSB of every 16-bit slot in
the sound buffer.</p>
<p>At boot, the Macintosh ROM performs an initial calibration by setting the drive to two different speeds
and reading back the tachometer signal (TACH register). This calibration deals with temperature and
component variance in the drive and electronics. During system operation, the drive is frequently re-calibrated.</p>
<p>To calculate the PWM duty cycle from the data in the sound buffer, convert the lower 6 bits of each value
using the following table (calculation from <a href="https://github.com/mamedev/mame/blob/46ca820d0e4594f88a711b8385f2e9f4cab8af2c/src/mame/apple/mac128.cpp#L551">MAME</a>):</p>
<pre><code> 0,  1, 59,  2, 60, 40, 54,  3,
61, 32, 49, 41, 55, 19, 35,  4,
62, 52, 30, 33, 50, 12, 14, 42,
56, 16, 27, 20, 36, 23, 44,  5,
63, 58, 39, 53, 31, 48, 18, 34,
51, 29, 11, 13, 15, 26, 22, 43,
57, 38, 47, 17, 28, 10, 25, 21,
37, 46,  9, 24, 45,  8,  7,  6
</code></pre>
<p>Sum these over a period of 100 values, then calculate the index using:</p>
<pre><code>    sum / (count / 10) - 11
</code></pre>
<p>Clamp the resulting value to 0-399 and calculate the duty cycle percentage by dividing the result by 4.19.</p>
<p>The disk drive specifications state the following bounds for drive speed vs. duty cycle:</p>
<table>
<tbody>
<tr>
<td>9.4%</td>
<td>305 &lt; V &lt; 380 rpm</td>
</tr>
<tr>
<td>91%</td>
<td>625 &lt; V &lt; 780 rpm</td>
</tr>
</tbody>
</table>
<p>With this information, you can calculate the drive speed dictated by the driver in the Macintosh ROM.</p>
<p>Emulating the PWM speed control is required, the software will not initialize the disk drive successfully
if it notices the drive does not respond to PWM changes during calibration. An improper implementation may
simply lead to failure to read the boot disk but may also cause a ‘sad Mac’ with a division by zero error.</p>
<p><img src="https://elijer.github.io/assets/posts/mac/sadmacdivz.png" alt="Sad Mac, division by zero" title="Division by zero"/></p>
<h2 id="speed-control-in-the-macintosh-plus-and-onwards">Speed control in the Macintosh Plus and onwards</h2>
<p>On models with dual-sided (800K) drives and onwards, the drive speed is controlled by hardware. When emulating
the IWM, as long as the speed per track group matches the table above, it should work.</p>

<p>The ROM contains a driver that talks to the IWM and disk drive, called ‘Sony’. The name likely chosen
because Sony designed and manufactured the early Mac disk drives. This driver exposes the decoded
sector data, upon which the filesystem layer is built.</p>
<p>The IWM supplies the CPU with the physical, encoded track data straight from the disk. Decoding the
GCR-encoding, finding and parsing the sector headers, etc. is all handled by the driver software.</p>
<p>For emulation purposes, knowledge of the Sony driver is not strictly required. However, it helps
tremendously when debugging issues.</p>
<h2 id="rom-api-functions">ROM API functions</h2>
<p>Below is a list of Sony driver functions exposed by the Macintosh 512K ROM and the
purpose of the function I’ve been able to discover.</p>
<table>
<thead>
<tr>
<th>Function</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>E_Sony_Open</code></td>
<td>Initializes driver, enumerates disk drives</td>
</tr>
<tr>
<td><code>E_Sony_Prime</code></td>
<td>Sets up drive for reading/writing</td>
</tr>
<tr>
<td><code>E_Sony_Control</code></td>
<td>Drive control commands (e.g. eject etc)</td>
</tr>
<tr>
<td><code>E_Sony_Status</code></td>
<td>Drive status request</td>
</tr>
<tr>
<td><code>E_Sony_Close</code></td>
<td>Does nothing?</td>
</tr>
<tr>
<td><code>P_Sony_FigTrkSpd</code></td>
<td>Calibrates the drive speed using the tacho signal.</td>
</tr>
<tr>
<td><code>P_Sony_DiskPrime</code></td>
<td>Sets up drive for reading/writing</td>
</tr>
<tr>
<td><code>P_Sony_RdAddr</code></td>
<td>Reads and decodes an address mark</td>
</tr>
<tr>
<td><code>P_Sony_RdData</code></td>
<td>Reads and decodes sector data</td>
</tr>
<tr>
<td><code>P_Sony_WrData</code></td>
<td>Writes a sector</td>
</tr>
<tr>
<td><code>P_Sony_Seek</code></td>
<td>Seeks to a sector</td>
</tr>
<tr>
<td><code>P_Sony_SetUpPoll</code></td>
<td>See below (polling)</td>
</tr>
<tr>
<td><code>P_Sony_Recal</code></td>
<td>Recalls the head to track 0</td>
</tr>
<tr>
<td><code>P_Sony_Control</code></td>
<td>Drive control commands</td>
</tr>
<tr>
<td><code>P_Sony_WakeUp</code></td>
<td>Yields the CPU to other tasks for some time</td>
</tr>
<tr>
<td><code>P_Sony_ReSeek</code></td>
<td>Seeks to a sector</td>
</tr>
<tr>
<td><code>P_Sony_MakeSpdTbl</code></td>
<td>Part of the drive calibration process</td>
</tr>
</tbody>
</table>
<h2 id="polling-the-scc">Polling the SCC</h2>
<p>Reading/writing in the Sony driver occurs in a critical section where interrupts are masked.
To avoid losing serial data during this time, the driver will poll the SCC write request pin and
read the serial data onto a stack. If there are too many serial events during this critical section,
that stack may overflow.</p>
<h2 id="boot-sequence-and-errors">Boot sequence and errors</h2>
<p>The ROM attempts to load a piece of boot code from the disk into RAM, to which it will jump.</p>
<p>Below are a few errors I have encountered which may help in troubleshooting. In any case, it is
very helpful to debug the ROM and see which Sony driver functions it goes through until it fails. Note
that negative return values from these functions indicate errors.</p>
<p>If you do not get the timing or IWM responses right in your emulator,
you will likely get the crossed-out disk, which means that the ROM did not manage to load and
execute the boot code from the disk:</p>
<p><img src="https://elijer.github.io/assets/posts/mac/macdiskcross.png" alt="Floppy with cross"/></p>
<p>If the ROM bootstrap <em>does</em> manage to load and execute the boot code, but the boot code does not
manage to find the second stage system file, you will get an ‘Invalid system disk’ sad Mac, like below. In
that case, you may not be feeding the right track data.</p>
<p><img src="https://elijer.github.io/assets/posts/mac/macbadsystem.png" alt="Bad system disk error"/></p>
<p>If everything works out, you should be greeted with the welcome screen, and finally, the desktop:</p>
<p><img src="https://elijer.github.io/assets/posts/mac/macboot.png" alt="Welcome to Macintosh"/></p>
<p><img src="https://elijer.github.io/assets/posts/mac/macdesktop.png" alt="Macintosh desktop"/></p>

<ul>
<li>Apple Computer, Inc - Guide to the Macintosh Family Hardware, 2nd edition</li>
<li>Apple Computer, Inc - Inside Macintosh, volume III</li>
<li>Apple Computer, Inc - 400KB disk drive specifications</li>
<li><a href="https://archive.org/details/Apple_2_IWM_Spec_1982/mode/1up">Apple Computer, Inc - Integrated Woz Machine (IWM) specification - 1982</a></li>
<li><a href="http://www.mac.linux-m68k.org/devel/iwm.php">Neil Parker - Controlling the 3.5 Drive Hardware on the Apple IIGS - 1994</a></li>
</ul>
</div>

</article></div>
  </body>
</html>
