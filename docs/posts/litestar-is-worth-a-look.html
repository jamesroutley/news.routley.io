<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.b-list.org/weblog/2025/aug/06/litestar/">Original</a>
    <h1>Litestar is worth a look</h1>
    
    <div id="readability-page-1" class="page"><div id="content">
    <div>
      




<!--
 If this entry is assigned to one or more categories, they'll appear
 in links in the paragraph below. Each of those links uses
 rel="category" to indicate it's a link to a category.

 See http://microformats.org/wiki/rel-category for details.
-->
<p>
  <a href="https://gianluca.ai/weblog/2025/aug/06/">  <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
    <title>Published on:</title>
    <path d="M3.5 0a.5.5 0 0 1 .5.5V1h8V.5a.5.5 0 0 1 1 0V1h1a2 2 0 0 1 2 2v11a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V3a2 2 0 0 1 2-2h1V.5a.5.5 0 0 1 .5-.5M1 4v10a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1V4z"></path>
    </svg>
August 6, 2025</a>
  Â Â 
  <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
    <title>Categories:</title>
    <path d="M3 2v4.586l7 7L14.586 9l-7-7zM2 2a1 1 0 0 1 1-1h4.586a1 1 0 0 1 .707.293l7 7a1 1 0 0 1 0 1.414l-4.586 4.586a1 1 0 0 1-1.414 0l-7-7A1 1 0 0 1 2 6.586z"></path>
    <path d="M5.5 5a.5.5 0 1 1 0-1 .5.5 0 0 1 0 1m0 1a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3M1 7.086a1 1 0 0 0 .293.707L8.75 15.25l-.043.043a1 1 0 0 1-1.414 0l-7-7A1 1 0 0 1 0 7.586V3a1 1 0 0 1 1-1z"></path>
  </svg>
  <a rel="category" href="https://gianluca.ai/weblog/categories/django/">Django</a>, <a rel="category" href="https://gianluca.ai/weblog/categories/python/">Python</a>
</p>
  
<p>A few years ago at work, I had a project which offered an opportunity to look at the new generation of async-first, type-hint-driven Python web frameworks. For reasons which arenâ€™t particularly relevant today, on that project I ended up choosing <a href="https://litestar.dev">Litestar</a>, which is the one that <em>doesnâ€™t</em> have a ravenous all-consuming hype machine surrounding it. And Iâ€™m very glad I did, because today Iâ€™m more convinced than ever it was the right choice, and for the last 18 months or so every new project Iâ€™ve started at my day job has been built withÂ Litestar.</p>
<p>But even if youâ€™re someone who does Python web apps for a living, and even if youâ€™re someone who builds asynchronous type-hint-driven web apps, you might not be familiar with this absolute gem of the Python web ecosystem, and today I want to remedyÂ that.</p>
<h2>AÂ taste</h2>
<p>Hereâ€™s the traditional single-file-appÂ demo:</p>
<div><pre><span></span><code><span>from</span><span> </span><span>litestar</span><span> </span><span>import</span> <span>Litestar</span><span>,</span> <span>get</span>


<span>@get</span><span>(</span><span>&#34;/greet&#34;</span><span>)</span>
<span>async</span> <span>def</span><span> </span><span>greet</span><span>(</span><span>name</span><span>:</span> <span>str</span><span>)</span> <span>-&gt;</span> <span>str</span><span>:</span>
    <span>return</span> <span>f</span><span>&#34;Hi, </span><span>{</span><span>name</span><span>}</span><span>!&#34;</span>


<span>app</span> <span>=</span> <span>Litestar</span><span>([</span><span>greet</span><span>])</span>
</code></pre></div>

<p>You save thisÂ as <code>app.py</code>, runÂ with <code>litestar run</code> or hand it directly to the <abbr title="Asynchronous Server Gateway Interface"><span>ASGI</span></abbr> server of your choice, and it launches a web application. You goÂ to <code>/greet?name=Bob</code> and it replies â€œHi, Bob!â€. Leave outÂ the <code>name</code> parameter and it responds with an <span>HTTP</span> 400 telling youÂ the <code>name</code> parameter isÂ required.</p>
<p>So what. Big deal. The FastAPI Evangelism Strike Force will be along soon to bury you under rocket-ship emoji while explaining that FastAPI does the same thing but a million times better. And if youâ€™re a Java person used to Spring, or a .<span>NET</span>  person used to <span>ASP</span>.<span>NET</span> <span>MVC</span>, well, thereâ€™s nothing here thatâ€™s new to you; youâ€™ve had this style of annotation/signature-driven framework for years (and in fact one thing I like about Litestar is how often it reminds me of the good parts of those frameworks). And did anyone tell you FastAPI does this, too!Â ğŸš€ğŸš€ğŸš€ğŸš€ğŸš€ğŸš€ğŸš€ğŸš€ğŸš€</p>
<p>But there are a lot of things that make Litestar stand out to me in the Python world. Iâ€™m going to pick out three to talk about today, and one of them is hiding in plain sight in that simple exampleÂ application.</p>
<div>
<p><strong>Whatâ€™s in aÂ name?</strong></p>
<p>You might see older material referring to Litestar as â€œStarliteâ€, which was its originalÂ name.</p>
<p><a href="https://www.starlette.io">Starlette</a> is a toolkit for doing async Python web development, which can be used standalone or as a component in a more complex library or framework. FastAPI still uses Starlette under the hood, for example. And Litestar originally was built on Starlette too, and was named â€œStarliteâ€, presumably in recognition of that. Over time, though, it dropped the Starlette dependency in favor of its own implementations for that functionality, and people on social media complained that the â€œStarliteâ€ name was confusing, especially since Star<em>lette</em> was no longer being used. So the project which had been â€œStarliteâ€ was renamed to Litestar for version 2.0, released in 2023, and has had that name everÂ since.</p>
</div>
<h3>Scaling (the otherÂ kind)</h3>
<p>Itâ€™s a bit unfortunate that the term â€œscalingâ€ is almost always assumed to mean handling larger and larger quantities of traffic, because thatâ€™s only one axis on which any given piece of of technology can â€œscaleâ€ (and, Iâ€™d argue, possibly the least important one). The type of scaling I want to talk about here is scaling of a codebase: how does something (in this case, a web framework) help or hinder you as you deal with different amounts ofÂ code?</p>
<p>Django, for example, has a reputation for not scaling â€œdownâ€ all that well. You <em>can</em> do it if you really want to, and every so often someone will come up with a new demo of doing a Django project in a single Python file, but itâ€™s just not something that comes naturally to Django. Quite the opposite: if you work through the official beginner Django tutorial and do things the â€œDjango wayâ€, youâ€™ll have around a dozen files laid out in a specific structure of directories and subdirectories before youâ€™ve written a single meaningful line of your ownÂ code. </p>
<p>But â€œmicroâ€ frameworks have often had the opposite problem: theyâ€™re great at starting out with a tiny single-file application, and then get painful as your codebase grows and needs to spread out (single-file Django approaches have the same problem: you have to do a lot of work to get a â€œmicro-Djangoâ€ working, and then you have to <em>undo</em> all that work as soon as the code grows large enough to be worth splitting across multipleÂ files).</p>
<p>Letâ€™s look at an example. Hereâ€™s a FastAPI equivalent of the basic Litestar application I showedÂ above:</p>
<div><pre><span></span><code><span>from</span><span> </span><span>fastapi</span><span> </span><span>import</span> <span>FastAPI</span>


<span>app</span> <span>=</span> <span>FastAPI</span><span>()</span>

<span>@app</span><span>.</span><span>get</span><span>(</span><span>&#34;/greet&#34;</span><span>)</span>
<span>async</span> <span>def</span><span> </span><span>greet</span><span>(</span><span>name</span><span>:</span> <span>str</span><span>)</span> <span>-&gt;</span> <span>str</span><span>:</span>
    <span>return</span> <span>f</span><span>&#34;Hello, </span><span>{</span><span>name</span><span>}</span><span>!&#34;</span>
</code></pre></div>

<p>Notice thatÂ the <code>get()</code> decorator here is attached to the application object. This is a common pattern (Flask/Quart do the same thing, for example, and Starlette used to but has deprecated its entire decorator-based routing system), but it creates a problem once you have multiple files. You need to import the main application object into the other files in order to decorate the routes, but you need to import the other files into your â€œmainâ€ application file to make sure the route registrations are visible from there, and now you have a circular import, and that doesnâ€™tÂ work.</p>
<p>The general solution these frameworks offer is some sort of alternative sub-application object which can act as a per-file route registry thatâ€™s safe to import into the file where your application object is defined. FastAPI calls this object an â€œ<span>API</span> routerâ€; Flask/Quart call it a â€œblueprintâ€. Either way, itâ€™s a necessary construct for those frameworks because their route decorators are always bound to some parent object, either the application object in a single-file app or an â€œ<span>API</span> routerâ€/â€œblueprintâ€/etc. object in a multi-fileÂ app.</p>
<p>That solves the circular-import problem, but creates a new issue: the whiz-bang quickstart demos of â€œmicroâ€ frameworks generally register all the example routes on the application object in a single file in order to keep everything as simple and flashy as possible, but now in order to build a real application (which will almost never stay in a single file) youâ€™ll need to use a different mechanism, or start out following the demo and then switch later on. You also have to <em>know</em> about that different mechanism; in one frameworkâ€™s documentation that I looked at, you can (at the time Iâ€™m writing this post) apparently get 40 pages into the user guide before encountering the section on how to register routes in a multi-file appÂ ğŸ˜–ğŸ˜–ğŸ˜–.</p>
<p>Litestar avoids this entire mess by having the route decorators be standalone functions, not bound to a parent application or application-like object. This may seem like a small thing to focus on, but if youâ€™ve spent time with popular Python microframeworks youâ€™ve probably had to deal with the transition from single- to multi-fileÂ applications.</p>
<p>More importantly, this small change in approach frees up Litestarâ€™s documentation to introduce route-grouping constructs early on and to present them as part of <a href="https://docs.litestar.dev/latest/usage/applications.html#layered-architecture">a coherent layered architecture/configuration concept</a> rather than as an escape hatch for avoiding circular imports. Which is great, because Litestarâ€™s layered architecture is one of its best features: its grouping constructs, and their ability to share configuration, offer an elegant way to compose functionality. For example, a common pattern I use when writing a set of <abbr title="Create, Retrieve, Update, Delete"><span>CRUD</span></abbr> endpoints looks likeÂ this:</p>
<div><pre><span></span><code><span>from</span><span> </span><span>litestar</span><span> </span><span>import</span> <span>Router</span>
<span>from</span><span> </span><span>litestar.di</span><span> </span><span>import</span> <span>Provide</span>

<span># Imagine some CRUD routes for widgets defined here...</span>

<span>_write_widget_router</span> <span>=</span> <span>Router</span><span>(</span>
    <span>guards</span><span>=</span><span>[</span><span>some_auth_function</span><span>],</span>
    <span>route_handlers</span><span>=</span><span>[</span>
        <span>create_widget</span><span>,</span>
        <span>delete_widget</span><span>,</span>
        <span>update_widget</span><span>,</span>
    <span>]</span>
<span>)</span>

<span>widget_router</span> <span>=</span> <span>Router</span><span>(</span>
    <span>dependencies</span><span>=</span><span>{</span><span>&#34;widget_dependency&#34;</span><span>:</span> <span>Provide</span><span>(</span><span>some_widget_dependency</span><span>)},</span>
    <span>path</span><span>=</span><span>&#34;/widgets&#34;</span><span>,</span>
    <span>route_handlers</span><span>=</span><span>[</span>
        <span>get_widget</span><span>,</span>
        <span>get_widget_list</span><span>,</span>
        <span>_write_widget_router</span><span>,</span>
    <span>]</span>
<span>)</span>
</code></pre></div>

<p>This provides a singleÂ â€œpublicâ€ <code>Router</code> instance with all the widget routes, all of which have access to the same core dependencies, but with the data-modifying routes also having auth applied. That composability is extremely powerful, and is less obvious if the â€œrouterâ€ has to be introduced initially as a way to solve circular-importÂ problems.</p>
<p>Litestarâ€™s approach also means itâ€™s easy to do things like register a single route multiple times, each with different configuration. Which enables use casesÂ like:</p>
<ul>
<li>Different authentication/authorization schemes for each registration. For example, a data-editing route might be written once, and registered once under a router which applies <span>API</span> key auth for machine-to-machine requests, then registered again under a router which uses session auth for interaction by a humanÂ user.</li>
<li>Different sets of dependencies for each registration. For example, a route which queries and returns a list of widgets might just declare that it accepts an argument ofÂ type <code>WidgetRepository</code>, and leave it up to the router configuration to decide whether to dependency-inject one that sees all widgets, or perhaps only a subset, or only those which are active,Â etc.</li>
</ul>
<p>If you know what youâ€™re doing, you can emulate some of this in the FastAPI/Flask style of bound route registration, but the techniques youâ€™ll end up using for that feel to me like fighting against the framework, which is something I usually want toÂ avoid.</p>
<h2>Not to be tooÂ Pydantic</h2>
<p><a href="https://docs.pydantic.dev/">Pydantic</a> is a popular package for defining schema objects which perform validation and serialization/deserialization, driven by Python type annotations, and one major use case for this is the input/output schemas of web applications. FastAPI appears to use Pydantic exclusively, which comes with both upsides and downsides. Pydantic is very useful and very powerful, of course, but it also means FastAPI is somewhat limited by what Pydantic can support: mostly, this is Pydanticâ€™s own classes, and <a href="https://docs.python.org/3/library/dataclasses.html">the Python standardÂ libraryâ€™s <code>dataclasses</code></a>.</p>
<p>One crucial limitation is an inability to derive validation/serialization behavior directly from <a href="https://www.sqlalchemy.org">SQLAlchemy</a> <abbr title="Object-Relational Mapper"><span>ORM</span></abbr> classes, even though they both support a very similar type-annotation-based declaration format. Which means that to use SQLAlchemy with a Pydantic-only framework (and SQLAlchemy is basically <em>the</em> standard database toolkit and <abbr title="Object-Relational Mapper"><span>ORM</span></abbr> for Python), you either have to write out the shape of your data multiple timesâ€”once for SQLAlchemy, and then at least one more time (possibly more than one time) for Pydanticâ€”or turn to a third-party package to help bridge the gap. FastAPIâ€™s author worked around this by writing <a href="https://sqlmodel.tiangolo.com">a new <span>DB</span> toolkit which combines SQLAlchemy and Pydantic</a>, and pushing it in FastAPIâ€™sÂ documentation.</p>
<p>Litestar, meanwhile, <em>supports</em> Pydantic, but is not <em>tightly coupled to</em> Pydantic, which gives a bit more flexibility. By default Litestar lets you define input/output schemas using PydanticÂ models, <code>dataclasses</code>, or <a href="https://jcristharif.com/msgspec/">msgspec</a>; ships with plugins to enable the use of <a href="https://www.attrs.org/">attrs</a> and of SQLAlchemy models; and <a href="https://docs.litestar.dev/latest/usage/plugins/index.html#serializationpluginprotocol">provides a protocol for writing your own serialization plugins</a> to extend support to other kinds ofÂ objects.</p>
<p>Thatâ€™s very convenient already, but the convenience is amplified by Litestarâ€™s <a href="https://docs.litestar.dev/latest/usage/dto/1-abstract-dto.html">system for automatically deriving data-transfer objects</a> from data-access or domain objects. Suppose, for example, that we have the following SQLAlchemy modelÂ class:</p>
<div><pre><span></span><code><span>from</span><span> </span><span>sqlalchemy.orm</span><span> </span><span>import</span> <span>DeclarativeBase</span><span>,</span> <span>Mapped</span><span>,</span> <span>mapped_column</span>

<span>Base</span> <span>=</span> <span>DeclarativeBase</span><span>()</span>

<span>class</span><span> </span><span>Widget</span><span>(</span><span>Base</span><span>):</span>
    <span>__tablename__</span> <span>=</span> <span>&#34;widget&#34;</span>

    <span>id</span><span>:</span> <span>Mapped</span><span>[</span><span>int</span><span>]</span> <span>=</span> <span>mapped_column</span><span>(</span><span>primary_key</span><span>=</span><span>True</span><span>)</span>
    <span>internal_notes</span><span>:</span> <span>Mapped</span><span>[</span><span>str</span><span>]</span>
    <span>sku</span><span>:</span> <span>Mapped</span><span>[</span><span>str</span><span>]</span> <span>=</span> <span>mapped_column</span><span>(</span><span>unique</span><span>=</span><span>True</span><span>)</span>
    <span>name</span><span>:</span> <span>Mapped</span><span>[</span><span>str</span><span>]</span>
    <span>price_cents</span><span>:</span> <span>Mapped</span><span>[</span><span>int</span><span>]</span>
</code></pre></div>

<p>In a Pydantic-only world, weâ€™d need to write multiple Pydantic models representing different useÂ cases:</p>
<ul>
<li>A â€œreadâ€ schema for use in <span>HTTP</span> responses, which would probably not includeÂ the <code>internal_notes</code> field and probably alsoÂ not <code>id</code> (since <code>sku</code> is more likely to be the publicÂ identifier)</li>
<li>A â€œwriteâ€ schema for creating widgets, which wouldÂ exclude <code>id</code> since that likely is auto-generated onÂ insert</li>
<li>Another â€œwriteâ€ schema for updating widgets, setting all fields optional to allow partialÂ update</li>
</ul>
<p>As well as possibly more schemas like an admin-view â€œreadâ€ schema that does include the internal fields, etc. Even if you get clever and use inheritance to share field definitions among all these Pydantic classes, you still will write out the full set of fields for widgets at least twice, and the second time it will be fragmented across multiple Pydantic classes, creating the risk of making a change to the <abbr title="Object-Relational Mapper"><span>ORM</span></abbr> model and forgetting to update all the corresponding field definitions in the PydanticÂ models.</p>
<p>Litestarâ€™s approach is a significant improvement on this. For example, hereâ€™s how to use Litestarâ€™s <abbr title="Data Transfer Object"><span>DTO</span></abbr> helpers to define the â€œreadâ€Â schema:</p>
<div><pre><span></span><code><span>from</span><span> </span><span>litestar.dto</span><span> </span><span>import</span> <span>DTOConfig</span>
<span>from</span><span> </span><span>litestar.plugins.sqlalchemy</span><span> </span><span>import</span> <span>SQLAlchemyDTO</span>

<span>class</span><span> </span><span>ReadWidget</span><span>(</span><span>SQLAlchemyDTO</span><span>[</span><span>Widget</span><span>]):</span>
    <span>config</span> <span>=</span> <span>DTOConfig</span><span>(</span><span>exclude</span><span>=</span><span>{</span><span>&#34;id&#34;</span><span>,</span> <span>&#34;internal_notes&#34;</span><span>})</span>
</code></pre></div>

<p>This will give you a <abbr title="Data Transfer Object"><span>DTO</span></abbr> class containing all the fields ofÂ the <code>Widget</code> <abbr title="Object-Relational Mapper"><span>ORM</span></abbr> model <em>except</em> the two explicitly excluded, and will derive that set of fields, and the correct data types, fromÂ introspecting <code>Widget</code>. It will also automatically handle conversion to and from instancesÂ of <code>Widget</code> when you specify it as the input or return <abbr title="Data Transfer Object"><span>DTO</span></abbr> type of a route. Similarly, itâ€™s possible to declare a list of fields to include, or to re-map field names for public consumption, or to declare a <abbr title="Data Transfer Object"><span>DTO</span></abbr> which makes fields optional for partial updates. This means thereâ€™s only one canonical definition of the fieldsâ€”on the original class, which might be a SQLAlchemy <abbr title="Object-Relational Mapper"><span>ORM</span></abbr> model, might beÂ a <code>dataclass</code>, etc.â€”and it doesnâ€™t have to be repeated in the DTOs because the DTOs will always derive their field definitions directly from the source class you point themÂ at.</p>
<p>Of course, there are going to be cases where your DTOs are sufficiently different from your DAOs and domain objects that this isnâ€™t a big help, but my own experience is that â€œthe <abbr title="Data Transfer Object"><span>DTO</span></abbr> is a subset of the <abbr title="Data Access Object"><span>DAO</span></abbr>â€™s fieldsâ€ is extremely common in real-world applications, so Litestarâ€™s approach really pays off in both reduced boilerplate and reduced errors from manual â€œtranscriptionâ€ of fields between different classÂ definitions.</p>
<h2>AlchemicalÂ architecture</h2>
<p>I wasnâ€™t exaggerating earlier when I said that SQLAlchemy is <em>the</em> database toolkit and <abbr title="Object-Relational Mapper"><span>ORM</span></abbr> for Python. While there are others out there, the only one Iâ€™m aware of that sees anything close to SQLAlchemyâ€™s usage is the Django <abbr title="Object-Relational Mapper"><span>ORM</span></abbr>, and only because itâ€™s built into and tightly integrated with Django. So if youâ€™re going to be writing a database-backed web application in Python, and youâ€™re not doing Django, you are almost certainly going to be usingÂ SQLAlchemy.</p>
<p>And Litestar makes that easy. While officially remaining agnostic as to whether you even have a persistence layer, it still includes good integrations for SQLAlchemy: the serialization plugin mentioned earlier allows the direct use of SQLAlchemy <abbr title="Object-Relational Mapper"><span>ORM</span></abbr> classes as input and output schemas; the <abbr title="Data Transfer Object"><span>DTO</span></abbr> helpers can derive subsets and remappings of fields from SQLAlchemy <abbr title="Object-Relational Mapper"><span>ORM</span></abbr> classes; and Litestar also ships with <a href="https://docs.litestar.dev/latest/usage/databases/sqlalchemy/plugins/sqlalchemy_init_plugin.html">a plugin that manages a SQLAlchemy engine and per-request <abbr title="Object-Relational Mapper"><span>ORM</span></abbr> session for you</a>, as well as <a href="https://docs.litestar.dev/latest/usage/databases/sqlalchemy/plugins/sqlalchemy_plugin.html">a single SQLAlchemy mega-plugin</a> combining all the SQLAlchemy pluginsâ€™Â functionality.</p>
<p>So itâ€™s already pretty convenient to use SQLAlchemy in Litestar applications. But thereâ€™s more! The Litestar team also maintains <a href="https://docs.advanced-alchemy.litestar.dev/latest/">the excellent Advanced Alchemy library</a> which provides a bunch of useful features on top of SQLAlchemy. While Advanced Alchemy is framework-agnostic, Litestarâ€™s SQLAlchemy plugin makes use of it and re-exports much of its functionality, giving you access to it automatically, and it does include Litestar-specific helpers for registering certain utility classes with Litestarâ€™s dependencyÂ injection.</p>
<p>Advanced Alchemy provides a lot of quality-of-life improvements for SQLAlchemy, including a variety of base classes and mixins and data types doing useful things like database-agnostic big-integer primary keys, automatic create/update timestamps, <abbr title="Universally Unique IDentifier"><span>UUID</span></abbr>-keyed models, a proper <abbr title="Coordinated Universal Time"><span>UTC</span></abbr> timestamp type, and a <abbr title="JavaScript Object Notation"><span>JSON</span></abbr> type which chooses the best column type for your database. There are also command-line helpers for database management (including creating and working with <a href="https://alembic.sqlalchemy.org/en/latest/">Alembic migrations</a>), database dumping and seeding to/from <abbr title="JavaScript Object Notation"><span>JSON</span></abbr>, and a lotÂ more.</p>
<p>But the place where Advanced Alchemy really shines is in providing <a href="https://docs.advanced-alchemy.litestar.dev/latest/usage/repositories.html">a generic repository implementation</a> (both sync and async flavors) on top of SQLAlchemy models, along with <a href="https://docs.advanced-alchemy.litestar.dev/latest/usage/services.html">a service-layer abstraction</a> and helpers to integrate them into Litestarâ€™s dependency injectionÂ system.</p>
<p>Hereâ€™s a basic example usingÂ the <code>Widget</code> class fromÂ above:</p>
<div><pre><span></span><code><span>from</span><span> </span><span>litestar.plugins.sqlalchemy</span><span> </span><span>import</span> <span>repository</span>

<span>class</span><span> </span><span>WidgetRepository</span><span>(</span><span>repository</span><span>.</span><span>SQLAlchemyAsyncRepository</span><span>[</span><span>Widget</span><span>]):</span>
    <span>model_type</span> <span>=</span> <span>Widget</span>
</code></pre></div>

<p><code>WidgetRepository</code> will have all the methods youâ€™dÂ expectâ€”<code>list()</code>, <code>get_one()</code>, <code>add()</code>, <code>delete()</code>, etc.â€”automatically derived fromÂ the <code>Widget</code> model. And let me just say that having repository implementations automatically derived from any SQLAlchemy model, with not just basic <abbr title="Create, Retrieve, Update, Delete"><span>CRUD</span></abbr> operations but also things like paginated fetches, is a <em>massive</em> productivity boost compared to just using vanilla SQLAlchemy. Itâ€™s maybe not quite on the level of Djangoâ€™s generic views, but itâ€™s a big step in that direction, and you probably could produce something like Djangoâ€™s generic views with Litestar and Advanced Alchemy if you wanted to (perhaps one day, in my copious free time, Iâ€™ll even make an attempt atÂ it).</p>
<p>I know it may seem strange to hear me saying this, since a few years ago I went on record as being strongly <em>against</em> these sorts of abstractionsâ€”specifically service layersâ€”in Django. And I still think you absolutely should not try to retrofit repository or service-layer abstractions onto Django! Theyâ€™re not the native patterns of Djangoâ€™s architecture, and instead I think you should stick to <a href="https://gianluca.ai/weblog/2020/mar/16/no-service/">what I recommended back then</a>, which is to leverage Djangoâ€™s own architecture, especially its â€œmanagerâ€ abstraction, rather than trying to force abstractions onto it that donâ€™tÂ fit.</p>
<p>I also still think there are a lot of bad use cases for repositories and service layers that people should avoid, but thatâ€™s a digression which should probably become its own post, so Iâ€™ll just say for now that I think itâ€™s fine to use repositories and service layers <em>as an organizing principle</em> when youâ€™re using a less-structured framework which doesnâ€™t express strong opinions about how you should lay out your code. And thatâ€™s exactly what I do when working withÂ Litestar.</p>
<h2>A lightweight star ofÂ Python</h2>
<p>There are plenty of other features and conveniences in Litestar, many of which I use daily. Its auth system, supporting both <a href="https://docs.litestar.dev/latest/usage/security/guards.html">simple guard functions</a> and <a href="https://docs.litestar.dev/latest/usage/security/abstract-authentication-middleware.html">middlewares</a> for attaching identity and complex authn/authz logic to requests. Its <a href="https://docs.litestar.dev/latest/usage/stores.html">â€œstoresâ€ framework</a>, which makes caching and similar tasks convenient. Its <a href="https://docs.litestar.dev/latest/usage/logging.html">logging integrations</a> which support both the Python standardÂ libraryâ€™s <code>logging</code> module and popular third-party toolsÂ like <code>structlog</code>. Its built-in support for <a href="https://docs.litestar.dev/latest/usage/plugins/problem_details.html">transforming errors to standard â€œproblem detailsâ€ structures</a>. Its built-in support for <a href="https://docs.litestar.dev/latest/usage/metrics/index.html">recording and exporting metrics in standard Prometheus or OpenTelemetry formats</a>. Its <a href="https://docs.litestar.dev/latest/usage/htmx.html">htmx support</a>.</p>
<p>You can do this stuff in other microframeworks, but it typically involves a lot of tracking down of third-party add-ons and/or writing your own glue code to integrate things. Litestar manages to keep the â€œmicroframeworkâ€ feel when starting a new project while also having all these nice bits optionally available with the framework itself when and if you decide you want them, and thatâ€™s nothing to sneeze at. Thatâ€™s what I was getting at earlier when I said it reminds me of the things I like in certain frameworks from other languages. Litestar doesnâ€™t feel, to me, like itâ€™s trying to be a replacement for any pre-existing Python web framework. Itâ€™s not trying to be the next Django or the next Flask or whatever; instead, it feels to me like a Pythonic take on the good parts of something like Spring Boot (and the way I like to set it up, doing things like using <a href="https://svcs.hynek.me/en/stable/">svcs</a> behind the scenes as a service locator to feed things to both Litestarâ€™s and <a href="https://docs.pytest.org/">pytestâ€™s</a> dependency injection, makes it feel even more thatÂ way).</p>
<p>I could go on for a lot longer listing things I like about Litestar, and probably wind up way too far into my own subjective preferences, but hopefully Iâ€™ve given you enough of a realistic taste of what it offers that, next time youâ€™re about to build a Python web app, you might decide to reach for ğŸ’¡â­ to carry you to the moonÂ ğŸš€ğŸš€ğŸš€.</p>


    </div>
  </div></div>
  </body>
</html>
