<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://devblogs.microsoft.com/oldnewthing/20230403-00/?p=108005">Original</a>
    <h1>C&#43;&#43;17 creates a practical use of the backward array index operator</h1>
    
    <div id="readability-page-1" class="page"><div id="featured">

	<div>
                         <p>
            April 3rd, 2023</p><!-- .entry-meta -->
        
<p>It is well-known that if <code>a</code> is a pointer or array and <code>i</code> is an integer, then <code>a[i]</code> and <code>i[a]</code> are equivalent in C and C++, resulting in hilarity like</p>
<pre>void haha()
{
    int a[5];
    for (i = 0; i &lt; 5; i++) {
        i[a] = 42;
    }
}
</pre>
<p>There is very little practical use for this equivalency, aside from pranking people.¹</p>
<p>And then C++17 happened.</p>
<p>One of the changes to the core language in C++17 was stronger order of evaluation rules, formally known as <i>sequencing</i>. We previously encountered this <a title="The mystery of the crash that seems to be on a std::move operation" href="https://devblogs.microsoft.com/oldnewthing/20220120-00/?p=106178"> when studying a crash that seemed to be on a <code>std::move</code> operation</a>.</p>
<p>One of the operations that received a defined order of evaluation is the subscript operator. Starting in C++17, <code>a[b]</code> always evaluates <code>a</code> before evaluating <code>b</code>.</p>
<pre>int* p;
int index();

auto test()
{
    return p[index()];
}

// Compiled as C++14

    sub     rsp, 40
    call    index       ; call index first
    movsxd  rcx, rax
    mov     rax, p      ; then fetch p
    mov     eax, [rax + rcx * 4]
    add     rsp, 40
    ret

// Compiled as c++17

    push    rbx
    sub     rsp, 32
    mov     rbx, p      ; fetch p first
    call    index       ; then call index
    movsxd  rcx, rax
    mov     eax, [rbx + rcx * 4]
    add     rsp, 32
    pop     rbx
    ret
</pre>
<p>Therefore, if your evaluation of the index may have a side effect on the evaluation of the pointer, you can flip the order to force the index to be calculated first.</p>
<pre>auto test()
{
    return index()[p];
}
</pre>
<p>Astound your friends! Confuse your enemies!</p>
<p><b>Bonus chatter</b>: Though I wouldn’t rely on this yet. clang implements this correctly, but <a href="https://gcc.godbolt.org/z/s11KhnKcn"> msvc (v19) and gcc (v13) get the order wrong</a> and still load <code>p</code> before calling <code>index</code>. (By comparison, icc also gets the order wrong, but the other way: It always loads <code>p</code> <i>last</i>.)</p>
<p>¹ Another practical use is to bypass any possible overloading of the <code>[]</code> operator, as noted in Chapter 14 of <a href="http://www.imperfectcplusplus.com/"> <i>Imperfect C++</i></a>:</p>
<pre>#define ARRAYSIZE(a) (sizeof(a) / sizeof(0[a]))
</pre>
<p>By flipping the order in <code>0[a]</code>, this bypasses any possible <code>a[]</code> overloaded.</p>
<pre>std::vector&lt;int&gt; v(5);
int size = ARRAYSIZE(v); // compiler error
</pre>
<p>However, it isn’t foolproof. You just need to create a more clever fool: If <code>v</code> is a pointer or an object convertible to a pointer, then that pointer will happily go inside the <code>0[...]</code>.</p>
<pre>struct Funny
{
    operator int*() { return oops; }
    int oops[5];
    int extra;
};

Funny f;
int size1 = ARRAYSIZE(f); // oops: 6

int* p = f;
int size2 = ARRAYSIZE(p); // oops: 1
</pre>
<p>Fortunately, you don’t need any macro tricks. You can let C++ <code>constexpr</code> functions do the work for you:</p>
<pre>template&lt;typename T, std::size_t N&gt;
constexpr std::size_t array_size(T(&amp;)[N]) { return N; }
</pre>

        

		
        
	</div><!-- .entry-content -->

</div></div>
  </body>
</html>
