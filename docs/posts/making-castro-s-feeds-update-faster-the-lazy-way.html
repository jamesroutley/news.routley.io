<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://castro.fm/blog/making-castros-feeds-update-faster-the-lazy-way">Original</a>
    <h1>Making Castro’s Feeds Update Faster the Lazy Way</h1>
    
    <div id="readability-page-1" class="page"><div>
        <p>This is more technical than my previous posts. In terms of Castro itself, the app is doing great. Last week we again hit new user highs for 2024, presumably spurred by the <a href="https://mastodon.social/@castropodcasts/113312555313628095" target="_blank" rel="noreferrer noopener">pumpkin icon</a>. The app is how users experience Castro, and it needs the most improvement, so that takes up 90% of our time, effort, and attention. We&#39;ll have more on the client soon, but that other 10% is also very important and is our subject here.</p>
<h3>The Problem</h3>
<p>You can broadly think of Castro’s backend in two parts: the endpoints Castro interacts with when you use the app and the workers we use to update your podcast feeds. The workers actually do many things, but ~99% of their clock cycles are spent checking podcast feeds and updating them. This is not directly user facing, so in theory it&#39;s not a prime candidate for optimization. Most update jobs don&#39;t change anything at all, and when a feed does change, a few hundred milliseconds to update our database is hardly noticeable to the average user.<br/></p>
<figure><img src="https://castro.fm/posts/Screenshot-2024-10-13-at-7.13.52-PM.png" alt="Time before optimization"/></figure>
<p>But in aggregate these jobs add up, and I&#39;ve noticed as we&#39;ve tacked on various new checks and features to the worker jobs, their execution time has crept upward from ~1 second to ~1.3-1.4 seconds. Given my knowledge of what’s actually happening even 1 second seems a bit too long. I want to improve this number, but I don’t want to spend much time on it, because the marginal worker is pretty cheap and we have many other things to focus on.</p>
<p>So what are these jobs doing and how can we make it better?</p>
<h3> The Setup</h3>
<p>I inherited the system more than I designed it but the Castro backend is fairly typical per my understanding. We run a Ruby on Rails app with a Postgres database, and we use Sidekiq to update our podcast feeds. There are many types of workers, but a podcast update job does 3 things:</p>
<ol><li>Lookup some info about a podcast in the database</li><li>Query the podcast URL</li><li>Most of the time, this is it, we’re done. Other times we have to record some data about the run, and less often we have to make some database writes for new episodes or updated podcast metadata.<sup>1</sup></li></ol>
<p>So it’s a lazy afternoon and I decide I’m going to make this better. But I’m not going to refactor anything or make any large changes. Instead I’m going to give myself an hour or two, poke at things a little bit, and abandon my efforts if they prove fruitless. </p>
<p>I don’t know ruby<sup>2</sup> or rails well. I’m much more comfortable with statically typed languages with meaningful function names, but I worked on performance optimizations for a living at one time so I have some relevant experience. The biggest thing I&#39;ve learned working on performance is that 80% of the gain is going to come from &lt;20% of the effort. For the vast majority of software systems, open source or otherwise, nobody is monitoring what every line of code in production is doing, so just looking carefully at things with fresh eyes will usually yield something that can be improved.<br/></p>
<h3>Debugging</h3>
<p>The first thing I need to do is google how to profile ruby in production. <a href="https://github.com/rbspy/rbspy">Rbspy</a> quickly comes up as the best tool for the job, and indeed it proves incredibly helpful. As I said, almost all the worker time is spent updating feeds, and we&#39;re doing things the lazy way. So I don&#39;t bother isolating a specific job or any other setup. I just run rbspy for a few minutes in production to see what those workers are actually doing:</p>
<figure><img src="https://castro.fm/posts/initial_flame_2.png" alt="Initial Flame"/></figure>
<p>Roughly speaking we can separate the resulting graph into four distinct parts:<br/></p>
<ul><li>18% sidekiq overhead / redis calls (far left)</li><li>8% rails / active record overhead</li><li>49% network request (large block in center)</li><li>25% parsing feeds, database updates (bottom right)</li></ul>
<p>On the surface I’m not sure this is bad. I didn’t have strong priors. Redis overhead seems high, so we&#39;ll check that in a moment. Most of our network requests are very quick, but it&#39;s also the thing we&#39;re doing the most and all requests are to random third parties. 49% could be reasonable, let&#39;s check what&#39;s actually happening in there.</p>
<figure><img src="https://castro.fm/posts/Screenshot-2024-10-20-at-4.30.42-PM.png" alt="Network Request"/></figure>
<ul><li>~18% in the <a href="https://github.com/ruby/net-http/blob/master/lib/net/http.rb#L2373">request</a> block itself (well yeah that checks out, gotta start the request and wait)</li><li>~10% <a href="https://github.com/ruby/net-http/blob/master/lib/net/http.rb#L1692">here</a> (shrug, idk, seems legit)</li><li>~13% in a function called <a href="https://github.com/lostisland/faraday-net_http/blob/main/lib/faraday/adapter/net_http.rb#L175C29-L175C78">set_default_paths</a>. Hmmm. What is that doing? </li></ul>
<p>If the reader clicked that last link they know just as much as I do, but from a cursory glance at the code it seems like it&#39;s just setting up the trust store for the request. Mind you this is 13% of all Castro&#39;s worker time. I took several traces to ensure it was representative (we are trying to be lazy but not stupid, going down a rabbithole based on an outlier would waste even more time).</p>
<p>Trust stores should generally be fine to reuse on a request, at least for our purposes. I guess what is happening is every part of the network stack is being torn down and reconstructed every time. If you were just making an occasional network request, it might not matter very much. Since we’re doing this 10s of millions of times per day, that setup is adding up. From the perspective of a client engineer, this is an unexpected source of performance issues. When writing a client side http library, reusing heavy files that don’t change would be an obvious thing to do. (e.g. <a href="https://github.com/square/okhttp/blob/f2771425cb714a5b0b27238bd081b2516b4d640f/okhttp/src/main/kotlin/okhttp3/OkHttpClient.kt#L300-L302">Here</a> is OkHttp setting it up once for the whole client.)</p>
<h3>Improving the network request</h3>
<p>We can do better.<br/></p>
<p>I could set up a trust store in advance and reuse it. Net::Http looks like it’s checking for an existing file in that line of code, so there must be a config option. But do I really want to be creating trust stores? I do not want to start looking at OpenSSL API documentation. Think lazier.</p>
<p>Wait. Shouldn’t the networking stack just handle this? Maybe there&#39;s a simple way to turn on resource pooling. Luckily others have done actual work on this topic so we can just breeze through some blog posts. We stand on the shoulders of <a href="https://mattbrictson.com/blog/advanced-http-techniques-in-ruby">giants</a> and late <a href="https://engineering.wework.com/ruby-users-be-wary-of-net-http-f284747288b2">2017 WeWork</a> was extremely <a href="https://old.reddit.com/r/ruby/comments/7k1llt/ruby_users_be_wary_of_nethttp_wework_engineering/">helpful</a> so I hope everything went well for them the next couple years.</p>
<p>Anyway the upshot after thinking about this:</p>
<ul><li>This is reasonably well known and documented behavior, it&#39;s just really not what we want in this case</li><li>The <a href="https://github.com/drbrain/net-http-persistent">persistent</a> gem would probably solve our problem. Even though &#34;persistent&#34; refers to reusing connections to the same server, which is very much not what we want, presumably they&#39;re also pooling resources better.</li><li>Swapping out the underlying http client sounds like a scary change, but we are lucky that all the worker code is written against Faraday and it actually is a fairly small implementation detail</li><li>If we have to swap out the http client anyway... the more I read about this http stack the less l like it. </li><li>Maybe we just take WeWork&#39;s advice above and use <a href="https://github.com/typhoeus/typhoeus">Typhoeus</a>.</li></ul>
<p>I add Typhoeus to the gem file and it’s just one line of code to swap out the adapter.



</p>
<pre>Faraday.new 
 ...
 builder.adapter Faraday.default_adapter
end</pre>
<p>Becomes</p>
<pre>Faraday.new 
 ...
 builder.adapter :typhoeus
end</pre>
<p>I&#39;m not kidding that was the whole change. The tests pass. After deploying to a test worker and making sure everything works, I give it a production workload for an hour. While it’s running, I look into a few small issues in the flamegraph and add some better Redis <a href="https://github.com/sidekiq/sidekiq/wiki/Advanced-Options#connection-pooling">connection pooling</a> to cut down on some of that initial 18% above. I also disable the Typheous http cache (add cache: false to the above code snippet) as I notice cache setup is showing up on new traces, and we have custom cache handling outside the http layer anyway. Test everything more, deploy all this to production and let it sit overnight.</p>
<figure><img src="https://castro.fm/posts/Screenshot-2024-10-13-at-7.14.10-PM.png" alt=""/></figure>
<p>That’s maybe 2 hours of work. Large improvement, we’re back to ~1 second, which was my whole goal anyway. I can go back to working on Castro’s client. Mission Accomplished.</p>
<h3>Or is it?</h3>
<p>The next day I just can’t resist taking a few more production traces. </p>
<figure><img src="https://castro.fm/posts/Screenshot-2024-10-20-at-6.01.34-PM.png" alt="Second Flame Graph"/></figure>

<p>I verify we&#39;re following the advice <a href="https://github.com/sidekiq/sidekiq/wiki/Advanced-Options#concurrency">here</a>. We have a very standard Sidekiq setup, with 8 threads per worker. and each of those threads should have a dedicated connection. What are these threads all waiting on? I could add more connections to the pool, but why would I need to? I feel like I&#39;m missing something more fundamental.</p>
<p>I&#39;m basically treating ActiveRecord as a black box, but of course it isn&#39;t. The right thing to do might be to read more blog posts, crawl through github issues, read the active record source code, and figure out why a connection wouldn&#39;t be freed. (Perhaps if you&#39;ve worked with AR, you&#39;ve already guessed the solution.) But let&#39;s just try a couple things first.</p>
<p>Maybe ActiveRecord is not very good at closing the connection after a job runs? What if we try to clear them proactively. Google for the right API (clear_all_active_connections!), make sure it only affects the current thread, and add it after each run.</p>
<figure><img src="https://castro.fm/posts/Screenshot-2024-10-20-at-8.42.12-PM.png" alt="code block 1"/></figure>
<p>Run that on some representative data on a test worker.</p>
<figure><img src="https://castro.fm/posts/Screenshot-2024-10-20-at-6.16.07-PM.png" alt="After closing connections"/></figure>
<p>Nope. If anything this is worse. Let&#39;s take a look at the job code above. Where would active record be holding an unused connection? ... Ah, when we&#39;re querying the 3rd party podcast server, we don&#39;t need to do anything with our database, and we don&#39;t know how long that will take. Seems like we might want to release the connection before querying. Acquiring a new connection afterward will have overhead but it&#39;s not going to outweigh 20-30% of all server time. (I asked ChatGPT if that&#39;s a good idea and it said no, but this still seems like a good idea to me.)</p>
<h3>Idea #2</h3>
<p>We try this:</p>
<figure><img src="https://castro.fm/posts/Screenshot-2024-10-20-at-8.43.20-PM.png" alt="code block 2"/></figure>
<p>Run some tests locally and deploy to a worker for testing. I don’t even need a flamegraph to know this was a good change, as I notice the number of jobs we’re completing is significantly higher.</p>
<figure><img src="https://castro.fm/posts/Screenshot-2024-10-20-at-6.26.00-PM.png" alt="Final Trace"/></figure>
<figure><img src="https://castro.fm/posts/Screenshot-2024-10-15-at-12.06.26-PM.png" alt="Final Time"/></figure>

<p>We’ve just cut Castro’s entire backend workload in half in two sessions of debugging and what amounts to two lines of code. Further tweaking got the average down to ~.50 seconds. In theory we can update every feed much more frequently, and indeed we&#39;re already doing that. You might have noticed over the past week or two. We freed up so much worker capacity that we can&#39;t use it all yet, as I’m not sure the rest of the system could handle all the load, meaning we&#39;ll run less workers going forward and save server costs as well.</p>
<p>Can we do better?</p>
<ul><li>Almost certainly. I never even looked at the feed parsing or database write portions of the graph. Naively, those should take the most time, and I’m fairly sure there would some low hanging fruit if we went looking for it.</li><li>Not all feeds or feed jobs are the same. If you dig into this data a little bit in non lazy way, we have only improved the easy case. But most jobs are quick and freeing up the fast case just overwhelms everything else.</li><li>Truly optimizing this would require isolating certain types of jobs and really digging into what individual runs are doing. We have enough throughput now that the juice isn’t worth the squeeze compared to everything else we have to do, but rest assured we&#39;ll continue improving this as needed.</li></ul>
<h3>Focus on Impact</h3>
<figure><img src="https://castro.fm/posts/Screenshot-2024-10-20-at-8.52.28-PM-2.png" alt="Feed Cycle Times"/></figure>
<p>The graphic is less popular feeds that have only a few subscribers, so it&#39;s the worst case scenario. (The bump was slowing things down to ensure nothing broke before we ramped things up in production.)<br/></p>
<p>Historically, there have been complaints about Castro feeds sometimes falling days or hours behind. This does not happen anymore<sup>3</sup> and hasn&#39;t for a long time. Today, every active<sup>4</sup> feed is updated on our server every 10-12 minutes, which is an improvement from ~20 minutes before last week. At peak times this number may slip a bit but honestly not much and we&#39;re getting better there as well. </p>
<p>Hope you enjoy the faster feed updates!<br/></p>
<h6>Notes</h6>
<h6>1. In the case that we did find a new episode, a different job sends notifications to the user, so we don&#39;t have to worry about that here.</h6>
<h6>2. Ruby is an abomination of a programming language, but Rails makes it very easy to be productive.</h6>
<h6>3. Certainly some users might still experience issues. I&#39;m not saying there aren&#39;t bugs. But those issues would generally be caused by app bugs or feed migrations, both of which we&#39;re improving (there may be a future post on feed migrations which is a problem we&#39;ve mostly resolved).</h6>
<h6>4. Active here means a feed is alive and a user on Castro is subscribed to it.</h6>
      </div></div>
  </body>
</html>
