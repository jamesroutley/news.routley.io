<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://flawless.dev/">Original</a>
    <h1>Flawless – Durable execution engine for Rust</h1>
    
    <div id="readability-page-1" class="page"><div>
        <header>
            <a href="https://flawless.dev/">
                <img src="https://flawless.dev/img/logo.png" alt="Flawless Logo, a beautiful woman with freckles head illustration."/>
                <span>flawless</span><span>.dev</span>
            </a>
        </header>

        

<section>
    <p>
        Flawless is an execution engine for durable computation. It will run your code until completion
        even <span>in the presence of hardware or software failure<span>.
    </span></span></p>
    <p>
        We aspire to allow <b>builders</b> to create amazing experiences for others. And the best user
        experiences require complex UIs holding complex state, but trying to model all the state inside
        your database can be challenging. At the same time, you don&#39;t want the user to lose progress by
        accidentally refreshing the page, making continues persistence a
        requirement for modern applications.
    </p>
    <p>
        <span>
            Flawless allows you to model this persistent state with just code and local variables, raising
            the bar when it comes to expressing complex behaviors inside applications.</span>
    </p>
</section>

<section>
    <h2>How does it work?</h2>

    <p>
        Workflows in flawless are written in <b>Rust</b>, in fact they are just regular Rust functions.
        This means that they can contain arbitrary logic. But instead of native code, the functions
        are compiled to WebAssembly and executed in a completely deterministic environment. The only
        nondeterminism is introduced when interacting with the &#34;real world&#34;, like performing HTTP requests
        or generating random numbers. WebAssembly requires us to explicitly handle the non-deterministic
        execution.
    </p>
    <p>
        We use that knowledge to persist a log of non-deterministic side effects. This means that if
        the execution of a workflow is ever interrupted, we can just re-run it and catch up to the same
        state without the need to perform the side effects again.
    </p>

    
<div id="animation">
    <p>workflow.rs <span>×</span></p>
    <p><b>restarting ...</b></p>
    <p>side effect log</p>

    <p>&gt;</p>

    
    <p>63</p>
    

    <p>64</p>
    <p><span>let user</span> = <span>&#34;Adele Goldberg&#34;</span>;</p>
    <p>deterministic</p>
    
    

    <p>65</p>
    <p><span>let comic_id</span>: <span>u32</span> =
        <span>flawless::random()</span>;
    </p>
    <p>side effect</p>
    
    

    <p>66</p>
    <p><span>let url</span> = <span>format!(</span><span>&#34;https://xkcd.com/{comic_id}/&#34;</span><span>)</span>;
    </p>
    
    <p>deterministic</p>
    

    <p>67</p>
    <p><span>let content</span> = <span>flawless::http::get(</span><span>url</span><span>)</span>;</p>
    
    <p>side effect</p>
    

    <p>68</p>
    <p><span>let quote</span> = <span>parse_comic(</span><span>content</span><span>)</span>;
    </p>
    
    
    <p>deterministic</p>

    <p>69</p>
    <p><span>let greeting</span> = <span>format!(</span><span>&#34;Hi {user}! //
            &#39;{quote}&#39;&#34;</span><span>)</span></p>
    
    
    <p>deterministic</p>

    <p>70</p>
    
    
    

    <div><p> Error: Execution Interrupted!</p></div>
    <p>Execution Completed!</p>

    
    
    

    
    <div>
        <p>...</p>
        <p>recv msg {...}</p>
        <p>HTTP request</p>
        <p>send msg {...}</p>
        <p>get clock time</p>
        <p>_</p>
        <p>_</p>
        <p>_</p>
    </div>

    <p>
        &gt;
    </p>
    <p>▓———————————————————————————————————————————————————————————————————————————█</p>
</div>



    <p>
        This makes the amount of data we need to persist minimal, and the rest is just re-calculated
        on-demand in case of failure. A nice side effect of this model is that the whole system is
        observable. We can take any finished or still running workflow and analyze the exact execution
        path it took to get into the current state. With a completely deterministic execution environment,
        impossible to reproduce bugs become a problem of the past.
    </p>
    <p>
        Notice how flawless takes away the burden of persisting the state. You just write business logic
        and can be assured that all the actions are going to run until completion, even if you need to
        occasionally restart the server because of maintenance. Once you start the flawless engine back
        up, <span>the workflows are going to seamlessly continue executing from where
            they stopped</span>.
    </p>
</section>

<section>
    <h2>Want to try it out?</h2>

    <p>
        If you would like to be one of the first developers to get access to flawless as part of our
        private alpha. Join our waitlist.
    </p>

    




    <p>
        If you are a company and would like to work closely with me to shape flawless specifically for
        your needs, email <a href="https://flawless.dev/cdn-cgi/l/email-protection#daaabba8aeb4bfa89abcb6bbadb6bfa9a9f4bebfac"><span data-cfemail="8efeeffcfae0ebfccee8e2eff9e2ebfdfda0eaebf8">[email protected]</span></a>.
    </p>

    <p>~ Bernard</p>
</section>

<section>
    <h2>Essays</h2>

    <ul>
        
        
        <li>
            <a href="https://flawless.dev/essays/when-letting-it-crash-is-not-enough/">When &#34;letting it crash&#34; is not enough</a>
            <span>24 Oct. 2023</span>
        </li>
        
    </ul>
</section>


    </div></div>
  </body>
</html>
