<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://briancallahan.net/blog/20220629.html">Original</a>
    <h1>OpenBSD has two new C compilers: chibicc and kefir</h1>
    
    <div id="readability-page-1" class="page">
	<a name="top"></a>
	<div id="main">
	    
	    <p>academic, developer, with an eye towards a brighter techno-social life</p>
	    <hr/>
		
	    <hr/>
	</div>
<h5 id="prev"><a href="https://www.wired.com/story/farming-drives-towards-precision-agriculture-technologies/20220427.html">[prev]</a></h5>
<h5 id="next">[next]</h5>
    <h2 id="title">2022-06-29</h2>
<p>In my never ending quest to have <a href="https://github.com/ibara/oksh">oksh</a> support every <a href="https://en.wikipedia.org/wiki/C_(programming_language)">C</a> <a href="https://en.wikipedia.org/wiki/Compiler">compiler</a> in existence, I have ported two more C compilers to <a href="https://www.openbsd.org/">OpenBSD</a>. They are chibicc and kefir. As always, let&#39;s review them and at the end I&#39;ll have links to unofficial ports so that you can play around with these C compilers.</p> 
<h4>chibicc</h4>
<p><a href="https://github.com/rui314/chibicc">chibicc</a> is a small <a href="https://en.wikipedia.org/wiki/C11_(C_standard_revision)">C11</a> compiler written by the <a href="https://github.com/rui314">person</a> who is the original creator of the current <a href="https://lld.llvm.org/">LLVM lld</a> linker. As an <a href="https://www.openbsd.org/">OpenBSD</a> developer, Rui&#39;s work is extremely appreciated, as lld is the system linker on OpenBSD these days.</p>
<p>Unfortunately for me, chibicc was developed on Linux, and only tested there. So I am immediately wandering into unknown territory. With that said, I would not be very surprised if the port is relatively straightfoward, as chibicc compiles C to assembly and then calls <a href="https://www.gnu.org/software/binutils/">GNU as</a> to assemble the output into machine code. All the modern Unixes (that I know of and use) these days follow the <a href="https://wiki.osdev.org/System_V_ABI">System V ABI</a> so I can be relatively certain that if the assembly code chibicc generates works on Linux, it&#39;ll work on OpenBSD (and all the BSDs) too. It should be mentioned that only supports <a href="https://en.wikipedia.org/wiki/X86-64">amd64</a> so its utility as a multi-architecture compiler is nil. But its utility as a compiler to learn about compilers is high, since the purpose of chibicc is to be the focus of a compiler textbook.</p>
<h4>Building chibicc</h4>
<p>Building chibicc was very straightforward. In fact, it compiled pretty much as-is out of the box. That is not to say it worked out of the box, however. At first, chibicc would cause the assembler to complain. It turns out chibicc uses the <code>-c</code> flag with <code>as</code> which enables <a href="https://en.wikipedia.org/wiki/DWARF">DWARF</a> debug section compression. The old <code>as</code> in the OpenBSD base system does not understand that flag. Using the newer <code>gas</code> from ports does understand that flag, but it seems that lld does not know what to do with the compressed sections. I don&#39;t know if that&#39;s an lld issue or an OpenBSD issue but DWARF compressed sections probably are not that big of a deal for my purposes so I just removed that flag from the assembler invocation. I continued to use <code>gas</code> since chibicc issues instructions that the old <code>as</code> does not understand.</p>
<p>I then needed to turn my attention to the linker invocation, as chibicc assumes you&#39;re on the author&#39;s Linux system. Adapting the linker invocation to OpenBSD is pretty straightfoward. You can just look at the verbose linker invocation from the in-base <a href="https://clang.llvm.org/">clang</a> and copy the flags over.</p>
<p>Then for the tests, they assume <a href="https://www.gnu.org/software/bash/">GNU bash</a> and <a href="https://www.gnu.org/software/grep/">GNU grep</a>. So I just adapted the tests to call them correctly. No need to try to translate bash to POSIX sh and GNU grep to BSD grep.</p>
<p>If you&#39;re interested in what this all looks like, <a href="https://github.com/ibara/chibicc/commit/f00442a12569b388486088981d4db4da6331cbdb">here</a> is the commit that contains the entire port to OpenBSD.</p>
<h4>Running chibicc</h4>
<p>There was one last thing missing from complete support for chibicc: <a href="https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html#Extended-Asm">GNU extended assembly</a>. OpenBSD uses this in a <a href="https://github.com/openbsd/src/blob/master/sys/arch/amd64/include/endian.h">header</a> and when chibicc sees the extended assembly it has no idea what to do and gives up. This problem does not solely affect chibicc; it also affects other small C compilers such as <a href="https://sr.ht/~mcf/cproc/">cproc</a>.</p>
<p>The solution is fairly easy: we simply have to fix up this header for chibicc, not too dissimilar to what <a href="https://gcc.gnu.org/">gcc</a> does for itself. We will have chibicc look in a custom directory for headers before checking the system directories, and in that custom directory will be a rewritten header file with the extended assembly removed. We can do this because OpenBSD has C fallback functions for all the functions written in extended assembly, and so chibicc will simply use those functions when needed.</p>
<p>We can see this in the <code>install</code> routine I added to the chibicc <a href="https://github.com/ibara/chibicc/blob/main/Makefile#L47"><code>Makefile</code></a>. It does a simple delete using <a href="https://en.wikipedia.org/wiki/Sed">sed</a> and puts the fixed up header in the custom directory. The original header does not get changed, so this is totally non-destructive for the system.</p>
<p>With this, chibicc works on OpenBSD.</p>
<p>For some reason, the <code>exit</code> command does not work in a chibicc-built oksh. If you issue <code>^D</code> you get a segfault. I am not sure why this is.</p>
<h4>kefir</h4>
<p><a href="https://sr.ht/~jprotopopov/kefir/">Kefir</a> is an independent <a href="https://en.wikipedia.org/wiki/C17_(C_standard_revision)">C17</a> compiler. Like chibicc, it targets amd64 only. Also like chibicc, kefir outputs assembly. Unlike chibicc, kefir claims to be supported on <a href="https://www.freebsd.org/">FreeBSD</a>, so this might not be such uncharted territory.</p>
<p>Kefir also says in all bold letters in its <code>README.md</code>: <span>Usage is strongly discouraged. This is [an] experimental project which is not meant for production purposes.</span> That was all the encouragement I needed.</p>
<h4>Building kefir</h4>
<p>Kefir did not build out of the box on OpenBSD. The main issue is that kefir uses a number of <a href="https://en.wikipedia.org/wiki/Variable-width_encoding">multibyte</a> to <a href="https://en.wikipedia.org/wiki/UTF-8">UTF-8</a>, <a href="https://en.wikipedia.org/wiki/UTF-16">UTF-16</a>, and <a href="https://en.wikipedia.org/wiki/UTF-32">UTF-32</a> conversion routines, not all of which are available on OpenBSD. For those that were not in OpenBSD libc, I found highly portable C versions in <a href="https://musl.libc.org/">musl-libc</a> and <a href="https://github.com/ibara/kefir/blob/master/source/util/mb.c">used those</a>.</p>
<p>It seems that kefir may also produce assembly that the old <code>as</code> doesn&#39;t understand, so the newer <code>gas</code> is recommended as well.</p>
<p>Kefir also requires you to build a runtime library, not unlike <a href="https://compiler-rt.llvm.org/">compiler-rt</a> for clang and <a href="https://gcc.gnu.org/onlinedocs/gccint/Libgcc.html">libgcc</a> for gcc. However, the build system does not do this for you, you need to do it yourself. You also need to install it yourself. I took care of all this in the port; that is the <code>libkefirrt.a</code> library. I had to come up with the name; I am very original. I actually got it from the reserved prefix of its functions.</p>
<h4>Installing kefir</h4>
<p>Like chibicc, kefir also does not understand GNU extended assembly, so the same trick with chibicc had to be deployed. Additionally, kefir does not understand <code>__aligned(__alignof__(long long))</code> nor <code>__aligned(__alignof__(long double))</code>, which the <a href="https://github.com/openbsd/src/blob/master/include/stddef.h#L78"><code>stddef.h</code></a> header uses. So I also had to fix up that header.</p>
<h4>Using kefir</h4>
<p>Unlike chibicc, and indeed every C compiler I&#39;ve used up to this point, kefir does not feature a complete compiler driver. What that means is the kefir only does the compilation of C to assembly; it is up to you to pass that output to the assembler and then to the linker. All the other C compilers do all that work for you in the driver.</p>
<p>That means when it comes to building oksh, we can&#39;t run the <code>configure</code> script using kefir. We have to call <code>configure</code> with some other C compiler. And then we can&#39;t even use the <code>Makefile</code> either. Here is a quick shell script that will build oksh with kefir once you&#39;ve run <code>configure</code> with another C compiler:</p>
<pre>#!/bin/sh

for i in *.c ; do
  o=&#34;${i%?}o&#34;
  echo &#34;kefir -I/usr/local/libexec/kefir/include -I/usr/include -D_ANSI_LIBRARY -DEMACS -DVI $i | gas -o $o&#34;
  kefir -I/usr/local/libexec/kefir/include -I/usr/include -D_ANSI_LIBRARY -DEMACS -DVI $i | gas -o $o
done

echo cc -fno-PIC -DEMACS -DVI -c emacs.c
cc -fno-PIC -DEMACS -DVI -c emacs.c

echo cc -fno-PIC -DEMACS -DVI -c misc.c
cc -fno-PIC -DEMACS -DVI -c misc.c

echo cc -nopie -o oksh *.o -lcurses -L/usr/local/libexec/kefir -lkefirrt
cc -nopie -o oksh *.o -lcurses -L/usr/local/libexec/kefir -lkefirrt
</pre>
<p>In addition, kefir fails to compile <code>emacs.c</code> and <code>misc.c</code>. Here are the error messages:</p>
<pre>kefir -I/usr/local/libexec/kefir/include -I/usr/include -D_ANSI_LIBRARY -DEMACS -DVI emacs.c | gas -o emacs.o
Failed to compile! Error stack:
No.  Message                                                                              Class          Subclass   Compiler ref.
  0| emacs.c@883:15 Expression value shall be assignable to function parameter type |     Error|         Analysis|  source/ast/analyzer/nodes/function_call.c:94

kefir -I/usr/local/libexec/kefir/include -I/usr/include -D_ANSI_LIBRARY -DEMACS -DVI misc.c | gas -o misc.o
Failed to compile! Error stack:
No.  Message                                                                             Class          Subclass   Compiler ref.
  0| misc.c@724:22 Expression value shall be assignable to function parameter type |     Error|         Analysis|  source/ast/analyzer/nodes/function_call.c:94
</pre>
<p>That is why the build script above has the system C compiler build those two files.</p>
<h4>Comparing compilers</h4>
<p>Let&#39;s do the fun bit of comparing generated code sizes. To be clear, neither compiler is an optimizing compiler. So we should not expect <a href="https://www.wired.com/story/farming-drives-towards-precision-agriculture-technologies/20211010.html">numbers</a> anywhere near that of clang or gcc.</p>
<p>Here are the number for chibicc:</p>
<pre>text    data    bss     dec     hex
753670  40034   29848   823552  c9100
</pre>
<p>And here are the numbers for kefir:</p>
<pre>text    data    bss     dec     hex
2374884 12071   30120   2417075 24e1b3
</pre>
<p>Remember too that two of the source files in the kefir build were compiled with clang so that brings the numbers down somewhat.</p>
<p>Hardly a surprise that both compilers bring up the rear of the pack in terms of binary size. What is surprising is just how far away kefir is from all the other C compilers. This is not inherently a bad thing; if the code kefir produces is correct, then it is amazing that one person was able to create a complete C17 compiler and that fact should be celebrated.</p>
<p>Having read a good bit of kefir-generated assembly, it appears what&#39;s happening is that the kefir runtime library has a list of all the actions that the <a href="https://en.wikipedia.org/wiki/Intermediate_representation">intermediate representation</a> can represent (<span>e.g.</span>, push, pop, add, sub, etc.). Then, instead of translating from IR into assembly, what kefir does is converts the IR into a sequence of jumps into the functions in the runtime library.</p>
<p>To better understand this, imagine the following simple C program:</p>
<pre>extern int puts(const char *);

int
main(void)
{

	puts(&#34;Hello&#34;);

	return 0;
}
</pre>
<p>Kefir will produce the following assembly:</p>
<pre># Globals
.global main

main:
# Begin prologue of main
    call __kefirrt_preserve_state
    sub %rsp, 16
    call __kefirrt_generic_prologue
# Load parameters of main
# End prologue of main
    lea %rbx, [__main_body]
    jmp [%rbx]
__main_body:
    .quad __kefirrt_push_impl, __kefirrt_string_literal0
    .quad __kefirrt_sfunction_puts_gate3, 0
    .quad __kefirrt_extend32_impl, 0
    .quad __kefirrt_pop_impl, 0
    .quad __kefirrt_push_impl, 0
    .quad __main_epilogue, 0
    .quad __main_epilogue, 0
__main_epilogue:
# Begin epilogue of main
    pop %rax
    mov %rsp, %r14
    add %rsp, 16
    jmp __kefirrt_restore_state
# End of main

__kefirrt_sfunction_puts_gate3:
    mov %r12, %rsp
    and %rsp, -16
    mov %rdi, [%r12 + 0]
    call puts
    mov %rsp, %r12
    add %rsp, 8
    push %rax
    add %rbx, 16
    jmp [%rbx]

.section .data
__kefirrt_module_static_vars:
    .byte 0x6d, 0x61, 0x69, 0x6e, 0x00

.section .rodata
__kefirrt_string_literal0:
    .ascii &#34;Hello\000&#34;
</pre>
<p>The functions <code>__kefirrt_push_impl</code>, <code>__kefirrt_extend32_impl</code>, <code>__kefirrt_pop_impl</code>, and <code>__kefirrt_push_impl</code> are all in the runtime library and won&#39;t be written out in the assembly file. Under the hood, kefir is using <code>%rbx</code> to keep track of where you are in the function and making indirect jumps to hop from instruction to instruction. For instructions kefir cannot possibly know in advance, like the calls, it does write those out in the generated assembly. But it is the same idea: it is just another address to jump to in the sequence of jumps.</p>
<p>The fancy term for this is <a href="https://en.wikipedia.org/wiki/Threaded_code">threaded code</a> and I recently learned that this was the way the old <a href="https://en.wikipedia.org/wiki/B_(programming_language)">B</a> compiler generated code. I&#39;ll admit this is not something I would have thought of but it appears to work just fine. I tend to think of <a href="https://en.wikipedia.org/wiki/Forth_(programming_language)">Forth</a> when I think of threaded code.</p>
<p>In comparison, the assembly chibicc outputs is so routine as to be boring; though that is exactly how it should be.</p>
<h4>Conclusion</h4>
<p>Porting compilers to OpenBSD is fun. These two small C compilers are complete enough to compile real software and demonstrate that there are a myriad of ways to solve the same set of problems. That to me is what makes compilers and interpreters interesting: there are so many ways to solve the same problem that there is always something new to learn.</p>
<p>If you&#39;d like unofficial ports of these two compilers, here is one for <a href="https://github.com/ibara/openbsd-ports-wip/tree/master/lang/chibicc">chibicc</a> and one for <a href="https://github.com/ibara/openbsd-ports-wip/tree/master/lang/kefir">kefir</a>.</p>
<p><a href="#top"><img alt="Top" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAICAYAAADJEc7MAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4wkWDyUKJxzXegAAAB1pVFh0Q29tbWVudAAAAAAAQ3JlYXRlZCB3aXRoIEdJTVBkLmUHAAAAUklEQVQY02Ocd/j/fwY0kGjDwMhACPz//5/h////DPMO//8PYxODWXAZOP8Iw39k22F8uBg2G7Gx0cWYGMgEWJ2aaMPAiO5UDOcTGxjogUe2UwHwdJDZUucW5QAAAABJRU5ErkJggg=="/></a></p>
<a href="https://www.wired.com/story/farming-drives-towards-precision-agriculture-technologies/feed.xml"><img alt="RSS" src="https://www.wired.com/story/farming-drives-towards-precision-agriculture-technologies/media/pic_rss.gif"/></a>
	</div>
  </body>
</html>
