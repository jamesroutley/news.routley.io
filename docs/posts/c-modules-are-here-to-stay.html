<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://faresbakhit.github.io/e/cpp-modules/">Original</a>
    <h1>C&#43;&#43; Modules Are Here to Stay</h1>
    
    <div id="readability-page-1" class="page"><div>
      
<header>
  
  <time>January 24th, 2026</time>
</header>
<blockquote><p>Within C++, there is a much smaller and cleaner language struggling to get out.</p></blockquote>
<p>C++ enthusiasts will often bash you for using the C preprocessor instead
of the latest great metaprogramming feature of the language but until
recently, any meaningful use of C++ meant that you had to
use at least one preprocessor directive (<code>#include</code>) and that is no longer true.</p>
<p>C++20 modules provide a way to encapsulate a library (or a namespace) such as
<code>Qt</code>, <code>cv</code>, or
<code>std</code><sup><a href="#user-content-fn-1" id="user-content-fnref-1" data-footnote-ref="" aria-describedby="footnote-label">1</a></sup>.</p>
<h2>Know your modules</h2>
<p>Using modules is as easy as</p>
<pre><code><span>import</span> std;

<span><span>auto</span> <span>main</span><span>()</span> -&gt; <span>int</span> </span>{
  std::<span>println</span>(<span>&#34;Hello world!&#34;</span>);
}
</code></pre>
<p>and creating your own module is no harder, but we ought to have
some terminology laid down first:</p>
<ul>
<li><strong>Translation unit</strong>: Think of this as any <code>.cpp</code> file.</li>
<li><strong>Module unit</strong>: This is one or more translation units that declares a module. You can declare everything in one file (that we call the interface unit)
or separate your interface and implementation (like a <code>.h</code> file with a corresponding set of <code>.cpp</code> files).</li>
<li><strong>Export declarations</strong>: Inside of your module unit, you can export declarations (classes, functions, etc.)
that are importable by the users of your modules. Exports are explicit.</li>
</ul>
<p>With those definitions out of the way, we can begin by declaring our first module, a data structures and algorithms module:</p>
<pre><code>
<span>export</span> <span>module</span> dsa;

<span>namespace</span> dsa {
<span><span>export</span> <span>int</span> <span>pow</span><span>(<span>int</span> a, <span>int</span> b)</span> </span>{
  ...
}
}
</code></pre>
<p>Well, that was easy. How about we add Red-Black Tree as a submodule?</p>
<pre><code>
<span>export</span> <span>module</span> dsa.rbtree;

<span>export</span> <span>namespace</span> dsa {
<span>enum class</span> <span>AllowDuplicates</span> : <span>bool</span> {
    No,
    Yes,
};

<span>template</span>&lt;<span>typename</span> T, AllowDuplicates AllowDuplicates, <span>typename</span> Compare = std::less&lt;T&gt;&gt;
<span>class</span> RedBlackTree {
  ...
}
}
</code></pre>
<p>It’s the same thing. In fact, from the compiler’s perspective submodules
are not a thing; <code>dsa.rbtree</code> is to <code>dsa</code> what “openai” is to “open”.</p>
<p>Since there’s no such thing as “submodules”, there’s no way
for modules to interact except by their public interfaces and
that is by design. But this also means that you’ll have one
gigantic module unit with many correlating parts and
implementation details; navigating such code will be a nightmare.</p>
<p><strong>Module partitions</strong> to the rescue, they’re module units that are only
importable by their <em>named</em> module and the other module partitions under
the named module.</p>
<p>For example, you’ve added a bunch of linked list variants to your
DSA library and they all share the private <code>Node</code> structure, so you
split your code (that is for the same module) into multiple
dependent modules that are only visible to each other and to your module.</p>
<pre><code>
<span>export</span> <span>module</span> dsa.linked_list;

<span>export</span> <span>import</span> :circular_list;
<span>export</span> <span>import</span> :ordered_list;
<span>export</span> <span>import</span> :unordered_list;


<span>import</span> :node; 
              

<span>export</span> <span>namespace</span> dsa {
<span>template</span> &lt;<span>typename</span> T&gt;
<span>class</span> <span>CircularSinglyLinkedList</span> {
}
}
</code></pre>
<p>There’s one missing piece of the puzzle: backwards compatibility. Yes, you can
use libraries that don’t support modules inside of modules and even
upgrade your code incrementally to use modules through what is called
the “global module fragment” (<code>module;</code>). There’s also a private module
fragment, but we won’t discuss it.</p>
<pre><code><span>module</span>;
<span>#<span>define</span> GLFW_INCLUDE_NONE</span>
<span>#<span>include</span> <span>&lt;GLFW/glfw3.h&gt;</span></span>
<span>#<span>include</span> <span>&lt;glad/gl.h&gt;</span></span>
<span>export</span> <span>module</span> dsa.sortvis;
</code></pre>
<p>That’s about everything you need to know to get started using modules!</p>
<p>You might wonder, “Why go through the hassle when all of my C++ projects use header files and work perfectly fine?”
Yes, that’s true but at some point the C model begins to show
its age, particularly in the time it takes to compile a big project. That’s not
to mention that with enough preprocessor hacks (or time until you resort to them,)
your abstractions become leaky and you’re faced with <a href="https://www.hyrumslaw.com/">Hyrum’s Law</a>.</p>
<h2>Fast compile times</h2>
<p>It’s actually pretty easy to notice that C++ has a “compile time” problem. For quite some time, I’ve taken it upon myself to go through most of the
<a href="https://cses.fi/problemset/">CSES Problem Set</a> and while in these
competitive programming style problems, you spend most of your time analyzing
the problem and coming up with a plausible algorithm, I’ve found
the compile times of the major C++ compilers to be a real bottleneck; having
to wait &gt;4 seconds<sup><a href="#user-content-fn-2" id="user-content-fnref-2" data-footnote-ref="" aria-describedby="footnote-label">2</a></sup> simply interrupts my flow.</p>

<p>It’s apparent from the µbenchmark on my <a href="https://github.com/faresbakhit/cp">solved problems</a> that
C++20 Modules are a clear winner and they provide an 8.6x speedup over the stock Clang and a 1.2x speedup over PCH.
See footnotes<sup><a href="#user-content-fn-bignote" id="user-content-fnref-bignote" data-footnote-ref="" aria-describedby="footnote-label">3</a></sup> for the competitive programming template and script using modules.</p>
<p>To not bore you to death and frankly I’d do a bad job at it, I’ll not explain
how to work with C++20 modules in Clang, instead the amazing developers
behind Clang wrote a comprehensive article: <a href="https://clang.llvm.org/docs/StandardCPlusPlusModules.html">Standard C++ Modules — Clang documentation</a>
(You don’t need to read it unless you’re building tooling around Clang, which
the CMake folks have already done.)</p>
<h2>But support</h2>
<p>Lagging support for modules from C++ vendors to tooling is a valid point to not
consider modules at all in your projects. But your personal projects don’t
need the guarantees C++ often holds for commercial projects (and I think
most commericial projects don’t either), and the story is only half bad.
As of now, most major compilers either implement the spec completely
or partially and CMake provides complete modules support but experimental support for <code>import std;</code>,
which is enough in my book.</p>
<p>Here’s the minimal <code>CMakeLists.txt</code> to get you started:</p>
<pre><code><span>cmake_minimum_required</span>(VERSION <span>3.28</span>)

<span>project</span>(dsa)

<span>set</span>(CMAKE_CXX_SCAN_FOR_MODULES <span>ON</span>)
<span>set</span>(CMAKE_CXX_STANDARD <span>23</span>)

<span>add_library</span>(dsa)
<span>target_sources</span>(dsa
  PUBLIC FILE_SET dsa_public_modules TYPE CXX_MODULES
  FILES
    src/dsa.cpp
)

<span>add_executable</span>(hello src/bin/hello.cpp)
<span>target_link_libraries</span>(hello PRIVATE dsa)
</code></pre>
<p>or if you really want to do <code>import std;</code> (EXPERIMENTAL),
you need to add the following lines:</p>
<pre><code>
<span>set</span>(CMAKE_EXPERIMENTAL_CXX_IMPORT_STD <span>&#34;XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX&#34;</span>)
<span>set</span>(CMAKE_CXX_MODULE_STD <span>ON</span>)
</code></pre>


    </div></div>
  </body>
</html>
