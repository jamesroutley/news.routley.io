<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/bryanmcnett/sdf_hardware">Original</a>
    <h1>Modifications to GPU Hardware to Benefit Signed Distance Fields</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text"><p dir="auto">Modifications to GPU Hardware to benefit Signed Distance Fields</p>
<p dir="auto">The Signed Distance Field (SDF) is a fundamental primitive used in computer graphics, which has the nice property that it encodes a surface in 3D space, which regardless of topological complexity can be filtered efficiently for automatic level-of-detail by massively parallel hardware, much as a texture map can.</p>
<p dir="auto">This makes SDF amenable to implementation in GPU hardware, though to date no hardware has been designed specifically to accelerate SDF. Rather, whatever hardware was developed for triangle rasterization has been repurposed for SDF by end users.</p>
<p dir="auto">In this article we explore possible changes to GPU hardware specifically for the purpose of accelerating SDF.</p>
<p dir="auto">Texture Format</p>
<p dir="auto">For a 3D SDF texture we can store a much smaller &#34;meta texture&#34; in which each block of 8x8x8 texels is encoded as 16 bits: 8 bits of &#34;minimum distance in block&#34; and 8 bits of &#34;maximum distance in block&#34;. This is 0.004 bits per texel, and is sufficient information to traverse an SDF much of the time.
While this is reminiscent of the endpoints of a traditionally block-compressed texture, it would be stored in separate cachelines from any per-texel information, to avoid wasting memory bandwidth on such information when it isn&#39;t relevant. Many SDF fetches don&#39;t need the precise value of an individual
texel, but rather wish to compare it to a known range of values. As with PCF filtering of shadow maps, the comparison can be a part of the fetch instruction itself.</p>
<p dir="auto">When it is necessary to read per-texel information, since for most texels the value can be predicted from adjacent texels (most texels are &#34;exactly one unit&#34; further away from the surface than their neighbors) a simple predictive decoder in hardware is likely efficient.
An 8x8x8 block that holds a flat piece of surface will likely need to encode information for only 25% of the texels, and the rest can be predicted trivially.</p>
<p dir="auto">Face Centered Cubic Volume Textures</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/a63670e151e097b375184bafdcc3803d14a9f44292c1ab7eff6ef3c8acbcf7dd/68747470733a2f2f776973632e70622e756e697a696e2e6f72672f6170702f75706c6f6164732f73697465732f3239332f323031392f30372f434e585f4368656d5f31305f30365f437562556e74436c6c2e706e67"><img src="https://camo.githubusercontent.com/a63670e151e097b375184bafdcc3803d14a9f44292c1ab7eff6ef3c8acbcf7dd/68747470733a2f2f776973632e70622e756e697a696e2e6f72672f6170702f75706c6f6164732f73697465732f3239332f323031392f30372f434e585f4368656d5f31305f30365f437562556e74436c6c2e706e67" alt="Primitive Cubic vs. Face Centered Cubic" data-canonical-src="https://wisc.pb.unizin.org/app/uploads/sites/293/2019/07/CNX_Chem_10_06_CubUntCll.png"/></a></p>
<p dir="auto">The Nintendo 64 game console did not tap the 4 nearest samples in a 2D grid to <em>bilinearly</em> filter a 2D texture, as contemporary hardware does. Rather, it tapped the 3 nearest samples, and <em>linearly</em> blended among them.
For a given dimension N, a bilinear filter requires pow(2,N) taps, and a linear filter requires N+1 taps. In ten dimensions bilinear would require 1024 taps, and linear 11. So, any hardware that aims to sample a high
dimensional function would be under great pressure to use linear filtering, rather than bilinear filtering.</p>
<p dir="auto">An N64 texture can be conceptualized as being made of triangular texels, rather than the square texels of contemporary hardware.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/31c7aad61fa1d4d05f2b410bb1d6e438bca10cea3258135d1e252635a53873ee/68747470733a2f2f7777772e74686565646b696e732e636f2e756b2f6a6f2f746573732f747269616e676c6531302e676966"><img src="https://camo.githubusercontent.com/31c7aad61fa1d4d05f2b410bb1d6e438bca10cea3258135d1e252635a53873ee/68747470733a2f2f7777772e74686565646b696e732e636f2e756b2f6a6f2f746573732f747269616e676c6531302e676966" alt="N64 texture sample grid" data-animated-image="" data-canonical-src="https://www.theedkins.co.uk/jo/tess/triangle10.gif"/></a></p>
<p dir="auto">In 3D such a texture would be made of rhombic dodecahedral texels rather than cubic texels, in a Face Centered Cubic lattice (see above image) rather than the Primitive Cubic lattice of contemporary hardware.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/d44d823f60859679fb4f1c4dde4d5916c324603081e247fd521c7021b2e3cc98/68747470733a2f2f75706c6f61642e77696b696d656469612e6f72672f77696b6970656469612f636f6d6d6f6e732f322f32652f52686f6d6269635f646f6465636168656472616c5f686f6e6579636f6d625f342d636f6c6f722e676966"><img src="https://camo.githubusercontent.com/d44d823f60859679fb4f1c4dde4d5916c324603081e247fd521c7021b2e3cc98/68747470733a2f2f75706c6f61642e77696b696d656469612e6f72672f77696b6970656469612f636f6d6d6f6e732f322f32652f52686f6d6269635f646f6465636168656472616c5f686f6e6579636f6d625f342d636f6c6f722e676966" alt="Rhombic Dodecahedron Honeycomb" data-animated-image="" data-canonical-src="https://upload.wikimedia.org/wikipedia/commons/2/2e/Rhombic_dodecahedral_honeycomb_4-color.gif"/></a></p>
<p dir="auto">An SDF encoded as a 3D texture would require 4 taps with a linear filter, rather than 8 taps with a bilinear filter. The pipeline to blend 1/2 as many taps would require 1 less bit of internal precision, and would
process 1/2 as much data at any instant. This may present opportunities to increase the degree of parallelism by a factor of 2.</p>
</article></div></div>
  </body>
</html>
