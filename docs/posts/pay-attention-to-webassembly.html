<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://harshal.sheth.io/2022/01/31/webassembly.html">Original</a>
    <h1>Pay attention to WebAssembly</h1>
    
    <div id="readability-page-1" class="page"><div aria-label="Content">
      <div>
        <article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    <p>WebAssembly is at an inflection point. Over the next few years, I expect to see increased adoption of WebAssembly across the tech sphere, from containerization to plugin systems to serverless computing platforms. The following is a discussion of what WebAssembly is, what makes it a relevant technology, and where it’s being used today. I’ll also describe some potentially high-impact applications and make some predictions about its future.</p>

<h2 id="what-is-webassembly">What is WebAssembly?</h2>

<p>WebAssembly (abbreviated Wasm) is an intermediate layer between various programming languages and many different execution environments. You can take code written in over 30 different languages and compile it into a .wasm file, and then can execute that file in the browser, on a server, or even on a car.</p>

<p>The name “WebAssembly” is misleading. While it was initially designed to make code run fast on the web, it now can run in a variety of environments outside of the browser as well. Moreover, WebAssembly is not assembly but rather a slightly higher-level bytecode.</p>

<p>Plenty of ink has been spilled on describing WebAssembly and explaining its history, so I’ll simply refer to some good primers here:</p>

<ul>
  <li><a href="https://hacks.mozilla.org/2017/02/a-cartoon-intro-to-webassembly/">A cartoon intro to WebAssembly - Mozilla Hacks - the Web developer blog</a></li>
  <li><a href="https://nickymeuleman.netlify.app/blog/webassembly">WebAssembly. Scary name, exciting applications. | Nicky blogs</a></li>
  <li><a href="https://desiatov.com/why-webassembly/">How WebAssembly changes software distribution | Max Desiatov</a></li>
</ul>

<h2 id="where-does-webassembly-excel">Where does WebAssembly excel?</h2>

<p>WebAssembly excels because of the following five characteristics:</p>

<ul>
  <li><strong>Portable</strong>: The binary format for Wasm bytecode is standardized, meaning that any runtime capable of executing Wasm will be able to run any Wasm code.<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" rel="footnote">1</a></sup> This is similar to Java’s promise of “write once, run anywhere”. In the browser, <a href="https://caniuse.com/wasm">95% of users’ browsers</a> can execute WebAssembly, and the remaining gap can be bridged using a wasm2js compiler. For servers, there are runtimes like <a href="https://github.com/bytecodealliance/wasmtime">Wasmtime</a> and <a href="https://github.com/wasmerio/wasmer">Wasmer</a>. Even resource-constrained IoT devices can join the fun using <a href="https://github.com/bytecodealliance/wasm-micro-runtime">WAMR</a>.<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" rel="footnote">2</a></sup></li>
  <li><strong>Universal</strong>: Many languages can compile into Wasm. This support goes beyond systems languages like C, C++, and Rust to include garbage-collected, high-level languages like Go, Python, and Ruby.<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" rel="footnote">3</a></sup> A full list of languages that compile to Wasm can be found <a href="https://github.com/appcypher/awesome-wasm-langs">here</a>.</li>
  <li><strong>“Near-Native Performance”</strong>: Wasm is often <a href="https://developer.mozilla.org/en-US/docs/WebAssembly">described</a> as having “near-native performance”. What this actually means is that WebAssembly is almost always faster than JavaScript, especially for compute-intensive workloads, and averages between 1.45 and 1.55 times slower than <a href="https://www.usenix.org/conference/atc19/presentation/jangda">native code</a>, but results do <a href="https://00f.net/2021/02/22/webassembly-runtimes-benchmarks/">vary by runtime</a>.</li>
  <li><strong>Fast Startup Time</strong>: The cold start time of Wasm is important enough that it warrants a category of its own. On the server, it can achieve 10-100x <a href="https://repositum.tuwien.at/bitstream/20.500.12708/17598/1/Gackstatter%20Philipp%20-%202021%20-%20A%20WebAssembly%20Container%20Runtime%20for%20Serverless%20Edge...pdf">faster cold starts</a> than Docker containers because it does not need to create a new OS process for every container. In the browser, decoding Wasm and translating it to machine code is faster than parsing, interpreting, and optimizing JavaScript, and so Wasm code can begin executing at peak performance more quickly than JavaScript can.<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" rel="footnote">4</a></sup></li>
  <li><strong>Secure</strong>: WebAssembly was designed with the web in mind and so security was a priority. Code running in a Wasm runtime is memory sandboxed and capability constrained, meaning that it is restricted to doing what it is explicitly allowed to do.<sup id="fnref:5" role="doc-noteref"><a href="#fn:5" rel="footnote">5</a></sup> While sandboxed, Wasm code can still be granted access to the underlying system, including system-level interfaces and hardware features.</li>
</ul>

<h2 id="where-is-webassembly-useful">Where is WebAssembly useful?</h2>

<h3 id="speeding-up-javascript">Speeding up JavaScript</h3>

<p>The initial motivation behind Wasm and its precursor asm.js was to speed up client-side code on the web, and there are many examples of Wasm excelling in this arena:</p>

<ul>
  <li>The core of the Figma design tool, for example, is written in C++ and then compiled to WebAssembly. They found major <a href="https://www.figma.com/blog/building-a-professional-design-tool-on-the-web/">performance and usability wins</a> by writing in C++, while <a href="https://www.figma.com/blog/webassembly-cut-figmas-load-time-by-3x/">compiling to WebAssembly</a> cut load times by 3x and dramatically reduced download sizes.</li>
  <li>The password manager 1Password saw up to <a href="https://blog.1password.com/1password-x-may-2019-update/">13-39x speedups</a> on form-heavy sites when switching to Wasm. Wasm performance is also <a href="https://developers.google.com/web/updates/2019/02/hotpath-with-wasm">more consistent</a> than JavaScript, which is important for latency-sensitive applications.<sup id="fnref:6" role="doc-noteref"><a href="#fn:6" rel="footnote">6</a></sup></li>
</ul>

<h3 id="programming-language-interoperability">Programming Language Interoperability</h3>

<p>WebAssembly lets us more easily cross the boundaries between programming languages. Libraries and frameworks are usually written in a single language, which makes it difficult to make use of that code from other languages without a full rewrite. With WebAssembly, we can more easily execute code written in other languages. <strong>This enables us to reuse code rather than reinventing the wheel.</strong></p>

<p>Right now, this is mainly used to port applications to the web. Here’s some examples:</p>

<ul>
  <li>Figma makes use of a low-level C++ library called Skia for some graphics algorithms rather than building their own or porting them to JavaScript.<sup id="fnref:7" role="doc-noteref"><a href="#fn:7" rel="footnote">7</a></sup></li>
  <li>My favorite chess server, lichess.org, runs the world-class Stockfish chess engine in users’ browsers, saving them the computational burden of running it server-side.</li>
  <li><a href="https://medium.com/google-earth/google-earth-comes-to-more-browsers-thanks-to-webassembly-1877d95810d6">Google Earth</a> and <a href="https://web.dev/ps-on-the-web/">Adobe Photoshop</a> ported their C++ codebases to the web using Wasm.</li>
</ul>

<p>Porting applications to the web is the easiest place to start, and we’ll likely see that <a href="https://paulbutler.org/2020/the-webassembly-app-gap/">trend continue</a>. However, Wasm’s interoperability is not limited to the browser. It’s also been used to make code work cross-platform and cross-device:</p>

<ul>
  <li>The <a href="https://platform.uno/">Uno Platform</a> is a UI platform that lets you write a single application and have it run across Windows, macOS, iOS, Android, Linux, and browsers. It seems to be fairly Windows-centric, as applications are written in C# and XAML, and so many of the use cases are based around reducing the effort required to port legacy applications to new platforms.</li>
  <li><a href="https://www.amazon.science/blog/how-prime-video-updates-its-app-for-more-than-8-000-device-types">Amazon Prime</a>, <a href="https://medium.com/disney-streaming/introducing-the-disney-application-development-kit-adk-ad85ca139073">Disney+</a>, and the <a href="https://www.youtube.com/watch?v=28paRXqI-Gk">BBC</a> all use WebAssembly in their video platforms. For example, Amazon Prime uses it to ship new features to a huge variety of device types while maintaining acceptable performance.</li>
</ul>

<p>Beyond application portability, WebAssembly can also serve as a cross-language bridge on the server-side. Unfortunately we haven’t seen too much of this yet, since the interfaces used to communicate with the operating system (the <a href="https://hacks.mozilla.org/2019/03/standardizing-wasi-a-webassembly-system-interface/">Web Assembly System Interface</a>, abbreviated WASI) and work across language boundaries (the <a href="https://github.com/WebAssembly/component-model">Wasm Component Model</a>) are still in development and have not yet reached the requisite maturity level.</p>

<h3 id="plugin-systems">Plugin Systems</h3>

<p>When most applications reach a certain level of maturity, they need to allow for extensibility by end users. Historically applications have reached for copious config systems or built complex DSLs, but these invariably turn out to be exceedingly painful to manage or force developers to work with unfamiliar languages.</p>

<p>Let’s consider an example: configuring request filtering rules in a system like NGINX. In order to do so, a sysadmin must declaratively implement their desired logic in a custom configuration language that they’re unfamiliar with. They’re beholden to the types of matching and filtering operators that the NGINX designers anticipated, which often severely limits their ability to implement the behavior they want. If anything goes wrong, debugging can be frustrating because of the lack of available tooling.</p>

<p>Some newer applications have opted for a different approach: provide a standard set of interfaces and embed a Wasm runtime, and let end users provide Wasm binaries that implement the needed custom logic. This yields a much more flexible and familiar interface for end users: they can implement arbitrarily complex business logic and can do so in whatever language they choose. This was not possible with other languages because of security concerns, but Wasm makes it feasible because the runtime can sandbox the user-provided code.</p>

<p>A few examples of where this is used today:</p>

<ul>
  <li>The Envoy proxy, originally developed by Lyft and now used across the industry, allows extensions to be <a href="https://github.com/proxy-wasm/spec/blob/master/docs/WebAssembly-in-Envoy.md">built with Wasm</a> and loaded dynamically at runtime. The Istio service mesh, which is built on top of Envoy, has followed suit.</li>
  <li>Redpanda, a Kafka alternative, lets users write <a href="https://vectorized.io/blog/wasm-architecture/">in-stream custom data transformations</a> using Wasm.</li>
  <li>The Open Policy Agent allows for policies to be <a href="https://www.openpolicyagent.org/docs/latest/wasm/">defined using Wasm</a>.</li>
  <li>The Minecraft server <a href="https://github.com/feather-rs/feather">Feather</a> uses WebAssembly to run plugins in a sandbox.</li>
</ul>

<h3 id="embedded-sandboxing">Embedded Sandboxing</h3>

<p>The idea of embedding WebAssembly within other applications is useful beyond plugin systems. In fact, it can be used to sandbox entire third-party libraries or to construct layers of security for first-party code.</p>

<p>Firefox is <a href="https://hacks.mozilla.org/2021/12/webassembly-and-back-again-fine-grained-sandboxing-in-firefox-95/">leading the way</a> in this area by protecting themselves against bugs in third-party libraries, like the ones they use for spell checking or image decoding. In conjunction with a tool called RLBox, which provides a <a href="https://hacks.mozilla.org/2020/02/securing-firefox-with-webassembly/">tainting layer</a>, they can protect against vulnerabilities in those libraries without resorting to heavy-handed process isolation. For Firefox, they don’t even ship Wasm binaries in their final release; the process of compiling to Wasm and then transpiling to another language, coupled with RLBox, provides the security they need.</p>

<p>This approach might prevent some serious vulnerabilities from being exploited. Since attackers usually chain multiple vulnerabilities together, such intermediate security layers will probably be invaluable moving forwards.</p>

<h3 id="containerization">Containerization</h3>

<p>In an oft-cited <a href="https://twitter.com/solomonstre/status/1111004913222324225?ref_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1111004913222324225%7Ctwgr%5E%7Ctwcon%5Es1_&amp;ref_url=https%3A%2F%2Fnickymeuleman.netlify.app%2Fblog%2Fwebassemblysecurity">tweet</a>, Docker founder Solomon Hykes underscored the importance of WebAssembly:</p>

<blockquote>
  <p>If WASM+WASI existed in 2008, we wouldn’t have needed to created Docker. That’s how important it is. Webassembly on the server is the future of computing.</p>
</blockquote>

<p>There’s <a href="https://kubesphere.io/blogs/will-cloud-native-webassembly-replace-docker_/">good reason</a> to believe that Wasm represents the future of containerization. <strong>Compared to Docker, it has 10-100x faster cold start times, has a smaller footprint, and uses a better-constrained capability-based security model.</strong> Making Wasm modules, as opposed to containers, the standard unit of compute and deployment would enable better scalability and security.</p>

<p>Such a transition isn’t going to happen overnight, so Wasm-based containerization will likely integrate into existing orchestration systems rather than attempting to replace Docker entirely.</p>

<p>I anticipate this space will be buzzing with activity over the next few years. A few projects are already leading the charge:</p>

<ul>
  <li>Microsoft Azure’s Deis Labs built <a href="https://krustlet.dev/">Krustlet</a>, which is a way to run Wasm workloads in existing Kubernetes clusters.</li>
  <li>Deis Labs also released <a href="https://github.com/deislabs/hippo">Hippo</a>, a Wasm-centric platform-as-a-service. I would guess that <a href="https://github.com/fermyon">Fermyon</a> is trying to commercialize that tech.</li>
  <li>With their <a href="https://github.com/wasmCloud/wasmCloud">wasmCloud</a> project, <a href="https://cosmonic.com/">Cosmonic</a> is building a platform and orchestration tier that combines Wasm containerization with the actor model for distributed systems.</li>
  <li>The <a href="https://github.com/lunatic-solutions/lunatic">Lunatic</a> platform also embraces the actor model and seems to have the best support running multiple light containers on top of a single WebAssembly runtime process.</li>
  <li><a href="https://suborbital.dev/">Suborbital</a>’s <a href="https://github.com/suborbital/atmo">Atmo</a> is another platform and orchestration system, but is more oriented towards serverless workloads.</li>
</ul>

<h3 id="faasserverless-platforms">FaaS/Serverless Platforms</h3>

<p>Function-as-a-service platforms need to execute user-provided code quickly and safely. Since serverless platforms are often used to run code for short durations, startup times are a particularly important metric. <strong>The ultra-fast cold starts and broad language support make Wasm a good choice for serverless workloads.</strong><sup id="fnref:8" role="doc-noteref"><a href="#fn:8" rel="footnote">8</a></sup></p>

<p>The CDN-edge computing platforms provided by <a href="https://blog.cloudflare.com/webassembly-on-cloudflare-workers/">Cloudflare Workers</a> and <a href="https://www.fastly.com/blog/how-compute-edge-is-tackling-the-most-frustrating-aspects-of-serverless">Fastly Compute@Edge</a> already provide the ability to run WebAssembly. Fastly claims 100x faster startup times than other offerings in the market, and attributes this speedup to their WebAssembly-based compiler and runtime. Netlify and Vercel are also building products in this space.</p>

<p>The serverless platforms built by major cloud providers aren’t far behind: AWS Lambda launched WebAssembly serverless functions a few months ago, and I expect that GCP and Azure will follow suit.</p>

<h3 id="blockchains">Blockchains</h3>

<p>Platforms like Ethereum and Solana provide a mechanism for users to write code, dubbed “smart contracts”, which can run on the blockchain. Ethereum built a fully custom system, creating a language called Solidity, a binary format for the compiled bytecode, and the Ethereum Virtual Machine for sandboxed execution. Solana opted to reuse some existing innovations, harnessing the LLVM compiler infrastructure to compile C, C++, or Rust code into a binary bytecode format inspired by the Berkeley Packet Filter, but still built their own runtime called Sealevel.</p>

<p>WebAssembly already provides much of this infrastructure: it lets users write code in the language of their choosing, provides compiler infrastructure to produce Wasm bytecode, and has numerous high-performance runtimes.</p>

<p>But if Ethereum and Solana have already built this infrastructure, what value does WebAssembly provide? The main value-add is actually around ecosystems. For example, Ethereum has its own language for writing smart contracts, which means that it is unable to leverage all the libraries and common functions that have been written in other languages. Solana is a bit better since it can use the Rust ecosystem. Assuming the technical challenges can be overcome, <strong>WebAssembly opens up smart contract development to a much wider audience and enables them to use the libraries and tools they’re already comfortable with.</strong></p>

<p>I am definitely not the first to make this realization. The Polkadot network, for example, uses a <a href="https://wiki.polkadot.network/docs/learn-wasm">WebAssembly-based virtual machine</a> as its runtime. The EOS virtual machine is also <a href="https://eos.io/news/eos-virtual-machine-a-high-performance-blockchain-webassembly-interpreter/">based on WebAssembly</a>. <a href="https://cosmwasm.com/">CosmWasm</a> uses it to build smart contracts that work across multiple blockchains. There was also a proposal called <a href="https://github.com/ewasm/design">eWASM</a> to replace the Ethereum Virtual Machine with a limited subset of WebAssembly, but it seems that effort has since fizzled out. The Wasmer runtime provides a “singlepass” compiler mode that is explicitly built for blockchains, while WasmEdge claims to have an Ethereum-compatible smart contract execution engine.</p>

<h2 id="predictions-and-opportunities">Predictions and Opportunities</h2>

<h3 id="a-new-application-architecture">A New Application Architecture</h3>

<p>Just as Docker could not replace virtual machines entirely, Wasm cannot replace Docker entirely. For instance, Docker containers can’t run custom OS kernels while virtual machines can. Similarly, Wasm containers can’t use some specialized CPU instructions, like x86’s 256-bit AVX instructions,<sup id="fnref:9" role="doc-noteref"><a href="#fn:9" rel="footnote">9</a></sup> and hence can’t compete with Docker on performance for some applications.</p>

<p>In my opinion, the set of workloads that Docker can support but Wasm can’t is currently larger than the analogous delta between Docker and virtual machines. However, Wasm is still a developing technology and hence will incrementally be able to address more types of workloads. Docker’s rise was closely coupled with the rise of microservice architectures. This took monolithic applications that were well-suited for virtual machines and replaced them with microservices that were well-suited for Docker containers. We’ll probably see <strong>a new application architecture that takes advantage of WebAssembly’s unique capabilities</strong>.</p>

<p>As per Conway’s law, an application’s architecture reflects the communication structure of the organization that produces it. Every new “reference architecture” throughout the history of computing has reduced the amount of coordination that is required between people. From mainframes to virtual machines to Docker containers, the number of people required to produce a deployable unit has progressively decreased. We’ve achieved this by decomposing systems into smaller and smaller components and by allowing the people building those components to work independently against well-defined interfaces. While microservices have decomposed monolithic applications into several small independent services, <strong>WebAssembly makes it easier to decompose microservices into even smaller components</strong>.<sup id="fnref:10" role="doc-noteref"><a href="#fn:10" rel="footnote">10</a></sup></p>

<p>What will this look like? Here’s a few possibilities:</p>

<ul>
  <li>When you split applications into the core business logic and the glue code needed to work with other systems, it turns out that the business logic is usually pretty small compared to the rest. By separating the interface of the glue code from the implementation of the capability it provides, it becomes possible to build business logic-centric applications and delegate the rest to external capability providers. Coupled with the long sidelined <a href="https://www.brianstorti.com/the-actor-model/">actor model</a>, this is the essence of <a href="https://github.com/wasmCloud/wasmCloud">wasmCloud</a>’s approach.</li>
  <li>Another possibility is that serverless architecture is the next step beyond microservices. Most services can be segmented into stateful and stateless portions, and the stateless portions can run as arbitrarily scalable serverless functions. In this case, WebAssembly serves as a convenient and easily scalable runtime for those serverless functions.</li>
  <li>WebAssembly might change the way we take on third-party dependencies. Modern code relies heavily on third-party libraries,<sup id="fnref:11" role="doc-noteref"><a href="#fn:11" rel="footnote">11</a></sup> and most of these dependencies are not vetted fully or frequently. As software supply chain issues like the recent <a href="https://en.wikipedia.org/wiki/Log4Shell">Log4j vulnerabilities</a> come to light, I expect people will start to take security of third-party libraries more seriously. Approaches like Firefox’s use of Wasm and RLBox to isolate certain libraries will become more widespread. It might also be feasible to isolate third-party libraries into separate capability-constrained containers within the same Wasm runtime, assuming the performance limitations can be overcome.<sup id="fnref:12" role="doc-noteref"><a href="#fn:12" rel="footnote">12</a></sup></li>
</ul>

<h3 id="brownfield-deployment">Brownfield Deployment</h3>

<p>Wasm will eventually need to interoperate with Docker in some way. For the next couple years this is not strictly necessary, since Wasm will primarily be used in greenfield deployments with few requirements for backwards compatibility. But ultimately brownfield deployments need to be easy for Wasm to fully win the containerization race, especially in enterprise settings.</p>

<p>One potential outcome is that Docker will integrate a Wasm runtime. While plausible, I expect Wasm will be sufficiently differentiated to warrant a separate tooling entirely. Instead, <strong>the unification of Docker and Wasm containers will happen at the orchestration layer</strong>.</p>

<p>It’s less clear if Kubernetes will effectively integrate Wasm-based execution or if a new orchestration system will emerge. On one hand, Kubernetes is currently the unrivaled king of orchestration. It has incredible momentum, and the Wasm containerization movement would be wise to ride on its coattails. Folks at Microsoft are investing in that future by building <a href="https://github.com/krustlet/krustlet">Krustlet</a>, which lets you run Wasm workloads in Kubernetes. On the other hand, Wasm code will have different requirements than Docker containers and hence Kubernetes might not be the right fit. For example, it would be useful to set up shared memory for inter-container communication when using Wasm-based third-party library isolation, which would be difficult to do with Kubernetes. Such Wasm-native orchestrators will eventually build bridges that ease migration from or integration with Docker.</p>

<p>While I’m hopeful for the upcoming wave of Wasm orchestrators, Kubernetes is sufficiently entrenched that it’s probably not going anywhere in the short-term.</p>

<h3 id="standardized-serverlessedge-framework">Standardized Serverless/Edge Framework</h3>

<p>Most serverless providers have their own framework for defining routes and lambda functions. Cloudflare, for instance, defines its own “cf” type and provides a CLI tool called wrangler for setting up code scaffolding. Fastly has its own set of interfaces for interacting with caches and logging, and AWS Lambda has a similar setup. The Fission framework for Kubernetes has its own set of libraries for integration with various languages. Some platforms try to circumvent this problem by letting users provide a Docker container, such that the platform only needs to handle execution. <a href="https://knative.dev/docs/">Knative</a> and <a href="https://fly.io/">Fly.io</a> both follow this approach. However, they must then keep a “warm pool” of workers to reduce the impact of cold start times, or pass this problem on to their users.</p>

<p>There’s an opportunity to build a standardized serverless function definition and deployment spec. The popular <a href="https://github.com/serverless/serverless">Serverless Framework</a> does a decent job at abstracting deployment, but still leaks provider-specific details into the function implementations. As soon as those details are abstracted away, multi-cloud deployments become much easier and hence the framework becomes much more powerful. It could eventually be like the Terraform of serverless.<sup id="fnref:13" role="doc-noteref"><a href="#fn:13" rel="footnote">13</a></sup></p>

<h3 id="package-management">Package Management</h3>

<p>Every programming language has an ecosystem around it. Most modern languages have a centralized package registry: Python has PyPI, NodeJS has npm, and Rust has Crates.io. Such registries, and the tooling and workflows that accompany them, are important to developing a high quality ecosystem and makes developer lives much easier.</p>

<p>For Wasm, the <a href="https://wapm.io/">WebAssembly Package Manager</a> (WAPM) promised to fill that gap. However, in practice the project seems largely dormant. At the time of writing, only three packages have been updated in the <a href="https://web.archive.org/web/20211229050050/https://wapm.io/">past two months</a>. The issue is that packages are supposed to build on each other, but WAPM only works well for standalone Wasm binaries with no inter-dependencies. The other option for a developer is to publish Wasm modules to npm, but of course this is not ideal for building a Wasm ecosystem beyond JavaScript or AssemblyScript as it does not encourage cross-language interoperability.</p>

<p>The issue isn’t really the fault of WAPM or npm, but rather a rough edge with WebAssembly itself.</p>

<blockquote>
  <p>attempting to write any non-trivial WebAssembly application that tries to interoperate across runtime or language boundaries requires significant effort today, and exchanging any non-fundamental data types (such as strings or structures) involves pointer arithmetic and low-level memory manipulation.</p>

  <p>― <a href="https://radu-matei.com/blog/intro-wasm-components/">Introduction to WebAssembly components | radu’s blog</a></p>
</blockquote>

<p>This is exactly the problem that the WebAssembly Component Model will solve. Wasm components standardizes the WebAssembly Interface format, and provides <a href="https://github.com/bytecodealliance/wit-bindgen">code generators</a> for both implementing and consuming those interfaces. In other words, it lets us easily cross runtime and language boundaries with Wasm.</p>

<p>There’s a big opportunity to build a high quality package manager for WebAssembly. It should use Wasm components codegen to generate bindings for using Wasm modules from other languages. If the tooling is sufficiently good, it could make cross-language development a breeze, which would be the real unlock for the server-side WebAssembly ecosystem. The Wasm package registry could even syndicate across other package registries, automatically publishing packages with appropriate generated bindings to PyPI, npm, and Crates.io.</p>

<h2 id="conclusion">Conclusion</h2>

<p>At this point you’re probably thinking: if WebAssembly is so good, why isn’t it more widely used? Let me volunteer some responses:</p>

<ul>
  <li>WebAssembly’s marketing hasn’t been great. The name is a misnomer, since it is neither restricted to the web nor is it assembly. WebAssembly has primarily been marketed and <a href="https://blog.bitsrc.io/whats-wrong-with-web-assembly-3b9abb671ec2">pushed towards web developers</a>, but its real potential lies beyond the browser. The real unlock will come when C++ and Rust developers, en masse, start to recognize the potential that Wasm holds.</li>
  <li>WebAssembly standardization isn’t there yet. For example, the WebAssembly System Interface has numerous extensions that have not been officially standardized, but various runtimes implement a selection of these extensions. The promise of universal portability has not yet been fully realized.</li>
  <li>Cross-language interactions suck. We need WebAssembly components and good code generators for a critical mass of languages before people actually start to use Wasm across different languages.</li>
  <li>The developer experience leaves much to be desired. I’d love to see improvements in tooling, especially <a href="https://thenewstack.io/the-pain-of-debugging-webassembly/">around debugging</a>, and integrations with package managers, build systems, and IDEs.</li>
  <li>I hate to say this, but we probably need a few more severe software supply-chain incidents, of similar scale to Log4Shell, before WebAssembly’s library isolation capabilities are fully appreciated.</li>
</ul>

<p>WebAssembly has been deployed in a fairly impressive list of places and serves an assortment of use cases, but these represent isolated pockets of activity within the broader tech world. Among my friends, the small fraction who have heard of WebAssembly think it’s really exciting in principle, but are not building with it because it isn’t quite mature yet. However, many of these issues are being actively worked on and will probably reach an acceptable state within the next year or two. As such, it seems <strong>we’re on the brink of an explosion in WebAssembly activity, ecosystem, and community</strong>.</p>

<p><em>Thanks to Nihar Sheth, Mohak Jain, Andrew Sun, and Michelle Fang for their feedback on early drafts of this article.</em></p>

<h2 id="notes">Notes</h2>



  </div>
</article>

      </div>
    </div></div>
  </body>
</html>
