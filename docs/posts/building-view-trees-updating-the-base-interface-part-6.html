<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.stanistan.com/writes/building-view-trees-in-go-part-6/">Original</a>
    <h1>Building view-trees: Updating the base interface [Part 6]</h1>
    
    <div id="readability-page-1" class="page"><article>
        
        

        

        

        <section>
            <p>Previously: <a href="https://www.stanistan.com/writes/building-view-trees-in-go-part-1">intro</a>, <a href="https://www.stanistan.com/writes/building-view-trees-in-go-part-2">the basics</a>, <a href="https://www.stanistan.com/writes/building-view-trees-in-go-part-3">error handling</a>,
<a href="https://www.stanistan.com/writes/building-view-trees-in-go-part-4">async data fetching</a>, and <a href="https://www.stanistan.com/writes/building-view-trees-in-go-part-5">http.Handler</a>.</p>
<hr/>
<p>We have a thing that kind of works and in building out our interfaces and types
we end up with something that is just a bit more complicated than we need, and
a bit too specific, or not specific enough.</p>
<p>Our concepts <a rel="nofollow noreferrer" href="https://pkg.go.dev/github.com/stanistan/veun@v0.0.0-20231208164029-003211b1d092#Renderable">include</a>: Renderables, AsRenderables, Views, ErrorRenderables,
RequestRenderables, RequestHandlers. To be fair this isn&#39;t a ton, but it has a smell,
and it&#39;s a lot to type.</p>
<p>I have questions like:</p>
<ul>
<li>Why do we have both an <code>AsRenderable</code> and <code>Renderable</code>?</li>
<li>Why do most of our <code>Renderable</code> functions return <code>View</code>?</li>
<li>Are these the same?</li>
<li>Why do we <em>always</em> need a <code>template</code> in order to render something?</li>
</ul>
<p>Do we need both interfaces and interface factories (which is what we have and that
feels bad)?</p>
<h2 id="renderable-but-like-to-html">Renderable, but like, to HTML</h2>
<p>The <code>Renderable</code> interface should probably only be, this gives us the ability
to render strings, or have some async calls that just return html, or something
else.</p>
<pre data-lang="go"><code data-lang="go"><span>type </span><span>Renderable </span><span>interface </span><span>{
</span><span>    </span><span>RenderToHTML</span><span>(ctx context.</span><span>Context</span><span>) (template.</span><span>HTML</span><span>, </span><span>error</span><span>)
</span><span>}
</span><span>
</span><span>type </span><span>RenderableFunc </span><span>func</span><span>(context.</span><span>Context</span><span>) (template.</span><span>HTML</span><span>, </span><span>error</span><span>)
</span></code></pre>










<div>
  <details>
    <summary>
      RenderToHML()
      <a href="https://github.com/stanistan/veun/commit/7130ec0402ce80a862bd9ea71529c92ebb1df024">(source: 7130ec04)</a>
    </summary>

<pre data-lang="patch"><code data-lang="patch"><span>diff --git a/render_container_test.go b/render_container_test.go
</span><span>index aef4e68..1876b12 100644
</span><span>---</span><span> a/render_container_test.go
</span><span>+++</span><span> b/render_container_test.go
</span><span>@@ -32,15 +32,15 @@ func tplWithRealSlotFunc(ctx context.Context, tpl *template.Template, slots map[
</span><span> 	})
</span><span> }
</span><span> 
</span><span>-func (v ContainerView) Template(ctx context.Context) (*template.Template, error) {
</span><span>-	return tplWithRealSlotFunc(ctx, containerViewTpl, map[string]AsRenderable{
</span><span>-		&#34;heading&#34;: v.Heading,
</span><span>-		&#34;body&#34;:    v.Body,
</span><span>-	}), nil
</span><span>-}
</span><span>-
</span><span>-func (v ContainerView) TemplateData(_ context.Context) (any, error) {
</span><span>-	return nil, nil
</span><span>+</span><span>func (v ContainerView) RenderToHTML(ctx context.Context) (template.HTML, error) {
</span><span>+</span><span>	return RenderToHTML(tplWithRealSlotFunc(
</span><span>+</span><span>		ctx,
</span><span>+</span><span>		containerViewTpl,
</span><span>+</span><span>		map[string]AsRenderable{
</span><span>+</span><span>			&#34;heading&#34;: v.Heading,
</span><span>+</span><span>			&#34;body&#34;:    v.Body,
</span><span>+</span><span>		},
</span><span>+</span><span>	), nil)
</span><span> }
</span><span> 
</span><span> func (v ContainerView) Renderable(_ context.Context) (Renderable, error) {
</span><span>diff --git a/renderable.go b/renderable.go
</span><span>index 27759f6..aa0bc86 100644
</span><span>---</span><span> a/renderable.go
</span><span>+++</span><span> b/renderable.go
</span><span>@@ -5,14 +5,10 @@ import (
</span><span> 	&#34;html/template&#34;
</span><span> )
</span><span> 
</span><span>-// Renderable represents any struct that can be rendered
</span><span>-// in the Render function.
</span><span>+</span><span>// Renderable represents anything that can be rendered
</span><span>+</span><span>// to HTML.
</span><span> type Renderable interface {
</span><span>-	// Template provides the template object / parsed and compiled,
</span><span>-	// that Render will execute given a context.
</span><span>-	Template(ctx context.Context) (*template.Template, error)
</span><span>-	// TemplateData provides the data to the template given a context.
</span><span>-	TemplateData(ctx context.Context) (any, error)
</span><span>+</span><span>	RenderToHTML(ctx context.Context) (template.HTML, error)
</span><span> }
</span><span> 
</span><span> type AsRenderable interface {
</span><span>diff --git a/renderer.go b/renderer.go
</span><span>index 1ff48e3..e3a5204 100644
</span><span>---</span><span> a/renderer.go
</span><span>+++</span><span> b/renderer.go
</span><span>@@ -17,7 +17,7 @@ func Render(ctx context.Context, r AsRenderable) (template.HTML, error) {
</span><span> 		return handleRenderError(ctx, err, r)
</span><span> 	}
</span><span> 
</span><span>-	out, err := render(ctx, renderable)
</span><span>+</span><span>	out, err := renderable.RenderToHTML(ctx)
</span><span> 	if err != nil {
</span><span> 		return handleRenderError(ctx, err, r)
</span><span> 	}
</span><span>@@ -25,23 +25,13 @@ func Render(ctx context.Context, r AsRenderable) (template.HTML, error) {
</span><span> 	return out, nil
</span><span> }
</span><span> 
</span><span>-func render(ctx context.Context, r Renderable) (template.HTML, error) {
</span><span>+</span><span>func RenderToHTML(tpl *template.Template, data any) (template.HTML, error) {
</span><span> 	var empty template.HTML
</span><span> 
</span><span>-	tpl, err := r.Template(ctx)
</span><span>-	if err != nil {
</span><span>-		return empty, fmt.Errorf(&#34;Template(): %w&#34;, err)
</span><span>-	}
</span><span>-
</span><span> 	if tpl == nil {
</span><span> 		return empty, fmt.Errorf(&#34;missing template&#34;)
</span><span> 	}
</span><span> 
</span><span>-	data, err := r.TemplateData(ctx)
</span><span>-	if err != nil {
</span><span>-		return empty, fmt.Errorf(&#34;TemplateData(): %w&#34;, err)
</span><span>-	}
</span><span>-
</span><span> 	var bs bytes.Buffer
</span><span> 	if err := tpl.Execute(&amp;bs, data); err != nil {
</span><span> 		return empty, fmt.Errorf(&#34;tpl.Execute(): %w&#34;, err)
</span><span>diff --git a/view.go b/view.go
</span><span>index 99578bf..b39ef50 100644
</span><span>---</span><span> a/view.go
</span><span>+++</span><span> b/view.go
</span><span>@@ -2,7 +2,6 @@ package veun
</span><span> 
</span><span> import (
</span><span> 	&#34;context&#34;
</span><span>-	&#34;fmt&#34;
</span><span> 	&#34;html/template&#34;
</span><span> 	&#34;io/fs&#34;
</span><span> )
</span><span>@@ -13,16 +12,13 @@ type View struct {
</span><span> 	Data  any
</span><span> }
</span><span> 
</span><span>-func (v View) Template(ctx context.Context) (*template.Template, error) {
</span><span>-	if v.Tpl == nil {
</span><span>-		return nil, fmt.Errorf(&#34;template missing&#34;)
</span><span>+</span><span>func (v View) RenderToHTML(ctx context.Context) (template.HTML, error) {
</span><span>+</span><span>	tpl := v.Tpl
</span><span>+</span><span>	if v.Tpl != nil {
</span><span>+</span><span>		tpl = v.Slots.addToTemplate(ctx, v.Tpl)
</span><span> 	}
</span><span> 
</span><span>-	return v.Slots.addToTemplate(ctx, v.Tpl), nil
</span><span>-}
</span><span>-
</span><span>-func (v View) TemplateData(_ context.Context) (any, error) {
</span><span>-	return v.Data, nil
</span><span>+</span><span>	return RenderToHTML(tpl, v.Data)
</span><span> }
</span><span> 
</span><span> func (v View) Renderable(_ context.Context) (Renderable, error) {
</span><span>
</span></code></pre>


  </details>
</div>
<p>Leaving the template bits to be an implementation detail of the
specific <em>kind</em> of Renderable.</p>
<pre data-lang="go"><code data-lang="go"><span>type </span><span>TemplateRenderable </span><span>struct </span><span>{
</span><span>    Template </span><span>*</span><span>template.</span><span>Template
</span><span>    Data     </span><span>any
</span><span>}
</span><span>
</span><span>func </span><span>(t </span><span>TemplateRenderable</span><span>) </span><span>RenderToHTML</span><span>(ctx context.</span><span>Context</span><span>) (template.</span><span>HTML</span><span>, </span><span>error</span><span>) {
</span><span>    </span><span>// the content of our `render` function
</span><span>}
</span></code></pre>
<p>Where a <code>View</code> can defer to be <code>TemplateRenderable</code> but with <code>Slots</code>.</p>
<h3 id="lists">Lists</h3>
<p>Removing the need for a template also gives us the ability to concatenate, and
potentially make some views cheaper to construct.</p>
<pre data-lang="go"><code data-lang="go"><span>type </span><span>Views []</span><span>AsRenderable
</span><span>
</span><span>func </span><span>(vs </span><span>Views</span><span>) </span><span>Renderable</span><span>(_ context.</span><span>Context</span><span>) (</span><span>Renderable</span><span>, </span><span>error</span><span>) { </span><span>return </span><span>vs, </span><span>nil </span><span>}
</span><span>
</span><span>func </span><span>(vs </span><span>Views</span><span>) </span><span>RenderToHTML</span><span>( </span><span>/*........
</span></code></pre>
<h3 id="div">&lt;div /&gt;</h3>
<p>Or maybe you wanted to do something like:</p>
<pre data-lang="go"><code data-lang="go"><span>func </span><span>Div</span><span>(contents </span><span>AsRenderable</span><span>) </span><span>AsRenderable </span><span>{
</span><span>    </span><span>return </span><span>RenderableFunc(</span><span>func</span><span>(ctx context.</span><span>Context</span><span>) (template.</span><span>HTML</span><span>, </span><span>error</span><span>) {
</span><span>        inner, out </span><span>:= </span><span>Render(ctx, r)
</span><span>        </span><span>if </span><span>err </span><span>!= </span><span>nil </span><span>{
</span><span>            </span><span>return </span><span>inner, err
</span><span>        }
</span><span>
</span><span>        </span><span>return </span><span>template.HTML(</span><span>&#34;&lt;div&gt;&#34;</span><span>) </span><span>+ </span><span>inner </span><span>+ </span><span>template.HTML(</span><span>&#34;&lt;/div&gt;&#34;</span><span>), </span><span>nil
</span><span>    })
</span><span>}
</span></code></pre>
<p>But this doesn&#39;t really seem that great at all, and feels like we&#39;re
leaking our implementation. We have the flexibility to do this, but
we&#39;re losing our delcarative composability.</p>
<p>We can:</p>
<ol>
<li>make a <code>Raw</code> type that is a string wrapper, and</li>
<li>reuse <code>Views</code> to elide the inner call to <code>Render</code></li>
</ol>
<pre data-lang="go"><code data-lang="go"><span>type </span><span>Raw </span><span>string
</span><span>
</span><span>func </span><span>(r </span><span>Raw</span><span>) </span><span>RenderToHTML</span><span>(_ context.</span><span>Context</span><span>) (template.</span><span>HTML</span><span>, </span><span>error</span><span>) {
</span><span>    </span><span>return </span><span>template.HTML(r), </span><span>nil
</span><span>}
</span><span>
</span><span>func </span><span>Div</span><span>(contents </span><span>AsRenderable</span><span>) </span><span>AsRenderable </span><span>{
</span><span>    </span><span>return </span><span>RenderableFunc(</span><span>func</span><span>(_ context.</span><span>Context</span><span>) </span><span>Renderable </span><span>{
</span><span>        </span><span>return </span><span>Views{
</span><span>            Raw(</span><span>&#34;&lt;div&gt;&#34;</span><span>), contents, Raw(</span><span>&#34;&lt;/div&gt;&#34;</span><span>),
</span><span>        }
</span><span>    })
</span><span>}
</span></code></pre>










<div>
  <details>
    <summary>
      w/ common_views (Raw &amp; Views)
      <a href="https://github.com/stanistan/veun/commit/ef34bc30ac2946fb83c143f84c80816d5a36a3e0">(source: ef34bc30)</a>
    </summary>

<pre data-lang="patch"><code data-lang="patch"><span>diff --git a/common_views.go b/common_views.go
</span><span>new file mode 100644
</span><span>index 0000000..dd96434
</span><span>---</span><span> /dev/null
</span><span>+++</span><span> b/common_views.go
</span><span>@@ -0,0 +1,61 @@
</span><span>+</span><span>package veun
</span><span>+
</span><span>+</span><span>import (
</span><span>+</span><span>	&#34;context&#34;
</span><span>+</span><span>	&#34;html/template&#34;
</span><span>+</span><span>)
</span><span>+
</span><span>+</span><span>type Raw string
</span><span>+
</span><span>+</span><span>func (r Raw) Renderable(_ context.Context) (Renderable, error) { return r, nil }
</span><span>+
</span><span>+</span><span>func (r Raw) RenderToHTML(_ context.Context) (template.HTML, error) {
</span><span>+</span><span>	return template.HTML(r), nil
</span><span>+</span><span>}
</span><span>+
</span><span>+</span><span>type Views []AsRenderable
</span><span>+
</span><span>+</span><span>func (vs Views) Renderable(ctx context.Context) (Renderable, error) {
</span><span>+</span><span>	return vs, nil
</span><span>+</span><span>}
</span><span>+
</span><span>+</span><span>func (vs Views) RenderToHTML(ctx context.Context) (template.HTML, error) {
</span><span>+</span><span>	var out template.HTML
</span><span>+
</span><span>+</span><span>	for _, v := range vs {
</span><span>+</span><span>		r, err := v.Renderable(ctx)
</span><span>+</span><span>		if err != nil {
</span><span>+</span><span>			return template.HTML(&#34;&#34;), err
</span><span>+</span><span>		}
</span><span>+
</span><span>+</span><span>		html, err := r.RenderToHTML(ctx)
</span><span>+</span><span>		if err != nil {
</span><span>+</span><span>			return template.HTML(&#34;&#34;), err
</span><span>+</span><span>		}
</span><span>+
</span><span>+</span><span>		out += html
</span><span>+</span><span>	}
</span><span>+
</span><span>+</span><span>	return out, nil
</span><span>+</span><span>}
</span><span>+
</span><span>+</span><span>type RViews []Renderable
</span><span>+
</span><span>+</span><span>func (vs RViews) Renderable(_ context.Context) (Renderable, error) {
</span><span>+</span><span>	return vs, nil
</span><span>+</span><span>}
</span><span>+
</span><span>+</span><span>func (vs RViews) RenderToHTML(ctx context.Context) (template.HTML, error) {
</span><span>+</span><span>	var out template.HTML
</span><span>+
</span><span>+</span><span>	for _, r := range vs {
</span><span>+</span><span>		html, err := r.RenderToHTML(ctx)
</span><span>+</span><span>		if err != nil {
</span><span>+</span><span>			return template.HTML(&#34;&#34;), err
</span><span>+</span><span>		}
</span><span>+
</span><span>+</span><span>		out += html
</span><span>+</span><span>	}
</span><span>+
</span><span>+</span><span>	return out, nil
</span><span>+</span><span>}
</span><span>diff --git a/common_views_test.go b/common_views_test.go
</span><span>new file mode 100644
</span><span>index 0000000..ef724f4
</span><span>---</span><span> /dev/null
</span><span>+++</span><span> b/common_views_test.go
</span><span>@@ -0,0 +1,29 @@
</span><span>+</span><span>package veun_test
</span><span>+
</span><span>+</span><span>import (
</span><span>+</span><span>	&#34;context&#34;
</span><span>+</span><span>	&#34;html/template&#34;
</span><span>+</span><span>	&#34;testing&#34;
</span><span>+
</span><span>+</span><span>	&#34;github.com/alecthomas/assert/v2&#34;
</span><span>+
</span><span>+</span><span>	. &#34;github.com/stanistan/veun&#34;
</span><span>+</span><span>)
</span><span>+
</span><span>+</span><span>func Div(contents AsRenderable) AsRenderable {
</span><span>+</span><span>	return Views{
</span><span>+</span><span>		Raw(&#34;&lt;div&gt;&#34;), contents, Raw(&#34;&lt;/div&gt;&#34;),
</span><span>+</span><span>	}
</span><span>+</span><span>}
</span><span>+
</span><span>+</span><span>func TestCommonViews(t *testing.T) {
</span><span>+</span><span>	html, err := Render(context.Background(), Div(ChildView1{}))
</span><span>+</span><span>	assert.NoError(t, err)
</span><span>+</span><span>	assert.Equal(t, template.HTML(&#34;&lt;div&gt;HEADING&lt;/div&gt;&#34;), html)
</span><span>+</span><span>}
</span><span>+
</span><span>+</span><span>func BenchmarkCommonViews(b *testing.B) {
</span><span>+</span><span>	for i := 0; i &lt; b.N; i++ {
</span><span>+</span><span>		_, _ = Render(context.Background(), Div(ChildView1{}))
</span><span>+</span><span>	}
</span><span>+</span><span>}
</span><span>diff --git a/slots.go b/slots.go
</span><span>index 8a04e81..bb69032 100644
</span><span>---</span><span> a/slots.go
</span><span>+++</span><span> b/slots.go
</span><span>@@ -20,5 +20,9 @@ func (s Slots) renderSlot(ctx context.Context) func(string) (template.HTML, erro
</span><span> }
</span><span> 
</span><span> func (s Slots) addToTemplate(ctx context.Context, t *template.Template) *template.Template {
</span><span>+</span><span>	if t == nil {
</span><span>+</span><span>		return nil
</span><span>+</span><span>	}
</span><span>+
</span><span> 	return t.Funcs(template.FuncMap{&#34;slot&#34;: s.renderSlot(ctx)})
</span><span> }
</span><span>
</span></code></pre>


  </details>
</div>
<p>And now since we&#39;re no longer doing any render call, we
can make it even clearer:</p>
<pre data-lang="go"><code data-lang="go"><span>func </span><span>Div</span><span>(contents </span><span>AsRenderable</span><span>) </span><span>AsRenderable </span><span>{
</span><span>    </span><span>return </span><span>Views{
</span><span>        Raw(</span><span>&#34;&lt;div&gt;&#34;</span><span>), contents, Raw(</span><span>&#34;&lt;/div&gt;&#34;</span><span>), </span><span>// NICE :boom:
</span><span>    }
</span><span>}
</span></code></pre>










<div>
  <details>
    <summary>
      w/ TemplateRenderable
      <a href="https://github.com/stanistan/veun/commit/f427fa0ee981019b9e48a2e99d2a016f035b4af4">(source: f427fa0e)</a>
    </summary>

<pre data-lang="patch"><code data-lang="patch"><span>diff --git a/render_container_test.go b/render_container_test.go
</span><span>index 1876b12..6be78c3 100644
</span><span>---</span><span> a/render_container_test.go
</span><span>+++</span><span> b/render_container_test.go
</span><span>@@ -33,14 +33,12 @@ func tplWithRealSlotFunc(ctx context.Context, tpl *template.Template, slots map[
</span><span> }
</span><span> 
</span><span> func (v ContainerView) RenderToHTML(ctx context.Context) (template.HTML, error) {
</span><span>-	return RenderToHTML(tplWithRealSlotFunc(
</span><span>-		ctx,
</span><span>-		containerViewTpl,
</span><span>-		map[string]AsRenderable{
</span><span>+</span><span>	return TemplateRenderable{
</span><span>+</span><span>		Tpl: tplWithRealSlotFunc(ctx, containerViewTpl, map[string]AsRenderable{
</span><span> 			&#34;heading&#34;: v.Heading,
</span><span> 			&#34;body&#34;:    v.Body,
</span><span>-		},
</span><span>-	), nil)
</span><span>+</span><span>		}),
</span><span>+</span><span>	}.RenderToHTML(ctx)
</span><span> }
</span><span> 
</span><span> func (v ContainerView) Renderable(_ context.Context) (Renderable, error) {
</span><span>diff --git a/renderer.go b/renderer.go
</span><span>index e3a5204..4fab94b 100644
</span><span>---</span><span> a/renderer.go
</span><span>+++</span><span> b/renderer.go
</span><span>@@ -7,33 +7,55 @@ import (
</span><span> 	&#34;html/template&#34;
</span><span> )
</span><span> 
</span><span>-func Render(ctx context.Context, r AsRenderable) (template.HTML, error) {
</span><span>+</span><span>func RenderToHTML(ctx context.Context, r Renderable, errHandler any) (template.HTML, error) {
</span><span>+</span><span>	var empty template.HTML
</span><span>+
</span><span> 	if r == nil {
</span><span>-		return template.HTML(&#34;&#34;), nil
</span><span>+</span><span>		return empty, nil
</span><span>+</span><span>	}
</span><span>+
</span><span>+</span><span>	out, err := r.RenderToHTML(ctx)
</span><span>+</span><span>	if err != nil {
</span><span>+</span><span>		return handleRenderError(ctx, err, errHandler)
</span><span>+</span><span>	}
</span><span>+
</span><span>+</span><span>	return out, nil
</span><span>+</span><span>}
</span><span>+
</span><span>+</span><span>func Render(ctx context.Context, v AsRenderable) (template.HTML, error) {
</span><span>+</span><span>	var empty template.HTML
</span><span>+
</span><span>+</span><span>	if v == nil {
</span><span>+</span><span>		return empty, nil
</span><span> 	}
</span><span> 
</span><span>-	renderable, err := r.Renderable(ctx)
</span><span>+</span><span>	r, err := v.Renderable(ctx)
</span><span> 	if err != nil {
</span><span>-		return handleRenderError(ctx, err, r)
</span><span>+</span><span>		return handleRenderError(ctx, err, v)
</span><span> 	}
</span><span> 
</span><span>-	out, err := renderable.RenderToHTML(ctx)
</span><span>+</span><span>	out, err := RenderToHTML(ctx, r, v)
</span><span> 	if err != nil {
</span><span>-		return handleRenderError(ctx, err, r)
</span><span>+</span><span>		return empty, err
</span><span> 	}
</span><span> 
</span><span> 	return out, nil
</span><span> }
</span><span> 
</span><span>-func RenderToHTML(tpl *template.Template, data any) (template.HTML, error) {
</span><span>+</span><span>type TemplateRenderable struct {
</span><span>+</span><span>	Tpl  *template.Template
</span><span>+</span><span>	Data any
</span><span>+</span><span>}
</span><span>+
</span><span>+</span><span>func (v TemplateRenderable) RenderToHTML(_ context.Context) (template.HTML, error) {
</span><span> 	var empty template.HTML
</span><span> 
</span><span>-	if tpl == nil {
</span><span>+</span><span>	if v.Tpl == nil {
</span><span> 		return empty, fmt.Errorf(&#34;missing template&#34;)
</span><span> 	}
</span><span> 
</span><span> 	var bs bytes.Buffer
</span><span>-	if err := tpl.Execute(&amp;bs, data); err != nil {
</span><span>+</span><span>	if err := v.Tpl.Execute(&amp;bs, v.Data); err != nil {
</span><span> 		return empty, fmt.Errorf(&#34;tpl.Execute(): %w&#34;, err)
</span><span> 	}
</span><span> 
</span><span>diff --git a/view.go b/view.go
</span><span>index b39ef50..241cd29 100644
</span><span>---</span><span> a/view.go
</span><span>+++</span><span> b/view.go
</span><span>@@ -13,15 +13,13 @@ type View struct {
</span><span> }
</span><span> 
</span><span> func (v View) RenderToHTML(ctx context.Context) (template.HTML, error) {
</span><span>-	tpl := v.Tpl
</span><span>-	if v.Tpl != nil {
</span><span>-		tpl = v.Slots.addToTemplate(ctx, v.Tpl)
</span><span>-	}
</span><span>-
</span><span>-	return RenderToHTML(tpl, v.Data)
</span><span>+</span><span>	return TemplateRenderable{
</span><span>+</span><span>		Tpl:  v.Slots.addToTemplate(ctx, v.Tpl),
</span><span>+</span><span>		Data: v.Data,
</span><span>+</span><span>	}.RenderToHTML(ctx)
</span><span> }
</span><span> 
</span><span>-func (v View) Renderable(_ context.Context) (Renderable, error) {
</span><span>+</span><span>func (v View) Renderable(ctx context.Context) (Renderable, error) {
</span><span> 	return v, nil
</span><span> }
</span><span> 
</span><span>
</span></code></pre>


  </details>
</div>
<h2 id="errors">Errors</h2>
<p>I&#39;m not going to get to revisiting errors here just yet.</p>

        </section>

        

    </article></div>
  </body>
</html>
