<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jmmv.dev/2025/12/from-azure-functions-to-freebsd.html">Original</a>
    <h1>From Azure Functions to FreeBSD</h1>
    
    <div id="readability-page-1" class="page"><div><div><article><p><em>Putting FreeBSD’s “power to serve” motto to the test.</em></p><p>On Thanksgiving morning, I woke up to one of my web services being unavailable. All HTTP requests failed with a “503 Service unavailable” error. I logged into the console, saw a simplistic “Runtime version: Error” message, and was not able to diagnose the problem.</p><p>I did not spend a lot of time trying to figure the issue out and I didn’t even want to contact the support black hole. Because… there was something else hidden behind an innocent little yellow warning at the top of the dashboard:</p><blockquote><p>Migrate your app to Flex Consumption as Linux Consumption will reach EOL on September 30 2028 and will no longer be supported.</p></blockquote><p>I had known for a few weeks now, while trying to set up a new app, that all of my Azure Functions apps were on death row. The free plan I was using was going to be decommissioned and the alternatives I tried didn’t seem to support custom handlers written in Rust. I still had three years to deal with this, but hitting a showstopper error pushed me to take action.</p><p>All of my web services are now hosted by the FreeBSD server in my garage with just a few tweaks to their codebase. This is their migration story.</p><p>Back in 2021, I had been developing my <a href="https://www.endbasic.dev/">EndBASIC language</a> for over a year and I wanted to create a file sharing service for it. Part of this was to satisfy my users, but another part was to force myself into the web services world as I felt “behind”.</p><p>At that time, I had also <a href="https://jmmv.dev/2020/10/bye-google-hi-microsoft.html">been at Microsoft</a> for a few months already working on Azure Storage. One of the perks of the job was something like $300 of <em>yearly</em> credit to deploy stuff on Azure for learning purposes. It was only “natural” that I’d pick Azure for what I wanted to do with EndBASIC.</p><p>Now… $300 can be plentiful for a simple app, but it can also be paltry. Running a dedicated VM would eat through this in a couple of months, but the serverless model offered by Azure Functions with its “infinite” free tier would go a long way. I looked at their online documentation, found a very good guide on <a href="https://learn.microsoft.com/en-us/azure/azure-functions/how-to-create-function-vs-code?pivots=programming-language-other&amp;tabs=rust%2Clinux">how to deploy Rust-native functions onto a Linux runtime</a>, and… I was sold.</p><p>I quickly got a bare bones service up and running on Azure Functions and I built it up from there. Based on these foundations, I later developed a separate service for my own site analytics (poorly named <a href="https://endtracker.jmmv.dev/">EndTRACKER</a>), and I recently started working on a new service to provide secure auto-unlock of encrypted ZFS volumes (stay tuned!).</p><p>And, for the most part, the experience with Azure has been neat. I learned a bunch and I got to a point where I had set up “push on green” via GitHub Actions and dual staging vs. prod deployments. The apps ran completely on their own for the last three years, a testament to the stability of the platform <em>and</em> to the value of <a href="https://jmmv.dev/2023/07/unit-testing-a-web-service.html">designing for testability</a>. Until now that is.</p><p>Compute-wise, I was set: Azure Functions worked fine as the runtime for my apps’ logic and it cost pennies to run, so the $300 was almost untouched. But web services aren’t made of compute alone: they need to store data, which means they need a database.</p><p>My initial research in 2021 concluded that the only option for a database instance with a free plan was to go with, no surprise, <em>serverless</em> Microsoft SQL Server (MSSQL). I had never used Microsoft’s offering but it couldn’t be that different from PostgreSQL or MySQL, could it?</p><p>Maybe so, but I didn’t get very far in that line of research. The very first blocker I hit was that the MSSQL connection <em>required</em> TLS and this hadn’t been implemented in the <code>sqlx</code> connector I chose to use for my Rust-based functions. I wasted two weeks implementing TLS support in <code>sqlx</code> (see <a href="https://github.com/launchbadge/sqlx/pull/1200">PR #1200</a> and <a href="https://github.com/launchbadge/sqlx/pull/1203">PR #1203</a>) and got it to work, but that code was not accepted upstream because it conflicted with their business strategy. Needless to say, this was disappointing because getting that <a href="https://github.com/jmmv/sqlx/blob/8ac975b1b267d64e7b6b9ec48436e5bf1c92c8a7/sqlx-core/src/mssql/connection/tls.rs"><code>TlsStreamWrapper</code></a> to work was a frigging nightmare. In any case, once I passed that point, I started discovering more missing features and bugs in the MSSQL connector, and then I also found some really weird surprises in MSSQL’s dialect of SQL. TL;DR, this turned into a dead end.</p><figure><img src="https://jmmv.dev/images/2025-12-07-azure-postgres-costs.png" width="100%"/><figcaption>On the left, the default instance and cost selected by Azure when choosing to create a managed PostgreSQL server today. On the right, minimum possible cost after dialing down CPU, RAM, disk, and availability requirements.</figcaption></figure><p>I had no choice other than to provision a full PostgreSQL server on Azure. Their onboarding wizard tried to push me towards a pretty beefy and redundant instance that would cost over $600 per month when all I needed was the lowest machine you could get for the amount of traffic I expected. Those options were hidden under a “for development only” panel and riddled with warnings about no redundancy, but after I dialed all the settings down and accepted the “serious risks”, I was left with an instance that’d cost $15 per month or so. This fit well well within the free yearly credit I had access to, so that was it.</p><p>About two months ago, I started working on <a href="https://x.com/jmmv/status/1964517899101725041">a new service to securely auto-unlock ZFS encrypted volumes</a> (more details coming). For this, I had to create a new Azure Functions deployment… and I started seeing the writing on the wall. I don’t remember the exact details, but it was really difficult to get the creation wizard to provision me the same flex plan I had used for my other services, and it was warning me that the selected plan was going to be axed in 2028.</p><p>At the time of this writing, 2028 is still three years out and this warning was for a new service I was creating. I didn’t want to consider migrating neither EndBASIC nor EndTRACKER to something else just yet. Until Thanksgiving, that was.</p><p>On Thanksgiving morning, I noticed that my web analytics had stopped working. All HTTP API requests failed with a “503 Service unavailable.” error but, interestingly, the cron-triggered APIs were still running in the background just fine and the staging deployment slot of the same app worked fine end-to-end as well. I tried redeploying the app with a fresh binary, thinking that a refresh would fix the problem, but that was of no use. I also poked through the dashboard trying to figure out what “Runtime version: Error” would be about, making sure the version spec in <code>host.json</code> was up-to-date, and couldn’t figure it out either.</p><figure><img src="https://jmmv.dev/images/2025-12-07-azure-functions-runtime-error.png" width="100%"/><figcaption>Summary state of my problematic Azure Functions deployment. Note the cryptic runtime error along with the subtle warning at the top about upcoming deprecations.</figcaption></figure><p>So… I had to get out of Azure Functions, quick.</p><p>Not accidentally, I had bought a second-hand, over-provisioned ThinkStation (2x36-core Xeon E5-2697, 64 GB of RAM, a 2 TB NVMe drive, and a 4x4 TB HDD array) just two years back. The justification I gave myself was to use it as my development server, but I had this idea in the back of my mind to use it to host my own services at some point. The time to put it to serving real-world traffic with FreeBSD 14.x had come.</p><p>The way you run a serverless Rust (or Go) service on Azure Functions is by creating a binary that exposes an HTTP server on the port provided to it by the <code>FUNCTIONS_CUSTOMHANDLER_PORT</code> environment variable. Then, you package the binary along a set of metadata JSON files that tell the runtime what HTTP routes the binary serves and push the packaged ZIP file to Azure. From there on, the Azure Functions runtime handles TLS termination for those routes, spawns your binary server on a micro VM on demand, and redirects the requests to it.</p><p>By removing the Azure Functions runtime from the picture, I had to make my server binary stand alone. This was actually pretty simple because the binary was already an HTTP server: it just had to be coerced into playing nicely with FreeBSD’s approach to running services. In particular, I had to:</p><ul><li>Inject configuration variables into the server process at startup time. These used to come from the Azure Functions configuration page, and are necessary to tell the server where the database lives and what credentials to use.</li><li>Make the service run as an unprivileged user, easily.</li><li>Create a PID file to track the execution of the process so that the <code>rc.d</code> framework could handle restarts and stop requests.</li><li>Store the logs that the service emits via stderr to a log file, and rotate the log to prevent local disk overruns.</li></ul><p>Most daemons implement all of the above as features in their own code, but I did not want to have to retrofit all of these into my existing HTTP service in a rush. Fortunately, FreeBSD provides this little tool, <a href="https://man.freebsd.org/cgi/man.cgi?daemon(8)"><code>daemon(8)</code></a>, which wraps an existing binary and offers all of the above.</p><p>This incantation was enough to get me going:</p><div><pre tabindex="0"><code data-lang="shell"><span><span>daemon <span>\
</span></span></span><span><span><span></span>    -P /var/run/endbasic.pid <span>\
</span></span></span><span><span><span></span>    -o /var/log/endbasic.log <span>\
</span></span></span><span><span><span></span>    -H <span>\
</span></span></span><span><span><span></span>    -u endbasic <span>\
</span></span></span><span><span><span></span>    -t endbasic <span>\
</span></span></span><span><span><span></span>    /bin/sh -c <span>&#39;
</span></span></span><span><span><span>        . /usr/local/etc/endbasic.conf
</span></span></span><span><span><span>        /usr/local/sbin/endbasic&#39;</span>
</span></span></code></pre></div><p>I won’t dive into the details of each flag, but to note: <code>-P</code> specifies which PID file to create; <code>-o</code> specifies where to store the stdout and stderr of the process; <code>-H</code> is required for log rotation (much more below); <code>-u</code> drops privileges to the given user; and <code>-t</code> specifies the “title” of the process to display in <code>ps ax</code> output.</p><p>The <code>. /usr/local/etc/endbasic.conf</code> trick was sufficient to inject configuration variables upon process startup, simulating the same environment that my server used to see when spawned by the Azure Functions runtime.</p><p>Hooking that up into an <code>rc.d</code> service script was then trivial:</p><div><pre tabindex="0"><code data-lang="shell"><span><span><span>#! /bin/sh
</span></span></span><span><span><span></span>
</span></span><span><span><span># PROVIDE: endbasic</span>
</span></span><span><span><span># REQUIRE: NETWORKING postgresql</span>
</span></span><span><span>
</span></span><span><span>. /etc/rc.subr
</span></span><span><span>
</span></span><span><span><span>name</span><span>=</span><span>&#34;endbasic&#34;</span>
</span></span><span><span><span>command</span><span>=</span><span>&#34;daemon&#34;</span>
</span></span><span><span><span>rcvar</span><span>=</span><span>&#34;endbasic_enable&#34;</span>
</span></span><span><span><span>pidfile</span><span>=</span><span>&#34;/var/run/</span><span>${</span><span>name</span><span>}</span><span>.pid&#34;</span>
</span></span><span><span><span>start_cmd</span><span>=</span><span>&#34;endbasic_start&#34;</span>
</span></span><span><span><span>required_files</span><span>=</span><span>&#34;
</span></span></span><span><span><span>    /usr/local/etc/endbasic.conf
</span></span></span><span><span><span>    /usr/local/sbin/endbasic&#34;</span>
</span></span><span><span>
</span></span><span><span>endbasic_start<span>()</span>
</span></span><span><span><span>{</span>
</span></span><span><span>    <span>if</span> <span>[</span> ! -f /var/log/endbasic.log <span>]</span><span>;</span> <span>then</span>
</span></span><span><span>        touch /var/log/endbasic.log
</span></span><span><span>        chmod <span>600</span> /var/log/endbasic.log
</span></span><span><span>        chown endbasic /var/log/endbasic.log
</span></span><span><span>    <span>fi</span>
</span></span><span><span>
</span></span><span><span>    <span>echo</span> <span>&#34;Starting </span><span>${</span><span>name</span><span>}</span><span>.&#34;</span>
</span></span><span><span>    daemon <span>\
</span></span></span><span><span><span></span>        -P <span>&#34;</span><span>${</span><span>pidfile</span><span>}</span><span>&#34;</span> <span>\
</span></span></span><span><span><span></span>        -o /var/log/endbasic.log <span>\
</span></span></span><span><span><span></span>        -H <span>\
</span></span></span><span><span><span></span>        -u endbasic <span>\
</span></span></span><span><span><span></span>        -t endbasic <span>\
</span></span></span><span><span><span></span>        /bin/sh -c <span>&#39;
</span></span></span><span><span><span>            . /usr/local/etc/endbasic.conf
</span></span></span><span><span><span>            /usr/local/sbin/endbasic&#39;</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span>load_rc_config <span>$name</span>
</span></span><span><span>run_rc_command <span>&#34;</span><span>$1</span><span>&#34;</span>
</span></span></code></pre></div><p>And with that:</p><div><pre tabindex="0"><code data-lang="shell"><span><span>sysrc <span>endbasic_enabled</span><span>=</span><span>&#34;YES&#34;</span>
</span></span><span><span>service endbasic start
</span></span></code></pre></div><p>Ta-da! I had the service running locally and listening to a local port determined in the configuration file.</p><p>As part of the migration out of Azure Functions, I switched to self-hosting PostgreSQL as well. This was straightforward but required a couple of extra improvements to my web framework: one to <a href="https://github.com/jmmv/iii-iv/commit/eefd8f4453348de8c01688b7d972fc8f207d04be">stop using a remote PostgreSQL instance for tests</a>(something I should have done eons ago), and another to <a href="https://github.com/jmmv/iii-iv/commit/bc6508959b75ba2ad7107625a5c14f269d742a58">support local peer authentication</a> to avoid unnecessary passwords.</p><p>In the call to <code>daemon</code> above, I briefly mentioned the need for the <code>-H</code> flag to support log rotation. What’s that about?</p><p>You see, in Unix-like systems, when a process opens a file, the process holds a <em>handle</em> to the open file. If you delete or rename the file, the handle <em>continues to exist exactly as it was</em>. This has two consequences:</p><ul><li>If you rename the file, all subsequent reads and writes go to the new file location, not the old one.</li><li>If you delete the file, all subsequent reads and writes continue to go to disk but to a file you cannot reference anymore. You can run out of disk space and, while <code>df</code> will confirm the fact, <code>du</code> will not let you find what file is actually consuming it!</li></ul><p>For a long-running daemon that spits out verbose logs, writing them to a file can become problematic because you can end up running out of disk space. To solve this problem, daemons typically implement <em>log rotation</em>: a mechanism to keep log sizes in check by moving them aside when a certain period of time passes or when they cross a size threshold, and then only keeping the last N files around. Peeking into one of the many examples in my server, note how <code>maillog</code> is the “live” log where writes go to but there is a daily <code>maillog.N.bz2</code> archive for up to a week:</p><div><pre tabindex="0"><code data-lang="shell"><span><span>$ ls -l /var/log/maillog*
</span></span><span><span>-rw-r----- <span>1</span> root       wheel       <span>4206</span> Dec  <span>6</span> 05:41 maillog
</span></span><span><span>-rw-r----- <span>1</span> root       wheel        <span>823</span> Dec  <span>6</span> 00:00 maillog.0.bz2
</span></span><span><span>-rw-r----- <span>1</span> root       wheel        <span>876</span> Dec  <span>5</span> 00:00 maillog.1.bz2
</span></span><span><span>-rw-r----- <span>1</span> root       wheel        <span>791</span> Dec  <span>4</span> 00:00 maillog.2.bz2
</span></span><span><span>-rw-r----- <span>1</span> root       wheel        <span>820</span> Dec  <span>3</span> 00:00 maillog.3.bz2
</span></span><span><span>-rw-r----- <span>1</span> root       wheel        <span>808</span> Dec  <span>2</span> 00:00 maillog.4.bz2
</span></span><span><span>-rw-r----- <span>1</span> root       wheel        <span>759</span> Dec  <span>1</span> 00:00 maillog.5.bz2
</span></span><span><span>-rw-r----- <span>1</span> root       wheel        <span>806</span> Nov <span>30</span> 00:00 maillog.6.bz2
</span></span><span><span>$ █
</span></span></code></pre></div><p>Having all daemons implement log rotation logic on their own would be suboptimal because you’d have duplicate logic throughout the system and you would not be able to configure policy easily for them all. This is where <a href="https://man.freebsd.org/cgi/man.cgi?newsyslog(8)"><code>newsyslog(8)</code></a> on FreeBSD (or <code>logrotate(8)</code> on Linux) comes into play.</p><p><code>newsyslog</code> is a tool that rotates log files based on criteria such as size or time and optionally compresses them. But remember: the semantics of open file handles mean that simply renaming log files is insufficient! Once <code>newsyslog</code> takes action and moves a log file aside, it must ensure that the process that was writing to that file <em>closes</em> the file handle and <em>reopens it</em> so that writes start going to the new place. This is typically done via sending a <code>SIGHUP</code> to the daemon, and is why we need to pass <code>-H</code> to the <code>daemon</code> call. To illustrate the sequence:</p><ol><li>The system starts a service via <code>daemon</code> and redirects logs to <code>/var/log/service.log</code>.</li><li><code>newsyslog</code> runs and determines that <code>/var/log/service.log</code> needs to be rotated because a day has passed.</li><li><code>newsyslog</code> <em>renames</em> <code>/var/log/service.log</code> to <code>/var/log/service.log.0</code> and creates a new and empty <code>/var/log/service.log</code>. At this point <code>daemon</code> is <em>still writing</em> to <code>/var/log/service.log.0</code>!</li><li><code>newsyslog</code> sends a <code>SIGHUP</code> to the <code>daemon</code> process.</li><li>The <code>daemon</code> process closes its file handle for the log, reopens <code>/var/log/service.log</code> (which is the fresh new log file), and resumes writing.</li><li><code>newsyslog</code> compresses the <code>/var/log/service.log.0</code> file for archival now that it’s quiesced.</li></ol><p>Configuring <code>newsyslog</code> is easy, but cryptic. We can create a service-specific configuration file under <code>/usr/local/etc/newsyslog.d/</code> that provides entries for our service, such as:</p><div><pre tabindex="0"><code data-lang="plain"><span><span>/var/log/endbasic.log endbasic:wheel 600 7 * @T00 JC /var/run/endbasic.pid
</span></span></code></pre></div><p>I’ll leave you to the manpage to figure out what the <code>7 * @T00 JC</code> magic is (but in short, it controls retention count, rotation schedule, and compression).</p><p>As I briefly mentioned earlier, the Azure Functions runtime was responsible for TLS termination in my previous setup. Without such a runtime in place, I had to configure TLS on my own in my HTTP server… or did I?</p><p>I had been meaning to play with <a href="https://developers.cloudflare.com/cloudflare-one/networks/connectors/cloudflare-tunnel/">Cloudflare Tunnels</a> for a while given that I already use Cloudflare for DNS. Zero Trust Tunnels allow you to expose a service without opening <em>inbound</em> ports in your firewall. The way this works is by installing the <code>cloudflared</code> tunnel daemon on your machine and configuring the tunnel to redirect certain URL routes to an internal address (typically <code>http://localhost:PORT</code>). Cloudflare then acts as the frontend for the requests, handles TLS termination and DDOS protection, and <em>then</em> redirects the request to your local service.</p><figure><img src="https://jmmv.dev/images/2025-12-07-cloudflared.png" width="100%"/><figcaption>Interactions between client machines, Cloudflare servers, the cloudflared tunnel agent, and the actual HTTP servers I wrote.</figcaption></figure><p>The obvious downside of relying on someone <em>else</em> to do TLS termination instead of doing it yourself on your own server is that they can intercept and modify your traffic. For the kinds of services I run this isn’t a big deal for me, and the simplicity of others dealing with certificates is well welcome. Note that I was already offloading TLS termination to Azure Functions anyway, so this isn’t a downgrade in security or privacy.</p><p>But using Cloudflare as the frontend came with a little annoyance: CORS handling. You see: the services I run require configuring extra allowed origins, and as soon as I tried to connect to them via the Cloudflare tunnel, I’d get the dreaded “405 Method not allowed” error in the requests.</p><p>Before, I used to configure CORS orgins from the Azure Functions console, but no amount of peeking through the Cloudflare console showed me how to do this for my tunneled routes.</p><p>At some point during the investigation, I assumed that I had to configure CORS on my own server. I’m not sure how I reached that bogus conclusion, but I ended up wasting a few hours implementing <a href="https://github.com/jmmv/iii-iv/blob/bc6508959b75ba2ad7107625a5c14f269d742a58/core/src/rest/cors.rs">a configuration system for CORS in my web framework</a>. Nice addition… but ultimately useless.</p><p>I had not accounted for the fact that because Cloudflare acts as the frontend for the services, it is the one responsible for handling the pre-flight HTTP requests necessary for CORS. In turn, this means that Cloudflare is where CORS needs to be configured but there is nothing “obvious” about configuring CORS in the Cloudflare portal.</p><p>AI to the rescue! As skeptical as I am of these tools, it’s true that they work well to get answers to common problems—and figuring out how to deal with CORS in Cloudflare was no exception. They told me to configure <em>a transformation rule</em> that explicitly sets CORS response headers for specific subdomains, and that did the trick:</p><figure><img src="https://jmmv.dev/images/2025-12-07-cloudflare-cors-rules.png" width="100%"/><figcaption>Sample rule configuration on the Cloudflare portal to rewrite CORS response headers.</figcaption></figure><p>Even though AI was correct in this case, the whole thing looked fishy to me, so I did spend time reading about the inner workings of CORS to make sure I understood what this proposed solution was about and to gain my own confidence that it was correct.</p><p>By now, my web services are now fully running on my FreeBSD machine. The above may have seemed complicated, but in reality it was all just a few hours of work on Thanksgiving morning. Let’s conclude by analyzing the results of the transition.</p><p>On the plus side, here is what I’ve gained:</p><ul><li><p><strong>Predictability:</strong> Running in the cloud puts you at the mercy of the upgrade and product discontinuation treadmill of big cloud providers. It’s no fun to have to be paying attention to deprecation messages and adjust to changes no matter how long the deadlines are. FreeBSD also evolves, of course, but it has remained pretty much the same over the last 30 years and I have no reason to believe it’ll significantly change in the years to come.</p></li><li><p><strong>Performance:</strong> My apps are <em>so</em> much faster now it’s ridiculous. The serverless runtime of Azure Functions starts quickly for sure, but it just can’t beat a server that’s continuously running and that has hot caches at all layers. That said, I bet the real difference in performance for my use case comes from collocating the app servers with the database, duh.</p></li><li><p><strong>Ease of management:</strong> In the past, having automated deployments via GitHub Actions to Azure Functions was pretty cool, not gonna lie. But… being now able to deploy with a trivial <code>sudo make install</code>, perform administration PostgreSQL tasks with just a <code>sudo -u postgres psql</code>, and inspecting logs trivially <em>and quickly</em> by looking at <code>/var/log/</code> beats any sort of online UI and distributed system. “Doesn’t scale” you say, but it scales up <em>my time</em>.</p></li><li><p><strong>Cost:</strong> My Azure bill has gone from $20/month, the majority of which was going into the managed PostgreSQL instance, to almost zero. Yes, the server I’m running in the garage is probably costing me the same or more in electricity, but I was running it <em>anyway</em> already for other reasons.</p></li></ul><p>And here is what I’ve lost (for now):</p><ul><li><p><strong>Availability (and redundancy):</strong> The cloud gives you the chance of very high availability by providing access to multiple regions. Leveraging these extra availability features is not cheap and often requires extra work, and I wasn’t taking advantage of them in my previous setup. So, I haven’t <em>really</em> decreased redundancy, but it’s funny that the day right after I finished the migration, I lost power for about 2 hours. Hah, I think I hadn’t suffered any outages with Azure other than the one described in this article.</p></li><li><p><strong>A staging deployment:</strong> In my previous setup, I had dual prod and staging deployments (via Azure Functions slots and separate PostgreSQL databases—not servers) and it was cool to deploy first to staging, perform some manual validations, and then promote the deployment to prod. In practice, this was rather annoying because the deployment flow was very slow and not fully automated (see “manual testing”), but it indeed saved me from breaking prod a few times.</p></li><li><p><strong>Auto-deployments:</strong> Lastly and also in my previous setup, I had automated the push to staging and prod by simply updating tags in the GitHub repository. Once again, this was convenient, but the biggest benefit of it all was that the prod build process was “containerized” and not subject to environmental interference. I’d very well set up a cron job or webhook-triggered local service that rebuilt and deployed my services on push… but it’s now hard to beat the simplicity of <code>sudo make install</code>.</p></li></ul><p>None of the above losses are inherent to self-hosting, of course. I could provide alternatives for them all and at some point I will; consider them to-dos!</p></article></div></div></div>
  </body>
</html>
