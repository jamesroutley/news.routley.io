<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.philipzucker.com/compile_constraints/">Original</a>
    <h1>Compiling with Constraints</h1>
    
    <div id="readability-page-1" class="page"><div aria-label="Content">
      <div>
        <article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    <p>There are lots of interesting little subproblems in compilation like <a href="https://www.diva-portal.org/smash/get/diva2:951540/FULLTEXT01.pdf">instruction selection</a>, <a href="https://en.wikipedia.org/wiki/Register_allocation">register allocation</a> and <a href="https://en.wikipedia.org/wiki/Instruction_scheduling">instruction scheduling</a>. These can be expressed in declarative interlinked way to constraint solvers.</p>

<p>I’ve been fiddling with probably 6 iterations of using constraint solvers for compiler backends over the last 3 years and never written a blog post on it. This is long over due, and still highly imperfect. I have found this post only gets harder to write and my standards rise. Write early, write often.</p>



<p>Register allocation is the backend problem most obviously castable as a constraint problem. It is often described as a variant of graph coloring (there are nuances <a href="https://c9x.me/compile/bib/irc.pdf">like coalescing</a>).  <a href="https://en.wikipedia.org/wiki/Graph_coloring">Graph coloring</a> selects a color for each vertex in a graph such that no edge connects two nodes of the same color.</p>

<p>Here’s a toy implementation over a single SSA block using z3. <a href="https://news.ycombinator.com/item?id=33080799">Traversing backwards</a> through a block is a useful trick to analyze <a href="https://en.wikipedia.org/wiki/Live-variable_analysis">liveness</a> while you’re also building constraint.</p>

<p>During this collection, you can also emit any constraints that are opcode specific. Some instructions like the <a href="https://www.aldeid.com/wiki/X86-assembly/Instructions/mul"><code>mul</code></a> instruction in x86 do not work on every kind of register. You can also collect up specific objective functions, for example biasing <code>mov</code> to go between the same registers. Spilling to the stack can be modelled by pseudo registers that you put a lot of weight on. Requiring the input or output parameters follow any calling convention is again a simple extra constraint.</p>

<p>Multiple blocks can be linked together in the same constraint solve by sharing variables. This may require packing in extra <code>mov</code> instructions between blocks to keep the problem solvable in general. See this <a href="https://arxiv.org/pdf/1804.02452.pdf">paper</a> for more</p>

<div><div><pre><code><span>from</span> <span>typing</span> <span>import</span> <span>List</span><span>,</span> <span>Tuple</span>
<span>from</span> <span>collections</span> <span>import</span> <span>namedtuple</span>
<span>from</span> <span>dataclasses</span> <span>import</span> <span>dataclass</span>
<span>import</span> <span>z3</span>

<span># using an enumlike alegrbaic datatype is probably the cleanest way to model this
</span><span>RegSort</span> <span>=</span> <span>z3</span><span>.</span><span>Datatype</span><span>(</span><span>&#34;Register&#34;</span><span>)</span>
<span>for</span> <span>r</span> <span>in</span> <span>&#34;R0 R1 R2 R3 R4 R5 R6 R7&#34;</span><span>.</span><span>split</span><span>():</span>
    <span>RegSort</span><span>.</span><span>declare</span><span>(</span><span>r</span><span>)</span>
<span>RegSort</span> <span>=</span> <span>RegSort</span><span>.</span><span>create</span><span>()</span>
<span>x</span><span>,</span><span>y</span><span>,</span><span>z</span><span>,</span><span>w</span> <span>=</span> <span>z3</span><span>.</span><span>Consts</span><span>(</span><span>&#34;x y z w&#34;</span><span>,</span> <span>RegSort</span><span>)</span>

<span># Types. I&#39;m not particularly enforcing them.
</span><span>OpCode</span> <span>=</span> <span>str</span>
<span>Operation</span> <span>=</span> <span>tuple</span><span>[</span><span>OpCode</span><span>,</span> <span>&#34;RegSort&#34;</span><span>,</span> <span>List</span><span>[</span><span>&#34;RegSort&#34;</span><span>]]</span>
<span>Prog</span> <span>=</span> <span>List</span><span>[</span><span>Operation</span><span>]</span>
                   
<span>prog</span> <span>=</span> <span>[</span>
    <span>(</span><span>&#34;mov&#34;</span><span>,</span> <span>z</span><span>,</span> <span>[</span><span>y</span><span>]),</span>
    <span>(</span><span>&#34;add&#34;</span><span>,</span> <span>x</span><span>,</span> <span>[</span><span>y</span><span>,</span> <span>z</span><span>]),</span>
    <span>(</span><span>&#34;sub&#34;</span><span>,</span> <span>w</span><span>,</span> <span>[</span><span>y</span><span>,</span> <span>z</span><span>]),</span>
    <span>(</span><span>&#34;dummy_out&#34;</span><span>,</span> <span>None</span><span>,</span> <span>[</span><span>x</span><span>,</span><span>w</span><span>])</span> <span># a dummy node to put demand on output
</span><span>]</span>

<span>def</span> <span>compile</span><span>(</span><span>prog</span><span>):</span>
    <span>&#34;&#34;&#34;Get the constraints out of a program&#34;&#34;&#34;</span>
    <span>live</span> <span>=</span> <span>set</span><span>()</span>
    <span>constraints</span> <span>=</span> <span>[]</span>
    <span>objective</span> <span>=</span> <span>[]</span>
    <span>for</span> <span>insn</span><span>,</span> <span>(</span><span>op</span><span>,</span> <span>out</span><span>,</span> <span>in_ops</span><span>)</span> <span>in</span> <span>enumerate</span><span>(</span><span>reversed</span><span>(</span><span>prog</span><span>)):</span> <span># backwards to collect up liveness
</span>        <span>print</span><span>(</span><span>op</span><span>,</span> <span>out</span><span>,</span> <span>in_ops</span><span>,</span> <span>live</span><span>)</span>
        <span>if</span> <span>out</span> <span>!=</span> <span>None</span><span>:</span>
            <span>live</span><span>.</span><span>discard</span><span>(</span><span>out</span><span>)</span> <span># assignment means variable is no long defined
</span>        <span>live</span><span>.</span><span>update</span><span>(</span><span>in_ops</span><span>)</span>
        <span>constraints</span><span>.</span><span>append</span><span>(</span><span>z3</span><span>.</span><span>Distinct</span><span>(</span><span>live</span><span>))</span>

        <span>if</span> <span>op</span> <span>==</span> <span>&#34;mov&#34;</span><span>:</span> <span>#it&#39;s nice to fuse out mov
</span>            <span>objective</span><span>.</span><span>append</span><span>(</span><span>out</span> <span>==</span> <span>in_ops</span><span>[</span><span>0</span><span>])</span>

    <span>return</span> <span>constraints</span><span>,</span> <span>objective</span><span>,</span> <span>live</span>

<span>constraints</span><span>,</span> <span>objective</span><span>,</span> <span>live_entry</span> <span>=</span> <span>compile</span><span>(</span><span>prog</span><span>)</span>

<span>s</span> <span>=</span> <span>z3</span><span>.</span><span>Solver</span><span>()</span> <span># could use z3 optimize api.
</span><span>s</span><span>.</span><span>add</span><span>(</span><span>constraints</span><span>)</span>
<span>print</span><span>(</span><span>s</span><span>)</span>
<span>s</span><span>.</span><span>check</span><span>()</span>
<span>s</span><span>.</span><span>model</span><span>()</span>
</code></pre></div></div>

<div><div><pre><code>dummy_out None [x, w] set()
sub w [y, z] {w, x}
add x [y, z] {z, y, x}
mov z [y] {z, y}
[w != x, Distinct(z, y, x), z != y, Distinct(y)]
</code></pre></div></div>

<p>[w = R0, z = R2, y = R0, x = R1]</p>

<div><div><pre><code><span>def</span> <span>build</span><span>(</span><span>prog</span><span>,</span> <span>sol</span><span>):</span>
    <span>&#34;&#34;&#34;Fill in a program from a solution.&#34;&#34;&#34;</span>
    <span>return</span> <span>[(</span><span>op</span><span>,</span> <span>sol</span><span>[</span><span>out</span><span>]</span> <span>if</span> <span>out</span> <span>!=</span> <span>None</span> <span>else</span> <span>None</span><span>,</span> <span>[</span><span>sol</span><span>[</span><span>arg</span><span>]</span> <span>for</span> <span>arg</span> <span>in</span> <span>in_ops</span><span>])</span> <span>for</span> <span>op</span><span>,</span> <span>out</span><span>,</span> <span>in_ops</span> <span>in</span> <span>prog</span><span>]</span>

<span>def</span> <span>pp</span><span>(</span><span>prog</span><span>):</span>
    <span>&#34;&#34;&#34;Pretty print a program.&#34;&#34;&#34;</span>
    <span>for</span> <span>op</span><span>,</span> <span>out</span><span>,</span> <span>in_ops</span> <span>in</span> <span>prog</span><span>:</span>
        <span>print</span><span>(</span><span>op</span><span>,</span> <span>&#34;, &#34;</span><span>.</span><span>join</span><span>(</span><span>map</span><span>(</span><span>str</span><span>,</span> <span>[</span><span>out</span><span>]</span> <span>+</span> <span>in_ops</span><span>)))</span>

<span>prog_reg</span> <span>=</span> <span>build</span><span>(</span><span>prog</span><span>,</span><span>s</span><span>.</span><span>model</span><span>())</span>
<span>pp</span><span>(</span><span>prog_reg</span><span>)</span>
</code></pre></div></div>

<div><div><pre><code>mov R2, R0
add R1, R0, R2
sub R0, R0, R2
dummy_out None, R1, R0
</code></pre></div></div>

<h2 id="why">Why?</h2>

<p>One might think the advantage of compiling with constraints is getting perfectly optimized solutions. I have found this to not be the case. Heuristic solutions to these problems are fast and effective.</p>

<p>The advantage to compiling with constraints is that it short, declarative and rapidly flexible.</p>

<p>It also is another attack on the phase ordering problem, similar to the pitch for <a href="https://egraphs.org/">egraphs</a>. The phase ordering problem is that these compiler phases are interlinked, so there are uncomfortable compromises made in serializing them.</p>

<p>Mainly for me its just fun though. I like solvers.</p>

<h2 id="distinction-to-superoptimization">Distinction To Superoptimization</h2>

<p><a href="https://en.wikipedia.org/wiki/Superoptimization">Superoptimization</a> as I’ll define it today is taking the semantics of assembly instructions, the semantics of your host program, making the constraint that they match and tossing it into a solver. This is vastly over simplified. Any even remotely pragmatic approach prunes the search space significantly using domain specific techniques.</p>

<p>The difference between this and compiling with constraints is that compilation with constraints does not take a deep semantical perspective. The deep semantics are encoded in the instruction selection table, the generation of which I am not commenting on.</p>

<p>Compiling with constraints is largely concerned only with the dependency relationship of operands and instructions. This is a more tractable abstraction than the full instruction semantics. It also can be viewed as taking a traditional compiler pipeline and making it more declarative.</p>

<p>Superoptimization traditionally scales very poorly. Compiling with constraints could feasibly be done at a much larger more practical scale as the Unison compiler showed.</p>



<p>I first started on the VIBES project <a href="https://github.com/draperlaboratory/VIBES">https://github.com/draperlaboratory/VIBES</a> . The hypothesis there was that binary patching requires unusual constraints and that superoptimization like abilities may make the difference between patching in place or requiring detours. These two cases are very different tiers of complexity and error-proneness. In <a href="https://www.philipzucker.com/permutation_compile/">micropatching</a> we are compiling very small program fragments, for which the slowness of constraint compiling is not an issue.</p>

<p>This proposal was highly inspired by the <a href="https://unison-code.github.io/">Unison</a> compiler (not the distributed system one). You can find our <a href="https://www.minizinc.org/">minizinc</a> model here <a href="https://github.com/draperlaboratory/VIBES/blob/main/resources/minizinc/model.mzn">https://github.com/draperlaboratory/VIBES/blob/main/resources/minizinc/model.mzn</a> . It is a simplified form of the constraint model from Unison.</p>

<p>A few comments to help explain:</p>

<p>The paper “Combinatorial Register Allocation and Instruction Scheduling” was crucial. In particular append A is a very useful artifact.</p>

<p><a href="https://arxiv.org/abs/1804.02452">Source: Appendix A</a></p>

<p><img src="https://www.scattered-thoughts.net/assets/unison/model_params.png" alt=""/>
<img src="https://www.scattered-thoughts.net/assets/unison/constraints.png" alt=""/></p>

<p>These are the solver variables of our model. <code>reg</code> is a mapping from temporaries to possible registers. <code>issue</code> is a mapping from operation to issue cycle. The rest of the bits are constrained to make sense following the solution of these variables.</p>

<div><div><pre><code><span>%% ---------------------------------------------------------------</span><span>
</span><span>%%  VARIABLES</span><span>
</span><span>%% ---------------------------------------------------------------</span><span>
</span><span>array</span><span>[</span><span>temp_t</span><span>]</span><span> </span><span>of</span><span> </span><span>var</span><span> </span><span>reg_t</span><span> </span><span>:</span><span> </span><span>reg</span><span>;</span><span>
</span><span>array</span><span>[</span><span>operation_t</span><span>]</span><span> </span><span>of</span><span> </span><span>var</span><span> </span><span>opcode_t</span><span> </span><span>:</span><span> </span><span>opcode</span><span>;</span><span>
</span><span>array</span><span>[</span><span>operand_t</span><span>]</span><span> </span><span>of</span><span> </span><span>var</span><span> </span><span>temp_t</span><span> </span><span>:</span><span> </span><span>temp</span><span>;</span><span>
</span><span>array</span><span>[</span><span>temp_t</span><span>]</span><span> </span><span>of</span><span> </span><span>var</span><span> </span><span>bool</span><span> </span><span>:</span><span> </span><span>live</span><span>;</span><span>
</span><span>array</span><span>[</span><span>operation_t</span><span>]</span><span> </span><span>of</span><span> </span><span>var</span><span> </span><span>bool</span><span> </span><span>:</span><span> </span><span>active</span><span>;</span><span>
</span><span>array</span><span>[</span><span>operation_t</span><span>]</span><span> </span><span>of</span><span> </span><span>var</span><span> </span><span>0</span><span>..</span><span>MAXC</span><span> </span><span>:</span><span> </span><span>issue</span><span>;</span><span> </span><span>% maybe make these ranges. I could see a good argument for that</span><span>
</span><span>array</span><span>[</span><span>temp_t</span><span>]</span><span> </span><span>of</span><span> </span><span>var</span><span> </span><span>0</span><span>..</span><span>MAXC</span><span> </span><span>:</span><span> </span><span>start_cycle</span><span>;</span><span>
</span><span>array</span><span>[</span><span>temp_t</span><span>]</span><span> </span><span>of</span><span> </span><span>var</span><span> </span><span>0</span><span>..</span><span>MAXC</span><span> </span><span>:</span><span> </span><span>end_cycle</span><span>;</span><span>

</span></code></pre></div></div>

<p>Here is an example constraint. They map back to the table from the Unison paper.</p>

<div><div><pre><code>% C7.1  The issue cycle of operations that define temporaries must be before all
%       active operations that use that temporary
constraint forall (t in temp_t)(
  let {operand_t : p = definer[t]} in
  forall(q in users[t] where active[operand_operation[q]] /\ temp[q] == t)(
    let {operation_t : u = operand_operation[q]} in
    let {operation_t : d = operand_operation[p]} in
    issue[u] &gt;= issue[d] + latency[opcode[d]]
  )
);
</code></pre></div></div>

<p>In the end I don’t believe the hypothesis that this complexity was needed for micropatching was born out and we would have been better served by a more traditional compiler architecture. We became ensnared in the implementation issues of talking to the constraint solver and the concepts of the model were too rigid and complicated to explain easily to others or modify when inevitable surprises popped up. Serialization to and from minizinc was very painful. That these data structures were not easily hand editable or all that readable (they were human readable json, but gobs of complicated json) was a huge impediment to development and debugging when my bandwidth was already strapped. Live and learn.</p>

<p>It has been asked before why we didn’t use Z3 as it has great bindings and we already used it elsewhere. The answer is we were sticking close to the Unison design (we actually initially wanted to literally reuse <a href="https://github.com/unison-code/unison/blob/master/src/solvers/multi_backend/minizinc/code-generation.mzn">their model</a>, but it was completely incomprehensible to me after some weeks of trying to decrypt it). There is a general question of when to use CSP, MIP, SAT, ASP, or SMT. I have never seen a good answer. This is a good research question that someone should attack. My heuristic is that if the community in question targets problems similar ot yours, try that one. CSP, MIP and ASP are better for optimization style problems as compared to satisfaction.</p>

<p>One thing not fully realized was a simplification of the model to get rid of the distinction between temporaries and operands. This subtle conceptual distinction caused a lot of communication issues amongst the team. I think with the ability to have multiple possible operations overlapping means this could be factored out.</p>

<p>A not fully explored alternative was using a shallow embedding instead to encode the problem over to minizinc. This may have solved the pain that serialization caused us. Minizinc does not have good support for syntax trees as objects. However, it does support functions. So the idea was that instead of serializing to a pile of arrays, instead one can pretty print a program that looks like a relational representation of the program. This representation is immediately interpreted to constraint in the finally tagless style using minizinc function definitions.</p>

<p>I had a mini version of this in this tweet <a href="https://x.com/SandMouth/status/1530331356466712578?s=20">https://x.com/SandMouth/status/1530331356466712578?s=20</a>
<img src="https://www.scattered-thoughts.net/assets/unison/minizinc_tweet.jpeg" alt=""/></p>

<div><div><pre><code>enum reg_t = {R0, R1, R2, R3};
enum temp_t = {T0, T1, T2, T3, T4, T5};
int : MAXID = 5;
set of int : operation_t = 0..MAXID;

array[temp_t, operation_t] of var bool : live_in;
array[temp_t] of var reg_t : reg;

predicate insn(operation_t : id, list of temp_t : lhs, string : opcode, list of temp_t : rhs) = 
  % https://en.wikipedia.org/wiki/Live_variable_analysis
  forall(t in temp_t)(
    if (t in rhs) % in gen set
      then live_in[t, id] = true
    elseif (t in lhs) % not in gen set, in kill set
      then live_in[t,id] = false
    else % propagate
      live_in[t,id] &lt;- live_in[t, id + 1] 
    endif) /\
  % Assignments need to go to different registers than live variables of next instruction.
  forall(t1 in lhs)(
    forall(t2 in temp_t where t1 != t2)(
      live_in[t2,id+1] -&gt; reg[t1] != reg[t2]
  ));

% Nothing is live at end of block
constraint forall(t in temp_t)( live_in[t, MAXID] = false);

constraint 
  insn(0, [T1], &#34;mov&#34;, [T0])     /\
  insn(1, [T2], &#34;add&#34;, [T0, T1]) /\
  insn(2, [T3], &#34;sub&#34;, [T0, T1]) /\
  insn(3, [T4], &#34;mul&#34;, [T1, T2]) /\
  insn(4, [T5], &#34;inc&#34;, [T4]);


%reg = [T0: R2, T1: R0, T2: R1, T3: R2, T4: R0, T5: R0];
%live_in = 
%[|         0:     1:     2:     3:     4:     5: 
% | T0:  true,  true,  true, false, false, false
% | T1: false,  true,  true,  true, false, false
% | T2: false, false,  true,  true, false, false
% | T3: false, false, false, false, false, false
% | T4: false, false, false, false,  true, false
% | T5: false, false, false, false, false, false
% |];
%----------

% if we&#39;re not in ssa, maybe 
% array[temp_t, id] of var reg_t; 
% since register can change as reuse site.

% Registers don&#39;t allocate to same spot
%constraint forall (id in operation_t)(
%  forall(t1 in temp_t)(
%    forall(t2 in temp_t)(
%      (live_in[t1,id] /\ live_in[t2,id] /\ t1 != t2) -&gt;
%      reg[t1] != reg[t2]
%    )));

</code></pre></div></div>

<h2 id="answer-set-programming">Answer Set Programming</h2>

<p>Answer set programming has a decent pitch in my opinion to being a natural fit to this problem. One of the supposed utilities of datalog is that it is good for expressing fixed point <a href="https://users.cs.utah.edu/~blg/resources/notes/datalog-for-static-analysis/datalog-for-static-analysis.pdf">program analyses</a>. These fixed points are needed to handle loops in the control flow graphs. Answer set programming is a superset of datalog, so it too can express these analyses.</p>

<p>What it adds on top of datalog is a SAT-like solver. Because of this, I would claim that you can naturally express program anlayses in the datalog style, and then make combinatorial choices for register allocation, instruction selection, and instruction scheduling.</p>

<p>I showed how to use datalog for graph matching of instructions here <a href="https://www.philipzucker.com/imatch-datalog/">https://www.philipzucker.com/imatch-datalog/</a></p>

<ul>
  <li><a href="https://link.springer.com/chapter/10.1007/11799573_21">TOAST: Applying Answer Set Programming to Superoptimisation</a> <a href="http://www.cs.bath.ac.uk/tom/toast/">http://www.cs.bath.ac.uk/tom/toast/</a></li>
  <li><a href="https://link.springer.com/chapter/10.1007/978-3-642-04238-6_57">Generating Optimal Code Using Answer Set Programming 2009</a></li>
  <li><a href="https://purehost.bath.ac.uk/ws/portalfiles/portal/187949093/UnivBath_PhD_2009_T_Crick.pdf">Superoptimisation: Provably Optimal Code Generation using Answer Set Programmin - crick thesis</a></li>
</ul>

<p>Having said all that, Greenberg was highly skeptical of this suggestion.</p>

<p>There are bits and pieces of this below. Perhaps I’ll clean up and comment more on this another day.</p>



<p>I have been chewing on this stuff for years, and have written more half baked stuff than I care to read.</p>

<p>People are struggling with getting loopy multi block egraph compilers to work. I think integrating single block egraph solves with these techniques is fascinating axis to declaratively combine almost every piece of a backend. It’s relatively straightforward seeming and does not require new insight to do. A single block can be seen as a purely functional expression and can have optimizing rewrites applied in a straightforward manner.</p>

<p>Eli has mentioned that the “<code>-O4</code>” market is underserved. A compiler that ekes out a bit more performance at the cost of huge compile times could save big companies deplaying the same program to a bunch of servers a ton of money.</p>

<p>Fancy egraph extraction is very similar to the declarative instruction selection problem. See <a href="https://dl.acm.org/doi/10.1145/3126528">Complete and Practical Universal Instruction Selection</a>.</p>

<p>One of my big regrets on the VIBES project was not writing up a checkpoint on the ideas and state of the constraint compiler aspect of it when it was all fresh in my mind and exciting. I</p>

<p>Nevertheless, it is quite a cool approach and even in it’s imperfect state it is interesting</p>

<p><a href="https://c9x.me/compile/bib/irc.pdf">iterated register coalescing - appell and george</a></p>

<p>An interesting perspective is staged metaprogramming. <code>code -&gt; (constraints * (model -&gt; asm))</code></p>

<p>destination driven is very clean and useful. It is also uses tge backwards processing liveness trick as i recall.</p>

<ul>
  <li><a href="https://bernsteinbear.com/blog/ddcg/">https://bernsteinbear.com/blog/ddcg/</a></li>
  <li><a href="https://github.com/tekknolagi/pyddcg">https://github.com/tekknolagi/pyddcg</a></li>
  <li><a href="https://github.com/tekknolagi/ddcg">https://github.com/tekknolagi/ddcg</a></li>
  <li><a href="https://legacy.cs.indiana.edu/~dyb/pubs/ddcg.pdf">https://legacy.cs.indiana.edu/~dyb/pubs/ddcg.pdf</a></li>
</ul>

<p>It is a fairly mathemtical and precise problem and also practical feeling. It’s quite fun.</p>

<p>I like constraint solvers. I like them because it’s kind of fun to figure out how to mold your problem into the form they need.</p>

<p>It isn’t all roses. Sometimes using an off the shelf solver requires mangling your problem.</p>

<p>They can be slower than a bespoke heuristics.</p>

<p>In compilation, there are multiple IRs to speak of.</p>

<p>There’s usually some kind of SSA IR like LLVM IR.
Then there may be instructions filled in but logical variables instead of registers.
And what is given to the assembler isn’t fully concretized. You still have abstract labels for memory addresses and program addresses.
Even after you run that, linking or dynamic linking can still occur, so there are relocations describing the ways to fix up the binary.</p>

<p>It’s nice to traverse a block backwards. This is because you can perform a livness analysis at the same time you are making your constraints.</p>

<p>One can push different pieces into the metalevel (python) or the object languages (z3). You can push the liveness ana;lysis into the solver, or the instruction selection, or the assembler.</p>

<p>It all gets more complicated.</p>

<p>The more powerful compile time techniqyes seem to deliver fairly maginal gains. One problem is that the model of cpu operation isn’t that clear. There’s a lot of internal complexity to the CPU (caches, pipelining, <a href="https://en.wikipedia.org/wiki/Out-of-order_execution">out of order</a> execution). Considering these gives rules of thumb.</p>

<p>More straightforward objectives are things like code size. Smaller is always better (well, unless you also care about performance. It is conceivable larger code performs better.).</p>

<p>It is conceivable to have crazier constraints. Like maybe you’re writing shellcode that can’t have certain bytes in it.</p>

<p>Register allocation is often modelled as a graph coloring. This isn’t quite true because it can be the case that if you can get your resgiters right, your peephole optimizer can reduce your code a little bit. The canonical example is a <code>mov x,y</code> instruction. If you can select registers such that <code>x=y</code>, then</p>

<p><a href="https://en.wikipedia.org/wiki/Instruction_scheduling">Instruction scheduling</a> is the problem of reshuffling your instructions according to your dependencies. It is good to get your memory accesses as early as possible. They are often going to be slower than more computational register to register functions. It’s kind of like firing off an async request.</p>

<p>Memory models</p>

<p>Instruction Selection is a combination of problems. Perhaps it is the richest. Here are some declarative specs of instruction selectors. Go, cranelift.
Instruction selection finds patterns.
The source can be modelled as Trees, DAGs, or Graphs. See  <a href="https://www.amazon.com/Instruction-Selection-Principles-Methods-Applications/dp/3319816586">https://www.amazon.com/Instruction-Selection-Principles-Methods-Applications/dp/3319816586</a></p>

<p>Then it selects a sufficient set of these patterns to actually cover the required function.</p>



<p>A major touchpoint for compiling with constraints is the <a href="https://unison-code.github.io/">Unison compiler</a>.</p>

<p>Unison is an alternative LLVM backend that solves the register allocation problem and instruction selection problem in “unison” using a constraint solving backend.</p>

<p>Unison supported multiple architectures, but one, <a href="https://en.wikipedia.org/wiki/Qualcomm_Hexagon">Hexagon</a> was a <a href="https://en.wikipedia.org/wiki/Very_long_instruction_word">very long instruction word</a> (VLIW) architecture. My 10cent discussion of VLIW is that the instruction set allows explicit specification of parallelism / data dependencies. This enables perhaps a more direct model of the actual parallel interworkings of the cpu at the cost of significant compiler complexity. It is here that perhaps constraint compilation carries its weight.</p>

<p>This paper is particular is useful [Combinatorial Register Allocation and Instruction Scheduling])<a href="https://arxiv.org/abs/1804.02452">https://arxiv.org/abs/1804.02452</a>). Also very interesting was the <a href="https://unison-code.github.io/doc/manual.pdf">manual</a>.</p>

<p>LLVM has multiple IRs. One of them is <a href="https://llvm.org/docs/MIRLangRef.html">Machine IR</a> (MIR), which is an IR that has more of the information filled in. Unison takes this output, fiddles with it, and then performs solving. This reuses the frontend, middle end passes, and instruction selection of llvm, which is huge.</p>

<p>The actual unison minizinc model is <a href="https://github.com/unison-code/unison/blob/master/src/solvers/multi_backend/minizinc/code-generation.mzn">here</a>. I spent a good month probably studying this and trying to pare this down. Ultimately, I decided to write it from scratch again, adding in pieces as we understood we needed them.</p>

<p>This is an example of a unison IR taken from the manual:</p>

<div><div><pre><code>function: factorial
b0 (entry, freq: 4):
    o0: [t0:r0,t1:r31] &lt;- (in) []
    o1: [t2] &lt;- A2_tfrsi [1]
    o2: [t3] &lt;- C2_cmpgti [t0,0]
    o3: [] &lt;- J2_jumpf [t3,b2]
    o4: [] &lt;- (out) [t0,t1,t2]
b1 (freq: 85):
    o5: [t4,t5,t6] &lt;- (in) []
    o6: [t7] &lt;- A2_addi [t5,-1]
    o7: [t8] &lt;- M2_mpyi [t5,t4]
    o8: [t9] &lt;- C2_cmpgti [t5,1]
    o9: [] &lt;- J2_jumpt [t9,b1]
    o10: [] &lt;- (out) [t6,t7,t8]
b2 (exit, return, freq: 4):
    o11: [t10,t11] &lt;- (in) []
    o12: [] &lt;- JMPret [t11]
    o13: [] &lt;- (out) [t10:r0]
adjacent:
    t0 -&gt; t5, t1 -&gt; t6, t1 -&gt; t11, t2 -&gt; t4, t2 -&gt; t10, t6 -&gt; t6, t6 -&gt; t11,
    t7 -&gt; t5, t8 -&gt; t4, t8 -&gt; t10
</code></pre></div></div>



<h2 id="compiler-problems">Compiler problems</h2>

<p><a href="https://link.springer.com/chapter/10.1007/11799573_21">TOAST: Applying Answer Set Programming to Superoptimisation</a> <a href="http://www.cs.bath.ac.uk/tom/toast/">http://www.cs.bath.ac.uk/tom/toast/</a>
<a href="https://link.springer.com/chapter/10.1007/978-3-642-04238-6_57">Generating Optimal Code Using Answer Set Programming 2009</a>
<a href="https://purehost.bath.ac.uk/ws/portalfiles/portal/187949093/UnivBath_PhD_2009_T_Crick.pdf">Superoptimisation: Provably Optimal Code Generation using Answer Set Programmin - crick thesis</a></p>

<div><div><pre><code><span>import</span> <span>clingo</span>

<span>def</span> <span>Var</span><span>(</span><span>x</span><span>):</span>
  
<span>def</span> <span>Add</span><span>(</span><span>e1</span><span>,</span><span>e2</span><span>):</span>

<span>def</span> <span>Set</span><span>(</span><span>v</span><span>,</span> <span>e</span><span>):</span>



</code></pre></div></div>

<pre><code>
prog(plus(a, b)).

expr(E) :- prog(E).
expr(A) :- expr(plus(A,_)).
expr(B) :- expr(plus(_,B)).

isel(add(plus(A,B),A,B)) :- expr(plus(A,B)). 

{cover(E,P)} = 1 :- expr(E).

alloc(R,T)

%#show expr/1.
</code></pre>

<pre><code>% re
#script (python)
import clingo

def is_const(x):
    print(x)
    return x.type == clingo.SymbolType.Function and len(x.arguments) == 0
def mkid(x):
    if is_const(x):
        return x
    return clingo.Function(&#34;var&#34;, [clingo.Number(hash(x))])

#end.

% flatten
expr(E) :- prog(E).
expr(A) :- expr(plus(A,_)).
expr(B) :- expr(plus(_,B)).

% generate possible instruction outputs via pattern matching
%insn(add(V, A1, B1)) :- expr(E), E = plus(A,B), V = @mkid(E), A1 = @mkid(A), B1 = @mkid(B). 

pre_insn(add(E, A, B)) :- expr(E), E = plus(A,B).
pre_insn(mov(E,A)) :-  expr(E), E = plus(A,0).
pre_insn(mov(E,B)) :-  expr(E), E = plus(0,B).

% do the id conversion all at once.
insn(add(E1,A1,B1)) :- pre_insn(add(E,A,B)), E1 = @mkid(E), A1 = @mkid(A), B1 = @mkid(B).
insn(mov(E1,A1)) :- pre_insn(mov(E,A)), E1 = @mkid(E), A1 = @mkid(A).

% Is there really a reason to have separate insn and select?
{select(I)} :- insn(I).

defines(I,V) :- insn(I), I = add(V, A1, B1).
defines(I,V) :- insn(I), I = mov(V, A).

uses(I,A) :- insn(I), I = add(V, A, B).
uses(I,B) :- insn(I), I = add(V, A, B).
uses(I,A) :- insn(I), I = mov(V, A).

% top level output is needed.
used(P1) :- prog(P), P1 = @mkid(P). 
{select(I) : defines(I,V)} = 1 :- used(V). % if used, need to select something that defines it.

% if selected, things instruction uses are used. Again if selected 
used(A) :- select(I), uses(I,A).

%//{select(A) :- select(add(V,A,B)).
%select

%prog(plus(a, plus(b,c))).
prog(plus(a, plus(plus(0,b),c))).
defines(a,a; b,b; c,c).

%#show expr/1.
#show select/1.

% if used, must be assigned register
{assign(V, reg(0..9)) } = 1 :- used(V).

le(X,Z) :- le(X,Y), le(Y,Z). % transitive
:- le(X,Y), le(Y,X), X != Y. % antisymmettric
le(X,X) :- le(X,_). % reflexive
le(Y,Y) :- le(_,Y).

% instructions must be ordered
{le(I,J)} :- select(I), select(J).

% definitions must become before uses.
le(I,J) :- defines(I,A), used(J,A).

% var is live at instructin I if I comes after definition J, but before a use K.
% using instruction as program point is slight and therefore perhaps alarming conflation
live(I, X) :- defines(J, X), le(J, I), J!=I, le(I,K), uses(K,X).

#show assign/2.
</code></pre>

<div><div><pre><code>add(0, z, x, y).
add(1, z, x, y).
add(2, )

insn(, add).
insn(, sub, ).
insn(N, mov, ).

:- insn(N), insn(M), N != M. % unique times
:- 

:- assign(Temp,R), assign(Temp2,R), live(Temp,T), live(Temp2,T) ; no register clashes.
</code></pre></div></div>

<pre><code>%#program myprog.
insn(x, add, y , z).
insn(w, mul, x,  y).




% identify instruction with the temp it defines. Good or bad?
%#program base.
temp(T) :- insn(T,_,_,_).
temp(T) :- insn(_,_,T,_).
temp(T) :- insn(_,_,_,T).

% scheduling
{lt(U,T); lt(T,U)} = 1 :- temp(T), temp(U), T &lt; U.
lt(T,U) :- lt(T,V), lt(V,U). %transitive
% not lt(T,T). % irreflexive redundant
% :- lt(T,U), lt(U,T). % antisymmettric redundant

% uses
use(T,A) :- insn(T, _, A, _).
use(T,B) :- insn(T, _, _, B).

lt(A,T) :- use(T,A).

% live if U is defined before T and there is a use after T.
live(T,U) :- lt(U,T), lt(T,V), use(V,U). 

reg(r(0..9)).

{assign(T,R): reg(R)} = 1 :- temp(T).
:- assign(T,R), assign(U,R), live(U,T).

% minimize number of registers used 
#minimize { 1,R : assign(T,R)}.
% try to use lower registers as secondary objective
#minimize { 1,R : assign(T,R)}.

% sanity vs constraints. I expect none of these to be true.

binop(Op) :- insn(_, Op, _,  _).

error(&#34;assign field is not register&#34;, R) :- assign(_,R), not reg(R).
error(&#34;assign field is not temp&#34;, T) :- assign(T,_), not temp(T).


</code></pre>

<pre><code>#script (python)
import clingo

def is_const(x):
    return isinstance(x, clingo.Symbol) and len(x.arguments) == 0
def mkid(x):
    if is_const(x):
        return x
    return clingo.Function(&#34;v&#34; + str(hash(x)), [])

#end.

prog(plus(a,plus(b,c))).
expr(E) :- prog(E).
expr(A) :- expr(plus(A,_)).
expr(B) :- expr(plus(_,B)).

% It&#39;s almost silly, but also not.
insn(@mkid(E), add, @mkid(A), @mkid(B)) :- expr(E), E = plus(A,B).
id(@mkid(E),E) :- expr(E).



</code></pre>

<pre><code>#script(python)
import clingo
def my_add(a,b):
  return clingo.Number(a.number + b.number)

#end.

test_fact(@my_add(1,2)).
</code></pre>

<pre><code>biz.
{foo; bar} = 2 :- biz.
</code></pre>

<p>Could use python parser to create code. That’s kind of intriguing.</p>

<p>Free floating and assign to blocks?
The graph like structure is nice for sea of nodes perhaps.
clingo-dl might be nice for scheduling constraints.</p>

<p>Using clingraph would be cool here.</p>

<pre><code>
prog(E).
expr(E) :- prog(E).

% block(B,X,E) % variable X should have expression E in it. This summarizes the block.

% demand.  ( dead code elimination kind of actually. )
expr(A;B) :- expr(add(A,B)). 

reg(rax;rdi;rsi;r10;r11).


insn(E, x86add(I1,I2)) :- expr(add(A,B)), insn(A,I1), insn(B,I2). 

{ insn(E, x86add(R1,R2)) } :- expr(E), E = add(A,B), insn(A,I1), insn(B,I2), reg(R1), reg(R2). 

% how to factor representing intructions

{ insn(E, x86add) } :- expr(add(A,B)).

% really its a pattern identifier.



sched(E,I,N) :- insn(E,I), ninsn(N), 0...N.
{ dst(E,x86add,0,R) } :- reg(R), not live(R).
src(E,I,R) :- insn(add(A,B, x86add), dst(A,_,R), dst(B,_,R).

% must schedule value needed before computation
:- sched(add(A,B), I, N), sched(A,I1,M), M &gt;= N.
:- sched(add(A,B), I, N), sched(B,I1,M), M &gt;= N.

% We could schedule at multiple times. That&#39;s rematerialization.


% copy packing?
{insn(E, cp)} :- expr(E).


read(src) :- insn(x86add(Dst, Src)).
clobber(Dst;zf;cf) :- insn(x86add(Dst, Src)).

% initial values / calling conventions
value(rdi,x0,0; rsi,x1,0; rcx,x2,0).
value(rax, E, N) :- prog(E), ninsn(N).

live(R,N-1) :- live(R,N), not clobber(R,I,N). 
live(R,N-1) :- read(R,N). 



ninsn(N) :- N = #count { I : active(E,I) }.



</code></pre>

<pre><code>#script (python)
import clingo

def to_asm(t):
  if t.name == &#34;add&#34;:

  return clingo.String(&#34;todo&#34;)

#end.


prog(E).
expr(E) :- prog(E).
expr(A;B) :- expr(add(A,B)).

child(E,A; E,B):- expr(E), E = add(A,B).

reg(rax;rdi;rsi;r10;r11).
ecount(N) :- N = #count { E : expr(E) }.
{ where(R,E)   } = 1 :- reg(R), expr(E).
{ when(1..N,E) } = 1 :- ecount(N), expr(E).

% subexpressions must come earlier
:- when(I, E), when(I2, C), child(E,C), I2 &gt; I.

% time is unique
:- when(I,E1), when(I,E2), E1 != E.

% There can&#39;t exist a clobber E1 that occurs
:- child(E,C), where(R,C), where(R, E1), E1 != C, 
   when(T,E), when(Tc,C), when(T1,E1), Tc &lt; T1, T1 &lt; T. 

write(R,T) :- when(T,E), where(R,E).
read(R,T)  :-  when(T,E), child(E,C), where(R,C).

liver(R,T) :- read(R,T).
liver(R,T-1) :- liver(R,T), not write(R,T).

live(T, C)   :-  when(T, E), child(E,C).
live(T-1, E) :-  live(T,E), not when(T,E), T &gt;= 0. 

avail(T,E) :- when(T,E).
avail(T+1,E) :- avail(T,E), where(R,E), not write(R,T), T &lt;= End.

% where = assign ? alloc ?

#minimize { 10, : where(R,E), reg(R)  } + { 50, : where(R,E), stack(R)  }.

</code></pre>



<p><a href="https://www.philipzucker.com/asp-for-egraph-extraction/">https://www.philipzucker.com/asp-for-egraph-extraction/</a></p>

<pre><code>%re
eq(Y,X) :- eq(X,Y).
eq(X,Z) :- eq(X,Y), eq(Y,Z).

term(X) :- eq(X,_).
term(X;Y) :- term(add(X,Y)).

eq(add(X,Y), add(Y,X)) :- term(add(X,Y)).
eq(add(X,add(Y,Z)), add(add(X,Y),Z)) :- term(add(X,add(Y,Z))).
eq(add(X,add(Y,Z)), add(add(X,Y),Z)) :- term(add(add(X,Y),Z)).

term(add(1,add(2,add(3,4)))).
</code></pre>

<pre><code>%re
#script(python)

uf = {}
def find(x):
  while x in uf:
    x = uf[x]
  return x

def union(x,y):
  x = find(x)
  y = find(y)
  if x != y:
    uf[x] = y
  return y

#end.


% :- term(add(X,Y)), rw(X,X1), rw(Y,Y1), 

% add( @find(Y) , @find(X) ,@find(XY) ):- add(X,Y,XY).

%rw(T, @union(T,add(@find(X), @find(Y)))) :- term(T), T = add(X,Y). % congruence?
%rw(T, @union(T,add(@find(Y), @find(X)))) :- term(T), T = add(X,Y). % commutativity.
%rw(T, @find(T)) :- term(T).
%rw(X, @find(X); Y, @find(Y)) :- term(add(X,Y)).

%term(T) :- rw(_,T).

term(@union(T, add(@find(X), @find(Y)))) :- term(T), T = add(X,Y).
term(@union(T, add(@find(Y), @find(X)))) :- term(T), T = add(X,Y).

term(@find(X); @find(Y)) :- term(add(X,Y)).

bterm(1,0).
bterm(N+1, add(N,X)):- bterm(N,X), N &lt; 5. 
term(X) :-  bterm(5,X).
%term(add(1,2)).

#show term/1.
</code></pre>

<p>Explicit strata control. Does this work? Does it semi-naive? But I want to add strata for term producing rules</p>

<div><div><pre><code>#script(python)
def main(ctl):
  for i in range(10):
    ctl.ground([&#34;cong&#34;, [])]) # aka rebuild
    ctl.ground([&#34;rewrite&#34;,[])])
  ctl.solve()

#prog(rebuild)
add(@find(X),@find(Y),@find(Z)) :- add(X,Y,Z).
add(X,Y,@union(Z,Z1)) :- add(X,Y,Z), add(X,Y,Z1), Z != Z1.
#end.

#prog(rewrite)
add(Y,X,Z) :- add(X,Y,Z).
add()

@end.

#end.
</code></pre></div></div>

<pre><code>%re
#script(python)

uf = {}
def find(x):
  while x in uf:
    x = uf[x]
  return x

def union(x,y):
  x = find(x)
  y = find(y)
  if x != y:
    uf[x] = y
  #print(uf)
  return y

#end.

add(X,Y,XY) :- term(XY), XY = add(X,Y).
term(X;Y) :- term(add(X,Y)).
term(add(add(add(add(1,2),3),4),5)).

add(@find(Y),@find(X),@find(Z)) :- add(X,Y,Z).
add(@find(X),@find(YZ),@find(XYZ);@find(Y),@find(Z),@find(YZ)) :- add(X,Y,XY), add(XY,Z,XYZ), YZ = @find(add(Y,Z)).

add(@find(X),@find(Y),@find(Z)) :- add(X,Y,Z).
add(@find(X),@find(Y),@union(Z,Z1)) :- add(X,Y,Z), add(X,Y,Z1), Z != Z1.

enode(N) :- N = #count { X,Y,XY : add(X,Y,XY) }.
enode2(N) :- N = #count { X,Y,XY : fadd(X,Y,XY) }.

fadd(@find(X),@find(Y),@find(Z)) :- add(X,Y,Z).

#show enode/1.
#show enode2/1.
</code></pre>

<h2 id="instruction-selection">Instruction Selection</h2>

<p><a href="https://dl.acm.org/doi/10.1145/3126528">Complete and Practical Universal Instruction Selection</a></p>

<pre><code>prog((
  set(p2,plus(p1,4)),
  set((st,q1), p2),
  set(q2, plus(q1,4)),
  set((st,p1), q2)
)).

plus(p1,4,p2).
plus(p1,4,p1).

</code></pre>

<p>This is doing dag tiling. Graph matching probably doesn’t look that much different.</p>

<pre><code>% demand
expr(X;Y) :- expr(add(X,Y)).
expr(X;Y) :- expr(mul(X,Y)).

{ sel( add, E) } :- expr(E),    E = add(X,Y),        sel(P1,X), sel(P2,Y).
{ sel( mul, E) } :- expr(E),    E = mul(X,Y),        sel(P1,X), sel(P2,Y).
{ sel( fma, E) } :- expr(E),    E = add(mul(X,Y),Z), sel(P1,X), sel(P2,Y), sel(P3,Z).
@
offset(0;1;2;4;8;16).
{ sel( load, E) } :- expr(E),    E = load(add(Addr,N)), sel(P1,Addr), offset(N).

{ sel(reg, E) } :- expr(E), E = var(X). % we don&#39;t _have_ to &#34;use&#34; register if something dumb is using it.


{ sel(nop, E) }:- expr(E), E = add(X,0), sel(P,X).

prog(mul(var(x), var(y))).
expr(E) :- prog(E).

pat(P) :- sel(P,_).

%:- #count { sel(P,E) : expr(E),pat(P) } &gt; 1. % only select at most one pattern
:- #count {sel(P, E) : pat(P), prog(E)} = 0.
%#minimize { 1,X,Y : sel(X,Y) }.

#show expr.


</code></pre>



<p>Given that we already had experience using z3 and that smt solvers are not that different from constraint programming systems, why go for minizinc?</p>

<ul>
  <li>Optimization</li>
  <li>
    <p>Useful bits</p>
  </li>
  <li>text file vs bindings. Speed, flexibility, readability, serialization (cost and boon)</li>
</ul>



<div><div><pre><code><span>% Follow paper exactly.  https://arxiv.org/abs/1804.02452 See Appendix A</span><span>
</span><span>% Difference from unison model.mzn: Try not using integers. Try to use better minizinc syntax. Much simplified</span><span>

</span><span>include</span><span> </span><span>&#34;globals.mzn&#34;</span><span>;</span><span>

</span><span>%% ---------------------------------------</span><span>
</span><span>%% PARAMETERS</span><span>
</span><span>%% ---------------------------------------</span><span>

</span><span>% Type definitions</span><span>
</span><span>% All are enumerative types</span><span>
</span><span>enum</span><span> </span><span>reg_t</span><span>;</span><span>
</span><span>enum</span><span> </span><span>opcode_t</span><span>;</span><span>
</span><span>enum</span><span> </span><span>temp_t</span><span>;</span><span>
</span><span>enum</span><span> </span><span>hvar_t</span><span>;</span><span>
</span><span>enum</span><span> </span><span>operand_t</span><span>;</span><span>
</span><span>enum</span><span> </span><span>operation_t</span><span>;</span><span>
</span><span>enum</span><span> </span><span>block_t</span><span>;</span><span>



</span><span>array</span><span>[</span><span>operand_t</span><span>]</span><span> </span><span>of</span><span> </span><span>operation_t</span><span> </span><span>:</span><span> </span><span>operand_operation</span><span>;</span><span> </span><span>% map from operand to operations it belongs to</span><span>
</span><span>array</span><span>[</span><span>temp_t</span><span>]</span><span> </span><span>of</span><span> </span><span>operand_t</span><span> </span><span>:</span><span> </span><span>definer</span><span>;</span><span> </span><span>%map from temporary to operand that defines it</span><span>
</span><span>array</span><span>[</span><span>temp_t</span><span>]</span><span> </span><span>of</span><span> </span><span>set</span><span> </span><span>of</span><span> </span><span>operand_t</span><span> </span><span>:</span><span> </span><span>users</span><span>;</span><span> </span><span>%map from temporary to operands that possibly use it</span><span>
</span><span>array</span><span>[</span><span>temp_t</span><span>]</span><span> </span><span>of</span><span> </span><span>block_t</span><span> </span><span>:</span><span> </span><span>temp_block</span><span>;</span><span> </span><span>% map from temporary to block it lives in</span><span>

</span><span>set</span><span> </span><span>of</span><span> </span><span>operation_t</span><span> </span><span>:</span><span> </span><span>copy</span><span>;</span><span> </span><span>% is operation a copy operation</span><span>

</span><span>array</span><span>[</span><span>temp_t</span><span>]</span><span> </span><span>of</span><span> </span><span>int</span><span> </span><span>:</span><span> </span><span>width</span><span>;</span><span> </span><span>% Atom width of temporary. Atoms are subpieces of registers. Maybe 8 bit.</span><span>

</span><span>array</span><span>[</span><span>operand_t</span><span>]</span><span> </span><span>of</span><span> </span><span>set</span><span> </span><span>of</span><span> </span><span>reg_t</span><span> </span><span>:</span><span> </span><span>preassign</span><span>;</span><span> </span><span>% preassign operand_t to register.</span><span>

</span><span>array</span><span>[</span><span>temp_t</span><span>]</span><span> </span><span>of</span><span> </span><span>set</span><span> </span><span>of</span><span> </span><span>temp_t</span><span> </span><span>:</span><span> </span><span>congruent</span><span>;</span><span> </span><span>% Whether congruent. Congruent operands are actually the same temporary split by linear SSA.</span><span>

</span><span>array</span><span>[</span><span>operation_t</span><span>]</span><span> </span><span>of</span><span> </span><span>set</span><span> </span><span>of</span><span> </span><span>opcode_t</span><span> </span><span>:</span><span> </span><span>operation_opcodes</span><span>;</span><span> </span><span>% map from operation to possible instructions that implement it</span><span>

</span><span>% register class</span><span>
</span><span>% For simd registers, spilling.</span><span>

</span><span>array</span><span>[</span><span>operand_t</span><span>,</span><span> </span><span>opcode_t</span><span>]</span><span> </span><span>of</span><span> </span><span>set</span><span> </span><span>of</span><span> </span><span>reg_t</span><span> </span><span>:</span><span> </span><span>class_t</span><span>;</span><span>

</span><span>array</span><span>[</span><span>opcode_t</span><span>]</span><span> </span><span>of</span><span> </span><span>int</span><span>:</span><span> </span><span>latency</span><span>;</span><span> </span><span>% latency of instruction</span><span>


</span><span>array</span><span>[</span><span>block_t</span><span>]</span><span> </span><span>of</span><span> </span><span>operation_t</span><span> </span><span>:</span><span> </span><span>block_ins</span><span>;</span><span>
</span><span>array</span><span>[</span><span>block_t</span><span>]</span><span> </span><span>of</span><span> </span><span>operation_t</span><span> </span><span>:</span><span> </span><span>block_outs</span><span>;</span><span>
</span><span>array</span><span>[</span><span>block_t</span><span>]</span><span> </span><span>of</span><span> </span><span>set</span><span> </span><span>of</span><span> </span><span>operation_t</span><span> </span><span>:</span><span> </span><span>block_operations</span><span>;</span><span>

</span><span>% map from user friendly names to temporaries derived them via linear ssa.</span><span>
</span><span>array</span><span>[</span><span>hvar_t</span><span>]</span><span> </span><span>of</span><span> </span><span>set</span><span> </span><span>of</span><span> </span><span>temp_t</span><span> </span><span>:</span><span> </span><span>hvars_temps</span><span>;</span><span>

</span><span>int</span><span>:</span><span> </span><span>MAXC</span><span> </span><span>=</span><span> </span><span>100</span><span>;</span><span> </span><span>% maximum cycle. This should possibily be a parameter read from file.</span><span>

</span><span>% todo: resource parameter</span><span>
</span><span>% con, dur, cap</span><span>

</span><span>% todo: objective function parameters.</span><span>
</span><span>% weight</span><span>
</span><span>% cost</span><span>

</span><span>%% -------------------</span><span>
</span><span>%% Solution exclusion</span><span>
</span><span>%% ---------------------</span><span>
</span><span>int</span><span> </span><span>:</span><span> </span><span>number_excluded</span><span>;</span><span>
</span><span>set</span><span> </span><span>of</span><span> </span><span>int</span><span> </span><span>:</span><span> </span><span>exclusions</span><span> </span><span>=</span><span> </span><span>1</span><span>..</span><span>number_excluded</span><span>;</span><span>
</span><span>array</span><span>[</span><span>exclusions</span><span>,</span><span> </span><span>temp_t</span><span>]</span><span> </span><span>of</span><span> </span><span>reg_t</span><span> </span><span>:</span><span> </span><span>exclude_reg</span><span>;</span><span>
</span><span>/* array[exclusions, operation_t] of opcode_t : exclude_insn;
array[exclusions, operand_t] of temp_t : exclude_temp;
array[exclusions, temp_t] of bool : exclude_live;
array[exclusions, operation_t] of bool : exclude_active;
array[exclusions, operation_t] of 0..MAXC : exclude_issue; % maybe make these ranges. I could see a good argument for that
array[exclusions, temp_t] of 0..MAXC : exclude_start_cycle;
array[exclusions, temp_t] of 0..MAXC : exclude_end_cycle;
*/</span><span>

</span><span>%% ---------------------------------------------------------------</span><span>
</span><span>%%  VARIABLES</span><span>
</span><span>%% ---------------------------------------------------------------</span><span>
</span><span>array</span><span>[</span><span>temp_t</span><span>]</span><span> </span><span>of</span><span> </span><span>var</span><span> </span><span>reg_t</span><span> </span><span>:</span><span> </span><span>reg</span><span>;</span><span>
</span><span>array</span><span>[</span><span>operation_t</span><span>]</span><span> </span><span>of</span><span> </span><span>var</span><span> </span><span>opcode_t</span><span> </span><span>:</span><span> </span><span>opcode</span><span>;</span><span>
</span><span>array</span><span>[</span><span>operand_t</span><span>]</span><span> </span><span>of</span><span> </span><span>var</span><span> </span><span>temp_t</span><span> </span><span>:</span><span> </span><span>temp</span><span>;</span><span>
</span><span>array</span><span>[</span><span>temp_t</span><span>]</span><span> </span><span>of</span><span> </span><span>var</span><span> </span><span>bool</span><span> </span><span>:</span><span> </span><span>live</span><span>;</span><span>
</span><span>array</span><span>[</span><span>operation_t</span><span>]</span><span> </span><span>of</span><span> </span><span>var</span><span> </span><span>bool</span><span> </span><span>:</span><span> </span><span>active</span><span>;</span><span>
</span><span>array</span><span>[</span><span>operation_t</span><span>]</span><span> </span><span>of</span><span> </span><span>var</span><span> </span><span>0</span><span>..</span><span>MAXC</span><span> </span><span>:</span><span> </span><span>issue</span><span>;</span><span> </span><span>% maybe make these ranges. I could see a good argument for that</span><span>
</span><span>array</span><span>[</span><span>temp_t</span><span>]</span><span> </span><span>of</span><span> </span><span>var</span><span> </span><span>0</span><span>..</span><span>MAXC</span><span> </span><span>:</span><span> </span><span>start_cycle</span><span>;</span><span>
</span><span>array</span><span>[</span><span>temp_t</span><span>]</span><span> </span><span>of</span><span> </span><span>var</span><span> </span><span>0</span><span>..</span><span>MAXC</span><span> </span><span>:</span><span> </span><span>end_cycle</span><span>;</span><span>




</span><span>%% ------------------------------</span><span>
</span><span>%% CONSTRAINTS</span><span>
</span><span>%% ------------------------------</span><span>


</span><span>% Exclude all previous solutions</span><span>
</span><span>constraint</span><span> </span><span>forall</span><span>(</span><span>n</span><span> </span><span>in</span><span> </span><span>exclusions</span><span>)(</span><span>
        </span><span>exists</span><span>(</span><span> </span><span>t</span><span> </span><span>in</span><span> </span><span>temp_t</span><span> </span><span>)(</span><span> </span><span>reg</span><span>[</span><span>t</span><span>]</span><span> </span><span>!=</span><span> </span><span>exclude_reg</span><span>[</span><span>n</span><span>,</span><span>t</span><span>]</span><span> </span><span>)</span><span>
    </span><span>%\/  exists( o in operation_t )( opcode[o] != exclude_opcode[n,o] )</span><span>
    </span><span>%\/  exists( o in operand_t )( temp[o] != exclude_temp[n,o] )</span><span>
    </span><span>%\/  exists( t in temp_t )( live[t] != exclude_live[n,t] )</span><span>
    </span><span>%\/  exists( o in operation_t )( active[o] != exclude_active[n,o] )</span><span>
    </span><span>%\/  exists( o in operation_t )( issue[o] != exclude_issue[n,o] )</span><span>
    </span><span>%\/  exists( t in temp_t )( start_cycle[t] != exclude_start_cycle[n,t] )</span><span>
    </span><span>%\/  exists( t in temp_t )( end_cycle[t] != exclude_end_cycle[n,t] )</span><span>
</span><span>);</span><span>


</span><span>% function nonempty?</span><span>


</span><span>% constraint to choose instruction from allowed instructions. Why was this not implied</span><span>
</span><span>% not in the paper</span><span>
</span><span>% maybe if I had more logic interconnecting choice of temporary / register with opcode this would be implied</span><span>
</span><span>constraint</span><span> </span><span>forall</span><span>(</span><span>o</span><span> </span><span>in</span><span> </span><span>operation_t</span><span> </span><span>where</span><span> </span><span>card</span><span>(</span><span>operation_opcodes</span><span>[</span><span>o</span><span>])</span><span> </span><span>&gt;</span><span> </span><span>0</span><span> </span><span>)(</span><span>
    </span><span>opcode</span><span>[</span><span>o</span><span>]</span><span> </span><span>in</span><span> </span><span>operation_opcodes</span><span>[</span><span>o</span><span>]</span><span>
 </span><span>);</span><span>


</span><span>% operand should only be assigned to temporary it either defines or uses.</span><span>
</span><span>% Is this implicit from other constraints?</span><span>
</span><span>constraint</span><span> </span><span>forall</span><span>(</span><span>o</span><span> </span><span>in</span><span> </span><span>operand_t</span><span>)(</span><span>
        </span><span>temp</span><span>[</span><span>o</span><span>]</span><span> </span><span>in</span><span> </span><span>{</span><span> </span><span>t</span><span> </span><span>|</span><span> </span><span>t</span><span> </span><span>in</span><span> </span><span>temp_t</span><span> </span><span>where</span><span> </span><span>definer</span><span>[</span><span>t</span><span>]</span><span> </span><span>=</span><span> </span><span>o</span><span> </span><span>\/</span><span> </span><span>o</span><span> </span><span>in</span><span> </span><span>users</span><span>[</span><span>t</span><span>]</span><span> </span><span>}</span><span>
</span><span>);</span><span>



</span><span>/*
constraint forall(t in temp_t)(
    temp[definer[t]] = t
);

constraint forall(t in temp_t)(
    forall(o in operand_t)(
        exists() temp[o] = t
    )
    temp[users[t]] = t
);
*/</span><span>

</span><span>%C1.1</span><span>
</span><span>% no overlap constraint for live register usage</span><span>
</span><span>% use cumulative?</span><span>
</span><span>% use minizinc built-in diffn.</span><span>
</span><span>% The original unison model uses many different options</span><span>
</span><span>function</span><span> </span><span>array</span><span>[</span><span>int</span><span>]</span><span> </span><span>of</span><span> </span><span>var</span><span> </span><span>int</span><span> </span><span>:</span><span> </span><span>block_array</span><span>(</span><span>array</span><span>[</span><span>temp_t</span><span>]</span><span> </span><span>of</span><span> </span><span>var</span><span> </span><span>int</span><span> </span><span>:</span><span> </span><span>a</span><span>,</span><span> </span><span>block_t</span><span> </span><span>:</span><span> </span><span>b</span><span>)</span><span> </span><span>=</span><span>
    </span><span>[</span><span>a</span><span>[</span><span>t</span><span>]</span><span> </span><span>|</span><span> </span><span>t</span><span> </span><span>in</span><span> </span><span>temp_t</span><span> </span><span>where</span><span> </span><span>temp_block</span><span>[</span><span>t</span><span>]</span><span> </span><span>=</span><span> </span><span>b</span><span> </span><span>];</span><span>

</span><span>% [diffn_nonstrict]  https://www.minizinc.org/doc-latest/en/lib-globals.html#packing-constraints</span><span>
</span><span>% Constrains rectangles i , given by their origins ( x [ i ], y [ i ]) and</span><span>
</span><span>% sizes ( dx [ i ], dy [ i ]), to be non-overlapping. Zero-width rectangles can be packed anywhere.</span><span>

</span><span>% still need to include live[t] condition</span><span>
</span><span>constraint</span><span> </span><span>forall</span><span>(</span><span>blk</span><span> </span><span>in</span><span> </span><span>block_t</span><span>)(</span><span>
        </span><span>diffn</span><span>(</span><span>block_array</span><span>(</span><span>reg</span><span>,</span><span>blk</span><span>),</span><span>  </span><span>% built in global minizinc constraint</span><span>
              </span><span>block_array</span><span>(</span><span>start_cycle</span><span>,</span><span>blk</span><span>),</span><span>
            </span><span>%  block_array([width[t] * bool2int(live[t]) | t in temp_t ], b), % no this is bad</span><span>
            </span><span>block_array</span><span>(</span><span>width</span><span>,</span><span> </span><span>blk</span><span>),</span><span>
              </span><span>[</span><span>end_cycle</span><span>[</span><span>t</span><span>]</span><span> </span><span>-</span><span> </span><span>start_cycle</span><span>[</span><span>t</span><span>]</span><span> </span><span>|</span><span> </span><span>t</span><span> </span><span>in</span><span> </span><span>temp_t</span><span> </span><span>where</span><span> </span><span>temp_block</span><span>[</span><span>t</span><span>]</span><span> </span><span>=</span><span> </span><span>blk</span><span>])</span><span>
</span><span>);</span><span>


</span><span>% C2.1 Pre-assignment to registers</span><span>
</span><span>constraint</span><span> </span><span>forall</span><span>(</span><span>p</span><span> </span><span>in</span><span> </span><span>operand_t</span><span>)</span><span> </span><span>(</span><span>
                </span><span>forall</span><span>(</span><span>r</span><span> </span><span>in</span><span> </span><span>preassign</span><span>[</span><span>p</span><span>])(</span><span>
                      </span><span>reg</span><span>[</span><span>temp</span><span>[</span><span>p</span><span>]]</span><span> </span><span>=</span><span> </span><span>r</span><span>
                </span><span>)</span><span>
            </span><span>);</span><span>

</span><span>% C3.2. register class constraint</span><span>
</span><span>constraint</span><span> </span><span>forall</span><span>(</span><span>p</span><span> </span><span>in</span><span> </span><span>operand_t</span><span> </span><span>where</span><span> </span><span>active</span><span>[</span><span>operand_operation</span><span>[</span><span>p</span><span>]])(</span><span>
    </span><span>reg</span><span>[</span><span>temp</span><span>[</span><span>p</span><span>]]</span><span> </span><span>in</span><span> </span><span>class_t</span><span>[</span><span>p</span><span>,</span><span> </span><span>opcode</span><span>[</span><span>operand_operation</span><span>[</span><span>p</span><span>]]]</span><span>

</span><span>);</span><span>

</span><span>% C4 Every operation that is not a copy must be active.</span><span>
</span><span>constraint</span><span> </span><span>forall</span><span>(</span><span>o</span><span> </span><span>in</span><span> </span><span>operation_t</span><span> </span><span>where</span><span> </span><span>not</span><span> </span><span>(</span><span>o</span><span> </span><span>in</span><span> </span><span>copy</span><span>))(</span><span>
    </span><span>active</span><span>[</span><span>o</span><span>]</span><span>
</span><span>);</span><span>

</span><span>% C5.1  A temporary is live if its defining operation is active</span><span>
</span><span>constraint</span><span> </span><span>forall</span><span>(</span><span>t</span><span> </span><span>in</span><span> </span><span>temp_t</span><span>)(</span><span>
    </span><span>live</span><span>[</span><span>t</span><span>]</span><span> </span><span>=</span><span> </span><span>active</span><span>[</span><span>operand_operation</span><span>[</span><span>definer</span><span>[</span><span>t</span><span>]]]</span><span>
</span><span>);</span><span>

</span><span>% C5.2 For an active operation there must be at least one live temporary available</span><span>
</span><span>constraint</span><span> </span><span>forall</span><span>(</span><span>t</span><span> </span><span>in</span><span> </span><span>temp_t</span><span>)(</span><span>
    </span><span>%card({p | p in users[t] where live[t] == active[operand_operation[p]] /\ temp[p] == t}) &gt;= 1 % fishy encoding</span><span>
    </span><span>live</span><span>[</span><span>t</span><span>]</span><span> </span><span>&lt;-</span><span> </span><span>exists</span><span>(</span><span>p</span><span> </span><span>in</span><span> </span><span>users</span><span>[</span><span>t</span><span>])(</span><span> </span><span>active</span><span>[</span><span>operand_operation</span><span>[</span><span>p</span><span>]]</span><span> </span><span>/\</span><span> </span><span>temp</span><span>[</span><span>p</span><span>]</span><span> </span><span>=</span><span> </span><span>t</span><span> </span><span>)</span><span> </span><span>% should be both way implication?</span><span>
</span><span>);</span><span>

</span><span>% C6 Congruent temps map to the same register</span><span>
</span><span>constraint</span><span> </span><span>forall</span><span> </span><span>(</span><span>p</span><span> </span><span>in</span><span> </span><span>temp_t</span><span>,</span><span> </span><span>q</span><span> </span><span>in</span><span> </span><span>temp_t</span><span> </span><span>where</span><span> </span><span>q</span><span> </span><span>in</span><span> </span><span>congruent</span><span>[</span><span>p</span><span>])(</span><span>
    </span><span>reg</span><span>[</span><span>p</span><span>]</span><span> </span><span>=</span><span> </span><span>reg</span><span>[</span><span>q</span><span>]</span><span>
</span><span>);</span><span>

</span><span>%% Instruction Scheduling Constraints</span><span>

</span><span>% C7.1  The issue cycle of operations that define temporaries must be before all</span><span>
</span><span>%       active operations that use that temporary</span><span>
</span><span>constraint</span><span> </span><span>forall</span><span> </span><span>(</span><span>t</span><span> </span><span>in</span><span> </span><span>temp_t</span><span>)(</span><span>
     </span><span>let</span><span> </span><span>{</span><span>operand_t</span><span> </span><span>:</span><span> </span><span>p</span><span> </span><span>=</span><span> </span><span>definer</span><span>[</span><span>t</span><span>]}</span><span> </span><span>in</span><span>
        </span><span>forall</span><span>(</span><span>q</span><span> </span><span>in</span><span> </span><span>users</span><span>[</span><span>t</span><span>]</span><span> </span><span>where</span><span> </span><span>active</span><span>[</span><span>operand_operation</span><span>[</span><span>q</span><span>]]</span><span> </span><span>/\</span><span> </span><span>temp</span><span>[</span><span>q</span><span>]</span><span> </span><span>==</span><span> </span><span>t</span><span>)(</span><span>
            </span><span>issue</span><span>[</span><span>operand_operation</span><span>[</span><span>q</span><span>]]</span><span> </span><span>&gt;=</span><span> </span><span>issue</span><span>[</span><span>operand_operation</span><span>[</span><span>p</span><span>]]</span><span> </span><span>+</span><span> </span><span>latency</span><span>[</span><span>opcode</span><span>[</span><span>operand_operation</span><span>[</span><span>p</span><span>]]]</span><span>
    </span><span>)</span><span>
</span><span>);</span><span>

</span><span>% resource consumptions contraint</span><span>
</span><span>% TODO. We are not tracking resource consumption yet</span><span>
</span><span>/*
use cumulative

constraint forall (b in block_ts)(
    forall (s in Resource)
)
*/</span><span>

</span><span>%% Integration Constraints</span><span>

</span><span>% C9 The start cycle of a temporary is the issue cycle of it&#39;s defining operation</span><span>
</span><span>constraint</span><span> </span><span>forall</span><span> </span><span>(</span><span>t</span><span> </span><span>in</span><span> </span><span>temp_t</span><span> </span><span>where</span><span> </span><span>live</span><span>[</span><span>t</span><span>])(</span><span>
   </span><span>start_cycle</span><span>[</span><span>t</span><span>]</span><span> </span><span>==</span><span> </span><span>issue</span><span>[</span><span>operand_operation</span><span>[</span><span>definer</span><span>[</span><span>t</span><span>]]]</span><span>
</span><span>);</span><span>

</span><span>% Not in paper. Do we want this?</span><span>
</span><span>% end is at least past the start cycle plus the latency of the operation</span><span>
</span><span>/*
constraint forall (t in temp_t)(
    end[t] &gt;= start[t] + latency[ opcode[ operand_operation[definer[t]] ]]
);
*/</span><span>



</span><span>%C10 Then end cycle of a temporary is the last issue cycle of operations that use it.</span><span>
</span><span>constraint</span><span> </span><span>forall</span><span> </span><span>(</span><span>t</span><span> </span><span>in</span><span> </span><span>temp_t</span><span> </span><span>where</span><span> </span><span>card</span><span>(</span><span>users</span><span>[</span><span>t</span><span>])</span><span> </span><span>&gt;</span><span> </span><span>0</span><span> </span><span>/\</span><span> </span><span>live</span><span>[</span><span>t</span><span>])(</span><span>

   </span><span>end_cycle</span><span>[</span><span>t</span><span>]</span><span> </span><span>==</span><span> </span><span>max</span><span>(</span><span>
      </span><span>% [ start[t] + 10 ] ++  % a kludge to make minizinc not upset when users[t] is empty.</span><span>
       </span><span>[</span><span> </span><span>issue</span><span>[</span><span>operand_operation</span><span>[</span><span>p</span><span>]]</span><span>  </span><span>|</span><span> </span><span>p</span><span> </span><span>in</span><span> </span><span>users</span><span>[</span><span>t</span><span>]</span><span> </span><span>where</span><span> </span><span>temp</span><span>[</span><span>p</span><span>]</span><span> </span><span>==</span><span> </span><span>t</span><span>  </span><span>]</span><span>  </span><span>)</span><span>
       </span><span>% shouldn&#39;t this also be contingent on whether the user is active?</span><span>
       </span><span>% I suppose the temporary won&#39;t be live then.</span><span>
</span><span>);</span><span>

</span><span>% In blocks must be at start of block</span><span>
</span><span>% Outs must be at end</span><span>

</span><span>constraint</span><span> </span><span>forall</span><span> </span><span>(</span><span>blk</span><span> </span><span>in</span><span> </span><span>block_t</span><span>)(</span><span>
    </span><span>issue</span><span>[</span><span>block_ins</span><span>[</span><span>blk</span><span>]]</span><span> </span><span>==</span><span> </span><span>0</span><span>
    </span><span>/\</span><span>
    </span><span>% worse but possibly faster</span><span>
    </span><span>% issue[block_outs[blk]] == MAXC</span><span>
    </span><span>forall</span><span>(</span><span>o</span><span> </span><span>in</span><span> </span><span>block_operations</span><span>[</span><span>blk</span><span>])</span><span> </span><span>(</span><span>issue</span><span>[</span><span>o</span><span>]</span><span> </span><span>&lt;=</span><span> </span><span>issue</span><span>[</span><span>block_outs</span><span>[</span><span>blk</span><span>]])</span><span>
</span><span>);</span><span>


</span><span>% anything that has a where clause that isn&#39;t just parameters makes me queasy. What is this going to do?</span><span>

</span><span>%----------------------</span><span>
</span><span>% HELPERS</span><span>
</span><span>%----------------------</span><span>

</span><span>predicate</span><span> </span><span>set_reg</span><span>(</span><span>hvar_t</span><span>:</span><span> </span><span>hvar</span><span>,</span><span> </span><span>reg_t</span><span>:</span><span> </span><span>r</span><span>)</span><span> </span><span>=</span><span>
 </span><span>forall</span><span>(</span><span>t</span><span> </span><span>in</span><span> </span><span>hvars_temps</span><span>[</span><span>hvar</span><span>])(</span><span>reg</span><span>[</span><span>t</span><span>]</span><span> </span><span>=</span><span> </span><span>r</span><span>);</span><span>

</span><span>predicate</span><span> </span><span>exclude_reg</span><span>(</span><span>reg_t</span><span>:</span><span> </span><span>r</span><span>)</span><span> </span><span>=</span><span>
 </span><span>forall</span><span>(</span><span>t</span><span> </span><span>in</span><span> </span><span>temp</span><span>)(</span><span>reg</span><span>[</span><span>t</span><span>]</span><span> </span><span>!=</span><span> </span><span>r</span><span>);</span><span>

</span><span>%--------------------------------</span><span>
</span><span>% OBJECTIVE</span><span>
</span><span>%-------------------------------</span><span>

</span><span>% Minimize number of registers</span><span>
</span><span>solve</span><span> </span><span>minimize</span><span> </span><span>card</span><span>(</span><span> </span><span>{</span><span>r</span><span> </span><span>|</span><span> </span><span>p</span><span> </span><span>in</span><span> </span><span>operand_t</span><span>,</span><span> </span><span>r</span><span> </span><span>in</span><span> </span><span>reg_t</span><span> </span><span>where</span><span> </span><span>reg</span><span>[</span><span>temp</span><span>[</span><span>p</span><span>]]</span><span> </span><span>=</span><span> </span><span>r</span><span> </span><span>}</span><span> </span><span>);</span><span>


</span><span>%TODO. For the moment, mere satisfaction would make me happy</span><span>
</span><span>% minimize max( [end[t] | t in temp_t ] ) % total estimated time (spilling is slow)</span><span>
</span><span>% minimize resource usage</span><span>
</span><span>% solve minimize max( end );</span><span>
</span><span>% solve minimize max( reg ); % use smallest number of registers</span><span>

</span></code></pre></div></div>

<h3 id="shallow-minizinc-dsl">Shallow Minizinc DSL</h3>



<h4 id="arch-spcific-arm">arch spcific. Arm</h4>

<div><div><pre><code>enum reg = {R0, R1, R2, 
    Stack0, Stack1, Stack2,
    Mem,
    ZF,
    CF};
%enum pseudo_temp
callee_saved = 
caller_saved = 
gpr = {R0, R1, R2};
stack


predicate gpr(temp_t : t) = 
     reg[t] in {R0, R1, R2};

predicate mov(temp_t t1, temp_t t2) = 
    insn([t1], &#34;mov&#34;, [t2]) /\ gpr(t1) /\ gpr(t2);

predicate binop(temp_t t1, temp_t t2, temp_t t3) = 
    insn([t1], &#34;mov&#34;, [t2]) /\ gpr(t1) /\ gpr(t2) /\ gpr(t3);

% style not good for programmatic discovered insns
% could pretty print it.
predicate arm(id, lhs, opcode, rhs) =
    if opcode = &#34;mov&#34; then
        insn() /\ gpr() /\ gpr()
    elseif opcode = &#34;add&#34; \/ opcode = &#34;mul&#34; \/ then
        isns(opcode)
    elseif
    endif
    
</code></pre></div></div>

<h4 id="model-3">model 3</h4>

<div><div><pre><code>% Follow paper exactly.  https://arxiv.org/abs/1804.02452 See Appendix A
% Difference from unison model.mzn: Try not using integers. Try to use better minizinc syntax. Much simplified

include &#34;globals.mzn&#34;;

% Type definitions
% All are enumerative types
enum reg_t = {R0,R1,R2, R3, R4};
enum block_t;
enum temp_t;

int: MAXC = 100; % maximum cycle. This should possibily be a parameter read from file.




predicate insn_c(operation_t : id, list of temp_t : lhs, string : opcode, list of temp_t : rhs) = 
    all_equal([start_cycle[t] | t in lhs]) /\
    forall(t in lhs)(
        live[t] /\ % definer active
        issue[id] + 1 = start_cycle[t] /\
        end_cycle[t] &gt;= issue[id] + 1)
        /\
        forall(t2 in rhs)(
            live[t2] /\ %user active
            issue[id] &gt;= start_cycle[t2] /\ % t2 is already defined
            end_cycle[t2] &gt;= issue[id]  % t2 ends
        );



predicate insn(operation_t : id, list of temp_t : lhs, string : opcode, list of temp_t : rhs) = 
    active[id] /\ insn_c(id,lhs,opcode,rhs);
predicate insn_opt(operation_t : id, list of temp_t : lhs, string : opcode, list of temp_t : rhs) = 
    active[id] -&gt; insn_c(id,lhs,opcode,rhs);

% still need to include live[t] condition
constraint diffn(reg,  % built in global minizinc constraint
              start_cycle,
            %  block_array([width[t] * bool2int(live[t]) | t in temp_t ], b), % no this is bad
              [1 | t in temp_t],
              [end_cycle[t] - start_cycle[t] | t in temp_t]);

array[temp_t] of var reg_t : reg;
array[temp_t] of var 0..MAXC : start_cycle; % def_cycle
array[temp_t] of var 0..MAXC : end_cycle; % death_cycle
array[operation_t] of var bool : active;
array[operation_t] of var 0..MAXC : issue;
array[temp_t] of var bool : live;

% https://www.minizinc.org/doc-2.5.5/en/sat.html
% useful for alternative instructions.
predicate atmostone(array[int] of var bool:x) =
          forall(i,j in index_set(x) where i &lt; j)(
            (not x[i] \/ not x[j]));
predicate exactlyone(array[int] of var bool:x) =
          atmostone(x) /\ exists(x);
predicate alt_insn(list of operation_t : ops) =
    exactlyone([active[o] |o in ops]);


predicate preassign(temp_t : t, reg_t : r) = reg[t] = r;

predicate cong(temp_t : t1, temp_t : t2) = 
    reg[t1] = reg[t2] /\ live[t1] = live[t2];

predicate outs(list of temp_t : ts) =
    forall( t in ts)(end_cycle[t] = MAXC);

predicate ins(list of temp_t : ts) =
    forall( t in ts)(start_cycle[t] = 0);

predicate force_order(operation_t : id1, operation_t : id2) =
    issue[id1] &lt; issue[id2];

% Program specific data:


/*
enum block_t = {B1};
enum temp_t = {T1,T2,T3};
set of int : operation_t = 1..3;

constraint preassign(F,R0);


constraint 
           ins([T3]) /\ 
           insn(1, [T1], &#34;add&#34;, [T2,T3]) /\ 
           insn(2, [T2], &#34;mov&#34;, [T3]) /\ 
           outs([T1]);

*/
block_t = {Begin, Loop, End};
temp_t = {FB,NB, FL1, FL2, NL1, NL2, };
set of int : operation_t = 1..3;

constraint preassign(NB,R0);


constraint 
           ins([NB]) /\ 
           insn(1, [FB], &#34;mov&#34;, []) /\ % mov F, 1
           outs([NB,FB]) /\

           ins([NL1,FL1]) /\
           insn(2, [FL2], &#34;mul&#34;, [FL1, NL1] ) /\
          % insn(3, [NL2], &#34;dec&#34;, [NL1]) /\ cong(NL1,NL2) /\ 
           % jmp loop if NL2 &gt; 0
           outs([NL2, FL2]) /\

           % ret
           cong(FB,FL1)  /\
           cong(NB, NL1) /\
           cong(NL1,NL2);

</code></pre></div></div>

<h4 id="no-reorder">no reorder</h4>

<div><div><pre><code>% Follow paper exactly.  https://arxiv.org/abs/1804.02452 See Appendix A
% Difference from unison model.mzn: Try not using integers. Try to use better minizinc syntax. Much simplified

include &#34;globals.mzn&#34;;

% Type definitions
% All are enumerative types
enum reg_t = {R0,R1,R2};
enum block_t = {B1};
enum temp_t = {T1,T2,T3};

int: MAXC = 100; % maximum cycle. This should possibily be a parameter read from file.

predicate insn(int : id, list of temp_t : lhs, string : opcode, list of temp_t : rhs) = 
    forall(t in lhs)(
        start_cycle[t] = id /\
        forall(t2 in rhs)(
            start_cycle[t] &gt; start_cycle[t2] /\ % t2 is already started
            end_cycle[t2] &gt;= start_cycle[t]  %
        )
    );

% still need to include live[t] condition
constraint diffn(reg,  % built in global minizinc constraint
              start_cycle,
            %  block_array([width[t] * bool2int(live[t]) | t in temp_t ], b), % no this is bad
              [1 | t in temp_t],
              [end_cycle[t] - start_cycle[t] | t in temp_t]);

array[temp_t] of var reg_t : reg;
array[temp_t] of var 0..MAXC : issue; % def_cycle
array[temp_t] of var 0..MAXC : start_cycle; % def_cycle
array[temp_t] of var 0..MAXC : end_cycle; % death_cycle

predicate preassign(temp_t : t, reg_t : r) = reg[t] = r;

predicate outs(list of temp_t : ts) =
    forall( t in ts)(end_cycle[t] = MAXC);

predicate ins(list of temp_t : ts) =
    forall( t in ts)(start_cycle[t] = 0);

% Program specific data:

constraint preassign(T1,R2);

constraint 
           ins([T3]) /\ 
           insn(1,[T2], &#34;mov&#34;, [T3]) /\ 
           insn(2,[T1], &#34;add&#34;, [T2,T3]) /\ 
           outs([T1]);


</code></pre></div></div>

<h4 id="basic">basic</h4>

<div><div><pre><code><span>% Follow paper exactly.  https://arxiv.org/abs/1804.02452 See Appendix A</span><span>
</span><span>% Difference from unison model.mzn: Try not using integers. Try to use better minizinc syntax. Much simplified</span><span>

</span><span>include</span><span> </span><span>&#34;globals.mzn&#34;</span><span>;</span><span>

</span><span>% Type definitions</span><span>
</span><span>% All are enumerative types</span><span>
</span><span>enum</span><span> </span><span>reg_t</span><span> </span><span>=</span><span> </span><span>{</span><span>R0</span><span>,</span><span>R1</span><span>,</span><span>R2</span><span>};</span><span>
</span><span>enum</span><span> </span><span>block_t</span><span> </span><span>=</span><span> </span><span>{</span><span>B1</span><span>};</span><span>
</span><span>enum</span><span> </span><span>temp_t</span><span> </span><span>=</span><span> </span><span>{</span><span>T1</span><span>,</span><span>T2</span><span>,</span><span>T3</span><span>};</span><span>

</span><span>int</span><span>:</span><span> </span><span>MAXC</span><span> </span><span>=</span><span> </span><span>100</span><span>;</span><span> </span><span>% maximum cycle. This should possibily be a parameter read from file.</span><span>

</span><span>predicate</span><span> </span><span>insn</span><span>(</span><span>list</span><span> </span><span>of</span><span> </span><span>temp_t</span><span> </span><span>:</span><span> </span><span>lhs</span><span>,</span><span> </span><span>string</span><span> </span><span>:</span><span> </span><span>opcode</span><span>,</span><span> </span><span>list</span><span> </span><span>of</span><span> </span><span>temp_t</span><span> </span><span>:</span><span> </span><span>rhs</span><span>)</span><span> </span><span>=</span><span> 
    </span><span>all_equal</span><span>([</span><span>start_cycle</span><span>[</span><span>t</span><span>]</span><span> </span><span>|</span><span> </span><span>t</span><span> </span><span>in</span><span> </span><span>lhs</span><span>])</span><span> </span><span>/\</span><span>
    </span><span>forall</span><span>(</span><span>t</span><span> </span><span>in</span><span> </span><span>lhs</span><span>)(</span><span>
        </span><span>forall</span><span>(</span><span>t2</span><span> </span><span>in</span><span> </span><span>rhs</span><span>)(</span><span>
            </span><span>start_cycle</span><span>[</span><span>t</span><span>]</span><span> </span><span>&gt;</span><span> </span><span>start_cycle</span><span>[</span><span>t2</span><span>]</span><span> </span><span>/\</span><span> </span><span>% t2 is already started</span><span>
            </span><span>end_cycle</span><span>[</span><span>t2</span><span>]</span><span> </span><span>&gt;=</span><span> </span><span>start_cycle</span><span>[</span><span>t</span><span>]</span><span>  </span><span>%</span><span>
        </span><span>)</span><span>
    </span><span>);</span><span>

</span><span>% still need to include live[t] condition</span><span>
</span><span>constraint</span><span> </span><span>diffn</span><span>(</span><span>reg</span><span>,</span><span>  </span><span>% built in global minizinc constraint</span><span>
              </span><span>start_cycle</span><span>,</span><span>
            </span><span>%  block_array([width[t] * bool2int(live[t]) | t in temp_t ], b), % no this is bad</span><span>
              </span><span>[</span><span>1</span><span> </span><span>|</span><span> </span><span>t</span><span> </span><span>in</span><span> </span><span>temp_t</span><span>],</span><span>
              </span><span>[</span><span>end_cycle</span><span>[</span><span>t</span><span>]</span><span> </span><span>-</span><span> </span><span>start_cycle</span><span>[</span><span>t</span><span>]</span><span> </span><span>|</span><span> </span><span>t</span><span> </span><span>in</span><span> </span><span>temp_t</span><span>]);</span><span>

</span><span>array</span><span>[</span><span>temp_t</span><span>]</span><span> </span><span>of</span><span> </span><span>var</span><span> </span><span>reg_t</span><span> </span><span>:</span><span> </span><span>reg</span><span>;</span><span>
</span><span>array</span><span>[</span><span>temp_t</span><span>]</span><span> </span><span>of</span><span> </span><span>var</span><span> </span><span>0</span><span>..</span><span>MAXC</span><span> </span><span>:</span><span> </span><span>start_cycle</span><span>;</span><span> </span><span>% def_cycle</span><span>
</span><span>array</span><span>[</span><span>temp_t</span><span>]</span><span> </span><span>of</span><span> </span><span>var</span><span> </span><span>0</span><span>..</span><span>MAXC</span><span> </span><span>:</span><span> </span><span>end_cycle</span><span>;</span><span> </span><span>% death_cycle</span><span>

</span><span>predicate</span><span> </span><span>preassign</span><span>(</span><span>temp_t</span><span> </span><span>:</span><span> </span><span>t</span><span>,</span><span> </span><span>reg_t</span><span> </span><span>:</span><span> </span><span>r</span><span>)</span><span> </span><span>=</span><span> </span><span>reg</span><span>[</span><span>t</span><span>]</span><span> </span><span>=</span><span> </span><span>r</span><span>;</span><span>

</span><span>predicate</span><span> </span><span>outs</span><span>(</span><span>list</span><span> </span><span>of</span><span> </span><span>temp_t</span><span> </span><span>:</span><span> </span><span>ts</span><span>)</span><span> </span><span>=</span><span>
    </span><span>forall</span><span>(</span><span> </span><span>t</span><span> </span><span>in</span><span> </span><span>ts</span><span>)(</span><span>end_cycle</span><span>[</span><span>t</span><span>]</span><span> </span><span>=</span><span> </span><span>MAXC</span><span>);</span><span>

</span><span>predicate</span><span> </span><span>ins</span><span>(</span><span>list</span><span> </span><span>of</span><span> </span><span>temp_t</span><span> </span><span>:</span><span> </span><span>ts</span><span>)</span><span> </span><span>=</span><span>
    </span><span>forall</span><span>(</span><span> </span><span>t</span><span> </span><span>in</span><span> </span><span>ts</span><span>)(</span><span>start_cycle</span><span>[</span><span>t</span><span>]</span><span> </span><span>=</span><span> </span><span>0</span><span>);</span><span>

</span><span>% Program specific data:</span><span>

</span><span>constraint</span><span> </span><span>preassign</span><span>(</span><span>T1</span><span>,</span><span>R2</span><span>);</span><span>

</span><span>constraint</span><span> 
           </span><span>ins</span><span>([</span><span>T3</span><span>])</span><span> </span><span>/\</span><span> 
           </span><span>insn</span><span>([</span><span>T1</span><span>],</span><span> </span><span>&#34;add&#34;</span><span>,</span><span> </span><span>[</span><span>T2</span><span>,</span><span>T3</span><span>])</span><span> </span><span>/\</span><span> 
           </span><span>insn</span><span>([</span><span>T2</span><span>],</span><span> </span><span>&#34;mov&#34;</span><span>,</span><span> </span><span>[</span><span>T3</span><span>])</span><span> </span><span>/\</span><span> 
           </span><span>outs</span><span>([</span><span>T1</span><span>]);</span><span>


</span></code></pre></div></div>

<h4 id="bool-live">bool live</h4>

<div><div><pre><code>enum reg_t = {R0, R1, R2, R3};
enum temp_t = {T0, T1, T2, T3, T4, T5};
int : MAXID = 5;
set of int : operation_t = 0..MAXID;

array[temp_t, operation_t] of var bool : live_in;
array[temp_t] of var reg_t : reg;

predicate insn(operation_t : id, list of temp_t : lhs, string : opcode, list of temp_t : rhs) = 
  % https://en.wikipedia.org/wiki/Live_variable_analysis
  forall(t in temp_t)(
    if (t in rhs) % in gen set
      then live_in[t, id] = true
    elseif (t in lhs) % not in gen set, in kill set
      then live_in[t,id] = false
    else % propagate
      live_in[t,id] &lt;- live_in[t, id + 1] 
    endif) /\
  % Assignments need to go to different registers than live variables of next instruction.
  forall(t1 in lhs)(
    forall(t2 in temp_t where t1 != t2)(
      live_in[t2,id+1] -&gt; reg[t1] != reg[t2]
  ));

% Nothing is live at end of block
constraint forall(t in temp_t)( live_in[t, MAXID] = false);

constraint 
  insn(0, [T1], &#34;mov&#34;, [T0])     /\
  insn(1, [T2], &#34;add&#34;, [T0, T1]) /\
  insn(2, [T3], &#34;sub&#34;, [T0, T1]) /\
  insn(3, [T4], &#34;mul&#34;, [T1, T2]) /\
  insn(4, [T5], &#34;inc&#34;, [T4]);


%reg = [T0: R2, T1: R0, T2: R1, T3: R2, T4: R0, T5: R0];
%live_in = 
%[|         0:     1:     2:     3:     4:     5: 
% | T0:  true,  true,  true, false, false, false
% | T1: false,  true,  true,  true, false, false
% | T2: false, false,  true,  true, false, false
% | T3: false, false, false, false, false, false
% | T4: false, false, false, false,  true, false
% | T5: false, false, false, false, false, false
% |];
%----------

% if we&#39;re not in ssa, maybe 
% array[temp_t, id] of var reg_t; 
% since register can change as reuse site.

% Registers don&#39;t allocate to same spot
%constraint forall (id in operation_t)(
%  forall(t1 in temp_t)(
%    forall(t2 in temp_t)(
%      (live_in[t1,id] /\ live_in[t2,id] /\ t1 != t2) -&gt;
%      reg[t1] != reg[t2]
%    )));
</code></pre></div></div>





<h2 id="declarative-code-gen">Declarative Code Gen</h2>

<ul>
  <li><a href="https://personal.utdallas.edu/~hamlen/lundquist19minikanren.pdf">Relational Processing for Fun and Diversity</a> minikanren</li>
  <li><a href="https://courses.cs.washington.edu/courses/cse501/15sp/papers/joshi.pdf">Denali - a goal directed super optimizer</a> egraph based optimization of assembly</li>
  <li><a href="https://cseweb.ucsd.edu/~lerner/papers/popl09.pdf">PEG</a> egraph cfg</li>
  <li><a href="https://github.com/egraphs-good/egg/discussions/106">RVSDG</a></li>
  <li><a href="https://github.com/orchid-hybrid/minimips">minimips minikanren mips assembler/disassembler</a></li>
  <li>
    <p><a href="https://dl.acm.org/doi/abs/10.1145/22719.22946">Parsing and compiling using Prolog</a> There is also a chapter in the art of prolog</p>
  </li>
  <li><a href="https://www.cs.tufts.edu/~nr/pubs/zipcfg.pdf">https://www.cs.tufts.edu/~nr/pubs/zipcfg.pdf</a> zgraph</li>
  <li>hoopl <a href="https://hackage.haskell.org/package/hoopl-3.7.7.0/src/hoopl.pdf">https://hackage.haskell.org/package/hoopl-3.7.7.0/src/hoopl.pdf</a> a framework for transformations</li>
</ul>

<h3 id="unison-1">Unison</h3>

<ul>
  <li><a href="https://unison-code.github.io/">Unison</a></li>
</ul>

<p><a href="http://www.diva-portal.org/smash/get/diva2:1232129/FULLTEXT01.pdf">diversification</a> make many versions of binary to make code reuse attacks harder. disunison</p>

<p>Toy Program:</p>

<p>If you do liveness analysis ahead of time, it really does become graph coloring, with an edge between every temporary that is live at the same time.</p>

<p>You cannot do liveness ahead of time if you integrate instruction scheduling with allocation. It needs to be internalized.</p>

<p>If you do SSA ahead of time, you have more flexibility to change colors/register at overwrite points</p>

<p>How to communicate to minizinc:</p>

<ul>
  <li>Serialized files or C bindings</li>
  <li>Parameters or constraints. In some sense, you a writing a constraint interpreter over the parameters. Why not cut out the middleman? 1: less clear what the structure is. 2. It forces your hand with the bundling of different pieces. Many things need to be bundled into the <code>insn</code> predicate unless you reify the <code>insn</code> predicate to a variable, in which case you are rebuilding the parameter version.</li>
</ul>

<p>There is a spectrum of more or less complex models you can use.</p>

<h3 id="fixed-instruction-order">Fixed Instruction Order</h3>

<p>This makes a DSL in minizinc that looks like a somewhat reasonable IR. It uses a predicate function <code>insn</code> that takes in the lhs and rhs temporaries. It assigns a register to each temporary such that it never clobbers a live variable.</p>

<p>I could do the liveness analysis completely statically, but I choose to internalize it into the model for ease.</p>

<div><div><pre><code><span>enum</span><span> </span><span>reg_t</span><span> </span><span>=</span><span> </span><span>{</span><span>R0</span><span>,</span><span> </span><span>R1</span><span>,</span><span> </span><span>R2</span><span>,</span><span> </span><span>R3</span><span>};</span><span>
</span><span>enum</span><span> </span><span>temp_t</span><span> </span><span>=</span><span> </span><span>{</span><span>T0</span><span>,</span><span> </span><span>T1</span><span>,</span><span> </span><span>T2</span><span>,</span><span> </span><span>T3</span><span>,</span><span> </span><span>T4</span><span>,</span><span> </span><span>T5</span><span>};</span><span>
</span><span>int</span><span> </span><span>:</span><span> </span><span>MAXID</span><span> </span><span>=</span><span> </span><span>5</span><span>;</span><span>
</span><span>set</span><span> </span><span>of</span><span> </span><span>int</span><span> </span><span>:</span><span> </span><span>operation_t</span><span> </span><span>=</span><span> </span><span>0</span><span>..</span><span>MAXID</span><span>;</span><span>

</span><span>array</span><span>[</span><span>temp_t</span><span>,</span><span> </span><span>operation_t</span><span>]</span><span> </span><span>of</span><span> </span><span>var</span><span> </span><span>bool</span><span> </span><span>:</span><span> </span><span>live_in</span><span>;</span><span>
</span><span>array</span><span>[</span><span>temp_t</span><span>]</span><span> </span><span>of</span><span> </span><span>var</span><span> </span><span>reg_t</span><span> </span><span>:</span><span> </span><span>reg</span><span>;</span><span>

</span><span>predicate</span><span> </span><span>insn</span><span>(</span><span>operation_t</span><span> </span><span>:</span><span> </span><span>id</span><span>,</span><span> </span><span>list</span><span> </span><span>of</span><span> </span><span>temp_t</span><span> </span><span>:</span><span> </span><span>lhs</span><span>,</span><span> </span><span>string</span><span> </span><span>:</span><span> </span><span>opcode</span><span>,</span><span> </span><span>list</span><span> </span><span>of</span><span> </span><span>temp_t</span><span> </span><span>:</span><span> </span><span>rhs</span><span>)</span><span> </span><span>=</span><span> 
  </span><span>% https://en.wikipedia.org/wiki/Live_variable_analysis</span><span>
  </span><span>forall</span><span>(</span><span>t</span><span> </span><span>in</span><span> </span><span>temp_t</span><span>)(</span><span>
    </span><span>if</span><span> </span><span>(</span><span>t</span><span> </span><span>in</span><span> </span><span>rhs</span><span>)</span><span> </span><span>% in gen set</span><span>
      </span><span>then</span><span> </span><span>live_in</span><span>[</span><span>t</span><span>,</span><span> </span><span>id</span><span>]</span><span> </span><span>=</span><span> </span><span>true</span><span>
    </span><span>elseif</span><span> </span><span>(</span><span>t</span><span> </span><span>in</span><span> </span><span>lhs</span><span>)</span><span> </span><span>% not in gen set, in kill set</span><span>
      </span><span>then</span><span> </span><span>live_in</span><span>[</span><span>t</span><span>,</span><span>id</span><span>]</span><span> </span><span>=</span><span> </span><span>false</span><span>
    </span><span>else</span><span> </span><span>% propagate</span><span>
      </span><span>live_in</span><span>[</span><span>t</span><span>,</span><span>id</span><span>]</span><span> </span><span>&lt;-</span><span> </span><span>live_in</span><span>[</span><span>t</span><span>,</span><span> </span><span>id</span><span> </span><span>+</span><span> </span><span>1</span><span>]</span><span> 
    </span><span>endif</span><span>)</span><span> </span><span>/\</span><span>
  </span><span>% Assignments need to go to different registers than live variables of next instruction.</span><span>
  </span><span>forall</span><span>(</span><span>t1</span><span> </span><span>in</span><span> </span><span>lhs</span><span>)(</span><span>
    </span><span>forall</span><span>(</span><span>t2</span><span> </span><span>in</span><span> </span><span>temp_t</span><span> </span><span>where</span><span> </span><span>t1</span><span> </span><span>!=</span><span> </span><span>t2</span><span>)(</span><span>
      </span><span>live_in</span><span>[</span><span>t2</span><span>,</span><span>id</span><span>+</span><span>1</span><span>]</span><span> </span><span>-&gt;</span><span> </span><span>reg</span><span>[</span><span>t1</span><span>]</span><span> </span><span>!=</span><span> </span><span>reg</span><span>[</span><span>t2</span><span>]</span><span>
  </span><span>));</span><span>

</span><span>% Nothing is live at end of block</span><span>
</span><span>constraint</span><span> </span><span>forall</span><span>(</span><span>t</span><span> </span><span>in</span><span> </span><span>temp_t</span><span>)(</span><span> </span><span>live_in</span><span>[</span><span>t</span><span>,</span><span> </span><span>MAXID</span><span>]</span><span> </span><span>=</span><span> </span><span>false</span><span>);</span><span>

</span><span>constraint</span><span> 
  </span><span>insn</span><span>(</span><span>0</span><span>,</span><span> </span><span>[</span><span>T1</span><span>],</span><span> </span><span>&#34;mov&#34;</span><span>,</span><span> </span><span>[</span><span>T0</span><span>])</span><span>     </span><span>/\</span><span>
  </span><span>insn</span><span>(</span><span>1</span><span>,</span><span> </span><span>[</span><span>T2</span><span>],</span><span> </span><span>&#34;add&#34;</span><span>,</span><span> </span><span>[</span><span>T0</span><span>,</span><span> </span><span>T1</span><span>])</span><span> </span><span>/\</span><span>
  </span><span>insn</span><span>(</span><span>2</span><span>,</span><span> </span><span>[</span><span>T3</span><span>],</span><span> </span><span>&#34;sub&#34;</span><span>,</span><span> </span><span>[</span><span>T0</span><span>,</span><span> </span><span>T1</span><span>])</span><span> </span><span>/\</span><span>
  </span><span>insn</span><span>(</span><span>3</span><span>,</span><span> </span><span>[</span><span>T4</span><span>],</span><span> </span><span>&#34;mul&#34;</span><span>,</span><span> </span><span>[</span><span>T1</span><span>,</span><span> </span><span>T2</span><span>])</span><span> </span><span>/\</span><span>
  </span><span>insn</span><span>(</span><span>4</span><span>,</span><span> </span><span>[</span><span>T5</span><span>],</span><span> </span><span>&#34;inc&#34;</span><span>,</span><span> </span><span>[</span><span>T4</span><span>]);</span><span>


</span><span>%reg = [T0: R2, T1: R0, T2: R1, T3: R2, T4: R0, T5: R0];</span><span>
</span><span>%live_in = </span><span>
</span><span>%[|         0:     1:     2:     3:     4:     5: </span><span>
</span><span>% | T0:  true,  true,  true, false, false, false</span><span>
</span><span>% | T1: false,  true,  true,  true, false, false</span><span>
</span><span>% | T2: false, false,  true,  true, false, false</span><span>
</span><span>% | T3: false, false, false, false, false, false</span><span>
</span><span>% | T4: false, false, false, false,  true, false</span><span>
</span><span>% | T5: false, false, false, false, false, false</span><span>
</span><span>% |];</span><span>
</span><span>%----------</span><span>

</span><span>% if we&#39;re not in ssa, maybe </span><span>
</span><span>% array[temp_t, id] of var reg_t; </span><span>
</span><span>% since register can change as reuse site.</span><span>

</span><span>% Registers don&#39;t allocate to same spot</span><span>
</span><span>%constraint forall (id in operation_t)(</span><span>
</span><span>%  forall(t1 in temp_t)(</span><span>
</span><span>%    forall(t2 in temp_t)(</span><span>
</span><span>%      (live_in[t1,id] /\ live_in[t2,id] /\ t1 != t2) -&gt;</span><span>
</span><span>%      reg[t1] != reg[t2]</span><span>
</span><span>%    )));</span><span>


</span></code></pre></div></div>

<p>How do you want to talk about the solution space.</p>

<ul>
  <li>a next(id1,id2) matrix</li>
  <li>live[id,t] matrix vs start end cycle integers.</li>
</ul>

<p>% since we don’t record the gen kill sets we need to do this in here.
<code>% next[i,j]</code> where you see <code>id + 1</code>
I was assuming SSA, but maybe it can handle non ssa? Noo. It probably can’t.</p>

<h3 id="scheduling-and-allocation">Scheduling and Allocation</h3>

<p>We can also use a next[i,j] matrix or change live to a start end cycle parameter.</p>

<h3 id="multiple-blocks">Multiple Blocks</h3>

<h3 id="register-packing">Register Packing</h3>

<p>Using the rectangle packing constraint for register modelling</p>

<h2 id="rewrite-rules">Rewrite Rules</h2>

<p>peephole optimization
<a href="https://github.com/bytecodealliance/wasmtime/blob/918671316301306d653345cc3486f0a15de2aa50/cranelift/docs/isle-integration.md">cranelift isle</a>
<a href="https://dl.acm.org/doi/pdf/10.1145/3428234">Verifying and Improving Halide’s Term Rewriting System with Program Synthesis</a></p>

<p>See: e-graphs
<a href="https://twitter.com/taktoa1/status/1531386684876632064?s=20&amp;t=-IHVNfpCMKlhva0T8ctWXA">scheduling using unimodular modelling</a></p>

<h2 id="instruction-selection-1">Instruction Selection</h2>

<p><a href="https://www.cs.tufts.edu/~nr/pubs/gentileset-abstract.html">Automatically Generating Back Ends Using Declarative Machine Descriptions</a> dias ramsey <a href="https://www.cs.tufts.edu/~nr/pubs/tiler-abstract.html">https://www.cs.tufts.edu/~nr/pubs/tiler-abstract.html</a></p>

<p><a href="https://www.cs.tufts.edu/~nr/pubs/hoopl-abstract.html">Hoopl</a></p>

<p>Maximal munch parsing
<a href="http://www.cs.cmu.edu/afs/cs/academic/class/15745-s07/www/lectures/lect9-instruction_selection_745.pdf">http://www.cs.cmu.edu/afs/cs/academic/class/15745-s07/www/lectures/lect9-instruction_selection_745.pdf</a>
Like parser generators / libraries, you can make instruction selection libraries / generators. Bottom up vs top down</p>

<ul>
  <li>
    <h2 id="twig-burg-beg-bottom-up-generate-instruction-selectors">TWIG BURG BEG bottom up generate instruction selectors</h2>
  </li>
</ul>

<p><a href="https://old.reddit.com/r/Compilers/comments/edgx5s/successors_to_iburg/">iburg</a> <a href="https://github.com/drh/iburg">https://github.com/drh/iburg</a> a code generator generator</p>

<p><a href="https://pp.ipd.kit.edu/uploads/publikationen/buchwald18cgo.pdf">Synthesizing an Instruction Selection Rule Library from Semantic Specifications</a></p>

<p>Subgraph isomorphism problem
VF2 algorithm
Very similar to “technology mapping” in the vlsi community.</p>



<p>Macro expansion</p>

<ul>
  <li>procede bottom up
Maximal Munch</li>
</ul>

<p>Instruction selection is taking a program and figuriing out which instructions can be used to implement this. Typically this leaves behind still some problems to solve, in particular register allocation and instruction scheduling. Presumably, everything in the program needs to be done. We have some notion of correspondence between the program representation and the available instructions. The exact nature of this correspondence depends on how we represent our program.</p>

<ul>
  <li>Sequence</li>
  <li>Tree - One representation of a program might be as a syntax tree, say <code>(x + (y * z))</code>.</li>
  <li>DAG - consider <code>(x + y) * (x + y)</code>. Really we want to note common shared computation and not recompute <code>x+ y</code> twice. DAGs and the technique of hash consing can be useful here.</li>
  <li>Tree-like DAGS</li>
  <li>CFG - A different representation might be to separate out blocks and control edges between them. Blocks consist of a sequence of statements.</li>
</ul>

<p>If the statements are purely for assignment, assignment can be inlined. The block is nearly purely functional in some sense. It can be compressed into a functional form like the DAG or Tree by inlining. The block could also itself be considered as a graph, as there is often more then one equivalent way of sequencing the instructions.</p>

<p>The simplest case to consider is that of the tree. We can enumerate patterns in the tree that we know how to implement using instructions. The relationship between tree patterns and instructions can be many-to-many. We should understand how to implement every node in the tree <code>(?a + ?b)</code>, <code>(?a * ?b)</code> with a pattern consisting of a sequence of instructions for completeness (ability to compile any tree). We also should try to figure out the tree patterns that correspond to a single assembly instruction like <code>load reg [reg+n]</code> because these will often be efficient and desirable.</p>

<p>There are two distinct and often separable problems here:</p>

<ol>
  <li>Find pattern matches</li>
  <li>Pick which matches to actually use aka pattern selection</li>
</ol>

<p>A direct approach to describing patterns is to develop a datatype of patterns. This datatype will be basically the datatype of your AST with holes. This is clearly duplication and becomes painful the more constructors your language has, but whatever.</p>

<div><div><pre><code><span>type</span> <span>ast</span> <span>=</span> <span>Add</span> <span>of</span> <span>ast</span> <span>*</span> <span>ast</span> <span>|</span> <span>Var</span> <span>of</span> <span>string</span>
<span>type</span> <span>ast_pat</span> <span>=</span> <span>Hole</span> <span>of</span> <span>string</span> <span>|</span> <span>PAdd</span> <span>of</span> <span>ast_pat</span> <span>*</span> <span>ast_pat</span> <span>|</span> <span>PVar</span> <span>of</span> <span>string</span>

<span>pmatch</span> <span>:</span> <span>ast_pat</span> <span>-&gt;</span> <span>ast</span> <span>-&gt;</span> <span>(</span><span>string</span> <span>*</span> <span>ast</span><span>)</span> <span>list</span> <span>option</span>
</code></pre></div></div>

<p>Alternatively, we can note that the main point of a pattern is to pattern match and use a church-ish/finalish representation</p>

<div><div><pre><code><span>type</span> <span>ast_pat&#39;</span> <span>=</span> <span>ast</span> <span>-&gt;</span> <span>(</span><span>string</span> <span>*</span> <span>ast</span><span>)</span> <span>list</span> <span>option</span>
<span>let</span> <span>convert_pat&#39;</span> <span>:</span> <span>ast_pat</span> <span>-&gt;</span> <span>ast_pat&#39;</span> <span>=</span> <span>pmatch</span>
</code></pre></div></div>

<div><div><pre><code><span>type</span> <span>var</span> <span>=</span> <span>string</span>
<span>type</span> <span>stmt</span> <span>=</span> <span>Ass</span> <span>of</span> <span>var</span> <span>*</span> <span>expr</span>
<span>type</span> <span>expr</span> <span>=</span> <span>Add</span> <span>of</span> <span>var</span> <span>*</span> <span>var</span> <span>|</span> <span>Var</span> <span>of</span> <span>var</span>

<span>type</span> <span>blk</span> <span>=</span> <span>stmt</span> <span>list</span>

<span>let</span> <span>inline</span> <span>:</span> <span>blk</span> <span>-&gt;</span> <span>(</span><span>var</span> <span>*</span> <span>ast</span><span>)</span> <span>list</span>
<span>type</span> <span>insn</span> <span>=</span> <span>Mov</span> <span>of</span> <span>reg</span> <span>*</span> <span>reg</span> <span>|</span> <span>Add</span> <span>of</span> <span>reg</span> <span>*</span> <span>reg</span> <span>|</span> <span>Add2</span> <span>of</span> <span>reg</span> <span>*</span> <span>reg</span> <span>*</span> <span>reg</span>


</code></pre></div></div>

<p>A novelty of the Blindell et al work is the notion of universal function (UF) graph. There is both the functinal repsentation of data values, but also cfg is represented as opaque nodes. The correspondence of where values are defined and where computations happen is left up to the constraint solver.</p>

<p>What is the input language? Is it a pure expression langage? A side effectful imperative language? We can convert between these.</p>

<p>I have directly gone to effectful assembly from pure expression language above.</p>

<p>I understand enough to have many questions. What is the input language over which one is pattern matching. Perhaps language is already the wrong word since language tends to imply something tree-like. Is it a pure language or an imperative language. Is it represented as a sequence of IR instructions, a tree, tree-like dag, dag,  a graph, or something else. Is represented too weak a word for this question which seems to be very important? “BIL” represented as a sequence vs as a graph might as well be nearly entirely different things. It seems totally possible to translate between pure and imperative, and between the representations and yet it matters so much. What is the output language. It structurally isn’t concrete assembly in many ways. It is definitely un-register allocated and probably unsequenced. Sometimes it feels like tree-like quasi assembly, where the node represents an “output” register even though assembly is really just a sequence of effects. Is there freedom to choose any N^2 combination of structural representations between input and output languages, purity and impurity?  None of this even starts to touch control flow. None of this touches what does “overlapping” of patterns mean and what should be allowed</p>

<p>Sequenced representation: Patterns may need to stretch over bits / reorderings. The sequence of the input language does not at all have to be the sequence of the output. Restricting yourself in this way</p>

<p>You can often macro repeat patterns in ways to undo any arbitrary choices made by the representation. Some kind of quotienting. If we have an order free representation, we could aebitrary sequence it, and then sequence the patterns into all possible sequencings. Then you end up with baically the same thing. You can’t go the other way in general.
There is something that feels galois connection-y here.</p>

<p>What is the output of pattern matching? Typically I would consider the output of a pattern match to be just pattern variable bindings. But in this case, really we may need full identification between pattern nodes and pattee nodes since this defines the covering.</p>

<p>There are different axes upon which to consider graph variations</p>

<ul>
  <li>input/output Edges ordered or unordered / have identity are interchangeable. AST tree have identity. Consider the example of a power or any non commutative operation. Edges with identities may want to be considered to be attached to “ports”</li>
  <li>Zero/many input output edges (trees)</li>
  <li>Labels on vertices and or edges</li>
</ul>

<p>Different kinds can be embedded in each other.
Trees can represent graphs if you are allowed to indirectly refer to nodes via labels.
Hash cons dags can have many input and output edges. However the output edges of the hash cons are unported, whereas the input edges are ported. The symmettry can be improved by using projection/port nodes connected to the output. In some sense the output of the original is then
Operads</p>

<p>You could take a relational perspective on operations, having neither input not output.</p>

<h2 id="register-allocation">Register Allocation</h2>

<p><a href="https://c9x.me/compile/bib/irc.pdf">iterated register coalescing - appell and george</a>
move edges are considered special because the can be coalesced (collapse the node in the interference graph)
nodes with less than number of register nighbors can be removed and you can construct a coloring
conservative coalescing -
constants can be spilled cheaply via rematerialization</p>

<p><a href="https://github.com/bytecodealliance/regalloc2/blob/main/doc/DESIGN.md">regallo2 design doc</a></p>

<p><a href="https://github.com/ocaml-flambda/flambda-backend/pull/678">flambda reg alloc</a> points to an <a href="https://dl.acm.org/doi/abs/10.1145/229542.229546">appell paper - iterated register coalescing</a> and tiger book
<a href="https://arxiv.org/abs/1804.02452">https://arxiv.org/abs/1804.02452</a></p>

<p><a href="https://cfallin.org/blog/2022/06/09/cranelift-regalloc2/">cranelift regalloc</a> great blog post</p>

<p><a href="https://link.springer.com/chapter/10.1007/978-3-540-72521-3_21#:~:text=Abstract,graph%20associated%20to%20the%20variables.">Register Allocation: What Does the NP-Completeness Proof of Chaitin et al. Really Prove? Or Revisiting Register Allocation: Why and How</a></p>

<p><a href="https://twitter.com/impraxical/status/1577321303400452100?s=20&amp;t=UJrepWvNkFpXFRNY8yoWDA">The Solid-State Register Allocator</a> <a href="https://www.mattkeeter.com/blog/2022-10-04-ssra/">https://www.mattkeeter.com/blog/2022-10-04-ssra/</a>
Belady’s OPT algorithm page faults</p>

<p><a href="http://polaris.cs.uiuc.edu/publications/guo-2003-old.pdf">The Power of Belady’s Algorithm in Register Allocation for Long Basic Blocks</a>
<a href="https://arxiv.org/abs/2011.05608">efficient global register allocation</a></p>

<p><a href="http://web.cs.ucla.edu/~palsberg/course/cs132/linearscan.pdf">linear scan register allocation</a></p>

<p>The typical starting point of register allocation is support you’ve been given as assembly program that doesn’t have registers filled in like</p>

<pre><code># input v1 v2 v3
mov v1, v2
add v1, v1
mul v3, v1
# output v3
</code></pre>

<p>The interference graph has an edge between any two variables that are live at the same time.
Live means that the variable has been made and someone still needs to use it now or later.
In this example, if we assume v1 v2 &amp; v3 are live at the beginning, v1 is live for all 3 instructions, v3 is live for all three and at the output, but v2 is only live at the first instruction since it is never used again.</p>

<p><a href="https://en.wikipedia.org/wiki/DSatur">dsatur graph coliring heurisitc</a></p>

<p><a href="https://twitter.com/johnregehr/status/1513561374873464833?s=20&amp;t=NBROMONLYyqlU8uerfss0A">RL4ReAl: Reinforcement Learning for Register Allocation</a>
Compiler gym</p>

<h2 id="instruction-scheduling">Instruction Scheduling</h2>

<p>The pure instruction scheduling problem might occur even at the IR level. We can imagine an imperative IR. Certain operations commute and others don’t. We may want to minimize the liveness time of variables for example. This would make sense as a pre-processing step to a sequence input language to an instruction selector.</p>

<p>Instruction scheduling can be parametrized as:</p>

<ol>
  <li>an embedding into actual time (cycle issue time probably). This is important if you are optimizing for runtime and can get estimates of how long each instruction takes.</li>
  <li>a ranking as integers</li>
  <li>next(i,j) relation which is basically integers. Allows for partial order. after(i,j) :- next(i,k), after(). after is path connected in temporal dag. Possibly this is mappable into a lattice notion of time (i,j,k,etc)?</li>
</ol>

<h2 id="superoptimizers">SuperOptimizers</h2>

<p><a href="https://en.wikipedia.org/wiki/Superoptimization">https://en.wikipedia.org/wiki/Superoptimization</a></p>

<p><a href="https://web.stanford.edu/class/cs343/resources/superoptimizer.pdf">Superoptimizer – A Look at the Smallest Program</a> Massalin
<a href="https://news.ycombinator.com/item?id=25196121">https://news.ycombinator.com/item?id=25196121</a> discussion</p>

<ul>
  <li>Souper <a href="https://github.com/google/souper">https://github.com/google/souper</a> <a href="https://arxiv.org/pdf/1711.04422.pdf">https://arxiv.org/pdf/1711.04422.pdf</a></li>
  <li>STOKE <a href="https://cs.stanford.edu/people/eschkufz/docs/asplos_13.pdf">https://cs.stanford.edu/people/eschkufz/docs/asplos_13.pdf</a></li>
  <li>TOAST an ASP based one? <a href="https://purehost.bath.ac.uk/ws/portalfiles/portal/187949093/UnivBath_PhD_2009_T_Crick.pdf">https://purehost.bath.ac.uk/ws/portalfiles/portal/187949093/UnivBath_PhD_2009_T_Crick.pdf</a></li>
  <li>
    <h2 id="gso-gnu-superoptimizer">GSO gnu superoptimizer</h2>
  </li>
</ul>

<p><a href="https://twitter.com/kripken/status/1564754007289057280?s=20&amp;t=KWXpxw5bjeXiDnNeX75ogw">https://twitter.com/kripken/status/1564754007289057280?s=20&amp;t=KWXpxw5bjeXiDnNeX75ogw</a> Zakai binaryen superopitmizer</p>

<h2 id="compiling-with-constraints-i">Compiling with Constraints I</h2>

<p>Hey Hey! We’ve open sourced our project <a href="https://github.com/draperlaboratory/VIBES">VIBES</a> (Verified, Incremental Binary Editing with Synthesis).</p>

<p>A compiler can be a complicated thing. Often we break up and approach the problem by breaking it into pieces. The front end takes text and converts it to a tree. In turn it is often converted to some kind of intermediate representation, say a control flow graph. The middle end performs rearrangements and analyses on this graph. The back end is in charge of taking this intermediate representation and bringing it to executable machine code.</p>

<p>The backend of a compiler has a number of different problems</p>

<ol>
  <li>Instruction Selection - Take <code>x := a + b</code> and turn it into <code>mov x, a; add x,b</code></li>
  <li>Register Allocation - Take <code>add x,a</code> and turn it into <code>add R0, R1</code></li>
  <li>Instruction Scheduling - Rearrange instructions to maximize throughput of CPU. Internally cpu has pipelines and resources, store and loads to memory are slow, you want to make sure these are chugging along and interleaved well.</li>
</ol>

<p>Typically, these will be run one after the other in some order, with greedy-ish algorithms and hand tuned code. This works pretty well and is fast to compile.
It does leave performance and size of the resulting code on the table.
The Unison approach is trying to build a non toy compiler that uses declarative constraint programming to solve these in concert.
Now any optimization is only as good as our modelling of the situation. This is one of the common fallacies of godhood people get when they think about applying math to problems. If your model of the cpu is coarse, then perfectly optimizing with respect to this . Ultimately, every ahead of time model is bad because it must be unable to know information that is readily accessible at runtime. This is at least one reason why without experimentation and measurement, you really can’t tell whether crass online optimization can deliver superior results to thorough ahead of time optimization. See for example JITs, branch prediction, VLIW architectures, out of order execution.</p>

<p>Can I write CFG programs directly in minizinc in a good way?
Would avoid 1 indirection or going in and out of a language</p>

<p>Declarative Solving for Compiler Backends using Minizinc
Unison-style Compiler backends</p>

<p>Declarative compilation</p>

<p><a href="https://arxiv.org/pdf/1804.02452.pdf">Combinatorial Register Allocation and Instruction Scheduling</a></p>

<p>Schulte course on constraint programming
<a href="https://kth.instructure.com/courses/7669/files/folder/lectures">https://kth.instructure.com/courses/7669/files/folder/lectures</a>?
on compilers
<a href="https://kth.instructure.com/courses/6414/files">https://kth.instructure.com/courses/6414/files</a></p>



<p>In any case we are embedding a liveness analysis into minizinc.
live(t,i) = true/false
next(i1,i2) = true/false
next forms total order.</p>

<p>[after(i,k)  &lt;- next(i,j), after(j,k) for i,j,k in insns]
[after(i,k) &lt;-&gt; exists(j in insn)( next(i,j) /\  after(j,k)) \/ next(i,k) forall i,k ]
[live[insn, temp] &lt;- ]</p>



<p>The pure instruction scheduling problem might occur even at the IR level. We can imagine an imperative IR. Certain operations commute and others don’t. We may want to minimize the liveness time of variables for example. This would make sense as a pre-processing step to a sequence input language to an instruction selector.</p>

<p>Instruction scheduling can be parametrized as:</p>

<ol>
  <li>an embedding into actual time (cycle issue time probably). This is important if you are optimizing for runtime and can get estimates of how long each instruction takes.</li>
  <li>a ranking as integers</li>
  <li>next(i,j) relation which is basically integers. Allows for partial order. after(i,j) :- next(i,k), after(). after is path connected in temporal dag. Possibly this is mappable into a lattice notion of time (i,j,k,etc)?</li>
</ol>

<p>Instruction matching as an SMT problem</p>

<p>Why is there such an impulse to model these problems in a purely functional style? Invariably we need to introduce a state threading.</p>

<p>Dataflow analysis with Datalog.
I should lay out what I understand of the unison compiler.</p>

<p>Register Packing
Instruction Scheduling1</p>

<p>The box model</p>

<p>Christian Schulte course</p>



<p>simple</p>

<div><div><pre><code><span>include</span><span> </span><span>&#34;alldifferent.mzn&#34;</span><span>;</span><span>
</span><span>include</span><span> </span><span>&#34;all_equal.mzn&#34;</span><span>;</span><span>
</span><span>include</span><span> </span><span>&#34;diffn.mzn&#34;</span><span>;</span><span>

</span><span>set</span><span> </span><span>of</span><span> </span><span>int</span><span> </span><span>:</span><span> </span><span>reg_t</span><span> </span><span>=</span><span> </span><span>1</span><span>..</span><span>4</span><span>;</span><span>
</span><span>set</span><span> </span><span>of</span><span> </span><span>int</span><span> </span><span>:</span><span> </span><span>temp_t</span><span> </span><span>=</span><span> </span><span>1</span><span>..</span><span>10</span><span>;</span><span>
</span><span>set</span><span> </span><span>of</span><span> </span><span>int</span><span> </span><span>:</span><span> </span><span>instr_t</span><span> </span><span>=</span><span> </span><span>1</span><span>..</span><span>10</span><span>;</span><span>
</span><span>array</span><span>[</span><span>temp_t</span><span>]</span><span> </span><span>of</span><span> </span><span>var</span><span> </span><span>reg_t</span><span> </span><span>:</span><span> </span><span>reg</span><span>;</span><span>
</span><span>array</span><span>[</span><span>temp_t</span><span>]</span><span> </span><span>of</span><span> </span><span>var</span><span> </span><span>instr_t</span><span> </span><span>:</span><span> </span><span>def</span><span>;</span><span>
</span><span>array</span><span>[</span><span>temp_t</span><span>]</span><span> </span><span>of</span><span> </span><span>var</span><span> </span><span>instr_t</span><span> </span><span>:</span><span> </span><span>death</span><span>;</span><span>
</span><span>/*
There is a possible off by one error
is death at the last use site, or is it the instruction after
Let&#39;s say it is the last use site.
Or rather should we be thinking of program points between instructions


*/</span><span>



</span><span>%constraint alldifferent(def);</span><span>

</span><span>predicate</span><span> </span><span>insn</span><span>(</span><span>array</span><span>[</span><span>int</span><span>]</span><span> </span><span>of</span><span> </span><span>var</span><span> </span><span>temp_t</span><span> </span><span>:</span><span> </span><span>defs</span><span>,</span><span> </span><span>string</span><span>:</span><span> </span><span>operator</span><span>,</span><span>  </span><span>array</span><span>[</span><span>int</span><span>]</span><span> </span><span>of</span><span> </span><span>var</span><span> </span><span>temp_t</span><span> </span><span>:</span><span> </span><span>uses</span><span>)</span><span> </span><span>=</span><span>
    </span><span>all_equal</span><span>([</span><span>def</span><span>[</span><span>t</span><span>]</span><span> </span><span>|</span><span> </span><span>t</span><span> </span><span>in</span><span> </span><span>defs</span><span> </span><span>]</span><span> </span><span>)</span><span>
    </span><span>/* 
         forall(t2 in defs)(
             def[t1] = def[t2]
        ) */</span><span>
        </span><span>/\</span><span>
        </span><span>forall</span><span>(</span><span> </span><span>t1</span><span> </span><span>in</span><span> </span><span>defs</span><span>)(</span><span>
        </span><span>forall</span><span> </span><span>(</span><span>t2</span><span> </span><span>in</span><span> </span><span>uses</span><span>)</span><span> </span><span>(</span><span>
            </span><span>def</span><span>[</span><span>t1</span><span>]</span><span> </span><span>&gt;</span><span> </span><span>def</span><span>[</span><span>t2</span><span>]</span><span> </span><span>/\</span><span> </span><span>death</span><span>[</span><span>t2</span><span>]</span><span> </span><span>&gt;=</span><span> </span><span>def</span><span>[</span><span>t1</span><span>]</span><span>
        </span><span>)</span><span>
    </span><span>);</span><span>

</span><span>% redundant?</span><span>
</span><span>constraint</span><span> </span><span>forall</span><span>(</span><span>t</span><span> </span><span>in</span><span> </span><span>temp_t</span><span>)(</span><span>
    </span><span>def</span><span>[</span><span>t</span><span>]</span><span> </span><span>&lt;=</span><span> </span><span>death</span><span>[</span><span>t</span><span>]</span><span>
</span><span>);</span><span>

</span><span>%output [&#34;foo&#34; | t in temp_t];</span><span>
</span><span>constraint</span><span> </span><span>diffn</span><span>(</span><span> </span><span>reg</span><span>,</span><span> </span><span>def</span><span> </span><span>,</span><span> </span><span>[</span><span>1</span><span> </span><span>|</span><span> </span><span>t</span><span> </span><span>in</span><span> </span><span>temp_t</span><span>],</span><span> </span><span>[</span><span> </span><span>death</span><span>[</span><span>t</span><span>]</span><span> </span><span>-</span><span> </span><span>def</span><span>[</span><span>t</span><span>]</span><span> </span><span>|</span><span> </span><span>t</span><span> </span><span>in</span><span> </span><span>temp_t</span><span> </span><span>]</span><span> </span><span>);</span><span>
</span><span>%constraint diffn( reg, def ,  reg, [ death[t] - def[t] | t in temp_t ] );</span><span>
</span><span>/* 
We can&#39;t do it this way because alldifferent takes a compile time array.
We could do this if we had a set of dummy values,
Or if we ahead of time fixed the instruction ordering.
If wwe did that, liveness analysis might need to be done out of minizinc.

constraint forall( i in instr_t)(
    alldifferent(  [ reg[t]   | t in temp_t where i &lt; death[t] /\  def[t] &lt; i ]    )
); */</span><span>

</span><span>constraint</span><span> </span><span>insn</span><span>(</span><span> </span><span>[</span><span>3</span><span>],</span><span> </span><span>&#34;add&#34;</span><span>,</span><span> </span><span>[</span><span>1</span><span>,</span><span>2</span><span>]</span><span> </span><span>);</span><span>
</span><span>constraint</span><span> </span><span>insn</span><span>(</span><span> </span><span>[</span><span>4</span><span>],</span><span> </span><span>&#34;sub&#34;</span><span>,</span><span> </span><span>[</span><span>1</span><span>,</span><span>3</span><span>]</span><span> </span><span>);</span><span>

</span><span>solve</span><span> </span><span>minimize</span><span> </span><span>card</span><span>(</span><span>array2set</span><span>(</span><span>reg</span><span>));</span><span>
</span></code></pre></div></div>

<p>ordered</p>

<div><div><pre><code><span>include</span><span> </span><span>&#34;alldifferent.mzn&#34;</span><span>;</span><span>
</span><span>/*

This file shows register allocation if we prefix the instruction order.

*/</span><span>
</span><span>set</span><span> </span><span>of</span><span> </span><span>int</span><span> </span><span>:</span><span> </span><span>reg_t</span><span> </span><span>=</span><span> </span><span>1</span><span>..</span><span>4</span><span>;</span><span>
</span><span>set</span><span> </span><span>of</span><span> </span><span>int</span><span> </span><span>:</span><span> </span><span>temp_t</span><span> </span><span>=</span><span> </span><span>1</span><span>..</span><span>4</span><span>;</span><span>
</span><span>%set of int : instr_t = 1..10;</span><span>
</span><span>array</span><span>[</span><span>temp_t</span><span>]</span><span> </span><span>of</span><span> </span><span>var</span><span> </span><span>reg_t</span><span> </span><span>:</span><span> </span><span>reg</span><span>;</span><span>
</span><span>%array[temp_t] of var instr_t : def;</span><span>
</span><span>%array[temp_t] of var instr_t : death;</span><span>
</span><span>enum</span><span> </span><span>inout</span><span> </span><span>=</span><span> </span><span>{</span><span>Out</span><span>,</span><span> </span><span>In</span><span>};</span><span>
</span><span>set</span><span> </span><span>of</span><span> </span><span>int</span><span> </span><span>:</span><span> </span><span>instr_t</span><span> </span><span>=</span><span> </span><span>1</span><span>..</span><span>4</span><span>;</span><span>
</span><span>array</span><span>[</span><span>instr_t</span><span>,</span><span>inout</span><span>]</span><span> </span><span>of</span><span> </span><span>set</span><span> </span><span>of</span><span> </span><span>temp_t</span><span> </span><span>:</span><span> </span><span>instrs</span><span> </span><span>=</span><span>
   </span><span>[|</span><span>
    </span><span>{</span><span>1</span><span>,</span><span>2</span><span>},</span><span> </span><span>{}</span><span>  </span><span>|</span><span>
    </span><span>{</span><span>3</span><span>},</span><span> </span><span>{</span><span>1</span><span>,</span><span>2</span><span>}</span><span> </span><span>|</span><span>
    </span><span>{</span><span>4</span><span>},</span><span> </span><span>{</span><span>2</span><span>,</span><span>3</span><span>}</span><span> </span><span>|</span><span>
    </span><span>{},</span><span>  </span><span>{</span><span>1</span><span>,</span><span>4</span><span>}</span><span>
   </span><span>|];</span><span>

</span><span>array</span><span>[</span><span>temp_t</span><span>]</span><span> </span><span>of</span><span> </span><span>int</span><span> </span><span>:</span><span> </span><span>def</span><span> </span><span>=</span><span>
   </span><span>[</span><span> </span><span>min</span><span>([</span><span> </span><span>i</span><span>  </span><span>|</span><span> </span><span>i</span><span> </span><span>in</span><span> </span><span>instr_t</span><span> </span><span>where</span><span> </span><span>t</span><span> </span><span>in</span><span> </span><span>instrs</span><span>[</span><span>i</span><span>,</span><span>Out</span><span>]</span><span> </span><span>])</span><span>  </span><span>|</span><span> </span><span>t</span><span> </span><span>in</span><span> </span><span>temp_t</span><span> </span><span>]</span><span> </span><span>;</span><span>

</span><span>array</span><span>[</span><span>temp_t</span><span>]</span><span> </span><span>of</span><span> </span><span>int</span><span> </span><span>:</span><span> </span><span>death</span><span> </span><span>=</span><span>
   </span><span>[</span><span> </span><span>max</span><span>([</span><span> </span><span>i</span><span>  </span><span>|</span><span> </span><span>i</span><span> </span><span>in</span><span> </span><span>instr_t</span><span> </span><span>where</span><span> </span><span>t</span><span> </span><span>in</span><span> </span><span>instrs</span><span>[</span><span>i</span><span>,</span><span>In</span><span>]</span><span> </span><span>\/</span><span> </span><span>t</span><span> </span><span>in</span><span> </span><span>instrs</span><span>[</span><span>i</span><span>,</span><span>Out</span><span>]</span><span>  </span><span>])</span><span>  </span><span>|</span><span> </span><span>t</span><span> </span><span>in</span><span> </span><span>temp_t</span><span> </span><span>];</span><span>

</span><span>constraint</span><span> </span><span>forall</span><span>(</span><span> </span><span>i</span><span> </span><span>in</span><span> </span><span>instr_t</span><span>)(</span><span>
    </span><span>alldifferent</span><span>(</span><span>  </span><span>[</span><span> </span><span>reg</span><span>[</span><span>t</span><span>]</span><span>   </span><span>|</span><span> </span><span>t</span><span> </span><span>in</span><span> </span><span>temp_t</span><span> </span><span>where</span><span> </span><span>i</span><span> </span><span>&lt;=</span><span> </span><span>death</span><span>[</span><span>t</span><span>]</span><span> </span><span>/\</span><span>  </span><span>def</span><span>[</span><span>t</span><span>]</span><span> </span><span>&lt;</span><span> </span><span>i</span><span> </span><span>]</span><span>    </span><span>)</span><span>
</span><span>);</span><span>
</span></code></pre></div></div>

<p>Something like a finally tagless style encoding of block?
But I’d also like the same of insn
Side effectful functions?
Ok. So I want</p>

<div><div><pre><code><span>
</span><span>predicate</span><span> </span><span>block</span><span>(</span><span>string</span><span> </span><span>:</span><span> </span><span>name</span><span>,</span><span> </span><span>set</span><span>[</span><span>temp_t</span><span>]</span><span> </span><span>:</span><span> </span><span>ins</span><span>,</span><span> </span><span>set</span><span> </span><span>of</span><span> </span><span>[</span><span>temp_t</span><span>]</span><span> </span><span>:</span><span> </span><span>outs</span><span>,</span><span> </span><span>array</span><span>[</span><span>int</span><span>]</span><span> </span><span>of</span><span> </span><span>insn</span><span> </span><span>:</span><span> </span><span>data</span><span>,</span><span> </span><span>array</span><span>[</span><span>int</span><span> </span><span>of</span><span> </span><span>insns</span><span> </span><span>:</span><span> </span><span>data</span><span>]</span><span> </span><span>:</span><span> </span><span>ctrl</span><span>)</span><span>

</span></code></pre></div></div>

<div><div><pre><code><span>@</span><span>dataclass</span>
<span>class</span> <span>Block</span><span>:</span>
    <span>name</span><span>:</span> <span>str</span>
    <span>ins</span><span>:</span> <span>List</span><span>[</span><span>&#34;RegSort&#34;</span><span>]</span>
    <span>prog</span><span>:</span> <span>Prog</span>
    <span>outs</span><span>:</span> <span>List</span><span>[</span><span>&#34;RegSort&#34;</span><span>]</span>

<span># operation = (name, out, ins)
</span>

<span>run</span><span>(</span><span>prog</span><span>)</span>


<span>def</span> <span>peephole</span><span>(</span><span>prog</span><span>):</span>
    <span>out_prog</span> <span>=</span> <span>[]</span>
    <span>for</span> <span>op</span><span>,</span> <span>out</span><span>,</span> <span>in_ops</span> <span>in</span> <span>prog</span><span>:</span>
        <span>if</span> <span>op</span> <span>==</span> <span>&#34;mov&#34;</span> <span>and</span> <span>len</span><span>(</span><span>in_ops</span><span>)</span> <span>==</span> <span>1</span> <span>and</span> <span>in_ops</span><span>[</span><span>0</span><span>]</span> <span>==</span> <span>out</span><span>:</span> <span># fuse out redundant movs
</span>            <span>continue</span>
        <span>out_prog</span><span>.</span><span>append</span><span>((</span><span>op</span><span>,</span> <span>out</span><span>,</span> <span>in_ops</span><span>))</span>


<span>#[(op,outs, ins)]
</span>

<span>Expr</span> <span>=</span> <span>Tuple</span><span>[</span><span>Op</span><span>,</span> <span>Any</span><span>]</span>

<span>def</span> <span>simp</span><span>(</span><span>expr</span><span>):</span>
    
<span>def</span> <span>isel_stmt</span><span>(</span><span>stmt</span><span>):</span>

<span>def</span> <span>isel_expr</span><span>(</span><span>expr</span><span>):</span>
    <span>match</span> <span>expr</span><span>:</span>
        <span>case</span> <span>(</span><span>&#34;add&#34;</span><span>,</span> <span>x</span><span>,</span> <span>y</span><span>):</span>
        <span>case</span> <span>(</span><span>&#34;mul&#34;</span><span>,</span> <span>x</span><span>,</span> <span>y</span><span>):</span>
        <span>case</span> <span>(</span><span>&#34;neg&#34;</span><span>,</span> <span>x</span><span>):</span>
        <span>case</span> <span>(</span><span>&#34;load&#34;</span><span>,</span> <span>x</span><span>):</span>
        
<span>def</span> <span>eval</span><span>(</span><span>env</span><span>,</span> <span>block</span><span>):</span>
    <span>for</span> <span>(</span><span>op</span><span>,</span> <span>outs</span><span>,</span> <span>ins</span><span>)</span> <span>in</span> <span>reversed</span><span>(</span><span>block</span><span>):</span>
        <span>pass</span>


</code></pre></div></div>

  </div>
</article>

      </div>
    </div></div>
  </body>
</html>
