<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.linusakesson.net/programming/tty/">Original</a>
    <h1>The TTY Demystified (2008)</h1>
    
    <div id="readability-page-1" class="page"><div><div><div>


<div>
<p><img src="https://www.linusakesson.net/programming/tty/oldschool.jpg" alt="Teletypes"/></p><p>Real teletypes in the 1940s.</p>
</div>

<p><span>The TTY subsystem is central to the design of Linux, and UNIX in general.
Unfortunately, its importance is often overlooked, and it is difficult to find
good introductory articles about it. I believe that a basic understanding of
TTYs in Linux is essential for the developer and the advanced user.</span></p>

<p>Beware, though: What you are about to see is not particularly elegant. In
fact, the TTY subsystem — while quite functional from a user&#39;s point of
view — is a twisty little mess of special cases. To understand how this
came to be, we have to go back in time.</p>

<h2>History</h2>

<p>In 1869, the <i>stock ticker</i> was invented. It was an electro-mechanical
machine consisting of a typewriter, a long pair of wires and a ticker tape
printer, and its purpose was to distribute stock prices over long distances in
realtime. This concept gradually evolved into the faster, ASCII-based
<i>teletype</i>. Teletypes were once connected across the world in a large
network, called <i>Telex</i>, which was used for transferring commercial
telegrams, but the teletypes weren&#39;t connected to any computers yet.</p>

<p>Meanwhile, however, the computers — still quite large and
primitive, but able to multitask — were becoming powerful enough to be
able to interact with users in realtime. When the command line eventually
replaced the old batch processing model, teletypes were used as input and
output devices, because they were readily available on the market.</p>

<p>There was a plethora of teletype models around, all slightly different, so
some kind of software compatibility layer was called for. In the UNIX world,
the approach was to let the operating system kernel handle all the low-level
details, such as word length, baud rate, flow control, parity, control codes
for rudimentary line editing and so on. Fancy cursor movements, colour output
and other advanced features made possible in the late 1970s by solid state
<i>video terminals</i> such as the VT-100, were left to the applications.</p>

<p>In present time, we find ourselves in a world where physical teletypes and
video terminals are practically extinct. Unless you visit a museum or a
hardware enthusiast, all the TTYs you&#39;re likely to see will be emulated video
terminals — software simulations of the real thing. But as we shall
see, the legacy from the old cast-iron beasts is still lurking beneath the
surface.</p>

<h2>The use cases</h2>

<p><img src="https://www.linusakesson.net/programming/tty/case1.png" alt="Diagram"/></p><p>A user types at a terminal (a physical teletype). This terminal is connected
through a pair of wires to a <i>UART</i> (Universal Asynchronous Receiver and
Transmitter) on the computer. The operating system contains a <i>UART driver</i> which
manages the physical transmission of bytes, including parity checks and flow
control. In a naïve system, the UART driver would then deliver the incoming
bytes directly to some application process. But such an approach would lack the
following essential features:</p>

<p><b>Line editing.</b> Most users make mistakes while typing, so a backspace
key is often useful. This could of course be implemented by the applications
themselves, but in accordance with the UNIX design philosophy, applications
should be kept as simple as possible. So as a convenience, the operating system
provides an editing buffer and some rudimentary editing commands (backspace,
erase word, clear line, reprint), which are enabled by default inside the
<i>line discipline</i>. Advanced applications may disable these features by
putting the line discipline in <i>raw</i> mode instead of the default
<i>cooked</i> (or <i>canonical</i>) mode. Most interactive applications
(editors, mail user agents, shells, all programs relying on <tt>curses</tt> or
<tt>readline</tt>) run in raw mode, and handle all the line editing commands
themselves. The line discipline also contains options for character echoing and
automatic conversion between carriage returns and linefeeds. Think of it as a
primitive kernel-level <tt>sed(1)</tt>, if you like.</p>

<p>Incidentally, the kernel provides several different line disciplines. Only
one of them is attached to a given serial device at a time. The default
discipline, which provides line editing, is called <tt>N_TTY</tt>
(<tt>drivers/char/n_tty.c</tt>, if you&#39;re feeling adventurous). Other
disciplines are used for other purposes, such as managing packet switched data
(ppp, IrDA, serial mice), but that is outside the scope of this article.</p>

<p><b>Session management.</b> The user probably wants to run several programs
simultaneously, and interact with them one at a time. If a program goes into an
endless loop, the user may want to kill it or suspend it. Programs that are
started in the background should be able to execute until they try to write to
the terminal, at which point they should be suspended. Likewise, user input
should be directed to the foreground program only. The operating system
implements these features in the <i>TTY driver</i>
(<tt>drivers/char/tty_io.c</tt>).</p>

<p>An operating system process is &#34;alive&#34; (has an <i>execution context</i>),
which means that it can perform actions. The TTY driver is not alive; in object oriented
terminology, the TTY driver is a passive object. It has some data fields and some
methods, but the only way it can actually do something is when one of its
methods gets called from the context of a process or a kernel interrupt
handler. The line discipline is likewise a passive entity.</p>

<p>Together, a particular triplet of UART driver, line discipline instance and
TTY driver may be referred to as a <i>TTY device</i>, or sometimes just TTY. A
user process can affect the behaviour of any TTY device by manipulating the
corresponding device file under <tt>/dev</tt>. Write permissions to the device
file are required, so when a user logs in on a particular TTY, that user must
become the owner of the device file. This is traditionally done by the
<tt>login(1)</tt> program, which runs with root privileges.</p>

<p>The physical line in the previous diagram could of course be a long-distance
phone line:</p>

<p><img src="https://www.linusakesson.net/programming/tty/case2.png" alt="Diagram"/></p><p>This does not change much, except that the system now has to handle a modem
hangup situation as well.</p>

<p>Let&#39;s move on to a typical desktop system. This is how the Linux console
works:</p>

<p><img src="https://www.linusakesson.net/programming/tty/case3.png" alt="Diagram"/></p><p>The TTY driver and line discipline behave just like in the previous
examples, but there is no UART or physical terminal involved anymore. Instead,
a video terminal (a complex state machine including a <i>frame buffer</i> of
characters and graphical character attributes) is emulated in software, and
rendered to a VGA display.</p>

<p>The console subsystem is somewhat rigid. Things get more flexible (and
abstract) if we move the terminal emulation into userland. This is how
<tt>xterm(1)</tt> and its clones work:</p>

<p><img src="https://www.linusakesson.net/programming/tty/case4.png" alt="Diagram"/></p><p>To facilitate moving the terminal emulation into userland, while still
keeping the TTY subsystem (session management and line discipline) intact, the
<i>pseudo terminal</i> or <i>pty</i> was invented. And as you may have guessed,
things get even more complicated when you start running pseudo terminals
inside pseudo terminals, à la <tt>screen(1)</tt> or <tt>ssh(1)</tt>.</p>

<p>Now let&#39;s take a step back and see how all of this fits into the
process model.</p>

<h2>Processes</h2>

<p>A Linux process can be in one of the following states:</p>

<p><img src="https://www.linusakesson.net/programming/tty/linuxprocess.png" alt="Process states"/></p><table>
<tbody><tr><td>R</td><td>Running or runnable (on run queue)</td></tr>
<tr><td>D</td><td>Uninterruptible sleep (waiting for some event)</td></tr>
<tr><td>S</td><td>Interruptible sleep (waiting for some event or signal)</td></tr>
<tr><td>T</td><td>Stopped, either by a job control signal or because it is being traced by a debugger.</td></tr>
<tr><td>Z</td><td>Zombie process, terminated but not yet reaped by its parent.</td></tr>
</tbody></table>

<p>By running <tt>ps l</tt>, you can see which processes are running, and which are
sleeping. If a process is sleeping, the <tt>WCHAN</tt> column (&#34;wait channel&#34;, the name
of the wait queue) will tell you what kernel event the process is waiting for.</p>

<div>
<pre>$ ps l
F   UID   PID  PPID PRI  NI    VSZ   RSS WCHAN  STAT TTY        TIME COMMAND
0   500  5942  5928  15   0  12916  1460 wait   Ss   pts/14     0:00 -/bin/bash
0   500 12235  5942  15   0  21004  3572 wait   S+   pts/14     0:01 vim index.php
0   500 12580 12235  15   0   8080  1440 wait   S+   pts/14     0:00 /bin/bash -c (ps l) &gt;/tmp/v727757/1 2&gt;&amp;1
0   500 12581 12580  15   0   4412   824 -      R+   pts/14     0:00 ps l
</pre>
</div>

<p>The &#34;<tt>wait</tt>&#34; wait queue corresponds to the <tt>wait(2)</tt> syscall,
so these processes will be moved to the running state whenever there&#39;s a state change in one of their
child processes. There are two sleeping states: Interruptible
sleep and uninterruptible sleep. Interruptible sleep (the most common case)
means that while the process is part of a wait queue, it may actually also be
moved to the running state when a signal is sent to it. If you look inside the
kernel source code, you will find that any kernel code which is waiting for an
event must check if a signal is pending after schedule() returns, and abort the
syscall in that case.</p>

<p>
In the <tt>ps</tt> listing above, the <tt>STAT</tt> column displays the current state of each
process. The same column may also contain one or more attributes, or flags:
</p>

<table>
<tbody><tr><td>s</td><td>This process is a session leader.</td></tr>
<tr><td>+</td><td>This process is part of a foreground process group.</td></tr>
</tbody></table>

<p>These attributes are used for job control.</p>

<h2>Jobs and sessions</h2>

<p>Job control is what happens when you press <tt>^Z</tt> to suspend a program,
or when you start a program in the background using <tt>&amp;</tt>. A job is
the same as a process group. Internal shell commands like <tt>jobs</tt>,
<tt>fg</tt> and <tt>bg</tt> can be used to manipulate the existing jobs within
a <i>session</i>. Each session is managed by a <i>session leader</i>, the
shell, which is cooperating tightly with the kernel using a complex protocol of
signals and system calls.</p>

<p>The following example illustrates the relationship between processes, jobs
and sessions:</p>

<h3>The following shell interactions...</h3>

<p><img src="https://www.linusakesson.net/programming/tty/exampleterm.png" alt="Screenshot"/></p><h3>...correspond to these processes...</h3>

<p><img src="https://www.linusakesson.net/programming/tty/examplediagram.png" alt="Table"/></p><h3>...and these kernel structures.</h3>

<ul>
<li>TTY Driver (<tt>/dev/pts/0</tt>).

<pre>Size: 45x13
Controlling process group: (101)
Foreground process group: (103)
UART configuration (ignored, since this is an xterm):
  Baud rate, parity, word length and much more.
Line discipline configuration:
  cooked/raw mode, linefeed correction,
  meaning of interrupt characters etc.
Line discipline state:
  edit buffer (currently empty),
  cursor position within buffer etc.
</pre>

</li>

<li>pipe0

<pre>Readable end (connected to PID 104 as file descriptor 0)
Writable end (connected to PID 103 as file descriptor 1)
Buffer
</pre>

</li>
</ul>

<p>The basic idea is that every pipeline is a job, because every process in a
pipeline should be manipulated (stopped, resumed, killed) simultaneously.
That&#39;s why <tt>kill(2)</tt> allows you to send signals to entire process
groups. By default, <tt>fork(2)</tt> places a newly created child process in
the same process group as its parent, so that e.g. a <tt>^C</tt> from the
keyboard will affect both parent and child. But the shell, as part of its
session leader duties, creates a new process group every time it
launches a pipeline.</p>

<p>The TTY driver keeps track of the foreground process group id, but only in a
passive way. The session leader has to update this information explicitly when
necessary. Similarly, the TTY driver keeps track of the size of the connected
terminal, but this information has to be updated explicitly, by the terminal
emulator or even by the user.</p>

<p>As you can see in the diagram above, several processes have
<tt>/dev/pts/0</tt> attached to their standard input. But only the foreground
job (the <tt>ls | sort</tt> pipeline) will receive input from the
TTY. Likewise, only the foreground job will be allowed to write to the TTY
device (in the default configuration). If the cat process were to attempt to
write to the TTY, the kernel would suspend it using a signal.</p>

<h2>Signal madness</h2>

<p>Now let&#39;s take a closer look at how the TTY drivers, the line disciplines
and the UART drivers in the kernel communicate with the userland processes.</p>

<p>UNIX files, including the TTY device file, can of course be read from and
written to, and further manipulated by means of the magic <tt>ioctl(2)</tt> call (the Swiss
army-knife of UNIX) for which lots of TTY related operations have been defined.
Still, <tt>ioctl</tt> requests have to be initiated from processes, so they can&#39;t be
used when the kernel needs to communicate <i>asynchronously</i> with an
application.</p>

<p>In <i>The Hitchhiker&#39;s Guide to the Galaxy</i>, Douglas Adams mentions an
extremely dull planet, inhabited by a bunch of depressed humans and a certain breed
of animals with sharp teeth which communicate with the humans by biting them
very hard in the thighs. This is strikingly similar to UNIX, in which the kernel
communicates with processes by sending paralyzing or deadly signals to them.
Processes may intercept some of the signals, and try to adapt to the situation,
but most of them don&#39;t.</p>

<p>So a signal is a crude mechanism that allows the kernel to communicate
asynchronously with a process. Signals in UNIX aren&#39;t clean or general; rather,
each signal is unique, and must be studied individually.</p>

<p>You can use the command <tt>kill -l</tt> to see which signals your system implements.
This is what it may look like:</p>

<pre>$ kill -l
 1) SIGHUP	 2) SIGINT	 3) SIGQUIT	 4) SIGILL
 5) SIGTRAP	 6) SIGABRT	 7) SIGBUS	 8) SIGFPE
 9) SIGKILL	10) SIGUSR1	11) SIGSEGV	12) SIGUSR2
13) SIGPIPE	14) SIGALRM	15) SIGTERM	16) SIGSTKFLT
17) SIGCHLD	18) SIGCONT	19) SIGSTOP	20) SIGTSTP
21) SIGTTIN	22) SIGTTOU	23) SIGURG	24) SIGXCPU
25) SIGXFSZ	26) SIGVTALRM	27) SIGPROF	28) SIGWINCH
29) SIGIO	30) SIGPWR	31) SIGSYS	34) SIGRTMIN
35) SIGRTMIN+1	36) SIGRTMIN+2	37) SIGRTMIN+3	38) SIGRTMIN+4
39) SIGRTMIN+5	40) SIGRTMIN+6	41) SIGRTMIN+7	42) SIGRTMIN+8
43) SIGRTMIN+9	44) SIGRTMIN+10	45) SIGRTMIN+11	46) SIGRTMIN+12
47) SIGRTMIN+13	48) SIGRTMIN+14	49) SIGRTMIN+15	50) SIGRTMAX-14
51) SIGRTMAX-13	52) SIGRTMAX-12	53) SIGRTMAX-11	54) SIGRTMAX-10
55) SIGRTMAX-9	56) SIGRTMAX-8	57) SIGRTMAX-7	58) SIGRTMAX-6
59) SIGRTMAX-5	60) SIGRTMAX-4	61) SIGRTMAX-3	62) SIGRTMAX-2
63) SIGRTMAX-1	64) SIGRTMAX	
</pre>

<p>As you can see, signals are numbered starting with 1. However, when they are
used in bitmasks (e.g. in the output of <tt>ps s</tt>), the least significant bit
corresponds to signal 1.</p>

<p>This article will focus on the following signals: <tt>SIGHUP</tt>,
<tt>SIGINT</tt>, <tt>SIGQUIT</tt>, <tt>SIGPIPE</tt>, <tt>SIGCHLD</tt>,
<tt>SIGSTOP</tt>, <tt>SIGCONT</tt>, <tt>SIGTSTP</tt>, <tt>SIGTTIN</tt>,
<tt>SIGTTOU</tt> and <tt>SIGWINCH</tt>.</p>

<div>
<h3>SIGHUP</h3>
<ul><li>Default action: <b>Terminate</b></li>
<li>Possible actions: Terminate, Ignore, Function call</li></ul>

<p><tt>SIGHUP</tt> is sent by the UART driver to the entire session when a hangup
condition has been detected. Normally, this will kill all the processes. Some
programs, such as <tt>nohup(1)</tt> and <tt>screen(1)</tt>, detach
from their session (and TTY), so that their child processes won&#39;t notice a
hangup.</p>
</div>

<div>
<h3>SIGINT</h3>
<ul><li>Default action: <b>Terminate</b></li>
<li>Possible actions: Terminate, Ignore, Function call</li></ul>

<p><tt>SIGINT</tt> is sent by the TTY driver to the current foreground job when the
<i>interactive attention</i> character (typically <tt>^C</tt>, which has ASCII
code 3) appears in the input stream, unless this behaviour has been turned
off. Anybody with access permissions to the TTY device can change the
interactive attention character and toggle this feature; additionally, the
session manager keeps track of the TTY configuration of each job, and updates
the TTY whenever there is a job switch.</p>
</div>

<div>
<h3>SIGQUIT</h3>
<ul><li>Default action: <b>Core dump</b></li>
<li>Possible actions: Core dump, Ignore, Function call</li></ul>

<p><tt>SIGQUIT</tt> works just like <tt>SIGINT</tt>, but the quit character is typically
<tt>^\</tt> and the default action is different.</p>
</div>

<div>
<h3>SIGPIPE</h3>
<ul><li>Default action: <b>Terminate</b></li>
<li>Possible actions: Terminate, Ignore, Function call</li></ul>

<p>The kernel sends <tt>SIGPIPE</tt> to any process which tries to write to a pipe with
no readers. This is useful, because otherwise jobs like
<tt>yes | head</tt> would never terminate.</p>
</div>

<div>
<h3>SIGCHLD</h3>
<ul><li>Default action: <b>Ignore</b></li>
<li>Possible actions: Ignore, Function call</li></ul>

<p>When a process dies or changes state (stop/continue), the kernel sends a
<tt>SIGCHLD</tt> to its parent process. The <tt>SIGCHLD</tt> signal carries additional
information, namely the process id, the user id, the exit status (or
termination signal) of the terminated process and some execution time
statistics. The session leader (shell) keeps track of its jobs using this
signal.</p>
</div>

<div>
<h3>SIGSTOP</h3>
<ul><li>Default action: <b>Suspend</b></li>
<li>Possible actions: Suspend</li></ul>

<p>This signal will unconditionally suspend the recipient, i.e. its signal
action can&#39;t be reconfigured. Please note, however, that <tt>SIGSTOP</tt>
isn&#39;t sent by the kernel during job control. Instead, <tt>^Z</tt> typically
triggers a <tt>SIGTSTP</tt>, which can be intercepted by the application. The
application may then e.g. move the cursor to the bottom of the screen or
otherwise put the terminal in a known state, and subsequently put itself to sleep using <tt>SIGSTOP</tt>.</p>
</div>

<div>
<h3>SIGCONT</h3>
<ul><li>Default action: <b>Wake up</b></li>
<li>Possible actions: Wake up, Wake up + Function call</li></ul>

<p><tt>SIGCONT</tt> will un-suspend a stopped process. It is sent explicitly by the
shell when the user invokes the <tt>fg</tt> command. Since <tt>SIGSTOP</tt> can&#39;t be
intercepted by an application, an unexpected <tt>SIGCONT</tt> signal might indicate that
the process was suspended some time ago, and then un-suspended.</p>
</div>

<div>
<h3>SIGTSTP</h3>
<ul><li>Default action: <b>Suspend</b></li>
<li>Possible actions: Suspend, Ignore, Function call</li></ul>

<p><tt>SIGTSTP</tt> works just like <tt>SIGINT</tt> and <tt>SIGQUIT</tt>, but the magic character is
typically <tt>^Z</tt> and the default action is to suspend the process.</p>
</div>

<div>
<h3>SIGTTIN</h3>
<ul><li>Default action: <b>Suspend</b></li>
<li>Possible actions: Suspend, Ignore, Function call</li></ul>

<p>If a process within a background job tries to read from a TTY device, the
TTY sends a <tt>SIGTTIN</tt> signal to the entire job. This will normally suspend the
job.</p>
</div>

<div>
<h3>SIGTTOU</h3>
<ul><li>Default action: <b>Suspend</b></li>
<li>Possible actions: Suspend, Ignore, Function call</li></ul>

<p>If a process within a background job tries to write to a TTY device, the TTY
sends a <tt>SIGTTOU</tt> signal to the entire job. This will normally suspend the job.
It is possible to turn off this feature on a per-TTY basis.</p>
</div>

<div>
<h3>SIGWINCH</h3>
<ul><li>Default action: <b>Ignore</b></li>
<li>Possible actions: Ignore, Function call</li></ul>

<p>As mentioned, the TTY device keeps track of the terminal size, but this
information needs to be updated manually. Whenever that happens, the TTY device
sends <tt>SIGWINCH</tt> to the foreground job. Well-behaving interactive applications,
such as editors, react upon this, fetch the new terminal size from the TTY
device and redraw themselves accordingly.</p>
</div>

<h2>An example</h2>

<p>Suppose that you are editing a file in your (terminal based) editor of
choice. The cursor is somewhere in the middle of the screen, and the editor is
busy executing some processor intensive task, such as a search and replace
operation on a large file. Now you press <tt>^Z</tt>. Since the line
discipline has been configured to intercept this character (<tt>^Z</tt> is a
single byte, with ASCII code 26), you don&#39;t have to wait for the editor to
complete its task and start reading from the TTY device. Instead, the line discipline
subsystem instantly sends <tt>SIGTSTP</tt> to the foreground process group. This process
group contains the editor, as well as any child processes created by it.</p>

<p>The editor has installed a signal handler for <tt>SIGTSTP</tt>, so the kernel diverts
the process into executing the signal handler code. This code moves the cursor
to the last line on the screen, by writing the corresponding control sequences
to the TTY device. Since the editor is still in the foreground, the control
sequences are transmitted as requested. But then the editor sends a <tt>SIGSTOP</tt> to
its own process group.</p>

<p>The editor has now been stopped. This fact is reported to the session leader
using a <tt>SIGCHLD</tt> signal, which includes the id of the suspended
process. When all processes in the foreground job have been suspended, the
session leader reads the current configuration from the TTY device, and stores
it for later retrieval. The session leader goes on to install itself as the
current foreground process group for the TTY using an <tt>ioctl</tt> call.
Then, it prints something like &#34;[1]+ Stopped&#34; to inform the user that a job was
just suspended.</p>

<p>At this point, <tt>ps(1)</tt> will tell you that the editor process is in
the stopped state (&#34;<tt>T</tt>&#34;). If we try to wake it up, either by using the <tt>bg</tt>
built-in shell command, or by using <tt>kill(1)</tt> to send <tt>SIGCONT</tt> to the
process(es), the editor will start executing its <tt>SIGCONT</tt> signal handler. This
signal handler will probably attempt to redraw the editor GUI by writing to the
TTY device. But since the editor is now a background job, the TTY device will
not allow it. Instead, the TTY will send <tt>SIGTTOU</tt> to the editor, stopping it
again. This fact will be communicated to the session leader using <tt>SIGCHLD</tt>, and
the shell will once again write &#34;[1]+ Stopped&#34; to the terminal.</p>

<p>When we type <tt>fg</tt>, however, the shell first restores the line
discipline configuration that was saved earlier. It informs the TTY driver that
the editor job should be treated as the foreground job from now on. And
finally, it sends a <tt>SIGCONT</tt> signal to the process group. The editor process
attempts to redraw its GUI, and this time it will not be interrupted by <tt>SIGTTOU</tt>
since it is now a part of the foreground job.</p>

<h2>Flow control and blocking I/O</h2>

<p><a href="https://www.linusakesson.net/pix/data/061001-1/dsc00043.jpg"><img src="https://www.linusakesson.net/pix/data/061001-1/300/300/dsc00043.jpg" alt=""/></a></p>

<p>Run <tt>yes</tt> in an <tt>xterm</tt>, and you will see a lot of
&#34;<tt>y</tt>&#34; lines swooshing past your eyes. Naturally, the <tt>yes</tt>
process is able to generate &#34;<tt>y</tt>&#34; lines much faster than the
<tt>xterm</tt> application is able to parse them, update its frame buffer,
communicate with the X server in order to scroll the window and so on. How is
it possible for these programs to cooperate?</p>

<p>The answer lies in <i>blocking I/O</i>. The pseudo terminal can only keep a
certain amount of data inside its kernel buffer, and when that buffer is full
and <tt>yes</tt> tries to call <tt>write(2)</tt>, then <tt>write(2)</tt> will
<i>block</i>, moving the <tt>yes</tt> process into the interruptible sleep
state where it remains until the <tt>xterm</tt> process has had a chance to
read off some of the buffered bytes.</p>

<p>The same thing happens if the TTY is connected to a serial port.
<tt>yes</tt> would be able to transmit data at a much higher rate than, say,
9600 baud, but if the serial port is limited to that speed, the kernel
buffer soon fills up and any subsequent <tt>write(2)</tt> calls block the
process (or fail with the error code <tt>EAGAIN</tt> if the process has
requested non-blocking I/O).</p>

<p>What if I told you, that it is possible to explicitly put the TTY in a
blocking state even though there is space left in the kernel buffer? That until
further notice, every process trying to <tt>write(2)</tt> to the TTY
automatically blocks. What would be the use of such a feature?</p>

<p>Suppose we&#39;re talking to some old VT-100 hardware at 9600 baud. We
just sent a complex control sequence asking the terminal to scroll the display.
At this point, the terminal gets so bogged down with the scrolling operation,
that it&#39;s unable to receive new data at the full rate of 9600 baud. Well,
physically, the terminal UART still runs at 9600 baud, but there won&#39;t be enough
buffer space in the terminal to keep a backlog of received characters. This is
when it would be a good time to put the TTY in a blocking state. But how do we
do that from the terminal?</p>

<p>We have already seen that a TTY device may be configured to give certain
data bytes a special treatment. In the default configuration, for instance, a
received <tt>^C</tt> byte won&#39;t be handed off to the application through
<tt>read(2)</tt>, but will instead cause a <tt>SIGINT</tt> to be delivered to
the foreground job. In a similar way, it is possible to configure the TTY to
react on a <i>stop flow</i> byte and a <i>start flow</i> byte. These are
typically <tt>^S</tt> (ASCII code 19) and <tt>^Q</tt> (ASCII code 17)
respectively. Old hardware terminals transmit these bytes
automatically, and expect the operating system to regulate its flow of data
accordingly. This is called flow control, and it&#39;s the reason why your
<tt>xterm</tt> sometimes appears to lock up when you accidentally press
<tt>^S</tt>.</p>

<p>There&#39;s an important difference here: Writing to a TTY which is stopped due
to flow control, or due to lack of kernel buffer space, will <i>block</i> your
process, whereas writing to a TTY from a background job will cause a
<tt>SIGTTOU</tt> to suspend the entire process group. I don&#39;t know why the
designers of UNIX had to go all the way to invent <tt>SIGTTOU</tt> and
<tt>SIGTTIN</tt> instead of relying on blocking I/O, but my best guess is that
the TTY driver, being in charge of job control, was designed to monitor and
manipulate whole jobs; never the individual processes within them.</p>

<h2>Configuring the TTY device</h2>

<p><img src="https://www.linusakesson.net/programming/tty/cockpit.jpg" alt="Control panel"/>
</p>

<p>To find out what the controlling TTY for your shell is called, you could
refer to the <tt>ps l</tt> listing as described earlier, or you could simply
run the <tt>tty(1)</tt> command.</p>

<p>A process may read or modify the configuration of an open TTY device
using <tt>ioctl(2)</tt>. The API is described in <tt>tty_ioctl(4)</tt>. Since
it&#39;s part of the binary interface between Linux applications and the kernel,
it will remain stable across Linux versions. However, the interface is
non-portable, and applications should rather use the POSIX wrappers described
in the <tt>termios(3)</tt> man page.</p>

<p>I won&#39;t go into the details of the <tt>termios(3)</tt> interface, but if
you&#39;re writing a C program and would like to intercept <tt>^C</tt> before it
becomes a <tt>SIGINT</tt>, disable line editing or character echoing, change
the baud rate of a serial port, turn off flow control etc. then you will find
what you need in the aforementioned man page.</p>

<p>There is also a command line tool, called <tt>stty(1)</tt>, to manipulate
TTY devices. It uses the <tt>termios(3)</tt> API.</p>

<p>Let&#39;s try it!</p>

<tt>
$ stty -a</tt>

<p>The <tt>-a</tt> flag tells stty to display <b>all</b> settings. By default,
it will look at the TTY device attached to your shell, but you can specify
another device with <tt>-F</tt>.</p>

<p>Some of these settings refer to UART parameters, some affect the line
discipline and some are for job control. <i>All mixed up in a bucket for
monsieur.</i> Let&#39;s have a look at the first line:</p>

<table>
<tbody><tr><td>speed</td><td>UART</td><td>The baud rate. Ignored for pseudo terminals.</td></tr>
<tr><td>rows, columns</td><td>TTY driver</td><td>Somebody&#39;s idea of the size, in characters, of the terminal attached to this TTY device. Basically, it&#39;s just a pair of variables within kernel space, that you may freely set and get. Setting them will cause the TTY driver to dispatch a <tt>SIGWINCH</tt> to the foreground job.</td></tr>
<tr><td>line</td><td>Line discipline</td><td>The line discipline attached to the TTY device. 0 is <tt>N_TTY</tt>. All valid numbers are listed in <tt>/proc/tty/ldiscs</tt>. Unlisted numbers appear to be aliases for <tt>N_TTY</tt>, but don&#39;t rely on it.</td></tr>
</tbody></table>

<p>Try the following: Start an <tt>xterm</tt>. Make a note of its TTY device
(as reported by <tt>tty</tt>) and its size (as reported by <tt>stty -a</tt>).
Start <tt>vim</tt> (or some other full-screen terminal application) in the
<tt>xterm</tt>. The editor queries the TTY device for the current terminal size
in order to fill the entire window. Now, from a different shell window, type:</p>

<pre>stty -F <i>X</i> rows <i>Y</i></pre>

<p>where <i>X</i> is the TTY device, and
<i>Y</i> is half the terminal height. This will update the TTY data structure
in kernel memory, and send a <tt>SIGWINCH</tt> to the editor, which will
promptly redraw itself using only the upper half of the available window
area.</p>

<p>The second line of <tt>stty -a</tt> output lists all the special characters.
Start a new <tt>xterm</tt> and try this:</p>

<pre>stty intr o</pre>

<p>Now &#34;<tt>o</tt>&#34;, rather than <tt>^C</tt>, will send a <tt>SIGINT</tt> to
the foreground job. Try starting something, such as <tt>cat</tt>, and verify
that you can&#39;t kill it using <tt>^C</tt>. Then, try typing &#34;<tt>hello</tt>&#34;
into it.</p>

<p>Occasionally, you may come across a UNIX system where the backspace key
doesn&#39;t work. This happens when the terminal emulator transmits a backspace
code (either ASCII 8 or ASCII 127) which doesn&#39;t match the <tt>erase</tt>
setting in the TTY device. To remedy the problem, one usually types <tt>stty
erase ^H</tt> (for ASCII 8) or <tt>stty erase ^?</tt> (for ASCII 127). But
please remember that many terminal applications use <tt>readline</tt>, which
puts the line discipline in raw mode. Those applications aren&#39;t affected.</p>

<p>Finally, <tt>stty -a</tt> lists a bunch of switches. As expected, they are
listed in no particular order. Some of them are UART-related, some affect the
line discipline behaviour, some are for flow control and some are for job
control. A dash (<tt>-</tt>) indicates that the switch is off; otherwise it is
on. All of the switches are explained in the <tt>stty(1)</tt> man page, so
I&#39;ll just briefly mention a few:</p>

<p><b><tt>icanon</tt></b> toggles the canonical (line-based) mode. Try this in a new <tt>xterm</tt>:</p>
<pre>stty -icanon; cat</pre>
<p>Note how all the line editing characters, such as backspace and <tt>^U</tt>,
have stopped working. Also note that <tt>cat</tt> is receiving (and
consequently outputting) one character at a time, rather than one line at a
time.</p>

<p><b><tt>echo</tt></b> enables character echoing, and is on by default.
Re-enable canonical mode (<tt>stty icanon</tt>), and then try:</p>

<pre>stty -echo; cat</pre>

<p>As you type, your terminal emulator transmits information to the kernel.
Usually, the kernel echoes the same information back to the terminal emulator,
allowing you to see what you type. Without character echoing, you can&#39;t see
what you type, but we&#39;re in cooked mode so the line editing facilities are
still working. Once you press enter, the line discipline will transmit the edit
buffer to <tt>cat</tt>, which will reveal what your wrote.</p>

<p><b><tt>tostop</tt></b> controls whether background jobs are allowed to write to the terminal. First try this:</p>

<pre>stty tostop; (sleep 5; echo hello, world) &amp;</pre>

<p>The <tt>&amp;</tt> causes the command to run as a background job. After five
seconds, the job will attempt to write to the TTY. The TTY driver will suspend
it using <tt>SIGTTOU</tt>, and your shell will probably report this fact,
either immediately, or when it&#39;s about to issue a new prompt to you. Now kill
the background job, and try the following instead:</p>

<pre>stty -tostop; (sleep 5; echo hello, world) &amp;</pre>

<p>You will get your prompt back, but after five seconds, the background job
transmits <tt>hello, world</tt> to the terminal, in the middle of whatever you
were typing.</p>

<p>Finally, <tt>stty sane</tt> will restore your TTY device configuration to
something reasonable.</p>

<h2>Conclusion</h2>

<p>I hope this article has provided you with enough information to get to terms
with TTY drivers and line disciplines, and how they are related to terminals, line
editing and job control. Further details can be found in the various man pages
I&#39;ve mentioned, as well as in the glibc manual (<tt>info libc</tt>, &#34;Job
Control&#34;).</p>

<p>Finally, while I don&#39;t have enough time to answer all the questions I get, I
do welcome feedback on this and other pages on the site. Thanks for
reading!</p>

<p>Posted Friday 25-Jul-2008 19:46</p>
<div>
<h3>Discuss this page</h3><p>Disclaimer: I am not responsible for what people (other than myself) write in the forums. Please report any abuse, such as insults, slander, spam and illegal material, and I will take appropriate actions. Don&#39;t feed the trolls.</p><p>Jag tar inget ansvar för det som skrivs i forumet, förutom mina egna inlägg. Vänligen rapportera alla inlägg som bryter mot reglerna, så ska jag se vad jag kan göra. Som regelbrott räknas till exempel förolämpningar, förtal, spam och olagligt material. Mata inte trålarna.</p><div><div><p>Very good and informative article for a complex topic</p></div></div>
<div><div><div><p>Very good and informative article for a complex topic</p></div></div></div>
<div><p>I have been trying to chew through documents in every unix book possible to explain how the TTY system really works. Your article has been more informative than all of these books. Without a programmers knowledge of how a unix kernel works, it&#39;s quite difficult for a System Administrator to understand concepts that are so crucial to their jobs. Thank you for your writing such a great article. Your help is truly appreciated.</p></div>
<div><div><p>I really admire you!! I&#39;m not use to post, but this article was by far the best I ever read about tty, i read many articles and even books but nothing so clear like this. </p></div></div>
<div><div><p>Good article. A few years ago, after some experimentation, I wrote up some TTY stuff for myself, because I couldn&#39;t find any good documentation. For example, I never understood why process group leaders (and consequently also session leaders) are prevented from calling setsid(2). (See the manual for what setsid(2) does.) I think I can explain it now.</p></div></div>
<div><p>good job &amp; best introductory for TTY</p></div>
<div><p>amazing man , this is amazing !!! best tty article ever</p></div>

<div><div><p>Holy Smokes dude, those were the days!</p></div></div>
<div><p>I rarely comment on Blogs as I usually feel my input would not be necessary, but I must say this has been one of the best written and descriptive documents I have had the pleasure of learning from</p></div>
<div><p>ZZZZZZZZZZZZZZZZZZZZZZZZZZ to long, jesus christ write up a summery for us lazy people</p></div>
<div><p>I&#39;ve been looking for an article like this for a very long time... thanks very much for putting this together!</p></div>
<div><p>Great summary, and very useful. Thanks!</p></div>


<div><div><p>Thanks for the great article!</p></div></div>
<div><div><p>Actually, to be more precise:</p></div></div>
<div><p>A reader pointed out that VT (in VT-100) stands for &#34;video terminal&#34;, not &#34;virtual terminal&#34;. This has been fixed.</p></div>
<div><p>Thanks for the article, really helped !</p></div>
<div><p>Thankyou, I found this to be an excellent TTY primer.</p></div>

<div><p>Very nice. I&#39;m currently (trying to) write a Unix-clone mostly from scratch, and this is a good resource on how TTYs are supposed to work.</p></div>
<div><div><p>Hi--how are things in Sweden?</p></div></div>
<div><p>Wonderful article.the explanation is meticulous and elegant. Thank you.</p></div>
<div><div><p>GREAT ARTICLE!!! Read articles and books on Terminal I/O and none as clear as this summary.</p></div></div>
<div><p>Thanks for a good article</p></div>
<div><p>Thanks for this very good article</p></div>
<div><p>Thanks for such a wonderful article. I am a beginner in tty and your article was of great help!!</p></div>
<div><p>nice article..thanx for sharing ur knowledge  :)</p></div>
<div><p>Thanks a lot for this precise article ! This has been very useful to me... (reading an external device on RS232 from bash...)</p></div>
<div><p>Thank you for sharing such a great artical. -Hai</p></div>
<div><p>Thanks a lot for this great article</p></div>
<div><p>Wonderful article!  I never learned much about unix process stuff (apart from little practical things like piping, detaching, killing, etc), but now I feel like I&#39;m starting to see what&#39;s behind the magical terminals!  Thank you :)</p></div>
<div><p>&#34;daemonizing&#34; a process - detaching from the tty - would probably also fit here. -rurban</p></div>



<div><p>excellent article, well done!</p></div>
<div><div><p>The process of daemonizing is covered elsewhere, easy to Google. It involved forking, killing the parent, then calling setsid() in the child, and optionally chdir()ing to / and closing stdin/stdout/stderr. </p></div></div>
<div><div><p>Nice article, various points...</p></div></div>
<div><div><div><p><b>ralph</b> wrote:</p><p>Nice article, various points...</p></div></div></div>
<div><div><p>How do you restart bash in tty0? For some reason my bash has died in all tty&#39;s (Ctrl-Alt-Fn). I does not show the login prompt anymore.</p></div></div>
<div><div><div><p>How do you restart bash in tty0? For some reason my bash has died in all tty&#39;s (Ctrl-Alt-Fn). I does not show the login prompt anymore.</p></div></div></div>



<div><p>How to Modify the tty driver so that control-W erases the previous word typed by the user.</p></div>
<div><p>Nithin: thanks for the page....i got a lot of information from ur web page...</p></div>
<div><p>Great article, very imformative please explain how to prevent UART overrun</p></div>
<div><p>Hi there ! Would it be possible to create a raw tty which redirects input to some fifo and another tty to read from that fifo ? I know that is extrange what I&#39;m asking...I&#39;m building a z80 emulator and if this is possible would help me to test the input/output routines of the emulator without writting code to read/display...</p></div>
<div><p>very helpful indeed Thanks a ton.</p></div>
<div><div><p>Good article.Thanks you very much</p></div></div>
<div><div><p>this article is very good .</p></div></div>
<div><div><p>Awesome article! Its been very helpful in understanding TTY layer as whole. </p></div></div>
<div><div><p>Hi, this seems to be an excellent technical article, however is there any chance you can provide a broad description of TTY for a non technical audience. e.g. explain in simple language the origin, function and implications of TTY.</p></div></div>

<div><p>Very good document, thanks!</p></div>
<div><p>great article. I have known the term &#39;TTY&#39; for a long time and never knew what the history behind it. Seeing how even current day UNIX system still make use of TTY is quite interesting to me. Now I feel more &#39;connected&#39; when I press a key on my keyboard and seeing a character appear on the monitor screen. A good read.</p></div>
<div><div><p>Wow! The name of the article says it all, but for real this time! Thanks!</p></div></div>
<div><p>Amazing article. Thanks so much for putting this together. I&#39;ve been using Linux for 10 years, and this taught me quite a bit.</p></div>
<div><div><p>ZZZZZZZZZZZZZZZZZZZZZZZZZZ to long, jesus christ write up a summery for us lazy people</p><p>if(easilyBored || notInterested){</p></div></div>
<div><p>Fantastic expalanation. Keep up the good work</p></div>
<div><p>Greatly informative article. Of course, Bookmarked.</p></div>
<div><p>Very informative article; Thanks for knowledge sharing ...</p></div>
<div><p>Fucking awesome. Thanks a lot for the info!</p></div>
<div><p>Fucking awesome. Thanks a lot for the info!</p></div>
<div><p>Excelent article, I started to read it at work, now I&#39;m printing it to read it more carefuly on my way home. Thanks for sharing all this!</p></div>
<div><p>Thank you for sharing your knoledge so generously!</p></div>


<div><p>can anybody give exact command for sending messages via linux?</p></div>

<div><div><p>From your disclaimer: “Please report any abuse, such as insults, slander, spam and illegal material”</p></div></div>
<div><p>Thanks for writing the article.  It was a bit heavy going at times, but it&#39;s helped me understand some of what is going on with the whole terminal thing.</p></div>
<div><p>This was enormously informative and helpful. I&#39;ve bookmarked it for future use. Thank you!</p></div>
<div><div><p>I am trying to solve a mystery with certain services started at reboot or via a root crontab.</p></div></div>
<div><p>Very informative article, thanks very much for sharing it with the web.</p></div>
<div><p>Real great article thanks very much.</p></div>

<div><p>Great article! I&#39;m currently running a real Teletype ASR-33 on a serial port with Ubuntu. I have to use stty to set the proper parameters for an uppercase-only terminal, change tabs to spaces, etc. Is there a way to determine what port I&#39;m logging into (ttyS0? S1? S2, S3 or S4?) Right now, I have to run stty on all ports and get an access denied error for any port I&#39;m not connected to. I&#39;d like to find out what port I&#39;m on and only run the stty on that port. Thanks for your time!</p></div>
<div><div><p>Is there a way to determine what port I&#39;m logging into (ttyS0? S1? S2, S3 or S4?)</p><p>Sounds like a job for the tty(1) command.</p></div></div>
<div><div><p>I think the commentary about line editing being part of the operating system to simplify programs is  potentially misleading - the simplification of applications is a side effect.</p></div></div>
<div><p>This is a really great job!  Really helped with background jobs writing to stdout and going to sleep (putting &#39;stty -tostop;&#39; before background command).  It takes much time to generate meaningful examples - much appreciated!</p></div>

<div><div><p>Great Article and good writing. I came looking for one answer (which I found) and found that I could not stop reading (normally a sign of a good article).</p></div></div>
<div><div><p>This is a very good article and I&#39;ve read and enjoyed it multiple times (no, really!).</p></div></div>
<div><div><p>Great and insightful article!!!</p></div></div>
<div><p>Thank you so much. Great article!</p></div>


<div><p>Can you explain why sometimes my terminal gets diseased, and the line I&#39;m typing overwrites itself, or the cursor is in the wrong place, or similar symptoms? is there a way to fix it?</p></div>
<div><p>Love the article, but I did have a comment -- namely that I wouldn&#39;t describe the DEC VT100 as solid state because of its CRT.  Again, though, the article is great!  Thanks!</p></div>

<div><div><p>That brings back old memories. The TTY shown is from the 1940&#39;s were 5 bit rather than the later 8 bit (really 7 bit plus parity) machines seen in the late 60&#39;s and 70&#39;s. Next retro core memory come back.</p></div></div>
<div><div><p>Fantastic! awesome article you should think about to write a book or something, It clarified me some things, even having 5+ years of Unix experience.</p></div></div>
<div><p>Thanks a lot for writing this!</p></div>
<div><div><p>&#34;yes&#34; program , produced in 2009 !</p></div></div>
<div><div><div><p>&#34;yes&#34; program , produced in 2009 !</p></div></div></div>
<div><div><div><p>&#34;yes&#34; program , produced in 2009 !</p></div></div></div>
<div><div><div><p>&#34;yes&#34; program , produced in 2009 !</p></div></div></div>
<div><div><p>int main( in argc, char** arg)</p></div></div>

<div><div><div><p>Shell is allowing me to type in only 256 characters. e.g. </p></div></div></div>
<div><div><div><p>Can Web Master please delete this post so that the page would not be made so wide in some browser to be unreadable?</p></div></div></div>
<div><div><div><p><b>lft</b> wrote:</p><p>Can Web Master please delete this post <br/></p></div></div></div>
<div><div><div><div><p><b>lft</b> wrote:</p><p>Can Web Master please delete this post <br/></p></div></div></div></div>
<div><div><p>It&#39;s not to keep application simple that the line discipline is in the kernel.  The unix philosophy is quite the contrary, to keep the KERNEL simple, and deport to user space the handing of complexities that they don&#39;t want inside the kernel. (See for example interrupted system calls and signal handling, but that&#39;s another topic).</p></div></div>
<div><p>Thanks a lot! Was looking for this kind of information all over the place, never found anything good. If you got more please keep it coming.</p></div>
<div><div><p>The most concise/intuitive article I&#39;ve read so far on the subject. Diagrams were especially helpful. If you manage to write a book on Linux is such manner, no doubt it&#39;s going to be a bestseller... </p></div></div>
<div><div><p>ZZZZZZZZZZZZZZZZZZZZZZZZZZ to long, jesus christ write up a summery for us lazy people</p></div></div>
<div><p>Thanks for the page. You help me a lot.</p></div>

<div><p>Thank you very much for this great article!</p></div>
<div><p>Excellent!! Thank you very much for this article. Watching and trying to understand technological issues via their historical context and being showed how they evolved make it really a pleasure to follow your explanations and very easy to get them.</p></div>
<div><div><p>Very useful article, thanks.</p></div></div>
<div><div><p>Wow! Thanks Linus for the article.</p></div></div>
<div><p>Real very informative! Kudos to your effort and thanks for hard work!</p></div>
<div><div><p>Fantastic, tack så mycket!</p></div></div>
<div><div><p> So much for the &#39;age of information&#39;.</p></div></div>
<div><div><div><p>&#34;yes&#34; program , produced in 2009 !</p></div></div></div>
<div><div><p>So I was searching for information about the TTY system, and where did I, by chance, end up? Thanks for the great article. :-)</p></div></div>
<div><p>really great post ! Thanks a lot for the general understanding of the how, instead of the usual &#34;to do this, do that&#34; ! And I&#39;ll stop here because having three exclamation mark in one sentence is a clear sign of mental disorder, but thanks again.</p></div>
<div><p>Excellent post on TTY!! Thank you -- Aananth C N</p></div>
<div><p>thank you. very interesting.</p></div>
<div><p>I&#39;ll join the crowd here to say thank you for the time you spent on this article, I&#39;ve appreciated it a lot.</p></div>
<div><p>Thank you. I don&#39;t think this article will EVER be outdated :P</p></div>
<div><div><p>Great article! I&#39;m currently running a real Teletype ASR-33 on a serial port with Ubuntu. I have to use stty to set the proper parameters for an uppercase-only terminal, change tabs to spaces, etc. Is there a way to determine what port I&#39;m logging into (ttyS0? S1? S2, S3 or S4?) Right now, I have to run stty on all ports and get an access denied error for any port I&#39;m not connected to. I&#39;d like to find out what port I&#39;m on and only run the stty on that port. Thanks for your time!</p></div></div>
<div><div><p>Thanks for this enlightening article! It is a bit wordy, but I completely expected that.</p></div></div>
<div><p>First teletype was made in Germany around the 30s or 40s. One of the many types of teletypes was the Hellschreiber. There were also other types but all worked the same: you punch letters and they are remote printed to one or more receiving stations. After the war in the operations of confiscating the german patents, the US developed the teletype further. That&#39;s missing from your article.</p></div>
<div><div><p>First teletype was made in Germany around the 30s or 40s. One of the many types of teletypes was the Hellschreiber. There were also other types but all worked the same: you punch letters and they are remote printed to one or more receiving stations. After the war in the operations of confiscating the german patents, the US developed the teletype further. That&#39;s missing from your article.</p></div></div>
<div><div><p>First teletype was made in Germany around the 30s or 40s. One of the many types of teletypes was the Hellschreiber. There were also other types but all worked the same: you punch letters and they are remote printed to one or more receiving stations. After the war in the operations of confiscating the german patents, the US developed the teletype further. That&#39;s missing from your article.</p></div></div>
<div><p>man! you made me see the light!</p></div>
<div><div><div><p>Hi--how are things in Sweden?</p></div></div></div>
<div><div><p>&gt; Writing to a TTY which is stopped due to flow control, ...... will block your process</p></div></div>
<div><div><div><p>&gt; Writing to a TTY which is stopped due to flow control, ...... will block your process</p></div></div></div>


<div><p>the VT100 was not a colour terminal as the text suggests, though.</p></div>
<div><p>Unix purist &lt;- I WAS HERE  +1 great article</p></div>
<div><div><p>Great article - I will recommend it to my network.</p></div></div>
<div><div><p>the VT100 was not a colour terminal as the text suggests, though.</p></div></div>
<div><p>The Plan 9 operating system completely does away with TTY, signals, and ioctl. Everything in Plan 9 is either a file or represented as a file.</p></div>
<div><div><p>The basic idea is that every pipeline is a job, because every process in a pipeline should be manipulated (stopped, resumed, killed) simultaneously.</p></div></div>
<div><p>By far the most amazing article about TTY I have ever read, thanks!</p></div>
<div><p>Great article. Thank you! After 15 years of using unix and linux i finally got to the description of ttys :)</p></div>
<div><div><p>Fantastic article. Thanks for doing all of the legwork. :)</p></div></div>
<div><div><p>Thank you so for the article!</p></div></div>
<div><p>Great article, thanks a lot!</p></div>
<div><div><p>This is the best article I have ever read about tty.</p></div></div>

<div><p>Yup, interesting intro to the TTY area, I think, and fun trying out the terminal tweaks..but any ideas of where I can find a good intro to using TTY in Linux, without the writer assuming I know all about networking/the Linux kernel in advance??? Please and thank-you.</p></div>
<div><p>Yup, interesting intro to the TTY area, I think, and fun trying out the terminal tweaks..but any ideas of where I can find a good intro to using TTY in Linux, without the writer assuming I know all about networking/the Linux kernel in advance??? Please and thank-you.</p></div>
<div><div><p>Yup, interesting intro to the TTY area, I think, and fun trying out the terminal tweaks..but any ideas of where I can find a good intro to using TTY in Linux, without the writer assuming I know all about networking/the Linux kernel in advance??? Please and thank-you.</p></div></div>
<div><div><p>best tty explanation ever written, hands down. </p></div></div>
<div><div><p>I&#39;m not especially new to bash programming or serial ports in general, but have never delved into stty and echo.</p></div></div>
<div><div><p>This is best ever article on TTY. What an awesome job. Please keep writing such articles.</p></div></div>
<div><p>The best article about tty ever! no kidding.</p></div>

<div><p>I am new to Linux but this article is so clear even i can taste 60% of them. I will read it again a couple days later because this is the best article i ever read about linux.</p></div>
<div><p>amazingly clear on a very fundamental piece of technology that I never really knew about. Just the build up of the subject is a great way to approach any kind of technical writing.  I&#39;ll definitely keep this post in mind when I try to tackle writing about a complicated technical subject.</p></div>
<div><div><div><p>&#34;yes&#34; program , produced in 2009 !</p></div></div></div>
<div><div><p>This is really cool. I&#39;ve just discovered this; I might have more to add after I&#39;ve properly read through it. While I remember, though, I want to mention one of the better resources I&#39;ve found for terminal escape sequences: an old online manpage for dtterm(5), at</p></div></div>
<div><p>Thanks for a great explanation of infrequently discussed, arcane, but essential part of the Unix/Linux &#34;reptile brain&#34;. Required knowledge for anyone who hopes to use Unix/Linux beyond a novice level.</p></div>
<div><p>Amazing. Very very needed. Thank you very much.</p></div>
<div><div><p>Very nice summary for those born too late :-)</p></div></div>

<div><p>Really good document,thanks for your great efforts</p></div>
<div><p>I am learning linux... and it is best article to understand what is going under the hood:) thanks for your time</p></div>
<div><div><p>Good job demystifying TTY for me. Keep it up.</p></div></div>
<div><p>This and all OK.. But.. I have one doubt for long time... In case of terminal emulator we can navigate/scroll using mouse.. How do we scroll/navigate inside TTY (I am a Linux beginner.. So sorry if it&#39;s a stupid question)</p></div>
<div><div><p>This and all OK.. But.. I have one doubt for long time... In case of terminal emulator we can navigate/scroll using mouse.. How do we scroll/navigate inside TTY (I am a Linux beginner.. So sorry if it&#39;s a stupid question)</p></div></div>
<div><p>Yes! More than I was looking for, but I&#39;m not complaining. Brilliant article, and now I know enough to stay the fuck away until I must.</p></div>
<div><p>really cool thanx to share your knowledge</p></div>
<div><div><p>Hello Linus! I have a question about what happens when you kill a process in raw mode. If you launch, say, vim in a terminal and then run `killall -9 vim` from a separate terminal, you would expect the original terminal to be left in raw mode after vim exits (as if you had run `stty raw` or something). However, surprisingly, it is left in canonical mode. I have tried this with multiple shells, terminal emulators, and OS&#39;s, and only urxvt behaves differently from this. My question is, what mechanism resets the terminal in this case?</p></div></div>
<div><div><div><p>Hello Linus! I have a question about what happens when you kill a process in raw mode. If you launch, say, vim in a terminal and then run `killall -9 vim` from a separate terminal, you would expect the original terminal to be left in raw mode after vim exits (as if you had run `stty raw` or something). However, surprisingly, it is left in canonical mode. I have tried this with multiple shells, terminal emulators, and OS&#39;s, and only urxvt behaves differently from this. My question is, what mechanism resets the terminal in this case?</p></div><p>Historically, the UNIX tty driver used to reset terminal settings to known values (300bps, some parity, cooked mode, etc.) in close() callback (which was called by the kernel only on last close to the device only) but this was found nonsense, because normal initial session programs like old /etc/getty (yes, it was stored there) were to initialize it fully.  This had some drawbacks, because this last close could happen when not needed and the reasons to conserve settings between close where significant.</p></div></div>
<div><p>Thank you sir. You have been helpful.</p></div>
<div><div><p>Thank you. I don&#39;t think this article will EVER be outdated :P</p><p>The images of it already are on high resolution monitors.</p></div></div>
<div><p>Best article regarding this mess!</p></div>
<div><p>This is just awesome!  I have old phone co UNIX books that don&#39;t go into this depth!   Thx for this info</p></div>

<div><div><p>I&#39;m using python on Debian os.</p></div></div>
<div><div><div><p>&#34;yes&#34; program , produced in 2009 !</p></div></div></div>
<div><div><div><p>I&#39;m not especially new to bash programming or serial ports in general, but have never delved into stty and echo.</p></div></div></div>
<div><div><p>This and all OK.. But.. I have one doubt for long time... In case of terminal emulator we can navigate/scroll using mouse.. How do we scroll/navigate inside TTY (I am a Linux beginner.. So sorry if it&#39;s a stupid question)</p></div></div>
<div><div><div><div><p>I&#39;m not especially new to bash programming or serial ports in general, but have never delved into stty and echo.</p></div></div></div></div>
<div><div><p>I have been with Linux and UNIX systems since 1994. They were good old days and I am learning these amazing knowledge just now from this article.</p></div></div>
<div><div><p>   * the text should be arranged to wrap to the width of the (reader&#39;s) window<br/></p></div></div>
<div><div><p>Wow, very impressive style of writing, thank you very much.</p></div></div>

<div><div><p>ZZZZZZZZZZZZZZZZZZZZZZZZZZ to long, jesus christ write up a summery for us lazy people</p></div></div>
<div><p>Thank you Linus. Really helped me understand this stuff.</p></div>
<div><p>This was extremely helpful, thanks!</p></div>
<div><div><p>&gt; In The Hitchhiker&#39;s Guide to the Galaxy, Douglas Adams mentions an extremely dull planet, inhabited by a bunch of depressed humans and a certain breed of animals with sharp teeth which communicate with the humans by biting them very hard in the thighs. This is strikingly similar to UNIX, in which the kernel communicates with processes by sending paralyzing or deadly signals to them. Processes may intercept some of the signals, and try to adapt to the situation, but most of them don&#39;t.</p></div></div>

<div><div><p>Just wanted to leave another pile of thanks for this great article.</p></div></div>

<div><div><p>Thanks for that nice write-up. Actually, I just came here because I don&#39;t want linux to mess with my payload over the serialport, is there a quick way to tell the tty to simply forward everything and _not_ mess with it?</p></div></div>
<div><p>I have been always wondering how tty works for years and could not get a clear idea until today I stumbled on this write up, an admirable article! Thank you!</p></div>
<div><div><p>&#34;To facilitate moving the terminal emulation into userland,(...) inside pseudo terminals, à la screen(1) or ssh(1)...&#34;</p></div></div>
<div><p>@OP, Btw do you have any &#34;to the metal&#34; UNIX/linux books to recommend that has information regarding such stuff?</p></div>

<div><p>You are a Rocket Scientist!</p></div>
<div><div><p>10 years old, still the best article on TTYs.  Still getting comments. Not a record  ( I presume ) but noteworthy. </p></div></div>
<div><p>Returning to Unix/Linux after 30 year gap. If only all documentation was as clear as this. Excellent. Thanks.</p></div>
<div><p>An awesome article, it helps a lot! Thanks from china.</p></div>
<div><div><p>Thank you very much for this amazing article!</p></div></div>
<div><p>Beautifully written and comprehensive enough for UNiX beginners like me. Thank you!</p></div>
<div><p>Thanks for the introduction of TTY!</p></div>
<div><div><p>I thought that it would be helpful to leave a comment about something that confused me.</p></div></div>
<div><div><p> which terminal introduced color attributes for escape sequences?</p></div></div>
<div><div><p>However when modems came in to play, the terminal&#39;s UART and the host&#39;s UART were no longer directly wired to each other and modems would only transmit data and no control lines between them. This situation required another method of flow control that would have to be transmitted in-band with the data. So software flow control via device control characters was invented.</p></div></div>
<div><p>Excellent comprehensive article on tty, thx Linus!</p></div>
<div><p>Great and informative read indeed! I feel a bit more confident tinkering my terminal now. Also learnt quite a lot on signal and process concepts. Thanks :)</p></div>
<div><div><p>Thanks for an informative article.  I really learned something!</p></div></div>
<div><p>Brilliant article! Thanks a lot!</p></div>
<div><p>Thank you for the wonderful article!</p></div>

<div><div><p>superb, fantastic -- opened a new world for me.</p></div></div>

<div><div><p>ZZZZZZZZZZZZZZZZZZZZZZZZZZ to long, jesus christ write up a summery for us lazy people</p></div></div>
<div><div><p>How do a program should propperly handle a &#34;/dev/pts&#34;?  I mean, I am able to open that device for read and write, the program is effectively writing and reading stuff, but when I want to close the program gracefully and close the file descriptor used to open the device, the program crashes with no clue on what has happened.</p></div></div>
<div><p>Having read your wonderful article, am feeling obliged to give my thanks. BIG thanks! :)</p></div>
<div><p>Amazing stuff! Thank you!</p></div>

<div><p>This is a fantastic guide. As you say, it&#39;s hard to find straightforward information about how the tty system works.</p></div>
<div><p>Thanks for the great post!!</p></div>
<div><div><p>lucid explanation. much makes sense on terminals in stevens/kerrisk linux api guide</p></div></div>
<div><p>a really excellent article on a subject that mystified me - (and I&#39;m an old guy who remembers punched tape &#39;telex&#39; as the main communication channel between our company and it&#39;s Connecticut USA parent) - thanks so much for this Mr Akesson!</p></div>
<div><div><p>For me, background processes are able to write to the terminal. For example, </p></div></div>
<div><p>Trying to use GDB GUI application, with two terminals, and you  find out this information bringing some light when you want control on the execution screen. New decade and still useful info.</p></div>
<div><p>Total shit. Doesn&#39;t explain how the tty works, nor how the shell connected to tty/pty.</p></div>
<div><p>If it&#39;s possible: How is related /dev/ack with /dev/tty?</p></div>


<div><p>Great article, thank you for putting this together!</p></div>
<div><div><p>I didn&#39;t get exactly how pty came into picture and what is the usage of that. </p></div></div>
<div><p>Really informative! good article!</p></div>

<div><p>Thank you! Still informative in 2020! After so many years, there&#39;s still not article explains TTY better than this.</p></div>
<div><p>Thanks for your article！</p></div>


<div><div><p>Wow, Bennie, thanks for that thorough response, and it does help. I thought the TTY might be the answer to most of my questions, but I now understand that it is much more complex than that.</p></div></div>
<div><div><p>A well formulated question deserves a proper answer I think. Besides, you did your research by even contacting the app-developer. Happy to help :).</p></div></div>
<div><div><p>I forgot to mention some resources if you are interested:</p></div></div>
<div><p>I wonder when I&#39;m in bash and erasing text with backspace what stops me from erasing the bash prompt at the beginning of the line?</p></div>
<div><div><p>Thank you very much, Bennie, for all the additional information! ’ll check out those additional resources you recommended.</p></div></div>

<div><p>Why aren&#39;t UART driver in the graph for typical desktop system? From the article, it seems only the hardware of Terminal and UART are gone. UART setting still exists in later parts of the article.</p></div>
<div><div><p>I wonder when I&#39;m in bash and erasing text with backspace what stops me from erasing the bash prompt at the beginning of the line?</p></div></div>

<div><div><p>So as a convenience, the operating system provides an editing buffer and some rudimentary editing commands (backspace, erase word, clear line, reprint) </p></div></div>
<div><p>Marvelous article. Big thanks for that. I use the pipes for decades but never understood it down to the ground of the kernel, not better until now... good idea to start at the beginning with the teletypers ;)</p></div>
<div><div><div><p>So as a convenience, the operating system provides an editing buffer and some rudimentary editing commands (backspace, erase word, clear line, reprint) </p></div></div></div>


</div>
</div></div></div></div>
  </body>
</html>
