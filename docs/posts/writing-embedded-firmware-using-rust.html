<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.anyleaf.org/blog/writing-embedded-firmware-using-rust">Original</a>
    <h1>Writing embedded firmware using Rust</h1>
    
    <div id="readability-page-1" class="page"><p>


            <h5>Written on Sept. 25, 2021, 5:45 p.m.</h5>

            
                <h5>Updated Dec. 1, 2021, 11:36 p.m.</h5>
            
        </p><div><h2>Overview</h2>

<p>Microcontrollers (MCUs) are ubiquitous in modern electronics. These combination hardware/software devices are called embedded devices, and their software is usually programmed in C or C++. <a href="https://www.rust-lang.org/">Rust</a> is a modern language that&#39;s recently become a viable alternative. This article explores Rust&#39;s capabilities on  embedded, and provides a starting point for writing firmware with it. It contains introductory information about embedded programming and Rust that you may already be familiar with; you may wish to scroll down and skip to the code examples.</p>

<p>This doesn&#39;t intend to be a tutorial, or suitable learning resource on its own. Its goals: Describe why you should consider Rust for new projects, provide an overview of common libraries, and provide code samples that cover the most important parts. Some topics overlap with the official <a href="https://docs.rust-embedded.org/book/">Rust embedded</a> and <a href="https://docs.rust-embedded.org/discovery/">Rust embedded discovery</a> books. These are great resources for getting started, and go into detail for experienced embedded engineers new to Rust, and people new to embedded respectively. This article&#39;s focus is on the architecture of practical firmware, and it describes tools and libraries that have been released after these books.</p>

<p>We wrote the Water Monitor firmware and Stove Thermometer using Rust, and plan to do the same for future devices, due to its memory safety and ergonomics.</p>

<h2>Rust compared to C and C++</h2>

<h3>Reasons not to use Rust</h3>

<p>C is the industry standard for embedded programming, and most embedded jobs use C, with a minority using C++. Hiring programmers proficient in Rust is much more difficult than in C or C++ due to the smaller user base. Example code, tools, and libraries released by MCU manufacturers are almost always for C or C++. The Rust embedded infrastructure is new, and rapidly changing.</p>

<p>Currently Rust on embedded only works well with <a href="https://developer.arm.com/ip-products/processors/cortex-m">ARM Cortex-M</a>-based MCUs. This will likely change soon, and Espressif/ESP-32 and RISC-V support are rapidly improving.</p>

<p>High-level library support is immature. Depending on your MCU, you may need to write your own abstractions, or work at the register level. This requires an understanding of the specific hardware capabilities and register layout, requires frequent reference manual (RM) checks, and makes switching MCUs more difficult. Some libraries make heavy use of generics and other verbose syntax.</p>

<p>The <a href="https://en.wikipedia.org/wiki/Lindy_effect">Lindy Effect</a>: A  phenomenon by which the future life expectancy of some things, like a technology or an idea, is proportional to their current age. If your project has a requirement that the tools used to build and flash your program be available in 10 or 20 years, C may be a better choice: It&#39;s long history (arguably) predicts a long future. This is a simplistic outlook, but often works.</p>

<h3>Reasons to use Rust</h3>

<p>Rust is a comparatively new language. It&#39;s learned from mistakes of existing languages, and has drawn inspiration from other languages, including C, C++, OCaml, and Haskell. It&#39;s one of a handful of languages capable of writing fast, low-level code: the type used to write drivers, operating systems, and embedded firmware. At this time, Rust is one of few viable alternatives to C and C++ in these domains. (Other alternatives include ADA, SPARK, and Zig.) Advantages of using Rust fall into two broad categories: memory management, and ergonomics.</p>

<h3>Memory safety</h3>

<p>Regarding memory management, most languages fall into one of 2 broad categories: Manually managed, and garbage-collected. C and C++ are examples of manually managed, and Python, Go, and Java are examples of garbage-collected languages. Languages with memory management run quickly, but care must be taken to prevent subtle errors. <a href="https://en.wikipedia.org/wiki/Memory_safety">This Wikipedia article</a> provides a overview of this class of error, and specific examples. Garbage-collected languages don&#39;t have this problem, but run comparatively slowly, and with inconsistent performance; they&#39;re not suitable for embedded. </p>

<p>Rust has a unique feature: It can run with the speed and fine control of manually managed, but can guarantee memory safety by using a borrow checker to validate references. This forces you to write programs in a memory-safe way; if you make a mistake, it&#39;s caught at compile time. Rust&#39;s <a href="https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html">ownership</a> model is responsible for this. From that docs page: &#34;Memory is managed through a system of ownership with a set of rules that the compiler checks at compile time. None of the ownership features slow down your program while it’s running.&#34;</p>

<p>In embedded, we often have to bypass Rust&#39;s ownership model to interact with hardware. This is confined to blocks marked as <code>unsafe{ }</code>. By carefully controlling code in these blocks and minimizing their use, we can write safe firmware. Rust&#39;s ownership model provides the biggest advantages when the heap is used, eg on PCs. On embedded, it&#39;s still useful for preventing concurrent access to the same memory. This can occur due to interrupt, DMA use, or additional cores attempting to access the same piece of memory (Eg a buffer, or peripheral register).</p>

<h3>Ergonomics</h3>

<p>Memory management is perhaps the most common reason people consider Rust. In embedded, ergonomics may be an even more compelling reason. Stated simply: Rust programs are (subjectively) easier to read and write. Compiling and flashing embedded C/++ firmware often requires complex tooling, and proprietary and/or expensive IDEs. Development may be tied to an IDE that allows access to MCU-specific features, at the cost of deficiencies as a code editor. Here are some features Rust provides:</p>

<ul>
<li>Official, standardized, automatically-published documentation for the Rust language, and third-party libraries: <a href="https://docs.rs/">Official docs page</a></li>
<li>A standardized tool used to compile and flash programs: <a href="https://doc.rust-lang.org/cargo/">Cargo</a></li>
<li>Official and included <a href="https://github.com/rust-lang/rustfmt">formatter</a> and <a href="https://github.com/rust-lang/rust-clippy">linter</a> </li>
<li>A standardized project structure and layout, including a project configuration file (cargo.toml) that contains publication metadata, and semvar dependencies</li>
<li>High level abstractions and data structures associated with modern languages</li>
<li>Easy compiling, flashing, and debugging</li>
</ul>

<p>Namespaced modules and imports make a big difference to code reading, writing, and maintenance.</p>

<p>Together, these make programming in Rust (including installation, setup, and config) a streamlined process. Rust has a reputation as a challenging, complex language due its its ownership model. Its official tooling, standards, and language features more than overcome this.</p>

<h2>Programming an MCU using Rust</h2>

<p>The next few sections of this article go over examples of programming an MCU using Rust, at various levels of abstraction. The <a href="https://docs.rust-embedded.org/book/">official Rust embedded book</a> provides more detailed information along these lines. It&#39;s a great resource for learning how to use embedded Rust, for those already familiar with embedded programming in C or C++.</p>

<p>In this article, we&#39;ll assume you&#39;re using an <a href="https://www.st.com/en/microcontrollers-microprocessors/stm32-32-bit-arm-cortex-mcus.html">STM32</a>. Most of the information here can be easily modified to work with other ARM Cortex-M processors. The general concepts will work with other architectures as well. The specific variant of STM32 doesn&#39;t matter much for the purpose of this article, and the code could be applied to any, with slight modifications.</p>

<p>Interaction with MCUs is usually done using <a href="https://developer.arm.com/documentation/102618/latest">memory mapped peripherals</a>. This means that <strong>to interact with an MCU peripheral (or an external one through an MCU communications protocol), you write to, or read from a memory address.</strong> This is an important concept: It illuminates the border between abstract computer logic, and interactions with the real world. The code examples below all do this; first directly, then through calling functions and methods that perform these writes and reads.</p>

<h2>Restrictions on Rust embedded, vice on a PC</h2>

<p>The most notable restrictions when programming Rust for an embedded target are the lack of a memory heap or allocator by default, and a more limited standard library. To indicated that your Rust program is intended to embedded, put this line towards the top of Cargo.toml: <code>#![no_std]</code>. When this is specified, you must use the <a href="https://doc.rust-lang.org/core/">Core library</a> instead of the Standard library. For supported features, use <code>core::</code> as the <code>use</code> syntax, instead of <code>std::</code>. Core is a subset of Standard, and its docs pages for shared features are identical.</p>

<p>Additionally, by default, the heap isn&#39;t available. In fact, there&#39;s no allocator, which means dynamic memory allocation (Like with <code>Vec</code> and <code>HashMap</code>) won&#39;t work. You can use the <a href="https://crates.io/crates/alloc-cortex-m">alloc-cortex-m library</a> if you wish to use an allocator. Alternatively, the <a href="https://docs.rs/heapless/0.7.7/heapless/">heapless library</a> allows use of data structures similar to <code>Vec</code> etc, without using a Heap. Instead, you specify their maximum size at initialization.</p>

<p>Without a stack or allocator, you might pass mutable <code>array</code> references as function parameters, in cases where you&#39;d otherwise return a <code>Vec</code>. Instead of generating a return <code>Vec</code> or <code>array</code>, the function modifies the output reference in-place.  In general, you&#39;ll make frequent use of (fixed-size) <a href="https://doc.rust-lang.org/std/primitive.array.html">arrays</a>.</p>

<h2>Getting started</h2>

<ul>
<li><a href="https://www.rust-lang.org/tools/install">Install Rust</a>.</li>
<li>Install the compilation target for your MCU. Ie, run <code>rustup target add thumbv7em-none-eabihf</code>.</li>
<li>Install flash and debug tools: <code>cargo install flip-link</code>, <code>cargo install probe-run</code>. Note that you can also use OpenOCD, although we think Knurling&#39;s tools here are easier to use.</li>
<li>Clone the <a href="https://github.com/David-OConnor/stm32-hal-quickstart">STM32-HAL quickstart repo</a>: <code>git clone https://github.com/David-OConnor/stm32-hal-quickstart</code>. Note that this is a thin wrapper over the <a href="https://github.com/knurling-rs/app-template">Knurling App Template</a>. The specific Hardware Abstraction Layer (HAL) library used here will help with our higher-level examples, but makes no difference for our first few.</li>
</ul>

<p>Alternatively, you can create a new project using <code>cargo new --lib projectname</code>, and add the required code. An advantage of using a template like above is it provides some boilerplate needed to work with Embedded, like <code>.config.TOML</code> to specify the compiler target, and <code>memory.x</code> to specify your MCU&#39;s amount of flash and RAM. It&#39;s likely you&#39;ll end up with your own template or templates tailored to your specific use case or MCU.</p>

<p>The main program code lives in <code>src/main.rs</code>. It includes setup code to make your program work with the Knurling debug and flash tools, and example imports for the high-level API we&#39;ll use later in this article.</p>

<p>You don&#39;t need a special IDE to write and flash embedded using Rust: You can write in your code editor of choice, and use a terminal to compile and flash your code (run <code>cargo run --release</code>). The <a href="https://www.jetbrains.com/rust/">IntelliJ Rust plugin</a> is very nice, and is compatible with any IntelliJ IDE, including CLion and PyCharm. VsCode with the <a href="https://marketplace.visualstudio.com/items?itemName=matklad.rust-analyzer">rust-analyzer</a> plugin is another good choice.</p>

<h2>Flashing and debugging</h2>

<p>When using the setup created above, to compile and flash, run <code>cargo run --release</code>. Or shorthand: <code>cargo r --release</code>. Using <a href="https://doc.rust-lang.org/book/ch14-01-release-profiles.html">release mode</a> takes longer to compile than without, but using non-release-mode firmware can lead to performance and memory problems. Generally, compiling Rust programs takes longer than compiling an equivalent C program. To compile without flashing, run <code>cargo build --release</code>, or <code>cargo b --release</code>. </p>

<p>This works due to the <a href="https://github.com/knurling-rs/probe-run">probe-run</a> tool we installed, in conjunction with the <code>.cargo/config.toml</code> file provided in the template.  You may need to change the <code>runner</code> and <code>target</code> lines in accordance with your MCU, as described in comments on those lines. Ie, to set the runner, run <code>probe-run --list-chips</code>, and copy+paste yours. Comment in or out the <code>target</code> line associated with your Cortex-M version. For example, <code>thumbv7em-none-eabihf</code> for Cortex-M4, <code>thumbv6m-none-eabi</code> for Cortex-M0 or M0+, and <code>thumbv8m.main-none-eabihf</code> for Cortex-M33. You can remove the <code>hf</code> suffixes if you don&#39;t intend to use hardware floats. (Operations on float types without hardware floats enabled will be comparatively slow.)</p>

<p>For flashing finalized firmware for production, you may want to create a standalone binary. One way to do this is with <a href="https://github.com/rust-embedded/cargo-binutils">cargo-binutils</a>, which you can install with this command: <code>cargo install cargo-binutils</code>. You can then compile a standalone binary with this command: <code>cargo objcopy --release -- -O binary target/firmware.bin</code>. You can then use a tool like Stm32CubeProgrammer, or dfu-util to flash an MCU. This is also useful if you intend to flash using USB.</p>

<p>To print to the terminal using the setup above, we can use <code>defmt</code> commands like this: <code>defmt::println!(&#34;Pin state: {}&#34;, pin_state);</code>, or <code>defmt::error!(&#34;Oh no!&#34;);</code>. For detailed information on debugging capabilities, check out <a href="https://defmt.ferrous-systems.com/">Defmt&#39;s official guide</a>.</p>

<h2>Writing registers directly</h2>

<p>Your main program logic in this example will live in the project directly created above, under <code>src/main.rs</code>. It uses the <a href="https://docs.rs/cortex-m/0.7.3/cortex_m/">Cortex-M library</a> as a backbone, and can perform computations. To interact with the world (input/output) you&#39;ll usually use peripherals on your MCU, including General Purpose Input/Output (GPIO) pins, analog-to-digital and digital-to-analog (ADC and DAC) peripherals, and communication protocol peripherals like SPI, I²C, and UART.</p>

<p>We cross the barrier between abstract computer code, and interaction with the world by writing to and reading from memory addresses in our microcontroller. They&#39;re listed in your MCU&#39;s reference manual (RM) (Or perhaps called <em>Datasheet</em> or <em>Product Specification</em>). On STM32, you need to look in 2 RM sections: the Memory Organization section near the top to find peripheral base addresses, and the register tables (at the end of each peripheral-specific chapter) to find the offset of each register. You can find the register address using an OR (|) operation between the base address and offset.</p>

<p><strong>The following example uses a low-level API that&#39;s not practical for application code, and may be confusing to new users. You may wish to go directly to the <em>Writing registers using a Peripheral Access Crate</em>, or <em>High level abstractions</em> sections: They&#39;re more practical.</strong></p>

<p>We&#39;ll use GPIO pins as an example, since they&#39;re easy to work with on STM32. To write to a register using Rust, we use the <a href="https://doc.rust-lang.org/core/ptr/fn.write_volatile.html">ptr::write_volatile</a> function. From that docs page: <code>write_volatile</code> &#34;Performs a volatile write of a memory location with the given value without reading or dropping the old value. Volatile operations are intended to act on I/O memory, and are guaranteed to not be elided or reordered by the compiler across other volatile operations.&#34; We wrap this call in an unsafe block, because we&#39;re bypassing Rust&#39;s memory-safety guarantees. This is required here, and won&#39;t cause problems unless another process (like an interrupt returning, DMA, or an additional MCU core) attempts to access the same memory location before these operations complete.</p>

<p>The abstractions we&#39;ll build in later sections build on top of the <code>read_volatile</code> and <code>write_volatile</code> commands. They&#39;ll have a different API, and application code will look different, and have a different structure - but they&#39;re ultimately wrapping these same commands and addresses.</p>

<p>Before we start, here&#39;s a table excerpt from the <a href="https://www.st.com/resource/en/reference_manual/dm00314099-stm32h742-stm32h743-753-and-stm32h750-value-line-advanced-arm-based-32-bit-mcus-stmicroelectronics.pdf">STM32H743 RM</a>, which shows the MODER address offset, what fields are available, and what value each field can take. Note that the GPIOA port base address is listed earlier in the RM - we OR (|) that with the offset listed in the table. Also note that in our code, we use binary and hex notation, even for simple integers, for consistency with the RM. (Technique only! Feel free to us base-10 integers.) Can you see how values in (and above and below) the table correspond to the code below?</p>

<p><img src="https://omarish.com/static/images/blog/moder_register.png" alt="Graph of pH and voltage"/></p>

<p>This code goes in your <code>main</code> function, which of note, always ends in a loop. (Which is enforced by its <code>!</code> type signature). We enable our GPIO port&#39;s peripheral clock, configure our pins as required, and change and/or read their value. Note that on some MCUs, this process is simpler, and may not required enabling a peripheral clock.</p>

<div><pre><span>#[entry]</span>
<span>fn</span> main() -&gt; ! {
    <span>// Set up named variables for the register addresses we&#39;ll use. These are defined in the STM32&#39;s</span>
    <span>// reference manual (RM). You can find base addresses under the Memory and bus architecture chapter, and the offsets (Things we | the base addresses with), under the RCC and GPIO chapters, registers sections.</span>

    <span>let</span> RCC_AHB2ENR = <span>0x58024400</span> | <span>0x0DC</span>;
    <span>let</span> GPIOA_BASE = <span>0x48001018</span>;

    <span>// You can find these offsets under each RM register table: `Address Offset`</span>
    <span>let</span> GPIOA_MODER = GPIOA_BASE | <span>0x00</span>;
    <span>let</span> GPIOA_BSRR = GPIOA_BASE | <span>0x18</span>;
    <span>let</span> GPIOA_IDR = GPIOA_BASE | <span>0x10</span>;

    <span>let</span> gpioaen_field = <span>0</span>;
    <span>let</span> output_pin_num = <span>1</span>;  <span>// A variable to indicate with GPIO pin number we&#39;re using. Ie PA1.</span>
    <span>let</span> input_pin_num = <span>2</span>; <span>// ie PA2.</span>

    <span>unsafe</span> {
        <span>// Set the GPIOAEN field of the RCC register block, AHB2_ENR register. This enables the peripheral clock</span>
        <span>// to all pins on the GPIOA port.</span>
        ptr::write_volatile(RCC_AHB2ENR <span>as</span> *<span>mut</span> <span>u32</span>, <span>1</span> &lt;&lt; gpioaen_field);

        <span>// Set the mode of PA1 to Output, and PA2 to input. The hex values 0b01 and 0b00 (1 and 0) are defined in the GPIO registers section of the RM, under GPIO port mode register (GPIOx_MODER).</span>
        <span>// We Multiply the pin numbers by 2, since each field of this register is 2 bits wide. Also note that we  perform a register read, as not to override previous settings. </span>

        Let <span>mut</span> existing_val = ptr::read_volatile(GPIOA_MODER <span>as</span> *<span>const</span> <span>u32</span>);
        <span>// We use binary arithmetic here to 0 out the fields we’ll write to. Modifying single-bit fields is simpler.</span>
        existing_val = existing_val &amp; !(<span>0b11</span> &lt;&lt;  output_pin_num * <span>2</span>) &amp; !(<span>0b11</span> &lt;&lt;  input_pin_num * <span>2</span>) 

        ptr::write_volatile(
            GPIOA_MODER <span>as</span> *<span>mut</span> <span>u32</span>, 
            existing_val | (<span>0b01</span> &lt;&lt; (output_pin_num * <span>2</span>)) | (<span>0b00</span> &lt;&lt; (input_pin_num * <span>2</span>))
        );

        <span>// Write to the GPIOA bit set/reset register. These writes are atomic, so won&#39;t experience</span>
        <span>// concurrency issues; no further action is required to ensure safe access across interrupts etc.</span>
        ptr::write_volatile(GPIOA_BSRR <span>as</span> *<span>mut</span> <span>u32</span>, <span>1</span> &lt;&lt; output_pin_num);

        <span>// Read from the GPIOA Input Data Register, and extract the value associated with PA2.</span>
        <span>let</span> input_state = ptr::read_volatile(GPIOA_IDR <span>as</span> *<span>const</span> <span>u32</span>) | (<span>1</span> &lt;&lt; input_pin_num);
    }
    <span>loop</span> {}
}
</pre></div>

<h2>Writing registers using a Peripheral Access Crate</h2>

<p>The code above is unsuitable for writing firmware directly with. Libraries are available that provide named access to registers and fields. These are conventionally called Peripheral Access Crates (PAC). These are generated from SVD files, as defined in the <a href="https://www.keil.com/pack/doc/CMSIS/SVD/html/index.html">Cortex-M CMSIS-SVD library</a>. For example, the <a href="https://docs.rs/stm32l4/0.13.0/stm32l4/">STM32L4 library</a> provides this for STM32L4 MCUs. </p>

<p>For some peripherals on STM32 like GPIO this is straightforward. For communications protocols, many separate operations are required, so using PACs directly isn&#39;t ideal. Other MCUs, like Nordic&#39;s nRF series make this easier; their direct register writes are more powerful, while STM32 peripherals rely on recipe-like sections described in their reference manuals. Most peripherals beyond GPIO include more complex config and setup steps, also described in the RMs.</p>

<p>Here&#39;s the above GPIO code, written using a PAC. Note that the syntax uses closures. This is to allow changing multiple fields on the same register, without using different syntax.</p>

<div><pre><span>use</span> stm32l4::pac::{RCC, GPIOA};

<span>#[entry]</span>
<span>fn</span> main() -&gt; ! {
    <span>let</span> <span>mut</span> dp = pac::Peripherals::take().unwrap();

    <span>// Enable the GPIOA peripheral clock as above.</span>
    dp.RCC.ahb2enr.modify(|_, w| w.gpioaen().set_bit());

    <span>// Set PA1 to output, and PA2 to input, as before. Note this simpler syntax that doesn’t</span>
    <span>// require knowing memory addresses. It performs a read, then write, as before, since writing this</span>
    <span>// register overwrites previous bits; that’s what the `modify` method is for.</span>
    dp.GPIOA.moder.modify(|_, w| {
        w.moder1().bits(<span>0b01</span>);
        w.moder2().bits(<span>0b00</span>)
    );

    <span>// The BSRR register is defined as ST as atomic write; you can set a specific bit by</span>
    <span>// writing without performing a read, as `modify` does; this won&#39;t affect other bits.</span>
    dp.GPIOA.bsrr.write(|w| w.bits(<span>1</span> &lt;&lt; output_pin_num));

    <span>// Read from the GPIOA Input Data Register, and extract the value associated with PA2.</span>
    <span>let</span> input_state = dp.GPIOA.idr.read().idr2().bit_is_set();

    <span>loop</span> {}
}
</pre></div>

<p>As before, compare to the RM table posted above for an example of the registers, fields, and values we&#39;re using.</p>

<p>Note how the above code is more concise, doesn&#39;t require manually looking up addressed, and doesn&#39;t require the <code>unsafe</code> keyword. It&#39;s more sustainable in production code, and is similar to <em>Low Level (LL)</em> code APIs in C. An alternative approach is provided in the <a href="https://github.com/adamgreig/stm32ral">STM32 Register Access Layer</a> library. This leverages Rust macros to provide a terse syntax.</p>

<p>PACs may or may not be practical for application code, depending on your use case, and how complicated your hardware and peripherals are. They have a distinct advantage compared to other levels of abstraction of mapping directly to RM descriptions.</p>

<h3>Using a Peripheral Access Crate to implement a RM procedure</h3>

<p>We&#39;ll now use a PAC to implement a series of steps in a RM. In this example, we demonstrate how to configure the UART peripheral in transmission mode. This is intended as a broadly-applicable example of how to set up a peripheral - the same structure and PAC library can be use to set up any peripheral, and similar PACs are available (Or can be built from SVD files) for any ARM MCU:</p>

<div><pre><span>#[derive(Clone, Copy)]</span>
<span>#[repr(u8)]</span>
<span>/// The number of stop bits to use. Sets the CR2 register, STOP field.</span>
<span>pub</span> <span>enum</span> StopBits {
    <span>/// 1 stop bit</span>
    S1 = <span>0b00</span>,
    <span>/// Half a stop bit</span>
    S0_5 = <span>0b01</span>,
    <span>/// 2 stop bits</span>
    S2 = <span>0b10</span>,
    <span>/// 1 and a half stop bits</span>
    S1_5 = <span>0b11</span>,
}

<span>// ... The other Config enums are similar.</span>

<span>/// Configuration for Usart. Can be used with default::Default.</span>
<span>pub</span> <span>struct</span> UsartConfig {
    <span>pub</span> word_len: WordLen,
    <span>pub</span> stop_bits: StopBits,
    <span>pub</span> oversampling: OverSampling,
    <span>pub</span> parity: Parity,
}

<span>// ...</span>

<span>/// Set up UART transmission. See STM32L443 RM, section 38.5.2: &#34;Character Transmission Procedures&#34;.</span>
<span>pub</span> <span>fn</span> setup_transmission(regs: &amp;<span>mut</span> R, baud: <span>u32</span>, config: UsartConfig, clock_cfg: &amp;Clocks) 
    where R: Deref&lt;Target = pac::usart1::RegisterBlock&gt; {   

    <span>// 1. Program the M bits in USART_CR1 to define the word length.</span>
    <span>let</span> word_len_bits = config.word_len.bits();
    regs.cr1.modify(|_, w| {
        w.over8().bit(config.oversampling <span>as</span> <span>u8</span> != <span>0</span>);
        w.pce().bit(config.parity != Parity::Disabled);
        <span>// M0 and M1 bits are on separate, non-adjacent fields, so we need 2 separate </span>
        <span>// commands to modify them.</span>
        w.m1().bit(word_len_bits.<span>0</span> != <span>0</span>);
        w.m0().bit(word_len_bits.<span>1</span> != <span>0</span>);
        w.ps().bit(config.parity == Parity::EnabledOdd)
    });

    <span>// 2. Select the desired baud rate using the USART_BRR register.</span>
    set_baud(baud, clock_cfg); <span>// (Setting up the baud rate has its own details!)</span>

    <span>// 3. Program the number of stop bits in USART_CR2.</span>
    regs.cr2.modify(|_, w| w.stop().bits(config.stop_bits <span>as</span> <span>u8</span>));

    <span>// 4. Enable the USART by writing the UE bit in USART_CR1 register to 1.</span>
    regs.cr1.modify(|_, w| w.ue().set_bit());

    <span>// 5. Select DMA enable (DMAT[R]] in USART_CR3 if multibuffer communication is to take</span>
    <span>// place. Configure the DMA register as explained in multibuffer communication.</span>
    <span>// (Handled in `read_dma()` and `write_dma()` functions)</span>

    <span>// 6. Set the TE bit in USART_CR1 to send an idle frame as first transmission.</span>
    regs.cr1.modify(|_, w| w.te().set_bit());
}
</pre></div>

<p>This is similar to what <code>STM32-HAL</code> does in its <code>Usart::new</code> constructor. In this case, we&#39;ve set it up as a standalone function, and have left out a few things like baud-rate and DMA config, as well as all but one config enum, for simplicity. Rust enums are an elegant way to define what possible value each field can take. The value we assign to each variant (in conjunction with the <code>repr(u8)</code> line) matches the bit value from the RM. Note that we use doc comments to show which register and field the enum controls, and copy+paste each value&#39;s description from the RM.</p>

<p>In the procedure itself, we cite where in the RM each step came from before we perform it, so it&#39;s easy to cross check that the procedure is correct, or identify errors if we encounter problems in use. Using this approach is a viable alternative to a HAL - ie creating your own functions and structs that perform the steps you need. This has the advantage of tighter control over what code your device runs, at the expense of more work upfront - especially if your project requirements change.</p>

<p>Note the line <code>Deref&lt;Target = pac::usart1::RegisterBlock&gt;</code>, and its associated generic parameter <code>R</code>. This is a consequence of how the PACs (and the manufacturer-provided SVDs they&#39;re built from) handle similar peripherals. It allows you to use the same code for the USART1, USART2 etc peripherals, instead of tying it to one in particular.</p>

<p>Also note that we perform additional configuration steps under the *Step 1`. These aren&#39;t explicitly listed in the RM&#39;s transmission procedure, but use the same register - so it makes sense to set them up here, for efficiency, and code simplicity. (The whole register needs to be written even if we only need to change one field.)</p>

<h2>High level abstractions</h2>

<p>For application code, higher-level abstractions are more suitable, but may or may not be available for a given MCU. This is an area that&#39;s actively improving in Rust. Our devices are programmed using the <a href="https://github.com/David-OConnor/stm32-hal">STM32-HAL library</a>, which we created for this purpose. It provides a level, ergonomic API for configuring and using peripherals. There are similar libraries available for MCUs, in varying states of robustness and maturity. For example, if you&#39;re using a Nordic MCU, check out <a href="https://github.com/nrf-rs/nrf-hal">nrf-RS nRF-HAL</a>. These libraries wrap the PACs with a higher-level, more intuitive API.</p>

<p>Here&#39;s an example of it in use. For its full API, check out the <a href="https://docs.rs/stm32-hal2/latest/stm32_hal2/">STM32-HAL docs</a>.</p>

<div><pre><span>use</span> stm32_hal2::gpio::{Pin, PinMode, Port};

<span>#[entry]</span>
<span>fn</span> main() -&gt; ! {
    <span>let</span> output_pin = Pin::new(Port::A, <span>1</span>, PinMode::Output);
    <span>let</span> input_pin = Pin::new(Port::A, <span>2</span>, PinMode::Input);

    output_pin.set_high();
    <span>let</span> input_state = input_pin.is_high();

    <span>loop</span> {}
}
</pre></div>

<p>Note that we don&#39;t need to explicitly enable the GPIOA peripheral clock here; the <code>Pin&#39;s</code> <code>new</code> constructor handles that, as indicated by <a href="https://docs.rs/stm32-hal2/latest/stm32_hal2/gpio/struct.Pin.html#method.new">its documentation</a>. That page shows other methods available for the <code>Pin</code> struct - these are mostly configuration options for the given GPIO config, and match those listed in the RM. Many of the settings here (and in other modules of this library) use Rust enums to configure. They are set to explicit <code>u8</code> types associated with their associated bit values. Their You can look at the documentation for the associated enum, or the associated RM entry. For example, <a href="https://docs.rs/stm32-hal2/latest/stm32_hal2/gpio/enum.OutputSpeed.html">here is documentation for the OutputSpeed enum</a>, used with the <code>.output_speed()</code> method.</p>

<p>Now let&#39;s look at an example function that takes a measurement from an external ADC, the <a href="https://omarish.com/www.ti.com/lit/ds/symlink/ads1115.pdf">TI ADS1115</a>. This code is used in the <a href="https://omarish.com/water-monitor">Water Monitor</a> firmware. Note that MCUs like the STM32 usually include onboard ADCs. In this case, we use an offboard ADC, since this particular one provides higher-accuracy readings.</p>

<div><pre><span>const</span> CFG_REG: <span>u8</span> = <span>0x1</span>;
<span>const</span> CONV_REG: <span>u8</span> = <span>0x0</span>;

<span>// ...</span>

<span>/// Take a measurement from an external ADS1115 ADC, using the I²C peripheral.</span>
<span>fn</span> take_reading(addr: <span>u8</span>, cmd: <span>u16</span>, i2c: &amp;mut stm32_hal::I2c&lt;I2C1&gt;) -&gt; <span>i16</span> {
    <span>let</span> <span>mut</span> result_buf: [<span>u8</span>; <span>2</span>] = [<span>0</span>, <span>0</span>];

    <span>// Set up the cfg, and command a one-shot reading. Note that we</span>
    <span>// pass the 16-bit i2c command as 2 bytes.</span>
    i2c.write(addr, &amp;[CFG_REG, (cmd &gt;&gt; <span>8</span>) <span>as</span> <span>u8</span>, cmd <span>as</span> <span>u8</span>]).ok();

    <span>// Wait until the conversion is complete.</span>
    <span>let</span> <span>mut</span> converting = <span>true</span>;
    <span>let</span> <span>mut</span> buf = [<span>0</span>, <span>0</span>];
    <span>while</span> converting {
        i2c.write_read(addr, &amp;[CFG_REG], &amp;<span>mut</span> buf).ok();
        <span>// First of 16 cfg reg bits is 0 while converting, 1 when ready. (when reading)</span>
        converting = buf[<span>0</span>] &gt;&gt; <span>7</span> == <span>0</span>;
    }

    <span>// Read the result from the conversion register.</span>
    i2c.write_read(addr, &amp;[CONV_REG], &amp;<span>mut</span> result_buf).ok();

    <span>// Convert the 2 8-bit integers from the result into a single 16-bit signed integer.</span>
    <span>i16</span>::from_be_bytes([result_buf[<span>0</span>], result_buf[<span>1</span>]])
}
</pre></div>

<p>To understand what&#39;s going on here, we need to reference the ADS1115 datasheet linked above. Note that this is a blocking API: The whole program is frozen during the time it takes to perform the conversion (See the <code>while converting</code> loop). For our purpose here, this is acceptable, since we&#39;re taking one reading from each ADC at a relatively low frequency. If we needed to perform a sequence of readings, or continuous readings, we&#39;d use interrupts, or even better, DMA, instead of a blocking loop.</p>

<p>Also note that we return an <code>i16</code>: A signed integer, since this is a differential reading. Note that the <code>cmd</code> command argument configures the ADC, and takes a reading, IOC the ADC&#39;s datasheet. Also note that both reading and writing is performed 8 bits at a time, IOC the I2C protocol, and the ADC&#39;s datasheet.</p>

<p>The <code>.ok()</code> suffixes are due to the <code>I2C</code> <a href="https://docs.rs/stm32-hal2/latest/stm32_hal2/i2c/struct.I2c.html">read and write methods</a> having the potential to return an error state generally, although we don&#39;t expect to encounter that here. Note the <code>write_dma</code> and <code>read_dma</code> methods also available on that page.</p>

<p>If you examine the function signature, you&#39;ll see this line: <code>i2c: &amp;mut I2c&lt;I2C1&gt;</code>, in addition to the I2C device address and command we&#39;re sending. This is a mutable reference to the HAL library&#39;s <a href="https://docs.rs/stm32-hal2/latest/stm32_hal2/i2c/struct.I2c.html">I2c struct</a>. We can see from that page that we initialize it with its <code>new</code> constructor. Included also is our clock setup boilerplate, initializing to a safe default that varies based on the MCU used:</p>

<div><pre><span>let</span> clock_cfg = Clocks::default();
clock_cfg.setup().unwrap();

<span>let</span> i2c = I2c::new(dp.I2C1, Default::default(), &amp;clock_cfg);

<span>// ...</span>

<span>let</span> reading = take_reading(PH_ADC_ADDR, PH_READ_CMD, &amp;<span>mut</span> i2c);
</pre></div>

<p>This initializes the I2C peripheral with default settings, since we replace the <code>cfg</code> parameter with its default implementation. To see what other configuration options are available, you can view the <a href="https://docs.rs/stm32-hal2/latest/stm32_hal2/i2c/struct.I2cConfig.html">I2cConfig&#39;s docs page</a>. Here&#39;s an example config that modifies the noise filter and speed settings of the default config:</p>

<div><pre><span>let</span> i2c_cfg = I2cConfig {
    speed: I2cSpeed::Fast400K, <span>// Set to Fast mode, at 400Khz.</span>
    <span>// Set a digital noise filter instead of the default analog one.</span>
    noise_filter: NoiseFilter::Digitial(<span>5</span>),
    ..Default::default()
};
</pre></div>

<p>The first argument to <code>I2c::new</code> is the PAC structure that allows (exclusive-by-default) access to modify the registers. This helps to prevent race conditions. The second argument indicates which of the several I2C peripherals is being used - lets the library know which peripheral clock to enable. The final <code>&amp;clock_cfg</code> argument passes information about how the MCU&#39;s clocks are configured, so it can properly set the I2C peripheral&#39;s speed using scalers.</p>

<p>This peripheral configuration is specific to STM32&#39;s I²C using the <code>STM32-HAL</code> library, but can be applied more broadly: All peripherals in this library use the same basic API. Other HAL libraries use different syntax, but accomplish the same basic tasks.</p>

<p>On STM32, you need to configure pins associated with a peripheral with the suitable <em>alternate function</em>. Other MCUs often require a similar process. For example, nRF MCUs require setting the peripherals <code>PSEL</code> register to identify the pins used. I²c generally also requires SDA and SCL lines to be pulled high, and set as open drain. On many variants, pins PB6 and PB7 can be used as SCL and SDA pins respectively, when set as Alternate Function 4. (Check your MCU&#39;s user manual for this information; on STM MCUs, this is separate from the RM, and is more specific). Given the example GPIO code above, and the <a href="https://docs.rs/stm32-hal2/latest/stm32_hal2/gpio/struct.Pin.html">STM32-HAL GPIO Pin docs</a>, can you figure out how to set up the pins? You need to set the alternate mode, make them pullup using software, and configure as open drain. You can use any of the 3 APIs above. The HAL code will be the most concise, and can be determined using that docs page alone.</p>

<h2>Interrupts</h2>

<p>In practice, much of embedded application code occurs in <a href="https://en.wikibooks.org/wiki/Embedded_Systems/Interrupts">interrupts</a>, which call functions called Interrupt Service Routines (ISR) when specific events occur. These pause other code as required to run. ISRs can also <em>interrupt</em> other ISRs of lower priority.</p>

<p>The code above include an empty loop at the end of their <code>main</code> functions. This causes continual power use from the MCU. In order to prevent this, you can use the Cortex-M <em>wait for interrupt</em> (WFI) instruction. This causes the MCU core to enter a low power mode until an interrupt occurs. You can do this by adding this code instead:</p>

<div><pre>use cortex_m::asm::wfi;

<span>// ...</span>
<span>#[entry]</span>
<span>fn</span> main() -&gt; ! {
    <span>// ...</span>
    <span>loop</span> {
        wfi();
    }
}
</pre></div>

<p>Different MCUs handle low power modes in different ways, but this often enters a basic low power mode. On STM32, by default, this configures a mode called <code>sleep</code>, or <code>sleep now</code>. You can also use the <code>STM32-HAL</code> function <code>low_power::sleep_now()</code>, which ensures the appropriate configuration is set, then enters WFI. (In case you&#39;d previously set it to go into a deeper low power mode upon <code>wfi</code>.)</p>

<p>Interrupts pause execution of other code (such as the main loop), in order to run specific code. They can be triggered by various events, including timers expiring, ADC conversions being ready, FIFO buffers for various peripherals being filled, errors occurring etc. The specifics depend on the MCU. T</p>

<p>To enable a specific interrupt, it usually needs to be configured by the peripheral. In addition, it needs to be unmasked, eg using the Cortex-M NVIC system. The following excerpt shows how to unmask an interrupt, and set its priority, using the <code>cortex-m</code> library. This should go in your <code>main</code> function, above the infinite loop. You may need to place this right above the main loop, to prevent ISRs from running before you initialize peripherals and state.</p>

<div><pre><span>unsafe</span> {
    NVIC::unmask(pac::Interrupt::TIM2);
    cp.NVIC.set_priority(pac::Interrupt::TIM2, <span>1</span>);
}
</pre></div>

<p>Note that lower-valued priority values have a &#34;higher&#34; priority.  When an interrupt occurs, an Interrupt Service Routine (ISR) runs - this is a type of function.</p>

<div><pre><span>#[interrupt]</span>
<span>/// This ISR runs when Timer 2 expires.</span>
<span>fn</span> TIM2() {
    <span>// You may need to clear an interrupt flag here, depending on MCU and peripheral.</span>
    defmt::println!(<span>&#34;Timer 2 expired!&#34;</span>);
}
</pre></div>

<p>The above code is agnostic to any Cortex-M MCU, while the code that configures a given peripheral to generate an interrupt depends on the MCU and peripheral. Note that you may need to clear an interrupt flag in the ISR depending on the peripheral, or the ISR will continuously run. Here&#39;s an example of setting up a timer and its interrupt, using <code>STM32-HAL</code>:</p>

<div><pre><span>let</span> <span>mut</span> debounce_timer = Timer::new_tim2(dp.TIM12, <span>10.</span>, &amp;clock_cfg);
debounce_timer.enable_interrupt(TimerInterrupt::Update);
</pre></div>

<p>This enables Timer 2, sets it to repeatedly count down with frequency of 10Hz. (0.1s period), The timer triggers an interrupt each time it counts down. This means the associated ISR will run 10 times each second.</p>

<p>If an interrupt of higher priority triggers while this ISR is running, this ISR will pause execution until the higher-priority interrupt&#39;s ISR completes, then resume where it left off. (Note that any interrupt will pause the main loop&#39;s code until it completes). If a lower or equal priority interrupt triggers, this ISR will complete first, then the new interrupt&#39;s ISR will run.</p>

<p>Interrupts can be used to wake up devices from low power states. The specific depends on your MCU, and the low power state being used. Battery-powered devices often run in a low power mode by default, periodically wake up to run an ISR, then go back to the low power mode. Lighter low power modes (Like <em>sleep</em> on STM32) are fast to enter and exit, and are easy to use. Deeper states like <code>stop</code> and <code>standby</code> take longer to exit from, may require re-configuring peripherals like clocks, and may not preserve RAM contents.</p>

<h2>DMA</h2>

<p>Direct Memory Access (DMA) allows peripherals to communicate with each other, and with memory without direct intervention
from the CPU. They can perform tasks that could also be done with ISRs, but without interrupting other code execution. This
is very useful for performance-critical, and low-power applications. It&#39;s especially useful when sending or receiving large buffers of data.</p>

<p>Examples of when you may want to use DMA</p>

<ul>
<li>Send a display buffer over SPI</li>
<li>Set up a sequence of ADC conversions</li>
<li>Trigger a DAC write at a fixed time interval, like for audio</li>
</ul>

<p>With DMA, you can initiate a transfer to or from an array, then do other tasks without waiting for the transfer to complete.</p>

<p>DMA has the potential to cause concurrency problems. For example, let&#39;s say you pass a (pointer to a) array to be updated by a peripheral using DMA. DMA by nature runs simultaneously with other code - that&#39;s one of its big advantages. If you modify the buffer before the write completes, or drop it from memory, you may get undefined behavior, or a crash. Here&#39;s an example of code using DMA to trigger a DAC write from a buffer. We use a timer to trigger the writes:</p>

<div><pre>    <span>let</span> <span>mut</span> dac_timer = Timer::new_tim6(dp.TIM6, timer_freq, &amp;clock_cfg);

    <span>//  The update event is selected as a trigger output (TRGO). For instance a</span>
    <span>// master timer can then be used as a prescaler for a slave timer.</span>
    dac_timer.set_master_mode(MasterMode::Update);

    <span>let</span> <span>mut</span> dac = Dac::new(dp.DAC, DacBits::TwelveR, <span>3.3</span>);
    dac.set_trigger(DacChannel::C1, Trigger::Tim6);

    <span>let</span> <span>mut</span> dma = Dma::new(dp.DMA1);

    dma::mux(DmaChannel::C3, DmaInput::DacCh1, &amp;<span>mut</span> dp.DMAMUX1);

    <span>// Load the Sine LUT into a DMA circular buffer, which will send a 16-byte word of data</span>
    <span>// to the DAC on each timer trigger. Because it&#39;s a circular buffer, it will start at</span>
    <span>// the first value again once complete.</span>
    <span>let</span> channel_cfg = dma::ChannelCfg {
        circular: dma::Circular::Enabled,
        ..Default::default()
    };

    <span>unsafe</span> {
        dac.write_dma(
            &amp;SIN_X,
            DacChannel::C1,
            DmaChannel::C3,
            channel_cfg,
            &amp;<span>mut</span> dma,
        );
    }

    dac.enable(DacChannel::C1);
    dac_timer.enable();
</pre></div>

<p>This code sends a word from the <code>SIN_X</code> array to the DAC every time Timer 6 expires. When it reaches the end of the array, it starts again at the beginning. In this case, we&#39;ve defined our buffer as a static variable. Let&#39;s say instead, this code were in a function, and we&#39;d used a local variable for the buffer. The buffer would dissapear when the function finished running, but the DMA peripheral would continue to attempt to access that memory location, leading to undefined behavior, or crashes.</p>

<p>Another way we can get into trouble with DMA is setting the DMA to write to a mutable buffer, then manually modifying that buffer before the write completes.</p>

<p>The <a href="https://github.com/rust-embedded/embedded-dma">embedded-dma</a> library provides Traits that attempt to provide memory-safe interfaces for DMA. When used properly, these should guarantee race-free DMA use. I don&#39;t know if there is a good reference implementation at this time.</p>

<h2>Avoiding race conditions</h2>

<p>Concurrency can lead to state variables, memory-buffers, and other data structures being requested by multiple segments of code at arbitrary times. If more than one piece of code attempts to access the same resource simultaneously, undefined
behavior can occur. There are several ways we can deal with this.</p>

<h3>Atomic types</h3>

<p>From the <a href="https://doc.rust-lang.org/core/sync/atomic/">Rust documentation on Atomic types</a>: &#34;Atomic types provide primitive shared-memory communication between threads, and are the building blocks of other concurrent types.&#34; These work the same was atomics in other languages, and their ordering system is the same as <a href="https://en.cppreference.com/w/cpp/atomic/memory_order">C++&#39;s</a>.</p>

<p>Bottom line: using atomic types is slightly verbose and has subtleties (beyond the scope of this article), but is the best way to safely share integers and booleans between contexts. They&#39;re not suitable for more complicated types like structs.</p>

<div><pre><span>use</span> core::sync::atomic::{AtomicBool, Ordering};

<span>static</span> READY: AtomicBool = AtomicBool::new(<span>false</span>);

<span>// ..</span>

    <span>let</span> ready = READY.load(Ordering::Acquire) {

    READY.store(<span>true</span>, Ordering::Release);
</pre></div>

<p>Atomic types have a number of methods that allow various forms of safe manipulation. Here are the docs for <a href="https://doc.rust-lang.org/core/sync/atomic/struct.AtomicBool.html">AtomicBool</a> and <a href="https://doc.rust-lang.org/core/sync/atomic/struct.AtomicU8.html">AtomicU8</a>. These can be tricky to learn, but should be your default way of handling mutable global integers and booleans. Unlike Mutexes below, they don&#39;t require critical sections.</p>

<h3>Mutexes and critical sections</h3>

<p>For managing access to resources that don&#39;t have atomic types (eg structs, like the ones we used to manage peripherals above), we can use Mutexes to ensure only one resource has access at a time. Two Cortex-M features are useful here: <a href="https://docs.rs/cortex-m/0.7.3/cortex_m/interrupt/struct.Mutex.html">mutex</a> and <a href="https://docs.rs/cortex-m/0.2.12/cortex_m/interrupt/fn.free.html">Critical sections</a>. Note that this is different from the mutex in Rust&#39;s standard library.</p>

<p>A mutex, short for Mutual Exclusion, can be thought of as a lock, preventing access to the resource under normal circumstances. <a href="https://en.wikipedia.org/wiki/Mutual_exclusion">This Wikipedia article</a> goes into detail. No interrupts are allowed to interfere with critical sections - mutexes can be accessed in these. Combined, they allow for exclusive access to the resource: only one process can be in the critical section at a time. We also need to use Rust&#39;s <a href="https://doc.rust-lang.org/core/cell/struct.RefCell.html">RefCell</a> or <a href="https://doc.rust-lang.org/core/cell/struct.Cell.html">Cell</a> in conjunction with the mutexes.</p>

<p>How it works:</p>

<ul>
<li>Declare your variable statically, as a <code>Mutex&lt;RefCell&lt;Option&lt;type&gt;&gt;&gt;</code>, where <code>type</code> is the type in question. <code>Option</code> is required, since we need to initialize this with a value, but often can&#39;t set up the variable we&#39;re storing until the <code>main</code> function. <code>Option</code> allows us to initialize it to <code>None</code>.</li>
<li>Using a critical section, eg in <code>main</code>, replace the interior of this type with our actual variable. Note that we use <code>cortex_m::interrupt::free</code> to start a critical section. Everything inside of its closure runs without being interrupted.</li>
<li>When we need access to the variable, use a critical section to provide a mutable reference to it.</li>
</ul>

<p>Note that for <a href="https://doc.rust-lang.org/core/marker/trait.Copy.html">Copy</a> types, we use <code>Cell</code> instead of <code>RefCell</code>, and don&#39;t need the option. Example:</p>

<div><pre><span>// `RefCell&lt;Option&gt;` For non-copy types</span>
<span>static</span> ADC: Mutex&lt;RefCell&lt;Option&lt;ADC&lt;ADC1&gt;&gt;&gt;&gt; = Mutex::new(RefCell::new(None));
<span>// `Cell` for copy types</span>
<span>static</span> SENSOR_READING: Mutex&lt;Cell&lt;<span>f32</span>&gt;&gt; = Mutex::new(Cell::new(<span>335.</span>));

<span>#[entry]</span>
<span>fn</span> main() -&gt; ! {
    <span>// ...</span>
    <span>let</span> <span>mut</span> adc = Adc::new_adc1(dp.ADC1, Default::default(), &amp;clock_cfg);

    <span>// Set up a GPIO pin associate with a button that grounds the pin when pressed.</span>
    <span>let</span> <span>mut</span> read_button = Pin::new(Port::A, <span>0</span>, PinMode::Input);
    read_button.pull(Pull::Up);
    read_button.enable_interrupt(Edge::Falling);

    <span>// Set up our ADC as a global variable accessible in interrupts, now that it&#39;s initialized.</span>
    free(|cs| {
        ADC.borrow(cs).replace(Some(adc));
    });

    <span>// Unmask the interrupt line. EXTI0 is used for GPIO interrupts, eg when pushing a button.</span>
    <span>unsafe</span> {
        NVIC::unmask(pac::Interrupt::EXTI0);
        cp.NVIC.set_priority(pac::Interrupt::EXTI0, <span>0</span>);
    }

    <span>loop</span> {}
}

<span>#[interrupt]</span>
<span>/// GPIO interrupt associated with pins numbered 0 (PA0, PB0 etc)</span>
<span>fn</span> EXTI0() {
    <span>unsafe</span> {
        <span>// Clear the interrupt flag, to prevent continous firing.</span>
        (*pac::EXTI::ptr()).pr1.modify(|_, w| w.pr0().set_bit());
    }

    free(|cs| {
        <span>// We use this syntax, inside a critical section, to access our Adc struct, as a mutable reference.</span>
        <span>let</span> <span>mut</span> a = ADC.borrow(cs).borrow_mut();
        <span>let</span> adc = a.as_mut().unwrap();

        <span>let</span> reading = adc.read(AdcChannel::C1).unwrap();
        SENSOR_READING.borrow(cs).replace(reading);

        <span>// This is how we get the value using the `Cell` syntax.</span>
        <span>let</span> reading2 = SENSOR_READING.borrow(cs).get();
    });
}
</pre></div>

<p>Unfortunately, this is verbose. You can make it easier using macros to simplify the syntax. The <code>STM32-HAL</code> crate includes some for this purpose. For example, you can use <code>let adc = access_global!(ADC, adc, cs);</code> instead of the 2 lines above. It also contains a macro for the initialization, which makes the syntax more concise. Note that the code above relating to reading and writing these <code>Mutex</code> variables use the <code>cs</code> parameter from <code>free</code>&#39;s closure. This is an indication they need to be in a critical section to run.</p>

<p>Critical sections and mutexes have a disadvantage: No interrupts can occur inside them. This includes higher-priority ones, which would otherwise run inside lower priority ones. This is not a problem for some uses, but can be a deal breaker for processes that need to respond quickly, like RF and USB. See the below section on RTIC for one way around this. You should try to keep critical sections short, so interrupts are delayed for the shortest time possible.</p>

<h3>RTIC and static analysis</h3>

<p>The <a href="https://rtic.rs/dev/book/en/">Real-Time Interrupt-driven Concurrency library</a> is a lightweight framework that uses static analysis to ensure safe state access between contexts. It performs checks at compile time to ensure race conditions don&#39;t happen, and is built on top of Cortex-M&#39;s interrupt system. RTIC requires you to structure your program in a specific way. Note that this a drop-in replacement for some other methods of handling concurrency. For example, RTIC <em>Tasks</em> can be thought of as ISRs with a different syntax, and its task priorities are similar to the NVIC peripheral it wraps. </p>

<p>RTIC has a distinct advantage for resource sharing over critical sections (CS): CSs prevent any interrupt from occuring until they complete. RTIC can higher-priority interrupts to execute inside their CS-analog: The <em>lock</em>. This is allowed as long as the higher-priority interrupt doesn&#39;t use a resource controlled by the lock it executes inside.</p>

<p>RTIC also provides a scheduling abstraction using hardware timers. This can make code easier to reason about, and more generic than using the timers and their associated ISRs directly.</p>

<p>The easiest way to learn RTIC is from the documentation above, or from <a href="https://github.com/rtic-rs/rtic-examples/tree/master/rtic_v5">official examples</a>. It&#39;s used to solve the same problem we solve above using mutexes and critical sections, and its code structure is similar, although with different syntax.</p>

<h3>Async and Await</h3>

<p>If you like <a href="https://rust-lang.github.io/async-book/01_getting_started/01_chapter.html">Async and Await syntax</a>, check out the <a href="https://github.com/embassy-rs/embassy">Embassy project</a>. This provides an alternative control flow to ISRs, which you may be familiar with from Javascript, Python, or non-embedded Rust. There are currently no releases, but it&#39;s usable from Github. It uses a custom PAC, which abstracts over differences between MCUs, resulting in simpler HAL-level code.</p>

<h2>The Embedded-HAL library</h2>

<p>The Rust embedded working group provides a library called <a href="https://docs.rs/embedded-hal/latest/embedded_hal/">embedded-hal</a> that provides standard interfaces for working with common peripherals. It does this by leveraging <a href="https://doc.rust-lang.org/book/ch10-02-traits.html">Rust&#39;s trait system</a> - a form of generics. Its goal is to allow the creation of software libraries that provide a high-level interface to a specific peripheral (eg a display, sensor etc). These libraries can then be used with arbitrary MCUs. The <a href="https://github.com/rust-embedded/awesome-embedded-rust">Awesome Embedded Rust page</a> contains links to a number of these libraries.You may not need to write a driver/interface for each peripheral you use - there&#39;s a chance someone&#39;s already written one, and you can use it as a dependency.</p>

<p>This is a promising idea, and is useful for prototyping. At this time, most of these traits are too limited to be useful, other than for communications protocols like SPI, I²C etc. Many drivers that use them are unsuitable for real-world devices, due to missing features, lack of regard for power use, blocking interfaces, poor ergonomics, or interfaces unsuitable for use with DMA. This may change in the future. If you find an <code>embedded-hal</code> driver for a peripheral you&#39;re using, give it a try, and see if it meets your project&#39;s requirements - if so, it may save time.</p>

<h2>Sample Projects</h2>

<p>The complete firmware for our conductivity module is <a href="https://github.com/David-OConnor/stm32-hal/tree/main/examples/conductivity_module">published here</a>, in the <code>STM32-HAL</code> examples folder. The <code>ec.rs</code> file included is also directly used by the Water Monitor, as a dependency. This is a simple program that demonstrates how to make embedded firmware using Rust. It manages a DAC, external multiplexer, polarity-switch and I2C ADC to take conductivity measurements. Dive in to the code and comments for more details. <code>src/main.rs</code> contains code for setting up peripherals and control flow. <code>src/ec.rs</code> contains code for preparing measurements, and is used by both the standalone module, and Water Monitor.</p>

<p>For another example, <a href="https://github.com/David-OConnor/nrf-hal/tree/main/examples/temperature_transmitter">here&#39;s the (WIP!) code</a> for the sensor module of our upcoming <a href="https://omarish.com/stove-thermometer">Stove thermometer</a>. Note that this uses a different HAL library. It&#39;s a modified version of the <code>nrf-rs</code> <code>nRF-HAL</code> linked above, with some changes to improve the API. This device periodically takes measurements from an MLX-90614 IR thermometer, transmits them over a simple radio protocol, then goes to sleep until the next measurement. It&#39;s designed to run for long periods of time on a coin cell battery.</p>

<h2>Zig</h2>

<p><a href="https://ziglang.org/">Zig</a> is another modern language that&#39;s suitable for embedded programming. It&#39;s a much simpler language, and isn&#39;t as strict about memory management as Rust. Its embedded infrastructure is currently small, and its dependency management is a work in progress. Zig may be a good alternative to Rust on embedded in a few years, but isn&#39;t suitable for production devices at this time.</p>

<p>If you&#39;re looking for a modern language for embedded that&#39;s safer and more ergonomic than C, but don&#39;t like Rust&#39;s complexity and surface-area, Zig may be suitable in the future. <a href="https://kevinlynagh.com/rust-zig/">This article by Kevin Lynagh</a> compares keyboard firmware written in Rust and Zig.</p>

<h2>Interaction with C</h2>

<p>If you&#39;d like to use a C library in Rust, you can wrap it using the <a href="https://github.com/rust-lang/rust-bindgen">Bindgen</a> tool, which &#34;automatically generates Rust FFI bindings to C (and some C++) libraries.&#34; Rust, by design, has basic types that map 1:1 with C types. This makes libraries wrapped with Bindgen compatible using an API compatible to the original, and with automatic conversion. For example, <a href="https://crates.io/crates/cmsis-dsp-sys">cmsis-dsp-sys</a> is a Rust library built using this tool that wraps the official ARM <a href="https://www.keil.com/pack/doc/CMSIS/DSP/html/index.html">CMSIS-DSP</a> library. This is a powerful, well-documented library for performing calculations useful for DSP - and its documentation is easy to interpret in Rust. A notable limitation is that since C doesn&#39;t use references, the generated Rust APIs use pointers for arrays, leading to syntax different from typical Rust. You can either use this API (making use of an array&#39;s <code>.as_ptr()</code> and <code>.as_mut_ptr()</code> methods), or wrap in a higher-level Rust API.</p>

<p>When communicating with embedded engineers who don&#39;t use Rust, it&#39;s easiest to talk in terms of registers, fields, and other concepts that come directly from RMs and datasheets. For example, you may not be familiar with the official HAL functions commonly used by STM32 users and vice versa, but you both share the language of register reads and writes, which higher level libraries wrap, and documentation refers to. </p>

<p>For example, let&#39;s say you&#39;re describing setting up an STM32 DAC: A C user may describe the process as running <code>HAL_DAC_Start(&amp;hdac2, DAC1_CHANNEL_1);</code>. You might describe it as <code>hal::Dac::new(dp.DAC, DacBits::TwelveR, 3.3); dac.enable(Channel::C1);</code>. Neither of you would know what the other is talking about! But you both can understand the process described in the RM: (Paraphrased)</p>

<ul>
<li>Enable the DAC peripheral clock: Set RCC_APB1ENR register, DAC1EN field</li>
<li>Enable the channel: Set DAC_CR register, en1 or en2 fields</li>
<li>Write to the appropriate data register, depending on alignment and num of bits. Eg: DAC_DHR12L1 register, write the word you wish to output</li>
</ul>
</div></div>
  </body>
</html>
