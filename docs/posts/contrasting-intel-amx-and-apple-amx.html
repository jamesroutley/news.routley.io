<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.corsix.org/content/contrasting-intel-amx-and-apple-amx">Original</a>
    <h1>Contrasting Intel AMX and Apple AMX</h1>
    
    <div id="readability-page-1" class="page"><div>

<div>
<p data-sourcepos="1:1-1:220">Intel has an x64 instruction set extension called <a href="https://en.wikichip.org/wiki/x86/amx">AMX</a>, meanwhile Apple has a <em>totally different</em> aarch64 instruction set extension also called <a href="https://github.com/corsix/amx">AMX</a>.</p>
<p data-sourcepos="3:1-3:17"><strong>Register file</strong></p>
<p data-sourcepos="5:1-5:270">Intel AMX: 8 <code>tmm</code> registers, each a 16 by 16 matrix of 32-bit elements (technically, each can be configured to be any size - square or rectangular - between 1 by 1 and 16 by 16, though element size is fixed at 32-bits regardless). Total architectural state 8 kilobytes.</p>
<p data-sourcepos="7:1-7:65">Apple AMX: Total architectural state 5 kilobytes, broken down as:</p>
<ul data-sourcepos="8:3-17:0">
<li data-sourcepos="8:3-8:48">8 <code>x</code> registers, each a 64-byte (row) vector</li>
<li data-sourcepos="9:3-9:58">8 <code>y</code> registers, each a 64-byte (row or column) vector</li>
<li data-sourcepos="10:3-17:0">Then <code>z</code>, which can be variously viewed as <em>any</em> of:
<ul data-sourcepos="11:5-17:0">
<li data-sourcepos="11:5-11:53">1 register, a 64 by 64 matrix of 8-bit elements</li>
<li data-sourcepos="12:5-12:54">1 register, a 32 by 32 matrix of 32-bit elements</li>
<li data-sourcepos="13:5-13:60">2 registers, each a 32 by 32 matrix of 16-bit elements</li>
<li data-sourcepos="14:5-14:60">4 registers, each a 16 by 16 matrix of 32-bit elements</li>
<li data-sourcepos="15:5-15:59">8 registers, each an 8 by 8 matrix of 64-bit elements</li>
<li data-sourcepos="16:5-17:0">64 registers, each a 64-byte row vector</li>
</ul>
</li>
</ul>
<p data-sourcepos="18:1-18:232">The vectors have 8/16/32/64-bit elements, like regular SIMD registers. Note that Intel AMX does not need vector registers, as Intel already has AVX512 with 64-byte vectors (32 of which are in the AVX512 architectural register file).</p>
<p data-sourcepos="20:1-20:14"><strong>Data types</strong></p>
<p data-sourcepos="22:1-22:173">Intel AMX: Multiplicands are always 32-bit, either <code>i8[4]</code> or <code>u8[4]</code> or <code>bf16[2]</code>, combined via dot product. Accumulators are always 32-bit, either <code>i32</code> or <code>u32</code> or <code>f32</code>.</p>
<p data-sourcepos="24:1-24:311">Apple AMX: Multiplicands are scalars, any of <code>i8</code> / <code>u8</code> / <code>i16</code> / <code>u16</code> / <code>f16</code> / <code>f32</code> / <code>f64</code>. Accumulators are any of <code>i16</code> / <code>u16</code> / <code>i32</code> / <code>u32</code> / <code>f16</code> / <code>f32</code> / <code>f64</code>. Note <code>f16</code> (i.e. IEEE 754 half-precision with 5-bit exponent and 10-bit fraction) rather than <code>bf16</code> (8-bit exponent, 7-bit fraction).</p>
<p data-sourcepos="26:1-26:28"><strong>Computational operations</strong></p>
<p data-sourcepos="28:1-28:237">Intel AMX: <em>Matrix multiplication</em> of any two <code>tmm</code> registers, accumulating onto a third <code>tmm</code> register. For the multiplication, matrix elements are themselves (very small) vectors, combined via dot product. This is the <em>only</em> operation.</p>
<p data-sourcepos="30:1-30:748">Apple AMX: <em>Outer product</em> of any <code>x</code> register with any <code>y</code> register (viewed as a column vector), accumulating onto any (matrix view) <code>z</code> register. For the multiplication, <code>x</code> / <code>y</code> elements are scalars. Alternatively, <em>pointwise product</em> of any <code>x</code> register with any <code>y</code> register (viewed as a row vector), accumulating onto any (vector view) <code>z</code> register. <a href="https://github.com/corsix/amx/blob/main/Instructions.md#floating-point-matrix-arithmetic-ie-outer-products-writing-to-z">Many more operations as well</a>, though the general theme is {outer or pointwise} {multiplication or addition or subtraction}, possibly followed by right-shift, possibly followed by integer saturation. The most exotic exceptions to the theme are <code>min</code> / <code>max</code> / <code>popcnt</code>.</p>
<p data-sourcepos="32:1-32:21"><strong>Memory operations</strong></p>
<p data-sourcepos="34:1-34:188">Intel AMX: Matrix load or store (up to 1 kilobyte), configurable with a base address (register + immediate offset) and a row stride (register or zero, optionally shifted left by 1-3 bits).</p>
<p data-sourcepos="36:1-36:376">Apple AMX: Vector load or store (64 bytes), configurable with a base address (register). Also load or store pair (128 bytes), though the two registers must be consecutive, and the row stride is fixed at 64 bytes, and the base address must be 128-byte aligned. Loads or stores with <code>y</code> effectively give a free vector transpose, as <code>y</code> registers can be viewed as column vectors.</p>
<p data-sourcepos="38:1-38:17"><strong>Masking modes</strong></p>
<p data-sourcepos="40:1-40:346">Intel AMX: Each <code>tmm</code> register can be configured to any size - square or rectangular - between 1 by 1 and 16 by 16. This is (mostly) equivalent to saying that a <code>tmm</code> register is always 16 by 16, but has an associated mask on each dimension to only enable some number of leading rows and columns. These per-register masks are architectural state.</p>
<p data-sourcepos="42:1-42:270">Apple AMX: Per-dimension masking is available on a per-instruction basis (though notably not for loads / stores). Available masking modes are: all rows (columns), even/odd rows (columns) only, first N rows (columns) only, last N rows (columns) only, row (column) N only.</p>
<p data-sourcepos="44:1-44:225">Note that both of these approaches are different to Intel&#39;s AVX512 approach, which is a separate register file containing 8 mask registers (<code>k0</code> through <code>k7</code>) and every operation optionally taking a mask register as an input.</p>
<p data-sourcepos="46:1-46:9"><strong>Other</strong></p>
<p data-sourcepos="48:1-48:495">Apple AMX contains a <em>very</em> interesting instruction called <a href="https://github.com/corsix/amx/blob/main/genlut.md"><code>genlut</code></a>. In the forward direction (&#34;lookup&#34;), it is somewhere between AVX512&#39;s <code>vpshufb</code> and <code>vgatherps</code>. In the backward direction (&#34;generate&#34;) it is something like an <em>inverse</em> <code>vpshufb</code>, performing arbitrary 2/3/4/5-bit quantisation. When used in both directions, it can be useful for piecewise linear interpolation, or as an alternative to AVX512&#39;s <code>vfpclassps</code> / <code>vfixupimmps</code>.</p>
</div>
</div></div>
  </body>
</html>
