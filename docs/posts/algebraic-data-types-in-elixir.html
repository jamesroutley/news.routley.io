<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.appsignal.com/2022/05/31/algebraic-data-types-in-elixir.html">Original</a>
    <h1>Algebraic Data Types in Elixir</h1>
    
    <div id="readability-page-1" class="page"><div><div><p>Elixir is a dynamically-typed language. Types in Elixir are checked when a program runs, not when it compiles. If they don’t match up, an exception is thrown.</p><p>In statically-typed languages, types are checked during compile time. This can help us write code that is correct, understandable, and refactorable.</p><p>But it also introduces a certain focus on types as the foundation for your application. One interesting concept is to use types to model your business domain. In languages like Haskell, F#, and OCaml, this is usually done with algebraic data types (ADTs) — they build compound data types by aggregating types with product (AND) and sum (OR) types.</p><p>With the help of Dialyzer, a static analysis tool, you can use ADTs to constrain the number of your application&#39;s allowed states. This decreases the chance that errors will slip in.</p><p>In this article, we&#39;ll cover Dialyzer, ADTs, and how you can solve the problem of illegal states by using them together.</p><p>Let&#39;s get going!</p><div><h2>Type Declarations in Elixir with Dialyzer</h2><p>In Elixir (and other BEAM languages), checking type specifications is usually done with <a href="https://www.erlang.org/doc/man/dialyzer.html">Dialyzer</a>.</p><p>Dialyzer is different from the type systems of Haskell, OCaml, or even TypeScript. Instead of you proving to the compiler that your code is correct, Dialyzer needs to prove to you that your code is not correct.</p><p>This makes Dialyzer rather lax in requirements. If there is a way for the types to work, Dialyzer will assume you know what you are doing, and the types will, indeed, work.</p><p>But it’s still useful to reason about types and catch the occasional mistake.</p></div><div><h2>Quick Intro to Dialyzer in Elixir</h2><p>You can use Dialyzer in Elixir by adding a type spec for your functions via <code>@spec</code>.</p><div data-rehype-pretty-code-fragment=""><pre><code data-language="elixir" data-theme="default"><span><span>#          (1)      (2)           (3)</span></span>
<span><span>  </span><span>@spec</span><span> </span><span>plus_one</span><span>(integer) :: integer</span></span>
<span> </span>
<span><span>  </span><span>def</span><span> </span><span>plus_one</span><span>(x), </span><span>do:</span><span> x </span><span>+</span><span> </span><span>1</span></span>
<span><span>end</span></span></code></pre></div><p>Here, we just write the name of the function (1) with its type as an argument (2), then the return type of the function (3).</p><p>You can find a <a href="https://hexdocs.pm/elixir/1.13/typespecs.html#basic-types">list of basic types to use in Elixir&#39;s documentation</a>.</p><p>You can also create your own type aliases via <code>@type</code>. To do that, you need to provide the alias&#39; name (1) and its type (2).</p><div data-rehype-pretty-code-fragment=""><pre><code data-language="elixir" data-theme="default"><span><span>#         (1)        (2)</span></span>
<span><span>  </span><span>@type</span><span> counter :: integer</span></span></code></pre></div><p>If you use the Elixir language server, that’s all you need to do: your plugin/extension will notify you about any specs that Dialyzer doesn’t like. Otherwise, you need to run the <code>mix dialyzer</code> task to check your types.</p><p>You can find more about <a href="https://elixir-lang.org/getting-started/typespecs-and-behaviours.html">the use of Dialyzer on Elixir&#39;s website</a> and in <a href="https://hexdocs.pm/elixir/1.13/typespecs.html">Elixir&#39;s typespec docs</a>.</p><p>Now that we can type spec our Elixir code, let’s dig into algebraic data types.</p></div><div><h2>Algebraic Data Types</h2><p>While the name sounds scary (ooh, algebra 👻), algebraic data types are relatively simple.</p><p>This section will focus on the two main parts of ADTs: product (AND) and sum (OR) types.</p><div><h3>Product Types</h3><p>Product types are all around us. A product type is just a type with two or more fields that each hold a data type. You can also think of them as AND types.</p><p>For example, a tuple is a product type:</p><div data-rehype-pretty-code-fragment=""><pre><code data-language="elixir" data-theme="default"><span><span>@type</span><span> </span><span>tuple</span><span>(a, b) :: {a, b}</span></span></code></pre></div><p>It takes two data types — a <strong>and</strong> b — and returns a type that holds both of these data types.</p><p>In Elixir, we also use product types with named fields — structs.</p><div data-rehype-pretty-code-fragment=""><pre><code data-language="elixir" data-theme="default"><span><span>defmodule</span><span> </span><span>Person</span><span> </span><span>do</span></span>
<span><span>  </span><span>defstruct</span><span> </span><span>first_name:</span><span> </span><span>&#34;Gints&#34;</span><span>, </span><span>last_name:</span><span> </span><span>&#34;Dreimanis&#34;</span></span>
<span><span>end</span></span></code></pre></div><p>Let&#39;s look at the type in this example:</p><div data-rehype-pretty-code-fragment=""><pre><code data-language="elixir" data-theme="default"><span><span>@type</span><span> </span><span>t</span><span>() :: %</span><span>__MODULE__</span><span>{</span></span>
<span><span>        </span><span>first_name:</span><span> </span><span>String</span><span>.</span><span>t</span><span>(),</span></span>
<span><span>        </span><span>last_name:</span><span> </span><span>String</span><span>.</span><span>t</span><span>()</span></span>
<span><span>      }</span></span></code></pre></div><p>Generally, you can think of types as being sets of possible values. For example, a boolean has two possible values: <code>:true</code> and <code>:false</code>. A type for a traffic light color has one of three possible values: <code>:green</code>, <code>:yellow</code>, and <code>:red</code>.</p><p>If we have two types with sizes <code>a</code> and <code>b</code>, then the product type of those types will contain <code>a * b</code> values — the product of the sizes of those types. If you make a product type of the boolean and traffic light types — e.g., put a boolean and traffic light in a tuple — you&#39;ll have <code>2 * 3 = 6</code> possible values.</p><div data-rehype-pretty-code-fragment=""><pre><code data-language="elixir" data-theme="default"><span><span>{</span><span>:</span><span>green</span><span>, </span><span>:</span><span>true</span><span>}</span></span>
<span><span>{</span><span>:</span><span>yellow</span><span>, </span><span>:</span><span>true</span><span>}</span></span>
<span><span>{</span><span>:</span><span>red</span><span>, </span><span>:</span><span>true</span><span>}</span></span>
<span><span>{</span><span>:</span><span>green</span><span>, </span><span>:</span><span>false</span><span>}</span></span>
<span><span>{</span><span>:</span><span>yellow</span><span>, </span><span>:</span><span>false</span><span>}</span></span>
<span><span>{</span><span>:</span><span>red</span><span>, </span><span>:</span><span>false</span><span>}</span></span></code></pre></div></div><div><h3>Sum Types</h3><p>A historically less common kind of type is sum types.</p><p>In contrast to a product type, a sum type gives you one of two (or more) options. You can also think of them as OR types.</p><p>We use these in Elixir as well. For example, result tuples are sum types.</p><div data-rehype-pretty-code-fragment=""><pre><code data-language="elixir" data-theme="default"><span><span>@type</span><span> </span><span>result</span><span>(a, b) :: {</span><span>:</span><span>error</span><span>, a} | {</span><span>:</span><span>ok</span><span>, b}</span></span></code></pre></div><p>In a result tuple, we can have an error of type <code>a</code> <strong>or</strong> success of type <code>b</code>.</p><p>Or, for example, we can have a sum type for optional values.</p><div data-rehype-pretty-code-fragment=""><pre><code data-language="elixir" data-theme="default"><span><span>@type</span><span> </span><span>optional</span><span>(a) :: </span><span>:</span><span>error</span><span> | {</span><span>:</span><span>ok</span><span>, a}</span></span></code></pre></div><p>But it can also just be used for making lists of alternatives.</p><div data-rehype-pretty-code-fragment=""><pre><code data-language="elixir" data-theme="default"><span><span>@type</span><span> direction :: </span><span>:</span><span>north</span><span> | </span><span>:</span><span>west</span><span> | </span><span>:</span><span>south</span><span> | </span><span>:</span><span>east</span></span></code></pre></div><p>If you list two types in a sum type, the resulting type can pick a type from one set of values or the other. Because of this, its size is generally the sum of the sizes of those types.</p><p>The above might not always be true when using Dialyzer: you can put together two sets that overlap. For the statement to be true, they need to be tagged with the set they come from — the result type we defined above is a prime example.</p><p>That’s what people usually mean by algebraic data types.</p></div><div><h3>There&#39;s More to Algebraic Data Types</h3><p>By putting together sums and products, we have something akin to the algebra that we know and love from our school days: multiplication, sums, and variables.</p><p>Of course, there is more to algebraic types than just this: there’s also recursion, exponentials, etc. If you want to delve deeper into the subject, check out how they look in languages like Haskell.</p><p>Here are two Haskell articles that you can read: one from <a href="https://codewords.recurse.com/issues/three/algebra-and-calculus-of-algebraic-data-types">Joel Burget on the algebra of ADTs</a> and <a href="https://serokell.io/blog/algebraic-data-types-in-haskell">an ADTs in Haskell tutorial from yours truly</a>.</p></div></div><div><h2>How Algebraic Data Types Help in Domain Modeling</h2><p>We Elixir programmers usually don’t think in terms of sum types. The primary tool for modeling a domain in Elixir is the struct, a product type with named fields.</p><p>While that&#39;s good enough for most things, sometimes it is beneficial to use sum types as well.</p><p>Let’s look at an example.</p><div><h3>Custom Kanban Board</h3><p>Let’s imagine we need to create a representation of a customized Kanban board issue.</p><p>Our issues can be in one of these states:</p><ul><li>Searching for assignee: in this case, it should have neither an assignee nor a reviewer</li><li>Not started yet: in this and the following state, it should have an assignee but not a reviewer</li><li>In progress</li><li>In review: in this and the following state, it should have an assignee and a reviewer</li><li>Done</li></ul><p>All issues also have names and descriptions.</p><p>At first, one might be tempted to use a simple struct.</p><div data-rehype-pretty-code-fragment=""><pre><code data-language="elixir" data-theme="default"><span><span>defmodule</span><span> </span><span>Issue</span><span> </span><span>do</span></span>
<span><span>  </span><span>defstruct</span><span> </span><span>name:</span><span> </span><span>&#34;&#34;</span><span>,</span></span>
<span><span>            </span><span>description:</span><span> </span><span>&#34;&#34;</span><span>,</span></span>
<span><span>            </span><span>state:</span><span> </span><span>:</span><span>searching_for_assignee</span></span>
<span><span>            </span><span>assignee:</span><span> </span><span>nil</span><span>,</span></span>
<span><span>            </span><span>reviewer:</span><span> </span><span>nil</span></span>
<span><span>end</span></span></code></pre></div><p>But as we saw in the section on product types, a simple product type has a lot of possible values, some of which might not match our requirements.</p><p>For example, we can create an issue that searches for an assignee but still has an assignee and a reviewer.</p><div data-rehype-pretty-code-fragment=""><pre><code data-language="sh" data-theme="default"><span><span>iex(1)&gt; %Issue{name: </span><span>&#34;wrong issue&#34;</span><span>, description: </span><span>&#34;not good at all&#34;</span><span>, state: :searching_for_assignee, assignee: </span><span>&#34;Jorge Luis Borges&#34;</span><span>, reviewer: </span><span>&#34;Gabriel García Márquez&#34;</span><span>}</span></span>
<span><span>%Issue{</span></span>
<span><span>  assignee: </span><span>&#34;Jorge Luis Borges&#34;</span><span>,</span></span>
<span><span>  description: </span><span>&#34;not good at all&#34;</span><span>,</span></span>
<span><span>  name: </span><span>&#34;wrong issue&#34;</span><span>,</span></span>
<span><span>  reviewer: </span><span>&#34;Gabriel García Márquez&#34;</span><span>,</span></span>
<span><span>  state: :searching_for_assignee</span></span>
<span><span>}</span></span></code></pre></div><p>While it is possible to avoid doing that generally, it is simpler to make it impossible. We have a saying for this: “make illegal states unrepresentable”.</p><p>To do that, we need to create a sum type that covers all the states that we want to allow. It will enable us to cut out some of the wrong states by substituting products of values with sums of values.</p><p>First, let’s combine the <code>state</code>, <code>assignee</code>, and <code>reviewer</code> fields into one field: <code>state</code>.</p><div data-rehype-pretty-code-fragment=""><pre><code data-language="elixir" data-theme="default"><span><span>defstruct</span><span> </span><span>name:</span><span> </span><span>&#34;&#34;</span><span>,</span></span>
<span><span>          </span><span>description:</span><span> </span><span>&#34;&#34;</span><span>,</span></span>
<span><span>          </span><span>state:</span><span> </span><span>:</span><span>searching_for_assignee</span></span></code></pre></div><p>After that, let’s define a sum type for <code>state</code> that will contain our specified options.</p><p>Let’s look at them again. Our issue can be in one of these states:</p><ul><li>Searching for assignee</li><li>Not started yet but with an assignee</li><li>In progress and with an assignee</li><li>In review with an assignee and reviewer</li><li>Done, with the assignee and reviewer left for the historical record</li></ul><p>It’s quite easy to define a type that reads almost like this:</p><div data-rehype-pretty-code-fragment=""><pre><code data-language="elixir" data-theme="default"><span><span>@type</span><span> state ::</span></span>
<span><span>        </span><span>:</span><span>searching_for_assignee</span></span>
<span><span>        | {</span><span>:</span><span>not_started</span><span>, </span><span>String</span><span>.</span><span>t</span><span>()}</span></span>
<span><span>        | {</span><span>:</span><span>in_progress</span><span>, </span><span>String</span><span>.</span><span>t</span><span>()}</span></span>
<span><span>        | {</span><span>:</span><span>in_review</span><span>, </span><span>String</span><span>.</span><span>t</span><span>(), </span><span>String</span><span>.</span><span>t</span><span>()}</span></span>
<span><span>        | {</span><span>:</span><span>done</span><span>, </span><span>String</span><span>.</span><span>t</span><span>(), </span><span>String</span><span>.</span><span>t</span><span>()}</span></span></code></pre></div><p>So that it&#39;s simpler to understand, we can create aliases for the assignee and reviewer.</p><div data-rehype-pretty-code-fragment=""><pre><code data-language="elixir" data-theme="default"><span><span>@type</span><span> assignee :: </span><span>String</span><span>.</span><span>t</span><span>()</span></span>
<span><span>@type</span><span> reviewer :: </span><span>String</span><span>.</span><span>t</span><span>()</span></span></code></pre></div><p>Now, the type looks exactly like our list of rules.</p><div data-rehype-pretty-code-fragment=""><pre><code data-language="elixir" data-theme="default"><span><span>@type</span><span> state ::</span></span>
<span><span>        </span><span>:</span><span>searching_for_assignee</span></span>
<span><span>        | {</span><span>:</span><span>not_started</span><span>, assignee}</span></span>
<span><span>        | {</span><span>:</span><span>in_progress</span><span>, assignee}</span></span>
<span><span>        | {</span><span>:</span><span>in_review</span><span>, assignee, reviewer}</span></span>
<span><span>        | {</span><span>:</span><span>done</span><span>, assignee, reviewer}</span></span></code></pre></div><p>All that&#39;s left is to create a type specification for the module struct (<code>Issue</code>) by using our state type.</p><div data-rehype-pretty-code-fragment=""><pre><code data-language="elixir" data-theme="default"><span><span>@type</span><span> </span><span>t</span><span>() :: %</span><span>__MODULE__</span><span>{</span></span>
<span><span>        </span><span>name:</span><span> </span><span>String</span><span>.</span><span>t</span><span>(),</span></span>
<span><span>        </span><span>description:</span><span> </span><span>String</span><span>.</span><span>t</span><span>(),</span></span>
<span><span>        </span><span>state:</span><span> state</span></span>
<span><span>      }</span></span></code></pre></div><p>Here’s the complete module code:</p><div data-rehype-pretty-code-fragment=""><pre><code data-language="elixir" data-theme="default"><span><span>defmodule</span><span> </span><span>Issue</span><span> </span><span>do</span></span>
<span><span>  </span><span>defstruct</span><span> </span><span>name:</span><span> </span><span>&#34;&#34;</span><span>,</span></span>
<span><span>            </span><span>description:</span><span> </span><span>&#34;&#34;</span><span>,</span></span>
<span><span>            </span><span>state:</span><span> </span><span>:</span><span>searching_for_assignee</span></span>
<span> </span>
<span><span>  </span><span>@type</span><span> assignee :: </span><span>String</span><span>.</span><span>t</span><span>()</span></span>
<span><span>  </span><span>@type</span><span> reviewer :: </span><span>String</span><span>.</span><span>t</span><span>()</span></span>
<span><span>  </span><span>@type</span><span> state ::</span></span>
<span><span>          </span><span>:</span><span>searching_for_assignee</span></span>
<span><span>          | {</span><span>:</span><span>not_started</span><span>, assignee}</span></span>
<span><span>          | {</span><span>:</span><span>in_progress</span><span>, assignee}</span></span>
<span><span>          | {</span><span>:</span><span>in_review</span><span>, assignee, reviewer}</span></span>
<span><span>          | {</span><span>:</span><span>done</span><span>, assignee, reviewer}</span></span>
<span> </span>
<span><span>  </span><span>@type</span><span> </span><span>t</span><span>() :: %</span><span>__MODULE__</span><span>{</span></span>
<span><span>          </span><span>name:</span><span> </span><span>String</span><span>.</span><span>t</span><span>(),</span></span>
<span><span>          </span><span>description:</span><span> </span><span>String</span><span>.</span><span>t</span><span>(),</span></span>
<span><span>          </span><span>state:</span><span> state</span></span>
<span><span>        }</span></span>
<span><span>end</span></span></code></pre></div><p>Now we can test whether this type specification can stop us from making a logic error.</p><p>We’ll create a function that adds a reviewer to the issue, but we’ll slip a bug inside: it will not change the state of the issue. We’ll also add a type spec.</p><div data-rehype-pretty-code-fragment=""><pre><code data-language="elixir" data-theme="default"><span><span>@spec</span><span> </span><span>add_assignee</span><span>(</span><span>Issue</span><span>.</span><span>t</span><span>(), assignee) :: </span><span>Issue</span><span>.</span><span>t</span><span>()</span></span>
<span><span>def</span><span> </span><span>add_assignee</span><span>(%{</span><span>state:</span><span> </span><span>:</span><span>searching_for_assignee</span><span>} </span><span>=</span><span> issue, assignee_name) </span><span>do</span></span>
<span><span>  %{issue | </span><span>state:</span><span> {</span><span>:</span><span>searching_for_assignee</span><span>, assignee_name}}</span></span>
<span><span>end</span></span></code></pre></div><p>Dialyzer will correctly return a type error here:</p><div data-rehype-pretty-code-fragment=""><pre><code data-language="sh" data-theme="default"><span><span>lib/issue.ex:21:invalid_contract</span></span>
<span><span>The @spec </span><span>for</span><span> the </span><span>function</span><span> </span><span>does</span><span> not match the success typing of the function.</span></span>
<span> </span>
<span><span>Function:</span></span>
<span><span>Issue.add_assignee/2</span></span>
<span> </span>
<span><span>Success typing:</span></span>
<span><span>@spec add_assignee(%{:state =&gt; :searching_for_assignee, _ =&gt; _}, _) :: %{</span></span>
<span><span>  :state =&gt; {:searching_for_assignee, _},</span></span>
<span><span>  _ =&gt; _</span></span>
<span><span>}</span></span></code></pre></div><p>It’s a bit cryptic, but it basically means that <code>Issue.add_assignee</code> didn’t compile, and we should look into it! 🙃</p><p>As you can see, algebraic data types have saved us from making an error. Turns out, they’re not really a scary monster but a friend.</p></div></div><div><h2>Benefits of Algebraic Data Types for Your Elixir App</h2><p>Adopting algebraic data types for your Elixir applications is a two-step decision process.</p><p>The first step is to choose to use Dialyzer and typespecs. Dialyzer gives most of the benefits that any language with static typing would:</p><ul><li>It&#39;s easier to catch errors you&#39;ve made in code.</li><li>Types give extra information about code: what it does and what values it operates. This is helpful when trying to understand the code.</li><li>Once you have written your code, types can ensure the code still does the same thing (similar to tests) so it is easier to refactor.</li></ul><p>Once you&#39;ve adopted Dialyzer for your codebase, thinking in terms of algebraic data types should come naturally, and give a few benefits:</p><ul><li>As we have seen in the example, sum types in particular let you cut down the possible states and make illegal states unrepresentable.</li><li>Having AND and OR in your vocabulary helps you build compound types in a way that&#39;s intuitive and understandable even to non-developers (domain experts).</li></ul><p>Of course, ADTs are just one tool for software correctness — definitely not a panacea. But in general, ADTs are a helpful concept for anyone working with an Elixir codebase that uses Dialyzer.</p><p>If your codebase doesn&#39;t use Dialyzer, your first goal should be to introduce it, which is a much larger undertaking than changing how you do types when writing type specifications. That undertaking is unfortunately out of the scope of this article.</p><p>If you want to learn more about how ADTs can make your code clearer and help you ship better code, I invite you to check out <a href="https://pragprog.com/titles/swdddf/domain-modeling-made-functional/">Domain Modeling Made Functional</a> by Scott Wlaschin or his blog post series called <a href="https://fsharpforfunandprofit.com/series/designing-with-types/">Designing with Types</a>.</p></div><div><h2>ADTs in Elixir: Wrap Up and Further Reading</h2><p>In this post, we explored how to check type specifications with Dialyzer, before focusing on the two main parts of ADTs: product (AND) and sum (OR) types.</p><p>We then turned to the use of ADTs in domain modeling and finally touched on the benefits of ADTs.</p><p>If you want to explore algebraic data types, the best option is to get accustomed to a statically-typed functional language such as Haskell, OCaml, or F#.</p><p>Each of those languages has excellent materials for using types as the foundation of your code. The resource that would vibe the best with Elixir developers is probably the aforementioned <a href="https://pragprog.com/titles/swdddf/domain-modeling-made-functional/">Domain Modeling Made Functional</a> since it also covers domain-driven design, which can confuse new Phoenix developers.</p><p>Elixir also has a library that emulates algebraic data types called <a href="https://github.com/witchcrafters/algae">Algae</a>, which we used in one of our previous articles — <a href="https://blog.appsignal.com/2022/02/08/functional-programming-in-elixir-with-witchcraft.html">Functional Programming in Elixir with Witchcraft</a>. In general, Algae provides better tools than Dialyzer to build up a tower of abstractions from simple building blocks. Brave readers might find it rewarding to experiment with.</p><p>Until next time, happy coding!</p><p><strong>P.S. If you&#39;d like to read Elixir Alchemy posts as soon as they get off the press, <a href="https://blog.appsignal.com/elixir-alchemy">subscribe to our Elixir Alchemy newsletter and never miss a single post</a>!</strong></p></div></div></div></div>
  </body>
</html>
