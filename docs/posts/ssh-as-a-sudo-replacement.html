<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://whynothugo.nl/journal/2024/06/13/ssh-as-a-sudo-replacement/">Original</a>
    <h1>SSH as a Sudo Replacement</h1>
    
    <div id="readability-page-1" class="page"><article><p>A major caveat in tools like <code>sudo</code> and <a href="https://man.openbsd.org/doas"><code>doas</code></a> for that matter is that they
rely on <a href="https://en.wikipedia.org/wiki/Setuid"><code>setuid</code></a> binaries and privilege escalation in order to run commands as
root.</p><p>The design is not ideal, and also drags in a few limitations:</p><ol><li>The whole user session needs to retain capabilities to perform privilege
escalation.</li><li>They don’t work when running an entire user session in a restricted user
namespace.</li><li><code>setuid</code> binaries limitations on how the whole system is secured.</li></ol><p>An interesting alternative with a is <code>s6-sudod</code>, which splits the program into
two parts: a privileged server and an unprivileged client.</p><p>This is a summary of an experiment from a few weeks ago where I experimented
with using <code>ssh</code> locally to perform the same role as <code>sudo</code>, without exposing
this <code>sshd</code> instance to the network.</p><ul><li>Enable authorised users (and only authorised users) to run commands as root.</li><li>Don’t use privilege escalation.</li></ul><p>First, I configured a dedicated SSH key that will be authorised for
authentication as root. This key is not in the regular <code>authorized_keys</code> file,
but in a separate file which will only be used for this purpose:</p><div><pre tabindex="0"><code data-lang="sh"><span><span>mkdir /root/.ssh/
</span></span><span><span>echo ssh-ed25519 AAAAC3Nza... &gt; /root/.ssh/local_keys
</span></span></code></pre></div><p>I then ran an <code>sshd</code> server instance bound to a unix domain socket. Permissions
are tightened so unauthorised users cannot even access the socket. This instance
overrides the <code>PermitRootLogin</code> option to enable logging in as root<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup>
and uses the newly created <code>/root/.ssh/local_keys</code> as a source for authorised
keys:</p><div><pre tabindex="0"><code data-lang="sh"><span><span>mkdir /run/sshd/
</span></span><span><span>chown root:wheel /run/sshd/
</span></span><span><span>chmod <span>750</span> /run/sshd/
</span></span><span><span>s6-ipcserver /run/sshd/sshd.sock sshd -ie -o AuthorizedKeysFile<span>=</span>/root/.ssh/local_keys -o PermitRootLogin<span>=</span>yes
</span></span></code></pre></div><p>The root account was locked to disallow logging in via any mechanism. This was
done by prefixing the password’s hash with <code>!</code> (so no password’s hash can ever
match this value). <code>sshd</code> interprets this special prefix as the account being
locked and won’t allow logging in as root.</p><p>I changed the root password in <code>/etc/passwd</code> and replaced the <code>!</code> with an <code>*</code>.
<code>sshd</code> won’t give new value any special interpretation, and will allow logging
in as root. The value <code>*</code> will never match the hash of any password either, so
logging in via password remains effectively disabled.<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup></p><p>I then needed to connect to the local <code>sshd</code> instance. While <code>sshd</code> has a <code>-i</code>
flag which allows passing an existing socket to it, <code>ssh</code> has no equivalent
flag. The <code>ProxyCommand</code> option can be (ab)used for this:</p><div><pre tabindex="0"><code data-lang="sh"><span><span>ssh -o ProxyCommand<span>=</span><span>&#39;socat STDIO UNIX-CONNECT:/run/sshd/sshd.sock&#39;</span> <span>\
</span></span></span><span><span><span></span>    -i .ssh/root-key.pub <span>\
</span></span></span><span><span><span></span>    -t <span>\
</span></span></span><span><span><span></span>    root@root <span>\
</span></span></span><span><span><span></span>    <span>&#34;cd </span><span>$(</span>pwd<span>)</span><span>; &#39;</span>$SHELL<span>&#39; --login&#34;</span>
</span></span></code></pre></div><p>I’m using a hardware-bound SSH key in this case, which means that I need to tap
the physical device to authorise this connection. I could also use an ssh-agent
that requires explicit approval before disclosing keys (e.g.: <code>hissh-agent</code>).</p><p>A little caveat here is that <code>socat</code> will read all input from <code>ssh</code>, and then
write it into the socket, effectively duplicating the overhead of the
connection. I read the relevant manual pages a few more times, and couldn’t find
a solution. I came across <a href="https://man.openbsd.org/ssh_config.5#ProxyUseFdpass"><code>ProxyUseFdpass</code></a>, but wasn’t entirely sure how to
make it work.</p><p>After some more research online (and some major frustration), I found <a href="https://www.gabriel.urdhr.fr/2016/08/07/openssh-proxyusefdpass/">a clear
usage example from 2016</a>. It turnes out that <code>ProxyUseFdpass</code> was quite
straightforward and allows me to specify a command that sends the socket file
descriptor (via <code>stdout</code>) to <code>ssh</code>, and <code>ssh</code> then connects over this socket.</p><p>I saved the following script into <code>/home/hugo/tmp/passfd.py</code>:</p><div><pre tabindex="0"><code data-lang="python"><span><span><span>#!/usr/bin/env python3</span>
</span></span><span><span><span># From: https://www.gabriel.urdhr.fr/2016/08/07/openssh-proxyusefdpass/</span>
</span></span><span><span>
</span></span><span><span><span>import</span> sys
</span></span><span><span><span>import</span> socket
</span></span><span><span><span>import</span> array
</span></span><span><span>
</span></span><span><span><span># Create the file descriptor:</span>
</span></span><span><span>s <span>=</span> socket<span>.</span>socket(socket<span>.</span>AF_UNIX, socket<span>.</span>SOCK_STREAM)
</span></span><span><span>s<span>.</span>connect(<span>&#34;/run/sshd/sshd.sock&#34;</span>)
</span></span><span><span>
</span></span><span><span><span># Pass the file descriptor:</span>
</span></span><span><span>fds <span>=</span> array<span>.</span>array(<span>&#34;i&#34;</span>, [s<span>.</span>fileno()])
</span></span><span><span>ancdata <span>=</span> [(socket<span>.</span>SOL_SOCKET, socket<span>.</span>SCM_RIGHTS, fds)]
</span></span><span><span>socket<span>.</span>socket(fileno <span>=</span> <span>1</span>)<span>.</span>sendmsg([<span>b</span><span>&#39;</span><span>\0</span><span>&#39;</span>], ancdata)
</span></span></code></pre></div><p>And the command to connect to ssh now becomes:</p><div><pre tabindex="0"><code data-lang="sh"><span><span>ssh -o ProxyCommand<span>=</span><span>&#39;/home/hugo/tmp/passfd.py&#39;</span> <span>\
</span></span></span><span><span><span></span>    -i .ssh/root-key.pub <span>\
</span></span></span><span><span><span></span>    -o ProxyUseFdpass<span>=</span>yes <span>\
</span></span></span><span><span><span></span>    -t <span>\
</span></span></span><span><span><span></span>    root@root <span>\
</span></span></span><span><span><span></span>    <span>&#34;cd </span><span>$(</span>pwd<span>)</span><span>; &#39;</span>$SHELL<span>&#39; --login&#34;</span>
</span></span></code></pre></div><p>The linked article mentioned using <code>nc</code> (for a somewhat different use case).
Initially, it would seem that <code>nc -FU /run/sshd/sshd.sock</code> would work, but the
manual page actually specifies that this is not supported:</p><div><pre tabindex="0"><code data-lang="man"><span><span>-F		Pass the first connected socket using sendmsg(2) to stdout and exit. This
</span></span><span><span>		is useful in conjunction with -X to have nc perform connection setup
</span></span><span><span>		with a proxy but then leave the rest of the connection to another
</span></span><span><span>		program (e.g. ssh(1) using the ssh_config(5) ProxyUseFdpass option).
</span></span><span><span>		Cannot be used with -c or -U.
</span></span></code></pre></div><p>This technique works. It relies mainly on OpenSSH for all the sensitive security
details. Not only does OpenSSH have a great track record, but it also enables
various forms of authentication including using a hardware-based SSH key.</p><p>Configuring this on a new host has no complex steps, and the above <code>ipcserver</code>
command can just be executed via the system’s service manager.</p><p>The above <code>passfd.py</code> script is a quick hack to move the experiment forward; for
daily usage it would be best to write a tiny executable that does the same thing
and put it into <code>/usr/local/bin</code>. The whole <code>ssh</code> command could also be placed
in a tiny wrapper.</p></article></div>
  </body>
</html>
