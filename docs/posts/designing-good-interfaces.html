<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://pboyd.io/posts/good-interfaces/">Original</a>
    <h1>Designing Good Interfaces</h1>
    
    <div id="readability-page-1" class="page"><div>
				<p><em>Technician:</em> Welcome to Custom Lube, how can I help you?</p>
<p>The car is ready in record time, and the bill is less than expected. For all the oddity, I think, at least this place is efficient. I begin to drive away, but halfway out of the bay, I hear a sound like an ax hitting wood, followed by grinding and then silence as the engine seizes. Furious, I get out and find the attendant.</p>
<p><em>Me:</em> What kind of oil did you put in my car?</p>
<p>I know it’s absurd. And yet how many times have you seen code like this Go example:</p>
<div><pre tabindex="0"><code data-lang="Go"><span><span><span>func</span> <span>ChangeOil</span>(<span>c</span> <span>Car</span>, <span>oil</span> []<span>BottleOfOil</span>) {
</span></span><span><span>	<span>drainOil</span>(<span>c</span>)
</span></span><span><span>	<span>for</span> <span>_</span>, <span>bottle</span> <span>:=</span> <span>range</span> <span>oil</span> {
</span></span><span><span>		<span>addOil</span>(<span>c</span>, <span>bottle</span>)
</span></span><span><span>	}
</span></span><span><span>}
</span></span></code></pre></div><p>The dependency (oil, in this example) is an argument, not because anyone cares to customize it, but to simplify the implementation. Leave the argument <code>nil</code>, and the function will silently leave the object in a bad state.</p>
<p>What the caller probably wanted was more like this:</p>
<div><pre tabindex="0"><code data-lang="Go"><span><span><span>type</span> <span>OilType</span> <span>uint</span>
</span></span><span><span>
</span></span><span><span><span>const</span> (
</span></span><span><span>	<span>Synthetic</span> <span>OilType</span> = <span>iota</span>
</span></span><span><span>	<span>Conventional</span>
</span></span><span><span>)
</span></span><span><span>
</span></span><span><span><span>func</span> <span>ChangeOil</span>(<span>c</span> <span>Car</span>, <span>oilType</span> <span>OilType</span>) <span>error</span> {
</span></span><span><span>	<span>oil</span>, <span>err</span> <span>:=</span> <span>inventory</span>.<span>GetOil</span>(<span>oilType</span>)
</span></span><span><span>	<span>if</span> <span>err</span> <span>!=</span> <span>nil</span> {
</span></span><span><span>		<span>return</span> <span>err</span>
</span></span><span><span>	}
</span></span><span><span>
</span></span><span><span>	<span>drainOil</span>(<span>c</span>)
</span></span><span><span>	<span>for</span> <span>_</span>, <span>quart</span> <span>:=</span> <span>range</span> <span>oil</span> {
</span></span><span><span>		<span>addQuartOfOil</span>(<span>c</span>, <span>quart</span>)
</span></span><span><span>	}
</span></span><span><span>
</span></span><span><span>	<span>return</span> <span>err</span>
</span></span><span><span>}
</span></span></code></pre></div><p>Better? Perhaps. It’s definitely better for me, a mechanically ignorant driver who is happy to delegate this task to someone else. But not everyone is like me; somewhere out there is someone who would prefer to supply their own oil but not change it themselves.</p>
<p>That’s why you must understand who’s calling your code and design an interface that meets their needs. I’ll leave the imaginary examples behind and explain what I mean through a somewhat real-world program, but it requires some background information, so bear with me.</p>
<h2 id="greek-numbers">Greek Numbers</h2>
<p>Pompeii contains this bit of graffiti preserved by the volcanic ash: Φιλω ης αριθμος ϕμε. Or “I love her whose number is <em>phi mu epsilon</em> (545)”.<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup> This is an example of Isopsephy where the letters in a word or phrase are summed to make a number. That’s right, rather than declare his<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup> love in person, our would-be lover wrote a riddle in graffiti. I don’t know if this strategy worked or much of anything about these two. It had to be written before the volcano erupted in 79 CE, and the love interest was a woman, but that’s it. In the movie version of their lives, I imagine them gazing into one another’s eyes as the pyroclastic flow creeps closer until the movie fades out and the credits begin to roll. But most inhabitants escaped Pompeii, so there’s a good chance they lived a long and happy life.</p>
<p>Anyway, Isopsephy was probably obvious to anyone literate in Greek at the time. The same symbols were used for letters and numbers, so Isopsephy is simply adding the letters as if they were numbers. For example, take Ἀφροδίτη (Aphrodite–no doubt the goddess our graffiti artist was praying to) and convert each letter to its numeric equivalent:</p>
<pre tabindex="0"><code>Α = 1
φ = 500
ρ = 100
ο = 70
δ = 4
ί = 10
τ = 300
η = 8
</code></pre><p>This sums to 993 (ϡϙγ, if you prefer).</p>
<p>To recap, we have an algorithm that’s easy to compute, hard to reverse, and used to confirm that a secret is known without having to share the secret. Sound familiar? It’s a hash function! It’s weak by modern standards, but a hash function nonetheless.</p>
<blockquote>
<p>Every man has two deaths, when he is buried in the ground and the last time someone says his name.</p>
</blockquote>
<p>If you believe that, and we can find this woman’s name, we can resurrect her, so to speak, from that second kind of death. That’s the problem this program will attempt to solve.</p>
<p>Thanks to Oxford University, we have what we need for a dictionary attack: the <a href="https://www.lgpn.ox.ac.uk/">Lexicon of Greek Personal Names</a> (LGPN). It even has a searchable online database. So the program will compute the <em>arithmos</em> of each name and see if we have a plausible match.</p>
<h2 id="user-interface">User Interface</h2>
<p>This article is really focused on APIs (in the sense of code libraries, not REST, etc.), but the process of designing a good API overlaps with designing any other interface. And an application with good code and a bad UI is still useless. So let’s look at the UI first.</p>
<p>Like any UI designer, we need to start by understanding what the user is trying to do and what they’ll need. In this case, understanding the user is remarkably simple because I will probably be the only user ever. Personally I don’t need or even want a fancy graphical UI, I simply want to input a number and see potential names:</p>
<div><pre tabindex="0"><code data-lang="sh"><span><span>$ ./antisopsephy <span>545</span>
</span></span><span><span>Possible Name <span>1</span>
</span></span><span><span>Possible Name <span>2</span>
</span></span><span><span>...
</span></span></code></pre></div><p>Programmer me needs more details, but user me doesn’t care. So the programmer side of my split personality will have to figure that out. Putting the wishes of the caller before the wishes of the implementer is necessary for a good design. There is more to a good UI, even a minimal CLI like this, but let’s move on.</p>
<h2 id="downloading-names">Downloading names</h2>
<p>The LGPN has a endpoint which returns every names in their database as JSON, which is absolutely perfect for this program. But the response almost 5 MB in size which would be slow to download and parse for each run. Also the LGPN is a free service and I don’t want to abuse it, so the program needs to cache that response.</p>
<p>When designing an interface I find it helpful to start by writing the code that will call it. In this case the <code>main</code> function of the program needs to iterate over every name. Ideally, it would like something like this:</p>
<div><pre tabindex="0"><code data-lang="Go"><span><span><span>for</span> <span>_</span>, <span>name</span> <span>:=</span> <span>range</span> <span>lgpn</span>.<span>Names</span>() {
</span></span><span><span>	<span>if</span> <span>magicFunction</span>(<span>name</span>) <span>==</span> <span>searchNumber</span> {
</span></span><span><span>		<span>// It&#39;s a match!
</span></span></span><span><span><span></span>	}
</span></span><span><span>}
</span></span></code></pre></div><p>Reality, however, is never ideal. <code>Names()</code> could fail, so we’ll need an error. This also implies that <code>Names()</code> returns the whole list in memory. There are about 40,000 names, so it would easily fit, but since we only need one name at a time why load them all at once? Trying again:</p>
<div><pre tabindex="0"><code data-lang="Go"><span><span><span>names</span>, <span>err</span> <span>:=</span> <span>lgpn</span>.<span>Names</span>(<span>ctx</span>)
</span></span><span><span><span>if</span> <span>err</span> <span>!=</span> <span>nil</span> {
</span></span><span><span>	<span>// handle this!
</span></span></span><span><span><span></span>}
</span></span><span><span><span>for</span> <span>name</span> <span>:=</span> <span>range</span> <span>names</span> {
</span></span><span><span>	<span>// Same as before
</span></span></span><span><span><span></span>}
</span></span></code></pre></div><p>In this version, <code>Names()</code> returns a channel that will be closed when all the names have been sent or the context is canceled. This is one way to implement an iterator in Go, it uses a channel like a generator in other languages.</p>
<p>Our ideal interface lacks anything related to the LGPN service or the cache. This code in <code>main</code> is focused on the search algorithm, so URLs and cache locations aren’t relevant. They belong to a lower level of abstraction.</p>
<p>Of course, pushing the details down only works because we know what the caller needs. If, instead of an application, this were a general library making assumptions about where cache files should be stored would be bad form. Good interfaces are not one size fits all. They must be designed for a specific case.</p>
<p>Next, I like to stub out the functions and types:</p>
<div><pre tabindex="0"><code data-lang="Go"><span><span><span>func</span> <span>Names</span>(<span>ctx</span> <span>context</span>.<span>Context</span>) (<span>&lt;-</span><span>chan</span> <span>string</span>, <span>error</span>) {
</span></span><span><span>	<span>return</span> <span>nil</span>, <span>nil</span>
</span></span><span><span>}
</span></span></code></pre></div><p>One crucial part of the interface is missing: the documentation. A user of this code should be able to understand how to use it from the docs alone. If someone looks at the implementation for details to call the function,  the docs are incomplete.</p>
<div><pre tabindex="0"><code data-lang="Go"><span><span><span>// Names returns a channel that will receive every name in the Lexicon of Greek
</span></span></span><span><span><span>// Personal Names (LGPN). If the names cannot be retrieved an error is
</span></span></span><span><span><span>// returned.
</span></span></span><span><span><span>//
</span></span></span><span><span><span>// The returned channel will be closed after the last name has been read or
</span></span></span><span><span><span>// when the passed context is closed.
</span></span></span><span><span><span></span><span>func</span> <span>Names</span>(<span>ctx</span> <span>context</span>.<span>Context</span>) (<span>&lt;-</span><span>chan</span> <span>string</span>, <span>error</span>) {
</span></span><span><span>	<span>return</span> <span>nil</span>, <span>nil</span>
</span></span><span><span>}
</span></span></code></pre></div><p>When the docs are written first they become something of a spec. I often rewrite them later, but the result is always better documentation and probably better code.</p>
<h2 id="tests">Tests</h2>
<p>The interface to fetch names is not the least bit configurable. This was intentional, but it complicates the unit tests. I don’t want my test to download a file from the internet (that would be slow, flaky, and possibly abusive to the LGPN’s web service). I also want to control the cache file in a way that doesn’t destroy the cache used during normal execution.</p>
<p>There are several ways to handle this, but I will opt for another interface with more options. It’s pretty common to have a simple interface for most users that’s a front-end to a more powerful and more complicated interface. We’ll start by stubbing the interface:</p>
<div><pre tabindex="0"><code data-lang="Go"><span><span><span>// client handles fetching and caching of names from the LGPN.
</span></span></span><span><span><span></span><span>type</span> <span>client</span> <span>struct</span> {
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>// newClient returns a client which will connect to the LGPN using lgpnBase for
</span></span></span><span><span><span>// the URL and cache results in cacheDir.
</span></span></span><span><span><span>//
</span></span></span><span><span><span>// lgpnBase should contain the scheme and hostname of the URL. For example,
</span></span></span><span><span><span>// &#34;http://clas-lgpn2.classics.ox.ac.uk&#34; or &#34;http://localhost:8080&#34;. If
</span></span></span><span><span><span>// lgpnBase is an invalid URL newClient will panic.
</span></span></span><span><span><span>//
</span></span></span><span><span><span>// If cacheDir is an empty string a suitable directory will be selected based
</span></span></span><span><span><span>// of the system platform. If the cacheDir does not exist an attempt will be
</span></span></span><span><span><span>// made to create it. If there is any problem with the cacheDir newClient will
</span></span></span><span><span><span>// panic.
</span></span></span><span><span><span></span><span>func</span> <span>newClient</span>(<span>lgpnBase</span>, <span>cacheDir</span> <span>string</span>) <span>*</span><span>client</span> {
</span></span><span><span>	<span>return</span> <span>nil</span>
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>// Names is the internal implementation of the package-level Names function.
</span></span></span><span><span><span>// See that function for the documentation.
</span></span></span><span><span><span></span><span>func</span> (<span>c</span> <span>*</span><span>client</span>) <span>Names</span>(<span>ctx</span> <span>context</span>.<span>Context</span>) (<span>&lt;-</span><span>chan</span> <span>string</span>, <span>error</span>) {
</span></span><span><span>	<span>return</span> <span>nil</span>, <span>nil</span>
</span></span><span><span>}
</span></span></code></pre></div><p>These functions are not public (the lowercase first letter in <code>client</code>). The only callers of this code will be tests in the same package, so they don’t need to be exported. If I export something I’ll have to maintain it, and I see no reason to make unnecessary work for myself.</p>
<p>This more advanced interface enables us to write a unit that uses a mock web server instead of the real web service. There is a danger here that we’ll miss a bug in the little bit of code that wasn’t tested. But this untested code is minimal, and unit tests are not meant to replace all other testing.</p>
<h2 id="implementation">Implementation</h2>
<p>I know it’s taken a while to get to the “real code.” Designing an interface when you could be cranking out code may seem like a waste of time. But the real waste of time is ignoring the design and paying for it whenever someone needs to understand the mess you made. And it actually doesn’t take that long.</p>
<p>The implementation to download names is <a href="https://github.com/pboyd/antisopsephy/tree/master/internal/lgpn">nothing special</a>. It was mostly a matter of writing a test and filling out the stubbed methods. After the 3rd or 4th private method I wrote named <code>cache*</code> I split that code into another internal <code>cache</code> struct. Which did require another brief bit of interface design, but the process was the same the above.</p>
<h2 id="searching">Searching</h2>
<p>Now that we can iterate through the names, we can calculate the “number” of each name. This is straightforward, so the interface can be a single function call, which we will call like this:</p>
<div><pre tabindex="0"><code data-lang="Go"><span><span><span>for</span> <span>name</span> <span>:=</span> <span>range</span> <span>names</span> {
</span></span><span><span>	<span>n</span>, <span>err</span> <span>:=</span> <span>isopsephy</span>.<span>Calculate</span>(<span>name</span>)
</span></span><span><span>	<span>if</span> <span>err</span> <span>!=</span> <span>nil</span> {
</span></span><span><span>		<span>fmt</span>.<span>Fprintf</span>(<span>os</span>.<span>Stderr</span>, <span>&#34;invalid name: %v\n&#34;</span>, <span>err</span>)
</span></span><span><span>		<span>continue</span>
</span></span><span><span>	}
</span></span><span><span>
</span></span><span><span>	<span>if</span> <span>n</span> <span>==</span> <span>number</span> {
</span></span><span><span>		<span>fmt</span>.<span>Println</span>(<span>name</span>)
</span></span><span><span>	}
</span></span><span><span>}
</span></span></code></pre></div><p>Nothing fancy, but that’s fine. It doesn’t need to be. The <code>Calculate</code> function interface is much like you probably expect:</p>
<div><pre tabindex="0"><code data-lang="Go"><span><span><span>// Calculate finds the &#34;number&#34; of a word by summing the numeric equivalent of
</span></span></span><span><span><span>// each Greek letter. If an unrecognized character is encountered an error is
</span></span></span><span><span><span>// returned.
</span></span></span><span><span><span></span><span>func</span> <span>Calculate</span>(<span>word</span> <span>string</span>) (<span>int</span>, <span>error</span>) {
</span></span><span><span><span>...</span>
</span></span><span><span>}
</span></span></code></pre></div><p>With that, the program is complete. It can search for the number of any Greek name and report matches, which is all I wanted.</p>
<h2 id="results">Results</h2>
<p>Searching for 545 (the number from the graffiti) gave me 25 potential names. Most of those can be excluded because they were either male names or from the wrong time period. Unfortunately, none were very likely matches, so the best I can do is pick relatively popular names from the time period. My two favorites are:</p>
<ul>
<li>Γάουιλλα (Gaoülla)</li>
<li>Κυθερία (Kütheria)</li>
</ul>
<p>Of course, there’s no way to confirm either of these. For all I know, the name was never recorded, or our would-be lover added it incorrectly. Such is life.</p>
<p>If you want to play with this program I know of two similar inscriptions from the Ancient Graffiti Project: <a href="http://ancientgraffiti.org/Graffiti/graffito/AGP-SMYT00221">1</a> <a href="http://ancientgraffiti.org/Graffiti/graffito/AGP-SMYT00242">2</a>, and there are probably others.</p>
<p>If you want to know more about software design, I’d recommend <a href="https://web.stanford.edu/~ouster/cgi-bin/book.php">A Philosophy of Software Design</a> by John Ouserhout. Many of the ideas in this post are his.</p>
<p>The source code for this program is on <a href="https://github.com/pboyd/antisopsephy/">github</a>.</p>


			</div></div>
  </body>
</html>
