<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://docs.astral.sh/uv/concepts/build-backend/">Original</a>
    <h1>The uv build back end is now stable</h1>
    
    <div id="readability-page-1" class="page"><article>
                
                  

  
  



<div>
<p>Note</p>
<p>Currently, the default build backend for <code>uv init</code> is
<a href="https://pypi.org/project/hatchling/">hatchling</a>. This will change to <code>uv</code> in a future version.</p>
</div>
<p>A build backend transforms a source tree (i.e., a directory) into a source distribution or a wheel.</p>
<p>uv supports all build backends (as specified by <a href="https://peps.python.org/pep-0517/">PEP 517</a>), but
also provides a native build backend (<code>uv_build</code>) that integrates tightly with uv to improve
performance and user experience.</p>
<h2 id="choosing-a-build-backend"><a href="#choosing-a-build-backend">Choosing a build backend</a></h2>
<p>The uv build backend is a great choice for most Python projects. It has reasonable defaults, with
the goal of requiring zero configuration for most users, but provides flexible configuration to
accommodate most Python project structures. It integrates tightly with uv, to improve messaging and
user experience. It validates project metadata and structures, preventing common mistakes. And,
finally, it&#39;s very fast.</p>
<p>The uv build backend currently <strong>only supports pure Python code</strong>. An alternative backend is
required to build a
<a href="https://docs.astral.sh/uv/concepts/projects/init/#projects-with-extension-modules">library with extension modules</a>.</p>
<div>
<p>Tip</p>
<p>While the backend supports a number of options for configuring your project structure, when build scripts or
a more flexible project layout are required, consider using the
<a href="https://hatch.pypa.io/latest/config/build/#build-system">hatchling</a> build backend instead.</p>
</div>
<h2 id="using-the-uv-build-backend"><a href="#using-the-uv-build-backend">Using the uv build backend</a></h2>
<p>To use uv as a build backend in an existing project, add <code>uv_build</code> to the
<a href="https://docs.astral.sh/uv/concepts/projects/config/#build-systems"><code>[build-system]</code></a> section in your <code>pyproject.toml</code>:</p>
<div><p><span>pyproject.toml</span></p><pre><span></span><code><a id="__codelineno-0-1" name="__codelineno-0-1" href="#__codelineno-0-1"></a><span>[build-system]</span>
<a id="__codelineno-0-2" name="__codelineno-0-2" href="#__codelineno-0-2"></a><span>requires</span><span> </span><span>=</span><span> </span><span>[</span><span>&#34;uv_build&gt;=0.7.19,&lt;0.8.0&#34;</span><span>]</span>
<a id="__codelineno-0-3" name="__codelineno-0-3" href="#__codelineno-0-3"></a><span>build-backend</span><span> </span><span>=</span><span> </span><span>&#34;uv_build&#34;</span>
</code></pre></div>
<div>
<p>Note</p>
<p>The uv build backend follows the same <a href="https://docs.astral.sh/uv/reference/policies/versioning/">versioning policy</a>
as uv. Including an upper bound on the <code>uv_build</code> version ensures that your package continues to
build correctly as new versions are released.</p>
</div>
<p>To create a new project that uses the uv build backend, use <code>uv init</code>:</p>
<div><pre><span></span><code><a id="__codelineno-1-1" name="__codelineno-1-1" href="#__codelineno-1-1"></a><span>$ </span>uv<span> </span>init<span> </span>--build-backend<span> </span>uv
</code></pre></div>
<p>When the project is built, e.g., with <a href="https://docs.astral.sh/uv/guides/package/"><code>uv build</code></a>, the uv build backend will
be used to create the source distribution and wheel.</p>
<h2 id="bundled-build-backend"><a href="#bundled-build-backend">Bundled build backend</a></h2>
<p>The build backend is published as a separate package (<code>uv_build</code>) that is optimized for portability
and small binary size. However, the <code>uv</code> executable also includes a copy of the build backend, which
will be used during builds performed by uv, e.g., during <code>uv build</code>, if its version is compatible
with the <code>uv_build</code> requirement. If it&#39;s not compatible, a compatible version of the <code>uv_build</code>
package will be used. Other build frontends, such as <code>python -m build</code>, will always use the
<code>uv_build</code> package, typically choosing the latest compatible version.</p>
<h2 id="modules"><a href="#modules">Modules</a></h2>
<p>Python packages are expected to contain one or more Python modules, which are directories containing
an <code>__init__.py</code>. By default, a single root module is expected at <code>src/&lt;package_name&gt;/__init__.py</code>.</p>
<p>For example, the structure for a project named <code>foo</code> would be:</p>
<div><pre><span></span><code><a id="__codelineno-2-1" name="__codelineno-2-1" href="#__codelineno-2-1"></a>pyproject.toml
<a id="__codelineno-2-2" name="__codelineno-2-2" href="#__codelineno-2-2"></a>src
<a id="__codelineno-2-3" name="__codelineno-2-3" href="#__codelineno-2-3"></a>└── foo
<a id="__codelineno-2-4" name="__codelineno-2-4" href="#__codelineno-2-4"></a>    └── __init__.py
</code></pre></div>
<p>uv normalizes the package name to determine the default module name: the package name is lowercased
and dots and dashes are replaced with underscores, e.g., <code>Foo-Bar</code> would be converted to <code>foo_bar</code>.</p>
<p>The <code>src/</code> directory is the default directory for module discovery.</p>
<p>These defaults can be changed with the <code>module-name</code> and <code>module-root</code> settings. For example, to use
a <code>FOO</code> module in the root directory, as in the project structure:</p>
<div><pre><span></span><code><a id="__codelineno-3-1" name="__codelineno-3-1" href="#__codelineno-3-1"></a>pyproject.toml
<a id="__codelineno-3-2" name="__codelineno-3-2" href="#__codelineno-3-2"></a>FOO
<a id="__codelineno-3-3" name="__codelineno-3-3" href="#__codelineno-3-3"></a>└── __init__.py
</code></pre></div>
<p>The correct build configuration would be:</p>
<div><p><span>pyproject.toml</span></p><pre><span></span><code><a id="__codelineno-4-1" name="__codelineno-4-1" href="#__codelineno-4-1"></a><span>[tool.uv.build-backend]</span>
<a id="__codelineno-4-2" name="__codelineno-4-2" href="#__codelineno-4-2"></a><span>module-name</span><span> </span><span>=</span><span> </span><span>&#34;FOO&#34;</span>
<a id="__codelineno-4-3" name="__codelineno-4-3" href="#__codelineno-4-3"></a><span>module-root</span><span> </span><span>=</span><span> </span><span>&#34;&#34;</span>
</code></pre></div>
<h2 id="namespace-packages"><a href="#namespace-packages">Namespace packages</a></h2>
<p>Namespace packages are intended for use-cases where multiple packages write modules into a shared
namespace.</p>
<p>Namespace package modules are identified by a <code>.</code> in the <code>module-name</code>. For example, to package the
module <code>bar</code> in the shared namespace <code>foo</code>, the project structure would be:</p>
<div><pre><span></span><code><a id="__codelineno-5-1" name="__codelineno-5-1" href="#__codelineno-5-1"></a>pyproject.toml
<a id="__codelineno-5-2" name="__codelineno-5-2" href="#__codelineno-5-2"></a>src
<a id="__codelineno-5-3" name="__codelineno-5-3" href="#__codelineno-5-3"></a>└── foo
<a id="__codelineno-5-4" name="__codelineno-5-4" href="#__codelineno-5-4"></a>    └── bar
<a id="__codelineno-5-5" name="__codelineno-5-5" href="#__codelineno-5-5"></a>        └── __init__.py
</code></pre></div>
<p>And the <code>module-name</code> configuration would be:</p>
<div><p><span>pyproject.toml</span></p><pre><span></span><code><a id="__codelineno-6-1" name="__codelineno-6-1" href="#__codelineno-6-1"></a><span>[tool.uv.build-backend]</span>
<a id="__codelineno-6-2" name="__codelineno-6-2" href="#__codelineno-6-2"></a><span>module-name</span><span> </span><span>=</span><span> </span><span>&#34;foo.bar&#34;</span>
</code></pre></div>
<div>
<p>Important</p>
<p>The <code>__init__.py</code> file is not included in <code>foo</code>, since it&#39;s the shared namespace module.</p>
</div>
<p>It&#39;s also possible to have a complex namespace package with more than one root module, e.g., with
the project structure:</p>
<div><pre><span></span><code><a id="__codelineno-7-1" name="__codelineno-7-1" href="#__codelineno-7-1"></a>pyproject.toml
<a id="__codelineno-7-2" name="__codelineno-7-2" href="#__codelineno-7-2"></a>src
<a id="__codelineno-7-3" name="__codelineno-7-3" href="#__codelineno-7-3"></a>├── foo
<a id="__codelineno-7-4" name="__codelineno-7-4" href="#__codelineno-7-4"></a>│   └── __init__.py
<a id="__codelineno-7-5" name="__codelineno-7-5" href="#__codelineno-7-5"></a>└── bar
<a id="__codelineno-7-6" name="__codelineno-7-6" href="#__codelineno-7-6"></a>    └── __init__.py
</code></pre></div>
<p>While we do not recommend this structure (i.e., you should use a workspace with multiple packages
instead), it is supported via the <code>namespace</code> option:</p>
<div><p><span>pyproject.toml</span></p><pre><span></span><code><a id="__codelineno-8-1" name="__codelineno-8-1" href="#__codelineno-8-1"></a><span>[tool.uv.build-backend]</span>
<a id="__codelineno-8-2" name="__codelineno-8-2" href="#__codelineno-8-2"></a><span>namespace</span><span> </span><span>=</span><span> </span><span>true</span>
</code></pre></div>
<h2 id="stub-packages"><a href="#stub-packages">Stub packages</a></h2>
<p>The build backend also supports building type stub packages, which are identified by the <code>-stubs</code>
suffix on the package or module name, e.g., <code>foo-stubs</code>. The module name for type stub packages must
end in <code>-stubs</code>, so uv will not normalize the <code>-</code> to an underscore. Additionally, uv will search for
a <code>__init__.pyi</code> file. For example, the project structure would be:</p>
<div><pre><span></span><code><a id="__codelineno-9-1" name="__codelineno-9-1" href="#__codelineno-9-1"></a>pyproject.toml
<a id="__codelineno-9-2" name="__codelineno-9-2" href="#__codelineno-9-2"></a>src
<a id="__codelineno-9-3" name="__codelineno-9-3" href="#__codelineno-9-3"></a>└── foo-stubs
<a id="__codelineno-9-4" name="__codelineno-9-4" href="#__codelineno-9-4"></a>    └── __init__.pyi
</code></pre></div>
<p>Type stub modules are also supported for <a href="#namespace-packages">namespace packages</a>.</p>
<h2 id="file-inclusion-and-exclusion"><a href="#file-inclusion-and-exclusion">File inclusion and exclusion</a></h2>
<p>The build backend is responsible for determining which files in a source tree should be packaged
into the distributions.</p>
<p>To determine which files to include in a source distribution, uv first adds the included files and
directories, then removes the excluded files and directories. This means that exclusions always take
precedence over inclusions.</p>
<p>By default, uv excludes <code>__pycache__</code>, <code>*.pyc</code>, and <code>*.pyo</code>.</p>
<p>When building a source distribution, the following files and directories are included:</p>
<ul>
<li>The <code>pyproject.toml</code></li>
<li>The <a href="#modules">module</a> under
  <a href="https://docs.astral.sh/uv/reference/settings/#build-backend_module-root"><code>tool.uv.build-backend.module-root</code></a>.</li>
<li>The files referenced by <code>project.license-files</code> and <code>project.readme</code>.</li>
<li>All directories under <a href="https://docs.astral.sh/uv/reference/settings/#build-backend_data"><code>tool.uv.build-backend.data</code></a>.</li>
<li>All files matching patterns from
  <a href="https://docs.astral.sh/uv/reference/settings/#build-backend_source-include"><code>tool.uv.build-backend.source-include</code></a>.</li>
</ul>
<p>From these, items matching
<a href="https://docs.astral.sh/uv/reference/settings/#build-backend_source-exclude"><code>tool.uv.build-backend.source-exclude</code></a> and
the <a href="https://docs.astral.sh/uv/reference/settings/#build-backend_default-excludes">default excludes</a> are removed.</p>
<p>When building a wheel, the following files and directories are included:</p>
<ul>
<li>The <a href="#modules">module</a> under
  <a href="https://docs.astral.sh/uv/reference/settings/#build-backend_module-root"><code>tool.uv.build-backend.module-root</code></a></li>
<li>The files referenced by <code>project.license-files</code>, which are copied into the <code>.dist-info</code> directory.</li>
<li>The <code>project.readme</code>, which is copied into the project metadata.</li>
<li>All directories under <a href="https://docs.astral.sh/uv/reference/settings/#build-backend_data"><code>tool.uv.build-backend.data</code></a>,
  which are copied into the <code>.data</code> directory.</li>
</ul>
<p>From these,
<a href="https://docs.astral.sh/uv/reference/settings/#build-backend_source-exclude"><code>tool.uv.build-backend.source-exclude</code></a>,
<a href="https://docs.astral.sh/uv/reference/settings/#build-backend_wheel-exclude"><code>tool.uv.build-backend.wheel-exclude</code></a> and
the default excludes are removed. The source dist excludes are applied to avoid source tree to wheel
source builds including more files than source tree to source distribution to wheel build.</p>
<p>There are no specific wheel includes. There must only be one top level module, and all data files
must either be under the module root or in the appropriate
<a href="https://docs.astral.sh/uv/reference/settings/#build-backend_data">data directory</a>. Most packages store small data in the
module root alongside the source code.</p>
<h3 id="include-and-exclude-syntax"><a href="#include-and-exclude-syntax">Include and exclude syntax</a></h3>
<p>Includes are anchored, which means that <code>pyproject.toml</code> includes only <code>&lt;root&gt;/pyproject.toml</code> and
not <code>&lt;root&gt;/bar/pyproject.toml</code>. To recursively include all files under a directory, use a <code>/**</code>
suffix, e.g. <code>src/**</code>. Recursive inclusions are also anchored, e.g., <code>assets/**/sample.csv</code> includes
all <code>sample.csv</code> files in <code>&lt;root&gt;/assets</code> or any of its children.</p>
<div>
<p>Note</p>
<p>For performance and reproducibility, avoid patterns without an anchor such as <code>**/sample.csv</code>.</p>
</div>
<p>Excludes are not anchored, which means that <code>__pycache__</code> excludes all directories named
<code>__pycache__</code> regardless of its parent directory. All children of an exclusion are excluded as well.
To anchor a directory, use a <code>/</code> prefix, e.g., <code>/dist</code> will exclude only <code>&lt;root&gt;/dist</code>.</p>
<p>All fields accepting patterns use the reduced portable glob syntax from
<a href="https://peps.python.org/pep-0639/#add-license-FILES-key">PEP 639</a>, with the addition that
characters can be escaped with a backslash.</p>

  
    
  
  


  


  




                
              </article></div>
  </body>
</html>
