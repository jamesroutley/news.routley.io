<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lwn.net/SubscriberLink/896267/6bac8e29d614ec66/">Original</a>
    <h1>splice() and the ghost of set_fs()</h1>
    
    <div id="readability-page-1" class="page"><p>

<h2>[LWN subscriber-only content]</h2>
</p><div>
<!-- $Id: slink-none,v 1.2 2005-11-04 22:11:18 corbet Exp $ -->
<blockquote>
<div>
<h3>Welcome to LWN.net</h3>
<p>
The following subscription-only content has been made available to you 
by an LWN subscriber.  Thousands of subscribers depend on LWN for the 
best news from the Linux and free software communities.  If you enjoy this 
article, please consider <a href="https://lwn.net/subscribe/">subscribing to LWN</a>.  Thank you
for visiting LWN.net!
</p></div>
</blockquote>
<p>
The normal rule of kernel development is that the creation of user-space
regressions is not allowed; a patch that breaks a previously working
application must be either fixed or reverted.  There are exceptions,
though, including <a href="https://git.kernel.org/linus/36e2c7421f02">a
5.10 patch</a> that has been turning up regressions ever since.  The story
that emerges here shows what can happen when the goals of stability,
avoiding security problems, and code cleanup run into conflict.
</p><p>
The <tt>set_fs()</tt> function was added to the kernel early in its
history; it was not in the initial 0.01 release, but was added before the
0.10 release in late 1991.
Normally, kernel code that is intended to access user-space memory will
generate an error if it attempts to access kernel space instead; this
restriction prevents, for example, attempts by an attacker to access kernel
memory via system calls.  A call to
<tt>set_fs(KERNEL_DS)</tt> can be used to lift the restriction when the 
need arises; a common use case for <tt>set_fs()</tt> is to be able to
perform file I/O from within the kernel.  Calling <tt>set_fs(USER_DS)</tt>
puts the restriction back.
</p><p>
The problem with <tt>set_fs()</tt> is that it turns out to be easy to
forget the second <tt>set_fs()</tt> call to restore the protection of
kernel space, leading directly to the &#34;total compromise&#34; scenario that
kernel developers will normally take some pains to avoid.  Numerous such
bugs have been fixed over the years, but it had long been clear that the
real solution was to just get rid of <tt>set_fs()</tt> entirely and adopt
safer ways of accessing kernel memory when needed.
</p><p>
Developers (and Christoph Hellwig in particular) got more serious about
this objective in 2020 and <a href="https://lwn.net/Articles/832121/">made a determined
push</a> to eliminate <tt>set_fs()</tt> entirely.  Much of this work went
into 5.10, though the final bits of the <tt>set_fs()</tt> infrastructure
were only removed in 5.18.  Back in 2020, though, one question that
provoked some discussion was what should be done about <a href="https://man7.org/linux/man-pages/man2/splice.2.html"><tt>splice()</tt></a>.
</p><p>
The <tt>splice()</tt> system call will connect an open file descriptor to a
pipe, then move data between the two for as long as the data stream lasts.
This movement happens entirely within the kernel, potentially eliminating
the need for large numbers of system calls; in some settings, it can
provide a significant performance improvement.  By its nature,
<tt>splice()</tt> often has to move data to and from buffers that are in
kernel space; to make that possible, it used <tt>set_fs()</tt>.
</p><p>
Hellwig duly came up with a new implementation that would keep
<tt>splice()</tt> working in the absence of <tt>set_fs()</tt>, but Linus
Torvalds <a href="https://lwn.net/ml/linux-kernel/CAHk-=wit9enePELG=-HnLsr0nY5bucFNjqAqWoFTuYDGR1P4KA@mail.gmail.com/">rejected
it</a>, saying that he didn&#39;t like the &#34;<span>complexity and
messiness</span>&#34; of the implementation.  But he also made it clear that he
didn&#39;t feel the need to guarantee that <tt>splice()</tt> would keep working
at all; he felt that making <tt>splice()</tt> work by default on most file
types led to a number of security issues.  Later in 2020, for example, he <a href="https://lwn.net/ml/linux-kernel/CAHk-%3DwiXQVE_jGN0ajk%2BKm925WSbCL16mAZ-UXNkp%2Bnkc1nuQw%40mail.gmail.com/">said</a>:
</p><blockquote>
	I&#39;d rather limit splice (and kernel_read too, for that matter) as
	much as possible. It was a mistake originally to allow it
	everywhere, and it&#39;s come back to bite us.
<p>
	So I&#39;d rather have people notice these odd corner cases and get
	them fixed one by one than just say &#34;anything goes&#34;.
</p></blockquote>
<p>
So the patches that went into 5.10 ended up breaking <tt>splice()</tt> for
any file 
type that did not have explicit support for the new way of doing things;
the idea was that the important cases would be noticed and fixed over time.
That has indeed happened; if one looks for patches committed as explicit
fixes to the disabling of <tt>splice()</tt> support, one finds fixes for
<a href="https://git.kernel.org/linus/06a17bbe1d47">the AFS filesystem</a>,
<a href="https://git.kernel.org/linus/cf03f316ad20">the 9p filesystem</a>,
<a href="https://git.kernel.org/linus/c1048828c3db">the orangefs filesystem</a>,
<a href="https://git.kernel.org/linus/14e3e989f6a5"><tt>/proc/mountinfo</tt></a>,
<a href="https://git.kernel.org/linus/dd78b0c483e3">the TTY subsystem</a>,
<a href="https://git.kernel.org/linus/f2d6c2708bd8">kernfs</a>,
<a href="https://git.kernel.org/linus/f8ad8187c3b5"><tt>sendfile()</tt></a>,
<a href="https://git.kernel.org/linus/a35d8f016e0b">the nilfs2
filesystem</a>, and
<a href="https://git.kernel.org/linus/42984af09afc">the JFFS2 filesystem</a>.
</p><p>
Most recently, Jens Axboe <a href="https://lwn.net/ml/linux-kernel/20220519193133.194138-1-axboe@kernel.dk/">reported</a>
that <tt>splice()</tt> no longer worked on <tt>/dev/random</tt> or
<tt>/dev/urandom</tt>; he 
included a patch to fix the problem as well.  These patches were later <a href="https://lwn.net/ml/linux-kernel/20220520094459.116240-1-Jason@zx2c4.com/">reworked</a>
by random-number-generator maintainer Jason Donenfeld and were applied to
the mainline during the 5.19 merge window.

Along the way, Donenfeld <a href="https://lwn.net/ml/linux-kernel/Yoey+FOYO69lS5qP@zx2c4.com/">observed</a> that the
necessary changes resulted in a performance regression of about 3% when
reading from <tt>/dev/urandom</tt>.  That led him to ask whether the fix
was something that was needed at all; after some discussion, Axboe <a href="https://lwn.net/ml/linux-kernel/72344aad-b5ad-b317-d36d-385cb16d5204@kernel.dk/">gave
him the lecture</a> on regressions:
</p><blockquote>
	 If you have an application that is written using eg splice from
	 /dev/urandom, then it should indeed be safe to expect that it will
	 indeed continue working. If we have one core tenet in the kernel
	 it&#39;s that you should ALWAYS be able to upgrade your kernel and not
	 have any breakage in terms of userspace ABI. Obviously that can
	 happen sometimes, but I think this one is exactly the poster child
	 of breakage that should NOT happen. We took away a feature that
	 someone depended on.
</blockquote>
<p>
That is the sort of breakage that did indeed happen but, in this case, a
change was made knowing that this kind of problem would result.  Hellwig
<a href="https://lwn.net/ml/linux-kernel/20220520060244.GA16503@lst.de/">said</a> in
response to Axboe&#39;s patch set that &#34;<span>compared to my initial fears the
fallout actually isn&#39;t 
that bad</span>&#34;, but a perusal of the above list of fixes might lead one
to a different conclusion.
</p><p>
The removal of <tt>set_fs()</tt> is, in many ways, a model for what the
kernel development process can do.  A fundamental piece of low-level
structure that had been deeply wired into the kernel since the beginning
was replaced with a much safer alternative without breaking the project&#39;s
pace of a stable release every nine or ten weeks.  The steady stream of
regressions resulting from this change, though, is not what the project
sets out to do â€” and it seems 
certain that this particular gift has not yet stopped giving.
</p><p>
The decision to take this path was driven by a fear of security problems,
based on the past history of the <tt>splice()</tt> system call.  If those
fears are still justified (and they might well be; consider, for example,
that <tt>splice()</tt> 
was a part of the <a href="https://dirtypipe.cm4all.com/">&#34;Dirty Pipe&#34;
vulnerability</a> reported earlier this year), then refusing to make all
existing <tt>splice()</tt> implementations just work without
<tt>set_fs()</tt> may have prevented far worse regressions than the ones we
have seen.  Having to fix a filesystem is annoying; having to endure yet
another security drill for a branded vulnerability with a silly
name is rather more so.
</p><p>
There is no way of knowing whether that is how things would have gone in
this case.  But it is
true that this type of episode makes the kernel&#39;s &#34;no regressions&#34; rule
look a bit more like just a guideline.  It does not take too many of those
to create breakage to the project&#39;s reputation that is hard to splice back together.</p>
               </div></div>
  </body>
</html>
