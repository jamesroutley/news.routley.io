<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://research.nccgroup.com/2023/02/06/rustproofing-linux-part-1-4-leaking-addresses/">Original</a>
    <h1>Rustproofing Linux (Part 1/4 Leaking Addresses) (2023)</h1>
    
    <div id="readability-page-1" class="page"><div>
  

  <section>
        
        
    </section>

    <section>
      
                    <div>
          
<p><a href="https://www.rust-lang.org/">Rust</a> is a programming
language guaranteeing memory and thread safety while still being able to
access raw memory and hardware. This sounds impossible, and it is,
that’s why Rust has an <code>unsafe</code> keyword which allows a
programmer to dereference a raw pointer and perform some other dangerous
operations. The dangerous code is effectively contained to
<code>unsafe</code> blocks, which makes Rust an interesting option for
embedded and system programming, where it could potentially be used to
replace C, which has a long history of memory safety
vulnerabilities.</p>
<p><a href="https://kernel.org/">The Linux Kernel</a>, like many other
operating system kernels, has a long history of memory and thread safety <a href="https://www.linuxkernelcves.com/cves">vulnerabilities</a>. <a href="https://github.com/Rust-for-Linux/linux">The Rust for Linux
project</a> aims to add Rust language support to the Linux Kernel and
try to improve the security situation. Serious efforts to bring Rust
into the mainline started in <a href="https://lkml.org/lkml/2021/4/14/1023">April 2021</a> and after
many patch iterations, minimal Rust support has been <a href="https://lwn.net/Articles/910762/">merged</a> into <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/rust?h=v6.1">Linux
6.1</a>.</p>
<p>With rudimentary Rust support now existing in the Linux Kernel, we
expect some developers will try writing new device drivers in Rust, and
some will port existing ones (e.g., Google has already developed a
prototype of the <a href="https://security.googleblog.com/2021/04/rust-in-linux-kernel.html">Binder
driver</a>). This blog series explores security aspects of porting a
Linux device driver from C to Rust. We have created <a href="https://github.com/nccgroup/rustproofing-linux/">five vulnerable
drivers</a> in C, ported them to Rust, explored a few porting variants
that make use of different Rust APIs, and discussed how plausible it is
for vulnerabilities to persist across the porting process.</p>
<p>This exploration was done from the perspective of a C programmer who
is a beginner in Rust. My Rust code might not be idiomatic Rust, and
could probably be described as “path of least resistance” Rust, which
might not be too far off from what the other developers will
attempt.</p>
<p>The blog series is made of four parts:</p>
<ul>
<li><a href="https://research.nccgroup.com/?p=18577">Part 1 – Leaking Addresses</a> – you’re reading it now</li>
<li><a href="https://research.nccgroup.com/?p=18655">Part 2 – Race Conditions</a></li>
<li><a href="https://research.nccgroup.com/?p=18658">Part 3 – Integer Overflows</a></li>
<li><a href="https://research.nccgroup.com/?p=18659">Part 4 – Shared Memory</a></li>
</ul>

<p>Let’s get started with a very <a href="https://github.com/nccgroup/rustproofing-linux/blob/main/vuln_printk_leak.c">simple
device driver</a>. It only implements one <code>ioctl</code> command,
<code>VULN_PRINT_ADDR</code>, which prints the address of the handling
function itself and an address of a stack variable.</p>
<p>While printing a kernel address seems rather innocent – it’s just a
number after all – these values are useful sources of information
leakage that assists an attacker in bypassing KASLR when developing an
exploit for a memory safety vulnerability. The Linux kernel has aimed to
reduce such infoleaks for quite some time as per <a href="https://kernsec.org/wiki/index.php/Bug_Classes/Kernel_pointer_leak">KSPP
Kernel pointer leak page</a>. Eventually the <code>&#34;%p&#34;</code> format
string in the Linux Kernel was changed to print a hashed pointer value
instead of leaking sensitive memory layout information.</p>
<p>The <code>&#34;%p&#34;</code> printing restriction was bypassed in our driver
with a <code>printk</code> specific format string <a href="https://www.kernel.org/doc/Documentation/printk-formats.txt"><code>&#34;%px&#34;</code></a>
that can be used when you <em>really</em> want to print the address.</p>
<p>When <a href="https://github.com/nccgroup/rustproofing-linux/blob/main/rust_vuln_printk_leak.rs">porting
this code to Rust</a>, one can see some boilerplate changes. Rust’s
<code>module_misc_device!</code> macro neatly merged some
miscdevice/module boilerplate, and <code>struct file_operations</code>
is now a set of methods that are implemented on the driver struct. The
problematic lines themselves have few changes.</p>
<p>The original C version is shown below:</p>
<pre><span>pr_info</span><span>(</span><span>&#34;%s is at address %px</span><span>n</span><span>&#34;</span><span>,</span> __func__<span>,  </span>__func__<span>);</span>
<span>pr_info</span><span>(</span><span>&#34;stack is at address %px</span><span>n</span><span>&#34;</span><span>,  </span>stack_dummy<span>);</span>
</pre>
<p><span>Original C version</span></p><p>And the Rust version looks quite similar:</p>
<pre>pr_info<span>!(</span><span>&#34;RustVuln::ioctl is at address {:p}</span><span></span><span>n&#34;</span><span>,</span> <span>Self</span><span>::</span>ioctl <span>as</span> <span>*</span><span>const</span> <span>());</span>
pr_info<span>!(</span><span>&#34;stack is at address {:p}</span><span></span><span>n&#34;</span><span>,  </span>stack_dummy<span>);</span>
</pre>
<p><span>Rust version</span></p><p>In Rust, format strings are different, but that is easy to figure
out.</p>
<p>Surprisingly, despite the vast efforts to eliminate pointer infoleaks
in the Linux kernel, the Rust frameworks seemingly take a step backwards
on this front. In Rust, one can actually just use <code>&#34;{:p}&#34;</code> as
an equivalent to <code>&#34;%p&#34;</code> to print pointer values. To be
crystal clear: The Rust <code>pr_info!</code> macro does not hash the
pointer value like the C <code>pr_info</code> function does. We have
reported this to the Rust for Linux maintainers.</p>
<p>It might be surprising to some that the raw addresses are easily
accessible. Sure there’s a somewhat odd looking
<code>Self::ioctl as *const ()</code> (basically a cast to a void
pointer), but no <code>unsafe</code> or anything like that.</p>
<p>Developers who feel the need to print pointer values in C, will
probably continue to do so after porting their drivers to Rust.</p>

<p>First, some backstory: The C standards do not require that memory
covered by the struct but not belonging to any of its members is
initialised to any value. That is, padding between structure members is
not guaranteed to be initialised. This can be a bit surprising, since
one does not expect uninitialised data in an initialised data
container.</p>
<p>When such structures are copied across kernel trust boundaries (for
example, as syscall outputs) small portions of kernel memory may be
revealed to user space, constituting an info leak. <a href="https://lwn.net/Articles/417989/">This</a> <a href="https://research.nccgroup.com/2019/10/30/padding-the-struct-how-a-compiler-optimization-can-disclose-stack-memory/">problem</a>
has <a href="https://sefcom.asu.edu/publications/leak-kptr-woot20.pdf">apparently</a>
<a href="https://seclists.org/oss-sec/2017/q4/357">happened</a> <a href="https://seclists.org/oss-sec/2021/q2/218">often</a> <a href="https://seclists.org/oss-sec/2022/q4/188">enough</a> that the
Linux kernel now has an automatic stack initialisation <a href="https://lwn.net/Articles/823152/">feature</a>. To fix these types
of problems, enable <code>CONFIG_INIT_STACK_ALL_PATTERN</code> or
<code>CONFIG_INIT_STACK_ALL_ZERO</code> (there’s also the
<code>init_on_alloc</code> boot parameter that zero initialises SLAB
memory).</p>
<p>We have created an <a href="https://github.com/nccgroup/rustproofing-linux/blob/main/vuln_stack_leak.c">example
driver</a> to demonstrate how stack contents can be leaked accidentally.
<em>Note: for this demonstration to work, the kernel needs to be
configured with <code>CONFIG_INIT_STACK_NONE=y</code>, which disables
automatic stack variable initialisation</em>. The interesting part
follows:</p>
<pre><span>struct</span> vuln_info <span>{</span>
        u8 version<span>;</span>
        u64 id<span>;</span>
        u8 _reserved<span>;</span>
<span>};</span>

<span>static long</span> <span>vuln_ioctl</span><span>(</span><span>struct</span> file <span>*</span>filp<span>,</span> <span>unsigned int</span> cmd<span>,</span> <span>unsigned long</span> arg<span>)</span>
<span>{</span>
        <span>struct</span> vuln_info info<span>;</span>

        <span>switch</span> <span>(</span>cmd<span>) {</span>
        <span>case</span> VULN_GET_INFO<span>:</span>
                info <span>= (</span><span>struct</span> vuln_info<span>) {</span>
                        <span>.</span>version <span>=</span> <span>1</span><span>,</span>
                        <span>.</span>id <span>=</span> <span>0x1122334455667788</span><span>,</span>
                <span>};</span>
                <span>if</span> <span>(</span><span>copy_to_user</span><span>((</span><span>void</span> __user <span>*)</span>arg<span>,  </span>info<span>,</span> <span>sizeof</span><span>(</span>info<span>)) !=</span> <span>0</span><span>)</span>
</pre>
<p><span><code>ioctl</code> leaking stack memory contents</span></p><p>As described, the entire struct is not initialised. While the
<code>_reserved</code> member is implicitly initialised by the compiler,
the padding bytes are not.</p>
<p>In memory, this data structure will be represented as:</p>
<table>
  <tbody><tr>
    <th>Offset  Byte</th>
    <th>7</th>
    <th>6</th>
    <th>5</th>
    <th>4</th>
    <th>3</th>
    <th>2</th>
    <th>1</th>
    <th>0</th>
  </tr>
  <tr>
    <td><i>0</i></td>
    <td colspan="7">Padding</td>
    <td><tt>01</tt></td>
  </tr>
  <tr>
    <td><i>8</i></td>
    <td><tt>11</tt></td>
    <td><tt>22</tt></td>
    <td><tt>33</tt></td>
    <td><tt>44</tt></td>
    <td><tt>55</tt></td>
    <td><tt>66</tt></td>
    <td><tt>77</tt></td>
    <td><tt>88</tt></td>
  </tr>
  <tr>
    <td><i>16</i></td>
    <td colspan="7">Padding</td>
    <td><tt>00</tt></td>
  </tr>
</tbody></table>
<p><span>Memory layout of struct vuln_info</span></p><p>We can test the transferred padding values with a <a href="https://github.com/nccgroup/rustproofing-linux/blob/main/poc/poc_vuln_stack_leak.c">simple
PoC</a>, whose output is shown below. We see padding bytes at offset 0
and 16 are leaked, and the <code>0xffff...</code> looks very much like
an address from the kernel address space.</p>
<pre>root@(none):/# /xxx/rustproofing-linux/poc/test.sh vuln_stack_leak
[   24.367962] vuln_stack_leak: loading out-of-tree module taints kernel.
value at offset 0 differs: 0xbe4b0a10dd2f9a01 vs 0x1
value at offset 16 differs: 0xffffffffb2fcd300 vs 0
</pre>
<p><span>PoC demonstrating data has been leaked</span></p><h2 id="porting-to-rust">Porting to Rust</h2>
<h3 id="accessing-userspace-memory">Accessing Userspace Memory</h3>
<p>The Linux kernel uses <code>copy_from_user</code> to copy data from
userspace, and <code>copy_to_user</code> to copy kernel buffers to
userspace. However, in Rust for Linux, these same copy operations can be
achieved with <code>UserSlicePtrReader</code> and
<code>UserSlicePtrWriter</code>. In this section, we will only describe
the “writer”, since both the reader and writer follow the same design
patterns, only the direction is reversed.</p>
<p><a href="https://github.com/Rust-for-Linux/linux/blob/bd123471269354fdd504b65b1f1fe5167cb555fc/rust/kernel/user_ptr.rs#L133"><code>UserSlicePtrWriter</code></a>
consists of a pointer and a length, and any write operation will
increment the pointer while decrementing the length until the whole
buffer is consumed. Note how this is a nice way of eliminating <a href="https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use">TOCTOU</a>
style bugs – that is, the writer only allows the data to be written
once. It has an <code>unsafe</code> <code>write_raw</code> operation
which is a <code>copy_to_user</code> wrapper with the mentioned pointer
and length change. Here, <code>write_raw</code> is <code>unsafe</code>
because the programmer needs to guarantee the destination kernel buffer
pointer is safe to be dereferenced and “length” number of bytes can be
read from it.</p>
<p>It also “inherits” the following convenient and safe <a href="https://github.com/Rust-for-Linux/linux/blob/bd123471269354fdd504b65b1f1fe5167cb555fc/rust/kernel/io_buffer.rs#L60"><code>IoBufferWriter</code></a>
methods:</p>
<ul>
<li><code>write_slice</code> – Write <code>slice</code> into a userspace
buffer.</li>
<li><code>write&lt;T: WritableFromBytes&gt;</code> – Write a
<code>WritableFromBytes</code> type into a userspace buffer. It’s worth
pointing out that <code>WritableFromBytes</code> is defined for the
integer types, but one could define it for any type, and then be able to
use <code>write</code> on that type, like we do below.</li>
</ul>
<p>The <a href="https://github.com/Rust-for-Linux/linux/blob/bd123471269354fdd504b65b1f1fe5167cb555fc/rust/kernel/user_ptr.rs#L98"><code>UserSlicePtrReader</code></a>
has all the above semantics (just reverse read and write) with the added
method:</p>
<ul>
<li><code>read_all</code> – read the whole userspace buffer into a newly
allocated <code>Vec&lt;u8&gt;</code></li>
</ul>
<p>Rust IOCTL handling uses an <code>UserSlicePtrReader</code> and/or
<code>UserSlicePtrWriter</code>, depending on IOCTL direction.</p>
<h3 id="initial-rust-version">Initial Rust Version</h3>
<p>The <a href="https://github.com/nccgroup/rustproofing-linux/blob/main/rust_vuln_stack_leak.rs">Rust
version</a> has a bit more involved IOCTL handling compared to the above
C version, but it should still be easy to follow. The relevant bits from
above translate to:</p>
<pre><span>#[repr(C)]</span> <span>// same struct layout as in C, since we are sending it to userspace</span>
<span>struct</span> VulnInfo <span>{</span>
    version<span>:</span> <span>u8</span><span>,</span>
    id<span>:</span> <span>u64</span><span>,</span>
    _reserved<span>:</span> <span>u8</span><span>,</span>
<span>}</span>

        <span>match</span> cmd <span>{</span>
            VULN_GET_INFO <span>=&gt; {</span>
                <span>let</span> info <span>=</span> VulnInfo <span>{</span>
                    version<span>:</span> <span>1</span><span>,</span>
                    id<span>:</span> <span>0x1122334455667788</span><span>,</span>
                    _reserved<span>:</span> <span>0</span><span>,</span> <span>// compiler requires an initialiser</span>
                <span>};</span>

                <span>// pointer weakening coercion + cast</span>
                <span>let</span> info_ptr <span>=  </span>info <span>as</span> <span>*</span><span>const</span> _ <span>as</span> <span>*</span><span>const</span> <span>u8</span><span>;</span>
                <span>// SAFETY: &#34;info&#34; is declared above and is local</span>
                <span>unsafe</span> <span>{</span> writer<span>.</span><span>write_raw</span><span>(</span>info_ptr<span>,</span> <span>size_of_val</span><span>( </span>info<span>))</span>? <span>};</span>
</pre>
<p><span>Rust implementation that leaks stack memory
contents</span></p><p>The main differences between C and Rust are:</p>
<ul>
<li><code>#[repr(C)]</code> is required, because the Rust compiler is
otherwise free to reorder struct members.</li>
<li>The <code>_reserved</code> member needs to be explicitly
initialised, whereas in C unspecified members are implicitly
initialised.</li>
<li>There’s an <code>unsafe</code> block required for
<code>write_raw</code>, which is just a fancy <code>copy_to_user</code>
wrapper.</li>
</ul>
<p>When we try the PoC, we observe that the kernel stack contents were
leaked once again:</p>
<pre>root@(none):/# /xxx/rustproofing-linux/poc/test.sh rust_vuln_stack_leak
value at offset 0 differs: 0xffffffffb2fcd501 vs 0x1
value at offset 16 differs: 0xffff888003d77f00 vs 0
</pre>
<p><span>PoC demonstrating data has been leaked</span></p><p>In a way, this is somewhat surprising, but maybe it shouldn’t be.
After all, the Rust version looks a lot like the C version, and there’s
even an <code>unsafe</code> block which should make the developer or
auditor think twice that there might be something unsafe about this
code.</p>
<h3 id="writabletobytes-variant"><code>WritableToBytes</code>
Variant</h3>
<p>The <code>unsafe</code> <code>write_raw</code> that was used above
takes a raw pointer, but there’s actually a nicer API we can leverage
here. A safe <code>write</code> could be used, if we implement the
<code>unsafe trait WritableToBytes</code>. The <a href="https://github.com/nccgroup/rustproofing-linux/blob/main/rust_vuln_stack_leak_v2.rs">new
Rust variant</a> then becomes:</p>
<pre><span>#[repr(C)]</span> <span>// same struct layout as in C, since we are sending it to userspace</span>
<span>struct</span> VulnInfo <span>{</span>
    version<span>:</span> <span>u8</span><span>,</span>
    id<span>:</span> <span>u64</span><span>,</span>
    _reserved<span>:</span> <span>u8</span><span>,</span>
<span>}</span>
<span><span>unsafe impl</span> WritableToBytes <span>for</span> VulnInfo <span>{ }</span></span>
<span>[...]</span>
                <span>let</span> info <span>=</span> VulnInfo <span>{</span>
                    version<span>:</span> <span>1</span><span>,</span>
                    id<span>:</span> <span>0x1122334455667788</span><span>,</span>
                    _reserved<span>:</span> <span>0</span><span>,</span> <span>// compiler requires an initialiser</span>
                <span>};</span>

                <span>writer<span>.</span><span>write</span><span>( </span>info<span>)</span>?<span>;</span></span>
</pre>
<p><span>Nicer Rust variant with
<code>WritableToBytes</code></span></p><p>There is the following informational <a href="https://github.com/Rust-for-Linux/linux/blob/bd123471269354fdd504b65b1f1fe5167cb555fc/rust/kernel/io_buffer.rs#L137-L140">comment</a>
above <code>WritableToBytes</code>, which explains exactly what is wrong
with our code. We feel somewhat uneasy about this comment. The correct
usage of this API requires that developers notice the comment:</p>
<pre><span>/// A type must not include padding bytes and must be fully initialised to safely implement</span>
<span>/// [`WritableToBytes`] (i.e., it doesn&#39;t contain [`MaybeUninit`] fields). A composition of</span>
<span>/// writable types in a structure is not necessarily writable because it may result in padding</span>
<span>/// bytes.</span>
</pre>
<p><span>Very relevant warning</span></p><h3 id="bonus-point-for-no-unsafe">Bonus Point for no
<code>unsafe</code></h3>
<p>While playing around with this we have discovered we can actually do
this without any <code>unsafe</code> in our <a href="https://github.com/nccgroup/rustproofing-linux/blob/main/rust_vuln_stack_leak_v3.rs">code</a>:</p>
<pre><span>// pr_info! can be used to hide unsafe</span>
pr_info<span>!(</span><span>&#34;writing data to userspace {:?}</span><span></span><span>n&#34;</span><span>,</span> writer<span>.</span><span>write_raw</span><span>(</span>info_ptr<span>,</span> <span>size_of_val</span><span>( </span>info<span>))</span>?<span>);</span>
</pre>
<p><span>Trick to hide <code>unsafe</code></span></p><p>And the PoC works:</p>
<pre>root@(none):/# /xxx/rustproofing-linux/poc/test.sh rust_vuln_stack_leak_v3
[  178.302849] vuln_stack_leak: writing data to userspace ()
value at offset 0 differs: 0xffff88800420ff01 vs 0x1
value at offset 16 differs: 0xffffff00 vs 0
</pre>
<p><span>PoC demonstrating data has been leaked</span></p><p>But what is happening here? <code>pr_info!</code> has an internal
<code>unsafe</code> in its implementation, so the arguments are
interpreted as <code>unsafe</code>. This was rather surprising to us, so
we reported it to the Rust for Linux maintainers. We have later
discovered they track this issue <a href="https://github.com/Rust-for-Linux/linux/issues/479">already</a>,
and our report served as a reminder. A <a href="https://lore.kernel.org/rust-for-linux/20230109204912.539790-1-ojeda@kernel.org/">fix</a>
is due to be merged with the next release.</p>
<h2 id="fixing-struct-padding-leaks">Fixing Struct Padding Leaks</h2>
<p>The idiomatic way in a C-based Linux kernel is to explicitly zero the
structure’s memory before initialising it:</p>
<pre><span>memset</span><span>( </span>info<span>,</span> <span>0</span><span>,</span> <span>sizeof</span><span>(</span>info<span>));</span> <span>// explicitly clear all &#34;info&#34; memory</span>
info <span>= (</span><span>struct</span> vuln_info<span>) {</span>
        <span>.</span>version <span>=</span> <span>1</span><span>,</span>
        <span>.</span>id <span>=</span> <span>0x1122334455667788</span><span>,</span>
<span>};</span>
</pre>
<p><span>Idiomatic fix is with a <code>memset</code></span></p><p>In Rust this can be accomplished with <code>MaybeUninit</code> <a href="https://github.com/nccgroup/rustproofing-linux/blob/main/rust_vuln_stack_leak_fixed_v2.rs">porting
variation</a>, as shown below:</p>
<pre><span>let mut</span> info <span>=</span> MaybeUninit<span>::&lt;</span>VulnInfo<span>&gt;::</span><span>zeroed</span><span>();</span>
<span>let</span> info <span>=</span> info<span>.</span><span>write</span><span>(</span>VulnInfo <span>{</span>
    version<span>:</span> <span>1</span><span>,</span>
    id<span>:</span> <span>0x1122334455667788</span><span>,</span>
    _reserved<span>:</span> <span>0</span><span>,</span> <span>// compiler requires an initialiser</span>
<span>});</span>
</pre>
<p><span>Fixing Rust version with <code>MaybeUninit</code></span></p><p>Note that while <code>MaybeUninit::&lt;T&gt;::zeroed()</code> will
fix the issue, there’s still that <code>unsafe</code> required for
<code>WritableToBytes</code>. To eliminate this undesirable
<code>unsafe</code> block, one can explicitly write all individual
struct members as shown in this <a href="https://github.com/nccgroup/rustproofing-linux/blob/main/rust_vuln_stack_leak_fixed.rs">example</a>.</p>
<h2 id="mitigation">Mitigation</h2>
<p>This is a common enough problem that automatic stack initialisation
feature was merged recently. When compiling the driver, if the
<code>CONFIG_INIT_STACK_ALL_ZERO</code> config option is enabled, the
issue can no longer be reproduced in the C-based driver:</p>
<pre>root@(none):/# /xxx/rustproofing-linux/poc/test.sh vuln_stack_leak
[   36.900538] vuln_stack_leak: loading out-of-tree module taints kernel.
root@(none):/#
</pre>
<p><span>PoC shows no data leaked when mitigation applied</span></p><p>Oddly, the problem can still be reproduced in the Rust port of the
vulnerable code:</p>
<pre>root@(none):/# /xxx/rustproofing-linux/poc/test.sh rust_vuln_stack_leak
value at offset 0 differs: 0xffffffffaa7d8b01 vs 0x1
value at offset 16 differs: 0xffff8880047d7f00 vs 0
root@(none):/#
</pre>
<p><span>PoC shows data leaked in Rust port even with
mitigation</span></p><p>In other words, the <code>CONFIG_INIT_STACK_ALL_ZERO</code> build
option does nothing for Rust code! Developers must be cautious to avoid
shooting themselves in the foot when porting a driver from C to Rust,
especially if they previously relied on this config option to mitigate
this class of vulnerability. It seems that kernel info leaks and KASLR
bypasses might be here to stay, at least, for a little while longer.</p>
<p>This surprising behaviour has been reported to the maintainers of
the Rust for Linux project.</p>

<h2 id="nextpart">There’s More…</h2>
<p><a href="https://research.nccgroup.com/2023/02/08/rustproofing-linux-part-2-4-race-conditions/">Part 2</a> of this blog series talks about race conditions and the caveats one needs to pay attention to.</p>
        </div>
            </section>
    
    <section>
        <!-- <pre>  </pre> -->
    
    
    
</section>    <!--  -->
    
<section>
    <div>
        <h3>Here are some related articles you may find interesting</h3>
        <div>
                            <!-- <pre>  </pre> -->
            
            <div>
                <a href="https://research.nccgroup.com/2024/08/13/new-website-address-and-rss-feed/" title="New website address and RSS Feed">
                    <h4>New website address and RSS Feed</h4>
                </a>
                <p>We’re excited to announce that all of NCC Group’s latest research findings and articles are now hosted on our website at the following link: NCC Group Research Blog. (https://www.nccgroup.com/us/research-blog/) To stay up-to-date with our latest research, you can also subscribe to our RSS feed here: NCC Group Research Blog RSS…</p>
                
                
            </div>
            
            <div>
                <a href="https://research.nccgroup.com/2024/06/12/stepping-stones-a-red-team-activity-hub/" title="Stepping Stones – A Red Team Activity Hub">
                    <h4>Stepping Stones – A Red Team Activity Hub</h4>
                </a>
                <p>Executive Summary NCC Group is pleased to open source a new tool built to help Red Teams log their activity for later correlation with the Blue Team’s own logging. What started as a simple internal web based data-collection tool has grown to integrate with Cobalt Strike and BloodHound to improve…</p>
                
                
            </div>
            
            <div>
                <a href="https://research.nccgroup.com/2024/06/11/pumping-iron-on-the-musl-heap-real-world-cve-2022-24834-exploitation-on-an-alpine-mallocng-heap/" title="Pumping Iron on the Musl Heap – Real World CVE-2022-24834 Exploitation on an Alpine mallocng Heap">
                    <h4>Pumping Iron on the Musl Heap – Real World CVE-2022-24834 Exploitation on an Alpine mallocng Heap</h4>
                </a>
                <p>Pumping Iron on the Musl Heap – Real World CVE-2022-24834 Exploitation on an Alpine mallocng Heap Lua 5.1 Musl’s Next Generation Allocator – aka mallocng mallocng Cycling Offset Exploiting CVE-2022-24834 on the mallocng heap mallocng Heap Shaping Ensuring Correct Target Table-&gt;Array Distance Lua Table Confusion redis-server/libc ASLR Bypass and Code…</p>
                
                
            </div>
                                </div>
    </div>

    
</section>
    <section>
    <div>
      <div>
        <h3>View articles by category</h3>
                  <ul>
                          <li>
                <i></i>
                
            </li>
                          <li>
                <i></i>
                
            </li>
                          <li>
                <i></i>
                
            </li>
                          <li>
                <i></i>
                
            </li>
                          <li>
                <i></i>
                
            </li>
                          <li>
                <i></i>
                
            </li>
                          <li>
                <i></i>
                
            </li>
                          <li>
                <i></i>
                
            </li>
                          <li>
                <i></i>
                
            </li>
                          <li>
                <i></i>
                
            </li>
                          <li>
                <i></i>
                
            </li>
                          <li>
                <i></i>
                
            </li>
                          <li>
                <i></i>
                
            </li>
                          <li>
                <i></i>
                
            </li>
                          <li>
                <i></i>
                
            </li>
                          <li>
                <i></i>
                
            </li>
                          <li>
                <i></i>
                
            </li>
                          <li>
                <i></i>
                
            </li>
                          <li>
                <i></i>
                
            </li>
                          <li>
                <i></i>
                
            </li>
                          <li>
                <i></i>
                
            </li>
                          <li>
                <i></i>
                
            </li>
                          <li>
                <i></i>
                
            </li>
                          <li>
                <i></i>
                
            </li>
                          <li>
                <i></i>
                
            </li>
                          <li>
                <i></i>
                
            </li>
                          <li>
                <i></i>
                
            </li>
                          <li>
                <i></i>
                
            </li>
                          <li>
                <i></i>
                
            </li>
                          <li>
                <i></i>
                
            </li>
                          <li>
                <i></i>
                
            </li>
                          <li>
                <i></i>
                
            </li>
                          <li>
                <i></i>
                
            </li>
                          <li>
                <i></i>
                
            </li>
                          <li>
                <i></i>
                
            </li>
                          <li>
                <i></i>
                
            </li>
                          <li>
                <i></i>
                
            </li>
                          <li>
                <i></i>
                
            </li>
                          <li>
                <i></i>
                
            </li>
                          <li>
                <i></i>
                
            </li>
                          <li>
                <i></i>
                
            </li>
                          <li>
                <i></i>
                
            </li>
                          <li>
                <i></i>
                
            </li>
                          <li>
                <i></i>
                
            </li>
                          <li>
                <i></i>
                
            </li>
                          <li>
                <i></i>
                
            </li>
                          <li>
                <i></i>
                
            </li>
                          <li>
                <i></i>
                
            </li>
                          <li>
                <i></i>
                
            </li>
                          <li>
                <i></i>
                
            </li>
                          <li>
                <i></i>
                
            </li>
                          <li>
                <i></i>
                
            </li>
                          <li>
                <i></i>
                
            </li>
                          <li>
                <i></i>
                
            </li>
                          <li>
                <i></i>
                
            </li>
                          <li>
                <i></i>
                
            </li>
                          <li>
                <i></i>
                
            </li>
                          <li>
                <i></i>
                
            </li>
                          <li>
                <i></i>
                
            </li>
                          <li>
                <i></i>
                
            </li>
                          <li>
                <i></i>
                
            </li>
                          <li>
                <i></i>
                
            </li>
                      </ul>
      </div>

      

      
    </div>
  </section>    <section>
    <div>
      <h2>Call us before you need us.</h2>
      <p>Our experts will help you.</p>
      <p><a href="https://www.nccgroup.com/uk/contact-us/" target="_blank" title="Get in touch">Get in touch</a>
    </p></div>
</section>
            </div></div>
  </body>
</html>
