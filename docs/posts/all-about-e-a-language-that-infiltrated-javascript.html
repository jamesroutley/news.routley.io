<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://thenewstack.io/all-about-e-the-language-that-infiltrated-javascript/">Original</a>
    <h1>All About E: A Language That Infiltrated JavaScript</h1>
    
    <div id="readability-page-1" class="page"><div>
<div id="tns-post-body-content">


<p>Doug Crockford is best known for his long-time work in JavaScript and for creating the JSON Data Interchange Format. His opinion tends to carry weight — and Crockford said it’s time to retire JavaScript.</p>
<p>“JavaScript, like the other dinosaur languages, has become a barrier to progress,” Crockford told IT outsourcing firm <a href="https://evrone.com/douglas-crockford-interview" target="_blank" rel="noopener external " onclick="this.target=&#39;_blank&#39;;">Evrone in an interview</a>. “We should be focused on the next language, which should look more like E than like JavaScript.”</p>
<p>What is E? Wikipedia calls E “an <a href="https://thenewstack.io/why-are-so-many-developers-hating-on-object-oriented-programming/" target="_blank">object-oriented language</a> for securing distributed computing,” and by design, E emphasizes security. But to learn more about E’s impact on JavaScript, The New Stack spoke with <a href="https://www.crunchbase.com/person/mark-s-miller" target="_blank" rel="noopener external " onclick="this.target=&#39;_blank&#39;;">Mark Miller</a>, the <a href="http://www.erights.org/talks/thesis/markm-thesis.pdf" target="_blank" rel="noopener external " onclick="this.target=&#39;_blank&#39;;">main designer of E</a>, which he co-created with <a href="https://www.linkedin.com/in/deantribble/" target="_blank" rel="noopener external " onclick="this.target=&#39;_blank&#39;;">Dean Tribble</a> as well as several Electric Communications colleagues, including <a href="https://www.crockford.com/about.html" target="_blank" rel="noopener external " onclick="this.target=&#39;_blank&#39;;">Crockford</a>, Doug Barnes, <a href="https://www.linkedin.com/in/danfuzz/" target="_blank" rel="noopener external " onclick="this.target=&#39;_blank&#39;;">Dan Bornstein</a>, and <a href="https://www.linkedin.com/in/chip-morningstar-57923/" target="_blank" rel="noopener external " onclick="this.target=&#39;_blank&#39;;">Chip Morningstar</a> during the mid-1990s.</p>
<p>“Both Doug and I had a lot to do with the birth of the language,” Miller told us. “We were quite in love with the language that we had created.”</p>
<p>Miller considers the language itself dead — an open source language, E never attracted more than 100 users to the community, he said.</p>
<p>But E didn’t go softly into that good night — its influence is still seen in JavaScript today, thanks to the efforts of Miller, Crockford, and other members of the ECMAScript standards committee. Miller explained to The New Stack how E influenced JavaScript, how his company <a href="https://agoric.com/" target="_blank" rel="noopener external " onclick="this.target=&#39;_blank&#39;;">Agoric</a> still puts the E ideas to use in DeFi with <a href="https://thenewstack.io/open-source-blockchain-development-strong-despite-funding-cuts/" target="_blank">blockchain</a>, and the additional aspects of E he’d like to see upcycled into JavaScript.</p>
<h2>12 Angry Men and ECMAScript</h2>
<p>“Have you seen the movie <a href="https://www.imdb.com/title/tt0050083/" target="_blank" rel="noopener external " onclick="this.target=&#39;_blank&#39;;"><em>12 Angry Men</em></a>?” Miller asked me. I have, I replied. “I think that movie is the best way to explain what the ECMAScript committee was like at the time that I joined Google.”</p>
<p>Crockford convinced Miller to join the committee in 2007 as an additional Google representative. The committee was focused on upgrading ECMAScript 3 to ECMAScript 4 but it wasn’t going well.</p>
<p>“The committee had been meeting continuously from 1999 to 2007 at this point, and they still did not have a successor standard. Most of the committee was focused on ECMAScript 4, which in my opinion was a horrible language,” Miller said. “Doug started off as the one holdout — the Henry Fonda character saying, ‘No, we will not agree on this.’”</p>
<p>JavaScript was messy, complicated and weird, but Crockford convinced Miller that ECMAScript 3 had the seeds for an E-like experience and that it had the core enabling elements that would allow it to become an E-like secure distributed programming language.</p>
<p>“I joined his revolt against ECMAScript 4, and that revolt had several other members by that time — just like in <em>12 Angry Men</em> — he incrementally convinced the jurors to come over to his camp,” Miller said. Eventually, the revolt won. The successor to ECMAScript 3 became ECMAScript 5, the version designed by the revolters while the rest of the committee focused on ECMAScript 4.</p>
<p>“The ECMAScript 5 standard did have the enablers for using JavaScript as a straightforward, simple, secure programming language. We were both very proud of what we did for ECMAScript 5,” he said.</p>
<p>One fundamental aspect of E they brought over in ECMAScript 5 was support for the object-capability security model, he said.</p>
<p>“JavaScript’s functions together with JavaScript’s objects, used as records, can be combined to create a pattern that Doug named the objects-as-closures pattern, and if you use JavaScript as objects-as-closures, the expressiveness feels much like E. But as of ECMAScript 3, it doesn’t have the security yet.”</p>
<p>The enablers they got into ECMAScript 5 enabled them to write the SES-shim, a library that brings about a secure language state, which is now called Hardened JavaScript, Miller said.</p>
<h2>Freeze</h2>
<p>In ECMAScript 5, they introduced several enablers, the primary being Object.freeze(). Despite its name, it has nothing to do with immutability, Miller said. Instead, it tamper-proofs the surface of an object so that the clients of the object can now only interact with the object — according to the object’s explicit behavior, Miller explained. The provider of the object can populate it with methods that capture internal state variables and can encapsulate that state, so the clients of the object cannot tamper with it. By “freezing,” what’s meant is that the properties of the object can no longer be changed, he added.</p>
<p>“The client can no longer change the shape of the object. So the shape of the object is fixed. The internal state is now hidden from the clients,” he said. “Now the object becomes something that can only be interacted with according to the object’s design.”</p>
<p>That step addressed a security problem: prototype poisoning, in which objects created in traditional JavaScript were all mutable and can be subverted to confuse or surveil other parts of a program by anyone who had access to them.</p>
<p>“One of the things that we do with freeze and with the other enablers that we got into ECMAScript 5 (Object.getOwnPropertyNames() and Object.getPrototypeOf() ) is we were able to write something we call ‘harden(),’ which is a transitive freeze that walks an object graph, freezing all of the objects that it finds by doing property traversal. We were able to enumerate all of the primordial objects, all of the objects that JavaScript programs within the same environment implicitly share, like Array and Array.prototype, etc.,” Miller said.</p>
<h2>I/O Expression</h2>
<p>The SES-shim library, at the beginning, when it initializes, does some repairs on the primordials, then hardens all of the primordials, he said. That ensures all of the implicitly shared objects are now genuinely immutable.</p>
<p>“We did some repair on the committee so that the primordials didn’t have any hidden mutable state or hidden I/O abilities,” he said.</p>
<p>Everything that was implicitly shared is completely powerless and immutable, he added, so that sharing does not violate isolation.</p>
<p>Another crucial enabler was the ability to virtualize all <a href="https://thenewstack.io/language-i-o-runs-react-based-javascript-with-java-backend/" target="_blank">I/O</a>. One of the beautiful and under-appreciated aspects of JavaScript, Miller said, is that the language is about computation — not about I/O. JavaScript programs express I/O by performing a global variable lookup of a host-provided object, like “document” in the browser or “process” in Node.</p>
<p>Those host-provided global variables are not standardized as part of the language standard, but are brought in by the host that provides all of the I/O abilities for affecting the outside world or for sensing the outside world.</p>
<p>“What that means is that if you can intervene in the global scope lookup, you can completely virtualize all of the I/O and that’s what we made possible with our enablers in ECMAScript 5. Hardened JavaScript continues to use the enablers to intercept the global scope lookup,” he said.</p>
<p>Hardened JavaScript is what Agoric still uses today. Agoric writes most of their code within a disciplined subset of Hardened JavaScript called Jessie (a name intended to evoke a combination of JS and E). Jessie emphasizes Crockford’s objects-as-closures pattern as an alternative to JavaScript’s inheritance mechanisms.</p>
<h2>Promises</h2>
<p>Another important aspect of E ported to JavaScript is non-blocking promises, which E was the first language to have, Miller said. Promises happened in ECMAScript 6 and those promises are directly based on E promises.</p>
<p>“A promise is an object returned by an asynchronous function. … the promise object provides methods to handle the eventual success or failure of the operation,” <a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Promises" target="_blank" rel="noopener external " onclick="this.target=&#39;_blank&#39;;">explains MDN web docs</a>. <a href="http://www.skyhunter.com/marcs/ewalnut.html#SEC20" target="_blank" rel="noopener external " onclick="this.target=&#39;_blank&#39;;">E in a Walnut explains promises</a> in more detail. Essentially, in promise systems before E, the calling thread would at some point block, waiting for the operation to complete. In much the way one wouldn’t wait for someone to finish a task on a project before beginning to work on one’s own tasks, E’s non-blocking promises made it possible to handle the eventual success or failure of the operation without blocking to wait for the resolution.</p>
<p>JavaScript’s promises only provide for local asynchrony out of the box, but Agoric’s Endo libraries extend them to also provide E-like distributed object-capability security over cryptographic protocols, making JavaScript into an E-like distributed secure language.</p>
<p>ECMAScript 6 introduced E’s non-blocking promises. But ECMAScript 6 also introduced classes and became at least twice as big … and kept growing, Miller said. It became more complex, an anathema to both Miller and Crockford. While Miller stayed, Crockford left the committee, essentially seeing JavaScript as a lost cause, according to Miller.</p>
<p>Miller still sees potential in JavaScript.</p>
<p>”I do not see it as a lost cause,” he told The New Stack. “I’m very proud of what we’ve continued to accomplish in the efforts of the committee, enabling us to use it as an E-like distributed secure language.”</p>

<p>
<svg width="68px" height="31px" viewBox="0 0 68 31" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<title>Group</title>
<desc>Created with Sketch.</desc>
<g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
<g id="Group">
<path d="M24.002,29.619 L29.77,29.619 L29.77,15.808 C29.77,15.038 29.622,11.265 29.59,10.414 L29.77,10.414 C31.424,14.019 31.473,14.147 32.168,15.322 L39.65,29.618 L44.845,29.618 L44.845,0 L39.075,0 L39.075,11.064 C39.075,12.197 39.075,12.44 39.182,14.472 L39.325,17.468 L39.151,17.468 C39.034,17.267 38.596,16.173 38.467,15.929 C38.164,15.323 37.725,14.512 37.373,13.905 L30.031,0 L24,0 L24,29.619 L24.002,29.619 Z" id="Path-Copy" fill="#FF3287"></path>
<path d="M56.948,0 C50.745,0 47.606,3.43 47.606,8.296 C47.606,14.114 51.036,15.404 55.518,17.132 C60.438,18.853 61.782,19.332 61.782,21.539 C61.782,24.225 58.969,24.867 57.401,24.867 C54.579,24.867 52.493,23.342 51.536,20.858 L47,24.185 C49.43,28.937 52.145,30.185 57.713,30.185 C59.364,30.185 62.059,29.74 63.727,28.694 C67.779,26.156 67.779,22.22 67.779,20.898 C67.779,18.129 66.531,16.207 66.178,15.726 C65.049,14.121 63.032,12.918 61.25,12.278 L57.084,10.914 C55.073,10.267 52.928,10.105 52.928,8.019 C52.928,7.707 53.008,5.528 56.288,5.319 L61.465,5.319 L61.465,0 C61.465,0 57.342,0 56.948,0 Z" id="Path-Copy-2" fill="#00AFF4"></path>
<polygon id="Path" fill="#00AFF4" points="5.32907052e-15 1.77635684e-15 5.32907052e-15 5.319 7.572 5.319 7.572 29.564 14.132 29.564 14.132 5.319 21.544 5.319 21.544 1.77635684e-15"></polygon>
</g>
</g>
</svg> </p>
</div>
</div></div>
  </body>
</html>
