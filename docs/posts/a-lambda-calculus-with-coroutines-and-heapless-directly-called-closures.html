<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ayazhafiz.com/articles/23/a-lambda-calculus-with-coroutines-and-heapless-closures#source-language">Original</a>
    <h1>A Lambda Calculus with Coroutines and Heapless, Directly-Called Closures</h1>
    
    <div id="readability-page-1" class="page"><article>
<ul id="toc">
<li><a href="#introduction">Introduction</a></li>
<li><a href="#source-language">Source language</a></li>
<li><a href="#virtual-machine-strategy">Virtual machine strategy</a>
<ul>
<li><a href="#representing-function-frames">Representing function frames</a></li>
<li><a href="#representing-function-calls">Representing function calls</a></li>
<li><a href="#representing-fibers">Representing fibers</a></li>
<li><a href="#representing-tuples">Representing tuples</a></li>
<li><a href="#instruction-set">Instruction set</a></li>
</ul>
</li>
<li><a href="#compilation-strategy">Compilation strategy</a>
<ul>
<li><a href="#type-inference">Type inference</a>
<ul>
<li><a href="#a-tip-for-inference-of-tuples">A tip for inference of tuples</a></li>
</ul>
</li>
<li><a href="#eliminating-indirect-calls-and-heap-allocated-closures-via-defunctionalization">Eliminating indirect calls and heap-allocated closures via defunctionalization</a>
<ul>
<li><a href="#why-does-eliminating-indirect-calls-matter%3F">Why does eliminating indirect calls matter?</a>
<ul>
<li><a href="#function-pointers">Function pointers</a></li>
<li><a href="#conditionally-determined-functions">Conditionally-determined functions</a></li>
</ul>
</li>
<li><a href="#eliminating-heap-allocated-captures">Eliminating heap-allocated captures</a></li>
<li><a href="#inference-and-compilation-semantics-of-lambda-sets">Inference and compilation semantics of lambda sets</a></li>
</ul>
</li>
<li><a href="#compiling-functions%2C-including-lambda-sets">Compiling functions, including lambda sets</a></li>
<li><a href="#tip%3A-deciding-where-to-store-values">Tip: deciding where to store values</a>
<ul>
<li><a href="#tail-call-optimization">Tail-call optimization</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#unexplored-extensions">Unexplored extensions</a></li>
<li><a href="#playground-%26-implementation">Playground &amp; Implementation</a></li>
<li><a href="#ad%3A-are-you-interested-in-compiling-structural-subtypes%3F">Ad: Are you interested in compiling structural subtypes?</a></li>
</ul>
<p>In this cc, I&#39;d like to present a small language based on the lambda calculus
extended with stackful coroutines. I&#39;ll discuss a virtual machine designed for
the language&#39;s execution, and an efficient compilation scheme.</p>
<p>We&#39;ll see that the compilation scheme</p>
<ul>
<li>naturally supports tail-call optimization</li>
<li>eliminates all heap allocation of closures</li>
<li>eliminates the need for indirect calls</li>
</ul>
<p>without restriction of the language&#39;s expressiveness - which may be interesting in its own right.</p>
<p>This post is intended for anyone broadly interested in implementing coroutines,
compilers, or virtual machines. I am not an expert in any of those, but I hope
that something in this post may be useful to you. The post will assume basic
familiarity with unification-based type inference and code generation schemes.</p>
<p>First, let you let me show you a <a href="https://ayazhafiz.com/plts/playground/co_lc/?input=DYUwLgBATiDGEDMCWAjCBeCAdAdhAtAHwBQEEAnkiMACYDcpESCEeAPBAEyNgAWIeHI2oBnEBAAUyNBLz4IARgCUSiAGpJ0yXK4riSIcVCQY8EAA84GbCLABDMOKKNbDiK8cA6AAyMAPhAABgAKAjQGAOYEJGRkxoioCtYwIgCuALbiHiA%2BTEKxEBZWAN7SCgA0EN6V2Z6c6ooAvv5BACIA9jjicoQQxbXVrDX2XpzNBkbg0Kk4AGKo1iIADnYA7nhSC5zeqhPxKanAkJhF8MVQM-MolYPejXnExADEXN44fAkonXawsEisGRQICglRwgOBEHaLAO6SWYCQnRExHOIDSR08FWgqMOYDqjSAA&amp;backend=ir&amp;options=NohEFMFsEsBdQDQG9QDcCGAbAruUAuUABwCdoA7eBUAeyNmhvIGcDhizLEJN0AjUAF0AvoMEIwUOIhQYceQqQpVa9RizYdl3cLwEixgoA">playground</a> exemplifying the language and its
compiler/VM. You can hover over values in the input buffer of the playground to
see inferred types. The default program comes from <a href="https://cyberscript.dev/play.html#">Cyber&#39;s playground</a>,
computing the 20th fibonacci number, and how many times <code>fib</code> was called.</p>
<figure>

</figure>
<h2 id="introduction" tabindex="-1"><a href="#introduction" aria-hidden="true"></a>Introduction</h2>
<p>Recently, I&#39;ve been studying the efficient implementation of <a href="https://effekt-lang.org/docs/concepts/effect-handlers">effect
handlers</a>, which I
currently believe are the most promising avenue for the future of managed
effects in programming languages.</p>
<p>Effect handlers have a lot to do with coroutines - in fact, one way to implement
effect handlers is as stackful coroutines, <a href="https://v2.ocaml.org/manual/effects.html#s:effects-fibers">like OCaml does</a>.</p>
<details>
<summary>
In this cc, I&#39;ll use the terms &#34;coroutine&#34;, &#34;green thread&#34;, and &#34;fiber&#34; all to
refer to the specific idea of first-class, stackful, non-presumptive coroutines.
</summary>
<p>Specifically,</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Coroutine">Coroutines</a> are segments of a
program whose execution can be paused and resumed at-will. They can be thought
of threads of execution controlled in userspace, rather than in the kernel.
<ul>
<li>If you are familiar with goroutines, coroutines are like goroutines, except
that
<ul>
<li>The point at which coroutines are preempted must be explicitly defined by
the programmer; in the language we&#39;ll look at below, via the <code>yield</code>
keyword.</li>
<li>Dually, coroutines do not imply a concurrent runtime; it is up the
programmer whether to, and how to, execute coroutines in a concurrent
fashion. In the language we&#39;ll look at below, this is done the <code>spawn</code> and
<code>resume</code> keywords.</li>
</ul>
</li>
</ul>
</li>
<li>A <strong>first-class</strong> coroutine can be used like any other value in a language,
unrestricted in its behavior; think of first-class functions.</li>
<li><strong>Stackful</strong> coroutines can arbitrarily pause their execution, including
within nested function calls. Stackful coroutines require a preserved call
stack while they are preserved, <a href="https://blog.varunramesh.net/posts/stackless-vs-stackful-coroutines/">in contrast to stackless
coroutines</a>.
C++ (via <code>co_await</code>/<code>co_yield</code>), Rust (via <code>async</code>/<code>await</code>), and JavaScript
(via <code>async</code>/<code>await</code>) all implement stackless coroutines - with the
restriction that you cannot suspend in nested, non-co-routine call in those
languages. The latter behavior induces the often-named <a href="https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/">function color
problem</a>
for async/await.</li>
<li><strong>Non-presumptive</strong> coroutines are those that cannot be resumed more than
once. In the language we&#39;ll discuss below, the <code>resume</code> keyword resumes
execution of a coroutines, and returns a new handle to the coroutine. It is a
runtime error to call <code>resume</code> on the same handle to a coroutine more than
once.</li>
<li>Coroutines are cooperative - unlike threads, which may be preempted
arbitrarily by an operating systems, coroutines require programmer intervention
to specify where execution should be paused and resumed (think <code>async</code>/<code>await</code>
in JavaScript/Python/Rust). Moreoever, coroutines do not imply a concurrent
runtime, and it is up the programmer to define how to execute coroutines.
<ul>
<li>Again, contrast this to goroutines, where the runtime of goroutines is
well-defined and suspension points are largely implicit.</li>
</ul>
</li>
</ul>
</details>
<p>Why am I talking about coroutines here?
I&#39;ve seen a few good articles discussing implementing coroutines against a
machine-language target
(<a href="https://graphitemaster.github.io/fibers/">1</a>,
<a href="https://cfsamson.gitbook.io/green-threads-explained-in-200-lines-of-rust/">2</a>),
and recent projects like <a href="https://cyberscript.dev">Cyber</a> and
<a href="https://abhinavsarkar.net/posts/implementing-co-1/">Co</a>.
I&#39;d like to present a small model and implementation of coroutines
against a virtual machine target, which may be a nice base for launching more
experiments without designing a programming language intended for general use.</p>
<p><a href="https://abhinavsarkar.net/posts/implementing-co-1/">Co</a> implements coroutines as continuations - which I believe
is also the most promising technique for an efficient implementation of
effect handlers, but I won&#39;t expand on that here. Continuations often go hand-in-hand
with closures, which are typically heap-allocated and called
indirectly. To show off something interesting, we&#39;ll also have our implementation
compile closures unboxed, and eliminate all indirect calls via
defunctionalization.</p>
<p>Finally, we&#39;ll see that tail-call optimization falls out naturally with other
aspects of the implementation.</p>
<p>Okay, let&#39;s get started!</p>
<h2 id="source-language" tabindex="-1"><a href="#source-language" aria-hidden="true"></a>Source language</h2>
<p>Our source language will be the simply-typed lambda calculus extended with
tuples and fibers. Fibers will be our source-language-level representation of
coroutines, and can be used like any other value. Fibers can be <code>spawn</code>ed,
<code>yield</code>ed, and <code>resume</code>d by the author to enable cooperative multitasking.</p>
<p>As an example, let&#39;s consider a program (<a href="https://cyberscript.dev/play.html#">taken from Cyber&#39;s
examples</a>) that calculates the 20th
fibonacci number in a fiber that yields to its parent fiber on every iteration.
This usage of <code>yield</code> and <code>resume</code> lets us compute how many times <code>fib</code>
recursively calls itself. I hope you can see how you could run more complicated
tasks concurrently in this style.</p>
<pre><p>ocaml</p><p><code><p><span>let</span><span> </span><span>rec</span><span> </span><span>fib</span><span> </span><span>=</span><span> \n </span><span>-&gt;</span></p><p><span>  yield</span><span>;</span></p><p><span>  </span><span>if</span><span> n </span><span>&lt;</span><span> </span><span>2</span></p><p><span>  </span><span>then</span><span> n</span></p><p><span>  </span><span>else</span><span> </span><span>(</span><span>fib </span><span>(</span><span>n </span><span>-</span><span> </span><span>1</span><span>))</span><span> </span><span>+</span><span> </span><span>(</span><span>fib </span><span>(</span><span>n </span><span>-</span><span> </span><span>2</span><span>))</span></p><p><span>in</span></p><p><span>let</span><span> </span><span>rec</span><span> </span><span>exec</span><span> </span><span>=</span><span> \state </span><span>-&gt;</span></p><p><span>  stat state</span><span>.</span><span>0</span></p><p><span>  | `Pending -&gt;</span></p><p><span>    let </span><span>fib1</span><span> </span><span>=</span><span> resume state</span><span>.</span><span>0 in</span></p><p><span>    </span><span>exec</span><span> </span><span>{</span><span>fib1</span><span>, 0, </span><span>state</span><span>.2 + 1</span><span>}</span></p><p><span>  </span><span>|</span><span> `</span><span>Done</span><span> </span><span>n</span><span> </span><span>-&gt;</span><span> </span><span>{</span><span>state</span><span>.0, </span><span>n</span><span>, </span><span>state</span><span>.2</span><span>}</span></p><p><span>in</span></p><p><span>let</span><span> </span><span>runFib</span><span> </span><span>=</span><span> spawn </span><span>(</span><span>fib </span><span>20</span><span>)</span><span> in</span></p><p><span>let</span><span> </span><span>result</span><span> </span><span>=</span><span> exec </span><span>{</span><span>runFib</span><span>, 0, 0</span><span>}</span><span> in</span></p><p><span>{result.1, result.2}</span></p></code></p></pre>
<p>This language&#39;s syntax is very similar to OCaml&#39;s. I&#39;ll point out a few key
features of its semantics:</p>
<ul>
<li>
<p><code>let rec</code> defines a recursive binding; by default, <code>let</code> bindings are
non-recursive.</p>
</li>
<li>
<p><code>{e1, e2, ..., en}</code> defines a n-ary tuple. Tuple elements are accessed by
0-based indices; for example, <code>t.0</code>.</p>
</li>
<li>
<p>Every program starts on a unique <code>main</code> fiber. A program terminates when the
<code>main</code> fiber terminates, even if other fibers have not terminated<span><label for="contrast-threads"></label></span><span>contrast
this to non-joined kernel threads in e.g. C</span>. It&#39;s up to the programmer to
decide whether or not all child fibers should terminate<span><label for="whether-terminate"></label></span><span>whether this is
a good design design is a different question</span>.</p>
</li>
<li>
<p><code>spawn (fib 20)</code> executes the call <code>fib 20</code> on a new fiber, which can yield to
the parent fiber (in this case the <code>main</code> fiber) arbitrarily. <code>spawn</code> returns
to the calling fiber a handle to the child fiber. These handles have type <code>Fiber</code>.
Fibers have two states - they are either in the pending state, or have
terminated with a value.</p>
</li>
<li>
<p>Fibers can be passed around arbitrarily, including to other fibers. Fibers are
first-class values.</p>
</li>
<li>
<p><code>yield</code> suspends a fiber&#39;s execution and returns execution to the current
parent fiber. Note that since fibers can be passed around arbitrarily, the
parent of a fiber may change during a program&#39;s execution. <code>yield</code> is a
no-op on the main fiber<span><label for="yield-noop-warn"></label></span><span>I believe you could
detect <code>yield</code>s that are only reached by the main fiber with a full-program
static analysis, but it&#39;s not clear to me whether a more localized analysis
would be suitable.</span>.</p>
</li>
<li>
<p><code>resume</code> returns execution to a child fiber, which executes until its next
<code>yield</code> point or completion. Like <code>spawn</code>, <code>resume</code> returns a <code>Fiber</code>.
It is a runtime to resume the same <code>Fiber</code> twice - in our example above, for
example, it would not be legal to define</p>
<pre><p>diff</p><p><code><p><span>- let fib1 = resume state.0 in</span></p><p><span>- exec {fib1, 0, state.2 + 1}</span></p><p><span>+ let _ = resume state.0 in</span></p><p><span>+ exec {state.0, 0, state.2 + 1}</span></p></code></p></pre>
<p>A affine type system could enforce this requirement at compile-time, but we
won&#39;t discuss that here.</p>
<p>Resuming a completed <code>Fiber</code> is effectively a no-op; the <code>Fiber</code> is
immediately returned as-is.</p>
</li>
<li>
<p>A <code>stat</code> expression queries the state of a <code>Fiber</code>, and matches on a
<code>`Pending</code> branch if the fiber has not yet terminated, or a
<code>`Done</code> branch if it has. The <code>`Done</code> binds the
return value of the fiber to a variable name.</p>
</li>
</ul>
<p>The source language has four types:</p>
<ul>
<li>Integers</li>
<li>Booleans</li>
<li>Tuples composed of the language types, inductively</li>
<li>Fibers composed of the language types, inductively</li>
</ul>
<h2 id="virtual-machine-strategy" tabindex="-1"><a href="#virtual-machine-strategy" aria-hidden="true"></a>Virtual machine strategy</h2>
<p>There are a lot of ways you could design a virtual machine for the language
described above. Here, I&#39;ll show one design for a <a href="https://en.wikipedia.org/wiki/Stack_machine">stack-based
machine</a>.</p>
<p>First off, let&#39;s define the stack part of the stack machine. Suppose that we can
represent all our types as integers<span><label for="stack-cell-repr"></label></span><span>tuples are just blocks of integers next to
each other, and I&#39;ll explain the representation of fibers in a bit</span>; then our
stack is just a dynamically-growing array of integers. For the sake of
simplicity we&#39;ll have the stack deal with 64-bit integers, rather than bytes.
This is wasteful, but that&#39;s okay for this discussion.</p>
<p>We&#39;ll allow a program to arbitrarily push integers onto the stack, pop integers
off the stack, and store integers into arbitrary indices in the stack.</p>
<h3 id="representing-function-frames" tabindex="-1"><a href="#representing-function-frames" aria-hidden="true"></a>Representing function frames</h3>
<p>Since a function in our source language might have local variables referenced
multiple times, it&#39;d be nice to support some idea of local variables in the
runtime representation of a function call frame.</p>
<p>The standard approach here is to keep track of a frame pointer in the
runtime, which points to the place that was the top of the stack when a function
call was entered<span><label for="fp-repr-machine"></label></span><span>Typically, when targeting machine code, frame pointers are
stored in CPU registers.</span>.
When a function is entered, it can ask the runtime to reserve some space on the
stack that it will use for storing local variables. Then, those local values
can be accessed relative to an offset from the frame pointer.</p>
<details>
<summary>Example of compiling a function</summary>
<pre><p>ocaml</p><p><code><p><span>let</span><span> </span><span>f</span><span> </span><span>=</span><span> \x </span><span>-&gt;</span></p><p><span>  n </span><span>=</span><span> </span><span>1</span></p><p><span>  m </span><span>=</span><span> </span><span>2</span></p><p><span>  n </span><span>+</span><span> m</span></p></code></p></pre>
<p>can compile to something like</p>
<pre><p><code><p><span>f:
  sp-add 2  # reserve two cells on the stack, for n and m.
            # n will live at fp[0], i.e. at the index of the frame pointer
            # m will live at fp[1]
  push 1
  store-into fp[0]  # push, store n=1
  push 2
  store-into fp[1]  # push, store m=2
  push fp[0]
  push fp[1]
  add
  ret</span></p></code></p></pre>
</details>
<h3 id="representing-function-calls" tabindex="-1"><a href="#representing-function-calls" aria-hidden="true"></a>Representing function calls</h3>
<p>Before calling a function, the caller needs to</p>
<ul>
<li>allocate space for the callee&#39;s return value</li>
<li>push on the callee&#39;s arguments<span><label for="push-args"></label></span><span>this includes any captured values, which will be discussed later</span></li>
<li>store the program counter of the caller (since this is global)</li>
<li>store the frame pointer of the caller (since this is global, and will be
modified in the new function frame)</li>
</ul>
<p>We can have the virtual machine runtime take care of storing the program counter
and frame pointer, and restoring them when a function is returned, but our
compiler will need to take care of the first two line items.</p>
<p>In all, the procedure for calling functions is:</p>
<ul>
<li>
<p>Before call entry:</p>
<ul>
<li>
<p>allocate space for the return value</p>
</li>
<li>
<p>push on the callee&#39;s arguments</p>
</li>
<li>
<details>
<summary>
push on the caller&#39;s program counter and frame pointer
</summary>
<pre><p><code><p><span>&lt;return value&gt;
arg1
...
argn
@caller_pc
@caller_fp
--- &lt; stack top</span></p></code></p></pre>
</details>
</li>
</ul>
</li>
<li>
<p>During call:</p>
<ul>
<li>
<details>
<summary>Set the new program counter and frame pointer for the callee</summary>
<pre><p><code><p><span>&lt;return value&gt;
arg1
...
argn
@caller_pc
@caller_fp
--- &lt; stack top = fp</span></p></code></p></pre>
</details>
</li>
</ul>
</li>
<li>
<p>Upon return:</p>
<ul>
<li>
<details>
<summary>Reset the top of the stack to the callee&#39;s frame pointer.
That means the caller&#39;s frame pointer is now the top value on the stack.</summary>
<pre><p><code><p><span>&lt;return value&gt;
arg1
...
argn
@caller_pc
@caller_fp
---        &lt; fp &lt;-------\
&lt;local args&gt;            |
&lt;other stuff&gt;           |
---        &lt; reset to --/</span></p></code></p></pre>
</details>
</li>
<li>
<details>
<summary>Pop and restore the caller&#39;s frame pointer and program
counter.</summary>
<pre><p><code><p><span>&lt;return value&gt;
arg1
...
argn       &lt; ----------\
@caller_pc             |
@caller_fp             |
---        &lt; reset to -/</span></p></code></p></pre>
</details>
</li>
<li>
<details>
<summary>The caller deallocates the provided arguments, leaving the return value on
the top of the stack.</summary>
<pre><p><code><p><span>&lt;return value&gt; &lt;-------\
arg1                   |
...                    |
argn       &lt; reset to -/</span></p></code></p></pre>
</details>
</li>
</ul>
</li>
</ul>
<details>
<summary>Here&#39;s how a full function call would be represented in the VM.</summary>
<figure>

</figure>
</details>
<h3 id="representing-fibers" tabindex="-1"><a href="#representing-fibers" aria-hidden="true"></a>Representing fibers</h3>
<p>In this model, each fiber is identified by a unique stack. Spawning a fiber
allocates a new call stack. The virtual machine needs to bookkeep</p>
<ul>
<li>each unique fiber&#39;s call stack</li>
<li>what the current stack of fibers is, relative to the main fiber</li>
</ul>
<p>Spawning or resuming a fiber pushes onto the stack of active fibers.
Yielding pops the current fiber off the top of the stack, leaving the yielded
fiber&#39;s representation on the parent fiber&#39;s stack, as the return value of the
matching <code>spawn</code> or <code>resume</code>.</p>
<p>Because our fibers cannot be resumed multiple times, we also need to keep track
of a dirty bit in both the runtime representation of a fiber&#39;s stack, and the
<code>Fiber</code> value we return to the parent fiber. When a fiber is resumed, we check
that its dirty bit lines up with the fiber&#39;s dirty bit state; if these values
are out-of-line, we know the fiber has already been resumed and can&#39;t be resumed
again.<span><label for="dirty-bit-unneeded"></label></span><span> Note that the dirty bit would not needed if the type system were to enforce that a
fiber can be resumed at most once. It also would not be needed if multi-shot
resumptions were supported; one strategy to enable that is to create a new fiber
on each resumption, and reference-count fiber stacks.</span></p>
<p>Put all together, we can represent a <code>Fiber</code> that terminates with type <code>T</code> as
the runtime tuple</p>
<pre><p>ocaml</p><p><code><p><span>{ bit: int, value: T, fibidx: int, fibdirty: int }</span></p></code></p></pre>
<p>Where <code>bit=1</code> when the fiber is done, and 0 otherwise; <code>value</code> is the value the
fiber terminated with, or else undefined; <code>fibidx</code> is the unique reference to
the fiber&#39;s call stack; <code>fibdirty</code> is the fiber&#39;s dirty bit.</p>
<p>The values in the runtime tuple cannot be accessed directly from our source
language. In fact, <code>fibidx</code> and <code>fibdirty</code> are purely implementation details.
<code>bit</code> and <code>value</code> can be accessed conditionally, via the <code>stat</code> keyword.</p>
<h3 id="representing-tuples" tabindex="-1"><a href="#representing-tuples" aria-hidden="true"></a>Representing tuples</h3>
<p>Speaking of <code>stat</code>, it&#39;s worth noting how tuples (including <code>Fiber</code>s) are
represented on the stack. The directionality is somewhat arbitrary, but here
we&#39;ll have lower-indexed elements in a tuple stored at the top of the stack. For
example, a <code>Fiber&lt;{int, int}&gt;</code> will be stored as</p>
<pre><p><code><p><span>fiber.fibdirty
fiber.fibidx
fiber.value.1
fiber.value.0
fiber.bit &lt; stack top</span></p></code></p></pre>
<p>This has the advantage of making <code>stat</code>&#39;s job easier - once a fiber is loaded
onto the top of the stack, the pending/done bit can be immediately popped off,
and if needed, the terminating value is right on top of the stack.</p>
<h3 id="instruction-set" tabindex="-1"><a href="#instruction-set" aria-hidden="true"></a>Instruction set</h3>
<details>
<summary>
All that described, we can construct an instruction set for our virtual machine.
</summary>
<pre><p>ocaml</p><p><code><p><span>type</span><span> </span><span>op</span><span> </span><span>=</span></p><p><span>  </span><span>|</span><span> </span><span>Eq</span></p><p><span>  </span><span>|</span><span> </span><span>Lt</span></p><p><span>  </span><span>|</span><span> </span><span>Sub</span></p><p><span>  </span><span>|</span><span> </span><span>Add</span></p><p><span>  </span><span>|</span><span> </span><span>Mul</span></p><p><span>  </span><span>|</span><span> </span><span>Yield</span></p><p><span>  </span><span>|</span><span> </span><span>Spawn</span><span> </span><span>of</span><span> </span><span>{</span><span> </span><span>proc</span><span> </span><span>:</span><span> label</span><span>;</span><span> </span><span>args_size</span><span> </span><span>:</span><span> int</span><span>;</span><span> </span><span>ret_size</span><span> </span><span>:</span><span> int </span><span>}</span></p><p><span>  </span><span>|</span><span> </span><span>Resume</span><span> </span><span>of</span><span> int  </span><span>(** size of return value *)</span></p><p><span>  </span><span>|</span><span> </span><span>Push</span><span> </span><span>of</span><span> locator</span></p><p><span>  </span><span>|</span><span> </span><span>Store</span><span> </span><span>of</span><span> int  </span><span>(** store-into fp[offset] *)</span></p><p><span>  </span><span>|</span><span> </span><span>SpAdd</span><span> </span><span>of</span><span> int</span></p><p><span>  </span><span>|</span><span> </span><span>SpSub</span><span> </span><span>of</span><span> int</span></p><p><span>  </span><span>|</span><span> </span><span>SpRestoreFp</span><span>  </span><span>(** restore to the frame pointer. Used for tail calls *)</span></p><p><span>  </span><span>|</span><span> </span><span>Jmp</span><span> </span><span>of</span><span> label</span></p><p><span>  </span><span>|</span><span> </span><span>Jmpz</span><span> </span><span>of</span><span> label</span></p><p><span>  </span><span>|</span><span> </span><span>Jmprel1</span><span>  </span><span>(** jump relative to 1 + the integer on the top of the stack. *)</span></p><p><span>  </span><span>|</span><span> </span><span>Call</span><span> </span><span>of</span><span> label</span></p><p><span>  </span><span>|</span><span> </span><span>Ret</span></p><p><span>type</span><span> </span><span>basic_block</span><span> </span><span>=</span><span> label </span><span>*</span><span> op </span><span>list</span></p><p><span>type</span><span> </span><span>proc</span><span> </span><span>=</span><span> </span><span>{</span></p><p><span>  </span><span>name</span><span> </span><span>:</span><span> label</span><span>;</span></p><p><span>  </span><span>blocks</span><span> </span><span>:</span><span> basic_block </span><span>list</span><span>;</span></p><p><span>  </span><span>debug_frame</span><span> </span><span>:</span><span> debug_frame</span><span>;</span></p><p><span>}</span></p></code></p></pre>
</details>
<p>Instructions are organized into <a href="https://en.wikipedia.org/wiki/Basic_block">basic blocks</a>,
which are identified by a label and contain zero or more instructions that are
executed in a linear fashion. A basic block only branches out via a jump or
return at its exit.
Procedures consist of a name and one or more basic blocks.</p>
<p>Most of the bytecode instructions are standard, though there are a few
interesting ones:</p>
<ul>
<li>Along with taking the procedure to call, <code>Spawn</code> requires the size of the
procedure&#39;s arguments. That&#39;s because the arguments will need to be copied
over from the parent stack into the stack allocated for the child fiber.</li>
<li>Both <code>Spawn</code> and <code>Resume</code> require the size of the fiber&#39;s termination value,
because upon yield or termination, the runtime will need to know how
large to make the <code>Fiber</code> value representation.</li>
<li><code>SpAdd</code> allocates space on the stack (for local arguments and return values),
<code>SpSub</code> deallocates space on the stack (so callers can reclaim space used
for call argument), and <code>SpRestoreFp</code> restores the top of the stack to the
current frame pointer. We&#39;ll see that the latter instruction is useful for
implementing tail call elimination; it is otherwise unnecessary, since such
restoration happens by the runtime during a return.</li>
<li><code>Call</code> requires a named procedure, and there is no support for indirect calls.
This is not a joke, and there is no restiction here - we&#39;ll see below how to
compile <code>co_lc</code>, unrestricted in the kinds of closures you can create,
with only direct calls.</li>
</ul>
<h2 id="compilation-strategy" tabindex="-1"><a href="#compilation-strategy" aria-hidden="true"></a>Compilation strategy</h2>
<h3 id="type-inference" tabindex="-1"><a href="#type-inference" aria-hidden="true"></a>Type inference</h3>
<p>There are a few type systems <code>co_lc</code> could use; here we use the type system of
the simply-typed lambda calculus, with complete type inference via <a href="https://en.wikipedia.org/wiki/Unification_(computer_science)">unification</a>.
<a href="https://github.com/ayazhafiz/plts/blob/base/co_lc/ty_solve.ml">Here&#39;s one implementation of <code>co_lc</code> inference algorithm</a>;
I won&#39;t go into depth about it here, but the approach is pretty standard.</p>
<h4 id="a-tip-for-inference-of-tuples" tabindex="-1"><a href="#a-tip-for-inference-of-tuples" aria-hidden="true"></a>A tip for inference of tuples</h4>
<p>One thing that may be interesting, which I don&#39;t see typically covered in
discussions of unification-based inference, is how to deal with the inference of
tuples. The question has to do with an expression like</p>
<pre><p>ocaml</p><p><code><p><span>let</span><span> </span><span>f</span><span> </span><span>=</span><span> \t </span><span>-&gt;</span></p><p><span>  t</span><span>.</span><span>1 == 10</span></p></code></p></pre>
<p>Clearly, <code>t</code> is a tuple with an arity of at least two, where the second element
is an int. But the precise arity of the tuple, and its other elements&#39; types,
cannot be known at this point.</p>
<p>One solution is to have both dense representations of tuple types (for when
a tuple literal is seen), and a sparse representation for cases like the above.
That is, our type definition might look like</p>
<pre><p>ocaml</p><p><code><p><span>type</span><span> </span><span>ty</span><span> </span><span>=</span></p><p><span>  </span><span>..</span><span>.</span></p><p><span>  </span><span>|</span><span> </span><span>TupleDense</span><span> </span><span>of</span><span> ty </span><span>list</span><span>  </span><span>(*</span><span> list of element types </span><span>*)</span></p><p><span>  </span><span>|</span><span> </span><span>TupleSparse</span><span> </span><span>of</span><span> </span><span>(</span><span>int </span><span>*</span><span> ty</span><span>)</span><span> </span><span>list</span><span>  </span><span>(*</span><span> list of known indices&#39; types </span><span>*)</span></p><p><span>  </span><span>...</span></p></code></p></pre>
<p>When a <code>TupleSparse</code> unifies with a <code>TupleDense</code>, its respective elements (and
arities) must unify, and then the <code>TupleSparse</code> must become a <code>TupleDense</code>,
since that is the point of the concrete type&#39;s instantiation.</p>
<h3 id="eliminating-indirect-calls-and-heap-allocated-closures-via-defunctionalization" tabindex="-1"><a href="#eliminating-indirect-calls-and-heap-allocated-closures-via-defunctionalization" aria-hidden="true"></a>Eliminating indirect calls and heap-allocated closures via defunctionalization</h3>
<p>I did promise no indirect function calls, and I must deliver. We&#39;ll use
type-directed defunctionalization, via <strong>lambda sets</strong>, to guarantee that
all calls can be compiled directly<span><label for="defunctionalization-opt"></label></span><span>Defunctionalization (and <a href="https://quuxplusone.github.io/blog/2021/02/15/devirtualization/">devirtualization</a>) are typically done as optimizations in later stages of a compiler; however, by embedding call information in the type system, we can guarantee the optimization is applied.</span>,
with conditional dispatch via a jump table rather than a function pointer.</p>
<p>Lambda sets are due to William Brandon, et.al., unpublished manuscript. Lambda
sets are also used in <a href="https://www.roc-lang.org">Roc</a> to compile closures
without indirect calls or heap allocation.</p>
<h4 id="why-does-eliminating-indirect-calls-matter%3F" tabindex="-1"><a href="#why-does-eliminating-indirect-calls-matter%3F" aria-hidden="true"></a>Why does eliminating indirect calls matter?</h4>
<p>An indirect call occurs when a machine has to load the address to call at
runtime, rather than it being statically known.</p>
<h5 id="function-pointers" tabindex="-1"><a href="#function-pointers" aria-hidden="true"></a>Function pointers</h5>
<p>In our source language, it&#39;s reasonable to write something like</p>
<pre><p>ocaml</p><p><code><p><span>let</span><span> </span><span>caller</span><span> </span><span>=</span><span> \f </span><span>-&gt;</span><span> f </span><span>1</span><span> in</span></p><p><span>let</span><span> </span><span>id</span><span> </span><span>=</span><span> \x </span><span>-&gt;</span><span> x in</span></p><p><span>caller id</span></p></code></p></pre>
<p>A direct compilation of this code might produce bytecode like</p>
<pre><p><code><p><span>id:
  ...
caller:
  # suppose the argument is at fp[-3]
  push 1
  push fp[-3]
  call-indirect
  ret
main:
  push &amp;id
  call caller
  ret</span></p></code></p></pre>
<p>where the address of the function passed to <code>caller</code> has to be loaded, popped,
and dereferenced at runtime in order for <code>call-indirect</code> to determine what
function should ultimately be called. It&#39;s clear that in a program like the one
above, a smarter analysis could reduce the compiled code to</p>
<pre><p><code><p><span>id:
  ...
caller:
  push 1
  call id
  ret
main:
  call caller
  ret</span></p></code></p></pre>
<p>The advantages of the latter include</p>
<ul>
<li>The call site is statically known, enabling further compiler analyses and
optimizations like inlining <code>id</code> in <code>caller</code>.</li>
<li>If this were compiled to target a CPU, there would be no reliance on the CPU&#39;s
branch target predictor at runtime.</li>
</ul>
<p>The biggest downside of this approach I&#39;m aware of is that if <code>caller</code> is called
with multiple times with unique functions,</p>
<ul>
<li>a unique copy of <code>caller</code> must be stamped out for each unique argument (monomorphization, increasing code size)</li>
<li>or, direct calls can be used, but must be guarded by a jump table</li>
</ul>
<p>Speaking of jump tables -</p>
<h5 id="conditionally-determined-functions" tabindex="-1"><a href="#conditionally-determined-functions" aria-hidden="true"></a>Conditionally-determined functions</h5>
<p>A second case has to do with the representation of conditionally-determined
functions. Let&#39;s extend our previous example to</p>
<pre><p>ocaml</p><p><code><p><span>let</span><span> </span><span>caller</span><span> </span><span>=</span><span> \f </span><span>-&gt;</span><span> f </span><span>1</span><span> in</span></p><p><span>let</span><span> </span><span>id</span><span> </span><span>=</span><span> \x </span><span>-&gt;</span><span> x in</span></p><p><span>let</span><span> </span><span>mul2</span><span> </span><span>=</span><span> \x </span><span>-&gt;</span><span> x </span><span>*</span><span> </span><span>2</span></p><p><span>caller </span><span>(</span><span>if</span><span> </span><span>0</span><span> </span><span>==</span><span> </span><span>0</span><span> </span><span>then</span><span> id </span><span>else</span><span> mul2</span><span>)</span></p></code></p></pre>
<p>Again, a direct compilation of this code might produce bytecode like</p>
<pre><p><code><p><span>id:
  ...
caller:
  # suppose the argument is at fp[-3]
  push 1
  push fp[-3]
  call-indirect
main:
  push 0
  ifz
  jmp else
then:
  push &amp;id
  call caller
  ret
else:
  push &amp;mul
  call caller
  ret</span></p></code></p></pre>
<p>As before, this compilation determines a function pointer to dispatch to, and
passes that into <code>caller</code>. An alternative is to push down the conditional into
the body of <code>caller</code>, enabling a direct call within each branch of the
conditional.</p>
<pre><p><code><p><span>id:
  ...
caller:
  push 1
  # suppose the argument is at fp[-3]
  push fp[-3]
  ifz
  jmp call_mul_
call_id_:
  call id
  ret
call_mul_:
  call mul
  ret
main:
  push 0
  call caller
  ret</span></p></code></p></pre>
<p>The advantage here is that we&#39;ve eliminated one source of indirection - we still
need a conditional, but we&#39;ve gotten rid of function pointers. This
may make inline analyses more fruitful, and places less pressure on a CPU&#39;s
branch target predictor.</p>
<p>One thing I&#39;m not sure about is the efficacy of the jump-table-based <code>caller</code>
implementation relative to the function-pointer-based one, when <code>caller</code>&#39;s argument is static. In
that case, the main performance consideration would be</p>
<ul>
<li>for the function-pointer-based <code>caller</code>, how long a dereference takes, and how well
branch target prediction works on a CPU</li>
<li>for the jump-table-based <code>caller</code>, how long a conditional and jump takes, and how well
branch prediction works on a CPU</li>
</ul>
<p>I am not aware of any empirical studies on the efficacy of CPU&#39;s branch predictors
vs their branch target predictors<span><label for="branch-predictor-cf"></label></span><span>Though,
there is <a href="https://blog.cloudflare.com/branch-predictor/">this nice analysis by Cloudflare</a>.</span> -
<a href="https://ayazhafiz.com/cdn-cgi/l/email-protection#d7b6aeb6adf9bfb6b1beadf9e6fcb4b888bbb497b0bab6bebbf9b4b8bae8a4a2b5bdb2b4a3ea92b1b1beb4b6b4aef2e5e7b8b1f2e5e7b5a5b6b9b4bff2e5e7a3b6a5b0b2a3f2e5e7a7a5b2b3beb4a3b8a5a4f2e5e7a1a4f2e5e7b5a5b6b9b4bff2e5e7a7a5b2b3beb4a3b8a5a4">please let me know</a> if you know of any!</p>
<h4 id="eliminating-heap-allocated-captures" tabindex="-1"><a href="#eliminating-heap-allocated-captures" aria-hidden="true"></a>Eliminating heap-allocated captures</h4>
<p>Lambda sets also enable a natural way to eliminate heap
allocation of closure captures. This is pretty nice, especially in functional
paradigms where closures are common.</p>
<p>Let&#39;s consider the program</p>
<figure>

</figure>
<p>where <code>f</code> returns a function that either captures <code>x</code>, <code>x</code> and <code>y</code>, or <code>x</code> and
<code>y</code> and <code>z</code> (notice that <code>f</code> itself must capture all three). At runtime, the
captures must live alongside the representation of the function to call - which
means that the runtime representation of the captures must also be the same
size, no matter what function is returned<span><label for="captures-same-sized"></label></span><span>Because the return
value of <code>f</code> can be used indiscriminately, including being passed around to arbitrary
locations, it must have a statically-known size.</span>.</p>
<p>The typical way this requirement of uniformity<span><label for="conditional-closure"></label></span><span>Of course, one
alternative is to disallow the conditional selection of a closure. C++ and Rust
enforce this restriction by giving each closure a unique type, which is
incompatible with every other closure type.</span>
is achieved is by compiling closures to a representation like the following C struct</p>
<pre><p>c</p><p><code><p><span>struct</span><span> closure {</span></p><p><span>  </span><span>void</span><span>* fn_addr;</span></p><p><span>  </span><span>void</span><span>* captures;</span></p><p><span>};</span></p></code></p></pre>
<p>where each capturing function takes an opaque <code>captures</code> pointer as an argument,
which it can then unpack to the concrete type of captures it knows.</p>
<p>For the function <code>f</code> returns, this is needlessly generic - <code>f</code>&#39;s returned closure
can have the stricter representation</p>
<pre><p>c</p><p><code><p><span>struct</span><span> f_closure {</span></p><p><span>  </span><span>int</span><span> tag; </span><span>// 1, 2, or 3</span></p><p><span>  </span><span>struct</span><span> f_closure_captures captures;</span></p><p><span>};</span></p><p><span>union</span><span> f_closure_captures {</span></p><p><span>  </span><span>struct</span><span> captures1;</span></p><p><span>  </span><span>struct</span><span> captures2;</span></p><p><span>  </span><span>struct</span><span> captures3;</span></p><p><span>};</span></p><p><span>struct</span><span> captures1 {</span></p><p><span>  </span><span>int</span><span> x;</span></p><p><span>};</span></p><p><span>struct</span><span> captures2 {</span></p><p><span>  </span><span>int</span><span> x; </span><span>int</span><span> y;</span></p><p><span>};</span></p><p><span>struct</span><span> captures3 {</span></p><p><span>  </span><span>int</span><span> x; </span><span>int</span><span> y; </span><span>int</span><span> z;</span></p><p><span>};</span></p></code></p></pre>
<p>That is, we can keep a tag of three states telling us which function to dispatch
to (this is the elimination of function pointers discussed in previous
sections). And, we can reduce the representation of captures to a three-state
union - which can all be stored on the stack, at the expense of paying for the
largest captures size!</p>
<p>As before, we are making tradeoffs here. While this helps avoid heap-allocation,
it means that</p>
<ul>
<li>The smallest captures in a representation like the above take as much space on
the stack as the largest captures, which can be exceptionally wasteful if
the size discrepancy is large.</li>
<li>This scheme makes incremental and separate compilation more challenging, as
the addition of a new function can change the memory representation of
values far away.</li>
</ul>
<h4 id="inference-and-compilation-semantics-of-lambda-sets" tabindex="-1"><a href="#inference-and-compilation-semantics-of-lambda-sets" aria-hidden="true"></a>Inference and compilation semantics of lambda sets</h4>
<p>Actually, the <code>f_closure</code> struct representation I gave above is exactly where
lambda sets take us! If you already see how to get there, feel free to skip this
section.</p>
<p>I must again say that the original idea of lambda sets in this type-directed
form is due to William Brandon, et.al. in an unpublished manuscript. We&#39;ve also
used them in Roc, and learned a lot about their behavior (many potential blog
posts about that!).</p>
<p>The idea is</p>
<ul>
<li>
<p>Each syntactic function (a lambda <code>\x -&gt; ...</code>) gets a unique name</p>
</li>
<li>
<p>When inferring the type of a function, include the name of that function and
its set of captures in a set adjacent to the function type; this is the
lambda set.
For example,</p>
<pre><p>ocaml</p><p><code><p><span>x = 1</span></p><p><span>y = 1</span></p><p><span>f = \n -&gt; n + x + y</span></p></code></p></pre>
<p>may be given type <code>int -[f {x: int, y: int}]-&gt; int</code>, where <code>[f {x: int, y: int}]</code> is the lambda set.</p>
</li>
<li>
<p>When two functions unify, their lambda sets union.</p>
</li>
</ul>
<p>Take a look at the inferred types of our example from above. Feel free to
hover over <code>f</code>, or look at the elaborated output.</p>
<figure>

</figure>
<p>Notice that the inferred type is saying that <code>f</code> returns a function of type <code>int -&gt; int</code> whose lambda set is <code>[lam {x} | lam1 {x, y} | lam2 {x, y, z}]</code> - exactly
the three functions that we might dispatch to, and what their captures are! This
is all we need in order to compile the return value of <code>f</code> to the
<code>f_closure</code>-like representation described previously.</p>
<h3 id="compiling-functions%2C-including-lambda-sets" tabindex="-1"><a href="#compiling-functions%2C-including-lambda-sets" aria-hidden="true"></a>Compiling functions, including lambda sets</h3>
<details>
<summary>
Put all together, our compilation scheme for functions consists of
</summary>
<figure>

</figure>
</details>
<ul>
<li>When compiling a function (e.g. <code>lam2</code> of the example above)
<ul>
<li>Determine the stack size of its captures based on the largest captures of
any lambda in the lambda set it&#39;s involved in.
<ul>
<li>Compile the function to unpack the passed captures appropriately.</li>
<li>For the runtime representation of the function-to-call, store the captures on the
stack.</li>
</ul>
</li>
<li>If the lambda set of the function is non-unary, the function to call must be
determined conditionally; store a tag for this function on the top of the
stack (e.g. <code>2</code>, since <code>lam2</code> appears in index 2 of the set).</li>
</ul>
</li>
<li>When calling a function
<ul>
<li>
<details>
<summary>Load the argument, then the function. That way, the stack consists of the
argument, followed by any captures, followed by optionally the function
tag on the top of the stack.</summary>
<pre><p><code><p><span>&lt;arg&gt;
&lt;captures&gt;
&lt;tag if non-unary lambda set&gt;   &lt; stack top</span></p></code></p></pre>
</details>
</li>
<li>
<p>If the lambda set is unary, there is only one function that can be called -
compile the direct call.</p>
</li>
<li>
<p>If the lambda set is non-unary, build a <a href="https://stackoverflow.com/questions/48017/what-is-a-jump-table">jump table</a> (<a href="https://github.com/ayazhafiz/plts/blob/618c11248c41766be0a62d560b53fa9ce40a0040/co_lc/vm_conv.ml#L656-L682">one implementation</a>)
using the integer tag of the lambda on the top of the stack. Each branch of
the jump table can perform the appropriate direct call to the matched
function.</p>
</li>
</ul>
</li>
</ul>
<h3 id="tip%3A-deciding-where-to-store-values" tabindex="-1"><a href="#tip%3A-deciding-where-to-store-values" aria-hidden="true"></a>Tip: deciding where to store values</h3>
<p>I don&#39;t know if this is well-known, but one thing I find helpful during
compilation is to have the procedure that compiles an expression take a
parameter indicating where the expression should be compiled, rather than
(in this case) always compiling to the stack and storing the result elsewhere
later. This eliminates a lot of trivially-reducable load and stores.</p>
<p>For example, <a href="https://github.com/ayazhafiz/plts/blob/618c11248c41766be0a62d560b53fa9ce40a0040/co_lc/vm_conv.ml#L530">my implementation</a>
has the recursive bytecode compiler take an optional target destination, which
looks like</p>
<pre><p>ocaml</p><p><code><p><span>type</span><span> </span><span>opt_target</span><span> </span><span>=</span></p><p><span>  [ `Any</span></p><p><span>  | `FpOffset of int  (** store as a local offset from the frame pointer *)</span></p><p><span>  | `Stack (** store on the top of the stack *) ]</span></p></code></p></pre>
<p>Sometimes, the target truly can be arbitrary. For example, when <a href="https://github.com/ayazhafiz/plts/blob/618c11248c41766be0a62d560b53fa9ce40a0040/co_lc/vm_conv.ml#L736-L738">compiling a
tuple access</a>,
we don&#39;t really care if the tuple is loaded onto the top of stack or is in an
offset from the frame pointer - in the former case we can pop values off until
we get to the field we&#39;re looking for, and in the latter case, the access can be
made relative to where the tuple lives.</p>
<p>To facilitate the arbitrary-target case, the procedure also returns where
exactly the expression ended up being stored, as a type that&#39;s <code>opt_target</code>
without the <code>Any</code> variant.</p>
<h4 id="tail-call-optimization" tabindex="-1"><a href="#tail-call-optimization" aria-hidden="true"></a>Tail-call optimization</h4>
<p>Passing an optional target makes tail-call optimization very natural - when
we&#39;re compiling a function, we set up the target of the function body to a
special <code>return</code> local, which is the location where the caller allocated space
for the return value.</p>
<p>During the compilation of a function, if we see a call to the same function, and
whose target is the <code>return</code> local, we know that we can perform a tail-call
optimization! Thanks to lambda sets, the destination of a function call is in the function
type, so only the type of the function being applied needs to be examined to
understand <a href="https://github.com/ayazhafiz/plts/blob/618c11248c41766be0a62d560b53fa9ce40a0040/co_lc/vm_conv.ml#L609-L614">whether the optimization can be made</a>.</p>
<p>To actually perform the optimization, compile the call argument into the
location of the argument in the current function frame, reset the stack pointer
to the frame pointer, and jump back up to the top of the function. See, I
promised a use of <code>SpRestoreFp</code>!</p>
<h2 id="unexplored-extensions" tabindex="-1"><a href="#unexplored-extensions" aria-hidden="true"></a>Unexplored extensions</h2>
<p>Thanks for making it this far! You must be pretty interested in this kind of
stuff. There are various natural extensions to this project, which may make for
interesting projects:</p>
<ul>
<li>Make these fibers do something interesting. Our language and compiler is
enough to show off that the implementation of fibers works, but doesn&#39;t
actually demonstrate its use in an interesting one. One idea would be to add
support for making non-blocking network requests and show an example of
cooperative multitasking where multiple fibers fetch many webpages.</li>
<li>Implement an affine type system to enforce the one-shot behavior of our fibers
at compile-time.</li>
<li>Design and implement an analysis to detect what spawned expressions will never
yield. Those expressions can be optimized to happen as direct evaluations,
rather than needing to happen on a child fiber.</li>
<li>Design an efficient scheme for multi-resumable fibers.</li>
<li>Design a system for implicitly-yielding userland threads, and a preempting
runtime scheduler of userland threads. Modify the VM and compiler to support
this system.</li>
<li>Implement additional optimizations over the virtual machine, and optimizations
of the bytecode in the compiler.</li>
<li>My virtual machine is implemented in OCaml (and compiled to JavaScript via JSOO).
Using a tighter language, like C/Rust/Zig/whatever, for the VM (and compiling
to WASM) may result in a much faster machine.</li>
</ul>
<h2 id="playground-%26-implementation" tabindex="-1"><a href="#playground-%26-implementation" aria-hidden="true"></a>Playground &amp; Implementation</h2>
<p>I hope you enjoyed this post, and learned something. You can find my implementation
of the language compiler and VM on <a href="https://github.com/ayazhafiz/plts/tree/base/co_lc">GitHub</a>.
As you saw previously in this post, I&#39;ve also made a <a href="https://ayazhafiz.com/plts/playground/co_lc/?input=DYUwLgBATiDGEDMCWAjCBeCAdAdhAtAHwBQEEAnkiMACYDcpESCEeAPBAEyNgAWIeHI2oBnEBAAUyNBLz4IARgCUSiAGpJ0yXK4riSIcVCQY8EAA84GbCLABDMOKKNbDiK8cA6AAyMAPhAABgAKAjQGAOYEJGRkxoioCtYwIgCuALbiHiA%2BTEKxEBZWAN7SCgA0EN6V2Z6c6ooAvv5BACIA9jjicoQQxbXVrDX2XpzNBkbg0Kk4AGKo1iIADnYA7nhSC5zeqhPxKanAkJhF8MVQM-MolYPejXnExADEXN44fAkonXawsEisGRQICglRwgOBEHaLAO6SWYCQnRExHOIDSR08FWgqMOYDqjSAA&amp;backend=ir&amp;options=NohEFMFsEsBdQDQG9QDcCGAbAruUAuUABwCdoA7eBUAeyNmhvIGcDhizLEJN0AjUAF0AvoMEIwUOIhQYceQqQpVa9RizYdl3cLwEixgoA">playground</a> for the
language, embdded again below.</p>
<figure>

</figure>
<h2 id="ad%3A-are-you-interested-in-compiling-structural-subtypes%3F" tabindex="-1"><a href="#ad%3A-are-you-interested-in-compiling-structural-subtypes%3F" aria-hidden="true"></a>Ad: Are you interested in compiling structural subtypes?</h2>
<p>If you know of ways, or are interested in, compiling languages based on
structural subtyping to non-uniform representations,
please <a href="https://ayazhafiz.com/cdn-cgi/l/email-protection#83e2fae2f9adebe2e5eaf9adb2a8e0ecdcefe0c3e4eee2eaefade0eceebcf0f6e1e9e6e0f7bec0eceef3eaefeaede4a6b1b3f0f7f1f6e0f7f6f1e2efa6b1b3f0f6e1f7faf3eaede4a6b1b3f7eca6b1b3edecedaef6edeae5ecf1eea6b1b3f1e6f3f1e6f0e6edf7e2f7eaecedf0">email me</a>! This has been an ongoing project of mine
and I hope to write about it soon, and would love to chat through with others
interested.</p>
<p>In particular, the idea here is to combine</p>
<ul>
<li>the programming flexibility of structural subtyping</li>
<li>(non-principal, possibly incomplete) type inference, a-la MLsub</li>
<li>row polymorphism and polymorphic variants</li>
</ul>
<p>to design subtyping-based source languages with compilation to target languages
that</p>
<ul>
<li>do not support runtime object polymorphism (i.e. all procedures are monomorphized)</li>
<li>have non-uniform, unboxed representations</li>
<li>do not require introducing implicit conversions at re-binding or usage sites</li>
</ul>
</article></div>
  </body>
</html>
