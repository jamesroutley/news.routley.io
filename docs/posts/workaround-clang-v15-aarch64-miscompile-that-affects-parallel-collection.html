<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/cisco/ChezScheme/pull/879">Original</a>
    <h1>Workaround Clang v15 AArch64 miscompile that affects parallel collection</h1>
    
    <div id="readability-page-1" class="page"><div disabled="" sortable="">
<div>
          <p dir="auto">I spent so long tracking this down that I&#39;d like to tell you the long story, even though it doesn&#39;t really matter. The miscompile seems like a run-of-the-mill compiler error, but the way it affected Chez Scheme and Racket made it especially difficult to find.</p>
<p dir="auto">During 2022-2024, I&#39;ve tried off and on to track down an occasional failure in Racket builds on my macOS M1/M2 laptops. Memory would get mangled late in the build â€” specifically during documentation rendering for he &#34;math&#34; library, which uses libgmp and libmpfr in multi-threaded mode. Since the problem never happened on x86_64, and since it only happened during parallel documentation rendering, I was pretty sure that I was looking for some sort of race condition exposed by AArch64&#39;s weak memory coherence.</p>
<p dir="auto">Although I discovered that I could provoke a crash by just rebuilding documentation, even that step takes 10 minutes, and the crash would only happen rarely, so getting a crash would take hours. Any little change I made to try to gather information would make the crash go away or become much more difficult to provoke, so hours turned to days.</p>
<p dir="auto">Meanwhile, users of the Racket main distribution were not running into problems, which I chalked up to the fact that documentation is pre-rendered. Also, maybe more generally libgmp or libmpfr needed to be involved, so maybe it wasn&#39;t my problem. In any case, the lack of reports made the problem feel less of an emergency than I would normally consider crashing bugs, especially since I had so much trouble replicating the crash or pinpointing an issue. So, I&#39;d burn a day or three on the issue every few months.</p>
<p dir="auto">In September 2024, I finally gathered evidence to suspect that the problem was in the GC&#39;s parallel mode. And with that suspicion, I was finally able to make a small Chez Scheme program with the right ingredients to crash, showing that the problem was independent of Racket and math libraries. The big difference was being able to provoke a crash within seconds instead of hours, and I found the problem over the next day.</p>
<p dir="auto">In retrospect, it&#39;s clear why the problem was so difficult to find. I was pretty sure I was looking for a memory race, but that turned out to be because only multi-threaded programs could reach the miscompiled code. And only during parallel collections. And only when the collector is looking at specific words within a thread representing virtual registers, which are not something that programs normally use directly. The effect of the miscompile was that a &#34;does this object belong to me?&#34; check would succeed when it shouldn&#39;t. That matters only when a thread has an object in its virtual register that was allocated by a different thread, which is an even more rare use of a virtual register. And even when it goes wrong, there&#39;s only a small chance that different collector threads will end up looking at the same object at the same time, and even concurrent traversal of the same object will turn out ok a lot of the time! Finally, and most perniciously, the miscompile creates a race that isn&#39;t in the source code, and in a code template that is put in place by a macro that is used dozens of times in the output (and compiled ok in all other other instances).</p>
<p dir="auto">Meanwhile, Racket distributions are compiled with Clang v12, which is why it hasn&#39;t been a problem for Racket users, even when they run programs with parallelism.</p>
      </div>
</div></div>
  </body>
</html>
