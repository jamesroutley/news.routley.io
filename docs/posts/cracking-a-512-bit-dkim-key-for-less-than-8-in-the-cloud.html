<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://dmarcchecker.app/articles/crack-512-bit-dkim-rsa-key">Original</a>
    <h1>Cracking a 512-bit DKIM key for less than $8 in the cloud</h1>
    
    <div id="readability-page-1" class="page"><div><p>In our <a href="https://dmarcchecker.app/articles/spf-dkim-dmarc-adoption-2024">study on the SPF, DKIM, and DMARC records of the top 1M websites</a>, we were surprised to uncover more than 1,700 public DKIM keys that were shorter than 1,024 bits in length. This finding was unexpected, as RSA keys shorter than 1,024 bits are considered insecure, and their use in DKIM has been deprecated since the introduction of <a href="https://datatracker.ietf.org/doc/html/rfc8301" target="_blank">RFC 8301</a> in 2018.</p><p>Driven by curiosity, we decided to explore whether we could crack one of these keys. Our goal was to extract the private key from a public RSA key, enabling us to sign emails as if we were the original sender. We were also curious to see whether emails signed with this compromised key would pass the DKIM verification checks of major email providers like Gmail, Outlook.com, and Yahoo Mail, or if they would outright refuse to verify a signature generated with such a short key.</p><p>For our experiment, we chose redfin.com after discovering a 512-bit RSA public key at <i>key1._domainkey.redfin.com</i> (now no longer available):</p><pre>$ dig +short TXT key1._domainkey.redfin.com
&#34;k=rsa; p=MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAMx7VnoRmk/wFPeFWxrVUde6AJQI51/uPFL2CbiHGMnRSnLjPs72AgxAVHIe5QrNQ2riR5+7u47Sgh5R5va/d0cCAwEAAQ==&#34;</pre><h2>Decoding the RSA Public Key</h2><p>The public key, located in the DKIM record’s <code>p</code> tag, is encoded in <a href="https://en.wikipedia.org/wiki/X.690#DER_encoding" target="_blank">ASN.1 DER format</a>, and further encoded as Base64. To decode the key to obtain the modulus (<i>n</i>) and the public exponent (<i>e</i>), we used a couple of lines of Python code:</p><pre>$ python3
&gt;&gt;&gt; from Crypto.PublicKey import RSA
&gt;&gt;&gt; RSA.import_key(&#39;-----BEGIN PUBLIC KEY-----\n&#39; + &#39;MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAMx7VnoRmk/wFPeFWxrVUde6AJQI51/uPFL2CbiHGMnRSnLjPs72AgxAVHIe5QrNQ2riR5+7u47Sgh5R5va/d0cCAwEAAQ==&#39; + &#39;\n-----END PUBLIC KEY-----&#39;)
RsaKey(n=10709580243955269690347257968368575486652256021267387585731784527165077094358215924099792804326677548390607229176966588251215467367272433485332943072098119, e=65537)</pre><h2>Factorizing the RSA Modulus</h2><p>With the modulus <i>n</i> in hand, our next step was to identify the two prime numbers, <i>p</i> and <i>q</i>, whose product equals <i>n</i>. This process, known as factoring, can be quite challenging to perform efficiently. Fortunately, we found a powerful open-source tool called <a href="https://cado-nfs.gitlabpages.inria.fr/" target="_blank">CADO-NFS</a>, which offers an easy-to-use implementation of the Number Field Sieve (NFS) algorithm — the most efficient method available for factoring large integers.</p><p>Since factoring takes a lot of computing power and we didn’t want to tie up our computers for days, we went with renting a cloud server. We chose a server with 8 dedicated vCPUs (AMD EPYC 7003 series) and 32 GB of RAM from Hetzner, installing Ubuntu as the OS. Setting up CADO-NFS was straightforward:</p><pre>git clone https://gitlab.inria.fr/cado-nfs/cado-nfs.git
cd cado-nfs
make</pre><p>To ensure the server had enough memory for the task, we added 32 GB of swap space:</p><pre>sudo fallocate -l 32G /swapfile
sudo chmod 600 /swapfile
sudo mkswap /swapfile
sudo swapon /swapfile</pre><p>We started the factorization by calling the <code>cado-nfs.py</code> script with <i>n</i> as the input:</p><pre>./cado-nfs.py 10709580243955269690347257968368575486652256021267387585731784527165077094358215924099792804326677548390607229176966588251215467367272433485332943072098119</pre><p>The process took approximately 86 hours on our 8-vCPU server, successfully factorizing <i>n</i> into <i>p</i> and <i>q</i>:</p><pre>Info:Complete Factorization / Discrete logarithm: Total cpu/elapsed time for entire Complete Factorization 2.20529e+06/309865 [3d 14:04:25]
97850895333751392558280999318309697780438485965134147739065017624372104720767 109447953515671602102748820944693252789237215829169932130613751100276125683257</pre><p>Although opting for a more powerful server or distributing the workload across several systems (a process simplified by CADO-NFS) could have expedited the task, we weren’t pressed for time and didn’t mind the wait.</p><h2>Constructing the RSA Private Key</h2><p>After determining <i>p</i> and <i>q</i>, we had all the necessary components to construct the RSA private key. The process involved using Python and the PyCryptodome library:</p><pre>$ python3
&gt;&gt;&gt; from Crypto.PublicKey import RSA
&gt;&gt;&gt; from Crypto.Util.number import inverse
&gt;&gt;&gt; p = 97850895333751392558280999318309697780438485965134147739065017624372104720767
&gt;&gt;&gt; q = 109447953515671602102748820944693252789237215829169932130613751100276125683257
&gt;&gt;&gt; e = 65537
&gt;&gt;&gt; n = p * q
&gt;&gt;&gt; phi = (p-1) * (q-1)
&gt;&gt;&gt; d = inverse(e, phi)
&gt;&gt;&gt; key = RSA.construct((n, e, d, p, q))
&gt;&gt;&gt; private_key = key.export_key()
&gt;&gt;&gt; print(private_key.decode())</pre><p>These Python lines output the private key in PEM format, ready for use:</p><pre>-----BEGIN RSA PRIVATE KEY-----
MIIBOgIBAAJBAMx7VnoRmk/wFPeFWxrVUde6AJQI51/uPFL2CbiHGMnRSnLjPs72
AgxAVHIe5QrNQ2riR5+7u47Sgh5R5va/d0cCAwEAAQJAPliEv2dKk4DyA54nbwEH
mSzfLEOiuD8dKXZW9GpMhou72DYYcc5YD0PeQW0uGGsusnTZXRU3Kd3cmVfeR+np
4QIhANhVpOQ440Gqlda3nqCOAag12jq8ET+qr1G7VL8x9PF/AiEA8flYr5rUO6Io
/5HRoHq6p7dA75PRK+7v79o0/ijfTjkCIEdWPpCPfckKomxykllpWnyIfZT+rUVs
WHHAL1r480erAiAz3xD87ALtGbESQE8gyM50n5sjAJwJf/odf7h2d4qPOQIhAKwr
Nv6s5cQiwbYgm1KND83nrkxe6uFQlu9ilkdwAIY4
-----END RSA PRIVATE KEY-----</pre><h2>Sending DKIM-Signed Test Mails From @redfin.com</h2><p>With the RSA private key integrated into our OpenDKIM setup, we proceeded to the testing phase. We crafted a simple email with a FROM address of security@redfin.com, then sent it to a variety of email hosting services. Although most providers correctly identified the 512-bit key as insecure and rejected our DKIM signature, three major providers — Yahoo Mail, Mailfence, and Tuta — reported a <code>dkim=pass</code> result.</p><p><img src="https://dmarcchecker.app/assets/images/articles/dkim-pass-redfin-yahoo.png" alt="Yahoo Mail: Authentication Results"/></p><p>Here’s how each provider responded:</p><ul><li>Gmail: <span>FAIL</span></li><li>Outlook: <span>FAIL</span></li><li>Yahoo Mail: <span><strong>PASS</strong></span></li><li>Zoho: <span>FAIL</span></li><li>Fastmail: <span>FAIL</span></li><li>Proton Mail: <span>FAIL</span></li><li>Mailfence: <span><strong>PASS</strong></span></li><li>Tuta: <span><strong>PASS</strong></span></li><li>GMX: <span>FAIL</span></li><li>OnMail: <span>FAIL</span></li></ul><p>Given that redfin.com also has a valid DMARC record (<code>v=DMARC1;p=reject;pct=100;rua=mailto:a+99923342@fdmarc.net;ruf=mailto:f+99923342@fdmarc.net;ri=3600;fo=1;</code>), passing the DKIM check for <code>redfin.com</code> also means that our email passed DMARC verification and met the requirements for <a href="https://bimigroup.org/" target="_blank">BIMI</a>.</p><h2>Final Thoughts</h2><p>Three decades ago, breaking a 512-bit RSA public key was a feat achievable only with a supercomputer. Today, it’s possible to do so in just a few hours for less than US$8 on a cloud server. And if you have a powerful computer at home with 16 or more cores, you could accomplish this even more swiftly and cost-effectively.</p><p>There’s no good reason to use 512 or 768-bit keys these days. Email providers should automatically reject any DKIM signature generated with an RSA key shorter than 1,024 bits. We’ve alerted Yahoo, Mailfence, and Tuta about our findings and shared this advice with them.</p><p>Domain owners must also take action by reviewing their DNS settings for any outdated DKIM records that don’t comply with the 1,024-bit minimum standard. A simple way to check a DKIM record’s <code>p</code> tag is to count its Base64 characters: a 1,024-bit RSA public key will have at least 216 characters.</p></div></div>
  </body>
</html>
