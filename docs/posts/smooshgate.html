<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://developer.chrome.com/blog/smooshgate/">Original</a>
    <h1>SmooshGate</h1>
    
    <div id="readability-page-1" class="page"><div><h2 id="what-the-smoosh-happened" tabindex="-1"><a href="#what-the-smoosh-happened" aria-hidden="true">#</a> What the <em>smoosh</em> happened?!</h2><p>A <a href="https://tc39.github.io/proposal-flatMap/">proposal</a> for a JavaScript language feature called <code>Array.prototype.flatten</code> turns out to be Web-incompatible. Shipping the feature in Firefox Nightly caused <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1443630">at least one popular website</a> to break. Given that the problematic code is part of the widespread MooTools library, it’s likely that many more websites are affected. (Although MooTools is not commonly used for new websites in 2018, it used to be very popular and is still present on many production websites.)</p><p>The proposal author jokingly suggested renaming <code>flatten</code> to <code>smoosh</code> to avoid the compatibility issue. The joke was not clear to everyone, some people started to incorrectly believe that the new name had already been decided, and things escalated quickly.</p><h2 id="what-does-arrayprototypeflatten-do" tabindex="-1"><a href="#what-does-arrayprototypeflatten-do" aria-hidden="true">#</a> What does <code>Array.prototype.flatten</code> do?</h2><p><code>Array.prototype.flat</code>, originally proposed as <code>Array.prototype.flatten</code>, flattens arrays recursively up to the specified <code>depth</code>, which defaults to <code>1</code>.</p><pre><code></code></pre><p>Since the publication of this article, <code>flatten</code> has been renamed to <code>flat</code> to resolve #SmooshGate. The above example has been updated accordingly, but keep in mind that the original name was <code>flatten</code>.</p><p>The same proposal includes <code>Array.prototype.flatMap</code>, which is like <code>Array.prototype.map</code> except it flattens the result into a new array.</p><pre><code><span>[</span><span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>]</span><span>.</span><span>flatMap</span><span>(</span><span>(</span><span>x</span><span>)</span> <span>=&gt;</span> <span>[</span>x<span>,</span> x <span>*</span> <span>2</span><span>]</span><span>)</span><span>;</span></code></pre><p>MooTools defines their own non-standard version of <code>Array.prototype.flatten</code>:</p><pre><code><span>Array</span><span>.</span>prototype<span>.</span>flatten <span>=</span> <span>;</span></code></pre><p>MooTools’ <code>flatten</code> implementation differs from the proposed standard. However, this is not the problem! When browsers ship <code>Array.prototype.flatten</code> natively, MooTools overrides the native implementation. This ensures that code relying on the MooTools behavior works as intended regardless of whether native <code>flatten</code> is available. So far, so good!</p><p>Unfortunately, something else then happens. MooTools copies over all its custom array methods to <code>Elements.prototype</code> (where <code>Elements</code> is a MooTools-specific API):</p><pre><code><span>for</span> <span>(</span><span>var</span> key <span>in</span> <span>Array</span><span>.</span>prototype<span>)</span> <span>{</span></code></pre><p><code>for</code>-<code>in</code> iterates over “enumerable” properties, which doesn’t include native methods like <code>Array.prototype.sort</code>, but it does include regularly-assigned properties like <code>Array.prototype.foo = whatever</code>. But — and here’s the kicker — if you overwrite a non-enumerable property, e.g. <code>Array.prototype.sort = whatever</code>, it remains non-enumerable.</p><p>Currently, <code>Array.prototype.flatten = mooToolsFlattenImplementation</code> creates an enumerable <code>flatten</code> property, so it’s later copied to <code>Elements</code>. But if browsers ship a native version of <code>flatten</code>, it becomes non-enumerable, and <em>isn’t</em> copied to <code>Elements</code>. <strong>Any code relying on MooTools’ <code>Elements.prototype.flatten</code> is now broken.</strong></p><p>Although it seems like changing the native <code>Array.prototype.flatten</code> to be enumerable would fix the problem, it would likely cause even more compatibility issues. Every website relying on <code>for</code>-<code>in</code> to iterate over an array (which is a bad practice, but it happens) would then suddenly get an additional loop iteration for the <code>flatten</code> property.</p><p>The bigger underlying problem here is modifying built-in objects. Extending native prototypes is generally accepted as a bad practice nowadays, as it doesn’t compose nicely with other libraries and third-party code. Don’t modify objects you don’t own!</p><h2 id="why-dont-we-just-keep-the-existing-name-and-break-the-web" tabindex="-1"><a href="#why-dont-we-just-keep-the-existing-name-and-break-the-web" aria-hidden="true">#</a> Why don’t we just keep the existing name and break the Web?</h2><p>In 1996, before CSS became widespread, and long before “HTML5” became a thing, <a href="https://www.spacejam.com/1996/">the Space Jam website</a> went live. Today, the website still works the same way it did 22 years ago.</p><p>How did that happen? Did someone maintain that website for all these years, updating it every time browser vendors shipped a new feature?</p><p>As it turns out, “don’t break the Web” is the number one <a href="https://www.w3.org/TR/html-design-principles/#support-existing-content">design principle</a> for HTML, CSS, JavaScript, and any other standard that’s widely used on the Web. If shipping a new browser feature causes existing websites to stop working, that’s bad for <em>everyone</em>:</p><ul><li>visitors of the affected websites suddenly get a broken user experience;</li><li>the website owners went from having a perfectly-working website to a non-functional one without them changing anything;</li><li>browser vendors shipping the new feature lose market share, due to users switching browsers after noticing “it works in browser X”;</li><li>once the compatibility issue is known, other browser vendors refuse to ship it. The feature specification does not match reality (<a href="https://www.webstandards.org/2009/05/13/interview-with-ian-hickson-editor-of-the-html-5-specification/#about-browsers">“nothing but a work of fiction”</a>), which is bad for the standardization process.</li></ul><p>Sure, in retrospect MooTools did the wrong thing — but breaking the web doesn’t punish them, it punishes users. These users do not know what a moo tool is. Alternatively, we can find another solution, and users can continue to use the web. The choice is easy to make.</p><h2 id="does-that-mean-bad-apis-can-never-be-removed-from-the-web-platform" tabindex="-1"><a href="#does-that-mean-bad-apis-can-never-be-removed-from-the-web-platform" aria-hidden="true">#</a> Does that mean bad APIs can never be removed from the Web Platform?</h2><p>It depends. In rare cases, <a href="https://whatwg.org/faq#removing-bad-ideas">bad features can be removed from the Web</a>. Even just figuring out whether it’s <em>possible</em> to remove a feature is a very tricky effort, requiring extensive telemetry to quantify how many web pages would have their behavior changed. But when the feature is sufficiently insecure, is harmful to users, or is used very rarely, this can be done.</p><p><code>&lt;applet&gt;</code>, <code>&lt;keygen&gt;</code>, and <a href="https://dev.opera.com/blog/showmodaldialog/"><code>showModalDialog()</code></a> are all examples of bad APIs that were successfully removed from the Web Platform.</p><p>Patching MooTools so that it no longer extends built-in objects is a good idea. However, it doesn’t solve the problem at hand. Even if MooTools were to release a patched version, all existing websites using it would have to update for the compatibility problem to go away.</p><p>In a perfect world, MooTools would release a patch, and every single website using MooTools would magically be updated the next day. Problem solved, right?!</p><p>Unfortunately, this is unrealistic. Even if someone were to somehow identify the full set of affected websites, manage to find contact information for each and every one of them, successfully reach out to all the website owners, and convince them all to perform the update (which might mean refactoring their entire code base), the entire process would take years, at best.</p><p>Keep in mind that many of these websites are old and likely unmaintained. Even if the maintainer is still around, it’s possible they’re not a highly-skilled web developer like yourself. We can’t expect everyone to go and change their 8-year-old website because of a web compatibility issue.</p><h2 id="how-does-the-tc39-process-work" tabindex="-1"><a href="#how-does-the-tc39-process-work" aria-hidden="true">#</a> How does the TC39 process work?</h2><p>TC39 is the committee in charge of evolving the JavaScript language through the ECMAScript standard.</p><p><em>#SmooshGate</em> caused some to believe that “TC39 wants to rename <code>flatten</code> to <code>smoosh</code>”, but it was an in-joke that wasn’t well-communicated externally. Major decisions like renaming a proposal are not taken lightly, are not taken by a single person, and are definitely not taken overnight based on a single GitHub comment.</p><p>TC39 operates on <a href="https://tc39.github.io/process-document/">a clear staging process</a> for feature proposals. ECMAScript proposals and any major changes to them (including method renaming) are discussed during TC39 meetings, and need to be approved by the entire committee before they become official. In the case of <code>Array.prototype.flatten</code>, the proposal has already gone through several stages of agreement, all the way up to Stage 3, indicating the feature is ready to be implemented in Web browsers. It’s common for additional spec issues to come up during implementation. In this case, the most important feedback came <em>after</em> trying to ship it: the feature, in its current state, breaks the Web. Hard-to-predict issues like these are part of the reason why the TC39 process doesn’t just end once browsers ship a feature.</p><p>TC39 operates on consensus, meaning the committee has to agree on any new changes. Even if <code>smoosh</code> had been a serious suggestion, it seems likely that a committee member would object to it in favor of a more common name like <code>compact</code> or <code>chain</code>.</p><p>The renaming from <code>flatten</code> to <code>smoosh</code> (even if it hadn’t been a joke) has never been discussed at a TC39 meeting. As such, the official TC39 stance on this topic is currently unknown. No single individual can speak on behalf of all of TC39 until consensus is reached at the next meeting.</p><p>TC39 meetings are generally attended by people with highly diverse backgrounds: some have years of programming language design experience, others work on a browser or JavaScript engine, and an increasing number of attendants are there to represent the JavaScript developer community.</p><h2 id="how-was-smooshgate-resolved-eventually" tabindex="-1"><a href="#how-was-smooshgate-resolved-eventually" aria-hidden="true">#</a> How was SmooshGate resolved, eventually?</h2><p>During <a href="https://github.com/tc39/agendas/blob/master/2018/05.md">the May 2018 TC39 meeting</a>, #SmooshGate was officially resolved by renaming <code>flatten</code> to <code>flat</code>.</p><p><code>Array.prototype.flat</code> and <code>Array.prototype.flatMap</code> shipped in V8 v6.9 and Chrome 69.</p></div></div>
  </body>
</html>
