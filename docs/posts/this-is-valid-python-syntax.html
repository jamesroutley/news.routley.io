<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.bitecode.dev/p/this-is-valid-python-syntax">Original</a>
    <h1>This is valid Python syntax</h1>
    
    <div id="readability-page-1" class="page"><div><div><article><div class=""><div><div dir="auto"><ul><li><p><code>f&#34;{0xBE_AF:.2f}&#34;</code><em> is what happens if you use &#34;_&#34; in hex, and interpolate it with a 2 decimal precision.</em></p></li><li><p><code>[*(_ for [[][:], *_] in [((1, 2), &#34;woops&#34;)])]</code><em> combines a generator, unpacking in a list, unpacking in a loop, and unpacking in a slice, for this delicious cryptic effect.</em></p></li><li><p><code>(lambda *数字: __import__(&#39;math&#39;).prod(数字))(*([2]*6)) == 2**6</code><em> leverages the splat operator </em><code>*</code><em> for variadic parameters (as they work in a lambda) and unpacking arguments. Because </em><code>prod()</code><em> is not a built-in, we use the </em><code>__import__</code><em> function to access the module that holds it. 数字 is variable name.</em></p></li></ul><p>Python has come with a variety of notations for numbers for a long time:</p><pre><code><code>&gt;&gt;&gt; 250 # decimal
250
&gt;&gt;&gt; 0b11111010 # binary
250
&gt;&gt;&gt; 0xFA # hexadecimal
250
&gt;&gt;&gt; 2.5e2 # scientific notation
250.0
&gt;&gt;&gt; 0xFA == 250 == 0xFA  == 2.5e2
True
</code></code></pre><p><span>In 2016, </span><a href="https://peps.python.org/pep-0515/" rel="">PEP 515</a><span> started to allow underscores in numeric literals to Python 3.6. E.G, as a thousands separator:</span></p><pre><code><code>&gt;&gt;&gt; 250_000_000 == 250000000
True
</code></code></pre><p>But the new feature is not limited to base 10:</p><pre><code><code>&gt;&gt;&gt; 0b11_11_10_10
250
&gt;&gt;&gt; 0xBEAF == 0xBE_AF == 48_815
True
</code></code></pre><p>Now, it turns out 3.6 also added another fantastic feature, f-strings. And f-strings have the capacity to allow arbitrary code in them:</p><pre><code><code>&gt;&gt;&gt; f&#34;{1 + 1}&#34;
&#39;2&#39;
</code></code></pre><p><span>They also have an </span><a href="https://pyformat.info/" rel="">entire formatting language</a><span>, inherited from </span><code>format()</code><span>, with pretty sweet capabilities:</span></p><pre><code><code>&gt;&gt;&gt; f&#34;{1:03}&#34; # pad with zero
&#39;001&#39;
&gt;&gt;&gt; f&#34;{3.14957:.3f}&#34; # choosing decimal precision
&#39;3.150&#39;
</code></code></pre><p>And because those features can be combined, if you use &#34;_&#34; in hex, and interpolate it with a 2 decimal precision, you get:</p><pre><code><code>&gt;&gt;&gt; f&#34;{0xBE_AF:.2f}&#34;
&#39;48815.00&#39;
</code></code></pre><p>Of course, while all those nice toys are useful independently, I would not advise you to mix all of them too often. That doesn&#39;t scream readability, does it?</p><p>While not as powerful as destructuring in other languages (I still wish we could unpack dicts as JS does with objects), unpacking is still much more interesting than most people thinks.</p><p>When people say &#34;unpacking&#34;, they usually mean one of those in their head...</p><p>Putting iterable content in variables:</p><pre><code><code>&gt;&gt;&gt; a, b, c = range(3)
&gt;&gt;&gt; a
0
&gt;&gt;&gt; b
1
&gt;&gt;&gt; c
2
</code></code></pre><p>Inverting variables:</p><pre><code><code>&gt;&gt;&gt; a, b = b, a
&gt;&gt;&gt; a
1
&gt;&gt;&gt; b
0
</code></code></pre><p>(don&#39;t know why this is so famous, I never, ever used that in prod)</p><p>And because unpacking works in for loops, iterating on a dictionary:</p><pre><code><code>&gt;&gt;&gt; score = {&#34;red&#34;: 1, &#34;blue&#34;: 2}
&gt;&gt;&gt; for team, points in score.items():
...     print(team, &#34;:&#34;, points)
...
red : 1
blue : 2
</code></code></pre><p>But unpacking packs more than that. It can assign nested structures:</p><pre><code><code>&gt;&gt;&gt; [(team1, score1), (team2, score2)] = score.items()
&gt;&gt;&gt; team1
&#39;red&#39;
&gt;&gt;&gt; score1
1
</code></code></pre><p><span>If you don&#39;t care about other values, you can use </span><code>*</code><span> to capture them:</span></p><pre><code><code>&gt;&gt;&gt; first, *others = [&#34;Matrix 1&#34;, &#34;Matrix 2&#34;, &#34;Matrix 3&#34;, &#34;Matrix 4&#34;]
&gt;&gt;&gt; first
&#39;Matrix 1&#39;
&gt;&gt;&gt; others
[&#39;Matrix 2&#39;, &#39;Matrix 3&#39;, &#39;Matrix 4&#39;]
</code></code></pre><p><span>Also </span><code>*</code><span> has a completely different meaning, it can populate a list by unpacking other iterables in it:</span></p><pre><code><code>&gt;&gt;&gt; [*&#34;abc&#34;, *range(3)]
[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, 0, 1, 2]
</code></code></pre><p><span>This also works for tuples and sets, and </span><code>**</code><span> will populate mapping, but let&#39;s not make this article too big.</span></p><p>Now, for a new trick, Python allows you to assign to slices:</p><pre><code><code>&gt;&gt;&gt; numbers = list(range(10))
&gt;&gt;&gt; numbers[3:6] = [&#34;III&#34;, &#34;IV&#34;, &#34;V&#34;]
&gt;&gt;&gt; numbers
[0, 1, 2, &#39;III&#39;, &#39;IV&#39;, &#39;V&#39;, 6, 7, 8, 9]
</code></code></pre><p>It seems weird, but it&#39;s extremely performant in Python, where loops are super slow.</p><p>Well, it gets weirder when you realize you can actually use unpacking AND assign to slices together.</p><p>Imagine you have a list of RGB pixels:</p><pre><code><code>img = [&#34;r&#34;, &#34;g&#34;, &#34;b&#34;] * 10_000_000

</code></code></pre><p>And you want to turn it into a BGR pixels.</p><p>You can use a loop:</p><pre><code><code>&gt;&gt;&gt; %%timeit
... img = [&#34;r&#34;, &#34;g&#34;, &#34;b&#34;] * 10_000_000
... iterator= iter(img)
... groups= zip(iterator, iterator, iterator)
... img = [pixel for group in groups for pixel in group[::-1]]
...
...
1.15 s ± 18.2 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
</code></code></pre><p>But using slicing and unpacking is about 5 times faster:</p><pre><code><code>&gt;&gt;&gt; %%timeit
... img = [&#34;r&#34;, &#34;g&#34;, &#34;b&#34;] * 10_000_000
... img[:-1:3], img[2::3] = img[2::3], img[:-1:3]
...
...
279 ms ± 2.99 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
</code></code></pre><p><span>To understand the title on this section, you also need to realize </span><code>_</code><span> is a valid variable name in Python. In fact, we use it to say we want to ignore a value.</span></p><p>Now we can decrypt the hieroglyphs.</p><p>First, we assigned to a slice. But look at that, we can omit the variable to hold the list, and it still works. It&#39;s useless, but it works:</p><pre><code><code>&gt;&gt;&gt; a = []
&gt;&gt;&gt; a[:] = (1, 2)
&gt;&gt;&gt; a
[1, 2]
&gt;&gt;&gt; [][:] = (1, 2)
</code></code></pre><p>So this beast:</p><pre><code><code>&gt;&gt;&gt; [][:], *_ = ((1, 2), &#34;woops&#34;)
&gt;&gt;&gt; _
[&#39;woops&#39;]
</code></code></pre><p><span>Is unpacking </span><code>(1, 2)</code><span> to a slice on the left, and </span><code>&#34;woops&#34;</code><span> to </span><code>*_</code><span> on the right.</span></p><p>We can put it in a for loop because unpacking is legal in there:</p><pre><code><code>&gt;&gt;&gt; for [[][:], *_] in [((1, 2), &#34;woops&#34;)]:
...     print(_)
...
[&#39;woops&#39;]
</code></code></pre><p>And if it can go in a for loop, it can go into a comprehension list:</p><pre><code><code>&gt;&gt;&gt; [_ for [[][:], *_] in [((1, 2), &#34;woops&#34;)]]
[[&#39;woops&#39;]]
</code></code></pre><p>A comprehension list can be turned into a generator, we just have to swap brackets for parentheses. And we can unpack it in a list:</p><pre><code><code>&gt;&gt;&gt; gen = (_ for [[][:], *_] in [((1, 2), &#34;woops&#34;)])
&gt;&gt;&gt; [*gen]
[[&#39;woops&#39;]]
</code></code></pre><p>Finally:</p><pre><code><code>&gt;&gt;&gt; [*(_ for [[][:], *_] in [((1, 2), &#34;woops&#34;)])]
[[&#39;woops&#39;]]
</code></code></pre><p>Do you want this monstrosity to be written anywhere? Certainly not, but by decoding it, we learned a ton about Python.</p><p>Last one for the road?</p><p><span>There are no way to manipulate pointers from Python syntax, but splat operator (</span><code>*</code><span>) is still used for a lot of different cases.</span></p><p><span>First, putting a number to a power of something in Python is not </span><code>^</code><span>, but </span><code>**</code><span>:</span></p><pre><code><code>&gt;&gt;&gt; 3**4
81
</code></code></pre><p>Then, you have variadic parameters, which allows you to declare an infinite number of params for a function:</p><pre><code><code>&gt;&gt;&gt; def a_lot(*of_stuff): # accept 0, 1 or more params
...     print(of_stuff)
...
&gt;&gt;&gt; a_lot(1, 2, 3) # they are stored in a tuple in of_stuff
(1, 2, 3)
</code></code></pre><p><span>No need to call it </span><code>*args</code><span> by the way. This is just the naming convention used for &#34;I have no idea what&#39;s going in there&#34;, like for decorators.</span></p><p>Turns out, this works with lambdas:</p><pre><code><code>&gt;&gt;&gt; lambda *of_stuff: print(of_stuff)
&lt;function &lt;lambda&gt; at 0x7f5093e39510&gt;
</code></code></pre><p><span>One tricky thing that beginners get confused about, is that you can also use </span><code>*</code><span> to unpack arguments in a function call:</span></p><pre><code><code>&gt;&gt;&gt; def square_area(x1, y1, x2, y2):
...     side_length = abs(x2 - x1)
...     area = side_length ** 2
...     return area
... coords = [0, 0, 3, 3]
&gt;&gt;&gt; square_area(coords[0], coords[1], coords[2], coords[3])
9
&gt;&gt;&gt; square_area(*coords)
9
</code></code></pre><p><span>It&#39;s easy to get mixed up between </span><code>def func(*values)</code><span> (declare func with infinite params) and </span><code>func(*values)</code><span> (call func while unpacking arguments).</span></p><p><span>Let&#39;s add one last use case for </span><code>*</code><span>, initializing a list:</span></p><pre><code><code>&gt;&gt;&gt; [0] * 10
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
</code></code></pre><p>And we are almost there.</p><p><span>Now for the final touch, we must understand </span><code>import</code><span> is a statement in Python, meaning it must exist on its own line. But there is a function </span><code>__import__</code><span> that can also import modules, and calling it is an expression, so we can use it inside another expression:</span></p><pre><code><code>&gt;&gt;&gt; import sys
&gt;&gt;&gt; print(&#34;dev mode:&#34;, sys.flags.dev_mode) # if you don&#39;t know dev_mode, check it out!
dev mode: False
&gt;&gt;&gt; print(&#34;dev mode:&#34;, import sys)
  Cell In[126], line 1
    print(&#34;dev mode:&#34;, import sys)
                       ^
SyntaxError: invalid syntax
&gt;&gt;&gt; print(&#34;dev mode:&#34;, __import__(&#39;sys&#39;).flags.dev_mode)
dev mode: False
</code></code></pre><p>Now all together!</p><p>We create a list of 2:</p><pre><code><code>&gt;&gt;&gt; [2]*6
[2, 2, 2, 2, 2, 2]
</code></code></pre><p><span>This can be passed to the </span><code>math.prod</code><span> function:</span></p><pre><code><code>&gt;&gt;&gt; __import__(&#39;math&#39;).prod([2, 2, 2, 2, 2, 2])
64
</code></code></pre><p>Giving us the exact same value as:</p><pre><code><code>&gt;&gt;&gt; 2**6
64
</code></code></pre><p>Let&#39;s make it needlessly complicated with a function that accepts infinite parameters, then unpack the list in it:</p><pre><code><code>&gt;&gt;&gt; def useless_prod_wrapper(*numbers):
...     return __import__(&#39;math&#39;).prod(numbers)
...
&gt;&gt;&gt; useless_prod_wrapper(*[2, 2, 2, 2, 2, 2])
64
</code></code></pre><p>Hey, they cancel each other :)</p><p>This can be a lambda:</p><pre><code><code>&gt;&gt;&gt; useless_prod_wrapper = lambda *numbers: __import__(&#39;math&#39;).prod(numbers)
</code></code></pre><p>But why give a name to a lambda? We can call it directly:</p><pre><code><code>&gt;&gt;&gt; (     lambda *numbers: __import__(&#39;math&#39;).prod(numbers)     )(*[2, 2, 2, 2, 2, 2])
64
</code></code></pre><p>Well, if you put them all together, and translate “numbers” into simplified chinese, you get our magic formulas:</p><pre><code><code>&gt;&gt;&gt; (lambda *数字: __import__(&#39;math&#39;).prod(数字))(*([2]*6)) == 2**6
True
</code></code></pre><p>Yep, some unicode characters are valid Python variable names.</p><p>Once again, don&#39;t do this to your colleagues. Or to yourself.</p><p>Yet, while we can&#39;t fight against masters like C++ or Perl, Python is perfectly capable of being unreadable if you beat it with a hammer.</p><p>Python has this wonderful quality of allowing people to be rapidly productive with the core language and stdlib.</p><p>But you can dig deeper and deeper into the languages for years and still learn things.</p><p><span>For example, did you know that the </span><code>else</code><span> keyword can be used with </span><code>for</code><span>, </span><code>while</code><span> and </span><code>try</code><span>?</span></p><p>Have fun with the learning curve, it&#39;s a long one, but it&#39;s smooth and rewarding.</p></div></div></div></article></div></div></div>
  </body>
</html>
