<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://buttondown.email/hillelwayne/archive/i-have-complicated-feelings-about-tdd-8403/">Original</a>
    <h1>I have complicated feelings about TDD</h1>
    
    <div id="readability-page-1" class="page"><div>
                
                    
                        <p>There were a couple of threads this week on why Test Driven Development, or TDD, isn’t more widely used by programmers.</p>
<div><blockquote data-dnt="true"><p dir="ltr" lang="en">I spoze the historic and ongoing inability/unwillingness of the software trade to grasp and adopt test-driven development (TDD) is one of the most frustrating &amp; demoralizing events of my forty-two years as a professional geek.</p>— GeePaw Hill (@GeePawHill) <a href="https://twitter.com/GeePawHill/status/1556825728326553600?ref_src=twsrc%5Etfw">August 9, 2022</a></blockquote>

</div><p>That thread (it’s a good one) argues that the problem was an organization failure by TDD proponents, pushing too hard and letting memetic decay transmute “TDD” into “tests r gud”. I have a different explanation: TDD isn’t as valuable as its strongest proponents believe. Most of them are basing TDD’s value on their experience, so I’ll base it on mine.</p>
<p>Let’s start with my background: I’d consider myself a “TDD person”. I learned it in 2012, it helped me get my first software job, and my first two jobs were places that did strict TDD in Ruby. For a while all my personal projects followed strict TDD, and if I ever went crazy and did a tech startup, I’d use TDD to write the software. I <a href="https://www.hillelwayne.com/post/why-tdd-isnt-crap/" target="_blank">defended it back in 2018</a> and would defend it now.</p>
<p>The difference is that I treat it as a useful technique, one of many, while the very strongest advocates consider it transformational. Some claim <a href="https://twitter.com/gypsydave5/status/1405102658655080448" target="_blank">it’s as important to programming as washing your hands is to medicine</a>. Others think my experience with formal methods irrevocably stains my TDD credentials.</p>
<p><img alt="&#34;There&#39;s no doing TDD and TLA at the same time and you know it&#34;" src="https://buttondown.s3.amazonaws.com/images/d23eba2f-d159-4851-9f7f-0bf0cecf0f18.png"/> </p>
<p>Why the difference? Because we mean two different things. I practice “weak TDD”, which just means “writing tests before code, in short feedback cycles”. This is sometimes derogatively referred to as “test-first”. Strong TDD follows a much stricter “red-green-refactor” cycle:</p>
<ol>
<li>Write a minimal failing test.</li>
<li>Write <em>the minimum code possible</em> to pass the test.</li>
<li>Refactor everything without introducing new behavior.</li>
</ol>
<p>The emphasis is on minimality. In its purest form we have Kent Beck’s <a href="https://medium.com/@kentbeck_7670/test-commit-revert-870bbd756864" target="_blank">test &amp;&amp; commit || reset</a> (TCR): if the minimal code doesn’t pass, erase all changes and start over.</p>
<p>Further, we have different views on <em>why</em> to do TDD. Proponents of strong TDD often say it’s not a testing technique, but rather a “design technique” that happens to use testing. I struggle with this framing for two reasons. First of all, they’re using “design” in a very different way than I do: the local code organization versus the system specification. Second, many say it was <em>always</em> this way, when the original book explicitly calls it a testing technique. It’s okay to say “it was but we’ve learned since then”, but I get annoyed by historical revisionism.<sup id="fnref:revisionism"><a href="#fn:revisionism">2</a></sup></p>
<p>Regardless, it’s a core tenet of modern strong TDD: TDD makes your <em>design</em> better. In other words, weak TDD is a technique, while strong TDD is a <em>paradigm</em>.</p>
<h3>The straw maximalist</h3>
<blockquote>
<p>No one likes to hear they’re doing it wrong, least of all when they’re doing it wrong.</p>
<p>What if you tried TDD and it didn’t “work” (whatever that means), but in fact the thing you tried wasn’t TDD at all? — <a href="https://neopragma.com/2019/09/against-tdd/" target="_blank">Against TDD</a></p>
</blockquote>
<p>So a disclaimer: this is a newsletter piece, not a blog, so I’m trying to timebox the writing to one day.<sup id="fnref:one-day"><a href="#fn:one-day">1</a></sup> So I didn’t do as much research to make sure I completely understand the other side. Also, for the sake of not working through every nuance, I’m going to focus on a “maximalist” model of TDD:</p>
<ul>
<li>TDD must be used in all but the most exceptional cases.</li>
<li>The TDD cycle should be followed as strictly as possible (though TCR is unnecessary).</li>
<li>Test-first isn’t TDD.</li>
<li>TDD always leads to a better design.</li>
<li>TDD obviates other forms of design.</li>
<li>TDD obviates other forms of verification.</li>
<li>TDD cannot fail. If it causes problems, it’s because you did it wrong.</li>
</ul>
<div><blockquote data-dnt="true"><p dir="ltr" lang="en">The tradeoff between TDD and productivity is about the learning curve. Once you reach the top of that hill there’s no tradeoff. If you’re talking about a tradeoff, that signals where on the hill you might be.</p>— Jason Gorman (@jasongorman) <a href="https://twitter.com/jasongorman/status/1526254655453421568?ref_src=twsrc%5Etfw">May 16, 2022</a></blockquote>

</div><p>I don’t believe there are many true maximalists out there, though I’ve met at least one.<sup id="fnref:who"><a href="#fn:who">3</a></sup> Most advocates are moderate in some ways and extreme in others— I’m certainly no exception! But the maximalist is a good model for what the broader TDD dialog <em>looks like</em>. While people pay lip service to things like “use the right tool” and “there is no silver bullet”, they often express their <em>maximal viewpoints</em> and don’t share their caveats. Maximalism thinking is spread diffuse across the discipline.</p>
<p>Further, the counterpart to maximal TDD is “some TDD”, and knowing why maximalism breaks down helps me figure out where that “some” should be. So even if (almost) nobody is maximalist, it’s worth investigating. Just know that I’m assuming a spherical cow.</p>
<h2>Analyzing Maximalism</h2>
<p>The maximalist case for TDD comes from two benefits: it’s good for your testing and it’s good for design. </p>
<h3>Verification</h3>
<div><blockquote data-dnt="true"><p dir="ltr" lang="en">Test Driven Development <em>IS</em> Double Entry Bookkeeping.  Same discipline.  Same reasoning.  Same result.</p>— Uncle Bob Martin (@unclebobmartin) <a href="https://twitter.com/unclebobmartin/status/1193936180301185024?ref_src=twsrc%5Etfw">November 11, 2019</a></blockquote>

</div><p>The argument here is pretty simple: under maximal TDD, every line of code written is covered by a test, which will catch more bugs. I believe this, too!  More test coverage means fewer bugs. </p>
<p>The problem is that TDD tests are very constrained. To keep the TDD cycle fast, your tests need to be fast to write and run— “hundreds of tests in a second”. The only tests that fit all three criteria are hand-made unit tests. This leaves out other forms of testing:</p>
<ul>
<li>Integration testing</li>
<li>End-to-end testing</li>
<li>Mutation testing</li>
<li>Fuzzing</li>
<li>Property testing</li>
<li>Model-based testing</li>
</ul>
<p>For unit testing to be sufficient, it needs to supersede all of these other forms of testing. And it also needs to supersede non-testing based verification techniques:</p>
<ul>
<li>Manual testing</li>
<li>Code review</li>
<li>Type systems</li>
<li>Static analysis</li>
<li>Contracts</li>
<li>Shoving assert statements everywhere</li>
</ul>
<p>“But nobody says unit tests are all you need!” Well consider yourself lucky, because I’ve run into that strain of maximalism many, <em>many</em> times. If you use TDD you don’t have bugs, so if you have bugs you didn’t use TDD right. </p>
<blockquote>
<p>I don’t have to write the test for nil because I know that nil will never be passed. I don’t need to make states unrepresentable, if I know those states will never be represented. — <a href="https://blog.cleancoder.com/uncle-bob/2019/06/08/TestsAndTypes.html" target="_blank">Tests and Types</a></p>
</blockquote>
<p>But that’s impossible. Unit tests only cover <em>units</em>. There are no side effects, nondeterminism, or sequences of events. They only cover what the programmer thought to test, and only the specific inputs they chose. But many serious bugs are higher level, from <em>correct</em> components interacting in a bad way (<a href="https://www.hillelwayne.com/post/feature-interaction/" target="_blank">1</a> <a href="https://www.hillelwayne.com/post/stamping-on-eventstream/" target="_blank">2</a> <a href="https://www.youtube.com/watch?v=SM2uXpmyJmA" target="_blank">3</a>).<sup id="fnref:unhandled-errors"><a href="#fn:unhandled-errors">4</a></sup> Or they only happen with <a href="https://hillelwayne.com/post/cross-branch-testing/" target="_blank">very specific inputs</a>. Or they always happen on a nil, but there’s only a specific call chain that could pass nil. You never know if states will never be represented.</p>
<h3>“Design”</h3>
<div><blockquote data-dnt="true"><p dir="ltr" lang="en">Test Driven Development (TDD) is not a testing approach. </p>— Daniel Moka⚡ (@dmokafa) <a href="https://twitter.com/dmokafa/status/1333425674049216514?ref_src=twsrc%5Etfw">November 30, 2020</a></blockquote>

</div><p>As I said before, TDD advocates use “design” in a very different way than I do, so let’s start by explaining the difference.</p>
<p>Design, to me, is the software’s specification. We have a problem we want to solve and a set of properties we want to preserve, does our system satisfy that? For example, consider a worker that pulls data from three streams, merges them together, and uploads them into a database. I want to make sure that data isn’t duplicated, stream downtime are handled gracefully, all data is eventually merged, etc. I don’t care what methods the code is calling to make its “API requests” or how it turns a JSON response into domain objects. I just care what it does with the data.</p>
<p>By contrast, the “design” in TDD is how the code is organized. Is <code>munge</code> a public or private method? Should we split the http response handler into separate objects? What are the parameters for the <code>check_available</code> method? TDD advocates talk about “listening to your tests”: if writing the tests is hard, then that points to a problem in your code. You should refactor the code to make it easier to test. In other words, <strong>code that is hard to test through TDD is badly organized.</strong> </p>
<div><blockquote data-dnt="true"><p dir="ltr" lang="en">TDD is a <em>design</em> technique. If you don’t need to design, you don’t need TDD. (The tests are just a nice side effect of the design process.) I’m hard pressed to imagine a system so small that you can get away with zero design, tho.</p>— Allen Holub (@allenholub) <a href="https://twitter.com/allenholub/status/1360753124487491587?ref_src=twsrc%5Etfw">February 14, 2021</a></blockquote>

</div><p>(Again, this is the maximalist position.) </p>
<p>But does TDD guarantee good organization? I don’t think so. We know that TDDed code looks different. Among other things:</p>
<ul>
<li>Dependency injection. This makes the code more configurable at the cost of making it a lot more complex.</li>
<li>Lots of small functions instead of a few larger functions. </li>
<li>Large surfaces of public methods instead of deep use of private methods.</li>
</ul>
<p>Are these necessarily bad? No. <em>Can</em> they bad? Yes! Sometimes large functions <a href="https://copyconstruct.medium.com/small-functions-considered-harmful-91035d316c29" target="_blank">make for better abstractions</a> and small functions lead to confusing behavior graphs. Sometimes dependency injection makes code a lot more complex and hard to understand. Sometimes large public APIs tightens module coupling by encouraging reuse of “implementation objects”. If TDD is at odds with your organization, <em>sometimes the TDD is wrong</em>.</p>
<p>Now that’s a fairly weak argument, because it applies as much to any kind of design pressure. The more specific problem with maximalism is that the code organization must evolve in extremely small steps. This leads to path dependence: the end result of the code is strongly influenced by the path you took to get there.<sup id="fnref:refactoring"><a href="#fn:refactoring">6</a></sup> Take quicksort. Following maximal TDD, here were the first seven tests I wrote:</p>
<div><pre><span></span><code><span>quicksort</span><span>([])</span> <span># prove it exists</span>
<span>assert</span> <span>quicksort</span><span>([])</span> <span>==</span> <span>[]</span>
<span>assert</span> <span>quicksort</span><span>([</span><span>1</span><span>])</span> <span>==</span> <span>[</span><span>1</span><span>]</span>
<span>assert</span> <span>quicksort</span><span>([</span><span>2</span><span>,</span> <span>1</span><span>])</span> <span>==</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>]</span>
<span>assert</span> <span>quicksort</span><span>([</span><span>1</span><span>,</span> <span>2</span><span>])</span> <span>==</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>]</span>
<span>assert</span> <span>quicksort</span><span>([</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>1</span><span>])</span> <span>==</span> <span>[</span><span>1</span><span>,</span> <span>1</span><span>,</span> <span>2</span><span>]</span>
<span>assert</span> <span>quicksort</span><span>([</span><span>2</span><span>,</span> <span>3</span><span>,</span> <span>1</span><span>])</span> <span>==</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>]</span>
</code></pre></div>

<p>And here’s the minimal code that passes it:</p>
<div><pre><span></span><code><span>def</span> <span>quicksort</span><span>(</span><span>l</span><span>):</span>
    <span>if</span> <span>not</span> <span>l</span><span>:</span>
        <span>return</span> <span>[]</span>
    <span>out</span> <span>=</span> <span>[</span><span>l</span><span>[</span><span>0</span><span>]]</span>
    <span>for</span> <span>i</span> <span>in</span> <span>l</span><span>[</span><span>1</span><span>:]:</span>
        <span>if</span> <span>i</span> <span>&lt;=</span> <span>out</span><span>[</span><span>0</span><span>]:</span>
            <span>out</span> <span>=</span> <span>[</span><span>i</span><span>]</span> <span>+</span> <span>out</span>
        <span>else</span><span>:</span>
            <span>out</span><span>.</span><span>append</span><span>(</span><span>i</span><span>)</span>
    <span>return</span> <span>out</span>
</code></pre></div>

<p>To be clear, I wasn’t <em>trying</em> to be perverse here, this is how I used to do when I was being strict about TDD. With more tests it will converge on being correct, but the design is gonna be all wonky, because we wrapped the code around a bunch of tiny tests.</p>
<p>Now I said I do “weak TDD”, so I’d still write a test before quicksort. Unlike with maximal TDD, though, I wouldn’t write a unit test. Instead:</p>
<div><pre><span></span><code><span>from</span> <span>hypothesis</span> <span>import</span> <span>given</span>
<span>from</span> <span>hypothesis.core</span> <span>import</span> <span>example</span>
<span>import</span> <span>hypothesis.strategies</span> <span>as</span> <span>st</span>

<span>@given</span><span>(</span><span>st</span><span>.</span><span>lists</span><span>(</span><span>st</span><span>.</span><span>integers</span><span>()))</span>
<span>def</span> <span>test_it_sorts</span><span>(</span><span>l</span><span>):</span>
    <span>out</span> <span>=</span> <span>quicksort</span><span>(</span><span>l</span><span>)</span>
    <span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>1</span><span>,</span> <span>len</span><span>(</span><span>l</span><span>)):</span>
        <span>assert</span> <span>out</span><span>[</span><span>i</span><span>]</span> <span>&gt;=</span> <span>out</span><span>[</span><span>i</span><span>-</span><span>1</span><span>]</span>
</code></pre></div>

<p>This is an example of <em>property testing</em>. Instead of coding to a bunch of specific examples, I’m coding to the definition of sorting, and the test will run my code on random lists and check if the property holds. The conceptual unification runs much deeper, and this drives better organization.</p>
<p>That leads to my biggest pet peeve about maximalist TDD: it emphasizes local organization over global organization. If it can keep you from thinking holistically about a function, it can also keep you from thinking holistically about the whole component or interactions between components.<sup id="fnref:sudoku"><a href="#fn:sudoku">5</a></sup> Up front planning is a <em>good</em> thing. It leads to better design. </p>
<div><blockquote data-dnt="true"><p dir="ltr" lang="en">Architecture is too essential to design up-front.</p>— James Shore (@jamesshore) <a href="https://twitter.com/jamesshore/status/1416831739524091908?ref_src=twsrc%5Etfw">July 18, 2021</a></blockquote>

</div><p>(Actually my biggest pet peeve is that it makes people conflate code organization with software design, but non-TDDers conflate them too, so maybe I just picked an exceptionally poor topic to evangelize.)</p>
<h3>In defense of TDD</h3>
<p>I’ve spent enough time talking trash about TDD. As I said before, I regularly practice the “weak” form of TDD: write some kind of verification before writing the code, but without sticking to minimality or even test-based verification. The TDD maximalist might say this isn’t “real TDD”, but hell with them.</p>
<p>Weak TDD has four benefits:</p>
<ol>
<li>You write more tests. If writing a test “gates” writing code, you have to do it. If you can write tests later, you can keep putting it off and never get around to it. This, IMO, is the principle benefit of teaching TDD to early-stage programmers.</li>
<li>It’s easier to refactor, as you catch regressions more easily. </li>
<li>All of your code now has at least one client as you develop it. This tells you if your interfaces are too awkward early on.</li>
<li>It gets you in the habit of thinking about how your code will be verified, even if you don’t actually do so with a unit test.</li>
</ol>
<p>Wait, aren’t these the same benefits as maximal TDD? “It checks if you’ve got awkward interfaces” sounds an <em>awful</em> lot like “listening to your tests.” Well, yes. You <em>should</em> listen to your tests! TDD often makes your design better!</p>
<p>My point is that it can also make your design <em>worse</em>. Some TDD is better than no TDD, but no TDD is better than excessive TDD. TDD is a <em>method</em> you use in conjunction with other methods. Sometimes you’ll listen to the methods and they’ll give conflicting advice. Sometimes, TDD’s advice will be right and sometimes it will be wrong. Sometimes it’ll be so wrong that you shouldn’t use TDD in that circumstance.</p>
<h3>Why TDD hasn’t conquered the world</h3>
<div><blockquote data-dnt="true"><p dir="ltr" lang="en">Somewhat eye opening day. Test driven development was cutting edge circa 1999. It is the basis of modern development. I can’t imagine not using it. Hearing companies that don’t use it, is like hearing companies go “have you heard of this new thing called Linux?” … wtf?</p>— Simon Wardley ❤️🇺🇦 (@swardley) <a href="https://twitter.com/swardley/status/1491113234052665347?ref_src=twsrc%5Etfw">February 8, 2022</a></blockquote>

</div><p>So, after all that, I have my hypothesis on why TDD doesn’t spread. And to be honest it’s a pretty anticlimactic one. Maximal TDD isn’t nearly as important as the maximalist would believe. TDD is better used in a portfolio of methods. Since there’s way more useful methods than one person can possibly master, you pick what you want to get good at. Often TDD doesn’t make the cut. </p>
<p>I’d equate it to shell scripting. I spent a lot of time this spring learning shell scripting.<sup id="fnref:powershell"><a href="#fn:powershell">7</a></sup> It’s paid off tenfold. I think that every developer should know how to write custom functions. Is it more important than TDD? If people don’t have the time to learn both, which one should they pick? What if proper TDD takes so much time you can learn both shell scripting <em>and</em> debugging practices? When do people get to stop?</p>
<h2>Conclusions</h2>
<p>I have no idea where I’m even ending up. This “one day newsletter” took three days and 2500 words and I don’t know if it made anything clearer for me or for any of you. I don’t even know if my understandings are valid, because I didn’t do much research or work through any of the nuances. This is why I should leave this stuff to the blog and just use the newsletter for <a href="https://buttondown.email/hillelwayne/archive/regexes-are-cool-and-good/" target="_blank">regex stanning</a>.</p>
<hr/>
<h3>Update for the Internets</h3>
<p>This was sent as part of an email newsletter; you can subscribe <a href="https://buttondown.email/hillelwayne/" target="_blank">here</a>. Common topics are <a href="https://buttondown.email/hillelwayne/archive/why-uml-really-died/" target="_blank">software history</a>, <a href="https://buttondown.email/hillelwayne/archive/10-misconceptions-about-formal-methods/" target="_blank">formal methods</a>, the <a href="https://buttondown.email/hillelwayne/archive/reject-simplicity-embrace-complexity/" target="_blank">theory of software engineering</a>, and <a href="https://buttondown.email/hillelwayne/archive/whats-the-most-expensive-software-per-byte/" target="_blank">silly research dives</a>. Updates are usually 1x a week. I also have a <a href="https://www.hillelwayne.com/" target="_blank">website</a> where I put my polished writing (the newsletter is more for off-the-cuff stuff).</p>

                    
                
            </div></div>
  </body>
</html>
