<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.yet-another-blog.com/porting_the_game_to_jai_part0/">Original</a>
    <h1>Porting 58000 lines of D and C&#43;&#43; to jai, Part 0: Why and How</h1>
    
    <div id="readability-page-1" class="page"><article>
  <div>
    <div>

      
      <div>
        <p>In this series of blogposts, I will document my experience of porting <a href="https://www.spaced-game.com" target="_blank">the game that I am currently working on</a> to the jai programming language. It’s currently written in mostly D and some C++ and comes in at exactly 58,620 lines of code (excluding libraries). I’ve planned on doing this for a long time and want to keep some sort of record of my expectations, the journey and the result. And since every self-respecting programmer needs to start a blog at some point - why not share the process with the internet?</p>
<h3 id="why">Why<a href="#why"></a></h3><p>You may rightfully ask yourself: Why would anyone port a program of this size to another programming language? Just finish the project and then move on to the new language. In my case it’s for a couple reasons:</p>
<ul>
<li>The current setup causes me a lot of grief in day-to-day work</li>
<li>I have systems in place to help me porting, so I expect porting to go <em>somewhat</em> smoothly</li>
<li>jai seems way more attractive to me than either C++ or D</li>
</ul>
<p>And the most important reason: I just feel like it!</p>
<h4 id="why-not-c">Why not C++<a href="#why-not-c"></a></h4><p>Much has been said about the shortcomings of C++, so I’m not going to go into great detail here. In short, C++ has accumulated decades of bad decisions without any mechanism to get rid of them. The standard library is a disaster, (successfully) using other people’s code is comically hard and somehow each new addition to the language always seems to come with a catch. C++ is right in the spot where its shortcomings cause me a lot of pain, but at the same time it’s not bad enough that moving on is a no-brainer. But since it’s also not evolving in a direction I find promising, I don’t expect things to get better and want to leave the C++ ecosystem.</p>
<h4 id="why-not-d">Why not D<a href="#why-not-d"></a></h4><p>When I started working on my game in 2019, all the reasons for leaving C++ were already true, but I wasn’t sure where to go. Nevertheless, I settled on D since the basic pitch seemed reasonable: C++, but without the bad parts<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup>. Unfortunately, it turned out that we disagree on what <em>the bad parts</em> are and that D has various shortcomings that C++ doesn’t.</p>
<ul>
<li>90% of times, the <code>this</code> pointer is missing or wrong</li>
<li>variables on function stacks are often partially or completely missing or wrong</li>
<li><strong>values of variables are sometimes reported wrong without any other visible issues</strong></li>
<li>static foreach expansions are not handled well and confuse the debugger</li>
<li>mixins (D’s macro equivalent) generate debug info in a way that causes the debugger to not find the correct file (so you step through disassembly)</li>
<li>moving the instruction pointer back to the previous line in visual studio often crashes the program on the next instruction</li>
</ul>
<p>On the D Language Code Club discord, I was told that “DMD has historically had a lot of issues with the quality of its debug info” and that it’s being worked on, but unfortunately most of the points above apply to both compilers, not just dmd. Aside from debugging, there are other issues and shortcomings, to a significant part in metaprogramming:</p>
<ul>
<li>different compiler phases interact in weird ways that lead to surprises in metaprogramming, while generating misleading errors<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup><sup id="fnref:3"><a href="#fn:3" role="doc-noteref">3</a></sup><sup id="fnref:4"><a href="#fn:4" role="doc-noteref">4</a></sup></li>
<li>ldc2 is awfully slow to compile<sup id="fnref:5"><a href="#fn:5" role="doc-noteref">5</a></sup>, but sometimes the only choice because dmd has bugs<sup id="fnref:6"><a href="#fn:6" role="doc-noteref">6</a></sup></li>
<li>D offers a <em>betterC</em> mode that among other things disables garbage collection. However, when using this mode, the standard library does not compile and meta programming<sup id="fnref:7"><a href="#fn:7" role="doc-noteref">7</a></sup> is significantly hampered.</li>
<li>the documentation is lacking</li>
<li>… and about twenty other increasingly nitpicky issues.</li>
</ul>
<p>All this is to say: While D is genuinely better at some things than C++, the issues pile up in other places and make working with it very painful. Bad debug info and the de-facto need for garbage collection are dealbreakers, but there’s also the general feeling that the D creators’ vision of what a fixed C++ looks like is just vastly different from mine. Since I want to improve on C++, not just trade its problems for others, D is not the place to stay for me. I have severe trust issues with debuggers now.</p>
<h4 id="why-jai">Why jai<a href="#why-jai"></a></h4><p>This leads us to jai<sup id="fnref:8"><a href="#fn:8" role="doc-noteref">8</a></sup>. Jonathan Blow started development on this language in 2014 and has kept the compiler behind closed doors<sup id="fnref:9"><a href="#fn:9" role="doc-noteref">9</a></sup> until December 2019, where a closed beta began. This closed beta is still ongoing and about two months ago I was invited to it. Jai was born out of frustration over C++ and as opposed to D, it has evolved in a direction that I think could make a meaningful improvement over C++. In my eyes, the most important ones are faster compilation and allowing metaprogramming via unrestricted compile time execution.</p>
<ul>
<li>Reducing compile times from about 60s right now to under 5s, hopefully around 1s</li>
<li><em>having debuggers work</em></li>
<li>Replacing build-scripts with jai code</li>
<li>Catching more errors by introducing custom compilation checks using metaprogramming</li>
<li>Replacing complex metaprogramming code with simpler, imperative code</li>
<li>Reducing noise in the code due to various syntax improvements</li>
<li>Removing duplication that is unavoidable when using multiple languages</li>
</ul>
<p>Part of the reason this blogpost exist is because I don’t know yet whether these benefits will come to fruition in the manner I hope. Looking back at my initial expectations and checking how much they have been fulfilled will be an interesting exercise.</p>
<h4 id="why-not-something-else">Why not something else<a href="#why-not-something-else"></a></h4><p>Ok, so I don’t like D and C++ and jai looks good. But what about all the other languages?</p>
<p>The largest elephant in the room to address is probably Rust. It has gained a lot of momentum and a zealous community, but personally I simply don’t think it gets the tradeoffs right. Its proponents seem to share a strict memory-safety-is-the-only-way mentality, which I can vaguely relate to, given the many vulnerabilities that are attributed to memory safety, but this overlooks other approaches to making safe and high-quality software that are less extreme. For example, I believe a big chunk of these vulnerabilities would not exist if C and C++ (the most prominent “unsafe” languages for sure) simply didn’t have zero-terminated string, initialized values by default, had a proper pointer+length type thus replacing 90% of pointer arithmetic with easily bounds-checkable code, and had established a culture that discouraged the prevalent ad-hoc style of memory management. In addition to this, I think the most important reason we have so many vulnerabilities (and bugs in general) is completely disregarded in the hunt for “safe” code: culturally tolerated and even encouraged complexity<sup id="fnref:14"><a href="#fn:14" role="doc-noteref">14</a></sup>. In conclusion, putting up with Rusts compile times and submitting to the borrow checker seems like an extreme solution that doesn’t address the most important problem, which is a cultural one. Jai on the other hand is extremely concerned with complexity and tries to get the cultural part right.</p>
<p>For other less popular options like for example Zig, all I can say is that while they might have enormous potential, I simply wasn’t totally convinced that they would be the right choice. That doesn’t mean they are bad or anything, but it simply didn’t fully click.</p>
<h3 id="how">How<a href="#how"></a></h3><p>In the beginning I hinted at expecting the porting process to go <em>somewhat smoothly</em> (which I’m sure I won’t regret later). The reason for this is that I have two systems in my game that will hopefully be immensely helpful in this endeavor:</p>
<ul>
<li>The game records the inputs (HID, loaded files, network, …) of a play-session into a file and replay them later. When replaying, feeding recorded input into the deterministic game loop leads to the exact same state, down to the bit.</li>
<li>The game hashes game state at various points during execution and saves these hashes to a different file. When replaying, the contents of this file can be used to check that the execution of the replayed session exactly matches the original execution.</li>
</ul>
<p>There are a couple of nuances to both features, but they are not important for the big picture. Relying on these features, my plan to porting is the following:</p>
<ul>
<li>Copy a small piece of code from D or C++ to jai and make it compile.</li>
<li>Call the new jai code instead of the old D or C++ code.</li>
<li>Replay a recorded game session.</li>
<li>If the replay diverged, porting introduced a bug. Fix the bug.</li>
<li>If the replay didn’t diverge, porting was successful. repeat.</li>
</ul>
<p>The key questions for how well this approach will work are:</p>
<ul>
<li>Do all introduced bugs actually cause the game state to diverge in a noticeable manner?</li>
<li>Can the code be ported in small enough increments so that knowing a bug exists makes finding the bug itself easier?</li>
</ul>
<p>The first question depends on how much of the code is covered by state hashing. There are parts of code that need to know if the game is replaying or not, and these parts will internally behave differently and thus can’t be hashed meaningfully. For example, the write-file function just discards any data when replaying, so if porting introduces a bug in writing files, it won’t be noticed by hashing. Luckily, most code does not fall under this category. Initially hashing was only used sparsely in the codebase, in places like physics simulation (which already was super helpful!), but lately I managed to extend this to including hashing the size and capacity of a dynamic array when inserting into it. This means: When a bug causes any insert into a dynamic array to change <em>anywhere in the entire game logic</em>, it will be noticed. Since basically everything uses dynamic arrays in my code, even the minor changes in intermediary behavior of a big and complicated math algorithm should get noticed.</p>
<p>The second question is a classical programming problem: How well decoupled is your code? This is going to be super interesting because I am going to dig up all the accidental complexity in my codebase that I had forgotten about. An obvious problem are templated functions: These can’t be ported straightforwardly because the function definition and call sites have to be <em>in the same compiler</em> for templates to work, unless you manually instantiate the template. There’s quite some amount of templated code in the codebase, but it is relatively isolated to things like containers or serialization, so I hope this doesn’t cause too big of a headache.</p>
<h3 id="onwards">Onwards<a href="#onwards"></a></h3><p>Are you still here? I’m sorry, this has gotten way too long. Let me reward you with some pretty stats and pictures! First of all, this is the current state of the codebase:</p>
<pre><code>-------------------------------------------------------------------------------
Language                     files          blank        comment           code
-------------------------------------------------------------------------------
D                               27          10201           3104          32396
C++                              4           2343            411           7807
C/C++ Header                     1            533             75           1750
-------------------------------------------------------------------------------
SUM:                            32          13077           3590          41953
-------------------------------------------------------------------------------
</code></pre>
<p>Overall, 45701 lines of D and 12919 lines of C++, for a total of 58620 lines. Compile times are the following:</p>
<table>
<thead>
<tr>
<th>compiler</th>
<th>loc</th>
<th>debug</th>
<th>debug loc/s</th>
<th>release</th>
<th>release loc/s</th>
</tr>
</thead>
<tbody>
<tr>
<td>cl  (C++, v19.33.31630)</td>
<td>12919</td>
<td>2.9s</td>
<td>4,454</td>
<td>5.6s</td>
<td>2,306</td>
</tr>
<tr>
<td>ldc2 (D &amp; linking, v1.27.1)</td>
<td>45701</td>
<td>59s</td>
<td>774</td>
<td>317s</td>
<td>144</td>
</tr>
<tr>
<td>total</td>
<td>58620</td>
<td>61.9s</td>
<td>947</td>
<td>322.6s</td>
<td>182</td>
</tr>
</tbody>
</table>
<p>It regularly happens that ldc2 takes 3 minutes in debug mode, because it peaks at around 8GB of RAM, which can easily saturate my 16GB laptop when a browser is open. Release mode is even worse at 11.5GB.</p>
<figure>
  <a>
    <img data-src="/2022_11_11_plot_by_quarter.png" data-action="zoom" alt="Lines of code by quarter over time"/>
  </a>
  
</figure>
<figure>
  <a>
    <img data-src="/2022_11_11_plot_by_extensions.png" data-action="zoom" alt="Lines of code by filetype over time"/>
  </a>
  
</figure>
<p>If everything goes to plan, then in both graphs all existing color bands should be replaced by new ones. Exciting!</p>
<ul>
<li>I expect this to take 160 hours (one month of 40-hour weeks) of work. I’m horrible at estimating time, but one month seems like a long time.</li>
<li>I expect the compile time to go from about 1 minute to at most 5s, hopefully around 1s</li>
</ul>
<p>With that it’s off to the races! See you next time!</p>



        <hr/>
        
        <hr/>

        
        



<p><a href="https://disqus.com">comments powered by </a>







      </p></div>

      
      
      
      
      
      
      
    </div>
  </div>
</article></div>
  </body>
</html>
