<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://wafris.org/blog/rearchitecting-for-sqlite">Original</a>
    <h1>Rearchitecting: Redis to SQLite</h1>
    
    <div id="readability-page-1" class="page"><div>
             <p>Pssst - want to skip right to the chart? <a href="#chart">click here</a></p>
<h2>Background</h2>
<p>We&#39;re Wafris, an open-source web application firewall company that, among other frameworks, ships a Rails middleware client.</p>
<p>At launch, the v1 client required a local Redis datastore to be deployed with your app. We&#39;re now releasing v2 of our Rails client which uses SQLite as the backing datastore.</p>
<p>This article covers the decision-making that went into our migration from Redis to SQLite, performance considerations, and architectural changes. Continue reading this if you&#39;re interested in the decision-making that went into our migration to SQLite from Redis for our clients (the deployed middleware)</p>
<h2>TL;DR</h2>
<ul>
<li>SQLite has things it&#39;s good and bad at.</li>
<li>Redis has things it&#39;s good and bad at.</li>
<li>Traditional RDBMS (Postgres/MySQL) have things they&#39;re good and bad at.</li>
</ul>
<p>These data stores are not drop-in replacements, and if you try to do that, you&#39;ll have a bad time. This article walks through the testing and decision-making that went into rearchitecting our v1 Redis-based client to our v2 SQLite-based client.</p>
<h2>What forced this change?</h2>
<p>Since day one of Wafris, our goal has been to make it as easy as possible for developers to protect their sites.</p>
<p>But our v1 has had mixed results in delivering on that promise. We made what we thought at the time was a solid choice to back the Wafris client with a user-owned (bring your own) Redis datastore.</p>
<p>Partially, this was due to our having come up in the Heroku ecosystem, where Redis is an easy click away to get going and deployed in such a way that it&#39;s easy to access remotely. We also looked at successful projects like Sidekiq, which had a similar model.</p>
<blockquote><p>If we&#39;re trying to make things easy on you, we shouldn&#39;t casually make you a Redis database admin in the process.</p></blockquote>
<p>But the ecosystem is much larger than that, and many of our users encountered Redis deployment issues that were difficult to debug and fix.</p>
<p>In other words, if we&#39;re trying to make things easy on you, we shouldn&#39;t casually make you a Redis database admin in the process.</p>
<p>Further, when we exhibited at <a href="https://wafris.org/blog/railsworld-2023-recap" rel="follow">RailsWorld 2023</a>, there was a definite &#34;blood in the water&#34; vibe regarding Redis and the assumption that you&#39;d automatically need a Redis server running alongside your Rails application.</p>
<h2>What is Speed?</h2>
<p>While Redis is &#34;fast&#34; in comparison to traditional RDBMS, it&#39;s still a database that you have to manage connections, memory, processes, etc., which introduces more brittleness into the stack (the opposite of what we&#39;re trying to achieve).</p>
<p>And more than any of those, if you&#39;re in a cloud environment, you&#39;re looking at network latency. Network delays are a big deal for us as every inbound HTTP request to your app must be evaluated against the rules stored in Wafris. So while we sweated blood and code to get our v1 client as fast as possible, we&#39;d often wind up in situations where, despite our best efforts, we&#39;d still slow down an application as the network the app was provisioned into was slow.</p>
<p><img src="https://cdn.buttercms.com/Qgraed3TIekXzqhffUFR" alt="network-latency.webp" width="565" height="228"/></p>

<h2>Monolith-ish Assumptions</h2>
<p>While there certainly exist wholly distributed applications out there, and while most Rails apps are &#34;majestic monoliths&#34; (tm? idk, don&#39;t sue me), we&#39;ve found a lot of distributed apps that messed up our assumptions.</p>
<p>Apps that deploy to multiple zones, split functionality into servers with overlapping responsibilities, or are only partially Rails and deployed alongside other languages or frameworks.</p>
<p>Mostly, things aren&#39;t that clean in production, introducing even more friction with using Redis.</p>
<h2>Forcing a rethink of our architecture</h2>
<p>Wafris is a web application firewall. In Rails, it&#39;s installed as a middleware. It lets you set rules like &#34;block the IP 1.2.3.4,&#34; and then when someone requests your site, you evaluate that request against those rules.</p>
<p>Imagine it&#39;s this simplified two-step process:</p>
<ol>
<li>Compare HTTP request against the rules (if match == 403, else 200)</li>
<li>Report treatment (blocked, allowed, passed)</li>
</ol>
<p>Abstractly, this is a paired &#34;read&#34; of the rules in the database (step 2) and then a &#34;write&#34; of the report detailing what was done with that request along with its data.</p>
<p>From a logical standpoint, the first &#34;read&#34; half of this process is vastly more important than the latter &#34;write&#34; half:</p>
<ul>
<li>Reads, aka &#34;requests,&#34; need to be handled sequentially</li>
<li>Filtering of requests <em>must</em> work or bad requests could get through</li>
<li>Reads, aka &#34;requests,&#34; are time-sensitive as they affect user-perceived site performance.</li>
<li>Writes, aka &#34;reporting,&#34; can be done slower, batched, async, etc.</li>
</ul>
<h2>Enter SQLite</h2>
<p>Others have written far more eloquently about what SQLite is suitable for in general than I could ever hope to do so myself, so on that topic, I&#39;ll point you to the following resources:</p>
<ul>
<li>Aaron Francis&#39; &#34;High Performance SQLite&#34; course at <a href="https://highperformancesqlite.com/" rel="follow">https://highperformancesqlite.com/</a></li>
<li>Stephen Margheim&#39;s &#34;SQLite on Rails&#34; - <a href="https://fractaledmind.github.io/2024/04/15/sqlite-on-rails-the-how-and-why-of-optimal-performance/" rel="follow">the how and why of optimal performance</a> </li>
<li>Oldmoe - <a href="https://oldmoe.blog/" rel="follow">https://oldmoe.blog/</a></li>
</ul>
<h2>What&#39;s good about SQLite for Wafris?</h2>
<p>As noted above, our major bottleneck is network IO, and Stephen mentioned this line from the SQLite documentation: &#34;SQLite does not compete with client/server databases. SQLite competes with fopen().&#34;</p>
<blockquote><p>SQLite does not compete with client/server databases. SQLite competes with fopen().</p></blockquote>
<p>In theory, this should be much faster than a Redis solution solely based on cutting out the network round trip.</p>
<p>So, we decided to benchmark SQLite vs Redis.</p>
<h2>Benchmarking SQLite and Redis</h2>
<p>Benchmarking is a dark art of deceiving yourself with highly precise numbers.</p>
<p>And benchmarketing datastores is even more fraught. Every single flipping database benchmark I&#39;ve ever seen has been covered in a layer of asterisks and qualifications, and the comments on HN are full of &#34;if you&#39;d just set this flag when compiling it, you&#39;d get 3% more speed out of reads, and the fact that the people running this didn&#39;t do this is proof that they were paid off and that they actively sell shady NFT scams of deranged yacht rock Harambe memes.</p>
<p><img src="https://cdn.buttercms.com/4QeEUKlrSmSXIwf4F6by" alt="undefined" width="351" height="351"/></p>
<p>However, we have an advantage here. We&#39;re not trying to get some absolute number of speed under pristine conditions and carefully tweaked settings. We are creating a wildly specific and biased benchmark against our own data in a use case that lends itself to some extremes that I would neither expect nor hope that anyone else would have to deal with.</p>

<h3>Studiously ignoring optimization tweaks</h3>
<p>We&#39;re trying to optimize for people throwing Wafris into their app and having it &#34;Just Work™&#34; (ok, this one might actually be <a href="https://trademarks.justia.com/776/82/it-just-works-77682144.html">trademarked</a>).</p>
<p>We&#39;re also not testing against some theoretical benchmark suite (that can be gamed ala <a href="https://www.theregister.com/2021/01/28/nvidia_tpc_benchmark/#::text=Nvidia%20has%20been%20accused%20of,very%20umpires%20of%20the%20test">NVIDIA</a>).</p>
<p>We&#39;re testing the hot path of <em>our</em> own application and <em>our</em> worst query.</p>
<p>Our worst query is a somewhat complicated request for a &#34;lexical decimal&#34; data structure that maps IP ranges (v4 and v6) against categories. The simplest to consider is IP -&gt; Country mapping, where we return the country if an IP address is within a range of two addresses.</p>
<p>It&#39;s terrible because these structures are, by necessity, large (millions of rows), and in the case of IPv6, every single entry is huge.</p>
<p>To make this happen, we precompute the range lookups and then wrote them to:</p>
<ul>
<li>A table in SQLite</li>
<li>A <a href="https://redis.io/docs/latest/develop/data-types/sorted-sets/">sorted set</a> in Redis</li>
</ul>
<p>For each inbound HTTP request, we, in the pathological case, have to check the requesting IP against:</p>
<ol>
<li>Custom Allow ranges</li>
<li>Custom Block ranges</li>
<li>GeoIP ranges</li>
<li>IP Reputation ranges</li>
</ol>
<p>This is what we mean by &#34;hot path&#34;—this singular query type is so important that we can ignore all the rest of the query types and functions.<a href="https://moderndaymoguls.com/2020/01/05/peloton-bike/" rel="follow"></a></p>
<p>So, for our benchmarking scripts, we tested only this one query type, saving us days of work porting more significant (but irrelevant to the hot path) portions of the app to the benchmark.</p>
<h2>The Testing Protocol</h2>
<p><img src="https://cdn.buttercms.com/HklvqQLITaOLUv9bna3b" alt="undefined"/></p>
<p>Testing was done on my local Macbook Air M2 with a homebrew installed Redis and local SQLite db.</p>
<ol>
<li>We tested against our existing ranges dataset (1.2 million entries)</li>
<li>Multiple sets of IPs were then run in the same order against both SQLite and Redis.</li>
<li>At each multiple, we ran the test 5 times and took the average of the runs.</li>
</ol>
<h2>Testing Results</h2>
<p><img src="https://cdn.buttercms.com/gd2RyAi4RGiz44JhWGOH" alt="undefined" width="739" height="554"/></p>

<p>SQLite beat Redis like an overhyped UFC fighter doing a jump off the fence to land a kick punch (for our particular use case in this niche)</p>
<p>SQLite was roughly a 3x speed improvement over a locally deployed Redis instance. YMMV. Note again that this is before any network latency is considered.</p>
<p>From our perspective, this was a fantastic result as even if SQLite were only on par with Redis locally, we&#39;d still win by being able to entirely axe network times.</p>
<p>I&#39;d like to stress again that this is extremely flawed testing (by design) with really naive settings, but it is done in a way that mirrors the flaws of real-world usage we observed.</p>
<h2>What&#39;s missing from the chart?</h2>
<p>Benchmarks exist in a vacuum. What the chart fails to capture is that:</p>
<ul>
<li>Even if the SQLite performance was significantly worse (like 2x worse) in the benchmark, it would <em>still</em> probably be faster in the &#34;real world&#34; because of network latency, even to a Redis that was in the same data center/region</li>
<li>Even if you had a super robust Redis server (cluster, sharded, etc.), there are still a bunch of limits around it for network bandwidth, connections, etc., and again cross-region latency. SQLite gets us near-infinite horizontal scaling for &#34;free&#34;; more on this below.</li>
<li>The onboarding is so much better with SQLite - I imagine most users won&#39;t even know that it&#39;s being used; they&#39;ll just add the gem to their web app and be up and running.</li>
<li>There are a lot of potential improvements that could be done to get more juice out of Redis. However, we&#39;ve been unable to consistently persuade users to make even basic configuration changes (like cache eviction policy) to their Redis setups as it&#39;s such a pain and they don&#39;t want to be Redis admins.</li>
</ul>
<p>We&#39;re focused on:</p>
<ol>
<li>Making Wafris easy to deploy</li>
<li>Making rule evaluation as fast as possible</li>
</ol>
<p>Everything else flows from that, so that&#39;s what we&#39;re rearchitecting towards. NOT &#34;the best database setup,&#34; not &#34;the easiest infrastructure for us (Wafris) to manage,&#34; etc.</p>
<h2>Results are just the start</h2>
<p>Great, so now that we&#39;ve established that SQLite is faster than Redis (caveats, caveats, caveats), everything still isn&#39;t great because there are real-world tradeoffs.</p>
<p>One <em>huge</em> tradeoff in the testing above is that we didn&#39;t even consider doing any writes.</p>
<p>While it&#39;s never really stated, the whole reason for a &#34;proper&#34; database to have connections, connection pools, transactions, and whatever proprietary magic allows Oracle to charge a billion dollars for a database is to manage writes contending with reads for data in your database.</p>
<p>Consider an electric Chinese supercar driven by a charming British man - it&#39;s fast, it&#39;s fantastic, and it is absolute bollocks at hauling a load of concrete blocks across town.</p>
<p><a href="https://www.youtube.com/watch?v=DzFT5ndMZ_Q" rel="follow"><img src="https://cdn.buttercms.com/iX3Bns2ySayFT5LOKidM" alt="undefined" width="713" height="398"/></a></p>
<p>SQLite is like that NIO EP9 supercar. We need to use it for what it&#39;s good at and not force it into a role it&#39;s not suited for.</p>
<h2>Building a sync architecture</h2>
<p>On v1 (Redis), the update loop looked like this:</p>
<ol>
<li>User updates a rule (&#34;block the IP 1.2.3.4&#34;) in Wafris Hub</li>
<li>Wafris Hub updates the rules in your Redis datastore</li>
</ol>
<p>This obviously won&#39;t work with SQLite because we can&#39;t &#34;push&#34; a SQLite database to a web server. There are some newer SQLite as a service providers that let you do a version of this, but for a variety of cost, performance, and security considerations, it won&#39;t work for us as we&#39;d still need individual users to deploy them, open ports, allow inbound connections, etc.</p>
<p>On v2 (SQLite), the update loop looks like this:</p>
<ol>
<li>User updates a rule (&#34;block the IP 1.2.3.4&#34;) in Wafris Hub</li>
<li>At some interval (time or number of requests), the client checks for updated rules</li>
<li>If rules are updated, the client downloads an entirely new SQLite database</li>
</ol>
<p>This works well as it removes much of the user&#39;s installation and configuration responsibility.</p>
<p>We&#39;re seeing a ~3x increase in successful installs of the v2 client.</p>
<h2>SQLite Distributed Architecture</h2>
<p>Consider a Rails app deployed to a cloud provider (AWS, Heroku, Fly, etc). with autoscaling enabled.</p>
<p>Your requests go from 100 req/s to 10,000 req/s. and your compute (dynos, machines, ec2 instances) start spinning up to handle the load, but does your database?</p>
<p>The answer is almost certainly no because a bottleneck is a bottleneck without the database, and while you could overprovision it by 100x &#34;just in case,&#34; realistically, nobody wants to do that.</p>
<p><code><img src="https://cdn.buttercms.com/F4yeDPLUSN2JsDEZrOLD" alt="singular.webp"/></code></p>
<p>In practice, this is the number one thing that we see kill Rails apps under heavy load. Rarely is it an actual DDOS attack; more often, it&#39;s a credential stuffing attack or a bad bot that is hammering a site, pushing up autoscaling that&#39;s then exhausting database connections, which causes the app to fall over.</p>
<p><code><img src="https://cdn.buttercms.com/kjwGl08yRwiwjX9GLdrp" alt="distributed.webp"/></code></p>
<p>Flipping this to a system where an SQLite DB is synced down to each compute instance solves this problem excellently by keeping all the calls local to the new compute instance.</p>
<h2>But what about writes?</h2>
<p>We started this article by discussing splitting the app into a read (rule evaluation) and write (reporting) path and then studiously ignored the write path.</p>
<p>We did rearchitect the write path to do the following:</p>
<ul>
<li>Async connects to Wafris Hub for reporting</li>
<li>Batch sending of the reports</li>
<li>Completely removing database writes from the clients</li>
</ul>
<p>Which will work for approximately 0% of everybody else, but we don&#39;t care about them.</p>
<p>We care about the 100% of our users who want the Wafris client to be easy to deploy and stupid fast.</p>
<p>It&#39;s hard to know if there&#39;s a lesson you can learn from reading all of this, but we sincerely appreciate you taking the time.</p>
<h2>Conclusion</h2>
<p>First: thanks to <a href="https://x.com/aarondfrancis" rel="follow">Aaron Francis</a>, <a href="https://x.com/tnorthcutt" rel="follow">Travis Northcutt</a>,  <a href="https://brianhogg.com">Brian Hogg</a>, <a href="https://twitter.com/dceddia.com">Dave Ceddia</a>, <a href="https://push.cx">Peter Bhat Harkins</a> and <a href="https://x.com/natebosscher?lang=en">Nate Bosscher</a> for their feedback and suggestions on this post.</p>
<p>Second: we&#39;re exceedingly happy with our v2 architecture, which uses SQLite. It&#39;s already helped many sites weather attacks and stay online.</p>
<p>It&#39;s much easier to get going, with less support work for us and less hassle for users, which we think is a win for a safer, more secure internet.</p>
<p>If you&#39;d like to get started, sign up on <a href="https://wafris.org/signup" rel="follow">Wafris Hub</a>.</p>
          </div></div>
  </body>
</html>
