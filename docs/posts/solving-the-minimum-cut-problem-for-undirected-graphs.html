<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://research.google/blog/solving-the-minimum-cut-problem-for-undirected-graphs/">Original</a>
    <h1>Solving the minimum cut problem for undirected graphs</h1>
    
    <div id="readability-page-1" class="page"><div>
                
                    <section>
                        
                        



<p>We discuss a recent (best-paper award) publication at ACM-SIAM Symposium on Discrete Algorithms (SODA24) which gives a near-linear running time deterministic algorithm for the fundamental optimization problem of finding a minimum cut in weighted graphs.</p>
                        
                    </section>
                
                
                
                


<section>
    
    <div>
        <p data-block-key="ef8si">A <a href="https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)" target="_blank" rel="noopener noreferrer">graph</a> is a ubiquitous data structure used in computer science that consists of nodes (or vertices) and edges between pairs of nodes to capture objects and their relations. The <a href="https://en.wikipedia.org/wiki/Minimum_cut" target="_blank" rel="noopener noreferrer">minimum cut problem</a> (often referred to as “min-cut”) is a basic structural question about the connectivity of a graph that asks: what is the least expensive way to disconnect a network? More formally, given an input graph where edges have <a href="https://en.wikipedia.org/wiki/Orientation_(graph_theory)" target="_blank" rel="noopener noreferrer">no orientation</a> (i.e., the graph is <i>undirected</i>) and are associated with positive weights quantifying the importance of the edges (e.g., capacity of a road, or strength of a relationship, level of similarity between the endpoints, etc.), a cut is a partition of the nodes into two sides. The size of a cut is the total weight of edges connecting nodes on different sides of the cut, and the min-cut problem is to find a cut of the minimum size.</p><p data-block-key="8gv1h">Solving it efficiently has been one of the most fundamental problems in algorithmic graph theory. Moreover, min-cut has diverse applications in practice such as image restoration, stereo and segmentation in computer vision, and network resilience analysis (such as for roads or power grids). It is also generally very useful when the underlying graph data is too large and needs to be partitioned into smaller components to be processed in a divide-and-conquer manner.</p><p data-block-key="20u0d">In the theory of algorithm design, the <a href="https://en.wikipedia.org/wiki/Asymptotic_computational_complexity" target="_blank" rel="noopener noreferrer">asymptotic complexity</a> for any problem that requires reading the entire input (which is the case for min-cut) is at least linear in the size of the input (since that is the time needed to read the input). A <a href="https://web.eecs.umich.edu/~gurevich/Opera/82.pdf" target="_blank" rel="noopener noreferrer">nearly-linear time</a> algorithm essentially achieves this lower-bound, and thus is canonically viewed as the optimal result one can achieve. For the min-cut problem, existing nearly-linear time algorithms are either randomized (which may output an incorrect answer with some probability) or only work for the special case when the graph is <a href="https://mathworld.wolfram.com/SimpleGraph.html" target="_blank" rel="noopener noreferrer">simple</a> (which cannot model many real-world applications), so its optimal complexity remains an open problem.</p><p data-block-key="3mnj3">In “<a href="https://epubs.siam.org/doi/10.1137/1.9781611977912.111" target="_blank" rel="noopener noreferrer">Deterministic Near-Linear Time Minimum Cut in Weighted Graphs</a>”, which co-won the best paper award at the ACM-SIAM Symposium on Discrete Algorithms (<a href="https://www.siam.org/conferences/cm/conference/soda24" target="_blank" rel="noopener noreferrer">SODA2024</a>), we design the first nearly-linear algorithm for the min-cut problem that is deterministic (i.e., always finds the correct answer) and that also works for general graphs, thus settling the optimal complexity for the min-cut problem.</p>
    </div>


    
</section>

                
                


<section>
    
    <div>
        <h2 data-block-key="ef8si">Technical insights</h2><p data-block-key="er3ve">Our result is the culmination of a long line of research, and algorithmic advances on this problem (including ours) are usually motivated by structural discoveries of graph connectivity. In particular, a seminal result by <a href="https://dl.acm.org/doi/10.1145/237814.237829" target="_blank" rel="noopener noreferrer">Karger in 1996</a> gave a nearly-linear time randomized algorithm that finds a min-cut with high probability, and a critical insight from that work was the existence of a much smaller graph that largely preserves all cuts’ size. This is useful since one can afford to run a slower algorithm with the smaller graph as input, and the slower running time (in terms of the size of the smaller graph) can still be nearly-linear in the size of the original (larger) graph. Indeed, many of the structural discoveries on the min-cut problem are along this direction, and the high-level idea of reducing problem size while preserving structures of interest has been widely impactful in algorithm design.</p>
    </div>


    
</section>

                
                


<section>
    
    <div>
        <h2><span>Cut-preserving graph sparsification</span></h2>
<p><span>We start by discussing the structural insight used by Karger in more detail. Starting with a graph </span><span><em><span>G</span></em></span><span> with</span><em><span> <span>n</span></span></em><span> nodes, the cut-preserving sparsification by </span><a href="https://arxiv.org/pdf/cs/0207078.pdf" target="_blank" rel="noopener noreferrer"><span>Benzur and Karger</span></a><span> established the existence of a sparse </span><em><span>weighted</span></em><span> graph </span><em><span><span>G</span>’</span></em><span> on the same set of nodes with a smaller number of edges such that with high probability, every cut </span><span><em><span>S</span></em></span><span>’s size in </span><em><span><span>G</span>’</span></em><span> is roughly the same as its size in </span><span><em><span>G</span></em></span><span>. This idea is illustrated below, where the original graph consists of two complete graphs connected by a single edge (i.e., the dumbbell graph), and the sparsified graph has fewer, but larger weight, edges, while all the cut sizes are approximately preserved. </span></p>
    </div>


    
</section>

                
                
    

<!-- mode: '' -->


  
    <div>
      <video playsinline="" muted="true" loop="true" preload="auto">
        <source src="https://storage.googleapis.com/gweb-research2023-media/media/GraphMinCut1-Sparsification.mp4" type="video/mp4"/>
      </video>
      <div aria-label="Video Play/pause">
        <p><span>play silent looping video</span>
          <span>pause silent looping video</span>
        </p>
        
      </div>
      
      <p data-block-key="dszb2">Illustration of the cut preserving graph sparsification.</p>
      
    </div>
  



                
                


<section>
    
    <div>
        
<p><span>To algorithmically construct such a sparser graph, Benzur and Karger used the approach of sampling edges independently, where each edge in </span><span><em><span>G</span></em></span><span> is included in </span><em><span><span>G</span>’</span></em><span> with some probability, and its weight in </span><em><span><span>G</span>’</span></em><span> is scaled up by the reciprocal of the sampling probability (e.g., an edge of original weight </span><span>1 </span><span>in </span><span><em><span>G</span></em></span><span> would have a weight of </span><span>10 </span><span>in </span><em><span><span>G</span>’</span></em><span> if it’s included with a </span><span>10%</span><span> chance). It turns out that with high probability, this remarkably simple (and nearly-linear time) method can successfully construct a cut-preserving graph sparsification.</span></p>
<p><span>The cut-preserving graph sparsification, along with several other creative algorithmic ideas, yielded Karger&#39;s breakthrough result. However, Karger’s algorithm is a </span><a href="https://en.wikipedia.org/wiki/Monte_Carlo_algorithm" target="_blank" rel="noopener noreferrer"><span>Monte Carlo algorithm</span></a><span>, i.e., the output may be incorrect with (small) probability, and there is no known way to tell if the output is correct other than comparing it with an actual known min-cut. Since then, researchers have been on the quest to resolve the open question of a nearly-linear time deterministic algorithm. In particular, the construction of the cut-preserving graph sparsification is the only component in Karger’s algorithm that is randomized, and an apparent recipe is to find a deterministic construction (a.k.a. </span><a href="https://en.wikipedia.org/wiki/Randomized_algorithm#Derandomization" target="_blank" rel="noopener noreferrer"><span>derandomization</span></a><span>) of the sparsification in nearly-linear time.</span></p>
<p><span>In 2015, </span><a href="https://arxiv.org/pdf/1411.5123.pdf" target="_blank" rel="noopener noreferrer"><span>Kawarabayashi and Thorup</span></a><span> achieved a major milestone with such a deterministic nearly-linear time algorithm for simple graphs, i.e., graphs that have at most one edge between every pair of nodes and all edge weights equal to </span><span>1</span><span>. The key observation in that work is a connection between min-cut and another important graph structure known as a low-conductance cut (explained below). This connection also turned out to be critical in later efforts to derandomize Karger’s algorithm on graphs of general edge weights, which eventually culminated in our result.</span></p>
    </div>


    
</section>

                
                


<section>
    
    <div>
        <h2><span>Alignment of min-cut and low-conductance cut</span></h2>
<p><span>The </span><a href="https://en.wikipedia.org/wiki/Conductance_(graph)" target="_blank" rel="noopener noreferrer"><span>conductance</span></a><span> of a cut </span><span><em><span>S</span></em></span><span> is defined as the ratio of the cut size of </span><span><em><span>S</span></em></span><span> over the volume of </span><span><em><span>S</span></em></span><span> (assuming </span><span><em><span>S</span></em></span><span> is the smaller volume side of the cut and is non-empty), where the volume of </span><span><em><span>S</span></em></span><span> is the sum of the degree of the nodes in </span><span><em><span>S</span></em></span><span>. A cut </span><span><em><span>S</span></em></span><span> of low conductance intuitively captures a bottleneck in a network, as there is only a small number of edges (relative to its volume) connecting </span><span><em><span>S</span></em></span><span> to the rest of the graph. The conductance of a graph is defined as the min conductance of any cut in the graph, and a graph of large conductance (a.k.a. an </span><a href="https://en.wikipedia.org/wiki/Expander_graph" target="_blank" rel="noopener noreferrer"><span>expander graph</span></a><span>) is considered well-connected as there is no bottleneck inside. </span></p>
    </div>


    
</section>

                
                
    

<!-- mode: '' -->


  
    
    
    <picture>
      
      
      <source media="(min-width: 768px)" srcset="https://storage.googleapis.com/gweb-research2023-media/images/GraphMinCut2-ConductanceHERO.width-800.png" alt="GraphMinCut2-ConductanceHERO"/>
      
      <img src="https://storage.googleapis.com/gweb-research2023-media/images/GraphMinCut2-ConductanceHERO.width-800.png" alt="GraphMinCut2-ConductanceHERO" loading="lazy"/>
      
        <p data-block-key="02c3n">The cut represented by the red dotted line has size 2, and the smaller side (the bottom) has volume 24, so its conductance is 1/12, which is also the graph’s conductance.</p>
      
    </picture>
  



                
                


<section>
    
    <div>
        <p><span>Kawayabarashi and Thorup made the observation that any non-trivial (i.e., both sides have at least two nodes) min-cut must have low conductance in a simple graph where the min node degree is large. Following this observation, if one can partition the graph into well-connected clusters, the partitioning must be consistent with every non-trivial min-cut in the sense that each cluster must lie entirely on one side of every such cut. One can then contract each cluster into a single node, and work on the smaller graph where all non-trivial min-cuts of the original graph are intact.</span></p>
<p><span>However, for weighted graphs the same observation no longer holds, and the same partitioning used in the simple graph case may not be exactly consistent with non-trivial min-cuts. Nonetheless, </span><a href="https://arxiv.org/abs/2106.05513" target="_blank" rel="noopener noreferrer"><span>Li 2021</span></a><span> observed that such a partitioning is still approximately consistent with non-trivial min-cuts as illustrated in the figure below. In particular, for a non-trivial min-cut </span><span><em><span>S</span></em></span><span>, there exists a cut </span><em><span><span>S</span>’</span></em><span> that is not too different from </span><span><em><span>S</span></em></span><span> such that </span><em><span><span>S</span>’</span></em><span> is consistent with the clusters. Li further observed that this property of the partitioning can be exploited to efficiently derandomize the construction of cut-preserving graph sparsification. </span></p>
    </div>


    
</section>

                
                
    

<!-- mode: '' -->


  
    <div>
      <video playsinline="" muted="true" loop="true" preload="auto">
        <source src="https://storage.googleapis.com/gweb-research2023-media/media/GraphMinCut3-NearMin.mp4" type="video/mp4"/>
      </video>
      <div aria-label="Video Play/pause">
        <p><span>play silent looping video</span>
          <span>pause silent looping video</span>
        </p>
        
      </div>
      
      <p data-block-key="yw8w3">A partitioning of the graph that is approximately consistent with near-minimum cuts.</p>
      
    </div>
  



                
                


<section>
    
    <p><span>In our new result, we devise an algorithm to construct such a partitioning tailored to our use case of finding min-cut. Compared to the more generic off-the-shelf method used by Li in the previous work, our tailored construction is much more precise, so that the original min-cut </span><span><em><span>S</span></em></span><span> and its corresponding cluster-consistent cut </span><em><span><span>S</span>’</span></em><span> (in the figure above) are guaranteed to have more similar cut sizes. Moreover, our algorithm is faster than off-the-shelf methods, which comes by improving previous clustering techniques developed solely for simple graphs (by </span><a href="https://arxiv.org/abs/1704.01254" target="_blank" rel="noopener noreferrer"><span>Henzinger, Rao and Wang</span></a><span> in 2017) to work more broadly on weighted graphs. The stronger precision and running time guarantees achieved by the new construction ultimately lead to our nearly-linear time deterministic algorithm for the min-cut problem.</span></p>


    
</section>

                
                


<section>
    
    <div>
        <h2 data-block-key="16nlj">Acknowledgements</h2><p data-block-key="egg4e"><i>We are grateful to our co-authors Monika Henzinger, Jason Li, and Satish Rao. We would also like to extend special thanks to John Guilyard for creating the animation used in this post.</i></p>
    </div>


    
</section>

                

                


<section aria-label="List of footnotes">
  
</section>

                
<section>
    
</section>

            </div></div>
  </body>
</html>
