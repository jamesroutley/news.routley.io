<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://zed.dev/blog/debugger">Original</a>
    <h1>The Zed Debugger Is Here</h1>
    
    <div id="readability-page-1" class="page"><article><p>Over 2,000 developers asked, and we delivered.</p>
<p>Debugging in Zed is now a reality—and it&#39;s a big leap toward Zed 1.0.</p>
<h2 id="overview"><a href="#overview" aria-label="Copy heading link"><span><svg xmlns="http://www.w3.org/2000/svg" width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="4" x2="20" y1="9" y2="9"></line><line x1="4" x2="20" y1="15" y2="15"></line><line x1="10" x2="8" y1="3" y2="21"></line><line x1="16" x2="14" y1="3" y2="21"></line></svg></span><span>Overview</span></a></h2>
<p>We set out to build a debugger with three primary focuses:</p>
<ul>
<li>Fast: Spend less time context switching and more time debugging</li>
<li>Familiar: In line with Zed&#39;s design language and supports everything expected from a typical debugger flow</li>
<li>Configurable: You&#39;re able to customize the UI, keybindings, debug configurations and more</li>
</ul>
<p>Out of the box, Zed supports debugging popular languages including Rust, C/C++, JavaScript, Go, and Python.
With our extension system, Zed can support any debug adapter that implements the <a href="https://microsoft.github.io/debug-adapter-protocol/">Debug Adapter Protocol (DAP)</a>.</p>
<p>To simplify the setup process, we&#39;ve introduced locators, a system that translates build configurations into debug configurations. Meaning that you can write a build task once in <code>tasks.json</code> and reference it from <code>debug.json</code> — or, even better, rely on Zed&#39;s automatic configuration.</p>
<p>Zed automatically runs locators on built-in or language server-generated runnables, so in many cases you won&#39;t even need to write a debug configuration to get up and running.</p>
<p>We currently support locators for Cargo, Python, JavaScript, and Go, with more coming in the future.
For more information on configuring a debug session, <a href="https://zed.dev/docs/debugger">see our documentation</a>.</p>
<p>Once in a debug session, Zed makes it easy to inspect your program&#39;s state, such as threads, variables, breakpoints, the call stack, and more.</p>
<p><figure><video src="https://customer-snccc0j9v3kfzkif.cloudflarestream.com/fd34bd93b1ec8d7c5554daf0ffdb909e/downloads/default.mp4" width="3280" height="2160" poster="/img/debugger/zero-setup-poster.webp" controls=""></video><figcaption>Setting some breakpoints and running the test in a debug session.</figcaption></figure></p>
<p>The debugger panel is fully customizable too, just drag and rearrange tabs in whatever order you want; you can even move the debug panel around so it fits your workflow.</p>
<p>Zed also supports keyboard-driven debugging for users that prefer to keep their hands on the keyboard.
You can step through code, toggle breakpoints, and navigate a debug session without ever touching the mouse.</p>
<p><figure><video src="https://customer-snccc0j9v3kfzkif.cloudflarestream.com/642d476eeaab0423087c9c19aab53828/downloads/default.mp4" width="3280" height="2160" poster="/img/debugger/keyboard-poster.webp" controls=""></video><figcaption>Navigating through the Debugger surfaces using only the keyboard.</figcaption></figure></p>
<h2 id="a-special-thanks"><a href="#a-special-thanks" aria-label="Copy heading link"><span><svg xmlns="http://www.w3.org/2000/svg" width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="4" x2="20" y1="9" y2="9"></line><line x1="4" x2="20" y1="15" y2="15"></line><line x1="10" x2="8" y1="3" y2="21"></line><line x1="16" x2="14" y1="3" y2="21"></line></svg></span><span>A Special Thanks</span></a></h2>
<p>The debugger started as a community-led project with some impressive stats: <a href="https://github.com/zed-industries/zed/pull/13433/commits">8 months of development, 977 commits, and 25k+ lines of code</a>. The community built the core foundation that made today’s launch possible.</p>
<p>Special thanks to <a href="https://github.com/RemcoSmitsDev">Remco Smits</a> for driving a lot of the heavy lifting on this project—your contributions have been critical to getting us here.</p>
<h2 id="under-the-hood"><a href="#under-the-hood" aria-label="Copy heading link"><span><svg xmlns="http://www.w3.org/2000/svg" width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="4" x2="20" y1="9" y2="9"></line><line x1="4" x2="20" y1="15" y2="15"></line><line x1="10" x2="8" y1="3" y2="21"></line><line x1="16" x2="14" y1="3" y2="21"></line></svg></span><span>Under the Hood</span></a></h2>
<p>Zed&#39;s debugger supports debugging a variety of languages through the Debug Adapter Protocol.
But simply implementing the protocol wasn&#39;t enough—we needed an architecture that could scale to collaborative debugging, support extensions, and efficiently cache and manage responses from debug adapters.</p>
<p>To achieve this, we built a two-layer architecture: a data layer that communicates directly with the debug adapters, and a UI layer that fetches data from the data layer to render the interface.</p>
<figure data-rehype-pretty-code-figure=""><div><pre><code data-language="rust" data-theme="dark-plus light-plus"><span data-line=""><span>/// All functions are cheap to call, as they grab current state of the debug session and schedule refreshing on a background</span></span>
<span data-line=""><span>/// thread if that state is outdated.</span></span>
<span data-line=""><span>pub</span><span> fn</span><span> modules</span><span>(&amp;</span><span>mut</span><span> self</span><span>, </span><span>cx</span><span>: &amp;</span><span>mut</span><span> Context</span><span>&lt;</span><span>Self</span><span>&gt;) -&gt; &amp;[</span><span>Module</span><span>] {</span></span>
<span data-line=""><span>    /// Kick off a fresh request to a DAP for modules list if we don&#39;t have an up-to-date state.</span></span>
<span data-line=""><span>    /// This is a no-op in case we&#39;ve ran that request already. In case we did not, it kicks off a background task.</span></span>
<span data-line=""><span>    self</span><span>.</span><span>fetch</span><span>(</span></span>
<span data-line=""><span>        /// We cache request results based on it&#39;s arguments. `Modules` request does not take any arguments</span></span>
<span data-line=""><span>        dap_command</span><span>::</span><span>ModulesCommand</span><span>,</span></span>
<span data-line=""><span>        /// Callback invoked with the result of a request.</span></span>
<span data-line=""><span>        |</span><span>this</span><span>, </span><span>result</span><span>, </span><span>cx</span><span>| {</span></span>
<span data-line=""><span>            let</span><span> Some</span><span>(</span><span>result</span><span>) = </span><span>result</span><span>.</span><span>log_err</span><span>() </span><span>else</span><span> {</span></span>
<span data-line=""><span>                return</span><span>;</span></span>
<span data-line=""><span>            };</span></span>
<span data-line=""> </span>
<span data-line=""><span>            this</span><span>.modules = </span><span>result</span><span>;</span></span>
<span data-line=""><span>            cx</span><span>.</span><span>emit</span><span>(</span><span>SessionEvent</span><span>::</span><span>Modules</span><span>);</span></span>
<span data-line=""><span>            cx</span><span>.</span><span>notify</span><span>();</span></span>
<span data-line=""><span>        },</span></span>
<span data-line=""><span>        cx</span><span>,</span></span>
<span data-line=""><span>    );</span></span>
<span data-line=""> </span>
<span data-line=""><span>    /// Returns a current list of modules; it might be outdated at the time the new request is underway,</span></span>
<span data-line=""><span>    /// but once it is done, the return value of this function will reflect that.</span></span>
<span data-line=""><span>    &amp;</span><span>self</span><span>.modules</span></span>
<span data-line=""><span>}</span></span></code></pre></div></figure>
<figure data-rehype-pretty-code-figure=""><div><pre><code data-language="rust" data-theme="dark-plus light-plus"><span data-line=""><span>/// This function is called from the Module list render function in the UI layer whenever the data layer invalidates the module list state.</span></span>
<span data-line=""><span>fn</span><span> schedule_rebuild</span><span>(&amp;</span><span>mut</span><span> self</span><span>, </span><span>cx</span><span>: &amp;</span><span>mut</span><span> Context</span><span>&lt;</span><span>Self</span><span>&gt;) {</span></span>
<span data-line=""><span>    /// Setting the task drops any current work in progress that is out of date</span></span>
<span data-line=""><span>    self</span><span>._rebuild_task = </span><span>Some</span><span>(</span><span>cx</span><span>.</span><span>spawn</span><span>(</span><span>async</span><span> move</span><span> |</span><span>this</span><span>, </span><span>cx</span><span>| {</span></span>
<span data-line=""><span>        this</span><span>.</span><span>update</span><span>(</span><span>cx</span><span>, |</span><span>this</span><span>, </span><span>cx</span><span>| {</span></span>
<span data-line=""><span>            /// The UI layer queries the data layer for modules and clones the data</span></span>
<span data-line=""><span>            let</span><span> modules</span><span> = </span><span>this</span></span>
<span data-line=""><span>                .session</span></span>
<span data-line=""><span>                .</span><span>update</span><span>(</span><span>cx</span><span>, |</span><span>session</span><span>, </span><span>cx</span><span>| </span><span>session</span><span>.</span><span>modules</span><span>(</span><span>cx</span><span>).</span><span>to_owned</span><span>());</span></span>
<span data-line=""><span>            this</span><span>.entries = </span><span>modules</span><span>;</span></span>
<span data-line=""><span>            cx</span><span>.</span><span>notify</span><span>();</span></span>
<span data-line=""><span>        })</span></span>
<span data-line=""><span>        .</span><span>ok</span><span>();</span></span>
<span data-line=""><span>    }));</span></span>
<span data-line=""><span>}</span></span></code></pre></div></figure>
<p>This separation means the UI layer only requests what it needs, allowing the data layer to lazily fetch information and avoid unnecessary requests.
It also makes the data layer solely responsible for maintaining session state, caching responses, and invalidating stale data.
This architecture will make implementing collaborative debugging significantly easier, since the same UI code can be reused across multiplayer sessions—and we only send essential data across the wire, preserving bandwidth.</p>
<p>Supporting every debug adapter out of the box wasn&#39;t feasible—there are over <a href="https://microsoft.github.io/debug-adapter-protocol/implementors/adapters/">70 DAP implementations</a>, each with its own quirks.
To solve this, we <a href="https://zed.dev/docs/extensions/debugger-extensions">extended</a> Zed&#39;s extension API to support debugger integration.</p>
<figure data-rehype-pretty-code-figure=""><div><pre><code data-language="rust" data-theme="dark-plus light-plus"><span data-line=""><span>    /// Returns the debug adapter binary for the specified adapter name and configuration.</span></span>
<span data-line=""><span>    fn</span><span> get_dap_binary</span><span>(</span></span>
<span data-line=""><span>        &amp;</span><span>mut</span><span> self</span><span>,</span></span>
<span data-line=""><span>        _adapter_name</span><span>: </span><span>String</span><span>,</span></span>
<span data-line=""><span>        _config</span><span>: </span><span>DebugTaskDefinition</span><span>,</span></span>
<span data-line=""><span>        _user_provided_debug_adapter_path</span><span>: </span><span>Option</span><span>&lt;</span><span>String</span><span>&gt;,</span></span>
<span data-line=""><span>        _worktree</span><span>: &amp;</span><span>Worktree</span><span>,</span></span>
<span data-line=""><span>    ) -&gt; </span><span>Result</span><span>&lt;</span><span>DebugAdapterBinary</span><span>, </span><span>String</span><span>&gt; {</span></span>
<span data-line=""><span>        Err</span><span>(</span><span>&#34;`get_dap_binary` not implemented&#34;</span><span>.</span><span>to_string</span><span>())</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""> </span>
<span data-line=""><span>    /// Determines whether the specified adapter configuration should *launch* a new debuggee process</span></span>
<span data-line=""><span>    /// or *attach* to an existing one. This function should not perform any further validation (outside of determining the kind of a request).</span></span>
<span data-line=""><span>    /// This function should return an error when the kind cannot be determined (rather than fall back to a known default).</span></span>
<span data-line=""><span>    fn</span><span> dap_request_kind</span><span>(</span></span>
<span data-line=""><span>        &amp;</span><span>mut</span><span> self</span><span>,</span></span>
<span data-line=""><span>        _adapter_name</span><span>: </span><span>String</span><span>,</span></span>
<span data-line=""><span>        _config</span><span>: </span><span>serde_json</span><span>::</span><span>Value</span><span>,</span></span>
<span data-line=""><span>    ) -&gt; </span><span>Result</span><span>&lt;</span><span>StartDebuggingRequestArgumentsRequest</span><span>, </span><span>String</span><span>&gt; {</span></span>
<span data-line=""><span>        Err</span><span>(</span><span>&#34;`dap_request_kind` not implemented&#34;</span><span>.</span><span>to_string</span><span>())</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""><span>    /// Converts a high-level definition of a debug scenario (originating in a new session UI) to a &#34;low-level&#34; configuration suitable for a particular adapter.</span></span>
<span data-line=""><span>    ///</span></span>
<span data-line=""><span>    /// In layman&#39;s terms: given a program, list of arguments, current working directory and environment variables,</span></span>
<span data-line=""><span>    /// create a configuration that can be used to start a debug session.</span></span>
<span data-line=""><span>    fn</span><span> dap_config_to_scenario</span><span>(&amp;</span><span>mut</span><span> self</span><span>, </span><span>_config</span><span>: </span><span>DebugConfig</span><span>) -&gt; </span><span>Result</span><span>&lt;</span><span>DebugScenario</span><span>, </span><span>String</span><span>&gt; {</span></span>
<span data-line=""><span>        Err</span><span>(</span><span>&#34;`dap_config_to_scenario` not implemented&#34;</span><span>.</span><span>to_string</span><span>())</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""> </span>
<span data-line=""><span>    /// Locators are entities that convert a Zed task into a debug scenario.</span></span>
<span data-line=""><span>    ///</span></span>
<span data-line=""><span>    /// They can be provided even by extensions that don&#39;t provide a debug adapter.</span></span>
<span data-line=""><span>    /// For all tasks applicable to a given buffer, Zed will query all locators to find one that can turn the task into a debug scenario.</span></span>
<span data-line=""><span>    /// A converted debug scenario can include a build task (it shouldn&#39;t contain any configuration in such case); a build task result will later</span></span>
<span data-line=""><span>    /// be resolved with [`Extension::run_dap_locator`].</span></span>
<span data-line=""><span>    ///</span></span>
<span data-line=""><span>    /// To work through a real-world example, take a `cargo run` task and a hypothetical `cargo` locator:</span></span>
<span data-line=""><span>    /// 1. We may need to modify the task; in this case, it is problematic that `cargo run` spawns a binary. We should turn `cargo run` into a debug scenario with</span></span>
<span data-line=""><span>    /// `cargo build` task. This is the decision we make at `dap_locator_create_scenario` scope.</span></span>
<span data-line=""><span>    /// 2. Then, after the build task finishes, we will run `run_dap_locator` of the locator that produced the build task to find the program to be debugged. This function</span></span>
<span data-line=""><span>    /// should give us a debugger-agnostic configuration for launching a debug target (that we end up resolving with [`Extension::dap_config_to_scenario`]). It&#39;s almost as if the user</span></span>
<span data-line=""><span>    /// found the artifact path by themselves.</span></span>
<span data-line=""><span>    ///</span></span>
<span data-line=""><span>    /// Note that you&#39;re not obliged to use build tasks with locators. Specifically, it is sufficient to provide a debug configuration directly in the return value of</span></span>
<span data-line=""><span>    /// `dap_locator_create_scenario` if you&#39;re able to do that. Make sure to not fill out `build` field in that case, as that will prevent Zed from running second phase of resolution in such case.</span></span>
<span data-line=""><span>    /// This might be of particular relevance to interpreted languages.</span></span>
<span data-line=""><span>    fn</span><span> dap_locator_create_scenario</span><span>(</span></span>
<span data-line=""><span>        &amp;</span><span>mut</span><span> self</span><span>,</span></span>
<span data-line=""><span>        _locator_name</span><span>: </span><span>String</span><span>,</span></span>
<span data-line=""><span>        _build_task</span><span>: </span><span>TaskTemplate</span><span>,</span></span>
<span data-line=""><span>        _resolved_label</span><span>: </span><span>String</span><span>,</span></span>
<span data-line=""><span>        _debug_adapter_name</span><span>: </span><span>String</span><span>,</span></span>
<span data-line=""><span>    ) -&gt; </span><span>Option</span><span>&lt;</span><span>DebugScenario</span><span>&gt; {</span></span>
<span data-line=""><span>        None</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""> </span>
<span data-line=""><span>    /// Runs the second phase of locator resolution.</span></span>
<span data-line=""><span>    /// See [`Extension::dap_locator_create_scenario`] for a hefty comment on locators.</span></span>
<span data-line=""><span>    fn</span><span> run_dap_locator</span><span>(</span></span>
<span data-line=""><span>        &amp;</span><span>mut</span><span> self</span><span>,</span></span>
<span data-line=""><span>        _locator_name</span><span>: </span><span>String</span><span>,</span></span>
<span data-line=""><span>        _build_task</span><span>: </span><span>TaskTemplate</span><span>,</span></span>
<span data-line=""><span>    ) -&gt; </span><span>Result</span><span>&lt;</span><span>DebugRequest</span><span>, </span><span>String</span><span>&gt; {</span></span>
<span data-line=""><span>        Err</span><span>(</span><span>&#34;`run_dap_locator` not implemented&#34;</span><span>.</span><span>to_string</span><span>())</span></span>
<span data-line=""><span>    }</span></span></code></pre></div></figure>
<p>Adding DAP support via an extension involves defining a custom schema that integrates with our JSON server, implementing logic for downloading and launching the adapter, processing debug configuration to add sane default values, and integrating with locators for automatic configuration.
This design follows our approach to LSP extensions, giving extension authors full control to bring their own debug adapters to Zed with minimal friction.</p>
<p>We also wanted inline variable values to work out of the box.
Surprisingly, the <a href="https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocument_inlineValue">inline values request</a> is a part of the <a href="https://microsoft.github.io/language-server-protocol/">Language Server Protocol (LSP)</a> instead of the DAP.
Using the inline values approach would limit Zed to only showing inline values for DAPs which integrate with LSPs, which isn&#39;t many.
A naive workaround might be to use regular expressions to match variable names between the source code and debugger values, but that quickly breaks down when dealing with scopes, and comments.
Instead, we turned to <a href="https://tree-sitter.github.io/tree-sitter/">Tree-sitter</a>. After all Zed is built by the creators of Tree-sitter!</p>
<div><figure><img src="https://zed.dev/img/debugger/inline-values.webp" alt="An inline value example."/><figcaption>An inline value example.</figcaption></figure></div>
<p>Through Tree-sitter queries, we can accurately identify variables within the current execution scope, and easily support any language through <code>.scm</code> files without relying on an LSP server to be tightly integrated with a debug adapter.
At launch, inline values are supported for Python, Rust, and Go.
More languages will be supported in the coming weeks.</p>
<h2 id="whats-next"><a href="#whats-next" aria-label="Copy heading link"><span><svg xmlns="http://www.w3.org/2000/svg" width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="4" x2="20" y1="9" y2="9"></line><line x1="4" x2="20" y1="15" y2="15"></line><line x1="10" x2="8" y1="3" y2="21"></line><line x1="16" x2="14" y1="3" y2="21"></line></svg></span><span>What&#39;s Next</span></a></h2>
<p>When we set out to build the debugger, we wanted to make it seamless to use, out of the way, and in line with Zed&#39;s high standard of quality.
Now that we&#39;ve built a strong foundation that is compatible with any debug adapter, we&#39;re ready to explore and implement advanced features such as:</p>
<ul>
<li>New views: While we support all the fundamental views, we&#39;re planning on adding more advanced views such as a watch list, memory view, disassembly view, and a stack trace view</li>
<li>Automatic configuration: We&#39;re going to add support for more languages and build systems</li>
<li>Polish and more: reach out to us <a href="https://discord.com/invite/qSDQ8VWc7k">on Discord</a> or <a href="https://github.com/zed-industries/zed/issues">on Zed&#39;s GitHub repo</a> to let us know!</li>
</ul><hr/></article></div>
  </body>
</html>
