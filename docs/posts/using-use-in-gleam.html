<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://erikarow.land/notes/using-use-gleam">Original</a>
    <h1>Using use in Gleam</h1>
    
    <div id="readability-page-1" class="page"><section id="Using-use-in-Gleam">

<p>Recently, a colleague checked out Gleam’s <a href="https://tour.gleam.run">language tour</a>. They liked what they saw, but they were confused by Gleam’s <code>use</code> syntax. I like Gleam’s syntax a lot<label for="fn1"></label><span><span>I even wrote an article about <a href="https://www.pcmag.com/notes/gleam-syntax">Gleam’s syntax</a>.</span></span>, but I was also confused by <code>use</code> when I first encountered it. Here’s how I use <code>use</code>:<label for="fn2"></label><span><span>The <code>use</code> expression was introduced in <a href="https://gleam.run/news/v0.25-introducing-use-expressions/">Gleam v0.25</a>, as a more general replacement for the <code>try</code> keyword that preceded it.</span></span></p>
<section id="What-is-use-anyway">
<h2>What is <code>use</code> anyway?</h2>
<p><a href="https://tour.gleam.run/advanced-features/use/"><code>use</code></a> is a Gleam expression that allows me to write code that uses a callback<label for="fn3"></label><span><span>I’ve heard debate over whether a function argument to a higher order function is <em>always</em> a callback, but <a href="https://tour.gleam.run/advanced-features/use/">the language tour</a> for Gleam uses “callback function”, so I’ve used callback here.</span></span> function in an unindented style. Specifically, for functions whose last argument is a callback function. For example:</p>
<pre><code>import gleam/list

fn catify_without_use(
  strings: List(String)
) -&gt; List(String) {
  list.map(strings, fn(string) {
    string &lt;&gt; &#34; cat&#34;
  })
}
</code></pre>
<p>Here, I take a list of strings and append <code>&#34; cat&#34;</code> to the end of each of them. <a href="https://hexdocs.pm/gleam_stdlib/gleam/list.html#map"><code>list.map</code></a> takes a list as the first argument, and a callback function that takes a list element and returns a new list element. Here’s what that same function looks like with a <code>use</code> expression:</p>
<pre><code>import gleam/list

fn catify_with_use(
  strings: List(String)
) -&gt; List(String) {
  use string &lt;- list.map(strings)
  string &lt;&gt; &#34; cat&#34;
}
</code></pre>
<p>Here the <code>use</code> expression has done three things:</p>
<p>First, we’ve moved the arguments for the callback function to the left of the arrow. <code>fn(string)</code> becomes <code>use string &lt;-</code>.<label for="fn4"></label><span><span>The name <code>string</code> is an identifier chosen by me, it could just as easily be <code>use to_be_catted &lt;- ...</code></span></span></p>
<p>Second, we’ve changed <code>list.map</code> into a function that takes one less argument than it usually does. It’s now <code>list.map(strings)</code> as though it only took one argument. <code>list.map</code> still takes two arguments, but <code>use</code> has changed how we write that second argument.<label for="fn5"></label><span><span>This aspect of <code>use</code> makes it easier to see what the non callback arguments of a <code>use</code>d function are, since the callback is often the bulkiest part of the outer function call signature.</span></span><label for="fn6"></label><span><span>The <code>use</code> statement has exactly one identifier, because that’s how many arguments <code>list.map</code>’s callback function needs, see <a href="#A-note-on-use-arguments">this note</a> for more examples.</span></span></p>
<p>Third, the body of the callback function is now below the line of the <code>use</code> expression, indented in line with the <code>use</code> expression. Everything below the <code>use</code> expression until the end of <code>catify_with_use</code> becomes the body for the callback function.<label for="fn7"></label><span><span>That is, everything in the same <em>block</em> as the <code>use</code> expression. See <a href="#A-note-of-use-scope">this note</a> for more explanation.</span></span></p>
</section>
<section id="So-What">
<h2>So What?</h2>
<p>I’ve introduced some syntax sugar<label for="fn8"></label><span><span>A <code>use</code> expression is <a href="https://en.wikipedia.org/wiki/Syntactic_sugar">syntactic sugar</a> for a regular call and an anonymous function. During compilation, a <code>use</code> expression expands into the <code>fn(arg1, arg2, ...) { body() } </code> form. It’s explicitly to allow a different way of writing expressions.</span></span> that allows me to change how I write functions that take a callback function as their last argument. But in my example, it doesn’t help me much. In the example, it’s no longer clear that I’m writing a callback function, and I can’t do anything else after my <code>list.map</code> call, that doesn’t end up in the callback function. <code>list.map</code> <em>can</em> be used with a <code>use</code> expression, but it’s a poor choice over the default syntax in most cases.<label for="fn9"></label><span><span>I chose <code>list.map</code> <em>because</em> it’s a commonly used Gleam function that is a poor fit for <code>use</code>. <code>list.map</code> <em>is</em> one of my favorite functions though, and I’ve used it a lot in one of my other <a href="https://www.pcmag.com/notes/gleam-favorite-feature">Gleam articles</a>.</span></span></p>
<p>So what <em>is</em> <code>use</code> useful for?</p>
<section id="resultunwrap-and-early-returns">
<h3><code>result.unwrap</code> and early returns</h3>
<p>Gleam has no exceptions, all errors must be returned as values from a function.<label for="fn10"></label><span><span>Gleam also has no <code>return</code> keyword, the last expression in a block is returned as the value of that block. In a function, that’s the last thing in the function.</span></span> Specifically, Gleam uses the convention of <a href="https://tour.gleam.run/data-types/results/"><code>Result</code></a> to capture this information. Success looks like <code>Ok(value)</code> and failure looks like <code>Error(reason)</code>.</p>
<p>But what if I want to do something that might fail, and then continue to do something else in the same function.</p>
<pre><code>import gleam/result

fn outer() -&gt; Result(success, failure) {
  let id = parse_id() |&gt; result.unwrap(0)
  ... // More code that uses the id
}
</code></pre>
<p><code>parse_id</code> might fail, and therefore returns a <code>Result</code>. To use the inner value, we need to unwrap it somehow. On a successful parse, the wrapped value will look like <code>Ok(id)</code>, and this code uses <a href="https://hexdocs.pm/gleam_stdlib/gleam/result.html#unwrap"><code>result.unwrap</code></a> to pull out the <code>id</code> on an <code>Ok</code> case, or set the <code>id</code> to 0 in the <code>Error</code> case.</p>
<p>But <code>0</code> as an id is made up, and likely has no reliable meaning in our system. If we wanted to convey that the id failed to parse, we already had an <code>Error</code> that we could have returned directly.</p>
<p>Instead of using <code>result.unwrap</code>, we can use <a href="https://hexdocs.pm/gleam_stdlib/gleam/result.html#map"><code>result.map</code></a><label for="fn11"></label><span><span>Both <code>list.map</code> and <code>result.map</code> are named <code>map</code>, because they are examples of the higher order function <a href="https://en.wikipedia.org/wiki/Map_(higher-order_function%29">map</a> that applies a function to every element of collection.</span><span>In the case of <code>result.map</code> the “collection” is only the contents of the <code>Ok</code>, <code>Error</code>s are simply returned without invoking the callback function.</span></span>, which takes a <code>Result</code> and a callback function, where the callback function is only invoked when the <code>Result</code> is <code>Ok</code>. If the Result is an <code>Error</code> then it returns the <code>Error</code>.<label for="fn12"></label><span><span>This is how Gleam can do an “early” return, <code>result.map</code> only evaluates the callback function on success, so in the failure case the value of the <code>result.map</code> expression (and therefore the block) <em>is</em> the <code>Error</code>, and it doesn’t evaluate any more code.</span></span> The callback function gets the unwrapped, inner value as its one argument.</p>
<p>So we can do:</p>
<pre><code>import gleam/result

fn outer() -&gt; Result(success, failure) {
  result.map(parse_id(), fn(id) {
    ... // More code that uses the id
  })
}
</code></pre>
<p>The problem with invoking <code>result.map</code> this way, is that now all of the internals of <code>outer</code> are indented inside the callback function. Here, we can use a <code>use</code> expression to eliminate the extra indentation and focus our function on the success case:</p>
<pre><code>import gleam/result

fn outer() -&gt; Result(success, failure) {
  use id &lt;- result.map(parse_id())
  ... // More code that uses the id
}
</code></pre>
<p>We have still accomplished what we wanted to accomplish, which is that if <code>parse_id</code> fails, it returns early with the <code>Error</code>.<label for="fn13"></label><span><span>If you’re familiar with Rust’s <a href="https://doc.rust-lang.org/rust-by-example/std/result/question_mark.html"><code>?</code></a> operator, the expression <code>use id &lt;- result.map(parse_id())</code> is equivalent to Rust’s <code>let id = parse_id()?;</code></span></span> Now, we can focus our code<label for="fn14"></label><span><span>and limited attention</span></span> on the unwrapped <code>id</code> in the success case.</p>
</section>
<section id="Avoiding-boilerplate-with-resultmap">
<h3>Avoiding boilerplate with <code>result.map</code></h3>
<p>A <code>use</code> expression can also allow you to avoid a lot of boilerplate. For example, reading from a file is an operation that can fail, so it returns a <code>Result</code>. If I want to read lines from a file and then transform them, I can use <code>result.map</code>:</p>
<pre><code>import gleam/result
import gleam/list

fn transform_lines() {
  read_file_lines()
  |&gt; result.map(list.filter(...))
  |&gt; result.map(list.map(...))
  |&gt; result.map(list.sort(...))
  |&gt; result.map(something_else())
}
</code></pre>
<p>but because <code>result.map</code> returns a new <code>Result</code>, I have to continue chaining <code>result.map</code> calls until I’ve finished all of the transformations that I need.</p>
<p>A <code>use</code> expression allows us to gracefully handle the failure case, while removing the need for chained calls to <code>result.map</code>:</p>
<pre><code>import gleam/result
import gleam/list

fn transform_lines() {
  use lines &lt;- result.map(read_file_lines())

  lines
  |&gt; list.filter(...)
  |&gt; list.map(...)
  |&gt; list.sort(...)
  |&gt; something_else()
}
</code></pre>
<p>These two functions are equivalent, but the <code>use</code> expression allows us to focus on the transformations we care about.<label for="fn15"></label><span><span>Since <code>use</code> is only syntax sugar, all of the piped transformations <em>could</em> be written inside <code>result.map</code>’s callback function without a <code>use</code> expression:</span><span><code>fn(lines) { ... }</code>.</span></span></p>
</section>
<section id="Chaining-resulttry">
<h3>Chaining <code>result.try</code></h3>
<p><code>use</code> expressions are especially helpful when doing multiple <em>different</em> things that might fail. <a href="https://hexdocs.pm/gleam_stdlib/gleam/result.html#try"><code>result.try</code></a> takes a <code>Result</code> and callback function that itself returns a <code>Result</code>.<label for="fn16"></label><span><span><code>try</code> the first thing, then <code>try</code> a second thing if the first one succeeds.</span></span><label for="fn17"></label><span><span>I’ve heard this concept of chaining <code>result.try</code> calls together referred to as railroad-oriented design. If any operation fails, it switches to the <code>Error</code> “track” and returns that <code>Error</code>, otherwise it continues along the <code>Ok</code> track until the next operation that could fail, which has another “railroad switch”.</span></span> If the first argument is an <code>Error</code> it returns that error. Otherwise, it evaluates the callback function and returns whatever <code>Result</code> that callback function does. For example:</p>
<pre><code>import gleam/result

fn handle_form(form_data: RegistrationForm) {
  result.try(
    unique_username(form_data.username), 
    fn(username) {
      result.try(
        validate_password(form_data.password), 
        fn(password) {
          result.map(
            register_user(username, password), 
            fn(user) {
              &#34;welcome &#34; &lt;&gt; user.username &lt;&gt; &#34;!&#34;
            }
          )
        }
      )
    }
  )
}
</code></pre>
<p>Because each operation can separately fail, we can’t chain these together like I did in the <code>result.map</code> boilerplate example. This creates a cascade of indented callback functions that makes it hard to keep track of what’s going on and what the final return value in the success case is.<label for="fn18"></label><span><span>I’ver heard this referred to as callback hell.</span></span> With <code>use</code> expressions the meaning is much clearer:</p>
<pre><code>import gleam/result

fn handle_form(form_data: RegistrationForm) {
  use username &lt;- result.try(
    unique_username(form_data.username)
  )
  use password &lt;- result.try(
    validate_password(form_data.password)
  )
  use user &lt;- result.map(
    register_user(username, password)
  )
  
  &#34;welcome &#34; &lt;&gt; user.username &lt;&gt; &#34;!&#34;
}
</code></pre>
<p>Here it’s much easier to tell which operations we’re doing, and what the final return value is.<label for="fn19"></label><span><span>The last operation uses <code>result.map</code> because we’re finally returning something that can’t fail. It was the same in the first example, did you notice?</span></span></p>
</section>
<section id="Context-Management">
<h3>Context Management</h3>
<p>Another place where <code>use</code> expressions shine is with context management: functions that do setup, cleanup, or both. In Gleam, there’s no special way of handling context management, and so these functions use a callback function as an argument to wrap the user behavior they’re managing. For example, opening a database connection with <a href="https://hexdocs.pm/sqlight/"><code>sqlight</code></a>:</p>
<pre><code>import sqlight

fn get_data() {
  use conn &lt;- sqlight.with_connection(
    &#34;my_database.db&#34;
  )
  
  ... // query the database
}
</code></pre>
<p><a href="https://hexdocs.pm/sqlight/sqlight.html#with_connection"><code>sqlight.with_connection</code></a> will open a connection to the database, execute code, and then close the connection afterwards. The database connection is available as <code>conn</code> for the rest of the function. Technically, all of the user code is wrapped in a function:</p>
<pre><code>import sqlight

fn get_data() {
  sqlight.with_connection(
    &#34;my_database.db&#34;, 
     fn(conn) {
       ... // query the database
  })
}
</code></pre>
<p>but the <code>use</code> expression allows us to focus on the query we want to write, not on database management.</p>
<p>Another example of this kind of callback function wrapper comes from <a href="https://hexdocs.pm/wisp/"><code>wisp</code></a>, Gleam’s web framework:<label for="fn20"></label><span><span>This example comes from wisp’s <a href="https://github.com/gleam-wisp/wisp/blob/main/examples/07-logging/src/app/web.gleam">logging example</a>.</span></span></p>
<pre><code>import wisp

pub fn middleware(
  req: wisp.Request,
  handle_request: fn(wisp.Request) -&gt; wisp.Response,
) -&gt; wisp.Response {
  let req = wisp.method_override(req)
  use &lt;- wisp.log_request(req)
  use &lt;- wisp.rescue_crashes
  use req &lt;- wisp.handle_head(req)

  handle_request(req)
}
</code></pre>
<p>Here <a href="https://hexdocs.pm/wisp/wisp.html#log_request"><code>wisp.log_request</code></a> uses a callback function to allow logging to take place after a request has been handled, regardless of how the user of <code>wisp</code> chooses to do that handling.</p>
<p>The other <code>wisp</code> functions use a similar pattern allowing for customization to the application while still handling core web application concerns.</p>
<p>This is also an example of <code>use</code> expressions preventing cascading nested callbacks, without <code>use</code>:</p>
<pre><code>import wisp

pub fn middleware(
  req: wisp.Request,
  handle_request: fn(wisp.Request) -&gt; wisp.Response,
) -&gt; wisp.Response {
  let req = wisp.method_override(req)
  wisp.log_request(req, fn() {
    wisp.rescue_crashes(fn() {
      wisp.handle_head(req, fn(req) { 
        handle_request(req)
      })
    })
  })
}
</code></pre>
<p>Without <code>use</code>, how the request is being handled is obscured by the nested callback functions used to manage <code>wisp</code> request context.<label for="fn21"></label><span><span>This example has three of these context manager functions, but I’ve seen <code>wisp</code> applications with 8 or more. You <em>could</em> write that without <code>use</code>, but the <code>use</code> expressions allow the custom logic to remain readable.</span></span></p>
</section>
</section>
<section id="Takeaways">
<h2>Takeaways</h2>
<p>I’ve shared a number of examples where <code>use</code> expressions can add clarity to code, both with error handling and context management. As I showed in the <code>list.map</code> example, <code>use</code> expressions aren’t <em>always</em> helpful. The key is to use <code>use</code> when it allows you to highlight the happy path of your code, while handling concerns like failure and logging.<label for="fn22"></label><span><span>Thank you to <a href="https://ntietz.com">Nicole</a>, <a href="http://www.aristobit.com/blog/">Jeff Miller</a>, and <a href="https://github.com/markholmes">Mark</a>, as well as the Gleam discord for helping me write and edit this article.</span></span></p>
<p>A <code>use</code> expression is syntax sugar, and it’s always possible to write Gleam code without it, though maybe not as clearly.<label for="fn23"></label><span><span>Why <code>use</code>, specifically, as a keyword? <a href="https://github.com/gleam-lang/gleam/issues/1709">This issue</a> highlighted the need for a general syntax sugar. <a href="https://koka-lang.github.io/koka/doc/book.html#sec-with"><code>with</code> statements</a> in <a href="https://koka-lang.github.io/koka/doc/index.html">koka</a> were identified as a similar solution, but <code>with</code> was already a well-used special form <a href="https://hexdocs.pm/elixir/1.17.1/Kernel.SpecialForms.html#with/1">in Elixir</a>, and Gleam didn’t want to confuse BEAM programmers coming from Elixir.</span><span>After a lot of discussion <code>use</code> was chosen, in part because it’s the same length as <code>let</code> and it wasn’t already in use anywhere.</span></span></p>
</section>
<section id="Additional-Notes">
<h2>Additional Notes</h2>
<section id="A-note-of-use-scope">
<h3>A note of <code>use</code> scope</h3>
<p>Everything below the <code>use</code> expression comprises the body of the callback function <em>until the end of the current block</em>. By default, this will be the end of the function, but we can use <code>{}</code> to create a smaller block:<label for="fn24"></label><span><span>From the <a href="https://tour.gleam.run/advanced-features/use-sugar/">language tour</a>: “<code>use</code> is an expression like everything else in Gleam, so it can be placed within blocks.”</span></span></p>
<pre><code>import gleam/result

fn example() {
  let smaller_block = {
    use value &lt;- result.try(thing_that_might_fail())
    ... // do something with the value
  }

  no_longer_in_use_callback(smaller_block)
}
</code></pre>
<p>A example of this comes from the new <a href="https://hexdocs.pm/decode/"><code>decode</code></a> library:<label for="fn25"></label><span><span>This example comes from the <a href="https://hexdocs.pm/decode/0.2.0/index.html">README</a> for <code>decode</code>.</span></span></p>
<pre><code>let decoder =
  decode.into({
    use name &lt;- decode.parameter
    use email &lt;- decode.parameter
    use is_admin &lt;- decode.parameter
    User(name, email, is_admin)
  })
  |&gt; decode.field(&#34;name&#34;, decode.string)
  |&gt; decode.field(&#34;email&#34;, decode.string)
  |&gt; decode.field(&#34;is-admin&#34;, decode.bool)

decoder
|&gt; decode.from(data)
</code></pre>
<p>Here, <a href="https://hexdocs.pm/decode/decode.html#into"><code>decode.into</code></a> is using a <code>{}</code> block to succinctly create a decoder function using a combination of <code>use</code> and <a href="https://hexdocs.pm/decode/decode.html#parameter"><code>decode.parameter</code></a>.<label for="fn26"></label><span><span>This is a clever use of <code>use</code> as syntax sugar, since <code>decode.parameter</code> simply returns its argument. So the above block translates to:</span><span><code>fn(name) { fn(email) { fn(is_admin) { User(name, email, is_admin) }}}</code></span><span>Which is much harder to read, especially since the ordering of fields matters.</span></span></p>
</section>
<section id="A-note-on-use-arguments">
<h3>A note on <code>use</code> arguments</h3>
<p>The number of arguments in the <code>use</code> expression are exactly the same as the arguments required for the callback function being replaced.</p>
<section id="boolguard">
<h4><code>bool.guard</code></h4>
<p><a href="https://hexdocs.pm/gleam_stdlib/gleam/list.html#fold"><code>bool.guard</code></a> takes a function that requires no arguments:<label for="fn27"></label><span><span><code>fn() -&gt; a</code></span></span></p>
<pre><code>// without `use`
bool.guard(condition, &#34;early return&#34;, fn() {
  ...
  &#34;late return&#34;
})

// with `use`
use &lt;- bool.guard(condition, &#34;early return&#34;)
...
&#34;late return&#34;
</code></pre>
</section>
<section id="listfold">
<h4><code>list.fold</code></h4>
<p><a href="https://hexdocs.pm/gleam_stdlib/gleam/list.html#fold"><code>list.fold</code></a> takes a functions that requires <em>two</em> arguments.<label for="fn28"></label><span><span><code>fn(a, a) -&gt; a</code></span></span></p>
<pre><code>// without `use`
list.fold(numbers, 1, fn(accumulator, element) {
  accumulator * element
})

// with `use`
use accumulator, element &lt;- list.fold(numbers, 1)
accumulator * element
</code></pre>
</section>
</section>
</section>
</section></div>
  </body>
</html>
