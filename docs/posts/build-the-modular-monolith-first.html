<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.fearofoblivion.com/build-a-modular-monolith-first">Original</a>
    <h1>Build the Modular Monolith First</h1>
    
    <div id="readability-page-1" class="page"><div id="site-main" role="main">
    <div>

        <article>

            

            
            <figure>
            </figure>
            

            <section>
                <div>
                    <p>Even talking about building a monolith today, is a bit taboo. It is all about microservices at the moment, and has been for a few years. But they aren’t a silver bullet…</p>

<p>Sure, a bunch of the big players use them. But microservices also come with a lot of extra complexity that can make life a lot harder than it has to be. So maybe…just maybe…you should consider building a modular monolith to start of with, and then transition it to a services based architecture when you actually need it.</p>

<h2 id="the-pros-and-cons-of-microservices">The pros and cons of microservices</h2>

<p>Microservices do have benefit. I’m not saying that they don’t…</p>

<p>Personally, I think the biggest benefit with microservices, is the ability to distribute the development on multiple smaller teams, without having them trip over each other. But that’s an organizational problem, not a technical one. But they do also allow us to choose the best language, and architecture, for each service. And allow us to scale the services independently, making it possible to tailor the system resources based on the actual needs. Not to mention that they allow us to deploy our services independently, allowing for faster release cycles. At least if they are built right, and the system is architected properly.</p>

<p>However, they also come with quite a few disadvantages, or “complexities”. First of all, they are distributed across the network. And networks aren’t always as reliable as you would like. They are also much slower than executing code inside the same machine. Not to mention that they make logging and tracing a lot harder. And those last parts become <em>really</em> important when you start doing microservices. They are really the only way to debug issues, and when the system is distributed, well…your issues are also distributed. So the logging and tracing must be good enough to find out not only what has gone wrong, but also where…</p>

<p>Oh…and that part about being able to build and deploy your services independently. That <em>very</em> much depends on the interfaces you define. If they need to change, which they will over time, all changes need to be backwards compatible for that to work. And that my friend, can sometimes be harder than it sounds. At least if you haven’t planned for it upfront.</p>

<p>So, yes, there are definitely pros to using a microservice’s architecture. But there are also a lot of complexity that comes with it. To the point that the first law of distributed objects is “don’t distribute your objects”.</p>

<h2 id="the-pros-and-cons-of-monoliths">The pros and cons of monoliths</h2>

<p>Building a monolith today, might not sound that awesome. Over the years, the term monolith has turned into meaning a bunch of poorly built legacy code. But that isn’t necessarily what it means.</p>

<p>Yes, it can mean a monolithically coded, entangled ball of mud. But it can also mean a system that is deployed as a single unit. This doesn’t mean that the code that makes up the system has to be a ball of mud.</p>

<p>Yes, when you build a monolith, it quite easily becomes an entangled mess. But if you take some time, and put in some love, it doesn’t have to. And honestly, your microservice’s architecture can also quite easily become an entangled monolith if you aren’t careful.</p>

<p>Sure, monoliths don’t support independent scaling of individual pieces of the system, and it doesn’t allow for releasing parts of the system independently. But those are really the biggest downsides in my mind. We can still write “beautiful” code, and build a system that can be properly maintained and evolve over time. And maybe even evolve into a distributed system if needed.</p>

<p>On top of that, by not distributing the system across multiple services, we get rid of a lot of the complexity. Logging and tracing becomes a <em>lot</em> easier. There are no costly cross network calls. And we don’t have to be as scared of the calls failing, as most of them will now be inside the same machine.</p>

<p><strong>Note:</strong> Yes, by moving to a message based system, which most people believe is the right thing for microservices, we can get rid of some of the problems with failing networks and temporarily missing services. But it also means designing the system to be as asynchronous as possible, which can be a bit complicated in some cases.</p>

<p>However, I still love the idea of being able to split the system into individual pieces, possibly across multiple teams that can work somewhat independently to a large degree. I also <em>really</em> like the idea of being able to choose the architecture based on what the different parts of the system do. Some parts might just need a simple CRUD model with EF Core, while other parts might need a domain model, or event sourcing, or maybe an actor-based model. But these things don’t mean that we can’t still have a monolith. A well-designed, modular monolith. And if we do it right, we can even prepare the whole thing to be pulled apart into smaller services if we get to the point where we really need that.</p>

<h2 id="designing-a-modular-monolith">Designing a modular monolith</h2>

<p>When designing a modular monolith, it is all about breaking up the system into modules, and then combining those modules into a monolith for deployment.</p>

<p>It might be worth noting that finding what modules you will need, might not be as easy as you would think. They have to be as independent as possible. High-cohesion and low coupling is very important here, as all communication between the modules might end up being a cross network call, if you decide to break it into services in the future.</p>

<p>This means that all communication between modules need to well abstracted, and be either asynchronous, so that they can handle the call going across the network in the future, or use some form of messaging.</p>

<p><strong>Comment:</strong> You must also ignore that urge of being “DRY”. You will probably end up with duplicate code in some places. And that is ok! Rather some duplication of code in independent modules, than unnecessary dependencies between modules.</p>

<p>The next step is to figure out how to work on those pieces in a good way. Preferably in a way that allows you to work on, and in the future potentially deploy it, as individual pieces, while still being able to deploy it as a monolith at the moment.</p>

<p>In the architecture I’m about to describe, this is done by having each module be its own ASP.NET Core API project. Complete with an entry point that allows you to start and run the module on its own. This allows each module to have its own architecture, be tested individually using the MVC Testing framework and be worked on in isolation.</p>

<p>These modules are then pulled together, into a single API, in a separate ASP.NET Core API project, allowing us to deploy the whole system as a monolith. But it still allows us to pull out the individual modules into separate services, if needed in the future.</p>

<h2 id="the-sample">The sample</h2>

<p>To demonstrate the architecture, I will use <em>very</em> simple 2 modules. A user management module, and an order management module. The order management module depends on the user management module to fetch user information.</p>

<p><strong>Note:</strong> I have kept this sample extremely basic, as it is not the actual functionality that is interesting, but the set-up of the system. I have also not demonstrated message based interaction as this has very little impact on the system as such.</p>

<p>For this, I have created 3 ASP.NET Core Web projects and one class library</p>

<ul>
  <li>OrderManagement.Module - The project that contains the code for the order management module</li>
  <li>UserManagement.Module - The project that contains the code for the user management module</li>
  <li>Api - The “host” project that ties the modules together into a monolith for deployment</li>
  <li>UserManagement - A “shared” class library that contains the interface and DTO that enables interaction with the user management module</li>
</ul>

<p><strong>Comment:</strong> In the code on GitHub, there are also 3 test projects. One for each of the two modules, to show how you can test the modules individually, and one to test the host to see that it all works together as intended.</p>

<h3 id="the-usermanagementmodule-project">The UserManagement.Module project</h3>

<p>The user management module is quite simple. It contains a single controller called <code>UsersController</code>, which has a single <code>Get</code> method that allows you to get a user.</p>

<p>To fetch the actual user entity, it uses a simple repository interface called <code>IUsers</code>.</p>

<div><div><pre><code><span>[</span><span>Route</span><span>(</span><span>&#34;api/[controller]&#34;</span><span>)]</span>
<span>[</span><span>ApiController</span><span>]</span>
<span>public</span> <span>class</span> <span>UsersController</span> <span>:</span> <span>ControllerBase</span>
<span>{</span>
    <span>private</span> <span>readonly</span> <span>Data</span><span>.</span><span>IUsers</span> <span>users</span><span>;</span>

    <span>public</span> <span>UsersController</span><span>(</span><span>Data</span><span>.</span><span>IUsers</span> <span>users</span><span>)</span>
    <span>{</span>
        <span>this</span><span>.</span><span>users</span> <span>=</span> <span>users</span><span>;</span>
    <span>}</span>

    <span>[</span><span>HttpGet</span><span>(</span><span>&#34;{id}&#34;</span><span>)]</span>
    <span>public</span> <span>async</span> <span>Task</span><span>&lt;</span><span>ActionResult</span><span>&lt;</span><span>User</span><span>&gt;&gt;</span> <span>Get</span><span>(</span><span>int</span> <span>id</span><span>)</span>
    <span>{</span>
        <span>var</span> <span>user</span> <span>=</span> <span>await</span> <span>users</span><span>.</span><span>WithId</span><span>(</span><span>id</span><span>);</span>

        <span>return</span> <span>user</span> <span>==</span> <span>null</span> <span>?</span> <span>NotFound</span><span>()</span> <span>:</span> <span>user</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>The <code>IUsers</code> interface is also really simple</p>

<div><div><pre><code><span>public</span> <span>interface</span> <span>IUsers</span>
<span>{</span>
    <span>Task</span><span>&lt;</span><span>User</span><span>?&gt;</span> <span>WithId</span><span>(</span><span>int</span> <span>id</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<p>That’s it! The implementation of the interface is pretty unimportant for this post.</p>

<p>Not to mention that the implementation in the demo is <strong>really</strong> dumb. But it removes the need for a database etc.</p>

<p>The project also has a Program.cs file that looks a lot like a standard web application</p>

<div><div><pre><code><span>using</span> <span>FiftyNine.ModularMonolith.UserManagement.Module.Extensions</span><span>;</span>

<span>var</span> <span>builder</span> <span>=</span> <span>WebApplication</span><span>.</span><span>CreateBuilder</span><span>(</span><span>args</span><span>);</span>
<span>builder</span><span>.</span><span>Services</span><span>.</span><span>AddControllers</span><span>();</span>

<span>// Add the User Management module</span>
<span>builder</span><span>.</span><span>AddUserManagement</span><span>();</span>

<span>var</span> <span>app</span> <span>=</span> <span>builder</span><span>.</span><span>Build</span><span>();</span>

<span>if</span> <span>(!</span><span>app</span><span>.</span><span>Environment</span><span>.</span><span>IsDevelopment</span><span>())</span>
<span>{</span>
    <span>app</span><span>.</span><span>UseExceptionHandler</span><span>(</span><span>&#34;/Error&#34;</span><span>);</span>
    <span>app</span><span>.</span><span>UseHsts</span><span>();</span>
<span>}</span>

<span>app</span><span>.</span><span>UseHttpsRedirection</span><span>();</span>
<span>app</span><span>.</span><span>UseStaticFiles</span><span>();</span>
<span>app</span><span>.</span><span>UseRouting</span><span>();</span>
<span>app</span><span>.</span><span>UseAuthorization</span><span>();</span>
<span>app</span><span>.</span><span>UseEndpoints</span><span>(</span><span>endpoints</span> <span>=&gt;</span>
<span>{</span>
    <span>endpoints</span><span>.</span><span>MapControllers</span><span>();</span>
<span>});</span>
<span>app</span><span>.</span><span>Run</span><span>();</span>
</code></pre></div></div>

<p>The only real thing to note in here, is the call to <code>AddUserManagement()</code>, which is an extension method that adds all the stuff needed to run the API in the user management module.</p>

<p>However, it doesn’t “just” add the stuff needed to run it on its own. It also adds some MVC code that makes it integrate with the “host” as well. Like this</p>

<div><div><pre><code><span>public</span> <span>static</span> <span>WebApplicationBuilder</span> <span>AddUserManagement</span><span>(</span><span>this</span> <span>WebApplicationBuilder</span> <span>builder</span><span>)</span>
<span>{</span>
    <span>builder</span><span>.</span><span>Services</span><span>.</span><span>AddControllers</span><span>()</span>
                    <span>.</span><span>AddApplicationPart</span><span>(</span><span>typeof</span><span>(</span><span>WebApplicationBuilderExtensions</span><span>).</span><span>Assembly</span><span>);</span>

    <span>builder</span><span>.</span><span>Services</span><span>.</span><span>AddSingleton</span><span>&lt;</span><span>Users</span><span>&gt;()</span>
                    <span>.</span><span>AddSingleton</span><span>&lt;</span><span>Data</span><span>.</span><span>IUsers</span><span>&gt;(</span><span>x</span> <span>=&gt;</span> <span>x</span><span>.</span><span>GetRequiredService</span><span>&lt;</span><span>Users</span><span>&gt;())</span>
                    <span>.</span><span>AddSingleton</span><span>&lt;</span><span>IUsers</span><span>&gt;(</span><span>x</span> <span>=&gt;</span> <span>x</span><span>.</span><span>GetRequiredService</span><span>&lt;</span><span>Users</span><span>&gt;());</span>

    <span>return</span> <span>builder</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>As you can see, it starts off by telling MVC to include any controller defined in the current assembly.</p>

<p>When running it on its own, this has no effect at all. But when you run it “inside” the “host”, it will make sure that any controller in this project is registered in the host.</p>

<p>After that, it just adds the services needed for this module. In this case the <code>IUsers</code> service. However, as you can see, the <code>Users</code> service is registered using 2 different interfaces, both called <code>IUsers</code>, unfortunately.</p>

<p>The reason for the double <code>IUsers</code> interface, is that we need two ways to retrieve users. One that we can use internally in this module, and one that can be used from any external module that also needs to retrieve users. Which is what the <code>UserManagement</code> project, is all about.</p>

<p>But for now, all you need to know is that we need to register 2 interfaces. And in this case, the service that is registered in the <code>AddUserManagement()</code> method happens to implement both.</p>

<p><strong>Note:</strong> Yes, the naming is unfortunate. But I’m not sure how to name this any better. The module project becomes <code>UserManagement.Module</code>, and the “integration” project used to talk to this module is <code>UserManagement</code>. And inside them, we end up having the same interface name, because it is unfortunately the name that makes sense in both cases. If you have a better suggestion, please let me know!</p>

<h3 id="the-usermanagement-integration-project">The UserManagement “integration” project</h3>

<p>The <code>UserManagement</code> project contains the objects needed to interact with the user management module from external modules. In this case for example, the order module needs to retrieve users from the user module to add to the orders. For this to work, the <code>UserManagement</code> project contains an interface and a DTO. The interface is, as mentioned before, called <code>IUsers</code> and looks like this</p>

<div><div><pre><code><span>public</span> <span>interface</span> <span>IUsers</span>
<span>{</span>
    <span>Task</span><span>&lt;</span><span>User</span><span>?&gt;</span> <span>WithId</span><span>(</span><span>int</span> <span>id</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<p>As you can see, it is pretty much identical to the one inside the <code>UserManagement.Module</code> project. Which is, as mentioned, a bit unfortunate, as it causes some interesting namespacing issues inside the module. But the naming makes sense as such, so I have kept it. And most of the time, we only really care about the internal one anyway.</p>

<p>However, a big difference is that it returns a <code>User</code> DTO, defined in the <code>UserManagement</code> project, and not the <code>User</code> from the module project. Yes, it is a bit confusing when describing it, but it makes sense if you look at the code. I promise!</p>

<p>The actual implementation implements both interfaces</p>

<div><div><pre><code><span>public</span> <span>class</span> <span>Users</span> <span>:</span> <span>IUsers</span><span>,</span> <span>UserManagement</span><span>.</span><span>IUsers</span>
<span>{</span>
    <span>public</span> <span>Task</span><span>&lt;</span><span>User</span><span>?&gt;</span> <span>WithId</span><span>(</span><span>int</span> <span>id</span><span>)</span>
    <span>{</span>
        <span>// Implementation</span>
    <span>}</span>

    <span>Task</span><span>&lt;</span><span>UserManagement</span><span>.</span><span>User</span><span>?&gt;</span> <span>UserManagement</span><span>.</span><span>IUsers</span><span>.</span><span>WithId</span><span>(</span><span>int</span> <span>id</span><span>)</span>
        <span>=&gt;</span> <span>WithId</span><span>(</span><span>id</span><span>).</span><span>ContinueWith</span><span>(</span><span>x</span> <span>=&gt;</span> <span>x</span><span>.</span><span>Result</span><span>?.</span><span>ToUser</span><span>());</span>
<span>}</span>
</code></pre></div></div>

<p>As you can see, the “integration” implementation just uses the “internal” <code>WithId()</code> method to retrieve a <code>User</code> entity, and then uses a <code>ToUser()</code> extension method to map it to an <code>User</code> DTO instance from the “integration” project.</p>

<p>And since the <code>Users</code> class happens to implement both the interfaces, it is registered like this</p>

<div><div><pre><code><span>builder</span><span>.</span><span>Services</span><span>.</span><span>AddSingleton</span><span>&lt;</span><span>Users</span><span>&gt;()</span>
                <span>.</span><span>AddSingleton</span><span>&lt;</span><span>Data</span><span>.</span><span>IUsers</span><span>&gt;(</span><span>x</span> <span>=&gt;</span> <span>x</span><span>.</span><span>GetRequiredService</span><span>&lt;</span><span>Users</span><span>&gt;())</span>
                <span>.</span><span>AddSingleton</span><span>&lt;</span><span>IUsers</span><span>&gt;(</span><span>x</span> <span>=&gt;</span> <span>x</span><span>.</span><span>GetRequiredService</span><span>&lt;</span><span>Users</span><span>&gt;());</span>
</code></pre></div></div>

<p>The first <code>AddSingleton()</code> call is to register the service in the IoC container. And the second and third is to register that instance as both the <code>IUsers</code> interfaces.</p>

<h2 id="the-ordermanagementmodule-project">The OrderManagement.Module project</h2>

<p>The order management module is <em>very</em> similar to the user management module in this case. It contains a very simple controller that uses an internal <code>IOrders</code> interface to retrieve orders, as well as the <code>IUsers</code> interface from the user management “integration” project, to retrieve the user who placed the order.</p>

<div><div><pre><code><span>[</span><span>Route</span><span>(</span><span>&#34;api/[controller]&#34;</span><span>)]</span>
<span>[</span><span>ApiController</span><span>]</span>
<span>public</span> <span>class</span> <span>OrdersController</span> <span>:</span> <span>ControllerBase</span>
<span>{</span>
    <span>private</span> <span>readonly</span> <span>IOrders</span> <span>orders</span><span>;</span>
    <span>private</span> <span>readonly</span> <span>IUsers</span> <span>users</span><span>;</span>

    <span>public</span> <span>OrdersController</span><span>(</span><span>IOrders</span> <span>orders</span><span>,</span> <span>IUsers</span> <span>users</span><span>)</span>
    <span>{</span>
        <span>this</span><span>.</span><span>orders</span> <span>=</span> <span>orders</span><span>;</span>
        <span>this</span><span>.</span><span>users</span> <span>=</span> <span>users</span><span>;</span>
    <span>}</span>

    <span>[</span><span>HttpGet</span><span>(</span><span>&#34;{id}&#34;</span><span>)]</span>
    <span>public</span> <span>async</span> <span>Task</span><span>&lt;</span><span>ActionResult</span><span>&gt;</span> <span>Get</span><span>(</span><span>int</span> <span>id</span><span>)</span>
    <span>{</span>
        <span>var</span> <span>order</span> <span>=</span> <span>await</span> <span>orders</span><span>.</span><span>WithId</span><span>(</span><span>id</span><span>);</span>

        <span>if</span> <span>(</span><span>order</span> <span>==</span> <span>null</span><span>)</span>
            <span>return</span> <span>NotFound</span><span>();</span>

        <span>var</span> <span>user</span> <span>=</span> <span>await</span> <span>users</span><span>.</span><span>WithId</span><span>(</span><span>order</span><span>.</span><span>OrderedById</span><span>);</span>

        <span>return</span> <span>Ok</span><span>(</span><span>new</span> <span>{</span> 
            <span>Id</span> <span>=</span> <span>order</span><span>.</span><span>Id</span><span>,</span>
            <span>OrderDate</span> <span>=</span> <span>order</span><span>.</span><span>OrderDate</span><span>.</span><span>ToString</span><span>(</span><span>&#34;yyyy-MM-dd HH:mm&#34;</span><span>),</span>
            <span>OrderedBy</span> <span>=</span> <span>user</span> <span>==</span> <span>null</span> <span>?</span> <span>null</span> <span>:</span> <span>new</span>
            <span>{</span>
                <span>Id</span> <span>=</span> <span>user</span><span>.</span><span>Id</span><span>,</span>
                <span>FirstName</span> <span>=</span> <span>user</span><span>.</span><span>FirstName</span><span>,</span>
                <span>LastName</span> <span>=</span> <span>user</span><span>.</span><span>LastName</span>
            <span>}</span>
        <span>});</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>Yes, a bit more code, but a lot of it is just mapping the result to a dynamic object to be returned. Other than that, it is pretty simple. Retrieve the order, and then retrieve the user who placed the order by calling the <code>IUsers.WithId()</code> method.</p>

<p>In the monolithic version, the <code>IUsers</code> interface will be the implementation that is created in the <code>UserManagement.Module</code>. However, if we wanted to split out the user management module to a separate service, we could just replace the implementation with one that uses an <code>HttpClient</code> to retrieve the user instead. And none of the code in here would change.</p>

<p>But what implementation is used when this module is run on its own? Well, for this sample, I have simply added a <a href="https://fakeiteasy.github.io/">FakeItEasy</a> fake to do the job. It looks like this in the Program.cs</p>

<div><div><pre><code><span>var</span> <span>builder</span> <span>=</span> <span>WebApplication</span><span>.</span><span>CreateBuilder</span><span>(</span><span>args</span><span>);</span>

<span>builder</span><span>.</span><span>Services</span><span>.</span><span>AddControllers</span><span>();</span>

<span>// Add the Order Management module</span>
<span>builder</span><span>.</span><span>AddOrderManagement</span><span>();</span>

<span>var</span> <span>usersFake</span> <span>=</span> <span>A</span><span>.</span><span>Fake</span><span>&lt;</span><span>IUsers</span><span>&gt;();</span>
<span>A</span><span>.</span><span>CallTo</span><span>(()</span> <span>=&gt;</span> <span>usersFake</span><span>.</span><span>WithId</span><span>(</span><span>1</span><span>)).</span><span>Returns</span><span>(</span><span>User</span><span>.</span><span>Create</span><span>(</span><span>1</span><span>,</span> <span>&#34;John&#34;</span><span>,</span> <span>&#34;Doe&#34;</span><span>));</span>
<span>builder</span><span>.</span><span>Services</span><span>.</span><span>AddSingleton</span><span>(</span><span>usersFake</span><span>);</span>

<span>var</span> <span>app</span> <span>=</span> <span>builder</span><span>.</span><span>Build</span><span>();</span>

<span>if</span> <span>(!</span><span>app</span><span>.</span><span>Environment</span><span>.</span><span>IsDevelopment</span><span>())</span>
<span>{</span>
    <span>app</span><span>.</span><span>UseExceptionHandler</span><span>(</span><span>&#34;/Error&#34;</span><span>);</span>
    <span>app</span><span>.</span><span>UseHsts</span><span>();</span>
<span>}</span>

<span>app</span><span>.</span><span>UseHttpsRedirection</span><span>();</span>
<span>app</span><span>.</span><span>UseStaticFiles</span><span>();</span>
<span>app</span><span>.</span><span>UseRouting</span><span>();</span>
<span>app</span><span>.</span><span>UseAuthorization</span><span>();</span>
<span>app</span><span>.</span><span>UseEndpoints</span><span>(</span><span>endpoints</span> <span>=&gt;</span>
<span>{</span>
    <span>endpoints</span><span>.</span><span>MapControllers</span><span>();</span>
<span>});</span>
<span>app</span><span>.</span><span>Run</span><span>();</span>
</code></pre></div></div>

<p>As you can see, it calls an <code>AddOrderManagement()</code> extension method to add the required things to the system, just like the <code>UserManagement.Module</code> project. However, since it requires an implementation of the <code>IUsers</code> interface from the <code>UserManagement</code> project, which isn’t supplied in this case, I create a simple fake to take its place.</p>

<p><strong>Note:</strong> Yes, this implementation is probably overly simplified. However, you could obviously create something more elaborate here. The main thing is that you are not dependent on the other module to be able to work.</p>

<p>Remember, this <code>Program.cs</code> will only be called when running the project in isolation. When running it as part of the “host”, this code will never be executed, and the <code>IUsers</code> implementation will be the one registered in the <code>UserManagement.Module</code> project.</p>

<p>The <code>AddOrderManagement()</code> extension method looks like this</p>

<div><div><pre><code><span>public</span> <span>static</span> <span>WebApplicationBuilder</span> <span>AddOrderManagement</span><span>(</span><span>this</span> <span>WebApplicationBuilder</span> <span>builder</span><span>)</span>
<span>{</span>
    <span>builder</span><span>.</span><span>Services</span><span>.</span><span>AddControllers</span><span>()</span>
                    <span>.</span><span>AddApplicationPart</span><span>(</span><span>typeof</span><span>(</span><span>WebApplicationBuilderExtensions</span><span>).</span><span>Assembly</span><span>);</span>

    <span>builder</span><span>.</span><span>Services</span><span>.</span><span>AddSingleton</span><span>&lt;</span><span>IOrders</span><span>,</span> <span>Orders</span><span>&gt;();</span>

    <span>return</span> <span>builder</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>As you can see, it is pretty much an exact copy of the one from the user management module. Which makes sense, as all modules would need to register its own “application part”, and its own services. And since this demo is so ridiculously simple, the modules are almost identical.</p>

<p>The final part of the puzzle is to bring it all together in the monolith for deployment.</p>

<h3 id="the-api-project">The API project</h3>

<p>The API project is the thing that is responsible for this. It references all the required modules, and registers them during start up, using the same extension methods that the individual modules use.</p>

<p>Like this</p>

<div><div><pre><code><span>var</span> <span>builder</span> <span>=</span> <span>WebApplication</span><span>.</span><span>CreateBuilder</span><span>(</span><span>args</span><span>);</span>

<span>builder</span><span>.</span><span>Services</span><span>.</span><span>AddControllers</span><span>();</span>

<span>builder</span><span>.</span><span>AddOrdersModule</span><span>();</span>
<span>builder</span><span>.</span><span>AddUsersModule</span><span>();</span>

<span>var</span> <span>app</span> <span>=</span> <span>builder</span><span>.</span><span>Build</span><span>();</span>

<span>if</span> <span>(!</span><span>app</span><span>.</span><span>Environment</span><span>.</span><span>IsDevelopment</span><span>())</span>
<span>{</span>
    <span>app</span><span>.</span><span>UseExceptionHandler</span><span>(</span><span>&#34;/Error&#34;</span><span>);</span>
    <span>app</span><span>.</span><span>UseHsts</span><span>();</span>
<span>}</span>

<span>app</span><span>.</span><span>UseHttpsRedirection</span><span>();</span>
<span>app</span><span>.</span><span>UseStaticFiles</span><span>();</span>
<span>app</span><span>.</span><span>UseRouting</span><span>();</span>
<span>app</span><span>.</span><span>UseAuthorization</span><span>();</span>
<span>app</span><span>.</span><span>UseEndpoints</span><span>(</span><span>endpoints</span> <span>=&gt;</span>
<span>{</span>
    <span>endpoints</span><span>.</span><span>MapControllers</span><span>();</span>
<span>});</span>
<span>app</span><span>.</span><span>Run</span><span>();</span>
</code></pre></div></div>

<p>As you can see, all it really does, is asking the modules to register themselves. They will then add their own assemblies as application parts in MVC, making sure that they are discovered when calling <code>endpoints.MapControllers()</code>, and add whatever services they provide in the IoC container. Both internal services, and “integration” services that are to be used by other modules.</p>

<p>This allows the “host” to have a complete set of endpoints, made up of both local ones and those defined in the referenced modules.</p>

<p><strong>Note:</strong> This registration could obviously be automated using some attribute or interface, and some reflection if you have a lot of modules.</p>

<p>If the “host” needs to get some information from one of the modules, it can use the “integration” services in the same way as other modules do.</p>

<div><div><pre><code><span>public</span> <span>class</span> <span>HomeController</span> <span>:</span> <span>Controller</span>
<span>{</span>
    <span>private</span> <span>readonly</span> <span>IUsers</span> <span>users</span><span>;</span>

    <span>public</span> <span>HomeController</span><span>(</span><span>IUsers</span> <span>users</span><span>)</span>
    <span>{</span>
        <span>this</span><span>.</span><span>users</span> <span>=</span> <span>users</span><span>;</span>
    <span>}</span>

    <span>[</span><span>HttpGet</span><span>(</span><span>&#34;/&#34;</span><span>)]</span>
    <span>public</span> <span>async</span> <span>Task</span><span>&lt;</span><span>IActionResult</span><span>&gt;</span> <span>Index</span><span>()</span>
    <span>{</span>
        <span>var</span> <span>user</span> <span>=</span> <span>await</span> <span>users</span><span>.</span><span>WithId</span><span>(</span><span>1</span><span>);</span>

        <span>return</span> <span>user</span> <span>==</span> <span>null</span> <span>?</span> <span>NotFound</span><span>()</span> <span>:</span> <span>View</span><span>(</span><span>user</span><span>);</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>And if you ever need to break the system apart and put some of the modules in external services, you can do so as long as you create new implementations for the “integration” services.</p>

<p>And since every module is its own project, much like microservices, they can choose their own architecture and be developed and managed by separate teams.</p>

<p>Another nice benefit of this is that since the “integration” service interfaces are actual C# interfaces, any breaking change will show up when you try to compile the “host” project. Instead of at run time, which can easily happen when your interfaces are loosely defined as REST endpoints.</p>

<h2 id="conclusion">Conclusion</h2>

<p>I personally believe that this architecture is good starting point when building ASP.NET Core Web applications. It allows for a nice separation of concerns, just as with a microservice’s architecture. It allows the system to be migrated into a distributed system if needed. And it allows for different architecture styles inside each of the modules, without making the system design look disjointed and weird. But, compared to a microservice’s architecture, it doesn’t have the same complexity out of the gate. Instead, you have the simplicity of a monolith, but hopefully without the all too common spaghetti code that is caused by putting it all in one place. And when you really need it, you can split it into separate services.</p>

<p><strong>Comment:</strong> Being able to split it into separate services obviously depends on how you design your modules. If you for example make them too chatty, splitting them might cause a lot of latency. And if you put all the data in a single database, you still have a common dependency that has to be managed as such. And so on…</p>

<p>If you have any thoughts or questions. I’m on Twitter as usual. Just ping me at <a href="https://twitter.com/zerokoll">@ZeroKoll</a>!</p>

<p>And of course, the code is available on GitHub! Just go to <a href="https://github.com/chrisklug/asp-net-modular-monolith">https://github.com/chrisklug/asp-net-modular-monolith</a> to look at it!</p>

                </div>
            </section>

            <!-- Email subscribe form at the bottom of the page -->
            

            

            <!-- If you use Disqus comments, just uncomment this block.
            The only thing you need to change is "test-apkdzgmqhj" - which
            should be replaced with your own Disqus site-id. -->
            

        </article>

    </div>
</div></div>
  </body>
</html>
