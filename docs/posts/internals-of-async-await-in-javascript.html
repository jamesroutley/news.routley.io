<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://akashhamirwasia.com/blog/internals-of-async-await-in-javascript/">Original</a>
    <h1>Internals of async / await in JavaScript</h1>
    
    <div id="readability-page-1" class="page"><div><iframe src="https://www.youtube.com/embed/sB_P0m9ggTU" title="Internals of async / await in JavaScript YouTube video" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><p>If you have ever used JavaScript in the past, there is a high chance you have encountered the <a href="https://javascript.info/async-await">async / await</a> syntax. async / await makes it easy to define asynchronous logic in a synchronous way that our brains can comprehend better. Some of you JavaScript veterans might know that async / await is merely a <a href="https://en.wikipedia.org/wiki/Syntactic_sugar">syntactic sugar</a> over the existing <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promises API</a>. This means that we should be able to achieve the functionality of async / await in JavaScript without using <code>async</code> and <code>await</code> keywords albeit with some verbosity. This is exactly what I wanted to explore in this post.</p><h2 id="what-are-we-trying-to-achieve">What are we trying to achieve?</h2><p>Letâ€™s look at some boilerplate code to understand what we are trying to achieve.</p><pre><div><p>js</p><pre><div><p><span>2</span></p><p><span>  </span><span>return</span><span> </span><span>new</span><span> </span><span>Promise</span><span>(</span><span>(</span><span>resolve</span><span>,</span><span> reject</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span></span></p></div><div><p><span>4</span></p><p><span>      </span><span>resolve</span><span>(</span><span>&#39;Timeout resolved&#39;</span><span>)</span><span>;</span><span></span></p></div><div><p><span>12</span></p><p><span>  </span><span>const</span><span> result </span><span>=</span><span> </span><span>await</span><span> </span><span>wait</span><span>(</span><span>)</span><span>;</span><span></span></p></div><div><p><span>19</span></p><p><span></span><span>main</span><span>(</span><span>)</span><span>.</span><span>then</span><span>(</span><span>result</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span></span></p></div></pre></div></pre><p>The output of the above code:</p><pre></pre><p>Given the above code snippet and its respective output, can we re-write the <code>main()</code> function to <strong>not use</strong> <code>async</code> and <code>await</code> keywords, but still achieve the same output? Conditions being the following:</p><ul><li><strong>Cannot use Promise chaining within <code>main()</code></strong>. This makes the problem trivial and deviates from the original goal. Promise chaining might work in the contrived example above but it does not capture the complete essence of async / await and the problems it solves.</li><li><strong>Not changing any function signatures</strong>. Changing function signatures would require updating function calls as well which is complex in a large project with many interdependent functions. So try not to change any function signatures.</li></ul><p>Even though I have defined the conditions above, if you feel stuck and donâ€™t see a way forward without breaking the above conditions, do take the liberty to try that approach. Maybe breaking the condition will lead you to an approach that satisfies the above condition. No one is expected to come up with the right solution on their first try(even I didnâ€™t while preparing this ðŸ™‚).</p><h2 id="playground">Playground</h2><p>This blog post is hands-on and I strongly suggest you use the below playground to test out your ideas to implement something like async / await without using <code>async</code> and <code>await</code> keywords. The rest of the post has hints and solutions on how you can achieve this, but feel free to take a moment and try out some code whenever you get an idea to proceed.</p><p><span>Tip: You can play around with the code above!</span></p><h2 id="hint-1-looking-at-pausing-and-resuming-a-function-execution">Hint #1: Looking at pausing and resuming a function execution</h2><p>At a high level, what does async / await do? Well, it <strong>pauses</strong> the execution of the async function whenever it encounters an <code>await</code> statement. And <strong>resumes</strong> the execution when the awaited promise is resolved(or throws an error). A natural question to ask here would be how to go about pausing and resuming a functionâ€™s execution. Functions tend to execute to completion right?</p><p>Is there a native feature in JavaScript that mimics this behavior? Yes! Itâ€™s <strong>Generators</strong>.</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator">Generators</a> are a special type of function that can return multiple pieces of data <strong>during</strong> its execution. Traditional functions can return multiple data by using structures like Arrays and Objects, but Generators return data whenever the caller asks for it, and they <em>pause</em> execution until they are <em>asked to continue to generate</em> and return more data.</p><p>I wonâ€™t be diving deep into what Generators can do, please use the linked reference. Hereâ€™s a code snippet explaining the concept of Generators, try to follow the comments to understand what is happening.</p><pre><div><p>js</p><pre><div><p><span>4</span></p><p><span>  </span><span>const</span><span> message </span><span>=</span><span> </span><span>yield</span><span> </span><span>&#39;Result 1&#39;</span><span>;</span><span></span></p></div><div><p><span>19</span></p><p><span></span><span>console</span><span>.</span><span>log</span><span>(</span><span>it</span><span>.</span><span>next</span><span>(</span><span>)</span><span>)</span><span>;</span><span></span></p></div><div><p><span>29</span></p><p><span></span><span>console</span><span>.</span><span>log</span><span>(</span><span>it</span><span>.</span><span>next</span><span>(</span><span>&#39;Message Passing&#39;</span><span>)</span><span>)</span><span>;</span><span></span></p></div><div><p><span>40</span></p><p><span></span><span>console</span><span>.</span><span>log</span><span>(</span><span>it</span><span>.</span><span>next</span><span>(</span><span>)</span><span>)</span><span>;</span><span></span></p></div></pre></div></pre><p>Now that you know about Generator functions, I suggest you take a pause and go to the <a href="#playground">playground</a> to see if you can proceed from here.</p><h2 id="hint-2-when-to-resume-function-execution">Hint #2: When to resume function execution?</h2><p>Generators provide a way to pause and resume function execution. Recalling how async / await works, an async function is paused when it encounters <code>await</code> statement. So we can treat the async function as a generator function and place a <code>yield</code> statement near a promise so that it pauses at this step. Looks something like this:</p><pre></pre><p>But when should the generator function <strong>resume</strong> its execution? It should resume when the <strong>promise near the yield is resolved.</strong> How can the caller know about the promise when it is within the generator function? Is there a way to expose the promise to the caller so that they can attach a <code>.then()</code> callback to it which will call the <code>.next()</code> on the generator object to resume execution?</p><p>The answer to all the questions above is to simply <code>yield</code> the promise we want to wait for so that the caller can use this yielded promise and call <code>.next()</code> when it is resolved.</p><pre><div><p>js</p><pre><div><p><span>4</span></p><p><span>  </span><span>const</span><span> result </span><span>=</span><span> </span><span>yield</span><span> </span><span>wait</span><span>(</span><span>)</span><span>;</span><span></span></p></div><div><p><span>12</span></p><p><span>it</span><span>.</span><span>next</span><span>(</span><span>)</span><span>.</span><span>value</span><span>.</span><span>then</span><span>(</span><span>(</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span></span></p></div></pre></div></pre><h2 id="hint-3-making-promises-resolved-data-available-to-the-generator">Hint #3: Making promiseâ€™s resolved data available to the generator</h2><p>In the previous code snippet, we were able to successfully pause and resume function execution when the promise was resolved. But the generator function does not get the resolved data from the promise. <code>result</code> variable in the <code>main()</code> function is supposed to have <code>&#34;Timeout resolved&#34;</code> as we see when using async / await. But in our implementation, it does not get the data that the promise gives when it is resolved. Is there a way to pass the resolved data of the promise to the generator? After all, the caller has access to resolved data since the generator yields the promise. So can it pass this data back to the generator function when the caller calls <code>.next()</code> on the generator object? We have already come across this message-passing behavior above in this post ðŸ˜‰</p><p><code>.next()</code> function takes an argument that is made available to the last <code>yield</code> statement where the generator was paused. So to pass the promiseâ€™s resolved data, we simply call <code>.next()</code> with the resolved data from the promise.</p><pre><div><p>js</p><pre><div><p><span>4</span></p><p><span>  </span><span>const</span><span> result </span><span>=</span><span> </span><span>yield</span><span> </span><span>wait</span><span>(</span><span>)</span><span>;</span><span></span></p></div><div><p><span>12</span></p><p><span>it</span><span>.</span><span>next</span><span>(</span><span>)</span><span>.</span><span>value</span><span>.</span><span>then</span><span>(</span><span>resolvedData</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span></span></p></div><div><p><span>13</span></p><p><span>  it</span><span>.</span><span>next</span><span>(</span><span>resolvedData</span><span>)</span><span>;</span><span></span></p></div></pre></div></pre><p>With this change, we have a basic implementation of async / await without using <code>async</code> and <code>await</code> keywords. Notice the <code>main()</code> function and compare it with its async counterpart. They are shockingly similar, right? Instead of using <code>async function</code>, it is <code>function *</code>, and instead of <code>await</code>, it uses <code>yield</code> keyword. <strong>Thatâ€™s the beauty of this implementation!</strong></p><p>We have come quite far! If you were able to figure out some of these steps on your own then give yourself a pat on the back ðŸ’š</p><h2 id="hint-4-extending-it-to-work-with-multiple-yield-statements">Hint #4: Extending it to work with multiple <code>yield</code> statements</h2><p>The next step is to make our implementation work with an arbitrary number of <code>yield</code> statements. The above snippet only works with one <code>yield</code> as it calls <code>.next()</code> only after the first promise is resolved. But the generator can have an arbitrary number of promises being yielded. Can we write an abstraction that dynamically waits for any yielded promise to be resolved and then calls <code>.next()</code>?</p><p>This abstraction can be a function(say <code>run</code>) which takes in the generator function. What should <code>run</code> return? Again, compared with the async function counterpart, every async function implicitly returns a <code>Promise</code>, which gets resolved when the async function has completed execution. We can mimic this behavior by returning a <code>Promise</code> from the <code>run</code> function, and resolving it only when the generator has <strong>finished</strong> execution.</p><p>This is how the code looks like, your implementation might vary.</p><pre><div><p>js</p><pre><div><p><span>1</span></p><p><span>run</span><span>(</span><span>main</span><span>)</span><span>.</span><span>then</span><span>(</span><span>result</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span></span></p></div><div><p><span>5</span></p><p><span></span><span>function</span><span> </span><span>run</span><span>(</span><span>fn</span><span>,</span><span> </span><span>...</span><span>args</span><span>)</span><span> </span><span>{</span><span></span></p></div><div><p><span>6</span></p><p><span>  </span><span>const</span><span> it </span><span>=</span><span> </span><span>fn</span><span>(</span><span>...</span><span>args</span><span>)</span><span>;</span><span></span></p></div><div><p><span>8</span></p><p><span>  </span><span>return</span><span> </span><span>new</span><span> </span><span>Promise</span><span>(</span><span>(</span><span>resolve</span><span>,</span><span> reject</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span></span></p></div></pre></div></pre><h2 id="hint-5-calling-next-arbitrary-number-of-times">Hint #5: Calling <code>.next()</code> arbitrary number of times</h2><p>Now, letâ€™s focus on implementing the <code>run</code> function. It should call <code>.next()</code> on the generator object as long as promises are being yielded. Can we use loops to do this? Would it work as expected when we are using promises? Of course not, we canâ€™t use loops since it will keep calling <code>.next()</code> on the generator object without waiting for the promises being yielded to be resolved. Is there a better way to loop which does not have this problem?</p><p>Itâ€™s Recursion! By using Recursion, we can keep calling <code>.next()</code> on the generator object when yielded promises get resolved. Whatâ€™s the exit condition or the base case for the recursion to end? We want to stop when the generator ends. What does <code>.next()</code> return when the generator has reached the end? The <code>done</code> property on the returned object is set to <code>true</code>!</p><pre><div><p>js</p><pre><div><p><span>1</span></p><p><span>function</span><span> </span><span>run</span><span>(</span><span>fn</span><span>,</span><span> </span><span>...</span><span>args</span><span>)</span><span> </span><span>{</span><span></span></p></div><div><p><span>2</span></p><p><span>  </span><span>const</span><span> it </span><span>=</span><span> </span><span>fn</span><span>(</span><span>...</span><span>args</span><span>)</span><span>;</span><span></span></p></div><div><p><span>4</span></p><p><span>  </span><span>return</span><span> </span><span>new</span><span> </span><span>Promise</span><span>(</span><span>(</span><span>resolve</span><span>,</span><span> reject</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span></span></p></div><div><p><span>6</span></p><p><span>      </span><span>const</span><span> result </span><span>=</span><span> it</span><span>.</span><span>next</span><span>(</span><span>)</span><span>;</span><span></span></p></div><div><p><span>13</span></p><p><span>      result</span><span>.</span><span>value</span><span>.</span><span>then</span><span>(</span><span>resolvedValue</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span></span></p></div></pre></div></pre><p>We are not passing <code>resolvedValue</code> from the promise back to the generator. To do this, letâ€™s make the <code>step</code> function accept an argument. Also, notice how the promise returned by <code>run</code> is never resolved. Because we donâ€™t call the <code>resolve()</code> function anywhere! When should the promise be resolved? When the generator ends and thereâ€™s nothing else to execute. What should the promise resolve with? With whatever the generator function returns, as that matches the behavior of async functions.</p><pre><div><p>js</p><pre><div><p><span>1</span></p><p><span>function</span><span> </span><span>run</span><span>(</span><span>fn</span><span>,</span><span> </span><span>...</span><span>args</span><span>)</span><span> </span><span>{</span><span></span></p></div><div><p><span>2</span></p><p><span>  </span><span>const</span><span> it </span><span>=</span><span> </span><span>fn</span><span>(</span><span>...</span><span>args</span><span>)</span><span>;</span><span></span></p></div><div><p><span>4</span></p><p><span>  </span><span>return</span><span> </span><span>new</span><span> </span><span>Promise</span><span>(</span><span>(</span><span>resolve</span><span>,</span><span> reject</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span></span></p></div><div><p><span>5</span></p><p><span>    </span><span>function</span><span> </span><span>step</span><span>(</span><span>resolvedValue</span><span>)</span><span> </span><span>{</span><span></span></p></div><div><p><span>6</span></p><p><span>      </span><span>const</span><span> result </span><span>=</span><span> it</span><span>.</span><span>next</span><span>(</span><span>resolvedValue</span><span>)</span><span>;</span><span></span></p></div><div><p><span>10</span></p><p><span>        </span><span>resolve</span><span>(</span><span>result</span><span>.</span><span>value</span><span>)</span><span>;</span><span></span></p></div><div><p><span>14</span></p><p><span>      result</span><span>.</span><span>value</span><span>.</span><span>then</span><span>(</span><span>resolvedValue</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span></span></p></div></pre></div></pre><h2 id="there-you-have-it-async--await-without-async-and-await">There you have it â€“Â async / await without <code>async</code> and <code>await</code>!</h2><p>That completes the implementation of async / await without using <code>async</code> and <code>await</code> keywords. Async functions are represented as generator functions and instead of using <code>await</code> we use <code>yield</code> statements to wait for promises to get resolved. For a developer using our implementation, it still feels similar to async / await and it doesnâ€™t break the two conditions set at the beginning of this post.</p><p><span>Tip: You can play around with the code above!</span></p><p>This is exactly what transpilers like Babel do when converting async / await to older versions of JavaScript that did not have this feature natively. If you <a href="https://babeljs.io/repl#?browsers=defaults%2C%20not%20ie%2011%2C%20not%20ie_mob%2011&amp;build=&amp;builtIns=false&amp;corejs=false&amp;spec=false&amp;loose=false&amp;code_lz=IYZwngdgxgBAZgV2gFwJYHsLyQCgJQwDeAUDDMAO7CrIxU34DcxAvse4hE0A&amp;debug=false&amp;forceAllTransforms=false&amp;modules=false&amp;shippedProposals=false&amp;circleciRepo=&amp;evaluate=false&amp;fileSize=false&amp;timeTravel=false&amp;sourceType=module&amp;lineWrap=true&amp;presets=env%2Creact%2Cstage-2&amp;prettier=true&amp;targets=Node-7.3&amp;version=7.22.5&amp;externalPlugins=&amp;assumptions=%7B%7D">see the transpiled code</a>, you can draw a lot of parallels to our implementation above!</p><p><span>
      <span></span>
  <img alt="async / await transpiled code with Babel" title="async / await transpiled code with Babel" src="https://riskmusings.substack.com/static/f822928a9bc79f2afd4eacce53904b7e/e5166/babel.jpg" srcset="/static/f822928a9bc79f2afd4eacce53904b7e/f93b5/babel.jpg 300w,/static/f822928a9bc79f2afd4eacce53904b7e/b4294/babel.jpg 600w,/static/f822928a9bc79f2afd4eacce53904b7e/e5166/babel.jpg 1200w,/static/f822928a9bc79f2afd4eacce53904b7e/d9c39/babel.jpg 1800w,/static/f822928a9bc79f2afd4eacce53904b7e/df51d/babel.jpg 2400w,/static/f822928a9bc79f2afd4eacce53904b7e/ff72e/babel.jpg 2964w" sizes="(max-width: 1200px) 100vw, 1200px" loading="lazy" decoding="async"/>
    </span></p><h2 id="next-steps">Next steps</h2><p>The implementation above only covers the successful path of async / await. Our implementation does not handle error scenarios when a promise gets rejected. I would like to leave this as an exercise to the readers, as this is very similar to the success path, just the functions used are different. Do take a look at the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator#instance_methods">Generators API</a> to see if there is a way to propagate errors back to a generator similar to the <code>.next()</code> function to start with! If you do solve this, share it with me on Twitter, and donâ€™t forget to tag me â€“ <a href="https://twitter.com/blenderskool">@blenderskool</a>.</p><h2 id="conclusion">Conclusion</h2><p>When I first came across this implementation, I was awestruck by its beauty and simplicity. I was aware that async / await was a syntactic sugar, but did not know what it looked like under the hood. This post covered exactly this aspect of async / await, and how it ties in with Promises and Generators. I like to unravel abstractions from time to time to get a sense of how things work under the hood. And that is where I find interesting concepts to learn. I hope this post also motivated you to stay curious and learn things practically instead of just following a tutorial ðŸ™Œ.</p><p>If you found this helpful in any way and want to make my day, <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Fakashhamirwasia.com%2Fblog%2Finternals-of-async-await-in-javascript%2F&amp;via=blenderskool&amp;text=Check%20out%20this%20article%20on%20Internals%20of%20async%20%2F%20await%20in%20JavaScript" target="_blank" rel="noopener noreferrer">share it on Twitter</a>(Donâ€™t forget to tag me - <a href="https://twitter.com/blenderskool" target="_blank" rel="noopener noreferrer">@blenderskool</a>) ðŸ’š</p></div></div>
  </body>
</html>
