<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://eieio.games/nonsense/game-11-flappy-bird-finder/">Original</a>
    <h1>Flappy Dird: Flappy Bird implemented in MacOS Finder</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
    <p>I made a game. It’s called Flappy Dird. It’s Flappy Bird inside MacOS Finder.</p>

<div>
    <video playsinline="" controls="" muted="">
        <source src="/assets/images/flappy-dird/vidlong.mp4"/>
    </video>
    <p>ad placements start at $2,000</p>
</div>

<p>It has instructions, high score tracking, and marquee banner ads. You double-click to start a game and select any file in the window to jump. It runs at 4 frames a second and can’t run much faster. It occasionally drops inputs for reasons that you’ll understand if you finish this blog.</p>

<p>I’m going to lay out how Flappy Dird works and how it got there. <a href="https://github.com/nolenroyalty/flappy-dird">Head to the github repo</a> if you want to check out the code or play the game yourself.
<!-- excerpt-end --></p>


<p>The original idea for Flappy Dird came when I noticed that Finder had a “Date Last Opened” field for directories. I knew that the <code>atime</code> (file access time) field was controversial (updating an inode on every file read is expensive!) and wanted to learn how similar date last opened was. I found a few things:</p>
<ol>
  <li>The field only updated when opened via Finder; <code>cd</code>ing didn’t update the timestamp.</li>
  <li>The field <em>did</em> update if you made a symlink to a directory and then double-clicked that symlink within Finder.</li>
  <li>The field was accessible (with second-level precision) via <code>mdls</code></li>
</ol>

<p>This got me pretty excited! I like <a href="http://eieio.games/nonsense/implementing-wordle-in-the-firefox-address-bar/">putting games in weird places</a>, and I realized I could combine those three facts to make a button! The basic idea:</p>
<ul>
  <li>Create a directory <code>dir</code>. Inside <code>dir</code> make a directory <code>button</code> that symlinks back to <code>dir</code>.</li>
  <li>On startup, read the ‘last opened’ timestamp of <code>dir</code>.</li>
  <li>Repeatedly poll the ‘last opened’ timestamp and do something when it changes.</li>
  <li>Open <code>button</code> (inside <code>dir</code>) to change the ‘last opened’ timestamp without changing your location in Finder.</li>
</ul>

<p>I brainstormed some ideas for iconic games that could be played with a single button and came up with Flappy Bird<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" rel="footnote">1</a></sup> pretty quickly. And then I started trying to figure out how I’d draw something like Flappy Bird in Finder.</p>

<p>I spent a while looking into making Finder’s font monospaced (to make ascii art easier) and measuring out the width of various ascii characters in Finder’s default font before realizing that I had a much better option: <em>emojis have a constant width and if you put them in filenames Finder will display them.</em></p>

<p><img src="http://eieio.games/assets/images/flappy-dird/emoji-names.png"/>
</p>
<p>emojis in filenames. the future is here.</p>

<p>So I had a way to accept clicks and a way to draw to the screen - enough for a prototype!</p>

<div>
    
    
    <video playsinline="" controls="" poster=" /assets/images/flappy-dird/flap-novsync-firstframe.png ">
    
        <source src="/assets/images/flappy-dird/flap-novsync.mp4" type="video/mp4"/>
    </video>
    
    <p> vsync does NOT work for emojis in Finder </p>
    
</div>

<p>The basic idea:</p>
<ul>
  <li>Set up <code>dir</code> so that it has 15 subdirectories that symlink back to <code>dir</code></li>
  <li>Wait until the player double-clicks a directory to start the game. Treat all future double clicks as flaps.</li>
  <li>Write a function from <code>bird_y_pos,pipe_locations,frame</code> to a 15x15 grid of emojis</li>
  <li>Every frame, rename every symlink in the directory to a row from our emoji grid.</li>
  <li>Do some hackery to rename the symlinks in the right order so that we can tell Finder to sort by ‘Date Modified’</li>
</ul>

<p>This works! But it’s really slow and the screen tears a lot. We can do better.</p>



<p>The biggest problem with the prototype was that the screen tearing was <em>bad</em>. I figured I’d try to get Finder to “refresh” the file listing in case the tearing was because it wasn’t updating frequently enough. I stumbled upon <a href="https://apple.stackexchange.com/questions/49543/is-there-a-way-to-refresh-a-finder-file-listing">this Stack Exchange question</a> which pointed me to the AppleScript invocation <code>tell application &#34;Finder&#34; to tell front window to update every item</code>.</p>

<p>This line helped a little bit (I still saw tearing), but more importantly it planted the seed of using AppleScript. It also delighted me - I find AppleScript totally bizarre. <a href="https://twitter.com/slomobo/status/1707521508308816148">slomobo made this joke on twitter</a> and it feels pretty correct:</p>

<p><img src="http://eieio.games/assets/images/flappy-dird/tweet.png"/>
</p>
<p>this is an image; i have no idea how to embed a tweet anymore</p>

<p>I shopped the tearing problem around to some smart friends and a bunch suggested that I find a way to do double buffering. The basic idea of double buffering<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" rel="footnote">2</a></sup> is:</p>
<ul>
  <li>Have two buffers, buf1 and buf2</li>
  <li>On frame 1, display buf1 and start writing your data for frame 2 to buf2.</li>
  <li>On frame 2, display buf2 all at once! And start writing your data for frame 3 to buf1.</li>
  <li>Etc.</li>
</ul>

<p>Or something like that. The point is that you avoid the jitter that comes from writing some but not all of the pixels of a new frame to the screen.</p>

<p>We came up with several ideas for how to do double buffering. The big ones were:</p>
<ul>
  <li>Use symlinks to atomically swap out the directory’s contents. This doesn’t work because you can’t expand the contents of a symlinked dir in Finder (you have to double-click on it, at which point Finder dereferences the symlink and won’t follow renames).</li>
  <li>Make two directories whose inner symlinks <em>point at each other</em>. This would solve the tearing problem but would mean that we could only advance a frame when the user clicked, which wouldn’t really work for this game.</li>
  <li>Magically find a way to make Finder display a different directory without changing the “last opened” timestamp.</li>
</ul>

<p>The winning solution came from my friend <a href="https://jakelazaroff.com/">Jake</a>, who suggested that AppleScript might have a way to control Finder. And it does! <code>tell application &#34;Finder&#34; to set target of front Finder window to (&#34;PATH&#34; POSIX file)</code> does exactly what you’d think.</p>



<p>I hacked together a double buffering implementation and got the game running smoothly at 1 frame per second! But 1 FPS is slow. We can do better.</p>



<p>The game couldn’t reasonably run above 1 FPS because our input mechanism (double-clicking a file) only had second-level precision - if Flappy Dird ran at 2 FPS you’d only be able to jump every other frame. So I needed a new way to accept input. At this point I figured that AppleScript was all-powerful and could tell me whether an item in Finder was selected. I checked and it totally could! I reworked the code to accept <em>selection</em> of any file in the window as a jump.</p>

<p>This worked well and even matched the original game better than double clicking. The game logic became something like:</p>
<ul>
  <li>Wait until the user double clicks</li>
  <li>On every frame, shell out to AppleScript and check whether the user has selected a file in the current window.</li>
  <li>If they have (or if the “last opened” timestamp has changed), make the bird jump.</li>
  <li>Shell out to AppleScript to change the directory displayed in Finder.</li>
  <li>Sleep so that we maintain a constant framerate (e.g. if the above steps took 0.1 seconds and we want to run at 2 FPS, sleep for 0.4 seconds).</li>
</ul>



<p>This could…kind of get us to 2 FPS. Except for one problem: AppleScript startup was <em>really really slow.</em> Like 0.2 seconds slow. Which meant:</p>
<ul>
  <li>There was no hope of going above 2 FPS, since we had fixed AppleScript costs of 0.4 seconds.</li>
  <li>When running at 2 FPS there was only a tiny window where you could actually tap a file - if you tapped the file after we shelled out to AppleScript to check whether you had tapped a file we’d miss the tap!</li>
</ul>

<p>So the game wasn’t super playable at 2 FPS. And 2 FPS still felt too slow. We can do better.</p>



<p>I searched for ways to improve AppleScript’s startup speed. I compiled my AppleScripts (basically useless), entertained ideas like “writing an AppleScript RPC server,” and repeatedly googled “AppleScript improve startup speed” and “AppleScript preload script.”</p>

<p>Eventually I posted in the <a href="https://recurse.com">Recurse Center</a> chat and my friend <a href="https://iangrunert.com/">Ian</a> pitched a few suggestions. One of his first suggestions, <em>“can you write the whole game in AppleScript?”</em>, went a little far<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" rel="footnote">3</a></sup> - but he also pitched inverting the control flow between my Python and AppleScript code: I could move my main loop to AppleScript while still shelling out to Python for most of the game logic, allowing me to only pay AppleScript’s startup cost once.</p>

<p>I was reluctant to do this because adding any amount of control flow to an AppleScript seemed hard - but I was also pretty excited to get to say “I rewrote it in AppleScript for speed.” Coming up with a way to communicate back from Python to AppleScript was tricky but I landed on something like:</p>
<div><div><pre><code><span>do shell script</span><span> </span><span>&#34;game.py await&#34;</span><span>

</span><span>set</span><span> </span><span>shouldContinue</span><span> </span><span>to</span><span> </span><span>&#34;continue&#34;</span><span>
</span><span>repeat</span><span> </span><span>while</span><span> </span><span>shouldContinue</span><span> </span><span>=</span><span> </span><span>&#34;continue&#34;</span><span>
    </span><span>do shell script</span><span> </span><span>&#34;game.py start-frame&#34;</span><span>
    </span><span>tell</span><span> </span><span>application</span><span> </span><span>&#34;Finder&#34;</span><span> </span><span>to</span><span> </span><span>set</span><span> </span><span>sel</span><span> </span><span>to</span><span> </span><span>selection</span><span>
    </span><span>set</span><span> </span><span>curBuf</span><span> </span><span>to</span><span> </span><span>do shell script</span><span> </span><span>&#34;game.py tick &#34;</span><span> </span><span>&amp;</span><span> </span><span>(</span><span>number</span><span> </span><span>of</span><span> </span><span>sel</span><span>)</span><span>
    </span><span>tell</span><span> </span><span>application</span><span> </span><span>&#34;Finder&#34;</span><span> </span><span>to</span><span> </span><span>set</span><span> </span><span>target</span><span> </span><span>of</span><span> </span><span>front</span><span> </span><span>¬
</span><span>        </span><span>Finder</span><span> </span><span>window</span><span> </span><span>to</span><span> </span><span>(</span><span>&#34;DIR&#34;</span><span> </span><span>&amp;</span><span> </span><span>curBuf</span><span> </span><span>as</span><span> </span><span>POSIX</span><span> </span><span>file</span><span>)</span><span>
    </span><span>set</span><span> </span><span>shouldContinue</span><span> </span><span>to</span><span> </span><span>do shell script</span><span> </span><span>&#34;game.py sleep&#34;</span><span>
</span><span>end</span><span> </span><span>repeat</span><span>
</span></code></pre></div></div>

<p>That is:</p>
<ul>
  <li>Wait for the user to double-click to start the game (<code>await</code>)</li>
  <li>Record the time at which we’re starting the frame (<code>start-frame</code>)</li>
  <li>Pass the number of files selected to <code>tick</code> to render the frame.</li>
  <li>Save the response from <code>tick</code> (which is the name of the directory we just prepared) and navigate to it in Finder.</li>
  <li>Sleep to achieve our target framerate and emit <code>continue</code> if the player hasn’t lost yet (so that we keep looping).</li>
</ul>

<p>This worked really well! Ian pointed out to me that <code>start-frame</code> and <code>sleep</code> can be easily combined, and I ended up adding <em>another</em> layer of looping to add a way to restart after you die, but this is the basic structure that the game still uses.</p>



<p>The rest of the game was more straightforward - not necessarily easy, but it was just writing Python code to make the emojis on screen look right given some game state. A few notes about that process:</p>
<ul>
  <li>To store state during and between runs I made a little <code>state.json</code> file that I read/wrote every frame</li>
  <li>Adding text was hard because the text I chose was narrower than the emojis I was using. I used a lot of hardcoded spacing to make sure that things lined up correctly.</li>
  <li>Getting scrolling text across the top was particularly annoying because of the spacing - I ended up writing a function <code>read_n_ad_chars</code> to handle the guesswork around how many characters to show at a given time.</li>
  <li>I didn’t want to mess with relaying the working directory to AppleScript, so the script has a bunch of template variables that get swapped out by the <code>first-time-setup</code> Python invocation.</li>
  <li>AppleScript eats anything the python script outputs so I handled logging by appending to a file and catting it afterwards.</li>
  <li>You jump up an extra row if you tap on two successive frames, which I think makes the game feel a lot better.</li>
</ul>

<p>The hardest bit here was the scrolling banner text. It was particularly tricky because I couldn’t use a debugger since the script was being invoked via AppleScript<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" rel="footnote">4</a></sup>.</p>



<p>I loved making this. One thing I found particularly delightful was how simple writing the Python for this game was. The prototype was ~90 lines of code (it’s now ~550 lines but like a third of it is boilerplate or constants)! I did it all in vim! No clicking at all! It was great to work without an engine and keep all of my frame state in tiny 2D array. It was easy to keep the whole game in my head from start to finish (even as the control flow got wonkier). The experience made me excited to try making something bigger without an engine.</p>

<p>I presented an early iteration of Flappy Dird at <a href="https://recurse.com">Recurse Center</a> and spent a whole lot more time on it because of the response it got during that presentation. Thanks so much to the folks at Recurse for the encouragement, especially since I was presenting 2 weeks after I “never graduated” (Recurse’s word for finishing a batch). If being encouraged to make nonsense like this sounds fun to you you should consider <a href="https://www.recurse.com/apply">applying!</a> And a special thank you to <a href="https://twitter.com/kelin_online">Kelin</a> for telling me that the banner ads should be pulled by a little plane emoji.</p>

<p>4 frames a second and limited input is a pretty big constraint but I think that it’d be feasible to build some other games this way. Some <a href="https://mastodon.gamedev.place/@eieio/111190521120302217">folks on mastodon</a> suggested building Tetris in Finder and I think that’s hard but feasible. If you want to chat about this please <a href="http://eieio.games/whats-my-deal">get in touch!</a> I’ve been particularly enjoying <a href="https://cohost.org/eieio">cohost</a> for gamedev chatting but I’m all over.</p>

<p>I’m currently on vacation (I wrote this on a train from Busan to Seoul) but I’ll be back with some more nonsense in November :)</p>



  </div></div>
  </body>
</html>
