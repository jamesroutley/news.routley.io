<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://about.xethub.com/blog/nfs-fuse-why-we-built-nfs-server-rust">Original</a>
    <h1>NFS &gt; FUSE: Why We Built Our Own NFS Server in Rust</h1>
    
    <div id="readability-page-1" class="page"><div><div><h3>The Optimistic Case for FUSE</h3><p>I love files. Everything understands files. Every program knows how to read files and write files. Its a truly universal API. As such, I love the idea of FUSE. FUSE, or ‚ÄúFilesystem in Userspace‚Äù is a set of Linux interfaces that allow user-mode programs to define a filesystem.</p><figure class="w-richtext-align-center w-richtext-figure-type-image"><p><img src="https://uploads-ssl.webflow.com/6474aea6101c81b742144dd2/6503bb5f57ddf9f32163597d_first.png" loading="lazy" alt=""/></p></figure><p>This allows filesystem drivers to be built very easily <strong>without needing a kernel module.</strong> Fuse is the basis for a large number of filesystem clients, including NTFS and even remote ‚Äúfilesystems‚Äù like SFTP or Amazon S3. It can also be used to make strange filesystems which are not actually filesystems like <a href="https://about.xethub.com/a5ab0a3b55724d45b3e91d1d890b9a8b?pvs=25"><strong>WikipediaFS</strong></a> which allows one to edit wikipedia articles using their own text editor.</p><p>Here at XetHub, we wanted to build an easy way to access any version of any dataset from your laptop using the tools you have. It is <em>really</em> nice being able to directly browse an image dataset without having to go through S3 commands.</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://uploads-ssl.webflow.com/6474aea6101c81b742144dd2/6503bb6a47462c93017f9ec1_second.gif" loading="lazy" alt=""/></p><figcaption><em>What if you could interact with S3 this way?</em></figcaption></figure><p>The obvious solution to enabling this superpower was FUSE.</p><p>FUSE however, is an frustrating API to build against:</p><ul role="list"><li>there are 2 API classes to choose from ‚Äî a low-level API and a high-level API</li><li>there are 2 incompatible API versions (libfuse2 and libfuse3)</li><li>and lots of other smaller API changes over time (See FUSE_USE_VERSION).</li></ul><p>In addition, FUSE is <strong>unavailable natively on Mac and Windows</strong> and requires the user to install a 3rd party driver (<a href="https://osxfuse.github.io/">MacFuse</a>, <a href="https://github.com/billziss-gh/winfuse">WinFuse</a>). Each of these drivers may have subtle API incompatibilities.</p><h3>The Key Question</h3><p>Because of these issues, I asked myself the following questions.</p><blockquote>Is it possible to build a userspace filesystem interface that is truly cross-platform?</blockquote><p>To answer this question, I had to look back 20 years into computer science history to stumble into <strong>NFSv3.</strong></p><h3>NFS</h3><p>NFSv3 is 20 years old and is a network filesystem protocol that was so simple and so ubiquitous that nearly every operating system has a built-in implementation of it.</p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://uploads-ssl.webflow.com/6474aea6101c81b742144dd2/6503bb7357ddf9f321636887_third.png" loading="lazy" alt=""/></p><figcaption><em>From Wikipedia</em></figcaption></figure><p>The NFSv3 protocol is has a beautiful and simple set of design principles:</p><ol role="list"><li><strong>The server is completely stateless</strong>: This simplifies the implementation immensely.</li><li><strong>NFS Servers are dumb and NFS clients are smart</strong>: ¬†(explicitly stated in <a href="https://datatracker.ietf.org/doc/html/rfc1813#section-1.6">RFC 1813 ¬†Section 1.6 Par 4</a>). This is great because we only need to implement the server, and the very smart clients have already been implemented and hardened for &gt; 20 years.</li><li><strong>Simple Cache Consistency Rules</strong>: Server does not define cache policy. The client can be as smart as it wants. Instead, the protocol defines a mechanism for the server to notify the client when something changes. This implementation is simpler and more efficient than FUSE. In practice the FUSE daemon has to explicitly implement a lot caching itself. With NFS we can avoid all of that extra complexity.</li><li><strong>The NFS client knows its talking over a network</strong>: This means that the NFS Client and protocol has builtin timeout, retry and failure semantics we can immediately take advantage of. The stateless protocol makes this very easy. With FUSE, the timeout/failure behavior has to be implemented robustly everywhere in the daemon. It is remarkably easy to hang the daemon and all programs reading from the filesystem if you get stuck in an API call.</li><li><strong>Actually extremely good performance.</strong> On the nixes at least, localhost networking is as fast as pipes. I do not know about Windows but I will be surprised if its not very fast too.</li></ol><p>The summary is that implementing a user-mode filesystem using localhost NFS instead of FUSE makes it easier get performance and resiliency. We can take advantage of the existing caching support and 20+ years of robustness and hardening. We just need to implement the server protocol <em>once</em>.</p><p>So last year, while isolating myself from a COVID-19 infection, I implemented an NFSv3 server in Rust as an experiment. It turned out fantastically.</p><p>‚Äç</p><h3>How we use NFS at XetHub</h3><p>XetHub has the world‚Äôs first <strong>natively cross-platform, user-mode filesystem implementation,</strong> allowing you to mount arbitrarily large datasets on your machine without needing any kernel driver.</p><p>This enables you to, in just a few seconds, locally <a href="https://about.xethub.com/blog/comparing-code-llama-models-locally-macbook">mount ~660 GB of Llama 2 models</a> or write DuckDB queries to <a href="https://about.xethub.com/blog/version-control-machine-learning-workflow-pyxet-part-1">analyze large parquet files</a> and scan just the data you need.</p><p>All of this is currently supported on Linux, Mac and Windows Pro (unfortunately doesn‚Äôt work with Windows Home). Windows has some minor quirks in the experience but it generally works.</p><h3>Open Sourcing nfsserve</h3><p>We are open sourcing<strong> nfsserve</strong>, our Rust implementation for the NFS server, on <a href="https://github.com/xetdata/nfsserve">GitHub</a>. ¬†If you‚Äôre a ü¶Ä Rust-acean, you can install it using <a href="https://docs.rs/nfsserve/latest/nfsserve/">cargo</a> with the dependency <strong>nfsserve = &#34;0.10&#34;.</strong></p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://uploads-ssl.webflow.com/6474aea6101c81b742144dd2/6503bb9347462c93017fccc0_four.png" loading="lazy" alt=""/></p></figure><p>The documentation could definitely use more love and we‚Äôd happily accept PR‚Äôs for any improvements! You can find some ways to contribute here in the <a href="https://github.com/xetdata/nfsserve">readme</a>.</p><p>We plan to maintain this library moving forward because it‚Äôs an actual dependency to enabling our¬†xet mount implementation within <a href="https://github.com/xetdata/pyxet">PyXet</a> and <a href="https://github.com/xetdata/xet-core/tree/main/rust/gitxetcore/src/xetmnt">xet-core</a> (which we‚Äôve also open sourced).</p><p>Here are the initial capabilities we‚Äôve implemented:</p><ul role="list"><li>Reads are pretty performant</li><li>Writes work but still need a lot of optimizations</li></ul><p>I hope others will find this useful and help. There are a lot of low-hanging fruit for performance improvements and lots of refactoring to be done!</p><p>‚Äç</p></div></div></div>
  </body>
</html>
