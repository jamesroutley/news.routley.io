<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://juliaobjects.github.io/Accessors.jl/stable/lenses/">Original</a>
    <h1>Lenses in Julia</h1>
    
    <div id="readability-page-1" class="page"><article id="documenter-page"><p>Accessors.jl is build around so called lenses. A Lens allows to access or replace deeply nested parts of complicated objects.</p><pre><code>julia&gt; using Accessors

julia&gt; struct T;a;b; end

julia&gt; obj = T(&#34;AA&#34;, &#34;BB&#34;);

julia&gt; lens = @optic _.a
(@o _.a)

julia&gt; lens(obj)
&#34;AA&#34;

julia&gt; set(obj, lens, 2)
T(2, &#34;BB&#34;)

julia&gt; obj # the object was not mutated, instead an updated copy was created
T(&#34;AA&#34;, &#34;BB&#34;)

julia&gt; modify(lowercase, obj, lens)
T(&#34;aa&#34;, &#34;BB&#34;)</code></pre><p>Lenses can also be constructed directly and composed with <a href="https://juliaobjects.github.io/Accessors.jl/stable/docstrings/#CompositionsBase.opcompose"><code>opcompose</code></a>, <code>⨟</code>, or <code>∘</code> (note reverse order).</p><pre><code>julia&gt; using Accessors

julia&gt; v = (a = 1:3, )
(a = 1:3,)

julia&gt; l = opcompose(PropertyLens(:a), IndexLens(1))
(@o _.a[1])

julia&gt; l ≡ @optic _.a[1]   # equivalent to macro form
true

julia&gt; l(v)
1

julia&gt; set(v, l, 3)
(a = [3, 2, 3],)</code></pre><p>Implementing lenses is straight forward. They can be of any type and just need to implement the following interface:</p><ul><li><code>Accessors.set(obj, lens, val)</code></li><li><code>lens(obj)</code></li></ul><p>These must be pure functions, that satisfy the three lens laws:</p><pre><code>@assert lens(set(obj, lens, val)) ≅ val
        # You get what you set.
@assert set(obj, lens, lens(obj)) ≅ obj
        # Setting what was already there changes nothing.
@assert set(set(obj, lens, val1), lens, val2) ≅ set(obj, lens, val2)
        # The last set wins.</code></pre><p>Here <code>≅</code> is an appropriate notion of equality or an approximation of it. In most contexts this is simply <code>==</code>. But in some contexts it might be <code>===</code>, <code>≈</code>, <code>isequal</code> or something else instead. For instance <code>==</code> does not work in <code>Float64</code> context, because <code>get(set(obj, lens, NaN), lens) == NaN</code> can never hold. Instead <code>isequal</code> or <code>≅(x::Float64, y::Float64) = isequal(x,y) | x ≈ y</code> are possible alternatives.</p><p>See also <a href="https://juliaobjects.github.io/Accessors.jl/stable/docstrings/#Accessors.@optic-Tuple%7BAny%7D"><code>@optic</code></a>, <a href="https://juliaobjects.github.io/Accessors.jl/stable/docstrings/#Accessors.set"><code>set</code></a>, <a href="https://juliaobjects.github.io/Accessors.jl/stable/docstrings/#Accessors.modify"><code>modify</code></a>.</p></article></div>
  </body>
</html>
