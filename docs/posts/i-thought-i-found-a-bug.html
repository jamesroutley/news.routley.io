<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.os2museum.com/wp/i-thought-i-found-a-bug/">Original</a>
    <h1>I thought I found a bug</h1>
    
    <div id="readability-page-1" class="page"><div>
						
<p>So I was working on improving a DOS emulator, when I found that something seemingly trivial wasn’t working right when COMMAND.COM was asked to do the following:</p>



<pre>echo AB&gt; foo.txt</pre>



<p>Instead of ABCD, foo.txt contained ABBC.</p>



<p>I verified that yes, the right data was being passed to <code>fwrite()</code>, with the big caveat that what COMMAND.COM was doing wasn’t quite as straightforward as one might think:</p>



<ul>
<li>Open foo.txt</li>



<li>Write ‘AB’</li>



<li>Close foo.txt</li>



<li>Open foo.txt</li>



<li>Seek one byte backward from the end of the file</li>



<li>Read one byte</li>



<li>Write ‘CD’</li>



<li>Close foo.txt</li>
</ul>



<p>The reason for the complexity is that COMMAND.COM tries to deal with a case that the file ends with a Ctrl-Z character (which wasn’t the case for me), and if so, the Ctrl-Z needs to be deleted. Somehow the seek/read/write sequence was confusing things. But why?</p>



<p>Sitting down with a debugger, I could just see how the C run-time library (Open Watcom) could be fixed to avoid this problem. But I could not shake a nagging feeling that such a basic bug would have had to be discovered and fixed years ago.</p>



<p>So I proceeded to write a simple test program which I could try with other compilers. </p>



<p>To my great surprise, the venerable Microsoft Visual C++ 6.0 as well as IBM C/C++ 3.6 for Windows both only wrote ‘AB’ to the output file! The ‘CD’ never got written at all.</p>



<p>I added further logging to determine that in both cases, the second <code>fwrite()</code> reported that it wrote zero bytes. But that’s where things got a bit weird.</p>



<p>For the Microsoft runtime, <code>ferror()</code> was set but <code>errno</code> was zero. For the IBM runtime, <code>ferror()</code> was clear but <code>errno</code> was set to 41. Which according to IBM’s <code>errno.h</code> header means <code>EPUTANDGET</code>… and what does that error even mean?</p>



<p>At this point, I knew I was doing something wrong. But what? For once, stackoverflow <a href="https://stackoverflow.com/questions/23843587/fwrite-doesnt-work-directly-after-fread">actually had the right answer</a>! Amazing, that almost never happens.</p>



<h3>Why Oh Why?</h3>



<p>Of course one has to wonder… why is it like this? Having basic file I/O functions behave in this non-obvious way (either quietly failing or not writing the expected data, depending on the sequence of other function calls) is clearly sub-optimal.</p>



<p>It is obvious that it would not be rocket science for the C library to keep a record of whether the most recent I/O was a read or a write, and perform the appropriate flush or seek when switching directions. Indeed it’s clear that for example the IBM C runtime keeps track internally, and issues a very specific error when the correct sequencing is violated.</p>



<p>The closest thing to an answer that I’ve been able to find is that “it’s always been this way”.</p>



<p>With a caveat that “always” means since circa 1979, not always always. Looking at the 1978 edition of K&amp;R, it’s obvious why: The original K&amp;R library only supported the read (<code>&#34;r&#34;</code>), write (<code>&#34;w&#34;</code>), and append (<code>&#34;a&#34;</code>) modes for <code>fopen()</code>, with append being effectively a write. There was no update mode, (<code>&#34;r+&#34;</code>) and hence reads and writes could not be mixed at all! That is very likely part of the puzzle.</p>



<p>By the time the oldest preserved ANSI C draft rolled out, the behavior was already set in stone. Consider how little things have changed over the years:</p>



<blockquote>
<p>When a file is opened with update mode (<em><code>&#39;+&#39;</code></em> as the second or third character in the mode argument), both input and output may be performed on the associated stream.  However, output may not be directly followed by input without an intervening call to the <em><code>fflush</code></em> function or to a file positioning function (<em><code>fseek</code></em>, <em><code>fsetpos</code></em>, or <em><code>rewind</code></em>), and input may not be directly followed by output without an intervening call to a file positioning function, unless the input operation encounters end-of-file. Opening a file with update mode may open or create a binary stream in some implementations.</p>
<cite>ANSI X3J11 C draft, 1988</cite></blockquote>



<p>The ANSI C Rationale contains the following text:</p>



<blockquote>
<p>A change of input/output direction on an update file is only allowed following a</p>
</blockquote>



<p>The implication is that when the buffer I/O contains data, it’s not safe to switch read/write direction.</p>



<p>The published ANSI C89/ISO C90 is near identical to the draft Standard and does not bear repeating here. In C99, “may not” was replaced with “shall not” but little else changed:</p>



<blockquote>
<p>When a file is opened with update mode (<em><code>&#39;+&#39;</code></em> as the second or third character in the above list of mode argument values), both input and output may be performed on the associated stream. However, output shall not be directly followed by input without an intervening call to the <em><code>fflush</code></em> function or to a file positioning function (<em><code>fseek</code></em>, <em><code>fsetpos</code></em>, or <em><code>rewind</code></em>), and input shall not be directly followed by output without an intervening call to a file positioning function, unless the input operation encounters end-of-file. Opening (or creating) a text file with update mode may instead open (or create) a binary stream in some implementations.</p>
<cite>ISO C99, 1999</cite></blockquote>



<p>Fast forward another (almost) quarter century, and we have this:</p>



<blockquote>
<p>When a file is opened with update mode (’+’ as the second or third character in the previously described list of mode argument values), both input and output may be performed on the associated stream. However, output shall not be directly followed by input without an intervening call to the <em><code>fflush</code></em> function or to a file positioning function (<em><code>fseek</code></em>, <em><code>fsetpos</code></em>, or <em><code>rewind</code></em>), and input shall not be directly followed by output without an intervening call to a file positioning function, unless the input operation encounters end-of-file. Opening (or creating) a text file with update mode may instead open (or create) a binary stream in some implementations.</p>
<cite>ISO C23, 2024</cite></blockquote>



<p>As far as Standard C is concerned, this has provably not changed since 1988 until present.</p>



<p>But of course the ANSI X3J11 Committee did not invent the C library. It worked on the basis of earlier documents, namely the elusive 1984 <em>/usr/group Standard</em> in case of the library.</p>



<p>While I couldn’t find a copy of the <em>/usr/group Standard</em>, the /usr/group committee likewise didn’t create the C library but rather tried to standardize existing implementations. Which means that the answer might lie in old UNIX manuals.</p>



<p>Even System V is too new and we have to look further back. The <a href="http://www.bitsavers.org/pdf/att/unix/System_III/UNIX_Users_Manual_Release_3_Jun80.pdf#page=503&amp;zoom=auto,-170,7">AT&amp;T UNIX System III manual</a> contains the following text in the <code>fread</code> manual page:</p>



<blockquote>
<p>When a file is opened for update, both input and output may be done on</p>
<cite>AT&amp;T UNIX System III manual, 1980</cite></blockquote>



<p>Hmm, that text from 1980 is rather similar to what ended up in ANSI C89. Sure, there was no <code>fsetpos()</code> yet (an ANSI C invention), and the text is oddly missing any mention of <code>fflush()</code>, even though flushing almost certainly made it OK to switch from writing to reading even then.</p>



<p>But it’s obvious that the restriction on switching between reading and writing on C library streams has been there for a very, very long time.</p>



<p>7th Edition UNIX (1979), even in the updated documentation from 1983, <a href="https://bitsavers.org/pdf/att/unix/7th_Edition/UNIX_Programmers_Manual_Seventh_Edition_Vol_1_1983.pdf#page=277&amp;zoom=auto,-158,783">does not mention update mode for <code>fopen()</code></a> and hence does not offer any advice on switching read/write directions.</p>



<h3>Current Practice</h3>



<p>At least Linux (glibc) and FreeBSD allow free intermixing of reads and writes. The FreeBSD man page for <code>fopen()</code> states:</p>



<blockquote>
<p>Reads and writes may be intermixed on read/write streams in any order, and do not require an intermediate seek as in previous versions of <em>stdio</em>. This is not portable to other systems, however; ISO/IEC 9899:1990 (“ISO C90”) and IEEE Std 1003.1 (“POSIX.1”) both require that a file positioning function intervene between output and input, unless an input operation encounters end-of-file.</p>
</blockquote>



<p>In contrast, Microsoft’s library documentation (as of 2024) mirrors ISO C and states that flushing or seeking is required when changing read/write direction.</p>



<p>On the one hand, transparently handling the direction switching in the library is not outrageously difficult. On the other hand, doing so encourages programmers to write non-conforming C code which will fail in rather interesting ways on other implementations. As always, there are tradeoffs.</p>



<h3>Old Source</h3>



<p>Looking at historic source code proved quite interesting.</p>



<p>In 32V UNIX from 1979, <a href="https://www.tuhs.org/cgi-bin/utree.pl?file=32V/usr/src/libc/stdio/fopen.c">fopen</a> clearly opens files for either reading or writing, but not both (and any mode other than ‘w’ or ‘a’ means implicitly ‘r’!).</p>



<p>V6 UNIX from 1975 is too old to even have <code>fopen()</code>. System III from 1980 on the other hand supports update mode, and <a href="https://www.tuhs.org/cgi-bin/utree.pl?file=SysIII/usr/src/lib/libc/pdp11/stdio/endopen.c">opening streams</a> for update sets an explicit <code>_IORW</code> flag (and, as mentioned above, the System III documentation demands extra care when switching I/O direction).</p>



<p>Things get confusing with V7 UNIX from 1979. Although the documentation does not show any update mode option for <code>fopen()</code>, the <a href="https://www.tuhs.org/cgi-bin/utree.pl?file=V7/usr/src/libc/stdio/endopen.c">actual implementation</a> supports it. In fact the V7 code from 1979 is nearly identical to what was in System III a year later. Why? I don’t know.</p>



<p>And then there’s the <a href="https://www.tuhs.org/cgi-bin/utree.pl?file=2BSD/src/libNS/fopen.c">2BSD code</a>, again from 1979. While the BSD <code>fopen()</code> has no provision for indicating update mode with the ‘+’ character, it allows specifying open modes like <code>&#34;rw&#34;</code>, setting both the <code>_IOREAD</code> and <code>_IOWRT</code> flags. In fact the 2BSD <a href="https://www.tuhs.org/cgi-bin/utree.pl?file=2BSD/man/fopen.u">man page for fopen</a> explicitly lists <code>&#34;rw&#34;</code> and <code>&#34;ra&#34;</code> as supported open modes which allow both reading and writing, but there is nothing said about whether mixing <code>fread()</code> and <code>fwrite()</code> freely is allowed. There is also an <a href="https://www.tuhs.org/cgi-bin/utree.pl?file=2BSD/src/libNS/READ_ME">explanatory README file</a> with a note from November 1978 describing the change to allow mixed read and write access.</p>



<p>A 1977 paper by Dennis M. Ritchie <a href="http://roguelife.org/~fujita/COOKIES/HISTORY/V6/newgear.html"><em>A New Input-Output Package</em></a> is quite clear that when <code>fopen()</code> was first conceived, a stream would support either reading or writing, but not both. It is also clear that users found this too restrictive and by 1979, there were at least two different implementations (AT&amp;T and BSD) which allowed mixed read/write streams.</p>



<p>Notably in the BSD implementation, <code>fopen()</code> was modified to allow both reading and writing but <code>fread()</code> and <code>fwrite()</code> were not. It is not clear to me if the BSD code was robust enough to allow free mixing of reads and writes. The AT&amp;T documentation has always been clear that it’s not allowed.</p>



<p>And as far as Standard C and POSIX are concerned, that has not changed until today. To write portable code, it is necessary to take some action when changing read/write direction. A dummy call such as</p>



<pre>fseek( f, 0, SEEK_CUR );</pre>



<p>is entirely sufficient to get the stream into a state where switching between reading and writing is safe.</p>



<p>I suppose oddities like this just happen when you have nearly nearly 50 years of history behind you.</p>




											</div></div>
  </body>
</html>
