<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.divyendusingh.com/p/my-git-worktree-workflow-ft-worktrunk">Original</a>
    <h1>My git-worktree workflow ft. worktrunk, caddy</h1>
    
    <div id="readability-page-1" class="page"><div><div dir="auto"><p>Imagine you are building a large feature and find yourself deep in the context of a problem when you receive a request to solve a minor bug.</p><p>While you know how to fix this bug instantly, this is still a major context switch as you have to </p><ul><li><p>stash or temporarily commit your current changes</p></li><li><p>open a new branch</p></li><li><p>make the “minor” change</p></li><li><p>re-create the context</p></li></ul><p><a href="https://git-scm.com/docs/git-worktree" rel="">git-worktree</a><span> aims to address this issue by allowing you to work on multiple branches in the same repository.</span></p><p>However, it only provides the ability to quickly switch a branch without losing context. To have a working project where you can test changes end to end, you need some additional things like</p><ul><li><p>the environment variables, as the .env files are usually git ignored, they aren’t copied over in the git-worktree folder.</p></li><li><p>ability to run multiple versions of the codebase (if it is a web server for example)</p></li></ul><p><a href="https://nilan.substack.com/" rel="">A friend introduced</a><span> me to </span><a href="https://github.com/max-sixty/worktrunk" rel="">Worktrunk</a><span> the other day and I instantly loved it. Although, you can use git-worktree commands directly, worktrunk provides nicer APIs to achieve the same goals (copying .env files over, less typing). </span></p><p>It is a very thin wrapper, here is an example</p><pre><code>$ wt switch -c feat1
# gets translate to
# git worktree add -b feat ../repo.feat1 &amp;&amp; \
# cd ../repo.feat1</code></pre><p>See their docs for other examples but you get the idea. </p><p><span>This is very project specific so it would vary from project to project but usually my projects are powered by .env files. You can run a git hook using </span><a href="https://lefthook.dev/" rel="">lefthook</a><span> to generate an env file (by getting the relevant secrets from 1password or locally encrypted env files using </span><a href="https://dotenvx.com/" rel="">dotenvx</a><span> for example). In fact, this is what I was doing until a week or so ago before I ran into worktrunk.</span></p><p><span>Worktrunk has a concept of </span><code>.worktreeinclude</code><span> file which is a </span><code>.gitignore</code><span> style file for copying files over, here is what it looks like for a web project that I work on</span></p><pre><code>$ cat .worktreeinclude
.env
.dev.vars</code></pre><p>Just this file is not enough, you need a way to run worktrunk hooks on each work tree, here is my config currently</p><pre><code>$ cat .config/wt.toml
[post-create]
install = &#34;pnpm install&#34;
env = &#34;wt step copy-ignored&#34;</code></pre><p><span>So essentially, when a git-worktree is created via </span><code>worktrunk</code><span>, we install the dependencies and copy over the .env files (yes this works for nested files too). With this, you are already ready to work on the project and run a dev server (but what about port clashes?). </span></p><p><span>You are usually testing things end to end in a web server, I usually like to even run projects with https on a custom URL. To power this, I use </span><a href="https://caddyserver.com/" rel="">caddy</a><span>, here is what my </span><code>Caddyfile</code><span> usually looks. </span></p><pre><code>$ cat Caddyfile
trackfootball.localhost {
  reverse_proxy localhost:5173
}</code></pre><p>But when using multiple git-worktrees, I didn’t want to stop the dev server so port 5173 (vite default) gets free. I wanted to create a predictable pattern so the next available port is used (and is addressable with https). </p><p><span>Luckily, </span><code>vite</code><span> does half the job of running the dev server at 5174, if 5173 is not available but depending on your application, you might have to get a random port and run your application there.</span></p><p><span>For the other half, I use caddy, here is the modified </span><code>Caddyfile</code></p><pre><code>$ cat Caddyfile                                                                                                                                   
:80 {
        @default host trackfootball.localhost
        reverse_proxy @default localhost:5173

        @port header_regexp port Host ^trackfootball-([0-9]+)\.localhost
        reverse_proxy @port localhost:{re.port.1}
}</code></pre><p>Essentially, this allows the following scheme to work</p><pre><code>trackfootball.localhost - localhost:5173 # hardcoded, existing setup keeps on working
trackfootball-5173.localhost - localhost:5173 # port derived from url
trackfootball-5174.localhost - localhost:5174 # port derived from url

# and so on...</code></pre><p>You might have to change some other things in your application for this to work for you or change the URL scheme to suit your application needs.</p><p><span>For example, this setup doesn’t support ‘login’ locally for me because the cookie domain is set to </span><code>trackfootball.localhost</code><span>. But it doesn’t affect my local because of my local login setup (more on that later, I don’t really recommend that approach). I will likely change this to be </span><code>5173.trackfootball.localhost</code><span> in the future so the local login + cookies keep on working without any change. </span></p><p>Is it 2026 without a post mentioning AI agents? While this post is 100% handwritten, you might have noticed by now that the above setup would make AI agents have access to isolated environment with git-worktree easily (depending on what all do you need to / want to isolate in your environment). </p><p><span>In fact, worktrunk supports running any binary command with a single command while creating the git-worktree. Here is how you would boot the </span><a href="https://ampcode.com/" rel="">amp</a><span> in one go:</span></p><pre><code>$ wt switch -c -x amp feat1</code></pre><p><span>I mentioned earlier in the post about why I am not bothered with local login auth cookie not working in my current setup, the reason is that I use an env var </span><code>UNSAFE_AUTH_BYPASS_USER</code><span> to completely bypass authentication locally (it is something I am experimenting with and don’t recommend it yet). In code it roughly looks like this:</span></p><pre><code>    ctx.user = null

    if (
      env.UNSAFE_AUTH_BYPASS_USER === &#39;1&#39; ||
      env.UNSAFE_AUTH_BYPASS_USER === &#39;true&#39;
    ) {
      ctx.user = {
        id: 1,
        createdAt: new Date(&#39;2021-05-05T12:41:06.248Z&#39;),
        updatedAt: new Date(&#39;2025-06-14T19:07:43.754Z&#39;),
        email: &#39;john.doe@mail.com&#39;,
        firstName: &#39;John&#39;,
        lastName: &#39;Doe&#39;,
        locale: &#39;en&#39;,
        picture: &#39;https://i.pravatar.cc/150?u=jd@mail.com&#39;,
        auth0Sub: &#39;google-oauth2|104619003144932489723&#39;,
        emailVerified: true,
        type: &#39;ADMIN&#39;,
      } as User
      return
    }</code></pre><p>I did this to not having to deal with login flow and expiry locally (which I don’t recommend as it means that this code path will be less frequently hit). This also makes it easier for an AI agent to build features behind auth as it doesn’t have to struggle with authentication for each task.</p><p>This post described my current git-worktree setup, this hasn’t stood the test of time yet but I wanted to share it already to get feedback from the wider community. </p><p>Thanks for reading this and please share tips and your setup with me.</p></div></div></div>
  </body>
</html>
