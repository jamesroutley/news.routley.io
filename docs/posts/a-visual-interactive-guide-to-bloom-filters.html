<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://samwho.dev/bloom-filters/">Original</a>
    <h1>A Visual Interactive Guide to Bloom Filters</h1>
    
    <div id="readability-page-1" class="page"><div>
        

<p>Everyone has a set of tools they use to solve problems. Growing this set helps
you to solve ever more difficult problems.  In this post, I&#39;m going to teach you
about a tool you may not have heard of before. It&#39;s a niche tool that won&#39;t
apply to many problems, but when it does you&#39;ll find it invaluable.  It&#39;s called
a &#34;bloom filter.&#34;</p>
<s-dog name="sage" mode="warning">
  <b>Before you continue!</b> This post
  assumes you know what a <b>hash function</b> is, and if you don&#39;t it&#39;s going
  to be tricky to understand. Sam has written a post about hash functions, and
  recommendeds that you <b><a href="https://samwho.dev/hashing">read this first</a>.</b>
</s-dog>
<h3 id="what-bloom-filters-can-do"><a href="#what-bloom-filters-can-do">#</a>
What bloom filters can do</h3>
<p>Bloom filters are similar to the <code>Set</code> data structure. You can add items to
them, and check if an item is present. Here&#39;s what it might look like to use
a bloom filter in JavaScript, using a made-up <code>BloomFilter</code> class:</p>
<pre data-lang="javascript"><code data-lang="javascript"><span>let </span><span>bf </span><span>= new </span><span>BloomFilter</span><span>()</span><span>;
</span><span>bf</span><span>.</span><span>add</span><span>(</span><span>&#34;Ant&#34;</span><span>)</span><span>;
</span><span>bf</span><span>.</span><span>add</span><span>(</span><span>&#34;Rhino&#34;</span><span>)</span><span>;
</span><span>bf</span><span>.</span><span>contains</span><span>(</span><span>&#34;Ant&#34;</span><span>)</span><span>; </span><span>// true
</span><span>bf</span><span>.</span><span>contains</span><span>(</span><span>&#34;Rhino&#34;</span><span>)</span><span>; </span><span>// true
</span></code></pre>
<p>While this looks almost identical to a <code>Set</code>, there are some key differences.
Bloom filters are what&#39;s called a <strong>probabalistic data structure</strong>.  Where a
<code>Set</code> can give you a concrete &#34;yes&#34; or &#34;no&#34; answer when you call <code>contains</code>, a
bloom filter can&#39;t. Bloom filters can give definite &#34;no&#34;s, but they can&#39;t be
certain about &#34;yes.&#34;</p>
<p>In the example above, when we ask <code>bf</code> if it contains <code>&#34;Ant&#34;</code> and <code>&#34;Rhino&#34;</code>, the
<code>true</code> that it returns isn&#39;t a guarantee that they&#39;re present. We know that
they&#39;re present because we added them just a couple of lines before, but it
would be possible for this to happen:</p>
<pre data-lang="javascript"><code data-lang="javascript"><span>let </span><span>bf </span><span>= new </span><span>BloomFilter</span><span>()</span><span>;
</span><span>bf</span><span>.</span><span>add</span><span>(</span><span>&#34;Ant&#34;</span><span>)</span><span>;
</span><span>bf</span><span>.</span><span>add</span><span>(</span><span>&#34;Rhino&#34;</span><span>)</span><span>;
</span><span>bf</span><span>.</span><span>contains</span><span>(</span><span>&#34;Fox&#34;</span><span>)</span><span>; </span><span>// true
</span></code></pre>
<p>We&#39;ll demonstrate <em>why</em> over the course of this post. For now, we&#39;ll say that
when bloom filters return <code>true</code> it doesn&#39;t mean &#34;yes&#34;, it means &#34;maybe&#34;.  When
this happens and the item has never been added before, it&#39;s called a
<strong>false-positive</strong>.</p>
<p>The opposite, claiming &#34;no&#34; when the answer is &#34;yes,&#34; is called a
<strong>false-negative</strong>. A bloom filter will <em>never</em> give a false-negative, and this
is what makes them useful.</p>
<s-dog name="haskie" mode="confused">
  A data structure that lies to you?! How could that possibly be useful?
</s-dog>
<p>It&#39;s not strictly lying, it&#39;s just not giving you a definite answer. Let&#39;s look
at an example where we can use this property to our advantage.</p>
<h3 id="when-bloom-filters-are-useful"><a href="#when-bloom-filters-are-useful">#</a>
When bloom filters are useful</h3>
<p>Imagine you&#39;re building a web browser, and you want to protect users from
malicious links. You could build and maintain a list of all known malicious
links and check the list every time a user navigates the browser. If the link
they&#39;re trying to visit is in the list, you warn the user that they might be
about to visit a malicious website.</p>
<p>If we assume there are, say, 1,000,000 malicious links on the Internet, and each
link is 20 characters long, then the list of malicious links would be 20MB in
size. This isn&#39;t a huge amount of data, but it&#39;s not small either. If you have
lots of users and want to keep this list up to date, the bandwidth could add up.</p>
<p>However, if you&#39;re happy to accept being wrong 0.0001% of the time (1 in a
million), you could use a bloom filter which can store the same data in 3.59MB.
That&#39;s an 82% reduction in size, and all it costs you is showing the user an
incorrect warning 1 in every million links visited. If you wanted to take it
even further, and you were happy to accept being wrong 0.1% of the time (1 in
1000), the bloom filter would only be 1.8MB.</p>
<p>This use-case isn&#39;t hypothetical, either. Google Chrome used a bloom filter for
this exact purpose until 2012. If you were worried about showing a warning when
it wasn&#39;t needed, you could always make an API that has the full list of
malicious links in a database. When the bloom filter says &#34;maybe,&#34; you would
then make an API call to check the full list to be sure. No more spurious
warnings, and the bloom filter would save you from having to call the API for
every link visited.</p>
<h3 id="how-bloom-filters-work"><a href="#how-bloom-filters-work">#</a>
How bloom filters work</h3>
<p>At its core, a bloom filter is an array of <s-word>bits</s-word>. When it is
created, all of the <s-word>bits</s-word> are set to 0. We&#39;re going to represent
this as a grid of circles, with each circle representing 1 <s-word>bit</s-word>.
Our bloom filters in this post are all going to have 32 <s-word>bits</s-word> in
total.</p>

<s-dog name="sam" padding="false">
  I&#39;m experimenting with alternate colour palettes. If you find the above
  difficult to read, or just don&#39;t like it, please try <a href="https://samwho.dev/bloom-filters/?palette=tol#bf0">this one</a> and let me know what you think.
  <a href="https://samwho.dev/bloom-filters/?palette=wong#bf0">Click here</a> to go back to normal.
</s-dog>
<p>To add an item to the bloom filter, we&#39;re going to hash it with 3 different hash
functions, then use the 3 resulting values to set 3 <s-word>bits</s-word>. If
you&#39;re not familiar with hashing, I recommend reading <a href="https://samwho.dev/hashing">my post</a> about
it before continuing.</p>
<p>For this post I&#39;m choosing to use 3 of the
<a href="https://en.wikipedia.org/wiki/Secure_Hash_Algorithms">SHA</a> family of hash
functions: <s-word>sha1</s-word>, <s-word>sha256</s-word>, and
<s-word>sha512</s-word>. Here&#39;s what our bloom filter looks like if we add the
value &#34;foo&#34; to it:</p>
<s-bloom-filter id="bf1" hashes="sha1,sha256,sha512" bits="32">
  <add value="foo">
</add></s-bloom-filter>
<p>The <s-word>bits</s-word> in positions <s-bitlink bfid="bf1" highlight="true">15</s-bitlink>, <s-bitlink bfid="bf1">16</s-bitlink> and <s-bitlink bfid="bf1">27</s-bitlink> have been set. Other <s-word>bits</s-word>, e.g.
<s-bitlink bfid="bf1">1</s-bitlink> have not been set. You can hover or tap the
<s-word>bits</s-word> in this paragraph to highlight them in the visualisation.
We get to this state by taking the hash value of &#34;foo&#34; for each of our 3 hash
functions and modulo it by the number of <s-word>bits</s-word> in our bloom
filter. Modulo gets us the remainder when dividing by 32, so we get 27 with
<s-word>sha1</s-word>, 15 with <s-word>sha256</s-word> and 16 with
<s-word>sha512</s-word>. The table below shows what&#39;s happening, and you can try
inputting your own values to see what <s-word>bits</s-word> they would set if
added.</p>

<hash-values id="hv1" bfid="bf1" value="foo" mod="32"></hash-values>
<p>Go ahead and <s-word>add</s-word> a few of your own values to our bloom filter
below and see what happens. There&#39;s also a <s-word>check</s-word> button that
will tell you if a value is present within the bloom filter. A value is only
considered present if all of the <s-word>bits</s-word> checked are set. You can
start again by hitting the <s-word>clear</s-word> button.</p>

<p>You might occasionally notice that only 2, or even 1, <s-word>bits</s-word> get
set. This happens when 2 or more of our hash functions produce the same value,
or we attempt to set a <s-word>bit</s-word> that has already been set. Taking
that a bit further, have a think about the implications of a bloom filter that
has every <s-word>bit</s-word> set.</p>
<s-dog name="haskie" mode="concerned">
  Hmm... If every <s-word>bit</s-word> is set, then won&#39;t the bloom filter
  claim it contains every item you check? That&#39;s a false-positive every
  time!
</s-dog>
<p>Exactly right. A bloom filter with every <s-word>bit</s-word> set is equivalent
to a <code>Set</code> that always returns <code>true</code> for <code>contains</code>. It will claim to contain
everything you ask it about, even if that thing was never added.</p>
<h2 id="false-positive-rates"><a href="#false-positive-rates">#</a>
False-positive rates</h2>
<p>The rate of false-positives in our bloom filter will grow as the percentage of
set <s-word>bits</s-word> increases. Drag the slider below the graph to see how
the false-positive rate changes as the number of set <s-word>bits</s-word>
increases.</p>
<s-graph id="graph1" drawupto="0">
  <axes>
    <x tics="0.2" ticformat="(tic * 100).toFixed(0) + &#39;%&#39;" label="Bits set" max="1">
    <y tics="0.2" ticformat="(tic * 100).toFixed(0) + &#39;%&#39;" label="Chance of false-positive" max="1">
  </y></x></axes>
  <lines>
    <line y="Math.pow(x, 3)">
  </line></lines>
</s-graph>
<s-slider value="0" min="0" max="1" step="any" onchange="
    document.getElementById(&#39;graph1&#39;).setAttribute(&#39;drawupto&#39;, e.target.value)
  ">
</s-slider>
<p>It grows slowly at first, but as we get closer to having all
<s-word>bits</s-word> set the rate increases. This is because we calculate the
false-positive rate as <code>x^3</code>, where <code>x</code> is the percentage of set
<s-word>bits</s-word> and <code>3</code> is the number of hash functions used. To give an
example of why we calculate it with this formula, imagine we have a bloom filter
with half of its bits set, <code>x = 0.5</code>.  If we assume that our hash function has
an equal chance of setting any of the bits, then the chance that all 3 hash
functions set a bit that is already set is <code>0.5 * 0.5 * 0.5</code>, or <code>x^3</code>.</p>
<p>Let&#39;s have a look at the false-positive rate of bloom filters that use different
numbers of hash functions.</p>
<s-graph id="graph2" drawupto="0">
  <legend position="top-left">
  <axes>
    <x tics="0.2" ticformat="(tic * 100).toFixed(0) + &#39;%&#39;" label="Bits set" max="1">
    <y tics="0.2" ticformat="(tic * 100).toFixed(0) + &#39;%&#39;" label="Chance of false-positive" max="1">
  </y></x></axes>
  <lines>
    <line y="Math.pow(x, 1)" label="k=1">
    <line y="Math.pow(x, 2)" label="k=2">
    <line y="Math.pow(x, 3)" label="k=3">
    <line y="Math.pow(x, 4)" label="k=4">
    <line y="Math.pow(x, 5)" label="k=5">
  </line></line></line></line></line></lines>
</legend></s-graph>
<s-slider value="0" min="0" max="1" step="any" onchange="
    document.getElementById(&#39;graph2&#39;).setAttribute(&#39;drawupto&#39;, e.target.value)
  ">
</s-slider>
<s-dog name="haskie">
  It looks like more hash functions we use, the better our false-positive rate
  is.  Doesn&#39;t that mean we should always use lots of hash functions? Why don&#39;t
  we use, like, 100?
</s-dog>
<p>The problem that using lots of hash functions introduces is that it makes the
bloom filter fill up faster. The more hash functions you use, the more
<s-word>bits</s-word> get set for each item you add. There&#39;s also the cost of
hashing itself.  Hash functions aren&#39;t free, and while the hash functions you&#39;d
use in a bloom filter try to be as fast as possible, it&#39;s still more expensive
to run 100 of them than it is to run 3.</p>
<p>It&#39;s possible to calculate how full a bloom filter will be after inserting a
number of items, based on the number of hash functions used. The graph below
assumes a bloom filter with 1000 <s-word>bits</s-word>.</p>
<s-graph id="graph3" drawupto="0">
  <legend position="top-left">
  <axes>
    <x tics="100" label="Items added" max="1000">
    <y tics="100" label="Bits set" max="1000">
  </y></x></axes>
  <lines>
    <line y="1000 * (1 - Math.pow(1 - 1/1000, 5 * x))" label="k=5">
    <line y="1000 * (1 - Math.pow(1 - 1/1000, 4 * x))" label="k=4">
    <line y="1000 * (1 - Math.pow(1 - 1/1000, 3 * x))" label="k=3">
    <line y="1000 * (1 - Math.pow(1 - 1/1000, 2 * x))" label="k=2">
    <line y="1000 * (1 - Math.pow(1 - 1/1000, 1 * x))" label="k=1">
  </line></line></line></line></line></lines>
</legend></s-graph>
<s-slider value="0" min="0" max="1000" step="any" onchange="
    document.getElementById(&#39;graph3&#39;).setAttribute(&#39;drawupto&#39;, e.target.value)
  ">
</s-slider>
<p>The more hash functions we use, the faster we set all of the bits. You&#39;ll notice that
the curve tails off as more items are added. This is because the more
<s-word>bits</s-word> that are set, the more likely it is that we&#39;all attempt to
set a <s-word>bit</s-word> that has already been set.</p>
<p>In practice, 1000 <s-word>bits</s-word> is a very small bloom filter, occupying
only 125 bytes of memory. Modern computers have a lot of memory, so let&#39;s crank this
up to 100,000 <s-word>bits</s-word> (12.5kB) and see what happens.</p>
<s-graph id="graph4" drawupto="0">
  <legend position="top-left">
  <axes>
    <x tics="100" label="Items added" max="1000">
    <y tics="10000" ticformat="(tic / 1000).toFixed(0) + &#39;k&#39;" label="Bits set" max="100000">
  </y></x></axes>
  <lines>
    <line y="100000 * (1 - Math.pow(1 - 1/100000, 5 * x))" label="k=5">
    <line y="100000 * (1 - Math.pow(1 - 1/100000, 4 * x))" label="k=4">
    <line y="100000 * (1 - Math.pow(1 - 1/100000, 3 * x))" label="k=3">
    <line y="100000 * (1 - Math.pow(1 - 1/100000, 2 * x))" label="k=2">
    <line y="100000 * (1 - Math.pow(1 - 1/100000, 1 * x))" label="k=1">
  </line></line></line></line></line></lines>
</legend></s-graph>
<s-slider value="0" min="0" max="1000" step="any" onchange="
    document.getElementById(&#39;graph4&#39;).setAttribute(&#39;drawupto&#39;, e.target.value)
  ">
</s-slider>
<p>The lines barely leave the bottom of the graph, meaning the bloom filter will
be very empty and the false-positive rate will be low. All this cost us was
12.5kB of memory, which is still a very small amount by 2024 standards.</p>
<h2 id="tuning-a-bloom-filter"><a href="#tuning-a-bloom-filter">#</a>
Tuning a bloom filter</h2>
<p>Picking the correct number of hash functions and <s-word>bits</s-word> for a bloom
filter is a fine balance. Fortunately for us, if we know up-front how many
unique items we want to store, and what our desired false-positive rate is, we
can calculate the optimal number of hash functions, and the required number of
<s-word>bits</s-word>.</p>
<p>The <a href="https://en.wikipedia.org/wiki/Bloom_filter">bloom filter</a> page on Wikipedia
covers the mathematics involved, which I&#39;m going to translate into JavaScript
functions for us to use. I want to stress that you don&#39;t need to understand the
maths to use a bloom filter or read this post. I&#39;m including the link to it only
for completeness.</p>
<h3 id="optimal-number-of-bits"><a href="#optimal-number-of-bits">#</a>
Optimal number of bits</h3>
<p>The following JavaScript function, which might look a bit scary but bear with
me, takes the number of items you want to store (<code>items</code>) and the desired
false-positive rate (<code>fpr</code>, where 1% == <code>0.01</code>), and returns how many
<s-word>bits</s-word> you will need to achieve that false-positive rate.</p>
<pre data-lang="javascript"><code data-lang="javascript"><span>function </span><span>bits</span><span>(items</span><span>, </span><span>fpr) {
</span><span>  </span><span>const </span><span>n </span><span>= -</span><span>items </span><span>* </span><span>Math</span><span>.</span><span>log</span><span>(fpr)</span><span>;
</span><span>  </span><span>const </span><span>d </span><span>= </span><span>Math</span><span>.</span><span>log</span><span>(</span><span>2</span><span>) </span><span>** </span><span>2</span><span>;
</span><span>  </span><span>return </span><span>Math</span><span>.</span><span>ceil</span><span>(n </span><span>/ </span><span>d)</span><span>;
</span><span>}
</span></code></pre>
<p>We can see how this grows for a variety of <code>fpr</code> values in the graph below.</p>
<s-graph id="graph5" drawupto="0">
  <legend position="top-left">
  <axes>
    <x tics="100" label="Items you plan to add" max="1000">
    <y tics="1000" ticformat="(tic / 1000).toFixed(0) + &#39;k&#39;" label="Bits required" max="10000">
  </y></x></axes>
  <lines>
    <line y="Math.ceil((-x * Math.log(0.01)) / (Math.log(2) ** 2))" label="fpr=0.01 (1%)">
    <line y="Math.ceil((-x * Math.log(0.05)) / (Math.log(2) ** 2))" label="fpr=0.05 (5%)">
    <line y="Math.ceil((-x * Math.log(0.10)) / (Math.log(2) ** 2))" label="fpr=0.1 (10%)">
  </line></line></line></lines>
</legend></s-graph>
<s-slider value="0" min="0" max="1000" step="any" onchange="
    document.getElementById(&#39;graph5&#39;).setAttribute(&#39;drawupto&#39;, e.target.value)
  ">
</s-slider>
<h3 id="optimal-number-of-hash-functions"><a href="#optimal-number-of-hash-functions">#</a>
Optimal number of hash functions</h3>
<p>After we&#39;ve used the JavaScript above to calculate how many
<s-word>bits</s-word> we need, we can use the following function to calculate
the optimal number of hash functions to use:</p>
<pre data-lang="javascript"><code data-lang="javascript"><span>function </span><span>hashFunctions</span><span>(bits</span><span>, </span><span>items) {
</span><span>  </span><span>return </span><span>Math</span><span>.</span><span>ceil</span><span>((bits </span><span>/ </span><span>items) </span><span>* </span><span>Math</span><span>.</span><span>log</span><span>(</span><span>2</span><span>))</span><span>;
</span><span>}
</span></code></pre>
<p>Pause for a second here and have a think about how the number of hash functions
might grow based on the size of the bloom filter and the number of items you
expect to add. Do you think you&#39;ll use more hash functions, or fewer, as the
bloom filter gets larger? What about as the number of items increases?</p>
<s-graph id="graph6" drawupto="0">
  <legend position="top-left">
  <axes>
    <x tics="1000" ticformat="(tic / 1000).toFixed(0) + &#39;k&#39;" label="Bits in bloom filter" max="10000">
    <y tics="1" label="Optimal hash functions" max="10">
  </y></x></axes>
  <lines>
    <line y="Math.ceil((x / 100) * Math.log(2))" label="items = 100">
    <line y="Math.ceil((x / 1000) * Math.log(2))" label="items = 1000">
    <line y="Math.ceil((x / 5000) * Math.log(2))" label="items = 5000">
  </line></line></line></lines>
</legend></s-graph>
<s-slider value="0" min="0" max="10000" step="any" onchange="
    document.getElementById(&#39;graph6&#39;).setAttribute(&#39;drawupto&#39;, e.target.value)
  ">
</s-slider>
<p>The more items you plan to add, the fewer hash functions you should use. Yet, a
larger bloom filter means you can use more hash functions. More hash functions
keep the false-positive rate lower for longer, but more items fills up the bloom
filter faster. It&#39;s a complex balancing act, and I am thankful that
mathematicians have done the hard work of figuring it out for us.</p>
<h3 id="caution"><a href="#caution">#</a>
Caution</h3>
<p>While we can stand on the shoulders of giants and pick the optimal number of
<s-word>bits</s-word> and hash functions for our bloom filter, it&#39;s important to
remember that these rely on you giving good estimates of the number of items you
expect to add, and choosing a false-positive rate that&#39;s acceptable for your
use-case. These numbers might be difficult to come up with, and I recommend
erring on the side of caution. If you&#39;re not sure, it&#39;s likely better to use a
larger bloom filter than you think you need.</p>
<h2 id="removing-items-from-a-bloom-filter"><a href="#removing-items-from-a-bloom-filter">#</a>
Removing items from a bloom filter</h2>
<p>We&#39;ve spent the whole post talking about adding things to a bloom filter, and
the optimal parameters to use. We haven&#39;t spoken at all about removing items.</p>
<p>And that&#39;s because you can&#39;t!</p>
<p>In a bloom filter, we&#39;re using <s-word>bits</s-word>, individual 1s and 0s, to
track the presence of items. If we were to remove an item by setting its
<s-word>bits</s-word> to 0, we might also be removing other items by accident.
There&#39;s no way of knowing.</p>
<p>Click the buttons of the bloom filter below to see this in action. First we will
add &#34;foo&#34;, then &#34;baz&#34;, and then we will remove &#34;baz&#34;. Hit &#34;clear&#34; if you want
to start again.</p>
<s-add-remove bfid="bf3">
  <add value="foo">
  <add value="baz">
  <remove value="baz">
  <clear>
</clear></remove></add></add></s-add-remove>
<s-bloom-filter id="bf3" hashes="sha1,sha256,sha512" bits="32"></s-bloom-filter>
<p>The end result of this sequence is a bloom filter that doesn&#39;t contain &#34;baz&#34;,
but doesn&#39;t contain &#34;foo&#34; either. Because both &#34;foo&#34; and &#34;baz&#34; set
<s-word>bit</s-word> <s-bitlink bfid="bf3">27</s-bitlink>, we accidentally clobber
the presence of &#34;foo&#34; while removing &#34;baz&#34;.</p>
<p>Something else you might have noticed playing with the above example is that if
you add &#34;foo&#34; and then attempt to remove &#34;baz&#34; before having added it, nothing
happens. Even though <s-bitlink bfid="bf3">27</s-bitlink> is set,
<s-word>bits</s-word> <s-bitlink bfid="bf3">18</s-bitlink> and <s-bitlink bfid="bf3">23</s-bitlink> are not, so the bloom filter cannot contain &#34;baz&#34;.
Because of this, it won&#39;t unset <s-bitlink bfid="bf3">27</s-bitlink>.</p>
<h3 id="counting-bloom-filters"><a href="#counting-bloom-filters">#</a>
Counting bloom filters</h3>
<p>While you can&#39;t remove items from a standard bloom filter, there are variants
that allow you to do so. One of these variants is called a &#34;counting bloom
filter,&#34; which uses an array of counters instead of bits to keep track of items.</p>
<s-add-remove bfid="bf4">
  <add value="foo">
  <add value="baz">
  <remove value="baz">
  <clear>
</clear></remove></add></add></s-add-remove>
<s-bloom-filter id="bf4" counting="true" hashes="sha1,sha256,sha512" bits="32"></s-bloom-filter>
<p>Now when you go through the sequence, the end result is that the bloom filter
still contains &#34;foo.&#34; It solves the problem.</p>
<p>The trade-off, though, is that counters are bigger than <s-word>bits</s-word>.
With 4 bits per counter you can increment up to 15. With 8 bits per counter you
can increment up to 255. You&#39;ll need to pick a counter size sufficient to never
reach the maximum value, otherwise you risk corrupting the bloom filter. Using
8x more memory than a standard bloom filter could be a big deal, especially if
you&#39;re using a bloom filter to save memory in the first place. Think hard about
whether you really need to be able to remove items from your bloom filter.</p>
<p>Counting bloom filters also introduce the possibility of false-negatives, which
are impossible in standard bloom filters. Consider the following example.</p>
<s-add-remove bfid="bf5">
  <add value="loved">
  <add value="your">
  <remove value="response">
  <clear>
</clear></remove></add></add></s-add-remove>
<s-bloom-filter id="bf5" counting="true" hashes="sha1,sha256,sha512" bits="32"></s-bloom-filter>
<p>Because &#34;loved&#34; and &#34;response&#34; both hash to the <s-word>bits</s-word>
<s-bitlink bfid="bf5">5</s-bitlink>, <s-bitlink bfid="bf5">22</s-bitlink>, and
<s-bitlink bfid="bf5">26</s-bitlink>, when we remove &#34;response&#34; we also remove &#34;loved&#34;. If
we write this as JavaScript the problem becomes more clear:</p>
<pre data-lang="javascript"><code data-lang="javascript"><span>let </span><span>bf </span><span>= new </span><span>CountingBloomFilter</span><span>()</span><span>;
</span><span>bf</span><span>.</span><span>add</span><span>(</span><span>&#34;loved&#34;</span><span>)</span><span>;
</span><span>bf</span><span>.</span><span>add</span><span>(</span><span>&#34;your&#34;</span><span>)</span><span>;
</span><span>bf</span><span>.</span><span>remove</span><span>(</span><span>&#34;response&#34;</span><span>)</span><span>;
</span><span>bf</span><span>.</span><span>contains</span><span>(</span><span>&#34;loved&#34;</span><span>)</span><span>; </span><span>// false
</span></code></pre>
<p>Even though we know for sure we&#39;ve added &#34;loved&#34; in this snippet, the call to
<code>contains</code> will return <code>false</code>. This sort of false-negative can&#39;t happen in a
standard bloom filter, and it removes one of the key benefits of using a bloom
filter in the first place: the guarantee of no false-negatives.</p>
<h2 id="bloom-filters-in-the-real-world"><a href="#bloom-filters-in-the-real-world">#</a>
Bloom filters in the real-world</h2>
<p>Real-world users of bloom filters include <a href="https://www.akamai.com/">Akamai</a>, who
use them to avoid caching web pages that are accessed once and never again. They
do this by storing all page accesses in a bloom filter, and only writing them
into cache if the bloom filter says they&#39;ve been seen before. This does result
in some pages being cached on the first access, but that&#39;s fine because it&#39;s
still an improvement. It would be impractical for them to store all page
accesses in a <code>Set</code>, so they accept the small false-positive rate in favour of
the significantly smaller bloom filter. Akamai released a
<a href="https://web.archive.org/web/20210814193152/https://www.akamai.com/us/en/multimedia/documents/technical-publication/algorithmic-nuggets-in-content-delivery-technical-publication.pdf">paper</a>
about this that goes into the full details if you&#39;re interested.</p>
<p>Google&#39;s
<a href="https://storage.googleapis.com/pub-tools-public-publication-data/pdf/68a74a85e1662fe02ff3967497f31fda7f32225c.pdf">BigTable</a>
is a distributed key-value store, and uses bloom filters internally to know what
keys are stored within. When a read request for a key comes in, a bloom filter
in memory is first checked to see if the key is in the database. If not,
BigTable can respond with &#34;not found&#34; without ever needing to read from disk.
Sometimes the bloom filter will say a key might be in the database when it isn&#39;t,
but this is fine because when that happens a disk access will confirm the key in
fact isn&#39;t in the database.</p>
<h2 id="conclusion"><a href="#conclusion">#</a>
Conclusion</h2>
<p>Bloom filters, while niche, can be a huge optimisation in the right situation.
They&#39;re a wonderful application of hash functions, and a great example of making
a deliberate trade-off to achieve a specific goal.</p>
<p>Trade-offs, and combining simpler building blocks to create more complex,
purpose-built data structures, are present everywhere in software engineering.
Being able to spot where a data structure could net a big win can separate you
from the pack, and take your career to the next level.</p>
<p>I hope you&#39;ve enjoyed this post, and that you find a way to apply bloom filters
to a problem you&#39;re working on.</p>
<p><em>Join the discussion on <a href="https://news.ycombinator.com/item?id=39439505">Hacker News</a> or <a href="https://lobste.rs/s/gwyglz/visual_interactive_guide_bloom_filters">Lobste.rs</a>!</em></p>
<h2 id="acknowledgements"><a href="#acknowledgements">#</a>
Acknowledgements</h2>
<p>Enormous thank you to my reviewers, without whom this post would be a shadow of
what you read today. In no particular order:</p>
<p><a href="https://rylon.dev">rylon</a>, <a href="https://indy.codes">Indy</a>,
<a href="https://twitter.com/AaronKalair">Aaron</a>, Sophie, <a href="https://dvsj.in">Davis</a>,
<a href="https://eduardmoldovan.com">ed</a>, <a href="https://github.com/mike12345567">Michael
Drury</a>, <a href="https://antonz.org/">Anton Zhiyanov</a>,
<a href="https://appliedgo.net/">Christoph Berger</a>, <a href="https://github.com/aptkingston">Andrew Kingston</a>, <a href="https://thattommyhall.com">Tom Hall</a>.</p>

    </div></div>
  </body>
</html>
