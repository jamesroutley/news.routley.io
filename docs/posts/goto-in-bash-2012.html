<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://bobcopeland.com/blog/2012/10/goto-in-bash/">Original</a>
    <h1>Goto in Bash (2012)</h1>
    
    <div id="readability-page-1" class="page"><article id="post-1880">
		<!-- .entry-header -->

	
	<div>
		<p>If you are as old and nerdy as I, you may have spent your grade school days hacking in the BASIC computer language.  One of the (mostly hated) features of the (mostly hated) language was that any statement required a line number; this provided both the ability to edit individual lines of the program without a screen editor, as well as de facto labels for the (mostly hated) GOTO and GOSUB commands.  But you could also use line numbers to run your program starting from any random point: “RUN 250” might start in the middle of a program, typically after line 250 exited with some syntax error and was subsequently fixed.</p>
<p>Today, in bash, we have no such facility.  Why on earth would anyone want it, with the presence of actual flow control constructs?  Who knows, but asking Google about “bash goto” shows that I am not the first.</p>
<p>For my part, at $work, I have a particular script which takes several days to run, each part of which may take many hours, and, due to moon phases, may fail haphazardly.  If a command fails, the state up to that point is preserved, so I just need to continue where that left off.  Each major part of the job is already factored into individual scripts, so I could cut-and-paste commands from the failure point onward, but I’m lazy.</p>
<p>Thus, I present bash goto.  It runs sed on itself to strip out any parts of the script that shouldn’t run, and then evals it all.  Prepare to cringe.</p>
<pre><code>
#!/bin/bash
# include this boilerplate
function jumpto
{
    label=$1
    cmd=$(sed -n &#34;/$label:/{:a;n;p;ba};&#34; $0 | grep -v &#39;:$&#39;)
    eval &#34;$cmd&#34;
    exit
}

start=${1:-&#34;start&#34;}

jumpto $start

start:
# your script goes here...
x=100
jumpto foo

mid:
x=101
echo &#34;This is not printed!&#34;

foo:
x=${x:-10}
echo x is $x
</code></pre>
<p>results in:</p>
<pre><code>
$ ./test.sh
x is 100
$ ./test.sh foo
x is 10
$ ./test.sh mid
This is not printed!
x is 101
</code></pre>
<p>My quest to make bash look like assembly language draws ever nearer to completion.</p>
<p><b>Update 2019/05/21:</b> A reader pointed out that executing one of the labels results in bash complaining “command not found” and suggested putting the labels in a comment, which works just fine without any other changes (but if you like, you can drop the “grep -v” in that case).  You might also be interested in the takes of folks on <a href="http://www.reddit.com/r/programming/comments/31ei6h/i_wanted_to_use_goto_in_a_bash_script_ended_up/">reddit</a>, or my own take of <a href="https://bobcopeland.com/blog/2015/04/on-reddit/">being discussed on reddit</a>.</p>
	</div><!-- .entry-content -->

			 <!-- .entry-footer -->	
</article></div>
  </body>
</html>
