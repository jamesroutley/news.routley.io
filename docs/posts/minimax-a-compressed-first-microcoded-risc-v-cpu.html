<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/gsmecher/minimax">Original</a>
    <h1>Show HN: Minimax â€“ A Compressed-First, Microcoded RISC-V CPU</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
            <article itemprop="text">
<p dir="auto"><a href="https://github.com/gsmecher/minimax/actions?query=workflow%3ACI"><img src="https://github.com/gsmecher/minimax/workflows/CI/badge.svg" alt="CI status"/></a></p>
<p dir="auto">RISC-V&#39;s compressed instruction (RVC) extension is intended as an add-on to the
regular, 32-bit instruction set, not a replacement or competitor. Its designers
designed RVC instructions to be expanded into regular 32-bit RV32I equivalents
via a pre-decoder.</p>
<p dir="auto">What happens if we <em>explicitly</em> architect a RISC-V CPU to execute RVC
instructions, and &#34;mop up&#34; any RV32I instructions that aren&#39;t convenient via a
microcode layer? What architectural optimizations are unlocked as a result?</p>
<p dir="auto">&#34;Minimax&#34; is an experimental RISC-V implementation intended to establish if an
RVC-optimized CPU is, in practice, any simpler than an ordinary RV32I core with
pre-decoder. While it passes a modest test suite, you should not use it without
caution. (There are a large number of excellent, open source, &#34;little&#34; RISC-V
implementations you should probably use reach for first.)</p>
<p dir="auto">In short:</p>
<ul dir="auto">
<li>
<p dir="auto">RV32C (compressed) instructions are first-class and execute at 1 clock per
instruction. (Exceptions: shifts and branches.)</p>
</li>
<li>
<p dir="auto">SOME RV32I instructions are directly implemented in RTL and execute in 2
clocks per instruction.</p>
</li>
<li>
<p dir="auto">Other RV32I instructions are emulated in microcode, using the instructions
above.</p>
</li>
</ul>
<p dir="auto">This is distinct from (all?) other RV32C-capable RISC-V cores, because it
really is architected for compressed first. This is not how the compressed
ISA was intended to be implemented.</p>
<p dir="auto">A compressed-first RISC-V architecture unlocks the following:</p>
<ul dir="auto">
<li>
<p dir="auto">1 clock per instruction (CPI) using a 2-port register file. RVC
instructions have only 1 rd and 1 rs field. A 2-port register file
maps cleanly into a single RAM64X1D per bit.</p>
</li>
<li>
<p dir="auto">A simplified 16-bit instruction path without alignment considerations. The
processor is a modified Harvard architecture, with a separate 16-bit
instruction bus intended to connect to a second port of the instruction
memory.  On Xilinx, the asymmetric ports (16-bit instruction, 32-bit data)
are reconciled using an asymmetric block RAM primitive. As a result, we don&#39;t
have to worry about a 32-bit instruction split across two 32-bit words.</p>
</li>
</ul>
<p dir="auto">Native instructions are selected for a balance of:</p>
<ul dir="auto">
<li>
<p dir="auto">Small implementation cost. We use a 2-port register file, and 3-operand
instructions require more ports (or more cycles and logic to share ports)</p>
</li>
<li>
<p dir="auto">A reasonable performance baseline. Microcode traps require many clock
cycles, so an impoverished &#34;direct&#34; instruction set hurts us in two ways:</p>
<ol dir="auto">
<li>by requiring more traps to microcode emulation, and</li>
<li>by making microcode itself longer, due to an impoverished instruction
set.</li>
</ol>
</li>
<li>
<p dir="auto">Sufficiency. Some RV32I instructions can&#39;t be emulated using just RV32C
and require RTL support. (For example: word/byte stores.)</p>
</li>
</ul>
<p dir="auto">We end up with the following native instructions:</p>
<ul dir="auto">
<li>C.xxx (all RV32C, except shifts that aren&#39;t 0 or 1 bit)</li>
<li>LUI, AUIPC</li>
<li>ADDI/NOP, ANDI, ORI, XORI</li>
</ul>
<p dir="auto">Why is this desirable?</p>
<ul dir="auto">
<li>
<p dir="auto">Compilers (GCC, LLVM) are learning to prefer RVC instructions when
optimizing for size. This means compiled code (with appropriate
optimization settings) plays to Minimax&#39;s performance sweet-spot,
preferring direct instructions to microcoded instructions.
(see e.g. <a href="https://muxup.com/2022q3/whats-new-for-risc-v-in-llvm-15" rel="nofollow">https://muxup.com/2022q3/whats-new-for-risc-v-in-llvm-15</a>)</p>
</li>
<li>
<p dir="auto">RVC instructions nearly double code density, which pay for the cost of
microcode ROM when compared against a minimalist RV32I implementation.</p>
</li>
<li>
<p dir="auto">It&#39;s not quite the smallest RVC implementation (SERV is smaller), but
it is likely much faster with the appropriate compiler settings, and
slightly less unorthodox in implementation.</p>
</li>
</ul>
<p dir="auto">What&#39;s awkward?</p>
<ul dir="auto">
<li>
<p dir="auto">RVC decoding is definitely uglier than regular RV32I. I expect this
ugliness is better masked when RVC instructions are decoded to RV32I and
executed as &#34;regular&#34; 32-bit instructions.</p>
</li>
<li>
<p dir="auto">The logic depth in the &#34;execute&#34; pipeline stage is extremely long. This CPU
will not reach a high FMAX even on Xilinx UltraScale/UltraScale+ FPGAs.</p>
</li>
<li>
<p dir="auto">Store-word (SB) and store-byte (SB) instructions are not yet supported.</p>
</li>
</ul>
<p dir="auto">What&#39;s the design like?</p>
<ul dir="auto">
<li>
<p dir="auto">Three-stage pipeline (fetch, fetch2, and everything-else). The fetch
pipeline is 2 cycles long to allow the use of embedded block RAM
registers, which frees up more clock slack for the execution stage.
There is a corresponding 2-cycle penalty on taken branches.</p>
</li>
<li>
<p dir="auto">Several &#34;extension instructions&#34; that use the non-standard extension space
reserved in C.SLLI. This space allows us to add &#34;fused&#34; instructions
accessible only in microcode, that perform the following:</p>
<ul dir="auto">
<li>&#34;Thunk&#34; from microcode back to standard code,</li>
<li>Move data from &#34;user&#34; registers into &#34;microcode&#34; registers and back again.</li>
</ul>
<p dir="auto">Because these extension instructions reach deeply into the implementation
details, they are ignored (converted to NOPs) outside emulation microcode.</p>
</li>
</ul>
<p dir="auto">Resource usage (excluding ROM and peripherals; KU060; 12-bit PC):</p>
<ul dir="auto">
<li>Minimax: 61 FFs, 423 CLB LUTs</li>
</ul>
<p dir="auto">Compare to:</p>
<ul dir="auto">
<li>PicoRV32: 483 FFs, 782 LUTs (&#34;small&#34;, RV32I only)</li>
<li>FemtoRV32 186 FFs, 411 LUTs (&#34;quark&#34;, RV32I only)</li>
<li>SERV: 312 FFs, 182 LUTs (no CSR or timer; RV32I only)</li>
<li>PicoBlaze: 82 FFs, 103 LUTs</li>
</ul>
<p dir="auto">Minimax is competitive, even against RV32I-only cores. When comparing
against RV32IC implementations, it does better:</p>
<ul dir="auto">
<li>SERV: 303 FFs, 336 LUTs (no CSR or timer; RV32IC)</li>
<li>PicoRV32: 518 FFs, 1085 LUTs (RV32IC)</li>
</ul>
<p dir="auto">It is difficult to gather defensible benchmarks: please treat these as
approximate, and let me know if they are inaccurate.</p>
<p dir="auto">Comments and PRs always welcome.</p>
<p dir="auto">Graeme Smecher
<a href="mailto:gsmecher@threespeedlogic.com">gsmecher@threespeedlogic.com</a></p>
</article>
          </div></div>
  </body>
</html>
