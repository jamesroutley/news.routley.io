<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.quiss.org/signal_carnival/">Original</a>
    <h1>Signal Carnival</h1>
    
    <div id="readability-page-1" class="page"><div id="main_content_wrap">

<section id="main_content">

<iframe width="560" height="315" src="https://www.youtube.com/embed/_Orvsms7Ils?si=z9KbNEWr_E6vsuZV" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe>

<p>At Revision 2025, we released &#34;Signal Carnival&#34; (<a href="https://csdb.dk/release/?id=252090">csdb</a>, <a href="https://youtu.be/_Orvsms7Ils">YouTube</a>). This demo asks you to
switch the audio and video cable of your C64:</p>

<p><img src="https://www.quiss.org/signal_carnival/cross_small.png" alt="Diagram of audio and video crossed" title=""/>
(<strong>Diagram by Felidae</strong>)</p>

<p>Technically, &#34;misplugging&#34; those cables is not a completely new idea. In the
90s, it was a common thing to connect audio to both speaker and video,
to get screen flickering timed with the music beats.</p>

<p>However, &#34;Signal Carnival&#34; is the first production to switch both these
cables, while still being able to play meaningful audio and video.</p>

<h2>How to drive audio using a video signal</h2>

<p>The C64&#39;s VIC chip operates at a frequency of 7.9Mhz, and new values can be
written to it by the 6502 at a rate of up to 246kHz. Since even high
quality audio rarely exceeds 44kHz, this is easily a high enough frequency
to generate music.</p>

<p>Inspired by the music routine from freespin, we combined two timers to
get an interesting waveform, which is adjusted once per frame. This is
the code that drives audio:</p>

<pre><code>lda $dc06
ora $dd06
eor $02
sta $d020
</code></pre>

<p>Here, <code>$dc06</code> and <code>$dd06</code> are the lower bytes of the B timers of CIA #1 and #2,
respectively. They&#39;re in turn increased every time their A timers
overflow. And those are set to a new value for every new note.</p>

<p>Eor-ing with the value at zeropage <code>$02</code> allows to slightly tweak the waveform (and volume!),
and then the result is written to <code>$d020</code>, which is the screen color.
Only the brightness of said color matters (chrominance is encoded at the
PAL color carrier frequency, which is outside of the human hearing
range). There&#39;s no obvious relationship between the brightness of the C64 color
and its number, but that&#39;s fine - it actually makes the
waveforms more interesting.</p>

<p>Of course, the above uses up all four timers the C64 CIAs have, which means there
are no timers left for e.g. video stabilization, which is instead done
through the lightpen circuitry. (Finally! A use case for <code>$d013</code>. :))</p>

<p>Music is just one voice, but the song switches between voices (and
waveforms) often enough to sound mildly polyphonic.</p>

<h2>How to drive video using an audio signal</h2>

<p>The SID chip of the C64 internally operates (for PAL) at 9.85Mhz, and,
like the VIC, can be fed with new values at a rate of up to 246kHz.</p>

<p>The SID has a number of audio features. It can generate three voices
using multiple waveforms, it has an ADSR envelope generator, can sync
between voices, and apply filters.
Unfortunately, all this circuitry works at a (for video)
glacial pace: The highest frequency the chip can output is 3906Hz, which
is the equivalent of changing the video output every four rasterlines.
Similar with ADSR, for which the smallest possible configurable attack
time is 2 ms, so about 32 rasterlines.</p>

<p>But thankfully, there&#39;s also circuitry that is wired more directly and
and gives instant output: the volume register ($d418)!
This has been used in the past to generate samples at high frequencies
(16+ khz), and is a good choice for generating video, as well.</p>

<p>However, the C64 mainboard also, vexingly, passes the SID signal through
a analogue bandpass filter. And this always happens, regardless of
whether filtering is on or not.</p>

<p><img src="https://www.quiss.org/signal_carnival/filter.png" alt="Subsection of C64 mainboard circuit diagram" title=""/></p>

<p>This means that the pixels we work with are very wide, and also horizontally
blurred. Here&#39;s one &#34;pixel&#34;, displayed on my 1084 monitor:</p>

<p><img src="https://www.quiss.org/signal_carnival/onepixel_cropped.png" alt="Photo of 1084 display, with a blurry horizontal &#34;pixel&#34;" title=""/></p>

<p>This blurryness poses an interesting constraint on effects. While technically,
you do have some degree of horizontal resolution, the blurriness makes it
unenticing to use it for scrollers. Here are a few letters, for illustration:</p>

<p><img src="https://www.quiss.org/signal_carnival/end.jpg" alt="Photo of three letters, heavily blurred" title=""/></p>

<p>Signal Carnival makes heavy use of both axis,
but to cope with the bluriyness, the x axis is used for graphics elements that
are fine to blur, like e.g. textures.</p>

<p>Other than that, driving the video is just your normal vanilla video
bitbanging. Due to the bandpass filter, horizontal syncs (i.e., pulling
the signal line to ground) need to be precisely timed, so they get
recognized, but not mistaken for vertical syncs. (which differ from
horizontal syncs only in that the signal is pulled to ground a
little bit longer)</p>

<p>Video sync generation is happening at the same refresh frequency that
the VIC would have produced (so we can use raster interrupts and query
the lightpen), but we use a different horizontal frequency (64 cycles
per line instead of 63), since having that extra cycle proved useful
in a lot of effects. And besides, if you&#39;re generating your own
video signal, you might as well make your own rules!</p>

<h2>Loading</h2>

<p>I&#39;ve written a new loader for probably every demo I&#39;ve ever released on the C64,
and this one is no exception. Since a lot of the effects are quite
memory-hungry (we even play a sample at the end), loading breaks are
long enough that we can&#39;t just
<a href="http://www.quiss.org/freespin/loading.html">pause audio while they happen</a>.</p>

<p>Hence, we have to bitbang audio the entire time. Also while transferring
data from the drive to the C64. Also during decrunching. (The
decruncher actually unrolls all copy loops, also for that reason)</p>

<p>The loader has a few gimmicks, like doing on-the-fly GCR decoding that
allows to write to any page (not just stack), and it buffers (stashes) a
full kilobyte. <em>But</em> it&#39;s also a one-off, so it&#39;s missing tons of
features seen in fully-fledged C64 loaders. It doesn&#39;t even support
loading from tracks 18 and above yet (the demo uses 1-10.)
Also no checksumming. (So remember, kids, dust off your 1541 drives, or
Signal Carnival might not work!)</p>

<p>Talking about GCR decoding, I found it tedious to handcode the decoding
tables, so we instead wrote a solver that generates them given the code
that uses the tables, and the desired input/output. Very useful tool,
hopefully to be released soon.</p>


</section>

    </div></div>
  </body>
</html>
