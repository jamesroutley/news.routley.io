<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://byorgey.github.io/blog/posts/2024/11/27/stacks-queues.html">Original</a>
    <h1>Purely Functional Sliding Window Aggregation Algorithm</h1>
    
    <div id="readability-page-1" class="page"><section>
<p>Suppose we have a list of items of length <span>\(n\)</span>, and we want to
consider <em>windows</em> (<em>i.e.</em> contiguous subsequences) of width <span>\(w\)</span>
within the list.</p>
<p><span><label for="sn-0">⊕</label><span>A list of numbers, with contiguous size-3 windows highlighted</span></span></p>
<figure>
<img src="https://byorgey.github.io/blog/diagrams/84a9401ef1ac9137.svg"/>
</figure>
<p>We can compute the <em>sum</em> of each window by brute
force in <span>\(O(nw)\)</span> time, by simply generating the list of all the
windows and then summing each. But, of course, we can do better: keep
track of the sum of the current window; every time we slide the window
one element to the right we can add the new element that enters the
window on the right and subtract the element that falls of the window
to the left. Using this “sliding window” technique, we can compute the
sum of every window in only <span>\(O(n)\)</span> total time instead of <span>\(O(nw)\)</span>.</p>
<p>How about finding the <em>maximum</em> of every window? Of course the brute
force <span>\(O(nw)\)</span> algorithm still works, but doing it in only <span>\(O(n)\)</span> is
considerably trickier! We can’t use the same trick as we did for sums
since there’s no way to “subtract” the element falling off the left.
This really comes down to the fact that addition forms a <em>group</em>
(<em>i.e.</em> a monoid-with-inverses), but <code>max</code> does not. So more
generally, the question is: how can we compute a <em>monoidal</em> summary
for every window in only <span>\(O(n)\)</span> time?</p>
<p>Today I want to show you how to solve this problem using one of my
favorite competitive programming tricks, which fits beautifully in a
functional context. Along the way we’ll also see how to implement
simple yet efficient functional queues.</p>
<section id="stacks">
<h2>Stacks</h2>
<p>Before we get to queues, we need to take a detour through stacks.
Stacks in Haskell are pretty boring. We can just use a list, with the
front of the list corresponding to the top of the stack. However, to
make things more interesting—and because it will come in very handy
later—we’re going to implement <em>monoidally-annotated</em> stacks. Every
element on the stack will have a <em>measure</em>, which is a value from some
monoid <code>m</code>. We then want to be able to query any stack for the total
of all the measures in <span>\(O(1)\)</span>. For example, perhaps we want to always
be able to find the sum or max of all the elements on a stack.</p>
<p>If we wanted to implement stacks annotated by a <em>group</em>, we could just
do something like this:</p>
<div id="cb1"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span>data</span> <span>GroupStack</span> g a <span>=</span> <span>GroupStack</span> (a <span>-&gt;</span> g) <span>!</span>g [a]</span></code></pre></div>
<p>That is, a <code>GroupStack</code> stores a <em>measure function</em>, which assigns to
each element of type <code>a</code> a measure of type <code>g</code> (which is intended to
be a <code>Group</code>); a value of type <code>g</code> representing the sum (via the group
operation) of measures of all elements on the stack; and the actual
stack itself. To push, we would just compute the measure of the new element
and add it to the cached <code>g</code> value; to pop, we subtract the measure of
the element being popped, something like this:</p>
<div id="cb2"><pre><code><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span>push ::</span> a <span>-&gt;</span> <span>GroupStack</span> g a <span>-&gt;</span> <span>GroupStack</span> g a</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>push a (<span>GroupStack</span> f g as) <span>=</span> <span>GroupStack</span> f (f a <span>&lt;&gt;</span> g) (a<span>:</span>as)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span>pop ::</span> <span>GroupStack</span> g a <span>-&gt;</span> <span>Maybe</span> (a, <span>GroupStack</span> g a)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>pop (<span>GroupStack</span> f g as) <span>=</span> <span>case</span> as <span>of</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>  [] <span>-&gt;</span> <span>Nothing</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>  (a<span>:</span>as&#39;) <span>-&gt;</span> <span>GroupStack</span> f (inv (f a) <span>&lt;&gt;</span> g) as&#39;</span></code></pre></div>
<p>But this won’t work for a monoid, of course. The problem is <code>pop</code>, where
we can’t just subtract the measure for the element being
popped. Instead, we need to be able to <em>restore</em> the measure of a
previous stack. Hmmm… sounds like we might be able to use… a stack! We
could just store a stack of measures alongside the stack of elements;
even better is to store a stack of <em>pairs</em>. That is, each element on
the stack is paired with an annotation representing the sum of all the
measures at or below it. Here, then, is our representation of
monoidally-annotated stacks:</p>
<div id="cb3"><pre><code><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span>{-# LANGUAGE BangPatterns #-}</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span>module</span> <span>Stack</span> <span>where</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span>data</span> <span>Stack</span> m a <span>=</span> <span>Stack</span> (a <span>-&gt;</span> m) <span>!</span><span>Int</span> [(m, a)]</span></code></pre></div>
<p>A <code>Stack m a</code> stores three things:</p>
<ol type="1">
<li><p>A measure function of type <code>a -&gt; m</code>.<span><label for="sn-1"></label><span>Incidentally, what if we want
to be able to specify an arbitrary measure for each element, and
even give different measures to the same element at different
times? Easy: just use <code>(m,a)</code> pairs as elements, and use <code>fst</code> as
the measure function.</span></span></p></li>
<li><p>An <code>Int</code> representing the size of the stack. This is not strictly
necessary, especially since one could always just use a monoidal
annotation to keep track of the size; but wanting the size is so
ubiquitous that it seems convenient to just include it as a special
case.</p></li>
<li><p>The aforementioned stack of (annotation, element) pairs.</p></li>
</ol>
<p>Note that we cannot write a <code>Functor</code> instance for <code>Stack m</code>, since
<code>a</code> occurs contravariantly in <code>(a -&gt; m)</code>. But this makes sense: if we
change all the <code>a</code> values, the cached measures would no longer be valid.</p>
<p>When creating a new, empty stack, we have to specify the measure
function; to get the measure of a stack, we just look up the measure
on top, or return <code>mempty</code> for an empty stack.</p>
<div id="cb4"><pre><code><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span>new ::</span> (a <span>-&gt;</span> m) <span>-&gt;</span> <span>Stack</span> m a</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>new f <span>=</span> <span>Stack</span> f <span>0</span> []</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span>size ::</span> <span>Stack</span> m a <span>-&gt;</span> <span>Int</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>size (<span>Stack</span> _ n _) <span>=</span> n</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span>measure ::</span> <span>Monoid</span> m <span>=&gt;</span> <span>Stack</span> m a <span>-&gt;</span> m</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>measure (<span>Stack</span> _ _ as) <span>=</span> <span>case</span> as <span>of</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>  [] <span>-&gt;</span> <span>mempty</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>  (m, _) <span>:</span> _ <span>-&gt;</span> m</span></code></pre></div>
<p>Now let’s implement <code>push</code> and <code>pop</code>. Both are relatively
straightforward.</p>
<div id="cb5"><pre><code><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span>push ::</span> <span>Monoid</span> m <span>=&gt;</span> a <span>-&gt;</span> <span>Stack</span> m a <span>-&gt;</span> <span>Stack</span> m a</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>push a s<span>@</span>(<span>Stack</span> f n as) <span>=</span> <span>Stack</span> f (n <span>+</span> <span>1</span>) ((f a <span>&lt;&gt;</span> measure s, a) <span>:</span> as)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span>pop ::</span> <span>Stack</span> m a <span>-&gt;</span> <span>Maybe</span> (a, <span>Stack</span> m a)</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>pop (<span>Stack</span> f n as) <span>=</span> <span>case</span> as <span>of</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>  [] <span>-&gt;</span> <span>Nothing</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>  (_, a) <span>:</span> as&#39; <span>-&gt;</span> <span>Just</span> (a, <span>Stack</span> f (n <span>-</span> <span>1</span>) as&#39;)</span></code></pre></div>
<p>Note that if we care about using <em>non-commutative</em> monoids,
in the implementation of <code>push</code> we have a choice to make between <code>f a &lt;&gt; measure s</code> and <code>measure s &lt;&gt; f a</code>. The former seems nicer to me,
since it keeps the measures “in the same order” as the list
representing the stack. For example, if we push a list of elements
onto a stack via <code>foldr</code>, using the measure function <code>(:[])</code> that injects
each element into the monoid of lists, the resulting <code>measure</code> is just
the original list:</p>
<div id="cb6"><pre><code><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>measure <span>.</span> <span>foldr</span> push (new (<span>:</span>[])) <span>==</span> <span>id</span></span></code></pre></div>
<p>And more generally, for any measure function <code>f</code>, we have</p>
<div id="cb7"><pre><code><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>measure <span>.</span> <span>foldr</span> push (new f) <span>==</span> <span>foldMap</span> f</span></code></pre></div>
<p>Finally, we are going to want a function to <em>reverse</em> a stack, which
is a one-liner:</p>
<div id="cb8"><pre><code><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span>reverse</span><span> ::</span> <span>Monoid</span> m <span>=&gt;</span> <span>Stack</span> m a <span>-&gt;</span> <span>Stack</span> m a</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span>reverse</span> (<span>Stack</span> f _ as) <span>=</span> foldl&#39; (<span>flip</span> push) (new f) (<span>map</span> <span>snd</span> as)</span></code></pre></div>
<p>That is, to reverse a stack, we extract the elements and then use
<code>foldl&#39;</code> to push the elements one at a time onto a new stack using the
same measure function.</p>
<p>There is a <a href="https://github.com/byorgey/comprog-hs/blob/master/Stack.hs">bit more code you can find on
GitHub</a>,
such as <code>Show</code> and <code>Eq</code> instances.</p>
</section>
<section id="queues">
<h2>Queues</h2>
<p>Now that we have monoidally-annotated stacks under our belt, let’s
turn to queues. And here’s where my favorite trick is revealed: we
can implement a queue out of two stacks, so that enqueue and dequeue
run in <span>\(O(1)\)</span> amortized time; and if we use monoidally-annotated
stacks, we get monoidally-annotated queues for free!</p>
<p>First, some imports.</p>
<div id="cb9"><pre><code><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span>{-# LANGUAGE ImportQualifiedPost #-}</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span>module</span> <span>Queue</span> <span>where</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span>import</span> <span>Data.Bifunctor</span> (second)</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span>import</span> <span>Stack</span> (<span>Stack</span>)</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span>import</span> <span>Stack</span> <span>qualified</span> <span>as</span> <span>Stack</span></span></code></pre></div>
<p>A <code>Queue m a</code> just consists of two stacks, one for the front and one
for the back. To create a <code>new</code> queue, we just create two new stacks;
to get the <code>size</code> of a queue, we just add the sizes of the stacks; to
get the <code>measure</code> of a queue, we just combine the measures of the
stacks. Easy peasy.</p>
<div id="cb10"><pre><code><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span>type</span> <span>CommutativeMonoid</span> <span>=</span> <span>Monoid</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span>data</span> <span>Queue</span> m a <span>=</span> <span>Queue</span> {<span>getFront ::</span> <span>Stack</span> m a,<span> getBack ::</span> <span>Stack</span> m a}</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>  <span>deriving</span> (<span>Show</span>, <span>Eq</span>)</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span>new ::</span> (a <span>-&gt;</span> m) <span>-&gt;</span> <span>Queue</span> m a</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>new f <span>=</span> <span>Queue</span> (Stack.new f) (Stack.new f)</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a><span>size ::</span> <span>Queue</span> m a <span>-&gt;</span> <span>Int</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>size (<span>Queue</span> front back) <span>=</span> Stack.size front <span>+</span> Stack.size back</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a><span>measure ::</span> <span>CommutativeMonoid</span> m <span>=&gt;</span> <span>Queue</span> m a <span>-&gt;</span> m</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>measure (<span>Queue</span> front back) <span>=</span> Stack.measure front <span>&lt;&gt;</span> Stack.measure back</span></code></pre></div>
<p>Note the restriction to <em>commutative</em> monoids, since the queue
elements are stored in different orders in the front and back stacks.
If we really cared about making this work with non-commutative
monoids, we would have to make two different <code>push</code> methods for the
front and back stacks, to combine the measures in opposite orders.
That just doesn’t seem worth it. But if you have a good example
requiring the use of a queue annotated by a non-commutative monoid,
I’d love to hear it!</p>
<p>Now, to <code>enqueue</code>, we just push the new element on the back:</p>
<div id="cb11"><pre><code><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span>enqueue ::</span> <span>CommutativeMonoid</span> m <span>=&gt;</span> a <span>-&gt;</span> <span>Queue</span> m a <span>-&gt;</span> <span>Queue</span> m a</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>enqueue a (<span>Queue</span> front back) <span>=</span> <span>Queue</span> front (Stack.push a back)</span></code></pre></div>
<p>Dequeueing is the magic bit that makes everything work. If there are
any elements in the front stack, we can just pop from there.
Otherwise, we need to first reverse the back stack into the front
stack. This means <code>dequeue</code> may occasionally take <span>\(O(n)\)</span> time, but it’s
still <span>\(O(1)\)</span> amortized.<span><label for="sn-2"></label><span>The easiest way to see this is to note that
every element is touched exactly three times: once when it is pushed
on the back; once when it is transferred from the back to the front;
and once when it is popped from the front. So, overall, we do <span>\(O(1)\)</span>
work per element.</span></span></p>
<div id="cb12"><pre><code><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span>dequeue ::</span> <span>CommutativeMonoid</span> m <span>=&gt;</span> <span>Queue</span> m a <span>-&gt;</span> <span>Maybe</span> (a, <span>Queue</span> m a)</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>dequeue (<span>Queue</span> front back)</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>  <span>|</span> Stack.size front <span>==</span> <span>0</span> <span>&amp;&amp;</span> Stack.size back <span>==</span> <span>0</span> <span>=</span> <span>Nothing</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>  <span>|</span> Stack.size front <span>==</span> <span>0</span> <span>=</span> dequeue (<span>Queue</span> (Stack.reverse back) front)</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>  <span>|</span> <span>otherwise</span> <span>=</span> second (\front&#39; <span>-&gt;</span> <span>Queue</span> front&#39; back) <span>&lt;$&gt;</span> Stack.pop</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>  front</span></code></pre></div>
<p>Finally, for convenience, we can make a function <code>drop1</code> which just
dequeues an item from the front of a queue and throws it away.</p>
<div id="cb13"><pre><code><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span>drop1 ::</span> <span>CommutativeMonoid</span> m <span>=&gt;</span> <span>Queue</span> m a <span>-&gt;</span> <span>Queue</span> m a</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>drop1 q <span>=</span> <span>case</span> dequeue q <span>of</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>  <span>Nothing</span> <span>-&gt;</span> q</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>  <span>Just</span> (_, q&#39;) <span>-&gt;</span> q&#39;</span></code></pre></div>
<p>This “banker’s queue” method of building a queue out of two stacks is
discussed in <em>Purely Functional Data Structures</em> by Okasaki, though I
don’t think he was the first to come up with the idea. It’s also
possible to use some clever tricks to <a href="https://www.hedonisticlearning.com/posts/global-rebuilding-coroutines-and-defunctionalization.html">make both <code>enqueue</code> and
<code>dequeue</code> take <span>\(O(1)\)</span> time in the <em>worst</em>
case</a>.
In a future post I’d like to do some benchmarking to compare various
queue implementations (<em>i.e.</em> banker’s queues, <code>Data.Sequence</code>,
circular array queues built on top of <code>STArray</code>). At least
anecdotally, in solving some sliding window problems, banker’s queues
seem quite fast so far.</p>
</section>
<section id="sliding-windows">
<h2>Sliding windows</h2>
<p>I hope you can see how this solves the initial motivating problem: to
find <em>e.g.</em> the max of a sliding window, we can just put the elements
in a monoidally-annotated queue, enqueueing and dequeueing one element
every time we slide the window over.<span><label for="sn-3"></label><span>More generally, of course, it
doesn’t even matter if the left and right ends of the window stay
exactly in sync; we can enqueue and dequeue as many times as we want.</span></span> The following <code>windows</code> function computes the monoidal sum <code>foldMap f window</code> for each window of width <span>\(w\)</span>, in only <span>\(O(n)\)</span> time
overall.</p>
<div id="cb14"><pre><code><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span>windows ::</span> <span>CommutativeMonoid</span> m <span>=&gt;</span> <span>Int</span> <span>-&gt;</span> (a <span>-&gt;</span> m) <span>-&gt;</span> [a] <span>-&gt;</span> [m]</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>windows w f as <span>=</span> go startQ rest</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a> <span>where</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>  (start, rest) <span>=</span> <span>splitAt</span> w as</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>  startQ <span>=</span> foldl&#39; (<span>flip</span> enqueue) (new f) start</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>  go q as <span>=</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>    measure q <span>:</span> <span>case</span> as <span>of</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>      [] <span>-&gt;</span> []</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>      a <span>:</span> as <span>-&gt;</span> go (enqueue a (drop1 q)) as</span></code></pre></div>
<p>“But…maximum and minimum do not form monoids, only semigroups!”
I hear you cry. Well, we can just adjoin special positive or negative
infinity elements as needed, like so:</p>
<div id="cb15"><pre><code><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span>data</span> <span>Max</span> a <span>=</span> <span>NegInf</span> <span>|</span> <span>Max</span> a <span>deriving</span> (<span>Eq</span>, <span>Ord</span>, <span>Show</span>)</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span>instance</span> <span>Ord</span> a <span>=&gt;</span> <span>Semigroup</span> (<span>Max</span> a) <span>where</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>  <span>NegInf</span> <span>&lt;&gt;</span> a <span>=</span> a</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>  a <span>&lt;&gt;</span> <span>NegInf</span> <span>=</span> a</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>  <span>Max</span> a <span>&lt;&gt;</span> <span>Max</span> b <span>=</span> <span>Max</span> (<span>max</span> a b)</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a><span>instance</span> <span>Ord</span> a <span>=&gt;</span> <span>Monoid</span> (<span>Max</span> a) <span>where</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>  <span>mempty</span> <span>=</span> <span>NegInf</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a><span>data</span> <span>Min</span> a <span>=</span> <span>Min</span> a <span>|</span> <span>PosInf</span> <span>deriving</span> (<span>Eq</span>, <span>Ord</span>, <span>Show</span>)</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a><span>instance</span> <span>Ord</span> a <span>=&gt;</span> <span>Semigroup</span> (<span>Min</span> a) <span>where</span></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>  <span>PosInf</span> <span>&lt;&gt;</span> a <span>=</span> a</span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>  a <span>&lt;&gt;</span> <span>PosInf</span> <span>=</span> a</span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>  <span>Min</span> a <span>&lt;&gt;</span> <span>Min</span> b <span>=</span> <span>Min</span> (<span>min</span> a b)</span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a><span>instance</span> <span>Ord</span> a <span>=&gt;</span> <span>Monoid</span> (<span>Min</span> a) <span>where</span></span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a>  <span>mempty</span> <span>=</span> <span>PosInf</span></span></code></pre></div>
<p>Now we can write, for example, <code>windows 3 Max [1,4,2,8,9,4,4,6]</code> which
yields <code>[Max 4, Max 8, Max 9, Max 9, Max 9, Max 6]</code>, the maximums of
each 3-element window.</p>
</section>
<section id="challenges">
<h2>Challenges</h2>
<p>If you’d like to try solving some problems using the techniques from this
blog post, I can recommend the following (generally in order of difficulty):</p>
<ul>
<li><a href="https://open.kattis.com/problems/tiredterry">Tired Terry</a></li>
<li><a href="https://open.kattis.com/problems/treeshopping">Tree Shopping</a></li>
<li><a href="https://open.kattis.com/problems/einvigi">Einvígi</a></li>
<li><a href="https://open.kattis.com/problems/hockeyfans">Hockey Fans</a></li>
</ul>
<p>In a future post I’ll walk through my solution to <a href="https://open.kattis.com/problems/hockeyfans">Hockey
Fans</a>. And here’s another
couple problems along similar lines; unlike the previous problems I am
not so sure how to solve these in a nice way. I may write about them
in the future.</p>
<ul>
<li><a href="https://open.kattis.com/problems/martiandna">Martian DNA</a></li>
<li><a href="https://open.kattis.com/problems/slidecount">Slide Count</a></li>
</ul>
</section>

</section></div>
  </body>
</html>
