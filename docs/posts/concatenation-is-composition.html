<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://concatenative.org/wiki/view/Concatenative%20language/Concatenation%20is%20composition">Original</a>
    <h1>Concatenation is composition</h1>
    
    <div id="readability-page-1" class="page"><div>
		<p>A fundamental property of stack languages is that the concatenation of two programs <code>X</code> and <code>Y</code> -- <code>X Y</code> -- is the program that applies <code>Y</code> to the result of <code>X</code>, that is, the <em>composition</em> of <code>X</code> and <code>Y</code>. This means that certain common quotation patterns can be written very concisely.</p><p>For example, in Factor we can filter a sequence by a predicate using the <code>filter</code> combinator:</p><pre> <span>{</span> <span>1</span> <span>2</span> <span>3</span> <span>4</span> <span>5</span> <span>6</span> <span>7</span> <span>8</span> <span>}</span> <span>[</span> even? <span>]</span> filter .
<span>{</span> <span>2</span> <span>4</span> <span>6</span> <span>8</span> <span>}</span></pre><p>If we want to remove elements matching the predicate instead, we can compose the predicate with the <code>not</code> word:</p><pre> <span>{</span> <span>1</span> <span>2</span> <span>3</span> <span>4</span> <span>5</span> <span>6</span> <span>7</span> <span>8</span> <span>}</span> <span>[</span> even? not <span>]</span> filter .
<span>{</span> <span>1</span> <span>3</span> <span>5</span> <span>7</span> <span>}</span></pre><p>Partial application works out very nicely too: write a quotation which pushes some of the parameters before calling a word:</p><pre> <span>{</span> <span>1</span> <span>2</span> <span>3</span> <span>4</span> <span>5</span> <span>6</span> <span>7</span> <span>8</span> <span>}</span> <span>[</span> <span>4</span> &gt; <span>]</span> filter .
<span>{</span> <span>5</span> <span>6</span> <span>7</span> <span>8</span> <span>}</span></pre><p>Compare these three quotations,</p><pre><span>[</span> even? <span>]</span>
<span>[</span> even? not <span>]</span>
<span>[</span> <span>4</span> &gt; <span>]</span></pre><p>This is shorter than the equivalent in an applicative language, because we have to name the input argument, that is only used once. In Common Lisp:</p><pre>(<span>function</span> <span>evenp</span>)
(<span>lambda</span> (x) (<span>not</span> (<span>evenp</span> x)))
(<span>lambda</span> (x) (<span>&gt;</span> x <span>4</span>))</pre><p>In Haskell:</p><pre>(even)
(not . even)
(<span>4</span> <span>&gt;</span>)</pre><p>Since concatenative languages do not have named parameters (let&#39;s ignore Factor&#39;s <code>locals</code> vocabulary for now), talking about free variables does not make sense. The nearest equivalent in a concatenative language is constructing new quotations from existing quotations.</p><p>In Factor, quotations look like a sequence of objects; for example, <code>[ 2 2 + ]</code> has three elements, the integer <code>2</code>, the integer <code>2</code> again, and the word <code>+</code>; the latter is itself an object which can be introspected and executed. This means that we can use sequence operations to construct quotations.</p><p>Suppose we have the quotation <code>[ + ]</code>. When executed, it takes two numbers from the stack, adds them, and leaves the result on the stack. If we prefix the quotation with the integer 5, we get a new quotation, <code>[ 5 + ]</code>, which adds 5 to the top of the stack. This is similar to <em>currying</em> in applicative languages, so Factor calls this operation <code>curry</code>.</p><p>Another fundamental operation on quotations is composition: suppose we take the quotation <code>[ 2 + ]</code> and the quotation <code>[ 0 &gt; ]</code>; their composition is <code>[2 + 0 &gt; ]</code>. Of course, this is just the concatenation of the two quotations.</p><p>These two fundamental operations -- <code>curry</code> and <code>compose</code> -- have very simple and intuitive semantics. Note that quotations are printable objects, whereas in applicative languages, closures are typically opaque.</p><p>Examples of <code>curry</code>:</p><pre> <span>5</span> <span>[</span> + <span>]</span> curry .
<span>[</span> <span>5</span> + <span>]</span></pre><p>Compare with lisps applicative version; note the closure does not print readably:</p><pre><span>*</span> (<span>let</span> ((x <span>5</span>)) (<span>lambda</span> (y) (<span>+</span> x y)))
#&lt;FUNCTION (LAMBDA (Y)) {<span>11682335</span>}<span>&gt;</span></pre><p>or Haskell:</p><pre>(<span>5</span><span>+</span>)
Functions cannot be printed <span>in</span> Haskell</pre><p>Examples of <code>compose</code>:</p><pre> <span>[</span> <span>3</span> = <span>]</span> <span>[</span> not <span>]</span> compose .
<span>[</span> <span>3</span> = not <span>]</span></pre><p>Applicative version:</p><pre><span>*</span> (<span>let</span> ((f (<span>lambda</span> (x) (<span>=</span> x <span>3</span>)))) (<span>lambda</span> (y) (<span>not</span> (<span>funcall</span> f y))))
#&lt;FUNCTION (LAMBDA (Y)) {11680B3D}<span>&gt;</span></pre><pre>(not . (<span>3</span> <span>=</span><span>=</span>))
Again, functions cannot be printed</pre><p>As you can see, function composition and partial application feels a lot more natural in stack languages, because of the duality between composition and concatenation.</p>
	</div></div>
  </body>
</html>
