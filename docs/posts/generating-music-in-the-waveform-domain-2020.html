<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://sander.ai/2020/03/24/audio-generation.html">Original</a>
    <h1>Generating music in the waveform domain (2020)</h1>
    
    <div id="readability-page-1" class="page"><div>
      <p>In November last year, I co-presented a tutorial on <strong>waveform-based music processing with deep learning</strong> with <a href="http://www.jordipons.me/">Jordi Pons</a> and <a href="https://jongpillee.github.io/">Jongpil Lee</a> at <a href="https://ismir2019.ewi.tudelft.nl/">ISMIR 2019</a>. Jongpil and Jordi talked about music classification and source separation respectively, and I presented the last part of the tutorial, on music generation in the waveform domain. It was very well received, so I’ve decided to write it up in the form of a blog post.</p>

<p><a href="https://ismir2019.ewi.tudelft.nl/"><img src="https://sander.ai/images/ismir_logo.jpg" alt="ISMIR"/></a></p>

<p>ISMIR used to be my home conference when I was a PhD student working on music information retrieval, so it was great to be back for the first time in five years. With about 450 attendees (the largest edition yet), it made for a very different experience than what I’m used to with machine learning conferences like ICML, NeurIPS and ICLR, whose audiences tend to number in the thousands these days.</p>

<p>Our tutorial on the first day of the conference gave rise to plenty of interesting questions and discussions throughout, which inspired me to write some of these things down and hopefully provide a basis to continue these discussions online. Note that I will only be covering music generation in this post, but Jordi and Jongpil are working on blog posts about their respective parts. I will share them here when they are published. In the meantime, <strong>the slide deck we used includes all three parts and is now available on <a href="https://zenodo.org/record/3529714#.XdBi0dv7Sf5">Zenodo (PDF)</a> and on <a href="https://docs.google.com/presentation/d/1_ezZXDkyhp9USAYMc5oKJCkUrUhBfo-Di8H8IfypGBM/edit#slide=id.g647f5a8648_0_57">Google slides</a></strong>.  I’ve also added a few things to this post that I’ve thought of since giving the tutorial, and some new work that has come out since.</p>

<p>This is also an excellent opportunity to revive my blog, which has lain dormant for the past four years. I have taken the time to update the blog software, so if anything looks odd, that may be why. Please let me know so I can fix it!</p>

<figure>
  <a href="https://sander.ai/images/ismir_2019_photo.jpeg"><img src="https://sander.ai/images/ismir_2019_photo.jpeg" alt="Presenting our tutorial session at ISMIR 2019 in Delft, The Netherlands."/></a>
  <figcaption>Presenting our tutorial session at ISMIR 2019 in Delft, The Netherlands. Via <a href="https://twitter.com/ismir2019/status/1191341227825934336">ISMIR2019 on Twitter</a>.</figcaption>
</figure>

<h2 id="-overview"><a name="overview"></a> Overview</h2>

<p>This blog post is divided into a few different sections. I’ll try to motivate why modelling music in the waveform domain is an interesting problem. Then I’ll give an overview of generative models, the various flavours that exist, and some important ways in which they differ from each other. In the next two sections I’ll attempt to cover the state of the art in both likelihood-based and adversarial models of raw music audio. Finally, I’ll raise some observations and discussion points. If you want to skip ahead, just click the section title below to go there.</p>

<ul>
  <li><em><a href="#motivation">Motivation</a></em></li>
  <li><em><a href="#generative-models">Generative models</a></em></li>
  <li><em><a href="#likelihood-based-models">Likelihood-based models of waveforms</a></em></li>
  <li><em><a href="#adversarial-models">Adversarial models of waveforms</a></em></li>
  <li><em><a href="#discussion">Discussion</a></em></li>
  <li><em><a href="#conclusion">Conclusion</a></em></li>
  <li><em><a href="#references">References</a></em></li>
</ul>

<p>Note that this blog post is not intended to provide an exhaustive overview of all the published research in this domain – I have tried to make a selection and I’ve inevitably left out some great work. <strong>Please don’t hesitate to suggest relevant work in the comments section!</strong></p>

<h2 id="-motivation"><a name="motivation"></a> Motivation</h2>

<h3 id="why-audio">Why audio?</h3>

<p>Music generation has traditionally been studied in the <strong>symbolic domain</strong>: the output of the generative process could be a musical score, a sequence of <a href="https://en.wikipedia.org/wiki/MIDI">MIDI events</a>, a simple melody, a sequence of chords, a textual representation<sup id="fnref:folkrnn" role="doc-noteref"><a href="#fn:folkrnn" rel="footnote">1</a></sup> or some other higher-level representation. The physical process through which sound is produced is abstracted away. This dramatically reduces the amount of information that the models are required to produce, which makes the modelling problem more tractable and allows for lower-capacity models to be used effectively.</p>

<p>A very popular representation is the so-called <em>piano roll</em>, which dates back to the player pianos of the early 20th century. Holes were punched into a roll of paper to indicate which notes should be played at which time. This representation survives in digital form today and is commonly used in music production. Much of the work on music generation using machine learning has made use of (some variant of) this representation, because it allows for capturing performance-specific aspects of the music without having to model the sound.</p>

<figure>
  <a href="https://sander.ai/images/player_piano.jpg"><img src="https://sander.ai/images/player_piano.jpg" alt="Player piano with a physical piano roll inside."/></a>
  <a href="https://sander.ai/images/piano_roll.jpg"><img src="https://sander.ai/images/piano_roll.jpg" alt="Modern incarnation of a piano roll."/></a>
  <figcaption><strong>Left:</strong> player piano with a physical piano roll inside. <strong>Right:</strong> modern incarnation of a piano roll.</figcaption>
</figure>

<p>Piano rolls are great for piano performances, because they are able to exactly capture the <em>timing</em>, <em>pitch</em> and <em>velocity</em> (i.e. how hard a piano key is pressed, which is correlated with loudness, but not equivalent to it) of the notes. They are able to very accurately represent piano music, because they cover all the “degrees of freedom” that a performer has at their disposal. However, most other instruments have many more degrees of freedom: think about all the various ways you can play a note on the guitar, for example. You can decide which string to use, where to pick, whether to bend the string or not, play vibrato, … you could even play harmonics, or use two-hand tapping. Such a vast array of different playing techniques endows the performer with a lot more freedom to vary the sound that the instrument produces, and coming up with a high-level representation that can accurately capture all this variety is much more challenging. In practice, a lot of this detail is ignored and a simpler representation is often used when generating music for these instruments.</p>

<p>Modelling the sound that an instrument produces is much more difficult than modelling (some of) the parameters that are controlled by the performer, but it frees us from having to manually design high-level representations that accurately capture all these parameters. Furthermore, it allows our models to capture variability that is beyond the performer’s control: the idiosyncracies of individual instruments, for example (no two violins sound exactly the same!), or the parameters of the recording setup used to obtain the training data for our models. It also makes it possible to model ensembles of instruments, or other sound sources altogether, without having to fundamentally change anything about the model apart from the data it is trained on.</p>

<p>Digital audio representations require a reasonably high bit rate to achieve acceptable fidelity however, and modelling all these bits comes with a cost. <strong>Music audio models will necessarily have to have a much higher capacity than their symbolic counterparts</strong>, which implies higher computational requirements for model training.</p>

<h3 id="why-waveforms"><a name="why-waveforms"></a>Why waveforms?</h3>

<p>Digital representations of sound come in many shapes and forms. For reproduction, sound is usually stored by encoding the shape of the waveform as it changes over time. For analysis however, we often make use of <strong><a href="https://en.wikipedia.org/wiki/Spectrogram">spectrograms</a></strong>, both for computational methods and for visual inspection by humans. A spectrogram can be obtained from a waveform by computing the Fourier transform of overlapping windows of the signal, and stacking the results into a 2D array. This shows the <strong>local frequency content of the signal over time</strong>.</p>

<p>Spectrograms are complex-valued: they represent both the amplitude and the phase of different frequency components at each point in time. Below is a visualisation of a magnitude spectrogram and its corresponding phase spectrogram. While the magnitude spectrogram clearly exhibits a lot of structure, with sustained frequencies manifesting as horizontal lines and harmonics showing up as parallel horizontal lines, the phase spectrogram looks a lot more random.</p>

<figure>
  <a href="https://sander.ai/images/spectrogram_magnitude.png"><img src="https://sander.ai/images/spectrogram_magnitude.png" alt="Magnitude spectrogram of a piano recording."/></a>
  <a href="https://sander.ai/images/spectrogram_phase.png"><img src="https://sander.ai/images/spectrogram_phase.png" alt="Phase spectrogram of a piano recording."/></a>
  <figcaption><strong>Top:</strong> magnitude spectrogram of a piano recording. <strong>Bottom:</strong> the corresponding phase spectrogram.</figcaption>
</figure>

<p>When extracting information from audio signals, it turns out that we can often just <strong>discard the phase component</strong>, because it is not informative for most of the things we could be interested in. In fact, this is why the magnitude spectrogram is often referred to simply as “the spectrogram”. When generating sound however, phase is very important because it meaningfully affects our perception. Listen below to an original excerpt of a piano piece, and a corresponding excerpt where the original phase has been replaced by random uniform phase information. Note how the harmony is preserved, but the timbre changes completely.</p>

<figure>
    <audio controls="" src="/files/original_phase.wav"><a href="https://sander.ai/files/original_phase.wav">Audio with original phase</a></audio>
    <audio controls="" src="/files/random_phase.wav"><a href="https://sander.ai/files/random_phase.wav">Audio with random phase</a></audio>
    <figcaption><strong>Left:</strong> excerpt with original phase. <strong>Right:</strong> the same excerpt with random phase.</figcaption>
</figure>

<p>The phase component of a spectrogram is tricky to model for a number of reasons:</p>
<ul>
  <li>it is an <strong>angle</strong>: \(\phi \in [0, 2 \pi)\) and it wraps around;</li>
  <li>it becomes <strong>effectively random</strong> as the magnitude tends towards 0, because noise starts to dominate;</li>
  <li>absolute phase is less meaningful, but <strong>relative phase differences over time matter perceptually</strong>.</li>
</ul>

<p>If we model waveforms directly, we are implicitly modelling their phase as well, but we don’t run into these issues that make modelling phase so cumbersome. There are other strategies to avoid these issues, some of which I will <a href="#alternatives">discuss later</a>, but <strong>waveform modelling currently seems to be the dominant approach in the generative setting</strong>. This is particularly interesting because magnitude spectrograms are by far the most common representation used for discriminative models of audio.</p>

<h3 id="discretising-waveforms">Discretising waveforms</h3>

<p>When representing a waveform digitally, we need to <strong>discretise it in both time and amplitude</strong>. This is referred to as <a href="https://en.wikipedia.org/wiki/Pulse-code_modulation">pulse code modulation (PCM)</a>. Because audio waveforms are effectively band-limited (humans cannot perceive frequencies above ~20 kHz), the <a href="https://en.wikipedia.org/wiki/Nyquist%E2%80%93Shannon_sampling_theorem">sampling theorem</a> tells us that we can discretise the waveform in time without any loss of information, as long as the sample rate is high enough (twice the highest frequency). This is why CD quality audio has a sample rate of 44.1 kHz. Much lower sample rates result in an audible loss of fidelity, but since the resulting discrete sequences also end up being much shorter, a compromise is often struck in the context of generative modelling to reduce computational requirements. Most models from literature use sample rates of 16 or 24 kHz.</p>

<figure>
  <a href="https://sander.ai/images/digital_waveform.gif"><img src="https://sander.ai/images/digital_waveform.gif" alt="Digital waveform."/></a>
  <figcaption>Digital waveform. The individual samples become visible as the zoom level increases. Figure taken from <a href="https://deepmind.com/blog/article/wavenet-generative-model-raw-audio">the original WaveNet blog post</a>.</figcaption>
</figure>

<p>When we also quantise the amplitude, some loss of fidelity is inevitable. CD quality uses 16 bits per sample, representing 2<sup>16</sup> equally spaced quantisation levels. If we want to use fewer bits, we can use logarithmically spaced quantisation levels instead to account for our nonlinear perception of loudness. This <strong><a href="https://en.wikipedia.org/wiki/%CE%9C-law_algorithm">“mu-law companding”</a></strong> will result in a smaller perceived loss of fidelity than if the levels were equally spaced.</p>

<h2 id="-generative-models"><a name="generative-models"></a> Generative models</h2>

<p>Given a dataset \(X\) of examples \(x \in X\), which we assume to have been drawn independently from some underlying distribution \(p_X(x)\), a generative model can learn to approximate this distribution \(p_X(x)\). Such a model could be used to generate new samples that look like they could have been part of the original dataset. We distinguish <em>implicit</em> and <em>explicit</em> generative models: an implicit model can produce new samples \(x \sim p_X(x)\), but cannot be used to infer the likelihood of an example (i.e. we cannot tractably compute \(p_X(x)\) given \(x\)). If we have an explicit model, we can do this, though sometimes only up to an unknown normalising constant.</p>

<h3 id="conditional-generative-models">Conditional generative models</h3>

<p>Generative models become more practically useful when we can exert some influence over the samples we draw from them. We can do this by providing a <strong>conditioning signal</strong> \(c\), which contains side information about the kind of samples we want to generate. The model is then fit to the conditional distribution \(p_X(x \vert c)\) instead of \(p_X(x)\).</p>

<p>Conditioning signals can take many shapes or forms, and it is useful to distinguish different levels of information content. The generative modelling problem becomes easier if the conditioning signal \(c\) is richer, because it reduces uncertainty about \(x\). We will refer to conditioning signals with low information content as <em>sparse conditioning</em>, and those with high information content as <em>dense conditioning</em>. Examples of conditioning signals in the image domain and the music audio domain are shown below, ordered according to density.</p>

<figure>
  <img src="https://sander.ai/images/sparse-dense-conditioning.svg" alt="Examples of sparse and dense conditioning signals in the image domain (top) and the music audio domain (bottom)."/>
  <figcaption>Examples of sparse and dense conditioning signals in the image domain (top) and the music audio domain (bottom).</figcaption>
</figure>

<p>Note that the density of a conditioning signal is often correlated with its level of abstraction: high-level side information tends to be more sparse. Low-level side information isn’t necessarily dense, though. For example, we could condition a generative model of music audio on a low-dimensional vector that captures the overall timbre of an instrument. This is a low-level aspect of the audio signal, but it constitutes a sparse conditioning signal.</p>

<h3 id="likelihood-based-models">Likelihood-based models</h3>

<p>Likelihood-based models directly parameterise \(p_X(x)\). The parameters \(\theta\) are then fit by maximising the likelihood of the data under the model:</p><p>

\[\mathcal{L}_\theta(x) = \sum_{x \in X} \log p_X(x|\theta) \quad \quad \theta^* = \arg \max_\theta \mathcal{L}_\theta(x) .\]

</p><p>Note that this is typically done in the log-domain because it simplifies computations and improves numerical stability. Because the model directly parameterises \(p_X(x)\), we can <strong>easily infer the likelihood of any</strong> \(x\), so we get an explicit model. Three popular flavours of likelihood-based models are autoregressive models, flow-based models and variational autoencoders. The following three subsections provide a brief overview of each.</p>

<h3 id="autoregressive-models">Autoregressive models</h3>

<p>In an autoregressive model, we assume that our examples \(x \in X\) can be treated as sequences \(\{x_i\}\). We then factorise the distribution into a product of conditionals, using the <a href="https://en.wikipedia.org/wiki/Chain_rule_(probability)">chain rule of probability</a>:</p><p>

\[p_X(x) = \prod_i p(x_i \vert x_{&lt;i}) .\]

</p><p>These conditional distributions are typically scalar-valued and much easier to model. Because we further assume that the distribution of the sequence elements is stationary, we can share parameters and use the same model for all the factors in this product.</p>

<p>For audio signals, this is a very natural thing to do, but we can also do this for other types of structured data by arbitrarily choosing an order (e.g. raster scan order for images, as in PixelRNN<sup id="fnref:pixelrnn" role="doc-noteref"><a href="#fn:pixelrnn" rel="footnote">2</a></sup> and PixelCNN<sup id="fnref:pixelcnn" role="doc-noteref"><a href="#fn:pixelcnn" rel="footnote">3</a></sup>).</p>

<p>Autoregressive models are attractive because they are able to <strong>accurately capture correlations between the different elements</strong> \(x_i\) in a sequence, and they allow for fast inference (i.e. computing \(p_X(x)\) given \(x\)). Unfortunately they tend to be <strong>slow to sample from</strong>, because samples need to be drawn sequentially from the conditionals for each position in the sequence.</p>

<h3 id="flow-based-models">Flow-based models</h3>

<p>Another strategy for constructing a likelihood-based model is to use the <strong><a href="https://en.wikipedia.org/wiki/Probability_density_function#Function_of_random_variables_and_change_of_variables_in_the_probability_density_function">change of variables theorem</a></strong> to transform \(p_X(x)\) into a simple, factorised distribution \(p_Z(z)\) (standard Gaussian is a popular choice) using an invertible mapping \(x = g(z)\):</p><p>

\[p_X(x) = p_Z(z) \cdot |\det J|^{-1} \quad \quad J = \frac{dg(z)}{dz}.\]

</p><p>Here, \(J\) is the Jacobian of \(g(z)\). Models that use this approach are referred to as normalising flows or flow-based models<sup id="fnref:nice" role="doc-noteref"><a href="#fn:nice" rel="footnote">4</a></sup><sup id="fnref:realnvp" role="doc-noteref"><a href="#fn:realnvp" rel="footnote">5</a></sup>. They are fast both for inference and sampling, but the <strong>requirement for \(g(z)\) to be invertible significantly constrains the model architecture</strong>, and it makes them less parameter-efficient. In other words: flow-based models need to be quite large to be effective.</p>

<p>For an in-depth treatment of flow-based models, I recommend Eric Jang’s <a href="https://blog.evjang.com/2018/01/nf1.html">two-part blog post</a> on the subject, and <a href="https://arxiv.org/abs/1912.02762">Papamakarios et al.’s excellent review paper</a>.</p>

<h3 id="variational-autoencoders-vaes">Variational autoencoders (VAEs)</h3>

<p>By far the most popular class of likelihood-based generative models, I can’t avoid mentioning variational<sup id="fnref:vaerezende" role="doc-noteref"><a href="#fn:vaerezende" rel="footnote">6</a></sup> autoencoders<sup id="fnref:vaekingma" role="doc-noteref"><a href="#fn:vaekingma" rel="footnote">7</a></sup> – but <strong>in the context of waveform modelling, they are probably the least popular approach</strong>. In a VAE, we jointly learn two neural networks: an <em>inference network</em> \(q(z \vert x)\) learns to probabilistically map examples \(x\) into a latent space, and a <em>generative network</em> \(p(x \vert z)\) learns the distribution of the data conditioned on a latent representation \(z\). These are trained to maximise a lower bound on \(p_X(x)\), called the ELBO (Evidence Lower BOund), because computing \(p_X(x)\) given \(x\) (exact inference) is not tractable.</p>

<p>Typical VAEs assume a factorised distribution for \(p(x \vert z)\), which limits the extent to which they can capture dependencies in the data. While this is often an acceptable trade-off, in the case of waveform modelling it turns out to be a problematic restriction in practice. I believe this is why not a lot of work has been published that takes this approach (if you know of any, please point me to it). VAEs can also have more powerful decoders with fewer assumptions (autoregressive decoders, for example), but this may introduce other issues such as posterior collapse<sup id="fnref:pc" role="doc-noteref"><a href="#fn:pc" rel="footnote">8</a></sup>.</p>

<p>To learn more about VAEs, check out <a href="https://jaan.io/what-is-variational-autoencoder-vae-tutorial/">Jaan Altosaar’s tutorial</a>.</p>

<h3 id="adversarial-models">Adversarial models</h3>

<p>Generative Adversarial Networks<sup id="fnref:gans" role="doc-noteref"><a href="#fn:gans" rel="footnote">9</a></sup> (GANs) take a very different approach to capturing the data distribution. Two networks are trained simultaneously: a <em>generator</em> \(G\) attempts to produce examples according to the data distribution \(p_X(x)\), given latent vectors \(z\), while a <em>discriminator</em> \(D\) attempts to tell apart generated examples and real examples. In doing so, the discriminator provides a learning signal for the generator which enables it to better match the data distribution. In the original formulation, the loss function is as follows:</p><p>

\[\mathcal{L}(x) = \mathbb{E}_x[\log D(x)] + \mathbb{E}_z[log(1 - D(G(z)))] .\]

</p><p>The generator is trained to minimise this loss, whereas the discriminator attempts to maximise it. This means the training procedure is a <strong>two-player minimax game</strong>, rather than an optimisation process, as it is for most machine learning models. Balancing this game and keeping training stable has been one of the main challenges for this class of models. Many alternative formulations have been proposed to address this.</p>

<p>While adversarial and likelihood-based models are both ultimately trying to model \(p_X(x)\), they approach this target from very different angles. As a result, <strong>GANs tend to be better at producing realistic examples, but worse at capturing the full diversity of the data distribution</strong>, compared to likelihood-based models.</p>

<h3 id="more-exotic-flavours">More exotic flavours</h3>

<p>Many other strategies to learn models of complicated distributions have been proposed in literature. While research on waveform generation has chiefly focused on the two dominant paradigms of likelihood-based and adversarial models, some of these alternatives may hold promise in this area as well, so I want to mention a few that I’ve come across.</p>

<ul>
  <li>
    <p><strong>Energy-based models</strong> measure the “energy” of examples, and are trained by fitting the model parameters so that examples coming from the dataset have low energy, whereas all other configurations of inputs have high energy. This amounts to fitting an unnormalised density.  A nice recent example is <a href="https://openai.com/blog/energy-based-models/">the work by Du &amp; Mordatch at OpenAI</a><sup id="fnref:energy" role="doc-noteref"><a href="#fn:energy" rel="footnote">10</a></sup>. Energy-based models have been around for a very long time though, and one could argue that likelihood-based models are a special case.</p>
  </li>
  <li>
    <p><strong>Optimal transport</strong> is another approach to measure the discrepancy between probability distributions, which has served as inspiration for new variants of generative adversarial networks<sup id="fnref:wgan" role="doc-noteref"><a href="#fn:wgan" rel="footnote">11</a></sup> and autoencoders<sup id="fnref:swa" role="doc-noteref"><a href="#fn:swa" rel="footnote">12</a></sup>.</p>
  </li>
  <li>
    <p><strong>Autoregressive implicit quantile networks</strong><sup id="fnref:aiqn" role="doc-noteref"><a href="#fn:aiqn" rel="footnote">13</a></sup> use a similar network architecture as likelihood-based autoregressive models, but they are trained using the quantile regression loss, rather than maximimum likelihood.</p>
  </li>
  <li>
    <p>Two continuous distributions can be matched by minimising the L2 distance between the gradients of the density functions with respect to their inputs: \(\mathcal{L}(x) = \mathbb{E} [\vert\vert \nabla_x \log p_X(x) - \nabla_y \log p_Y(y) \vert\vert ^2]\). This is called <strong>score matching</strong><sup id="fnref:scorematching" role="doc-noteref"><a href="#fn:scorematching" rel="footnote">14</a></sup> and some recent works have revisited this idea for density estimation<sup id="fnref:ssm" role="doc-noteref"><a href="#fn:ssm" rel="footnote">15</a></sup> and generative modelling<sup id="fnref:scorebased" role="doc-noteref"><a href="#fn:scorebased" rel="footnote">16</a></sup>.</p>
  </li>
  <li>
    <p>Please share any others that I haven’t mentioned in the comments!</p>
  </li>
</ul>

<h3 id="mode-covering-vs-mode-seeking-behaviour">Mode-covering vs. mode-seeking behaviour</h3>

<p>An important consideration when determining which type of generative model is appropriate for a particular application, is the degree to which it is <em>mode-covering</em> or <em>mode-seeking</em>. When a model does not have enough capacity to capture all the variability in the data, different compromises can be made. If all examples should be reasonably likely under the model, it will have to overgeneralise and put probability mass on interpolations of examples that may not be meaningful (mode-covering). If there is no such requirement, the probability mass can be focused on a subset of examples, but then some parts of the distribution will be ignored by the model (mode-seeking).</p>

<figure>
  <a href="https://sander.ai/images/mode_seeking_covering.png"><img src="https://sander.ai/images/mode_seeking_covering.png" alt="Illustration of mode-seeking and mode-covering behaviour in model fitting."/></a>
  <figcaption>Illustration of mode-seeking and mode-covering behaviour in model fitting. The blue density represents the data distribution. The green density is our model, which is a single Gaussian. Because the data distribution is multimodal, our model does not have enough capacity to accurately capture it.</figcaption>
</figure>

<p><strong>Likelihood-based models are usually mode-covering</strong>. This is a consequence of the fact that they are fit by maximising the joint likelihood of the data. <strong>Adversarial models on the other hand are typically mode-seeking</strong>. A lot of ongoing research is focused on making it possible to control the trade-off between these two behaviours directly, without necessarily having to switch the class of models that are used.</p>

<p>In general, mode-covering behaviour is desirable in sparsely conditioned applications, where we want diversity or we expect a certain degree of “creativity” from the model. Mode-seeking behaviour is more useful in densely-conditioned settings, where most of the variability we care about is captured in the conditioning signal, and we favour realism of the generated output over diversity.</p>

<h2 id="-likelihood-based-models-of-waveforms"><a name="likelihood-based-models"></a> Likelihood-based models of waveforms</h2>

<p>In this section, I’ll try to summarise some of the key results from the past four years obtained with likelihood-based models of waveforms. While this blog post is supposed to be about music, note that many of these developments were initially targeted at generating speech, so inevitably I will also be talking about some work in the text-to-speech (TTS) domain. I recommend reading the associated papers and/or blog posts to find out more about each of these works.</p>

<h3 id="wavenet--samplernn">WaveNet &amp; SampleRNN</h3>

<figure>
  <a href="https://sander.ai/images/wavenet.gif"><img src="https://sander.ai/images/wavenet.gif" alt="Wavenet sampling procedure."/></a>
  <figcaption>Animation showing sampling from a WaveNet model. The model predicts the distribution of potential signal values for each timestep, given past signal values.</figcaption>
</figure>

<p>WaveNet<sup id="fnref:wavenet" role="doc-noteref"><a href="#fn:wavenet" rel="footnote">17</a></sup> and SampleRNN<sup id="fnref:samplernn" role="doc-noteref"><a href="#fn:samplernn" rel="footnote">18</a></sup> are <strong>autoregressive models of raw waveforms</strong>. While WaveNet is a convolutional neural network, SampleRNN uses a stack of recurrent neural networks. Both papers appeared on arXiv in late 2016 with only a few months in between, signalling that autoregressive waveform-based audio modelling was an idea whose time had come. Before then, this idea had not been seriously considered, as modelling long-term correlations in sequences across thousands of timesteps did not seem feasible with the tools that were available at that point. Furthermore, discriminative models of audio all used spectral input representations, with only a few works investigating the use of raw waveforms in this setting (and usually with worse results).</p>

<p>Although these models have their flaws (including slow sampling due to autoregressivity, and a lack of interpretability w.r.t. what actually happens inside the network), I think they constituted an important <em>existence proof</em> that encouraged further research into waveform-based models.</p>

<p>WaveNet’s strategy to deal with long-term correlations is to use <em>dilated convolutions</em>: successive convolutional layers use filters with gaps between their inputs, so that the connectivity pattern across many layers forms a tree structure (see figure above). This enables rapid growth of the receptive field, which means that <strong>a WaveNet with only a few layers can learn dependencies across many timesteps</strong>. Note that the convolutions used in WaveNet are causal (no connectivity from future to past), which forces the model to learn to predict what values the signal could take at each position in time.</p>

<p>SampleRNN’s strategy is a bit different: multiple RNNs are stacked on top of each other, with each running at a different frequency. Higher-level RNNs update less frequently, which means they can more easily capture long-range correlations and learn high-level features.</p>

<p>Both models demonstrated excellent text-to-speech results, surpassing the state of the art at the time (concatenative synthesis, for most languages) in terms of naturalness. Both models were also applied to (piano) music generation, which constituted a nice demonstration of the promise of music generation in the waveform domain, but they were clearly limited in their ability to capture longer-term musical structure.</p>

<p>
<strong>WaveNet</strong>: <a href="https://arxiv.org/abs/1609.03499">paper</a> - <a href="https://deepmind.com/blog/article/wavenet-generative-model-raw-audio">blog post</a></p>

<h3 id="parallel-wavenet--clarinet">Parallel WaveNet &amp; ClariNet</h3>

<p>Sampling from autoregressive models of raw audio can be quite slow and impractical. To address this issue, Parallel WaveNet<sup id="fnref:parallelwavenet" role="doc-noteref"><a href="#fn:parallelwavenet" rel="footnote">19</a></sup> uses <em>probability density distillation</em> to train a model from which samples can be drawn in a single feed-forward pass. This requires a trained autoregressive WaveNet, which functions as a teacher, and an inverse autoregressive flow (IAF) model which acts as the student and learns to mimic the teacher’s predictions.</p>

<p>While an autoregressive model is slow to sample from, inferring the likelihood of a given example (and thus, maximum-likelihood training) can be done in parallel. <strong>For an inverse autoregressive flow, it’s the other way around: sampling is fast, but inference is slow</strong>. Since most practical applications rely on sampling rather than inference, such a model is often better suited. IAFs are hard to train from scratch though (because that requires inference), and the probability density distillation approach makes training them tractable.</p>

<p>Due to the nature of the probability density distillation objective, the student will end up matching the teacher’s predictions in a way that minimises the <em>reverse</em> KL divergence. This is quite unusual: likelihood-based models are typically trained to minimise the forward KL divergence instead, which is equivalent to maximising the likelihood (and minimising the reverse KL is usually intractable). While minimising the forward KL leads to mode-covering behaviour, <strong>minimising the reverse KL will instead lead to mode-seeking behaviour</strong>, which means that the model may end up ignoring certain modes in the data distribution.</p>

<p>In the text-to-speech (TTS) setting, this may actually be exactly what we want: given an excerpt of text, we want the model to generate a realistic utterance corresponding to that excerpt, but we aren’t particularly fussed about being able to generate every possible variation – one good-sounding utterance will do. This is a setting where <strong>realism is clearly more important than diversity</strong>, because all the diversity that we care about is already captured in the conditioning signal that we provide. This is usually the setting where adversarial models excel, because of their inherent mode-seeking behaviour, but using probability density distillation we can also train likelihood-based models this way.</p>

<p>To prevent the model from collapsing, parallel WaveNet uses a few additional loss terms to encourage the produced waveforms to resemble speech (such as a loss on the average power spectrum).</p>

<p>If we want to do music generation, we will typically care more about diversity because the conditioning signals we provide to the model are weaker. I believe this is why we haven’t really seen the Parallel WaveNet approach catch on outside of TTS.</p>

<p>ClariNet<sup id="fnref:clarinet" role="doc-noteref"><a href="#fn:clarinet" rel="footnote">20</a></sup> was introduced as a variant of Parallel WaveNet which uses a Gaussian inverse autoregressive flow. The Gaussian assumption makes it possible to compute the reverse KL in closed form, rather than having to approximate it by sampling, which stabilises training.</p>

<p>
<strong>Parallel WaveNet</strong>: <a href="https://arxiv.org/abs/1711.10433">paper</a> - <a href="https://deepmind.com/blog/article/high-fidelity-speech-synthesis-wavenet">blog post 1</a> - <a href="https://deepmind.com/blog/article/wavenet-launches-google-assistant">blog post 2</a></p>

<h3 id="flow-based-models-waveglow-flowavenet-waveflow-blow">Flow-based models: WaveGlow, FloWaveNet, WaveFlow, Blow</h3>

<p>Training an IAF with probability density distillation isn’t the only way to train a flow-based model: most can be trained by maximum likelihood instead. In that case, the models will be encouraged to capture all the modes of the data distribution. This, in combination with their relatively low parameter efficiency (due to the invertibility requirement), means that they might need to be a bit larger to be effective. On the other hand, <strong>they allow for very fast sampling because all timesteps can be generated in parallel</strong>, so while the computational cost may be higher, sampling will still be faster in practice. Another advantage is that no additional loss terms are required to prevent collapse.</p>

<p>WaveGlow<sup id="fnref:waveglow" role="doc-noteref"><a href="#fn:waveglow" rel="footnote">21</a></sup> and FloWaveNet<sup id="fnref:flowavenet" role="doc-noteref"><a href="#fn:flowavenet" rel="footnote">22</a></sup>, both originally published in late 2018, are flow-based models of raw audio conditioned on mel-spectrograms, which means they can be used as <em>vocoders</em>. Because of the limited parameter efficiency of flow-based models, I suspect that it would be difficult to use them for music generation in the waveform domain, where conditioning signals are much more sparse – but they could of course be used to render mel-spectrograms generated by some other model into waveforms (more on that later).</p>

<p>WaveFlow<sup id="fnref:waveflow" role="doc-noteref"><a href="#fn:waveflow" rel="footnote">23</a></sup> (with an F instead of a G) is a more recent model that improves parameter efficiency by combining the flow-based modelling approach with partial autoregressivity to model local signal structure. This allows for a trade-off between sampling speed and model size. Blow<sup id="fnref:blow" role="doc-noteref"><a href="#fn:blow" rel="footnote">24</a></sup> is a flow-based model of waveforms for non-parallel voice conversion.</p>

<p>
<strong>WaveGlow</strong>: <a href="https://arxiv.org/abs/1811.00002">paper</a> - <a href="https://github.com/NVIDIA/waveglow">code</a> - <a href="https://nv-adlr.github.io/WaveGlow">samples</a></p>

<h3 id="hierarchical-wavenets">Hierarchical WaveNets</h3>

<p>For the purpose of music generation, <strong>WaveNet is limited by its ability to capture longer-term signal structure</strong>, as previously stated. In other words: while it is clearly able to capture local signal structure very well (i.e. the timbre of an instrument), it isn’t able to model the evolution of chord progressions and melodies over longer time periods. This makes the outputs produced by this model sound rather improvisational, to put it nicely.</p>

<p>This may seem counterintuitive at first: the tree structure of the connectivity between the layers of the model should allow for a very rapid growth of its receptive field. So if you have a WaveNet model that captures up to a second of audio at a time (more than sufficient for TTS), stacking a few more dilated convolutional layers on top should suffice to grow the receptive field by several orders of magnitude (up to many minutes). At that point, the model should be able to capture any kind of meaningful musical structure.</p>

<p>In practice, however, we need to train models on excerpts of audio that are at least as long as the longest-range correlations that we want to model. So while the depth of the model has to grow only logarithmically as we increase the desired receptive field, <strong>the computational and memory requirements for training do in fact grow linearly</strong>. If we want to train a model that can learn about musical structure across tens of seconds, that will necessarily be an order of magnitude more expensive – and WaveNets that generate music already have to be quite large as it is, even with a receptive field of just one second, because <strong>music is harder to model than speech</strong>. Note also that one second of audio corresponds to a sequence of 16000 timesteps at 16 kHz, so even at a scale of seconds, we are already modelling very long sequences.</p>

<p>In 10 years, the hardware we would need to train a WaveNet with a receptive field of 30 seconds (or almost half a million timesteps at 16 kHz) may just fit in a desktop computer, so we could just wait until then to give it a try. But if we want to train such models today, we need a different strategy. If we could train separate models to capture structure at different timescales, we could have a dedicated model that focuses on capturing longer-range correlations, without having to also model local signal structure. This seems feasible, seeing as models of high-level representations of music (i.e. scores or MIDI) clearly do a much better job of capturing long-range musical structure already.</p>

<p>We can approach this as a <strong>representation learning</strong> problem: to decouple learning of local and large-scale structure, we need to extract a more compact, high-level representation \(h\) from the audio signals \(x\), that makes abstraction of local detail and has a much lower sample rate. Ideally, we would learn a model \(h = f(x)\) to extract such a representation from data (although using existing high-level representations like MIDI is also possible, as we’ll discuss later).</p>

<p>Then we can split up the task by training two separate models: a WaveNet that models the high-level representation: \(p_H(h)\), and another that models the local signal structure, conditioned on the high-level representation: \(p_{X \vert H}(x \vert h)\). The former model can focus on learning about long-range correlations, as local signal structure is not present in the representation it operates on. The latter model, on the other hand, can focus on learning about local signal structure, as relevant information about large-scale structure is readily available in its conditioning signal. Combined together, these models can be used to sample new audio signals by first sampling \(\hat{h} \sim p_H(h)\) and then \(\hat{x} \sim p_{X \vert H}(x \vert \hat{h})\).</p>

<p>We can learn both \(f(x)\) and \(p_{X \vert H}(x \vert h)\) together by training an <em>autoencoder</em>: \(f(x)\) is the encoder, a feed-forward neural network, and \(p_{X \vert H}(x \vert h)\) is the decoder, a conditional WaveNet. Learning these jointly will enable \(f(x)\) to adapt to the WaveNet, so that it extracts information that the WaveNet cannot easily model itself.</p>

<p>To make the subsequent modelling of \(h = f(x)\) with another WaveNet easier, we use a VQ-VAE<sup id="fnref:vqvae" role="doc-noteref"><a href="#fn:vqvae" rel="footnote">25</a></sup>: an <strong>autoencoder with a discrete bottleneck</strong>. This has two important consequences:</p>
<ul>
  <li><strong>Autoregressive models seem to be more effective on discrete sequences</strong> than on continuous ones. Making the high-level representation discrete makes the hierarchical modelling task much easier, as we don’t need to adapt the WaveNet model to work with continuous data.</li>
  <li>The discreteness of the representation also <strong>limits its information capacity</strong>, forcing the autoencoder to encode only the most important information in \(h\), and to use the autoregressive connections in the WaveNet decoder to capture any local structure that wasn’t encoded in \(h\).</li>
</ul>

<p>To split the task into more than two parts, we can apply this procedure again to the high-level representation \(h\) produced by the first application, and <strong>repeat this until we get a hierarchy with as many levels as desired</strong>. Higher levels in the hierarchy make abstraction of more and more of the low-level details of the signal, and have progressively lower sample rates (yielding shorter sequences). a three-level hierarchy is shown in the diagram below. Note that <strong>each level can be trained separately and in sequence</strong>, thus greatly reducing the computational requirements of training a model with a very large receptive field.</p>

<figure>
  <img src="https://sander.ai/images/hierarchical_wavenet.svg" alt="Hierarchical WaveNet model, consisting of (conditional) autoregressive models of several levels of learnt discrete representations."/>
  <figcaption>Hierarchical WaveNet model, consisting of (conditional) autoregressive models of several levels of learnt discrete representations.</figcaption>
</figure>

<p>My colleagues and I explored this idea and trained hierachical WaveNet models on piano music<sup id="fnref:challenge" role="doc-noteref"><a href="#fn:challenge" rel="footnote">26</a></sup>. We found that there was a trade-off between audio fidelity and long-range coherence of the generated samples. When more model capacity was repurposed to focus on long-range correlations, this reduced the capability of the model to capture local structure, resulting in lower perceived audio quality. We also conducted a human evaluation study where we asked several listeners to rate both the fidelity and the musicality of some generated samples, to demonstrate that hierarchical models produce samples which sound more musical.</p>

<p>
<strong>Hierarchical WaveNet</strong>: <a href="https://papers.nips.cc/paper/8023-the-challenge-of-realistic-music-generation-modelling-raw-audio-at-scale">paper</a> - <a href="https://drive.google.com/drive/folders/1s7yGi928cMla8gZhfQKNXACPACSrJ9Vg">samples</a>
</p>

<h3 id="-wave2midi2wave-and-the-maestro-dataset"><a name="wave2midi2wave"></a> Wave2Midi2Wave and the MAESTRO dataset</h3>

<p>As alluded to earlier, rather than learning high-level representations of music audio from data, we could also <strong>use existing high-level representations such as MIDI</strong> to construct a hierarchical model. We can use a powerful language model to model music in the symbolic domain, and also construct a conditional WaveNet model that generates audio, given a MIDI representation. Together with my colleagues from the Magenta team at Google AI, <a href="https://magenta.tensorflow.org/maestro-wave2midi2wave">we trained such models</a> on a new dataset called MAESTRO, which features 172 hours of virtuosic piano performances, captured with fine alignment between note labels and audio waveforms<sup id="fnref:maestro" role="doc-noteref"><a href="#fn:maestro" rel="footnote">27</a></sup>. This dataset is <a href="https://magenta.tensorflow.org/datasets/maestro">available to download</a> for research purposes.</p>

<p>Compared to hierarchical WaveNets with learnt intermediate representations, this approach yields much better samples in terms of musical structure, but it is limited to instruments and styles of music that MIDI can accurately represent. Manzelli et al. <a href="http://people.bu.edu/bkulis/projects/music/index.html">have demonstrated this approach</a> for a few instruments other than piano<sup id="fnref:manzellithakkar" role="doc-noteref"><a href="#fn:manzellithakkar" rel="footnote">28</a></sup>, but the lack of available aligned data could pose a problem.</p>

<figure>
  <img src="https://sander.ai/images/wave2midi2wave.png" alt="Wave2Midi2Wave: a transcription model to go from audio to MIDI, a transformer to model MIDI sequences and a WaveNet to synthesise audio given a MIDI sequence."/>
  <figcaption>Wave2Midi2Wave: a transcription model to go from audio to MIDI, a transformer to model MIDI sequences and a WaveNet to synthesise audio given a MIDI sequence.</figcaption>
</figure>

<p>
<strong>Wave2Midi2Wave</strong>: <a href="https://openreview.net/forum?id=r1lYRjC9F7">paper</a> - <a href="https://magenta.tensorflow.org/maestro-wave2midi2wave">blog post</a> - <a href="https://storage.googleapis.com/magentadata/papers/maestro/index.html">samples</a> - <a href="https://magenta.tensorflow.org/datasets/maestro">dataset</a></p>

<h3 id="sparse-transformers">Sparse transformers</h3>

<p>OpenAI introduced the <a href="https://openai.com/blog/sparse-transformer/">Sparse Transformer</a> model<sup id="fnref:sparsetransformer" role="doc-noteref"><a href="#fn:sparsetransformer" rel="footnote">29</a></sup>, a large transformer<sup id="fnref:transformer" role="doc-noteref"><a href="#fn:transformer" rel="footnote">30</a></sup> with a <strong>sparse attention mechanism</strong> that scales better to long sequences than traditional attention (which is quadratic in the length of the modelled sequence). They demonstrated impressive results autoregressively modelling language, images, and music audio using this architecture, with sparse attention enabling their model to cope with waveforms of up to 65k timesteps (about 5 seconds at 12 kHz). The sparse attention mechanism seems like a good alternative to the stacked dilated convolutions of WaveNets, provided that an efficient implementation is available.</p>

<p>
<strong>Sparse Transformer</strong>: <a href="https://arxiv.org/abs/1904.10509">paper</a> - <a href="https://openai.com/blog/sparse-transformer/">blog post</a> - <a href="https://soundcloud.com/openai_audio/sets/sparse_transformers">samples</a>
</p>

<h3 id="universal-music-translation-network">Universal music translation network</h3>

<p>An interesting conditional waveform modelling problem is that of “music translation” or “music style transfer”: given a waveform, <strong>render a new waveform where the same music is played by a different instrument</strong>. The Universal Music Translation Network<sup id="fnref:umtn" role="doc-noteref"><a href="#fn:umtn" rel="footnote">31</a></sup> tackles this by training an autoencoder with multiple WaveNet decoders, where the encoded representation is encouraged to be agnostic to the instrument of the input (using an adversarial loss). A separate decoder is trained for each target instrument, so once this representation is extracted from a waveform, it can be synthesised in an instrument of choice. The separation is not perfect, but it works surprisingly well in practice. I think this is a nice example of a model that combines ideas from both likelihood-based models and the adversarial learning paradigm.</p>

<p>
<strong>Universal music translation network</strong>: <a href="https://openreview.net/forum?id=HJGkisCcKm">paper</a> - <a href="https://github.com/facebookresearch/music-translation">code</a> - <a href="https://musictranslation.github.io/">samples</a>
</p>

<h3 id="dadabots">Dadabots</h3>

<p><a href="http://dadabots.com">Dadabots</a> are a researcher / artist duo who have trained SampleRNN models on various albums (primarily metal) in order to produce more music in the same vein. These models aren’t great at capturing long-range correlations, so it works best for artists whose style is naturally a bit disjointed. Below is a 24 hour livestream they’ve set up with a model generating infinite technical death metal in the style of ‘Relentless Mutation’ by Archspire.</p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/MwtVkPKx3RA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>

<h2 id="-adversarial-models-of-waveforms"><a name="adversarial-models"></a> Adversarial models of waveforms</h2>

<p>Adversarial modelling of audio has only recently started to see some successes, which is why this section is going to be a lot shorter than the previous one on likelihood-based models. The adversarial paradigm has been extremely successful in the image domain, but researchers have had a harder time translating that success to other domains and modalities, compared to likelihood-based models. As a result, published work so far has primarily focused on speech generation and the generation of individual notes or very short clips of music. As a field, we are still very much in the process of figuring out how to make GANs work well for audio at scale.</p>

<h3 id="wavegan">WaveGAN</h3>

<p>One of the first works to attempt using GANs for modelling raw audio signals is WaveGAN<sup id="fnref:wavegan" role="doc-noteref"><a href="#fn:wavegan" rel="footnote">32</a></sup>. They trained a GAN on single-word speech recordings, bird vocalisations, individual drum hits and short excerpts of piano music. They also compared their raw audio-based model with a spectrogram-level model called SpecGAN. Although the fidelity of the <a href="https://chrisdonahue.com/wavegan_examples/">resulting samples</a> is far from perfect in some cases, this work undoubtedly inspired a lot of researchers to take audio modelling with GANs more seriously.</p>

<p>
<strong>WaveGAN</strong>: <a href="https://openreview.net/forum?id=ByMVTsR5KQ">paper</a> - <a href="https://github.com/chrisdonahue/wavegan">code</a> - <a href="https://chrisdonahue.com/wavegan_examples/">samples</a> - <a href="https://chrisdonahue.com/wavegan/">demo</a> - <a href="https://colab.research.google.com/drive/1e9o2NB2GDDjadptGr3rwQwTcw-IrFOnm">colab</a>
</p>

<h3 id="gansynth">GANSynth</h3>

<p>So far in this blog post, we have focused on generating audio waveforms directly. However, I don’t want to omit GANSynth<sup id="fnref:gansynth" role="doc-noteref"><a href="#fn:gansynth" rel="footnote">33</a></sup>, even though technically speaking it does not operate directly in the waveform domain. This is because the spectral representation it uses is <strong>exactly invertible</strong> – no other models or phase reconstruction algorithms are used to turn the spectograms it generates into waveforms, which means it shares a lot of the advantages of models that operate directly in the waveform domain.</p>

<p>As <a href="#why-waveforms">discussed before</a>, modelling the phase component of a complex spectrogram is challenging, because the phase of real audio signals can seem essentially random. However, using some of its unique characteristics, we can transform the phase into a quantity that is easier to model and reason about: the <em>instantaneous frequency</em>. This is obtained by computing the temporal difference of the <em>unwrapped</em> phase between subsequent frames. “Unwrapping” means that we shift the phase component by a multiple of \(2 \pi\) for each frame as needed to make it monotonic over time, as shown in the diagram below (because phase is an angle, all values modulo \(2 \pi\) are equivalent).</p>

<p><strong>The instantaneous frequency captures how much the phase of a signal moves from one spectrogram frame to the next</strong>. For harmonic sounds, this quantity is expected to be constant over time, as the phase rotates at a constant velocity. This makes this representation particularly suitable to model musical sounds, which have a lot of harmonic content (and in fact, it might also make the representation less suitable for modelling more general classes of audio signals, though I don’t know if anyone has tried). For harmonic sounds, the instantaneous frequency is almost trivial to predict.</p>

<p>GANSynth is an adversarial model trained to produce the magnitude and instantaneous frequency spectrograms of recordings of individual musical notes. The trained model is also able to generalise to sequences of notes to some degree. <a href="https://magenta.tensorflow.org/gansynth">Check out the blog post</a> for sound examples and more information.</p>

<figure>
  <img src="https://sander.ai/images/gansynth1.png" alt="Waveform with specrogram frame boundaries indicated as dotted lines."/>
  <img src="https://sander.ai/images/gansynth2.png" alt="From phase to instantaneous frequency."/>
  <img src="https://sander.ai/images/gansynth3.png" alt="Visualisations of the magnitude, phase, unwrapped phase and instantaneous frequency spectra of a real recording of a note."/>
  <figcaption><strong>Top</strong>: waveform with specrogram frame boundaries indicated as dotted lines. <strong>Middle</strong>: from phase to instantaneous frequency. <strong>Bottom</strong>: visualisations of the magnitude, phase, unwrapped phase and instantaneous frequency spectra of a real recording of a note.</figcaption>
</figure>

<p>
<strong>GANSynth</strong>: <a href="https://openreview.net/forum?id=H1xQVn09FX">paper</a> - <a href="http://goo.gl/magenta/gansynth-code">code</a> - <a href="http://goo.gl/magenta/gansynth-examples">samples</a> - <a href="https://magenta.tensorflow.org/gansynth">blog post</a> - <a href="http://goo.gl/magenta/gansynth-demo">colab</a>
</p>

<h3 id="-melgan--gan-tts"><a name="melgan-gantts"></a> MelGAN &amp; GAN-TTS</h3>

<p>Two recent papers demonstrate excellent results using GANs for text-to-speech: MelGAN<sup id="fnref:melgan" role="doc-noteref"><a href="#fn:melgan" rel="footnote">34</a></sup> and GAN-TTS<sup id="fnref:gantts" role="doc-noteref"><a href="#fn:gantts" rel="footnote">35</a></sup>. The former also includes some music synthesis results, although fidelity is still an issue in that domain. The focus of MelGAN is inversion of magnitude spectrograms (potentially generated by other models), whereas as GAN-TTS is conditioned on the same “linguistic features” as the original WaveNet for TTS.</p>

<p>The architectures of both models share some interesting similarities, which shed light on the right inductive biases for raw waveform discriminators. Both models use <strong>multiple discriminators at different scales</strong>, each of which operates on a <strong>random window</strong> of audio extracted from the full sequence produced by the generator. This is similar to the patch-based discriminators that have occasionally been used in GANs for image generation. This windowing strategy seems to dramatically improve the capability of the generator to <strong>correctly model high frequency content</strong> in the audio signals, which is much more crucial to get right for audio than for images because it more strongly affects perceptual quality. The fact that both models benefited from this particular discriminator design indicates that we may be on the way to figuring out how to best design discriminator architectures for raw audio.</p>

<p>There are also some interesting differences: where GAN-TTS uses a combination of conditional and unconditional discriminators, MelGAN uses only unconditional discriminators and instead encourages the generator output to match the ground truth audio by adding an additional <em>feature matching</em> loss: the L1 distance between discriminator feature maps of real and generated audio. Both approaches seem to be effective.</p>

<p>Adversarial waveform synthesis is particularly useful for TTS, because it enables the use of highly parallelisable feed-forward models, which tend to have relatively low capacity requirements because they are trained with a mode-seeking loss. This means the models <strong>can more easily be deployed on low-power hardware while still performing audio synthesis in real-time</strong>, compared to autoregressive or flow-based models.</p>

<p>
<strong>MelGAN</strong>: <a href="https://papers.nips.cc/paper/9629-melgan-generative-adversarial-networks-for-conditional-waveform-synthesis">paper</a> - <a href="https://github.com/descriptinc/melgan-neurips">code</a> - <a href="https://melgan-neurips.github.io/">samples</a></p>

<h2 id="-discussion"><a name="discussion"></a> Discussion</h2>

<p>To wrap up this blog post, I want to summarise a few thoughts about the current state of this area of research, and where things could be moving next.</p>

<h3 id="why-the-emphasis-on-likelihood-in-music-modelling">Why the emphasis on likelihood in music modelling?</h3>

<p>Clearly, the dominant paradigm for generative models of music in the waveform domain is likelihood-based. This stands in stark contrast to the image domain, where adversarial approaches greatly outnumber likelihood-based ones. I suspect there are a few reasons for this (let me know if you think of any others):</p>

<ul>
  <li>
    <p>Compared to likelihood-based models, it seems like it has been harder to translate the successes of adversarial models in the image domain to other domains, and to the audio domain in particular. I think this is because in a GAN, the discriminator fulfills the role of a <strong>domain-specific loss function</strong>, and important prior knowledge that guides learning is encoded in its architecture. We have known about good architectural priors for images for a long time (stacks of convolutions), as evidenced by work on e.g. style transfer<sup id="fnref:styletransfer" role="doc-noteref"><a href="#fn:styletransfer" rel="footnote">36</a></sup> and the deep image prior<sup id="fnref:deepimageprior" role="doc-noteref"><a href="#fn:deepimageprior" rel="footnote">37</a></sup>. For other modalities, we don’t know as much yet. It seems we are now starting to figure out what kind of architectures work for waveforms (see <a href="#melgan-gantts">MelGAN and GAN-TTS</a>, some relevant work has also been done in the discriminative setting<sup id="fnref:randomcnn" role="doc-noteref"><a href="#fn:randomcnn" rel="footnote">38</a></sup>).</p>
  </li>
  <li>
    <p><strong>Adversarial losses are mode-seeking</strong>, which makes them more suitable for settings where realism is more important than diversity (for example, because the conditioning signal contains most of the required diversity, as in TTS). In music generation, which is primarily a creative application, <strong>diversity is very important</strong>. Improving diversity of GAN samples is the subject of intense study right now, but I think it could be a while before they catch up with likelihood-based models in this sense.</p>
  </li>
  <li>
    <p>The current disparity could also simply be a consequence of the fact that <strong>likelihood-based models got a head start</strong> in waveform modelling, with WaveNet and SampleRNN appearing on the scene in 2016 and WaveGAN in 2018.</p>
  </li>
</ul>

<p>Another domain where likelihood-based models dominate is language modelling. I believe the underlying reasons for this might be a bit different though: language is inherently <strong>discrete</strong>, and extending GANs to modelling discrete data at scale is very much a work in progress. This is also more likely to be the reason why likelihood-based models are dominant for symbolic music generation as well: most symbolic representations of music are discrete.</p>

<h3 id="-alternatives-to-modelling-waveforms-directly"><a name="alternatives"></a> Alternatives to modelling waveforms directly</h3>

<p>Instead of modelling music in the waveform domain, there are many possible alternative approaches. We could model other representations of audio signals, such as spectrograms, as long as we have a way to obtain waveforms from such representations. We have quite a few options for this:</p>

<ul>
  <li>
    <p>We could use <strong>invertible spectrograms</strong> (i.e. phase information is not discarded), but in this case modelling the phase poses a considerable challenge. There are ways to make this easier, such as the instantaneous frequency representation used by GANSynth.</p>
  </li>
  <li>
    <p>We could also use <strong>magnitude spectrograms</strong> (as is typically done in discriminative models of audio), and then use a <strong>phase reconstruction algorithm</strong> such as the Griffin-Lim algorithm<sup id="fnref:griffinlim" role="doc-noteref"><a href="#fn:griffinlim" rel="footnote">39</a></sup> to infer a plausible phase component, based only on the generated magnitude. This approach was used for the original Tacotron model for TTS<sup id="fnref:tacotron" role="doc-noteref"><a href="#fn:tacotron" rel="footnote">40</a></sup>, and for MelNet<sup id="fnref:melnet" role="doc-noteref"><a href="#fn:melnet" rel="footnote">41</a></sup>, which models music audio autoregressively in the spectrogram domain.</p>
  </li>
  <li>
    <p>Instead of a traditional phase reconstruction algorithm, we could also use a <strong>vocoder</strong> to go from spectrograms to waveforms. A vocoder, in this context, is simply a generative model in the waveform domain, conditioned on spectrograms. Vocoding is a densely conditioned generation task, and many of the models discussed before can and have been used as vocoders (e.g. WaveNet in Tacotron 2<sup id="fnref:tacotron2" role="doc-noteref"><a href="#fn:tacotron2" rel="footnote">42</a></sup>, flow-based models of waveforms, or MelGAN). This approach has some advantages: generated magnitude spectrograms are often imperfect, and vocoder models can learn to account for these imperfections. Vocoders can also work with inherently lossy spectrogram representations such as mel-spectrograms and constant-Q spectrograms<sup id="fnref:constantq" role="doc-noteref"><a href="#fn:constantq" rel="footnote">43</a></sup>.</p>
  </li>
  <li>
    <p>If we are generating audio conditioned on an existing audio signal, we could also simply <strong>reuse the phase</strong> of the input signal, rather than reconstructing or generating it. This is commonly done in source separation, and the approach could also be used for music style transfer.</p>
  </li>
</ul>

<p>That said, modelling spectrograms <strong>isn’t always easier</strong> than modelling waveforms. Although spectrograms have a much lower temporal resolution, they contain much more information per timestep. In autoregressive models of spectrograms, one would have to condition along both the time and frequency axes to capture all dependencies, which means we end up with roughly as many sequential sampling steps as in the raw waveform case. This is the approach taken by MelNet.</p>

<p>An alternative is to make an <strong>assumption of independence between different frequency bands at each timestep</strong>, given previous timesteps. This enables autoregressive models to produce entire spectrogram frames at a time. This partial independence assumption turns out to be an acceptable compromise in the text-to-speech domain, and is used in Tacotron and Tacotron 2. Vocoder models are particularly useful here as they can attempt to fix the imperfections resulting from this simplification of the model. I’m not sure if anybody has tried, but I would suspect that this independence assumption would cause more problems for music generation.</p>

<p>An interesting new approach combining traditional signal processing ideas with neural networks is <a href="https://magenta.tensorflow.org/ddsp">Differentiable Digital Signal Processing (DDSP)</a><sup id="fnref:ddsp" role="doc-noteref"><a href="#fn:ddsp" rel="footnote">44</a></sup>. By creating learnable versions of existing DSP components and incorporating them directly into neural networks, these models are endowed with <strong>much stronger inductive biases about sound and music</strong>, and can learn to produce realistic audio with fewer trainable parameters, while also being more interpretable. I suspect that this research direction may gain a lot of traction in the near future, not in the least because the authors <a href="https://github.com/magenta/ddsp">have made their code publicly available</a>, and also because of its modularity and lower computational requirements.</p>

<figure>
  <img src="https://sander.ai/images/ddsp.png" alt="Diagram of an example DDSP model. The yellow boxes represent differentiable signal processing components."/>
  <figcaption>Diagram of an example DDSP model. The yellow boxes represent differentiable signal processing components. Taken from <a href="https://magenta.tensorflow.org/ddsp">the original blog post</a>.</figcaption>
</figure>

<p>Finally, we could train <strong>symbolic models of music</strong> instead: for many instruments, we already have realistic synthesisers, and we can even train them given enough data (see <a href="#wave2midi2wave">Wave2Midi2Wave</a>). If we are able to craft symbolic representations that capture the aspects of music we care about, then this is an attractive approach as it is much less computationally intensive. Magenta’s <a href="https://magenta.tensorflow.org/music-transformer">Music Transformer</a><sup id="fnref:musictransformer" role="doc-noteref"><a href="#fn:musictransformer" rel="footnote">45</a></sup> and OpenAI’s <a href="https://openai.com/blog/musenet/">MuseNet</a> are two models that have recently shown impressive results in this domain, and it is likely that other ideas from the language modelling community could bring further improvements.</p>

<p>
<strong>DDSP</strong>: <a href="https://openreview.net/forum?id=B1x1ma4tDr">paper</a> - <a href="https://github.com/magenta/ddsp">code</a> - <a href="https://g.co/magenta/ddsp-examples">samples</a> - <a href="https://magenta.tensorflow.org/ddsp">blog post</a> - <a href="https://g.co/magenta/ddsp-demo">colab</a></p>

<h3 id="whats-next">What’s next?</h3>

<p>Generative models of music in the waveform domain have seen substantial progress over the past few years, but the best results so far are still relatively easy to distinguish from real recordings, even at fairly short time scales. There is still a lot of room for improvement, but I believe a lot of this will be driven by better availability of computational resources, and not necessarily by radical innovation on the modelling front – we have great tools already, they are simply a bit expensive to use due to <strong>substantial computational requirements</strong>. As time goes on and computers get faster, hopefully this task will garner interest as it becomes accessible to more researchers.</p>

<p>One interesting question is <strong>whether adversarial models are going to catch up</strong> with likelihood-based models in this domain. I think it is quite likely that GANs, having recently made in-roads in the densely conditioned setting, will gradually be made to work for more sparsely conditioned audio generation tasks as well.  Fully unconditional generation with long-term coherence seems very challenging however, and I suspect that the mode-seeking behaviour of the adversarial loss will make this much harder to achieve. A hybrid model, where a GAN captures local signal structure and another model with a different objective function captures high-level structure and long-term correlations, seems like a sensible thing to build.</p>

<p><strong>Hierarchy</strong> is a very important prior for music (and, come to think of it, for pretty much anything else we like to model), so models that explicitly incorporate this are going to have a leg up on models that don’t – at the cost of some additional complexity. Whether this additional complexity will always be worth it remains to be seen, but at the moment, this definitely seems to be the case.</p>

<p>At any rate, <strong>splitting up the problem into multiple stages</strong> that can be solved separately has been fruitful, and I think it will continue to be. So far, hierarchical models (with learnt or handcrafted intermediate representations) and spectrogram-based models with vocoders have worked well, but perhaps there are other ways to “divide and conquer”. A nice example of a different kind of split in the image domain is the one used in Subscale Pixel Networks<sup id="fnref:spn" role="doc-noteref"><a href="#fn:spn" rel="footnote">46</a></sup>, where separate networks model the most and least significant bits of the image data.</p>

<h2 id="-conclusion"><a name="conclusion"></a> Conclusion</h2>

<p>If you made it to the end of this post, congratulations! I hope I’ve convinced you that music modelling in the waveform domain is an interesting research problem. It is also <strong>very far from a solved problem</strong>, so there are lots of opportunities for interesting new work. I have probably missed a lot of relevant references, especially when it comes to more recent work. If you know about relevant work that isn’t discussed here, feel free to share it in the comments! Questions about this blog post and this line of research are very welcome as well.</p>

<!-- TODO: add some bolded parts to highlight them where it makes sense. -->

<h2 id="-references"><a name="references"></a> References</h2>



      
    </div></div>
  </body>
</html>
