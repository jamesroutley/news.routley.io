<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.naff.dev/blog/all-the-packages">Original</a>
    <h1>How many Alpine packages can you install at once? (2024)</h1>
    
    <div id="readability-page-1" class="page"><div><article><header><p><time datetime="2024-11-10">November 10, 2024</time></p></header><p>It‚Äôs annoying to try and run a command only to discover it hasn‚Äôt been
installed. It‚Äôs even more annoying to build an entire container and miss some
crucial dependency your app needs. Wouldn‚Äôt it be more convenient if your
machine already had all of the software you could ever need installed ahead of
time?</p><p>Thankfully, Linux distributions include a large selection of software in their
repositories. However, we can‚Äôt just install everything, as a package
may <em>conflict</em> with another, meaning they can‚Äôt both be installed. Additionally,
we have to ensure all of the dependencies of each package are also installed,
<em>and</em> that they don‚Äôt introduce any conflicts.</p><p>This all seems rather complicated, and indeed this problem is NP-Hard. Package
managers include a constraint solver to determine what packages should be
installed to bring the system to the desired state. We can also use a constraint
solver, but instead ask it to maximise the number of installed packages subject
to the dependency and conflict constraints.</p><p>I‚Äôve chosen to target <a href="https://alpinelinux.org/">Alpine Linux</a> for this
experiment, as the format of its repositories is easy to parse, and I enjoy
using it. As Alpine is commonly used as a basis for containers, this also
suggests the terrifying possibility of using this as a base image‚Äîvery much
the opposite of <code>FROM scratch</code>.</p><h2 id="parsing-apk-repositories">Parsing APK Repositories</h2><p>The first step is to load a description of the package repository. Alpine has
two primary repositories: <code>main</code> and <code>community</code>. For each of these, we can
download an <code>APKINDEX</code> file that gives us information about every package in the
repository. The <code>community</code> repository expects to be used alongside <code>main</code>, so
we‚Äôll also need to consider the two together.</p><p>The format of <code>APKINDEX</code> is straightforward. Packages are separated by blank
lines, and each line begins with a single character code describing how to
interpret the value on this line. For this experiment, we need to parse the
following properties for each package:</p><ul><li><code>P:</code>, the package name;</li><li><code>V:</code>, the package version;</li><li><code>D:</code>, the dependencies of the package;</li><li><code>p:</code>, what the package provides; and</li><li><code>i:</code>, what other packages should cause this package to also be installed.</li></ul><p>I haven‚Äôt explained the last two yet, and the concept of conflicts seems
conspicuously absent. Saying a package conflicts with another is the same as
saying it depends on the other package not being installed, which APK can
represent as <code>!another_package</code>.</p><p>A package may <em>provide</em> any number of names, optionally with corresponding
versions. If the package is installed, APK can then treat it as equivalent to
these provided packages being installed. Packages can provide a name without a
version: this is called a <em>virtual</em> package. Multiple packages providing the
same virtual package can be installed at once, but only one package can provide
a non-virtual package at a time. This system allows packages to depend on any of
a number of semantically equivalent packages being installed.</p><p>Finally, a package can ask to be installed if a number of other packages are
also installed. This is useful when another package augments an existing one, or
connects two packages‚Äô functionality somehow. I didn‚Äôt initially include this
field, but from testing it seems that APK will always follow it.</p><h2 id="creating-constraints">Creating Constraints</h2><p>With the APK repositories parsed, we can turn our attention to formulating a set
of constraints to enforce the relationships between the packages. Additionally,
we need an <em>objective function</em>: a goal for the constraint solver to maximise,
which in our case is the total of number of packages installed.</p><p>To understand how APK interprets packages, I found the <a href="https://wiki.alpinelinux.org/wiki/APKBUILD_Reference">APKBUILD
reference</a> and <a href="https://wiki.alpinelinux.org/wiki/Apk_spec">Apk
spec</a> pages very helpful. The most
complicated part, and the part I skimped on the most, was implementing version
comparisons. APK supports requiring that a dependency is an exact version, or an
exact version ignoring the final part of the version describing the package
rather than the software it contains. Additionally, it can constrain
dependencies based on inequalities: any of less-than-or-equal-to, less-than,
greater-than, or greater-than-or-equal-to. Package versions can be in any number
of formats, and from what I can see APK has a dedicated algorithm to parse and
compare them, including support for things like alpha and beta versions. I took
as simple an approach as I could get away with: converting all sets of
consecutive digits in the version string to integers, then comparing these with
the earliest set of digits having most significance.</p><p>For this experiment, I used <a href="https://coin-or.github.io/pulp/">PuLP</a>, which is a
Mixed Integer Linear Programming (MILP) solver. Our constraints take the form of
inequalities between a linear combination of variables and an integer.
Additionally, we constrain our variables to be integers themselves.
Specifically, we can constrain variables to be either 0 or 1, representing a
Boolean value, such as whether a package is installed. I chose PuLP as it has a
nice Python API and I‚Äôve had good success with it in the past on problems that
<a href="https://github.com/Z3Prover/z3">z3</a> has struggled with.</p><p>We create a binary variable for each package in the repository. I‚Äôll denote
these like <math display="inline"><msub><mi>x</mi><mtext>firefox</mtext></msub></math>,
which represents whether to install the package <code>firefox</code>. Note that there is a
separate variable for each version of the package in the repository, but I omit
that here for simplicity. The objective function we are trying to maximise is
simply the sum of all of these variables, which is the total number of packages
installed.</p><h3 id="conflicts">Conflicts</h3><p>Now we need to express the package constraints such that PuLP can understand
them. The simplest constraints are those for packages that conflict. I find it
easiest to draw the boolean truth table we‚Äôre looking for, such as this for two
conflicting packages <code>A</code> and <code>B</code>:</p><table><thead><tr><th><math display="inline"><msub><mi>x</mi><mtext>A</mtext></msub></math></th><th><math display="inline"><msub><mi>x</mi><mtext>B</mtext></msub></math></th><th>Correct?</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>1</td></tr><tr><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>0</td><td>1</td></tr><tr><td>1</td><td>1</td><td>0</td></tr></tbody></table><p>The only disallowed case is if both packages are installed. It is clear the
boolean operation we‚Äôre looking for is NAND, but we can also express this with
the constraint
<math display="inline"><msub><mi>x</mi><mtext>A</mtext></msub><mo>+</mo><msub><mi>x</mi><mtext>B</mtext></msub><mo>‚â§</mo><mn>1</mn></math>.
We make packages conflict in a number of cases:</p><ul><li>with packages of the same name (different versions of a package can‚Äôt be
installed at the same time);</li><li>with packages of the same name as something this package provides;</li><li>with packages also providing something this package provides, so long as the
name provided isn‚Äôt a virtual package; and</li><li>with packages this package explicitly conflict with (via a <code>!another_package</code>
dependency).</li></ul><h3 id="dependencies">Dependencies</h3><p>Next, we can tackle dependencies. The truth table for a package <code>A</code> that depends
on package <code>B</code> is as follows:</p><table><thead><tr><th><math display="inline"><msub><mi>x</mi><mtext>A</mtext></msub></math></th><th><math display="inline"><msub><mi>x</mi><mtext>B</mtext></msub></math></th><th>Correct?</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>1</td></tr><tr><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>0</td><td>0</td></tr><tr><td>1</td><td>1</td><td>1</td></tr></tbody></table><p>Here the boolean operation is that of logical implication:
<math display="inline"><msub><mi>x</mi><mtext>A</mtext></msub><mo>‚üπ</mo><msub><mi>x</mi><mtext>B</mtext></msub></math>.
We can formulate this as a constraint
<math display="inline"><msub><mi>x</mi><mtext>B</mtext></msub><mo>-</mo><msub><mi>x</mi><mtext>A</mtext></msub><mo>‚â•</mo><mn>0</mn></math>.
This constraint also generalises nicely to when package <code>A</code> depends on any of a
set of packages <math display="inline"><mi>ùêó</mi></math>:
<math display="inline"><munder><mo>‚àë</mo><mrow><mi>a</mi><mo>‚àà</mo><mi>ùêó</mi></mrow></munder><mi>a</mi><mo>-</mo><msub><mi>x</mi><mtext>A</mtext></msub><mo>‚â•</mo><mn>0</mn></math>.
We can only subtract one after the sum, so as long as at least one of the
dependencies is installed, the total cannot be negative.</p><h3 id="install-if">Install If</h3><p>Finally, we must handle the <code>i:</code> field. I was unable to come up with a simple
constraint to express that a package must be installed if all of the packages
listed in the field are satisfied by at least one package, so I turned to a
classic constraint embedding trick: auxiliary variables. We break the constraint
into multiple simpler constraints, with new variables representing intermediate
steps. These variables are auxiliary because we don‚Äôt directly care about their
value; they don‚Äôt correspond to whether a particular package should be
installed.</p><p>Specifically, for each entry in the <code>i:</code> field, we introduce a variable
representing whether that entry has been satisfied by a package. In essence, we
make each package that could fulfil it depend on this variable. However, we must
add an additional constraint. With our package dependency example above, with
<code>A</code> depending on <code>B</code>, it is valid for <code>B</code> to be installed and <code>A</code> to not be.
Similarly, it would be possible for this auxiliary variable to be true if none
of its providers are installed. We need to ensure that this auxiliary variable
is zero if no package is installed that fulfils it. We do this by making it
depend on at least one of the packages that fulfils it, just as in the example
with <code>A</code> and <math display="inline"><mi>ùêó</mi></math> above.</p><p>Additionally, we introduce an auxiliary variable representing whether every
entry in the <code>i:</code> field has been satisfied. We make this variable depend on all
the variables we introduced above. As before, we need an extra constraint to
make sure it is true if all of the sub-variables are true. Representing the
sub-variables as the set <math display="inline"><mi>ùêó</mi></math> and the final
variable as <math display="inline"><mi>y</mi></math> I achieved this with the
constraint
<math display="inline"><munder><mo>‚àë</mo><mrow><mi>a</mi><mo>‚àà</mo><mi>ùêó</mi></mrow></munder><mi>a</mi><mo>-</mo><mi>y</mi><mo>‚â§</mo><mi>|</mi><mi>ùê±</mi><mi>|</mi><mo>‚àí</mo><mn>1</mn></math>.
If every variable in <math display="inline"><mi>ùêó</mi></math> is true,
<math display="inline"><mi>y</mi></math> must be true to bring the total low enough. To
complete these constraints, we make this final variable depend on the package
being installed.</p><p>This was by far the most complicated set of constraints to write and debug.
Either there is a simpler way of doing this, or they illustrate that a different
solver or an automated way of creating constraints from boolean logic would be
more convenient.</p><h2 id="solving">Solving</h2><p>After setting up all of these constraints, we turn our problem over to the
solver and wait. On my laptop, solving them takes around two seconds for <code>main</code>
alone, and two minutes for <code>main</code> and <code>community</code>. The choice of solver and
constraints can make a huge difference about how long a problem takes to solve,
so it may be possible to make large improvements to the performance.</p><p>One interesting thing I stumbled across was the existence of packages in the
repository that were impossible to install. For example, in the <code>APKINDEX</code> file
I downloaded, the package <code>aconf-mod-network</code> depends on <code>network</code>, but no such
package is provided. Indeed, APK is unable to install this package. This issue
has been <a href="https://git.alpinelinux.org/aports/commit/main/aconf/APKBUILD?id=e83d62f470e6469b7dd7226dfb8fa5d5a73c899f">fixed on
edge</a>.</p><h2 id="testing-the-world-files">Testing the World Files</h2><p>After the solver finishes, we can emit a world file, describing the exact
version of every package we want to install. If we have set up our constraints
right to mirror APK, no packages that aren‚Äôt listed in this world file should
need to be installed.</p><p>We can copy our world file to <code>/etc/apk/world</code> and run <code>apk fix --simulate</code> to
test it out. This checks that the world isn‚Äôt broken without having to download
all of the packages‚Äîsaving both bandwidth and disk space.</p><p>It took a number of iterations before APK was happy with my world files. The
majority of the nuances around virtual packages and providers were not present
in my initial tests, which were also missing the entire concept of the <code>i:</code>
field. APK gives an explanation of which packages conflict, so I would read
their entries in the <code>APKINDEX</code> file to understand why that happened before
adding the relevant constraints.</p><h2 id="conclusion">Conclusion</h2><p>Overall, I was able to get APK to commit to the following package counts in
Alpine 3.20, compared to the total number of available packages:</p><ul><li><code>main</code>: 5441/5525 (98.5%)</li><li><code>main</code> + <code>community</code>: 23644/24165 (97.8%)</li></ul><p>I‚Äôve posted my (terrible, ramshackle) code and the final world files I came up
with to <a href="https://gist.github.com/chamlis/4d7441967787dc862f635a53958cabd6">this
gist</a>. As
packages update in Alpine, these world files will drift out of date and become
uninstallable, so you may have to regenerate them yourself from the latest
<code>APKINDEX</code> files.</p><p>Replicating all of the behaviour of APK is non-trivial, especially if, like me,
you avoid looking at the source code and guess what it‚Äôs doing based on the
conflicts you‚Äôre seeing. It‚Äôs absolutely possible I‚Äôve been too harsh with my
constraints or bungled some entirely, and that you can install more packages. If
you‚Äôre able to improve upon these results, or do a similar thing for another
operating system, I‚Äôd love to hear about it! I only humbly request that you
don‚Äôt cause unnecessary burden on freely provided infrastructure.</p></article></div></div>
  </body>
</html>
