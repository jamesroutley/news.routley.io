<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://haskellwingman.dev/">Original</a>
    <h1>Wingman for Haskell</h1>
    
    <div id="readability-page-1" class="page"><div id="hero">
      
      <p><span>Consider <a href="https://www.patreon.com/wingman_for_haskell">pledging on Patreon</a> to support the project and get access to cutting-edge features.</span>
    </p></div><div id="features">
      <div>
        
        <p><span>Type-Aware Code Generation</span></p><p>
        Fill typed holes with ease. Generate idiomatic Haskell solutions using
        pattern matching, class methods, and even recursion.
        </p>
        <p><a href="#" onclick="openModal(&#39;foldr.gif&#39;)">See it in action</a>
      </p></div>
      <div>
        
        <p><span>Case Splitting</span></p><p>
        Introduce complete case statements for any variable in scope.
        Automatically expand top-level splits into multiple equations.
        </p>
        <p><a href="#" onclick="openModal(&#39;case-split.gif&#39;)">See it in action</a>
      </p></div>
      <div>
        
        <p><span>Editor Agnostic</span></p><p>
        Wingman is built on LSP, so it works out-of-the-box in most editors.
        Just hover over a typed hole to get started!
        </p>
        <!-- <a href="#" onclick="openModal('intros.gif')">See it in action</a> -->
      </div>
    </div><div id="about">
      <div>
      

      <p>Wingman for Haskell automates away the old <a href="https://reasonablypolymorphic.com/blog/typeholes/">hole-driven
          design</a> workflow. You probably know the one —  where you put
        down a hole, and ask the compiler what type it has. After a little bit
        of thinking, you add a little bit of code around the hole, and then ask
        the compiler again.  Over time, the expression gets written, but it
        seems like the compiler is doing most of the work. Sometimes it can
        feel like all you&#39;re around for is to write down what the compiler
        says.</p>

      <p>Instead, imagine a world where you can just ask &#34;hey, fill in this
        hole for me, please.&#34; Wingman is that world. A typechecker is nothing
        but a series of rules that determine what type an expression has. By
        running these rules backwards, we can instead look at what expressions
        could produce a certain type. Search through a few thousand well-typed
        expessions, score them, and give back the best one.</p>

      <p>As you might expect, running the search is the easy part. Keeping it
        fast and making sure it returns good results is where the challenge comes
        in. And often, these goals are in tension. Always returning
        <code>undefined</code> would certainly be well-typed and fast, but it&#39;s
        clearly not what you had in mind.</p>

      <p>Wingman tries really hard to write the code you would have written
        youself. It prefers linear solutions, ensures productive recursion, and
        has a reasonable knowledge of common Haskell idioms — including
        eta-reduction and every-day combinators.</p>

      <p>Of course, sometimes human ingenuity is necessary to get a function
        out the door, and no automated tool can do the job. Even when you&#39;re not
        asking Wingman to fill holes for you, it can still help. By running
        small pieces of the code synthesizer, it can perform case splits,
        introduce lambdas and, in general, help move you closer to the
        important part of the problem.</p>
      </div>
    </div><div id="faq">
      <div>
      

      <h2>Sounds great, but how do I get started?</h2>

      <p>Make sure you have the Haskell Language Server installed, then try
        writing out the following:</p>

<pre>my_foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b
my_foldr = _</pre>

      <p>Simply hover over the <code>_</code> and run the <code>Attempt to fill
        hole</code> code action (under <span><i></i></span> in VSCode.) Prepare to be
        amazed.</p>


      <h2>What can Wingman do?</h2>

      <p><span>Attempt to fill hole</span> —
        try to synthesize a complete solution to the current hole. Fails if it
        can only make partial progress.</p>
      <p><span>Case split on</span> — pattern match on
        a local variable. Comes in many varieties, for creating homomorphisms and
        working with <code>-XLambdaCase</code>.</p>
      <p><span>Introduce lambda</span> —
        add a lambda abstraction, binding every function argument.</p>
      <p><span><span></span>Refine hole</span> —
        make one step in the &#34;obvious direction.&#34; Introduces a lambda or uses
        a data constructor if it&#39;s the only one that can match.</p>
      <p><span><span></span>Split all function arguments</span> —
        make a function head for every possible combination of its arguments.</p>
      <p><span><span></span>Use constructor</span> —
        use the specified constructor, adding new holes for each argument.</p>


      <h2>What&#39;s the difference between Wingman and HLS?</h2>

      <p>The Haskell Language Server is best thought of as a platform for
        writing specific tools. It provides a bridge between the editor and the
        compiler, and ensures that build artifacts are up to date.</p>

      <p>Wingman is built on top of HLS, and that&#39;s the reason it doesn&#39;t
        require dedicated editor support. We&#39;re bundled together in the spirit
        of symbiosis and convenience — Wingman provides some features
        otherwise lacking in HLS, but also wouldn&#39;t be possible
        <em>without</em> HLS.</p>


      <h2>Is this different than hls-tactics-plugin?</h2>

      <p>No, just better branding.</p>

      <p>Internally, the project is still known as
        <code>hls-tactics-plugin</code>, due to its intentions to be tactic
        meta-programming tool for Haskell. On the inside, Wingman makes heavy
        use of Reed Mullanix&#39;s excellent <a href="https://hackage.haskell.org/package/refinery">refinery</a>
        tactic library for doing its code synthesis.</p>

      <p>Maybe one day we&#39;ll get to tactic meta-programming. But for now, this
        is just an implementation detail, and <code>hls-tactics-plugin</code>
        isn&#39;t exactly a name that inspires enthusiasm.</p>
      </div>
    </div></div>
  </body>
</html>
