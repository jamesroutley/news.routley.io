<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.joseferben.com/posts/3-things-that-surprised-me-while-running-sqlite-in-production/">Original</a>
    <h1>Things that surprised me while running SQLite in production</h1>
    
    <div id="readability-page-1" class="page"><div>
    <div>
      
        
        <picture>
          <source media="(min-width:640px)" srcset="https://erbensystems-cms.s3.amazonaws.com/media/images/Screenshot_2023-07-03_at.width-800.format-webp-lossless.webp?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=AKIAQ4VTUFKDJHY2LAAR%2F20230704%2Feu-central-1%2Fs3%2Faws4_request&amp;X-Amz-Date=20230704T062035Z&amp;X-Amz-Expires=3600&amp;X-Amz-SignedHeaders=host&amp;X-Amz-Signature=023196adc358fce42a547aa2669bff76a221455c02b3bd31590a12b4c8653b19" width="800" height="533"/>
          <img alt="sqlite" height="266" loading="eager" src="https://erbensystems-cms.s3.amazonaws.com/media/images/Screenshot_2023-07-03_at.width-400.format-webp-lossless.webp?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=AKIAQ4VTUFKDJHY2LAAR%2F20230704%2Feu-central-1%2Fs3%2Faws4_request&amp;X-Amz-Date=20230704T062035Z&amp;X-Amz-Expires=3600&amp;X-Amz-SignedHeaders=host&amp;X-Amz-Signature=fea02c5cc0833fbd1e2a122785b544989ff0605e41b15454b29c36a80474db0d" width="400"/>
        </picture>
      
      <p><time datetime="July 3, 2023, 4:54 p.m.">
      July 3, 2023</time></p>
      <div><p data-block-key="pb5p8">I&#39;ve been using SQLite in several production projects for six months, and I&#39;ve encountered some surprising aspects.&#34;</p></div>
      <div><div><h2 data-block-key="al6to">How I use SQLite</h2><p data-block-key="cc1if">I use SQLite in three Django apps and a Node-based MMORPG that&#39;s still in the early stages of development.&#34;</p><p data-block-key="drhum">The Django apps have 2 web workers (= processes) each and 2 of the 3 apps have additional background worker processes. One app is running 24 background worker processes.</p><p data-block-key="8cg87">The MMORPG snapshots the game state into a single SQLite database within a Node process.</p><h2 data-block-key="67ftq">Why?</h2><p data-block-key="2c6s7">Because <a href="https://fly.io/blog/all-in-on-sqlite-litestream/">fly.io</a> and <a href="https://hn.algolia.com/?dateRange=all&amp;page=0&amp;prefix=false&amp;query=sqlite&amp;sort=byPopularity&amp;type=story">The Orange Website</a> said it&#39;s a good idea. No seriously, SQLite received so much goodwill and attention in the last few years that I decided to have a closer look.</p><p data-block-key="f68rr">I am a minimalist in my personal life and I am convinced that you should start out simply, like <i>stupidly</i> simple.</p><p data-block-key="7mt7d">In my opinion, Postgres is boring but not necessarily simple. There are many knobs that can be tweaked. I don&#39;t think you need to decide between one or the other, I think Postgres is a natural step from SQLite once you out grow SQLite.</p><p data-block-key="64r2h">The first thing I&#39;ve come to appreciate about SQLite is its documentation.. I felt like I could wrap my head around the tool in a matter of hours. It&#39;s very honest about what SQLite can do under which circumstances. And more important, what it<i> can&#39;t</i> do.</p></div>
<div><h2 data-block-key="j4fe2">1. In-memory SQLite is not too exciting</h2><p data-block-key="8oaca">At least not in my JavaScript benchmarks where I compared SQLite in-memory and SQLite backed by a file. I tested inserting and updating 1k, 10k and 100k rows.</p><p data-block-key="4rvlm">This one surprised me because in my mind</p><ul><li data-block-key="78d9m">memory is fast and</li><li data-block-key="3glbg">I/O is slow</li></ul><p data-block-key="4iqtb">I guess this is what years of dealing with databases over networks by using ORMs does to you.</p><p data-block-key="8t1vl">I had hoped that changing</p></div>
<div><div><pre><span></span><span>const</span><span> </span><span>db</span><span> </span><span>=</span><span> </span><span>new</span><span> </span><span>Database</span><span>(</span><span>&#34;db.sqlite3&#34;</span><span>)</span>
</pre></div>

</div>
<p data-block-key="20f5v">to</p>
<div><div><pre><span></span><span>const</span><span> </span><span>db</span><span> </span><span>=</span><span> </span><span>new</span><span> </span><span>Database</span><span>(</span><span>&#34;:memory:&#34;</span><span>)</span>
</pre></div>

</div>
<div><p data-block-key="3ue2g">would speed up everything by x100 and all my problems would go away.</p><p data-block-key="aatfv">Similarly, when I switched my Django tests from file to in-memory, there wasn&#39;t much of a difference.</p><p data-block-key="91va9">I suspect that the data in my benchmarks was too small, so that SQLite <a href="https://stackoverflow.com/a/764743">never flushed</a> the page cache. I know that in-memory SQLite has its uses, but personally, I didn&#39;t notice a significant difference in my everyday work as a web developer.</p></div>
<div><h2 data-block-key="j4fe2">2. SQLite is surprisingly fast</h2><p data-block-key="5u6u5">At least compared to native JavaScript data structures. I ran some benchmarks for inserting and updating entities stored as JSON blobs. I compared</p></div>
<div><div><pre><span></span><span>const</span><span> </span><span>db</span><span>:</span><span> </span><span>Map</span><span>&lt;</span><span>string</span><span>,</span><span> </span><span>Entity</span><span>&gt;</span><span> </span><span>=</span><span> </span><span>new</span><span> </span><span>Map</span><span>()</span>
</pre></div>

</div>
<div><p data-block-key="al6to">with storing entities in a in-memory SQLite database using better-sqlite3.</p><p data-block-key="bepuj">What&#39;s your intuition on this?</p><p data-block-key="6518e">The JavaScript Map was only 1-2 orders of magnitude faster! This blew my mind. I expected SQLite to be at least 1000x slower than a data structure built for inserting and retrieving things by key, with all the V8 goodness and what not.</p></div>
<div><h2 data-block-key="j4fe2">3. SQLite feels surprisingly concurrent</h2><p data-block-key="ckdup">Of course, SQLite is not truly concurrent. No matter what you do, there can only be a single writer process. But with the following setup</p></div>
<div><div><pre><span></span><span>@receiver</span><span>(</span><span>connection_created</span><span>)</span>
<span>def</span> <span>configure_sqlite</span><span>(</span><span>sender</span><span>,</span> <span>connection</span><span>,</span> <span>**</span><span>kwargs</span><span>):</span>
    <span>if</span> <span>connection</span><span>.</span><span>vendor</span> <span>==</span> <span>&#34;sqlite&#34;</span><span>:</span>
        <span>cursor</span> <span>=</span> <span>connection</span><span>.</span><span>cursor</span><span>()</span>
        <span>cursor</span><span>.</span><span>execute</span><span>(</span><span>&#34;PRAGMA journal_mode = WAL;&#34;</span><span>)</span>
        <span>cursor</span><span>.</span><span>execute</span><span>(</span><span>&#34;PRAGMA busy_timeout = 5000;&#34;</span><span>)</span>
        <span>cursor</span><span>.</span><span>execute</span><span>(</span><span>&#34;PRAGMA synchronous = NORMAL;&#34;</span><span>)</span>
</pre></div>

</div>
<div><p data-block-key="1j2f0">SQLite certainly feels quite concurrent.</p><p data-block-key="ej15d">Many consider Python a &#34;slow blocking&#34; language. In one of my Django apps I have 24 background worker processes writing to the database 4-5 times per minute and 2 web workers with 1-2 writes per second. In total there are 26 processes potentially writing at the same time.</p><p data-block-key="583t">The SQLite driver complains about a locked database maybe once every week. So far, none of the human writers have been affected. All the stack traces came from background workers which simply retry.</p><p data-block-key="c42oo">There is plenty of room for improvements. For starters, the workers probably shouldn&#39;t write directly to the application database but instead to some worker database.</p></div>
<div><h2 data-block-key="6stxk">Conclusion</h2><p data-block-key="5jd48">I&#39;ll continue testing SQLite with various workloads to see how it responds. Let&#39;s see how long I can keep going without having to switch to Postgres.</p></div></div>
      
      
    </div>
  </div></div>
  </body>
</html>
