<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://verdverm.com/go-mods/">Original</a>
    <h1>Go mod’s lesser known features</h1>
    
    <div id="readability-page-1" class="page"><div id="main">
    
    <p>Modules are how Go manages dependencies.
A module is a collection of packages that are released, versioned, and distributed together.
Each package within a module is a collection of source files in the same directory that are compiled together.</p>
<p>In this post,
we will explore Go mododules design and
learn how they support supply chain security.
You can find the <code>go mod</code> documentation here: <a href="https://golang.org/ref/mod">https://golang.org/ref/mod</a></p>
<h3 id="contents">Contents</h3>
<nav aria-labelledby="toc-heading">
<nav id="TableOfContents">
  <ul>
    <li></li>
    <li><a href="#anatomy-of-a-gomod-file">Anatomy of a go.mod file</a></li>
    <li><a href="#minimum-version-selection">Minimum Version Selection</a></li>
    <li><a href="#directives-in-gomod">Directives in go.mod</a></li>
    <li><a href="#environment-variables">Environment variables</a></li>
    <li><a href="#hashes-and-the-gosum-file">Hashes and the go.sum file</a></li>
    <li><a href="#local-module-cache">Local module cache</a></li>
    <li><a href="#global-services-modules-and-hashes">Global services modules and hashes</a></li>
    <li><a href="#module-naming">Module naming</a></li>
    <li><a href="#only-secure-remotes">Only Secure Remotes</a></li>
    <li><a href="#private-module-support">Private module support</a></li>
    <li><a href="#preventing-dependency-confusion">Preventing dependency confusion</a></li>
    <li><a href="#malicious-version-changes">Malicious version changes</a></li>
    <li><a href="#no-pre-or-post-hooks">No pre or post hooks</a></li>
    <li><a href="#information-in-the-binaries">Information in the binaries</a></li>
    <li><a href="#reproducible-builds">Reproducible Builds</a></li>
    <li><a href="#learning-more">Learning more</a></li>
  </ul>
</nav>
</nav>

<p>Notes:</p>
<p><em>The statements here reference Go 1.17 and not all applies to older versions.</em></p>
<p><em>This post is accompanied by a talk at PackageCon2021. The video will be added once available.</em></p>
<p><a href="https://verdverm.com/PackagingCon2021-GoMods.pdf">Download the slides</a></p>
<h2 id="anatomy-of-a-gomod-file">Anatomy of a go.mod file</h2>
<pre><code>// Sample go.mod file
module github.com/org/module         // module name

require (                            // module dependencies
  github.com/foo/bar  v0.1.2
  github.com/cow/moo  v1.2.3
  mydomain.com/gopher v0.2.3-beta1
)
</code></pre>
<p>Go has restrictions on a module name which we will talk about later.
The version is a specific and minimum version for your project.
Note, there are no version ranges, only a single Semantic Version.
As Go processes the dependency tree, it selects the <em>maximum</em> of the versions found.
In doing so, MVS can create a reproducible dependency tree without a lockfile.</p>
<h2 id="minimum-version-selection">Minimum Version Selection</h2>
<p>Golang uses the MVS (minimum version selection) <sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup> <sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup> algorithm to select dependency versions.
This deterministic algorithm has nice properties for reproducible builds and avoids the NP-complete runtime complexity.
There is no need for a SAT solver because the dependency selection problem is constrained.</p>
<p>At its heart, <em>hand waving away some details</em>,
MVS is a breadth-first traversal across modules and versions.
The tree is defined by <code>go.mod</code> files for a module,
its dependencies, its dependencies-dependencies, and so on.</p>
<p><img src="https://verdverm.com/images/mvs-buildlist.svg" alt="Minimum Version Selection"/></p>
<p>The <code>minimum</code> terminology is due to the idea that this is a minimal implementation
for a lockfile free, deterministic dependecy management system.</p>
<h2 id="directives-in-gomod">Directives in go.mod</h2>
<p>The <code>go.mod</code> file has a number of directives for controlling versions
and dependencies.</p>
<pre><code>module example.com/my/thing

go 1.16

require example.com/other/thing v1.0.2
require example.com/new/thing/v2 v2.3.4
exclude example.com/old/thing v1.2.3
replace example.com/bad/thing v1.4.5 =&gt; example.com/good/thing v1.4.5
retract [v1.9.0, v1.9.5]
</code></pre>
<ul>
<li><code>go</code> - sets the minimum Go syntax version</li>
<li><code>require</code> - specify direct module dependencies</li>
<li><code>exclude</code> - prevents a dependency version</li>
<li><code>replace</code> - substitutes without renaming</li>
<li><code>retract</code> - minor and patch versions of this module</li>
</ul>
<p><code>//Deprecated</code> can be used for major version of your modules.
You add a comment and tag a new release.</p>
<pre><code>// Deprecated: use example.com/mod/v2 instead.
module example.com/mod
</code></pre>
<p>As of Go 1.17, there are two require blocks,
one for direct and indirect each,
to support lazy loading. <sup id="fnref:3"><a href="#fn:3" role="doc-noteref">3</a></sup></p>
<h2 id="environment-variables">Environment variables</h2>
<p>Go supports a number of environment variables
for controlling how modules and module aware commands <sup id="fnref:4"><a href="#fn:4" role="doc-noteref">4</a></sup> work.
The following table contains the variables referenced in later sections.
For a full list, more details, and examples, see: <sup id="fnref:5"><a href="#fn:5" role="doc-noteref">5</a></sup> <sup id="fnref:6"><a href="#fn:6" role="doc-noteref">6</a></sup></p>
<p>You can use <code>go env</code> to see the current settings.</p>
<table>
<thead>
<tr>
<th>variable</th>
<th>used for</th>
</tr>
</thead>
<tbody>
<tr>
<td>GOMODCACHE</td>
<td>directory for module related files</td>
</tr>
<tr>
<td>GOPRIVATE</td>
<td>module globs to handle as private</td>
</tr>
<tr>
<td>GOPROXY</td>
<td>ordered list of module proxies to use</td>
</tr>
<tr>
<td>GONOPROXY</td>
<td>module globs to fetch directly</td>
</tr>
<tr>
<td>GOSUMDB</td>
<td>ordered list of sumdb hosts to use</td>
</tr>
<tr>
<td>GONOSUMDB</td>
<td>module globs to omit remote sumdb checks on</td>
</tr>
<tr>
<td>GOVCS</td>
<td>sets VCS tools allowed for public and private access</td>
</tr>
<tr>
<td>GOINSECURE</td>
<td>globs to allow fallback to http on <sup id="fnref:7"><a href="#fn:7" role="doc-noteref">7</a></sup></td>
</tr>
</tbody>
</table>
<h2 id="hashes-and-the-gosum-file">Hashes and the go.sum file</h2>
<p>When the go command downloads a module,
it computes a cryptographic hash and compares it
with a known value to verify the file hasn’t changed since it was first downloaded.
Modules store these hashes in a <code>go.sum</code> file
and the Go command verifies they match.
Go also stores these hashes in mode module cache
and will compare them with a global database.
<sup id="fnref:8"><a href="#fn:8" role="doc-noteref">8</a></sup></p>
<h2 id="local-module-cache">Local module cache</h2>
<p>Go maintains a shared module cache on your local system. <sup id="fnref:9"><a href="#fn:9" role="doc-noteref">9</a></sup>
This is where downloaded modules are stored.
The location is determined by the <code>GOMODCACHE</code> variable.
Module code is read-only by default to prevent local modifications
and “it works on my machine” issues.
The shared cache also contains prebuilt artifacts.
All of this means that multiple projects on your machine
can reuse the same downloaded and preprocessed packages.</p>
<h2 id="global-services-modules-and-hashes">Global services modules and hashes</h2>
<p>The Go team maintain global proxies for
sumdb, cachedb, and global hash integrity and revocation checks.
<sup id="fnref:10"><a href="#fn:10" role="doc-noteref">10</a></sup>
The checksum database can be used to detect misbehaving origin and proxy servers.
It has a merkel tree transparency log for hashes powered by the Trillian project.
The cache database proxies public modules and will maintain copies even if the origin server removes them.</p>
<p>The Go team has taken privacy seriously. These services record very minimal information.
You can read the <a href="https://sum.golang.org/privacy">privacy statemnt for sum.golang.org/privacy</a> for details.
Their communications in issues on GitHub reflects this.
For example, only limited auth features have been enabled,
because they are being careful in trying to maintain privacy in proxy.</p>
<h2 id="module-naming">Module naming</h2>
<p>Go has a number of module naming rules.
These are partially by design,
in using code hosts rather than package registries,
but also for security resaons.</p>
<blockquote>
<p><strong>Requires a domain name to be the first part of the module identifier</strong></p>
</blockquote>
<p>The domain requirement is itself required
because Go resolves modules to the code host.
It also prevents a class of dependency confusion,
discussed in the next section.</p>
<blockquote>
<p><strong>Only contain ascii letters, digits, and limited punctuation (<code>[.~_-]</code>)</strong></p>
</blockquote>
<p>Restrictions on allowed import path parameters prevents
<strong>homograph</strong> or <strong>homoglyph</strong> attacks. <sup id="fnref:11"><a href="#fn:11" role="doc-noteref">11</a></sup> <sup id="fnref:12"><a href="#fn:12" role="doc-noteref">12</a></sup> <sup id="fnref:13"><a href="#fn:13" role="doc-noteref">13</a></sup></p>
<pre><code>$ go mod init ɢoogle.com/chrome
go: malformed module path &#34;ɢoogle.com/chrome&#34;: invalid char &#39;ɢ&#39;
</code></pre>
<blockquote>
<p><strong>Cannot begin or end with a slash or dot</strong></p>
</blockquote>
<p>Slash and dot restrictions prevent absolute and relative path
from being part of imports.
While this means they are more verbose,
it also means that</p>
<ol>
<li>you can always see the exact package being used</li>
<li>relative and absolute path attacks are not possible</li>
</ol>
<blockquote>
<p><strong>There are more restrictions</strong></p>
</blockquote>
<p>For specific contexts, there are more rules</p>
<ul>
<li>The domain part has further restrictions</li>
<li>Windows has reserved files to avoid</li>
<li>Major version suffixes</li>
</ul>
<p>See <sup id="fnref:14"><a href="#fn:14" role="doc-noteref">14</a></sup> for more details.</p>
<h2 id="only-secure-remotes">Only Secure Remotes</h2>
<p>Go will only talk to secure code hosts,
preferring <code>https</code> and <code>git+ssh</code>.</p>
<p>You can use GOINSECURE to list module patterns
which can be fetched over http and other insecure protocols.
Modules fetched insecurly will still be validated against
the checksum database.</p>
<p>Consult the table of VCS Schemes <sup id="fnref:15"><a href="#fn:15" role="doc-noteref">15</a></sup> to
find which tools and protocols are supported.
You may also need to set GOVCS <sup id="fnref:16"><a href="#fn:16" role="doc-noteref">16</a></sup>.</p>
<h2 id="private-module-support">Private module support</h2>
<p>Go supports modules developed in private.
You can</p>
<ul>
<li>Fetch modules from private code repositories</li>
<li>Prevent your private modules from being publicly indexed</li>
<li>Run a private proxy and sumdb</li>
</ul>
<p>See the private modules section <sup id="fnref:17"><a href="#fn:17" role="doc-noteref">17</a></sup>
for details and necessary configuration.</p>
<p>To authenticate with private module hosts,
Go defers to tool config like <code>.gitconfig</code>
when downloading directly. For <code>https</code>
BasicAuth is supported through the <code>.netrc</code> file.
<sup id="fnref:18"><a href="#fn:18" role="doc-noteref">18</a></sup></p>
<h2 id="preventing-dependency-confusion">Preventing dependency confusion</h2>
<p><strong>Dependency confusion</strong> <sup id="fnref:19"><a href="#fn:19" role="doc-noteref">19</a></sup>
is when a public package with the same name
as an internal package is fetched.
Go helps to prevent this by</p>
<blockquote>
<p><strong>Requiring a domain to start module and import paths</strong></p>
</blockquote>
<p>This means that module names cannot overlap, such as when
a malicious actor registers the same module in a public registry.</p>
<blockquote>
<p><strong>Ignoring replace directives in dependencies</strong></p>
</blockquote>
<p>A comprimised dependency cannot replace other dependencies
with one hosted under a different domain.</p>
<h2 id="malicious-version-changes">Malicious version changes</h2>
<p>There are two main version attacks,
replacing or adding a tag with an exploit.</p>
<blockquote>
<p><strong>Replacing a tag</strong></p>
</blockquote>
<p>Retagging is practically impossible, given a module has been fetched once, by anyone.
The original hash will be in the global sumdb and the validation will fail.
This will of course depend on your <code>GO[NO]SUM</code>, <code>GO[NO]PROXY</code>, and <code>GOPRIVATE</code> settings.</p>
<blockquote>
<p><strong>Creating a new tag</strong></p>
</blockquote>
<p>In Go, versions are specific, not a range.
Additionally, Go will only select from versions which are listed.
By design, Go will not select newer modules
and is relatively safe from malicious version increments.</p>
<h2 id="no-pre-or-post-hooks">No pre or post hooks</h2>
<p>The go module system lacks any pre or post hooks for fetch, build, or install.
This rules out a class of attacks, such as those seen with NPM.</p>
<h2 id="information-in-the-binaries">Information in the binaries</h2>
<p>Go adds the dependency information into the binary.
This includes their path, version, and sumdb hash.</p>
<p><code>go version -m $(which binary)</code></p>
<p>With Go 1.18, it will also include the build flags,
environment settings, and VCS information for the main module.
<sup id="fnref:20"><a href="#fn:20" role="doc-noteref">20</a></sup></p>
<h2 id="reproducible-builds">Reproducible Builds</h2>
<p>Go has a goal for 100% reproducible builds of artifacts.
MVS dependency management is one part and core to this,
ensuring that the source code is the same.
While this is only the first step,
the Go team has been able to reach this goal
even when cross-compiling.</p>
<h2 id="learning-more">Learning more</h2>
<ul>
<li><a href="https://golang.org/ref/mod">Module Reference</a></li>
<li><a href="https://research.swtch.com/vgo">Go &amp; Versioning</a></li>
<li><a href="https://github.com/golang/go/issues/24301">Original Proposal</a></li>
<li><a href="https://github.com/golang/go/issues?q=is%3Aopen+is%3Aissue+label%3Amodules">GitHub Issues</a></li>
</ul>


  </div></div>
  </body>
</html>
