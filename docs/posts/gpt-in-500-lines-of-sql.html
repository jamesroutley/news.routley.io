<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://explainextended.com/2023/12/31/happy-new-year-15/">Original</a>
    <h1>GPT in 500 Lines of SQL</h1>
    
    <div id="readability-page-1" class="page"><div>
	<p><small><strong>Translations</strong>: <a href="https://habr.com/ru/articles/786276/" rel="noopener" target="_blank">Russian</a></small></p>
<p>This year, the talk of the town was AI and how it can do everything for you.</p>
<p>I like it when someone or something does everything for me. To this end, I decided to ask ChatGPT to write my New Year&#39;s post:</p>
<blockquote><p>
&#34;Hey ChatGPT. Can you implement a large language model in SQL?&#34;</p></blockquote>
<p>It just proves that if you want something done right, you have to do it yourself.</p>
<p>Encouraged by this optimistic forecast, today we will implement a large language model in SQL.</p>
<p><img fetchpriority="high" decoding="async" width="700" height="539" data-attachment-id="7315" data-permalink="https://explainextended.com/2023/12/31/happy-new-year-15/kandinsky-download-1703639350496/" data-orig-file="https://explainextended.com/wp-content/uploads/2023/12/kandinsky-download-1703639350496.jpg" data-orig-size="700,539" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="Scribe" data-image-description="" data-image-caption="" data-medium-file="https://explainextended.com/wp-content/uploads/2023/12/kandinsky-download-1703639350496-300x231.jpg" data-large-file="https://explainextended.com/wp-content/uploads/2023/12/kandinsky-download-1703639350496.jpg" src="https://explainextended.com/wp-content/uploads/2023/12/kandinsky-download-1703639350496.jpg" alt="" srcset="https://explainextended.com/wp-content/uploads/2023/12/kandinsky-download-1703639350496.jpg 700w, https://explainextended.com/wp-content/uploads/2023/12/kandinsky-download-1703639350496-300x231.jpg 300w" sizes="(max-width: 700px) 100vw, 700px"/></p>
<h3>Theory</h3>
<p>While writing this post, I used the wonderful article <a href="https://jaykmody.com/blog/gpt-from-scratch/" rel="noopener" target="_blank">GPT in 60 Lines of NumPy</a> by Jay Mody. This article explains the inner workings of a GPT model much better than I can hope to do. Still, a little recap is in order.</p>
<h4>What is a generative large language model from a technical perspective?</h4>
<p>A generative LLM is a function. It takes a text string as input (called &#34;prompt&#34; in AI parlance), and returns an array of strings and numbers. Here&#39;s what the signature of this function looks like:</p>
<p><code>llm(prompt: str) -&gt; list[tuple[str, float]]</code></p>
<p>This function is deterministic. It does a lot of math under the hood, but all this math is hardwired. If you call it repeatedly with the same input, it will always return the same output.</p>
<p>It may come as a surprise to anyone who&#39;s been using ChatGPT and similar products because they can give different answers to the same question. Yet, it&#39;s true. We will shortly see how it works.</p>
<h4>What are the values this function returns?</h4>
<p>Something like this:</p>
<pre title="">llm(&#34;I wish you a happy New&#34;)

0       (&#39; Year&#39;, 0.967553)
1       (&#39; Years&#39;, 0.018199688)
2       (&#39; year&#39;, 0.003573329)
3       (&#39; York&#39;, 0.003114716)
4       (&#39; New&#39;, 0.0009022804)
…
50252   (&#39; carbohyd&#39;, 2.3950911e-15)
50253   (&#39; volunte&#39;, 2.2590102e-15)
50254   (&#39;pmwiki&#39;, 1.369229e-15)
50255   (&#39; proport&#39;, 1.1198108e-15)
50256   (&#39; cumbers&#39;, 7.568147e-17)
</pre>
<p>It returns an array of tuples. Each tuple consists of a word (or, rather, a string) and a number. The number is the probability that this word will continue the prompt. The model &#34;thinks&#34; that the phrase &#34;I wish you a happy New&#34; will be followed by the character sequence &#34; Year&#34; with a probability of 96.7%, &#34; Years&#34; of 1.8% and so on.</p>
<p>The word &#34;think&#34; above is quoted because, of course, the model doesn&#39;t really think. It mechanically returns arrays of words and numbers according to some hardwired internal logic.</p>
<h4>If it&#39;s that dumb and deterministic, how can it generate different texts?</h4>
<p>Large language models are used in text applications (chatbots, content generators, code assistants etc). These applications repeatedly call the model and select the word suggested by it (with some degree of randomness). The next suggested word is added to the prompt and the model is called again. This continues in a loop until enough words are generated.</p>
<p>The accrued sequence of words will look like a text in a human language, complete with grammar, syntax and even what appears to be intelligence and reasoning. In this aspect, it is not unlike a <a href="https://en.wikipedia.org/wiki/Discrete-time_Markov_chain" rel="noopener" target="_blank">Markov chain</a> which works on the same principle.</p>
<p>The internals of a large language model are wired up so that the next suggested word will be a natural continuation of the prompt, complete with its grammar, semantics and sentiment. Equipping a function with such a logic became possible through a series of scientific breakthroughs (and programming drudgery) that have resulted in the development of the family of algorithms known as GPT, or Generative Pre-trained Transformer.</p>
<h4>What does &#34;Generative Pre-trained Transformer&#34; mean?</h4>
<p>&#34;Generative&#34; means that it generates text (by adding continuations to the prompt recursively, as we saw earlier).</p>
<p>&#34;Transformer&#34; means that it uses a particular type of neural network, first developed by Google and described in <a href="https://arxiv.org/pdf/1706.03762.pdf" rel="noopener" target="_blank">this paper</a>.</p>
<p>&#34;Pre-trained&#34; is a little bit historical. Initially, the ability for the model to continue text was thought of as just a prerequisite for a more specialized task: inference (finding logical connections between phrases), classification (for instance, guessing the number of stars in a hotel rating from the text of the review), machine translation and so on. It was thought that these two parts should have been trained separately, the language part being just a <em>pre-</em>training for a &#34;real&#34; task that would follow.</p>
<p>As the original GPT paper puts it:</p>
<blockquote><p>
We demonstrate that large gains on these tasks can be realized by generative pre-training of a language model on a diverse corpus of unlabeled text, followed by discriminative fine-tuning on each specific task.
</p></blockquote>
<p>It was not until later that people realized that, with a model large enough, the second step was often not necessary. A Transformer model, trained to do nothing else than generate texts, turned out to be able to follow human language instructions that were contained in these texts, with no additional training (&#34;fine-tuning&#34; in AI parlance) required.</p>
<p>With that out of the way, let&#39;s focus on the implementation.</p>
<h3>Generation</h3>
<p>Here is what happens when we try to generate text from the prompt using GPT2:</p>
<pre title="">def generate(prompt: str) -&gt; str:
  # Transforms a string into a list of tokens.
  tokens = tokenize(prompt) # tokenize(prompt: str) -&gt; list[int]

  while True:

    # Runs the algorithm.
    # Returns tokens&#39; probabilities: a list of 50257 floats, adding up to 1.
    candidates = gpt2(tokens) # gpt2(tokens: list[int]) -&gt; list[float]

    # Selects the next token from the list of candidates
    next_token = select_next_token(candidates)
    # select_next_token(candidates: list[float]) -&gt; int

    # Append it to the list of tokens
    tokens.append(next_token)

    # Decide if we want to stop generating.
    # It can be token counter, timeout, stopword or something else.
    if should_stop_generating():
      break

  # Transform the list of tokens into a string
  completion = detokenize(tokens) # detokenize(tokens: list[int]) -&gt; str
  return completion
</pre>
<p>Let&#39;s implement all these pieces one by one in SQL.</p>
<h3>Tokenizer</h3>
<p>Before a text can be fed to a neural network, it needs to be converted into a list of numbers. Of course, that&#39;s barely news: that&#39;s what text encodings like Unicode do. Plain Unicode, however, doesn&#39;t really work well with neural networks.</p>
<p>Neural networks, at their core, do a lot of matrix multiplications and capture whatever predictive powers they have in the coefficients of these matrixes. Some of these matrixes have one row per every possible value in the &#34;alphabet&#34;; others have one row per &#34;character&#34;.</p>
<p>Here, the words &#34;alphabet&#34; and &#34;character&#34; don&#39;t have the usual meaning. In Unicode, the &#34;alphabet&#34; is 149186 characters long (this is how many different Unicode points there are at the time of this writing), and a &#34;character&#34; can be something like this: ﷽ (yes, that&#39;s a single Unicode point number 65021, encoding <a href="https://en.wikipedia.org/wiki/Basmala">a whole phrase in Arabic</a> that is particularly important for the Muslims). Note that the very same phrase could have been written in usual Arabic letters. It means that the same text can have many encodings.</p>
<p>As an illustration, let&#39;s take the word &#34;PostgreSQL&#34;. If we were to encode it (convert to an array of numbers) using Unicode, we would get 10 numbers that could potentially be from 1 to 149186. It means that our neural network would need to store a matrix with 149186 rows in it and perform a number of calculations on 10 rows from this matrix. Some of these rows (corresponding to the letters of the English alphabet) would be used a lot and pack a lot of information; others, like poop emoji and obscure symbols from dead languages, would hardly be used at all, but still take up space.</p>
<p>Naturally, we want to keep both these numbers, the &#34;alphabet&#34; length and the &#34;character&#34; count, as low as possible. Ideally, all the &#34;characters&#34; in our alphabet should be distributed uniformly, and we still want our encoding to be as powerful as Unicode.</p>
<p>The way we can do that, intuitively, is to assign unique numbers to sequences of words that occur often in the texts we work with. In Unicode, the same religious phrase in Arabic can be encoded using either a single code point, or letter by letter. Since we are rolling our own encoding, we can do the same for the words and phrases that are important for the model (i.e. show up often in texts).</p>
<p>For instance, we could have separate numbers for &#34;Post&#34;, &#34;greSQL&#34; and &#34;ing&#34;. This way, the words &#34;PostgreSQL&#34; and &#34;Posting&#34; would both have a length of 2 in our representation. And of course, we would still maintain separate code points for shorter sequences and individual bytes. Even if we come across gibberish or a text in a foreign language, it would still be encodable, albeit longer.</p>
<p>GPT2 uses a variation of the algorithm called <a href="https://en.wikipedia.org/wiki/Byte_pair_encoding" rel="noopener" target="_blank">Byte pair encoding</a> to do precisely that. Its tokenizer uses a dictionary of 50257 code points (in AI parlance, &#34;tokens&#34;) that correspond to different byte sequences in UTF-8 (plus the &#34;end of text&#34; as a separate token).</p>
<p>This dictionary was built by statistical analysis performed like this:</p>
<ol>
<li>Start with a simple encoding of 256 tokens: one token per byte.</li>
<li>Take a large corpus of texts (preferably the one the model will be trained on).</li>
<li>Encode it.</li>
<li>Calculate which pair of tokens is the most frequent. Let&#39;s assume it&#39;s 0x20 0x74 (space followed by the lowercase &#34;t&#34;).</li>
<li>Assign the next available value (257) to this pair of bytes.</li>
<li>Repeat the steps 3-5, now paying attention to the byte sequences. If a sequence of bytes can be encoded with a complex token, use the complex token. If there are ambiguities (say, &#34;abc&#34; can, at some point, be encoded as &#34;a&#34; + &#34;bc&#34; or &#34;ab&#34; + &#34;c&#34;), use the one with the lowest number (because it was added earlier and hence is more frequent). Do this recursively until all sequences that can collapse into a single token will collapse into a single token.</li>
<li>Perform the collapse 50000 times over.</li>
</ol>
<p>The number 50000 was chosen more or less arbitrarily by the developers. Other models keep the number of tokens in a similar range (from 30k to 100k).</p>
<p>At every iteration of this algorithm, a new token that is a concatenation of two previous ones will be added to the dictionary. Ultimately, we will end up with 50256 tokens. Add a fixed-number token for &#34;end-of-text&#34;, and we&#39;re done.</p>
<p>The GPT2 version of BTE has another layer of encoding: the token dictionary maps tokens to strings and not arrays of bytes. Mapping from bytes to string characters is defined in <a href="https://github.com/openai/gpt-2/blob/a74da5d99abaaba920de8131d64da2862a8f213b/src/encoder.py#L9-L28" rel="noopener" target="_blank">this function</a>. We will save the dictionary it produces in the table <code>encoder</code>.</p>
<p>Let&#39;s see how we can implement the tokenizer in SQL.</p>
<p>The tokenizer is an integral part of GPT2, and the token dictionary can be downloaded from OpenAI&#39;s website along with the rest of the model. We will need to import it into the table <code>tokenizer</code>. At the bottom of this post, you will find a link to the code repository. Its code will automate populating database tables needed for the model.</p>
<p>In a recursive CTE, we will split this word into tokens (starting with single bytes) and merge the best adjacent pairs, until there is nothing left to merge. The merging itself happens in a nested recursive CTE.</p>
<p>For the demo, I will use the word &#34;Mississippilessly&#34;. Each record in the resultset shows the best pair to collapse found so far, and also the progress through the query.</p>
<pre title="">WITH    RECURSIVE
        bpe AS
        (
        SELECT  (n + 1)::BIGINT AS position, character, TRUE AS continue, 1 AS step,
                NULL::INT AS token, NULL::TEXT AS combined
        FROM    CONVERT_TO(&#39;Mississippilessly&#39;, &#39;UTF-8&#39;) AS bytes
        CROSS JOIN LATERAL
                GENERATE_SERIES(0, LENGTH(bytes) - 1) AS n
        JOIN    encoder
        ON      byte = GET_BYTE(bytes, n)
        UNION ALL
        (
        WITH    RECURSIVE
                base AS
                (
                SELECT  *
                FROM    bpe
                WHERE   continue
                ),
                bn AS
                (
                SELECT  ROW_NUMBER() OVER (ORDER BY position) AS position,
                        continue,
                        character,
                        character || LEAD(character) OVER (ORDER BY position) AS cluster
                FROM    base
                ),
                top_rank AS
                (
                SELECT  tokenizer.*
                FROM    bn
                CROSS JOIN LATERAL
                        (
                        SELECT  *
                        FROM    tokenizer
                        WHERE   tokenizer.cluster = bn.cluster
                        LIMIT   1
                        ) tokenizer
                ORDER BY
                        token
                LIMIT   1
                ),
                breaks AS
                (
                SELECT  0::BIGINT AS position, 1 AS length
                UNION ALL
                SELECT  bn.position,
                        CASE WHEN token IS NULL THEN 1 ELSE 2 END
                FROM    breaks
                JOIN    bn
                ON      bn.position = breaks.position + length
                LEFT JOIN
                        top_rank
                USING   (cluster)
                )
        SELECT  position, character, token IS NOT NULL,
                (SELECT step + 1 FROM base LIMIT 1), token, top_rank.cluster
        FROM    breaks
        LEFT JOIN
                top_rank
        ON      1 = 1
        CROSS JOIN LATERAL
                (
                SELECT  STRING_AGG(character, &#39;&#39; ORDER BY position) AS character
                FROM    bn
                WHERE   bn.position &gt;= breaks.position
                        AND bn.position &lt; breaks.position + length
                ) bn
        WHERE   position &gt; 0
        )
        )
SELECT  step, MAX(token) AS token, MAX(combined) AS combined, ARRAY_AGG(character ORDER BY position)
FROM    bpe
WHERE   continue
GROUP BY
        step
ORDER BY
        step
</pre>
<div>
<table>
<tbody><tr>
<th>step</th>
<th>token</th>
<th>combined</th>
<th>array_agg</th>
</tr>
<tr>
<td>1</td>
<td>None</td>
<td>None</td>
<td>[&#39;M&#39;, &#39;i&#39;, &#39;s&#39;, &#39;s&#39;, &#39;i&#39;, &#39;s&#39;, &#39;s&#39;, &#39;i&#39;, &#39;p&#39;, &#39;p&#39;, &#39;i&#39;, &#39;l&#39;, &#39;e&#39;, &#39;s&#39;, &#39;s&#39;, &#39;l&#39;, &#39;y&#39;]</td>
</tr>
<tr>
<td>2</td>
<td>271</td>
<td>is</td>
<td>[&#39;M&#39;, &#39;is&#39;, &#39;s&#39;, &#39;is&#39;, &#39;s&#39;, &#39;i&#39;, &#39;p&#39;, &#39;p&#39;, &#39;i&#39;, &#39;l&#39;, &#39;e&#39;, &#39;s&#39;, &#39;s&#39;, &#39;l&#39;, &#39;y&#39;]</td>
</tr>
<tr>
<td>3</td>
<td>274</td>
<td>es</td>
<td>[&#39;M&#39;, &#39;is&#39;, &#39;s&#39;, &#39;is&#39;, &#39;s&#39;, &#39;i&#39;, &#39;p&#39;, &#39;p&#39;, &#39;i&#39;, &#39;l&#39;, &#39;es&#39;, &#39;s&#39;, &#39;l&#39;, &#39;y&#39;]</td>
</tr>
<tr>
<td>4</td>
<td>306</td>
<td>ly</td>
<td>[&#39;M&#39;, &#39;is&#39;, &#39;s&#39;, &#39;is&#39;, &#39;s&#39;, &#39;i&#39;, &#39;p&#39;, &#39;p&#39;, &#39;i&#39;, &#39;l&#39;, &#39;es&#39;, &#39;s&#39;, &#39;ly&#39;]</td>
</tr>
<tr>
<td>5</td>
<td>346</td>
<td>il</td>
<td>[&#39;M&#39;, &#39;is&#39;, &#39;s&#39;, &#39;is&#39;, &#39;s&#39;, &#39;i&#39;, &#39;p&#39;, &#39;p&#39;, &#39;il&#39;, &#39;es&#39;, &#39;s&#39;, &#39;ly&#39;]</td>
</tr>
<tr>
<td>6</td>
<td>381</td>
<td>pp</td>
<td>[&#39;M&#39;, &#39;is&#39;, &#39;s&#39;, &#39;is&#39;, &#39;s&#39;, &#39;i&#39;, &#39;pp&#39;, &#39;il&#39;, &#39;es&#39;, &#39;s&#39;, &#39;ly&#39;]</td>
</tr>
<tr>
<td>7</td>
<td>408</td>
<td>ess</td>
<td>[&#39;M&#39;, &#39;is&#39;, &#39;s&#39;, &#39;is&#39;, &#39;s&#39;, &#39;i&#39;, &#39;pp&#39;, &#39;il&#39;, &#39;ess&#39;, &#39;ly&#39;]</td>
</tr>
<tr>
<td>8</td>
<td>747</td>
<td>iss</td>
<td>[&#39;M&#39;, &#39;iss&#39;, &#39;iss&#39;, &#39;i&#39;, &#39;pp&#39;, &#39;il&#39;, &#39;ess&#39;, &#39;ly&#39;]</td>
</tr>
<tr>
<td>9</td>
<td>3974</td>
<td>ipp</td>
<td>[&#39;M&#39;, &#39;iss&#39;, &#39;iss&#39;, &#39;ipp&#39;, &#39;il&#39;, &#39;ess&#39;, &#39;ly&#39;]</td>
</tr>
<tr>
<td>10</td>
<td>17140</td>
<td>Miss</td>
<td>[&#39;Miss&#39;, &#39;iss&#39;, &#39;ipp&#39;, &#39;il&#39;, &#39;ess&#39;, &#39;ly&#39;]</td>
</tr>
<tr>
<td>11</td>
<td>30608</td>
<td>iless</td>
<td>[&#39;Miss&#39;, &#39;iss&#39;, &#39;ipp&#39;, &#39;iless&#39;, &#39;ly&#39;]</td>
</tr>
</tbody></table>
</div>
<p>On each step, the BPE algorithm finds the best pair of tokens to merge and merges them (you can see the merged pair and its rank in the output). This procedure brings down the token space size from Unicode&#39;s 150k to 50k, and the number of tokens (in this particular word) from 17 to 5. Both are great improvements.</p>
<p>When working with multiple words, the tokenizer first splits the text into separate words using <a href="https://github.com/openai/gpt-2/blob/master/src/encoder.py#L53" rel="noopener" target="_blank">this regexp</a> and merges the tokens inside each word separately. Unfortunately, PostgreSQL doesn&#39;t support Unicode character properties in regexps, so I had to tweak it a little bit (probably killing proper Unicode support in the process). Here&#39;s how it looks in SQL:</p>
<pre title="">WITH    input AS
        (
        SELECT  &#39;PostgreSQL is great&#39; AS prompt
        ),
        clusters AS
        (
        SELECT  part_position, bpe.*
        FROM    input
        CROSS JOIN LATERAL
                REGEXP_MATCHES(prompt, &#39;&#39;&#39;s|&#39;&#39;t|&#39;&#39;re|&#39;&#39;ve|&#39;&#39;m|&#39;&#39;ll|&#39;&#39;d| ?\w+| ?\d+| ?[^\s\w\d]+|\s+(?!\S)|\s+&#39;, &#39;g&#39;) WITH ORDINALITY AS rm (part, part_position)
        CROSS JOIN LATERAL
                (
                WITH    RECURSIVE
                        bpe AS
                        (
                        SELECT  (n + 1)::BIGINT AS position, character, TRUE AS continue
                        FROM    CONVERT_TO(part[1], &#39;UTF-8&#39;) AS bytes
                        CROSS JOIN LATERAL
                                GENERATE_SERIES(0, LENGTH(bytes) - 1) AS n
                        JOIN    encoder
                        ON      byte = GET_BYTE(bytes, n)
                        UNION ALL
                        (
                        WITH    RECURSIVE
                                base AS
                                (
                                SELECT  *
                                FROM    bpe
                                WHERE   continue
                                ),
                                bn AS
                                (
                                SELECT  ROW_NUMBER() OVER (ORDER BY position) AS position,
                                        continue,
                                        character,
                                        character || LEAD(character) OVER (ORDER BY position) AS cluster
                                FROM    base
                                ),
                                top_rank AS
                                (
                                SELECT  tokenizer.*
                                FROM    bn
                                CROSS JOIN LATERAL
                                        (
                                        SELECT  *
                                        FROM    tokenizer
                                        WHERE   tokenizer.cluster = bn.cluster
                                        LIMIT   1
                                        ) tokenizer
                                ORDER BY
                                        token
                                LIMIT   1
                                ),
                                breaks AS
                                (
                                SELECT  0::BIGINT AS position, 1 AS length
                                UNION ALL
                                SELECT  bn.position,
                                        CASE WHEN token IS NULL THEN 1 ELSE 2 END
                                FROM    breaks
                                JOIN    bn
                                ON      bn.position = breaks.position + length
                                LEFT JOIN
                                        top_rank
                                USING   (cluster)
                                )
                        SELECT  position, character, token IS NOT NULL
                        FROM    breaks
                        LEFT JOIN
                                top_rank
                        ON      1 = 1
                        CROSS JOIN LATERAL
                                (
                                SELECT  STRING_AGG(character, &#39;&#39; ORDER BY position) AS character
                                FROM    bn
                                WHERE   bn.position &gt;= breaks.position
                                        AND bn.position &lt; breaks.position + length
                                ) bn
                        WHERE   position &gt; 0
                        )
                        )
                SELECT  position, character AS cluster
                FROM    bpe
                WHERE   NOT continue
                ) bpe
        ),
        tokens AS
        (
        SELECT  token, cluster
        FROM    clusters
        JOIN    tokenizer
        USING   (cluster)
        )
SELECT  *
FROM    tokens
</pre>
<div>
<table>
<tbody><tr>
<th>token</th>
<th>cluster</th>
</tr>
<tr>
<td>6307</td>
<td>Post</td>
</tr>
<tr>
<td>47701</td>
<td>greSQL</td>
</tr>
<tr>
<td>318</td>
<td>Ġis</td>
</tr>
<tr>
<td>1049</td>
<td>Ġgreat</td>
</tr>
</tbody></table>
</div>
<p>The weird character Ġ is the whitespace.</p>
<p>This query tokenizes the prompt and converts it into an array of numbers. This way, the prompt is ready for its journey through the layers of the model.</p>
<h3>Embeddings</h3>
<p>The tokens represent parts of the human languages (about 0.75 words per token, in general), so any model that is trying to succeed at text completion should somehow encode the relationships between these parts. Even in isolation, the parts of the speech have sets of orthogonal properties.</p>
<p>Let&#39;s take the word &#34;subpoena&#34; (which happens to have a whole token in itself in the GPT2 tokenizer). Is it a noun? Yes, very much so. Is it a verb? Well, sort of. Is it an adjective? Not that much, but it can be if you squint hard enough. Is it legalese? Hell yes. And so on.</p>
<p>All these properties are orthogonal, i.e. independent of each other. A word can be a legalese noun but not an adjective or a verb. In English, any combination thereof can happen.</p>
<p>Things with orthogonal properties are best encoded using vectors. Instead of having a single property (like a token number), we can have many. And it helps if we can wiggle them as we want. For instance, for a word to continue the phrase &#34;A court decision cited by the lawyer mentions the …&#34; we would probably want something that&#39;s heavy on the legalese dimension and at the same time heavy on being a noun. We don&#39;t really care if it has a side hustle being an adjective, a verb, or a flower.</p>
<p>In math, mapping narrower values into wider spaces (such as token IDs to vectors) is called an <a href="https://en.wikipedia.org/wiki/Embedding" rel="noopener" target="_blank">embedding</a>. This is exactly what we are doing here.</p>
<p>How do we decide which properties these vectors represent? We don&#39;t. We just provide enough vector space for every token and hope that the model during its training phase will populate these dimensions with something meaningful. GPT2 uses 768 dimensions for its vectors. There is no telling in advance (and, actually, even in the retrospective) what property of the word will, say, the dimension 247 encode. Surely it would encode something, but it&#39;s not easy to tell what it is.</p>
<p>What properties of each token do we want to embed in the vector space? Anything that has any bearing on what the next token would be.</p>
<p>Token id? Of course. Different tokens mean different things.</p>
<p>Position of the token in the text? Yes, please. &#34;Blue violet&#34; and &#34;violet blue&#34; are not the same thing.</p>
<p>Relationships of tokens to each other? Sure! That&#39;s, probably, the most important part of the job, and the Attention block of the Transformer architecture was the first one to get it right.</p>
<p>Tokens and positions are easy to embed. Let&#39;s say we have the phrase &#34;PostgreSQL is great&#34;, which, as we already know, maps to four tokens: <code>[6307, 47701, 318, 1049]</code>.</p>
<p>Among other parameters of GPT2, there are two matrixes called WTE (word token embedding) and WPE (word position embedding). As the names suggest, the former stores embeddings of the tokens, and the latter stores embeddings of the positions. The actual values of these embeddings have been populated (&#34;learned&#34;) during the training of GPT2. As far as we are concerned, they are constants that live in the database tables <code>wte</code> and <code>wpe</code>.</p>
<p>WTE is 50257×768 and WPE is 1024×768. The latter means that the maximum number of tokens that we can use in a prompt to GPT2 is 1024. If we provide more tokens in the prompt, we just won&#39;t be able to pull positional embeddings for them. It&#39;s an architectural aspect (&#34;hyperparameter&#34; in AI parlance) of the model that is set at design time and cannot be changed by training. When people talk about the &#34;context window&#34; of an LLM, they mean this number.</p>
<p>We have the token 6307 at place 0, 47701 at 1, 318 at 2, and 1049 at 3. For each of these tokens and positions, we have two vectors: one from WTE and another one from WPE. We need to <a href="https://github.com/jaymody/picoGPT/blob/29e78cc52b58ed2c1c483ffea2eb46ff6bdec785/gpt2.py#L75" rel="noopener" target="_blank">add them together</a>. The four resulting vectors will be the inputs for the next part of the algorithm: the feed-forward neural network with the attention mechanism.</p>
<p>For the SQL part, we will use <a href="https://github.com/pgvector/pgvector" rel="noopener" target="_blank">pgvector</a>, a PostgreSQL extension.</p>
<p><em>A little disclaimer: normally, I write code for my New Year posts in vanilla SQL, sometimes with pure SQL functions as helpers. It would be perfectly possible to do it for this post as well by defining vector operations on arrays, at the cost of some performance decrease (it was done in version 1 and worked, albeit slowly). With the advent of the AI and growing importance of vector databases, pgvector or its equivalent will definitely make it into the core of PostgreSQL within two or three releases. I just decided to ride the wave of the future.</em></p>
<p>Here&#39;s how we do that in SQL:</p>
<pre title="">WITH    embeddings AS
        (
        SELECT  place, values
        FROM    UNNEST(ARRAY[6307, 47701, 318, 1049]) WITH ORDINALITY AS tokens (token, ordinality)
        CROSS JOIN LATERAL
                (
                SELECT  ordinality - 1 AS place
                ) o
        CROSS JOIN LATERAL
                (
                SELECT  wte.values + wpe.values AS values
                FROM    wte
                CROSS JOIN
                        wpe
                WHERE   wte.token = tokens.token
                        AND wpe.place = o.place
                ) embedding
        )
SELECT  place, (values::REAL[])[0:5]
FROM    embeddings
</pre>
<div>
<table>
<tbody><tr>
<th>place</th>
<th>values</th>
</tr>
<tr>
<td>0</td>
<td>[0.1035146, -0.22879261, 0.18413992, -0.29924694, 0.18642524]</td>
</tr>
<tr>
<td>1</td>
<td>[0.10757777, -0.0011023134, -0.0077463835, 0.03656415, -0.14654925]</td>
</tr>
<tr>
<td>2</td>
<td>[-0.005507436, -0.07471258, 0.11009377, -0.11708109, -0.14026159]</td>
</tr>
<tr>
<td>3</td>
<td>[-0.04785268, -0.0792546, 0.1628486, -0.3598496, 0.11462127]</td>
</tr>
</tbody></table>
</div>
<p>(To keep the output short, this query only shows the first 5 dimensions for each vector)</p>
<h3>Attention</h3>
<p>The part that really makes the Transformer architecture tick is the self-attention mechanism. It was first described in the 2017 paper <a href="https://arxiv.org/abs/1706.03762" rel="noopener" target="_blank">&#34;Attention is all you need&#34;</a> by Vasmani et al., probably <em>the</em> most famous AI paper, whose name has since become a <a href="https://en.wikipedia.org/wiki/Snowclone" rel="noopener" target="_blank">snowclone</a> (a cliché for naming other papers).</p>
<p>So far, we have several vectors that, hopefully, encode some syntactic and semantic properties of the words in our prompt. We need these properties to somehow transfer to the last vector. A little spoiler alert: at the end of the day, it will be the last vector that will store the embedding for the continuation word.</p>
<p>In a phrase like &#34;I looked at the violet and saw that it was not the usual …&#34;, the ellipsis has to be something you see (and this notion has to jump from &#34;saw&#34;), something that&#39;s a property of a violet (jumping from &#34;violet&#34; to &#34;it&#34; and then to the ellipsis), and something that is &#34;unusual&#34; (jumping from &#34;not&#34; and &#34;usual&#34; and flipping the sign in the dimensions responsible for the usualness). The analogy in the real world would be a person reading a book in a foreign language that they kind of have a basic command of, but don&#39;t quite know very well. They would need to consciously trace their way from one word to another, and if they don&#39;t <em>pay attention</em> to the crucial part of the phrase, their understanding would be wrong.</p>
<p>To enable this transfer of meaning from one token to another, we need to allow the vectors of all the tokens to influence each other. If we want to populate the word &#34;it&#34; with some concrete semantics, how much of the semantics should come from the previous vectors in the prompt, and how much should remain from the word &#34;it&#34; itself?</p>
<p>To solve this problem, the model uses 12 sets of matrixes called Q (query), K (key) and V (value). Each of them has 64 columns. They are obtained from the vector embeddings through a 768×2304 linear transformation <code>c_attn</code>, whose weights and biases are stored in the tables <code>c_attn_w</code> and <code>c_attn_b</code>.</p>
<p>The result of <code>c_attn</code> is a matrix with <code>n_token</code> rows and 2304 columns (3×12×64). It consists of 12 Q matrixes, 12 K matrixes and 12 V matrixes stacked horizontally, in this order.</p>
<p>Each set of Q, K and V is called a &#34;head&#34;. They are used to perform the step known as &#34;multi-headed causal self-attention&#34;, by calculating the attention function.</p>
<p>Here&#39;s the formula for the attention function:</p>
<p><img decoding="async" src="https://s0.wp.com/latex.php?latex=A+%3D+%5Cmathrm%7Bsoftmax%7D%28%5Cdfrac%7BQK%5ET%7D%7B%5Csqrt%7Bd_k%7D%7D+%2B+M%29V&amp;bg=fff&amp;fg=1c1c1c&amp;s=0&amp;c=20201002" alt="A = \mathrm{softmax}(\dfrac{QK^T}{\sqrt{d_k}} + M)V"/>,</p>
<p>where softmax is the weight normalization function. It&#39;s defined like this:</p>
<p><img decoding="async" src="https://s0.wp.com/latex.php?latex=%5Cmathrm%7Bsoftmax_n%7D%28%5Ctextbf%7BR%7D%29+%3D+%5Cdfrac%7Be%5E%7BR_n%7D%7D%7B%5Csum%5Climits_n+e%5E%7BR_n%7D+%7D&amp;bg=fff&amp;fg=1c1c1c&amp;s=0&amp;c=20201002" alt="\mathrm{softmax_n}(\textbf{R}) = \dfrac{e^{R_n}}{\sum\limits_n e^{R_n} }"/></p>
<p><img decoding="async" src="https://s0.wp.com/latex.php?latex=M+&amp;bg=fff&amp;fg=1c1c1c&amp;s=0&amp;c=20201002" alt="M "/> is a constant matrix called a &#34;causal mask&#34;. It is defined like this: <img decoding="async" src="https://s0.wp.com/latex.php?latex=M+%3D+%5Cbegin%7Bbmatrix%7D++++++0+%26+-inf+%26+-inf+%26+%5Cdots++%26+-inf+%5C%5C++++++0+%26+0+%26+-inf+%26+%5Cdots++%26+-inf+%5C%5C++++++%5Cvdots+%26+%5Cvdots+%26+%5Cvdots+%26+%5Cddots+%26+%5Cvdots+%5C%5C++++++0+%26+0+%26+0+%26+%5Cdots+%26+-inf+%5C%5C++++++0+%26+0+%26+0+%26+%5Cdots+%26+0++%5Cend%7Bbmatrix%7D+&amp;bg=fff&amp;fg=1c1c1c&amp;s=0&amp;c=20201002" alt="M = \begin{bmatrix}      0 &amp; -inf &amp; -inf &amp; \dots  &amp; -inf \\      0 &amp; 0 &amp; -inf &amp; \dots  &amp; -inf \\      \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\      0 &amp; 0 &amp; 0 &amp; \dots &amp; -inf \\      0 &amp; 0 &amp; 0 &amp; \dots &amp; 0  \end{bmatrix} "/></p>
<p>Softmax turns negative infinities into zeros.</p>
<h4>Why do we need masking?</h4>
<p>The prompt in our previous examples had 4 tokens, and the first thing the model did was calculate the 4 embeddings for these 4 tokens. As the model progresses, these vectors will undergo a lot of calculations, but for the most part, they will be independent and parallel. Changes in one vector will not affect the other vectors, as if they had not existed. The self-attention block is the only place in the whole model where the vectors affect each other.</p>
<p>Once the model is done with the math, the candidates for the next token will be decided solely from the last embedding. All the information flow should be directed towards this last vector and not from it. The transient values of the last embedding should not affect the transient values of the previous embeddings during the forward pass of the model.</p>
<p>That&#39;s why we &#34;mask&#34; the latter embeddings so that they don&#39;t influence the earlier embeddings through this particular channel. Hence the word &#34;causal&#34; in &#34;multi-headed causal self-attention&#34;.</p>
<h4>Why are the matrixes called &#34;query&#34;, &#34;key&#34; and &#34;value&#34;?</h4>
<p>To be honest, I&#39;m not sure it&#39;s even a good analogy. But I&#39;ll still do my take on the intuition behind it.</p>
<p>In machine learning, generally, calculations should not involve variable-length loops or statement branching. Everything should be done through the composition of simple analytic functions (additions, multiplications, powers, logarithms and trig). It allows backpropagation, which relies on technologies like <a href="https://en.wikipedia.org/wiki/Automatic_differentiation" rel="noopener" target="_blank">automatic differentiation</a>, to work efficiently. </p>
<p>The mathematical model of the key-value store is the expression</p>
<p><img decoding="async" src="https://s0.wp.com/latex.php?latex=%5Cdisplaystyle+%5Cbegin%7Bcases%7Dv%2C+%26+k+%3D+q+%5C%5C+0%2C+%26+%5Ctext%7Botherwise%7D+%5Cend%7Bcases%7D&amp;bg=fff&amp;fg=1c1c1c&amp;s=0&amp;c=20201002" alt="\displaystyle \begin{cases}v, &amp; k = q \\ 0, &amp; \text{otherwise} \end{cases}"/></p>
<p>, but it&#39;s not a smooth, differentiable function and it will not work well with backpropagation. To make it work, we would need to turn it into a smooth function that would be <em>close</em> to <img decoding="async" src="https://s0.wp.com/latex.php?latex=v&amp;bg=fff&amp;fg=1c1c1c&amp;s=0&amp;c=20201002" alt="v"/> when <img decoding="async" src="https://s0.wp.com/latex.php?latex=k&amp;bg=fff&amp;fg=1c1c1c&amp;s=0&amp;c=20201002" alt="k"/> is close to <img decoding="async" src="https://s0.wp.com/latex.php?latex=q&amp;bg=fff&amp;fg=1c1c1c&amp;s=0&amp;c=20201002" alt="q"/>, and <em>close</em> to <img decoding="async" src="https://s0.wp.com/latex.php?latex=0&amp;bg=fff&amp;fg=1c1c1c&amp;s=0&amp;c=20201002" alt="0"/> otherwise.</p>
<p>The Gaussian distribution (&#34;bell curve&#34;), scaled to <img decoding="async" src="https://s0.wp.com/latex.php?latex=v&amp;bg=fff&amp;fg=1c1c1c&amp;s=0&amp;c=20201002" alt="v"/>, with the expectation of <img decoding="async" src="https://s0.wp.com/latex.php?latex=k&amp;bg=fff&amp;fg=1c1c1c&amp;s=0&amp;c=20201002" alt="k"/> and a small enough standard deviation would do perfectly for this purpose:</p>
<p><img decoding="async" src="https://s0.wp.com/latex.php?latex=%5Cdisplaystyle+%5Cfrac%7Bv%7D%7B%5Csigma%5Csqrt%7B2%5Cpi%7D%7D+%5C%2C+%5Cmathrm%7Bexp%7D%5Cleft%28-%5Cfrac%7B%5Cleft%28q+-+k%5Cright%29%5E2%7D%7B2%5Csigma%5E2%7D%5Cright%29&amp;bg=fff&amp;fg=1c1c1c&amp;s=0&amp;c=20201002" alt="\displaystyle \frac{v}{\sigma\sqrt{2\pi}} \, \mathrm{exp}\left(-\frac{\left(q - k\right)^2}{2\sigma^2}\right)"/></p>
<p>, where <img decoding="async" src="https://s0.wp.com/latex.php?latex=%5Csigma&amp;bg=fff&amp;fg=1c1c1c&amp;s=0&amp;c=20201002" alt="\sigma"/> is an arbitrary parameter, defining how sharp the bell curve is.</p>
<p>In a vector space with many enough dimensions, if we take a fixed vector <img decoding="async" src="https://s0.wp.com/latex.php?latex=%5Cmathbf+K&amp;bg=fff&amp;fg=1c1c1c&amp;s=0&amp;c=20201002" alt="\mathbf K"/> and several vectors <img decoding="async" src="https://s0.wp.com/latex.php?latex=%5Cmathbf+Q&amp;bg=fff&amp;fg=1c1c1c&amp;s=0&amp;c=20201002" alt="\mathbf Q"/> that randomly and uniformly deviate from <img decoding="async" src="https://s0.wp.com/latex.php?latex=%5Cmathbf+K&amp;bg=fff&amp;fg=1c1c1c&amp;s=0&amp;c=20201002" alt="\mathbf K"/> on every dimension, their dot products will naturally form the bell curve. So, in the vector space, the concept of a &#34;differentiable key-value store&#34; can be modeled by the expression <img decoding="async" src="https://s0.wp.com/latex.php?latex=%28%5Ctextbf+Q+%5Ccdot+%5Ctextbf+K%29+%5Ctextbf+V&amp;bg=fff&amp;fg=1c1c1c&amp;s=0&amp;c=20201002" alt="(\textbf Q \cdot \textbf K) \textbf V"/>, which is what we are using in our attention function.</p>
<p>Again, this analogy is far-fetched. It&#39;s best not to pay too much attention (no pun intended) to these concepts of attention, meaning flow, hash tables and so on. Just think of them as an inspiration for a math trick that has been put to the test and proved to work really well.</p>
<p>Let&#39;s illustrate this step:</p>
<pre title="">WITH    embeddings AS
        (
        SELECT  place, values
        FROM    UNNEST(ARRAY[6307, 47701, 318, 1049]) WITH ORDINALITY AS tokens (token, ordinality)
        CROSS JOIN LATERAL
                (
                SELECT  ordinality - 1 AS place
                ) o
        CROSS JOIN LATERAL
                (
                SELECT  wte.values + wpe.values AS values
                FROM    wte
                CROSS JOIN
                        wpe
                WHERE   wte.token = tokens.token
                        AND wpe.place = o.place
                ) embedding
        ),
        c_attn_w AS
        (
        SELECT  *
        FROM    c_attn_w
        WHERE   block = 0
        ),
        c_attn_b AS
        (
        SELECT  *
        FROM    c_attn_b
        WHERE   block = 0
        ),
        ln_1_g AS
        (
        SELECT  *
        FROM    ln_1_g
        WHERE   block = 0
        ),
        ln_1_b AS
        (
        SELECT  *
        FROM    ln_1_b
        WHERE   block = 0
        ),
        mha_norm AS
        (
        SELECT  place, mm.values + c_attn_b.values AS values
        FROM    (
                SELECT  place, ARRAY_AGG(INNER_PRODUCT(c_attn_w.values, layer_norm.values) ORDER BY y)::VECTOR(2304) AS values
                FROM    (
                        SELECT  place, agg.values * ln_1_g.values + ln_1_b.values AS values
                        FROM    (
                                SELECT  place, norm.values
                                FROM    embeddings
                                CROSS JOIN LATERAL
                                        (
                                        SELECT  AVG(value) AS mean,
                                                VAR_POP(value) AS variance
                                        FROM    UNNEST(values::REAL[]) value
                                        ) agg
                                CROSS JOIN LATERAL
                                        (
                                        SELECT  ARRAY_AGG((value - mean) / SQRT(variance + 1E-5) ORDER BY ordinality)::VECTOR(768) AS values
                                        FROM    UNNEST(values::REAL[]) WITH ORDINALITY AS n(value, ordinality)
                                        ) norm
                                ) agg
                        CROSS JOIN
                                ln_1_b
                        CROSS JOIN
                                ln_1_g
                        ) layer_norm
                CROSS JOIN
                        c_attn_w
                GROUP BY
                        place
                ) mm
        CROSS JOIN
                c_attn_b
        ),
        head AS
        (
        SELECT  place,
                (values::REAL[])[1:64]::VECTOR(64) AS q,
                (values::REAL[])[1 + 768:64 + 768]::VECTOR(64) AS k,
                (values::REAL[])[1 + 1536:64 + 1536]::VECTOR(64) AS v
        FROM    mha_norm
        ),
        sm_input AS
        (
        SELECT  h1.place AS x, h2.place AS y, INNER_PRODUCT(h1.q, h2.k) / 8 + CASE WHEN h2.place &gt; h1.place THEN -1E10 ELSE 0 END AS value
        FROM    head h1
        CROSS JOIN
                head h2
        ),
        sm_diff AS
        (
        SELECT  x, y, value - MAX(value) OVER (PARTITION BY x) AS diff
        FROM    sm_input
        ),
        sm_exp AS
        (
        SELECT  x, y, CASE WHEN diff &lt; -745.13 THEN 0 ELSE EXP(diff) END AS e
        FROM    sm_diff
        ),
        softmax AS
        (
        SELECT  x, y AS place, e / SUM(e) OVER (PARTITION BY x) AS value
        FROM    sm_exp
        ),
        attention AS
        (
        SELECT  place, (ARRAY_AGG(value ORDER BY ordinality))[:3] AS values
        FROM    (
                SELECT  x AS place, SUM(ARRAY_FILL(softmax.value, ARRAY[64])::VECTOR(64) * head.v) AS values
                FROM    softmax
                JOIN    head
                USING   (place)
                GROUP BY
                        x
                ) q
        CROSS JOIN LATERAL
                UNNEST(values::REAL[]) WITH ORDINALITY v (value, ordinality)
        GROUP BY
                place
        )
SELECT  place,
        (SELECT STRING_AGG(TO_CHAR(n, &#39;S0.000&#39;), &#39; &#39;) || &#39; …&#39; FROM UNNEST((q::REAL[])[:3]) AS n) AS q,
        (SELECT STRING_AGG(TO_CHAR(n, &#39;S0.000&#39;), &#39; &#39;) || &#39; …&#39; FROM UNNEST((k::REAL[])[:3]) AS n) AS k,
        (SELECT STRING_AGG(TO_CHAR(n, &#39;S0.000&#39;), &#39; &#39;) || &#39; …&#39; FROM UNNEST((v::REAL[])[:3]) AS n) AS v,
        matrix,
        (SELECT STRING_AGG(TO_CHAR(n, &#39;S0.000&#39;), &#39; &#39;) || &#39; …&#39; FROM UNNEST((values::REAL[])[:3]) AS n) AS attention
FROM    head
JOIN    attention
USING   (place)
JOIN    (
        SELECT  x AS place, STRING_AGG(CASE WHEN value &gt; 0 THEN TO_CHAR(value, &#39;0.00&#39;) ELSE &#39;    0&#39; END, &#39; &#39; ORDER BY place) AS matrix
        FROM    softmax
        GROUP BY
                x
        ) softmax_grouped
USING   (place)
</pre>
<div>
<table>
<tbody><tr>
<th>place</th>
<th>q</th>
<th>k</th>
<th>v</th>
<th>matrix</th>
<th>attention</th>
</tr>
<tr>
<td>0</td>
<td>+0.381 -0.579 +0.073 …</td>
<td>-1.395 +2.367 +0.332 …</td>
<td>-0.006 +0.192 +0.047 …</td>
<td> 1.00     0     0     0</td>
<td>-0.006 +0.192 +0.047 …</td>
</tr>
<tr>
<td>1</td>
<td>+1.518 +0.827 -0.388 …</td>
<td>-2.380 +3.714 +0.659 …</td>
<td>-0.315 -0.062 +0.018 …</td>
<td> 0.73  0.27     0     0</td>
<td>-0.089 +0.124 +0.039 …</td>
</tr>
<tr>
<td>2</td>
<td>+0.238 -0.226 +0.344 …</td>
<td>-1.952 +2.404 +1.953 …</td>
<td>+0.256 -0.268 +0.301 …</td>
<td> 0.67  0.26  0.07     0</td>
<td>-0.069 +0.095 +0.057 …</td>
</tr>
<tr>
<td>3</td>
<td>+1.130 -0.011 -0.103 …</td>
<td>-2.855 +2.053 +2.813 …</td>
<td>+0.176 +0.019 -0.099 …</td>
<td> 0.59  0.19  0.12  0.10</td>
<td>-0.016 +0.071 +0.058 …</td>
</tr>
</tbody></table>
</div>
<p>Here is what we did:</p>
<ol>
<li>Before calculating the attention function, we normalized the vectors by applying the linear transformation <img decoding="async" src="https://s0.wp.com/latex.php?latex=%5Cmathbf+R%5E%5Cprime+%3D+%5Cmathbf%7BR%5CGamma_1%7D+%2B+%5Cmathbf%7BB_1%7D&amp;bg=fff&amp;fg=1c1c1c&amp;s=0&amp;c=20201002" alt="\mathbf R^\prime = \mathbf{R\Gamma_1} + \mathbf{B_1}"/>. The matrix <img decoding="async" src="https://s0.wp.com/latex.php?latex=%5Cmathbf%7B%5CGamma_1%7D+&amp;bg=fff&amp;fg=1c1c1c&amp;s=0&amp;c=20201002" alt="\mathbf{\Gamma_1} "/> and the vector <img decoding="async" src="https://s0.wp.com/latex.php?latex=%5Cmathbf%7BB_1%7D+&amp;bg=fff&amp;fg=1c1c1c&amp;s=0&amp;c=20201002" alt="\mathbf{B_1} "/> are called &#34;scale&#34; and &#34;shift&#34;, accordingly. They are learned parameters of the model, which are stored in the tables <code>ln_1_g</code> and <code>ln_1_b</code></li>
<li>We are only showing the first head of the first layer of the algorithm. After we multiplied the vectors by the learned coefficients from <code>c_attn_w</code> and <code>c_attn_b</code> (&#34;weight&#34; and &#34;bias&#34;), we sliced the resulting 2304-vectors, taking 64-vectors starting at the positions 0, 768 and 1536. They correspond to the vectors Q, K and V for the first head.</li>
<li><code>EXP</code> in PostgreSQL fails on really small numbers, that&#39;s why we shortcut to zero if the argument to <code>EXP</code> is less than -745.13.</li>
<li>We are only showing the first three elements for each vector. The attention matrix we show in full.</li>
</ol>
<p>As we can see, the first value vector got copied to the output as is (as it will do in every other layer of the algorithm). It means that once the model has been trained, the output embedding for the first token will be only defined by the value of the first token. In general, during the recursive inference phase, where tokens only get added to the prompt, only the last embedding in the output will ever change compared to the previous iteration. This is what the causal mask does.</p>
<p>Looking a bit forward: the attention block is the <em>only</em> place in the entire algorithm where tokens can influence each other during the forward pass. Since we have disabled the ability of later tokens to influence the previous ones in this step, all the calculations done on the previous tokens can be reused between the forward passes of the model.</p>
<p>Remember, the model operates by appending tokens to the prompt. If our original (tokenized) prompt is &#34;Post greSQL Ġis Ġgreat&#34; and the next one will be (for instance) &#34;Post greSQL Ġis Ġgreat Ġfor&#34;, all the results of the calculations made on the first four tokens can be reused for the new prompt; they will never change, regardless of what is appended to them.</p>
<p>Jay Mody&#39;s illustrative article doesn&#39;t make use of this fact (and neither do we, for the sake of simplicity), but the original GPT2 implementation <a href="https://github.com/openai/gpt-2/blob/a74da5d99abaaba920de8131d64da2862a8f213b/src/model.py#L161" rel="noopener" target="_blank">does</a>.</p>
<p>Once all the heads are done, we will end up with 12 matrixes, each 64 columns wide and <code>n_tokens</code> rows tall. To map it back to the dimension of embedding vectors (768), we just need to stack these matrixes horizontally.</p>
<p>The final step of multi-headed attention involves projecting the values through a learned linear transformation of the same dimension. Its weights and biases are stored in the tables <code>c_proj_w</code> and <code>c_proj_b</code>.</p>
<p>Here&#39;s what the code for a complete multi-headed attention step in the first layer looks like:</p>
<pre title="">WITH    embeddings AS
        (
        SELECT  place, values
        FROM    UNNEST(ARRAY[6307, 47701, 318, 1049]) WITH ORDINALITY AS tokens (token, ordinality)
        CROSS JOIN LATERAL
                (
                SELECT  ordinality - 1 AS place
                ) o
        CROSS JOIN LATERAL
                (
                SELECT  wte.values + wpe.values AS values
                FROM    wte
                CROSS JOIN
                        wpe
                WHERE   wte.token = tokens.token
                        AND wpe.place = o.place
                ) embedding
        ),
        c_proj_w AS
        (
        SELECT  *
        FROM    c_proj_w
        WHERE   block = 0
        ),
        c_proj_b AS
        (
        SELECT  *
        FROM    c_proj_b
        WHERE   block = 0
        ),
        mlp_c_fc_w AS
        (
        SELECT  *
        FROM    mlp_c_fc_w
        WHERE   block = 0
        ),
        mlp_c_fc_b AS
        (
        SELECT  *
        FROM    mlp_c_fc_b
        WHERE   block = 0
        ),
        mlp_c_proj_w AS
        (
        SELECT  *
        FROM    mlp_c_proj_w
        WHERE   block = 0
        ),
        mlp_c_proj_b AS
        (
        SELECT  *
        FROM    mlp_c_proj_b
        WHERE   block = 0
        ),
        c_attn_w AS
        (
        SELECT  *
        FROM    c_attn_w
        WHERE   block = 0
        ),
        c_attn_b AS
        (
        SELECT  *
        FROM    c_attn_b
        WHERE   block = 0
        ),
        ln_1_g AS
        (
        SELECT  *
        FROM    ln_1_g
        WHERE   block = 0
        ),
        ln_1_b AS
        (
        SELECT  *
        FROM    ln_1_b
        WHERE   block = 0
        ),
        mha_norm AS
        (
        SELECT  place, mm.values + c_attn_b.values AS values
        FROM    (
                SELECT  place, ARRAY_AGG(INNER_PRODUCT(c_attn_w.values, layer_norm.values) ORDER BY y)::VECTOR(2304) AS values
                FROM    (
                        SELECT  place, agg.values * ln_1_g.values + ln_1_b.values AS values
                        FROM    (
                                SELECT  place, norm.values
                                FROM    embeddings
                                CROSS JOIN LATERAL
                                        (
                                        SELECT  AVG(value) AS mean,
                                                VAR_POP(value) AS variance
                                        FROM    UNNEST(values::REAL[]) value
                                        ) agg
                                CROSS JOIN LATERAL
                                        (
                                        SELECT  ARRAY_AGG((value - mean) / SQRT(variance + 1E-5) ORDER BY ordinality)::VECTOR(768) AS values
                                        FROM    UNNEST(values::REAL[]) WITH ORDINALITY AS n(value, ordinality)
                                        ) norm
                                ) agg
                        CROSS JOIN
                                ln_1_b
                        CROSS JOIN
                                ln_1_g
                        ) layer_norm
                CROSS JOIN
                        c_attn_w
                GROUP BY
                        place
                ) mm
        CROSS JOIN
                c_attn_b
        ),
        heads AS
        (
        SELECT  place, head,
                (values::REAL[])[(head * 64 + 1):(head * 64 + 64)]::VECTOR(64) AS q,
                (values::REAL[])[(head * 64 + 1 + 768):(head * 64 + 64 + 768)]::VECTOR(64) AS k,
                (values::REAL[])[(head * 64 + 1 + 1536):(head * 64 + 64 + 1536)]::VECTOR(64) AS v
        FROM    mha_norm
        CROSS JOIN
                GENERATE_SERIES(0, 11) head
        ),
        sm_input AS
        (
        SELECT  head, h1.place AS x, h2.place AS y, INNER_PRODUCT(h1.q, h2.k) / 8 + CASE WHEN h2.place &gt; h1.place THEN -1E10 ELSE 0 END AS value
        FROM    heads h1
        JOIN    heads h2
        USING   (head)
        ),
        sm_diff AS
        (
        SELECT  head, x, y, value - MAX(value) OVER (PARTITION BY head, x) AS diff
        FROM    sm_input
        ),
        sm_exp AS
        (
        SELECT  head, x, y, CASE WHEN diff &lt; -745.13 THEN 0 ELSE EXP(diff) END AS e
        FROM    sm_diff
        ),
        softmax AS
        (
        SELECT  head, x, y AS place, e / SUM(e) OVER (PARTITION BY head, x) AS value
        FROM    sm_exp
        ),
        attention AS
        (
        SELECT  place, ARRAY_AGG(value ORDER BY head * 64 + ordinality)::VECTOR(768) AS values
        FROM    (
                SELECT  head, x AS place, SUM(ARRAY_FILL(softmax.value, ARRAY[64])::VECTOR(64) * heads.v) AS values
                FROM    softmax
                JOIN    heads
                USING   (head, place)
                GROUP BY
                        head, x
                ) q
        CROSS JOIN LATERAL
                UNNEST(values::REAL[]) WITH ORDINALITY v (value, ordinality)
        GROUP BY
                place
        ),
        mha AS
        (
        SELECT  place, w.values + c_proj_b.values AS values
        FROM    (
                SELECT  attention.place, ARRAY_AGG(INNER_PRODUCT(attention.values, c_proj_w.values) ORDER BY c_proj_w.place)::VECTOR(768) AS values
                FROM    attention
                CROSS JOIN
                        c_proj_w
                GROUP BY
                        attention.place
                ) w
        CROSS JOIN
                c_proj_b
        )
SELECT  place,
        (SELECT STRING_AGG(TO_CHAR(n, &#39;S0.000&#39;), &#39; &#39;) || &#39; …&#39; FROM UNNEST((values::REAL[])[:10]) AS n) AS q
FROM    mha
</pre>
<div>
<table>
<tbody><tr>
<th>place</th>
<th>q</th>
</tr>
<tr>
<td>0</td>
<td>+0.814 -1.407 +0.171 +0.008 +0.065 -0.049 -0.407 +1.178 -0.234 -0.061 …</td>
</tr>
<tr>
<td>1</td>
<td>+1.150 -0.430 +0.083 +0.030 +0.010 +0.015 -0.245 +3.778 -0.445 -0.004 …</td>
</tr>
<tr>
<td>2</td>
<td>-0.219 -0.745 -0.116 +0.032 +0.064 -0.044 +0.290 +3.187 -0.074 -0.003 …</td>
</tr>
<tr>
<td>3</td>
<td>-0.526 -0.757 -0.510 -0.008 +0.027 -0.017 +0.302 +2.842 +0.188 -0.028 …</td>
</tr>
</tbody></table>
</div>
<p>Before the results of multi-headed attention are passed to the next step, the original inputs are added to them. This trick was described in the original transformer paper. It&#39;s supposed to help with vanishing and exploding gradients.</p>
<p>It&#39;s a common problem during training: sometimes the gradients of the parameters turn out too big or too small. Changing them on the training iteration either has very little effect on the loss function (and so the model converges very slowly), or, on the opposite, has such a big effect that even a small change throws the loss function too far away from its local minimum, negating the training efforts.</p>
<h3>Feedforward</h3>
<p>This is what the deep neural networks do. The larger part of the model parameters is actually used at this step.</p>
<p>This step is a <a href="https://en.wikipedia.org/wiki/Feedforward_neural_network#Multilayer_perceptron" rel="noopener" target="_blank">multi-layer perceptron</a> with three layers (768, 3072, 768), using the Gaussian Error Linear Unit (GELU) as an activation function:</p>
<p><img decoding="async" src="https://s0.wp.com/latex.php?latex=%5Cmathrm%7BGELU%7D%28x%29+%3D+%5Cdisplaystyle+%5Cfrac+x+2+%5Cleft%281+%2B+%5Cmathrm%7Berf%7D%5C%2C%5Cfrac+x+%7B%5Csqrt+2%7D%5Cright%29&amp;bg=fff&amp;fg=1c1c1c&amp;s=0&amp;c=20201002" alt="\mathrm{GELU}(x) = \displaystyle \frac x 2 \left(1 + \mathrm{erf}\,\frac x {\sqrt 2}\right)"/></p>
<p>This function <a href="https://arxiv.org/abs/1606.08415" rel="noopener" target="_blank">has been observed</a> to yield good results in deep neural networks. It can be analytically approximated like this:</p>
<p><img decoding="async" src="https://s0.wp.com/latex.php?latex=%5Cmathrm%7BGELU%7D%28x%29+%5Cdisplaystyle+%5Capprox+0.5x+%5Cleft%281+%2B+%5Cmathrm%7Btanh%7D%5Cleft%5B0.797884%5Cleft%28x+%2B+0.044715x%5E3%5Cright%29+%5Cright%5D%5Cright%29+&amp;bg=fff&amp;fg=1c1c1c&amp;s=0&amp;c=20201002" alt="\mathrm{GELU}(x) \displaystyle \approx 0.5x \left(1 + \mathrm{tanh}\left[0.797884\left(x + 0.044715x^3\right) \right]\right) "/></p>
<p>The learned linear transformation parameters for layer connections are called <code>c_fc</code> (768 → 3072) and <code>c_proj</code> (3072 → 768). The values for the first layer are first normalized using the coefficients in the learned parameter <code>ln_2</code>. After the feedforward step is completed, its input is again added to the output. This, too, is a part of the original transformer design.</p>
<p>The whole feedforward step looks like this:</p>
<p><img decoding="async" src="https://s0.wp.com/latex.php?latex=%5Cdisplaystyle+%5Cmathrm%7BFFN%7D%28%5Cmathbf+R%29+%3D+%5Cmathbf+R+%2B+%5Cmathrm%7Bc%5C_proj%7D%5Cleft%28%5Cmathrm%7BGELU%7D%5Cleft%28%5Cmathrm%7Bc%5C_fc%7D%5Cleft%28%5Cmathrm%7Bln%5C_2%7D%5Cleft%28%5Cmathbf+R%5Cright%29%5Cright%29%5Cright%29%5Cright%29+&amp;bg=fff&amp;fg=1c1c1c&amp;s=0&amp;c=20201002" alt="\displaystyle \mathrm{FFN}(\mathbf R) = \mathbf R + \mathrm{c\_proj}\left(\mathrm{GELU}\left(\mathrm{c\_fc}\left(\mathrm{ln\_2}\left(\mathbf R\right)\right)\right)\right) "/></p>
<p>And here&#39;s how we do this in SQL:</p>
<pre title="">WITH    embeddings AS
        (
        SELECT  place, values
        FROM    UNNEST(ARRAY[6307, 47701, 318, 1049]) WITH ORDINALITY AS tokens (token, ordinality)
        CROSS JOIN LATERAL
                (
                SELECT  ordinality - 1 AS place
                ) o
        CROSS JOIN LATERAL
                (
                SELECT  wte.values + wpe.values AS values
                FROM    wte
                CROSS JOIN
                        wpe
                WHERE   wte.token = tokens.token
                        AND wpe.place = o.place
                ) embedding
        ),
        c_proj_w AS
        (
        SELECT  *
        FROM    c_proj_w
        WHERE   block = 0
        ),
        c_proj_b AS
        (
        SELECT  *
        FROM    c_proj_b
        WHERE   block = 0
        ),
        mlp_c_fc_w AS
        (
        SELECT  *
        FROM    mlp_c_fc_w
        WHERE   block = 0
        ),
        mlp_c_fc_b AS
        (
        SELECT  *
        FROM    mlp_c_fc_b
        WHERE   block = 0
        ),
        mlp_c_proj_w AS
        (
        SELECT  *
        FROM    mlp_c_proj_w
        WHERE   block = 0
        ),
        mlp_c_proj_b AS
        (
        SELECT  *
        FROM    mlp_c_proj_b
        WHERE   block = 0
        ),
        c_attn_w AS
        (
        SELECT  *
        FROM    c_attn_w
        WHERE   block = 0
        ),
        c_attn_b AS
        (
        SELECT  *
        FROM    c_attn_b
        WHERE   block = 0
        ),
        ln_1_g AS
        (
        SELECT  *
        FROM    ln_1_g
        WHERE   block = 0
        ),
        ln_1_b AS
        (
        SELECT  *
        FROM    ln_1_b
        WHERE   block = 0
        ),
        ln_2_b AS
        (
        SELECT  *
        FROM    ln_2_b
        WHERE   block = 0
        ),
        ln_2_g AS
        (
        SELECT  *
        FROM    ln_2_g
        WHERE   block = 0
        ),
        mha_norm AS
        (
        SELECT  place, mm.values + c_attn_b.values AS values
        FROM    (
                SELECT  place, ARRAY_AGG(INNER_PRODUCT(c_attn_w.values, layer_norm.values) ORDER BY y)::VECTOR(2304) AS values
                FROM    (
                        SELECT  place, agg.values * ln_1_g.values + ln_1_b.values AS values
                        FROM    (
                                SELECT  place, norm.values
                                FROM    embeddings
                                CROSS JOIN LATERAL
                                        (
                                        SELECT  AVG(value) AS mean,
                                                VAR_POP(value) AS variance
                                        FROM    UNNEST(values::REAL[]) value
                                        ) agg
                                CROSS JOIN LATERAL
                                        (
                                        SELECT  ARRAY_AGG((value - mean) / SQRT(variance + 1E-5) ORDER BY ordinality)::VECTOR(768) AS values
                                        FROM    UNNEST(values::REAL[]) WITH ORDINALITY AS n(value, ordinality)
                                        ) norm
                                ) agg
                        CROSS JOIN
                                ln_1_b
                        CROSS JOIN
                                ln_1_g
                        ) layer_norm
                CROSS JOIN
                        c_attn_w
                GROUP BY
                        place
                ) mm
        CROSS JOIN
                c_attn_b
        ),
        heads AS
        (
        SELECT  place, head,
                (values::REAL[])[(head * 64 + 1):(head * 64 + 64)]::VECTOR(64) AS q,
                (values::REAL[])[(head * 64 + 1 + 768):(head * 64 + 64 + 768)]::VECTOR(64) AS k,
                (values::REAL[])[(head * 64 + 1 + 1536):(head * 64 + 64 + 1536)]::VECTOR(64) AS v
        FROM    mha_norm
        CROSS JOIN
                GENERATE_SERIES(0, 11) head
        ),
        sm_input AS
        (
        SELECT  head, h1.place AS x, h2.place AS y, INNER_PRODUCT(h1.q, h2.k) / 8 + CASE WHEN h2.place &gt; h1.place THEN -1E10 ELSE 0 END AS value
        FROM    heads h1
        JOIN    heads h2
        USING   (head)
        ),
        sm_diff AS
        (
        SELECT  head, x, y, value - MAX(value) OVER (PARTITION BY head, x) AS diff
        FROM    sm_input
        ),
        sm_exp AS
        (
        SELECT  head, x, y, CASE WHEN diff &lt; -745.13 THEN 0 ELSE EXP(diff) END AS e
        FROM    sm_diff
        ),
        softmax AS
        (
        SELECT  head, x, y AS place, e / SUM(e) OVER (PARTITION BY head, x) AS value
        FROM    sm_exp
        ),
        attention AS
        (
        SELECT  place, ARRAY_AGG(value ORDER BY head * 64 + ordinality)::VECTOR(768) AS values
        FROM    (
                SELECT  head, x AS place, SUM(ARRAY_FILL(softmax.value, ARRAY[64])::VECTOR(64) * heads.v) AS values
                FROM    softmax
                JOIN    heads
                USING   (head, place)
                GROUP BY
                        head, x
                ) q
        CROSS JOIN LATERAL
                UNNEST(values::REAL[]) WITH ORDINALITY v (value, ordinality)
        GROUP BY
                place
        ),
        mha AS
        (
        SELECT  place, w.values + c_proj_b.values + embeddings.values AS values
        FROM    (
                SELECT  attention.place, ARRAY_AGG(INNER_PRODUCT(attention.values, c_proj_w.values) ORDER BY c_proj_w.place)::VECTOR(768) AS values
                FROM    attention
                CROSS JOIN
                        c_proj_w
                GROUP BY
                        attention.place
                ) w
        CROSS JOIN
                c_proj_b
        JOIN    embeddings
        USING   (place)
        ),
        ffn_norm AS
        (
        SELECT  place, agg.values * ln_2_g.values + ln_2_b.values AS values
        FROM    (
                SELECT  place, norm.values
                FROM    mha
                CROSS JOIN LATERAL
                        (
                        SELECT  AVG(value) AS mean,
                                VAR_POP(value) AS variance
                        FROM    UNNEST(values::REAL[]) value
                        ) agg
                CROSS JOIN LATERAL
                        (
                        SELECT  ARRAY_AGG((value - mean) / SQRT(variance + 1E-5) ORDER BY ordinality)::VECTOR(768) AS values
                        FROM    UNNEST(values::REAL[]) WITH ORDINALITY AS n(value, ordinality)
                        ) norm
                ) agg
        CROSS JOIN
                ln_2_b
        CROSS JOIN
                ln_2_g
        ),
        ffn_a AS
        (
        SELECT  gelu.place, gelu.values
        FROM    (
                SELECT  place, w.values + mlp_c_fc_b.values AS values
                FROM    (
                        SELECT  ffn_norm.place, ARRAY_AGG(INNER_PRODUCT(ffn_norm.values, mlp_c_fc_w.values) ORDER BY mlp_c_fc_w.place)::VECTOR(3072) AS values
                        FROM    ffn_norm
                        CROSS JOIN
                                mlp_c_fc_w
                        GROUP BY
                                ffn_norm.place
                        ) w
                CROSS JOIN
                        mlp_c_fc_b
                ) v
        CROSS JOIN LATERAL
                (
                SELECT  place, ARRAY_AGG(0.5 * value * (1 + TANH(0.797884560802 * (value + 0.044715 * value*value*value))) ORDER BY ordinality)::VECTOR(3072) AS values
                FROM    UNNEST(values::REAL[]) WITH ORDINALITY n (value, ordinality)
                GROUP BY
                        place
                ) gelu
        ),
        ffn AS
        (
        SELECT  place, w.values + mlp_c_proj_b.values + mha.values AS values
        FROM    (
                SELECT  ffn_a.place, ARRAY_AGG(INNER_PRODUCT(ffn_a.values, mlp_c_proj_w.values) ORDER BY mlp_c_proj_w.place)::VECTOR(768) AS values
                FROM    ffn_a
                CROSS JOIN
                        mlp_c_proj_w
                GROUP BY
                        ffn_a.place
                ) w
        CROSS JOIN
                mlp_c_proj_b
        JOIN    mha
        USING   (place)
        )
SELECT  place,
        (SELECT STRING_AGG(TO_CHAR(n, &#39;S0.000&#39;), &#39; &#39;) || &#39; …&#39; FROM UNNEST((values::REAL[])[:10]) AS n) AS q
FROM    ffn
</pre>
<div>
<table>
<tbody><tr>
<th>place</th>
<th>q</th>
</tr>
<tr>
<td>0</td>
<td>+0.309 -1.267 -0.250 -1.111 -0.226 +0.549 -0.346 +0.645 -1.603 -0.501 …</td>
</tr>
<tr>
<td>1</td>
<td>+0.841 -1.081 +0.227 -1.029 -1.554 +1.061 -0.070 +5.258 -1.892 -0.973 …</td>
</tr>
<tr>
<td>2</td>
<td>-1.256 -0.528 -0.846 -0.288 +0.166 +0.409 +0.019 +3.393 +0.085 -0.212 …</td>
</tr>
<tr>
<td>3</td>
<td>-1.007 -1.719 -0.725 -1.417 -0.086 -0.144 +0.605 +3.272 +1.051 -0.666 …</td>
</tr>
</tbody></table>
</div>
<p>This output is what comes out of the first block of GPT2.</p>
<h3>Blocks</h3>
<p>What we saw in the previous steps is repeated in layers (called &#34;blocks&#34;). The blocks are set up in a pipeline so that the output of a previous block goes straight to the next one. Each block has its own set of learned parameters.</p>
<p>In SQL, we would need to connect the blocks using a recursive CTE.</p>
<p>Once the final block produces the values, we need to normalize it using the learned parameter <code>ln_f</code>.</p>
<p>Here&#39;s what the model ultimately looks like:</p>
<p><img decoding="async" src="https://s0.wp.com/latex.php?latex=%5Cdisplaystyle+%5Cmathrm%7BGPT%7D%28tokens%29+%3D+%5Cmathrm%7Bln%5C_f%7D%28%5Cmathbf+R_%7B12%7D%29&amp;bg=fff&amp;fg=1c1c1c&amp;s=0&amp;c=20201002" alt="\displaystyle \mathrm{GPT}(tokens) = \mathrm{ln\_f}(\mathbf R_{12})"/></p>
<p><img decoding="async" src="https://s0.wp.com/latex.php?latex=%5Cdisplaystyle+%5Cmathbf+R_%7Bn%7D+%3D+%5Cmathrm%7Bblock_n%7D%28%5Cmathbf+R_%7Bn-1%7D%29%2C+n+%3E+0&amp;bg=fff&amp;fg=1c1c1c&amp;s=0&amp;c=20201002" alt="\displaystyle \mathbf R_{n} = \mathrm{block_n}(\mathbf R_{n-1}), n &gt; 0"/></p>
<p><img decoding="async" src="https://s0.wp.com/latex.php?latex=%5Cdisplaystyle+%5Cmathrm%7Bblock_n%7D%28%5Cmathbf+R%29+%3D+%5Cmathrm%7Bffn_n%7D%28%5Cmathrm%7Bmha_n%7D%28%5Cmathbf+R%29%29&amp;bg=fff&amp;fg=1c1c1c&amp;s=0&amp;c=20201002" alt="\displaystyle \mathrm{block_n}(\mathbf R) = \mathrm{ffn_n}(\mathrm{mha_n}(\mathbf R))"/></p>
<p><img decoding="async" src="https://s0.wp.com/latex.php?latex=%5Cdisplaystyle+%5Cmathbf+R_0+%3D+%5Cmathrm%7Bwte%7D%28tokens%29+%2B+%5Cmathrm%7Bwpe%7D%28%5B1+%5Cldots+%5Cmathrm%7Bdim%7D%28tokens%29%5D%29&amp;bg=fff&amp;fg=1c1c1c&amp;s=0&amp;c=20201002" alt="\displaystyle \mathbf R_0 = \mathrm{wte}(tokens) + \mathrm{wpe}([1 \ldots \mathrm{dim}(tokens)])"/></p>
<p>And here&#39;s how it looks in SQL:</p>
<pre title="">WITH    RECURSIVE
        initial AS
        (
        SELECT  ARRAY[6307, 47701, 318, 1049] AS input
        ),
        hparams AS
        (
        SELECT  12 AS n_block
        ),
        embeddings AS
        (
        SELECT  place, values
        FROM    initial
        CROSS JOIN
                hparams
        CROSS JOIN LATERAL
                UNNEST(input) WITH ORDINALITY AS tokens (token, ordinality)
        CROSS JOIN LATERAL
                (
                SELECT  ordinality - 1 AS place
                ) o
        CROSS JOIN LATERAL
                (
                SELECT  wte.values + wpe.values AS values
                FROM    wte
                CROSS JOIN
                        wpe
                WHERE   wte.token = tokens.token
                        AND wpe.place = o.place
                ) embedding
        ),
        transform AS
        (
        SELECT  0 AS block, place, values
        FROM    embeddings
        UNION ALL
        (
        WITH    previous AS
                (
                SELECT  *
                FROM    transform
                )
        SELECT  block + 1 AS block, transformed_layer.*
        FROM    hparams
        CROSS JOIN LATERAL
                (
                SELECT  block
                FROM    previous
                WHERE   block &lt; 12
                LIMIT   1
                ) q
        CROSS JOIN LATERAL
                (
                WITH    ln_2_b AS
                        (
                        SELECT  *
                        FROM    ln_2_b
                        WHERE   block = q.block
                        ),
                        ln_2_g AS
                        (
                        SELECT  *
                        FROM    ln_2_g
                        WHERE   block = q.block
                        ),
                        c_proj_w AS
                        (
                        SELECT  *
                        FROM    c_proj_w
                        WHERE   block = q.block
                        ),
                        c_proj_b AS
                        (
                        SELECT  *
                        FROM    c_proj_b
                        WHERE   block = q.block
                        ),
                        mlp_c_fc_w AS
                        (
                        SELECT  *
                        FROM    mlp_c_fc_w
                        WHERE   block = q.block
                        ),
                        mlp_c_fc_b AS
                        (
                        SELECT  *
                        FROM    mlp_c_fc_b
                        WHERE   block = q.block
                        ),
                        mlp_c_proj_w AS
                        (
                        SELECT  *
                        FROM    mlp_c_proj_w
                        WHERE   block = q.block
                        ),
                        mlp_c_proj_b AS
                        (
                        SELECT  *
                        FROM    mlp_c_proj_b
                        WHERE   block = q.block
                        ),
                        c_attn_w AS
                        (
                        SELECT  *
                        FROM    c_attn_w
                        WHERE   block = q.block
                        ),
                        c_attn_b AS
                        (
                        SELECT  *
                        FROM    c_attn_b
                        WHERE   block = q.block
                        ),
                        ln_1_g AS
                        (
                        SELECT  *
                        FROM    ln_1_g
                        WHERE   block = q.block
                        ),
                        ln_1_b AS
                        (
                        SELECT  *
                        FROM    ln_1_b
                        WHERE   block = q.block
                        ),
                        mha_norm AS
                        (
                        SELECT  place, mm.values + c_attn_b.values AS values
                        FROM    (
                                SELECT  place, ARRAY_AGG(INNER_PRODUCT(c_attn_w.values, layer_norm.values) ORDER BY y)::VECTOR(2304) AS values
                                FROM    (
                                        SELECT  place, agg.values * ln_1_g.values + ln_1_b.values AS values
                                        FROM    (
                                                SELECT  place, norm.values
                                                FROM    previous
                                                CROSS JOIN LATERAL
                                                        (
                                                        SELECT  AVG(value) AS mean,
                                                                VAR_POP(value) AS variance
                                                        FROM    UNNEST(values::REAL[]) value
                                                        ) agg
                                                CROSS JOIN LATERAL
                                                        (
                                                        SELECT  ARRAY_AGG((value - mean) / SQRT(variance + 1E-5) ORDER BY ordinality)::VECTOR(768) AS values
                                                        FROM    UNNEST(values::REAL[]) WITH ORDINALITY AS n(value, ordinality)
                                                        ) norm
                                                ) agg
                                        CROSS JOIN
                                                ln_1_b
                                        CROSS JOIN
                                                ln_1_g
                                        ) layer_norm
                                CROSS JOIN
                                        c_attn_w
                                GROUP BY
                                        place
                                ) mm
                        CROSS JOIN
                                c_attn_b
                        ),
                        heads AS
                        (
                        SELECT  place, head,
                                (values::REAL[])[(head * 64 + 1):(head * 64 + 64)]::VECTOR(64) AS q,
                                (values::REAL[])[(head * 64 + 1 + 768):(head * 64 + 64 + 768)]::VECTOR(64) AS k,
                                (values::REAL[])[(head * 64 + 1 + 1536):(head * 64 + 64 + 1536)]::VECTOR(64) AS v
                        FROM    mha_norm
                        CROSS JOIN
                                GENERATE_SERIES(0, 11) head
                        ),
                        sm_input AS
                        (
                        SELECT  head, h1.place AS x, h2.place AS y, INNER_PRODUCT(h1.q, h2.k) / 8 + CASE WHEN h2.place &gt; h1.place THEN -1E10 ELSE 0 END AS value
                        FROM    heads h1
                        JOIN    heads h2
                        USING   (head)
                        ),
                        sm_diff AS
                        (
                        SELECT  head, x, y, value - MAX(value) OVER (PARTITION BY head, x) AS diff
                        FROM    sm_input
                        ),
                        sm_exp AS
                        (
                        SELECT  head, x, y, CASE WHEN diff &lt; -745.13 THEN 0 ELSE EXP(diff) END AS e
                        FROM    sm_diff
                        ),
                        softmax AS
                        (
                        SELECT  head, x, y AS place, e / SUM(e) OVER (PARTITION BY head, x) AS value
                        FROM    sm_exp
                        ),
                        attention AS
                        (
                        SELECT  place, ARRAY_AGG(value ORDER BY head * 64 + ordinality)::VECTOR(768) AS values
                        FROM    (
                                SELECT  head, x AS place, SUM(ARRAY_FILL(softmax.value, ARRAY[64])::VECTOR(64) * heads.v) AS values
                                FROM    softmax
                                JOIN    heads
                                USING   (head, place)
                                GROUP BY
                                        head, x
                                ) q
                        CROSS JOIN LATERAL
                                UNNEST(values::REAL[]) WITH ORDINALITY v (value, ordinality)
                        GROUP BY
                                place
                        ),
                        mha AS
                        (
                        SELECT  place, w.values + c_proj_b.values + previous.values AS values
                        FROM    (
                                SELECT  attention.place, ARRAY_AGG(INNER_PRODUCT(attention.values, c_proj_w.values) ORDER BY c_proj_w.place)::VECTOR(768) AS values
                                FROM    attention
                                CROSS JOIN
                                        c_proj_w
                                GROUP BY
                                        attention.place
                                ) w
                        CROSS JOIN
                                c_proj_b
                        JOIN    previous
                        USING   (place)
                        ),
                        ffn_norm AS
                        (
                        SELECT  place, agg.values * ln_2_g.values + ln_2_b.values AS values
                        FROM    (
                                SELECT  place, norm.values
                                FROM    mha
                                CROSS JOIN LATERAL
                                        (
                                        SELECT  AVG(value) AS mean,
                                                VAR_POP(value) AS variance
                                        FROM    UNNEST(values::REAL[]) value
                                        ) agg
                                CROSS JOIN LATERAL
                                        (
                                        SELECT  ARRAY_AGG((value - mean) / SQRT(variance + 1E-5) ORDER BY ordinality)::VECTOR(768) AS values
                                        FROM    UNNEST(values::REAL[]) WITH ORDINALITY AS n(value, ordinality)
                                        ) norm
                                ) agg
                        CROSS JOIN
                                ln_2_b
                        CROSS JOIN
                                ln_2_g
                        ),
                        ffn_a AS
                        (
                        SELECT  gelu.place, gelu.values
                        FROM    (
                                SELECT  place, w.values + mlp_c_fc_b.values AS values
                                FROM    (
                                        SELECT  ffn_norm.place, ARRAY_AGG(INNER_PRODUCT(ffn_norm.values, mlp_c_fc_w.values) ORDER BY mlp_c_fc_w.place)::VECTOR(3072) AS values
                                        FROM    ffn_norm
                                        CROSS JOIN
                                                mlp_c_fc_w
                                        GROUP BY
                                                ffn_norm.place
                                        ) w
                                CROSS JOIN
                                        mlp_c_fc_b
                                ) v
                        CROSS JOIN LATERAL
                                (
                                SELECT  place, ARRAY_AGG(0.5 * value * (1 + TANH(0.797884560802 * (value + 0.044715 * value*value*value))) ORDER BY ordinality)::VECTOR(3072) AS values
                                FROM    UNNEST(values::REAL[]) WITH ORDINALITY n (value, ordinality)
                                GROUP BY
                                        place
                                ) gelu
                        ),
                        ffn AS
                        (
                        SELECT  place, w.values + mlp_c_proj_b.values + mha.values AS values
                        FROM    (
                                SELECT  ffn_a.place, ARRAY_AGG(INNER_PRODUCT(ffn_a.values, mlp_c_proj_w.values) ORDER BY mlp_c_proj_w.place)::VECTOR(768) AS values
                                FROM    ffn_a
                                CROSS JOIN
                                        mlp_c_proj_w
                                GROUP BY
                                        ffn_a.place
                                ) w
                        CROSS JOIN
                                mlp_c_proj_b
                        JOIN    mha
                        USING   (place)
                        )
                SELECT  *
                FROM    ffn
                ) transformed_layer
        )
        ),
        block_output AS
        (
        SELECT  *
        FROM    hparams
        JOIN    transform
        ON      transform.block = n_block
        ),
        ln_f AS
        (
        SELECT  place, norm.values * ln_f_g.values + ln_f_b.values AS values
        FROM    block_output
        CROSS JOIN LATERAL
                (
                SELECT  AVG(value) AS mean,
                        VAR_POP(value) AS variance
                FROM    UNNEST(values::REAL[]) AS n(value)
                ) agg
        CROSS JOIN LATERAL
                (
                SELECT  ARRAY_AGG((value - mean) / SQRT(variance + 1E-5) ORDER BY ordinality)::VECTOR(768) AS values
                FROM    UNNEST(values::REAL[]) WITH ORDINALITY AS n (value, ordinality)
                ) norm
        CROSS JOIN
                ln_f_b
        CROSS JOIN
                ln_f_g
        )
SELECT  place,
        (SELECT STRING_AGG(TO_CHAR(n, &#39;S0.000&#39;), &#39; &#39;) || &#39; …&#39; FROM UNNEST((values::REAL[])[:10]) AS n) AS q
FROM    ln_f
</pre>
<div>
<table>
<tbody><tr>
<th>place</th>
<th>q</th>
</tr>
<tr>
<td>0</td>
<td>-0.153 -0.126 -0.368 +0.028 -0.013 -0.198 +0.661 +0.056 -0.228 -0.001 …</td>
</tr>
<tr>
<td>1</td>
<td>-0.157 -0.314 +0.291 -0.386 -0.273 -0.054 +3.397 +0.440 -0.137 -0.243 …</td>
</tr>
<tr>
<td>2</td>
<td>-0.912 -0.220 -0.886 -0.661 +0.491 -0.050 +0.693 +1.128 +0.031 -0.577 …</td>
</tr>
<tr>
<td>3</td>
<td>-0.098 -0.323 -1.479 -0.736 +0.235 -0.608 +1.774 +0.566 -0.057 -0.211 …</td>
</tr>
</tbody></table>
</div>
<p>This is the output of the model. </p>
<p>The fourth vector is the actual embedding of the next token predicted by the model. We just need to map it back to the tokens.</p>
<h3>Tokens</h3>
<p>We have an embedding (a 768-vector) which, according to the model, captures the semantics and the grammar of the most likely continuation of the prompt. Now we need to map it back to the token.</p>
<p>One of the first steps the model makes is mapping the tokens to their embeddings. It is done through the 50257×768 matrix <code>wpe</code>. We will need to use the same matrix to map the embedding back to the token.</p>
<p>The problem is that the exact reverse mapping is not possible: the embedding will not (likely) be equal to any of the rows in the matrix. So we will need to find the &#34;closest&#34; token to the embedding.</p>
<p>Since the dimensions of embeddings capture (as we hope) some semantic and grammatical aspects of the token, we need them to match as closely as possible. One way to consolidate the closeness of each dimension would be to just calculate the dot product of the two embeddings. The higher the dot product, the closer the token is to the prediction.</p>
<p>To do this, we will multiply the embedding by the matrix <code>wte</code>. The result will be a single-column matrix, 50257 rows tall. Each value in this result will be the dot product of the predicted embedding and the token embedding. The higher this number, the more likely it is for the token to continue the prompt.</p>
<p>To pick the next token, we will need to convert the similarities to probabilities. To do this, we will use our good friend softmax (the same function that we used to normalize attention weights).</p>
<h4>Why use softmax for probabilities?</h4>
<p>Softmax has the nice property of satisfying <a href="https://en.wikipedia.org/wiki/Luce%27s_choice_axiom" rel="noopener" target="_blank">Luce&#39;s choice axiom</a>. It means that the relative probabilities of two options don&#39;t depend on the presence or probability of other options. If A is twice as probable as B, then the presence or absence of other options will not change this ratio (although it of course can change the absolute values).</p>
<p>The vector of dot products (&#34;logit&#34; in AI parlance) contains arbitrary scores that don&#39;t have an intrinsic scale. If A has a larger score than B, we know that it&#39;s more likely, but that&#39;s about it. We can tweak the inputs to softmax as we please, as long as they keep their order (i.e. larger scores stay larger).</p>
<p>One common way to do that is to normalize the scores by subtracting the greatest value from the set from them (so that the biggest score becomes 0 and the rest become negative numbers). Then we take some fixed number (let&#39;s say five or ten) top scores. Finally, we multiply each score by a constant before feeding it to softmax.</p>
<p>The number of top scores that we take is usually called <img decoding="async" src="https://s0.wp.com/latex.php?latex=top%5C_n&amp;bg=fff&amp;fg=1c1c1c&amp;s=0&amp;c=20201002" alt="top\_n"/> and the multiplication constant (or, rather, its reverse) is called &#34;temperature&#34; (<img decoding="async" src="https://s0.wp.com/latex.php?latex=T&amp;bg=fff&amp;fg=1c1c1c&amp;s=0&amp;c=20201002" alt="T"/>). The higher the temperature, the more smoothed out the probabilities, and the bigger the chance that the next picked token will not be just the first one.</p>
<p>The formula for tokens&#39; probabilities is <img decoding="async" src="https://s0.wp.com/latex.php?latex=%5Cdisplaystyle+p_n+%3D+%5Cmathrm%7Bsoftmax_n%5Cleft%28%5Cfrac%7B%5Cmathbf%7Bscores%7D%7D%7BT%7D%5Cright%29%7D&amp;bg=fff&amp;fg=1c1c1c&amp;s=0&amp;c=20201002" alt="\displaystyle p_n = \mathrm{softmax_n\left(\frac{\mathbf{scores}}{T}\right)}"/>, where <img decoding="async" src="https://s0.wp.com/latex.php?latex=%5Cmathbf%7Bscores%7D&amp;bg=fff&amp;fg=1c1c1c&amp;s=0&amp;c=20201002" alt="\mathbf{scores}"/> is the set of <img decoding="async" src="https://s0.wp.com/latex.php?latex=top%5C_n&amp;bg=fff&amp;fg=1c1c1c&amp;s=0&amp;c=20201002" alt="top\_n"/> scores.</p>
<h4>Why is it called &#34;temperature&#34;?</h4>
<p>The softmax function has another name: <a href="https://en.wikipedia.org/wiki/Boltzmann_distribution" rel="noopener" target="_blank">Boltzmann distribution</a>. It&#39;s extensively used in physics. Among other things, it serves as a base for the <a href="https://en.wikipedia.org/wiki/Barometric_formula" rel="noopener" target="_blank">barometric formula</a>, which tells how density or air varies with altitude.</p>
<p>Intuitively, hot air rises. It spreads further away from the Earth. When air is hot, it&#39;s more likely for an air molecule to bounce off its neighbors and jump at an otherwise impossible height. Compared to colder temperatures, air density increases at higher altitudes and drops at sea level.</p>
<p>See how air behaves at different temperatures:</p>


<p><em>Courtesy of Dominic Ford, <a href="https://sciencedemos.org.uk/balls.php" rel="noopener" target="_blank">Bouncing Balls and the Boltzmann Distribution</a></em></p>
<p>By analogy, a large &#34;temperature&#34; increases the probability of second-choice tokens being selected (at the expense of the first-choice tokens, of course). The inference becomes less predictable and more &#34;creative&#34;.</p>
<p>Let&#39;s put this all into SQL. The prompt was &#34;PostgreSQL is great&#34;. Here are the top 5 tokens that, according to the model, are most likely to continue this phrase, and their probabilities at different temperatures:</p>
<pre title="">WITH    RECURSIVE
        initial AS
        (
        SELECT  ARRAY[6307, 47701, 318, 1049] AS input
        ),
        hparams AS
        (
        SELECT  12 AS n_block,
                5 AS top_n,
                ARRAY_LENGTH(input, 1) AS n_seq
        FROM    initial
        ),
        embeddings AS
        (
        SELECT  place, values
        FROM    initial
        CROSS JOIN
                hparams
        CROSS JOIN LATERAL
                UNNEST(input) WITH ORDINALITY AS tokens (token, ordinality)
        CROSS JOIN LATERAL
                (
                SELECT  ordinality - 1 AS place
                ) o
        CROSS JOIN LATERAL
                (
                SELECT  wte.values + wpe.values AS values
                FROM    wte
                CROSS JOIN
                        wpe
                WHERE   wte.token = tokens.token
                        AND wpe.place = o.place
                ) embedding
        ),
        transform AS
        (
        SELECT  0 AS block, place, values
        FROM    embeddings
        UNION ALL
        (
        WITH    previous AS
                (
                SELECT  *
                FROM    transform
                )
        SELECT  block + 1 AS block, transformed_layer.*
        FROM    hparams
        CROSS JOIN LATERAL
                (
                SELECT  block
                FROM    previous
                WHERE   block &lt; 12
                LIMIT   1
                ) q
        CROSS JOIN LATERAL
                (
                WITH    ln_2_b AS
                        (
                        SELECT  *
                        FROM    ln_2_b
                        WHERE   block = q.block
                        ),
                        ln_2_g AS
                        (
                        SELECT  *
                        FROM    ln_2_g
                        WHERE   block = q.block
                        ),
                        c_proj_w AS
                        (
                        SELECT  *
                        FROM    c_proj_w
                        WHERE   block = q.block
                        ),
                        c_proj_b AS
                        (
                        SELECT  *
                        FROM    c_proj_b
                        WHERE   block = q.block
                        ),
                        mlp_c_fc_w AS
                        (
                        SELECT  *
                        FROM    mlp_c_fc_w
                        WHERE   block = q.block
                        ),
                        mlp_c_fc_b AS
                        (
                        SELECT  *
                        FROM    mlp_c_fc_b
                        WHERE   block = q.block
                        ),
                        mlp_c_proj_w AS
                        (
                        SELECT  *
                        FROM    mlp_c_proj_w
                        WHERE   block = q.block
                        ),
                        mlp_c_proj_b AS
                        (
                        SELECT  *
                        FROM    mlp_c_proj_b
                        WHERE   block = q.block
                        ),
                        c_attn_w AS
                        (
                        SELECT  *
                        FROM    c_attn_w
                        WHERE   block = q.block
                        ),
                        c_attn_b AS
                        (
                        SELECT  *
                        FROM    c_attn_b
                        WHERE   block = q.block
                        ),
                        ln_1_g AS
                        (
                        SELECT  *
                        FROM    ln_1_g
                        WHERE   block = q.block
                        ),
                        ln_1_b AS
                        (
                        SELECT  *
                        FROM    ln_1_b
                        WHERE   block = q.block
                        ),
                        mha_norm AS
                        (
                        SELECT  place, mm.values + c_attn_b.values AS values
                        FROM    (
                                SELECT  place, ARRAY_AGG(INNER_PRODUCT(c_attn_w.values, layer_norm.values) ORDER BY y)::VECTOR(2304) AS values
                                FROM    (
                                        SELECT  place, agg.values * ln_1_g.values + ln_1_b.values AS values
                                        FROM    (
                                                SELECT  place, norm.values
                                                FROM    previous
                                                CROSS JOIN LATERAL
                                                        (
                                                        SELECT  AVG(value) AS mean,
                                                                VAR_POP(value) AS variance
                                                        FROM    UNNEST(values::REAL[]) value
                                                        ) agg
                                                CROSS JOIN LATERAL
                                                        (
                                                        SELECT  ARRAY_AGG((value - mean) / SQRT(variance + 1E-5) ORDER BY ordinality)::VECTOR(768) AS values
                                                        FROM    UNNEST(values::REAL[]) WITH ORDINALITY AS n(value, ordinality)
                                                        ) norm
                                                ) agg
                                        CROSS JOIN
                                                ln_1_b
                                        CROSS JOIN
                                                ln_1_g
                                        ) layer_norm
                                CROSS JOIN
                                        c_attn_w
                                GROUP BY
                                        place
                                ) mm
                        CROSS JOIN
                                c_attn_b
                        ),
                        heads AS
                        (
                        SELECT  place, head,
                                (values::REAL[])[(head * 64 + 1):(head * 64 + 64)]::VECTOR(64) AS q,
                                (values::REAL[])[(head * 64 + 1 + 768):(head * 64 + 64 + 768)]::VECTOR(64) AS k,
                                (values::REAL[])[(head * 64 + 1 + 1536):(head * 64 + 64 + 1536)]::VECTOR(64) AS v
                        FROM    mha_norm
                        CROSS JOIN
                                GENERATE_SERIES(0, 11) head
                        ),
                        sm_input AS
                        (
                        SELECT  head, h1.place AS x, h2.place AS y, INNER_PRODUCT(h1.q, h2.k) / 8 + CASE WHEN h2.place &gt; h1.place THEN -1E10 ELSE 0 END AS value
                        FROM    heads h1
                        JOIN    heads h2
                        USING   (head)
                        ),
                        sm_diff AS
                        (
                        SELECT  head, x, y, value - MAX(value) OVER (PARTITION BY head, x) AS diff
                        FROM    sm_input
                        ),
                        sm_exp AS
                        (
                        SELECT  head, x, y, CASE WHEN diff &lt; -745.13 THEN 0 ELSE EXP(diff) END AS e
                        FROM    sm_diff
                        ),
                        softmax AS
                        (
                        SELECT  head, x, y AS place, e / SUM(e) OVER (PARTITION BY head, x) AS value
                        FROM    sm_exp
                        ),
                        attention AS
                        (
                        SELECT  place, ARRAY_AGG(value ORDER BY head * 64 + ordinality)::VECTOR(768) AS values
                        FROM    (
                                SELECT  head, x AS place, SUM(ARRAY_FILL(softmax.value, ARRAY[64])::VECTOR(64) * heads.v) AS values
                                FROM    softmax
                                JOIN    heads
                                USING   (head, place)
                                GROUP BY
                                        head, x
                                ) q
                        CROSS JOIN LATERAL
                                UNNEST(values::REAL[]) WITH ORDINALITY v (value, ordinality)
                        GROUP BY
                                place
                        ),
                        mha AS
                        (
                        SELECT  place, w.values + c_proj_b.values + previous.values AS values
                        FROM    (
                                SELECT  attention.place, ARRAY_AGG(INNER_PRODUCT(attention.values, c_proj_w.values) ORDER BY c_proj_w.place)::VECTOR(768) AS values
                                FROM    attention
                                CROSS JOIN
                                        c_proj_w
                                GROUP BY
                                        attention.place
                                ) w
                        CROSS JOIN
                                c_proj_b
                        JOIN    previous
                        USING   (place)
                        ),
                        ffn_norm AS
                        (
                        SELECT  place, agg.values * ln_2_g.values + ln_2_b.values AS values
                        FROM    (
                                SELECT  place, norm.values
                                FROM    mha
                                CROSS JOIN LATERAL
                                        (
                                        SELECT  AVG(value) AS mean,
                                                VAR_POP(value) AS variance
                                        FROM    UNNEST(values::REAL[]) value
                                        ) agg
                                CROSS JOIN LATERAL
                                        (
                                        SELECT  ARRAY_AGG((value - mean) / SQRT(variance + 1E-5) ORDER BY ordinality)::VECTOR(768) AS values
                                        FROM    UNNEST(values::REAL[]) WITH ORDINALITY AS n(value, ordinality)
                                        ) norm
                                ) agg
                        CROSS JOIN
                                ln_2_b
                        CROSS JOIN
                                ln_2_g
                        ),
                        ffn_a AS
                        (
                        SELECT  gelu.place, gelu.values
                        FROM    (
                                SELECT  place, w.values + mlp_c_fc_b.values AS values
                                FROM    (
                                        SELECT  ffn_norm.place, ARRAY_AGG(INNER_PRODUCT(ffn_norm.values, mlp_c_fc_w.values) ORDER BY mlp_c_fc_w.place)::VECTOR(3072) AS values
                                        FROM    ffn_norm
                                        CROSS JOIN
                                                mlp_c_fc_w
                                        GROUP BY
                                                ffn_norm.place
                                        ) w
                                CROSS JOIN
                                        mlp_c_fc_b
                                ) v
                        CROSS JOIN LATERAL
                                (
                                SELECT  place, ARRAY_AGG(0.5 * value * (1 + TANH(0.797884560802 * (value + 0.044715 * value*value*value))) ORDER BY ordinality)::VECTOR(3072) AS values
                                FROM    UNNEST(values::REAL[]) WITH ORDINALITY n (value, ordinality)
                                GROUP BY
                                        place
                                ) gelu
                        ),
                        ffn AS
                        (
                        SELECT  place, w.values + mlp_c_proj_b.values + mha.values AS values
                        FROM    (
                                SELECT  ffn_a.place, ARRAY_AGG(INNER_PRODUCT(ffn_a.values, mlp_c_proj_w.values) ORDER BY mlp_c_proj_w.place)::VECTOR(768) AS values
                                FROM    ffn_a
                                CROSS JOIN
                                        mlp_c_proj_w
                                GROUP BY
                                        ffn_a.place
                                ) w
                        CROSS JOIN
                                mlp_c_proj_b
                        JOIN    mha
                        USING   (place)
                        )
                SELECT  *
                FROM    ffn
                ) transformed_layer
        )
        ),
        block_output AS
        (
        SELECT  *
        FROM    hparams
        JOIN    transform
        ON      transform.block = n_block
        ),
        ln_f AS
        (
        SELECT  place, norm.values * ln_f_g.values + ln_f_b.values AS values
        FROM    block_output
        CROSS JOIN LATERAL
                (
                SELECT  AVG(value) AS mean,
                        VAR_POP(value) AS variance
                FROM    UNNEST(values::REAL[]) AS n(value)
                ) agg
        CROSS JOIN LATERAL
                (
                SELECT  ARRAY_AGG((value - mean) / SQRT(variance + 1E-5) ORDER BY ordinality)::VECTOR(768) AS values
                FROM    UNNEST(values::REAL[]) WITH ORDINALITY AS n (value, ordinality)
                ) norm
        CROSS JOIN
                ln_f_b
        CROSS JOIN
                ln_f_g
        ),
        logits AS
        (
        SELECT  logits.*
        FROM    hparams
        CROSS JOIN LATERAL
                (
                SELECT  token, INNER_PRODUCT(ln_f.values, wte.values) AS value
                FROM    ln_f
                CROSS JOIN
                        wte
                WHERE   ln_f.place = n_seq - 1
                ORDER BY
                        value DESC
                LIMIT   (top_n)
                ) logits
        ),
        temperatures (temperature) AS
        (
        VALUES
        (0.5),
        (1),
        (2)
        ),
        tokens AS
        (
        SELECT  token, value, softmax, temperature
        FROM    temperatures
        CROSS JOIN LATERAL
                (
                SELECT  *, (e / SUM(e) OVER ()) AS softmax
                FROM    (
                        SELECT  *,
                                (value - MAX(value) OVER ()) / temperature AS diff
                        FROM    logits
                        ) exp_x
                CROSS JOIN LATERAL
                        (
                        SELECT  CASE WHEN diff &lt; -745.13 THEN 0 ELSE EXP(diff) END AS e
                        ) exp
                ) q
        )
SELECT  token,
        cluster,
        TO_CHAR(t1.value, &#39;S00.000&#39;) AS score,
        TO_CHAR(t1.softmax, &#39;0.00&#39;) AS &#34;temperature = 0.5&#34;,
        TO_CHAR(t2.softmax, &#39;0.00&#39;) AS &#34;temperature = 1&#34;,
        TO_CHAR(t3.softmax, &#39;0.00&#39;) AS &#34;temperature = 2&#34;
FROM    (
        SELECT  *
        FROM    tokens
        WHERE   temperature = 0.5
        ) t1
JOIN    (
        SELECT  *
        FROM    tokens
        WHERE   temperature = 1
        ) t2
USING   (token)
JOIN    (
        SELECT  *
        FROM    tokens
        WHERE   temperature = 2
        ) t3
USING   (token)
JOIN    tokenizer
USING   (token)
</pre>
<div>
<table>
<tbody><tr>
<th>token</th>
<th>cluster</th>
<th>score</th>
<th>temperature = 0.5</th>
<th>temperature = 1</th>
<th>temperature = 2</th>
</tr>
<tr>
<td>329</td>
<td>Ġfor</td>
<td>-85.435</td>
<td> 0.74</td>
<td> 0.48</td>
<td> 0.33</td>
</tr>
<tr>
<td>11</td>
<td>,</td>
<td>-86.232</td>
<td> 0.15</td>
<td> 0.22</td>
<td> 0.22</td>
</tr>
<tr>
<td>13</td>
<td>.</td>
<td>-86.734</td>
<td> 0.05</td>
<td> 0.13</td>
<td> 0.17</td>
</tr>
<tr>
<td>379</td>
<td>Ġat</td>
<td>-86.785</td>
<td> 0.05</td>
<td> 0.12</td>
<td> 0.17</td>
</tr>
<tr>
<td>284</td>
<td>Ġto</td>
<td>-87.628</td>
<td> 0.01</td>
<td> 0.05</td>
<td> 0.11</td>
</tr>
</tbody></table>
</div>
<h3>Inference</h3>
<p>Finally, we are ready to do some real inference: run the model, select a token according to its probability, add it to the prompt and repeat until enough tokens are generated.</p>
<p>The LLM itself, as we saw before, is deterministic: it&#39;s just a series of matrix multiplications and other math operations on predefined constants. As long as the prompt and the hyperparameters like temperature and top_n are the same, the output will also be the same.</p>
<p>The only non-deterministic process is token selection. There is randomness involved in it (to a variable degree). That&#39;s why GPT-based chatbots can give different answers to the same prompt.</p>
<p>We will use the phrase &#34;Happy New Year! I wish&#34; as the prompt and make the model generate 10 new tokens for this prompt. The temperature will be set to 2, and top_n will be set to 5.</p>
<p>The query runs for 2:44 minutes on my machine. Here&#39;s its output:</p>
<pre title="">SELECT SETSEED(0.20231231);

WITH    RECURSIVE
        input AS
        (
        SELECT  &#39;Happy New Year! I wish you&#39; AS prompt,
                10 AS threshold,
                2 AS temperature,
                1 AS top_n
        ),
        clusters AS
        (
        SELECT  part_position, bpe.*
        FROM    input
        CROSS JOIN LATERAL
                REGEXP_MATCHES(prompt, &#39;&#39;&#39;s|&#39;&#39;t|&#39;&#39;re|&#39;&#39;ve|&#39;&#39;m|&#39;&#39;ll|&#39;&#39;d| ?\w+| ?\d+| ?[^\s\w\d]+|\s+(?!\S)|\s+&#39;, &#39;g&#39;) WITH ORDINALITY AS rm (part, part_position)
        CROSS JOIN LATERAL
                (
                WITH    RECURSIVE
                        bpe AS
                        (
                        SELECT  (n + 1)::BIGINT AS position, character, TRUE AS continue
                        FROM    CONVERT_TO(part[1], &#39;UTF-8&#39;) AS bytes
                        CROSS JOIN LATERAL
                                GENERATE_SERIES(0, LENGTH(bytes) - 1) AS n
                        JOIN    encoder
                        ON      byte = GET_BYTE(bytes, n)
                        UNION ALL
                        (
                        WITH    RECURSIVE
                                base AS
                                (
                                SELECT  *
                                FROM    bpe
                                WHERE   continue
                                ),
                                bn AS
                                (
                                SELECT  ROW_NUMBER() OVER (ORDER BY position) AS position,
                                        continue,
                                        character,
                                        character || LEAD(character) OVER (ORDER BY position) AS cluster
                                FROM    base
                                ),
                                top_rank AS
                                (
                                SELECT  tokenizer.*
                                FROM    bn
                                CROSS JOIN LATERAL
                                        (
                                        SELECT  *
                                        FROM    tokenizer
                                        WHERE   tokenizer.cluster = bn.cluster
                                        LIMIT   1
                                        ) tokenizer
                                ORDER BY
                                        token
                                LIMIT   1
                                ),
                                breaks AS
                                (
                                SELECT  0::BIGINT AS position, 1 AS length
                                UNION ALL
                                SELECT  bn.position,
                                        CASE WHEN token IS NULL THEN 1 ELSE 2 END
                                FROM    breaks
                                JOIN    bn
                                ON      bn.position = breaks.position + length
                                LEFT JOIN
                                        top_rank
                                USING   (cluster)
                                )
                        SELECT  position, character, token IS NOT NULL
                        FROM    breaks
                        LEFT JOIN
                                top_rank
                        ON      1 = 1
                        CROSS JOIN LATERAL
                                (
                                SELECT  STRING_AGG(character, &#39;&#39; ORDER BY position) AS character
                                FROM    bn
                                WHERE   bn.position &gt;= breaks.position
                                        AND bn.position &lt; breaks.position + length
                                ) bn
                        WHERE   position &gt; 0
                        )
                        )
                SELECT  position, character AS cluster
                FROM    bpe
                WHERE   NOT continue
                ) bpe
        ),
        tokens AS
        (
        SELECT  ARRAY_AGG(token ORDER BY part_position, position) AS input
        FROM    clusters
        JOIN    tokenizer
        USING   (cluster)
        ),
        gpt AS
        (
        SELECT  input, ARRAY_LENGTH(input, 1) AS original_length
        FROM    tokens
        UNION ALL
        SELECT  input || next_token.token, original_length
        FROM    gpt
        CROSS JOIN
                input
        CROSS JOIN LATERAL
                (
                WITH    RECURSIVE
                        hparams AS
                        (
                        SELECT  ARRAY_LENGTH(input, 1) AS n_seq,
                                12 AS n_block
                        ),
                        embeddings AS
                        (
                        SELECT  place, values
                        FROM    hparams
                        CROSS JOIN LATERAL
                                UNNEST(input) WITH ORDINALITY AS tokens (token, ordinality)
                        CROSS JOIN LATERAL
                                (
                                SELECT  ordinality - 1 AS place
                                ) o
                        CROSS JOIN LATERAL
                                (
                                SELECT  wte.values + wpe.values AS values
                                FROM    wte
                                CROSS JOIN
                                        wpe
                                WHERE   wte.token = tokens.token
                                        AND wpe.place = o.place
                                ) embedding
                        ),
                        transform AS
                        (
                        SELECT  0 AS block, place, values
                        FROM    embeddings
                        UNION ALL
                        (
                        WITH    previous AS
                                (
                                SELECT  *
                                FROM    transform
                                )
                        SELECT  block + 1 AS block, transformed_layer.*
                        FROM    hparams
                        CROSS JOIN LATERAL
                                (
                                SELECT  block
                                FROM    previous
                                WHERE   block &lt; 12
                                LIMIT   1
                                ) q
                        CROSS JOIN LATERAL
                                (
                                WITH    ln_2_b AS
                                        (
                                        SELECT  *
                                        FROM    ln_2_b
                                        WHERE   block = q.block
                                        ),
                                        ln_2_g AS
                                        (
                                        SELECT  *
                                        FROM    ln_2_g
                                        WHERE   block = q.block
                                        ),
                                        c_proj_w AS
                                        (
                                        SELECT  *
                                        FROM    c_proj_w
                                        WHERE   block = q.block
                                        ),
                                        c_proj_b AS
                                        (
                                        SELECT  *
                                        FROM    c_proj_b
                                        WHERE   block = q.block
                                        ),
                                        mlp_c_fc_w AS
                                        (
                                        SELECT  *
                                        FROM    mlp_c_fc_w
                                        WHERE   block = q.block
                                        ),
                                        mlp_c_fc_b AS
                                        (
                                        SELECT  *
                                        FROM    mlp_c_fc_b
                                        WHERE   block = q.block
                                        ),
                                        mlp_c_proj_w AS
                                        (
                                        SELECT  *
                                        FROM    mlp_c_proj_w
                                        WHERE   block = q.block
                                        ),
                                        mlp_c_proj_b AS
                                        (
                                        SELECT  *
                                        FROM    mlp_c_proj_b
                                        WHERE   block = q.block
                                        ),
                                        c_attn_w AS
                                        (
                                        SELECT  *
                                        FROM    c_attn_w
                                        WHERE   block = q.block
                                        ),
                                        c_attn_b AS
                                        (
                                        SELECT  *
                                        FROM    c_attn_b
                                        WHERE   block = q.block
                                        ),
                                        ln_1_g AS
                                        (
                                        SELECT  *
                                        FROM    ln_1_g
                                        WHERE   block = q.block
                                        ),
                                        ln_1_b AS
                                        (
                                        SELECT  *
                                        FROM    ln_1_b
                                        WHERE   block = q.block
                                        ),
                                        mha_norm AS
                                        (
                                        SELECT  place, mm.values + c_attn_b.values AS values
                                        FROM    (
                                                SELECT  place, ARRAY_AGG(INNER_PRODUCT(c_attn_w.values, layer_norm.values) ORDER BY y)::VECTOR(2304) AS values
                                                FROM    (
                                                        SELECT  place, agg.values * ln_1_g.values + ln_1_b.values AS values
                                                        FROM    (
                                                                SELECT  place, norm.values
                                                                FROM    previous
                                                                CROSS JOIN LATERAL
                                                                        (
                                                                        SELECT  AVG(value) AS mean,
                                                                                VAR_POP(value) AS variance
                                                                        FROM    UNNEST(values::REAL[]) value
                                                                        ) agg
                                                                CROSS JOIN LATERAL
                                                                        (
                                                                        SELECT  ARRAY_AGG((value - mean) / SQRT(variance + 1E-5) ORDER BY ordinality)::VECTOR(768) AS values
                                                                        FROM    UNNEST(values::REAL[]) WITH ORDINALITY AS n(value, ordinality)
                                                                        ) norm
                                                                ) agg
                                                        CROSS JOIN
                                                                ln_1_b
                                                        CROSS JOIN
                                                                ln_1_g
                                                        ) layer_norm
                                                CROSS JOIN
                                                        c_attn_w
                                                GROUP BY
                                                        place
                                                ) mm
                                        CROSS JOIN
                                                c_attn_b
                                        ),
                                        heads AS
                                        (
                                        SELECT  place, head,
                                                (values::REAL[])[(head * 64 + 1):(head * 64 + 64)]::VECTOR(64) AS q,
                                                (values::REAL[])[(head * 64 + 1 + 768):(head * 64 + 64 + 768)]::VECTOR(64) AS k,
                                                (values::REAL[])[(head * 64 + 1 + 1536):(head * 64 + 64 + 1536)]::VECTOR(64) AS v
                                        FROM    mha_norm
                                        CROSS JOIN
                                                GENERATE_SERIES(0, 11) head
                                        ),
                                        sm_input AS
                                        (
                                        SELECT  head, h1.place AS x, h2.place AS y, INNER_PRODUCT(h1.q, h2.k) / 8 + CASE WHEN h2.place &gt; h1.place THEN -1E10 ELSE 0 END AS value
                                        FROM    heads h1
                                        JOIN    heads h2
                                        USING   (head)
                                        ),
                                        sm_diff AS
                                        (
                                        SELECT  head, x, y, value - MAX(value) OVER (PARTITION BY head, x) AS diff
                                        FROM    sm_input
                                        ),
                                        sm_exp AS
                                        (
                                        SELECT  head, x, y, CASE WHEN diff &lt; -745.13 THEN 0 ELSE EXP(diff) END AS e
                                        FROM    sm_diff
                                        ),
                                        softmax AS
                                        (
                                        SELECT  head, x, y AS place, e / SUM(e) OVER (PARTITION BY head, x) AS value
                                        FROM    sm_exp
                                        ),
                                        attention AS
                                        (
                                        SELECT  place, ARRAY_AGG(value ORDER BY head * 64 + ordinality)::VECTOR(768) AS values
                                        FROM    (
                                                SELECT  head, x AS place, SUM(ARRAY_FILL(softmax.value, ARRAY[64])::VECTOR(64) * heads.v) AS values
                                                FROM    softmax
                                                JOIN    heads
                                                USING   (head, place)
                                                GROUP BY
                                                        head, x
                                                ) q
                                        CROSS JOIN LATERAL
                                                UNNEST(values::REAL[]) WITH ORDINALITY v (value, ordinality)
                                        GROUP BY
                                                place
                                        ),
                                        mha AS
                                        (
                                        SELECT  place, w.values + c_proj_b.values + previous.values AS values
                                        FROM    (
                                                SELECT  attention.place, ARRAY_AGG(INNER_PRODUCT(attention.values, c_proj_w.values) ORDER BY c_proj_w.place)::VECTOR(768) AS values
                                                FROM    attention
                                                CROSS JOIN
                                                        c_proj_w
                                                GROUP BY
                                                        attention.place
                                                ) w
                                        CROSS JOIN
                                                c_proj_b
                                        JOIN    previous
                                        USING   (place)
                                        ),
                                        ffn_norm AS
                                        (
                                        SELECT  place, agg.values * ln_2_g.values + ln_2_b.values AS values
                                        FROM    (
                                                SELECT  place, norm.values
                                                FROM    mha
                                                CROSS JOIN LATERAL
                                                        (
                                                        SELECT  AVG(value) AS mean,
                                                                VAR_POP(value) AS variance
                                                        FROM    UNNEST(values::REAL[]) value
                                                        ) agg
                                                CROSS JOIN LATERAL
                                                        (
                                                        SELECT  ARRAY_AGG((value - mean) / SQRT(variance + 1E-5) ORDER BY ordinality)::VECTOR(768) AS values
                                                        FROM    UNNEST(values::REAL[]) WITH ORDINALITY AS n(value, ordinality)
                                                        ) norm
                                                ) agg
                                        CROSS JOIN
                                                ln_2_b
                                        CROSS JOIN
                                                ln_2_g
                                        ),
                                        ffn_a AS
                                        (
                                        SELECT  gelu.place, gelu.values
                                        FROM    (
                                                SELECT  place, w.values + mlp_c_fc_b.values AS values
                                                FROM    (
                                                        SELECT  ffn_norm.place, ARRAY_AGG(INNER_PRODUCT(ffn_norm.values, mlp_c_fc_w.values) ORDER BY mlp_c_fc_w.place)::VECTOR(3072) AS values
                                                        FROM    ffn_norm
                                                        CROSS JOIN
                                                                mlp_c_fc_w
                                                        GROUP BY
                                                                ffn_norm.place
                                                        ) w
                                                CROSS JOIN
                                                        mlp_c_fc_b
                                                ) v
                                        CROSS JOIN LATERAL
                                                (
                                                SELECT  place, ARRAY_AGG(0.5 * value * (1 + TANH(0.797884560802 * (value + 0.044715 * value*value*value))) ORDER BY ordinality)::VECTOR(3072) AS values
                                                FROM    UNNEST(values::REAL[]) WITH ORDINALITY n (value, ordinality)
                                                GROUP BY
                                                        place
                                                ) gelu
                                        ),
                                        ffn AS
                                        (
                                        SELECT  place, w.values + mlp_c_proj_b.values + mha.values AS values
                                        FROM    (
                                                SELECT  ffn_a.place, ARRAY_AGG(INNER_PRODUCT(ffn_a.values, mlp_c_proj_w.values) ORDER BY mlp_c_proj_w.place)::VECTOR(768) AS values
                                                FROM    ffn_a
                                                CROSS JOIN
                                                        mlp_c_proj_w
                                                GROUP BY
                                                        ffn_a.place
                                                ) w
                                        CROSS JOIN
                                                mlp_c_proj_b
                                        JOIN    mha
                                        USING   (place)
                                        )
                                SELECT  *
                                FROM    ffn
                                ) transformed_layer
                        )
                        ),
                        block_output AS
                        (
                        SELECT  *
                        FROM    hparams
                        JOIN    transform
                        ON      transform.block = n_block
                        ),
                        ln_f AS
                        (
                        SELECT  place, norm.values * ln_f_g.values + ln_f_b.values AS values
                        FROM    block_output
                        CROSS JOIN LATERAL
                                (
                                SELECT  AVG(value) AS mean,
                                        VAR_POP(value) AS variance
                                FROM    UNNEST(values::REAL[]) AS n(value)
                                ) agg
                        CROSS JOIN LATERAL
                                (
                                SELECT  ARRAY_AGG((value - mean) / SQRT(variance + 1E-5) ORDER BY ordinality)::VECTOR(768) AS values
                                FROM    UNNEST(values::REAL[]) WITH ORDINALITY AS n (value, ordinality)
                                ) norm
                        CROSS JOIN
                                ln_f_b
                        CROSS JOIN
                                ln_f_g
                        ),
                        logits AS
                        (
                        SELECT  token, INNER_PRODUCT(ln_f.values, wte.values) AS value
                        FROM    hparams
                        JOIN    ln_f
                        ON      ln_f.place = n_seq - 1
                        CROSS JOIN
                                wte
                        ORDER BY
                                value DESC
                        LIMIT   (top_n)
                        ),
                        tokens AS
                        (
                        SELECT  token,
                                high - softmax AS low,
                                high
                        FROM    (
                                SELECT  *,
                                        SUM(softmax) OVER (ORDER BY softmax) AS high
                                FROM    (
                                        SELECT  *, (e / SUM(e) OVER ()) AS softmax
                                        FROM    (
                                                SELECT  *,
                                                        (value - MAX(value) OVER ()) / temperature AS diff
                                                FROM    logits
                                                ) exp_x
                                        CROSS JOIN LATERAL
                                                (
                                                SELECT  CASE WHEN diff &lt; -745.13 THEN 0 ELSE EXP(diff) END AS e
                                                ) exp
                                        ) q
                                ) q
                        ),
                        next_token AS
                        (
                        SELECT  *
                        FROM    (
                                SELECT  RANDOM() AS rnd
                                ) r
                        CROSS JOIN LATERAL
                                (
                                SELECT  *
                                FROM    tokens
                                WHERE   rnd &gt;= low
                                        AND rnd &lt; high
                                ) nt
                        )
                SELECT  *
                FROM    next_token
                ) next_token
        WHERE   ARRAY_LENGTH(input, 1) &lt; original_length + threshold
                AND next_token.token &lt;&gt; 50256
        ),
        output AS
        (
        SELECT  CONVERT_FROM(STRING_AGG(SET_BYTE(&#39;\x00&#39;, 0, byte), &#39;&#39; ORDER BY position), &#39;UTF8&#39;) AS response
        FROM    (
                SELECT  STRING_AGG(cluster, &#39;&#39; ORDER BY ordinality) AS response
                FROM    input
                JOIN    gpt
                ON      ARRAY_LENGTH(input, 1) = original_length + threshold
                CROSS JOIN LATERAL
                        UNNEST(input) WITH ORDINALITY n (token, ordinality)
                JOIN    tokenizer
                USING   (token)
                ) q
        CROSS JOIN LATERAL
                STRING_TO_TABLE(response, NULL) WITH ORDINALITY n (character, position)
        JOIN    encoder
        USING   (character)
        )
SELECT  *
FROM    output
</pre>
<div>
<table>
<tbody><tr>
<th>response</th>
</tr>
<tr>
<td>Happy New Year! I wish you all the best in your new year!
</td>
</tr>
</tbody></table>
</div>
<p>This part the AI got right. I do wish you all the best in your new year!</p>
<p>You can find the queries and the installation code in the GitHub repository: <a href="https://github.com/quassnoi/explain-extended-2024" rel="noopener" target="_blank">quassnoi/explain-extended-2024</a></p>
<p>
<big><strong>Happy New Year!</strong></big>
</p>
<p>Previous New Year posts:</p>
<ul>
<li><a href="https://www.scattered-thoughts.net/2009/12/31/happy-new-year/">2010: SQL graphics in Oracle, MySQL, SQL Server and PostgreSQL</a></li>
<li><a href="https://www.scattered-thoughts.net/2010/12/31/happy-new-year-2/">2011: Drawing a clock in SQL</a></li>
<li><a href="https://www.scattered-thoughts.net/2011/12/31/happy-new-year-3/">2012: Drawing snowflakes in SQL</a></li>
<li><a href="https://www.scattered-thoughts.net/2012/12/31/happy-new-year-4/">2013: View of Earth from space in SQL</a></li>
<li><a href="https://www.scattered-thoughts.net/2013/12/31/happy-new-year-5/">2014: Drawing fractals in SQL</a></li>
<li><a href="https://www.scattered-thoughts.net/2014/12/31/happy-new-year-6/">2015: Composing music in SQL</a></li>
<li><a href="https://www.scattered-thoughts.net/2015/12/31/happy-new-year-7/">2016: Conway’s Game of Life in SQL</a></li>
<li><a href="https://www.scattered-thoughts.net/2016/12/31/happy-new-year-8/">2017: The Sultan’s Riddle in SQL</a></li>
<li><a href="https://www.scattered-thoughts.net/2017/12/31/happy-new-year-9/">2018: Settlers of Catan in SQL</a></li>
<li><a href="https://www.scattered-thoughts.net/2018/12/31/happy-new-year-10/">2019: GIF decoder in SQL</a></li>
<li><a href="https://www.scattered-thoughts.net/2019/12/31/happy-new-year-11/">2020: A stereogram in SQL</a></li>
<li><a href="https://www.scattered-thoughts.net/2020/12/31/happy-new-year-12/">2021: 3D picture of the coronavirus in SQL</a></li>
<li><a href="https://www.scattered-thoughts.net/2021/12/31/happy-new-year-13/">2022: Quantum computer emulator in SQL</a></li>
<li><a href="https://www.scattered-thoughts.net/2022/12/31/happy-new-year-14/">2023: Solving the Rubik’s Cube in SQL</a></li>
</ul>
</div></div>
  </body>
</html>
