<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://doordash.engineering/2023/01/31/how-we-reduced-our-ios-app-launch-time-by-60/">Original</a>
    <h1>We reduced our iOS app launch time by 60%</h1>
    
    <div id="readability-page-1" class="page"><div>
					<!-- wp:paragraph -->
<p>App startup time is a critical metric for users, as it’s their first interaction with the app, and even minor improvements can have significant benefits for the user experience. First impressions are a big driver in consumer conversion, and startup times often indicate the app’s overall quality. Furthermore, other companies found that <a href="https://www.gigaspaces.com/blog/amazon-found-every-100ms-of-latency-cost-them-1-in-sales" target="_blank" rel="noreferrer noopener">an increase in latency equals a decrease in sales</a>.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>At DoorDash, we take app startup speed extremely seriously. We are obsessed with optimizing our customers&#39; experience and making continuous improvements.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>In this article, we will explore three separate optimizations that reduced the time it took to launch our iOS consumer app by 60%. We identified these opportunities using proprietary performance tools, but Xcode instruments or DTrace could also be suitable alternatives.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Changing String(describing:) to ObjectIdentifier()</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>In early 2022, our app startup optimization journey began with visualizing top bottlenecks using <a href="https://www.emergetools.com/" target="_blank" rel="noreferrer noopener">Emerge Tools’</a> Performance Analysis tool, as seen in Figure 1.</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":9066,"sizeSlug":"large","linkDestination":"none"} -->
<figure><img src="https://doordash.engineering/wp-content/uploads/2023/01/Screenshot-2023-01-27-at-1.57.34-PM-1024x358.png" alt="Figure 1: Stack trace showing the three performance optimization opportunities"/><figcaption>Figure 1: Stack trace showing the three performance optimization opportunities</figcaption></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>This performance tool helped showcase unoptimized branches from both a birdseye and a detailed point-of-view. One of the biggest immediate standouts was the time we spent on <a href="https://github.com/apple/swift/blob/244ca4e2426260e7b9161c2fd6534dc350983cdf/stdlib/public/runtime/ProtocolConformance.cpp#L970" target="_blank" rel="noreferrer noopener">Swift protocol conformance checks</a> (checking if a type conforms to a protocol), but why?</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Architectural principles like the single responsibility principle, separation of concerns, and others, are key to how we write code at DoorDash. Services and dependencies are often injected and described by their type. The problem is that we used <a href="https://developer.apple.com/documentation/swift/string/init(describing:)-67ncf" target="_blank" rel="noreferrer noopener">String(describing:)</a> to identify services, which came with a runtime performance penalty of checking if the type conforms to various other protocols. The stack trace in Figure 2 is taken directly from our app launch to showcase this.</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":9068,"sizeSlug":"large","linkDestination":"none"} -->
<figure><img src="https://doordash.engineering/wp-content/uploads/2023/01/Screenshot-2023-01-27-at-1.58.21-PM-1024x308.png" alt="Figure 2: Stack trace of what happens behind the scenes of the String(describing:) API"/><figcaption>Figure 2: Stack trace of what happens behind the scenes of the String(describing:) API</figcaption></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>The first question we asked ourselves was: “Do we really need a string to identify a type?”Eliminating the string requirement and switching to identifying types using ObjectIdentifier instead, which is a mere <a href="https://github.com/apple/swift/blob/main/stdlib/public/core/ObjectIdentifier.swift#L63" target="_blank" rel="noreferrer noopener">pointer to the type</a>, yielded <strong>11%</strong> faster app startup times. We also applied this technique to other areas where a pointer sufficed instead of a raw string, which yielded an additional <strong>11% </strong>improvement.</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":9069,"sizeSlug":"full","linkDestination":"none"} -->
<figure><img src="https://doordash.engineering/wp-content/uploads/2023/01/Screenshot-2023-01-27-at-1.58.57-PM.png" alt=""/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>If it’s possible to use a raw pointer to the type instead of using <a href="https://developer.apple.com/documentation/swift/string/init(describing:)-67ncf" target="_blank" rel="noreferrer noopener">String(describing:)</a> We recommend making the same change to save on the latency penalty.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Stop converting unnecessary objects to AnyHashable</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>At DoorDash, we encapsulate user actions, network requests, data mutations, and other computational workloads into (what we call) commands. For example, when we load a store menu, we submit that as a request to the command execution engine. The engine will then store the command in a processing array and perform the inbound commands sequentially. Structuring our operations this way is a key part of our new architecture, where we purposely isolate direct mutations and observe the results of expected actions instead.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>This optimization began with rethinking how we identify commands and generate their <a href="https://computersciencewiki.org/index.php/Hashing" target="_blank" rel="noreferrer noopener">hash value</a>. Our processing array, and other dependencies, rely on a unique hash value to identify and separate the respective commands. Historically, we circumvented the need of having to think about hashing by using <a href="https://developer.apple.com/documentation/swift/anyhashable" target="_blank" rel="noreferrer noopener">AnyHashable</a>. However, <a href="https://github.com/apple/swift/blob/main/stdlib/public/core/AnyHashable.swift#L133" target="_blank" rel="noreferrer noopener">as noted in the Swift standard</a>, doing so was dangerous because relying on hash values given by AnyHashable could change between releases.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We could have chosen to optimize our hashing strategy in several ways, but we started by rethinking our original restrictions and bounds. Originally, the hash value of a command was a combination of its associated members. This decision had been made deliberately since we wanted to maintain a flexible and powerful abstraction of commands. But after an app-wide adoption of the new architecture, we noticed that the design choice was premature and overall left unused. Changing this requirement to identify commands by their type led to a <strong>29%</strong> faster app launch, <strong>55%</strong> faster command execution, and <strong>20%</strong> faster registration of commands.</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":9071,"sizeSlug":"full","linkDestination":"none"} -->
<figure><img src="https://doordash.engineering/wp-content/uploads/2023/01/Screenshot-2023-01-27-at-2.00.02-PM.png" alt=""/></figure>
<!-- /wp:image -->

<!-- wp:shortcode -->

						<div id="subscribeform1">
							<h4>Subscribe for weekly updates</h4>
							
						</div>

<!-- /wp:shortcode -->

<!-- wp:heading -->
<h2>Auditing 3rd party framework initializers</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>At DoorDash, we strive to be free of third-party dependencies wherever possible. Still, there are times when a consumer&#39;s experience could greatly benefit from a third-party integration. Regardless, we conduct several rigorous audits of how third-party dependencies impact our service and the quality we uphold.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>A recent audit found that a certain third-party framework caused our iOS application to launch roughly 200ms slower. This framework alone occupied roughly 40%(!) of our app launch time, as seen in Figure 3.</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":9073,"sizeSlug":"large","linkDestination":"none"} -->
<figure><img src="https://doordash.engineering/wp-content/uploads/2023/01/Screenshot-2023-01-27-at-2.00.41-PM-1024x417.png" alt="Figure 3: A flame chart showing roughly 200ms of our app startup time was due to a third-party framework iterating over our NSBundle."/><figcaption>Figure 3: A flame chart showing roughly 200ms of our app startup time was due to a third-party framework iterating over our <a href="https://developer.apple.com/documentation/foundation/nsbundle" target="_blank" rel="noreferrer noopener">NSBundle</a>.<br/></figcaption></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>To make matters trickier, the framework in question was a key part of ensuring a positive consumer experience. So what can we do? How do we balance one aspect of the customer experience with fast app launch times?</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Typically, a good approach is to start by moving any computationally expensive startup functions to a later part of the launch process and reevaluate from there. In our case, we only called or referenced classes in the framework much later in the process, but the framework was still blocking our launch time; why?</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>When an application starts up and loads into memory, the dynamic linker (dyld) is responsible for getting it ready. One of the steps of dyld is scanning through dynamically linked frameworks and calling any module initialization functions that it may have. dyld does this by looking for section types marked with 0x9 (<a href="https://opensource.apple.com/source/xnu/xnu-792/EXTERNAL_HEADERS/mach-o/loader.h" target="_blank" rel="noreferrer noopener">S_MOD_INIT_FUNC_POINTERS</a>), typically located in the “__DATA” segment.</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":9075,"sizeSlug":"full","linkDestination":"none"} -->
<figure><img src="https://doordash.engineering/wp-content/uploads/2023/01/Screenshot-2023-01-27-at-2.01.27-PM.png" alt=""/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Once found, dyld sets a Boolean variable to true and calls the initializers in another phase shortly thereafter.</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":9076,"sizeSlug":"large","linkDestination":"none"} -->
<figure><img src="https://doordash.engineering/wp-content/uploads/2023/01/Screenshot-2023-01-27-at-2.02.05-PM-1024x332.png" alt=""/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>The third-party framework in question had a total of nine module initializers that all, because of dyld, were granted to run before our application ran main(). Those nine initializers attributed to the total cost that delayed our app launch. So how do we fix it?</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>There are several ways we could have gone about fixing the delay. A popular option is to use <a href="https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man3/dlopen.3.html" target="_blank" rel="noreferrer noopener">dlopen</a> and write a wrapper interface for functions that have yet to be resolved. This method meant losing compiler safety, though, since the compiler could no longer reassure that a certain function would exist in the framework at compile time. This option has <a href="https://www.mailerq.com/blog/good-reasons-to-use-dlopen#:~:text=The%20downside%20of%20dlopen(),manage%20pointer%2Dto%2Dfunctions." target="_blank" rel="noreferrer noopener">other cons</a>, but compile safety meant the most to us.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We also contacted the third-party developers and asked them to convert the module initializer to a simple function we could instead call at our leisure. They, unfortunately, have yet to reply to us.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Instead, we went for a slightly different approach than publicly known methods. The idea was to trick dyld into thinking it is looking at a regular section and therefore skip calling the module initializers. Then, later at runtime, we would grab the base address of the framework with <a href="https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man3/dladdr.3.html" target="_blank" rel="noreferrer noopener">dladdr</a>, and call the initializers at a known static offset. We would enforce this offset by validating the hash of the framework at compile time, verifying sections at runtime, and checking that the section flag had indeed been replaced. With these safety guards and an overall plan in mind, we successfully rolled out this optimization and yielded an additional <strong>36%</strong> faster app startup.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Conclusion</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Accurately identifying performance bottlenecks and opportunities is often the most challenging part of any optimization. Notoriously, a common mistake is to measure A, optimize B, and conclude C. That is where good performance tools help highlight bottlenecks and surface them. Xcode instruments, a part of Xcode, come with several templates to help pinpoint various potential issues in a macOS/iOS application. But for additional granularity and ease of use, Emerge Tools provides a simplified view of app performance with their performance tools.</p>
<!-- /wp:paragraph -->				</div></div>
  </body>
</html>
