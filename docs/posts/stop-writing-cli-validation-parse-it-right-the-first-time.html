<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://hackers.pub/@hongminhee/2025/stop-writing-cli-validation-parse-it-right-the-first-time">Original</a>
    <h1>Stop writing CLI validation. Parse it right the first time</h1>
    
    <div id="readability-page-1" class="page"><div lang="en"><p>I have this bad habit. When something annoys me enough times,
I end up building a library for it. This time, it was CLI validation code.</p>
<p>See, I spend a lot of time reading other people&#39;s code. Open source projects,
work stuff, random GitHub repos I stumble upon at 2 AM. And I kept noticing this
thing: every CLI tool has the same ugly validation code tucked away somewhere.
You know the kind:</p>
<pre><code><span><span>if</span><span> (</span><span>!</span><span>opts</span><span>.</span><span>server</span><span> &amp;&amp;</span><span> opts</span><span>.</span><span>port</span><span>)</span><span> {</span></span>
<span><span>  throw</span><span> new</span><span> Error</span><span>(</span><span>&#34;</span><span>--port requires --server flag</span><span>&#34;</span><span>);</span></span>
<span><span>}</span></span>
<span></span>
<span><span>if</span><span> (</span><span>opts</span><span>.</span><span>server</span><span> &amp;&amp;</span><span> !</span><span>opts</span><span>.</span><span>port</span><span>)</span><span> {</span></span>
<span><span>  opts</span><span>.</span><span>port</span><span> =</span><span> 3000</span><span>;</span><span> // default port</span></span>
<span><span>}</span></span>
<span></span>
<span><span>// wait, what if they pass --port without a value?</span></span>
<span><span>// what if the port is out of range?</span></span>
<span><span>// what if...</span></span></code></pre>
<p>It&#39;s not even that this code is hard to write. It&#39;s that it&#39;s <em>everywhere</em>.
Every project. Every CLI tool. The same patterns, slightly different flavors.
Options that depend on other options. Flags that can&#39;t be used together.
Arguments that only make sense in certain modes.</p>
<p>And here&#39;s what really got me: we solved this problem years ago for other types
of data. Just… not for CLIs.</p>
<h2 id="0199203f-a6e9-7f90-9462-0af136538c9c--the-problem-with-validation">The problem with validation <a href="#0199203f-a6e9-7f90-9462-0af136538c9c--the-problem-with-validation"><span aria-hidden="true"></span></a></h2>
<p>There&#39;s this blog post that completely changed how I think about parsing.
It&#39;s called <a href="https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/"><em>Parse, don&#39;t validate</em></a> by Alexis King. The gist? Don&#39;t parse data
into a loose type and then check if it&#39;s valid. Parse it directly into a type
that can only be valid.</p>
<p>Think about it. When you get JSON from an API, you don&#39;t just parse it as <code>any</code>
and then write a bunch of <code>if</code>-statements. You use something like <a href="https://zod.dev/">Zod</a> to parse
it directly into the shape you want. Invalid data? The parser rejects it. Done.</p>
<p>But with CLIs? We parse arguments into some bag of properties and then spend
the next 100 lines checking if that bag makes sense. It&#39;s backwards.</p>
<p>So yeah, I built <a href="https://optique.dev/">Optique</a>. Not because the world desperately needed another CLI
parser (it didn&#39;t), but because I was tired of seeing—and writing—the same
validation code everywhere.</p>
<h2 id="0199203f-a6e9-7f90-9462-0af136538c9c--three-patterns-i-was-sick-of-validating">Three patterns I was sick of validating <a href="#0199203f-a6e9-7f90-9462-0af136538c9c--three-patterns-i-was-sick-of-validating"><span aria-hidden="true"></span></a></h2>
<h3 id="0199203f-a6e9-7f90-9462-0af136538c9c--dependent-options">Dependent options <a href="#0199203f-a6e9-7f90-9462-0af136538c9c--dependent-options"><span aria-hidden="true"></span></a></h3>
<p>This one&#39;s everywhere. You have an option that only makes sense when another
option is enabled.</p>
<p>The old way? Parse everything, then check:</p>
<pre><code><span><span>const </span><span>opts</span><span> =</span><span> parseArgs</span><span>(</span><span>process</span><span>.</span><span>argv</span><span>);</span></span>
<span><span>if</span><span> (</span><span>!</span><span>opts</span><span>.</span><span>server</span><span> &amp;&amp;</span><span> opts</span><span>.</span><span>port</span><span>)</span><span> {</span></span>
<span><span>  throw</span><span> new</span><span> Error</span><span>(</span><span>&#34;</span><span>--port requires --server</span><span>&#34;</span><span>);</span></span>
<span><span>}</span></span>
<span><span>if</span><span> (</span><span>opts</span><span>.</span><span>server</span><span> &amp;&amp;</span><span> !</span><span>opts</span><span>.</span><span>port</span><span>)</span><span> {</span></span>
<span><span>  opts</span><span>.</span><span>port</span><span> =</span><span> 3000</span><span>;</span></span>
<span><span>}</span></span>
<span><span>// More validation probably lurking elsewhere...</span></span></code></pre>
<p>With Optique, you just describe what you want:</p>
<pre><code><span><span>const </span><span>config</span><span> =</span><span> withDefault</span><span>(</span></span>
<span><span>  object</span><span>({</span></span>
<span><span>    server</span><span>: </span><span>flag</span><span>(</span><span>&#34;</span><span>--server</span><span>&#34;</span><span>),</span></span>
<span><span>    port</span><span>: </span><span>option</span><span>(</span><span>&#34;</span><span>--port</span><span>&#34;</span><span>, </span><span>integer</span><span>()),</span></span>
<span><span>    workers</span><span>: </span><span>option</span><span>(</span><span>&#34;</span><span>--workers</span><span>&#34;</span><span>, </span><span>integer</span><span>())</span></span>
<span><span>  }),</span></span>
<span><span>  { </span><span>server</span><span>: </span><span>false</span><span> }</span></span>
<span><span>);</span></span></code></pre>
<p>Here&#39;s what TypeScript infers for <code>config</code>&#39;s type:</p>
<pre><code><span><span>type</span><span> Config</span><span> =</span><span> </span></span>
<span><span>  |</span><span> {</span><span> readonly</span><span> server</span><span>: </span><span>false</span><span> }</span></span>
<span><span>  |</span><span> {</span><span> readonly</span><span> server</span><span>: </span><span>true</span><span>;</span><span> readonly</span><span> port</span><span>: </span><span>number</span><span>;</span><span> readonly</span><span> workers</span><span>: </span><span>number</span><span> }</span></span></code></pre>
<p>The type system now understands that when <code>server</code> is false, <code>port</code> literally
doesn&#39;t exist. Not <code>undefined</code>, not <code>null</code>—it&#39;s not there. Try to access it and
TypeScript yells at you. No runtime validation needed.</p>
<h3 id="0199203f-a6e9-7f90-9462-0af136538c9c--mutually-exclusive-options">Mutually exclusive options <a href="#0199203f-a6e9-7f90-9462-0af136538c9c--mutually-exclusive-options"><span aria-hidden="true"></span></a></h3>
<p>Another classic. Pick one output format: JSON, YAML, or XML. But definitely not
two.</p>
<p>I used to write this mess:</p>
<pre><code><span><span>if</span><span> ((</span><span>opts</span><span>.</span><span>json</span><span> ?</span><span> 1</span><span> :</span><span> 0</span><span>)</span><span> +</span><span> (</span><span>opts</span><span>.</span><span>yaml</span><span> ?</span><span> 1</span><span> :</span><span> 0</span><span>)</span><span> +</span><span> (</span><span>opts</span><span>.</span><span>xml</span><span> ?</span><span> 1</span><span> :</span><span> 0</span><span>)</span><span> &gt;</span><span> 1</span><span>)</span><span> {</span></span>
<span><span>  throw</span><span> new</span><span> Error</span><span>(</span><span>&#39;</span><span>Choose only one output format</span><span>&#39;</span><span>);</span></span>
<span><span>}</span></span></code></pre>
<p>(Don&#39;t judge me, you&#39;ve written something similar.)</p>
<p>Now?</p>
<pre><code><span><span>const </span><span>format</span><span> =</span><span> or</span><span>(</span></span>
<span><span>  map</span><span>(</span><span>option</span><span>(</span><span>&#34;</span><span>--json</span><span>&#34;</span><span>),</span><span> ()</span><span> =&gt;</span><span> &#34;</span><span>json</span><span>&#34;</span><span> as</span><span> const</span><span>),</span></span>
<span><span>  map</span><span>(</span><span>option</span><span>(</span><span>&#34;</span><span>--yaml</span><span>&#34;</span><span>),</span><span> ()</span><span> =&gt;</span><span> &#34;</span><span>yaml</span><span>&#34;</span><span> as</span><span> const</span><span>),</span></span>
<span><span>  map</span><span>(</span><span>option</span><span>(</span><span>&#34;</span><span>--xml</span><span>&#34;</span><span>),</span><span> ()</span><span> =&gt;</span><span> &#34;</span><span>xml</span><span>&#34;</span><span> as</span><span> const</span><span>)</span></span>
<span><span>);</span></span></code></pre>
<p>The <code>or()</code> combinator means exactly one succeeds. The result is just
<code>&#34;json&#34; | &#34;yaml&#34; | &#34;xml&#34;</code>. A single string. Not three booleans to juggle.</p>
<h3 id="0199203f-a6e9-7f90-9462-0af136538c9c--environment-specific-requirements">Environment-specific requirements <a href="#0199203f-a6e9-7f90-9462-0af136538c9c--environment-specific-requirements"><span aria-hidden="true"></span></a></h3>
<p>Production needs auth. Development needs debug flags. Docker needs different
options than local. You know the drill.</p>
<p>Instead of a validation maze, you just describe each environment:</p>
<pre><code><span><span>const </span><span>envConfig</span><span> =</span><span> or</span><span>(</span></span>
<span><span>  object</span><span>({</span></span>
<span><span>    env</span><span>: </span><span>constant</span><span>(</span><span>&#34;</span><span>prod</span><span>&#34;</span><span>),</span></span>
<span><span>    auth</span><span>: </span><span>option</span><span>(</span><span>&#34;</span><span>--auth</span><span>&#34;</span><span>, </span><span>string</span><span>()),      </span><span>// Required in prod</span></span>
<span><span>    ssl</span><span>: </span><span>option</span><span>(</span><span>&#34;</span><span>--ssl</span><span>&#34;</span><span>),</span></span>
<span><span>    monitoring</span><span>: </span><span>option</span><span>(</span><span>&#34;</span><span>--monitoring</span><span>&#34;</span><span>, </span><span>url</span><span>())</span></span>
<span><span>  }),</span></span>
<span><span>  object</span><span>({</span></span>
<span><span>    env</span><span>: </span><span>constant</span><span>(</span><span>&#34;</span><span>dev</span><span>&#34;</span><span>),</span></span>
<span><span>    debug</span><span>: </span><span>optional</span><span>(</span><span>option</span><span>(</span><span>&#34;</span><span>--debug</span><span>&#34;</span><span>)),    </span><span>// Optional in dev</span></span>
<span><span>    verbose</span><span>: </span><span>option</span><span>(</span><span>&#34;</span><span>--verbose</span><span>&#34;</span><span>)</span></span>
<span><span>  })</span></span>
<span><span>);</span></span></code></pre>
<p>No auth in production? Parser fails immediately. Trying to access <code>--auth</code> in
dev mode? TypeScript won&#39;t let you—the field doesn&#39;t exist on that type.</p>
<h2 id="0199203f-a6e9-7f90-9462-0af136538c9c--but-parser-combinators-though">“But parser combinators though…” <a href="#0199203f-a6e9-7f90-9462-0af136538c9c--but-parser-combinators-though"><span aria-hidden="true"></span></a></h2>
<p>I know, I know. “Parser combinators” sounds like something you&#39;d need
a CS degree to understand.</p>
<p>Here&#39;s the thing: I don&#39;t have a CS degree. Actually, I don&#39;t have any degree.
But I&#39;ve been using parser combinators for years because they&#39;re actually… not
that hard? It&#39;s just that the name makes them sound way scarier than they are.</p>
<p>I&#39;d been using them for other stuff—parsing config files, DSLs, whatever.
But somehow it never clicked that you could use them for CLI parsing until
I saw Haskell&#39;s <a href="https://github.com/pcapriotti/optparse-applicative">optparse-applicative</a>. That was a real “wait, of course”
moment. Like, why are we doing this any other way?</p>
<p>Turns out it&#39;s stupidly simple. A parser is just a function. Combinators are
just functions that take parsers and return new parsers. That&#39;s it.</p>
<pre><code><span><span>// This is a parser</span></span>
<span><span>const </span><span>port</span><span> =</span><span> option</span><span>(</span><span>&#34;</span><span>--port</span><span>&#34;</span><span>,</span><span> integer</span><span>());</span></span>
<span></span>
<span><span>// This is also a parser (made from smaller parsers)</span></span>
<span><span>const </span><span>server</span><span> =</span><span> object</span><span>({</span></span>
<span><span>  port</span><span>: </span><span>port</span><span>,</span></span>
<span><span>  host</span><span>: </span><span>option</span><span>(</span><span>&#34;</span><span>--host</span><span>&#34;</span><span>, </span><span>string</span><span>())</span></span>
<span><span>});</span></span>
<span></span>
<span><span>// Still a parser (parsers all the way down)</span></span>
<span><span>const </span><span>config</span><span> =</span><span> or</span><span>(</span><span>server</span><span>,</span><span> client</span><span>);</span></span></code></pre>
<p>No monads. No category theory. Just functions. Boring, beautiful functions.</p>
<h2 id="0199203f-a6e9-7f90-9462-0af136538c9c--typescript-does-the-heavy-lifting">TypeScript does the heavy lifting <a href="#0199203f-a6e9-7f90-9462-0af136538c9c--typescript-does-the-heavy-lifting"><span aria-hidden="true"></span></a></h2>
<p>Here&#39;s the thing that still feels like cheating: I don&#39;t write types for my CLI
configs anymore. TypeScript just… figures it out.</p>
<pre><code><span><span>const </span><span>cli</span><span> =</span><span> or</span><span>(</span></span>
<span><span>  command</span><span>(</span><span>&#34;</span><span>deploy</span><span>&#34;</span><span>,</span><span> object</span><span>({</span></span>
<span><span>    action</span><span>: </span><span>constant</span><span>(</span><span>&#34;</span><span>deploy</span><span>&#34;</span><span>),</span></span>
<span><span>    environment</span><span>: </span><span>argument</span><span>(</span><span>string</span><span>()),</span></span>
<span><span>    replicas</span><span>: </span><span>option</span><span>(</span><span>&#34;</span><span>--replicas</span><span>&#34;</span><span>, </span><span>integer</span><span>())</span></span>
<span><span>  })),</span></span>
<span><span>  command</span><span>(</span><span>&#34;</span><span>rollback</span><span>&#34;</span><span>,</span><span> object</span><span>({</span></span>
<span><span>    action</span><span>: </span><span>constant</span><span>(</span><span>&#34;</span><span>rollback</span><span>&#34;</span><span>),</span></span>
<span><span>    version</span><span>: </span><span>argument</span><span>(</span><span>string</span><span>()),</span></span>
<span><span>    force</span><span>: </span><span>option</span><span>(</span><span>&#34;</span><span>--force</span><span>&#34;</span><span>)</span></span>
<span><span>  }))</span></span>
<span><span>);</span></span>
<span></span>
<span><span>// TypeScript infers this type automatically:</span></span>
<span><span>type</span><span> Cli</span><span> =</span><span> </span></span>
<span><span>  |</span><span> {</span><span> </span></span>
<span><span>      readonly</span><span> action</span><span>: </span><span>&#34;</span><span>deploy</span><span>&#34;</span></span>
<span><span>      readonly</span><span> environment</span><span>: </span><span>string</span></span>
<span><span>      readonly</span><span> replicas</span><span>: </span><span>number</span></span>
<span><span>    }</span></span>
<span><span>  |</span><span> {</span><span> </span></span>
<span><span>      readonly</span><span> action</span><span>: </span><span>&#34;</span><span>rollback</span><span>&#34;</span></span>
<span><span>      readonly</span><span> version</span><span>: </span><span>string</span></span>
<span><span>      readonly</span><span> force</span><span>: </span><span>boolean</span></span>
<span><span>    }</span></span></code></pre>
<p>TypeScript knows that if <code>action</code> is <code>&#34;deploy&#34;</code>, then <code>environment</code> exists but
<code>version</code> doesn&#39;t. It knows <code>replicas</code> is a <code>number</code>. It knows <code>force</code> is
a <code>boolean</code>. I didn&#39;t tell it any of this.</p>
<p>This isn&#39;t just about nice autocomplete (though yeah, the autocomplete is great).
It&#39;s about catching bugs before they happen. Forget to handle a new option
somewhere? Code won&#39;t compile.</p>
<h2 id="0199203f-a6e9-7f90-9462-0af136538c9c--what-actually-changed-for-me">What actually changed for me <a href="#0199203f-a6e9-7f90-9462-0af136538c9c--what-actually-changed-for-me"><span aria-hidden="true"></span></a></h2>
<p>I&#39;ve been dogfooding this for a few weeks. Some real talk:</p>
<p><strong>I delete code now.</strong> Not refactor. Delete. That validation logic that used to
be 30% of my CLI code? Gone. It feels weird every time.</p>
<p><strong>Refactoring isn&#39;t scary.</strong> Want to know something that usually terrifies me?
Changing how a CLI takes its arguments. Like going from <code>--input file.txt</code> to
just <code>file.txt</code> as a positional argument. With traditional parsers,
you&#39;re hunting down validation logic everywhere. With this?
You change the parser definition, TypeScript immediately shows you every place
that breaks, you fix them, done. What used to be an hour of “did I catch
everything?” is now “fix the red squiggles and move on.”</p>
<p><strong>My CLIs got fancier.</strong> When adding complex option relationships doesn&#39;t mean
writing complex validation, you just… add them. Mutually exclusive groups?
Sure. Context-dependent options? Why not. The parser handles it.</p>
<p>The reusability is real too:</p>
<pre><code><span><span>const </span><span>networkOptions</span><span> =</span><span> object</span><span>({</span></span>
<span><span>  host</span><span>: </span><span>option</span><span>(</span><span>&#34;</span><span>--host</span><span>&#34;</span><span>, </span><span>string</span><span>()),</span></span>
<span><span>  port</span><span>: </span><span>option</span><span>(</span><span>&#34;</span><span>--port</span><span>&#34;</span><span>, </span><span>integer</span><span>())</span></span>
<span><span>});</span></span>
<span></span>
<span><span>// Reuse everywhere, compose differently</span></span>
<span><span>const </span><span>devServer</span><span> =</span><span> merge</span><span>(</span><span>networkOptions</span><span>,</span><span> debugOptions</span><span>);</span></span>
<span><span>const </span><span>prodServer</span><span> =</span><span> merge</span><span>(</span><span>networkOptions</span><span>,</span><span> authOptions</span><span>);</span></span>
<span><span>const </span><span>testServer</span><span> =</span><span> merge</span><span>(</span><span>networkOptions</span><span>,</span><span> mockOptions</span><span>);</span></span></code></pre>
<p>But honestly? The biggest change is trust. If it compiles, the CLI logic works.
Not “probably works” or “works unless someone passes weird arguments.”
It just works.</p>
<h2 id="0199203f-a6e9-7f90-9462-0af136538c9c--should-you-care">Should you care? <a href="#0199203f-a6e9-7f90-9462-0af136538c9c--should-you-care"><span aria-hidden="true"></span></a></h2>
<p>If you&#39;re writing a 10-line script that takes one argument, you don&#39;t need this.
<code>process.argv[2]</code> and call it a day.</p>
<p>But if you&#39;ve ever:</p>
<ul>
<li>Had validation logic get out of sync with your actual options</li>
<li>Discovered in production that certain option combinations explode</li>
<li>Spent an afternoon tracking down why <code>--verbose</code> breaks when used with
<code>--json</code></li>
<li>Written the same “option A requires option B” check for the fifth time</li>
</ul>
<p>Then yeah, maybe you&#39;re tired of this stuff too.</p>
<p>Fair warning: Optique is young. I&#39;m still figuring things out, the API might
shift a bit. But the core idea—parse, don&#39;t validate—that&#39;s solid.
And I haven&#39;t written validation code in months.</p>
<p>Still feels weird. Good weird.</p>
<h2 id="0199203f-a6e9-7f90-9462-0af136538c9c--try-it-or-dont">Try it or don&#39;t <a href="#0199203f-a6e9-7f90-9462-0af136538c9c--try-it-or-dont"><span aria-hidden="true"></span></a></h2>
<p>If this resonates:</p>
<ul>
<li><a href="https://optique.dev/tutorial"><em>Tutorial</em></a>: Build something real, see if you hate it</li>
<li><em>Concepts</em>: <a href="https://optique.dev/concepts/primitives">Primitives</a>, <a href="https://optique.dev/concepts/constructs">constructs</a>, <a href="https://optique.dev/concepts/modifiers">modifiers</a>, <a href="https://optique.dev/concepts/valueparsers">value parsers</a>,
the whole thing</li>
<li><a href="https://github.com/dahlia/optique"><em>GitHub</em></a>: The code, issues, angry rants</li>
</ul>
<p>I&#39;m not saying Optique is the answer to all CLI problems. I&#39;m just saying
I was tired of writing the same validation code everywhere, so I built something
that makes it unnecessary.</p>
<p>Take it or leave it. But that validation code you&#39;re about to write?
You probably don&#39;t need it.</p>
</div></div>
  </body>
</html>
