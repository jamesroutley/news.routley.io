<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/zesterer/chumsky">Original</a>
    <h1>Chumsky, a Rust parser-combinator library with error recovery</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
            <article itemprop="text">
<p dir="auto"><a href="https://crates.io/crates/chumsky" rel="nofollow"><img src="https://camo.githubusercontent.com/1cc835813d9bd37230385755e95c4a59a1180a2190005061f553c099426d2ce0/68747470733a2f2f696d672e736869656c64732e696f2f6372617465732f762f6368756d736b792e737667" alt="crates.io" data-canonical-src="https://img.shields.io/crates/v/chumsky.svg"/></a>
<a href="https://docs.rs/chumsky" rel="nofollow"><img src="https://camo.githubusercontent.com/c6e14113760c8b0cd3dde352af8281ff2a7cf4177815eafd2b7a048d11f7c03c/68747470733a2f2f646f63732e72732f6368756d736b792f62616467652e737667" alt="crates.io" data-canonical-src="https://docs.rs/chumsky/badge.svg"/></a>
<a href="https://github.com/zesterer/chumsky"><img src="https://camo.githubusercontent.com/3e7a787ff278fa3576ad5df6a18bc1ebe82fe3c0b338025d8f54a4c629126c95/68747470733a2f2f696d672e736869656c64732e696f2f6372617465732f6c2f6368756d736b792e737667" alt="License" data-canonical-src="https://img.shields.io/crates/l/chumsky.svg"/></a>
<a href="https://github.com/zesterer/chumsky/actions"><img src="https://github.com/zesterer/chumsky/workflows/Rust/badge.svg?branch=master" alt="actions-badge"/></a></p>
<p dir="auto">A parser library for humans with powerful error recovery.</p>
<a href="https://www.github.com/zesterer/tao">
    <img src="https://raw.githubusercontent.com/zesterer/chumsky/master/misc/example.png" alt="Example usage with my own language, Tao"/>
</a>
<p dir="auto"><em>Note: Error diagnostic rendering is performed by <a href="https://github.com/zesterer/ariadne">Ariadne</a></em></p>
<h2 dir="auto"><a id="user-content-contents" aria-hidden="true" href="#contents"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Contents</h2>
<ul dir="auto">
<li><a href="#features">Features</a></li>
<li><a href="#example-brainfuck-parser">Example Brainfuck Parser</a></li>
<li><a href="#tutorial">Tutorial</a></li>
<li><a href="#what-is-a-parser-combinator"><em>What</em> is a parser combinator?</a></li>
<li><a href="#why-use-parser-combinators"><em>Why</em> use parser combinators?</a></li>
<li><a href="#classification">Classification</a></li>
<li><a href="#error-recovery">Error Recovery</a></li>
<li><a href="#performance">Performance</a></li>
<li><a href="#planned-features">Planned Features</a></li>
<li><a href="#philosophy">Philosophy</a></li>
<li><a href="#notes">Notes</a></li>
<li><a href="#license">License</a></li>
</ul>
<h2 dir="auto"><a id="user-content-features" aria-hidden="true" href="#features"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Features</h2>
<ul dir="auto">
<li>Lots of combinators!</li>
<li>Generic across input, output, error, and span types</li>
<li>Powerful error recovery strategies</li>
<li>Inline mapping to your AST</li>
<li>Text-specific parsers for both <code>u8</code>s and <code>char</code>s</li>
<li>Recursive parsers</li>
<li>Backtracking is fully supported, allowing the parsing of all known context-free grammars</li>
<li>Parsing of nesting inputs, allowing you to move delimiter parsing to the lexical stage (as Rust does!)</li>
<li>Built-in parser debugging</li>
</ul>
<h2 dir="auto"><a id="user-content-example-brainfuck-parser" aria-hidden="true" href="#example-brainfuck-parser"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Example <a href="https://en.wikipedia.org/wiki/Brainfuck" rel="nofollow">Brainfuck</a> Parser</h2>
<p dir="auto">See <a href="https://github.com/zesterer/chumsky/blob/master/examples/brainfuck.rs"><code>examples/brainfuck.rs</code></a> for the full
interpreter (<code>cargo run --example brainfuck -- examples/sample.bf</code>).</p>
<div data-snippet-clipboard-copy-content="use chumsky::prelude::*;

#[derive(Clone)]
enum Instr {
    Left, Right,
    Incr, Decr,
    Read, Write,
    Loop(Vec&lt;Self&gt;),
}

fn parser() -&gt; impl Parser&lt;char, Vec&lt;Instr&gt;, Error = Simple&lt;char&gt;&gt; {
    recursive(|bf| choice((
        just(&#39;&lt;&#39;).to(Instr::Left),
        just(&#39;&gt;&#39;).to(Instr::Right),
        just(&#39;+&#39;).to(Instr::Incr),
        just(&#39;-&#39;).to(Instr::Decr),
        just(&#39;,&#39;).to(Instr::Read),
        just(&#39;.&#39;).to(Instr::Write),
        bf.delimited_by(just(&#39;[&#39;), just(&#39;]&#39;)).map(Instr::Loop),
    ))
        .repeated())
}"><pre><span>use</span> chumsky<span>::</span>prelude<span>::</span><span>*</span>;

#[derive(Clone)]
<span>enum</span> <span>Instr</span> {
    Left, Right,
    Incr, Decr,
    Read, Write,
    <span>Loop</span>(<span>Vec</span><span>&lt;</span><span>Self</span><span>&gt;</span>),
}

<span>fn</span> <span>parser</span>() -&gt; <span>impl</span> Parser&lt;<span>char</span>, <span>Vec</span>&lt;Instr&gt;, Error = Simple&lt;<span>char</span>&gt;&gt; {
    <span>recursive</span>(<span>|</span>bf<span>|</span> <span>choice</span>((
        <span>just</span>(<span>&#39;&lt;&#39;</span>).<span>to</span>(Instr<span>::</span>Left),
        <span>just</span>(<span>&#39;&gt;&#39;</span>).<span>to</span>(Instr<span>::</span>Right),
        <span>just</span>(<span>&#39;+&#39;</span>).<span>to</span>(Instr<span>::</span>Incr),
        <span>just</span>(<span>&#39;-&#39;</span>).<span>to</span>(Instr<span>::</span>Decr),
        <span>just</span>(<span>&#39;,&#39;</span>).<span>to</span>(Instr<span>::</span>Read),
        <span>just</span>(<span>&#39;.&#39;</span>).<span>to</span>(Instr<span>::</span>Write),
        bf.<span>delimited_by</span>(<span>just</span>(<span>&#39;[&#39;</span>), <span>just</span>(<span>&#39;]&#39;</span>)).<span>map</span>(Instr<span>::</span>Loop),
    ))
        .<span>repeated</span>())
}</pre></div>
<p dir="auto">Other examples include:</p>
<ul dir="auto">
<li>A <a href="https://github.com/zesterer/chumsky/blob/master/examples/json.rs">JSON parser</a> (<code>cargo run --example json -- examples/sample.json</code>)</li>
<li>An <a href="https://github.com/zesterer/chumsky/blob/master/examples/nano_rust.rs">interpreter for a simple Rust-y language</a>
(<code>cargo run --example nano_rust -- examples/sample.nrs</code>)</li>
</ul>
<h2 dir="auto"><a id="user-content-tutorial" aria-hidden="true" href="#tutorial"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Tutorial</h2>
<p dir="auto">Chumsky has <a href="https://github.com/zesterer/chumsky/blob/master/tutorial.md">a tutorial</a> that teaches you how to write a
parser and interpreter for a simple dynamic language with unary and binary operators, operator precedence, functions,
let declarations, and calls.</p>
<h2 dir="auto"><a id="user-content-what-is-a-parser-combinator" aria-hidden="true" href="#what-is-a-parser-combinator"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><em>What</em> is a parser combinator?</h2>
<p dir="auto">Parser combinators are a technique for implementing parsers by defining them in terms of other parsers. The resulting
parsers use a <a href="https://en.wikipedia.org/wiki/Recursive_descent_parser" rel="nofollow">recursive descent</a> strategy to transform a stream
of tokens into an output. Using parser combinators to define parsers is roughly analogous to using Rust&#39;s
<a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html" rel="nofollow"><code>Iterator</code></a> trait to define iterative algorithms: the
type-driven API of <code>Iterator</code> makes it more difficult to make mistakes and easier to encode complicated iteration logic
than if one were to write the same code by hand. The same is true of parser combinators.</p>
<h2 dir="auto"><a id="user-content-why-use-parser-combinators" aria-hidden="true" href="#why-use-parser-combinators"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><em>Why</em> use parser combinators?</h2>
<p dir="auto">Writing parsers with good error recovery is conceptually difficult and time-consuming. It requires understanding the
intricacies of the recursive descent algorithm, and then implementing recovery strategies on top of it. If you&#39;re
developing a programming language, you&#39;ll almost certainly change your mind about syntax in the process, leading to some
slow and painful parser refactoring. Parser combinators solve both problems by providing an ergonomic API that allows
for rapidly iterating upon a syntax.</p>
<p dir="auto">Parser combinators are also a great fit for domain-specific languages for which an existing parser does not exist.
Writing a reliable, fault-tolerant parser for such situations can go from being a multi-day task to a half-hour task
with the help of a decent parser combinator library.</p>
<h2 dir="auto"><a id="user-content-classification" aria-hidden="true" href="#classification"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Classification</h2>
<p dir="auto">Chumsky&#39;s parsers are <a href="https://en.wikipedia.org/wiki/Recursive_descent_parser" rel="nofollow">recursive descent</a> parsers and are
capable of parsing <a href="https://en.wikipedia.org/wiki/Parsing_expression_grammar" rel="nofollow">parsing expression grammars (PEGs)</a>, which
includes all known context-free languages. It is theoretically possible to extend Chumsky further to accept limited
context-sensitive grammars too, although this is rarely required.</p>
<h2 dir="auto"><a id="user-content-error-recovery" aria-hidden="true" href="#error-recovery"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Error Recovery</h2>
<p dir="auto">Chumsky has support for error recovery, meaning that it can encounter a syntax error, report the error, and then
attempt to recover itself into a state in which it can continue parsing so that multiple errors can be produced at once
and a partial <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree" rel="nofollow">AST</a> can still be generated from the input for future
compilation stages to consume.</p>
<p dir="auto">However, there is no silver bullet strategy for error recovery. By definition, if the input to a parser is invalid then
the parser can only make educated guesses as to the meaning of the input. Different recovery strategies will work better
for different languages, and for different patterns within those languages.</p>
<p dir="auto">Chumsky provides a variety of recovery strategies (each implementing the <code>Strategy</code> trait), but it&#39;s important to
understand that all of</p>
<ul dir="auto">
<li>which you apply</li>
<li>where you apply them</li>
<li>what order you apply them</li>
</ul>
<p dir="auto">will greatly affect the quality of the errors that Chumsky is able to produce, along with the extent to which it is able
to recover a useful AST. Where possible, you should attempt more &#39;specific&#39; recovery strategies first rather than those
that mindlessly skip large swathes of the input.</p>
<p dir="auto">It is recommended that you experiment with applying different strategies in different situations and at different levels
of the parser to find a configuration that you are happy with. If none of the provided error recovery strategies cover
the specific pattern you wish to catch, you can even create your own by digging into Chumsky&#39;s internals and
implementing your own strategies! If you come up with a useful strategy, feel free to open a PR against the
<a href="https://github.com/zesterer/chumsky/">main repository</a>!</p>
<h2 dir="auto"><a id="user-content-performance" aria-hidden="true" href="#performance"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Performance</h2>
<p dir="auto">Chumsky focuses on high-quality errors and ergonomics over performance. That said, it&#39;s important that Chumsky can keep
up with the rest of your compiler! Unfortunately, it&#39;s <em>extremely</em> difficult to come up with sensible benchmarks given
that exactly how Chumsky performs depends entirely on what you are parsing, how you structure your parser, which
patterns the parser attempts to match first, how complex your error type is, what is involved in constructing your AST,
etc. All that said, here are some numbers from the
<a href="https://github.com/zesterer/chumsky/blob/master/benches/json.rs">JSON benchmark</a> included in the repository running on
my Ryzen 7 3700x.</p>
<div data-snippet-clipboard-copy-content="test chumsky ... bench:   4,782,390 ns/iter (+/- 997,208)
test pom     ... bench:  12,793,490 ns/iter (+/- 1,954,583)"><pre><span>test</span> <span>chumsky</span> <span>...</span> <span>bench:</span>   <span>4,782,390</span> <span>ns</span>/<span>iter</span> <span>(+</span>/<span>-</span> <span>997,208)</span>
<span>test</span> <span>pom</span>     <span>...</span> <span>bench:</span>  <span>12,793,490</span> <span>ns</span>/<span>iter</span> <span>(+</span>/<span>-</span> <span>1,954,583)</span></pre></div>
<p dir="auto">I&#39;ve included results from <a href="https://github.com/J-F-Liu/pom"><code>pom</code></a>, another parser combinator crate with a similar
design, as a point of reference. The sample file being parsed is broadly representative of typical JSON data and has
3,018 lines. This translates to a little over 630,000 lines of JSON per second.</p>
<p dir="auto">Clearly, this is a little slower than a well-optimised hand-written parser: but that&#39;s okay! Chumsky&#39;s goal is to be
<em>fast enough</em>. If you&#39;ve written enough code in your language that parsing performance even starts to be a problem,
you&#39;ve already committed enough time and resources to your language that hand-writing a parser is the best choice going!</p>
<h2 dir="auto"><a id="user-content-planned-features" aria-hidden="true" href="#planned-features"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Planned Features</h2>
<ul dir="auto">
<li>An optimised &#39;happy path&#39; parser mode that skips error recovery &amp; error generation</li>
<li>An even faster &#39;validation&#39; parser mode, guaranteed to not allocate, that doesn&#39;t generate outputs but just verifies
the validity of an input</li>
</ul>
<h2 dir="auto"><a id="user-content-philosophy" aria-hidden="true" href="#philosophy"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Philosophy</h2>
<p dir="auto">Chumsky should:</p>
<ul dir="auto">
<li>Be easy to use, even if you don&#39;t understand exactly what the parser is doing under the hood</li>
<li>Be type-driven, pushing users away from anti-patterns at compile-time</li>
<li>Be a mature, &#39;batteries-included&#39; solution for context-free parsing by default. If you need to implement either
<code>Parser</code> or <code>Strategy</code> by hand, that&#39;s a problem that needs fixing</li>
<li>Be &#39;fast enough&#39;, but no faster (i.e: when there is a tradeoff between error quality and performance, Chumsky will
always take the former option)</li>
<li>Be modular and extensible, allowing users to implement their own parsers, recovery strategies, error types, spans, and
be generic over both input tokens and the output AST</li>
</ul>
<h2 dir="auto"><a id="user-content-notes" aria-hidden="true" href="#notes"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Notes</h2>
<p dir="auto">My apologies to Noam for choosing such an absurd name.</p>
<h2 dir="auto"><a id="user-content-license" aria-hidden="true" href="#license"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>License</h2>
<p dir="auto">Chumsky is licensed under the MIT license (see <code>LICENSE</code> in the main repository).</p>
</article>
          </div></div>
  </body>
</html>
