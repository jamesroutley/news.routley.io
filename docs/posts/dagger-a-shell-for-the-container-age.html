<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://dagger.io/blog/dagger-shell">Original</a>
    <h1>Dagger: A shell for the container age</h1>
    
    <div id="readability-page-1" class="page"><div data-framer-name="Post"><div><div data-framer-name="Content" data-framer-component-type="RichTextContainer"><p>The Unix shell is over 50 years old, but it still defines how programmers use their computers. We type a few words in a terminal, and milliseconds later an ephemeral factory comes online: the Unix pipeline. Data streams through a network of simple programs working concurrently, like robots on the factory floor, executing a computational choreography we composed seconds ago. Its job done, the factory vanishes. Onto the next command. That loop built the internet, and still runs it today.</p><p>The design principles of Unix are timeless: write simple programs, compose them with standard interfaces. But 50 years is a long time… the software stack has expanded, and Unix interfaces are buried under layers of abstraction. We still use the shell, but it’s no longer the universal composition system it was meant to be. What if we changed that?</p><p>What if the Unix shell took the best ideas from docker, make, powershell and nix? Native support for primitives like containers, secrets and service endpoints; typed objects; declarative execution; content-addressed artifacts; everything sandboxed and cached by default. What if those all became standard shell features, available with standard shell syntax, and backed by a modern API? Would we still need to learn a dozen DSLs to automate the basic tasks of shipping software? Or would the complexity of the modern software stack melt away, leaving only two fundamental elements: shell and code? Let’s find out!</p><p>Today we’re introducing Dagger Shell: a bash syntax frontend for our state-of-the-art runtime and composition system, the Dagger Engine. Use it for builds, tests, ephemeral environments, deployments, or any other task you want to automate from the terminal. It’s also a great way to <!--$--><a href="https://x.com/solomonstre/status/1895671390176747682" rel="noopener">compose AI agents</a><!--/$-->…but more on that later.</p><p>To get started, just <!--$--><a href="https://docs.dagger.io/install" rel="noopener">install the latest version of Dagger</a><!--/$-->, and type <code>dagger</code>. Or keep reading for examples.</p><h4>A complement to your system shell</h4><p>Dagger Shell isn’t meant to replace your system shell, but to complement it. When a workflow is too complex to fit in a regular shell, the next available option is often a brittle monolith: not as simple as a shell script, not as robust as full-blown software. The Dagger Shell aspires to help you replace that monolith with a collection of simple modules, composed with standard interfaces.</p><div><div><div><div><div><div><pre translate="no"><code>container |
  from alpine |
  with-exec apk add <span>git</span>

</code></pre></div></div></div></div></div></div><p><img alt="" height="452" src="https://framerusercontent.com/images/XH95QDMWgq7HcdaYmJUjMGTBj34.gif" srcset="https://framerusercontent.com/images/XH95QDMWgq7HcdaYmJUjMGTBj34.gif?scale-down-to=512 512w,https://framerusercontent.com/images/XH95QDMWgq7HcdaYmJUjMGTBj34.gif?scale-down-to=1024 1024w,https://framerusercontent.com/images/XH95QDMWgq7HcdaYmJUjMGTBj34.gif 1500w" width="750" data-framer-original-sizes="" sizes="(min-width: 1200px) 100vw, (min-width: 768px) and (max-width: 1199px) 100vw, (max-width: 767px) 100vw"/></p><h4><strong>Shell and code are all you need</strong></h4><p>When a script becomes too complex and outgrows the shell syntax, why learn a weird DSL when you can write real code?</p><p>Unix was built on the twin pillars of its shell and C programming environment. Dagger follows the same model, with SDKs available for Go, Python, Typescript, Java and PHP. Pick a language, write a function…Congratulations, you just extended Dagger with your own primitive! No matter how complex your system, you should only ever need two building blocks: shell and code.</p><p><img alt="" height="256" src="https://framerusercontent.com/images/XzKufwbAdlU0AdzOmCafaNvnS8.png" srcset="https://framerusercontent.com/images/XzKufwbAdlU0AdzOmCafaNvnS8.png?scale-down-to=512 512w,https://framerusercontent.com/images/XzKufwbAdlU0AdzOmCafaNvnS8.png?scale-down-to=1024 1024w,https://framerusercontent.com/images/XzKufwbAdlU0AdzOmCafaNvnS8.png 1500w" width="750" data-framer-original-sizes="" sizes="(min-width: 1200px) 100vw, (min-width: 768px) and (max-width: 1199px) 100vw, (max-width: 767px) 100vw"/><img alt="" height="205" src="https://framerusercontent.com/images/IWYAReQkyuqaRLUw1bty3xVTY.png" srcset="https://framerusercontent.com/images/IWYAReQkyuqaRLUw1bty3xVTY.png?scale-down-to=512 512w,https://framerusercontent.com/images/IWYAReQkyuqaRLUw1bty3xVTY.png?scale-down-to=1024 1024w,https://framerusercontent.com/images/IWYAReQkyuqaRLUw1bty3xVTY.png 1499w" width="749" data-framer-original-sizes="" sizes="(min-width: 1200px) 100vw, (min-width: 768px) and (max-width: 1199px) 100vw, (max-width: 767px) 100vw"/></p><h4><strong>Shell, meet API</strong></h4><p>Dagger Shell is just another Dagger API client, giving you typed objects, built-in documentation, and access to a <!--$--><a href="https://daggerverse.dev/" rel="noopener">cross-language ecosystem of reusable modules</a><!--/$-->.</p><p>That’s right, Dagger Shell can load any of the thousands of modules in the Daggerverse, inspect their API, and run their functions. Here we explore a <!--$--><a href="https://daggerverse.dev/mod/github.com/jpadams/daggerverse/trivy" rel="noopener">Trivy module</a><!--/$-->:</p><p><img alt="" height="344" src="https://framerusercontent.com/images/AFe3wlbkkncUQgak0QOtYVgc.gif" srcset="https://framerusercontent.com/images/AFe3wlbkkncUQgak0QOtYVgc.gif?scale-down-to=512 512w,https://framerusercontent.com/images/AFe3wlbkkncUQgak0QOtYVgc.gif?scale-down-to=1024 1024w,https://framerusercontent.com/images/AFe3wlbkkncUQgak0QOtYVgc.gif 1500w" width="750" data-framer-original-sizes="" sizes="(min-width: 1200px) 100vw, (min-width: 768px) and (max-width: 1199px) 100vw, (max-width: 767px) 100vw"/></p><h4><strong>Sandboxed by default</strong></h4><p>Dagger Shell commands run as sandboxed functions, accessing host resources (files, secrets, services) only when explicitly provided as arguments.</p><p>This can make commands slightly more verbose, but also more repeatable, giving you confidence to iterate quickly without second-guessing.</p><p>For example, here’s a dev environment using a secret, local directory, and database access:</p><h4><strong>Simple container build</strong></h4><p>This creates an Alpine container, drops in a text file with your message, sets it to display that message when run, and publishes it to a temporary registry. All in one pipeline - no context switching between Dockerfile creation, build commands, and registry pushes.</p><p><img alt="" height="344" src="https://framerusercontent.com/images/TeLBJhuROM3rJ5SOUrl07nl59QM.gif" srcset="https://framerusercontent.com/images/TeLBJhuROM3rJ5SOUrl07nl59QM.gif?scale-down-to=512 512w,https://framerusercontent.com/images/TeLBJhuROM3rJ5SOUrl07nl59QM.gif?scale-down-to=1024 1024w,https://framerusercontent.com/images/TeLBJhuROM3rJ5SOUrl07nl59QM.gif 1500w" width="750" data-framer-original-sizes="" sizes="(min-width: 1200px) 100vw, (min-width: 768px) and (max-width: 1199px) 100vw, (max-width: 767px) 100vw"/></p><h4><strong>Test environments</strong></h4><p>A common problem in CI is creating ephemeral test environments: you need to containerize the software being tested, and connect it to its dependencies. Dagger makes this easy with native support for service bindings.</p><p>For example, let’s create an environment with several live instances of the Dagger docs hooked up, and “test” them with curl.</p><p>This also highlights how third-party modules can be seamlessly mixed and matched.</p><div><div><div><div><div><div><pre translate="no"><code><span># Build a wolfi linux container with curl, then test connection to stable and dev docs</span>
github.com/dagger/dagger/modules/wolfi | container <span>--packages</span>=<span>curl</span> |
  with-service-binding docs-stable <span>$(github.com/dagger/dagger/docs@v0.17.1 | server)</span> |
  with-service-binding docs-dev <span>$(github.com/dagger/dagger/docs@main | server)</span> |
  with-exec <span>curl</span> http://docs-stable |
  with-exec <span>curl</span>

</code></pre></div></div></div></div></div></div><h4><strong>Multi-Stage Builds</strong></h4><p>Implement complex build workflows with clear, modular syntax. Maintain visibility and control over each stage of your pipeline. Save and reuse parts of your pipeline. Why juggle between editing Dockerfiles, running build and push commands, when you can do it all in one go?</p><div><div><div><div><div><div><pre translate="no"><code><span>repo</span>=<span>$(git https://github.com/dagger/hello-dagger | head | tree)</span>

<span>env</span>=<span>$(container | from node:23 | with-directory /app </span><span>$repo</span><span> | with-workdir /app)</span>

<span>build</span>=<span>$(</span><span>$env</span><span> | with-exec npm install | with-exec npm run build | directory ./dist)</span>

container | from nginx | with-directory /usr/share/nginx/html <span>$build</span> | terminal <span>--cmd</span>

</code></pre></div></div></div></div></div></div><p><img alt="" height="344" src="https://framerusercontent.com/images/tE3HikgkldkbnnkqBtA9zpxVeas.gif" srcset="https://framerusercontent.com/images/tE3HikgkldkbnnkqBtA9zpxVeas.gif?scale-down-to=512 512w,https://framerusercontent.com/images/tE3HikgkldkbnnkqBtA9zpxVeas.gif?scale-down-to=1024 1024w,https://framerusercontent.com/images/tE3HikgkldkbnnkqBtA9zpxVeas.gif 1500w" width="750" data-framer-original-sizes="" sizes="(min-width: 1200px) 100vw, (min-width: 768px) and (max-width: 1199px) 100vw, (max-width: 767px) 100vw"/></p><p>This example pulls source code, creates a Node.js build environment, runs the build process, and packages just the built files into a minimal nginx container. Each stage is a named variable you can inspect, modify, or reuse - the state is explicit, not hidden in layers of a Dockerfile or build cache.</p><p>Get a dev build of Dagger, fresh from our repository:</p><div><div><div><div><div><div><pre translate="no"><code>container |
  from golang:latest |
  with-directory /src <span>$(git https://github.com/dagger/dagger | head | tree)</span> |
  with-workdir /src |
  with-exec go build ./cmd/dagger |
  file ./dagger |
  <span>export</span>

</code></pre></div></div></div></div></div></div><p><img alt="" height="344" src="https://framerusercontent.com/images/txHfsn8szyA0OoDpVR9d1ozuRN4.gif" srcset="https://framerusercontent.com/images/txHfsn8szyA0OoDpVR9d1ozuRN4.gif?scale-down-to=512 512w,https://framerusercontent.com/images/txHfsn8szyA0OoDpVR9d1ozuRN4.gif?scale-down-to=1024 1024w,https://framerusercontent.com/images/txHfsn8szyA0OoDpVR9d1ozuRN4.gif 1500w" width="750" data-framer-original-sizes="" sizes="(min-width: 1200px) 100vw, (min-width: 768px) and (max-width: 1199px) 100vw, (max-width: 767px) 100vw"/></p><h4>What’s Next?</h4><p>We’d love for you to try out Dagger Shell and share your feedback. Learn more in the <!--$--><a href="https://docs.dagger.io/features/shell" target="_blank" rel="noopener">Dagger Shell documentation</a><!--/$-->, join our<!--$--><a href="https://discord.com/channels/707636530424053791/1318344234511892490" rel="noopener"> Discord</a><!--/$--> and let us know how Dagger Shell improves your development workflow!</p><p>Happy hacking! 🚀</p></div></div><div><div data-framer-name="Content" data-framer-component-type="RichTextContainer"><p>The Unix shell is over 50 years old, but it still defines how programmers use their computers. We type a few words in a terminal, and milliseconds later an ephemeral factory comes online: the Unix pipeline. Data streams through a network of simple programs working concurrently, like robots on the factory floor, executing a computational choreography we composed seconds ago. Its job done, the factory vanishes. Onto the next command. That loop built the internet, and still runs it today.</p><p>The design principles of Unix are timeless: write simple programs, compose them with standard interfaces. But 50 years is a long time… the software stack has expanded, and Unix interfaces are buried under layers of abstraction. We still use the shell, but it’s no longer the universal composition system it was meant to be. What if we changed that?</p><p>What if the Unix shell took the best ideas from docker, make, powershell and nix? Native support for primitives like containers, secrets and service endpoints; typed objects; declarative execution; content-addressed artifacts; everything sandboxed and cached by default. What if those all became standard shell features, available with standard shell syntax, and backed by a modern API? Would we still need to learn a dozen DSLs to automate the basic tasks of shipping software? Or would the complexity of the modern software stack melt away, leaving only two fundamental elements: shell and code? Let’s find out!</p><p>Today we’re introducing Dagger Shell: a bash syntax frontend for our state-of-the-art runtime and composition system, the Dagger Engine. Use it for builds, tests, ephemeral environments, deployments, or any other task you want to automate from the terminal. It’s also a great way to <!--$--><a href="https://x.com/solomonstre/status/1895671390176747682" rel="noopener">compose AI agents</a><!--/$-->…but more on that later.</p><p>To get started, just <!--$--><a href="https://docs.dagger.io/install" rel="noopener">install the latest version of Dagger</a><!--/$-->, and type <code>dagger</code>. Or keep reading for examples.</p><h4>A complement to your system shell</h4><p>Dagger Shell isn’t meant to replace your system shell, but to complement it. When a workflow is too complex to fit in a regular shell, the next available option is often a brittle monolith: not as simple as a shell script, not as robust as full-blown software. The Dagger Shell aspires to help you replace that monolith with a collection of simple modules, composed with standard interfaces.</p><div><div><div><div><div><div><pre translate="no"><code>container |
  from alpine |
  with-exec apk add <span>git</span>

</code></pre></div></div></div></div></div></div><p><img alt="" height="452" src="https://framerusercontent.com/images/XH95QDMWgq7HcdaYmJUjMGTBj34.gif" srcset="https://framerusercontent.com/images/XH95QDMWgq7HcdaYmJUjMGTBj34.gif?scale-down-to=512 512w,https://framerusercontent.com/images/XH95QDMWgq7HcdaYmJUjMGTBj34.gif?scale-down-to=1024 1024w,https://framerusercontent.com/images/XH95QDMWgq7HcdaYmJUjMGTBj34.gif 1500w" width="750" data-framer-original-sizes="" sizes="(min-width: 1200px) 100vw, (min-width: 768px) and (max-width: 1199px) 100vw, (max-width: 767px) 100vw"/></p><h4><strong>Shell and code are all you need</strong></h4><p>When a script becomes too complex and outgrows the shell syntax, why learn a weird DSL when you can write real code?</p><p>Unix was built on the twin pillars of its shell and C programming environment. Dagger follows the same model, with SDKs available for Go, Python, Typescript, Java and PHP. Pick a language, write a function…Congratulations, you just extended Dagger with your own primitive! No matter how complex your system, you should only ever need two building blocks: shell and code.</p><p><img alt="" height="256" src="https://framerusercontent.com/images/XzKufwbAdlU0AdzOmCafaNvnS8.png" srcset="https://framerusercontent.com/images/XzKufwbAdlU0AdzOmCafaNvnS8.png?scale-down-to=512 512w,https://framerusercontent.com/images/XzKufwbAdlU0AdzOmCafaNvnS8.png?scale-down-to=1024 1024w,https://framerusercontent.com/images/XzKufwbAdlU0AdzOmCafaNvnS8.png 1500w" width="750" data-framer-original-sizes="" sizes="(min-width: 1200px) 100vw, (min-width: 768px) and (max-width: 1199px) 100vw, (max-width: 767px) 100vw"/><img alt="" height="205" src="https://framerusercontent.com/images/IWYAReQkyuqaRLUw1bty3xVTY.png" srcset="https://framerusercontent.com/images/IWYAReQkyuqaRLUw1bty3xVTY.png?scale-down-to=512 512w,https://framerusercontent.com/images/IWYAReQkyuqaRLUw1bty3xVTY.png?scale-down-to=1024 1024w,https://framerusercontent.com/images/IWYAReQkyuqaRLUw1bty3xVTY.png 1499w" width="749" data-framer-original-sizes="" sizes="(min-width: 1200px) 100vw, (min-width: 768px) and (max-width: 1199px) 100vw, (max-width: 767px) 100vw"/></p><h4><strong>Shell, meet API</strong></h4><p>Dagger Shell is just another Dagger API client, giving you typed objects, built-in documentation, and access to a <!--$--><a href="https://daggerverse.dev/" rel="noopener">cross-language ecosystem of reusable modules</a><!--/$-->.</p><p>That’s right, Dagger Shell can load any of the thousands of modules in the Daggerverse, inspect their API, and run their functions. Here we explore a <!--$--><a href="https://daggerverse.dev/mod/github.com/jpadams/daggerverse/trivy" rel="noopener">Trivy module</a><!--/$-->:</p><p><img alt="" height="344" src="https://framerusercontent.com/images/AFe3wlbkkncUQgak0QOtYVgc.gif" srcset="https://framerusercontent.com/images/AFe3wlbkkncUQgak0QOtYVgc.gif?scale-down-to=512 512w,https://framerusercontent.com/images/AFe3wlbkkncUQgak0QOtYVgc.gif?scale-down-to=1024 1024w,https://framerusercontent.com/images/AFe3wlbkkncUQgak0QOtYVgc.gif 1500w" width="750" data-framer-original-sizes="" sizes="(min-width: 1200px) 100vw, (min-width: 768px) and (max-width: 1199px) 100vw, (max-width: 767px) 100vw"/></p><h4><strong>Sandboxed by default</strong></h4><p>Dagger Shell commands run as sandboxed functions, accessing host resources (files, secrets, services) only when explicitly provided as arguments.</p><p>This can make commands slightly more verbose, but also more repeatable, giving you confidence to iterate quickly without second-guessing.</p><p>For example, here’s a dev environment using a secret, local directory, and database access:</p><h4><strong>Simple container build</strong></h4><p>This creates an Alpine container, drops in a text file with your message, sets it to display that message when run, and publishes it to a temporary registry. All in one pipeline - no context switching between Dockerfile creation, build commands, and registry pushes.</p><p><img alt="" height="344" src="https://framerusercontent.com/images/TeLBJhuROM3rJ5SOUrl07nl59QM.gif" srcset="https://framerusercontent.com/images/TeLBJhuROM3rJ5SOUrl07nl59QM.gif?scale-down-to=512 512w,https://framerusercontent.com/images/TeLBJhuROM3rJ5SOUrl07nl59QM.gif?scale-down-to=1024 1024w,https://framerusercontent.com/images/TeLBJhuROM3rJ5SOUrl07nl59QM.gif 1500w" width="750" data-framer-original-sizes="" sizes="(min-width: 1200px) 100vw, (min-width: 768px) and (max-width: 1199px) 100vw, (max-width: 767px) 100vw"/></p><h4><strong>Test environments</strong></h4><p>A common problem in CI is creating ephemeral test environments: you need to containerize the software being tested, and connect it to its dependencies. Dagger makes this easy with native support for service bindings.</p><p>For example, let’s create an environment with several live instances of the Dagger docs hooked up, and “test” them with curl.</p><p>This also highlights how third-party modules can be seamlessly mixed and matched.</p><div><div><div><div><div><div><pre translate="no"><code><span># Build a wolfi linux container with curl, then test connection to stable and dev docs</span>
github.com/dagger/dagger/modules/wolfi | container <span>--packages</span>=<span>curl</span> |
  with-service-binding docs-stable <span>$(github.com/dagger/dagger/docs@v0.17.1 | server)</span> |
  with-service-binding docs-dev <span>$(github.com/dagger/dagger/docs@main | server)</span> |
  with-exec <span>curl</span> http://docs-stable |
  with-exec <span>curl</span>

</code></pre></div></div></div></div></div></div><h4><strong>Multi-Stage Builds</strong></h4><p>Implement complex build workflows with clear, modular syntax. Maintain visibility and control over each stage of your pipeline. Save and reuse parts of your pipeline. Why juggle between editing Dockerfiles, running build and push commands, when you can do it all in one go?</p><div><div><div><div><div><div><pre translate="no"><code><span>repo</span>=<span>$(git https://github.com/dagger/hello-dagger | head | tree)</span>

<span>env</span>=<span>$(container | from node:23 | with-directory /app </span><span>$repo</span><span> | with-workdir /app)</span>

<span>build</span>=<span>$(</span><span>$env</span><span> | with-exec npm install | with-exec npm run build | directory ./dist)</span>

container | from nginx | with-directory /usr/share/nginx/html <span>$build</span> | terminal <span>--cmd</span>

</code></pre></div></div></div></div></div></div><p><img alt="" height="344" src="https://framerusercontent.com/images/tE3HikgkldkbnnkqBtA9zpxVeas.gif" srcset="https://framerusercontent.com/images/tE3HikgkldkbnnkqBtA9zpxVeas.gif?scale-down-to=512 512w,https://framerusercontent.com/images/tE3HikgkldkbnnkqBtA9zpxVeas.gif?scale-down-to=1024 1024w,https://framerusercontent.com/images/tE3HikgkldkbnnkqBtA9zpxVeas.gif 1500w" width="750" data-framer-original-sizes="" sizes="(min-width: 1200px) 100vw, (min-width: 768px) and (max-width: 1199px) 100vw, (max-width: 767px) 100vw"/></p><p>This example pulls source code, creates a Node.js build environment, runs the build process, and packages just the built files into a minimal nginx container. Each stage is a named variable you can inspect, modify, or reuse - the state is explicit, not hidden in layers of a Dockerfile or build cache.</p><p>Get a dev build of Dagger, fresh from our repository:</p><div><div><div><div><div><div><pre translate="no"><code>container |
  from golang:latest |
  with-directory /src <span>$(git https://github.com/dagger/dagger | head | tree)</span> |
  with-workdir /src |
  with-exec go build ./cmd/dagger |
  file ./dagger |
  <span>export</span>

</code></pre></div></div></div></div></div></div><p><img alt="" height="344" src="https://framerusercontent.com/images/txHfsn8szyA0OoDpVR9d1ozuRN4.gif" srcset="https://framerusercontent.com/images/txHfsn8szyA0OoDpVR9d1ozuRN4.gif?scale-down-to=512 512w,https://framerusercontent.com/images/txHfsn8szyA0OoDpVR9d1ozuRN4.gif?scale-down-to=1024 1024w,https://framerusercontent.com/images/txHfsn8szyA0OoDpVR9d1ozuRN4.gif 1500w" width="750" data-framer-original-sizes="" sizes="(min-width: 1200px) 100vw, (min-width: 768px) and (max-width: 1199px) 100vw, (max-width: 767px) 100vw"/></p><h4>What’s Next?</h4><p>We’d love for you to try out Dagger Shell and share your feedback. Learn more in the <!--$--><a href="https://docs.dagger.io/features/shell" target="_blank" rel="noopener">Dagger Shell documentation</a><!--/$-->, join our<!--$--><a href="https://discord.com/channels/707636530424053791/1318344234511892490" rel="noopener"> Discord</a><!--/$--> and let us know how Dagger Shell improves your development workflow!</p><p>Happy hacking! 🚀</p></div></div><div><div data-framer-name="Content" data-framer-component-type="RichTextContainer"><p>The Unix shell is over 50 years old, but it still defines how programmers use their computers. We type a few words in a terminal, and milliseconds later an ephemeral factory comes online: the Unix pipeline. Data streams through a network of simple programs working concurrently, like robots on the factory floor, executing a computational choreography we composed seconds ago. Its job done, the factory vanishes. Onto the next command. That loop built the internet, and still runs it today.</p><p>The design principles of Unix are timeless: write simple programs, compose them with standard interfaces. But 50 years is a long time… the software stack has expanded, and Unix interfaces are buried under layers of abstraction. We still use the shell, but it’s no longer the universal composition system it was meant to be. What if we changed that?</p><p>What if the Unix shell took the best ideas from docker, make, powershell and nix? Native support for primitives like containers, secrets and service endpoints; typed objects; declarative execution; content-addressed artifacts; everything sandboxed and cached by default. What if those all became standard shell features, available with standard shell syntax, and backed by a modern API? Would we still need to learn a dozen DSLs to automate the basic tasks of shipping software? Or would the complexity of the modern software stack melt away, leaving only two fundamental elements: shell and code? Let’s find out!</p><p>Today we’re introducing Dagger Shell: a bash syntax frontend for our state-of-the-art runtime and composition system, the Dagger Engine. Use it for builds, tests, ephemeral environments, deployments, or any other task you want to automate from the terminal. It’s also a great way to <!--$--><a href="https://x.com/solomonstre/status/1895671390176747682" rel="noopener">compose AI agents</a><!--/$-->…but more on that later.</p><p>To get started, just <!--$--><a href="https://docs.dagger.io/install" rel="noopener">install the latest version of Dagger</a><!--/$-->, and type <code>dagger</code>. Or keep reading for examples.</p><h4>A complement to your system shell</h4><p>Dagger Shell isn’t meant to replace your system shell, but to complement it. When a workflow is too complex to fit in a regular shell, the next available option is often a brittle monolith: not as simple as a shell script, not as robust as full-blown software. The Dagger Shell aspires to help you replace that monolith with a collection of simple modules, composed with standard interfaces.</p><div><div><div><div><div><div><pre translate="no"><code>container |
  from alpine |
  with-exec apk add <span>git</span>

</code></pre></div></div></div></div></div></div><p><img alt="" height="452" src="https://framerusercontent.com/images/XH95QDMWgq7HcdaYmJUjMGTBj34.gif" srcset="https://framerusercontent.com/images/XH95QDMWgq7HcdaYmJUjMGTBj34.gif?scale-down-to=512 512w,https://framerusercontent.com/images/XH95QDMWgq7HcdaYmJUjMGTBj34.gif?scale-down-to=1024 1024w,https://framerusercontent.com/images/XH95QDMWgq7HcdaYmJUjMGTBj34.gif 1500w" width="750" data-framer-original-sizes="" sizes="(min-width: 1200px) 100vw, (min-width: 768px) and (max-width: 1199px) 100vw, (max-width: 767px) 100vw"/></p><h4><strong>Shell and code are all you need</strong></h4><p>When a script becomes too complex and outgrows the shell syntax, why learn a weird DSL when you can write real code?</p><p>Unix was built on the twin pillars of its shell and C programming environment. Dagger follows the same model, with SDKs available for Go, Python, Typescript, Java and PHP. Pick a language, write a function…Congratulations, you just extended Dagger with your own primitive! No matter how complex your system, you should only ever need two building blocks: shell and code.</p><p><img alt="" height="256" src="https://framerusercontent.com/images/XzKufwbAdlU0AdzOmCafaNvnS8.png" srcset="https://framerusercontent.com/images/XzKufwbAdlU0AdzOmCafaNvnS8.png?scale-down-to=512 512w,https://framerusercontent.com/images/XzKufwbAdlU0AdzOmCafaNvnS8.png?scale-down-to=1024 1024w,https://framerusercontent.com/images/XzKufwbAdlU0AdzOmCafaNvnS8.png 1500w" width="750" data-framer-original-sizes="" sizes="(min-width: 1200px) 100vw, (min-width: 768px) and (max-width: 1199px) 100vw, (max-width: 767px) 100vw"/><img alt="" height="205" src="https://framerusercontent.com/images/IWYAReQkyuqaRLUw1bty3xVTY.png" srcset="https://framerusercontent.com/images/IWYAReQkyuqaRLUw1bty3xVTY.png?scale-down-to=512 512w,https://framerusercontent.com/images/IWYAReQkyuqaRLUw1bty3xVTY.png?scale-down-to=1024 1024w,https://framerusercontent.com/images/IWYAReQkyuqaRLUw1bty3xVTY.png 1499w" width="749" data-framer-original-sizes="" sizes="(min-width: 1200px) 100vw, (min-width: 768px) and (max-width: 1199px) 100vw, (max-width: 767px) 100vw"/></p><h4><strong>Shell, meet API</strong></h4><p>Dagger Shell is just another Dagger API client, giving you typed objects, built-in documentation, and access to a <!--$--><a href="https://daggerverse.dev/" rel="noopener">cross-language ecosystem of reusable modules</a><!--/$-->.</p><p>That’s right, Dagger Shell can load any of the thousands of modules in the Daggerverse, inspect their API, and run their functions. Here we explore a <!--$--><a href="https://daggerverse.dev/mod/github.com/jpadams/daggerverse/trivy" rel="noopener">Trivy module</a><!--/$-->:</p><p><img alt="" height="344" src="https://framerusercontent.com/images/AFe3wlbkkncUQgak0QOtYVgc.gif" srcset="https://framerusercontent.com/images/AFe3wlbkkncUQgak0QOtYVgc.gif?scale-down-to=512 512w,https://framerusercontent.com/images/AFe3wlbkkncUQgak0QOtYVgc.gif?scale-down-to=1024 1024w,https://framerusercontent.com/images/AFe3wlbkkncUQgak0QOtYVgc.gif 1500w" width="750" data-framer-original-sizes="" sizes="(min-width: 1200px) 100vw, (min-width: 768px) and (max-width: 1199px) 100vw, (max-width: 767px) 100vw"/></p><h4><strong>Sandboxed by default</strong></h4><p>Dagger Shell commands run as sandboxed functions, accessing host resources (files, secrets, services) only when explicitly provided as arguments.</p><p>This can make commands slightly more verbose, but also more repeatable, giving you confidence to iterate quickly without second-guessing.</p><p>For example, here’s a dev environment using a secret, local directory, and database access:</p><h4><strong>Simple container build</strong></h4><p>This creates an Alpine container, drops in a text file with your message, sets it to display that message when run, and publishes it to a temporary registry. All in one pipeline - no context switching between Dockerfile creation, build commands, and registry pushes.</p><p><img alt="" height="344" src="https://framerusercontent.com/images/TeLBJhuROM3rJ5SOUrl07nl59QM.gif" srcset="https://framerusercontent.com/images/TeLBJhuROM3rJ5SOUrl07nl59QM.gif?scale-down-to=512 512w,https://framerusercontent.com/images/TeLBJhuROM3rJ5SOUrl07nl59QM.gif?scale-down-to=1024 1024w,https://framerusercontent.com/images/TeLBJhuROM3rJ5SOUrl07nl59QM.gif 1500w" width="750" data-framer-original-sizes="" sizes="(min-width: 1200px) 100vw, (min-width: 768px) and (max-width: 1199px) 100vw, (max-width: 767px) 100vw"/></p><h4><strong>Test environments</strong></h4><p>A common problem in CI is creating ephemeral test environments: you need to containerize the software being tested, and connect it to its dependencies. Dagger makes this easy with native support for service bindings.</p><p>For example, let’s create an environment with several live instances of the Dagger docs hooked up, and “test” them with curl.</p><p>This also highlights how third-party modules can be seamlessly mixed and matched.</p><div><div><div><div><div><div><pre translate="no"><code><span># Build a wolfi linux container with curl, then test connection to stable and dev docs</span>
github.com/dagger/dagger/modules/wolfi | container <span>--packages</span>=<span>curl</span> |
  with-service-binding docs-stable <span>$(github.com/dagger/dagger/docs@v0.17.1 | server)</span> |
  with-service-binding docs-dev <span>$(github.com/dagger/dagger/docs@main | server)</span> |
  with-exec <span>curl</span> http://docs-stable |
  with-exec <span>curl</span>

</code></pre></div></div></div></div></div></div><h4><strong>Multi-Stage Builds</strong></h4><p>Implement complex build workflows with clear, modular syntax. Maintain visibility and control over each stage of your pipeline. Save and reuse parts of your pipeline. Why juggle between editing Dockerfiles, running build and push commands, when you can do it all in one go?</p><div><div><div><div><div><div><pre translate="no"><code><span>repo</span>=<span>$(git https://github.com/dagger/hello-dagger | head | tree)</span>

<span>env</span>=<span>$(container | from node:23 | with-directory /app </span><span>$repo</span><span> | with-workdir /app)</span>

<span>build</span>=<span>$(</span><span>$env</span><span> | with-exec npm install | with-exec npm run build | directory ./dist)</span>

container | from nginx | with-directory /usr/share/nginx/html <span>$build</span> | terminal <span>--cmd</span>

</code></pre></div></div></div></div></div></div><p><img alt="" height="344" src="https://framerusercontent.com/images/tE3HikgkldkbnnkqBtA9zpxVeas.gif" srcset="https://framerusercontent.com/images/tE3HikgkldkbnnkqBtA9zpxVeas.gif?scale-down-to=512 512w,https://framerusercontent.com/images/tE3HikgkldkbnnkqBtA9zpxVeas.gif?scale-down-to=1024 1024w,https://framerusercontent.com/images/tE3HikgkldkbnnkqBtA9zpxVeas.gif 1500w" width="750" data-framer-original-sizes="" sizes="(min-width: 1200px) 100vw, (min-width: 768px) and (max-width: 1199px) 100vw, (max-width: 767px) 100vw"/></p><p>This example pulls source code, creates a Node.js build environment, runs the build process, and packages just the built files into a minimal nginx container. Each stage is a named variable you can inspect, modify, or reuse - the state is explicit, not hidden in layers of a Dockerfile or build cache.</p><p>Get a dev build of Dagger, fresh from our repository:</p><div><div><div><div><div><div><pre translate="no"><code>container |
  from golang:latest |
  with-directory /src <span>$(git https://github.com/dagger/dagger | head | tree)</span> |
  with-workdir /src |
  with-exec go build ./cmd/dagger |
  file ./dagger |
  <span>export</span>

</code></pre></div></div></div></div></div></div><p><img alt="" height="344" src="https://framerusercontent.com/images/txHfsn8szyA0OoDpVR9d1ozuRN4.gif" srcset="https://framerusercontent.com/images/txHfsn8szyA0OoDpVR9d1ozuRN4.gif?scale-down-to=512 512w,https://framerusercontent.com/images/txHfsn8szyA0OoDpVR9d1ozuRN4.gif?scale-down-to=1024 1024w,https://framerusercontent.com/images/txHfsn8szyA0OoDpVR9d1ozuRN4.gif 1500w" width="750" data-framer-original-sizes="" sizes="(min-width: 1200px) 100vw, (min-width: 768px) and (max-width: 1199px) 100vw, (max-width: 767px) 100vw"/></p><h4>What’s Next?</h4><p>We’d love for you to try out Dagger Shell and share your feedback. Learn more in the <!--$--><a href="https://docs.dagger.io/features/shell" target="_blank" rel="noopener">Dagger Shell documentation</a><!--/$-->, join our<!--$--><a href="https://discord.com/channels/707636530424053791/1318344234511892490" rel="noopener"> Discord</a><!--/$--> and let us know how Dagger Shell improves your development workflow!</p><p>Happy hacking! 🚀</p></div></div></div></div>
  </body>
</html>
