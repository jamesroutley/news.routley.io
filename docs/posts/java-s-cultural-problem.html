<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://alexn.org/blog/2022/09/19/java-cultural-problem/">Original</a>
    <h1>Java&#39;s Cultural Problem</h1>
    
    <div id="readability-page-1" class="page"><div id="content" itemprop="articleBody">
<p>
Java is good by modern standards, from a technical perspective, the platform having received a lot of improvements from Java 8 to 17. Unfortunately, it still stinks, and the problem is its &#34;enterprise&#34; culture.
</p>
<p>Let me illustrate the problem via examples ‚Ä¶</p>
<p><a href="https://quarkus.io/">Quarkus</a> is a very promising framework, being a lightweight replacement for Spring, promising compatibility with <a href="https://www.graalvm.org/reference-manual/native-image/">GraalVM‚Äôs Native Image</a>. Full of hope, I enthusiastically opened its documentation, and started with <a href="https://quarkus.io/guides/config">how to configure an app</a>, expecting something with common sense, like <a href="https://www.dropwizard.io/en/latest/getting-started.html#creating-a-configuration-class">Dropwizard‚Äôs quick-start guide</a>.</p>
<p>Quarkus depends on <a href="https://github.com/smallrye/smallrye-config">SmallRye Config</a>. And if you want to map your configuration to objects, <a href="https://quarkus.io/guides/config-mappings">the documentation</a> has this to say:</p>
<div><div><pre><code><span>@ConfigMapping</span><span>(</span><span>prefix</span> <span>=</span> <span>&#34;server&#34;</span><span>)</span>
<span>interface</span> <span>ServerConfig</span> <span>{</span>
  <span>String</span> <span>host</span><span>();</span>

  <span>int</span> <span>port</span><span>();</span>
<span>}</span>
</code></pre></div></div>
<p>In Java‚Äôs world, interfaces and abstract classes get used by dependency injection libraries, with methods left abstract in order for their implementation to be filled-in later. Any <a href="https://alexn.org/blog/2017/10/15/functional-programming/">FP developer</a> should scream when seeing this, because:</p>
<ol>
<li>This should be a pure data structure;</li>
<li>These abstract methods signal the possibility of side effects ‚Äî in general, it is the possibility of side effects that drives the demand for abstract methods, as pure data structures rarely need it;</li>
</ol>
<p>Do you know what the library does in this instance? I sure don‚Äôt. It could be reading from a file and block a thread on every access, it could be thread unsafe, I wouldn‚Äôt know, since whatever it does is magic‚Ñ¢Ô∏è, and this isn‚Äôt my data structure. Even if it generates a pure data structure, for all I know its implementation can always change in future versions to also launch rockets to Mars.</p>
<p>Since Java 14 we have <a href="https://docs.oracle.com/en/java/javase/14/language/records.html">records</a>. The more common-sense definition doesn‚Äôt work, the library being (currently) unable to work with it:</p>
<div><div><pre><code><span>//</span>
<span>// java.lang.IllegalStateException: SRCFG00043: </span>
<span>// The @ConfigMapping annotation can only be placed in interfaces...</span>
<span>// </span>
<span>@ConfigMapping</span><span>(</span><span>prefix</span> <span>=</span> <span>&#34;server&#34;</span><span>)</span>
<span>final</span> <span>record</span> <span>ServerConfig</span><span>(</span>
  <span>String</span> <span>host</span><span>,</span>
  <span>int</span> <span>port</span><span>,</span>
<span>)</span> <span>{}</span>
</code></pre></div></div>
<p>And frankly, I‚Äôd like to also be able to test the deserialization of the application‚Äôs configuration, to ensure that all required values are there, which is why I‚Äôd start with a plain function:</p>
<div><div><pre><code><span>ServerConfig</span> <span>readServerConfig</span><span>(</span><span>ConfigSource</span> <span>src</span><span>)</span> <span>{</span> <span>/*...*/</span> <span>}</span>
</code></pre></div></div>
<p>Dropwizard has a more common-sense approach, as it leaves you in charge of defining a type safe configuration object. But it, too, was infected by the Java EE culture (aka <a href="https://en.wikipedia.org/wiki/Jakarta_EE">Jakarta EE</a>), preferring <a href="https://beanvalidation.org/">Bean Validation via annotations</a>, with the help of <a href="https://hibernate.org/validator/">hibernate-validator</a>.</p>
<div><div><pre><code><span>public</span> <span>record</span> <span>ServerConfig</span><span>(</span>
  <span>@NotNull</span> <span>@NotEmpty</span>
  <span>String</span> <span>host</span><span>,</span>
  <span>@NotNull</span>
  <span>Integer</span> <span>port</span><span>,</span>
  <span>@NotNull</span> <span>@Email</span>
  <span>String</span> <span>noReplyEmailAddress</span>
<span>)</span> <span>{}</span>
</code></pre></div></div>
<p>I understand the <code>@NotNull</code> annotation. Java has <code>null</code> in it, all object references can be <code>null</code>, and it‚Äôs too late for that to change. What‚Äôs odd is that <code>noReplyEmailAddress</code> should always be an email address, no matter the context. Not even if you consider this ‚Äúraw input‚Äù, because actual ‚Äúraw input‚Äù is a plain string or an array of bytes, and if you ever reach this stage of having a structured <code>record</code>, then you should already have an email address.</p>
<p>Java‚Äôs culture eschews common sense approaches, like defining new types. Defining new types would <a href="https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/">make illegal states unrepresentable</a>. Note how, with the following definition, there is no way to get an <code>EmailAddress</code> that doesn‚Äôt pass the ‚Äúvalidation‚Äù, and you don‚Äôt need a freaking annotations-driven library to validate your email address:</p>
<div><div><pre><code><span>import</span> <span>java.util.Objects</span><span>;</span>

<span>public</span> <span>record</span> <span>EmailAddress</span><span>(</span><span>String</span> <span>value</span><span>)</span> <span>{</span>
  <span>public</span> <span>EmailAddress</span> <span>{</span>
    <span>// We could&#39;ve used an Either data type, ofc;</span>
    <span>Objects</span><span>.</span><span>requireNonNull</span><span>(</span><span>value</span><span>);</span>
    <span>// regexp could be better</span>
    <span>if</span> <span>(!</span><span>value</span><span>.</span><span>matches</span><span>(</span><span>&#34;^[^@\\s]+@\\S+$&#34;</span><span>))</span> 
      <span>throw</span> <span>new</span> <span>IllegalArgumentException</span><span>(</span>
        <span>String</span><span>.</span><span>format</span><span>(</span><span>&#34;&#39;%s&#39; is not a valid email address&#34;</span><span>,</span> <span>value</span><span>));</span>
  <span>}</span>
<span>}</span>
</code></pre></div></div>
<p>Back to Quarkus, dependency injection (via CDI) is required, and it‚Äôs not easy to keep the Java EE crap out of your classes. Reading <a href="https://quarkus.io/guides/cdi-reference">their documentation</a>, by default you‚Äôd end up with something like this:</p>
<div><div><pre><code><span>@ConfigMapping</span><span>(</span><span>prefix</span> <span>=</span> <span>&#34;greetings&#34;</span><span>)</span>
<span>public</span> <span>interface</span> <span>GreetingServiceConfig</span> <span>{</span>
  <span>String</span> <span>name</span><span>();</span>
<span>}</span>

<span>// Not a final class</span>
<span>@RequestScoped</span>
<span>public</span> <span>class</span> <span>GreetingService</span> <span>{</span>
  <span>// Abstract, and it cannot be private üò±</span>
  <span>@Inject</span>
  <span>GreetingServiceConfig</span> <span>config</span><span>;</span>

  <span>public</span> <span>String</span> <span>greeting</span><span>()</span> <span>{</span>
    <span>return</span> <span>&#34;Hello, &#34;</span> <span>+</span> <span>name</span> <span>+</span> <span>&#34;!&#34;</span><span>;</span>
  <span>}</span>

  <span>// @PreDestroy is required for &#34;closeable&#34; resources; </span>
  <span>// I would have expected the framework to work with AutoCloseable, </span>
  <span>// but ALAS it doesn&#39;t;</span>
  <span>@PreDestroy</span>
  <span>public</span> <span>void</span> <span>close</span><span>()</span> <span>{</span>
    <span>LoggerFactory</span><span>.</span><span>getLogger</span><span>(</span><span>getClass</span><span>).</span><span>info</span><span>(</span><span>&#34;Destroying GreetingService!&#34;</span><span>);</span>
  <span>}</span>
<span>}</span>
</code></pre></div></div>
<p>In the sample above, adding a scope (e.g., <code>@RequestScoped</code>) makes the framework automatically initialize this ‚Äúbean‚Äù when needed. And <code>@PreDestroy</code> marks methods that have to be called when the ‚Äúbean‚Äù is disposed. Note that my ‚Äúbean‚Äù should implement <code>Closeable</code>, but the framework completely ignores it, this being another instance in which a Java EE implementation ignores the Java language. You need that <code>@PreDestroy</code>, or otherwise you‚Äôll have a leak.</p>
<p>Of note is how this approach will infect your entire codebase, forcing all your downstream users to forgo Java language constructs, such as easily building an instance with <code>new</code>, or safe disposal of resources via <a href="https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html">try-with-resources</a>.</p>
<p>With this approach, not working with <code>final</code> classes jumps at me, because <a href="https://www.artima.com/articles/versioning-virtual-and-override">‚Äúfinal‚Äù is a best practice</a>. This isn‚Äôt related to Quarkus in any way, this being the status quo in Java land. For instance, Kotlin‚Äôs classes are <a href="https://kotlinlang.org/docs/inheritance.html">final by default</a>, yet if you want to <a href="https://kotlinlang.org/docs/jvm-spring-boot-restful.html">build Spring apps</a>, the recommended way would be to import the <a href="https://kotlinlang.org/docs/all-open-plugin.html#spring-support">kotling-spring</a> plugin, which automatically ‚Äúopens‚Äù your classes that have certain DI-related annotations. Whether you agree with ‚Äúfinal by default‚Äù as a best practice or not, you‚Äôre getting a bad deal if the framework makes that choice for you.</p>
<p>Quarkus ships with a <a href="https://jakarta.ee/specifications/cdi/2.0/cdi-spec-2.0.html">CDI 2.0</a> implementation, like Spring before it, although <a href="https://quarkus.io/guides/cdi-reference">its implementation</a> isn‚Äôt fully compliant, since all those annotations and runtime behavior can‚Äôt be fully supported on top of GraalVM‚Äôs Native Image. It‚Äôs odd seeing such a framework forcing Java EE‚Äôs CDI.</p>
<p>Quarkus makes it hard to have a common-sense <a href="https://blog.ploeh.dk/2011/07/28/CompositionRoot/">composition root</a>. Thankfully, I discovered how, via trial and error, meaning half-baked Stack Overflow answers and using the right keywords to appease the search gods. One of these days I‚Äôll find out what the heck is a ‚Äúbean‚Äù.</p>
<div><div><pre><code><span>// ------------------------------------------------</span>
<span>// No Java EE crap</span>
<span>public</span> <span>record</span> <span>GreetingServiceConfig</span><span>(</span><span>String</span> <span>name</span><span>)</span> <span>{}</span>

<span>// ------------------------------------------------</span>
<span>// No Java EE crap</span>
<span>public</span> <span>final</span> <span>class</span> <span>GreetingService</span> <span>implements</span> <span>Closeable</span> <span>{</span>
  <span>private</span> <span>final</span> <span>GreetingServiceConfig</span> <span>config</span><span>;</span>

  <span>public</span> <span>GreetingService</span><span>(</span><span>GreetingServiceConfig</span> <span>cfg</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span><span>config</span> <span>=</span> <span>cfg</span><span>;</span>
  <span>}</span>

  <span>public</span> <span>String</span> <span>greeting</span><span>()</span> <span>{</span>
    <span>return</span> <span>&#34;Hello, &#34;</span> <span>+</span> <span>config</span><span>.</span><span>name</span><span>()</span> <span>+</span> <span>&#34;!&#34;</span><span>;</span>
  <span>}</span>

  <span>@Override</span>
  <span>public</span> <span>void</span> <span>close</span><span>()</span> <span>{</span>
    <span>LoggerFactory</span><span>.</span><span>getLogger</span><span>(</span><span>getClass</span><span>()).</span><span>info</span><span>(</span><span>&#34;Destroying GreetingService!&#34;</span><span>);</span>
  <span>}</span>
<span>}</span>

<span>// ------------------------------------------------</span>
<span>// Implements the &#34;composition root&#34; pattern...</span>
<span>//</span>
<span>// (all of these imports is already a code smell)</span>
<span>import</span> <span>javax.enterprise.context.RequestScoped</span><span>;</span>
<span>import</span> <span>javax.enterprise.inject.Disposes</span><span>;</span>
<span>import</span> <span>javax.ws.rs.Produces</span><span>;</span>
<span>import</span> <span>javax.enterprise.context.ApplicationScoped</span><span>;</span>
<span>import</span> <span>javax.enterprise.context.RequestScoped</span><span>;</span>
<span>import</span> <span>javax.enterprise.inject.Disposes</span><span>;</span>
<span>import</span> <span>javax.ws.rs.Produces</span><span>;</span>

<span>public</span> <span>class</span> <span>AppConfiguration</span> <span>{</span>
  <span>@Produces</span>
  <span>@ApplicationScoped</span>
  <span>public</span> <span>GreetingServiceConfig</span> <span>gsConfig</span><span>()</span> <span>{</span>
    <span>return</span> <span>new</span> <span>GreetingServiceConfig</span><span>(</span>
      <span>ConfigProvider</span><span>.</span><span>getConfig</span><span>().</span><span>getValue</span><span>(</span><span>&#34;greetings.name&#34;</span><span>,</span> <span>String</span><span>.</span><span>class</span><span>)</span>
    <span>);</span>
  <span>}</span>

  <span>@Produces</span>
  <span>@RequestScoped</span>
  <span>public</span> <span>GreetingService</span> <span>greetingService</span><span>(</span><span>GreetingServiceConfig</span> <span>config</span><span>)</span> <span>{</span>
    <span>return</span> <span>new</span> <span>GreetingService</span><span>(</span><span>config</span><span>);</span>
  <span>}</span>

  <span>// Closeable resource needs to be destroyed, and </span>
  <span>// framework won&#39;t do it automatically;</span>
  <span>void</span> <span>disposesGreetingService</span><span>(</span><span>@Disposes</span> <span>GreetingService</span> <span>ref</span><span>)</span> <span>{</span>
    <span>ref</span><span>.</span><span>close</span><span>();</span>
  <span>}</span>
<span>}</span>
</code></pre></div></div>
<p>At least this way you can limit the impact of Java EE on your codebase. But it does need restraint, and you still have to learn a domain-specific language that has few things in common with Java, the language.</p>
<p>Newcomers to Java have to deal with this nonsense, and it‚Äôs a pity given that Java 17 is a decent language and awesome platform. Java‚Äôs ecosystem still hasn‚Äôt learned enough from its competition.</p>
</div></div>
  </body>
</html>
