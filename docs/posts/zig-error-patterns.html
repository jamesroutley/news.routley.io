<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://glfmn.io/posts/zig-error-patterns/">Original</a>
    <h1>Zig Error Patterns</h1>
    
    <div id="readability-page-1" class="page"><section>
<h2 id="introduction">Introduction</h2>
<p>Although I try to make good use of the debugger, I am quite used to print-based
debugging, especially for unit tests. I wanted to explore some tricks to improve
print-based debugging, and also incorporate the debugger more.</p>
<h2 id="print-based-debugging-improved">print-based debugging improved</h2>
<p>One big problem with using print debugging is spammy output. If I am
running something in a loop, and only one iteration of the loop has anything
interesting, I still need to filter and sort through every iteration&#39;s output.</p>
<p>Or perhaps I am working with some data structure that has a printable
representation that is easier to parse than the raw data; if I don&#39;t know where
the error comes from I would have to litter print functions everywhere hoping to
catch the necessary context.</p>
<p>However, I realized that since zig tests use <code>error</code>s, instead of panics, it is
possible to use <code>errdefer</code> to print something only when a test actually fails.</p>
<pre data-lang="zig"><code data-lang="zig"><span><span>test</span> <span>{</span>
</span><span>    <span>errdefer</span> std.debug.<span>print</span><span>(</span><span>&#34;{f}&#34;</span><span>,</span> .<span>{</span>ast<span>}</span><span>)</span><span>;</span>
</span><span>    </span><span><span>}</span>
</span></code></pre>
<p>Does a fantastic job of avoiding cluttering the code, and providing the precise
context necessary when an error actually occurs.</p>
<h2 id="running-tests-in-the-debugger">Running tests in the debugger</h2>
<p>If anything more complex is necessary, using the debugger is the way to go.
However, naively trying to run <code>seergdb</code> or <code>gdb -tui</code> directly from the
terminal gets difficult, as the test binaries are not in <code>zig-out</code> directory
(understandably) but in the <code>zig-cache</code> directory.</p>
<p>I learned a trick from <a href="https://ziggit.dev/t/zig-debugging-with-lldb/3931/7?u=glfmn">ziggit</a> that the <code>build.zig</code> can run
commands, and you can feed the artifact path of a build step as an argument into
the command:</p>
<figure>
  <figcaption><cite>build.zig</cite></figcaption>
  <pre data-lang="zig"><code data-lang="zig"><span></span><span><span>const</span> debugger <span>=</span> b.<span>addSystemCommand</span><span>(</span>&amp;.<span>{</span> <span>&#34;seergdb&#34;</span><span>,</span> <span>&#34;--run&#34;</span><span>,</span> <span>&#34;--&#34;</span> <span>}</span><span>)</span><span>;</span>
</span><span>debugger.<span>addArtifactArg</span><span>(</span>exe_unit_tests<span>)</span><span>;</span>
</span><span>
</span><span><span>const</span> debug_step <span>=</span> b.<span>step</span><span>(</span><span>&#34;debug&#34;</span><span>,</span> <span>&#34;Run unit tests under debugger&#34;</span><span>)</span><span>;</span>
</span><span>debug_step.<span>dependOn</span><span>(</span><span>&amp;</span>debugger.step<span>)</span><span>;</span>
</span></code></pre>
</figure>
<p>This makes it really easy to run the proper binary; however, this isn&#39;t enough
on its own: the debugger only kicks into action for a breakpoint or panic, but
the test runner gracefully handles errors.</p>
<p>We can get around this by adding <code>@breakpoint</code> calls, but then we are
potentially back to square one, where we have to speculatively add breakpoints
and catch the precise moment where things fail, or have to manually step through
until failure.</p>
<h2 id="combining-tricks">Combining tricks</h2>
<p>Of course, a good solution is to use:</p>
<pre data-lang="zig"><code data-lang="zig"><span><span>test</span> <span>{</span>
</span><span>    <span>errdefer</span> <span>@breakpoint</span><span>(</span><span>)</span><span>;</span>
</span><span><span>}</span>
</span></code></pre>
<p>This will break the program at the precise moment we hit an error. There&#39;s a
chance enough context is still around to snoop at with the debugger, and we
would also have the debug printing that the <code>std.testing.expect{.*}</code> functions
provide.</p>
<p>However, this does have downsides. Consider the program:</p>
<pre data-lang="zig"><code data-lang="zig"><span><span>test</span> <span>&#34;errdefer @breakpoint()&#34;</span> <span>{</span>
</span><span>    <span>errdefer</span> <span>@breakpoint</span><span>(</span><span>)</span><span>;</span>
</span><span>    <span>return</span> <span>error</span><span>.</span><span>FixMe</span><span>;</span>
</span><span><span>}</span>
</span><span>
</span><span><span>test</span> <span>&#34;normal test&#34;</span> <span>{</span>
</span><span>    <span>return</span> <span>error</span><span>.</span><span>FixMe</span><span>;</span>
</span><span><span>}</span>
</span></code></pre>
<p>If we run <code>zig build test</code>, instead of reporting individual test errors, the
summary will just report that the entire test <em>step</em> failed:</p>
<pre><code><span>error: while executing test &#39;main.test.@&#34;errdefer @breakpoint()&#34;&#39;,
</span><span>the following command terminated with signal 5 (expected exited with code 0):
</span><span>
</span><span>  ./.zig-cache/o/348ca1907303b41ca8e0fceafd43ad63/test \
</span><span>    --cache-dir=./.zig-cache \
</span><span>    --seed=0xe3f1cf05 --listen=-
</span></code></pre>
<p>If we still want to preserve the normal behavior except when we actually <em>want</em>
to break for a debugger, then we need one more trick.</p>
<h2 id="conditional-compilation">Conditional compilation</h2>
<p>The Zig build system allows us use
<a href="https://ziglang.org/learn/build-system/#conditional-compilation">build options to pass compile time values</a> to our program. We
can leverage these to pass a <code>bool</code> to decide when to call <code>@breakpoint</code> in
our tests.</p>
<p>Starting from a simple build script that only runs tests:</p>
<figure>
  <figcaption><cite>build.zig</cite></figcaption>
  <pre data-linenos="" data-lang="zig"><code data-lang="zig"><table><tbody><tr><td>1</td><td><span><span>const</span> std <span>=</span> <span>@import</span><span>(</span><span>&#34;std&#34;</span><span>)</span><span>;</span>
</span></td></tr><tr><td>2</td><td><span>
</span></td></tr><tr><td>3</td><td><span><span>pub</span> <span>fn</span> <span>build</span><span>(</span><span>b</span><span>:</span> <span>*</span><span>std.Build</span><span>)</span> <span>void</span> <span>{</span>
</span></td></tr><tr><td>4</td><td><span>    <span>const</span> target <span>=</span> b.<span>standardTargetOptions</span><span>(</span>.<span>{</span><span>}</span><span>)</span><span>;</span>
</span></td></tr><tr><td>5</td><td><span>    <span>const</span> optimize <span>=</span> b.<span>standardOptimizeOption</span><span>(</span>.<span>{</span><span>}</span><span>)</span><span>;</span>
</span></td></tr><tr><td>6</td><td><span>
</span></td></tr><tr><td>7</td><td><span>    <span>const</span> lib <span>=</span> b.<span>addModule</span><span>(</span><span>&#34;zig-test-patterns&#34;</span><span>,</span> .<span>{</span>
</span></td></tr><tr><td>8</td><td><span>        .root_source_file <span>=</span> b.<span>path</span><span>(</span><span>&#34;src/root.zig&#34;</span><span>)</span><span>,</span>
</span></td></tr><tr><td>9</td><td><span>        .target <span>=</span> target<span>,</span>
</span></td></tr><tr><td>10</td><td><span>        .optimize <span>=</span> optimize<span>,</span>
</span></td></tr><tr><td>11</td><td><span>    <span>}</span><span>)</span><span>;</span>
</span></td></tr><tr><td>12</td><td><span>
</span></td></tr><tr><td>13</td><td><span>    <span>const</span> mod_tests <span>=</span> b.<span>addTest</span><span>(</span>.<span>{</span>
</span></td></tr><tr><td>14</td><td><span>        .root_module <span>=</span> lib<span>,</span>
</span></td></tr><tr><td>15</td><td><span>    <span>}</span><span>)</span><span>;</span>
</span></td></tr><tr><td>16</td><td><span>
</span></td></tr><tr><td>17</td><td><span>    <span>const</span> run_mod_tests <span>=</span> b.<span>addRunArtifact</span><span>(</span>mod_tests<span>)</span><span>;</span>
</span></td></tr><tr><td>18</td><td><span>
</span></td></tr><tr><td>19</td><td><span>    <span>const</span> test_step <span>=</span> b.<span>step</span><span>(</span><span>&#34;test&#34;</span><span>,</span> <span>&#34;Run tests&#34;</span><span>)</span><span>;</span>
</span></td></tr><tr><td>20</td><td><span>    test_step.<span>dependOn</span><span>(</span><span>&amp;</span>run_mod_tests.step<span>)</span><span>;</span>
</span></td></tr><tr><td>21</td><td><span><span>}</span>
</span></td></tr></tbody></table></code></pre>
</figure>
<p>We can add the compile time option like so:</p>
<figure>
  <figcaption><cite>build.zig</cite></figcaption>
  <pre data-linenos="" data-lang="zig"><code data-lang="zig"><table><tbody><tr><td>4</td><td><span><span>const</span> options <span>=</span> b.<span>addOptions</span><span>(</span><span>)</span><span>;</span>
</span></td></tr><tr><td>5</td><td><span>options.<span>addOption</span><span>(</span>bool<span>,</span> <span>&#34;debugger&#34;</span><span>,</span> <span>false</span><span>)</span><span>;</span>
</span></td></tr></tbody></table></code></pre>
</figure>
<p>We need to add the generated options module to our lib:</p>
<figure>
  <figcaption><cite>build.zig</cite></figcaption>
  <pre data-linenos="" data-lang="zig"><code data-lang="zig"><table><tbody><tr><td>16</td><td><span>lib.<span>addImport</span><span>(</span><span>&#34;config&#34;</span><span>,</span> options.<span>createModule</span><span>(</span><span>)</span><span>)</span><span>;</span>
</span></td></tr></tbody></table></code></pre>
</figure>
<p>Then, in our <code>root.zig</code> file we can reference the options like so:</p>
<figure>
  <figcaption><cite>root.zig</cite></figcaption>
  <pre data-linenos="" data-lang="zig"><code data-lang="zig"><table><tbody><tr><td>1</td><td><span><span>const</span> std <span>=</span> <span>@import</span><span>(</span><span>&#34;std&#34;</span><span>)</span><span>;</span>
</span></td></tr><tr><td>2</td><td><span><span>const</span> config <span>=</span> <span>@import</span><span>(</span><span>&#34;config&#34;</span><span>)</span><span>;</span>
</span></td></tr><tr><td>3</td><td><span>
</span></td></tr><tr><td>4</td><td><span><span>test</span> <span>&#34;errdefer @breakpoint()&#34;</span> <span>{</span>
</span></td></tr><tr><td>5</td><td><span>    <span>errdefer</span> <span>if</span> <span>(</span>config.debugger<span>)</span> <span>@breakpoint</span><span>(</span><span>)</span><span>;</span>
</span></td></tr><tr><td>6</td><td><span>
</span></td></tr><tr><td>7</td><td><span>    <span>return</span> <span>error</span><span>.</span><span>FixMe</span><span>;</span>
</span></td></tr><tr><td>8</td><td><span><span>}</span>
</span></td></tr><tr><td>9</td><td><span>
</span></td></tr><tr><td>10</td><td><span><span>test</span> <span>&#34;no breakpoint&#34;</span> <span>{</span>
</span></td></tr><tr><td>11</td><td><span>    <span>return</span> <span>error</span><span>.</span><span>FixMe</span><span>;</span>
</span></td></tr><tr><td>12</td><td><span><span>}</span>
</span></td></tr></tbody></table></code></pre>
</figure>
<p>Now, we can run the test and get no breakpoint:</p>
<pre><code><span>zig build test
</span></code></pre>
<p>However, we run into a snag: this value is observable to our program, but
we have to recompile the <code>build.zig</code> in order to change the value. We need
to add the option to the build system itself:</p>
<figure>
  <figcaption><cite>build.zig</cite></figcaption>
  <pre data-linenos="" data-lang="zig"><code data-lang="zig"><table><tbody><tr><td>4</td><td><span><span>var</span> options <span>=</span> b.<span>addOptions</span><span>(</span><span>)</span><span>;</span>
</span></td></tr><tr><td>5</td><td><span><span>const</span> use_debugger <span>=</span> b.<span>option</span><span>(</span>
</span></td></tr><tr><td>6</td><td><span>    bool<span>,</span>
</span></td></tr><tr><td>7</td><td><span>    <span>&#34;debugger&#34;</span><span>,</span>
</span></td></tr><tr><td>8</td><td><span>    <span>&#34;Enables code intended to only run under a debugger&#34;</span><span>,</span>
</span></td></tr><tr><td>9</td><td><span><span>)</span> <span>orelse</span> <span>false</span><span>;</span>
</span></td></tr><tr><td>10</td><td><span>options.<span>addOption</span><span>(</span>bool<span>,</span> <span>&#34;debugger&#34;</span><span>,</span> use_debugger<span>)</span><span>;</span>
</span></td></tr></tbody></table></code></pre>
</figure>
<p>Now we can run:</p>
<pre><code><span>zig build -Ddebugger test
</span></code></pre>
<p>And observe the change in behavior.</p>
<p>As a final step, we can hook up the command to run our debugger when
the <code>use_debugger</code> flag is set like so:</p>
<figure>
  <figcaption><cite>build.zig</cite></figcaption>
  <pre data-linenos="" data-lang="zig"><code data-lang="zig"><table><tbody><tr><td>29</td><td><span><span>const</span> test_step <span>=</span> b.<span>step</span><span>(</span><span>&#34;test&#34;</span><span>,</span> <span>&#34;Run tests&#34;</span><span>)</span><span>;</span>
</span></td></tr><tr><td>30</td><td><span><span>if</span> <span>(</span>use_debugger<span>)</span> <span>{</span>
</span></td></tr><tr><td>31</td><td><span>    <span>const</span> debugger <span>=</span> b.<span>addSystemCommand</span><span>(</span>&amp;.<span>{</span> <span>&#34;seergdb&#34;</span><span>,</span> <span>&#34;--run&#34;</span><span>,</span> <span>&#34;--&#34;</span> <span>}</span><span>)</span><span>;</span>
</span></td></tr><tr><td>32</td><td><span>    debugger.<span>addArtifactArg</span><span>(</span>mod_tests<span>)</span><span>;</span>
</span></td></tr><tr><td>33</td><td><span>
</span></td></tr><tr><td>34</td><td><span>    test_step.<span>dependOn</span><span>(</span><span>&amp;</span>debugger.step<span>)</span><span>;</span>
</span></td></tr><tr><td>35</td><td><span><span>}</span> <span>else</span> <span>{</span>
</span></td></tr><tr><td>36</td><td><span>    test_step.<span>dependOn</span><span>(</span><span>&amp;</span>run_mod_tests.step<span>)</span><span>;</span>
</span></td></tr><tr><td>37</td><td><span><span>}</span>
</span></td></tr></tbody></table></code></pre>
</figure>
<p>Now, if we run with the <code>-Ddebugger</code> flag, the test runner will automatically
run in the debugger, and will break on error! See a screenshot <a href="https://glfmn.io/posts/zig-error-patterns/./seergdb.png">here</a>.</p>
<p>It might be nice to encapsulate the config option checking in a function:</p>
<pre data-lang="zig"><code data-lang="zig"><span><span>fn</span> <span>breakForDebugger</span><span>(</span><span>)</span> <span>void</span> <span>{</span>
</span><span>    <span>if</span> <span>(</span>config.debugger<span>)</span> <span>@breakpoint</span><span>(</span><span>)</span><span>;</span>
</span><span><span>}</span>
</span></code></pre>
<p>But I leave that up to your judgement.</p>
<h2 id="zig-version">Zig Version</h2>
<p>This guide was written with Zig version:</p>
<pre><code><span>0.15.0-dev.1184+c41ac8f19
</span></code></pre>
<p>Also, special thanks to <a href="https://ziggit.dev/u/alanza/">Alanza</a> for reading an early draft of this article.</p>

</section></div>
  </body>
</html>
