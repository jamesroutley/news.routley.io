<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.tuned.org.uk/posts/013_the_topological_transformer_training_tauformer">Original</a>
    <h1>Starting from scratch: Training a 30M Topological Transformer</h1>
    
    <div id="readability-page-1" class="page"><div>
        

<p>Tauformer is a <strong>topological transformer</strong> (see <a href="https://www.techrxiv.org/users/685780/articles/1375955-topological-transformer-a-redesign-for-domain-memory-and-cheaper-kernel-operations">paper</a>) that replaces dot‑product attention with a Laplacian-derived scalar (taumode) per token/head, then attends using distances in that scalar space.
Below is a post-style overview of the idea and the first training signals from a 30M-parameter run.</p>

<h2 id="tauformer-in-one-idea">Tauformer in one idea</h2>

<p>Tauformer’s goal is to inject <strong>domain structure</strong> directly into attention by using a Graph Laplacian built from a domain embedding space (a “domain memory”) as a persistent reference.
Instead of ranking keys by \(Q\cdot K\), Tauformer ranks them by how similar their Laplacian-derived taumode scalars are, which is intended to bias attention toward domain-relevant relations rather than generic geometric similarity.</p>

<p>At the implementation level, Tauformer keeps the familiar Q/K/V projections, RoPE, causal masking, and stable softmax/value aggregation pipeline, but changes how attention logits are computed.
Each head vector is compressed into a scalar \(\lambda\) using a bounded Rayleigh-quotient energy computed with a feature-space Laplacian \(L\), then logits are computed as a negative distance \(-|\lambda_q-\lambda_k|/\text{temperature}\).</p>

<p>Key building blocks (as implemented):</p>

<ul>
  <li>Taumode scalar: compute \(E_{\text{raw}}=(x^\top L x)/(x^\top x+\varepsilon)\), then bound it as \(E_{\text{raw}}/(E_{\text{raw}}+\tau)\) to produce \(\lambda\in[0,1)\).</li>
  <li>Logits: \(\text{att}_{ij} = -\|\lambda^Q_i - \lambda^K_j\|/\text{temperature}\), then reuse causal mask \(→\) subtract row max \(→\) softmax \(→\) multiply by \(V\).</li>
</ul>

<h2 id="why-it-can-be-cheaper">Why it can be cheaper</h2>

<p>Because scoring no longer needs full key vectors, Tauformer’s KV-cache can store values plus a compact key-side scalar stream rather than both K and V tensors.
Concretely, the cache payload is \((V,\lambda_k)\) (not \((K,V)\)), which yields an approximate ~50% per-layer cache reduction for typical head dimensions (small overhead for storing the extra scalar).</p>

<p>The design also anticipates using a sparse Laplacian from a precomputed domain manifold so computing \(\lambda\) can depend on Laplacian sparsity (nnz) rather than dense \(D^2\) multiplication. It exchanges the long preliminary adjustment of weights with a pre-training shorter phase in which a Laplacian is built using <code>arrowspace</code>.</p>

<h2 id="run-setup-what-was-trained">Run setup (what was trained)</h2>

<p>This run trains a 30M-class TauGPT.
Training uses AdamW with base LR \(5\times10^{-4}\) and a warmup of 100 steps, then keeps the base LR constant unless the plateau logic scales it down.
Data comes from a local JSONL file (<code>train.jsonl</code>) streamed through an IterableDataset, with a routed split where every 20th batch is used for validation (\(≈5%\)).</p>

<table>
  <thead>
    <tr>
      <th>Category</th>
      <th>Setting</th>
      <th>Value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Model</td>
      <td>Class / size</td>
      <td>TauGPT ~30M parameters  (GPT2-inspired)</td>
    </tr>
    <tr>
      <td>Model</td>
      <td>Layers (<code>n_layer</code>)</td>
      <td>6</td>
    </tr>
    <tr>
      <td>Model</td>
      <td>Heads (<code>n_head</code>)</td>
      <td>6</td>
    </tr>
    <tr>
      <td>Model</td>
      <td>Embedding size (<code>n_embd</code>)</td>
      <td>384</td>
    </tr>
    <tr>
      <td>Model</td>
      <td>Sequence length (<code>seq_len</code>)</td>
      <td>1024</td>
    </tr>
    <tr>
      <td>Model</td>
      <td>Vocabulary size (<code>vocab_size</code>)</td>
      <td>30522</td>
    </tr>
    <tr>
      <td>Optimizer</td>
      <td>Optimizer</td>
      <td>AdamW</td>
    </tr>
    <tr>
      <td>Optimizer</td>
      <td>Base learning rate</td>
      <td>5e-4</td>
    </tr>
    <tr>
      <td>LR schedule</td>
      <td>Warmup</td>
      <td>100 steps</td>
    </tr>
    <tr>
      <td>LR schedule</td>
      <td>Post-warmup behavior</td>
      <td>Constant LR (no decay unless manually/externally adjusted)</td>
    </tr>
    <tr>
      <td>Data</td>
      <td>Source file</td>
      <td>Local JSONL file <code>train.jsonl</code></td>
    </tr>
    <tr>
      <td>Data</td>
      <td>Loading mode</td>
      <td>Streamed via an IterableDataset-style pipeline (no shuffle in DataLoader)</td>
    </tr>
    <tr>
      <td>Validation</td>
      <td>Split rule</td>
      <td>Routed split where every 20th batch is used for validation</td>
    </tr>
    <tr>
      <td>Validation</td>
      <td>Approx. validation fraction</td>
      <td>About 5%</td>
    </tr>
  </tbody>
</table>

<h2 id="results-at-a-glance">Results at a glance</h2>

<p>At step 100 the run reports train loss 4.6772 and val loss 4.9255 (PPL 107.47), and by step 2000 it reaches val loss 2.3585 (Perplexity 6.59).
The best validation point in the log is step 4500 with <code>val_loss=1.9146</code>, after which validation regresses to <code>2.3746</code> by step 5000.
The final run summary records <code>step=5000</code>, <code>best_val_loss=1.914555</code>, <code>current_lr_scale=0.03125</code>, and <code>total_tokens=655360000</code>. That is a good result for \(~2\) hours of training on this smallest model (at an average of ~60K Tokens Per Second).</p>

<p>The early phase is strong: validation drops from 4.93 at step 100 to ~2.36 by step 2000, showing that the model and pipeline learn effectively at this scale.
After that, validation becomes noisy (e.g., rising back to 2.92 at step 2100 and peaking near 2.95 at step 4200) before the late “lucky break” to 1.91 at step 4500.
Throughout, the run holds a fixed taumode value which means the attention geometry is not being updated as weights evolve as this will be take place in the next iterations.</p>

<h2 id="baseline-closing-note">Baseline: Closing note</h2>

<p>All the model’s files, data, training settings and logs will be published with a permissive license once the results are consolidated and tests will move to a larger scale model.</p>

<p>This baseline run kept taumode fixed throughout, while using a simple validation loop and plateau-triggered LR scaling, and it still converged quickly in the early-to-mid training window.</p>

<p>Because the later part of the run shows volatility and regression after the best checkpoint, the next experiments focus on “adaptive” taumode strategies where taumode is recalibrated at intervals (including the “gradient” strategy that detects energy drift and gates recalibration by performance of the gradient in the previous steps) plus more sophisticated validation behaviors already implemented in the training loop.</p>

<p>Considering the small model size and the short training horizon (5,000 steps total, lowest loss at 4600), these results support the architecture as promising, with broader evaluation and scaled tests planned next—especially at 100M parameters.</p>

<p>A very interesting question has been raised by this test: <strong>what is the correlation between cross-entropy and taumode?</strong> Model convergence brings the loss down but at the same time recalibrating the taumode used on the learned weights brings down the taumode.</p>



<p>Cross-entropy and taumode are likely correlated because Tauformer’s attention kernel is built from Laplacian-derived scalar energies (λ/taumode) rather than dot-product similarity, so changes in the λ distribution change attention behavior and therefore training dynamics.
In the current training loop, the observed “taumode convergence” is also mechanically explained by how taumode is recalibrated: on (re)start, the code can compute a median energy from <strong>block0 key (K) vectors</strong> produced by the <em>current</em> weights and then set that median as the global taumode.</p>

<h2 id="what-converging-taumode-means-here">What “converging taumode” means here</h2>

<p>The calibration is effectively computing a Rayleigh-style energy statistic on K vectors under a Laplacian (numerator/denominator), and then taking a median over the batch to set a single scalar taumode.
In the reference implementation, taumode/λ is based on a bounded Rayleigh quotient: \(E_{\text{raw}}(x) = \frac{x^\top L x}{x^\top x + \varepsilon}\) and then \(\lambda_\tau(x)=\frac{E_{\text{raw}}}{E_{\text{raw}}+\tau}\), which maps energies into \([0,1)\).</p>

<h2 id="why-taumode-can-drift-downward-as-loss-improves">Why taumode can drift downward as loss improves</h2>

<ul>
  <li><strong>Healthy interpretation:</strong> as training progresses, the model may learn K representations that are “smoother” (lower-energy, so closer) with respect to the domain/manifold Laplacian, pushing the median energy down while also improving next-token prediction (lower cross-entropy).</li>
  <li><strong>Unhealthy interpretation (collapse risk):</strong> median energy can also drop if K vectors collapse toward low-variance or less-discriminative configurations, which can reduce contrast in λ-distance logits even if loss continues improving short-term.</li>
  <li><strong>Key confound:</strong> if taumode is recalibrated on resume, then taumode changes are not purely a passive “measurement of convergence”; they can act like a mid-training hyperparameter change, so correlation with loss does not automatically imply causality in the direction “lower taumode \(⇒\) lower loss”.</li>
</ul>

<p>A strong explanation for “converging taumode” (as a property of learned representations, not an artifact) is: as weights converge, the distribution of per-token energies \(x^\top L x\) stabilizes, so repeated measurements (median, p50) across batches and checkpoints become consistent and typically shift toward lower-energy manifold-aligned directions.
To validate that, it helps to separate (1) the fixed constant used by attention from (2) a purely diagnostic “current batch median energy”, and track not just the median but also the spread (p05/p95), because collapse would show shrinking spread even when the median looks lower.</p>

<p>“lower loss \(⇒\) lower taumode” is a plausible causal direction in Tauformer, because the cross-entropy gradient flows through the Tauformer attention path that depends on Laplacian-energy-derived scalars computed from Q/K (and in your calibration code, specifically from block0 K vectors). As the model improves next-token prediction, it can simultaneously learn representations whose Laplacian Rayleigh energy is lower, so any “recalibrate taumode from learned weights” procedure will tend to output a smaller median. If this it true, where is the optimal stopping state?</p>

<h2 id="further-readings">Further readings</h2>
<p>Some shift is happening in understanding information thanks to large scale learning machines!</p>

<p>In <a href="https://arxiv.org/pdf/2601.03220">this recent paper</a>, MDL refers to the “minimum description length principle”, which says the best explanation/model is the one that minimizes the total code length needed to describe (1) the model and (2) the data given the model.
<em>Epiplexity</em> \(ST(X)\) is defined as the program length of the compute-feasible model \(P\) that minimizes time-bounded MDL, while time-bounded entropy HT(X) is the expected code length of the data under that model.
Operationally, the paper proposes practical estimators based on neural-network training dynamics (e.g., prequential “area under the loss curve above final loss”) to approximate how much structure a bounded learner actually absorbs from data</p>

<p>Qualitatively, <code>arrowspace</code>, <code>taumode</code> and <code>tau-attention</code> are exactly the kind of deterministic computations that can increase usable/learnable structure for bounded learners, which is one of the central motivations for epiplexity.
Through the epiplexity lens, the operations carried on by <code>arrowspace</code> and Tauformer (converts each head vector into a bounded scalar λτ using a Rayleigh-quotient-style energy followed by a bounding map) is a deterministic compression that can re-factor information into a form that is cheaper for downstream computation to exploit, potentially increasing the amount of structure a bounded observer can learn from the same underlying signal.</p>

<p>I am happy I have somehow anticipated this switch in point of view in <code>arrowspace</code>.</p>

<h2 id="acknoledgements">Acknoledgements</h2>
<p>I gratefully acknowledge <a href="https://www.enverge.ai/enverge-labs">Enverge Labs</a> for kindly providing the computation time used to run these experiments on their H100 GPU cluster powered by clean and cheap energy, this aligns perfectly with the topological tranformer objective to provide cheaper computation for Transformers.</p>

    </div></div>
  </body>
</html>
