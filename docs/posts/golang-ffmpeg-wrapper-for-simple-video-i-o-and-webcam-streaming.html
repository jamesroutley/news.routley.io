<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/AlexEidt/Vidio">Original</a>
    <h1>Show HN: Golang FFmpeg wrapper for simple Video I/O and Webcam Streaming</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
            <article itemprop="text">
<p dir="auto">A simple Video I/O library written in Go. This library relies on <a href="https://www.ffmpeg.org/" rel="nofollow">FFmpeg</a>, and <a href="https://www.ffmpeg.org/" rel="nofollow">FFProbe</a> which must be downloaded before usage and added to the system path.</p>
<p dir="auto">All frames are encoded and decoded in 8-bit RGB format.</p>
<h2 dir="auto"><a id="user-content-installation" aria-hidden="true" href="#installation"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Installation</h2>
<div data-snippet-clipboard-copy-content="go get github.com/AlexEidt/Vidio"><pre><code>go get github.com/AlexEidt/Vidio
</code></pre></div>
<h2 dir="auto"><a id="user-content-video" aria-hidden="true" href="#video"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><code>Video</code></h2>
<p dir="auto">The <code>Video</code> struct stores data about a video file you give it. The code below shows an example of sequentially reading the frames of the given video.</p>
<div data-snippet-clipboard-copy-content="FileName() string
Width() int
Height() int
Depth() int
Bitrate() int
Frames() int
Duration() float64
FPS() float64
Codec() string
AudioCodec() string
FrameBuffer() []byte"><pre><span>FileName</span>() <span>string</span>
<span>Width</span>() <span>int</span>
<span>Height</span>() <span>int</span>
<span>Depth</span>() <span>int</span>
<span>Bitrate</span>() <span>int</span>
<span>Frames</span>() <span>int</span>
<span>Duration</span>() <span>float64</span>
<span>FPS</span>() <span>float64</span>
<span>Codec</span>() <span>string</span>
<span>AudioCodec</span>() <span>string</span>
<span>FrameBuffer</span>() []<span>byte</span></pre></div>
<div data-snippet-clipboard-copy-content="video := vidio.NewVideo(&#34;input.mp4&#34;)
for video.Read() {
	// &#34;frame&#34; stores the video frame as a flattened RGB image in row-major order
	frame := video.FrameBuffer() // stored as: RGBRGBRGBRGB...
	// Video processing here...
}"><pre><span>video</span> <span>:=</span> <span>vidio</span>.<span>NewVideo</span>(<span>&#34;input.mp4&#34;</span>)
<span>for</span> <span>video</span>.<span>Read</span>() {
	<span>// &#34;frame&#34; stores the video frame as a flattened RGB image in row-major order</span>
	<span>frame</span> <span>:=</span> <span>video</span>.<span>FrameBuffer</span>() <span>// stored as: RGBRGBRGBRGB...</span>
	<span>// Video processing here...</span>
}</pre></div>
<h2 dir="auto"><a id="user-content-camera" aria-hidden="true" href="#camera"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><code>Camera</code></h2>
<p dir="auto">The <code>Camera</code> can read from any cameras on the device running Vidio. It takes in the stream index. On most machines the webcam device has index 0. Note that audio retrieval from the microphone is not yet supported.</p>
<div data-snippet-clipboard-copy-content="Name() string
Width() int
Height() int
Depth() int
FPS() float64
Codec() string
FrameBuffer() []byte"><pre><span>Name</span>() <span>string</span>
<span>Width</span>() <span>int</span>
<span>Height</span>() <span>int</span>
<span>Depth</span>() <span>int</span>
<span>FPS</span>() <span>float64</span>
<span>Codec</span>() <span>string</span>
<span>FrameBuffer</span>() []<span>byte</span></pre></div>
<div data-snippet-clipboard-copy-content="camera := vidio.NewCamera(0) // Get Webcam
defer camera.Close()

// Stream the webcam
for camera.Read() {
	// &#34;frame&#34; stores the video frame as a flattened RGB image
	frame := camera.FrameBuffer() // stored as: RGBRGBRGBRGB...
	// Video processing here...
}"><pre><span>camera</span> <span>:=</span> <span>vidio</span>.<span>NewCamera</span>(<span>0</span>) <span>// Get Webcam</span>
<span>defer</span> <span>camera</span>.<span>Close</span>()

<span>// Stream the webcam</span>
<span>for</span> <span>camera</span>.<span>Read</span>() {
	<span>// &#34;frame&#34; stores the video frame as a flattened RGB image</span>
	<span>frame</span> <span>:=</span> <span>camera</span>.<span>FrameBuffer</span>() <span>// stored as: RGBRGBRGBRGB...</span>
	<span>// Video processing here...</span>
}</pre></div>
<h2 dir="auto"><a id="user-content-videowriter" aria-hidden="true" href="#videowriter"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><code>VideoWriter</code></h2>
<p dir="auto">The <code>VideoWriter</code> is used to write frames to a video file. The only required parameters are the output file name, the width and height of the frames being written, and an <code>Options</code> struct. This contains all the desired properties of the new video you want to create.</p>
<div data-snippet-clipboard-copy-content="FileName() string
Width() int
Height() int
Bitrate() int
Loop() int
Delay() int
Macro() int
FPS() float64
Quality() float64
Codec() string
AudioCodec() string"><pre><span>FileName</span>() <span>string</span>
<span>Width</span>() <span>int</span>
<span>Height</span>() <span>int</span>
<span>Bitrate</span>() <span>int</span>
<span>Loop</span>() <span>int</span>
<span>Delay</span>() <span>int</span>
<span>Macro</span>() <span>int</span>
<span>FPS</span>() <span>float64</span>
<span>Quality</span>() <span>float64</span>
<span>Codec</span>() <span>string</span>
<span>AudioCodec</span>() <span>string</span></pre></div>
<div data-snippet-clipboard-copy-content="type Options struct {
	Bitrate     int             // Bitrate
	Loop        int             // For GIFs only. -1=no loop, 0=loop forever, &gt;0=loop n times
	Delay       int             // Delay for Final Frame of GIFs. Default -1 (Use same delay as previous frame)
	Macro       int             // macro size for determining how to resize frames for codecs. Default 16
	FPS         float64         // Frames per second. Default 25
	Quality     float64         // If bitrate not given, use quality instead. Must be between 0 and 1. 0:best, 1:worst
	Codec       string          // Codec for video. Default libx264
	Audio       string          // File path for audio for the video. If no audio, audio=nil.
	AudioCodec  string          // Codec for audio. Default aac
}"><pre><span>type</span> <span>Options</span> <span>struct</span> {
	<span>Bitrate</span>     <span>int</span>             <span>// Bitrate</span>
	<span>Loop</span>        <span>int</span>             <span>// For GIFs only. -1=no loop, 0=loop forever, &gt;0=loop n times</span>
	<span>Delay</span>       <span>int</span>             <span>// Delay for Final Frame of GIFs. Default -1 (Use same delay as previous frame)</span>
	<span>Macro</span>       <span>int</span>             <span>// macro size for determining how to resize frames for codecs. Default 16</span>
	<span>FPS</span>         <span>float64</span>         <span>// Frames per second. Default 25</span>
	<span>Quality</span>     <span>float64</span>         <span>// If bitrate not given, use quality instead. Must be between 0 and 1. 0:best, 1:worst</span>
	<span>Codec</span>       <span>string</span>          <span>// Codec for video. Default libx264</span>
	<span>Audio</span>       <span>string</span>          <span>// File path for audio for the video. If no audio, audio=nil.</span>
	<span>AudioCodec</span>  <span>string</span>          <span>// Codec for audio. Default aac</span>
}</pre></div>
<div data-snippet-clipboard-copy-content="w, h, c := 1920, 1080, 3
options := vidio.Options{} // Will fill in defaults if empty

writer := vidio.NewVideoWriter(&#34;output.mp4&#34;, w, h, &amp;options)
defer writer.Close()

frame := make([]byte, w*h*c) // Create Frame as RGB Image and modify
writer.Write(frame) // Write Frame to video"><pre><span>w</span>, <span>h</span>, <span>c</span> <span>:=</span> <span>1920</span>, <span>1080</span>, <span>3</span>
<span>options</span> <span>:=</span> vidio.<span>Options</span>{} <span>// Will fill in defaults if empty</span>

<span>writer</span> <span>:=</span> <span>vidio</span>.<span>NewVideoWriter</span>(<span>&#34;output.mp4&#34;</span>, <span>w</span>, <span>h</span>, <span>&amp;</span><span>options</span>)
<span>defer</span> <span>writer</span>.<span>Close</span>()

<span>frame</span> <span>:=</span> <span>make</span>([]<span>byte</span>, <span>w</span><span>*</span><span>h</span><span>*</span><span>c</span>) <span>// Create Frame as RGB Image and modify</span>
<span>writer</span>.<span>Write</span>(<span>frame</span>) <span>// Write Frame to video</span></pre></div>
<h2 dir="auto"><a id="user-content-images" aria-hidden="true" href="#images"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Images</h2>
<p dir="auto">Vidio provides some convenience functions for reading and writing to images using an array of bytes. Currently, only <code>png</code> and <code>jpeg</code> formats are supported.</p>
<div data-snippet-clipboard-copy-content="// Read png image
w, h, img := vidio.Read(&#34;input.png&#34;)

// w - width of image
// h - height of image
// img - byte array in RGB format. RGBRGBRGBRGB...

vidio.Write(&#34;output.jpg&#34;, w, h, img)"><pre><span>// Read png image</span>
<span>w</span>, <span>h</span>, <span>img</span> <span>:=</span> <span>vidio</span>.<span>Read</span>(<span>&#34;input.png&#34;</span>)

<span>// w - width of image</span>
<span>// h - height of image</span>
<span>// img - byte array in RGB format. RGBRGBRGBRGB...</span>

<span>vidio</span>.<span>Write</span>(<span>&#34;output.jpg&#34;</span>, <span>w</span>, <span>h</span>, <span>img</span>)</pre></div>
<h2 dir="auto"><a id="user-content-examples" aria-hidden="true" href="#examples"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Examples</h2>
<p dir="auto">Copy <code>input.mp4</code> to <code>output.mp4</code>. Copy the audio from <code>input.mp4</code> to <code>output.mp4</code> as well.</p>
<div data-snippet-clipboard-copy-content="video := vidio.NewVideo(&#34;input.mp4&#34;)
options := vidio.Options{
	FPS: video.FPS(),
	Bitrate: video.Bitrate(),
	Audio: &#34;input.mp4&#34;,
}

writer := vidio.NewVideoWriter(&#34;output.mp4&#34;, video.Width(), video.Height(), &amp;options)
defer writer.Close()

for video.Read() {
    writer.Write(video.FrameBuffer())
}"><pre><span>video</span> <span>:=</span> <span>vidio</span>.<span>NewVideo</span>(<span>&#34;input.mp4&#34;</span>)
<span>options</span> <span>:=</span> vidio.<span>Options</span>{
	<span>FPS</span>: <span>video</span>.<span>FPS</span>(),
	<span>Bitrate</span>: <span>video</span>.<span>Bitrate</span>(),
	<span>Audio</span>: <span>&#34;input.mp4&#34;</span>,
}

<span>writer</span> <span>:=</span> <span>vidio</span>.<span>NewVideoWriter</span>(<span>&#34;output.mp4&#34;</span>, <span>video</span>.<span>Width</span>(), <span>video</span>.<span>Height</span>(), <span>&amp;</span><span>options</span>)
<span>defer</span> <span>writer</span>.<span>Close</span>()

<span>for</span> <span>video</span>.<span>Read</span>() {
    <span>writer</span>.<span>Write</span>(<span>video</span>.<span>FrameBuffer</span>())
}</pre></div>
<p dir="auto">Grayscale 1000 frames of webcam stream and store in <code>output.mp4</code>.</p>
<div data-snippet-clipboard-copy-content="webcam := vidio.NewCamera(0)
defer webcam.Close()

options := vidio.Options{FPS: webcam.FPS()}

writer := vidio.NewVideoWriter(&#34;output.mp4&#34;, webcam.Width(), webcam.Height(), &amp;options)
defer writer.Close()

count := 0
for webcam.Read() {
	frame := webcam.FrameBuffer()
	for i := 0; i &lt; len(frame); i += 3 {
		rgb := frame[i : i+3]
		r, g, b := int(rgb[0]), int(rgb[1]), int(rgb[2])
		gray := uint8((3*r + 4*g + b) / 8)
		frame[i] = gray
		frame[i+1] = gray
		frame[i+2] = gray
	}
	writer.Write(frame)
	count++
	if count &gt; 1000 {
		break
	}
}"><pre><span>webcam</span> <span>:=</span> <span>vidio</span>.<span>NewCamera</span>(<span>0</span>)
<span>defer</span> <span>webcam</span>.<span>Close</span>()

<span>options</span> <span>:=</span> vidio.<span>Options</span>{<span>FPS</span>: <span>webcam</span>.<span>FPS</span>()}

<span>writer</span> <span>:=</span> <span>vidio</span>.<span>NewVideoWriter</span>(<span>&#34;output.mp4&#34;</span>, <span>webcam</span>.<span>Width</span>(), <span>webcam</span>.<span>Height</span>(), <span>&amp;</span><span>options</span>)
<span>defer</span> <span>writer</span>.<span>Close</span>()

<span>count</span> <span>:=</span> <span>0</span>
<span>for</span> <span>webcam</span>.<span>Read</span>() {
	<span>frame</span> <span>:=</span> <span>webcam</span>.<span>FrameBuffer</span>()
	<span>for</span> <span>i</span> <span>:=</span> <span>0</span>; <span>i</span> <span>&lt;</span> <span>len</span>(<span>frame</span>); <span>i</span> <span>+=</span> <span>3</span> {
		<span>rgb</span> <span>:=</span> <span>frame</span>[<span>i</span> : <span>i</span><span>+</span><span>3</span>]
		<span>r</span>, <span>g</span>, <span>b</span> <span>:=</span> <span>int</span>(<span>rgb</span>[<span>0</span>]), <span>int</span>(<span>rgb</span>[<span>1</span>]), <span>int</span>(<span>rgb</span>[<span>2</span>])
		<span>gray</span> <span>:=</span> <span>uint8</span>((<span>3</span><span>*</span><span>r</span> <span>+</span> <span>4</span><span>*</span><span>g</span> <span>+</span> <span>b</span>) <span>/</span> <span>8</span>)
		<span>frame</span>[<span>i</span>] <span>=</span> <span>gray</span>
		<span>frame</span>[<span>i</span><span>+</span><span>1</span>] <span>=</span> <span>gray</span>
		<span>frame</span>[<span>i</span><span>+</span><span>2</span>] <span>=</span> <span>gray</span>
	}
	<span>writer</span>.<span>Write</span>(<span>frame</span>)
	<span>count</span><span>++</span>
	<span>if</span> <span>count</span> <span>&gt;</span> <span>1000</span> {
		<span>break</span>
	}
}</pre></div>
<p dir="auto">Create a gif from a series of <code>png</code> files enumerated from 1 to 10 that loops continuously with a final frame delay of 1000 centiseconds.</p>
<div data-snippet-clipboard-copy-content="w, h, _ := vidio.Read(&#34;1.png&#34;) // Get frame dimensions from first image

options := vidio.Options{FPS: 1, Loop: 0, Delay: 1000}

gif := vidio.NewVideoWriter(&#34;output.gif&#34;, w, h, &amp;options)
defer gif.Close()

for i := 1; i &lt;= 10; i++ {
	_, _, img := vidio.Read(strconv.Itoa(i)+&#34;.png&#34;)
	gif.Write(img)
}"><pre><span>w</span>, <span>h</span>, <span>_</span> <span>:=</span> <span>vidio</span>.<span>Read</span>(<span>&#34;1.png&#34;</span>) <span>// Get frame dimensions from first image</span>

<span>options</span> <span>:=</span> vidio.<span>Options</span>{<span>FPS</span>: <span>1</span>, <span>Loop</span>: <span>0</span>, <span>Delay</span>: <span>1000</span>}

<span>gif</span> <span>:=</span> <span>vidio</span>.<span>NewVideoWriter</span>(<span>&#34;output.gif&#34;</span>, <span>w</span>, <span>h</span>, <span>&amp;</span><span>options</span>)
<span>defer</span> <span>gif</span>.<span>Close</span>()

<span>for</span> <span>i</span> <span>:=</span> <span>1</span>; <span>i</span> <span>&lt;=</span> <span>10</span>; <span>i</span><span>++</span> {
	<span>_</span>, <span>_</span>, <span>img</span> <span>:=</span> <span>vidio</span>.<span>Read</span>(<span>strconv</span>.<span>Itoa</span>(<span>i</span>)<span>+</span><span>&#34;.png&#34;</span>)
	<span>gif</span>.<span>Write</span>(<span>img</span>)
}</pre></div>

<ul dir="auto">
<li>Special thanks to <a href="http://zulko.github.io/" rel="nofollow">Zulko</a> and his <a href="http://zulko.github.io/blog/2013/09/27/read-and-write-video-frames-in-python-using-ffmpeg/" rel="nofollow">blog post</a> about using FFmpeg to process video.</li>
<li>The <a href="https://github.com/imageio/imageio-ffmpeg/">ImageIO-FFMPEG</a> project on GitHub.</li>
</ul>
</article>
          </div></div>
  </body>
</html>
