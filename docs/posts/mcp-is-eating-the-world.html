<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.stainless.com/blog/mcp-is-eating-the-world--and-its-here-to-stay">Original</a>
    <h1>MCP is eating the world</h1>
    
    <div id="readability-page-1" class="page"><div fs-toc-element="contents"><p>Despite the hype, Model Context Protocol (MCP) isn’t magic or revolutionary. But, it’s simple, well-timed, and well-executed. At Stainless, we’re betting it’s here to stay.</p><p>“MCP helps you build agents and complex workflows on top of LLMs”. If you’ve paid attention, you know we’ve been here before. There are <em>numerous</em> past attempts at connecting the world to an LLM in a structured, automatic way.</p><ul role="list"><li><strong>Function/tool calling</strong>: Write a JSON schema, the model picks a function. But you had to manually wire each function per request and assume most of the responsibility for implementing retry logic.</li><li><strong>ReAct / LangChain</strong>: Let the model emit an <code>Action:</code> string, then parse it yourself—often flaky and hard to debug.</li><li><strong>ChatGPT plugins</strong>: Fancy, but gated. You had to host an OpenAPI server and obtain approval.</li><li><strong>Custom GPTs</strong>: Lower barrier to entry, but still stuck inside OpenAI’s runtime.</li><li><strong>AutoGPT, BabyAGI</strong>: Agents with ambition, but a mess of configuration, loops, and error cascades.</li></ul><p>Heck, even MCP itself isn’t new—the spec was released by Anthropic in November, but it suddenly blew up in February, 3 months later.</p><figure><p><img src="https://cdn.prod.website-files.com/662240109faccc0cefd740ae/685606fd02172b94e1944b7f_Screenshot%202025-06-13%20at%2014.53.08.png" loading="lazy" alt=""/></p><figcaption>Interest over time for MCP in Google search trends (<a href="https://trends.google.com/trends/explore?date=2024-10-13%202025-06-13&amp;geo=US&amp;q=MCP&amp;hl=en">link</a>)</figcaption></figure><p>Why is it that MCP is seemingly in ascent, while previous attempts fell short?</p><h2>Why is MCP eating the world?</h2><h3>1. The models finally got good enough</h3><p>Early tool use was messy—at best—due to unreliable models. Even basic functionality required extensive error handling—retries, validation, and detailed error messages were necessary just to get complex workflows running.</p><p>Tool use in an agentic setting requires a high standard of robustness. Those who used earlier coding agents know the perils of context poisoning—when a nonsensical output from your agent sends the rest of the conversation into an inescapable spiral. These dangers only multiply as you add more tools.</p><p>With newer models, LLMs are good enough that they don’t get sucked into pits of despair and they can usually recover from mistakes. Of course, models and agents are still far from perfect—the better models are pretty slow, context sizes are still limited, and performance degrades when more and more context is present.</p><p>What’s important is that the models are good enough—once models cross that threshold, the overhead of integrating tool use drops dramatically. MCP just showed up right on time.</p><h3>2. The protocol is good enough</h3><p>Earlier tool interfaces were tied to specific stacks:</p><ul role="list"><li>OpenAI’s function calling only worked in their API.</li><li>ChatGPT plugins needed their runtime.</li><li>LangChain tools were tightly bound to their prompt loop.</li></ul><p>You couldn’t just take a tool from one setup and use it somewhere else, every platform needed its own wiring for every tool.</p><p>To make matters worse, translating connectors to the various platforms was not trivial: each provider supports slightly different capabilities, such as supporting different dialects of JSON Schema. To support retries, you had to figure out a way to append messages and create a new completion, which was slightly, annoyingly different between providers.</p><p>There were also the less explicit footguns, like cases where the same rough prompt performed significantly worse between providers due to small details in how you threaded through the messages.</p><p>MCP addresses these issues by providing a shared, vendor-neutral protocol. You define a tool once, and its accessible to any LLM agent that supports MCP.</p><p>Of course, compatibility problems aren’t fully resolved. In practice, getting <a href="https://www.stainless.com/blog/what-we-learned-converting-complex-openapi-specs-to-mcp-servers#:~:text=MCP%20Clients%20have%20different%20schema%20limitations">MCP to work with all platforms remains a challenge</a>—and the lack of an auth standard at the beginning of the roll out made integrations more challenging.</p><p>Still, the promise of MCP is important: if you’re developing a tool, you just need to comply with the MCP standard—the rest is a bug in someone else’s code. It’s easier to develop something new <a href="https://matklad.github.io/2022/04/25/why-lsp.html">when you’re not fighting the world to make it happen</a>.</p><p>Although the protocol isn’t perfect, it’s arguably good enough. As an abstraction, the protocol sets clear boundaries between the tool and the agent, which lets tool developers focus on tools and agent developers focus on agents. Exposing the right amount of detail in an API sounds easy, but is actually an art: at Stainless we call this “designing at the right altitude”. In our experience, when an API is designed at the right altitude, it just doesn’t go away.</p><h3>3. The tooling is good enough</h3><p>MCP’s tooling is straightforward, high-quality, and relatively easy to approach. SDKs are available in many languages, which makes integrations easy no matter what stack you use.</p><p>As an example, we’ll take a look at <a href="https://github.com/modelcontextprotocol/python-sdk">the Python SDK,</a> though every SDK shares the following rough shape:</p><ul role="list"><li>Something that makes it easy to define tools (decorators for Python functions)</li><li>A runtime to start the MCP Server</li><li>A basic MCP Client to interface with the server</li></ul><p><strong>Define a tool</strong></p><div><!-- JavaScript -->
<div>
  
  <pre>  <code fs-copyclip-element="copy-this">
from mcp.server.fastmcp import FastMCP

mcp = FastMCP(&#34;Demo&#34;)

@mcp.tool()
def get_weather(location: str) -&gt; str:
    &#34;&#34;&#34;Fetch the weather forecast for a given location.&#34;&#34;&#34;
    ...
  </code>
  </pre>
</div></div><p><strong>Start a local MCP server:</strong>‍</p><div><!-- JavaScript -->
<div>
  
  <pre>  <code fs-copyclip-element="copy-this">
mcp dev ... path.to.your.module
  </code>
  </pre>
</div></div><p>That’s it—now the tools in that module are available to any MCP client, without unnecessary scaffolding or worrying about retries and agents. The lower barrier means that you can build and share tools faster—and reuse them across environments, in your CLI tools, your IDE, agents, web services, and more.</p><p>Of course, developing great MCP tools still requires a lot of work, including curating descriptions and paying attention to context usage, but what matters is that you can get started quickly and see the impact right away.</p><p>There’s a small lesson here: developer ergonomics matter. The difference between a platform achieving widespread adoption or dying in obscurity is sometimes attributable to just a small change in friction.</p><h3>4. The momentum is good enough</h3><p>To state the obvious, momentum is key to the success of any platform, protocol, or standard. A protocol is only as good as the clients and servers that adopt the framework.</p><p>On the client side, MCP adoption is already near-universal: OpenAI has <a href="https://openai.github.io/openai-agents-python/mcp/">adopted MCP</a> in their agents SDK and Google&#39;s Deepmind is <a href="https://x.com/demishassabis/status/1910107859041271977">throwing their weight behind it</a>. With that, all the major foundational model providers are now onboard. There are also many agent integrations, including Cursor, Cline, and Zed.</p><p>On the server side, we’ve seen API-first companies race to expose their services as MCP tools. Even where first-party tools aren&#39;t available, third-party servers fill the gaps.</p><p>Beyond the core software powering MCP, a rich ecosystem of independent resources is emerging:</p><ul role="list"><li>Registries (<a href="https://github.com/punkpeye/awesome-mcp-servers">awesome-mcp-servers,</a> <a href="https://smithery.ai/">smithery.ai,</a> <a href="https://www.postman.com/explore/mcp-servers">postman</a>, <a href="https://glama.ai/mcp">glama.ai</a>)</li><li>Services (Cloudflare, Vercel)</li><li>Tutorials (<a href="https://glama.ai/blog/2024-11-25-model-context-protocol-quickstart">glama.ai</a>, <a href="https://towardsdatascience.com/model-context-protocol-mcp-tutorial-build-your-first-mcp-server-in-6-steps/">towardsdatascience.com</a>)</li><li>Courses (<a href="https://huggingface.co/learn/mcp-course/unit0/introduction">huggingface</a>)</li><li>Events (<a href="https://workos.com/mcp-night">MCP Night</a>)</li></ul><p>Momentum wasn’t built overnight—Anthropic’s team did a great job of advancing the ecosystem, such as writing excellent <a href="https://modelcontextprotocol.io/introduction">first party documentation</a>, providing <a href="https://www.youtube.com/watch?v=kQmXtrmQ5Zg">talks</a>, hosting events, and <a href="https://linear.app/changelog/2025-05-01-mcp">working directly with companies</a> to bootstrap a world where MCP is already compelling.</p><p>Momentum incentivizes the community to build and publish tools, which in turn makes agents more powerful, which in turn further accelerates community adoption.</p><p>As MCP becomes more commonplace, it’s likely foundational model providers will start training on the usage patterns. This influx of data will undoubtedly make the models even better at agentic tasks, cementing MCP in how we think about APIs in the future.</p><h2>We think it’s going to stay</h2><p>MCP is in the zeitgeist, but being in the zeitgeist historically hasn&#39;t meant longevity, so it&#39;s reasonable to approach MCP with a healthy dose of skepticism.</p><p>Despite this skepticism, we’re convinced MCP is going to stay: because it’s good enough, and it’s good enough in ways that previous technologies weren’t. And it’s not just us: our API-first customers see MCP servers as a core part of their API. We’re making a bet on MCP.</p></div></div>
  </body>
</html>
