<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://rachelbythebay.com/w/2024/04/29/pb/">Original</a>
    <h1>Hitting every branch on the way down</h1>
    
    
<p>
I keep seeing people saying that the answer to my 
<a href="https://rachelbythebay.com/w/2024/04/02/autoconf/">complaints</a>
about autoconf is to rub *more* autoconf on the problem.  I don&#39;t like 
this.  In the general vein of &#34;this should not be that hard&#34;, I decided 
to revisit something from two years ago and tried to use my build tool 
to generate my stuff on a fresh BSD-flavored install.  (The exact 
flavor is unimportant here, and mentioning it by name would only trigger 
the weenies in the crowd, so I won&#39;t.)
</p>
<p>
I wanted to prove to myself that yes, my stuff can Just Build on 
other (i.e., not Linux or Mac) systems without resorting to the kinds of 
stuff that I wish we had collectively left behind in the 90s.
</p>
<p>
The OS itself was fine.  The install process on a throwaway VM image was 
quick and painless.  I knew how to get my usual tools installed - bash, 
nano, that kind of thing.  Unlike
<a href="https://rachelbythebay.com/w/2022/04/29/bsd/">last time,</a>
I opted to not do X and just focused on getting my stuff to build.
</p>
<p>
But then I made a mistake: I told it to install &#34;protobuf&#34; since I use 
that library in my build tool.  That actually installed 
&#34;protobuf-24.4,1&#34; which is some insane version number I&#39;d never seen 
before.  All of my other systems are all running 3.x.x type versions.
</p>
<p>
Now, realize, I didn&#39;t know this was a mistake yet, and kept on going.  
I did manage to bootstrap my build tool into a usable binary, and then 
started a &#34;build the world&#34; process, at which point it blew up.  It was 
complaining about not being able to find a library called 
&#34;google/protobuf/arena&#34; inside my personal source tree.
</p>
<p>
This made no sense, so I started digging, and found out that the 
&#34;protoc&#34; compiler in that version of the software spits out code like 
this:
</p>
<pre class="terminal">#include &#34;google/protobuf/thing1.h&#34;
#include &#34;google/protobuf/thing2.h&#34;
#include &#34;google/protobuf/thing3.h&#34;
</pre>
<p>
... you get the idea.  It&#39;s a third-party library that&#39;s installed at 
the system level, and yet it&#39;s using &#34;&#34; like it&#39;s all chummy and hanging 
out with your code in your local repo.  Yeah, no.  That&#39;s wrong.  They 
should be &lt;&gt; includes, like this:
</p>
<pre class="terminal">#include &lt;google/protobuf/thing1.h&gt;
#include &lt;google/protobuf/thing2.h&gt;
#include &lt;google/protobuf/thing3.h&gt;
</pre>
<p>
What&#39;s weird is... it *is* that way on all of my other machines - my Mac 
with Macports and my Debian/Raspbian boxes all generate those #includes 
with &lt;&gt; like they&#39;re supposed to, and everything Just Works.
</p>
<p>
I won&#39;t lie.  This really made me angry at first.  I was like, okay, 
they did yet another stupid thing upstream, and now everyone else is 
going to have to work around it.  It got me thinking thoughts like 
&#34;just how hard would it be to NOT use protobuf, anyway&#34;.  I figured 
that this abomination would eventually filter down to Macports and 
Debian&#39;s apt repo and whatnot, and then I&#39;d have to deal with it, or 
toss it.
</p>
<p>
After a few minutes of cooling off, it occurred to me that I could do 
something super-duper obnoxious: wrap protoc, and run a nasty little sed 
command afterward to flip the &#34;&#34; to &lt;&gt;.  So I did that, and things 
proceeded.  Awful.
</p>
<p>
Of course, then I ran into some other fun problems with my code, like 
IPPROTO_* definitions not being available.  I have a wrapper for 
getaddrinfo() and it uses IPPROTO_TCP in the .ai_protocol field.  I had 
all of the #includes that the man pages say to have for using 
that function, but that&#39;s not enough on this particular system.
</p>
<p>
I assume that there&#39;s some transitive #include on Macs and on 
glibc-flavored Linuxes that drags this in for me, but on this one BSD it 
doesn&#39;t work that way.  The fix was simple enough, and mighty stupid:
</p>
<pre class="terminal">#include &lt;netinet/in.h&gt;
</pre>
<p>
And no, that&#39;s not listed in their getaddrinfo(3) manual page, even 
though IPPROTO_UDP and _TCP are both explicitly mentioned in it.  Dig 
around online and you&#39;ll find this tripping up other people.  That&#39;s the 
extent of my self-inflicted damage that had to be fixed to make it 
build: lack of a few #includes.
</p>
<p>
Stuff like this is why I tend to wall off calls into the C library with 
a bunch of compatibility gunk and then use my own interfaces above that.  
</p>
<p>
At some point during this, I decided to go back into the protobuf git 
repo to see just when they decided to dump the angle brackets in favor 
of the double-quotes, and that&#39;s when I hit another wall of stupid.  
Apparently it&#39;s possible to change a git repo in such a way that &#34;git 
log -p&#34; will never show it.  Did you know that?  Before yesterday, I 
definitely didn&#39;t.
</p>
<p>
Here&#39;s how I discovered this: obviously, there was code that would do 
the &lt;&gt; stuff at some point.  The last version of it I could find looked 
like this:
</p>
<pre class="terminal">  std::string left = &#34;\&#34;&#34;;
  std::string right = &#34;\&#34;&#34;;
  if (use_system_include) {
    left = &#34;&lt;&#34;;
    right = &#34;&gt;&#34;;
  }
  return left + name + right;
</pre>
<p>
It seems simple enough, if a little goofy: return &#34;input&#34; unless 
use_system_include gets set a few lines up, in which case it should 
return &lt;input&gt;.  No big deal, right?
</p>
<p>
But... that code exists nowhere in the repo as it stands now.  Silly 
naive me, I thought I could just &#34;git log -p&#34; and do a / search in less 
for &#34;use_system_include&#34; to find the commit which dropped it.  I wanted 
to learn why they did this, because maybe they had a good reason, or 
basically, if I complained about it, what I would be up against.
</p>
<p>
I found nothing.
</p>
<p>
This started a terrible sequence where I started checking out different 
commits from the tree to see what it looked like at various points in 
the past.  I got it down to a commit that contained the above code, and 
then one commit past that dropped it.
</p>
<p>
This must be it, right?  I should be able to &#34;git log -p&#34; and see it, 
right?  Nope.
</p>
<pre class="terminal">commit d85c9944c55fb38f4eae149979a0f680ea125ecb (HEAD)
Merge: 7764c864b 0264866ce
Author: &lt;removed because it&#39;s not their fault&gt;
Date:   Mon Sep 19 14:10:44 2022 -0700

    Sync from Piper @475378801
    
    PROTOBUF_SYNC_PIPER
</pre>
<p>
The next line in the git log output is the next commit.  There&#39;s no 
&#34;body&#34; to this commit.  It&#39;s just a &#34;Merge:&#34; and two other commits.
</p>
<p>
7764c864b and 0264866ce, right?  I should be able to sync to those with 
git checkout and see which one dropped it, yeah?  Well, I&#39;ll spare you 
the effort and just say that BOTH OF THEM have the old code in it.
</p>
<p>
So... this commit somehow drops the code even though it&#39;s merging two 
&#34;ancestral commits&#34; that both contain it, and there&#39;s no diff shown.
</p>
<p>
Confusing, right?
</p>
<p>
I don&#39;t know how I finally figured this out, but after a whole lot of 
cursing and thrashing, I found &#34;git show &lt;commit&gt;&#34; will FINALLY give me 
the results I want, ish.  It contains the change which dumped the &lt;&gt; 
code and put in the new stuff.
</p>
<pre class="terminal">--  std::string left = &#34;\&#34;&#34;;
--  std::string right = &#34;\&#34;&#34;;
--  if (use_system_include) {
--    left = &#34;&lt;&#34;;
--    right = &#34;&gt;&#34;;
--  }
--  return left + name + right;
++  return absl::StrCat(&#34;\&#34;&#34;, basename, &#34;\&#34;&#34;);
</pre>
<p>
There&#39;s no explanation or other context.  Presumably that all got 
squashed out when it was exported from whatever they use internally.
</p>
<p>
&#34;Why&#34; is gone.  I just have &#34;when&#34;, and that&#39;s not very interesting: it 
was merged in September 2022, ho hum.  That just means that whenever 
Linux distributions and Macports catch up with at least that point, I&#39;m 
going to have to deal with this for real.
</p>
<p>
Oh, there&#39;s one more bit of batshittery which needs to be mentioned 
here.  My stuff uses pkg-config to find out how to compile and link 
against these libraries, right?  Well, when it was using this oh-so-new 
protobuf version, the commands it was running were so long, it was 
scrolling off my standard 80x25 terminal.
</p>
<pre class="terminal">$ pkg-config --cflags protobuf | wc -c
    4326
</pre>
<p>
Yep!  4 KB of cflags.  Here&#39;s just the top part of it:
</p>
<pre class="terminal"># pkg-config --cflags protobuf
-I/usr/local/include -DPROTOBUF_USE_DLLS -Wno-float-conversion 
-DNOMINMAX -Wno-float-conversion -DNOMINMAX -Wno-float-conversion 
-DNOMINMAX -Wno-float-conversion -DNOMINMAX -Wno-float-conversion 
-DNOMINMAX -Wno-float-conversion -DNOMINMAX -Wno-float-conversion 
-DNOMINMAX -Wno-float-conversion -DNOMINMAX -Wno-float-conversion 
</pre>
<p>
... and it just goes on like this.  It actually worked, though!
</p>
<p>
Finally, remember when I said that I made a problem by installing their 
&#34;protobuf&#34; package without realizing it?  Yeah, it turns out they 
actually also have &#34;protobuf3&#34; which is a nice sane version just like 
the ones on my other machines, #include &lt;...&gt; and all.  So, I removed 
the bad one, installed this other one, and dropped my sed hack.
</p>
<p>
What a night.
</p>

  </body>
</html>
