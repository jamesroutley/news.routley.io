<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://traxys.me/riscv_os_buddy.html">Original</a>
    <h1>Making an RISC-V OS (Part 3): Managing free memory</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>See <a href="https://traxys.me/riscv_os_2.html">previous part</a> on handling the transition from physical to virtual memory.</p>

<p>When we left last time our kernel had booted up in virtual memory, but we still had no idea what our surroundings looked like.
The only things we know about are the sections that have been allocated by the linker in our ELF binary,
but those are <em>statically</em> defined, they don&#39;t adapt to our hardware.</p>
<p>We need to find a way to get a list of all the devices &amp; memory regions we have access to, with their properties &amp; physical locations.
In x86 machines this is often done through <a href="https://en.wikipedia.org/wiki/ACPI">ACPI</a>.
On RISC-V, as well as ARM, this is often done through <a href="https://en.wikipedia.org/wiki/Devicetree">Devicetrees</a>.</p>
<p>Device trees are a data structure that is populated by a low-level firmware (or it could even be hard-coded somewhere in the address-space) that contain all the information on the system.
Device trees have two main representations:</p>
<ul>
<li>A textual format (<code>.dts</code>) that is human editable.</li>
<li>A binary format (<code>.dtb</code>) that is space efficient and easily parsable by machines.</li>
</ul>
<p>In order to gather our system specs we are going to rely on the <code>dtb</code> structure populated by QEMU before the system boot.
This structure is passed in the <code>a1</code> register, and OpenSBI forwards it to us.</p>

<p>We can dump the QEMU device tree blob by running <code>qemu-system-riscv64 -M virt,dumpdtb=virt.dtb</code>.
It is then possible to convert it to a textual format by running <code>dtc -I dtb -O dts virt.dtb &gt;&gt; virt.dts</code>.</p>
<p>Here is a small extract from the Devicetree with the properties that we want to query for now:</p>
<pre><code><span><span>/dts-v1/</span>
</span><span><span></span>
</span><span><span>/ <span>{</span></span>
</span><span><span>    #<span>address</span>-<span>cells</span> <span>=</span> <span>&lt;</span><span>0x02</span><span>&gt;</span><span>;</span></span>
</span><span>    #<span>size</span>-<span>cells</span> <span>=</span> <span>&lt;</span><span>0x02</span><span>&gt;</span><span>;</span>
</span><span>    <span>compatible</span> <span>=</span> &#34;<span>riscv</span>-<span>virtio</span>&#34;<span>;</span>
</span><span>    <span>model</span> <span>=</span> &#34;<span>riscv</span>-<span>virtio</span><span>,</span><span>qemu</span>&#34;<span>;</span>
</span><span>
</span><span>    <span>/* some nodes ... */</span>
</span><span>
</span><span>    <span>memory</span><span>@</span><span>80000000</span> <span>{</span>
</span><span>        <span>device_type</span> <span>=</span> &#34;<span>memory</span>&#34;<span>;</span>
</span><span>        <span>reg</span> <span>=</span> <span>&lt;</span><span>0x00</span> <span>0x80000000</span> <span>0x00</span> <span>0x80000000</span><span>&gt;</span><span>;</span>
</span><span>    <span>}</span><span>;</span>
</span><span>
</span><span>    <span>/* ... more nodes */</span>
</span><span><span>}</span><span>;</span>
</span></code></pre>
<p>The RAM location in physical memory and its length is coded in the <code>reg</code> property of the <code>memory@80000000</code> node.
We simply need to parse this device tree when booting, and we would be able to initialize the rest of the memory.</p>

<p>The <a href="https://github.com/devicetree-org/devicetree-specification/releases/download/v0.4/devicetree-specification-v0.4.pdf">Devicetree specification PDF</a> describes in the 5th section the format of the Devicetree.</p>
<p>In summary a device tree is divided in two main sections:</p>
<ul>
<li>The <em>struct</em> section, containing the hierarchy of the device tree.</li>
<li>The <em>strings</em> section, containing the value of numerous properties.</li>
</ul>
<p>The main structure to be parsed is the <em>struct</em> section, as the strings section is only pointed to.
The struct section in organised in nested arrays, each array is composed of the following parts:</p>
<ul>
<li>A header indicating the start of a node</li>
<li>A number of properties of the current object</li>
<li>A number of sub arrays (each of exactly the same format)</li>
<li>An end of node marker</li>
</ul>
<p>This means that to get the offset of the second child of a node the entire first child tree must be parsed.
In order to query the Devicetree without needing to re-parse the entire tree each time we can use a new structure of the form:</p>
<pre><code><span><span>#</span><span>[</span><span>derive</span><span>(</span><span>Debug</span><span>)</span><span>]</span>
</span><span><span>pub</span> <span>struct</span> <span>DeviceTreeNode</span><span>&lt;</span><span>&#39;</span><span>a</span><span>,</span> <span>&#39;</span><span>d</span><span>&gt;</span> <span>{</span>
</span><span>    <span>pub</span> <span>name</span><span>:</span> <span>&amp;</span><span>&#39;</span><span>d</span> <span>str</span><span>,</span>
</span><span>    <span>// This is a type reprensenting each possible property</span>
</span><span>    <span>pub</span> <span>props</span><span>:</span> <span>Vec</span><span>&lt;</span><span>&#39;</span><span>a</span><span>,</span> <span>DtProp</span><span>&lt;</span><span>&#39;</span><span>a</span><span>,</span> <span>&#39;</span><span>d</span><span>&gt;</span><span>&gt;</span><span>,</span>
</span><span>    <span>pub</span> <span>children</span><span>:</span> <span>Vec</span><span>&lt;</span><span>&#39;</span><span>a</span><span>,</span> <span>DeviceTreeNode</span><span>&lt;</span><span>&#39;</span><span>a</span><span>,</span> <span>&#39;</span><span>d</span><span>&gt;</span><span>&gt;</span><span>,</span>
</span><span><span>}</span>
</span></code></pre>
<p>The only issue with this representation is that it requires an allocator, but we are trying to find the RAM, so we don&#39;t have any free memory right now!</p>
<p>Note that all integers are stored big-endian! Most tokens also need to be 32 bit aligned.
There exists a <code>NOP</code> token that needs to be skipped. All those restrictions make the code a bit more
complex than it seems with the description, so I won&#39;t show include the parsing function in this post,
but it is available on <a href="https://github.com/traxys/pantheon/blob/dd7c136b95a010f87392d02017f811446acaca0d/hades/src/dtb.rs">the git repository</a></p>

<p>In order to parse the dtb we are going to create a small section in the binary using the following assembly snippet:</p>
<pre><code><span><span>.section</span> .data
</span><span><span>.global</span> <span>_early_heap</span>
</span><span><span>.align</span> <span>12</span>
</span><span><span>_early_heap</span><span>:</span>
</span><span><span>.rep</span> 1024 <span>*</span> <span>1024</span>
</span><span>    <span>.byte</span> <span>0</span>
</span><span><span>.endr</span>
</span></code></pre>
<p>We can then access this zone with the following code:</p>
<pre><code><span><span>const</span> <span>EARLY_HEAP_LEN</span><span>:</span> <span>usize</span> <span>=</span> <span>1024</span> <span>*</span> <span>1024</span><span>;</span>
</span><span>
</span><span><span>extern</span> <span>&#34;C&#34;</span> <span>{</span>
</span><span>    <span>#</span><span>[</span><span>link_name</span> <span>=</span> <span>&#34;_early_heap&#34;</span><span>]</span>
</span><span>    <span>static</span> <span>mut</span> <span>EARLY_HEAP</span><span>:</span> <span>u8</span><span>;</span>
</span><span><span>}</span>
</span><span>
</span><span><span>fn</span> <span>kmain</span><span>(</span><span>...</span><span>)</span> <span>-&gt;</span> <span>!</span> <span>{</span>
</span><span>    <span>/* ... See previous part ... */</span>
</span><span>
</span><span>    <span>let</span> <span>early_heap</span><span>:</span> <span>&amp;</span><span>[</span><span>u8</span><span>]</span> <span>=</span> <span>unsafe</span> <span>{</span>
</span><span>        <span>core</span><span>::</span><span>slice</span><span>::</span><span>from_raw_parts_mut</span><span>(</span>
</span><span>            <span>addr_of_mut</span><span>!</span><span>(</span><span>EARLY_HEAP</span><span>)</span> <span>as</span> <span>*</span><span>mut</span> <span>MaybeUninit</span><span>&lt;</span><span>u8</span><span>&gt;</span><span>,</span>
</span><span>            <span>EARLY_HEAP_LEN</span><span>,</span>
</span><span>        <span>)</span>
</span><span>    <span>}</span><span>;</span>
</span><span>
</span><span>    <span>/* ... parse the dtb ... */</span>
</span><span><span>}</span> 
</span></code></pre>
<p>Using this block of memory we have 1 MiB to do whatever we want!
We are going to implement a really simple bump allocator with this memory.
A bump allocator looks like this:</p>
<p><img src="https://traxys.me/public/bump_allocator.png" alt="bump allocator"/></p>
<p>We have a <code>current</code> pointer inside the buffer that indicates when next to allocate.
The memory between <code>start</code> and <code>current</code> is in use, and can&#39;t be freed.
Whenever we need to allocate some memory we can <em>bump</em> the current pointer according to the amount we need, and use that block.</p>
<p>It is possible to improve a bit the bump allocator by implementing two optimizations:</p>
<ul>
<li>If are trying to free the <em>last</em> block (meaning the end of the block is equal to <code>current</code>) then
we can decrement <code>current</code> by the length of the block. This allows to handle efficiently short-lived objects.</li>
<li>If we try to re-allocate some memory, and it is the last piece of memory we allocated we can simply bump the <code>current</code> pointer to increase as required the allocation size (or decrease it!). This allows to efficiently implement growable arrays (<code>Vec</code>) where we append the items sequentially, and never touch them again.</li>
</ul>
<p>Using this allocator we can implement <code>Vec</code> that re-allocate themselves with twice the capacity whenever they are full. This allows us to parse easily the <code>dtb</code> described in the previous section!</p>

<p>The <code>memory</code> section is not the only useful node to read, there is a second node that is important to locate the RAM: <code>reserved-memory</code>.
OpenSBI will reserve some of the RAM for itself, and our OS is not allowed to touch it.
This is implemented using Machine level permissions, if we try to access that memory the CPU will trap.</p>
<p>This means that we need to combine the information from the <code>memory</code> field with the information from the <code>reserved-memory</code> field in order to find the effective memory.</p>
<p>Right now Hades only handles a single physical memory block, and uses all memory after the last <code>reserved-memory</code> field.</p>

<p>Now that we know where our physical memory lies we can start to write some code to know what RAM is free, and what RAM is allocated.
We are going to write a buddy allocator for getting pages, as it is a quite simple allocator that has nice guarantees on external fragmentation.
In order to simplify the implementation we are going to choose the largest allocation size, above which we won&#39;t be able to allocate contiguous memory.
This is a bit arbitrary, but we are going to choose <math display="inline"><mrow><msup><mn>2</mn><mn>12</mn></msup></mrow></math> pages or 16 MiB.</p>

<p>When talking about allocators <strong>fragmentation</strong> is one of the most important things we need to think about.
There are two kinds of fragmentation that are important to handle:</p>
<ul>
<li>Internal fragmentation</li>
<li>External fragmentation</li>
</ul>
<p>External fragmentation measures the &#34;contiguousness&#34; of memory.
If an allocator has 16 GiB available, but can&#39;t allocate more than 1 KiB of contiguous memory because all
the memory is split up, then we would say that the external fragmentation is very large.</p>
<p>Internal fragmentation measures the amount of &#34;wasted&#34; space.
An allocator can give a bigger amount of RAM to a request than requested.
For example if our allocation is a page (4 KiB), and the user asks for 4 B we would waste most of the space!</p>
<p><img src="https://traxys.me/public/allocator_fragmentation.png" alt="Allocator fragmentation"/></p>
<p>See the <a href="https://en.wikipedia.org/wiki/Fragmentation_(computing)">Wikipedia page</a> for more details on fragmentation.</p>

<p>The first step in implementing a buddy allocator is to define free lists for each of the allocation sizes we support.
A free list is simply a linked list where we only pop or push to the head of the list.
This allows fast access to free elements, if all our elements are fungible.</p>
<p>So we can start our page allocator as follows:</p>
<pre><code><span><span>#</span><span>[</span><span>derive</span><span>(</span><span>Clone</span><span>,</span> <span>Copy</span><span>)</span><span>]</span>
</span><span><span>struct</span> <span>FreeList</span> <span>{</span>
</span><span>    <span>head</span><span>:</span> <span>Option</span><span>&lt;</span><span>&amp;</span><span>&#39;</span><span>static</span> <span>Page</span><span>&gt;</span><span>,</span>
</span><span><span>}</span>
</span><span>
</span><span><span>#</span><span>[</span><span>derive</span><span>(</span><span>Clone</span><span>,</span> <span>Copy</span><span>)</span><span>]</span>
</span><span><span>struct</span> <span>FreePageState</span> <span>{</span>
</span><span>    <span>next</span><span>:</span> <span>Option</span><span>&lt;</span><span>&amp;</span><span>&#39;</span><span>static</span> <span>Page</span><span>&gt;</span><span>,</span>
</span><span><span>}</span>
</span><span>
</span><span><span>pub</span> <span>union</span> <span>PageState</span> <span>{</span>
</span><span>    <span>free</span><span>:</span> <span>FreePageState</span><span>,</span>
</span><span><span>}</span>
</span><span>
</span><span><span>#</span><span>[</span><span>derive</span><span>(</span><span>Debug</span><span>)</span><span>]</span>
</span><span><span>#</span><span>[</span><span>non_exhaustive</span><span>]</span>
</span><span><span>pub</span> <span>struct</span> <span>Page</span> <span>{</span>
</span><span>    <span>pub</span> <span>state</span><span>:</span> <span>UnsafeCell</span><span>&lt;</span><span>PageState</span><span>&gt;</span><span>,</span>
</span><span>    <span>/// Represents the status of allocations in the buddy allocator</span>
</span><span>    <span>allocated</span><span>:</span> <span>AtomicU16</span><span>,</span>
</span><span><span>}</span>
</span><span>
</span><span><span>pub</span> <span>struct</span> <span>PageAllocator</span> <span>{</span>
</span><span>    <span>free</span><span>:</span> <span>[</span><span>FreeList</span><span>;</span> <span>MAX_ORDER</span> <span>+</span> <span>1</span><span>]</span><span>,</span> <span>// MAX_ORDER is 12</span>
</span><span>    <span>pages</span><span>:</span> <span>&amp;</span><span>&#39;</span><span>static</span> <span>[</span><span>Page</span><span>]</span><span>,</span>
</span><span><span>}</span>
</span><span>
</span><span><span>static</span> <span>PAGE_ALLOCATOR</span><span>:</span> <span>SpinLock</span><span>&lt;</span><span>PageAllocator</span><span>&gt;</span> <span>=</span> <span>SpinLock</span><span>::</span><span>new</span><span>(</span><span>PageAllocator</span> <span>{</span>
</span><span>    <span>free</span><span>:</span> <span>[</span><span>FreeList</span> <span>{</span> <span>head</span><span>:</span> <span>None</span> <span>}</span><span>;</span> <span>MAX_ORDER</span> <span>+</span> <span>1</span><span>]</span><span>,</span>
</span><span>    <span>pages</span><span>:</span> <span>&amp;</span><span>[</span><span>]</span><span>,</span>
</span><span><span>}</span><span>)</span><span>;</span>
</span></code></pre>
<p>We need to initialize the <code>PageAllocator</code> with a pointer to a memory region that will store our bookkeeping for the pages (the array of <code>Page</code>).
In our OS we are going to put this at the start of RAM (as found in the <code>dtb</code>).
Each entry in the <code>PageAllocator.pages</code> field represents the corresponding 4 KiB page from the remaining of RAM.</p>
<p>The <code>Page</code> structs are linked together using the <code>Page.state.free.next</code> field. This field is <strong>only</strong> valid when the page is not currently allocated.
Because we must use one <code>Page</code> struct for every page in the system it is important to keep the struct as small as possible.</p>
<p>Because there is no way to construct a <code>PageAllocator</code>, as the fields are private, the safety invariants on the <code>PageState</code> rely on the <code>PAGE_ALLOCATOR</code> structure being only accessible through a <code>SpinLock</code>.
This allows us to ensure that while we hold the lock we can be sure that there can&#39;t be another user that can access unallocated pages, and as such it is safe to take a (single!) mutable reference on the <code>Page.state</code> field.</p>
<p>We are then going to create a <code>init</code> function, that will assign physical memory the to <code>PAGE_ALLOCATOR</code> static:</p>
<pre><code><span><span>fn</span> <span>align</span><span>(</span><span>v</span><span>:</span> <span>usize</span><span>,</span> <span>exp</span><span>:</span> <span>usize</span><span>)</span> <span>-&gt;</span> <span>usize</span> <span>{</span>
</span><span>    <span>assert</span><span>!</span><span>(</span><span>exp</span><span>.</span><span>is_power_of_two</span><span>(</span><span>)</span><span>)</span><span>;</span>
</span><span>
</span><span>    <span>(</span><span>v</span> <span>+</span> <span>exp</span> <span>-</span> <span>1</span><span>)</span> <span>&amp;</span> <span>!</span><span>(</span><span>exp</span> <span>-</span> <span>1</span><span>)</span>
</span><span><span>}</span>
</span><span>
</span><span><span>/// SAFETY: `start` must point to currently _unused_ physical memory</span>
</span><span><span>///</span>
</span><span><span>/// This function may only be called once</span>
</span><span><span>pub</span> <span>unsafe</span> <span>fn</span> <span>init</span><span>(</span><span>start</span><span>:</span> <span>usize</span><span>,</span> <span>mut</span> <span>length</span><span>:</span> <span>usize</span><span>)</span> <span>{</span>
</span><span>    <span>static</span> <span>INIT</span><span>:</span> <span>AtomicBool</span> <span>=</span> <span>AtomicBool</span><span>::</span><span>new</span><span>(</span><span>false</span><span>)</span><span>;</span>
</span><span>
</span><span>    <span>assert</span><span>!</span><span>(</span><span>!</span><span>INIT</span><span>.</span><span>load</span><span>(</span><span>atomic</span><span>::</span><span>Ordering</span><span>::</span><span>Relaxed</span><span>)</span><span>)</span><span>;</span>
</span><span>
</span><span>    <span>let</span> <span>max_page_size</span> <span>=</span> <span>PAGE_SIZE</span> <span>*</span> <span>(</span><span>1</span> <span>&lt;&lt;</span> <span>MAX_ORDER</span><span>)</span><span>;</span>
</span><span>
</span><span>    <span>let</span> <span>start_aligned</span> <span>=</span> <span>align</span><span>(</span><span>start</span><span>,</span> <span>max_page_size</span><span>)</span><span>;</span>
</span><span>
</span><span>    <span>// Remove start pages that are not aligned</span>
</span><span>    <span>length</span> <span>-=</span> <span>start_aligned</span> <span>-</span> <span>start</span><span>;</span>
</span><span>    <span>// Remove end pages that don&#39;t fit in a max_page_size</span>
</span><span>    <span>length</span> <span>-=</span> <span>length</span> <span>%</span> <span>max_page_size</span><span>;</span>
</span><span>
</span><span>    <span>// We know know exactly how many 2**12 contiguous pages blocks are available on the system</span>
</span><span>    <span>let</span> <span>max_page_count</span> <span>=</span> <span>length</span> <span>/</span> <span>max_page_size</span><span>;</span>
</span><span>
</span><span>    <span>let</span> <span>page_count</span> <span>=</span> <span>length</span> <span>/</span> <span>PAGE_SIZE</span><span>;</span>
</span><span>    <span>let</span> <span>page_info_size</span> <span>=</span> <span>page_count</span> <span>*</span> <span>core</span><span>::</span><span>mem</span><span>::</span><span>size_of</span><span>::</span><span>&lt;</span><span>Page</span><span>&gt;</span><span>(</span><span>)</span><span>;</span>
</span><span>    <span>let</span> <span>required_pages_for_page_struct</span> <span>=</span> <span>page_info_size</span><span>.</span><span>div_ceil</span><span>(</span><span>max_page_size</span><span>)</span><span>;</span>
</span><span>
</span><span>    <span>// We reserve the start of RAM for our array of Page</span>
</span><span>    <span>let</span> <span>pages</span><span>:</span> <span>&amp;</span><span>[</span><span>Page</span><span>]</span> <span>=</span> <span>unsafe</span> <span>{</span>
</span><span>        <span>core</span><span>::</span><span>slice</span><span>::</span><span>from_raw_parts</span><span>(</span>
</span><span>            <span>(</span><span>start_aligned</span> <span>+</span> <span>RAM_VIRTUAL_START</span> <span>as</span> <span>usize</span><span>)</span> <span>as</span> <span>*</span><span>const</span> <span>_</span><span>,</span>
</span><span>            <span>page_count</span><span>,</span>
</span><span>        <span>)</span>
</span><span>    <span>}</span><span>;</span>
</span><span>
</span><span>    <span>// We iterate over each of the pages in the start of a 2**12 block of pages, </span>
</span><span>    <span>// and add it to the max order freelist</span>
</span><span>    <span>let</span> <span>mut</span> <span>free_pages</span> <span>=</span> <span>[</span><span>FreeList</span> <span>{</span> <span>head</span><span>:</span> <span>None</span> <span>}</span><span>;</span> <span>MAX_ORDER</span> <span>+</span> <span>1</span><span>]</span><span>;</span>
</span><span>    <span>for</span> <span>i</span> <span>in</span> <span>(</span><span>required_pages_for_page_struct</span><span>..</span><span>max_page_count</span><span>)</span><span>.</span><span>rev</span><span>(</span><span>)</span> <span>{</span>
</span><span>        <span>let</span> <span>page_idx</span> <span>=</span> <span>i</span> <span>*</span> <span>(</span><span>1</span> <span>&lt;&lt;</span> <span>MAX_ORDER</span><span>)</span><span>;</span>
</span><span>
</span><span>        <span>free_pages</span><span>[</span><span>MAX_ORDER</span><span>]</span><span>.</span><span>add</span><span>(</span><span>&amp;</span><span>pages</span><span>[</span><span>page_idx</span><span>]</span><span>)</span><span>;</span>
</span><span>    <span>}</span>
</span><span>
</span><span>    <span>let</span> <span>mut</span> <span>allocator</span> <span>=</span> <span>PAGE_ALLOCATOR</span><span>.</span><span>lock</span><span>(</span><span>)</span><span>;</span>
</span><span>
</span><span>    <span>allocator</span><span>.</span><span>free</span> <span>=</span> <span>free_pages</span><span>;</span>
</span><span>    <span>allocator</span><span>.</span><span>pages</span> <span>=</span> <span>pages</span><span>;</span>
</span><span>
</span><span>    <span>INIT</span><span>.</span><span>store</span><span>(</span><span>true</span><span>,</span> <span>atomic</span><span>::</span><span>Ordering</span><span>::</span><span>Relaxed</span><span>)</span><span>;</span>
</span><span><span>}</span>
</span></code></pre>

<p>To represent a page allocation we are going to use a <code>PageAllocation</code> structure, that acts as a RAII handle:</p>
<pre><code><span><span>pub</span> <span>struct</span> <span>PageAllocation</span><span>(</span><span>&amp;</span><span>&#39;</span><span>static</span> <span>[</span><span>Page</span><span>]</span><span>)</span><span>;</span>
</span><span>
</span><span><span>impl</span> <span>Deref</span> <span>for</span> <span>PageAllocation</span> <span>{</span>
</span><span>    <span>type</span> <span>Target</span> <span>=</span> <span>[</span><span>Page</span><span>]</span><span>;</span>
</span><span>
</span><span>    <span>fn</span> <span>deref</span><span>(</span><span>&amp;</span><span>self</span><span>)</span> <span>-&gt;</span> <span>&amp;</span><span>Self</span><span>::</span><span>Target</span> <span>{</span>
</span><span>        <span>self</span><span>.</span><span>0</span>
</span><span>    <span>}</span>
</span><span><span>}</span>
</span><span>
</span><span><span>impl</span> <span>Drop</span> <span>for</span> <span>PageAllocation</span> <span>{</span>
</span><span>    <span>fn</span> <span>drop</span><span>(</span><span>&amp;</span><span>mut</span> <span>self</span><span>)</span> <span>{</span>
</span><span>        <span>PAGE_ALLOCATOR</span><span>.</span><span>lock</span><span>(</span><span>)</span><span>.</span><span>free</span><span>(</span><span>self</span><span>.</span><span>0</span><span>)</span><span>;</span>
</span><span>    <span>}</span>
</span><span><span>}</span>
</span><span>
</span><span><span>pub</span> <span>fn</span> <span>alloc_pages</span><span>(</span><span>order</span><span>:</span> <span>usize</span><span>)</span> <span>-&gt;</span> <span>Option</span><span>&lt;</span><span>PageAllocation</span><span>&gt;</span> <span>{</span>
</span><span>    <span>if</span> <span>order</span> <span>&gt;</span> <span>MAX_ORDER</span> <span>{</span>
</span><span>        <span>return</span> <span>None</span><span>;</span>
</span><span>    <span>}</span>
</span><span>
</span><span>    <span>let</span> <span>pages</span> <span>=</span> <span>PAGE_ALLOCATOR</span><span>.</span><span>lock</span><span>(</span><span>)</span><span>.</span><span>alloc</span><span>(</span><span>order</span><span>)</span><span>?</span><span>;</span>
</span><span>
</span><span>    <span>Some</span><span>(</span><span>PageAllocation</span><span>(</span><span>pages</span><span>)</span><span>)</span>
</span><span><span>}</span>
</span></code></pre>
<p>We are now going to describe how to allocate &amp; free memory with a buddy allocator!</p>

<p>Allocations with a buddy allocator are quite simple:
When allocating an order <math display="inline"><mrow><mi>n</mi></mrow></math> we look if we have any available memory in the free list at index <math display="inline"><mrow><mi>n</mi></mrow></math> of our <code>PAGE_ALLOCATOR</code>.
If a page is available then we remove it from the free list, and return it.
If no page is available we try to allocate a page of order <math display="inline"><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></math>, and then split it in two parts (the two buddies!), adding the second half to the free list of index <math display="inline"><mrow><mi>n</mi></mrow></math> and returning the first half.</p>
<p>Note that this is a recursive algorithm, and it terminates whenever we can allocate a page at a given order because the free list is not empty, or when the free list at index <code>MAX_ORDER</code> is empty, and we try to pop from it.</p>
<p>Here is the code to implement this algorithm:</p>
<pre><code><span><span>impl</span> <span>PageAllocator</span> <span>{</span>
</span><span>    <span>fn</span> <span>alloc</span><span>(</span><span>&amp;</span><span>mut</span> <span>self</span><span>,</span> <span>order</span><span>:</span> <span>usize</span><span>)</span> <span>-&gt;</span> <span>Option</span><span>&lt;</span><span>&amp;</span><span>&#39;</span><span>static</span> <span>[</span><span>Page</span><span>]</span><span>&gt;</span> <span>{</span>
</span><span>        <span>match</span> <span>self</span><span>.</span><span>free</span><span>[</span><span>order</span><span>]</span><span>.</span><span>head</span><span>.</span><span>take</span><span>(</span><span>)</span> <span>{</span>
</span><span>            <span>Some</span><span>(</span><span>h</span><span>)</span> <span>=&gt;</span> <span>{</span>
</span><span>                <span>self</span><span>.</span><span>free</span><span>[</span><span>order</span><span>]</span><span>.</span><span>head</span> <span>=</span> <span>unsafe</span> <span>{</span> <span>(</span><span>*</span><span>h</span><span>.</span><span>state</span><span>.</span><span>get</span><span>(</span><span>)</span><span>)</span><span>.</span><span>free</span><span>.</span><span>next</span> <span>}</span><span>;</span>
</span><span>
</span><span>                <span>h</span><span>.</span><span>allocated</span><span>.</span><span>fetch_or</span><span>(</span><span>1</span> <span>&lt;&lt;</span> <span>order</span><span>,</span> <span>atomic</span><span>::</span><span>Ordering</span><span>::</span><span>Relaxed</span><span>)</span><span>;</span>
</span><span>
</span><span>                <span>Some</span><span>(</span><span>&amp;</span><span>self</span><span>.</span><span>pages</span><span>[</span><span>h</span><span>.</span><span>index</span><span>(</span><span>self</span><span>.</span><span>pages</span><span>)</span><span>..</span><span>h</span><span>.</span><span>index</span><span>(</span><span>self</span><span>.</span><span>pages</span><span>)</span> <span>+</span> <span>(</span><span>1</span> <span>&lt;&lt;</span> <span>order</span><span>)</span><span>]</span><span>)</span>
</span><span>            <span>}</span>
</span><span>            <span>None</span> <span>=&gt;</span> <span>{</span>
</span><span>                <span>if</span> <span>order</span> <span>==</span> <span>MAX_ORDER</span> <span>{</span>
</span><span>                    <span>None</span>
</span><span>                <span>}</span> <span>else</span> <span>{</span>
</span><span>                    <span>let</span> <span>larger</span> <span>=</span> <span>self</span><span>.</span><span>alloc</span><span>(</span><span>order</span> <span>+</span> <span>1</span><span>)</span><span>?</span><span>;</span>
</span><span>                    <span>let</span> <span>buddy</span> <span>=</span> <span>&amp;</span><span>larger</span><span>[</span><span>larger</span><span>.</span><span>len</span><span>(</span><span>)</span> <span>/</span> <span>2</span><span>]</span><span>;</span>
</span><span>                    <span>self</span><span>.</span><span>free</span><span>[</span><span>order</span><span>]</span><span>.</span><span>add</span><span>(</span><span>buddy</span><span>)</span><span>;</span>
</span><span>
</span><span>                    <span>larger</span><span>[</span><span>0</span><span>]</span>
</span><span>                        <span>.</span><span>allocated</span>
</span><span>                        <span>.</span><span>fetch_or</span><span>(</span><span>1</span> <span>&lt;&lt;</span> <span>order</span><span>,</span> <span>atomic</span><span>::</span><span>Ordering</span><span>::</span><span>Relaxed</span><span>)</span><span>;</span>
</span><span>
</span><span>                    <span>Some</span><span>(</span><span>&amp;</span><span>larger</span><span>[</span><span>0</span><span>..</span><span>larger</span><span>.</span><span>len</span><span>(</span><span>)</span> <span>/</span> <span>2</span><span>]</span><span>)</span>
</span><span>                <span>}</span>
</span><span>            <span>}</span>
</span><span>        <span>}</span>
</span><span>    <span>}</span>
</span><span><span>}</span>
</span></code></pre>

<p>Freeing allocations is conceptually simple, but requires a bit more code to implement.
The main idea is that when we free a page of order <math display="inline"><mrow><mi>n</mi></mrow></math> we try to see if the buddy (meaning the part that was split up during the allocation) is free too.
If both are free then we can merge the two pages of order <math display="inline"><mrow><mi>n</mi></mrow></math> to create a page of order <math display="inline"><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></math>.</p>
<p>We can then recursively free the page of order <math display="inline"><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></math>, until we arrive at a page of order <code>MAX_ORDER</code>, where we don&#39;t have buddies anymore.</p>
<p>The code that does this is the following:</p>
<pre><code><span><span>impl</span> <span>PageAllocator</span> <span>{</span>
</span><span>    <span>fn</span> <span>free</span><span>(</span><span>&amp;</span><span>mut</span> <span>self</span><span>,</span> <span>pages</span><span>:</span> <span>&amp;</span><span>&#39;</span><span>static</span> <span>[</span><span>Page</span><span>]</span><span>)</span> <span>{</span>
</span><span>        <span>// Because order is a power of two this is guaranteed to give the log2</span>
</span><span>        <span>let</span> <span>order</span> <span>=</span> <span>pages</span><span>.</span><span>len</span><span>(</span><span>)</span><span>.</span><span>trailing_zeros</span><span>(</span><span>)</span> <span>as</span> <span>usize</span><span>;</span>
</span><span>
</span><span>        <span>// Mark the page as free</span>
</span><span>        <span>let</span> <span>prev</span> <span>=</span> <span>pages</span><span>[</span><span>0</span><span>]</span>
</span><span>            <span>.</span><span>allocated</span>
</span><span>            <span>.</span><span>fetch_and</span><span>(</span><span>!</span><span>(</span><span>1</span> <span>&lt;&lt;</span> <span>order</span><span>)</span><span>,</span> <span>atomic</span><span>::</span><span>Ordering</span><span>::</span><span>Relaxed</span><span>)</span><span>;</span>
</span><span>        <span>assert</span><span>!</span><span>(</span><span>prev</span> <span>&amp;</span> <span>(</span><span>1</span> <span>&lt;</span><span>&lt;</span> <span>order</span><span>)</span> <span>!</span><span>=</span> <span>0</span><span>)</span><span>;</span>
</span><span>
</span><span>        <span>// If it&#39;s a max order page no merging to be done</span>
</span><span>        <span>if</span> <span>order</span> <span>&lt;</span> <span>MAX_ORDER</span> <span>{</span>
</span><span>            <span>/// Calculate the index of the page using the address of pages[0]</span>
</span><span>            <span>let</span> <span>index</span> <span>=</span> <span>pages</span><span>[</span><span>0</span><span>]</span><span>.</span><span>index</span><span>(</span><span>self</span><span>.</span><span>pages</span><span>)</span><span>;</span>
</span><span>            <span>// Is this the first page or the second page?</span>
</span><span>            <span>//</span>
</span><span>            <span>// There exists a trick to find the buddy with a bit manipulation if sizes are a </span>
</span><span>            <span>// power of two, but as I don&#39;t exactly understand it I have not implemented it</span>
</span><span>            <span>let</span> <span>(</span><span>first_idx</span><span>,</span> <span>buddy_index</span><span>)</span> <span>=</span> <span>match</span> <span>index</span> <span>%</span> <span>(</span><span>1</span> <span>&lt;&lt;</span> <span>(</span><span>order</span> <span>+</span> <span>1</span><span>)</span><span>)</span> <span>{</span>
</span><span>                <span>0</span> <span>=&gt;</span> <span>(</span><span>index</span><span>,</span> <span>index</span> <span>+</span> <span>(</span><span>1</span> <span>&lt;&lt;</span> <span>order</span><span>)</span><span>)</span><span>,</span>
</span><span>                _ <span>=&gt;</span> <span>{</span>
</span><span>                    <span>let</span> <span>first</span> <span>=</span> <span>index</span> <span>-</span> <span>(</span><span>1</span> <span>&lt;&lt;</span> <span>order</span><span>)</span><span>;</span>
</span><span>                    <span>(</span><span>first</span><span>,</span> <span>first</span><span>)</span>
</span><span>                <span>}</span>
</span><span>            <span>}</span><span>;</span>
</span><span>
</span><span>            <span>let</span> <span>buddy</span> <span>=</span> <span>&amp;</span><span>self</span><span>.</span><span>pages</span><span>[</span><span>buddy_index</span><span>]</span><span>;</span>
</span><span>            <span>// Find if the buddy is currently allocated</span>
</span><span>            <span>let</span> <span>buddy_allocation</span> <span>=</span> <span>buddy</span><span>.</span><span>allocated</span><span>.</span><span>load</span><span>(</span><span>atomic</span><span>::</span><span>Ordering</span><span>::</span><span>Relaxed</span><span>)</span><span>;</span>
</span><span>
</span><span>            <span>if</span> <span>buddy_allocation</span> <span>&amp;</span> <span>(</span><span>1</span> <span>&lt;&lt;</span> <span>order</span><span>)</span> <span>==</span> <span>0</span> <span>{</span>
</span><span>                <span>// Remove the buddy from it&#39;s freelist. Because we use a simply linked list we need</span>
</span><span>                <span>// to iterate over the list to it.</span>
</span><span>                <span>// I may implement a doubly linked list at a further date to alleviate this, but</span>
</span><span>                <span>// it is much more unsafe to do in rust</span>
</span><span>                <span>self</span><span>.</span><span>free</span><span>[</span><span>order</span><span>]</span>
</span><span>                    <span>.</span><span>remove</span><span>(</span><span>buddy</span><span>)</span>
</span><span>                    <span>.</span><span>expect</span><span>(</span><span>&#34;buddy was not in the free list while it was un-allocated&#34;</span><span>)</span><span>;</span>
</span><span>
</span><span>                <span>buddy</span>
</span><span>                    <span>.</span><span>allocated</span>
</span><span>                    <span>.</span><span>fetch_and</span><span>(</span><span>!</span><span>(</span><span>1</span> <span>&lt;&lt;</span> <span>order</span><span>)</span><span>,</span> <span>atomic</span><span>::</span><span>Ordering</span><span>::</span><span>Relaxed</span><span>)</span><span>;</span>
</span><span>
</span><span>                <span>// Recursively free the aggregated large page</span>
</span><span>                <span>return</span> <span>self</span><span>.</span><span>free</span><span>(</span><span>&amp;</span><span>self</span><span>.</span><span>pages</span><span>[</span><span>first_idx</span><span>..</span><span>first_idx</span> <span>+</span> <span>(</span><span>1</span> <span>&lt;&lt;</span> <span>(</span><span>order</span> <span>+</span> <span>1</span><span>)</span><span>)</span><span>]</span><span>)</span><span>;</span>
</span><span>            <span>}</span>
</span><span>        <span>}</span>
</span><span>
</span><span>        <span>self</span><span>.</span><span>free</span><span>[</span><span>order</span><span>]</span><span>.</span><span>add</span><span>(</span><span>&amp;</span><span>pages</span><span>[</span><span>0</span><span>]</span><span>)</span><span>;</span>
</span><span>    <span>}</span>
</span><span><span>}</span>
</span></code></pre>
<p>With this we can now handle allocations &amp; de-allocations of blocks of pages, up to 16 MiB.
Note while the buddy allocator handles external fragmentation well (due to us always re-aggregating the memory), our allocator has issues with internal fragmentation.
Indeed, even if we need to allocate a single byte we need to allocate a 4 KiB page!
This is often solved using slab allocators, but we won&#39;t be implementing one right now, as we try to keep the complexity to a minimum if we don&#39;t encounter any issues.</p>
</div></div>
  </body>
</html>
