<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://entropicthoughts.com/parser-combinators-beat-regexes">Original</a>
    <h1>Parser Combinators Beat Regexes</h1>
    
    <div id="readability-page-1" class="page"><div>
                <p>
Someone online was solving Advent of Code problems, and had a question about
<a href="https://adventofcode.com/2024/day/3">last years’ day 3</a>. They had a working solution using regular expressions
(regexes) on <code>String</code> values, but they wanted to use <code>ByteString</code> values instead
for performance reasons. They were surprised, however, that there seems to be a
lack of community cohesion around regex libraries in Haskell.
</p>

<p>
There’s a reason for that. We generally don’t use regexes in Haskell. We use
parser combinators instead, because they are almost always better. In other
languages, it would be considered overkill to write a full parser when a simple
regex can do the same thing. In Haskell, writing a parser is no big deal. We
just do it and move on with our lives.
</p>
<section id="outline-container-the-regex-solution">

<div id="text-org923fa84">
<p>
The first part of the Advent of Code problem is well suited for a regex-based
solution. Here’s what such a solution might look like in Haskell. It uses the
<i>pcre-heavy</i> Haskell library which in turn calls out to the system-wide <abbr>pcre</abbr>
C library for actually compiling and running the regex.
</p>

<p><label>In[1]:</label></p><div>
<pre><span>{-# LANGUAGE QuasiQuotes #-}</span>

<span>module</span> <span>Main</span> <span>where</span>

<span>import</span>           <span>Data.ByteString</span>       (<span>ByteString</span>)
<span>import</span> <span>qualified</span> <span>Data.ByteString.Char8</span> <span>as</span> <span>Char8</span>
<span>import</span>           <span>Data.Monoid</span>           (<span>Sum</span> (<span>..</span>))
<span>import</span> <span>qualified</span> <span>Text.Regex.PCRE.Heavy</span> <span>as</span> <span>Re</span>
<span>import</span>           <span>Text.Regex.PCRE.Heavy</span> (re)

<span>test_input</span> <span>::</span> <span>ByteString</span>
<span>test_input</span> <span>=</span> Char8.pack <span>&#34;xmul(2,4)%&amp;mul[3,7]!@^do_not_mul(5,5)+mul(32,64]then(mul(11,8)mul(8,5))&#34;</span>

<span>regex_matches</span> <span>::</span> <span>ByteString</span> <span>-&gt;</span> <span>Int</span>
<span>regex_matches</span> input <span>=</span>
  <span>let</span>
    <span>-- </span><span>Get a list of regex matches with numbers extracted.</span>
    <span>-- </span><span>The &#39;re&#39; quasi-quoter compiles the regex at compile</span>
    <span>-- </span><span>time, avoiding the runtime cost of that.</span>
    hits <span>=</span> Re.scan [re<span>|mul\((\d+),(\d+)\)|</span>] input
    <span>-- </span><span>Take one hit and compute its product, converting the</span>
    <span>-- </span><span>stringified numbers into actual numbers, then wrapping</span>
    <span>-- </span><span>it up as a term in a sum.</span>
    compute (<span>_</span>, [a, b]) <span>=</span>
      <span>Sum</span> (read (Char8.unpack a) <span>*</span> read (Char8.unpack b))
  <span>in</span>
    <span>-- </span><span>Fold up all terms in the sum into a single number.</span>
    getSum (foldMap compute hits)

<span>main</span> <span>::</span> <span>IO</span> <span>()</span>
<span>main</span> <span>=</span> <span>do</span>
  print (regex_matches test_input)
</pre>
</div>

<p>
This does the job and returns the expected sum of 161. If we run this on just
under a megabyte of input data, it takes 19 seconds on my machine, spending
almost all of that time inside the <abbr>pcre</abbr> library.<span><sup>1</sup> Though this is a little
strange, because if I do the same thing in Perl, it takes 0.02 seconds. I wish I
had time to investigate what goes wrong.</span>
</p>

<p>
But the main thing I dislike about this is that there’s a very strong implicit
contract between the regex and the <code>compute</code> function. The <code>compute</code> function
assumes that there were exactly two capturing groups and that they are strings
that can safely be converted to integers. This is true, but there’s nothing in
the code making that guarantee. If those assumptions become violated a year from
now, that would not be a compiler error but an exception that interrupts the
production service at 3 <abbr>am</abbr> the day before an important customer meeting.
</p>
</div>
</section>
<section id="outline-container-the-parser-solution">

<div id="text-orgbc5cd54">
<p>
For the sort of problem we are facing here, the parser-based solution does look
more complicated at first glance. Part of the reason is that the regex library
comes with a method that gets all matches, regardless of their position in the
input. Parser combinators are meant to be written to consume all of the input,
so we have to manually write the parser code that iterates the input and finds
the next match.
</p>

<p>
This solution uses the <i>attoparsec</i> library, which is made to work with
<code>ByteString</code> values specifically, since the person who asked the question seemed
to care about performance.
</p>


<p><label>In[2]:</label></p><div>
<pre><span>module</span> <span>Main</span> <span>where</span>

<span>import</span>           <span>Control.Applicative</span>              ((<span>&lt;|&gt;</span>))
<span>import</span> <span>qualified</span> <span>Data.Attoparsec.ByteString.Char8</span> <span>as</span> <span>Parser</span>
<span>import</span>           <span>Data.ByteString</span>                  (<span>ByteString</span>)
<span>import</span> <span>qualified</span> <span>Data.ByteString.Char8</span>            <span>as</span> <span>Char8</span>
<span>import</span> <span>qualified</span> <span>Data.Either</span>                      <span>as</span> <span>Either</span>

<span>test_input</span> <span>::</span> <span>ByteString</span>
<span>test_input</span> <span>=</span> Char8.pack <span>&#34;xmul(2,4)%&amp;mul[3,7]!@^do_not_mul(5,5)+mul(32,64]then(mul(11,8)mul(8,5))&#34;</span>

<span>parser_matches</span> <span>::</span> <span>ByteString</span> <span>-&gt;</span> <span>Int</span>
<span>parser_matches</span> input <span>=</span>
  <span>let</span>
    <span>-- </span><span>Parse a mul instruction. Starts by reading the opening</span>
    <span>-- </span><span>sequence, then the first value, then the separator,</span>
    <span>-- </span><span>then the second value, then the terminator. Finally,</span>
    <span>-- </span><span>it returns the product of the pair of values.</span>
    mul <span>=</span> <span>do</span>
      Parser.string (Char8.pack <span>&#34;mul(&#34;</span>)
      first <span>&lt;-</span> Parser.decimal
      Parser.char <span>&#39;,&#39;</span>
      second <span>&lt;-</span> Parser.decimal
      Parser.char <span>&#39;)&#39;</span>
      pure (first <span>*</span> second)

    <span>-- </span><span>Parse the next mul instruction. Start by trying to</span>
    <span>-- </span><span>parse a mul instruction immediately. If that fails,</span>
    <span>-- </span><span>instead (1) advance the parser one step, and</span>
    <span>-- </span><span>(2) try again.</span>
    next <span>=</span>
      mul <span>&lt;|&gt;</span> <span>do</span>
        Parser.anyChar
        next

    <span>-- </span><span>Scan the entire input for all mul instructions,</span>
    <span>-- </span><span>returning the sum of their products.</span>
    scan <span>=</span> <span>do</span>
      muls <span>&lt;-</span> Parser.many1 next
      pure (sum muls)

  <span>in</span>
    <span>-- </span><span>Run the parser over the input,</span>
    <span>-- </span><span>handling a parse error by throwing</span>
    <span>-- </span><span>an exception.</span>
    Either.fromRight (error <span>&#34;Failed to parse input.&#34;</span>)
      (Parser.parseOnly scan input)

<span>main</span> <span>::</span> <span>IO</span> <span>()</span>
<span>main</span> <span>=</span> <span>do</span>
  print (parser_matches test_input)
</pre>
</div>

<p>
This is written in what one might call <i>direct, monadic</i> style, doing just what
was requested in the first part of the Advent of Code puzzle, using <code>do</code>
notation for sequencing. We could rewrite it to be neater, but we will resist
refactoring for now; we never know what twist in the requirements will be
introduced in the second part of an Advent of Code puzzle. (The curious can
check the refactoring out in the appendix.)
</p>

<p>
This did involve more up-front writing, but there are some benefits. Granted, we
use <code>Either.fromRight</code> to throw away all the useful error reporting we could get
from <i>attoparsec</i>, but if we didn’t do that we would get more useful error
messages when things went wrong. We also didn’t have to manually convert strings
to integers, or blindly hope that the right number of integers were parsed. The
compiler checks all those assumptions for us.
</p>



<p>
When we run this on the same megabyte of input, it takes 0.07 seconds. This is
within a magnitude of the Perl regex, but we get all the benefits of a more
expressive language too. As we will see shortly, another big benefit of parsers
is that they are more flexible to adapt to future requirements.
</p>
</div>
</section>
<section id="outline-container-making-the-parser-stateful">

<div id="text-org5596867">
<p>
The next part of the Advent of Code puzzle involves interpreting instructions
called <code>do()</code> and <code>don&#39;t()</code> which turn on and off the contributions of <code>mul</code>
instructions to the sum. As we parse, we now need to keep track of one bit of
state. This is a nightmare for regexes to deal with, because they recognise
regular languages, and regular languages are literally stateless
languages.<span><sup>2</sup> There’s more nuance, of course, but as a first approximation.
Technically regular languages are those that can be recognised by a finite state
automaton, and if there are a finite number of states (as there are in this
case) then all of them can be encoded in an <abbr>fsa</abbr> but let’s not get pedantic
here.</span>
</p>

<p>
But with the parser-based solution, we can lift it into a state transformer, and
we get a stateful parser.<span><sup>3</sup> Note that in a serious application, we might have
lexing and parsing as separate steps, but parser combinators give us the freedom
to combine both steps for tiny parsers like this.</span>
</p>

<p><label>In[3]:</label></p><div>
<pre><span>module</span> <span>Main</span> <span>where</span>

<span>import</span>           <span>Control.Applicative</span>              (asum, (<span>&lt;|&gt;</span>))
<span>import</span> <span>qualified</span> <span>Control.Monad.State.Class</span>        <span>as</span> <span>State</span>
<span>import</span> <span>qualified</span> <span>Control.Monad.State.Strict</span>       <span>as</span> <span>State</span>
<span>import</span> <span>qualified</span> <span>Data.Attoparsec.ByteString.Char8</span> <span>as</span> <span>Parser</span>
<span>import</span>           <span>Data.Bool</span>                        (bool)
<span>import</span>           <span>Data.ByteString</span>                  (<span>ByteString</span>)
<span>import</span> <span>qualified</span> <span>Data.ByteString</span>                  <span>as</span> <span>ByteString</span>
<span>import</span> <span>qualified</span> <span>Data.ByteString.Char8</span>            <span>as</span> <span>Char8</span>
<span>import</span> <span>qualified</span> <span>Data.Either</span>                      <span>as</span> <span>Either</span>

<span>test_input</span> <span>::</span> <span>ByteString</span>
<span>test_input</span> <span>=</span> Char8.pack <span>&#34;xmul(2,4)&amp;mul[3,7]!^don&#39;t()_mul(5,5)+mul(32,64](mul(11,8)undo()?mul(8,5))&#34;</span>

<span>parser_matches</span> <span>::</span> <span>ByteString</span> <span>-&gt;</span> <span>Int</span>
<span>parser_matches</span> input <span>=</span>
  <span>let</span>
    <span>-- </span><span>Upon successfully parsing a do instruction,</span>
    <span>-- </span><span>enable contribution of mul instructions.</span>
    enable <span>=</span> <span>do</span>
      State.lift (Parser.string (Char8.pack <span>&#34;do()&#34;</span>))
      State.put <span>True</span>

    <span>-- </span><span>Upon successfully parsing a don&#39;t instruction,</span>
    <span>-- </span><span>disable contribution of mul instructions.</span>
    disable <span>=</span> <span>do</span>
      State.lift (Parser.string (Char8.pack <span>&#34;don&#39;t()&#34;</span>))
      State.put <span>False</span>

    <span>-- </span><span>Parse a mul instruction just as before, except</span>
    <span>-- </span><span>now lifted into a stateful operation.</span>
    mul <span>=</span> State.lift <span>$</span> <span>do</span>
      Parser.string (Char8.pack <span>&#34;mul(&#34;</span>)
      first <span>&lt;-</span> Parser.decimal
      Parser.char <span>&#39;,&#39;</span>
      second <span>&lt;-</span> Parser.decimal
      Parser.char <span>&#39;)&#39;</span>
      pure (first <span>*</span> second)

    <span>-- </span><span>If a do or don&#39;t instruction is parsed,</span>
    <span>-- </span><span>continue searching for the next mul.</span>
    <span>--</span>
    <span>-- </span><span>If a mul is encountered, check the value of</span>
    <span>-- </span><span>the state. If muls are enabled, leave it</span>
    <span>-- </span><span>unaltered (id), but if muls are disabled,</span>
    <span>-- </span><span>force its value to be zero (const 0).</span>
    <span>--</span>
    <span>-- </span><span>If no instruction is recognised, step</span>
    <span>-- </span><span>forward one character and try again.</span>
    next <span>=</span> asum
      [ enable <span>*&gt;</span> next
      , disable <span>*&gt;</span> next
      , bool (const 0) id <span>&lt;$&gt;</span> State.get <span>&lt;*&gt;</span> mul
      , State.lift Parser.anyChar <span>*&gt;</span> next
      ]

    scan <span>=</span> sum <span>&lt;$&gt;</span> Parser.many1 next

  <span>in</span>
    <span>-- </span><span>Start off evaluation with mul contributions enabled.</span>
    Either.fromRight (error <span>&#34;Failed to parse input.&#34;</span>) <span>$</span>
      Parser.parseOnly (State.evalStateT scan <span>True</span>) input

<span>main</span> <span>::</span> <span>IO</span> <span>()</span>
<span>main</span> <span>=</span> <span>do</span>
  print (parser_matches test_input)
</pre>
</div>

<p>
One has to be a little careful when making specifically <i>attoparsec</i> parsers
stateful, because attoparsec is very happy to backtrack in the input on failure,
but it will not undo the state changes that were caused by the initial parsing
attempt. Thus, when making attoparsec parsers stateful, we have to write them
such that they never backtrack past a state change.<span><sup>4</sup> One could imagine an
attoparsec primitive called something like <code>cut</code> (inspired by Prolog) which
stops backtracking past a certain point. This could be used in combination with
state changes to make sure the parser never backtracks past that change. Such a
primitive would be fairly easy to write but it needs to be supplied by the
library – it cannot be written by library users.</span> On the positive side, avoiding
long sequences of backtracking is also good for memory usage and performance, so
we should do that anyway.
</p>

<p>
The alert reader might notice that we used the parser result to store the value
of the sum, but stored the contribution bit in the state. We could have done it any
other way. We could store both sum and bit in state, or both in the result, or
the other way around with the sum in the state and the bit in the result. This
was just the quickest way I could think of to get it up and running. Haskell
makes it cheap and safe to refactor later.
</p>

<p>
The above runs in 0.12 seconds on about a megabyte of input. I won’t even try to
write a regex-based solution for the second part, but I’m fairly confident it
would be slower, less flexible, and more difficult to maintain.
</p>
</div>
</section>
<section id="outline-container-appendix-a--refactoring-the-direct--monadic-parser">

<div id="text-org73fd703">
<p>
The <code>mul</code> instruction is really an instance of a more general “delimited pair of
values” parser. We can extract this into its own function.
</p>

<p><label>In[4]:</label></p><div>
<pre><span>pair</span> <span>::</span> <span>Parser</span> open <span>-&gt;</span> <span>Parser</span> sep <span>-&gt;</span> <span>Parser</span> close <span>-&gt;</span> <span>Parser</span> value <span>-&gt;</span> <span>Parser</span> (value, value)
<span>pair</span> open sep close value <span>=</span>
  liftA2 <span>(,)</span> (open <span>*&gt;</span> value) (sep <span>*&gt;</span> value <span>&lt;*</span> close)
</pre>
</div>

<p>
This takes three parsers for the opening sequence, separator, and closing
sequence, and then a parser for the actual values, and constructs a parser that
returns a pair of values. We can use this to parse the <code>mul</code> instruction, but
also any other instruction based on a pair of values.
</p>

<p>
Similarly, we were missing a function that returns all matches for a parser,
regardless of where in the input they were located. The regex library had that
function, but it does not come out of the box with <i>attoparsec</i>. We can make that.
</p>

<p><label>In[5]:</label></p><div>
<pre><span>scan_all</span> <span>::</span> <span>Parser</span> a <span>-&gt;</span> <span>Parser</span> [a]
<span>scan_all</span> p <span>=</span>
  <span>let</span> next <span>=</span> p <span>&lt;|&gt;</span> Parser.anyChar <span>*&gt;</span> next
  <span>in</span> Parser.many1 next
</pre>
</div>

<p>
With these parts of the code broken out into their own functions, the final
parser can be written in a more <i>applicative</i> style as
</p>

<p><label>In[6]:</label></p><div>
<pre><span>parser_matches</span> <span>::</span> <span>ByteString</span> <span>-&gt;</span> <span>Int</span>
<span>parser_matches</span> input <span>=</span>
  <span>let</span>
    mul <span>=</span> uncurry (<span>*</span>) <span>&lt;$&gt;</span> pair
      (Parser.string (Char8.pack <span>&#34;mul(&#34;</span>))
      (Parser.char <span>&#39;,&#39;</span>)
      (Parser.char <span>&#39;)&#39;</span>)
      Parser.decimal

    result <span>=</span> sum <span>&lt;$&gt;</span> scan_all mul
  <span>in</span>
    Either.fromRight (error <span>&#34;Failed to parse input.&#34;</span>)
      (Parser.parseOnly result input)
</pre>
</div>

<p>
This reads quite nicely: the result parser is the sum of all <code>mul</code> instructions,
which are specified as the product of a pair of values with specific delimiters.
</p>
</div>
</section>

            </div></div>
  </body>
</html>
