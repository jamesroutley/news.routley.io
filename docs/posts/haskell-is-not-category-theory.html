<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://pema.dev/2023/02/01/haskell-not-ct/">Original</a>
    <h1>Haskell is not category theory</h1>
    
    <div id="readability-page-1" class="page"><div>
        <article>
  
  <time datetime="2023-02-01T00:00:00+00:00">01 Feb 2023</time>
  

<p>If you have hung out in Haskell communities, you might have heard people mentioning concepts from the mathematical field of category theory, perhaps even claiming that Haskell is built upon category-theoretic foundations.</p>

<p>There is some truth to this, but I think it is more accurate to say that certain abstractions in Haskell are <em>inspired</em> by category theory. When learning Haskell, I took this connection too literally and ended up confusing the hell out of myself. This post is aimed at my former self and aims to clear up some confusions I came across while trying to make sense of it all.</p>

<p>Before we get started, I want to get a few important disclaimers out of the way:</p>

<ul>
  <li>This is not a Haskell tutorial and will assume some familiarity with the language. However, if you are proficient with any functional language, especially if it is a dialect of ML, you should be able to follow along.</li>
  <li>You do <strong>not</strong> need to know any category theory to learn and become proficient with Haskell. If you are looking to learn the language, I recommend <a href="http://learnyouahaskell.com/">Learn You A Haskell</a>.</li>
  <li>I’ll try not to assume you know any category theory already.</li>
  <li>I am not a category theorist. I consider myself a novice. This is just my attempt of making sense of the parts I am familiar with, so take it with a grain of salt.</li>
  <li>As with several of my posts in the past, this is going to be structured more like a collection of notes, than as a coherent story.</li>
</ul>



<blockquote>
  <p>Note: If you know any category theory, you can probably skip this section.</p>
</blockquote>

<p>The primary object of study in category theory is the category. A category consists of:</p>

<ul>
  <li>A collection of <em>objects</em>.</li>
  <li>A collection of <em>morphisms</em>, also known as <em>arrows</em>, which map from one object to another. I’ll write these as \(f: a \rightarrow b\). Here, \(f\) is an arrow from the object \(a\) to the object \(b\).</li>
  <li>A binary operation called <em>composition</em>, which combines arrows together. I’ll write composition as \(x \bullet y\) where \(x\) and \(y\) are arrows.</li>
</ul>

<p>A few additional criteria must be satisfied:</p>

<ul>
  <li>Whenever we have an arrow from \(a\) to \(b\), and an arrow from \(b\) to \(c\), there is also an arrow from \(a\) to \(c\) which is the composition of the two. Thus, \((x: b \rightarrow c) \bullet (y: a \rightarrow b) = (z: a \rightarrow c)\).</li>
  <li>Composition is associative, so \(x \bullet (y \bullet z)\) = \((x \bullet y) \bullet z\).</li>
  <li>For every object \(a\), there is an identity arrow \(I_a: a \rightarrow a\) which just maps from the object to itself.</li>
  <li>Composition with an identity arrow has no effect, so \(I \bullet f = f \bullet I = f\).</li>
</ul>

<p>This is intentionally pretty abstract. In the next section, I’ll give a concrete example of a category.</p>



<p>A concrete example of a category is the category of Haskell types, typically called \(Hask\). In this category:</p>

<ul>
  <li>Our objects are types, such as <code>Boolean</code>, <code>String</code>, <code>[a]</code>, and so on.</li>
  <li>Our arrows are just plain old functions. They take a value of one type and map it to a value of another.</li>
  <li>Our composition operator is just function composition ‘<code>.</code>’.</li>
  <li>The identity arrow for any type is the identity function, <code>id</code>.</li>
</ul>

<p>All the criteria for a category are satisfied:</p>

<ul>
  <li>If we have a function <code>x :: b -&gt; c</code> and a function <code>y :: a -&gt; b</code>, then <code>x . y</code> will be a function of type <code>a -&gt; c</code>.</li>
  <li>Function composition is associative, <code>(x . y) . z == x . (y . z)</code>.</li>
  <li>Composing the identity function with any other function has no effect, <code>id . f == f . id == f</code>.</li>
</ul>

<p>When we are talking about Haskell from a category-theoretic lens, we are almost always talking about \(Hask\). Since types are more or less sets of possible values, this category is closely related to the category of sets, typically denoted \(Set\).</p>



<blockquote>
  <p>Note: If you are not interested in extreme pedantry, feel free to skip this section as well.</p>
</blockquote>

<p>I lied. \(Hask\) is technically not a category. There are several reasons for this, but I’ll focus on just one of them.</p>

<p>Haskell has the notion of a <em>bottom</em> value (uwu). Bottom values are a member of <em>any</em> type. A bottom value is trivial to define - we just recurse infinitely!</p>

<div><div><pre><code><span>bottom</span> <span>::</span> <span>a</span>
<span>bottom</span> <span>=</span> <span>bottom</span>
</code></pre></div></div>

<p>We can use it in place of <em>any</em> type:</p>

<div><div><pre><code><span>addNums</span> <span>::</span> <span>Num</span> <span>a</span> <span>=&gt;</span> <span>a</span> <span>-&gt;</span> <span>a</span> <span>-&gt;</span> <span>a</span>
<span>addNums</span> <span>a</span> <span>b</span> <span>=</span> <span>a</span> <span>+</span> <span>b</span>

<span>-- no problems here!</span>
<span>addNums</span> <span>bottom</span> <span>3</span>
</code></pre></div></div>

<p>This value is allowed to be a member of any type because we can never fully evaluate it, so we will never actually violate any type constraint!</p>

<p>Haskell is a lazily evaluated language but provides a mechanism for strict evaluation through the <code>seq</code> combinator. The expression <code>seq a b</code> evaluates <code>b</code>, but will force <code>a</code> to be strictly evaluated.</p>

<p>With all of this in mind, let’s revisit our criteria for a category. It must hold that composing the identity function with any other function has no effect - <code>id . a == a</code>. Consider the following Haskell program:</p>

<div><div><pre><code><span>foo</span> <span>::</span> <span>a</span> <span>-&gt;</span> <span>b</span>
<span>foo</span> <span>=</span> <span>foo</span>

<span>main</span> <span>::</span> <span>IO</span> <span>()</span>
<span>main</span> <span>=</span> <span>do</span>
    <span>print</span> <span>(</span><span>seq</span> <span>(</span><span>id</span> <span>.</span> <span>foo</span><span>)</span> <span>1337</span><span>)</span>
    <span>print</span> <span>(</span><span>seq</span> <span>foo</span> <span>1337</span><span>)</span>
</code></pre></div></div>

<p>This program will output:</p>



<p>So we can tell the difference between <code>foo</code> and <code>id . foo</code>, breaking the criteria! Oh, and by the way <code>&lt;&lt;loop&gt;&gt;</code> is just Haskell’s way to tell us “this is definitely going to loop forever”.</p>



<p>Another common object in category theory is a <em>functor</em>. A functor is a mapping (arrow) from a category to a category. I’ll write these as \(F: A \rightarrow B\) where \(F\) is a functor from category \(A\) to category \(B\). Such a functor will map:</p>

<ul>
  <li>Each object \(a\) in category \(A\) to an object \(F(a)\) in category \(B\)</li>
  <li>Each arrow \(x: a \rightarrow b\) in category \(A\) to an arrow \(F(x) : F(a) \rightarrow F(b)\)</li>
</ul>

<p>In the above, \(F(a)\) should be read as “the result of applying functor F to element a”, if \(a\) is an object, we get an object back, and if \(a\) is an arrow, we get an arrow back. You can view functors as a kind of polymorphic function on elements (be they objects or arrows) in a category.</p>

<p>A simple example of a functor is the <em>identity functor</em>, which does … wait for it … absolutely nothing! Every object and arrow in \(A\) is mapped to the same object and arrow in \(B\). Of course, an identity functor from \(A\) to \(B\) can only exist if \(A\) and \(B\) are the same since the mapping must be valid for <em>all</em> objects in \(A\). We call functors from a category to that same category <em>endofunctors</em>.</p>

<p>Haskell’s standard library includes a typeclass (like a trait in Rust, or a C# interface on steroids) called <code>Functor</code>. It looks like this:</p>

<div><div><pre><code><span>-- Functor typeclass declaration</span>
<span>class</span> <span>Functor</span> <span>f</span> <span>where</span>
  <span>fmap</span> <span>::</span> <span>(</span><span>a</span> <span>-&gt;</span> <span>b</span><span>)</span> <span>-&gt;</span> <span>f</span> <span>a</span> <span>-&gt;</span> <span>f</span> <span>b</span>
</code></pre></div></div>

<p>Many built-in types implement this typeclass, such as lists and <code>Maybe</code>’s (optional values):</p>

<div><div><pre><code><span>fmap</span> <span>(</span><span>+</span><span>2</span><span>)</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>]</span> <span>==</span> <span>[</span><span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>]</span>
<span>fmap</span> <span>(</span><span>*</span><span>5</span><span>)</span> <span>(</span><span>Just</span> <span>3</span><span>)</span> <span>==</span> <span>Just</span> <span>6</span>
<span>fmap</span> <span>(</span><span>-</span><span>10</span><span>)</span> <span>Nothing</span> <span>==</span> <span>Nothing</span>
</code></pre></div></div>

<p>If you are anything like me when I was learning Haskell, you might be tempted to assume that Haskell’s <code>Functor</code> is equivalent to a functor from category theory, but in fact, it is something much more restricted. Perhaps the most obvious difference is that every Haskell <code>Functor</code> is really an <em>endofunctor on \(Hask\)</em>, since \(Hask\) is the only category we can talk about in Haskell. What other differences are there, though?</p>

<p>Recall that objects in \(Hask\) are types, and arrows are functions. A proper functor \(F\) would then have to consist of:</p>

<ul>
  <li>A mapping from a type <code>a</code> to a type <code>F(a)</code></li>
  <li>A mapping from functions of type <code>a -&gt; b</code> to functions of type <code>F(a) -&gt; F(b)</code></li>
</ul>

<p>Looking at the definition of <code>fmap</code>, this pretty clearly implements the second of the 2 mappings. But what about the first one? This would have to be a function taking a type as input, and returning a type as output - but Haskell cannot treat types as values directly, so we cannot write such a function!</p>

<blockquote>
  <p>Note: It is only partially true that Haskell has no type-level functions. With GHC extensions such as TypeFamilies, we can get something like this.</p>
</blockquote>

<p>Instead, we’ll have to settle for the next best thing - type constructors. We can view a datatype like this:</p>



<p>As a sort of type-level function from any type to a subset of all types. Specifically those with the shape <code>forall a. Foo a</code>. This is the missing mapping - the type constructors implementing the <code>Functor</code> typeclass.</p>

<p>To illustrate why this makes Haskell’s <code>Functor</code> a more limited abstraction than a full-blown category-theoretic endofunctor, let’s try to implement the dead simple identity functor mentioned earlier in this section. This is the best we can do:</p>

<div><div><pre><code><span>data</span> <span>Identity</span> <span>a</span> <span>=</span> <span>Identity</span> <span>a</span>

<span>instance</span> <span>Functor</span> <span>Identity</span> <span>where</span>
    <span>fmap</span> <span>f</span> <span>(</span><span>Identity</span> <span>a</span><span>)</span> <span>=</span> <span>Identity</span> <span>(</span><span>f</span> <span>a</span><span>)</span>
</code></pre></div></div>

<p>With a property identity functor \(F\), we would have that that \(F(a) = a\) for any object or arrow \(a\). This clearly isn’t the case here; the values <code>Identity &#34;foo&#34;</code> and <code>&#34;foo&#34;</code> have two different types. Here we have an example of an endofunctor that cannot be made an instance of the <code>Functor</code> typeclass.</p>



<p>Another piece of information that is implicit in Haskell’s <code>Functor</code> typeclass, is that it is <em>covariant</em>. Covariance means that direction of arrows in the category upon which the functor acts (\(Hask\) in our case) is preserved. We can also define a contravariant functor, which flips the direction of arrows. In Haskell, the <code>Contravariant</code> typeclass is used to describe such functors:</p>

<div><div><pre><code><span>class</span> <span>Contravariant</span> <span>f</span> <span>where</span>
  <span>contramap</span> <span>::</span> <span>(</span><span>a</span> <span>-&gt;</span> <span>b</span><span>)</span> <span>-&gt;</span> <span>f</span> <span>b</span> <span>-&gt;</span> <span>f</span> <span>a</span>
</code></pre></div></div>

<p>Notice how <code>contramap</code> is almost equivalent to <code>fmap</code>, but that the direction of arrows (functions) is flipped. A function of type <code>a -&gt; b</code> becomes a function of type <code>F(b) -&gt; F(a)</code>.</p>

<p>Haskell’s standard library contains several other kinds of functors lifted from category theory:</p>

<ul>
  <li><code>Bifunctor</code> is a combination of 2 covariant functors, kind of like a pair <code>Functor</code>’s.</li>
  <li><code>Profunctor</code> is a combination of a covariant functor and a contravariant functor. Interesting for their use in <a href="https://github.com/hablapps/DontFearTheProfunctorOptics">lenses</a>.</li>
  <li><code>Applicative</code> is <a href="https://stackoverflow.com/a/35047673">essentially</a> a <a href="https://en.wikipedia.org/wiki/Monoidal_functor">monoidal functor</a>. You may know that every <code>Monad</code> is also <code>Applicative</code>, and <code>Applicative</code> is a kind of weaker monad, which is what makes this abstraction interesting. Alas, these are beyond the scope of this post.</li>
  <li>Probably even more that I don’t know of…</li>
</ul>



<p>I’ve described how functors are mappings between categories. Before moving on to monads, I should also mention mappings between functors. These are known as <em>natural transformations</em>. I’ll write these as \(N_a : F(a) \rightarrow G(a)\) where \(N\) is a natural transformation from functor \(F\) to functor \(G\). \(N_a\) is called the <em>component</em> of \(N\) at \(a\). This is the concrete arrow of \(N\) that applies to object \(a\).</p>

<p>We can express natural transformations quite directly in Haskell - they are just polymorphic functions. Here’s an example using our <code>Identity</code> functor implementation from earlier:</p>

<div><div><pre><code><span>identityToMaybe</span> <span>::</span> <span>Identity</span> <span>a</span> <span>-&gt;</span> <span>Maybe</span> <span>a</span>
<span>identityToMaybe</span> <span>(</span><span>Identity</span> <span>a</span><span>)</span> <span>=</span> <span>Just</span> <span>a</span>
</code></pre></div></div>

<p>This particular function is a natural transformation from the Identity functor to the Maybe functor. The components of such a natural transformation are concrete instantiations of the polymorphic function, such as:</p>

<div><div><pre><code><span>-- &#34;component at Boolean&#34;</span>
<span>identityToMaybe</span> <span>::</span> <span>Identity</span> <span>Boolean</span> <span>-&gt;</span> <span>Maybe</span> <span>Boolean</span>

<span>-- &#34;component at [Integer]</span>
<span>identityToMaybe</span> <span>::</span> <span>Identity</span> <span>[</span><span>Integer</span><span>]</span> <span>-&gt;</span> <span>Maybe</span> <span>[</span><span>Integer</span><span>]</span>
</code></pre></div></div>



<p>For the same reason that Haskell’s <code>Functor</code> is not quite a full-blown category-theoretic functor, Haskell’s <code>Monad</code> can never be full-blown. It comes a tad closer than in the case of functor, though.</p>

<p>In category theory, a monad is typically defined in terms of an endofunctor \(F: C \rightarrow C\) together with 2 <em>natural transformations</em> \(r: I_C \rightarrow F\) and \(j: (F \times F) \rightarrow F\) where \(I_C\) is the identity functor from \(C\) to \(C\), and \(F \times F\) is the <em>functor composition</em> of \(F\) with itself. Just as we could use \(\bullet\) to compose 2 arrows into a new arrow, we can use \(\times\) to compose 2 functors into a new functor. Additionally, a few monad laws must hold:</p>

<ul>
  <li>
\[j \bullet Fj = j \bullet jF\]
  </li>
  <li>
\[j \bullet Fr = j \bullet rF = I_F\]
  </li>
</ul>

<p>Where \(I_F\) is the identity natural transformation from \(F\) to \(F\).</p>

<p>The notation \(Fj\) means a natural transformation whose components \((Fj)_a\) are given by \(F(j_a)\), ie. selecting the specific arrow from \(j\) which applies to object \(a\), <em>and then</em> applying functor \(F\) to the result. Similarly, \(jF\) is a natural transformation with components \((jF)_a = j_{F(a)}\), ie. applying the functor \(F\) to object \(a\) first, and then using the resulting object to select an arrow from \(j\).</p>

<p>Let’s take a specific monad, <code>Maybe</code>, and see if we can write an implementation of \(r\) and \(j\) that seems to make sense. In the context of \(Hask\), the natural transformation \(r\) should be a function from the <code>Identity</code> functor to some other <code>Functor</code>. Since we are using <code>Maybe</code> as an example, this <code>Functor</code> is just <code>Maybe</code>. We get the following:</p>

<div><div><pre><code><span>r</span> <span>::</span> <span>Identity</span> <span>a</span> <span>-&gt;</span> <span>Maybe</span> <span>a</span>
<span>r</span> <span>(</span><span>Identity</span> <span>a</span><span>)</span> <span>=</span> <span>Just</span> <span>a</span>
</code></pre></div></div>

<p>Since <code>Identity a</code> carries no more information than <code>a</code>, let’s get rid of it:</p>

<div><div><pre><code><span>r</span> <span>::</span> <span>a</span> <span>-&gt;</span> <span>Maybe</span> <span>a</span>
<span>r</span> <span>a</span> <span>=</span> <span>Just</span> <span>a</span>
</code></pre></div></div>

<p>This function lets us <em>lift</em> a value of any type into our monad.</p>

<p>Next, recall that the natural transformation \(j\) mapped from some composition of functors \(F \times F\) to functor \(F\). In Haskell, we would write \(F \times F\) as <code>Functor f =&gt; f (f a)</code>, or <code>Maybe (Maybe a)</code> for the concrete case of <code>Maybe</code>. We get the following:</p>

<div><div><pre><code><span>j</span> <span>::</span> <span>Maybe</span> <span>(</span><span>Maybe</span> <span>a</span><span>)</span> <span>-&gt;</span> <span>Maybe</span> <span>a</span>
<span>j</span> <span>(</span><span>Nothing</span><span>)</span> <span>=</span> <span>Nothing</span>
<span>j</span> <span>(</span><span>Just</span> <span>(</span><span>Nothing</span><span>))</span> <span>=</span> <span>Nothing</span>
<span>j</span> <span>(</span><span>Just</span> <span>(</span><span>Just</span> <span>a</span><span>))</span> <span>=</span> <span>Just</span> <span>a</span>
</code></pre></div></div>

<p>This function lets us remove one level of monadic structure, <em>flattening</em> a nested monad in a meaningful way. For the <code>Maybe</code> monad, it works sort of like a logical and.</p>

<p>With these implementations in mind, let’s take a look at how Haskell’s <code>Monad</code> typeclass looks (omitting a few irrelevancies):</p>

<div><div><pre><code><span>class</span> <span>Applicative</span> <span>m</span> <span>=&gt;</span> <span>Monad</span> <span>m</span> <span>where</span>
  <span>(</span><span>&gt;&gt;=</span><span>)</span> <span>::</span> <span>m</span> <span>a</span> <span>-&gt;</span> <span>(</span><span>a</span> <span>-&gt;</span> <span>m</span> <span>b</span><span>)</span> <span>-&gt;</span> <span>m</span> <span>b</span>
  <span>return</span> <span>::</span> <span>a</span> <span>-&gt;</span> <span>m</span> <span>a</span>
</code></pre></div></div>

<p>You can pretty easily convince yourself that the <code>r</code> function is precisely equivalent to the <code>return</code> function on this typeclass. But what about the <code>j</code> function? It is nowhere to be found. This confused me quite a bit when I was first learning about monads. It turns out that this missing function does exist in the standard library - just not on the <code>Monad</code> typeclass itself. This function is called <code>join</code>:</p>

<div><div><pre><code><span>join</span> <span>::</span> <span>Monad</span> <span>m</span> <span>=&gt;</span> <span>m</span> <span>(</span><span>m</span> <span>a</span><span>)</span> <span>-&gt;</span> <span>m</span> <span>a</span>
</code></pre></div></div>

<p>The missing piece of the puzzle is some nifty identities, which relate <code>join</code> and <code>&gt;&gt;=</code> (also known as the “bind” operator) together:</p>

<div><div><pre><code><span>-- We can write &gt;&gt;= in terms of join and fmap:</span>
<span>(</span><span>m</span> <span>&gt;&gt;=</span> <span>f</span><span>)</span> <span>==</span> <span>(</span><span>join</span> <span>(</span><span>fmap</span> <span>f</span> <span>m</span><span>))</span>

<span>-- Or join in terms of &gt;&gt;= and the identity function:</span>
<span>(</span><span>join</span> <span>m</span><span>)</span> <span>==</span> <span>(</span><span>m</span> <span>&gt;&gt;=</span> <span>id</span><span>)</span>
</code></pre></div></div>

<p>Using this, we could write a valid instance of <code>Monad</code> for <code>Maybe</code> as so:</p>

<div><div><pre><code><span>instance</span> <span>Monad</span> <span>Maybe</span> <span>where</span>
    <span>m</span> <span>&gt;&gt;=</span> <span>f</span> <span>=</span> <span>j</span> <span>(</span><span>fmap</span> <span>f</span> <span>m</span><span>)</span>
    <span>return</span> <span>=</span> <span>r</span>
</code></pre></div></div>

<p>That’s all fine and good, but what about the 2 monad laws from earlier? Does our implementation satisfy these? Let’s take another look at the first law, \(j \bullet Fj = j \bullet jF\), and translate each piece of the equation into Haskell:</p>

<ul>
  <li>The composition operator \(\bullet\) is function composition ‘<code>.</code>’.</li>
  <li>The natural transformation \(j\) is the <code>j</code> function from earlier.</li>
  <li>The \(F\) construct in \(Fj\) translates to <code>fmap</code>. We are applying our functor \(F\) to the natural transformation \(j\), which in Haskell was just a function. Remember, <code>fmap</code> is the portion of a functor that maps functions to functions.</li>
  <li>The \(F\) construct in \(jF\) disappears. Here, the functor \(F\) is applied to the objects (types) in \(Hask\), turning any type <code>a</code> into the type <code>Maybe a</code>. We use this type to select the component of \(j\) to apply. Concretely, we select the instantiation of <code>j</code> which applies to <code>Maybe</code> values - this is just <code>j</code>.</li>
</ul>

<p>Putting all of this together, we can translate the law into Haskell like so:</p>



<p>Cool. Does it hold? Well, let’s check every possibility:</p>

<div><div><pre><code><span>(</span><span>j</span> <span>.</span> <span>j</span><span>)</span> <span>(</span><span>Just</span> <span>(</span><span>Just</span> <span>(</span><span>Just</span> <span>42</span><span>)))</span> <span>==</span> <span>Just</span> <span>42</span>
<span>(</span><span>j</span> <span>.</span> <span>j</span><span>)</span> <span>(</span><span>Just</span> <span>(</span><span>Just</span> <span>Nothing</span><span>))</span> <span>==</span> <span>Nothing</span>
<span>(</span><span>j</span> <span>.</span> <span>j</span><span>)</span> <span>(</span><span>Just</span> <span>Nothing</span><span>)</span> <span>==</span> <span>Nothing</span>
<span>(</span><span>j</span> <span>.</span> <span>j</span><span>)</span> <span>Nothing</span> <span>==</span> <span>Nothing</span>

<span>(</span><span>j</span> <span>.</span> <span>fmap</span> <span>j</span><span>)</span> <span>(</span><span>Just</span> <span>(</span><span>Just</span> <span>(</span><span>Just</span> <span>42</span><span>)))</span> <span>==</span> <span>Just</span> <span>42</span>
<span>(</span><span>j</span> <span>.</span> <span>fmap</span> <span>j</span><span>)</span> <span>(</span><span>Just</span> <span>(</span><span>Just</span> <span>Nothing</span><span>))</span> <span>==</span> <span>Nothing</span>
<span>(</span><span>j</span> <span>.</span> <span>fmap</span> <span>j</span><span>)</span> <span>(</span><span>Just</span> <span>Nothing</span><span>)</span> <span>==</span> <span>Nothing</span>
<span>(</span><span>j</span> <span>.</span> <span>fmap</span> <span>j</span><span>)</span> <span>Nothing</span> <span>==</span> <span>Nothing</span>
</code></pre></div></div>

<p>Yep, it checks out! Following similar logic, we can translate the second of the 2 laws into Haskell as:</p>

<div><div><pre><code><span>j</span> <span>.</span> <span>fmap</span> <span>r</span> <span>==</span> <span>j</span> <span>.</span> <span>r</span> <span>==</span> <span>id</span>
</code></pre></div></div>

<p>Which also holds for all possibilities. Both <code>(j . fmap r)</code> and <code>(j . r)</code> will do absolutely nothing when applied to a <code>Maybe</code> value.</p>



<p>You might have heard the meme-worthy phrase “a monad is simply a monoid in the category of endofunctors” before. I don’t intend to give a full explanation of what this phrase means, but I’d like to build some intuition. Most of the words in this phrase should be familiar by known, but I haven’t yet defined what a <em>monoid</em> is. The classical definition of a monoid is:</p>

<ul>
  <li>A set S</li>
  <li>… equipped with a binary operator \(\otimes\)</li>
  <li>… which is associative, \((a \otimes b) \otimes c = a \otimes (b \otimes c)\)</li>
  <li>… and has an <em>neutral</em> element \(ne\) such that for all \(a \in S\), we have \(a \otimes ne = ne \otimes a = a\)</li>
</ul>

<p>Typical examples include:</p>

<ul>
  <li>The set of natural numbers with \(+\) as the operator, and \(0\) as the neutral element.</li>
  <li>The set of natural numbers with \(*\) as the operator, and \(1\) as the neutral element.</li>
  <li>The set of strings with string concatenation as the operator, and “” as the neutral element.</li>
</ul>

<p>In the last section, we derived a few laws for monads, written in Haskell:</p>

<div><div><pre><code><span>j</span> <span>.</span> <span>fmap</span> <span>j</span> <span>==</span> <span>j</span> <span>.</span> <span>j</span>
<span>j</span> <span>.</span> <span>fmap</span> <span>r</span> <span>==</span> <span>j</span> <span>.</span> <span>r</span> <span>==</span> <span>id</span>
</code></pre></div></div>

<p>Using the aforementioned standard library functions, we can generalize these to work for any monad:</p>

<div><div><pre><code><span>join</span> <span>.</span> <span>fmap</span> <span>join</span> <span>==</span> <span>join</span> <span>.</span> <span>join</span>
<span>join</span> <span>.</span> <span>fmap</span> <span>return</span> <span>==</span> <span>join</span> <span>.</span> <span>return</span> <span>==</span> <span>id</span>
</code></pre></div></div>

<p>If you stare at these laws for a moment, you might notice that they look sort of similar to the requirements for a monoid.</p>

<p>The first law is roughly saying “If we have a stack of 3 nested monadic values, it doesn’t matter if we first use <code>join</code> to flatten the innermost 2 values (the left-hand side), or the 2 outermost values (the right-hand side)”. In other words, it doesn’t matter how we group our <code>join</code>’s - this is the essence of associativity.</p>

<p>The second law is saying “If we inject an extra monadic layer into a monadic value using <code>fmap return</code>, and then flatten using <code>join</code> (left-hand side), <em>or</em> we wrap a monadic value in another monadic layer using <code>return</code>, and then flatten with <code>join</code> (middle part of the equation), we have achieved nothing. Since we achieved nothing, both of these operations are equivalent to the identity function <code>id</code>”. Here, <code>return</code> plays the role of a monoidal neutral element, and the law describes something similar to left and right identity.</p>

<p>This intuitive explanation should hopefully give a hint as to why we can consider monads to be a specific kind of monoid.</p>



<p>So far, I’ve shed some light on the differences between some common abstractions in Haskell, and their category-theory equivalents. I’ve been insinuating that the Haskell counterparts of these abstractions are proper subsets of category-theory concepts. However, for each of the abstractions I’ve described so far, this hinges on the adherence to some <em>laws</em>, such as the monad laws described in the previous section.</p>

<p>Haskell isn’t capable of enforcing these laws! For all of these abstractions, we can write implementations that type check but have absolutely nothing to do with category theory.</p>

<p>To illustrate this principle, let’s take a look at some properties of category-theoretic functors that I chose to omit earlier. For any functor \(F: A \rightarrow B\), the following laws must hold:</p>

<ul>
  <li>\(F(I_a) = I_{F(a)}\) where both \(I\)’s are identity arrows in their respective categories. Put simply, functors must preserve identity.</li>
  <li>\(F(x \bullet y) = F(x) \bullet F(y)\), for all arrows \(x\) and \(y\) in category \(A\). Put simply, functors must preserve composition.</li>
</ul>

<p>In Haskell, these laws are spelled:</p>

<div><div><pre><code><span>fmap</span> <span>id</span> <span>==</span> <span>id</span>
<span>fmap</span> <span>f</span> <span>.</span> <span>fmap</span> <span>g</span> <span>==</span> <span>fmap</span> <span>(</span><span>f</span> <span>.</span> <span>g</span><span>)</span>
</code></pre></div></div>

<p>Now consider the following botched implementation of the <code>Functor</code> typeclass for <code>Maybe</code>:</p>

<div><div><pre><code><span>instance</span> <span>Functor</span> <span>Maybe</span> <span>where</span>
    <span>fmap</span> <span>a</span> <span>b</span> <span>=</span> <span>Nothing</span>
</code></pre></div></div>

<p>This type checks just fine. Let’s check if the first law holds:</p>

<div><div><pre><code><span>fmap</span> <span>id</span> <span>(</span><span>Just</span> <span>a</span><span>)</span> <span>==</span> <span>Nothing</span>
<span>id</span> <span>(</span><span>Just</span> <span>a</span><span>)</span> <span>==</span> <span>Just</span> <span>a</span>
</code></pre></div></div>

<p>Oh no! It doesn’t. Interestingly, the second law does actually hold, because both sides of the equation just evaluate to a function that always returns <code>Nothing</code>.</p>

<p>Of course, these kinds of botched implementations are not common and are considered buggy code, but they <em>are</em> expressible, further distancing Haskell from a category-theoretic foundation.</p>



<ul>
  <li>
    <p><a href="https://wiki.haskell.org/Hask">https://wiki.haskell.org/Hask</a></p>
  </li>
  <li>
    <p><a href="https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/">https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/</a></p>
  </li>
  <li>
    <p><a href="https://1lab.dev/#category-theory">https://1lab.dev/#category-theory</a></p>
  </li>
  <li>
    <p><a href="https://ncatlab.org/nlab/show/whiskering">https://ncatlab.org/nlab/show/whiskering</a></p>
  </li>
  <li>
    <p><a href="https://stackoverflow.com/questions/3870088/a-monad-is-just-a-monoid-in-the-category-of-endofunctors-whats-the-problem">https://stackoverflow.com/questions/3870088/a-monad-is-just-a-monoid-in-the-category-of-endofunctors-whats-the-problem</a></p>
  </li>
  <li>
    <p><a href="https://stackoverflow.com/questions/45829110/monad-laws-expressed-in-terms-of-join-instead-of-bind">https://stackoverflow.com/questions/45829110/monad-laws-expressed-in-terms-of-join-instead-of-bind</a></p>
  </li>
  <li>
    <p><a href="https://math.andrej.com/2016/08/06/hask-is-not-a-category/">https://math.andrej.com/2016/08/06/hask-is-not-a-category/</a></p>
  </li>
</ul>

</article>





      </div></div>
  </body>
</html>
