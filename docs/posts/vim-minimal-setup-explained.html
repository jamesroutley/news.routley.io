<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.guckes.net/vim/setup.html">Original</a>
    <h1>Vim â€“ Minimal Setup Explained</h1>
    
    <div id="readability-page-1" class="page"><div>

<tbody><tr>
<td> <tt> command </tt> </td>
<td> description </td>
</tr>

<!--

<tr>
<td valign=top>
<pre>
<tt> </tt> <br>
<tt> </tt>
</pre>
</td>
<td>
</td>
</tr>

-->

<tr>
<td>
<pre><tt> <b>nocompatible</b> </tt>
<tt> set <SPAN color="green">nocp</SPAN> </tt>
</pre>
</td>
<td>
This changes the values of a LOT of options,
enabling features which are not Vi compatible
but really really nice.
</td>
</tr>

<tr>
<td>
<pre><tt> <b>digraph</b> </tt>
<tt> set <SPAN color="green">digraph</SPAN> </tt>
</pre>
</td>
<td>
Enables input of special characters by a combination of two characters.
Example:  Type &#39;a&#39;, erase it by typing CTRL-H -
and then type &#39;:&#39; - this results in the umlaut: Ã¤
So Vim remembers the character you have erased and combines it
with the character you have typed &#34;over&#34; the previos one.
</td>
</tr>

<tr>
<td>
<pre><tt> <b>esckeys</b> </tt>
<tt> set <SPAN color="green">ek</SPAN> </tt>
</pre>
</td>
<td>
Enables recognition of arrow key codes which start off with an ESC.
This would normally end your current mode (insert/append/open mode)
and return you command mode (aka normal mode), and the rest of the
code would trigger commands.  bah!  Although I dont use the arrow
keys often, I sometimes want to use them with replace mode and
virtual editing And I don&#39;t want to be *that*
compatible to vanilla vi, anyway. (so sue me).
</td>
</tr>

<tr>
<td>
<pre><tt> <b>hidden</b> </tt>
<tt> set <SPAN color="green">hid</SPAN> </tt>
</pre>
</td>
<td>
Allows hiding buffers even though they contain modifications
which have not yet been written back to the associated file.
(sounds quite technical, eh?)
</td>
</tr>

<tr>
<td>
<pre><tt> <b>ruler</b> </tt>
<tt> set <SPAN color="green">ru</SPAN> </tt>
</pre>
</td>
<td>
Shows the &#34;ruler&#34; for the cursor, ie its current position
with line+column and the percentage within the buffer.
This saves me typing CTRL-G (or better &#34;g CTRL-G&#34;) -
and many users like this feature, too.
And it is nice when showing Vim.
</td>
</tr>

<tr>
<td>
<pre><tt> <b>showcmd</b> </tt>
<tt> set <SPAN color="green">sc</SPAN> </tt>
</pre>
</td>
<td>
Show the input of an *incomplete* command.
So while you are typing the command <tt>&#34;y23dd</tt>
you will see <tt>&#34;y23dd</tt> before you type
the last &#39;d&#39; which completes the command.
Makes learning Vi much simpler as you get
some feedback to what you have already typed.
</td>
</tr>

<tr>
<td>
<pre><tt> <b>visualbell</b> </tt>
<tt> set <SPAN color="green">vb</SPAN> </tt>
</pre>
</td>
<td>
Chose &#34;visual bell&#34; effect rather than &#34;beeping&#34;.
</td>
</tr>

<tr>
<td>
<pre><tt> <b>wildmenu</b> </tt>
<tt> set <SPAN color="green">wmnu</SPAN> </tt>
</pre>
</td>
<td>
Make use of the &#34;status line&#34; to show possible completions of
command line commands, file names, and more.  Allows to cycle
forward and backward throught the list.
This is called the &#34;wild menu&#34;.
</td>
</tr>

<tr>
<td>
<pre><tt> <b>noerrorbells</b> </tt>
<tt> set <SPAN color="green">noeb</SPAN> </tt>
</pre>
</td>
<td>
Turn off the bell.  You do know the &#34;beep&#34;
you get when you type ESC in normal mode?
Be nice to your co-workers - turn it off! ;-)
</td>
</tr>

<tr>
<td>
<pre><tt> <b>noexpandtab</b> </tt>
<tt> set <SPAN color="green">noet</SPAN> </tt>
</pre>
</td>
<td>
When inserting text do not expand TABs to spaces.
While I try to avoid all control characters in text
I can make good use of TABs when typing a table.
And I know I can always make Vim expand the TABs later
(using the &#34;:retab&#34; command).  Your mileage may vary..
</td>
</tr>

<tr>
<td>
<pre><tt> <b>nostartofline</b> </tt>
<tt> set <SPAN color="green">nosol</SPAN> </tt>
</pre>
</td>
<td>
Prevent the cursor from changing the current column
when jumping to other lines within the window.
(And if you like that then you&#39;ll &#34;virtual editing&#34; with Vim-6! :-)
</td>
</tr>

<tr>
<td>
<pre><tt> <b>autoindent</b> </tt>
<tt> set <SPAN color="green">ai</SPAN> </tt>
</pre>
</td>
<td>
Automatic indentation.  This automatically inserts the
indentation from the current line when you start a new line;
in insert mode you would start a new line by ending the current
one by inserting CTRL-J or CTRL-M - and in command mode you&#39;d
&#34;open&#34; a new line with either &#39;o&#39; or &#39;O&#39; for below or above the
current line, respectively.
By the way, &#34;autoindent&#34; is actually a feature of vanilla vi.
</td>
</tr>

<tr>
<td>
<pre><tt> <b>backspace</b> </tt>
<tt> set <SPAN color="red">bs=2</SPAN> </tt>
</pre>
</td>
<td>
Backspace with this value allows to use the backspace character
(aka CTRL-H or &#34;&lt;-&#34;) to use for moving the cursor over
automatically inserted indentation and over the start/end of line.
(see also the whichwrap option)
</td>
</tr>

<tr>
<td>
<pre><tt> <b>formatoptions</b> </tt>
<tt> set <SPAN color="red">fo=cqrt</SPAN> </tt>
</pre>
</td>
<td>
The formatoptions affect the built-in &#34;text formatting&#34; command.
The default value omits the &#34;flag&#34; &#39;r&#39; which makes Vim insert a
&#34;comment leader&#34; of the line when starting a new one.
This allows to add text to a comment and still be
within the comment after you start a new line.
It also allows to break the line within a comment
without breaking the comment.
</td>
</tr>

<tr>
<td>
<pre><tt> <b>laststatus</b> </tt>
<tt> set <SPAN color="red">ls=2</SPAN> </tt>
</pre>
</td>
<td>
This makes Vim show a status line even when only one window is shown.
Who said a status line is only useful to separate multiple windows?
</td>
</tr>

<tr>
<td>
<pre><tt> <b>shortmess</b> </tt>
<tt> set <SPAN color="red">shm=at</SPAN> </tt>
</pre>
</td>
<td>
This shortens about every message to a minimum and
thus avoids scrolling within the output of messages
and the &#34;press a key&#34; prompt that goes with these.
</td>
</tr>

<tr>
<td>
<pre><tt> <b>textwidth</b> </tt>
<tt> set <SPAN color="red">tw=72</SPAN> </tt>
</pre>
</td>
<td>
This explicitly sets the width of text to 72 characters.
After each completion of a word in insert mode
Vim checks whether its end is past this width;
if so then it will break the word onto the next line.
Note that Vim will remove trailing spaces when applying
the word wrap - a feature which many editors are missing
(and which will leave trailing spaces, of course).
NOTE:  The word wrap applies only when the *completed* word
goes over the line; when you insert a word before that
which moves other words over the line then Vim will *not*
break the words at the end of the line onto the next line!
Programmers certainly don&#39;t want that.  It&#39;s a feature!!
</td>
</tr>

<tr>
<td>
<pre><tt> <b>whichwrap</b> </tt>
<tt> set <SPAN color="red">ww=&lt;,&gt;,h,l</SPAN> </tt>
</pre>
</td>
<td>
There are several commands which move the cursor within the line.
When you get to the start/end of a line then these commands will
fail as you cannot go on.  However, many users expect the cursor
to be moved onto the previous/next line.  Vim allows you to chose
which commands will &#34;wrap&#34; the cursor around the line borders.
Here I allow the cursor left/right keys
as well as the &#39;h&#39; and &#39;l&#39; command to do that.
</td>
</tr>

<tr>
<td>
<pre><tt> <b>comments</b> </tt>
<tt> set <SPAN color="blue">com=b:#,:%,n:&gt;</SPAN> </tt>
</pre>
</td>
<td>
Vim can reformat text and preserve comments (commented lines)
even when several kinds of comment indentation &#34;nest&#34; within.
(This is very useful for reformatting quoted text in Email and News.)
But you need to tell Vim how the comments look like.
Usually a comment starts off with some string,
which may require a following blank.
Comments may also span over lines by starting off with some string,
skipping some middle part, and then end with another string
(think about comments in C++, for example).
I simply removed the &#34;<tt>/* foo */</tt>&#34; commenting from the
default value and added that &#39;)&#39; can also be &#34;nested comments&#34;.
</td>
</tr>

<tr>
<td>
<pre><tt> <b>list listchars</b> </tt>
<tt> set list </tt>
<tt> set <SPAN color="blue">lcs=tab:»·</SPAN> </tt>
<tt> set <SPAN color="blue">lcs+=trail:·</SPAN> </tt>
</pre>
</td>
<td>
This option is cool!  Or let&#39;s say that
&#34;other editors don&#39;t have that at all.&#34;
These characters are called &#34;list characters&#34;
as they are related to the <tt>list</tt> option
of vanilla vi:
This will show the end-of-lines by adding a
&#39;$&#39; sign after the last character of each line,
and by replacing all TABs by &#39;<tt>^I</tt>&#39;.
However, it is much nicer to still have TABs
shown in expanded form.
Vim takes it one step further by
also making trailing spaces visible.
Being able to see EOLs, TABs, and trailing space
has become an absolute MUST with every editor.
</td>
</tr>

<tr>
<td>
<pre><tt> <b>viminfo</b> </tt>
<tt> set <SPAN color="blue">vi=%,&#39;50</SPAN> </tt>
<tt> set <SPAN color="blue">vi+=\&#34;100,:100</SPAN> </tt>
<tt> set <SPAN color="blue">vi+=n~/.viminfo</SPAN> </tt>
</pre>
</td>
<td>
The idea of &#34;viminfo&#34; is to save info from one editing session
for the next by saving the data in an &#34;viminfo file&#34;.
So next time I satrt up Vim I can use the search patterns from
the search history and the commands from the command line again.
I can also load files again with a simple &#34;<tt>:b bufname</tt>&#34;.
And Vim also remember where the cursor was in the files I edited.
See &#34;:help viminfo&#34; for more info on Vim&#39;s &#34;viminfo&#34;.  :-}
</td>
</tr>

</tbody></div><p>
<b>NOTES:</b>
I have grouped the options such that the Boolean ones
(read: on/off true/false) come first, then those with
a short amount of &#34;flags&#34;, and after that the ones
with a very long value.
</p><p>
With all &#34;<tt>:set</tt>&#34; command you can leave out the colon
before the &#34;set&#34; when you put them into the setup file.
And you can set many options in one command line.
</p><p>
The values of the options &#34;comments&#34;, &#34;listchars&#34;, and
&#34;viminfo&#34; can become quite long, so I have broken them up
in the table into several &#34;set&#34; statements, using
<tt>:set +=</tt> to add further value to the current one.
</p><p>
<b>Getting help on options</b>:
You can get help about options and their values with
<tt>:help <i>option</i></tt>.
You need not enter the full option name -
many option names have abbreviations, eg
&#34;ai&#34; abbreviates &#34;autoindent&#34; - and
&#39;tabstop&#39; can be abbreviated with &#34;ts&#34;.
And it suffices to enter &#34;h&#34; instead of &#34;:help&#34;.
Isn&#39;t &#34;:h ai&#34; much shorter than &#34;:help autoindent&#34;?
</p></div>
  </body>
</html>
