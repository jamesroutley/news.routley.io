<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.serverlessq.com/aws-sns-vs-sqs-what-are-the-main-differences">Original</a>
    <h1>AWS SNS vs. SQS â€“ Main Differences</h1>
    
    <div id="readability-page-1" class="page"><div id="post-content-wrapper"><p>AWS offers many great messaging services. Two of their most famous services are Amazon Simple Notification Service (SNS) and Amazon Simple Queue Service (SQS). While both can be used in a pretty similar way they are completely different services. </p>
<p>This blog post will explain to you the similarities, differences, and how to choose which service. </p>
<p>Finally, I will show you some example use cases and a common event-driven pattern called the fanout pattern that combines SNS and SQS. </p>
<p>Let&#39;s go ðŸš€</p>
<h2 id="heading-amazon-simple-notification-service-sns">Amazon Simple Notification Service (SNS)</h2>
<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1653474441770/YD006idiY.png?auto=compress,format&amp;format=webp" alt="AWS SNS Introduction with many subscribers and many publishers"/></p>
<p>Amazon&#39;s SNS is a fully managed publish and subscribe service. A publisher sends a message to a <strong>topic</strong> and many consumers/subscribers are subscribed to this topic. The relationship is many to many. You can have many publishers and many subscribers to a topic.</p>
<p>SNS differentiates in sending their sending methods. It is either Application to Application (A2A) or Application to Person (A2P). </p>
<p>Application to Application (A2A) destinations are:</p>
<ul>
<li>AWS Lambda</li>
<li>Amazon SQS</li>
<li>Amazon Kinesis Data Firehose</li>
<li>AWS Event Fork Pipelines</li>
<li>HTTP Endpoints</li>
</ul>
<p>Application to Person (A2P) destinations are: </p>
<ul>
<li>SMS</li>
<li>Email</li>
<li>In-App notification</li>
<li>AWS Chatbot</li>
<li>PagerDuty</li>
</ul>
<p>SNS is super performant. Messages will be published within milliseconds. </p>
<p>A common pattern is a fan-out pattern that allows to fan out one event to various subscribers within AWS. I will go more into detail about that pattern later on in the use case section.</p>
<p>SNS allows standard topics or FIFO topics. FIFO topics have a message ordering and standard topics don&#39;t. For FIFO topics there are much harder limits!</p>
<h2 id="heading-amazon-simple-queue-service-sqs">Amazon Simple Queue Service (SQS)</h2>
<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1653471650688/swDV9d8mh.png?auto=compress,format&amp;format=webp" alt="AWS SQS Introduction - Many Producers and one consumer"/></p>
<p>Amazon SQS is a fully-managed distributed queueing service. SQS is poll-based and not push-based. Even, if it often seems like a push-based system, it is not. Amazon SQS is often used to decouple systems from each other and to enable asynchronous workloads. </p>
<p>The main pattern of SQS is to have producers send messages to a queue. The message retains in the queue for a defined time (by default 4 days, maximum 14 days). See <a target="_blank" href="https://blog.serverlessq.com/aws-sqs-retention-period">our article on retention period</a>. Consumers can pick up the messages on their own schedule by checking the queue if any new messages are available.</p>
<p>If a consumer works on a message the message will be deleted if it is successful. Otherwise, it can also be picked up by other consumers.</p>
<p>SQS offers many capabilities for retrying messages with its redrive policy. You can define a number of retries and a dead letter queue in case messages are failing.
Dead letter queues (DLQ) are used to handle messages with errors. If messages can&#39;t be worked on they will be sent to a DLQ to inform the application developer about the issues and optionally save the message to replay it in the original queue. </p>
<p>SQS has a many-to-one relationship. You can send messages to a queue from many different producers but only one consumer can be defined. A consumer is another application, most often some compute instances such as Lambda, EC2, or Fargate.</p>
<p>There are two different types of queues: Standard queues and First-in, first-out (FIFO) queues. The latter one will keep the messages in order. </p>
<p>Fun fact: SQS is AWS&#39;s <strong>oldest service</strong>. </p>
<h2 id="heading-differences">Differences</h2>
<p>This article focuses on the differences between both services.</p>
<p>We understand that both services handle messages in some way. Both services enable better decoupling. The backend API and the execution of background logic are loosely coupled and not connected anymore. </p>
<p>But there are notable differences. Let&#39;s have a look at all of them.</p>
<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1653459899138/x_xd2zG80.png?auto=compress,format&amp;format=webp" alt="SQS vs SNS Table"/></p>
<h3 id="heading-push-and-poll-based">Push and poll-based</h3>
<p>The main difference lies in the foundation of the services. SQS is <strong>poll-based</strong> and SNS is <strong>push-based</strong> service. </p>
<p>That means SNS is simply forwarding all messages to your subscribed consumers, whereas SQS really saves the messages in a queue and waits till they get picked up. This is a notable difference in various aspects. The latency in SQS architectures for example is a bit higher since the polling still needs to be accounted for. The persistence and reliability on the other hand are with SQS much better since the message is properly saved for a short period.</p>
<h3 id="heading-many-to-many-vs-many-to-one-number-of-consumers">Many-to-many vs. many-to-one (Number of Consumers)</h3>
<p>A second difference is the type of relationship. Both services can receive messages from different producers. That means both services have a many-to-x relationship. </p>
<p>The main difference is that SNS can have a lot of subscribers whereas SQS can only have one consumer. </p>
<p>The <a target="_blank" href="https://docs.aws.amazon.com/general/latest/gr/sns.html#limits_sns">current limit</a> of SNS subscribers is 12,500,000 subscribers per topic. That is a lot! This means you can have many many consumers who will work on your message.</p>
<p>SQS on the other hand can only have <strong>one consumer</strong>. This consumer is working on the message and deletes the message afterward.</p>
<h3 id="heading-types-of-consumers">Types of Consumers</h3>
<p>SNS sends their messages either to an application or directly to a person, or both. That means it supports a variety of different consumer types.</p>
<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1653471927096/XaOEEaVTL.png?auto=compress,format&amp;format=webp" alt="All AWS SNS Subscriber Types"/></p>
<p>SNS can send to many different destinations. These are:</p>
<p>Application to Application (A2A) destinations are:</p>
<ul>
<li>AWS Lambda</li>
<li>Amazon SQS</li>
<li>Amazon Kinesis Data Firehose</li>
<li>AWS Event Fork Pipelines</li>
<li>HTTP Endpoints</li>
</ul>
<p>Application to Person (A2P) destinations are: </p>
<ul>
<li>SMS</li>
<li>Email</li>
<li>In-App notification</li>
<li>AWS Chatbot</li>
<li>PagerDuty</li>
</ul>
<p>SQS messages on the other hand will typically be picked up using the SQS API. So every client that supports the AWS SDK can use it. Typically, messages in queues will be picked up from AWS Lambda because there is native integration with SQS and Lambda. But it is also possible to simply pick up and remove a message with the SQS API. You can also do it from your local PC ðŸ˜‰</p>
<h3 id="heading-persistence">Persistence</h3>
<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1653471970056/ioBGyLamZ.png?auto=compress,format&amp;format=webp" alt="AWS SNS vs. AWS SQS Persistence"/></p>
<p>Messages in SQS will be saved for some duration. This is called the <strong>retention period</strong>. The retention period can be between 1 minute and 14 days and its default value are 4 days. If the message wasn&#39;t picked up within that timeframe the message will be removed automatically. Here is a more detailed <a target="_blank" href="https://blog.serverlessq.com/aws-sqs-retention-period">article</a>.</p>
<p>In <strong>SNS</strong> however, no persistence exists. There is no guarantee that the message will be delivered. If a consumer is not available the message won&#39;t be delivered.</p>
<p>This can make quite a difference in the reliability. If a consumer for example is not available in SNS the message will simply not be delivered. Or if a consumer doesn&#39;t end successfully the message is simply gone. SQS adds a lot of reliability to that. The fanout pattern can be used to combine both, but later more on that topic.</p>
<h3 id="heading-reliability-retries">Reliability - Retries</h3>
<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1653471991671/i60-cp12-j.png?auto=compress,format&amp;format=webp" alt="AWS SNS vs. AWS SQS Reliability and Retries"/></p>
<p>SQS has the ability to add a <strong>Redrive Policy</strong>. This policy defines how many times a failed message should be retried before it will be moved to a Dead Letter Queue (DLQ). The DLQ handles failed messages. For example, you could save failed messages in a bucket and inform the developer about them.</p>
<p>SNS doesn&#39;t offer retries <strong>when the client fails</strong>. In case a consumer is not available or the consumer fails in working on the message (e.g. push notification won&#39;t come through) the message can&#39;t be repeated. This is due to the asynchronous nature of SNS.</p>
<h3 id="heading-batching">Batching</h3>
<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1653472265528/5jpaamAGu.png?auto=compress,format&amp;format=webp" alt="Batching in AWS SNS vs. AWS SQS - Differences"/></p>
<p>SQS allows you to <strong>batch</strong> multiple messages together into one. You can define the parameter <strong>batch_size</strong>. The batch size can be a maximum of 10,000 records for standard queues and a maximum of 10 for FIFO queues. </p>
<p>SNS only works on one message at a time, so no batching is possible.</p>
<h2 id="heading-when-to-use-what">When to use what</h2>
<p>When should I use SNS and when should I use SQS now? </p>
<p>Some general advice:</p>
<p><strong>Use SNS if:</strong></p>
<ul>
<li>You have many subscribers</li>
<li>You need to send to consumers of the type SMS, Email, or app notifications</li>
<li>You want to use a fanout pattern to send a message to many subscribers at the same time (later more)</li>
</ul>
<p><strong>Use SQS if:</strong></p>
<ul>
<li>you only need one subscriber</li>
<li>persistence and error handling are really important (each message needs to be delivered)</li>
<li>you need to batch your requests</li>
<li>you want to simply decouple your application and enable async background processing</li>
</ul>
<h2 id="heading-use-cases">Use Cases</h2>
<p>Let&#39;s have some example use cases. </p>
<h3 id="heading-sns">SNS</h3>
<p><strong>CloudWatch Alarms: </strong></p>
<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1653472085417/HAbeT1pF_.png?auto=compress,format&amp;format=webp" alt="AWS SNS CloudWatch Example with Email and SMS"/></p>
<p>An alarm will be triggered and you want to send messages to 10 different email addresses and SMS to some mobile phones. Persistence, batching, and retries are not important.</p>
<p><strong>In-App Notification</strong></p>
<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1653472110815/WHuxyH80O.png?auto=compress,format&amp;format=webp" alt="Amazon SNS Example to send push notifications"/></p>
<p>A new user followed you on your new social media application. You want to inform the user about that.</p>
<h3 id="heading-sqs">SQS</h3>
<p><strong>Background Processing</strong></p>
<p>Your application is doing all tasks in a synchronous way and your user needs to wait till your API returns. By adding an SQS queue you can run background tasks and decouple the whole application.</p>
<p><strong>Batch Processing</strong></p>
<p>You need to work on a large number of messages at the same time. SQS can handle that by handling all messages in batch. </p>
<p>One example:</p>
<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1653472326506/t0zUBWJ-m.png?auto=compress,format&amp;format=webp" alt="AWS SQS Example to handle scalability with SQS and Lambda"/></p>
<p>You host a startup show and you get a huge number of votes at the same time. You need to process these votes. It is not feasible that your API handles all of that and you don&#39;t want your users to wait the time it takes to process them.</p>
<p>You can use SQS for that. When a user votes your API sends a message to SQS. Your API returns 200 OK to the end-user and the end-user gets a super-fast response.</p>
<p>The actual business logic is decoupled. SQS and Lambda will take care of the rest. In such scenarios, many messages will be batched together and many lambda functions will be spawned. This is what scalability looks like. </p>
<h2 id="heading-sns-and-sqs-in-combination-fanout-pattern">SNS and SQS in Combination - Fanout pattern</h2>
<p>In the article so far we&#39;ve looked at SNS and SQS as two distinguished services. There is a common pattern out there called which combines both services together.</p>
<p>It is called the <strong>fanout pattern</strong>.</p>
<p>The fanout pattern describes a scenario where messages published to SNS will be sent to several endpoints at the same time. With a pattern like that it is possible that one message triggers several executions. This allows for asynchronous processing.</p>
<p>For example:</p>
<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1653472354506/mW6L2ElU0.png?auto=compress,format&amp;format=webp" alt="Using AWS SQS and AWS SNS Fanout pattern with image uploads"/></p>
<p>A user uploads a picture to your application. You want to have several background processes kicking off when this happens. The following things should happen:</p>
<ol>
<li>Start image recognition and create a headline</li>
<li>Process the image and create a thumbnail</li>
<li>Notify the users </li>
</ol>
<p>All of these processes can run at the same time in the background. </p>
<p>Another example could be a social media network.</p>
<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1653472383054/3VXV94vWg.png?auto=compress,format&amp;format=webp" alt="Using the fanout pattern with AWS SNS and AWS SQS with a social network example"/></p>
<p>For each post published several actions should take. place:</p>
<ul>
<li>SQS Queue 1: Translate post to different languages</li>
<li>SQS Queue 2: Transform post into audio</li>
<li>SQS Queue 3: Update user statistics (number of posts)</li>
<li>Email: Notify followers about new post</li>
<li>In-App: Notify followers about new post</li>
</ul>
<h2 id="heading-questions">Questions</h2>
<p>There are a lot of questions I hear a lot when people start learning SNS and SQS. Let&#39;s have a look at some of the most common ones.</p>
<h3 id="heading-when-should-i-use-sns-vs-sqs">When should I use SNS vs. SQS?</h3>
<p>SNS:</p>
<ul>
<li>Multiple receivers</li>
<li>Receiver type is Email, SMS, or an In-App Notification</li>
<li>The message needs to be forwarded instantly</li>
</ul>
<p>SQS:</p>
<ul>
<li>Reliability is important</li>
<li>You have only one consumer</li>
<li>Complicated retry and error handling </li>
<li>Messages are picked up after some time and not instantly</li>
</ul>
<h3 id="heading-what-other-alternatives-are-out-there">What other alternatives are out there?</h3>
<p>One alternative to mention is definitely <strong>EventBridge</strong>. There are use cases where the choice for SNS or EventBridge overlap. EventBridge allows you to send events to a special event bus and EventBridge forwards your event to services such as SNS, SQS, Lambda, etc. </p>
<p>One of the main differences is that EventBridge allows to route and filter based on the whole event. There are also many different limits such as the 5 targets per event rule. </p>
<p>Another common message service is <strong>Kinesis</strong>. Kinesis is meant for processing and analyzing streaming data. </p>
<h3 id="heading-when-to-use-kinesis-vs-sns-vs-sqs">When to use Kinesis vs. SNS vs. SQS?</h3>
<p>Kinesis:</p>
<ul>
<li>Ongoing stream of data</li>
<li>Data needs to be processed or analyzed</li>
<li>Complex real-time requirements</li>
</ul>
<p>SNS:</p>
<ul>
<li>Multiple receivers</li>
<li>Receiver type is Email, SMS, or an In-App Notification</li>
<li>The message needs to be forwarded instantly</li>
</ul>
<p>SQS:</p>
<ul>
<li>Reliability is important</li>
<li>You have only one consumer</li>
<li>Complicated retry and error handling </li>
<li>Messages are picked up after some time and not instantly</li>
</ul>
<h3 id="heading-is-sqs-push-or-poll">Is SQS push or poll?</h3>
<p>SQS is a poll service. Consumers poll for messages. Even if you use an EventSourceMapping with AWS Lambda. The lambda is still polling multiple times and receives a lot of empty responses. </p>
<p>This is where SQS can get quite expensive if you have a large number of queues that get polled a lot. </p>
<h3 id="heading-which-targets-are-available-for-sqs">Which targets are available for SQS?</h3>
<p>SQS can be used with a lot of different targets. All systems that can call the AWS API can receive and remove messages from a queue. </p>
<p>SQS will often be used in combination with:</p>
<ul>
<li>AWS Lambda</li>
<li>Amazon ECS</li>
<li>Amazon EC2</li>
<li>Amazon SNS</li>
</ul>
<p>But you can use it with almost all systems that are out there.</p>
<h3 id="heading-is-sns-push-or-poll">Is SNS push or poll?</h3>
<p>SNS is a push system. It won&#39;t persist the message at all but push it directly to its consumers.</p>
<h3 id="heading-can-i-use-sns-for-push-notifications">Can I use SNS for Push Notifications?</h3>
<p>Yes! You can use SNS for push notifications on iOS and Android for example. </p>
<h2 id="heading-final-words">Final Words</h2>
<p>This article gave you an introduction to both AWS Services Amazon Simple Queue Service (SQS) and Amazon Simple Notification Service (SNS). These services build the basics of many distributed and decoupled applications out there. 
The service exists for many many years and was one of the main pillars of AWS. 
Using these services to build reliant and performant applications is crucial.</p>
<p>If you want to integrate a message queue into your application but don&#39;t want to learn the ins and outs of SQS and SNS I&#39;ll recommend giving <a href="https://serverlessq.com" target="_blank">serverlessq.com</a> a try. It is a hosted message queue solution that builds on top of these AWS services and makes it easier to use them. </p>
<h2 id="heading-references">References</h2>
<ul>
<li><a target="_blank" href="https://docs.aws.amazon.com/sns/latest/dg/sns-event-destinations.html">SNS Event Destinations</a></li>
<li><a target="_blank" href="https://docs.aws.amazon.com/general/latest/gr/sns.html#limits_sns">SNS Limits</a></li>
<li><a target="_blank" href="https://docs.aws.amazon.com/sns/latest/dg/sns-message-delivery-retries.html">SNS Retries</a></li>
<li><a target="_blank" href="https://aws.amazon.com/blogs/aws/queues-and-notifications-now-best-friends/">Fanout Pattern</a></li>
</ul>
</div></div>
  </body>
</html>
