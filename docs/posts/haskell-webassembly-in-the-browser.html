<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://joeyh.name/blog/entry/Haskell_webassembly_in_the_browser/">Original</a>
    <h1>Haskell WebAssembly in the Browser</h1>
    
    <div id="readability-page-1" class="page"><article class="page">







<div id="pagebody">

<section id="content" role="main">
<p><a href="http://joeyh.name/blog/pics/haskellinthebrowser.png"><img src="http://joeyh.name/blog/pics/haskellinthebrowser.png" width="861" height="559"/></a></p>

<p>As far as I know this is the first Haskell program
compiled to Webassembly (WASM) with mainline ghc and using the browser DOM.</p>

<p>ghc&#39;s WASM backend is solid, but it only provides very low-level FFI bindings
when used in the browser. Ints and pointers to WASM memory.
(<a href="https://gitlab.haskell.org/ghc/ghc-wasm-meta">See here for
details</a> and for instructions on getting the ghc WASM toolchain I used.)</p>

<p>I imagine that in the future, WASM code will interface with the DOM by
using a
<a href="https://bytecodealliance.org/articles/webassembly-the-updated-roadmap-for-developers">WASI &#34;world&#34;</a>
that defines a complete API (and browsers won&#39;t include Javascript engines
anymore). But currently, WASM can&#39;t do anything in a browser without
calling back to Javascript.</p>

<p>For this project, I needed 63 lines of (reusable) javascript
(<a href="https://git.joeyh.name/index.cgi/haskell-wasmjsbridge.git/tree/wasmjsbridge.js?id=076105852666e4337e7aeee50d1db73811271684">here</a>).
Plus another 18 to bootstrap running the WASM program
(<a href="https://git.joeyh.name/index.cgi/haskell-wasmjsbridge.git/tree/index.js?id=076105852666e4337e7aeee50d1db73811271684">here</a>).
(Also <a href="https://github.com/bjorn3/browser_wasi_shim">browser_wasi_shim</a>)</p>

<p>But let&#39;s start with the Haskell code. A simple program to pop up
an alert in the browser looks like this:</p>

<pre><code>{-# LANGUAGE OverloadedStrings #-}

import Wasmjsbridge

foreign export ccall hello :: IO ()

hello :: IO ()
hello = do
    alert &lt;- get_js_object_method &#34;window&#34; &#34;alert&#34;
    call_js_function_ByteString_Void alert &#34;hello, world!&#34;
</code></pre>

<p>A larger program that draws on the canvas and generated the image above
is <a href="https://git.joeyh.name/index.cgi/haskell-wasmjsbridge.git/tree/Hello.hs?id=076105852666e4337e7aeee50d1db73811271684">here</a>.</p>

<p>The Haskell side of the FFI interface is a bunch of fairly mechanical
functions like this:</p>

<pre><code>foreign import ccall unsafe &#34;call_js_function_string_void&#34;
    _call_js_function_string_void :: Int -&gt; CString -&gt; Int -&gt; IO ()

call_js_function_ByteString_Void :: JSFunction -&gt; B.ByteString -&gt; IO ()
call_js_function_ByteString_Void (JSFunction n) b =
      BU.unsafeUseAsCStringLen b $ \(buf, len) -&gt;
                _call_js_function_string_void n buf len
</code></pre>

<p>Many more would need to be added, or generated, to continue down this
path to complete coverage of all data types. All in all it&#39;s 64 lines
of code so far
(<a href="https://git.joeyh.name/index.cgi/haskell-wasmjsbridge.git/tree/Wasmjsbridge.hs?id=076105852666e4337e7aeee50d1db73811271684">here</a>).</p>

<p>Also a C shim is needed, that imports from WASI modules and provides
C functions that are used by the Haskell FFI. It looks like this:</p>

<pre><code>void _call_js_function_string_void(uint32_t fn, uint8_t *buf, uint32_t len) __attribute__((
        __import_module__(&#34;wasmjsbridge&#34;),
        __import_name__(&#34;call_js_function_string_void&#34;)
));

void call_js_function_string_void(uint32_t fn, uint8_t *buf, uint32_t len) {
        _call_js_function_string_void(fn, buf, len);
}
</code></pre>

<p>Another 64 lines of code for that
(<a href="https://git.joeyh.name/index.cgi/haskell-wasmjsbridge.git/tree/wasmjsbridge.c?id=076105852666e4337e7aeee50d1db73811271684">here</a>).
I found this pattern in Joachim Breitner&#39;s <a href="https://github.com/nomeata/haskell-on-fastly/blob/master/fastly-sys.c">haskell-on-fastly</a> and copied it rather blindly.</p>

<p>Finally, the Javascript that gets run for that is:</p>

<pre><code>call_js_function_string_void(n, b, sz) {
    const fn = globalThis.wasmjsbridge_functionmap.get(n);
    const buffer = globalThis.wasmjsbridge_exports.memory.buffer;
    fn(decoder.decode(new Uint8Array(buffer, b, sz)));
},
</code></pre>

<p>Notice that this gets an identifier representing the javascript function
to run, which might be any method of any object. It looks it up in a map
and runs it. And the ByteString that got passed from Haskell has to be decoded to a
javascript string.</p>

<p>In the Haskell program above, the function is <code>document.alert</code>. Why not
pass a ByteString with that through the FFI? Well, you could. But then
it would have to eval it. That would make running WASM in the browser be
evaling Javascript every time it calls a function. That does not seem like a
good idea if the goal is speed. GHC&#39;s
<a href="https://ghc.gitlab.haskell.org/ghc/doc/users_guide/javascript.html">javascript backend</a>
does use Javascript`FFI snippets like that, but there they get pasted into the generated
Javascript hairball, so no eval is needed.</p>

<p>So my code has things like <code>get_js_object_method</code> that look up things like
Javascript functions and generate identifiers. It also has this:</p>

<pre><code>call_js_function_ByteString_Object :: JSFunction -&gt; B.ByteString -&gt; IO JSObject
</code></pre>

<p>Which can be used to call things like <code>document.getElementById</code>
that return a javascript object:</p>

<pre><code>getElementById &lt;- get_js_object_method (JSObjectName &#34;document&#34;) &#34;getElementById&#34;
canvas &lt;- call_js_function_ByteString_Object getElementById &#34;myCanvas&#34;
</code></pre>

<p>Here&#39;s the Javascript called by <code>get_js_object_method</code>. It generates a
Javascript function that will be used to call the desired method of the object,
and allocates an identifier for it, and returns that to the caller.</p>

<pre><code>get_js_objectname_method(ob, osz, nb, nsz) {
    const buffer = globalThis.wasmjsbridge_exports.memory.buffer;
    const objname = decoder.decode(new Uint8Array(buffer, ob, osz));
    const funcname = decoder.decode(new Uint8Array(buffer, nb, nsz));
    const func = function (...args) { return globalThis[objname][funcname](...args) };
    const n = globalThis.wasmjsbridge_counter + 1;
    globalThis.wasmjsbridge_counter = n;
    globalThis.wasmjsbridge_functionmap.set(n, func);
    return n;
},
</code></pre>

<p>This does mean that every time a Javascript function id is looked up,
some more memory is used on the Javascript side. For more serious uses of this,
something would need to be done about that. Lots of other stuff like
object value getting and setting is also not implemented, there&#39;s
no support yet for callbacks, and so on. Still, I&#39;m happy where this has
gotten to after 12 hours of work on it.</p>

<p>I <em>might</em> release the reusable parts of this as a Haskell library, although
it seems likely that ongoing development of ghc will make it obsolete. In the
meantime, clone the
<a href="https://git.joeyh.name/index.cgi/haskell-wasmjsbridge.git/">git repo</a>
to have a play with it.</p>

<hr/>

<p>This blog post was sponsored by unqueued <a href="https://patreon.com/joeyh">on Patreon</a>.</p>

</section>









</div>



</article></div>
  </body>
</html>
