<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://frederikbraun.de/why-sethtml.html">Original</a>
    <h1>Why the Sanitizer API is just `setHTML()`</h1>
    
    <div id="readability-page-1" class="page"><div id="wrapper">
<div id="text1">
        
<header>
  
  <time datetime="2025-12-07T00:00:00+01:00">Sun 07 December 2025</time>
</header>
<article>
    <p>Sanitizing HTML is the practice of taking a piece of HTML and removing some
unwanted elements and attributes. Most often this is done to allow
user-generated content with HTML but without causing XSS bugs.
When imported from a library, a sanitizer typically looks like this:</p>
<div><pre><span></span><code><span>const</span><span> </span><span>clean</span><span> </span><span>=</span><span> </span><span>DOMPurify</span><span>.</span><span>sanitize</span><span>(</span><span>input</span><span>);</span>
<span>context</span><span>.</span><span>innerHTML</span><span> </span><span>=</span><span> </span><span>clean</span><span>;</span>
</code></pre></div>

<p>However, the API that we are building doesn&#39;t look like this at all.
The core feature of the Sanitizer API is actually just <code>Element.setHTML(input)</code>.</p>
<p>This blog post will explain why.</p>
<p>To do so, we have to study the two lines of code from the DOMPurity example
above. They result in the following steps:</p>
<ol>
<li>Take an input string (and optionally a list of allowed elements as parameter).</li>
<li>Parse the input into an HTML fragment (no context element given).</li>
<li>Traverse the HTML fragment and remove elements as configured.</li>
<li>Serialize the remaining fragment into a string.</li>
<li>Parse the sanitized string (again), this time with <code>context</code> as context node
into a fragment.</li>
<li>Insert the new fragment below <code>context</code> in the DOM tree.</li>
</ol>
<p>Quick exercise for the reader: Can you spot where line 1 (<code>DOMPurify.sanitize()</code>)
stops and line 2 (the <code>innerHTML</code> assignment) starts?</p>
<details>
  <summary>Solution</summary>
  <code>DOMPurify.sanitize()</code> includes steps 1 through 4. The
  <code>innerHTML</code> assignment.
  is steps 5-6.
</details>

<p>This is pretty similar to the Sanitizer that I wanted to build into the browser:</p>
<div><pre><span></span><code><span>const</span><span> </span><span>mySanitizer</span><span> </span><span>=</span><span> </span><span>new</span><span> </span><span>Sanitizer</span><span>(</span><span>/* config */</span><span>);</span>
<span>//XXX This never shipped.</span>
<span>context</span><span>.</span><span>innerHTML</span><span> </span><span>=</span><span> </span><span>Sanitizer</span><span>.</span><span>sanitize</span><span>(</span><span>input</span><span>);</span>
</code></pre></div>

<p>But that is <em>NOT</em> the Sanitizer we ended up with.</p>
<p>And the reason is essentially Mutated XSS (mXSS).
To quickly recap, the idea behind mXSS is that HTML parsing is not
stable and a line of HTML being parsed and serialized and parsed again
may turn into something rather different.
(See <a href="https://www.sonarsource.com/blog/mxss-the-vulnerability-hiding-in-your-code/">this description of mXSS bugs collected by SonarSource</a>
if you need a refresher.)</p>
<p>Another key point with mXSS is that HTML parsing can be quite <em>context-sensitive</em>:
How an input string will be interpreted depends on the current node it is being
inserted into.</p>
<p>Now let&#39;s go back to the algorithm steps 1-6. Did you notice that step 2 and 5 both
perform HTML parsing? DOMPurify and most other sanitizers do this <em>without</em> any
supplied context element. Typically, they parse into a new document and
only return the content of the resulting <code>&lt;body&gt;</code>. The second parse step
(step 5), however, <em>does</em> include a context element.</p>
<p>This means that we are parsing the input subtly different each time.
We accidentally built a <a href="https://langsec.org/">weird machine</a> that
will turn HTML into mXSS.</p>
<p>A better HTML sanitizer therefore needs to do away with all of that.
How about the following:</p>
<ul>
<li>Use the right context when parsing HTML input.</li>
<li>Remove the need for parsing twice.</li>
</ul>
<p>Starting from an API design with a constructor like <code>new Sanitizer()</code>,
it felt pretty hard to think of a context-sensitive method.
I wanted something like <code>Sanitizer.sanitize(input, context)</code>.
But how would we actually ensure that the return value can not be used another,
potentially wrong <code>context</code>?</p>
<p>What we settled on was an API that has no return value:</p>
<div><pre><span></span><code><span>context</span><span>.</span><span>setHTML</span><span>(</span><span>input</span><span>,</span><span> </span><span>{</span><span>sanitizer</span><span>:</span><span> </span><span>...</span><span> </span><span>}</span><span> </span><span>);</span>
</code></pre></div>

<p>The internal algorithm is now the following:</p>
<ol>
<li>Parse the input (with the right context element) into a document fragment</li>
<li>Traverse the resulting fragment and sanitize. (Using safe defaults or a
user-specified configuration).</li>
<li>Replace the child nodes below <code>context</code> with the sanitized up fragment.</li>
</ol>
<p>No superfluous parsing. No ambiguous contexts. Just setting HTML.</p>
<p>As a nice side-effect, you can replace existing code in the style of
<code>ctx.innerHTML = input</code> with <code>context.setHTML(input)</code> and it should just work
the same.</p>
<p>Except that there&#39;s no XSS.</p>
<p>To learn more about the Sanitizer API, please continue on
<a href="https://developer.mozilla.org/en-US/docs/Web/API/HTML_Sanitizer_API/Using_the_HTML_Sanitizer_API">MDN</a>,
in the <a href="https://sanitizer-api.dev/">Sanitizer Playground</a>,
or the <a href="https://github.com/WICG/sanitizer-api/">Specification</a>).</p>
</article>

<hr/>

<section id="minicontact">
<em>
<!-- Please comment on <a href="https://social.security.plumbing/@freddy">Mastodon</a>. -->
If you find a mistake in this article, you can <a href="https://github.com/freddyb/homepage/edit/main/content/2025-12-why-sethtml.md">submit a pull request on GitHub</a>.
</em>
</section>

<section id="article-list">
<h4>Recent posts</h4>
<ol>
  <li><a href="https://frederikbraun.de/why-sethtml.html">Why the Sanitizer API is just <code>setHTML()</code></a>
    <em>(Sun 07 December 2025)</em>
  </li>
  <li><a href="https://frederikbraun.de/lego-star-wars-complete-saga-c3po-bug.html">The C3PO Bug in Lego Star Wars: The Complete Saga</a>
    <em>(Sat 06 December 2025)</em>
  </li>
  <li><a href="https://frederikbraun.de/madweb-keynote-2025.html">With Carrots &amp; Sticks - Can the browser handle web security?</a>
    <em>(Tue 08 April 2025)</em>
  </li>
  <li><a href="https://frederikbraun.de/home-assistant-can-not-be-secured-for-internet-access.html">Home assistant can not be secured for internet access</a>
    <em>(Sun 15 December 2024)</em>
  </li>
  <li><a href="https://frederikbraun.de/modern-solutions-xsleaks.html">Modern solutions against cross-site attacks</a>
    <em>(Tue 26 November 2024)</em>
  </li>
            
</ol>
</section>
</div>
</div></div>
  </body>
</html>
