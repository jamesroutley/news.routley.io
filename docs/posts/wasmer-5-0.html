<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://wasmer.io/posts/introducing-wasmer-v5">Original</a>
    <h1>Wasmer 5.0</h1>
    
    <div id="readability-page-1" class="page"><div><p>We are thrilled to announce the release of <strong>Wasmer 5.0</strong>, the latest milestone in our journey to make WebAssembly the greatest tool for executing software anywhere.</p>
<p>This announcement comes packed with awesome new features:</p>
<ul>
<li>Experimental support for more backends: <strong>V8</strong>, <strong>Wasmi</strong> and <strong>WAMR</strong></li>
<li><strong>iOS</strong> support</li>
<li>Leaner codebase</li>
<li>Enhanced Performance</li>
<li>Upgraded Compilers (now using LLVM 18 and latest Cranelift)</li>
</ul>
<p>Do you like the new features? Don&#39;t wait and give us a ⭐️ on Github! <a href="https://github.com/wasmerio/wasmer">github.com/wasmerio/wasmer</a></p>
<hr/>

<h2>New experimental backends</h2>
<p>Some time ago <a href="https://github.com/wasmerio/wasmer/discussions/3839">we asked in Wasmer’s Community</a> which backend would you like to see Wasmer support next.</p>
<p>The responses were overwhelming: V8 (the engine behind Google’s Chrome Javascript runtime) was the most voted backend, with 56% of the votes. We learned from the poll results that interpreter support was also a desire from the community.</p>
<p><img src="https://wasmer.io/_next/image?url=https%3A%2F%2Fcdn.wasmer.io%2Fimages%2Fwasmer-backend-poll.original.png&amp;w=1920&amp;q=75" alt="Wasmer Backend Community Poll"/></p>
<p>Well, the day has come. We have added support for more backends: V8, Wasmi and also WAMR. All of them are integrated via the <a href="https://github.com/WebAssembly/wasm-c-api">Wasm-C-API</a> , as they all share this external interface in common.</p>
<p>Thanks to the latest additions, now any interpreter or runtime that supports the Wasm-C-API spec can be easily integrated into Wasmer.</p>
<p>We expect that the V8 integration will allow bringing a great debugging experience via the V8 debugger and <a href="https://developer.chrome.com/docs/devtools/">Chrome Devtools</a>. But not only that, having V8 as a backend also means supporting WebAssembly Exceptions and Garbage Collection under the hood. Stay tuned for more news on this front soon.</p>
<p>As of today, Wasmer supports the following backends, so you can run WebAssembly using the Wasmer API in the following contexts:</p>
<ul>
<li><strong>Natively</strong> (via Wasmer native compilers)
<ul>
<li>Singlepass (<code>singlepass</code> feature): ideal for blockchains</li>
<li>Cranelift (<code>cranelift</code> feature): ideal for development</li>
<li>LLVM (<code>llvm</code> feature): ideal for production workloads</li>
</ul>
</li>
<li><strong>Browser</strong>: the browser’s underlying Wasm engine (<code>web</code> feature)
See <a href="https://github.com/wasmerio/wasmer-js">https://github.com/wasmerio/wasmer-js</a> for more info.</li>
<li><strong>JavascriptCore</strong>: JavascriptCore engine from Apple. Ideal if you want to use a lightweight and incredibly performant runtime in macOS (<code>jsc</code> feature)</li>
<li><strong>V8</strong>: Google’s JS V8 engine, ideal if you want to use Wasmer in iOS or Android (<code>v8</code> feature)</li>
<li><strong>Wasmi</strong>: one of the most optimal Rust WebAssembly interpreters. Ideal if you want to use Wasm in <code>nostd</code> environments or blockchains with a pure Rust codebase (<code>wasmi</code> feature)</li>
<li><strong>WAMR</strong>: (<code>wamr</code> feature) ideal for iOS</li>
</ul>
<p>So… how fast are each of the backends?</p>
<h3>Benchmarking the backends</h3>
<p>We have run an extensive set of benchmarks based on <a href="https://wasmi-labs.github.io/blog/posts/wasmi-v0.32/">Wasmi’s great benchmarking blogpost</a> to see how each of these backends behave for diverse scenarios. Here are our findings!</p>
<p><img src="https://wasmer.io/_next/image?url=https%3A%2F%2Fcdn.wasmer.io%2Fimages%2Fwasmer-5-time-argon2.original.png&amp;w=1920&amp;q=75" alt="Wasmer 5 Argon 2 benchmark"/></p>
<p><img src="https://wasmer.io/_next/image?url=https%3A%2F%2Fcdn.wasmer.io%2Fimages%2Fwasmer-5-time-bulkops.original.png&amp;w=1920&amp;q=75" alt="Wasmer 5 Bulk Operations benchmark"/></p>
<p><img src="https://wasmer.io/_next/image?url=https%3A%2F%2Fcdn.wasmer.io%2Fimages%2Fwasmer-5-time-counter.original.png&amp;w=1920&amp;q=75" alt="Wasmer 5 Counter benchmark"/></p>
<p><img src="https://wasmer.io/_next/image?url=https%3A%2F%2Fcdn.wasmer.io%2Fimages%2Fwasmer-5-time-primes.original.png&amp;w=1920&amp;q=75" alt="Wasmer 5 Primes benchmark"/></p>
<p><img src="https://wasmer.io/_next/image?url=https%3A%2F%2Fcdn.wasmer.io%2Fimages%2Fwasmer-5-time-fibonacci-iterative.original.png&amp;w=1920&amp;q=75" alt="Wasmer 5 Fibonacci (iterative) benchmark"/></p>
<p><img src="https://wasmer.io/_next/image?url=https%3A%2F%2Fcdn.wasmer.io%2Fimages%2Fwasmer-5-time-fibonacci-recursive.original.png&amp;w=1920&amp;q=75" alt="Wasmer 5 Fibonacci (recursive) benchmark"/></p>
<p><img src="https://wasmer.io/_next/image?url=https%3A%2F%2Fcdn.wasmer.io%2Fimages%2Fwasmer-5-time-matmul.original.png&amp;w=1920&amp;q=75" alt="Wasmer 5 Matmul benchmark"/></p>
<h2>Full iOS Support via WAMR, Wasmi and V8 bindings</h2>
<p>For the first time, Wasmer brings WebAssembly to <strong>iOS</strong> devices through a new interpreted mode.</p>
<p><img src="https://wasmer.io/_next/image?url=https%3A%2F%2Fcdn.wasmer.io%2Fimages%2Fwasmer-5-ios-new.original.png&amp;w=1920&amp;q=75" alt="Wasmer 5 Running on iOS"/></p>
<p>About a year ago we added support for <a href="https://wasmer.io/posts/wasmer-3_3-and-javascriptcore">JavacriptCore in Wasmer</a>, with the hope that it would enable a fast runtime on iOS (since the JIT would be unrestricted). Unfortunately, iOS capped the ability of using WebAssembly via JavascriptCore (since iOS 14).</p>
<p>Leveraging the capabilities of <strong>V8</strong>, <strong>Wasmi</strong> and <strong>WebAssembly Micro Runtime (WAMR)</strong>, developers can now run WebAssembly modules seamlessly on iOS thanks to Wasmer 5.0. No changes needed on their codebase. This opens up a world of possibilities for mobile development, enabling high-performance applications on Apple&#39;s ecosystem.</p>
<p>We want to thank <a href="https://www.holochain.org/">Holochain</a> as this work wouldn’t be possible without our partnership.</p>
<h2>Leaner codebase</h2>
<p>For the release of Wasmer 5.0 we have put an special emphasis on making Wasmer codebase as lean as possible, so we can develop new features even faster.</p>
<p>As part of this effort, we realized that:</p>
<ul>
<li>Emscripten bindings have been mostly unused in the last two years, mainly influenced by these two factors:
<ul>
<li>Emscripten emits code using WASI systemcalls under the hood when possible, removing the need for having special bindings for Emscripten</li>
<li><a href="https://wasix.org/">WASIX</a> helps to bridge the gap of the WASI systemcalls that are not supported (<code>threads</code>, <code>longjmp/setjmp</code>, <code>fork</code>, …)</li>
</ul>
</li>
<li>Some of the dependencies Wasmer used have been long unmaintained, or duplicated by newer and safer crates</li>
</ul>
<p>Because of that, we decided to drop support for Emscripten and trimmed up the dependencies resulting in a net result of <strong>20k lines of code deleted</strong> in the Wasmer codebase.</p>
<h2>Enhanced Performance</h2>
<p>Module deserialization now is up to 50% faster (that is, when you call <code>Module::deserialize</code> or when you run a module via <code>wasmer run</code>).</p>
<p>Performance is at the heart of Wasmer, and version 5.0 takes it to the next level. These improvements are leveraging essential updates on <strong>rkyv:</strong> the zero-copy deserialization library that we use to deserialize our Modules.</p>
<p>Here’s a benchmark of all the backends using latest Wasmer vs the latest release.</p>
<p><img src="https://wasmer.io/_next/image?url=https%3A%2F%2Fcdn.wasmer.io%2Fimages%2Fwasmer-5-time-deserialize.original.png&amp;w=1920&amp;q=75" alt="Wasmer 5 Time to deserialize a WebAssembly module"/></p>
<h2>Upgraded Compilers: Cranelift  and LLVM 18</h2>
<p>The latest Cranelift integration results in significant runtime speed improvements, making your WebAssembly modules execute faster than ever before.</p>
<p>Wasmer 5.0 now includes the most recent version of <strong>LLVM (18)</strong>, ensuring that developers have access to the latest optimizations from the toolchain. The LLVM upgrade enhances compatibility and performance, providing a robust foundation for compiling and running complex WebAssembly modules.</p>
<p>On top of that, Wasmer 5.0 also ships with experimental <em>LoongAarch64</em> support.</p>
<p>We have also benchmarked <code>coremark</code> with the latest version of the compilers to see how they compare:
<img src="https://wasmer.io/_next/image?url=https%3A%2F%2Fcdn.wasmer.io%2Fimages%2Fwasmer-5-time-coremark.original.jpg&amp;w=1920&amp;q=75" alt="Wasmer 5 Coremark results"/></p>
<blockquote>
<p>LLVM and Cranelift are about 8% faster in Wasmer v5.0 compared to v4.4.0</p>
</blockquote>

<p>Ready to dive in? Here&#39;s how you can start exploring the new features:</p>
<ul>
<li><strong>Download Wasmer 5.0</strong>: Get the latest version from our <a href="https://wasmer.io/">official website</a>.</li>
<li><strong>Update Your Projects</strong>: Upgrade your existing Wasmer projects to leverage the new capabilities.</li>
<li><strong>Explore the Documentation</strong>: Visit our updated docs for detailed guides and tutorials.</li>
<li><strong>Join the Community</strong>: Connect with other developers on our Discord server and share your experiences.</li>
</ul>
<h2>Looking Ahead</h2>
<p>Wasmer 5.0 is a significant step forward in our mission to empower developers thanks of the exciting possibilities that WebAssembly brings to the table. With iOS support, our pluggable backend architecture and the enhanced performance, the possibilities are now endless. We can&#39;t wait to see what you&#39;ll build next with Wasmer.</p>
<hr/>
<p><strong>Stay Updated</strong></p>
<ul>
<li><strong>Website</strong>: <a href="https://wasmer.io/">wasmer.io</a></li>
<li><strong>GitHub</strong>: <a href="https://github.com/wasmerio/wasmer">github.com/wasmerio/wasmer</a></li>
<li><strong>Twitter</strong>: <a href="https://twitter.com/wasmerio">@wasmerio</a></li>
<li><strong>Discord</strong>: <a href="https://discord.gg/rWkMNStrEW">Join our community</a></li>
</ul>
<p>Thank you everyone for being part of the Wasmer journey!</p></div></div>
  </body>
</html>
