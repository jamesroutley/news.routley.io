<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.janestreet.com/zero-knowledge-fpgas-hardcaml/">Original</a>
    <h1>Accelerating zk-SNARKs - MSM and NTT algorithms on FPGAs with Hardcaml</h1>
    
    <div id="readability-page-1" class="page"><div>
      <p>In 2022 a consortium of companies ran an international competition,
called the <a href="https://www.zprize.io/">ZPrize</a>, to advance the state of
the art in “zero-knowledge” cryptography. We decided to have a go in
our free time at submitting solutions to both the Multi-Scalar
Multiplication (MSM) and Number Theoretic Transform (NTT) tracks,
using the same open source <a href="https://hardcaml.com/">Hardcaml</a> libraries
that Jane Street uses for our own FPGA development. We believe by
using Hardcaml we were able to more efficiently and robustly come up
with designs in the short competition period. These designs also
interact with the standard vendor RTL flow and so we hope they will be
useful to others.</p>

<p>Our MSM solution, implemented on the BLS12-377 curve, beats all
current FPGA state of the art, including the recently released
<a href="https://eprint.iacr.org/2022/1396.pdf">Cyclone MSM</a> and
<a href="https://eprint.iacr.org/2022/999">PipeMSM</a>. It’s able to calculate 4
rounds of 2<sup>26</sup> MSMs 20.331s, an average of 5.083s per MSM,
and won first place in the ZPrize MSM track. Our
power-area-performance balanced NTT solution took second place in the
ZPrize NTT track. Full results are available
<a href="https://www.zprize.io/blog/announcing-zprize-results">here</a>.</p>

<p>Our results and a bit of background on the competition are summarized
below. For more detailed reading, we have created a <a href="https://zprize.hardcaml.com/">Hardcaml ZPrize
website</a>.</p>

<h2 id="zero-knowledge-proofs">Zero-knowledge proofs</h2>

<p><a href="https://en.wikipedia.org/wiki/Zero-knowledge_proof">Zero-knowledge proofs
(ZKPs)</a> are
powerful cryptography tools that allow a prover to prove that a
certain statement is true without revealing any other information to
the verifier. For example for a given function <em>F</em> and publicly known
<em>x</em>, a prover can show <em>F(x,w) = y</em>, without revealing <em>w</em> to the
verifier.</p>

<p>This property means ZKPs are attractive in contexts where online
privacy is paramount, for instance anonymous voting. They also form
the backbone of certain blockchain features
(<a href="https://ethereum.org/en/developers/docs/scaling/zk-rollups/">zk-Rollups</a>)
and <a href="https://en.wikipedia.org/wiki/Web3">“Web3”</a> applications, and
have been becoming increasingly popular in recent years.</p>

<p>One class of ZKP getting attention lately is called “Zero-knowledge
Succinct Non-interactive Arguments of Knowledge” (zk-SNARKs). These
require no interaction between the prover and verifier, and are
compact and quick to verify.</p>

<p>The problem is that while verifying is relatively fast, constructing
the proof of a zk-SNARK can be quite time consuming—minutes or even
hours when there is a large number of constraints. Most of this time
is spent in the calculation of NTTs and MSMs (roughly 30% and 70%
respectively). Current systems that use zk-SNARKs tend to have
constraint sizes in the millions.</p>

<p>Before describing our specific solutions, we’ll briefly introduce the
underlying cryptographic primitives.</p>

<h3 id="elliptic-curve-cryptography">Elliptic curve cryptography</h3>

<p>Elliptic curve cryptography (ECC) allows for smaller keys compared to
non-EC cryptography such as RSA (modular exponentiation based on
plain Galois fields), to provide the same level of security. For
example a small 228 bit ECC key requires as much time to crack as a
much larger 2,380 bit RSA key. A smaller key here means cryptographic
systems and the data transfer involved can be much more compact and
faster.</p>

<p>All ECC calculations take place within <em>F<sub>p</sub></em>, a finite field
of integers modulus a large prime <em>p</em>, and in particular are performed
over cyclic groups which have a generator <em>g</em> (all elements in the
group can be generated from this point).</p>

<p>Basic operations on a elliptic curve are point addition and point
doubling, which are used repeatedly in the MSM algorithm. In order to
implement point operations, we are performing multiplications and
additions modulo a prime. These operations can further be optimized
with efficient modulo reduction algorithms such as Barrett or
Montgomery, and better-than-<em>O(n<sup>2</sup>)</em> multiplication
techniques such as the Karatsuba algorithm.</p>

<p>zk-SNARKs make use of ECC primitives, through several well-known
prover algorithms such as
<a href="https://eprint.iacr.org/2016/260.pdf">Groth16</a>. But the problem is
the more complex zk-SNARK we want to implement, the more constraints
we need—which translates directly into very large polynomials.</p>

<p>It’s the operations on these large polynomials (order <em>2<sup>26</sup></em>
and up) that require fast MSM and NTT solutions. NTTs are used to
achieve an <em>O(NlogN)</em> rather than <em>O(n<sup>2</sup>)</em> time complexity
in polynomial multiplication; MSMs are needed for the exponentiation
of the elliptic curve points, described more in the next section.</p>

<p>The diagram below shows that in order to accelerate zk-SNARKs, we need
to focus on both MSM and NTT problems, which in turn require novel
optimizations in their ECC primitives—a full-stack solution.</p>

<p><a href="https://blog.janestreet.com/zero-knowledge-fpgas-hardcaml/zksnarks.png"><img src="https://blog.janestreet.com/zero-knowledge-fpgas-hardcaml/zksnarks.png" alt="zk-SNARKs"/></a>

zk-SNARKs</p>


<h2 id="our-solutions-to-the-msm-and-ntt-problems">Our solutions to the MSM and NTT problems</h2>

<h3 id="msm">MSM</h3>

<p>In general, the MSM problem is to take a list of scalars and points
and compute the sum of each of the points scaled by its corresponding
scalar. For the MSM prize track, we were tasked with performing the
MSM computation over a fixed set of 2<sup>26</sup> elliptic curve
points from the <a href="https://eips.ethereum.org/EIPS/eip-2539">BLS 12-377 G1
curve</a> and a randomly sampled
set of scalars from the corresponding scalar field. (Because the
points are fixed, this is sometimes referred to as a “fixed-base
MSM”.)</p>

<p>To solve this problem, we implemented a heavily optimized version of
<a href="https://epubs.siam.org/doi/10.1137/0209022">Pippenger’s algorithm</a> (explained
<a href="https://zprize.hardcaml.com/msm-top-level-pippenger-design.html">here</a>).</p>

<p>We implemented a solution that uses the FPGA to do the vast majority
of the computational work, while the host does a much smaller set of
computations to obtain the final result. By splitting the work between
the x86 host and the FPGA, we were able to focus on optimizing the
algorithm for implementation on an FPGA while leaving seldom-seen
corner cases to the host. One challenge we had to overcome with
fragmenting the computation like this was how to architect system
communication to allow the FPGA to start streaming and processing the
next round of calculations, while in parallel having the host finish
up the previous batch.</p>

<p>The core of our design is a fully pipelined, optimized elliptic curve
point adder. The majority of the work in Pippenger’s algorithm
consists of adding the points into buckets based on their
coefficients. By performing all of these bucket accumulations on the
FPGA, we accelerate the entire algorithm. However, because elliptic
curve point addition is a complex operation, our pipelined adder has
over 200 pipeline stages! Flushing the pipeline every time we hit a
data hazard while adding points into the same bucket would destroy our
throughput, so we also implement a controller which coordinates
stalling and adding points into buckets to avoid data hazards. The
FPGA then streams these partial bucket sums back to the host, where
they are combined to produce the final result.</p>

<p><a href="https://blog.janestreet.com/zero-knowledge-fpgas-hardcaml/msm_top_level.png"><img src="https://blog.janestreet.com/zero-knowledge-fpgas-hardcaml/msm_top_level.png" alt="Overview of our MSM solution"/></a>
Overview of our MSM solution</p>


<p>We made a number of optimizations, both algorithmic and
engineering-wise, across the full stack of the solution, including
finite field operations, elliptic curve arithmetic, and Pippenger’s
algorithm. For a detailed discussion of our techniques and
optimizations, see our
<a href="https://zprize.hardcaml.com/msm-overview">website</a>.</p>

<h4 id="results">Results</h4>

<p>We implemented our MSM solution on an AWS f1.2xlarge instance which
costs $1.65 per hour, over various input sizes up to 2<sup>26</sup>
inputs. The FPGA card uses a V9P UltraScale+ Xilinx chip. We report
both the total latency for 4 rounds of MSM, as well as the latency for
a single round, over several different MSM sizes. “Masked 1 round
latency” is the average of 4 rounds, taking into account our
optimizations that allow host and FPGA work to be parallelized.
“Unmasked 1 round latency” means we explicitly calculate one round,
which shows the overhead of doing work on the host.</p>

<div>
  <table>
    <thead>
      <tr>
        <th>Input size</th>
        <th>4 round latency (s)</th>
        <th>Masked 1 round latency (s)</th>
        <th>Unmasked 1 round latency (s)</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>2<sup>26</sup></td>
        <td>20.331</td>
        <td>5.083</td>
        <td>5.518</td>
      </tr>
      <tr>
        <td>2<sup>25</sup></td>
        <td>10.398</td>
        <td>2.600</td>
        <td>2.989</td>
      </tr>
      <tr>
        <td>2<sup>24</sup></td>
        <td>5.967</td>
        <td>1.492</td>
        <td>1.724</td>
      </tr>
      <tr>
        <td>2<sup>23</sup></td>
        <td>3.901</td>
        <td>0.975</td>
        <td>1.092</td>
      </tr>
      <tr>
        <td>2<sup>22</sup></td>
        <td>2.883</td>
        <td>0.720</td>
        <td>0.779</td>
      </tr>
    </tbody>
  </table>
</div>

<p>Average running power used by the FPGA design is 52 watts regardless
of input size. For detailed resource usage and even more detailed
latency breakdowns see our
<a href="https://blog.janestreet.com/zero-knowledge-fpgas-hardcaml/zprize.hardcaml.com/msm-results.html">website</a>.</p>

<h3 id="ntt">NTT</h3>

<p>The Number Theoretic Transform (NTT) is very similar to the Fast
Fourier Transform (FFT), except that it operates over a finite field
instead of complex numbers. NTTs replace the normal twiddle factors
you see in an FFT with a new finite primitive root of unity w, where w
is the n<sup>th</sup> root of unity if w<sup>n</sup> = 1 modulo some
large prime number. In this competition, we were required to use the
<a href="https://en.wikipedia.org/wiki/Solinas_prime">Solinas prime</a>
<em>2<sup>64</sup>-2<sup>32</sup>+1</em>.</p>

<p>Our NTT solution was written to target a C1100 FPGA accelerator card,
 and implements the <a href="https://zprize.hardcaml.com/ntt-4step.html">4-step
 algorithm</a> over a
 <em>2<sup>24</sup></em> NTT.</p>

<p>By choosing this algorithm we were able to decompose the original NTT
into many smaller ones that can be run in parallel. The smaller NTTs,
each of size <em>2<sup>12</sup></em>, can easily fit in the available SRAM
resources on the FPGA. These smaller transforms were implemented using
the well-known <a href="https://en.wikipedia.org/wiki/Cooley%E2%80%93Tukey_FFT_algorithm">Cooley-Tukey
FFT</a>
algorithm adapted for a finite field.</p>

<p>We decided to implement 8 parallel cores as a cluster, as this matched
our HBM bus width of 512 bits. Each core inputs and outputs 64 bits
and has its own field multiplier and two adders. All the cores in a
cluster share a single controller. We can then instantiate multiple
clusters of cores over the FPGA to achieve high parallelism. The
diagram below highlights the blocks and data-flow between off-chip
memory (HBM) and on-chip SRAM.</p>

<p><a href="https://blog.janestreet.com/zero-knowledge-fpgas-hardcaml/parallel-ntt-top-level.png"><img src="https://blog.janestreet.com/zero-knowledge-fpgas-hardcaml/parallel-ntt-top-level.png" alt="NTT core scaling"/></a>
 NTT core scaling</p>


<p>We have a much more detailed writeup of the algorithms used, plus
source code and instructions for building from scratch
<a href="https://zprize.hardcaml.com/ntt-overview">here</a>.</p>

<h4 id="results-1">Results</h4>

<p>We experimented with different core counts on a single C1100 Varium
 card, with results listed below for a full 2<sup>24</sup> NTT:</p>

<div>
  <table>
    <thead>
      <tr>
        <th>Cores</th>
        <th>Latency (s)</th>
        <th>Power (W)</th>
        <th>LUTs</th>
        <th>Registers</th>
        <th>DSP</th>
        <th>BRAM36</th>
        <th>URAM</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>8</td>
        <td>0.2315</td>
        <td>16.97</td>
        <td>107291</td>
        <td>141006</td>
        <td>260</td>
        <td>162</td>
        <td>48</td>
      </tr>
      <tr>
        <td>16</td>
        <td>0.1238</td>
        <td>18.19</td>
        <td>126422</td>
        <td>156149</td>
        <td>512</td>
        <td>162</td>
        <td>96</td>
      </tr>
      <tr>
        <td>32</td>
        <td>0.0691</td>
        <td>21.13</td>
        <td>166488</td>
        <td>184436</td>
        <td>1028</td>
        <td>162</td>
        <td>192</td>
      </tr>
      <tr>
        <td>64</td>
        <td>0.0450</td>
        <td>27.70</td>
        <td>265523</td>
        <td>246385</td>
        <td>2052</td>
        <td>162</td>
        <td>384</td>
      </tr>
    </tbody>
  </table>
</div>

<h2>Future work</h2>

<p>Due to time constraints, there were a number of optimizations that we
did not have a chance to experiment with. We discuss them at length on
the corresponding page of our
<a href="https://zprize.hardcaml.com/msm-future-work.html">website</a>.</p>




    </div></div>
  </body>
</html>
