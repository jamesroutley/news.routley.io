<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://stpn.bearblog.dev/reproducing-double-descent/">Original</a>
    <h1>reproducing deep double descent</h1>
    
    <div id="readability-page-1" class="page"><div>
    

    
        
    

    
        

        <p>
            <i>
                <time datetime="2025-06-04T04:00Z">
                    04 Jun, 2025
                </time>
            </i>
        </p>
    

    <p>This summer, I&#39;ve been at the <a href="https://www.recurse.com/scout/click?t=5523c0b9c525bf244fc04081e71a485a">recurse center</a> intensively trying to catch up to the current state of the machine learning world. I don&#39;t have any prior background in ML, so I&#39;ve been taking some <a href="https://arena-chapter0-fundamentals.streamlit.app">classes</a> and reading a lot of papers.</p>
<p>Two weeks in, I now have some basic working knowledge and wanted to get my hands dirty. After reading the Deep Double Descent paper, I wanted to see if I understood enough to reproduce the results. In a <a href="https://stpn.bearblog.dev/notes-on-renting-a-gpu/">previous post</a>, I went over some notes about doing the training for this on a rental GPU, but I figured I&#39;d go into details about the project itself.</p>
<p>Please note the understanding here is still one of a student - if you spot something wrong, please send me a <a href="mailto:mail@stephenwan.net">message</a>!</p>
<p>For a long time, the ML community thought that models could only be so big before they started degrading in accuracy. Around the start of the GPT era, folks realized that you could get better test-time results from a model just by training it for much, much longer.</p>
<p>In 2019, folks at OpenAI and Harvard <a href="https://arxiv.org/pdf/1912.02292">wrote a paper</a> that tries to formalize this effect and also goes into how model size can impact results, i.e. <em>model-wise</em> double descent where bigger models are eventually better.</p>
<p>The phrasing <em>double descent</em> refers to this behavior where error gets better at first, then peaks much worse, then eventually comes back down again.</p>
<p><img src="https://bear-images.sfo2.cdn.digitaloceanspaces.com/stpn/56pm.webp" alt="Deep Double Descent from the OpenAI paper"/></p>
<p>Models are trained on a training set and then evaluated against a separate test set. When a model is really good at the training set but really bad at the test set, we say it <em>generalized</em> poorly. Imagine: the model memorized the multiple-choice answers on the homework but it doesn&#39;t help with taking the final exam. It&#39;s not super clear why this happens, but here&#39;s the rough intuition I came away from.</p>
<p>With smaller models, the model can do its best to approximate the right behavior for test time but just doesn&#39;t have enough &#34;brain cells&#34; (parameters) to fit the whole problem in its head. To a certain point, giving small models more brain cells leads to better performance. This region is called <em>underparameterized</em>.</p>
<p>At around the model size where the model is just barely large enough to match the problem (called the <em>interpolation threshold</em>), the model can memorize &#34;the&#34; solution that lets it ace the training set, but that makes it prone to doing really poorly on the test set.</p>
<p>And finally, at larger model sizes, the model has plenty of brain cells (<em>overparameterization</em>) and can fit enough underlying features to classify well without overfitting to just the training set. This causes the second descent where the model converges to low error again.</p>
<p>There&#39;s also a factor here of how well the model can inherently learn the data. The paper discusses that introducing noise (purposefully adding incorrect labels) can be a proxy for this effect to highlight double descent.</p>
<p>To be honest, I&#39;m not sure how much I trust my intuition so far about why double descent happens. It feels like if I squint at this formulation it kind of makes sense to me.</p>
<p>I set out to repro a narrow portion of the paper: just the parts where they trained and compared varying size <a href="https://arxiv.org/abs/1512.03385">resnet18s</a> from circa 2015.</p>
<p>To challenge myself, I wanted to start with a blank <code>.py</code> file and not look at existing repro work (though, as we&#39;ll see later this did not work out well for me). The final code is <a href="https://github.com/stephen/2025-05-29-resnet18-double-descent">here on github</a>.</p>
<p>The paper has quite a bit of detail for the experimental setup. Some helpful excerpts:</p>
<blockquote>
<p>We follow the Preactivation ResNet18 architecture of He et al. (2016), using <strong>4 ResNet blocks</strong>, each consisting of <strong>two BatchNorm-ReLU-Convolution layers</strong>. The layer widths for the 4 blocks are [k,2k,4k,8k] for varying k and the strides are [1, 2, 2, 2].</p>
</blockquote>
<p>Their experiment ran models from size 1 to 64. I ended up deciding to cut down to &#34;only&#34; 7 sizes (k=1, 2, 4, 8, 16, 32, 64) to save on training time.</p>
<blockquote>
<p>For ResNets and CNNs, we train with cross-entropy loss, and the following optimizers: (1) <strong>Adam with learning-rate 0.0001 for 4K epochs</strong></p>
</blockquote>
<p>Adam is a modern gradient descent variant that works betterâ„¢ and we run it for 4,000 iterations. For reference, the original resnet paper trained the model on ~100 epochs, so we&#39;re going for 40x longer.</p>
<blockquote>
<p>[...] we apply <strong><code>RandomCrop(32, padding=4)</code> and <code>RandomHorizontalFlip</code></strong>. In experiments with added label noise, the label for all augmentations of a given training sample are given the same label.</p>
</blockquote>
<p>We introduce some variation during training as a common trick to improve performance.</p>
<blockquote>
<p>Batch size: All experiments use a <strong>batchsize of 128</strong>.</p>
</blockquote>
<p>One of the figures also shows that they trained the models with 0%, 5%, 10%, 15%, and 20% label noise (purposefully mislabeling some items). I opted for doing just 0%, 10% and 20% in the interest of cost savings.</p>
<h2 id="configuring-the-model">configuring the model</h2><p>At first, I tried to use the off-the-shelf <code>resnet18</code> available in the <code>torchvision</code> package but I quickly ran into issues. The biggest problem was that the paper wants us to vary model size using the <code>k</code> parameter for the convolution widths. <code>resnet18</code> has a <code>width_per_group</code> setting that seems to correspond, but unfortunately...</p>
<div><pre><span></span><span>if</span> <span>groups</span> <span>!=</span> <span>1</span> <span>or</span> <span>base_width</span> <span>!=</span> <span>64</span><span>:</span>
    <span>raise</span> <span>ValueError</span><span>(</span><span>&#34;BasicBlock only supports groups=1 and base_width=64&#34;</span><span>)</span>
</pre></div>
<p>It&#39;s not supported! Digging into code, the <code>width_per_group</code> was meant for &#34;bottleneck&#34; variants of resnet18, which we&#39;re not using. The resnet class hardcodes the model width for each layer so we&#39;ll either have to subclass and dig around or fork the code.</p>
<h2 id="complications">complications</h2><p>The original resnet18 was designed to run on <a href="https://en.wikipedia.org/wiki/ImageNet">ImageNet</a>, a large corpus of 224x224 images with 20k categories. We&#39;re going to run it the much smaller <a href="https://www.cs.toronto.edu/~kriz/cifar.html">CIFAR-10</a> data set that only has 10 categories and 32x32 sized images. This meant I had to modify the model a little to replace the final output layer to give one of 10 results, not 20k.</p>
<p>I figured I could monkeypatch the model (<code>model.fc = t.nn.Linear(...)</code>), but at this point I also realized that the paper uses an old variation of resnets where the order of the convolution, activation and batch norm is different from the way pytorch implements it. I figured I&#39;d fork the code to make things easier.</p>
<p>Stripping away some extra parameters I didn&#39;t need, I ended up with a tidy <a href="https://github.com/stephen/2025-05-29-resnet18-double-descent/blob/main/resnet18.py">~100 line model</a>.</p>
<h2 id="training-a-run-on-my-macbook">training a run on my macbook</h2><p>While developing the model, my macbook was fast enough to handle test runs of the model at around 10s per epoch. However, the paper calls for 4,000 epochs across 64 model sizes and 5 noise configurations. 10s x 4,000 x 64 x 5=768,000 seconds, or nearly 5 months of training. Yikes.</p>
<p>As mentioned earlier, I cut this down to 3 noise configs and only 7 model sizes, cutting the time estimate to 10 days. 10 days is kind of a viable time to wait for results, but it would have meant keeping my macbook stationary and blasted the whole time. I ended up <a href="https://stpn.bearblog.dev/notes-on-renting-a-gpu/">renting GPU time instead</a> to cut the training run down to ~20 hours.</p>
<h2 id="debugging-hell">debugging hell</h2><p>At this point, I was two days in, feeling pretty good about myself for having a working model and making good time. I didn&#39;t know that it would end up taking me 3 days of-on-and off debugging to figure out a few pieces I was missing:</p>
<ul>
<li><p>I was <a href="https://github.com/stephen/2025-05-29-resnet18-double-descent/commit/156880682dbffc17317952bd7e974d1f089bf119">calculating label noise but not applying it correctly</a>, which took me longer than I&#39;d like to admit to realize.</p>
</li>
<li><p>I didn&#39;t think about the fact that resnet18 is designed for 224x224 ImageNet-sized images, so it does an aggressive downsampling as a first step. Unfortunately, this really kills the model&#39;s ability to see what&#39;s going on for the much smaller 32x32 CIFAR images. It&#39;s not mentioned in the paper, but I finally gave in and looked at the <a href="https://gitlab.com/harvard-machine-learning/double-descent/-/blob/master/models/resnet18k.py">reference implementation</a> and realized I needed to <a href="https://github.com/stephen/2025-05-29-resnet18-double-descent/commit/84c9fb6930c4e6e40986e6eac4fdd4c1dc5e25ab">adjust the model</a>.</p>
</li>
<li><p>And finally, I did not realize that the paper is using the words <em>test error</em> to refer to <em>accuracy</em> (% incorrect), not <em>loss</em> (cross-entropy loss). This had me going crazy because for the life of me I could not get my test loss to converge to a reasonable number. After a few hours of re-reading the paper and my code, I finally noticed that all of their graphs for error are bound to [0, 1] and also that some other graphs are specifically labeled &#34;loss&#34; instead. I couldn&#39;t find a definitive source, but I&#39;m pretty sure that means we&#39;re actually talking about % accuracy. I am still vaguely annoyed by this oversight.</p>
</li>
</ul>
<h2 id="the-results">the results</h2><p>After several training re-runs, the final results came out well! I didn&#39;t draw out the same model size x epoch chart that the paper had, but both double descents are legible.</p>
<p>No label noise:
<img src="https://bear-images.sfo2.cdn.digitaloceanspaces.com/stpn/20pm.webp" alt="Test error by epoch across model sizes with 0% noise"/></p>
<p>10% label noise:
<img src="https://bear-images.sfo2.cdn.digitaloceanspaces.com/stpn/03pm.webp" alt="Test error by epoch across model sizes with 10% noise"/></p>
<p>20% label noise:
<img src="https://bear-images.sfo2.cdn.digitaloceanspaces.com/stpn/39pm.webp" alt="Test error by epoch across model sizes with 20% noise"/></p>
<h2 id="some-observations">some observations</h2><p>With no label noise, there is no double descent. This matches the paper&#39;s findings as well. My interpretation is that the model has relatively low noise and there&#39;s more leeway for the model to learn good features, i.e. since there are only 10 output categories and 32x32 size images.</p>
<p>At 10% and 20% label noise, we see both model-wise and epoch-wise double descent!</p>
<p>Visually scanning up/down the 10% noise graph at the later epochs, we see that with model-size the performance from worst to best is k=1, 2, 8, 16, 4, 32, then k=64. The larger k=8 and k=16 models perform worse than the smaller k=4! The middle-sized models are too busy memorizing the test set to learn the material.</p>
<p>On the same 10% graph, scanning left/right, the larger models starting with k=16 also present with double descent. Right around the 100-300 epoch mark, we see the bigger models get worse error but eventually recover and even exceed their minimum error from the underparameterized region.</p>
<p>When we look at the 20% graph, the effects are even more pronounced. The k=8 model can&#39;t even outperform the k=2 model. It&#39;s also interesting to see that the larger models never end up achieving better error than their original minima during underparameterization. My guess here is that adding too  much noise makes the model unable to learn well enough, but maybe we&#39;d see it converge lower if we gave it more epochs to run with?</p>
<h2 id="takeaways">takeaways</h2><p>It was pretty exciting to see that I could actually repro the paper results! I did end up having to take a peek at the reference implementation near the end, but I&#39;m pretty proud of myself for learning enough to go from scratch to a working model and training loop.</p>
<hr/>
<p>discuss this on the <a href="https://news.ycombinator.com/item?id=44194431">hacker news</a>?</p>


    

    
        

        
            


        
    


  </div></div>
  </body>
</html>
