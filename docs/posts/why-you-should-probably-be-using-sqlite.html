<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.epicweb.dev/why-you-should-probably-be-using-sqlite">Original</a>
    <h1>Why you should probably be using SQLite</h1>
    
    <div id="readability-page-1" class="page"><div><p>Where you store your application data has enormous impacts on your entire application. There are implications on the entire stack based on what you decide to use here.</p>
<p>There are terrific solutions like MySQL and Postgres that have become the default for many people. These are fine solutions. But for most web app use cases, you could drastically simplify your life by using SQLite.</p>
<p>SQLite is a sql-based database with a particularly unique feature: the entire database is in a single file. Largely for this reason, many people have historically seen it as a simple database for simple use cases.</p>
<p>However, in recent years SQLite has received a great deal of development and attention making it a simple database for even more advanced use cases. Let’s talk about some of those advancements and why for most of us, SQLite is the best balance of trade-offs.</p>
<h2 id="zero-latency">Zero Latency</h2>
<p>The fact that SQLite is a single file on disk comes with a major benefit of 0 latency which <a href="https://www.sqlite.org/np1queryprob.html">drastically reduces the &#34;n+1 problem.&#34;</a> This means that as a developer you don’t have to spend so much time worrying about reducing the number of queries you’re making to the database (which can lead to less efficient queries and certainly less efficient developers).</p>
<p>And latency itself is not to be underestimated. If you’re not thoughtful about the distance between your database and your application, you can easily put a baseline on your application’s performance. It’s not uncommon for the app-to-database latency to be measured in the tens of milliseconds (and sometimes even hundreds). This means no matter what you do, your page can’t load with fresh data in less than that amount of time.</p>
<p>I know performance isn’t the number 1 priority of all apps, but it’s pretty important for most. I’m  pretty sure even though the business executive who paid for your app and doesn’t have alternatives doesn’t like loading spinners flashing in their face for every interaction. 🌀😠</p>
<h2 id="one-less-service">One Less Service</h2>
<p>One huge benefit to SQLite is the fact that it runs as an embedded part of your application. So that’s one less service to babysit. Honestly, that was my primary motivation when I decided to migrate my own website from Postgres to SQLite. I just stick SQLite in the same volume I’m mounting for other data for my application already and I’m off the races.</p>
<p>This saves on complexity as well as cost.</p>
<p>And this is multiplied by the number of instances and replication considerations, but we’re getting ahead of ourselves… Let’s get into that…</p>
<h2 id="multi-instance-replication">Multi-instance replication</h2>
<p>As a file on disk, you cannot &#34;distribute&#34; SQLite directly. However, this is where there have been advancements in this space. For my own applications that need multiple instances, I use <a href="https://fly.io/docs/litefs">LiteFS</a>:</p>
<blockquote>
<p>LiteFS is a distributed file system that transparently replicates SQLite databases. You can run your application like it’s running against a local on-disk SQLite database but behind the scenes the database is replicated to all the nodes in your cluster. With LiteFS, you can run your database right next to your application on the edge. You can run LiteFS anywhere!</p>
</blockquote>
<p>On top of this, LiteFS has built-in support to handle the &#34;Read Replica Consistency&#34; challenge. So if you need your app to run in multiple instances, you need to use one of these tools.</p>
<p>Another solution here is <a href="https://turso.tech/">Turso</a> which uses SQLite under the hood and even has a concept called &#34;embedded replicas&#34; for zero latency reads. Very cool!</p>
<h2 id="database-size">Database size</h2>
<p>Another issue people sometimes bring up is database size. However, <a href="https://sqlite.org/hctree/doc/hctree/doc/hctree/index.html">SQLite is capable of handling databases that are an Exabyte in size</a> (that&#39;s one million Terabytes, or one billion Gigabytes 🤯). Most of us web developers don’t work with near that amount of data. You’ll have much different problems before database size is one of them with SQLite.</p>
<p>Even putting large amounts of data in a SQLite database record is pretty efficient! In fact, in some cases, <a href="https://www.sqlite.org/fasterthanfs.html">it can be faster</a> to retrieve data out of a SQLite database than from the file system 😆 SQLite is an incredible feat of engineering!</p>
<h2 id="development-and-testing">Development and Testing</h2>
<p>I know some of you reading this right now are perfectly comfortable running <code>docker compose</code> as a regular part of your workflow before you start developing your application. But you have to admit that it’s annoying to run multiple apps at once with conflicting databases and ports. With SQLite, it’s a total non-issue. It’s just a file. So you can run multiple instances of the same app at once with no trouble whatsoever.</p>
<p>Also, while starting up a new Postgres database is fairly involved (there are of course tools that make it easier), SQLite has no such issue. Again, it’s just a file. Run your production migrations/seed and you’re good to go.</p>
<p>And this ease carries over to the testing side of things as well. When your database setup is complicated, you end up spending time evaluating ways to mock out your database at the ORM level so you can avoid having to run and connect to your database during testing and the isolation issues that can happen as a result of that.</p>
<p>Not a problem with SQLite. It’s just a file! Each test can have its own database with barely a thought. Just a little bit of code to create and connect the database and then your tests can run on the full database. You can definitely do this with other databases, but not as easily and efficiently as SQLite.</p>
<h2 id="weaknesses">Weaknesses</h2>
<p>SQLite is not without its shortcomings. And it would be unfair of me to just talk about where SQLite shines without addressing some of those.</p>
<ul>
<li>SQLite does not support subscriptions which can be a limitation on certain real-time use cases. However, there are plenty of reasons to recommend against using database subscriptions for real-time use cases anyway. Scaling real-time use cases is quite challenging, and personally have really enjoyed letting <a href="https://www.partykit.io/">Partykit</a> do that part for me in my apps.</li>
<li>SQLite being a file on disk does make connecting from external clients effectively impossible. But with <a href="http://Fly.io">Fly.io</a> at least, it’s easy to run prisma studio on the production server and proxy that for local access. If you need to connect to it from another app, then you’re out of luck and have to set up HTTP endpoints on the host app for any data you need (<a href="https://github.com/superfly/litefs/issues/326">for now</a>).</li>
<li>SQLite does not support plugins like <a href="https://github.com/timescale/timescaledb">TimescaleDB</a> for Postgres. While time-series data is possible with SQLite, I do not have experience with this use case and can&#39;t speak to the challenges there. My intuition says it&#39;s not advisable to use SQLite for that use case, but maybe someone else can offer me more insight.</li>
<li>SQLite does not support enums which means you&#39;re forced to use strings. I have mixed feelings about this, but I mostly don&#39;t like enums anyway. The main drawback to this is when it comes to the typings for the client which doesn&#39;t allow you to ensure all values of a column are only within a set of specific possible values for the string. However, with Prisma client extensions, handling this kind of enforcement at the client (and typing) level <a href="https://github.com/L-Steinmacher/epic-stack-with-prisma-client-extensions">is possible</a>.</li>
</ul>
<h2 id="conclusion">Conclusion</h2>
<p>So, can <em>you</em> use SQLite? For the vast majority of you reading this, the answer is “yes.” Should you use SQLite? I’d say that still for the majority of you reading this, the answer is also “yes.” Though it’s complicated. As with everything in technology, there are multiple solutions that will work out. But I think you should give SQLite a serious look due to the performance, simplification, and cost benefits I’ve mentioned.</p>
<p>And that’s why I’m using SQLite for my own applications and why I teach you to use SQLite in the <a href="http://EpicWeb.dev">EpicWeb.dev</a> series of workshops.</p>
<p>– Kent</p></div><section id="article"><div><p>Stay up to date</p><p>Subscribe to the newsletter to stay up to date with articles, courses and much more!</p></div><p>I respect your privacy. Unsubscribe at any time.</p></section></div>
  </body>
</html>
