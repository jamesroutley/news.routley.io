<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.jacobvosmaer.nl/0018-0018-midi-parser/">Original</a>
    <h1>A small MIDI parser</h1>
    
    <div id="readability-page-1" class="page"><div><p><i><a href="https://blog.jacobvosmaer.nl/">Jacob Vosmaer&#39;s blog</a></i></p>

<p>2024-01-12</p>

<p>In this post I will talk through the code of a pet project of mine, a small <a href="https://gitlab.com/jacobvosmaer/midiparser">MIDI parser library written in C</a>.</p>

<h2>MIDI</h2>

<p><a href="https://en.wikipedia.org/wiki/MIDI">MIDI</a> stands for &#34;Musical Instrument Digital Interface&#34;. It is a standard from 1983 that describes both an electrical interface between musical instruments and the digital protocol used t ocommunicate over that interface.</p>

<p>The electrical part is a <a href="https://en.wikipedia.org/wiki/Universal_asynchronous_receiver-transmitter">UART</a> current loop through an <a href="https://en.wikipedia.org/wiki/Opto-isolator">opto-isolator</a> on the receiving end. The opto-isolator provides <a href="https://en.wikipedia.org/wiki/Galvanic_isolation">galvanic isolation</a> which prevents <a href="https://en.wikipedia.org/wiki/Ground_loop_(electricity)">ground loops</a>.</p>

<p>The digital protocol consists of variable length messages of 1 up to 3 bit bytes. The first byte is the &#34;status&#34; which indicates the type of the message. The optional second and third bytes are the &#34;data&#34; bytes.</p>

<h2>Why write a MIDI parser</h2>

<p>My first embedded programming project was to rewrite the code of the <a href="https://blog.jacobvosmaer.nl/0014-yocto/">Yocto</a> that translates MIDI messages into drum triggers. Because it seemed like fun at the time I decided to write my own MIDI parser in C.</p>

<p>I don&#39;t have a formal education in computer science so this was probably one of the first times I wrote a parser. It also is one of the earliest things I wrote in C.</p>

<p>Over time this parser has proven to be a fun piece of code to come back to and refactor. Below I will talk you through the current version.</p>

<h2>The header file</h2>

<p>The header contains three definitions.</p>

<pre><code>
typedef struct midi_message {
    uint8_t status;
    uint8_t data[2];
} midi_message;
</code></pre>

<p>The parser emits <code>midi_message</code> structs. A MIDI message consists of 1 &#34;status&#34; byte (which has its highest bit set to 1) followed by 0, 1 or 2 &#34;data&#34; bytes (with their highest bit set to 0). </p>

<pre><code>
typedef struct midi_parser {
    uint8_t status;
    uint8_t previous;
} midi_parser;
</code></pre>

<p>The <code>midi_parser</code> struct contains the internal state of the parser. Because MIDI messages are spread over multiple bytes, and the bytes come in one at a time, the parser must &#34;remember&#34; what it has seen before. It needs 2 bytes of memory for this. </p>

<p>Users of the library do not need to know the internals of <code>midi_parser</code> but we will look at it in detail below.</p>

<pre><code>
midi_message midi_read(midi_parser *p, uint8_t b);
</code></pre>

<p>The final piece of the interface is the <code>midi_read()</code> function which consumes a byte <code>b</code> of the incoming MIDI stream, updates the start of parser <code>p</code>, and returns a <code>midi_message</code> struct. Not every call to <code>midi_read()</code> yields a message. If there is no message, the <code>.status</code> field of the returned struct is 0.</p>

<h2>Example code</h2>

<p>This is straight from the README.</p>

<pre><code>
int main(void) {
  int c;
  midi_parser parser = {0};

  puts(&#34;status data0 data1&#34;);
  while ((c = getchar()) != EOF) {
    midi_message msg = midi_read(&amp;parser, c);
    if (msg.status)
      printf(&#34;  0x%02x  0x%02x  0x%02x\n&#34;, msg.status,
        msg.data[0], msg.data[1]);
  }
}
</code></pre>

<p>Output:</p>

<pre><code>
$ printf &#39;\x90\x11\x22\x33\x44&#39; | ./example
status data0 data1
  0x90  0x11  0x22
  0x90  0x33  0x44
</code></pre>

<p>Note how the example feeds 5 bytes into the parser but the parser only returns 2 messages. Part of the time, the return <code>msg</code> has its <code>.status</code> set to zero.</p>

<h2>The implementation</h2>

<p>Here is the entire implementation.</p>

<pre><code>
midi_message midi_read(midi_parser *p, uint8_t b) {
    enum { DATA0_PRESENT = 0x80 };
    midi_message msg = {0};

    if (b &gt;= 0xf8) {
        msg.status = b;
    } else if (b &gt;= 0xf4) {
        msg.status = b;
        p-&gt;status = 0;
    } else if (b &gt;= 0x80) {
        p-&gt;status = b;
        p-&gt;previous = b == 0xf0 ? b : 0;
    } else if ((p-&gt;status &gt;= 0xc0 &amp;&amp; p-&gt;status &lt; 0xe0) ||
           (p-&gt;status &gt;= 0xf0 &amp;&amp; p-&gt;status != 0xf2)) {
        msg.status = p-&gt;status;
        msg.data[0] = b;
        msg.data[1] = p-&gt;previous;
        p-&gt;previous = 0;
    } else if (p-&gt;status &amp;&amp; p-&gt;previous &amp; DATA0_PRESENT) {
        msg.status = p-&gt;status;
        msg.data[0] = p-&gt;previous ^ DATA0_PRESENT;
        msg.data[1] = b;
        p-&gt;previous = 0;
    } else {
        p-&gt;previous = b | DATA0_PRESENT;
    }

    return msg;
}
</code></pre>

<p>I will talk through it step by step below.</p>

<pre><code>
    if (b &gt;= 0xf8) {
        msg.status = b;
</code></pre>

<p>Some MIDI messages have &#34;real time&#34; priority and no data bytes. These get returned immediately by the parser. One example is 0xf8 which is a MIDI clock tick. These real time messages do not change the state of the parser.</p>

<pre><code>
    } else if (b &gt;= 0xf4) {
        msg.status = b;
        p-&gt;status = 0;
</code></pre>

<p>Next we have some messages again without data but which do reset the parser. An example is 0xf7 which is &#34;end of system exclusive data&#34;. These messages get emitted immediately.</p>

<pre><code>
    } else if (b &gt;= 0x80) {
        p-&gt;status = b;
        p-&gt;previous = b == 0xf0 ? b : 0;
</code></pre>

<p>Next we come to the class of messages which have 1 or 2 data bytes. For these, we must remember the status byte and we cannot yet emit a message, so <code>msg.status</code> remains unset.</p>

<p>There is a special case for status 0xf0 which is the start of a system exclusive message. System exclusive messages are a stream of arbitrarily many 7-bit values, starting with 0xf0 and ending with 0xf7. For the API of <code>midi_read()</code> I chose to return these as follows.</p>

<p>Suppose we have a system exclusive (&#34;sysex&#34;) message <code>0xf0 0x01 0x02 0x03 0xf7</code>. When you feed this to the parser it will return 4 message structs: <code>{0xf0, 0x01, 0xf0}</code>, <code>{0xf0, 0x02, 0x00}</code>, <code>{0xf0, 0x03, 0x00}</code> and <code>{0xf7, 0x00, 0x00}</code>. The first message has 0xf0 as its second data byte. This is to signal the start of a sysex stream.</p>

<p>To implement this special behavior for <code>0xf0</code>, we store a value in <code>p-&gt;previous</code> above.</p>

<pre><code>
    } else if ((p-&gt;status &gt;= 0xc0 &amp;&amp; p-&gt;status &lt; 0xe0) ||
           (p-&gt;status &gt;= 0xf0 &amp;&amp; p-&gt;status != 0xf2)) {
        msg.status = p-&gt;status;
        msg.data[0] = b;
        msg.data[1] = p-&gt;previous;
        p-&gt;previous = 0;
</code></pre>

<p>When we reach this branch, the parser <code>p-&gt;status</code> field is set, the message type has 1 data byte, and the data byte just came in in <code>b</code>. We know that <code>b</code> is not a status byte because it is less than 0x80. In this case we emit a message. Note how we set <code>p-&gt;previous</code> to 0 so that in the special status 0xf0 case, only the first message has 0xf0 as its second data byte.</p>

<pre><code>
    } else if (p-&gt;status &amp;&amp; p-&gt;previous &amp; DATA0_PRESENT) {
        msg.status = p-&gt;status;
        msg.data[0] = p-&gt;previous ^ DATA0_PRESENT;
        msg.data[1] = b;
        p-&gt;previous = 0;
</code></pre>

<p>In this branch, the parser has a <code>p-&gt;status</code> value which carries 2 data bytes, and <code>b</code> holds the second data byte. We can tell it is the second one because the <code>DATA0_PRESENT</code> flag was set when the first data byte came in. In this case we emit a message and reset <code>p-&gt;previous</code>.</p>

<pre><code>
    } else {
        p-&gt;previous = b | DATA0_PRESENT;
    }
</code></pre>

<p>In this final branch, we know that <code>p-&gt;status</code> indicates we need 2 data bytes, and <code>b</code> holds the first data byte. In case <code>b</code> is zero, we would not be able to detect that <code>b</code> is set during the next call to <code>midi_read()</code>. The <code>DATA0_PRESENT</code> flag avoids this problem by making sure <code>p-&gt;previous</code> is not zero.</p>

<h2>Why no callbacks</h2>

<p>Many examples of MIDI parsers I see use callbacks. This is indeed a natural solution for dealing with the problem that when you feed a byte to the parser, sometimes you get a message, and sometimes you do not.</p>

<p>However, I feel that a callback API would have been bigger, and clunky in the case when you don&#39;t need it. Callbacks in C are clunky because you have to define them as top-level functions. It is not hard to embed this library in a program that does use callbacks but now you have the choice not to use callbacks.</p>

<h2>Conclusion</h2>

<p>Thank you for reading this far. This was all very nerdy.</p>

<p>To my knowledge this parser is correct. Let me know if you think differently. The <a href="https://gitlab.com/jacobvosmaer/midiparser">library</a> is MIT licensed in the hope that others can benefit from using it.</p>
<p>Tags:
<a href="https://blog.jacobvosmaer.nl/music.html">music</a>
</p><details><summary>Edit history</summary><table>
<tbody><tr><td>2024-01-12</td><td></td><td>Add 0018 midi parser</td></tr>
</tbody></table></details><p><a href="https://blog.jacobvosmaer.nl/">Back</a></p>
</div></div>
  </body>
</html>
