<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://2ality.com/2025/01/typescript-enum-patterns.html">Original</a>
    <h1>TypeScript enums: use cases and alternatives</h1>
    
    <div id="readability-page-1" class="page"><div><p>In this blog post, we take a closer look at TypeScript enums:</p>
<ul>
<li>How do they work?</li>
<li>What are their use cases?</li>
<li>What are the alternatives if we don’t want to use them?</li>
</ul>
<p>The blog post concludes with recommendations for what to use when.</p>
<!--more-->
<nav>
<ul>
  <li>
    <a href="#notation">Notation</a>
  </li>
  <li>
    <a href="#the-basics-of-typescript-enums">The basics of TypeScript enums</a>
    <ul>
      <li>
        <a href="#an-enum-defines-an-object">An enum defines an object</a>
      </li>
      <li>
        <a href="#an-enum-defines-a-type">An enum defines a type</a>
      </li>
      <li>
        <a href="#we-can-check-exhaustiveness-for-enums">We can check exhaustiveness for enums</a>
      </li>
      <li>
        <a href="#enumerating-members">Enumerating members</a>
      </li>
      <li>
        <a href="#enums-without-explicitly-specified-values">Enums without explicitly specified values</a>
      </li>
    </ul>
  </li>
  <li>
    <a href="#use-cases-for-enums">Use cases for enums</a>
  </li>
  <li>
    <a href="#use-case%3A-namespace-for-constants-with-primitive-values">Use case: namespace for constants with primitive values</a>
    <ul>
      <li>
        <a href="#enum-as-namespace-for-constants-with-primitive-values">Enum as namespace for constants with primitive values</a>
      </li>
      <li>
        <a href="#alternative-to-enum%3A-object-literal">Alternative to enum: object literal</a>
      </li>
    </ul>
  </li>
  <li>
    <a href="#use-case%3A-custom-type-with-unique-values">Use case: custom type with unique values</a>
    <ul>
      <li>
        <a href="#enum-as-custom-type-with-unique-values">Enum as custom type with unique values</a>
      </li>
      <li>
        <a href="#alternative-to-enum%3A-object-literal-1">Alternative to enum: object literal</a>
      </li>
      <li>
        <a href="#alternative-to-enum%3A-union-of-string-literal-types">Alternative to enum: union of string literal types</a>
      </li>
    </ul>
  </li>
  <li>
    <a href="#use-case%3A-namespace-for-constants-with-object-values">Use case: namespace for constants with object values</a>
    <ul>
      <li>
        <a href="#object-literal-whose-property-values-are-objects">Object literal whose property values are objects</a>
      </li>
      <li>
        <a href="#enum-class">Enum class</a>
      </li>
    </ul>
  </li>
  <li>
    <a href="#mapping-to-and-from-an-enum">Mapping to and from an enum</a>
  </li>
  <li>
    <a href="#recommendations">Recommendations</a>
  </li>
</ul>
</nav>
<h2 id="notation" tabindex="-1">Notation  <a href="#notation" aria-hidden="true">#</a></h2>
<p>For showing inferred types in the source code, I use the npm package <a href="https://github.com/TypeStrong/ts-expect"><code>ts-expect</code></a> – e.g.:</p>
<pre><code>
expectType&lt;<span>string</span>&gt;(<span>&#39;abc&#39;</span>);
expectType&lt;<span>number</span>&gt;(<span>123</span>);


<span>type</span> <span>Pair</span>&lt;T&gt; = [T, T];
expectType&lt;<span>TypeEqual</span>&lt;<span>Pair</span>&lt;<span>string</span>&gt;, [<span>string</span>,<span>string</span>]&gt;&gt;(<span>true</span>);
</code></pre>
<h2 id="the-basics-of-typescript-enums" tabindex="-1">The basics of TypeScript enums  <a href="#the-basics-of-typescript-enums" aria-hidden="true">#</a></h2>
<p>There are many different kinds of <em>enums</em> in various programming languages. In TypeScript, an enum defines two things:</p>
<ul>
<li>an object that maps member keys to member values</li>
<li>a type that only contains the member values</li>
</ul>
<p>Note that we are ignoring <a href="https://exploringjs.com/tackling-ts/ch_enums.html#const-enums">const enums</a> in this blog post.</p>
<p>Next, we’ll look at various aspects of enums in more detail.</p>
<h3 id="an-enum-defines-an-object" tabindex="-1">An enum defines an object  <a href="#an-enum-defines-an-object" aria-hidden="true">#</a></h3>
<p>On one hand, an enum is an object that maps member keys to member values. In that way, it works much like an object literal:</p>
<pre><code><span>enum</span> <span>Color</span> {
  <span>Red</span> = <span>0</span>,
  <span>Green</span> = <span>&#39;GREEN&#39;</span>,
}
assert.<span>equal</span>(<span>Color</span>.<span>Red</span>, <span>0</span>);
assert.<span>equal</span>(<span>Color</span>.<span>Green</span>, <span>&#39;GREEN&#39;</span>);
assert.<span>equal</span>(<span>Color</span>[<span>&#39;Green&#39;</span>], <span>&#39;GREEN&#39;</span>);
</code></pre>
<p>One limitation is that only numbers and strings are allowed as member values.</p>
<h3 id="an-enum-defines-a-type" tabindex="-1">An enum defines a type  <a href="#an-enum-defines-a-type" aria-hidden="true">#</a></h3>
<p>On the other hand, an enum is also a type that only contains the member values:</p>
<pre><code><span>let</span> <span>color</span>: <span>Color</span>;
color = <span>Color</span>.<span>Red</span>;
color = <span>Color</span>.<span>Green</span>;

color = <span>true</span>;
</code></pre>
<p>There is one important difference between string members and number members: We cannot assign plain strings to <code>color</code>:</p>
<pre><code>

color = <span>&#39;GREEN&#39;</span>;
</code></pre>
<p>But we can assign a plain number to <code>color</code> – if it is the value of a member:</p>
<pre><code>color = <span>0</span>;

color = <span>123</span>;
</code></pre>
<h3 id="we-can-check-exhaustiveness-for-enums" tabindex="-1">We can check exhaustiveness for enums  <a href="#we-can-check-exhaustiveness-for-enums" aria-hidden="true">#</a></h3>
<p>Consider the following enum:</p>
<pre><code><span>enum</span> <span>Color</span> {
  <span>Red</span> = <span>0</span>,
  <span>Green</span> = <span>&#39;GREEN&#39;</span>,
}
</code></pre>
<p>If we handle the values that a variable of type <code>Color</code> may have, then TypeScript can warn us if we forget one of them. In other words: If we didn’t handle all cases “exhaustively”. That is called an <em>exhaustiveness check</em>. To see how that works, let’s start with the following code:</p>
<pre><code>
<span>function</span> <span>colorToString</span>(<span>color: Color</span>) {
  expectType&lt;<span>Color</span>&gt;(color); 
  <span>if</span> (color === <span>Color</span>.<span>Red</span>) {
    <span>return</span> <span>&#39;red&#39;</span>;
  }
  expectType&lt;<span>Color</span>.<span>Green</span>&gt;(color); 
  <span>if</span> (color === <span>Color</span>.<span>Green</span>) {
    <span>return</span> <span>&#39;green&#39;</span>;
  }
  expectType&lt;<span>never</span>&gt;(color); 
}
</code></pre>
<p>In line A, <code>color</code> can still have any value. In line B, we have crossed off <code>Color.Red</code> and <code>color</code> can only have the value <code>Color.Green</code>. In line C, <code>color</code> can’t have any value – which explains its type <code>never</code>.</p>
<p>If <code>color</code> is <em>not</em> <code>never</code> in line C then we have forgotten a member. We can let TypeScript report an error at compile time like this:</p>
<pre><code><span>function</span> <span>colorToString</span>(<span>color: Color</span>) {
  <span>if</span> (color === <span>Color</span>.<span>Red</span>) {
    <span>return</span> <span>&#39;red&#39;</span>;
  }
  <span>if</span> (color === <span>Color</span>.<span>Green</span>) {
    <span>return</span> <span>&#39;green&#39;</span>;
  }
  <span>throw</span> <span>new</span> <span>UnsupportedValueError</span>(color);
}
</code></pre>
<p>How does that work? The <code>value</code> we pass to <code>UnsupportedValueError</code> must have the type <code>never</code>:</p>
<pre><code><span>class</span> <span>UnsupportedValueError</span> <span>extends</span> <span>Error</span> {
  <span>constructor</span>(<span>value: <span>never</span>, message = <span>`Unsupported value: <span>${value}</span>`</span></span>) {
    <span>super</span>(message)
  }
}
</code></pre>
<p>This is what happens if we forget the second case:</p>
<pre><code><span>function</span> <span>colorToString</span>(<span>color: Color</span>) {
  <span>if</span> (color === <span>Color</span>.<span>Red</span>) {
    <span>return</span> <span>&#39;red&#39;</span>;
  }
  
  
  <span>throw</span> <span>new</span> <span>UnsupportedValueError</span>(color);
}
</code></pre>
<p>Exhaustiveness checking works just as well with <code>case</code> statements:</p>
<pre><code><span>function</span> <span>colorToString</span>(<span>color: Color</span>) {
  <span>switch</span> (color) {
    <span>case</span> <span>Color</span>.<span>Red</span>:
      <span>return</span> <span>&#39;red&#39;</span>;
    <span>case</span> <span>Color</span>.<span>Green</span>:
      <span>return</span> <span>&#39;green&#39;</span>;
    <span>default</span>:
      <span>throw</span> <span>new</span> <span>UnsupportedValueError</span>(color);
  }
}
</code></pre>
<p>Another way to check exhaustiveness is by specifying a return type for the function:</p>
<pre><code>

<span>function</span> <span>colorToString</span>(<span>color: Color</span>): <span>string</span> {
  <span>switch</span> (color) {
    <span>case</span> <span>Color</span>.<span>Red</span>:
      <span>return</span> <span>&#39;red&#39;</span>;
  }
}
</code></pre>
<p>In my code, I usually do that but additionally throw an <code>UnsupportedValueError</code> because I like having a check that also works at runtime.</p>
<h3 id="enumerating-members" tabindex="-1">Enumerating members  <a href="#enumerating-members" aria-hidden="true">#</a></h3>
<p>One operation that is occasionally useful is enumerating the members of an enum. Can we do that with TypeScript enums? Let’s use our previous enum:</p>
<pre><code><span>enum</span> <span>Color</span> {
  <span>Red</span> = <span>0</span>,
  <span>Green</span> = <span>&#39;GREEN&#39;</span>,
}
</code></pre>
<p>Compiled to JavaScript, <code>Color</code> looks like this:</p>
<pre><code><span>var</span> <span>Color</span>;
(<span>function</span> (<span>Color</span>) {
    <span>Color</span>[<span>Color</span>[<span>&#34;Red&#34;</span>] = <span>0</span>] = <span>&#34;Red&#34;</span>; 
    <span>Color</span>[<span>&#34;Green&#34;</span>] = <span>&#34;GREEN&#34;</span>; 
})(<span>Color</span> || (<span>Color</span> = {}));
</code></pre>
<p>This is a function that is immediately invoked and adds properties to an object <code>Color</code>.</p>
<p>The code for the string member <code>Green</code> in line B is straightforward: It maps from key to value.</p>
<p>The code for the number member <code>Red</code> in line A adds two properties for <code>Red</code> instead of one – a mapping from key to value and a mapping from value to key:</p>
<pre><code><span>Color</span>[<span>&#34;Red&#34;</span>] = <span>0</span>;
<span>Color</span>[<span>0</span>] = <span>&#34;Red&#34;</span>;
</code></pre>
<p>Note that the zero in the second line is coerced to a string (a property key can only be a string or a symbol). Thus, we can’t even really look up a number this way. We have to convert it to a string first.</p>
<p>Therefore, the number member prevents us from enumerating the keys or values of this enum:</p>
<pre><code>assert.<span>deepEqual</span>(
  <span>Object</span>.<span>keys</span>(<span>Color</span>), [<span>&#39;0&#39;</span>, <span>&#39;Red&#39;</span>, <span>&#39;Green&#39;</span>]
);
assert.<span>deepEqual</span>(
  <span>Object</span>.<span>values</span>(<span>Color</span>), [<span>&#39;Red&#39;</span>, <span>0</span>, <span>&#39;GREEN&#39;</span>]
);
</code></pre>
<p>If we switch to only string members then enumeration works:</p>
<pre><code><span>enum</span> <span>Color</span> {
  <span>Red</span> = <span>&#39;RED&#39;</span>,
  <span>Green</span> = <span>&#39;GREEN&#39;</span>,
}

assert.<span>deepEqual</span>(
  <span>Object</span>.<span>keys</span>(<span>Color</span>), [<span>&#39;Red&#39;</span>, <span>&#39;Green&#39;</span>]
);
assert.<span>deepEqual</span>(
  <span>Object</span>.<span>values</span>(<span>Color</span>), [<span>&#39;RED&#39;</span>, <span>&#39;GREEN&#39;</span>]
);
</code></pre>
<h3 id="enums-without-explicitly-specified-values" tabindex="-1">Enums without explicitly specified values  <a href="#enums-without-explicitly-specified-values" aria-hidden="true">#</a></h3>
<p>We can also create enums without explicitly specifying member values. Then TypeScript specifies them for us and uses numbers:</p>
<pre><code><span>enum</span> <span>Color</span> {
  <span>Red</span>, 
  <span>Green</span>, 
}
assert.<span>equal</span>(<span>Color</span>.<span>Red</span>, <span>0</span>);
assert.<span>equal</span>(<span>Color</span>.<span>Green</span>, <span>1</span>);
</code></pre>
<h2 id="use-cases-for-enums" tabindex="-1">Use cases for enums  <a href="#use-cases-for-enums" aria-hidden="true">#</a></h2>
<p>Making sense of enums and enum-related patterns can quickly get confusing because what an enum is varies widely between programming languages – e.g.:</p>
<ul>
<li>Java’s enums are classes with a fixed set of instances.</li>
<li>Rust’s enums are more like algebraic datatypes in functional programming languages. They are loosely related to <a href="https://exploringjs.com/tackling-ts/ch_enum-alternatives.html#discriminated-union">discriminated unions</a> in TypeScript.</li>
</ul>
<p>Therefore, we benefit from a narrow definition of the term <em>enum</em>:</p>
<ul>
<li>A fixed set of values.</li>
<li>That can be accessed via the keys of an object.</li>
</ul>
<p>In the following sections, we’ll go through the following use cases for this kind of enum:</p>
<ol>
<li>Namespace for constants with primitive values</li>
<li>Custom type with unique values</li>
<li>Namespace for constants with object values</li>
</ol>
<p>We’ll consider how well TypeScript enums work for these use cases. (Spoiler: they work reasonably well for #1 and #2 but can’t be used for #3.) And we’ll look at enum-like patterns that we can use instead.</p>
<p>For each option, we’ll also examine:</p>
<ul>
<li>Can exhaustiveness checks be performed?</li>
<li>Can members be enumerated?</li>
</ul>
<h2 id="use-case%3A-namespace-for-constants-with-primitive-values" tabindex="-1">Use case: namespace for constants with primitive values  <a href="#use-case%3A-namespace-for-constants-with-primitive-values" aria-hidden="true">#</a></h2>
<p>One way in which enums (or enum-like objects) are sometimes used is simply as a namespace for constants – e.g., the Node.js function <a href="https://nodejs.org/api/fs.html#fsaccesspath-mode-callback"><code>fs.access()</code></a> has a parameter <code>mode</code> whose values are provided via an object that is similar to the following enum:</p>
<pre><code><span>enum</span> constants {
  <span>F_OK</span> = <span>0</span>,
  <span>R_OK</span> = <span>4</span>,
  <span>W_OK</span> = <span>2</span>,
  <span>X_OK</span> = <span>1</span>,
  
}
</code></pre>
<p>Except for the first value, these are bits that are combined via bitwise Or:</p>
<pre><code><span>const</span> readOrWrite = constants.<span>R_OK</span> | constants.<span>W_OK</span>;
</code></pre>
<h3 id="enum-as-namespace-for-constants-with-primitive-values" tabindex="-1">Enum as namespace for constants with primitive values  <a href="#enum-as-namespace-for-constants-with-primitive-values" aria-hidden="true">#</a></h3>
<p>Which enum features are relevant for this use case?</p>
<ul>
<li>One major limitation of enums is that values can only be number or strings.</li>
<li>The enum as a type doesn’t matter: The type of parameter <code>mode</code> is <code>number</code>, not <code>constants</code> or something similar. That’s because the values of <code>constants</code> are not an exhaustive list of all possible values of <code>mode</code>.</li>
<li>For the same reason, exhaustiveness checks are not relevant in this case.</li>
<li>Enumerating members isn’t desirable either. And it’s not something that we can do with number-valued enums anyway.</li>
</ul>
<h3 id="alternative-to-enum%3A-object-literal" tabindex="-1">Alternative to enum: object literal  <a href="#alternative-to-enum%3A-object-literal" aria-hidden="true">#</a></h3>
<p>For this use case, an object literal is a very good alternative:</p>
<pre><code><span>const</span> constants = {
  <span>__proto__</span>: <span>null</span>,
  <span>F_OK</span>: <span>0</span>,
  <span>R_OK</span>: <span>4</span>,
  <span>W_OK</span>: <span>2</span>,
  <span>X_OK</span>: <span>1</span>,
};
</code></pre>
<p>We use the pseudo property key <code>__proto__</code> to set the prototype of <code>constants</code> to <code>null</code>. That is a good practice because then we don’t have to deal with inherited properties:</p>
<ul>
<li>The main benefit is that we can use the <code>in</code> operator to check if <code>constants</code> has a given key without worrying about properties inherited from <code>Object.prototype</code> such as <code>.toString</code>.</li>
<li>However, <code>Object.keys()</code> and <code>Object.values()</code> ignore inherited properties anyway, so we don’t gain anything there.</li>
</ul>
<p>Note that <code>__proto__</code> also exists as a getter and a setter in <code>Object.prototype</code>. This feature is deprecated in favor of <code>Object.getPrototypeOf()</code> and <code>Object.setPrototypeOf()</code>. However, that is different from using this name in an object literal – which is not deprecated.</p>
<p>For more information, check out these sections of “Exploring JavaScript”:</p>
<ul>
<li><a href="https://exploringjs.com/js/book/ch_objects.html#the-pitfalls-of-using-an-object-as-a-dictionary">“The pitfalls of using an object as a dictionary”</a></li>
<li><a href="https://exploringjs.com/js/book/ch_objects.html#tips-for-working-with-prototypes">“Tips for working with prototypes”</a></li>
<li><a href="https://exploringjs.com/js/book/ch_classes.html#Object.prototype.__proto__">“<code>Object.prototype.__proto__</code> (accessor)”</a></li>
</ul>
<h2 id="use-case%3A-custom-type-with-unique-values" tabindex="-1">Use case: custom type with unique values  <a href="#use-case%3A-custom-type-with-unique-values" aria-hidden="true">#</a></h2>
<p>Sometimes we may want to define our own custom type that has a fixed set of values. For example, booleans don’t always express intentions well. Then an enum can do a better job:</p>
<pre><code><span>enum</span> <span>Activation</span> {
  <span>Active</span> = <span>&#39;Active&#39;</span>,
  <span>Inactive</span> = <span>&#39;Inactive&#39;</span>,
}
</code></pre>
<p>It’s a good practice to explicitly specify string values via <code>=</code>:</p>
<ul>
<li>We get more type safety and can’t accidentally provide numbers where an <code>Activation</code> is expected.</li>
<li>We can enumerate the keys and values of <code>Activation</code>.</li>
</ul>
<h3 id="enum-as-custom-type-with-unique-values" tabindex="-1">Enum as custom type with unique values  <a href="#enum-as-custom-type-with-unique-values" aria-hidden="true">#</a></h3>
<p>Which enum features are relevant for this use case?</p>
<ul>
<li>We will use the type defined by <code>Activation</code>.</li>
<li>Exhaustiveness checks are possible and useful.</li>
<li>We also may want to enumerate keys or values.</li>
</ul>
<h3 id="alternative-to-enum%3A-object-literal-1" tabindex="-1">Alternative to enum: object literal  <a href="#alternative-to-enum%3A-object-literal-1" aria-hidden="true">#</a></h3>
<p>Let’s use an object literal to define the value part of an enum (we’ll get to the type part next):</p>
<pre><code><span>const</span> <span>Activation</span> = {
  <span>__proto__</span>: <span>null</span>,
  <span>Active</span>: <span>&#39;Active&#39;</span>,
  <span>Inactive</span>: <span>&#39;Inactive&#39;</span>,
} <span>as</span> <span>const</span>; 


expectType&lt;<span>&#39;Active&#39;</span>&gt;(<span>Activation</span>.<span>Active</span>);

<span>type</span> <span>ActivationType</span> = <span>PropertyValues</span>&lt;<span>typeof</span> <span>Activation</span>&gt;;
expectType&lt;
  <span>TypeEqual</span>&lt;<span>ActivationType</span>, <span>&#39;Active&#39;</span> | <span>&#39;Inactive&#39;</span>&gt;
&gt;(<span>true</span>);
</code></pre>
<p>The <code>as const</code> in line A enables us to derive <code>ActivationType</code> from <code>Activation</code> via the helper type <code>PropertyValues</code> (which is defined below).</p>
<p>Why is this type called <code>ActivationType</code> and not <code>Activation</code>? Since the namespaces of values and types are separate in TypeScript, we could indeed use the same name. However, I’ve had issues when using Visual Studio Code to rename value and type: It got confused because importing <code>Activation</code> imported both value and type. That’s why I’m using different names – for now.</p>
<p>The helper type <code>PropertyValues</code> looks like this:</p>
<pre><code><span>type</span> <span>PropertyValues</span>&lt;<span>Obj</span>&gt; = <span>Obj</span>[<span>Exclude</span>&lt;keyof <span>Obj</span>, <span>&#39;__proto__&#39;</span>&gt;];
</code></pre>
<ul>
<li>The type <code>Obj[K]</code> contains the values of all properties whose keys are in <code>K</code>.</li>
<li>We exclude the key <code>&#39;__proto__&#39;</code> from <code>keyof Obj</code> because TypeScript treats that key as a normal property and that’s not what we want (<a href="https://github.com/microsoft/TypeScript/issues/38385">related GitHub issue</a>).</li>
</ul>
<p>Let’s explore what the derived type looks like if we don’t use <code>as const</code>:</p>
<pre><code><span>const</span> <span>Activation</span> = {
  <span>__proto__</span>: <span>null</span>,
  <span>Active</span>: <span>&#39;Active&#39;</span>,
  <span>Inactive</span>: <span>&#39;Inactive&#39;</span>,
};

expectType&lt;<span>string</span>&gt;(<span>Activation</span>.<span>Active</span>);
expectType&lt;<span>string</span>&gt;(<span>Activation</span>.<span>Inactive</span>);

<span>type</span> <span>ActivationType</span> = <span>PropertyValues</span>&lt;<span>typeof</span> <span>Activation</span>&gt;;
expectType&lt;
  <span>TypeEqual</span>&lt;<span>ActivationType</span>, <span>string</span>&gt;
&gt;(<span>true</span>);
</code></pre>
<h4 id="exhaustiveness-checks" tabindex="-1">Exhaustiveness checks  <a href="#exhaustiveness-checks" aria-hidden="true">#</a></h4>
<p>TypeScript supports exhaustiveness checks for unions of literal types. And that’s what <code>ActivationType</code> is. Therefore, we can use the same pattern as we did with enums:</p>
<pre><code><span>function</span> <span>activationToString</span>(<span>activation: ActivationType</span>): <span>string</span> {
  <span>switch</span> (activation) {
    <span>case</span> <span>Activation</span>.<span>Active</span>:
      <span>return</span> <span>&#39;ACTIVE&#39;</span>;
    <span>case</span> <span>Activation</span>.<span>Inactive</span>:
      <span>return</span> <span>&#39;INACTIVE&#39;</span>;
    <span>default</span>:
      <span>throw</span> <span>new</span> <span>UnsupportedValueError</span>(activation);
  }
}
</code></pre>
<h4 id="enumerating-members-1" tabindex="-1">Enumerating members  <a href="#enumerating-members-1" aria-hidden="true">#</a></h4>
<p>We can use <code>Object.keys()</code> and <code>Object.values()</code> to enumerate the members of the object <code>Activation</code>:</p>
<pre><code><span>for</span> (<span>const</span> value <span>of</span> <span>Object</span>.<span>values</span>(<span>Activation</span>)) {
  <span>console</span>.<span>log</span>(value);
}
</code></pre>
<p>Output:</p>
<pre><code>Active
Inactive
</code></pre>
<h4 id="using-symbols-as-property-values" tabindex="-1">Using symbols as property values  <a href="#using-symbols-as-property-values" aria-hidden="true">#</a></h4>
<p>One downside of using strings as property values is that <code>ActivationType</code> does not exclude arbitrary strings from being used. We can get more type safety if we use symbols:</p>
<pre><code><span>const</span> <span>Active</span> = <span>Symbol</span>(<span>&#39;Active&#39;</span>);
<span>const</span> <span>Inactive</span> = <span>Symbol</span>(<span>&#39;Inactive&#39;</span>);

<span>const</span> <span>Activation</span> = {
  <span>__proto__</span>: <span>null</span>,
  <span>Active</span>,
  <span>Inactive</span>,
} <span>as</span> <span>const</span>;

expectType&lt;<span>typeof</span> <span>Active</span>&gt;(<span>Activation</span>.<span>Active</span>);

<span>type</span> <span>ActivationType</span> = <span>PropertyValues</span>&lt;<span>typeof</span> <span>Activation</span>&gt;;
expectType&lt;
  <span>TypeEqual</span>&lt;
    <span>ActivationType</span>, <span>typeof</span> <span>Active</span> | <span>typeof</span> <span>Inactive</span>
  &gt;
&gt;(<span>true</span>);
</code></pre>
<p>This seems overly complicated: Why the intermediate step of first declaring variables for the symbols before we use them? Why not create the symbols inside the object literal? Alas, that’s a current limitation of <code>as const</code> for symbols: They are not recognized as unique (<a href="https://github.com/microsoft/TypeScript/issues/54100">related GitHub issue</a>):</p>
<pre><code><span>const</span> <span>Activation</span> = {
  <span>__proto__</span>: <span>null</span>,
  <span>Active</span>: <span>Symbol</span>(<span>&#39;Active&#39;</span>),
  <span>Inactive</span>: <span>Symbol</span>(<span>&#39;Inactive&#39;</span>),
} <span>as</span> <span>const</span>;


expectType&lt;<span>symbol</span>&gt;(<span>Activation</span>.<span>Active</span>);

<span>type</span> <span>ActivationType</span> = <span>PropertyValues</span>&lt;<span>typeof</span> <span>Activation</span>&gt;;
expectType&lt;
  <span>TypeEqual</span>&lt;<span>ActivationType</span>, <span>symbol</span>&gt;
&gt;(<span>true</span>);
</code></pre>
<h3 id="alternative-to-enum%3A-union-of-string-literal-types" tabindex="-1">Alternative to enum: union of string literal types  <a href="#alternative-to-enum%3A-union-of-string-literal-types" aria-hidden="true">#</a></h3>
<p>A union of string literal types is an interesting alternative to an enum when it comes to defining a type with a fixed set of members:</p>
<pre><code><span>type</span> <span>Activation</span> = <span>&#39;Active&#39;</span> | <span>&#39;Inactive&#39;</span>;
</code></pre>
<p>How does such a type compare to an enum?</p>
<p>Pros:</p>
<ul>
<li>It’s a quick and simple solution.</li>
<li>It supports exhaustiveness checks.</li>
<li>Renaming members works reasonably well in Visual Studio Code.</li>
</ul>
<p>Cons:</p>
<ul>
<li>The type members are not unique. We could change that by using symbols but then we’d lose some of the convenience of string literal union types – e.g., we’d have to import the values.</li>
<li>We can’t enumerate the members. The next section explains how to change that.</li>
</ul>
<h4 id="reifying-string-literal-unions" tabindex="-1">Reifying string literal unions via Sets  <a href="#reifying-string-literal-unions" aria-hidden="true">#</a></h4>
<p><em>Reification</em> means creating an entity at the object level (think JavaScript values) for an entity that exists at the meta level (think TypeScript types).</p>
<p>We can use a Set to reify a string literal union type:</p>
<pre><code><span>const</span> activation = <span>new</span> <span>Set</span>([
  <span>&#39;Active&#39;</span>,
  <span>&#39;Inactive&#39;</span>,
] <span>as</span> <span>const</span>);
expectType&lt;<span>Set</span>&lt;<span>&#39;Active&#39;</span> | <span>&#39;Inactive&#39;</span>&gt;&gt;(activation);



activation.<span>has</span>(<span>&#39;abc&#39;</span>);
  


<span>type</span> <span>Activation</span> = <span>SetElementType</span>&lt;<span>typeof</span> activation&gt;;
expectType&lt;
  <span>TypeEqual</span>&lt;<span>Activation</span>, <span>&#39;Active&#39;</span> | <span>&#39;Inactive&#39;</span>&gt;
&gt;(<span>true</span>);

<span>type</span> <span>SetElementType</span>&lt;S <span>extends</span> <span>Set</span>&lt;<span>any</span>&gt;&gt; =
  S <span>extends</span> <span>Set</span>&lt;infer <span>Elem</span>&gt; ? <span>Elem</span> : <span>never</span>;
</code></pre>
<h2 id="use-case%3A-namespace-for-constants-with-object-values" tabindex="-1">Use case: namespace for constants with object values  <a href="#use-case%3A-namespace-for-constants-with-object-values" aria-hidden="true">#</a></h2>
<p>Sometimes, it’s useful to have an enum-like construct for looking up richer data – stored in objects. We can’t use objects as enum values, so we’ll have to use other solutions.</p>
<h3 id="object-literal-whose-property-values-are-objects" tabindex="-1">Object literal whose property values are objects  <a href="#object-literal-whose-property-values-are-objects" aria-hidden="true">#</a></h3>
<p>This is an example of using an object literal as an enum for objects:</p>
<pre><code>

<span>type</span> <span>TTextStyle</span> = {
  <span>key</span>: <span>string</span>,
  <span>html</span>: <span>string</span>,
  <span>latex</span>: <span>string</span>,
};
<span>const</span> <span>TextStyle</span> = {
  <span>Bold</span>: {
    <span>key</span>: <span>&#39;Bold&#39;</span>,
    <span>html</span>: <span>&#39;b&#39;</span>,
    <span>latex</span>: <span>&#39;textbf&#39;</span>,
  },
  <span>Italics</span>: {
    <span>key</span>: <span>&#39;Italics&#39;</span>,
    <span>html</span>: <span>&#39;i&#39;</span>,
    <span>latex</span>: <span>&#39;textit&#39;</span>,
  },
} <span>as</span> <span>const</span> satisfies <span>Record</span>&lt;<span>string</span>, <span>TTextStyle</span>&gt;;

<span>type</span> <span>TextStyleType</span> = <span>PropertyValues</span>&lt;<span>typeof</span> <span>TextStyle</span>&gt;;
<span>type</span> <span>PropertyValues</span>&lt;<span>Obj</span>&gt; = <span>Obj</span>[<span>Exclude</span>&lt;keyof <span>Obj</span>, <span>&#39;__proto__&#39;</span>&gt;];
</code></pre>
<h4 id="exhaustiveness-check" tabindex="-1">Exhaustiveness check  <a href="#exhaustiveness-check" aria-hidden="true">#</a></h4>
<p>Why do the property values of <code>TextStyle</code> have the property <code>.key</code>? That property lets us do exhaustiveness checks because the property values form a <a href="https://exploringjs.com/tackling-ts/ch_enum-alternatives.html#discriminated-union">discriminated union</a>.</p>
<pre><code><span>function</span> <span>f</span>(<span>textStyle: TextStyleType</span>): <span>string</span> {
  <span>switch</span> (textStyle.<span>key</span>) {
    <span>case</span> <span>TextStyle</span>.<span>Bold</span>.<span>key</span>:
      <span>return</span> <span>&#39;BOLD&#39;</span>;
    <span>case</span> <span>TextStyle</span>.<span>Italics</span>.<span>key</span>:
      <span>return</span> <span>&#39;ITALICS&#39;</span>;
    <span>default</span>:
      <span>throw</span> <span>new</span> <span>UnsupportedValueError</span>(textStyle); 
  }
}
</code></pre>
<p>For comparison, this is what <code>f()</code> would look like if <code>TextStyle</code> were an enum:</p>
<pre><code><span>enum</span> <span>TextStyle2</span> { <span>Bold</span>, <span>Italics</span> }
<span>function</span> <span>f2</span>(<span>textStyle: TextStyle2</span>): <span>string</span> {
  <span>switch</span> (textStyle) {
    <span>case</span> <span>TextStyle2</span>.<span>Bold</span>:
      <span>return</span> <span>&#39;BOLD&#39;</span>;
    <span>case</span> <span>TextStyle2</span>.<span>Italics</span>:
      <span>return</span> <span>&#39;ITALICS&#39;</span>;
    <span>default</span>:
      <span>throw</span> <span>new</span> <span>UnsupportedValueError</span>(textStyle);
  }
}
</code></pre>
<h3 id="enum-class" tabindex="-1">Enum class  <a href="#enum-class" aria-hidden="true">#</a></h3>
<p>We can also use a class as an enum – a pattern that is borrowed from Java:</p>
<pre><code><span>class</span> <span>TextStyle</span> {
  <span>static</span> <span>Bold</span> = <span>new</span> <span>TextStyle</span>();
  <span>static</span> <span>Italics</span> = <span>new</span> <span>TextStyle</span>();
}
<span>type</span> <span>TextStyleKeys</span> = <span>EnumKeys</span>&lt;<span>typeof</span> <span>TextStyle</span>&gt;;
expectType&lt;
  <span>TypeEqual</span>&lt;<span>TextStyleKeys</span>, <span>&#39;Bold&#39;</span> | <span>&#39;Italics&#39;</span>&gt;
&gt;(<span>true</span>);

<span>type</span> <span>EnumKeys</span>&lt;T&gt; = <span>Exclude</span>&lt;keyof T, <span>&#39;prototype&#39;</span>&gt;;
</code></pre>
<p>One pro of this pattern is that we can use methods to add behavior to the enum values. A con is that there is no simple way to get an exhaustiveness check.</p>
<p><code>Object.keys()</code> and <code>Object.values()</code> ignore non-enumerable properties of <code>TextStyle</code> such as <code>.prototype</code> – which is why we can use them to enumerate keys and values – e.g.:</p>
<pre><code>assert.<span>deepEqual</span>(
  
  <span>Object</span>.<span>keys</span>(<span>TextStyle</span>),
  [<span>&#39;Bold&#39;</span>, <span>&#39;Italics&#39;</span>]
);
</code></pre>
<h2 id="mapping-to-and-from-an-enum" tabindex="-1">Mapping to and from an enum  <a href="#mapping-to-and-from-an-enum" aria-hidden="true">#</a></h2>
<p>Sometimes we want to translate enum values to other values or vice versa – e.g. when serializing them to JSON or deserializing them from JSON. If we do so via a <code>Map</code>, we can use TypeScript to get a warning if we forget an enum value.</p>
<p>To explore how that works, we’ll use the following enum pattern type:</p>
<pre><code><span>const</span> <span>Pending</span> = <span>Symbol</span>(<span>&#39;Pending&#39;</span>);
<span>const</span> <span>Ongoing</span> = <span>Symbol</span>(<span>&#39;Ongoing&#39;</span>);
<span>const</span> <span>Finished</span> = <span>Symbol</span>(<span>&#39;Finished&#39;</span>);
<span>const</span> <span>TaskStatus</span> = {
  <span>__proto__</span>: <span>null</span>,
  <span>Pending</span>,
  <span>Ongoing</span>,
  <span>Finished</span>,
} <span>as</span> <span>const</span>;
<span>type</span> <span>TaskStatusType</span> = <span>PropertyValues</span>&lt;<span>typeof</span> <span>TaskStatus</span>&gt;;
<span>type</span> <span>PropertyValues</span>&lt;<span>Obj</span>&gt; = <span>Obj</span>[<span>Exclude</span>&lt;keyof <span>Obj</span>, <span>&#39;__proto__&#39;</span>&gt;];
</code></pre>
<p>This is the Map:</p>
<pre><code><span>const</span> taskPairs = [
  [<span>TaskStatus</span>.<span>Pending</span>, <span>&#39;not yet&#39;</span>],
  [<span>TaskStatus</span>.<span>Ongoing</span>, <span>&#39;working on it&#39;</span>],
  [<span>TaskStatus</span>.<span>Finished</span>, <span>&#39;finished&#39;</span>],
] <span>as</span> <span>const</span>;

<span>type</span> <span>Key</span> = (<span>typeof</span> taskPairs)[<span>number</span>][<span>0</span>];
<span>const</span> taskMap = <span>new</span> <span>Map</span>&lt;<span>Key</span>, <span>string</span>&gt;(taskPairs);
</code></pre>
<p>If you are wondering why we didn’t directly use the value of <code>taskPairs</code> as the argument of <code>new Map()</code> and omit the type parameters: TypeScript doesn’t seem to be able to infer the type parameters if the keys are symbols and reports a compile-time error. With strings, the code would be simpler:</p>
<pre><code><span>const</span> taskPairs = [
  [<span>&#39;Pending&#39;</span>, <span>&#39;not yet&#39;</span>],
  [<span>&#39;Ongoing&#39;</span>, <span>&#39;working on it&#39;</span>],
  [<span>&#39;Finished&#39;</span>, <span>&#39;finished&#39;</span>],
] <span>as</span> <span>const</span>;
<span>const</span> taskMap = <span>new</span> <span>Map</span>(taskPairs); 
</code></pre>
<p>The final step is to check if we forgot only of the values of <code>TaskStatus</code>:</p>
<pre><code>expectType&lt;
  <span>TypeEqual</span>&lt;<span>MapKey</span>&lt;<span>typeof</span> taskMap&gt;, <span>TaskStatusType</span>&gt;
&gt;(<span>true</span>);
<span>type</span> <span>MapKey</span>&lt;M <span>extends</span> <span>Map</span>&lt;<span>any</span>, <span>any</span>&gt;&gt; =
  M <span>extends</span> <span>Map</span>&lt;infer K, <span>any</span>&gt; ? K : <span>never</span>;
</code></pre>
<h2 id="recommendations" tabindex="-1">Recommendations  <a href="#recommendations" aria-hidden="true">#</a></h2>
<p>When should we use an enum and when an alternative pattern?</p>
<p><strong>TypeScript enums are not JavaScript:</strong> Enums are one of the few TypeScript language constructs (vs. type constructs) that have no corresponding JavaScript features. That can matter in two ways:</p>
<ul>
<li>The transpiled code looks a bit strange – especially if some enum members are numbers.</li>
<li>If a tool doesn’t transpile TypeScript but only strips types then it won’t support enums. That’s not (yet?) that common but one prominent example is <a href="https://2ality.com/2025/01/nodejs-strip-type.html">Node’s current built-in support for TypeScript</a>.</li>
</ul>
<p><strong>Performance of strings:</strong> One thing to keep in mind is that comparing strings is usually slower than comparing numbers or symbols. Therefore, enums or enum patterns where values are strings, are slower. Note that applies to string literal unions too. But such a performance cost only matters if we do many comparisons.</p>
<p><strong>What is the use case?</strong> Looking at the use cases can help us make a decision:</p>
<ol>
<li>Namespace for constants with primitive values:
<ul>
<li>If the primitive values are numbers or strings, we can use a TypeScript enum.
<ul>
<li>Alas, number values aren’t great because each member produces two properties: a mapping from key to value and a reverse mapping.</li>
</ul>
</li>
<li>Otherwise (or if we don’t want to use an enum) we can use an object literal.</li>
</ul>
</li>
<li>Custom type with unique values:
<ul>
<li>If we use an enum, it should have string values because that gives us more type safety and lets us iterate over keys and values.</li>
<li>A union of string literal types is a lightweight, quick solution. Its downsides are: less type safety and no namespace object for easy lookup.
<ul>
<li>If we want to access the string literal values at runtime, we can use a Set to reify them.</li>
</ul>
</li>
<li>If we want a solid, slightly verbose solution, we can use an object literal with symbol property values.</li>
</ul>
</li>
<li>Namespace for constants with object values:
<ul>
<li>We can’t use enums for this use case.</li>
<li>We can use an object literal whose property values are objects. The upside of this solution is that we can check exhaustiveness.</li>
<li>If we want enum values to have methods, we can use an enum class. However that means that we can’t check exhaustiveness.</li>
</ul>
</li>
</ol>
</div></div>
  </body>
</html>
