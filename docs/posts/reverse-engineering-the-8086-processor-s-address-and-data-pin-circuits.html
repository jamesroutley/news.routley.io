<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.righto.com/2023/07/8086-pins.html">Original</a>
    <h1>Reverse-engineering the 8086 processor&#39;s address and data pin circuits</h1>
    
    <div id="readability-page-1" class="page"><div id="post-body-2795813864611579036" itemprop="description articleBody">


<p>The Intel 8086 microprocessor (1978) started the x86 architecture that continues to this day.
In this blog post, I&#39;m focusing on a small part of the chip: the address and data pins that connect the chip to
external memory and I/O devices.
In many processors, this circuitry is straightforward, but it is complicated in the 8086 for two reasons.
First, Intel decided to package the 8086 as a 40-pin DIP, which didn&#39;t provide enough pins for all the functionality.
Instead, the 8086 multiplexes address, data, and status.
In other words, a pin can have multiple roles, providing an address bit at one time and a data bit at another time.</p>
<p>The second complication is that the 8086 has a 20-bit address space (due to its infamous segment registers), while the
data bus is 16 bits wide.
As will be seen, the &#34;extra&#34; four address bits have more impact than you might expect.
To summarize, 16 pins, called AD0-AD15, provide 16 bits of address and data.
The four remaining address pins (A16-A19) are multiplexed for use as status pins,
providing information about what the processor is doing for use by other parts of the system.
You might expect that the 8086 would thus have two types of pin circuits, but it turns out that there are four
distinct circuits, which I will discuss below.</p>
<p><a href="https://static.righto.com/images/8086-ad-pins/die-labeled.jpg"><img alt="The 8086 die under the microscope, with the main functional blocks and address pins labeled. Click this image (or any other) for a larger version." height="623" src="https://static.righto.com/images/8086-ad-pins/die-labeled-w700.jpg" title="The 8086 die under the microscope, with the main functional blocks and address pins labeled. Click this image (or any other) for a larger version." width="700"/></a></p><p>The 8086 die under the microscope, with the main functional blocks and address pins labeled. Click this image (or any other) for a larger version.</p>
<p>The microscope image above shows the silicon die of the 8086.
In this image, the metal layer on top of the chip is visible, while the silicon and polysilicon underneath are obscured.
The square pads around the edge of the die are connected by tiny bond wires to the chip&#39;s 40 external pins.
The 20 address pins are labeled: Pins AD0 through AD15 function as
address and data pins. Pins A16 through A19 function as address pins and status pins.<span id="fnref:ad"><a href="#fn:ad">1</a></span>
The circuitry that controls the pins is highlighted in red.
Two internal busses are important for this discussion: the 20-bit AD bus (green) connects the AD pins to the rest of the CPU,
while the 16-bit C bus (blue) communicates with the registers.
These buses are connected through a circuit that can swap the byte order or shift the value.
(The lines on the diagram are simplified; the real wiring twists and turns to fit the layout.
Moreover, the C bus (blue) has its bits spread across the width of the register file.)</p>
<h2>Segment addressing in the 8086</h2>
<p>One goal of the 8086 design was to maintain backward compatibility with the earlier 8080 processor.<span id="fnref:compatibility"><a href="#fn:compatibility">2</a></span>
This had a major impact on the 8086&#39;s memory design, resulting in the much-hated segment registers.
The 8080 (like most of the 8-bit processors of the early 1970s) had a 16-bit address space, able to access 64K (65,536 bytes) of memory,
which was plenty at the time.
But due to the exponential growth in memory capacity described by Moore&#39;s Law, it was clear that the 8086 needed to
support much more. Intel decided on a 1-megabyte address space, requiring 20 address bits.
But Intel wanted to keep the 16-bit memory addresses used by the 8080.</p>
<p>The solution was to break memory into segments. Each segment was 64K long, so a 16-bit offset was sufficient to access memory
in a segment.
The segments were allocated in a 1-megabyte address space, with the result that you could access a megabyte of memory, but
only in 64K chunks.<span id="fnref:pointers"><a href="#fn:pointers">3</a></span>
Segment addresses were also 16 bits, but were shifted left by 4 bits (multiplied by 16) to support the 20-bit address space.</p>
<p>Thus, every memory access in the 8086 required a computation of the physical address.
The diagram below illustrates this process: the logical address consists of the segment base address and the offset within the segment.
The 16-bit segment register was shifted 4 bits and added to the 16-bit offset to yield the 20-bit physical memory address.</p>
<p><a href="https://static.righto.com/images/8086-ad-pins/physical-address-generation.jpg"><img alt="The segment register and the offset are added to create a 20-bit physical address.  From iAPX 86,88 User&#39;s Manual, page 2-13." height="260" src="https://static.righto.com/images/8086-ad-pins/physical-address-generation-w500.jpg" title="The segment register and the offset are added to create a 20-bit physical address.  From iAPX 86,88 User&#39;s Manual, page 2-13." width="500"/></a></p><p>The segment register and the offset are added to create a 20-bit physical address.  From <a href="http://www.bitsavers.org/components/intel/_dataBooks/1981_iAPX_86_88_Users_Manual.pdf">iAPX 86,88 User&#39;s Manual</a>, page 2-13.</p>
<p>This address computation was not performed by the regular ALU (Arithmetic/Logic Unit), but by a separate adder that
was devoted to address computation.
The address adder is visible in the upper-left corner of the die photo.
I will discuss the address adder in more detail below.</p>
<h2>The AD bus and the C Bus</h2>
<p>The 8086 has multiple internal buses to move bits internally, but the relevant ones are the AD bus and the C bus.
The AD bus is a 20-bit bus that connects the 20 address/data pins to the internal circuitry.<span id="fnref:patent"><a href="#fn:patent">4</a></span>
A 16-bit bus called the C bus provides the connection between
the AD bus, the address adder and some of the registers.<span id="fnref:registers"><a href="#fn:registers">5</a></span>
The diagram below shows the connections.
The AD bus can be connected to the 20 address pins through latches. The low 16 pins can also be used for data input, while the upper 4 pins
can also be used for status output.
The address adder performs the 16-bit addition necessary for segment arithmetic. Its output is shifted left by four bits
(i.e. it has four 0 bits appended), producing the 20-bit result.
The inputs to the adder are provided by registers, a constant ROM that holds small constants such as +1 or -2, or the C bus.</p>
<p><a href="https://static.righto.com/images/8086-ad-pins/buses.jpg"><img alt="My reverse-engineered diagram showing how the AD bus and the C bus interact with the address pins." height="311" src="https://static.righto.com/images/8086-ad-pins/buses-w350.jpg" title="My reverse-engineered diagram showing how the AD bus and the C bus interact with the address pins." width="350"/></a></p><p>My reverse-engineered diagram showing how the AD bus and the C bus interact with the address pins.</p>
<p>The shift/crossover circuit provides the interface between these two buses, handling the 20-bit to 16-bit conversion. The busses can be connected in three ways: direct, crossover, or shifted.<span id="fnref:swapping"><a href="#fn:swapping">6</a></span>
The direct mode connects the 16 bits of the C bus to the lower 16 bits of the address/data pins.
This is the standard mode for transferring data between the 8086&#39;s internal circuitry and the data pins.
The crossover mode performs the same connection but swaps the bytes. This is typically used for unaligned memory accesses, where the low memory byte corresponds to
the high register byte, or vice versa.
The shifted mode shifts the 20-bit AD bus value four positions to the right.
In this mode, the 16-bit output from the address adder goes to the 16-bit C bus.
(The shift is necessary to counteract the 4-bit shift applied to the address adder&#39;s output.)
Control circuitry selects the right operation for the shift/crossover circuit at the right time.<span id="fnref:shift"><a href="#fn:shift">7</a></span></p>
<p>Two of the registers are invisible to the programmer but play an important role in memory accesses.
The <code>IND</code> (Indirect) register specifies the memory address; it holds the 16-bit memory offset in a segment.
The <code>OPR</code> (Operand) register holds the data value.<span id="fnref:prefetch"><a href="#fn:prefetch">9</a></span>
The <code>IND</code> and <code>OPR</code> registers are not accessed directly by the programmer; the microcode for a machine instruction moves the appropriate
values to these registers prior to the write.</p>
<h2>Overview of a write cycle</h2>
<p>I hesitate to present a timing diagram, since I may scare off of my readers,
but the 8086&#39;s communication is designed around a four-step bus cycle.
The diagram below shows simplified timing for a write cycle, when the 8086 writes to memory or an I/O device.<span id="fnref:timing"><a href="#fn:timing">8</a></span>
The external bus activity is organized as four states, each one clock cycle long: T1, T2, T3, T4.
These T states are very important since they control what happens on the bus.
During T1, the 8086 outputs the address on the pins. During the T2, T3, and T4 states, the 8086 outputs the data word on the pins.
The important part for this discussion is that the pins are multiplexed depending on the T-state: the pins provide the address during T1 and data during
T2 through T4.</p>
<p><a href="https://static.righto.com/images/8086-ad-pins/write-cycle.jpg"><img alt="A typical write bus cycle consists of four T states. Based on The 8086 Family Users Manual, B-16." height="130" src="https://static.righto.com/images/8086-ad-pins/write-cycle-w700.jpg" title="A typical write bus cycle consists of four T states. Based on The 8086 Family Users Manual, B-16." width="700"/></a></p><p>A typical write bus cycle consists of four T states. Based on The 8086 Family Users Manual, B-16.</p>
<p>There two undocumented T states that are important to the bus cycle.
The physical address is computed in the two clock cycles before T1 so the address will be available in T1.
I give these &#34;invisible&#34; T states the names TS (start) and T0.</p>
<h2>The address adder</h2>
<!--
This computation is a bit tricky because the input buses and the adder are 16 bits, but the physical address is 20 bits.
-->
<p>The operation of the address adder is a bit tricky since the 16-bit adder must generate a 20-bit physical address.
The adder has two 16-bit inputs: the B input is connected to the upper registers via the B bus, while the C input is connected to the C bus.
The segment register value is transferred over the B bus to the adder during the second half
of the TS state (that is, two clock cycles before the bus cycle becomes externally visible during T1).
Meanwhile, the address offset is transferred over the C bus to the adder, but the adder&#39;s C input shifts the value four bits to the right,
discarding the four low bits. (As will be explained later, the pin driver circuits latch these bits.)
The adder&#39;s output is shifted left four bits and transferred to the AD bus during the second half of T0. 
This produces the upper 16 bits of the 20-bit physical memory address.
This value is latched into the address output flip-flops at the start of T1, putting the computed address on the pins.
To summarize, the 20-bit address is generated by storing the 4 low-order bits during T0 and then the 16 high-order sum bits
during T1.</p>
<p>The address adder is not needed for segment arithmetic during T1 and T2.
To improve performance, the 8086 uses the adder during this idle time to increment or decrement memory addresses.
For instance, after popping a word from the stack, the stack pointer needs to be incremented by 2.
The address adder can do this increment &#34;for free&#34; during T1 and T2, leaving the ALU available for other operations.<span id="fnref:pipelining"><a href="#fn:pipelining">10</a></span>
Specifically, the adder updates the memory address in <code>IND</code>, incrementing it or decrementing it as appropriate.
First, the <code>IND</code> value is transferred over the B bus to the adder during the second half of T1.
Meanwhile, a constant (-3 to +2) is loaded from the Constant ROM and transferred to the adder&#39;s C input.
The output from the adder is transferred to the AD bus during the second half of T2.
As before, the output is shifted four bits to the left. However, the shift/crossover circuit between the AD bus and the C bus
is configured to shift four bits to the right, canceling the adder&#39;s shift.
The result is that the C bus gets the 16-bit sum from the adder, and this value is stored in the <code>IND</code> register.<span id="fnref:predecrement"><a href="#fn:predecrement">11</a></span>
For more information on the implemenation of the address adder, see my <a href="https://www.righto.com/2020/08/reverse-engineering-adder-inside-intel.html">previous blog post</a>.</p>
<!-- 
The use of the address pins is closely tied to the 8086's external timing.
The diagram below shows how a typical bus cycle is divided into four "T" states, each one corresponding to one clock cycle.
During T1, the CPU puts the memory address on the bus using the address pins.
During T3 and T4, the CPU writes to memory by putting the data value on the data pins.
Alternatively, the CPU reads from memory by reading the data value during T3 and T4.
State T2 acts a buffer period to ensure that memory and the CPU don't try to write to the bus at the same time.

![A typical bus cycle consists of four T states. Diagram from The 8086 Family Users Manual, figure 4-5.](bus-cycle.jpg "w500")
-->

<h2>The pin driver circuit</h2>
<p>Now I&#39;ll dive down to the hardware implementation of an output pin.
When the 8086 chip communicates with the outside world, it needs to provide relatively high currents.
The tiny logic transistors can&#39;t provide enough current, so the chip needs to use large output transistors.
To fit the large output transistors on the die, they are constructed of multiple wide transistors in parallel.<span id="fnref:ratio"><a href="#fn:ratio">12</a></span>
Moreover, the drivers use a somewhat unusual &#34;superbuffer&#34; circuit with two transistors: one to pull the output high, and one to pull the output low.<span id="fnref:superbuffer"><a href="#fn:superbuffer">13</a></span></p>
<p>The diagram below shows the transistor structure for one of the output pins (AD10), consisting of three
parallel transistors between the output and +5V, and five parallel transistors between the output and ground.
The die photo on the
left shows the metal layer on top of the die. This shows the power and ground wiring and the connections to
the transistors.
The photo on the right shows the die with the metal layer removed, showing the underlying silicon and the
polysilicon wiring on top.
A transistor gate is formed where a polysilicon wire crosses the doped silicon region. 
Combined, the +5V transistors are equivalent to about 60 typical transistors, while the ground transistors are
equivalent to about 100 typical transistors.
Thus, these transistors provide substantially more current to the output pin.</p>
<p><a href="https://static.righto.com/images/8086-ad-pins/output-transistor.jpg"><img alt="Two views of the output transistors for a pin. The first shows the metal layer, while the second shows the polysilicon and silicon." height="402" src="https://static.righto.com/images/8086-ad-pins/output-transistor-w800.jpg" title="Two views of the output transistors for a pin. The first shows the metal layer, while the second shows the polysilicon and silicon." width="800"/></a></p><p>Two views of the output transistors for a pin. The first shows the metal layer, while the second shows the polysilicon and silicon.</p>
<h3>Tri-state output driver</h3>
<p>The output circuit for an address pin uses a tri-state buffer, which allows the output to be disabled
by putting it into a high-impedance &#34;tri-state&#34; configuration.
In this state, the output is not pulled high or low but is left floating.
This capability allows the pin to be used for data input.
It also allows external devices to device can take control of the bus, for instance, to perform
DMA (direct memory access).</p>
<p>The pin is driven by two large MOSFETs, one to pull the output high and one to pull it low.
(As described earlier, each large MOSFET is physically multiple transistors in parallel, but I&#39;ll ignore that for now.)
If both MOSFETs are off, the output floats, neither on nor off.</p>
<p><a href="https://static.righto.com/images/8086-ad-pins/output-circuit.jpg"><img alt="Schematic diagram of a &#34;typical&#34; address output pin." height="230" src="https://static.righto.com/images/8086-ad-pins/output-circuit-w400.jpg" title="Schematic diagram of a &#34;typical&#34; address output pin." width="400"/></a></p><p>Schematic diagram of a &#34;typical&#34; address output pin.</p>
<p>The tri-state output is implemented by driving the MOSFETs with two &#34;superbuffer&#34;<span id="fnref:and"><a href="#fn:and">15</a></span> AND gates.
If the <code>enable</code> input is low, both AND gates produce a low output and both output transistors are off.
On the other hand, if <code>enable</code> is high, one AND gate will be on and one will be off.
The desired output value is loaded into a flip-flop to hold it,<span id="fnref:clock"><a href="#fn:clock">14</a></span>
and the flip-flop turns one of the output transistors on, driving the output pin high or low as appropriate.
(Conveniently, the flip-flop provides the data output Q and the inverted data output <span>Q</span>.)
Generally, the address pin outputs are enabled for T1-T4 of a write but only during T1 for a read.<span id="fnref:enable"><a href="#fn:enable">16</a></span></p>
<p>In the remainder of the discussion, I&#39;ll use the tri-state buffer symbol below, rather than showing the implementation of the buffer.</p>
<p><a href="https://static.righto.com/images/8086-ad-pins/output-simplified.jpg"><img alt="The output circuit, expressed with a tri-state buffer symbol." height="137" src="https://static.righto.com/images/8086-ad-pins/output-simplified-w350.jpg" title="The output circuit, expressed with a tri-state buffer symbol." width="350"/></a></p><p>The output circuit, expressed with a tri-state buffer symbol.</p>
<h3>AD4-AD15</h3>
<p>Pins AD4-AD15 are &#34;typical&#34; pins, avoiding the special behavior of the top and bottom pins, so I&#39;ll discuss them first.
The behavior of these pins is that the value on the AD bus is latched by the circuit and then put on the output pin
under the control of the <code>enaable</code> signal.
The circuit has three parts: a multiplexer to select the output value, a flip-flop to hold the output value, and a tri-state driver to
provide the high-current output to the pin.
In more detail, the multiplexer selects either the value on the AD bus or the current output from the flip-flop.
That is, the multiplexer can either load a new value into the flip-flop or hold the existing value.<span id="fnref:implementation"><a href="#fn:implementation">17</a></span>
The flip-flop latches the input value on the falling edge of the clock, passing it to the output driver.
If the enable line is high, the output driver puts this value on the corresponding address pin.</p>
<!-- datasheet: output low tested at 2.0mA, output high tested at -400 microamps -->

<p><a href="https://static.righto.com/images/8086-ad-pins/ad415.jpg"><img alt="The output circuit for AD4-AD15 has a latch to hold the desired output value, an address or data bit." height="129" src="https://static.righto.com/images/8086-ad-pins/ad415-w400.jpg" title="The output circuit for AD4-AD15 has a latch to hold the desired output value, an address or data bit." width="400"/></a></p><p>The output circuit for AD4-AD15 has a latch to hold the desired output value, an address or data bit.</p>
<p>For a write, the circuit latches the address value on the bus during the second half of T0 and puts it on the pins during T1.
During the second half of the T1 state, the data word is transferred from the <code>OPR</code> register over the C bus to the AD bus and loaded
into the AD pin latches.
The word is transferred from the latches to the pins during T2 and held for the remainder of the bus cycle.</p>
<h3>AD0-AD3</h3>
<p>The four low address bits have a more complex circuit because these address bits are latched from the bus before the address adder computes its sum, as described earlier.
The memory offset (before the segment addition) will be on the C bus during the second half of TS and is loaded into the lower
flip-flop. This flip-flop delays these bits for one clock cycle and then they are loaded into the upper flip-flop.
Thus, these four pins pick up the offset prior to the addition, while the other pins get the result of the segment addition.</p>
<p><a href="https://static.righto.com/images/8086-ad-pins/ad03.jpg"><img alt="The output circuit for AD0-AD3 has a second latch to hold the low address bits before the address adder computes the sum." height="174" src="https://static.righto.com/images/8086-ad-pins/ad03-w500.jpg" title="The output circuit for AD0-AD3 has a second latch to hold the low address bits before the address adder computes the sum." width="500"/></a></p><p>The output circuit for AD0-AD3 has a second latch to hold the low address bits before the address adder computes the sum.</p>
<p>For data, the AD0-AD3 pins transfer data directly from the AD bus to the pin latch, bypassing the delay that was used to get the address bits.
That is, the AD0-AD3 pins have two paths: the delayed path used for addresses during T0 and the direct path otherwise used for data.
Thus, the multiplexer has three inputs: two for these two paths and a third loop-back input to hold the flip-flop value.</p>
<!--
ad-latch-load loads the  AD0-15 latches.
-->

<!--
If the memory access was an instruction fetch,
the address adder is immediately reused to update the instruction pointer (program counter).
In the second half of T1, one input of the address adder is loaded with the instruction pointer increment from the constant ROM (2 if a word was fetched).
This value is added to the instruction pointer value and
the updated instruction pointer value is written back in the second half of T2.
A similar process is used for other memory accesses that update a pointer, such as stack operations or string operations.

If another bus cycle follows, the T3 and T4 states act like the T0 and T1 states described above, preparing the next memory address.
Thus, address calculation is pipelined in the 8086: the address adder performs the segment computation during the last half of the previous bus cycle, so the physical memory address will be ready at the start of the bus cycle.

For a memory write, the address latches are reloaded during T1, loading them with the `OPR` register???
-->

<h3>A16-A19: status outputs</h3>
<p>The top four pins (A16-A19) are treated specially, since they are not used for data.
Instead, they provide processor status during T2-T4.<span id="fnref:status"><a href="#fn:status">18</a></span> The pin latches for these
pins are loaded with the address during T0 like the other pins, but loaded with status instead of data during T1.
The multiplexer at the input to the latch selects the address bit during T0 and the status bit during T1, and
holds the value otherwise.
The schematic below shows how this is implemented for A16, A17, and A19.</p>
<p><a href="https://static.righto.com/images/8086-ad-pins/ad1619.jpg"><img alt="The output circuit for AD16, AD17, and AD19 selects either an address output or a status output." height="115" src="https://static.righto.com/images/8086-ad-pins/ad1619-w400.jpg" title="The output circuit for AD16, AD17, and AD19 selects either an address output or a status output." width="400"/></a></p><p>The output circuit for AD16, AD17, and AD19 selects either an address output or a status output.</p>
<p>Address pin A18 is different because it indicates the current status of the interrupt enable flag bit.
This status is updated every clock cycle, unlike the other pins.
To implement this, the pin has a different circuit that isn&#39;t latched,
so the status can be updated continuously.
The clocked transistors act as &#34;pass transistors&#34;, passing the signal through when active.
When a pass transistor is turned off, the following logic gate holds the previous value due to the capacitance of the
wiring.
Thus, the pass transistors provide a way of holding the value through the clock cycle.
The flip-flops are implemented with pass transistors internally, so in a sense the circuit below is a flip-flop
that has been &#34;exploded&#34; to provide a second path for the interrupt status.</p>
<p><a href="https://static.righto.com/images/8086-ad-pins/ad18.jpg"><img alt="The output circuit for AD18 is different from the rest so the I flag status can be updated every clock cycle." height="162" src="https://static.righto.com/images/8086-ad-pins/ad18-w540.jpg" title="The output circuit for AD18 is different from the rest so the I flag status can be updated every clock cycle." width="540"/></a></p><p>The output circuit for AD18 is different from the rest so the I flag status can be updated every clock cycle.</p>
<h2>Reads</h2>
<p>A memory or I/O read also uses a 4-state bus cycle, slightly different from the write cycle.
During T1, the address is provided on the pins, the same as for a write.
After that, however, the output circuits are tri-stated so they float, allowing the external memory to put data on the bus.
The read data on the pin is put on the AD bus at the start of the T4 state.
From there, the data passes through the crossover circuit to the C bus. Normally the 16 data bits pass straight through to
the C bus, but the bytes will be swapped if the memory access is unaligned.
From the C bus, the data is written to the <code>OPR</code> register, a byte or a word as appropriate.
(For an instruction prefetch, the word is written to a prefetch queue register instead.)</p>
<p><a href="https://static.righto.com/images/8086-ad-pins/read-cycle.jpg"><img alt="A typical read bus cycle consists of four T states. Based on The 8086 Family Users Manual, B-16." height="139" src="https://static.righto.com/images/8086-ad-pins/read-cycle-w600.jpg" title="A typical read bus cycle consists of four T states. Based on The 8086 Family Users Manual, B-16." width="600"/></a></p><p>A typical read bus cycle consists of four T states. Based on The 8086 Family Users Manual, B-16.</p>
<p>To support data input on the AD0-AD15 pins, they have a circuit to buffer the input data and transfer it to the AD bus.
The incoming data bit is buffered by the two inverters and sampled when the clock is high.
If the enable&#39; signal is low, the data bit is transferred to the AD bus when the clock is low.<span id="fnref:read-enable"><a href="#fn:read-enable">19</a></span>
The two MOSFETs act as a &#34;superbuffer&#34;, providing enough current for the fairly long AD bus.
I&#39;m not sure what the capacitor accomplishes, maybe avoiding a race condition if the data pin changes just as the clock goes low.<span id="fnref:race"><a href="#fn:race">20</a></span></p>
<p><a href="https://static.righto.com/images/8086-ad-pins/read-circuit.jpg"><img alt="Schematic of the input circuit for the data pins." height="134" src="https://static.righto.com/images/8086-ad-pins/read-circuit-w500.jpg" title="Schematic of the input circuit for the data pins." width="500"/></a></p><p>Schematic of the input circuit for the data pins.</p>
<p>This circuit has a second role, precharging the AD bus high when the clock is low, if there&#39;s no data.
Precharging a bus is fairly common in the 8086 (and other NMOS processors) because NMOS transistors are better at pulling a
line low than pulling it high. Thus, it&#39;s often faster to precharge a line high before it&#39;s needed and then pull it low for a 0.<span id="fnref:adder"><a href="#fn:adder">21</a></span></p>
<p>Since pins A16-A19 are not used for data, they operate the same for reads as for writes: providing address bits and then status.</p>
<h2>The pin circuit on the die</h2>
<p>The diagram below shows how the pin circuitry appears on the die. The metal wiring has been removed to show the silicon and polysilicon.
The top half of the image is the input circuitry, reading a data bit from the pin and feeding it to the AD bus.
The lower half of the image is the output circuitry, reading an address or data bit from the AD bus and amplifying it for output
via the pad.
The light gray regions are doped, conductive silicon. The thin tan lines are polysilicon, which forms transistor gates where it crosses doped silicon.</p>
<p><a href="https://static.righto.com/images/8086-ad-pins/pin-labeled.jpg"><img alt="The input/output circuitry for an address/data pin. The metal layer has been removed to show the underlying silicon and polysilicon. Some crystals have formed where the bond pad was." height="482" src="https://static.righto.com/images/8086-ad-pins/pin-labeled-w600.jpg" title="The input/output circuitry for an address/data pin. The metal layer has been removed to show the underlying silicon and polysilicon. Some crystals have formed where the bond pad was." width="600"/></a></p><p>The input/output circuitry for an address/data pin. The metal layer has been removed to show the underlying silicon and polysilicon. Some crystals have formed where the bond pad was.</p>
<h2>A historical look at pins and timing</h2>
<p>The number of pins on Intel chips has grown exponentially, more than a factor of 100 in 50 years.
In the early days, Intel management was convinced that a 16-pin package was large enough for any integrated circuit.
As a result, the Intel 4004 processor (1971) was crammed into a 16-pin package.
Intel chip designer Federico Faggin<span id="fnref:faggin"><a href="#fn:faggin">22</a></span> describes 16-pin packages as a completely silly requirement that was throwing away
performance,
but the &#34;God-given 16 pins&#34; was like a religion at Intel.
When Intel was forced to use 18 pins by the 1103 memory chip, it &#34;was like the sky had dropped from heaven&#34;
and he had &#34;never seen so many long faces at Intel.&#34;
Although the 8008 processor (1972) was able to use 18 pins, this low pin count still harmed performance by forcing pins to be used for multiple
purposes.</p>
<p>The Intel 8080 (1974) had a larger, 40-pin package that allowed it to have 16 address pins and 8 data pins.
Intel stuck with this size for the 8086, even though competitors used larger packages with more pins.<span id="fnref:ti"><a href="#fn:ti">23</a></span>
As processors became more complex, the 40-pin package became infeasible and the pin count rapidly expanded;
The 80286 processor (1982) had a 68-pin package, while the
i386 (1985) had 132 pins; the i386 needed many more pins because it had a 32-bit data bus and a 24- or 32-bit address bus.
The i486 (1989) went to 196 pins while the original Pentium had 273 pins.
Nowadays, a modern <a href="https://www.intel.com/content/www/us/en/products/sku/232167/intel-core-i913900ks-processor-36m-cache-up-to-6-00-ghz/specifications.html">Core I9 processor</a> uses the <a href="https://en.wikipedia.org/wiki/LGA_1700">FCLGA1700</a> socket with a whopping 1700 contacts.</p>
<p>Looking at the history of Intel&#39;s bus timing, the 8086&#39;s complicated memory timing goes back to the Intel 8008 processor (1972). Instruction execution in the 8008 went through
a specific sequence of timing states; each clock cycle was assigned a particular state number.
Memory accesses took three cycles:
the address was sent to memory during states T1 and T2, half of the address at a time since there were only 8 address pins.
During state T3, a data byte was either transmitted to memory or read from memory.
Instruction execution took place during T4 and T5.
State signals from the 8008 chip indicated which state it was in.</p>
<!-- http://www.bitsavers.org/components/intel/MCS8/Intel_8008_8-Bit_Parallel_Central_Processing_Unit_Rev1_Apr72.pdf -->

<p>The 8080 used an even more complicated timing system.
An instruction consisted of one to five &#34;machine cycles&#34;, numbered M1 through M5, where each machine cycle corresponded to
a memory or I/O access. Each machine cycle consisted of three to five states, T1 through T5, similar to the 8008 states.
The 8080 had 10 different types of machine cycle such as instruction fetch, memory read, memory write, stack read or write,
or I/O read or write. The status bits indicated the type of machine cycle.
The 8086 kept the T1 through T4 memory cycle. Because the 8086 decoupled instruction prefetching from execution, it no
longer had explicit M machine cycles. Instead, it used status bits to indicate 8 types of bus activity such as instruction
fetch, read data, or write I/O.</p>
<h2>Conclusions</h2>
<p>Well, address pins is another subject that I thought would be straightforward to explain but turned out to be surprisingly
complicated.
Many of the 8086&#39;s design decisions combine in the address pins: segmented addressing, backward compatibility, and the small 40-pin package.
Moreover, because memory accesses are critical to performance, Intel put a lot of effort into this circuitry.
Thus, the pin circuitry is tuned for particular purposes, especially pin A18 which is different from all the rest.</p>
<p>There is a lot more to say about memory accesses and how the 8086&#39;s Bus Interface Unit performs them.
The process is very complicated, with interacting state machines for memory operation and instruction prefetches, as well
as handling unaligned memory accesses.
I plan to write more, so 
follow me on Twitter <a href="https://twitter.com/kenshirriff">@kenshirriff</a> or <a href="https://www.righto.com/feeds/posts/default">RSS</a> for updates.
I&#39;ve also started experimenting with Mastodon recently as <a href="https://oldbytes.space/@kenshirriff">@<span data-cfemail="2348464d504b4a51514a4545634c4f47415a5746500d5053424046">[emailÂ protected]</span></a>
and Bluesky as <a href="https://staging.bsky.app/profile/righto.com">@righto.com</a> so you can follow me there too.</p>
<h2>Notes and references</h2>


</div></div>
  </body>
</html>
