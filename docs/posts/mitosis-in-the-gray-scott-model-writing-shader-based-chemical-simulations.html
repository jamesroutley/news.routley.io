<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://pierre-couy.dev/simulations/2024/09/gray-scott-shader.html">Original</a>
    <h1>Mitosis in the Gray-Scott model: writing shader-based chemical simulations</h1>
    
    <div id="readability-page-1" class="page"><article role="document" tabindex="0">
    <p>The <a href="https://groups.csail.mit.edu/mac/projects/amorphous/GrayScott/">Gray Scott Model of Reaction Diffusion</a>
is an interesting instance of <a href="https://en.wikipedia.org/wiki/Emergence">emergence</a>.
By simulating a small chemical system that involves only a few components and
reactions, complex and mesmerizing patterns appear.</p>



<p>You can interact with the simulation above by clicking on it to drop some green
and you can reset it by pressing the previous (⏮️) button.</p>

<p>Although the local rules and the underlying math are quite simple, there is some
heavy computations involved. For each time step in the simulation, we must
apply these rules to compute the concentrations of every involved component
at every possible location. Running such a simulation on a CPU would be
extremely slow. GPUs, however, are specifically built to handle large volumes of
a single small computation in parallel.</p>

<p>This post is an introduction to writing such simulations using <a href="https://www.khronos.org/registry/OpenGL/specs/es/3.0/GLSL_ES_Specification_3.00.pdf">GLSL
ES</a>,
with a <a href="https://www.shadertoy.com/view/lXXcz7">basic implementation of the Gray Scott model that runs in the browser on
Shadertoy</a> that is less than 100 lines of
code.</p>

<ol id="markdown-toc">
  <li><a href="#prerequisites" id="markdown-toc-prerequisites">Prerequisites</a>    <ol>
      <li><a href="#computing-simulations" id="markdown-toc-computing-simulations">Computing simulations</a></li>
      <li><a href="#gray-scott-model" id="markdown-toc-gray-scott-model">Gray Scott model</a>        <ol>
          <li><a href="#chemical-reactions" id="markdown-toc-chemical-reactions">Chemical reactions</a></li>
          <li><a href="#diffusion" id="markdown-toc-diffusion">Diffusion</a></li>
          <li><a href="#catalytic-reactions" id="markdown-toc-catalytic-reactions">Catalytic reactions</a></li>
          <li><a href="#auto-catalytic-reactions" id="markdown-toc-auto-catalytic-reactions">Auto-catalytic reactions</a></li>
          <li><a href="#the-gray-scott-model-itself" id="markdown-toc-the-gray-scott-model-itself">The Gray-Scott model itself</a></li>
        </ol>
      </li>
      <li><a href="#shaders" id="markdown-toc-shaders">Shaders</a>        <ol>
          <li><a href="#what-is-a-shader-" id="markdown-toc-what-is-a-shader-">What is a shader ?</a></li>
          <li><a href="#the-basics-of-writing-shaders" id="markdown-toc-the-basics-of-writing-shaders">The basics of writing shaders</a></li>
        </ol>
      </li>
    </ol>
  </li>
  <li><a href="#implementing-the-simulation" id="markdown-toc-implementing-the-simulation">Implementing the simulation</a>    <ol>
      <li><a href="#update-rules" id="markdown-toc-update-rules">Update rules</a>        <ol>
          <li><a href="#reactions" id="markdown-toc-reactions">Reactions</a>            <ol>
              <li><a href="#auto-catalytic-reactions-1" id="markdown-toc-auto-catalytic-reactions-1">Auto-catalytic reactions</a></li>
              <li><a href="#gray-scott-reactions" id="markdown-toc-gray-scott-reactions">Gray-Scott reactions</a></li>
            </ol>
          </li>
          <li><a href="#diffusion-1" id="markdown-toc-diffusion-1">Diffusion</a></li>
        </ol>
      </li>
      <li><a href="#visual-representation-of-the-system" id="markdown-toc-visual-representation-of-the-system">Visual representation of the system</a></li>
      <li><a href="#texture-buffer" id="markdown-toc-texture-buffer">Texture buffer</a></li>
      <li><a href="#simulation-shader" id="markdown-toc-simulation-shader">Simulation shader</a>        <ol>
          <li><a href="#initialization" id="markdown-toc-initialization">Initialization</a></li>
          <li><a href="#update-rules-implementation" id="markdown-toc-update-rules-implementation">Update rules implementation</a></li>
          <li><a href="#final-shader" id="markdown-toc-final-shader">Final shader</a></li>
        </ol>
      </li>
    </ol>
  </li>
  <li><a href="#playing-with-the-simulation" id="markdown-toc-playing-with-the-simulation">Playing with the simulation</a>    <ol>
      <li><a href="#interesting-emergent-behaviors" id="markdown-toc-interesting-emergent-behaviors">Interesting emergent behaviors</a></li>
      <li><a href="#hacking-on-the-code" id="markdown-toc-hacking-on-the-code">Hacking on the code</a></li>
      <li><a href="#continuous-cellular-automata" id="markdown-toc-continuous-cellular-automata">Continuous cellular automata</a></li>
    </ol>
  </li>
  <li><a href="#conclusion" id="markdown-toc-conclusion">Conclusion</a></li>
</ol>

<h2 id="prerequisites">Prerequisites</h2>

<p>In this section, I’ll try to quickly introduce some important concepts in a
short and beginner friendly way.</p>

<h3 id="computing-simulations">Computing simulations</h3>

<p>Simulating any kind of physical system involves computing what happens at any
possible location, for any possible moment in time.</p>

<p>However, the world we live our daily lives in is <em>continuous</em> in regards to space and
time : the real world is not made in a voxel grid of even the smallest size.
Likewise, even the shortest durations can still be split into smaller
durations. Worded differently, any volume larger than 0 contains an infinite
amount of points in space, and any duration larger than 0 contains an infinite amount of
points in time.</p>

<p>Computers cannot simulate a continuous world because it would require infinite
computations to handle even the tiniest fractions of space and time. To overcome
this, we will <a href="https://en.wikipedia.org/wiki/Discretization"><em>discretize</em></a> both
space and time.</p>

<p>Discretization is the action of subdividing space into a fixed grid, and time into
fixed elementary durations (<em>time steps</em>). For each cell of this grid, we will repeatedly
run a computation to determine how its content changes over one time step. This
results in an approximation of a continuous world. The smaller our grid and time
steps, the more accurate our simulation.</p>

<p>Since we will be using shaders, which is a technology from computer graphics, it
makes sense to use pixels as grid cells, and frames (as in <em>frames per second</em>)
as elementary time steps. (The simulation we will build will run in a 2D space
for easier visualization and manageable computations).</p>

<p>In the following, I’ll use \(dT\) to represent the duration of an elementary time step.
\(dX\) and \(dY\) will be the size of a single grid cell. Elementary lengths and durations
in discrete spaces are usually written with the \(\Delta\) prefix, but using
\(d\) instead will make it consistent with the code.</p>

<h3 id="gray-scott-model">Gray Scott model</h3>



<p>The Gray Scott model describes a specific family of <em>reaction-diffusion</em> systems.
More specifically, they involve an <em>auto-catalytic</em> reaction.
Let’s first define and mathematically describe these terms. This will allow us
to derive general update rules for reaction-diffusion models.
Then I will describe what makes the Gray-Scott model interesting as a specific
instance of reaction-diffusion.</p>

<h4 id="chemical-reactions">Chemical reactions</h4>

<p>A chemical <em>reaction</em> is the process in which one or more chemical species
(reactants) are consumed to produce one or more other chemical species
(products).</p>

<p>Chemical reactions are usually described with an equation that summarizes their
outcome, such as the following :</p>

<p>\(A + 2B \rightarrow 4C\)</p>

<p>In this example, the reaction that is described produces 4 molecules of the \(C\)
chemical species by consuming 1 molecule of \(A\) and 2 molecules of \(B\).</p>

<p>The speed at which a chemical reaction occurs is defined as the quantity of
molecules that get transformed in a given amount of time.
Every reactant (molecule that is listed on the left side of the equation) need to
meet at the same time and spot for the reaction to happen. Since the probability
of finding a molecule at any given spot is proportional to its concentration,
the speed of the reaction is proportional to the concentration of every
reactant.</p>

<p>The speed of the example reaction above is then :</p>

<p>\(speed = k*[A]*[B]*[B]\)</p>

<p>where \([X]\) is the concentration of molecule \(X\), and \(k\) is a positive constant
we’ll call the “speed constant of the reaction”. Since 2 molecules of \(B\) are
required at the input of the reaction, it needs to appear twice in the formula
for the reaction speed.</p>

<h4 id="diffusion">Diffusion</h4>

<p>Diffusion is the process through which certain quantities, such as chemical
species concentrations, tend to spread out and homogenize. It can be easily
observed by putting a drop of ink into a glass of water.</p>

<p>One way to think about it in the context of the simulation is that each cell of
the 2D grid is slowly and constantly leaking a fixed proportion of its content
to its neighbors. At the same time, it’s receiving content leaked from its
neighbouring cells. We will write \(\tau_X\) as this fixed proportion for chemical
species \(X\) that leaks over a base unit of time, and we will call it the diffusion rate.</p>

<p>Let’s consider two simple cases to make sure this is a reasonable way to model
diffusion :</p>

<ul>
  <li>If the quantity is homogeneous over the grid (the same in every cell), the outgoing
amount will be the same as the incoming one, resulting in the quantity staying
homogeneous.</li>
  <li>On the other hand, if a cell \(C_1\) contains more than a neighbor cell \(C_2\), then
\(C_1\) will leak a larger amount to its neighbors than \(C_2\). This will cause
the quantity inside \(C_1\) to decrease, while the quantity inside \(C_2\) will
increase. In the end, quantities inside \(C_1\) and \(C_2\) are closer together
than they were at the start, which is consistent for a process that homogenizes
quantities.</li>
</ul>

<h4 id="catalytic-reactions">Catalytic reactions</h4>

<p>Some chemical reactions require a specific chemical species, which does not
seem to get consumed by the reaction, to be present for the reaction to
happen. Let’s consider a very simple reaction where a species \(A\) transforms to
species \(B\) :</p>

<p>\(A \rightarrow B\)</p>

<p>If this reaction only happens when a third species \(C\) is present, we say that
\(C\) is a <em>catalyst</em> for this reaction, and the reaction is said to be
<em>catalytic</em>. While the outcome of the reaction does
not affect the concentration in species \(C\), we can still make it appear in
the reaction’s equation to account for its role. We do this by making it appear
on both sides of the arrow :</p>

<p>\(A + C \rightarrow B + C\)</p>

<p>This changes the formula for speed of the reaction to :</p>

<p>\(speed = k * [A] * [C]\)</p>

<p>If \(C\) is absent, then \([C]=0\), making the speed 0 as well. This
is consistent with \(C\) being a catalyst for the reaction. This also implies that
while the concentration in \(C\) does not change during the reaction, the speed
of the reaction is proportional to the concentration of species \(C\).</p>

<h4 id="auto-catalytic-reactions">Auto-catalytic reactions</h4>

<p>Among the family of catalytic reactions, there are special cases where the
catalyst is also a product of the reaction : the reaction requires the catalyst
to be present in order to happen and produces more of the catalyst in turn.
Such reactions are called <a href="https://en.wikipedia.org/wiki/Autocatalysis"><em>auto-catalytic</em>
reactions</a>. The equation still
makes the catalyst appear on both sides, but in this case, the number in front
of it will be larger on the right side, indicating an increase in concentration
for the catalyst. For instance :</p>

<p>\(2A + C \rightarrow 2C\)</p>

<p>Autocatalytic reactions are of special interest because of their role in biology and
their <a href="https://en.wikipedia.org/wiki/Abiogenesis">supposed role in the origin of life</a>.</p>

<h4 id="the-gray-scott-model-itself">The Gray-Scott model itself</h4>

<p>I previously referred to the Gray-Scott model as a “Reaction-Diffusion model for
a specific auto-catalytic reaction”. This means that in this model, both
diffusion and an auto-catalytic reaction will happen simultaneously. The main
reaction involves two chemical species \(A\) and \(B\) which react according to
the following equation :</p>

<p>\(A + 2B \rightarrow 3B\) with speed constant \(S\)</p>

<p>We also consider two hypothetical reactions :</p>

<ul>
  <li>\(\emptyset \rightarrow A\) which constantly adds species \(A\) at rate \(F\)</li>
  <li>\(B \rightarrow \emptyset\) which removes \(B\) with speed constant \(K\)</li>
</ul>

<p>We call \(F\) the <em>feed rate</em> and \(K\) is the <em>kill rate</em>. If we look at the
main reaction as \(A\) being used as food by \(B\), \(F\) is indeed the rate at
which we add food to the system, and \(K\) is the rate at which we remove – or
kill – \(B\).</p>

<p>Let’s also add a process that removes a fixed fraction of \(A\) and \(B\) from
every cell at each time step. We will use the value of the feed rate as a speed
constant for this process.</p>

<p>Diffusion, occurring concurrently with these reactions, is crucial for complex
patterns to emerge. It will allow \(B\) to
propagate through space, starting the autocatalytic reaction in new grid cells
which did not previously contain any of the chemical \(B\).
Diffusion will also let \(A\) flow from regions where it is more abundant to
regions where it is rarer (because it was consumed by \(B\)).</p>

<p>By tuning the relative values of \(S\), \(F\), \(K\), \(\tau_A\) and \(\tau_B\),
different kind of complex patterns can emerge.</p>

<h3 id="shaders">Shaders</h3>

<p>Shaders are a specific kind of computer programs that are designed to run on a
Graphical Processing Unit (GPU). They are generally written in a dedicated
programming language and are mostly used to control how a 3D world is rendered
to a 2D screen.</p>

<p>Since <a href="https://www.youtube.com/watch?v=0ifChJ0nJfM">good resources</a> on
<a href="https://thebookofshaders.com/">how to start writing shaders</a> already exist, this
introduction will focus on the most relevant parts for implementing a Gray-Scott
simulation.</p>

<h4 id="what-is-a-shader-">What is a shader ?</h4>

<p>Most shaders come in one of two flavors : <em>vertex shaders</em> and <em>fragment
shaders</em>. Rendering a 3D world to a 2D screen roughly involves two steps :</p>

<ul>
  <li>Convert coordinates from the 3D space to a position on screen. This
involves performing a <a href="https://en.wikipedia.org/wiki/3D_projection">projection</a>
depending on the position of the camera. Vertex shaders perform this step</li>
  <li>Determine the color of each fragment (pixel) on the screen. This involves
running computations on the output of the previous step for every pixel of the
screen, which is what fragment shaders are made for.</li>
</ul>

<p>Running a computation for every pixel should remind you of how we derived update
rules that should be applied to every cell of a grid. By implementing such a
simulation as a fragment shader, we will take advantage of the main strength of
GPUs : parallelization.</p>

<p>While there surely exists a better way to run simulations on the GPU, the amount
of resources dedicated to learning computer graphics made it a lot easier (to
me) to start writing and running code on the GPU. There are even web-based
editors (such as <a href="https://www.shadertoy.com/">Shadertoy</a> which I used for this)
that let you compile and run your shaders in the browser without having to
install anything. As a bonus, this is agnostic of the GPU brand (by contrast with Cuda
which is Nvidia specific, or ROCm for AMD).</p>

<h4 id="the-basics-of-writing-shaders">The basics of writing shaders</h4>

<p>As I am not a shader expert, I will focus on how to get one running on
Shadertoy. My understanding is that there is a lot of boilerplate that Shadertoy
handles and that it is the most straightforward way to begin writing shaders.</p>

<p>GLSL, like most programming languages, uses variables, functions, conditionals
and loops.
Assuming you already used a few different programming languages, you will
probably be comfortable with reading and tinkering with shader code. However,
there are some specificities of <em>OpenGL Shading Language</em> (GLSL) that may surprise you.</p>

<p>The most important thing to understand is that we are going to write a function
that will be run on the GPU for every pixel of every frame. This function will
take the coordinates of a pixel as an input, and will output the color that
should be used for this pixel. For our simulation, this means that this function
will be in charge of simulating one grid cell for one time step. It will then be
repeatedly executed, resulting in the full animated simulation.</p>

<p>Using Shadertoy, this function will look like the following :</p>

<div><div><pre><code><span>void</span> <span>mainImage</span><span>(</span> <span>out</span> <span>vec4</span> <span>fragColor</span><span>,</span> <span>in</span> <span>vec2</span> <span>fragCoord</span> <span>)</span>
<span>{</span>
    <span>// Normalized pixel coordinates (from 0 to 1)</span>
    <span>vec2</span> <span>uv</span> <span>=</span> <span>fragCoord</span><span>/</span><span>iResolution</span><span>.</span><span>xy</span><span>;</span>

    <span>// Time and space varying pixel color</span>
    <span>vec3</span> <span>col</span> <span>=</span> <span>0</span><span>.</span><span>5</span> <span>+</span> <span>0</span><span>.</span><span>5</span><span>*</span><span>cos</span><span>(</span><span>iTime</span><span>+</span><span>uv</span><span>.</span><span>xyx</span><span>+</span><span>vec3</span><span>(</span><span>0</span><span>,</span><span>2</span><span>,</span><span>4</span><span>));</span>

    <span>// Output to screen</span>
    <span>fragColor</span> <span>=</span> <span>vec4</span><span>(</span><span>col</span><span>,</span><span>1</span><span>.</span><span>0</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<p>There are a few things to notice already. First, this function does not return
anything. Instead, the pixel’s color is output by setting the value of
<code>fragColor</code>, which is defined as an <code>out</code> parameter of the function.</p>

<p>You may also notice the use of variables which were not previously defined, such as
<code>iResolution</code> or <code>iTime</code>. These variables are called <em>uniforms</em>, and their
values are provided from the outside of the shader. This is part of the
boilerplate that Shadertoy handles for us.</p>

<p>Shaders usually make heavy use of vectors, which can have 2, 3 or 4 dimensions.
The sample code above features the <code>vec*</code> types for all three sizes of vectors.
GLSL comes with a convenient syntax for picking and rearranging vector
components. If we have <code>x = vec4(0.0, 0.2, 0.4, 0.6)</code>, then <code>x.xyy</code> will be
equal to <code>vec3(0.0, 0.2, 0.2)</code>. You can reference each vector coordinate by <code>x</code>,
<code>y</code>, <code>z</code> and <code>w</code> respectively. Since vectors are also used to represent colors,
the symbols <code>r</code>, <code>g</code>, <code>b</code> and <code>a</code> can also be used.</p>

<h2 id="implementing-the-simulation">Implementing the simulation</h2>

<h3 id="update-rules">Update rules</h3>

<p>This is the most math-heavy section of the article, in which we derive the
update rules for the simulation.</p>

<h4 id="reactions">Reactions</h4>

<p>In the general case, when simulating the reaction \(A + 2B \rightarrow 4C\) for a single time step, the
concentrations of \(A\), \(B\) and \(C\) need to be updated in the following way
for every \((x,y)\) cell in the simulation :</p>

<p>
\([A](t+dT,x,y) = [A](t,x,y) - speed(t,x,y)*dT\)
\([B](t+dT,x,y) = [B](t,x,y) - 2*speed(t,x,y)*dT\)
\([C](t+dT,x,y) = [C](t,x,y) + 4*speed(t,x,y)*dT\)
</p>

<p>Replacing \(speed(t,x,y)\) with its expression from above yields :</p>

<p>
\([A](t+dT,x,y) = [A](t,x,y) - k*[A](t,x,y)*[B](t,x,y)^2*dT\)
\([B](t+dT,x,y) = [B](t,x,y) - 2*k*[A](t,x,y)*[B](t,x,y)^2*dT\)
\([C](t+dT,x,y) = [C](t,x,y) + 4*k*[A](t,x,y)*[B](t,x,y)^2*dT\)
</p>

<p>where \( dT \) is the duration of a time step. Notice that the numbers in
front of \(speed(t)\) come from the quantities in the equation that summarizes
the reaction.</p>

<p>Looking closely at this update rule, you may notice that chemical reactions
happen independently in each cell. This can be evidenced by the fact that the
formula for updating cell \((x,y)\) only involves coordinates \((x,y)\) and
ignores concentrations in neighboring cells (such as \((x+dX,y)\)).</p>

<h5 id="auto-catalytic-reactions-1">Auto-catalytic reactions</h5>

<p>Consider the following auto-catalytic reaction :</p>

<p>
\(2A + C \rightarrow 2C\)
</p>

<p>The update rule for this reaction is then</p>

<p>
\([A](t+dT,x,y) = [A](t,x,y) - 2*k*[A](t,x,y)^2*[C](t,x,y)*dT\)
\([C](t+dT,x,y) = [C](t,x,y) + (2-1)*k*[A](t,x,y)^2*[C](t,x,y)*dT\)
</p>

<h5 id="gray-scott-reactions">Gray-Scott reactions</h5>

<p>By combining the update rules for all processes (which consists in
successively applying them) previously described, we get the following
update rules for the “reactions” part of our Gray-Scott model :</p>

<p>
\([A](t+dT) = [A](t) + (F - S * [A](t) * [B](t)^2 - F * [A](t)) * dT\)
\([B](t+dT) = [B](t) + (S * [A](t) * [B](t)^2 - K * [B](t) - F * [B](t)) * dT\)
</p>

<p>which can be rearranged as :</p>

<p>
\([A](t+dT) = [A](t) + (F * (1-[A](t)) - S * [A](t) * [B](t)^2) * dT\)
\([B](t+dT) = [B](t) + (S * [A](t) * [B](t)^2 - (K+F) * [B](t)) * dT\)
</p>

<h4 id="diffusion-1">Diffusion</h4>

<p>We can write the following equations for a “two-cell” system :</p>

<ul>
  <li>The amount leaked out of a cell \(C_y\) over duration \(dT\)
is \(out_X(t,C_y) = \tau * [X](t,C_y) * dT\).</li>
  <li>Anything that leaks out of a cell \(C_y\) gets inside the other cell \(C_z\) :
\(in_X(t,C_z) = out_X(t,C_y)\)</li>
  <li>The variation of quantity in a cell \(C_y\) is the difference between the quantity
that leaked in and the quantity that leaked out :
\([X](t+dT,C_y) - [X](t,C_y) = in_X(t,C_y) - out_X(t,C_y)\)
for \(y=1\) and \(y=2\)</li>
</ul>

<p>By rearranging these equations, we get the following update rule for diffusion :</p>

<p>
\([X](t+dT,C_y) = [X](t,C_y) + \tau_X * [X](t,C_z) * dT - \tau_X * [X](t,C_y)) * dT\)
\([X](t+dT,C_y) = (1-\tau_X * dT) * [X](t,C_y) + \tau_X * dT * [X](t,C_z)\)
</p>

<p>with \((y,z) = (1,2)\) or \((y,z) = (2,1)\).</p>

<p>This update rule can be generalized from a two-cell system to the 2D grid by
replacing \([X](t,C_z)\) by a (possibly weighted) average of the concentrations
in the neighbor cells.</p>

<h3 id="visual-representation-of-the-system">Visual representation of the system</h3>

<p>Before starting to write code, let’s pick a way to display the state of the
simulation. Since we only need to represent the concentrations of two chemical
species over a 2D system, the full state of the system can be represented, at
any given time, with a picture. Each pixel in this picture is a cell in the
simulated grid, and the red and green channels of each pixel are respectively
proportional to the concentrations of species \(A\) and \(C\) in the corresponding
grid cells.</p>

<h3 id="texture-buffer">Texture buffer</h3>

<p>In order to run the simulation, we will need to store the current state of the
grid (the concentration of each chemical species for each cell) at a location
we are able to read during a later iteration. This is required in order to apply
the update rules, which use the state at time \(t\) to compute a new state at time
\(t+dT\).</p>

<p>To achieve this, we will use a secondary shader that will get rendered to a <em>texture buffer</em>. The
main shader will simply display this texture to the screen, while the secondary
shader will be in charge of actually running the simulation.</p>

<p>To create the secondary shader, click on the “+” in the tab bar of the editor and
select “Buffer A”. This will create a new tab in which you can write another
<code>mainImage(...)</code> function. We will call it the <em>simulation shader</em>.</p>

<p>Make sure this both shaders have access to Buffer A’s
contents from the previous iteration : map it to <code>iChannel0</code> in both the
“Image” and “Buffer A” tabs.</p>

<p>The output of the <em>simulation</em> shader from the previous time step will be available
to both shaders as the <em>uniform</em> <code>iChannel0</code>, from which we can retrieve the
value of a pixel using <code>texture(iChannel0, vec2(x, y))</code>, where <code>x</code> and <code>y</code> are
the coordinates of the pixel we’re interested in. Note that both these coordinates
are floats with values between 0.0 and 1.0, no matter the size in pixels of the texture.</p>

<p>Since the main shader is only responsible for displaying the contents of
<code>iChannel0</code> to the screen, we can already write the full code for it and focus
on the actual simulation later :</p>

<div><div><pre><code><span>void</span> <span>mainImage</span><span>(</span> <span>out</span> <span>vec4</span> <span>fragColor</span><span>,</span> <span>in</span> <span>vec2</span> <span>fragCoord</span> <span>)</span>
<span>{</span>
    <span>// Normalized pixel coordinates (from 0 to 1)</span>
    <span>vec2</span> <span>uv</span> <span>=</span> <span>fragCoord</span><span>/</span><span>iResolution</span><span>.</span><span>xy</span><span>;</span>

    <span>// Output to screen</span>
    <span>fragColor</span> <span>=</span> <span>texture</span><span>(</span><span>iChannel0</span><span>,</span> <span>uv</span><span>)</span> <span>*</span> <span>vec4</span><span>(</span><span>0</span><span>.</span><span>5</span><span>,</span><span>2</span><span>.</span><span>0</span><span>,</span><span>0</span><span>.,</span><span>1</span><span>.);</span>
<span>}</span>
</code></pre></div></div>

<p>This code simply converts <code>fragCoord</code> (which contains coordinates in pixel
units) to <code>uv</code> (coordinates between 0 and 1). It then samples <code>iChannel0</code> at the
<code>uv</code> coordinates. Finally, it scales the red channel by <code>0.5</code> and the green
channel by <code>2.0</code>, which will make it easier to visually interpret the
simulation.</p>

<h3 id="simulation-shader">Simulation shader</h3>

<p>This shader will repeatedly apply the update rules to every pixel in the
<code>iChannel0</code> texture buffer, effectively running the simulation. It consists of a
<code>mainImage(...)</code> function, just like the main shader.</p>

<h4 id="initialization">Initialization</h4>

<p>Let’s start with defining some variables we will need and setting an initial
state for the simulation.</p>

<div><div><pre><code><span>void</span> <span>mainImage</span><span>(</span> <span>out</span> <span>vec4</span> <span>fragColor</span><span>,</span> <span>in</span> <span>vec2</span> <span>fragCoord</span> <span>)</span>
<span>{</span>
    <span>float</span> <span>dT</span> <span>=</span> <span>2</span><span>.</span><span>0</span><span>;</span> <span>//The lower this is, the more stable (but the slower) the simulation is. Weird stuff starts to happen from 3.0</span>
    <span>vec4</span> <span>TAU</span> <span>=</span> <span>vec4</span><span>(</span><span>0</span><span>.</span><span>4</span><span>,</span> <span>0</span><span>.</span><span>2</span><span>,</span> <span>0</span><span>.,</span> <span>0</span><span>.);</span>  <span>// Diffusion rate of components</span>
    <span>float</span> <span>k1</span> <span>=</span> <span>1</span><span>.;</span>  <span>// Speed constant of the main reaction</span>
    <span>float</span> <span>k2</span> <span>=</span> <span>0</span><span>.</span><span>057</span><span>;</span> <span>// Speed constant of the &#34;kill&#34; reaction</span>
    <span>float</span> <span>k3</span> <span>=</span> <span>0</span><span>.</span><span>01</span><span>95</span><span>;</span> <span>// Speed constant of the &#34;feed&#34; reaction</span>
    
    <span>vec2</span> <span>pixelSize</span> <span>=</span> <span>1</span><span>.</span> <span>/</span> <span>iResolution</span><span>.</span><span>xy</span><span>;</span>
    <span>vec2</span> <span>uv</span> <span>=</span> <span>fragCoord</span><span>.</span><span>xy</span> <span>*</span> <span>pixelSize</span><span>;</span>
    
    <span>vec2</span> <span>h</span> <span>=</span> <span>vec2</span><span>(</span><span>pixelSize</span><span>.</span><span>x</span><span>,</span> <span>0</span><span>.);</span>
    <span>vec2</span> <span>v</span> <span>=</span> <span>vec2</span><span>(</span><span>0</span><span>.,</span> <span>pixelSize</span><span>.</span><span>y</span><span>);</span>
    
    <span>if</span> <span>(</span><span>iFrame</span> <span>&lt;</span> <span>10</span><span>)</span> <span>{</span> <span>// Init</span>
        <span>fragColor</span> <span>=</span> <span>vec4</span><span>(</span><span>1</span><span>.,</span> <span>0</span><span>.</span><span>0</span><span>,</span> <span>0</span><span>.</span><span>0</span><span>,</span> <span>1</span><span>.</span><span>0</span><span>);</span> <span>// Default initial value</span>
        <span>if</span> <span>(</span> <span>length</span><span>(</span><span>uv</span> <span>-</span> <span>vec2</span><span>(.</span><span>5</span><span>,.</span><span>5</span><span>))</span> <span>&lt;</span> <span>length</span><span>(</span><span>1</span><span>.</span><span>*</span><span>pixelSize</span><span>)</span> <span>)</span> <span>{</span>  <span>// If at center of canvas</span>
            <span>fragColor</span><span>+=</span> <span>vec4</span><span>(</span><span>0</span><span>.,</span> <span>0</span><span>.</span><span>2</span><span>,</span> <span>0</span><span>.,</span> <span>1</span><span>.);</span>  <span>// Seed-in some catalyst</span>
        <span>}</span>
    <span>}</span>
    <span>else</span> <span>{</span>  <span>// Simulation</span>
        <span>// Apply the update rules</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>The first block of definitions are the constants we will use in the update
rules for the reactions and for diffusion :</p>

<ul>
  <li><code>dT</code> is the duration that will be simulated at every step</li>
  <li><code>TAU</code> (\(\tau\)) is a vector that holds the diffusion rates of \(A\) and \(C\)
in its first and second components.</li>
  <li><code>k1</code>, <code>k2</code> and <code>k3</code> are the speed constants for the 3 chemical reactions that take
place in the system</li>
</ul>

<p>All these values have been cherry picked to produce an interesting result.
Later, we’ll see that you can get results that look very different by tuning
them.</p>

<p>The second block of declarations are useful for converting between coordinates
in pixel space and <em>UV</em> coordinates (floats between 0.0 and 1.0).</p>

<p><code>h</code> and <code>v</code> are vectors in UV coordinates that are 1 pixel long, respectively
horizontally and vertically. This will be useful for computing the update rule
for diffusion, which involves retrieving the values from the neighboring pixels.</p>

<p>The conditional block handles the initialization of the simulation by outputting
a fixed state for the first 10 frames. This initial state consists of only \(A\)
everywhere, except for a small radius in the middle where we add a small amount of
the catalyst \(C\).</p>

<p>After these 10 initial frames, all subsequent executions of the
shader will go through the <code>else</code> block, in which we will implement the actual
update rules.</p>

<h4 id="update-rules-implementation">Update rules implementation</h4>

<p>Here is the full contents of the <code>else</code> block :</p>

<div><div><pre><code><span>vec4</span> <span>col</span> <span>=</span> <span>texture</span><span>(</span><span>iChannel0</span><span>,</span> <span>uv</span><span>);</span>

<span>vec4</span> <span>inboundFlow</span> <span>=</span> <span>TAU</span> <span>/</span> <span>8</span><span>.</span> <span>*</span> <span>(</span>   <span>// Algebric inbound diffusion flow</span>
    <span>texture</span><span>(</span><span>iChannel0</span><span>,</span> <span>uv</span> <span>+</span> <span>h</span><span>)</span> <span>+</span>  <span>// Concentrations of neighbor to the right</span>
    <span>texture</span><span>(</span><span>iChannel0</span><span>,</span> <span>uv</span> <span>-</span> <span>h</span><span>)</span> <span>+</span>  <span>// Concentrations of neighbor to the left</span>
    <span>texture</span><span>(</span><span>iChannel0</span><span>,</span> <span>uv</span> <span>+</span> <span>v</span><span>)</span> <span>+</span>  <span>// ....</span>
    <span>texture</span><span>(</span><span>iChannel0</span><span>,</span> <span>uv</span> <span>-</span> <span>v</span><span>)</span> <span>+</span>
    <span>1</span><span>.</span><span>/</span><span>1</span><span>.</span><span>41</span><span>*</span><span>(</span>  <span>// diagonal neighbors are at a distance of sqrt(2) ~= 1.41</span>
        <span>texture</span><span>(</span><span>iChannel0</span><span>,</span> <span>uv</span> <span>+</span> <span>h</span> <span>+</span> <span>v</span><span>)</span> <span>+</span>
        <span>texture</span><span>(</span><span>iChannel0</span><span>,</span> <span>uv</span> <span>+</span> <span>h</span> <span>-</span> <span>v</span><span>)</span> <span>+</span>
        <span>texture</span><span>(</span><span>iChannel0</span><span>,</span> <span>uv</span> <span>-</span> <span>h</span> <span>+</span> <span>v</span><span>)</span> <span>+</span>
        <span>texture</span><span>(</span><span>iChannel0</span><span>,</span> <span>uv</span> <span>-</span> <span>h</span> <span>-</span> <span>v</span><span>)</span>
        <span>)</span> <span>-</span>
    <span>4</span><span>.</span><span>*</span><span>(</span><span>1</span><span>.</span><span>+</span><span>1</span><span>.</span><span>/</span><span>1</span><span>.</span><span>41</span><span>)</span><span>*</span><span>col</span>
<span>);</span>

<span>// Reaction : X + 2X -&gt; 3X</span>
<span>float</span> <span>reactionSpeed1</span> <span>=</span> <span>k1</span><span>*</span><span>col</span><span>.</span><span>x</span><span>*</span><span>col</span><span>.</span><span>y</span><span>*</span><span>col</span><span>.</span><span>y</span><span>;</span>
<span>// Concentration variations due to reactions</span>
<span>vec4</span> <span>dCol</span> <span>=</span> <span>vec4</span><span>(</span><span>-</span><span>reactionSpeed1</span> <span>+</span> <span>k3</span><span>*</span><span>(</span><span>1</span><span>.</span><span>-</span><span>col</span><span>.</span><span>x</span><span>),</span> <span>reactionSpeed1</span> <span>-</span> <span>(</span><span>k2</span><span>+</span><span>k3</span><span>)</span><span>*</span><span>col</span><span>.</span><span>y</span><span>,</span> <span>0</span><span>.,</span> <span>0</span><span>.);</span>

<span>fragColor</span> <span>=</span> <span>clamp</span><span>(</span><span>col</span><span>+</span><span>dT</span><span>*</span><span>(</span><span>dCol</span><span>+</span><span>inboundFlow</span><span>),</span> <span>0</span><span>.,</span> <span>1</span><span>.);</span>
</code></pre></div></div>

<p>This can be broken up into 4 steps :</p>

<ol>
  <li>Retrieve the concentrations at the start of the time step from <code>iChannel0</code>
and store it inside <code>col</code></li>
  <li>Compute the variations of concentrations due to diffusion and store the
result inside <code>inboundFlow</code></li>
  <li>Compute the variations of concentrations due to all chemical reactions and
store the result inside <code>dCol</code></li>
  <li><code>dCol</code> and <code>inboundFlow</code> are scaled by <code>dT</code> before being added to the
concentrations at the start of the time step, which gives us the
concentrations at the end of the time step. This is then clamped between 0.0
and 1.0 before being used as the output of the shader</li>
</ol>

<p>Every time a frame is rendered, this shader is executed once for every pixel of
the canvas, resulting in a full update of the simulation. Since this shader’s
output is <code>iChannel0</code>, this means that on each frame (iteration of the
simulation), <code>col</code> will hold the result from the previous time step.</p>

<h4 id="final-shader">Final shader</h4>

<p>We can now put everything together to obtain <a href="https://www.shadertoy.com/view/lXXcz7">the code that runs the simulation
in this article’s introduction</a>. There
are a few additions to the code I just presented here, which make the shader
interactive :</p>

<ul>
  <li>The <code>iMouse</code> uniform lets us add some catalyst anywhere by clicking on the simulation :</li>
</ul>

<div><div><pre><code><span>// The following goes at the beginning of the `else` block</span>
<span>vec4</span> <span>new</span> <span>=</span> <span>vec4</span><span>(</span><span>0</span><span>.</span><span>0</span><span>,</span> <span>0</span><span>.</span><span>0</span><span>,</span> <span>0</span><span>.</span><span>0</span><span>,</span> <span>0</span><span>.</span><span>0</span><span>);</span>
<span>if</span> <span>(</span> <span>iMouse</span><span>.</span><span>z</span> <span>&gt;</span> <span>0</span><span>.</span><span>5</span> <span>&amp;&amp;</span> <span>length</span><span>((</span><span>fragCoord</span> <span>-</span> <span>iMouse</span><span>.</span><span>xy</span><span>)</span><span>*</span><span>pixelSize</span><span>)</span> <span>&lt;</span> <span>length</span><span>(</span><span>1</span><span>.</span><span>*</span><span>pixelSize</span><span>)</span> <span>)</span> <span>{</span>
    <span>// If the mouse button is pressed AND the pixel we&#39;re drawing is at the mouse&#39;s location</span>
    <span>new</span> <span>=</span> <span>vec4</span><span>(</span><span>0</span><span>.,</span> <span>0</span><span>.</span><span>2</span><span>,</span> <span>0</span><span>.,</span> <span>1</span><span>.);</span>
<span>}</span>

<span>// Contents of the `else` block from the previous section</span>

<span>// The final line of the `else` block is now :</span>
<span>fragColor</span> <span>=</span> <span>clamp</span><span>(</span><span>col</span><span>+</span><span>new</span><span>+</span><span>dT</span><span>*</span><span>(</span><span>dCol</span><span>+</span><span>inboundFlow</span><span>),</span> <span>0</span><span>.,</span> <span>1</span><span>.);</span> <span>// Same as before, but we add `new`</span>
</code></pre></div></div>

<ul>
  <li>We map the keyboard state to the uniform <code>iChannel1</code> in Buffer A and reset the simulation
when the space bar is pressed. The keyboard state is represented as a 2D
texture in which the current state of the spacebar can be read from
the red channel at coordinates <code>(0.126953125, 0.25)</code> :</li>
</ul>

<div><div><pre><code><span>// Replace the `if(...)` line with :</span>
<span>bool</span> <span>spacePressed</span> <span>=</span> <span>texture</span><span>(</span><span>iChannel1</span><span>,</span>  <span>vec2</span><span>(</span><span>0</span><span>.</span><span>126953125</span><span>,</span> <span>.</span><span>25</span><span>)).</span><span>x</span> <span>&gt;</span> <span>0</span><span>.;</span>
<span>if</span> <span>(</span><span>iFrame</span> <span>&lt;</span> <span>10</span> <span>||</span> <span>spacePressed</span><span>)</span> <span>{</span> 
</code></pre></div></div>

<p>I also moved the simulation’s parameters to the “Common” tab in Shadertoy, with
the goal of making it easier to tune these parameters and observe the wide
range of behaviors that can emerge from this model.</p>

<h2 id="playing-with-the-simulation">Playing with the simulation</h2>

<h3 id="interesting-emergent-behaviors">Interesting emergent behaviors</h3>

<p>Some smart people have already studied the Gray-Scott model in-depth. And
described the behaviors for some interesting parameter values. Most
prominently :</p>

<ul>
  <li><a href="http://mrob.com/pub/comp/xmorphia/index.html">Robert Munafo hosts a methodic and exhaustive exploration of the Gray-Scott model’s
parameter space</a>. His website
also features a gallery of videos for interesting parameter values.</li>
  <li><a href="https://karlsims.com/rd.html">Karl Sims’ tutorial</a> features some visual
explanations.</li>
  <li><a href="https://itp.uni-frankfurt.de/~gros/StudentProjects/Projects_2020/projekt_schulz_kaefer/">Katharina Käfer and Mirjam Schulz’s
page</a>
features an interesting <a href="https://itp.uni-frankfurt.de/~gros/StudentProjects/Projects_2020/projekt_schulz_kaefer/#theory">“Theory”
section</a>
that includes some discussion about the model’s fixed points (conditions over
which concentrations in both chemical species in a cell remain constant over time).</li>
</ul>

<p>Their work has allowed me to quickly try out speed-constant values which produce
interesting results. The video below showcases a few set of well-known parameters.</p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/rFwKSS5C3e8?si=rrxew4JtzG42cgNC" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay;
clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe>

<p>I strongly encourage you to <a href="https://www.shadertoy.com/view/lXXcz7">check it out on Shadertoy</a>.
Experiment with different values for the speed constants <code>k2</code> and <code>k3</code> (in the “Common” tab)
and see how adding some catalyst (green species) with your mouse changes the
patterns.</p>

<h3 id="hacking-on-the-code">Hacking on the code</h3>

<p>Beyond simply tuning the values of <code>k2</code> (\(K\)) and <code>k3</code> (\(F\)), there are a few easy things to try 
(use the “Fork” button to save your changes to a new shader) :</p>

<ul>
  <li>Change the initial conditions of the simulation and see how they influence the emerging behaviors for some given parameter values. The easiest way to do this is to change the source of <code>iChannel2</code> in the “Buffer A” tab and change the <code>channel2Init</code> parameter in the “Common” tab</li>
  <li>Add new ways to interact with the simulation, such as :
    <ul>
      <li>A keyboard toggle for adding/removing the catalyst with the mouse</li>
      <li>A key to switch between the catalyst (green) and the food (red) when using the mouse</li>
      <li>A key to pause the simulation while maintaining the ability to interact with it</li>
      <li>Different keys reset the simulation with a different initial state</li>
    </ul>
  </li>
  <li>Control the scale of the simulation by expanding the diffusion neighborhood</li>
  <li>Use some <a href="https://lygia.xyz/generative">generative noise</a> to continuously add some perturbations to the simulation</li>
  <li>Try to reproduce the last piece of footage from the video (parameter space visualization).
This only requires setting <code>k2</code> and <code>k3</code> to be proportional to the x and y coordinates. If you go one step
further, you can even zoom into the most interesting regions of the parameter space.</li>
</ul>

<h3 id="continuous-cellular-automata">Continuous cellular automata</h3>

<p>You may have heard of <a href="https://conwaylife.com/">Conway’s game of life</a> in which a
grid is repeatedly updated according to simple local rules in a binary way (the cells
are either ON or OFF). This is an instance of a <a href="https://en.wikipedia.org/wiki/Cellular_automaton">cellular automaton</a></p>

<p><img src="https://pierre-couy.dev/media/conway-glider-generator.gif" alt="A glider generator in Conway&#39;s game of life"/></p>

<p>Even though Conway’s game of life is much simpler than the reaction-diffusion
model, complex patterns can still emerge from it such as the one in the
animation above. Some people have even built logic gates in Conway’s game of life
and used them to build <a href="https://www.youtube.com/watch?v=QtJ77qsLrpw">Game of life inside Game of
life</a></p>

<p>The Gray-Scott model can be seen as a continuous extension to the discrete version :
instead of each cell’s state being represented with a value from a finite set of
possible values, each cell’s state is now represented as two numbers from a
continuum of possible values.</p>

<p>Other continuous cellular automata include the
<a href="https://chakazul.github.io/lenia.html#Code">Lenia</a> family and <a href="https://sites.google.com/view/flowlenia/">Flow
Lenia</a> which adds constraints
enforcing some conservation of mass in the system. These kinds of models are
actually used by scientific researchers to explore possible conditions for the
emergence of proto-life.</p>

<p>Taking inspiration from the implementation I wrote for the Gray-Scott model, it
should be possible to run a rudimentary version of other continuous cellular
automata.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Although this can be considered an unorthodox use of shaders, this has been a
great way to introduce myself to GPU programming. Being an implementation of
concepts I’m already familiar with, I think this was much easier than dealing
with the complex linear algebra involved in 3D rendering.</p>

<p>I hope to explore more systems that exhibit emergence in future posts, as I find
this field really fascinating.</p>

</article></div>
  </body>
</html>
