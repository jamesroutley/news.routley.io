<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://www.ulisp.com/show?4Y20">Original</a>
    <h1>A Lisp compiler to RISC-V written in Lisp</h1>
    
    <div id="readability-page-1" class="page"><div id="content">

<p>11th October 2024</p>
<p>This is a simple experimental Lisp compiler, written in uLisp, that will compile a Lisp function into RISC-V machine code. You can run the compiler on the RISC-V core of a Raspberry Pi Pico 2 (or another RP2350-based board):</p>
<p><img src="https://words.filippo.io/pictures/3j/raspberrypipico2.jpg" alt="RaspberryPiPico2.jpg" width="600" height="275"/></p>
<p>It&#39;s based on my earlier project <a href="https://words.filippo.io/show?4W2I">A Lisp compiler to ARM written in Lisp</a>.</p>
<h4><span>Introduction</span></h4>
<p>When I added the facility of executing machine code to uLisp I had in mind the eventual goal of being able to compile uLisp functions into machine code, and this is a first step in that direction.</p>
<p>The nice thing about compiling Lisp is that you don&#39;t have to write a tokeniser or parser, because Lisp programs are already in a consistent structure that can be processed by another Lisp program.</p>
<p>The compiler program is written in the subset of Common Lisp supported by uLisp, and will run on the RISC-V core of a RP2350-based board; I used a Raspberry Pi Pico 2. You can also run it using Common Lisp on a laptop or desktop computer, and display the code it generates, but of course you won&#39;t be able to run the RISC-V machine code because Common Lisp doesn&#39;t have uLisp&#39;s <strong>defcode</strong> command.</p>
<p>I got my initial inspiration for this compiler from Peter Norvig&#39;s book &#34;Paradigms of Artificial Intelligence Programming&#34; <sup id="cite_ref1"><a href="#cite_note1">[1]</a></sup>.</p>
<h4>Resources</h4>
<p>To use the compiler you first need to load the RISC-V assembler from: <a href="https://words.filippo.io/list?31OE">RISC-V assembler in uLisp</a>.</p>
<p>Get the full source of the compiler here: <a href="https://words.filippo.io/list?4Y4Q">Lisp compiler for RISC-V</a>.</p>
<p>Or from GitHub here: <a href="https://github.com/technoblogy/lisp-arm-compiler" target="_blank">https://github.com/technoblogy/lisp-arm-compiler</a>.</p>
<p>For information about setting up uLisp on a Raspberry Pi Pico 2 see: <a href="https://words.filippo.io/show?4X21">Raspberry Pi Pico 2</a>.</p>
<h4>Using the compiler</h4>
<p>To run the compiler you simply call <strong>compile</strong> on a Lisp function; for example:</p>
<pre>(compile &#39;fibonacci)</pre>
<p>The function will be compiled into a machine code function, replacing the original Lisp code, so that calling <strong>fibonacci</strong> will now execute the RISC-V machine-code version.</p>
<p>You can also display the code generated for an expression by calling <strong>comp</strong> on the expression; for example:</p>
<pre>(pprint (comp &#39;(* 13 17)))

(:integer
  ($li &#39;a0 13)
  ($addi &#39;sp &#39;sp -4)
  ($sw &#39;a0 0 &#39;(sp))
  ($li &#39;a0 17)
  ($lw &#39;a1 0 &#39;(sp))
  ($addi &#39;sp &#39;sp 4)
  ($mul &#39;a0 &#39;a1 &#39;a0))</pre>
<p>The <strong>:integer</strong> prefix shows that the result is an integer; see below.</p>
<p>For examples of several simple Lisp programs that it will successfully compile see <a href="#examples">Examples</a> below. These also give a comparison of the speed of the Lisp and machine-code versions.</p>
<h4>Specification</h4>
<p>The compiler understands the following Lisp objects:</p>
<p><strong>Defining variables and functions:</strong> defun, setq</p>
<p><strong>Symbols:</strong> nil, t</p>
<p><strong>List functions:</strong> car, cdr</p>
<p><strong>Arithmetic functions:</strong> +, -, *, /, mod, 1+, 1-</p>
<p><strong>Arithmetic comparisons:</strong> =, &lt;, &lt;=, &gt;, &gt;=, /=</p>
<p><strong>Conditionals:</strong> if, and, or</p>
<h4>Tail-call optimisation</h4>
<p>Although the compiler doesn&#39;t include any iteration constructs, it does provide tail-call optimisation which can make recursive programs as efficient as iterative ones. Consider this recursive program to add two positive numbers:</p>
<pre>(defun add (a b)
  (if (= b 0) a
    (add (+ a 1) (- b 1))))</pre>
<p>On a system without tail-call optimisation, evaluating:</p>
<pre>(add 10000 10000)</pre>
<p>will probably fail, because it requires 10000 stack frames to store the intermediate results. This compiler recognises that the recursive call to <strong>add</strong> can be replaced by a jump to the start of the program, and so it has no problem evaluating it. For a more sensible example see <strong><a href="#factor">factor</a></strong> below.</p>
<h3>How the compiler works</h3>
<h4>Register usage</h4>
<p>To avoid needing to keep track of register usage the compiler makes use of the stack to pass values to an expression, and store the value returned by an expression.</p>
<p>The following table shows how the RISC-V registers are used within the compiler:</p>
<table>
<thead>
<tr>
<td><strong>Registers</strong></td>
<td><strong>Use</strong></td>
</tr>
</thead>
<tbody>
<tr>
<td>a0 a1 a2 a3</td>
<td>Used to pass the parameters to the main function&#39;s arguments.</td>
</tr>
<tr>
<td>a0</td>
<td>Contains the value returned by the main function.</td>
</tr>
<tr>
<td>a4 a5 a6 a7</td>
<td>Contain copies of the function arguments within the function.</td>
</tr>
<tr>
<td>a0 a1</td>
<td>Used to pass the arguments to each operator.</td>
</tr>
<tr>
<td>a0</td>
<td>Used to return the value from each operator.</td>
</tr>
<tr>
<td>s0 to s11</td>
<td>Local variables.</td>
</tr>
</tbody>
</table>
<h4>Compiling an expression</h4>
<p>The following steps show the sequence of compiling an expression, such as:</p>
<pre>(* x 13)</pre>
<ul>
<li>Code is generated to evaluate each of the arguments, in this case <strong>x</strong> and 13, and each result is pushed onto the stack, apart from the last which is left in <strong>a0</strong>.</li>
<li>The first value is popped from the stack into register <strong>a1.</strong></li>
<li>The function, in this case *, is then evaluated for <strong>a1</strong> and <strong>a0</strong>, with the result in <strong>a0</strong>.</li>
</ul>
<p>This stack-based approach ensures that a more complex expression, such as:</p>
<pre>(* (- x 1) (+ x 13))</pre>
<p>will also compile into correct code, without conflicts between registers.</p>
<h4>Calling the function recursively</h4>
<p>The compiler supports calling a function recursively from within the function itself. Because the registers corresponding to the parameters and local variables would be overwritten by the recursive call they are stored on the stack around the function call.</p>
<p>There are several recursive functions in the examples below.</p>
<h4>Types</h4>
<p>For boolean operations I decided to represent <strong>nil</strong> as 0, and <strong>t</strong> as 1. A problem I hadn&#39;t anticipated was that I would need to keep track of what type of object each function returned, integer or boolean. For example, consider the problem of compiling the statement:</p>
<pre>(and x y)</pre>
<p>If <strong>x</strong> has the value 0 and <strong>y</strong> has the value 7 this should return 7. However, if <strong>x</strong> has the value <strong>nil</strong> and <strong>y</strong> has the value 7 this should return <strong>nil</strong>. Representing <strong>nil</strong> as zero leads to an ambiguity.</p>
<p>I solved this by returning a type, <strong>:integer</strong> or <strong>:boolean</strong>, with each compiled expression, according to the following rules:</p>
<ul>
<li>Predicates, and <strong>t</strong> or <strong>nil</strong>, always return a <strong>:boolean</strong>.</li>
<li>Arithmetic operations always return an <strong>:integer</strong>.</li>
<li>An <strong>if</strong> form requires a <strong>:boolean</strong> test form and returns an <strong>:integer</strong>.</li>
<li>A <strong>progn</strong> or <strong>let</strong> block returns the type of its last expression.</li>
</ul>
<p>An item with an ambiguous type returns the type <strong>nil</strong>.</p>
<h4>Running the examples</h4>
<p>I used the following simple examples to test the compiler. Before compiling a new function you might want to remove the previous one from memory using <strong>makunbound</strong> to free up the code memory before compiling the next function; for example:</p>
<pre>(makunbound &#39;fibonacci)</pre>
<p>Alternatively you could increase the amount of memory available for machine code by editing the directive such as:</p>
<pre>#define CODESIZE 256 </pre>
<p>before uploading uLisp to your board.</p>
<h3 id="examples">Examples</h3>
<p>The following examples take integer arguments and return an integer result.</p>
<h4 id="factor">Factor</h4>
<p>This function takes a simple approach to finding the least prime factor of a number:</p>
<pre>(defun factor (n d)
  (if (&gt; (* d d) n) n
   (if (= 0 (mod n d)) d
     (factor n (1+ d)))))</pre>
<p>It should be called with n equal to the number to be factorized, and d=2. It takes advantage of the compiler&#39;s tail-call optimisation, which makes it as efficient as an iterative solution. If the number is prime, factor will print the number itself.</p>
<p>To find the least prime factor of 2146654199 (46327 x 46337):</p>
<p>Lisp version:</p>
<pre>&gt; (time (factor 2146654199 2))
46327
Time: 5.4 s</pre>
<p>Compiled version:</p>
<pre>&gt; (time (factor 2146654199 2))
46327
Time: 19 ms</pre>
<p>You can use the above function as the basis for a simple recursive routine to factorize a number into a list of its prime factors:</p>
<pre>(defun factorize (n)
  (let ((f (factor n 2)))
    (if (= n f) (list n) (cons f (factorize (/ n f))))))</pre>
<p>For example:</p>
<pre>&gt; (factorize 731731731)
(3 17 43 333667)</pre>
<h4>Takeuchi function</h4>
<p>This is a version of the highly-recursive benchmark I use for comparing versions of Lisp <sup id="cite_ref2"><a href="#cite_note2">[2]</a></sup>:</p>
<pre>(defun tak (x y z)
  (if (&gt;= y x) z
    (tak
     (tak (1- x) y z)
     (tak (1- y) z x)
     (tak (1- z) x y))))</pre>
<p>Lisp version:</p>
<pre>&gt; (time (tak 18 12 6))
7
Time: 4.1 s
</pre>
<p>Compiled version</p>
<pre>&gt; (time (tak 18 12 6))
7
Time: 16 ms</pre>
<h4>Factorial</h4>
<p>This is a recursive implementation of the factorial function:</p>
<pre>(defun fact (n)
  (if (&lt;= n 1) 1
    (* n (fact (- n 1)))))</pre>
<p>Lisp version:</p>
<pre>&gt; (time (fact 12))
479001600
Time: 1 ms
</pre>
<p>Compiled version</p>
<pre>&gt; (time (fact 12))
479001600
Time: 0 ms</pre>
<h4>Fibonacci</h4>
<p>This is a recursive implementation of the Fibonacci series:</p>
<pre>(defun fibonacci (n)
  (if (&lt; n 3) 1
    (+ (fibonacci (- n 1)) (fibonacci (- n 2)))))</pre>
<p>Lisp version:</p>
<pre>&gt; (time (fibonacci 27))</pre>
<p>Compiled version</p>
<pre>&gt; (time (fibonacci 27))
196418
Time: 80 ms</pre>
<h4>Greatest Common Divisor</h4>
<p>A recursive algorithm to calculate the greatest common divisor of two integers.</p>
<pre>(defun gcd (a b)
  (if (= b 0) a
   (gcd b (mod a b))))</pre>
<p>Lisp version:</p>
<pre>&gt; (time (gcd 2032460032 2056252672))
256
Time: 1 ms
</pre>
<p>Compiled version</p>
<pre>&gt; (time (gcd 2032460032 2056252672))
256
Time: 0 ms</pre>
<h4>Hofstadter Q sequence</h4>
<p>This is one of several recursive sequences described in Douglas Hofstadter&#39;s book &#34;Gödel, Escher, Bach: an Eternal Golden Braid&#34;. It is defined as follows:</p>
<pre>(defun q (n)
  (if (&lt;= n 2) 1
    (+
     (q (- n (q (- n 1))))
     (q (- n (q (- n 2)))))))</pre>
<p>It is related to the Fibonacci sequence, except that in this case the two preceding terms specify how far to go back in the sequence to find the two terms to be summed.</p>
<p>Lisp version:</p>
<pre>&gt; (time (q 21))
12
Time: 8.6 s
</pre>
<p>Compiled version</p>
<pre>&gt; (time (q 21))
12
Time: 25 ms</pre>
<h4>Two-dimensional recursive function Q2</h4>
<p>This function Q2 is my two-dimensional extension of the Hofstadter Q sequence <sup id="cite_ref3"><a href="#cite_note3">[3]</a></sup>:</p>
<pre>(defun q2 (x y)
  (if (or (&lt; x 1) (&lt; y 1)) 1
    (+ (q2 (- x (q2 (1- x) y)) y)
       (q2 x (- y (q2 x (1- y)))))))</pre>
<p>Lisp version:</p>
<pre>&gt; (time (q2 7 8))
31
Time: 13.8 s
</pre>
<p>Compiled version</p>
<pre>&gt; (time (q2 7 8))
31
Time: 50 ms</pre>
<h4>Number of combinations - nCr</h4>
<p>This is a simple but very inefficient way of recursively calculating nCr, based on Pascal&#39;s Triangle:</p>
<pre>(defun ncr (n r)
  (if (or (= r 0) (= r n)) 1
    (+ (ncr (1- n) (1- r)) (ncr (1- n) r))))</pre>
<p>For example, to calculate the number of possible poker hands from a pack of cards:</p>
<p>Lisp version:</p>
<pre>&gt; (time (ncr 52 5))
2598960
Time: 615.5 s
</pre>
<p>Compiled version</p>
<pre>&gt; (time (ncr 52 5))
2598960
Time: 1.7 s</pre>
<h3 id="listexamples">List examples</h3>
<p>Any of the arguments to a machine-code function can be a list, in which case the address of the list is passed to the routine in the corresponding parameter. You can then use the functions <strong>car</strong> and <strong>cdr</strong> to process the elements in the list.</p>
<h4>Dot product</h4>
<p>This recursive function calculates the dot product of two vectors:</p>
<pre>(defun dot-product (a b)
  (if (and a b)
      (+ (* (car a) (car b)) (dot-product (cdr a) (cdr b)))</pre>
<p>It can handle two vectors of arbitrary length provided they are the same length.</p>
<p>For example, to calculate the following dot product:</p>
<p>(987 654 321) • (963 852 741) = 987 × 963 + 654 × 852 + 321 × 741 = 1745550</p>
<p>Lisp version:</p>
<pre>&gt; (time (dot-product &#39;(987 654 321) &#39;(963 852 741)))
1745550
Time: 0 ms
</pre>
<p>Compiled version</p>
<pre>&gt; (time (dot-product &#39;(987 654 321) &#39;(963 852 741)))
1745550
Time: 0 ms</pre>
<h3>Compiler source</h3>
<p>Here&#39;s a description of the source of the compiler.</p>
<h4>Invoking the compiler</h4>
<p>To compile a Lisp function you simply give the command compile followed by the name of the function; for example, to compile the <strong>fibonacci</strong> function:</p>
<pre>(compile &#39;fibonacci)</pre>
<p>Here&#39;s the definition of the command <strong>compile</strong>:</p>
<pre>(defun compile (name)
  (if (eq (car (eval name)) &#39;lambda)
    (eval (comp (cons &#39;defun (cons name (cdr (eval name))))))
 &#34;Not a Lisp function&#34;))</pre>
<h4>Main compiler function</h4>
<p>The main function <strong>comp</strong> returns the compiled code for an expression or form, as a list of assembler instructions prefixed by the type, <strong>:integer</strong> or <strong>:boolean</strong>:</p>
<pre>(defun comp (x &amp;optional env tail)
  (cond
   ((null x) (type-code :boolean &#39;(($li &#39;a0 0))))
   ((eq x t) (type-code :boolean &#39;(($li &#39;a0 1))))
   ((symbolp x) (comp-symbol x env tail))
   ((atom x) (type-code :integer (list (list &#39;$li &#39;&#39;a0 x))))
   (t (let ((fn (first x)) (args (rest x)))
        (case fn
          (defun (setq *label-num* 0)
                 (setq env (mapcar #&#39;(lambda (x y) (cons x y)) (second args) *locals*))
                 (comp-defun (first args) (second args) (cddr args) env))
          (progn (comp-progn args env tail))
          (if    (comp-if (first args) (second args) (third args) env tail))
          (setq  (comp-setq args env tail))
          (t     (comp-funcall fn args env tail)))))))</pre>
<p>The function <strong>comp</strong> takes the item <strong>x</strong> to be compiled, the current environment <strong>env</strong> associating each local variable with a register, and a flag <strong>tail</strong> which is true if the item has no successors.</p>
<p>Each of the different types of form are handled by separate functions such as <strong>comp-defun</strong>, <strong>comp-if</strong>, and <strong>comp-progn</strong>.</p>
<h4>Utilities</h4>
<p>The compiler uses the following utility functions:</p>
<p>The functions <strong>push-regs</strong> and <strong>pop-regs</strong> generate instructions to push a list of registers to the stack, and pop a list of registers from the stack:</p>
<pre>(defun push-regs (&amp;rest regs)
  (let ((n -4))
  (append
   (list (list &#39;$addi &#39;&#39;sp &#39;&#39;sp (* -4 (length regs))))
   (mapcar #&#39;(lambda (reg) (list &#39;$sw (list &#39;quote reg) (incf n 4) &#39;&#39;(sp))) regs))))

(defun pop-regs (&amp;rest regs)
  (let ((n (* 4 (length regs))))
  (append
   (mapcar #&#39;(lambda (reg) (list &#39;$lw (list &#39;quote reg) (decf n 4) &#39;&#39;(sp))) regs)
   (list (list &#39;$addi &#39;&#39;sp &#39;&#39;sp (* 4 (length regs)))))))</pre>
<p>The function <strong>mappend</strong> applies a function to the elements of a list, and the results, which should be lists, are appended together:</p>
<pre>(defun mappend (fn lst)
  (apply #&#39;append (mapcar fn lst)))</pre>
<p>The function <strong>type-code</strong> adds a code type label to the front of a list of assembler instructions, and the functions code-type and code return the code type label, and the code list, respectively:</p>
<pre>(defun type-code (type code) (cons type code))

(defun code-type (type-code) (car type-code))

(defun code (type-code) (cdr type-code))</pre>
<p>The function <strong>checktype</strong> gives an error if the value returned is not the correct type:</p>
<pre>(defun checktype (fn type check)
  (unless (or (null type) (null check) (eq type check))
    (error &#34;Argument to &#39;~a&#39; must be ~a not ~a~%&#34; fn check type)))</pre>
<p>The lists <strong>*params*</strong> and <strong>*locals*</strong> list the registers available for use in the compiler:</p>
<pre>(defvar *params* &#39;(a0 a1 a2 a3))

(defvar *locals* &#39;(a4 a5 s0 s1 a6 a7 s2 s3 s4 s5 s6 s7 s8 s9 s10 s11))</pre>
<p>Finally, <strong>gen-label</strong> generates a new label for use in branches and jumps:</p>
<pre>(defvar *label-num* 0)

(defun gen-label ()
  (read-from-string (format nil &#34;lab~d&#34; (incf *label-num*))))</pre>
<p>The remaining functions handle the compiling of specific types of Lisp form:</p>
<h4>Symbols</h4>
<p>The environment is represented by an association list giving the register associated with each variable, such as:</p>
<pre>((y . r5) (x . r4))</pre>
<p>The function <strong>comp-symbol</strong> looks up a symbol in the association list and returns the appropriate register:</p>
<pre>(defun comp-symbol (x env)
  (let ((reg (cdr (assoc x env))))
    (type-code nil (list (list &#39;$mv &#39;&#39;a0 (list &#39;quote reg))))))</pre>
<h4>Assignment</h4>
<p>The function <strong>comp-setq</strong> handles assignment to a variable:</p>
<pre>(defun comp-setq (args env tail)
  (let ((value (comp (second args) env tail))
        (reg (cdr (assoc (first args) env))))
    (type-code 
     (code-type value) 
     (append (code value) (list (list &#39;$mv (list &#39;quote reg) &#39;&#39;a0))))))</pre>
<h4>Function definition</h4>
<p>The definition of the function being compiled is handled by <strong>comp-defun</strong>:</p>
<pre>(defun comp-defun (name args body env)
  (setq *used-params* (subseq *locals* 0 (length args)))
  (append 
   (list &#39;defcode name args)
   (list name)
   (apply #&#39;append 
          (mapcar #&#39;(lambda (x y) (list (list &#39;$mv (list &#39;quote x) (list &#39;quote y))))
                  *used-params* *params*))
   (code (comp-progn body env t))))</pre>
<h4>Progn special form</h4>
<p>The function <strong>comp-progn</strong> compiles a <strong>progn</strong> form:</p>
<pre>(defun comp-progn (exps env tail)
  (let* ((len (1- (length exps)))
         (nlast (subseq exps 0 len))
         (last1 (nth len exps))
         (start (mappend #&#39;(lambda (x) (append (code (comp x env t)))) nlast))
         (end (comp last1 env tail)))
    (type-code (code-type end) (append start (code end)))))</pre>
<p>It compiles code to evaluate each expression in the body of the <strong>progn</strong>, discarding all but the last results, and returns the type of the last form as the type of the whole block.</p>
<h4>If special form</h4>
<p>The function <strong>comp-if</strong> compiles the code for an <strong>if</strong> special form:</p>
<pre>(defun comp-if (pred then else env tail)
  (let ((lab1 (gen-label))
        (lab2 (gen-label))
        (test (comp pred env nil)))
    (checktype &#39;if (car test) :boolean)
    (type-code :integer
               (append
                (code test) (list (list &#39;$beqz &#39;&#39;a0 lab1))
                (code (comp then env t)) (list (list &#39;$j lab2) lab1)
                (code (comp else env tail)) (list lab2)
                (when tail &#39;(($ret)))))))</pre>
<h4>Function calls</h4>
<p>Finally, <strong>comp-funcall</strong> compiles code for function calls to the built-in functions, or a recursive call to the main function:</p>
<pre>(defun comp-funcall (f args env tail)
  (let ((test (assoc f &#39;((&lt; . $slt) (&gt; . $sgt))))
        (teste (assoc f &#39;((= . $seqz) (/= . $snez))))
        (testn (assoc f &#39;((&gt;= . $slt) (&lt;= . $sgt))))
        (logical (assoc f &#39;((and . $and) (or . $or))))
        (arith1 (assoc f &#39;((1+ . 1) (1- . -1))))
        (arith (assoc f &#39;((+ . $add) (- . $sub) (* . $mul) (/ . $div) (mod . $rem)))))
    (cond
     ((or test teste testn)
      (type-code :boolean
                   (append
                    (comp-args f args 2 :integer env)
                    (pop-regs &#39;a1)
                    (cond
                     (test (list (list (cdr test) &#39;&#39;a0 &#39;&#39;a1 &#39;&#39;a0)))
                     (teste (list &#39;($sub &#39;a0 &#39;a1 &#39;a0) (list (cdr teste) &#39;&#39;a0 &#39;&#39;a0)))
                     (testn (list (list (cdr testn) &#39;&#39;a0 &#39;&#39;a1 &#39;&#39;a0) &#39;($xori &#39;a0 &#39;a0 1))))
                    (when tail &#39;(($ret))))))
     (logical 
      (type-code :boolean
                 (append
                  (comp-args f args 2 :boolean env)
                  (pop-regs &#39;a1)
                  (list (list (cdr logical) &#39;&#39;a0 &#39;&#39;a0 &#39;&#39;a1))
                  (when tail &#39;(($ret))))))
     (arith1
      (type-code :integer
                 (append
                  (comp-args f args 1 :integer env)
                  (list (list &#39;$addi &#39;&#39;a0 &#39;&#39;a0 (cdr arith1)))
                  (when tail &#39;(($ret))))))
     (arith
      (type-code :integer 
                 (append
                  (comp-args f args 2 :integer env)
                  (pop-regs &#39;a1)
                  (list (list (cdr arith) &#39;&#39;a0 &#39;&#39;a1 &#39;&#39;a0))
                  (when tail &#39;(($ret))))))
     ((member f &#39;(car cdr))
      (type-code :integer
                 (append
                  (comp-args f args 1 :integer env)
                  (if (eq f &#39;cdr) (list &#39;($lw &#39;a0 4 &#39;(a0)))
                    (list &#39;($lw &#39;a0 0 &#39;(a0)) &#39;($lw &#39;a0 4 &#39;(a0))))
                  (when tail &#39;(($ret))))))
     (t ; function call
      (type-code :integer 
                 (append
                  (comp-args f args nil :integer env)
                  (when (&gt; (length args) 1)
                    (append
                     (list (list &#39;$mv (list &#39;quote (nth (1- (length args)) *params*)) &#39;&#39;a0))
                     (apply #&#39;pop-regs (subseq *params* 0 (1- (length args))))))
                  (cond
                   (tail (list (list &#39;$j f)))
                   (t (append
                       (apply #&#39;push-regs (cons &#39;ra (reverse *used-params*)))
                       (list (list &#39;$jal f))
                       (apply &#39;pop-regs (append *used-params* (list &#39;ra))))))))))))</pre>
<p>The arithmetic comparisons take advantage of the RISC-V instructions such as <strong>slt</strong> (Set if less than), which set the destination register to 0 if the comparison is false, and to 1 if it&#39;s true; this provides the required boolean result without needing a branch.</p>
<p>The function <strong>comp-funcall</strong> uses the routine <strong>comp-args</strong> to generate code to compile each of the arguments to a function:</p>
<pre>(defun comp-args (fn args n type env)
  (unless (or (null n) (= (length args) n))
    (error &#34;Incorrect number of arguments to &#39;~a&#39;&#34; fn))
  (let ((n (length args)))
    (mappend #&#39;(lambda (y)
                 (let ((c (comp y env nil)))
                   (decf n)
                   (checktype fn type (code-type c))
                   (if (zerop n) (code c) (append (code c) (push-regs &#39;a0)))))
             args)))</pre>
<h3>Appendix</h3>
<p>The following example shows the code generated by a simple function, <strong>rec</strong>, a recursive function related to the factorial function:</p>
<pre>(defun rec (n)
  (1+ (* n (if (= n 0) 0 (rec (1- n))))))</pre>
<p>Compiling this gives the following RISC-V machine code:</p>
<pre>&gt; (compiler &#39;rec)
0000      rec
0000 872a ($mv &#39;a4 &#39;a0)
0002 853a ($mv &#39;a0 &#39;a4)
0004 1171 ($addi &#39;sp &#39;sp -4)
0006 c02a ($sw &#39;a0 0 &#39;(sp))
0008 853a ($mv &#39;a0 &#39;a4)
000a 1171 ($addi &#39;sp &#39;sp -4)
000c c02a ($sw &#39;a0 0 &#39;(sp))
000e 4501 ($li &#39;a0 0)
0010 4582 ($lw &#39;a1 0 &#39;(sp))
0012 0111 ($addi &#39;sp &#39;sp 4)
0014 8533 ($sub &#39;a0 &#39;a1 &#39;a0)
0016 40a5 
0018 3513 ($seqz &#39;a0 &#39;a0)
001a 0015 
001c c119 ($beqz &#39;a0 lab1)
001e 4501 ($li &#39;a0 0)
0020 a819 ($j lab2)
0022      lab1
0022 853a ($mv &#39;a0 &#39;a4)
0024 157d ($addi &#39;a0 &#39;a0 -1)
0026 1161 ($addi &#39;sp &#39;sp -8)
0028 c006 ($sw &#39;ra 0 &#39;(sp))
002a c23a ($sw &#39;a4 4 &#39;(sp))
002c f0ef ($jal rec)
002e fd5f 
0030 4712 ($lw &#39;a4 4 &#39;(sp))
0032 4082 ($lw &#39;ra 0 &#39;(sp))
0034 0121 ($addi &#39;sp &#39;sp 8)
0036      lab2
0036 4582 ($lw &#39;a1 0 &#39;(sp))
0038 0111 ($addi &#39;sp &#39;sp 4)
003a 8533 ($mul &#39;a0 &#39;a1 &#39;a0)
003c 02a5 
003e 0505 ($addi &#39;a0 &#39;a0 1)
0040 8082 ($ret)</pre>
<p>Trying it out:</p>
<pre>&gt; (rec 12)
1302061345</pre>
<p>This example demonstrates how the RISC-V Lisp assembler takes advantage of 16-bit compressed instructions where possible, instead of the equivalent full 32-bit instructions.</p><hr/>
<ol>
<li id="cite_note1"><a href="#cite_ref1">^</a> Norvig, Peter &#34;Paradigms of Artificial Intelligence Programming&#34; Morgan Kaufmann Publishers, Inc, San Francisco, 1992, pp 784-833, available as a PDF <a href="https://github.com/norvig/paip-lisp" target="_blank">paip-lisp</a> on GitHub.</li>
<li id="cite_note2"><a href="#cite_ref2">^</a> <a href="http://www.ulisp.com/show?1EO1#tak">Benchmarks - Takeuchi function</a>.</li>
<li id="cite_note3"><a href="#cite_ref3">^</a> <a href="http://www.ulisp.com/show?1EO1#q2">Benchmarks - Two-dimensional recursive function Q2</a>.</li>
</ol>

</div></div>
  </body>
</html>
