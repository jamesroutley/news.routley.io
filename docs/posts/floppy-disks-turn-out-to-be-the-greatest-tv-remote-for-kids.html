<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.smartere.dk/2026/01/floppy-disks-the-best-tv-remote-for-kids/">Original</a>
    <h1>Floppy disks turn out to be the greatest TV remote for kids</h1>
    
    <div id="readability-page-1" class="page"><div id="container">
		
		
    
  <div id="main">
  	<div id="content">
		  <div>
										<div id="post-702">
						       
							<div><p>Posted on <span>mandag, januar 12, 2026</span> in <span><a href="https://blog.smartere.dk/category/planets/hal9k/" rel="category tag">Hal9k</a>, <a href="https://blog.smartere.dk/category/planets/planet-ubuntu-dk-planets/" rel="category tag">Planet Ubuntu-DK</a>, <a href="https://blog.smartere.dk/category/planets/" rel="category tag">Planets</a></span></p></div>
							
<p>Modern TVs are very poorly suited for kids. They require using complicated remotes or mobile phones, and navigating apps that continually try to lure you into watching something else than you intended to. The usual scenario ends up with the kid feeling disempowered and asking an adult to put something on. That something ends up on auto-play because then the adult is free to do other things and the kid ends up stranded powerless and comatose in front of the TV.</p>



<figure><video controls="" src="https://blog.smartere.dk/wp-content/uploads/2026/01/20230908_224249.mp4" playsinline=""></video></figure>



<p>Instead I wanted to build something for my 3-year old son that he could understand and use independently. It should empower him to make his own choices. It should be physical and tangible, i.e. it should be something he could touch and feel. It should also have some illusion that the actual media content was stored physically and not un-understandably in “the cloud”, meaning it should e.g. be destroyable — if you break the media there should be consequences. And there should be no auto-play: interact <em>once </em>and get <em>one </em>video.</p>



<h2>Floppy disks are awesome!</h2>



<p>And then I remembered the sound of a floppy disk. The mechanical click as you insert it, the whirr of the disk spinning, and the sound of the read-head moving. Floppy disks are the best storage media ever invented! Why else would the “save-icon” still be a floppy disk? Who hasn’t turned in a paper on a broken floppy disk, with the excuse ready that the floppy must have broken when the teacher asks a few days later? But kids these days have never used nor even seen a floppy disk, and I believe they deserve this experience!</p>



<p>Building on the experience from the <a href="https://blog.smartere.dk/2023/10/fantus-button-part-2-the-physical-button-build-and-the-network-communication/" data-type="post" data-id="570">Big Red Fantus-Button</a>, I already had a framework for controlling a Chromecast, and because of the <code>netcat | bash</code> shenanigans it was easily extendable.</p>



<p>My first idea for datastorage was to use the shell of a floppy disk and floppy drive, and put in an RFID tag; this has been done a couple of times on the internet, such as <a href="https://github.com/ItsDanik/rfidisk">RFIDisk</a> or this <a href="https://magazine.raspberrypi.com/articles/rfid-floppy-disk-reader">RaspberryPi based RFID reader</a> or this <a href="https://www.youtube.com/watch?v=MsiUxiEBAqs">video covering how to embed an RFID tag in a floppy disk</a>. But getting the floppy disk apart to put in an RFID tag and getting it back together was kinda wonky.</p>



<p>When working on the project in <a href="http://hal9k.dk">Hal9k</a> someone remarked: “Datastorage? The floppy disk can store data!”, and a quick prototype later this worked really, <em>really</em>, well. Formatting the disk and storing a single small file, “autoexec.sh”, means that all the data ends up in track 0 and is read more or less immediately. It also has the benefit that everything can be checked and edited with a USB floppy disk drive; and the major benefit that all the sounds are completely authentic: click, whirrr, brrr brrr.</p>



<h2>Autorun for floppy disks is not really a thing.</h2>



<p>The next problem to tackle was how to detect that a disk is inserted. The concept of <a href="https://en.wikipedia.org/wiki/AutoRun">AutoRun</a> from Windows 95 was a beauty: insert a CD-ROM and it would automatically start whatever was on the media. Great for convenience, quite questionably for security. While <em>in theory</em> <a href="https://learn.microsoft.com/da-dk/windows/win32/shell/autoplay-reg?redirectedfrom=MSDN">floppy disks are supported for AutoRun</a>, it turns out that floppy drives basically don’t know if a disk is inserted until the operating system tries to access it! There is a <a href="https://en.wikipedia.org/wiki/Floppy_disk_drive_interface">pin 34 “Disk Change” that is supposed to give this information</a>, but this is basically a lie. None of the drives in my possession had that pin connected to anything, and the internet mostly concurs. In the end I slightly modified the drive and added a simple rolling switch, that would engage when a disk was inserted.</p>



<figure><video controls="" src="https://blog.smartere.dk/wp-content/uploads/2026/01/insert_floppy_mechanism.mp4" playsinline=""></video></figure>



<h2>A floppy disk walks into a drive; the microcontroller says “hello!”</h2>



<p>The next challenge was to read the data on a microcontroller. Helpfully, there is the <a href="https://github.com/dhansel/ArduinoFDC">Arduino FDC Floppy library</a> by dhansel, which I must say is <em>most</em> excellent. Overall, this meant that the part of the project that involved reading a file from the floppy disk FAT filesystem was basically the easiest part of all!</p>


<div>
<figure><img fetchpriority="high" decoding="async" width="416" height="416" src="https://blog.smartere.dk/wp-content/uploads/2026/01/image-1.png" alt="" srcset="https://blog.smartere.dk/wp-content/uploads/2026/01/image-1.png 416w, https://blog.smartere.dk/wp-content/uploads/2026/01/image-1-300x300.png 300w, https://blog.smartere.dk/wp-content/uploads/2026/01/image-1-150x150.png 150w" sizes="(max-width: 416px) 100vw, 416px"/><figcaption>A combined ATMega + ESP8266 UNO-like board. Not really recommended, but can be made to work.</figcaption></figure></div>


<p>However, the <a href="https://github.com/dhansel/ArduinoFDC">Arduino FDC Floppy</a> library is <em>only</em> compatible with the AVR-based Arduinos, not the ESP-based ones, because it needs to control the timing very precisely and therefore uses a healthy amount of inline assembler. This meant that I would need one AVR-based Arduino to control the floppy disk, but another ESP-based one to do the WiFi communication. Such combined boards do exist, and I ended up using such a board, but I’m not sure I would recommend it: the usage is really finagly, as you need to set the jumpers differently for programming the ATmega, or programming the ESP, or connecting the two boards serial ports together.</p>



<h2>A remote should be battery-powered</h2>



<p>A remote control should be portable, and this means battery-powered. Driving a floppy disk of of lithium batteries was interesting. There is a large spike in current draw when the disk needs to spin up of several amperes, while the power draw afterwards is more modest, a couple of hundred milliamperes. I wanted the batteries to be 18650s, because I have those in abundance. This meant a battery voltage of 3.7V nominally, up to 4.2V for a fully charged battery; 5V is needed to spin the floppy around, so a boost DC-DC converter was needed. I used an off the shelf XL6009 step-up converter board. At this point a lot of head-scratching occurred: that initial spin-up power draw would cause the microcontroller to reset. In the end a 1000uF capacitor at the microcontroller side seemed to help but not eliminate the problem.</p>



<figure data-wp-context="{&#34;imageId&#34;:&#34;69662a69ec4f6&#34;}" data-wp-interactive="core/image"><img decoding="async" width="1024" height="768" data-wp-class--hide="state.isContentHidden" data-wp-class--show="state.isContentVisible" data-wp-init="callbacks.setButtonStyles" data-wp-on-async--click="actions.showLightbox" data-wp-on-async--load="callbacks.setButtonStyles" data-wp-on-async-window--resize="callbacks.setButtonStyles" src="https://blog.smartere.dk/wp-content/uploads/2026/01/image-1024x768.png" alt="" srcset="https://blog.smartere.dk/wp-content/uploads/2026/01/image-1024x768.png 1024w, https://blog.smartere.dk/wp-content/uploads/2026/01/image-300x225.png 300w, https://blog.smartere.dk/wp-content/uploads/2026/01/image-768x576.png 768w, https://blog.smartere.dk/wp-content/uploads/2026/01/image-1536x1152.png 1536w, https://blog.smartere.dk/wp-content/uploads/2026/01/image.png 1667w" sizes="(max-width: 1024px) 100vw, 1024px"/></figure>



<p>One crucial finding was that the ground side of the interface cable should absolutely <em>not</em> be connected to any grounds on the microcontroller side. I was using a relatively simple logic-level MOSFET, the <a href="https://www.infineon.com/assets/row/public/documents/24/49/infineon-irlz34n-datasheet-en.pdf?fileId=5546d462533600a40153567206892720">IRLZ34N</a>, to turn off the drive by disconnecting the ground side. If any ground is connected, the disk won’t turn off. But also: if any logic pin was being pulled to ground by the ATmega, that would also provide a path to ground. But since the ATmega cannot sink that much current this would lead to spurious resets! Obvious after the fact, but this took quite some headscratching. <a href="https://github.com/mchro/FloppyDiskCast/commit/7a59d0754a0b9ad62af22d06c4fe978462e26150">Setting all the logic pins to input, and thus high impedance</a>, finally fixed the stability issues.</p>



<figure data-wp-context="{&#34;imageId&#34;:&#34;69662a69ecbb2&#34;}" data-wp-interactive="core/image"><img decoding="async" width="1024" height="585" data-wp-class--hide="state.isContentHidden" data-wp-class--show="state.isContentVisible" data-wp-init="callbacks.setButtonStyles" data-wp-on-async--click="actions.showLightbox" data-wp-on-async--load="callbacks.setButtonStyles" data-wp-on-async-window--resize="callbacks.setButtonStyles" src="https://blog.smartere.dk/wp-content/uploads/2026/01/image-7-1024x585.png" alt="" srcset="https://blog.smartere.dk/wp-content/uploads/2026/01/image-7-1024x585.png 1024w, https://blog.smartere.dk/wp-content/uploads/2026/01/image-7-300x171.png 300w, https://blog.smartere.dk/wp-content/uploads/2026/01/image-7-768x439.png 768w, https://blog.smartere.dk/wp-content/uploads/2026/01/image-7-1536x877.png 1536w, https://blog.smartere.dk/wp-content/uploads/2026/01/image-7.png 1656w" sizes="(max-width: 1024px) 100vw, 1024px"/></figure>



<p>After fixing the stability, the next challenge was how to make <em>both</em> of the microcontrollers sleep. Because the ATmega sleep modes are quite a lot easier to deal with, and because the initial trigger would be the floppy inserting, I decided to make the ATmega in charge overall. Then the ESP has a very simple function: when awoken, read serial in, when a newline is found then send off that complete line via WiFi, and after 30 seconds signal to the ATmega that we’re sleeping, and go back to sleep.</p>



<figure data-wp-context="{&#34;imageId&#34;:&#34;69662a69ed45e&#34;}" data-wp-interactive="core/image"><img loading="lazy" decoding="async" width="1024" height="677" data-wp-class--hide="state.isContentHidden" data-wp-class--show="state.isContentVisible" data-wp-init="callbacks.setButtonStyles" data-wp-on-async--click="actions.showLightbox" data-wp-on-async--load="callbacks.setButtonStyles" data-wp-on-async-window--resize="callbacks.setButtonStyles" src="https://blog.smartere.dk/wp-content/uploads/2026/01/image-3-1024x677.png" alt="" srcset="https://blog.smartere.dk/wp-content/uploads/2026/01/image-3-1024x677.png 1024w, https://blog.smartere.dk/wp-content/uploads/2026/01/image-3-300x198.png 300w, https://blog.smartere.dk/wp-content/uploads/2026/01/image-3-768x508.png 768w, https://blog.smartere.dk/wp-content/uploads/2026/01/image-3.png 1244w" sizes="auto, (max-width: 1024px) 100vw, 1024px"/></figure>



<p>The overall flow for the ATmega is then:</p>



<ol>
<li>A disk is inserted, this triggers a interrupt on the ATmega that wakes up.</li>



<li>The ATmega resets the ESP, waking it from deep sleep.</li>



<li>The ATmega sends a “diskin” message over serial to the ESP; the ESP transmits this over WiFi when available.</li>



<li>The ATmega turns on the drive itself, and reads the disk contents, and just sends it over serial to the ESP.</li>



<li>Spin down the disk, go to sleep.</li>



<li>When the disk is ejected, send a “diskout” message over serial, resetting the ESP if needed.</li>



<li>Go back to 1.</li>
</ol>



<p>The box itself is just lasercut from MDF-board. For full details see the <a href="https://github.com/mchro/FloppyDiskCast">FloppyDiskCast Git repository</a>.</p>



<h2>Server-side handlers</h2>



<p>Responding to those commands is still the <code>netcat | bash</code> from the <a href="https://blog.smartere.dk/2023/10/fantus-button-part-2-the-physical-button-build-and-the-network-communication/" data-type="post" data-id="570">Big Red Fantus-Button</a>, which was simply extended with a few more commands and capabilities.</p>



<figure><img loading="lazy" decoding="async" width="552" height="609" src="https://blog.smartere.dk/wp-content/uploads/2026/01/image-9.png" alt="" srcset="https://blog.smartere.dk/wp-content/uploads/2026/01/image-9.png 552w, https://blog.smartere.dk/wp-content/uploads/2026/01/image-9-272x300.png 272w" sizes="auto, (max-width: 552px) 100vw, 552px"/><figcaption>A few different disks to chose from, with custom printed labels.</figcaption></figure>



<p><code>diskin</code> always sends a “play” command to the Chromecast.</p>



<ul>
<li><a href="https://github.com/mchro/FloppyDiskCast/blob/1ac7c6f91fe1d587e3c1154cfd170fe0712a4c69/serverside/floppy-chromecast/handlers/common_player.py#L269">Play a random video from a set, if a video from that set is not already playing</a>: e.g. <code>dad-music</code> will randomly play one of dad’s music tracks – gotta influence the youth!</li>



<li><a href="https://github.com/mchro/FloppyDiskCast/blob/1ac7c6f91fe1d587e3c1154cfd170fe0712a4c69/serverside/floppy-chromecast/handlers/common_player.py#L309">Play the next video from a list, if a video from the list is not already playing</a>: e.g. <code>fantus-maskinerne</code> will play the next episode, and only the next episode.</li>
</ul>



<p>Common for both is that they should be idempotent actions, and the <code>diskin</code> shortcut will make the media resume without having to wait for the disk contents itself to be read and processed. This means that the “play/pause” disk just contains an empty file to work.</p>



<h2>Questionable idea meets real-world 3 year old user</h2>



<figure><video controls="" src="https://blog.smartere.dk/wp-content/uploads/2026/01/20231125_112423.mp4" playsinline=""></video></figure>



<p>The little guy quickly caught on to the idea! Much fun was had just pausing and resuming music and his Fantus TV shows. He explored and prodded, and some disks <em>were</em> harmed in the process. One problem that I did solve was that the read head stayed on track 0 after having read everything: this means that when the remote with disk inside it is tumbled around, the disk gets damaged at track 0. To compensate for this, I move the head to track 20 after reading has finished: any damage is then done there, where we don’t store any data. As a bonus it also plays a little more mechanic melody.</p>
						
						
						
				

				
				</div>
						
						</div>
		</div>
				    
  </div>
  
		
	</div></div>
  </body>
</html>
