<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://mariusbancila.ro/blog/2023/09/12/formatting-text-in-c-the-old-and-the-new-ways/">Original</a>
    <h1>Formatting text in C&#43;&#43;: Old and new ways</h1>
    
    <div id="readability-page-1" class="page"><article id="post-4687">

	

	
	<div>
		
<p>When it comes to format a piece of text in C++ there are several ways you can employ:</p>



<ul><li>I/O streams, particularly <a href="https://en.cppreference.com/w/cpp/io/basic_stringstream" target="_blank" rel="noopener" title="">std::stringstream</a> with stream operations (such as <code>operator &lt;&lt;</code>)</li><li>printf family of functions, particularly <a href="https://en.cppreference.com/w/c/io/fprintf" target="_blank" rel="noopener" title="">sprintf</a></li><li>the C++20 format library, particularly <a href="https://en.cppreference.com/w/cpp/utility/format/format" target="_blank" rel="noopener" title="">std::format</a> / <a href="https://en.cppreference.com/w/cpp/utility/format/format_to" target="_blank" rel="noopener" title="">std::format_to</a></li><li>any 3rd party library, <a href="https://github.com/fmtlib/fmt" target="_blank" rel="noopener" title="">{fmt}</a> in particular (the source of the new standard format library)</li></ul>



<p>The first two options represent the old ways. The format library, is, obviously, the new, modern way of formatting text. But which is better in terms of performance? Let’s try to figure out.</p>



<h2>In which examples are presented…</h2>



<p>First, let’s see a few simple examples of formatting text. Let’s say we want to format a text in the form <code>&#34;severity=1,error=42,reason=access denied&#34;</code>. We can do this as follows:</p>



<ul><li>with streams</li></ul>



<pre data-enlighter-language="cpp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">int severity = 1;
unsigned error = 42;
reason = &#34;access denied&#34;;

std::stringstream ss;
ss &lt;&lt; &#34;severity=&#34; &lt;&lt; severity
   &lt;&lt; &#34;,error=&#34; &lt;&lt; error
   &lt;&lt; &#34;,reason=&#34; &lt;&lt; reason;

std::string text = ss.str();</pre>



<ul><li>with printf</li></ul>



<pre data-enlighter-language="cpp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">int severity = 1;
unsigned error = 42;
reason = &#34;access denied&#34;;

std::string text(50, &#39;\0&#39;);
sprintf(text.data(), &#34;severity=%d,error=%u,reason=%s&#34;, severity, error, reason);</pre>



<ul><li>with format</li></ul>



<pre data-enlighter-language="cpp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">int severity = 1;
unsigned error = 42;
reason = &#34;access denied&#34;;

std::string text = std::format(&#34;severity={},error={},reason={}&#34;, severity, error, reason);

// or

std::string text;
std::format_to(std::back_inserter(text), &#34;severity={},error={},reason={}&#34;, severity, error, reason);</pre>



<p><code>std::format</code> is very similar in many aspects to <code>printf</code>, although you don’t need to provide type specifiers, such as <code>%d</code>, <code>%u</code>, <code>%s</code>, only an argument placeholder <code>{}</code>. Of course, there are format specifiers available, which you can read about <a href="https://en.cppreference.com/w/cpp/utility/format/formatter" target="_blank" rel="noopener" title="">here</a>, but that’s not of interest for the point of this article.</p>



<p>The <code>std::format_to</code> is useful to append text because it writes to an output buffer through an iterator. This allows us to append text, conditionally, such as in the following example where the reason is written in the message only if it’s not empty:</p>



<pre data-enlighter-language="cpp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">std::string text = std::format(&#34;severity={},error={}&#34;, severity, error);

if(!reason.empty())
  std::format_to(std::back_inserter(text), &#34;,reason=&#34;, reason);</pre>



<h2>In which performance is compared…</h2>



<p>With all these options, the question is which is the best to use? In general, stream operations are slow, and <code>{fmt}</code> is known to be significantly faster. But not all cases are equal, and, in general, when you want to make optimizations, you should measure yourself and not take decisions based on generalities.</p>



<p>I asked myself this question recently, when I noticed in a project that I’m currently involved with the large scale use of <code>std::stringstream</code> to format log messages. Most examples involved one to three arguments. For instance:</p>



<pre data-enlighter-language="cpp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">std::stringstream ss;
ss &lt;&lt; &#34;component id: &#34; &lt;&lt; id;

std::string msg = ss.str();

// or

std::stringstream ss;
ss &lt;&lt; &#34;source: &#34; &lt;&lt; source &lt;&lt; &#34;|code=&#34; &lt;&lt; code;

std::string msg = ss.str();</pre>



<p>I thought that replacing <code>std::stringstream</code> with <code>std::format</code> should be beneficial for performance, but I wanted to measure how much faster it would be. So I wrote the following program to compare the alternatives. What it does is:</p>



<ul><li>format a text to the form <code>&#34;Number 42 is great!&#34;</code></li><li>compares <code>std::stringstream</code>, <code>sprintf</code>, <code>std::format</code>, and <code>std::format_to</code></li><li>runs a variable number of iterations, 1 to 1000000, and determines the average time per iteration</li></ul>



<pre data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">int main()
{
   {
      std::stringstream ss;
      ss &lt;&lt; 42;
   }

   using namespace std::chrono_literals;

   std::random_device rd{};
   auto mtgen = std::mt19937{ rd() };
   auto ud = std::uniform_int_distribution&lt;&gt;{ -1000000, 1000000 };

   std::vector&lt;int&gt; iterations{ 1, 2, 5, 10, 100, 1000, 10000, 100000, 1000000 };

   std::println(&#34;{:&gt;10} {:&gt;12} {:&gt;7} {:&gt;9} {:&gt;6}&#34;, &#34;iterations&#34;, &#34;stringstream&#34;, &#34;sprintf&#34;, &#34;format_to&#34;, &#34;format&#34;);
   std::println(&#34;{:&gt;10} {:&gt;12} {:&gt;7} {:&gt;9} {:&gt;6}&#34;, &#34;----------&#34;, &#34;------------&#34;, &#34;-------&#34;, &#34;---------&#34;, &#34;------&#34;);

   for (int count : iterations)
   {
      std::vector&lt;int&gt; numbers(count);
      for (std::size_t i = 0; i &lt; numbers.size(); ++i)
      {
         numbers[i] = ud(mtgen);
      }

      long long t1, t2, t3, t4;

      {
         auto start = std::chrono::high_resolution_clock::now();

         for (std::size_t i = 0; i &lt; numbers.size(); ++i)
         {
            std::stringstream ss;
            ss &lt;&lt; &#34;Number &#34; &lt;&lt; numbers[i] &lt;&lt; &#34; is great!&#34;;
            std::string s = ss.str();
         }

         auto end = std::chrono::high_resolution_clock::now();
         t1 = std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(end - start).count();
      }

      {
         auto start = std::chrono::high_resolution_clock::now();

         for (std::size_t i = 0; i &lt; numbers.size(); ++i)
         {
            std::string str(100, &#39;\0&#39;);
            std::sprintf(str.data(), &#34;Number %d is great!&#34;, numbers[i]);
         }

         auto end = std::chrono::high_resolution_clock::now();
         t2 = std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(end - start).count();
      }

      {
         auto start = std::chrono::high_resolution_clock::now();

         for (std::size_t i = 0; i &lt; numbers.size(); ++i)
         {
            std::string s;
            std::format_to(std::back_inserter(s), &#34;Number {} is great!&#34;, numbers[i]);
         }

         auto end = std::chrono::high_resolution_clock::now();
         t3 = std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(end - start).count();
      }

      {
         auto start = std::chrono::high_resolution_clock::now();

         for (std::size_t i = 0; i &lt; numbers.size(); ++i)
         {
            std::string s = std::format(&#34;Number {} is great!&#34;, numbers[i]);
         }

         auto end = std::chrono::high_resolution_clock::now();
         t4 = std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(end - start).count();
      }

      std::println(&#34;{:&lt;10} {:&lt;12.2f} {:&lt;7.2f} {:&lt;9.2f} {:&lt;7.2f}&#34;, count, t1/1000.0 / count, t2 / 1000.0 / count, t3 / 1000.0 / count, t4 / 1000.0 / count);
   }
}</pre>



<p>The results vary slightly for each execution, and, as one would expect, should be different on different machines. On my machine, a Release build for 64-bit produces results as following (time values are given in microseconds):</p>



<pre data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">iterations stringstream sprintf format_to format
---------- ------------ ------- --------- ------
1          29.60        11.80   1.80      0.60
2          10.00        4.20    0.55      0.50
5          1.56         0.56    0.34      0.26
10         1.61         1.15    0.26      0.31
100        1.15         0.28    0.22      0.26
1000       1.17         0.30    0.24      0.26
10000      1.29         0.28    0.23      0.24
100000     0.87         0.18    0.15      0.16
1000000    0.74         0.18    0.15      0.16</pre>



<p>If we ran the loop a single time, the <code>sprintf</code> is 2-3 times faster, in general, than <code>std::stringstream</code>, but <code>std::format</code>/<code>std::format</code> are 20-30x times faster than <code>std::stringstream</code> and 5-20x faster than <code>sprintf</code>. These numbers change as we measure the execution of more loops, but still, <code>std::format</code> is still about 5 times faster than <code>std::stringstream</code> and mostly the same with <code>sprintf</code>. Since in my case generating a log message does not occur in a loop, I can conclude that the speed-up can be 20-30x.</p>



<p>For the case when 2 arguments are written in the output text, the numbers are similar. The program is only slightly different, to generate text of the form <code>&#34;Numbers 42 and 43 are great!&#34;</code>:</p>



<pre data-enlighter-language="cpp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">int main()
{
   {
      std::stringstream ss;
      ss &lt;&lt; 42;
   }

   using namespace std::chrono_literals;

   std::random_device rd{};
   auto mtgen = std::mt19937{ rd() };
   auto ud = std::uniform_int_distribution&lt;&gt;{ -1000000, 1000000 };

   std::vector&lt;int&gt; iterations{ 1, 2, 5, 10, 100, 1000, 10000, 100000, 1000000 };

   std::println(&#34;{:&gt;10} {:&gt;12} {:&gt;7} {:&gt;9} {:&gt;6}&#34;, &#34;iterations&#34;, &#34;stringstream&#34;, &#34;sprintf&#34;, &#34;format_to&#34;, &#34;format&#34;);
   std::println(&#34;{:&gt;10} {:&gt;12} {:&gt;7} {:&gt;9} {:&gt;6}&#34;, &#34;----------&#34;, &#34;------------&#34;, &#34;-------&#34;, &#34;---------&#34;, &#34;------&#34;);

   for (int count : iterations)
   {
      std::vector&lt;int&gt; numbers(count);
      for (std::size_t i = 0; i &lt; numbers.size(); ++i)
      {
         numbers[i] = ud(mtgen);
      }

      long long t1, t2, t3, t4;

      {
         auto start = std::chrono::high_resolution_clock::now();

         for (std::size_t i = 0; i &lt; numbers.size(); ++i)
         {
            std::stringstream ss;
            ss &lt;&lt; &#34;Numbers &#34; &lt;&lt; numbers[i] &lt;&lt; &#34; and &#34; &lt;&lt; numbers[i] + 1 &lt;&lt; &#34; are great!&#34;;
            std::string s = ss.str();
         }

         auto end = std::chrono::high_resolution_clock::now();
         t1 = std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(end - start).count();
      }

      {
         auto start = std::chrono::high_resolution_clock::now();

         for (std::size_t i = 0; i &lt; numbers.size(); ++i)
         {
            std::string str(100, &#39;\0&#39;);
            sprintf(str.data(), &#34;Numbers %d and %d are great!&#34;, numbers[i], numbers[i] + 1);
         }

         auto end = std::chrono::high_resolution_clock::now();
         t2 = std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(end - start).count();
      }

      {
         auto start = std::chrono::high_resolution_clock::now();

         for (std::size_t i = 0; i &lt; numbers.size(); ++i)
         {
            std::string s;
            std::format_to(std::back_inserter(s), &#34;Numbers {} and {} are great!&#34;, numbers[i], numbers[i] + 1);
         }

         auto end = std::chrono::high_resolution_clock::now();
         t3 = std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(end - start).count();
      }

      {
         auto start = std::chrono::high_resolution_clock::now();

         for (std::size_t i = 0; i &lt; numbers.size(); ++i)
         {
            std::string s = std::format(&#34;Numbers {} and {} are great!&#34;, numbers[i], numbers[i] + 1);
         }

         auto end = std::chrono::high_resolution_clock::now();
         t4 = std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(end - start).count();
      }

      std::println(&#34;{:&lt;10} {:&lt;12.2} {:&lt;7.2} {:&lt;9.2} {:&lt;7.2}&#34;, count, t1 / 1000.0 / count, t2 / 1000.0 / count, t3 / 1000.0 / count, t4 / 1000.0 / count);
   }
}</pre>



<p>The results are in the same range as shown previously (although, again, they vary from one execution to another):</p>



<pre data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">iterations stringstream sprintf format_to format
---------- ------------ ------- --------- ------
1          27           4.7     5.8       0.8
2          8.1          1.4     0.9       0.75
5          3.4          0.8     0.62      0.46
10         4.3          0.82    0.44      0.38
100        1.9          0.45    0.31      0.33
1000       1.9          0.46    0.37      0.35
10000      1.8          0.38    0.29      0.31
100000     1.3          0.26    0.22      0.24
1000000    1.2          0.27    0.23      0.25</pre>



<h2>In which compatibility of formatting is discussed…</h2>



<p>Although in most cases, moving from <code>std::stringstream</code> to <code>std::format</code> is straight forward, there are some things that are not the same and, therefore, require extra work. Examples include formatting pointers and arrays of unsigned characters.</p>



<p>You can easily write the value of a pointer to an output buffer as follows:</p>



<pre data-enlighter-language="cpp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">int a = 42;

std::stringstream ss;
ss &lt;&lt; &#34;address=&#34; &lt;&lt; &amp;a;
std::string text = ss.str();</pre>



<p>The text will have the form <code>&#34;address=00000004D4DAE218&#34;</code>. But this does not work with <code>std::format</code>:</p>



<pre data-enlighter-language="cpp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">int a = 42;

std::string text = std::format(&#34;address={}&#34;, &amp;a); // error, does not know how to format</pre>



<p>This snippet will generate errors (that vary with the compiler) because it does not know how to format the pointer. You can obtain the same result as previously, treating the pointer like a <code>std:size_t</code> value and using a format specifier such as <code>:016X</code> (16 hexadecimal uppercase digits with leading zeros):</p>



<pre data-enlighter-language="cpp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">std::string text = std::format(&#34;address={:016X}&#34;, reinterpret_cast&lt;std::size_t&gt;(&amp;a));</pre>



<p>Now, the result will be the same (although you should keep in mind that for 32-bit the pointers are only 8 hexadecimal digits).</p>



<p>Here is another example with arrays of unsigned characters, that <code>std::stringstream</code> converts to <code>char</code> when writing to the output buffer:</p>



<pre data-enlighter-language="cpp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">unsigned char str[]{3,4,5,6,0};

std::stringstream ss;
ss &lt;&lt; &#34;str=&#34; &lt;&lt; str;
std::string text = ss.str();</pre>



<p>The content of text will be <code>&#34;str=♥♦♣♠&#34;</code>.</p>



<p>Trying the same with <code>std::format</code>, will fail again because it does not know how to format the array:</p>



<pre data-enlighter-language="cpp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">std::string text = std::format(&#34;str={}&#34;, str); // error, does not now how to format</pre>



<p>We can write the content of the array in a loop, as follows:</p>



<pre data-enlighter-language="cpp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">std::string text = &#34;str=&#34;;
for (auto c : str)
   std::format_to(std::back_inserter(text), &#34;{}&#34;, c);</pre>



<p>The content of the text will be <code>&#34;str=34560&#34;</code> because every <code>unsigned char</code> is written as such to the output buffer, without any casting. To obtain the same result as previously, you need to perform a cast explicitly:</p>



<pre data-enlighter-language="cpp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">std::string text = &#34;str=&#34;;
for (auto c : str)
   std::format_to(std::back_inserter(text), &#34;{}&#34;, static_cast&lt;char&gt;(c));</pre>



<h2>Bonus talk</h2>



<p>If you’re formatting text to be written to the output console and use the result of <code>std::format</code> / <code>std::format_to</code> with <code>std::cout</code> (or other alternatives) there is no need for that in C++23, which introduced <a href="https://en.cppreference.com/w/cpp/io/print" target="_blank" rel="noopener" title="">std::print</a> and <a href="https://en.cppreference.com/w/cpp/io/println" target="_blank" rel="noopener" title="">std::println</a>:</p>



<pre data-enlighter-language="cpp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">int severity = 1;
unsigned error = 42;
reason = &#34;access denied&#34;;

std::println(&#34;severity={},error={},reason={}&#34;, severity, error, reason);</pre>





	</div><!-- .entry-content -->

	</article></div>
  </body>
</html>
