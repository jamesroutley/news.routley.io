<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://pythonspeed.com/articles/faster-cython-simd/">Original</a>
    <h1>Speeding up Cython with SIMD</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
      <p>Cython allows you to write compiled extensions for Python, by translating Python-y code to C or C++.
Often you’ll use it to speed up your software, and it’s especially useful for implementing small data science or scientific computing algorithms.</p>

<p>But what happens when Cython is too slow?
Often there’s still speed improvements you can do.
In a previous article we focused on examples of <a href="https://pythonspeed.com/articles/optimizing-dithering/">optimizing your code</a> to take advantage of things like instruction-level parallelism.</p>

<p>In this article, we’ll focus on another CPU feature, Single Instruction Multiple Data or SIMD, specifically in the context of Cython.
As well see, in some situations using SIMD can happen with only minimal changes to your code.</p>

<blockquote>
  <p><strong>Parts of this article are excerpted from a book I’m working on that will help <a href="https://pythonspeed.com/products/lowlevelcode/">teach you how to optimize low-level code</a>, the kind of code you’d write with Cython, C, or Rust.</strong>
The goal is to help data scientists and scientists who normally write Python to understand how to make their compiled code faster.</p>
</blockquote>

<!-- TEASER_END -->

<h2 id="what-is-simd">What is SIMD?</h2>

<p>Single Instruction Multiple Data, or SIMD, are CPU instructions that can execute the same operation on a sequence primitive values (integers or floats) that are stored next to each other in memory, using a single instruction.
The compiler needs to explicitly generate these special instructions, which as we’ll see can make it harder to utilize this functionality.</p>

<p>For example, if we want to multiply four consecutive integers in an array by the same constant, we can do that with a single SIMD CPU instruction instead of with 4 normal CPU instructions.
Reducing the number of CPU instructions by a factor of 4 can lead to a significant speedup!</p>

<h2 id="three-ways-to-use-simd">Three ways to use SIMD</h2>

<p>If you want to use SIMD, there are different ways you can get the compiler to generate these specialized CPU instructions:</p>

<ol>
  <li><strong>Intrinsics:</strong> You directly tell the compiler to use specific CPU instructions, using special compiler features called “intrinsics”.
You can do this with Cython, but it’s not portable.
For example, x86-64 CPU instructions are different than ARM CPU instructions.</li>
  <li><strong>Auto-vectorization:</strong> Compilers can generate SIMD instructions automatically, especially if you structure your code appropriately.
Because this relies on compiler heuristics you have less control, and different compiler versions might give different results.
(Don’t confuse this with the Python meaning of “vectorized”; in the context of low-level languages like C, “vectorized” is another word for SIMD.)</li>
  <li><strong>SIMD libraries:</strong> C++ has libraries available providing data structures that will use SIMD for their mathematical operations.
This gives you more abstraction than intrinsics, while being more reliable than auto-vectorization.
Cython can probably use these, but we won’t be covering them here.</li>
</ol>

<p>In this article we’ll focus on using auto-vectorization: getting the compiler to generate SIMD instructions for you.</p>

<h2 id="our-starting-code">Our starting code</h2>

<p>We’ll start with the following Cython extension:</p>

<div><div><pre><code><span>import</span> <span>numpy</span> <span>as</span> <span>np</span>
<span>cimport</span> <span>numpy</span> <span>as</span> <span>cnp</span>

<span>def</span> <span>average_arrays_1</span><span>(</span>
    <span>cnp</span><span>.</span><span>float32_t</span><span>[:]</span> <span>arr1</span><span>,</span>
    <span>cnp</span><span>.</span><span>float32_t</span><span>[:]</span> <span>arr2</span>
<span>):</span>
    <span>out</span> <span>=</span> <span>np</span><span>.</span><span>empty</span><span>((</span><span>len</span><span>(</span><span>arr1</span><span>),</span> <span>),</span> <span>dtype</span><span>=</span><span>np</span><span>.</span><span>float32</span><span>)</span>
    <span>cdef</span> <span>cnp</span><span>.</span><span>float32_t</span><span>[:]</span> <span>out_view</span> <span>=</span> <span>out</span>
    <span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>len</span><span>(</span><span>arr1</span><span>)):</span>
        <span>out_view</span><span>[</span><span>i</span><span>]</span> <span>=</span> <span>(</span><span>arr1</span><span>[</span><span>i</span><span>]</span> <span>+</span> <span>arr2</span><span>[</span><span>i</span><span>])</span> <span>/</span> <span>2</span>
    <span>return</span> <span>out</span>
</code></pre></div></div>

<p>The <code>cnp.float32_t[:]</code> is the <a href="https://cython.readthedocs.io/en/latest/src/userguide/numpy_tutorial.html">memoryview Cython API</a>; we’re using it on all arrays to make sure Cython has an easier time translating the code to C.
This ensures we’re using fast low-level operations instead of generic “index some random Python object” operations that would be no faster than normal Python.</p>

<p>We want to measure the speed of our function in two situations:</p>

<ul>
  <li>Two arrays where all the memory is contiguous, linear memory.</li>
  <li>Two <a href="https://pythonspeed.com/articles/numpy-memory-views/"><em>views</em></a> of arrays, where we’re grabbing only every 16th item, using a NumPy feature called “strides”.
The views the code will be averaging will not have entries next to each other in memory; our code will need to skip and do every 16th item.</li>
</ul>

<p>To give an example of what I mean in the latter case, in the following snippet we grab every 2nd item.
The object we create is a view, meaning we’re <em>not</em> copying the memory.
Notice that if we mutate the view, it affects the original array:</p>

<div><div><pre><code><span>&gt;&gt;&gt;</span> <span>import</span> <span>numpy</span> <span>as</span> <span>np</span>
<span>&gt;&gt;&gt;</span> <span>arr</span> <span>=</span> <span>np</span><span>.</span><span>array</span><span>([</span><span>0</span><span>,</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>,</span> <span>6</span><span>])</span>
<span>&gt;&gt;&gt;</span> <span>view</span> <span>=</span> <span>arr</span><span>[::</span><span>2</span><span>]</span>
<span>&gt;&gt;&gt;</span> <span>view</span>
<span>array</span><span>([</span><span>0</span><span>,</span> <span>2</span><span>,</span> <span>4</span><span>,</span> <span>6</span><span>])</span>
<span>&gt;&gt;&gt;</span> <span>view</span><span>[</span><span>1</span><span>]</span> <span>=</span> <span>100</span>
<span>&gt;&gt;&gt;</span> <span>arr</span>
<span>array</span><span>([</span>  <span>0</span><span>,</span>   <span>1</span><span>,</span> <span>100</span><span>,</span>   <span>3</span><span>,</span>   <span>4</span><span>,</span>   <span>5</span><span>,</span>   <span>6</span><span>])</span>
</code></pre></div></div>

<p>Here’s our benchmark script:</p>

<div><div><pre><code><span>from</span> <span>time</span> <span>import</span> <span>time</span>
<span>import</span> <span>numpy</span> <span>as</span> <span>np</span>
<span>import</span> <span>sys</span>
<span>import</span> <span>simd_example</span>

<span># Use the first command-line argument to choose which
# function to call:
</span><span>average_arrays</span> <span>=</span> <span>getattr</span><span>(</span><span>simd_example</span><span>,</span> <span>sys</span><span>.</span><span>argv</span><span>[</span><span>1</span><span>])</span>


<span>def</span> <span>timeit</span><span>(</span><span>title</span><span>,</span> <span>arr1</span><span>,</span> <span>arr2</span><span>):</span>
    <span>start</span> <span>=</span> <span>time</span><span>()</span>
    <span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>1_000</span><span>):</span>
        <span>out</span> <span>=</span> <span>average_arrays</span><span>(</span><span>arr1</span><span>,</span> <span>arr2</span><span>)</span>
    <span>elapsed</span> <span>=</span> <span>(</span><span>time</span><span>()</span> <span>-</span> <span>start</span><span>)</span> <span>/</span> <span>1_000</span>
    <span>print</span><span>(</span><span>f</span><span>&#34;Time per call, </span><span>{</span><span>title</span><span>}</span><span>: </span><span>{</span><span>elapsed</span> <span>*</span> <span>1000</span><span>:.</span><span>2</span><span>}</span><span> ms&#34;</span><span>)</span>


<span># Arrays laid out linearly in memory:
</span><span>ARR1</span> <span>=</span> <span>np</span><span>.</span><span>random</span><span>.</span><span>random</span><span>((</span><span>1_000_000</span><span>,)).</span><span>astype</span><span>(</span><span>np</span><span>.</span><span>float32</span><span>)</span>
<span>ARR2</span> <span>=</span> <span>np</span><span>.</span><span>random</span><span>.</span><span>random</span><span>((</span><span>1_000_000</span><span>,)).</span><span>astype</span><span>(</span><span>np</span><span>.</span><span>float32</span><span>)</span>
<span>timeit</span><span>(</span><span>&#34;contiguous&#34;</span><span>,</span> <span>ARR1</span><span>,</span> <span>ARR2</span><span>)</span>

<span># Arrays where we grab every 16th item:
</span><span>ARR3</span> <span>=</span> <span>np</span><span>.</span><span>random</span><span>.</span><span>random</span><span>((</span><span>16_000_000</span><span>,)).</span><span>astype</span><span>(</span><span>np</span><span>.</span><span>float32</span><span>)</span>
<span>ARR4</span> <span>=</span> <span>np</span><span>.</span><span>random</span><span>.</span><span>random</span><span>((</span><span>16_000_000</span><span>,)).</span><span>astype</span><span>(</span><span>np</span><span>.</span><span>float32</span><span>)</span>
<span>timeit</span><span>(</span><span>&#34;strided&#34;</span><span>,</span> <span>ARR3</span><span>[::</span><span>16</span><span>],</span> <span>ARR4</span><span>[::</span><span>16</span><span>])</span>
</code></pre></div></div>

<h2 id="were-not-using-simd">We’re not using SIMD!</h2>

<p>On Intel CPUs, if you’re using floating point operations you can check if SIMD is being used by inspecting CPU counters.
On Linux these are exposed by the <a href="https://perf.wiki.kernel.org/index.php/Main_Page"><code>perf</code> program</a>.
For integer operations there are more difficult ways of checking, for example looking at the generated assembly code, but we’ll do it the easy way.
My CPU doesn’t support 512-bit SIMD, so we’re only looking at 128- and 256-bit SIMD, like this:</p>

<div><div><pre><code><span>$</span><span> </span>perf <span>stat</span> <span>-e</span> instructions:u,fp_arith_inst_retired.128b_packed_single:u,fp_arith_inst_retired.256b_packed_single:u <span>--</span> python benchmark.py average_arrays_1
<span>Time per call, contiguous: 0.57 ms
Time per call, strided: 4.2 ms

 Performance counter stats for &#39;python benchmark.py average_arrays_1&#39;:

    31,773,910,107      cpu_core/instructions:u/
       459,588,037      cpu_atom/instructions:u/
                 0      cpu_core/fp_arith_inst_retired.128b_packed_single:u/
                 0      cpu_core/fp_arith_inst_retired.256b_packed_single:u/
</span></code></pre></div></div>

<p>The “_single” suffix means 32-bit floats; for 64-bit floats we’d want the “_double” suffix.
It looks like there were no “packed” (i.e SIMD) operations done at all.
Let’s fix that.</p>

<h2 id="step-1-enabling-auto-vectorization-in-the-compiler">Step 1. Enabling auto-vectorization in the compiler</h2>

<p>Why no SIMD?
Recall that to use SIMD the compiler has to generate special instructions.
Specifically:</p>

<ol>
  <li>We want to use auto-vectorization, where the compiler does this automatically.</li>
  <li>Which means the compiler has to successfully use its heuristics to generate SIMD instructions.</li>
</ol>

<p>As it turns out, by default on Linux Python uses the <code>-O2</code> compiler optimization level for extensions, which doesn’t even try to do auto-vectorization.
So we’ll want to switch to <code>-O3</code> optimization level to turn this and other optimizations on.</p>

<p>You can do this in the <code>setup.py</code> config for Cython, but we’ll just set an environment variable and recompile:</p>

<div><div><pre><code><span>$</span><span> </span><span>export </span><span>CFLAGS</span><span>=</span><span>&#34;-O3&#34;</span>
<span>$</span><span> </span>pip <span>install</span> <span>.</span>
</code></pre></div></div>

<p>Unfortunately, if we rerun our benchmark we get the same results as above.
This suggests the compiler heuristics are failing to figure out how to use SIMD with the code.</p>

<h2 id="step-2-disabling-bounds-checks-and-other-implicit-conditionals">Step 2. Disabling bounds checks and other implicit conditionals</h2>

<p>Recall that SIMD does the same operation on a series of values.
For example, we’re hoping the compiler will decide to use SIMD instructions to add one set of float32s to another set of float32s with a single CPU instruction.</p>

<p>Sometimes the compiler won’t be able to use SIMD instructions.
For our purposes, if you have branches—<code>if</code> statements and other conditional control flow—that makes it harder to do the same operation with a single instruction.
If the branch decides to exit the loop on the first item, how could a single CPU instruction handle the remaining items?</p>

<p>Our code doesn’t have any explicit conditionals, so that’s not a problem.
It does, however, have some implicit conditionals: <a href="https://cython.readthedocs.io/en/latest/src/userguide/numpy_tutorial.html#tuning-indexing-further">bounds checking and index wrapping</a>.</p>

<ol>
  <li>In order to prevent reading from (or writing to!) invalid memory addresses, Cython adds a bounds check to each array lookup to make sure you haven’t gone too far.
It raises an exception if the index is out bounds—in other words, it’s a branch.</li>
  <li>In order to support indexing with negative numbers, the way Python does, Cython also adds branches.</li>
</ol>

<p>On a good day the compiler might optimize some of these away, but in this case we probably will have to disable them.
This means we have to be extra careful, because the compiler isn’t helping us catch bugs anymore!</p>

<blockquote>
  <p><strong>Note:</strong> Turning off bounds checking is a terrible idea.
It’s a recipe for crashes, security problems, and even worse: silent failures where you get wrong results without knowing it.</p>

  <p>When using Rust people have come up with ways to keep bounds checking on while <a href="https://shnatsel.medium.com/how-to-avoid-bounds-checks-in-rust-without-unsafe-f65e618b4c1e">giving hints to the compiler</a> so it can optimize them out of existence.
Figuring out if this is possible in Cython is something I hope to investigate.</p>
</blockquote>

<p>Here’s our new version:</p>

<div><div><pre><code><span>import</span> <span>numpy</span> <span>as</span> <span>np</span>
<span>cimport</span> <span>numpy</span> <span>as</span> <span>cnp</span>
<span>cimport</span> <span>cython</span>

<span>@</span><span>cython</span><span>.</span><span>boundscheck</span><span>(</span><span>False</span><span>)</span>
<span>@</span><span>cython</span><span>.</span><span>wraparound</span><span>(</span><span>False</span><span>)</span>
<span>def</span> <span>average_arrays_2</span><span>(</span>
    <span>cnp</span><span>.</span><span>float32_t</span><span>[:]</span> <span>arr1</span><span>,</span>
    <span>cnp</span><span>.</span><span>float32_t</span><span>[:]</span> <span>arr2</span>
<span>):</span>
    <span>if</span> <span>len</span><span>(</span><span>arr1</span><span>)</span> <span>!=</span> <span>len</span><span>(</span><span>arr2</span><span>):</span>
        <span>raise</span> <span>ValueError</span><span>(</span><span>&#34;Arrays must be the same size&#34;</span><span>)</span>
    <span>out</span> <span>=</span> <span>np</span><span>.</span><span>empty</span><span>((</span><span>len</span><span>(</span><span>arr1</span><span>),</span> <span>),</span> <span>dtype</span><span>=</span><span>np</span><span>.</span><span>float32</span><span>)</span>
    <span>cdef</span> <span>cnp</span><span>.</span><span>float32_t</span><span>[:]</span> <span>out_view</span> <span>=</span> <span>out</span>
    <span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>len</span><span>(</span><span>arr1</span><span>)):</span>
        <span>out_view</span><span>[</span><span>i</span><span>]</span> <span>=</span> <span>(</span><span>arr1</span><span>[</span><span>i</span><span>]</span> <span>+</span> <span>arr2</span><span>[</span><span>i</span><span>])</span> <span>/</span> <span>2</span>
    <span>return</span> <span>out</span>
</code></pre></div></div>

<p>The new version runs about 15% faster in the linear case, which is nice, but it’s still not using any SIMD.
(See the end of the article for the actual numbers.)</p>

<h2 id="step-3-getting-rid-of-stride-support">Step 3. Getting rid of stride support</h2>

<p>It’s time to inspect the C code that Cython generates from the <code>.pyx</code> file.
We can annotate the code with the <code>cythonize</code> tool, and that gives us an HTML file we can open.</p>

<div><div><pre><code><span>$</span><span> </span>cythonize <span>--annotate</span> src/simd_example/_extension.pyx
<span>$</span><span> </span><span>ls </span>src/simd_example/<span>*</span>.html
<span>src/simd_example/_extension.html
</span></code></pre></div></div>

<p>The report maps Cython code to C code, and if we look at the C code generated for <code>out_view[i] = (arr1[i] + arr2[i]) / 2</code> we see:</p>

<div><div><pre><code><span>*</span><span>((</span><span>__pyx_t_5numpy_float32_t</span> <span>*</span><span>)</span> <span>(</span> <span>/* dim=0 */</span> <span>(</span><span>__pyx_v_out_view</span><span>.</span><span>data</span> <span>+</span> <span>__pyx_t_13</span> <span>*</span> <span>__pyx_v_out_view</span><span>.</span><span>strides</span><span>[</span><span>0</span><span>])</span> <span>))</span> <span>=</span> <span>(((</span><span>*</span><span>((</span><span>__pyx_t_5numpy_float32_t</span> <span>*</span><span>)</span> <span>(</span> <span>/* dim=0 */</span> <span>(</span><span>__pyx_v_arr1</span><span>.</span><span>data</span> <span>+</span> <span>__pyx_t_11</span> <span>*</span> <span>__pyx_v_arr1</span><span>.</span><span>strides</span><span>[</span><span>0</span><span>])</span> <span>)))</span> <span>+</span> <span>(</span><span>*</span><span>((</span><span>__pyx_t_5numpy_float32_t</span> <span>*</span><span>)</span> <span>(</span> <span>/* dim=0 */</span> <span>(</span><span>__pyx_v_arr2</span><span>.</span><span>data</span> <span>+</span> <span>__pyx_t_12</span> <span>*</span> <span>__pyx_v_arr2</span><span>.</span><span>strides</span><span>[</span><span>0</span><span>])</span> <span>))))</span> <span>/</span> <span>2</span><span>.</span><span>0</span><span>);</span>
</code></pre></div></div>

<p>That’s a lot more complicated than our Cython code… because of strides.
Basically, Cython has to handle the case where we passed in a NumPy view that is not reading <em>all</em> the memory, but instead skips every N items.
It can’t assume the memory is contiguous.</p>

<p>If we have non-contiguous memory, from the compiler’s auto-vectorization perspective using SIMD is likely to be a lot less compelling, given different items might well be very distant from each other in memory.
And even if we can’t optimize that case, contiguous memory situations ought to be faster.
So as a first pass, let’s tell Cython to only support contiguous memory, indicated by switching <code>float32_t[:]</code> to <code>float32_t[::1]</code>.
<a href="https://cython.readthedocs.io/en/latest/src/userguide/memoryviews.html#brief-recap-on-c-fortran-and-strided-memory-layouts">See the Cython docs for more details on this syntax</a>.</p>

<div><div><pre><code><span>@</span><span>cython</span><span>.</span><span>boundscheck</span><span>(</span><span>False</span><span>)</span>
<span>@</span><span>cython</span><span>.</span><span>wraparound</span><span>(</span><span>False</span><span>)</span>
<span>def</span> <span>average_arrays_3</span><span>(</span><span>cnp</span><span>.</span><span>float32_t</span><span>[::</span><span>1</span><span>]</span> <span>arr1</span><span>,</span> <span>cnp</span><span>.</span><span>float32_t</span><span>[::</span><span>1</span><span>]</span> <span>arr2</span><span>):</span>
    <span>if</span> <span>len</span><span>(</span><span>arr1</span><span>)</span> <span>!=</span> <span>len</span><span>(</span><span>arr2</span><span>):</span>
        <span>raise</span> <span>ValueError</span><span>(</span><span>&#34;Arrays must be the same size&#34;</span><span>)</span>
    <span>out</span> <span>=</span> <span>np</span><span>.</span><span>empty</span><span>((</span><span>len</span><span>(</span><span>arr1</span><span>),</span> <span>),</span> <span>dtype</span><span>=</span><span>np</span><span>.</span><span>float32</span><span>)</span>
    <span>cdef</span> <span>cnp</span><span>.</span><span>float32_t</span><span>[::</span><span>1</span><span>]</span> <span>out_view</span> <span>=</span> <span>out</span>
    <span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>len</span><span>(</span><span>arr1</span><span>)):</span>
        <span>out_view</span><span>[</span><span>i</span><span>]</span> <span>=</span> <span>(</span><span>arr1</span><span>[</span><span>i</span><span>]</span> <span>+</span> <span>arr2</span><span>[</span><span>i</span><span>])</span> <span>/</span> <span>2</span>
    <span>return</span> <span>out</span>
</code></pre></div></div>

<p>The generated C code no longer refers to strides:</p>

<div><div><pre><code><span>*</span><span>((</span><span>__pyx_t_5numpy_float32_t</span> <span>*</span><span>)</span> <span>(</span> <span>/* dim=0 */</span> <span>((</span><span>char</span> <span>*</span><span>)</span> <span>(((</span><span>__pyx_t_5numpy_float32_t</span> <span>*</span><span>)</span> <span>__pyx_v_out_view</span><span>.</span><span>data</span><span>)</span> <span>+</span> <span>__pyx_t_13</span><span>))</span> <span>))</span> <span>=</span> <span>(((</span><span>*</span><span>((</span><span>__pyx_t_5numpy_float32_t</span> <span>*</span><span>)</span> <span>(</span> <span>/* dim=0 */</span> <span>((</span><span>char</span> <span>*</span><span>)</span> <span>(((</span><span>__pyx_t_5numpy_float32_t</span> <span>*</span><span>)</span> <span>__pyx_v_arr1</span><span>.</span><span>data</span><span>)</span> <span>+</span> <span>__pyx_t_11</span><span>))</span> <span>)))</span> <span>+</span> <span>(</span><span>*</span><span>((</span><span>__pyx_t_5numpy_float32_t</span> <span>*</span><span>)</span> <span>(</span> <span>/* dim=0 */</span> <span>((</span><span>char</span> <span>*</span><span>)</span> <span>(((</span><span>__pyx_t_5numpy_float32_t</span> <span>*</span><span>)</span> <span>__pyx_v_arr2</span><span>.</span><span>data</span><span>)</span> <span>+</span> <span>__pyx_t_12</span><span>))</span> <span>))))</span> <span>/</span> <span>2</span><span>.</span><span>0</span><span>);</span>
</code></pre></div></div>

<p>We recompile and run our benchmark:</p>

<div><div><pre><code>Time per call, contiguous: 0.24 ms
Traceback (most recent call last):
  File &#34;/home/itamarst/devel/simd-profiles/benchmark.py&#34;, line 28, in &lt;module&gt;
    timeit(&#34;strided&#34;, ARR3[::16], ARR4[::16])
  File &#34;/home/itamarst/devel/simd-profiles/benchmark.py&#34;, line 14, in timeit
    out = average_arrays(arr1, arr2)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File &#34;src/simd_example/_extension.pyx&#34;, line 41, in simd_example._extension.average_arrays_3
    def average_arrays_3(cnp.float32_t[::1] arr1, cnp.float32_t[::1] arr2):
  File &#34;&lt;stringsource&gt;&#34;, line 663, in View.MemoryView.memoryview_cwrapper
  File &#34;&lt;stringsource&gt;&#34;, line 353, in View.MemoryView.memoryview.__cinit__
ValueError: ndarray is not C-contiguous

 Performance counter stats for &#39;python benchmark.py average_arrays_3&#39;:

     4,940,110,700      cpu_core/instructions:u/
        66,742,512      cpu_atom/instructions:u/
       500,000,000      cpu_core/fp_arith_inst_retired.128b_packed_single:u/
                 0      cpu_core/fp_arith_inst_retired.256b_packed_single:u/
</code></pre></div></div>

<p>The good news:</p>

<ul>
  <li>We’re finally using SIMD!</li>
  <li>We’re now twice as fast when in the contiguous memory case.</li>
</ul>

<p>The bad news is that we can’t handle non-contiguous memory: strided views blow up.
But we can fix that.</p>

<h2 id="step-4-add-back-support-for-strided-memory">Step 4. Add back support for strided memory</h2>

<p>The way we’re going to solve this is by having two versions of the function:</p>

<ul>
  <li>One for contiguous memory, which will use SIMD and run faster.</li>
  <li>The other will fall back to the more generic version, that doesn’t use SIMD.
It’ll be slower, but at least our code will run.</li>
</ul>

<p>To reduce code duplication, we’ll do this with a Cython feature called <a href="https://cython.readthedocs.io/en/latest/src/userguide/fusedtypes.html">“fused types”</a>, which is a simplified version of C++ templates or Rust generics.
Essentially Cython will end up generating two versions of our function, one for each type.</p>

<div><div><pre><code><span># This type will be one of these two underlying types
# at compile time:
</span><span>ctypedef</span> <span>fused</span> <span>float_arr_t</span><span>:</span>
   <span>cnp</span><span>.</span><span>float32_t</span><span>[:]</span>
   <span>cnp</span><span>.</span><span>float32_t</span><span>[::</span><span>1</span><span>]</span>

<span>@</span><span>cython</span><span>.</span><span>boundscheck</span><span>(</span><span>False</span><span>)</span>
<span>@</span><span>cython</span><span>.</span><span>wraparound</span><span>(</span><span>False</span><span>)</span>
<span>cdef</span> <span>average_impl</span><span>(</span>
    <span>float_arr_t</span> <span>arr1</span><span>,</span>
    <span>float_arr_t</span> <span>arr2</span>
<span>):</span>
    <span>out</span> <span>=</span> <span>np</span><span>.</span><span>empty</span><span>((</span><span>len</span><span>(</span><span>arr1</span><span>),</span> <span>),</span> <span>dtype</span><span>=</span><span>np</span><span>.</span><span>float32</span><span>)</span>
    <span>cdef</span> <span>cnp</span><span>.</span><span>float32_t</span><span>[::</span><span>1</span><span>]</span> <span>out_view</span> <span>=</span> <span>out</span>
    <span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>len</span><span>(</span><span>arr1</span><span>)):</span>
        <span>out_view</span><span>[</span><span>i</span><span>]</span> <span>=</span> <span>(</span><span>arr1</span><span>[</span><span>i</span><span>]</span> <span>+</span> <span>arr2</span><span>[</span><span>i</span><span>])</span> <span>/</span> <span>2</span>
    <span>return</span> <span>out</span>

<span>def</span> <span>average_arrays_4</span><span>(</span><span>arr1</span><span>,</span> <span>arr2</span><span>):</span>
    <span>if</span> <span>len</span><span>(</span><span>arr1</span><span>)</span> <span>!=</span> <span>len</span><span>(</span><span>arr2</span><span>):</span>
        <span>raise</span> <span>ValueError</span><span>(</span><span>&#34;Arrays must be the same size&#34;</span><span>)</span>
    <span>if</span> <span>arr1</span><span>.</span><span>data</span><span>.</span><span>contiguous</span> <span>and</span> <span>arr2</span><span>.</span><span>data</span><span>.</span><span>contiguous</span><span>:</span>
        <span>return</span> <span>average_impl</span><span>[</span><span>cnp</span><span>.</span><span>float32_t</span><span>[::</span><span>1</span><span>]](</span><span>arr1</span><span>,</span> <span>arr2</span><span>)</span>
    <span>else</span><span>:</span>
        <span>return</span> <span>average_impl</span><span>[</span><span>cnp</span><span>.</span><span>float32_t</span><span>[:]](</span><span>arr1</span><span>,</span> <span>arr2</span><span>)</span>
</code></pre></div></div>

<p>If we compile this and run our benchmark, we get:</p>

<div><div><pre><code>Time per call, contiguous: 0.24 ms
Time per call, strided: 4.0 ms

 Performance counter stats for &#39;python benchmark.py average_arrays_4&#39;:

    13,953,180,922      cpu_core/instructions:u/
       412,866,119      cpu_atom/instructions:u/
       500,000,000      cpu_core/fp_arith_inst_retired.128b_packed_single:u/
                 0      cpu_core/fp_arith_inst_retired.256b_packed_single:u/
</code></pre></div></div>

<p>Our function is using SIMD when it can, and falling back to a slower path when it can’t.
And it has minimal code duplication.</p>

<h2 id="reviewing-our-results-the-speedup-and-how-we-got-it">Reviewing our results: the speedup and how we got it</h2>

<p>Here’s a comparison of our different versions:</p>

<table>
  <thead>
    <tr>
      <th>Version</th>
      <th>Contiguous run time (ms)</th>
      <th>Strided run time (ms)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Baseline</td>
      <td>0.57</td>
      <td>4.2</td>
    </tr>
    <tr>
      <td><code>-O3</code> compiler flag</td>
      <td>0.57</td>
      <td>4.2</td>
    </tr>
    <tr>
      <td>Disabled bounds checks</td>
      <td>0.46</td>
      <td>4.1</td>
    </tr>
    <tr>
      <td>SIMD for contiguous memory</td>
      <td>0.24</td>
      <td>4.0</td>
    </tr>
  </tbody>
</table>

<p>It’s not clear if the difference in run time for strided arrays is meaningful, but for contiguous arrays our code now runs twice as fast.
And making these changes wasn’t particularly invasive.</p>

<p>To recap, we had to:</p>

<ol>
  <li>Add a <code>-O3</code> compiler flag.
This will work on Linux and macOS compilers.
On Windows the defaults might suffice or you might need to set a similar but different flag, I haven’t checked.</li>
  <li><em>Carefully</em> disable bounds and wraparound checks.
This is where a good test suite is helpful—we made sure to test invalid inputs!</li>
  <li>Make sure Cython can generate the simpler code that contiguous arrays enable.</li>
</ol>

<p>If you’re maintaining Cython code, consider making these changes!
It won’t always be enough to start using SIMD, of course.
This is a simple example where auto-vectorization was very likely to work, and more complex code might fail.
But in many cases it will make your code faster.</p>

<p>If you can’t get auto-vectorization to work, you can:</p>

<ul>
  <li>Enable gcc output of vectorization issues: <code>export CFLAGS=&#34;-O3 -fopt-info-vec-missed&#34;</code> and then run <code>pip install --verbose .</code> so you can see compiler output.</li>
  <li>Try switching to the Clang compiler instead of the default gcc (<code>export CC=clang</code>).
To get hints about the compiler’s decision making process, add <code>-Rpass-analysis=loop-vectorize</code> to CFLAGS.</li>
</ul>

<p>To learn more about SIMD:</p>

<ul>
  <li>Sign up to get notified about the release of <a href="https://pythonspeed.com/products/lowlevelcode/">my upcoming book on optimizing low-level code</a>, which introduces SIMD in more depth, and is the basis for some parts of this chapter.</li>
  <li>The <a href="https://llvm.org/docs/Vectorizers.html">Clang documentation</a> gives a good overview of the various techniques it supports.</li>
  <li>Read the excellent book <a href="https://book.easyperf.net/perf_book"><em>Performance Analysis and Tuning on Modern CPUs</em></a>.</li>
</ul>

  </div></div>
  </body>
</html>
