<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.netmeister.org/blog/basic-network-troubleshooting.html">Original</a>
    <h1>Basic Network Troubleshooting</h1>
    
    <div id="readability-page-1" class="page"><div width="75%">
    <tbody><tr>
      <td>
<p><small>February 12th, 2022</small></p>

<p><img src="https://www.netmeister.org/blog/images/dino.png" alt="Chrome&#39;s
about://dino game" title="about://dino" width="200"/>There are many possible
reasons for why you are unable to connect to a remote
system, and no, it&#39;s <a href="https://twitter.com/jschauma/status/1490894962262691842">not
<em>always</em> the DNS</a>.  Being able to quickly
identify what the most likely cause of the problem is
(or: who would be in a position to fix it) is a useful
skill, yet I often see even senior engineers waste
time chasing false flags and red herrings when certain
problems could quickly be ruled out by a better
understanding of the specific meaning of the various
error messages you might encounter.  </p>

<p>The best way to cut down on wasted time is to
quickly answer the question: &#34;<em><b>Is it the DNS,
the network, or the app?</b></em>&#34;  To help you answer
this question and troubleshoot more efficiently,
here&#39;s a quick explanation of the most common error
scenarios and how to quickly identify at least
<em>where</em> the problem is likely to lie, all based
on this one weird trick: reading and understanding the
error message.</p>

<hr/>

<h3><a name="unable-to-resolve">Unable to resolve</a></h3>

<p>Ok, so sometimes it really is the DNS:</p>

<div><pre>macos$ ssh foo.netmeister.org
ssh: Could not resolve hostname foo.netmeister.org: nodename nor servname provided, or not known

or

netbsd$ ssh foo.netmeister.org
ssh: Could not resolve hostname foo.netmeister.org: No address associated with hostname
$ </pre></div>

<p>Hooold it.  No need to whip out <tt>ping(8)</tt>,
<tt>traceroute(8)</tt>, and <tt>tcpdump(1)</tt> just
yet -- this is an easy one.  It tells you right there
what the problem is: <em>could not resolve</em>.  That
is, you never even got to the point where your system
tried to send any packets to the remote side, because
it couldn&#39;t translate the name <span><tt>foo.netmeister.org</tt></span> into an IP
address. (Different tools and even different versions
of the same tool on different platforms may give
slightly different error messages, as shown
above.)</p>

<p>In this case, you want to find out <em>why</em> you
can&#39;t resolve the name.  For starters, make sure you
don&#39;t have a typo there: it&#39;s easy to accidentally
slip in an extra letter or fatfinger a domain name.
But suppose you are sure you have the right name, what
can you check?</p>

<h4>Try the authoritative nameserver</h4>

<p>First, see whether the name actually exists in the
authoritative nameserver in question:</p>

<div><pre>$ dig +short netmeister.org ns
ns-181-a.gandi.net.
ns-143-b.gandi.net.
ns-179-c.gandi.net.
$ dig +noall +answer +comments @ns-179-c.gandi.net. foo.netmeister.org
;; Got answer:
;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, <span>status: NOERROR</span>, id: 25060
;; flags: qr aa rd; QUERY: 1, ANSWER: 0, AUTHORITY: 1, ADDITIONAL: 1
;; WARNING: recursion requested but not available

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 1232
$ </pre></div>

<p><tt><span>NOERROR</span></tt> indicates that there was,
well, no error on the DNS server&#39;s side, meaning the
query was correctly answered.  Ok, so we&#39;ve
established that <span><tt>foo.netmeister.org</tt></span> simply
doesn&#39;t exist in the DNS, so your journey ends
here.  That&#39;s right, that&#39;s it: fix the DNS entry or
talk to whomever owns the domain.</p>

<h4>But what if you can&#39;t reach the authoritative
nameserver?</h4>

<div><pre>$ dig +noall +answer +comments @ns-179-c.gandi.net. foo.netmeister.org
[ time elapses ]
;; connection timed out; no servers could be reached
$ </pre></div>

<p>Does this mean that the problem is with the
authoritative nameserver?  Not necessarily!  It&#39;s
possible that it&#39;s only <em>your</em> system that
can&#39;t talk to the NS, but that your configured
resolver (e.g., from <span><tt>/etc/resolv.conf</tt></span>)
<em>can</em>.  This may be the case if, for example,
your network administrator blocks outgoing DNS
traffic to hosts other than the configured
resolvers.</p>

<p>Note: it may also be the case that you <em>can</em>
talk to the <em>second-level domain</em> authoritative
nameserver (<span><tt>netmeister.org</tt></span> in this case),
but the name you&#39;re trying to resolve is under a
<em>subdomain</em> with a <em>different</em>
authoritative nameserver:</p>

<div><pre>$ dig +noall +answer +comments @ns-179-c.gandi.net. bar.dns.netmeister.org
;; Got answer:
;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 39531
;; flags: qr rd; QUERY: 1, ANSWER: 0, AUTHORITY: 2, ADDITIONAL: 3
;; WARNING: recursion requested but not available

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 1232
$ dig +short dns.netmeister.org ns
panix.netmeister.org
$ dig +noall +answer @panix.netmeister.org bar.dns.netmeister.org
[ time elapses ]
;; connection timed out; no servers could be reached
$ </pre></div>

<p>What can you do to verify whether the name exists
without asking your resolver (which we know failed to
resolve the name, since that&#39;s how we started our
journey here) and without making outbound port 53 UDP
calls?  Here you have a few options:</p>

<h4>Use TCP</h4>

<p>DNS is not just port 53 <em>UDP</em>, and you may
be able to simply ask the authoritative via TCP:</p>

<div><pre>$ dig <span>+tcp</span> +noall +answer +comments @ns-179-c.gandi.net. foo.netmeister.org
;; communications error to 2604:3400:aaac::b4#53: host unreachable
</pre></div>

<p>Alas, no luck.  Our query is still blocked.</p>

<h4>Try DNS-over-HTTPs</h4>

<p>You can try to use <a href="https://en.wikipedia.org/wiki/DNS_over_HTTPS">DNS
over HTTPs</a> to one of the public DoH resolvers,
such as e.g., Google&#39;s or Cloudflare&#39;s DNS servers.
<tt>dig(1)</tt> supports DoH <a href="https://www.isc.org/blogs/bind-doh-update-2021/">since
March 2021</a> via the <span><tt>+https</tt></span> flag, but if your
<tt>dig(1)</tt> is older than that, you can also use
the JSON API directly:</p>

<div><pre>$ curl -s &#39;https://dns.google/resolve?name=foo.netmeister.org&amp;type=a&#39; | jq &#39;.Answer&#39;
null
$ curl -s -H &#39;accept: application/dns-json&#39; &#39;https://cloudflare-dns.com/dns-query?name=foo.netmeister.org&#39; | jq &#39;.Answer&#39;
null
</pre></div>

<p>This doesn&#39;t let you ask the <em>authoritative</em>
resolver, but it lets you confirm that at least
<em>some</em> other nameserver can resolve the hostname
you are experiencing problems with.</p>

<h4>Try DNS-over-TLS</h4>

<p>If you know a public resolver that supports <a href="https://en.wikipedia.org/wiki/DNS_over_TLS">DNS
over TLS</a>, then you can try that.  Different
command-line tools such as e.g., <tt><a href="https://www.knot-dns.cz/docs/2.6/html/man_kdig.html">kdig(1)</a></tt>
or <tt><a href="https://dns.lookup.dog/">dog(1)</a></tt> exist,
and e.g., <tt>dig(1)</tt> has support for DoT via the
<span><tt>+tls</tt></span> flag <a href="https://bind9.readthedocs.io/en/v9_18_0/notes.html">since
version 9.18.0</a>, but if you want to go really
bare-bones, you can even use <tt>stunnel(1)</tt>:</p>

<div><pre>$ cat &gt;/tmp/dot &lt;&lt;EOF
[dns]
client = yes
accept = 127.0.0.1:5353
connect = 8.8.8.8:853
CAfile = /etc/ssl/cert.pem
verifyChain = yes
checkIP = 8.8.8.8
EOF
$ stunnel /tmp/dot
$ dig -p 5353 +tcp @127.0.0.1 foo.netmeister.org
</pre></div>

<p>Some authoritative nameservers may even support DoT
directly, so you may not need to use a public resolver
like Google&#39;s DNS server here, which then would get
you an authoritative answer, but even asking
<tt>8.8.8.8</tt>, you can once again confirm that what
your resolver does is in line with (or different from)
what others do.</p>

<h4>Compare various public resolvers</h4>

<p>Taking this concept a step further, you may want to
compare the results across <em>multiple</em> different
public resolvers.  Good thing I have <a href="https://www.netmeister.org/puddy/">just the tool
for you</a>!  You can either make a simple HTTP GET
request:</p>

<div><pre>$ curl -s &#39;https://www.netmeister.org/puddy/?name=foo.netmeister.org&amp;format=json&#39; | jq &#39;.results&#39;
{
  &#34;2001:4860:4860::8888&#34;: {
    &#34;CNAME&#34;: {
      &#34;status&#34;: &#34;NOERROR&#34;
    },
    &#34;AAAA&#34;: {
      &#34;status&#34;: &#34;NOERROR&#34;
    },
    &#34;comment&#34;: &#34;Google Public DNS&#34;,
    &#34;A&#34;: {
      &#34;status&#34;: &#34;NOERROR&#34;
    }
  },
[...]
</pre></div>

<p>...or you can run the <a href="https://github.com/jschauma/puddy">command-line tool</a>
directly:</p>

<div><pre>$ puddy -1 foo.netmeister.org a aaaa
2001:470:20::2 (Hurricane Electric)
        A: [NO RECORD FOUND]
        AAAA: [NO RECORD FOUND]                                                                     
2001:4860:4860::8888 (Google)
        A: [NO RECORD FOUND]
        AAAA: [NO RECORD FOUND]                                                                     
2606:4700:4700::1001 (Cloudflare)
        A: [NO RECORD FOUND]
        AAAA: [NO RECORD FOUND]                                                                     
2620:0:ccc::2 (OpenDNS)
        A: [NO RECORD FOUND]
        AAAA: [NO RECORD FOUND]                                                                     
2620:fe::fe (Quad9)
        A: [NO RECORD FOUND]
        AAAA: [NO RECORD FOUND]                                                                     
$ </pre></div>

<p>...although that does again require you to be able
to talk to the different resolvers on port 53.  Either
way, this offers you another way of checking if other
people are seeing the same result as you do on your
local system, which can be helpful.</p>

<h3><a name="etc-hosts"></a>Eliminate <tt>/etc/hosts</tt> confusion</h3>

<p>
A common source of frustration is an apparent
discrepancy between a DNS lookup and behavior seen by
other tools.  This can often be traced back to a local
change made to <tt>/etc/hosts</tt>, and would exhibit
itself like this:
</p>

<div><pre>$ host foo.netmeister.org
Host foo.netmeister.org not found: 3(NXDOMAIN)
$ ssh foo.netmeister.org
ssh: connect to host foo.netmeister.org port 22: Connection refused

or, even more frustratingly:

$ host bar.dns.netmeister.org
bar.dns.netmeister.org has address 198.51.100.1
bar.dns.netmeister.org has IPv6 address <span>2001:db8::c2de:2d22:5ca1:2727</span>
$ ping6 bar.dns.netmeister.org
PING6(56=40+8+8 bytes) 2001:470:30:84:e276:63ff:fe72:3900 --&gt; <span>2001:db8::9a6f:ba98:b763:574e</span>
ping6: sendmsg: Network is unreachable
ping6: wrote 2001:db8::9a6f:ba98:b763:574e 16 chars, ret=-1
ping6: sendmsg: Network is unreachable
ping6: wrote 2001:db8::9a6f:ba98:b763:574e 16 chars, ret=-1
^C
--- 2001:db8::9a6f:ba98:b763:574e ping6 statistics ---                                              
2 packets transmitted, 0 packets received, 100.0% packet loss                                       
$ grep bar.dns.netmeister.org /etc/hosts                                                            
<span>2001:db8::9a6f:ba98:b763:574e</span>   bar.dns.netmeister.org
$ </pre></div>

<p> That is, you observe one address (or no address)
when performing an explicit DNS lookup (<span>2001:db8::c2de:2d22:5ca1:2727</span>), but
another (<span>2001:db8::9a6f:ba98:b763:574e</span>)
when running commands that use the normal
<tt>gethostbyname(3)</tt> library functions, which (in
most cases) will <em>first</em> try
<tt>/etc/hosts</tt>.  </p>

<p> If you see this, fix <tt>/etc/hosts</tt>, yell at
the person who made that change (probably you
yourself), and then <a href="https://twitter.com/jschauma/status/1258097612290318337">make
that file immutable</a> (e.g., <span><tt>sudo chflags
schg /etc/hosts</tt></span> or <span><tt>sudo chattr +i
/etc/hosts</tt></span>).  </p>

<h3><a name="resolution-failure"></a>Other name resolution failures</h3>

<p>Here&#39;s another way that hostname resolution may
fail without it being a DNS failure, strictly
speaking:</p>

<div><pre>$ ssh foo.netmeister.org
ssh: Could not resolve hostname foo.netmeister.org: Temporary failure in name resolution
$ </pre></div>

<p>
You may see this if there is no resolver configured in
<tt>/etc/resolv.conf</tt> at all, for example.  This
is again different from (depending on OS and SSH
version):
</p>

<div><pre>$ ssh foo.netmeister.org
ssh: Could not resolve hostname foo.netmeister.org: Name or service not known
$ </pre></div>

<p>...which you might see if none of the nameservers
configured are reachable.  Which is <em>yet
again</em> different from: </p>

<div><pre>$ ssh foo.netmeister.org
ssh: Could not resolve hostname foo.netmeister.org: Non-recoverable failure in name resolution
$ </pre></div>

<p>...which you might get if you <em>are</em> able to
reach your configured nameserver, but that nameserver
does not want to talk to you, e.g., it&#39;s configured to
accept DNS queries, but has restrictions on who may
query it for the zone in question, so returns <span><tt>status:
REFUSED</tt></span> to your DNS query.</p>


<h3><a name="connection-refused"></a>Connection refused</h3>

<p> If you <em>are</em> able to resolve the hostname,
you may see a different error:</p>

<div><pre>$ ssh foo.netmeister.org
ssh: connect to host foo.netmeister.org port 22: Connection refused
</pre></div>

<p>
This error message is self-explanatory:
<em>connection refused</em> means that you
<em>are</em> able to talk to the host, but nothing is
listening on port 22.  That is, after your host
resolves the name to an IP address and sends a TCP
<span><tt>SYN</tt></span> packet, the remote side responds with a
TCP <tt><span>RST</span></tt>:
</p>

<div><pre>20:29:46.690536 IP 172.16.1.15.54702 &gt; foo.netmeister.org.ssh: Flags [S], seq 1750579353, win 65535,
        options [mss 1460,nop,wscale 6,nop,nop,TS val 674037520 ecr 0,sackOK,eol], length 0
20:29:46.701705 IP foo.netmeister.org.ssh &gt; 172.16.1.15.54702: Flags [<span>R</span>.], seq 0, ack 1750579354, win 0, length 0
</pre></div>

<p>
If you&#39;re sure you have the right port and hostname,
then the problem is on the remote side at this point.
But do note that <span><tt>connection refused</tt></span> is
notably different from...
</p>

<h3><a name="timed-out"></a>Operation timed out</h3>

<div><pre>$ ssh foo.netmeister.org
ssh: connect to host foo.netmeister.org port 22: Operation timed out
$ </pre></div>

<p>While <span><tt>connection refused</tt></span> clearly
shows that you can reach the remote side, <span><tt>operation timed
out</tt></span> equally clearly indicates that you can
<em>not</em> talk to the remote system on the given
port and protocol.  <tt>tcpdump(1)</tt> will show your
system sending repeated but unanswered <tt><span>SYN</span></tt>
packets:</p>

<div><pre>20:57:10.360287 IP 172.16.1.15.55111 &gt; foo.netmeister.org.ssh: Flags [<span>S</span>], seq 2997342946
20:57:11.361373 IP 172.16.1.15.55111 &gt; foo.netmeister.org.ssh: Flags [<span>S</span>], seq 2997342946
20:57:12.361702 IP 172.16.1.15.55111 &gt; foo.netmeister.org.ssh: Flags [<span>S</span>], seq 2997342946
20:57:13.362352 IP 172.16.1.15.55111 &gt; foo.netmeister.org.ssh: Flags [<span>S</span>], seq 2997342946
20:57:14.363566 IP 172.16.1.15.55111 &gt; foo.netmeister.org.ssh: Flags [<span>S</span>], seq 2997342946
...
</pre></div>

<p> So once more, so long as you&#39;re sure you have the
right port and hostname, the problem is on the remote
side.  Or rather, it&#39;s not on <em>your</em> side --
something else in between your system and the remote
side may be dropping packets.</p>

<h4><tt>ping(8)</tt> and <tt>traceroute(8)</tt></h4>

<p>Finally, you can bring in your trusty friends
<tt>ping(8)</tt> and <tt>traceroute(8)</tt>.  Is the
host in question up at all? <tt>ping(8)</tt>
<em>may</em> be able to tell you, but remember that
ICMP may be blocked or dropped along the way, and
failure to ping a host does not necessarily mean that
it&#39;s offline.</p>

<p><tt>traceroute(8)</tt> <em>may</em> be able to help
you identify where along the way traffic is getting
dropped, but here, too, remain aware of the probes
possibly being dropped, the UDP port actually being
in use, and so on.  You can remediate some of that by
trying e.g., <span><tt>traceroute -P tcp -p
&lt;port&gt;</tt></span>.</p>

<p> But not being able to talk to a remote host can
also have different causes, for example...</p>

<h3><a name="no-route"></a>No route to host</h3>

<div><pre>netbsd$ ssh foo.netmeister.org
ssh: connect to host foo.netmeister.org port 22: No route to host
$ </pre></div>

<p>
The hostname resolves, but we can&#39;t talk to the IP
address: our system doesn&#39;t know how to route the
packets to the remote side.  This may be the case when
the hostname in question resolves to an IPv6 address,
but your system doesn&#39;t have IPv6 connectivity.
Another reason might simply be a wrong or missing
route, but either way, this is a problem on the client
side.
</p><p>Infuriatingly, this error may be <a href="https://github.com/apple-oss-distributions/OpenSSH/blob/6bfdfb38f01e95db9893bfc0370248d5a4a3c2e3/openssh/sshconnect.c#L557">reported on e.g.,
macOS</a> as:</p>

<div><pre>macos$ ssh foo.netmeister.org
ssh: connect to host foo.netmeister.org port 22: Undefined error: 0
$ </pre></div>

<p>Gee, thanks a lot, Apple. That&#39;s really
helpful.</p>

<h3><a name="connection-closed"></a>Connection closed by remote host</h3>

<p>Finally, you may encounter an error that sounds
very similar to <span><tt>connection refused</tt></span> (see <a href="#connection-refused">above</a>):</p>

<div><pre>$ ssh foo.netmeister.org
kex_exchange_identification: Connection closed by remote host
$ </pre></div>

<p>In this case, you were able to resolve the host and
even talk to it using TCP on port 22, but the remote
side decided to close the connection.  This may be
because whatever is listening on port 22 on that host
doesn&#39;t actually speak SSH; often times this happens
if there is some sort of proxy or load balancing going
on, or you simply have the wrong port.</p>

<hr/>

<h3><a name="summary"></a>Summary</h3>

<p>The above examples were given using SSH; many of
them translate more or less 1:1 to other TCP based
protocols, such as HTTP.  Of course there are many
other application specific failure modes, and
different applications differ in how well they relay
the error messages to the user.</p>

<p>But before you get to debuggin the
<em>application</em>, we can summarize the different
network errors and their meaning into this flow chart
(click to open a full-sized version):</p>

<center><a href="https://www.netmeister.org/blog/images/network-troubleshooting.png"><img src="https://www.netmeister.org/blog/images/network-troubleshooting-small.png" width="800" title="click for a full-sized version"/></a> </center>

<p>This chart then simplifies, as promised
above...</p>

<center><img src="https://www.netmeister.org/blog/images/network-troubleshooting-simplified-small.png"/></center>

<p>...to &#34;<em>Is it the DNS, the network, or is it the
app?</em>&#34;.  Knowing which one of these it is is often
the first step in troubleshooting the larger
problem.</p>

<p><small>February 12th, 2022</small></p>

<hr/>

<p><small>Links:</small></p>

<ul>
<li><small><a href="https://twitter.com/jschauma/status/1492599473863864322">This blog post as a Twitter thread</a></small></li><a href="https://twitter.com/jschauma/status/1492599473863864322">
</a><li><a href="https://twitter.com/jschauma/status/1492599473863864322"><small></small></a><small><a href="https://news.ycombinator.com/item?id=30317540">Discussion on HackerNews</a></small></li><a href="https://news.ycombinator.com/item?id=30317540">
</a></ul><a href="https://news.ycombinator.com/item?id=30317540">

      </a></td>
    </tr>
  </tbody></div></div>
  </body>
</html>
