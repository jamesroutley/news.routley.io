<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.metaobject.com/2018/12/uis-are-not-pure-functions-of-model.html">Original</a>
    <h1>UIs are not pure functions of the model (2018)</h1>
    
    <div id="readability-page-1" class="page"><div id="post-body-3561052214998875002" itemprop="description articleBody"><p>
When I first saw <a href="https://reactjs.org">React.js</a>, I had a quick glance and thought that it was cool,
they finally figured out how to do a Cocoa-like MVC UI framework in JavaScript.
</p><p>

Of course, they could have just used <a href="http://www.cappuccino-project.org">Cappuccino</a>, but &#34;details&#34;.  Some more
details were that their version of <code>drawRect:</code> was called <code>render()</code> and returned HTML instead
of drawing into a graphics context, but that&#39;s just the reality of living
inside a browser.  And of course there was <a href="https://github.com/Flipboard/react-canvas">react-canvas</a>.</p><p>

Overall, though, the use of a true MVC UI framework seemed like a great step
forward compared to directly manipulating the DOM on user input, at least for actual applications.</p><p>

Imagine my surprise when I learned about <a href="https://facebook.github.io/react-native/">React.native</a>!  It looked
like they took what I had assumed to be an implementation detail as the main feature.  Looking a little more
closely confirmed my suspicions.</p><p>

Fortunately, the React.js team was so kind as to put their basic ideas in writing:  <a href="https://github.com/reactjs/react-basic">React - Basic Theoretical Concepts</a> (also <a href="https://news.ycombinator.com/item?id=16769193">discussed</a> on HN)
).  So I had a look and after a bit of reading decided it would be useful to do a side-by-side comparison with equivalents of those concepts in Cocoa as far as I understand them.</p><hr/>

<table>
  <tbody><tr>
    <th><h2>React</h2></th>
    <th><h2>Cocoa</h2></th> 
  </tr>




  <tr>
    <td>
<h3>Transformation</h3>
<p>The core premise for React is that UIs are simply a projection of data into a different form of data. The same input gives the same output. A simple pure function.</p>
<div><pre><span>function</span> <span>NameBox</span>(<span>name</span>) {
  <span>return</span> { fontWeight<span>:</span> 
          <span><span>&#39;</span>bold<span>&#39;</span></span>, labelContent<span>:</span> name };
}</pre></div>


</td>
    <td>
	<h3>Transformation</h3>
	A core premise of Cocoa, and MVC in general, is that UIs are
		a projection of data into a different form of data, specifically
		bits on a screen.  The same input gives the same output.  A simple method:
<div><pre> <span>-(void)drawRect:(NSRect)aRect </span> {
	...
}
</pre>
</div>

Due to the fact that screens and the bits on them are fairly expensive, we use the
screen as an accumulator instead of returning the bits from the method.<p>
We do not make the (unwarranted) assumption that this transformation can or should be expressed as 
a <em>pure</em> function.  While that would be <em>nice</em>, there are many reasons why this is not
a good idea, some pretty obvious.

</p></td> 

  </tr>

  <tr>
    <td>
<h3>Abstraction</h3>
<p>You can&#39;t fit a complex UI in a single function though. It is important that UIs can be abstracted into reusable pieces that don&#39;t leak their implementation details. Such as calling one function from another.</p>
<div><pre><span>function</span> <span>FancyUserBox</span>(<span>user</span>) {
  <span>return</span> {
    borderStyle<span>:</span> <span><span>&#39;</span>1px solid blue<span>&#39;</span></span>,
    childContent<span>:</span> [
      <span><span>&#39;</span>Name: <span>&#39;</span></span>,
      <span>NameBox</span>(<span>user</span>.<span>firstName</span> <span>+</span> <span><span>&#39;</span> <span>&#39;</span></span> <span>+</span>
<span>user</span>.<span>lastName</span>)
    ]
  };
}</pre></div>
<pre><code>{ firstName: &#39;Sebastian&#39;, 
   lastName: &#39;Markbåge&#39; } -&gt;
{
  borderStyle: &#39;1px solid blue&#39;,
  childContent: [
    &#39;Name: &#39;,
    { fontWeight: &#39;bold&#39;,
    labelContent: &#39;Sebastian Markbåge&#39; }
  ]
};
</code></pre></td>
    <td><h3>Abstraction</h3>
Although it is be possible to render an entire UI in a single View&#39;s 
<code>drawRect::</code> method, and users of NSOpenGLView tend to do that, it is generally
better practice to split complex UIs into reusable pieces that don&#39;t leak their implementation details. 
<p>
 Fortunately we have such reusable pieces, they are 
called <em>objects</em>, and we can group them into <em>classes</em>.  Following
the MVC naming conventions, we call objects that represent UI <em>views</em>, in
Cocoa they are instance of <code>NSView</code> or its subclasses, in CocoaTouch
the common superclass in called <code>UIView</code>.
</p></td> 

  </tr>




  <tr>
    <td>
<h3>Composition</h3>
<p>To achieve truly reusable features, it is not enough to simply reuse leaves and build new containers for them. You also need to be able to build abstractions from the containers that <em>compose</em> other abstractions. The way I think about &#34;composition&#34; is that they&#39;re combining two or more different abstractions into a new one.</p>
<div><pre><span>function</span> <span>FancyBox</span>(<span>children</span>) {
  <span>return</span> {
    borderStyle<span>:</span> <span><span>&#39;</span>1px solid blue<span>&#39;</span></span>,
    children<span>:</span> children
  };
}

<span>function</span> <span>UserBox</span>(<span>user</span>) {
  <span>return</span> <span>FancyBox</span>([
    <span><span>&#39;</span>Name: <span>&#39;</span></span>,
    <span>NameBox</span>(<span>user</span>.<span>firstName</span> <span>+</span> <span><span>&#39;</span> <span>&#39;</span></span> <span>+</span>
    <span>user</span>.<span>lastName</span>)
  ]);
}</pre></div></td>
    <td><h3>Composition</h3>

<p>To achieve truly reusable features, it is not enough to simply reuse leaves and build new containers for them. You also need to be able to build abstractions from the containers that <em>compose</em> other abstractions. The way I think about &#34;composition&#34; is that they&#39;re combining two or more different abstractions into a new one.</p>

Examples of this are the <code>NSScrollView</code>, which composes the actual scrollers,
themselves composed of different parts, a <code>NSClipView</code> to provide a 
window onto the user-provided <code>contentView</code>. 
<p>
Other examples are <code>NSTableViews</code> coordinating their columns, rows, headers and the 
system- or user-provided Cells.
</p></td> 

  </tr>


  <tr>
    <td>
<h3>State</h3>
<p>A UI is NOT simply a replication of server / business logic state. There is actually a lot of state that is specific to an exact projection and not others. For example, if you start typing in a text field. That may or may not be replicated to other tabs or to your mobile device. Scroll position is a typical example that you almost never want to replicate across multiple projections.</p>
<p>We tend to prefer our data model to be immutable. We thread functions through that can update state as a single atom at the top.</p>
<div><pre><span>function</span> <span>FancyNameBox</span>(<span>user</span>, <span>likes</span>,
  <span>onClick</span>) {
  <span>return</span> <span>FancyBox</span>([
    <span><span>&#39;</span>Name: <span>&#39;</span></span>, <span>NameBox</span>(<span>user</span>.<span>firstName</span> <span>+</span> <span><span>&#39;</span> <span>&#39;</span></span> <span>+</span>
  <span>user</span>.<span>lastName</span>),
    <span><span>&#39;</span>Likes: <span>&#39;</span></span>, <span>LikeBox</span>(likes),
    <span>LikeButton</span>(onClick)
  ]);
}

<span><span>//</span> Implementation Details</span>

<span>var</span> likes <span>=</span> <span>0</span>;
<span>function</span> <span>addOneMoreLike</span>() {
  likes<span>++</span>;
  <span>rerender</span>();
}

<span><span>//</span> Init</span>

<span>FancyNameBox</span>(
  { firstName<span>:</span> <span><span>&#39;</span>Sebastian<span>&#39;</span></span>, 
   lastName<span>:</span> <span><span>&#39;</span>Markbåge<span>&#39;</span></span> },
  likes,
  addOneMoreLike
);</pre></div>
<p><em>NOTE: These examples use side-effects to update state. My actual mental model of this is that they return the next version of state during an &#34;update&#34; pass. It was simpler to explain without that but we&#39;ll want to change these examples in the future.</em></p>

</td>
    <td><h3>State</h3>
<p>A UI is NOT simply a replication of server / business logic state. There is actually a lot of state that is specific to an exact projection and not others. For example, if you start typing in a text field. That may or may not be replicated to other tabs or to your mobile device. Scroll position is a typical example that you almost never want to replicate across multiple projections.</p>

Fortunately, the view objects we are using already provide exactly this UI-specific state, so yay objects.</td> 

  </tr>


  <tr>
    <td>
<h3>Memoization</h3>
<p>Calling the same function over and over again is wasteful if we know that the function is pure. We can create a memoized version of a function that keeps track of the last argument and last result. That way we don&#39;t have to reexecute it if we keep using the same value.</p>
<div><pre><span>function</span> <span>memoize</span>(<span>fn</span>) {
  <span>var</span> cachedArg;
  <span>var</span> cachedResult;
  <span>return</span> <span>function</span>(<span>arg</span>) {
    <span>if</span> (cachedArg <span>===</span> arg) {
      <span>return</span> cachedResult;
    }
    cachedArg <span>=</span> arg;
    cachedResult <span>=</span> <span>fn</span>(arg);
    <span>return</span> cachedResult;
  };
}

<span>var</span> MemoizedNameBox <span>=</span> <span>memoize</span>(NameBox);

<span>function</span> <span>NameAndAgeBox</span>(<span>user</span>, <span>currentTime</span>)
 {
  <span>return</span> <span>FancyBox</span>([
    <span><span>&#39;</span>Name: <span>&#39;</span></span>,
    <span>MemoizedNameBox</span>(<span>user</span>.<span>firstName</span> <span>+
    </span> <span><span>&#39;</span> <span>&#39;</span></span> <span>+</span> <span>user</span>.<span>lastName</span>),
    <span><span>&#39;</span>Age in milliseconds: <span>&#39;</span></span>,
    currentTime <span>-</span> <span>user</span>.<span>dateOfBirth</span>
  ]);
}</pre></div>
</td>
    <td>
<h3>Memoization</h3>
Calling the same method over and over again is wasteful.<p>
So we don&#39;t do that.</p><p>
First, we did not start with the obviously incorrect premise that the UI is a 
simple &#34;pure&#34; function of the model.  Except for games, UIs are actually very
stable, more stable than the model.  You have chrome, viewers, tools etc.  What <em>is</em> a (somewhat)
pure mapping from the model is the data that is displayed <em>in</em> the UI,
but not the entire UI.</p><p>

So if we don&#39;t make the incorrect assumption that UIs are unstable (pure functions of model),
then we don&#39;t have to expend additional and fragile effort to re-create that necessary stability.</p><p>

In terms of optimizing output, this is also handled within the model, rather than in 
opposition to it:   views are stable, so we keep a note of which views have
collected damage and need to be redrawn.  The application event loop coalesces these
damage rectangles and initiates an optimized operation:  it only redraws views whose
bounds intersect the damaged region, and also passes the rectangle(s) to the <code>drawRect::</code>
method.  (That&#39;s why it&#39;s called <code>drawRect::</code>).</p></td> 

  </tr>


  <tr>
    <td>
<h3>Lists</h3>
<p>Most UIs are some form of lists that then produce multiple different values for each item in the list. This creates a natural hierarchy.</p>
<p>To manage the state for each item in a list we can create a Map that holds the state for a particular item.</p>
<div><pre><span>function</span> <span>UserList</span>(<span>users</span>, <span>likesPerUser</span>,
 <span>updateUserLikes</span>) {
  <span>return</span> <span>users</span>.<span>map</span>(<span>user</span> <span>=&gt;</span> <span>FancyNameBox</span>(
    user,
    <span>likesPerUser</span>.<span>get</span>(<span>user</span>.<span>id</span>),
    () <span>=&gt;</span> <span>updateUserLikes</span>(<span>user</span>.<span>id</span>, 
<span>likesPerUser</span>.<span>get</span>(<span>user</span>.<span>id</span>) <span>+</span> <span>1</span>)
  ));
}

<span>var</span> likesPerUser <span>=</span> <span>new</span> <span>Map</span>();
<span>function</span> <span>updateUserLikes</span>(<span>id</span>, <span>likeCount</span>) {
  <span>likesPerUser</span>.<span>set</span>(id, likeCount);
  <span>rerender</span>();
}

<span>UserList</span>(<span>data</span>.<span>users</span>, likesPerUser,
            updateUserLikes);</pre></div>
<p><em>NOTE: We now have multiple different arguments passed to FancyNameBox. That breaks our memoization because we can only remember one value at a time. More on that below.</em></p>

</td>
    <td>
<h3>Lists</h3>
<p>Most UIs are some form of lists that then produce multiple different values for each item in the list. This creates a natural hierarchy.</p>

<p>Fortunately there is nothing to do here, the basic hierarchical view model already takes care of it.  There are 
specific view classes for lists, but there is nothing special about them in terms of the conceptual or implementation
model.</p>


</td> 

  </tr>


  <tr>
    <td>
<h3>Continuations</h3>
<p>Unfortunately, since there are so many lists of lists all over the place in UIs, it becomes quite a lot of boilerplate to manage that explicitly.</p>
<p>We can move some of this boilerplate out of our critical business logic by deferring execution of a function. For example, by using &#34;currying&#34; (<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" rel="nofollow"><code>bind</code></a> in JavaScript). Then we pass the state through from outside our core functions that are now free of boilerplate.</p>
<p>This isn&#39;t reducing boilerplate but is at least moving it out of the critical business logic.</p>
<div><pre><span>function</span> <span>FancyUserList</span>(<span>users</span>) {
  <span>return</span> <span>FancyBox</span>(
    <span>UserList</span>.<span>bind</span>(<span>null</span>, users)
  );
}

<span>const</span> <span>box</span> <span>=</span> <span>FancyUserList</span>(<span>data</span>.<span>users</span>);
<span>const</span> <span>resolvedChildren</span> <span>=</span>
     <span>box</span>.<span>children</span>(likesPerUser,
        updateUserLikes);
<span>const</span> <span>resolvedBox</span> <span>=</span> {
  <span>...</span>box,
  children<span>:</span> resolvedChildren
};</pre></div>


</td>
    <td><h3>Continuations</h3>
<p>Fortunately, it doesn&#39;t matter how many lists of lists there are all over the place in UIs, since our composition mechanism actually works for this use case.</p>

</td> 

  </tr>


  <tr>
    <td>
<h3>State Map</h3>
<p>We know from earlier that once we see repeated patterns we can use composition to avoid reimplementing the same pattern over and over again. We can move the logic of extracting and passing state to a low-level function that we reuse a lot.</p>
<div><pre><span>function</span> <span>FancyBoxWithState</span>(
  <span>children</span>,
  <span>stateMap</span>,
  <span>updateState</span>
) {
  <span>return</span> <span>FancyBox</span>(
    <span>children</span>.<span>map</span>(<span>child</span> <span>=&gt;</span> <span>child</span>.<span>continuation</span>(
      <span>stateMap</span>.<span>get</span>(<span>child</span>.<span>key</span>),
      updateState
    ))
  );
}

<span>function</span> <span>UserList</span>(<span>users</span>) {
  <span>return</span> <span>users</span>.<span>map</span>(<span>user</span> <span>=&gt;</span> {
    continuation<span>:</span>
      <span>FancyNameBox</span>.<span>bind</span>(<span>null</span>, user),
    key<span>:</span> <span>user</span>.<span>id</span>
  });
}

<span>function</span> <span>FancyUserList</span>(<span>users</span>) {
  <span>return</span> <span>FancyBoxWithState</span>.<span>bind</span>(<span>null</span>,
    <span>UserList</span>(users)
  );
}

<span>const</span> <span>continuation</span> <span>=</span>
     <span>FancyUserList</span>(<span>data</span>.<span>users</span>);
<span>continuation</span>(likesPerUser,
 updateUserLikes);</pre></div>

</td>
    <td>
<h3>State Map</h3>
Don&#39;t need it.<p>
(Just how many distinct mechanism do we have now for re-introducing state?  At what point do we revisit
our initial premise that UIs are pure functions of the model??)</p></td> 

  </tr>


  <tr>
    <td>

<h3>Memoization Map</h3>
<p>Once we want to memoize multiple items in a list memoization becomes much harder. You have to figure out some complex caching algorithm that balances memory usage with frequency.</p>
<p>Luckily, UIs tend to be fairly stable in the same position. The same position in the tree gets the same value every time. This tree turns out to be a really useful strategy for memoization.</p>
<p>We can use the same trick we used for state and pass a memoization cache through the composable function.</p>
<div><pre><span>function</span> <span>memoize</span>(<span>fn</span>) {
  <span>return</span> <span>function</span>(<span>arg</span>, <span>memoizationCache</span>) {
    <span>if</span> (<span>memoizationCache</span>.<span>arg</span> <span>===</span> arg) {
      <span>return</span> <span>memoizationCache</span>.<span>result</span>;
    }
    <span>const</span> <span>result</span> <span>=</span> <span>fn</span>(arg);
    <span>memoizationCache</span>.<span>arg</span> <span>=</span> arg;
    <span>memoizationCache</span>.<span>result</span> <span>=</span> result;
    <span>return</span> result;
  };
}

<span>function</span> <span>FancyBoxWithState</span>(
  <span>children</span>,
  <span>stateMap</span>,
  <span>updateState</span>,
  <span>memoizationCache</span>
) {
  <span>return</span> <span>FancyBox</span>(
    <span>children</span>.<span>map</span>(<span>child</span> <span>=&gt;</span>
    <span>child</span>.<span>continuation</span>(
      <span>stateMap</span>.<span>get</span>(<span>child</span>.<span>key</span>),
      updateState,
      <span>memoizationCache</span>.<span>get</span>(<span>child</span>.<span>key</span>)
    ))
  );
}

<span>const</span> <span>MemoizedFancyNameBox</span> <span>=</span>

      <span>memoize</span>(FancyNameBox);</pre></div>


</td>
    <td>
<h3>Memoization Map</h3>

Huh?<p>

Seriously?

</p></td> 

  </tr>


  <tr>
    <td>
<h3>Algebraic Effects</h3>
<p>It turns out that it is kind of a PITA to pass every little value you might need through several levels of abstractions. It is kind of nice to sometimes have a shortcut to pass things between two abstractions without involving the intermediates. In React we call this &#34;context&#34;.</p>
<p>Sometimes the data dependencies don&#39;t neatly follow the abstraction tree. For example, in layout algorithms you need to know something about the size of your children before you can completely fulfill their position.</p>
<p>Now, this example is a bit &#34;out there&#34;. I&#39;ll use <a href="http://math.andrej.com/eff/" rel="nofollow">Algebraic Effects</a> as <a href="https://esdiscuss.org/topic/one-shot-delimited-continuations-with-effect-handlers" rel="nofollow">proposed for ECMAScript</a>. If you&#39;re familiar with functional programming, they&#39;re avoiding the intermediate ceremony imposed by monads.</p>
<div><pre><span>function</span> <span>ThemeBorderColorRequest</span>() 
{ }

<span>function</span> <span>FancyBox</span>(<span>children</span>) {
  <span>const</span> <span>color</span> <span>=</span> raise 
    <span>new</span> <span>ThemeBorderColorRequest</span>();
  <span>return</span> {
    borderWidth<span>:</span> <span><span>&#39;</span>1px<span>&#39;</span></span>,
    borderColor<span>:</span> color,
    children<span>:</span> children
  };
}

<span>function</span> <span>BlueTheme</span>(<span>children</span>) {
  <span>return</span> <span>try</span> {
    <span>children</span>();
  } <span>catch</span> effect
     ThemeBorderColorRequest <span>-</span><span>&gt;</span> 
     [, continuation] {
    <span>continuation</span>(<span><span>&#39;</span>blue<span>&#39;</span></span>);
  }
}

<span>function</span> <span>App</span>(<span>data</span>) {
  <span>return</span> <span>BlueTheme</span>(
    <span>FancyUserList</span>.<span>bind</span>(<span>null</span>, <span>data</span>.<span>users</span>)
  );
}</pre></div>
</td>
    <td><h3>Algebraic Effects</h3>
<p>It turns out that it is kind of a PITA to pass every little value you might need through several levels of abstractions....</p>
So don&#39;t do that.<p>
This is another reason why it&#39;s advantageous to have a <em>stable</em> hierarchy of stateful objects representing your
UI.  If you need more context, you just ask around.  Ask your parent, ask your siblings, ask your children, they are all present.  Again, no special magic needed.</p></td> 

  </tr>

</tbody></table>



<hr/><p>

So that was the comparison.   I have to apologise for getting somewhat less detail-oriented near the end, but the
level of complexity just started to overwhelm me.  Add to that, for React.native, the joy of having to duplicate the
entire hierarchy of view classes, just to have the &#34;components&#34; generate not-quite-temporary temporary views that than generate
layers that draw the actual UI.  Maybe there&#39;s one <a href="https://en.wikipedia.org/wiki/Fundamental_theorem_of_software_engineering">too many layers</a>. Or <a href="https://en.wikipedia.org/wiki/Occam&#39;s_razor">two</a>.</p><p>


The idea of UI being a pure function of the model seems so obviously incorrect, and leads to such a plethora of problems,
that it is a bit puzzling how one could come up with it in the first place, and certainly how one would stick with it
in face of the avalanche of problems that just keeps coming.  A part of this is certainly the current unthinking 
infatuation with functional programming ideas.  These ideas are broadly good, but not nearly as widely or universally
applicable as some of their more starry-eyed proponents propose (I hesitate to use the word &#34;think&#34; in this context).</p><p>

Another factor is the the usefulness of immediate-mode graphics, compared to retained-state graphics.  This is actually
an interesting topic by itself, IMHO, one of those eternal circles where we move from a fully retained model such
as the early <a href="https://en.wikipedia.org/wiki/Graphical_Kernel_System">GKS</a> or laterr <a href="https://en.wikipedia.org/wiki/PHIGS">Phigs</a> to immedate drawing models such as Postscript, Quartz, und OpenGL, only to
then re-invent the retained model (sort of) with things like CoreAnimation, Avalon and, of course, the DOM (and round and round we go).  Cocoa&#39;s model represents a variable approach, where you can mix-and-match object-oriented and immediate-mode
drawing as you see fit.  But more on that later.</p><p>

Last not least, it&#39;s probably not entirely coincidental that this idea was <a href="https://en.wikipedia.org/wiki/React_(JavaScript_library)#History">hatched</a> for Facebook and Instagram feed applications.  Similar to games,
these sorts of apps have displays that really <em>are</em> determined mostly by their &#34;model&#34;, the stream of data
coming from their feed.  I am not convinced that <em>feed application</em> generalizes well to <em>application</em>.</p><p>


Anyway, for me, this whole exercise has actually motivated me to start using react.js a little.  I still think that
Cappuccino is probably the better, less confused framework, but it helps to know about what the quasi-mainstream
is doing.  I also think that despite all the flaws, react.js and react.native are currently eating native development&#39;s
lunch.  And that&#39;s certainly interesting.  Stay tuned!</p><p>


UPDATE:</p><blockquote>
I think you’re overfocusing on the “pure” wording and theoretical definitions over practical differences.
</blockquote>


<blockquote>
To elaborate a bit, React components aren’t always “pure” in strict FP sense of the word. They’re also not always functions (although we’re adding a stateful function API as a preferred alternative to classes soon). Support for local state and side effects is absolutely a core feature of React components and not something we avoid for “purity”.</blockquote>

<p>

I added a <a href="https://github.com/reactjs/react-basic/pull/12">PR</a> to remove the misleading &#34;pure&#34; from the concepts page.<br/>

</p>
</div></div>
  </body>
</html>
