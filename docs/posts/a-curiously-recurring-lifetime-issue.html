<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.dureuill.net/articles/recurring-lifetime/">Original</a>
    <h1>A curiously recurring lifetime issue</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
                                <p>Naming is hard. After all, it is one of the two hard problems of computer science, with cache invalidation and off-by-one errors.</p>
<p>Mostly we would assume that poorly chosen type and variable names would merely make the code harder to read, but turns out they can lead to <a href="http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html">undefined behaviour</a>, too. And no, I&#39;m not talking about the <a href="https://en.cppreference.com/w/c/language/identifier#Reserved_identifiers">reserved identifiers in C</a> (I mean, who would use <code>_Foo</code> or <code>__init__</code> as identifiers? Nonsense!), but rather something a bit more subtle.</p>
<hr/>
<p>When providing an API, if your types are named like types that usually own their data (<code>Vector</code>, <code>String</code>, <code>Map</code>, ...) then users of your API will use your types like types that own their data. When the types are actually reference types that don&#39;t own their data, this leads to lifetime errors, either compile time or hilariously runtime, depending on your language of choice.
You would think that users know better and that documentation suffices, but listen to this curious example.</p>
<p><a href="https://capnproto.org/">Cap&#39;n Proto</a> is an IPC format and RPC system. Think protobuf, but without encoding and decoding of the data in messages. Data is obtained through pointer chasing in the message. Cap&#39;n Proto provides the best interface language usable for cross language RPC, in my opinion. I chose it to replace (using the <a href="https://understandlegacycode.com/blog/avoid-rewriting-a-legacy-system-from-scratch-by-strangling-it/">strangler fig pattern</a>) our then <strong>very</strong> legacy network layer that was providing communication between our Python API client and our C++ server.</p>
<p>So I embedded the legacy network layer inside the new Cap&#39;n Proto layer, wrote a minimal &#34;pure capnp&#34; service, a first feature benefitting from the new layer, provided documentation and quick starts for my team, and several weeks later, a colleague came to see me with a dismayed look on his face.</p>
<p>&#34;So I tried to use the new stack, but there&#39;s an issue in my service. It returns a list of stuff, and when the list contains only a few elements, it works as expected, but when the list is big, the client segfaults. Can you have a look at the code?&#34;</p>
<p>Uh, segfault. Doesn&#39;t bode well for Cap&#39;n Proto. Surely the issue lies with our code. So let&#39;s take a look indeed. My colleague had written a small interface file for his service, that we could simplify to:</p>
<pre data-lang="capnp"><code data-lang="capnp"><span>@0x870928ae94aa7710;
</span><span>
</span><span>interface Stuff {
</span><span>    items @0 (size: UInt64) -&gt; (list :List(UInt64));
</span><span>}
</span></code></pre>
<p>A simplified C++ server implementation:</p>
<pre data-lang="c++"><code data-lang="c++"><span>#pragma</span><span> once
</span><span>
</span><span>#include </span><span>&lt;</span><span>cstdint</span><span>&gt;
</span><span>
</span><span>#include </span><span>&#34;</span><span>stuff.capnp.h</span><span>&#34;
</span><span>
</span><span>class </span><span>StuffImpl </span><span>final </span><span>: </span><span>public </span><span>Stuff::Server
</span><span>{
</span><span>  </span><span>auto </span><span>items</span><span>(ItemsContext </span><span>ctx</span><span>) -&gt; ::kj::Promise&lt;</span><span>void</span><span>&gt; </span><span>final
</span><span>  {
</span><span>    </span><span>auto</span><span> size </span><span>=</span><span> ctx.</span><span>getParams</span><span>().</span><span>getSize</span><span>();
</span><span>    </span><span>auto</span><span> list </span><span>=</span><span> ctx.</span><span>getResults</span><span>().</span><span>initList</span><span>(size);
</span><span>    std::uint64_t i </span><span>= </span><span>0</span><span>;
</span><span>    </span><span>for </span><span>(</span><span>auto</span><span> i </span><span>= </span><span>0</span><span>; i </span><span>&lt;</span><span> size; </span><span>++</span><span>i) {
</span><span>      list.</span><span>set</span><span>(i, i); </span><span>// just put `i` in the element of index `i`
</span><span>    }
</span><span>    </span><span>return</span><span> kj::READY_NOW;
</span><span>  }
</span><span>}</span><span>;
</span></code></pre>
<p>And then a simplified C++ client calling the service:</p>
<pre data-lang="c++"><code data-lang="c++"><span>#include </span><span>&lt;</span><span>cstdint</span><span>&gt;
</span><span>#include </span><span>&lt;</span><span>vector</span><span>&gt;
</span><span>
</span><span>#include </span><span>&lt;</span><span>capnp/ez-rpc.h</span><span>&gt;
</span><span>#include </span><span>&lt;</span><span>fmt/core.h</span><span>&gt;
</span><span>
</span><span>#include </span><span>&#34;</span><span>stuff.capnp.h</span><span>&#34;
</span><span>
</span><span>constexpr int</span><span> read_size = </span><span>0xffff</span><span>;
</span><span>
</span><span>auto </span><span>main</span><span>() -&gt; </span><span>int
</span><span>{
</span><span>  capnp::EzRpcClient </span><span>client</span><span>(&#34;</span><span>127.0.0.1:8000</span><span>&#34;);
</span><span>  Stuff::Client stuff = client.</span><span>getMain</span><span>&lt;Stuff&gt;();
</span><span>  </span><span>auto</span><span>&amp; wait_scope = client.</span><span>getWaitScope</span><span>();
</span><span>  </span><span>auto</span><span> request = stuff.</span><span>itemsRequest</span><span>();
</span><span>  request.</span><span>setSize</span><span>(read_size);
</span><span>  </span><span>const</span><span> capnp::List&lt;std::uint64_t&gt;::Reader list =
</span><span>      request.</span><span>send</span><span>().</span><span>wait</span><span>(wait_scope).</span><span>getList</span><span>();
</span><span>  std::vector&lt;std::uint64_t&gt; items;
</span><span>  items.</span><span>reserve</span><span>(list.</span><span>size</span><span>());
</span><span>  </span><span>for </span><span>(</span><span>auto</span><span> i : list) {
</span><span>    items.</span><span>push_back</span><span>(i);
</span><span>  }
</span><span>  </span><span>for </span><span>(</span><span>auto</span><span> i : items) {
</span><span>    fmt::</span><span>print</span><span>(&#34;</span><span>{}</span><span>\n</span><span>&#34;, i);
</span><span>  }
</span><span>}
</span></code></pre>
<p>Running the main with <code>read_size = 0xff</code> does not segfault, but returns <strong>wrong values</strong> after a while:</p>
<pre><code><span># ...
</span><span>242
</span><span>243
</span><span>244
</span><span>245 # values are normal up to this point
</span><span>1057 # hu?
</span><span>140479108999968 # wtf?
</span><span>140479108999968
</span><span>0 # wtf wtf???
</span><span>0
</span><span>251 # let&#39;s resume.
</span><span>252
</span><span>253
</span><span>254
</span></code></pre>
<p>Running with <code>read_size = 0xffff;</code> causes:</p>
<pre><code><span>[1]    63094 segmentation fault (core dumped)  ./client
</span></code></pre>
<p>Perhaps you already have it, taking into account the context of the article, but at the time the cause completely eluded me, after a cursory read of the code.</p>
<p>So I turned to tooling.</p>
<h3 id="codechecker-clang-tidy-clang-static-analyzer-cppcheck"><a href="#codechecker-clang-tidy-clang-static-analyzer-cppcheck" aria-label="Anchor link for: codechecker-clang-tidy-clang-static-analyzer-cppcheck">CodeChecker (clang-tidy, clang static-analyzer, cppcheck)</a></h3>
<p>All three static analyzers reported success, no report created.</p>
<h3 id="address-sanitizer"><a href="#address-sanitizer" aria-label="Anchor link for: address-sanitizer">Address sanitizer</a></h3>
<p>No longer segfaults, displays correct result. No error reported though.</p>
<h3 id="ub-sanitizer"><a href="#ub-sanitizer" aria-label="Anchor link for: ub-sanitizer">UB sanitizer</a></h3>
<p>Segfaults, no error reported.</p>
<h3 id="valgrind"><a href="#valgrind" aria-label="Anchor link for: valgrind">valgrind</a></h3>
<p>Oh! as often, valgrind is the most competent at actually finding an issue (I love valgrind ‚ù§Ô∏è... btw, <a href="https://valgrind.org/docs/manual/faq.html#faq.pronounce">valgrind rhymes with &#34;tinned&#34;, not &#34;find&#34;</a>), let&#39;s see what it found:</p>
<pre><code><span>==58150== Invalid read of size 8
</span><span>==58150==    at 0x10C5EE: capnp::_::DirectWireValue&lt;unsigned long&gt;::get() const (endian.h:77)
</span><span>==58150==    by 0x10D8FB: unsigned long capnp::_::ListReader::getDataElement&lt;unsigned long&gt;(unsigned int) const (layout.h:1212)
</span><span>==58150==    by 0x10CF58: capnp::List&lt;unsigned long, (capnp::Kind)0&gt;::Reader::operator[](unsigned int) const (list.h:116)
</span><span>==58150==    by 0x10C187: capnp::_::IndexingIterator&lt;capnp::List&lt;unsigned long, (capnp::Kind)0&gt;::Reader const, unsigned long&gt;::operator*() const (list.h:56)
</span><span>==58150==    by 0x10A57B: main (client.cpp:22)
</span></code></pre>
<p>OK, so something was up with that list, a use-after-free. Unfortunately while valgrind was dutifully reporting the point where the list&#39;s data had been freed, the backtrace only linked to the internals of Cap&#39;n Proto. Why was it freed?</p>
<p>That list was part of a type generated by Cap&#39;n Proto from the interface file, so I had to forage through its generated header to find it. It ultimately boiled down to a <code>kj::ArrayPtr</code>, which was <a href="https://github.com/capnproto/capnproto/blob/f7e8d58ac67635d7e09997bca3254ff376a568a0/c%2B%2B/src/kj/common.h#L1750">fortunately documented</a> to be a <strong>non-owning</strong> view of data. So, the list itself hadn&#39;t been freed, rather it was referring to data from the response! The response data was freed in the chain of calls <code>.send().wait().getList()</code></p>
<p>Knowing this, the fix was simple:</p>
<pre data-lang="cpp"><code data-lang="cpp"><span>auto </span><span>main</span><span>() -&gt; </span><span>int
</span><span>{
</span><span>  capnp::EzRpcClient </span><span>client</span><span>(&#34;</span><span>127.0.0.1:8000</span><span>&#34;);
</span><span>  Stuff::Client stuff = client.</span><span>getMain</span><span>&lt;Stuff&gt;();
</span><span>  </span><span>auto</span><span>&amp; wait_scope = client.</span><span>getWaitScope</span><span>();
</span><span>  </span><span>auto</span><span> request = stuff.</span><span>itemsRequest</span><span>();
</span><span>  request.</span><span>setSize</span><span>(read_size);
</span><span>  </span><span>auto</span><span> response = request.</span><span>send</span><span>().</span><span>wait</span><span>(wait_scope); </span><span>// üëà ADDED
</span><span>  </span><span>const</span><span> capnp::List&lt;std::uint64_t&gt;::Reader list =
</span><span>      response.</span><span>getList</span><span>();
</span><span>      </span><span>// ‚òùÔ∏è CHANGED
</span><span>  std::vector&lt;std::uint64_t&gt; items;
</span><span>  items.</span><span>reserve</span><span>(list.</span><span>size</span><span>());
</span><span>  </span><span>for </span><span>(</span><span>auto</span><span> i : list) {
</span><span>    items.</span><span>push_back</span><span>(i);
</span><span>  }
</span><span>  </span><span>for </span><span>(</span><span>auto</span><span> i : items) {
</span><span>    fmt::</span><span>print</span><span>(&#34;</span><span>{}</span><span>\n</span><span>&#34;, i);
</span><span>  }
</span><span>}
</span></code></pre>
<p>By putting the response in an intermediate local variable, we make sure its lifetime lasts for at least as long as the list object, which indeed references the data from the response.</p>
<p>Now the surprising part with this bug is how <strong>recurring</strong> it became, despite us knowing very well it could happen.</p>
<h2 id="oops-i-did-it-again"><a href="#oops-i-did-it-again" aria-label="Anchor link for: oops-i-did-it-again">Oops I did it again</a></h2>
<p>Sometime later, I wrote a Rust client for the same service as a proof-of-concept of cross-language capabilities for Cap&#39;n Proto.</p>
<p>I wrote:</p>
<pre data-lang="rust"><code data-lang="rust"><span>/// Most of the boilerplate retrieved from
</span><span>/// &lt;https://github.com/capnproto/capnproto-rust/blob/master/capnp-rpc/examples/hello-world/main.rs&gt;
</span><span>/// see their license
</span><span>
</span><span>pub mod </span><span>stuff_capnp {
</span><span>    include!(concat!(env!(&#34;</span><span>OUT_DIR</span><span>&#34;), &#34;</span><span>/stuff_capnp.rs</span><span>&#34;));
</span><span>}
</span><span>
</span><span>use crate</span><span>::stuff_capnp::stuff;
</span><span>use </span><span>capnp_rpc::{rpc_twoparty_capnp, twoparty, RpcSystem};
</span><span>
</span><span>use </span><span>futures::AsyncReadExt;
</span><span>
</span><span>const </span><span>READ_SIZE</span><span>: </span><span>u64 </span><span>= </span><span>0xFFFF</span><span>;
</span><span>
</span><span>#[</span><span>tokio</span><span>::</span><span>main</span><span>(flavor = &#34;</span><span>current_thread</span><span>&#34;)]
</span><span>pub</span><span> async </span><span>fn </span><span>main</span><span>() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
</span><span>    tokio::task::LocalSet::new()
</span><span>        .</span><span>run_until</span><span>(async </span><span>move </span><span>{
</span><span>            </span><span>let</span><span> stream = tokio::net::TcpStream::connect(&amp;&#34;</span><span>localhost:8000</span><span>&#34;).await?;
</span><span>            stream.</span><span>set_nodelay</span><span>(</span><span>true</span><span>)?;
</span><span>            </span><span>let </span><span>(reader, writer) =
</span><span>                tokio_util::compat::TokioAsyncReadCompatExt::compat(stream).</span><span>split</span><span>();
</span><span>            </span><span>let</span><span> rpc_network = Box::new(twoparty::VatNetwork::new(
</span><span>                reader,
</span><span>                writer,
</span><span>                rpc_twoparty_capnp::Side::Client,
</span><span>                Default::default(),
</span><span>            ));
</span><span>            </span><span>let mut</span><span> rpc_system = RpcSystem::new(rpc_network, None);
</span><span>            </span><span>let</span><span> stuff: stuff::Client = rpc_system.</span><span>bootstrap</span><span>(rpc_twoparty_capnp::Side::Server);
</span><span>
</span><span>            tokio::task::spawn_local(rpc_system);
</span><span>
</span><span>            </span><span>let mut</span><span> request = stuff.</span><span>items_request</span><span>();
</span><span>            request.</span><span>get</span><span>().</span><span>set_size</span><span>(</span><span>READ_SIZE</span><span>);
</span><span>
</span><span>            </span><span>let</span><span> list = request.</span><span>send</span><span>().promise.await?.</span><span>get</span><span>()?.</span><span>get_list</span><span>()?;
</span><span>
</span><span>            </span><span>let</span><span> v: Vec&lt;</span><span>u64</span><span>&gt; = list.</span><span>iter</span><span>().</span><span>collect</span><span>();
</span><span>
</span><span>            </span><span>for</span><span> i in v {
</span><span>                println!(&#34;</span><span>{i}</span><span>&#34;);
</span><span>            }
</span><span>
</span><span>            Ok(())
</span><span>        })
</span><span>        .await
</span><span>}
</span></code></pre>
<p>Doing so, I accidentally reproduced the issue my colleague had run into... can you spot it?</p>
<p>Now, Rust is not C++, fortunately it is memory safe, so the compiler helpfully said:</p>
<pre><code><span>‚ùØ cargo check
</span><span>    Checking cxxnproto v0.1.0 (/home/dureuill/exp/rust/cxxnproto)
</span><span>error[E0716]: temporary value dropped while borrowed
</span><span>  --&gt; src/main.rs:34:24
</span><span>   |
</span><span>34 |             let list = request.send().promise.await?.get()?.get_list()?;
</span><span>   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^                   - temporary value is freed at the end of this statement
</span><span>   |                        |
</span><span>   |                        creates a temporary value which is freed while still in use
</span><span>35 |
</span><span>36 |             let v: Vec&lt;u64&gt; = list.iter().collect();
</span><span>   |                               ---- borrow later used here
</span><span>   |
</span><span>help: consider using a `let` binding to create a longer lived value
</span><span>   |
</span><span>34 ~             let binding = request.send().promise.await?;
</span><span>35 ~             let list = binding.get()?.get_list()?;
</span><span>   |
</span><span>
</span><span>For more information about this error, try `rustc --explain E0716`.
</span><span>error: could not compile `cxxnproto` (bin &#34;cxxnproto&#34;) due to previous error
</span></code></pre>
<p>It even provided the fix üòÖ. I would then go and do it again in a different service, and have another colleague do it too. All while knowing that it could happen...</p>
<p>So, apart from the fact that switching from C++ to Rust reduced the debugging session from two hours of two engineers to 10 seconds of a single one, what is the moral of this story?</p>
<p>Because the Cap&#39;n Proto type is named <code>List</code>, we assume that it refers to owned data and make wrong assumptions about lifetimes. This is compounded by the fact that other Cap&#39;n Proto types (integers, boolean, and some <code>Text</code>) are immediately copied from the message and so we don&#39;t see the reference semantics when using them.</p>
<p>Is this on Cap&#39;n Proto? Honestly, I don&#39;t know. On the one hand, the code documents that the type is a view, and the generated method is named after the user-provided method name in the interface file. When you think about it, it is also perfectly normal that the list doesn&#39;t own its data, as doing so would incur a copy from the data of the received message to the List object (or some fashion of reference counting). On the other hand, I heard from a friend the other day, who works also in C++ albeit in a totally different field, that he was happening to use Cap&#39;n Proto as well. Can you guess <em>which bug</em> his team ran into?</p>

                            </div></div>
  </body>
</html>
