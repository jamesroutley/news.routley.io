<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://sailor.li/aocnds.html">Original</a>
    <h1>Advent of Code on the Nintendo DS</h1>
    
    <div id="readability-page-1" class="page"><div id="post-text">
            
<p><img src="https://bjorg.bjornroche.com/static/aocnds/img/hero.png"/></p><p>
    It is December. That means annoying Christmas things are everywhere, including but not limited
    to the annual programming semi-competition known as Advent of Code.
</p>

<p>
    The problem with Advent of Code is that it is a waste of time. Most of the puzzles are in the
    realm of either string processing (somewhat applicable to programming), logic puzzles (not
    really applicable to most programming), or stupid gotchas in the input format (annoyingly, very
    applicable to most programming). So to combat this a lot of people use Advent of Code as an
    excuse to learn a new programming language that they wouldn&#39;t otherwise have a reason to use.
</p>

<p>
    In this spirit, I&#39;ve decided to do Advent of Code 2024 in Rust, a language don&#39;t I use that
    often.
</p>

<blockquote>
    I do actually know Rust, but I never learned how to use it. I just started writing it because I
    was born with an innate knowledge of the language, similar to how I know Java or Kotlin despite
    never having learned them.
</blockquote>

<p>
    However, writing standard userland Rust on a system with a runtime is too easy; it&#39;s like
    writing a more annoying version of Java. So instead I will write it for an embedded system which
    has no runtime, a limited amount of memory, and most importantly little to no existing ecosystem
    for me to fall back on.
</p>

<blockquote>
    All the code for this project is available
    <a href="https://github.com/Fuyukai/aocnds">in the repository.</a>
</blockquote>

<blockquote>
    <h4>Warning!</h4>

    <p>
        This post is long, verbose, and explains a lot about things that aren&#39;t relevant because
        this was written in tandem with developing the project and is meant to show everything I
        learned on the way. There&#39;s a lot of things here that might seem obvious to people who know
        things about executables or embedded systems.
    </p>

    <p>
        If I wanted to do this fast, I could&#39;ve just copied everything BlocksDS does, but I
        deliberately avoided anything related to other Nintendo DS homebrew projects or SDKs as they
        are focused on teaching you how to put all of the blocks together, but not how to actually
        build the blocks yourself.
    </p>
</blockquote>

<h2>A quick overview of the Nintendo DS (Nitro)</h2>

<p>
    As the title of this post states, I&#39;m going to be writing it on the Nintendo DS (the original
    edition). Whilst there is a fair bit of interest in the &#34;embedded gaming&#34; scene of its
    predecessor systems (the Game Boy and Game Boy Advance), as well as its successor system the
    3DS, the homebrew and emulation scene for the DS itself is relatively limited due to the more
    esoteric design of the system.
</p>

<p>
    The DS&#39;s codename was &#34;Nitro&#34;, hence the model number NTR-001. Its successor system, the DSi,
    has the codename of &#34;Twilight&#34; with the model number TWL-001. I&#39;ll refer to the system
    exclusively using its codename, as Nitro sounds cooler and is easier to refer to than &#34;Nintendo
    DS&#34; is.
</p>

<blockquote>
    If you&#39;re interested in a more comprehensive overview of the system, I recommend this
    <a href="https://www.copetti.org/writings/consoles/nintendo-ds/">excellent article</a>
    by Rodrigo Copetti.
</blockquote>

<p>
    The Nitro uses two processors; an ARM946E-S running at 67MHz (in practice, less) which uses the
    ARM v5 instruction set, and an ARM7TDMI running at 33MHz which uses the ARM v4 instruction set.
</p>

<blockquote>
    <p>
        In fact, the ARM7 CPU is identical the one inside of the Game Boy Advance, meaning that when
        you play a GBA game on the Nitro it executes a small amount of code to lock out the main CPU
        and sets up the secondary processor into the same setup as the original console.
    </p>

    <p>
        The Twilight includes the same ARM7 CPU, just without the GBA slot. The 3DS/CTR also
        includes this CPU alongside its other two CPUs, which is used to run DS(i) games (and, when
        hacked, GBA games). Every Nintendo handheld up to the 3DS contains a GameBoy inside it!
    </p>
</blockquote>

<p>
    Unlike what you might expect, the two processors have different roles; the ARM9 processor is
    where the majority - if not all - of the game&#39;s code exists, and the ARM7 processor acts
    strictly as a coprocessor that controls interaction with the system&#39;s I/O. The two processors
    talk to each-other using a FIFO interface mapped in both processors&#39; memory space. It&#39;s hard to
    get an actual source on this, but various comments spread across the internet talk about how
    most code on the ARM7 was heavily restricted by Nintendo, thus most of the power of the
    secondary processor goes entirely unused.
</p>

<p>
    This works out great for me, as it means I can focus only on writing code to run on the ARM9,
    and let the ARM7 spin idly.
</p>

<h2>Preparations</h2>

<p>
    I know a little bit about how the DS works from reverse-engineering a game over the last two
    years or so; but beyond that everything here is gleamed from a few sources:
</p>

<ul>
    <li>
        <a href="https://problemkaputt.de/gbatek.htm">GBATEK</a> which is a very large and very
        detailed technical reference on everything there is to know about the GameBoy Advance as
        well as the Nitro/Twilight.
    </li>
    <li>
        The aforementioned decompiled game,
        <a href="https://en.wikipedia.org/wiki/Infinite_Space">Infinite Space (2009)</a>. It&#39;s a
        pretty decent JRPG albeit unbelievably difficult, and is worth playing with cheats on a few
        times.
    </li>
    <li>
        The official ARM v5 ARM Architecture Reference Manual, (ARM v5 ARM) available from the A RM
        website.
    </li>
</ul>

<p>
    In addition, I set up an ARM cross-compiler using
    <a href="https://wiki.gentoo.org/wiki/Crossdev">Crossdev</a>, compiling only binutils and GDB.
</p>

<h2>Getting a working ROM</h2>

<p>There&#39;s three major tasks to do to finish this project:</p>

<ol>
    <li>Get something that even boots. This is 90% of the effort.</li>
    <li>Solve Advent of Code. This is also 90% of the effort.</li>
    <li>Actually display something to the screen. This is <i>also</i> 90% of the effort.</li>
</ol>

<h3>The sample program</h3>

<p>
    First, I need a sample program to actually <i>run</i> on the Nitro. Let&#39;s just write something
    that loops forever, helpfully annotated:
</p>

<pre data-snippet="00/00sample.rs"><code>#![no_std]   // Obviously, we don&#39;t have a runtime.
#![no_main]  // We use an extern &#34;C&#34; main instead of a Rust main.
#![allow(clippy::empty_loop)]  // Otherwise clippy gets mad at our infinite loop.

// This is an empty panic handler as we don&#39;t have any infrastructure to actually... well, handle
// panics in any form.
//
// On platforms with a runtime, ``std`` provides lots of helpful code to unwind all of the code
// and print a stacktrace, but we don&#39;t have that, so instead when ``panic!()`` (or, rather,
// ``core::panicking::panic``) is called, it calls this function instead.
//
// See https://fractalfir.github.io/generated_html/rustc_codegen_clr_v0_2_1.html for the
// nitty-gritty details.
#[panic_handler]
fn _handle_panic(_: &amp;core::panic::PanicInfo) -&gt; ! {
    loop {}
}

// Unsafe attributes are a new feature in Rust 2024, and means &#34;you now need to prefix this
// attribute with unsafe&#34;.
//
// Without ``no_mangle``, this function would get optimised out (as nothing calls it), and even
// if it didn&#39;t, it would be given an unintelligible name so that it wouldn&#39;t conflict with
// functions from other packages called ``_start`` (as unwise as it would be to use that name).
//
// This also needs to be named ``_start``, or else the linker just won&#39;t output anything. More on
// that later!
#[unsafe(no_mangle)]
extern &#34;C&#34; fn _start() -&gt; ! {
    loop {}
}</code></pre>

<p>
    Next, Cargo/Rust needs to be configured to build for Nitro. The compiler triplet for ARM9 CPUs
    like the Nitro&#39;s is <code>armv5te-none-eabi</code>; i.e., ARM version 5, no OS (baremetal),
    using the embedded ABI. I could do <code>cargo build --target=armv5te-none-eabi</code> every
    time, but Cargo has the ability to do this automatically with the confusingly named
    <code>.cargo/config.toml</code> file:
</p>

<pre data-snippet="00/00config.toml"><code>[build]
target = &#34;armv5te-none-eabi&#34;</code></pre>

<p>Running <code>cargo build</code> now will grant me an error:</p>

<pre data-snippet="00/00cargo-build-err.txt"><code>$ cargo build
   Compiling aocnds v25.0.0 (/home/lura/dev/misc/aocnds)
error[E0463]: can&#39;t find crate for `core`
  |
  = note: the `armv5te-none-eabi` target may not be installed
  = help: consider downloading the target with `rustup target add armv5te-none-eabi`
  = help: consider building the standard library from source with `cargo build -Zbuild-std`</code></pre>

<p>
    The help text in this case is useless, as <code>armv5te-none-eabi</code> is a
    <a href="https://doc.rust-lang.org/nightly/rustc/platform-support.html">Tier 3</a>
    target and doesn&#39;t come with any pre-built standard library packages. Instead, I need to use the
    <a href="https://doc.rust-lang.org/cargo/reference/unstable.html#build-std"><code>build-std</code></a>
    feature of Cargo to compile the <code>core</code> (and, later, <code>alloc</code>) packages for
    my target.
</p>

<blockquote>
    This feature is (still) unstable and requires a nightly compiler + cargo version to use.
</blockquote>

<p>
    Now with this, I can build my program with a regular
    <code>cargo build --release</code>, which spits out a nice, 4440 byte
    <code>aocnds</code> executable (after stripping).
</p>

<h3>Wait, is that it?</h3>

<p>
    Okay, I don&#39;t have a ROM. But I do have a nice blob of ARM9 code that I can turn into a ROM,
    right?
</p>

<pre data-snippet="01/01-objcopy-broken.txt"><code># Just do a straight up memory copy with objcopy...
$ arm-none-eabi-objcopy -O binary aocnds arm9.bin
# Then disassemble it with objdump:
$ arm-none-eabi-objdump -D -b binary -marmv5te arm9.bin

arm9.bin:     file format binary


Disassembly of section .data:

00000000 &lt;.data&gt;:
       0:	00010010 	andeq	r0, r1, r0, lsl r0
       4:	00000001 	andeq	r0, r0, r1
       8:	00010010 	andeq	r0, r1, r0, lsl r0
       c:	00000001 	andeq	r0, r0, r1
	...
   10010:	eaffffff 	b	0x10014
   10014:	eafffffe 	b	0x10014</code></pre>

<blockquote>
    <p>
        If you don&#39;t know how to read a disassembly, there&#39;s three columns: the <i>address</i> of
        the instruction, the <i>raw bytes</i> of the instruction, and the <i>assembly</i>
        for the instruction.
    </p>
    <p>
        Objdump and other disassemblers don&#39;t discriminate between actual ARM machine code and
        random data included by the compiler and linker. Thanks to a quirk of the way the ARM
        instruction encoding was designed, most junk instructions end up being decoded as valid
        instructions, albeit nonsensical and usually nonfunctional.
    </p>
</blockquote>

<p>
    There&#39;s some junk at the beginning of the file, and then finally the actual code begins at
    offset 0x10010. By using <code>readelf</code> and <code>objdump</code> on the file, we can see
    that the 16 bytes of junk at the start is the same as the <code>.ARM.exidx</code> section:
</p>

<pre data-snippet="01/01-exidx.txt"><code>Disassembly of section .ARM.exidx:

000100d4 &lt;.ARM.exidx&gt;:
   100d4:       00010010        andeq   r0, r1, r0, lsl r0
   100d8:       00000001        andeq   r0, r0, r1
   100dc:       00010010        andeq   r0, r1, r0, lsl r0
   100e0:       00000001        andeq   r0, r0, r1</code></pre>

<p>
    The <code>0x10010</code> bytes of padding before the program text and after the ARM section is
    because the second header is loaded at a virtual address 0x10010 bytes later.
</p>

<pre data-snippet="01/01-progheaders.txt"><code>Program Headers:
  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align
  PHDR           0x000034 0x00010034 0x00010034 0x000a0 0x000a0 R   0x4
  LOAD           0x000000 0x00010000 0x00010000 0x000e4 0x000e4 R   0x10000
  LOAD           0x0000e4 0x000200e4 0x000200e4 0x00008 0x00008 R E 0x10000
  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RW  0
  ARM_EXIDX      0x0000d4 0x000100d4 0x000100d4 0x00010 0x00010 R   0x4</code></pre>

<p>
    The code at <code>0x10010</code> is a <strong>B</strong>ranch instruction to
    <code>0x10014</code>, which is then a branch instruction to itself. Because the
    <code>b</code> instruction with a constant is always a relative jump,
    <code>eafffffe</code> means &#34;jump zero bytes forwards&#34;; or, <code>PC := PC</code> which matches
    the Rust code. Great!
</p>

<p>
    The outputted ARM9 blob can be packed into a ROM using
    <a href="https://github.com/devkitPro/ndstool"><code>ndstool</code></a> for now. Borrowing an
    ARM7 from a game, I can pack my blob like so:
</p>

<pre data-snippet="01/01-ndstool.txt"><code>$ ndstool -c rom.nds -9 arm9.bin -7 ~/aur/emulation/roms/nds/arm7-is.bin
$ ndstool -i rom.nds
...
0x20    ARM9 ROM offset                 0x200
0x24    ARM9 entry address              0x2000000
0x28    ARM9 RAM address                0x2000000
0x2C    ARM9 code size                  0x10018
...</code></pre>

<p><img src="https://bjorg.bjornroche.com/static/aocnds/img/nogba_firstrun.png"/></p><p>
    For the moment I&#39;ll use NO$GBA debug to load the rom; I&#39;ll use a better emulator with a GDB stub
    for debugging later. After hitting run, the emulated ARM9 skips past the junk at the start of
    the file (thankfully, that junk all decodes to <code>andeq</code> instructions, which don&#39;t do
    anything) until it reaches the infinite loop. Success! I have built my first rust binary for
    Nitro, and I didn&#39;t really have to do anything!
</p>

<h3>No, that&#39;s not it</h3>

<p>Unfortunately, I got lucky here. This program actually has some immediate problems:</p>
<ul>
    <li>
        <code>.bss</code> has not been zeroed, which is UB. At least I don&#39;t have any global
        variables.
    </li>
    <li>The stack pointer is set to a junk value, not real memory.</li>
</ul>
<p>Oh, but there&#39;s another really important one:</p>
<ul>
    <li>The code is not running where it expects to!</li>
</ul>

<p>Nitro has, essentially, three main memory areas:</p>
<ul>
    <li>
        <p>
            The Instruction Tightly Coupled Memory (ITCM), which is mapped at 0x0 and mirrored at
            <code>0x01000000</code> (but most commercial Nitro software uses the mirror at
            <code>0x01ff8000</code>). This is 32KiB.
        </p>
    </li>
    <li>
        <p>
            The Data Tightly Coupled Memory (DOCM), which is movable throughout the entire memory
            space but in practice is usually mapped at <code>0x027e0000</code>. This is only 16KiB.
            Most commercial Nitro software uses this for the stack.
        </p>
    </li>
    <li>
        <p>
            Main memory, which is mapped at <code>0x02000000</code>. This is 4MiB on retail units
            and 8MiB on debug units.
        </p>
    </li>
</ul>

<blockquote>
    There&#39;s also the &#34;shared RAM&#34;, which is 32KiB in total and can be allocated to either the ARM7
    or the ARM9, either half and half or all to one. The ARM7 is crying out for memory as it only
    has 64KiB for itself, so this can all be allocated to the ARM7 and ignored. I believe all
    official Nitro games do this.
</blockquote>

<p>
    At boot, the software running on the cartridge is copied to the very bottom of main memory, and
    the BIOS jumps to the entrypoint specified by the cart header. With my binary, the entrypoint
    was set to be the very first address of main memory (the gigantic stack of empty
    <code>andeq</code>s) with the <code>_start</code> function trailing it. The more pressing manner
    is that the code in <code>_start</code> was built and linked with the assumption that it would
    be loaded at <code>0x200e4</code>, which it very much is not.
</p>

<blockquote>
    <p>A quick terminology lesson here, as some of those terms might not be familiar.</p>
    </blockquote>

<blockquote>
    <p>
        If all of the <code>b</code> instructions are relative, what&#39;s the problem with the code
        thinking it&#39;s loaded somewhere else?
    </p>

    </blockquote>

<h3>The first linker script</h3>

<p>I need to somehow tell the compiler and my code to do the following:</p>
<ul>
    <li>Compile with the assumption the code will be loaded and running at 0x02000000.</li>
    <li>
        Arrange the <code>.data</code>/<code>.rodata</code> section with the assumption it&#39;ll be
        loaded after 0x02000000 too.
    </li>
    <li>
        Set up a stack pointer that points into the Data Tightly Coupled Memory section so that I
        can actually use local variables.
    </li>
</ul>

<p>
    The first two can be done using a <em>linker script</em>. The misleadingly named linker script
    is a configuration file for the linker which tells it where to put the sections found in the
    intermediate files produced by the compiler into the final binary file.
</p>

<p>
    The average programmer will likely never interact with a non-default linker script in their
    life. Of the ones that do, only a tiny percentage will ever write their own linker script.
    Thankfully the programmers that <em>do</em> know how to write linker scripts have
    <a href="https://mcyoung.xyz/2021/06/01/linker-script">documented it</a>.
</p>

<pre data-snippet="03/03-ld-pt1.ld"><code>/* Standard cruft at the beginning of the file. I don&#39;t know what omitting this does,
  so let&#39;s not do that. */
OUTPUT_FORMAT(&#34;elf32-littlearm&#34;)
OUTPUT_ARCH(arm)
ENTRY(_start)

/*
 * The memory layout of the DS is pretty simple; for now, we&#39;ll just define the main memory.
 * It&#39;s a nice block of 4MB that&#39;s Readable, Writable, and eXecutable.
 */
MEMORY {
    main_ram (rwx) : ORIGIN = 0x02000000, LENGTH = 4M
}</code></pre>

<p>
    To actually use this file, I need to add another option to my <code>.cargo/config.toml</code> to
    tell the linker what script to use:
</p>

<pre data-snippet="03/03-config.toml"><code>[target.armv5te-none-eabi]
rustflags = [
    # The default ``rust-lld`` linker kinda works, but it doesn&#39;t support some linker script options
    # in weird and obscure ways. I&#39;ll just use my cross-compiler linker instead.
    &#34;-Clinker=arm-none-eabi-ld&#34;,
    &#34;-Clink-arg=-Tlinker.ld&#34;
]</code></pre>

<p>I was curious to see if this would Just Work, so I built the ELF file and objdump&#39;d it:</p>

<pre data-snippet="03/03-objdump-1.txt"><code>Disassembly of section .text:

02010010 &lt;_start&gt;:
 2010010:       eaffffff        b       2010014 &lt;_start+0x4&gt;
 2010014:       eafffffe        b       2010014 &lt;_start+0x4&gt;</code></pre>

<p>
    Aha! The 0x10000 bytes of junk is still there at the start, but now the code is correctly being
    loaded into Nitro&#39;s main memory. Not only that but the entrypoint is correct too:
</p>

<pre data-snippet="03/readelf.txt"><code>$ arm-none-eabi-readelf -h aocnds
ELF Header:
  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00
  Class:                             ELF32
  Data:                              2&#39;s complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              EXEC (Executable file)
  Machine:                           ARM
  Version:                           0x1
  Entry point address:               0x2010010</code></pre>

<p>
    If I compile a slightly modified program that calls a function with a
    <code>&amp;&#39;static str</code> variable, I can also verify that it&#39;s using the right addresses
    for <code>.rodata</code>:
</p>

<pre data-snippet="03/rodata-mizuki.rs"><code>#[unsafe(no_mangle)]
pub static BLOB: &amp;str = &#34;暁山瑞希&#34;;

// has to 1) exist 2) take the arg or the linker GCs us :(
fn other(_: &amp;str) {
    // bx lr
}

#[unsafe(no_mangle)]
extern &#34;C&#34; fn _start() -&gt; ! {
    other(BLOB);
    loop {}
}</code></pre> <pre data-snippet="03/rodata-mizuki-nm.txt"><code>Disassembly of section .rodata:

02000010 &lt;BLOB-0xc&gt;:
 2000010:       e5819ae6        str     r9, [r1, #2790] @ 0xae6
 2000014:       91e7b1b1        strhls  fp, [r7, #17]!
 2000018:       8cb8e59e        ldchi   5, cr14, [r8], #632     @ 0x278

0200001c &lt;BLOB&gt;:
 200001c:       02000010        andeq   r0, r0, #16
 2000020:       0000000c        andeq   r0, r0, ip

Disassembly of section .text:

02010024 &lt;_ZN6aocnds5other17hd0540aae0727baf3E&gt;:
 2010024:       e24dd008        sub     sp, sp, #8
 2010028:       e58d0000        str     r0, [sp]
 201002c:       e58d1004        str     r1, [sp, #4]
 2010030:       e28dd008        add     sp, sp, #8
 2010034:       e12fff1e        bx      lr

02010038 &lt;_start&gt;:
 2010038:       e59f1010        ldr     r1, [pc, #16]   @ 2010050 &lt;_start+0x18&gt;
 201003c:       e5910000        ldr     r0, [r1]
 2010040:       e5911004        ldr     r1, [r1, #4]
 2010044:       ebfffff6        bl      2010024 &lt;_ZN6aocnds5other17hd0540aae0727baf3E&gt;
 2010048:       eaffffff        b       201004c &lt;_start+0x14&gt;
 201004c:       eafffffe        b       201004c &lt;_start+0x14&gt;
 2010050:       0200001c        andeq   r0, r0, #28  &lt;-- BLOB &lt;-- BLOB-0xc</code></pre>

<p>
    The linker is placing the data in the right memory section and the reference after the body of
    <code>_start</code> is pointing to main memory. Success!
</p>

<h3>The C Runtime</h3>

<p>
    I&#39;m still in no man&#39;s land here; without a stack pointer, I can&#39;t use local variables or call
    other functions as the compiler automatically emits instructions to manipulate the stack pointer
    on function entry and exit.
</p>

<blockquote>
    <p>
        The stack is an area of memory where local variables are stored. It&#39;s called a stack because
        it grows in a first-in last-out manner. When a function needs to use a local variable, it
        allocates some space in the stack at the address of <i>stack pointer</i> - one of the
        processor registers specifically designated for this purpose - then moves it downwards by
        the amount of space that variable takes. That way, every local variable in a function has
        its own memory address automatically assigned.
    </p>

    <p>
        The stack is also used to preserve the state of the processor registers from a previous
        function when calling a function. The number of registers preserved varies depending on
        something known as a <i>calling convention</i>; for 32-bit ARM in the embedded ABI, this is
        registers four through eleven, as well as the Link register which is used to return from a
        function to the previous one.
    </p>

    <p>
        When a function exits, it no longer needs the space for the local variables, so the stack
        pointer is reset back to where it was before the function was called, allowing the previous
        function to reuse that memory for other local variables or other function calls. The
        compiler does this automatically for me in assembly known as the function prologues and
        epilogues. Without a valid stack pointer, <i>none</i> of the operations described here are
        valid, and will cause the processor to fault.
    </p>
</blockquote>

<blockquote>
    <p>
        These instructions on entry/exit are known as the function prologue and epilogue, and are
        related to avoiding clobbering registers used by previous functions. You can find more
        information about the 32-bit ARM calling convention
        <a href="https://en.wikipedia.org/wiki/Calling_convention#ARM_(A32">here</a>).
    </p>
</blockquote>

<p>
    Before every single program is a small stub of hand-written assembly known as the
    <code>crt</code>, which stands for &#34;C Runtime&#34;. This is also a misleading name, as it is neither
    a runtime nor exclusive to the C programming language. On Nitro, this has a few things it needs
    to do before jumping into the managed (i.e. my Rust) code:
</p>

<ul>
    <li>Set up the stack pointer</li>
    <li>Set up Coprocessor 15 for memory protection</li>
    <li>Zero out a memory area for the BSS segment</li>
    <li>Finally, jump into the high-level main function.</li>
</ul>

<blockquote>
    <p>
        If you don&#39;t know assembly or anything about it; that&#39;s okay. I didn&#39;t either until I
        started this. Sure, I could read <em>some</em> ARM assembly, but writing it is a whole
        different beast. Luckily it&#39;s a very nice instruction set that is easy to understand.
    </p>
</blockquote>

<p>
    Before I dive straight into writing all of this, let&#39;s get the infrastructure for the assembly
    working first. It&#39;s all going to go into a file named <code>start.s</code> in src, and can be
    included in the build process with the <code>global_asm!</code> macro, like so:
</p>

<pre><code>global_asm!(include_str!(&#34;start.s&#34;));</code></pre>

<p>
    I&#39;ll just write a basic asm file that jumps straight to the Rust main function to make sure it
    builds properly:
</p>

<pre data-snippet="04/start-1.s"><code>// Put it in the ``.text`` section, i.e. where all the functions are.
.section &#34;.text._start&#34;
// Export it globally so the linker can see it. 
.global _start

_start:
    // Branch relative to the label (function) called main.
    b main</code></pre>

<p>
    I&#39;ll also go back and rename the Rust function from <code>_start</code> to <code>main</code> so
    that it gets picked up. Dumping the executable shows that it is indeed included in my build:
</p>

<pre data-snippet="04/start-1-nm.txt"><code>Disassembly of section .text:

02010010 &lt;_start&gt;:
 2010010:       eaffffff        b       2010014 &lt;main&gt;

02010014 &lt;main&gt;:
 2010014:       eaffffff        b       2010018 &lt;main+0x4&gt;
 2010018:       eafffffe        b       2010018 &lt;main+0x4&gt;</code></pre>

<h3>A real linker script</h3>

<p>
    Up until now, I&#39;ve been coasting along on what is essentially a bunch of heuristics from the
    linker to put all of the sections in the right place. This <em>mostly</em> works, but let&#39;s see
    what happens if I add a region for the ITCM to the memory map in the linker script. The ITCM is
    officially mapped starting at <code>0x0</code>, but most official software pretends it&#39;s mapped
    at <code>0x01000000</code>. Because it&#39;s mirrored every <code>0x8000</code> bytes, most official
    software seems to pretend it actually starts at <code>0x01ff8000</code>, which is
    <code>0x8000</code> bytes before main memory.
</p>

<pre data-snippet="05/memory.diff"><code>MEMORY {
+   itcm (rwx)      : ORIGIN = 0x01ff8000, LENGTH = 32K
    main_ram (rwx)  : ORIGIN = 0x02000000, LENGTH = 4M
+   dtcm (rw)       : ORIGIN = 0x027e0000, LENGTH = 16K
}</code></pre>



<blockquote>
    I could just not add it to the linker, but eventually I want to move some of my code into the
    ITCM as it&#39;s significantly faster to fetch instructions from the ITCM than from main memory.
</blockquote>

<p>
    Attempting to compile with this linker script will result in an immediate error because the ARM
    unwind table doesn&#39;t fit into 32KiB:
</p>

<pre data-snippet="05/lld-error.txt"><code>  = note: rust-lld: error: section &#39;.ARM.exidx&#39; will not fit in region &#39;itcm&#39;: overflowed by 32784 bytes
          rust-lld: error: section &#39;.text&#39; will not fit in region &#39;itcm&#39;: overflowed by 98372 bytes</code></pre>

<p>
    This is because the heuristics the linker uses is to put all sections in the first memory
    segment it finds; in this case, it&#39;s the ITCM segment. I don&#39;t want unwind tables or the first
    half of my program text in the ITCM anyway!
</p>

<p>
    To solve this, I need to actually start defining some sections in the linker script. First, I&#39;m
    going to make it so that Cargo will correctly rebuild the project if the script changes, rather
    than going &#34;yup, looks good to me!&#34;, by creating a `build.rs` file in the root of the project:
</p>

<pre data-snippet="05/build.rs"><code>pub fn main() {
    println!(&#34;cargo::rerun-if-changed=linker.ld&#34;);
}</code></pre>

<p>Next, let&#39;s define some code sections in a... <code>SECTIONS</code> block:</p>

<pre data-snippet="05/sections.ld"><code>SECTIONS {
    /* The CRT always needs to be in main memory. Let&#39;s put it at the start for good measure. */
    .crt : ALIGN(4) { *(.crt); *(.crt.*) } &gt; main_ram =0x39

    /* The text section should be in main memory. Things that will go into the ITCM can be put
       there explicitly. */
    .text : ALIGN(4) { *(.text); *(.text.*) } &gt; main_ram =0x39
    /* The data section should also be in RAM. DTCM variables can be placed there explicitly. */
    .data : ALIGN(4) { *(.data); *(.data.*) } &gt; main_ram =0x39
    .rodata : ALIGN(4) { *(.rodata); *(.rodata.*); } &gt; main_ram =0x39
    /* The BSS section doesn&#39;t really... exist, but we need to allocate some space for it anyway. */
    .bss : ALIGN(4) { KEEP(*(.bss)); KEEP(*(.bss.*)); } &gt; main_ram

    /* Make sure the start of the heap is properly aligned. */
    . = ALIGN(4);
    __text_end = .;

    /* Let&#39;s get rid of anything we haven&#39;t explicitly specified. This includes some debugging
       info for now. */
    /DISCARD/ : { * }
}</code></pre>

<p>
    As the comments show, this forces the <code>crt</code> assembly to be in main memory and at the
    very start of the code, then the <code>.text</code> section after, and finally the
    <code>.(ro)data</code> sections. All of these sections have their unused bytes filled with a
    fixed <code>0x39</code> (e.g. the trailing, unaligned bytes for global data or THUMB
    instructions). The <code>.bss</code> section doesn&#39;t exist in the binary, but I need to mark it
    in the linker script so that the code knows where to zero it out at runtime.
</p>

<p>Finally, I can define some &#34;variables&#34; which will be exported to the final code:</p>

<pre data-snippet="05/variables.ld"><code>__bss_start = ADDR(.bss);
__bss_end = ADDR(.bss) + SIZEOF(.bss);</code></pre>

<p>With the BSS labels defined, I can write some assembly to zero the section out:</p>

<pre data-snippet="05/start-1.s"><code>// R0: value
// R1: ptr to start
// R2: size
_ASM_primitive_memset:
    // R12 (end) = start + size
    add r12, r1, r2
.L0:
    // Compare current pointer to end
    cmp r1, r12
    // Store multiple registers, increment address, only run if R1 &lt; R12
    // *R1 = R0, R1 += 4
    // Also, the double braces are because this is being compiled with ``global_asm!()``, and single
    // braces means it would think it&#39;s a parameter and flip out at me for not providing an ``R0``
    // parameter.
    // Doesn&#39;t clear the condition bits so...
    stmialt r1!, {{R0}}
    // ... jump back if the condition still matches
    blt .L0
    // Return
    bx lr

_start:
    // Clear BSS
    ldr r2, =__bss_size
    ldr r1, =__bss_start
    mov r0, #0
    bl _ASM_primitive_memset

    // For future-proofing, we do a branch-with-exchange in case ``main`` ends up as a thumb
    // function.
    ldr r0, =main
    bx r0</code></pre>

<h3>The rest of the CRT</h3>

<p>
    With a working linker script and my memory sections actively defined in the linker script, I can
    start filling in the rest of the CRT. First, I disable interrupts and wait for vertical sync:
</p>

<pre data-snippet="06/start-2.s"><code>_start:
    // The IME is at address 0x4000208, and is a 32-bit register.
    // The only bit in it that matters is bit zero, which acts as the enable bit.
    // 1 = interrupts controlled by IE
    // 0 = interrupts forcibly disabled.
    //
    // The ``mov`` instruction with an immediate can only operate on any 8-bit value that is shifted
    // by an even power of two, which 0x04000208 is not. 0x04000000 (the base address for I/O
    // registers) is, so that&#39;s loaded into register zero. Then, exploiting the fact that the
    // LSB of 0x04000000 is 0, we store that into IME and the upper bits are ignored.

    mov r0, #0x04000000
    str r0, [r0, #0x208]

    // Wait for vertical sync.
    // Note: The syntax ``.L&lt;name&gt;`` signifies a local label, which isn&#39;t exported as a symbol
    // in the final compiled object.
.Lvsync:
    // Load half-word at REG_DISP_VCOUNT. R0 was already the base of the I/O registers, so we
    // can just add 0x6 to it to load it into R1.
    ldrh r1, [r0, #0x6]
    // Compare to 0x0 and set the comparison flag.
    cmp r1, #0
    // Branch if not equal back to the VSYNC label.
    bne .Lvsync</code></pre>

<p>
    Next, I set up my stack pointers. I want it to be in the DTCM, as that is significantly faster
    than main memory. As eventually I&#39;ll want to copy things into the DTCM from main memory, I&#39;ll
    define some variables in the linker script:
</p>

<pre data-snippet="06/variables.ld"><code>__dtcm_region_start = ORIGIN(dtcm);
__dtcm_region_end = ORIGIN(dtcm) + LENGTH(dtcm) - 4;</code></pre>

<p>
    Now, I&#39;ll finally give myself a frame pointer - or, in fact, <i>three</i> frame pointers; one
    for each mode (Supervisor, IRQ, and System).
</p>

<blockquote>
    <p>
        The vast majority of CPUs ever made have a concept of special modes; these are sometimes
        called privilege modes, or rings, and are normally used to protect the kernel from user
        software and userland software from <em>other</em> userland software. Each mode has its own
        set of registers and state that is isolated from the other modes.
    </p>
    <p>
        Being that this is a game console - and an old, low-powered one at that - there&#39;s no need
        for this protection, so the modes are used primarily to separate the stacks and registers
        when doing things like processing exceptions or interrupts.
    </p>
</blockquote>

<blockquote>
    <h4>Trivia!</h4>

    <p>
        On x86 (but not AMD64), there are four rings, numbered zero through three. User code
        typically runs in Ring 3 and kernel code typically runs in Ring 0, with Ring 1 and 2 unused.
        Back in the day, OS/2 used Ring 2 for device drivers, which makes emulating/virtualising it
        a bit harder as one would have to support the middle rings.
    </p>
</blockquote>

<blockquote>
    <h4>More trivia!</h4>

    <p>
        ARM actually supports <em>seven</em> modes; in addition to those four, there&#39;s also User
        mode, FIQ mode, Abort mode, and... Undefined mode. I have no reason for User mode as there&#39;s
        no end-user programs (or even an MMU), and the other four modes are treated identically by
        the BIOS.
    </p>
</blockquote>

<p>
    To set the frame pointers, I need to switch into every mode and assign a value to the register.
    The mode is set by the lower four bits of the CPSR (Current Program Status Register), and all
    the other bits can safely be set to zero without issue. The offsets from the DTCM are calculated
    in the linker script rather than the assembly file as they are known at compile time:
</p>

<pre data-snippet="06/stacks.ld"><code>__stack_start_irq = __dtcm_region_end - 0x100;
__stack_start_svc = __stack_start_irq - 0x100;
__stack_start_sys = __stack_start_sys - 0x100;</code></pre>

<p>Then, it&#39;s just a few repeated instructions to change modes:</p>

<pre data-snippet="06/stacks.s"><code>// Stack setup for every mode
// 0b10010 == 0x12, IRQ mode
mov r0, #0x12
msr cpsr, r0
ldr sp, =__stack_start_irq

// 0b10011 == 0x13, Supervisor mode
mov r0, #0x13
msr cpsr, r0
ldr sp, =__stack_start_svc

// 0b11111 == 0x1f, System mode
mov r0, #0x1f
msr cpsr, r0
ldr sp, =__stack_start_sys</code></pre>

<p>
    With the stack pointers now valid and the <code>.bss</code> zeroed, I now have a
    <em>valid</em> Rust program that can be built and linked.
</p>

<h3>Coprocessor 15</h3>

<p>
    Coprocessor 15 (also known as the System Control coprocessor) is a special processor built-in to
    the ARM9 (and ARM7) chips that controls things mostly relating to memory layouts and memory
    protection. CP15 has sixteen registers, with the most interesting ones being:
</p>
<ul>
    <li>
        <p>
            Registers 2, 5, 6, 8, 10, and 13 control the memory protection subsystem, which is an
            alternative to the memory management unit subsystem (which the ARM9 doesn&#39;t have). This
            subsystem mostly pertains to caching and raising CPU exceptions on out-of-bounds reads.
        </p>
    </li>
    <li>
        <p>
            Registers 7 and 9 control the cache and write buffers, as well as the tightly coupled
            memory locations.
        </p>
    </li>
</ul>
<p>
    This is fiddly and annoying (my decompiled game has 45 (!) instructions to set it up)... so I&#39;m
    simply going to blindly steal what said game does. I&#39;ve helpfully commented everything too, so
    that future generations can understand it easier.
</p>

</div></div>
  </body>
</html>
