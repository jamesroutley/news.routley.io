<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://databasearchitects.blogspot.com/2020/10/c-concurrency-model-on-x86-for-dummies.html">Original</a>
    <h1>C&#43;&#43; Concurrency Model on x86 for Dummies (2020)</h1>
    
    <div id="readability-page-1" class="page"><div id="post-body-308138814233477345" itemprop="description articleBody">
<p>Since C++11, multi-threaded C++ code has been governed by a rigorous memory model. The model allows implementing concurrent code such as low-level synchronization primitives or lock-free data structures in a portable fashion. To use the memory model, programmers need to do two things: First, they have to use the <i>std::atomic</i> type for concurrently-accessed memory locations. Second, each atomic operation requires a memory order argument with six options determining the concurrency semantics in terms of which re-orderings are allowed. (Some operations even allow specifying two memory orders!)</p><p>There are only six things one needs to know to write high-performance concurrent code on x86.<br/></p><h2>1. Data races are undefined<br/></h2><p>If a data race occurs in C++, the behavior of the program is undefined. Let&#39;s unpack that statement. A data race can be defined as two or more threads accessing the same memory location with at least one of the accesses being a write. By default (i.e., without using <i>std::atomic</i>), the compiler may assume that no other thread is concurrently modifying memory. This allows the compiler to optimize the code, for example by reordering or optimizing away memory accesses. Consider the following example:</p><h2>2. Sequentially-consistent loads are fast</h2><h2>3. Sequentially-consistent stores are slow</h2><h2>4. Stores that can be delayed can benefit from the <i>release</i> memory order</h2><h2>5. Some atomic operations are always sequentially consistent</h2><h2>6. Scalable code should avoid cache invalidations</h2><h2>Summary</h2>

</div></div>
  </body>
</html>
