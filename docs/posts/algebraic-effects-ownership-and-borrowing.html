<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://antelang.org/blog/effects_ownership_and_borrowing/">Original</a>
    <h1>Algebraic effects, ownership, and borrowing</h1>
    
    <div id="readability-page-1" class="page"><div id="post-content">
                          <hr/>

<p><a href="https://antelang.org/docs/language/#algebraic-effects">Algebraic Effects</a> are a useful abstraction
for reasoning about effectful programs by letting us leave the interpretation
of these effects to callers. However, most existing literature discusses these
in the context of a pure functional language with pervasive sharing of values.
What restrictions would we need to introduce algebraic effects into a language
with ownership and borrowing - particularly Ante?<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup></p>
<hr/>

<p>Consider the following program:</p>
<div><pre tabindex="0"><code data-lang="ante"><span>effect</span> <span>Read</span> <span>a</span> <span>with</span>
    <span>read</span> <span>:</span> <span>Unit</span> <span>-&gt;</span> <span>a</span>

<span>the_value</span> <span>(</span><span>value</span><span>:</span> <span>a</span><span>)</span> <span>(</span><span>f</span><span>:</span> <span>Unit</span> <span>-&gt;</span> <span>b</span> <span>can</span> <span>Read</span> <span>a</span><span>)</span> <span>:</span> <span>b</span> <span>=</span>
    <span>handle</span> <span>f</span> <span>()</span>
    <span>|</span> <span>read</span> <span>()</span> <span>-&gt;</span> <span>resume</span> <span>value</span>
</code></pre></div><p>This seems like it’d pass type checking at first glance, but we can easily
construct a program that tries to use the same moved value twice:</p>
<div><pre tabindex="0"><code data-lang="ante"><span>foo</span> <span>()</span> <span>:</span> <span>Unit</span> <span>can</span> <span>Read</span> <span>String</span> <span>=</span>
    <span>s1</span> <span>=</span> <span>read</span> <span>()</span>
    <span>s2</span> <span>=</span> <span>read</span> <span>()</span>

<span>foo</span> <span>()</span> <span>with</span> <span>the_value</span> <span>&#34;foo&#34;</span>

<span>// The above is sugar for</span>
<span>// the_value &#34;foo&#34; (fn () -&gt; foo ())</span>
</code></pre></div><p>Since a handler’s body may be called multiple times, it may not move any
value in its environment. This restriction is similar to moving values in a loop:</p>
<div><pre tabindex="0"><code data-lang="ante"><span>the_value</span> <span>(</span><span>value</span><span>:</span> <span>a</span><span>)</span> <span>(</span><span>f</span><span>:</span> <span>Unit</span> <span>-&gt;</span> <span>b</span> <span>can</span> <span>Read</span> <span>a</span><span>)</span> <span>:</span> <span>b</span> <span>=</span>
    <span>handle</span> <span>f</span> <span>()</span>
    <span>// Error: Handler body moves `value` which will still</span>
    <span>//         be needed if the handler is called again</span>
    <span>|</span> <span>read</span> <span>()</span> <span>-&gt;</span> <span>resume</span> <span>value</span>
</code></pre></div><hr/>

<p>Things get more complicated when we consider borrowing. Although Ante’s references
<a href="https://antelang.org/docs/language/#borrowing">do not have explicit lifetime variables</a>,
we still need to ensure their lifetime is sound.</p>
<h2 id="returning-owning-references">Returning Owning References</h2>
<p>Consider the following program:</p>
<div><pre tabindex="0"><code data-lang="ante"><span>bad</span> <span>()</span> <span>:</span> <span>Unit</span> <span>can</span> <span>Read</span> <span>(</span><span>&amp;</span><span>own</span> <span>mut</span> <span>Box</span> <span>String</span><span>)</span> <span>=</span>
    <span>s1</span> <span>=</span> <span>read</span> <span>()</span>

    <span>// Uh-oh, we&#39;ve just obtained a second mutable owning reference to the same String</span>
    <span>s2</span> <span>=</span> <span>read</span> <span>()</span>
    <span>s2_inner_ref</span> <span>=</span> <span>as_ref</span> <span>s2</span>

    <span>// Drop the old Box referenced by s1 and s2</span>
    <span>s1</span> <span>:=</span> <span>Box</span><span>.</span><span>of</span> <span>&#34;foo&#34;</span>

    <span>// And now we&#39;re printing a dangling reference</span>
    <span>print</span> <span>s2_inner_ref</span>

<span>the_ref</span> <span>(</span><span>ref</span><span>:</span> <span>&amp;</span><span>own</span> <span>mut</span> <span>t</span><span>)</span> <span>(</span><span>f</span><span>:</span> <span>Unit</span> <span>-&gt;</span> <span>a</span> <span>can</span> <span>Read</span> <span>(</span><span>&amp;</span><span>own</span> <span>mut</span> <span>t</span><span>))</span> <span>:</span> <span>a</span> <span>=</span>
    <span>handle</span> <span>f</span> <span>()</span>
    <span>|</span> <span>read</span> <span>()</span> <span>-&gt;</span> <span>resume</span> <span>ref</span>

<span>my_string</span> <span>=</span> <span>mut</span> <span>Box</span><span>.</span><span>of</span> <span>&#34;bar&#34;</span>
<span>bad</span> <span>()</span> <span>with</span> <span>the_ref</span> <span>&amp;</span><span>my_string</span>
</code></pre></div><p>This breaks the aliasing restriction on <code>&amp;own mut</code> in a way the compiler
cannot verify with existing rules on tracking lifetimes.</p>
<p>The solution to this is that each function using the same <code>Read (&amp;own mut Box String)</code>
effect is considered to borrow from the same effect handler. Attempting to retrieve
two owned, mutable references from the same handler then would be a lifetime error:</p>
<div><pre tabindex="0"><code data-lang="ante"><span>bad</span> <span>()</span> <span>:</span> <span>Unit</span> <span>can</span> <span>Read</span> <span>(</span><span>&amp;</span><span>own</span> <span>mut</span> <span>Box</span> <span>String</span><span>)</span> <span>=</span>
    <span>s1</span> <span>=</span> <span>read</span> <span>()</span>

    <span>// Error: Cannot create a new aliased reference with `s1` still in scope</span>
    <span>s2</span> <span>=</span> <span>read</span> <span>()</span>

    <span>print</span> <span>s1</span>
</code></pre></div><p>Similarly, trying to obfuscate this by calling a function which indirectly
returns another reference should also fail:</p>
<div><pre tabindex="0"><code data-lang="ante"><span>indirect</span> <span>()</span> <span>can</span> <span>Read</span> <span>(</span><span>&amp;</span><span>own</span> <span>mut</span> <span>Box</span> <span>String</span><span>)</span> <span>=</span>
    <span>read</span> <span>()</span>

<span>foo</span> <span>()</span> <span>can</span> <span>Read</span> <span>(</span><span>&amp;</span><span>own</span> <span>mut</span> <span>Box</span> <span>String</span><span>)</span> <span>=</span>
    <span>r1</span> <span>=</span> <span>read</span> <span>()</span>

    <span>// Error: Cannot borrow from `Read` effect again with `r1` still in scope</span>
    <span>r2</span> <span>=</span> <span>indirect</span> <span>()</span>
</code></pre></div><h2 id="owned-reference-parameters">Owned Reference Parameters</h2>
<p>Now let’s consider how we can break programs which pass references to effects.
For this we’re going to use the <code>Yield a</code> effect which is used for creating
generators or streams:</p>
<div><pre tabindex="0"><code data-lang="ante"><span>effect</span> <span>Yield</span> <span>a</span> <span>with</span>
    <span>yield</span><span>:</span> <span>a</span> <span>-&gt;</span> <span>Unit</span>

<span>foo</span> <span>()</span> <span>:</span> <span>Unit</span> <span>can</span> <span>Yield</span> <span>(</span><span>&amp;</span><span>own</span> <span>mut</span> <span>I32</span><span>)</span> <span>=</span>
    <span>vec</span> <span>=</span> <span>mut</span> <span>Vec</span><span>.</span><span>of</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>]</span>
    <span>yield</span> <span>(</span><span>get_mut</span> <span>&amp;</span><span>vec</span> <span>0</span><span>)</span>
    <span>vec</span> <span>:=</span> <span>Vec</span><span>.</span><span>of</span> <span>[</span><span>3</span><span>]</span>
    <span>yield</span> <span>(</span><span>get_mut</span> <span>&amp;</span><span>vec</span> <span>0</span><span>)</span>

<span>bar</span> <span>()</span> <span>=</span>
    <span>x</span> <span>=</span> <span>mut</span> <span>None</span>

    <span>handle</span> <span>foo</span> <span>()</span>
    <span>|</span> <span>yield</span> <span>y</span> <span>-&gt;</span>
        <span>if</span> <span>Some</span> <span>x</span> <span>=</span> <span>x</span> <span>then</span>
            <span>// foo has cleared the underlying vec by this point,</span>
            <span>// so this would print a dangling reference!</span>
            <span>print</span> <span>x</span>

        <span>x</span> <span>:=</span> <span>Some</span> <span>y</span>
        <span>resume</span> <span>()</span>
</code></pre></div><p>To prevent this we need to tie <code>y</code> to the variable that owns it - which is <code>resume</code>.
This way we can still yield owned references if needed, but we cannot call <code>resume</code> until they are dropped.</p>
<p>Conceptually, we can think of a handle expression as receiving a single <code>resume</code> object which
is then unpacked:</p>
<div><pre tabindex="0"><code data-lang="ante"><span>handle</span> <span>foo</span> <span>()</span>
<span>|</span> <span>MyEffect</span> <span>a</span> <span>b</span> <span>-&gt;</span>
    <span>...</span>

<span>// Conceptually the same as:</span>
<span>handle</span> <span>foo</span> <span>()</span>
<span>|</span> <span>MyEffect</span> <span>resume</span> <span>-&gt;</span>
    <span>a</span> <span>=</span> <span>resume</span><span>.</span><span>a</span>
    <span>b</span> <span>=</span> <span>resume</span><span>.</span><span>b</span>
    <span>resume</span> <span>=</span> <span>resume</span><span>.</span><span>continuation</span>
    <span>...</span>
</code></pre></div><hr/>

<p>One core aspect of effects that we’ve glossed over so far is the <code>resume</code> function
which resumes an effectful computation from the handler. Since <code>resume</code> refers to an
in-progress computation, we need a way to safely encode this environment, yet we
need to do so when defining the effect before the environment is known.
What type should be given to <code>resume</code>?</p>
<p>Consider the following code:</p>
<div><pre tabindex="0"><code data-lang="ante"><span>effect</span> <span>Fork</span> <span>with</span>
    <span>fork</span><span>:</span> <span>Unit</span> <span>-&gt;</span> <span>Bool</span>

<span>foo</span> <span>()</span> <span>:</span> <span>Unit</span> <span>can</span> <span>Fork</span> <span>=</span>
    <span>message</span> <span>=</span> <span>&#34;branch&#34;</span>

    <span>if</span> <span>fork</span> <span>()</span> <span>then</span>
        <span>print</span> <span>&#34;${message} A&#34;</span>
        <span>drop</span> <span>message</span>
    <span>else</span>
        <span>print</span> <span>&#34;${message} B&#34;</span>

<span>handle_fork</span> <span>(</span><span>f</span><span>:</span> <span>Unit</span> <span>-&gt;</span> <span>a</span> <span>can</span> <span>Fork</span><span>)</span> <span>:</span> <span>a</span> <span>=</span>
    <span>handle</span> <span>f</span> <span>()</span>
    <span>|</span> <span>fork</span> <span>()</span> <span>-&gt;</span>
        <span>// Run `resume` twice, arbitrarily returning the second result</span>
        <span>resume</span> <span>true</span>
        <span>resume</span> <span>false</span>

<span>handle_fork</span> <span>foo</span>
</code></pre></div><p>After resuming from the <code>fork</code> the second time, we enter the false branch.
When doing so, <code>message</code> has already been moved, so we’d be reading from an
already-dropped value.</p>
<p>This is the problem the different closure types already solve. We just need
some way to determine if <code>resume</code> should be a <code>Fn</code>, <code>FnMut</code>, or <code>FnOnce</code> since
we cannot know this within the handler itself.</p>
<p>One possibility is to require this in the definition of <code>Fork</code>:</p>
<div><pre tabindex="0"><code data-lang="ante"><span>effect</span> <span>Fork</span> <span>with</span>
    <span>fork</span><span>:</span> <span>Unit</span> <span>-&gt;</span> <span>Bool</span>

    <span>// The underscores here are because we&#39;re omitting the closure environment</span>
    <span>// type as well as the actual function type - which is derived from fork&#39;s type.</span>
    <span>// Although the environment type can be specified if desired, the function type of resume</span>
    <span>// must be omitted because its return type will be the handler type, which is</span>
    <span>// not known at this point.</span>
    <span>fork</span><span>.</span><span>resume</span><span>:</span> <span>FnMut</span> <span>_</span> <span>_</span>
</code></pre></div><p>Note that <code>fork</code> is still callable without restrictions.
It is only <code>resume</code> that will be a <code>FnMut</code> when it is introduced.</p>
<p>Anyways, now we’d get an error when writing <code>foo</code>:</p>
<div><pre tabindex="0"><code data-lang="ante"><span>foo</span> <span>()</span> <span>:</span> <span>Unit</span> <span>can</span> <span>Fork</span> <span>=</span>
    <span>message</span> <span>=</span> <span>&#34;branch&#34;</span>

    <span>// Error: `fork` can be resumed multiple times, but `message` would</span>
    <span>//         possibly be moved after the first call to `resume`.</span>
    <span>if</span> <span>fork</span> <span>()</span> <span>then</span>
        <span>print</span> <span>&#34;${message} A&#34;</span>
        <span>// Note: `message` is moved here</span>
        <span>drop</span> <span>message</span>
    <span>else</span>
        <span>print</span> <span>&#34;${message} B&#34;</span>
</code></pre></div><p>Since this error would otherwise be much more common, <code>resume</code> is by
default a <code>FnOnce</code> unless otherwise specified. This means when defining
an effect we will need to think about what kinds of effect handlers we
want to permit.</p>
<p>Also note that after removing <code>drop</code>, <code>message</code> will not be dropped at the
end of <code>foo</code>. Instead, it is part of <code>resume</code>’s environment and will be dropped
after the last use of <code>resume</code> in the effect handler.</p>
<h2 id="environment-type-quantification">Environment Type Quantification</h2>
<p>Most effects which give an explicit type for <code>resume</code> will either omit the
environment type, or specify it as a type variable quantified over the function:</p>
<div><pre tabindex="0"><code data-lang="ante"><span>effect</span> <span>Foo</span> <span>with</span>
    <span>foo</span><span>:</span> <span>Unit</span> <span>-&gt;</span> <span>Unit</span>
    <span>foo</span><span>.</span><span>resume</span><span>:</span> <span>FnOnce</span> <span>env</span> <span>_</span>

    <span>// The above means:</span>
    <span>// foo.resume: forall env. FnOnce env _</span>
</code></pre></div><p>This is generally desired since it allows the <code>resume</code> closure to be unboxed most
of the time. However, what would happen if the user wrote the trait as the following:</p>
<div><pre tabindex="0"><code data-lang="ante"><span>effect</span> <span>Foo</span> <span>env</span> <span>with</span>
    <span>foo</span><span>:</span> <span>Unit</span> <span>-&gt;</span> <span>Unit</span>
    <span>foo</span><span>.</span><span>resume</span><span>:</span> <span>FnOnce</span> <span>env</span> <span>_</span>
</code></pre></div><p>Since each generic instance of a trait would be separate (e.g. <code>Read I32</code> versus <code>Read String</code>),
each use of this effect with a different environment would be a separate effect:</p>
<div><pre tabindex="0"><code data-lang="ante"><span>forced_example</span> <span>(</span><span>x</span><span>:</span> <span>&amp;</span><span>I32</span><span>)</span> <span>=</span>
    <span>foo</span> <span>()</span>
    <span>y</span> <span>=</span> <span>x</span>
    <span>foo</span> <span>()</span>
    <span>print</span> <span>(</span><span>x</span><span>,</span> <span>y</span><span>)</span>
</code></pre></div><p>Above, <code>forced_example</code> would be inferred to have the effects <code>Foo Env1</code> and <code>Foo Env2</code> where
<code>Env1</code> and <code>Env2</code> are both opaque types representing the environments. Since each of these would
need to be handled by separate effect handlers, this technique could be used to limit an effect
to being called at most once per handler. It remains to be seen how useful this would be however.</p>
<h2 id="restricting-the-environment-type">Restricting the environment type</h2>
<p>If any capabilities are required on the <code>resume</code> closure, a <code>given</code> clause can be added.
Since most traits on closures are defined as long as they’re defined on the closure environment,
it is usually sufficient to require the trait on the closure environment alone:</p>
<div><pre tabindex="0"><code data-lang="ante"><span>effect</span> <span>FooCloneEnv</span> <span>with</span>
    <span>foo</span><span>:</span> <span>Unit</span> <span>-&gt;</span> <span>Unit</span>
    <span>foo</span><span>.</span><span>resume</span><span>:</span> <span>FnOnce</span> <span>env</span> <span>_</span> <span>given</span> <span>Clone</span> <span>env</span>
</code></pre></div><p>Note that since <code>resume</code> is a continuation, this environment type includes any captured variables
across other function calls as well. So the <code>Clone</code> constraint above would also apply to
the <code>vec</code> variable below:</p>
<div><pre tabindex="0"><code data-lang="ante"><span>inner_fn</span> <span>()</span> <span>:</span> <span>Unit</span> <span>can</span> <span>FooCloneEnv</span> <span>=</span>
    <span>// x may be cloned</span>
    <span>x</span> <span>=</span> <span>3</span>
    <span>foo</span> <span>()</span>
    <span>print</span> <span>x</span>

<span>outer_fn</span> <span>()</span> <span>:</span> <span>Unit</span> <span>can</span> <span>FooCloneEnv</span> <span>=</span>
    <span>// vec may also be cloned</span>
    <span>vec</span> <span>=</span> <span>Vec</span><span>.</span><span>of</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>]</span>
    <span>function2</span> <span>()</span>
    <span>print</span> <span>vec</span>
</code></pre></div><p>Since environment types can grow quite large, it is generally recommended to avoid cloning
<code>resume</code>. A more useful trait constraint on <code>resume</code> is covered in the next section.</p>
<hr/>

<p>Going back to the <code>Fork</code> example, what would happen if we tried to run each
resumption in its own thread?</p>
<div><pre tabindex="0"><code data-lang="ante"><span>effect</span> <span>Fork</span> <span>with</span>
    <span>fork</span><span>:</span> <span>Unit</span> <span>-&gt;</span> <span>Bool</span>

    <span>// Changed to Fn so that we can alias this twice below</span>
    <span>fork</span><span>.</span><span>resume</span><span>:</span> <span>Fn</span> <span>env</span> <span>_</span>

<span>multithread_fork</span> <span>(</span><span>f</span><span>:</span> <span>Unit</span> <span>-&gt;</span> <span>a</span> <span>can</span> <span>Fork</span><span>)</span> <span>:</span> <span>a</span> <span>=</span>
    <span>handle</span> <span>f</span> <span>()</span>
    <span>|</span> <span>fork</span> <span>()</span> <span>-&gt;</span>
        <span>// Spawn two threads and wait for them both to complete</span>
        <span>Thread</span><span>.</span><span>wait</span> <span>fn</span> <span>()</span> <span>-&gt;</span>
            <span>// Error: Expected argument of `Thread.spawn` to be `Send`</span>
            <span>//        No impl found for `Send (Fn _ (Unit -&gt; Bool))`</span>
            <span>Thread</span><span>.</span><span>spawn</span> <span>(</span><span>fn</span> <span>()</span> <span>-&gt;</span> <span>resume</span> <span>true</span><span>)</span>
            <span>Thread</span><span>.</span><span>spawn</span> <span>(</span><span>fn</span> <span>()</span> <span>-&gt;</span> <span>resume</span> <span>false</span><span>)</span>
</code></pre></div><p>In order to spawn a new thread to call <code>resume</code> we’d need to require
a reference to the closure environment is <code>Send</code>:</p>
<div><pre tabindex="0"><code data-lang="ante"><span>effect</span> <span>Fork</span> <span>with</span>
    <span>fork</span><span>:</span> <span>Unit</span> <span>-&gt;</span> <span>Bool</span>
    <span>foo</span><span>.</span><span>resume</span><span>:</span> <span>Fn</span> <span>env</span> <span>_</span> <span>given</span> <span>Send</span> <span>&amp;</span><span>env</span>

<span>multithread_fork</span> <span>(</span><span>f</span><span>:</span> <span>Unit</span> <span>-&gt;</span> <span>a</span> <span>can</span> <span>Fork</span><span>)</span> <span>:</span> <span>a</span> <span>=</span>
    <span>handle</span> <span>f</span> <span>()</span>
    <span>|</span> <span>fork</span> <span>()</span> <span>-&gt;</span>
        <span>Thread</span><span>.</span><span>wait</span> <span>fn</span> <span>()</span> <span>-&gt;</span>
            <span>Thread</span><span>.</span><span>spawn</span> <span>(</span><span>fn</span> <span>()</span> <span>-&gt;</span> <span>resume</span> <span>true</span><span>)</span>
            <span>Thread</span><span>.</span><span>spawn</span> <span>(</span><span>fn</span> <span>()</span> <span>-&gt;</span> <span>resume</span> <span>false</span><span>)</span>
</code></pre></div><hr/>

<p>Ante also enables functions to be polymorphic over their effects.
For example, the <code>map</code> function has the type:</p>
<div><pre tabindex="0"><code data-lang="ante"><span>map</span><span>:</span> <span>Stream</span> <span>a</span> <span>-&gt;</span> <span>FnMut</span> <span>a</span> <span>=&gt;</span> <span>b</span> <span>can</span> <span>e</span> <span>-&gt;</span> <span>Unit</span> <span>can</span> <span>Emit</span> <span>b</span><span>,</span> <span>e</span>
</code></pre></div><p>Now, recalling the <code>FooCloneEnv</code> example from earlier:</p>
<div><pre tabindex="0"><code data-lang="ante"><span>inner_fn</span> <span>()</span> <span>:</span> <span>Unit</span> <span>can</span> <span>FooCloneEnv</span> <span>=</span>
    <span>// x may be cloned</span>
    <span>x</span> <span>=</span> <span>3</span>
    <span>foo</span> <span>()</span>
    <span>print</span> <span>x</span>

<span>outer_fn</span> <span>()</span> <span>:</span> <span>Unit</span> <span>can</span> <span>FooCloneEnv</span> <span>=</span>
    <span>// vec may also be cloned</span>
    <span>vec</span> <span>=</span> <span>Vec</span><span>.</span><span>of</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>]</span>
    <span>function2</span> <span>()</span>
    <span>print</span> <span>vec</span>
</code></pre></div><p>This works fine, but how could we pass a function such as <code>outer_fn</code> to
<code>map</code>? The effect variable <code>e</code> would be instantiated to <code>FooCloneEnv</code> but
now we’d also need to know if the environment of <code>map</code> when it calls the
passed-in function is clone-able. In the most general case, we’d need to
be able to verify any trait from <code>map</code> and whether it can allow the function
used to resume multiple times or not.</p>
<p>We’d have to add these constraints to the effect variables directly:</p>
<div><pre tabindex="0"><code data-lang="fallback">map: Stream a -&gt; FnMut a =&gt; b can e -&gt; Unit
    given Clone e, Send e, Fn e.resume _
    can Emit b, e
</code></pre></div><p>This is a big hit to the usability of effects in this scheme since these constraints
would have to be manually specified on <code>map</code> for its contents to be checked. If not
specified, a new version of <code>map</code> would have to be written with a <code>Send</code>able environment
or similar. This will inevitably lead to some duplication when using effects that algebraic
effect handlers are usually meant to remove.</p>
<p>In a later article, we’ll focus on ways to simplify the usability of this scheme by
providing sane defaults where possible.</p>
<hr/>

<p>So far, each of the rules covered above should apply to any language with effects,
ownership, and borrowing. Different implementations of effects can have wildly
different runtime costs however.</p>
<p>For example, most languages implementing the full spectrum of algebraic effects
will keep track of the stack of effect handlers at runtime. When an effect call
is made, a lookup needs to be performed then the code needs to jump to the relevant
handler and back. This may be done by jumping up the call stack and copying stack frames or
by converting effectful functions to continuation passing style (CPS) - like Ante does.</p>
<p>Languages without algebraic effects aren’t completely free from the costs of effects
either though. Even if we restrict ourselves to just the <code>async</code> effect, we can
see plenty of languages which include it - each with its own unique implementation
and performance characteristics.</p>
<p>Consider Rust’s <code>async</code> effect which is implemented by compiling async functions
to state machines. In this scheme, the following code is rejected:</p>
<div><pre tabindex="0"><code data-lang="rust"><span>async</span><span> </span><span>fn</span> <span>recursive</span><span>()</span><span> </span><span>{</span><span>
</span><span>    </span><span>recursive</span><span>().</span><span>await</span><span>;</span><span>
</span><span>    </span><span>recursive</span><span>().</span><span>await</span><span>;</span><span>
</span><span></span><span>}</span><span>
</span></code></pre></div><p>Because the resulting state machine would have infinite size:</p>
<div><pre tabindex="0"><code data-lang="rust"><span>enum</span> <span>Recursive</span><span> </span><span>{</span><span>
</span><span>    </span><span>First</span><span>(</span><span>Recursive</span><span>),</span><span>
</span><span>    </span><span>Second</span><span>(</span><span>Recursive</span><span>),</span><span>
</span><span></span><span>}</span><span>
</span></code></pre></div><p>To get around this, users need to box recursive functions:</p>
<div><pre tabindex="0"><code data-lang="rust"><span>use</span><span> </span><span>futures</span>::<span>future</span>::<span>{</span><span>BoxFuture</span><span>,</span><span> </span><span>FutureExt</span><span>};</span><span>
</span><span>
</span><span></span><span>fn</span> <span>recursive</span><span>()</span><span> </span>-&gt; <span>BoxFuture</span><span>&lt;&#39;</span><span>static</span><span>,</span><span> </span><span>()</span><span>&gt;</span><span> </span><span>{</span><span>
</span><span>    </span><span>async</span><span> </span><span>move</span><span> </span><span>{</span><span>
</span><span>        </span><span>recursive</span><span>().</span><span>await</span><span>;</span><span>
</span><span>        </span><span>recursive</span><span>().</span><span>await</span><span>;</span><span>
</span><span>    </span><span>}.</span><span>boxed</span><span>()</span><span>
</span><span></span><span>}</span><span>
</span></code></pre></div><p>If we try to implement a similar example in future-Ante<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup>:</p>
<div><pre tabindex="0"><code data-lang="ante"><span>effect</span> <span>Async</span> <span>with</span>
    <span>await</span><span>:</span> <span>Unit</span> <span>-&gt;</span> <span>Unit</span>

<span>recursive</span> <span>()</span> <span>:</span> <span>Unit</span> <span>can</span> <span>Await</span> <span>=</span>
    <span>// This doesn&#39;t quite match the semantics of the Rust example above,</span>
    <span>// but lets us use a simpler definition for `await`</span>
    <span>await</span> <span>()</span>
    <span>recursive</span> <span>()</span>
    <span>await</span> <span>()</span>
    <span>recursive</span> <span>()</span>

<span>handle</span> <span>recursive</span> <span>()</span>
<span>|</span> <span>await</span> <span>f</span> <span>-&gt;</span> <span>resume</span> <span>()</span>
</code></pre></div><p>The result would look quite different:</p>
<div><pre tabindex="0"><code data-lang="ante"><span>recursive</span> <span>()</span> <span>:</span> <span>Unit</span> <span>=</span>
    <span>recursive</span> <span>()</span>
    <span>recursive</span> <span>()</span>
</code></pre></div><p>So theoretically no boxing is needed for recursion alone.
The performance characteristics here look quite different - but that is
because in Ante they’re largely determined by the handler that is used
rather than the call site of the effect. If we use a different handler
which does not resume in a tail position, boxing will be required.
For example:</p>
<div><pre tabindex="0"><code data-lang="ante"><span>handle</span> <span>recursive</span> <span>()</span>
<span>|</span> <span>await</span> <span>f</span> <span>-&gt;</span>
    <span>resume</span> <span>(</span><span>f</span> <span>())</span>
    <span>print</span> <span>&#34;done&#34;</span>
</code></pre></div><p>Compiles to<sup id="fnref:3"><a href="#fn:3" role="doc-noteref">3</a></sup>:</p>
<div><pre tabindex="0"><code data-lang="ante"><span>recursive</span> <span>k</span> <span>=</span>
    <span>recursive</span> <span>fn</span> <span>()</span> <span>-&gt;</span>
      <span>recursive</span> <span>k</span>
      <span>print</span> <span>&#34;done&#34;</span>
    <span>print</span> <span>&#34;done&#34;</span>
</code></pre></div><p>Here we can see the inner continuation captures the outer continuation <code>k</code>.</p>
<p>To give <code>k</code> a valid type, we’d need to box it to ensure it always has the
same size for each recursive call. This is similar to what we’d need to do
in the Rust example, but there are some unique problems with requiring users manually
box these continuations in Ante:</p>
<ul>
<li>The continuation is added by the compiler, so it isn’t clear to the user where
they should add the boxing.</li>
<li>Whether boxing is required is dependent on the structure of the handler. We don’t
want to always add boxing since tail-resume is the more common case.</li>
</ul>
<p>We could try to get around this by marking whether a given effect must have a tail-resumptive
handler or not, and requiring recursive functions using non-tail-resumptive handlers to
box their continuations somehow. This would make effects much more cumbersome to use however,
and one of Ante’s goals is to be a slightly <em>higher</em> level language than Rust. If effects are
not simple to use then users will avoid them.</p>
<p>For these reasons, the current plan is for the compiler to automatically insert boxing
of closures where appropriate and infer their lifetimes via <a href="https://antelang.org/docs/ideas/#lifetime-inference">lifetime inference</a>.
Lifetime inference is a very interesting topic to me - it was one of Ante’s original goals
to experiment with it. When it works well it can be great since it can stack-allocate
potentially even to prior stack frames. The downside is that the inferred lifetimes can be imprecise.
Although, in this case, if lifetimes cannot be accurately inferred, we would still know
their longest possible lifetime is that of the effect handler.<sup id="fnref:4"><a href="#fn:4" role="doc-noteref">4</a></sup>
This is a topic that deserves much more detail though so I’ll leave it to a future
blog post. If you’re still curious, there are some papers on it reachable from the documentation link above.</p>


                        </div></div>
  </body>
</html>
