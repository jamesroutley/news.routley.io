<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/eugene-khyst/postgresql-event-sourcing">Original</a>
    <h1>Show HN: Light implementation of Event Sourcing using PostgreSQL as event store</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
            <article itemprop="text">
<ul dir="auto">
<li><a href="#1">Introduction</a></li>
<li><a href="#2">Example domain</a></li>
<li><a href="#3">Event sourcing and CQRS basics</a>
<ul dir="auto">
<li><a href="#3-1">State-oriented persistence</a></li>
<li><a href="#3-2">Event sourcing</a></li>
<li><a href="#3-3">Snapshotting</a></li>
<li><a href="#3-4">Querying the data</a></li>
<li><a href="#3-5">CQRS</a></li>
<li><a href="#3-6">Event handlers</a></li>
<li><a href="#3-7">Domain events vs Integration events</a></li>
<li><a href="#3-8">Advantages of CQRS</a></li>
<li><a href="#3-9">Advantages of event sourcing</a></li>
</ul>
</li>
<li><a href="#4">Solution architecture</a>
<ul dir="auto">
<li><a href="#4-1">Component diagram</a></li>
<li><a href="#4-2">ER diagram</a></li>
<li><a href="#4-3">Optimistic concurrency control</a></li>
<li><a href="#4-4">Snapshotting</a></li>
<li><a href="#4-5">Loading any revision of the aggregate</a></li>
<li><a href="#4-6">Synchronously updating projections</a></li>
<li><a href="#4-7">Asynchronously sending integration events to a message broker</a>
<ul dir="auto">
<li><a href="#4-7-1">Reliable transactional outbox with PostgreSQL</a></li>
<li><a href="#4-7-2">Database polling</a></li>
<li><a href="#4-7-3">Database polling alternative</a></li>
</ul>
</li>
<li><a href="#4-8">Adding new asynchronous event handlers</a></li>
<li><a href="#4-9">Drawbacks</a></li>
</ul>
</li>
<li><a href="#5">Project structure</a>
<ul dir="auto">
<li><a href="#5-1">Gradle subprojects</a></li>
<li><a href="#5-2">Database schema migrations</a></li>
<li><a href="#5-3">Class diagrams</a>
<ul dir="auto">
<li><a href="#5-3-1">Class diagram of the domain model</a></li>
<li><a href="#5-3-2">Class diagram of the projections</a></li>
<li><a href="#5-3-3">Class diagram of the service layer</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#6">How to adapt it to your domain?</a></li>
<li><a href="#7">How to run the sample?</a></li>
</ul>

<h2 tabindex="-1" id="user-content-introduction" dir="auto"><a href="#introduction"></a><a id="user-content-1"></a>Introduction<svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></h2>
<p dir="auto">Usually, our applications operate with the current state of a domain object.
But sometimes, we need to know the entire history of the domain object changes.
For example, we want to know how an order got into its current state.</p>
<p dir="auto">The audit trail (also called the audit log) is a chronological record of the history
and details of the actions that affected the system.
An audit trail may be a regulatory or business requirement.</p>
<p dir="auto">We can store all changes to the domain object state as a sequence of events in an append-only event stream.
Thus, event streams will contain an entire history of changes.
But how can we be sure that this history is authentic and error-free?
We can use event streams as a primary source of truth in a system.
To get the current state of an object, we have to replay all events in the order of occurrence.
This pattern is called event sourcing. The database for storing event streams is called an event store.
Event sourcing provides a complete and accurate record of all changes made to a system.
Event sourcing is an industry standard for implementing audit trail.</p>
<p dir="auto">There are specialized databases for event sourcing.
Developer Advocates working for the companies behind these specialized databases said
you shouldn&#39;t implement event sourcing with traditional relational or document-oriented databases.
Is this true or just a marketing ploy?</p>
<p dir="auto">Specialized databases for event sourcing are convenient and provide the necessary functionality out of the box.
But PostgreSQL, the world&#39;s most advanced open-source database, is also suitable for event sourcing.
You can use PostgreSQL as an event store without additional frameworks or extensions
instead of setting up and maintaining a separate specialized database for event sourcing.</p>
<p dir="auto">This repository provides a reference implementation of an event-sourced system
that uses PostgreSQL as an event store built with Spring Boot.
<a href="https://github.com/eugene-khyst/postgresql-event-sourcing/fork">Fork</a> the repository and use it as a template for your projects.
Or clone the repository and run end-to-end tests to see how everything works together.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/eugene-khyst/postgresql-event-sourcing/blob/main/img/potgresql-logo.png"><img src="https://github.com/eugene-khyst/postgresql-event-sourcing/raw/main/img/potgresql-logo.png" alt="PostgreSQL Logo"/></a></p>
<p dir="auto">See also</p>
<ul dir="auto">
<li><a href="https://github.com/eugene-khyst/eventstoredb-event-sourcing">Event Sourcing with EventStoreDB</a></li>
<li><a href="https://github.com/eugene-khyst/ksqldb-event-souring">Event Sourcing with Kafka and ksqlDB</a></li>
</ul>
<h2 tabindex="-1" id="user-content-example-domain" dir="auto"><a href="#example-domain"></a><a id="user-content-2"></a>Example domain<svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></h2>
<p dir="auto">This sample uses a simplified domain model of the ride-hailing system.</p>
<ul dir="auto">
<li>A rider can place an order for a ride along a route specifying a price.</li>
<li>A rider can edit an order price to pay more instead of waiting in cases of very high demand.</li>
<li>A driver can accept an order.</li>
<li>A driver can complete previously accepted order.</li>
<li>An order can be canceled before completion.</li>
</ul>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/eugene-khyst/postgresql-event-sourcing/blob/main/img/domain-1.svg"><img src="https://github.com/eugene-khyst/postgresql-event-sourcing/raw/main/img/domain-1.svg" alt="Domain use case diagram"/></a></p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/eugene-khyst/postgresql-event-sourcing/blob/main/img/domain-2.svg"><img src="https://github.com/eugene-khyst/postgresql-event-sourcing/raw/main/img/domain-2.svg" alt="Domain state diagram"/></a></p>
<h2 tabindex="-1" id="user-content-event-sourcing-and-cqrs-basics" dir="auto"><a href="#event-sourcing-and-cqrs-basics"></a><a id="user-content-3"></a>Event sourcing and CQRS basics<svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></h2>
<h3 tabindex="-1" id="user-content-state-oriented-persistence" dir="auto"><a href="#state-oriented-persistence"></a><a id="user-content-3-1"></a>State-oriented persistence<svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></h3>
<p dir="auto">State-oriented persistence (CRUD) applications store only the latest version of an entity.
Database records present entities.
When an entity is updated, the corresponding database record gets updated too.
SQL <code>INSERT</code>, <code>UPDATE</code> and <code>DELETE</code> statements are used.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/eugene-khyst/postgresql-event-sourcing/blob/main/img/state-oriented-persistence.svg"><img src="https://github.com/eugene-khyst/postgresql-event-sourcing/raw/main/img/state-oriented-persistence.svg" alt="State-oriented persistence"/></a></p>
<h3 tabindex="-1" id="user-content-event-sourcing" dir="auto"><a href="#event-sourcing"></a><a id="user-content-3-2"></a>Event sourcing<svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></h3>
<p dir="auto">Event sourcing applications persist the state of an entity as a sequence of immutable state-changing events.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/eugene-khyst/postgresql-event-sourcing/blob/main/img/event-sourcing-1.svg"><img src="https://github.com/eugene-khyst/postgresql-event-sourcing/raw/main/img/event-sourcing-1.svg" alt="Event sourcing"/></a></p>
<p dir="auto">Whenever the state of an entity changes, a new event is appended to the list of events.
Only SQL <code>INSERT</code> statements are used.
Events are immutables, so SQL <code>UPDATE</code> and <code>DELETE</code> statements are not used.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/eugene-khyst/postgresql-event-sourcing/blob/main/img/event-sourcing-2.svg"><img src="https://github.com/eugene-khyst/postgresql-event-sourcing/raw/main/img/event-sourcing-2.svg" alt="Event sourcing"/></a></p>
<p dir="auto">The current state of an entity can be restored by replaying all its events.</p>
<p dir="auto">Event sourcing is closely related to domain-driven design (DDD) and shares some terminology.</p>
<p dir="auto">An entity in event sourcing is called an <strong>aggregate</strong>.</p>
<p dir="auto">A sequence of events for the same aggregate is called a <strong>stream</strong>.</p>
<p dir="auto">Event sourcing is best suited for short-living entities with a small total number of
events (e.g., orders).</p>
<p dir="auto">Restoring the state of the short-living entity by replaying all its events doesn&#39;t have any
performance impact. Thus, no optimizations for restoring state are required for short-living
entities.</p>
<p dir="auto">For endlessly stored entities (e.g., users, bank accounts) with thousands of events restoring state
by replaying all events is not optimal, and snapshotting should be considered.</p>
<h3 tabindex="-1" id="user-content-snapshotting" dir="auto"><a href="#snapshotting"></a><a id="user-content-3-3"></a>Snapshotting<svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></h3>
<p dir="auto">Snapshotting is an optimization technique where a snapshot of the aggregate&#39;s state is also saved,
so an application can restore the current state of the aggregate from the snapshot rather than from
all the events (potentially thousands).</p>
<p dir="auto">On every <em>nth</em> event, make an aggregate snapshot by storing an aggregate state and its version.</p>
<p dir="auto">To restore an aggregate state:</p>
<ol dir="auto">
<li>first read the latest snapshot,</li>
<li>then read events forward from the original stream starting from the version pointed by the snapshot.</li>
</ol>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/eugene-khyst/postgresql-event-sourcing/blob/main/img/event-sourcing-snapshotting.svg"><img src="https://github.com/eugene-khyst/postgresql-event-sourcing/raw/main/img/event-sourcing-snapshotting.svg" alt="Snapshotting in event souring"/></a></p>
<h3 tabindex="-1" id="user-content-querying-the-data" dir="auto"><a href="#querying-the-data"></a><a id="user-content-3-4"></a>Querying the data<svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></h3>
<p dir="auto">It&#39;s easy to find an aggregate by ID, but other queries are difficult.
Since aggregates are stored as append-only lists of immutable events,
querying the data using SQL, as we used to, is impossible.
To find an aggregate by some field, we need to first read all the events and replay them to restore all the aggregates.</p>
<p dir="auto">To bring back all the querying power a relational database has to offer,
we can create a dedicated read model derived from the event stream.</p>
<p dir="auto">The event stream is the write model and the primary source of truth.</p>
<p dir="auto">The read model is a &#34;denormalized&#34; view of the write model, allowing faster and more convenient querying.
Read models are projections of the system state.
Therefore, read models are also known as <strong>projections</strong>.</p>
<p dir="auto">Projections provide a view of data for a single aggregate type
or perform aggregations and combine data from multiple aggregate types.</p>
<p dir="auto">That&#39;s where CQRS comes in handy.</p>
<h3 tabindex="-1" id="user-content-cqrs" dir="auto"><a href="#cqrs"></a><a id="user-content-3-5"></a>CQRS<svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></h3>
<p dir="auto">Command-query responsibility segregation (CQRS) stands for segregating the responsibility between
commands (write requests) and queries (read requests).
The write requests and the read requests are processed by different handlers.</p>
<p dir="auto">A command generates zero or more events or results in an error.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/eugene-khyst/postgresql-event-sourcing/blob/main/img/cqrs-1.svg"><img src="https://github.com/eugene-khyst/postgresql-event-sourcing/raw/main/img/cqrs-1.svg" alt="CQRS"/></a></p>
<p dir="auto">CQRS is a self-sufficient architectural pattern and doesn&#39;t require event sourcing.
But in practice, event sourcing is usually used in conjunction with CQRS.
Event store is used as a write database, and SQL or NoSQL database as a read database.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/eugene-khyst/postgresql-event-sourcing/blob/main/img/cqrs-2.svg"><img src="https://github.com/eugene-khyst/postgresql-event-sourcing/raw/main/img/cqrs-2.svg" alt="CQRS with event sourcing"/></a></p>
<h3 tabindex="-1" id="user-content-event-handlers" dir="auto"><a href="#event-handlers"></a><a id="user-content-3-6"></a>Event handlers<svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></h3>
<p dir="auto">Commands generate events.
Event processing is done by <strong>event handlers</strong>.
As a part of event processing, we may need to update projections,
send a message to a message broker, or make an API call.</p>
<p dir="auto">There are two types of event handlers: <strong>synchronous</strong> and <strong>asynchronous</strong>.</p>
<p dir="auto">Storing the write model and read model in the same database allows for transactional updates of the read model.
Each time we append a new event, the projection is updated <strong>synchronously</strong> in the same transaction.
The projection is <strong>consistent</strong> with the event stream.</p>
<p dir="auto">When an event handler communicates with an external system or middleware (e.g., sends a message to Kafka),
it should run <strong>asynchronously</strong> after the transaction updating the write model.
Asynchronous execution leads to <strong>eventual consistency</strong>.</p>
<p dir="auto">Communication with external systems should not occur in the same transaction updating the write model.
The external system call may succeed, but the transaction will later be rolled back, resulting in an inconsistency.</p>
<p dir="auto">Anyway, distributed systems should be designed with eventual consistency in mind.</p>
<h3 tabindex="-1" id="user-content-domain-events-vs-integration-events" dir="auto"><a href="#domain-events-vs-integration-events"></a><a id="user-content-3-7"></a>Domain events vs Integration events<svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></h3>
<p dir="auto">Events in event sourcing are <strong>domain events</strong>.
The domain event is a part of a bounded context and should not be used &#34;as-is&#34; for integration with other bounded
contexts.</p>
<p dir="auto">For communication between bounded contexts <strong>integration events</strong> are used.
The integration event represents the current state of an aggregate, not just changes to the aggregate as a domain event.</p>
<h3 tabindex="-1" id="user-content-advantages-of-cqrs" dir="auto"><a href="#advantages-of-cqrs"></a><a id="user-content-3-8"></a>Advantages of CQRS<svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></h3>
<ul dir="auto">
<li>Independent scaling of the read and write databases.</li>
<li>Optimized data schema for the read database (e.g. the read databases can be denormalized).</li>
<li>Simpler queries (e.g. complex <code>JOIN</code> operations can be avoided).</li>
</ul>
<h3 tabindex="-1" id="user-content-advantages-of-event-sourcing" dir="auto"><a href="#advantages-of-event-sourcing"></a><a id="user-content-3-9"></a>Advantages of event sourcing<svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></h3>
<ul dir="auto">
<li>A true history of the system (audit and traceability).
An industry standard for implementing audit trail.</li>
<li>Ability to put the system in any prior state (e.g. for debugging).</li>
<li>New read-side projections can be created as needed (later) from events.
It allows responding to future needs and new requirements.</li>
</ul>
<h2 tabindex="-1" id="user-content-solution-architecture" dir="auto"><a href="#solution-architecture"></a><a id="user-content-4"></a>Solution architecture<svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></h2>
<p dir="auto">PostgreSQL can be used as an event store.
It will natively support appending events, concurrency control and reading events.
Subscribing on events requires additional implementation.</p>
<h3 tabindex="-1" id="user-content-component-diagram" dir="auto"><a href="#component-diagram"></a><a id="user-content-4-1"></a>Component diagram<svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></h3>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/eugene-khyst/postgresql-event-sourcing/blob/main/img/postgresql-event-sourcing.svg"><img src="https://github.com/eugene-khyst/postgresql-event-sourcing/raw/main/img/postgresql-event-sourcing.svg" alt="PostgreSQL event store component diagram"/></a></p>
<h3 tabindex="-1" id="user-content-er-diagram" dir="auto"><a href="#er-diagram"></a><a id="user-content-4-2"></a>ER diagram<svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></h3>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/eugene-khyst/postgresql-event-sourcing/blob/main/img/er-diagram.svg"><img src="https://github.com/eugene-khyst/postgresql-event-sourcing/raw/main/img/er-diagram.svg" alt="PostgreSQL event store ER diagram"/></a></p>
<p dir="auto">Events are stored in the <code>ES_EVENT</code> table.</p>
<h3 tabindex="-1" id="user-content-optimistic-concurrency-control" dir="auto"><a href="#optimistic-concurrency-control"></a><a id="user-content-4-3"></a>Optimistic concurrency control<svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></h3>
<p dir="auto">Latest aggregate version is stored in the <code>ES_AGGREGATE</code> table.
Version checking is used for optimistic concurrency control.
Version checking uses version numbers to detect conflicting updates (and to prevent lost updates).</p>
<p dir="auto">Appending an event operation consists of 2 SQL statements in a single transaction:</p>
<ol dir="auto">
<li>check the actual and expected version match and increment the version
<div dir="auto" data-snippet-clipboard-copy-content="UPDATE ES_AGGREGATE
   SET VERSION = :newVersion
 WHERE ID = :aggregateId
   AND VERSION = :expectedVersion"><pre><span>UPDATE</span> ES_AGGREGATE
   <span>SET</span> VERSION <span>=</span> :newVersion
 <span>WHERE</span> ID <span>=</span> :aggregateId
   <span>AND</span> VERSION <span>=</span> :expectedVersion</pre></div>
</li>
<li>insert new event
<div dir="auto" data-snippet-clipboard-copy-content="INSERT INTO ES_EVENT (TRANSACTION_ID, AGGREGATE_ID, VERSION, EVENT_TYPE, JSON_DATA)
VALUES(pg_current_xact_id(), :aggregateId, :version, :eventType, :jsonObj::json)
RETURNING ID, TRANSACTION_ID::text, EVENT_TYPE, JSON_DATA"><pre><span>INSERT INTO</span> ES_EVENT (TRANSACTION_ID, AGGREGATE_ID, VERSION, EVENT_TYPE, JSON_DATA)
<span>VALUES</span>(pg_current_xact_id(), :aggregateId, :version, :eventType, :jsonObj::json)
RETURNING ID, TRANSACTION_ID::<span>text</span>, EVENT_TYPE, JSON_DATA</pre></div>
<code>pg_current_xact_id()</code> returns the current transaction&#39;s ID. The need for this will be explained later.</li>
</ol>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/eugene-khyst/postgresql-event-sourcing/blob/main/img/event-sourcing-concurrency.svg"><img src="https://github.com/eugene-khyst/postgresql-event-sourcing/raw/main/img/event-sourcing-concurrency.svg" alt="Optimistic Concurrency Control"/></a></p>
<h3 tabindex="-1" id="user-content-snapshotting-1" dir="auto"><a href="#snapshotting-1"></a><a id="user-content-4-4"></a>Snapshotting<svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></h3>
<p dir="auto">On every <em>nth</em> event insert an aggregate state (snapshot) to the <code>ES_AGGREGATE_SNAPSHOT</code> table specifying the version</p>
<div dir="auto" data-snippet-clipboard-copy-content="INSERT INTO ES_AGGREGATE_SNAPSHOT (AGGREGATE_ID, VERSION, JSON_DATA)
VALUES (:aggregateId, :version, :jsonObj::json)"><pre><span>INSERT INTO</span> ES_AGGREGATE_SNAPSHOT (AGGREGATE_ID, VERSION, JSON_DATA)
<span>VALUES</span> (:aggregateId, :version, :jsonObj::json)</pre></div>
<p dir="auto">Snapshotting for an aggregate type can be disabled and configured in the <a href="https://github.com/eugene-khyst/postgresql-event-sourcing/blob/main/src/main/resources/application.yml"><code>application.yml</code></a></p>
<div dir="auto" data-snippet-clipboard-copy-content="event-sourcing:
  snapshotting:
    # com.example.eventsourcing.domain.AggregateType
    ORDER:
      enabled: true
      # Create a snapshot on every nth event
      nth-event: 10"><pre><span>event-sourcing</span>:
  <span>snapshotting</span>:
    <span><span>#</span> com.example.eventsourcing.domain.AggregateType</span>
    <span>ORDER</span>:
      <span>enabled</span>: <span>true</span>
      <span><span>#</span> Create a snapshot on every nth event</span>
      <span>nth-event</span>: <span>10</span></pre></div>
<h3 tabindex="-1" id="user-content-loading-any-revision-of-the-aggregate" dir="auto"><a href="#loading-any-revision-of-the-aggregate"></a><a id="user-content-4-5"></a>Loading any revision of the aggregate<svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></h3>
<p dir="auto">To restore any revision of the aggregate:</p>
<ol dir="auto">
<li>first read the latest value of the snapshot
<div dir="auto" data-snippet-clipboard-copy-content="SELECT a.AGGREGATE_TYPE,
       s.JSON_DATA
  FROM ES_AGGREGATE_SNAPSHOT s
  JOIN ES_AGGREGATE a ON a.ID = s.AGGREGATE_ID
 WHERE s.AGGREGATE_ID = :aggregateId
   AND (:version IS NULL OR s.VERSION &lt;= :version)
 ORDER BY s.VERSION DESC
 LIMIT 1"><pre><span>SELECT</span> <span>a</span>.<span>AGGREGATE_TYPE</span>,
       <span>s</span>.<span>JSON_DATA</span>
  <span>FROM</span> ES_AGGREGATE_SNAPSHOT s
  <span>JOIN</span> ES_AGGREGATE a <span>ON</span> <span>a</span>.<span>ID</span> <span>=</span> <span>s</span>.<span>AGGREGATE_ID</span>
 <span>WHERE</span> <span>s</span>.<span>AGGREGATE_ID</span> <span>=</span> :aggregateId
   <span>AND</span> (:version IS <span>NULL</span> <span>OR</span> <span>s</span>.<span>VERSION</span> <span>&lt;=</span> :version)
 <span>ORDER BY</span> <span>s</span>.<span>VERSION</span> <span>DESC</span>
 <span>LIMIT</span> <span>1</span></pre></div>
</li>
<li>then read forward from the event stream from the revision the snapshot points to
<div dir="auto" data-snippet-clipboard-copy-content="SELECT ID,
       TRANSACTION_ID::text,
       EVENT_TYPE,
       JSON_DATA
  FROM ES_EVENT
 WHERE AGGREGATE_ID = :aggregateId
   AND (:fromVersion IS NULL OR VERSION &gt; :fromVersion)
   AND (:toVersion IS NULL OR VERSION &lt;= :toVersion)
 ORDER BY VERSION ASC"><pre><span>SELECT</span> ID,
       TRANSACTION_ID::<span>text</span>,
       EVENT_TYPE,
       JSON_DATA
  <span>FROM</span> ES_EVENT
 <span>WHERE</span> AGGREGATE_ID <span>=</span> :aggregateId
   <span>AND</span> (:fromVersion IS <span>NULL</span> <span>OR</span> VERSION <span>&gt;</span> :fromVersion)
   <span>AND</span> (:toVersion IS <span>NULL</span> <span>OR</span> VERSION <span>&lt;=</span> :toVersion)
 <span>ORDER BY</span> VERSION <span>ASC</span></pre></div>
</li>
</ol>
<h3 tabindex="-1" id="user-content-synchronously-updating-projections" dir="auto"><a href="#synchronously-updating-projections"></a><a id="user-content-4-6"></a>Synchronously updating projections<svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></h3>
<p dir="auto">Using PostgreSQL as an event store and a read database allows for transactional updates of the read model.
Each time we append a new event, the projection is updated synchronously in the same transaction.
It&#39;s a big advantage because sometimes consistency is not so easy to achieve.</p>
<p dir="auto">You can&#39;t get consistent projections when a separate database is used as an event store.</p>
<h3 tabindex="-1" id="user-content-asynchronously-sending-integration-events-to-a-message-broker" dir="auto"><a href="#asynchronously-sending-integration-events-to-a-message-broker"></a><a id="user-content-4-7"></a>Asynchronously sending integration events to a message broker<svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></h3>
<p dir="auto">Integration events should be sent asynchronously after the transaction updating the write model.</p>
<p dir="auto">PostgreSQL doesn&#39;t allow subscribing on changes, so the solution is a Transactional Outbox pattern.
A service that uses a database inserts events into an outbox table as part of the local transaction.
A separate process publishes the events inserted into database to a message broker.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/eugene-khyst/postgresql-event-sourcing/blob/main/img/transactional-outbox-1.svg"><img src="https://github.com/eugene-khyst/postgresql-event-sourcing/raw/main/img/transactional-outbox-1.svg" alt="Transactional outbox pattern"/></a></p>
<p dir="auto">We may have multiple asynchronous event handlers or so-called subscriptions.
The subscription concept is required to keep track of delivered events separately for different event handlers.
The last event processed by the event handler (subscription) is stored in the separate table <code>ES_EVENT_SUBSCRIPTION</code>.
New events are processed by polling the <code>ES_EVENT</code> table.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/eugene-khyst/postgresql-event-sourcing/blob/main/img/transactional-outbox-2.svg"><img src="https://github.com/eugene-khyst/postgresql-event-sourcing/raw/main/img/transactional-outbox-2.svg" alt="Transactional outbox pattern with subscriptions"/></a></p>
<p dir="auto">Since multiple instances of this application can run in parallel,
we need to ensure that any processing only affects the event once.
We don&#39;t want more than one event handler instance to handle the same event.</p>
<p dir="auto">This is achieved by acquiring locks on the rows of the <code>ES_EVENT_SUBSCRIPTION</code> table.
We lock the row (<code>SELECT FOR UPDATE</code>) of the currently processed subscription.</p>
<p dir="auto">To not hang other backend instances, we want to skip already locked rows (<code>SELECT FOR UPDATE SKIP LOCKED</code>)
and lock the &#34;next&#34; subscription.
It allows multiple backend instances to select different subscriptions that do not overlap.
This way, we improve availability and scalability.</p>
<p dir="auto">The event subscription processor polls <code>ES_EVENT_SUBSCRIPTION</code> table every second (interval is configurable) for new events
and processes them:</p>
<ol dir="auto">
<li>read the last transaction ID and event ID processed by the subscription and acquire lock
<div dir="auto" data-snippet-clipboard-copy-content="SELECT LAST_TRANSACTION_ID::text,
       LAST_EVENT_ID
  FROM ES_EVENT_SUBSCRIPTION
 WHERE SUBSCRIPTION_NAME = :subscriptionName
   FOR UPDATE SKIP LOCKED"><pre><span>SELECT</span> LAST_TRANSACTION_ID::<span>text</span>,
       LAST_EVENT_ID
  <span>FROM</span> ES_EVENT_SUBSCRIPTION
 <span>WHERE</span> SUBSCRIPTION_NAME <span>=</span> :subscriptionName
   FOR <span>UPDATE</span> SKIP LOCKED</pre></div>
</li>
<li>read new events
<div dir="auto" data-snippet-clipboard-copy-content="SELECT e.ID,
       e.TRANSACTION_ID::text,
       e.EVENT_TYPE,
       e.JSON_DATA
  FROM ES_EVENT e
  JOIN ES_AGGREGATE a on a.ID = e.AGGREGATE_ID
 WHERE a.AGGREGATE_TYPE = :aggregateType
   AND (e.TRANSACTION_ID, e.ID) &gt; (:lastProcessedTransactionId::xid8, :lastProcessedEventId)
   AND e.TRANSACTION_ID &lt; pg_snapshot_xmin(pg_current_snapshot())
 ORDER BY e.TRANSACTION_ID ASC, e.ID ASC"><pre><span>SELECT</span> <span>e</span>.<span>ID</span>,
       <span>e</span>.<span>TRANSACTION_ID</span>::<span>text</span>,
       <span>e</span>.<span>EVENT_TYPE</span>,
       <span>e</span>.<span>JSON_DATA</span>
  <span>FROM</span> ES_EVENT e
  <span>JOIN</span> ES_AGGREGATE a <span>on</span> <span>a</span>.<span>ID</span> <span>=</span> <span>e</span>.<span>AGGREGATE_ID</span>
 <span>WHERE</span> <span>a</span>.<span>AGGREGATE_TYPE</span> <span>=</span> :aggregateType
   <span>AND</span> (<span>e</span>.<span>TRANSACTION_ID</span>, <span>e</span>.<span>ID</span>) <span>&gt;</span> (:lastProcessedTransactionId::xid8, :lastProcessedEventId)
   <span>AND</span> <span>e</span>.<span>TRANSACTION_ID</span> <span>&lt;</span> pg_snapshot_xmin(pg_current_snapshot())
 <span>ORDER BY</span> <span>e</span>.<span>TRANSACTION_ID</span> <span>ASC</span>, <span>e</span>.<span>ID</span> <span>ASC</span></pre></div>
A comparison like <code>(a, b) &gt; (c, d)</code> is a row comparison and is equivalent to <code>a &gt; c OR (a = c AND b &gt; d)</code>.</li>
<li>update the last transaction ID and event ID processed by the subscription
<div dir="auto" data-snippet-clipboard-copy-content="UPDATE ES_EVENT_SUBSCRIPTION
   SET LAST_TRANSACTION_ID = :lastProcessedTransactionId::xid8,
       LAST_EVENT_ID = :lastProcessedEventId
 WHERE SUBSCRIPTION_NAME = :subscriptionName"><pre><span>UPDATE</span> ES_EVENT_SUBSCRIPTION
   <span>SET</span> LAST_TRANSACTION_ID <span>=</span> :lastProcessedTransactionId::xid8,
       LAST_EVENT_ID <span>=</span> :lastProcessedEventId
 <span>WHERE</span> SUBSCRIPTION_NAME <span>=</span> :subscriptionName</pre></div>
</li>
</ol>
<h4 tabindex="-1" id="user-content-reliable-transactional-outbox-with-postgresql" dir="auto"><a href="#reliable-transactional-outbox-with-postgresql"></a><a id="user-content-4-7-1"></a>Reliable transactional outbox with PostgreSQL<svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></h4>
<p dir="auto">Using only the event ID to track events processed by the subscription is unreliable
and can result in lost events.</p>
<p dir="auto">The <code>ID</code> column of the <code>ES_EVENT</code> table is of type <code>BIGSERIAL</code>.
It&#39;s a notational convenience for creating ID columns having their default values assigned from a <code>SEQUENCE</code> generator.</p>
<p dir="auto">PostgreSQL sequences can&#39;t be rolled back.
<code>SELECT nextval(&#39;ES_EVENT_ID_SEQ&#39;)</code> increments and returns the sequence value.
Even if the transaction is not yet committed, the new sequence value becomes visible to other transactions.</p>
<p dir="auto">If transaction #2 started after transaction #1 but committed first,
the event subscription processor can read the events created by transaction #2, update the last processed event ID,
and thus lose the events created by transaction #1.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/eugene-khyst/postgresql-event-sourcing/blob/main/img/postgresql-naive-outbox.svg"><img src="https://github.com/eugene-khyst/postgresql-event-sourcing/raw/main/img/postgresql-naive-outbox.svg" alt="PostgreSQL naive transactional outbox"/></a></p>
<p dir="auto">We use transaction ID with event ID to build a reliable PostgreSQL polling mechanism that doesn&#39;t lose events.</p>
<p dir="auto">Each event is supplemented with the current transaction ID.
<code>pg_current_xact_id()</code> returns the current transaction&#39;s ID of type <code>xid8</code>.
<code>xid8</code> values increase strictly monotonically and cannot be reused in the lifetime of a database cluster.</p>
<p dir="auto">The latest event that is &#34;safe&#34; to process is right before the <code>xmin</code> of the current snapshot.
<code>pg_current_snapshot()</code> returns a current snapshot, a data structure showing which transaction IDs are now in-progress.
<code>pg_snapshot_xmin(pg_snapshot)</code> returns the <code>xmin</code> of a snapshot.
<code>xmin</code> is the lowest transaction ID that was still active.
All transaction IDs less than <code>xmin</code> are either committed and visible, or rolled back.</p>
<p dir="auto">Even if transaction #2 started after transaction #1 and committed first,
the events it created won&#39;t be read by the event subscription processor until transaction #1 is committed.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/eugene-khyst/postgresql-event-sourcing/blob/main/img/postgresql-reliable-outbox.svg"><img src="https://github.com/eugene-khyst/postgresql-event-sourcing/raw/main/img/postgresql-reliable-outbox.svg" alt="PostgreSQL reliable transactional outbox"/></a></p>
<h4 tabindex="-1" id="user-content-database-polling" dir="auto"><a href="#database-polling"></a><a id="user-content-4-7-2"></a>Database polling<svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></h4>
<p dir="auto">To get new events from the <code>ES_EVENT</code> table, the application has to poll the database.
The shorter the polling period, the shorter the delay between persisting a new event and processing it by the subscription.
But the lag is inevitable. If the polling period is 1 second, then the lag is at most 1 second.</p>
<p dir="auto">The polling mechanism implementation <a href="https://github.com/eugene-khyst/postgresql-event-sourcing/blob/main/src/main/java/com/example/eventsourcing/service/ScheduledEventSubscriptionProcessor.java">ScheduledEventSubscriptionProcessor</a>
uses a Spring annotation <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/scheduling/annotation/Scheduled.html" rel="nofollow">@Scheduled</a> to poll database with a fixed period.</p>
<p dir="auto">The polling event subscription processing can be enabled and configured in the <a href="https://github.com/eugene-khyst/postgresql-event-sourcing/blob/main/src/main/resources/application.yml"><code>application.yml</code></a></p>
<div dir="auto" data-snippet-clipboard-copy-content="event-sourcing:
  subscriptions: polling # Enable database polling subscription processing
  polling-subscriptions:
    polling-initial-delay: PT1S
    polling-interval: PT1S"><pre><span>event-sourcing</span>:
  <span>subscriptions</span>: <span>polling </span><span><span>#</span> Enable database polling subscription processing</span>
  <span>polling-subscriptions</span>:
    <span>polling-initial-delay</span>: <span>PT1S</span>
    <span>polling-interval</span>: <span>PT1S</span></pre></div>
<h4 tabindex="-1" id="user-content-database-polling-alternative" dir="auto"><a href="#database-polling-alternative"></a><a id="user-content-4-7-3"></a>Database polling alternative<svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></h4>
<p dir="auto">To reduce the lag associated with database polling, the polling period can be set to a very low value,
such as 1 second.
But this means that there will be 3600 database queries per hour and 86400 per day, even if there are no new events.</p>
<p dir="auto">PostgreSQL <code>LISTEN</code> and <code>NOTIFY</code> feature can be used instead of polling.
This mechanism allows for sending asynchronous notifications across database connections.
Notifications are not sent directly from the application,
but via the database <a href="https://github.com/eugene-khyst/postgresql-event-sourcing/blob/main/src/main/resources/db/migration/V2__notify_trigger.sql">trigger</a> on a table.</p>
<p dir="auto">To use this functionality an unshared <a href="https://jdbc.postgresql.org/documentation/publicapi/org/postgresql/jdbc/PgConnection.html" rel="nofollow">PgConnection</a>
which remains open is required.
The long-lived dedicated JDBC <code>Connection</code> for receiving notifications has to be created using the <code>DriverManager</code> API,
instead of getting from a pooled <code>DataSource</code>.</p>
<p dir="auto">PostgreSQL JDBC driver can&#39;t receive asynchronous notifications
and must poll the backend to check if any notifications were issued.
A timeout can be given to the poll function <code>getNotifications(int timeoutMillis)</code>,
but then the execution of statements from other threads will block.
When <code>timeoutMillis</code> = 0, blocks forever or until at least one notification has been received.
It means that notification is delivered almost immediately, without a lag.
If more than one notification is about to be received, these will be returned in one batch.</p>
<p dir="auto">This solution  significantly reduces the number of issued queries
and also solves the lag problem that the polling solution suffers from.</p>
<p dir="auto">The Listen/Notify mechanism implementation <a href="https://github.com/eugene-khyst/postgresql-event-sourcing/blob/main/src/main/java/com/example/eventsourcing/service/PostgresChannelEventSubscriptionProcessor.java">PostgresChannelEventSubscriptionProcessor</a>
is inspired by the Spring Integration class <a href="https://github.com/spring-projects/spring-integration/blob/v6.0.0/spring-integration-jdbc/src/main/java/org/springframework/integration/jdbc/channel/PostgresChannelMessageTableSubscriber.java">PostgresChannelMessageTableSubscriber</a>.</p>
<p dir="auto">The Listen/Notify event subscription processing can be enabled in the <a href="https://github.com/eugene-khyst/postgresql-event-sourcing/blob/main/src/main/resources/application.yml"><code>application.yml</code></a></p>
<div dir="auto" data-snippet-clipboard-copy-content="event-sourcing:
  subscriptions: postgres-channel # Enable Listen/Notify event subscription processing"><pre><span>event-sourcing</span>:
  <span>subscriptions</span>: <span>postgres-channel </span><span><span>#</span> Enable Listen/Notify event subscription processing</span></pre></div>
<p dir="auto">This mechanism is used by default as more efficient.</p>
<h3 tabindex="-1" id="user-content-adding-new-asynchronous-event-handlers" dir="auto"><a href="#adding-new-asynchronous-event-handlers"></a><a id="user-content-4-8"></a>Adding new asynchronous event handlers<svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></h3>
<p dir="auto">After restarting the backend, existing subscriptions will only process new events after the last processed event
and not everything from the first one.</p>
<p dir="auto"><span><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M6.457 1.047c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0 1 14.082 15H1.918a1.75 1.75 0 0 1-1.543-2.575Zm1.763.707a.25.25 0 0 0-.44 0L1.698 13.132a.25.25 0 0 0 .22.368h12.164a.25.25 0 0 0 .22-.368Zm.53 3.996v2.5a.75.75 0 0 1-1.5 0v-2.5a.75.75 0 0 1 1.5 0ZM9 11a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z"></path></svg>Warning</span></p>
<h3 tabindex="-1" id="user-content-drawbacks" dir="auto"><a href="#drawbacks"></a><a id="user-content-4-9"></a>Drawbacks<svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></h3>
<p dir="auto">Using PostgreSQL as an event store has a lot of advantages, but there are also drawbacks.</p>
<ol dir="auto">
<li><strong>Asynchronous event handlers can process the same event more than once.</strong>
It might crash after processing an event but before recording the fact that it has done so.
When it restarts, it will then process the same event again (e.g., send an integration event).
Integration events are delivered with <strong>at-least-once</strong> delivery guarantee.
The exactly-once delivery guarantee is hard to achieve due to a dual-write.
A dual-write describes a situation when you need to atomically update the database and publish messages
without two-phase commit (2PC).
Consumers of integration events should be idempotent and filter duplicates and unordered events.</li>
<li>The asynchronous event handling results in the <strong>eventual consistency between the write model and sent integration events</strong>.
The polling database table for new events with a fixed delay introduces a full consistency lag
greater than or equal to the interval between polls (1 second by default).</li>
<li><strong>A long-running transaction in the same database will effectively &#34;pause&#34; all event handlers.</strong>
<code>pg_snapshot_xmin(pg_snapshot)</code> will return the ID of this long-running transaction
and events created by all later transactions will be read by the event subscription processor
only after this long-running transaction is committed.</li>
</ol>
<h2 tabindex="-1" id="user-content-project-structure" dir="auto"><a href="#project-structure"></a><a id="user-content-5"></a>Project structure<svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></h2>
<h3 tabindex="-1" id="user-content-gradle-subprojects" dir="auto"><a href="#gradle-subprojects"></a><a id="user-content-5-1"></a>Gradle subprojects<svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></h3>
<p dir="auto">This reference implementation can be easily extended to comply with your domain model.</p>
<p dir="auto">Event sourcing related code and application specific code are located in separate Gradle subprojects:</p>
<ul dir="auto">
<li><a href="https://github.com/eugene-khyst/postgresql-event-sourcing/blob/main/postgresql-event-sourcing-core"><code>postgresql-event-sourcing-core</code></a>: event sourcing and PostgreSQL related code, a shared library, <code>eventsourcing.postgresql</code> package,</li>
<li><a href="https://github.com/eugene-khyst/postgresql-event-sourcing/blob/main/event-sourcing-app"><code>event-sourcing-app</code></a>: application specific code, a simplified ride-hailing sample, <code>com.example.eventsourcing</code> package.</li>
</ul>
<p dir="auto"><code>event-sourcing-app</code> depends on <code>postgresql-event-sourcing-core</code>:</p>
<div dir="auto" data-snippet-clipboard-copy-content="dependencies {
    implementation project(&#39;:postgresql-event-sourcing-core&#39;)
}"><pre>dependencies {
    implementation project(<span><span>&#39;</span>:postgresql-event-sourcing-core<span>&#39;</span></span>)
}</pre></div>
<h3 tabindex="-1" id="user-content-database-schema-migrations" dir="auto"><a href="#database-schema-migrations"></a><a id="user-content-5-2"></a>Database schema migrations<svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></h3>
<p dir="auto">Event sourcing related database schema migrations:</p>
<ul dir="auto">
<li><a href="https://github.com/eugene-khyst/postgresql-event-sourcing/blob/main/event-sourcing-app/src/main/resources/db/migration/V1__eventsourcing_tables.sql">V1__eventsourcing_tables.sql</a></li>
<li><a href="https://github.com/eugene-khyst/postgresql-event-sourcing/blob/main/event-sourcing-app/src/main/resources/db/migration/V2__notify_trigger.sql">V2__notify_trigger.sql</a></li>
</ul>
<p dir="auto">Application specific projections database schema migration:</p>
<ul dir="auto">
<li><a href="https://github.com/eugene-khyst/postgresql-event-sourcing/blob/main/event-sourcing-app/src/main/resources/db/migration/V3__projection_tables.sql">V3__projection_tables.sql</a></li>
</ul>
<h3 tabindex="-1" id="user-content-class-diagrams" dir="auto"><a href="#class-diagrams"></a><a id="user-content-5-3"></a>Class diagrams<svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></h3>
<h4 tabindex="-1" id="user-content-class-diagram-of-the-domain-model" dir="auto"><a href="#class-diagram-of-the-domain-model"></a><a id="user-content-5-3-1"></a>Class diagram of the domain model<svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></h4>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/eugene-khyst/postgresql-event-sourcing/blob/main/img/class-domain.svg"><img src="https://github.com/eugene-khyst/postgresql-event-sourcing/raw/main/img/class-domain.svg" alt="Class diagram of the domain model"/></a></p>
<h4 tabindex="-1" id="user-content-class-diagram-of-the-projections" dir="auto"><a href="#class-diagram-of-the-projections"></a><a id="user-content-5-3-2"></a>Class diagram of the projections<svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></h4>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/eugene-khyst/postgresql-event-sourcing/blob/main/img/class-projection.svg"><img src="https://github.com/eugene-khyst/postgresql-event-sourcing/raw/main/img/class-projection.svg" alt="Class diagram of the projections"/></a></p>
<h4 tabindex="-1" id="user-content-class-diagram-of-the-service-layer" dir="auto"><a href="#class-diagram-of-the-service-layer"></a><a id="user-content-5-3-3"></a>Class diagram of the service layer<svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></h4>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/eugene-khyst/postgresql-event-sourcing/blob/main/img/class-service.svg"><img src="https://github.com/eugene-khyst/postgresql-event-sourcing/raw/main/img/class-service.svg" alt="Class diagram of the service layer"/></a></p>
<h2 tabindex="-1" id="user-content-how-to-adapt-it-to-your-domain" dir="auto"><a href="#how-to-adapt-it-to-your-domain"></a><a id="user-content-6"></a>How to adapt it to your domain?<svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></h2>
<p dir="auto">To adapt this sample to your domain model, make changes to <code>event-sourcing-app</code> subproject.
No changes to <code>postgresql-event-sourcing-core</code> subproject are required.</p>
<h2 tabindex="-1" id="user-content-how-to-run-the-sample" dir="auto"><a href="#how-to-run-the-sample"></a><a id="user-content-7"></a>How to run the sample?<svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></h2>
<ol dir="auto">
<li>
<p dir="auto">Download &amp; install <a href="https://sdkman.io/install" rel="nofollow">SDKMAN!</a>.</p>
</li>
<li>
<p dir="auto">Install JDK 21</p>
<div dir="auto" data-snippet-clipboard-copy-content="sdk list java
sdk install java 21-tem"><pre>sdk list java
sdk install java 21-tem</pre></div>
</li>
<li>
<p dir="auto">Install <a href="https://docs.docker.com/engine/install/" rel="nofollow">Docker</a>
and <a href="https://docs.docker.com/compose/install/" rel="nofollow">Docker Compose</a>.</p>
</li>
<li>
<p dir="auto">Build Java project and Docker image</p>
<div dir="auto" data-snippet-clipboard-copy-content="./gradlew clean build jibDockerBuild -i"><pre>./gradlew clean build jibDockerBuild -i</pre></div>
</li>
<li>
<p dir="auto">Run PostgreSQL, Kafka and event-sourcing-app</p>
<div dir="auto" data-snippet-clipboard-copy-content="docker compose --env-file gradle.properties up -d --scale event-sourcing-app=2
# wait a few minutes"><pre>docker compose --env-file gradle.properties up -d --scale event-sourcing-app=2
<span><span>#</span> wait a few minutes</span></pre></div>
</li>
<li>
<p dir="auto">Follow the logs of the application</p>
<div dir="auto" data-snippet-clipboard-copy-content="docker compose logs -f event-sourcing-app"><pre>docker compose logs -f event-sourcing-app</pre></div>
</li>
<li>
<p dir="auto">Run E2E tests and see the output</p>
<div dir="auto" data-snippet-clipboard-copy-content="E2E_TESTING=true ./gradlew clean test -i"><pre>E2E_TESTING=true ./gradlew clean <span>test</span> -i</pre></div>
</li>
<li>
<p dir="auto">Explore the database using the Adminer database management tool at <a href="http://localhost:8181" rel="nofollow">http://localhost:8181</a>.
Find the database name, user, and password in the <a href="https://github.com/eugene-khyst/postgresql-event-sourcing/blob/main/docker-compose.yml">docker-compose.yml</a>.</p>
</li>
</ol>
<p dir="auto">You can also manually call the REST API endpoints.</p>
<ol dir="auto">
<li>
<p dir="auto">Install <a href="https://curl.se/" rel="nofollow">curl</a> and <a href="https://stedolan.github.io/jq/" rel="nofollow">jq</a></p>

</li>
<li>
<p dir="auto">Place new order</p>
<div dir="auto" data-snippet-clipboard-copy-content="ORDER_ID=$(curl -s -X POST http://localhost:8080/orders -d &#39;{&#34;riderId&#34;:&#34;63770803-38f4-4594-aec2-4c74918f7165&#34;,&#34;price&#34;:&#34;123.45&#34;,&#34;route&#34;:[{&#34;address&#34;:&#34;Kyiv, 17A Polyarna Street&#34;,&#34;lat&#34;:50.51980052414157,&#34;lon&#34;:30.467197278948536},{&#34;address&#34;:&#34;Kyiv, 18V Novokostyantynivska Street&#34;,&#34;lat&#34;:50.48509161169076,&#34;lon&#34;:30.485170724431292}]}&#39; -H &#39;Content-Type: application/json&#39; | jq -r .orderId)"><pre>ORDER_ID=<span><span>$(</span>curl -s -X POST http://localhost:8080/orders -d <span><span>&#39;</span>{&#34;riderId&#34;:&#34;63770803-38f4-4594-aec2-4c74918f7165&#34;,&#34;price&#34;:&#34;123.45&#34;,&#34;route&#34;:[{&#34;address&#34;:&#34;Kyiv, 17A Polyarna Street&#34;,&#34;lat&#34;:50.51980052414157,&#34;lon&#34;:30.467197278948536},{&#34;address&#34;:&#34;Kyiv, 18V Novokostyantynivska Street&#34;,&#34;lat&#34;:50.48509161169076,&#34;lon&#34;:30.485170724431292}]}<span>&#39;</span></span> -H <span><span>&#39;</span>Content-Type: application/json<span>&#39;</span></span> <span>|</span> jq -r .orderId<span>)</span></span></pre></div>
</li>
<li>
<p dir="auto">Get the placed order</p>
<div dir="auto" data-snippet-clipboard-copy-content="curl -s -X GET http://localhost:8080/orders/$ORDER_ID | jq"><pre>curl -s -X GET http://localhost:8080/orders/<span>$ORDER_ID</span> <span>|</span> jq</pre></div>
</li>
<li>
<p dir="auto">Accept the order</p>
<div dir="auto" data-snippet-clipboard-copy-content="curl -s -X PUT http://localhost:8080/orders/$ORDER_ID -d &#39;{&#34;status&#34;:&#34;ACCEPTED&#34;,&#34;driverId&#34;:&#34;2c068a1a-9263-433f-a70b-067d51b98378&#34;}&#39; -H &#39;Content-Type: application/json&#39;"><pre>curl -s -X PUT http://localhost:8080/orders/<span>$ORDER_ID</span> -d <span><span>&#39;</span>{&#34;status&#34;:&#34;ACCEPTED&#34;,&#34;driverId&#34;:&#34;2c068a1a-9263-433f-a70b-067d51b98378&#34;}<span>&#39;</span></span> -H <span><span>&#39;</span>Content-Type: application/json<span>&#39;</span></span></pre></div>
</li>
<li>
<p dir="auto">Get the accepted order</p>
<div dir="auto" data-snippet-clipboard-copy-content="curl -s -X GET http://localhost:8080/orders/$ORDER_ID | jq"><pre>curl -s -X GET http://localhost:8080/orders/<span>$ORDER_ID</span> <span>|</span> jq</pre></div>
</li>
<li>
<p dir="auto">Complete the order</p>
<div dir="auto" data-snippet-clipboard-copy-content="curl -s -X PUT http://localhost:8080/orders/$ORDER_ID -d &#39;{&#34;status&#34;:&#34;COMPLETED&#34;}&#39; -H &#39;Content-Type: application/json&#39;"><pre>curl -s -X PUT http://localhost:8080/orders/<span>$ORDER_ID</span> -d <span><span>&#39;</span>{&#34;status&#34;:&#34;COMPLETED&#34;}<span>&#39;</span></span> -H <span><span>&#39;</span>Content-Type: application/json<span>&#39;</span></span></pre></div>
</li>
<li>
<p dir="auto">Get the completed order</p>
<div dir="auto" data-snippet-clipboard-copy-content="curl -s -X GET http://localhost:8080/orders/$ORDER_ID | jq"><pre>curl -s -X GET http://localhost:8080/orders/<span>$ORDER_ID</span> <span>|</span> jq</pre></div>
</li>
<li>
<p dir="auto">Try to cancel a completed order to simulate business rule violation</p>
<div dir="auto" data-snippet-clipboard-copy-content="curl -s -X PUT http://localhost:8080/orders/$ORDER_ID -d &#39;{&#34;status&#34;:&#34;CANCELLED&#34;}&#39; -H &#39;Content-Type: application/json&#39; | jq"><pre>curl -s -X PUT http://localhost:8080/orders/<span>$ORDER_ID</span> -d <span><span>&#39;</span>{&#34;status&#34;:&#34;CANCELLED&#34;}<span>&#39;</span></span> -H <span><span>&#39;</span>Content-Type: application/json<span>&#39;</span></span> <span>|</span> jq</pre></div>
</li>
<li>
<p dir="auto">Print integration events</p>
<div dir="auto" data-snippet-clipboard-copy-content="docker compose exec kafka /bin/kafka-console-consumer --bootstrap-server localhost:9092 --topic order-events --from-beginning --property print.key=true --timeout-ms 10000"><pre>docker compose <span>exec</span> kafka /bin/kafka-console-consumer --bootstrap-server localhost:9092 --topic order-events --from-beginning --property print.key=true --timeout-ms 10000</pre></div>
</li>
</ol>
</article>
          </div></div>
  </body>
</html>
