<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://bytes.zone/posts/modeling-crdts-in-alloy-counters/">Original</a>
    <h1>modeling CRDTs in Alloy - counters</h1>
    
    <div id="readability-page-1" class="page"><article><p><em>Brian Hicks, November 27, 2023</em></p><p>Hey, welcome back! <a href="https://bytes.zone/posts/modeling-crdts-in-alloy-introduction-and-the-importance-of-idempotence/">Last time, we introduced conflict-free replicated datatypes (CRDTs) and modeled them in Alloy by using boolean <code>OR</code> as our merge function</a>.</p><p>As a quick recap, CRDTs give you eventual consistency, no matter how out of sync the data originally was. This makes them great for local-first or networked multiplayer applications. If you can write a <code>merge</code> function for a data structure that is commutative, associative, and idempotent, you might be able to build a CRDT on top of it.</p><p>Further, we&#39;re modeling all these semantics in <a href="https://alloytools.org">Alloy</a>, a lightweight formal methods tool good for modeling and analyzing data structures. We&#39;ll see some cool stuff it can do in a second.</p><h2 id="counting-birds">Counting Birds</h2><p>Last time our document was a single boolean. That&#39;s useful, but we can&#39;t build an application on top of it, so let&#39;s keep moving. To get much further, we&#39;re going to have to figure out how to sync numbers back and forth. Let&#39;s use the <a href="https://www.birdcount.org/">the Great Backyard Bird Count</a> as an example. Say we&#39;re counting <a href="https://www.allaboutbirds.org/guide/Red-tailed_Hawk/id">red-tailed hawks</a>:</p><ol><li>Everyone starts at zero.</li><li>Person A sees a hawk! Ka-kaw! They increment the counter by one.</li><li>Person B sees another hawk! Screeee! They increment the counter by one, too.</li><li>Person C sees <em>two</em> hawks. Wow! Of course, they increment the counter by two.</li><li>Day&#39;s over; good job everyone! Sync up your apps and lets see how many hawks we saw total.</li></ol><p>At first glance, we might want to use <code>+</code> as the merge function. But remember, that&#39;s not idempotent. So this might happen among three people:</p><ol><li>The group has seen four hawks total. Person A and person B have seen 1 each, person C has seen 2. Nobody has talked to anyone else.</li><li>Person A and person B sync and set both their totals to <code>1 + 1 = 2</code> (one from each, the initial count)</li><li>Person A and person C sync and set both their totals to <code>2 + 2 = 4</code> (two from A because of the previous sync)</li><li>Person B and person C sync and set both their totals to <code>2 + 4 = 6</code></li><li>Further syncs happen, and the result increases every time.</li></ol><p>In other words, we can return with a huge number of hawks when really we only saw four. That&#39;s not what we wanted! This fails because <code>+</code> is not idempotent: adding any meaningful number will always change the result.</p><p>What if we used <code>max</code> instead? It&#39;s commutative, associative, and idempotent, but the semantics don&#39;t work out here: if we used <code>max</code> to merge, we&#39;d only get to see the max of hawks that any <em>one person</em> had seen.</p><p>However, <code>max</code> would work if we synced one counter for each person and then added them together locally to get the result! Let&#39;s look at an example:</p><ol><li>Just like before, the group has seen four hawks total. Person A and person B have seen 1 each, person C has seen 2. Nobody has talked to anyone else.</li><li>Person A and person B sync their totals, going from person A&#39;s <code>{a: 1}</code> and person B&#39;s <code>{b: 1}</code> to <code>{a: 1, b: 1}</code>.</li><li>Person A and person C sync their totals, going from person A&#39;s <code>{a: 1, b: 1}</code> and person C&#39;s <code>{c: 2}</code> to <code>{a: 1, b: 2, c: 2}</code>.</li><li>Person B and person C sync their totals, finishing the sync. Now everyone has <code>{a: 1, b: 1, c: 2}</code> and anyone can compute that we&#39;ve seen four hawks total.</li></ol><p>When you have a conflicting value (say B saw another hawk later) you take the <code>max</code> of <em>that person&#39;s</em> count when syncing.</p><p>This also has the nice property of moving information through the system without requiring everyone to talk to everyone else. Consider what would happen if we did A+B, A+C, A+B instead of ending with B+C. We&#39;d end up with the same value, since A+C would have given A the count to pass along to B, except that B and C never have to talk directly. It&#39;s eventually consistent!</p><h2 id="moving-to-alloy">Moving to Alloy</h2><p>Let&#39;s model this scheme in Alloy. We&#39;ll model an ID to represent each individual birdwatcher:</p><pre data-lang="alloy"><code data-lang="alloy"><span>sig</span><span> ID {}
</span></code></pre><p>We&#39;ll also model a <code>Document</code> to allow each person to keep their count and the count of each of their peers:</p><pre data-lang="alloy"><code data-lang="alloy"><span>sig</span><span> Document {
</span><span>  id</span><span>: one</span><span> ID,
</span><span>  var counts</span><span>:</span><span> ID </span><span>-&gt; lone</span><span> Natural,
</span><span>}
</span></code></pre><p><code>A -&gt; lone B</code> means &#34;each A maps to at most one B.&#34; In other words, it makes <code>ID</code> unique in <code>counts</code> for each <code>Document</code> (the way you&#39;d expect a dictionary to work in an implementation.)</p><p>We have an error already, though. When I run this, Alloy gives me and edge case where we use the same ID for multiple documents:</p><p><img src="https://torrentfreak.com/images/duplicate-ids-in-counter-document.png" alt="An Alloy instance showing two documents using the same ID."/></p><p>If this happened we&#39;d lose data since we couldn&#39;t distinguish between values we needed to add and those we needed to <code>max</code>. Better disallow that in the model:</p><pre data-lang="alloy"><code data-lang="alloy"><span>fact</span><span> &#34;</span><span>no</span><span> two documents can have the same ID&#34; {
</span><span>  </span><span>// &#34;disj&#34; means d1 and d2 can&#39;t be the same document
</span><span>  </span><span>no disj</span><span> d1, d2</span><span>:</span><span> Document </span><span>|</span><span> d1</span><span>.</span><span>id </span><span>=</span><span> d2</span><span>.</span><span>id
</span><span>}
</span></code></pre><p>As always, adding a <code>fact</code> weakens our spec by making assumptions. So let&#39;s think: can we actually get rid of ID collisions when we implement this spec? Well, maybe… in real life, we&#39;d use some ID scheme that we were reasonably sure would never collide. In production CRDTs, it seems like this means using <a href="https://en.wikipedia.org/wiki/Universally_unique_identifier">UUIDs</a> a lot of the time. Good enough for me; let&#39;s move on.</p><p>With this change, we can get some more interesting instances of the data structure. For example, here&#39;s what it could look like when these <code>counts</code> maps are filled out:</p><p><img src="https://torrentfreak.com/images/two-counters-with-conflicting-counts.png" alt="An Alloy instance showing two documents with various counts in need of syncing."/></p><p>(You don&#39;t need to know how to read this example, but if you want to: the keys in the map are represented by the labels on the arrows. For example, &#34;Document 0 has a count for ID 1 of 0&#34;.)</p><h2 id="merging">Merging</h2><p>We don&#39;t have a way to sync yet, so let&#39;s start fixing that. Let&#39;s define <code>merge</code>, as well as adding checks that it satisfies our three laws:</p><pre data-lang="alloy"><code data-lang="alloy"><span>fun </span><span>merge[</span><span>d1, d2: ID -&gt; lone Natural</span><span>]</span><span>:</span><span> (ID </span><span>-&gt; lone</span><span> Natural) {
</span><span>  </span><span>// intent: set each value in the document to the maximum value
</span><span>  </span><span>// of that key in all the documents we&#39;re currently merging.
</span><span>  </span><span>let</span><span> allCounts </span><span>=</span><span> d1</span><span>+</span><span>d2 </span><span>|
</span><span>    { id</span><span>:</span><span> ID, count</span><span>:</span><span> Natural </span><span>|
</span><span>        id</span><span>-&gt;</span><span>count </span><span>in</span><span> allCounts
</span><span>        </span><span>and</span><span> count </span><span>=</span><span> nat/</span><span>max[</span><span>allCounts[id</span><span>]</span><span>]
</span><span>    }
</span><span>}
</span><span>
</span><span>check</span><span> MergeIsCommutative {
</span><span>  </span><span>all</span><span> d1, d2</span><span>:</span><span> Document </span><span>|
</span><span>    </span><span>merge[</span><span>d1.counts, d2.counts</span><span>] </span><span>= </span><span>merge[</span><span>d2.counts, d1.counts</span><span>]
</span><span>}
</span><span>
</span><span>check</span><span> MergeIsAssociative {
</span><span>  </span><span>all</span><span> d1, d2, d3</span><span>:</span><span> Document </span><span>|
</span><span>    </span><span>merge[</span><span>merge[d1.counts, d2.counts</span><span>]</span><span>, d3</span><span>.</span><span>counts] </span><span>= </span><span>merge[</span><span>d1.counts, merge[d2.counts, d3.counts</span><span>]</span><span>]
</span><span>}
</span><span>
</span><span>check</span><span> MergeIsIdempotent {
</span><span>  </span><span>all</span><span> d1, d2</span><span>:</span><span> Document </span><span>|
</span><span>    </span><span>merge[</span><span>d1.counts, d2.counts</span><span>] </span><span>= </span><span>merge[</span><span>merge[d1.counts, d2.counts</span><span>]</span><span>, d2</span><span>.</span><span>counts]
</span><span>}
</span></code></pre><p>Alloy says it can&#39;t find a counterexample for these three checks, so it looks like we might be in business.</p><h2 id="actions">Actions</h2><p>Next let&#39;s set up some things our documents can do. First, we should be able to increment a number in a document by removing the old count for this document and ID and addign the new one:</p><pre data-lang="alloy"><code data-lang="alloy"><span>pred </span><span>increment[</span><span>d: Document</span><span>]</span><span> {
</span><span>  </span><span>let</span><span> current </span><span>=</span><span> d</span><span>.</span><span>counts[</span><span>d.id</span><span>]</span><span> {
</span><span>    counts&#39; </span><span>=
</span><span>      counts
</span><span>      </span><span>-</span><span> d</span><span>-&gt;</span><span>d</span><span>.</span><span>id</span><span>-&gt;</span><span>current
</span><span>      </span><span>+</span><span> d</span><span>-&gt;</span><span>d</span><span>.</span><span>id</span><span>-&gt;</span><span>bounded_inc[</span><span>current</span><span>]
</span><span>  }
</span><span>}
</span></code></pre><p>About all the arrows: <code>a-&gt;b-&gt;c</code> creates a three-valued relation (you can think of it like a 3-tuple if it helps: <code>(a, b, c)</code>.) Since <code>counts</code> is actually a mapping of document-to-id-to-natural, we need this level of precision. However, this is the only place we&#39;ll this since writing <code>d.counts</code> will pop the <code>Document</code> off the left-hand side of the relation, leaving us with <code>ID -&gt; Natural</code> (as in our <code>sig</code>.)</p><p>I had to write a <code>bounded_inc</code> helper function to write <code>increment</code>. Here it is:</p><pre data-lang="alloy"><code data-lang="alloy"><span>fun </span><span>bounded_inc[</span><span>n: Natural</span><span>]</span><span>:</span><span> Natural {
</span><span>  n </span><span>=</span><span> nat/last </span><span>implies</span><span> nat/last </span><span>else</span><span> nat/</span><span>inc[</span><span>n</span><span>]
</span><span>}
</span></code></pre><p>This was necessary because Alloy&#39;s numbers are actually just regular <code>sig</code>s with an ordering.</p><p>Since we only deal with a bounded number of instances for each sig, addition and counting has a gotcha. Say you only knew the numbers 1 and 2: counting works fine up to a certain point, but if someone asked you &#34;ok, and what&#39;s after two?&#34; you wouldn&#39;t know. This is exactly what&#39;s going on with Alloy, which will return a blank set if you run out of numbers. Specs can define semantics specific to their applications, though, and in ours I&#39;ve decided that incrementing past the max is simply not allowed—a number will just stop growing a certain point.</p><p>This should not really affect the soundness of our spec, but choosing limits like this requires careful thought. Alloy is not designed for numerical computing, and forcing it means dealing with weird edge cases like this. Fortunately, that&#39;s the only place in the spec we should have to deal with this.</p><h2 id="now-we-can-sync">Now We Can Sync!</h2><p>Let&#39;s move on to <code>sync</code>, which should merge two documents:</p><pre data-lang="alloy"><code data-lang="alloy"><span>pred </span><span>sync[</span><span>d1, d2: Document</span><span>]</span><span> {
</span><span>  </span><span>let</span><span> merged </span><span>= </span><span>merge[</span><span>d1.counts, d2.counts</span><span>] </span><span>|
</span><span>    counts&#39; </span><span>=</span><span> counts </span><span>++</span><span> (d1</span><span>-&gt;</span><span>merged </span><span>+</span><span> d2</span><span>-&gt;</span><span>merged)
</span><span>}
</span></code></pre><p>Next the little bit of boilerplate that we need to treat these as actions:</p><pre data-lang="alloy"><code data-lang="alloy"><span>pred</span><span> init {
</span><span>  </span><span>// intent: set every document to 0 for its own ID
</span><span>  counts </span><span>=</span><span> { d</span><span>:</span><span> Document, i</span><span>:</span><span> ID, count</span><span>:</span><span> Zero </span><span>|</span><span> d</span><span>.</span><span>id </span><span>=</span><span> id }
</span><span>}
</span><span>
</span><span>fact</span><span> traces {
</span><span>  init
</span><span>  always {
</span><span>    (</span><span>some</span><span> d</span><span>:</span><span> Document </span><span>| </span><span>increment[</span><span>d</span><span>]</span><span>)
</span><span>    </span><span>or</span><span> (</span><span>some</span><span> d1, d2</span><span>:</span><span> Document </span><span>| </span><span>sync[</span><span>d1, d2</span><span>]</span><span>)
</span><span>  }
</span><span>}
</span></code></pre><p>Finally, let&#39;s check idempotence <a href="https://bytes.zone/posts/modeling-crdts-in-alloy-introduction-and-the-importance-of-idempotence/">like last time</a>:</p><pre data-lang="alloy"><code data-lang="alloy"><span>check</span><span> SyncIsIdempotent {
</span><span>  always </span><span>all</span><span> d1, d2</span><span>:</span><span> Document </span><span>|
</span><span>    (</span><span>sync[</span><span>d1, d2</span><span>]</span><span>; </span><span>sync[</span><span>d1, d2</span><span>]</span><span>) </span><span>implies</span><span> counts&#39; </span><span>=</span><span> counts&#39;&#39;
</span><span>}
</span></code></pre><p>Alloy can&#39;t find a counterexample for this, so I think we&#39;re done! These documents should work as CRDTs! In fact, our counters here model something called a &#34;GCounter&#34; (a &#34;grow-only&#34; counter.) There are plenty of implementations out there if you want search for that term and find some real code to read!</p><p>But… GCounters can only count up. That&#39;s a problem, right? You might think &#34;ah, we can get around that—each node could set its own count to whatever it wanted!&#34; But we&#39;d hit problems there on the first sync: since our <code>merge</code> function uses <code>max</code>, any time a node&#39;s counter decremented it&#39;d go back up to the highest-seen value on the next sync.</p><p>There&#39;s a nice way out of this predicament, though: use two counters per document, <code>positive</code> and <code>negative</code>. Both counters always go up (so <code>max</code> doesn&#39;t give us trouble) and when you need to get the value out of the document, you sum up all the values of both counters, then get the final value from <code>positive - negative</code>. Ta-da! The final can now go up and down, and you have something called a &#34;PNCounter&#34; (a &#34;positive/negative&#34; counter.)</p><p>You might also look at this and think &#34;yikes, that looks like a lot of memory for a single number… that would just be a single integer if this wasn&#39;t distributed.&#34; Yep! There&#39;s always going to be some overhead for syncing. You can minimize it, though, and people who make production-class CRDTs (like <a href="https://www.inkandswitch.com/">Ink and Switch</a>) clearly think about data compression a lot! In fact, <a href="https://jakelazaroff.com/words/making-crdts-98-percent-more-efficient/">Jake Lazaroff has written an excellent blog post about doing this in an image-based CRDT</a>. Go read that next!</p><hr/><p>Thanks to <a href="https://alloytools.discourse.group/t/merging-two-sets-of-relations-by-some-rule/407">Alcino Cunha on the Alloy forums for helping me understand how set comprehensions could be used for <code>merge</code></a>, as well as pointing out that it should be possible to specify our checks with only events. Thanks also to Jake Lazaroff for reviewing an early draft and suggesting better ways to structure this.</p></article></div>
  </body>
</html>
