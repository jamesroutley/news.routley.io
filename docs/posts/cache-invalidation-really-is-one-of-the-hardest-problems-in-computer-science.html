<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://surfingcomplexity.blog/2022/11/25/cache-invalidation-really-is-one-of-the-hardest-things-in-computer-science/">Original</a>
    <h1>Cache invalidation really is one of the hardest problems in computer science</h1>
    
    <div id="readability-page-1" class="page"><div>
		
<p>My colleagues recently wrote a <a href="https://netflixtechblog.com/seeing-through-hardware-counters-a-journey-to-threefold-performance-increase-2721924a2822">great post on the Netflix tech blog</a> about a tough performance issue they wrestled with. They ultimately diagnosed the problem as <em><a href="https://en.wikipedia.org/wiki/False_sharing">false sharing</a></em>, which is a performance problem that involves caching. </p>



<p>I’m going to take that post and write a simplified version of part of it here, as an exercise to help me understand what happened. After all, the best way to understand something is to try to explain it to someone else. </p>



<p>But note that the topic I’m writing about here is outside of my personal area of expertise, so caveat lector!</p>



<h2>The problem: two bands of CPU performance</h2>



<p>Here’s a graph from that post that illustrates the problem. It shows CPU utilization for different virtual machines instances (nodes) inside of a cluster. Note that all of the nodes are configured identically, including running the same application logic and taking the same traffic.</p>



<figure><a href="https://lorinhochstein.files.wordpress.com/2022/11/image-1.png"><img data-attachment-id="2814" data-permalink="https://surfingcomplexity.blog/2022/11/25/cache-invalidation-really-is-one-of-the-hardest-things-in-computer-science/image-1-4/" data-orig-file="https://lorinhochstein.files.wordpress.com/2022/11/image-1.png" data-orig-size="692,303" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image-1" data-image-description="" data-image-caption="" data-medium-file="https://lorinhochstein.files.wordpress.com/2022/11/image-1.png?w=300" data-large-file="https://lorinhochstein.files.wordpress.com/2022/11/image-1.png?w=692" src="https://lorinhochstein.files.wordpress.com/2022/11/image-1.png?w=692" alt="" srcset="https://lorinhochstein.files.wordpress.com/2022/11/image-1.png 692w, https://lorinhochstein.files.wordpress.com/2022/11/image-1.png?w=150 150w, https://lorinhochstein.files.wordpress.com/2022/11/image-1.png?w=300 300w" sizes="(max-width: 692px) 100vw, 692px"/></a></figure>



<p>Note that there are two “bands”, a low band at around 15-20% CPU utilization, and a high band that varies a lot, from about 25%-90%.</p>



<h2>Caching and multiple cores</h2>



<p>Computer programs keep the data that they need in main memory. The problem with main memory is that accessing it is slow in computer time. According to <a href="https://specbranch.com/posts/common-perf-numbers/">this site</a>, a CPU instruction cycle is about 400ps, and accessing main memory (DRAM access) is 50-100ns, which means it takes ~ 125 – 250 cycles. To improve performance, CPUs keep some of the memory in a faster, local cache.</p>



<p>There’s a tradeoff between the size of the cache and its speed, and so computer architects use a hierarchical cache design where they have multiple caches of different sizes and speeds. It was an interaction pattern with the fastest on-core cache (the L1 cache) that led to the problem described here, so that’s the cache we’ll focus on in this post. </p>



<figure><a href="https://lorinhochstein.files.wordpress.com/2022/11/cache-1.jpg"><img data-attachment-id="2825" data-permalink="https://surfingcomplexity.blog/2022/11/25/cache-invalidation-really-is-one-of-the-hardest-things-in-computer-science/cache-1/" data-orig-file="https://lorinhochstein.files.wordpress.com/2022/11/cache-1.jpg" data-orig-size="1192,745" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;1&#34;}" data-image-title="cache-1" data-image-description="" data-image-caption="" data-medium-file="https://lorinhochstein.files.wordpress.com/2022/11/cache-1.jpg?w=300" data-large-file="https://lorinhochstein.files.wordpress.com/2022/11/cache-1.jpg?w=1024" src="https://lorinhochstein.files.wordpress.com/2022/11/cache-1.jpg?w=1024" alt="" srcset="https://lorinhochstein.files.wordpress.com/2022/11/cache-1.jpg?w=1024 1024w, https://lorinhochstein.files.wordpress.com/2022/11/cache-1.jpg?w=150 150w, https://lorinhochstein.files.wordpress.com/2022/11/cache-1.jpg?w=300 300w, https://lorinhochstein.files.wordpress.com/2022/11/cache-1.jpg?w=768 768w, https://lorinhochstein.files.wordpress.com/2022/11/cache-1.jpg 1192w" sizes="(max-width: 1024px) 100vw, 1024px"/></a></figure>



<p>If you’re a computer engineer designing a multi-core system where each core has on-core cache, your system has to implement a solution for the problem known as <em>cache coherency</em>.</p>



<h2>Cache coherency</h2>



<p>Imagine a multi-threaded program where each thread is running on a different core:</p>



<ul>
<li>thread T1 runs on CPU 1</li>



<li>thread T2 runs on CPU 2</li>
</ul>



<p>There’s a variable used by the program, which we’ll call <em>x</em>. </p>



<p>Let’s also assume that both threads have previously read <em>x</em>, so the memory associated with x is loaded in the caches of both. So the caches look like this:</p>



<figure><a href="https://lorinhochstein.files.wordpress.com/2022/11/cache-2.jpg"><img data-attachment-id="2827" data-permalink="https://surfingcomplexity.blog/2022/11/25/cache-invalidation-really-is-one-of-the-hardest-things-in-computer-science/cache-2/" data-orig-file="https://lorinhochstein.files.wordpress.com/2022/11/cache-2.jpg" data-orig-size="1192,745" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;1&#34;}" data-image-title="cache-2" data-image-description="" data-image-caption="" data-medium-file="https://lorinhochstein.files.wordpress.com/2022/11/cache-2.jpg?w=300" data-large-file="https://lorinhochstein.files.wordpress.com/2022/11/cache-2.jpg?w=1024" src="https://lorinhochstein.files.wordpress.com/2022/11/cache-2.jpg?w=1024" alt="" srcset="https://lorinhochstein.files.wordpress.com/2022/11/cache-2.jpg?w=1024 1024w, https://lorinhochstein.files.wordpress.com/2022/11/cache-2.jpg?w=150 150w, https://lorinhochstein.files.wordpress.com/2022/11/cache-2.jpg?w=300 300w, https://lorinhochstein.files.wordpress.com/2022/11/cache-2.jpg?w=768 768w, https://lorinhochstein.files.wordpress.com/2022/11/cache-2.jpg 1192w" sizes="(max-width: 1024px) 100vw, 1024px"/></a></figure>



<p>Now imagine thread T1 modifies x, and then T2 reads x.  </p>



<figure><a href="https://lorinhochstein.files.wordpress.com/2022/11/cache-3.jpg"><img data-attachment-id="2828" data-permalink="https://surfingcomplexity.blog/2022/11/25/cache-invalidation-really-is-one-of-the-hardest-things-in-computer-science/cache-3/" data-orig-file="https://lorinhochstein.files.wordpress.com/2022/11/cache-3.jpg" data-orig-size="1192,745" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;1&#34;}" data-image-title="cache-3" data-image-description="" data-image-caption="" data-medium-file="https://lorinhochstein.files.wordpress.com/2022/11/cache-3.jpg?w=300" data-large-file="https://lorinhochstein.files.wordpress.com/2022/11/cache-3.jpg?w=1024" src="https://lorinhochstein.files.wordpress.com/2022/11/cache-3.jpg?w=1024" alt="" srcset="https://lorinhochstein.files.wordpress.com/2022/11/cache-3.jpg?w=1024 1024w, https://lorinhochstein.files.wordpress.com/2022/11/cache-3.jpg?w=150 150w, https://lorinhochstein.files.wordpress.com/2022/11/cache-3.jpg?w=300 300w, https://lorinhochstein.files.wordpress.com/2022/11/cache-3.jpg?w=768 768w, https://lorinhochstein.files.wordpress.com/2022/11/cache-3.jpg 1192w" sizes="(max-width: 1024px) 100vw, 1024px"/></a></figure>



<pre><code>
T1             T2
--             --
x = x + 1

              if(x==0) {
              // shouldn&#39;t execute this!
              }
         </code></pre>



<p>The problem is that T2’s local cache has become stale, and so it reads a value that is no longer valid.</p>



<p>The term <em>cache coherency</em> refers to the problem of ensuring that local caches in a multi-core (or, more generally, distributed) system stay in sync.</p>



<p>This problem is solved by a hardware device called a cache controller. The cache controller can detect when values in a cache have been modified on one core, and whether another core has cached the same data. In this case, the cache controller <em>invalidates</em> the stale cache. In the example above, the cache controller would invalidate the cache in T2. When T2 went to read the variable x, it would have to read the data from main memory into the core.</p>



<p>Cache coherency ensures that the behavior is correct, but every time a cache is invalidated and the same memory has to be retrieved from main memory again, it pays the performance penalty of reading from main memory.</p>



<figure><a href="https://lorinhochstein.files.wordpress.com/2022/11/cache-4.jpg"><img data-attachment-id="2830" data-permalink="https://surfingcomplexity.blog/2022/11/25/cache-invalidation-really-is-one-of-the-hardest-things-in-computer-science/cache-4/" data-orig-file="https://lorinhochstein.files.wordpress.com/2022/11/cache-4.jpg" data-orig-size="1192,745" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;1&#34;}" data-image-title="cache-4" data-image-description="" data-image-caption="" data-medium-file="https://lorinhochstein.files.wordpress.com/2022/11/cache-4.jpg?w=300" data-large-file="https://lorinhochstein.files.wordpress.com/2022/11/cache-4.jpg?w=1024" src="https://lorinhochstein.files.wordpress.com/2022/11/cache-4.jpg?w=1024" alt="" srcset="https://lorinhochstein.files.wordpress.com/2022/11/cache-4.jpg?w=1024 1024w, https://lorinhochstein.files.wordpress.com/2022/11/cache-4.jpg?w=150 150w, https://lorinhochstein.files.wordpress.com/2022/11/cache-4.jpg?w=300 300w, https://lorinhochstein.files.wordpress.com/2022/11/cache-4.jpg?w=768 768w, https://lorinhochstein.files.wordpress.com/2022/11/cache-4.jpg 1192w" sizes="(max-width: 1024px) 100vw, 1024px"/></a><figcaption>The diagram above shows that the cache contains both the data as well as the addresses in main memory where the data comes from: we only need to invalidate caches that correspond to the same range of memory</figcaption></figure>



<h2>Data gets brought into cache in chunks</h2>



<p>Let’s say a program needs to read data from main memory. For example, let’s say it needs to read the variable named <em>x</em>. Let’s assume <em>x</em> is implemented as a 32-bit (4 byte) integer.  When the CPU reads from main memory, the memory that holds the variable <em>x</em> will be brought into the cache. </p>



<p>But the CPU won’t just read the variable <em>x</em> into cache. It will read a contiguous chunk of memory that includes the variable <em>x</em> into cache. On x86 systems, the size of this chunk is 64 bytes. This means that accessing the 4 bytes that encodes the variable <em>x</em> actually ends up bringing 64 bytes along for the ride.</p>



<figure><a href="https://lorinhochstein.files.wordpress.com/2022/11/cache-5.jpg"><img data-attachment-id="2832" data-permalink="https://surfingcomplexity.blog/2022/11/25/cache-invalidation-really-is-one-of-the-hardest-things-in-computer-science/cache-5/" data-orig-file="https://lorinhochstein.files.wordpress.com/2022/11/cache-5.jpg" data-orig-size="1192,745" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;1&#34;}" data-image-title="cache-5" data-image-description="" data-image-caption="" data-medium-file="https://lorinhochstein.files.wordpress.com/2022/11/cache-5.jpg?w=300" data-large-file="https://lorinhochstein.files.wordpress.com/2022/11/cache-5.jpg?w=1024" src="https://lorinhochstein.files.wordpress.com/2022/11/cache-5.jpg?w=1024" alt="" srcset="https://lorinhochstein.files.wordpress.com/2022/11/cache-5.jpg?w=1024 1024w, https://lorinhochstein.files.wordpress.com/2022/11/cache-5.jpg?w=150 150w, https://lorinhochstein.files.wordpress.com/2022/11/cache-5.jpg?w=300 300w, https://lorinhochstein.files.wordpress.com/2022/11/cache-5.jpg?w=768 768w, https://lorinhochstein.files.wordpress.com/2022/11/cache-5.jpg 1192w" sizes="(max-width: 1024px) 100vw, 1024px"/></a></figure>



<p>These chunks of memory stored in the cache are referred to as <em>cache lines</em>.</p>



<figure><a href="https://lorinhochstein.files.wordpress.com/2022/11/cache-6.jpg"><img data-attachment-id="2834" data-permalink="https://surfingcomplexity.blog/2022/11/25/cache-invalidation-really-is-one-of-the-hardest-things-in-computer-science/cache-6/" data-orig-file="https://lorinhochstein.files.wordpress.com/2022/11/cache-6.jpg" data-orig-size="1192,745" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;1&#34;}" data-image-title="cache-6" data-image-description="" data-image-caption="" data-medium-file="https://lorinhochstein.files.wordpress.com/2022/11/cache-6.jpg?w=300" data-large-file="https://lorinhochstein.files.wordpress.com/2022/11/cache-6.jpg?w=1024" src="https://lorinhochstein.files.wordpress.com/2022/11/cache-6.jpg?w=1024" alt="" srcset="https://lorinhochstein.files.wordpress.com/2022/11/cache-6.jpg?w=1024 1024w, https://lorinhochstein.files.wordpress.com/2022/11/cache-6.jpg?w=150 150w, https://lorinhochstein.files.wordpress.com/2022/11/cache-6.jpg?w=300 300w, https://lorinhochstein.files.wordpress.com/2022/11/cache-6.jpg?w=768 768w, https://lorinhochstein.files.wordpress.com/2022/11/cache-6.jpg 1192w" sizes="(max-width: 1024px) 100vw, 1024px"/></a></figure>



<h2>False sharing</h2>



<p>We now almost have enough context to explain the failure mode. Here’s a C++ code snippet from the OpenJDK repository (from <a href="https://github.com/openjdk/jdk/blob/40b0ed565720fa75fc23e1a8f26e7cfe5feebf8f/src/hotspot/share/oops/klass.hpp#L138-L141">src/hotspot/share/oops/klass.hpp</a>) </p>



<pre><code>class Klass : public Metadata {
  ...

  // Cache of last observed secondary supertype
  Klass*      _secondary_super_cache;
  // Array of all secondary supertypes
  Array&lt;Klass*&gt;* _secondary_supers;</code></pre>



<p>This declares two pointer variables inside of the Klass class: <em>_secondary_super_cache</em>, and <em>_secondary_supers</em>. Because these two variables are declared one after the other, they will get laid out next to each other in memory.</p>



<figure><a href="https://lorinhochstein.files.wordpress.com/2022/11/cache-7.jpg"><img data-attachment-id="2835" data-permalink="https://surfingcomplexity.blog/2022/11/25/cache-invalidation-really-is-one-of-the-hardest-things-in-computer-science/cache-7/" data-orig-file="https://lorinhochstein.files.wordpress.com/2022/11/cache-7.jpg" data-orig-size="1192,745" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;1&#34;}" data-image-title="cache-7" data-image-description="" data-image-caption="" data-medium-file="https://lorinhochstein.files.wordpress.com/2022/11/cache-7.jpg?w=300" data-large-file="https://lorinhochstein.files.wordpress.com/2022/11/cache-7.jpg?w=1024" src="https://lorinhochstein.files.wordpress.com/2022/11/cache-7.jpg?w=1024" alt="" srcset="https://lorinhochstein.files.wordpress.com/2022/11/cache-7.jpg?w=1024 1024w, https://lorinhochstein.files.wordpress.com/2022/11/cache-7.jpg?w=150 150w, https://lorinhochstein.files.wordpress.com/2022/11/cache-7.jpg?w=300 300w, https://lorinhochstein.files.wordpress.com/2022/11/cache-7.jpg?w=768 768w, https://lorinhochstein.files.wordpress.com/2022/11/cache-7.jpg 1192w" sizes="(max-width: 1024px) 100vw, 1024px"/></a><figcaption>The two variables are adjacent in main memory.</figcaption></figure>



<p>The _secondary_super_cache is, itself, a cache. It’s a very small cache, one that holds a single value. It’s used in a code path for dynamically checking if a particular Java class is a subtype of another class. This code path isn’t commonly used, but it does happen for programs that dynamically create classes at runtime.</p>



<p>Now imagine the following scenario:</p>



<ol>
<li>There are two threads: T1 on CPU 1, T2 on CPU 2</li>



<li>T1 wants to write the  <em>_secondary_super_cache</em> variable and already has the memory associated with the  _secondary_super_cache variable loaded in its L1 cache</li>



<li>T2 wants to read from the <em>_secondary_supers</em> variable and already has the memory associated with the _secondary_supers variable loaded in its L1 cache.</li>
</ol>



<p>When T1 (CPU 1) writes to _secondary_super_cache, if CPU 2 has the same block of memory loaded in its cache, then the cache controller will invalidate that cache line in CPU 2.</p>



<p>But if that cache line contained the _secondary_supers variable, then CPU 2 will have to reload that data from cache to do its read, which is slow.</p>



<figure><a href="https://lorinhochstein.files.wordpress.com/2022/11/cache-8.jpg"><img data-attachment-id="2837" data-permalink="https://surfingcomplexity.blog/2022/11/25/cache-invalidation-really-is-one-of-the-hardest-things-in-computer-science/cache-8/" data-orig-file="https://lorinhochstein.files.wordpress.com/2022/11/cache-8.jpg" data-orig-size="1192,745" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;1&#34;}" data-image-title="cache-8" data-image-description="" data-image-caption="" data-medium-file="https://lorinhochstein.files.wordpress.com/2022/11/cache-8.jpg?w=300" data-large-file="https://lorinhochstein.files.wordpress.com/2022/11/cache-8.jpg?w=1024" src="https://lorinhochstein.files.wordpress.com/2022/11/cache-8.jpg?w=1024" alt="" srcset="https://lorinhochstein.files.wordpress.com/2022/11/cache-8.jpg?w=1024 1024w, https://lorinhochstein.files.wordpress.com/2022/11/cache-8.jpg?w=150 150w, https://lorinhochstein.files.wordpress.com/2022/11/cache-8.jpg?w=300 300w, https://lorinhochstein.files.wordpress.com/2022/11/cache-8.jpg?w=768 768w, https://lorinhochstein.files.wordpress.com/2022/11/cache-8.jpg 1192w" sizes="(max-width: 1024px) 100vw, 1024px"/></a><figcaption>ssc refers to _secondary_super_cache, ss refers to _secondary_supers</figcaption></figure>



<p>This phenomenon, where the cache controller invalidates cached non-stale data that a core needed to access, which just so happens to be on the same cache line as stale data, is called <em>false sharing</em>. </p>



<h2>What’s the probability of false sharing in this scenario?</h2>



<p>In this case, the two variables are both pointers. On this particular CPU architecture, pointers are 64-bits, or 8 bytes. The L1 cache line size is 64 bytes. That means a cache line can store 8 pointers. Or, put another away, a pointer can occupy one of 8 positions in the cache line.</p>



<p>There’s only one scenario where the two variables don’t end up on the same cache line: when <em>_secondary_super_cache </em>occupies position 8, and <em>_secondary_supers</em> occupies position 1. In all of the other scenarios, the two variables will occupy the same cache line, and hence will be vulnerable to false sharing.</p>



<p>1 / 8 = 12.5%, and that’s roughly the number of nodes that were observed in the low band in this scenario.</p>



<figure><a href="https://lorinhochstein.files.wordpress.com/2022/11/cache-9.jpg"><img data-attachment-id="2839" data-permalink="https://surfingcomplexity.blog/2022/11/25/cache-invalidation-really-is-one-of-the-hardest-things-in-computer-science/cache-9/" data-orig-file="https://lorinhochstein.files.wordpress.com/2022/11/cache-9.jpg" data-orig-size="1192,745" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;1&#34;}" data-image-title="cache-9" data-image-description="" data-image-caption="" data-medium-file="https://lorinhochstein.files.wordpress.com/2022/11/cache-9.jpg?w=300" data-large-file="https://lorinhochstein.files.wordpress.com/2022/11/cache-9.jpg?w=1024" src="https://lorinhochstein.files.wordpress.com/2022/11/cache-9.jpg?w=1024" alt="" srcset="https://lorinhochstein.files.wordpress.com/2022/11/cache-9.jpg?w=1024 1024w, https://lorinhochstein.files.wordpress.com/2022/11/cache-9.jpg?w=150 150w, https://lorinhochstein.files.wordpress.com/2022/11/cache-9.jpg?w=300 300w, https://lorinhochstein.files.wordpress.com/2022/11/cache-9.jpg?w=768 768w, https://lorinhochstein.files.wordpress.com/2022/11/cache-9.jpg 1192w" sizes="(max-width: 1024px) 100vw, 1024px"/></a></figure>



<p>And now I recommend you take another look at the <a href="https://netflixtechblog.com/seeing-through-hardware-counters-a-journey-to-threefold-performance-increase-2721924a2822">original blog post</a>, which has a lot more details, including how they solved this problem, as well as a new problem that emerged once they fixed this one.</p>
	</div></div>
  </body>
</html>
