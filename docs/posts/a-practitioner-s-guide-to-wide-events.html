<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jeremymorrell.dev/blog/a-practitioners-guide-to-wide-events/">Original</a>
    <h1>A Practitioner&#39;s Guide to Wide Events</h1>
    
    <div id="readability-page-1" class="page"><article> <p>Adopting Wide Event-style instrumentation has been one of the highest-leverage changes I’ve made
in my engineering career. The feedback loop on all my changes tightened and debugging systems
became so much easier. Systems that were scary to work on suddenly seemed a lot more manageable.</p>
<p>Lately there have been a lot of good blog posts on what “Wide Events” mean and why they are
important. Here are some of my recent favorites:</p>
<ul>
<li><a href="https://isburmistrov.substack.com/p/all-you-need-is-wide-events-not-metrics">All you need is Wide Events, not “Metrics, Logs and Traces”</a> by <a href="https://bsky.app/profile/isburmistrov.bsky.social">Ivan Burmistrov</a></li>
<li><a href="https://boristane.com/blog/observability-wide-events-101/">Observability wide events 101</a> by
<a href="https://twitter.com/boristane">Boris Tane</a></li>
<li><a href="https://charity.wtf/2024/08/07/is-it-time-to-version-observability-signs-point-to-yes/">Is it time to version Observability? (Signs point to yes)</a> by <a href="https://bsky.app/profile/mipsytipsy.bsky.social">Charity Majors</a></li>
</ul>
<p>The tl;dr is that for each unit-of-work in your system (usually, but not always an HTTP request / response)
you emit one “event” with all of the information you can collect about that work. “Event” is an over-loaded
term in telemetry so replace that with “log line” or “span” if you like. <a href="https://jeremymorrell.dev/blog/minimal-js-tracing/">They are all effectively the same
thing</a>.</p>
<p><a href="https://bsky.app/profile/mipsytipsy.bsky.social">Charity Majors</a> has been promoting this approach lately under the
name <a href="https://www.honeycomb.io/blog/one-key-difference-observability1dot0-2dot0">“Observability 2.0”</a>, creating some
new momentum around the concept, however, it is <em>not</em> a new idea. <a href="https://twitter.com/brandur">Brandur Leach</a> wrote
about “Canonical Log Lines” both on <a href="https://brandur.org/canonical-log-lines">his own blog in 2016</a> and
<a href="https://stripe.com/blog/canonical-log-lines">as used by Stripe in 2019</a>. And <a href="https://aws.amazon.com/builders-library/instrumenting-distributed-systems-for-operational-visibility/#Request_log_best_practices">AWS has recommended it as a best-practice for ages</a>.</p>
<h2 id="okay-i-think-i-get-the-idea-but-how-do-i-do-wide-events">Okay… I think I get the idea… but how do I do “wide events”?</h2>
<p>This is where I find a lot of developers get tripped up. The idea sounds good in theory,
and we should totally try that one day! But I have this stack of features to ship, that
bug that’s been keeping me up at night, and 30 new AI tools that came out
yesterday to learn about. And like… where do you even start? What data should I add?</p>
<p>Like anything in software, there are a lot of options for how to approach this, but I’ll talk
through one approach that has worked for me.</p>
<p>We’ll cover how to approach this in tooling and code, an <strong>extensive</strong> list of attributes to add,
and I’ll respond to some frequent objections that come up when discussing this approach.</p>
<p>For this post we’ll focus on web services, but you would apply a similar approach to any workload.</p>

<p>We will need some way to instrument your code (traces or structured log lines) and somewhere to
send the instrumentation to in order to query and visualize it.</p>
<p>This approach is best paired with a tool that lets you query your data in quick iterations.
I like <a href="https://www.honeycomb.io/">Honeycomb</a> for this, but any Observability tool backed by
a modern OLAP database is likely going to work in a pinch.</p>
<ul>
<li><a href="https://www.honeycomb.io/">Honeycomb</a> has <a href="https://www.honeycomb.io/resources/why-we-built-our-own-distributed-column-store">Retriever</a></li>
<li><a href="https://www.datadoghq.com/">DataDog</a> has <a href="https://www.datadoghq.com/blog/engineering/introducing-husky/">Husky</a></li>
<li><a href="https://newrelic.com/">New Relic</a> has <a href="https://docs.newrelic.com/docs/data-apis/get-started/nrdb-horsepower-under-hood/">NRDB</a></li>
<li><a href="https://baselime.io/">Baselime</a> uses <a href="https://boristane.com/talks/observability-with-clickhouse/">ClickHouse</a></li>
<li><a href="https://signoz.io/">SigNoz</a> uses <a href="https://clickhouse.com/blog/signoz-observability-solution-with-clickhouse-and-open-telemetry">ClickHouse</a></li>
</ul>
<p>Honeycomb, New Relic, and DataDog built their own columnar <a href="https://aws.amazon.com/compare/the-difference-between-olap-and-oltp/">OLAP</a> data stores,
though now with the availability of <a href="https://clickhouse.com/">ClickHouse</a>, <a href="https://www.influxdata.com/blog/influxdb-engine/">InfluxDB IOx</a>,
<a href="https://pinot.apache.org/">Apache Pinot</a>, and <a href="https://duckdb.org/">DuckDB</a> there are new Observability tools popping up all the time.</p>
<p>If you aren’t constrained, I <strong>highly recommend</strong> defaulting to using <a href="https://opentelemetry.io/">OpenTelemetry</a>
and <a href="https://www.honeycomb.io/">Honeycomb</a>. Your life will be easier.</p>
<p>However even if you are stuck in a corporate environment with a strong allergy to technology built after 2010 you
can leverage log search tools like ElasticSearch in a pinch. <a href="https://stripe.com/blog/canonical-log-lines">Stripe</a>’s
blog post goes over how to use Splunk for this.</p>
<p>In any tool you want to focus on getting proficient at 3 core techniques in order to sift through your events.
The faster you are able to apply these, iterate, and ask questions of your data, the better you’ll be able to
debug issues and see what your system is really doing. When observability folks refer to “slicing and dicing”
data, this is what they are generally referring to. I’ll represent queries using a made-up SQL dialect, but
you should be able to find equivalents in your tool’s query language.</p>
<h4 id="visualizing">Visualizing</h4>
<p>Existing in a human body comes with its fair share of downsides, but the human visual cortex is really, really
good at recognizing patterns. Give it a fighting chance by getting really good at summoning visualizations
of the data your system is emitting. <code>COUNT</code>, <code>COUNT_DISTINCT</code>, <code>HEATMAP</code>, <code>P90</code>, <code>MAX</code>, <code>MIN</code>, Histogram.
Learn to leverage whatever graphs your tool makes available to you. Practice it. Get fast.</p>
<p><img src="https://jeremymorrell.dev/_astro/heatmaps.BtFRY6ZF_1tdCcj.webp" alt="A Honeycomb screenshot of heatmap" width="801" height="250" loading="lazy" decoding="async"/></p>
<p><img src="https://jeremymorrell.dev/_astro/splunk-histogram.DyaarE-V_2iOt7R.webp" alt="A Splunk screenshot of histogram" width="3546" height="990" loading="lazy" decoding="async"/></p>
<h4 id="grouping">Grouping</h4>
<p>With each new annotation that we add to our wide events, we create another dimension along which we can
slice our data. <code>GROUP BY</code> allows us to look along that dimension and see if the values along that
dimension match our expectations.</p>
<pre tabindex="0" data-language="sql"><code><span><span>GROUP BY</span><span> instance</span><span>.</span><span>id</span></span>
<span></span></code></pre>
<pre tabindex="0" data-language="sql"><code><span><span>GROUP BY</span><span> client</span><span>.</span><span>OS</span><span>, </span><span>client</span><span>.</span><span>version</span></span>
<span></span></code></pre>
<h4 id="filtering">Filtering</h4>
<p>Once we’ve narrowed in one dimension that is interesting, we usually want to dig further into
that data. Filtering down so that we’re only looking at data from one endpoint, or from one IP address,
or sent by the iOS app, or only from users with a specific feature flag turned on allows us to narrow our
focus to a very specific segment of traffic.</p>
<pre tabindex="0" data-language="sql"><code><span><span>WHERE</span><span> http</span><span>.</span><span>route</span><span> =</span><span> &#34;/user/account&#34;</span></span>
<span></span></code></pre>
<pre tabindex="0" data-language="sql"><code><span><span>WHERE</span><span> http</span><span>.</span><span>route</span><span> !=</span><span> &#34;/health&#34;</span></span>
<span></span></code></pre>
<pre tabindex="0" data-language="sql"><code><span><span>WHERE</span><span> http</span><span>.</span><span>user_agent_header</span><span> contains </span><span>&#34;Android&#34;</span></span>
<span></span></code></pre>
<h2 id="write-a-middleware-to-help-you">Write a middleware to help you</h2>
<p>If you are using an OpenTelemetry SDK it is already creating a wrapping span around the request and
response. You can access it by asking for the active span at any point during the processing of
the request.</p>
<pre tabindex="0" data-language="js"><code><span><span>let</span><span> span </span><span>=</span><span> opentelemetry.trace.</span><span>getActiveSpan</span><span>();</span></span>
<span><span>span.</span><span>setAttributes</span><span>({</span></span>
<span><span>  &#34;user_agent.original&#34;</span><span>: c.req.</span><span>header</span><span>(</span><span>&#34;User-Agent&#34;</span><span>),</span></span>
<span><span>});</span></span>
<span></span></code></pre>
<p>However if anyone wraps any of your code in a child span the “active span” will change to be that
new wrapping span! There is no first-class way of addressing this original “main” span in OpenTelemetry.
However, we can work around this by saving a reference to this specific span in the <a href="https://opentelemetry.io/docs/specs/otel/context/">context</a>
so we can always have access to the “main” wrapping span.</p>
<pre tabindex="0" data-language="js"><code><span><span>// create a reference to store the span on the opentelemetry context object</span></span>
<span><span>const</span><span> MAIN_SPAN_CONTEXT_KEY</span><span> =</span><span> createContextKey</span><span>(</span><span>&#34;main_span_context_key&#34;</span><span>);</span></span>
<span></span>
<span><span>function</span><span> mainSpanMiddleware</span><span>(</span><span>req</span><span>, </span><span>res</span><span>, </span><span>next</span><span>) {</span></span>
<span><span>  // pull the active span created by the http instrumentation</span></span>
<span><span>  let</span><span> span </span><span>=</span><span> trace.</span><span>getActiveSpan</span><span>();</span></span>
<span></span>
<span><span>  // get the current context</span></span>
<span><span>  let</span><span> ctx </span><span>=</span><span> context.</span><span>active</span><span>();</span></span>
<span></span>
<span><span>  // set any attributes we always want on the main span</span></span>
<span><span>  span.</span><span>setAttribute</span><span>(</span><span>&#34;main&#34;</span><span>, </span><span>true</span><span>);</span></span>
<span></span>
<span><span>  // OpenTelemetry context is immutable, so to modify it we create</span></span>
<span><span>  // a new version with our span added</span></span>
<span><span>  let</span><span> newCtx </span><span>=</span><span> ctx.</span><span>setValue</span><span>(</span><span>MAIN_SPAN_CONTEXT_KEY</span><span>, span);</span></span>
<span></span>
<span><span>  // set that new context as active for the duration of the request</span></span>
<span><span>  context.</span><span>with</span><span>(newCtx, () </span><span>=&gt;</span><span> {</span></span>
<span><span>    next</span><span>();</span></span>
<span><span>  });</span></span>
<span><span>}</span></span>
<span></span>
<span><span>// create another function that allows you to annotate this saved span easily</span></span>
<span><span>function</span><span> setMainSpanAttributes</span><span>(</span><span>attributes</span><span>) {</span></span>
<span><span>  let</span><span> mainSpan </span><span>=</span><span> context.</span><span>active</span><span>().</span><span>getValue</span><span>(</span><span>MAIN_SPAN_CONTEXT_KEY</span><span>);</span></span>
<span><span>  if</span><span> (mainSpan) {</span></span>
<span><span>    mainSpan.</span><span>setAttributes</span><span>(attributes);</span></span>
<span><span>  }</span></span>
<span><span>}</span></span>
<span></span></code></pre>
<p>Now our annotation code can look a little simpler, and we can always know that we’re setting these
attributes on the wrapping span.</p>
<pre tabindex="0" data-language="js"><code><span><span>setMainSpanAttributes</span><span>({</span></span>
<span><span>  &#34;user.id&#34;</span><span>: </span><span>&#34;123&#34;</span><span>,</span></span>
<span><span>  &#34;user.type&#34;</span><span>: </span><span>&#34;enterprise&#34;</span><span>,</span></span>
<span><span>  &#34;user.auth_method&#34;</span><span>: </span><span>&#34;oauth&#34;</span><span>,</span></span>
<span><span>});</span></span>
<span></span></code></pre>
<p>You can play around with a minimal running example <a href="https://github.com/jmorrell/a-practitioners-guide-to-wide-events/tree/main/opentelemetry-js-example">here</a>.</p>
<p>At Heroku we had internal <a href="https://opentelemetry.io/docs/concepts/distributions/">OpenTelemetry Distributions</a>
that set this up for you automatically and added as many automatic annotations as possible to these spans.</p>
<p>If you are not using OpenTelemetry
<a href="https://gist.github.com/jmorrell/76a9ee631370e073d6e2616dc1f67feb">here’s a gist that might help you get started</a>.
<a href="https://jeremymorrell.dev/blog/minimal-js-tracing/">My previous post</a> may help you put this logic together.</p>
<h2 id="what-do-i-add-to-this-main-span">What do I add to this “main” span?</h2>
<blockquote data-conversation="none" data-dnt="true" data-theme="light"><p lang="en" dir="ltr">And how many dimensions do you plan to emit and pack into your wide events?</p>— Charity Majors (@mipsytipsy) <a href="https://twitter.com/mipsytipsy/status/1744579558962336138">January 9, 2024</a></blockquote> 
<p>We need to add attributes about the request, and there are likely far more of these than you would expect.
It’s easy to come up with a dozen or so, but in a well-instrumented code base there will be hundreds of attributes.</p>
<p>Note that while this is a long list, it is definitely not exhaustive. OpenTelemetry defines sets of attribute names as
<a href="https://opentelemetry.io/docs/specs/semconv/">Semantic Conventions</a> that can also be used for inspiration. I have tried
to follow these in my naming where possible.</p>
<h3 id="a-convention-to-filter-out-everything-else">A convention to filter out everything else</h3>
<p>Traces contain lots of spans, so it’s helpful to have a convention for identifying and searching for these “wide events”.
<code>root</code> and <code>canon</code> were floated as options, but I’ve landed on calling them <code>main</code> spans.</p>















<table><thead><tr><th>Attribute</th><th>Examples</th><th>Description</th></tr></thead><tbody><tr><td><code>main</code></td><td><code>true</code></td><td>Present only for spans designated as a “wide event”, usually wrapping a request / response, or a background job</td></tr></tbody></table>
<p>This convention allows you to quickly figure out “what does the traffic to this service look like?” with a single query:</p>
<pre tabindex="0" data-language="sql"><code><span><span>SELECT</span></span>
<span><span>  COUNT</span><span>(</span><span>*</span><span>)</span></span>
<span><span>WHERE</span></span>
<span><span>  main </span><span>=</span><span> true</span></span>
<span><span>GROUP BY</span><span> http</span><span>.</span><span>route</span></span>
<span></span></code></pre>
<p><img src="https://jeremymorrell.dev/_astro/traffic-by-route.Bvy3b1dc_Z19Vwcg.webp" alt="Graph of traffic grouped by route over a week. There is an anomally." width="1227" height="691" loading="lazy" decoding="async"/></p>
<h3 id="service-metadata">Service metadata</h3>
<p>Of course we need to add some information about the service we’re running. Consider adding additional metadata about
which team owns the system, or which Slack channel the owning team hangs out in, though note that this can be
tedious to update if your workplace experiences frequent re-orgs. Tying these to a service catalog like <a href="https://backstage.io/">Backstage</a>
is left as an exercise to the reader.</p>






























<table><thead><tr><th>Attribute</th><th>Examples</th><th>Description</th></tr></thead><tbody><tr><td><code>service.name</code></td><td><code>api</code> </td><td>What is the name of this service?</td></tr><tr><td><code>service.environment</code></td><td><code>production</code> </td><td>Where is this service running?</td></tr><tr><td><code>service.team</code></td><td><code>web-services</code> </td><td>Which team owns this service. Useful for knowing who to page in during incidents.</td></tr><tr><td><code>service.slack_channel</code></td><td><code>web-services</code> </td><td>If I discover an issue with this service, where should I reach out?</td></tr></tbody></table>
<blockquote>
<p>How many services does each team run?</p>
</blockquote>
<pre tabindex="0" data-language="sql"><code><span><span>SELECT</span></span>
<span><span>  COUNT_DISTINCT(</span><span>service</span><span>.</span><span>name</span><span>)</span></span>
<span><span>WHERE</span></span>
<span><span>  service</span><span>.</span><span>environment</span><span> =</span><span> &#34;production&#34;</span></span>
<span><span>GROUP BY</span><span> service</span><span>.</span><span>team</span></span>
<span></span></code></pre>
<p>Ever look at the load on a system and then wonder “Is that appropriate for the machine this is running on?”, and
now you have to look through other tools or config files to get that information. Throw that context on the wide
event so that it’s available when you need it.</p>






























<table><thead><tr><th>Attribute</th><th>Examples</th><th>Description</th></tr></thead><tbody><tr><td><code>instance.id</code></td><td><code>656993bd-40e1-4c76-baff-0e50e158c6eb</code></td><td>An ID that maps to this one instance of the service</td></tr><tr><td><code>instance.memory_mb</code></td><td><code>12336</code></td><td>How much RAM is available to this service?</td></tr><tr><td><code>instance.cpu_count</code></td><td><code>4</code> </td><td>How many cores are available to this service?</td></tr><tr><td><code>instance.type</code></td><td><code>m6i.xlarge</code></td><td>Does your vendor have a name for this type of instance?</td></tr></tbody></table>
<blockquote>
<p>What are the services with the most memory that we run? What instance types do they use?</p>
</blockquote>
<pre tabindex="0" data-language="sql"><code><span><span>SELECT</span></span>
<span><span>  service</span><span>.</span><span>name</span><span>,</span></span>
<span><span>  instance</span><span>.</span><span>memory_mb</span><span>,</span></span>
<span><span>  instance</span><span>.</span><span>type</span></span>
<span><span>ORDER BY</span><span> instance</span><span>.</span><span>memory_mb</span><span> DESC</span></span>
<span><span>GROUP BY</span><span> service</span><span>.</span><span>name</span><span>, </span><span>instance</span><span>.</span><span>type</span></span>
<span><span>LIMIT</span><span> 10</span></span>
<span></span></code></pre>
<p>However you’re orchestrating your systems make sure that all of the relevant information is added. I’ve included some
examples from <a href="https://opentelemetry.io/docs/specs/semconv/resource/k8s/">the Kubernetes semantic conventions</a> for inspiration.</p>








































<table><thead><tr><th>Attribute</th><th>Examples</th><th>Description</th></tr></thead><tbody><tr><td><code>container.id</code></td><td><code>a3bf90e006b2</code></td><td>An ID used to identify Docker containers</td></tr><tr><td><code>container.name</code></td><td><code>nginx-proxy</code> </td><td>Container name used by container runtime</td></tr><tr><td><code>k8s.cluster.name</code></td><td><code>api-cluster</code></td><td>Name of the kubernetes cluster your service is running in</td></tr><tr><td><code>k8s.pod.name</code></td><td><code>nginx-2723453542-065rx</code></td><td>Name of the kubernetes pod your service is running in</td></tr><tr><td><code>cloud.availability_zone</code></td><td><code>us-east-1c</code></td><td>AZ where you’re running your service</td></tr><tr><td><code>cloud.region</code></td><td><code>us-east-1</code></td><td>Region where you’re running your service</td></tr></tbody></table>
<p>But even if you’re using a Platform-as-a-Service you can still pull out a lot of useful information!</p>








































<table><thead><tr><th>Attribute</th><th>Examples</th><th>Description</th></tr></thead><tbody><tr><td><code>heroku.dyno</code></td><td><code>web.1</code> </td><td>The env var <code>DYNO</code> that is set on your app at runtime</td></tr><tr><td><code>heroku.dyno_type</code></td><td><code>web</code> </td><td>The first part of the <code>DYNO</code> env var before the <code>.</code>. Separating this makes it easier to query</td></tr><tr><td><code>heroku.dyno_index</code></td><td><code>1</code> </td><td>The second part of the <code>DYNO</code> env var after the <code>.</code>. Separating this makes it easier to query</td></tr><tr><td><code>heroku.dyno_size</code></td><td><code>performance-m</code></td><td>The selected dyno size</td></tr><tr><td><code>heroku.space</code></td><td><code>my-private-space</code></td><td>The name of the private space that your are deployed into</td></tr><tr><td><code>heroku.region</code></td><td><code>virginia</code> </td><td>Which region is this app located in?</td></tr></tbody></table>
<blockquote>
<p>How many dynos are we running? What dyno types are they? For which services?</p>
</blockquote>
<pre tabindex="0" data-language="sql"><code><span><span>SELECT</span></span>
<span><span>  COUNT_DISTINCT(</span><span>heroku</span><span>.</span><span>dyno_index</span><span>)</span></span>
<span><span>GROUP BY</span><span> service</span><span>.</span><span>name</span><span>, </span><span>heroku</span><span>.</span><span>dyno_type</span><span>, </span><span>instance</span><span>.</span><span>type</span></span>
<span></span></code></pre>
<h3 id="build-info">Build info</h3>
<p>Inevitably some of the first questions asked in any incident are “Did something just go out?” or “What changed?“.
Instead of jumping to your deployment tool or looking through GitHub repositories, add that data to your telemetry.</p>
<p>Threading this data from your build system through to your production system so that it’s available at runtime can
be a non-trivial amount of glue code, but having this information easily available during incidents is invaluable.</p>























































<table><thead><tr><th>Attribute</th><th>Examples</th><th>Description</th></tr></thead><tbody><tr><td><code>service.version</code></td><td><code>v123</code> </td><td>However you track your version, ex: a version string or a hash of the built image</td></tr><tr><td><code>service.build.id</code></td><td><code>acd8bb57-fb9f-4b2d-a750-4315e99dac64</code></td><td>If your build system gives you an ID, this context allows you to audit the build if something goes wrong</td></tr><tr><td><code>service.build.git_hash</code></td><td><code>6f6466b0e693470729b669f3745358df29f97e8d</code></td><td>The git SHA of the deployed commit so you can know exactly which code was running</td></tr><tr><td><code>service.build.pull_request_url</code></td><td><code>https://github.com/your-company/api-service/pull/121</code></td><td>The url of the pull request that was merged that triggered the deploy</td></tr><tr><td><code>service.build.diff_url</code></td><td><code>https://github.com/your-company/api-service/compare/c9d9380..05e5736</code></td><td>A url that compares the previously deployed commit against the newly deployed commit</td></tr><tr><td><code>service.build.deployment.at</code></td><td><code>2024-10-14T19:47:38Z</code></td><td>Timestamp when the deployment process started</td></tr><tr><td><code>service.build.deployment.user</code></td><td><code><a href="https://jeremymorrell.dev/cdn-cgi/l/email-protection" data-cfemail="d3b8b6b2bda6fda1b6b6a5b6a093aabca6a1feb0bcbea3b2bdaafdb0bcbe">[email protected]</a></code></td><td>Which authenticated user kicked off the build? Could be a bot</td></tr><tr><td><code>service.build.deployment.trigger</code></td><td><code>merge-to-main</code> </td><td>What triggered the deploy? Extremely valuable context during an deploy-triggered incident</td></tr><tr><td><code>service.build.deployment.age_minutes</code></td><td><code>1</code> </td><td>How old is this deploy? Shortcuts the frequent incident question “Did something just go out?”</td></tr></tbody></table>
<p><strong>Won’t this be a lot of repetitive data?</strong> These values do not change except between deploys! See <a href="#frequent-objections">Frequent Objections</a></p>
<blockquote>
<p>What systems have recently been deployed?</p>
</blockquote>
<pre tabindex="0" data-language="sql"><code><span><span>SELECT</span></span>
<span><span>  service</span><span>.</span><span>name</span><span>,</span></span>
<span><span>  MIN</span><span>(</span><span>service</span><span>.</span><span>build</span><span>.</span><span>deployment</span><span>.</span><span>age_minutes</span><span>) </span><span>as</span><span> age</span></span>
<span><span>WHERE</span></span>
<span><span>  service</span><span>.</span><span>build</span><span>.</span><span>deployment</span><span>.</span><span>age_minutes</span><span> &lt;</span><span> 20</span></span>
<span><span>GROUP BY</span><span> service</span><span>.</span><span>name</span></span>
<span><span>ORDER BY</span><span> age </span><span>ASC</span></span>
<span><span>LIMIT</span><span> 10</span></span>
<span></span></code></pre>
<blockquote>
<p>What’s up with the spike of 500s when we did the last deploy?</p>
</blockquote>
<pre tabindex="0" data-language="sql"><code><span><span>SELECT</span></span>
<span><span>  COUNT</span><span>(</span><span>*</span><span>)</span></span>
<span><span>WHERE</span></span>
<span><span>  service</span><span>.</span><span>name</span><span> =</span><span> &#34;api-service&#34;</span><span> AND</span></span>
<span><span>  main </span><span>=</span><span> true</span></span>
<span><span>GROUP BY</span><span> http</span><span>.</span><span>status_code</span><span>, </span><span>service</span><span>.</span><span>version</span></span>
<span></span></code></pre>
<p><img src="https://jeremymorrell.dev/_astro/group-by-http-and-status.tDSRPVAz_WRwGN.webp" alt="Graph showing requests grouped by http status code and version. There is a spike of 500s correlating to v1 shutting down." width="1616" height="926" loading="lazy" decoding="async"/></p>
<h3 id="http">HTTP</h3>
<p>You should get most of these from your tracing library instrumentation, but there are usually more you can add if, for example,
your organization uses non-standard headers. Don’t settle for only what OpenTelemetry gives you by default!</p>

































































<table><thead><tr><th>Attribute</th><th>Examples</th><th>Description</th></tr></thead><tbody><tr><td><code>server.address</code></td><td><code>example.com</code> </td><td>Name of the HTTP server that received the request</td></tr><tr><td><code>url.path</code></td><td><code>/checkout</code> </td><td>URI path after the domain</td></tr><tr><td><code>url.scheme</code></td><td><code>http</code>, <code>https</code></td><td>URI scheme</td></tr><tr><td><code>url.query</code></td><td><code>q=test</code>, <code>ref=####</code></td><td>URI query component</td></tr><tr><td><code>http.request.id</code></td><td><code>79104EXAMPLEB723</code></td><td>Platform request id: ex: <code>x-request-id</code>, <code>x-amz-request-id</code></td></tr><tr><td><code>http.request.method</code></td><td><code>GET</code> </td><td>HTTP request method</td></tr><tr><td><code>http.request.body_size</code></td><td><code>3495</code></td><td>Size of the request payload body in bytes</td></tr><tr><td><code>http.request.header.content-type</code></td><td><code>application/json</code></td><td>Value of a specific request header, “content-type” in this case, but there are many more. Pick out any that are important for your service</td></tr><tr><td><code>http.response.status_code</code></td><td><code>200</code> </td><td>HTTP response status code</td></tr><tr><td><code>http.response.body_size</code></td><td><code>1284</code> </td><td>Size of the response payload body in bytes</td></tr><tr><td><code>http.request.header.content-type</code></td><td><code>text/html</code></td><td>Value of a specific response header, “content-type” in this case, but there are many more. Pick out any that are important for your service</td></tr></tbody></table>
<pre tabindex="0" data-language="sql"><code><span><span>SELECT</span></span>
<span><span>  HEATMAP(</span><span>http</span><span>.</span><span>response</span><span>.body_size),</span></span>
<span><span>WHERE</span></span>
<span><span>  main </span><span>=</span><span> true </span><span>AND</span></span>
<span><span>  service</span><span>.</span><span>name</span><span> =</span><span> &#34;api-service&#34;</span></span>
<span></span></code></pre>
<p><img src="https://jeremymorrell.dev/_astro/http-body-size-annotated.BXCOh_iU_Z2smyDz.webp" alt="A heatmap of response sizes. Most are within a fixed band, but there are sharp outliers that warrant more investigation." width="1769" height="1027" loading="lazy" decoding="async"/></p>
<p><code>User-Agent</code> headers contain a wealth of info. Don’t rely on regex queries to try and make sense of them down the road. Parse them
into structured data from the beginning.</p>



































<table><thead><tr><th>Attribute</th><th>Examples</th><th>Description</th></tr></thead><tbody><tr><td><code>user_agent.original</code></td><td><code>Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/129.0.0.0 Safari/537.3</code></td><td>The value of the HTTP <code>User-Agent</code> header</td></tr><tr><td><code>user_agent.device</code></td><td><code>computer</code> </td><td>Device type derived from the <code>User-Agent</code> header</td></tr><tr><td><code>user_agent.OS</code></td><td><code>Windows</code> </td><td>OS derived from the <code>User-Agent</code> header</td></tr><tr><td><code>user_agent.browser</code></td><td><code>Chrome</code> </td><td>Browser derived from the <code>User-Agent</code> header</td></tr><tr><td><code>user_agent.browser_version</code></td><td><code>129</code> </td><td>Browser version derived from the <code>User-Agent</code> header</td></tr></tbody></table>
<blockquote>
<p>What browsers are my users using?</p>
</blockquote>
<pre tabindex="0" data-language="sql"><code><span><span>SELECT</span></span>
<span><span>  COUNT</span><span>(</span><span>*</span><span>)</span></span>
<span><span>GROUP BY</span><span> user_agent</span><span>.</span><span>browser</span><span>, </span><span>user_agent</span><span>.</span><span>browser_version</span></span>
<span></span></code></pre>
<p>If you have any custom user agents or headers used as a convention within your org parse that out too.</p>






























<table><thead><tr><th>Attribute</th><th>Examples</th><th>Description</th></tr></thead><tbody><tr><td><code>user_agent.service</code></td><td><code>api-gateway</code> </td><td>If you have a distributed architecture, have each service send a custom <code>User-Agent</code> header with its name and version</td></tr><tr><td><code>user_agent.service_version</code></td><td><code>v123</code> </td><td>If you have a distributed architecture, have each service send a custom <code>User-Agent</code> header with its name and version</td></tr><tr><td><code>user_agent.app</code></td><td><code>iOS</code> </td><td>If a request is coming from a mobile app, make sure it includes which app and its version</td></tr><tr><td><code>user_agent.app_version</code></td><td><code>v123</code> </td><td>If a request is coming from a mobile app, make sure it includes which app and its version</td></tr></tbody></table>
<h3 id="route-info">Route info</h3>
<p>We’re not done with HTTP attributes yet! One of the most important bits is the API endpoint
that the request matched. OpenTelemetry SDKs will <em>usually</em> give this to you automagically
but not always. Consider extracting the route parameters and query parameters as additional attributes.</p>

























<table><thead><tr><th>Attribute</th><th>Examples</th><th>Description</th></tr></thead><tbody><tr><td><code>http.route</code></td><td><code>/team/{team_id}/user/{user_id}</code></td><td>The route pattern that the url path is matched against</td></tr><tr><td><code>http.route.param.team_id</code></td><td><code>14739</code> </td><td>The extracted segment of the url path as it is parsed for each parameter</td></tr><tr><td><code>http.route.query.sort_dir</code></td><td><code>asc</code></td><td>The query parameters that are relevant to the response of your service. Ex: <code>?sort_dir=asc&amp;...</code></td></tr></tbody></table>
<pre tabindex="0" data-language="sql"><code><span><span>SELECT</span></span>
<span><span>  P99(duration_ms)</span></span>
<span><span>WHERE</span></span>
<span><span>  main </span><span>=</span><span> true </span><span>AND</span></span>
<span><span>  service</span><span>.</span><span>name</span><span> =</span><span> &#34;api-service&#34;</span></span>
<span><span>GROUP BY</span><span> http</span><span>.</span><span>route</span></span>
<span></span></code></pre>
<p><img src="https://jeremymorrell.dev/_astro/p99-duration-annotated.BXlgufk3_2gG79r.webp" alt="A chart of p99&amp;#x27;s broken down by route. There is a spike on only some of them. We should break down by version now to check if this was caused by a deploy." width="1769" height="1012" loading="lazy" decoding="async"/></p>
<h3 id="user-and-customer-info">User and customer info</h3>
<p>Once you get the basics down, this is <strong>the most important</strong> piece of metadata that you can add. No automagic SDK
will be able to encode the particulars of your user model.</p>
<p>It’s common for a single user or account to be responsible for a 10%+ of a business’ revenue, and frequently their
usage patterns look significantly different than the average user. They probably have more users, store more data,
and hit limits and edge-cases that will never show up for the user paying $10 / month. Be sure you can separate
their traffic from others.</p>


















































<table><thead><tr><th>Attribute</th><th>Examples</th><th>Description</th></tr></thead><tbody><tr><td><code>user.id</code></td><td><code>2147483647</code> </td><td>The primary ID for a user. If this is an email and you’re using a vendor, consider your org’s policy on putting PII in external services.</td></tr><tr><td><code>user.type</code></td><td><code>free</code> </td><td>How does the business see this type of user? Individual accounts are sometimes responsible for 10%+ of a business’ income. Make sure you can separate their traffic from others!</td></tr><tr><td><code>user.auth_method</code></td><td><code>token</code> </td><td>How did this user authenticate into your system?</td></tr><tr><td><code>user.team.id</code></td><td><code>5387</code> </td><td>If you have a team construct, which one does this user belong to?</td></tr><tr><td><code>user.org.id</code></td><td><code>278</code> </td><td>If this user is part of an organization with an enterprise contract, track that!</td></tr><tr><td><code>user.age_days</code></td><td><code>0</code> </td><td>Not the user’s literal age, but how long ago was this account created? Is this an issue experienced by someone new to your app, or only once they’ve saved a lot of data?</td></tr><tr><td><code>user.assumed</code></td><td><code>true</code></td><td>Have an internal way of assuming a user’s identity for debugging? Be sure to track this</td></tr><tr><td><code>user.assumed_by</code></td><td><code><a href="https://jeremymorrell.dev/cdn-cgi/l/email-protection" data-cfemail="35505b525c5b5050471806754c5a404718565a5845545b4c1b565a58">[email protected]</a></code></td><td>And track which actual user is assuming the user’s identity</td></tr></tbody></table>
<pre tabindex="0" data-language="sql"><code><span><span>SELECT</span></span>
<span><span>  P99(duration_ms)</span></span>
<span><span>WHERE</span></span>
<span><span>  main </span><span>=</span><span> true </span><span>AND</span></span>
<span><span>  service</span><span>.</span><span>name</span><span> =</span><span> &#34;api-service&#34;</span></span>
<span><span>GROUP BY</span><span> user</span><span>.</span><span>type</span></span>
<span></span></code></pre>
<h3 id="rate-limits">Rate limits</h3>
<p>Whatever your rate limiting strategy, make sure the current rate limit info gets added too. Can you quickly find
examples of users that are being rate-limited by your service?</p>






























<table><thead><tr><th>Attribute</th><th>Examples</th><th>Description</th></tr></thead><tbody><tr><td><code>ratelimit.limit</code></td><td><code>200000</code></td><td>You might not now, but you will likely have users with different rate limits in the future, note down what the actual limit is for this request</td></tr><tr><td><code>ratelimit.remaining</code></td><td><code>130000</code></td><td>What is the budget remaining for this user?</td></tr><tr><td><code>ratelimit.used</code></td><td><code>70000</code></td><td>How many requests have been used in the current rate window</td></tr><tr><td><code>ratelimit.reset_at</code></td><td><code>2024-10-14T19:47:38Z</code></td><td>When will the rate limit be reset next? if applicable</td></tr></tbody></table>
<blockquote>
<p>This user has a support ticket open about being rate-limited. Let’s see what they were doing</p>
</blockquote>
<pre tabindex="0" data-language="sql"><code><span><span>SELECT</span></span>
<span><span>  COUNT</span><span>(</span><span>*</span><span>)</span></span>
<span><span>WHERE</span></span>
<span><span>  main </span><span>=</span><span> true </span><span>AND</span></span>
<span><span>  service</span><span>.</span><span>name</span><span> =</span><span> &#34;api-service&#34;</span><span> AND</span></span>
<span><span>  user</span><span>.</span><span>id</span><span> =</span><span> 5838</span></span>
<span><span>GROUP BY</span><span> http</span><span>.</span><span>route</span></span>
<span></span></code></pre>
<p><img src="https://jeremymorrell.dev/_astro/rate-limit-investigation-annotated.DGJPVuPW_Z2hIjxj.webp" alt="A graph of one users activity. There is a big spike hitting the same route a lot at the end. This gives us a starting point for investigation" width="1769" height="1012" loading="lazy" decoding="async"/></p>
<blockquote>
<p>What routes are users who have burned most of their rate limit hitting? Does this activity look suspicious?</p>
</blockquote>
<pre tabindex="0" data-language="sql"><code><span><span>SELECT</span></span>
<span><span>  COUNT</span><span>(</span><span>*</span><span>)</span></span>
<span><span>WHERE</span></span>
<span><span>  main </span><span>=</span><span> true </span><span>AND</span></span>
<span><span>  service</span><span>.</span><span>name</span><span> =</span><span> &#34;api-service&#34;</span><span> AND</span></span>
<span><span>  ratelimit</span><span>.</span><span>remaining</span><span> &lt;</span><span> 100</span></span>
<span><span>GROUP BY</span><span> http</span><span>.</span><span>route</span></span>
<span></span></code></pre>
<h3 id="caching">Caching</h3>
<p>For every code path where we could shortcut with a cache response, add whether or not it was successful</p>




















<table><thead><tr><th>Attribute</th><th>Examples</th><th>Description</th></tr></thead><tbody><tr><td><code>cache.session_info</code></td><td><code>true</code> </td><td>Was the session info cached or did it need to be re-fetched?</td></tr><tr><td><code>cache.feature_flags</code></td><td><code>true</code> </td><td>Were the feature flags cached for this user or did they need to be re-fetched?</td></tr></tbody></table>
<h3 id="localization-info">Localization info</h3>
<p>What localization options has the user chosen? This can be a frequent source of bugs</p>

























<table><thead><tr><th>Attribute</th><th>Examples</th><th>Description</th></tr></thead><tbody><tr><td><code>localization.language_dir</code></td><td><code>rtl</code>, <code>ltr</code></td><td>Which direction is text laid out in their language?</td></tr><tr><td><code>localization.country</code></td><td><code>mexico</code>, <code>uk</code></td><td>Which country are they from?</td></tr><tr><td><code>localization.currency</code></td><td><code>USD</code>, <code>CAD</code></td><td>Which currency have they chosen to work with?</td></tr></tbody></table>
<h3 id="uptime">Uptime</h3>
<p>Tracking how long the service has been running when it serves a request can help you visualize several classes of bugs:</p>
<ul>
<li>Issues that show up on a reboot</li>
<li>Memory leaks that only start to show up when the service has been running for a long time</li>
<li>Frequent crashes / restarts if you have automatically restart the service on failure</li>
</ul>
<p>I recommend also either adding the <code>log10</code> of the uptime or having some way of visualizing this. When graphed this emphasizes
the important first few minutes of a service without being squished into the bottom of the graph by instances with several days
or more of uptime.</p>




















<table><thead><tr><th>Attribute</th><th>Examples</th><th>Description</th></tr></thead><tbody><tr><td><code>uptime_sec</code></td><td><code>1533</code></td><td>How long has this instance of your app been running? Can be useful to visualize to see restarts</td></tr><tr><td><code>uptime_sec_log_10</code></td><td><code>3.185</code></td><td>Grows sub-linearly which allows you to visualize long-running services and brand new ones on the same graph</td></tr></tbody></table>
<pre tabindex="0" data-language="sql"><code><span><span>SELECT</span></span>
<span><span>  HEATMAP(uptime_sec),</span></span>
<span><span>  HEATMAP(uptime_sec_log_10)</span></span>
<span><span>WHERE</span></span>
<span><span>  main </span><span>=</span><span> true </span><span>AND</span></span>
<span><span>  service</span><span>.</span><span>name</span><span> =</span><span> &#34;api-service&#34;</span></span>
<span></span></code></pre>
<p><img src="https://jeremymorrell.dev/_astro/uptime.CJbFmMOT_2a6ER4.webp" alt="Heatmaps of uptime when a service enters a crash loop. It&amp;#x27;s far easier to distinguish in log scale" width="1810" height="1895" loading="lazy" decoding="async"/></p>
<h3 id="metrics">Metrics</h3>
<p>This one might be a bit controversial, but I’ve found it helpful to tag spans with context about what the system
was experiencing while processing the request. We fetch this information every ~10 seconds, cache it, and add it
to every main span produced during that time.</p>
<p>Capturing metrics in this way is not mathematically sound. Since you only get data when traffic is flowing, you
can’t calculate a <code>P90</code> for cpu load that would stand up to any rigorous scrutiny, but that’s actually fine
in practice. It’s close enough to get some quick signal while you’re debugging without switching to a different tool,
especially if you can avoid calculations and visualize with a heatmap.</p>
<p>I wouldn’t recommend setting alerts on this data though. Plain ol’ metrics are great for that.</p>
<p><a href="https://jessitron.com/">Jessica Kerr</a> recently wrote about this approach on the <a href="https://www.honeycomb.io/blog/get-infinite-custom-metrics-for-free">Honeycomb Blog</a>.</p>








































<table><thead><tr><th>Attribute</th><th>Examples</th><th>Description</th></tr></thead><tbody><tr><td><code>metrics.memory_mb</code></td><td><code>153</code> </td><td>How much memory is being used by the system at the time its service this request</td></tr><tr><td><code>metrics.cpu_load</code></td><td><code>0.57</code> </td><td>CPU load of the system service this request. Given as # of active cores</td></tr><tr><td><code>metrics.gc_count</code></td><td><code>5390</code></td><td>Last observed number of garbage collections. Could be cumulative (total since service started) or delta (ex: number in the last minute)</td></tr><tr><td><code>metrics.gc_pause_time_ms</code></td><td><code>14</code> </td><td>Time spent in garbage collections. Could also be cumulative or delta. Pick one and document which</td></tr><tr><td><code>metrics.go_routines_count</code></td><td><code>3</code> </td><td>Number of go routines running</td></tr><tr><td><code>metrics.event_loop_latency_ms</code></td><td><code>0</code> </td><td>Cumulative time spent waiting on the next event loop tick. An important metric for Node apps</td></tr></tbody></table>
<blockquote>
<p>Are these requests getting slow because we’re running out of memory or CPU?</p>
</blockquote>
<pre tabindex="0" data-language="sql"><code><span><span>SELECT</span></span>
<span><span>  HEATMAP(duration_ms),</span></span>
<span><span>  HEATMAP(</span><span>metrics</span><span>.</span><span>memory_mb</span><span>),</span></span>
<span><span>  HEATMAP(</span><span>metrics</span><span>.</span><span>cpu_load</span><span>)</span></span>
<span><span>WHERE</span></span>
<span><span>  main </span><span>=</span><span> true </span><span>AND</span></span>
<span><span>  service</span><span>.</span><span>name</span><span> =</span><span> &#34;api-service&#34;</span></span>
<span><span>GROUP BY</span><span> instance</span><span>.</span><span>id</span></span>
<span></span></code></pre>
<p><img src="https://jeremymorrell.dev/_astro/metrics.BHs4tp2f_1WSeWX.webp" alt="An example showing using the metrics data tagged on the span to get context for whats happening with the system" width="2982" height="4630" loading="lazy" decoding="async"/></p>
<h3 id="async-request-summaries">Async request summaries</h3>
<p>When using a tracing system async requests should get their own spans, but it can still be useful to roll up
some stats to identify outliers and quickly find interesting traces.</p>


















































<table><thead><tr><th>Attribute</th><th>Examples</th><th>Description</th></tr></thead><tbody><tr><td><code>stats.http_requests_count</code></td><td><code>1</code> </td><td>How many http requests were triggered during the processing of this request?</td></tr><tr><td><code>stats.http_requests_duration_ms</code></td><td><code>849</code></td><td>Cumulative time spent in these http requests</td></tr><tr><td><code>stats.postgres_query_count</code></td><td><code>7</code> </td><td>How many Postgres queries were triggered during the processing of this request?</td></tr><tr><td><code>stats.postgres_query_duration_ms</code></td><td><code>1254</code></td><td>Cumulative time spent in these Postgres queries</td></tr><tr><td><code>stats.redis_query_count</code></td><td><code>3</code> </td><td>How many redis queries were triggered during the processing of this request?</td></tr><tr><td><code>stats.redis_query_duration_ms</code></td><td><code>43</code></td><td>Cumulative time spent in these redis queries</td></tr><tr><td><code>stats.twilio_calls_count</code></td><td><code>1</code> </td><td>How many calls to this vendors api were triggered during the processing of this request?</td></tr><tr><td><code>stats.twilio_calls_duration_ms</code></td><td><code>2153</code></td><td>Cumulative time spent in these vendor calls</td></tr></tbody></table>
<blockquote>
<p>Surely my service makes a reasonable number of calls to the database… right?</p>
</blockquote>
<pre tabindex="0" data-language="sql"><code><span><span>SELECT</span></span>
<span><span>  HEATMAP(</span><span>stats</span><span>.</span><span>postgres_query_count</span><span>)</span></span>
<span><span>WHERE</span></span>
<span><span>  main </span><span>=</span><span> true </span><span>AND</span></span>
<span><span>  service</span><span>.</span><span>name</span><span> =</span><span> &#34;api-service&#34;</span></span>
<span></span></code></pre>
<p><img src="https://jeremymorrell.dev/_astro/postgres-queries.BANqR6rQ_13iADg.webp" alt="A heatmap of db queries per request. There is a bi-modal distribution but also some outliers that make a lot of requests" width="1284" height="700" loading="lazy" decoding="async"/></p>
<p><strong>Instead of adding this explicitly, couldn’t we aggregate this by querying the whole trace?</strong> See <a href="#frequent-objections">Frequent Objections</a></p>
<h3 id="sampling">Sampling</h3>
<p>Once you start collecting fine-grained telemetry from your systems at a significant scale you run head-on
into the problem of sampling. Running systems can produce a lot of data! Engineers frequently want to store
and query all of it. Exact answers always! Make it fast! Also cheap! But it’s trade-offs all the way down.
Telemetry data is fundamentally different from the transaction data you’re storing for your users, and you
should think about it differently.</p>
<p>Luckily you only really need a statistically significant subset of the full dataset. Even sampling 1 out of every
1000 requests can provide a suprisingly detailed picture of the overall traffic patterns in a system.</p>
<p>Sampling is a suprisingly deep topic. Keep it simple if you’re starting and do uniform random head sampling,
but track your sample rate per-span so you can be ready for more sophisticated approaches down-the-line.</p>
<p>Good tooling will weight your calculations with a per-span, so you don’t have to mentally multiple the <code>COUNT</code>
call by the <code>sample_rate</code> to get an accurate answer. Here are some relevant articles:</p>
<ul>
<li><a href="https://research.facebook.com/file/2964294030497318/scuba-diving-into-data-at-facebook.pdf">I was first introduced to this idea in the Scuba paper</a></li>
<li><a href="https://docs.honeycomb.io/manage-data-volume/sample/sampled-data-in-honeycomb/">Honeycomb supports per-event sample rates</a></li>
<li><a href="https://blog.cloudflare.com/explaining-cloudflares-abr-analytics/">Cloudflare’s Analytics Engine will automatically sample for you based on volume</a></li>
</ul>















<table><thead><tr><th>Attribute</th><th>Examples</th><th>Description</th></tr></thead><tbody><tr><td><code>sample_rate</code></td><td><code>1</code> </td><td><code>N</code> where 1 in <code>N</code> events will be sampled and stored and the rest dropped. If you’re sampling <code>1%</code> of requests, the <code>sample_rate</code> would be <code>100</code></td></tr></tbody></table>
<h3 id="timings">Timings</h3>
<p>I find it super useful to break up the work that gets done to respond to a request into a handful of important chunks
and track how long each segment took on the main span.</p>
<blockquote>
<p>Wait, isn’t that what child spans are for?</p>
</blockquote>
<p>Wrapping absolutely everything in its own span is the most common failure mode I see when engineers first get access
to tracing tools. You have to design the structure of your data for the way you want to query it.</p>
<p>Child spans are helpful for waterfall visualization for a single request, but can be difficult to query and visualize
across <em>all</em> of your requests. Putting that information on a single span makes it easier to query and also helps with
tools like <a href="https://www.honeycomb.io/bubbleup">Honeycomb’s BubbleUp</a> which can then immediately tell you that
that group of requests was slow because authentication took 10 seconds for some reason.</p>




















<table><thead><tr><th>Attribute</th><th>Examples</th><th>Description</th></tr></thead><tbody><tr><td><code>auth.duration_ms</code></td><td><code>52.2</code> </td><td>How long did we spend performing authentication during this request?</td></tr><tr><td><code>payload_parse.duration_ms</code></td><td><code>22.1</code> </td><td>Identify the core workloads of the service and add timings for them</td></tr></tbody></table>
<h3 id="errors">Errors</h3>
<p>If you encounter an error and need to fail the operation, tag the span with the error information: type, stacktrace, etc.</p>
<p>One approach that I have found super-valuable is tagging each location where we throw an error with a unique slug describing
the error. If this string is unique within your codebase, it is easily found with a quick search. This allows someone
to jump straight from a spike in errors on a dashboard to the exact line of code that throwing the error. It also provides
a convenient low-cardinality field to <code>GROUP BY</code>.</p>
<p>You’re unlikely to be able to wrap all possible errors, but any time a failed request doesn’t have an <code>exception.slug</code>
that is a good sign that you have places in your code where your error handling could be improved. It’s now really easy
to find examples of requests that failed in ways you didn’t anticipate.</p>
<pre tabindex="0" data-language="js"><code><span><span>if</span><span> isNotRecoverable</span><span>(err) {</span></span>
<span><span>  // note the use of a plain string, not a variable, not dynamically generated</span></span>
<span><span>  // consider enforcing this with custom lint rules</span></span>
<span><span>  setErrorAttributes</span><span>(err, </span><span>&#34;err-stripe-call-failed-exhausted-retries&#34;</span><span>);</span></span>
<span><span>  throw</span><span> err;</span></span>
<span><span>}</span></span>
<span></span></code></pre>








































<table><thead><tr><th>Attribute</th><th>Examples</th><th>Description</th></tr></thead><tbody><tr><td><code>error</code></td><td><code>true</code> </td><td>Special field for whether the request failed or not</td></tr><tr><td><code>exception.message</code></td><td><code>Can&#39;t convert &#39;int&#39; object to str</code> </td><td>The exception message encoded in the exception</td></tr><tr><td><code>exception.type</code></td><td><code>IOError</code> </td><td>The programmatic type of the exception</td></tr><tr><td><code>exception.stacktrace</code></td><td><code>ReferenceError: user is not defined</code></td><td>Capture the stack trace if its available to help pin-point where the error is being thrown</td></tr><tr><td><code>exception.expected</code></td><td><code>true</code>, <code>false</code></td><td>Is this an expected exception like a bot trying to hit a url that doesn’t exist? Allows filtering out of exceptions we can’t prevent but don’t need to worry about</td></tr><tr><td><code>exception.slug</code></td><td><code>auth-error</code> </td><td>Create a unique grepp-able slug-value to identify the code location of an error if its predictable during development time</td></tr></tbody></table>
<blockquote>
<p>Which of our enterprise users hit the most errors last week? And which one?</p>
</blockquote>
<pre tabindex="0" data-language="sql"><code><span><span>SELECT</span></span>
<span><span>  COUNT_DISTINCT(</span><span>user</span><span>.</span><span>id</span><span>)</span></span>
<span><span>WHERE</span></span>
<span><span>  main </span><span>=</span><span> true </span><span>AND</span></span>
<span><span>  service</span><span>.</span><span>name</span><span> =</span><span> &#34;api-service&#34;</span><span> AND</span></span>
<span><span>  user</span><span>.</span><span>type</span><span> =</span><span> &#34;enterprise&#34;</span></span>
<span><span>GROUP BY</span><span> exception</span><span>.</span><span>slug</span></span>
<span></span></code></pre>
<blockquote>
<p>Show me traces where we likely need to improve our error handling</p>
</blockquote>
<pre tabindex="0" data-language="sql"><code><span><span>SELECT</span></span>
<span><span>  trace</span><span>.</span><span>trace_id</span></span>
<span><span>WHERE</span></span>
<span><span>  main </span><span>=</span><span> true </span><span>AND</span></span>
<span><span>  service</span><span>.</span><span>name</span><span> =</span><span> &#34;api-service&#34;</span><span> AND</span></span>
<span><span>  error </span><span>=</span><span> true </span><span>AND</span></span>
<span><span>  exception</span><span>.</span><span>slug</span><span> =</span><span> NULL</span></span>
<span><span>GROUP BY</span><span> trace</span><span>.</span><span>trace_id</span></span>
<span></span></code></pre>
<h3 id="feature-flags">Feature flags</h3>
<p>Fine-grained feature flags are a developer super power that allows you to test code changes in production with only a fraction of
your users or traffic. Adding the flag information per-request allows you to compare how the new code is working as you opt more
of your traffic into the new code path. Coupled with the broad visibility you can get with wide events, and this can make even tricky
migrations vastly more manageable and allow you to ship code with confidence.</p>
<p>Note that semantic conventions differ here and suggest adding feature flag information as
<a href="https://opentelemetry.io/docs/specs/semconv/feature-flags/feature-flags-spans/">events on the span</a>.
I would suggest following that standard since it will ultimately have the best support from vendors if it’s moved to stable,
but especially in the mean time, I’m also putting this info on the main span.</p>




















<table><thead><tr><th>Attribute</th><th>Examples</th><th>Description</th></tr></thead><tbody><tr><td><code>feature_flag.auth_v2</code></td><td><code>true</code> </td><td>The value of a particular feature flag for this request</td></tr><tr><td><code>feature_flag.double_write_to_new_db</code></td><td><code>true</code> </td><td>The value of a particular feature flag for this request</td></tr></tbody></table>
<blockquote>
<p>What errors are the users in the new authentication flows hitting? How does it compare to the control group?</p>
</blockquote>
<pre tabindex="0" data-language="sql"><code><span><span>SELECT</span></span>
<span><span>  COUNT</span></span>
<span><span>WHERE</span></span>
<span><span>  main </span><span>=</span><span> true </span><span>AND</span></span>
<span><span>  service</span><span>.</span><span>name</span><span> =</span><span> &#34;api-service&#34;</span><span> AND</span></span>
<span><span>GROUP BY</span><span> feature_flag</span><span>.</span><span>auth_v2</span><span>, </span><span>exception</span><span>.</span><span>slug</span></span>
<span></span></code></pre>
<h3 id="versions-of-important-things">Versions of important things</h3>
<p>Runtimes, frameworks, and any major libraries you are using can be really helpful context.</p>

























<table><thead><tr><th>Attribute</th><th>Examples</th><th>Description</th></tr></thead><tbody><tr><td><code>go.version</code></td><td><code>go1.23.2</code></td><td>What version of your language runtime are you using?</td></tr><tr><td><code>rails.version</code></td><td><code>7.2.1.1</code></td><td>Pick out any core libraries like web frameworks and track their version too</td></tr><tr><td><code>postgres.version</code></td><td><code>16.4</code></td><td>If you can add the versions of any datastores you’re using, even better</td></tr></tbody></table>
<blockquote>
<p>A security issue with Rails just got announced. What versions of the framework are our services using?</p>
</blockquote>
<pre tabindex="0" data-language="sql"><code><span><span>SELECT</span></span>
<span><span>  COUNT_DISTINCT(</span><span>service</span><span>.</span><span>name</span><span>)</span></span>
<span><span>WHERE</span></span>
<span><span>  service</span><span>.</span><span>environment</span><span> =</span><span> &#34;production&#34;</span></span>
<span><span>GROUP BY</span><span> rails</span><span>.</span><span>version</span></span>
<span></span></code></pre>
<blockquote>
<p>Our memory usage seems higher that it used to be. Didn’t we upgrade the runtime recently? Does that correlate?</p>
</blockquote>
<pre tabindex="0" data-language="sql"><code><span><span>SELECT</span></span>
<span><span>  HEATMAP(</span><span>metrics</span><span>.</span><span>memory_mb</span><span>)</span></span>
<span><span>WHERE</span></span>
<span><span>  main </span><span>=</span><span> true </span><span>AND</span></span>
<span><span>  service</span><span>.</span><span>name</span><span> =</span><span> &#34;api-service&#34;</span></span>
<span><span>GROUP BY</span><span> go</span><span>.</span><span>version</span></span>
<span></span></code></pre>
<h3 id="your-specific-application">Your specific application</h3>
<p>Now we go off the map and get to the really valuable stuff. Your app likely does something unique or works in a particular
domain. You might need to <em>really</em> care about which professional credentials a Dentist using your app has, or which
particular storage warehouse a package is in, or which chip is in the embedded tracking device installed in the cat that
your app exists to track.</p>
<p>No framework is going to be able to understand what parts of your domain are important to track and automate this for you,
you have to do that.</p>






























<table><thead><tr><th>Attribute</th><th>Examples</th><th>Description</th></tr></thead><tbody><tr><td><code>asset_upload.s3_bucket_path</code></td><td><code>s3://bucket-name/path/to/asset.jpg</code></td><td>If you upload something, add context about where</td></tr><tr><td><code>email_vendor.transaction_id</code></td><td><code>62449c60-b51e-4d5c-8464-49217d91c441</code></td><td>If you interact with a vendor, track whatever transaction ID they give you in case you need to follow up with them</td></tr><tr><td><code>vcs_integration.vendor</code></td><td><code>github</code> </td><td>If there are 3-4 types that something might fall into, be sure to add that context. Ex: If 2% of requests start failing because bitbucket is experiencing issues, this will help identify the source of the issue immediately.</td></tr><tr><td><code>process_submission.queue_length</code></td><td><code>153</code> </td><td>Any time you interact with a queue, see if you can get the current length during submission</td></tr></tbody></table>
<h2 id="things-to-note">Things to note</h2>
<h3 id="you-should-probably-add-the-thing">You should probably add the thing</h3>
<p>If you find yourself asking “Am I ever really going to need this bit of data?”, default to throwing the attribute on.
The marginal cost of each extra attribute is very small. If the data volume does start to grow, prefer wider,
more context-rich events and a higher sample rate vs smaller events with a lower sample rate.</p>
<h3 id="heatmaps-are-your-friend">Heatmaps are your friend</h3>
<p><a href="https://www.honeycomb.io/blog/heatmaps-are-the-new-hotness">Honeycomb’s heatmaps</a> are amazing at helping you find outliers, seeing multi-modal distributions,
and getting a feel for your data. I wish more tooling supported them. I am not sure I can build software without them any more.</p>
<h3 id="embrace-the-feedback-loop">Embrace the feedback loop</h3>
<p>When you are modifying code, make a change to the telemetry so that you can see the impact of the new code running. Once
the code is released, check to make sure that you see the outcome you expected. Don’t hesitate to add specific fields
for one release and them remove them after.</p>
<p>Tighter feedback loops are like going faster on a bicycle. They make for more stable systems and let you move faster
with confidence.</p>
<h3 id="semantic-conventions-and-naming-consistency">Semantic conventions and naming consistency</h3>
<p>I’ve tried to embrace <a href="https://opentelemetry.io/docs/specs/semconv/general/trace/">semantic conventions</a> in my naming, but would not
be surprised if I’ve made multiple errors. Naming is hard!</p>
<p>It’s also hard to get consistency right within an organization or even across multiple systems owned by the same team. I would recommend
trying to use semantic conventions as a guide, but do prioritize getting data out of your system in some form and getting some early wins
over exacting adherence to an evolving specification. Once this data has proven its value within your organization, then you will have the
leverage to spend engineering cycles on making things consistent.</p>
<p>In the long run semantic conventions should allow Observability vendors to build new value and understanding on top of the telemetry you emit,
but this effort is only just getting started.</p>
<h2 id="frequent-objections">Frequent Objections</h2>
<h3 id="does-this-really-work">Does this really work??</h3>
<p>I have done this for dozens of production systems. Every single time the data has been invaluable for digging in and understanding what the
system is <em>actually</em> doing, and we’ve found something surprising, even for the engineers who had worked on the system for many years.</p>
<p>Things like:</p>
<ul>
<li>Oh, actually 90% of the traffic of this system comes from one user</li>
<li>Wait, one of our worker processes is actually running a month old version of the code somehow?</li>
<li>This API endpoint usually has payloads of 1-2kb, but there is an edge case affecting one user where it’s 40+MB. This causes their page loads to be <strong>several minutes longer than the p99</strong>.</li>
<li>After instrumenting the authentication middleware, around 20% of requests still didn’t have user info. There was a whole second authentication system for a different class of users that hadn’t been touched in years.</li>
<li>This endpoint that we’d like to deprecate accepts data in the form of <code>A</code>, <code>B</code>, and <code>C</code>, but none of our traffic ever even uses <code>C</code>. We can just drop support for that now.</li>
</ul>
<h3 id="i-dont-like-it-this-feels-wrong">I don’t like it. This feels wrong</h3>
<p>For anyone feeling that way now, I ask you to <a href="https://signalvnoise.com/posts/3124-give-it-five-minutes">give it five minutes</a>.</p>
<p>I find that when a log line wraps around your terminal window multiple times, most developers have a pretty visceral negative reaction.</p>
<p>This <em>feels</em> right:</p>
<pre tabindex="0" data-language="log"><code><span><span>[</span><span>2024-09-18</span><span> 22:48:32.990</span><span>] Request started http_path=/v1/charges request_id=req_123</span></span>
<span><span>[</span><span>2024-09-18</span><span> 22:48:32.991</span><span>] User authenticated auth_type=api_key key_id=mk_123 user_id=usr_123</span></span>
<span><span>[</span><span>2024-09-18</span><span> 22:48:32.992</span><span>] Rate limiting ran rate_allowed=</span><span>true</span><span> rate_quota=</span><span>100</span><span> rate_remaining=</span><span>99</span></span>
<span><span>[</span><span>2024-09-18</span><span> 22:48:32.998</span><span>] Charge created charge_id=ch_123 permissions_used=account_write request_id=req_123</span></span>
<span><span>[</span><span>2024-09-18</span><span> 22:48:32.999</span><span>] Request finished http_status=</span><span>200</span><span> request_id=req_123</span></span>
<span></span></code></pre>
<p>But this <em>feels</em> wrong:</p>
<pre tabindex="0" data-language="log"><code><span><span>[</span><span>2024-10-20T14:43:36.851Z</span><span>] duration_ms=</span><span>1266</span><span>.</span><span>1819686777117</span><span> main=</span><span>true</span><span> http.ip_address</span><span>=</span><span>92</span><span>.</span><span>21</span><span>.</span><span>101</span><span>.</span><span>252</span><span> instance.id</span><span>=api-</span><span>1</span><span> instance.memory_mb</span><span>=</span><span>12336</span></span>
<span><span>instance.cpu_count</span><span>=</span><span>4</span><span> instance.type</span><span>=</span><span>t3.small</span><span> http.request.method</span><span>=GET </span><span>http.request.path</span><span>=/api/categories/substantia-trado</span></span>
<span><span>http.route</span><span>=/api/categories/:slug </span><span>http.request.body.size</span><span>=</span><span>293364</span><span> http.request.header.content_type</span><span>=application/xml</span></span>
<span><span>user_agent.original</span><span>=</span><span>&#34;Mozilla/5.0 (X11; Linux i686 AppleWebKit/535.1.2 (KHTML, like Gecko) Chrome/39.0.826.0 Safari/535.1.2&#34;</span><span> user_agent.device</span><span>=phone</span></span>
<span><span>user_agent.os</span><span>=Windows </span><span>user_agent.browser</span><span>=Edge </span><span>user_agent.browser_version</span><span>=</span><span>3</span><span>.</span><span>0</span><span> url.scheme</span><span>=https </span><span>url.host</span><span>=</span><span>api-service.com</span><span> service.name</span><span>=api-service</span></span>
<span><span>service.version</span><span>=</span><span>1</span><span>.</span><span>0</span><span>.</span><span>0</span><span> build.id</span><span>=</span><span>1234567890</span><span> go.version</span><span>=</span><span>go1.23.2</span><span> rails.version</span><span>=</span><span>7</span><span>.</span><span>2</span><span>.</span><span>1</span><span>.</span><span>1</span><span> service.environment</span><span>=production </span><span>service.team</span><span>=api-team</span></span>
<span><span>service.slack_channel</span><span>=#api-alerts </span><span>service.build.deployment.at</span><span>=</span><span>2024-10-14T19:47:38Z</span></span>
<span><span>service.build.diff_url</span><span>=</span><span>https://github.com/your-company/api-service/compare/c9d9380..05e5736</span></span>
<span><span>service.build.pull_request_url</span><span>=</span><span>https://github.com/your-company/api-service/pull/123</span></span>
<span><span>service.build.git_hash</span><span>=</span><span>05e5736</span><span> service.build.deployment.user</span><span>=</span><span>keanu.reeves</span><span>@</span><span>your-company.com</span></span>
<span><span>service.build.deployment.trigger</span><span>=manual </span><span>container.id</span><span>=</span><span>1234567890</span><span> container.name</span><span>=api-service-</span><span>1234567890</span><span> cloud.availability_zone</span><span>=us-east-</span><span>1</span></span>
<span><span>cloud.region</span><span>=us-east-</span><span>1</span><span> k8s.pod.name</span><span>=api-service-</span><span>1234567890</span><span> k8s.cluster.name</span><span>=api-service-cluster </span><span>feature_flag.auth_v2</span><span>=</span><span>true</span></span>
<span><span>http.response.status_code</span><span>=</span><span>401</span><span> user.id</span><span>=Samanta27@</span><span>gmail.com</span><span> user.type</span><span>=vip </span><span>user.auth_method</span><span>=sso-google </span><span>user.team_id</span><span>=team-</span><span>1</span></span>
<span></span></code></pre>
<p><strong>You are structuring data so that it can be read efficiently by machines, not humans.</strong> Our systems emit too much data to waste
precious human lifetimes using our eyeballs to scan lines of text looking for patterns to jump out. Let the robots help.</p>
<h3 id="this-seems-like-a-lot-of-work">This seems like a lot of work</h3>
<p>If you want to implement everything I’ve talked about in this post that would be a <em>ton</em> of work. However, even implementing
the easiest subset is going to provide a lot of value. Not doing this results in so much <em>more work</em> building a mental model
of your system, trying to debug by thinking through the code and hoping your mental model matches reality.</p>
<p>A lot of this logic can be put into shared libraries within your org, though getting them adopted, keeping them updated and
in-sync, and getting engineers used to these tools presents a whole different set of challenges.</p>
<p>Many of these things could be surfaced to you by opinionated platforms or frameworks. I would love to see things move in
this direction.</p>
<h3 id="isnt-this-a-lot-of-data-wont-it-cost-a-lot">Isn’t this a lot of data? Won’t it cost a lot??</h3>
<p><a href="https://news.ycombinator.com/item?id=39531022"><img src="https://jeremymorrell.dev/_astro/hn-comment-on-cost.BvDY3dCa_Z1qSGcj.webp" alt="Hacker News comment: This isn&amp;#x27;t an unknown idea outside of Meta, it&amp;#x27;s just really expensive, especially if you&amp;#x27;re using a vendor and not building your own tooling. Prohibitively so, even with sampling." width="1472" height="262" loading="lazy" decoding="async"/></a></p>
<p>First, you should compare this to your current log volume per request. I have seen many systems where this
approach would <em>reduce</em> overall log volume.</p>
<p>However storing this data for every request against your system could be too expensive at scale. That’s
where sampling comes in. Sampling gives you the controls to determine what you want to spend vs the value
you receive from storing and making that data available to query.</p>
<p>Realtime OLAP systems are also getting cheaper all the time. Once upon a time Scuba held all data in memory
to make these types of questions quick to answer. Now most OLAP systems are evolving to columnar files stored
on cloud object storage with queries handled by ephemeral compute which is many orders of magnitude cheaper.</p>
<p>In the next section I’ll show just how much cheaper.</p>
<h3 id="repeated-data">Repeated data</h3>
<blockquote>
<p>Many of these fields will be the same for every request. Isn’t that really inefficient?</p>
</blockquote>
<p>This is where our intuitions can lie to us. Let’s look at a concrete example.</p>
<p>I <a href="https://github.com/jmorrell/a-practitioners-guide-to-wide-events/blob/main/column-storage-compression/index.js">wrote a script</a>
<a href="#footnote-1" id="footnote-ref-1" data-footnote-ref="true" aria-describedby="footnote-label"><code>[1]</code></a>
to generate a newline-delimited JSON file with a lot of the above fields and at least somewhat reasonable fake values.</p>
<p>Let’s say our service is serving <code>1000</code> req/s all day and sampling 1% of that traffic. Rounding to a whole number, that’s about a
million events. Generating a million example wide events results in a <code>1.6GB</code> file.</p>
<pre tabindex="0" data-language="js"><code><span><span>http_logs.ndjson     </span><span>1607.61</span><span> MB</span></span>
<span></span></code></pre>
<p>But we repeat the keys on every single line. Even just turning it into a CSV cuts the size by
more than 50%.</p>
<pre tabindex="0" data-language="js"><code><span><span>http_logs.csv         </span><span>674.72</span><span> MB</span></span>
<span></span></code></pre>
<p>Gzipping the file shows an amazing amount of compression, hinting that this isn’t
as much data as we might think.</p>
<pre tabindex="0" data-language="js"><code><span><span>http_logs.ndjson.gz   </span><span>101.67</span><span> MB</span></span>
<span></span></code></pre>
<p>Column store formats like <code>parquet</code> and Duckdb’s native format can do even better.</p>
<pre tabindex="0" data-language="js"><code><span><span>http_logs.parquet      </span><span>88.83</span><span> MB</span></span>
<span><span>http_logs.duckdb       </span><span>80.01</span><span> MB</span></span>
<span></span></code></pre>
<p>They store all of the data for a specific column contiguously, which lends itself to different
compression approachs. In the simplest case, if the column is always the same value, it can store that fact only once.
Values that are the same across an entire <a href="https://cloudsqale.com/2020/05/29/how-parquet-files-are-written-row-groups-pages-required-memory-and-flush-operations/">row group</a>
are incredibly cheap.</p>
<p><img src="https://jeremymorrell.dev/_astro/constant.wLvXM20h_Duvle.webp" alt="DuckDB diagram showing how a constant value along a whole column gets compressed" width="400" height="225" loading="lazy" decoding="async"/></p>
<p>If there are 2-3 different values, it can use dictionary-encoding to bit-pack these values really tightly. This also
speeds up queries against this column.</p>
<p><img src="https://jeremymorrell.dev/_astro/dictionary.B0WbkNfy_tDk06.webp" alt="DuckDB diagram showing how values get compressed using dictionary encoding" width="400" height="225" loading="lazy" decoding="async"/></p>
<p><a href="https://duckdb.org/2022/10/28/lightweight-compression.html">DuckDB has a great writeup on this</a> which goes into much more detail.
All of the data remains available and is easily (and quickly!) queryable.</p>
<p>This is hardly “big data”. Storing this on <a href="https://developers.cloudflare.com/r2/pricing/">Cloudflare’s R2</a> for a month would cost <code>US$ 0.0012</code>.
You could keep 60 days of retention for <code>US$ 0.072</code> / month.</p>
<pre tabindex="0" data-language="plaintext"><code><span><span>❯ duckdb http_logs.duckdb</span></span>
<span><span>D SELECT COUNT(*) FROM http_logs;</span></span>
<span><span>┌──────────────┐</span></span>
<span><span>│ count_star() │</span></span>
<span><span>│    int64     │</span></span>
<span><span>├──────────────┤</span></span>
<span><span>│      1000000 │</span></span>
<span><span>└──────────────┘</span></span>
<span><span>Run Time (s): real 0.002 user 0.002350 sys 0.000946</span></span>
<span><span>D SELECT SUM(duration_ms) FROM http_logs;</span></span>
<span><span>┌───────────────────┐</span></span>
<span><span>│ sum(duration_ms)  │</span></span>
<span><span>│      double       │</span></span>
<span><span>├───────────────────┤</span></span>
<span><span>│ 999938387.7714149 │</span></span>
<span><span>└───────────────────┘</span></span>
<span><span>Run Time (s): real 0.003 user 0.008020 sys 0.000415</span></span>
<span><span></span></span></code></pre>
<p>There are even <a href="https://arrow.apache.org/">in-memory</a> and <a href="https://arrow.apache.org/blog/2019/10/13/introducing-arrow-flight/">transport formats</a> to help
reduce size in memory and on the wire. <a href="https://opentelemetry.io/blog/2023/otel-arrow">OpenTelemetry is adopting arrow for its payloads</a> for this reason.</p>
<p>I found <a href="https://www.youtube.com/watch?v=dlO1cKnfWAI">this podcast on the FDAP stack particularly helpful in understanding this space</a>.</p>
<h3 id="couldnt-we-join-data-from-multiple-spans-together-to-get-this-information-query-the-whole-trace-at-once">Couldn’t we <code>JOIN</code> data from multiple spans together to get this information? Query the whole trace at once?</h3>
<p>This is certainly possible. <a href="https://docs.honeycomb.io/investigate/query/build/#clauses">Honeycomb has started allowing you to filter on fields on other spans in the same trace</a>.
However I’d qualify this as very advanced. You want to make the right thing the easiest thing, and if you make it
harder to ask questions, people will simply ask fewer questions. There are already a million things competing for our
attention. Keep it simple. Make it fast.</p>
<h3 id="does-this-mean-i-dont-need-metrics">Does this mean I don’t need metrics?</h3>
<p>You should probably still generate high-level metrics, though I bet you will need far fewer.</p>
<p>Metrics are great when you know you want an exact answer to a very specific question that you know ahead of time.
Questions like “How many requests did a serve yesterday?” or “What was my CPU usage like last month?”</p>
<hr/>
<p><a href="#footnote-ref-1" id="footnote-1"><code>[1]</code></a> Well… mostly <a href="https://www.cursor.com/">Cursor</a> wrote it</p> </article></div>
  </body>
</html>
