<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/Isysxp/Pico_1140">Original</a>
    <h1>Pico_1140: A PDP11/40 emulator that will run Unix v5/v6 on a Raspberry Pi RP2040</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
            <article itemprop="text">
<p dir="auto">A PDP11/40 emulator that will run Unix v5/v6 and a number of DEC operating systems.</p>
<p dir="auto">Introduction and acknowledgements:</p>
<p dir="auto">This is an updated version of Dave Cheney&#39;s CPP11 <a href="https://github.com/davecheney/cpp11">https://github.com/davecheney/cpp11</a> which will run on a Pi Pico.
For this project I have selected the Sparkfun Thing Plus board which contains an RP2040 chip, an SD card and 16Mb flash.
See <a href="https://www.sparkfun.com/products/17745" rel="nofollow">https://www.sparkfun.com/products/17745</a>.
Other hardware may be used including a Pi Pico itself. Wire the SDCard as per the Sparkfun schematic.
The SD card interface uses Karl Kugler&#39;s app (<a href="https://github.com/carlk3/no-OS-FatFS-SD-SPI-RPi-Pico">https://github.com/carlk3/no-OS-FatFS-SD-SPI-RPi-Pico</a>) which is included in the repo.
The project environment is for Visual Studio Code. The Pico SDK is also required <a href="https://github.com/raspberrypi/pico-sdk">https://github.com/raspberrypi/pico-sdk</a>. This is not included.</p>
<p dir="auto">The emulator:</p>
<p dir="auto">The de facto emulator for most old computers is Simh <a href="https://github.com/simh/simh">https://github.com/simh/simh</a>. The size and complexity of the individual machine
apps is such that a direct port to a memory limited system is not feasible. This is the reason for basing the system on a lightweight
emulator as provided by Dave Cheney for the ATMEGA2560 <a href="https://github.com/davecheney/avr11">https://github.com/davecheney/avr11</a> and the C++ version above.
The code has been updated with patches to the KL11/KT11/KB11/RK11 systems so that the Pico SDK services may be used.
The 11/40 FIS has also been added an this is not a true simulation as found in Simh but an optimised emulation.
The emulator will run the instruction test and EIS MAINDECS. It fails the traps tests as a stack limit trap and trace trap are not implemented.
Similarly, the KT11 test fails as the maintainence mode is not implemented. Finally, the FIS test fails as the implementation of this
uses translation of DEC floating point to IEEE 754.
The app is sufficiently accurate to run RT11 V3/V4, Unix V5 and V6 and mini-unix (<a href="http://www.tavi.co.uk/unixhistory/mini-unix.html" rel="nofollow">http://www.tavi.co.uk/unixhistory/mini-unix.html</a>). I would note
that the floating point performance for Unix is rather slow. It will also run MINC Basic for which I have included an RK05 image
which has the limitation that some command will return to the RT11 . prompt. The original version uses a modified RX02 monitor.
There is a KW11 line time clock. The implementation is not good and system time will not be accurate.</p>
<p dir="auto">Building:</p>
<p dir="auto">The app is provided as a Visual Studio Code project. Firstly, a copy of the Pico SDK is required in the same top level directory as the app.
The path to the SDK will need to be setup on your system. Also, GCC of at least version 10 is required. This may need to be installed and
selected as the active kit. The build process will create a .uf2 binary in the build directory. This can be copied to the RP2040 via the
virtual drive presented by the RP2040 boot system.
Any number of RK05 disk images may be copied to the root of an SDCard formatted to FAT32. I use a 32Gb card and the SPI system works with this.
The images are in the same format as used by Simh and may be built or modified in Simh prior to use.</p>
<p dir="auto">Booting:</p>
<p dir="auto">After inserting an SDCard and resetting the card, a COM port will appear. Connect a terminal app to this eg TeraTerm. The images on the SDCard
will be listed with an index that is used to select the boot volume.
The system boots using a boot rom in bootrom.h at address 2000. The start address is set in setup(..) in avr11.cxx.
At present, only 1 volume can be attached at a time. Typically, unix images prompt with a &#39;@&#39;, then type unix or rkunix to boot.
The switchregister is set by default to 0173030 in KB11::reset which will boot unix in single user mode.
In addition, the app contains a binary loader which can be called from setup(...) as above with a suitable change to the cpu start address.
You can load a binary tape from the SDCard if the name of the tape image starts with &#39;maindec&#39;. The default start address in 0200;</p>
<p dir="auto">Unix: It is sooooo easy to trash these old unix volumes! It is a good habit to &#39;sync&#39; a lot of times just in case something does go wrong!</p>
<p dir="auto">Update: 20/12/2022</p>
<p dir="auto">I have now added an RL01/2 driver to the system. By default, the app will attach rt11V.dsk to unit 0. Please make sure this file is on
the SD Card (copy is in images). The logic in this driver is slightly different to the RK11 driver in that I/O is defered for 10 CPU cycles.
This is due to some curious behavior of RT11 in that without this option, the &#39;R&#39; command does not work correctly whereas &#39;RUN&#39; does.
After the system has booted into RT11 V4..
.BOOT DL0:
This will bring up RT11 V5 from the RL02 image.</p>
<p dir="auto">On this image there is a copy of the DECUS c compiler. This only compiles really odltime c. Documentation in images directory.
As a test of this system, you can have a really good laugh and run PDP8.sav...
</p>
<p dir="auto">. (now you are running the 4K PDP-8 DMS system.)</p>
<p dir="auto">SHALL I RETAIN LOG, EXP, ATN ?:YES</p>
<p dir="auto">PROCEED.</p>
<ul dir="auto">
<li></li>
</ul>
<p dir="auto">So, now you have an emulated PDP-8 runnning on an emulated PDP-11 .... Rabbit hole or what!!!!
See PDP8.COM for the command lines to build this app and PDP8.C for the source code.</p>
<p dir="auto">Have fun, Ian Schofield Dec 2022.</p>
<p dir="auto">Update Jan 2023
I have committed a substantial update to the code base which has been in test for some time.</p>
<ol dir="auto">
<li>Added an RL01/2 handler. The image and boot device can be selcted from the initial dialogues.<br/></li>
<li>Updated a significant problem with register mapping into I/O space. This is only a partial fix. See KB11.H for the apparently trivial changes.<br/></li>
<li>Minor changes to other handlers to allow for the below.<br/></li>
<li>Added a suitable minimal RSTS/E image which is built to use the FIS instruction set.<br/></li>
<li>Added a suitable minimal Multi-User BASIC image.<br/></li>
</ol>
<p dir="auto">It has turned out to be quite complex to allow for the function of UNIX/RT11/RSTS/MUBAS as they all have some interesting differences.</p>
<p dir="auto">Ian Schofield Jan 2023</p>
<p dir="auto">Update Jan 2023</p>
<ol dir="auto">
<li>RT11. RT11_V5_CFB: Fortran/Basic/C.<br/></li>
<li>RT11_V5_MUBasic: Multi user basic. Boot to RT11XM and run MUBASX. Type &#39;2user&#39; for the config file.<br/></li>
<li>Unix_V6: I have rebuilt the kernel to add an extra DL11 device. You should see a login in both terminal windows.<br/></li>
<li>RSX_31_Fortran: This image boot RSX11/M in 2 user mode. This is a very complex OS. Best of luck!<br/></li>
<li>MINC_BASIC is as before and boots to a &#39;READY&#39; prompt.<br/></li>
<li>Rsts_DL: This boot Rsts/E in multi user mode. A bit easier to use than RSX/11.<br/></li>
</ol>
 </article>
          </div></div>
  </body>
</html>
