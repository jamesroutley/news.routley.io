<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.dlp.rip/decorative-cryptography">Original</a>
    <h1>Decorative Cryptography</h1>
    
    <div id="readability-page-1" class="page"><div aria-label="Content">
      <div>
        <article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    <p>All encryption is end-to-end, if you’re not picky about the ends.</p>

<pre><code>config TCG_TPM2_HMAC
    bool &#34;Use HMAC and encrypted transactions on the TPM bus&#34;
    default n
    select CRYPTO_ECDH
    select CRYPTO_LIB_AESCFB
    select CRYPTO_LIB_SHA256
    select CRYPTO_LIB_UTILS
    help
      Setting this causes us to deploy a scheme which uses request
      and response HMACs in addition to encryption for
      communicating with the TPM to prevent or detect bus snooping
      and interposer attacks (see tpm-security.rst).  Saying Y
      here adds some encryption overhead to all kernel to TPM
      transactions.
</code></pre>

<p>Last year, I came agross a Linux kernel feature called <code>TCG_TPM2_HMAC</code>. It
claims to detect or prevent active and passive interposer attackers. That’s <a href="https://www.dlp.rip/tpm-genie">one
of my sleeper agent activation phrases</a>, so I dug in.</p>

<!--more-->

<p><code>TCG_TPM2_HMAC</code> lives primarily in
<a href="https://github.com/torvalds/linux/blob/master/drivers/char/tpm/tpm2-sessions.c">drivers/char/tpm/sessions.c</a>
and is discussed at further length in
<a href="https://github.com/torvalds/linux/blob/master/Documentation/security/tpm/tpm-security.rst">Documentation/security/tpm/tpm-security.rst</a>.</p>

<p>It all sounds really great. We should care about interposer adversaries. It’s
great to use the TPM features that were invented to help us with these problems.
Let’s draw a little picture of what’s being attempted here.</p>

<p><img src="https://www.dlp.rip/images/2026-01-03-tpm2-hmac-threat-model.drawio.svg" alt="TCG_TPM2_HMAC&#39;s Threat Model"/></p>

<p>In this threat model, there is an adversary who can access the untrusted bus
on which all the TPM traffic is sent during the boot. This can be done using
<a href="https://trmm.net/tpm-sniffing/">hardware hacking</a> or by hijacking another
device that controls the TPM bus (e.g., a BMC).</p>

<p><code>TCG_TPM2_HMAC</code> is a kernel feature, and the kernel boots after the platform
firmware and the boot loader, so it can’t do anything about interposer
adversaries tampering with firmware and boot loader measurements. Let’s assume
for now that the firmware and boot loader are just implicitly trusted to have
booted “correct” code and successfully made honest measurements of all the boot
stages up to and including the kernel. We also implicitly trust the TPM to
behave correctly, here. <a href="https://www.dlp.rip/attesting-tpm-firmware">Or if you have a newer TPM, don’t!</a></p>

<p>Someone familiar with
<a href="https://en.wikipedia.org/wiki/STRIDE_model">the STRIDE model</a> can easily
observe the following threats just on the big red wire in our picture above:</p>

<table>
  <thead>
    <tr>
      <th>Attack</th>
      <th>Example</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Spoofing</strong></td>
      <td>Attacker pretends to be the TPM or the CPU to the other device</td>
    </tr>
    <tr>
      <td><strong>Tampering</strong></td>
      <td>Attacker drops or modifies measurements sent to the TPM</td>
    </tr>
    <tr>
      <td>Repudiation</td>
      <td>Not obviously applicable in this case</td>
    </tr>
    <tr>
      <td><strong>Information Disclosure</strong></td>
      <td>Attacker obtains unsealed secrets (e.g., disk encryption keys)</td>
    </tr>
    <tr>
      <td><strong>Denial of Service</strong></td>
      <td>Attacker drops measurements sent to the TPM</td>
    </tr>
    <tr>
      <td>Escalation of Privilege</td>
      <td>Not obviously applicable in this case</td>
    </tr>
  </tbody>
</table>

<p>The attacker may or may not necessarily get anything out of manipulating the TPM
traffic itself (unless they are some kind of <a href="https://www.dlp.rip/">degenerate</a> that
just likes to talk to TPMs for fun). But folks who are familiar with TPM-based
measured boot and attestation should be able to immediately see the value to the
attacker of “modifying measurements” or “obtaining unsealed secrets”.</p>

<p>Let’s take a second to distinguish the two types of attackers here:</p>

<ul>
  <li><strong>Passive Interposers</strong> aka snoopers can only read from the bus but not modify
the data.</li>
  <li><strong>Active Interposers</strong> can read and write to the bus.</li>
</ul>

<p>The very best thing a <strong>passive</strong> interposer can do here is <strong>Information</strong>
<strong>Disclosure</strong>: read data from the bus. Since measurements should typically not
be secret, the (legitimate) measurements sent to the TPM are not very
interesting. Unsealed secrets (that were sealed to the measurements in the TPM)
might very much be! That’s why
<a href="https://github.com/torvalds/linux/blob/master/security/keys/trusted-keys/trusted_tpm2.c">security/keys/trusted-keys/trusted_tpm2.c</a>
<a href="https://github.com/torvalds/linux/blob/aacb0a6d604ac9953b261963efe25ae7521b7c58/security/keys/trusted-keys/trusted_tpm2.c#L506">uses an <code>encrypt</code> session</a>
using the helper
<a href="https://github.com/torvalds/linux/blob/aacb0a6d604ac9953b261963efe25ae7521b7c58/drivers/char/tpm/tpm2-sessions.c#L364"><code>tpm_buf_append_hmac_session</code></a>
which is unfortunately a little bit entangled with the <code>TCG_TPM2_HMAC</code> feature
(but that’s how software development goes). All that really needs to be done
here for this case is to use an <code>encrypt</code> session key established using the EK
as discussed widely by many others but also <a href="https://www.dlp.rip/tpm-genie">myself</a>.</p>

<p>The remainder of this blog post discusses the <strong>active</strong> interposer case.</p>

<p>An active interposer generally wants to do one of two things in this scenario:</p>

<ol>
  <li>(<strong>Tampering</strong>, <strong>Denial of Service</strong>) Tamper with TPM measurements made by
the kernel, to falsely attest or unseal as the “intended” code or state, from
“unintended” code or state.</li>
  <li>(<strong>Spoofing</strong>, <strong>Information Disclosure</strong>) Interpose the TPM connection and
defeat the encrypt session solution for unsealing secrets.</li>
</ol>

<p>The <code>TCG_TPM2_HMAC</code> feature will
<a href="https://github.com/torvalds/linux/blob/aacb0a6d604ac9953b261963efe25ae7521b7c58/drivers/char/tpm/tpm2-sessions.c#L982">establish an auth session</a>
salted (key-encapsulated) to the EK every time the kernel
<a href="https://github.com/torvalds/linux/blob/aacb0a6d604ac9953b261963efe25ae7521b7c58/drivers/char/tpm/tpm2-cmd.c#L192">extends a PCR</a>
or
<a href="https://github.com/torvalds/linux/blob/aacb0a6d604ac9953b261963efe25ae7521b7c58/drivers/char/tpm/tpm2-cmd.c#L273">gets randomness</a>.
You might say to yourself, “self, that’s a lot of overhead (asymmetric crypto
in the TPM) for common, fast operations (PCR extensions, randomness generation)”
and
<a href="https://lore.kernel.org/linux-integrity/b8a7b3566e6014ba102ab98e10ede0d574d8930e.camel@huaweicloud.com/">you’d be right</a>.
Wow, this feature is expensive! Good thing it’s solving a real problem, right?</p>

<p><img src="https://www.dlp.rip/images/2026-01-03-anakin-padme.jpg" alt="Anakin says no"/></p>

<p>Every time a session is needed (e.g., every time the kernel needs to extend a
PCR), the <code>TCG_TPM2_HMAC</code> feature key-encapsulates a new session key with
something called the “Null Primary Key” which is a P256 ECDH key derived from
the Null hierarchy (which means it changes on every boot). It uses this session
key to protect the TPM command by encrypting the inputs and outputs and
adding an HMAC to detect tampering. Great.</p>

<p>One problem: how does the kernel know what the Null Primary Key should be? Read
<a href="https://lore.kernel.org/linux-integrity/CAMigqh0x+yK25f8J_Yrn9v93969zQxbpevivWWZ6-NLFy4pDHQ@mail.gmail.com/T/#m835cf391e6ff8b3f85ff72e064798f9439b5770a">this thread</a>
to not find out.</p>

<p>The kernel takes the Null Primary Key at face value and stashes the Name (hash)
of it at <code>/sys/class/tpm/tpm0/null_name</code> and <strong>trusts that userspace will</strong>
<strong>attest the key later using the EK.</strong></p>

<p>This inverts the chain of trust for measured boot: the kernel is responsible for
measuring userspace, so that “bad” or “malicious” or “unintended” userspace
cannot impersonate “good” or “well-behaved” or “intended” userspace.</p>

<p>This means that all the active-interposer attacker has to do to defeat
<code>TCG_TPM2_HMAC</code> is:</p>

<ol>
  <li>Replace or hijack the userspace component responsible for checking the
Null Primary Key. Call this “Component X”.</li>
  <li>Interpose HMAC session establishment by creating a fake Null Primary Key
themselves (e.g., in software) and pretend to be the TPM responding to
requests.</li>
  <li>Intercept <code>TPM2_PCR_Extend</code> commands, replacing the measurements as desired
(e.g., replace “hash of malicious Component X” with “hash of good Component
X”).</li>
  <li>Malicious component X ignores the “wrong” Null Primary Key name at
<code>/sys/class/tpm/tpm0/null_name</code>.</li>
</ol>

<p>You can solve this problem by threat model gerrymandering: simply declare that
the active interposer adversary is not able to tamper with userspace, which is
stored on physical media less than 12 inches away from the TPM in most cases.
Note that full disk encryption using the TPM cannot save you here, because
if the booting system can fetch the key, so can the physical adversary. If you
still think you have a tamper-proof userspace at this point, ask yourself why
you need the kernel to measure it anymore.</p>

<p>Adding remote attestation also does not help here, because while a remote system
can spot-attest a “Null Primary Key”, it has no way of knowing which key the
kernel used when making its measurements.</p>

<p><code>TPM2_TCG_HMAC</code> was disabled by default again
<a href="https://lore.kernel.org/linux-integrity/20250825203223.629515-1-jarkko@kernel.org/">in August 2025</a>
<a href="https://lore.kernel.org/all/aOibAOKu_lEsSlC8@kernel.org/">starting with version 6.18</a>.</p>

<p>What lessons can we learn from all this?</p>

<ol>
  <li>
    <p><strong>Applied cryptography cannot solve a security problem. It can only convert</strong>
<strong>a security problem into a key-management problem.</strong></p>

    <p>Corollary: If you aren’t actually solving the key-management problem, your
cryptography is strictly decorative. This is not only not helpful, it is
actively harmful, because it gives users a false sense of security, leading
them to skip other precautions they would have otherwise taken.</p>
  </li>
  <li>
    <p><strong>Chains of trust are directional. Do not invert them.</strong></p>

    <p>Corollary:</p>

    <p><img src="https://www.dlp.rip/images/2026-01-03-jayne.jpg" alt="Jayne"/></p>

    <p><em>
You know what the chain of trust is? It&#39;s the chain I go get and beat you
 with &#39;til ya understand who&#39;s trustin&#39; who here.
 </em></p>
  </li>
  <li>
    <p><strong>Unexplainable security features are just marketing materials.</strong></p>

    <p>Corollary: While attestation protocols can be quite byzantine, they should
always boil down to 1 or more of “X checks Y against Z” and it should always
be possible to explain why X, Y, and Z are each trusted. The explanations
may lead to more X, Y, Z tuples, and this is fine, but don’t give up if your
questions aren’t being answered.</p>

    <p>Corollary 2: When someone comes along with detailed questions about something
you’re responsible for, don’t take it personally. Instead, build trust by
engaging in a good-faith discussion. You’ll either be right, and your answers
appreciated, or you’ll learn about a gap in your system you can improve.</p>
  </li>
</ol>

<p>Active physical interposer adversaries are a very real part of legitimate threat
models. You need an integrated root-of-trust in your CPU in order to solve
these. Check out <a href="https://chipsalliance.github.io/caliptra-web/">Caliptra</a>,
which provides
<a href="https://trustedcomputinggroup.org/work-groups/dice-architectures/">TCG DICE</a>
APIs from within the SoC itself as an integrated root-of-trust. This can be
used on its own, or in conjunction with a discrete TPM.</p>

<p><em>Opinions expressed here are my own and do not represent the official positions
of any employer(s) of mine, past or present</em></p>

  </div>
</article>

      </div>
    </div></div>
  </body>
</html>
