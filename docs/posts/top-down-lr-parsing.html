<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://pavpanchekha.com/blog/top-down-lr.html">Original</a>
    <h1>Top-Down LR Parsing</h1>
    
    <div id="readability-page-1" class="page"><div id="content">

<p>
This semester, I am teaching <a href="https://github.com/utah-cs4470-sp23/class">Compilers</a>, and I&#39;m quite happy with how I covered parsing this year. Specifically, I taught students to build a top-down LR parser and it seemed to go relatively well.
</p>

<p>
<i>Update</i>: Laurence asks me to note that he&#39;s not as much of a parser theorist as this post makes him out to be.
</p>

<p>
<i>Update</i>: There&#39;s an ongoing <a href="https://news.ycombinator.com/item?id=35151606">discussion on Hacker News</a> about this post. I learned a lot from it!
</p>

<div id="outline-container-org01f949d">
<h2 id="org01f949d">What I want out of parsing</h2>
<div id="text-org01f949d">
<p>
I am not a big fan of the parsing portion of a compilers class, but I try to do a good job of it because I recognize that parsing is the part of my compilers class that students are most likely to reuse in their later programming. This means that I do want students to parse a real programming language with infix operators and precedence, not just S-expressions, and to use a general-enough parsing algorithm that they could re-use their skills on future parsing problems.
</p>

<p>
Additionally, the style of my Compilers class is that we write nearly everything from scratch, so I don&#39;t just want to teach them to use ANTLR or a similar tool. I also do not want to spend a lot of time on theory. While I find Laurence Tratt&#39;s <a href="https://tratt.net/laurie/blog/2023/why_we_need_to_know_lr_and_recursive_descent_parsing_techniques.html">argument for LR parsing</a> persuasive, I find that most presentations of LR parsing are very theoretical, and building intuition for resolving conflicts takes longer than I want to spend on parsing (which is two weeks of lecture and three assignments).
</p>

<p>
Finally, what I did take away from Laurence Tratt&#39;s posts is that I do <i>not</i> want students to just write spaghetti code recursive descent parsers that just &#34;do something&#34;. I want to teach a parsing <i>methodology</i>, not just get them to write enough code to get the parser working; I want students to derive their parser directly from their grammar. Especially because, in my experience, students are exceptionally clever when it comes to inventing bugs, and parser bugs are often quite hard to find.
</p>
</div>
</div>

<div id="outline-container-org3e2b753">
<h2 id="org3e2b753">Top-down LL</h2>
<div id="text-org3e2b753">
<p>
I start by teaching students to write recursive descent parsers for what I call LL(1) languages. Specifically, I say that a grammar is LL(1) if every production for a non-terminal N starts with a different terminal T. I make sure the grammar we compile has plenty of productions like that:
</p>

<pre>expr : &lt;integer&gt;
	| &lt;float&gt;
	| &lt;variable&gt;
	| [ &lt;expr&gt; , ... ]
	| { &lt;expr&gt; , ... }
</pre>

<p>
Because I am teaching them a methodology, I have a very specific way I want them to write this parser.
</p>

<p>
I ask them to write a function called <code>parse_expr</code>, and functions called <code>parse_int_expr</code>, <code>parse_float_expr</code>, and so on. The <code>parse_expr</code> functions only ever do one thing: they switch on the results of <code>peek_token</code>, and in each branch calls a <code>parse_X_expr</code> function:
</p>

<div>
<pre><span>Expr</span> <span>parse_expr</span>() {
    <span>switch</span> (peek_token()) {
    <span>case</span> INT:
        <span>return</span> parse_int_expr();
    ...
    }
}
</pre>
</div>

<p>
The <code>parse_X_expr</code> functions only ever do one thing: they call <code>expect_token</code> for each token and <code>parse_N</code> for each non-terminal <code>N</code>, one after another, before finally building and returning an AST node of the appropriate type.
</p>

<div>
<pre><span>IntExpr</span> <span>parse_int_expr</span>() {
    <span>int</span> <span>n</span> = expect_token(<span>TokenType</span>.INTVALUE);
    <span>return</span> <span>new</span> <span>IntExpr</span>(n);
}
</pre>
</div>

<p>
This year, I waited to introduce sequences and repetion until I had covered LR parsing, but in future years I might introduce the idea of a <code>parse_exprs</code> function that contains a while loop, and teach them to write a single specific while loop to parse sequences.
</p>

<p>
The goal is that students should be able to translate an LL(1) grammar to code mechanically. This part is pretty standard, it&#39;s how top-down parsing is normally taught. Most parsing classes that aren&#39;t using a parser generator are going to have a section somewhat like this.
</p>
</div>
</div>

<div id="outline-container-orge6f481a">
<h2 id="orge6f481a">Top-down LR</h2>
<div id="text-orge6f481a">
<p>
I now explain that some grammars are not LL(1), because multiple productions can start with the same terminal. I stick to easy examples, like post-fix indexing operations, instead of doing tricky things like infix operations. So for example, we might add this to the grammar:<sup><a id="fnr.1" href="#fn.1" role="doc-backlink">1</a></sup><span id="fn.1"><sup>1</sup> For those wondering, in the language I have them compile, square brackets are for N-dimensional tensors and curly braces are for tuples.</span>
</p>

<pre>expr : &lt;expr&gt; [ &lt;expr&gt; , ... ]
	| &lt;expr&gt; { &lt;integer&gt; }
</pre>

<p>
This grammar isn&#39;t LL(1) because both these productions and other productions can start with, say, a variable token. Note that this is implicitly introducing the <code>FIRST</code> set from LR table construction, but instead of defining it recursively, I just talk them through the concept of whether the first token of two productions can match. This is a natural follow-on from discussing LL(1) grammars.
</p>

<p>
Now, instead of introducing LR grammars and LR parsing, I introduce the idea of transforming this grammar into another one. Specifically, I ask students to transform the grammar into:
</p>

<pre>expr : &lt;integer&gt; &lt;expr_cont&gt;
	| &lt;float&gt; &lt;expr_cont&gt;
	| &lt;variable&gt; &lt;expr_cont&gt;
	| [ &lt;expr&gt; , ... ] &lt;expr_cont&gt;
	| { &lt;expr&gt; , ... } &lt;expr_cont&gt;

expr_cont : [ &lt;expr&gt; , ... ] &lt;expr_cont&gt;
		| { &lt;integer&gt; } &lt;expr_cont&gt;
		|
</pre>

<p>
This grammar isn&#39;t quite LL(1), because <code>expr_cont</code> has an empty production, but the rule is just that all productions have to start with different tokens, except that there can be an empty production, and if there&#39;s a single production then it can start with a non-terminal.
</p>

<p>
Note that this grammar is equivalent to the original. Doing this transformation is <i>not</i> easy or intuitive for students, but we do lots of examples. I pick two different productions that can start with the same token and write out example programs that use those two productions. Then I ask: at what point do we know that they&#39;re using two different productions, because they correspond to two different tokens that can be seen at that point? That&#39;s the point where we want to add a <code>_cont</code> grammar class. Again, this is implicitly introducing the <code>FOLLOWS</code> set from LR parsing, but I introduce it intuitively instead of mathematically.
</p>

<p>
The <code>parse_expr</code> and <code>parse_int_expr</code> functions stay exactly the same; here, <code>parse_int_expr</code> calls <code>parse_expr_cont</code> at the end, just like a normal non-terminal. However, these continuation non-terminals are special (and I tell students to always name them <code>x_cont</code> to keep track): instead of taking no arguments, they take terminals or non-terminals as an argument. So, for example, the <code>parse_int_expr</code> parses an integer token, builds an <code>IntExpr</code> AST node from it, and then calls <code>parse_expr_cont</code> with that <code>IntExpr</code> as an argument:
</p>

<div>
<pre><span>Expr</span> <span>parse_int_expr</span>() {
    <span>String</span> <span>n</span> = expect_token(<span>TokenType</span>.INTVALUE);
    <span>IntExpr</span> <span>e</span> = <span>new</span> <span>IntExpr</span>(n);
    <span>return</span> parse_expr_cont(e);
}
</pre>
</div>

<p>
These parsing functions for continuation non-terminals then use that argument to build larger AST nodes, based on further parses:
</p>

<div>
<pre><span>Expr</span> <span>parse_tupleindex_expr_cont</span>(<span>Expr</span> <span>base</span>) {
    expect_token(<span>TokenType</span>.LCURLY);
    <span>String</span> <span>n</span> = expect_token(<span>TokenType</span>.INTVALUE);
    expect_token(<span>TokenType</span>.RCURLY);
    <span>Expr</span> <span>e</span> = <span>new</span> <span>TupleIndexExpr</span>(base, n);
    <span>return</span> parse_expr_cont(e);
}
</pre>
</div>

<p>
One big advantage of this approach is that it leverages the idea of grammar transformation / elaboration / equivalence. This makes talking about ambiguity easier, because my approach to grammar ambiguity also involves rewriting the grammar into an equivalent, non-ambiguous grammar. Moreover, I can ask students to turn in elaborated grammars before they start coding, which cuts down on bugs dramatically and also isn&#39;t that much work for me (because the grammars are short).
</p>

<p>
Now, if you think about this in terms of LR parsing, all of the <code>_cont</code> grammatical classes here correspond to different LR(0) states, and the fact that these <code>_cont</code> classes always come at the end of a production means that the recursive descent parser is using tail calls, that is, just iterating instead of recursing. So once you have the parser in this form, you can create invert the control flow to get a normal LR parser with a table, so I&#39;m not straying far from the theory here.
</p>

<p>
But most presentations of an LR parser introduce it with enough formality to write a parser generator—because most LR parsers use a table, and writing a table by hand is difficult for any non-trivial language. Instead of doing that, my top-down LR parsing approach requires students to compute the state table and transitions mostly by hand—but they only need to do it once, for the specific language that we are compiling, which means much less formality is needed. Students don&#39;t need to learn how the <code>FIRST</code> and <code>FOLLOW</code> sets are defined, though they do <i>use</i> those concepts when doing the transformation themselves. (And, of course, I control the langauge grammar so I&#39;ve built it in a way to require <code>_cont</code> tokens in a couple of places.) By framing that as a grammar transformation instead of table construction, I also get them to practice a skill they&#39;ll need later for grammar disambiguation.
</p>
</div>
</div>

<div id="outline-container-orga761679">
<h2 id="orga761679">Disambiguation</h2>
<div id="text-orga761679">
<p>
My discussion of disambiguation is pretty standard, so I won&#39;t discuss it in too much detail. I introduce ambiguity, explain the idea of banning of banning certain patterns (like a <code>AddExpr</code> below a <code>MultExpr</code>), show how you do that by splitting the <code>expr</code> class into multiple classes, and so on. This is how most discussions of parsing cover it, and I do it too.
</p>

<p>
But one thing that has to do with parsing algorithms is associativity. LL parsers prefer to parenthesize to the right while LR parsers prefer to parenthesize to the left. However, in my top-down LR approach, the grammar is the same:
</p>

<pre>addexpr : &lt;mulexpr&gt; &lt;addexpr_cont&gt;

addexpr_cont: + &lt;mulexpr&gt; &lt;addexpr_cont&gt;
		    |
</pre>

<p>
The main difference is how <code>parse_addexpr_cont</code> works. You can specify its input to be a <code>MulExpr</code> or an <code>Expr</code>. In the first case, you&#39;re guaranteeing that the left hand side of the addition is a multiply node, meaning that you get right associativity. In the second case, you allow it to be an addition node and get left associativity. In code, option one looks like this:
</p>

<div>
<pre><span>Expr</span> <span>parse_add_addexpr_cont</span>(<span>MulExpr</span> <span>lhs</span>) {
    expect_token(<span>TokenType</span>.PLUS);
    <span>MulExpr</span> <span>middle</span> = parse_mulexpr();
    <span>Expr</span> <span>rhs</span> = parse_addexpr_cont(middle);
    <span>return</span> <span>new</span> <span>AddExpr</span>(lhs, rhs);
}
</pre>
</div>

<p>
Option two looks like this:
</p>

<div>
<pre><span>Expr</span> <span>parse_add_addexpr_cont</span>(<span>Expr</span> <span>first</span>) {
    expect_token(<span>TokenType</span>.PLUS);
    <span>MulExpr</span> <span>middle</span> = parse_mulexpr();
    <span>Expr</span> <span>lhs</span> = <span>new</span> <span>AddExpr</span>(first, middle);
    <span>return</span> parse_addexpr_cont(lhs);
}
</pre>
</div>

<p>
Note that the first option, which left associates, looks a lot like an LL parser, where the last thing we do is build an AST node. And the second option, which right associates, looks a lot like an LR parser, at least in the sense that we tail recurse, which is kind of like iterating. Importantly, students figured this out without hints.
</p>
</div>
</div>

<div id="outline-container-org5590e12">
<h2 id="org5590e12">Conclusion</h2>
<div id="text-org5590e12">
<p>
I taught students to parse a reasonably complicated language this way, and didn&#39;t get too much complaining. Students did struggle with grammar transformations, but they would have struggled with them anyway when I talked about grammar ambiguity. And despite building a pretty complex parser, the parser could be almost entirely derived from the grammar, with the associativity decision being the only decision they have to make at the code level.
</p>

<p>
Now, one part of Laurence&#39;s pitch that I find compelling that I&#39;m <i>not</i> making use of here is the idea that an LR parser generator is a kind of type checker for your grammar, making sure that it can be parsed unambiguously. It would be cool to build some grammar tooling for students to use, which could maybe use a standard LR parser generator under the hood to provably identify ambiguous grammars. But even in this case, I wouldn&#39;t need to actually teach the students what shift/reduce and reduce/reduce conflicts are, because those would just be translated into two productions starting with the same token. Also, I&#39;d be interested to know what the standard name for this kind of parsing is; if you&#39;ve seen it before, let me know.
</p>
</div>
</div>
</div></div>
  </body>
</html>
