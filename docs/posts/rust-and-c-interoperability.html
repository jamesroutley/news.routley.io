<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://slint-ui.com/blog/rust-and-cpp.html">Original</a>
    <h1>Rust and C&#43;&#43; Interoperability</h1>
    
    <div id="readability-page-1" class="page"><div>
        
    <p>
      <i>This blog post is based on a presentation I gave at
        <a href="https://eurorust.eu/2022/">EuroRust 2022</a> in Berlin.
        <a href="https://github.com/hunger/reveal.js/blob/eurorust_2022_cxx_and_rust/Rust%20and%20C%2B%2B.pdf">Slides</a>
        are available, as is
        <a href="https://youtu.be/WQAMJDS1tv4">the video recording</a>.</i>
    </p>

    <p>
      Here at Slint we work on an UI toolkit written in Rust. A UI toolkit is
      useful for other languages and eco-systems in addition to the one it was
      written in, so Slint comes with C++ and even Javascript APIs. Those APIs
      must of course feel fully native to developers using those languages. For
      this reason we&#39;ve a strong interest in how to provide native-feeling APIs
      to Rust code for users in the C++ world.
    </p>

    <p>
      Slint can (optionally) make use of existing C++ code to integrate into the
      different operating system environments. This includes topics like widget
      styling, accessibility, and more. This is why we also care about exposing
      existing C++ code into the Rust world.
    </p>

    <p>
        In this blog post, I want to explore both directions of integration
        between Rust and C++ and present some tools we use in Slint.
      </p>

    <p>
      If you need an open source C or C++ library in your Rust project: Have a
      look at
      <a href="https://crates.io/">crates.io</a> or
      <a href="https://lib.rs/">lib.rs</a>: Maybe somebody else has already done
      the work for you?
    </p>

    <h3>For readers with a C++ background</h3>

    <p>
      As a Rustacean I use &#34;safe&#34; in the Rust sense: Code is safe if the rust
      compiler has made sure all the properties needed to enforce memory safety
      are met. As the Rust compiler can not parse C++ code and check the
      properties there, all C++ code is unsafe by definition. This doesn&#39;t mean
      that the &#34;unsafe&#34; C++ code triggers undefined behavior or do invalid
      memory accesses, just that it <em>could</em>.
    </p>

    <p>
      You don&#39;t need to know Rust for this post, but one concept you will run
      into is Rust macros. They are different from C macros. A Rust macro is a
      function written in Rust that accepts a stream of tokens as input and
      produces a stream of tokens as output. The compiler runs this function at
      compile time whenever it encounters the macro in code, passing in the
      current stream of tokens and replacing it by the generated stream. This
      mechanism makes for powerful macros that are still &#34;hygienic&#34;: They won&#39;t
      change the meaning of code around them.
    </p>

    <h2>Language level integration</h2>

    <p>
      Let&#39;s first look at language level integration: How to make Rust call code
      written in C++ and the other way around.
    </p>

    <p>
      The Rust compiler can not understand C++ code. This makes it necessary to
      tell the Rust compiler about code you want to use on the C++ side. A bit
      of glue code is needed: Language bindings. Bindings define functions and
      data types available on the C++ side in a way that the Rust compiler can
      understand. Once a binding is available, Rust code can use those bindings
      to call code on the C++ side. The same is of course also true in the other
      direction: The C++ compiler also needs language bindings to tell it about
      code available on the Rust side.
    </p>

    <p>
      This means you can not mix and match C++ and Rust code, but need defined
      interfaces to cross from one language into the other.
    </p>

    <h3>Challenges</h3>

    <p>
      All we need to do is to generate some bindings and everything is smooth
      sailing from there on out. How hard can that be?
    </p>

    <p>There are a number of challenges:</p>

    <ul>
      <li>
        The two languages we want to map to each other do have very different
        concepts. Rust has a different macro system than C++, C++ has
        inheritance, Rust uses a system of traits instead (where these two
        concept do not map directly to each other), Rust has life-times,
        something foreign to C++. C++ templates and Rust generics address
        similar problems, but approach them differently. All these mismatches
        makes it hard to map between the two languages.
      </li>

      <li>
        Rust does not have a defined Application Binary Interface (ABI): This
        means the Rust compiler is free to change how it represents data types
        or function calls in the binary output it generates. Of course that
        makes it challenging to exchange data in binary form. The situation on
        the C++ side isn&#39;t too different: The ABI is compiler defined. This is
        why you can not mix libraries generated with MSVC and GCC. The least
        common denominator is the C foreign function interface (FFI). This
        provides a stable binary interface, but it also limits the interface to
        what can be expressed in the C programming language. Despite this
        limitation, C FFI is the backbone most inter-language communication (not
        only between Rust and C++) is build upon.
      </li>

      <li>
        Both languages have data types to express concepts like strings of text,
        but the internal representation of these data types differ. For example
        both languages offer a way to represent a dynamic sequence of elements
        of the same type stored next to each other. That&#39;s
        <code>std::vector</code> in C++ or <code>std::Vec</code> in Rust. Both
        define a vector as a pointer to some memory, a capacity and a length.
        But what type does the pointer have? How does the data pointed to need
        to be aligned in memory? What type represents capacity and length? In
        which sequence are pointer, capacity and length stored? Any mismatch in
        these or other details makes it impossible to map one language&#39;s type to
        the other language conceptually similar type.
      </li>

      <li>
        Even if the data structure happens to match: Different languages may
        have different requirements on the data stored in those data types. For
        example a string needs to be valid UTF-8 in Rust, while to C++ it&#39;s just
        a sequence of bytes - the programmer surely knows what encoding to used.
        This means it&#39;s always safe to pass a string from Rust to C++ (assuming
        all the little details about the string type in the standard libraries
        happen to match), but passing a string from C++ to Rust might trigger a
        panic.
      </li>

      <li>
        Another problem comes in the form of inlined code. This code isn&#39;t
        directly callable with just the binary. Instead it&#39;s inserted wherever
        the inlined code is used. This requires the compiler to be able to
        compile the code in question: The Rust compiler can obviously not inline
        C++ code and neither can the C++ compiler inline Rust code. This is a
        widely used technique: In C++ all templates are effectively inline code.
      </li>
    </ul>

    <p>
      All this makes it hard to generate binding to mediate between Rust and
      C++.
    </p>

    <h3>Automatic binding generation</h3>

    <p>
      In an ideal world no bindings are needed. This is not possible for the
      combination of Rust and C++, so let&#39;s look at the next best thing:
      Generating binaries automatically from existing rust files or C++ header
      files. This is what automatic binding generation is about.
    </p>

    <p>
      Even though it&#39;s hard to create good language bindings automatically, it&#39;s
      still valuable to have generators. They get you started. There are options
      for both directions: Making Rust code available to C++ as well as the
      other way around.
    </p>

    <p>
      The most widely used binding generators are <code>bindgen</code> and
      <code>cbindgen</code>.
    </p>

    <h4><code>bindgen</code></h4>

    <p>
      <a href="https://lib.rs/crates/bindgen">Bindgen</a> parses header files
      and generates Rust bindings. This works well for C code, but is not
      perfect for C++ code. By default bindgen skip any construct it can not
      generate bindings for. This way it produces as many bindings as it can.
    </p>

    <p>
      In practice bindgen needs configuration to work for any real world C++
      project. You will include and exclude types as needed, or mark types as
      opaque: This mean they can be passed to Rust from C++, and back from Rust
      to C++, but the Rust side can not interact with those types in any way.
      You might need to add C(++) helper-functions that enable access to
      functionality not to visible to bindgen by default.
    </p>

    <p>
      Typically bindgen is used to generate a low level crate (for C++ users: A
      library in a package manager) with a name ending in
      <code>-sys</code>. <code>-sys</code> crates tend to be full of
      <code>unsafe</code> calls into the C or C++ library they wrap.
    </p>
    <p>
      Since Rust is all about building safe wrappers around unsafe code, you
      typically write another crate with safe wrappers around the
      <code>-sys</code> crate, which then drops the <code>-sys</code> suffix
      from its name.
    </p>

    <p>
      Note that the process isn&#39;t unlike how C++ developers provide safe
      wrappers around C libraries. Of course the <code>-sys</code>-level is not
      needed there as C++ can just consume the C headers directly.
    </p>

    <h4><code>cbindgen</code></h4>

    <p>
      <a href="https://lib.rs/crates/cbindgen">Cbindgen</a> covers the other
      direction: It parses Rust code and generates C or C++ headers from it.
    </p>

    <p>
      Cbindgen looks at code specifically marked up by a developer as compatible
      with the C FFI interface using the <code>#[repr(C)]</code> attribute.
    </p>

    <p>
      Typically developers create a module (often called <code>ffi</code>) in
      their Rust project and collect all the <code>#[repr(C)]</code> they want
      to expose in this module. This process isn&#39;t unlike how C++ developers
      write a C-level interface to their C++ code.
    </p>

    <h4>When to use binding generators</h4>

    <p>
      Binding generators work best when you have code with a stable interface in
      one language and want to make that code available to the other language.
      Typically the code exists in the form of a library.
    </p>

    <p>
      This is how we use binding generation in Slint: We generate bindings from
      our stable Rust API. We then extend the generated code on the C++ side to
      make the code nicer to interact with from C++, (partially) hiding the
      generated code behind a hand-crafted facade.
    </p>

    <h4>How to use binding generators</h4>

    <p>
      Binding generators can be run once and have the generated bindings put
      under version control. This only works reliably though for code with very
      stable interfaces.
    </p>

    <p>
      Binding generators should generate bindings at build time. This does of
      course require integration into the build system of choice.
    </p>

    <h3>Semi-automatic binding generation</h3>

    <p>
      Semi-automatic binding generation works by having one custom piece of code
      or configuration to define an interface between two languages. This is
      then turned into a set of bindings for both Rust and C++, on top of an
      automatically generated C FFI interface hidden between the set of
      bindings.
    </p>

    <p>
      The advantage is that more abstraction on top of the C FFI interface are
      possible, making the generated bindings more comfortable to use.
    </p>

    <h4>The <code>cxx</code> crate</h4>

    <p>
      A popular option is the
      <a href="https://lib.rs/crates/cxx">cxx</a> crate. Other options exist and
      either build on top of <code>cxx</code> or offer similar functionality.
    </p>

    <p><code>cxx</code> promises safe and fast bindings.</p>

    <p>
      The safety is limited to the bindings themselves: The code called trough
      those bindings is of course still unsafe. This is a nice property, as you
      can be sure that the generated code isn&#39;t introducing problems of its own.
      You can concentrate on debugging the &#34;other side&#34; of the bindings instead
      of looking into the generated code.
    </p>

    <p>
      To ensure the bindings safety, <code>cxx</code> generates static asserts
      and checks function and type signatures.
    </p>

    <p>
      To keep the bindings fast, <code>cxx</code> makes sure there is no copy of
      data done in the binding - nor is there any conversion. This leads to
      types from one language bleeding into the other. For example a
      <code>std::string</code> on the C++ side turns into a
      <code>CxxString</code> in Rust. This makes the generated binding feel
      foreign to developers.
    </p>

    <p>
      How does this look like? You need to have a module in your Rust code that
      defines both sides of the interface. Here is an example taken from the
      documentation of <code>cxx</code>:
    </p>

    <pre>      <!-- prettier-ignore -->
      <code language="rust">
#[cxx::bridge]
mod ffi {
    struct Metadata {
        size: usize,
        tags: Vec&lt;String&gt;,
    }

    extern &#34;Rust&#34; {
        type MultiBuf;

        fn next_chunk(buf: &amp;mut MultiBuf) -&gt; &amp;[u8];
    }

    unsafe extern &#34;C++&#34; {
        include!(&#34;demo/include/blob_store.h&#34;);

        type Client;

        fn new_client() -&gt; UniquePtr&lt;Client&gt;;
        fn put(&amp;self, parts: &amp;mut MultiBuf) -&gt; u64;
    }
}
      </code>
    </pre>

    <ol>
      <li>
        You need to mark the module with <code>#[cxx::bridge]</code>. This
        triggers a Rust macro to process this code. Inside the module (called
        <code>ffi</code> in this case), data types available to both C++ and
        Rust get defined.
      </li>

      <li>
        A <code>extern &#34;Rust&#34;</code> section is next. This lists types and
        functions defined on the Rust side that should be exposed to C++.
        <code>cxx</code> notices that the first argument to
        <code>next_chunk</code> is a mutable reference to the
        <code>MultiBuf</code> data type. It models <code>MultiBuf</code> as a
        class on the C++ side and makes <code>next_chunk</code> a member of that
        class.
      </li>

      <li>
        A <code>unsafe extern &#34;C++&#34;</code> section defines data types and
        functions available on the C++ side, which should be usable from Rust.
        <code>cxx</code> looks for information relevant to Rust here: You need
        to express life time information as well as whether a function is safe
        to call or not. In this case both <code>new_client</code> and
        <code>put</code> are safe. This information is relevant for the Rust
        side but has no effect on the C++ code that gets wrapped.
      </li>
    </ol>

    <h4>When to use <code>cxx</code>?</h4>

    <p>
      It work best when you can control both sides of the API. For example when
      you want to factor out some code from an existing C++ implementation into
      new library written in Rust. <code>cxx</code> is ideal here since defines
      a matching set of bindings and the C FFI interface between them in one go.
    </p>

    <h3>Don&#39;t generate bindings</h3>

    <p>
      A third option is to use the
      <a href="https://lib.rs/crates/cpp">cpp</a> crate in Rust to write C++
      code inline. Let&#39;s look at a (shortened) Rust member function
      <code>notify</code>, taken from Slint source code:
    </p>

    <pre>      <!-- prettier-ignore -->
      <code language="rust">
fn notify(&amp;self) {
  let obj = self.obj;
  cpp!(unsafe [obj as &#34;Object*&#34;] {
    auto data = queryInterface(obj)-&gt;data();
    rust!(rearm [data: Pin&lt;&amp;A18yItemData&gt; as &#34;void*&#34;] {
      data.arm_state_tracker();
    });
    updateA18y(Event(obj));
  });
}
      </code>
    </pre>

    <p>
      When I first saw this in Rust code, it blew my mind. What does this piece
      of code do?
    </p>

    <ol>
      <li>
        A local variable <code>obj</code>, holding a reference to a member
        variable <code>obj</code> (of type <code>&amp;c_void</code>) is created.
      </li>

      <li>
        The <code>cpp!</code> macro (all callable macros in Rust end in `!`)
        processes all the code till the closing parenthesis at the end of the
        <code>notify</code> function.

        <p>
          This macro implicitly declares an <code>unsafe</code> C++ function
          returning <code>void</code>, which takes one argument called
          <code>obj</code> of type <code>Object*</code>. The macro expect
          <code>obj</code> to be defined in the surrounding Rust code. The body
          of this C++ function is the code between the curly braces.
        </p>
      </li>

      <li>
        While in the C++ world, we interact with <code>obj</code> to extract
        some information which we then store into a local variable
        <code>data</code>. This <code>data</code> is of course only visible
        inside the C++ function we just have defined implicitly. The surrounding
        Rust code can not see it.
      </li>

      <li>
        In the next line we use the <code>rust!</code> (pseudo-)macro. This
        switches back into the Rust language.
      </li>

      <li>
        This <code>rust!</code> macro creates another (rust) function called
        <code>rearm</code>, which will take a argument <code>data</code> of type
        <code>Pin&lt;A18yItemData&gt;</code>. This argument must exist in the
        surrounding C++ code and we expect it to have a type of
        <code>void*</code> there. We need to give type definitions for both C++
        and Rust here as the <code>cpp</code> crate can unfortunately not find
        the type on the C++ side. The body of that Rust function will contain
        <code>data.arm_state_tracker();</code> and will return
        <code>void</code>. It will also create the necessary bindings to call
        the new <code>rearm</code> function from C++. Once the
        <code>rust!</code> pseudo-macro has generated this code, it will replace
        itself with C++ code calling the <code>rearm</code> function through the
        generated C++ bindings.
      </li>

      <li>
        Back in the C++ function created by the <code>cpp</code>, we call have
        some more C++ code <code>updateA11y(Event(obj));</code> and reach the
        end of the body of the implicitly created C++ function. Once the
        <code>cpp</code> macro has generated all its code, it replaces itself
        with a call to the C++ function it generated via the Rust binding it
        created for it.
      </li>
    </ol>

    <p>
      After all the macros are expanded, we have two new functions generated,
      including the necessary bindings to call them. The final
      <code>notify</code> function seen by the Rust compiler is just the
      definition of the <code>obj</code> variable followed by a call to some
      binding taking this <code>obj</code> as argument.
    </p>

    <p>
      This approach doesn&#39;t avoid the generation of bindings, so the title of
      this section is misleading. It handles a big part of the binding
      generation implicitly. Of course you still need to generate bindings for
      data types you want to access in both Rust and C++. The
      <code>cpp</code> crate has more macros to help with that.
    </p>

    <h4>How does this work?</h4>

    <p>
      The macros shipped by the <code>cpp</code> crate do generate all the code.
      You do need build system integration to build and link the generated C++
      code.
    </p>

    <h4>When to use the <code>cpp</code> crate?</h4>

    <p>
      In Slint we use the cpp crate to interact with C++ GUI toolkits that have
      a stable API. It works great for this use case.
    </p>

    <h3>Summary</h3>

    <p>
      You have a wide range of options to integrate C++ and Rust code, but you
      always need to generate language bindings. This indirection avoids a tight
      coupling between the languages and opens up more design spaces for Rust to
      explore, but it also makes a seamless integration of Rust and C++
      impossible.
    </p>

    <h2>Build system integration</h2>

    <p>
      Once you have a project that combines Rust and C++ code, you need to build
      both the Rust and the C++ parts, and merge both together into one
      consistent binary. Let&#39;s take a short look at what&#39;s necessary to build a
      cross-language project.
    </p>

    <p>
      <a href="https://doc.rust-lang.org/cargo/index.html"><code>cargo</code></a>, the official Rust build system, is the only supported way to build Rust
      code. You have a build system for your C++ code. Typically that build
      system isn&#39;t trivial, don&#39;t try to reimplement it in <code>cargo</code>.
      Integrate the two build systems with each other instead.
    </p>

    <p>Let&#39;s start by looking at Cargo</p>

    <h3>Cargo</h3>

    <p>
      Having Cargo as the main build tool driving your project build is great if
      you have a little C++ code in a bigger Rust context. The typical use cases
      is generating bindings around C and C++ code.
    </p>

    <p>
      Cargo can run arbitrary code at build time. It looks for a file called
      <a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html"><code>build.rs</code></a>
      next to the <code>Cargo.toml</code> file. If a
      <code>build.rs</code>
      file exists, cargo builds and executes this file in the build process. The
      build.rs file can inform the rest of the build process by printing
      instructions to cargo on stdout. Check the cargo documentation for
      details.
    </p>

    <p>
      <code>build.rs</code> is a normal Rust code and may use any crate
      specified as a <code>build-dependency</code> in the
      <code>Cargo.toml</code> file!
    </p>

    <p>
      When working with C and C++ code the
      <a href="https://lib.rs/crates/cc">cc</a> crate is interesting. It allows
      to drive a C or C++ compiler from within <code>build.rs</code>. This is
      ideal to build a few simple files. For bigger C or C++ projects you
      probably want to run the projects build system directly. The
      <a href="https://lib.rs/crates/cmake">cmake</a> crate comes in handy here.
      It drives the typical CMake configure, build, install workflow and exposes
      the CMake build targets to cargo afterwards.
    </p>
    <p>
      Other build systems have similar support crates or can be driven via a
      lower level crates to run arbitrary commands like
      <a href="https://lib.rs/crates/xshell">xshell</a>.
    </p>

    <h3>CMake</h3>

    <p>
      I use <a href="https://cmake.org/">CMake</a> as one example of a build
      system widely used for C and C++ projects. Similar support is available
      for other build tools, some even claim to support Rust natively -- often
      by running the rust compiler directly (unsupported by Rust!).
    </p>

    <p>
      Using the existing C++ build system to drive the entire build is ideal
      when you have a little Rust code in a bigger C++ project. A typical use
      case is replacing some small part of a project with code written in Rust
      or using a Rust library.
    </p>

    <p>
      The
      <a href="https://github.com/corrosion-rs/corrosion"><code>corrosion</code></a>
      projects provides cargo integration into CMake. A simple
      <code>CMakeLists.txt</code> file building a Rust example library and
      linking to it would look like this:
    </p>

    <pre>      <!-- prettier-ignore -->
      <code>
cmake_minimum_required(VERSION 3.15)
project(MyCoolProject LANGUAGES CXX)

find_package(Corrosion REQUIRED)

corrosion_import_crate(MANIFEST_PATH rust-lib/Cargo.toml)

add_executable(cpp-exe main.cpp)
target_link_libraries(cpp-exe PUBLIC rust-lib)
      </code>
    </pre>

    <ol>
      <li>
        You start out with the usual two lines in any CMake project, defining
        the minimum CMake version required to build the project followed by the
        project name and the programming languages CMake needs to build. Note
        that you don&#39;t mention Rust there.
      </li>

      <li>
        The <code>find_package(Corrosion REQUIRED)</code> line asks CMake to
        include the Corrosion support and fail if it isn&#39;t found. You could also
        use <code>FetchContent</code> to download Corrosion as part of your
        build instead.
      </li>

      <li>
        Now that corrosion is available, you can ask it to build Rust code using
        <code>corrosion_import_crate</code>, pointing it to an existing
        <code>Cargo.toml</code> file. Corrosion builds this Rust project and
        exposes all build targets to CMake.
      </li>

      <li>
        The last two lines in the example build a C++ binary file and link it to
        the Rust code.
      </li>
    </ol>

    <p>
      Slint uses the Corrosion project to enable C++ developers to use the Slint
      library in C++ code without having to bother with Rust too much.
    </p>

    <p>
      I hope this gives you a good starting place for your project integrating
      C++ and Rust code - or at you found some option you weren&#39;t aware of
      before. Please feel free to reach out with questions in the
      <a href="https://github.com/slint-ui/slint/discussions/1847">discussion on github</a>.
    </p>
  
    </div></div>
  </body>
</html>
