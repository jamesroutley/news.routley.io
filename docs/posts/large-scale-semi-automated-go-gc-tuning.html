<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://eng.uber.com/how-we-saved-70k-cores-across-30-mission-critical-services/">Original</a>
    <h1>Large-scale, semi-automated Go GC tuning</h1>
    
    <div id="readability-page-1" class="page"><div>
            <!-- image -->
                                <p><img src="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/2BA497C1-858B-48AC-8954-9D5DA98549A1.jpeg" alt="How We Saved 70K Cores Across 30 Mission-Critical Services (Large-Scale, Semi-Automated Go GC Tuning @Uber)" title="How We Saved 70K Cores Across 30 Mission-Critical Services (Large-Scale, Semi-Automated Go GC Tuning @Uber)"/>
                                            </p>
            
            
<p><span>As part of Uber engineering’s wide efforts to reach profitability, recently our team was focused on reducing cost of compute capacity by improving efficiency. Some of the most impactful work was around GOGC optimization. In this blog we want to share our experience with a highly effective, low-risk, large-scale, semi-automated Go GC tuning mechanism.</span></p>
<p><span>Uber’s tech stack is composed of thousands of microservices, backed by a cloud-native, scheduler-based infrastructure. Most of these services are written in Go. Our team, Maps Production Engineering, has previously played an instrumental role in significantly improving the efficiency of multiple Java services by tuning GC. At the beginning of 2021, we explored the possibilities of having a similar impact on Go-based services. We ran several CPU profiles to assess the current state of affairs and we found that GC was the top CPU consumer for a vast majority of mission-critical services. Here is a representation of some CPU profiles where GC (identified by the <span>runtime.scanobject</span> method) is consuming a significant portion of allocated compute resources.</span></p>

<h4><b>Service #1</b></h4>
<figure id="attachment_9243" aria-describedby="caption-attachment-9243"><img loading="lazy" src="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_1-128x300.png" alt="" width="127" height="299" srcset="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_1-128x300.png 128w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_1-179x420.png 179w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_1.png 222w" sizes="(max-width: 127px) 100vw, 127px"/><figcaption id="caption-attachment-9243">Figure 1: GC CPU cost of Example Service #1</figcaption></figure>

<h4><b>Service #2</b></h4>
<figure id="attachment_9244" aria-describedby="caption-attachment-9244"><img loading="lazy" src="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_2-127x300.png" alt="" width="127" height="300" srcset="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_2-127x300.png 127w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_2-177x420.png 177w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_2.png 232w" sizes="(max-width: 127px) 100vw, 127px"/><figcaption id="caption-attachment-9244">Figure 2: GC CPU cost of Example Service #1</figcaption></figure>

<p><span>Emboldened by this finding, we commenced to tune GC for the relevant services. To our delight, Go’s GC implementation and the simplicity of tuning allowed us to automate the bulk of the detection and tuning mechanism. We detail our approach and its impact in the following sections.</span></p>

<h2><span>GOGC Tuner </span></h2>
<p><span>Go runtime invokes a concurrent garbage collector at periodic intervals unless there is a triggering event before it. The triggering events are based on memory back pressure. Due to this, GC-impacted Go services benefit from more memory, since it reduces the times GC has to run. In addition, we realized that our host-level CPU to memory ratio is 1:5 (1 core : 5 GB RAM), while most Golang services were configured with a 1:1 to 1:2 ratio. Therefore, we were confident that we could leverage using more memory to reduce GC CPU impact. This is a service-agnostic mechanism that can yield a large impact when applied judiciously.</span></p>
<p><span>Delving deep into Go’s garbage collection is beyond the scope of this article, but here are the relevant bits for this work: Garbage collection in Go is concurrent and involves analyzing all objects to identify which ones are still reachable. We would call the reachable objects the “live dataset.” Go offers only one knob, </span><i><span>GOGC,</span></i> <span>expressed in percentage of live dataset, to control garbage collection. The </span><i><span>GOGC</span></i><span> value acts as a multiplier for the dataset. The default value of </span><i><span>GOGC</span></i><span> is 100%, which means Go runtime will reserve the same amount of memory for new allocations as the live dataset. For instance:</span></p>
<p><span>hard_target = live_dataset + live_dataset * (GOGC / 100).</span></p>
<p><span>Then the </span><i><span>pacer</span></i><span> is in charge of predicting when it is the best time to trigger GC to avoid hitting the hard target (soft target).</span></p>
<figure id="attachment_9245" aria-describedby="caption-attachment-9245"><img loading="lazy" src="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_3-270x300.png" alt="" width="270" height="300" srcset="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_3-270x300.png 270w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_3-378x420.png 378w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_3.png 450w" sizes="(max-width: 270px) 100vw, 270px"/><figcaption id="caption-attachment-9245">Figure 3: Example heap with default configuration.</figcaption></figure>


<h2><span>Dynamic and Diverse: One Size Does Not Fit All</span></h2>
<p><span>We identified that a fixed GOGC value-based tuning is not suitable for services at Uber. Some of the challenges are:</span></p>
<ul>
<li aria-level="1"><span>It is not aware of the maximum memory assigned to the container and can cause out of memory issues.</span></li>
<li aria-level="1"><span>Our microservices have a significantly diverse memory utilization portfolio. For example, a sharded system can have very different live datasets. We experienced this in one of our services where the p99 utilization was 1G but the p1 was 100MB, therefore the 100MB instances were having a huge GC impact.</span></li>
</ul>

<h2><span>A Case for Automation</span></h2>
<p><span>The pain points previously presented are the reason for the conception of GOGCTuner. GOGCTuner is a library which simplifies the process of tuning garbage collection for service owners and adds a reliability layer on top of it.</span></p>
<p><span>GOGCTuner dynamically computes the correct GOGC value in accordance with the container’s memory limit (or the upper limit from the service owner) and sets it using Go’s runtime API. Following are the specifics of the GOGCTuner library’s features:</span></p>
<ul>
<li aria-level="1"><span>Simplified configuration for easier reasoning and deterministic calculations. GOGC at 100% is not clear for beginner Go developers and it is not deterministic, because it still depends on the live dataset. On the other hand a 70% limit ensures that the service is always going to use 70% of the heap space.</span></li>
<li aria-level="1"><span>Protection against OOMs (Out Of Memory): The library reads the memory limit from the cgroup and uses a default hard limit of 70%, a safe value from our experience.</span>
<ul>
<li>
<ul>
<li>
<ul>
<li aria-level="2"><span>It is important to note that there is a limit to this protection. The tuner can only adjust the buffer allocation, so if your service live objects are higher than the limit the tuner would set a default lower limit of 1.25X your live objects utilization.</span></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li aria-level="1"><span>Allow higher GOGC values for corner cases like:</span>
<ul>
<li>
<ul>
<li>
<ul>
<li aria-level="2"><span>As we mentioned above, manual GOGC is not deterministic. We are still relying on the size of the live dataset. What if live_dataset doubles our last peak value? GOGCTuner would enforce the same memory limit at the cost of more CPU. Manual tuning instead could cause OOMs. Therefore, service owners used to give plenty of buffer for these types of scenarios. See the example below:</span></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

<h4><strong>Normal traffic (live dataset is 150M)</strong></h4>
<figure id="attachment_9246" aria-describedby="caption-attachment-9246"><a href="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_4.png"><img loading="lazy" src="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_4-300x165.png" alt="" width="300" height="165" srcset="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_4-300x165.png 300w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_4-1024x564.png 1024w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_4-768x423.png 768w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_4-696x385.png 696w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_4-1068x589.png 1068w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_4-762x420.png 762w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_4.png 1484w" sizes="(max-width: 300px) 100vw, 300px"/></a><figcaption id="caption-attachment-9246">Figure 4: Normal operation. Default configuration on the left, manually tuned on the right.</figcaption></figure>

<h4><strong>Traffic increased 2X (live dataset is 300M)</strong></h4>
<figure id="attachment_9247" aria-describedby="caption-attachment-9247"><a href="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_5.png"><img loading="lazy" src="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_5-300x206.png" alt="" width="300" height="206" srcset="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_5-300x206.png 300w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_5-1024x705.png 1024w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_5-768x528.png 768w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_5-218x150.png 218w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_5-696x479.png 696w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_5-610x420.png 610w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_5-100x70.png 100w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_5.png 1058w" sizes="(max-width: 300px) 100vw, 300px"/></a><figcaption id="caption-attachment-9247">Figure 5: Double the load. Default configuration on the left, manually tuned on the right.</figcaption></figure>

<h4><strong>Traffic increased 2X with GOGCTuner at 70% (live dataset is 300M)</strong></h4>
<figure id="attachment_9248" aria-describedby="caption-attachment-9248"><a href="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_6.png"><img loading="lazy" src="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_6-300x169.png" alt="" width="300" height="169" srcset="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_6-300x169.png 300w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_6-1024x578.png 1024w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_6-768x433.png 768w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_6-696x393.png 696w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_6-1068x603.png 1068w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_6-744x420.png 744w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_6.png 1304w" sizes="(max-width: 300px) 100vw, 300px"/></a><figcaption id="caption-attachment-9248">Figure 6: Double the load, but using the tuner. Default configuration on the left, GOGCTuner tuned on the right.</figcaption></figure>

<ul>
<li aria-level="2"><span>Services using </span><a href="https://man7.org/linux/man-pages/man2/madvise.2.html"><span>MADV_FREE</span></a><span> memory policy that results in wrong memory metrics. For instance, our observability metrics were showing 50% memory utilization (when it actually had already released 20% of that 50%). Then service owners were only tuning GOGC using this “inaccurate” metric.</span></li>
</ul>

<h2><span>Observability</span></h2>
<p><span>We found that we lacked some critical metrics which would give us more insights into garbage collection of each service.</span></p>
<ul>
<li aria-level="2"><i><span>Intervals between garbage collections</span></i><span>: useful to know if we can still tune. For instance, Go forces a garbage collection every 2 minutes. If your service is still having high GC impact, but you already see 120s for this graph, it means that you can no longer tune using GOGC. In this case you would need to optimize your allocations.</span></li>
</ul>

<figure id="attachment_9250" aria-describedby="caption-attachment-9250"><a href="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_7.png"><img loading="lazy" src="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_7-1024x297.png" alt="" width="696" height="202" srcset="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_7-1024x297.png 1024w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_7-300x87.png 300w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_7-768x223.png 768w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_7-1536x445.png 1536w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_7-696x202.png 696w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_7-1068x310.png 1068w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_7-1448x420.png 1448w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_7.png 1676w" sizes="(max-width: 696px) 100vw, 696px"/></a><figcaption id="caption-attachment-9250">Figure 7: Graph for intervals between GCs.</figcaption></figure>

<ul>
<li aria-level="2"><i><span>GC CPU impact</span></i><span>: allows us to know which services are the most affected by GC.</span></li>
</ul>

<figure id="attachment_9251" aria-describedby="caption-attachment-9251"><a href="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_8.png"><img loading="lazy" src="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_8-1024x290.png" alt="" width="696" height="197" srcset="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_8-1024x290.png 1024w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_8-300x85.png 300w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_8-768x218.png 768w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_8-1536x435.png 1536w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_8-696x197.png 696w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_8-1068x303.png 1068w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_8-1482x420.png 1482w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_8.png 1666w" sizes="(max-width: 696px) 100vw, 696px"/></a><figcaption id="caption-attachment-9251">Figure 8: Graph for p99 GC CPU cost.</figcaption></figure>

<ul>
<li aria-level="2"><i><span>Live dataset size</span></i><span>: helps us to identify memory leaks. The concern noted by service owners was that they saw an increase in memory utilization. In order to show them there was no memory leak we added the “live usage” metric, which showed a steady utilization.</span></li>
</ul>

<figure id="attachment_9252" aria-describedby="caption-attachment-9252"><a href="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_9.png"><img loading="lazy" src="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_9-1024x297.png" alt="" width="696" height="202" srcset="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_9-1024x297.png 1024w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_9-300x87.png 300w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_9-768x222.png 768w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_9-1536x445.png 1536w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_9-696x202.png 696w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_9-1068x309.png 1068w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_9-1450x420.png 1450w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_9.png 1692w" sizes="(max-width: 696px) 100vw, 696px"/></a><figcaption id="caption-attachment-9252">Figure 9: Graph for estimated p99 live dataset.</figcaption></figure>

<ul>
<li aria-level="2"><i><span>GOGC value</span></i><span>: useful to know how the tuner is reacting.</span></li>
</ul>

<figure id="attachment_9253" aria-describedby="caption-attachment-9253"><a href="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_10.png"><img loading="lazy" src="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_10-1024x316.png" alt="" width="696" height="215" srcset="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_10-1024x316.png 1024w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_10-300x93.png 300w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_10-768x237.png 768w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_10-1536x474.png 1536w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_10-696x215.png 696w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_10-1068x330.png 1068w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_10-1360x420.png 1360w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_10.png 1690w" sizes="(max-width: 696px) 100vw, 696px"/></a><figcaption id="caption-attachment-9253">Figure 10: Graph for min, p50, p99 GOGC value assigned to the application by the tuner.</figcaption></figure>


<h2><span>Implementation</span></h2>
<p><span>Our initial approach was to have a ticker to run every second to monitor the heap metrics, and then adjust GOGC value accordingly. The disadvantage of this approach is that the overhead starts to become considerable, because in order to read heap metrics Go needs to do a STW (</span><a href="https://golang.org/pkg/runtime/#ReadMemStats"><span>ReadMemStats</span></a><span>) and it is somewhat inaccurate, because we can have more than one garbage collection per second.</span></p>
<p><span>Luckily we were able to find a good alternative. Go has finalizers (</span><a href="https://golang.org/pkg/runtime/#SetFinalizer"><span>SetFinalizer</span></a><span>), which are functions that run when the object is going to be garbage collected. They are mainly useful for cleaning memory in C code or some other resources. We were able to employ a self-referencing finalizer that resets itself on every GC invocation. This allows us to reduce any CPU overhead. For instance:</span></p>
<figure id="attachment_9254" aria-describedby="caption-attachment-9254"><a href="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_11.png"><img loading="lazy" src="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_11.png" alt="" width="489" height="485" srcset="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_11.png 1022w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_11-300x298.png 300w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_11-150x150.png 150w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_11-768x762.png 768w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_11-696x691.png 696w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_11-423x420.png 423w" sizes="(max-width: 489px) 100vw, 489px"/></a><figcaption id="caption-attachment-9254">Figure 11: Example code for GC triggered events.</figcaption></figure>

<p><span>Calling </span><span><span>runtime</span><span>.</span><span>SetFinalizer</span></span><span>(</span><span>f</span><span>,</span> <span>finalizerHandler</span><span>)</span><span> inside of </span><span>finalizerHandler</span><span> is what allows the handler to run on every GC; it is basically not letting the reference die, since it is not a costly resource to keep alive (it is just a pointer).</span></p>

<h2><span>Impact</span></h2>
<p><span>After deploying GOGCTuner across a few dozen of our services, we dove deep on a few that showed significant, double-digit improvement in their CPU utilization. Accumulated cost savings from these services alone are around 70K cores. Following are 2 such examples:</span></p>

<figure id="attachment_9255" aria-describedby="caption-attachment-9255"><a href="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_12.png"><img loading="lazy" src="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_12-1024x327.png" alt="" width="696" height="222" srcset="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_12-1024x327.png 1024w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_12-300x96.png 300w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_12-768x246.png 768w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_12-1536x491.png 1536w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_12-2048x655.png 2048w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_12-696x223.png 696w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_12-1068x341.png 1068w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_12-1920x614.png 1920w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_12-1314x420.png 1314w" sizes="(max-width: 696px) 100vw, 696px"/></a><figcaption id="caption-attachment-9255">Figure 12: Observability service that operates on thousands of compute cores with high standard deviation for live_dataset (max value was 10X of the lowest value), showed ~65% reduction in p99 CPU utilization.</figcaption></figure>


<figure id="attachment_9256" aria-describedby="caption-attachment-9256"><a href="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_13.png"><img loading="lazy" src="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_13-1024x329.png" alt="" width="696" height="224" srcset="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_13-1024x329.png 1024w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_13-300x96.png 300w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_13-768x247.png 768w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_13-1536x493.png 1536w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_13-2048x658.png 2048w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_13-696x224.png 696w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_13-1068x343.png 1068w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_13-1920x617.png 1920w, https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2021/12/Figure_13-1307x420.png 1307w" sizes="(max-width: 696px) 100vw, 696px"/></a><figcaption id="caption-attachment-9256">Figure 13: Mission critical Uber eats service that operates on thousands of compute cores, showed ~30% reduction in p99 CPU utilization.</figcaption></figure>

<p><span>The resulting CPU utilization reduction improves p99 latency (and associated SLA, user experience) tactically, and cost of capacity strategically (since services are scaled based on their utilization). </span></p>


<p><span>Garbage collection is one of the most elusive and underestimated performance influencers of an application. Go’s robust GC mechanism and simplified tuning, our diverse, large-scale Go services footprint, and a robust internal platform (Go, compute, observability) collectively allowed us to make such a large-scale impact. We expect to continue improving how we tune GC as the problem space itself is evolving, due to changes in the tech and our competency.</span></p>
<p><span>To reiterate what we mentioned at the introduction: there is no one size fits all solution. We feel GC performance will remain variable in cloud-native setup due to the highly variable performance of both public clouds and containerized workloads that run within. Coupled with the fact that a vast majority of CNCF landscape projects that we use are written in Golang (Kubernetes, Prometheus, Jaeger, etc.), this means any large-scale deployment outside could also benefit from such effort.</span></p>
        </div></div>
  </body>
</html>
