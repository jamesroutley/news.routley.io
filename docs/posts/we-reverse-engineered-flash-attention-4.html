<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://modal.com/blog/reverse-engineer-flash-attention-4">Original</a>
    <h1>We reverse-engineered Flash Attention 4</h1>
    
    <div id="readability-page-1" class="page"><div><!----><article><!----><p>One month ago at <a rel="nofollow" href="https://hotchips.org/"><!----><!---->Hot Chips<!----></a><!---->, Tri Dao presented preliminary results on Flash Attention 4, the latest addition to the <a rel="nofollow" href="https://github.com/Dao-AILab/flash-attention"><!----><!---->Flash Attention series of CUDA kernels<!----></a><!---->. These kernels are used in the attention layers of Transformer neural networks. Along with more standard matrix multiplications, these calculations are the primary bottlenecks in contemporary generative AI workloads. Billions of dollars and gigawatts of power are being expended on GPUs to run more of these calculations faster. And Flash Attention 4 is the way to run lots of them as fast as possible. This blog post explains how it works.</p> <p>The new FA4 kernel is optimized for Nvidia’s new <a rel="nofollow" href="https://modal.com/blog/introducing-b200-h200"><!----><!---->Blackwell Streaming Multiprocessor architecture<!----></a><!----> and achieves a reported ~20% speedup over the previous state-of-the-art, the attention kernels in Nvidia’s <a rel="nofollow" href="https://modal.com/gpu-glossary/host-software/cudnn"><!----><code>cudnn</code><!----></a><!----> library.</p> <p><img src="https://modal-cdn.com/blog/images/fa4-vs-cudnn-results-slide.jpg" alt="A chart depicting the ~20% performance improvement of Flash Attention 4 over cudnn attention kernels."/> <!--[!--><!--]--><!----></p> <p><code>cudnn</code> kernels are closed source, so Jensen only knows what’s going on in there.</p> <p>There’s also no official technical report on how FA4 works yet. But the source code for Flash Attention 4 was already released online <a rel="nofollow" href="https://github.com/Dao-AILab/flash-attention/blob/5c1627a7a1cda9c32cb9b937a053564e663f81bc/flash_attn/cute/flash_fwd_sm100.py"><!----><!---->here<!----></a><!---->. We’ve <a rel="nofollow" href="https://github.com/sgl-project/sglang/pull/9588"><!----><!---->recently<!----></a><!----> been contributing to open source LLM inference engines, so we read the code and reverse-engineered how the kernel works, including two math tricks (faster approximate exponentials and a more efficient online softmax) that are classic Dao. This write-up contains our findings.</p> <p>Perhaps surprisingly, the architecture of FA4 is readily understandable by a general software engineering audience.</p> <p>That’s because the biggest change in FA4 isn’t the (very cool) math — it’s a massive increase in the complexity of its asynchronous “pipeline” of operations. This kind of asynchronous programming is fairly new in the world of CUDA, but <a rel="nofollow" href="https://assets.bitbashing.io/images/cubedrone-103.png"><!----><!---->pipes have been in Unix for like 40 goddamn years<!----></a><!---->. A programmer who has experience with parallel and concurrent programs, like high performance databases and web servers, will feel right at home (absent some novel <a rel="nofollow" href="https://modal.com/gpu-glossary/readme"><!----><!---->GPU technical vocabulary<!----></a><!---->).</p> <p>So we organize our write-up into two parts.</p> <p>The first section, a “quick tour”, covers the architecture of FA4 by tracing what happens as a block of inputs is turned into a block of outputs. It is written to be understandable by a practicing software engineer without any CUDA programming experience. We give brief explanations of CUDA concepts and hardware, like <a rel="nofollow" href="https://modal.com/gpu-glossary/device-software/warp"><!----><!---->warps<!----></a><!----> and <a rel="nofollow" href="https://modal.com/gpu-glossary/device-hardware/warp-scheduler"><!----><!---->warp schedulers<!----></a><!---->, but defer detailed explanation to our <a rel="nofollow" href="https://modal.com/gpu-glossary/readme"><!----><!---->GPU Glossary<!----></a><!----> (linked throughout).</p> <p>The second section, a “deep dive”, walks through each of the subcomponents in turn, explaining what each does, supported by links to the source code for particularly intrepid spelunkers.</p> <h2 id="a-quick-tour-of-flash-attention-4-the-life-of-a-tile">A quick tour of Flash Attention 4: The “Life of a Tile”</h2> <p>We start with <a rel="nofollow" href="https://float.exposed/b0x3a0a"><!----><!---->bf16<!----></a><!----> tensors of queries, keys, and values in <a rel="nofollow" href="https://modal.com/gpu-glossary/device-software/global-memory"><!----><!---->global memory<!----></a><!----> (aka <a rel="nofollow" href="https://modal.com/gpu-glossary/device-hardware/gpu-ram"><!----><!---->GPU RAM<!----></a><!---->). We’re aiming to produce a tensor of bf16 outputs, also in global memory. Outputs are values weighted by the similarity of queries to keys. Computing this weighting requires matrix multiplication, exponentiation, and normalization.</p> <p>Like the good engineers we are, we tackle this very big problem by breaking it down into smaller pieces. That’s fairly literal in this case: we take our very large input tensor and split it up into “tiles” of adjacent rows and columns, each of which contribute to the calculation of one tile of outputs.</p> <p>Specifically, one running instance of our kernel program (namely, one <a rel="nofollow" href="https://modal.com/gpu-glossary/device-software/cooperative-thread-array"><!----><!---->“cooperative thread array”<!----></a><!----> of threads) produces two tiles of the outputs tensor by reading two tiles of the queries tensor. In between, it streams all of the keys &amp; values for each query tile. Keys and values are also read in tiles. If you’re a database ‘head, you might think of it as a vectorized sequential scan for a batch of aggregation queries against a key-value store.</p> <p><img src="https://modal-cdn.com/blog/images/fa4-streaming-tiles.jpg" alt="A diagram showing a tile of queries combining with a stream of key and value tiles to produce an output tile."/> <!--[!--><!--]--><!----></p> <p>By running this tile-level program many times concurrently (typically, massively in parallel), we produce the entire outputs tensor. This is a <a rel="nofollow" href="https://modal.com/gpu-glossary/device-software/kernel"><!----><!---->“single program, multiple data” execution model<!----></a><!---->, where each datum is a pair of tiles. This kind of concurrency <em>across</em> program instances is the bread-and-butter of the <a rel="nofollow" href="https://modal.com/gpu-glossary/device-software/cuda-programming-model"><!----><!---->CUDA programming model<!----></a><!----> and is transparently handled for the programmer by the <a rel="nofollow" href="https://modal.com/gpu-glossary/host-software/cuda-software-platform"><!----><!---->CUDA runtime<!----></a><!---->.</p> <p>But with the fastest contemporary kernels, like Flash Attention 3 &amp; 4 and all state-of-the-art matrix multiplications, there is also concurrency <em>within</em> our program. Each program instance sets up an asynchronous pipeline of operations that together effect the tile-level computation depicted above. We write our kernel such that all of our pipeline steps can run as concurrently as possible as we process a tile. In Flash Attention 4, we achieve this by mapping chunks of our pipeline onto 32-thread groups called <a rel="nofollow" href="https://modal.com/gpu-glossary/device-software/warp"><!----><em>warps</em><!----></a><!----> (a technique called <em>warp specialization</em>).</p> <p>We then rely on the <a rel="nofollow" href="https://modal.com/gpu-glossary/device-hardware/warp-scheduler"><!----><!---->warp schedulers<!----></a><!----> to switch between pipeline steps within program instances on each clock, swapping out when a step stalls and swapping back in when a step’s next input is ready. Think <a rel="nofollow" href="https://blog.codingconfessions.com/p/simultaneous-multithreading"><!----><!---->simultaneous multithreading<!----></a><!---->/“hyperthreading” from CPUs, but on steroids. The diagram below, from our <a rel="nofollow" href="https://modal.com/gpu-glossary/perf"><!----><!---->GPU Performance Glossary<!----></a><!---->, depicts four cycles across four parallel slots, for a total of sixteen <a rel="nofollow" href="https://modal.com/gpu-glossary/perf/issue-efficiency"><!----><!---->execution slots<!----></a><!---->, fifteen of which are filled with warps actively executing instructions thanks to this rapid warp switching. See the <a rel="nofollow" href="https://modal.com/gpu-glossary/perf/warp-execution-state"><!----><!---->associated article<!----></a><!----> for details.</p> <p><img src="https://modal-cdn.com/gpu-glossary/terminal-cycles.svg" alt="A diagram depicting sixteen execution slots. Fifteen of them are colored in, indicating that they are filled with an active warp."/> <!--[!--><!--]--><!----></p> <p>This execution model is “dual” to <a rel="nofollow" href="https://ibraheem.ca/posts/too-many-web-servers/"><!----><!---->the way that an asynchronous program for CPUs works<!----></a><!----> in the following sense. In an async CPU program, a single thread implements the entire journey of a single datum (e.g. request) through a state machine (e.g. Reading, Parsing, Writing), switching between transitions as data become ready. In an async GPU program like FA4, a single warp implements a single <em>transition</em> (e.g. from queries and values to attention scores) in a similar state machine.</p> <p><img src="https://modal-cdn.com/blog/images/fa4-cpu-async-vs-gpu-async.jpg" alt="cpu-async-vs-gpu-async.drawio.png"/> <!--[!--><!--]--><!----></p> <p>The pipeline is organized with a producer/consumer model and uses barriers for synchronization.</p> <p>Unlike the concurrency across program instances, the internal pipeline concurrency is all implemented manually. This leads to quite gnar code — though the control flow will look familiar to anyone who has <a rel="nofollow" href="https://os.phil-opp.com/async-await/"><!----><!---->written their own event loop<!----></a><!---->.</p> <p>So like most async code, the FA4 kernel is best understood by tracing the path of a single tile: the “life of a tile”, akin to <a rel="nofollow" href="https://groups.google.com/a/chromium.org/g/blink-dev/c/AK_rwEp61ME"><!----><!---->the “life of a pixel” in a browser’s rendering pipeline<!----></a><!---->. In particular, let’s follow the tile’s path through the <a rel="nofollow" href="https://modal.com/gpu-glossary/device-software/memory-hierarchy"><!----><!---->memory hierarchy of the GPU<!----></a><!----> as it is transformed from initial query tile to final output tile.</p> <p>At a high level, and eliding a few details about multiple buffering that increase concurrency and parallelism, that looks something like this:</p> <p><img src="https://modal-cdn.com/blog/images/fa4-life-of-a-tile.jpg" alt="fa4-life-of-tile.drawio.png"/> <!--[!--><!--]--><!----></p> <p>Which vaguely resembles a <a rel="nofollow" href="https://microservices.io/patterns/microservices.html"><!----><!---->microservices diagram<!----></a><!---->. As above, so below!</p> <p>Spelled out, that’s:</p> <ul><li>A tile of queries is loaded from global memory (<code>mQ</code>) into shared memory (<code>sQ</code>) by the Load warp. <a rel="nofollow" href="https://modal.com/gpu-glossary/device-software/shared-memory"><!----><!---->Shared memory<!----></a><!----> is a “scratchpad” L1 cache managed by the programmer.</li> <li>Tiles of keys (<code>mK</code>) and values (<code>mV</code>) are streamed into shared memory (<code>sK</code>, <code>sV</code>), also by the Load warp. Note that if the working set size permits, future loads of these tiles for other query tiles will be serviced from the hardware-managed L2 cache (not pictured).</li> <li>When each tile of keys is ready, the MMA warp multiplies it with our tile of queries using a Tensor Core, producing a tile of unnormalized attention scores in Tensor Memory (<code>tS</code>). <a rel="nofollow" href="https://modal.com/gpu-glossary/device-hardware/tensor-core"><!----><!---->Tensor Cores<!----></a><!----> are single-purpose hardware for running matmuls. <a rel="nofollow" href="https://modal.com/gpu-glossary/device-hardware/tensor-memory"><!----><!---->Tensor Memory<!----></a><!----> is another programmer-managed L1 cache designed to hold and accumulate intermediates during sequences of Tensor Core operations.</li> <li>When each tile of unnormalized attention scores is ready, a Softmax warp produces normalized attention scores for that tile in Tensor Memory (<code>tP</code>) without using the Tensor Core and updates a scaling factor used for numerical stability (in shared memory, not pictured). <ul><li>⚡️ New in Flash Attention 4: this step can use CUDA Cores instead of <a rel="nofollow" href="https://modal.com/gpu-glossary/device-hardware/special-function-unit"><!----><!---->Special Function Units (SFUs)<!----></a><!----> to perform the exponential step of the normalization. SFUs are intended to provide hardware acceleration for transcendental operations like exponentials. But there are <a rel="nofollow" href="https://modal.com/gpu-glossary/device-hardware/streaming-multiprocessor"><!----><!---->far fewer SFUs than CUDA Cores<!----></a><!---->, which can lead to queueing. The basic idea, fast approximate exponentiation in software for neural networks that can tolerate a bit of accuracy loss, was proposed in <a rel="nofollow" href="https://nic.schraudolph.org/pubs/Schraudolph99.pdf"><!----><!---->a 1999 <em>Neural Computation</em> paper by Schraudolph<!----></a><!---->, but the implementation here is quite different, involving a cubic polynomial approximation (as described in detail below).</li></ul></li> <li>When each tile of normalized attention scores is ready, a Correction warp checks if the normalization scaling factor has changed and, if necessary, rescales the final output tile in Tensor Memory (<code>tO</code>). <ul><li>⚡️ New in Flash Attention 4: the choice of when to rescale became much smarter, reportedly cutting down on output rescaling operations by a factor of 10. Roughly: the scaling factor used to be a simple running maximum. Now updates are applied only when the maximum has changed enough to impact numerical stability. This seems like a good, and very portable, idea.</li></ul></li> <li>When each rescaling update finishes, the MMA warp updates the output tile in Tensor Memory (<code>tO</code>) by accumulating it with the value tile (<code>sV</code>) scaled by the attention score tile (<code>tP</code>).</li> <li>When each tile of final output values is ready, the Correction warp stores it in shared memory (<code>sO</code>), then the Epilogue warp stores it in global memory (<code>mO</code>), and we’re done with that tile.</li></ul> <p>Our high-level, tile-centric view elides a number of details, like the number of warps assigned to each pipeline step and the use of buffers to store different tiles. It also leaves out all of the details of the barrier synchronization, which is required on both sides of every producer/consumer relationship (aka where an arrow tip meets an arrow tail in the diagram). These are critical for performance.</p> <p>We go through these details in a “warp-centric” view of the kernel below, which focuses on the operations in each warp, rather than the movement of tiles, and includes links to the source code. This is necessarily more technical and goes through some GPU-specific features at higher speed, so it’s less suitable for a general software engineering audience.</p> <p>But before that, one last takeaway for those only interested in the high level.</p> <h2 id="where-does-gpu-programming-go-from-here">Where does GPU programming go from here?</h2> <p>When <a rel="nofollow" href="https://graphics.stanford.edu/papers/brookgpu/brookgpu.pdf"><!----><!---->Ian Buck<!----></a><!----> and others designed <a rel="nofollow" href="https://modal.com/gpu-glossary/host-software/cuda-c"><!----><!---->CUDA C<!----></a><!---->, they were driven by a north star: can it be used to write a single precision vector addition (<code>saxpy</code>) with respectable performance as a clean one-liner that’s easily understood by a C programmer? The core of the <a rel="nofollow" href="https://modal.com/gpu-glossary/device-software/cuda-programming-model"><!----><!---->CUDA programming model<!----></a><!----> laid down then and described in the <a rel="nofollow" href="https://www.cs.cmu.edu/afs/cs/academic/class/15869-f11/www/readings/lindholm08_tesla.pdf"><!----><!---->2008 Lindholm et al. paper<!----></a><!----> still persists today.</p> <p>What’s new in the last few years (in the Hopper and Blackwell architectures) is an increasing reliance on programmer-managed asynchrony, like FA4’s multi-stage, multi-buffered pipeline. This represents a major jump in complexity from FA3’s simpler “ping-pong” pipeline (<a rel="nofollow" href="https://www.together.ai/blog/flashattention-3"><!----><!---->added to take advantage of Hopper GPUs’ async capabilities<!----></a><!---->).</p> <p>And <a rel="nofollow" href="https://bitbashing.io/async-rust.html"><!----><!---->just as in other well-designed languages<!----></a><!---->, CUDA C/C++ has struggled to accommodate the introduction of asynchrony. It is a <a rel="nofollow" href="https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/"><!----><!---->truth universally acknowledged<!----></a><!----> that <a rel="nofollow" href="https://fasterthanli.me/articles/pin-and-suffering"><!----><!---->async programming sucks absolute ass<!----></a><!---->. That’s especially true when you need to manage your own event loop, as we’re effectively doing here. And it’s made harder, not easier, by the thread-centricity and warp uniformity of the CUDA programming model and <a rel="nofollow" href="https://modal.com/gpu-glossary/device-software/parallel-thread-execution"><!----><!---->PTX machine model<!----></a><!---->.</p> <p>No wonder <a rel="nofollow" href="https://www.youtube.com/watch?v=5e1YKqsP8i8&amp;t=1059s"><!----><!---->the Triton team gave up on writing Blackwell attention<!----></a><!----> and added the new Gluon frontend at a lower level!</p> <p>Triton’s troubles notwithstanding, this kernel is a clear instance of the swing towards tile-based, warp-specialized programming. And Nvidia is betting big on a number of new languages and libraries to try to make this easier, from the <a rel="nofollow" href="https://docs.nvidia.com/cutlass/media/docs/pythonDSL/cute_dsl_general/dsl_introduction.html"><!----><!---->CuTe DSL<!----></a><!----> and <a rel="nofollow" href="https://docs.nvidia.com/cutlass/index.html"><!----><!---->CUTLASS<!----></a><!----> C++ used in this kernel to the forthcoming <a rel="nofollow" href="https://www.youtube.com/watch?v=uZTtViomW6w"><!----><!---->CuTile<!----></a><!---->. Say what you will about the chatbot hype wave, these are exciting times for high performance numerical computing!</p> <h2 id="deep-dive-for-the-gpu-enjoyers-what-does-each-warp-do-in-flash-attention-4">Deep dive for the GPU enjoyers: What does each warp do in Flash Attention 4?</h2> <p>There are five different specializations for warps in the Flash Attention 4 kernel. They are listed below, along with links to their source code.</p> <ol><li>A <a rel="nofollow" href="https://github.com/Dao-AILab/flash-attention/blob/5c1627a7a1cda9c32cb9b937a053564e663f81bc/flash_attn/cute/flash_fwd_sm100.py#L837"><!----><!---->Load warp<!----></a><!----> to load query, key, and value tiles from global memory into shared memory</li> <li>An <a rel="nofollow" href="https://github.com/Dao-AILab/flash-attention/blob/5c1627a7a1cda9c32cb9b937a053564e663f81bc/flash_attn/cute/flash_fwd_sm100.py#L953"><!----><!---->MMA warp<!----></a><!----> to compute unnormalized attention scores from query and key tiles and accumulate score-weighted value tiles into the output tiles</li> <li>Eight <a rel="nofollow" href="https://github.com/Dao-AILab/flash-attention/blob/5c1627a7a1cda9c32cb9b937a053564e663f81bc/flash_attn/cute/flash_fwd_sm100.py#L1143-L1145"><!----><!---->Softmax warps<!----></a><!----> to compute normalized attention scores and track running stats (max, sum)</li> <li>Four <a rel="nofollow" href="https://github.com/Dao-AILab/flash-attention/blob/5c1627a7a1cda9c32cb9b937a053564e663f81bc/flash_attn/cute/flash_fwd_sm100.py#L1413"><!----><!---->Correction warps<!----></a><!----> to watch for updates to the normalization scale and re-normalize the output tiles</li> <li>One or two <a rel="nofollow" href="https://github.com/Dao-AILab/flash-attention/blob/5c1627a7a1cda9c32cb9b937a053564e663f81bc/flash_attn/cute/flash_fwd_sm100.py#L1737"><!----><!---->Epilogue warps<!----></a><!----> to store completed output tiles from shared memory into global memory</li></ol> <p>In the above discussion, we implied that each CTA works on just two query tiles and produces just two output tiles. That’s true in some settings, but the mapping between tiles and CTAs is technically abstracted by a <a rel="nofollow" href="https://github.com/Dao-AILab/flash-attention/blob/5c1627a7a1cda9c32cb9b937a053564e663f81bc/flash_attn/cute/flash_fwd_sm100.py#L398-L404"><!----><code>TileScheduler</code><!----></a><!---->. For the best performance, you need to use the <a rel="nofollow" href="https://github.com/Dao-AILab/flash-attention/blob/1ceaa984b2f348caea18b39a98458d33b4ea7a09/flash_attn/cute/tile_scheduler.py#L122"><!----><code>StaticPersistentTileScheduler</code><!----></a><!---->, which launches <a rel="nofollow" href="https://github.com/Dao-AILab/flash-attention/blob/1ceaa984b2f348caea18b39a98458d33b4ea7a09/flash_attn/cute/tile_scheduler.py#L162-L163"><!----><!---->at most one CTA per Streaming Multiprocessor<!----></a><!----> and then schedules tiles onto those SMs. This reduces CTA launch overhead and allows for more fine-grained concurrency (e.g. overlapping Epilogue warps for one tile with the Load and MMA warps for the next tile).</p> <p>The core work of the kernel is the same — there’s just not a clean mapping of work onto thread constructs, which makes explaining the work harder. From here, we’ll go back to speaking about the code as though each CTA handles only two tiles (which is literally true if you use the <a rel="nofollow" href="https://github.com/Dao-AILab/flash-attention/blob/1ceaa984b2f348caea18b39a98458d33b4ea7a09/flash_attn/cute/tile_scheduler.py#L56"><!----><code>SingleTileScheduler</code><!----></a><!---->).</p> <p>Also, from here we will start using some shorthand, matching the code and convention: Q for queries, K for keys, V for values, O for outputs, S for unnormalized attention scores, and P for normalized attention scores/“probabilities”.</p> <h3 id="the-load-warp-loads-two-q-tiles-and-streams-all-k-and-v-tiles">The Load warp loads two Q tiles and streams all K and V tiles.</h3> <p>The <a rel="nofollow" href="https://github.com/Dao-AILab/flash-attention/blob/5c1627a7a1cda9c32cb9b937a053564e663f81bc/flash_attn/cute/flash_fwd_sm100.py#L837"><!----><!---->Load warp<!----></a><!----> operates on <a rel="nofollow" href="https://github.com/Dao-AILab/flash-attention/blob/5c1627a7a1cda9c32cb9b937a053564e663f81bc/flash_attn/cute/flash_fwd_sm100.py#L841-L843"><!----><!---->pointers to Q, K, and V tensors in global memory<!----></a><!----> and writes to <a rel="nofollow" href="https://github.com/Dao-AILab/flash-attention/blob/5c1627a7a1cda9c32cb9b937a053564e663f81bc/flash_attn/cute/flash_fwd_sm100.py#L844-L846"><!----><!---->Q, K, and V tensors in shared memory<!----></a><!---->. It supports paged keys and values (as in <a rel="nofollow" href="https://arxiv.org/abs/2309.06180"><!----><!---->Paged Attention<!----></a><!---->, not as in operating system pages) via an <a rel="nofollow" href="https://github.com/Dao-AILab/flash-attention/blob/5c1627a7a1cda9c32cb9b937a053564e663f81bc/flash_attn/cute/flash_fwd_sm100.py#L847"><!----><!---->optional “page table” tensor<!----></a><!----> (again, <em>not</em> the page tables co-managed by the OS, the CPU, and the MMU).</p> <p>It uses the <a rel="nofollow" href="https://modal.com/gpu-glossary/device-hardware/tensor-memory-accelerator"><!----><!---->Tensor Memory Accelerator (TMA)<!----></a><!----> to reduce register pressure from multidimensional array access and <a rel="nofollow" href="https://github.com/Dao-AILab/flash-attention/blob/5c1627a7a1cda9c32cb9b937a053564e663f81bc/flash_attn/cute/flash_fwd_sm100.py#L889-L909"><!----><!---->fire off copies asynchronously<!----></a><!---->. This also avoids very long <a rel="nofollow" href="https://modal.com/gpu-glossary/perf/warp-execution-state"><!----><!---->warp stalls<!----></a><!----> on loads that would require even more warp specialization to <a rel="nofollow" href="https://modal.com/gpu-glossary/perf/latency-hiding"><!----><!---->hide latency<!----></a><!---->.</p> <p>The Load warp <a rel="nofollow" href="https://github.com/Dao-AILab/flash-attention/blob/5c1627a7a1cda9c32cb9b937a053564e663f81bc/flash_attn/cute/flash_fwd_sm100.py#L934-L935"><!----><!---->loads two Q tiles<!----></a><!---->. It loads all K and V blocks <a rel="nofollow" href="https://github.com/Dao-AILab/flash-attention/blob/5c1627a7a1cda9c32cb9b937a053564e663f81bc/flash_attn/cute/flash_fwd_sm100.py#L939-L946"><!----><!---->in a loop<!----></a><!---->. It is the ”<a rel="nofollow" href="https://github.com/Dao-AILab/flash-attention/blob/5c1627a7a1cda9c32cb9b937a053564e663f81bc/flash_attn/cute/flash_fwd_sm100.py#L859"><!----><!---->producer<!----></a><!---->” of these tiles (in a producer/consumer setup). It can <a rel="nofollow" href="https://github.com/Dao-AILab/flash-attention/blob/5c1627a7a1cda9c32cb9b937a053564e663f81bc/flash_attn/cute/flash_fwd_sm100.py#L170"><!----><!---->concurrently load up to three blocks each of K and V<!----></a><!---->.</p> <p>As it completes these loads, the Load warp signals their completion to the MMA warp through <a rel="nofollow" href="https://github.com/Dao-AILab/flash-attention/blob/5c1627a7a1cda9c32cb9b937a053564e663f81bc/flash_attn/cute/flash_fwd_sm100.py#L852"><!----><!---->an array of barriers in shared memory<!----></a><!---->. All barriers (not just for Load/MMA synchronization) are <a rel="nofollow" href="https://github.com/Dao-AILab/flash-attention/blob/5c1627a7a1cda9c32cb9b937a053564e663f81bc/flash_attn/cute/flash_fwd_sm100.py#L913"><!----><!---->referenced via their offset in this array<!----></a><!----> to support variable barrier counts with different configuration settings.</p> <h3 id="the-mma-warp-computes-unnormalized-attention-scores-and-output-values">The MMA warp computes unnormalized attention scores and output values.</h3> <p>The <a rel="nofollow" href="https://github.com/Dao-AILab/flash-attention/blob/5c1627a7a1cda9c32cb9b937a053564e663f81bc/flash_attn/cute/flash_fwd_sm100.py#L953"><!----><!---->MMA warp<!----></a><!----> operates on pointers to Q, K, and V tensors in <a rel="nofollow" href="https://github.com/Dao-AILab/flash-attention/blob/5c1627a7a1cda9c32cb9b937a053564e663f81bc/flash_attn/cute/flash_fwd_sm100.py#L957-L959"><!----><!---->shared memory<!----></a><!---->. For every K/V tile, it runs <a rel="nofollow" href="https://github.com/Dao-AILab/flash-attention/blob/5c1627a7a1cda9c32cb9b937a053564e663f81bc/flash_attn/cute/flash_fwd_sm100.py#L990"><!----><!---->two matmuls to create S tiles<!----></a><!----> and <a rel="nofollow" href="https://github.com/Dao-AILab/flash-attention/blob/5c1627a7a1cda9c32cb9b937a053564e663f81bc/flash_attn/cute/flash_fwd_sm100.py#L998"><!----><!---->two matmuls for O<!----></a><!----> (Q/K for the S tiles, P/V for the O tiles). The matmuls are <a rel="nofollow" href="https://github.com/Dao-AILab/flash-attention/blob/1ceaa984b2f348caea18b39a98458d33b4ea7a09/flash_attn/cute/blackwell_helpers.py#L327-L369"><!----><!---->emitted as inline PTX assembly<!----></a><!---->, as is necessary for CUDA C/C++ programs to use the Tensor Cores in Hopper and Blackwell. The vast majority of the FLOPS in this kernel are driven by these lines; most everything else is memory management.</p> <p>The specific PTX instruction used is <code>tcgen05.mma.cta_group::1</code>. <code>mma</code> is matrix-multiply-accumulate. <code>tcgen05</code> means <code>5</code>th generation <code>t</code>ensor <code>c</code>ore, aka Blackwell, as in <code>sm100</code>/<a rel="nofollow" href="https://modal.com/gpu-glossary/device-software/compute-capability"><!----><!---->Compute Capability 10.0<!----></a><!---->. <code>cta_group::1</code> means we run our matmul using only a single CTA, avoiding the nastiness of <a rel="nofollow" href="https://modal.com/gpu-glossary/device-hardware/texture-processing-cluster"><!----><!---->TPC<!----></a><!---->-based 2SM/2CTA matmuls <a rel="nofollow" href="https://docs.nvidia.com/cutlass/media/docs/cpp/blackwell_functionality.html"><!----><!---->available in Blackwell<!----></a><!---->. This likely introduces a small memory throughput penalty but simplifies CTA/tile scheduling. Interestingly, the <a rel="nofollow" href="https://github.com/HazyResearch/ThunderKittens/blob/2ba96ceedfb1b5c5d6e1eb4a1241a24d16049be4/kernels/attn/b200/b200.cu"><!----><!---->ThunderKittens Blackwell attention kernel<!----></a><!----> makes a different choice.</p> <p>Also on the front of scheduling/simplification: only a single <code>leader_thread</code> issues the instruction. And we’re only working from a single warp. This is an important difference from performant Hopper MMAs, which were coordinated across an entire warpgroup.</p> <p>After <a rel="nofollow" href="https://github.com/Dao-AILab/flash-attention/blob/5c1627a7a1cda9c32cb9b937a053564e663f81bc/flash_attn/cute/flash_fwd_sm100.py#L1017"><!----><!---->getting hold of a Q tile<!----></a><!----> and our first K tile, we <a rel="nofollow" href="https://github.com/Dao-AILab/flash-attention/blob/5c1627a7a1cda9c32cb9b937a053564e663f81bc/flash_attn/cute/flash_fwd_sm100.py#L1031"><!----><!---->run our first matmul<!----></a><!----> to produce our first result for S. Then we <a rel="nofollow" href="https://github.com/Dao-AILab/flash-attention/blob/5c1627a7a1cda9c32cb9b937a053564e663f81bc/flash_attn/cute/flash_fwd_sm100.py#L1045"><!----><!---->loop over the remaining K and V tiles<!----></a><!----> and update S and O. These <a rel="nofollow" href="https://github.com/Dao-AILab/flash-attention/blob/5c1627a7a1cda9c32cb9b937a053564e663f81bc/flash_attn/cute/flash_fwd_sm100.py#L963-L964"><!----><!---->S and O tensors<!----></a><!----> live in Tensor Memory. This is <a rel="nofollow" href="https://modal.com/gpu-glossary/device-hardware/tensor-memory"><!----><!---->the “intended” use of Tensor Memory<!----></a><!---->, as a store for accumulators read from and written to by the Tensor Cores.</p> <p>Since the K and V tiles are buffered, we need to signal the Load warp every time we finish using them (eg <a rel="nofollow" href="https://github.com/Dao-AILab/flash-attention/blob/5c1627a7a1cda9c32cb9b937a053564e663f81bc/flash_attn/cute/flash_fwd_sm100.py#L1073-L1075"><!----><!---->here<!----></a><!---->, signaling that the memory containing V can be reused once it has been used to construct the second O tile). There’s some additional coordination here (around S, P, and O), which we’ll discuss as it comes in up in the other warps.</p> <h3 id="eight-softmax-warps-produce-normalized-attention-scores">Eight Softmax warps produce normalized attention scores.</h3> <p>The Softmax warps <a rel="nofollow" href="https://github.com/Dao-AILab/flash-attention/blob/5c1627a7a1cda9c32cb9b937a053564e663f81bc/flash_attn/cute/flash_fwd_sm100.py#L1401"><!----><!---->produce normalized attention scores<!----></a><!----> (P, as in “probabilities”) consumed by the MMA warps. Ignore the name and don’t try to come up with an interpretation of the attention scores as the probability distribution for a random variable; it’ll make your head hurt and give you bad intuition about Transformers. They’re <a rel="nofollow" href="https://transformer-circuits.pub/"><!----><!---->better thought of<!----></a><!----> as weights for a linear combination of vectors from V.</p> <p>The core <a rel="nofollow" href="https://github.com/Dao-AILab/flash-attention/blob/5c1627a7a1cda9c32cb9b937a053564e663f81bc/flash_attn/cute/flash_fwd_sm100.py#L1143-L1145"><!----><!---->softmax operation is implemented by two warpgroups<!----></a><!---->, aka eight warps. The two warpgroups are mapped onto the two query/output tile workstreams. Warpgroups are made up of four adjacent warps with a warp index alignment of four. Using them was critical for the fast warpgroup MMAs in Hopper GPUs, <a rel="nofollow" href="https://www.together.ai/blog/flashattention-3"><!----><!---->as in Flash Attention 3<!----></a><!---->, but we didn’t see anything in this kernel that made explicit use of them. Warpgroup alignment may lead to more even distribution of work across warp schedulers/subunits of the SM, as it did in Hopper, which had <a rel="nofollow" href="https://modal.com/gpu-glossary/device-hardware/streaming-multiprocessor-architecture"><!----><!---->four warp schedulers per SM<!----></a><!---->. To our <a rel="nofollow" href="https://en.wikipedia.org/wiki/Blackwell_(microarchitecture)#Blackwell_dies"><!----><!---->and Wikipedia’s<!----></a><!----> knowledge, this level of detail on SM100 Blackwell GPUs like B200s is not published anywhere (but it <a rel="nofollow" href="https://images.nvidia.com/aem-dam/Solutions/geforce/blackwell/nvidia-rtx-blackwell-gpu-architecture.pdf"><!----><!---->is true of SM120 RTX Blackwell GPUs<!----></a><!---->).</p> <p>We’re also not certain of the reason why some pipeline stages are assigned more warps than others and in this particular ratio. Presumably, it helps ensure balanced throughput across the different stages, but our napkin math on relative operational load, bandwidth, and latency between the matmuls and the attention operations didn’t produce a smoking gun. We speculate that it was determined by benchmarking.</p> <p>Each warp runs <a rel="nofollow" href="https://github.com/Dao-AILab/flash-attention/blob/5c1627a7a1cda9c32cb9b937a053564e663f81bc/flash_attn/cute/flash_fwd_sm100.py#L1315"><!----><!---->a single step<!----></a><!----> of the online softmax calculation at a time while <a rel="nofollow" href="https://github.com/Dao-AILab/flash-attention/blob/5c1627a7a1cda9c32cb9b937a053564e663f81bc/flash_attn/cute/flash_fwd_sm100.py#L1267-L1269"><!----><!---->looping over<!----></a><!----> the <a rel="nofollow" href="https://github.com/Dao-AILab/flash-attention/blob/5c1627a7a1cda9c32cb9b937a053564e663f81bc/flash_attn/cute/flash_fwd_sm100.py#L1384"><!----><!---->S tiles produced by the MMA warp<!----></a><!---->.</p> <p>Looking within the individual <a rel="nofollow" href="https://github.com/Dao-AILab/flash-attention/blob/5c1627a7a1cda9c32cb9b937a053564e663f81bc/flash_attn/cute/flash_fwd_sm100.py#L1315"><!----><!---->softmax step<!----></a><!---->: the unnormalized attention scores are stored in Tensor Memory, which can only be <em>directly</em> operated on by the Tensor Cores. But the Tensor Cores can only do matrix multiplication. So the Softmax warps have to <a rel="nofollow" href="https://github.com/Dao-AILab/flash-attention/blob/5c1627a7a1cda9c32cb9b937a053564e663f81bc/flash_attn/cute/flash_fwd_sm100.py#L1363"><!----><!---->copy the scores<!----></a><!----> into the registers to apply the exponentiation and then <a rel="nofollow" href="https://github.com/Dao-AILab/flash-attention/blob/5c1627a7a1cda9c32cb9b937a053564e663f81bc/flash_attn/cute/flash_fwd_sm100.py#L1398"><!----><!---->copy the result back<!----></a><!---->.</p> <p>The exponentiation is done differently than in previous versions of Flash Attention. FA3 and earlier used the GPU’s Special Function Units to perform a hardware-accelerated exponentiation. Specifically, they use the <code>exp2</code> CUDA PTX intrinsic, which is typically <a rel="nofollow" href="https://godbolt.org/z/7e5jx9qcr"><!----><!---->mapped by the (closed-source) <code>ptxas</code> compiler to the <code>MUFU.EX2</code> SASS instruction<!----></a><!---->.</p> <p>The FA4 kernel does that too, but for <a rel="nofollow" href="https://github.com/Dao-AILab/flash-attention/blob/add175637c5d54b74bc25372e49ce282d6f236fc/flash_attn/cute/flash_fwd_sm100.py#L1390-L1391"><!----><!---->smaller attention head sizes<!----></a><!----> it <a rel="nofollow" href="https://github.com/Dao-AILab/flash-attention/blob/0165c96fff7a7cd2e152aa9659f75c972a702f5d/flash_attn/cute/softmax.py#L234-L238"><!----><!---->additionally mixes in a different exponentiation algorithm on some iterations with a tunable frequency<!----></a><!---->. That implementation uses <a rel="nofollow" href="https://github.com/Dao-AILab/flash-attention/blob/add175637c5d54b74bc25372e49ce282d6f236fc/flash_attn/cute/utils.py#L501-L541"><!----><!---->this block of inline PTX<!----></a><!----> to compute <code>2 ** x</code>. The algorithm splits the exponentiation into two parts: the easy integer part (<code>2 ** floor(x)</code>) and the hard rational part (<code>2 ** (x - floor(x))</code>). It uses a cubic polynomial to approximate <code>2 ** x</code> on the unit interval (check out the approximation on Wolfram Alpha <a rel="nofollow" href="https://www.wolframalpha.com/input?i=0.07711909*r%5E3%2B0.22756439*r%5E2%2B0.69514614*r%2B1.0+compared+to+2%5Er"><!----><!---->here<!----></a><!---->).</p> <p>The cubic polynomial calculation is done, following Horner’s method for linear time polynomial evaluation, with three fused multiply-adds (<code>fma</code>):</p> <!----> <p>Note that <code>f32x2</code> means that we operate on a vector (as in <a rel="nofollow" href="https://people.eecs.berkeley.edu/~pattrsn/252S98/Lec06-vector.pdf"><!----><!---->vector lanes<!----></a><!---->) of two 32 bit values. You can read about a similar implementation for CPU vector instructions on Stack Overflow <a rel="nofollow" href="https://stackoverflow.com/questions/47025373/fastest-implementation-of-the-natural-exponential-function-using-sse"><!----><!---->here<!----></a><!---->.</p> <p>In addition to only applying this method on some iterations, it <a rel="nofollow" href="https://github.com/Dao-AILab/flash-attention/blob/0165c96fff7a7cd2e152aa9659f75c972a702f5d/flash_attn/cute/softmax.py#L234-L238"><!----><!---->stops applying it on a configurable number of the last S tiles<!----></a><!---->. Together, these suggest that the reason for applying it is to avoid a bottleneck on the SFUs (which, due to <a rel="nofollow" href="https://www.thonking.ai/p/what-shapes-do-matrix-multiplications"><!----><!---->wave quantization effects<!----></a><!---->, is less relevant for the final tiles).</p> <p>The Softmax warps also <a rel="nofollow" href="https://github.com/Dao-AILab/flash-attention/blob/5c1627a7a1cda9c32cb9b937a053564e663f81bc/flash_attn/cute/flash_fwd_sm100.py#L1282"><!----><!---->track the running statistics for rescaling and normalizing attention scores<!----></a><!----> used by the Correction warps, as discussed below.</p> <p>There’s another important change here. All softmax algorithms need to handle <a rel="nofollow" href="https://en.wikipedia.org/wiki/Softmax_function#Numerical_algorithms"><!----><!---->numerical instability caused by exponentiation of large values<!----></a><!---->. Before Flash Attention, this was usually done by finding the largest value in each row and subtracting it from the value before exponentiating. All Flash Attention kernels use a streaming or online softmax algorithm, and the largest value is not known in advance — searching through the scores to find it would defeat the purpose of using a streaming algorithm! Instead, they use a running maximum for numerical stability and update the scaling factor whenever a new maximum is encountered. This ensures continued numerical stability and avoids an extra scan, but requires a costly correction of previous values (handled by the Correction warps) every time a new maximum is observed.</p> <p>This is inefficient. We only need to update the scaling factor <em>when the new maximum changes enough to threaten numerical stability</em>, not every time a new maximum appears. That logic is implemented <a rel="nofollow" href="https://github.com/Dao-AILab/flash-attention/blob/0165c96fff7a7cd2e152aa9659f75c972a702f5d/flash_attn/cute/softmax.py#L176-L179"><!----><!---->here<!----></a><!---->. In the Hot Chips talk, Dao indicated that this reduced the number of corrections by a factor of 10.</p> <p>There is additional support for <a rel="nofollow" href="https://github.com/Dao-AILab/flash-attention/blob/5c1627a7a1cda9c32cb9b937a053564e663f81bc/flash_attn/cute/flash_fwd_sm100.py#L1153"><!----><!---->attention sinks<!----></a><!----> and storing <a rel="nofollow" href="https://github.com/Dao-AILab/flash-attention/blob/5c1627a7a1cda9c32cb9b937a053564e663f81bc/flash_attn/cute/flash_fwd_sm100.py#L1152"><!----><!---->the log-sum-exp tensor<!----></a><!----> used in the backwards pass. At time of writing in late September 2025, a backwards version of this kernel is not available, but is expected imminently.</p> <h3 id="four-correction-warps-rescale-previous-outputs-as-the-normalization-changes">Four Correction warps rescale previous outputs as the normalization changes.</h3> <p>The <a rel="nofollow" href="https://github.com/Dao-AILab/flash-attention/blob/5c1627a7a1cda9c32cb9b937a053564e663f81bc/flash_attn/cute/flash_fwd_sm100.py#L1413"><!----><!---->Correction warps<!----></a><!----> update <a rel="nofollow" href="https://github.com/Dao-AILab/flash-attention/blob/5c1627a7a1cda9c32cb9b937a053564e663f81bc/flash_attn/cute/flash_fwd_sm100.py#L1418"><!----><!---->past output results<!----></a><!----> from the MMA warps <a rel="nofollow" href="https://github.com/Dao-AILab/flash-attention/blob/5c1627a7a1cda9c32cb9b937a053564e663f81bc/flash_attn/cute/flash_fwd_sm100.py#L1476-L1477"><!----><!---->as the numerical stability scaling factor changes<!----></a><!---->. The Correction warps need to coordinate their access to the O values in Tensor Memory with the MMA warps (eg <a rel="nofollow" href="https://github.com/Dao-AILab/flash-attention/blob/5c1627a7a1cda9c32cb9b937a053564e663f81bc/flash_attn/cute/flash_fwd_sm100.py#L1533"><!----><!---->here<!----></a><!---->, indicating that those values are consumed and the memory can be reclaimed).</p> <p>Like the Softmax warps, the four Correction warps form a warpgroup. Also like the Softmax warps, they need to load from Tensor Memory to registers to apply their <a rel="nofollow" href="https://github.com/Dao-AILab/flash-attention/blob/5c1627a7a1cda9c32cb9b937a053564e663f81bc/flash_attn/cute/flash_fwd_sm100.py#L1588"><!----><!---->non-matmul rescaling operation<!----></a><!---->.</p> <p>The Correction warps are also responsible for writing the output from Tensor Memory to shared memory and applying the final scaling by the row sum. This is <a rel="nofollow" href="https://github.com/Dao-AILab/flash-attention/blob/5c1627a7a1cda9c32cb9b937a053564e663f81bc/flash_attn/cute/flash_fwd_sm100.py#L1527-L1529"><!----><!---->called the <code>correction_epilogue</code><!----></a><!---->. “Epilogue” here means the same thing as in the name of the “Epilogue” warps — an operation that occurs at the end of a sequence of operations on values stored in one memory and before the results are written to another memory. But in this case, it refers to operations on data in Tensor Memory before they are stored to shared memory, whereas the Epilogue warps take data from shared memory and store it in global memory.</p> <p>This is especially confusing because the completion of this epilogue is the signal for the Epilogue warps to start their work.</p> <p>The Correction warps have the <a rel="nofollow" href="https://github.com/Dao-AILab/flash-attention/blob/5c1627a7a1cda9c32cb9b937a053564e663f81bc/flash_attn/cute/flash_fwd_sm100.py#L1420"><!----><!---->global memory output tensor among their arguments<!----></a><!---->, but only use it in commented-out code.</p> <h3 id="the-epilogue-warps-store-complete-output-tiles-back-into-global-memory">The Epilogue Warp(s) store complete output tiles back into global memory.</h3> <p>There are either one or two <a rel="nofollow" href="https://github.com/Dao-AILab/flash-attention/blob/5c1627a7a1cda9c32cb9b937a053564e663f81bc/flash_attn/cute/flash_fwd_sm100.py#L1737"><!----><!---->Epilogue warps<!----></a><!----> depending on <a rel="nofollow" href="https://github.com/Dao-AILab/flash-attention/blob/5c1627a7a1cda9c32cb9b937a053564e663f81bc/flash_attn/cute/flash_fwd_sm100.py#L367"><!----><!---->whether the TMA is enabled<!----></a><!---->.</p> <p>In <a rel="nofollow" href="https://github.com/Dao-AILab/flash-attention/blob/5c1627a7a1cda9c32cb9b937a053564e663f81bc/flash_attn/cute/flash_fwd_sm100.py#L1759"><!----><!---->the case that the Epilogue warps can use the TMA<!----></a><!---->, there’s only one and its work is simple. It <a rel="nofollow" href="https://github.com/Dao-AILab/flash-attention/blob/5c1627a7a1cda9c32cb9b937a053564e663f81bc/flash_attn/cute/flash_fwd_sm100.py#L1770"><!----><!---->waits on the correction loop to finish for an output tile<!----></a><!---->, then <a rel="nofollow" href="https://github.com/Dao-AILab/flash-attention/blob/5c1627a7a1cda9c32cb9b937a053564e663f81bc/flash_attn/cute/flash_fwd_sm100.py#L1772-L1773"><!----><!---->runs a TMA copy<!----></a><!---->, then <a rel="nofollow" href="https://github.com/Dao-AILab/flash-attention/blob/5c1627a7a1cda9c32cb9b937a053564e663f81bc/flash_attn/cute/flash_fwd_sm100.py#L1777"><!----><!---->signals that it has finished reading the O tensor in shared memory<!----></a><!----> and the buffer can be reused.</p> <p>If <a rel="nofollow" href="https://github.com/Dao-AILab/flash-attention/blob/5c1627a7a1cda9c32cb9b937a053564e663f81bc/flash_attn/cute/flash_fwd_sm100.py#L1778"><!----><!---->they can’t use the TMA<!----></a><!---->, their work is more complicated — they need to handle <a rel="nofollow" href="https://github.com/Dao-AILab/flash-attention/blob/5c1627a7a1cda9c32cb9b937a053564e663f81bc/flash_attn/cute/flash_fwd_sm100.py#L1780"><!----><!---->slicing<!----></a><!----> and <a rel="nofollow" href="https://github.com/Dao-AILab/flash-attention/blob/5c1627a7a1cda9c32cb9b937a053564e663f81bc/flash_attn/cute/flash_fwd_sm100.py#L1789"><!----><!---->packing<!----></a><!---->, which is <a rel="nofollow" href="https://github.com/Dao-AILab/flash-attention/blob/5c1627a7a1cda9c32cb9b937a053564e663f81bc/flash_attn/cute/flash_fwd_sm100.py#L1787"><!----><!---->pretty hard<!----></a><!---->. It also consumes <a rel="nofollow" href="https://github.com/Dao-AILab/flash-attention/blob/5c1627a7a1cda9c32cb9b937a053564e663f81bc/flash_attn/cute/flash_fwd_sm100.py#L1795"><!----><!---->quite a few more registers<!----></a><!---->.</p> <h2 id="if-you-made-it-this-far-you-might-enjoy-working-at-modal">If you made it this far, you might enjoy working at Modal.</h2> <p>At Modal, we’re building the cloud infrastructure that compute-intensive workloads like giant Transformers need. Our platform is used by companies like <a href="https://esoteric.codes/blog/suno-case-study"><!----><!---->Suno<!----></a><!---->, <a href="https://esoteric.codes/blog/lovable-case-study"><!----><!---->Lovable<!----></a><!---->, <a href="https://esoteric.codes/blog/ramp-case-study"><!----><!---->Ramp<!----></a><!---->, and <a href="https://esoteric.codes/blog/substack-case-study"><!----><!---->Substack<!----></a><!---->. We’re <a href="https://esoteric.codes/careers"><!----><!---->hiring<!----></a><!---->.</p> <p><em>The authors would like to thank Simon Mo of vLLM, Michael Goin of RedHat AI, and Kimbo Chen of SemiAnalysis for their comments on drafts of this article. We’d also like to thank Tri Dao for writing another banger of a kernel.</em></p><!----></article><!----></div></div>
  </body>
</html>
