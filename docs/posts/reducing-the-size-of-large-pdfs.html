<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://leancrew.com/all-this/2022/01/reducing-the-size-of-large-pdfs/">Original</a>
    <h1>Reducing the Size of Large PDFs</h1>
    
    <div id="readability-page-1" class="page"><div id="container">
       <!-- header -->
      
      <div id="content">
        <p>
          <span></span>
          <a href="https://leancrew.com/all-this/2022/01/lagrange-and-the-jwst/">Previous post</a>        </p>
        
        <p>January 29, 2022 at  6:32 PM by Dr. Drang</p>
        <p>This morning I was writing a report and realized that it was going to be too big to email to the client on Monday. The problem was that it contained 15–20 graphs, all of which were in the neighborhood of 2 MB. When this has happened before, I’d just send the client a Dropbox link or use whatever Apple Mail does to deal with large attachments. But today I decided to fix the problem.</p>

<p>Like all of the graphs I make for work, these were built in Python using <a href="https://matplotlib.org/">Matplotlib</a>. And although there is a fair amount of data being plotted in each graph, it’s always seemed to me that the PDF files produced were a lot bigger than they should be. My search for ways to reduce their size returned lots of web pages that will thin your PDFs for you, but I had no interest in uploading my files to some possibly sketchy site. The trick to getting the kind of answer I wanted was adding “ghostscript” to my search terms.</p>

<p>The solution came from adapting <a href="https://gist.github.com/firstdoit/6390547">a decade-old Gist</a> from Guilherme Rodrigues. The result was this shell script, which I named <code>reduceMPL</code>:</p>

<pre><code>bash:
 1:  #!/usr/bin/env bash
 2:  
 3:  # Reduces the size of PDF plots created by Matplotlib.
 4:  # Assumes that the files to be reduced are named mpl[Something].pdf
 5:  # and that it&#39;s called via
 6:  #
 7:  #     reduceMPL mpl*.pdf
 8:  #
 9:  # The results are a set of smaller files named [Something].pdf
10:  # The original files are *not* deleted.
11:  
12:  for mpl do
13:    new=$(cut -c 4- &lt;&lt;&lt; &#34;$mpl&#34;)
14:    gs -sDEVICE=pdfwrite -dCompatibilityLevel=1.4 -dNOPAUSE -dQUIET -dBATCH -sOutputFile=&#34;$new&#34; &#34;$mpl&#34;
15:  done
</code></pre>

<p>The key, of course, is Line 14, which opens the fat file in Ghostscript and spits out a skinny version. How skinny? My 1.9 MB inputs were turned into 23–25 KB outputs. That’s 25 <em>kilo</em>bytes, the kind of file size you see only in plain text files nowadays. I could easily store all my graphs for this report on a 3½″ diskette—if I still had any 3½″ diskettes. And I don’t see any difference between the original and smaller version.</p>

<p>The script assumes the input files will be prefixed with “mpl,” and the output files will have the same name but with the “mpl” prefix stripped off. For example, <code>mplHoopStress.pdf</code> will lead to the much smaller <code>HoopStress.pdf</code>. All I had to do to meet this assumption was alter one line in the Python code that generates the graphs. So when I have a bunch of graphs that need thinning, a simple</p>

<pre><code>reduceMPL mpl*.pdf
</code></pre>

<p>is all I need to get them converted. As the comment block at the top of the script says, <code>reduceMPL</code> does <em>not</em> delete the original files.</p>

<p>There are a couple of other interesting things in the script. First, you’ll note that Line 12 is</p>

<pre><code>for mpl do
</code></pre>

<p>instead of</p>

<pre><code>for mpl in &#34;$@&#34;; do
</code></pre>

<p>I learned how to do this just a few days ago from <a href="http://mywiki.wooledge.org/BashPitfalls#for_arg_in_.24.2A">a hint</a> on the Bash Pitfalls page of <a href="http://mywiki.wooledge.org">Greg’s Wiki</a>.<sup id="fnref:cook"><a href="#fn:cook" rel="footnote">1</a></sup> What makes it nice is that it loops through the arguments without my having to remember whether the variable to use there is <code>$@</code> or <code>$*</code>. And it handles the quoting of the variable automatically, too.</p>

<p>The other trick was using <a href="https://ss64.com/osx/cut.html"><code>cut</code></a> with a <a href="http://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html#Here-Strings">here-string</a> to get the new file name from the original. I wouldn’t have thought to use a here-string if not for <a href="https://sixcolors.com/post/2022/01/shortcuts-applescript-terminal-working-around-automation-roadblocks/">Jason Snell’s recent post</a> reminding me of how useful they can be.</p>

<p>I’m still not sure why Matplotlib produces such overstuffed PDFs, but at least I now have a way to fix them.</p>


        <p>
          <span></span>
          <a href="https://leancrew.com/all-this/2022/01/lagrange-and-the-jwst/">Previous post</a>        </p>

      </div> <!-- content -->
      
       <!-- sidebar -->
       
       <!-- footer -->
    </div></div>
  </body>
</html>
