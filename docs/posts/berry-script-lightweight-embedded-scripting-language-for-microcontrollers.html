<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://berry-lang.github.io/">Original</a>
    <h1>Berry Script: lightweight embedded scripting language for microcontrollers</h1>
    
    <div id="readability-page-1" class="page"><div>
			<article id="what-is-it">
				<section itemscope="" itemtype="http://schema.org/CreativeWork">
					<header>
						
					</header>
					<p itemprop="description">
						Berry is a ultra-lightweight dynamically typed embedded scripting language. It is designed for lower-performance embedded devices. The Berry interpreter-core&#39;s code size is less than 40KiB and can run on less than 4KiB heap (on ARM Cortex M4 CPU, Thumb ISA and ARMCC compiler).
					</p>
					<p>
						The interpreter of Berry include a one-pass compiler and register-based VM, all the code is written in ANSI C99. In Berry not every type is a class object. Some simple value types, such as int, real, boolean and string are not class object, but list, map and range are class object. This is a consideration about performance. Register-based VM is the same meaning as above.
					</p>
				</section>
			</article>
			<hr/>
			<article id="advantages">
				<section>
					<header>
						
					</header>
					<div>
						<div>
							<h2>Lightweight</h2>
							<p>
								A well-optimized interpreter with very little resources. Ideal for use in microprocessors.
							</p>
						</div>
						<div>
							<h2>Fast</h2>
							<p>
								Optimized one-pass bytecode compiler and register-based virtual machine.
							</p>
						</div>
						<div>
							<h2>Powerful</h2>
							<p>
								Supports imperative programming, object-oriented programming, functional programming.
							</p>
						</div>
						<div>
							<h2>Flexible</h2>
							<p>
								Berry is a dynamic type script, and it&#39;s intended for embedding in applications. It can provide good dynamic scalability for the host system.
							</p>
						</div>
						<div>
							<h2>Simple</h2>
							<p>
								Simple and natural syntax, support garbage collection, and easy to use FFI (foreign function interface).
							</p>
						</div>
						<div>
							<h2>RAM saving</h2>
							<p>
								With compile-time object construction, most of the constant objects are stored in read-only code data segments, so the RAM usage of the interpreter is very low when it starts.
							</p>
						</div>
					</div>
				</section>
			</article>
			<hr/>
			<article id="features">
				<section>
					<header>
						
					</header>
					<div>
						<ul>
							<li>
								<b>Base Type</b>
								<ul>
									<li>Nil: <mark>nil</mark></li>
									<li>Boolean: <mark>true</mark> and <mark>false</mark></li>
									<li>Numerical: Integer (<mark>int</mark>) and Real (<mark>real</mark>)</li>
									<li>String: Single quotation-mark string and double quotation-mark string</li>
									<li>Class: Instance template, read only</li>
									<li>Instance: Object constructed by class</li>
									<li>Module: Read-write key-value pair table</li>
									<li>List: Ordered container, like <mark>[1, 2, 3]</mark></li>
									<li>Map: Hash Map container, like <mark>{ &#39;a&#39;: 1, 2: 3, &#39;map&#39;: {} }</mark></li>
									<li>Range: include a lower and a upper integer value, like <mark>0..5</mark></li>
								</ul>
							</li>
						</ul>
						<ul>
							<li>
								<b>Operator and Expression</b>
								<ul>
									<li>Assign operator: <mark>=</mark>, <mark>+=</mark>, <mark>-=</mark>, <mark>*=</mark>, <mark>/=</mark>, <mark>%=</mark>, <mark>&amp;=</mark>, <mark>|=</mark>, <mark>^=</mark>, <mark>&lt;&lt;=</mark>, <mark>&gt;&gt;=</mark></li>
									<li>Relational operator: <mark>&lt;</mark>, <mark>&lt;=</mark>, <mark>==</mark>, <mark>!=</mark>, <mark>&gt;</mark>, <mark>&gt;=</mark></li>
									<li>Logic operator: <mark>&amp;&amp;</mark>, <mark>||</mark>, <mark>!</mark></li>
									<li>Arithmetic operator: <mark>+</mark>, <mark>-</mark>, <mark>*</mark>, <mark>/</mark>, <mark>%</mark></li>
									<li>Bitwise operator: <mark>&amp;</mark>, <mark>|</mark>, <mark>~</mark>, <mark>^</mark>, <mark>&lt;&lt;</mark>, <mark>&gt;&gt;</mark></li>
									<li>Field operator: <mark>.</mark></li>
									<li>Subscript operator: <mark>[]</mark></li>
									<li>Connect string operator: <mark>+</mark></li>
									<li>Conditional operator: condition <mark>?</mark> val_true <mark>:</mark> val_false</li>
									<li>Brackets: <mark>()</mark></li>
									<li>Bytes buffer support</li>
								</ul>
							</li>
						</ul>
						<ul>
							<li>
								<b>Control Structure</b>
								<ul>
									<li>Conditional statement: <mark>if</mark> <mark>elif</mark> <mark>else</mark> <mark>end</mark></li>
									<li>Iteration statement: <mark>while</mark>, <mark>for</mark></li>
									<li>Jump statement: <mark>break</mark>, <mark>continue</mark></li>
								</ul>
							</li>
						</ul>
						<ul>
							<li>
								<b>Function</b>
								<ul>
									<li>Local variable and block scope</li>
									<li>Return statement</li>
									<li>Nested functions definition</li>
									<li>Closure based on Upvalue</li>
									<li>Anonymous function</li>
									<li>Lambda expression</li>
								</ul>
							</li>
						</ul>
						<ul>
							<li>
								<b>Class</b>
								<ul>
									<li>Inheritance (only public single inheritance)</li>
									<li>Method and Operator Overload</li>
									<li>Constructor method</li>
									<li>Destructive method</li>
								</ul>
							</li>
						</ul>
						<ul>
							<li>
								<b>Module Management</b>
								<ul>
									<li>Built-in module that takes almost no RAM</li>
									<li>Extension module support: script module, bytecode file module and shared library (like *.so, *.dll) module</li>
									<li>Ability to solidify code, classes and modules in flash to reduce RAM usage</li>
									<li>Optional Regex support</li>
									<li>Optional <a href="https://github.com/lvgl/lv_binding_berry" target="_blank">LVGL mapping</a></li>
								</ul>
							</li>
						</ul>
						<ul>
							<li>
								<b>GC (Garbage collection)</b>
								<ul>
									<li>Mark-Sweep GC</li>
								</ul>
							</li>
						</ul>
						<ul>
							<li>
								<b>Exceptional Handling</b>
								<ul>
									<li>Throw any exception value using the <mark>raise</mark> statement</li>
									<li>Multiple catch mode</li>
								</ul>
							</li>
						</ul>
						<ul>
							<li>
								<b>Bytecode file support</b>
								<ul>
									<li>Export function to bytecode file</li>
									<li>Load the bytecode file and execute</li>
								</ul>
							</li>
						</ul>
						<ul>
							<li>
								<b>Native C interface</b>
								<ul>
									<li>Can be easily embedded as a library in existing code like <a href="https://tasmota.github.io/docs/" target="_blank">Tasmota</a></li>
									<li>Optional <a href="https://github.com/lvgl/lv_binding_berry" target="_blank">easy mapping</a> to call C code from Berry</li>
								</ul>
							</li>
						</ul>
					</div>
				</section>
			</article>
			<hr/>
			<article id="brief-tour">
				<section>
					<header>
						
					</header>
					<div>
						<div>
							<div>
								<h3>Simple and intuitive syntax</h3>
								<p>
									The Berry language syntax is similar to that of high-level languages and will be familiar to most programmers.
								</p>
							</div>
							<div>
<pre><span>var</span> list <span>= [</span> <span>&#34;Hello&#34;</span><span>,</span> <span>&#34;World&#34;</span> ]
<span>for</span> text <span>:</span> list
    <span>print</span><span>(</span>text<span>)</span>
<span>end</span>
</pre>
							</div>
						</div>
						<div>
							<div>
								<h3>Map Instance</h3>
								<p>
									The map class is a built-in class type that is used to provide an unordered container of key-value pairs. Within the Berry interpreter, map map uses the Hash table to implement. You can use key-value pairs to construct a map container.
								</p>
							</div>
							<div>
<pre><span>var</span> map <span>= {</span>
    <span>&#39;greets&#39;</span><span>:</span> <span>def</span><span>()</span> <span>return</span> <span>&#39;Hi!</span> <span>Berry</span><span>&#39; </span><span>end</span> <span>()</span><span>,</span>
<span>    &#39;</span><span>say</span><span>&#39;   : &#39;</span><span>Hello World</span><span>&#39;</span><span>,</span>
<span>    &#39;</span><span>sum</span><span>&#39;   : </span><span>10</span> <span>+</span> <span>50</span>
<span>}</span>
<span>for</span> i <span>:</span> map<span>.</span><span>keys</span><span>()</span>
    <span>print</span><span>(</span>i<span>,</span> <span>&#34;\t=&gt;&#34;</span><span>,</span> map<span>[</span>i<span>]</span><span>)</span>
<span>end</span>
</pre>
							</div>
						</div>
						<div>
							<div>
								<h3>Object Orientation</h3>
								<p>
									To use a class, you must first declare it. The declaration of a class begins with the keyword class.
								</p>
								<p>
									The member variables and methods of the class must be specified in the declaration. This is an example of class declaration:
								</p>
							</div>
							<div>
<pre><span>import</span> <span>string</span>

<span>class</span> Parent
    <span>#- member variables  -#</span>
    <span>var</span> fname
    <span>var</span> cname

    <span>#- constructor -#</span>
    <span>def</span> <span>init</span><span>()</span>
        <span>self</span><span>.</span>fname <span>=</span> <span>&#39;Darth vader&#39;</span>
    <span>end</span>

    <span>#- Method -#</span>
    <span>def</span> <span>say</span><span>()</span>
        <span>return</span> <span>string</span><span>.</span><span>format</span><span>(</span>
            <span>&#39;%s say</span><span>\n</span><span>%s %s&#39;</span><span>,</span> <span>self</span><span>.</span>fname<span>,</span>
            <span>self</span><span>.</span>cname<span>,</span> <span>&#34;i&#39;m your father&#34;</span>
        <span>)</span>
    <span>end</span>
<span>end</span>
</pre>
							</div>
						</div>
						<div>
							<div>
								<h3>Class inheritance</h3>
								<p>
									Berry only supports single inheritance, that is, a class can only have one base class, and the base class uses the operator : to declare :
								</p>
								<p>
									Here the Child class inherits from the Parent class. The subclass will inherit all the methods and properties of the Parent class, and you can override them in the subclass. This mechanism is called Overload.
								</p>
							</div>
							<div>
<pre><span>class</span> Child <span>:</span> Parent
    <span>#- constructor -#</span>
    <span>def</span> <span>init</span><span>(</span>name<span>)</span>
        <span>self</span><span>.</span>fname <span>=</span> <span>Parent</span><span>().</span>fname
        <span>self</span><span>.</span>cname <span>=</span> name
    <span>end</span>
<span>end</span>

child <span>=</span> <span>Child</span><span>(</span><span>&#39;Luke&#39;</span><span>)</span>
<span>print</span><span>(</span> child<span>.</span><span>say</span><span>() )</span> <span>#child inherits from parent the say method</span>
</pre>
							</div>
						</div>
					</div>
				</section>
			</article>
			<hr/>
			<article id="examples">
				<section>
					<header>
						
					</header>
					<p>
						You can also check out these Berry example source files on <a href="https://github.com/Skiars/berry/tree/master/examples">GitHub</a>
					</p>
				</section>
			</article>
		</div></div>
  </body>
</html>
