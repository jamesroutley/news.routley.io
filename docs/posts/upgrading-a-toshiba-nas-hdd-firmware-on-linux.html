<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://syscall.eu/blog/2024/08/28/toshiba_hdd_firmware/">Original</a>
    <h1>Upgrading a Toshiba NAS HDD Firmware on Linux</h1>
    
    <div id="readability-page-1" class="page"><div>
      <div>
  
  <p><span>28 Aug 2024</span></p><h2 id="tldr">TL;DR</h2>

<p>I reversed the firmware updater of my Toshiba HDD to be able to update it on Linux.
The following commands <strong>should</strong> work, <strong>USE AT YOUR OWN RISK</strong>:</p>

<div><div><pre><code>$ wget https://www.canvio.jp/en/support/download/hdd/ot_ihdd/fw/ISFw.dat
$ grep -C2 MODELNAME ISFw.dat
 # ^
 # |___ identify the right filename here
$ wget https://www.canvio.jp/en/support/download/hdd/ot_ihdd/fw/sk060202.ftd
# hdparm --fwdownload-mode3 sk060202.ftd /dev/sdX
</code></pre></div></div>

<h2 id="context">Context</h2>

<p>I bought a Toshiba HDWG480 HDD for my NAS. <code>hdparm -I /dev/XXX</code> gives the following output:</p>

<div><div><pre><code>ATA device, with non-removable media
        Model Number:       TOSHIBA HDWG480
        Serial Number:      3430A00RFR0H
        Firmware Revision:  0601
        Transport:          Serial, ATA8-AST, SATA 1.0a, SATA II Extensions, SATA Rev 2.5, SATA Rev 2.6, SATA Rev 3.0
Standards:
        Used: unknown (minor revision code 0x006d)
        Supported: 10 9 8 7 6 5
        Likely used: 10
[...]
</code></pre></div></div>

<p>As usual, I wanted to check if any firmware update is available. Toshiba’s <a href="https://www.canvio.jp/en/support/download/hdd/ot_ihdd/fw/en.htm">dedicated webpage</a> lists version <code>0602</code> as available for my model.</p>

<p>Unfortunately, as expected, there’s no firmware update process provided for Linux users, only an “Internal Storage Firmware Update Utility” is provided for Windows.</p>

<p>Update files are not provided either.</p>

<h3 id="goals">Goals</h3>

<p>So, our goals are:</p>

<ul>
  <li>understand where the updater gets its update files from</li>
  <li>reverse engineer the flashing process itself to reimplement it on Linux</li>
</ul>

<h2 id="reversing-the-windows-updater">Reversing the Windows Updater</h2>

<h3 id="intro">Intro</h3>

<p>Running the <a href="https://www.canvio.jp/en/support/download/hdd/ot_ihdd/fw/exe/InternalStorageFwUpdateUtility_1.20.0410.exe">installer</a><sup id="fnref:1" role="doc-noteref"><a href="#fn:1" rel="footnote">1</a></sup> with Wine works perfectly, resulting in the following files being installed under <code>Program Files (x86)</code>:</p>

<div><div><pre><code>  18312 ISFw.exe:        PE32 executable (native) Intel 80386, for MS Windows, 4 sections
2434952 TosISFw.exe:     PE32 executable (GUI) Intel 80386, for MS Windows, 5 sections
2172296 TosISFwSvc.exe:  PE32 executable (GUI) Intel 80386, for MS Windows, 5 sections
2362248 TosISFwTray.exe: PE32 executable (GUI) Intel 80386, for MS Windows, 5 sections
</code></pre></div></div>

<p>A quick look (filename, imports) hints at the following goals for each program:</p>

<ul>
  <li><code>ISFW.exe</code> is a driver (<code>DriverEntry</code> export), probably in charge of effectively flashing the update.</li>
  <li><code>TosISFw.exe</code> is the GUI</li>
  <li><code>TosISFwSvc.exe</code> is the userland service (as the service related imports show)</li>
  <li><code>TosISFwTray.exe</code> most probably handles a tray icon</li>
</ul>

<h3 id="finding-the-update-files">Finding the update files</h3>

<p>The obvious move is too grep for URLs in the various installed binaries. Unfortunately, it leads nowhere apart from URLs related to the digital signatures. However, grepping for <code>HttpOpenRequest</code>, an API often used by Windows programs to download files, gives two results: <code>TosISFw.exe</code> and <code>TosISFwSvc.exe</code>.</p>

<p>Let’s look at <code>TosISFwSvc.exe</code> which is smaller and let’s see if we can find the URL by checking the xrefs.</p>

<p>The call is in the function at 0x00401040, and looks like this:</p>

<div><div><pre><code><span>v15</span> <span>=</span> <span>HttpOpenRequestW</span><span>(</span><span>v14</span><span>,</span> <span>L&#34;GET&#34;</span><span>,</span> <span>&amp;</span><span>v36</span><span>[(</span><span>_DWORD</span><span>)</span><span>lpBuffer</span><span>],</span> <span>0</span><span>,</span> <span>(</span><span>LPCWSTR</span><span>)</span><span>szReferrer</span><span>,</span> <span>0</span><span>,</span> <span>0x84000000</span><span>,</span> <span>0</span><span>);</span>
</code></pre></div></div>

<p>the function is obviously a “download” helper, as all the API calls show. Let’s rename it <code>dlfile</code>. There are only two Xrefs to dlfile:</p>

<div><div><pre><code><span>if</span> <span>(</span> <span>!</span><span>RegOpenKeyExW</span><span>(</span>
        <span>HKEY_LOCAL_MACHINE</span><span>,</span>
        <span>L&#34;SYSTEM</span><span>\\</span><span>CurrentControlSet</span><span>\\</span><span>Services</span><span>\\</span><span>TosISFwSvc&#34;</span><span>,</span>
        <span>0</span><span>,</span>
        <span>0x20019u</span><span>,</span>
        <span>&amp;</span><span>phkResult</span><span>)</span>
  <span>&amp;&amp;</span> <span>readregstring</span><span>((</span><span>LPBYTE</span><span>)</span><span>&amp;</span><span>String</span><span>,</span> <span>&amp;</span><span>phkResult</span><span>,</span> <span>L&#34;FwURL&#34;</span><span>)</span>
  <span>&amp;&amp;</span> <span>lstrlenW</span><span>(</span><span>&amp;</span><span>String</span><span>)</span> <span>)</span>
<span>{</span>
  <span>sub_401000</span><span>();</span>
  <span>LOBYTE</span><span>(</span><span>v47</span><span>)</span> <span>=</span> <span>2</span><span>;</span>
  <span>if</span> <span>(</span> <span>dlfile</span><span>(</span><span>&amp;</span><span>String</span><span>,</span> <span>(</span><span>int</span><span>)</span><span>v38</span><span>)</span> <span>)</span>


<span>[...]</span>

<span>sub_4052E0</span><span>(</span><span>&amp;</span><span>lpValueName</span><span>,</span> <span>L&#34;%s%d&#34;</span><span>,</span> <span>L&#34;URL&#34;</span><span>,</span> <span>phkResult</span><span>);</span>
<span>v25</span> <span>=</span> <span>0</span><span>;</span>
<span>if</span> <span>(</span> <span>!</span><span>RegOpenKeyExW</span><span>(</span>
        <span>HKEY_LOCAL_MACHINE</span><span>,</span>
        <span>L&#34;SYSTEM</span><span>\\</span><span>CurrentControlSet</span><span>\\</span><span>Services</span><span>\\</span><span>TosISFwSvc&#34;</span><span>,</span>
        <span>0</span><span>,</span>
        <span>0x20019u</span><span>,</span>
        <span>&amp;</span><span>v25</span><span>)</span>
  <span>&amp;&amp;</span> <span>readregstring</span><span>((</span><span>LPBYTE</span><span>)</span><span>&amp;</span><span>String</span><span>,</span> <span>&amp;</span><span>v25</span><span>,</span> <span>lpValueName</span><span>)</span>
  <span>&amp;&amp;</span> <span>lstrlenW</span><span>(</span><span>&amp;</span><span>String</span><span>)</span>
  <span>&amp;&amp;</span> <span>dlfile</span><span>(</span><span>&amp;</span><span>String</span><span>,</span> <span>(</span><span>int</span><span>)</span><span>v36</span><span>)</span> <span>)</span>
</code></pre></div></div>

<p>The first one gives us our answer: the URL is stored in the registry. It’s actually written by the InstallShield setup.</p>

<p><a href="https://effectivetypescript.com/blog/public/toshiba/regedit.png"><img src="https://effectivetypescript.com/blog/public/toshiba/regedit.png" alt="disk"/></a></p>

<p>The value is <code>http://www.canvio.jp/en/support/download/hdd/ot_ihdd/fw/ISFw.dat</code></p>

<h3 id="parsing-the-update-file">Parsing the update file</h3>

<p>The file is an ini file, which is trivial to read and parse:</p>

<div><div><pre><code><span>[VERS]</span>
<span>VERSION</span><span>=</span><span>&#34;20240513&#34;</span>
<span>[Firmware]</span>
<span>0000</span><span>=</span><span>qa060378.ftd</span>
<span>0000model</span><span>=</span><span>&#34;TOSHIBA HDWG21E&#34;</span>
<span>0000rev</span><span>=</span><span>&#34;0603&#34;</span>
<span>0000rev0000</span><span>=</span><span>&#34;0601&#34;</span>
<span>0000native</span><span>=</span><span>0</span>
<span>0000option</span><span>=</span><span>0</span>
<span>0001</span><span>=</span><span>qa060378.ftd</span>
<span>0001model</span><span>=</span><span>&#34;TOSHIBA HDWG21C&#34;</span>
<span>0001rev</span><span>=</span><span>&#34;0603&#34;</span>
<span>0001rev0000</span><span>=</span><span>&#34;0601&#34;</span>
<span>0001native</span><span>=</span><span>0</span>
<span>0001option</span><span>=</span><span>0</span>
<span>[...]</span>
<span>0008</span><span>=</span><span>sk060202.ftd</span>
<span>0008model</span><span>=</span><span>&#34;TOSHIBA HDWG480 &#34;</span>
<span>0008rev</span><span>=</span><span>&#34;0602&#34;</span>
<span>0008rev0000</span><span>=</span><span>&#34;0601&#34;</span>
<span>0008native</span><span>=</span><span>0</span>
<span>0008option</span><span>=</span><span>0</span>
<span>[...]</span>
<span>; 905CBD24
</span></code></pre></div></div>

<p>in my case, the drive is number 8. What’s interesting is the checksum at the end. It’s the CRC32 of the file, minus the last 10 bytes, which can be easily checked with the <code>slice</code> and <code>crc32</code> tools of my hacking Swiss army knife <a href="https://github.com/trou/rsbkb">rsbkb</a>:</p>

<div><div><pre><code>$ slice -- ISFw.dat 0 -10 | crc32
905cbd24
</code></pre></div></div>

<p>Now obviously, let’s try to download the relevant file:</p>

<div><div><pre><code>$ wget https://www.canvio.jp/en/support/download/hdd/ot_ihdd/fw/sk060202.ftd
Resolving www.canvio.jp (www.canvio.jp)... 23.72.248.205, 23.72.248.202
Connecting to www.canvio.jp (www.canvio.jp)|23.72.248.205|:443... connected.
HTTP request sent, awaiting response... 200 OK
Length: 1171456 (1.1M)
[...]
</code></pre></div></div>

<p>Just for fun we can check if <a href="https://github.com/trou/cpu_rec_rs"><code>cpu_rec_rs</code></a> can identify any code in the binary:</p>

<div><div><pre><code><span>$</span><span> </span>~/tools/cpu_rec_rs/cpu_rec_rs sk060202.ftd
<span>Loading corpus from &#34;/home/trou/tools/cpu_rec_rs/cpu_rec_corpus/*.corpus&#34;
-------------------------------------------------
    File     |   Range    | Detected Architecture
-------------------------------------------------
sk060202.ftd | Whole file | ARMhf
-------------------------------------------------
</span></code></pre></div></div>

<p>So the firmware is probably running on an ARM SoC (it is).</p>

<h3 id="understanding-the-update-process">Understanding the update process</h3>

<p>Now, how is the file sent to the drive to actually perform the update? Recall that we have 4 binaries and we saw the <code>ISFW.exe</code> is actually a driver.</p>

<p>The <code>DriverEntry</code> function is actually extremely simple:</p>

<div><div><pre><code><span>NTSTATUS</span> <span>__stdcall</span> <span>DriverEntry</span><span>(</span><span>PDRIVER_OBJECT</span> <span>DriverObject</span><span>,</span> <span>PUNICODE_STRING</span> <span>RegistryPath</span><span>)</span>
<span>{</span>
  <span>int</span> <span>v2</span><span>;</span> <span>// eax</span>

  <span>readregistry</span><span>();</span>
  <span>v2</span> <span>=</span> <span>flashfirmware</span><span>();</span>
  <span>sub_1001812</span><span>(</span><span>v2</span> <span>%</span> <span>100</span> <span>==</span> <span>0</span><span>,</span> <span>1</span><span>,</span> <span>v2</span><span>);</span>
  <span>return</span> <span>NtTerminateProcess</span><span>((</span><span>HANDLE</span><span>)</span><span>0xFFFFFFFF</span><span>,</span> <span>0</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<p>I’ve already renamed <code>readregistry</code> and <code>flashfirmware</code> as the functions are easy to identify:</p>

<div><div><pre><code><span>char</span> <span>readregistry</span><span>()</span>
<span>{</span>
  <span>[...]</span>
  <span>RtlInitUnicodeString</span><span>(</span><span>&amp;</span><span>DestinationString</span><span>,</span> <span>L&#34;</span><span>\\</span><span>REGISTRY</span><span>\\</span><span>MACHINE</span><span>\\</span><span>SYSTEM</span><span>\\</span><span>CurrentControlSet</span><span>\\</span><span>Services</span><span>\\</span><span>TosISFwSvc&#34;</span><span>);</span>
  <span>[...]</span>
  <span>if</span> <span>(</span> <span>NtOpenKey</span><span>(</span><span>&amp;</span><span>KeyHandle</span><span>,</span> <span>0x20019u</span><span>,</span> <span>&amp;</span><span>ObjectAttributes</span><span>)</span> <span>&gt;=</span> <span>0</span> <span>)</span>
  <span>{</span>
    <span>RtlInitUnicodeString</span><span>(</span><span>&amp;</span><span>ValueName</span><span>,</span> <span>L&#34;FW_Serial&#34;</span><span>);</span>
    <span>if</span> <span>(</span> <span>NtQueryValueKey</span><span>(</span><span>KeyHandle</span><span>,</span> <span>&amp;</span><span>ValueName</span><span>,</span> <span>KeyValuePartialInformation</span><span>,</span> <span>KeyValueInformation</span><span>,</span> <span>0x800u</span><span>,</span> <span>&amp;</span><span>ResultLength</span><span>)</span> <span>&gt;=</span> <span>0</span> <span>)</span>
    <span>{</span>
      <span>memcpy</span><span>(</span><span>&amp;</span><span>fwserial</span><span>,</span> <span>&amp;</span><span>KeyValueInformation</span><span>[</span><span>3</span><span>],</span> <span>KeyValueInformation</span><span>[</span><span>2</span><span>]);</span>
       <span>[...]</span>
       <span>RtlInitUnicodeString</span><span>(</span><span>&amp;</span><span>ValueName</span><span>,</span> <span>L&#34;FW_CurRev&#34;</span><span>);</span>
       <span>memcpy</span><span>(</span><span>&amp;</span><span>fw_cur</span><span>,</span> <span>&amp;</span><span>KeyValueInformation</span><span>[</span><span>3</span><span>],</span> <span>KeyValueInformation</span><span>[</span><span>2</span><span>]);</span>
        <span>[...]</span>
        <span>RtlInitUnicodeString</span><span>(</span><span>&amp;</span><span>ValueName</span><span>,</span> <span>L&#34;FW_NewRev&#34;</span><span>);</span>
        <span>memcpy</span><span>(</span><span>fw_new</span><span>,</span> <span>&amp;</span><span>KeyValueInformation</span><span>[</span><span>3</span><span>],</span> <span>KeyValueInformation</span><span>[</span><span>2</span><span>]);</span>
          <span>[...]</span>
          <span>RtlInitUnicodeString</span><span>(</span><span>&amp;</span><span>ValueName</span><span>,</span> <span>L&#34;FW_Model&#34;</span><span>);</span>
          <span>memcpy</span><span>(</span><span>fw_model</span><span>,</span> <span>&amp;</span><span>KeyValueInformation</span><span>[</span><span>3</span><span>],</span> <span>KeyValueInformation</span><span>[</span><span>2</span><span>]);</span>
            <span>[...]</span>
            <span>RtlInitUnicodeString</span><span>(</span><span>&amp;</span><span>ValueName</span><span>,</span> <span>L&#34;FW_FWFile&#34;</span><span>);</span>
            <span>wmemcpy</span><span>(</span><span>path</span><span>,</span> <span>L&#34;</span><span>\\</span><span>??</span><span>\\</span><span>&#34;</span><span>,</span> <span>4</span><span>);</span>
            <span>memcpy</span><span>(</span><span>&amp;</span><span>path</span> <span>+</span> <span>4</span><span>,</span> <span>&amp;</span><span>KeyValueInformation</span><span>[</span><span>3</span><span>],</span> <span>KeyValueInformation</span><span>[</span><span>2</span><span>]);</span>
  <span>[...]</span>
<span>}</span>
</code></pre></div></div>

<p>Registry values (set by <code>TosISFwSvc.exe</code>) are read and copied into global variables, which I renamed according the registry value name.</p>

<p>Here’s the start of <code>flashfirmware</code>:</p>

<div><div><pre><code><span>int</span> <span>flashfirmware</span><span>()</span>
<span>{</span>
  <span>[...]</span>
  <span>Handle</span> <span>=</span> <span>0</span><span>;</span>
  <span>fwdata</span> <span>=</span> <span>0</span><span>;</span>
  <span>fwsize</span> <span>=</span> <span>0</span><span>;</span>
  <span>memset</span><span>(</span><span>&amp;</span><span>drivedata</span><span>,</span> <span>0</span><span>,</span> <span>sizeof</span><span>(</span><span>drivedata</span><span>));</span>
  <span>printf</span><span>(</span><span>L&#34;%s Firmware: %s -&gt; %s</span><span>\n</span><span>&#34;</span><span>,</span> <span>fw_model</span><span>,</span> <span>&amp;</span><span>fw_cur</span><span>,</span> <span>fw_new</span><span>);</span>
  <span>printf</span><span>(</span><span>L&#34;DO NOT TURN OFF THE PC WHILE ANY FIRMWARE UPDATE IS RUNNING.</span><span>\n</span><span>&#34;</span><span>);</span>
  <span>printf</span><span>(</span>
    <span>L&#34;Your device may become unusable if you do this and Toshiba is not </span><span>\n</span><span>&#34;</span>
     <span>&#34;responsible for any damage, including any necessary replacement of </span><span>\n</span><span>&#34;</span>
     <span>&#34;the unit, caused by your doing so.</span><span>\n</span><span>&#34;</span><span>);</span>
  <span>HeapHandle</span> <span>=</span> <span>RtlCreateHeap</span><span>(</span><span>2u</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>);</span>
  <span>if</span> <span>(</span> <span>HeapHandle</span> <span>)</span>
  <span>{</span>
    <span>status</span> <span>=</span> <span>readfile</span><span>(</span><span>&amp;</span><span>path</span><span>,</span> <span>&amp;</span><span>fwdata</span><span>,</span> <span>&amp;</span><span>fwsize</span><span>);</span>
    <span>if</span> <span>(</span> <span>!</span><span>(</span><span>status</span> <span>%</span> <span>100</span><span>)</span> <span>)</span>
    <span>{</span>
      <span>Handle</span> <span>=</span> <span>verifydisk</span><span>(</span><span>&amp;</span><span>fwserial</span><span>,</span> <span>&amp;</span><span>fw_cur</span><span>,</span> <span>fw_model</span><span>,</span> <span>&amp;</span><span>drivedata</span><span>);</span>
<span>[...]</span>
</code></pre></div></div>

<p><code>verifydisk</code> is very important, yet relatively simple (with everything already renamed):</p>

<div><div><pre><code><span>HANDLE</span> <span>__stdcall</span> <span>verifydisk</span><span>(</span><span>PCWSTR</span> <span>serial</span><span>,</span> <span>PCWSTR</span> <span>cur</span><span>,</span> <span>WCHAR</span> <span>*</span><span>model</span><span>,</span> <span>IDENTIFY_DEVICE_DATA</span> <span>*</span><span>devdata</span><span>)</span>
<span>{</span>
  <span>HANDLE</span> <span>hdl</span><span>;</span> <span>// edi</span>
  <span>UNICODE_STRING</span> <span>cur_</span><span>;</span> <span>// [esp+10h] [ebp-104h] BYREF</span>
  <span>struct</span> <span>_UNICODE_STRING</span> <span>serial_</span><span>;</span> <span>// [esp+18h] [ebp-FCh] BYREF</span>
  <span>UNICODE_STRING</span> <span>model_from_drive_u</span><span>;</span> <span>// [esp+20h] [ebp-F4h] BYREF</span>
  <span>UNICODE_STRING</span> <span>serial_from_drive_u</span><span>;</span> <span>// [esp+28h] [ebp-ECh] BYREF</span>
  <span>UNICODE_STRING</span> <span>model_</span><span>;</span> <span>// [esp+30h] [ebp-E4h] BYREF</span>
  <span>UNICODE_STRING</span> <span>fwrev_from_drive_u</span><span>;</span> <span>// [esp+38h] [ebp-DCh] BYREF</span>
  <span>DWORD</span> <span>*</span><span>drivenumber</span><span>;</span> <span>// [esp+40h] [ebp-D4h]</span>
  <span>HANDLE</span> <span>hdl_</span><span>;</span> <span>// [esp+44h] [ebp-D0h]</span>
  <span>char</span> <span>v14</span><span>;</span> <span>// [esp+4Bh] [ebp-C9h] BYREF</span>
  <span>WCHAR</span> <span>model_from_drive</span><span>[</span><span>50</span><span>];</span> <span>// [esp+4Ch] [ebp-C8h] BYREF</span>
  <span>WCHAR</span> <span>serial_from_drive</span><span>[</span><span>30</span><span>];</span> <span>// [esp+B0h] [ebp-64h] BYREF</span>
  <span>WCHAR</span> <span>fwrev_from_drive</span><span>[</span><span>18</span><span>];</span> <span>// [esp+ECh] [ebp-28h] BYREF</span>

  <span>[...]</span>
  <span>for</span> <span>(</span> <span>drivenumber</span> <span>=</span> <span>0</span><span>;</span> <span>(</span><span>unsigned</span> <span>int</span><span>)</span><span>drivenumber</span> <span>&lt;</span> <span>0x20</span><span>;</span> <span>drivenumber</span> <span>=</span> <span>(</span><span>DWORD</span> <span>*</span><span>)((</span><span>char</span> <span>*</span><span>)</span><span>drivenumber</span> <span>+</span> <span>1</span><span>)</span> <span>)</span>
  <span>{</span>
    <span>[...]</span>
    <span>hdl</span> <span>=</span> <span>opendrive</span><span>((</span><span>char</span><span>)</span><span>drivenumber</span><span>);</span>
    <span>if</span> <span>(</span> <span>!</span><span>hdl</span> <span>)</span>
      <span>break</span><span>;</span>
    <span>if</span> <span>(</span> <span>!</span><span>getdevprop</span><span>(</span><span>hdl</span><span>,</span> <span>&amp;</span><span>bustype</span><span>)</span> <span>||</span> <span>bustype</span> <span>==</span> <span>BusTypeUsb</span> <span>)</span> <span>{</span>
      <span>NtClose</span><span>(</span><span>hdl</span><span>);</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>if</span> <span>(</span> <span>get_IDENTIFY_DEVICE_DATA</span><span>(</span><span>hdl_</span><span>,</span> <span>devdata</span><span>,</span> <span>0x200u</span><span>)</span> <span>)</span> <span>{</span>
        <span>get_drive_serial</span><span>(</span><span>devdata</span><span>,</span> <span>serial_from_drive</span><span>,</span> <span>30</span><span>,</span> <span>1</span><span>);</span>
        <span>get_drive_fw_rev</span><span>(</span><span>devdata</span><span>,</span> <span>fwrev_from_drive</span><span>,</span> <span>18</span><span>,</span> <span>1</span><span>);</span>
        <span>get_drive_model</span><span>(</span><span>devdata</span><span>,</span> <span>model_from_drive</span><span>,</span> <span>50</span><span>,</span> <span>1</span><span>);</span>
        <span>RtlInitUnicodeString</span><span>(</span><span>&amp;</span><span>serial_from_drive_u</span><span>,</span> <span>serial_from_drive</span><span>);</span>
        <span>RtlInitUnicodeString</span><span>(</span><span>&amp;</span><span>fwrev_from_drive_u</span><span>,</span> <span>fwrev_from_drive</span><span>);</span>
        <span>RtlInitUnicodeString</span><span>(</span><span>&amp;</span><span>model_from_drive_u</span><span>,</span> <span>model_from_drive</span><span>);</span>
        <span>if</span> <span>(</span> <span>RtlEqualUnicodeString</span><span>(</span><span>&amp;</span><span>serial_</span><span>,</span> <span>&amp;</span><span>serial_from_drive_u</span><span>,</span> <span>0</span><span>)</span> <span>)</span>
        <span>{</span>
          <span>if</span> <span>(</span> <span>RtlEqualUnicodeString</span><span>(</span><span>&amp;</span><span>cur_</span><span>,</span> <span>&amp;</span><span>fwrev_from_drive_u</span><span>,</span> <span>0</span><span>)</span>
            <span>&amp;&amp;</span> <span>RtlEqualUnicodeString</span><span>(</span><span>&amp;</span><span>model_</span><span>,</span> <span>&amp;</span><span>model_from_drive_u</span><span>,</span> <span>0</span><span>)</span> <span>)</span>
          <span>{</span>
            <span>return</span> <span>hdl_</span><span>;</span>
          <span>}</span>
        <span>}</span>
      <span>}</span>
      <span>NtClose</span><span>(</span><span>hdl_</span><span>);</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> <span>0</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<h3 id="interacting-with-the-drive">Interacting with the drive</h3>

<h4 id="verifying-the-drive-type">Verifying the drive type</h4>

<p>Let’s dive into the <code>opendrive</code> and <code>getdevprop</code> functions:</p>

<div><div><pre><code><span>HANDLE</span> <span>__stdcall</span> <span>opendrive</span><span>(</span><span>char</span> <span>Args</span><span>)</span>
<span>{</span>
  <span>[...]</span>
  <span>HANDLE</span> <span>FileHandle</span><span>;</span> <span>// [esp+30h] [ebp-88h] BYREF</span>
  <span>WCHAR</span> <span>SourceString</span><span>[</span><span>64</span><span>];</span> <span>// [esp+34h] [ebp-84h] BYREF</span>

  <span>DestinationString</span><span>.</span><span>Length</span> <span>=</span> <span>0</span><span>;</span>
  <span>*</span><span>(</span><span>_DWORD</span> <span>*</span><span>)</span><span>&amp;</span><span>DestinationString</span><span>.</span><span>MaximumLength</span> <span>=</span> <span>0</span><span>;</span>
  <span>HIWORD</span><span>(</span><span>DestinationString</span><span>.</span><span>Buffer</span><span>)</span> <span>=</span> <span>0</span><span>;</span>
  <span>memset</span><span>(</span><span>SourceString</span><span>,</span> <span>0</span><span>,</span> <span>sizeof</span><span>(</span><span>SourceString</span><span>));</span>
  <span>FileHandle</span> <span>=</span> <span>0</span><span>;</span>
  <span>wsprintf</span><span>(</span><span>SourceString</span><span>,</span> <span>64</span><span>,</span> <span>(</span><span>wchar_t</span> <span>*</span><span>)</span><span>L&#34;</span><span>\\</span><span>??</span><span>\\</span><span>PhysicalDrive%u&#34;</span><span>,</span> <span>Args</span><span>);</span>
  <span>RtlInitUnicodeString</span><span>(</span><span>&amp;</span><span>DestinationString</span><span>,</span> <span>SourceString</span><span>);</span>
  <span>[...]</span>
  <span>NtOpenFile</span><span>(</span><span>&amp;</span><span>FileHandle</span><span>,</span> <span>0x100003u</span><span>,</span> <span>&amp;</span><span>ObjectAttributes</span><span>,</span> <span>&amp;</span><span>IoStatusBlock</span><span>,</span> <span>3u</span><span>,</span> <span>0x20u</span><span>);</span>
  <span>return</span> <span>FileHandle</span><span>;</span>
<span>}</span>

<span>char</span> <span>__stdcall</span> <span>getdevprop</span><span>(</span><span>HANDLE</span> <span>hdl</span><span>,</span> <span>char</span> <span>*</span><span>bustype</span><span>)</span>
<span>{</span>
  <span>char</span> <span>tmp</span><span>;</span> <span>// al</span>
  <span>struct</span> <span>_IO_STATUS_BLOCK</span> <span>IoStatusBlock</span><span>;</span> <span>// [esp+Ch] [ebp-1018h] BYREF</span>
  <span>char</span> <span>*</span><span>bustype_</span><span>;</span> <span>// [esp+14h] [ebp-1010h]</span>
  <span>HANDLE</span> <span>FileHandle</span><span>;</span> <span>// [esp+18h] [ebp-100Ch]</span>
  <span>char</span> <span>retvalue</span><span>;</span> <span>// [esp+1Fh] [ebp-1005h]</span>
  <span>STORAGE_DEVICE_DESCRIPTOR</span> <span>InputBuffer</span><span>;</span> <span>// [esp+20h] [ebp-1004h] BYREF</span>

  <span>FileHandle</span> <span>=</span> <span>hdl</span><span>;</span>
  <span>bustype_</span> <span>=</span> <span>bustype</span><span>;</span>
  <span>IoStatusBlock</span><span>.</span><span>Status</span> <span>=</span> <span>0</span><span>;</span>
  <span>IoStatusBlock</span><span>.</span><span>Information</span> <span>=</span> <span>0</span><span>;</span>
  <span>retvalue</span> <span>=</span> <span>0</span><span>;</span>
  <span>memset</span><span>(</span><span>&amp;</span><span>InputBuffer</span><span>,</span> <span>0</span><span>,</span> <span>0x1000u</span><span>);</span>
  <span>if</span> <span>(</span> <span>NtDeviceIoControlFile</span><span>(</span> <span>hdl</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>&amp;</span><span>IoStatusBlock</span><span>,</span>
        <span>IOCTL_STORAGE_QUERY_PROPERTY</span><span>,</span>
         <span>&amp;</span><span>InputBuffer</span><span>,</span> <span>0x1000u</span><span>,</span> <span>&amp;</span><span>InputBuffer</span><span>,</span> <span>0x1000u</span><span>)</span> <span>&lt;</span> <span>0</span> <span>)</span> <span>{</span>
    <span>tmp</span> <span>=</span> <span>0</span><span>;</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>tmp</span> <span>=</span> <span>InputBuffer</span><span>.</span><span>BusType</span><span>;</span>
    <span>retvalue</span> <span>=</span> <span>1</span><span>;</span>
  <span>}</span>
  <span>if</span> <span>(</span> <span>bustype_</span> <span>)</span>
    <span>*</span><span>bustype_</span> <span>=</span> <span>tmp</span><span>;</span>
  <span>return</span> <span>retvalue</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p><code>opendrive</code> returns a handle on a given <code>PhysicalDrive</code>, which is then used by <code>getdevprop</code>’s <a href="https://learn.microsoft.com/en-us/windows/win32/api/winternl/nf-winternl-ntdeviceiocontrolfile"><code>NtDeviceIoControlFile</code></a>.
Using IDA’s “standard enums”, I remapped <code>0x2D1400</code> to its readable definition: <a href="https://learn.microsoft.com/en-us/windows/win32/api/winioctl/ni-winioctl-ioctl_storage_query_property"><code>IOCTL_STORAGE_QUERY_PROPERTY</code></a>.</p>

<p>As <code>InputBuffer</code> is set to 0 before the call, the returned data is a <code>STORAGE_DEVICE_DESCRIPTOR</code> structure, which is used by <code>verifydisk</code> to verify if the drive is connected through USB (<code>BusTypeUsb</code>) and bails out if that’s the case.</p>

<h4 id="verifying-the-drive-model">Verifying the drive model</h4>

<p><code>get_IDENTIFY_DEVICE_DATA</code> is then called by <code>verifydisk</code>:</p>

<div><div><pre><code><span>char</span> <span>__stdcall</span> <span>get_IDENTIFY_DEVICE_DATA</span><span>(</span><span>HANDLE</span> <span>hdl</span><span>,</span> <span>void</span> <span>*</span><span>buff</span><span>,</span> <span>size_t</span> <span>Size</span><span>)</span>
<span>{</span>
  <span>struct</span> <span>_IO_STATUS_BLOCK</span> <span>IoStatusBlock</span><span>;</span> <span>// [esp+Ch] [ebp-3Ch] BYREF</span>
  <span>HANDLE</span> <span>FileHandle</span><span>;</span> <span>// [esp+14h] [ebp-34h]</span>
  <span>char</span> <span>v6</span><span>;</span> <span>// [esp+1Bh] [ebp-2Dh]</span>
  <span>ATA_PASS_THROUGH_DIRECT</span> <span>InputBuffer</span><span>;</span> <span>// [esp+1Ch] [ebp-2Ch] BYREF</span>

  <span>FileHandle</span> <span>=</span> <span>hdl</span><span>;</span>
  <span>IoStatusBlock</span><span>.</span><span>Status</span> <span>=</span> <span>0</span><span>;</span>
  <span>v6</span> <span>=</span> <span>0</span><span>;</span>
  <span>IoStatusBlock</span><span>.</span><span>Information</span> <span>=</span> <span>0</span><span>;</span>
  <span>memset</span><span>(</span><span>buff</span><span>,</span> <span>0</span><span>,</span> <span>Size</span><span>);</span>
  <span>memset</span><span>(</span><span>&amp;</span><span>InputBuffer</span><span>,</span> <span>0</span><span>,</span> <span>sizeof</span><span>(</span><span>InputBuffer</span><span>));</span>
  <span>InputBuffer</span><span>.</span><span>Length</span> <span>=</span> <span>0x28</span><span>;</span>
  <span>InputBuffer</span><span>.</span><span>AtaFlags</span> <span>=</span> <span>ATA_FLAGS_DRDY_REQUIRED</span><span>|</span><span>ATA_FLAGS_DATA_IN</span><span>|</span><span>ATA_FLAGS_NO_MULTIPLE</span><span>;</span>
  <span>InputBuffer</span><span>.</span><span>DataTransferLength</span> <span>=</span> <span>Size</span><span>;</span>
  <span>InputBuffer</span><span>.</span><span>TimeOutValue</span> <span>=</span> <span>10</span><span>;</span>
  <span>InputBuffer</span><span>.</span><span>DataBuffer</span> <span>=</span> <span>buff</span><span>;</span>
  <span>InputBuffer</span><span>.</span><span>CurrentTaskFile</span><span>[</span><span>reg_Command</span><span>]</span> <span>=</span> <span>0xEC</span><span>;</span>
  <span>if</span> <span>(</span> <span>NtDeviceIoControlFile</span><span>(</span><span>hdl</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>&amp;</span><span>IoStatusBlock</span><span>,</span>
         <span>IOCTL_ATA_PASS_THROUGH_DIRECT</span><span>,</span>
         <span>&amp;</span><span>InputBuffer</span><span>,</span> <span>0x28u</span><span>,</span> <span>&amp;</span><span>InputBuffer</span><span>,</span> <span>0x28u</span><span>)</span> <span>&gt;=</span> <span>0</span>
    <span>&amp;&amp;</span> <span>(</span><span>InputBuffer</span><span>.</span><span>CurrentTaskFile</span><span>[</span><span>reg_Status</span><span>]</span> <span>&amp;</span> <span>9</span><span>)</span> <span>==</span> <span>0</span> <span>)</span>
  <span>{</span>
    <span>return</span> <span>1</span><span>;</span>
  <span>}</span>
  <span>return</span> <span>v6</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p><code>NtDeviceIoControlFile</code> is now used with <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddscsi/ni-ntddscsi-ioctl_ata_pass_through_direct"><code>IOCTL_ATA_PASS_THROUGH_DIRECT</code></a>, which as the name implies, sends a raw ATA command to the drive. Actually understanding the request is a bit complex as the <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddscsi/ns-ntddscsi-_ata_pass_through_direct"><code>ATA_PASS_THROUGH_DIRECT</code></a> structure specifies both data buffers and “registers” through the <code>CurrentTaskFile</code> field.</p>

<p><code>CurrentTaskFile</code> is an array used to index 8 registers, both as input and output. Using the documentation, we can create two enums to use in IDA:</p>

<div><div><pre><code><span>enum</span> <span>ATA_INPUT_REGISTERS</span> <span>:</span> <span>__int32</span>
<span>{</span>
  <span>reg_Features</span> <span>=</span> <span>0x0</span><span>,</span>
  <span>reg_Sector_Count_in</span> <span>=</span> <span>0x1</span><span>,</span>
  <span>reg_Sector_Number_in</span> <span>=</span> <span>0x2</span><span>,</span>
  <span>reg_Cylinder_Low_in</span> <span>=</span> <span>0x3</span><span>,</span>
  <span>reg_Cylinder_High_in</span> <span>=</span> <span>0x4</span><span>,</span>
  <span>reg_Device_Head_in</span> <span>=</span> <span>0x5</span><span>,</span>
  <span>reg_Command</span> <span>=</span> <span>0x6</span><span>,</span>
  <span>reg_Reserved</span> <span>=</span> <span>0x7</span><span>,</span>
<span>};</span>

<span>enum</span> <span>ATA_OUTPUT_REGISTERS</span> <span>:</span> <span>__int32</span>
<span>{</span>
  <span>reg_Error</span> <span>=</span> <span>0x0</span><span>,</span>
  <span>reg_Sector_Count_out</span> <span>=</span> <span>0x1</span><span>,</span>
  <span>reg_Sector_Number_out</span> <span>=</span> <span>0x2</span><span>,</span>
  <span>reg_Cylinder_Low_out</span> <span>=</span> <span>0x3</span><span>,</span>
  <span>reg_Cylinder_High_out</span> <span>=</span> <span>0x4</span><span>,</span>
  <span>reg_Device_Head_out</span> <span>=</span> <span>0x5</span><span>,</span>
  <span>reg_Status</span> <span>=</span> <span>0x6</span><span>,</span>
  <span>reg_Reserved_out</span> <span>=</span> <span>0x7</span><span>,</span>
<span>};</span>
</code></pre></div></div>

<p>So the command here is <code>0xEC</code>. The ATA/ATAPI command set specification, found <a href="https://read.seas.harvard.edu/cs161/2024/pdf/ata-atapi-8.pdf">here</a>, describes the <code>IDENTIFY DEVICE – ECh, PIO Data-In</code> command, which returns a <em>lot</em> of data. Thankfully, Microsoft gives us the <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ata/ns-ata-_identify_device_data"><code>IDENTIFY_DEVICE_DATA</code></a> structure which has everything.</p>

<p>The following code then verify we have the “right” drive by comparing the serial, model and firmware version from the returned data to the ones stored in the registry.</p>

<div><div><pre><code><span>int</span> <span>__stdcall</span> <span>get_drive_serial</span><span>(</span><span>IDENTIFY_DEVICE_DATA</span> <span>*</span><span>drivedata</span><span>,</span> <span>wchar_t</span> <span>*</span><span>dest</span><span>,</span> <span>int</span> <span>destlen</span><span>,</span> <span>char</span> <span>stripflag</span><span>)</span>
<span>{</span>
  <span>return</span> <span>(</span><span>int</span><span>)</span><span>getdrive_data_string</span><span>(</span> <span>drivedata</span><span>,</span> <span>dest</span><span>,</span> <span>destlen</span><span>,</span>
                <span>offsetof</span><span>(</span><span>IDENTIFY_DEVICE_DATA</span><span>,</span> <span>SerialNumber</span><span>),</span> <span>20</span><span>,</span>
                <span>stripflag</span><span>);</span>
<span>}</span>

  <span>[...]</span>
  <span>get_drive_serial</span><span>(</span><span>devdata</span><span>,</span> <span>serial_from_drive</span><span>,</span> <span>30</span><span>,</span> <span>1</span><span>);</span>
  <span>[...]</span>
  <span>RtlInitUnicodeString</span><span>(</span><span>&amp;</span><span>serial_from_drive_u</span><span>,</span> <span>serial_from_drive</span><span>);</span>
  <span>[...]</span>
  <span>if</span> <span>(</span> <span>RtlEqualUnicodeString</span><span>(</span><span>&amp;</span><span>serial_</span><span>,</span> <span>&amp;</span><span>serial_from_drive_u</span><span>,</span> <span>0</span><span>)</span> <span>)</span>
        <span>{</span>
          <span>if</span> <span>(</span> <span>RtlEqualUnicodeString</span><span>(</span><span>&amp;</span><span>cur_</span><span>,</span> <span>&amp;</span><span>fwrev_from_drive_u</span><span>,</span> <span>0</span><span>)</span>
            <span>&amp;&amp;</span> <span>RtlEqualUnicodeString</span><span>(</span><span>&amp;</span><span>model_</span><span>,</span> <span>&amp;</span><span>model_from_drive_u</span><span>,</span> <span>0</span><span>)</span> <span>)</span>
</code></pre></div></div>

<h4 id="actually-sending-the-firmware-file">Actually sending the firmware file</h4>

<p>Once the driver has identified and verified the disk is actually flashable, it proceeds with the actual update:</p>

<div><div><pre><code><span>[...]</span>
      <span>MaxBlocksPerDownloadMicrocodeMode03</span> <span>=</span> <span>drivedata</span><span>.</span><span>MaxBlocksPerDownloadMicrocodeMode03</span><span>;</span>
      <span>if</span> <span>(</span> <span>!</span><span>drivedata</span><span>.</span><span>MaxBlocksPerDownloadMicrocodeMode03</span> <span>||</span> <span>drivedata</span><span>.</span><span>MaxBlocksPerDownloadMicrocodeMode03</span> <span>==</span> <span>0xFFFF</span> <span>)</span> <span>{</span>
        <span>MaxBlocksPerDownloadMicrocodeMode03</span> <span>=</span> <span>128</span><span>;</span>
      <span>}</span> <span>else</span> <span>if</span> <span>(</span> <span>drivedata</span><span>.</span><span>MaxBlocksPerDownloadMicrocodeMode03</span> <span>&gt;=</span> <span>0x80u</span> <span>)</span> <span>{</span>
        <span>MaxBlocksPerDownloadMicrocodeMode03</span> <span>=</span> <span>128</span><span>;</span>
      <span>}</span>
      <span>if</span> <span>(</span> <span>MaxBlocksPerDownloadMicrocodeMode03</span> <span>&gt;=</span> <span>drivedata</span><span>.</span><span>MinBlocksPerDownloadMicrocodeMode03</span>
        <span>&amp;&amp;</span> <span>MaxBlocksPerDownloadMicrocodeMode03</span> <span>)</span> <span>{</span>
        <span>fwblocks</span> <span>=</span> <span>fwsize</span> <span>&gt;&gt;</span> <span>9</span><span>;</span>
        <span>fwblocks2</span> <span>=</span> <span>fwsize</span> <span>&gt;&gt;</span> <span>9</span><span>;</span>
        <span>v1</span> <span>=</span> <span>60</span><span>;</span>
        <span>do</span> <span>{</span>
          <span>printprogress</span><span>();</span>
          <span>wait</span><span>((</span><span>LARGE_INTEGER</span><span>)</span><span>500LL</span><span>);</span>
          <span>--</span><span>v1</span><span>;</span>
        <span>}</span> <span>while</span> <span>(</span> <span>v1</span> <span>);</span>
        <span>for</span> <span>(</span> <span>fwsize</span> <span>=</span> <span>0</span><span>;</span> <span>(</span><span>int</span><span>)</span><span>fwsize</span> <span>&lt;</span> <span>30</span><span>;</span> <span>++</span><span>fwsize</span> <span>)</span> <span>{</span>
          <span>currentblock</span> <span>=</span> <span>0</span><span>;</span>
          <span>status</span> <span>=</span> <span>6000</span><span>;</span>
          <span>if</span> <span>(</span> <span>fwblocks</span> <span>)</span> <span>{</span>
            <span>fwdata1</span> <span>=</span> <span>fwdata</span><span>;</span>
            <span>MaxBytesPerDL</span> <span>=</span> <span>MaxBlocksPerDownloadMicrocodeMode03</span> <span>&lt;&lt;</span> <span>9</span><span>;</span>
            <span>while</span> <span>(</span> <span>1</span> <span>)</span> <span>{</span>
              <span>printprogress</span><span>();</span>
              <span>blocks_to_flash</span> <span>=</span> <span>fwblocks2</span> <span>-</span> <span>currentblock</span><span>;</span>
              <span>if</span> <span>(</span> <span>MaxBlocksPerDownloadMicrocodeMode03</span> <span>&lt;</span> <span>fwblocks2</span> <span>-</span> <span>currentblock</span> <span>)</span>
                <span>blocks_to_flash</span> <span>=</span> <span>MaxBlocksPerDownloadMicrocodeMode03</span><span>;</span>
              <span>if</span> <span>(</span> <span>!</span><span>ATA_CMD_DOWNLOAD_MICRO</span><span>(</span><span>Handle</span><span>,</span> <span>currentblock</span><span>,</span> <span>blocks_to_flash</span><span>,</span> <span>fwdata1</span><span>)</span> <span>)</span>
                <span>break</span><span>;</span>
              <span>currentblock</span> <span>+=</span> <span>MaxBlocksPerDownloadMicrocodeMode03</span><span>;</span>
              <span>fwdata1</span> <span>+=</span> <span>MaxBytesPerDL</span><span>;</span>
              <span>if</span> <span>(</span> <span>currentblock</span> <span>&gt;=</span> <span>fwblocks2</span> <span>)</span>
                <span>goto</span> <span>LABEL_25</span><span>;</span>
            <span>}</span>
            <span>status</span> <span>=</span> <span>6009</span><span>;</span>
<span>LABEL_25:</span>
            <span>fwblocks</span> <span>=</span> <span>fwblocks2</span><span>;</span>
          <span>}</span>
          <span>if</span> <span>(</span> <span>!</span><span>(</span><span>status</span> <span>%</span> <span>100</span><span>)</span> <span>)</span>
            <span>break</span><span>;</span>
          <span>v5</span> <span>=</span> <span>2</span><span>;</span>
          <span>do</span> <span>{</span>
            <span>printprogress</span><span>();</span>
            <span>wait</span><span>((</span><span>LARGE_INTEGER</span><span>)</span><span>500LL</span><span>);</span>
            <span>--</span><span>v5</span><span>;</span>
          <span>}</span> <span>while</span> <span>(</span> <span>v5</span> <span>);</span>
        <span>}</span>
        <span>if</span> <span>(</span> <span>!</span><span>(</span><span>status</span> <span>%</span> <span>100</span><span>)</span> <span>)</span>
        <span>{</span>
          <span>if</span> <span>(</span> <span>get_IDENTIFY_DEVICE_DATA</span><span>(</span><span>Handle</span><span>,</span> <span>&amp;</span><span>drivedata</span><span>,</span> <span>0x200u</span><span>)</span> <span>)</span> <span>{</span>
            <span>get_drive_fw_rev</span><span>(</span><span>&amp;</span><span>drivedata</span><span>,</span> <span>newfwrev</span><span>,</span> <span>18</span><span>,</span> <span>1</span><span>);</span>
            <span>if</span> <span>(</span> <span>wcsncmp</span><span>(</span><span>fw_new</span><span>,</span> <span>newfwrev</span><span>,</span> <span>wcslen</span><span>(</span><span>fw_new</span><span>))</span> <span>)</span>
              <span>status</span> <span>=</span> <span>6011</span><span>;</span>
          <span>}</span> <span>else</span> <span>{</span>
            <span>status</span> <span>=</span> <span>6010</span><span>;</span>
          <span>}</span>
        <span>}</span>
      <span>}</span> <span>else</span> <span>{</span>
<span>LABEL_35:</span>
        <span>status</span> <span>=</span> <span>6006</span><span>;</span>
      <span>}</span>
  <span>[...]</span>
  <span>if</span> <span>(</span> <span>status</span> <span>%</span> <span>100</span> <span>)</span>
    <span>printf</span><span>(</span><span>L&#34;Update Failed.      </span><span>\n</span><span>&#34;</span><span>);</span>
  <span>else</span>
    <span>printf</span><span>(</span><span>L&#34;Update Succeeded.   </span><span>\n</span><span>&#34;</span><span>);</span>
</code></pre></div></div>

<p>As you can see, the updater verifies an interesting field from the drive information data: <code>MaxBlocksPerDownloadMicrocodeMode03</code>. Let’s check what this means.</p>

<h3 id="sending-ata-firmware-update-commands">Sending ATA firmware update commands</h3>

<h4 id="documentation">Documentation</h4>

<p>The following excerpt from the ATA command set describes the meaning of the field:</p>

<div><div><pre><code>A.11.5.3.4 DM MAXIMUM TRANSFER SIZE field
If:
a) the value of the DM MAXIMUM TRANSFER SIZE field (see table A.30) is greater than zero;
b) the value of the DM MAXIMUM TRANSFER SIZE field is less than FFFFh;
c) the DOWNLOAD MICROCODE SUPPORTED bit (see A.11.5.2.20) is set to one or the DOWNLOAD MICROCODE DMA SUPPORTED bit (see A.11.5.2.6) is set to one; and
d) the DM OFFSETS DEFERRED SUPPORTED bit (see A.11.5.3.1) is set to one, or the DM OFFSETS IMMEDIATE
SUPPORTED bit (see A.11.5.3.3) is set to one, then the DM MAXIMUM TRANSFER SIZE field indicates the maximum number of 512-byte data blocks permitted by a DOWNLOAD MICROCODE command (see 7.7) or a DOWNLOAD MICROCODE DMA command (see 7.8) that specifies a subcommand of:
a) Download with offsets and save microcode for immediate and future use (i.e., 03h); or
b) Download with offsets and save microcode for future use (i.e., 0Eh).
Otherwise, no maximum is indicated (i.e., there is no maximum number of 512-byte data blocks).
The IDENTIFY DEVICE data contains a copy of the DM MAXIMUM TRANSFER SIZE field (see IDENTIFY DEVICE
data word 235 in table 45).
</code></pre></div></div>

<p>Of course, we want to check this <code>DOWNLOAD MICROCODE</code> command:</p>

<div><div><pre><code>The DOWNLOAD MICROCODE command allows the host to alter the device’s microcode. The data transferred
using the DOWNLOAD MICROCODE command and the DOWNLOAD MICROCODE DMA command is vendor
specific.
[...]
Downloading and activating microcode involves the following steps:
1) download: the host transfers updated microcode data to the device in one or more DOWNLOAD
MICROCODE commands or DOWNLOAD MICROCODE DMA commands;
2) save: after receiving the complete updated microcode data, if specified by the download microcode
mode, then the device shall save the updated microcode data to nonvolatile storage; and
3) activate: the device begins using the saved or deferred microcode data for the first time after an event
specified by the download microcode mode and the saved or deferred microcode data becomes the
active microcode data.

The BLOCK COUNT field specifies the number of 512-byte data blocks that shall be transferred. The BLOCK COUNT
field is specified in the COUNT field and the LBA field (see table 37).
</code></pre></div></div>

<p><code>DOWNLOAD</code> Subcommands actually define the update behavior:</p>

<p><a href="https://effectivetypescript.com/blog/public/toshiba/download_subcommands.png"><img src="https://effectivetypescript.com/blog/public/toshiba/download_subcommands.png" alt="disk"/></a></p>

<h3 id="actual-code">Actual code</h3>

<div><div><pre><code><span>char</span> <span>ATA_CMD_DOWNLOAD_MICRO</span><span>(</span><span>HANDLE</span> <span>FileHandle</span><span>,</span> <span>__int16</span> <span>currentblock</span><span>,</span> <span>int</span> <span>blocks_to_flash</span><span>,</span> <span>void</span> <span>*</span><span>fwdata</span><span>)</span>
<span>{</span>
  <span>struct</span> <span>_IO_STATUS_BLOCK</span> <span>IoStatusBlock</span><span>;</span> <span>// [esp+Ch] [ebp-38h] BYREF</span>
  <span>char</span> <span>v6</span><span>;</span> <span>// [esp+17h] [ebp-2Dh]</span>
  <span>ATA_PASS_THROUGH_DIRECT</span> <span>InputBuffer</span><span>;</span> <span>// [esp+18h] [ebp-2Ch] BYREF</span>

  <span>IoStatusBlock</span><span>.</span><span>Status</span> <span>=</span> <span>0</span><span>;</span>
  <span>IoStatusBlock</span><span>.</span><span>Information</span> <span>=</span> <span>0</span><span>;</span>
  <span>memset</span><span>(</span><span>&amp;</span><span>InputBuffer</span><span>,</span> <span>0</span><span>,</span> <span>sizeof</span><span>(</span><span>InputBuffer</span><span>));</span>
  <span>InputBuffer</span><span>.</span><span>Length</span> <span>=</span> <span>0x28</span><span>;</span>
  <span>InputBuffer</span><span>.</span><span>AtaFlags</span> <span>=</span> <span>ATA_FLAGS_DRDY_REQUIRED</span><span>|</span><span>ATA_FLAGS_DATA_OUT</span><span>|</span><span>ATA_FLAGS_NO_MULTIPLE</span><span>;</span>
  <span>*</span><span>(</span><span>_WORD</span> <span>*</span><span>)</span><span>&amp;</span><span>InputBuffer</span><span>.</span><span>CurrentTaskFile</span><span>[</span><span>reg_Sector_Count_in</span><span>]</span> <span>=</span> <span>blocks_to_flash</span><span>;</span><span>// BLOCK COUNT</span>
  <span>*</span><span>(</span><span>_WORD</span> <span>*</span><span>)</span><span>&amp;</span><span>InputBuffer</span><span>.</span><span>CurrentTaskFile</span><span>[</span><span>reg_Cylinder_Low_in</span><span>]</span> <span>=</span> <span>currentblock</span><span>;</span><span>// BUFFER OFFSET</span>
  <span>v6</span> <span>=</span> <span>0</span><span>;</span>
  <span>InputBuffer</span><span>.</span><span>DataTransferLength</span> <span>=</span> <span>blocks_to_flash</span> <span>&lt;&lt;</span> <span>9</span><span>;</span>
  <span>InputBuffer</span><span>.</span><span>TimeOutValue</span> <span>=</span> <span>70</span><span>;</span>
  <span>InputBuffer</span><span>.</span><span>DataBuffer</span> <span>=</span> <span>fwdata</span><span>;</span>
  <span>InputBuffer</span><span>.</span><span>CurrentTaskFile</span><span>[</span><span>reg_Features</span><span>]</span> <span>=</span> <span>3</span><span>;</span><span>// mode 3</span>
  <span>InputBuffer</span><span>.</span><span>CurrentTaskFile</span><span>[</span><span>reg_Device_Head_in</span><span>]</span> <span>=</span> <span>0xE0</span><span>;</span><span>// OBSOLETE7|N/A|OBSOLETE5</span>
  <span>InputBuffer</span><span>.</span><span>CurrentTaskFile</span><span>[</span><span>reg_Command</span><span>]</span> <span>=</span> <span>IDE_COMMAND_DOWNLOAD_MICROCODE</span><span>;</span>
  <span>if</span> <span>(</span> <span>NtDeviceIoControlFile</span><span>(</span><span>FileHandle</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>&amp;</span><span>IoStatusBlock</span><span>,</span>
         <span>IOCTL_ATA_PASS_THROUGH_DIRECT</span><span>,</span>
         <span>&amp;</span><span>InputBuffer</span><span>,</span> <span>0x28u</span><span>,</span> <span>&amp;</span><span>InputBuffer</span><span>,</span> <span>0x28u</span><span>)</span> <span>&gt;=</span> <span>0</span>
    <span>&amp;&amp;</span> <span>(</span><span>InputBuffer</span><span>.</span><span>CurrentTaskFile</span><span>[</span><span>6</span><span>]</span> <span>&amp;</span> <span>9</span><span>)</span> <span>==</span> <span>0</span> <span>)</span><span>// status</span>
  <span>{</span>
    <span>return</span> <span>1</span><span>;</span>
  <span>}</span>
  <span>return</span> <span>v6</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>As you can see, the <code>ATA_CMD_DOWNLOAD_MICRO</code> just follows the specification. The only weird point is the <code>Device</code> register, which is basically obsolete, but is set to <code>0xE0</code>.
Just to be sure, I checked <code>hdparm</code> source code to see the value set in the command, and indeed, they also set it to <code>0xE0</code>, so it’s probably legacy cruft:</p>

<div><div><pre><code><span>enum</span> <span>{</span>
	<span>ATA_USING_LBA</span>		<span>=</span> <span>(</span><span>1</span> <span>&lt;&lt;</span> <span>6</span><span>),</span>
	<span>ATA_STAT_DRQ</span>		<span>=</span> <span>(</span><span>1</span> <span>&lt;&lt;</span> <span>3</span><span>),</span>
	<span>ATA_STAT_ERR</span>		<span>=</span> <span>(</span><span>1</span> <span>&lt;&lt;</span> <span>0</span><span>),</span>
<span>};</span>

    <span>[...]</span>
	<span>r</span><span>-&gt;</span><span>lob</span><span>.</span><span>dev</span>   <span>=</span> <span>0xa0</span> <span>|</span> <span>ATA_USING_LBA</span><span>;</span>
</code></pre></div></div>

<h3 id="conclusion">Conclusion</h3>

<p>So basically, the updater does:</p>

<ul>
  <li>download the list of updates</li>
  <li>check if a drive matches, set registry values</li>
  <li>the driver takes over and:
    <ul>
      <li>checks if the drive is not connected through USB</li>
      <li>verifies it’s the actual drive specified in the registry using the <code>IDENTIFY DEVICE</code> command</li>
      <li>loops and sends the firmware update, 128 512-bytes chunks at a time, using the <code>DOWNLOAD MICROCODE</code> command</li>
      <li>verifies the drive was updated using the <code>IDENTIFY DEVICE</code> command</li>
    </ul>
  </li>
</ul>

<h4 id="actually-doing-the-update">Actually doing the update</h4>

<p>YOLO, I tried on my main NAS drive:</p>

<div><div><pre><code><span># hdparm -I /dev/sdb | grep Firmware
</span>	<span>Firmware</span> <span>Revision</span><span>:</span>  <span>0601</span>
<span># hdparm --fwdownload-mode3 sk060202.ftd --yes-i-know-what-i-am-doing --please-destroy-my-drive /dev/sdb
</span><span>/</span><span>dev</span><span>/</span><span>sdb</span><span>:</span>
<span>fwdownload</span><span>:</span> <span>xfer_mode</span><span>=</span><span>3</span> <span>min</span><span>=</span><span>1</span> <span>max</span><span>=</span><span>4224</span> <span>size</span><span>=</span><span>512</span>
<span>...............................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................</span>
<span>.</span> <span>Done</span><span>.</span>
<span># hdparm -I /dev/sdb | grep Firmware
</span>	<span>Firmware</span> <span>Revision</span><span>:</span>  <span>0602</span>
</code></pre></div></div>

<p><strong>\o/</strong></p>



</div>

    </div></div>
  </body>
</html>
