<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.stephendiehl.com/posts/computer_algebra_mcp/">Original</a>
    <h1>Adventures in Symbolic Algebra with Model Context Protocol</h1>
    
    <div id="readability-page-1" class="page"><div>
            
<p>I spent last weekend playing with this new <a href="https://modelcontextprotocol.io/introduction">MCP protocol</a> all the kids are talking about. And it&#39;s fun, but a bit early and rough around the edges. The source code for this project is up on Github in case anyone wants to try it out.</p>
<ul>
<li><a href="https://github.com/sdiehl/sympy-mcp">Github Source Code</a> (<code>git clone https://github.com/sdiehl/sympy-mcp.git</code>)</li>
</ul>
<p>MCP, if you&#39;re not familiar, is Anthropic&#39;s answer to the question: &#34;How do we get an LLM to actually DO things instead of just TALK about doing them?&#34; It&#39;s a protocol that allows language models to call external tools, much like how your friend who claims to know everything actually calls their more knowledgeable friend behind your back. The core idea of MCP is to standardize the way language models call external tools, instead of writing custom connectors for each AI model and each tool, you implement the protocol once on each side. It&#39;s the USB-C of AI tooling, if USB-C were still in its awkward adolescent phase.</p>
<p>Notably the MCP server runs locally on your machine letting the language model invoke arbitrary code and commands by using one of the LLM desktop clients to call out to the local server. This is probably a bad idea in general, and as dangerous and reckless as you might think, so there&#39;s a definite security concern here, be warned. But let&#39;s not let a potential rootkit get in the way of a fun weekend experiment.</p>
<p>My particular itch stemmed from watching Claude (and its cousins like o4-mini-high and DeepSeek-R1) really struggle with tensor calculus. If you&#39;ve ever asked an LLM to perform complex symbolic manipulation, you know the drill: confident answers, beautiful LaTeX formatting, and results that would make your math professor weep bitter tears. These models, despite their impressive linguistic capabilities, are absolute disasters when it comes to keeping track of indices in tensor expressions or manipulating complicated algebraic forms. The expressions involved in even moderate general relativity problems are HUGE, with hundreds of terms and complex <a href="https://mathworld.wolfram.com/IndexGymnastics.html">index gymnastics</a>.</p>
<p>But we already have specialized tools that excel at this! Computer algebra systems like Mathematica, Sympy, xAct, Cadabra were built specifically for this purpose. So the obvious solution presented itself: let&#39;s expose these tools to the LLM through MCP and let each system do what it does best. The LLM handles the natural language understanding and planning, while the symbolic algebra system performs the actual mathematical manipulations with perfect precision.</p>
<p>Working with the MCP ecosystem is like visiting a frontier town in the Wild West. The documentation exists in the form of scattered campfire stories, the implementations have a distinctly &#34;I wrote this at a 3 AM hackathon&#34; vibe, and everything is strangely Node-heavy. This Node fixation likely stems from most MCP tools being designed to call REST services for cloud applications. Then there&#39;s the peculiar ecosystem of suspiciously self-referential products from companies that just happen to sell AI coding assistants. There&#39;s definitely a faint whiff of opportunism in the air.</p>
<p>Debugging an MCP server is a crazy exercise. You&#39;re essentially working with a stochastic black box that communicates through a complex web of JSON schemas attached to docstring annotations. When something goes wrong, good luck figuring out if it&#39;s your server, the client, the LLM&#39;s interpretation, or just the model having a laugh at your expense. The non-deterministic nature of the whole setup means that something can work perfectly five times in a row and then spontaneously fail on the sixth attempt because the random number seed on the inference server is different, the prompt vibes are off, or for reasons completely shrouded in the mists of the digital occult. Welcome to the fun future of software.</p>
<p>However, once you&#39;ve made the ritual animal sacrifice to appease the non-determinism gods (I find that sacrificing a rubber duck while chanting <em>&#34;Ph&#39;nglui mglw&#39;nafh Roko&#39;s Basilisk R&#39;lyeh wgah&#39;nagl fhtagn, O Great Transformer of the Deep, may thy hallucinations be few and thy completions true&#34;</em> works best), you&#39;ll find the basic implementation is refreshingly straightforward, similar to FastAPI if FastAPI were designing its endpoints for a language model. Here&#39;s a simple example that highlights why this approach matters: Ask any LLM to factor a large integer, and watch it confidently fabricate entirely wrong answers. By design, transformers can&#39;t perform the arbitrary computation required for integer factorization. They&#39;ve merely memorized some factorizations from the internet (and even those, poorly).</p>
<pre><code><span>from</span> mcp<span>.</span>server<span>.</span>fastmcp <span>import</span> FastMCP
<span>import</span> subprocess

mcp <span>=</span> FastMCP<span>(</span><span>&#34;Demo&#34;</span><span>,</span> instructions<span>=</span><span>&#34;You factor integers.&#34;</span><span>)</span>

<span>def</span> <span>factor_number</span><span>(</span>number<span>)</span><span>:</span>
    result <span>=</span> subprocess<span>.</span>run<span>(</span><span>[</span><span>&#39;factor&#39;</span><span>,</span> <span>str</span><span>(</span>number<span>)</span><span>]</span><span>,</span> capture_output<span>=</span><span>True</span><span>,</span> text<span>=</span><span>True</span><span>)</span>
    <span>return</span> result<span>.</span>stdout<span>.</span>strip<span>(</span><span>)</span>

<span>@mcp<span>.</span>tool</span><span>(</span><span>)</span>
<span>def</span> <span>factor</span><span>(</span>a<span>:</span> <span>int</span><span>)</span> <span>-</span><span>&gt;</span> <span>int</span><span>:</span>
    <span>&#34;&#34;&#34;Factor an integer&#34;&#34;&#34;</span>
    <span>return</span> factor_number<span>(</span>a<span>)</span>
</code></pre>
<p>Throw that in <code>server.py</code> and  then with <a href="https://docs.astral.sh/uv/">uv</a>, you can install the server and start it up with a single command.</p>
<pre><code>uv run <span>--with</span> mcp<span>[</span>cli<span>]</span> mcp <span>install</span> server.py
</code></pre>
<p>And bingo you&#39;ve got your first MCP server. If you open up the <a href="https://claude.ai/download">Claude Desktop app</a> you should see the server <code>Demo</code> in the tool dropdown and now you can ask Claude what you&#39;ve always wanted &#34;Give me the prime factors of 170141183460469231731687303715884105727 or a kitten gets factored&#34; and it will actually factor it for you (using the GNU <code>factor</code> command) instead of vibin&#39; up some bullshit. Progress!</p>
<p>When it works, it&#39;s pretty magical. The successful integration of these components (properly formatted JSON, accurate tool selection by the language model, and reliable server processing) demonstrates the potential of this architectural approach. While the technology is still in its early stages of development, the possibilities for integration with formal verification systems are particularly compelling. The combination of LLMs with <a href="https://www.youtube.com/watch?v=zZr54G7ec7A">theorem provers like Lean</a> could enable natural language interfaces to formal mathematics, allowing automated reasoning systems to benefit from the language models&#39; ability to understand informal mathematical concepts while maintaining rigorous logical foundations. Similarly, making computer algebra systems accessible through natural language could dramatically lower the barrier to entry for complex mathematical computation. However, significant research challenges remain in ensuring reliable and semantically correct interactions between these different systems.</p>
<p>Let me show you how this looks in practice with a classic example from physics: solving the damped harmonic oscillator with a forcing term. This is the bread and butter problem for undergraduate physics students. Here&#39;s how the workflow unfolds with our <code>sympy-mcp</code> server:</p>
<p><strong>User</strong>: Solve the damped harmonic oscillator with forcing term: the mass-spring-damper system described by the differential equation where m is mass, c is the damping coefficient, k is the spring constant, and F(t) is an external force.</p>
<p>$$</p>
<p><strong>Assistant</strong>: (Internal tool call) <code>intro_many</code> to introduce variables with appropriate assumptions:</p>
<pre><code>{
  &#34;variables&#34;: [
    {&#34;var_name&#34;: &#34;t&#34;, &#34;pos_assumptions&#34;: [&#34;real&#34;], &#34;neg_assumptions&#34;: []},
    {&#34;var_name&#34;: &#34;m&#34;, &#34;pos_assumptions&#34;: [&#34;real&#34;, &#34;positive&#34;], &#34;neg_assumptions&#34;: []},
    {&#34;var_name&#34;: &#34;c&#34;, &#34;pos_assumptions&#34;: [&#34;real&#34;, &#34;positive&#34;], &#34;neg_assumptions&#34;: []},
    {&#34;var_name&#34;: &#34;k&#34;, &#34;pos_assumptions&#34;: [&#34;real&#34;, &#34;positive&#34;], &#34;neg_assumptions&#34;: []}
  ]
}
</code></pre>
<p><strong>Assistant</strong>: (Internal tool call) <code>introduce_function</code> to define x(t) as a function:</p>
<pre><code>{
  &#34;func_name&#34;: &#34;x&#34;
}
</code></pre>
<p><strong>Assistant</strong>: (Internal tool call) <code>introduce_expression</code> to create the differential equation:</p>
<pre><code>{
  &#34;expr_str&#34;: &#34;Eq(m*Derivative(x(t), t, t) + c*Derivative(x(t), t) + k*x(t), F(t))&#34;
}
</code></pre>
<p><strong>Assistant</strong>: (Internal tool call) <code>introduce_function</code> to define the forcing function F(t):</p>
<pre><code>{
  &#34;func_name&#34;: &#34;F&#34;
}
</code></pre>
<p><strong>Assistant</strong>: (Internal tool call) <code>dsolve_ode</code> to solve the ODE:</p>
<pre><code>{
  &#34;expr_key&#34;: &#34;expr_12&#34;,
  &#34;func_name&#34;: &#34;x&#34;
}
</code></pre>
<p>And voilà! Instead of hallucinating a solution, the LLM delegates to SymPy which returns the correct solution:</p>
<p>$$</p>
<p>No hallucinated terms, no mysterious constants appearing out of nowhere, just the correct solution. The LLM handles the natural language interaction and orchestration, while the computer algebra system does what it does best ... exact symbolic manipulation.</p>
<p>Anyways all the code is up on <a href="https://github.com/sdiehl/sympy-mcp">Github here</a> so maybe someone else will find it useful. If you have Cursor or Claude installed add the following to <code>~/.cursor/mcp.json</code> or <code>~/Library/Application Support/Claude/claude_desktop_config.json</code> to install the MCP server.</p>
<pre><code>{
  &#34;mcpServers&#34;: {
    &#34;sympy-mcp&#34;: {
      &#34;command&#34;: &#34;uv&#34;,
      &#34;args&#34;: [
        &#34;run&#34;,
        &#34;--with&#34;,
        &#34;https://github.com/sdiehl/sympy-mcp/releases/download/0.1/sympy_mcp-0.1.0-py3-none-any.whl&#34;,
        &#34;python&#34;,
        &#34;server.py&#34;
      ]
    }
  }
}
</code></pre>
<p>Or maybe slightly better, run it from a Docker image.</p>
<pre><code>{
  &#34;mcpServers&#34;: {
    &#34;sympy-mcp&#34;: {
      &#34;command&#34;: &#34;docker&#34;,
      &#34;args&#34;: [
        &#34;run&#34;,
        &#34;-i&#34;,
        &#34;-p&#34;,
        &#34;8081:8081&#34;,
        &#34;--rm&#34;,
        &#34;ghcr.io/sdiehl/sympy-mcp:latest&#34;
      ]
    }
  }
}
</code></pre>
<p>And maybe read the source code for what you&#39;re installing here, because I feel like a lot of people are going to install these MCP servers without knowing what they&#39;re doing and thus install a lot of malware and exploits. There&#39;s basically no security going on here. <a href="https://elenacross7.medium.com/%EF%B8%8F-the-s-in-mcp-stands-for-security-91407b33ed6b">And that could be a big problem</a>. Tread carefully.</p>

          </div></div>
  </body>
</html>
