<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://supabase.com/blog/postgres-full-text-search-vs-the-rest">Original</a>
    <h1>Postgres Full Text Search vs. the Rest</h1>
    
    <div id="readability-page-1" class="page"><article><p>Postgres is one of the best F/OSS databases partly because of its immense feature-set.</p>
<p>One of my favorite Postgres features is <a href="https://supabase.com/docs/guides/database/full-text-search">Full Text Search</a> (FTS). Search is a common requirement of applications. Well-known search engines like <a href="https://solr.apache.org/">Solr</a> and <a href="https://www.elastic.co/elasticsearch">ElasticSearch</a> are often a first choice, but with Postgres in your stack you&#39;ve got a great chance for <a href="https://en.wikipedia.org/wiki/Pareto_principle">Pareto improvement</a> at low complexity cost.</p>
<p>Many projects function just fine with Postgres Full Text Search and other <a href="https://www.postgresql.org/docs/current/contrib.html">built-in</a> extensions like <a href="https://www.postgresql.org/docs/current/pgtrgm.html">trigram search (<code>pg_trgm</code>)</a>. <a href="https://about.staging.gitlab.com/blog/2016/03/18/fast-search-using-postgresql-trigram-indexes/">GitLab&#39;s blog has a great article</a> on their use of Trigram indices to speed up search.</p>
<h2 id="search-engines-the-next-generation">Search Engines: The Next Generation</h2>
<p>These days, the debate isn&#39;t <em>just</em> Postgres versus Solr or ElasticSearch, a new generation of F/OSS search engines has arrived. To name a few:</p>
<ul>
<li><a href="https://www.meilisearch.com/">MeiliSearch</a></li>
<li><a href="https://opensearch.org/">OpenSearch</a></li>
<li><a href="https://www.sqlite.org/fts5.html">SQLite FTS</a></li>
<li><a href="https://typesense.org/">Typesense</a></li>
</ul>
<p>Well OK, some of these engines aren&#39;t <em>quite</em> new; SQLite is stable and has supported the search use-case for a while and OpenSearch is a fork of ElasticSearch. While not new, both are worth comparing as choices in front of engineers today (spoiler alert: we&#39;re going to compare them).</p>
<p>These search engines are all impressive, but it&#39;s hard to evaluate these options in a <code>VACUUM</code>.</p>
<p>If Postgres is already your main database, then it&#39;s probably easier to integrate than anything else. But would it be <em>better</em> to take on more complexity by choosing a dedicated search engine?</p>
<p>While search is an endlessly complicated problem and all of these tools are configurable, a comparison of minimal setup and tuning should yield some interesting insights.</p>
<p>Before we get into it though, a <em>brief</em> primer on what &#34;Full Text Search&#34; <em>means</em>, in Postgres land.</p>
<h2 id="a-whirlwind-tour-through-fts-in-postgres">A whirlwind tour through FTS in Postgres</h2>
<p>If we want to compare other solutions to Postgres FTS, we&#39;d better review how to set up and use <a href="https://www.postgresql.org/docs/current/textsearch.html">Postgres FTS</a>!</p>
<h3 id="wrangling-your-existing-data">Wrangling your existing data</h3>
<p>Imagine you have some information to search through, stored in your main database.</p>
<p>Maybe a <code>movies</code> table with a structure like this:</p>

<p>While you&#39;re inserting data you might perform <code>INSERTs</code> like this one:</p>

<h3 id="basic-searching-with-select-and-like">Basic searching with select and like</h3>
<p>With nothing but the raw data in your database, we can actually do some <em>basic</em> searching using <code>select</code> and comparison tools like <code>like</code>.</p>

<p>The <code>LIKE</code> <a href="https://www.postgresql.org/docs/current/functions-matching.html#FUNCTIONS-LIKE">operator</a> as used in the query above will match <em>only</em> the term &#34;Avengers&#34;, but it will match it in any part of a given row&#39;s <code>title</code> or <code>overview</code>.</p>
<p>We can hack around this basic functionality and make it a bit more robust:</p>
<ul>
<li>Storing the text as <a href="https://www.postgresql.org/docs/current/citext.html">case insensitive text (<code>citext</code>)</a></li>
<li>Combining the text that will be searched into one column</li>
<li>Using a <a href="https://www.postgresql.org/docs/14/indexes-types.html#INDEXES-TYPES-GIN">GIN index</a></li>
</ul>
<p>Our &#34;v0&#34; would be better, but using <code>like</code> isn&#39;t quite what people mean when they ask for <em>robust</em> full text search. <strong>Not a bad first version, but Postgres can do much better.</strong></p>
<h3 id="robust-full-text-search-with-postgres">Robust Full Text Search with Postgres</h3>
<p>Postgres has built-in <a href="https://www.postgresql.org/docs/current/textsearch.html">Full Text Search</a> which we can use instead of cobbling together our own with <code>like</code>.</p>
<p>Luckily for us, <a href="https://www.postgresql.org/docs/current/textsearch.html">the Postgres FTS documentation</a> is quite extensive, containing lots of information on the all-important <a href="https://www.postgresql.org/docs/current/datatype-textsearch.html">Postgres search data types: <code>tsvector</code> and <code>tsquery</code></a>.</p>
<p>State of the art search engines like <a href="https://solr.apache.org/">Solr</a> do things to make searches work well:</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Stemming">Stemming</a> (&#34;jumped&#34;, &#34;jumper&#34; -&gt; &#34;jump&#34;)</li>
<li><a href="https://en.wikipedia.org/wiki/lemmatization">Lemmatization</a> (&#34;better&#34; -&gt; &#34;good&#34;)</li>
<li>Result Ranking configuration</li>
<li>Search by <a href="https://en.wikipedia.org/wiki/Levenshtein_distance">edit distance</a></li>
<li>Vector based similarity (which you might use for a basic recommendation system)</li>
</ul>
<p>Postgres FTS does not do <em>all</em> of the things a purpose-built search engine can do, but Postgres can produce very good results with decent performance.</p>
<h2 id="a-working-postgres-fts-setup">A working Postgres FTS setup</h2>
<p>Integrating Full Text Search into our imaginary movies table is as simple as executing the following:</p>

<p>Postgres supports even more features like <a href="https://www.postgresql.org/docs/current/textsearch-controls.html#TEXTSEARCH-RANKING">facilities for ranking search results</a> but for now we&#39;ll simply use <code>title</code>, <code>original_title</code>, and <code>overview</code> as they are.</p>

<h2 id="comparable-fts-engines">Comparable FTS engines</h2>
<p>Now that we&#39;ve got a grasp on what FTS is and how it&#39;s used in Postgres, let&#39;s discuss a few of the alternative solutions Postgres can be compared to.</p>
<p>As you might expect, this isn&#39;t an exhaustive list of FTS engines, there are many more that we&#39;re not covering here (If you&#39;ve got another search engine you&#39;d like to see featured, <a href="https://github.com/VADOSWARE/fts-benchmark/issues">file an issue</a>).</p>
<h3 id="sqlite-fts">SQLite FTS</h3>
<p><a href="https://www.sqlite.org/">SQLite</a> is arguably the most widely deployed database in the world. SQLite is a library that produces and manages single file (or in-memory) databases that run on phones, planes, laptops, kiosks, Raspberry Pis, and everything in between.</p>
<p>Much like Postgres, SQLite is an excellent F/OSS project that has adopted the ability to perform Full Text Search.</p>
<p>The <a href="https://www.sqlite.org/fts5.html">SQLite FTS documentation</a> is extensive, and the FTS subsystems have undergone a few version upgrades -- <a href="https://www.sqlite.org/fts3.html">FTS 3/4</a> and <a href="https://www.sqlite.org/fts5.html">SQLite FTS 5</a> are both options.</p>
<p>For our experiments we&#39;ll use SQLite FTS5.</p>
<h3 id="typesense">TypeSense</h3>
<p><a href="https://typesense.org/">TypeSense</a> is a relatively new project that focuses on <em>lightning fast</em>, typo-tolerant open source search. Typesense boasts a high performance C++ codebase, promising nearly instant search results.</p>
<p>TypeSense provides many demos with example datasets available for query, which you can try out:</p>
<ul>
<li><a href="https://songs-search.typesense.org/">32MM songs from MusicBrainz</a></li>
<li><a href="https://books-search.typesense.org/">28M books from OpenLibrary</a></li>
<li><a href="https://xkcd-search.typesense.org/">XKCD comic search by topic</a></li>
</ul>
<p>Typesense quite ambitiously brands itself as the &#34;Algolia&#34; and &#34;Elasticsearch&#34; alternative, offering to solve your search problems without requiring a PhD.</p>
<h3 id="meilisearch">MeiliSearch</h3>
<p><a href="https://www.meilisearch.com/">MeiliSearch</a> is a new search engine written from the ground up in <a href="https://rust-lang.org/">Rust</a>, which also promises <em>lightning fast</em> searches, flexibility, and typo tolerance.</p>
<p>MeiliSearch has <a href="https://docs.meilisearch.com/">extensive documentation</a>, boasts an easy to use yet extendable architecture, and is well supported by a large community and team.</p>
<h3 id="opensearch">OpenSearch</h3>
<p>AWS <a href="https://opensearch.org/">OpenSearch</a> is AWS&#39;s answer to ElasticSearch&#39;s license changes. While opinions are varied, ElasticSearch built a great piece (formerly Apache 2.0 licensed) piece of software, and the AWS fork represents at least a <em>stale</em> measure of ElasticSearch&#39;s capabilities.</p>
<p>OpenSearch is the <em>same</em> as ElasticSearch (since the fork) but as it&#39;s license is much more permissive, it&#39;s the easy choice as a comparison to Postgres.</p>
<p>In production make sure to evaluate ElasticSearch versus OpenSearch (or other solutions) sufficiently for your use case.</p>
<h2 id="testing-our-fts-solutions">Testing our FTS solutions</h2>
<p>Well, how do we test performance of these disparate complex systems on an infinitely redefinable, hard-to-solve problem? By sticking to the use cases.</p>
<p>Any search engine has two jobs:</p>
<ul>
<li>Ingest information (usually referred to as &#34;documents&#34;)</li>
<li>Return documents that match user queries</li>
</ul>
<p>Ingesting information <em>can</em> be important, but &#34;search engine performance&#34; usually refers to the second step - taking queries and outputting results.</p>
<p>That is to say, the primary concern is assuming a cluster already has proper data loaded on to it, how fast can it deliver the relevant results for a user-submitted query?</p>
<p>We&#39;ll focus on the end-user-centric meaning of performance here (query speed).</p>
<h3 id="getting-a-dataset">Getting a dataset</h3>
<p><a href="https://huggingface.co/">Hugging Face</a> has a <a href="https://huggingface.co/spaces/Kamand/Movie_Recommendation/blob/main/movies_metadata.csv">32MB movie data set</a>. We&#39;re interested in the follow columns in this data set:</p>
<ul>
<li><code>title</code></li>
<li><code>original_title</code></li>
<li><code>overview</code></li>
</ul>
<p>Postgres is capable of loading CSVs, but since we&#39;ll be using other search engines as well, let&#39;s convert to format that&#39;s much easier to use and process - <a href="https://dataprotocols.org/ndjson/">Newline Delimited JSON</a>.</p>
<p>After a few lines of code and one <code>[csv2ndjson.mjs</code> script](<a href="https://github.com/VADOSWARE/fts-benchmark/blob/main/src/util/csv2ndjson.mjs">https://github.com/VADOSWARE/fts-benchmark/blob/main/src/util/csv2ndjson.mjs</a>) later, we have a <code>movies.ndjson.json</code> full of JSON documents that we can easily ingest into any search engine (or other database for that matter!).</p>
<h3 id="inserting-the-data">Inserting the data</h3>
<p>Each system ingests data slightly differently, but with a little scripting we can paper over the differences.</p>
<p><a href="https://github.com/VADOSWARE/fts-benchmark">The code</a> contains a scheme of &#34;drivers&#34; which are minimal ES6 modules.</p>
<p>Here&#39;s an example of the <code>ingest</code> function used for Postgres (with <a href="https://github.com/gajus/slonik"><code>slonik</code></a> as our DB driver):</p>

<p>The <a href="https://github.com/VADOSWARE/fts-benchmark/">repo</a> contains the complete code for Postgres as well as the other search engines, written in much this same fashion.</p>
<h3 id="picking-a-set-of-queries">Picking a set of queries</h3>
<p>This part is somewhat arbitrary - I&#39;ve gotten a list of queries here that one might search for in terms of movies:</p>

<p>Thanks to <a href="https://boingboing.net/2018/04/30/the-most-common-words-in-movie.html">boinboing.net&#39;s article from 2018</a>, there are some words that show up quite often in movie titles that we can search for.</p>
<p>The data set isn&#39;t very big, but doing all these searches in quick succession should be enough to get a realistic performance baseline.</p>
<h3 id="running-the-queries">Running the queries</h3>
<p>Similar to ingesting data, all the search engines take slightly different input for queries, so we&#39;ll change our simple string queries into whatever the relevant search engine expects to receive.</p>
<p>Here&#39;s what that script looks like for Postgres:</p>

<p>No surprises there, just like the Postgres FTS example from earlier.</p>
<h2 id="automating-our-toil">Automating our toil</h2>
<p>Once we&#39;ve combined our scripting magic with some <code>Makefile</code> incantations, running the queries produces output like this:</p>

<p>Right off the bat we can see that Postgres is plenty quick! Some results are quite obvious - as you might expect, &#34;love&#34; is <em>quite</em> a common search result.</p>
<h2 id="results">Results</h2>
<p>With the <code>ingest</code> and <code>query</code> machinery defined for the search engines, it&#39;s easy to get some results.</p>

<h2 id="what-does-the-data-tell-us">What does the data tell us?</h2>
<p>There&#39;s a <em>lot</em> of tuning left undone here, but a few points stand out right away:</p>
<ul>
<li>Even when consuming similar content, engines can produce different results, but generally ratios between queries on the same engine should be consistent.</li>
<li>Postgres FTS is quite close performance-wise to many other solutions, at least in their default configuration.</li>
<li>Only Typesense and MeiliSearch properly handled mis-spellings (the &#34;suprman&#34; query).</li>
<li>Typesense was relatively strict with matches compared to other engines.</li>
<li>OpenSearch was <em>very</em> fast with ingest, but the default configuration doesn&#39;t index misspellings.</li>
<li>In-memory SQLite is by far the fastest, and PG isn&#39;t too far behind for this small data set.</li>
</ul>
<h2 id="feedback-from-the-other-products">Feedback from the other products</h2>
<p>Since this is a benchmark, we felt it was fair to give the other products an opportunity to give their feedback.</p>
<h3 id="meilisearch-1">Meilisearch</h3>
<blockquote>
<p>I agree that using PG in simple use cases is an excellent way to be pragmatic.
Unfortunately, PG will never be able to offer you a search experience like the one you could have with Meilisearch. Meilisearch has perfect management of typos and searches by prefix, allowing a search at each keystroke. Enhanced relevancy with rules such as the number of words present, the importance of the attribute, the proximity of the terms searched in the document, and custom parameters. The ability to mix textual, geographic, and facet searches. Meilisearch automatically understands almost all languages with the possibility of having synonyms and stop words. Meilisearch has an incredible performance even on large volumes of data, and no backend proxy is needed, thanks to complete API Key management.</p>
</blockquote>
<p><em>Quentin de Quelen, Meilisearch CEO</em></p>
<h3 id="typesense-1">Typesense</h3>
<blockquote>
<p>Some more context around Typesense&#39;s behavior: how loose or exact matches are done are configurable in Typesense. For eg, you can configure the number of typos that are accounted for (num_typos), and when typo tolerance should kick-in, only if a configurable amount of results are not found (typo_tokens_treshold). For multi keyword searches, you can configure Typesense to expand the search by dropping some of the keywords, until at least a configurable number of search results are found (drop_tokens_threshold).
We&#39;ve chosen specifically to keep the search tight because we received feedback from users that some results were confusing if we let the defaults be too loose.</p>
</blockquote>
<p><em>Jason Bosco, Typesense CEO</em></p>
<h2 id="wrap-up">Wrap-up</h2>
<p>While this certainly isn&#39;t &#34;big data&#34;, it looks like Postgres has very much held it&#39;s own, even without too much wrangling/tuning. Postgres is clearly more than capable of delivering <em>good enough</em> search for this very basic case.</p>
<p>Special purpose systems are expected to out-perform a more general system like Postgres, but clearly result quality and search speed provided Postgres is likely to be <em>good enough</em> for many use cases, and is “complexity neutral” -- no new systems needed!</p>
<h2 id="more-postgres-resources">More Postgres resources</h2>
<ul>
<li><a href="https://supabase.com/blog/postgres-wasm">Postgres WASM by Snaplet and Supabase</a></li>
<li><a href="https://supabase.com/blog/choosing-a-postgres-primary-key">Choosing a Postgres Primary Key</a></li>
<li><a href="https://supabase.com/blog/seen-by-in-postgresql">Implementing &#34;seen by&#34; functionality with Postgres</a></li>
<li><a href="https://supabase.com/blog/partial-postgresql-data-dumps-with-rls">Partial data dumps using Postgres Row Level Security</a></li>
<li><a href="https://supabase.com/blog/postgresql-views">Postgres Views</a></li>
<li><a href="https://supabase.com/blog/realtime-row-level-security-in-postgresql">Realtime Postgres RLS on Supabase</a></li>
</ul></article></div>
  </body>
</html>
