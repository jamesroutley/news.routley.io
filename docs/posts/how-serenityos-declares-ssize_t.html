<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://awesomekling.github.io/How-SerenityOS-declares-ssize_t/">Original</a>
    <h1>How SerenityOS declares ssize_t</h1>
    
    <div id="readability-page-1" class="page"><div>
    <p>This post explores one of my favorite hacks in <a href="https://github.com/SerenityOS/serenity">SerenityOS</a>. I don’t recommend doing this in your codebase, but it has worked for us so far. :^)</p>

<hr/>

<h2 id="background">Background</h2>

<p><code>size_t</code> and <code>ssize_t</code> are common types used in many POSIX APIs.
<a href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_types.h.html">According to POSIX</a>,
they are used as follows:</p>

<ul>
  <li><code>size_t</code>: Used for sizes of objects.</li>
  <li><code>ssize_t</code>: Used for a count of bytes or an error indication.</li>
</ul>

<p>In practice, <code>ssize_t</code> is essentially a “signed <code>size_t</code>”.</p>

<p>Since we’re building the whole operating system, including the standard C library ourselves,
we’re also responsible for declaring all the common system types, including <code>size_t</code> and <code>ssize_t</code>.</p>

<h2 id="how-we-declare-them">How we declare them</h2>

<p>To <a href="https://github.com/SerenityOS/serenity/blob/master/Userland/Libraries/LibC/stddef.h#L20">declare</a> <code>size_t</code>, we leverage the C preprocessor’s predefined <code>__SIZE_TYPE__</code> macro:</p>

<div><div><pre><code><span>typedef</span> <span>__SIZE_TYPE__</span> <span>size_t</span><span>;</span>
</code></pre></div></div>

<p>However, there is no <code>__SSIZE_TYPE__</code> macro for <code>ssize_t</code>, so I decided to get a little <a href="https://github.com/SerenityOS/serenity/blob/master/Kernel/API/POSIX/sys/types.h#L18">creative</a>:</p>

<div><div><pre><code><span>#define unsigned signed
</span><span>typedef</span> <span>__SIZE_TYPE__</span> <span>ssize_t</span><span>;</span>
<span>#undef unsigned
</span></code></pre></div></div>

<p>Here’s what’s happening: The C preprocessor expands “<code>__SIZE_TYPE__</code>” to “<code>unsigned long</code>” or something similar.
We trick it by temporarily defining a macro that replaces “<code>unsigned</code>” with “<code>signed</code>”, and so <code>ssize_t</code> is declared as a signed version of whatever the <code>size_t</code> type is!</p>

<h2 id="how-others-declare-them">How others declare them</h2>

<p>Other C libraries typically use more careful techniques, such as wrapping the declarations in architecture-specific <code>#ifdef</code>s:</p>

<div><div><pre><code><span>#ifdef __i386__
</span><span>typedef</span> <span>uint32_t</span> <span>size_t</span><span>;</span>
<span>typedef</span> <span>int32_t</span> <span>ssize_t</span><span>;</span>
<span>#endif
</span>
<span>#ifdef __x86_64__
</span><span>typedef</span> <span>uint64_t</span> <span>size_t</span><span>;</span>
<span>typedef</span> <span>int64_t</span> <span>ssize_t</span><span>;</span>
<span>#endif
</span></code></pre></div></div>

<p>That’s obviously a better approach if you’re building with compilers that don’t predefine <code>__SIZE_TYPE__</code>, or in an environment where <code>unsigned</code> has already been redefined.</p>

<p>In our case, we haven’t had any issues with our approach yet, so I’m inclined to hold on to the hack as it’s just so cute. :^)</p>

  </div></div>
  </body>
</html>
