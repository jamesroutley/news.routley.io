<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://woodrush.github.io/blog/lambdalisp.html">Original</a>
    <h1>Show HN: LambdaLisp – A Lisp interpreter that runs on lambda calculus</h1>
    
    <div id="readability-page-1" class="page"><div aria-label="Content">
      <div>
        <article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    <p><a href="https://danluu.com/blog/assets/posts/2022-09-17/lambdalisp_logo.png">
  <img src="https://danluu.com/blog/assets/posts/2022-09-17/lambdalisp_logo.png" alt="LambdaLisp - A Lisp Interpreter Written as an Untyped Lambda Calculus Term"/>
</a>
</p>


<p>LambdaLisp is a Lisp interpreter written as an untyped lambda calculus term.
The input and output text is encoded into closed lambda terms using the <a href="https://en.wikipedia.org/wiki/Mogensen%E2%80%93Scott_encoding">Mogensen-Scott encoding</a>, so the entire computation process solely consists of the beta-reduction of lambda calculus terms.</p>

<p>When run on a lambda calculus interpreter that runs on the terminal, it presents a REPL where you can interactively define and evaluate Lisp expressions. Supported interpreters are:</p>

<ul>
  <li>The <a href="https://justine.lol/lambda/">521-byte lambda calculus interpreter</a> SectorLambda written by Justine Tunney</li>
  <li>The <a href="https://www.ioccc.org/">IOCCC</a> 2012 <a href="https://www.ioccc.org/2012/tromp/hint.html">“Most functional”</a> interpreter written by John Tromp
(the <a href="https://www.ioccc.org/2012/tromp/tromp.c">source</a> is in the shape of a λ)</li>
  <li>Universal Lambda interpreter <a href="https://github.com/irori/clamb">clamb</a> and Lazy K interpreter <a href="https://github.com/irori/lazyk">lazyk</a> written by Kunihiko Sakamoto</li>
</ul>

<p>Supported features are:</p>

<ul>
  <li>Signed 32-bit integers</li>
  <li>Strings</li>
  <li>Closures, lexical scopes, and persistent bindings with <code>let</code></li>
  <li>Object-oriented programming feature with class inheritance</li>
  <li>Reader macros with <code>set-macro-character</code></li>
  <li>Access to the interpreter’s virtual heap memory with <code>malloc</code>, <code>memread</code>, and <code>memwrite</code></li>
  <li>Show the call stack trace when an error is invoked</li>
  <li>Garbage collection during macro evaluation</li>
</ul>

<p>and much more.</p>

<p>LambdaLisp can be used to write interactive programs.
Execution speed is fast as well, and the <a href="https://github.com/woodrush/lambdalisp/blob/main/examples/number-guessing-game.cl">number guessing game</a> runs on the terminal with an almost instantaneous response speed.</p>

<p>Here is a PDF showing its entire lambda term, which is 42 pages long:</p>



<p><span>The embedded PDF may not show on mobile.</span>
The same PDF is also available at <a href="https://woodrush.github.io/lambdalisp.pdf">https://woodrush.github.io/lambdalisp.pdf</a>.</p>

<h2 id="overview">Overview</h2>

<p>LambdaLisp is a Lisp interpreter written as a closed untyped lambda calculus term.
It is written as a lambda calculus term <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">L</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">m</mi><mi mathvariant="normal">b</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">L</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">p</mi></mrow><mo>=</mo><mi>λ</mi><mi>x</mi><mi mathvariant="normal">.</mi><mo>⋯</mo></mrow><annotation encoding="application/x-tex">{\rm LambdaLisp} = \lambda x. \cdots</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span>LambdaLisp</span></span></span><span></span><span>=</span><span></span></span><span><span></span><span>λ</span><span>x</span><span>.</span><span></span><span>⋯</span></span></span></span>
which takes a string <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>x</span></span></span></span> as an input and returns a string as an output.
The input <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>x</span></span></span></span> is the Lisp program and the user’s standard input,
and the output is the standard output.
Characters are encoded into lambda term representations of natural numbers using the <a href="https://en.wikipedia.org/wiki/Church_encoding">Church encoding</a>,
and strings are encoded as a list of characters with lists expressed as lambdas in the <a href="https://en.wikipedia.org/wiki/Mogensen%E2%80%93Scott_encoding">Mogensen-Scott encoding</a>,
so the entire computation process solely consists of the beta-reduction of lambda terms,
without introducing any non-lambda-type object.
In this sense, LambdaLisp operates on a “truly purely functional language” without any primitive data types except for lambda terms.</p>

<p>Supported features are closures and persistent bindings with <code>let</code>, reader macros, 32-bit signed integers, a built-in object-oriented programming feature based on closures, and much more.
LambdaLisp is tested by running code on both Common Lisp and LambdaLisp and comparing their outputs.
The largest LambdaLisp-Common-Lisp polyglot program that has been tested is <a href="https://github.com/woodrush/lambdalisp/blob/main/examples/lambdacraft.cl">lambdacraft.cl</a>,
which runs the Lisp-to-lambda-calculus compiler <a href="https://github.com/woodrush/lambdacraft">LambdaCraft</a> I wrote for this project, also used to compile LambdaLisp itself.</p>

<p>When run on a lambda calculus interpreter that runs on the terminal,
LambdaLisp presents a REPL where you can interactively define and evaluate Lisp expressions.
These interpreters automatically process the string-to-lambda encoding for handling I/O through the terminal.</p>

<p>Lisp has been described by Alan Kay as the <a href="https://www.gnu.org/software/mes/manual/html_node/LISP-as-Maxwell_0027s-Equations-of-Software.html">Maxwell’s equations of software</a>.
In the same sense, I believe that lambda calculus is the particle physics of computation.
LambdaLisp may therefore be a gigantic electromagnetic <a href="https://en.wikipedia.org/wiki/Mathematical_formulation_of_the_Standard_Model">Lagrangian</a> that connects the realm of human-friendly programming to the origins of the notion of computation itself.</p>

<h2 id="usage">Usage</h2>

<p>LambdaLisp is available on GitHub at <a href="https://github.com/woodrush/lambdalisp">https://github.com/woodrush/lambdalisp</a>.
Here we will explain how to try LambdaLisp right away on x86-64-Linux and other platforms such as Mac.</p>

<h3 id="running-the-lambdalisp-repl-on-x86-64-linux">Running the LambdaLisp REPL (on x86-64-Linux)</h3>
<p>You can try the LambdaLisp REPL on x86-64-Linux by simply running:</p>

<div><div><pre><code>git clone https://github.com/woodrush/lambdalisp
<span>cd </span>lambdalisp
make run-repl
</code></pre></div></div>
<p>The requirement is <code>cc</code> which should be installed by default.
To try it on a Mac, please see the next section.</p>

<p>This will run LambdaLisp on SectorLambda, the <a href="https://justine.lol/lambda/">521-byte lambda calculus interpreter</a>.
The source code being run is <a href="https://github.com/woodrush/lambdalisp/blob/main/bin/lambdalisp.blc">lambdalisp.blc</a>,
which is the lambda calculus term shown in <a href="https://woodrush.github.io/lambdalisp.pdf">lambdalisp.pdf</a> written in <a href="https://tromp.github.io/cl/Binary_lambda_calculus.html">binary lambda calculus</a> notation.</p>

<p>SectorLambda automatically takes care of the string-to-lambda I/O encoding to run LambdaLisp on the terminal.
Interaction is done by writing LambdaLisp in continuation-passing style,
allowing a Haskell-style interactive I/O to work on lambda calculus interpreters.</p>

<p>When building SectorLambda, Make runs the following commands to get its source codes:</p>

<ul>
  <li><code>Blc.S</code>: <code>wget https://justine.lol/lambda/Blc.S?v=2</code></li>
  <li><code>flat.lds</code>: <code>wget https://justine.lol/lambda/flat.lds</code></li>
</ul>

<p>After running <code>make run-repl</code>, the REPL can also be run as:</p>

<div><div><pre><code><span>(</span> <span>cat</span> ./bin/lambdalisp.blc | ./bin/asc2bin<span>;</span> <span>cat</span> <span>)</span> | ./bin/Blc
</code></pre></div></div>

<h3 id="running-the-lambdalisp-repl-on-other-platforms">Running the LambdaLisp REPL (on Other Platforms)</h3>

<p>SectorLambda is x86-64-Linux exclusive. On other platforms such as a Mac, the following command can be used:</p>

<div><div><pre><code>git clone https://github.com/woodrush/lambdalisp
<span>cd </span>lambdalisp
make run-repl-ulamb
</code></pre></div></div>
<p>This runs LambdaLisp on the lambda calculus interpreter <code>clamb</code>.
The requirement for this is <code>gcc</code> or <code>cc</code>.</p>

<p>After running <code>make run-repl-ulamb</code>, the REPL can also be run as:</p>

<div><div><pre><code><span>(</span> <span>cat</span> ./bin/lambdalisp.ulamb | ./bin/asc2bin<span>;</span> <span>cat</span> <span>)</span> | ./bin/clamb <span>-u</span>
</code></pre></div></div>

<p>LambdaLisp supports other various lambda calculus interpreters as well.
For instructions for other interpreters, please see the <a href="https://github.com/woodrush/lambdalisp">GitHub repo</a>.</p>

<h3 id="playing-the-number-guessing-game">Playing the Number Guessing Game</h3>

<p>Once <code>make run-repl</code> is run, you can play the <a href="https://github.com/woodrush/lambdalisp/blob/main/examples/number-guessing-game.cl">number guessing game</a> with:</p>

<div><div><pre><code><span>(</span> <span>cat</span> ./bin/lambdalisp.blc | ./bin/asc2bin<span>;</span> <span>cat</span> ./examples/number-guessing-game.cl<span>;</span> <span>cat</span> <span>)</span> | ./bin/Blc
</code></pre></div></div>

<p>If you ran <code>make run-repl-ulamb</code>, you can run:</p>

<div><div><pre><code><span>(</span> <span>cat</span> ./bin/lambdalisp.ulamb | ./bin/asc2bin<span>;</span> <span>cat</span> ./examples/number-guessing-game.cl<span>;</span> <span>cat</span> <span>)</span> | ./bin/clamb <span>-u</span>
</code></pre></div></div>

<p>You can run the same script on Common Lisp. If you use SBCL, you can run it with:</p>

<div><div><pre><code>sbcl <span>--script</span> ./examples/number-guessing-game.cl
</code></pre></div></div>

<h2 id="examples">Examples</h2>

<h3 id="closures">Closures</h3>

<p>The following LambdaLisp code runs right out of the box:</p>

<div><div><pre><code><span>(</span><span>defun</span> <span>new-counter</span> <span>(</span><span>init</span><span>)</span>
  <span>;; Return a closure.</span>
  <span>;; Use the let over lambda technique for creating independent and persistent variables.</span>
  <span>(</span><span>let</span> <span>((</span><span>i</span> <span>init</span><span>))</span>
    <span>(</span><span>lambda</span> <span>()</span> <span>(</span><span>setq</span> <span>i</span> <span>(</span><span>+</span> <span>1</span> <span>i</span><span>)))))</span>

<span>;; Instantiate counters</span>
<span>(</span><span>setq</span> <span>counter1</span> <span>(</span><span>new-counter</span> <span>0</span><span>))</span>
<span>(</span><span>setq</span> <span>counter2</span> <span>(</span><span>new-counter</span> <span>10</span><span>))</span>

<span>(</span><span>print</span> <span>(</span><span>counter1</span><span>))</span> <span>;; =&gt; 1</span>
<span>(</span><span>print</span> <span>(</span><span>counter1</span><span>))</span> <span>;; =&gt; 2</span>
<span>(</span><span>print</span> <span>(</span><span>counter2</span><span>))</span> <span>;; =&gt; 11</span>
<span>(</span><span>print</span> <span>(</span><span>counter1</span><span>))</span> <span>;; =&gt; 3</span>
<span>(</span><span>print</span> <span>(</span><span>counter2</span><span>))</span> <span>;; =&gt; 12</span>
<span>(</span><span>print</span> <span>(</span><span>counter1</span><span>))</span> <span>;; =&gt; 4</span>
<span>(</span><span>print</span> <span>(</span><span>counter1</span><span>))</span> <span>;; =&gt; 5</span>
</code></pre></div></div>

<p>An equivalent JavaScript code is:</p>

<div><div><pre><code><span>// Runs on the browser&#39;s console</span>
<span>function</span> <span>new_counter</span> <span>(</span><span>init</span><span>)</span> <span>{</span>
    <span>let</span> <span>i</span> <span>=</span> <span>init</span><span>;</span>
    <span>return</span> <span>function</span> <span>()</span> <span>{</span>
        <span>return</span> <span>++</span><span>i</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>var</span> <span>counter1</span> <span>=</span> <span>new_counter</span><span>(</span><span>0</span><span>);</span>
<span>var</span> <span>counter2</span> <span>=</span> <span>new_counter</span><span>(</span><span>10</span><span>);</span>

<span>console</span><span>.</span><span>log</span><span>(</span><span>counter1</span><span>());</span> <span>// =&gt; 1</span>
<span>console</span><span>.</span><span>log</span><span>(</span><span>counter1</span><span>());</span> <span>// =&gt; 2</span>
<span>console</span><span>.</span><span>log</span><span>(</span><span>counter2</span><span>());</span> <span>// =&gt; 11</span>
<span>console</span><span>.</span><span>log</span><span>(</span><span>counter1</span><span>());</span> <span>// =&gt; 3</span>
<span>console</span><span>.</span><span>log</span><span>(</span><span>counter2</span><span>());</span> <span>// =&gt; 12</span>
<span>console</span><span>.</span><span>log</span><span>(</span><span>counter1</span><span>());</span> <span>// =&gt; 4</span>
<span>console</span><span>.</span><span>log</span><span>(</span><span>counter1</span><span>());</span> <span>// =&gt; 5</span>
</code></pre></div></div>

<h3 id="object-oriented-programming-with-class-inheritance">Object-Oriented Programming With Class Inheritance</h3>

<p>As described in <a href="https://letoverlambda.com/">Let Over Lambda</a>,
when you have closures, you get object-oriented programming for free.
LambdaLisp has a built-in OOP feature implemented as predefined macros based on closures.
It supports Python-like classes with class inheritance:</p>

<div><div><pre><code><span>;; Runs on LambdaLisp</span>
<span>(</span><span>defclass</span> <span>Counter</span> <span>()</span>
  <span>(</span><span>i</span> <span>0</span><span>)</span>

  <span>(</span><span>defmethod</span> <span>inc</span> <span>()</span>
    <span>(</span><span>setf</span> <span>(</span><span>.</span> <span>self</span> <span>i</span><span>)</span> <span>(</span><span>+</span> <span>1</span> <span>(</span><span>.</span> <span>self</span> <span>i</span><span>))))</span>

  <span>(</span><span>defmethod</span> <span>dec</span> <span>()</span>
    <span>(</span><span>setf</span> <span>(</span><span>.</span> <span>self</span> <span>i</span><span>)</span> <span>(</span><span>-</span> <span>(</span><span>.</span> <span>self</span> <span>i</span><span>)</span> <span>1</span><span>))))</span>


<span>(</span><span>defclass</span> <span>Counter-add</span> <span>(</span><span>Counter</span><span>)</span>
  <span>(</span><span>defmethod</span> <span>*init</span> <span>(</span><span>i</span><span>)</span>
    <span>(</span><span>setf</span> <span>(</span><span>.</span> <span>self</span> <span>i</span><span>)</span> <span>i</span><span>))</span>

  <span>(</span><span>defmethod</span> <span>add</span> <span>(</span><span>n</span><span>)</span>
    <span>(</span><span>setf</span> <span>(</span><span>.</span> <span>self</span> <span>i</span><span>)</span> <span>(</span><span>+</span> <span>(</span><span>.</span> <span>self</span> <span>i</span><span>)</span> <span>n</span><span>))))</span>


<span>(</span><span>defparameter</span> <span>counter1</span> <span>(</span><span>new</span> <span>Counter</span><span>))</span>
<span>(</span><span>defparameter</span> <span>counter2</span> <span>(</span><span>new</span> <span>Counter-add</span> <span>100</span><span>))</span>

<span>((</span><span>.</span> <span>counter1</span> <span>inc</span><span>))</span>
<span>((</span><span>.</span> <span>counter2</span> <span>add</span><span>)</span> <span>100</span><span>)</span>

<span>(</span><span>setf</span> <span>(</span><span>.</span> <span>counter1</span> <span>i</span><span>)</span> <span>5</span><span>)</span>
<span>(</span><span>setf</span> <span>(</span><span>.</span> <span>counter2</span> <span>i</span><span>)</span> <span>500</span><span>)</span>
</code></pre></div></div>

<p>An equivalent Python code is:</p>

<div><div><pre><code><span>class</span> <span>Counter</span> <span>():</span>
    <span>i</span> <span>=</span> <span>0</span>

    <span>def</span> <span>inc</span> <span>(</span><span>self</span><span>):</span>
        <span>self</span><span>.</span><span>i</span> <span>+=</span> <span>1</span>
        <span>return</span> <span>self</span><span>.</span><span>i</span>
    
    <span>def</span> <span>dec</span> <span>(</span><span>self</span><span>):</span>
        <span>self</span><span>.</span><span>i</span> <span>-=</span> <span>1</span>
        <span>return</span> <span>self</span><span>.</span><span>i</span>

<span>class</span> <span>Counter_add</span> <span>(</span><span>Counter</span><span>):</span>
    <span>def</span> <span>__init__</span> <span>(</span><span>self</span><span>,</span> <span>i</span><span>):</span>
        <span>self</span><span>.</span><span>i</span> <span>=</span> <span>i</span>
    
    <span>def</span> <span>add</span> <span>(</span><span>self</span><span>,</span> <span>n</span><span>):</span>
        <span>self</span><span>.</span><span>i</span> <span>+=</span> <span>n</span>
        <span>return</span> <span>self</span><span>.</span><span>i</span>

<span>counter1</span> <span>=</span> <span>Counter</span><span>()</span>
<span>counter2</span> <span>=</span> <span>Counter_add</span><span>(</span><span>100</span><span>)</span>

<span>counter1</span><span>.</span><span>inc</span><span>()</span>
<span>counter2</span><span>.</span><span>add</span><span>(</span><span>100</span><span>)</span>

<span>counter1</span><span>.</span><span>i</span> <span>=</span> <span>5</span>
<span>counter2</span><span>.</span><span>i</span> <span>=</span> <span>500</span>
</code></pre></div></div>

<h3 id="more-examples">More Examples</h3>

<p>More examples can be found in the <a href="https://github.com/woodrush/lambdalisp">GitHub repo</a>.
The largest LambdaLisp program currently written is <a href="https://github.com/woodrush/lambdalisp/blob/main/examples/lambdacraft.cl">lambdacraft.cl</a>,
which runs the lambda calculus compiler <a href="https://github.com/woodrush/lambdacraft">LambdaCraft</a> I wrote for this project, also used to compile LambdaLisp itself.</p>

<h2 id="features">Features</h2>

<p>Key features are:</p>

<ul>
  <li>Signed 32-bit integers</li>
  <li>Strings</li>
  <li>Closures, lexical scopes, and persistent bindings with <code>let</code></li>
  <li>Object-oriented programming feature with class inheritance</li>
  <li>Reader macros with <code>set-macro-character</code></li>
  <li>Access to the interpreter’s virtual heap memory with <code>malloc</code>, <code>memread</code>, and <code>memwrite</code></li>
  <li>Show the call stack trace when an error is invoked</li>
  <li>Garbage collection during macro evaluation</li>
</ul>

<p>Supported special forms and functions are:</p>

<ul>
  <li>defun, defmacro, lambda (&amp;rest can be used)</li>
  <li>quote, atom, car, cdr, cons, eq</li>
  <li>+, -, *, /, mod, =, &gt;, &lt;, &gt;=, &lt;=, integerp</li>
  <li>read (reads Lisp expressions), print, format (supports <code>~a</code> and <code>~%</code>), write-to-string, intern, stringp</li>
  <li>let, let*, labels, setq, boundp</li>
  <li>progn, loop, block, return, return-from, if, cond, error</li>
  <li>list, append, reverse, length, position, mapcar</li>
  <li>make-hash-table, gethash (setf can be used)</li>
  <li>equal, and, or, not</li>
  <li>eval, apply</li>
  <li>set-macro-character, peek-char, read-char, <code>`</code>   <code>,</code>   <code>,@</code>   <code>&#39;</code>   <code>#\</code></li>
  <li>carstr, cdrstr, str, string comparison with =, &gt;, &lt;, &gt;=, &lt;=, string concatenation with +</li>
  <li>defun-local, defglobal, type, macro</li>
  <li>malloc, memread, memwrite</li>
  <li>new, defclass, defmethod, <code>.</code>, field assignment by setf</li>
</ul>

<h2 id="tests">Tests</h2>

<p>There are 2 types of tests written for LambdaLisp. The GitHub Actions CI runs these tests.</p>

<h3 id="output-comparison-test">Output Comparison Test</h3>

<p>The files <code>examples/*.cl</code> run both on Common Lisp and LambdaLisp producing identical results, except for the initial <code>&gt; </code>   printed by the REPL in LambdaLisp. This test first runs <code>*.cl</code> on both SBCL and LambdaLisp and compares their outputs.</p>

<p>The files <code>examples/*.lisp</code> are LambdaLisp-exclusive programs. The output of these files are compared with <code>test/*.lisp.out</code>.</p>

<h3 id="lambdacraft-compiler-hosting-test">LambdaCraft Compiler Hosting Test</h3>

<p><code>examples/lambdacraft.cl</code> runs LambdaCraft, a Common-Lisp-to-lambda-calculus compiler written in Common Lisp,
used to compile the lambda calculus source for LambdaLisp.
The script defines a binary lambda calculus (BLC) program that prints the letter <code>A</code> and exits,
and prints the BLC source code for the defined program.</p>

<p>The LambdaCraft compiler hosting test first executes <code>examples/lambdacraft.cl</code> on LambdaLisp, then runs the output BLC program on a BLC interpreter, and checks if it prints the letter <code>A</code> and exits.</p>

<h3 id="experimental-self-hosting-test">Experimental: Self-Hosting Test</h3>

<p>This test is currently theoretical since it requires a lot of time and memory, and is unused in <code>make test-all</code>.
This test extends the previous LambdaCraft compiler hosting test and checks if the Common Lisp source code for LambdaLisp runs on LambdaLisp itself. Since the LambdaCraft compiler hosting test runs properly, this test should theoretically run as well, although it requires a tremendous amount of memory and time. The test is run on the binary lambda calculus interpreter Blc.</p>

<p>One concern is whether the 32-bit heap address space used internally in LambdaLisp is enough to compile this program. This can be solved by compiling LambdaLisp with an address space of 64-bit or larger, which can be done simply by replacing the literal <code>32</code> (which only appears once in <code>src/lambdalisp.cl</code>) with <code>64</code>, etc.
Another concern is whether if the execution hits Blc’s maximum term limit. This can be solved by compiling Blc with a larger memory limit, by editing the rule for <code>$(BLC)</code> in the Makefile.</p>

<h2 id="how-it-works---lambdalisp-implementation-details">How it Works - LambdaLisp Implementation Details</h2>

<p>Here we will explain LambdaLisp’s implementation details.
Below is a table of contents:</p>

<ul id="markdown-toc">
  <li><a href="#general-lambda-calculus-programming" id="markdown-toc-general-lambda-calculus-programming">General Lambda Calculus Programming</a>    <ul>
      <li><a href="#handling-io-in-lambda-calculus" id="markdown-toc-handling-io-in-lambda-calculus">Handling I/O in Lambda Calculus</a></li>
      <li><a href="#lambda-calculus-based-programming-languages" id="markdown-toc-lambda-calculus-based-programming-languages">Lambda-Calculus-Based Programming Languages</a></li>
      <li><a href="#lazy-k" id="markdown-toc-lazy-k">Lazy K</a></li>
      <li><a href="#interactive-io-in-lambda-calculus-based-languages" id="markdown-toc-interactive-io-in-lambda-calculus-based-languages">Interactive I/O in Lambda-Calculus-Based Languages</a></li>
    </ul>
  </li>
  <li><a href="#lambdalisp-implementation-details" id="markdown-toc-lambdalisp-implementation-details">LambdaLisp Implementation Details</a>    <ul>
      <li><a href="#the-core-implementation-strategy" id="markdown-toc-the-core-implementation-strategy">The Core Implementation Strategy</a></li>
      <li><a href="#the-startup-phase---a-primitive-form-of-asynchronous-programming" id="markdown-toc-the-startup-phase---a-primitive-form-of-asynchronous-programming">The Startup Phase - A Primitive Form of Asynchronous Programming</a></li>
      <li><a href="#the-basic-evaluation-loop" id="markdown-toc-the-basic-evaluation-loop">The Basic Evaluation Loop</a></li>
      <li><a href="#basic-data-structures" id="markdown-toc-basic-data-structures">Basic Data Structures</a></li>
      <li><a href="#virtual-heap-memory-ram" id="markdown-toc-virtual-heap-memory-ram">Virtual Heap Memory (RAM)</a></li>
      <li><a href="#registers-global-variables" id="markdown-toc-registers-global-variables">Registers (Global Variables)</a></li>
      <li><a href="#the-prelude-generator-and-string-compression" id="markdown-toc-the-prelude-generator-and-string-compression">The Prelude Generator and String Compression</a></li>
    </ul>
  </li>
  <li><a href="#language-features" id="markdown-toc-language-features">Language Features</a>    <ul>
      <li><a href="#the-memory-model-for-persistent-bindings" id="markdown-toc-the-memory-model-for-persistent-bindings">The Memory Model for Persistent Bindings</a></li>
      <li><a href="#garbage-collection" id="markdown-toc-garbage-collection">Garbage Collection</a></li>
      <li><a href="#macros" id="markdown-toc-macros">Macros</a></li>
      <li><a href="#object-oriented-programming" id="markdown-toc-object-oriented-programming">Object-Oriented Programming</a></li>
      <li><a href="#blocks" id="markdown-toc-blocks">Blocks</a></li>
      <li><a href="#loops" id="markdown-toc-loops">Loops</a></li>
      <li><a href="#error-invocation-and-stack-traces" id="markdown-toc-error-invocation-and-stack-traces">Error Invocation and Stack Traces</a></li>
    </ul>
  </li>
  <li><a href="#other-general-lambda-calculus-programming-techniques" id="markdown-toc-other-general-lambda-calculus-programming-techniques">Other General Lambda Calculus Programming Techniques</a>    <ul>
      <li><a href="#mutual-recursion" id="markdown-toc-mutual-recursion">Mutual Recursion</a></li>
      <li><a href="#deriving-isnil" id="markdown-toc-deriving-isnil">Deriving ‘isnil’</a></li>
      <li><a href="#lambdacrafts-do-macro" id="markdown-toc-lambdacrafts-do-macro">LambdaCraft’s ‘do’ Macro</a></li>
      <li><a href="#print-debugging" id="markdown-toc-print-debugging">Print Debugging</a></li>
      <li><a href="#type-checking-with-macro-call-signatures" id="markdown-toc-type-checking-with-macro-call-signatures">Type Checking with Macro Call Signatures</a></li>
    </ul>
  </li>
  <li><a href="#appendix" id="markdown-toc-appendix">Appendix</a>    <ul>
      <li><a href="#javascript-examples-of-continuation-passing-style-code" id="markdown-toc-javascript-examples-of-continuation-passing-style-code">JavaScript Examples of Continuation-Passing Style Code</a></li>
      <li><a href="#the-binary-lambda-calculus-notation" id="markdown-toc-the-binary-lambda-calculus-notation">The Binary Lambda Calculus Notation</a></li>
    </ul>
  </li>
  <li><a href="#about-the-logo" id="markdown-toc-about-the-logo">About the Logo</a></li>
  <li><a href="#credits" id="markdown-toc-credits">Credits</a></li>
</ul>

<h2 id="general-lambda-calculus-programming">General Lambda Calculus Programming</h2>
<p>Before introducing LambdaLisp-specific implementation details,
we’ll cover some general topics about programming in lambda calculus.</p>

<h3 id="handling-io-in-lambda-calculus">Handling I/O in Lambda Calculus</h3>
<p>LambdaLisp is written as a function <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">L</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">m</mi><mi mathvariant="normal">b</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">L</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">p</mi></mrow><mo>=</mo><mi>λ</mi><mi>x</mi><mi mathvariant="normal">.</mi><mo>⋯</mo></mrow><annotation encoding="application/x-tex">{\rm LambdaLisp} = \lambda x. \cdots</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span>LambdaLisp</span></span></span><span></span><span>=</span><span></span></span><span><span></span><span>λ</span><span>x</span><span>.</span><span></span><span>⋯</span></span></span></span>
which takes one string as an input and returns one string as an output.
The input represents the Lisp program and the user’s standard input (the <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>x</span></span></span></span> is the input string),
and the output represents the standard output.
A string is represented as a list of bits of its ASCII representation.
In untyped lambda calculus, a method called the <a href="https://en.wikipedia.org/wiki/Mogensen%E2%80%93Scott_encoding">Mogensen-Scott encoding</a>
can be used to express a list of lambda terms as a pure untyped lambda calculus term, without the help of introducing a non-lambda-type object.</p>

<p>Bits are encoded as:</p>

<p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>λ</mi><mi>x</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>y</mi><mi mathvariant="normal">.</mi><mi>x</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>λ</mi><mi>x</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>y</mi><mi mathvariant="normal">.</mi><mi>y</mi></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
0 &amp;= \lambda x. \lambda y. x \\
1 &amp;= \lambda x. \lambda y. y \\
\end{aligned}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span><span><span><span><span><span></span><span><span>0</span></span></span><span><span></span><span><span>1</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span><span><span><span><span><span></span><span><span></span><span></span><span>=</span><span></span><span>λ</span><span>x</span><span>.</span><span>λ</span><span>y</span><span>.</span><span>x</span></span></span><span><span></span><span><span></span><span></span><span>=</span><span></span><span>λ</span><span>x</span><span>.</span><span>λ</span><span>y</span><span>.</span><span>y</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span></span></span></p><p>Lists are made using the list constructor and terminator <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">s</mi></mrow><annotation encoding="application/x-tex">{\rm cons}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span>cons</span></span></span></span></span></span> and <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">n</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">l</mi></mrow><annotation encoding="application/x-tex">{\rm nil}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span>nil</span></span></span></span></span></span>:</p>

<p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">s</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>λ</mi><mi>x</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>y</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>f</mi><mi mathvariant="normal">.</mi><mo stretchy="false">(</mo><mi>f</mi><mi>x</mi><mi>y</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi mathvariant="normal">n</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">l</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>λ</mi><mi>x</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>y</mi><mi mathvariant="normal">.</mi><mi>y</mi></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
{\rm cons} &amp;= \lambda x. \lambda y. \lambda f. (f x y) \\
{\rm nil} &amp;= \lambda x. \lambda y. y
\end{aligned}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span><span><span><span><span><span></span><span><span><span><span>cons</span></span></span></span></span><span><span></span><span><span><span><span>nil</span></span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span><span><span><span><span><span></span><span><span></span><span></span><span>=</span><span></span><span>λ</span><span>x</span><span>.</span><span>λ</span><span>y</span><span>.</span><span>λ</span><span>f</span><span>.</span><span>(</span><span>f</span><span>x</span><span>y</span><span>)</span></span></span><span><span></span><span><span></span><span></span><span>=</span><span></span><span>λ</span><span>x</span><span>.</span><span>λ</span><span>y</span><span>.</span><span>y</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span></span></span></p><p>Note that <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>=</mo><mrow><mi mathvariant="normal">n</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">l</mi></mrow></mrow><annotation encoding="application/x-tex">1 = {\rm nil}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>1</span><span></span><span>=</span><span></span></span><span><span></span><span><span><span>nil</span></span></span></span></span></span>.
Under these rules, the bit sequence <code>0101</code> can be expressed as a composition of lambda terms:</p>

<p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">s</mi></mrow><mtext> </mtext><mn>0</mn><mtext> </mtext><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">s</mi></mrow><mtext> </mtext><mn>1</mn><mtext> </mtext><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">s</mi></mrow><mtext> </mtext><mn>0</mn><mtext> </mtext><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">s</mi></mrow><mtext> </mtext><mn>1</mn><mtext> </mtext><mrow><mi mathvariant="normal">n</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">l</mi></mrow><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">({\rm cons} ~ 0 ~ ({\rm cons} ~ 1 ~ ({\rm cons} ~ 0 ~ ({\rm cons} ~ 1 ~ {\rm nil}))))</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>(</span><span><span><span>cons</span></span></span><span> </span><span>0</span><span> </span><span>(</span><span><span><span>cons</span></span></span><span> </span><span>1</span><span> </span><span>(</span><span><span><span>cons</span></span></span><span> </span><span>0</span><span> </span><span>(</span><span><span><span>cons</span></span></span><span> </span><span>1</span><span> </span><span><span><span>nil</span></span></span><span>))))</span></span></span></span></span></p><p>which is exactly the same as how lists are constructed in Lisp.
This beta-reduces to:</p>

<p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>λ</mi><mi>f</mi><mi mathvariant="normal">.</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>λ</mi><mi>x</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>y</mi><mi mathvariant="normal">.</mi><mi>x</mi><mo stretchy="false">)</mo><mi>λ</mi><mi>g</mi><mi mathvariant="normal">.</mi><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">(</mo><mi>λ</mi><mi>x</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>y</mi><mi mathvariant="normal">.</mi><mi>y</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mi>λ</mi><mi>h</mi><mi mathvariant="normal">.</mi><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">(</mo><mi>λ</mi><mi>x</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>y</mi><mi mathvariant="normal">.</mi><mi>x</mi><mo stretchy="false">)</mo><mi>λ</mi><mi>i</mi><mi mathvariant="normal">.</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">(</mo><mi>λ</mi><mi>x</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>y</mi><mi mathvariant="normal">.</mi><mi>y</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>λ</mi><mi>x</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>y</mi><mi mathvariant="normal">.</mi><mi>y</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
\lambda f. &amp;(f (\lambda x.\lambda y.x) \lambda g.(g (\lambda x.\lambda y.y) \\
           &amp;\lambda h.(h (\lambda x.\lambda y.x) \lambda i.(i (\lambda x.\lambda y.y) (\lambda x.\lambda y.y)))))
\end{aligned}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span><span><span><span><span><span></span><span><span>λ</span><span>f</span><span>.</span></span></span><span><span></span><span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span><span><span><span><span><span></span><span><span></span><span>(</span><span>f</span><span>(</span><span>λ</span><span>x</span><span>.</span><span>λ</span><span>y</span><span>.</span><span>x</span><span>)</span><span>λ</span><span>g</span><span>.</span><span>(</span><span>g</span><span>(</span><span>λ</span><span>x</span><span>.</span><span>λ</span><span>y</span><span>.</span><span>y</span><span>)</span></span></span><span><span></span><span><span></span><span>λh</span><span>.</span><span>(</span><span>h</span><span>(</span><span>λ</span><span>x</span><span>.</span><span>λ</span><span>y</span><span>.</span><span>x</span><span>)</span><span>λi</span><span>.</span><span>(</span><span>i</span><span>(</span><span>λ</span><span>x</span><span>.</span><span>λ</span><span>y</span><span>.</span><span>y</span><span>)</span><span>(</span><span>λ</span><span>x</span><span>.</span><span>λ</span><span>y</span><span>.</span><span>y</span><span>)))))</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span></span></span></p><p>Using this method, both the standard input and output strings can entirely be encoded into pure lambda calculus terms,
letting LambdaLisp to operate with beta reduction of lambda terms as its sole rule of computation,
without the requirement of introducing any non-lambda-type object.</p>

<p>The LambdaLisp execution flow is thus as follows: you first encode the input string (Lisp program and stdin)
as lambda terms, apply it to <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">L</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">m</mi><mi mathvariant="normal">b</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">L</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">p</mi></mrow><mo>=</mo><mi>λ</mi><mi>x</mi><mi mathvariant="normal">.</mi><mo>⋯</mo></mrow><annotation encoding="application/x-tex">{\rm LambdaLisp} = \lambda x. \cdots</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span>LambdaLisp</span></span></span><span></span><span>=</span><span></span></span><span><span></span><span>λ</span><span>x</span><span>.</span><span></span><span>⋯</span></span></span></span>, beta-reduce it until it is in beta normal form,
and parse the output lambda term as a Mogensen-Scott-encoded list of bits
(inspecting the equivalence of lambda terms is quite simple in this case since it is in beta normal form).
This rather complex flow is supported exactly as is in 3 lambda-calculus-based programming languages:
Binary Lambda Calculus, Universal Lambda, and Lazy K.</p>

<h3 id="lambda-calculus-based-programming-languages">Lambda-Calculus-Based Programming Languages</h3>
<p>Binary Lambda Calculus (BLC) and Universal Lambda (UL) are programming languages with the exact same I/O strategy described above -
a program is expressed as one pure lambda term that takes a Church-Mogensen-Scott-encoded string and returns a Church-Mogensen-Scott-encoded string.
When the interpreters for these languages <code>Blc</code> and <code>clamb</code> are run on the terminal,
the interpreter automatically encodes the input bytestream to lambda terms, performs beta-reduction,
parses the output lambda term as a list of bits, and prints the output as a string in the terminal.</p>

<p>The differences in BLC and UL are in a slight difference in the method for encoding the I/O.
Otherwise, both of these languages follow the same principle, where lambda terms are the solely available object types in the language.</p>

<p>In BLC and UL, lambda terms are written in a notation called <a href="https://tromp.github.io/cl/Binary_lambda_calculus.html">binary lambda calculus</a>.
Details on the BLC notation is described in the Appendix.</p>

<h3 id="lazy-k">Lazy K</h3>
<p>Lazy K is a language with the same I/O strategy with BLC and UL except programs are written as
<a href="https://en.wikipedia.org/wiki/SKI_combinator_calculus">SKI combinator calculus</a> terms instead of lambda terms.
The SKI combinator calculus is a system equivalent to lambda calculus,
where there are only 3 functions:</p>

<p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>S</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>λ</mi><mi>x</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>y</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>z</mi><mi mathvariant="normal">.</mi><mo stretchy="false">(</mo><mi>x</mi><mi>z</mi><mo stretchy="false">(</mo><mi>y</mi><mi>z</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>K</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>λ</mi><mi>x</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>y</mi><mi mathvariant="normal">.</mi><mi>x</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>I</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>λ</mi><mi>x</mi><mi mathvariant="normal">.</mi><mi>x</mi></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
S &amp;= \lambda x.\lambda y.\lambda z.(x z (y z)) \\
K &amp;= \lambda x.\lambda y.x \\
I &amp;= \lambda x.x
\end{aligned}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span><span><span><span><span><span></span><span><span>S</span></span></span><span><span></span><span><span>K</span></span></span><span><span></span><span><span>I</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span><span><span><span><span><span></span><span><span></span><span></span><span>=</span><span></span><span>λ</span><span>x</span><span>.</span><span>λ</span><span>y</span><span>.</span><span>λ</span><span>z</span><span>.</span><span>(</span><span>x</span><span>z</span><span>(</span><span>yz</span><span>))</span></span></span><span><span></span><span><span></span><span></span><span>=</span><span></span><span>λ</span><span>x</span><span>.</span><span>λ</span><span>y</span><span>.</span><span>x</span></span></span><span><span></span><span><span></span><span></span><span>=</span><span></span><span>λ</span><span>x</span><span>.</span><span>x</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span></span></span></p><p>Every SKI combinator calculus term is written as a combination of these 3 functions.</p>

<p>Every SKI term can be easily be converted to an equivalent lambda calculus term by simply rewriting the term with these rules.
Very interestingly, there is a method for converting the other way around -
there is a <a href="https://en.wikipedia.org/wiki/Combinatory_logic#Completeness_of_the_S-K_basis">consistent method</a>
to convert an arbitrary lambda term with an arbitrary number of variables to an equivalent SKI combinator calculus term.
This equivalence relation with lambda calculus proves that SKI combinator calculus is Turing-complete.</p>

<p>Apart from the strong condition that only 3 predefined functions exist,
the beta-reduction rules for the SKI combinator calculus are exactly identical as that of lambda calculus,
so the computation flow and the I/O strategy for Lazy K is the same as BLC and Universal Lambda -
all programs can be written purely in SKI combinator calculus terms without the need of introducing any function other than <code>S</code>, <code>K</code>, and <code>I</code>.
This allows Lazy K’s syntax to be astonishingly simple, where only 4 keywords exist - <code>s</code>, <code>k</code>, <code>i</code>, and <code>`</code> for function application.</p>

<p>As mentioned in the <a href="https://tromp.github.io/cl/lazy-k.html">original Lazy K design proposal</a>,
if <a href="https://en.wikipedia.org/wiki/Brainfuck">BF</a> captures the distilled essence of structured imperative programming,
Lazy K captures the distilled essence of functional programming.
It might as well be the assembly language of lazily evaluated functional programming.
With the simple syntax and rules orchestrating a Turing-complete language,
I find Lazy K to be a very beautiful language being one of my all-time favorites.</p>

<p>LambdaLisp is written in these 3 languages - Binary Lambda Calculus, Universal Lambda, and Lazy K.
In each of these languages, LambdaLisp is expressed as one lambda term or SKI combinator calculus term.
Therefore, to run LambdaLisp, an interpreter for one of these languages is required.
To put in a rather convoluted way, LambdaLisp is a Lisp interpreter that runs on another language’s interpreter.</p>

<h3 id="interactive-io-in-lambda-calculus-based-languages">Interactive I/O in Lambda-Calculus-Based Languages</h3>
<p>The I/O model described previously looks static - at first sight it seems as if the entire value of <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">s</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi></mrow><annotation encoding="application/x-tex">{\rm stdin}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span>stdin</span></span></span></span></span></span> needs to be pre-supplied beforehand on execution, making interactive programs be impossible.
However, this is not the case. The interpreter handles interactive I/O by the following clever combination of input buffering and lazy evaluation:</p>

<ul>
  <li>The input string is buffered into the memory. Its values are lazily evaluated - execution proceeds
until the last moment an input needs to be referenced in order for beta reduction to proceed.</li>
  <li>
    <p>The output string is printed as soon as the interpreter deduces the first characters of the output string.</p>

    <!-- - While eager evaluation evaluates the innermost expressions first,
  lazy evaluation evaluates the outermost expressions first.
  Since the outermost expression is the output string,
  the interpreter is able to know parts of the output string before the program terminates. -->
  </li>
</ul>

<p>As an example, consider the BLC program <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">R</mi><mi mathvariant="normal">O</mi><mi mathvariant="normal">T</mi><mn>13</mn></mrow><annotation encoding="application/x-tex">{\rm ROT13}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span>ROT13</span></span></span></span></span></span> which initially prints a prompt <code>In&gt;</code>,
accepts standard input, then outputs the ROT13 encoding of the standard input.
After the user starts the program, the interpreter’s beta-reduction proceeds as follows:</p>

<p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow><mi mathvariant="normal">R</mi><mi mathvariant="normal">O</mi><mi mathvariant="normal">T</mi><mn>13</mn></mrow><mtext> </mtext><mrow><mi mathvariant="normal">s</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi></mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mo stretchy="false">(</mo><mi>λ</mi><mi>s</mi><mi mathvariant="normal">.</mi><mrow><mi mathvariant="normal">C</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">e</mi></mrow><mtext> </mtext><mi>s</mi><mo stretchy="false">)</mo><mtext> </mtext><mrow><mi mathvariant="normal">s</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi></mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">C</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">e</mi></mrow><mtext> </mtext><mrow><mi mathvariant="normal">s</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi></mrow><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">s</mi></mrow><mtext> </mtext><mover accent="true"><mi>I</mi><mo>~</mo></mover><mtext> </mtext><mo stretchy="false">(</mo><msub><mrow><mi mathvariant="normal">C</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">e</mi></mrow><mn>1</mn></msub><mtext> </mtext><mrow><mi mathvariant="normal">s</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi></mrow><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">s</mi></mrow><mtext> </mtext><mover accent="true"><mi>I</mi><mo>~</mo></mover><mtext> </mtext><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">s</mi></mrow><mtext> </mtext><mover accent="true"><mi>n</mi><mo>~</mo></mover><mtext> </mtext><mo stretchy="false">(</mo><msub><mrow><mi mathvariant="normal">C</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">e</mi></mrow><mn>2</mn></msub><mtext> </mtext><mrow><mi mathvariant="normal">s</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi></mrow><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">s</mi></mrow><mtext> </mtext><mover accent="true"><mi>I</mi><mo>~</mo></mover><mtext> </mtext><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">s</mi></mrow><mtext> </mtext><mover accent="true"><mi>n</mi><mo>~</mo></mover><mtext> </mtext><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">s</mi></mrow><mtext> </mtext><mover accent="true"><mo>&gt;</mo><mo>~</mo></mover><mtext> </mtext><mo stretchy="false">(</mo><msub><mrow><mi mathvariant="normal">C</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">e</mi></mrow><mn>3</mn></msub><mtext> </mtext><mrow><mi mathvariant="normal">s</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi></mrow><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
{\rm ROT13} ~ {\rm stdin}
&amp;= (\lambda s.{\rm Code} ~ s) ~ {\rm stdin} \\
&amp;= ({\rm Code} ~ {\rm stdin}) \\
&amp;= ({\rm cons} ~ \tilde I ~ ({\rm Code}_1 ~ {\rm stdin})) \\
&amp;= ({\rm cons} ~ \tilde I ~ ({\rm cons} ~ \tilde n ~ ({\rm Code}_2 ~ {\rm stdin}))) \\
&amp;= ({\rm cons} ~ \tilde I ~ ({\rm cons} ~ \tilde n ~ ({\rm cons} ~ \tilde &gt; ~ ({\rm Code}_3 ~ {\rm stdin})))) \\
\end{aligned}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span><span><span><span><span><span></span><span><span><span><span>ROT13</span></span></span><span> </span><span><span><span>stdin</span></span></span></span></span><span><span></span><span></span></span><span><span></span><span></span></span><span><span></span><span></span></span><span><span></span><span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span><span><span><span><span><span></span><span><span></span><span></span><span>=</span><span></span><span>(</span><span>λ</span><span>s</span><span>.</span><span><span><span>Code</span></span></span><span> </span><span>s</span><span>)</span><span> </span><span><span><span>stdin</span></span></span></span></span><span><span></span><span><span></span><span></span><span>=</span><span></span><span>(</span><span><span><span>Code</span></span></span><span> </span><span><span><span>stdin</span></span></span><span>)</span></span></span><span><span></span><span><span></span><span></span><span>=</span><span></span><span>(</span><span><span><span>cons</span></span></span><span> </span><span><span><span><span><span><span></span><span>I</span></span><span><span></span><span><span>~</span></span></span></span></span></span></span><span> </span><span>(</span><span><span><span><span>Code</span></span></span><span><span><span><span><span><span></span><span><span>1</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span> </span><span><span><span>stdin</span></span></span><span>))</span></span></span><span><span></span><span><span></span><span></span><span>=</span><span></span><span>(</span><span><span><span>cons</span></span></span><span> </span><span><span><span><span><span><span></span><span>I</span></span><span><span></span><span><span>~</span></span></span></span></span></span></span><span> </span><span>(</span><span><span><span>cons</span></span></span><span> </span><span><span><span><span><span><span></span><span>n</span></span><span><span></span><span><span>~</span></span></span></span></span></span></span><span> </span><span>(</span><span><span><span><span>Code</span></span></span><span><span><span><span><span><span></span><span><span>2</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span> </span><span><span><span>stdin</span></span></span><span>)))</span></span></span><span><span></span><span><span></span><span></span><span>=</span><span></span><span>(</span><span><span><span>cons</span></span></span><span> </span><span><span><span><span><span><span></span><span>I</span></span><span><span></span><span><span>~</span></span></span></span></span></span></span><span> </span><span>(</span><span><span><span>cons</span></span></span><span> </span><span><span><span><span><span><span></span><span>n</span></span><span><span></span><span><span>~</span></span></span></span></span></span></span><span> </span><span>(</span><span><span><span>cons</span></span></span><span> </span><span><span><span><span><span><span></span><span>&gt;</span></span><span><span></span><span><span>~</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span> </span><span>(</span><span><span><span><span>Code</span></span></span><span><span><span><span><span><span></span><span><span>3</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span> </span><span><span><span>stdin</span></span></span><span>))))</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span></span></span></p><p>Here, <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>I</mi><mo>~</mo></mover></mrow><annotation encoding="application/x-tex">\tilde I</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span><span><span><span></span><span>I</span></span><span><span></span><span><span>~</span></span></span></span></span></span></span></span></span></span> is a lambda term representing the character <code>I</code>.</p>

<p>As <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">C</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">e</mi></mrow><annotation encoding="application/x-tex">{\rm Code}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span>Code</span></span></span></span></span></span> is beta-reduced, it “weaves out” its output string <code>In&gt;</code> on the way.
This is somewhat akin to the central dogma of molecular biology,
where ribosomes transcribe genetic information to polypeptide chains - the program is the gene,
the interpreter is the ribosome, and the list of output characters is the polypeptide chain.</p>

<p>The interpreter continues its evaluation until further beta reduction is impossible without the knowledge of the value of <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">s</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi></mrow><annotation encoding="application/x-tex">{\rm stdin}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span>stdin</span></span></span></span></span></span>,
which happens at <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">C</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">e</mi></mrow><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">{\rm Code}_3</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span><span>Code</span></span></span><span><span><span><span><span><span></span><span><span>3</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span>. At this point, the string <code>In&gt;</code> is shown on the terminal since its values are already determined and available.</p>

<p>Seeing the prompt <code>In&gt;</code>, suppose that the user types the string “Hi”. The interpreter then buffers its lambda-encoded expression into the pointer that points to <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">s</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi></mrow><annotation encoding="application/x-tex">{\rm stdin}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span>stdin</span></span></span></span></span></span>,
making the evaluation proceed as:</p>

<p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>r</mi><mi mathvariant="normal">.</mi><mi>h</mi><mi mathvariant="normal">.</mi><mi>s</mi><mi mathvariant="normal">.</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">s</mi></mrow><mtext> </mtext><mover accent="true"><mi>I</mi><mo>~</mo></mover><mtext> </mtext><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">s</mi></mrow><mtext> </mtext><mover accent="true"><mi>n</mi><mo>~</mo></mover><mtext> </mtext><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">s</mi></mrow><mtext> </mtext><mover accent="true"><mo>&gt;</mo><mo>~</mo></mover><mtext> </mtext><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">s</mi></mrow><mtext> </mtext><mover accent="true"><mi>U</mi><mo>~</mo></mover><mtext> </mtext><mo stretchy="false">(</mo><msub><mrow><mi mathvariant="normal">C</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">e</mi></mrow><mn>4</mn></msub><mtext> </mtext><mrow><mi mathvariant="normal">s</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi></mrow><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">s</mi></mrow><mtext> </mtext><mover accent="true"><mi>I</mi><mo>~</mo></mover><mtext> </mtext><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">s</mi></mrow><mtext> </mtext><mover accent="true"><mi>n</mi><mo>~</mo></mover><mtext> </mtext><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">s</mi></mrow><mtext> </mtext><mover accent="true"><mo>&gt;</mo><mo>~</mo></mover><mtext> </mtext><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">s</mi></mrow><mtext> </mtext><mover accent="true"><mi>U</mi><mo>~</mo></mover><mtext> </mtext><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">s</mi></mrow><mtext> </mtext><mover accent="true"><mi>v</mi><mo>~</mo></mover><mtext> </mtext><mo stretchy="false">(</mo><msub><mrow><mi mathvariant="normal">C</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">e</mi></mrow><mn>5</mn></msub><mtext> </mtext><mrow><mi mathvariant="normal">s</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi></mrow><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
r.h.s.
&amp;= ({\rm cons} ~ \tilde I ~ ({\rm cons} ~ \tilde n ~ ({\rm cons} ~ \tilde &gt; ~ ({\rm cons} ~ \tilde U ~ ({\rm Code}_4 ~ {\rm stdin}))))) \\
&amp;= ({\rm cons} ~ \tilde I ~ ({\rm cons} ~ \tilde n ~ ({\rm cons} ~ \tilde &gt; ~ ({\rm cons} ~ \tilde U ~ ({\rm cons} ~ \tilde v ~ ({\rm Code}_5 ~ {\rm stdin})))))) \\
\end{aligned}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span><span><span><span><span><span></span><span><span>r</span><span>.</span><span>h</span><span>.</span><span>s</span><span>.</span></span></span><span><span></span><span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span><span><span><span><span><span></span><span><span></span><span></span><span>=</span><span></span><span>(</span><span><span><span>cons</span></span></span><span> </span><span><span><span><span><span><span></span><span>I</span></span><span><span></span><span><span>~</span></span></span></span></span></span></span><span> </span><span>(</span><span><span><span>cons</span></span></span><span> </span><span><span><span><span><span><span></span><span>n</span></span><span><span></span><span><span>~</span></span></span></span></span></span></span><span> </span><span>(</span><span><span><span>cons</span></span></span><span> </span><span><span><span><span><span><span></span><span>&gt;</span></span><span><span></span><span><span>~</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span> </span><span>(</span><span><span><span>cons</span></span></span><span> </span><span><span><span><span><span><span></span><span>U</span></span><span><span></span><span><span>~</span></span></span></span></span></span></span><span> </span><span>(</span><span><span><span><span>Code</span></span></span><span><span><span><span><span><span></span><span><span>4</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span> </span><span><span><span>stdin</span></span></span><span>)))))</span></span></span><span><span></span><span><span></span><span></span><span>=</span><span></span><span>(</span><span><span><span>cons</span></span></span><span> </span><span><span><span><span><span><span></span><span>I</span></span><span><span></span><span><span>~</span></span></span></span></span></span></span><span> </span><span>(</span><span><span><span>cons</span></span></span><span> </span><span><span><span><span><span><span></span><span>n</span></span><span><span></span><span><span>~</span></span></span></span></span></span></span><span> </span><span>(</span><span><span><span>cons</span></span></span><span> </span><span><span><span><span><span><span></span><span>&gt;</span></span><span><span></span><span><span>~</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span> </span><span>(</span><span><span><span>cons</span></span></span><span> </span><span><span><span><span><span><span></span><span>U</span></span><span><span></span><span><span>~</span></span></span></span></span></span></span><span> </span><span>(</span><span><span><span>cons</span></span></span><span> </span><span><span><span><span><span><span></span><span>v</span></span><span><span></span><span><span>~</span></span></span></span></span></span></span><span> </span><span>(</span><span><span><span><span>Code</span></span></span><span><span><span><span><span><span></span><span><span>5</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span> </span><span><span><span>stdin</span></span></span><span>))))))</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span></span></span></p><p>On the terminal, the interaction process would look like this:</p>

<div><div><pre><code>In&gt;[**Halts; User types string**]Hi[**User types return; `Hi` is buffered into stdin**]
Uv
</code></pre></div></div>

<h2 id="lambdalisp-implementation-details">LambdaLisp Implementation Details</h2>
<p>We will now cover LambdaLisp-specific implementation details.</p>

<h3 id="the-core-implementation-strategy">The Core Implementation Strategy</h3>
<p>When viewed as a programming language, lambda calculus is a purely functional language.
This derives the following two basic programming strategies for LambdaLisp:</p>

<ul>
  <li>In order to use global variables, the global state is passed to every function that affects or relies on the global state.</li>
  <li>In order to control the evaluation flow for I/O, continuation-passing style (CPS) is used.</li>
</ul>

<p>Writing in continuation-passing style also helps the lambda calculus interpreter to prevent re-evaluating the same term multiple times.
This is very, very important and critical when writing programs for the 521-byte binary lambda calculus interpreters Blc, tromp and uni,
since it seems that they lack a memoization feature, although they readily have a garbage collection feature.
Writing in direct style gradually slows down the runtime execution speed since memoization does not occur and the same computation is repeated multiple times.
However, by carefully writing the entire program in continuation-passing style,
the evaluation flow can be controlled so that the program only proceeds when the value under attention is in beta-normal form.
In this situation, since values are already evaluated to their final form,
the need for memoization becomes unnecessary in the first place.</p>

<p>The continuation-passing style technique suddenly transforms Blc to a very, very fast and efficient lambda calculus interpreter.
In fact, the largest program <a href="https://github.com/woodrush/lambdalisp/blob/main/examples/lambdacraft.cl">lambdacraft.cl</a> runs the fastest and even the most memory-efficient on Blc,
using only about 1.7 GB of memory, while <code>clamb</code> uses about 5GB of memory.
I suspect that the speed is due to a efficient memory configuration and the memory efficiency is due to the garbage collection feature.
I was very surprised how large of a galaxy is fit into the microcosmos of 521 bytes!
This realization that continuation-passing-style programs run very fast on Blc was what made everything possible and what motivated me to set on the journey of building LambdaCraft and LambdaLisp.</p>

<p>The difference between continuation-passing style and direct style is explained in the Appendix, with JavaScript code samples that run on the browser’s console.</p>

<h3 id="the-startup-phase---a-primitive-form-of-asynchronous-programming">The Startup Phase - A Primitive Form of Asynchronous Programming</h3>
<p>Right after LambdaLisp starts running, it runs the following steps:</p>

<ul>
  <li>The string generator decompresses the “prelude Lisp code”, and also generates keyword strings such as <code>quote</code>.</li>
  <li>The initial prompt carret <code>&gt; </code>   is printed.</li>
  <li>The prelude Lisp code is silently evaluated (the results are not printed).</li>
  <li>The user’s initial input is evaluated and the results are printed.</li>
  <li>The interpreter enters the basic read-eval-print-loop.</li>
</ul>

<p>The <a href="https://github.com/woodrush/lambdalisp/blob/main/src/prelude.lisp">prelude Lisp code</a> is a LambdaLisp code
that defines core functions such as <code>defun</code> and <code>defmacro</code> as macros.
The prelude is hard-coded as a compressed string, which is decompressed by the string generator before being passed to the interpreter.
The compression method is described later.
The LambdaLisp core code written in LambdaCraft hard-codes only the essential and speed-critical functions.
Other non-critical functions are defined through LambdaLisp code in the prelude.
A lot of the features including <code>defun</code> and <code>defmacro</code> which seem to look like keywords are in fact defined as macros.
Due to this implementation, it is in fact possible to override the definition of <code>defun</code> to something else using <code>setq</code>, but I consider that as a flexible feature.</p>

<p>There is in fact a subtle form of asynchronous programming in action in this startup phase.
Since the prelude code takes a little bit of time to evaluate since it contains a lot of code,
if the initial prompt carret <code>&gt; </code> is shown <em>after</em> evaluating the prelude code,
it causes a slightly stressful short lag until the prelude finishes running.</p>

<p>To circumvent this, the the initial prompt carret <code>&gt; </code> is printed <em>before</em> the prelude is loaded.
This allows the prelude code to be evaluated <em>while</em> the user is typing their initial Lisp code.
Since the input is buffered in all of the lambda calculus interpreters, their input does not get lost even when the prelude is running in the background.
If the user types very fast, there will become a little bit of waiting until the result of the inital input is shown,
but if the prelude is already loaded, their result will be shown right away.
All later inputs are evaluated faster because the prelude is only read once at initialization.
In a way, this is a primitive form of asynchronous programming, where processing the user input and the execution of some code is done concurrently.</p>

<h3 id="the-basic-evaluation-loop">The Basic Evaluation Loop</h3>
<p>After the prelude is loaded, the interpreter enters its basic read-eval-print loop.</p>

<p>As mentioned before, the basic design is that all state-affecting functions must pass the state as arguments,
and basicallly all functions are written in CPS.
This makes the core <code>eval</code> function have the following signature:</p>

<div><div><pre><code><span>;; LambdaCraft</span>
<span>(</span><span>defrec-lazy</span> <span>eval</span> <span>(</span><span>expr</span> <span>state</span> <span>cont</span><span>)</span>
  <span>...</span><span>)</span>
</code></pre></div></div>

<p>Where <code>expr</code> is a Lisp expression, <code>state</code> is the global state, and <code>cont</code> is the continuation.
The comment <code>;; LambdaCraft</code> indicates that this is the source code for the LambdaLisp interpreter written in LambdaCraft.</p>

<p>The direct return type of <code>eval</code> is <code>string</code>, and not <code>expr</code> or <code>state</code>.
This is because the entire program is expected to be a program that “takes a string and outputs a string”.
This design also allows print debugging to be written very intuitively in an imperative style as discussed later.</p>

<p>Instead of using the direct return values, the evaluation results are “returned” to later processes through the continuation <code>cont</code>.
<code>cont</code> is actually just a callback function that is called at the end of <code>eval</code>,
which is called with the evaluated <code>expr</code> and the new <code>state</code> as its arguments.
For example, if the evaluation result is <code>42</code> and the renewed state is <code>state</code>, <code>eval</code> calls the callback function <code>cont</code> as</p>

<div><div><pre><code><span>(</span><span>cont</span> <span>result</span> <span>state</span><span>)</span> <span>;; Where result == 42 and state is the renewed state</span>
</code></pre></div></div>

<p>in the final step of the code. Here, two values <code>result</code> and <code>state</code> are “returned” to the callback function <code>cont</code> and are used later in <code>cont</code>.</p>

<p>Having the direct return type of <code>eval</code> to be a string makes the implementation of <code>exit</code> very simple. It is implemented in <code>eval</code> as:</p>

<div><div><pre><code><span>;; LambdaCraft</span>
<span>((</span><span>stringeq</span> <span>(</span><span>valueof</span> <span>head</span><span>)</span> <span>kExit</span><span>)</span>
  <span>nil</span><span>)</span>
</code></pre></div></div>

<p>Here is how it works:</p>

<ul>
  <li>Normally, every successive chain of computations is evoked by calling the callback function (the continuation).
Here, since <code>eval</code> no longer calls a continuation when <code>exit</code> is called,
no further computation happens and the interpreter stops there.</li>
  <li><code>eval</code>’s direct return value is set to <code>nil</code>, which is a string terminator.
This leaves <code>nil</code> at the end of the output string, completing the value of the output string.</li>
</ul>

<p>A similar implementation is used for <code>read-expr</code>, which exits the interpreter when there is no more text to read:</p>

<div><div><pre><code><span>;; LambdaCraft</span>
<span>;; Exit the program when EOF is reached</span>
<span>(</span><span>if</span> <span>(</span><span>isnil</span> <span>stdin</span><span>)</span>
  <span>nil</span><span>)</span>
</code></pre></div></div>

<h3 id="basic-data-structures">Basic Data Structures</h3>
<p>The <code>state</code> is a 3-tuple that contains <code>reg</code>, <code>heap</code> and <code>stdin</code>. In lambda terms:</p>

<p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi mathvariant="normal">s</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">e</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>:</mo><mo>=</mo><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">s</mi><mn>3</mn></mrow><mtext> </mtext><mrow><mi mathvariant="normal">r</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">g</mi></mrow><mtext> </mtext><mrow><mi mathvariant="normal">h</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">p</mi></mrow><mtext> </mtext><mrow><mi mathvariant="normal">s</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi></mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mo stretchy="false">(</mo><mi>λ</mi><mi>a</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>b</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>c</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>f</mi><mi mathvariant="normal">.</mi><mo stretchy="false">(</mo><mi>f</mi><mtext> </mtext><mi>a</mi><mtext> </mtext><mi>b</mi><mtext> </mtext><mi>c</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mtext> </mtext><mrow><mi mathvariant="normal">r</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">g</mi></mrow><mtext> </mtext><mrow><mi mathvariant="normal">h</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">p</mi></mrow><mtext> </mtext><mrow><mi mathvariant="normal">s</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi></mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>λ</mi><mi>f</mi><mi mathvariant="normal">.</mi><mtext> </mtext><mo stretchy="false">(</mo><mi>f</mi><mtext> </mtext><mrow><mi mathvariant="normal">r</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">g</mi></mrow><mtext> </mtext><mrow><mi mathvariant="normal">h</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">p</mi></mrow><mtext> </mtext><mrow><mi mathvariant="normal">s</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi></mrow><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
{\rm state}
&amp;:= {\rm cons3} ~ {\rm reg} ~ {\rm heap} ~ {\rm stdin} \\
&amp;= (\lambda a. \lambda b. \lambda c. \lambda f. (f~a~b~c)) ~ {\rm reg} ~ {\rm heap} ~ {\rm stdin} \\
&amp;= \lambda f. ~ (f ~ {\rm reg} ~ {\rm heap} ~ {\rm stdin})
\end{aligned}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span><span><span><span><span><span></span><span><span><span><span>state</span></span></span></span></span><span><span></span><span></span></span><span><span></span><span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span><span><span><span><span><span></span><span><span></span><span></span><span>:=</span><span></span><span><span><span>cons3</span></span></span><span> </span><span><span><span>reg</span></span></span><span> </span><span><span><span>heap</span></span></span><span> </span><span><span><span>stdin</span></span></span></span></span><span><span></span><span><span></span><span></span><span>=</span><span></span><span>(</span><span>λa</span><span>.</span><span>λb</span><span>.</span><span>λ</span><span>c</span><span>.</span><span>λ</span><span>f</span><span>.</span><span>(</span><span>f</span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>c</span><span>))</span><span> </span><span><span><span>reg</span></span></span><span> </span><span><span><span>heap</span></span></span><span> </span><span><span><span>stdin</span></span></span></span></span><span><span></span><span><span></span><span></span><span>=</span><span></span><span>λ</span><span>f</span><span>.</span><span> </span><span>(</span><span>f</span><span> </span><span><span><span>reg</span></span></span><span> </span><span><span><span>heap</span></span></span><span> </span><span><span><span>stdin</span></span></span><span>)</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span></span></span></p><p><code>reg</code> is used to store values of global variables used internally by the interpreter.
<code>heap</code> is a virtual heap memory used to store the <code>let</code> and <code>lambda</code> bindings caused by the code.
<code>stdin</code> is the pointer to the standard input provided by the interpreter.</p>

<p>Similar with <code>cons</code>, <code>state</code> is a <em>function</em> that accepts a callback function and applies it with the values it’s storing.
Therefore, the contents of <code>state</code> can be extracted by passing a callback function to <code>state</code>:</p>

<div><div><pre><code><span>;; LambdaCraft</span>
<span>(</span><span>state</span>
  <span>(</span><span>lambda</span> <span>(</span><span>reg</span> <span>heap</span> <span>stdin</span><span>)</span>
    <span>[do</span> <span>something</span> <span>with</span> <span>reg/heap/stdin]</span><span>))</span>
</code></pre></div></div>

<p>which is continuation-passing style code, since we are using callback functions that accept values and describes what to do with those values.</p>

<p><code>expr</code> is a Lisp expression. Expressions in LambdaLisp belong to one of the following 5 types: atom, cons, lambda, integer, and string.
All expressions are a 2-tuple with a type tag and its value:</p>

<p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mrow><mi mathvariant="normal">e</mi><mi mathvariant="normal">x</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">r</mi></mrow><mo>=</mo><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">s</mi></mrow><mtext> </mtext><mrow><mi mathvariant="normal">t</mi><mi mathvariant="normal">y</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">g</mi></mrow><mtext> </mtext><mrow><mi mathvariant="normal">v</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">e</mi></mrow><mo>=</mo><mi>λ</mi><mi>f</mi><mi mathvariant="normal">.</mi><mtext> </mtext><mo stretchy="false">(</mo><mi>f</mi><mtext> </mtext><mrow><mi mathvariant="normal">t</mi><mi mathvariant="normal">y</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">g</mi></mrow><mtext> </mtext><mrow><mi mathvariant="normal">v</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">e</mi></mrow><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{\rm expr}
= {\rm cons} ~ {\rm typetag} ~ {\rm value}
= \lambda f. ~ (f ~ {\rm typetag} ~ {\rm value})</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span>expr</span></span></span><span></span><span>=</span><span></span></span><span><span></span><span><span><span>cons</span></span></span><span> </span><span><span><span>typetag</span></span></span><span> </span><span><span><span>value</span></span></span><span></span><span>=</span><span></span></span><span><span></span><span>λ</span><span>f</span><span>.</span><span> </span><span>(</span><span>f</span><span> </span><span><span><span>typetag</span></span></span><span> </span><span><span><span>value</span></span></span><span>)</span></span></span></span></span></p><p>The structure of <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">v</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">e</mi></mrow><annotation encoding="application/x-tex">{\rm value}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span>value</span></span></span></span></span></span> depends on the type.
For all types, <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">t</mi><mi mathvariant="normal">y</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">g</mi></mrow><annotation encoding="application/x-tex">{\rm typetag}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span>typetag</span></span></span></span></span></span> is a selector for a 5-tuple:</p>

<p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi mathvariant="normal">t</mi><mi mathvariant="normal">y</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">_</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">m</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>λ</mi><mi>a</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>b</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>c</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>d</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>e</mi><mi mathvariant="normal">.</mi><mi>a</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi mathvariant="normal">t</mi><mi mathvariant="normal">y</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">_</mi><mi mathvariant="normal">c</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">s</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>λ</mi><mi>a</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>b</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>c</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>d</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>e</mi><mi mathvariant="normal">.</mi><mi>b</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi mathvariant="normal">t</mi><mi mathvariant="normal">y</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">_</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">m</mi><mi mathvariant="normal">b</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">a</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>λ</mi><mi>a</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>b</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>c</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>d</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>e</mi><mi mathvariant="normal">.</mi><mi>c</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi mathvariant="normal">t</mi><mi mathvariant="normal">y</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">_</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">g</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>λ</mi><mi>a</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>b</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>c</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>d</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>e</mi><mi mathvariant="normal">.</mi><mi>d</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi mathvariant="normal">t</mi><mi mathvariant="normal">y</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">_</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">g</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>λ</mi><mi>a</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>b</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>c</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>d</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>e</mi><mi mathvariant="normal">.</mi><mi>e</mi></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
{\rm type\_ atom} &amp;= \lambda a.\lambda b.\lambda c.\lambda d.\lambda e. a \\
{\rm type\_ cons} &amp;= \lambda a.\lambda b.\lambda c.\lambda d.\lambda e. b \\
{\rm type\_ lambda} &amp;= \lambda a.\lambda b.\lambda c.\lambda d.\lambda e. c \\
{\rm type\_ integer} &amp;= \lambda a.\lambda b.\lambda c.\lambda d.\lambda e. d \\
{\rm type\_ string} &amp;= \lambda a.\lambda b.\lambda c.\lambda d.\lambda e. e \\
\end{aligned}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span><span><span><span><span><span></span><span><span><span><span>type_atom</span></span></span></span></span><span><span></span><span><span><span><span>type_cons</span></span></span></span></span><span><span></span><span><span><span><span>type_lambda</span></span></span></span></span><span><span></span><span><span><span><span>type_integer</span></span></span></span></span><span><span></span><span><span><span><span>type_string</span></span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span><span><span><span><span><span></span><span><span></span><span></span><span>=</span><span></span><span>λa</span><span>.</span><span>λb</span><span>.</span><span>λ</span><span>c</span><span>.</span><span>λ</span><span>d</span><span>.</span><span>λ</span><span>e</span><span>.</span><span>a</span></span></span><span><span></span><span><span></span><span></span><span>=</span><span></span><span>λa</span><span>.</span><span>λb</span><span>.</span><span>λ</span><span>c</span><span>.</span><span>λ</span><span>d</span><span>.</span><span>λ</span><span>e</span><span>.</span><span>b</span></span></span><span><span></span><span><span></span><span></span><span>=</span><span></span><span>λa</span><span>.</span><span>λb</span><span>.</span><span>λ</span><span>c</span><span>.</span><span>λ</span><span>d</span><span>.</span><span>λ</span><span>e</span><span>.</span><span>c</span></span></span><span><span></span><span><span></span><span></span><span>=</span><span></span><span>λa</span><span>.</span><span>λb</span><span>.</span><span>λ</span><span>c</span><span>.</span><span>λ</span><span>d</span><span>.</span><span>λ</span><span>e</span><span>.</span><span>d</span></span></span><span><span></span><span><span></span><span></span><span>=</span><span></span><span>λa</span><span>.</span><span>λb</span><span>.</span><span>λ</span><span>c</span><span>.</span><span>λ</span><span>d</span><span>.</span><span>λ</span><span>e</span><span>.</span><span>e</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span></span></span></p><p>This way, we can do type matching by writing:</p>

<div><div><pre><code><span>(</span><span>typetag</span>
  <span>[code</span> <span>for</span> <span>atom</span> <span>case]</span>
  <span>[code</span> <span>for</span> <span>cons</span> <span>case]</span>
  <span>[code</span> <span>for</span> <span>lambda</span> <span>case]</span>
  <span>[code</span> <span>for</span> <span>integer</span> <span>case]</span>
  <span>[code</span> <span>for</span> <span>string</span> <span>case]</span><span>)</span>
</code></pre></div></div>

<p>Type matching ensures that the <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">v</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">e</mi></mrow><annotation encoding="application/x-tex">{\rm value}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span>value</span></span></span></span></span></span> for each type is always processed correctly according to its type.
Since each tag is a selector of a 5-tuple, the tag will select the code that will be executed next.
Since all codes are lazily evaluated, the codes for the unselected cases will not be evaluated.</p>

<p>As in the case of <code>state</code>, the type and value can be extracted by passing a callback to <code>expr</code>:</p>

<div><div><pre><code><span>;; LambdaCraft</span>
<span>(</span><span>expr</span>
  <span>(</span><span>lambda</span> <span>(</span><span>dtype</span> <span>value</span><span>)</span>
    <span>(</span><span>dtype</span>
      <span>[do</span> <span>something</span> <span>with</span> <span>`</span><span>value</span><span>`</span><span>]</span><span>)))</span>
</code></pre></div></div>

<h3 id="virtual-heap-memory-ram">Virtual Heap Memory (RAM)</h3>
<p>The virtual heap memory (RAM) is expressed as a binary tree constructed by the tuple constructor <code>cons</code>.
The idea of using a binary tree data structure for expressing a RAM unit is borrowed from <a href="https://github.com/irori">irori</a>’s <a href="https://irori.hatenablog.com/entry/elvm-unlambda-part1">Unlambda VM</a> (in Japanese).
The implementation of the binary tree is modified from this definition so that the tree could be initialized as <code>nil</code>.</p>

<p>One RAM cell can store a value of any size and any type - Lisp terms, strings, or even the interpreter’s current continuation.
This is because the RAM can actually only store one type, lambdas, but everything in lambda calculus belongs to that one type.</p>

<p>Trees are constructed using the same constructor <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">s</mi></mrow><mo>=</mo><mi>λ</mi><mi>x</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>y</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>f</mi><mi mathvariant="normal">.</mi><mo stretchy="false">(</mo><mi>f</mi><mi>x</mi><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{\rm cons} = \lambda x. \lambda y. \lambda f. (f x y)</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span>cons</span></span></span><span></span><span>=</span><span></span></span><span><span></span><span>λ</span><span>x</span><span>.</span><span>λ</span><span>y</span><span>.</span><span>λ</span><span>f</span><span>.</span><span>(</span><span>f</span><span>x</span><span>y</span><span>)</span></span></span></span> as lists.
A list <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>L</span></span></span></span> containing <code>A B C</code> can be written using <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">s</mi></mrow><annotation encoding="application/x-tex">{\rm cons}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span>cons</span></span></span></span></span></span> as:</p>

<p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>L</mi><mo>=</mo><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">s</mi></mrow><mtext> </mtext><mi>A</mi><mtext> </mtext><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">s</mi></mrow><mtext> </mtext><mi>B</mi><mtext> </mtext><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">s</mi><mtext> </mtext><mi mathvariant="normal">C</mi><mtext> </mtext><mrow><mi mathvariant="normal">n</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">l</mi></mrow><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">L = ({\rm cons} ~ A ~ ({\rm cons} ~ B ~ (\rm cons ~ C ~ {\rm nil})))</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>L</span><span></span><span>=</span><span></span></span><span><span></span><span>(</span><span><span><span>cons</span></span></span><span> </span><span>A</span><span> </span><span>(</span><span><span><span>cons</span></span></span><span> </span><span>B</span><span> </span><span>(</span><span><span>cons</span><span> </span><span>C</span><span> </span><span><span><span>nil</span></span></span><span>)))</span></span></span></span></span></span></p><p>Using the same mechanism, the following binary tree <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>T</span></span></span></span>,</p>

<p>

<!-- Generated by graphviz version 2.43.0 (0)
 -->
<!-- Title: G Pages: 1 -->
<svg role="img" aria-label="graphviz-a05dd097a19b5eb598d30d9d1accd6ea" width="278pt" height="186pt" viewBox="0.00 0.00 278.00 185.60">
<title>graphviz-a05dd097a19b5eb598d30d9d1accd6ea</title>
<desc>
digraph G {
  bgcolor=&#34;transparent&#34;
  n0 [shape=point]
  n1 [shape=point]
  root -&gt; n0 [label=0]
  root -&gt; n1 [label=1]
  n0 -&gt; A [label = 0]
  n0 -&gt; B [label = 1]
  n1 -&gt; C [label = 0]
  n1 -&gt; D [label = 1]
}
</desc>

<g id="graph0" transform="scale(1 1) rotate(0) translate(4 181.6)">
<title>G</title>
<!-- n0 -->
<g id="node1">
<title>n0</title>
<ellipse fill="black" stroke="black" cx="99" cy="-88.8" rx="1.8" ry="1.8"></ellipse>
</g>
<!-- A -->
<g id="node4">
<title>A</title>
<ellipse fill="none" stroke="black" cx="27" cy="-18" rx="27" ry="18"></ellipse>
<text text-anchor="middle" x="27" y="-14.3" font-family="Times,serif" font-size="14.00">A</text>
</g>
<!-- n0->A -->
<g id="edge3">
<title>n0-&gt;A</title>
<path fill="none" stroke="black" d="M98.19,-87.03C93.41,-82.46 68.42,-58.57 49.38,-40.38"></path>
<polygon fill="black" stroke="black" points="51.57,-37.63 41.92,-33.26 46.73,-42.69 51.57,-37.63"></polygon>
<text text-anchor="middle" x="83" y="-57.8" font-family="Times,serif" font-size="14.00">0</text>
</g>
<!-- B -->
<g id="node5">
<title>B</title>
<ellipse fill="none" stroke="black" cx="99" cy="-18" rx="27" ry="18"></ellipse>
<text text-anchor="middle" x="99" y="-14.3" font-family="Times,serif" font-size="14.00">B</text>
</g>
<!-- n0->B -->
<g id="edge4">
<title>n0-&gt;B</title>
<path fill="none" stroke="black" d="M99,-86.83C99,-82.34 99,-63.11 99,-46.27"></path>
<polygon fill="black" stroke="black" points="102.5,-46.24 99,-36.24 95.5,-46.24 102.5,-46.24"></polygon>
<text text-anchor="middle" x="104" y="-57.8" font-family="Times,serif" font-size="14.00">1</text>
</g>
<!-- n1 -->
<g id="node2">
<title>n1</title>
<ellipse fill="black" stroke="black" cx="171" cy="-88.8" rx="1.8" ry="1.8"></ellipse>
</g>
<!-- C -->
<g id="node6">
<title>C</title>
<ellipse fill="none" stroke="black" cx="171" cy="-18" rx="27" ry="18"></ellipse>
<text text-anchor="middle" x="171" y="-14.3" font-family="Times,serif" font-size="14.00">C</text>
</g>
<!-- n1->C -->
<g id="edge5">
<title>n1-&gt;C</title>
<path fill="none" stroke="black" d="M171,-86.83C171,-82.34 171,-63.11 171,-46.27"></path>
<polygon fill="black" stroke="black" points="174.5,-46.24 171,-36.24 167.5,-46.24 174.5,-46.24"></polygon>
<text text-anchor="middle" x="176" y="-57.8" font-family="Times,serif" font-size="14.00">0</text>
</g>
<!-- D -->
<g id="node7">
<title>D</title>
<ellipse fill="none" stroke="black" cx="243" cy="-18" rx="27" ry="18"></ellipse>
<text text-anchor="middle" x="243" y="-14.3" font-family="Times,serif" font-size="14.00">D</text>
</g>
<!-- n1->D -->
<g id="edge6">
<title>n1-&gt;D</title>
<path fill="none" stroke="black" d="M171.81,-87.03C176.59,-82.46 201.58,-58.57 220.62,-40.38"></path>
<polygon fill="black" stroke="black" points="223.27,-42.69 228.08,-33.26 218.43,-37.63 223.27,-42.69"></polygon>
<text text-anchor="middle" x="210" y="-57.8" font-family="Times,serif" font-size="14.00">1</text>
</g>
<!-- root -->
<g id="node3">
<title>root</title>
<ellipse fill="none" stroke="black" cx="125" cy="-159.6" rx="29.8" ry="18"></ellipse>
<text text-anchor="middle" x="125" y="-155.9" font-family="Times,serif" font-size="14.00">root</text>
</g>
<!-- root->n0 -->
<g id="edge1">
<title>root-&gt;n0</title>
<path fill="none" stroke="black" d="M118.71,-141.95C113.8,-128.97 107.15,-111.36 102.96,-100.29"></path>
<polygon fill="black" stroke="black" points="106.11,-98.72 99.3,-90.6 99.56,-101.19 106.11,-98.72"></polygon>
<text text-anchor="middle" x="117" y="-112.4" font-family="Times,serif" font-size="14.00">0</text>
</g>
<!-- root->n1 -->
<g id="edge2">
<title>root-&gt;n1</title>
<path fill="none" stroke="black" d="M135.67,-142.64C144.71,-129.12 157.37,-110.19 164.82,-99.04"></path>
<polygon fill="black" stroke="black" points="167.8,-100.88 170.45,-90.62 161.98,-96.99 167.8,-100.88"></polygon>
<text text-anchor="middle" x="163" y="-112.4" font-family="Times,serif" font-size="14.00">1</text>
</g>
</g>
</svg>
</p>

<p>can be expressed using <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">s</mi></mrow><annotation encoding="application/x-tex">{\rm cons}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span>cons</span></span></span></span></span></span> cells as follows:</p>

<p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>T</mi><mo>=</mo><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">s</mi></mrow><mtext> </mtext><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">s</mi></mrow><mtext> </mtext><mi>A</mi><mtext> </mtext><mi>B</mi><mo stretchy="false">)</mo><mtext> </mtext><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">s</mi></mrow><mtext> </mtext><mi>C</mi><mtext> </mtext><mi>D</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T = ({\rm cons} ~ ({\rm cons} ~ A ~ B) ~ ({\rm cons} ~ C ~ D))</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>T</span><span></span><span>=</span><span></span></span><span><span></span><span>(</span><span><span><span>cons</span></span></span><span> </span><span>(</span><span><span><span>cons</span></span></span><span> </span><span>A</span><span> </span><span>B</span><span>)</span><span> </span><span>(</span><span><span><span>cons</span></span></span><span> </span><span>C</span><span> </span><span>D</span><span>))</span></span></span></span></span></p><p>Every node where all of its leaves have unwritten values have their branch trimmed and set to <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">n</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">l</mi></mrow><annotation encoding="application/x-tex">{\rm nil}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span>nil</span></span></span></span></span></span>. If all values with the address <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>∗</mo></mrow><annotation encoding="application/x-tex">1*</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>1</span><span>∗</span></span></span></span> is unwritten, the tree would look like this:</p>

<p>

<!-- Generated by graphviz version 2.43.0 (0)
 -->
<!-- Title: G Pages: 1 -->
<svg role="img" aria-label="graphviz-d01916b6478006752b5c60d3f80f7b52" width="145pt" height="218pt" viewBox="0.00 0.00 145.00 218.00">
<title>graphviz-d01916b6478006752b5c60d3f80f7b52</title>
<desc>
digraph G {
  bgcolor=&#34;transparent&#34;
  n0 [shape=point]
  root -&gt; n0 [label=0]
  root -&gt; nil [label=1]
  n0 -&gt; A [label = 0]
  n0 -&gt; B [label = 1]
}
</desc>

<g id="graph0" transform="scale(1 1) rotate(0) translate(4 214)">
<title>G</title>
<!-- n0 -->
<g id="node1">
<title>n0</title>
<ellipse fill="black" stroke="black" cx="63" cy="-105" rx="1.8" ry="1.8"></ellipse>
</g>
<!-- A -->
<g id="node4">
<title>A</title>
<ellipse fill="none" stroke="black" cx="27" cy="-18" rx="27" ry="18"></ellipse>
<text text-anchor="middle" x="27" y="-14.3" font-family="Times,serif" font-size="14.00">A</text>
</g>
<!-- n0->A -->
<g id="edge3">
<title>n0-&gt;A</title>
<path fill="none" stroke="black" d="M62.6,-103.05C60.19,-97.36 47.51,-67.42 37.96,-44.88"></path>
<polygon fill="black" stroke="black" points="41.1,-43.31 33.97,-35.46 34.65,-46.04 41.1,-43.31"></polygon>
<text text-anchor="middle" x="53" y="-57.8" font-family="Times,serif" font-size="14.00">0</text>
</g>
<!-- B -->
<g id="node5">
<title>B</title>
<ellipse fill="none" stroke="black" cx="99" cy="-18" rx="27" ry="18"></ellipse>
<text text-anchor="middle" x="99" y="-14.3" font-family="Times,serif" font-size="14.00">B</text>
</g>
<!-- n0->B -->
<g id="edge4">
<title>n0-&gt;B</title>
<path fill="none" stroke="black" d="M63.4,-103.05C65.81,-97.36 78.49,-67.42 88.04,-44.88"></path>
<polygon fill="black" stroke="black" points="91.35,-46.04 92.03,-35.46 84.9,-43.31 91.35,-46.04"></polygon>
<text text-anchor="middle" x="88" y="-57.8" font-family="Times,serif" font-size="14.00">1</text>
</g>
<!-- root -->
<g id="node2">
<title>root</title>
<ellipse fill="none" stroke="black" cx="86" cy="-192" rx="29.8" ry="18"></ellipse>
<text text-anchor="middle" x="86" y="-188.3" font-family="Times,serif" font-size="14.00">root</text>
</g>
<!-- root->n0 -->
<g id="edge1">
<title>root-&gt;n0</title>
<path fill="none" stroke="black" d="M81.46,-174.21C76.85,-157.19 69.87,-131.38 65.94,-116.88"></path>
<polygon fill="black" stroke="black" points="69.29,-115.83 63.3,-107.09 62.53,-117.66 69.29,-115.83"></polygon>
<text text-anchor="middle" x="81" y="-144.8" font-family="Times,serif" font-size="14.00">0</text>
</g>
<!-- nil -->
<g id="node3">
<title>nil</title>
<ellipse fill="none" stroke="black" cx="110" cy="-105" rx="27" ry="18"></ellipse>
<text text-anchor="middle" x="110" y="-101.3" font-family="Times,serif" font-size="14.00">nil</text>
</g>
<!-- root->nil -->
<g id="edge2">
<title>root-&gt;nil</title>
<path fill="none" stroke="black" d="M90.74,-174.21C94.09,-162.33 98.66,-146.17 102.5,-132.56"></path>
<polygon fill="black" stroke="black" points="105.92,-133.33 105.27,-122.76 99.18,-131.43 105.92,-133.33"></polygon>
<text text-anchor="middle" x="104" y="-144.8" font-family="Times,serif" font-size="14.00">1</text>
</g>
</g>
</svg>
</p>

<p>When the tree search function encounters <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">n</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">l</mi></mrow><annotation encoding="application/x-tex">{\rm nil}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span>nil</span></span></span></span></span></span>, it returns the integer zero (a list of <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>N</span></span></span></span> consecutive <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>0</span></span></span></span> s). The tree grows past <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">n</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">l</mi></mrow><annotation encoding="application/x-tex">{\rm nil}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span>nil</span></span></span></span></span></span> only when a value is written past that address. The initial state of the RAM is <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">r</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">t</mi></mrow><mo>=</mo><mrow><mi mathvariant="normal">n</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">l</mi></mrow></mrow><annotation encoding="application/x-tex">{\rm root} = {\rm nil}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span>root</span></span></span><span></span><span>=</span><span></span></span><span><span></span><span><span><span>nil</span></span></span></span></span></span>, which effectively initializes the entire <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>N</span></span></span></span>-bit memory space to zero without creating <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>N</mi></msup></mrow><annotation encoding="application/x-tex">2^N</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>2</span><span><span><span><span><span><span></span><span><span>N</span></span></span></span></span></span></span></span></span></span></span> nodes. Afterwards, the RAM unit only grows approximately linearly as values are written instead of growing exponentially with the machine’s bit size.</p>

<p>LambdaLisp uses a 32-bit address space for the RAM,
which is specified <a href="https://github.com/woodrush/lambdalisp/blob/main/src/lambdalisp.cl#L1812">here</a>.
The address space can be modified to an arbitrary integer by replacing the literal <code>32</code> which shows up only once in the source code with another Church-encoded numeral.</p>

<p>LambdaLisp exposes <code>malloc</code> and memory reading/writing to the user through the special forms <code>malloc</code>, <code>memread</code> and <code>memwrite</code>. <code>malloc</code> returns an integer indicating the pointer to the heap, which is initialized with <code>nil</code>.
The pointer can be used with <code>memread</code> and <code>memwrite</code> to read and store LambdaLisp objects inside the interpreter’s heap cell.
This can be used to implement C-style arrays, as demonstrated in <a href="https://github.com/woodrush/lambdalisp/blob/main/examples/malloc.lisp">malloc.lisp</a>.</p>

<h3 id="registers-global-variables">Registers (Global Variables)</h3>
<p>The register object <code>reg</code> uses the same binary tree data structure as the RAM,
except <code>reg</code> uses variable-length addresses,
while <code>heap</code> uses a fixed-length address.
The variable-length address makes the address of each cell shorter, speeding up the read and write processes.
<code>reg</code> is used to store global variables that are frequently read out and written by the interpreter.</p>

<p>For example, we can let the register tree <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">r</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">g</mi></mrow><annotation encoding="application/x-tex">{\rm reg}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span>reg</span></span></span></span></span></span> have the following structure:</p>

<p>

<!-- Generated by graphviz version 2.43.0 (0)
 -->
<!-- Title: G Pages: 1 -->
<svg role="img" aria-label="graphviz-adf739f41ea0ed63e19ce53a5aab2d76" width="172pt" height="305pt" viewBox="0.00 0.00 172.00 305.00">
<title>graphviz-adf739f41ea0ed63e19ce53a5aab2d76</title>
<desc>
digraph G {
  bgcolor=&#34;transparent&#34;
  rank=LR
  A B C D
  n1 [shape=point]
  n2 [shape=point]
  root -&gt; A [label=0]
  root -&gt; n1 [label=1]
  n1 -&gt; B [label = 0]
  n1 -&gt; n2 [label = 1]
  n2 -&gt; C [label = 0]
  n2 -&gt; D [label = 1]
}
</desc>

<g id="graph0" transform="scale(1 1) rotate(0) translate(4 301)">
<title>G</title>
<!-- A -->
<g id="node1">
<title>A</title>
<ellipse fill="none" stroke="black" cx="27" cy="-192" rx="27" ry="18"></ellipse>
<text text-anchor="middle" x="27" y="-188.3" font-family="Times,serif" font-size="14.00">A</text>
</g>
<!-- B -->
<g id="node2">
<title>B</title>
<ellipse fill="none" stroke="black" cx="54" cy="-105" rx="27" ry="18"></ellipse>
<text text-anchor="middle" x="54" y="-101.3" font-family="Times,serif" font-size="14.00">B</text>
</g>
<!-- C -->
<g id="node3">
<title>C</title>
<ellipse fill="none" stroke="black" cx="65" cy="-18" rx="27" ry="18"></ellipse>
<text text-anchor="middle" x="65" y="-14.3" font-family="Times,serif" font-size="14.00">C</text>
</g>
<!-- D -->
<g id="node4">
<title>D</title>
<ellipse fill="none" stroke="black" cx="137" cy="-18" rx="27" ry="18"></ellipse>
<text text-anchor="middle" x="137" y="-14.3" font-family="Times,serif" font-size="14.00">D</text>
</g>
<!-- n1 -->
<g id="node5">
<title>n1</title>
<ellipse fill="black" stroke="black" cx="74" cy="-192" rx="1.8" ry="1.8"></ellipse>
</g>
<!-- n1->B -->
<g id="edge3">
<title>n1-&gt;B</title>
<path fill="none" stroke="black" d="M73.65,-190.15C72.06,-186.29 65.48,-169.96 62,-156 60.18,-148.7 58.68,-140.68 57.49,-133.25"></path>
<polygon fill="black" stroke="black" points="60.94,-132.65 56.02,-123.27 54.02,-133.68 60.94,-132.65"></polygon>
<text text-anchor="middle" x="67" y="-144.8" font-family="Times,serif" font-size="14.00">0</text>
</g>
<!-- n2 -->
<g id="node6">
<title>n2</title>
<ellipse fill="black" stroke="black" cx="101" cy="-105" rx="1.8" ry="1.8"></ellipse>
</g>
<!-- n1->n2 -->
<g id="edge4">
<title>n1-&gt;n2</title>
<path fill="none" stroke="black" d="M74.3,-190.05C76.57,-182.9 91.01,-137.46 97.66,-116.53"></path>
<polygon fill="black" stroke="black" points="101.04,-117.43 100.73,-106.84 94.37,-115.31 101.04,-117.43"></polygon>
<text text-anchor="middle" x="95" y="-144.8" font-family="Times,serif" font-size="14.00">1</text>
</g>
<!-- n2->C -->
<g id="edge5">
<title>n2-&gt;C</title>
<path fill="none" stroke="black" d="M100.6,-103.05C98.19,-97.36 85.51,-67.42 75.96,-44.88"></path>
<polygon fill="black" stroke="black" points="79.1,-43.31 71.97,-35.46 72.65,-46.04 79.1,-43.31"></polygon>
<text text-anchor="middle" x="91" y="-57.8" font-family="Times,serif" font-size="14.00">0</text>
</g>
<!-- n2->D -->
<g id="edge6">
<title>n2-&gt;D</title>
<path fill="none" stroke="black" d="M101.4,-103.05C103.81,-97.36 116.49,-67.42 126.04,-44.88"></path>
<polygon fill="black" stroke="black" points="129.35,-46.04 130.03,-35.46 122.9,-43.31 129.35,-46.04"></polygon>
<text text-anchor="middle" x="126" y="-57.8" font-family="Times,serif" font-size="14.00">1</text>
</g>
<!-- root -->
<g id="node7">
<title>root</title>
<ellipse fill="none" stroke="black" cx="43" cy="-279" rx="29.8" ry="18"></ellipse>
<text text-anchor="middle" x="43" y="-275.3" font-family="Times,serif" font-size="14.00">root</text>
</g>
<!-- root->A -->
<g id="edge1">
<title>root-&gt;A</title>
<path fill="none" stroke="black" d="M38.87,-260.96C37.55,-255.26 36.14,-248.87 35,-243 33.57,-235.61 32.2,-227.57 31.01,-220.14"></path>
<polygon fill="black" stroke="black" points="34.45,-219.52 29.46,-210.17 27.54,-220.59 34.45,-219.52"></polygon>
<text text-anchor="middle" x="40" y="-231.8" font-family="Times,serif" font-size="14.00">0</text>
</g>
<!-- root->n1 -->
<g id="edge2">
<title>root-&gt;n1</title>
<path fill="none" stroke="black" d="M49.12,-261.21C55.33,-244.19 64.74,-218.38 70.03,-203.88"></path>
<polygon fill="black" stroke="black" points="73.46,-204.69 73.6,-194.09 66.89,-202.29 73.46,-204.69"></polygon>
<text text-anchor="middle" x="66" y="-231.8" font-family="Times,serif" font-size="14.00">1</text>
</g>
</g>
</svg>
</p>

<p>The addresses for <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo separator="true">,</mo><mi>C</mi><mo separator="true">,</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">A, B, C, D</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>A</span><span>,</span><span></span><span>B</span><span>,</span><span></span><span>C</span><span>,</span><span></span><span>D</span></span></span></span> becomes <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>0</span></span></span></span>, <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>10</mn></mrow><annotation encoding="application/x-tex">10</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>10</span></span></span></span>, <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>110</mn></mrow><annotation encoding="application/x-tex">110</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>110</span></span></span></span>, and <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>111</mn></mrow><annotation encoding="application/x-tex">111</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>111</span></span></span></span>, respectively.</p>

<p>LambdaLisp uses 7 registers which are defined <a href="https://github.com/woodrush/lambdalisp/blob/main/src/lambdalisp.cl#L644">here</a>.</p>

<h3 id="the-prelude-generator-and-string-compression">The Prelude Generator and String Compression</h3>
<p>As mentioned before, the prelude is hard-coded as text that is embedded into the LambdaLisp source.
When embedding it as a lambda, the text is compressed into an efficient lambda term,
optimized for the binary lambda calculus notation.</p>

<p>The prelude is generated by consecutively applying lots and lots of characters to a function called <code>string-concatenator</code>:</p>

<div><div><pre><code><span>;; LambdaCraft</span>
<span>(</span><span>def-lazy</span> <span>prelude</span>
  <span>(</span><span>let</span>
    <span>((</span><span>&#34;a&#34;</span> <span>...</span><span>)</span>
     <span>(</span><span>&#34;b&#34;</span> <span>...</span><span>)</span>
     <span>(</span><span>&#34;c&#34;</span> <span>...</span><span>)</span>
     <span>...</span><span>)</span>
    <span>(</span><span>string-concatenator</span> <span>...</span> <span>&#34;n&#34;</span> <span>&#34;u&#34;</span> <span>&#34;f&#34;</span> <span>&#34;e&#34;</span> <span>&#34;d&#34;</span> <span>&#34;(&#34;</span> <span>nil</span><span>)))</span>

<span>(</span><span>defrec-lazy</span> <span>string-concatenator</span> <span>(</span><span>curstr</span> <span>x</span><span>)</span>
  <span>(</span><span>cond</span>
    <span>((</span><span>isnil</span> <span>x</span><span>)</span>
      <span>curstr</span><span>)</span>
    <span>(</span><span>t</span>
      <span>(</span><span>string-concatenator</span> <span>(</span><span>cons</span> <span>x</span> <span>curstr</span><span>)))))</span>
</code></pre></div></div>

<p>The string concatenator is something close to a generator object in Python that:</p>

<ul>
  <li>When called with a character, it pushes the character to the current stack <code>curstr</code>, and returns <code>string-concatenator</code> itself (with a renewed <code>curstr</code>).</li>
  <li>When called with <code>nil</code>, it returns the stocked <code>curstr</code> instead of returning itself.</li>
</ul>

<p>To obtain the string <code>(aaa)</code>, you can use <code>string-concatenator</code> as:</p>

<div><div><pre><code><span>(</span><span>string-concatenator</span> <span>&#34;)&#34;</span> <span>&#34;a&#34;</span> <span>&#34;a&#34;</span> <span>&#34;a&#34;</span> <span>&#34;(&#34;</span> <span>nil</span><span>)</span>
</code></pre></div></div>

<p>The characters are written in reverse order, since <code>string-concatenator</code> uses a stack to create strings.</p>

<p>This helps a lot for compressing strings in binary lambda calculus notation.
The <code>let</code> in the above code is a macro that expands to:</p>

<div><div><pre><code><span>;; LambdaCraft</span>
<span>(</span><span>def-lazy</span> <span>prelude</span>
  <span>((</span><span>lambda</span> <span>(</span><span>&#34;(&#34;</span><span>)</span>
     <span>((</span><span>lambda</span> <span>(</span><span>&#34;)&#34;</span><span>)</span>
         <span>((</span><span>lambda</span> <span>(</span><span>&#34;a&#34;</span><span>)</span>
             <span>(</span><span>string-concatenator</span> <span>&#34;)&#34;</span> <span>&#34;a&#34;</span> <span>&#34;a&#34;</span> <span>&#34;a&#34;</span> <span>&#34;(&#34;</span> <span>nil</span><span>))</span>
          <span>[definition</span> <span>of</span> <span>&#34;a&#34;</span><span>]</span><span>))</span>
      <span>[definition</span> <span>of</span> <span>&#34;)&#34;</span><span>]</span><span>))</span>
   <span>[definition</span> <span>of</span> <span>&#34;(&#34;</span><span>]</span><span>))</span>
</code></pre></div></div>

<p>In binary lambda calculus, the innermost expression encodes to</p>

<div><div><pre><code><span>(</span><span>string-concatenator</span> <span>&#34;)&#34;</span> <span>&#34;a&#34;</span> <span>&#34;a&#34;</span> <span>&#34;a&#34;</span> <span>&#34;(&#34;</span> <span>nil</span><span>)</span>
<span>=</span> <span>apply</span> <span>apply</span> <span>apply</span> <span>apply</span> <span>apply</span> <span>string-concatenator</span> <span>&#34;)&#34;</span> <span>&#34;a&#34;</span> <span>&#34;a&#34;</span> <span>&#34;a&#34;</span> <span>&#34;(&#34;</span>
<span>=</span> <span>01</span> <span>01</span> <span>01</span> <span>01</span> <span>01</span> <span>[string-concatenator]</span> <span>110</span> <span>10</span> <span>10</span> <span>10</span> <span>1110</span>
</code></pre></div></div>

<p>Notice that the letter “a” is encoded as <code>01 ... 10</code>, which effectively only takes 4 <em>bits</em>.
Similarly, “)” takes 5 and “)” takes 6 bits.
Since <code>apply</code> doesn’t increase the De Bruijn indices no matter how many times it appears,
every occurrence of the same character can be encoded into the same number of bits.
Therefore, by encoding each character in the order of of appearance, its BLC notation can be optimized to a short bit notation.</p>

<p>This part of the string generator can be seen as an interesting pattern in page 33 in <a href="https://woodrush.github.io/lambdalisp.pdf">lambdalisp.pdf</a>:</p>

<p><a href="https://danluu.com/blog/assets/posts/2022-09-17/pdf_33.png"><img src="https://danluu.com/blog/assets/posts/2022-09-17/pdf_33.png" alt="p.33 of lambdalisp.pdf."/></a></p>

<p>Here you can see lots of variables being applied to some lambda term shown on the top line,
which actually represents <code>string-concatenator</code>.</p>

<p>This consecutive application causes a lot of consecutive <code>(</code>s.
This makes page 32 entirely consist of <code>(</code>:</p>

<p><a href="https://danluu.com/blog/assets/posts/2022-09-17/pdf_32.png"><img src="https://danluu.com/blog/assets/posts/2022-09-17/pdf_32.png" alt="p.32 of lambdalisp.pdf."/></a></p>

<h2 id="language-features">Language Features</h2>
<h3 id="the-memory-model-for-persistent-bindings">The Memory Model for Persistent Bindings</h3>
<p><code>let</code> bindings are stored in the <code>heap</code> in the <code>state</code> and passed on as persistent bindings.
Each <code>let</code> binding holds their own environment stack, and each environment stack points to its lexical parent environment stack.
For example, the following LambdaLisp code:</p>

<div><div><pre><code><span>;; LambdaLisp</span>
<span>(</span><span>let</span> <span>((</span><span>x</span> <span>10</span><span>)</span> <span>(</span><span>y</span> <span>20</span><span>))</span>
  <span>(</span><span>setq</span> <span>x</span> <span>5</span><span>)</span>
  <span>(</span><span>let</span> <span>((</span><span>f</span> <span>(</span><span>lambda</span> <span>...</span><span>))</span> <span>(</span><span>a</span> <span>&#39;</span><span>(</span><span>a</span> <span>b</span> <span>c</span><span>)))</span>
    <span>(</span><span>print</span> <span>x</span><span>)</span>
    <span>...</span><span>)</span>
  <span>(</span><span>let</span> <span>((</span><span>g</span> <span>(</span><span>lambda</span> <span>...</span><span>))</span> <span>(</span><span>b</span> <span>&#39;</span><span>(</span><span>a</span> <span>b</span> <span>c</span><span>))</span>
    <span>(</span><span>print</span> <span>b</span><span>)</span>
    <span>...</span><span>)))</span>
</code></pre></div></div>

<p>induces the following memory tree:</p>

<p><a href="https://danluu.com/blog/assets/posts/2022-09-17/memtree.png"><img src="https://danluu.com/blog/assets/posts/2022-09-17/memtree.png" alt="The memory tree model." width="50%"/></a></p>

<p>The node containing <code>name = hello</code> is not relevant now.
The root node at the bottom contains bindings to basic functions initialized when running the prelude.
This memory tree is expressed in the heap as:</p>

<p><a href="https://danluu.com/blog/assets/posts/2022-09-17/heap.png"><img src="https://danluu.com/blog/assets/posts/2022-09-17/heap.png" alt="The heap data structure."/></a></p>

<p>Here, the virtual RAM address space is shown as 16 bits for simplicity (the actual address space is 32 bits).</p>

<p>When a <code>let</code> binding occurs, the newest unallocated heap address is allocated my the <code>malloc</code> function,
and the interpreter’s “current environment pointer” global variable contained in <code>reg</code> is rewritten to the newly allocated address.
This also happens when a lambda is called, creating an environment binding the lambda arguments.</p>

<p>Each stack is initialized with a redirection pointer that points to its parent environment, shown at the bottom of the stack in the second figure.
The bindings for each variable name is then pushed on top of the stack.
On variable lookup, the lookup function first looks at the current environment’s topmost binding.
If the target variable is not contained in the stack, the lookup reaches the redirection pointer at the bottom of the stack,
where it will run the lookup again for the environment pointed by the redirection pointer.
The lookup process ends when the redirection pointer is <code>nil</code>, where it concludes that the target variable is not bound to any value in the target environment.
The use of the redirection pointer effectively models the environments’ tree structure.</p>

<p>For example, the <code>x</code> in the <code>(print x)</code> in the example code will invoke a lookup for <code>x</code>.
The lookup function first looks at the binding stack at address <code>0x0002</code> and searches the stack until it reaches the redirection pointer to 0x0001.
The lookup function then searches the binding stack at 0x0001, where it finds the newest binding of <code>x</code> which is <code>x == 5</code>.
Since new bindings are pushed onto the stack, they get found before old bindings (here, <code>x = 10</code>) are reached.</p>

<p>Variable rewriting with <code>setq</code> is done by pushing assignments onto the stack.
The <code>(setq x 5)</code> first searches for the variable <code>x</code>, finds it at environment 0x0001, then pushes <code>x = 5</code> on top of <code>y = 20 :: x = 10</code> on the environment 0x0001.</p>

<p>The address 0x0000 represents the base environment.
It first starts out by being initialized by the function and macro definitions in the prelude.
Variables stored in the base environment behave as global variables.
This is where <code>setq</code> and <code>defglobal</code> behave differently.
When <code>(setq x ...)</code> is called, <code>setq</code> first searches for <code>x</code> from the environment tree. If it finds <code>x</code> somewhere in the tree,
it rewrites the found <code>x</code> at that environment.
If it doesn’t find <code>x</code>, it defaults to pushing a new variable <code>x</code> to the <em>current</em> surrounding environment.
This way, <code>setq</code> will only affect known variables or local variables.
On the other hand, <code>defglobal</code> pushes the bindings to address 0x0000 no matter where it is called.
This way, the address 0x0000 can behave as a global environment.
The macro <code>defun</code> is defined using <code>defglobal</code> so that it always writes to the global environment.
The macro <code>defun-local</code> is defined using <code>setq</code> so that it writes in the local environment, allowing for Python and JavaScript-style local function definitions:</p>

<div><div><pre><code><span>;; LambdaLisp</span>
<span>(</span><span>defun</span> <span>f</span> <span>(</span><span>x</span> <span>y</span><span>)</span>
  <span>(</span><span>defun-local</span> <span>helper</span> <span>(</span><span>z</span><span>)</span>
    <span>(</span><span>*</span> <span>z</span> <span>z</span><span>))</span>
  <span>(</span><span>print</span> <span>helper</span><span>)</span> <span>;; =&gt; @lambda</span>
  <span>(</span><span>+</span> <span>(</span><span>helper</span> <span>x</span><span>)</span> <span>(</span><span>helper</span> <span>y</span><span>)))</span>

<span>(</span><span>print</span> <span>helper</span><span>)</span> <span>;; =&gt; (), since it is invisible from the global environment</span>
</code></pre></div></div>

<h3 id="garbage-collection">Garbage Collection</h3>
<p>Although there is no garbage collection for <code>let</code> and <code>setq</code> bindings, there is a minimal form of GC for macro expansion.
During an evaluation of a macro, there occurs 2 Lisp form evaluations:
one for constructing the expanded form, and another for evaluating the expanded form in the called environment.
Once the macro has been expanded, we know for sure that the bindings it has used will not be used again.
Therefore, macro bindings are allocated to the <em>stack</em> region which has negative addresses starting from 0xFFFF,
shown on the left half of the memory tree diagram and the heap diagram.
The stack region is freed once the macro expansion finishes.
This mechanism also supports nested macros.</p>

<p>In the memory tree in the first figure in the previous section,
the bindings for macros look the same as the bindings for lambdas,
since at evaluation time they are treated the same.
In the second figure, the environments for the macro bindings are shown on the left side of the RAM,
since they are allocated in the stack region.</p>

<p>Although the same garbage-collection feature could be implemented for lambdas,
it causes problems for lambdas that return closures.
If lambda bindings are created in the stack region,
the environment of the returned closure will point to the stack region, which will be freed right after the closure is returned.
This causes a problem when the returned closure refers to a variable defined in the global environment (for example, to basic macros defined in the prelude such as <code>cond</code>),
since the lookup function will eventually start looking at the stack region,
which could be occupied by an old environment or some other lambda’s environment, causing the risk for bugs.
This could be circumvented by carefully writing the code to not shadow global variables in <code>let</code> bindings,
but that would severely restrict the coding style, so I chose to allocate new bindings for each lambda call.
The growing memory can be freed by implementing a mark-and-sweep garbage collection function, which is currently not supported by LambdaLisp.</p>

<h3 id="macros">Macros</h3>
<p>Macros are implemented as first-class objects in LambdaLisp.
Both macros and lambdas are subtypes of the type <code>lambda</code>, each annotated with a subtype tag.</p>

<p>Macros are treated the same as lambdas, except for the following differences:</p>

<ul>
  <li>The arguments are taken verbatim and are not evaluated before being bound to the argument variable names.
    <ul>
      <li>In lambdas, the arguments are evaluated before being bound.</li>
    </ul>
  </li>
  <li>Two evaluations happen during a macro evaluation. The first evaluation evaluates the macro body to build the macro-expanded expression.
The expanded expression is then evaluated in the environment which the macro was called.
    <ul>
      <li>In lambdas, only one evaluation (the latter one) happens.</li>
    </ul>
  </li>
  <li>The first evaluation always has the base environment <code>0x00000000</code> set as its parent environment
so that expansion always happens in the global environment, as explained in the previous section.
    <ul>
      <li>The second evaluation works the same as lambdas, where the environment where the macro/lambda was called is used for evaluation.</li>
    </ul>
  </li>
  <li>The environment for the bound variables are stored in the stack region (negative addresses starting from <code>0xFFFFFFFF</code>).
    <ul>
      <li>In lambdas, they are stored in the heap region (starting from <code>0x00000001</code>).</li>
    </ul>
  </li>
</ul>

<p>An anonymous macro can be made with the <code>macro</code> keyword as <code>(macro (...) ...)</code>, in the exact same syntax as lambdas.
In the <a href="https://github.com/woodrush/lambdalisp/blob/main/src/prelude.lisp">prelude</a>, <code>defmacro</code> is defined as the following <code>macro</code>:</p>

<div><div><pre><code><span>;; LambdaLisp</span>
<span>(</span><span>defglobal</span> <span>defmacro</span> <span>(</span><span>macro</span> <span>(</span><span>name</span> <span>e</span> <span>&amp;rest</span> <span>b</span><span>)</span>
  <span>`</span><span>(</span><span>defglobal</span> <span>,</span><span>name</span> <span>(</span><span>macro</span> <span>,</span><span>e</span> <span>(</span><span>block</span> <span>,</span><span>name</span> <span>,@</span><span>b</span><span>)))))</span>
</code></pre></div></div>

<h3 id="object-oriented-programming">Object-Oriented Programming</h3>
<p>In <a href="https://letoverlambda.com/">Let Over Lambda</a>, it is mentioned that object-oriented programming can be implemented by using closures (<a href="https://letoverlambda.com/index.cl/guest/chap2.html#sec_1">Chapter 2</a>).
A primitive example is the counter example we’ve seen at the beginning:</p>

<div><div><pre><code><span>(</span><span>defun</span> <span>new-counter</span> <span>(</span><span>init</span><span>)</span>
  <span>;; Return a closure.</span>
  <span>;; Use the let over lambda technique for creating independent and persistent variables.</span>
  <span>(</span><span>let</span> <span>((</span><span>i</span> <span>init</span><span>))</span>
    <span>(</span><span>lambda</span> <span>()</span> <span>(</span><span>setq</span> <span>i</span> <span>(</span><span>+</span> <span>1</span> <span>i</span><span>)))))</span>

<span>;; Instantiate counters</span>
<span>(</span><span>setq</span> <span>counter1</span> <span>(</span><span>new-counter</span> <span>0</span><span>))</span>
<span>(</span><span>setq</span> <span>counter2</span> <span>(</span><span>new-counter</span> <span>10</span><span>))</span>

<span>(</span><span>print</span> <span>(</span><span>counter1</span><span>))</span> <span>;; =&gt; 1</span>
<span>(</span><span>print</span> <span>(</span><span>counter1</span><span>))</span> <span>;; =&gt; 2</span>
<span>(</span><span>print</span> <span>(</span><span>counter2</span><span>))</span> <span>;; =&gt; 11</span>
<span>(</span><span>print</span> <span>(</span><span>counter1</span><span>))</span> <span>;; =&gt; 3</span>
<span>(</span><span>print</span> <span>(</span><span>counter2</span><span>))</span> <span>;; =&gt; 12</span>
<span>(</span><span>print</span> <span>(</span><span>counter1</span><span>))</span> <span>;; =&gt; 4</span>
<span>(</span><span>print</span> <span>(</span><span>counter1</span><span>))</span> <span>;; =&gt; 5</span>
</code></pre></div></div>

<p>LambdaLisp extends this concept and implements OOP as a predefined macro in the <a href="https://github.com/woodrush/lambdalisp/blob/main/src/prelude.lisp">prelude</a>.
LambdaLisp supports the following Python-like object system with class inheritance:</p>

<div><div><pre><code><span>(</span><span>defclass</span> <span>Counter</span> <span>()</span>
  <span>(</span><span>i</span> <span>0</span><span>)</span>

  <span>(</span><span>defmethod</span> <span>inc</span> <span>()</span>
    <span>(</span><span>setf</span> <span>(</span><span>.</span> <span>self</span> <span>i</span><span>)</span> <span>(</span><span>+</span> <span>1</span> <span>(</span><span>.</span> <span>self</span> <span>i</span><span>))))</span>

  <span>(</span><span>defmethod</span> <span>dec</span> <span>()</span>
    <span>(</span><span>setf</span> <span>(</span><span>.</span> <span>self</span> <span>i</span><span>)</span> <span>(</span><span>-</span> <span>(</span><span>.</span> <span>self</span> <span>i</span><span>)</span> <span>1</span><span>))))</span>


<span>(</span><span>defclass</span> <span>Counter-add</span> <span>(</span><span>Counter</span><span>)</span>
  <span>(</span><span>defmethod</span> <span>*init</span> <span>(</span><span>i</span><span>)</span>
    <span>(</span><span>setf</span> <span>(</span><span>.</span> <span>self</span> <span>i</span><span>)</span> <span>i</span><span>))</span>

  <span>(</span><span>defmethod</span> <span>add</span> <span>(</span><span>n</span><span>)</span>
    <span>(</span><span>setf</span> <span>(</span><span>.</span> <span>self</span> <span>i</span><span>)</span> <span>(</span><span>+</span> <span>(</span><span>.</span> <span>self</span> <span>i</span><span>)</span> <span>n</span><span>))))</span>


<span>(</span><span>defclass</span> <span>Counter-addsub</span> <span>(</span><span>Counter-add</span><span>)</span>
  <span>(</span><span>defmethod</span> <span>*init</span> <span>(</span><span>c</span><span>)</span>
    <span>((</span><span>.</span> <span>(</span><span>.</span> <span>self</span> <span>super</span><span>)</span> <span>*init</span><span>)</span> <span>c</span><span>))</span>

  <span>(</span><span>defmethod</span> <span>sub</span> <span>(</span><span>n</span><span>)</span>
    <span>(</span><span>setf</span> <span>(</span><span>.</span> <span>self</span> <span>i</span><span>)</span> <span>(</span><span>-</span> <span>(</span><span>.</span> <span>self</span> <span>i</span><span>)</span> <span>n</span><span>))))</span>


<span>(</span><span>defparameter</span> <span>counter1</span> <span>(</span><span>new</span> <span>Counter</span><span>))</span>
<span>(</span><span>defparameter</span> <span>counter2</span> <span>(</span><span>new</span> <span>Counter-add</span> <span>100</span><span>))</span>
<span>(</span><span>defparameter</span> <span>counter3</span> <span>(</span><span>new</span> <span>Counter-addsub</span> <span>10000</span><span>))</span>

<span>((</span><span>.</span> <span>counter1</span> <span>inc</span><span>))</span>
<span>((</span><span>.</span> <span>counter2</span> <span>add</span><span>)</span> <span>100</span><span>)</span>
<span>((</span><span>.</span> <span>counter3</span> <span>sub</span><span>)</span> <span>10000</span><span>)</span>

<span>(</span><span>setf</span> <span>(</span><span>.</span> <span>counter1</span> <span>i</span><span>)</span> <span>5</span><span>)</span>
<span>(</span><span>setf</span> <span>(</span><span>.</span> <span>counter2</span> <span>i</span><span>)</span> <span>500</span><span>)</span>
<span>(</span><span>setf</span> <span>(</span><span>.</span> <span>counter3</span> <span>i</span><span>)</span> <span>50000</span><span>)</span>
</code></pre></div></div>

<h3 id="blocks">Blocks</h3>
<p>The notion of blocks in LambdaLisp is a feature borrowed from Common Lisp, close to <code>for</code> and <code>break</code> in C and Java.
A <code>block</code> creates a code block that can be escaped by running <code>(return [value])</code> or <code>(return-from [name] [value])</code>.</p>

<p>For example:</p>
<div><div><pre><code><span>;; LambdaLisp</span>
<span>(</span><span>block</span> <span>block-a</span>
  <span>(</span><span>if</span> <span>some-condition</span>
    <span>(</span><span>return-from</span> <span>block-a</span> <span>some-value</span><span>))</span>
  <span>...</span>
  <span>some-other-value</span><span>)</span>
</code></pre></div></div>

<p>Here, when <code>some-condition</code> is true, the <code>return-from</code> lets the control immediately break from <code>block-a</code>,
setting the value of the <code>block</code> to <code>some-value</code>.
If <code>some-condition</code> is false, the program proceeds until the end, and the value of the <code>block</code> becomes <code>some-other-value</code>,
which is the same behavior as <code>progn</code>. Nested blocks are also possible, as shown in <a href="https://github.com/woodrush/lambdalisp/blob/main/examples/block.cl">examples/block.cl</a>.</p>

<p><code>defun</code> is defined to wrap its content with an implicit block, you can write <code>return-from</code> statements with the function name:</p>

<div><div><pre><code><span>;; LambdaLisp</span>
<span>(</span><span>defun</span> <span>f</span> <span>(</span><span>x</span><span>)</span>
  <span>(</span><span>if</span> <span>some-condition</span>
    <span>(</span><span>return-from</span> <span>f</span> <span>some-value</span><span>))</span>
  <span>(</span><span>if</span> <span>some-condition2</span>
    <span>(</span><span>return-from</span> <span>f</span> <span>some-value2</span><span>)</span>
  <span>...</span><span>))</span>
</code></pre></div></div>

<p>Here is the definition of <code>defun</code> in the <a href="https://github.com/woodrush/lambdalisp/blob/main/src/prelude.lisp">prelude</a>:</p>

<div><div><pre><code><span>;; LambdaLisp</span>
<span>(</span><span>defmacro</span> <span>defun</span> <span>(</span><span>name</span> <span>e</span> <span>&amp;rest</span> <span>b</span><span>)</span>
  <span>`</span><span>(</span><span>defglobal</span> <span>,</span><span>name</span> <span>(</span><span>lambda</span> <span>,</span><span>e</span> <span>(</span><span>block</span> <span>,</span><span>name</span> <span>,@</span><span>b</span><span>))))</span>
</code></pre></div></div>

<p>In order to implement blocks, the interpreter keeps track of the name and the returning point of each block.
This is done by preparing a global variable <code>reg-block-cont</code> in the register,
used as a stack to push and pop name-returning-point pairs.
Since LambdaCraft is written in continuation-passing style, the returning point is explicitly given as the callback function <code>cont</code>
at any time in the <code>eval</code> function.
Using this feature, when a <code>block</code> form appears,
the interpreter first pushes the name and the current <code>cont</code> to the <code>reg-block-cont</code> global variable.
The pushed <code>cont</code> is a continuation that expects the return value of the <code>block</code> to be applied as its argument.
Whenever a <code>(return-from [name] [value])</code> form is called, the interpreter searches the <code>reg-block-cont</code> stack for the specified <code>[name]</code>.
Since the searched <code>cont</code> expects the return value of the <code>block</code> to be applied,
the block escape control flow can be realized by applying <code>[value]</code> to <code>cont</code>, after popping the <code>reg-block-cont</code> stack.</p>

<h3 id="loops">Loops</h3>
<p>A <code>loop</code> is a special form equivalent to <code>while (true)</code> in languages such as C, used to create infinite loops.
A <code>loop</code> creates an implicit block with the name <code>()</code>, and can be exited by running <code>(return)</code> inside:</p>

<div><div><pre><code><span>;; LambdaLisp</span>
<span>(</span><span>defparameter</span> <span>i</span> <span>0</span><span>)</span>
<span>(</span><span>loop</span>
  <span>(</span><span>if</span> <span>(</span><span>=</span> <span>i</span> <span>10</span><span>)</span>
    <span>(</span><span>return</span><span>))</span>
  <span>(</span><span>print</span> <span>i</span><span>)</span>
  <span>(</span><span>setq</span> <span>i</span> <span>(</span><span>+</span> <span>i</span> <span>1</span><span>)))</span>
</code></pre></div></div>

<p>Loops can also be exited by surrounding it with a <code>block</code>:</p>

<div><div><pre><code><span>;; LambdaLisp</span>
<span>(</span><span>defparameter</span> <span>i</span> <span>0</span><span>)</span>
<span>(</span><span>block</span> <span>loop-block</span>
  <span>(</span><span>loop</span>
    <span>(</span><span>if</span> <span>(</span><span>=</span> <span>i</span> <span>10</span><span>)</span>
      <span>(</span><span>return-from</span> <span>loop-block</span><span>))</span>
    <span>(</span><span>print</span> <span>i</span><span>)</span>
    <span>(</span><span>setq</span> <span>i</span> <span>(</span><span>+</span> <span>i</span> <span>1</span><span>))))</span>
</code></pre></div></div>

<p>Loops are implemented by passing a self-referenced continuation that runs the contents of <code>loop</code> again.</p>

<h3 id="error-invocation-and-stack-traces">Error Invocation and Stack Traces</h3>
<p>Some examples of situations when errors are invoked in LambdaLisp are:</p>

<ul>
  <li>In <code>read-expr</code>:
    <ul>
      <li>When an unexpected <code>)</code> is seen</li>
    </ul>
  </li>
  <li>In <code>eval</code>:
    <ul>
      <li>When an unbound variable is being referenced</li>
    </ul>
  </li>
  <li>In <code>eval-apply</code> (used when lambdas or macros are called):
    <ul>
      <li>When the value in the function cell does not belong to a subtype of <code>lambda</code></li>
    </ul>
  </li>
</ul>

<p>When an error occurs during <code>eval</code>, <code>read-expr</code> or any function, the interpreter does the following:</p>

<ul>
  <li>It immediately stops what it’s doing</li>
  <li>It shows an error message</li>
  <li>It shows the function call stack trace</li>
  <li>It returns to the REPL, awaiting the user’s input</li>
</ul>

<p>Immediately stopping the current task and returning to the REPL is implemented very simply thanks to continuation-passing style.
When an error is invoked, instead of calling the continuation (the callback), the <code>repl</code> function is called - this simple implementation allows error invocation.</p>

<p>Since invoking an error calls <code>repl</code>,
and <code>repl</code> calls <code>read-expr</code>, <code>eval</code> and <code>eval-apply</code>,
this makes the four functions
<code>read-expr</code>, <code>eval</code>, <code>eval-apply</code> and <code>repl</code> be mutually recursive functions.
How mutually recursive functions are implemented in LambdaLisp is described later in the next section.</p>

<p>The function call stack trace is printed by managing a call stack in one of the interpreter’s global variables.
Every time a lambda or a macro is called, the interpreter pushes the expression that invoked the function call to the call stack. When the function call exits properly, the call stack is popped.
When an error is invoked during a function call, the interpreter prints the contents of the call stack.</p>

<h2 id="other-general-lambda-calculus-programming-techniques">Other General Lambda Calculus Programming Techniques</h2>
<p>Below are some other general lambda calclus programming techniques used in LambdaLisp.</p>

<h3 id="mutual-recursion">Mutual Recursion</h3>

<p>In LambdaCraft, recursive functions can be defined using <code>defrec-lazy</code> as follows:</p>

<div><div><pre><code><span>;; LambdaCraft</span>
<span>(</span><span>defrec-lazy</span> <span>fact</span> <span>(</span><span>n</span><span>)</span>
  <span>(</span><span>if</span> <span>(</span><span>&lt;=</span> <span>n</span> <span>0</span><span>)</span>
    <span>1</span>
    <span>(</span><span>*</span> <span>n</span> <span>(</span><span>fact</span> <span>(</span><span>-</span> <span>n</span> <span>1</span><span>)))))</span>
</code></pre></div></div>

<p><code>defrec-lazy</code> uses the <a href="https://en.wikipedia.org/wiki/Fixed-point_combinator">Y combinator</a> to implement <a href="https://en.wikipedia.org/wiki/Anonymous_recursion">anonymous recursion</a>,
a technique used to write self-referencing functions under the absence of a named function feature.
Since LambdaLisp is based on macro expansion, when a self-referencing function is written using <code>defun-lazy</code>,
the function body becomes infinitely expanded, causing the program to not compile.
LambdaCraft shows an error message in this case.
Using the Y combinator through <code>defrec-lazy</code> prevents this infinite expansion from happening.</p>

<p>Things get more complex in the case of what is called mutual recursion.
In LambdaLisp, the functions <code>read-expr</code>, <code>eval</code>, <code>eval-apply</code>, and <code>repl</code> are mutually recursive,
meaning that these functions call each other inside their definitions.
Although using the normal Y combinator would still make the code compilable in this case,
it makes the same function be inlined over and over again, severely expanding the total output lambda term size.</p>

<p>The redundant inlining problem can be solved if each function held a reference to each other. This can be done by implementing a multiple-function version of the Y combinator.
The derivation of a fixed point combinator for mutual recursion is described very intuitively in
Wessel Bruinsma’s blog post, <a href="https://invenia.github.io/blog/2018/08/20/ycombinator/">A Short Note on The Y Combinator</a>,
in the section “Deriving the Y Combinator”.
Below is a summary of the derivation process introduced in this post.</p>

<p>Suppose that we have two functions <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>f</span></span></span></span> and <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>g</span></span></span></span> that are mutually recursive.
Since they reference each other in their definitions, <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>f</span></span></span></span> and <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>g</span></span></span></span> can be defined in terms of some function <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mi>f</mi></msub></mrow><annotation encoding="application/x-tex">h_f</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>h</span><span><span><span><span><span><span></span><span><span>f</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span> and <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mi>g</mi></msub></mrow><annotation encoding="application/x-tex">h_g</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>h</span><span><span><span><span><span><span></span><span><span>g</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span>, which takes the definitions of <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>f</span></span></span></span> and <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>g</span></span></span></span> as its arguments:</p>

<p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left right" columnspacing="0em 1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>f</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>:</mo><mo>=</mo><msub><mi>h</mi><mi>f</mi></msub><mi>f</mi><mi>g</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>g</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>:</mo><mo>=</mo><msub><mi>h</mi><mi>g</mi></msub><mi>f</mi><mi>g</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
f &amp;:= h_f f g &amp; (1)\\
g &amp;:= h_g f g &amp; (2)\\
\end{aligned}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span><span><span><span><span><span></span><span><span>f</span></span></span><span><span></span><span><span>g</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span><span><span><span><span><span></span><span><span></span><span></span><span>:=</span><span></span><span><span>h</span><span><span><span><span><span><span></span><span><span>f</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span>f</span><span>g</span></span></span><span><span></span><span><span></span><span></span><span>:=</span><span></span><span><span>h</span><span><span><span><span><span><span></span><span><span>g</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span>f</span><span>g</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span></span><span><span><span><span><span><span></span><span><span>(</span><span>1</span><span>)</span></span></span><span><span></span><span><span>(</span><span>2</span><span>)</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span></span></span></p><p><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mi>f</mi></msub></mrow><annotation encoding="application/x-tex">h_f</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>h</span><span><span><span><span><span><span></span><span><span>f</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span> and <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mi>g</mi></msub></mrow><annotation encoding="application/x-tex">h_g</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>h</span><span><span><span><span><span><span></span><span><span>g</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span> looks something like:</p>

<p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><msub><mi>h</mi><mi>f</mi></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>λ</mi><msup><mi>f</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mi mathvariant="normal">.</mi><mi>λ</mi><msup><mi>g</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mi mathvariant="normal">.</mi><mi>λ</mi><mi>x</mi><mi mathvariant="normal">.</mi><msub><mi>k</mi><mi>f</mi></msub><mo stretchy="false">[</mo><msup><mi>f</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo separator="true">,</mo><msup><mi>g</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">]</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><msub><mi>h</mi><mi>g</mi></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>λ</mi><msup><mi>f</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mi mathvariant="normal">.</mi><mi>λ</mi><msup><mi>g</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mi mathvariant="normal">.</mi><mi>λ</mi><mi>x</mi><mi mathvariant="normal">.</mi><msub><mi>k</mi><mi>g</mi></msub><mo stretchy="false">[</mo><msup><mi>f</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo separator="true">,</mo><msup><mi>g</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">]</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
h_f &amp;= \lambda f&#39;. \lambda g&#39;. \lambda x. k_f [f&#39;,g&#39;,x] \\
h_g &amp;= \lambda f&#39;. \lambda g&#39;. \lambda x. k_g [f&#39;,g&#39;,x] \\
\end{aligned}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span><span><span><span><span><span></span><span><span><span>h</span><span><span><span><span><span><span></span><span><span>f</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span><span><span></span><span><span><span>h</span><span><span><span><span><span><span></span><span><span>g</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span><span><span><span><span><span></span><span><span></span><span></span><span>=</span><span></span><span>λ</span><span><span>f</span><span><span><span><span><span><span></span><span><span><span>′</span></span></span></span></span></span></span></span></span><span>.</span><span>λ</span><span><span>g</span><span><span><span><span><span><span></span><span><span><span>′</span></span></span></span></span></span></span></span></span><span>.</span><span>λ</span><span>x</span><span>.</span><span><span>k</span><span><span><span><span><span><span></span><span><span>f</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span>[</span><span><span>f</span><span><span><span><span><span><span></span><span><span><span>′</span></span></span></span></span></span></span></span></span><span>,</span><span></span><span><span>g</span><span><span><span><span><span><span></span><span><span><span>′</span></span></span></span></span></span></span></span></span><span>,</span><span></span><span>x</span><span>]</span></span></span><span><span></span><span><span></span><span></span><span>=</span><span></span><span>λ</span><span><span>f</span><span><span><span><span><span><span></span><span><span><span>′</span></span></span></span></span></span></span></span></span><span>.</span><span>λ</span><span><span>g</span><span><span><span><span><span><span></span><span><span><span>′</span></span></span></span></span></span></span></span></span><span>.</span><span>λ</span><span>x</span><span>.</span><span><span>k</span><span><span><span><span><span><span></span><span><span>g</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span>[</span><span><span>f</span><span><span><span><span><span><span></span><span><span><span>′</span></span></span></span></span></span></span></span></span><span>,</span><span></span><span><span>g</span><span><span><span><span><span><span></span><span><span><span>′</span></span></span></span></span></span></span></span></span><span>,</span><span></span><span>x</span><span>]</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span></span></span></p><p>Where <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>k</mi><mo>∗</mo></msub><mo stretchy="false">[</mo><msup><mi>f</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo separator="true">,</mo><msup><mi>g</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">k_* [f&#39;,g&#39;,x]</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>k</span><span><span><span><span><span><span></span><span><span>∗</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span>[</span><span><span>f</span><span><span><span><span><span><span></span><span><span><span>′</span></span></span></span></span></span></span></span></span><span>,</span><span></span><span><span>g</span><span><span><span><span><span><span></span><span><span><span>′</span></span></span></span></span></span></span></span></span><span>,</span><span></span><span>x</span><span>]</span></span></span></span> is a term containing <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo separator="true">,</mo><msup><mi>g</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">f&#39;, g&#39;</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>f</span><span><span><span><span><span><span></span><span><span><span>′</span></span></span></span></span></span></span></span></span><span>,</span><span></span><span><span>g</span><span><span><span><span><span><span></span><span><span><span>′</span></span></span></span></span></span></span></span></span></span></span></span> and <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>x</span></span></span></span>.</p>

<p>Now suppose that <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>f</span></span></span></span> and <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>g</span></span></span></span> could be written using some unknown function <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>f</mi><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">\hat f</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span><span><span><span></span><span>f</span></span><span><span></span><span><span>^</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span> and <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>g</mi><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">\hat g</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span><span><span><span></span><span>g</span></span><span><span></span><span><span>^</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span> as:</p>

<p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>f</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>:</mo><mo>=</mo><mover accent="true"><mi>f</mi><mo>^</mo></mover><mover accent="true"><mi>f</mi><mo>^</mo></mover><mover accent="true"><mi>g</mi><mo>^</mo></mover></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>g</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>:</mo><mo>=</mo><mover accent="true"><mi>g</mi><mo>^</mo></mover><mover accent="true"><mi>f</mi><mo>^</mo></mover><mover accent="true"><mi>g</mi><mo>^</mo></mover></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
f &amp;:= \hat f \hat f \hat g \\
g &amp;:= \hat g \hat f \hat g
\end{aligned}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span><span><span><span><span><span></span><span><span>f</span></span></span><span><span></span><span><span>g</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span><span><span><span><span><span></span><span><span></span><span></span><span>:=</span><span></span><span><span><span><span><span><span></span><span>f</span></span><span><span></span><span><span>^</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span><span><span><span><span><span></span><span>f</span></span><span><span></span><span><span>^</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span><span><span><span><span><span></span><span>g</span></span><span><span></span><span><span>^</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span><span><span></span><span><span></span><span></span><span>:=</span><span></span><span><span><span><span><span><span></span><span>g</span></span><span><span></span><span><span>^</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span><span><span><span><span><span></span><span>f</span></span><span><span></span><span><span>^</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span><span><span><span><span><span></span><span>g</span></span><span><span></span><span><span>^</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span></span></span></p><p>Plugging this into Equations (1) and (2),</p>

<p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mover accent="true"><mi>f</mi><mo>^</mo></mover><mover accent="true"><mi>f</mi><mo>^</mo></mover><mover accent="true"><mi>g</mi><mo>^</mo></mover></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><msub><mi>h</mi><mi>f</mi></msub><mo stretchy="false">(</mo><mover accent="true"><mi>f</mi><mo>^</mo></mover><mover accent="true"><mi>f</mi><mo>^</mo></mover><mover accent="true"><mi>g</mi><mo>^</mo></mover><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mover accent="true"><mi>g</mi><mo>^</mo></mover><mover accent="true"><mi>f</mi><mo>^</mo></mover><mover accent="true"><mi>g</mi><mo>^</mo></mover><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mover accent="true"><mi>g</mi><mo>^</mo></mover><mover accent="true"><mi>f</mi><mo>^</mo></mover><mover accent="true"><mi>g</mi><mo>^</mo></mover></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><msub><mi>h</mi><mi>g</mi></msub><mo stretchy="false">(</mo><mover accent="true"><mi>f</mi><mo>^</mo></mover><mover accent="true"><mi>f</mi><mo>^</mo></mover><mover accent="true"><mi>g</mi><mo>^</mo></mover><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mover accent="true"><mi>g</mi><mo>^</mo></mover><mover accent="true"><mi>f</mi><mo>^</mo></mover><mover accent="true"><mi>g</mi><mo>^</mo></mover><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
\hat f \hat f \hat g  &amp;= h_f (\hat f \hat f \hat g) (\hat g \hat f \hat g ) \\
\hat g \hat f \hat g  &amp;= h_g (\hat f \hat f \hat g) (\hat g \hat f \hat g ) \\
\end{aligned}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span><span><span><span><span><span></span><span><span><span><span><span><span><span></span><span>f</span></span><span><span></span><span><span>^</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span><span><span><span><span><span></span><span>f</span></span><span><span></span><span><span>^</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span><span><span><span><span><span></span><span>g</span></span><span><span></span><span><span>^</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span><span><span></span><span><span><span><span><span><span><span></span><span>g</span></span><span><span></span><span><span>^</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span><span><span><span><span><span></span><span>f</span></span><span><span></span><span><span>^</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span><span><span><span><span><span></span><span>g</span></span><span><span></span><span><span>^</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span><span><span><span><span><span></span><span><span></span><span></span><span>=</span><span></span><span><span>h</span><span><span><span><span><span><span></span><span><span>f</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span>(</span><span><span><span><span><span><span></span><span>f</span></span><span><span></span><span><span>^</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span><span><span><span><span><span></span><span>f</span></span><span><span></span><span><span>^</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span><span><span><span><span><span></span><span>g</span></span><span><span></span><span><span>^</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span>)</span><span>(</span><span><span><span><span><span><span></span><span>g</span></span><span><span></span><span><span>^</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span><span><span><span><span><span></span><span>f</span></span><span><span></span><span><span>^</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span><span><span><span><span><span></span><span>g</span></span><span><span></span><span><span>^</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span>)</span></span></span><span><span></span><span><span></span><span></span><span>=</span><span></span><span><span>h</span><span><span><span><span><span><span></span><span><span>g</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span>(</span><span><span><span><span><span><span></span><span>f</span></span><span><span></span><span><span>^</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span><span><span><span><span><span></span><span>f</span></span><span><span></span><span><span>^</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span><span><span><span><span><span></span><span>g</span></span><span><span></span><span><span>^</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span>)</span><span>(</span><span><span><span><span><span><span></span><span>g</span></span><span><span></span><span><span>^</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span><span><span><span><span><span></span><span>f</span></span><span><span></span><span><span>^</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span><span><span><span><span><span></span><span>g</span></span><span><span></span><span><span>^</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span>)</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span></span></span></p><p>Which can be abstracted as</p>

<p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mover accent="true"><mi>f</mi><mo>^</mo></mover><mover accent="true"><mi>f</mi><mo>^</mo></mover><mover accent="true"><mi>g</mi><mo>^</mo></mover></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mo stretchy="false">(</mo><mi>λ</mi><mi>x</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>y</mi><mi mathvariant="normal">.</mi><msub><mi>h</mi><mi>f</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mi>x</mi><mi>y</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>y</mi><mi>x</mi><mi>y</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mover accent="true"><mi>f</mi><mo>^</mo></mover><mover accent="true"><mi>g</mi><mo>^</mo></mover></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mover accent="true"><mi>g</mi><mo>^</mo></mover><mover accent="true"><mi>f</mi><mo>^</mo></mover><mover accent="true"><mi>g</mi><mo>^</mo></mover></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mo stretchy="false">(</mo><mi>λ</mi><mi>x</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>y</mi><mi mathvariant="normal">.</mi><msub><mi>h</mi><mi>g</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mi>x</mi><mi>y</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>y</mi><mi>x</mi><mi>y</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mover accent="true"><mi>f</mi><mo>^</mo></mover><mover accent="true"><mi>g</mi><mo>^</mo></mover></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
\hat f \hat f \hat g  &amp;= (\lambda x. \lambda y. h_f (x x y) (y x y)) \hat f \hat g \\
\hat g \hat f \hat g  &amp;= (\lambda x. \lambda y. h_g (x x y) (y x y)) \hat f \hat g \\
\end{aligned}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span><span><span><span><span><span></span><span><span><span><span><span><span><span></span><span>f</span></span><span><span></span><span><span>^</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span><span><span><span><span><span></span><span>f</span></span><span><span></span><span><span>^</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span><span><span><span><span><span></span><span>g</span></span><span><span></span><span><span>^</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span><span><span></span><span><span><span><span><span><span><span></span><span>g</span></span><span><span></span><span><span>^</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span><span><span><span><span><span></span><span>f</span></span><span><span></span><span><span>^</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span><span><span><span><span><span></span><span>g</span></span><span><span></span><span><span>^</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span><span><span><span><span><span></span><span><span></span><span></span><span>=</span><span></span><span>(</span><span>λ</span><span>x</span><span>.</span><span>λ</span><span>y</span><span>.</span><span><span>h</span><span><span><span><span><span><span></span><span><span>f</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span>(</span><span>xx</span><span>y</span><span>)</span><span>(</span><span>y</span><span>x</span><span>y</span><span>))</span><span><span><span><span><span><span></span><span>f</span></span><span><span></span><span><span>^</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span><span><span><span><span><span></span><span>g</span></span><span><span></span><span><span>^</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span><span><span></span><span><span></span><span></span><span>=</span><span></span><span>(</span><span>λ</span><span>x</span><span>.</span><span>λ</span><span>y</span><span>.</span><span><span>h</span><span><span><span><span><span><span></span><span><span>g</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span>(</span><span>xx</span><span>y</span><span>)</span><span>(</span><span>y</span><span>x</span><span>y</span><span>))</span><span><span><span><span><span><span></span><span>f</span></span><span><span></span><span><span>^</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span><span><span><span><span><span></span><span>g</span></span><span><span></span><span><span>^</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span></span></span></p><p>Comparing both sides, we have</p>

<p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mover accent="true"><mi>f</mi><mo>^</mo></mover></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>λ</mi><mi>x</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>y</mi><mi mathvariant="normal">.</mi><msub><mi>h</mi><mi>f</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mi>x</mi><mi>y</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>y</mi><mi>x</mi><mi>y</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mover accent="true"><mi>g</mi><mo>^</mo></mover></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>λ</mi><mi>x</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>y</mi><mi mathvariant="normal">.</mi><msub><mi>h</mi><mi>g</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mi>x</mi><mi>y</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>y</mi><mi>x</mi><mi>y</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
\hat f &amp;= \lambda x. \lambda y. h_f (x x y) (y x y) \\
\hat g &amp;= \lambda x. \lambda y. h_g (x x y) (y x y) \\
\end{aligned}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span><span><span><span><span><span></span><span><span><span><span><span><span><span></span><span>f</span></span><span><span></span><span><span>^</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span><span><span></span><span><span><span><span><span><span><span></span><span>g</span></span><span><span></span><span><span>^</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span><span><span><span><span><span></span><span><span></span><span></span><span>=</span><span></span><span>λ</span><span>x</span><span>.</span><span>λ</span><span>y</span><span>.</span><span><span>h</span><span><span><span><span><span><span></span><span><span>f</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span>(</span><span>xx</span><span>y</span><span>)</span><span>(</span><span>y</span><span>x</span><span>y</span><span>)</span></span></span><span><span></span><span><span></span><span></span><span>=</span><span></span><span>λ</span><span>x</span><span>.</span><span>λ</span><span>y</span><span>.</span><span><span>h</span><span><span><span><span><span><span></span><span><span>g</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span><span>(</span><span>xx</span><span>y</span><span>)</span><span>(</span><span>y</span><span>x</span><span>y</span><span>)</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span></span></span></p><p>which are closed-form lambda expressions.
Plugging this into our definitions
<span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mo>=</mo><mover accent="true"><mi>f</mi><mo>^</mo></mover><mover accent="true"><mi>f</mi><mo>^</mo></mover><mover accent="true"><mi>g</mi><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">f := \hat f \hat f \hat g</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>f</span><span></span><span>:=</span><span></span></span><span><span></span><span><span><span><span><span><span></span><span>f</span></span><span><span></span><span><span>^</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span><span><span><span><span><span></span><span>f</span></span><span><span></span><span><span>^</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span><span><span><span><span><span></span><span>g</span></span><span><span></span><span><span>^</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span> and <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>:</mo><mo>=</mo><mover accent="true"><mi>g</mi><mo>^</mo></mover><mover accent="true"><mi>f</mi><mo>^</mo></mover><mover accent="true"><mi>g</mi><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">g := \hat g \hat f \hat g</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>g</span><span></span><span>:=</span><span></span></span><span><span></span><span><span><span><span><span><span></span><span>g</span></span><span><span></span><span><span>^</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span><span><span><span><span><span></span><span>f</span></span><span><span></span><span><span>^</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span><span><span><span><span><span></span><span>g</span></span><span><span></span><span><span>^</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span>,
we get the mutually recursive definitions of <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>f</span></span></span></span> and <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>g</span></span></span></span>.</p>

<p>A 4-function version of this mutual recursion setup is used in the <code>init</code> function in LambdaLisp to define
<code>repl</code>, <code>eval-apply</code>, <code>read-expr</code>, and <code>eval</code>:</p>

<div><div><pre><code><span>;; LambdaCraft</span>
<span>(</span><span>let*</span> <span>read-expr-hat</span>  <span>(</span><span>lambda</span> <span>(</span><span>x</span> <span>y</span> <span>z</span> <span>w</span><span>)</span> <span>(</span><span>def-read-expr</span>  <span>(</span><span>x</span> <span>x</span> <span>y</span> <span>z</span> <span>w</span><span>)</span> <span>(</span><span>y</span> <span>x</span> <span>y</span> <span>z</span> <span>w</span><span>)</span> <span>(</span><span>z</span> <span>x</span> <span>y</span> <span>z</span> <span>w</span><span>)</span> <span>(</span><span>w</span> <span>x</span> <span>y</span> <span>z</span> <span>w</span><span>))))</span>
<span>(</span><span>let*</span> <span>eval-hat</span>       <span>(</span><span>lambda</span> <span>(</span><span>x</span> <span>y</span> <span>z</span> <span>w</span><span>)</span> <span>(</span><span>def-eval</span>       <span>(</span><span>x</span> <span>x</span> <span>y</span> <span>z</span> <span>w</span><span>)</span> <span>(</span><span>y</span> <span>x</span> <span>y</span> <span>z</span> <span>w</span><span>)</span> <span>(</span><span>z</span> <span>x</span> <span>y</span> <span>z</span> <span>w</span><span>)</span> <span>(</span><span>w</span> <span>x</span> <span>y</span> <span>z</span> <span>w</span><span>))))</span>
<span>(</span><span>let*</span> <span>eval-apply-hat</span> <span>(</span><span>lambda</span> <span>(</span><span>x</span> <span>y</span> <span>z</span> <span>w</span><span>)</span> <span>(</span><span>def-eval-apply</span> <span>(</span><span>x</span> <span>x</span> <span>y</span> <span>z</span> <span>w</span><span>)</span> <span>(</span><span>y</span> <span>x</span> <span>y</span> <span>z</span> <span>w</span><span>)</span> <span>(</span><span>z</span> <span>x</span> <span>y</span> <span>z</span> <span>w</span><span>)</span> <span>(</span><span>w</span> <span>x</span> <span>y</span> <span>z</span> <span>w</span><span>))))</span>
<span>(</span><span>let*</span> <span>repl-hat</span>       <span>(</span><span>lambda</span> <span>(</span><span>x</span> <span>y</span> <span>z</span> <span>w</span><span>)</span> <span>(</span><span>def-repl</span>       <span>(</span><span>x</span> <span>x</span> <span>y</span> <span>z</span> <span>w</span><span>)</span> <span>(</span><span>y</span> <span>x</span> <span>y</span> <span>z</span> <span>w</span><span>)</span> <span>(</span><span>z</span> <span>x</span> <span>y</span> <span>z</span> <span>w</span><span>)</span> <span>(</span><span>w</span> <span>x</span> <span>y</span> <span>z</span> <span>w</span><span>))))</span>
<span>(</span><span>let*</span> <span>repl</span>       <span>(</span><span>repl-hat</span>       <span>read-expr-hat</span> <span>eval-hat</span> <span>eval-apply-hat</span> <span>repl-hat</span><span>))</span>
<span>(</span><span>let*</span> <span>eval-apply</span> <span>(</span><span>eval-apply-hat</span> <span>read-expr-hat</span> <span>eval-hat</span> <span>eval-apply-hat</span> <span>repl-hat</span><span>))</span>
<span>(</span><span>let*</span> <span>read-expr</span>  <span>(</span><span>read-expr-hat</span>  <span>read-expr-hat</span> <span>eval-hat</span> <span>eval-apply-hat</span> <span>repl-hat</span><span>))</span>
<span>(</span><span>let*</span> <span>eval</span>       <span>(</span><span>eval-hat</span>       <span>read-expr-hat</span> <span>eval-hat</span> <span>eval-apply-hat</span> <span>repl-hat</span><span>))</span>
</code></pre></div></div>

<p>The functions <code>*-hat</code> and <code>def-*</code>
each correspond to <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mo>∗</mo><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">\hat *</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span><span><span><span></span><span>∗</span></span><span><span></span><span><span>^</span></span></span></span></span></span></span></span></span></span> and <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mo>∗</mo></msub></mrow><annotation encoding="application/x-tex">h_*</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>h</span><span><span><span><span><span><span></span><span><span>∗</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span> in the derivation.
The final functions <code>repl eval-apply read-expr eval</code>
are defined in terms of these auxiliary functions.</p>

<p>The functions <code>def-*</code> are defined in a separate location.
<code>def-eval</code>, used to define <code>eval</code>, is defined as follows:</p>

<div><div><pre><code><span>;; LambdaCraft</span>
<span>(</span><span>defun-lazy</span> <span>def-eval</span> <span>(</span><span>read-expr</span> <span>eval</span> <span>eval-apply</span> <span>repl</span> <span>expr</span> <span>state</span> <span>cont</span><span>)</span>
  <span>...</span><span>)</span>
</code></pre></div></div>

<p><code>def-eval</code> is defined as a non-recursive function using <code>defun-lazy</code>,
taking the four mutually dependent functions <code>read-expr eval eval-apply repl</code> as the first four arguments,
followed by its “actual” arguments <code>expr state cont</code>.
The first four arguments are occupied in the expression <code>(def-read-expr (x x y z w) (y x y z w) (z x y z w) (w x y z w))</code> in the definition of <code>read-expr-hat</code>. By currying, this lets <code>eval</code> only take the 3 remaining unbound arguments, <code>expr state cont</code>.</p>

<h3 id="deriving-isnil">Deriving ‘isnil’</h3>
<p><code>isnil</code> is one of the most important functions in <code>cons</code>-based lambda calculus programming,
bearing the importance comparable to the <code>atom</code> special form in McCarthy’s original pure Lisp.</p>

<p>Consider the following function <code>reverse</code> that reverses a <code>cons</code>-based list:</p>

<div><div><pre><code><span>;; LambdaCraft</span>
<span>(</span><span>defrec-lazy</span> <span>reverse</span> <span>(</span><span>l</span> <span>tail</span><span>)</span>
  <span>(</span><span>do</span>
    <span>(</span><span>if-then-return</span> <span>(</span><span>isnil</span> <span>l</span><span>)</span>
      <span>tail</span><span>)</span>
    <span>(</span><span>&lt;-</span> <span>(</span><span>car-l</span> <span>cdr-l</span><span>)</span> <span>(</span><span>l</span><span>))</span>
    <span>(</span><span>reverse</span> <span>cdr-l</span> <span>(</span><span>cons</span> <span>car-l</span> <span>tail</span><span>))))</span>
</code></pre></div></div>

<p><code>reverse</code> is a recursive function that reverses a <code>nil</code>-terminated list made of <code>cons</code> cells.
The base case used to end the recursion for <code>reverse</code> is when <code>l</code> is <code>nil</code>,
decided by <code>(isnil l)</code>.</p>

<p>Basically, any recursive function that takes a <code>cons</code>-based list must check if the incoming list is either a <code>cons</code> or a <code>nil</code> to write its base case. However, these data types have very different definitions:</p>

<p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">s</mi></mrow><mtext> </mtext><mi>A</mi><mtext> </mtext><mi>B</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>:</mo><mo>=</mo><mi>λ</mi><mi>f</mi><mi mathvariant="normal">.</mi><mo stretchy="false">(</mo><mi>f</mi><mtext> </mtext><mi>A</mi><mtext> </mtext><mi>B</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi mathvariant="normal">n</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">l</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>:</mo><mo>=</mo><mi>λ</mi><mi>x</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>y</mi><mi mathvariant="normal">.</mi><mi>y</mi></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
{\rm cons} ~ A ~ B &amp;:= \lambda f. (f ~ A ~ B) \\
{\rm nil} &amp;:= \lambda x. \lambda y. y
\end{aligned}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span><span><span><span><span><span></span><span><span><span><span>cons</span></span></span><span> </span><span>A</span><span> </span><span>B</span></span></span><span><span></span><span><span><span><span>nil</span></span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span><span><span><span><span><span></span><span><span></span><span></span><span>:=</span><span></span><span>λ</span><span>f</span><span>.</span><span>(</span><span>f</span><span> </span><span>A</span><span> </span><span>B</span><span>)</span></span></span><span><span></span><span><span></span><span></span><span>:=</span><span></span><span>λ</span><span>x</span><span>.</span><span>λ</span><span>y</span><span>.</span><span>y</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span></span></span></p><p>The function <code>isnil</code> must return <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">t</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">e</mi></mrow><mo>:</mo><mo>=</mo><mi>λ</mi><mi>x</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>y</mi><mi mathvariant="normal">.</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">{\rm true} := \lambda x. \lambda y. x</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span>true</span></span></span><span></span><span>:=</span><span></span></span><span><span></span><span>λ</span><span>x</span><span>.</span><span>λ</span><span>y</span><span>.</span><span>x</span></span></span></span> when its argument is <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">n</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">l</mi></mrow><annotation encoding="application/x-tex">{\rm nil}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span>nil</span></span></span></span></span></span>,
and return <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">n</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">l</mi></mrow><annotation encoding="application/x-tex">{\rm nil}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span>nil</span></span></span></span></span></span> when the argument is any <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">s</mi></mrow><annotation encoding="application/x-tex">{\rm cons}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span>cons</span></span></span></span></span></span> cell.
At first sight, it seems that this is impossible since there is no general way to check the equivalence of two given <em>general</em> lambda terms. Moreover, <code>cons</code> cells are a <em>class</em> of lambda terms that have the form <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mi>f</mi><mi mathvariant="normal">.</mi><mo stretchy="false">(</mo><mi>f</mi><mtext> </mtext><mi>A</mi><mtext> </mtext><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\lambda f. (f ~ A ~ B)</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>λ</span><span>f</span><span>.</span><span>(</span><span>f</span><span> </span><span>A</span><span> </span><span>B</span><span>)</span></span></span></span>.</p>

<p>While checking the equivalence of <em>general</em> lambda terms is impossible due to the halting problem (c.f. <a href="https://weblogs.asp.net/dixin/lambda-calculus-via-c-sharp-24-undecidability-of-equivalence">here</a>),
it is possible for some cases of comparing between lambdas with predefined function signatures.
This is also the case for <code>isnil</code>, where we can derive its concrete definition as follows.</p>

<p>First observe that a <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">s</mi></mrow><annotation encoding="application/x-tex">{\rm cons}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span>cons</span></span></span></span></span></span> cell is a function that takes one callback function and applies to it the two values that it holds. On the other hand, <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">n</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">l</mi></mrow><annotation encoding="application/x-tex">{\rm nil}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span>nil</span></span></span></span></span></span> is a function that takes two functions as its argument.
This difference makes the following sequence of applications to turn out differently for <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">s</mi></mrow><annotation encoding="application/x-tex">{\rm cons}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span>cons</span></span></span></span></span></span> and <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">n</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">l</mi></mrow><annotation encoding="application/x-tex">{\rm nil}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span>nil</span></span></span></span></span></span>:</p>

<p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">s</mi></mrow><mtext> </mtext><mi>A</mi><mtext> </mtext><mi>B</mi><mo stretchy="false">)</mo><mtext> </mtext><mo stretchy="false">(</mo><mi>λ</mi><mi>a</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>b</mi><mi mathvariant="normal">.</mi><mi>x</mi><mo stretchy="false">)</mo><mtext> </mtext><mi>c</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mo stretchy="false">(</mo><mi>λ</mi><mi>f</mi><mi mathvariant="normal">.</mi><mo stretchy="false">(</mo><mi>f</mi><mtext> </mtext><mi>A</mi><mtext> </mtext><mi>B</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mtext> </mtext><mo stretchy="false">(</mo><mi>λ</mi><mi>a</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>b</mi><mi mathvariant="normal">.</mi><mi>x</mi><mo stretchy="false">)</mo><mtext> </mtext><mi>c</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>x</mi><mtext> </mtext><mi>c</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow><mi mathvariant="normal">n</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">l</mi></mrow><mtext> </mtext><mo stretchy="false">(</mo><mi>λ</mi><mi>a</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>b</mi><mi mathvariant="normal">.</mi><mi>x</mi><mo stretchy="false">)</mo><mtext> </mtext><mi>c</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mo stretchy="false">(</mo><mi>λ</mi><mi>x</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>y</mi><mi mathvariant="normal">.</mi><mi>y</mi><mo stretchy="false">)</mo><mtext> </mtext><mo stretchy="false">(</mo><mi>λ</mi><mi>a</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>b</mi><mi mathvariant="normal">.</mi><mi>x</mi><mo stretchy="false">)</mo><mtext> </mtext><mi>c</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>c</mi></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
({\rm cons} ~ A ~ B) ~ (\lambda a. \lambda b. x) ~ c
&amp;= (\lambda f. (f ~ A ~ B)) ~ (\lambda a. \lambda b. x) ~ c \\
&amp;= x ~ c \\
{\rm nil} ~ (\lambda a. \lambda b. x) ~ c
&amp;= (\lambda x. \lambda y. y) ~ (\lambda a. \lambda b. x) ~ c  \\
&amp;= c  \\
\end{aligned}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span><span><span><span><span><span></span><span><span>(</span><span><span><span>cons</span></span></span><span> </span><span>A</span><span> </span><span>B</span><span>)</span><span> </span><span>(</span><span>λa</span><span>.</span><span>λb</span><span>.</span><span>x</span><span>)</span><span> </span><span>c</span></span></span><span><span></span><span></span></span><span><span></span><span><span><span><span>nil</span></span></span><span> </span><span>(</span><span>λa</span><span>.</span><span>λb</span><span>.</span><span>x</span><span>)</span><span> </span><span>c</span></span></span><span><span></span><span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span><span><span><span><span><span></span><span><span></span><span></span><span>=</span><span></span><span>(</span><span>λ</span><span>f</span><span>.</span><span>(</span><span>f</span><span> </span><span>A</span><span> </span><span>B</span><span>))</span><span> </span><span>(</span><span>λa</span><span>.</span><span>λb</span><span>.</span><span>x</span><span>)</span><span> </span><span>c</span></span></span><span><span></span><span><span></span><span></span><span>=</span><span></span><span>x</span><span> </span><span>c</span></span></span><span><span></span><span><span></span><span></span><span>=</span><span></span><span>(</span><span>λ</span><span>x</span><span>.</span><span>λ</span><span>y</span><span>.</span><span>y</span><span>)</span><span> </span><span>(</span><span>λa</span><span>.</span><span>λb</span><span>.</span><span>x</span><span>)</span><span> </span><span>c</span></span></span><span><span></span><span><span></span><span></span><span>=</span><span></span><span>c</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span></span></span></p><p>Here, we applied <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>λ</mi><mi>a</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>b</mi><mi mathvariant="normal">.</mi><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\lambda a. \lambda b. x)</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>(</span><span>λa</span><span>.</span><span>λb</span><span>.</span><span>x</span><span>)</span></span></span></span> and <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>c</span></span></span></span> to <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">s</mi></mrow><mtext> </mtext><mi>A</mi><mtext> </mtext><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">({\rm cons} ~ A ~ B)</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>(</span><span><span><span>cons</span></span></span><span> </span><span>A</span><span> </span><span>B</span><span>)</span></span></span></span> and <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">n</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">l</mi></mrow><annotation encoding="application/x-tex">{\rm nil}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span>nil</span></span></span></span></span></span>,
where <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>x</span></span></span></span> and <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>c</span></span></span></span> are free variables.
Notice that the abstractions in <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>λ</mi><mi>a</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>b</mi><mi mathvariant="normal">.</mi><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\lambda a. \lambda b. x)</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>(</span><span>λa</span><span>.</span><span>λb</span><span>.</span><span>x</span><span>)</span></span></span></span> are used to ignore the values contained in the
<span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">s</mi></mrow><annotation encoding="application/x-tex">{\rm cons}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span>cons</span></span></span></span></span></span> cell.</p>

<p>These sequences of applications can directly be used to define <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">l</mi></mrow><annotation encoding="application/x-tex">{\rm isnil}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span>isnil</span></span></span></span></span></span>.
To implement <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">l</mi></mrow><annotation encoding="application/x-tex">{\rm isnil}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span>isnil</span></span></span></span></span></span>, we want the latter expression to evaluate to <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">t</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">e</mi></mrow><annotation encoding="application/x-tex">{\rm true}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span>true</span></span></span></span></span></span>.
This can be done by setting <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>:</mo><mo>=</mo><mrow><mi mathvariant="normal">t</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">e</mi></mrow></mrow><annotation encoding="application/x-tex">c := {\rm true}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>c</span><span></span><span>:=</span><span></span></span><span><span></span><span><span><span>true</span></span></span></span></span></span>.</p>

<p>It then remains to find an <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>x</span></span></span></span> where <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mtext> </mtext><mi>c</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>x</mi><mtext> </mtext><mrow><mi mathvariant="normal">t</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">e</mi></mrow><mo stretchy="false">)</mo><mo>:</mo><mo>=</mo><mrow><mi mathvariant="normal">n</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">l</mi></mrow></mrow><annotation encoding="application/x-tex">(x ~ c) = (x ~ {\rm true}) := {\rm nil}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>(</span><span>x</span><span> </span><span>c</span><span>)</span><span></span><span>=</span><span></span></span><span><span></span><span>(</span><span>x</span><span> </span><span><span><span>true</span></span></span><span>)</span><span></span><span>:=</span><span></span></span><span><span></span><span><span><span>nil</span></span></span></span></span></span>.
From here we immediately get <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>:</mo><mo>=</mo><mi>λ</mi><mi>w</mi><mi mathvariant="normal">.</mi><mrow><mi mathvariant="normal">n</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">l</mi></mrow></mrow><annotation encoding="application/x-tex">x := \lambda w. {\rm nil}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>x</span><span></span><span>:=</span><span></span></span><span><span></span><span>λ</span><span>w</span><span>.</span><span><span><span>nil</span></span></span></span></span></span>.</p>

<p>Therefore, <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">l</mi></mrow><annotation encoding="application/x-tex">{\rm isnil}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span>isnil</span></span></span></span></span></span> can be written by abstracting this process:</p>

<p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">l</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>λ</mi><mi>z</mi><mi mathvariant="normal">.</mi><mo stretchy="false">(</mo><mi>z</mi><mtext> </mtext><mo stretchy="false">(</mo><mi>λ</mi><mi>a</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>b</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>w</mi><mi mathvariant="normal">.</mi><mrow><mi mathvariant="normal">n</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">l</mi></mrow><mo stretchy="false">)</mo><mtext> </mtext><mrow><mi mathvariant="normal">t</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">e</mi></mrow><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>λ</mi><mi>z</mi><mi mathvariant="normal">.</mi><mo stretchy="false">(</mo><mi>z</mi><mtext> </mtext><mo stretchy="false">(</mo><mi>λ</mi><mi>a</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>b</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>w</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>x</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>y</mi><mi mathvariant="normal">.</mi><mi>y</mi><mo stretchy="false">)</mo><mtext> </mtext><mo stretchy="false">(</mo><mi>λ</mi><mi>x</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>y</mi><mi mathvariant="normal">.</mi><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
{\rm isnil}
&amp;= \lambda z. (z ~ (\lambda a. \lambda b. \lambda w. {\rm nil}) ~ {\rm true}) \\
&amp;= \lambda z. (z ~ (\lambda a. \lambda b. \lambda w. \lambda x. \lambda y. y) ~ (\lambda x. \lambda y. x)) \\
\end{aligned}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span><span><span><span><span><span></span><span><span><span><span>isnil</span></span></span></span></span><span><span></span><span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span><span><span><span><span><span></span><span><span></span><span></span><span>=</span><span></span><span>λ</span><span>z</span><span>.</span><span>(</span><span>z</span><span> </span><span>(</span><span>λa</span><span>.</span><span>λb</span><span>.</span><span>λ</span><span>w</span><span>.</span><span><span><span>nil</span></span></span><span>)</span><span> </span><span><span><span>true</span></span></span><span>)</span></span></span><span><span></span><span><span></span><span></span><span>=</span><span></span><span>λ</span><span>z</span><span>.</span><span>(</span><span>z</span><span> </span><span>(</span><span>λa</span><span>.</span><span>λb</span><span>.</span><span>λ</span><span>w</span><span>.</span><span>λ</span><span>x</span><span>.</span><span>λ</span><span>y</span><span>.</span><span>y</span><span>)</span><span> </span><span>(</span><span>λ</span><span>x</span><span>.</span><span>λ</span><span>y</span><span>.</span><span>x</span><span>))</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span></span></span></p><p>which can be used as</p>

<p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">l</mi></mrow><mtext> </mtext><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">s</mi></mrow><mtext> </mtext><mi>A</mi><mtext> </mtext><mi>B</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mrow><mi mathvariant="normal">n</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">l</mi></mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">l</mi></mrow><mtext> </mtext><mrow><mi mathvariant="normal">n</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">l</mi></mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mrow><mi mathvariant="normal">t</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">e</mi></mrow></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
{\rm isnil} ~ ({\rm cons} ~ A ~ B) &amp;= {\rm nil} \\
{\rm isnil} ~ {\rm nil} &amp;= {\rm true}
\end{aligned}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span><span><span><span><span><span></span><span><span><span><span>isnil</span></span></span><span> </span><span>(</span><span><span><span>cons</span></span></span><span> </span><span>A</span><span> </span><span>B</span><span>)</span></span></span><span><span></span><span><span><span><span>isnil</span></span></span><span> </span><span><span><span>nil</span></span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span><span><span><span><span><span></span><span><span></span><span></span><span>=</span><span></span><span><span><span>nil</span></span></span></span></span><span><span></span><span><span></span><span></span><span>=</span><span></span><span><span><span>true</span></span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span></span></span></p><p>The pattern <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mi>a</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>b</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>w</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>x</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>y</mi><mi mathvariant="normal">.</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">\lambda a. \lambda b. \lambda w. \lambda x. \lambda y. y</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>λa</span><span>.</span><span>λb</span><span>.</span><span>λ</span><span>w</span><span>.</span><span>λ</span><span>x</span><span>.</span><span>λ</span><span>y</span><span>.</span><span>y</span></span></span></span> is noticable in many places in <a href="https://woodrush.github.io/lambdalisp.pdf">lambdalisp.pdf</a>,
since <code>isnil</code> is used a lot of times in LambdaLisp.</p>

<h3 id="lambdacrafts-do-macro">LambdaCraft’s ‘do’ Macro</h3>
<p>The heavy use of CPS in LambdaLisp is supported by LambdaCraft’s <code>do</code> macro.
Writing raw code in CPS causes a heavily nested code, since CPS is based on callbacks.
The <code>do</code> macro makes such nested code to be written as flat code,
in a syntax close to Haskell’s <code>do</code> notation for monads.</p>

<p>Here is the <code>do</code> notation in Haskell:</p>

<div><div><pre><code><span>do</span>
  <span>(</span><span>y</span><span>,</span> <span>z</span><span>)</span> <span>&lt;-</span> <span>f</span> <span>x</span>
  <span>w</span> <span>&lt;-</span> <span>g</span> <span>y</span> <span>z</span>
  <span>return</span> <span>w</span>
</code></pre></div></div>

<p>A similar code can be written in LambdaCraft as:</p>

<div><div><pre><code><span>(</span><span>do</span>
  <span>(</span><span>&lt;-</span> <span>(</span><span>y</span> <span>z</span><span>)</span> <span>(</span><span>f</span> <span>x</span><span>))</span>
  <span>(</span><span>&lt;-</span> <span>(</span><span>w</span><span>)</span> <span>(</span><span>g</span> <span>y</span> <span>z</span><span>))</span>
  <span>w</span><span>)</span>
</code></pre></div></div>

<p>which is macro-expanded to:</p>

<div><div><pre><code><span>(</span><span>f</span> <span>x</span>
  <span>(</span><span>lambda</span> <span>(</span><span>y</span> <span>z</span><span>)</span>
    <span>(</span><span>g</span> <span>y</span> <span>z</span>
      <span>(</span><span>lambda</span> <span>(</span><span>w</span><span>)</span>
        <span>w</span><span>))))</span>
</code></pre></div></div>

<p>where <code>f, g</code> is defined in CPS:</p>

<div><div><pre><code><span>(</span><span>defun-lazy</span> <span>f</span> <span>(</span><span>x</span> <span>cont</span><span>)</span> <span>...</span><span>)</span>
<span>(</span><span>defun-lazy</span> <span>g</span> <span>(</span><span>y</span> <span>z</span> <span>cont</span><span>)</span> <span>...</span><span>)</span>
</code></pre></div></div>

<p>Here, the <code>cont</code> represents the callback function, which is directly written as the inner <code>lambda</code>s.</p>

<h3 id="print-debugging">Print Debugging</h3>
<p>The return type of <code>eval</code> is <code>string</code>, and not <code>expr</code>.
This is because <code>expr</code> is “returned” with CPS, by applying it to the provided callback:</p>

<div><div><pre><code><span>;; LambdaCraft</span>
<span>(</span><span>eval</span> <span>expr</span> <span>state</span>
  <span>(</span><span>lambda</span> <span>(</span><span>eval-result</span> <span>state</span><span>)</span>
    <span>[do</span> <span>something</span> <span>with</span> <span>eval-result</span> <span>and</span> <span>state]</span><span>))</span>
</code></pre></div></div>

<p>This is written using <code>do</code> as:</p>

<div><div><pre><code><span>(</span><span>do</span>
  <span>(</span><span>&lt;-</span> <span>(</span><span>eval-result</span> <span>state</span><span>)</span> <span>(</span><span>eval</span> <span>expr</span> <span>state</span><span>)</span>
  <span>[do</span> <span>something</span> <span>with</span> <span>eval-result</span> <span>and</span> <span>state]</span><span>))</span>
</code></pre></div></div>

<p>The nice part about the <code>do</code> macro and having <code>eval</code> return strings is that it makes print debugging very intuitive.
Since LambdaLisp is written in CPS, an arbitrary point in the <code>eval</code> function eventually becomes the head of the current evaluation.
Therefore, at any point in the program, you can write</p>

<div><div><pre><code><span>;; LambdaCraft</span>
<span>(</span><span>eval</span> <span>expr</span> <span>state</span>
  <span>(</span><span>lambda</span> <span>(</span><span>eval-result</span> <span>state</span><span>)</span>
    <span>(</span><span>cons</span> <span>&#34;a&#34;</span> <span>(</span><span>cons</span> <span>&#34;b&#34;</span> <span>(</span><span>cons</span> <span>&#34;c&#34;</span> <span>[do</span> <span>something</span> <span>with</span> <span>eval-result</span> <span>and</span> <span>state]</span><span>)))))</span>
</code></pre></div></div>

<p>which will make the entire expression eventually evaluate to</p>

<div><div><pre><code><span>;; LambdaCraft</span>
<span>;; The outermost expression</span>
<span>(</span><span>cons</span> <span>&#34;a&#34;</span> <span>(</span><span>cons</span> <span>&#34;b&#34;</span> <span>(</span><span>cons</span> <span>&#34;c&#34;</span> <span>...</span><span>)))</span>
</code></pre></div></div>

<p>which will print “abc” in the console.</p>

<p>The previous code can be written in imperative style using <code>do</code> as</p>

<div><div><pre><code><span>;; LambdaCraft</span>
<span>(</span><span>do</span>
  <span>(</span><span>&lt;-</span> <span>(</span><span>eval-result</span> <span>state</span><span>)</span> <span>(</span><span>expr</span> <span>state</span><span>))</span>
  <span>(</span><span>cons</span> <span>&#34;a&#34;</span><span>)</span>
  <span>(</span><span>cons</span> <span>&#34;b&#34;</span><span>)</span>
  <span>(</span><span>cons</span> <span>&#34;c&#34;</span><span>)</span>
  <span>[do</span> <span>something</span> <span>with</span> <span>eval-result</span> <span>and</span> <span>state]</span><span>)</span>
</code></pre></div></div>

<p>which is virtually identical to writing <code>(print &#34;a&#34;)</code> in an imperative language.
Note that the default behavior of <code>do</code> is to nest the successive argument at the end of the list, starting from the last argument, and <code><span>&lt;-</span></code> is a specially handled case by <code>do</code>.</p>

<p><code>(cons &#34;a&#34;)</code> can be replaced with a string printing function that accepts a continuation, such as:</p>

<div><div><pre><code><span>;; LambdaCraft</span>
<span>(</span><span>defun-lazy</span> <span>show-message</span> <span>(</span><span>message</span> <span>state</span> <span>cont</span><span>)</span>
  <span>(</span><span>do</span>
    <span>(</span><span>print-string</span> <span>message</span><span>)</span>
    <span>(</span><span>cons</span> <span>&#34;\\n&#34;</span><span>)</span>
    <span>(</span><span>cont</span> <span>state</span><span>)))</span>
</code></pre></div></div>

<p>which will print <code>message</code>, print a newline, and proceed with <code>(cont state)</code>.</p>

<p>This design was very helpful during debugging, since it let you track the execution flow using print debugging.
This design and technique can be used in other general lambda-calculus based programs as well.</p>

<h3 id="type-checking-with-macro-call-signatures">Type Checking with Macro Call Signatures</h3>
<p>Another large-scale programming technique is using macro signatures as a type-checking functionality.</p>

<p>Since all lambdas defined by <code>def-lazy</code>, <code>defun-lazy</code> or <code>defrec-lazy</code> are curried in LambdaCraft,
there is no simple way to tell how many arguments a lambda that is being called takes.
This is different for LambdaCraft <em>macros</em> defined by <code>defmacro-lazy</code>,
since LambdaCraft macros are implemented as <em>Common Lisp</em> functions that run on the Common Lisp environment to expand the macro at compile time.
Therefore, when a LambdaCraft macro is called with excessive or insufficient number of arguments,
it causes a Common Lisp error at compile time.
This works as a strong macro signature type-checker which significantly helps the debugging process of LambdaCraft,
letting you know when a LambdaCraft macro is called with insufficient arguments.
This effectively works as a simple type checker for macro call signatures.
The Common Lisp call stack even tells you which line got the macro call wrong which helps debugging as well.
It is therefore convenient to use as much macros as possible when writing programs in LambdaCraft.</p>

<p>Writing in terms of macros help reduce the code size as well,
since using macros can be seen as running compile-time beta reductions beforehand of the runtime.
For example, while <code>cons</code> can be written as a function <code>(defun-lazy cons (x y) (lambda (f) (f x y)))</code>,
it can also be written as a macro <code>(defmacro-lazy cons (x y) `(lambda (f) ,x ,y))</code>,
which is the beta-reduced form of the function-based definition.
Either code will evaluate the same results by writing <code>(cons p q)</code>,
except the function-based one requires an extra beta-reduction step at runtime, affecting the performance.</p>

<h2 id="appendix">Appendix</h2>
<h3 id="javascript-examples-of-continuation-passing-style-code">JavaScript Examples of Continuation-Passing Style Code</h3>
<p>CPS causes the largest impact when extracting the values of a <code>cons</code> cell.
This is illustrated in the JavaScript code below that runs on a browser’s JavaScript console.</p>

<p>In direct style, destructing a value of a <code>cons</code> tuple is written as:</p>

<div><div><pre><code><span>// Runs on the browser&#39;s JavaScript console</span>
<span>function</span> <span>car</span> <span>(</span><span>x</span><span>)</span> <span>{</span>
    <span>return</span> <span>x</span><span>(</span><span>function</span> <span>(</span><span>a</span><span>,</span> <span>b</span><span>)</span> <span>{</span> <span>return</span> <span>a</span><span>;</span> <span>});</span>
<span>}</span>
<span>function</span> <span>cdr</span> <span>(</span><span>x</span><span>)</span> <span>{</span>
    <span>return</span> <span>x</span><span>(</span><span>function</span> <span>(</span><span>a</span><span>,</span> <span>b</span><span>)</span> <span>{</span> <span>return</span> <span>b</span><span>;</span> <span>});</span>
<span>}</span>

<span>function</span> <span>cons</span> <span>(</span><span>a</span><span>,</span> <span>b</span><span>)</span> <span>{</span>
    <span>return</span> <span>function</span> <span>(</span><span>f</span><span>)</span> <span>{</span>
        <span>return</span> <span>f</span><span>(</span><span>a</span><span>,</span><span>b</span><span>);</span>
    <span>};</span>
<span>}</span>
<span>function</span> <span>t</span> <span>(</span><span>a</span><span>,</span> <span>b</span><span>)</span> <span>{</span>
    <span>return</span> <span>a</span><span>;</span>
<span>}</span>
<span>function</span> <span>nil</span> <span>(</span><span>a</span><span>,</span> <span>b</span><span>)</span> <span>{</span>
    <span>return</span> <span>b</span><span>;</span>
<span>}</span>

<span>(</span><span>function</span><span>(</span><span>x</span><span>)</span> <span>{</span>
    <span>return</span> <span>(</span><span>function</span> <span>(</span><span>y</span><span>)</span> <span>{</span>
        <span>return</span> <span>(</span><span>function</span> <span>(</span><span>z</span><span>)</span> <span>{</span>
            <span>return</span> <span>z</span><span>(</span><span>z</span><span>,</span> <span>z</span><span>);</span>
        <span>})(</span><span>car</span><span>(</span><span>y</span><span>));</span>
    <span>})(</span><span>cdr</span><span>(</span><span>x</span><span>));</span>
<span>})(</span><span>cons</span><span>(</span><span>t</span><span>,</span> <span>cons</span><span>(</span><span>nil</span><span>,</span> <span>t</span><span>)))</span>
</code></pre></div></div>

<p>The last expression in this code first binds <code>(cons t (cons nil t))</code> to <code>x</code>, and calculates <code>(car (cdr x))</code>.
Running this on the browser’s console should return the function <code>nil</code>.</p>

<p>The <code>car</code> and <code>cdr</code> correspond to the following lambda terms that accept a data and return the data in the desired position:</p>

<p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">r</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>λ</mi><mi>x</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>y</mi><mi mathvariant="normal">.</mi><mi>x</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">r</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>λ</mi><mi>x</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>y</mi><mi mathvariant="normal">.</mi><mi>y</mi></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
{\rm car} &amp;= \lambda x. \lambda y. x \\
{\rm cdr} &amp;= \lambda x. \lambda y. y \\
\end{aligned}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span><span><span><span><span><span></span><span><span><span><span>car</span></span></span></span></span><span><span></span><span><span><span><span>cdr</span></span></span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span><span><span><span><span><span></span><span><span></span><span></span><span>=</span><span></span><span>λ</span><span>x</span><span>.</span><span>λ</span><span>y</span><span>.</span><span>x</span></span></span><span><span></span><span><span></span><span></span><span>=</span><span></span><span>λ</span><span>x</span><span>.</span><span>λ</span><span>y</span><span>.</span><span>y</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span></span></span></p><p>On the other hand, in continuation-passing style, the same code is written as:</p>

<div><div><pre><code><span>// Runs on the browser&#39;s JavaScript console</span>
<span>function</span> <span>cons</span> <span>(</span><span>a</span><span>,</span> <span>b</span><span>)</span> <span>{</span>
    <span>return</span> <span>function</span> <span>(</span><span>f</span><span>)</span> <span>{</span>
        <span>return</span> <span>f</span><span>(</span><span>a</span><span>,</span><span>b</span><span>);</span>
    <span>};</span>
<span>}</span>
<span>function</span> <span>t</span> <span>(</span><span>a</span><span>,</span> <span>b</span><span>)</span> <span>{</span>
    <span>return</span> <span>a</span><span>;</span>
<span>}</span>
<span>function</span> <span>nil</span> <span>(</span><span>a</span><span>,</span> <span>b</span><span>)</span> <span>{</span>
    <span>return</span> <span>b</span><span>;</span>
<span>}</span>

<span>cons</span><span>(</span><span>t</span><span>,</span> <span>cons</span><span>(</span><span>nil</span><span>,</span> <span>t</span><span>))(</span>            <span>// cons returns a function that accepts a callback function. We pass a callback to it</span>
    <span>function</span> <span>(</span><span>tmp1</span><span>,</span> <span>y</span><span>){</span>           <span>// This function works as cdr; It takes the second value (and discards the first)</span>
        <span>return</span> <span>y</span><span>(</span>                 <span>// y == cons(nil, t) now. Inside, we write what we want to do with the y we receive via the callback. Here we pass another callback to the return value of the inner cons.</span>
            <span>function</span> <span>(</span><span>z</span><span>,</span> <span>tmp2</span><span>)</span> <span>{</span>  <span>// This function works as car; It takes the first value (and discards the second)</span>
                <span>return</span> <span>z</span><span>(</span><span>z</span><span>,</span> <span>z</span><span>);</span>   <span>// z == nil now. nil selects the second value among its arguments, which here evaluates to nil.</span>
            <span>}</span>
        <span>);</span>
    <span>}</span>
<span>)</span>
</code></pre></div></div>

<p>Here, values are extracted without using <code>car</code> or <code>cdr</code> at all.
It instead uses the fact that a <code>cons</code> cell is actually a <em>function</em> that accepts a callback function
that applies both of its contents to the provided callback.</p>

<p>This significantly improves performance when reading the <code>stdin</code>, which is a list made from <code>cons</code> cells:</p>

<div><div><pre><code><span>;; LambdaCraft</span>
<span>(</span><span>stdin</span>
  <span>(</span><span>lambda</span> <span>(</span><span>c</span> <span>cdr-stdin</span><span>)</span>
    <span>(</span><span>if</span> <span>(</span><span>=-bit</span> <span>c</span> <span>&#34;(&#34;</span><span>)</span>
      <span>...</span><span>)))</span>
</code></pre></div></div>

<h3 id="the-binary-lambda-calculus-notation">The Binary Lambda Calculus Notation</h3>
<p>The interpreters Blc, tromp, and uni runs programs writen in <a href="https://tromp.github.io/cl/cl.html">binary lambda calculus</a> (BLC - also see <a href="https://tromp.github.io/cl/Binary_lambda_calculus.html">here</a>).
The difference between binary lambda calculus and ordinary lambda calculus is in the notation, i.e. how lambda terms are written, and everything else including the rules of beta reduction are the same. BLC’s notation is based on <a href="https://en.wikipedia.org/wiki/De_Bruijn_index">De Bruijn notation</a>, where variable names such as <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x, y</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>x</span><span>,</span><span></span><span>y</span></span></span></span> and <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi></mrow><annotation encoding="application/x-tex">z</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>z</span></span></span></span> are eliminated, and are instead replaced by an integer describing the relative nesting depth distances viewed from the variable’s surrounding scope.</p>

<p>The De Bruijn notation works as follows. Consider for example the term <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mi>x</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>y</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>z</mi><mi mathvariant="normal">.</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">\lambda x. \lambda y. \lambda z. y</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>λ</span><span>x</span><span>.</span><span>λ</span><span>y</span><span>.</span><span>λ</span><span>z</span><span>.</span><span>y</span></span></span></span>. Here, from the eyes of the term <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>y</span></span></span></span>, the originating lambda of the variable <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>y</span></span></span></span> is reached by hopping 1 abstraction <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mi>z</mi></mrow><annotation encoding="application/x-tex">\lambda z</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>λ</span><span>z</span></span></span></span>, so the <em>De Bruijn index</em> for the term <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>y</span></span></span></span> is 1. We can therefore rewrite as</p>

<p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>λ</mi><mi>x</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>y</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>z</mi><mi mathvariant="normal">.</mi><mi>y</mi><mo>=</mo><mi>λ</mi><mi>x</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>y</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>z</mi><mi mathvariant="normal">.</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">\lambda x. \lambda y. \lambda z. y = \lambda x. \lambda y. \lambda z. 1</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>λ</span><span>x</span><span>.</span><span>λ</span><span>y</span><span>.</span><span>λ</span><span>z</span><span>.</span><span>y</span><span></span><span>=</span><span></span></span><span><span></span><span>λ</span><span>x</span><span>.</span><span>λ</span><span>y</span><span>.</span><span>λ</span><span>z</span><span>.1</span></span></span></span></span></p><p>and still recover its meaning. Similarly, The index for <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>x</span></span></span></span> in <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mi>x</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>y</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>z</mi><mi mathvariant="normal">.</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">\lambda x. \lambda y. \lambda z. x</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>λ</span><span>x</span><span>.</span><span>λ</span><span>y</span><span>.</span><span>λ</span><span>z</span><span>.</span><span>x</span></span></span></span> would be 2, and for <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi></mrow><annotation encoding="application/x-tex">z</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>z</span></span></span></span> in <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mi>x</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>y</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>z</mi><mi mathvariant="normal">.</mi><mi>z</mi></mrow><annotation encoding="application/x-tex">\lambda x. \lambda y. \lambda z. z</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>λ</span><span>x</span><span>.</span><span>λ</span><span>y</span><span>.</span><span>λ</span><span>z</span><span>.</span><span>z</span></span></span></span> would be 0 since no hops are required. This works for a more complicated setting, for example in <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mi>x</mi><mi mathvariant="normal">.</mi><mo stretchy="false">(</mo><mi>x</mi><mi>λ</mi><mi>y</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>z</mi><mi mathvariant="normal">.</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>x</mi><mi>z</mi><mo stretchy="false">)</mo><mi>y</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\lambda x. (x \lambda y. \lambda z.((x z) y))</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>λ</span><span>x</span><span>.</span><span>(</span><span>x</span><span>λ</span><span>y</span><span>.</span><span>λ</span><span>z</span><span>.</span><span>((</span><span>x</span><span>z</span><span>)</span><span>y</span><span>))</span></span></span></span> the index for <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>y</span></span></span></span> is 1.
<span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>x</span></span></span></span> occurs twice in this term, and each are encoded differently in this case. The innermost <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>x</span></span></span></span> has index 2 since 2 hops is required past <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mi>z</mi></mrow><annotation encoding="application/x-tex">\lambda z</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>λ</span><span>z</span></span></span></span> and <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">\lambda y</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>λ</span><span>y</span></span></span></span>, but the outer <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>x</span></span></span></span>’s index is 0 since no hops are required to reach <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">\lambda x</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>λ</span><span>x</span></span></span></span> in the eyes of the outermost <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>x</span></span></span></span>. We can then write</p>

<p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>λ</mi><mi>x</mi><mi mathvariant="normal">.</mi><mo stretchy="false">(</mo><mi>x</mi><mi>λ</mi><mi>y</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>z</mi><mi mathvariant="normal">.</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>x</mi><mi>z</mi><mo stretchy="false">)</mo><mi>y</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>λ</mi><mi>x</mi><mi mathvariant="normal">.</mi><mo stretchy="false">(</mo><mn>0</mn><mi>λ</mi><mi>y</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>z</mi><mi mathvariant="normal">.</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mn>20</mn><mo stretchy="false">)</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\lambda x. (x \lambda y. \lambda z.((x z) y)) = \lambda x. (0 \lambda y. \lambda z.((2 0) 1))</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>λ</span><span>x</span><span>.</span><span>(</span><span>x</span><span>λ</span><span>y</span><span>.</span><span>λ</span><span>z</span><span>.</span><span>((</span><span>x</span><span>z</span><span>)</span><span>y</span><span>))</span><span></span><span>=</span><span></span></span><span><span></span><span>λ</span><span>x</span><span>.</span><span>(</span><span>0</span><span>λ</span><span>y</span><span>.</span><span>λ</span><span>z</span><span>.</span><span>((</span><span>20</span><span>)</span><span>1</span><span>))</span></span></span></span></span></p><p>and we can still deduce which variable each integer corresponds to.</p>

<p>We then notice that when written in De Bruijn indices, the variable names in the lambda declaration becomes entirely redundant. The expression can thus be rewritten as</p>

<p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>λ</mi><mi>x</mi><mi mathvariant="normal">.</mi><mo stretchy="false">(</mo><mi>x</mi><mi>λ</mi><mi>y</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>z</mi><mi mathvariant="normal">.</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>x</mi><mi>z</mi><mo stretchy="false">)</mo><mi>y</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>λ</mi><mi>x</mi><mi mathvariant="normal">.</mi><mo stretchy="false">(</mo><mn>0</mn><mi>λ</mi><mi>y</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>z</mi><mi mathvariant="normal">.</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mn>20</mn><mo stretchy="false">)</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>λ</mi><mo stretchy="false">(</mo><mn>0</mn><mi>λ</mi><mi>λ</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mn>20</mn><mo stretchy="false">)</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
\lambda x. (x \lambda y. \lambda z.((x z) y))
&amp;= \lambda x. (0 \lambda y. \lambda z.((2 0) 1)) \\
&amp;= \lambda (0 \lambda \lambda ((2 0) 1))
\end{aligned}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span><span><span><span><span><span></span><span><span>λ</span><span>x</span><span>.</span><span>(</span><span>x</span><span>λ</span><span>y</span><span>.</span><span>λ</span><span>z</span><span>.</span><span>((</span><span>x</span><span>z</span><span>)</span><span>y</span><span>))</span></span></span><span><span></span><span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span><span><span><span><span><span></span><span><span></span><span></span><span>=</span><span></span><span>λ</span><span>x</span><span>.</span><span>(</span><span>0</span><span>λ</span><span>y</span><span>.</span><span>λ</span><span>z</span><span>.</span><span>((</span><span>20</span><span>)</span><span>1</span><span>))</span></span></span><span><span></span><span><span></span><span></span><span>=</span><span></span><span>λ</span><span>(</span><span>0</span><span>λλ</span><span>((</span><span>20</span><span>)</span><span>1</span><span>))</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span></span></span></p><p>and it would still hold the same meaning.</p>

<p>We can simplify the notation more by writing function application <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>A</mi><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(A B)</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>(</span><span>A</span><span>B</span><span>)</span></span></span></span> as <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">y</mi></mrow><mtext> </mtext><mi>A</mi><mtext> </mtext><mi>B</mi></mrow><annotation encoding="application/x-tex">{\rm apply}~A~B</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span>apply</span></span></span><span> </span><span>A</span><span> </span><span>B</span></span></span></span>.
Doing this we get:</p>

<p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>λ</mi><mi>x</mi><mi mathvariant="normal">.</mi><mo stretchy="false">(</mo><mi>x</mi><mi>λ</mi><mi>y</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>z</mi><mi mathvariant="normal">.</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>x</mi><mi>z</mi><mo stretchy="false">)</mo><mi>y</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>λ</mi><mo stretchy="false">(</mo><mn>0</mn><mi>λ</mi><mi>λ</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mn>20</mn><mo stretchy="false">)</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>λ</mi><mtext> </mtext><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">y</mi></mrow><mtext> </mtext><mn>0</mn><mtext> </mtext><mi>λ</mi><mi>λ</mi><mtext> </mtext><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">y</mi></mrow><mtext> </mtext><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">y</mi></mrow><mtext> </mtext><mn>2</mn><mtext> </mtext><mn>0</mn><mtext> </mtext><mn>1</mn></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
\lambda x. (x \lambda y. \lambda z.((x z) y))
&amp;= \lambda (0 \lambda \lambda ((2 0) 1)) \\
&amp;= \lambda ~ {\rm apply} ~ 0 ~ \lambda \lambda ~{\rm apply} ~ {\rm apply} ~ 2 ~ 0 ~ 1
\end{aligned}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span><span><span><span><span><span></span><span><span>λ</span><span>x</span><span>.</span><span>(</span><span>x</span><span>λ</span><span>y</span><span>.</span><span>λ</span><span>z</span><span>.</span><span>((</span><span>x</span><span>z</span><span>)</span><span>y</span><span>))</span></span></span><span><span></span><span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span><span><span><span><span><span></span><span><span></span><span></span><span>=</span><span></span><span>λ</span><span>(</span><span>0</span><span>λλ</span><span>((</span><span>20</span><span>)</span><span>1</span><span>))</span></span></span><span><span></span><span><span></span><span></span><span>=</span><span></span><span>λ</span><span> </span><span><span><span>apply</span></span></span><span> </span><span>0</span><span> </span><span>λλ</span><span> </span><span><span><span>apply</span></span></span><span> </span><span><span><span>apply</span></span></span><span> </span><span>2</span><span> </span><span>0</span><span> </span><span>1</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span></span></span></p><p>By assuming that <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">y</mi></mrow><annotation encoding="application/x-tex">{\rm apply}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span>apply</span></span></span></span></span></span> always takes exactly 2 parameters,
we can eliminate the need for writing parentheses to express <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">y</mi></mrow><annotation encoding="application/x-tex">{\rm apply}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span>apply</span></span></span></span></span></span>.</p>

<p>Binary lambda calculus then encodes this sequence as follows:</p>

<p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>λ</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mn>00</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">y</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mn>01</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>i</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><msup><mn>1</mn><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msup><mn>0</mn></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
\lambda &amp;= 00 \\
{\rm apply} &amp;= 01 \\
i &amp;= 1^{i+1}0 \\
\end{aligned}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span><span><span><span><span><span></span><span><span>λ</span></span></span><span><span></span><span><span><span><span>apply</span></span></span></span></span><span><span></span><span><span>i</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span><span><span><span><span><span></span><span><span></span><span></span><span>=</span><span></span><span>00</span></span></span><span><span></span><span><span></span><span></span><span>=</span><span></span><span>01</span></span></span><span><span></span><span><span></span><span></span><span>=</span><span></span><span><span>1</span><span><span><span><span><span><span></span><span><span><span>i</span><span>+</span><span>1</span></span></span></span></span></span></span></span></span><span>0</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span></span></span></p><p>We thus have</p>

<p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>λ</mi><mi>x</mi><mi mathvariant="normal">.</mi><mo stretchy="false">(</mo><mi>x</mi><mi>λ</mi><mi>y</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>z</mi><mi mathvariant="normal">.</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>x</mi><mi>z</mi><mo stretchy="false">)</mo><mi>y</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>λ</mi><mtext> </mtext><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">y</mi></mrow><mtext> </mtext><mn>0</mn><mtext> </mtext><mi>λ</mi><mi>λ</mi><mtext> </mtext><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">y</mi></mrow><mtext> </mtext><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">y</mi></mrow><mtext> </mtext><mn>2</mn><mtext> </mtext><mn>0</mn><mtext> </mtext><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mn>00</mn><mtext> </mtext><mn>01</mn><mtext> </mtext><mn>10</mn><mtext> </mtext><mn>00</mn><mtext> </mtext><mn>00</mn><mtext> </mtext><mn>01</mn><mtext> </mtext><mn>01</mn><mtext> </mtext><mn>1110</mn><mtext> </mtext><mn>10</mn><mtext> </mtext><mn>110</mn></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
\lambda x. (x \lambda y. \lambda z.((x z) y))
&amp;= \lambda ~ {\rm apply} ~ 0 ~ \lambda \lambda ~{\rm apply} ~ {\rm apply} ~ 2 ~ 0 ~ 1 \\
&amp;= 00~01~10~00~00~01~01~1110~10~110
\end{aligned}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span><span><span><span><span><span></span><span><span>λ</span><span>x</span><span>.</span><span>(</span><span>x</span><span>λ</span><span>y</span><span>.</span><span>λ</span><span>z</span><span>.</span><span>((</span><span>x</span><span>z</span><span>)</span><span>y</span><span>))</span></span></span><span><span></span><span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span><span><span><span><span><span></span><span><span></span><span></span><span>=</span><span></span><span>λ</span><span> </span><span><span><span>apply</span></span></span><span> </span><span>0</span><span> </span><span>λλ</span><span> </span><span><span><span>apply</span></span></span><span> </span><span><span><span>apply</span></span></span><span> </span><span>2</span><span> </span><span>0</span><span> </span><span>1</span></span></span><span><span></span><span><span></span><span></span><span>=</span><span></span><span>00</span><span> </span><span>01</span><span> </span><span>10</span><span> </span><span>00</span><span> </span><span>00</span><span> </span><span>01</span><span> </span><span>01</span><span> </span><span>1110</span><span> </span><span>10</span><span> </span><span>110</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span></span></span></p><p>which completes the definition of the binary lambda calculus notation.</p>

<p>The Blc interpreter (and the Universal Lambda interpreter) accepts this bitstream and parses it to a lambda term, which then applies beta reduction to execute the program.</p>

<p>Some more examples are</p>

<p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left right" columnspacing="0em 1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>λ</mi><mi>x</mi><mi mathvariant="normal">.</mi><mi>x</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>λ</mi><mn>0</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo>=</mo><mn>00</mn><mtext> </mtext><mn>10</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>λ</mi><mi>x</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mi>y</mi><mi mathvariant="normal">.</mi><mi>x</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>λ</mi><mi>λ</mi><mn>1</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo>=</mo><mn>00</mn><mtext> </mtext><mn>00</mn><mtext> </mtext><mn>110</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo stretchy="false">(</mo><mi>λ</mi><mi>x</mi><mi mathvariant="normal">.</mi><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>λ</mi><mi>x</mi><mi mathvariant="normal">.</mi><mi>x</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">y</mi></mrow><mtext> </mtext><mi>λ</mi><mn>0</mn><mtext> </mtext><mi>λ</mi><mn>0</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo>=</mo><mn>01</mn><mtext> </mtext><mn>00</mn><mtext> </mtext><mn>10</mn><mtext> </mtext><mn>00</mn><mtext> </mtext><mn>10</mn></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
\lambda x. x
&amp;= \lambda 0
&amp;= 00~10
\\
\lambda x. \lambda y. x
&amp;= \lambda \lambda 1
&amp;= 00~00~110
\\
(\lambda x. x) (\lambda x. x)
&amp;= {\rm apply}~ \lambda 0 ~ \lambda 0
&amp;= 01~00~10~00~10
\end{aligned}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span><span><span><span><span><span></span><span><span>λ</span><span>x</span><span>.</span><span>x</span></span></span><span><span></span><span><span>λ</span><span>x</span><span>.</span><span>λ</span><span>y</span><span>.</span><span>x</span></span></span><span><span></span><span><span>(</span><span>λ</span><span>x</span><span>.</span><span>x</span><span>)</span><span>(</span><span>λ</span><span>x</span><span>.</span><span>x</span><span>)</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span><span><span><span><span><span></span><span><span></span><span></span><span>=</span><span></span><span>λ</span><span>0</span></span></span><span><span></span><span><span></span><span></span><span>=</span><span></span><span>λλ</span><span>1</span></span></span><span><span></span><span><span></span><span></span><span>=</span><span></span><span><span><span>apply</span></span></span><span> </span><span>λ</span><span>0</span><span> </span><span>λ</span><span>0</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span><span></span><span><span><span><span><span><span></span><span><span>=</span><span></span><span>00</span><span> </span><span>10</span></span></span><span><span></span><span><span>=</span><span></span><span>00</span><span> </span><span>00</span><span> </span><span>110</span></span></span><span><span></span><span><span>=</span><span></span><span>01</span><span> </span><span>00</span><span> </span><span>10</span><span> </span><span>00</span><span> </span><span>10</span></span></span></span><span>​</span></span><span><span><span></span></span></span></span></span></span></span></span></span></span></span></p><p>The elegance of this notation is that it is a <a href="https://en.wikipedia.org/wiki/Prefix_code">prefix code</a>, so no delimiting characters are required - the spaces between the <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>0</span></span></span></span> and <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>1</span></span></span></span> can be removed in practice. Moreover, for any valid proram <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>P</span></span></span></span>, there exists no valid program <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mi>Q</mi></mrow><annotation encoding="application/x-tex">PQ</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>PQ</span></span></span></span> that starts with <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>P</span></span></span></span> followed with a nonempty <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>Q</span></span></span></span>.</p>

<p>Due to the prefix code property, the interpreter can distinguish the boundary between the program and the stdin even if they are provided as concatenated byte streams. For example, when running <code>lambdalisp.blc</code>, we run:</p>

<div><div><pre><code><span>cat </span>lambdalisp.blc | ./asc2bin <span>&gt;</span> lambdalisp.blc.bin
<span>cat </span>lambdalisp.blc.bin <span>[</span>filepath] | ./Blc
</code></pre></div></div>

<p>Normally, it is difficult or impossible to deduce the boundary between the binary <code>lambdalisp.blc.bin</code> and <code>[filepath]</code> since they are <code>cat</code>ed together, but it is easily possible in BLC since all valid programs are prefix codes.</p>

<h2 id="about-the-logo">About the Logo</h2>

<p><a href="https://danluu.com/blog/assets/posts/2022-09-17/lambdalisp_logo.png"><img src="https://danluu.com/blog/assets/posts/2022-09-17/lambdalisp_logo.png" alt="LambdaLisp&#39;s logo"/></a></p>

<ul>
  <li>The rounded edges of the cube represent Lisp’s parentheses syntax.</li>
  <li>Alan Kay described Lisp in the quote, “Lisp isn’t a language, it’s a building material.”
The cube is a depiction of a block, which represents the building blocks of software.</li>
</ul>

<h2 id="credits">Credits</h2>
<p>LambdaLisp was written by Hikaru Ikuta.
The lambda calculus term compiler <a href="https://github.com/woodrush/lambdacraft">LambdaCraft</a> was written by Hikaru Ikuta,
inspired by Ben Rudiak-Gould’s Scheme program Lazier, a compiler from lambda terms written in Scheme to Lazy K.
The LambdaLisp logo was designed by Hikaru Ikuta.
The <a href="https://justine.lol/lambda/">521-byte lambda calculus interpreter</a> SectorLambda was written by Justine Tunney.
The <a href="https://www.ioccc.org/">IOCCC</a> 2012 <a href="https://www.ioccc.org/2012/tromp/hint.html">“Most functional”</a> interpreter was written by John Tromp.
The Universal Lambda interpreter <a href="https://github.com/irori/clamb">clamb</a> and Lazy K interpreter <a href="https://github.com/irori/lazyk">lazyk</a> was written by Kunihiko Sakamoto.</p>

  </div>
</article>

      </div>
    </div></div>
  </body>
</html>
