<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jakelazaroff.com/words/building-a-collaborative-pixel-art-editor-with-crdts/">Original</a>
    <h1>Building a Collaborative Pixel Art Editor with CRDTs</h1>
    
    <div id="readability-page-1" class="page"><div data-content="" data-astro-cid-rnrqlda2="">
<p>Welcome back! In <a href="https://jakelazaroff.com/words/an-interactive-intro-to-crdts/" data-astro-cid-bi7aps5f="">An Interactive Intro to CRDTs</a><a data-tooltip="" href="https://jakelazaroff.com/words/an-interactive-intro-to-crdts/" data-astro-cid-bi7aps5f=""><img src="https://jakelazaroff.com/og/an-interactive-intro-to-crdts.png" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/><span data-astro-cid-bi7aps5f="">An Interactive Intro to CRDTs | jakelazaroff.com</span><span data-astro-cid-bi7aps5f="">CRDTs don&#39;t have to be all academic papers and math jargon. Learn what CRDTs are and how they work through interactive visualizations and code samples.</span><span data-astro-cid-bi7aps5f=""><img src="https://jakelazaroff.com/favicon.ico" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/><span data-astro-cid-bi7aps5f="">jakelazaroff.com/words/an-interactive-intro-to-crdts/</span><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"><use href="/icons.svg#share"></use></svg></span></a>, we learned what CRDTs are, and implemented two: a <strong>Last Write Wins Register</strong> and a <strong>Last Write Wins Map</strong>. We now have everything we need to build a collaborative pixel art editor, and in this post we’ll do just that. This post will be heavier on JavaScript and graphics programming, because I want to show how CRDTs can be used in an actual app.</p>
<p>As a reminder, this is what we’re building:</p>
<pixelart-demo></pixelart-demo>

<p>This post assumes no prior knowledge about CRDTs other than the previous post — so if you haven’t read it yet, <a href="https://jakelazaroff.com/words/an-interactive-intro-to-crdts/" data-astro-cid-bi7aps5f="">go back and do that now</a><a data-tooltip="" href="https://jakelazaroff.com/words/an-interactive-intro-to-crdts/" data-astro-cid-bi7aps5f=""><img src="https://jakelazaroff.com/og/an-interactive-intro-to-crdts.png" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/><span data-astro-cid-bi7aps5f="">An Interactive Intro to CRDTs | jakelazaroff.com</span><span data-astro-cid-bi7aps5f="">CRDTs don&#39;t have to be all academic papers and math jargon. Learn what CRDTs are and how they work through interactive visualizations and code samples.</span><span data-astro-cid-bi7aps5f=""><img src="https://jakelazaroff.com/favicon.ico" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/><span data-astro-cid-bi7aps5f="">jakelazaroff.com/words/an-interactive-intro-to-crdts/</span><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"><use href="/icons.svg#share"></use></svg></span></a>! — and only a rudimentary knowledge of TypeScript.<sup><a href="#user-content-fn-canvas" id="user-content-fnref-canvas" data-footnote-ref="" aria-describedby="footnote-label" data-astro-cid-bi7aps5f="">1</a></sup></p>
<h3 id="building-the-crdt">Building the CRDT</h3>
<p>Before we start on the CRDT, we need just one more type. We’ll store colors as tuples of three integers, representing red, green and blue values.</p>
<pre><code><span>type</span> <span><span>RGB</span></span> <span>=</span> <span>[</span>red<span>:</span> <span>number</span><span>,</span> green<span>:</span> <span>number</span><span>,</span> blue<span>:</span> <span>number</span><span>]</span><span>;</span></code></pre>
<p>With that out of the way, let’s build the CRDT! It’ll be a class called <code>PixelData</code>:</p>
<pre><code><span>class</span> <span>PixelData</span> <span>{</span>
  <span>readonly</span> id<span>:</span> <span>string</span><span>;</span>
  #data<span>:</span> LWWMap<span>&lt;</span><span>RGB</span><span>&gt;</span><span>;</span>

  <span>constructor</span><span>(</span>id<span>:</span> <span>string</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>id <span>=</span> id<span>;</span>
    <span>this</span><span>.</span>#data <span>=</span> <span>new</span> <span>LWWMap</span><span>(</span><span>this</span><span>.</span>id<span>,</span> <span>{</span><span>}</span><span>)</span><span>;</span>
  <span>}</span>

  
  <span>static</span> <span>key</span><span>(</span>x<span>:</span> <span>number</span><span>,</span> y<span>:</span> <span>number</span><span>)</span> <span>{</span>
    <span>return</span> <span><span>`</span><span><span>${</span>x<span>}</span></span><span>,</span><span><span>${</span>y<span>}</span></span><span>`</span></span><span>;</span>
  <span>}</span>

  <span>get</span> <span>value</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>this</span><span>.</span>#data<span>.</span>value<span>;</span>
  <span>}</span>

  <span>get</span> <span>state</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>this</span><span>.</span>#data<span>.</span>state<span>;</span>
  <span>}</span>

  <span>set</span><span>(</span>x<span>:</span> <span>number</span><span>,</span> y<span>:</span> <span>number</span><span>,</span> value<span>:</span> <span>RGB</span><span>)</span> <span>{</span>
    <span>const</span> key <span>=</span> PixelData<span>.</span><span>key</span><span>(</span>x<span>,</span> y<span>)</span><span>;</span>
    <span>this</span><span>.</span>#data<span>.</span><span>set</span><span>(</span>key<span>,</span> value<span>)</span><span>;</span>
  <span>}</span>

  <span>get</span><span>(</span>x<span>:</span> <span>number</span><span>,</span> y<span>:</span> <span>number</span><span>)</span><span>:</span> <span>RGB</span> <span>{</span>
    <span>const</span> key <span>=</span> PixelData<span>.</span><span>key</span><span>(</span>x<span>,</span> y<span>)</span><span>;</span>

    <span>const</span> register <span>=</span> <span>this</span><span>.</span>#data<span>.</span><span>get</span><span>(</span>key<span>)</span><span>;</span>
    <span>return</span> register <span>??</span> <span>[</span><span>255</span><span>,</span> <span>255</span><span>,</span> <span>255</span><span>]</span><span>;</span>
  <span>}</span>

  <span>delete</span><span>(</span>x<span>:</span> <span>number</span><span>,</span> y<span>:</span> <span>number</span><span>)</span> <span>{</span>
    <span>const</span> key <span>=</span> PixelData<span>.</span><span>key</span><span>(</span>x<span>,</span> y<span>)</span><span>;</span>
    <span>this</span><span>.</span>#data<span>.</span><span>delete</span><span>(</span>key<span>)</span><span>;</span>
  <span>}</span>

  <span>merge</span><span>(</span>state<span>:</span> PixelData<span>[</span><span>&#34;state&#34;</span><span>]</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>#data<span>.</span><span>merge</span><span>(</span>state<span>)</span><span>;</span>
  <span>}</span>
<span>}</span></code></pre>
<p>This is only a thin wrapper over a LWW Map. Almost every method just calls the corresponding LWW Map method!</p>
<p>The biggest change involves the static method <code>key</code>. When we’re interacting with the pixel art editor, it’s most natural to think in terms of <em>(x,y)</em> coordinates. But our LWW Map needs string keys! The <code>key</code> static method serializes coordinate pairs to strings — for example, <em>(15,29)</em> becomes <code>&#34;15,29&#34;</code>. Since the LWW Map values are colors in the form of <code>RGB</code> tuples, we can think of this data structure as mapping from pixel coordinates to colors, with each key representing a single pixel.</p>
<p>The <code>get</code> method is also slightly different. We want our pixels to default to white. So if no value has been set, we return a default value of <code>[255, 255, 255]</code>.</p>
<p>Let’s peek under the hood and see what will happen to each register in the map when we draw.<sup><a href="#user-content-fn-chonky" id="user-content-fnref-chonky" data-footnote-ref="" aria-describedby="footnote-label" data-astro-cid-bi7aps5f="">2</a></sup></p>
<combo-diagram></combo-diagram>
<p>Here we can really see how the keys and values interact. When painting the top left square, the key <code>&#34;1,1&#34;</code> is set to the RGB color you have selected (<code>[0, 0, 0]</code> if you didn’t change from the default). We can also see how pixels that haven’t yet been set default to white. Painting over a pixel overwrites the value and increments the timestamp by one. If you turn the network off and paint the same pixels on each canvas, the ones with the higher timestamps will win out when you turn the network back on.</p>
<p>This visualization takes a lot of space for just a few pixels. Instead, let’s overlay each pixel with the timestamp of its register:</p>
<pixelart-demo resolution="20" debug="true"></pixelart-demo>
<p>Now we can see how each pixel should interact in the context of the picture.</p>
<p>That’s it! That’s the whole CRDT! As you read through the rest of the post, you’ll see that the app mostly doesn’t even realize that it’s using a CRDT under the hood.</p>
<h3 id="scaffolding-the-ui">Scaffolding the UI</h3>
<p>Now that we have our CRDT, we need to set up the UI. Here’s the HTML and CSS:</p>
<pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>&#34;</span>wrapper<span>&#34;</span></span><span>&gt;</span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>&#34;</span>canvases<span>&#34;</span></span><span>&gt;</span></span>
    <span><span><span>&lt;</span>canvas</span> <span>class</span><span><span>=</span><span>&#34;</span>canvas<span>&#34;</span></span> <span>id</span><span><span>=</span><span>&#34;</span>alice<span>&#34;</span></span><span>&gt;</span></span><span><span><span>&lt;/</span>canvas</span><span>&gt;</span></span>
    <span><span><span>&lt;</span>canvas</span> <span>class</span><span><span>=</span><span>&#34;</span>canvas<span>&#34;</span></span> <span>id</span><span><span>=</span><span>&#34;</span>bob<span>&#34;</span></span><span>&gt;</span></span><span><span><span>&lt;/</span>canvas</span><span>&gt;</span></span>
  <span><span><span>&lt;/</span>div</span><span>&gt;</span></span>
  <span><span><span>&lt;</span>input</span> <span>class</span><span><span>=</span><span>&#34;</span>color<span>&#34;</span></span> <span>type</span><span><span>=</span><span>&#34;</span>color<span>&#34;</span></span> <span>value</span><span><span>=</span><span>&#34;</span>#000000<span>&#34;</span></span> <span>/&gt;</span></span>
<span><span><span>&lt;/</span>div</span><span>&gt;</span></span>

<span><span><span>&lt;</span>style</span><span>&gt;</span></span><span><span>
  <span>.wrapper</span> <span>{</span>
    <span>display</span><span>:</span> inline-flex<span>;</span>
    <span>flex-direction</span><span>:</span> column<span>;</span>
    <span>gap</span><span>:</span> 1rem<span>;</span>
  <span>}</span>

  <span>.canvases</span> <span>{</span>
    <span>display</span><span>:</span> flex<span>;</span>
    <span>gap</span><span>:</span> 1rem<span>;</span>
  <span>}</span>

  <span>.canvas</span> <span>{</span>
    <span>width</span><span>:</span> 25rem<span>;</span>
    <span>height</span><span>:</span> 25rem<span>;</span>
    <span>border</span><span>:</span> 0.25rem solid #eeeeee<span>;</span>
    <span>border-radius</span><span>:</span> 0.25rem<span>;</span>
    <span>cursor</span><span>:</span> crosshair<span>;</span>
    <span>touch-action</span><span>:</span> none<span>;</span>
  <span>}</span>

  <span>.color</span> <span>{</span>
    <span>border</span><span>:</span> 0<span>;</span>
  <span>}</span>
</span></span><span><span><span>&lt;/</span>style</span><span>&gt;</span></span></code></pre>
<p>Then a little JavaScript to instantiate our two editors:</p>
<pre><code>
<span>const</span> acanvas <span>=</span> document<span>.</span><span>querySelector</span><span>(</span><span>&#34;#alice&#34;</span><span>)</span><span>;</span>
<span>if</span> <span>(</span><span>!</span><span>(</span>acanvas <span>instanceof</span> <span>HTMLCanvasElement</span><span>)</span><span>)</span> <span>throw</span> <span>new</span> <span>Error</span><span>(</span><span><span>`</span><span>&lt;canvas id=&#34;alice&#34;&gt; not found!</span><span>`</span></span><span>)</span><span>;</span>


<span>const</span> bcanvas <span>=</span> document<span>.</span><span>querySelector</span><span>(</span><span>&#34;#bob&#34;</span><span>)</span><span>;</span>
<span>if</span> <span>(</span><span>!</span><span>(</span>bcanvas <span>instanceof</span> <span>HTMLCanvasElement</span><span>)</span><span>)</span> <span>throw</span> <span>new</span> <span>Error</span><span>(</span><span><span>`</span><span>&lt;canvas id=&#34;bob&#34;&gt; not found!</span><span>`</span></span><span>)</span><span>;</span>


<span>const</span> palette <span>=</span> document<span>.</span><span>querySelector</span><span>(</span><span><span>`</span><span>input[type=&#34;color&#34;]</span><span>`</span></span><span>)</span><span>;</span>
<span>if</span> <span>(</span><span>!</span><span>(</span>palette <span>instanceof</span> <span>HTMLInputElement</span><span>)</span><span>)</span> <span>throw</span> <span>new</span> <span>Error</span><span>(</span><span><span>`</span><span>&lt;input type=&#34;color&#34;&gt; not found!</span><span>`</span></span><span>)</span><span>;</span>


<span>const</span> artboardSize <span>=</span> <span>{</span> w<span>:</span> <span>100</span><span>,</span> h<span>:</span> <span>100</span> <span>}</span><span>;</span>


<span>const</span> alice <span>=</span> <span>new</span> <span>PixelEditor</span><span>(</span>acanvas<span>,</span> artboardSize<span>)</span><span>;</span>
<span>const</span> bob <span>=</span> <span>new</span> <span>PixelEditor</span><span>(</span>bcanvas<span>,</span> artboardSize<span>)</span><span>;</span>


alice<span>.</span><span>onchange</span> <span>=</span> state <span>=&gt;</span> bob<span>.</span><span>receive</span><span>(</span>state<span>)</span><span>;</span>
bob<span>.</span><span>onchange</span> <span>=</span> state <span>=&gt;</span> alice<span>.</span><span>receive</span><span>(</span>state<span>)</span><span>;</span>


palette<span>.</span><span>oninput</span> <span>=</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>const</span> hex <span>=</span> palette<span>.</span>value<span>.</span><span>substring</span><span>(</span><span>1</span><span>)</span><span>.</span><span>match</span><span>(</span><span><span>/</span><span>[\da-f]{2}</span><span>/</span><span>g</span></span><span>)</span> <span>||</span> <span>[</span><span>]</span><span>;</span>
  <span>const</span> rgb <span>=</span> hex<span>.</span><span>map</span><span>(</span>byte <span>=&gt;</span> <span>parseInt</span><span>(</span>byte<span>,</span> <span>16</span><span>)</span><span>)</span><span>;</span>
  <span>if</span> <span>(</span>rgb<span>.</span>length <span>===</span> <span>3</span><span>)</span> alice<span>.</span>color <span>=</span> bob<span>.</span>color <span>=</span> rgb <span>as</span> <span>RGB</span><span>;</span>
<span>}</span><span>;</span></code></pre>
<p>Let’s break this down a bit:</p>
<ol>
<li>Query the DOM for the two <code>&lt;canvas&gt;</code> elements and the color input.</li>
<li>Store the artboard size. These are the drawable dimensions, and they might be different from the size of the <code>&lt;canvas&gt;</code> element. For example, the canvas might be 400×400, but we might want our picture to only be 40×40, where each “pixel” the user sees takes up 10×10 actual pixels on the canvas. For clarity, “artboard” will always refer to what the user perceives and interacts with, while “canvas” will refer to the underlying <code>&lt;canvas&gt;</code> element.</li>
<li>Instantiate a <code>PixelEditor</code> class (which we’ll write shortly) with a <code>&lt;canvas&gt;</code> element and the artboard size.</li>
<li>When a change happens in either editor, merge the state with the other.</li>
<li>Set the editor color whenever the color input changes. HTML color inputs return their color as hex code strings<sup><a href="#user-content-fn-hex" id="user-content-fnref-hex" data-footnote-ref="" aria-describedby="footnote-label" data-astro-cid-bi7aps5f="">3</a></sup> (for example, <code>#845ef7</code>) so we need to do a little work to convert it to RGB format. This code just removes the <code>#</code>, splits the string into two-character chunks and parses each of them from a base 16 integer into a JS <code>number</code> — which is exactly what our <code>RGB</code> type expects.</li>
</ol>
<p>As you can see, we’re only simulating the network. Actually writing network code is a separate problem from designing and using the CRDT data structure.<sup><a href="#user-content-fn-network" id="user-content-fnref-network" data-footnote-ref="" aria-describedby="footnote-label" data-astro-cid-bi7aps5f="">4</a></sup></p>
<h3 id="starting-the-editor">Starting the Editor</h3>
<p>Let’s define the <code>PixelEditor</code> class now. Here’s the skeleton:</p>
<pre><code><span>class</span> <span>PixelEditor</span> <span>{</span>
  
  #el<span>:</span> HTMLCanvasElement<span>;</span>

  
  #ctx<span>:</span> CanvasRenderingContext2D<span>;</span>

  
  #artboard<span>:</span> <span>{</span> w<span>:</span> <span>number</span><span>;</span> h<span>:</span> <span>number</span> <span>}</span><span>;</span>

  
  #data <span>=</span> <span>new</span> <span>PixelData</span><span>(</span><span>)</span><span>;</span>

  
  #color<span>:</span> <span>RGB</span> <span>=</span> <span>[</span><span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>]</span><span>;</span>

  
  #listeners<span>:</span> <span>Array</span><span>&lt;</span><span>(</span>state<span>:</span> PixelData<span>[</span><span>&#34;state&#34;</span><span>]</span><span>)</span> <span>=&gt;</span> <span>void</span><span>&gt;</span> <span>=</span> <span>[</span><span>]</span><span>;</span>

  <span>constructor</span><span>(</span>el<span>:</span> HTMLCanvasElement<span>,</span> artboard<span>:</span> <span>{</span> w<span>:</span> <span>number</span><span>;</span> h<span>:</span> <span>number</span> <span>}</span><span>)</span> <span>{</span><span>}</span>

  
  <span>set</span> <span>onchange</span><span>(</span>listener<span>:</span> <span>(</span>state<span>:</span> PixelData<span>[</span><span>&#34;state&#34;</span><span>]</span><span>)</span> <span>=&gt;</span> <span>void</span><span>)</span> <span>{</span><span>}</span>

  
  <span>set</span> <span>color</span><span>(</span>color<span>:</span> <span>RGB</span><span>)</span> <span>{</span><span>}</span>

  
  <span>handleEvent</span><span>(</span>e<span>:</span> PointerEvent<span>)</span> <span>{</span><span>}</span>

  
  <span>#paint</span><span>(</span>x<span>:</span> <span>number</span><span>,</span> y<span>:</span> <span>number</span><span>)</span> <span>{</span><span>}</span>

  
  async <span>#draw</span><span>(</span><span>)</span> <span>{</span><span>}</span>

  
  <span>#notify</span><span>(</span><span>)</span> <span>{</span><span>}</span>

  
  <span>receive</span><span>(</span>state<span>:</span> PixelData<span>[</span><span>&#34;state&#34;</span><span>]</span><span>)</span> <span>{</span><span>}</span>
<span>}</span></code></pre>
<p>The methods are empty (for now), but hopefully this gives a decent idea of what the shape of this program will be. At a high level, when the user draws on the canvas with their mouse, the <code>PixelEditor</code>…</p>
<ol>
<li>Receives DOM events (<code>handleEvent</code>) and sets the selected color (<code>#paint</code>) in its <code>PixelData</code> CRDT.</li>
<li>Draws to the canvas (<code>#draw</code>) based on its <code>PixelData</code> CRDT value.</li>
<li>Notifies any listeners (<code>#notify</code>) that its data has changed.</li>
</ol>
<p>On the other end, when a <code>PixelEditor</code> receives state from a peer (<code>receive</code>) it updates its own <code>PixelData</code> CRDT and then draws to the canvas (<code>#draw</code>).</p>
<p>Cool, so let’s start filling in those missing <code>PixelEditor</code> methods. First up, the constructor:</p>
<pre><code>  <span>constructor</span><span>(</span>el<span>:</span> HTMLCanvasElement<span>,</span> artboard<span>:</span> <span>{</span> w<span>:</span> <span>number</span><span>;</span> h<span>:</span> <span>number</span> <span>}</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>#el <span>=</span> el<span>;</span>

    
    <span>const</span> ctx <span>=</span> el<span>.</span><span>getContext</span><span>(</span><span>&#34;2d&#34;</span><span>)</span><span>;</span>
    <span>if</span> <span>(</span><span>!</span>ctx<span>)</span> <span>throw</span> <span>new</span> <span>Error</span><span>(</span><span>&#34;Couldn&#39;t get rendering context&#34;</span><span>)</span><span>;</span>
    <span>this</span><span>.</span>#ctx <span>=</span> ctx<span>;</span>

    
    <span>this</span><span>.</span>#artboard <span>=</span> artboard<span>;</span>

    
    <span>this</span><span>.</span>#el<span>.</span><span>addEventListener</span><span>(</span><span>&#34;pointerdown&#34;</span><span>,</span> <span>this</span><span>)</span><span>;</span>
    <span>this</span><span>.</span>#el<span>.</span><span>addEventListener</span><span>(</span><span>&#34;pointermove&#34;</span><span>,</span> <span>this</span><span>)</span><span>;</span>
    <span>this</span><span>.</span>#el<span>.</span><span>addEventListener</span><span>(</span><span>&#34;pointerup&#34;</span><span>,</span> <span>this</span><span>)</span><span>;</span>

    
    <span>this</span><span>.</span>#el<span>.</span>width <span>=</span> <span>this</span><span>.</span>#el<span>.</span>clientWidth <span>*</span> devicePixelRatio<span>;</span>
    <span>this</span><span>.</span>#el<span>.</span>height <span>=</span> <span>this</span><span>.</span>#el<span>.</span>clientHeight <span>*</span> devicePixelRatio<span>;</span>
    <span>this</span><span>.</span>#ctx<span>.</span><span>scale</span><span>(</span>devicePixelRatio<span>,</span> devicePixelRatio<span>)</span><span>;</span>
    <span>this</span><span>.</span>#ctx<span>.</span>imageSmoothingEnabled <span>=</span> <span>false</span><span>;</span>
  <span>}</span></code></pre>
<ol>
<li>Store the <code>&lt;canvas&gt;</code> element and get the 2D rendering context.</li>
<li>Store the artboard size. We’ll use this later to convert between the artboard resolution and the canvas resolution.</li>
<li>Listen for <code>pointerdown</code>, <code>pointermove</code> and <code>pointerup</code> events. These will be triggered when the user interacts with the canvas.</li>
<li>Resize the canvas size to match the dimensions of the <code>&lt;canvas&gt;</code> element.<sup><a href="#user-content-fn-dpi" id="user-content-fnref-dpi" data-footnote-ref="" aria-describedby="footnote-label" data-astro-cid-bi7aps5f="">5</a></sup></li>
</ol>
<p>Now onto the instance methods. First up, <code>color</code>:</p>
<pre><code>  
  <span>set</span> <span>color</span><span>(</span>color<span>:</span> <span>RGB</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>#color <span>=</span> color<span>;</span>
  <span>}</span></code></pre>
<p>This is just a setter that takes an <code>RGB</code> tuple and sets the drawing color. You might remember that when we set up our HTML, we called this setter from outside the class in response to <code>input</code> events on the color input.</p>
<p>Next, <code>handleEvent</code>:</p>
<pre><code>  
  <span>handleEvent</span><span>(</span>e<span>:</span> PointerEvent<span>)</span> <span>{</span>
    <span>switch</span> <span>(</span>e<span>.</span>type<span>)</span> <span>{</span>
      
      <span>case</span> <span>&#34;pointerdown&#34;</span><span>:</span> <span>{</span>
        <span>this</span><span>.</span>#el<span>.</span><span>setPointerCapture</span><span>(</span>e<span>.</span>pointerId<span>)</span><span>;</span>
        
      <span>}</span>

      <span>case</span> <span>&#34;pointermove&#34;</span><span>:</span> <span>{</span>
        <span>if</span> <span>(</span><span>!</span><span>this</span><span>.</span>#el<span>.</span><span>hasPointerCapture</span><span>(</span>e<span>.</span>pointerId<span>)</span><span>)</span> <span>return</span><span>;</span>

        
        <span>const</span> x <span>=</span> Math<span>.</span><span>floor</span><span>(</span><span>(</span><span>this</span><span>.</span>#artboard<span>.</span>w <span>*</span> e<span>.</span>offsetX<span>)</span> <span>/</span> <span>this</span><span>.</span>#el<span>.</span>clientWidth<span>)</span><span>,</span>
          y <span>=</span> Math<span>.</span><span>floor</span><span>(</span><span>(</span><span>this</span><span>.</span>#artboard<span>.</span>h <span>*</span> e<span>.</span>offsetY<span>)</span> <span>/</span> <span>this</span><span>.</span>#el<span>.</span>clientHeight<span>)</span><span>;</span>

        <span>this</span><span>.</span><span>#paint</span><span>(</span>x<span>,</span> y<span>)</span><span>;</span>
        <span>break</span><span>;</span>
      <span>}</span>

      <span>case</span> <span>&#34;pointerup&#34;</span><span>:</span> <span>{</span>
        <span>this</span><span>.</span>#el<span>.</span><span>releasePointerCapture</span><span>(</span>e<span>.</span>pointerId<span>)</span><span>;</span>
        <span>break</span><span>;</span>
      <span>}</span>
    <span>}</span>
  <span>}</span></code></pre>
<p>This handles all three types of pointer events. Let’s go through them one by one:</p>
<ul>
<li><code>pointerdown</code> is triggered when the user depresses the mouse button or touches their finger to the screen. Calling <code>setPointerCapture</code> on the <code>&lt;canvas&gt;</code> element “captures” the pointer, which lets us figure out whether discrete events are part of one continuous drag. We also want to draw a pixel, which uses the same logic as the <code>pointermove</code> event, so we fall through to the next switch case.<sup><a href="#user-content-fn-badidearight" id="user-content-fnref-badidearight" data-footnote-ref="" aria-describedby="footnote-label" data-astro-cid-bi7aps5f="">6</a></sup></li>
<li><code>pointermove</code> is triggered when the pointer, uh, moves. At the top, we check whether the pointer is captured, so we can ignore mouse events if the user isn’t holding down the mouse button. Then, we convert from canvas pixels to artboard pixels and call the <code>#paint</code> method to draw the pixel on the canvas.</li>
<li><code>pointerup</code> is triggered when the user releases the mouse button or removes their finger from the screen. We clean up by calling <code>releasePointerCapture</code>.</li>
</ul>
<p>Since we’ve just called the <code>#paint</code> method, let’s see what it looks like:</p>
<pre><code>  <span>/**
   * Sets pixel under the mouse cursor with the current color.
   * @param x X coordinate of the destination pixel.
   * @param y Y coordinate of the destination pixel.
   */</span>
  <span>#paint</span><span>(</span>x<span>:</span> <span>number</span><span>,</span> y<span>:</span> <span>number</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>x <span>&lt;</span> <span>0</span> <span>||</span> <span>this</span><span>.</span>#artboard<span>.</span>w <span>&lt;=</span> x<span>)</span> <span>return</span><span>;</span>
    <span>if</span> <span>(</span>y <span>&lt;</span> <span>0</span> <span>||</span> <span>this</span><span>.</span>#artboard<span>.</span>h <span>&lt;=</span> y<span>)</span> <span>return</span><span>;</span>

    <span>this</span><span>.</span>#data<span>.</span><span>set</span><span>(</span>x<span>,</span> y<span>,</span> <span>this</span><span>.</span>#color<span>)</span><span>;</span>
    <span>this</span><span>.</span><span>#draw</span><span>(</span><span>)</span><span>;</span>
  <span>}</span></code></pre>
<p>Simple enough: if the given coordinates are inside the artboard, it sets the coordinates to the active color in <code>#data</code> (an instance of the <code>PixelData</code> class we defined before) and then draws to the canvas. Like I said, we don’t really care at this point that <code>PixelData</code> class is actually a CRDT — as far as the <code>PixelEditor</code> class is concerned, it’s just setting a color in its data.</p>
<p>Now, <code>#draw</code>. The basic idea is that we’ll allocate a <strong>buffer</strong> — a contiguous chunk of memory, like an array — and then we write the raw pixel data there. Once we’ve done that, the canvas API lets us draw the raw pixel data onto the canvas. Here’s what it looks like:</p>
<pre><code>  <span>/** Draw each pixel on the canvas. */</span>
  async <span>#draw</span><span>(</span><span>)</span> <span>{</span>
    <span>/** Number of channels per pixel; R, G, B, A */</span>
    <span>const</span> chans <span>=</span> <span>4</span><span>;</span>

    <span>/** A buffer to hold the raw pixel data.
     * Each pixel corresponds to four bytes in the buffer,
     * so the full size is the number of pixels times the number of channels per pixel. */</span>
    <span>const</span> buffer <span>=</span> <span>new</span> <span>Uint8ClampedArray</span><span>(</span><span>this</span><span>.</span>#artboard<span>.</span>w <span>*</span> <span>this</span><span>.</span>#artboard<span>.</span>h <span>*</span> chans<span>)</span><span>;</span>

    <span>/** The number of bytes in the buffer representing a single artboard row. */</span>
    <span>const</span> rowsize <span>=</span> <span>this</span><span>.</span>#artboard<span>.</span>w <span>*</span> chans<span>;</span>

    <span>for</span> <span>(</span><span>let</span> row <span>=</span> <span>0</span><span>;</span> row <span>&lt;</span> <span>this</span><span>.</span>#artboard<span>.</span>h<span>;</span> row<span>++</span><span>)</span> <span>{</span>
      <span>// calculate the byte offset of the start of the row relative to the start of the buffer</span>
      <span>const</span> offsetY <span>=</span> row <span>*</span> rowsize<span>;</span>

      <span>for</span> <span>(</span><span>let</span> col <span>=</span> <span>0</span><span>;</span> col <span>&lt;</span> <span>this</span><span>.</span>#artboard<span>.</span>w<span>;</span> col<span>++</span><span>)</span> <span>{</span>
        <span>// calculate the byte offset of the pixel relative to the start of the row</span>
        <span>const</span> offsetX <span>=</span> col <span>*</span> chans<span>;</span>

        <span>// calculate the byte offset of the pixel relative to the start of the buffer</span>
        <span>const</span> offset <span>=</span> offsetY <span>+</span> offsetX<span>;</span>

        <span>const</span> <span>[</span>r<span>,</span> g<span>,</span> b<span>]</span> <span>=</span> <span>this</span><span>.</span>#data<span>.</span><span>get</span><span>(</span>col<span>,</span> row<span>)</span><span>;</span>
        buffer<span>[</span>offset<span>]</span> <span>=</span> r<span>;</span>
        buffer<span>[</span>offset <span>+</span> <span>1</span><span>]</span> <span>=</span> g<span>;</span>
        buffer<span>[</span>offset <span>+</span> <span>2</span><span>]</span> <span>=</span> b<span>;</span>
        buffer<span>[</span>offset <span>+</span> <span>3</span><span>]</span> <span>=</span> <span>255</span><span>;</span>
      <span>}</span>
    <span>}</span>

    <span>const</span> data <span>=</span> <span>new</span> <span>ImageData</span><span>(</span>buffer<span>,</span> <span>this</span><span>.</span>#artboard<span>.</span>w<span>,</span> <span>this</span><span>.</span>#artboard<span>.</span>h<span>)</span><span>;</span>
    <span>const</span> bitmap <span>=</span> <span>await</span> <span>createImageBitmap</span><span>(</span>data<span>)</span><span>;</span>
    <span>this</span><span>.</span>#ctx<span>.</span><span>drawImage</span><span>(</span>bitmap<span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>this</span><span>.</span>#el<span>.</span>clientWidth<span>,</span> <span>this</span><span>.</span>#el<span>.</span>clientHeight<span>)</span><span>;</span>
  <span>}</span></code></pre>
<p>Slight tangent into how colors are represented in memory. RGB colors consist of three channels — red, green and blue — each of which is a single number between 0 and 255, or eight bits (one byte). That’s 24-bit color. The canvas API uses 32-bit color, which adds one extra channel — alpha, or transparency — which is also a single number between 0 and 255. So each pixel takes up up four bytes.</p>
<p>First, we need to allocate a buffer to hold the pixel data.<sup><a href="#user-content-fn-optimization" id="user-content-fnref-optimization" data-footnote-ref="" aria-describedby="footnote-label" data-astro-cid-bi7aps5f="">7</a></sup> Since we know the pixel dimensions of the artboard, we can calculate how big of a buffer we need: four bytes per pixel times the artboard width times the artboard height. From there, we iterate over the rows and columns of the artboard, calculating each pixel’s byte offset into the buffer. Then we write the pixel color values into the next four bytes of the buffer following that offset.</p>
<p>If you’re not familiar with how to calculate the offset, try the playground below. Hover over different pixels in the “artboard” at the top or the “buffer” at the bottom to see how they correspond to each other.</p>
<buffer-diagram width="3" height="3"></buffer-diagram>
<p>The first four bytes (0–3) are the red, green, blue and alpha channels of the top left pixel. The next four bytes (4–7) are the pixel second from the left on the top row — and so on, until we hit the top right pixel. Then, we wrap around — the next four bytes of the buffer are the leftmost pixel on the <strong>second</strong> row — and continue going, until finally we get to the bottom right pixel in the last four bytes of the buffer.</p>
<p>Finally, we draw that buffer to the canvas.<sup><a href="#user-content-fn-canvasstuff" id="user-content-fnref-canvasstuff" data-footnote-ref="" aria-describedby="footnote-label" data-astro-cid-bi7aps5f="">8</a></sup> Phew!</p>
<p>At this point, we have a fully functional pixel art editor without the peer-to-peer parts:</p>
<pixelart-demo network="off" dda="off" dedupe="off"></pixelart-demo>

<p>Before we can connect the two editors, we need to fix a big issue with the drawing. You’ve probably noticed it already: if you move quickly, there are gaps between the pixels.</p>
<h3 id="drawing-lines">Drawing Lines</h3>
<p>The problem is that events don’t necessarily get triggered as fast as the user can move their cursor, which means that the coordinates for each call to <code>#paint</code> might not be next to each other. We can fix this by storing the pixel coordinates of the pointer during the previous event, and drawing a line between them and the current coordinates. Buckle up, because we’re about to make a bunch of changes to our <code>PixelEditor</code> class.</p>
<p>First, we’ll add a private <code>#prev</code> property that holds either an <em>(x,y)</em> coordinate pair, or <code>undefined</code>:</p>
<pre><code><span>class</span> <span>PixelEditor</span> <span>{</span>
  <span>// ...</span>

  <span>/** The previous position of the mouse cursor */</span>
  #prev<span>:</span> <span>[</span>x<span>:</span> <span>number</span><span>,</span> y<span>:</span> <span>number</span><span>]</span> <span>|</span> <span>undefined</span><span>;</span>

  <span>// ...</span>
<span>}</span></code></pre>
<p>Then, we’ll modify our <code>handleEvent</code> method. We need to store the cursor’s coordinates on the artboard in <code>#prev</code> as the very last step in the <code>pointermove</code> case,<sup><a href="#user-content-fn-fallthrough" id="user-content-fnref-fallthrough" data-footnote-ref="" aria-describedby="footnote-label" data-astro-cid-bi7aps5f="">9</a></sup> right before the <code>break</code>. Then, in the <code>pointerup</code> case, we need to reset <code>#prev</code> to <code>undefined</code>:</p>
<pre><code>  <span>/**
   * Handles events on the canvas.
   * @param e Pointer event from the canvas element.
   */</span>
  <span>handleEvent</span><span>(</span>e<span>:</span> PointerEvent<span>)</span> <span>{</span>
    <span>switch</span> <span>(</span>e<span>.</span>type<span>)</span> <span>{</span>
      <span>// ...</span>

      <span>case</span> <span>&#34;pointermove&#34;</span><span>:</span> <span>{</span>
        <span>// ...</span>

        <span>this</span><span>.</span>#prev <span>=</span> <span>[</span>x<span>,</span> y<span>]</span><span>;</span>
        <span>break</span><span>;</span>
      <span>}</span>

      <span>case</span> <span>&#34;pointerup&#34;</span><span>:</span> <span>{</span>
        <span>// ...</span>
        <span>this</span><span>.</span>#prev <span>=</span> <span>undefined</span><span>;</span>
        <span>break</span><span>;</span>
      <span>}</span>
    <span>}</span>
  <span>}</span></code></pre>
<p>The biggest changes are in our <code>#paint</code> method, where we need to implement the line drawing. There are a bunch of algorithms for doing this; we’ll use one called <a href="https://www.tutorialspoint.com/computer_graphics/line_generation_algorithm.htm" data-astro-cid-bi7aps5f="">Digital Differential Analyzer</a><a data-tooltip="" href="https://www.tutorialspoint.com/computer_graphics/line_generation_algorithm.htm" data-astro-cid-bi7aps5f=""><img src="https://www.tutorialspoint.com/images/logo.png" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/><span data-astro-cid-bi7aps5f="">Line Generation Algorithm</span><span data-astro-cid-bi7aps5f="">Line Generation Algorithm - A line connects two points. It is a basic element in graphics. To draw a line, you need two points between which you can draw a line. In the following three algorithms, we refer the one point of line as $X_{0}, Y_{0}$ and the second point of line as $X_{1}, Y_{1}$.</span><span data-astro-cid-bi7aps5f=""><img src="https://www.tutorialspoint.com/favicon.ico" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/><span data-astro-cid-bi7aps5f="">www.tutorialspoint.com/computer_graphics/line_generation_algorithm.htm</span><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"><use href="/icons.svg#share"></use></svg></span></a>. That link explains the steps in detail, so I’ll just skip to the implementation:</p>
<pre><code>  <span>/**
   * Sets pixel under the mouse cursor with the current color.
   * If the user is dragging their cursor, also fills in pixels between the given coordinates and the previous ones.
   * @param x X coordinate of the destination pixel.
   * @param y Y coordinate of the destination pixel.
   */</span>
  <span>#paint</span><span>(</span>x<span>:</span> <span>number</span><span>,</span> y<span>:</span> <span>number</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>x <span>&lt;</span> <span>0</span> <span>||</span> <span>this</span><span>.</span>#artboard<span>.</span>w <span>&lt;=</span> x<span>)</span> <span>return</span><span>;</span>
    <span>if</span> <span>(</span>y <span>&lt;</span> <span>0</span> <span>||</span> <span>this</span><span>.</span>#artboard<span>.</span>h <span>&lt;=</span> y<span>)</span> <span>return</span><span>;</span>

    <span>this</span><span>.</span>#data<span>.</span><span>set</span><span>(</span>x<span>,</span> y<span>,</span> <span>this</span><span>.</span>#color<span>)</span><span>;</span>

    <span>let</span> <span>[</span>x0<span>,</span> y0<span>]</span> <span>=</span> <span>this</span><span>.</span>#prev <span>||</span> <span>[</span>x<span>,</span> y<span>]</span><span>;</span>

    <span>const</span> dx <span>=</span> x <span>-</span> x0<span>,</span>
      dy <span>=</span> y <span>-</span> y0<span>;</span>

    <span>const</span> steps <span>=</span> Math<span>.</span><span>max</span><span>(</span>Math<span>.</span><span>abs</span><span>(</span>dx<span>)</span><span>,</span> Math<span>.</span><span>abs</span><span>(</span>dy<span>)</span><span>)</span><span>;</span>
    <span>const</span> xinc <span>=</span> dx <span>/</span> steps<span>,</span>
      yinc <span>=</span> dy <span>/</span> steps<span>;</span>

    <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> steps<span>;</span> i<span>++</span><span>)</span> <span>{</span>
      x0 <span>+=</span> xinc<span>;</span>
      y0 <span>+=</span> yinc<span>;</span>
      <span>const</span> x1 <span>=</span> Math<span>.</span><span>round</span><span>(</span>x0<span>)</span><span>;</span>
      <span>const</span> y1 <span>=</span> Math<span>.</span><span>round</span><span>(</span>y0<span>)</span><span>;</span>

      <span>this</span><span>.</span>#data<span>.</span><span>set</span><span>(</span>x1<span>,</span> y1<span>,</span> <span>this</span><span>.</span>#color<span>)</span><span>;</span>
    <span>}</span>

    <span>this</span><span>.</span><span>#draw</span><span>(</span><span>)</span><span>;</span>
  <span>}</span></code></pre>
<p>We’re now drawing smooth, connected lines! Check it out:</p>
<pixelart-demo network="off" dedupe="off"></pixelart-demo>

<h3 id="syncing-state">Syncing state</h3>
<p>Finally, we’re ready to connect these two canvases together. Whenever one peer makes a change, we’ll send its state to the other. After that peer’s <code>PixelData</code> CRDT merges the incoming state into its own, both canvases will have converged upon the same state.</p>
<p>You might remember the <code>PixelEditor</code> property <code>#listeners</code> from way back, when we wrote the skeleton of the class. We’re about to put it to use. First, we’ll fill out the <code>onchange</code> setter:</p>
<pre><code>  <span>/**
   * Appends a listener to be called when the state changes.
   * @param listener */</span>
  <span>set</span> <span>onchange</span><span>(</span>listener<span>:</span> <span>(</span>state<span>:</span> PixelData<span>[</span><span>&#34;state&#34;</span><span>]</span><span>)</span> <span>=&gt;</span> <span>void</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>#listeners<span>.</span><span>push</span><span>(</span>listener<span>)</span><span>;</span>
  <span>}</span></code></pre>
<p>This takes an callback function and adds it to <code>#listeners</code>.</p>
<p>Next, we need a way to notify the listeners that the data changed. That method is called <code>#notify</code>:</p>
<pre><code>  <span>/** Notify all listeners that the state has changed. */</span>
  <span>#notify</span><span>(</span><span>)</span> <span>{</span>
    <span>const</span> state <span>=</span> <span>this</span><span>.</span>#data<span>.</span>state<span>;</span>
    <span>for</span> <span>(</span><span>const</span> listener <span>of</span> <span>this</span><span>.</span>#listeners<span>)</span> <span>listener</span><span>(</span>state<span>)</span><span>;</span>
  <span>}</span></code></pre>
<p>It grabs the current state from the <code>PixelData</code> CRDT stored in <code>#data</code>. Then, it iterates through each listener and calls it with that state.</p>
<p>Finally, we need to actually call our <code>#notify</code> method. We’ll nestle that right at the end of <code>#paint</code>, so that any time we change the state we also notify all the listeners:</p>
<pre><code>  <span>/**
   * Sets pixel under the mouse cursor with the current color.
   * If the user is dragging their cursor, also fills in pixels between the given coordinates and the previous ones.
   * @param x X coordinate of the destination pixel.
   * @param y Y coordinate of the destination pixel.
   */</span>
  <span>#paint</span><span>(</span>x<span>:</span> <span>number</span><span>,</span> y<span>:</span> <span>number</span><span>)</span> <span>{</span>
    <span>// ...</span>

    <span>this</span><span>.</span><span>#notify</span><span>(</span><span>)</span><span>;</span>
  <span>}</span></code></pre>
<p>That takes care of the sending. On the other end, we need to merge the data into our local state when we receive it from another peer. This last method is called <code>receive</code>:</p>
<pre><code>  <span>/**
   * Merge remote state with the current state and redraw the canvas.
   * @param state State to merge into the current state. */</span>
  <span>receive</span><span>(</span>state<span>:</span> PixelData<span>[</span><span>&#34;state&#34;</span><span>]</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>#data<span>.</span><span>merge</span><span>(</span>state<span>)</span><span>;</span>
    <span>this</span><span>.</span><span>#draw</span><span>(</span><span>)</span><span>;</span>
  <span>}</span></code></pre>
<p>We’re familiar with this pattern by now: when a CRDT has to merge some state, it sends parts of it to the appropriate CRDTs. In this case, <code>PixelEditor</code> isn’t a CRDT, so we’re just sending the whole thing off to <code>#data</code> to be merged.</p>
<p>And that’s it! Take a look at our two connected pixel art editors.</p>
<pixelart-demo dedupe="off"></pixelart-demo>

<h3 id="fixing-timestamps">Fixing Timestamps</h3>
<p>We’re almost done, but there’s one more optimization I want to make. We know that under the hood, each pixel is a LWW Register, which means it has a timestamp. Peers will compare those timestamps when merging their state.</p>
<p>But right now, if you click and drag around, the timestamps get weirdly high — especially if you go slowly. Here’s a playground with a lower resolution that shows each pixel’s timestamp.</p>
<pixelart-demo resolution="20" dedupe="off" debug="true"></pixelart-demo>

<p>The problem is pointer events can fire a lot — often, multiple times on the same artboard pixel. To solve this, we’ll keep a set of each pixel we’ve painted during a single drag operation, and ensure we don’t change any pixels already in the set.<sup><a href="#user-content-fn-leakyabstraction" id="user-content-fnref-leakyabstraction" data-footnote-ref="" aria-describedby="footnote-label" data-astro-cid-bi7aps5f="">10</a></sup></p>
<p>First, let’s add a set of all the keys we’ve painted to our <code>PixelEditor</code> class:</p>
<pre><code><span>class</span> <span>PixelEditor</span> <span>{</span>
  <span>// ...</span>

  <span>/** The set of pixel keys that have been painted during the current drag operation */</span>
  #painted <span>=</span> <span>new</span> <span>Set<span>&lt;</span><span>string</span><span>&gt;</span></span><span>(</span><span>)</span><span>;</span>

  <span>// ...</span>
<span>}</span></code></pre>
<p>Next, we’ll add a <code>#checkPainted</code> method. It will take an <em>(x,y)</em> coordinate pair and return whether it’s in the set of painted pixels.</p>
<pre><code>  <span>/**
   * Check whether a pixel has been painted during the current drag operation
   * @param x X coordinate of the target pixel.
   * @param y Y coordinate of the target pixel.
   */</span>
  <span>#checkPainted</span><span>(</span>x<span>:</span> <span>number</span><span>,</span> y<span>:</span> <span>number</span><span>)</span> <span>{</span>
    <span>const</span> key <span>=</span> PixelData<span>.</span><span>key</span><span>(</span>x<span>,</span> y<span>)</span><span>;</span>

    <span>const</span> painted <span>=</span> <span>this</span><span>.</span>#painted<span>.</span><span>has</span><span>(</span>key<span>)</span><span>;</span>
    <span>this</span><span>.</span>#painted<span>.</span><span>add</span><span>(</span>key<span>)</span><span>;</span>

    <span>return</span> painted<span>;</span>
  <span>}</span></code></pre>
<p>It also adds the coordinates to the set, so any successive calls to <code>#checkPainted</code> with the same coordinates return <code>true</code>. The order of these statements is important: we need to first check whether the pixel was already painted, then add it to the set, and finally return whether it was in the set <strong>before</strong> we added it.</p>
<p>We’ll use <code>#checkPainted</code> in the <code>#paint</code> method before we set a color for any pixel:</p>
<pre><code>  <span>/**
   * Sets pixel under the mouse cursor with the current color.
   * If the user is dragging their cursor, also fills in pixels between the given coordinates and the previous ones.
   * @param x X coordinate of the destination pixel.
   * @param y Y coordinate of the destination pixel.
   */</span>
  <span>#paint</span><span>(</span>x<span>:</span> <span>number</span><span>,</span> y<span>:</span> <span>number</span><span>)</span> <span>{</span>
    <span>// ...</span>

    <span>if</span> <span>(</span><span>!</span><span>this</span><span>.</span><span>#checkPainted</span><span>(</span>x<span>,</span> y<span>)</span><span>)</span> <span>this</span><span>.</span>#data<span>.</span><span>set</span><span>(</span>x<span>,</span> y<span>,</span> <span>this</span><span>.</span>#color<span>)</span><span>;</span>

    <span>// ...</span>

    <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> steps<span>;</span> i<span>++</span><span>)</span> <span>{</span>
      <span>// ...</span>

      <span>if</span> <span>(</span><span>!</span><span>this</span><span>.</span><span>#checkPainted</span><span>(</span>x1<span>,</span> y1<span>)</span><span>)</span> <span>this</span><span>.</span>#data<span>.</span><span>set</span><span>(</span>x1<span>,</span> y1<span>,</span> <span>this</span><span>.</span>#color<span>)</span><span>;</span>
    <span>}</span>
  <span>}</span></code></pre>
<p>Finally, on the <code>pointerup</code> event, just as we reset <code>#prev</code>, we also need to reset <code>#painted</code>:</p>
<pre><code>  <span>/**
   * Handles events on the canvas.
   * @param e Pointer event from the canvas element.
   */</span>
  <span>handleEvent</span><span>(</span>e<span>:</span> PointerEvent<span>)</span> <span>{</span>
    <span>switch</span> <span>(</span>e<span>.</span>type<span>)</span> <span>{</span>
			<span>// ...</span>

      <span>case</span> <span>&#34;pointerup&#34;</span><span>:</span> <span>{</span>
				<span>// ...</span>
        <span>this</span><span>.</span>#painted<span>.</span><span>clear</span><span>(</span><span>)</span><span>;</span>
        <span>break</span><span>;</span>
      <span>}</span>
    <span>}</span>
  <span>}</span></code></pre>
<p>Now, each pixel’s timestamp will be incremented by at most 1 during each drag:</p>
<pixelart-demo resolution="20" debug="true"></pixelart-demo>

<h3 id="the-end">The End!</h3>
<p>We made it! We have a completed collaborative pixel art editor, built with CRDTs. Take a look at what we’ve built and give yourself a pat on the back.</p>
<pixelart-demo></pixelart-demo>

<p>If you’d like to play with this on your own, I’ve made a <a href="https://codesandbox.io/s/crdt-pixel-art-editor-s6f9fh" data-astro-cid-bi7aps5f="">CodeSandbox with everything we’ve written here</a><a data-tooltip="" href="https://codesandbox.io/s/crdt-pixel-art-editor-s6f9fh" data-astro-cid-bi7aps5f=""><img src="https://codesandbox.io/api/v1/sandboxes/s6f9fh/screenshot.png" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/><span data-astro-cid-bi7aps5f="">crdt-pixel-art-editor - CodeSandbox</span><span data-astro-cid-bi7aps5f="">A toy collaborative pixel art editor, built with CRDTs.</span><span data-astro-cid-bi7aps5f=""><img src="data:image/svg+xml;utf8,%3Csvg%20xmlns=&#39;http:/www.w3.org/2000/svg&#39;%20viewBox=&#39;0%200%20100%20100&#39;%3E%3Cstyle%3Esvg%20%7Bbackground:%20transparent;%7Dpath%20%7Bfill:%20black;%7D@media%20(prefers-color-scheme:%20dark)%20%20%7Bpath%20%7Bfill:%20white;%7D%7D%3C/style%3E%3Cpath%20fill-rule=&#39;evenodd&#39;%20clip-rule=&#39;evenodd&#39;%20d=&#39;M81.8182%2018.1818V81.8182H18.1818V18.1818H81.8182ZM10%2090V10H90V90H10Z&#39;/%3E%3C/svg%3E" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/><span data-astro-cid-bi7aps5f="">codesandbox.io/s/crdt-pixel-art-editor-s6f9fh</span><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"><use href="/icons.svg#share"></use></svg></span></a>. Fork it and make something cool!</p>
<h3 id="reading-list">Reading List</h3>
<p>Hopefully these posts have made you interested in learning even more about CRDTs! Here’s a list of articles I leaned on heavily to write this one:</p>

<section data-footnotes="">
<ol>
<li id="user-content-fn-canvas">
<p>Familiarity with the browser’s <a href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial" data-astro-cid-bi7aps5f="">2D canvas API</a><a data-tooltip="" href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial" data-astro-cid-bi7aps5f=""><img src="https://developer.mozilla.org/mdn-social-share.cd6c4a5a.png" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/><span data-astro-cid-bi7aps5f="">Canvas tutorial - Web APIs | MDN</span><span data-astro-cid-bi7aps5f="">This tutorial describes how to use the &lt;canvas&gt; element to draw 2D graphics, starting with the basics. The examples provided should give you some clear ideas about what you can do with canvas, and will provide code snippets that may get you started in building your own content.</span><span data-astro-cid-bi7aps5f=""><img src="https://developer.mozilla.org/favicon-48x48.cbbd161b.png" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/><span data-astro-cid-bi7aps5f="">developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial</span><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"><use href="/icons.svg#share"></use></svg></span></a> will help when we get to the internals of the pixel art editor. But it’s not required to understand how the CRDT works or how it’s used in the app. Think of it as extra credit. <a href="#user-content-fnref-canvas" data-footnote-backref="" class="data-footnote-backref" aria-label="Back to content" data-astro-cid-bi7aps5f="">↩</a></p>
</li>
<li id="user-content-fn-chonky">
<p>Sorry about the huge pixels. I didn’t want the page to get too long as the maps below fill out. <a href="#user-content-fnref-chonky" data-footnote-backref="" class="data-footnote-backref" aria-label="Back to content" data-astro-cid-bi7aps5f="">↩</a></p>
</li>
<li id="user-content-fn-hex">
<p>Hex codes are actually just RGB colors encoded in base 16 (hexadecimal). Every two letters of a hex code combine to form one byte. <code>#845ef7</code> can be split into <code>84</code> (red), <code>5e</code> (green) and <code>f7</code> (blue), which works out to <code>132</code>, <code>94</code> and <code>247</code> in base 10 (decimal, or “normal” numbers). <a href="#user-content-fnref-hex" data-footnote-backref="" class="data-footnote-backref" aria-label="Back to content" data-astro-cid-bi7aps5f="">↩</a></p>
</li>
<li id="user-content-fn-network">
<p>The examples in this article simulate network latency by wrapping each <code>receive</code> call in a <code>setTimeout</code>. If you want to actually wire up this pixel art editor to the network, you can connect two peers using something like <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSocket" data-astro-cid-bi7aps5f="">WebSockets</a><a data-tooltip="" href="https://developer.mozilla.org/en-US/docs/Web/API/WebSocket" data-astro-cid-bi7aps5f=""><img src="https://developer.mozilla.org/mdn-social-share.cd6c4a5a.png" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/><span data-astro-cid-bi7aps5f="">WebSocket - Web APIs | MDN</span><span data-astro-cid-bi7aps5f="">The WebSocket object provides the API for creating and managing a WebSocket connection to a server, as well as for sending and receiving data on the connection.</span><span data-astro-cid-bi7aps5f=""><img src="https://developer.mozilla.org/favicon-48x48.cbbd161b.png" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/><span data-astro-cid-bi7aps5f="">developer.mozilla.org/en-US/docs/Web/API/WebSocket</span><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"><use href="/icons.svg#share"></use></svg></span></a> or <a href="https://webrtc.org/" data-astro-cid-bi7aps5f="">WebRTC</a><a data-tooltip="" href="https://webrtc.org/" data-astro-cid-bi7aps5f=""><img src="https://www.gstatic.com/devrel-devsite/prod/v0f868bacf787bf31b228952b4e9f9c852485b2025a1f6f6571309b6d62ea4de2/webrtc/images/lockup.svg" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/><span data-astro-cid-bi7aps5f="">WebRTC</span><span data-astro-cid-bi7aps5f="">An open framework for the web that enables Real-Time Communications (RTC) capabilities in the browser.
</span><span data-astro-cid-bi7aps5f=""><img src="https://www.gstatic.com/devrel-devsite/prod/v0f868bacf787bf31b228952b4e9f9c852485b2025a1f6f6571309b6d62ea4de2/webrtc/images/favicon.png" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/><span data-astro-cid-bi7aps5f="">webrtc.org/</span><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"><use href="/icons.svg#share"></use></svg></span></a>. Because we’re using a state-based CRDT, the communication protocol is simple: serialize each state to a JSON string before sending it, and parse it back into a JS object when receiving it. <a href="#user-content-fnref-network" data-footnote-backref="" class="data-footnote-backref" aria-label="Back to content" data-astro-cid-bi7aps5f="">↩</a></p>
</li>
<li id="user-content-fn-dpi">
<p>This also handles high resolution displays, in which case the physical monitor pixels might not be equivalent to “logical” canvas pixels on screen — which themselves might not be equivalent to our artboard pixels. Confused? Resizing is tricky, and there’s even a bit more to it, but I didn’t want to get too down in the weeds in this tutorial. If you’re curious, you can <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/devicePixelRatio" data-astro-cid-bi7aps5f="">read the docs on MDN</a><a data-tooltip="" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/devicePixelRatio" data-astro-cid-bi7aps5f=""><img src="https://developer.mozilla.org/mdn-social-share.cd6c4a5a.png" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/><span data-astro-cid-bi7aps5f="">Window: devicePixelRatio property - Web APIs | MDN</span><span data-astro-cid-bi7aps5f="">The devicePixelRatio of
  Window interface returns the ratio of the resolution in physical
pixels to the resolution in CSS pixels for the current display
  device.</span><span data-astro-cid-bi7aps5f=""><img src="https://developer.mozilla.org/favicon-48x48.cbbd161b.png" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/><span data-astro-cid-bi7aps5f="">developer.mozilla.org/en-US/docs/Web/API/Window/devicePixelRatio</span><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"><use href="/icons.svg#share"></use></svg></span></a>; if not, you can think of this as a magic incantation that makes the pixels look crisp. <a href="#user-content-fnref-dpi" data-footnote-backref="" class="data-footnote-backref" aria-label="Back to content" data-astro-cid-bi7aps5f="">↩</a></p>
</li>
<li id="user-content-fn-badidearight">
<p>Usually, falling through a switch case is a bug. In this case, we really do want to do it, which is why there’s a <code>// fallthrough</code> comment at the end to make it explicit. The <code>// @ts-expect-error</code> at the top suppresses a TypeScript error if you’ve <a href="https://www.typescriptlang.org/tsconfig#noFallthroughCasesInSwitch" data-astro-cid-bi7aps5f="">configured it to report errors for fallthrough cases in switch statements</a><a data-tooltip="" href="https://www.typescriptlang.org/tsconfig#noFallthroughCasesInSwitch" data-astro-cid-bi7aps5f=""><span data-astro-cid-bi7aps5f="">TSConfig Reference - Docs on every TSConfig option</span><span data-astro-cid-bi7aps5f="">From allowJs to useDefineForClassFields the TSConfig reference includes information about all of the active compiler flags setting up a TypeScript project.</span><span data-astro-cid-bi7aps5f=""><img src="https://www.typescriptlang.org/favicon-32x32.png#noFallthroughCasesInSwitch" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/><span data-astro-cid-bi7aps5f="">www.typescriptlang.org/tsconfig#noFallthroughCasesInSwitch</span><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"><use href="/icons.svg#share"></use></svg></span></a> (which you should). <a href="#user-content-fnref-badidearight" data-footnote-backref="" class="data-footnote-backref" aria-label="Back to content" data-astro-cid-bi7aps5f="">↩</a></p>
</li>
<li id="user-content-fn-optimization">
<p>We’re leaving some performance on the table here by allocating a new buffer every time we call this function. Really, we should pre-allocate the buffer as soon as we know the artboard size and reuse it in every <code>#draw</code> call. <a href="#user-content-fnref-optimization" data-footnote-backref="" class="data-footnote-backref" aria-label="Back to content" data-astro-cid-bi7aps5f="">↩</a></p>
</li>
<li id="user-content-fn-canvasstuff">
<p>The last three lines are pretty idiosyncratic to the JavaScript canvas API, so I’ll just refer you to the MDN documentation for <a href="https://developer.mozilla.org/en-US/docs/Web/API/ImageData" data-astro-cid-bi7aps5f=""><code>ImageData</code></a><a data-tooltip="" href="https://developer.mozilla.org/en-US/docs/Web/API/ImageData" data-astro-cid-bi7aps5f=""><img src="https://developer.mozilla.org/mdn-social-share.cd6c4a5a.png" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/><span data-astro-cid-bi7aps5f="">ImageData - Web APIs | MDN</span><span data-astro-cid-bi7aps5f="">The ImageData interface represents the underlying pixel data of an area of a &lt;canvas&gt; element.</span><span data-astro-cid-bi7aps5f=""><img src="https://developer.mozilla.org/favicon-48x48.cbbd161b.png" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/><span data-astro-cid-bi7aps5f="">developer.mozilla.org/en-US/docs/Web/API/ImageData</span><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"><use href="/icons.svg#share"></use></svg></span></a>, <a href="https://developer.mozilla.org/en-US/docs/Web/API/CreateImageBitmap" data-astro-cid-bi7aps5f=""><code>createImageBitmap</code></a><a data-tooltip="" href="https://developer.mozilla.org/en-US/docs/Web/API/CreateImageBitmap" data-astro-cid-bi7aps5f=""><img src="https://developer.mozilla.org/mdn-social-share.cd6c4a5a.png" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/><span data-astro-cid-bi7aps5f="">createImageBitmap() global function - Web APIs | MDN</span><span data-astro-cid-bi7aps5f="">The createImageBitmap() method creates a bitmap from a
  given source, optionally cropped to contain only a portion of that source. The method
  exists on the global scope in both windows and workers. It accepts a variety of
  different image sources, and returns a Promise which resolves to an
  ImageBitmap.</span><span data-astro-cid-bi7aps5f=""><img src="https://developer.mozilla.org/favicon-48x48.cbbd161b.png" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/><span data-astro-cid-bi7aps5f="">developer.mozilla.org/en-US/docs/Web/API/CreateImageBitmap</span><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"><use href="/icons.svg#share"></use></svg></span></a> and <a href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage" data-astro-cid-bi7aps5f=""><code>drawImage</code></a><a data-tooltip="" href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage" data-astro-cid-bi7aps5f=""><img src="https://developer.mozilla.org/mdn-social-share.cd6c4a5a.png" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/><span data-astro-cid-bi7aps5f="">CanvasRenderingContext2D: drawImage() method - Web APIs | MDN</span><span data-astro-cid-bi7aps5f="">The CanvasRenderingContext2D.drawImage() method of the
  Canvas 2D API provides different ways to draw an image onto the canvas.</span><span data-astro-cid-bi7aps5f=""><img src="https://developer.mozilla.org/favicon-48x48.cbbd161b.png" alt="" onerror="this.remove()" data-astro-cid-bi7aps5f=""/><span data-astro-cid-bi7aps5f="">developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage</span><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"><use href="/icons.svg#share"></use></svg></span></a>. <a href="#user-content-fnref-canvasstuff" data-footnote-backref="" class="data-footnote-backref" aria-label="Back to content" data-astro-cid-bi7aps5f="">↩</a></p>
</li>
<li id="user-content-fn-fallthrough">
<p>Remember that the <code>pointerdown</code> case also falls through to <code>pointermove</code>. <a href="#user-content-fnref-fallthrough" data-footnote-backref="" class="data-footnote-backref" aria-label="Back to content" data-astro-cid-bi7aps5f="">↩</a></p>
</li>
<li id="user-content-fn-leakyabstraction">
<p>Remember when I said that the app “mostly” doesn’t realize it’s using a CRDT under the hood? This is an example of the abstraction leaking through. If we were just writing pixel data and didn’t care about the timestamps, we wouldn’t have to bother with this step. <a href="#user-content-fnref-leakyabstraction" data-footnote-backref="" class="data-footnote-backref" aria-label="Back to content" data-astro-cid-bi7aps5f="">↩</a></p>
</li>
</ol>
</section></div></div>
  </body>
</html>
