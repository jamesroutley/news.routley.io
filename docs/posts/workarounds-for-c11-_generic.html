<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.chiark.greenend.org.uk/~sgtatham/quasiblog/c11-generic/">Original</a>
    <h1>Workarounds for C11 _Generic()</h1>
    
    <div id="readability-page-1" class="page">
    
    <p>[Simon Tatham, 2023-07-29]</p>
    <ul>
      <li>
        <a href="#intro">Introduction</a>
      </li>
      <li>
        <a href="#bigbug">The big bug</a>
      </li>
      <li>
        <a href="#thoughts">Thoughts on the failure</a>
        <ul>
          <li>
            <a href="#who">Whose bug is this?</a>
          </li>
          <li>
            <a href="#how">How did this happen?</a>
          </li>
          <li>
            <a href="#how">How was this not noticed?</a>
          </li>
        </ul>
      </li>
      <li>
        <a href="#inline">Inline-functions workaround</a>
        <ul>
          <li>
            <a href="#not-good-enough">Cases where this doesn’t help</a>
          </li>
        </ul>
      </li>
      <li>
        <a href="#coercion">Type coercion using a secondary <code>_Generic</code></a>
      </li>
      <li>
        <a href="#arrayhack">Type tuples using a multidimensional array</a>
      </li>
      <li>
        <a href="#defaultchain">Chaining one <code>_Generic</code> as the default of another</a>
      </li>
      <li>
        <a href="#remainingproblems">Remaining problems</a>
      </li>
      <li>
        <a href="#conclusion">Conclusion</a>
      </li>
    </ul>
    <h2 id="intro">Introduction</h2>
    <p>The C programming language has a limited form of type-generic
      programming, based on ‘selection expressions’ using the
      keyword <code>_Generic</code>. These expressions look a bit like
      a <code>switch</code>, but on types rather than values: based on
      the type of their first argument, they select one of the
      remaining arguments, each of which is of the form ‘type: output
      expression’.</p>
    <p>Usually you put these in macro definitions, so that
      they can make the macro test the type of one of its parameters
      and do the right thing for more than one possible answer:</p>
    <pre>#define my_macro(x, y) _Generic(x,                \
    int            : <em>some expression</em>,             \
    double         : <em>some other expression</em>,       \
    struct Whatnot : <em>something else again</em>,        \
    default        : <em>fallback expression</em>)</pre>
    <p>You can include a <code>default</code> clause that matches all
      remaining types, as shown above. Or you can leave it out, so
      that your macro will generate a compile error rather than try to
      operate on a type it isn’t designed to handle.</p>
    <p><code>_Generic</code> was introduced in the C11 revision of the
      standard. The previous revision, C99, had introduced one
      specific set of type-generic macros
      in <code>&lt;tgmath.h&gt;</code> (for selecting the right
      version of a maths function for the particular floating point
      type – <code>float</code> vs <code>double</code>, real vs
      complex). But it had provided no specification for the
      underlying system for making choices, so that programmers
      couldn’t reuse the same facility for similar cases of their own.
      C11 filled in this gap, by standardising <code>_Generic</code>,
      which can be used to implement <code>&lt;tgmath.h&gt;</code> and
      things like it.</p>
    <p>Once you have a reusable type-generic facility in C, there
      are <em>lots</em> of things you can imagine using it for.</p>
    <p>As a simple example, suppose you have a structure type of your
      own that stores a string in some kind of allocated buffer. You
      might want to write a ‘string length’ macro that automatically
      chooses between returning <code>strlen(x)</code> (if it’s an
      ordinary C string) or <code>x-&gt;length</code> (if it’s an
      instance of your buffer structure).</p>
    <p>More complicated examples might involve having a macro that
      switches its output based on the types of <em>two</em> of its
      parameters, or one that accepts an open-ended set of types by
      providing a <code>default</code> clause. (In a following section
      I’ll show an example that’s the reverse of this ‘string length’
      one, in which we want to pull out a named field
      from <em>lots</em> of structure types, and make only one
      exception.)</p>
    <p>Unfortunately, this kind of thing isn’t as easy as it looks!
      The specification of <code>_Generic</code> has a huge bug (from
      the point of view of someone wanting to use it for lots of
      different things). It doesn’t affect the original use case
      of <code>&lt;tgmath.h&gt;</code>, but it starts to cause
      problems with <em>most</em> of the more complicated use cases
      you might think of.</p>
    <p>In this article, I describe the bug, and multiple possible
      workarounds. But none of them is perfect, and even after you’ve
      used the workarounds, the results still won’t be very good.</p>

    <h2 id="bigbug">The big bug</h2>
    <p>Here’s the big problem with <code>_Generic</code>.</p>
    <p>Depending on the type of the selection argument, one of the
      output expressions will be selected at compile time, and the
      rest will be thrown away completely, and generate no
      code. <strong>But the discarded expressions still have to be
      semantically valid</strong> – they have to get through all of
      the same checking the compiler would apply to any other C
      expression, including type-checking successfully.</p>
    <p>For example, here’s how we might implement the ‘string length’
      macro mentioned in the previous section, which provides a
      uniform way to find the length of two different string types, by
      deciding whether to call the standard C <code>strlen</code> or
      look up a structure field:</p>
    <pre>#define string_length_broken(x) _Generic(x,        \
    const char *            : strlen(x),           \
    struct MyStringBuffer * : (x)-&gt;length)</pre>
    <p>This looks clear and simple. It might even have been one of the
      first kinds of idea you had, if you’d sat down and wondered
      “What useful things could I do with a spot of type-based
      selection in C?”</p>
    <p>But it won’t work. As soon as you actually try calling this
      macro with a <code>const char *</code> parameter pointing to an
      ordinary C string, you’ll get a compile error, because the
      expression <code>x-&gt;length</code> is illegal, because the
      type <code>char</code> isn’t a structure type with
      a <code>length</code> field.</p>
    <p>Of course, you <em>know</em> that! That’s <em>why</em> you
      wrote an alternative branch of the <code>_Generic</code>
      expression: in this case, where you
      knew <code>x-&gt;length</code> wouldn’t work, you wanted to
      use <code>strlen(x)</code> instead. But unfortunately, even
      though <code>_Generic</code> would end up <em>selecting</em>
      the <code>strlen</code> expression, it will still fail to
      compile because the <em>other</em> branch isn’t semantically
      valid.</p>
    <p>This is likely to affect <em>almost any</em> use
      of <code>_Generic</code> that reuses the macro parameter inside
      any of the expressions being selected, because it’s so likely
      that the use of the parameter in one branch of the selection
      will become illegal if the parameter has the type from another
      branch. So it <em>severely</em> restricts what you can do
      with <code>_Generic</code>, at least if you do it in the obvious
      way.</p>
    <p>It doesn’t just affect reusing the <em>same</em> macro
      parameter, either. Here’s a different example: suppose you have
      a macro with two parameters, and you want to switch on the types
      of both of them at once, with not all combinations of types
      legal. You’d expect that this would be possible by
      nesting <code>_Generic</code>s, and for each type of one
      argument, having a sub-switch on whatever types for the other
      argument go with it. For example:</p>
    <pre>#define switch_on_both_types(x,y) _Generic(x,                      \
    const char * : _Generic(y, int : <i>this</i>, const char * : <i>that</i>),   \
    struct Foo * : _Generic(y, int : <i>this</i>, struct Bar * : <i>that</i>))</pre>
    <p>This code is intended to accept two types for
      argument <code>x</code>, namely <code>const char *</code>
      and <code>struct Foo *</code>. For either type
      of <code>x</code>, it will accept an <code>int</code> for
      argument <code>y</code>, but it also wants to let you combine
      a <code>const char *x</code> with another <code>const char
      *y</code>, or a <code>struct Foo *x</code> with a <code>struct Bar
      *y</code>, but not <em>vice versa</em>.</p>
    <p>But again, it doesn’t work – not even if the output expressions
      are as simple as possible and don’t mention <code>x</code>
      or <code>y</code> at all.</p>
    <p>Why not? For the same reason again: a compile error
      in <em>either</em> branch is fatal, even if it’s the branch not
      selected. So, suppose I call this macro with types <code>struct
      Foo *</code> and <code>struct Bar *</code>, expecting the second
      branch of the outer <code>_Generic</code> to be selected. But
      the subsidiary <code>_Generic</code> in the <em>first</em>
      branch will cause a compile error, because that’s switching on
      the type of argument <code>y</code>, and <code>struct Bar
      *</code> isn’t in its list of acceptable types.</p>

    <h2 id="thoughts">Thoughts on the failure</h2>

    <p>When this first happened to me, it was a complete surprise. I
      thought the wrong branch of the <code>_Generic</code> must have
      been selected by mistake. It took me a long time to
      even <em>think</em> of the possibility that the compile error
      from the unwanted branch was happening <em>even though</em> it
      wasn’t selected!</p>
    <p>Even after I decided that that must be the answer, I couldn’t
      quite believe it. To my way of thinking, one of the
      main <em>reasons</em> you’d want to select at compile time
      between several alternative pieces of code was <em>because</em>
      not all of them would be legal, and you wanted to pick the one
      that was!</p>

    <h3 id="who">Whose bug is this?</h3>

    <p>Perhaps this was just a bug in the particular compiler I
      happened to try this with?</p>
    <p>I don’t think so, because <em>every</em> compiler I’ve tried
      agrees that this is how it works. Unless you want to believe
      that multiple completely independent C compilers all managed to
      have an identical <em>enormous</em> bug, the only other option
      is that they did it on purpose, because they agree that this was
      the genuine intent of the standard.</p>
    <p>But that seemed unlikely <em>too</em>, so I went and checked
      the standard myself.</p>
    <p>It’s not quite as unambiguous as you’d like
      it to be. C11 §6.5.1 clause 3 says that the unselected
      expressions are not <em>evaluated</em>, meaning they do not
      cause any code to be executed at run time, but it doesn’t say
      whether they should still be checked at compile time for
      semantic validity.</p>
    <p>But here’s the thing: nothing <em>else</em> in C has the
      syntactic form of an expression, without the requirement to be
      semantically valid. (Unlike C++, where it happens all the time
      in template-related contexts.) So if the unselected branches
      of <code>_Generic</code> <em>didn’t</em> have to be valid, then
      they’d be the only kind of expression with that property in the
      whole of C, and so I’d expect the standard to call them out
      explicitly as an exception to the usual rule. It does not.</p>
    <p>So, if all those compilers think the intent of the standard is
      that even the untaken branches of <code>_Generic</code> have to
      be semantically valid, then I can’t disagree with them. If I’m
      going to complain about anything, it has to be the standard
      itself!</p>

    <h3 id="how">How did this happen?</h3>

    <p>The C standards working group (WG14) doesn’t just publish the
      final standard. It also publishes records of the process leading
      to the standard: proposals, arguments for and against, minutes
      of meetings, etc. So you can at least try to find
      out <em>why</em> a decision was made a particular way, by
      looking in those documents.</p>
    <p>According to
      the <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1404.htm">original
      proposal</a>, the idea for <code>_Generic</code> originated in a
      GCC language extension feature – or rather, multiple
      features:</p>
    <ul>
      <li><code>__typeof</code> takes an expression and gives you its
        type</li>
      <li><code>__builtin_types_compatible_p</code> takes two type
        names and tells you if they’re compatible (returning a
        boolean).</li>
      <li><code>__builtin_choose_expr</code> is like a compile-time
        version of the <code>?:</code> ternary operator: depending on
        its first argument, it returns either its second or third. But
        unlike <code>?:</code>, it requires the first argument to be a
        compile-time constant, so that the unselected branch is not
        emitted as code at all, and so that the two output arguments
        can have incompatible types.</li>
    </ul>
    <p>The GCC
      manual <a href="https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html#index-_005f_005fbuiltin_005fchoose_005fexpr">gives
      an example</a> of using these features together to implement
      type-based selection, by
      making <code>__builtin_choose_expr</code>’s controlling
      expression the result of
      a <code>__builtin_types_compatible_p</code> test which
      checks <code>__typeof(parameter)</code> against a known type
      (and then maybe chaining multiple such tests via their ‘else’
      operand).</p>
    <p>WG14 apparently found that cumbersome (fair enough!), and
      instead provided a single syntax to do the whole job, adding the
      ability to give a whole list of type associations instead of
      just one.</p>
    <p>So the next question is, did the WG introduce the actual bug?
      Or does GCC’s original <code>__builtin_choose_expr</code> also
      insist on semantic validity of both its potential output
      expressions?</p>
    <p>The latter, it turns out – if you try to do type-based
      selection using GCC’s builtins, you find exactly the same problem:</p>
    <pre>#define demo(x) __builtin_choose_expr(                        \
    __builtin_types_compatible_p(__typeof(x), struct Foo *),  \
    (x)-&gt;field_of_struct_foo,                                 \
    -1)</pre>
    <p>Just as before, we’re trying to pull out a field from a
      particular structure type if we’re given one, and fall back to a
      default return value of −1 otherwise. But you see exactly the
      same problem if you evaluate, say, <code>demo(42)</code>:</p>
    <pre>test.c:5:8: error: invalid type argument of ‘-&gt;’ (have ‘int’)
    5 |     (x)-&gt;field_of_struct_foo,                                 \
      |        ^~
test.c:8:27: note: in expansion of macro ‘demo’
    8 | int thing(int f) { return demo(42); }
      |                           ^~~~</pre>
    <p>So GCC’s original design has the same limitation – WG14 didn’t
      introduce it.</p>
    <p>The really curious thing is that I didn’t find <em>any</em>
      discussion in the WG14 proposal of the question I’m addressing
      here. I was expecting to find that they had carefully considered
      the question “Should <code>_Generic</code> require even its
      unselected output expressions to be semantically valid?”,
      weighed up the pros and cons, and decided the answer was yes
      (for some reason that I currently can’t imagine, but would have
      been very interested to find out). But instead,
      it <em>looks</em> as if nobody even considered it at all.</p>

    <h3 id="how">How was this not noticed?</h3>

    <p>There are a lot of things you might want to do
      with <code>_Generic</code> which are prevented by this design
      feature. But it <em>does</em> work for the one case it was
      originally meant for: selecting between a family of related
<code>&lt;math.h&gt;</code> and <code>&lt;complex.h&gt;</code>
      functions, such
      as <code>sin()</code>, <code>sinf()</code>, <code>sinl()</code>, <code>csin()</code>, <code>csinf()</code>
      and <code>csinl()</code>, so that the user you can just
      write <code>sin()</code> every time, and the compiler will
      figure it out for you.</p>
    <p>This works because you only need to select between
      the <em>functions</em>, not the whole <em>function call
        expressions</em>. In other words, instead of writing this ...</p>
    <pre>#define dangerous(x) _Generic(x, \
    this_type : this_fn<strong>(x)</strong>, \
    that_type : that_fn<strong>(x)</strong>)</pre>
    <p>... you instead write this, which puts the call
      operation <em>outside</em> the <code>_Generic</code>, and the only
      thing inside it is function names:</p>
    <pre>#define safer(x) _Generic(x, \
    this_type : this_fn, \
    that_type : that_fn) <strong>(x)</strong></pre>
    <p>With the first form, the <code>x</code> you provide will be
      type-checked against <em>both</em> functions, and there will be a
      compile error if it isn’t compatible with either one. So
      if <code>this_fn</code> can’t take a value
      of <code>that_type</code>, or <em>vice versa</em>, then the macro
      won’t do its job.</p>
    <p>But with the second form, the function name isn’t type-checked
      against its argument until <em>after</em>
      the <code>_Generic</code> has decided which function it is. And
      each branch of the <code>_Generic</code> is a semantically valid
      C expression by itself, regardless of the type
      of <code>x</code>, because it doesn’t mention <code>x</code> at
      all – it’s just a bare function name, fixed at compile time. So
      this version works.</p>
    <p>(I suppose it’s <em>possible</em> that, in this mode of use,
      it’s mildly <em>useful</em> to have the compiler check all the
      possible output expressions, rather than only the selected one?
      If the output expressions are independent of the type-variable
      input that might make them illegal, then they <em>should</em>
      all be legal, and in that case, it’s better to detect a mistake
      in one as soon as possible, without having to wait until you
      actually exercise the faulty branch. For example, in this case,
      if you misspelled one of the possible function names, you’d get
      an error whether you’d tried to use that branch or not. But this
      still seems like a small consideration next to the huge number
      of useful things you could do if the feature worked the more
      permissive way. And, as I say in the previous section, I found
      no evidence that <code>_Generic</code> works this way on purpose
      for the sake of any specific advantage, including this one.)</p>

    <h2 id="inline">Inline-functions workaround</h2>

    <p>In the previous section, I describe the one mode of use
      of <code>_Generic</code> that <em>isn’t</em> inconvenienced by
      the requirement for all the output expressions to be valid.</p>
    <p>So an obvious workaround is: <em>write your own generic
        expressions in that form if you possibly can.</em> Then they
      should work, for the same reason
      that <code>&lt;tgmath.h&gt;</code> works.</p>
    <p>For example, instead of this example from a previous section ...</p>
    <pre>#define string_length_broken(x) _Generic(x,        \
    const char *            : strlen(x),           \
    struct MyStringBuffer * : (x)-&gt;length)</pre>
    <p>... we could write this:</p>
    <pre>static inline size_t mystrbuf_len(struct MyStringBuffer *msb)
{
    return msb-&gt;length;
}

#define string_length_fixed(x) _Generic(x,         \
    const char *            : strlen,              \
    struct MyStringBuffer * : mystrbuf_len) (x)</pre>
    <p>This version of the string-length macro is just selecting a
      function name, in exactly the same way as
      the <code>&lt;tgmath.h&gt;</code> selector macros do. And the
      function isn’t applied to <code>x</code> until after
      the <code>_Generic</code> has finished selecting one of its
      branches and thrown the rest away. So it never matters
      that <code>strlen</code> can’t accept a <code>struct
      MyStringBuffer *</code>, or that the <code>mystrbuf_len</code>
      function I’ve defined here can’t accept a <code>const char
      *</code>. This version of the macro will never need them to.</p>
    <p>It’s wordier than the first version, and (I think) less
      readable, because it’s less self-contained. But at least it
      works.</p>

    <h3 id="not-good-enough">Cases where this doesn’t help</h3>

    <p>This inline-functions workaround only works in cases where
      every branch of the generic <em>can</em> be written as a
      function call. But there are lots of reasons why that might not
      be true.</p>
    <p>One reason is if you want to do something non-trivial in
      the <em>default</em> clause of the generic expression. Then that
      clause has to match more than one input type, so you probably
      can’t write a C function that has a general enough type signature.</p>
    <p>As I mentioned in the introduction, an example case of this is
      if you want to pull out a named structure field from an open-ended set of
      <em>different</em> structure types. You might do this in order
      to treat them all as different implementations of the same
      ‘interface’ or ‘trait’. Say, you might have lots of structure
      types contain a <code>struct Foo foo</code> field, and then have
      a macro that would take an object of any of those types and
      operate on <code>obj-&gt;foo</code>.</p>
    <p>You don’t even need a <code>_Generic</code> to do that much.
      But suppose you also want the same macro to handle <code>struct
      Foo</code> <em>itself</em>, for the case where a function is
      already operating on a <em>generic</em> instance of the trait
      rather than a specific type of implementing object?</p>
    <p>So we’d like to write code along these lines, analogous to the
    ‘broken’ version of the previous <code>string_length</code>
    example:</p>
    <pre>#define foo_upcast_broken(x) _Generic(x,  \
    struct Foo * : (x),                   \
    default      : &amp;(x)-&gt;foo)</pre>
    <p>which responds to the one special case of a <code>struct
        Foo</code> pointer by just returning the pointer itself, and in
      all <em>other</em> cases, assumes you’ve passed it the address of
      a structure containing a <code>struct Foo foo</code>, and extracts
      a pointer to that.</p>
    <p>Of course, this won’t work, for the same reason
      that <code>string_length_broken</code> didn’t work: in the case
      where <code>x</code> has type <code>struct Foo *</code>,
      the <em>default</em> clause will turn out not to be semantically
      valid, because <code>struct Foo</code> doesn’t itself have a field
      of type <code>foo</code>.</p>
    <p>(In this example, you could work around that in turn by
      just <em>adding</em> one: give <code>struct Foo</code> a dummy
      member called <code>foo</code> of any type you like, simply to
      make the default branch of this <code>_Generic</code> happy. But
      in a more complicated case, where the expression in the default
      branch also needed <code>x-&gt;foo</code> to have the
      <em>right</em> type, even that wouldn’t help.)</p>
    <p>This workaround also doesn’t help with the other case shown
      above, of selecting based on two argument types by nesting a
      different <code>_Generic(y, ...)</code> within each branch of
      the outer <code>_Generic(x, ...)</code>. There’s no way to turn
      each of <em>those</em> generics into a function call.</p>
    <p>Here are some other cases I’ve seen which would prevent you
      from converting one (or all) of your output expressions into a
      function call:</p>
    <ul>
      <li>depending on the input type, the output expression might
          need to <em>not evaluate</em> a macro parameter (e.g. to
          avoid its side effects). Then the parameter must be included
          in the branches that <em>do</em> need it.</li>
      <li>in low-level work, the output expression might need to select
        between things that <em>look</em> like function calls but are
        really magic compiler builtins, in which case the compiler
        won’t let you use their names by themselves in
        the <code>_Generic</code>, because a compiler builtin name is
        often not a valid expression by itself. So you have to write
        the parameters right next to the builtin name, i.e. right
        inside the <code>_Generic</code>.</li>
      <li>in even lower-level work, the output expression might need
        to stringify one of the macro parameters and paste it into a
        GCC-style <code>asm</code> expression as an immediate operand
        to a machine instruction. Then the <code>asm</code> expression
        can’t be wrapped in a function.</li>
    </ul>
    <p>I’m sure there are more cases I haven’t thought of. The point
      is: this inline-functions workaround is the best
      thing <em>if</em> you can do it, but there are lots of reasons
      you can’t always do it.</p>

    <h2 id="coercion">Type coercion using a secondary <code>_Generic</code></h2>

    <p>Here’s an alternative workaround which can work in cases where
      the inline functions approach doesn’t.</p>
    <p>Within each output expression of the
      main <code>_Generic</code>, if you need to refer to a macro
      parameter whose type you’re switching on, you can force it to
      have a type appropriate to that particular output expression by
      means of wrapping it in a secondary instance
      of <code>_Generic</code>.</p>
    <p>How do you force it to have an appropriate type? By checking if
      it already does have that type, and if not, replacing it
      completely with some completely made-up expression
      that <em>does</em> have the type you want.</p>
    <p>The made-up alternative expression is selected to have the
      right <em>type</em>, so that the semantic checks on this branch
      of the <code>_Generic</code> won’t fail. It won’t have the
      right <em>value</em> at all – but that would only matter if this
      branch were <em>selected</em>. The idea is that the dummy
      wrong-value-of-the-right-type is only used in cases where the
      whole containing branch was going to be thrown away.</p>
    <p>For example, here’s a macro you might use to generate an
      expression of type <code>struct MyStringBuffer *</code>, which
      matches the input expression if <em>that</em> is of that type, and
      otherwise makes something up:</p>
    <pre>void *dummy(void);

#define coerce_to_MyStringBuffer(x) _Generic(x,                    \
    struct MyStringBuffer * : (x),                                 \
    default                 : (struct MyStringBuffer *)dummy())</pre>
    <p>Using this coercion macro, we can fix the <em>original</em>
      attempt to implement our <code>string_length</code> macro, by
      modifying the dangerous <code>(x)-&gt;length</code> output
      expression to wrap the parameter <code>x</code> in our new
      coercion macro:</p>
    <pre>#define string_length_refixed(x) _Generic(x,                       \
    const char *            : strlen(x),                           \
    struct MyStringBuffer * : coerce_to_MyStringBuffer(x)-&gt;length)</pre>
    <p><em>This</em> version of the macro will still compile if
      you give it a <code>const char *</code>, because in the
      unselected output expression,
      the <code>coerce_to_MyStringBuffer()</code> macro call will
      deliver its dummy expression (calling the <code>dummy()</code>
      function and casting its output type), which is of a type
      that <em>can</em> validly take ‘<code>-&gt;length</code>’ after
      it. But once it’s passed its semantic checks, that expression is
      thrown away completely, so that it doesn’t matter that
      its <em>value</em> couldn’t possibly have been anything useful.</p>
    <p>On the other hand, if you give this macro a <code>struct
        MyStringBuffer *</code>, then the coercion macro will act as a
      no-op, returning the same pointer it was passed. So when the
      second clause of the main <code>_Generic</code> <em>is</em>
      selected, it will have a useful value in it.</p>
    <p>If you’re reading this and you have even an ounce of instinct
      for defensive programming, this probably looks pretty dangerous
      to you! We’re relying here on two
      separate <code>_Generic</code>s making their choices the same
      way. Get it wrong, and we might accidentally emit code into the
      object file that <em>really</em> calls the <code>dummy()</code>
      function and casts its return type to something it was never
      meant to be.</p>
    <p>My answer to that is: I haven’t yet mentioned
      what <code>dummy()</code> actually is. In fact, it’s nothing at
      all: it’s a non-existent function. It exists <em>only</em> as a
      declaration in whatever header file defines the code
      base’s <code>_Generic</code> macros. No <em>definition</em> of
      it exists in any translation unit.</p>
    <p>Therefore, if the compiler emits an actual call to that
      function into any object file, the effect will be a link
      failure, when the function turns out not to be defined anywhere
      at link time. The only way the program can be compiled
      successfully is if <em>no</em> use of this generic macro ends up
      capable of actually calling <code>dummy()</code> at run time.</p>
    <p>So it’s not as unsafe as all that! It is possible that a coding
      error in one of these <code>_Generic</code>s might mismatch the
      inner and outer expressions – but if so, a link failure will
      prevent the mistake from getting as far as executable code, let
      alone actually <em>being</em> executed.</p>

    <h2 id="arrayhack">Type tuples using a multidimensional array</h2>

    <p>One case where even <em>that</em> workaround doesn’t help is if
      you want to switch based on the types of two expressions at
      once.</p>
    <p>Of course, if the sets of permitted types for the two
      expressions are independent – that is, expression <code>x</code>
      can have any of <em>these</em> types, <code>y</code> can have
      any of <em>those</em> types, and any of the former goes with any
      of the latter – then there’s no problem with this, and you can
      just nest a <code>_Generic</code> switch on the type
      of <code>y</code> inside each branch of the
      outer <code>_Generic</code> for <code>x</code>. But if there’s
      any type of <code>y</code> that goes with one type
      of <code>x</code> and not with another, then that won’t work, as
      we’ve already discussed above.</p>
    <p>Neither of the previous workarounds will help. You can’t wrap
      the inner <code>_Generic</code> into an inline function, because
      inline functions can’t themselves be type-generic. And if you
      try to mimic the type-coercion approach, by giving each
      inner <code>_Generic</code> some kind of a default clause that
      prevents it from failing spuriously, then the same default
      clause will apply when it <em>is</em> the selected branch of the
      outer <code>_Generic</code>, and the effect is that you won’t
      get the compile failures you <em>did</em> want, when you
      actually gave your macro a pair of types that don’t go together.</p>
    <p>What you <em>really</em> want, in this case, is not to have to
      nest two switches in the first place. You want to make a
      combined type that encapsulates the types of <em>both</em> your
      controlling arguments <code>x</code> and <code>y</code>, and
      write a single one-layer <code>_Generic</code> expression that
      switches on the set of acceptable <em>tuples</em> of types.</p>
    <p>In some languages, you could just <em>do</em> that, because
      type tuples (or something like them) exist in the language
      already. If this were C++, for example, you can combine any two
      types into a single type by using them as parameters of a
      template – either one you make up yourself, or something
      pre-existing like <code>std::pair</code>
      or <code>std::tuple</code>. But then, if this were C++, you
      wouldn’t be trying to get <code>_Generic</code> to do something
      useful in the first place, because it wouldn’t exist, and even
      if it did, there are other ways!</p>
    <p>In C, the problem is not that type tuples <em>don’t exist</em>.
      You could imagine, for example, representing a tuple of two
      types using the type of a function pointer taking two arguments
      with those types, e.g. <code>void (*)(int, const char *)</code>
      might be used to represent the type pair <code>(int, const char
      *)</code>. The problem is that you have no way
      to <em>construct</em> one of those out of the
      expressions <code>x,y</code> passed to your macro.</p>
    <p>If you have any language extension available to help, then the
      problem becomes easier. With the GNU
      extension <code>__typeof</code>, for example, you could do this
      just fine:</p>
<pre>#define type_tuple_switch(x, y) _Generic((void (*)(__typeof(x), __typeof(y)))NULL, \
    void (*)(int, int)        : &#34;got two ints&#34;,                                    \
    void (*)(int, char *)     : &#34;got an int and a string&#34;,                         \
    void (*)(char *, int)     : &#34;got a string and an int&#34;)</pre>
    <p>Here, we’ve recovered the types of <code>x,y</code>
      via <code>__typeof</code>; made a function pointer type with those
      types as arguments; and cast <code>NULL</code> to that function
      pointer type for the sake of having an expression of that type to
      use as the first argument to <code>_Generic</code>. Then we can
      test pairs of acceptable types by making further
      function-pointer-shaped tuples.</p>
    <p>But what if your code needs to compile in <em>standard</em> C,
      without benefit of any dialect-specific extension?</p>
    <p>As in the previous section, you can work around the
      difficulties of <code>_Generic</code> by using yet
      another <code>_Generic</code>, because that’s the closest thing
      we <em>do</em> have in standard C to <code>__typeof</code>. We
      can’t make it output the actual <em>type</em>, but we can use it
      to test the type of an input argument and
      output <em>something</em> we can use when constructing another
      type.</p>
    <p>Specifically: we can convert each input type into
      an <em>integer</em>, so that the problem of switching on a pair
      of types is reduced to switching on a pair of integers. Then we
      can wrap our integers back up into a thing <code>_Generic</code>
      can switch on by making a multidimensional array with those
      integers as dimensions.</p>
    <p>This is the longest example yet, because we need three stages:
      an enumeration of type ids, a macro that returns the type id of
      an input, and finally, a switch on arrays with type ids as
      dimensions.</p>
<pre>enum MyTypeId {
    MTI_NONE,    // avoid using 0 as a type id, because it’s illegal as an array dimension
    MTI_INT,
    MTI_CHAR_PTR,
    MTI_SOME_STRUCT,
};

#define MYTYPEID(x) _Generic(x,           \
    int               : MTI_INT,          \
    char *            : MTI_CHAR_PTR,     \
    struct SomeStruct : MTI_SOME_STRUCT)

#define type_tuple_switch(x, y) _Generic((int (*)[MYTYPEID(x)][MYTYPEID(y)])NULL,  \
    int (*)[MTI_INT][MTI_INT]      : &#34;got two ints&#34;,                               \
    int (*)[MTI_INT][MTI_CHAR_PTR] : &#34;got an int and a string&#34;,                    \
    int (*)[MTI_CHAR_PTR][MTI_INT] : &#34;got a string and an int&#34;)</pre>
    <p>The enumeration and the <code>MYTYPEID</code> macro are
      reusable: if you have more than one macro that needs to switch
      on multiple types, you can use the same system of type ids for
      all of them, as long as you make an enum value for every type
      that <em>any</em> of them wants to use. (To demonstrate this,
      I’ve included a value in the example above which isn’t used
      in <code>type_tuple_switch</code> – we imagine that elsewhere in
      the same program is some other similar macro that <em>can</em>
      take an argument of type <code>struct SomeStruct</code>.)</p>
    <p>In this example case, I’ve kept the output expressions simple:
      those don’t mention the arguments <code>x,y</code> at all. If
      they did, then it works fine to combine this workaround for the
      pair-based switch with the previous section’s workaround for
      referring to the arguments in the output expressions. As long as
      each output expression only coerces inputs to types that they
      would have to have <em>anyway</em> for that expression to be
      selected, the combination works fine.</p>

    <h2 id="defaultchain">Chaining one <code>_Generic</code> as the default of another</h2>

    <p>One annoying edge case in all of the above is: what if you want
      to select between lots of different integer types?</p>
    <p>You could imagine wanting to do that in order to treat all the
      integer types <em>the same</em> (e.g. pass all of them to the
      one of your functions that accepts integers in general), or to
      treat them <em>differently</em> (e.g. return some value specific
      to an integer type, like the location of the high bit, or an
      appropriate <code>printf</code> format-string directive).</p>
    <p>The problem with this in C is that you don’t reliably know
      which integer types are the <em>same</em> as each other. The
      basic
      types <code>short</code>, <code>int</code>, <code>long</code>
      and <code>long long</code> are all guaranteed to be distinct
      types, but which of those is the same as,
      say, <code>int32_t</code>? It could be either
      of <code>int</code> or <code>long</code> (in practice, and
      perhaps others in theory). Similarly, <code>int64_t</code> might
      very reasonably be an alias of <code>long</code>, or
      of <code>long long</code>.</p>
    <p>This leads to a problem if you’re
      constructing <code>_Generic</code> expressions, because you’re not
      allowed to have two clauses specifying the <em>same</em> type. But
      you don’t know what types <em>are</em> the same time, so how do
      you avoid it?</p>
<pre>#define MYTYPEID_INTEGER_EDITION(i) _Generic(i, \
    int     : MTI_INT,                          \
    long    : MTI_LONG,                         \
    int64_t : MTI_INT64_T)</pre>
    <p>This example macro tries to convert integer types into type
      ids, in the style of the previous section. It will work fine
      if <code>int64_t</code> is an alias for <code>long long</code>
      on the platform where you try to compile it. But
      if <code>int64_t</code> turns out to be an alias
      for <code>long</code> instead, you’ve got a compile error – two
      clauses of this <code>_Generic</code> specify the same type. And
      if you remove the <code>long</code> case and replace it with
      a <code>long long</code> case, now you’ll get a compile error on
      the <code>other</code> platform.</p>
    <p>(Obviously, I’ve left out several of the <em>other</em> C
      integer types here. That’s just for the sake of keeping this
      example short.)</p>
    <p>We can work around this annoyance in a similar way to the
      previous two workarounds I’ve shown: use <em>yet another</em>
      instance of <code>_Generic</code> to avoid the problems with the
      first one. In this case, we can chain together
      two <code>_Generic</code>s by their default clause, both
      switching on the type of the <em>same</em> expression:</p>
<pre>#define MYTYPEID_INTEGER_EDITION(i)             \
_Generic(i,                                     \
    int       : MTI_INT,                        \
    long      : MTI_LONG,                       \
    long long : MTI_LONG_LONG,                  \
    default: _Generic(i,                        \
        int32_t : MTI_INT32_T,                  \
        int64_t : MTI_INT64_T,                  \
        default : MTI_NONE))</pre>
    <p>Now it doesn’t matter any more whether <code>int64_t</code> is
      an alias for <code>long</code>, because those two types don’t
      appear together in the <em>same</em> <code>_Generic</code>: one
      is in the outer one, and the other is in the inner one. And
      if <code>int64_t</code> is an alias for <code>long long</code>
      instead, there’s still no problem, because <em>those</em> two
      don’t appear together. Generally, the idea is that I’ve put all
      the language’s <em>basic</em> integer types in one of the lists,
      and the <code>&lt;stdint.h&gt;</code> type aliases in the other,
      and as long as no two types in the <em>same</em> list collide,
      things should work.</p>
    <p>However, a couple of things to note about this workaround:</p>
    <p>Firstly, <em>not all the output expressions can be generated at
      all</em>, on a given platform. Suppose that our compiler’s
      headers define <code>int64_t</code> to be an alias
      for <code>long</code>. Then the macro above will never
      return <code>MTI_INT64_T</code> at all, because that branch of
      the inner <code>_Generic</code> will always have been pre-empted
      by the branch of the outer one that
      returns <code>MTI_LONG</code>. Conversely, on a different
      system, this macro might map an <code>int64_t</code> input
      to <code>MTI_LONG_LONG</code>.</p>
    <p>(In fact, is there <em>any</em> integer type capable of getting
      through the non-default cases of the outer <code>_Generic</code>
      and reaching the inner one? Perhaps not! But writing it like this,
      we should cope even if there is.)</p>
    <p>Secondly, note that even
      the <em>inner</em> <code>_Generic</code> has a default clause.
      This isn’t optional: it’s necessary for the same reason as
      usual, namely that the inner <code>_Generic</code> as a whole
      will be checked for semantic validity <em>even if</em> one of
      the other branches of the outer <code>_Generic</code> is
      selected. So if any type handled by the
      outer <code>_Generic</code> is not also handled by the inner
      one, then you’ll get a compile error.</p>
    <p>The simplest fix is to always return <em>something</em> from
      the expression as a whole. Here, we return the dummy
      value <code>MTI_NONE</code>, shown in the enum in the previous
      section. The idea would be that any attempt to use that value in
      an array-based type tuple would provoke a compile error in its
      own right, or even if not, it wouldn’t match any of the branches
      of a tuple-based <code>_Generic</code> you were writing.</p>

    <h2 id="remainingproblems">Remaining problems</h2>

    <p>“Phew! Are we done yet?”</p>
    <p>I’ve presented a variety of different workarounds for the
      various reasons why you might get unwanted compile errors when
      trying to do anything interesting with <code>_Generic</code>. Is
      there anything left that will <em>still</em> go wrong?</p>
    <p>Unfortunately, yes. There are two problems left, and I’ve run
      out of workarounds.</p>
    <p>Firstly: if you do all of this trickery with multiple
      nested <code>_Generic</code> expressions, and something goes
      wrong, the compiler error messages are <em>terrible</em>. If you
      define a macro that accepts three types, you’d like to see an
      error message saying something comprehensible like “Sorry, you
      gave <em>this</em> type and I wanted one of <em>these</em>.”</p>
    <p>You can just about get that from a really simple use
      of <code>_Generic</code>: if an input type doesn’t match any
      clause then gcc’s or clang’s error message will tell you what
      the input type <em>was</em>, and will point at the source
      location of the generic expression that it didn’t match. You’ll
      still have to go through the source expression yourself to find
      out what types <em>would</em> have matched, but at least you
      know where to look for that.</p>
    <p>But the more workarounds you add, the more the errors start
      talking about things in the workaround system and not things in
      the user’s actual code. For example, if you’re using the type-id
      system I’ve shown here, and it generates a type id that isn’t
      matched by a particular <code>_Generic</code>, the error message
      will tell you that the mismatching type is some nonsense
      multidimensional array type like <code>int (*)[5][2]</code>,
      which has no relation to the types you specified at the call
      site of your generic macro. Of course, we <em>had</em> to map
      the input types to opaque integers to make the system work at
      all – but a side effect is that those integers are now what you
      see in the error report.</p>
    <p>The first duty of compile-time error checking is to only let
      code through if it’s right. The second is to tell the user
      something <em>useful</em> if it’s wrong. With all these
      workarounds, we’ve only managed to fulfill the first of those!</p>
    <p>Secondly, the expansions of these macros become <em>enormous</em>.</p>
    <p>A macro containing multiple workarounds of this kind will have
      to expand its parameters in lots of different places: at least
      one macro argument will need to appear in the controlling
      argument of each <code>_Generic</code> (inner or outer), and if
      the point of the workarounds was to let you use the macro
      argument again in the output expressions, then you’ll want to do
      that as well. It’s very easy to write a macro that expands its
      argument ten times.</p>
    <p>This isn’t <em>dangerous</em> in correctness terms, which is
      the <em>usual</em> reason why people worry about multiply
      expanding macro parameters. In all the examples here, there’s no
      reason to expand any parameter in a way that will make it
      be <em>evaluated</em> twice (e.g. doubling its side effects).
      The controlling expression of <code>_Generic</code> is never
      evaluated, and at most one of its output expressions is. So you
      can perfectly well employ all the workarounds in this article,
      and still put at most one copy of the macro parameter in each
      output expression in a context where it will generate code. And
      only one of those output expressions will be evaluated, so you
      can easily arrange to get the expression’s side effects (if any)
      at most once.</p>
    <p>But in some cases, even the multiple <em>expansion</em> can
      cause a problem. For example, suppose I’ve defined a macro
      that’s packed with complicated <code>_Generic</code>
      expressions, with workarounds everywhere. And then suppose
      someone innocently writes this in their source code:</p>
<pre>int x = MY_MACRO(MY_MACRO(MY_MACRO(MY_MACRO(MY_MACRO(y)))));</pre>
    <p>Suppose the macro expands its parameter 10 times. Then the
      expansion of the innermost <code>MY_MACRO(y)</code> will still
      be reasonably small, because the text mentioned ten times is
      just the single identifier <code>y</code>. But the expansion of
      the next layer, <code>MY_MACRO(MY_MACRO(y))</code>, will repeat
      ten times the <em>entire innermost expansion</em>. And each of
      the next three layers will multiply <em>that</em> by another
      factor of ten.</p>
    <p>The combined effect will be that the C preprocessor generates
      a <em>huge</em> amount of output, which the main C compiler has
      to painstakingly parse, store in an internal data structure,
      semantically validate, and then process to the point of deciding
      which branch of each <code>_Generic</code> to take. In the end,
      it will throw away nearly all of that huge amount of text, and
      emit just the single short expression that ended up being
      selected. But your compiler will go <em>very</em> slowly in the
      process – and it might even consume too much of the system’s
      memory, and crash, or start starving other processes of
      resources!</p>
    <p>A user who knows that this is going on has an easy workaround,
      which is to avoid nesting expansions of macros that do this kind
      of trick. Instead, add extra intermediate variables, and use
      just a simple variable name in the next expansion:</p>
<pre>int y1 = MY_MACRO(y);
int y2 = MY_MACRO(y1);
int y3 = MY_MACRO(y2);
int y4 = MY_MACRO(y3);
int x  = MY_MACRO(y4);</pre>
    <p>But not all users will be sympathetic to being told to do that!</p>
    <p>Even the <em>intended</em> use of <code>_Generic</code> has
      this problem, to some extent. If you switch on your macro
      parameter to select one of a list of function names, and then
      write the parameter again after closing
      the <code>_Generic</code>, then you’ve expanded the parameter
      twice overall. So a nest of macro invocations like the above
      will still exponentially inflate the amount of preprocessor
      output. But it will only inflate by a factor of 2 each time,
      instead of 10 or more.</p>
    <p>So the moral of this section is the same thing I’ve said
      already: <em>if you can</em>, it’s better to
      use <code>_Generic</code> in a mode where it just selects between
      function names – even if you have to write some functions
      specially to be selected.</p>

    <h2 id="conclusion">Conclusion</h2>

    <p>In summary:</p>
    <ul>
      <li><code>_Generic</code> has a huge design limitation that
        makes a lot of things you wanted to do with it not work.</li>
      <li>The best available workaround is to try to use it the same
        way it was originally designed: select between function names
        only, and put the function call arguments outside
        the <code>_Generic</code>. This avoids <em>almost</em> all the
        inconvenience, if you can write your code in that style.</li>
      <li>If you can’t, there are several alternative workarounds
        available, all with the common theme of using an extra
        instance of <code>_Generic</code> to present the outer one
        with something it can handle.</li>
      <li>However, these workarounds create their own problems, in
        particular the risk of exponential compiler slowdown, so use
        with caution, if at all!</li>
    </ul>
    <p>It’s tempting to ask: is there anything
      that <code>_Generic</code> <em>is</em> useful for, if it’s so hard
      to make it do any of the things I’ve mentioned here?</p>
    <p>Apart from the most obvious answer (that it’s useful for things
      exactly like <code>&lt;tgmath.h&gt;</code>), the best
      thing I’ve thought of to do with <code>_Generic</code> is to use
      it for deliberate error checking. The annoyance in all the
      previous sections was that it was very hard to <em>avoid</em>
      compile errors, when we wanted our code to actually compile, run
      and do something useful. But if what we <em>wanted</em> was to
      provoke compile errors on a hair-trigger basis, then perhaps we
      could use it for that more reliably?</p>
    <p>An example: in a code base of mine I once refactored some
      open-coded uses of arrays for a particular purpose, replacing
      them with an abstract data type that had a documented API. One
      part of this refactoring involved finding all the places where I
      passed one of those arrays to <code>free()</code> – or rather,
      to the wrapper function <code>sfree()</code> that I habitually
      use in code bases of my own – and instead, pass the new ADT to
      its own dedicated free function. If I failed to do that, there
      would be a memory leak (secondary memory allocations hanging off
      the main object wouldn’t be cleaned up).
      But <code>sfree()</code> (just like
      standard <code>free()</code>) accepted a <code>void *</code>, so
      it wouldn’t throw an error if I used it for the new ADT.</p>
    <p>My solution was to turn <code>sfree()</code> itself into a
      macro that checked the input type using <code>_Generic</code>:</p>
<pre>extern void dummy(void *);

#define sfree(x) _Generic(x,   \
    MyNewADT *   : dummy,      \
    default      : sfree) (x)</pre>
    <p>Just like the dummy function in a previous
      section, <code>dummy()</code> here exists only as a declaration,
      and isn’t defined anywhere. So if I had any remaining cases of
      the new ADT being passed to <code>sfree()</code>, then this
      generic expression would select a call to a nonexistent
      function, and cause a link-time failure. Meanwhile,
      everything <em>else</em> gets freed as normal.</p>
    <p>(I decided this was ugly enough that I should only do it during
      the refactoring process, as a one-off check that I’d converted
      all the old <code>sfree()</code> calls. Once the refactoring was
      complete, I removed the scaffolding, turned <code>sfree</code>
      back to the way it normally was, and trusted myself to carry on
      freeing instances of the new ADT using its own free function
      when I add new code in future.)</p>
  

</div>
  </body>
</html>
