<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://pytorch.org/blog/helion/">Original</a>
    <h1>Helion: A high-level DSL for performant and portable ML kernels</h1>
    
    <div id="readability-page-1" class="page"><div>

            
            <div role="main">

            
<article id="post-5529">
  
  <div>

		<div data-hide-featured-media="1">
      
        <div><h2><b>Introduction to Helion</b></h2>
<p><span>In modern machine learning, the demand for high-performance computation has led to a proliferation of custom kernels. While these kernels can deliver impressive performance, they are often written in low-level, hardware-specific languages. This creates a long-term maintenance burden: A kernel meticulously optimized for one hardware architecture quickly becomes technical debt, difficult and costly to port to another. This challenge hinders development and innovation and forces developers to choose between productivity and performance.</span></p>
<p><a href="https://github.com/pytorch/helion"><span>Helion</span></a><span> resolves this conflict by compiling a high-level Python-embedded domain-specific language (DSL) into automatically tuned Triton code. It establishes a new layer of abstraction that bridges the user-friendly simplicity of PyTorch with the performance of a lower level language. By automating tedious and error-prone tasks like tensor indexing, memory management, and hardware-specific tuning, Helion empowers developers to focus on algorithmic logic rather than hardware-specific implementation details. Helion achieves this balance by pairing a familiar, PyTorch-centric syntax with a powerful autotuning engine that automates the complex search for optimal kernel configurations. This results in a system that delivers performance portability across hardware architectures while drastically reducing development effort. </span></p>
<h2><b>Motivation for a New DSL</b></h2>
<p><span>Choosing the right abstraction level for kernel development is a strategic decision that directly impacts performance, maintainability, and the developer velocity. The current programming languages and abstractions force developers into a false dichotomy between low-level control and high-level productivity. Both ends of the spectrum come with advantages and drawbacks.</span></p>
<ul>
<li aria-level="1"><b>CUDA/Gluon/TLX:</b><span> Writing kernels directly in languages like CUDA offers maximum control but can require significant effort to achieve high performance. These kernels are highly specialized to specific hardware and can be difficult to adapt to new architectures.</span></li>
<li aria-level="1"><b>Triton:</b><span> While Triton represents a major step forward, it still requires significant manual effort. Developers are responsible for explicitly managing tensor indexing, defining search spaces for autotuning, managing kernel arguments, and changing the optimization strategy can often require significant code rewrites. </span></li>
<li aria-level="1"><b>PyTorch:</b><span> While frameworks like PyTorch and <code>torch.compile</code></span><span> offer exceptional ease of use, they provide limited fine-grained control. Users who need to specify exact fusion strategies often find the high-level abstraction too restrictive.</span></li>
</ul>
<h2><b>Helion Programming Model: “PyTorch with Tiles”</b></h2>
<p><span>The goal of Helion’s programming model is to minimize boilerplate and leverage developers’ existing knowledge of PyTorch. This design philosophy accelerates the creation of correct, efficient kernels by providing a familiar and intuitive syntax, which can be described as “PyTorch with Tiles”.</span></p>
<p><span>A typical Helion kernel, such as the matrix multiplication example below, is composed of two distinct parts that work in concert:</span></p>
<pre><span><span>import</span> <span>torch,</span> <span>helion,</span> <span>helion.language</span> <span>as</span> <span>hl</span></span>

<span>@helion.kernel()</span>
<span><span>def</span> <span>matmul(x:</span> <span>torch.Tensor,</span> <span>y:</span> <span>torch.Tensor)</span> <span>-&gt;</span> <span>torch.Tensor:</span></span>
<span><span>    </span><span>#</span> <span>---</span> <span>Host</span> <span>Code</span> <span>(runs</span> <span>on</span> <span>CPU)</span> <span>---</span></span>
<span><span>    </span><span>m,</span> <span>k</span> <span>=</span> <span>x.size()</span></span>
<span><span>    </span><span>k,</span> <span>n</span> <span>=</span> <span>y.size()</span></span>
<span><span>    </span><span>out</span> <span>=</span> <span>torch.empty([m,</span> <span>n],</span> <span>dtype=x.dtype,</span> <span>device=x.device)</span></span>

<span><span>    </span><span>#</span> <span>---</span> <span>Device</span> <span>Code</span> <span>(compiles</span> <span>to</span> <span>a</span> <span>Triton</span> <span>kernel)</span> <span>---</span></span>
<span><span>    </span><span>for</span> <span>tile_m,</span> <span>tile_n</span> <span>in</span> <span>hl.tile([m,</span> <span>n]):</span></span>
<span><span>        </span><span>acc</span> <span>=</span> <span>hl.zeros([tile_m,</span> <span>tile_n],</span> <span>dtype=torch.float32)</span></span>
<span><span>        </span><span>for</span> <span>tile_k</span> <span>in</span> <span>hl.tile(k):</span></span>
<span><span>            </span><span>acc</span> <span>=</span> <span>torch.addmm(acc,</span> <span>x[tile_m,</span> <span>tile_k],</span> <span>y[tile_k,</span> <span>tile_n])</span></span>
<span><span>        </span><span>out[tile_m,</span> <span>tile_n]</span> <span>=</span> <span>acc
</span></span>
<span><span>    </span><span>return</span> <span>out

</span></span></pre>
<ul>
<li aria-level="1"><b>Host Code:</b><span> The code outside the outermost <code>hl.tile</code></span><span> </span><span>for loop is standard PyTorch code. It is primarily used for setup tasks such as allocating output tensors and computing shapes. Helion automatically handles the passing of these values to the device code, eliminating the need for manual argument management.</span></li>
<li aria-level="1"><b>Device Code:</b><span> The code inside the outermost <code>hl.tile</code></span><span> </span><span>for loop is the core of the kernel. This section is compiled into a single, high-performance Triton kernel that executes in parallel on a GPU.</span></li>
</ul>
<p><span>The core language construct, <code>hl.tile</code></span><span>, subdivides the kernel’s iteration space into tiles. The programmer only specifies to tile the iteration space, and the specific implementation details, such as tile sizes, iteration order, and memory layout optimizations, are handled by Helion’s autotuner, which systematically explores the optimal configuration for the target hardware.</span></p>
<p><span>Within the kernel body, developers can use standard PyTorch operators like </span><span>torch.addmm</span><span> and other pointwise or reduction operations. Helion leverages TorchInductor, a core component of PyTorch 2, to automatically map these PyTorch calls to their corresponding low-level Triton implementations. This delivers a powerful usability benefit: </span><b>Familiarity with PyTorch means you already know most of Helion.</b></p>
<p><span>Helion also includes templating capability that allows lambda functions, that may capture additional arguments in closures, to be passed in as arguments to a kernel. As shown in this </span><a href="https://github.com/pytorch/helion/blob/main/examples/matmul_split_k.py"><span>example</span></a><span>, this is particularly useful for implementing generic kernels with customizable epilogues. For instance, a lambda function can capture a tensor defined in the surrounding scope. Helion’s compiler automatically detects this variable and makes it into an argument in the generated Triton kernel. This eliminates a significant amount of boilerplate code to pass new inputs through multiple layers of function calls, enabling creation of highly reusable and generic kernels.</span></p>
<p><span>Helion makes kernel implementations radically simpler: the Attention kernel is just 30 lines in Helion, compared to 120 lines in Triton and thousands of lines in CUDA. This high-level, declarative programming model is made performant by the core mechanism that underpins the entire system: the autotuning engine.</span></p>
<h2><b>Helion’s Autotuner: Generating Optimal Kernels via Implicit Search Spaces</b></h2>
<p><span>Helion’s key differentiator is its automated, ahead-of-time (AOT) autotuning engine. In Triton, developers are responsible for manually defining the search space for optimizations. This requires explicitly enumerating every configuration to be tested, a tedious process that limits the scope of exploration.</span></p>
<p><span>Helion changes this dynamic with implicit search spaces. The high-level language automatically constructs a vast, multi-dimensional search space over implementation choices. For example, a single </span><code><span>hl.tile</span></code> call implicitly instructs the autotuner to explore different block sizes, loop orderings, and whether to flatten the iteration space into a single dimension. One Helion kernel definition thus maps to thousands of Triton configurations, allowing the autotuner to create a much larger and richer search space to discover a superior configuration.</p>
<p><img fetchpriority="high" decoding="async" src="https://pytorch.org/wp-content/uploads/2025/10/1-5.png" alt="" width="594" height="789" srcset="https://pytorch.org/wp-content/uploads/2025/10/1-5.png 1197w, https://pytorch.org/wp-content/uploads/2025/10/1-5-226x300.png 226w, https://pytorch.org/wp-content/uploads/2025/10/1-5-771x1024.png 771w" sizes="(max-width: 594px) 100vw, 594px"/></p>
<h3><b>The Autotuning Workflow</b></h3>
<p><span>When a kernel is run for the first time without a specified configuration, the autotuner initiates an automated search. This process, which typically takes around 10 minutes, evaluates thousands of candidate Triton kernel configurations using search strategies like Differential Evolution or Pattern Search to identify optimized sets of parameters for the given input shapes and hardware. Upon completion, the autotuner prints the single best configuration it discovered:</span></p>
<pre><span>[</span><span>586s</span><span>]</span> <span>Autotuning</span> <span>complete</span> <span>in</span> <span><span>586</span><span>.</span><span>6s</span></span> <span>after</span> <span>searching</span> <span>1520</span> <span>configs.</span>
<span>One</span> <span>can</span> <span>hardcode</span> <span>the</span> <span>best</span> <span>config</span> <span>and</span> <span>skip</span> <span>autotuning</span> <span>with:</span>
<span>    </span><span>@helion.kernel(config=helion.Config(block_sizes=[</span><span>64</span><span>,</span> <span>64</span><span>,</span> <span>64</span><span>],</span> 
<span>loop_orders=[[</span><span>0</span><span>,</span> <span>1</span><span>]],</span> <span>l2_groupings=[</span><span>4</span><span>],</span> <span>range_unroll_factors=[</span><span>0</span><span>,</span> <span>1</span><span>],</span> 
<span>range_warp_specializes=[None,</span> <span>False],</span> <span>range_num_stages=[</span><span>0</span><span>,</span> <span>3</span><span>],</span> 
<span>range_multi_buffers=[None,</span> <span>False],</span> <span>range_flattens=[None,</span> <span>None],</span> 
<span>num_warps=</span><span>8</span><span>,</span> <span>num_stages=</span><span>6</span><span>,</span> <span>indexing=</span><span>&#39;block_ptr&#39;</span><span>,</span> <span>pid_type=</span><span>&#39;flat&#39;</span><span>))

</span></pre>
<p><span>The developer can copy this config into the </span><code><span>@helion.kernel()</span></code><span> decorator in their source code. This instructs Helion to bypass the search process entirely during subsequent runs. In a production environment, this results in fast, deterministic compilation that generates the single, pre-optimized Triton kernel, delivering performance equivalent to a meticulously hand-tuned kernel with far less effort. </span></p>
<pre><span>@helion.kernel(config=helion.Config(</span>
<span>    </span><span>block_sizes=[</span><span>64</span><span>,</span> <span>64</span><span>,</span> <span>64</span><span>],</span>
<span>    </span><span>loop_orders=[[</span><span>0</span><span>,</span> <span>1</span><span>]],</span>
<span>    </span><span>l2_groupings=[</span><span>4</span><span>],</span>
<span>    </span><span>range_unroll_factors=[</span><span>0</span><span>,</span> <span>1</span><span>],</span>
<span>    </span><span>range_warp_specializes=[</span><span>None</span><span>,</span> <span>False],</span>
<span>    </span><span>range_num_stages=[</span><span>0</span><span>,</span> <span>3</span><span>],</span>
<span>    </span><span>range_multi_buffers=[</span><span>None</span><span>,</span> <span>False],</span>
<span>    </span><span>range_flattens=[</span><span>None</span><span>,</span> <span>None</span><span>],</span>
<span>    </span><span>num_warps=</span><span>8</span><span>,</span>
<span>    </span><span>num_stages=</span><span>6</span><span>,</span>
<span>    </span><span>indexing=</span><span>&#39;block_ptr&#39;</span><span>,</span>
<span>    </span><span>pid_type=</span><span>&#39;flat&#39;</span>
<span>))</span>
<span>def</span> <span>matmul(x:</span> <span>torch.Tensor,</span> <span>y:</span> <span>torch.Tensor)</span> <span>-&gt;</span> <span>torch.Tensor:</span>
<span>    </span><span>...</span></pre>
<p><span>The developer can also specify a list of configs in<code>@helion.kernel()</code></span><span>, in which case Helion will explore only those configs to choose the fastest implementation. </span></p>
<h3><span>The Configuration Space</span></h3>
<p><span>The configuration space represents the set of implementation choices that Helion automates. This space is the primary source of Helion’s performance portability, as it allows a single kernel definition to be adapted to the unique characteristics of different hardware architectures and input tensor sizes. Exploring this space is what gives Helion its advantage over manually written kernels, which are often tuned for a specific set of conditions.</span></p>
<p><span>The autotuner explores a wide range of parameters that control everything from data movement to thread mapping. The table below details the configuration options.</span></p>
<table>
<tbody>
<tr>
<td><span>Parameter</span></td>
<td colspan="2"><span>Description</span></td>
</tr>
<tr>
<td>
<pre><span><code>indexing</code></span></pre>
</td>
<td colspan="2"><span>In Triton, a developer can choose between three distinct methods for memory access: pointer arithmetic, block pointers, and tensor descriptors, which leverage Tensor Memory Accelerators (TMAs) on NVIDIA Hopper/Blackwell GPUs. The optimal choice depends on the hardware architecture and memory access patterns, but switching between these methods requires significant code rewrite.</span>
<p><span>Helion abstracts this complexity with the <span><code>indexing</code></span> configuration parameter (<span><code>&#39;pointer&#39;, &#39;block_ptr&#39;</code></span>, or<code><span>&#39;tensor_descriptor&#39;</span></code>) to allow the autotuner to automatically generate and benchmark code for all three memory access patterns from the same source. This not only simplifies development but also ensures that kernels can take advantage of the latest hardware features like TMAs without any code changes.</span></p></td>
</tr>
<tr>
<td>
<pre><span><code>block_sizes</code></span></pre>
</td>
<td colspan="2"><span>The <code><span>block_sizes</span></code> parameter is a list of tile sizes for each dimension in an <span><code><span>hl.tile</span></code> loop that determines the amount of data each thread block processes. This affects register usage, shared memory requirements, and parallelism.</span></span></td>
</tr>
<tr>
<td>
<pre><span><code>flatten_loops</code></span></pre>
</td>
<td colspan="2"><span>The <code>flatten_loops</code> option controls flattening a multi-dimensional tiling space of a <code><span>hl.tile</span></code> loop into a single dimension, expanding autotuner’s search space without having the developer re-write the kernel code.</span></td>
</tr>
<tr>
<td>
<pre><span><code>loop_orders,l2_grouping</code></span></pre>
</td>
<td colspan="2"><span>To optimize data locality, Helion provides two configuration knobs. The <code>loop_orders</code> parameter allows the autotuner to permute the iteration order of nested tiles, which can affect cache hit rates depending on tensor layouts. The <code>l2_grouping</code> configuration enables PID swizzling, a technique that reorders the assignment of thread blocks to improve data reuse in the L2 cache. In Triton, these transformations would require rewriting complex loop structures and index calculations.</span></td>
</tr>
<tr>
<td>
<pre><span><code>reduction_loops</code></span></pre>
</td>
<td colspan="2"><span>When performing a reduction (e.g., sum() over a tensor dimension), a persistent reduction processes the entire reduction dimension for a single tile, which is fast for small dimensions. However, if the reduction is large, this approach can create high register pressure, leading to register spilling and low performance. Alternatively, a developer can write a loop to iterate over the reduction dimension in smaller chunks.</span>
<p><span>While switching between the two strategies typically requires code rewrites, Helion automates this choice with the <code>reduction_loops</code> configuration, where the autotuner can benchmark both the persistent and looped versions and select the best one.</span></p></td>
</tr>
<tr>
<td>
<pre><span><code>pid_type</code></span></pre>
</td>
<td colspan="2"><span>Helion automates the calculation of grid sizes and the mapping of Program IDs (PIDs) to data tiles. The pid_type configuration allows the autotuner to explore various mapping strategies without any manual code changes:</span>
<ul>
<li>
<ul>
<li aria-level="1">
<p><span><code>&#39;flat&#39;</code>: Uses a simple 1D grid.</span></p>
</li>
<li aria-level="1">
<p><span><code>&#39;xyz&#39;</code>: Maps PIDs to a multi-dimensional grid.</span></p>
</li>
<li aria-level="1">
<p><span><code>&#39;persistent_blocked/persistent_interleaved&#39;</code>: Generates a persistent kernel to launch only one thread block per Streaming Multiprocessor (SM) and uses the internal loop within the kernel to iterate over virtual PIDs to process multiple tiles of work. This strategy can improve SM utilization by ensuring compute resources remain saturated without kernel launch overheads.</span></p>
</li>
</ul>
</li>
</ul>
</td>
</tr>
<tr>
<td>
<pre><span><code>load_eviction_policy</code></span></pre>
</td>
<td colspan="2"><span>Helion autotunes over Triton<code>tl.load</code>’s eviction_policy parameter, influencing GPU L1 cache residency. Autotuning can pick the combination of eviction hints that best suits the kernel’s memory access patterns.</span></td>
</tr>
<tr>
<td><span>Triton configs:</span>
<pre><span><code>num_warps, 
num_stages, 
range_unroll_factors, 
range_warp_specializes, 
range_num_stages, 
range_multi_buffers, 
range_flattens</code></span></pre>
</td>
<td colspan="2"><span>Helion automatically explores standard Triton tunable parameters, alleviating the developer effort of manual tuning.</span></td>
</tr>
</tbody>
</table>
<h2>Performance Analysis and Benchmarks</h2>
<p>We benchmark the performance of Helion to <code>torch.compile</code>(with max-autotune), and hand-written Triton to measure their respective speedups over eager mode execution across a wide variety of kernels and shapes on NVIDIA B200 and AMD MI350X GPUs. Most of the hand-written Triton kernels are from the <a href="https://github.com/linkedin/Liger-Kernel">Liger-Kernel benchmark suite</a>.</p>
<h3>Performance on NVIDIA B200</h3>
<p><span>The following table summarizes the performance on NVIDIA B200 GPU, with green highlighted cells indicating the highest speedup over eager mode execution for each kernel. Across all benchmarks, Helion achieves the highest geomean speedup of 3.27x, followed by <code>torch.compile</code></span><span> (with max-autotune) at 2.7x, and hand-written Triton kernels at 1.76x. On average, Helion delivers 1.21x speedup over <code>torch.compile</code></span><span> and 1.85x speedup over Triton kernels. Performance gains are especially notable for the <code>softmax kernel</code></span><span>, with Helion achieving 2.28x speedup over <code>torch.compile</code></span><span>, and for the <code>jsd</code></span><span> </span><span>kernel, where Helion outperforms hand-written Triton by 6.22x.</span></p>
<h3><img decoding="async" src="https://pytorch.org/wp-content/uploads/2025/10/Screenshot-2025-10-23-at-8.44.36-AM.png" alt="" width="1264" height="782" srcset="https://pytorch.org/wp-content/uploads/2025/10/Screenshot-2025-10-23-at-8.44.36-AM.png 1264w, https://pytorch.org/wp-content/uploads/2025/10/Screenshot-2025-10-23-at-8.44.36-AM-300x186.png 300w, https://pytorch.org/wp-content/uploads/2025/10/Screenshot-2025-10-23-at-8.44.36-AM-1024x634.png 1024w" sizes="(max-width: 1264px) 100vw, 1264px"/></h3>
<h3>Performance on AMD MI350X</h3>
<p>Performance on AMD MI350X shows a similar trend, with Helion achieving the highest geomean speedup of 2.37x over eager mode execution, compared to 2.26x for <code>torch.compile</code> and 1.65x for Triton kernels. On average, Helion delivers 1.05x speedup over <code>torch.compile</code> and 1.44x speedup over Triton kernels. The performance gains are particularly pronounced for the <code>int4_gemm</code> and <code>jsd</code> kernels, with Helion outperforming hand-written Triton kernels by 4.5x and 4.4x, respectively.</p>
<h3><img decoding="async" src="https://pytorch.org/wp-content/uploads/2025/10/Screenshot-2025-10-21-at-10.31.36-AM.png" alt="" width="1238" height="716" srcset="https://pytorch.org/wp-content/uploads/2025/10/Screenshot-2025-10-21-at-10.31.36-AM.png 1238w, https://pytorch.org/wp-content/uploads/2025/10/Screenshot-2025-10-21-at-10.31.36-AM-300x174.png 300w, https://pytorch.org/wp-content/uploads/2025/10/Screenshot-2025-10-21-at-10.31.36-AM-1024x592.png 1024w" sizes="(max-width: 1238px) 100vw, 1238px"/></h3>
<h3>Case Study 1: Outperforming Highly Optimized CuTe DSL Kernel</h3>
<p><span>A Helion implementation of the </span><a href="https://github.com/pytorch/helion/blob/main/examples/rms_norm.py#L69"><span>RMSNorm backward kernel</span></a><span>, written in less than a day, demonstrates performance on par with or exceeds a highly hand-optimized </span><a href="https://github.com/Dao-AILab/quack/blob/main/quack/rmsnorm.py"><span>Quack kernel</span></a><span> written in CuTe DSL. Across a range of reduction dimensions on H100 GPU, Helion consistently matches or outperforms the manually-tuned kernel, demonstrating its ability to match expert-level performance with significant productivity boost from developing at a higher level of abstraction. We also compare to <code>torch.compile</code></span><span> (with max-autotune) and hand-written Triton, where Helion outperformed in many cases. </span></p>
<p><img decoding="async" src="https://pytorch.org/wp-content/uploads/2025/10/3-6.png" alt="" width="1390" height="858" srcset="https://pytorch.org/wp-content/uploads/2025/10/3-6.png 1390w, https://pytorch.org/wp-content/uploads/2025/10/3-6-300x185.png 300w, https://pytorch.org/wp-content/uploads/2025/10/3-6-1024x632.png 1024w" sizes="(max-width: 1390px) 100vw, 1390px"/></p>

<p><span>These results are made possible by Helion’s underlying compiler architecture, which is designed to efficiently support large-scale search for autotuning.</span></p>
<h3><b>Case Study 2: Benchmarking Helion to TileLang</b></h3>
<p><span>We also compare the performance of Helion to </span><a href="https://github.com/tile-ai/tilelang"><span>TileLang</span></a><span>, an open-source DSL for developing high-performance GPU kernels. We implemented the Mamba-2-chunk-scan kernel — a selective scan operation central to the Mamba-2 architecture — in Helion to compare against its </span><a href="https://github.com/tile-ai/tilelang/blob/main/examples/linear_attention/example_mamba_chunk_scan.py"><span>TileLang</span></a><span> and </span><a href="https://github.com/state-spaces/mamba/blob/main/mamba_ssm/ops/triton/ssd_chunk_scan.py"><span>Triton</span></a><span> counterparts. On H100, Helion delivers the highest performance, achieving 2.12x–2.63x speedups over TileLang and 1.2x–1.85x over Triton across different configurations.</span></p>
<p><img decoding="async" src="https://pytorch.org/wp-content/uploads/2025/10/4-3.png" alt="" width="1200" height="742" srcset="https://pytorch.org/wp-content/uploads/2025/10/4-3.png 1200w, https://pytorch.org/wp-content/uploads/2025/10/4-3-300x186.png 300w, https://pytorch.org/wp-content/uploads/2025/10/4-3-1024x633.png 1024w" sizes="(max-width: 1200px) 100vw, 1200px"/></p>
<p><b>High-Level Compiler Architecture</b></p>
<p><img decoding="async" src="https://pytorch.org/wp-content/uploads/2025/10/5-2.png" alt="" width="1600" height="688" srcset="https://pytorch.org/wp-content/uploads/2025/10/5-2.png 1600w, https://pytorch.org/wp-content/uploads/2025/10/5-2-300x129.png 300w, https://pytorch.org/wp-content/uploads/2025/10/5-2-1024x440.png 1024w" sizes="(max-width: 1600px) 100vw, 1600px"/></p>
<p><span>Helion’s compiler architecture is designed to progressively lower a Python function into highly optimized Triton code with TorchInductor.</span></p>
<p><span>The compilation pipeline proceeds through the following key stages:</span></p>
<ol>
<li aria-level="1"><b>Python AST Parsing:</b><span> The process begins by parsing the kernel’s Python source code into an Abstract Syntax Tree (AST).</span></li>
<li aria-level="1"><b>Type Propagation &amp; Metadata:</b><span> A custom pass traverses the AST, annotating each node with type information and other essential metadata to create an extended AST.</span></li>
<li aria-level="1"><b>Lowering to Device IR:</b><span> This annotated tree is lowered into Helion’s primary intermediate representation (IR). The Device IR is a collection of FX Graphs in Static Single-Assignment (SSA) form, with one graph representing each basic block of the program. Every node in this graph contains a pointer to an Inductor IR node, which is used for code generation.</span></li>
<li aria-level="1"><b>Compiler Passes:</b><span> A series of transformation passes are applied to the Device IR. These passes implement key semantic changes, such as the reduction rolling optimization, which converts a persistent reduction into a looped one.</span></li>
<li aria-level="1"><b>Codegen with Configuration:</b><span> In the final stage, the code generator takes two inputs: the transformed Device IR and the autotuned config. It uses these to generate the final output Triton code.</span></li>
</ol>
<p><span>A key architectural decision is that the performance-critical config is applied only at the very end of the pipeline during code generation. This allows the majority of the compilation process, from parsing to IR transformation, to be run just once before the autotuning search, making the exploration of thousands of configurations computationally efficient.</span></p>
<h2><b>Conclusions</b></h2>
<p><span>Helion addresses a critical gap in today’s kernel authoring space for machine learning. By combining a familiar and high-level PyTorch-like syntax with a powerful, ahead-of-time autotuning engine, it provides a unique balance of developer productivity, fine-grained control, and performance portability. It empowers developers to write portable, future-proof kernels that achieve state-of-the-art performance without requiring deep hardware expertise, establishing a new and a more productive paradigm for performant machine learning kernels.</span></p>
<p><span>Helion is being released in Beta on Oct. 22nd, 2025, and we welcome feedback, bug reports, and contributions from the community. For more information, see:</span></p>
<ul>
<li aria-level="1"><a href="https://github.com/pytorch/helion"><span>Helion Source Code</span></a></li>
<li aria-level="1"><a href="https://helionlang.com/"><span>Helion Documentation</span></a></li>
<li aria-level="1"><a href="https://pytorchconference.sched.com/event/27QDl/helion-a-high-level-dsl-for-kernel-authoring-jason-ansel-meta?iframe=yes&amp;w=100%&amp;sidebar=yes&amp;bg=no"><span>Helion talk at PTC 2025</span></a></li>
</ul>
<p><span>Acknowledgements</span></p>
<p><i><span>Helion is the work of many hands including: Jason Ansel, Oguz Ulgen, Will Feng, Jongsok Choi, Markus Hoehnerbach, Manman Ren, Jie Liu, Paul Zhang, Driss Guessous, Joy Dong, Xuan Zhang, Karthick Panner Selvam, Peng Wu, Hongtao Yu, Neil Dhar, Nick Riasanovsky, Shane Nay, Alexey Loginov, as well as teams at Meta, NVIDIA, AMD, and Intel</span></i></p>
<p><span>Note: B200 Performance numbers updated 10/23. </span></p>
</div>        
      </div><!--/post-content-->
      
    </div><!--/inner-wrap-->
    
</article>
        </div><!--/post-area-->

            
        </div></div>
  </body>
</html>
