<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://rockyj-blogs.web.app/2025/10/25/result-monad.html">Original</a>
    <h1>Result is all I need</h1>
    
    <div id="readability-page-1" class="page"><div> <article>  <div>  <p>It has almost been a year since I last made a post. With everything in software development going the AI way and the small ideas I had, when I tried to put them in Claude I usually got the post I wanted to make in a few seconds. So it was kind of demotivating to spend hours on doing some research when people can get the same answer from AI anytime in seconds. Things have changed, now we need not search for answers, we need to ask the right questions üòÅ</p>
<p>Having said that, I still do not feel AI is there yet - yes, it is very good with small boilerplate stuff (and even then around 80% of the time) one cannot leave all development to AI if you really care about quality. Speaking of code quality, one major theme with AI churning out code is - <strong>code organization</strong>. Yes, AI can write code but if the code organization is not good, not only AI outputs worse code but at the end of the day code is all over the place - unreadable and unmaintainable.</p>
<p>So how do I personally look at code organization? There is no single or golden way, but working on mostly APIs and Web applications I tend to divide code based on some principles -</p>
<ul>
<li>Classes / modules / namespaces provide grouping of functions</li>
<li>Some classes are just pure data buckets, have as many of them as needed and do not put logic in them</li>
<li>Group logic holding classes / namespaces / modules by cohesive roles
<ul>
<li>It should be easy to look at a class / namespace / module <strong>name</strong> and guess its functions</li>
</ul>
</li>
<li>Divide and conquer, e.g. isolate the interfaces of the outside world from the internal logic</li>
<li>Interface level code or foundational code -
<ul>
<li>Controller classes for REST API (for example)</li>
<li>Database code (examples) - Entities &amp; Repositories</li>
<li>HTTP Clients</li>
<li>Other external interfaces like Kafka, SQS etc.</li>
<li>Configuration classes e.g. reading secrets from AWS Secret Manager</li>
<li>All these classes should be as stateless and isolated as possible, e.g. the kafka connection class should have no idea about the DB Connection and vice versa</li>
<li>This code should also not care about business logic, it should only care about its own interface / contract</li>
</ul>
</li>
<li>Service level code -
<ul>
<li>Provide small, isolated business logic slice on top of the interface code</li>
<li>Again as simple and stateless as possible, e.g. a function to create user in DB if none exists, push a message to SQS under certain conditions, upload a file to S3 etc.</li>
<li>At the end of the day the functions declared in the services should be ‚Äúsmall‚Äù - do only 1 thing in 1 function</li>
</ul>
</li>
<li>Now we have the ‚Äúfoundational code‚Äù and the ‚Äúservice level code‚Äù
<ul>
<li>The only thing that remains is some ‚Äúboilerplate stuff‚Äù like - logging, authorization checks etc. which can be sprinkled across code</li>
<li>All of this is very unit testable on its own</li>
<li>But something still needs to tie this all together</li>
</ul>
</li>
<li>All this goes back to most of my previous posts -
<ul>
<li>If all we can do is compose functions together, we are good!</li>
<li>Which now means, if we can confidently tie all our ‚Äúservice functions‚Äù, we can easily get our final working business logic</li>
<li>A ‚ÄúResult‚Äù is a neat object which is great at tying code together</li>
</ul>
</li>
</ul>
<p>So now, let us look at ways to write this final code which ties everything together. Assuming our service level code looks like this (not going deeper into the foundational code) -</p>
<div><figure><pre data-language="plaintext"><code><div><p><span>fun userExists(email: String): UUID? // -&gt; finds a user by email or returns null</span></p></div><div></div><div><p><span>fun register(</span></p></div><div><p><span><span>    </span></span><span>inputEmail: String,</span></p></div><div><p><span><span>    </span></span><span>password: String,</span></p></div><div><p><span>): UserDTO // -&gt; creates a user or can throw exception</span></p></div><div></div><div><p><span>fun verify(</span></p></div><div><p><span><span>    </span></span><span>email: String,</span></p></div><div><p><span><span>    </span></span><span>password: String,</span></p></div><div><p><span>): UUID? // -&gt; verifies a user email and password, can return null or throw exception</span></p></div></code></pre></figure></div>
<p>We see with these function signatures when we will tie them all together we will need to handle -</p>
<ul>
<li>Exceptions</li>
<li>Null values</li>
<li>And a mix of both</li>
</ul>
<p>So in an imperative style, this looks something like -</p>
<div><figure><pre data-language="plaintext"><code><div><p><span>@Service</span></p></div><div><p><span>class AuthCommand(</span></p></div><div><p><span><span>    </span></span><span>private val jwt: JWTService,</span></p></div><div><p><span><span>    </span></span><span>private val authService: AuthService,</span></p></div><div><p><span>) {</span></p></div><div><p><span><span>    </span></span><span>fun register(registrationRequest: UserRegistrationRequest): UserDTO {</span></p></div><div><p><span><span>        </span></span><span>val existingUserId = authService.userExists(registrationRequest.email)</span></p></div><div></div><div><p><span><span>        </span></span><span>if (existingUserId != null) {</span></p></div><div><p><span><span>            </span></span><span>throw RuntimeException(&#34;user already exists&#34;)</span></p></div><div><p><span><span>        </span></span><span>}</span></p></div><div></div><div><p><span><span>        </span></span><span>try {</span></p></div><div><p><span><span>            </span></span><span>val user = authService.register(registrationRequest.email, registrationRequest.password)</span></p></div><div></div><div><p><span><span>            </span></span><span>return user</span></p></div><div><p><span><span>        </span></span><span>} catch (exception: Exception) {</span></p></div><div><p><span><span>            </span></span><span>// log exception</span></p></div><div><p><span><span>            </span></span><span>throw exception</span></p></div><div><p><span><span>        </span></span><span>}</span></p></div><div><p><span><span>    </span></span><span>}</span></p></div><div></div><div><p><span><span>    </span></span><span>fun login(loginRequest: LoginRequest): String {</span></p></div><div><p><span><span>        </span></span><span>try {</span></p></div><div><p><span><span>            </span></span><span>val verifiedUserId = authService.verify(loginRequest.email, loginRequest.password)</span></p></div><div><p><span><span>                </span></span><span>?: throw RuntimeException(&#34;user not found&#34;)</span></p></div><div></div><div><p><span><span>            </span></span><span>val token =</span></p></div><div><p><span><span>                </span></span><span>jwt.signJWT(</span></p></div><div><p><span><span>                    </span></span><span>&#34;$verifiedUserId&#34;,</span></p></div><div><p><span><span>                    </span></span><span>audience = &#34;app&#34;,</span></p></div><div><p><span><span>                    </span></span><span>expirationMinutes = 60,</span></p></div><div><p><span><span>                    </span></span><span>customClaims = null,</span></p></div><div><p><span><span>                </span></span><span>)</span></p></div><div></div><div><p><span><span>            </span></span><span>return token</span></p></div><div></div><div><p><span><span>        </span></span><span>} catch (exception: Exception) {</span></p></div><div><p><span><span>            </span></span><span>throw exception</span></p></div><div><p><span><span>        </span></span><span>}</span></p></div><div><p><span><span>    </span></span><span>}</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div>
<p>While this code works, as the checks increase it is littered by <code>if</code>, <code>try</code>, <code>catch</code> statements which also will introduce mutability and although the core logic is 2-3 lines, we deal with the null checks and errors time and again. What really makes this worse is that in every such code which ties things together, we deal with these same problems again and again in slightly different ways.</p>
<p>If only there was a way to not care about null checks, errors and re-invent the wheel all the time. Enter - <strong>Result</strong>!</p>
<p>Without going into the formal definition of a <code>Result</code>, consider it as a ‚Äúwrapper‚Äù which internally handles null checks and exceptions so our code looks like -</p>
<div><figure><pre data-language="plaintext"><code><div><p><span>@Service</span></p></div><div><p><span>class AuthCommand(</span></p></div><div><p><span><span>    </span></span><span>private val jwt: JWTService,</span></p></div><div><p><span><span>    </span></span><span>private val authService: AuthService,</span></p></div><div><p><span>) {</span></p></div><div><p><span><span>    </span></span><span>fun register(registrationRequest: UserRegistrationRequest): UserDTO {</span></p></div><div><p><span><span>        </span></span><span>return success(registrationRequest)</span></p></div><div><p><span><span>            </span></span><span>.flatMap { validRequest -&gt;</span></p></div><div><p><span><span>                </span></span><span>throwIfExists(validRequest.email) { authService.userExists(validRequest.email) }</span></p></div><div><p><span><span>            </span></span><span>}.flatMap {</span></p></div><div><p><span><span>                </span></span><span>runWithSafety { authService.register(registrationRequest.email, registrationRequest.password) }</span></p></div><div><p><span><span>            </span></span><span>}.getOrThrow()</span></p></div><div><p><span><span>    </span></span><span>}</span></p></div><div></div><div><p><span><span>    </span></span><span>fun login(loginRequest: LoginRequest): String {</span></p></div><div><p><span><span>        </span></span><span>return success(loginRequest)</span></p></div><div><p><span><span>            </span></span><span>.flatMap { validRequest -&gt;</span></p></div><div><p><span><span>                </span></span><span>runWithSafety { authService.verify(validRequest.email, validRequest.password) }</span></p></div><div><p><span><span>            </span></span><span>}.flatMap { userId -&gt;</span></p></div><div><p><span><span>                </span></span><span>when (userId) {</span></p></div><div><p><span><span>                    </span></span><span>is UUID -&gt; success(userId)</span></p></div><div><p><span><span>                    </span></span><span>else -&gt; failure(ResponseStatusException(HttpStatus.BAD_REQUEST, &#34;user not found&#34;))</span></p></div><div><p><span><span>                </span></span><span>}</span></p></div><div><p><span><span>            </span></span><span>}</span></p></div><div><p><span><span>            </span></span><span>.flatMap { userId -&gt;</span></p></div><div><p><span><span>                </span></span><span>runWithSafety {</span></p></div><div><p><span><span>                    </span></span><span>jwt.signJWT(</span></p></div><div><p><span><span>                        </span></span><span>&#34;$userId&#34;,</span></p></div><div><p><span><span>                        </span></span><span>audience = &#34;app&#34;,</span></p></div><div><p><span><span>                        </span></span><span>expirationMinutes = 60,</span></p></div><div><p><span><span>                        </span></span><span>customClaims = null,</span></p></div><div><p><span><span>                    </span></span><span>)</span></p></div><div><p><span><span>                </span></span><span>}</span></p></div><div><p><span><span>            </span></span><span>}.getOrThrow()</span></p></div><div><p><span><span>    </span></span><span>}</span></p></div><div></div><div><p><span><span>    </span></span><span>private fun &lt;T&gt; throwIfExists(value: T, block: () -&gt; T): Result&lt;T&gt; {</span></p></div><div><p><span><span>        </span></span><span>return if (block() == null) {</span></p></div><div><p><span><span>            </span></span><span>success(value)</span></p></div><div><p><span><span>        </span></span><span>} else {</span></p></div><div><p><span><span>            </span></span><span>failure(ResponseStatusException(HttpStatus.BAD_REQUEST, &#34;user already exists&#34;))</span></p></div><div><p><span><span>        </span></span><span>}</span></p></div><div><p><span><span>    </span></span><span>}</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div>
<p>At the first glance, this code looks noisier and hard to understand (and that is why most people give up on FP), but if you look closely the <code>flatMap</code> operation just allows us to ‚Äúchain‚Äù functions together. Most of all, the code is very declarative now which means it is hard for bugs to creep in, we have more safety and a consistent way of doing things. The same pattern can be applied in all places and at the end of the day, the code is clean and compartmentalized.</p>
<p>How does the ‚ÄúResult‚Äù look like -</p>
<div><figure><pre data-language="plaintext"><code><div><p><span>sealed class Result&lt;out T&gt; {</span></p></div><div><p><span><span>    </span></span><span>data class Success&lt;T&gt;(</span></p></div><div><p><span><span>        </span></span><span>val value: T,</span></p></div><div><p><span><span>    </span></span><span>) : Result&lt;T&gt;()</span></p></div><div></div><div><p><span><span>    </span></span><span>data class Failure(</span></p></div><div><p><span><span>        </span></span><span>val error: Throwable,</span></p></div><div><p><span><span>    </span></span><span>) : Result&lt;Nothing&gt;()</span></p></div><div></div><div><p><span><span>    </span></span><span>companion object Factory {</span></p></div><div><p><span><span>        </span></span><span>fun &lt;T&gt; success(value: T): Result&lt;T&gt; = Success(value)</span></p></div><div></div><div><p><span><span>        </span></span><span>fun failure(error: Throwable): Result&lt;Nothing&gt; = Failure(Exception(&#34;error!&#34;, error))</span></p></div><div><p><span><span>        </span></span><span>fun failure(message: String): Result&lt;Nothing&gt; = Failure(Exception(message))</span></p></div><div></div><div><p><span><span>        </span></span><span>inline fun &lt;T&gt; runCatching(block: () -&gt; T): Result&lt;T&gt; =</span></p></div><div><p><span><span>            </span></span><span>try {</span></p></div><div><p><span><span>                </span></span><span>success(block())</span></p></div><div><p><span><span>            </span></span><span>} catch (e: Throwable) {</span></p></div><div><p><span><span>                </span></span><span>failure(e)</span></p></div><div><p><span><span>            </span></span><span>}</span></p></div><div><p><span><span>    </span></span><span>}</span></p></div><div></div><div><p><span><span>    </span></span><span>// Check if result is success/failure</span></p></div><div><p><span><span>    </span></span><span>val isSuccess: Boolean get() = this is Success</span></p></div><div><p><span><span>    </span></span><span>val isFailure: Boolean get() = this is Failure</span></p></div><div></div><div><p><span><span>    </span></span><span>// Get value or null</span></p></div><div><p><span><span>    </span></span><span>fun getOrNull(): T? =</span></p></div><div><p><span><span>        </span></span><span>when (this) {</span></p></div><div><p><span><span>            </span></span><span>is Success -&gt; value</span></p></div><div><p><span><span>            </span></span><span>is Failure -&gt; null</span></p></div><div><p><span><span>        </span></span><span>}</span></p></div><div></div><div><p><span><span>    </span></span><span>// Get error or null</span></p></div><div><p><span><span>    </span></span><span>fun errorOrNull(): Throwable? =</span></p></div><div><p><span><span>        </span></span><span>when (this) {</span></p></div><div><p><span><span>            </span></span><span>is Success -&gt; null</span></p></div><div><p><span><span>            </span></span><span>is Failure -&gt; error</span></p></div><div><p><span><span>        </span></span><span>}</span></p></div><div></div><div></div><div><p><span><span>    </span></span><span>// Get error or null</span></p></div><div><p><span><span>    </span></span><span>fun getOrError(): T =</span></p></div><div><p><span><span>        </span></span><span>when (this) {</span></p></div><div><p><span><span>            </span></span><span>is Success -&gt; value</span></p></div><div><p><span><span>            </span></span><span>is Failure -&gt; throw Exception(&#34;error!&#34;, error)</span></p></div><div><p><span><span>        </span></span><span>}</span></p></div><div><p><span>}</span></p></div><div></div><div><p><span>// ==================== PART 2: FACTORY FUNCTIONS ====================</span></p></div><div></div><div><p><span>// Create success result</span></p></div><div><p><span>fun &lt;T&gt; success(value: T): Result&lt;T&gt; = Result.Success(value)</span></p></div><div></div><div><p><span>// Create failure result</span></p></div><div><p><span>fun failure(error: Throwable): Result&lt;Nothing&gt; = Result.Failure(error)</span></p></div><div></div><div><p><span>fun failure(message: String): Result&lt;Nothing&gt; = Result.Failure(Exception(message))</span></p></div><div></div><div><p><span>// Wrap a potentially throwing operation</span></p></div><div><p><span>fun &lt;T&gt; runWithSafety(block: () -&gt; T): Result&lt;T&gt; =</span></p></div><div><p><span><span>    </span></span><span>try {</span></p></div><div><p><span><span>        </span></span><span>success(block())</span></p></div><div><p><span><span>    </span></span><span>} catch (e: Throwable) {</span></p></div><div><p><span><span>        </span></span><span>failure(e)</span></p></div><div><p><span><span>    </span></span><span>}</span></p></div></code></pre></figure></div>
<p>The full code is on <a href="https://github.com/rocky-jaiswal/new-spring-boot-demo">github</a>.</p>
<p><img src="https://rockyj-blogs.web.app/images/result_card.png" alt="Result"/></p>
<p>The <code>Result</code> monad (allows me to use the m-word roughly) is probably a great trick to tie up any function from anywhere. It can be written in any language that supports types and functional style of code e.g. TypeScript, Kotlin etc. Just write the foundational, service code (small and isolated) and at the end call it all safely together for a great result!</p> </div>   </article>  </div></div>
  </body>
</html>
