<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.fermyon.com/blog/introducing-spin-v3">Original</a>
    <h1>Spin 3.0 – open-source tooling for building and running WASM apps</h1>
    
    <div id="readability-page-1" class="page"><article>

                <nav>
                    <a href="https://www.fermyon.com/blog/index">
                        <img src="https://www.fermyon.com/static/image/arrow-green.svg" alt="Back to Blog index"/>
                        <span>Back</span>
                    </a>
                </nav>

                <div>

                    

                    

                    <div>
                            <p><img src="https://www.fermyon.com/static/image/avatar.png" alt="Radu Matei &amp; Michelle Dhanani"/>

                        <span>
                            Radu Matei &amp; Michelle Dhanani
                        </span></p><p>
                            <span>
                                <span>spin</span>
                                <span>webassembly</span>
                                <span>component</span>
                                <span>model</span>
                                <span>release</span>
                                <span>wasmtime</span>
                            </span>
                        </p>
                    </div>

                    <p><span>
                        <img src="https://www.fermyon.com/static/image/twc-introducing-spin-v3.jpg" alt="Introducing Spin 3.0"/>
 
                    </span>
                </p></div>

                
                <p>The Spin community is proud to introduce <a href="https://github.com/fermyon/spin/releases/tag/v3.0.0">Spin 3.0</a> — the latest major release of <a href="https://developer.fermyon.com/spin">Spin</a>, the open source developer tool for building, distributing, and running serverless WebAssembly (or Wasm) applications <em>everywhere</em>.</p>
<p>Since <a href="https://www.fermyon.com/blog/introducing-spin">the initial release of Spin back in 2022</a>, we have seen a growing community of passionate developers excited about the benefits they get from using Wasm: tiny, portable binaries, with <a href="https://fermyon.github.io/spin-benchmarks/criterion/reports/spin-executor__noop/concurrency-1/index.html">incredibly low startup latency</a> and massive throughput; and we have seen developers use Spin to build and run apps in some of the most diverse places: from Kubernetes and conventional cloud platforms, to cars, factory floors, or even experimenting with running Spin apps in space.</p>
<h2>Spin 3.0 Highlights</h2>
<p>We, the folks working on Spin, love Wasm for how lightweight it is, the quick cold start times and the superior safety guarantees. These properties make Wasm exciting for server side use cases, scenarios where containers are too slow or too big, situations where sandboxing is essential and for serverless use cases where you only want to use compute you actually need and portability is key. But Wasm is the gift that keeps on giving because we are just now scratching the surface of what Wasm can do for developers.</p>
<h3>Why We’re More Excited About Wasm Than Ever</h3>
<p>If you aren’t familiar, WebAssembly provides a common bytecode format and compile target across programming languages. The WebAssembly Component Model takes that a step further and standardizes interfaces for components using WebAssembly Interface Types (WIT). WIT enables components to interoperate regardless of what language the components were originally written in and that’s where things get even more exciting. When you compile to a WebAssembly component, you can then use that component as a library or a dependency in another program written in an <em>entirely different language</em>. Now, there’s a lot that goes into being able to do this behind the scenes, and it’s not an entirely simple task. </p>
<h3>Component Dependencies - Polyglot Programming Made Easy</h3>
<p>Spin 3.0 introduces a workflow for this type of development in the hopes of making it seamless to do things like write a library for some compute intensive task in Rust and use that as a dependency in a JavaScript application. Or perhaps you’re not a Rust developer and don’t feel like learning it overnight? No problem. Fetch a component someone else already built from an OCI registry. Component dependencies can be stored, discovered, and fetched from OCI registries giving you the npm/NuGet/<a href="http://crates.io">crates.io</a> style experience but for Wasm. Now, I think this particular feature is wild and could go on about it for at least a thesis, but there are even more Spin 3.0 topics to discuss so feel free to dig deeper in the component dependencies documentation <a href="https://developer.fermyon.com/spin/v3/writing-apps#using-component-dependencies">here</a> and in the demo later on.</p>
<h3>Selective Deployments - Build As One, Deploy Selectively</h3>
<p>You can now run a subset of components in a Spin application either locally with Spin CLI or <a href="https://www.spinkube.dev/docs/topics/selective-deployments">via SpinKube</a>. Spin 3.0 includes a new experimental flag: <code>spin up --component-id</code> that allows you to specify which components from your Spin application to run. In SpinKube, the containerd-shim-spin and spin-operator projects both support selective deployment of compoennts and there is a new <code>components</code> section in the SpinApp Custom Resource Definition (CRD) spec that enables selective deployment of components from a Spin application. This unlocks new scenarios for platform engineers who want to selectively run components on nodes that meets certain requirements. It also provides a streamlined workflow for developers who choose to develop a single Spin application containing multiple components while still giving platform engineers flexibility on how to split up and run components in a way that makes sense at deploy time.</p>
<h3>Deeper Integration With WASI Standards</h3>
<p>We’re big fans of standards in the Spin project. We both contribute to WASI APIs as we learn more about the needs of the community and also work to integrate them into the Spin project so folks can benefit from the collaboration and knowledge in the upstream WebAssembly community. With that said, we’re proud to announce that both the <a href="https://github.com/WebAssembly/wasi-keyvalue">WASI Key-Value</a> and <a href="https://github.com/WebAssembly/wasi-config">WASI Config</a> APIs are now officially supported in Spin. This marks an important next step in the journey to bringing <a href="https://github.com/WebAssembly/wasi-cloud-core">WASI cloud core</a>, a WASI proposal for standardizing a set of APIs applications can use to interact with a common set of cloud services, into Spin.</p>
<h3>OpenTelemetry (OTel) Integration - Observability With Batteries Included</h3>
<p>Observability is essential for today’s application development and runtime environments, and we’ve been experimenting with how to ensure Spin applications can integrate seamlessly into existing observability stacks since Spin 2.4. Spin 3.0 now officially supports <a href="https://developer.fermyon.com/spin/v2/observing-apps#observing-applications">OpenTelemetry (OTel) observability in Spin applications</a>. This unlocks integrating Spin application observability with all of the great tools you already use today like Grafana, Jaegar, Prometheus and more. Spin applications have the ability to export metrics and provide distributed tracing out of the box, not to mention the <a href="https://developer.fermyon.com/spin/v2/observing-apps#using-the-otel-plugin"><code>spin otel</code> plugin</a> makes setting up an observability stack even easier. We’re taking what we’ve learned and contributed upstream to the <a href="https://github.com/WebAssembly/wasi-observe">WASI observe</a> specification and are working with the community to continue to tackle improvements in this area.</p>
<h3>Spin Factors - A Major Runtime Refactor</h3>
<p>Last but not least for this post, we’ve done a HUGE refactor of the Spin internals with a feature called Spin Factors where a “factor” encapsulates a host functionality feature. Before Factors, host functionality was encapsulated in what we called “host components” but the more we added to Spin, the “soup-ier” things got. Another factor (get it?) in the creation of Spin Factors was the increase in the number of projects that are embedding Spin. These embeddings have slightly different environments and needs so we outgrew this concept of a “host component” and built an entirely new abstraction called Spin Factors based on these learnings. In turn, this allows the Spin runtime to be more modular. Everyone is a snowflake and we’re here for that. It’s also a bit easier now to extend the Spin runtime for your needs albeit it does require forking the project, but it’s possible and a big step in the right direction.</p>
<h2>Demos - Spin 3.0 In Action</h2>
<p>Here is an example of what you can do with the new component dependencies feature in Spin 3.0. This is all built on top of the standards work happening across the ecosystem, with the streamlined developer experience we are building into Spin.</p>
<p>The workload scenario is simple. We are building an image transformation application with 3 major components:</p>
<ul>
<li>a front-end component where users can upload images and select their transformation</li>
<li>an HTTP API component that receives images uploaded by users and the desired transformation</li>
<li>an image manipulation component that performs the actual transformation</li>
</ul>
<p>The common solution today is to use the same programming language for both your HTTP API component and the image manipulation component. If that is not possible or performant enough, then you might split the image manipulation component into its own microservice.</p>
<p>Using the power of Spin 3.0, we are going to use the new component dependency feature to build the image manipulation component in Rust, and consume that as a dependency from a JavaScript/TypeScript component that will act as our HTTP API. This shows the power of component dependencies feature as it allows us to use the right tool for the job.</p>
<p>Let’s start with writing <a href="https://github.com/radu-matei/spin-deps-image-manipulation/blob/main/lib/wit/world.wit">the interface for our image manipulation component</a>. We’ll define our image manipulation package (using <a href="https://github.com/WebAssembly/component-model/blob/main/design/mvp/WIT.md">the WIT format</a>) which contains one interface with two image transformations (grayscale and sepia):</p>
<pre><code>package component:image-manipulation-lib;
...
/// Image manipulation interface.
interface image-manipulation {
    /// Error returned by image manipulation components.
    variant image-error {
        image-error(string),
        io-error(string),
        unknown(string),
    }
    /// Type representing an image.
    type image = list&lt;u8&gt;;
    /// Apply the grayscale transformation to the input image.
    grayscale: func(img: image, quality: u8) -&gt; result&lt;image, image-error&gt;;
    /// Apply the sepia transformation to the input image.
    sepia: func(img: image, quality: u8) -&gt; result&lt;image, image-error&gt;;
}
</code></pre>
<p>To implement this component in Rust, we will use a cargo component and a popular Rust image transformation library (photon-rs). Here is what the skeleton of the component implementation looks like:</p>
<pre><code>impl Guest for Component {
    fn grayscale(img: Image, quality: u8) -&gt; Result&lt;Image, ImageError&gt; {
        // perform the grayscale transformation using a performant Rust lib
    }

    fn sepia(img: Image, quality: u8) -&gt; Result&lt;Image, ImageError&gt; {
        // perform the sepia transformation using a performant Rust lib
    }
}
</code></pre>
<p>We can build this into a Wasm component using cargo component. Now we’re now ready to publish this component to an OCI compliant registry using the latest work of the ecosystem around distributing Wasm components, <a href="https://github.com/bytecodealliance/wasm-pkg-tools">wkg</a>, or the new experimental plugin we are building for Spin that uses it, <a href="https://github.com/fermyon/spin-deps-plugin"><code>spin deps</code></a>:</p>
<pre><code>$ cargo component build --release
  Generating bindings for image-manipulation-lib (src/bindings.rs)
   Compiling image-manipulation-lib v0.1.0
    Finished `release` profile [optimized] target(s) in 5.20s
    Creating component target/wasm32-wasip1/release/image_manipulation_lib.wasm

$ spin deps publish target/wasm32-wasip1/release/image_manipulation_lib.wasm \
    --registry fermyon.com \
    --package fermyon-experimental:image-manipulation-lib@6.0.0
	
    Published fermyon-experimental:image-manipulation-lib@6.0.0
</code></pre>
<p>We now have <a href="https://github.com/orgs/fermyon/packages/container/wasm-pkg%2Ffermyon-experimental%2Fimage-manipulation-lib/302562897?tag=6.0.0">a Wasm component that is published in a registry</a> that we can now consume from a Wasm component written in an entirely different language!</p>
<p>We can continue building our image manipulation service by creating the HTTP API component in TypeScript which takes a dependency on the Rust component we just built:</p>
<pre><code># create a new Spin application based on the TypeScript template
$ spin new -t http-ts image-manipulation-http-api

# add a dependency to the image manipulation component we pushed to the registry
$ spin deps add --registry fermyon.com \
		fermyon-experimental:image-manipulation-lib@6.0.0
</code></pre>
<p>The <code>spin deps</code> plugin walks us through selecting the right interface from the package we published and adds it as a dependency to our TypeScript component in the application manifest (spin.toml):</p>
<pre><code>[component.image-manipulation-http-api.dependencies]
&#34;component:image-manipulation-lib/image-manipulation&#34; = { 
    version = &#34;^6.0.0&#34;, 
    registry = &#34;fermyon.com&#34;, 
    package = &#34;fermyon-experimental:image-manipulation-lib&#34; 
}
</code></pre>
<blockquote>
<p>Note: the spin deps plugin is experimental and will most likely change in the near future. If you are interested in dependency management and distributing Wasm components using registries, join our <a href="https://discord.gg/AAFNfS7NGf">Discord server</a>!</p>
</blockquote>
<p>We can now consume the dependency from our TypeScript component:</p>
<pre><code>import { grayscale, sepia } from &#34;component:image-manipulation-lib/image-manipulation&#34;

// ...

switch (transform) {
    case &#34;grayscale&#34;:
        transformed = grayscale(new Uint8Array(body), quality);
        break;
    case &#34;sepia&#34;:
        transformed = sepia(new Uint8Array(body), quality);
        break;
    default:
        throw new Error(&#34;Unknown image transform&#34;);
}
</code></pre>
<blockquote>
<p>Check the <a href="https://github.com/radu-matei/spin-deps-image-manipulation">demo repository</a> for the complete application and build setup. It also contains an example of consuming the same image manipulation component from a Rust HTTP API.</p>
</blockquote>
<p>You can use all the built-in Spin features for <a href="https://developer.fermyon.com/spin/v3/kv-store-api-guide">key/value data</a>, <a href="https://developer.fermyon.com/spin/v3/variables">configuration</a>, or <a href="https://developer.fermyon.com/spin/v3/sqlite-api-guide">relational databases</a>. If you need inspiration, the HTTP API component in this example uses the key/value store to cache transformed images.</p>
<p>At this point, we can build the entire application using <code>spin build</code> and run it locally using <code>spin up</code>, which takes care of all necessary steps for our composition.</p>
<p><img src="https://www.fermyon.com/static/image/blog/image-transformation.png" alt="Image Transformation"/></p>
<p>You can get full observability out of the box in your local setup using the <a href="https://developer.fermyon.com/spin/v2/observing-apps#using-the-otel-plugin">OpenTelemetry plugin</a> for Spin:</p>
<p><img src="https://www.fermyon.com/static/image/blog/observability-v3.png" alt="Observability"/></p>
<h2>State of the Ecosystem</h2>
<p>We’ve seen a number of CLI plugins and trigger plugins come about. Thank you to those who have contributed. There are also new releases of the SpinKube project. The containerd-shim-spin, spin-operator and spin kube CLI plugin all boast new features including <a href="https://www.spinkube.dev/docs/topics/selective-deployments">selective deployment</a>.</p>
<h2>Thank you!</h2>
<p>Thank you to everyone who has <a href="https://github.com/fermyon/spin/graphs/contributors">contributed to Spin 3</a>, filed issues, opened pull requests, participated in Discord and especially to our new contributors. We are excited to see the community grow and continue to iterate on building an even better experience for building and running serverless WebAssembly applications. Please join us at the weekly public Spin project meetings, in the discord channels and on the repository.</p>
<p>And a special thank you to everyone who has been contributing and continues contribute to the WebAssembly ecosystem particularly to the maintainers of the Bytecode Alliance projects, <a href="https://github.com/bytecodealliance/wasmtime/">the Wasmtime</a> project and the developers working on <a href="https://github.com/webassembly/wasi">WASI</a> and <a href="https://github.com/webassembly/component-model">the WebAssembly component model</a>. Their work is instrumental in supporting Spin.</p>
<h2>Stay In Touch</h2>
<p>Please join our weekly <a href="https://github.com/fermyon/spin#getting-involved-and-contributing">project meetings</a>, chat and random hangouts in the <a href="https://discord.gg/AAFNfS7NGf">Fermyon Discord server</a> and follow us on X (formerly Twitter) <a href="https://twitter.com/fermyontech/">@fermyontech</a> and <a href="https://twitter.com/spinframework">@spinframework</a>! If you’re at KubeCon, please stop our <a href="https://www.fermyon.com/kubeconna24">booth Q1</a> to say hey! We’d love to meet you in real life.</p>
  
            </article></div>
  </body>
</html>
