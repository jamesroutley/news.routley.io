<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://popovicu.com/posts/789-kb-linux-without-mmu-riscv/">Original</a>
    <h1>789 KB Linux Without MMU on RISC-V</h1>
    
    <div id="readability-page-1" class="page"><article id="article" role="article">
      <p><a href="https://twitter.com/popovicu94?ref_src=twsrc%5Etfw" data-show-count="false">Follow @popovicu94</a></p>
<p>In this guide, we’ll build a very tiny Linux kernel, weighing in at 789 K, and requiring <strong>no MMU support</strong>. We’ll write some userspace code and this will be deployed on a virtual RISC-V 64-bit machine, without MMU, and we’ll run some tiny programs of our own.</p>
<p>As a reminder, please go through <a href="https://popovicu.com/posts/making-a-micro-linux-distro/">the guide for a micro Linux distro</a> to understand the concepts behind what we’re doing today: building the kernel, <code>initramfs</code>, etc. This guide is basically a continuation of that one and an exercise in making an absolutely minimal Linux deployment for (in theory) extremely cheap hardware.</p>
<p>Like before, there’s very little here that is specific to RISC-V, I just want to stay consistent with my previous guides. This exercise should be easily repeatable for other architectures too (though <code>x86</code> may be somewhat sticky).</p>
<h2 id="table-of-contents">Table of contents</h2>
<details><summary>Open Table of contents</summary>
<ul>
<li>
<p><a href="#mmu-and-linux">MMU and Linux</a></p>
<ul>
<li><a href="#brief-history-of-uclinux">Brief history of uClinux</a></li>
</ul>
</li>
<li>
<p><a href="#challenges-with-mmu-less-linux">Challenges with MMU-less Linux</a></p>
<ul>
<li><a href="#executable-file-format">Executable file format</a></li>
<li><a href="#pointers-are-dangerous-obviously">Pointers are dangerous (obviously!)</a></li>
<li><a href="#vfork-instead-of-fork"><code>vfork</code> instead of <code>fork</code></a></li>
</ul>
</li>
<li>
<p><a href="#building-binaries-for-an-mmu-less-kernel">Building binaries for an MMU-less kernel</a></p>
<ul>
<li><a href="#getting-the-toolchain">Getting the toolchain</a></li>
<li><a href="#building-the-toolchain">Building the toolchain</a></li>
<li><a href="#building-bflt-files">Building bFLT files</a></li>
</ul>
</li>
<li>
<p><a href="#building-an-extremely-tiny-linux-kernel">Building an extremely tiny Linux kernel</a></p>
</li>
<li>
<p><a href="#building-an-initramfs-image-for-the-tiny-mmu-less-kernel">Building an <code>initramfs</code> image for the tiny MMU-less kernel</a></p>
</li>
<li>
<p><a href="#slightly-more-complicated-build-verifying-system-calls-and-multiprocessing">Slightly more complicated build: verifying system calls and multiprocessing</a></p>
</li>
<li>
<p><a href="#conclusion">Conclusion</a></p>
</li>
<li>
<p><a href="#github-repo">GitHub repo</a></p>
</li>
</ul>
</details>
<h2 id="mmu-and-linux">MMU and Linux</h2>
<p>An important piece of hardware when running an operating system is an <strong>MMU: memory management unit</strong>. This unit oversees memory accesses from a running CPU and translates them to different physical addresses. The reason why this is hugely important is because that is how the memory is <strong>virtualized</strong>, and the MMU is heavily used by the operating systems to implement a <strong>virtual address space</strong>. What this means is that the kernel typically enables the applications to not worry about how other running applications occupy the memory on a machine. Each process has an illusion of complete ownership of the memory, and the kernel facilitates that by virtualizing the memory. In other words, 2 processes on the same machine may use a memory location <code>0x12345678</code> and what they’d really be hitting inside the physical memory could be locations <code>0xAABBCCDD</code> and <code>0xDDCCBBAA</code>, respectively. The MMU, once set up by the kernel, will route the <code>0x12345678</code> accesses from each one of these applications to the relevant end physical address.</p>
<p>Your typical Linux build virtualizes the address space and uses the MMU for this, and while we didn’t explicitly set it in <a href="https://popovicu.com/posts/making-a-micro-linux-distro/">the previous guide</a>, MMU was used and the memory contents of one process were insulated from the other processes.</p>
<p>Now, as useful as MMU is, not all machines have it. The super simple budget-friendly microcontrollers typically do not have it, and the memory addresses coming out of the program running are actually what is used to access the memory. In this case, if a process accesses <code>0x12345678</code>, it will go to the address <code>0x12345678</code> indeed.</p>
<h3 id="brief-history-of-uclinux">Brief history of uClinux</h3>
<p>As Linux has been rising in popularity since its inception, there have been attempts to run it on pretty much any digital device. This includes popular <a href="https://en.wikipedia.org/wiki/Microcontroller">microcontrollers</a> that do not have an MMU attached. Enter <strong>uClinux</strong>.</p>
<p>The proper name for uClinux is actually μClinux, with a Greek ‘mu’, and so μC stands for ‘microcontroller’. We spell it as uClinux for ASCII-friendly simplicity.</p>
<p>The uClinux effort, per my understanding, was running independently for some time, before the decision has been made to <strong>mainline</strong> it, meaning it is now part of the Linux source code itself. Basically, what this means for us is that uClinux is now a set of configurations in the kernel build config, and we’ll get our MMU-less build easily.</p>
<h2 id="challenges-with-mmu-less-linux">Challenges with MMU-less Linux</h2>
<p>Before we get our hands dirty, I would like to highlight a few challenges with running Linux in this way. I will from this point refer to our Linux as MMU-less Linux, rather than uClinux to avoid confusion with the old project that has since been mainlined.</p>
<h3 id="executable-file-format">Executable file format</h3>
<p>First, ELF binaries will not work anymore. I have not been able to build a MMU-less flavor of Linux for ELF, and I strongly believe it is impossible. I’m not sure if something about the ELF format explicitly assumes a virtual address space necessarily, I don’t think it does, but it just seems impossible to load an ELF binary for running.</p>
<p>What MMU-less Linux likes are the <strong>bFLT</strong> binaries. FLT stands for <em>flat</em>, and this initially made me believe that there really is no file format here, that we’re supposed to just dump the machine instructions into a bare file, but this really isn’t the case. bFLT has some structure, which is far simpler than ELF, but it’s structured nonetheless. I personally found it very difficult to find any good documentation on what this file format really looks like, and really the only useful page I have found on the Internet around it is <a href="https://myembeddeddev.blogspot.com/2010/02/uclinux-flat-file-format.html">this page</a> from someone’s personal blog. It’s a bit interesting to think that if this blog goes offline, there really isn’t anything out there left except the actual source code in the Linux codebase, and I’m sure you agree that’s not the most elegant way to learn.</p>
<h3 id="pointers-are-dangerous-obviously">Pointers are dangerous (obviously!)</h3>
<p>It should be obvious, but I’ll still call it out — MMU is not routing our memory accesses now; whatever we access is really what we hit in the physical memory and this means that bad pointers are now very dangerous. You could easily corrupt the memory contents of another process or even the kernel itself.</p>
<p>This would be a great place to introduce something like Rust programming, but given that it was tricky to build bare C programs for this kind of a platform (more about it below), I would now just say it’s too early for that.</p>
<h3 id="vfork-instead-of-fork"><code>vfork</code> instead of <code>fork</code></h3>
<p>The <code>fork</code> system call does not work on an MMU-less Linux since that heavily depends on virtualizing the memory, and this may lead some people to believe that you can run only one process on a MMU-less Linux, but that is not correct, and we will show it later — multiprocessing is definitely possible.</p>
<p>The way you achieve multiprocessing is by simply using <code>vfork</code> instead of <code>fork</code>. I’ll keep things simple here and say that the difference between <code>vfork</code> and <code>fork</code> is that the parent process is sleeping until the child exits or calls <code>execve</code>. Please note that unless you <code>exec</code> into another binary from the child process, the child is running in <strong>the same memory space</strong>. Again, there is no MMU to help us out here.</p>
<h2 id="building-binaries-for-an-mmu-less-kernel">Building binaries for an MMU-less kernel</h2>
<p>As we mentioned before, we need to build bFLT binaries rather than ELFs. Figuring out how to exactly do this is what took most of my time in this exercise.</p>
<p>I’ll skip a lot of details and give you the end result, and I’m sure if you dig around why this is the end result, you’ll be able to quickly figure out what’s going on. Here it is: <strong>the simplest way to build bFLT binaries is with a uClibc toolchain</strong>.</p>
<p><code>uClibc</code> is basically a very slimmed down version of the C standard library, suitable for embedded systems. Of course, nothing is stopping you from using it outside of this context, for example, in a full blown desktop Linux distrbution.</p>
<p>Quick note: which flavor of the standard C library is the best is another frequent topic of debate.</p>
<h3 id="getting-the-toolchain">Getting the toolchain</h3>
<p>I strongly suggest building the <code>uClibc</code> toolchain from source. It’s very easy, since it is based on Buildroot.</p>
<p>Therefore, let’s head over to the <a href="https://buildroot.org/download.html">Buildroot download page</a>, fetch the latest release and unpack it. You can <code>cd</code> into the unpacked directory.</p>
<p>tl;dr on what Buildroot is: it is a massive collection of <code>Makefile</code>s that is typically used to build a Linux distribution for an embedded system. You can use it to drive the kernel download + build as well, though I personally prefer to do it separately. What I typically use Buildroot for is to fetch the sources of common tools and build the <code>initramfs</code> <code>cpio</code> archive containing them. If you don’t know what this means, please check the <a href="https://popovicu.com/posts/making-a-micro-linux-distro/">previous guide on making a micro Linux distro</a>. You configure the Buildroot flow almost the same as you configure the Linux kernel build flow: you run <code>make menuconfig</code>, toggle a bunch of options and you’re good to go. Buildroot is great because it has the scripts to pull and build a super wide range of common Linux tools and applications: <code>busybox</code>, <code>ip</code>, <code>vi</code>, <code>python</code>, <code>Xorg server</code> you name it.</p>
<p>Sadly, this is as much as the <a href="https://www.uclibc.org/toolchains.html">uClibc toolchain page</a> says. Personally, I was a bit puzzled after reading it: how do I use the toolchain and how do I build the binaries for <code>uClinux</code>? I’ll cover that part right now.</p>
<h3 id="building-the-toolchain">Building the toolchain</h3>
<p>Now that you have Buildroot downloaded, you can build the <code>uClibc</code> toolchain, which basically means you’ll have a GCC set of tools to compile with against it. I was always under the impression that changing which standard library you want is a matter of just providing a different standard library to any GCC compiler, but after some digging online, my understanding now is that the GCC needs to be specifically compiled against it somehow. It’s a bit beyond my understanding at the moment, to be perfectly honest.</p>
<ol>
<li>As mentioned above, you can do <code>make menuconfig</code> from your unpacked Buildroot directory.</li>
<li>Go to <code>Target options</code>, and select <code>RISCV</code> as the architecture.</li>
<li><code>Target architecture size</code> should be 64-bit.</li>
<li><strong>Unselect the MMU support</strong> option.</li>
<li><code>Target Binary Format</code> should be <strong>FLAT</strong>.</li>
<li><code>Target ABI</code> is fine as <code>lp64d</code>.</li>
<li>Go back to the main menu and head over to the <code>Toolchain</code> section.</li>
<li>C library should be <code>uClibc-ng</code>.</li>
<li>Select <code>Compile and install uClibc utilities</code>.</li>
<li>Save and exit.</li>
</ol>
<p>You should be all set up to build the toolchain. From the Buildroot directory, run the following:</p>
<pre is:raw="" tabindex="0"><code><span><span>make sdk</span></span></code></pre>
<p>This could take a while. Once it’s done, you should have your new toolchain under <code>output/host/bin/</code> within the Buildroot directory. Go ahead and <code>ls</code> that directory and you’ll see a bunch of stuff built in there, including your well known GCC tools. All we’ll be using is <code>riscv64-buildroot-linux-uclibc-gcc</code>, so make sure you hold on to that one.</p>
<h3 id="building-bflt-files">Building bFLT files</h3>
<p>bFLT files are, per my understanding, derived from the ELF files, actually. You use your GCC to get an ELF file, and then you use a tool called <code>elf2flt</code> to construct the bFLT file.</p>
<p>I have tried building <code>elf2flt</code> from source and using it, but I had a hard time getting the build to work in the first place. After many attempts, I gave up, but I was happy to realize that Buildroot provides <code>elf2flt</code>. In fact, when you <code>ls</code>‘ed the directory for your toolchain just a minute ago, you could see something like <code>riscv64-buildroot-linux-uclibc-elf2flt</code> in that directory. Once I realized this, I thought it was easy and I could just build a regular RISC-V ELF and convert it to bFLT with this tool — turns out it’s not that straightforward.</p>
<p>I lost hope I’d ever get this done, and then I tried having Buildroot build the whole <code>initramfs</code> for me. I was skeptical it would run properly with the MMU-less Linux, but it did, so that means there really is a way to do this properly and quickly. My hack was to look at the Buildroot logs for how it built some of the packages an observe what are the GCC flags it uses.</p>
<p>It turns out that I was missing the linker flag <code>-Wl,-elf2flt=-r</code> to make things work. This makes sure that the <code>elf2flt</code> is involved during the linking process and in the end, I got my bFLT file. I never had to run <code>elf2flt</code> myself. We’ll see a concrete detailed example later as we build a sample application.</p>
<p>First, let’s build a MMU-less kernel that we have something to run against.</p>
<h2 id="building-an-extremely-tiny-linux-kernel">Building an extremely tiny Linux kernel</h2>
<p>As this is an exercise in minimalism, we’ll build an extremely minimal Linux kernel. It will offer little more than a basic filesystem and running binaries on top of the kernel.</p>
<p><em>At this point, I assume you know how to build a Linux kernel in general. If you don’t, please look at the <a href="https://popovicu.com/posts/making-a-micro-linux-distro/">micro Linux distro guide</a> and familiarize yourself with the basic concepts before proceeding.</em></p>
<p>For simplicity, I’ll simply get the <code>tar</code> file from <code>kernel.org</code> for stable version <code>6.5.5</code>, though I believe if you see something newer as the latest, you can just go for it and nothing should change. Let’s download and unpack that.</p>
<p><strong>Here and below: my <code>CROSS_COMPILE</code> prefix may be different from what you need on your machine to invoke the build tools.</strong></p>
<p>Let’s begin by setting up a super minimal Linux configuration:</p>
<pre is:raw="" tabindex="0"><code><span><span>make ARCH=riscv CROSS_COMPILE=riscv64-linux-gnu- tinyconfig</span></span></code></pre>
<p>This <code>tinyconfig</code> really strips down the build to the most basic things. It doesn’t even have <code>printk</code> support, so you won’t be getting a whole lot of output by booting this. More accurately, it doesn’t even have the TTY support, so you really can’t even output anything through the standard methods like <code>printk</code>, and you wouldn’t be able to display something through UART or otherwise via standard output in the user space.</p>
<p>Let’s, however, build this (I run <code>make ARCH=riscv CROSS_COMPILE=riscv64-linux-gnu- -j16</code>) and see what we get out of it. I’m getting the following:</p>
<ul>
<li><code>arch/riscv/boot/Image</code> weighs in at 943 K.</li>
<li><code>arch/riscv/boot/Image.gz</code> weighs in at 559 K.</li>
</ul>
<p>This is good to know and we’ll use it as the baseline as we make the changes. Let’s do the following and make some changes to our build:</p>
<pre is:raw="" tabindex="0"><code><span><span>make ARCH=riscv CROSS_COMPILE=riscv64-linux-gnu- menuconfig</span></span></code></pre>
<p>The most important change we want to make is we want to disable the MMU facilities in the kernel. I’ve seen guides that say you can just drop a config line into the <code>.config</code> file because they don’t see the option to disable the MMU from <code>menuconfig</code>, but I would advise against it. I was able to get the option to appear, and I’m not sure if what they’re expericing is architecture specific, but for RISC-V, I was definitely able to get the option to disable the MMU stuff.</p>
<ol>
<li><code>CONFIG_NONPORTABLE</code> should be set to <code>y</code>. We are building for a specific machine and we want to enable non-portable builds as we know exactly what are the memory addresses we’d be deploying to.</li>
<li><code>CONFIG_MMU</code>: <code>n</code>. It should be obvious what this does. Note, we were unable to flip this to <code>n</code> before doing the step 1; we should be all good now.</li>
<li><code>PHYS_RAM_BASE_FIXED</code>: <code>y</code>. This means we’ll be deploying the kernel to a specific address in the memory.</li>
<li>Once you flip that, you can set <code>CONFIG_PHYS_RAM_BASE</code> to <code>0x80000000</code>. This makes perfect sense for us as this is where our execution will begin on the QEMU virtual machine. If you want to know more about it, please read the <a href="https://popovicu.com/posts/bare-metal-programming-risc-v/">bare metal guide</a> and the <a href="https://popovicu.com/posts/risc-v-sbi-and-full-boot-process/">SBI and boot process guide</a>. Those guides are lengthy, but they will enable you to fully understand what’s going on. That said, for the latter guide, please note that <strong>we are not</strong> using OpenSBI to boot here. We’re running a very light Linux, and we are not relying on the SBI infrastructure. This is much closer to bare metal programming than running Linux as you’re used to it.</li>
</ol>
<p>Let’s build this really quick and see if there are any changes. Save and exit, and run:</p>
<pre is:raw="" tabindex="0"><code><span><span>make ARCH=riscv CROSS_COMPILE=riscv64-linux-gnu- -j16</span></span></code></pre>
<p>Let’s weigh our kernel again:</p>
<ul>
<li><code>arch/riscv/boot/Image</code> weighs in at 789 K.</li>
<li><code>arch/riscv/boot/Image.gz</code> weighs in at 472 K.</li>
</ul>
<p>Wow, it’s significantly lighter! However, even though we disabled the MMU smartness from it, we still haven’t enabled any features and again, the <code>tinyconfig</code> is so tiny that it barely does anything. Let’s flip some more configurations:</p>
<ol>
<li><code>CONFIG_BLK_DEV_INITRD</code>: <code>y</code>. We need an <code>initramfs</code> image to be able to run our <code>init</code> process and start off some magic in the user space. Flip that to <code>y</code>.</li>
<li>The above will by default enable various compression support for the <code>initramfs</code>, but you can go ahead and disable them all. I will not list out all of them one by one (a single example is <code>CONFIG_RD_GZIP</code>), they should expand in <code>menuconfig</code> as <code>y</code> right under the option for enabling <code>initramfs</code>. You can flip them all to <code>n</code>, we don’t want to beef up our kernel image with compression algorithms now.</li>
<li><code>CONFIG_BINFMT_FLAT</code>: <code>y</code>. We need to add support for bFLT binaries. If you look at the same menu, there’s no mention of ELF: as soon as you disabled the MMU support, you lost the ELF binary support as well. We already knew this, so it’s not an issue, and as promised, we’ll talk about how to build bFLTs below on a concrete example. Let’s save and exit and build again:</li>
</ol>
<pre is:raw="" tabindex="0"><code><span><span>make ARCH=riscv CROSS_COMPILE=riscv64-linux-gnu- -j16</span></span></code></pre>
<ul>
<li><code>arch/riscv/boot/Image</code> weighs in at 789 K.</li>
<li><code>arch/riscv/boot/Image.gz</code> weighs in at 476 K.</li>
</ul>
<p>The only difference from the previous step is that the compressed image is slightly thicker, but it’s still tiny!</p>
<p>At this point, we have what we need to run an <code>init</code> process in user space!</p>
<h2 id="building-an-initramfs-image-for-the-tiny-mmu-less-kernel">Building an <code>initramfs</code> image for the tiny MMU-less kernel</h2>
<p>We’ll have a useless <code>init</code> that prints a message to UART and just goes to sleep. Notice an inconsistency? I said we’ll print to UART, but our <code>tinyconfig</code> has no UART drivers, no TTY, nothing. So how could this possibly work? Well, since we’re without an MMU, we can really target any physical address on the system. If you go through the <a href="https://popovicu.com/posts/bare-metal-programming-risc-v/">bare metal guide</a>, you’ll learn that the QEMU system we’ll be using to run this image has an UART device mapped out at <code>0x10000000</code>. We’ll be printing to UART through this address for two reasons:</p>
<ol>
<li>Most importantly, to illustrate that on MMU-less kernel you can access any physical address. This can be both good and bad, probably more bad and not only in terms of stability and being resilient to bugs, but also in terms of security if your system accepts any sort of user input.</li>
<li>We want to achieve extreme minimalism here in terms of the size of the build and see how far we can push the boundaries on how much we can slim the kernel down. Right now, it’s under 800 K, which is pretty cool. Bringing in drivers for TTY, UART, etc. would certaily add some weight to the size of our image.</li>
</ol>
<p>That said, here’s our C program:</p>
<pre is:raw="" tabindex="0"><code><span><span>#include</span><span> </span><span>&lt;string.h&gt;</span></span>
<span><span>#include</span><span> </span><span>&lt;unistd.h&gt;</span></span>
<span></span>
<span><span>volatile</span><span> </span><span>char</span><span> </span><span>*</span><span>UART </span><span>=</span><span> (</span><span>char*</span><span>) </span><span>0x</span><span>10000000</span><span>;</span></span>
<span></span>
<span><span>void</span><span> </span><span>print_to_uart</span><span>(</span><span>char</span><span> </span><span>*</span><span>message</span><span>) {</span></span>
<span><span>  </span><span>for</span><span> (</span><span>int</span><span> i </span><span>=</span><span> </span><span>0</span><span>; i </span><span>&lt;</span><span> </span><span>strlen</span><span>(message); i</span><span>++</span><span>) {</span></span>
<span><span>    </span><span>*</span><span>UART </span><span>=</span><span> </span><span>message</span><span>[i];</span></span>
<span><span>  }</span></span>
<span><span>}</span></span>
<span></span>
<span><span>int</span><span> </span><span>main</span><span>() {</span></span>
<span><span>  </span><span>print_to_uart</span><span>(</span><span>&#34;Hello world! Welcome to the Tiny Linux MMU-less kernel!</span><span>\n</span><span>&#34;</span><span>);</span></span>
<span></span>
<span><span>  </span><span>while</span><span> (</span><span>1</span><span>) {</span></span>
<span><span>    </span><span>sleep</span><span>(</span><span>1000</span><span>);</span></span>
<span><span>  }</span></span>
<span></span>
<span><span>  </span><span>return</span><span> </span><span>0</span><span>;</span></span>
<span><span>}</span></span></code></pre>
<p>Notice that we have an infinite loop: the <code>init</code> process is not supposed to ever really exit or the kernel falls into a panic (not that you would see it without <code>printk</code>, though).</p>
<p>Now is the time to compile this <code>init</code> to a bFLT file. This is where we’ll invoke the <code>uClibc</code> toolchain we had previously built. I run the following on my machine, and you only need to adjust the relevant paths to reproduce:</p>
<pre is:raw="" tabindex="0"><code><span><span>uros@uros-debian-desktop:/tmp/tiny/init$ /tmp/buildroot/buildroot-2023.02.5/output/host/bin/riscv64-buildroot-linux-uclibc-gcc -fPIC -Wl,-elf2flt=-r -Wall -static -o init init.c</span></span></code></pre>
<ul>
<li><code>-fPIC</code> is used to produce <strong>position independent code</strong>. This is crucial for understanding how bFLT binaries work on an MMU-less Linux. Since we’re directly going for the physical addresses, but we don’t know where exactly in memory our binary would be loaded, we can’t depend on any absolute address in our binary. If we did, we risk (and most likely will) hurting the memory of another process or the kernel itself. We simply can’t make any assumptions about the end memory addresses. Therefore, everything needs to be PC-relative in our code. If you don’t know what this means, please look this up online as it’s extremely important. tl;dr is that every memory access must be made with an offset relative to the CPU’s pointer to the current machine instruction, instead of accessing a hardcoded address. In other words, instead of accessing <code>0x1001</code> directly, we access with an offset of <code>1</code> if our program counter is at <code>0x1000</code>. This will still work if the binary loader places us at <code>0x2000</code> instead of <code>0x1000</code>; the former wouldn’t! Again, if you do not understand this concept, please review CPU addressing modes.</li>
<li><code>-Wl,-elf2flt=-r</code> is the magic flag we really needed from the toolchain. This ensures that <code>elf2flt</code> is invoked and that the end binary is able to relocate, meaning the loader can place it somewhere differently in memory and the binary should still work (owing to the <code>-fPIC</code> flag as well).</li>
<li>The rest of the flags should be familiar.</li>
</ul>
<p>This binary weighs in at onl 3.3 K, which is pretty light, especially for a statically linked binary. <code>uClibc</code> delivered on its promise of being light. Quick note here is that <code>elf2flt</code> also dropped a file called <code>init.gdb</code> which is an ELF file that you can use to do your <code>objdump</code> and whatnot with it to debug.</p>
<p>If you run <code>file init</code>, you should see something like this:</p>
<pre is:raw="" tabindex="0"><code><span><span>init: BFLT executable - version 4 ram gotpic</span></span></code></pre>
<p>This is what we needed. Let’s make a file called <code>file_list.txt</code> with a single line saying <code>init</code> and let’s make the <code>initramfs</code> image for this setup.</p>
<pre is:raw="" tabindex="0"><code><span><span>cpio -o -H newc &lt; file_list.txt &gt; initramfs.cpio</span></span></code></pre>
<p>Now that we have the kernel image and the <code>initramfs.cpio</code> file, we can fire this up in QEMU and see what we get.</p>
<pre is:raw="" tabindex="0"><code><span><span>uros@uros-debian-desktop:/tmp/linux/linux-6.5.5$ qemu-system-riscv64 -machine virt -cpu rv64,mmu=false -kernel /tmp/tiny/linux-6.5.5/arch/riscv/boot/Image -bios none -initrd /tmp/tiny/init/initramfs.cpio -nographic</span></span>
<span><span>Hello world! Welcome to the Tiny Linux MMU-less kernel!</span></span></code></pre>
<p>Awesome, we ran userspace code and even depended on a dangerous pointer to do something useful.</p>
<h2 id="slightly-more-complicated-build-verifying-system-calls-and-multiprocessing">Slightly more complicated build: verifying system calls and multiprocessing</h2>
<p>Instead of starting from a <code>tinyconfig</code> and working my way up, this time I start with the typical <code>defconfig</code>. From that point, I disabled a bunch of things like MMU (of course), networking, virtualization, etc. while retaining TTY, UART drivers and other useful goodies. Of course, nothing stops you from beginning with <code>tinyconfig</code> and adding incrementally, I just wanted to save myself some time. This time I ended up with images of these sizes:</p>
<ul>
<li><code>arch/riscv/boot/Image</code> weighs in at 4.1 M.</li>
<li><code>arch/riscv/boot/Image.gz</code> weighs in at 2.1 M.</li>
</ul>
<p>This is all much heavier than previously, but it comes with a bunch of cool features like ability to dump core, UART drivers, filesystem support, etc. The message I’m trying to send here is that kernel is full of amazing drivers and features that you can start taking advantage of by only adjusting your kernel build configuration. I ran the same <code>initramfs</code> image as above, and got much richer output with a lot of debug messages from the kernel:</p>
<pre is:raw="" tabindex="0"><code><span><span>uros@uros-debian-desktop:/tmp/linux/linux-6.5.5$ qemu-system-riscv64 -machine virt -cpu rv64,mmu=false -kernel /tmp/linux/linux-6.5.5/arch/riscv/boot/Image -bios none -initrd /tmp/tiny/init/initramfs.cpio -nographic</span></span></code></pre>
<pre is:raw="" tabindex="0"><code><span><span>[    0.000000] Linux version 6.5.5 (uros@uros-debian-desktop) (riscv64-linux-gnu-gcc (Debian 10.2.1-6) 10.2.1 20210110, GNU ld (GNU Binutils for Debian) 2.35.2) #9 Wed Oct  4 00:07:07 PDT 2023</span></span>
<span><span>[    0.000000] Machine model: riscv-virtio,qemu</span></span>
<span><span>[    0.000000] Zone ranges:</span></span>
<span><span>[    0.000000]   DMA32    [mem 0x0000000080000000-0x0000000087ffffff]</span></span>
<span><span>[    0.000000]   Normal   empty</span></span>
<span><span>[    0.000000] Movable zone start for each node</span></span>
<span><span>[    0.000000] Early memory node ranges</span></span>
<span><span>[    0.000000]   node   0: [mem 0x0000000080000000-0x0000000087ffffff]</span></span>
<span><span>[    0.000000] Initmem setup node 0 [mem 0x0000000080000000-0x0000000087ffffff]</span></span>
<span><span>[    0.000000] riscv: base ISA extensions acdfim</span></span>
<span><span>[    0.000000] riscv: ELF capabilities acdfim</span></span>
<span><span>[    0.000000] Kernel command line:</span></span>
<span><span>[    0.000000] Dentry cache hash table entries: 16384 (order: 5, 131072 bytes, linear)</span></span>
<span><span>[    0.000000] Inode-cache hash table entries: 8192 (order: 4, 65536 bytes, linear)</span></span>
<span><span>[    0.000000] Built 1 zonelists, mobility grouping on.  Total pages: 32320</span></span>
<span><span>[    0.000000] mem auto-init: stack:off, heap alloc:off, heap free:off</span></span>
<span><span>[    0.000000] Memory: 124576K/131072K available (2526K kernel code, 684K rwdata, 809K rodata, 141K init, 276K bss, 6496K reserved, 0K cma-reserved)</span></span>
<span><span>[    0.000000] SLUB: HWalign=64, Order=0-3, MinObjects=0, CPUs=1, Nodes=1</span></span>
<span><span>[    0.000000] NR_IRQS: 64, nr_irqs: 64, preallocated irqs: 0</span></span>
<span><span>[    0.000000] riscv-intc: 64 local interrupts mapped</span></span>
<span><span>[    0.000000] plic: plic@c000000: mapped 53 interrupts with 1 handlers for 2 contexts.</span></span>
<span><span>[    0.000000] clint: clint@2000000: timer running at 10000000 Hz</span></span>
<span><span>[    0.000000] clocksource: clint_clocksource: mask: 0xffffffffffffffff max_cycles: 0x24e6a1710, max_idle_ns: 440795202120 ns</span></span>
<span><span>[    0.000062] sched_clock: 64 bits at 10MHz, resolution 100ns, wraps every 4398046511100ns</span></span>
<span><span>[    0.003318] Console: colour dummy device 80x25</span></span>
<span><span>[    0.003525] printk: console [tty0] enabled</span></span>
<span><span>[    0.006416] Calibrating delay loop (skipped), value calculated using timer frequency.. 20.00 BogoMIPS (lpj=40000)</span></span>
<span><span>[    0.006531] pid_max: default: 32768 minimum: 301</span></span>
<span><span>[    0.007085] Mount-cache hash table entries: 512 (order: 0, 4096 bytes, linear)</span></span>
<span><span>[    0.007131] Mountpoint-cache hash table entries: 512 (order: 0, 4096 bytes, linear)</span></span>
<span><span>[    0.019370] RCU Tasks Trace: Setting shift to 0 and lim to 1 rcu_task_cb_adjust=1.</span></span>
<span><span>[    0.024447] devtmpfs: initialized</span></span>
<span><span>[    0.028181] clocksource: jiffies: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 7645041785100000 ns</span></span>
<span><span>[    0.028380] futex hash table entries: 256 (order: 1, 12288 bytes, linear)</span></span>
<span><span>[    0.045655] clocksource: Switched to clocksource clint_clocksource</span></span>
<span><span>[    0.060880] Unpacking initramfs...</span></span>
<span><span>[    0.064002] workingset: timestamp_bits=62 max_order=15 bucket_order=0</span></span>
<span><span>[    0.066160] io scheduler mq-deadline registered</span></span>
<span><span>[    0.066228] io scheduler kyber registered</span></span>
<span><span>[    0.113049] Serial: 8250/16550 driver, 4 ports, IRQ sharing disabled</span></span>
<span><span>[    0.119589] 10000000.uart: ttyS0 at MMIO 0x10000000 (irq = 4, base_baud = 230400) is a 16550A</span></span>
<span><span>[    0.120520] printk: console [ttyS0] enabled</span></span>
<span><span>[    0.134884] goldfish_rtc 101000.rtc: registered as rtc0</span></span>
<span><span>[    0.135476] goldfish_rtc 101000.rtc: setting system clock to 2023-10-04T19:51:49 UTC (1696449109)</span></span>
<span><span>[    0.148278] sysfs: cannot create duplicate filename &#39;/kernel/slab/:a-0000016&#39;</span></span>
<span><span>[    0.148656] CPU: 0 PID: 1 Comm: swapper Not tainted 6.5.5 #9</span></span>
<span><span>[    0.148979] Hardware name: riscv-virtio,qemu (DT)</span></span>
<span><span>[    0.149245] Call Trace:</span></span>
<span><span>[    0.149490] [&lt;0000000080003230&gt;] dump_backtrace+0x1c/0x24</span></span>
<span><span>[    0.150053] [&lt;000000008026c1ac&gt;] show_stack+0x2c/0x38</span></span>
<span><span>[    0.150297] [&lt;0000000080271822&gt;] dump_stack_lvl+0x20/0x32</span></span>
<span><span>[    0.150546] [&lt;0000000080271848&gt;] dump_stack+0x14/0x1c</span></span>
<span><span>[    0.150784] [&lt;000000008012b4d4&gt;] sysfs_warn_dup+0x52/0x66</span></span>
<span><span>[    0.151040] [&lt;000000008012b590&gt;] sysfs_create_dir_ns+0xa8/0xba</span></span>
<span><span>[    0.151331] [&lt;0000000080252640&gt;] kobject_add_internal+0x90/0x1ca</span></span>
<span><span>[    0.151638] [&lt;0000000080252878&gt;] kobject_init_and_add+0x50/0x84</span></span>
<span><span>[    0.151937] [&lt;00000000800cabe2&gt;] sysfs_slab_add+0x102/0x1d4</span></span>
<span><span>[    0.152216] [&lt;0000000080283388&gt;] slab_sysfs_init+0x8a/0xf6</span></span>
<span><span>[    0.152451] [&lt;000000008027959c&gt;] do_one_initcall+0x64/0x11e</span></span>
<span><span>[    0.152736] [&lt;0000000080279806&gt;] kernel_init_freeable+0x158/0x1b0</span></span>
<span><span>[    0.153051] [&lt;00000000802726a2&gt;] kernel_init+0x1c/0xea</span></span>
<span><span>[    0.153319] [&lt;0000000080001cde&gt;] ret_from_fork+0xa/0x1c</span></span>
<span><span>[    0.153728] kobject: kobject_add_internal failed for :a-0000016 with -EEXIST, don&#39;t try to register things with the same name in the same directory.</span></span>
<span><span>[    0.154345] SLUB: Unable to add boot slab kmalloc-rcl-8 to sysfs</span></span>
<span><span>[    0.156569] sysfs: cannot create duplicate filename &#39;/kernel/slab/:0000016&#39;</span></span>
<span><span>[    0.156885] CPU: 0 PID: 1 Comm: swapper Not tainted 6.5.5 #9</span></span>
<span><span>[    0.157159] Hardware name: riscv-virtio,qemu (DT)</span></span>
<span><span>[    0.157378] Call Trace:</span></span>
<span><span>[    0.157500] [&lt;0000000080003230&gt;] dump_backtrace+0x1c/0x24</span></span>
<span><span>[    0.157809] [&lt;000000008026c1ac&gt;] show_stack+0x2c/0x38</span></span>
<span><span>[    0.158071] [&lt;0000000080271822&gt;] dump_stack_lvl+0x20/0x32</span></span>
<span><span>[    0.158354] [&lt;0000000080271848&gt;] dump_stack+0x14/0x1c</span></span>
<span><span>[    0.158620] [&lt;000000008012b4d4&gt;] sysfs_warn_dup+0x52/0x66</span></span>
<span><span>[    0.158899] [&lt;000000008012b590&gt;] sysfs_create_dir_ns+0xa8/0xba</span></span>
<span><span>[    0.159212] [&lt;0000000080252640&gt;] kobject_add_internal+0x90/0x1ca</span></span>
<span><span>[    0.159518] [&lt;0000000080252878&gt;] kobject_init_and_add+0x50/0x84</span></span>
<span><span>[    0.159815] [&lt;00000000800cabe2&gt;] sysfs_slab_add+0x102/0x1d4</span></span>
<span><span>[    0.160101] [&lt;0000000080283388&gt;] slab_sysfs_init+0x8a/0xf6</span></span>
<span><span>[    0.160399] [&lt;000000008027959c&gt;] do_one_initcall+0x64/0x11e</span></span>
<span><span>[    0.160693] [&lt;0000000080279806&gt;] kernel_init_freeable+0x158/0x1b0</span></span>
<span><span>[    0.161010] [&lt;00000000802726a2&gt;] kernel_init+0x1c/0xea</span></span>
<span><span>[    0.161278] [&lt;0000000080001cde&gt;] ret_from_fork+0xa/0x1c</span></span>
<span><span>[    0.161598] kobject: kobject_add_internal failed for :0000016 with -EEXIST, don&#39;t try to register things with the same name in the same directory.</span></span>
<span><span>[    0.162289] SLUB: Unable to add boot slab kmalloc-8 to sysfs</span></span>
<span><span>[    0.162761] SLUB: Unable to add boot slab alias ep_head to sysfs</span></span>
<span><span>[    0.163061] SLUB: Unable to add boot slab alias blkdev_ioc to sysfs</span></span>
<span><span>[    0.164939] Legacy PMU implementation is available</span></span>
<span><span>[    0.165494] clk: Disabling unused clocks</span></span>
<span><span>[    0.178717] Freeing unused kernel image (initmem) memory: 140K</span></span>
<span><span>[    0.178974] This architecture does not have kernel memory protection.</span></span>
<span><span>[    0.179296] Run /init as init process</span></span>
<span><span>Hello world! Welcome to the Tiny Linux MMU-less kernel!</span></span></code></pre>
<p>Let’s write an <code>init</code> that starts a bunch of other processes and verifies that multiprocessing keeps working after they’re spawned.</p>
<p><code>init.c</code> below:</p>
<pre is:raw="" tabindex="0"><code><span><span>#include</span><span> </span><span>&lt;stdio.h&gt;</span></span>
<span><span>#include</span><span> </span><span>&lt;stdlib.h&gt;</span></span>
<span><span>#include</span><span> </span><span>&lt;unistd.h&gt;</span></span>
<span></span>
<span><span>int</span><span> </span><span>main</span><span>(</span><span>int</span><span> </span><span>argc</span><span>,</span><span> </span><span>char</span><span> </span><span>*</span><span>argv</span><span>[]</span><span>) {</span></span>
<span><span>  </span><span>printf</span><span>(</span><span>&#34;Hello world</span><span>\n</span><span>&#34;</span><span>);</span></span>
<span></span>
<span><span>  </span><span>for</span><span> (</span><span>int</span><span> i </span><span>=</span><span> </span><span>0</span><span>; i </span><span>&lt;</span><span> </span><span>3</span><span>; i</span><span>++</span><span>) {</span></span>
<span><span>    </span><span>pid_t</span><span> pid;</span></span>
<span></span>
<span><span>    </span><span>if</span><span> ((pid </span><span>=</span><span> </span><span>vfork</span><span>()) </span><span>&lt;</span><span> </span><span>0</span><span>) {</span></span>
<span><span>      </span><span>fprintf</span><span>(stderr, </span><span>&#34;Could not fork a worker at iteration </span><span>%d</span><span>\n</span><span>&#34;</span><span>, i);</span></span>
<span><span>      </span><span>exit</span><span>(</span><span>1</span><span>);</span></span>
<span><span>    }</span></span>
<span></span>
<span><span>    </span><span>if</span><span> (pid </span><span>==</span><span> </span><span>0</span><span>) {</span></span>
<span><span>      </span><span>// Child process</span></span>
<span><span>      </span><span>char</span><span> </span><span>*</span><span>args</span><span>[</span><span>2</span><span>] </span><span>=</span><span> { </span><span>&#34;worker&#34;</span><span>, </span><span>NULL</span><span> };</span></span>
<span><span>      </span><span>execv</span><span>(</span><span>&#34;/worker&#34;</span><span>, args);</span></span>
<span><span>    }</span></span>
<span><span>  }</span></span>
<span></span>
<span><span>  </span><span>while</span><span> (</span><span>1</span><span>) {</span></span>
<span><span>    </span><span>sleep</span><span>(</span><span>5</span><span>);</span></span>
<span><span>    </span><span>printf</span><span>(</span><span>&#34;Hello from init</span><span>\n</span><span>&#34;</span><span>);</span></span>
<span><span>  }</span></span>
<span></span>
<span><span>  </span><span>return</span><span> </span><span>0</span><span>;</span></span>
<span><span>}</span></span></code></pre>
<p><code>worker.c</code> below:</p>
<pre is:raw="" tabindex="0"><code><span><span>#include</span><span> </span><span>&lt;stdio.h&gt;</span></span>
<span><span>#include</span><span> </span><span>&lt;unistd.h&gt;</span></span>
<span></span>
<span><span>int</span><span> </span><span>main</span><span>(</span><span>int</span><span> </span><span>argc</span><span>,</span><span> </span><span>char</span><span> </span><span>*</span><span>argv</span><span>[]</span><span>) {</span></span>
<span><span>  </span><span>while</span><span> (</span><span>1</span><span>) {</span></span>
<span><span>    </span><span>printf</span><span>(</span><span>&#34;Hello from worker!</span><span>\n</span><span>&#34;</span><span>);</span></span>
<span><span>    </span><span>sleep</span><span>(</span><span>3</span><span>);</span></span>
<span><span>  }</span></span>
<span></span>
<span><span>  </span><span>return</span><span> </span><span>0</span><span>;</span></span>
<span><span>}</span></span></code></pre>
<p>We build them the same way as the <code>init</code> we built before and package them into a <code>cpio</code> archive. Running this in QEMU for some time gives the following:</p>
<pre is:raw="" tabindex="0"><code><span><span>uros@uros-debian-desktop:/tmp/linux/linux-6.5.5$ qemu-system-riscv64 -machine virt -cpu rv64,mmu=false -kernel /tmp/linux/linux-6.5.5/arch/riscv/boot/Image -bios none -initrd /tmp/linux/init/initramfs.cpio -nographic</span></span></code></pre>
<pre is:raw="" tabindex="0"><code><span><span>[    0.000000] Linux version 6.5.5 (uros@uros-debian-desktop) (riscv64-linux-gnu-gcc (Debian 10.2.1-6) 10.2.1 20210110, GNU ld (GNU Binutils for Debian) 2.35.2) #9 Wed Oct  4 00:07:07 PDT 2023</span></span>
<span><span>[    0.000000] Machine model: riscv-virtio,qemu</span></span>
<span><span>[    0.000000] Zone ranges:</span></span>
<span><span>[    0.000000]   DMA32    [mem 0x0000000080000000-0x0000000087ffffff]</span></span>
<span><span>[    0.000000]   Normal   empty</span></span>
<span><span>[    0.000000] Movable zone start for each node</span></span>
<span><span>[    0.000000] Early memory node ranges</span></span>
<span><span>[    0.000000]   node   0: [mem 0x0000000080000000-0x0000000087ffffff]</span></span>
<span><span>[    0.000000] Initmem setup node 0 [mem 0x0000000080000000-0x0000000087ffffff]</span></span>
<span><span>[    0.000000] riscv: base ISA extensions acdfim</span></span>
<span><span>[    0.000000] riscv: ELF capabilities acdfim</span></span>
<span><span>[    0.000000] Kernel command line:</span></span>
<span><span>[    0.000000] Dentry cache hash table entries: 16384 (order: 5, 131072 bytes, linear)</span></span>
<span><span>[    0.000000] Inode-cache hash table entries: 8192 (order: 4, 65536 bytes, linear)</span></span>
<span><span>[    0.000000] Built 1 zonelists, mobility grouping on.  Total pages: 32320</span></span>
<span><span>[    0.000000] mem auto-init: stack:off, heap alloc:off, heap free:off</span></span>
<span><span>[    0.000000] Memory: 124544K/131072K available (2526K kernel code, 684K rwdata, 809K rodata, 141K init, 276K bss, 6528K reserved, 0K cma-reserved)</span></span>
<span><span>[    0.000000] SLUB: HWalign=64, Order=0-3, MinObjects=0, CPUs=1, Nodes=1</span></span>
<span><span>[    0.000000] NR_IRQS: 64, nr_irqs: 64, preallocated irqs: 0</span></span>
<span><span>[    0.000000] riscv-intc: 64 local interrupts mapped</span></span>
<span><span>[    0.000000] plic: plic@c000000: mapped 53 interrupts with 1 handlers for 2 contexts.</span></span>
<span><span>[    0.000000] clint: clint@2000000: timer running at 10000000 Hz</span></span>
<span><span>[    0.000000] clocksource: clint_clocksource: mask: 0xffffffffffffffff max_cycles: 0x24e6a1710, max_idle_ns: 440795202120 ns</span></span>
<span><span>[    0.000059] sched_clock: 64 bits at 10MHz, resolution 100ns, wraps every 4398046511100ns</span></span>
<span><span>[    0.003249] Console: colour dummy device 80x25</span></span>
<span><span>[    0.003442] printk: console [tty0] enabled</span></span>
<span><span>[    0.006336] Calibrating delay loop (skipped), value calculated using timer frequency.. 20.00 BogoMIPS (lpj=40000)</span></span>
<span><span>[    0.006447] pid_max: default: 32768 minimum: 301</span></span>
<span><span>[    0.007026] Mount-cache hash table entries: 512 (order: 0, 4096 bytes, linear)</span></span>
<span><span>[    0.007070] Mountpoint-cache hash table entries: 512 (order: 0, 4096 bytes, linear)</span></span>
<span><span>[    0.019398] RCU Tasks Trace: Setting shift to 0 and lim to 1 rcu_task_cb_adjust=1.</span></span>
<span><span>[    0.024599] devtmpfs: initialized</span></span>
<span><span>[    0.028455] clocksource: jiffies: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 7645041785100000 ns</span></span>
<span><span>[    0.028661] futex hash table entries: 256 (order: 1, 12288 bytes, linear)</span></span>
<span><span>[    0.046105] clocksource: Switched to clocksource clint_clocksource</span></span>
<span><span>[    0.061575] Unpacking initramfs...</span></span>
<span><span>[    0.064941] workingset: timestamp_bits=62 max_order=15 bucket_order=0</span></span>
<span><span>[    0.066491] io scheduler mq-deadline registered</span></span>
<span><span>[    0.066556] io scheduler kyber registered</span></span>
<span><span>[    0.073683] Freeing initrd memory: 32K</span></span>
<span><span>[    0.114913] Serial: 8250/16550 driver, 4 ports, IRQ sharing disabled</span></span>
<span><span>[    0.121398] 10000000.uart: ttyS0 at MMIO 0x10000000 (irq = 4, base_baud = 230400) is a 16550A</span></span>
<span><span>[    0.122456] printk: console [ttyS0] enabled</span></span>
<span><span>[    0.134615] goldfish_rtc 101000.rtc: registered as rtc0</span></span>
<span><span>[    0.135109] goldfish_rtc 101000.rtc: setting system clock to 2023-10-04T21:01:14 UTC (1696453274)</span></span>
<span><span>[    0.147392] sysfs: cannot create duplicate filename &#39;/kernel/slab/:a-0000016&#39;</span></span>
<span><span>[    0.147670] CPU: 0 PID: 1 Comm: swapper Not tainted 6.5.5 #9</span></span>
<span><span>[    0.147955] Hardware name: riscv-virtio,qemu (DT)</span></span>
<span><span>[    0.148164] Call Trace:</span></span>
<span><span>[    0.148375] [&lt;0000000080003230&gt;] dump_backtrace+0x1c/0x24</span></span>
<span><span>[    0.148861] [&lt;000000008026c1ac&gt;] show_stack+0x2c/0x38</span></span>
<span><span>[    0.149056] [&lt;0000000080271822&gt;] dump_stack_lvl+0x20/0x32</span></span>
<span><span>[    0.149257] [&lt;0000000080271848&gt;] dump_stack+0x14/0x1c</span></span>
<span><span>[    0.149435] [&lt;000000008012b4d4&gt;] sysfs_warn_dup+0x52/0x66</span></span>
<span><span>[    0.149626] [&lt;000000008012b590&gt;] sysfs_create_dir_ns+0xa8/0xba</span></span>
<span><span>[    0.149837] [&lt;0000000080252640&gt;] kobject_add_internal+0x90/0x1ca</span></span>
<span><span>[    0.150048] [&lt;0000000080252878&gt;] kobject_init_and_add+0x50/0x84</span></span>
<span><span>[    0.150284] [&lt;00000000800cabe2&gt;] sysfs_slab_add+0x102/0x1d4</span></span>
<span><span>[    0.150502] [&lt;0000000080283388&gt;] slab_sysfs_init+0x8a/0xf6</span></span>
<span><span>[    0.150695] [&lt;000000008027959c&gt;] do_one_initcall+0x64/0x11e</span></span>
<span><span>[    0.150887] [&lt;0000000080279806&gt;] kernel_init_freeable+0x158/0x1b0</span></span>
<span><span>[    0.151102] [&lt;00000000802726a2&gt;] kernel_init+0x1c/0xea</span></span>
<span><span>[    0.151291] [&lt;0000000080001cde&gt;] ret_from_fork+0xa/0x1c</span></span>
<span><span>[    0.151561] kobject: kobject_add_internal failed for :a-0000016 with -EEXIST, don&#39;t try to register things with the same name in the same directory.</span></span>
<span><span>[    0.152043] SLUB: Unable to add boot slab kmalloc-rcl-8 to sysfs</span></span>
<span><span>[    0.153186] sysfs: cannot create duplicate filename &#39;/kernel/slab/:0000016&#39;</span></span>
<span><span>[    0.153443] CPU: 0 PID: 1 Comm: swapper Not tainted 6.5.5 #9</span></span>
<span><span>[    0.153632] Hardware name: riscv-virtio,qemu (DT)</span></span>
<span><span>[    0.153778] Call Trace:</span></span>
<span><span>[    0.153873] [&lt;0000000080003230&gt;] dump_backtrace+0x1c/0x24</span></span>
<span><span>[    0.154056] [&lt;000000008026c1ac&gt;] show_stack+0x2c/0x38</span></span>
<span><span>[    0.154247] [&lt;0000000080271822&gt;] dump_stack_lvl+0x20/0x32</span></span>
<span><span>[    0.154440] [&lt;0000000080271848&gt;] dump_stack+0x14/0x1c</span></span>
<span><span>[    0.154614] [&lt;000000008012b4d4&gt;] sysfs_warn_dup+0x52/0x66</span></span>
<span><span>[    0.154816] [&lt;000000008012b590&gt;] sysfs_create_dir_ns+0xa8/0xba</span></span>
<span><span>[    0.155035] [&lt;0000000080252640&gt;] kobject_add_internal+0x90/0x1ca</span></span>
<span><span>[    0.155256] [&lt;0000000080252878&gt;] kobject_init_and_add+0x50/0x84</span></span>
<span><span>[    0.155481] [&lt;00000000800cabe2&gt;] sysfs_slab_add+0x102/0x1d4</span></span>
<span><span>[    0.155691] [&lt;0000000080283388&gt;] slab_sysfs_init+0x8a/0xf6</span></span>
<span><span>[    0.155906] [&lt;000000008027959c&gt;] do_one_initcall+0x64/0x11e</span></span>
<span><span>[    0.156119] [&lt;0000000080279806&gt;] kernel_init_freeable+0x158/0x1b0</span></span>
<span><span>[    0.156342] [&lt;00000000802726a2&gt;] kernel_init+0x1c/0xea</span></span>
<span><span>[    0.156525] [&lt;0000000080001cde&gt;] ret_from_fork+0xa/0x1c</span></span>
<span><span>[    0.156744] kobject: kobject_add_internal failed for :0000016 with -EEXIST, don&#39;t try to register things with the same name in the same directory.</span></span>
<span><span>[    0.157236] SLUB: Unable to add boot slab kmalloc-8 to sysfs</span></span>
<span><span>[    0.157663] SLUB: Unable to add boot slab alias ep_head to sysfs</span></span>
<span><span>[    0.157902] SLUB: Unable to add boot slab alias blkdev_ioc to sysfs</span></span>
<span><span>[    0.159238] Legacy PMU implementation is available</span></span>
<span><span>[    0.159650] clk: Disabling unused clocks</span></span>
<span><span>[    0.172328] Freeing unused kernel image (initmem) memory: 140K</span></span>
<span><span>[    0.172645] This architecture does not have kernel memory protection.</span></span>
<span><span>[    0.172948] Run /init as init process</span></span>
<span><span>Hello world</span></span>
<span><span>Hello from worker!</span></span>
<span><span>Hello from worker!</span></span>
<span><span>Hello from worker!</span></span>
<span><span>Hello from worker!</span></span>
<span><span>Hello from worker!</span></span>
<span><span>Hello from worker!</span></span>
<span><span>Hello from init</span></span>
<span><span>Hello from worker!</span></span>
<span><span>Hello from worker!</span></span>
<span><span>Hello from worker!</span></span>
<span><span>Hello from worker!</span></span>
<span><span>Hello from worker!</span></span>
<span><span>Hello from worker!</span></span>
<span><span>Hello from init</span></span></code></pre>
<p>Hopefully this clears up the confusion about whether multiprocessing is possible on a no-MMU kernel build. Additionally, we verified that the system calls work properly.</p>
<h2 id="conclusion">Conclusion</h2>
<p>We managed to build a very light Linux kernel for a system without an MMU. By building a custom <code>uClibc</code> toolchain we also managed to build bFLT binaries to run in the userspace. System calls and multiprocessing worked well and so we have a fully functional system.</p>
<p>We pushed the boundaries of a lightweight deployment through <code>tinyconfig</code>, and ended up running a userspace process that writes to UART by directly writing to the UART device, bypassing the kernel.</p>
<p>If all we want is to multi-task a bit on our device, Linux is likely an overkill, even in a tiny deployment like this. Additionally, if we’re not leveraging any drivers from the kernel code base, it’s probably another indicator we’re going too heavy. I leave it to you to decide if this lightweight Linux deployment makes sense for your usecase or not.</p>
<p>We could use Buildroot to add some of the well known tools to our system, potentially even make something interactive. I’ll stop here, however, as my goal was to bring up the absolutely minimal set up. Please connect with me and let me know if there is a way to make the set up I described above even lighter from the <code>tinyconfig</code>-based one.</p>
<p>I think this finally answers my question that I’ve had for a long time which is: what is the absolutely minimal Linux kernel? Something that runs on a single core, extremely simple, with as little cruft as possible, but that can still process some system calls and provide some sort of a filesystem. If anyone has been looking for this answer as well, I hope I am providing it correctly here.</p>
<p>The way I initially got to this question was I wanted to implement a minimal machine (in simulation or otherwise in FPGA) that can run something useful like some sort of a minimal Linux, and that I can program with at least some standard tooling like GCC. After studying my options, I think RISC-V and Linux are the answer, and the last few guides I have written are the summary of my studies.</p>
<h2 id="github-repo">GitHub repo</h2>
<p>As always, I’ll be posting the code from above to GitHub as well. There won’t be <code>Makefile</code>s due to the need for a custom toolchain, and I’d really like the readers to go through this writeup and understand what’s going on exactly in order to build bFLT libraries. It stumped me for a few days and I hope this helps anyone with the same questions. The repo can be found <a href="https://github.com/popovicu/linux-no-mmu-userspace-example">here</a>.</p>
    </article></div>
  </body>
</html>
