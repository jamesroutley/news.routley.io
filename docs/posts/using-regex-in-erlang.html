<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://erikarow.land/notes/using-erlang-re">Original</a>
    <h1>Using Regex in Erlang</h1>
    
    <div id="readability-page-1" class="page"><section id="Using-Regex-in-Erlang">

<p>Recently, I was helping someone port some code to Erlang that involved a Regex. I hadn’t worked with Regex in Erlang before, so here are some notes on what I learned.</p>
<section id="re---Perl-like-regular-expressions-for-Erlang">
<h2><code>re</code> - Perl-like regular expressions for Erlang</h2>
<p>The Erlang standard library has the <a href="https://www.erlang.org/doc/man/re"><code>re</code></a> module, which supports regular expression matching for Erlang strings and binaries.<label for="fn1"></label><span><span>Both Gleam and Elixir use String to mean an Erlang binary. The default string type in Erlang is sugar over a linked list of code points.</span></span></p>
<p>The <code>re</code> module provides three main functions: <code>replace</code>, <code>run</code>, and <code>split</code>, which all operate on string-like input<label for="fn2"></label><span><span>Erlang uses the <a href="https://www.erlang.org/doc/man/erlang#type-iodata"><code>iodata</code></a> type to represent a generalization on binaries that can be more efficiently worked with, all three of these functions take an <code>iodata</code> or <a href="https://www.erlang.org/doc/man/unicode#type-charlist"><code>charlist</code></a>.</span></span> and a regex pattern.</p>
<p>Regex matching can be done with <code>run</code> like this:</p>
<pre><code>&gt; re:run(&#34;my string&#34;, &#34;[myexpression]&#34;).
{match,[{0,1}]}
</code></pre>
<p>By default <code>run</code> returns all captured parts of the input, as a list of <code>{Offset, Length}</code> pairs. It also only returns the first match, not all matches.</p>
<p>To return the captures as strings, I can use the <code>{capture, all, list}</code> option:</p>
<pre><code>&gt; re:run(&#34;my string&#34;, 
    &#34;[myexpression]&#34;,
    [{capture, all, list}]
  ).
{match,[&#34;m&#34;]}
</code></pre>
<p>To get all of the matches, I can use the <code>global</code> option:</p>
<pre><code>&gt; re:run(&#34;my string&#34;, 
    &#34;[myexpression]&#34;,
    [global,{capture, all, list}]
  ).
{match,[[&#34;m&#34;],[&#34;y&#34;],[&#34;s&#34;],[&#34;r&#34;],[&#34;i&#34;],[&#34;n&#34;]]}
</code></pre>
<section id="Named-Captures">
<h3>Named Captures</h3>
<p><code>re</code> supports Perl-style named captures, which look like this:</p>
<pre><code>Pattern1 = &#34;(?&lt;myname&gt;capture)&#34;.
</code></pre>
<p>It can used by changing the <code>ValueSpec</code> component of the capture option:<label for="fn3"></label><span><span>There isn’t a built in way to associate names with captures. Elixir provides a <a href="https://hexdocs.pm/elixir/1.12/Regex.html#named_captures/3"><code>named_captures</code></a> function to easily do this.</span><span>From reading the <a href="https://github.com/elixir-lang/elixir/blob/v1.12.3/lib/elixir/lib/regex.ex#L354">source code</a> of the Elixir implementation, it should be possible to combine <code>re:inspect</code> with <code>lists:zip</code> to get a list of <code>{Name, Capture}</code> pairs.</span></span></p>
<pre><code>&gt; re:run(
    &#34;my capture of my capture&#34;, 
    Pattern1, 
    [
      global,
      {capture, [&#34;myname&#34;], list}
    ]
  ).
{match,[[&#34;capture&#34;],[&#34;capture&#34;]]}
</code></pre>
</section>
<section id="Compiling-An-Expression">
<h3>Compiling An Expression</h3>
<p>Erlang provides a <a href="https://www.erlang.org/doc/man/re#compile-2"><code>compile</code></a> function to compile a regular expression for re-use throughout the lifetime of a program:</p>
<blockquote>
<p>Compiling the regular expression before matching is useful if the same expression is to be used in matching against multiple subjects during the lifetime of the program. Compiling once and executing many times is far more efficient than compiling each time one wants to match.</p>
</blockquote>
<p>A regex can be compiled into a pattern for use with <a href="https://www.erlang.org/doc/man/re#compile-2"><code>compile</code></a>:</p>
<pre><code>{ok, Pattern2} = re:compile(&#34;[myexpression]&#34;).
</code></pre>
<p>The used like any other regex pattern:</p>
<pre><code>&gt; re:run(
    &#34;my string&#34;,
    Pattern2,
    [{capture, all, list}]
  ).
{match,[&#34;m&#34;]}
</code></pre>
</section>
</section>
<section id="Takeaways">
<h2>Takeaways</h2>
<p>The Erlang regular expression module is a bit difficult to use, but it will be nice if I have need of a zero-dependency regex module when using Erlang.</p>
</section>
</section></div>
  </body>
</html>
