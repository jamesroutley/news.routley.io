<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.sunfishcode.online/port-std-to-rustix/">Original</a>
    <h1>Porting Rust&#39;s Std to Rustix</h1>
    
    <div id="readability-page-1" class="page"><article>
  

  
    <p>Posted on <time datetime="2022-01-04T00:00:00+00:00">January 04, 2022</time></p>
  

  <p><a href="https://crates.io/crates/rustix">Rustix</a> is a system-call wrapper library with multiple backends. It has a raw
Linux syscalls backend, as well as a libc backend, and <a href="https://github.com/bytecodealliance/rustix/tree/wasi/src/imp/wasi">other backends</a> are in
development. Rustix is designed for memory safety, <a href="https://github.com/rust-lang/rfcs/blob/master/text/3128-io-safety.md">I/O safety</a>, and
performance.</p>
<p>And <a href="https://github.com/sunfishcode/rust/tree/rustix"><em>this</em></a> is a branch of Rust&#39;s std partially ported to use rustix in
place of direct libc calls. Read on for why this is cool, and stay for the
benchmarks!</p>
<h2 id="factoring-out-unsafe-error-handling-and-raw-pointers">Factoring out <code>unsafe</code>, error handling, and raw pointers</h2>
<p>The first reason that porting std to rustix is cool is that rustix factors out
a lot of <code>unsafe</code> blocks from std. Talking to the OS still requires <code>unsafe</code>, but
with rustix the <code>unsafe</code> blocks are focused on individual syscalls. That way, the
<code>unsafe</code> blocks that remain in std are the interesting ones, where std itself is
doing something interesting that needs <code>unsafe</code>.</p>
<p>Rustix also provides idiomatic <code>Result</code> error handling for system calls. And
it uses Rust references and slices instead of raw pointers. These make it
easier to read std&#39;s code and focus on the important semantics of the system
calls, without the distractions of libc API mechanics.</p>
<p>And, rustix simplifies some minor infelicities in syscall APIs related to
C integer type sizes.</p>
<p>Putting these all together in an example, <a href="https://github.com/sunfishcode/rust/commit/74ec948f644d2a4a63e21587450d271e01f4fb32#diff-a5c25e0262199413ba7e001ae7067353d4b6833039cb1a25ff556b5b0a040f5aL646">this code</a>:</p>
<pre data-lang="rust"><code data-lang="rust"><span>   </span><span>let</span><span> len = cmp::min(buf.</span><span>len</span><span>(), &lt;wrlen_t&gt;::</span><span>MAX </span><span>as </span><span>usize</span><span>) as </span><span>wrlen_t</span><span>;
</span><span>   </span><span>let</span><span> ret = </span><span>cvt</span><span>(</span><span>unsafe </span><span>{
</span><span>       c::send(</span><span>self</span><span>.inner.</span><span>as_raw</span><span>(), buf.</span><span>as_ptr</span><span>() as </span><span>*const c_void</span><span>, len, </span><span>MSG_NOSIGNAL</span><span>)
</span><span>   })?;
</span></code></pre>
<p>becomes <a href="https://github.com/sunfishcode/rust/commit/74ec948f644d2a4a63e21587450d271e01f4fb32#diff-a5c25e0262199413ba7e001ae7067353d4b6833039cb1a25ff556b5b0a040f5aR647">this</a>:</p>
<pre data-lang="rust"><code data-lang="rust"><span>   </span><span>let</span><span> ret = rustix::net::send(&amp;</span><span>self</span><span>.inner, buf, SendFlags::</span><span>NOSIGNAL</span><span>)?;
</span></code></pre>
<p>This puts the focus on the <code>send</code> operation, without the distractions of
<code>unsafe</code>, raw pointers, <code>wrlen_t</code> types, and <code>cvt</code> error handling.</p>
<h2 id="a-path-to-a-rust-on-linux-without-libc">A path to a Rust on Linux without libc</h2>
<p>A second reason this is cool is that it&#39;s a step towards a Rust toolchain
on Linux that doesn&#39;t depend on libc.</p>
<p>Rustix is able to make direct Linux syscalls from Rust code. And <a href="https://github.com/sunfishcode/mustang/tree/main/origin#origin">origin</a> is a
Rust library which is able to startup and shutdown processes and threads
(comparable to crt1.o and libpthread).</p>
<p>With these, we have all the things needed to run Rust programs on Linux. And
it turns out there are two different ways to do this. The first way is <a href="https://blog.sunfishcode.online/rust-programs-entirely-in-rust/">mustang</a>.</p>
<p>Mustang is uses a library called <a href="https://github.com/sunfishcode/mustang/tree/main/c-scape#c-scape">c-scape</a>, which wraps rustix with libc-compatible
APIs, allowing std to use rustix without modifications, including
<a href="https://blog.sunfishcode.online/implementing-threads/">threading support</a>. This has gotten a lot of functionality up and running;
mustang can run a lot of real-world code now. And mustang helps test rustix and
origin. And beyond that, the c-scape libc compatibility layer has several additional
uses. But, mustang in its currrent form looks like it would be awkward to upstream
into Rust.</p>
<p>Fortunately, mustang&#39;s architecture of keeping c-scape as a separate layer on top
of rustix and origin, with rustix and origin providing idiomatic Rust APIs, means
that another way is possible as well. This blog post is about starting to port std
to rustix directly. In addition to not using libc code, this path doesn&#39;t use libc
APIs either.</p>
<h2 id="performance">Performance</h2>
<p>And another reason this is cool is that rustix-enabled std also brings several
modest speedups, compared to std in upstream Rust. On machines I&#39;ve tested it on:</p>
<ul>
<li><code>std::fs::metadata</code> is about 3% faster</li>
<li><code>std::fs::File::open</code> is about 5% faster</li>
<li><code>std::fs::read_to_string</code> is about 3% faster </li>
<li><code>std::time::Instant::now</code> ranges from 1% to 10% faster on Linux</li>
</ul>
<p>See <a href="https://github.com/sunfishcode/rustix-bench">the benchmark source code</a> to see what&#39;s being measured.</p>
<p>Rustix makes <code>metadata</code>, <code>open</code>, and other filesystem path operations faster by
avoiding a dynamic allocation when converting from Rust strings into
NUL-terminated C strings. Rustix uses stack-allocated memory for strings up
to a reasonable size, which is much faster.</p>
<p>Rustix makes <code>Instant::new</code> faster on Linux by simplifying error handling,
since we know that reading the system monotonic clock never fails (and as in
current std, it still does panic if a failure ever does occur).</p>
<p>And rustix contains a number of other optimizations, such as using inline
system calls and avoiding the TLS <code>errno</code> variable on Linux, but so far
benchmarks confirm the common wisdom that these aren&#39;t usually very
significant compared to the cost of the actual syscalls.</p>
<h2 id="looking-forward">Looking forward</h2>
<p>A goal for this port of std to rustix is to eventually propose it to be merged
into upstream Rust. I&#39;m hoping this blog post will start some conversations
about what this should eventually look like.</p>
<p>With rustix&#39;s libc backend, std can continue to support all the libc-using
platforms that Rust currently supports. And with either backend, rustix brings
the advantages of factoring out <code>unsafe</code>, error handling, and raw pointers,
and its optimizations for converting to C-style strings.</p>
<p>This project promotes several other goals as well, such as promoting
<a href="https://github.com/rust-lang/rfcs/blob/master/text/3128-io-safety.md">I/O safety</a> concepts and APIs, helping test some of the infrastructure used
by <a href="https://github.com/bytecodealliance/cap-std">cap-std</a>, and helping set the stage for future projects related to
sandboxing, WASI, <a href="https://crates.io/crates/nameless">nameless</a>, and other areas.</p>
<h2 id="thanks">Thanks!</h2>
<p>Thanks to @nivkner for implementing support for child processes, to
@Urgau for adding arm support and implementing several features in rustix,
@cole-miller for implementing <code>getcwd</code> and <code>chdir</code> in mustang, and @jplatte
and @ratmice and others for contributing useful patches, and @tshepang in
particular for bringing up <code>ripgrep</code> as a testcase (and it <a href="https://github.com/sunfishcode/mustang/issues/22#issuecomment-964653423">almost works</a>
now!).</p>

</article></div>
  </body>
</html>
