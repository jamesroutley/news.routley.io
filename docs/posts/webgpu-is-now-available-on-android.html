<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://developer.chrome.com/blog/new-in-webgpu-121">Original</a>
    <h1>WebGPU is now available on Android</h1>
    
    <div id="readability-page-1" class="page"><div>

  
    






<div>
  
    
    
      <div>
        
          <p><img alt="FranÃ§ois Beaufort" src="https://web.dev/images/authors/beaufortfrancois.jpg" decoding="async" height="64" loading="lazy" width="64"/></p>
      </div>
    
  
</div>

<h2 id="support-webgpu-on-android" data-text="Support WebGPU on Android" tabindex="-1"><a href="#support_webgpu_on_android" name="support_webgpu_on_android">Support WebGPU on Android</a></h2>

<p>The Chrome team is excited to announce that WebGPU is now enabled by default in Chrome 121 on devices running Android 12 and greater powered by Qualcomm and ARM GPUs.</p>

<p>Support will gradually expand to encompass a wider range of Android devices, including those running on Android 11 in a near future. This expansion will be dependent on further testing and optimization to ensure a seamless experience across a broader range of hardware configurations. See <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1497815">issue chromium:1497815</a>.</p>

<figure>
  <img src="https://developer.chrome.com/static/blog/new-in-webgpu-121/image/webgpu-android.png" ,="" alt="Screenshot of WebGPU sample running on Chrome for Android." width="854" height="480" srcset="https://developer.chrome.com/static/blog/new-in-webgpu-121/image/webgpu-android_36.png 36w,https://developer.chrome.com/static/blog/new-in-webgpu-121/image/webgpu-android_48.png 48w,https://developer.chrome.com/static/blog/new-in-webgpu-121/image/webgpu-android_72.png 72w,https://developer.chrome.com/static/blog/new-in-webgpu-121/image/webgpu-android_96.png 96w,https://developer.chrome.com/static/blog/new-in-webgpu-121/image/webgpu-android_480.png 480w,https://developer.chrome.com/static/blog/new-in-webgpu-121/image/webgpu-android_720.png 720w,https://developer.chrome.com/static/blog/new-in-webgpu-121/image/webgpu-android_856.png 856w,https://developer.chrome.com/static/blog/new-in-webgpu-121/image/webgpu-android_960.png 960w,https://developer.chrome.com/static/blog/new-in-webgpu-121/image/webgpu-android_1440.png 1440w,https://developer.chrome.com/static/blog/new-in-webgpu-121/image/webgpu-android_1920.png 1920w,https://developer.chrome.com/static/blog/new-in-webgpu-121/image/webgpu-android_2880.png 2880w" sizes="(max-width: 840px) 100vw, 856px"/>
  <figcaption>WebGPU sample running on Chrome for Android.</figcaption>
</figure>

<h2 id="use_dxc_instead_of_fxc_for_shader_compilation_on_windows" data-text="Use DXC instead of FXC for shader compilation on Windows" tabindex="-1">Use DXC instead of FXC for shader compilation on Windows</h2>

<p>Chrome now uses the power of <a href="https://github.com/microsoft/DirectXShaderCompiler/wiki">DXC</a> (DirectX Compiler) to compile shaders on Windows D3D12 machines equipped with SM6+ graphics hardware. Previously, WebGPU relied on FXC (FX Compiler) for shader compilation on Windows. While functional, FXC lacked the feature set and performance optimizations present in DXC.</p>

<p>Initial testing shows a 20% average increase in compute shader compilation speed when using DXC compared to FXC.</p>

<h2 id="timestamp_queries_in_compute_and_render_passes" data-text="Timestamp queries in compute and render passes" tabindex="-1">Timestamp queries in compute and render passes</h2>

<p><a href="https://gpuweb.github.io/gpuweb/#timestamp">Timestamp queries</a> allow WebGPU applications to measure precisely (down to the nanosecond) how much time their GPU commands take to execute compute and render passes. They are heavily used to gain insights into the performance and behavior of GPU workloads.</p>

<p>When the <code translate="no" dir="ltr">&#34;timestamp-query&#34;</code> feature is available in a <code translate="no" dir="ltr">GPUAdapter</code>, you can now do the following things:</p>

<ul>
<li>Request a <code translate="no" dir="ltr">GPUDevice</code> with the <code translate="no" dir="ltr">&#34;timestamp-query&#34;</code> feature.</li>
<li>Create a <code translate="no" dir="ltr">GPUQuerySet</code> of type <code translate="no" dir="ltr">&#34;timestamp&#34;</code>.</li>
<li>Use <a href="https://gpuweb.github.io/gpuweb/#dom-gpucomputepassdescriptor-timestampwrites"><code translate="no" dir="ltr">GPUComputePassDescriptor.timestampWrites</code></a> and <a href="https://gpuweb.github.io/gpuweb/#dom-gpurenderpassdescriptor-timestampwrites"><code translate="no" dir="ltr">GPURenderPassDescriptor.timestampWrites</code></a> to define where to write timestamp values in <code translate="no" dir="ltr">GPUQuerySet</code>.</li>
<li>Resolve timestamp values into a <code translate="no" dir="ltr">GPUBuffer</code> with <a href="https://gpuweb.github.io/gpuweb/#dom-gpucommandencoder-resolvequeryset"><code translate="no" dir="ltr">resolveQuerySet()</code></a>.</li>
<li>Read timestamp values back by copying the results from the <code translate="no" dir="ltr">GPUBuffer</code> to the CPU.</li>
<li>Decode timestamp values as a <code translate="no" dir="ltr">BigInt64Array</code>.</li>
</ul>

<p>See the following example and issue <a href="https://bugs.chromium.org/p/dawn/issues/detail?id=1800">dawn:1800</a>.</p>
<pre translate="no" dir="ltr"><code translate="no" dir="ltr">const adapter = await navigator.gpu.requestAdapter();
if (!adapter.features.has(&#34;timestamp-query&#34;)) {
  throw new Error(&#34;Timestamp query feature is not available&#34;);
}
// Explicitly request timestamp query feature.
const device = await adapter.requestDevice({
  requiredFeatures: [&#34;timestamp-query&#34;],
});
const commandEncoder = device.createCommandEncoder();

// Create a GPUQuerySet which holds 2 timestamp query results: one for the
// beginning and one for the end of compute pass execution.
const querySet = device.createQuerySet({ type: &#34;timestamp&#34;, count: 2 });
const timestampWrites = {
  querySet,
  beginningOfPassWriteIndex: 0, // Write timestamp in index 0 when pass begins.
  endOfPassWriteIndex: 1, // Write timestamp in index 1 when pass ends.
};
const passEncoder = commandEncoder.beginComputePass({ timestampWrites });
// TODO: Set pipeline, bind group, and dispatch work to be performed.
passEncoder.end();

// Resolve timestamps in nanoseconds as a 64-bit unsigned integer into a GPUBuffer.
const size = 2 * BigInt64Array.BYTES_PER_ELEMENT;
const resolveBuffer = device.createBuffer({
  size,
  usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC,
});
commandEncoder.resolveQuerySet(querySet, 0, 2, resolveBuffer, 0);

// Read GPUBuffer memory.
const resultBuffer = device.createBuffer({
  size,
  usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,
});
commandEncoder.copyBufferToBuffer(resolveBuffer, 0, resultBuffer, 0, size);

// Submit commands to the GPU.
device.queue.submit([commandEncoder.finish()]);

// Log compute pass duration in nanoseconds.
await resultBuffer.mapAsync(GPUMapMode.READ);
const times = new BigInt64Array(resultBuffer.getMappedRange());
console.log(`Compute pass duration: ${Number(times[1] - times[0])}ns`);
resultBuffer.unmap();
</code></pre>
<p>Due to <a href="https://gpuweb.github.io/gpuweb/#security-timing-device">timing attack</a> concerns, timestamp queries are quantized with a resolution of 100 microseconds, which provides a good compromise between precision and security. In Chrome browser, you can disable timestamp quantization by enabling the &#34;WebGPU Developer Features&#34; <a href="https://developer.chrome.com/docs/web-platform/chrome-flags#chromeflags">flag</a> at <code translate="no" dir="ltr">chrome://flags/#enable-webgpu-developer-features</code> during the development of your app. See <a href="https://developer.chrome.com/blog/new-in-webgpu-120#timestamp_queries_quantization">Timestamp queries quantization</a> to learn more.</p>

<p>As GPUs may reset the timestamp counter occasionally, which can result in unexpected values such as negative deltas between timestamps, I recommend you check out the <a href="https://github.com/webgpu/webgpu-samples/compare/d67ae2acb40bebfa7c7705cd28175b44fbb03b59..e59b76695212208600f5bbb5423895e6d440fd90#diff-fe64f06098aed64ad6bbd885ad77dc50f7fa856829bf22545d3aa1baaad1c0b8">git diff changes</a> that adds timestamp query support to the following <a href="https://webgpu.github.io/webgpu-samples/samples/computeBoids">Compute Boids</a> sample.</p>

<figure>
  <img src="https://developer.chrome.com/static/blog/new-in-webgpu-121/image/compute-boids.png" ,="" alt="Screenshot of Compute Boids sample featuring timestamp query." width="854" height="553" srcset="https://developer.chrome.com/static/blog/new-in-webgpu-121/image/compute-boids_36.png 36w,https://developer.chrome.com/static/blog/new-in-webgpu-121/image/compute-boids_48.png 48w,https://developer.chrome.com/static/blog/new-in-webgpu-121/image/compute-boids_72.png 72w,https://developer.chrome.com/static/blog/new-in-webgpu-121/image/compute-boids_96.png 96w,https://developer.chrome.com/static/blog/new-in-webgpu-121/image/compute-boids_480.png 480w,https://developer.chrome.com/static/blog/new-in-webgpu-121/image/compute-boids_720.png 720w,https://developer.chrome.com/static/blog/new-in-webgpu-121/image/compute-boids_856.png 856w,https://developer.chrome.com/static/blog/new-in-webgpu-121/image/compute-boids_960.png 960w,https://developer.chrome.com/static/blog/new-in-webgpu-121/image/compute-boids_1440.png 1440w,https://developer.chrome.com/static/blog/new-in-webgpu-121/image/compute-boids_1920.png 1920w,https://developer.chrome.com/static/blog/new-in-webgpu-121/image/compute-boids_2880.png 2880w" sizes="(max-width: 840px) 100vw, 856px"/>
  <figcaption>Compute Boids sample featuring timestamp query.</figcaption>
</figure>

<h2 id="default_entry_points_to_shader_modules" data-text="Default entry points to shader modules" tabindex="-1">Default entry points to shader modules</h2>

<p>To improve the developer experience, you can now omit the <a href="https://gpuweb.github.io/gpuweb/#dom-gpuprogrammablestage-entrypoint"><code translate="no" dir="ltr">entryPoint</code></a> of your shader module when creating a compute or render pipeline. If no unique entry point for the shader stage is found in the shader code, a <a href="https://developer.mozilla.org/docs/Web/API/GPUValidationError">GPUValidationError</a> will be triggered. See the following example and <a href="https://bugs.chromium.org/p/dawn/issues/detail?id=2254">issue dawn:2254</a>.</p>
<pre translate="no" dir="ltr"><code translate="no" dir="ltr">const code = `
    @vertex fn vertexMain(@builtin(vertex_index) i : u32) -&gt;
      @builtin(position) vec4f {
       const pos = array(vec2f(0, 1), vec2f(-1, -1), vec2f(1, -1));
       return vec4f(pos[i], 0, 1);
    }
    @fragment fn fragmentMain() -&gt; @location(0) vec4f {
      return vec4f(1, 0, 0, 1);
    }`;
const module = myDevice.createShaderModule({ code });
const format = navigator.gpu.getPreferredCanvasFormat();
const pipeline = await myDevice.createRenderPipelineAsync({
  layout: &#34;auto&#34;,
<s>  vertex: { module, entryPoint: &#34;vertexMain&#34; },</s>
<s>  fragment: { module, entryPoint: &#34;fragmentMain&#34;, targets: [{ format }] },</s>
<strong>  vertex: { module },</strong>
<strong>  fragment: { module, targets: [{ format }] },</strong>
});
</code></pre>
<h2 id="support_display-p3_as_gpuexternaltexture_color_space" data-text="Support display-p3 as GPUExternalTexture color space" tabindex="-1">Support display-p3 as GPUExternalTexture color space</h2>

<p>You can now set <code translate="no" dir="ltr">&#34;display-p3&#34;</code> destination color space when importing a <a href="https://developer.mozilla.org/docs/Web/API/GPUExternalTexture">GPUExternalTexture</a> from HDR videos with <a href="https://developer.mozilla.org/docs/Web/API/GPUDevice/importExternalTexture"><code translate="no" dir="ltr">importExternalTexture()</code></a>. Check out how WebGPU handles <a href="https://gpuweb.github.io/gpuweb/#color-spaces">color spaces</a>. See the following example and issue <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1330250">chromium:1330250</a>.</p>
<pre translate="no" dir="ltr"><code translate="no" dir="ltr">// Create texture from HDR video.
const video = document.querySelector(&#34;video&#34;);
const texture = myDevice.importExternalTexture({
  source: video,
  colorSpace: &#34;display-p3&#34;,
});
</code></pre>
<h2 id="memory_heaps_info" data-text="Memory heaps info" tabindex="-1">Memory heaps info</h2>

<p>To help you anticipate memory limitations when allocating large amounts during the development of your app, <a href="https://developer.mozilla.org/docs/Web/API/GPUAdapter/requestAdapterInfo"><code translate="no" dir="ltr">requestAdapterInfo()</code></a> now exposes <code translate="no" dir="ltr">memoryHeaps</code> information such as the size and type of memory heaps available on the adapter. This experimental feature is accessible only when the &#34;WebGPU Developer Features&#34; <a href="https://developer.chrome.com/docs/web-platform/chrome-flags#chromeflags">flag</a> at <code translate="no" dir="ltr">chrome://flags/#enable-webgpu-developer-features</code> is enabled. See the following example and <a href="https://bugs.chromium.org/p/dawn/issues/detail?id=2249">issue dawn:2249</a>.</p>
<pre translate="no" dir="ltr"><code translate="no" dir="ltr">const adapter = await navigator.gpu.requestAdapter();
const adapterInfo = await adapter.requestAdapterInfo();

for (const { size, properties } of adapterInfo.memoryHeaps) {
  console.log(size); // memory heap size in bytes
  if (properties &amp; GPUHeapProperty.DEVICE_LOCAL)  { /* ... */ }
  if (properties &amp; GPUHeapProperty.HOST_VISIBLE)  { /* ... */ }
  if (properties &amp; GPUHeapProperty.HOST_COHERENT) { /* ... */ }
  if (properties &amp; GPUHeapProperty.HOST_UNCACHED) { /* ... */ }
  if (properties &amp; GPUHeapProperty.HOST_CACHED)   { /* ... */ }
}
</code></pre>
<figure>
  <img src="https://developer.chrome.com/static/blog/new-in-webgpu-121/image/webgpureport.png" ,="" alt="Screenshot of https://webgpureport.org featuring memory heaps in adapter info." width="854" height="560" srcset="https://developer.chrome.com/static/blog/new-in-webgpu-121/image/webgpureport_36.png 36w,https://developer.chrome.com/static/blog/new-in-webgpu-121/image/webgpureport_48.png 48w,https://developer.chrome.com/static/blog/new-in-webgpu-121/image/webgpureport_72.png 72w,https://developer.chrome.com/static/blog/new-in-webgpu-121/image/webgpureport_96.png 96w,https://developer.chrome.com/static/blog/new-in-webgpu-121/image/webgpureport_480.png 480w,https://developer.chrome.com/static/blog/new-in-webgpu-121/image/webgpureport_720.png 720w,https://developer.chrome.com/static/blog/new-in-webgpu-121/image/webgpureport_856.png 856w,https://developer.chrome.com/static/blog/new-in-webgpu-121/image/webgpureport_960.png 960w,https://developer.chrome.com/static/blog/new-in-webgpu-121/image/webgpureport_1440.png 1440w,https://developer.chrome.com/static/blog/new-in-webgpu-121/image/webgpureport_1920.png 1920w,https://developer.chrome.com/static/blog/new-in-webgpu-121/image/webgpureport_2880.png 2880w" sizes="(max-width: 840px) 100vw, 856px"/>
  <figcaption>Adapter info memory heaps shown on <a href="https://webgpureport.org">https://webgpureport.org</a>.</figcaption>
</figure>

<h2 id="dawn_updates" data-text="Dawn updates" tabindex="-1">Dawn updates</h2>

<p>The <code translate="no" dir="ltr">HasWGSLLanguageFeature</code> and <code translate="no" dir="ltr">EnumerateWGSLLanguageFeatures</code> methods on <code translate="no" dir="ltr">wgpu::Instance</code> have been added to handle WGSL language features. See issue <a href="https://bugs.chromium.org/p/dawn/issues/detail?id=2260">dawn:2260</a>.</p>

<p>The non-standard <code translate="no" dir="ltr">wgpu::Feature::BufferMapExtendedUsages</code> feature lets you create a GPU buffer with <code translate="no" dir="ltr">wgpu::BufferUsage::MapRead</code> or <code translate="no" dir="ltr">wgpu::BufferUsage::MapWrite</code> and any other <code translate="no" dir="ltr">wgpu::BufferUsage</code>. See the following example and issue <a href="https://bugs.chromium.org/p/dawn/issues/detail?id=2204">dawn:2204</a>.</p>
<pre translate="no" dir="ltr"><code translate="no" dir="ltr">wgpu::BufferDescriptor descriptor = {
  .size = 128,
  .usage = wgpu::BufferUsage::MapWrite | wgpu::BufferUsage::Uniform
};
wgpu::Buffer uniformBuffer = device.CreateBuffer(&amp;descriptor);

uniformBuffer.MapAsync(wgpu::MapMode::Write, 0, 128,
   [](WGPUBufferMapAsyncStatus status, void* userdata)
   {
      wgpu::Buffer* buffer = static_cast&lt;wgpu::Buffer*&gt;(userdata);
      memcpy(buffer-&gt;GetMappedRange(), data, sizeof(data));
   },
   &amp;uniformBuffer);
</code></pre>
<p>The following features have been documented: <a href="https://dawn.googlesource.com/dawn/+/refs/heads/main/docs/dawn/features/angle_texture_sharing.md">ANGLE Texture Sharing</a>, <a href="https://dawn.googlesource.com/dawn/+/refs/heads/main/docs/dawn/features/d3d11_multithread_protected.md">D3D11 multithread protected</a>, <a href="https://dawn.googlesource.com/dawn/+/refs/heads/main/docs/dawn/features/implicit_device_synchronization.md">Implicit Device Synchronization</a>, <a href="https://dawn.googlesource.com/dawn/+/refs/heads/main/docs/dawn/features/norm16_texture_formats.md">Norm16 texture formats</a>, <a href="https://dawn.googlesource.com/dawn/+/refs/heads/main/docs/dawn/features/timestamp_query_inside_passes.md">Timestamp Query Inside Passes</a>, <a href="https://dawn.googlesource.com/dawn/+/refs/heads/main/docs/dawn/features/pixel_local_storage.md">Pixel Local Storage</a>, <a href="https://dawn.googlesource.com/dawn/+/refs/heads/main/docs/dawn/features/shader_features.md">Shader Features</a>, and <a href="https://dawn.googlesource.com/dawn/+/refs/heads/main/docs/dawn/features/multi_planar_formats.md">Multi Planar Formats</a>.</p>

<p>The Chrome team has created an <a href="https://github.com/google/dawn">official GitHub repository for Dawn</a>.</p>

<p>This covers only some of the key highlights. Check out the exhaustive <a href="https://dawn.googlesource.com/dawn/+log/chromium/6099..chromium/6167?n=1000">list of commits</a>.</p>

<h2 id="whats-new" data-text="What&#39;s New in WebGPU" tabindex="-1">What&#39;s New in WebGPU</h2>

<p>A list of everything that has been covered in the <a href="https://developer.chrome.com/docs/web-platform/webgpu/news">What&#39;s New in WebGPU</a> series.</p>

<h3 id="chrome121" data-text="Chrome 121" tabindex="-1">Chrome 121</h3>

<ul>
<li><a href="https://developer.chrome.com/blog/new-in-webgpu-121#support-webgpu-on-android">Support WebGPU on Android</a></li>
<li><a href="https://developer.chrome.com/blog/new-in-webgpu-121#use_dxc_instead_of_fxc_for_shader_compilation_on_windows">Use DXC instead of FXC for shader compilation on Windows</a></li>
<li><a href="https://developer.chrome.com/blog/new-in-webgpu-121#timestamp_queries_in_compute_and_render_passes">Timestamp queries in compute and render passes</a></li>
<li><a href="https://developer.chrome.com/blog/new-in-webgpu-121#default_entry_points_to_shader_modules">Default entry points to shader modules</a></li>
<li><a href="https://developer.chrome.com/blog/new-in-webgpu-121#support_display-p3_as_gpuexternaltexture_color_space">Support display-p3 as GPUExternalTexture color space</a></li>
<li><a href="https://developer.chrome.com/blog/new-in-webgpu-121#memory_heaps_info">Memory heaps info</a></li>
<li><a href="https://developer.chrome.com/blog/new-in-webgpu-121#dawn_updates">Dawn updates</a></li>
</ul>

<h3 id="chrome120" data-text="Chrome 120" tabindex="-1">Chrome 120</h3>

<ul>
<li><a href="https://developer.chrome.com/blog/new-in-webgpu-120#support_for_16-bit_floating-point_values_in_wgsl">Support for 16-bit floating-point values in WGSL</a></li>
<li><a href="https://developer.chrome.com/blog/new-in-webgpu-120#push_the_limits">Push the limits</a></li>
<li><a href="https://developer.chrome.com/blog/new-in-webgpu-120#changes_to_depth-stencil_state">Changes to depth-stencil state</a></li>
<li><a href="https://developer.chrome.com/blog/new-in-webgpu-120#adapter_information_updates">Adapter information updates</a></li>
<li><a href="https://developer.chrome.com/blog/new-in-webgpu-120#timestamp_queries_quantization">Timestamp queries quantization</a></li>
<li><a href="https://developer.chrome.com/blog/new-in-webgpu-120#spring-cleaning_features">Spring-cleaning features</a></li>
</ul>

<h3 id="chrome119" data-text="Chrome 119" tabindex="-1">Chrome 119</h3>

<ul>
<li><a href="https://developer.chrome.com/blog/new-in-webgpu-119#filterable_32-bit_float_textures">Filterable 32-bit float textures</a></li>
<li><a href="https://developer.chrome.com/blog/new-in-webgpu-119#unorm10-10-10-2_vertex_format">unorm10-10-10-2 vertex format</a></li>
<li><a href="https://developer.chrome.com/blog/new-in-webgpu-119#rgb10a2uint_texture_format">rgb10a2uint texture format</a></li>
<li><a href="https://developer.chrome.com/blog/new-in-webgpu-119#dawn_updates">Dawn updates</a></li>
</ul>

<h3 id="chrome118" data-text="Chrome 118" tabindex="-1">Chrome 118</h3>

<ul>
<li><a href="https://developer.chrome.com/blog/new-in-webgpu-118#htmlimageelement_and_imagedata_support_in_copyexternalimagetotexture">HTMLImageElement and ImageData support in <code translate="no" dir="ltr">copyExternalImageToTexture()</code></a></li>
<li><a href="https://developer.chrome.com/blog/new-in-webgpu-118#experimental_support_for_read-write_and_read-only_storage_texture">Experimental support for read-write and read-only storage texture</a></li>
<li><a href="https://developer.chrome.com/blog/new-in-webgpu-118#dawn_updates">Dawn updates</a></li>
</ul>

<h3 id="chrome117" data-text="Chrome 117" tabindex="-1">Chrome 117</h3>

<ul>
<li><a href="https://developer.chrome.com/blog/new-in-webgpu-117#unset_vertex_buffer">Unset vertex buffer</a></li>
<li><a href="https://developer.chrome.com/blog/new-in-webgpu-117#unset_bind_group">Unset bind group</a></li>
<li><a href="https://developer.chrome.com/blog/new-in-webgpu-117#silence_errors_from_async_pipeline_creation_when_device_is_lost">Silence errors from async pipeline creation when device is lost</a></li>
<li><a href="https://developer.chrome.com/blog/new-in-webgpu-117#spir-v_shader_module_creation_updates">SPIR-V shader module creation updates</a></li>
<li><a href="https://developer.chrome.com/blog/new-in-webgpu-117#improving_developer_experience">Improving developer experience</a></li>
<li><a href="https://developer.chrome.com/blog/new-in-webgpu-117#caching_pipelines_with_automatically_generated_layout">Caching pipelines with automatically generated layout</a></li>
<li><a href="https://developer.chrome.com/blog/new-in-webgpu-117#dawn_updates">Dawn updates</a></li>
</ul>

<h3 id="chrome116" data-text="Chrome 116" tabindex="-1">Chrome 116</h3>

<ul>
<li><a href="https://developer.chrome.com/blog/new-in-webgpu-116#webcodecs_integration">WebCodecs integration</a></li>
<li><a href="https://developer.chrome.com/blog/new-in-webgpu-116#lost_device_returned_by_gpuadapter_requestdevice">Lost device returned by GPUAdapter <code translate="no" dir="ltr">requestDevice()</code></a></li>
<li><a href="https://developer.chrome.com/blog/new-in-webgpu-116#keep_video_playback_smooth_if_importexternaltexture_is_called">Keep video playback smooth if <code translate="no" dir="ltr">importExternalTexture()</code> is called</a></li>
<li><a href="https://developer.chrome.com/blog/new-in-webgpu-116#spec_conformance">Spec conformance</a></li>
<li><a href="https://developer.chrome.com/blog/new-in-webgpu-116#improving_developer_experience">Improving developer experience</a></li>
<li><a href="https://developer.chrome.com/blog/new-in-webgpu-116#dawn_updates">Dawn updates</a></li>
</ul>

<h3 id="chrome115" data-text="Chrome 115" tabindex="-1">Chrome 115</h3>

<ul>
<li><a href="https://developer.chrome.com/blog/new-in-webgpu-115#supported_wgsl_language_extensions">Supported WGSL language extensions</a></li>
<li><a href="https://developer.chrome.com/blog/new-in-webgpu-115#experimental_support_for_direct3d_11">Experimental support for Direct3D 11</a></li>
<li><a href="https://developer.chrome.com/blog/new-in-webgpu-115#get_discrete_gpu_by_default_on_ac_power">Get discrete GPU by default on AC power</a></li>
<li><a href="https://developer.chrome.com/blog/new-in-webgpu-115#improving_developer_experience">Improving developer experience</a></li>
<li><a href="https://developer.chrome.com/blog/new-in-webgpu-115#dawn_updates">Dawn updates</a></li>
</ul>

<h3 id="chrome114" data-text="Chrome 114" tabindex="-1">Chrome 114</h3>

<ul>
<li><a href="https://developer.chrome.com/blog/new-in-webgpu-114#optimize_javascript">Optimize JavaScript</a></li>
<li><a href="https://developer.chrome.com/blog/new-in-webgpu-114#getcurrenttexture_on_unconfigured_canvas_throws_invalidstateerror">getCurrentTexture() on unconfigured canvas throws InvalidStateError</a></li>
<li><a href="https://developer.chrome.com/blog/new-in-webgpu-114#wgsl_updates">WGSL updates</a></li>
<li><a href="https://developer.chrome.com/blog/new-in-webgpu-114#dawn_updates">Dawn updates</a></li>
</ul>

<h3 id="chrome113" data-text="Chrome 113" tabindex="-1">Chrome 113</h3>

<ul>
<li><a href="https://developer.chrome.com/blog/new-in-webgpu-113#use_webcodecs_videoframe_source_in_importexternaltexture">Use WebCodecs VideoFrame source in <code translate="no" dir="ltr">importExternalTexture()</code></a></li>
</ul>

  

  
</div></div>
  </body>
</html>
