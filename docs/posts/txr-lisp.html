<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.nongnu.org/txr/txr-lisp.html">Original</a>
    <h1>TXR Lisp</h1>
    
    <div id="readability-page-1" class="page">


<p><a href="https://www.nongnu.org/txr/index.html">TXR</a> Lisp is an innovative,
original dialect from the Lisp language
family. It is not an implementation of Common Lisp, Scheme or any
existing dialect.</p>

<p>
One goals of TXR Lisp is to <span>remove
verbosity from Lisp programming</span>,
where doing so does not conflict with the Lisp ideology (&#34;Lispiness&#34;).
This means that the primary means of making programs succinct are
semantic devices, rather than syntactic sugars. However,  sugars
are also employed, when they are not disruptive to the surrounding
syntax.</p>

<p>Another goal of TXR Lisp is to serve as a platform for
experimentation an advancement within the context of a Lisp paradigm,
and bring together the right mix of advanced features as well as
innovative new solutions to old problems, <span>integrating these into an ergonomic whole</span>
which can be applied to real, practical tasks, right now.<br/>
</p>

<h3>Imperative to be Functional</h3>

<p>TXR Lisp supports functional programming, but isn&#39;t a functional
language. The TXR project consciously rejects the purely functional
ideology. TXR Lisp supports programming with higher order functions by
providing</p>

<ul>

  <li>first-class functions (lexical closures);</li>
  <li>an expressive syntax for explicit partial evaluation;</li>
  <li>a significant standard library of userful functional combinators;<br/>
  </li>
  <li>non-function objects which can be treated as functions; and</li>
  <li><span>delimited continuations</span>,
for reifying program state as a function.</li>
</ul>

<p>TXR Lisp supports imperative programming directly. It has mutable
variables, and mutable data structures such as lists, vectors, strings
and structures. It has control constructs such as loops, exception
handling and non-local exits.<br/>
</p>

<h3>Strictly Eager, with a Lazy Streak</h3>

<p>TXR
Lisp is strictly evaluated. Function argument expressions are
evaluated in left to right order, before the function call takes place.
Special operators and macros evaluate forms in a predictable order.
Sequencing operations with visible effects such as I/O is easy, just
like in any mainstream imperative language. TXR Lisp, however, has
support for lazy evaluation via several features:</p>

<ul>

  <li>lazy lists based on lazy cons cell objects, deeply integrated
into the Lisp data model;<br/>
  </li>
  <li>lazy instantiations OOP structures; allowing &#34;one step&#34; creation
of infinite, lazy structures made up of objects,  and mutually
referencing object clusters.<br/>
  </li>
  <li>explicit <code>delay</code> and <code>force</code> operators;
and<br/>
  </li>
  <li>a self-referential binding operator <code>mlet</code>, which is
an advancement over Scheme&#39;s <code>letrec</code>.</li>
</ul>

<p>TXR Lisp&#39;s construct for explicit laziness in the middle of a strict
language provide most of the benefits of lazy evaluation, without the
drawbacks such as poor performance, confusing semantics and clumsy
coordination of side effects which plague lazily-evaluated functional
languages.</p>

<h3>Generic Brand<br/>
</h3>

<p>Unlike in mainstream Lisp dialects, TXR Lisp allows traditional list
operations like <code>car</code>, <code>cdr</code>, and <code>mapcar</code>
to be applied to vectors and character strings, which is very
expressive and useful.</p>

<h3>Lisp-1,-2 Under one Roof</h3>

<p>A classic dilemma in the design of a Lisp dialect is whether to make
it Lisp-1 or Lisp-2. That is to say, should function and variable
bindings be in one namespace or in separate namespaces? TXR Lisp
innovates in this area with a new solution which integrates both
styles. The underlying infracstructure is Lisp-2: the global and
lexical environments have function and variable namespaces. However,
Lisp-1 style evaluation of arguments (with the two namespaces
apparently folded into one) occurs in forms which are written using
square brackets instead of parentheses. This feature is deeply
integrated into the language; it cannot be implemented in Lisp-2
dialects to the same level without working at the implemenation level,
or else transforming entire top-level forms with a code walker, or else
making it an incomplete hack. Even the macro expander is aware of the
feature: when a reference to a lexical function occurs as a Lisp-1
style argument, that function shadows a symbol macro in an outer scope,
which would not be shadowed in a Lisp-2 form due to the symbol macro
being considered in a variable namespace.<br/>
</p>

<p>Programming with functional arguments (&#34;higher order functions&#34;) in
TXR Lisp is free of distracting noise like <code>funcall</code> and <code>#&#39;</code>.
The <code>funcall</code> function exists and is named <code>call</code>,
and the function operator is called <code>fun</code>; but these are
hardly ever seen. The Common Lisp <code>#&#39;</code> (hash quote)
notation is absent. The <code>lambda</code> operator in  TXR
Lisp  works directly; it isn&#39;t a macro which  expands
to  <code>(fun (lambda ...))</code>.   Yet, TXR Lisp
retains the advantages of Lisp-2, such as its natural view of macro
programming and referential hygiene.</p>

<p>Incidentally, the square bracket forms in TXR Lisp provide a purer
vision of Lisp-1 than Lisp-1 dialects themselves. Proponents of Lisp-1
dialects like to say that every position of a form is
evaluated in the same way, which is more consistent than Lisp-2 which
treats the operator specially. Unfortunately, that is a lie, because
any worthwhile Lisp-1 dialect has macros. The leftmost position of a
form in any worthwhile Lisp-1 dialect must be considered in the macro
namespace. By contrast, TXR Lisp&#39;s square
bracket forms cannot be macro forms. In the form <code>[a b c]</code>, 
the  symbol <code>a</code> must resolve to a function, or an
object which can be used as a function. It cannot be a macro (other
than a symbol macro which simply replaces <code>a</code> with another
form). So the Lisp-1 advocacy soundbite is, ironically, true in TXR
Lisp: the arguments of a square bracketed form are all evaluated the
same way, period. </p>

<h3>Ask the Boss for Arrays</h3>

<p>Programmers who encounter one of the major Lisp dialects for the
first time usually complain about the clumsy support for working with
arrays. TXR Lisp takes heed of these complains. TXR&#39;s square bracket
forms provide array indexing and range referencing.</p>

<p>Indexing works naturally because sequences (lists, vectors and
arrays) as well as hashes are considered functions which map indexes to
elements. For instance, the form <code>(mapcar &#34;abc&#34; #(2 0 1))</code>
produces the vector <code>#(#\c #\a #\b)</code> because the character
string <code>&#34;abc&#34;</code> is a function which maps the indices 0, 1
and 2 to the character objects <code>#\a</code>, <code>#\b</code> and
<code>#\c</code>. (Also note that a vector is being processed with <code>mapcar</code>,
which is why the type which emerges is a vector).  Therefore, the
square brackets Lisp-1 notation provides array indexing. The form <code>[&#34;abc&#34;
1]</code>  means &#34;call the <code>&#34;abc&#34;</code> string as a
function, passing it the argument 1&#34;. The effect is that the character <code>#\b</code>
is retrieved.  This works for lists and vectors in the same way.
For hash tables, a hash lookup is performed. If <code>h</code> is a
hash table,  and <code>k</code> is a key, then <code>[h k]</code>
performs a lookup. Also, <code>[h k v]</code> performs a lookup such
that <code>v</code> is substituted if <code>k</code> is not found.</p>

<p>Range indexing is supported using the dotdot range notation. For
instance <code>[a 2..5]</code> denotes the slice of a starting from
element <code>[a 2]</code> up to and including <code>[a 4]</code>,
excluding <code>[a 5]</code>.  If the symbol <code>t</code> is
used as the upper endpoint, it denotes the element one beyond the last;
in other words, the slice extends to the end. The colon symbol : can
also be used on either end to denote &#34;from the start&#34; or &#34;to the end&#34;.
All of the following forms denote a slice of a <code>a</code> which
includes all of <code>a</code>:  <code>[a :..:]</code>, <code>[a
0..:]</code>, <code>[a 0..t]</code>, <code>[a :..t]</code>.  
Negative indices are supported, so that -1 denotes the last element.
The expression <code>[a 0..-1]</code> calculates a slice of a which
excludes the last element.  The dotdot notation is a syntactic
sugar, which denotes the construction of a range object: <code>a..b</code>
is converted by TXR Lisp&#39;s parser to <code>(rcons a b)</code>, a call
to the <code>rcons</code> function which constructs a range object.</p>

<p>Both element and range indexing forms support assignment as well as
deletion (if the array-like object is stored in an assignable place),
which makes for flexible and succinct array editing. For instance, if
variable <code>a</code> holds the string <code>&#34;car&#34;</code>, then <code>(set
[a 1..2] &#34;ape&#34;)</code> changes <code>a</code>  to <code>&#34;caper&#34;</code>.
The following example shows how we can exchange the ranges of two
arrays in a single <code>swap</code> operation:</p>

<pre><span>(</span><span>let</span> <span>((</span><span>a</span> <span>&#34;archibald&#34;</span><span>)</span> <span>(</span><span>b</span> <span>&#34;spooner&#34;</span><span>))</span></pre>


<p>Note that although the exchanged ranges happen to be of equal length
in the example, that isn&#39;t a constraint.</p>

<h3>Strings Attached</h3>

<p>Direct interpolation of values into strings is a considerable
convenience in programming languages. Their use leads to succinct,
expressive code for string construction. Mainstream Lisp dialects are
missing the boat in this regard. TXR Lisp has better designed string
interpolation than most scripting languages.</p>

<p>Interpolated string literals are called &#34;quasiliterals&#34; in TXR Lisp,
and are delimited by backquotes rather than double quotes. TXR Lisp
avoids the mistaken design of featuring just one kind of string
literal, which supports interpolation. There is a need for strings
which are true literals.</p>

<p>In a backquoted string, the <code>@</code> character denotes the
insertion of the value of an expression. It is followed by an
expression directly, or an expression surrounded in curly braces. 
The curly brace notation solves certain ambiguity problems which arise,
and also allows for the expression of modifiers for expressing field
width, left or right alignment and a separator string for merging list
elements. Example:<br/>
</p>

<pre><span>(</span><span>defvarl</span> <span>str</span> <span>&#34;abc&#34;</span><span>)</span></pre>

<p>Output:</p>
<pre>&#34;abc-abc&#34;</pre>
<p>Both quasiliterals and regular string literals can be prefixed by <code>#</code> which denotes a word list. In the above example, <code>#&#34;how now brown cow&#34;  </code> denotes the list structure <code>(&#34;how&#34; &#34;now&#34; &#34;brown&#34; &#34;cow&#34;).</code> This is prefixed with a quote to express the quoted list <span></span><code>&#39;(&#34;how&#34; &#34;now&#34; &#34;brown&#34; &#34;cow&#34;)</code>.
The ommission of the quote is necessary because word lists can be
embedded in unevaluated structure. However, quasiliterals are
structures intended for evaluation and so the expression <code>#`how now brown cow`</code> <span>evaluates</span> to the list <code>(&#34;how&#34; &#34;now&#34; &#34;brown&#34; &#34;cow&#34;)</code> without the need for a quote. Quasiliteral syntax produces <span>code</span>
which, when evaluated, constructs the implied character string or list
of strings, whereas an ordinary literal denotes a string or list of
strings as program syntax.
</p>

<h3>Objectively Simple</h3>
<p>
TXR Lisp doesn&#39;t have an object system similar to Common Lisp&#39;s CLOS.  Rather,
TXR Lisp&#39;s structures make up a simple object system featuring single dispatch
and multiple inheritance.
</p>

<p>
The term &#34;class&#34; is avoided in TXR Lisp; rather it has
structures (structs) which have object-oriented features.
Struct types must be explicitly defined using the
<code>defstruct</code> macro, or else the underlying API that it uses.
Structs have both instance slots and static slots.  Under inheritance,
a static slot can be overriden with an instance slot or vice versa.
Methods are represented as function values stored in static slots,
and therefore methods &#34;belong&#34; to structs. Dispatch of a method named <code>m</code>
on an object instance <code>o</code> takes place by dispatching the function
stored in the slot named <code>m</code> of <code>o</code>. The function
receives the object as its leftmost argument, followed by the remaining
method arguments.  New static slots can be added to an existing type. Also, a
type which has an inherited static slot can break that relationship and get its
own non-inherited instance of the static slot. This is the basis for method
definitions and redefinitions outside of <code>defstruct</code>.
</p>

<p>
TXR Lisp features a dot notation for referring to struct slots, including
method slots. For instance <code>sim.start-time.(set 42)</code> means
to retrieve the slot <code>start-time</code> of the <code>sim</code>
structure, and then invoke the <code>set</code> method on that
<code>start-time</code>. This notation is a syntactic sugar for the Lisp
syntax <code>(qref sim start-time (set 42))</code>. The <code>qref</code>
symbol has a macro binding; that macro compiles the abstract syntax into
the slot references and function calls that it denotes.
</p>

<p>
Suppose we have a list of objects, and we&#39;d like to call <code>set</code>
on their respective <code>start-time</code> members to reset their
times to zero:
</p>
<pre>(mapdo .start-time.(set 42) obj-list)</pre>
<p>
Here, the dot notation begins with a leading dot. This variant of the notation
doesn&#39;t correspond to <code>qref</code> but to <code>uref</code> (unbound reference):
<code>(uref start-time (set 42))</code>. This <code>uref</code> form compiles
into a higher order function which takes an object as an argument. That function
references the object&#39;s <code>start-time</code> slot and calls the <code>set</code>
method on it.
</p>

<p>
Objects have methods called on construction,
as well as finalizers. When the garbage collector detects an unreachable object
whose finalizers have not yet been called, the finalizers are called at that
time. An object&#39;s finalizers are also called if an exception occurs during its
construction, and may also be called explicitly before the object&#39;s lifetime
ends via the <code>call-finalizers</code> function.  The
<code>with-objects</code> macro instantiates objects in a lexical scope, and
calls their finalizers when their scope ends, enabling some aspects of the
&#34;RAII&#34; idiom from the C++ language to be used in TXR Lisp.
</p>


</div>
  </body>
</html>
