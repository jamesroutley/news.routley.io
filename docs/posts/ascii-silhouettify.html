<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://meatfighter.com/ascii-silhouettify/">Original</a>
    <h1>ASCII Silhouettify</h1>
    
    <div id="readability-page-1" class="page">
<p><img src="https://meatfighter.com/ascii-silhouettify/images/logo-white.svg" alt="AS"/> ASCII Silhouettify</p>

<p id="index">[ <a href="#about" target="_self">About</a> | <a href="#example" target="_self">Example</a> | <a href="#galleries" target="_self">Galleries</a> | <a href="#install" target="_self">Install</a> | <a href="#uninstall" target="_self">Uninstall</a> | <a href="#options" target="_self">Options</a> | <a href="#algorithm" target="_self">Algorithm</a> ]</p>



<p>ASCII Silhouettify is an app that converts images into ASCII silhouettes, a style of ASCII art distinguished by uniformly filled geometric shapes rather than lines or textures. For input, the app expects flat graphics—visuals with minimalistic, high-contrast forms lacking dimensional depth, such as logos, banners, and pixel art. It cannot handle photographs because it does not render shading, highlights, shadows, or gradients.</p>

<p>ASCII Silhouettify restricts itself to the 95 printable ASCII characters, the medium of traditional ASCII artists, as opposed to the line and block characters prevalent in ANSI art or the copious Unicode characters of kaomoji. However, based on user configuration, the app outputs monochrome plain text, text colored with ANSI escape sequences, HTML with or without color, or Neofetch ASCII art format.</p>

<p>ASCII Silhouettify is a desktop app accessible from a browser and from the command-line.</p>





<p>Here is the output of <a href="https://github.com/dylanaraps/neofetch">Neofetch</a> under an instance of Ubuntu:</p>

<p><img id="./images/neofetch-0.png" src="https://meatfighter.com/ascii-silhouettify/images/neofetch-0.png" alt="Neofetch Ubuntu output"/>
</p>

<p>For optimal ASCII art, we obtain a high-resolution image of the Ubuntu logo from the web, and we scale it to the size we want it to appear in the console:</p>

<p><img id="./images/neofetch-1.png" src="https://meatfighter.com/ascii-silhouettify/images/neofetch-1.png" alt="Ubuntu logo"/>
</p>

<p>We run it through the command-line version of ASCII Silhouettify:</p>

<p><img id="./images/neofetch-2.png" src="https://meatfighter.com/ascii-silhouettify/images/neofetch-2.png" alt="Ubuntu logo ANSI art"/>
</p>

<p>By default, ASCII Silhouettify generates text colored with ANSI escape sequences. With the <code>-o</code> flag, we can direct the output to a file that Neofetch will display. But Neofetch inserts a wide margin between ANSI art and the OS metrics. To prevent this, we‘ll use Neofetch‘s <a href="https://github.com/dylanaraps/neofetch/wiki/Custom-Ascii-art-file-format">custom ASCII art file format</a>: </p>

<p><img id="./images/neofetch-4.png" src="https://meatfighter.com/ascii-silhouettify/images/neofetch-4.png" alt="Generating Neofetch ASCII art file"/>
</p>

<p>The first line of the output file is a list of color indices. The successive lines contain the encoded image:</p>

<p><img id="./images/neofetch-5.png" src="https://meatfighter.com/ascii-silhouettify/images/neofetch-5.png" alt="Neofetch ASCII art file"/>
</p>

<p>In a text editor, we copy the first line to the clipboard, and then we remove it.</p>

<p>We invoke Neofetch with the following command, pasting in the value we stored in the clipboard:</p>

<p><img id="./images/neofetch-3.png" src="https://meatfighter.com/ascii-silhouettify/images/neofetch-3.png" alt="Neofetch with improved logo"/>
</p>

<p>Neofetch is a bash script. To make the change permanent, we replace the following part of the script, again using the value we stored in the clipboard.</p>

<p><img id="./images/neofetch-6.png" src="https://meatfighter.com/ascii-silhouettify/images/neofetch-6.png" alt="Neofetch script segment"/>
</p>

<p>For comparison, here is the original logo overlaid on the generated result:</p>

<p><img id="./images/neofetch-7.png" src="https://meatfighter.com/ascii-silhouettify/images/neofetch-7.png" alt="Logos overlaid"/>
</p>

<p>Note how the algorithm selects the largest characters that fit within the outlines of each colored region.</p>




<p>For more examples, click on one of the buttons below.</p>






<p>The command-line version of ASCII Silhouettify is a Node.js application. If you don&#39;t have Node.js installed on your system, follow the steps described <a href="https://nodejs.org/en/learn/getting-started/how-to-install-nodejs">here</a>.</p>

<p>In the Windows Command Prompt or PowerShell (but not WSL), run:</p>

<div>
    <pre>npm install -g ascii-silhouettify</pre>
    </div>

<p>On macOS and Linux (including WSL), you need to use <code>sudo</code>:</p>

<div>
    <pre>sudo npm install -g ascii-silhouettify</pre>
    </div>




<p>In the Windows Command Prompt or PowerShell (but not WSL), run:</p>

<div>
    <pre>npm uninstall -g ascii-silhouettify</pre>
    </div>

<p>On macOS and Linux (including WSL), you need to use <code>sudo</code>:</p>

<div>
    <pre>sudo npm uninstall -g ascii-silhouettify</pre>
    </div>




<p>The browser version and the command-line version support the same set of options. In the command-line version, the <code>-h</code> flag outputs a message that summarizes the information below.</p>


<h2 id="options.input"><a href="#options.input" target="_self">Input</a></h2>

<p>ASCII Silhouettify can convert multiple images at the same time. It supports <code>png</code>, <code>svg</code>, <code>jpg</code>, <code>webp</code>, <code>gif</code>, <code>tif</code>, <code>heif</code>, <code>avif</code>, and <code>pdf</code> image formats. The command-line version‘s <code>-i</code> flag accepts various filename pattern-matching rules (see the help message for details). The input images should have black or transparent backgrounds.</p>


<h2 id="options.output"><a href="#options.output" target="_self">Output</a></h2>

<p>ASCII Silhouettify can output plane or ANSI-colored text, monospaced text in HTML format, or Neofetch‘s custom ASCII art format. The latter is limited to six colors of the <span>256-color</span> extended ANSI palette.</p>


<h2 id="options.palette"><a href="#options.palette" target="_self">Palette</a></h2>

<p>By default, ASCII Silhouettify uses a palette of 240 colors from the <span>256-color</span> extended ANSI palette, excluding the <span>16-color</span> standard ANSI palette, as it is often redefined in modern terminal emulators. However, users have the option to select the first 8 colors of the standard ANSI palette, the full <span>16-color</span> standard ANSI palette, the full <span>256-color</span> extended ANSI palette, or stick with the default <span>240-color</span> palette.</p>


<h2 id="options.colors-and-monochrome"><a href="#options.colors-and-monochrome" target="_self">Colors and Monochrome</a></h2>

<p>The user can specify the maximum number of colors to appear in the output, not counting the presumably black background. The default is 255. Monochrome mode effectively sets this to one. For Neofetch‘s custom ASCII art format, it defaults to six, the maximum number of colors supported by that format.</p>


<h2 id="options.font-size-and-line-height"><a href="#options.font-size-and-line-height" target="_self">Font Size and Line Height</a></h2>

<p>When viewed in a terminal emulator, the aspect ratio of the generated ASCII art depends on the font, font size, line height, and the rounding rules for character dimensions. To optimize it, capture an image of text in the terminal, and measure the size of each monospaced character in pixels, including the space between lines:</p>

<p><img id="./images/intellij.png" src="https://meatfighter.com/ascii-silhouettify/images/intellij.png" alt="Intellij terminal"/>
</p>

<p>Plug the values into the following formulae to determine font size and line height settings.</p>

<p>$\text{font size} = \dfrac{\text{character width}+a}{.78}, a \in [-0.5, 0.5)$</p>

<p>$\text{line height} = \dfrac{.75 (\text{character height} + b)}{\text{font size}}, b \in [-0.5, 0.5) $</p>

<p>Select arbitrary values for $a$ and $b$ within the range $-0.5$ to $0.5$.</p>

<p>Here are some measured character dimensions and suggested settings based on the developer’s Windows desktop:</p>

<div>
    <table>
        <thead>
        <tr>
            <th>Application</th>
            <th>Character Width</th>
            <th>Character Height</th>
            <th>Font Size</th>
            <th>Line Height</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <td>IntelliJ Terminal</td>
            <td>8</td>
            <td>22</td>
            <td>10</td>
            <td>1.65</td>
        </tr>
        <tr>
            <td>Putty</td>
            <td>8</td>
            <td>16</td>
            <td>10</td>
            <td>1.2</td>
        </tr>
        <tr>
            <td>Notepad</td>
            <td>10</td>
            <td>18</td>
            <td>13</td>
            <td>1.04</td>
        </tr>
        <tr>
            <td>Notepad++</td>
            <td>9</td>
            <td>19</td>
            <td>12</td>
            <td>1.2</td>
        </tr>
        <tr>
            <td>Windows Command Prompt</td>
            <td>8</td>
            <td>16</td>
            <td>10</td>
            <td>1.2</td>
        </tr>
        <tr>
            <td>Windows Console Host</td>
            <td>9</td>
            <td>20</td>
            <td>12</td>
            <td>1.25</td>
        </tr>
        <tr>
            <td>Windows Terminal</td>
            <td>9</td>
            <td>19</td>
            <td>12</td>
            <td>1.2</td>
        </tr>
        </tbody>
    </table>
</div>

<p>Your mileage may vary.</p>


<h2 id="options.scale"><a href="#options.scale" target="_self">Scale</a></h2>

<p>Ideally, the input image file should be scaled in a paint program to the size the user wants it to appear in the terminal. However, for minor tweaks, ASCII Silhouettify accepts an image scaling factor, which defaults to one.</p>


<h2 id="options.darkness"><a href="#options.darkness" target="_self">Darkness</a></h2>

<p>The conversion algorithm replaces areas of the image below 5% brightness with space characters, enabling the presumably black background to fully show through. The user can adjust this threshold as needed.</p>


<h2 id="options.threads"><a href="#options.threads" target="_self">Threads</a></h2>

<p>By default, the conversion algorithm distributes work across all available logical processors. The user can reduce the number of allocated processors to as few as one, though this will result in longer processing times.</p>




<p>On the Windows desktop where the developer created ASCII Silhouettify, Terminal renders each monospaced character within a <span>9×19</span> pixel rectangle when configured with the default 12-points, 1.2-em Cascadia Mono font. The developer captured images of the 95 printable ASCII characters and thresholded them at 50% intensity, producing images containing only black and white pixels:</p>

<p><img id="./images/thresholded.png" src="https://meatfighter.com/ascii-silhouettify/images/thresholded.png" alt="Thresholded characters"/>
</p>

<p>The algorithm separates the source image into unique color planes, each a white silhouette on a black background:</p>

<p><img id="./images/planes.png" src="https://meatfighter.com/ascii-silhouettify/images/planes.png" alt="planes"/>
</p>

<p>The algorithm partitions each plane into a matrix of <span>9×19</span> pixel rectangular regions, every one of them destined to be replaced by an ASCII character. To select the optimal character, the algorithm compares a region pixel-by-pixel against every ASCII character image. If a white pixel in a character coincides with a black pixel in the region, the algorithm excludes the character to avoid distorting the silhouette&#39;s outline. Of the remaining characters, the algorithm selects the one with the maximum number of matching white pixels.</p>

<p>When the algorithm replaces a region with an ASCII character, it records the number of matching white pixels. After converting all planes, the algorithm combines them by selecting the characters with the highest number of matching white pixels. Finally, it colors those characters based on the colors of the planes from which they originated.</p>

<p>Prior to converting a source image, the algorithm sorts the ASCII character images by the number of white pixels. As shown below, the space character contains the fewest white pixels (zero), while the at sign contains the most.</p>

<p><img id="./images/sorted.png" src="https://meatfighter.com/ascii-silhouettify/images/sorted.png" alt="Sorted characters"/>
</p>

<p>The algorithm compares each region with the ASCII character images, starting with the at sign and moving downward. As soon as it finds a character that fully fits within the silhouette, the algorithm replaces the region with it because that character contains the greatest number of white pixels.</p>

<p>To significantly speed up the process, the algorithm prepares <span>171 bitmasks</span>, one for each pixel of the <span>9×19</span> pixel rectangular regions. Each bitmask represents the set of ASCII characters images with a black pixel at the coordinates that uniquely identifies the bitmask.</p>

<p>Specifically, each bitmask contains <span>95 bits</span>, where each bit corresponds to an ASCII character image ordered by the number of white pixels: <span>bit-0</span> represents the space character, and <span>bit-94</span> represents the at sign. The algorithm clears all bits in all bitmasks. Then, for each black pixel in each ASCII character image, the algorithm sets the bit corresponding to the character in the bitmask associated with the pixel.</p>

<p>During region conversion, the algorithm maintains a <span>95-bit</span> accumulator that represents a narrowing set of ASCII characters it can use for the replacement. When it begins to convert a region, the algorithm initializes the accumulator to all ones, indicating all characters are initially considered. Then, for each black pixel in the region, the algorithm updates the accumulator to the current accumulator value bitwise ANDed with the bitmask corresponding to the pixel. That operation excludes all ASCII character images with a white pixel at a location where a black pixel exists in the region.</p>

<p>After the algorithm repeats that process across the region, the accumulator‘s set bits represent the remaining characters that can replace the region. Since the characters are ordered, the number of leading zeros in the accumulator is the index of the ASCII character image with the greatest number of white pixels fully contained within the plane‘s silhouette. With the help of a library, the algorithm invokes a microprocessor instruction for <a href="https://en.wikipedia.org/wiki/Find_first_set">counting leading zeros</a> to obtain the value it needs rapidly.</p>

<p>When the algorithm partitions the source image into a matrix of rectangular regions, the origin of the matrix affects the outcome. To optimize the result, the algorithm repeats the entire image conversion for all integer-coordinate origins within a <span>9×19</span> pixel area around the image origin. It then returns the best result found. To manage the extensive processing required, the algorithm distributes the work among the available logical processors.</p>

<p>Based on user configuration, the algorithm limits itself to a palette that ranges from just the first eight colors of the standard ANSI palette to the full <span>256-color</span> extended ANSI palette. To separate the source image into unique color planes, the algorithm employs the computationally expensive <a href="http://www.brucelindbloom.com/index.html?Eqn_DeltaE_CIE2000.html">CIEDE2000</a> perceptual color difference formula to find the closest colors within the palette.</p>

<p>The source is available from the following repositories:</p>

<ul>
    <li><a href="https://github.com/meatfighter/ascii-silhouettify">Command-line version</a></li>
    <li><a href="https://github.com/meatfighter/quasar-ascii-silhouettify">Browser version</a></li>
</ul>

<hr/>




</div>
  </body>
</html>
