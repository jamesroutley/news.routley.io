<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/rex-rs/rex">Original</a>
    <h1>Rex is a safe kernel extension framework that allows Rust in the place of eBPF</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text"><div data-snippet-clipboard-copy-content=" ____  _______  __  _____      _                 _
|  _ \| ____\ \/ / | ____|_  _| |_ ___ _ __  ___(_) ___  _ __  ___
| |_) |  _|  \  /  |  _| \ \/ / __/ _ \ &#39;_ \/ __| |/ _ \| &#39;_ \/ __|
|  _ &lt;| |___ /  \  | |___ &gt;  &lt;| ||  __/ | | \__ \ | (_) | | | \__ \
|_| \_\_____/_/\_\ |_____/_/\_\\__\___|_| |_|___/_|\___/|_| |_|___/
"><pre><code> ____  _______  __  _____      _                 _
|  _ \| ____\ \/ / | ____|_  _| |_ ___ _ __  ___(_) ___  _ __  ___
| |_) |  _|  \  /  |  _| \ \/ / __/ _ \ &#39;_ \/ __| |/ _ \| &#39;_ \/ __|
|  _ &lt;| |___ /  \  | |___ &gt;  &lt;| ||  __/ | | \__ \ | (_) | | | \__ \
|_| \_\_____/_/\_\ |_____/_/\_\\__\___|_| |_|___/_|\___/|_| |_|___/

</code></pre></div>

<p dir="auto"><a href="https://github.com/rex-rs/rex/actions"><img src="https://camo.githubusercontent.com/188b9534a41ba6ad92302c6b74a9cd0076ef8803864631cd1b6d193f3bad25a4/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f616374696f6e732f776f726b666c6f772f7374617475732f7265782d72732f7265782f2e676974687562253246776f726b666c6f77732532466d65736f6e2e796d6c3f6c6162656c3d6369" alt="CI" data-canonical-src="https://img.shields.io/github/actions/workflow/status/rex-rs/rex/.github%2Fworkflows%2Fmeson.yml?label=ci"/></a>
<a href="https://www.gentoo.org" rel="nofollow"><img src="https://github.com/rex-rs/rex/raw/main/docs/image/gentoo-badge3.svg" alt="Gentoo"/></a></p>

<ul dir="auto">
<li><a href="#what-is-rex">What is Rex</a></li>
<li><a href="#example-program">Example program</a></li>
<li><a href="#build-and-run">Build and run</a></li>
<li><a href="#documentations">Documentations</a></li>
<li><a href="#why-rex">Why Rex</a></li>
<li><a href="#license">License</a></li>
</ul>

<p dir="auto">Rex is a safe and usable kernel extension framework that allows loading and
executing Rust kernel extension programs in the place of eBPF. Unlike
eBPF-based frameworks such as <a href="https://aya-rs.dev" rel="nofollow">Aya</a>, Rex programs do
not go through the in-kernel verifier, instead, the programs are
implemented in the safe subset of Rust, on which the Rust compiler performs
the needed safety checks and generates native code directly. This approach
avoids the overly restricted verification requirements (e.g., program
complexity constraints) and the resulting arcane verification errors, while
at the same time potentially provides a better optimization opportunity in
the native compiler backend (i.e., LLVM) than the eBPF backend + in-kernel
JIT approach.</p>
<p dir="auto">Rex currently supports the following features:</p>
<ul dir="auto">
<li>5 eBPF program types: <code>kprobe</code>, <code>perf_event</code>, <code>tracepoint</code>, <code>xdp</code>, and
<code>tc</code>.</li>
<li>invocation of eBPF helper functions that are commonly used by these
programs</li>
<li>interaction with eBPF maps</li>
<li>RAII-style management of kernel resources obtainable by programs</li>
<li>cleanup and in-kernel exception handling of Rust runtime panics with call
stack traces</li>
<li>kernel stack (only when CFG cannot be computed statically) and
termination safety from a thin in-kernel runtime</li>
<li>bindings and abstractions of kernel data types commonly needed by eBPF
programs</li>
</ul>

<p dir="auto">The following example implements a kprobe program that attaches to a
selected system call and injects an error (specified by <code>errno</code>) to the
system call on a process (specified by its <code>pid</code>). The full example,
including the loader program, can be found under
<a href="https://github.com/rex-rs/rex/blob/main/samples/error_injector">samples/error_injector</a>.</p>
<div dir="auto" data-snippet-clipboard-copy-content="#![no_std]
#![no_main]

use rex::kprobe::kprobe;
use rex::map::RexHashMap;
use rex::pt_regs::PtRegs;
use rex::rex_kprobe;
use rex::rex_map;
use rex::Result;

#[allow(non_upper_case_globals)]
#[rex_map]
static pid_to_errno: RexHashMap&lt;i32, u64&gt; = RexHashMap::new(1, 0);

#[rex_kprobe]
pub fn err_injector(obj: &amp;kprobe, ctx: &amp;mut PtRegs) -&gt; Result {
    obj.bpf_get_current_task()
        .map(|t| t.get_pid())
        .and_then(|p| obj.bpf_map_lookup_elem(&amp;pid_to_errno, &amp;p).cloned())
        .map(|e| obj.bpf_override_return(ctx, e))
        .ok_or(0)
}"><pre><span>#!<span>[</span>no_std<span>]</span></span>
<span>#!<span>[</span>no_main<span>]</span></span>

<span>use</span> rex<span>::</span>kprobe<span>::</span>kprobe<span>;</span>
<span>use</span> rex<span>::</span>map<span>::</span><span>RexHashMap</span><span>;</span>
<span>use</span> rex<span>::</span>pt_regs<span>::</span><span>PtRegs</span><span>;</span>
<span>use</span> rex<span>::</span>rex_kprobe<span>;</span>
<span>use</span> rex<span>::</span>rex_map<span>;</span>
<span>use</span> rex<span>::</span><span>Result</span><span>;</span>

<span>#<span>[</span>allow<span>(</span>non_upper_case_globals<span>)</span><span>]</span></span>
<span>#<span>[</span>rex_map<span>]</span></span>
<span>static</span> pid_to_errno<span>:</span> <span>RexHashMap</span><span>&lt;</span><span>i32</span><span>,</span> <span>u64</span><span>&gt;</span> = <span>RexHashMap</span><span>::</span><span>new</span><span>(</span><span>1</span><span>,</span> <span>0</span><span>)</span><span>;</span>

<span>#<span>[</span>rex_kprobe<span>]</span></span>
<span>pub</span> <span>fn</span> <span>err_injector</span><span>(</span><span>obj</span><span>:</span> <span>&amp;</span><span>kprobe</span><span>,</span> <span>ctx</span><span>:</span> <span>&amp;</span><span>mut</span> <span>PtRegs</span><span>)</span> -&gt; <span>Result</span> <span>{</span>
    obj<span>.</span><span>bpf_get_current_task</span><span>(</span><span>)</span>
        <span>.</span><span>map</span><span>(</span>|t| t<span>.</span><span>get_pid</span><span>(</span><span>)</span><span>)</span>
        <span>.</span><span>and_then</span><span>(</span>|p| obj<span>.</span><span>bpf_map_lookup_elem</span><span>(</span><span>&amp;</span>pid_to_errno<span>,</span> <span>&amp;</span>p<span>)</span><span>.</span><span>cloned</span><span>(</span><span>)</span><span>)</span>
        <span>.</span><span>map</span><span>(</span>|e| obj<span>.</span><span>bpf_override_return</span><span>(</span>ctx<span>,</span> e<span>)</span><span>)</span>
        <span>.</span><span>ok_or</span><span>(</span><span>0</span><span>)</span>
<span>}</span></pre></div>
<p dir="auto">More sample programs can be found under <a href="https://github.com/rex-rs/rex/blob/main/samples">samples</a>.</p>

<p dir="auto">You can find the detailed guide <a href="https://github.com/rex-rs/rex/blob/main/docs/getting-started.md">here</a>.</p>

<p dir="auto">Additional design documentations can be found under <a href="https://github.com/rex-rs/rex/blob/main/docs">docs</a>.</p>

<p dir="auto">The existing eBPF extension relies on the in-kernel eBPF verifier to
provide safety guarantees. This unfortunately leads to usability issues
where safe programs are rejected by the verifier, including but not limited
to:</p>
<ul dir="auto">
<li>programs may exceed the inherent complexity contraints of static
verification</li>
<li>compilers may not generate verifier-friendly code</li>
<li>same logic may need to be implemented in a certain way to please the
verifier</li>
</ul>
<p dir="auto">Rex aims to address these issues by directly leveraging the safety
guarantee from <em>safe Rust</em>. Developers can implement their programs in any
way that can be written in safe Rust with <a href="https://github.com/rex-rs/rex/blob/main/docs/rust_rex_subset.md">few
restrictions</a>, and no longer need to worry about
program complexity, the code generator, or finding the (many time
counter-intuitive) way of expressing the same logic to please the verifier.</p>
<p dir="auto">We demonstrate this with the implementation of the <a href="https://github.com/Orange-OpenSource/bmc-cache">BPF Memcached Cache
(BMC)</a>, a state-of-the-art
extension program for Memcached acceleration. As a complex eBPF program,
BMC is forced to be splitted into several components connected by BPF
tail-calls and use awkward loop/branch implementations to please the
verifier, which are totally not needed in <a href="https://github.com/rex-rs/rex/blob/main/samples/bmc">its Rex
implementation</a>.</p>
<p dir="auto">For example, we show the code in cache invalidation logic of the BPF-BMC
that searches for a <code>SET</code> command in the packet payload:</p>
<div dir="auto" data-snippet-clipboard-copy-content="// Searches for SET command in payload
for (unsigned int off = 0;
     off &lt; BMC_MAX_PACKET_LENGTH &amp;&amp;  payload + off + 1 &lt;= data_end;
     off++) {
    if (set_found == 0 &amp;&amp; payload[off] == &#39;s&#39; &amp;&amp;
        payload + off + 3 &lt;= data_end &amp;&amp; payload[off + 1] == &#39;e&#39; &amp;&amp;
        payload[off + 2] == &#39;t&#39;) {
            off += 3;
            set_found = 1;
    }
    ...
}"><pre><span>// Searches for SET command in payload</span>
<span>for</span> (<span>unsigned <span>int</span></span> <span>off</span> <span>=</span> <span>0</span>;
     <span>off</span> <span>&lt;</span> <span>BMC_MAX_PACKET_LENGTH</span> <span>&amp;&amp;</span>  <span>payload</span> <span>+</span> <span>off</span> <span>+</span> <span>1</span> &lt;= <span>data_end</span>;
     <span>off</span><span>++</span>) {
    <span>if</span> (<span>set_found</span> <span>==</span> <span>0</span> <span>&amp;&amp;</span> <span>payload</span>[<span>off</span>] <span>==</span> <span>&#39;s&#39;</span> <span>&amp;&amp;</span>
        <span>payload</span> <span>+</span> <span>off</span> <span>+</span> <span>3</span> &lt;= <span>data_end</span> <span>&amp;&amp;</span> <span>payload</span>[<span>off</span> <span>+</span> <span>1</span>] <span>==</span> <span>&#39;e&#39;</span> <span>&amp;&amp;</span>
        <span>payload</span>[<span>off</span> <span>+</span> <span>2</span>] <span>==</span> <span>&#39;t&#39;</span>) {
            <span>off</span> <span>+=</span> <span>3</span>;
            <span>set_found</span> <span>=</span> <span>1</span>;
    }
    ...
}</pre></div>
<p dir="auto">The code not only introduces an extra constraint in the loop (<code>off &lt; BMC_MAX_PACKET_LENGTH</code>) solely for passing the verifier, but also employs
repeated boilerplate code to check packet ends (<code>data_end</code>) and cumbersome
logic to match the <code>&#34;set&#34;</code> string in the packet.</p>
<p dir="auto">None of these burdens is needed with the power of safe Rust in Rex, which
has no complexity limits and provides more freedom on the implementation:</p>
<div dir="auto" data-snippet-clipboard-copy-content="let set_iter = payload.windows(4).enumerate().filter_map(|(i, v)| {
    if v == b&#34;set &#34; {
      Some(i)
    } else {
      None
    }
});
"><pre><span>let</span> set_iter = payload<span>.</span><span>windows</span><span>(</span><span>4</span><span>)</span><span>.</span><span>enumerate</span><span>(</span><span>)</span><span>.</span><span>filter_map</span><span>(</span>|<span>(</span>i<span>,</span> v<span>)</span>| <span>{</span>
    <span>if</span> v == <span>b&#34;set &#34;</span> <span>{</span>
      <span>Some</span><span>(</span>i<span>)</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>None</span>
    <span>}</span>
<span>}</span><span>)</span><span>;</span></pre></div>
<p dir="auto">The full implementation of BMC in Rex can be found at
<a href="https://github.com/rex-rs/rex/blob/main/samples/bmc">samples/bmc</a>.</p>

<p dir="auto">Rex is licensed under the GPLv2 license. The submodules (Linux, Rust, LLVM)
in this repo are licensed under their own terms. Please see the
corresponding license files for more details. Additionally, the memcached
benchmark is licensed under the MIT license.</p>
</article></div></div>
  </body>
</html>
