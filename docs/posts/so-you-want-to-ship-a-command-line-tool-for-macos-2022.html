<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://becca.ooo/blog/so-you-want-to-ship-a-command-line-tool-for-macos/">Original</a>
    <h1>So You Want to Ship a Command-Line Tool for macOS (2022)</h1>
    
    <div id="readability-page-1" class="page"><div id="main">
        
<p>A word of advice: <strong>don’t.</strong></p>
<p>At work, I’ve written a command-line tool which sets up the developer
environment. It installs the Nix package manager, sets up a local Postgres
instance, and handles all the complex bits of configuration. It does all of
this on Linux and macOS, and it supports <code>bash</code>, <code>zsh</code>, and <code>fish</code> for shell
configuration.</p>
<p>We build and publish releases with GitHub actions, so that engineers can
download and run the latest version of the tool when they need to set up a new
machine or repair the development environment on an existing machine.</p>
<p>On Linux, this is all fine and dandy (<a href="https://nixos.wiki/wiki/Packaging/Binaries">the usual headaches with running
anything on NixOS aside</a>), but macOS requires that
programs be code signed and notarized.</p>
<p>Code signing on macOS is a <em>nightmare.</em> Knowing a little bit about asymmetric
encryption, I expected the process to be roughly like this:</p>
<ol>
<li>Generate a public and private key (this is a blob of binary data, or roughly
“a file”).</li>
<li>Get Apple to make a certificate signed with my public key (this certificate
is also a file).</li>
<li>Run a program, pointing it to the files containing my private key and
certificate, which “signs” an executable for distribution.</li>
<li>When users go to run my program, the operating system can see that it’s
signed with a valid Apple certificate and run it without issue.</li>
</ol>
<p>This is not, in fact, how it works.</p>
<p>The first problem is that Apple provides no less than eight different sorts of
certificates, with little documentation on what they’re used for, so expect to
generate a half-dozen certificates and revoke several before you have a working
one.</p>
<p>The next issue is that the <code>codesign</code> command-line tool has a really opaque and
complex interface. There’s several options you need to actually run code that
aren’t really indicated as such (<code>-o runtime</code> and <code>-timestamp</code>, for instance,
are mandatory for notarization).</p>
<p>There’s few instructions for getting certificates into the keychain without GUI
access (like, for instance, to sign code in CI), and Apple doesn’t have much
documentation for signing anything that’s not built with Xcode.</p>
<p>I was able to solve most of the issues with actually signing code with the
<em>fantastic</em> <a href="https://gregoryszorc.com/blog/2022/04/25/expanding-apple-ecosystem-access-with-open-source,-multi-platform-code-signing/"><code>rcodesign</code> tool written by Gregory Szorc,</a> which has a
very reasonable command-line interface that actually takes all the keys and
certificates as files. I’ll excerpt a paragraph from the linked blog post that
rings true to me (emphasis my own):</p>
<blockquote>
<p>I’ve learned way too much around minutia around how Apple code signing
actually works. <strong>The mechanism is way too complex for something in the
security space.</strong> There was at least one high profile Gatekeeper bug in the
past year allowing improperly signed code to run. I suspect there will be
more: the surface area to exploit is just too large.</p>
</blockquote>

<p>Once I had succeeded in signing an executable and verifying it, I immediately
ran into another issue: <a href="https://developer.apple.com/forums/thread/706379">Gatekeeper blocks command-line tools from running when
clicked.</a> Apparently this is a “known bug in macOS”, though
because it’s filed in Apple’s proprietary “Radar” bug-tracker, I can’t see any
of the details or if there are any plans to fix it.</p>
<p>This is especially unfortunate because when an engineer downloads the binary
from GitHub on macOS, the downloads pop up from the bottom of the screen, just
begging to be clicked on.</p>
<p>The solution, Quinn from the Apple Developer Forums tells us, is to “embed your
tool in an application.” This, as far as I can tell, doesn’t work either, but
let’s run through it.</p>
<p>There’s a long guide on <a href="https://developer.apple.com/documentation/xcode/embedding-a-helper-tool-in-a-sandboxed-app">Embedding a Command-Line Tool in a Sandboxed
App,</a> so I followed that, and then slowly, painfully, factored
Xcode out of it, so that I wouldn’t have to figure out how to get a 10GB Xcode
install onto the CI machine (remember, you need to be signed in to an Apple ID
to download Xcode, and there’s no way to do it from the command-line).</p>
<p>With <a href="https://www.witchoflight.com/">Cassie’s</a> help, I produced a short Swift script which (I hoped)
would do what I want: First, it finds the embedded command-line tool binary
with the <a href="https://developer.apple.com/documentation/foundation/bundle/1411412-url"><code>Bundle.url(forAuxiliaryExecutable:)</code></a> method. Then, that
URL is passed to the <a href="https://developer.apple.com/documentation/appkit/nsworkspace/3172702-open"><code>NSWorkspace.open(urls:, withApplicationAt:)</code></a> method to run the embedded command-line
tool in a new window. Finally, the <code>completionHandler</code> closes the app once the
terminal window is open.</p>
<p>(There’s <a href="https://github.com/apple/swift/issues/55127">a bug in Swift</a> that makes the <code>@main</code> attribute,
mandatory for SwiftUI apps, not work, so I needed to run <code>swiftc</code> myself,
adding a mysterious <code>-parse-as-library</code> option to fix the bug. I also needed to
<a href="https://stackoverflow.com/questions/46532610/swiftc-possible-values-for-target-command-line-option">read the Swift source code</a> to determine the possible values for
the <code>-target</code> command-line option.)</p>
<p>Now, we have to code sign:</p>
<ol>
<li>The Swift wrapper script.</li>
<li>The original command-line tool.</li>
<li>The <code>.app</code> containing both of the above.</li>
<li>The <code>.dmg</code> containing the <code>.app</code>, because an <code>.app</code> is just a directory, so
you need to zip it up to distribute it.</li>
</ol>
<p>We also need to notarize the <code>.app</code> and the <code>.dmg</code>. Interestingly, you can only
notarize <code>.pkg</code>, <code>.dmg</code>, and <code>.app</code> files (in <code>.zip</code>s) — command-line tools can
only be notarized if they’re embedded in one of the listed containers.</p>
<p>Most of the notarization docs tell you to use <code>altool</code>, which, only once you
actually get it to upload something for notarization, will tell you that it’s
deprecated and replaced by <code>notarytool</code>. <code>notarytool</code> will print <code>status: Invalid</code> if anything fails, with no additional details. (There’s a separate
<code>notarytool</code> subcommand you can use to fetch logs with more information, but
nothing in the output tells you this is an option, including turning on
verbose/debug logging.)</p>
<p>Anyways, once the app was assembled and passing all of Apple’s validation
tools, it, uh, continued to not work!</p>
<p>You can double click the app to run it, but when it tries to launch the
embedded command-line tool, we get an error that “<code>mytool-cli</code> can’t be opened
because the identity of the developer cannot be confirmed“, followed by “The
application ‘Terminal’ can’t be opened. -128”.</p>
<p>I do get one error with Apple’s tooling on these files; though the <code>.app</code>
itself passes all the checks, the embedded tool fails <code>spctl</code>’s validation:</p>
<pre><code>$ spctl -a -v --raw ./mytool
./mytool: rejected (the code is valid but does not seem to be an app)
&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;
&lt;!DOCTYPE plist PUBLIC &#34;-//Apple//DTD PLIST 1.0//EN&#34; &#34;http://www.apple.com/DTDs/PropertyList-1.0.dtd&#34;&gt;
&lt;plist version=&#34;1.0&#34;&gt;
&lt;dict&gt;
	&lt;key&gt;assessment:authority&lt;/key&gt;
	&lt;dict&gt;
		&lt;key&gt;assessment:authority:flags&lt;/key&gt;
		&lt;integer&gt;0&lt;/integer&gt;
		&lt;key&gt;assessment:authority:source&lt;/key&gt;
		&lt;string&gt;obsolete resource envelope&lt;/string&gt;
		&lt;key&gt;assessment:authority:weak&lt;/key&gt;
		&lt;true/&gt;
	&lt;/dict&gt;
	&lt;key&gt;assessment:cserror&lt;/key&gt;
	&lt;integer&gt;-67002&lt;/integer&gt;
	&lt;key&gt;assessment:remote&lt;/key&gt;
	&lt;true/&gt;
	&lt;key&gt;assessment:verdict&lt;/key&gt;
	&lt;false/&gt;
&lt;/dict&gt;
&lt;/plist&gt;
</code></pre>
<p>Googling for “obsolete resource envelope” gives several different bugs over a
period of years, none of which apply, and anyways <code>spctl -a -v --raw</code> shows the
same error for the <code>/bin/ls</code> that gets shipped with macOS.</p>
<p>That’s where we’re at today. I’ve <a href="https://developer.apple.com/forums/thread/713932">reported this issue on the Apple Developer
Forums,</a> but I don’t expect to get any actionable advice back,
seeing as this distribution pathway is already attempting to work around
several “known” macOS bugs.</p>

<p>All of these tools and all of their error messages are <em>garbage.</em> (<code>rcodesign</code>,
being not written by Apple, is a notable exception.) Here are some of the
commands you might run to check code signatures:</p>
<pre><code>spctl -a -v --raw mytool.app
codesign -verify -vvvv mytool.app
codesign -d -vvv --entitlements :- mytool.app
codesign -vvvv -R=notarized --check-notarization mytool.app
</code></pre>
<p>Just absolute spews of letters with no discernible meaning and certainly no
reasonable intuition.</p>
<p>On the Apple Developer Forums, <a href="https://developer.apple.com/forums/thread/696235">MirrorMan posts about roughly the same
issue</a> with frustration:</p>
<blockquote>
<blockquote>
<p>If the product is signed, notarised, and stapled correctly, everything
should work. If not, you’ll need to investigate why Gatekeeper is unhappy
(2), fix that, and then retest.</p>
</blockquote>
<p>“Fix that” !!!!!! No! Just no! There MUST be a way for Gatekeeper/spctl to
render an exact description of whether or not it will run something (apps,
command line tools, …) on arbitrary customer machines, immediately, right
away, from the development machine, bypassing any caching or anything else.
How many thousands of 3rd party developer days need to be lost for one Apple
developer to spend a few days to update spctl to produce 100% accurate and
useful messaging? For example, the messaging out of notarytool was very good!
It told me which of the half-dozen hoops I had to jump through next
(keychains! app-specific passwords!). It just takes too too long to do the
research to figure out what to do at all, only to be confronted with an
inexplicable error. $237billion a year, and developers have to guess? Apple
can do better. Sorry for the rant but it is necessary.</p>
</blockquote>
<p>I don’t have much more to add, except that I’ve gained a lot of empathy for my
friends who have turned their backs on the Apple ecosystem entirely for exactly
this sort of developer-hostile behavior.</p>
<h2 id="moving-on">Moving on</h2>
<p>So, what can we do with all of this? We have a few options, but none of them
are particularly appealing.</p>
<ol>
<li>
<p>Maintain the status quo; tell users to <code>chmod +x</code> and <code>xattr -d com.apple.quarantine</code> the downloaded executable. This bypasses the code
signing mechanism but requires the user copy/paste magic commands.</p>
<p>It’s fine, ultimately — the users are engineers, so they can manage a
terminal or we can teach them to — but it’s not particularly “clean”,
especially when Apple (theoretically) offers code signing mechanisms for
this exact purpose, which my employer already pays for.</p>
</li>
<li>
<p>Download the file with <code>curl</code>. Unix command-line tools like <code>curl</code> and <code>tar</code>
don’t add the quarantine bit to the files they create on macOS, so it’s
pretty easy to run software downloaded with them.</p>
<p>Unfortunately, the repository where this tool is developed is private, so
unauthenticated <code>curl</code> downloads won’t work. I’m seriously considering
asking the CTO if we can make the repository public <em>solely</em> so we can use
<code>curl</code> as a distribution mechanism. I could even write a platform-detecting
shell script!</p>
</li>
<li>
<p>Reimplement the entire thing in Swift and distribute it as an App built with
Xcode without any embedded tools.</p>
<p>Hahahaha. Just kidding.</p>
</li>
<li>
<p>Distribute the tool as a custom Homebrew tap or something similar.</p>
<p>This tool is responsible for <em>installing</em> Homebrew, and moreover I work at a
Nix startup so plenty of engineers <em>refuse</em> to install Homebrew. I
think this is a little bit silly, but it’s my job to support them and deliver the
smoothest possible developement experience, so we can’t really distribute
this with Homebrew.</p>
</li>
</ol>
<p>I think I’ll probably distribute a code-signed executable, and macOS will say
it can’t figure out who made it even though their own tools say the signature
is fine, and I’ll cry myself to sleep at night.</p>
<h2 id="conclusions">Conclusions</h2>
<ol>
<li>
<p>Do not attempt to “create software” for macOS. They don’t want you to. If
you want to run your own programs, install Linux and suffer like you’re
supposed to.</p>
</li>
<li>
<p>If you need to code sign software for Apple computers, use
<a href="https://gregoryszorc.com/blog/2022/04/25/expanding-apple-ecosystem-access-with-open-source,-multi-platform-code-signing/"><code>rcodesign</code></a>.</p>
</li>
</ol>

        
        
    </div></div>
  </body>
</html>
