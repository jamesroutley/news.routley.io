<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.netlify.com/blog/how-we-run-nextjs/">Original</a>
    <h1>Netlify deploys hundreds of thousands of Next.js sites – here&#39;s what challenging</h1>
    
    <div id="readability-page-1" class="page"><div data-sb-object-id="1269ee7f-2b2a-4b7d-8c9a-abb832f4d271" data-pagefind-body="" data-astro-cid-7jjqptxk="">  <div data-astro-cid-7jjqptxk="">  <article id="post-content" data-sb-field-path="markdown" data-pagefind-index-attrs="excerpt" data-astro-cid-7jjqptxk=""> <div data-astro-cid-7jjqptxk="true" data-astro-cid-cnvtppup=""> <h2 id="a-note-about-this-moment">A note about this moment</h2>
<p>We actually sat on this post for a while, taking time to figure out how best to present the facts and suggestions below, without it appearing as a takedown post. After all, we are in competition with Vercel in the platform space.</p>
<p>Then, the recent <a href="https://nextjs.org/blog/cve-2025-29927">security incident</a> around Next.js middleware happened, triggering a <a href="https://x.com/pilcrowonpaper/status/1903349591409303894">small fire on social</a> and drawing criticism about how the incident was handled.</p>
<p>This article is <em>not</em> about that security incident. Rather, it is about the larger context of the current challenges in making sure Next.js runs as intended for customers. Many of these — as well as, arguably, the incident response — are related to the closed nature of how Next.js is maintained. But there is now <a href="https://vercel.com/blog/postmortem-on-next-js-middleware-bypass#next-steps">an honest effort</a> by everyone to tackle this problem.</p>
<p>Our aim here is to provide a better picture of the challenges, and draft a path for collaboration going forward.</p>
<h2 id="re-introducing-nextjs">Re-introducing Next.js</h2>
<p>Next.js is an open-source web development framework, created and <a href="https://nextjs.org/governance">governed by Vercel</a>, a cloud provider that offers managed hosting of Next.js as a service.</p>
<p>The framework’s innovations on top of React has made it a preferred tool for many developers for good reason: it has introduced concepts like built-in support for SSR, SSG, ISR, and API routes.</p>
<p>At Netlify, we’re proud to offer comprehensive Next.js support, ensuring developers have deployment choices without sacrificing functionality. However, maintaining this level of support for Next.js comes at a cost and presents unique engineering challenges. These challenges aren’t just limited to Netlify, but across peers like Cloudflare, AWS Amplify Hosting, SST, Google Firebase App Hosting, and Microsoft Azure Static Web Apps.</p>
<p>Let’s take a behind-the-scenes look at the work Netlify’s engineers do to maintain <a href="https://runtime-e2e-report.netlify.app/">feature parity</a> with Vercel’s platform, and the work we do to stay on top of a steady stream of changes to Next.js.</p>
<h2 id="challenge-1-no-adapter-support">Challenge #1: no adapter support</h2>
<p>A major benefit of open-source software is its portability — developers and organizations should have the freedom to move between different providers without fear of getting locked into a specific vendor. For example, the <code>npm</code> CLI integrates with both npm, Inc.’s registry as well as all third-party registries, as does Docker with DockerHub, among countless examples.</p>
<p>To achieve this, most modern web development frameworks use the concept of <em>adapters</em>, <em>plugins</em>, or <em>presets</em> to tailor the output of the framework to a specific deployment target. Providers need this to provision and configure the infrastructure needed to power your applications. Examples include <a href="https://remix.run/docs/en/main/discussion/runtimes">Remix</a>, <a href="https://docs.astro.build/en/reference/adapter-reference/">Astro</a>, <a href="https://kit.svelte.dev/docs/adapters">SvelteKit</a>, <a href="https://www.gatsbyjs.com/docs/how-to/previews-deploys-hosting/adapters/">Gatsby</a>, and <a href="https://qwik.dev/docs/deployments/">Qwik</a>.</p>
<p><img src="https://cdn.sanity.io/images/o0o2tn5x/production/0c72178bb9d40ab9ce0792cdba9a746349a82bf5-1155x1071.png" alt=""/></p>
<p><em>A framework (Astro) with first-class support for swappable build adapters, each targeting a deployment environment or provider</em></p>
<p>Some frameworks go even further: <a href="https://nuxt.com/">Nuxt</a>, <a href="https://analogjs.org/">Analog</a>, <a href="https://start.solidjs.com/">SolidStart</a>, and <a href="https://tanstack.com/start/">TanStack Start</a> all use the same underlying mechanism (<a href="https://nitro.build/">Nitro</a>) and thus share deployment target presets. The desired utility and scope of such common foundations is a fast-moving topic with differing opinions playing out in the open, just as it should be.</p>
<p><img src="https://cdn.sanity.io/images/o0o2tn5x/production/2648698ca020172fcea68f3af3026e017912a623-1573x1066.png" alt=""/></p>
<p><em>Nitro-based frameworks also have first-class support for swappable build adapters, but go further by sharing their adapters</em></p>
<p>These patterns allows frontend developers to keep the core of their code untouched and merely swap the adapter if they decide to deploy to another provider.</p>
<p>These adapters can be maintained by framework authors, hosting providers, the community, or all of the above. Frameworks are typically structured so that anyone can build their own adapter in case one isn’t available for the provider of their choice. This is possible because they have a publicly documented adapter specification. This also means fewer surprises, as changes to the adapter interface follow semantic versioning conventions.</p>
<p>On their end, platform vendors typically have their documented API for how frameworks should interact with the platform, which any framework can use. In our case, that is the <a href="https://docs.netlify.com/frameworks-api/">Netlify Frameworks API</a>.</p>
<p><img src="https://cdn.sanity.io/images/o0o2tn5x/production/13ea271d8eef27f385e17e0b8c821c354799660f-1252x572.png" alt=""/></p>
<p><em>How Netlify builds a site using a framework (Astro) with a Netlify build adapter, as an example</em></p>
<p>The unique challenge with Next.js is that, although Vercel (the platform) has a <a href="https://vercel.com/docs/build-output-api/v3">Build Output API</a> for frameworks since 2022, Next.js itself does not conform to this API and it has no adapter mechanism through which any other actor can support another platform. Rather, Next.js builds use a private, largely undocumented format that is subject to change.</p>
<p>Instead, providers like Netlify, Cloudflare, AWS Amplify Hosting, SST, Google Firebase App Hosting, and Microsoft Azure Static Web Apps must instead read the Vercel-tailored, partly-undocumented build output from disk, translate it to their own format, and write this back to disk.</p>
<p><img src="https://cdn.sanity.io/images/o0o2tn5x/production/151d92c8f6575a925feab9287cb9650eafcb342a-1543x652.png" alt=""/></p>
<p><em>Next.js builds are only compatible with Vercel, so other platforms (like Netlify) must transform it to their own format after the fact</em></p>
<p>At Netlify, we automatically run <a href="https://docs.netlify.com/build-plugins/">a build plugin</a> (<a href="https://github.com/opennextjs/opennextjs-netlify">the OpenNext Netlify adapter</a>) after Next.js builds. Coupled with comprehensive automated tests (both the framework’s own tests that we run, and our own test suites), the end result is a robust Next.js experience on Netlify. For the vast majority of sites this works out of the box with zero configuration. However, the implementation would be much simpler, easier to maintain, and easier for the community to contribute to if Next.js followed the established adapter pattern. This has been discussed on and off for some time, but really took off since the OpenNext group was expanded to clearly voice the needs of multiple actors. Now, it’s <a href="https://x.com/feedthejim/status/1903837444648382758">finally in motion</a>!</p>
<h2 id="challenge-2-no-production-grade-documentation-for-serverless-deployments">Challenge #2: No production-grade documentation for serverless deployments</h2>
<p><a href="https://nextjs.org/docs/pages/building-your-application/deploying">The Next.js deployment docs</a> list these deployment options:</p>
<blockquote>
<p>You can deploy managed Next.js with Vercel, or self-host on a Node.js server, Docker image, or even static HTML files.</p>
</blockquote>
<p>Here, “a Node.js server” refers to <em>one Node.js server</em>. A single, unique instance of a Node.js server (with or without Docker) with no horizontal scaling and no zero-downtime deploys is not a viable deployment strategy for serious projects, and fully static sites cover limited Next.js use cases these days. Out of the box, this does not support much of the functionality that makes Next.js powerful at scale: edge middleware, globally persistent page and fetch caching enabling Incremental Static Regeneration and on-demand revalidation, to name a few.</p>
<p>The <a href="https://nextjs.org/docs/pages/building-your-application/deploying#caching-and-isr">self-hosting docs</a> briefly touch on some complexities (emphasis ours):</p>
<blockquote>
<p>Caching and revalidating pages (using Incremental Static Regeneration (ISR) or newer functions in the App Router) use the same shared cache.</p>
<p>[…]</p>
<p>By default, generated cache assets will be stored in memory (defaults to 50mb) and on disk. If you are hosting Next.js using a container orchestration platform like Kubernetes, each pod will have a copy of the cache. <strong>To prevent stale data from being shown since the cache is not shared between pods by default, you can configure the Next.js cache to provide a cache handler and disable in-memory caching.</strong></p>
</blockquote>
<p>The issue of stale data is trickier than it seems. For example, as each node has its own cache, if you use <a href="https://nextjs.org/docs/app/api-reference/functions/revalidatePath"><code>revalidatePath</code></a> in your server action or route handler code, that code would run on just one of your nodes that happens to process that action/route, and only purge the cache for that node.</p>
<p>The docs provide a very high-level overview of how to implement this yourself with a custom <code>CacheHandler</code> implementation. A custom cache handler must concern itself with multiple types of cache entries (page, route, fetch, image, redirect) with separate logic for each, normalize cache keys to and from its backing store, handle on-demand revalidation, handle cache tags, parse and handle various undocumented build manifest files, handle a multitude of edge cases, and more.</p>
<p>Since Next.js is a major framework with wide adoption, we’re committed to fully supporting it — meaning that our engineering team that’s dedicated to frameworks support on our platform has built up the necessary knowledge and implemented our own cache handler and associated tests. If something changes in an upcoming canary version, we find out promptly.</p>
<p>The challenges described above mean that a disproportionate amount of this team’s time could easily be spent on Next.js. Fortunately, we’re using our own <a href="https://docs.netlify.com/platform/primitives/">platform primitives</a> as much as possible, building on robust features (and iterating on this as necessary) instead of tailoring framework-specific solutions for every requirement.</p>
<h3 id="you-should-be-able-to-pull-this-off-too">You should be able to pull this off too</h3>
<p>Even with using our own existing capabilities as much as possible, Netlify’s cache handler is ~500 lines of code and ~500 lines of tests — far from trivial. This type of investment is out of reach for most developers considering self-hosting.</p>
<p>Since Next.js abstracts much of these runtime details, there is a strong need to extend the adapter concept to support not just build-time concerns. For example, the <code>CacheHandler</code> interface for platforms should probably be re-imagined to require the least amount of framework logic (which is always subject to change) on the platform side.</p>
<p>This is currently beyond the scope of the build-time adapter discussed between the OpenNext group and Vercel, but we’re optimistic that this increased collaboration in a shared forum will lead to better, easier, simpler, documented deployment options for Next.js developers.</p>
<h2 id="challenge-3-undocumented-behaviors">Challenge #3: Undocumented behaviors</h2>
<p>The Next.js framework <a href="https://github.com/search?q=repo%3Avercel%2Fnext.js+undocumented&amp;type=issues">contains a number of undocumented options, features and behaviors</a>. For the platforms to reach feature parity with Vercel, platform vendors currently need to learn about these and take them into account.</p>
<p>For example, Next.js sites deployed to Vercel exercise their own unique Next.js code paths, opted into via the undocumented <code>minimalMode</code>. This disables many of the framework’s core features, which are then presumably reimplemented within the Vercel platform (which is naturally closed-source). Though Netlify does not, some providers have even chosen to leverage this undocumented mode and have reverse-engineered equivalent functionality into their own platforms.</p>
<h3 id="how-we-approach-it-proactive-automated-testing">How we approach it: proactive automated testing</h3>
<p>Our Next.js Adapter contains an extensive battery of hundreds of tests that we run against Next.js 13, 14, 15, and the latest canary release, all on Linux, macOS, and Windows. Most of these are integration tests that build and run a Next.js site fixture, and many of these are end-to-end tests that deploy the test site to Netlify.</p>
<p>Of course, these are just table stakes. In addition, for each Next.js version we test against, we also clone the source Next.js git repository and run its over 1700 end-to-end integration tests, adjusted to deploy to Netlify. These tests are <em>very extensive</em> and as they are testing through the entire, real experience via Playwright tests running in a browser like a user, these give us very high confidence to ship changes.</p>
<p>We then run this suite of tests daily, generate a report (<a href="https://runtime-e2e-report.netlify.app/">available publicly</a>) which automatically includes annotations for known issues we’ve tracked on GitHub, and we proactively notify our Frameworks team of any new unknown issues.</p>
<p>This is especially valuable because it tests against not only stable Next.js releases but also “canary” pre-releases. By ensuring we conform to tests against the latest canary release, we’re able to incrementally add support for new features and handle upcoming breaking changes (to both documented and undocumented interfaces) before they’re announced and become generally available. This is really only necessary because of the lack of roadmap transparency and release predictability (see challenges #5 and #6 below).</p>
<h2 id="challenge-4-not-built-on-open-web-standards">Challenge #4: Not built on open web standards</h2>
<p>At the time of writing, the first four words on the <a href="https://remix.run/">Remix framework website</a> are “Focused on web standards”; <a href="https://astro.build/">Astro’s website</a> advertises “Zero Lock-in”; SvelteKit’s asks you to “learn web standards that work across environments.”</p>
<p>When using Incremental Static Regeneration (ISR), Next.js emits <code>Cache-Control</code> response headers containing invalid Stale-While-Revalidate (SWR) directives such as:</p>
<pre tabindex="0" data-language="plaintext"><code><span><span>Cache-Control: s-maxage=600, stale-while-revalidate</span></span></code></pre>
<p>whereas <a href="https://datatracker.ietf.org/doc/html/rfc5861#section-3">RFC 5861 requires a Time-To-Live value</a> such as:</p>
<pre tabindex="0" data-language="plaintext"><code><span><span>Cache-Control: s-maxage=600, stale-while-revalidate=60</span></span></code></pre>
<p>This might look like a minor headache, perhaps not worth mentioning here at all. But the impact of such a detail is that the invalid directive is silently ignored by many CDNs. Vendors must first detect that the problem even exists, and then either choose to support noncompliant headers for Next.js’ sake, or include code to transform that header in their Next.js glue code. And while it is now possible to opt into valid headers by default (see GitHub <a href="https://github.com/vercel/next.js/pull/52251">#52251</a>, <a href="https://github.com/vercel/next.js/pull/61330">#61330</a>, <a href="https://github.com/vercel/next.js/pull/65867">#65867</a>, and <a href="https://github.com/vercel/next.js/pull/65887">#65887</a>), this issue was ultimately <a href="https://github.com/vercel/next.js/issues/51823">closed</a> with non-standard headers still returned by default. This is just one example.</p>
<p>In addition, some Next.js features (e.g. ISR) are implemented with an ad hoc solution that is deeply integrated with functionality baked into the Vercel platform. In many of these cases, these features could alternatively be built on top of open web standards (e.g. standard <a href="https://developer.mozilla.org/en-US/docs/Web/API">Web APIs</a>) for greater portability. This concern, among others, prompted Kent C. Dodds to pen his thoughtful post <a href="https://www.epicweb.dev/why-i-wont-use-nextjs">“Why I won’t use Next.js”</a>.</p>
<h3 id="advocating-for-the-open-web">Advocating for the open web</h3>
<p>Netlify’s mission is to build a better web, together.</p>
<p>We strive to put this into practice by participating in working groups like <a href="https://wintercg.org/">WinterCG</a> (now WinterTC) and initiatives like <a href="https://opennext.js.org/">OpenNext</a>, drafting RFCs for <a href="https://github.com/withastro/roadmap/discussions/907">frameworks</a> and <a href="https://github.com/jamstack/jamstack.org/discussions/549">for the community at large</a>, providing a <a href="https://www.netlify.com/blog/introducing-the-netlify-frameworks-api/">stable, documented platform</a> for partners to build upon, implementing support for new platform standards and APIs as the web continually evolves, and generally advocating for the open web at every opportunity.</p>
<p>But to solve our immediate, concrete needs for Next.js, we needed something more:</p>
<h3 id="primitives-over-frameworks">Primitives over frameworks</h3>
<p>Kent Beck says “First make the change easy (this might be hard), then make the easy change.” In a way, this has been <a href="https://www.smashingmagazine.com/2024/05/netlify-platform-primitives/">our strategy over the last year</a>. Rather than solving for each new Next.js feature specifically, we aim to identify the underlying platform primitives that would make the feature easy to adopt — not only in Next.js but in any framework or even without one.</p>
<p>For example, rather than implement Next.js Incremental Static Regeneration (ISR) deep within our platform, we <a href="https://www.netlify.com/blog/swr-and-fine-grained-cache-control/">implemented support for the standard <code>Stale-While-Revalidate</code> directive and other advanced caching primitives</a> entirely through simple HTTP response headers. As a result, Next.js ISR is implemented in our Next.js Adapter with a few lines of code that simply set headers, and since all other SSR frameworks allow users to set headers this functionality became automatically available to those frameworks — or even <a href="https://developers.netlify.com/guides/advanced-caching-made-easy/">without any framework at all</a>.</p>
<h2 id="challenge-5-lack-of-roadmap-visibility">Challenge #5: Lack of roadmap visibility</h2>
<p>Most frameworks publish a public roadmap to keep developers, providers, and integration developers apprised of upcoming new features, deprecations, breaking changes, and so on. See for example: <a href="https://github.com/withastro/.github/blob/main/GOVERNANCE.md">Astro</a>, <a href="https://remix.run/docs/en/main/guides/contributing">Remix</a>, <a href="https://github.com/QwikDev/qwik-evolution">Qwik</a>, <a href="https://nuxt.com/docs/community/roadmap">Nuxt</a>, <a href="https://angular.dev/roadmap">Angular</a>, and minimal roadmaps such as <a href="https://github.com/vitejs/vite/milestones">Vite’s</a> and <a href="https://github.com/sveltejs/svelte/milestones">Svelte’s</a></p>
<p>Next.js has no public roadmap or otherwise equivalent transparency.</p>
<p>While developers have the luxury of choosing when to upgrade their sites, hosting providers and integration developers must meet the community’s expectation to support new releases ASAP.</p>
<p>In addition, most frameworks’ roadmaps tend to be collaborative exercises with input from its community.</p>
<p><a href="https://nextjs.org/governance">Next.js’s governance model</a> states that “large architectural decisions and features start as a <a href="https://github.com/vercel/next.js/discussions/categories/rfc">Request for Comments (RFC)</a>”. However, at the time of writing, only four community RFCs have been adopted in eight years, with only one non-Google contributor among those. Ideation, decisions, and roadmaps are all hidden behind closed doors and shared with the public twice yearly at Vercel Conf and Next.js Conf concomitantly with new releases.</p>
<p>In collaboration with the community (OpenNext members and others), going forward <strong>we are committing to proposing and contributing to Next.js RFCs</strong> to address some of these challenges laid out above, such as the above-mentioned build output adapter. Let’s build together!</p>
<h2 id="challenge-6-lack-of-release-predictability">Challenge #6: Lack of release predictability</h2>
<p>Most frameworks either update their public roadmap regularly (see above), announce upcoming changes publicly as progress is made (e.g. <a href="https://nuxt.com/docs/getting-started/upgrade#testing-nuxt-4">Nuxt</a>), or adhere to a fixed release schedule (e.g. <a href="https://angular.dev/reference/releases#release-frequency">Angular</a>).</p>
<p>None of these is the case for Next.js. Developers, hosting providers, integration developers, and the community at large are left to speculate and read between the lines.</p>
<p>For example, <a href="https://nextjs.org/blog/next-15-rc">a Next.js 15 Release Candidate was announced in May</a>, but no updates were shared between then and <a href="https://nextjs.org/blog/next-15-rc2">the next Release Candidate five months later</a> (followed <a href="https://nextjs.org/blog/next-15">days later by Next.js 15 stable</a>), other than what can be gleaned from inspecting the 2,254 commits to the <code>canary</code> branch in between.</p>
<h3 id="how-we-track-nextjs-releases-and-prereleases">How we track Next.js releases and prereleases</h3>
<p>We watch Next.js PRs and releases like hawks. In fact, we were spending so much time doing this that we <a href="https://github.com/netlify/nextjs-sentinel">built a little service to automate the grunt work</a>.</p>
<p>Be assured there are teams resorting to the same thing at Cloudflare, AWS Amplify Hosting, SST, Google Firebase App Hosting, Microsoft Azure Static Web Apps, and more.</p>
<p>Fortunately, thanks to Vercel’s outreach, we’ve established lines of communication with the Next.js team. With this in place we hope to gain better insights into upcoming changes to the framework.</p>
<h2 id="looking-forward">Looking forward</h2>
<p>Let’s summarize where we are, and the concrete steps taken:</p>
<p>First, we’re committing to collaborating with other providers, with the community, and with the Next.js team. We all share a common goal of providing great experiences for Next.js developers and their sites’ visitors. That is why we <a href="https://www.netlify.com/blog/netlify-joins-opennext/">joined the OpenNext initiative</a> along with the SST and Cloudflare teams.</p>
<p>Second, thanks to outreach from engineers at Vercel, this has already led to the creation of direct lines of communication with the Next.js core team. We are optimistic that this will help us address challenges at the source.</p>
<p>Third — actions speak louder than words — per the <a href="https://nextjs.org/governance#roadmap-and-rfc-process">documented Next.js governance model</a>, we will begin drafting RFCs in collaboration with other providers to address some of these challenges. This is already in motion.</p>
<p>We’re looking forward to building a better web, together.</p> </div>  </article> </div> </div></div>
  </body>
</html>
