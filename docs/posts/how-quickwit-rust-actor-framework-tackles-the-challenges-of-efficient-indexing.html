<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://quickwit.io/blog/quickwit-actor-framework/">Original</a>
    <h1>How Quickwit Rust Actor Framework tackles the challenges of efficient indexing</h1>
    
    <div id="readability-page-1" class="page"><div><center><img loading="lazy" src="https://quickwit.io/img/blog/actor-framework-illustration.png" alt="Ferris &amp; co coordinating a choregraphy." width="100%"/></center><p>At Quickwit, we are building the most cost-efficient search engine for logs and traces. Such an engine typically ingests massive amounts of data while serving a comparatively low number of search queries. Under this workload, most of your CPU is spent on indexing, making our indexing pipeline a crucial component.</p><p>Like most search engines like Elasticsearch or Solr, Quickwit builds its inverted index in small batches.
The indexing pipeline’s role is to receive a continuous stream of documents, cut it into batches of typically 30s, and perform a sequence of operations to produce an new piece of the index we call split.</p><p><img loading="lazy" alt="pipeline-simplified.png" src="https://quickwit.io/assets/images/pipeline-simplified-0dfb83c9754e06f03ee4738be660cb90.png" width="1374" height="307"/></p><p>This component is full of fascinating engineering challenges:</p><ul><li>It should be efficient. In practice, this means the whole pipeline should be carefully streamlined to make sure we do not waste CPU while waiting for another resource.</li><li>The pipeline should be robust and have a clear and simple way to handle errors.</li><li>The code needs to be easy to test, navigate, and maintain.</li></ul><p>In this article, we delve into how we ended up adopting an actor model base solution for our indexing pipeline and discuss some of the distinctive features of our implementation. <a href="https://twitter.com/fulmicoton" target="_blank" rel="noopener noreferrer">Paul Masurel</a> one of our co-founders also gave a talk on this topic at <a href="https://fosdem.org/2023/schedule/event/building_an_actor_library_for_quickwits_indexing_pipeline/" target="_blank" rel="noopener noreferrer">FOSDEM23</a>.</p><p>First, let’s crack open the indexing pipeline box and briefly describe what it does. The following is a summary of the steps involved in the indexing pipeline.
Each steps is annotated with the resource it consumes.</p><ul><li>Parse and transform documents. (<code>CPU</code>)</li><li>Index JSON documents in an in-memory index. (<code>CPU</code>)</li><li>Trigger the end of the split according to <code>commit_timeout_secs</code> or <code>split_num_docs_target</code>. This step is what breaks the stream into batches.  (<code>CPU</code>, <code>Disk IO</code>)</li><li>Compress and serializes the in-memory split to the disk. (<code>CPU</code>, <code>Disk IO</code>)</li><li>Stage the split. (We need to record the split before starting the upload to be able to clean up on failures. (<code>Wait for Metastore</code>)</li><li>Upload the split to the target storage (Local FS, Object storage). (<code>Disk IO</code> or <code>Network</code>)</li><li>Publish the split to make it available for search queries.  (<code>Wait for Metastore</code>)</li></ul><p>As you can see, a document needs to go through a bunch of steps before it can be searchable. A naive implementation would run all of these steps sequentially.</p><div><div><pre tabindex="0"><code><span><span></span><br/></span><span><span></span><span></span><br/></span><span><span></span><span>let</span><span> active_split </span><span>=</span><span> </span><span>ingest_enougth_docs_to_make_split</span><span>(</span><span>)</span><span>;</span><span></span><br/></span><span><span></span><br/></span><span><span></span><span></span><br/></span><span><span></span><span>let</span><span> serialized_split </span><span>=</span><span> </span><span>save_split</span><span>(</span><span>active_split</span><span>,</span><span> local_working_directory</span><span>)</span><span>;</span><span></span><br/></span><span><span></span><br/></span><span><span></span><span></span><br/></span><span><span></span><span>let</span><span> split_metadata </span><span>=</span><span> serialized_split</span><span>.</span><span>metadata</span><span>(</span><span>)</span><span>;</span><span></span><br/></span><span><span></span><span>stage_split</span><span>(</span><span>&amp;</span><span>split_metadata</span><span>,</span><span> metastore</span><span>)</span><span>;</span><span></span><br/></span><span><span></span><br/></span><span><span></span><span></span><br/></span><span><span></span><span>upload_split</span><span>(</span><span>serialized_split</span><span>,</span><span> storage</span><span>)</span><span>;</span><span></span><br/></span><span><span></span><br/></span><span><span></span><span></span><br/></span><span><span></span><span>publish_split</span><span>(</span><span>split_metadata</span><span>.</span><span>split_id</span><span>,</span><span> metastore</span><span>)</span><span>;</span><br/></span></code></pre></div></div><p>However, we saw that these steps are operating on different resources: CPU, disk, network, and sometimes we are simply waiting for another service&#39;s response. Simply running these steps one after the other is a waste of resources. For instance, our CPU would be idle while we are writing our split to disk. We need to run these steps concurrently in order to get the most out of the available computing resources. We can achieve this by dedicating workers to each step and streamlining our pipeline.</p><p>Now, if a worker cannot keep up with the incoming tasks, it will accumulate them in its work queue, and eventually crash the system. This calls for some backpressure mechanism where we set a maximum number of items that can be held in a worker’s backlog. When that maximum is reached, all workers attempting to send a job to it will have to wait, thus slowing down and allowing the lagging worker to catch up.</p><p>In Rust, bounded mpsc (multiple-producer-single-consumer) channels are a natural solution for this task queue. Here is what such a worker might look like:</p><div><div><pre tabindex="0"><code><span><span>use</span><span> </span><span>tokio</span><span>::</span><span>sync</span><span>::</span><span>mpsc</span><span>::</span><span>*</span><span>;</span><span></span><br/></span><span><span></span><br/></span><span><span></span><span>struct</span><span> </span><span>Split</span><span> </span><span>{</span><span> </span><span> </span><span>}</span><span></span><br/></span><span><span></span><br/></span><span><span></span><span>fn</span><span> </span><span>start_worker</span><span>(</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>io</span><span>::</span><span>Result</span><span>&lt;</span><span>Sender</span><span>&lt;</span><span>Split</span><span>&gt;&gt;</span><span> </span><span>{</span><span></span><br/></span><span><span>    </span><span></span><br/></span><span><span>    </span><span>let</span><span> </span><span>(</span><span>tx</span><span>,</span><span> </span><span>mut</span><span> rx</span><span>)</span><span> </span><span>=</span><span> </span><span>channel</span><span>::</span><span>&lt;</span><span>Split</span><span>&gt;</span><span>(</span><span>3</span><span>)</span><span>;</span><span></span><br/></span><span><span>    </span><span>tokio</span><span>::</span><span>task</span><span>::</span><span>spawn</span><span>(</span><span>async</span><span> </span><span>move</span><span> </span><span>{</span><span> </span><span></span><br/></span><span><span>        </span><span>for</span><span> split </span><span>in</span><span> rx</span><span>.</span><span>recv</span><span>(</span><span>)</span><span>.</span><span>await</span><span> </span><span>{</span><span></span><br/></span><span><span>            </span><span>process_upload</span><span>(</span><span>split</span><span>)</span><span>.</span><span>await</span><span>?</span><span>;</span><span></span><br/></span><span><span>        </span><span>}</span><span></span><br/></span><span><span>        </span><span>io</span><span>::</span><span>Result</span><span>::</span><span>Ok</span><span>(</span><span>(</span><span>)</span><span>)</span><span></span><br/></span><span><span>    </span><span>}</span><span>)</span><span>;</span><span></span><br/></span><span><span>    </span><span>Ok</span><span>(</span><span>tx</span><span>)</span><span></span><br/></span><span><span></span><span>}</span><br/></span></code></pre></div></div><p>It turns out this worker setup is what is conceptually called an actor.</p><p>As framed by <a href="https://en.wikipedia.org/wiki/Carl_Hewitt" target="_blank" rel="noopener noreferrer">Carl Hewitt</a> in 1973, an actor is a computational entity that, in response to a message it receives, can concurrently:</p><ul><li>send a finite number of messages to other actors;</li><li>create a finite number of new actors</li><li>designate the behavior to be used for the next message it receives.</li></ul><p>Before jumping into the specificity of our actor framework, We must recommend the blog post from <a href="https://www.linkedin.com/in/aliceryhl/" target="_blank" rel="noopener noreferrer">Alice Ryhl</a> titled <a href="https://ryhl.io/blog/actors-with-tokio/" target="_blank" rel="noopener noreferrer">Actors with Tokio</a> which shows how to use Actors in Tokio rust, as a programming pattern and without any framework.</p><p>Implementing an actor-based solution requires too much wiring to manage the actors themselves. We do not want to mix this with the application code. A few of the actor&#39;s management chores that need to be taken care of are:</p><ul><li>Monitor or supervise actors and restart them when they fail.</li><li>Monitor actors’ jobs and schedule retries if necessary.</li><li>Manage message scheduling including time and priority aspects.</li><li>Provide testing and observability utilities (ex. mocking time, performance metrics).</li></ul><p>Actor frameworks can be handy to abstract away these aspects.</p><p>We ended up implementing our own framework called <code>quickwit-actors</code>.
But why implement our own framework when there are a plethora of actor frameworks in the Rust ecosystem (<a href="https://actix.rs/docs/actix/actor" target="_blank" rel="noopener noreferrer">Actix</a>, <a href="https://github.com/rillrate-lab/meio" target="_blank" rel="noopener noreferrer">meio</a>, <a href="https://riker.rs/" target="_blank" rel="noopener noreferrer">riker</a> etc …)? We found that most available options except Actix were not actively maintained.</p><p>Our main issue with Actix was the lack of message priority. Our indexer, for instance, is in charge of cutting batches every 30 seconds or so. We want to be able to have a message processed as soon as possible after the 30 seconds have elapsed. In Actix and in quickwit-actors, this is done by asking the framework to send a message to our actor after 30 seconds has elapsed. In Actix, that message is enqueued, and will only be processed once all of the pending messages have been processed. In Quickwit, this could mean 10 seconds later for this specific actor. As a solution, in our actor framework, each actor has a high-priority and a low-priority queue. Scheduled messages are delivered to the high-priority queue.</p><p>Implementing our own framework also made it possible to bake in some precious features. Such as measuring and reporting backpressure as metrics, and automatically detecting actors that are blocked on some operation.</p><p>From a Rust developer perspective, you define your actor type and implement the <a href="https://github.com/quickwit-oss/quickwit/blob/main/quickwit/quickwit-actors/src/actor.rs#L108" target="_blank" rel="noopener noreferrer"><code>Actor</code></a> trait, which only requires one method to be implemented. Next, you implement the <a href="https://github.com/quickwit-oss/quickwit/blob/main/quickwit/quickwit-actors/src/actor.rs#L213" target="_blank" rel="noopener noreferrer"><code>Handler</code></a> trait which is generic over the Message type it should handle;</p><div><div><pre tabindex="0"><code><span><span>#[derive(Debug)]</span><span></span><br/></span><span><span></span><span>struct</span><span> </span><span>HealthCheckMessage</span><span>;</span><span></span><br/></span><span><span></span><br/></span><span><span></span><span>#[derive(Debug, Default)]</span><span></span><br/></span><span><span></span><span>struct</span><span> </span><span>HealthActor</span><span>(</span><span>usize</span><span>)</span><span>;</span><span></span><br/></span><span><span></span><br/></span><span><span></span><span>#[async_trait]</span><span></span><br/></span><span><span></span><span>impl</span><span> </span><span>Actor</span><span> </span><span>for</span><span> </span><span>HealthActor</span><span> </span><span>{</span><span></span><br/></span><span><span>    </span><span>type</span><span> </span><span>ObservableState</span><span> </span><span>=</span><span> </span><span>usize</span><span>;</span><span></span><br/></span><span><span></span><br/></span><span><span>    </span><span>fn</span><span> </span><span>observable_state</span><span>(</span><span>&amp;</span><span>self</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>Self</span><span>::</span><span>ObservableState</span><span> </span><span>{</span><span></span><br/></span><span><span>            </span><span>self</span><span>.</span><span>0</span><span></span><br/></span><span><span>    </span><span>}</span><span></span><br/></span><span><span></span><br/></span><span><span>    </span><span>async</span><span> </span><span>fn</span><span> </span><span>initialize</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>self</span><span>,</span><span> ctx</span><span>:</span><span> </span><span>&amp;</span><span>ActorContext</span><span>&lt;</span><span>Self</span><span>&gt;</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>Result</span><span>&lt;</span><span>(</span><span>)</span><span>,</span><span>ActorExitStatus</span><span>&gt;</span><span> </span><span>{</span><span></span><br/></span><span><span>        ctx</span><span>.</span><span>send_self_message</span><span>(</span><span>HealthCheckMessage</span><span>)</span><span>.</span><span>await</span><span>?</span><span>;</span><span></span><br/></span><span><span>        </span><span>Ok</span><span>(</span><span>(</span><span>)</span><span>)</span><span></span><br/></span><span><span>    </span><span>}</span><span></span><br/></span><span><span></span><span>}</span><span></span><br/></span><span><span></span><br/></span><span><span></span><span>impl</span><span> </span><span>Handler</span><span>&lt;</span><span>HealthCheckMessage</span><span>&gt;</span><span> </span><span>for</span><span> </span><span>HealthActor</span><span> </span><span>{</span><span></span><br/></span><span><span>    </span><span>type</span><span> </span><span>Reply</span><span> </span><span>=</span><span> </span><span>(</span><span>)</span><span>;</span><span></span><br/></span><span><span></span><br/></span><span><span>    </span><span>async</span><span> </span><span>fn</span><span> </span><span>handle</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>self</span><span>,</span><span> health_check_msg</span><span>:</span><span> </span><span>HealthCheckMessage</span><span>,</span><span> ctx</span><span>:</span><span> </span><span>&amp;</span><span>ActorContext</span><span>&lt;</span><span>Self</span><span>&gt;</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>ActorResult</span><span>&lt;</span><span>(</span><span>)</span><span>&gt;</span><span> </span><span>{</span><span></span><br/></span><span><span>        </span><span></span><br/></span><span><span>        </span><span>check_health_status</span><span>(</span><span>)</span><span>.</span><span>await</span><span>?</span><span>;</span><span></span><br/></span><span><span></span><br/></span><span><span>        </span><span></span><br/></span><span><span>        </span><span>self</span><span>.</span><span>0</span><span> </span><span>+=</span><span> </span><span>1</span><span>;</span><span></span><br/></span><span><span>        </span><span></span><br/></span><span><span>        ctx</span><span>.</span><span>schedule_self_msg</span><span>(</span><span>Duration</span><span>::</span><span>from_secs</span><span>(</span><span>2</span><span>)</span><span>,</span><span> </span><span>HealthCheckMessage</span><span>)</span><span>.</span><span>await</span><span>;</span><span></span><br/></span><span><span>        </span><span>Ok</span><span>(</span><span>(</span><span>)</span><span>)</span><span></span><br/></span><span><span>    </span><span>}</span><span></span><br/></span><span><span></span><span>}</span><span></span><br/></span><span><span></span><br/></span><span><span></span><span>#[tokio::main]</span><span></span><br/></span><span><span></span><span>async</span><span> </span><span>fn</span><span> </span><span>main</span><span>(</span><span>)</span><span> </span><span>{</span><span></span><br/></span><span><span>    </span><span></span><br/></span><span><span>    </span><span>let</span><span> universe </span><span>=</span><span> </span><span>Universe</span><span>::</span><span>new</span><span>(</span><span>)</span><span>;</span><span></span><br/></span><span><span></span><br/></span><span><span>        </span><span></span><br/></span><span><span>    </span><span>let</span><span> health_checker </span><span>=</span><span> </span><span>HealthActor</span><span>::</span><span>default</span><span>(</span><span>)</span><span>;</span><span></span><br/></span><span><span>    </span><span>let</span><span> </span><span>(</span><span>_health_checker_mailbox</span><span>,</span><span> health_checker_handle</span><span>)</span><span> </span><span>=</span><span> universe</span><br/></span><span><span>        </span><span>.</span><span>spawn_actor</span><span>(</span><span>health_checker</span><span>)</span><span></span><br/></span><span><span>        </span><span>.</span><span>spawn</span><span>(</span><span>)</span><span>;</span><span></span><br/></span><span><span></span><br/></span><span><span>    health_checker_handle</span><span>.</span><span>join</span><span>(</span><span>)</span><span>.</span><span>await</span><span>;</span><span></span><br/></span><span><span></span><span>}</span><br/></span></code></pre></div></div><p>The above is an actor that checks the health status of an imaginary service every two seconds and maintains a state that counts the number of checks it has performed since its inception. This actor sends the <code>HealthCheckMessage</code> to itself.</p><ul><li>First in the <code>initialize</code> method of the Actor trait: the method that is initially run when an actor starts.</li><li>Then in the <code>handle</code> method of the Handler trait, but this time with a two seconds delay. This creates an infinite loop of <code>HealthCheckMessage</code> handling.</li></ul><p>In <code>main</code>, we create a <code>Universe</code> for our actors to live in. When an actor is spawned, we get back two things:</p><ul><li>A type-safe <code>Mailbox</code> that can be used to send messages to the corresponding actor.</li><li>A handle that can be used to monitor as well as wait, quit, kill, pause, and resume the actor.</li></ul><p>All Quickwit actors are async by default. To deal with the CPU-intensive actors, we simply schedule them on a different runtime. This trick is also used by InfluxDB as exposed in this <a href="https://www.influxdata.com/blog/using-rustlangs-async-tokio-runtime-for-cpu-bound-tasks/" target="_blank" rel="noopener noreferrer">blog post</a>. Typically, <code>RuntimeType::Blocking.get_runtime_handle()</code> is used to request an actor to be scheduled as synchronous actor.</p><p>Because our actors can be running in different runtimes, we had to introduce the concept of Universe to isolate groups of actors within the same process. For instance, each unit test typically starts by instantiating its own universe. A universe holds:</p><ul><li>An <code>ActorRegistry</code> that keeps track of actors instantiated in this universe.</li><li>A universe’s <code>KillSwitch</code> to shut down all of the actors in this universe.</li><li>A <code>SchedulerClient</code> to handle and mock time.</li></ul><p>Another feature of the universe that’s handy when testing is the method <code>Universe::with_accelerated_time()</code>. It provides a universe that accelerates time whenever no actor has any message to process.</p><p><img loading="lazy" alt="schedule-compression.png" src="https://quickwit.io/assets/images/schedule-compression-93c869645dcdba91cc370ba6799b98a7.png" width="1569" height="489"/></p><p>Concretely, here is how we use the actor framework within the Quickwit indexer service: when JSON documents arrive in Quickwit via the <code>source</code> actor, they are parsed by the <code>doc-processor</code> and buffered in an in-memory split (<code>indexer</code> actor). When the <a href="https://quickwit.io/docs/configuration/index-config#indexing-settings" target="_blank" rel="noopener noreferrer"><code>commit_timeout_secs</code></a> has expired or the <a href="https://quickwit.io/docs/configuration/index-config#indexing-settings" target="_blank" rel="noopener noreferrer"><code>split_num_docs_target</code></a> is reached, a new active split is created to keep receiving ingested documents while the previous split is finalized in the subsequent actors before being marked as searchable by the <code>publisher</code>. You can also distinguish the indexing pipeline (purple group) for indexing documents from the merge pipeline (green group) for merging splits that are not matured yet.</p><p><img loading="lazy" alt="pipeline.png" src="https://quickwit.io/assets/images/pipeline-481879ee7ae887a51682b769bb7d79a2.png" width="1736" height="1116"/></p><p><code>quickwit-actors</code> has proven to be a valuable asset for Quickwit. Though it lacks many features and documentation, it provides us the flexibility to mold it into what we need.</p><p>We recently released <a href="https://github.com/quickwit-oss/quickwit/tree/main/quickwit/quickwit-actors" target="_blank" rel="noopener noreferrer">the framework</a> under the MIT Licensed. We don&#39;t really expect it to become a popular crate, but we hope the MIT License will make it easy for people to experiment with it and scrap whatever pieces of code they see fit.</p></div></div>
  </body>
</html>
